00:05:34 * shapr yawns
00:06:45 * Korollary throws The Gothenburg Times at shapr
00:06:59 <shapr> Korollary: Är du i Göteborg?
00:07:16 <Korollary> no, I am near San Francisco
00:07:25 <shapr> Dit dator namn ser ut som San Fran...
00:07:29 <shapr> Är du svensk?
00:07:41 <shapr> What the heck is hostname in Swedish?
00:07:47 <shapr> For some reason my lexicon doesn't have it.
00:07:51 <Pseudonym> Probably "hostname".
00:08:12 <shapr> Yeah, probably so. Or maybe hostnamn since namn is Swedish for name.
00:09:26 <shapr> Korollary: Are you Swedish?
00:09:37 <Korollary> no sir
00:10:05 <shapr> I don't think I'm old enough or respectable enough to be a Sir.
00:10:14 <Korollary> no, dude
00:10:48 <shapr> So are you a commercial user of Haskell?
00:11:06 <Korollary> no, I am not. I am the artist formerly known as "Gahhh", actually.
00:11:50 <Wed5963> morning
00:12:21 <Wed5963> bleh, van duits volkore tarwe-rogge word je niet blij
00:17:43 <shapr> Korollary: Oh!
00:17:52 <shapr> Wed5963: ik begrijp het niet!
00:18:08 <shapr> ik viet het niet
00:19:15 <Wed5963> ok i'll try and translate
00:19:26 <shapr> From Dutch folklore ?
00:19:51 <luqui> what is the best approach, given a list of [(x, y)], make all x's unique by adding together their corresponding y's
00:20:57 <Wed5963> i was late at the supermarket yesterday....so the only bread they had...was this dark german rye bread....which is like eating C4
00:21:05 <Wed5963> i can image
00:21:07 <Wed5963> imagine
00:21:09 <Wed5963> -image
00:21:24 <shapr> C4 is soft like playdough, German rye bread always seemed rather tough to me.
00:21:32 <Wed5963> ow right.,...
00:21:35 <Wed5963> let me think
00:21:58 <Wed5963> that stuff they use to keep the heat in your house
00:22:05 <Wed5963> but then dark black/brown
00:22:25 <shapr> luqui: I can think of several different approaches, but I'm trying to find the best approach.
00:22:40 <Wed5963> hey wait a minute
00:22:41 <luqui> thanks
00:22:58 <Wed5963> that exact question was asked here a while ago. It was some exercise on some university/school
00:23:02 <Wed5963> is that the case here :D
00:23:07 <Wed5963> it involved sorting and grouping
00:25:21 <luqui> also, can I implement two different versions of a function: one that works on values that are part of Eq, and another when they aren't
00:26:21 <luqui> I just want an operator that will return True when they are ==, and False when they aren't or can't be compared
00:26:57 <Wed5963> uhm...isnt like == already the operator that does that?
00:27:02 <Wed5963> or am i misunderstanding you
00:27:04 <luqui> oh, is it?
00:27:32 <luqui> nope
00:27:44 <luqui> (\x -> x) == (\y -> y)
00:27:49 <luqui> No instance for (Eq (t -> t))
00:27:52 <luqui> I want that to be "False"
00:28:03 <Wed5963> you want to do equality on functions?
00:28:07 <Wed5963> i misunderstood indeed
00:28:21 <luqui> I just want an equality that will be false whenever the two things aren't an instance of Eq
00:28:36 <luqui> I don't intend to do it on functions, it was just the quickest thing I could think of
00:29:01 <Wed5963> i dont know if it's possible to test for membership of a class
00:29:11 <dblhelix> perhaps something like (Bounded a, Eq b) => (a -> b) -> (a -> b) -> Bool?
00:29:20 <Pseudonym> instance Eq a where
00:29:23 <Pseudonym>     _ == _ = False
00:29:28 <luqui> AHA!
00:29:30 <Pseudonym> If you -fallow-overlapping-instances, that should work.
00:29:44 <luqui> oh..
00:29:48 <Pseudonym> But I consider it highly inadvisable.
00:29:59 <Wed5963> Pseudonym, wouldnt that like screw up the rest of Eq's functionality
00:30:00 <Wed5963> :D
00:30:02 <luqui> that wasn't quite what I though
00:30:06 <shapr> luqui: should be something roughly like: let schwarz = \(x1,_) (x2,_) -> compare x1 x2 in map foldr1 \(x1,y1) (x2,y2) -> (x1,y1 + y2) $ groupBy schwarz . sortBy schwarz $ pairs
00:30:10 <Pseudonym> No, it shouldn't.
00:30:20 <Pseudonym> -fallow-overlapping-instances is pretty smart.
00:30:24 <Wed5963> shapr, you can use arrows very beautifull here
00:30:31 <Pseudonym> However, this is better:
00:30:36 <Pseudonym> class MyEq a where
00:30:37 <shapr> Wed5963: Show me :-)
00:30:45 <Pseudonym>     (===) :: a -> a -> Bool
00:30:49 <dblhelix> it used the most informative instance and falls back on the hacky one if really cannot do any better
00:30:50 <Pseudonym>     _ === _ = False
00:30:55 <luqui> shapr: thanks.  I'll now begin the half-hour-long struggle of trying to understand it :-)
00:31:03 <luqui> but at least you pointed me in the right direction
00:31:05 <Pseudonym> instance (Eq a) => MyEq a where
00:31:13 <Pseudonym>     a === b = a == b
00:31:14 <Pseudonym> Or something
00:31:28 <Pseudonym> You still need to -fallow-overlapping-instances, but at least you won't stuff up Eq.
00:31:29 <Wed5963> shapr, im digging up the example
00:31:39 <Pseudonym> Hmmmm.
00:31:39 <luqui> but that only works on Eqs
00:31:43 <Pseudonym> Actually, that won't work either.
00:31:56 <Pseudonym> What you ACTUALLY need is that nifty typeclass from the HList paper.
00:32:05 <Pseudonym> TypeNotEq or something.
00:32:21 <Pseudonym> But you need it done properly.
00:32:38 <luqui> so the short answer is "you can't", I suppose
00:32:48 <Pseudonym> Right.
00:32:56 <Pseudonym> The long answer is "you shouldn't anyway".
00:34:22 <Cale> luqui: I might write that as: collect xs = Map.toList $ Map.fromListWith (+) xs
00:34:39 <Cale> luqui: (I like to abuse Data.Map :)
00:35:40 <luqui> fromListWith... that's what I was looking for
00:35:41 <luqui> thanks
00:35:46 <luqui> I can actually understand that one
00:37:21 <Wed5963> shapr, map ((head Control.Arrow.*** sum) . unzip) . List.groupBy eqFst . List.sortBy cmpFst
00:37:30 <Wed5963> shapr, map ((head *** sum) . unzip) . List.groupBy eqFst . List.sortBy cmpFst
00:37:33 <Wed5963> there
00:37:45 <Wed5963> ok so arrows are not heavily used here :P but still
00:38:05 <Pseudonym> Gotta go.  Nytol!
00:39:19 <Wed5963> map ((head *** sum) . unzip) . groupBy eqFst . sortBy cmpFst
00:39:24 <Wed5963> without all the qualifications
00:40:55 <shapr> Hm, that's a neat bit of code.
00:41:08 <shapr> I think I'll use Cale's Map abuse in the future though.
00:41:19 <Wed5963> Map abuse?
00:41:23 <mflux_> @index cmpFst
00:41:24 <lambdabot> bzzt
00:41:32 <Wed5963> mflux_, its not defined :D
00:41:44 <Wed5963> \(a,_) (b,_) -> compare a b
00:41:57 <shapr> (compare . fst) and (==) . fst
00:41:58 <mflux_> yeah, but it's something that would be use at times, and I rarely bother to define such things ;)
00:42:00 <shapr> er wait
00:42:26 <shapr> bah
00:42:33 <mflux_> I suppose I could just write a module to have all those functions for pairs
00:42:55 <mflux_> too bad tuples are difficult to manipulate in a generic way
00:43:15 <Wed5963> without generics indeed
00:43:22 <shapr> The arrow ops are handy with two tuples.
00:43:47 <Wed5963> true
00:44:22 <aleator> Again, my troubles with ffi continue. I wish to have a foreignPtr with finalizer and I have c-functions "X* makeX()" "void releaseX(X **o)". There must be a simple way of doing this?
00:45:44 <shapr> hiya Enveigler_
00:46:51 <Wed5963> whats that map abuse you were talking aboot shapr
00:47:02 <shapr> collect xs = Map.toList $ Map.fromListWith (+) xs
00:47:55 <Wed5963> ow thats creative too
00:47:58 <shapr> Has anyone done a bittorrent implementation in Haskell?
00:53:33 <dblhelix> shapr: afaik, you'll be the first to do so ;)
00:53:49 <dblhelix> can we have it by Monday or so? :)
00:53:50 <shapr> Probably not actually.
00:54:26 <dblhelix> ah, too bad
00:54:30 <Enveigler_> Morning shapr
00:54:40 <Wed5963> can you tell vim to substitute spaces for tabs whenever i press tab?
00:55:07 <shapr> dblhelix: I'm not the first - http://www.haskell.org/pipermail/haskell-cafe/2005-April/009641.html
00:55:23 <dblhelix> Wed5963: I don't know, but I know you can tell emacs
00:55:26 <dblhelix> :)
00:55:30 <Wed5963> ok thanks
00:55:34 <Wed5963> i'll work from there :P
00:56:44 <dblhelix> shapr: cool stuff
01:01:48 <shapr> Does anyone have an Arbitrary instance for Data.Map?
01:03:51 * shapr suspects not
01:04:04 <shapr> I should collect up my various Arbitrary instances and make a QuickCheckExts cabal package.
01:04:46 <shapr> Anyone else have any Arbitrary instances they want to contribute?
01:04:58 <shapr> CosmicRay: Do you have PreludeExts in MissingH?
01:15:07 <Wed5963> @hoogle escape
01:15:17 <Wed5963> @index escape
01:15:17 <lambdabot> bzzt
01:15:42 <Wed5963> @index escape_char
01:15:43 <lambdabot> bzzt
01:15:45 <Wed5963> @index escapechar
01:15:46 <lambdabot> bzzt
01:17:58 <Wed5963> @hugs Char.showLitChar '{' $ ""
01:17:59 <lambdabot> "{"
01:21:34 <Wed5963> @hugs '\\':'\\':[]
01:21:35 <lambdabot> "\\\\"
01:21:46 <Wed5963> @hugs '\':[]
01:21:47 <lambdabot> lexical error in string/character literal
01:21:56 <Wed5963> '\\':[]
01:22:06 <Wed5963> @hugs '\\':[]
01:22:08 <lambdabot> "\\"
01:24:33 <luqui> hmmm.. I suppose it's not possible to instantiate a class while adding a class restriction on one of the arguments of one of the methods
01:25:05 <luqui> instance Monad Foo where (>==) :: Ord a => ..
01:25:17 <luqui> er, >>=
01:25:37 <shapr> No, I wish it were.
01:25:49 <dblhelix> luqui: you're right, you can't do that
01:25:50 <luqui> darn
01:29:09 <shapr> I wish haskell-mode were smart enough to fill in all the constructors for a pattern matching function.
01:29:50 <Wed5963> i wish programs wrote themselver
01:30:00 <Wed5963> r=s
01:30:08 <shapr> They do, somewhat.
01:30:46 <luqui> what would it name them?
01:31:00 <luqui> the arguments to the constructors, that is
01:31:30 <shapr> luqui: first char of the constructor for unary, first char of the type for multiples
01:32:38 <luqui> fair enough
01:35:59 <Wed5963> @pl (\x y -> x:y:[])
01:36:00 <lambdabot> (. return) . (:)
01:36:07 <Wed5963> @pl (\x y -> [x,y])
01:36:08 <lambdabot> (. return) . (:)
01:36:17 <shapr> pointless is mucho fun
01:36:23 <Wed5963> indeed
01:36:50 <Wed5963> quit sick construction i might add :)
01:36:58 <Wed5963> didnt see that return coming
01:51:51 <shapr> QuickCheck immediately finds a bug in my BEncode.hs
01:56:23 <Wed5963> @hugs showString "sauer" . showString "kraut" $ ""
01:56:24 <lambdabot> "sauerkraut"
02:00:29 <takuan_> lol
02:06:33 <ulfdoz_> re
02:07:29 <Wed5963> is there something like (..) :: (c->d) -> (b ->c) -> (a->b)
02:07:39 <Wed5963> @hoolg e(c->d) -> (b ->c) -> (a->b)
02:07:40 <lambdabot> No matches, try a more general search
02:07:45 <Wed5963> @hoolge (c->d) -> (b ->c) -> (a->b)
02:07:46 <lambdabot> Prelude.asTypeOf :: (a -> a -> a)
02:07:46 <lambdabot> Prelude.(**) :: Floating a => (a -> a -> a)
02:07:46 <lambdabot> Prelude.logBase :: Floating a => (a -> a -> a)
02:07:49 <Wed5963> @hoogle (c->d) -> (b ->c) -> (a->b)
02:07:50 <lambdabot> Prelude.asTypeOf :: (a -> a -> a)
02:07:50 <lambdabot> Prelude.(**) :: Floating a => (a -> a -> a)
02:07:50 <lambdabot> Prelude.logBase :: Floating a => (a -> a -> a)
02:08:06 <shapr> Wed5963: I think you got your types confused.
02:09:10 <shapr> It looks like you want (.).
02:10:47 <musasabi> shapr: for the Data.Map case wouldn't it be simple to use instance Arbitary [(k,v)] => Arbitary (Map k v) ?
02:11:21 <musasabi> *Arbitrary
02:11:23 <shapr> Oh that would be simple.
02:11:33 <shapr> I did it in a slighly more complicated manner.
02:13:04 <shapr> Oh, actually I didn't.
02:13:47 <shapr> Well, not quite as elegant as yours, I have an extra class constraint: instance (Ord k, Arbitrary k, Arbitrary v) => Arbitrary (Map k v) where \n arbitrary = liftM fromList arbitrary
02:16:11 <Wed5963> ow right sorry, i wanted to add *another* function
02:16:13 <Wed5963> so three
02:16:57 <Wed5963> or actually an arbitrary amount
02:20:02 <shapr> If they have matching types you can fold (.) over a list of functions.
02:23:37 <_Codex> what's the (..) supposed to do?
02:25:13 <Wed5963> the problem is, that im getting an unknown amount of parameters. so if i get x y z, i want to do x . y . z.
02:25:30 <Wed5963> if i get a b c d e then i want to do a . b . c . d . e
02:25:49 <Wed5963> so i dont have that list and dont have a function to construct a list if i dont know the amount of parameters
02:26:50 <Wed5963> !pl
02:27:07 <_Codex> oh, you've hit the "what's the hidden type" problem with (.).
02:27:27 <Wed5963> is that so?
02:27:39 <Wed5963> is there a solution :P
02:28:23 <_Codex> tuples of functions and a typeclass with different instances for each tuple type.
02:29:14 <_Codex> you actually need to write different code for different amount of parameters.
02:31:07 <_Codex> probably something like this: instance Foo (a->b, b->c) where and then have f :: a->c function in the typeclass and implement it with f (f,g) = g . f or something.
02:31:25 <dblhelix> what would be a good name for a class C defined as
02:31:40 <dblhelix> class C f where toList :: f a -> [a]
02:31:41 <dblhelix> ?
02:33:30 <dblhelix> anybody??
02:34:07 <shapr> unfold?
02:34:34 <shapr> Have you read the Bananas, Lenses, Barbed Wire, etc paper?
02:34:52 <dblhelix> i have
02:34:58 <shapr> ok
02:39:52 * dblhelix mmm, for the time being I use class Term t where fv :: t x -> [x]
02:42:30 <kosmikus> Container?
02:43:45 <dblhelix> kosmikus: crossed my mind
02:53:44 <Wed5963> !np
02:54:28 <_Codex> n*p = p
02:54:49 <_Codex> => n = 1.
02:55:50 <vegai> n=p=0 ?
02:56:43 <_Codex> if p=0, then the whole thing is useless.
02:57:39 <vegai> then by tautology, p must be 0
02:58:50 <ski> shapr,luqui : possibly one could have more restricted types for class members with something like http://repetae.net/john/recent/out/supertyping.html
03:09:54 <_Codex> subsets have known problems; getting back lost elements is difficult once there is more users for the set.
03:12:05 <Wed5963> @hugs id.id $ 's'
03:12:07 <lambdabot> 's'
03:13:16 <ski> is @hugs synonym for @eval ?
03:15:57 <Wed5963> no idea, just couldnt remember eval, so i used hugs :D
03:16:58 <ski> _Codex : subsets ?
03:17:03 <ski> ok
03:17:30 <ski> @help eval
03:17:30 <lambdabot>  @eval <expr>
03:17:30 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
03:17:34 <ski> @help hugs
03:17:35 <lambdabot>  @help <command> - ask for help for <command>
03:17:47 <ski> bah
03:18:04 <dons> there is no 'hugs' command
03:18:22 <dons>  @hugs gets spelling corrected to @plugs which is a synonym for @eval
03:18:34 <ski> aha
03:18:38 <ski> heh
03:19:15 <_Codex> ski: was thinking of the supertypes thing: that the new class need to have only subset of the parent class' functions.
03:19:22 <Wed5963> @ghci id.id 3
03:19:23 <lambdabot>  WARNING: SE CAFs unsupported, forcing UPD instead
03:19:30 <shapr> My BEncode module works well enough to parse torrent files, now to make some useful records.
03:19:33 <Wed5963> @ghci id.id $ 3
03:19:34 <lambdabot>  Info table already?
03:20:16 <Wed5963> @ghci return
03:20:17 <lambdabot>  WARNING: SE CAFs unsupported, forcing UPD instead
03:20:34 <Wed5963> @ghci 3 + 3
03:20:35 <lambdabot>  Use -fallow-incoherent-instances
03:20:45 <Wed5963> this is useful
03:20:48 <smott> it gives random error messages, use @eval
03:20:49 <shapr> I didn't know GHC had UPDs as well.
03:21:49 <Wed5963> @ghci 3 + 3
03:21:50 <lambdabot>  Exotic pattern inside meta brackets
03:21:51 <Wed5963> @ghci 3 + 3
03:21:52 <lambdabot>  On Alpha, I can only handle 4 non-floating-point arguments to
03:21:52 <lambdabot> foreign export dynamic
03:21:54 <Wed5963> @ghci 3 + 3
03:21:55 <lambdabot>  For basic information, try the `--help' option.
03:22:15 <shapr> @ghc
03:22:16 <lambdabot>  GHC stage restriction
03:22:22 <shapr> @quote
03:22:24 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr.
03:22:24 <lambdabot> kahl didn't teach us in 3e03
03:23:26 <reffie> good morning
03:23:30 <shapr> Oh hey, I found a few options that don't work with GHC, should I just report those as bugs?
03:23:38 <shapr> y0 reffie
03:23:44 <Wed5963> man... there's this tiny bright side to C that dr. kaal didn't teach us in 3^2
03:25:41 <ski> _Codex : mhm, you mean adding some new class in between is hard ?
03:29:12 <ski> (_Codex : anyway, i was thinking of a refinement of JohnMeacham's proposal, in which one can not only restrict by removing members, but also by restricting types of members to more specific instances (such as adding a class constraint, e.g.))
03:29:21 <_Codex> I mean, if you happen to make subset class which "hides" two functions from the typeclass, then the situation when you want one of them back is going to be difficult situation.
03:30:11 <ski> of course you must choose wisely what member functions to remove
03:31:09 <ski> because if you remove one, and later want to add it again (i.e. not remove it), someone might already have made an instance that can't be adapted to define that member in a sensible way ..
03:31:39 <luqui> ski, thanks
03:31:53 <ski> _Codex : hm, have you programmed in a language with this kind of feature ?  (page says Sather)
03:31:55 <luqui> doesn't solve my particular problem, but it gave me the inspiration to write up something about perl 6
03:32:09 <ski> hehe, ok
03:32:20 <_Codex> yes, that's the problem: when you have too many functions using the typeclass as constraint and at the same time too many instances (or restrictions in the instances) that they cannot be ported to implement the new functions.
03:32:31 <nothingmuch> why do arrows have a brain melting reputation that is worse than monads?
03:32:49 <shapr> I don't know, there's no good reason really.
03:32:50 <Philippa> because if you've barely understood monads you won't get arrows at all
03:33:00 <ski> _Codex : so possibly, you really want to add a new class in between in that case ?
03:35:18 <_Codex> well, the supertypes do decrease the amount of instances you need to write, in cases where you really want to hide existing functions. (rewriting all instances to get different name for the class is no good either :-)
03:35:58 <ski> _Codex : in the case one has made the mistake of "forgetting" one member might belong to the restricted interface, it's worse. so one must change interfaces and break code ..
03:36:48 <ski> hm
03:37:27 <ski> 'decrease' ? should it be 'increase' ?
03:37:44 <_Codex> no. That's a benefit of them.
03:37:46 <ski> generally, with weaker class, more types can be made instances, i think
03:38:17 <_Codex> Yes, but you dont need to rewrite the instances of the parent class; they are automatically included.
03:38:54 <_Codex> (at least according to the url above)
03:39:01 <ski> hm, but what do you mean by the "rewriting ..." bit ?
03:39:43 <_Codex> I mean, without supertypes, you would probably just need to create new typeclass manually and write new instances for it (which look pretty much like Num instances :-)
03:39:44 <ski> hm, this reminds me of sometimes i've wanted to, in one class, provide defaults of methods in superclasses ..
03:39:56 * arjanb wonders if the standard dictionary translation could work with superclasses
03:40:34 <_Codex> though, I'm not sure how the proposal planned to allow you to modify the automatically generated instance-set...
03:40:35 <ski> _Codex : ya, ok
03:40:58 <ski> _Codex : iiuc, it didn't plan anything such
03:41:08 <_Codex> oh
03:41:26 <ski> (which doesn't necessarily hinder adding some mechanism for that)
03:41:50 <ski> though, i think it's not clear if that is a good idea
03:42:24 <ski> (if by 'modify' you mean changing some method implementation, after restricting away some other methods)
03:42:58 <_Codex> yes, subset implementation might allow you to do some optimizations or somesuch for the implementations.
03:43:49 <ski> imo, we want the semantics to be the same as having the added restricted class as a base class, and deriving the full class from that
03:44:00 <_Codex> if the instance does not need to support that many functions, the implementation might be able to use some shortcuts that are not available with all the functions.
03:44:17 <ski> only, we don't want to actually make that change to the source code, we just want the same effect
03:44:20 <_Codex> yes.
03:45:13 <ski> so,i think, e.g. restricting Num to Group, and changing the implementation of e.g. (+) in Group for some instances would not be safe
03:46:03 <ski> (as it could possibly give different results than deriving Num from Group could give ..)
03:46:49 <ski> (arjanb : i don't know)
03:47:37 <ski> _Codex : yes (re optimisation), that could possibly be possible
03:49:03 <_Codex> ski: I'm thinking it as same situation as when you've not imported all functions from a module. Isn't the module import / function hiding mechanism exactly the same thing?
03:49:22 * ski has thought a little on 'restriction'-based generation of new types, in conjuction with sub-/super-typing of record/variant types, earlier
03:49:48 <ski> _Codex : i guess it could be seen as similar, in some ways
03:50:56 <ski> though, a module has only "instance", which classes can have many  (we don't have an ML-like module system with explicit signatures/module types)
03:51:05 <ski> s/which/while/
03:51:54 <_Codex> (I'm actually thinking it as the same situation than when you don't know all "diagrams" from a category - you only have subset of the morphisms available. )
03:54:49 <_Codex> but would that mean that you would only have subset of the instances available too? :-)
03:54:57 <_Codex> or types.
03:54:57 <Enveigler_> How long is the delay between this channel and the archive becoming available?
03:56:08 <ski> Enveigler_ : archive ?
03:56:42 <ski> _Codex : explain more ?
03:57:50 <_Codex> ski: same situation in modules: if you didn't import the module, you cannot see the functions in it. The functions were hidden. (but their implementation is still the same). You only had access to subset of all functions available in the system.
03:58:25 <Enveigler_> ski: The logs (http://meme.b9.com/cview.html?channel=haskell&date=today). I was interested in a conversation earlier but got cut off and missed the solution, but it hasn't show up in the backlog yet.
03:59:47 <jyp> it looks like there are problems with logging
03:59:50 <arjanb> the logs at http://tunes.org/~nef/logs/haskell/ don't have a delay
04:00:07 <jyp> normally  there's no delay on meme either
04:01:05 <ski> _Codex : ok
04:02:02 <ski> and you mean this would be somewhat similar to sub-typeclass for some instance ?
04:02:15 <_Codex> ski: instances just overload the same functions; so they are pretty much independent of the hiding mechanism (or supertyping/restriction thign.). But the key is that "is hiding a function" the only primitive to use, or is there something else, like how to change implementation. The instance-set's name obviously changes so that adding new instances becomes possible without modifying the original instance-set of the original class.
04:02:18 <Enveigler_> arjanb: Thanks. That's got what I was looking for.
04:02:32 <dcoutts> musasabi, sorry, I seemed to go on a bit of a rant about the "Prop" thing in my email! sorry abaout that :-)
04:03:10 <Enveigler_> dcoutts: Damned impressive documentation with gtk2hs.
04:04:57 <_Codex> ski: probably the intention there is to reuse the function names (+) etc without touching library code. But the mechanism they chose looks like it's just hiding mechanism with instance-set renaming twist :-)
04:06:30 <dcoutts> Enveigler_, oh glad you think so, it was a gap in the market for Haskell GUI libs we thought :-)
04:07:15 <dcoutts> we put quite a bit of time into generating it from the C docs and then "Haskellising" it
04:08:42 <_Codex> There might be other ways it could work, like allowing changes to parameter/return types so that the functions get more specific. ie. f: a->a changes to f: Monad m => (m a)->(m a) or something strange like that :-) (would that still be subset? :)
04:09:11 <Enveigler_> I've been reading those for both Perl and Ocaml and the originals and yours are the easiest to navigate and (within my ability to understand them) the most detailed (yet concise) information. Really impressive!
04:09:20 <ski> _Codex : hm, sorry, i seem to have trouble understanding what you're after ..
04:10:03 <ski> _Codex : yes, that's more or less what i suggested, i.e. one can not only restrict by removing members, but also by changing member type signatures into more specific ones :)
04:10:13 <_Codex> ski: I'm just thinking how its supposed to work.
04:10:23 <dcoutts> Enveigler_, well that's also thanks to JaffaCake and his excelent haddock documentation tool (which produces such nice looking output)
04:11:18 <ski> _Codex : as to whether it would still be subset, i guess it depends on what you mean by 'subset'  ..  but i guess i think it's more or less irrelevant whether it's or not :)
04:11:27 * JaffaCake grins
04:12:18 <dcoutts> JaffaCake, now all we want is a haddock 0.7 release :-)
04:13:01 <dcoutts> sorry, as if you didn't alreay have enought to do! Who else maintains haddock, perhaps we could prod them...
04:13:34 <_Codex> ski: what about more relaxed constraints in the implementation: if parent requires f :: Num a => a -> a, then supertype might require just f :: Group a => a -> a? is that still valid?
04:15:09 <ski> hm
04:15:30 <ski> 'parent' being ?
04:15:38 <_Codex> Num
04:15:48 <_Codex> in the typeclass.
04:15:50 * ski would call it child :)
04:15:55 <Lor> Anyone coming to ICFP?
04:16:11 * Lor would like to share a room with someone.
04:16:19 <ski> _Codex : i think so
04:16:48 <Enveigler_> Great work both of you. (Now the question :)
04:17:21 <ski> if we have  class Foo a where f :: Num b => ..a..b..   then we should be able to make a restricted  class Foo a <= Bar a where f :: Group b => ..a..b..
04:17:45 <ski> _Codex : was that what you meant ?
04:17:48 <_Codex> ski: yes.
04:17:52 <Enveigler_> When marshalling binary data, I am using word16, but the data is signed. How do I get Haskell to treat the marshalled data correctly?
04:18:02 <ski> _Codex : or wait ..
04:18:03 <ski> hm
04:18:21 <dcoutts> Enveigler_, use Int16 for signed data, Word16 for unsigned
04:18:34 <Enveigler_> D'oh!
04:18:38 <dcoutts> they're also available at 8,16,32 adn 54
04:18:38 <Enveigler_> Thanks.
04:18:44 * ski tries to think again
04:18:46 <dcoutts> 64 (not 54)
04:19:05 <_Codex> ski: the direction of the subtype is probably important there. It only works in one way. (and might work differently for parameters and return types :-)
04:20:05 <ski> _Codex : hm, basically, a subclass has more methods, which means, more restrictions, so a superclass has less restrictions
04:20:24 <ski> _Codex : i'm becoming confused by you talking about subtypes and supertypes :)
04:20:45 <_Codex> sorry about that.  :-)
04:21:14 <ski> _Codex : so, an type that manages to instance a subclass, should automatically manage to instance all superclasses
04:21:30 <ski> _Codex : now, what does this mean, here ? ..
04:22:00 <ski> _Codex : if we have a member with some type signature
04:22:16 <ski> then, we can imagine a more restricted form of that type signature
04:22:34 <ski> 'restricted', as in, 'automatically usable'
04:22:52 <ski> such as [Int] -> [Int] is a restriction of [a] -> [a], e.g.
04:23:41 <ski> so, let's take 'f :: Group b => ..a..b..', is that a restriction of 'f :: Num b => ..a..b..' ?
04:23:45 <ski> esap : hi
04:23:49 <esap> ski: hi
04:24:22 <_Codex> ski: Num requires more implementation.
04:24:44 <ski> _Codex : i guess it depends on whether 'b' occurs co- or contra-variantly in '..a..b..' ..
04:25:09 <ski> hm
04:25:15 <ski> (or maybe i'm mistaken)
04:25:20 <_Codex> yes, that's exactly what I was thinking.
04:25:32 <ski> we need some better/more conrete example :)
04:25:54 <_Codex> what about just 10 :: Integer? :)
04:26:40 <_Codex> return values for functions would probably work the same way as "10" value would work.
04:26:48 <ski> esap : i recalled later that i constructed the Monad Stream instance by noting that Stream a ~= Nat -> a  and that this is an environment monad (so it uses the copy/discard comoniod)
04:27:30 <ski> hm
04:28:23 <ski> class Foo f where genericLength :: Integral b => f a -> b    ?
04:28:27 <esap> ski: ok
04:28:49 <ski> class Foo f <= Bar f where genericLength :: f a -> Integer
04:28:57 <ski> _Codex : hm, is this a good example ?
04:29:01 <_Codex> yes
04:29:52 <ski> obviously, all existing instances of Foo can be automatically made instances of Bar, by restricting the typesignature, by setting b = Integer
04:30:03 <ski> so it's safe
04:31:08 <JaffaCake> dcoutts: yes, haddock 0.7 is on my queue... there aren't any other maintainers (but volunteers are welcome)
04:31:14 <_Codex> Yes. That one is safe.
04:31:27 <ski> (esap : this should hopefully give you better intuition and explain implementation, for the stream monad instance)
04:31:37 <ski> so, this is the covariant case
04:31:41 <ski> now, contra ?
04:31:46 <Lor> No icfp'ers?
04:32:28 <ski> class Foo2 f where genericTake :: Integral b => b -> f a -> f a    ?
04:32:37 <Igloo> JaffaCake: I vaguely remember some work on making it hugs/nhc98 friendly. Will 0.7 be able to be built by them out of the box? (that would really make my life easier)
04:32:47 <ski> class Foo2 f <= Bar2 f where genericTake :: Integer -> f a -> f a
04:32:49 <arjanb> ski: in that case a default implementation in Bar isn't valid for Foo
04:32:52 <esap> ski: well I suppose it will once I read about the connection between linear logic and the copy/discard comonad.
04:33:13 <JaffaCake> Igloo: actually, I don't know
04:33:28 <Igloo> Heh, OK  :-)
04:33:43 <ski> esap : i think you don't need to understand that, to just understand the monad instance
04:33:50 <Wed5963> guess your life is bound to be difficult Igloo
04:33:57 <ski> (esap : s/comonad/comonoid/)
04:34:10 <ski> arjanb : hm, explain ?
04:34:25 <esap> ski: oh ok :-)
04:35:46 <ski> arjanb : in the first or second example ?
04:36:06 * ski hasn't yet considered interaction with default impls
04:36:41 <arjanb> in the genericLength example but maybe i'm confused now too
04:36:46 <ski> (also, allowing restricting type signatures, would suggest allowing making type signatures less restricted, when deriving a new subclass)
04:40:05 <ski> arjanb : with the proposed system (with just removing members), i haven't seen anything about default impls at all
04:40:43 <ski> so, my first (easiest) idea would be to not allow stating default impls in the restricted superclass at all
04:40:44 <arjanb> hmm true
04:40:55 <ski> this might be too draconian, though
04:41:08 <aleator> Could anyone point me to c2hs example using #fun?
04:41:56 <_Codex> ski: better just remove them -- programmer will need to reinsert them if they want default impls for the new class instances.
04:41:58 <ski> arjanb : i think this ties in somewhat with the problem of not being able to specify default impls of methods in superclass, when deriving a subclass
04:43:44 <ski> _Codex : you mean when instancing new types in the new restricted superclass, (and possibly later in the original subclass, if possible and needed) ?
04:44:59 <ski> if we consider the 'just as if we had declared the new class first and derived the old from that'-perspective, the default impl should with current system be in the superclass
04:45:45 * esap found a paper saying "... we find that a comonoid is nothing more than an ordinary set dressed up to look scary."
04:45:58 <_Codex> if programmer rewrites the function types again, he should probably also rewrite the default impls too. I think the type signatures and default impls are somehow linked together? :-)
04:46:13 <ski> esap : where, where ? :)
04:46:24 <esap> ski: http://boole.stanford.edu/pub/comonoids.pdf
04:46:48 <ski> _Codex : yes. but how to make it interact nicely and safely ?
04:46:55 <ski> that is the question, i think
04:46:59 <ski> esap : ty
04:47:00 <_Codex> esap: I thought "sets are nothing more than ordinary elements dressed up to look scary." :-)
04:48:10 <arjanb> would it be needed/possible to instance a superclasses first when making a new instance of the subclass?
04:48:36 <_Codex> arjanb: no. It might not be possible.
04:50:40 <arjanb> that would be an annoying restriction
04:50:56 <dcoutts> aleator, I think GTK+HS used that, Gtk2Hs doesn't
04:51:15 <dcoutts> aleator, we found it to be more trouble than it's worth
04:51:39 <ski> (arjanb : indeed)
04:51:54 <_Codex> arjanb: you're right.
04:52:23 <Wed5963> is Data.Tree nice?
04:53:00 <_Codex> arjanb: but if the function type signature changed, its not possible (without rewriting the whole function) to fill in the gaps.
04:53:16 <arjanb> i think restricting the type signature yields all kinds of problems from the subtyping mess
04:53:32 * ski goes back to the contra- question
04:53:57 <ski> arjanb : hm, which ?
04:55:41 <ski> _Codex : i think the co- vs contra- variance of the tyvar to be restricted doesn't matter
04:56:17 <_Codex> arjanb: and it wouldnt work anyway. The dependency goes from library code to user code. Which means it's not very good idea. (or it might be very good idea if the system can automatically register the extensions :-)
04:56:46 <ski> (_Codex : what would prolly matter is the co- vs contra- of the class constraint, but haskell only has the 'contra-' variant (pun intended) of that (as opposed to mercury))
04:59:41 <Wed5963> @hoogle Tree
04:59:54 <ski> @index Tree
04:59:55 <lambdabot> Data.Tree, Data.Graph
05:00:33 <Wed5963> im wondering if its useful for me to use this 'builtin' tree type....are there many handy/interesting algorithms/functions for the Data.Tree type?
05:00:42 <Wed5963> inside Data.Tree itself...not so much
05:09:14 * CosmicRay stumbles into the channel
05:09:19 <shapr> y0 CosmicRay
05:09:24 <CosmicRay> morning shapr
05:09:27 <shapr> Is PreludeExts part of MissingH?
05:09:46 <CosmicRay> shapr: no
05:09:58 * CosmicRay checks it out
05:10:04 <shapr> Oh, too bad.
05:10:26 <CosmicRay> ahh, I remember this.
05:10:30 <CosmicRay> LicensedPreludeExts could be.
05:10:35 <shapr> Right, that's it.
05:11:11 <CosmicRay> some of this I have in there already
05:11:18 <shapr> Ok
05:11:25 <CosmicRay> most is new though
05:11:41 <CosmicRay> any particular bits you were interested in ?
05:11:45 <dcoutts> @seen SyntaxNinja
05:11:46 <lambdabot> I saw SyntaxNinja leaving #haskell 4 days, 12 hours, 12 minutes and
05:11:46 <lambdabot> 24 seconds ago, and I have missed 2 minutes and 49 seconds since
05:11:46 <lambdabot> then.
05:11:50 <shapr> I don't remember actually.
05:12:24 <CosmicRay> shapr: in fact, if you want to darcs get http://darcs.complete.org/missingh, you can then just darcs send me patches if you'd like.  I'm working on whipping some sort of ldap interface ti haskell into shape today.
05:12:28 <CosmicRay> s/ti/to/
05:12:33 <CosmicRay> s/to/from/ ;-)
05:12:41 <shapr> Ah, sounds good.
05:12:51 <shapr> For some reason I'm writing a Bittorrent client today.
05:12:56 <CosmicRay> in haskell?
05:12:59 <shapr> Yup
05:13:02 <CosmicRay> *nice*
05:13:14 <shapr> The parser bit is done, I just need to do the network part.
05:13:29 <Igloo> Does anyone know enough about mail headers/MIME to know if   "Content-Type: (wibble) text/plain; charset=us-ascii"   should be equivalent to   "Content-Type: text/plain; charset=us-ascii"?
05:13:45 <CosmicRay> let me know if I can help.  I haven't worked with bittorrent itself, but I have done variuos network stuff
05:13:49 <shapr> Igloo: I think it should be
05:13:52 <CosmicRay> Igloo: what exactly is "wibble" in that context?
05:14:02 <shapr> Anything in parens is a comment, I think.
05:14:03 <CosmicRay> I would tend to agree with shapr
05:14:03 <Igloo> It's a comment
05:14:04 <ibid> Igloo: yes
05:14:15 <Igloo> In that case I think mutt is broken
05:14:17 <ibid> Igloo: unless i'm badly mistaken
05:14:23 <CosmicRay> Igloo: IIRC, WASH should be able to give you just the "text/plain" bit
05:14:29 <CosmicRay> Igloo: what's it doing?
05:14:46 <ibid> i think even Content-Type text(wibble)/plain; charset="us-ascii" is
05:14:52 <Igloo> Not to mention pretty much every other parser I've looked at the source for, unless I missed something
05:14:57 <ibid> but i'm not sure, would need to consult the rfc's
05:14:58 <Igloo> [-- (wibble) text/plain is unsupported (use 'v' to view this part) --]
05:15:17 <ibid> Igloo: yeah, most MIME parsers are deficient, they work in the common case but ...
05:15:26 <ibid> then again, MIME is extremely baroque
05:15:32 * Igloo finds the RFCs very unclear on how to lex/parse things
05:15:50 <ibid> how so?
05:15:51 <CosmicRay> Igloo: it would be best to follow the postel mantra: conservative in what you generate, liberal in what you accept
05:15:53 <shapr> Igloo: Have you tried hsemail?
05:15:59 <ibid> they do have a formal grammar :)
05:16:00 <CosmicRay> mime is quite a minefield
05:16:14 <ibid> CosmicRay: ym mimefield :)
05:16:17 <shapr> mimefield
05:16:18 <shapr> haha
05:16:29 <CosmicRay> ibid: I was trying to come up with something along those lines.  thanks ;-)
05:16:54 <CosmicRay> hsemail is probably a bit more low-level than he really needs
05:17:00 <ibid> Igloo: istr there is even a mime test suite
05:17:34 <CosmicRay> ibid: conspiracy!  microsoft must have suppressed it because outlook would fail so horribly!
05:17:42 <Igloo> Looking at the Wash source I don't think it's going to cope either
05:17:52 <Igloo> ibid: Oh?
05:17:56 <CosmicRay> Igloo: who is actually generating content-type lines like that?
05:18:17 <Igloo> CosmicRay: I am, with vim
05:18:34 <ibid> Igloo: istr a now-superseded mime rfc mentioning one, and urging the testing of all implementations
05:18:38 <CosmicRay> Igloo: ahh.  then the solution is simple.  stop it. ;-)
05:18:57 <CosmicRay> ibid: you mean rfc2822, issued april 2001?
05:19:02 <Igloo> CosmicRay: Are you advocating using a broken MIME implementation?  :-þ
05:19:07 <ibid> CosmicRay: no
05:19:14 <ibid> CosmicRay: that's not a mime rfc
05:19:44 <CosmicRay> oh, right, that's the basic message format.
05:19:44 <CosmicRay> hmm.
05:19:53 <ibid> 15xx something
05:19:54 <CosmicRay> [RFC2045, RFC2046, RFC2049] <-- there are the mime ones.
05:20:00 <ibid> yeah
05:20:23 <CosmicRay> ahh, all header fields except content-disposition are defined to accept rfc822 comments
05:20:25 <ibid> i noted it when i first tried to learn internet mail techniques, back in 1996 or so
05:20:35 <ski> esap : "Categories, Types and Structures. An introduction to Category Theory for the working computer scientist", by Andrea Asperti and Giuseppe Longo (at http://www.di.ens.fr/users/longo/download.html) talks some on linear logic and comonoids (and monoids and monads as an instance of that)
05:20:36 <CosmicRay> In addition, comments are allowed in
05:20:36 <CosmicRay>    accordance with RFC 822 rules for structured header fields.  Thus the
05:20:36 <CosmicRay>    following two forms
05:20:36 <CosmicRay>      Content-type: text/plain; charset=us-ascii (Plain text)
05:20:36 <CosmicRay>      Content-type: text/plain; charset="us-ascii"
05:20:49 <ibid> (the testsuite thing)
05:21:51 <Lor> ibid, are you coming to icfp?
05:23:38 <Igloo> Hmm, Hsemail/Rfc2822.hs looks like it does actually pay attention to comments, although it knows nothing about MIME of course
05:23:42 <ibid> Lor: probably not
05:24:01 <CosmicRay> from glancing at rfc2822, it is somewhat unclear to me whether what you are doing is currently legal, igloo.
05:24:16 <CosmicRay> apparently they have tightened up the rules for where comments can occur in the headers
05:24:25 <CosmicRay> but it's not immediately obvious to me what that means
05:24:48 <Igloo> CosmicRay: Yeah, I find it very hard to follow, as I said above  :-(
05:25:08 <genneth> has anyone got any ideas for this guy here? : http://lambda-the-ultimate.org/node/view/865
05:30:06 <Philippa> he's not asking an OO vs FP question, he's asking a typing question
05:30:11 <Philippa> his solution #3 is the Right Thing
05:33:41 <grimace_> and that's basically what GTK does eh?
05:33:59 <Lor> GTK doesn't have multiple inheritance.
05:34:05 <Lor> Well, didn't use to have, anyway.
05:34:12 <genneth> i would have said that he should make two interfaces, HasChildren and HasWindow
05:34:34 <Lor> Gtk has a common "Container" superclass for all containers.
05:34:36 <dcoutts> Lor,  but it does have java-style interfaces which gives you much of multiple inheritance
05:35:02 <Lor> dcoutts, yep, that's a newer development that was only a future plan when I was last involved with gtk.
05:35:22 <dcoutts> Lor, you worked on gtk?
05:35:53 <genneth> you poor man... :-p
05:36:42 <Lor> Uh, I recall doing some very very minor things back when gtk was at 1.2 or something...
05:40:06 <dcoutts> well if you feel like doing some very very minor things for the Gtk Haskell bindings you know who to talk to :-)
05:41:23 <Lor> Haskell doesn't really accommodate subtyping very naturally.
05:42:34 <dcoutts> Lor, we use type classes, it works just fine
05:43:02 <CosmicRay> one problem with type classes is that you can't very easily have a list of different subtypes of widgets
05:43:10 <CosmicRay> that's something that's fairly natural in an OO language
05:43:21 <CosmicRay> it's psosible in hjaskell but requires some non-obvious hackery
05:43:22 <Lor> You mean a heterogeneous container?
05:43:23 <dcoutts> it models the single inheritance and the new style Gtk interface things
05:44:32 <CosmicRay> Lor: Not sure.  I just mean that, for instance:   Real a => [a]   denotes a list containing a bunch of items of the same type.  The type could be anything that's a Real, but every element in the list must be the same type (you can't mix various types of Reals in that list)
05:44:51 <CosmicRay> Lor: the only way around that, that I know of, is to have an encapsulating data type
05:45:04 <CosmicRay> which IIRC is an extension that both ghc and hugs supports
05:45:28 <CosmicRay> here's an example:
05:45:29 <CosmicRay> data HVFSStatEncap = forall a. HVFSStat a => HVFSStatEncap a
05:45:53 <CosmicRay> I can then have a list of HVFSStatEncap items, which can include various different types of HVFSStat objects.
05:45:53 <Lor> Yeah, existentials are the solution.
05:46:00 <CosmicRay> using this is not exactly straightforward though.
05:46:15 <CosmicRay> Lor: yes, it works, but my point is that it's a pain and I try to avoid it whenever possible.
05:46:28 <CosmicRay> because of this, I'm not as enthusiastic about type classes as I once was.
05:46:50 <CosmicRay> some people advocate using data structures consisting of various functions as an alternative.
05:46:57 <Lor> Yes, this is pretty much what I meant by Haskell not accommodating subtyping "naturally".
05:47:01 <CosmicRay> ah.
05:47:07 <jyp> there's also HList
05:47:25 <CosmicRay> that, and even with typeclasses, it's not that easy to extend some existing type and make only a small tweak to how it works
05:50:01 * Philippa is v.much looking forward to boxy types in GHC not least because they should avoid the need for existentials
05:50:10 <CosmicRay> I'm still wrapping my head around how to interface Haskell to C++ libraries that rely on the ability to trivially override methods as a fundamental way to operate
05:50:13 <Philippa> (at least in that particular situation)
05:51:01 <Philippa> provide the one overridden class that takes haskell funcs for everything? (for each such class)
05:54:46 <ski> Philippa : boxy types ?
05:54:51 <kosmikus> Philippa: you mean because you can encode existentials using higher-ranked universally quantified types?
05:55:11 <Philippa> kosmikus: I mean because the type I /want/ is just Foo a => a, no constructor
05:55:29 <Philippa> and then everything else can safely instantiate type variables to that
05:55:56 <Philippa> ski: something S P-J&co thought up to allow a mixture of inference and impredicative types
05:56:02 <ski> with real existential quantifiers in types, and not just in datatypes, one could have something like [exists a. Real a *> a]  (also with rank-2, i think)
05:56:13 <Philippa> (which means being able to instantiate type variables to polytypes)
05:56:39 <ski> Philippa : how would having that solve the prob here ?
05:56:44 <Philippa> sure, but why not forall a.Foo a => a?
05:57:35 <Philippa> ski: it makes "something belonging to some type class" a valid, useful type all on its own with no need to shove a constructor around it
05:57:49 <ski> (somwhat depending on Foo), "forall a. Foo a => a" is prolly not very useful
05:57:54 <Philippa> you could have a [forall a.Foo a => a]
05:58:03 <ski> hm
05:58:07 <kosmikus> yes, but that's not the same as the existential thing
05:58:12 <Philippa> it's potentially extremely useful. It's enough to implement OOP
05:58:36 <Philippa> kosmikus: like I said, it'd eliminate the need for existentials in the one case of "I want a type for 'everything belonging to Foo'"
05:58:37 * esap has built a library to implement OOP style in Haskell.
05:58:46 <ski> Philippa : hm, ah, it's other than for the heterogenos elems prob, yes ?
05:59:07 <kosmikus> but why do you want "everything belonging to Foo", not "something belonging to Foo"?
05:59:35 <Philippa> that's what the type actually translates to
05:59:58 <ski> a value of type '[forall a. Foo a => a]' would be a list of thing, where we can choose at will, separately, for each of the elems, which Foo instance they shall use
05:59:58 <dblhelix> are there concrete plans to make [forall a . Foo a => a] legal in GHC?
06:00:07 <Philippa> ski: bingo
06:00:23 <Philippa> dblhelix: I believe so. Well, I'm hearing something about implementing boxy types and that'd be a natural thing to do with them
06:00:33 <ski> Philippa : now, i'm just not sure how this helps with OO :)
06:00:49 <dblhelix> doesn't that make the type system impredicative? (answering: it does)
06:00:52 <Philippa> ski: it gives you an equivalent to class types
06:00:59 <kosmikus> dblhelix: sure
06:01:02 <Philippa> dblhelix: yup. That's the point. Boxy types let you do that
06:01:06 <ski> Philippa : which is ?
06:01:37 <Philippa> translate classes into type classes and (where the class is non-abstract) instances thereof
06:01:42 <Lor> You can already use "pure" existential types if you cps-convert them to universals. Tedious, but sometimes worthwhile.
06:01:54 <dblhelix> kosmikus: that opens doors for allowing more general quantified types as type indexes in GH, doesn't it?
06:01:58 <Philippa> Lor: yup
06:01:59 <ski> Philippa : i still don't see how this helps with heterogenous collections ..
06:02:20 <ski> esap : what kind of OOP ?
06:02:26 <esap> ski: The C++ kind.
06:02:39 <Philippa> ski: depends what you want out of your heterogeneity
06:03:05 <Philippa> a list of things that're Renderable whatever their underlying type is a potentially useful heterogenous collection...
06:03:19 <Philippa> you might even want a list of things that reflect their types
06:03:27 <Philippa> (but you might not care)
06:03:29 <ski> Philippa : like, putting specific things of types in the class together in the collection, like specific widget instances
06:03:33 <Philippa> feel free to extend to more general collections
06:03:40 <esap> ski: see http://www.kotiposti.net/epulkkin/oolib-1.0.tar.gz
06:03:50 <kosmikus> dblhelix: possibly
06:03:54 <Philippa> ski: all those widgets're instances of a Widget typeclass, yes?
06:04:01 <ski> yes
06:04:03 <Philippa> so, [forall a.Widget a => a] is the list you want
06:04:05 <kosmikus> no
06:04:09 <kosmikus> exists
06:04:44 <kosmikus> I'm with ski, you still want existentials
06:05:31 <Philippa> No, I don't. I don't want a damn thing but knowledge that I've an instance - the list /accepts/ all a such that a is in Widget
06:05:40 <kosmikus> no
06:06:02 <dblhelix> Phillipa: no, you can't populate the list with elements that are coercible to all possible types that are instances of Widget
06:06:16 <Philippa> dblhelix: that's not how that type reads in Haskell
06:06:17 <ski> that list will only accept things that are generic in what instance they use
06:06:26 <ski> it will not accept specific instances
06:06:56 <ski> compare with [forall a. a -> a] (barring bottom-things) this list can only contain id functions
06:07:08 * Philippa smacks forehead
06:07:11 <Philippa> OK, yes, I'm being stupid
06:07:23 <dblhelix> Phillipa: well, then syntax of boxy types is already inconsistent with rank-n syntax
06:07:24 <ski> as opposed to [exists a. a -> a] which can contain any endofunctions for any type a
06:07:49 <kosmikus> dblhelix: syntax of boxy types is ok
06:07:52 <Philippa> dblhelix: the syntax of existentially-quantified constructors is, hence my confusion
06:08:07 <ski> Philippa : so what was boxy types then ?
06:08:15 <xerox> What's an endofunction?
06:08:27 <Philippa> the ability to instantiate a type variable (like the one in list's constructor) to a polytype
06:08:37 <ski> just a function from some type, into the same type
06:08:58 <ski> xerox : i.e. a function f : A -> A   for any A you like
06:09:01 <kosmikus> ski: it's on spj's homepage
06:09:04 <xerox> How does that differ from id functions?
06:09:09 <dblhelix> kosmikus: you mean that [forall a . a] can indeed only contain lists that can only contain bottom? 'cause then it's okay
06:09:23 <ski> xerox : negate :: Integer -> Integer is an endofunction
06:09:23 <kosmikus> dblhelix: yes
06:09:44 <dblhelix> kosmikus: then we agree :)
06:09:50 <kosmikus> dblhelix: :)
06:09:56 <ski> Philippa : ok
06:10:04 <xerox> Ooh-kay.
06:10:29 <kosmikus> there's also MLF, a type system that allows impredicativity in an imho nicer way than the "boxy types" approach
06:10:40 <ski> (Philippa : i, somehow, thought rank-2 (-n ?) or something implied that ..)
06:10:54 <xerox> ok.
06:11:10 <Philippa> ski: if it did, we'd have exists already
06:11:19 <Philippa> as there's no other real barrier to it
06:11:38 <Philippa> I did confuse myself slightly on the type of 1 before defaulting...
06:11:49 <dblhelix> does this mean that with boxy types the only well-formedness restrictions on the type language are enforced by means of the kind system?
06:11:50 <ski> xerox : i just borrowed the word endomorphism from category theory (where it's any morphism f : A -> A, i.e. having same codomain as domain), to ordinary functions
06:12:24 <Philippa> endofunction's an established term IIRC and probably predates endomorphism
06:12:41 <ski> (Philippa : ok, didn't know that)
06:12:44 <kosmikus> dblhelix: I think there's still a normalization step for the position of quantifiers in a type, but otherwise, yes
06:13:00 <ski> kosmikus : how does MLF work, then ?
06:14:24 <kosmikus> ski: it's a type system that has impredicativity and prinicipal types and (limited) type inference, using some form of bounded quantification
06:14:46 <dblhelix> you should plug the paper here, kosmikus ;)
06:14:59 <kosmikus> there's been an icfp paper by didier remy and didier lebotlan, icfp 2003
06:15:00 <ski> kosmikus : with subtyping, then, i take it ?
06:15:20 <kosmikus> daan leijen and I have written a paper for this year's icfp that shows how qualified types can be done in mlf
06:15:42 <kosmikus> ski: no real subtyping, it's all instantiation
06:16:46 <ski> kosmikus : so what's the bound's for, then ?
06:18:20 <ski> kosmikus : "MLF: Raising ML to the Power of System F" ?
06:18:41 <kosmikus> if you have "forall (alpha >= sigma) . t" then you can only instantiate alpha to a type a if a is an instance of sigma.
06:18:49 <kosmikus> yes, that's the one
06:19:24 <kosmikus> "Qualified types for MLF" is the other
06:19:25 <ski> hm, ok
06:20:56 <ski> how is this different from 'forall FV(alpha). t[alpha := sigma]' ?
06:21:09 <ski> bah
06:21:17 <ski> 'forall FV(sigma). t[alpha := sigma]'
06:22:29 <kosmikus> not sure if I understand the notation, but if I get it right, then the difference is that the bounded quantification expresses sharing between multiple occurences of the bound variable, i.e., all occurrences have to be instantiated to the *same* type
06:24:00 <ski> i thought my version did that too .. ?
06:24:24 <ski> hm
06:24:45 <ski> any possibly tyvars in sigma, are they free ?
06:25:07 <ski> e.g.  'forall a >= (b -> b). [a]'
06:25:30 <kosmikus> yes, they're free
06:25:36 <ski> my version would be 'forall b. [b -> b]' .. but then b is not free
06:25:41 <ski> hm
06:26:25 <ski> (i assumed they were implicitely universally quantified ..)
06:26:48 <kosmikus> in your syntax, the type "forall (a >= forall b. b -> b) . a -> a" would be "(forall b. b -> b) -> (forall b. b -> b)", right?
06:26:53 <ski> so, then to compare with '[b -> b]' i guess
06:27:19 <ski> yes
06:27:38 <kosmikus> you can't make "forall c. (c -> c) -> (c -> c)" from the latter, but it's a valid instance of the bounded type
06:29:02 <kosmikus> look at the "choose id" example in either of the two papers, it's relatively near to the beginning and it explains well why the bounds are advantageous
06:30:45 <shapr> Is there a SHA1 module in a deb? Or should I grab something cabalized?
06:31:44 <ski> kosmikus : http://citeseer.ist.psu.edu/661451.html for first paper ? (can't find the other one now, url ?)
06:33:21 <kosmikus> cristal.inria.fr/~remy/work/mlf/icfp.pdf for the first (don't know if the other is equivalent)
06:34:34 <ski> "Qualified types for MLF" was by you and daan leijen ?
06:35:48 <kosmikus> ski: the other is temporarily available via cs.uu.nl/~andres/icfp-submit.pdf
06:37:44 <ski> "cs.uu.nl could not be found"
06:37:50 <kosmikus> www.cs.uu.nl
06:37:54 <ski> ah
06:37:59 <kosmikus> my mistake
06:38:10 <kosmikus> thought it would be possible without www.
06:39:20 <kosmikus> I'm away for a while
06:39:30 <ski> kosmikus : danke
07:22:41 <shapr> Is there an easy way to read a file as [Word8] ?
07:28:59 <CosmicRay> shapr: there are some binary handle I/O options out there
07:29:05 <CosmicRay> I think that is what they work with
07:29:07 <shapr> ok
07:29:26 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#21
07:29:46 <CosmicRay> well, it's maybe a bit more low-level than you were looking for
07:30:09 <CosmicRay> I have some code in MissingH.IO.Binary that converts those back and forth to strings
07:30:16 <CosmicRay> you could probably adapt it fairly easily for Word8
07:43:14 <ndm> this is probably a highly newbie question
07:43:25 <ndm> but i'm using GHCi, trying to load modules
07:43:48 <ndm> and if I do soemthing like :load Language.Haskell.Parser it says module `Language.Haskell.Parser' is a package module
07:43:55 <ndm> and doesn't seem to have loaded it
07:43:58 <Igloo> :m + Language.Haskell.Parser
07:44:02 <shapr> try :m + Language.Haskell.Parser
07:44:15 <ndm> yay
07:44:19 <ndm> thanks very much!
07:44:45 <Igloo> If you open a file in binary mode then you should be able to just map fromIntegral . ord over the result of hGetContents
07:45:01 <shapr> Cool, thanks.
07:48:00 <CosmicRay> Igloo: doesn't that risk corruption due to unicode issues?
07:48:17 <Igloo> Not if you open it in binary mode
07:48:26 <CosmicRay> ah.
07:48:31 <Igloo> AIUI, at least
07:48:35 * CosmicRay doesn't really understand how unicode works in haskell
07:48:43 <CosmicRay> it all seems rather opaque and weird.
07:49:02 <Igloo> It doesn't in GHC, which may be some of the source of your confusion  :-)
07:49:16 <Igloo> It does in hugs, but it working has other issues
07:49:18 <CosmicRay> heh, but apparently it does in hugs, to a certain extent
07:49:29 <shapr> I wish for a unicode solution.
07:49:56 * Igloo should get around to writing a FilePath proposed change and see what people think of it
08:21:15 * shapr boings cheerfully
08:21:34 * araujo throws lambda at shapr 
08:23:18 * autrijus finally saw the light of how to read "forall" as "lambda"
08:23:46 <shapr> I don't think I've got that light yet.
08:26:06 <ski> autrijus : um, how ?
08:28:02 <autrijus> intuitively ((lambda a -> a) :: (forall t. t)) can be read as (lambda T -> lambda (a :: T) -> a)
08:28:05 <shapr> Oh, I think I do understand that after all.
08:28:33 <autrijus> it's just the simple system F idea
08:28:36 <autrijus> it's just I never grokked it :)
08:28:59 <integral> it sounds almost too simple
08:29:26 <autrijus> *nod*
08:29:31 <ski> (lambda a -> a) :: (forall t. t -> t)
08:29:38 <autrijus> right, that's typo.
08:30:00 <ski> really, the forall is not lambda, it's proof is a lambda
08:30:21 <autrijus> aye.
08:30:29 <autrijus> but the mapping is straightforward, not mysterious
08:30:40 <ski> (/\ t. \a :: t. a) :: (forall t. t -> t)
08:30:41 <autrijus> (whereas I always thought as mysterious in my ignorance)
08:31:16 <ski> '/\' being big lambda  (small lambda is used also, at times)
08:31:25 <ski> this is related to dependent types, too
08:31:56 <autrijus> yeah, which is types calculated based on terms, if I'm not mistaken
08:32:06 <ski> yes
08:32:15 <autrijus> it finally starts to make sense :))
08:32:52 <ski> (\t :: *. \a :: t. a)  ::  (t :: *) -> t -> t     (which the type being shorthand for   (t :: *) -> (a :: t) -> t   )
08:33:07 <ski> s/which/with/
08:33:52 <ski> i.e. in dependent types, forall and implication/function are both a special case of the "(x :: t0) -> t1" construction
08:34:57 <ski> (one can also see    'forall t. t -> t'  as 'Pi (\t. t -> t)'  with 'Pi :: (* -> *) -> *'  ... :)
08:35:24 <autrijus> surprisingly and refreshingly I can follow what you're saying.
08:35:59 <ski> :)
08:35:59 <autrijus> is all this captured in CoC? I havn't started reading up on it
08:36:26 <ski> in that latter case, the '(\t. t -> t)' is a real type-lambda  (having kind '* -> *')
08:36:30 <ski> CoC ?
08:36:47 <ski> coq ?
08:36:50 <autrijus> calculus of constructions
08:36:55 <ski> ok
08:37:07 <ski> well, i don't know, i haven't looked at it
08:37:13 <ski> but, possibly
08:37:14 <autrijus> http://en.wikipedia.org/wiki/Calculus_of_constructions
08:37:26 <autrijus> coq without inductive types, according to that page
08:38:37 <shapr> That's nifty
08:47:08 <Lor> CoC is really nifty.
08:47:27 <Lor> I just wish there was some way to encode inductive types in pure functions.
08:48:23 <Lor> In almost all other systems data types can usually be church-encoded into functions, but CiCs inductive types seem to be a genuine extension to the system.
08:49:21 <autrijus> I don't know a thing about inductive types in CiC... how is it special?
08:50:19 <Lor> It's hard to explain. Just start toying with coq and you'll get it.
08:51:40 <autrijus> ok. compiling coq...
08:52:39 <Lor> once more: is anyone coming to ICFP, and interested in sharing a hotel room?
08:52:47 <autrijus> how is inductive types useful? (I'm assuming GHC/OCaml doesn't have it)
08:53:35 <Lor> Coq is a theorem prover, so its type system has to be strong enough to encode (almost) arbitrary properties.
08:53:47 <Lor> s/strong/expressive/
08:53:50 <autrijus> right, but I mean for general programming
08:54:39 <Lor> Weelll... there's a school of thought that says that even general programming should be proven correct.
08:55:08 <autrijus> ahh. proof-carrying programs.
08:55:28 <dcoutts> eg eppigram
08:55:28 <autrijus> but doesn't programs usually do undecidable things of undecidable correctness?
08:55:42 <dcoutts> not with eppigram! :-)
08:56:00 <dcoutts> eppigram just says no to general recursion
08:56:10 <autrijus> oh.
08:56:16 <dcoutts> if you can't prove it then it won't let you write it :-)
08:56:35 <dcoutts> it's fun, but you've got to be so disiplined
08:56:39 <autrijus> in that case it better generate some amazingly fast code.
08:57:09 <dcoutts> last I heard they were working on a C code generator in addition to the interpreter
08:57:32 <dcoutts> that would be able to take advantage of the strong proofs that the language provides
08:57:49 <dcoutts> eg that there cannot be any list/array indexing errors
08:57:55 <autrijus> right
08:57:57 <Igloo> Can anyone tell me what this says on Windows please? printf "#include <sys/stat.h>\nS_ISFIFO(wibble)\n" | gcc -E - | grep wibble
08:57:59 <dcoutts> so no need for runtime checks
08:58:11 <autrijus> it sounds like program analysis, i.e. optimization, on Epigram code, would be powerful as you can do away with most (all?) runtime checks
08:58:47 <Igloo> Sorry, I mean: printf "#include <sys/stat.h>\nwibble = S_ISFIFO(flibble)\n" | gcc -E - | grep wibble
08:58:58 <dcoutts> the point is there would be no runtime checks in your code in the first place because the types would prove that the error case could not happen
08:59:09 <autrijus> yes but if all you have is an interpreter
08:59:22 <autrijus> then that doesn't quite translate to any wallclock efficiency
08:59:48 <dcoutts> right, it needs the C backend to get the effeciency
09:00:04 <autrijus> can it have "soft correctness" mode?
09:00:10 <dcoutts> but the main point was to show that such a type system was possible for programming
09:00:17 <autrijus> i.e. if I start using general recursion etc then it warns that that part can't be proven
09:00:20 <autrijus> etc
09:00:30 <autrijus> and insert runtime checks accordingly
09:00:35 <autrijus> sort of like incremental typing
09:01:41 <tromp> just wasted an hour tracking down a bug in C
09:02:05 <tromp> stupid typing error
09:02:27 <tromp> C doesn't know log2 returns a double even if you include <math.h>
09:05:40 <autrijus> (type inference)++ # no need to be a strong typist to enjoy strong typing
09:08:40 <Fide_> what is the difference between => and ->?
09:08:57 <autrijus> a dash?
09:09:04 <autrijus> (which use of -> are you referring to?)
09:09:15 <dcoutts> Fide_, => is for seperating class constraints from the type, and -> is for writing function types
09:09:20 <integral> -> is a type constructor, and => is another thing
09:09:32 <dcoutts> Fide_, look at the types of a few examples to see how they are used
09:09:46 <dcoutts> @type (+)
09:09:50 <lambdabot> forall a. (Num a) => a -> a -> a
09:10:16 <dcoutts> so the type part is (a -> a -> a) ie a function type
09:10:36 <Fide_> I have something like that
09:10:39 <dcoutts> and the bit which says that each of those 'a' must be numbers is (Num a)
09:10:50 <Fide_> create :: (Eq a) => Menge a
09:10:55 <dcoutts> and you put it all together with "=>" as the seperator
09:11:02 <dcoutts> right
09:11:11 <ski> (dcoutts : s/each of those/that/ i think)
09:11:40 <Fide_> isEmpty :: (Eq a) => Menge a -> Bool is better to show what I mean
09:11:54 <dcoutts> ski, yeah ok
09:12:34 <ski> isEmpty is a function, that given any value of type 'Menge a', will return a boolean, provided 'a' is in typeclass 'Eq' (i.e. that you have equality on the type 'a')
09:13:04 <Fide_> is Menge a a typecast?
09:13:08 <ski> Fide_ : 'Menge' is 'Set' in german, i think, right ?
09:13:33 <ski> 'Menge a' is like '[a]'
09:13:35 <autrijus> Fide_: no, Menge is a type operator that takes a type (a) and yields another time (Menge a)
09:13:40 <autrijus> s/time/type/
09:13:43 <ski> i.e. a set of elements from type 'a'
09:14:53 <Fide_> Menge is a type and Menge a sounds like a typecast, because a is Type Eq
09:15:00 <Fide_> or am I wrong?
09:15:09 <ski> 'Menge a' is a type
09:16:33 <ski> Fide_ : if you have programmed with arrays in other langs, you can compare with "array of", which is also a type operator just like 'Menge' i.e."set of" is
09:17:08 <Fide_> I have: module Menge where
09:17:16 <Fide_> and type Menge a = [a]
09:17:38 <ski> ok, so a "set of a" is implemented as a "list of a", then
09:19:32 <Fide_> is type = class in other languages?
09:19:41 <ski> um
09:19:59 <ski> more psecifically, what other languages do you have in mind ?
09:20:07 <ski> java ? c++ ?
09:20:21 <ski> s/psecifically/specifically/
09:20:32 <Fide_> Pascal and Java
09:20:38 <ski> if yes, then somewhat
09:20:48 <ski> type here is similar to type in pascal
09:21:11 <Fide_> hmm
09:21:24 <ski> in pascal you have "set of" and "array of" type operators, i think  (though the array also depend on index type, iirc)
09:21:46 <Fide_> class is a type operator too
09:21:50 <ski> no
09:21:57 <ski> class is a type former
09:22:15 <Fide_> type class Stack
09:22:27 <Fide_> Begin End;
09:22:46 <ski> hm, speaking of type classes (in haskell) now ?  (they are not same as classes in other langs)
09:23:20 <ski> what lang is that ?
09:23:33 <Fide_> type in haskell looks like ADT
09:23:35 <ski> some OO pascal ? delphi ?
09:23:54 <Fide_> freepascal and Delphi
09:23:54 <ski> you can make ADTs in haskell, yes
09:24:08 <Fide_> make?
09:24:15 <ski> construct
09:24:49 <Fide_> type is ADT or not?
09:24:49 <ski> ADTs are about having a type, and some operations on that type, and the representation of the type and the implementation of the operations should be hidden
09:25:19 <ski> if the type becomes ADT or not depends on if you hide the type representation or not
09:26:21 <ski> (if you don't hide the type representation, then it's not abstract)
09:28:28 <ski> anyway, the way to think about 'Menge' is, it's a type operator, i.e. it takes a type, and gives back a type, example : 'Menge Int' is a type, namely the type of sets of integers  'Menge (String,Bool)' is a type, namely the type of pairs of strings and booleans
09:28:57 <ski> compare with 'set of int' in pascal
09:29:33 <esap> why is it called 'menge'? :-)
09:30:11 <ski> (esap : menge is set in german)
09:30:19 <esap> ah ok
09:32:46 <void-> Hi, has anyone built the SDL bindings on OSX?
09:34:48 <ski> Fide_ : the reason i said that "type class Stack ..." was not a type operator was, firstly that the whole thing is not a type (i.e. you can't put it to the right of ":"), it's a declaration, also, secondly, it doesn't take a fixed number of types whith specified purposes, but a variable number of sub-declarations (of fields and methods i would think), between 'Begin' and 'End'
09:35:23 <goron> If I would read "Types and Programming languages" will I be able to understand all the more advanced type stuff in e.g. GHC?
09:35:33 <Fide_> esap: because the ski you told, that type in haskell is equal as in pascal
09:36:10 <Fide_> s/esap: because the/''
09:38:48 <Fide_> http://rafb.net/paste/results/bGWjfZ14.html <-- how can I use this module?
09:41:45 <ski> start with an empty menge/set, gotten by 'create', then 'insert' some items into it, e.g. like 'insert (insert (insert create 1) 2) 3'
09:42:40 <ski> if you call that 'menge0', then you can test test whether '2' is in that by calling 'hasElement menge0 2'
09:43:21 <Fide_> how can I tell
09:43:22 <ski> hm, you can also write    menge0 = create `insert` 1 `insert` 2 `insert` 3  i think
09:43:35 <ski> and then    menge0 `isElem` 2
09:43:37 <Fide_> I have written that in Menge.hs
09:43:46 <ski> you use hugs or ghc ?
09:43:48 <Fide_> and want use it in menge.hs
09:43:54 <ski> (or nhc ? or hbc ?)
09:43:56 <Fide_> hugs
09:43:58 <ski> ok
09:44:07 <ski> then, save the file, if not done
09:44:53 <Fide_> Menge.hs I called and now I want it use in menge.hs to write the methods
09:45:00 <ski> hm, i'm not sure it's a good idea naming your test module the same way (ignoring capitalization) as the ADT module
09:45:01 <Fide_> create and so on
09:45:08 <ski> anyway
09:45:27 <ski> in your example module ("menge.hs") you can e.g. write
09:45:33 <ski> menge0 :: Menge Integer
09:45:42 <ski> menge0 = create `insert` 1 `insert` 2 `insert` 3
09:46:24 <ski> then you can load it in hugs by ':l menge.hs' (here hugs might possibly have problems finding files, because you've named them almost the same)
09:46:34 <ski> and then, in hugs you can type
09:46:35 <Fide_> wha I hate my english
09:46:47 <ski> menge> menge0 `isElem` 2
09:46:47 <Fide_> wait a second I write what I want in pascal
09:46:55 <ski> to which hugs should respond
09:46:56 <ski> True
09:47:05 <ski> ok
09:52:15 <Fide_> http://rafb.net/paste/results/nQiA3O11.html
09:53:22 <Fide_> the module is written in Menge.hs und want to use it in menge.hs
09:54:45 <ski> oh, you want to *implement* Menge.hs ?
09:54:54 <ski> i thought you wanted to *use* it ?
09:55:05 <ski> s/it ?//
09:55:13 <ski> s/it ?/it/ (i meant)
09:55:34 <Fide_> yes I want that to implement in merge.hs
09:56:08 <Fide_> communication is the worst thing that two humans do each other
09:56:08 <void-> Hi, I have another question about building haskell libs. Setup.lhs runs hsc2hs, but I want to change the flags to that command. Is there a standard way to do this?
09:56:35 <Fide_> *can do each other
09:57:16 <ski> mein deutch ist leider sehr schlect :(
09:57:50 <Fide_> Deutsch, but it's same to my english ;)
09:58:45 <void-> Nobody knows?
09:59:07 <Fide_> but doesn't matter how can I implement that in menge.hs?
09:59:46 <ski> isEmpty should be easy, if you implement sets by lists
09:59:56 <ski> just check if the list is the empty list
10:00:06 <Fide_> all is easy, but _how_ can I do that?
10:00:17 <ski> either by pattern-matching
10:00:19 <Fide_> I need like import Menge.hs or so
10:00:22 <ski> or calling the function
10:00:25 <ski> @type null
10:00:26 <lambdabot> forall a. [a] -> Bool
10:00:35 <ski> um
10:01:00 <ski> no, if you're implementing Menge.hs, you need to write the implementation *in that module*
10:01:23 <Fide_> no way do this in another file?
10:01:35 <ski> you 'import Menge' in a module that *uses* the ADT Menge
10:01:53 <ski> sorry, no way to specify module interfaces separately from implementations, in haskell
10:02:19 * ski would like an ML-style module system for haskell :)
10:04:49 <Fide_> is that legal? create [] = Menge a
10:05:36 <esap> Type classes can be used to describe module interfaces to some extent. But really, module interfaces are described by the compiler-generated .hi files.
10:07:13 * esap suggests ghc --show-iface <hi-file>
10:07:24 <ski> Fide_ : no,  first you put your name, i.e. 'create', then any possible arguments (none in this case), then an equals sign '=', and then what the thing to the left of the '=' should be equal to
10:07:31 <ski> ï.e.
10:08:00 <ski> create args... = ..something_being_the_representation_of_empty_set..
10:08:12 <ski> in your case, you have no 'args...'
10:08:23 <Igloo> OK, am I missing something or is it impossible to add some text to an IOException you catch?
10:09:16 <ski> esap : except that those are generated, so can not be checked against, when implementing module
10:09:48 <esap> ski: Right. But that's why you use type annotations in the module implementation itself.
10:10:09 <ski> (esap : and something like the 'functor' module function concept in ML becomes harder ..)
10:10:10 <esap> ski: The compiler does make the necessary checks.
10:10:51 <ski> esap : yes, but then you don't separate module interface from implementation, again :)
10:11:12 <Fide_> hmm
10:11:30 <Fide_> blubb :: Integer is legal?
10:11:33 <esap> ski: the separate part is the .hi files. It's not the same as separate interfaces in e.g. C++.
10:11:54 <ski> Fide_ : yes, that's a type signature for 'blubb'
10:12:17 <esap> ski: And of course, type classes can be used.
10:12:30 <ski> esap : have you seen ML functors ?
10:12:35 <Fide_> that means blubb does not need a parameter but returns a Integer?
10:12:37 <esap> ski: yes.
10:12:45 <ski> Fide_ : indeed
10:13:04 <ski> Fide_ : or, blubb *will not* take a parameter
10:13:10 <ski> you can't provide one
10:13:12 <esap> ski: I would consider a syntactic sugar to implement the same thing in Haskell.
10:13:17 <ski> even if you wanted to
10:13:41 <ski> esap : hm, i don't see that
10:14:32 <Fide_> isEmpty create = true <-- that legal?
10:14:39 <Fide_> *True
10:14:41 <ski> sorry, no
10:15:11 <Fide_> why? create returns Menga a and isEmpty needs one
10:15:12 <ski> there was a proposal to allow stuff like that, but iirc it never got implemented in haskell
10:15:31 <ski> yes, but you can only pattern-match against patterns, and 'create' is not one
10:15:33 <Fide_> *Menge
10:15:43 <ski> (or rather, it doesn't mean what you think)
10:15:58 <ski> what is your definition of 'create' ?
10:16:18 <Fide_> wha, I think I like ADT more than haskell
10:16:25 <Fide_> create = []
10:16:48 <ski> you can't do 'isEmpty create = ...' stuff in Pascal either ..
10:16:49 <ski> ok
10:16:56 <ski> so you can use [] as a pattern
10:17:03 <ski> isEmpty [] = True
10:17:12 <ski> (you need one case more, of course)
10:17:13 <Fide_> ski: yes but in ADT
10:17:28 <esap> ski: You can implement almost similar things by using a combination of Haskell constructs. One of those constructs is a module, which provides the large-scale structure. It is pretty hard to create parametrised modules, because you can't group parameters to members of modules, but it's still possible to get the same effect.
10:17:44 <ski> Fide_ : you mean in abstract pseudo-code description of ADT, which is not implemented ?
10:18:21 <Fide_> isEmpty xs | xs == [] = True
10:18:21 <Fide_>            | otherwise = False
10:18:26 <esap> ski: Because Haskell has * -> * kinded datatypes that can have those type parameters.
10:18:45 <ski> Fide_ : you can do it that way instead, that's also possible
10:19:34 <ski> though, what i had in mind was
10:19:41 <ski> isEmpty [] = True
10:19:46 <ski> isEmpty _  = False
10:19:54 <Fide_> ski: not acstract pseudo code, Haskell types looks like ADT for me therfore I want it use like ADT
10:20:02 <ski> in your case, the result would be the same, thought
10:20:05 <ski> -t
10:20:24 <esap> ski: But you do need syntactic sugar to make it easy-to-use. See the OO library Example.lhs, it has example of how to do it.
10:20:38 <ski> Fide_ : no, i wondered what you mean by "use like ADT" ?
10:20:49 <ski> esap : where ?
10:21:14 <Fide_> isEmpty(create) = True
10:21:15 <esap> ski: http://www.kotiposti.net/epulkkin/oolib-1.0.tar.gz
10:21:17 <Fide_> that's ADT
10:21:35 <ski> as i said, there has been a proposal to allow stuff like that, but it's not implemented
10:21:47 <Fide_> or hasElement(insert(S,x)) = True
10:21:56 <ski> esap : ok (will look later)
10:22:15 <Fide_> I got hungry :/
10:22:52 <Fide_> I go to buy some food
10:22:53 <ski> Fide_ : you can get something similar to that, if you instead define
10:22:55 <Fide_> afk!
10:23:08 <ski> data Menge a = Create | Insert a (Menge a)
10:38:15 <metaperl> I am getting a type error with the base case of my attempt to implement unzip using primitive recursion. Any suggestions to fix?
10:38:16 <metaperl> munzip :: [(a,b)] -> ([a],[b])
10:38:16 <metaperl> munzip [] = []
10:38:16 <metaperl> munzip [(a,b)] = ([a],[b])
10:39:03 <pejo> munzip [] = [] <- That isn't a pair.
10:43:31 <metaperl> pejo: yes, I see the problem.. but what should my base case be instead/
10:43:32 <metaperl> ?
10:43:48 <arjanb> ([],[])
10:43:59 <metaperl> oh ok
10:44:38 <Fide_> returned
10:45:08 <Fide_> nothing is better than a frozen pizza :)
10:45:13 <lament> hmmm
10:45:17 <lament> i can think of at least two things
10:45:22 * vegai prefers non-frozen pizza.
10:45:27 <vegai> it's easier on the teeth
10:45:39 <SyntaxNinja> good morning, #haskell
10:45:56 <BigDuke> can i use an unary function as an infix operator....so like   "1 `negate`"
10:45:57 <Fide_> @type DAta
10:45:58 <lambdabot> bzzt
10:46:04 <Fide_> @type Data
10:46:05 <lambdabot> bzzt
10:46:15 <Fide_> hmm
10:46:26 <Fide_> @explain Data
10:46:27 <lambdabot> Unknown command, try @listcommands.
10:46:35 <Fide_> @listcommands
10:46:36 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
10:46:36 <lambdabot> dict dict-help docs dummy easton echo elements elite eurohaskell
10:46:36 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
10:46:36 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
10:46:36 <lambdabot> hoogle hoogle+ index jargon karma karma+ karma- kind lambda learn
10:46:38 <lambdabot> libsrc listchans listcommands listmodules lojban moo more paste pl
10:46:40 <lambdabot> pl-resume plugs pointless prelude quote remember repo-add repo-del
10:46:42 <lambdabot> [4 @more lines]
10:46:44 <Fide_> urgs
10:46:48 <lament> @pointless
10:46:49 <lambdabot> (line 1, column 1):
10:46:49 <lambdabot> unexpected end of input
10:46:50 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
10:46:52 <lambdabot> expression
10:46:58 <lament> @pointless \x -> x x x x
10:46:59 <lambdabot> join (join (join id))
10:47:12 <ski> @type (1 `negate`)
10:47:13 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
10:47:18 <vegai> this one's fun, came up earlier
10:47:23 <vegai> @pl \x y -> [x,y]
10:47:24 <lambdabot> (. return) . (:)
10:47:25 <BigDuke> that doesnt seem to work ski
10:47:27 <BigDuke> ive tried it
10:47:39 <BigDuke> vegai, it was me :)
10:47:53 <lament> @lojban
10:48:01 <lament> wtf does that do
10:48:07 <lament> @lojban blah blah
10:48:20 <vegai> @lojban coi
10:48:25 * vegai shrugs.
10:48:28 <vegai> I guess onthin
10:48:31 <lambdabot> ERROR: 501 Syntax error, illegal parametersERROR: 501 Syntax error,
10:48:31 <lambdabot> illegal parameters
10:48:33 <lambdabot> ERROR: 501 Syntax error, illegal parameters
10:48:38 <arjanb> @help lojban
10:48:38 <lambdabot> I perform dictionary lookups via the following 14 commands:
10:48:38 <lambdabot>  @all-dicts .. Query all databases on dict.org
10:48:38 <lambdabot>  @devils ..... The Devil's Dictionary
10:48:38 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
10:48:38 <lambdabot>  @elements ... Elements database
10:48:39 <lament> sexy
10:48:40 <vegai> ah, something.
10:48:41 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
10:48:43 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
10:48:44 <lambdabot> [8 @more lines]
10:49:00 <lament> @lojban lojban
10:49:06 <thedward> @lojban xu do tavla fo la lojban
10:49:21 <lament> hm
10:49:21 <BigDuke> anyone else suggestions for `infix` unary functions?
10:49:23 <lambdabot> ERROR: 501 Syntax error, illegal parameters
10:49:27 <CosmicRay> ffi question.  what is the most elegant way to expose a set of #defines in a C library relating to numeric error values?  There are about 100 of them, the numbering is not contiguous (so enum doesn't work).  Is there an elegant way to turn them into a data structure and convert back and forth somehow?  To do this in an automated fashion by inspecting the .h file?
10:49:28 <lament> does everyone in this channel speak lojban or something?
10:49:38 <CosmicRay> I don't even know what lojban is
10:49:54 <vegai> lament: yes. Surprisingly enough, it's called #lojban
10:49:55 <lament> that's good
10:50:06 <lament> vegai: no! It's called #haskell!
10:50:10 <vegai> :-)
10:50:23 <lambdabot> ERROR: 501 Syntax error, illegal parametersERROR: 501 Syntax error,
10:50:23 <lambdabot> illegal parametersERROR: 501 Syntax error, illegal parametersERROR:
10:50:23 <lambdabot> 501 Syntax error, illegal parametersERROR: 501 Syntax error, illegal
10:50:23 <lambdabot> parametersERROR: thread killed
10:50:35 <lament> aww
10:50:37 <thedward> I guess lambdabot doesn't like lojban
10:50:47 <lament> yeah
10:50:50 <Fide_> hasElement [] [x] = False
10:50:50 <Fide_> hasElement (y:xs) [x] | [y] == [x] = True
10:50:50 <Fide_>                       | otherwise = hasElement xs x
10:50:53 <lament> that shows that lambdabot has good taste!
10:51:16 <Fide_> I does not really know, that I use [x] or x
10:51:33 <CosmicRay> Fide_: if you are looking for the API reference, loko here: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
10:51:51 <CosmicRay> Fide_: probably you should have just used x and y everywhere
10:52:04 <CosmicRay> Data.List.elem does what you want as well
10:52:46 <Fide_> what is Data?
10:53:12 <Fide_> I know now, that type is equal to class but data?
10:54:20 <CosmicRay> never mind, elem is in the Prelude as well
10:54:24 <CosmicRay> Data.List is a module
10:54:30 <CosmicRay> you can access its functions by using "import Data.List"
10:54:55 <lament> @hoogle [a] -> a -> Bool
10:54:57 <lambdabot> Prelude.notElem :: Eq a => (a -> [a] -> Bool)
10:54:57 <lambdabot> Prelude.elem :: Eq a => (a -> [a] -> Bool)
10:54:57 <lambdabot> List.genericIndex :: Integral a => ([b] -> a -> b)
10:55:00 <Fide_> hmm I thought I heard something about Data XYZ
10:55:01 <lament> there you go :)
10:55:27 <lament> and yes
10:55:40 <CosmicRay> Fide_: ah, "data", not "Data".  It is a way of defining a custom type.
10:55:40 <lament> a -> [a] is a nicer ordering than [a] -> a like you had
10:55:49 <CosmicRay> Fide_: similar in concept to typedef in C
10:56:02 <Fide_> oh haskell is case sensitive?
10:56:07 <CosmicRay> Fide_: yes
10:56:17 <lament> although i guess for hasElement [a] -> a makes more sense....
10:56:19 <lament> nvm
10:56:24 <Fide_> I am not a C programmer
10:56:39 <CosmicRay> Fide_: also, all types, constructors, and module names must start with an uppercase letter.  All other identifiers must start with a lowercase letter.
10:56:43 <CosmicRay> Fide_: what other languages do you know?
10:57:00 <Fide_> Pascal/Delphi and Java
10:57:06 <lament> ouch
10:57:08 <CosmicRay> heh
10:57:11 <Fide_> but it sound's like enum
10:57:18 <lament> ocuh
10:57:19 <ski> BigDuke : answer, yes one can use negate as infix, but it also assumes that your 'number' is a function (which is not impossible)
10:57:28 <CosmicRay> Fide_: data sounds like enum?
10:57:37 <lament> CosmicRay: data does sound like enum
10:57:45 <CosmicRay> hmm.  it doesn't to me.
10:57:48 <BigDuke> huh, but why does it do that ....
10:57:51 <CosmicRay> lament: why does it to you?
10:57:53 <lament> when all constructors are nullary
10:58:07 <CosmicRay> ok, I guess I could see that.
10:58:29 <CosmicRay> enums in C have some, erm, weird properties though.  dunno about java.
10:58:30 <lament> which is the first usage of data in any haskell tutorial
10:58:43 <lament> (i hope :) )
10:59:04 <Fide_> mom I looking for an example
10:59:15 <CosmicRay> Fide_: an example usage of "data"?
10:59:48 <ski> (Fide_ : 'data' would be an example of what i called 'type former' above)
11:00:18 <ski> data Menge a = Create | Insert a (Menge a)
11:00:20 <BigDuke> @type 1 `negate`
11:00:21 <CosmicRay> Fide_: I would once again highly recommend this tutorial: http://www.isi.edu/%7Ehdaume/htut/
11:00:21 <lambdabot> bzzt
11:00:28 <CosmicRay> but here's an example from the Prelude:
11:00:29 <ski> @type (1 `negate`)
11:00:31 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
11:00:33 <CosmicRay> data Bool = False | True
11:00:36 <CosmicRay> here's another example:
11:00:41 <CosmicRay> data Maybe a = Nothing | Just a
11:01:00 <lament> i wish there was a good newbie-oriented haskell tutorial
11:01:04 <lament> then maybe i would learn haskell one day.
11:01:09 <flodin> are there any commonly used haskell interpreters / compilers that are written in haskell?
11:01:14 <CosmicRay> flodin: GHC is
11:01:20 <flodin> aha
11:01:33 <CosmicRay> flodin: this is why it's so hard to port.  chicken-and-egg bootstraping issues. ;-)
11:01:52 <pejo> lament, could get a book from your local library. The craft of functional programming by Thompson is supposed to be good for beginners.
11:01:53 <CosmicRay> lament: some of us are working on one
11:02:12 <thedward> pejo: I second that recommendation; I'm working through it right now.
11:02:17 <flodin> CosmicRay: why not use an interpreter done in C to bootstrap it then?
11:02:19 <CosmicRay> lament: I'd echo that Haskell: Craft of FP suggestion.  probably the very best thing available.
11:02:31 <CosmicRay> flodin: because it requires some of GHC's extensions that nobody else hase
11:02:33 <CosmicRay> s/hase/has
11:02:34 <lament> CosmicRay: working on a book, or an online tutorial?
11:02:38 <Fide_> data Symbol = Variable Int
11:02:38 <Fide_>             | Funktion Int deriving (Eq, Read, Show)
11:02:43 <CosmicRay> lament: probably online
11:02:50 <Fide_> it looks more like enum for me
11:02:54 <lament> CosmicRay: i doubt my local library is powerful enough :)
11:02:54 <flodin> hrm too bad. They ought to make it independent of those extensions. GCC doesn't require GCC to compile
11:03:00 <CosmicRay> lament: there is also YAHT, which is the best online tutorial currently: http://www.isi.edu/%7Ehdaume/htut/
11:03:09 <CosmicRay> lament: amazon.com is ;-)
11:03:26 <ski> Fide_ : an enum can't contain arbitrary ints
11:03:33 <lament> CosmicRay: i'm not paying money for this :)
11:03:41 <pejo> Fide, call it an enum if you wish, but you can't construct a binary tree with enums afaik. So it's not really a comparison that works very well.
11:04:21 <lament> yeah, i'm reading yaht
11:04:29 <CosmicRay> lament: I also had a brief 5-page intro to the language in Free Software Magazine here: http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
11:04:48 <CosmicRay> it probably focuses more on I/O than YAHT, which IMHO is the main weakness in YAHT (and 80% of the rest of haskell tutorials)
11:05:18 <lament> heh
11:05:29 <Fide_> pejo: Syble can be Variable or Funktion that sounds more enums like something else
11:05:33 <Fide_> *Symbol
11:05:53 <pejo> flodin, why?
11:06:06 <flodin> pejo: so that it will be easier to port
11:06:26 <lament> Fide_: there's simply nothing in java or pascal that's at all like data
11:06:47 <lament> Fide_: those languages have very different type systems
11:07:04 <CosmicRay> for whatever reason, a lot of people, including tutorial authors, seem to think that I/O in Haskell is (choose one): 1) difficult, 2) irrelevant, 3) too hard to understand.
11:07:09 <CosmicRay> I disagree with all three.
11:07:36 <lament> maybe it's just that it feels like cheating :)
11:07:38 <Fide_> yes, there are imperative but otherwise what should data be? Symbol = Variable or Symbol = Funktion
11:07:38 <basti_> hi
11:07:41 <pejo> CosmicRay, thats because we're not as smart as you. :-)
11:07:55 <lament> Fide_: it's spelled "function"
11:08:08 <ski> lament : not in german
11:08:17 <Fide_> data Symbol = Variable Int
11:08:17 <Fide_>             | Funktion Int deriving (Eq, Read, Show)
11:08:18 <CosmicRay> pejo: I don't rank myself in the upper percentiles of intelligence in this channel ;-)
11:08:24 <Fide_> there is Funktion
11:08:26 <lament> heh
11:08:37 <Fide_> and noch function
11:08:44 <Fide_> that was wrong in that case
11:09:13 <CosmicRay> pejo: how could I, with the main author of GHC, a person that implemented Deflate in Haskell, and a guy that wrote a Perl6 interpreter in Haskell all hanging out here?
11:09:25 <CosmicRay> I've just cloned some of Python's standard library, really ;-)
11:10:14 <lament> wow you guys are smart
11:10:21 <lament> i'm even too stupid to use a mouse with more than one button :(
11:10:34 <CosmicRay> heh, mac user? ;-)
11:11:00 <pejo> CosmicRay, channel is pretty big, there's room for more. ;)
11:11:41 <CosmicRay> really, I think the reason that few have covered I/O very well is the history of haskell.  It seems that it's only recently been gaining ground outside academia, where people care about pesky things such as user interfaces and interaction ;-)
11:12:16 <CosmicRay> if you just need a thesis paper, it doesn't even matter if the compiler works, as long as you can talk about what it is supposed to do, and how one might use it if it could do I/O :-)
11:12:40 <pejo> CosmicRay, I think you're underestimating academia. People understand the importance of interaction with the outer world, Monads for example aren't exactly a new idea.
11:13:32 <dcoutts> @hackage help
11:13:33 <lambdabot> Unknown command, try @listcommands.
11:13:51 <dcoutts> not included yet, oh well
11:14:36 <CosmicRay> pejo: it just seems that I/O is an afterthought in a lot of languages with roots in academia.
11:14:47 <CosmicRay> No arguments about monads, but then they're used for a lot more than just I/O
11:14:58 <CosmicRay> not to mention being an interesting device good for several papers ;-)
11:15:02 <pejo> CosmicRay, and reading papers by Simon and Simon for example I say they try pretty hard to have a sound theory and a usable implementation. GADT's for example.
11:15:15 <CosmicRay> certainly, no arguments about them
11:15:18 <CosmicRay> they actually write code
11:15:22 <CosmicRay> totally different
11:15:37 * CosmicRay knows some computer scientists that don't
11:16:13 <SamB> how do they do experiments without writing code?
11:16:29 <CosmicRay> grad students? ;-)
11:16:32 <lament> thought experiements
11:16:33 <pejo> SamB, have an undergrad do it.
11:16:41 <CosmicRay> or thought experiments, yes.
11:16:59 <dcoutts> my department is mostly theoretical, lots of logic and proving things
11:17:07 <pejo> SamB, and far from all papers have any experiments in them.
11:17:26 <CosmicRay> dcoutts: yeah, and nothing wrong with that.  I'm just saying that when you are doing those sorts of things, you probably don't care that much about fancy I/O in a language
11:17:34 <CosmicRay> especially if said language has an interactive mode
11:17:40 <dcoutts> true
11:18:04 <CosmicRay> I had an entire semester class once, covering Lisp and Prolog, and I don't think I learned how to do I/O in either language *at all*.
11:18:10 <dcoutts> Igloo and I are in the group that actually write usable software :-)
11:18:11 <CosmicRay> everything was done in an interpreter.
11:18:20 <CosmicRay> dcoutts: I like that group :-)
11:18:21 <dcoutts> well are supposed to write usable software
11:18:38 <dcoutts> "Programming Tools Group"
11:18:44 <CosmicRay> dcoutts: ooo, that was a perfect opportunity to make a remark about Igloo representing a file as a list of Bools ;-)
11:18:59 <dcoutts> ha!
11:19:14 <SamB> pejo: how do they justify the use of the term "scientist" to describe someone who does not do experiments?
11:19:26 <lament> SamB: historical reasons
11:19:34 <dcoutts> SamB, by claiming to be mathmaticians
11:19:49 <CosmicRay> SamB: einstein didn't exactly design a lightspeed craft to verify his theories ;-)
11:19:53 <SamB> lament: historical reasons?
11:20:14 <aheller> SamB: I'm pretty sure it was Djikstra who thought "Computer Science" was a bad name for the field.
11:20:19 <lament> SamB: CS is called a science for no particular reason
11:20:44 <lament> but you can't just call it "math", that would be silly
11:20:45 <SamB> lament: not because it involves experiments?
11:20:59 <dcoutts> indeed, my department also resisted adding "Science" to the name of it's degrees for as long as it could
11:21:05 <reffie> so what should CS be called?
11:21:05 <aheller> I think Feynman also claimed it was not a science.
11:21:26 <dcoutts> reffie, our undergrad degreee used to be called "Computation"
11:21:37 <CosmicRay> that sounds like arithmetic with pencil and paper
11:21:40 <vegai> ours is called "Mathematical Information Techonolgy"
11:21:56 <vegai> I'm not sure if that "MIT"-thing is an accident or not
11:21:56 <ski> dcoutts : sounds nice
11:21:59 <lament> information technology / informatics is how it is called in russia
11:22:11 <dcoutts> CosmicRay, no that'd be computing, not computation :-)
11:22:55 <lament> the best name is still "Post-Turing decline in formal systems theory"
11:23:04 <aheller> :)
11:23:15 <CosmicRay> haha
11:23:43 <CosmicRay> dcoutts: oh, with computation you get to use a slide rule? ;-)
11:24:15 <CosmicRay> over here (USA) Information Technology would be more a business side, somebody that buys hardware or manages an IT department in a corporation
11:24:15 <dcoutts> :-)
11:24:45 <dcoutts> CosmicRay, we forwn on IT, it's too buisness orientated :-)
11:25:02 <dcoutts> all databases and networks and similar boring things :-)
11:25:43 <CosmicRay> heh
11:26:56 <ski> deductive databases are cool
11:27:01 <pejo> aheller, have you read "Cargo Cult Science" by Feynman?
11:27:32 <aheller> Not sure, actually.
11:28:06 <dcoutts> @seen Lemmih
11:28:08 <lambdabot> I saw Lemmih leaving #haskell 2 hours, 10 minutes and 59 seconds ago.
11:32:19 <Igloo> CosmicRay: You should write a more traditional variant and see how the speed compares
11:42:51 <mwc> kind of a noob question; but what's a good way to create a "subtype" of Int that's constrained to either 0 or 1?
11:43:03 <mwc> Maybe use bool?
11:43:12 <mwc> seems like a better way to do it now that I think of it
11:44:50 <autrijus> haskell has no subtyping, so you need to use Bool :)
11:45:04 <mwc> yeah
11:45:11 <ibid> Bool is not a subtype of Int, either
11:45:28 <ibid> but you could probably construct a two-element type that implements all the right classes
11:45:29 <mwc> doesn't matter; I need a way to map computational basis vectors to ints
11:45:40 <autrijus> you can even do the funky thing and implement "instance Num Bool".
11:45:41 <mwc> ibid: that's what I was thinking of doing; but this is better
11:46:26 <thedward> or something like: data Bit = One | Zero ?
11:47:06 <mwc> thedward: yeah, but this Bool way gives me a nice way to convert it
11:47:39 * thedward nods.
11:58:26 * SamB violates dependencies (oh no!)
11:58:35 * shapr depends on violators!
12:00:08 <SamB> in particular, I install libstdc++5-3.3-doc without a sufficiently up-to-date version of gcc-3.3-base!
12:00:55 <CosmicRay> Igloo: yeah it would be interesting.  a bool in haskell occupies 32 bits of ram, yes?
12:01:09 <CosmicRay> however, yours works so I don't have lots of motivation to do so
12:01:53 <SamB> CosmicRay: most likely more!
12:02:03 <CosmicRay> SamB: heh
12:02:24 <SamB> because, of course, it is boxed
12:05:50 <Igloo> Grr, it looks like I can't tell if an exception was caused by EOPNOTSUPP
12:33:39 <shapr> Silly question, does this look like the right way to get a SHA1 Hash? --> showHex (fromOctets 16 $ hash $ map (fromIntegral . Data.Char.ord) "foo") ""
12:34:09 <ulfdoz_> bye
12:36:06 * shapr gives up on cryptolib and uses SHA1 directly
12:46:09 <autrijus> @plugs ((1 :: (Num t) => t) :: (Real t) => t) :: Int
12:46:14 <lambdabot> 1
12:46:20 <autrijus> cool!
13:12:21 <TheHunter> @plugs let f :: (forall t. Num t => t) -> Int; f (x::Int) = x in f 1
13:12:21 <lambdabot> parse error on input `.'
13:12:49 <TheHunter> oh, no glasgow-exts...
13:16:27 <TheHunter> fwiw, ghc-6.2 allows that, i'm not sure about ghc-6.4, ghc-6.5.20050720 gives an error and it's a consious decision that the current cvs ghc doesn't allow it.
13:18:01 <autrijus> 6.4 gives
13:18:01 <autrijus> x.hs:3:49: Couldn't match `Int' against `forall t. (Num t) => t'
13:19:29 <TheHunter> yeah, that's the one I get with ghc-6.5.20050720, too.
13:20:04 <autrijus> I'm trying to think of a use for this and fails
13:20:06 <TheHunter> strange that both hugs and ghc accept your thing, it doesn't look like it's Haskell 98
13:20:31 <autrijus> it is h98 I think; annotated terms are just terms.
13:20:36 <autrijus> and you can annotate any term.
13:21:13 <TheHunter> with something like Num t => t. I don't really know, but I don'
13:21:19 <TheHunter> t believe it.
13:21:59 <autrijus> "Practical type inference for arbitary-rank types"++ # very good tutorial to local type inf, exactly the thing I need
13:22:58 <ski> autrijus : hm, url ?
13:23:08 <TheHunter> It's not awfully useful, but it can be handy sometimes, e.g. if you want to write a hof that takes a monadic action, but you want to hide which monad is actually used.
13:23:12 <kosmikus> the topmost on spj's homepage
13:23:20 <TheHunter> (subsumption in patterns, that is)
13:23:46 <autrijus> TheHunter: from the definition:
13:24:08 <autrijus> exp ::=    exp0 :: [context =>] type   |   exp0
13:24:22 <kosmikus> isn't a pattern type annotation already beyond Haskell98?
13:24:30 <dcoutts> Igloo, any idea how to find the build tools that a cabal package requires? eg if it needs happy/alex/cpphs/c2hs etc?
13:24:34 <autrijus> this looks recursive to me
13:25:04 <TheHunter> kosmikus, autrijus is talking about the  ((1 :: (Num t) => t) :: (Real t) => t) :: Int thing.
13:25:09 <Igloo> I don't understand the question
13:25:15 <Igloo> (but probably don't know the answer anyway)
13:25:21 <autrijus> ski: http://research.microsoft.com/Users/simonpj/papers/putting/
13:25:22 <TheHunter> i'm very surprised that this is haskell98.
13:25:34 <dcoutts> Igloo, what does your .cabal dependency program do about build tools?
13:25:54 <dcoutts> you extract the build-depends, but what about tools?
13:26:00 <Igloo> I haven't looked at that yet
13:26:03 <kosmikus> TheHunter: interesting, yes
13:26:11 <dcoutts> or do the cabal files list "build-depends: c2hs" ?
13:26:21 <Igloo> (the tool doesn't exist yet; i started writing it when I was packaging gtk2hs, but ran into the problems we talked about)
13:26:24 <dcoutts> Igloo, I suspect they are just not specified
13:26:42 <Igloo> I'd have thought they were listed as language extensions or their own special field, but I haven't looked
13:27:03 <ski> autrijus : ty  (http://research.microsoft.com/Users/simonpj/papers/higher-rank/index.htm seems to be a later version. yes ?)
13:27:04 <dcoutts> where is SyntaxNinga when we need him! :-)
13:27:47 <autrijus> looks like so. thanks!
13:28:34 <kosmikus> TheHunter: allowed according to the report, yes
13:33:51 * TheHunter wonders if that binds the type variable t somewhere
13:34:17 <TheHunter> if not, i would argue this thing should be disallowed.
13:34:35 <kosmikus> TheHunter: if I read the Report correctly, such annotations are interpreted just like top-level annotation, i.e. the free variables are implicitly universally quantified
13:34:56 <kosmikus> that seems to be in line with ghc-6.4 behaviour
13:35:53 <TheHunter> so it means (1 :: forall t. Num t => t) ?
13:38:50 <TheHunter> @plugs let x = (1 :: Num t => t) in (x :: Int, x :: Integer)
13:38:51 <lambdabot> Couldn't match `Integer' against `Int'
13:38:55 * mwc ponders harassing dcoutts_ about that 0.9.8.1 release again
13:39:16 <dcoutts> mwc, oh yes... comming
13:39:41 <ski> TheHunter : mono. restr. ?
13:39:49 <TheHunter> yes.
13:40:26 <TheHunter> i don't like this at all...
13:41:04 <mwc> I'm putting together an app that might make a nice gtk2hs screenshot. Quantum computer controller; with a sort of widget for displaying the circuit and a gtksourceview window for composing the circuit
13:41:54 <TheHunter> there's probably a policy though, that all h98 programs should compile under -fglasgow-exts
13:42:03 <kosmikus> TheHunter: well, it's not really worse than the implicit quantification policy on the top-level
13:42:27 <TheHunter> wait a minute, that's not true. f $x or f ?x are different.
13:42:34 <kosmikus> TheHunter: that policy is not true
13:43:11 <TheHunter> kosmikus, imho, it's worse, because patterns are treated totally different
13:43:34 <kosmikus> yes, and you can't use forall as a type variable :)
13:43:35 <kosmikus> etc. etc.
13:43:47 <TheHunter> right, good one.
13:43:49 <dcoutts> mwc, sounds cool, a screenshot or twp and a little blurb would be cool, see what we've put together for other apps: http://haskell.org/gtk2hs/archives/category/screenshots/
13:44:36 <TheHunter> actually i also don't like how forall a. ... brings a into scope and leaving out the forall doesn't. The other way round would make much more sense.
13:45:05 <kosmikus> you mean this new "scoped variables" thing?
13:45:08 <kosmikus> I don't like it either
13:45:22 <kosmikus> convenient, but a hack
13:45:30 <TheHunter> no, actually i like it very much.
13:45:56 <TheHunter> but i think the roles of explicitely writing the forall and leaving it out should be switched.
13:46:05 <kosmikus> that'd be much better
13:46:24 <kosmikus> but it's still strange
13:46:31 <TheHunter> so |foo :: (forall a. a -> a)| and |foo :: forall a. a -> a| wouldn't be different.
13:46:38 <kosmikus> I'd like better if an unquantified type variable is really treated as free
13:47:51 <kosmikus> uh, they're different?
13:48:09 <TheHunter> how would that be different from universally quantified?
13:48:30 <TheHunter> sure, the second one brings a into scope, the first one doesn't
13:48:37 <kosmikus> oh no
13:49:17 <kosmikus> well, with "
13:49:19 <kosmikus> sorry
13:49:53 <kosmikus> with "free" I mean that I could write something like "toUpper :: a -> a"
13:50:35 <ski> TheHunter : the second brings 'a' into scope where ? in the impl ?
13:50:57 <TheHunter> ski, in the body of the definition, since 6.4
13:51:14 <ski> TheHunter : ok, didn't know this. ty
13:51:45 <TheHunter> this was like ghc6.4's most convenient new feature.
13:52:26 <kosmikus> TheHunter: with free type variables allowed, one could essentially give partial type signatures, such as omitting class constraints, which are sometimes tedious to write down and keep up-to-date
13:53:00 <TheHunter> kosmikus, ah, I see. That'd be indeed great.
13:53:40 <TheHunter> you ever proposed that?
13:53:59 <ski> also, when doing stuff with existential types, one could at all give local type signatures for local functions ..
13:54:30 <ski> (i.e. if the local function has nonlocal (value-)var)
13:55:01 <kosmikus> TheHunter: now that I think of it, I'm not sure I did (well, not to spj at least)
13:55:17 <kosmikus> we certainly discussed it at .uu.nl
13:56:30 <TheHunter> ski, i'm not sure what you mean. Local type signatures are possible with existentials, as far as I see.
13:56:34 <kosmikus> I think there's not a big chance this gets through, because it is extremly non-backwards-compatible
13:57:24 <ski> TheHunter : hm, you're right. (confused it with pattern type asciptions ..)
13:57:24 <TheHunter> hmm, you could ask for a new 'quantifier' "free".
13:57:30 <ski> bah
13:57:52 <TheHunter> The roles of |free a. ...| and just |...| could be interchanged in haskell2 then.
13:57:53 <kosmikus> TheHunter: I think this was proposed in "First-class modules" by SPJ and Mark Shields
13:58:33 <ski> TheHunter : hm, can't one just make all tyvars in typesignature in scope in the impl ?
13:59:20 <TheHunter> kosmikus, thanks, gotta read that one.
13:59:22 <kosmikus> TheHunter: just checked; it proposed a "free t in ..." construct, but it's very similar
14:00:32 <TheHunter> ski, in |(forall a. Num a => a) -> b|, it doesn't make any sense to scope |a|.
14:01:48 <ski> TheHunter : hm, .. how about positive forall-bound, then ?
14:02:19 <TheHunter> that'd be a hack.
14:02:34 <kosmikus> it's a hack anyway
14:02:59 <TheHunter> true.
14:05:40 * TheHunter wonders if he should be ashamed of using acroread instead of xpdf.
14:07:37 <xerox> Evince is pretty good.
14:07:43 <jlouis> TheHunter: in that case, I should be ashamed too
14:07:53 <dcoutts> xerox, just what I was about to say :-)
14:08:24 <xerox> :-)
14:09:18 <TheHunter> i'll try it, even if that means installing all the gnome libraries :(
14:09:50 <xerox> I wonder how could you have lived without them.
14:09:55 <dcoutts> TheHunter, I'm sure it requires loads of gnome libs, but they're good for you!
14:10:08 <ski> gpdf ?
14:11:07 <xerox> Goodnight people. Fun with GNOME libs ;)
14:11:24 <TheHunter> if there is some pdf viewer that can be used nicely with two-column-pdfs, that'd be a killer feature.
14:12:56 <SamB> TheHunter: people are liking to use paper for this purpose
14:13:33 <TheHunter> but for some reason most (opensource) programs fail to provide some obvious features.
14:14:40 <TheHunter> SamB, that's not a great excuse for a pdf viewer though, it's single purpose is to allow people to view pdfs on the screen.
14:15:07 <TheHunter> and i don't even have a printer here.
14:16:53 <SamB> I thought PDF was a mechanism for electronicly transporting print? Print Download Format, you know.
14:17:54 <kosmikus> no, evince has too many dependencies for me ... still xpdf for now, thus
14:20:37 <TheHunter> SamB, so you think i shouldn't be able to view them on the screen? that's silly. How should I even know if they're worth printing?
14:22:30 <kosmikus> portable document format, isn't it?
14:24:43 * SamB is indeed being silly
14:28:08 <Fide_> is there an logical operator like not legal in haskell?
14:28:55 <jlouis> Fide_: not?
14:29:03 <SamB> Hmm, apparantly the IOCCC winners are so evil that one of them even falls under US International Traffic in Arms Regulations...
14:29:05 <Fide_>  <-- not
14:29:06 <jlouis> you mean (/=) ?
14:29:16 <jlouis> nah, you don't
14:29:25 <reffie> \o/ _o FREEZE!
14:29:27 <jlouis> @type not
14:29:29 <lambdabot> Bool -> Bool
14:29:30 <Fide_> I mean A
14:29:33 <jlouis> ;)
14:29:43 <Fide_> ahh, k
14:29:50 <jlouis> if A has type Bool, not A is what you want ;)
14:29:54 <Fide_> than this is legal: insert xs [x] | not hasElement xs x = [x] ++ xs
14:30:48 <TheHunter> insert xs [x] | not (hasElement xs x) = [x] ++ xs
14:30:55 <TheHunter> or insert xs [x] | not $ hasElement xs x = [x] ++ xs
14:31:29 <Fide_> what does $ mean?
14:32:30 <TheHunter> f $ x = f x, but $ is right associative and has a low precedence.
14:32:55 <TheHunter> so f $ g $ h x = f (g (h x)). Can save you parenthesis.
14:33:19 <Fide_> I see
14:37:38 * lispy` disagrees with the lack of parens....
14:39:10 <astrolabe> Well, with a name like lispy, that's to be expected ;)
14:39:26 <Fide_> hmm I have some problems
14:39:51 <Fide_> why is this not allowed?
14:39:56 <Fide_>  hasElement (y:xs) [x] | [y] == [x] = True
14:40:13 <lispy`> you need another |
14:40:26 <dcoutts> huh? it looks ok to me
14:40:26 <lispy`> er wait
14:40:33 <Fide_>                       | otherwise = hasElement xs x
14:40:36 <lispy`> yeah, i misread that
14:40:42 <Fide_> *** Because        : unification would give infinite type
14:41:03 <lispy`> Fide_: do you have a case where you give False?
14:41:22 <Fide_> hasElement [] [x] = False
14:41:34 <Fide_> lispy`: I do
14:41:36 <lispy`> Fide_: also, hasElement xs x has a problem
14:41:37 <ski> ah
14:41:48 <ski> don't say [x] as argument
14:41:59 <ski> hasElement .. x = ...
14:42:05 <lispy`> maybe i'm on crack today
14:42:07 * lispy` shuts up
14:42:16 <ski> not [x], but x
14:42:24 <lispy`> yeah, that's basically what i was getting at
14:42:29 <lispy`> but for the wrong reason :)
14:42:35 <Fide_> why? [x] means this ist one element right?
14:43:05 <Fide_> x is a list and [x] one element or am I wrong?
14:43:23 <kosmikus> what's the type of hasElement supposed to be, Fide_?
14:44:00 <Fide_> kosmikus: has xs the Element x
14:44:14 <Fide_> hasElement [] [x] = False
14:44:14 <Fide_> hasElement (y:xs) [x] | [y] == [x] = True
14:44:14 <Fide_>                       | otherwise = hasElement xs x
14:44:28 <ski> if x is an element, then [x] is a *list* with that element as sole element
14:44:34 <kosmikus> not the meaning, the type
14:44:44 <ski> hasElement :: Eq a => Menge a -> a -> Bool
14:44:54 <ski> type Menge a = [a]
14:45:03 <lispy`> Menge?
14:45:10 <ehuber> hi
14:45:11 <ski> 'set' in german
14:45:17 <ski> hiya ehuber
14:45:18 <lispy`> ski: okay, thanks
14:45:23 <ehuber> i'm new :p  what's up
14:45:34 <kosmikus> ski: I wanted to hear that from Fide_; I'm not surprised you can give it ;)
14:46:31 <ski> kosmikus : he has already given it, http://rafb.net/paste/results/bGWjfZ14.html and http://rafb.net/paste/results/nQiA3O11.html
14:46:37 <kosmikus> ah, ok
14:46:45 <Fide_> ;)
14:47:00 <Fide_> thanks. the load worked now
14:48:00 <kosmikus> btw, your guards simplify to "y == x || hasElement xs x"
14:48:52 <Fide_> create and isEmpty works well :)
14:49:05 <Fide_> hasElement has some problems :/
14:50:01 <Fide_> ahh, no it works too
14:51:11 <Fide_> Program error: pattern match failure: insert instEq_v27 [1] 1
14:51:14 <Fide_> huh?
14:52:50 <SyntaxNinja> Fide_: that means there's a case youf ailed to account for
14:53:22 <dcoutts> SyntaxNinja, you're back! :-) we've got some cabal questions + patches for you
14:53:38 <SyntaxNinja> dcoutts: hey. I've been oyt of town. saw your emails,b ut haven't read them yet.
14:53:39 <kosmikus> hehe
14:53:46 <kosmikus> hey Syntax
14:54:35 <SyntaxNinja> hi kosmikus
14:54:41 <ski> Fide_ : it says that when e.g. first arg is '[1]' and second arg is '1', then you don't handle that case
14:54:46 <dcoutts> SyntaxNinja, we've implemented the feature we were talking about the other day about moving the building of the GHCi .o library to the "./setup build" phase
14:54:54 <SyntaxNinja> dcoutts: excellent!
14:55:03 <dcoutts> rather than the "./setup register" phase
14:55:07 * SyntaxNinja nods
14:55:14 <SyntaxNinja> as it should be.
14:55:15 <kosmikus> yeah, but you'll only get the patch if you accept our cabal2conf tool, too ;)
14:55:24 <dcoutts> heh heh :-)
14:55:36 <Igloo> What is conf?
14:55:51 <dcoutts> package.conf style files
14:55:51 <SyntaxNinja> cabal2conf?
14:56:02 <SyntaxNinja> why would you want that? :)
14:56:04 <Igloo> Isn't that what cabal is?
14:56:07 <Fide_> ski: it works with different values, but crashes with the same or am I need otherwise always?
14:56:11 <dcoutts> kosmikus, your turn to explain?
14:56:36 <kosmikus> well, I can try
14:57:09 <ski> Fide_ : you're should should handle that case, but apparently doesn't currently ..
14:57:11 * SyntaxNinja frowns at Igloo
14:57:15 <kosmikus> registration cannot take place during the normal installation phase in Gentoo, but must be during the post-installation phase
14:57:16 <Igloo> Syn?
14:57:21 <ski> Fide_ : gah s/you're/your/
14:57:26 <SyntaxNinja> Igloo: it's so much more! ;)
14:57:31 <Igloo> heh
14:57:38 <kosmikus> the reason is that normal installation is within a sandbox, without write access to the main file system
14:57:56 <kosmikus> Cabal doesn't allow specifying a non-standard package config file location, so it can't be done during that phase
14:57:57 <SyntaxNinja> kosmikus: I thought that these changes were to make it so that the --gen-script script will work for you
14:57:58 <Fide_> ski: k works :)
14:58:05 <kosmikus> yes, sure
14:58:16 <kosmikus> --gen-script is better than nothing
14:58:34 <kosmikus> but actually, having the package.conf file itself would be even nicer
14:58:52 <kosmikus> it would allow us to handle Cabal packages the same way we handle non-Cabal packages
14:58:56 <SyntaxNinja> so why not just make the cabal2conf tool a part of gentoo insteadc of a part of cbal?
15:00:11 <kosmikus> that's an option, but we thought it might be useful for other distributions, too
15:00:18 <kosmikus> or was there an even deeper reason, dcoutts?
15:00:46 <dcoutts> it makes things a bit tricky for bootstrapping cabal if our prog is seperate
15:01:18 <dcoutts> and we'd have problems if a package is using a different version of cabal than the one the our cabal2conf tool was built against
15:01:32 <ski> Fide_ : nice
15:01:49 <dcoutts> maintainance for us would be easier if it were a cabal feature
15:02:25 <SyntaxNinja> hmm
15:02:27 <dcoutts> other systems may also be leary of running a shell script as root outside of the sandbox
15:03:02 <kosmikus> yes, that's the main argument contra the script generation that I haven't given yet
15:03:07 <SyntaxNinja> the problem with it is that it breaks encapsulation.
15:03:50 <kosmikus> SyntaxNinja: it's not intended to be used by users, it's intended for packagers like us; we have to break certain abstractions, because there's an overlap in functionality
15:04:47 <kosmikus> Cabal does some things that Gentoo's package manager is for, and the Cabal way isn't necessarily compatible with Gentoo policy; I guess other distributions are likely to have similar problems
15:04:50 <SyntaxNinja> I would be happier if it could be supported in a more generic way somehow, or if cabal2conf could be just a gentoo tool. even if others aren't "meant" to use it; they will :)
15:04:57 <Fide_> ski: is not completly mathematicaly correct, but it does not matter :)
15:07:05 <dcoutts> hello back again?
15:07:28 <kosmikus> SyntaxNinja: what could "more generic" be?
15:09:16 <SyntaxNinja> kosmikus: well, a --package-conf= feature is a little closer, even better would be a --in-place (rather than --user or --system)
15:10:33 <SyntaxNinja> you know ,the gen-script feature is realy the best, because it'll work for all the compilers, any future compilers, and future versions of this compiler, even if ghc-pkg's syntax changes.
15:10:35 <kosmikus> ah, dcoutts told me that --package-conf= was already rejected due to similar reasons
15:11:13 <SyntaxNinja> right, but --in-place would probably be accepted, especially if it helps me support multiple inter-dependent packages in a single directory
15:11:19 <dcoutts> but we already need to know everything about the ghc-pkg syntax
15:11:59 <SyntaxNinja> why?
15:12:59 <dcoutts> SyntaxNinja, for all the other non-cabal packaes we've got
15:13:02 <kosmikus> what would in-place do?
15:13:14 <kosmikus> create the config file locally?
15:13:18 <dcoutts> sylvan, for re-registering packages when ghc is reinstalled
15:13:37 <dcoutts> oops I meant to direct that to SyntaxNinja not sylvan
15:13:43 <kosmikus> dcoutts: would in-place work for us?
15:14:06 <dcoutts> kosmikus, if it's a well known and stable file name then yes
15:14:18 <Fide> returned
15:14:19 <kosmikus> I think so, too
15:14:23 <SyntaxNinja> dcoutts: but do you see where I'm coming from with the abstraction problem? currently, cabal abstracts away the package.conf file; the user doesn't have to know about it.
15:14:36 <Fide> I love 24h disconnects :)
15:15:05 <dcoutts> SyntaxNinja, yes I understand that, but I'm saying that packaging systems are already on the dirty side of that abstraction
15:15:07 <SyntaxNinja> but we should also explore just distributing the cabal2conf tool separately.
15:15:40 <SyntaxNinja> so there's a bootstrapping problem because you want to use the cabal2conf tool for cabal itself?
15:15:53 <dcoutts> SyntaxNinja, and since we're already on the dirty side of the packaging abstraction we could do with a bit more info from Cabal
15:15:57 <kosmikus> SyntaxNinja: I can see your point, but I wouldn't be so afraid about the users. Cabal is more than a tool for users, it's as much a tool for authors. The cabal2conf wouldn't need to be in the main cabal interface, I guess it could be a binary that comes with the Cabal distribution.
15:16:08 <dcoutts> SyntaxNinja, yes we want to use the cabal2conf tool for cabal itself
15:16:20 <dcoutts> it's doable, but not so nice
15:16:47 <dcoutts> I've already done it, it compliles against the files living in dist/build
15:16:58 <SyntaxNinja> what if cabal just generates the package.conf file during build and doesn't delete it unless you clean?
15:17:08 <dcoutts> already assuming things behind your nice abstraction, like directory layouts :-(
15:17:09 <kosmikus> otoh, I'm still thinking that --in-place would be ok as well
15:17:49 <dcoutts> just so long as we have some reliable way of getting the package.conf file
15:18:02 <kosmikus> if that package.conf generation is a documented feature that will remain, that's ok, I guess
15:18:34 <dcoutts> having an expicit option to write it out to a file or stdout would be ideal
15:18:43 <SyntaxNinja> OK I'll think on it a bit.
15:18:51 <kosmikus> thanks
15:18:59 <kosmikus> we'll think about it again, too
15:19:08 <dcoutts> especially if it's marked "don't use this! for packagers only"
15:19:21 <kosmikus> the ghci-lib thing is noncontroversial, though, right?
15:19:27 <SyntaxNinja> I don't want to get in the way of packaging; that's one of my main reasons for writing cabal, but I have gone out of my way to make things good for packages and users at the same time, and I'd hate to break that principal if there are better solutions.
15:19:28 <SyntaxNinja> kosmikus: right.
15:20:26 <dcoutts> SyntaxNinja, sure and it is indeed a great help, our cabal build/installation style is so much simpler and more unform that our ther packages
15:20:44 <dcoutts> unform than our other packages
15:20:50 <SyntaxNinja> cool :)
15:21:19 <kosmikus> eclasses are so nice; does debian have something like that?
15:21:24 <dcoutts> we just need a bit more info in a couple places :-) to make it "Just Work"tm
15:22:02 * SyntaxNinja nods
15:22:41 <dcoutts> SyntaxNinja, we can envisage packaging every cabal package under the sun using nice tools that automate everything
15:23:08 <dcoutts> but it needs a little work in places to make sure that everything is really automatable
15:23:38 <dcoutts> but when it is, it will make packaging Haskell progs/libs very easy and bring them to a wide audience
15:23:54 <SyntaxNinja> what if we had a cabal-register executable like we discussed the other day?
15:24:13 <dcoutts> that is roughly what our cabal2conf things does
15:24:17 <dcoutts> isn't it?
15:24:55 <kosmikus> cabal-register would combine cabal2conf with the actual call to ghc-pkg?
15:25:10 <SyntaxNinja> yeah. basically just like ./setup register, but you wouldn't have to trust any user code.
15:25:30 <dcoutts> hmm, that might do
15:25:52 <dcoutts> it would cope with ghc-6.2 style packages too?
15:26:27 <kosmikus> I had though about that. I think it might be a bit tricky to get it right, though.
15:26:52 <dcoutts> kosmikus, what about our requirement to be able to re-register packages when reinstalling ghc?
15:26:55 <kosmikus> there'd only ever be one cabal-register binary on the machine, which would need to be able to handle all ghc versions.
15:26:57 <SyntaxNinja> yeah, it would work for 6.2 as well
15:27:42 <kosmikus> it'd also need to be able to work with package-config files generated by different cabal versions
15:27:54 <kosmikus> I have a certain feeling it's less robust
15:28:44 <SyntaxNinja> it would input a cabal file, not a package-config file. why would it have to work with multipel cabal versions? because of updating?
15:28:51 <kosmikus> dcoutts: in principle, cabal-register could do re-registration, I guess
15:28:57 <SyntaxNinja> as long as you updated that thing last, it would work :)
15:29:15 <dcoutts> SyntaxNinja, so currently with gentoo we have a system where if ghc is reinstalled (for whatever reason) then all the libs that worked with that version of ghc are re-registered. It saves having to reinstall them all. At the moment that relyies on the fact that we save the package.conf fiels for each package
15:29:16 <kosmikus> dcoutts: we call cabal-register for .cabal files the same way we call ghc-pkg directly for package.conf files
15:29:39 <dcoutts> if it can be made to work then fine
15:29:52 <kosmikus> cabal-register would work on some sort of file, wouldn't it?
15:30:03 <kosmikus> or how does it know what to do for a specific package?
15:30:08 <SyntaxNinja> the .cabal file and the .installed-package-info or whatever it is
15:30:17 <SyntaxNinja> same thing that ./setup register works on
15:30:39 <SyntaxNinja> re-registering is actually a feature I'd like to include w/ cabal itself someday
15:30:41 <kosmikus> so we'd need to save those two and could register, unregister, and re-register at any time
15:30:44 <SyntaxNinja> btw, don't you have to recompile it too?
15:30:53 <dcoutts> SyntaxNinja, the .installed-package-info exists for all kinds of cabal isntalls? not just Distribution.Simple ones?
15:31:48 <dcoutts> sorry too many questions all at once :-)
15:32:09 <SyntaxNinja> dcoutts: no, not necessarily.
15:34:45 <dcoutts> SyntaxNinja, as for recompiling, this is only when re-installing the same version of ghc, not for upgrades. For upgrades, yes, all libs need recompiling
15:34:47 <SyntaxNinja> er, I think it's generated during configure; so cabal2conf would need this file too, fwiw.
15:35:37 <kosmikus> the longer I think about it, the more I like the --in-place idea
15:35:58 <kosmikus> but maybe I should spend some more time to let this discussion sink in
15:36:27 <dcoutts> yes I think cabal2conf does read the .installed-package-info file (whcih is one of the things which worries me about the approach - that it might not work in all cases)
15:37:16 <dcoutts> yes, lets deal with the ghci libs patch first and we can come back to this issue
15:37:24 * SyntaxNinja nods. there's no way to generate hte package.conf file without the .instaled-package-info file.
15:38:04 <dcoutts> (but hopefully before cabal-1.2 because we're hoping to make that a requirement of our new cabal style packaging stuff)
15:39:14 <kosmikus> dcoutts: I think we can safely go with cabal2conf as a cabal patch applied within Gentoo for the next Cabal version; it's just not a good long-term solution
15:39:32 <dcoutts> kosmikus, yes, ok
15:39:38 <dcoutts> SyntaxNinja, how does registering work then for cabal packages which do not use Distribution.Simple and so don't generate .instaled-package-info ?
15:41:07 <kosmikus> they can probably do whatever they like, then
15:41:10 <SyntaxNinja> dcoutts: it's up to them to generate the package.conf file themselves; they write the register command themselves, so they can do whatever they want.
15:41:43 <dcoutts> hmm, not sure how that would work for rpms, debs, etc
15:42:10 <kosmikus> that's why --in-place seems so appealing to me; then it could still be required that --user, --global, and --in-place should be handled correctly by a conforming setup program
15:42:20 <SyntaxNinja> I haven't actually seen systems which don't use dist.simple in practice; it's likely something that won't be quite perfected until there are more out there.
15:42:43 <dcoutts> yes me neither, they all use dist.simple
15:43:38 <kosmikus> wasn't there the idea that you could use setup.lhs as a wrapper around a configure/makefile-combo?
15:43:42 <dcoutts> but kosmikus makes a good point, --in-place/--global/--user would not be an onerous requirement on a non-dist.simple setup program
15:43:54 <SyntaxNinja> yeah
15:45:50 <dcoutts> well thanks for thinking this stuff through with us SyntaxNinja
15:46:11 <kosmikus> SyntaxNinja: another question. I noted that Cabal-1.1.1 installs a setup-config (or was it config-setup) program to /usr/bin. What's that for?
15:47:26 <dcoutts> [ we've been implementing all our cool new cabal stuff recently so are full of questions! sorry about that :-) ]
15:47:42 <kosmikus> /usr/bin/cabal-setup, that's the one
15:49:17 <SyntaxNinja> yeah, cabal-setup
15:49:48 <SyntaxNinja> not sure if that'll make it into the real releas... it's basically just defaultMain, so that if a tool uses defaultMain, you don't have to use their setup script, you can just youse that executable
15:50:26 <kosmikus> I see.
15:50:35 <kosmikus> it doesn't have the correct permissions, though.
15:50:53 <kosmikus> is this something that Cabal is supposed to handle?
15:51:02 <kosmikus> or should we fix all binaries that are installed by Cabal?
15:52:21 <SyntaxNinja> cabal should handle it; there was some bug report mentioned ont he ghc mailing list; I haven't looked into which versinos of ghc this affects.
15:52:39 <dcoutts> we were using cabal-1.1.1
15:53:03 <SyntaxNinja> right; it's a ghc bug
15:53:41 <dcoutts> oh yes the readPermissions >== writePermissions thing
15:53:44 <dcoutts> >>=
15:53:54 * SyntaxNinja nods
15:54:34 <kosmikus> what's that bug?
15:55:24 <dcoutts> readPermissions >== writePermissions looses some bits
15:56:11 <kosmikus> heh, that reminds me that I still don't know why readPermissions causes a sandbox violation
15:56:45 <dcoutts> kosmikus, try the same with the C function access()
15:57:15 <dcoutts> kosmikus, see man 2 access
15:57:21 <dcoutts> it's what readPermissions uses
16:08:26 <tewk> So what is the most commomly used  web server written in haskel hws, hws-wp ?
16:10:42 <thedward> is there an apt repository somewhere with up to date versions of cabal and hs-plugins?
16:15:20 <SyntaxNinja> thedward: ghc in debian is broken right now.
16:15:22 <SyntaxNinja> due to gcc
16:15:43 <TheHunter> now, to start a very intersting experiment: drinking my very first american beer...
16:16:01 <SyntaxNinja> TheHunter: WAIT!
16:16:04 <dcoutts> TheHunter, noooo! don't do it!
16:16:06 <SyntaxNinja> TheHunter: what is it?
16:16:13 <thedward> SyntaxNinja: the version I have installed seems to work.
16:16:15 <SyntaxNinja> TheHunter: it's very important that you dirnk the RIGHT beer.
16:16:30 <TheHunter> it's michigan brewing company, wheatland wheat beer.
16:17:01 <SyntaxNinja> thedward: ask Igloo for details; depends on what version of gcc you have installed. we're waiting for th enew ghc to fix this problem.
16:17:24 <TheHunter> ridiculously expensive, although it was one of the cheaper ones, but anyway.
16:17:35 <dcoutts> sound ok, my favourite american beer is "Moose Drool" from Montana
16:17:38 <TheHunter> it's not too bad actually.
16:18:11 <dcoutts> with a name like that I had to get some :-)
16:18:50 <dcoutts> http://www.bigskybrew.com/index.php/fuseaction/home.beers
16:19:28 <SyntaxNinja> portland OR where I live supposedly has the most brewries in the world, or something
16:21:58 <Pseudonym> I find that less impressive than being the home to Galois.
16:22:55 <TheHunter> hmm,why don't they tell you how much alcohol is in there?
16:23:21 <SyntaxNinja> Pseudonym: because it has the most haskellers in the world? ;)
16:23:54 * Pseudonym isn't so sure about that
16:24:12 <SamB> what? I thought all the skellers lived in EU?
16:24:31 <lispy`> skellers?
16:24:38 <SyntaxNinja> I'm not sure, but I'd guess that portland has more haskellers in a single city than elsewhere. could definitely be wrong, though.
16:24:49 <Pseudonym> A lot live in Sweden.  A lot live in Cambridge.
16:25:09 <SamB> oh, well, true that the skellers seem to be scattered throughought europe
16:25:30 <Pseudonym> I'd guess that a university that teaches Haskell to all of its first year CS students probably has the edge on anywhere else.
16:25:42 <SyntaxNinja> willing haskellers? ;)
16:27:11 <Pseudonym> Even then, I'd be more likely to pick Cambridge over Portland.
16:27:46 <Pseudonym> Not that Portland doesn't have quite a few.
16:30:02 <SyntaxNinja> how many would you estimate Cambridge has. Igloo only counts as one.
16:30:07 <SyntaxNinja> er,
16:30:08 <SyntaxNinja> um.
16:30:09 <SyntaxNinja> I know that.
16:30:19 <dcoutts> Pseudonym, or Oxford! we teach Haskell to first years
16:30:23 <Pseudonym> True.
16:30:28 <Pseudonym> There you go.
16:30:34 <SyntaxNinja> first years don't count
16:30:37 <Pseudonym> Cambridge also has both Simons.
16:30:53 <SyntaxNinja> how many non-simon, non-first-year haskellers does cambridge have?
16:31:25 <Igloo> Cambridge is more ML than Haskell isn't it?
16:31:43 <dcoutts> Ah, well then, Oxford has it! :-)
16:32:07 <Beelsebob> heh... tbh, I'm not sure that it's good to teach Haskell to first years
16:32:10 <Pseudonym> I'm talking about Cambridge the city, which includes both the university and the Microsoft campus.
16:32:28 <Beelsebob> something like Scheme where they don't have to deal with horrible type errors is a much better lead in
16:32:38 <dcoutts> Beelsebob, they seem to cope ok
16:32:40 <SyntaxNinja> galois has like 9; plus ogi & psu, at least 5 more
16:32:59 <Beelsebob> dcoutts: Oxford first years must be better than Kent first years then ;)
16:34:15 <Pseudonym> I think Melbourne only has myself and Bernie Pope.
16:34:29 <Pseudonym> Since John Shepherd moved to Sydney.
16:35:01 <Pseudonym> Though Tom Conway really, really wants to be a Haskeller.
16:35:08 <Beelsebob> learning Scheme in first year meant that the emphasis was on the programming, not on the language... Wheras here, we spend a lot of time telling first years not to put the brackets round the arguments
16:35:35 <lispy`> not to put the brackets round the arguments?
16:35:53 <Beelsebob> all first years here want to do: f (x,y,z)
16:36:10 <TheHunter> it's obviously a copy of typical bavarian wheat beers such as augustiner, although with a less strong taste.
16:36:14 <lispy`> hmm... i'd be more worried about the commas :)
16:36:23 <Beelsebob> and then wonder why they get (a,b,c) doesn't match a -> b -> c
16:36:49 <lispy`> anyone here use eclipse?
16:36:55 <Beelsebob> ugh
16:36:58 <reffie> for haskell?
16:37:07 <lispy`> i need to turn on syntax highlighting, but i'm a clueless
16:37:24 <lispy`> reffie: unfortunately no, i'm at work so i need it for java/javascript
16:37:32 <reffie> :(
16:38:23 <lispy`> i've been spoiled by emacs, using eclipse is like...well...really unpleasant
16:38:31 <Beelsebob> hehe
16:38:45 <Beelsebob> I'm not sure spoiled is the right word :D
16:38:55 <lispy`> pampered?
16:39:06 <Beelsebob> turned to the dark side?
16:39:15 <ehuber> :p
16:39:19 <ehuber> emacs is fun
16:39:20 <ehuber> sometimes
16:40:54 <lispy`> you know what i like about global state?
16:41:03 <lispy`> not a lot....
16:41:06 <Beelsebob> heh
16:41:06 <SamB> Beelsebob: with a name like that, you aren't really one to talk!
16:41:20 <Beelsebob> samB: ;)
16:43:02 * Beelsebob goes to find hula-hoops... lots of hula-hoops
16:48:48 <Pseudonym> Sounds kinda suspicious if you ask me.
16:48:57 <Pseudonym> What do you need that many for?
16:54:44 * autrijus finally finished reading the various O'Haskell papers.
16:54:58 <autrijus> Timber's source code/spec is not available anywhere, right?
16:55:08 <autrijus> O'Hugs doesn't even build for me :-/
16:58:39 <wilx> I could never make any sense out of O'Haskell.
17:00:30 <autrijus> actually I think the design is very very sound. :)
17:01:10 <autrijus> although, without a working implementation it's quite moot
17:02:03 * Pseudonym is reading the Omega paper
17:02:11 <Pseudonym> I realise I didn't spell "Omega" correctly.
17:02:17 <Pseudonym> But I refuse to do it they way that they did.
17:02:32 <stefanw> autrijus: O'Hugs from CVS built fine for me one year ago
17:02:38 <Pseudonym> Looks very interesting, though.
17:02:49 <autrijus> stefanw: oh. I didn't get the CVS version. maybe I should
17:04:06 <autrijus> Ω or ω?
17:04:23 <stefanw> autrijus: maybe you also wanna try rhaskell: http://www.stefanwehr.de/haskell/
17:05:26 <autrijus> cool! let me read your paper
17:06:55 <autrijus> ah, TIP based subtyping
17:07:46 <autrijus> so this is like OOHaskell but with TH sugar?
17:08:41 * autrijus sees huge amount of sugar in the paper
17:10:37 <stefanw> I don't know whether OOHaskell has reactive objects
17:10:54 <dcoutts> SyntaxNinja, still around? Cabal currently build-depends depends on util but doesn't use anything from it, it would seem. It should be removed because it sort-of exposes the util package which then breaks lots of other programs.
17:11:24 <autrijus> stefanw: it probably doesn't, but I'm just referring to the object system
17:11:39 <dcoutts> I'd send a patch but it's a 5 character change :-)
17:13:01 <stefanw> autrijus: it looks similar, right
17:13:14 <autrijus> stefanw: the chat server code is very cute
17:14:09 <autrijus> m4: illegal option -- -
17:14:12 <autrijus> gmake[1]: *** [varexp-test] Error 1
17:14:18 <autrijus> hm. rhaskell's makefile doesn't like me
17:15:10 <dons> oh, it uses m4 ...
17:15:36 <stefanw> autrijus: yeah, the build system is kind of messed up
17:15:41 <stefanw> but it should work
17:15:45 <stefanw> do you use GNU m4
17:16:00 <autrijus> no, it's freebsd's POSIX.1 m4
17:16:11 <autrijus> installing gm4 now
17:16:18 <stefanw> I think you need GNU m4, dons had the same problem
17:16:31 <dons> yep
17:16:33 <autrijus> why does TH not provide currentLoc again? ;)
17:16:50 <reffie> is yi still alive?
17:16:59 <stefanw> maybe it does now, but one year ago it didn't
17:17:01 <dons> reffie, try a darcs pull ;)
17:17:10 <dons> very much so. much hacking underway
17:17:17 <autrijus> ok, gm4 fixed it
17:17:17 <reffie> i don't have darcs here :(
17:17:24 <reffie> nor ghc :((
17:17:39 <dons> 160 patches since 0.1.0 came out
17:17:43 <reffie> cool
17:17:49 <dcoutts> dons, you'll ping me when you want yi packaging for gentoo wont you :-)
17:17:57 <dons> I will :)
17:18:15 <dcoutts> Yi uses cabal?
17:18:21 <dons> nope. but it should
17:18:26 <dons> it has a tricky build system though
17:18:33 <dcoutts> oh
17:18:33 <dons> due to the plugins, the static core etc
17:18:38 <dcoutts> right
17:19:14 <dons> dcoutts, going to icfp?
17:19:31 <dcoutts> no sadly :-(
17:19:36 <dons> :(
17:19:52 <dcoutts> unless we win the icpfc again!
17:19:58 <dcoutts> so no :-(
17:20:07 <dons> :(
17:20:25 <dcoutts> mwc, I've nearly got a tarball for you, it's just building...
17:20:30 <dcoutts> oh its done
17:20:52 <autrijus> hm
17:20:52 <autrijus> Starting O'Haskell transformation ...
17:20:52 <autrijus> O'Haskell transformation finished
17:20:58 <autrijus> I wonder what it's doing
17:21:32 <autrijus> oh wow, evil runIO
17:21:34 <Igloo> dcoutts: You reckon dons' lot will pip us to the post, then?  :-)
17:21:56 <dcoutts> Igloo, well Haskell has to win one way or the other, right?
17:22:26 <dcoutts> mwc, http://www.haskell.org/~duncan/gtk2hs/gtk2hs-0.9.8.1_pre.tar.gz
17:22:41 <stefanw> autrijus: transforming ;-)
17:22:53 <dcoutts> but it still unpacks to gtk2hs-0.9.8 and has the version number 0.9.8, hope that's not a problem
17:22:57 <autrijus> stefanw: what's this ChatServerTimber.hs ?
17:23:40 <dcoutts> Igloo, btw if you ever get time to try your deps tool again, this tarball generates correct .cabal files
17:24:21 <mwc> dcoutts: thank you
17:24:32 <dcoutts> mwc, sorry for the wait
17:24:45 <Igloo> I'm sure you'll have 0.9.8.1 out before I get to that
17:24:55 <dcoutts> Igloo, ok
17:24:58 <Igloo> Especially if ibid packages it first  :-)
17:25:23 <stefanw> autrijus: that's the chat server example written in timber/o'haskell. worked for me with the CVS version of O'Hugs
17:26:00 <mwc_> dcoutts: thanks, lost the last tqarball when the hard disk crashed
17:26:01 <autrijus> oh ok. so timber is not significantly different from o'haskell?
17:26:11 <dcoutts> mwc, this version includes the fixes to c2hs to make it understand asm thingies, so that should allow it to build on MasOS X 10.4 (whcih has some __asm__ bits in it's libc header files)
17:26:26 <mwc_> yeah, you had one for me earlier that built
17:26:35 <dcoutts> oh yes I remember
17:27:13 <lispy`> gtk2hs?
17:27:22 <mwc_> yep
17:27:26 <lispy`> osx 10.4?
17:27:30 <lispy`> what you say?
17:27:32 <lispy`> it's ready?
17:27:35 <dcoutts> yes
17:27:39 <dcoutts> apparently
17:27:44 <lispy`> oh....shiny....
17:27:52 <mwc_> lispy`: I'm waiting for an sf release so I can put up a darwinports Portfile
17:28:01 <lispy`> sf release?
17:28:02 <stefanw> autrijus: no, timber is the successor of O'Haskell I guess
17:28:15 <dcoutts> 0.9.8.1 is not out just yet, but it's in testing now
17:28:15 <lispy`> mwc_: okay, i'll hold off for the dports
17:28:34 <lispy`> i wouldn't have time to play with it ATM anyway
17:28:34 <autrijus> stefanw: I see -- so you meant "O'Haskell" but wrote "Timber" :)
17:28:38 <dcoutts> we don't have any other bug fixes that we know of
17:29:16 <lispy`> mwc_: how long after you make the port file till i can fetch it with port selfupdate (or whatever the command is)
17:29:21 <dcoutts> lispy`, well we apreciate testing before the actual release too! it means less bugs in the final release and less patching for you
17:29:45 <lispy`> dcoutts: true, but spare time is so scarce :(
17:29:49 <dcoutts> true
17:29:56 <mwc_> lispy`: that's up to the darwinports guys. if you go into #darwinports and ask it to go in after I submit it; I'm sure it would happen real fast.
17:30:04 <stefanw> autrijus: if you start the CVS version of O'Hugs, you'll see that the call it "Timber" now
17:30:07 <dcoutts> but you'll get your port advertised in the release notes :-)
17:30:07 <lispy`> and i've been spending a lot of it talking with my partner.  I haven't seen her over a month....
17:30:38 <autrijus> stefanw: ok... except it fails to build for me. oh well.
17:30:43 <mwc_> lispy`: yes, the summer's not so much fun once the girls' have gone home
17:30:49 * lispy` laments living 600 miles from home
17:30:53 * autrijus blames freebsd^linuxism
17:31:44 * lispy` goes back to trying to understand iframes
17:32:33 <mwc_> I forswore ever doing web dev stuff
17:32:38 <mwc_> and I think i'm happier for it
17:33:06 <dcoutts> lispy`, you follow the gtk2hs-users list right? you'll get the release announcement two days early there so you have a bit more time to get your package mentioned in the release notes
17:33:30 <lispy`> dcoutts: i don't follow the list
17:33:32 <dcoutts> mwc_, you too? you watch gtk2hs-users for release announcements?
17:33:49 <mwc_> Nah, I check the homepage
17:33:55 <dcoutts> like I say it'll give you a head start
17:33:58 <mwc_> ah
17:34:13 <dcoutts> you can filter it just for "ANNOUNCE: " if you like!
17:34:21 <dcoutts> you don't have to read the rest! :-)
17:34:25 <mwc_> I better go do it now
17:34:25 <lispy`> dcoutts: i've never actually used gtk2hs, i just thought it would be cool to try gui stuff in haskell and gtk2hs looked nice, and you wrote those tutorilas....
17:34:47 <dcoutts> lispy`, oh sorry I thought you were involved in packaging
17:35:22 <lispy`> dcoutts: i just push the button that says "Internet" when packets get stuck
17:35:31 <dcoutts> heh
17:35:33 <lispy`> i don't do any real work
17:36:52 <lispy`> according to google, DOM's body object doesn't have a frame field, but according to this code i'm reading it does :(
17:37:14 <lispy`> it must be ie specific
17:42:08 <lispy`> hmmm...maybe this code has extended the normal body element
17:58:43 <Igloo> Hmm, +RTS -xc could have been more useful than  "<Segmentation fault"
17:59:09 <Beelsebob> that isn't too usefull
18:14:45 <mwc_> dcoutts: I put together a portfile based on the tarball you gave me; holding off for the proper release ebfore sending it upstream
18:14:51 <mwc_> lispy`: do you want it?
18:15:16 <dcoutts> mwc_, and things seem to work?
18:15:31 <dcoutts> eg a couple demos, ghci perhaps?
18:15:49 <mwc_> I'll give those a shot
18:15:54 <mwc_> haven't tried ghci
18:16:30 <dcoutts> ghci support is sometimes troublesome
18:17:01 <mwc_> We
18:17:10 <mwc_> We'll see if dons has done his work :P
18:17:19 <dcoutts> :-)
18:19:24 <efuzzyone> basic question, when I try to do function composition like this: (length . filter) Char.isLower "Helllo World")
18:19:33 <efuzzyone> it gives me an error,
18:20:06 <efuzzyone> there is no ")" after World
18:20:36 <efuzzyone> why is it so? I am not able to understand the error message.
18:21:22 <dcoutts> efuzzyone, you want  (length . filter Char.isLower) "Helllo World"
18:21:53 <dcoutts> the (.) only accepts one arg, you're giving it two
18:23:00 <dcoutts> or to put it another way, (.) composes two funcions of one argument
18:23:42 <efuzzyone> ok, i see. thanks
18:23:52 <dcoutts> (length . filter) Char.isLower "Helllo World" = length (filter Char.isLower) "Helllo World"
18:24:07 <dcoutts> which shows (reasonably clearly) why it's not right
18:24:28 <dcoutts> I've just expanded the definition of (.) on the left to get the right hand side
18:24:40 <dcoutts> which you can see makes no sense
18:24:52 <efuzzyone> (length . filter) Char.isLower "Helllo World" = length (filter
18:24:52 <efuzzyone> 	  Char.isLower "Helllo World") why not this? any reasons?
18:25:09 <dcoutts> look at the definiton of (.)
18:25:54 <dcoutts> (f . g) x = f (g x)
18:26:39 <dcoutts> and apply that to your example
18:27:09 <efuzzyone> this is bit confusing, is this correct (z . f . g) x  y= z (f (g x) y)?
18:27:25 <efuzzyone> (z . f . g) x  y= z (f (g x) y)
18:27:55 <dcoutts> (z . f . g) x  y= (z (f (g x))) y
18:28:17 <dcoutts> @type \ z f g x -> (z . f . g) x
18:28:18 <lambdabot> forall c b c1 a.
18:28:18 <lambdabot>           (c1 -> c) -> (b -> c1) -> (a -> b) -> a -> c
18:28:33 <dcoutts> @type \ z f g x -> (z (f (g x))) y
18:28:35 <lambdabot> bzzt
18:28:49 <dcoutts> @type \ z f g x y -> (z . f . g) x y
18:28:50 <lambdabot> forall b c a t t1.
18:28:50 <lambdabot>             (c -> t -> t1) -> (b -> c) -> (a -> b) -> a -> t ->
18:28:50 <lambdabot> t1
18:28:57 <dcoutts> @type \ z f g x y -> (z (f (g x))) y
18:28:58 <lambdabot> forall t t1 t2 t3 t4.
18:28:58 <lambdabot>             (t -> t3 -> t4) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3 ->
18:28:58 <lambdabot> t4
18:29:33 <dcoutts> so those two have the same type
18:29:40 <Enveigler_> dcoutts: If I load CalcModel into ghci, should I be able to invoke testProg?
18:30:10 <dcoutts> Enveigler_, I guess so, I'd have to look at the code again
18:30:18 <efuzzyone> dcoutts: thanks, i need to look analyze them.
18:30:31 <mwc> dcoutts: seeing some weirdness on the install stage
18:30:39 <dcoutts> mwc, yes?
18:30:51 <mwc> lisppaste2: url?
18:30:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:32:02 <mwc> dcoutts: looks like a pakage registration problem
18:32:04 <mwc> http://paste.lisp.org/display/10264
18:32:12 <dcoutts> @type \ z f g x y -> z (f (g x) y)
18:32:13 <lambdabot> forall t t1 t2 t3 t4.
18:32:13 <lambdabot>            (t -> t1) -> (t2 -> t3 -> t) -> (t4 -> t2) -> t4 -> t3 ->
18:32:13 <lambdabot> t1
18:32:54 <dcoutts> efuzzyone, you can see this has a differnt type so can't be equal to the others
18:33:28 <dcoutts> mwc, so:
18:33:29 <dcoutts> ghc-pkg: /opt/local/lib/gtk2hs/imports/glib doesn't exist or isn't a directory
18:33:52 <dcoutts> where are you installing and does that dir really not exist?
18:34:24 <mwc> that's the ports tree
18:34:36 <mwc> anyways, /opt/local/lib/gtk2hs doesn't exist
18:34:46 <dcoutts> ok, so where did you configure it to install to?
18:35:02 <mwc> into /opt/local
18:35:20 <dcoutts> do you really want to register at this point anyway? most packaging systems don't like it
18:36:09 <mwc> what do you mean? This is the standard place for darwinports to put stuff
18:36:31 <dcoutts> ok, I mean other packaging systems would delay the registration phase
18:36:31 <mwc> its where ghc et al. live
18:36:39 <dcoutts> maybe you don't need to do that
18:37:08 <dcoutts> so where has it installed all the files then if not to /opt/local/lib/gtk2hs ?
18:37:43 <mwc> dcoutts: I'm not sure
18:38:21 <mwc> can't find it anywhere
18:38:24 <mwc> may as well do a search
18:38:42 <dcoutts> the install lines should say
18:38:57 <dcoutts> the lines just before the ones you pasted
18:39:48 <mwc> ah, I think its the destroot problem....
18:39:53 <mwc> I need to think about how to handle this
18:40:05 <dcoutts> eg: /usr/bin/install -c -m 644 'libHSglib.a' '/usr/local/lib/gtk2hs/libHSglib.a'
18:40:26 <mwc> it puts it into a temporary root at then creates a tarball for the package before putting it into the tree
18:40:48 <dcoutts> you can use: make install DESTDIR=
18:41:01 <mwc> that's what its doing
18:41:08 <dcoutts> right so in that case you don't want to register
18:41:16 <dcoutts> because the files are not in place yet
18:41:35 <mwc> yeah, is there a good way to postpone that?
18:41:41 <dcoutts> ./configure --enable-packager-mode
18:41:44 <mwc> ah
18:41:46 <mwc> ok
18:41:55 <mwc> and then run the registration afterwards
18:41:57 <dcoutts> it also changes a couple other things
18:42:23 <mwc> let me take a look at how other haskell packages are handling it
18:42:34 <dcoutts> it means you need to explicitly specify optional dependencies rather than it auto-discovering them (which is what most packagers want)
18:43:03 <dcoutts> so instead of registering it just leaves the <pkgname>.package.conf file in the install dir
18:43:10 <dcoutts> and you can register them yourself
18:43:26 <dcoutts> I can show you the gentoo ebuild which does this
18:43:39 <mwc> I'm looking at the portfile for hsplugins
18:43:44 <mwc> I see how they're doing it here
18:44:00 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/portage/dev-haskell/gtk2hs/gtk2hs-0.9.8.ebuild
18:44:47 <dcoutts> (although some bits have changed 0.9.8 -> 0.9.8.1 so don't trust that ebuild too much)
18:46:07 <dcoutts> mwc, you you have glade, gconf, etc? the optional packages?
18:46:11 <mwc> yeah
18:46:35 <dcoutts> if so then with --enable-packager-mode you'll need to specify --enable-libglade
18:46:39 <mwc> ok
18:46:45 <dcoutts> and similarly for the other optional packages
18:47:13 <dcoutts> gconf, sourceview & mozilla
18:48:00 <dcoutts> it seems like a pain to specify them explicitly, but it saves you accidentally picking up extra dependencies that you we're expecting
18:48:15 <dcoutts> which can cause major problems for some packaging systems
18:48:20 <mwc> no problem
18:48:32 <mwc> configure.args set
18:49:33 <dcoutts> it also means they become hard dependencies, ./configure --enable-packager-mode --enable-libglade will fail if libglade is not found rather than just turning it off
18:49:59 <dcoutts> if you want it optional then you've got to deal with that yourself
18:50:06 <mwc_> dcoutts: not a problem, putting it on the dependencies for the port
18:50:28 <dcoutts> ok, you see gentoo's got this crazy optional deps system :-)
18:50:37 <mwc_> yeah, we have variants
18:50:50 <mwc_> but they're trying to be phased out because they're a headache
18:51:09 <dcoutts> on gentoo: USE="doc gnome mozilla" emerge gtk2hs
18:51:25 <dcoutts> 'USE' flags, they're vey popular :-)
18:51:49 <dcoutts> but yes, the dependencies become more complicated
18:52:17 <dcoutts> but great for people who like the idea of running a 'lean' system with only the deps that they want
18:53:06 <lispy_> dcoutts: as long as you don't end up like this http://www.funroll-loops.org/
18:53:32 <dcoutts> heh heh :-)
18:53:42 <dcoutts> indeed, to be avoided
18:53:55 <mwc_> lispy_: indeed; especially since -Os is a better op most of the time
18:54:27 <dcoutts> CFLAGS="-Os" emerge gnome
18:54:29 <lispy_> read the whole site, it's cobbled together from real quotes from gentoo's most rabid users :)
18:54:42 <dcoutts> don't listen to te users!
18:54:56 <dcoutts> they're the worst :-)
18:55:00 <mwc_> dcoutts: uhm... Command output: configure: error: invalid feature name: packager-mode --enable-libglade --enable-gconf --enable-sourceview
18:55:07 <mikehammad> hi, i have a template haskell question.  when i make a function declaration like [d| myFunc x y = $(somesplice) |] how do i refer to x and y in the body of somsplice?
18:55:37 <dcoutts> mwc, run ./configure --help
18:55:43 <dcoutts> see if I've spelt it wrong
18:55:47 <metaperl> what does the word "ricer" mean?
18:56:41 <mwc_> dcoutts: I copied it straight from that output
18:56:50 <lispy_> metaperl: it's a reference to people that turn japanese-made cars (like honda) into "racing" cars
18:57:01 <metaperl> lol
18:57:41 <mwc_> lispy_: I was just at a ricer show this weekend
18:57:59 <lispy_> mwc: lots of cute girls?
18:58:08 <mwc_> actually... no
18:58:14 <mwc_> they were mostly nasty skanks
18:58:18 <mwc_> the booth babes at least
18:58:25 <mwc_> the model show girls were ok
18:58:29 <lispy_> ah okay
18:58:46 <dcoutts> mwc_, I'm most confused
18:58:50 <lispy_> there is some comedian (can't remember which) that has a bit about guys not caring for fast cars, but chicks dig 'em :)
18:59:29 <dcoutts> mwc_, it doesn't do that for me
19:01:33 <mwc_> yeah, its pretty odd
19:02:24 <dcoutts> mwc_, it's not a bash/sh thing is it?
19:02:35 <mwc_> Ah, I fixed it; it was passing an extra '' pair into configure
19:02:48 <dcoutts> oh ok :-)
19:03:22 <lispy_> yeah configure is not as robust as one would hope :(
19:04:07 <dcoutts> roll on cabal with multi-package support
19:04:27 <palomer> hello
19:04:49 <palomer> is there a call-by-value lambda calculus with call/cc?
19:04:54 <palomer> typed
19:05:09 <palomer> if so, any references?
19:14:34 <mwc_> dcoutts: got a handle on it now; just need to let it rebuild after I changed the portfile
19:17:43 <Enveigler_> @docs Data.IORef
19:17:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.IORef.html
19:20:30 <lispy_> shouldn't ical hide completed todo items?
19:20:36 * lispy_ boggles
19:40:12 <autrijus> mm massive wikispamming in action on hawiki
19:50:11 <mwc_> dcoutts: ghc-pkg register filename gconf.package.conf for all packages?
20:21:55 <Enveigler_> @index MVar
20:21:56 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
20:22:27 <Enveigler_> @docs Control.Concurrent.MVar
20:22:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.MVar.html
20:38:00 <mwc_> dcoutts_: any idea how to get it to build shared libraries?
20:38:17 <mwc_> dcoutts_: I don't see an --enable-shared switch in configure
21:09:15 <palomer> ugh, I'm going to have to prove subject reduction soon
21:09:16 * palomer shivers
21:11:08 <Korollary> is that for a course you are taking ?
21:11:19 <palomer> nonono, research
21:12:04 <palomer> the problem is call/cc
21:12:50 <palomer> man, it would rock if types were stable under the 4 reductions, reduced anywhere
21:13:30 <palomer> (it would also rock if there was a paper describing when subject reduction fails/succeeds)
21:14:52 <palomer> bah, ill prove subject reduction tomorrow
21:15:56 <palomer> actually, I'm pretty sure that cbv subject reduction fails when you put in call/cc
21:22:30 <Korollary> I dont even know what exactly call/cc is. I tried to learn scheme but I was bored.
21:28:05 <gzl> i got bored too.
21:29:11 <Korollary> heh
21:30:54 <palomer> call/cc captures the current position of your code
21:30:59 <palomer> it makes typing a tad difficult
21:33:02 <Korollary> I didnt know it had anything to do with typing
21:33:42 <palomer> if you consider it a function in your calculus, how would you type it?
21:34:53 <Korollary> I wouldnt know
21:34:55 <palomer> (this is a silly question, considering you don't know the operational semantics)
21:35:15 <mwc_> any body here know much tech detail of ghci?
21:35:25 <mwc_> trying to figure out how to get it loading a library at runtime
21:35:35 <mwc_> does it need to have the static libs availible in dylib form?
21:36:26 <Korollary> I developed an allergy to excel spreadsheets and microsoft netmeeting.
21:41:35 <gzl> what does that have to do with anything :)
21:41:39 <Lemmih> mwc_: loading a library at runtime?
21:41:49 <mwc_> yeah
21:41:54 <mwc_> like gtk2hs in particular
21:42:26 <mwc_> tries to load a dylib and I can't figure out how to convince the source to build me dynamic libs, only static
21:46:06 <Lemmih> Trying to use gtk2hs in GHCi?
21:57:44 * Lemmih heads to bed.
22:01:26 * palomer wonders where ski is
22:54:38 <pejo> palomer, asleep I'd guess, it's 8 am. ;)
22:56:22 <dons> not its not!
22:56:31 <dons> @timein sydney
22:56:33 <Korollary> it's 11pm
22:56:33 <lambdabot>  Thursday, July 28, 2005 at 3:57:36 PM EST
22:57:52 <Korollary> how many lines of test code do you people write for 100 lines of code (any language) ?
22:57:57 <pejo> dons, I bet you have great weather down there too. :-(
22:58:44 <dons> oh, it's lovely and warm today :)
22:58:52 <dons> even though its winter!
22:59:08 * dons plans trip to estonia and wonders how many coats he will need
22:59:36 <pejo> @tempin estonia
22:59:37 <lambdabot>  Thursday, July 28, 2005 at 9:00:39 AM EEST
22:59:42 <Korollary> lol
22:59:53 * pejo whacks lambdabot
22:59:55 <dons> huh. es
23:00:11 <Korollary> that is called a mandelbug
23:00:20 <dons> @timein lativia
23:00:22 <lambdabot>  Sorry, don't know this city
23:00:24 <dons> @timein latvia
23:00:25 <pejo> dons, 15C far up in northern Sweden at 8 am. You can just walk around in your shorts, I guess.
23:00:26 <lambdabot>  Thursday, July 28, 2005 at 9:01:28 AM EEST
23:00:52 <dons> ok, that's warm enough :)
23:01:14 <pejo> dons, don't take my word for that though. I have no idea how far it is to Estonia from here. :-)
23:01:26 <dons> looks like @timein is more flexible that I thought
23:01:31 <dons> @timein germany
23:01:42 <dons> @timein america
23:01:44 <Korollary> oopd
23:01:44 <lambdabot>  Wednesday, July 27, 2005 at 7:02:46 PM
23:01:55 <Korollary> thats not right btw
23:02:09 <dons> well, I wonder what it's returning?
23:02:17 <Korollary> check out the website directly
23:02:19 <pejo> Korollary, hm. Most people cheat on writing tests. Maybe QuickCheck is the right tool?
23:02:22 <dons> 7pm seems wrong, doesn't it.
23:02:27 <dons> oh, no maybe that's ok
23:02:33 <Korollary> it's 11pm on t west coast
23:02:52 <Korollary> hawaii maybe ?
23:03:32 <Korollary> pejo: I was asking from a philosophical point of view for a reasonably rigorous developer.
23:03:38 <pejo> Why does it interpret @tempin as @timein anyways?
23:03:51 <Korollary> @tumpin dublin
23:03:53 <lambdabot>  Thursday, July 28, 2005 at 7:04:55 AM IST
23:03:56 <Korollary> lol
23:04:15 <Korollary> @tampon chicago
23:04:16 <lambdabot> Unknown command, try @listcommands.
23:04:19 <dons>  @tempin -> @timein by spelling correction
23:04:20 <Korollary> oh well
23:04:25 <dons> you're allowed 3 edit mistakes
23:04:33 <dons> more than that and lambdabot doesn't try to correct you
23:05:14 <Korollary> I think lambdabot ought to say "I think you meant @timein" to avoid confusion
23:06:00 <dons> we used to have this behaviour, but it turns out to be annoying
23:06:00 <pejo> Yeah, and why not hook it up with temperature wherever you can find it? :-)
23:06:18 <dons> also, lambdabot will accept an unique prefix if you provide it with one
23:06:32 <dons> @t
23:06:33 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
23:06:33 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
23:06:40 <dons> so if you're too far out it suggests some options
23:06:55 <dons> prefixes first, followed by spelling mistakes (pl , wn)
23:07:26 * dons goes out for some exercise
23:07:46 * Korollary is watching the daily show
23:15:45 <juhp> ah, I finally get it lambdabot output is optimised for 80 cols apparently...
23:17:47 <lispy_> http://www.codersbase.com/Helisp  <-- if you look at the code be gentle and remember writing an interpret is not something i've done before
23:19:26 * lispy_ heads to bed
