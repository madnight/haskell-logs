00:05:51 <boegel> Itkovian: something up ? :)
00:06:03 <Itkovian> nah
00:06:07 <Itkovian> warm weather
00:06:22 <boegel> warm, like hell it is
00:06:31 <boegel> it isn't warm now
00:33:07 * boegel whistles
00:48:49 <earthy> i's clammy
00:49:31 <genneth> are the other vowels clammy too ?
00:49:49 <Itkovian> maybe the e is
00:50:07 <genneth> the 'a' is all curled up too
00:50:37 <gaal> hey. i need a hint on writing a Show instance for TVar.
00:51:16 <gaal> (STM)
00:51:34 <genneth> what do you need?
00:51:39 <genneth> a Show for a general TVar?
00:52:08 <gaal> i want the show'ed string to be reversible :) the context is the pugs haskell compiler.
00:52:31 <genneth> isn't show an IO action?
00:52:42 <gaal> so something like "(newTVar " ++ show ??? ++")" would probably do
00:52:46 <ski> @type show
00:53:06 <ski> bah, no lambdabot
00:53:16 <ski> show :: Show a => a -> String
00:53:22 <genneth> ah...
00:53:44 <ski> what's the type of newTVar ?
00:54:03 <gaal> newTVar :: a -> STM (TVar a)
00:54:04 <ski> something like   newTVar :: a -> STM (STMRef a)  ?
00:54:08 <ski> ah
00:54:22 <gaal> (i'm still pretty vague on monads unfortunately)
00:54:31 <ski> well, i think you cannot expect to show a TVar in that way
00:54:42 <genneth> so we should just make a TVar a -> STM String ?
00:54:56 <ski> a TVar is like an index i into a list where the real values lie
00:54:58 <genneth> oh no, ignore my ramblings
00:55:07 <ski> genneth : that would be possible, yes
00:56:02 <gaal> ski, you mean that readTVar only gets one current value out of many possible ones in the transaction log? i *think* for my purposes that's okay.
00:56:13 <gaal> that's okay to ignore the other ones that is.
00:56:20 <ski> showTVar :: Show a => TVar a -> STM String; showTVar tvar = do {a <- readTVar tvar; return (show a)}
00:56:28 <ski> something like that, i think
00:57:10 <ski> gaal : first, i haven't actually looked at STM, i'm just extrapolating from IO,IORef and ST,STRef
00:57:22 <gaal> i need to fulfil this, i think:
00:57:29 <gaal> instance (Typeable a) => Show (TVar a) where
00:57:35 <gaal> (magic)
00:57:41 <ski> that will not be possible
00:57:49 <gaal> shucks.
00:58:04 <ski> think of it in this way
00:58:12 <ski> say you have a list of e.g. strings
00:58:29 <gaal> ok
00:58:32 <ski> ["haskell","java","c++","perl"]
00:58:42 <ski> and, you pass this list around
00:59:01 <ski> into functions as an argument, and out as a (part of) the result
00:59:19 <ski> now, you can also have indices into this list
00:59:35 <ski> like the index 1, e.g. refers to "java" in that list
00:59:46 <ski> because ["haskell","java","c++","perl"] !! 1 = "java"
00:59:52 <gaal> yup
01:00:14 <ski> now, assume one of these functions that takes the list as input returns a modified list
01:00:16 <ski> say
01:00:28 <ski> ["haskell","smalltalk","c++","perl"]
01:00:30 <ski> now
01:00:54 <ski> the *same* index 1, will, with respect to this new list, refer to the element "smalltalk" instead
01:00:58 <ski> ok ?
01:01:03 <gaal> yes
01:01:05 <ski> so
01:01:29 <ski> you can think of your IORef and STRef and (i think) TVar as a kind of index, too
01:01:56 <ski> the index *by itself* does *not* in any way contain the data element that it refers to
01:02:18 * gaal nods
01:02:18 <ski> it only refers to the element *in conjunction* with a *specific instance* of the state
01:02:21 <ski> so
01:02:29 <ski> you can't have a function
01:02:37 <ski> Show a => TVar a -> String
01:02:56 <ski> because that function will only get the index, and not the state in which the index refers to the actual data
01:03:10 <Itkovian> @google the donkey in winnie the pooh
01:03:16 <ski> you see why this doesn't work, now ?
01:03:28 <gaal> isn't there a way to also dump that state?
01:03:55 <ski> to be able to do something with the state you must have it as an input
01:04:02 <ski> compare with IO and IORef
01:04:24 <ski> data IO a = MkIO (RealWorld -> (a,RealWord))  -- more or less
01:04:32 <ski> so, e.g. a function of type
01:04:43 <ski> Show a => IORef a -> IO String
01:04:53 <ski> will be more or less the same as
01:05:05 <ski> Show a => IORef a -> RealWorld -> (String,RealWorld)
01:05:10 <gaal> hmm, yes
01:05:13 <genneth> gaal: the way i see it is that there are no actions you can do to a TVar that doesn't result in an STM action
01:05:29 <ski> and here we see that this function actually get the world state as an input/argument
01:06:27 <ski> genneth : well, you can copy and discard and pass the TVars around, and i think you can conmpare them for equality (and maybe ordering .. ?), but not much else, yes
01:06:57 <gaal> yes, i see the problem. thanks for the explanation!
01:07:04 <ski> of course
01:07:09 <ski> in the actual implementation
01:07:22 <ski> the state used is the heap or similar of the computer
01:07:32 <gaal> uh huh
01:08:26 <ski> but, to sort of grab that state from nowhere, in the implementation would mean that functions could return different value when given the same arguments
01:09:01 <gaal> yeah, same problem as IO basically
01:09:16 <musasabi> Does a zip library exist for Haskell?
01:09:32 <ski> which is problematic partly because of the laziness of haskell (hard to predict exactly when, and if something reads or even modifies state) and partly because it makes reasoning more difficult (both for programmer and for compiler)
01:09:44 <ski> gaal : yeah, right. exactly
01:10:07 <genneth> thank the gods laziness kept us pure ;)
01:11:01 <gaal> i wonder how autrijus plans on approaching this problem. we'll see when he wakes up :)
01:11:27 <ski> maybe one could have a IOShow class ..
01:11:53 <ski> class IOShow a where ioShow :: a -> IO String
01:11:56 <ski> or even
01:12:10 <ski> class MonadicShow m a where mShow :: a -> m String
01:12:39 <ski> (which would show, relative to the IO monad, or possibly to other monads as well)
01:13:38 <ski> gaal : one thing one could do is to, so to speak, "freeze" some structure with IORefs / TVars to the current state, and then show that
01:13:41 <gaal> i need to understand better why parts of the AST (which is what i want to show here) are TVars in the first place
01:13:57 <ski> ok, i dunno about that
01:14:03 <ski> anyway, like
01:14:17 <gaal> i can imagine very cool stuff with partial compilation but i don't think that's the current use.
01:14:29 <genneth> locking?
01:14:49 <genneth> STM's are the easy way to scale with concurrency
01:15:07 <gaal> genneth: we're talking about the syntax tree of a pugs program :)
01:15:15 <ski> type RefList ref a = ref (RefListCell ref a);   data RefListCell ref a = Nil | Cons a (RefList ref a)
01:15:52 <ski> freezeIORefList :: RefList IORef a -> IO (RefList Id a)
01:15:57 <ski> data Id a = a
01:16:13 <ski> gaal : understand what i'm after ?
01:16:17 <genneth> gaal: yes; but if pugs is multithreaded (why the hell... beats me) then the access to the AST (presumably the main data structure in a compiler) then access to it would need to be carefully marshalled; STM makes sure that you can just ignore the locking and deadlocking, etc.
01:17:55 <gaal> ski, that's pushing the limits of my haskell knowledge :)
01:19:03 <ski> gaal : more or less, resolve all IORefs (or TVars, i guess) in something you e.g. want to print, to a specific state, and then you get a value that you could possibly show in a normal way
01:20:04 <gaal> genneth: a program pugs runs can certainly be multithreaded, and it carries the pugs runtime with it, so i guess the ast needs to be protected from thread stuff as well, but i really don't know.
01:20:05 <ski> gaal : RefList was just an example where the "tail link" goes through some kind of references, e.g. IORefs, or TVars
01:20:44 <gaal> what's "ref"?
01:22:00 <ski> a typevariable (argument to RefList)
01:22:08 <ski> that represents some kind of reference
01:22:11 <ski> e.g. IORef
01:22:13 <ski> or TVar
01:22:17 <gaal> ah, cool
01:23:06 <ski> in the freezeIORefList example, i used Id as resulting "reference", which is no reference at all, just the value itself, directly
01:23:37 <gaal> right
01:23:48 <ski> so, a value of type RefList IORef Int would be a kind of list of integers, where the "tail links" are references relative the current IO state
01:23:56 * boegel does a little dance
01:25:03 <gaal> and a similar thing could be done for TVars
01:25:13 <ski> while, on the other hasnd, a value of type RefList Id Int, would be a list of integers where the "tail links" are more or less just the rest of a list (so you can if you with convert this to and fro the type [Int], the "normal" type of list of integers)
01:25:17 <ski> gaal : right
01:25:53 <ski> at least if we have something like  readTVar :: TVar a -> STM a  which operates nicely
01:26:29 <ski> (as i said, i haven't checked on STM, yet, but i currently see nothing that would hinder this idea from working)
01:27:16 <gaal> there's exactly such a newTVar.
01:27:21 <gaal> err
01:27:24 <gaal> readTVar
01:27:26 <ski> good
01:34:27 <gaal> well, thanks again. i won't go and implement this yet because i don't know enough about why that's all in there but i'll probably be able to follow the solution someone else provides better now. :)
01:34:38 * boegel keeps dacing
01:34:46 <boegel> s/dacing/dancing
01:36:26 <Muad_Dibber> You should be dancing, yeah
01:36:29 <Muad_Dibber> - Beegees
01:37:34 <genneth> gaal: http://groups-beta.google.com/group/perl.perl6.internals/browse_frm/thread/8431e8ffbf74d77a/319b36760b1d5a74#319b36760b1d5a74
01:39:57 <gaal> yes; but i don't rightly know the place of STM in the AST.
01:40:36 <genneth> it seems to be just that; marshalling access to the AST from multiple threads in the running program
01:40:57 <genneth> but if you mean exactly how -- i can't find it either :D
01:42:40 * boegel catches a breath
01:43:00 * boegel continues dancing cheerfully
01:43:18 * genneth wonders what boegel is dancing too
01:43:50 <boegel> genneth: music :p
01:44:30 <earthy> joy
01:44:35 * genneth nods in beat
01:44:38 * earthy says bye bye to the data on his laptop
01:44:47 <boegel> earthy: ow ? what happened ?
01:44:54 <earthy> disk overheated
01:45:01 <earthy> (is my current best guess)
01:45:12 <boegel> sucks :(
01:45:14 <genneth> "Noooooooooooooooo....oooo.ooo... *cough* *splutter* (draws breath) oooooooooo"
01:45:44 <earthy> bigtime, as I have 0 backups
01:45:59 <earthy> and my PhD stuff was on it...
01:46:13 <boegel> earthy: :|
01:46:20 <boegel> why oh why didn't you take any backups ?
01:46:34 <earthy> oh, I do have backups
01:46:41 <earthy> of about 6 months ago...
01:46:44 <boegel> yaay
01:46:45 <boegel> oh :(
01:46:52 <boegel> not smart, is it ?
01:46:55 <mje> Hey, shouldn't it be okay to rebind a variable in the scope of a "let"?
01:47:07 <genneth> boegel: the urge to backup lasts for about the mean time to failure of the next disk
01:47:20 <earthy> then I moved and my backupserver got turned off and I haven't gotten round to getting it up and going yet, even though I was in the process of setting it up
01:47:34 <earthy> !autolart
01:47:42 <mje> For instance, in ML that would be allowed
01:48:13 <earthy> mje: why would you want to do that?
01:48:42 <mje> earthy: well if you want to thread a variable through a few functions
01:48:47 <genneth> mje: ML is impure
01:48:57 <mje> and let's say folding isn't exactly appropriate
01:49:08 <mje> genneth: I don't think that has anything to do with it
01:49:27 <mje> genneth: It's purely a scoping issue
01:49:45 <earthy> a static scoping issue, right?
01:49:51 <mje> right
01:50:09 <earthy> then *why* in heaven would you want that?
01:50:19 <earthy> it only serves to obscure things
01:50:25 <genneth> i'm not getting it either; why not change the name of the variable
01:50:32 <earthy> f a = let a = b in a
01:50:52 <mje> so lets say you are making updates to a set in sucessive lines
01:51:13 <mje> so you have let s = ...; s' = ... s ...; s'' = ... s' ...; ..
01:51:41 <earthy> ah, right.
01:51:44 <earthy> you want monads. :P
01:51:52 <mje> perhaps
01:52:04 <mje> but i don't see why one shouldn't be able to do what i want
01:52:12 <mje> #1 the type system can catch any problems
01:52:20 <mje> #2 ghc/hugs don't complain if you DO do that
01:52:40 <earthy> mje: the semantics are unclear
01:52:41 <mje> #3 ghc/hugs generate a segmentation fault at runtime if you do it, but not a compile error
01:53:02 <Itkovian> @type take
01:53:04 <earthy> the ; has to have a sequential evaluation semantics for that to work
01:53:22 <mje> Ah, so the issue is lazyness
01:53:23 <Itkovian> hnmm
01:53:25 <earthy> bingo
01:53:26 <Itkovian> @yow
01:53:28 <mje> I see
01:53:29 <mje> good point
01:53:32 <Itkovian> lambdabot off line?
01:53:38 <genneth> itkovian: i think lambdabot is offline
01:53:48 <Itkovian> oh well ...
01:54:13 <mje> but still then, shouldn't the type system complain if you try to rebind?
01:54:24 <ski> no, sequential evaluation semantics is not related to it
01:54:29 <ski> it has to do with scoping
01:54:31 <earthy> mje: why?
01:54:49 <earthy> if the expressions that are bound to s all have the same type it should work, right?
01:55:04 <earthy> from a type point of view
01:55:27 <ski> in ml,  let val <x0> = <e0>; val <x1> = <e1> in <e> end  is the same as let val <x0> = <e0> in let val <x1> = <e1> in <e> end ned
01:55:29 <mje> ok, well technically it's not a typing issue, but how about some sort of check
01:55:32 <ski> s/ned/end/
01:56:08 <ski> in haskell, let <x0> = <e0>; <x1> = <e1> in <e>  the two bindings are mutually recursive
01:56:42 <ski> in sml, they are sequential, and not recursive (unless using 'val rec' or 'fun')
01:57:54 <mje> hmm, i guess you'd need to allow rebinding for pattern dispatching
01:58:02 <ski> sequential as in <x0> is visible/in scope in <e1> and <e> and <x1> is in scope in <e>
01:58:14 <mje> but it bothers me that I can get a segmentation fault in haskell
01:58:26 <ski> yeah ..
01:59:00 <ski> if you try to define the same var twice (on the same level) you should get an error
01:59:11 <mje> ski: you don't
01:59:22 <ski> while  let x = 1 + y; y = 1 + x in x  should not give a compile-time error
01:59:40 <ski> mje : you don't what ?
01:59:47 <mje> ski: oh I thought you meant in the same let
01:59:59 <ski> i did
02:00:07 <ski> let x = 1; x = 2 in x
02:00:10 <ski> is disallowed
02:00:18 <mje> well I wrote somethign like that that was allowed
02:00:29 <ski> prolly it was more similar to
02:00:36 <ski> let x = 1 + y; y = 1 + x in x
02:00:39 <ski> that's my guess
02:00:41 <mje> something to the degree of let (v,vs) = ... ; (v,ss) = ... in ..
02:01:08 <mje> hmm
02:01:19 <mje> Let me find that code...
02:01:23 <ski> @type let (x,_) = undefined; (x,_) = undefined in x
02:01:33 <ski> arg
02:01:52 <ski> lambdabot: where are you in our hour of need ?
02:02:05 <mje> your bot evaluates haskell?
02:02:11 <ski> not my bot
02:02:16 <mje> whoevers botr
02:02:24 <genneth> where is lambdabot in real life?
02:02:26 <ski> but, yes, it evaluates (and types and more) haskell
02:02:53 <genneth> it also produces amusing ascii art of cows
02:03:01 <mje> nice
02:03:09 <mje> why cows?
02:03:22 <ski> genneth : i think lambdabot instances has been running from different places. different people have contributed to it ..
02:03:25 <genneth> exactly ;)
02:04:02 <ski> (it also can search for named functions in packages, and search for functions matching a type, etc ..)
02:04:09 <mje> Can I paste 4 lines of code?
02:04:19 * ski would say ok
02:04:25 <mje> >                   implClauses' node s vs =
02:04:25 <mje> >                       let (cs,fvs,vs') = dnfToCnfClauses s vs
02:04:25 <mje> >                           c = lhsClause node fvs
02:04:25 <mje> >                       in (c:cs,vs')
02:04:44 <mje> now if I change the "vs'"'s to "vs"'s
02:04:49 <ski> for longer pieces, though, it's better to use a paste page such as e.g. lisppaste or rafb or
02:04:56 <ski> @paste
02:05:00 <ski> arg :/
02:05:06 <genneth> lol
02:05:08 <mje> it causes a segfault
02:05:16 <ski> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:05:25 <ski> hm
02:05:53 <mje> I guess they are not in the same let though
02:05:57 <ski> that let seems ok, to me
02:06:16 <mje> but not to Mr. ghc
02:06:18 <ski> if they are not in same let, then there should be no problem with shadowing
02:06:28 <ski> so, i guess there is some other problem
02:07:01 <ski> mayybe it goes into an infinite loop (but to get a segmentation fault from that i still pretty bad behaviour)
02:08:38 <ski> s/i/is/
02:08:49 <mje> yep
02:09:05 <ski> hm
02:09:12 <ski> can you run it in hugs ?
02:09:15 <mje> ok another example was where there are nested lets defining the same variable
02:09:26 <ski> or it depends on libs / features not present in hugs ?
02:09:39 <mje> If I remember correctly, hugs had the same/similar problem
02:09:40 <mje> let me try it
02:09:42 <ski> let x = 1 in let x = False in x
02:11:08 <mje> I don't know my code isn't in typesafe shape right now
02:11:24 <mje> but I swear I got segmentation faults from reusing names
02:13:04 <ski> m
02:15:48 <ski> earthy : one reason for reusing names in that way to to make sure you can't accidentally use an "earlier" version, and to make inserting and removing transforming steps more robust
02:16:24 <earthy> um... yeah. that makes some sense
02:16:28 <ski> earthy : in simple cases, this can be done with (.), yes, and otherwise prolly a state monad
02:16:42 <earthy> still, if you need that, you probably should be designing it differently, though
02:17:08 <ski> hm, you mean like ?
02:17:50 <earthy> well, making sure you can't accidentally use an 'earlier' version implies you have an 'earlier' version lying around to play with
02:18:05 <earthy> good incentive to break up your function
02:18:26 <earthy> if that is not wanted
02:18:40 <earthy> and well, transforming steps should be in hardware, so...
02:18:42 <ski> earthy : e.g. clean has essentially a variant of let, which has this sequential scoping, with possibly shadowing, behaviour. though, there one most often passes around e.g. the state of the world, or a linear array explicitely ..
02:18:55 * earthy nods
02:19:06 <earthy> that's the # construct, right?
02:19:09 <ski> yes
02:19:21 <earthy> yeah, it's a hack to not have to do monads
02:19:27 <earthy> imho
02:19:43 <ski> to 'not to *have to* do monads' ?
02:20:13 <earthy> well, yeah, the clean style is to program stuff out with direct recursion and let and where clauses
02:20:19 * ski thinks both has advantages and disadvantages
02:20:34 <earthy> but that gets tedious rather quickly when you're dealing with I/O (even though clean's I/O system is neat)
02:20:49 <earthy> due to all the shuffling around with unique things
02:20:59 <ski> with monads, one usually ends up hardcoding a sequentiality to all actions in the monad
02:21:09 <earthy> one way to solve that is to encapsulate the unique thing inside a monad
02:21:26 <earthy> another is to put the sequentiality somewhere else
02:21:37 <ski> if you pass around linear state, then you can split the linear state in pieces, pass then on to different computations, and later merge the modified results
02:21:42 <earthy> but you have to encode it *somewhere*
02:21:56 * earthy knows about Clean's I/O system
02:21:57 <ski> e,g, one piece might be graphics screen, another might be filesystem, etc ..
02:22:03 <earthy> used it heavily back in 1995
02:22:15 <ski> m
02:22:25 <earthy> as in: took it places the Clean group hadn't taken it yet. ;)
02:22:26 * genneth looks up at the buzzing things flying over his head
02:23:05 <mje> hey just curious, do real haskell programmers go through the trouble of using Sets when they want a set and not a list?
02:23:17 <earthy> um, depends ;)
02:23:28 <ski> earthy : you don't have to encode somwhere sequentiality that isn't inherent in the problem/data
02:23:33 <earthy> on whether or not performance matters
02:23:54 <mje> earthy: So lists are the performance concious choice?
02:24:13 <ski> the other way around, i'd say
02:24:14 <earthy> ski: true enough, but in that case you don't want to reassign a value to an existing identifier
02:24:16 <shapr> metaperl_vc: pong
02:24:18 <shapr> swiert: pong
02:24:25 <earthy> mje: lists are the easy choice
02:25:12 <ski> earthy : right, that is for expressing the sequentity (though uglier than using (.) (if possible) or a state monad)
02:25:13 <earthy> since that reassignment really *needs* an encoded sequentiality
02:25:23 <ski> yup
02:25:27 <earthy> which is what we were talking about in the first place
02:25:32 <mje> Then the performance comes from the balanced trees or whatnot
02:25:38 <earthy> mje: exactly
02:25:58 <mje> but you'd have to think that lists are so deeply embedded into the language that they must be fairly efficient
02:26:21 <ski> complexities can still be bad, because of inherent structure of lists
02:26:54 <mje> *time* complexities
02:27:02 <mje> what about space?
02:27:22 <earthy> not all that much more expensive than lists
02:27:23 <mje> I guess it would be linear anyhow?
02:27:31 <ski> earthy : anyway, i think i'll argree on that using a state monad instead of # would be better, in many cases
02:28:10 <mje> oh so one more haskell thing i've been wondering
02:28:41 <mje> are there any good examples of scalability?  For example if I wrote a model checker, would it stand a chance?
02:28:59 * ski has pondered on if he could define a state-in-context comonad in clean (possibly defined using some unsafe ops ..)
02:29:39 <ski> (also, how to use the comonad usefully ..)
02:30:14 <ski> scalability of lists vs balanced trees as sets ?
02:30:15 * boegel is getting tired of dancing around
02:30:40 <mje> ski: scalability against model checkers written in c
02:30:40 <ski> boegel : let your fingers dance, mayhaps ?
02:31:05 <boegel> ski: I'm fixing some old pc, so I don't really hae time to code
02:31:12 <boegel> I should be finishing my HRay article
02:31:16 <ski> efficiency scalability, maintainance/extension scalability ?
02:31:25 <mje> efficiency
02:31:55 <ski> that would mostly depend on using good algorithms and data structures, i'd think
02:32:14 <mje> any evidence?
02:32:17 <ski> (not that i know very much about the particular case of model checkers)
02:33:04 <mje> (substitute any computationally hard problem)
02:33:45 <ski> guess i'll have to say, dunno :/
02:35:45 <ski> just thinking haskell prolly has some overhead over strict and more lowlevel langs. where pluses would be possible efficiency gains because of laziness (also can mean clearer more maintainable code) and also general high-levelness of haskell allows algos to be expressed more easily
02:35:58 <ski> etc
02:36:44 <mje> I've noticed that for some reason much of these programs for hard problems (e.g. SAT, modelchecking, Theorem proving, ...) are written in C
02:36:48 <mje> the successful ones anyhow
02:37:57 <mje> one would think that they could benefit from the things you've mentioned...
02:38:26 <ski> guess the devil's in the details
02:38:30 <mflux_> was there ever a release of Eager Haskell?
02:39:01 <mflux_> I found a website saying it'll be released 'in a few weeks' but no any other dates on the page, such as when it was last updated (and it was dynamic, hence headers revealed nothing)
02:39:20 <earthy> um. mje, that is not quite true.
02:39:33 <earthy> HOL, Isabelle and Coq are written in ML (or variants thereof)
02:39:46 <earthy> in fact, ML itself was designed as the meta language for a theorem prover
02:40:22 <mje> I'm familliar with ZCHaff, SMV, CVClite
02:40:34 <earthy> however, it *is* true that in the pursuit of speed modelcheckers and BDD libraries have been written in C
02:40:46 <earthy> there you go. model checkers. not theorem prover.s ;)
02:40:56 <mje> CVCLite is a theorem prover
02:41:01 <earthy> it is?
02:41:05 <mje> and ZChaff is a SAT solver
02:41:26 <mje> yea, it's from cornell or something
02:41:39 * ski continues watching SICP lectures
02:42:02 <earthy> quantifier-free first-order formulas
02:42:05 <earthy> right. :)
02:42:08 <ski> hiya TheHunter
02:42:14 <TheHunter> morning ski.
02:42:21 <earthy> that's not theorem proving. that's running a decidable algorithm. :)
02:42:23 <boegel> yo TheHunter
02:42:26 <mje> hehe
02:42:36 <TheHunter> y0, boegel
02:43:03 <mje> earthy: nevertheless useful ;-)
02:43:19 <tessier> More people in #haskell than #scheme...interesting.
02:43:24 <shapr> yay
02:43:31 <ski> morn shapr
02:43:32 <mje> scheme bites my a$$
02:43:38 * tessier is just needing to learn a functional language
02:43:43 <earthy> mje: yea, if you can state your problem in quantifier free first order formulas
02:43:59 <tessier> My vision/ability as a programmer is quite limited. I am hoping another way of looking at problems can get me out of the rut.
02:44:06 <earthy> then you've come to the right place
02:44:14 <boegel> yo shapr
02:44:23 <boegel> shapr: how about the feedback on my HRay article ?
02:44:25 <mje> you should read hudak
02:44:40 <mje> tessier: --^
02:45:18 <mje> or what's that one: the structure & interpretation...
02:45:35 <ski> structure and interpretating of computer programs
02:45:37 <mje> I heard that was a good book on functional programming
02:45:45 <ski> it's even online
02:45:50 <mje> really?
02:45:52 <mje> where?
02:45:58 <ski> lemme look ..
02:46:14 <genneth> @google sicp
02:46:16 <genneth> oh damn
02:46:24 <ski> http://mitpress.mit.edu/sicp/
02:46:27 <mje> oh you're right!
02:46:29 <mje> cool
02:46:34 <mflux_> people here are completely helphelpless witowithout lambdabot ;)
02:46:43 <mflux_> damn, irssi-feature hits again
02:46:51 <ski> (also http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/ has lecture vids .. that i'm currently watching ;)
02:46:57 <mflux_> (lag-induced)
02:47:01 <tessier> I've glanced over parts of SICP
02:47:04 <tessier> It's Scheme based though
02:47:10 <tessier> Which may be fine with me, I'm not too particular.
02:47:18 <tessier> But I have a feeling you folks would prefer I study haskell. :)
02:47:20 <earthy> SICP is good
02:47:32 <mje> ski: tell me that's not less than boring
02:47:38 <earthy> it's nto
02:47:40 <earthy> not, even
02:47:49 <earthy> tessier: not necessarily
02:47:57 <ski> mje : the lectures are quite fun, methinks
02:47:58 <poetix> For a real entry-level approach to FP, the "little" and "seasoned" schemer books are quite good
02:48:06 <poetix> (if a little cloying)
02:48:16 <earthy> ofcourse, there's also the haskell tutorials
02:48:20 <tessier> poetix: I have both of those books
02:48:28 <ski> tessier : you can also head for a tutorial for haskell, or maybe even buy/borrow a book
02:48:43 * tessier is looking at the "gentle introduction to haskell" tutorial on the website
02:48:54 <poetix> tessier: then you're probably ready for Haskell
02:49:02 <ski> which is said by some people to be not so gentle ..
02:49:18 <ski> tessier : have you checked out Yet Another Haskell Tutorial ?
02:49:22 <earthy> I'd take the 'yet another haskell tutorial'. :)
02:49:25 <poetix> The Grindingly Frustrating Introduction to Haskell
02:49:40 <earthy> or the 'haskell tutorial for C programmers'
02:49:45 <mje> haha
02:49:48 <earthy> at http://www.haskell.org/~pairwise/intro/intro.html
02:49:57 <mje> 2BG videos
02:49:59 <ski> YAHT : http://www.isi.edu/~hdaume/htut
02:50:00 <genneth> i would say that haskell isn't too easy until you get your head wrapped around monads
02:50:13 <genneth> that said, having only done that about a month ago...
02:50:18 * tessier will check out YAHT
02:50:34 <boegel> genneth: I haven't wrapped my head around monads yet, and still find it quite neat :)
02:50:40 <poetix> http://www.nomaware.com/monads/html/
02:50:48 <poetix> Very helpful
02:51:00 <genneth> boegel: i find that without "getting" monads, haskell is mostly the same as say, ML or scheme
02:51:04 <ski> earthy : i thought the 'for C programmers' was quite nice, if a bit short
02:51:19 <genneth> boegel: useful, but not awe-inspiringly so :-p
02:51:56 <tessier> scheme does not have monads?
02:52:13 <ski> not in (more or less) standard libs
02:52:20 <boegel> genneth: I was able to write a ray tracer, and I found that pretty cool :) I wouldn't have the patience to write on using C probably
02:52:26 <ski> you can sure program monads in scheme, though
02:52:29 <poetix> Monads aren't supported by Scheme's syntax or type system in the way they are by Haskell's.
02:52:41 <mje> just curious, does anybody know Scala?
02:52:52 <ski> (tessier : e.g. http://okmij.org/ftp/Scheme/monad-in-Scheme.html)
02:52:57 <poetix> You can program monads in Python...
02:53:13 <ski> iirc some guy even used monads in C++
02:53:19 <TheHunter> mje, funny thing, i read the ScalaOverview just yesterday.
02:53:44 <TheHunter> which obviously doesn't count as 'know'
02:53:46 <mje> TheHunter: pretty nice language, don't you think?
02:54:05 <poetix> @google scala overview
02:54:06 <genneth> ski: now there's a thought... implement monads in C++
02:54:11 <genneth> haha
02:54:26 <TheHunter> mje, yeah i quite liked it.
02:54:32 <genneth> poetix: sorry; but it's somewhere between hilarious and frustrating
02:54:46 <TheHunter> who killed lambdabot?
02:55:17 <mflux_> genneth, like http://www.cc.gatech.edu/~yannis/fc++/New1.5/lambda.html#monad ?
02:55:17 <mauke> huhu, complete with operator overloading so you can do stuff like m >>= f;
02:55:41 <ski> http://scala.epfl.ch/
02:56:03 <poetix> ski: can you moo as well?
02:56:15 <genneth> mflux_: oh that! i'd completely forgot about that
02:56:30 <ski> poetix : no. not that
02:56:44 <mje> they say Scala is the `state of the art' in type-systems
02:57:18 <mflux_> the example of a return type for a lambda function below that stuff is mind-boggling..
02:57:43 <TheHunter> i frankly didn't see why these path-dependent types have the enourmous expressive power they claim.
02:57:45 <mje> but the overview doesn't really emphasize that
02:59:06 <genneth> mflux_: meh; i've been playing with optimizing sparse matrix multiplication using statically determined sparsity; the types for those are even worse :)
02:59:43 <poetix> @seen lambdabot
02:59:50 <poetix> Sorry...desperate...
02:59:51 <mflux_> poetix, :-)
03:00:09 <mflux_> lambdabot needs a cluster. with failover.
03:00:20 <mje> TheHunter: you should look at some papers like "family polymorphism" and "delegation layers"
03:00:22 <poetix> A lambdabotnet
03:00:40 <mflux_> distributed lambdabot
03:01:02 * poetix images a beowulf cluster of those...
03:01:43 <mje> TheHunter: those path dependent types actually allow them both functional and object oriented decomposition together, which to my knowledge hasn't been acheived before
03:02:22 <mje> but I'm sure somebody could correct me
03:02:35 <ski> mje : scala has some kind of dependent types ??
03:03:00 <mje> ski: yep
03:03:15 <ski> well, OCaml is a functional language with what seems like a quite nice OO system
03:03:18 <mje> see `A nominal theory of objects with dependent types'
03:03:33 <mje> ski: but OCaml doesn't allow you to combine the decompositions
03:03:42 <ski> which means ? :)
03:03:56 <TheHunter> mje, i gotta look more closely into it, then. I don't quite see how they support the ADT idea, though, as far as I saw it, even if you do pattern matching on objects, the hierarchy is still extensible.
03:04:47 <mje> ski: meaning, you can allow room to modularly extend variations to a data type as well as operations on the data type and its variants
03:05:01 <tessier> oh man...OCaml...I haven't even looked at that one  yet
03:05:06 <mje> i guess modularly being the key word
03:05:12 <tessier> Only 42 people in #ocaml though. :)
03:05:22 <tessier> ocaml < scheme <  haskell
03:05:25 <mje> tessier: from what I've heard the OOP in OCaml should be left alone
03:06:17 <mje> I guess they've tried to combine OOP and FP but failed
03:06:39 <mje> Scala has succeeded though
03:06:40 <ski> they say standard libs doesn't use the OO so much because it got added afterwards
03:06:43 <musasabi> It would be nice to see some size statistics of freenode channels.
03:07:15 <tessier> musasabi: What sort of statistics? You could do a /list and generate your own.
03:07:21 <ski> mje : they do provide (at least some) support for (purely) functional OO
03:07:51 <ski> mje : like copy-modify of nonmutable objects
03:08:40 <ski> and support for binary methods with correct typing etc
03:09:00 <mje> ski: perhaps, I've never programmed in OCaml, but work with a few guys who do, and they say to stay away from the OOP there
03:09:03 <ski> (correct meaning, one which you don't have to cheat by "dynamically downcasting")
03:09:38 <musasabi> tessier: yes, but it goes under the category "one could do if one was not lazy".
03:10:19 <ski> mje : from what i understand, the OO system in ocaml is maybe a bit similar to java's but superior. though if you're looking for some other OO expression, maybe OCamls is not the best
03:11:11 <mje> I see
03:12:10 <ski> (also, AGs claim to have some of the benifits of both OO and FP ..)
03:12:41 <mje> AGs?
03:12:49 <ski> Attribute Grammars
03:13:03 <musasabi> It would be nice to see a good introduction into AG
03:13:16 <ski> (another declarative paradigm, i think one could say ..)
03:13:52 * tessier wonders why functional programming has been around for decades but isn't any more popular than it is
03:13:54 <ski> (or at least, distinct style)
03:14:16 <tessier> I can understand how speed issues might have held things up in the past
03:14:18 <ski> many reasons
03:14:21 <mje> tessier: read "more is less"
03:14:25 <wilx> I would guess tradition and lack of nice languages until Haskell has been invented :)
03:14:30 <mje> wait what's it called?
03:14:32 <tessier> But now when code correctness is more important you would think people would take another look
03:14:49 <mje> tessier: no that can't be it
03:15:07 <mje> 1 sec
03:15:17 <ski> industry lag and "must one what everyone else uses / is current hype" ?
03:15:57 <mje> http://www.dreamsongs.com/WIB.html
03:16:02 <mje> that's the one
03:16:05 <wilx> Also because it is mainly Pascal/C/Java that is/was being taught on HS and later on Unis.
03:16:08 <ski> not wanting to have to hunt for programmers who know the different paradigm ?
03:16:29 <ski> general cluelessness
03:16:31 <ski> etc
03:17:10 <poetix> Haskell looks like math. Java looks less like math. People are scared of math.
03:17:24 <reffie> math sucks.
03:17:37 <poetix> Math is hard.
03:17:47 <tessier> ski: That is a good point. But Paul Graham made some good counter arguments to thar.
03:17:47 <tessier> that
03:17:49 <mje> false
03:18:04 <tessier> I do really like the idea of specifying what to do instead of how to do it
03:18:14 <ski> (tessier : just reiterating what iv'e seen other say ..)
03:18:23 <tessier> Although the difference is a little hard to define because I keep falling back to imperative thinking
03:18:45 <mje> tessier: the joke is on you when you get to monads
03:18:45 <ski> tessier : yeah, like relational databases superiority over navigational databases
03:19:01 <ski> tessier : it's not perfect. but it's better
03:20:05 <bourbaki> moin
03:20:13 <tessier> ski: Navigational databases? Like a filesystem?
03:20:14 <mje> bourbaki: is that the name of those french math guys?
03:20:18 <ski> (tessier : specify what information you want, and leave to the sys to optimise and find out how to get the information, etc ..)
03:20:22 <bourbaki> mje: yes
03:20:30 <bourbaki> i have got a question
03:20:51 * tessier has also been playing with Zope/Plone lately and will be doing a project with ZODB soon
03:20:51 <bourbaki> if you have a recursive function that resembles something like a for looo
03:20:52 <mje> bourbaki: the ones who tried to make everything so completely formal and then fell on their faces?
03:20:53 <bourbaki> er loop
03:21:05 <tessier> That should prove interesting. An object db is basically a navigational db right?
03:21:09 <tessier> Heirarchical etc.
03:21:22 <poetix> tessier: Right
03:21:26 <bourbaki> mje: heh i dont know they invented lie algebra and did a lot of cool things in topology form what i know
03:21:31 <ski> tessier : yeah, like you have to be aware if a relation is implemented using one datastructure or another, and what indices there are, just to be able to correctly exctract info from it
03:21:38 <boegel> is there a unix command for splitting and joining files ?
03:21:38 <tessier> Why didn't the Ada guys look at something functional? They are all about proveable correctness.
03:21:39 <ski> morn bourbaki
03:21:42 <boegel> yo bourbaki
03:22:04 <mauke> boegel: you can concatenate files with cat
03:22:06 <bourbaki> will this recursive function then due to the lazyness expanded in such a way that its optimal (that is loop unrolling like) ?
03:22:08 <tessier> boegel: Yep. split and cat
03:22:09 <bourbaki> hi boegel
03:22:17 <boegel> tessier: thanks
03:22:34 <bourbaki> tessier: did you confuse the s with an r ;)?
03:23:24 <tessier> bourbaki: huh?
03:23:27 <ski> bourbaki : sorry ?
03:23:44 <bourbaki> tessier -> terrier ;)
03:23:45 <ski> s/expanded/expand/ ??
03:24:02 <bourbaki> ski: what i want to know is if the lazyness will flatten loops out
03:24:12 <bourbaki> if i write c code and i write a for loop
03:24:31 <bourbaki> then if i dont use fixed elements for the loop then it wont be unrolled properly
03:24:38 <bourbaki> that is if i use variables
03:24:51 <bourbaki> which is pretty shitty if you want to write reusable code
03:25:06 <ski> example ?
03:25:32 <bourbaki> for( i = 0; i<x; i++ ) ...
03:25:32 <bourbaki> and
03:25:36 <bourbaki> for( i = 0; i<20; i++ ) ...
03:25:44 <bourbaki> in the x case the loop cant be unrolled
03:25:52 <bourbaki> so there are a lot of jumps and such
03:25:58 <earthy> bourbaki: yes it can
03:26:00 <bourbaki> in the 20 case the loop can be unrolled
03:26:01 <ski> it can be unrolled, partly
03:26:08 <earthy> using duff's device-like code
03:26:11 <ski> yeah
03:26:17 <earthy> which may compilers actually do
03:26:18 <bourbaki> whats that?
03:26:21 <earthy> many
03:26:26 <bourbaki> what i would like is somethingl ike this
03:26:32 * poetix learns how to disappear into silk and amphetamine
03:26:35 <tessier> ocaml < scheme <  haskell < lisp
03:26:40 <tessier> Lots of people in #lisp. Wow.
03:26:49 <bourbaki> loop bounds -> runrolled_loop
03:26:54 <ski> http://catb.org/~esr/jargon/html/D/Duffs-device.html
03:26:55 <mauke> http://www.lysator.liu.se/c/duffs-device.html
03:26:58 <bourbaki> and then i inject the functioin
03:27:07 <earthy> http://catb.org/~esr/jargon/html/D/Duffs-device.html
03:27:15 <earthy> gawd.
03:27:21 <earthy> this machine *is* slowing me down
03:27:48 <earthy> (so much for not being dependent on your computer's speed)
03:28:28 <bourbaki> hm
03:28:35 <bourbaki> this wont unroll either would it?
03:28:46 <bourbaki> what i want i think is an in place compiler
03:29:06 <bourbaki> there are still jumps
03:29:32 <ski> bourbak : the important part of that isn't actually that he wants to write all byte to the same mem-mapped-io.reg, but that you only have to check for loop termination every 8 (or whatever) executions of the body, instead of every time
03:29:51 <bourbaki> example if i write a 3x3 matrix multiplication method in c that uses loops it always slower then writeing it in plain c without loops
03:29:54 <ski> so, partly unrolled loop
03:30:11 <ski> (normally just called "unrolled", e.g. -funroll-loops, iirc)
03:31:10 <bourbaki> but in haskell this problem wouldnt arise due to the lazyness right?
03:31:26 <ski> bourbaki : if the loop bounds are statically known, and small, then i think many compilers would happily duplicate the body code for all the iterations (especially if optimising for speed rather than for space)
03:31:36 <ski> depends
03:31:44 <mje> Hey here's one way to make hugs give a segmentation fault
03:31:49 <mje> let x = 1:[ y | y <- tail x ] in x
03:31:55 <bourbaki> ski: yes as i said i want the functions to be reusable so the bounds arent fixed
03:32:35 <TFK> mje, is that even valid code?
03:32:46 <mje> TFK: yep, sure is
03:32:46 <bourbaki> plus one of the amd guys at a conf showed that its always better to write all the stuff out for matrix stuff and such cause loops are always slower
03:32:47 <ski> i think you could possibly get this kind of (partly) unrolled loops, in haskell
03:33:08 <TFK> It gives me a stack overflow error, but doesn't crash.
03:33:13 <mje> hugs?
03:33:24 <TFK> Anyway, how is that valid? After all, there is no tail at the time of the call.
03:33:29 <TFK> Yup.
03:33:29 <bourbaki> maybe i need to write an inplace compiler then for c
03:33:30 <ski> mje : that is the same as let x = 1:(let y = y in y) in x  methinks
03:33:31 <Igloo> If you recurse infinitely then hugs can crash when the C stack overflows
03:33:51 <mje> I have hugs version March 2005
03:34:12 <ski> and you got a segfault ? not a stack overflow ?
03:34:17 <mje> yep
03:34:29 <mje> Hugs.Base> let x = 1:[ y | y <- tail x ] in x
03:34:30 <mje> [1Segmentation fault
03:34:33 <TFK> I have WinHugs, the latest version of that being from 2004 or somesuch o_O
03:34:51 <mje> WinHugs is for pussies
03:34:59 * TFK kicks mje
03:35:03 <mje> hehe
03:35:14 <TFK> Go suck on RMS.
03:35:29 <TFK> So... how does that reach a stack overflow? tail x is an empty at the first time it's evaluated, no?
03:35:45 <TFK> *an empty list
03:35:55 <ski> it's a thunk, that when forced, will force itself
03:36:03 <ski> it is *not* an empty list
03:36:08 <TFK> Why not?
03:36:41 <ski> tail x is the elements y, such that y comes from tail x
03:36:46 <mje> at any rate, hugs shouldn't bite the dust right?
03:36:50 <ski> which means the same as tail x = tail x
03:37:17 <ski> TFK : there never enters any empty list into the picture, there
03:37:27 <TFK> But there are no y's. tail x should be an empty list.
03:37:42 <TFK> x is a list. tail (x:xs) = xs, is that not so?
03:37:48 <TFK> err
03:37:53 <mje> TFK: but x is waiting evaluation
03:37:54 <ski> TFK : list comprehensions are not accumulatively generated, starting from an empty list
03:37:57 <mje> think lazy
03:38:15 * boegel is still dancing and can't feel his feet anymore
03:38:25 <bourbaki> boegel: why?
03:38:28 <bourbaki> got your degree?
03:38:41 <ski> it will only be an empty list if something explicitely tells it to be an empty list
03:38:41 <mje> ski: should this be a bug?
03:38:49 <TFK> What does "accumulatively generated" mean?
03:38:52 <boegel> bourbaki: no not yet, but I got some good news
03:38:58 <boegel> can't share yet though, sorry :)
03:39:04 * TheHunter can't think of a witty remark against http://www.haskell.org//pipermail/haskell/2005-July/016087.html
03:39:09 <bourbaki> boegel: heh ok
03:39:14 <boegel> I'll tell you next Wednesday
03:40:11 <ski> just because it hasn't found any y's yet, doesn't mean that it stops thinking that there could maybe come some y's later (which will of course never happen, because it's waiting on itself, but it doesn't "know" that. it's a bit like a kind of deadlock. with only one participiant :)
03:40:33 <TFK> This stuff sure is weird.
03:40:56 <ski> mje : yes, a bug. but prolly a known bug (which maybe can be a bit hard to avoid, given hugs' implementation)
03:40:57 <Philippa> TheHunter: 'sa difficult one, because effectively you're debating macros
03:41:37 <Philippa> I mean yeah, in the real world it's not always horrendously difficult to just write the traversal yourself, but hey
03:41:51 <TheHunter> Philippa, well, i guess optimizeDeep = everywhere (mkT optimize) is what he wants and it took me less than two minutes to come up with that.
03:42:04 <ski> TFK : by "accumulatively generated", i mean like it first says, i've currently found no y's so, it's currently an empty list, then later when y's arrive, it would append them to this list.  this is not how it happens
03:42:37 <Philippa> TheHunter: sure. Now watch while I try and remember which framework that uses.
03:43:05 <Philippa> I mean, we've got a fair amount of the power, but we've not got canonical answers yet and that means it tends to be a rarely-understood thing
03:43:30 <Philippa> I mean yeah, you /could/ just sell the guy a bridge to live under...
03:43:34 <TFK> Hmmm. I think I kinda got it o_O thanks.
03:45:24 * ski wonders if Arka's solution in scheme would also optimise Exprs that will result from applying functions inside a datastructure to arguments
03:47:02 <TFK> I don't understand that thread, but is the proposed solution by Mirko Rahn enough?
03:47:26 <Philippa> for the proposed problem, yes
03:47:30 <mje> those sussman lectures are awful!
03:47:40 <TFK> Looks deceptively short.
03:47:46 <Philippa> Haskell code often does
03:49:33 <Itkovian> 'noon.
03:49:46 <ski> mje : maybe a little terse
03:50:34 <mje> ski: he does do some funny stuff with his eyebrows though
03:50:42 <ski> yeah :)
03:50:58 <ski> (and the sound quality is not the best, always, 'tseems)
04:34:18 <Grimace> wotcha all
04:37:05 <shapr> hoi Grimace, ltns
04:38:30 <Grimace> true
04:40:53 <shapr> How's code?
04:41:42 <Grimace> somewhat imperative :/
04:42:00 * Grimace grins, I have started work this week as a web developer
04:42:28 <shapr> Wow, what frameworks?
04:42:37 <shapr> J2EE? RoR? Seaside? PHP?
04:43:18 <Grimace> PHP with Smarty & BinaryCloud
04:43:32 <shapr> Never heard of the last two, but I stay away from PHP.
04:43:33 <Philippa> Grimace: you in #afp as well by any chance?
04:44:17 <Grimace> philippa: certainly am!
04:45:46 <shapr> Grimace: So, you've come by here to write a decent PHP parser so you can do take care of your code? :-)
04:49:31 <boegel> shapr: any feedback on my HRay article yet ? :)
04:49:43 <shapr> Um, yeah.. it's cool :-)
04:49:58 <boegel> heh
04:50:03 <boegel> no language stuff ? :)
04:50:11 <shapr> I really liked your pseudocode description of the raytracing article, I was enlightened!
04:50:21 <boegel> heh, okay
04:50:42 <shapr> I read up on raytracing long ago, but when I read about this algorithm I felt like "Wow! This is so much better!"
04:50:44 <boegel> I also used that in my thesis
04:50:59 <boegel> shapr: that _is_ the algorithm :)
04:51:28 <shapr> Yeah, but the algorithm you're using is much better than whatever POV-Ray was using in the early 90s
04:51:58 <boegel> I bet POV-Ray is using the same one now, besides several extensions
04:52:23 <shapr> Yeah, probably so. But the algorithm I learned years ago wasn't this good.
04:52:33 <shapr> It was much more tedious and took more steps.
04:52:58 <boegel> the algorithm is really simple, that's what makes it so usefull as a 'first' programming experience
04:53:03 <boegel> the results you get are also quite cool
04:54:38 <shapr> Yeah, I've seen that.
04:56:31 <boegel> I hope I'll find time to work on it this afternoon
04:56:53 <boegel> if I don't, I won't be able to finish it before The August release either, 'cause I'm on holiday
05:07:58 * boegel reboots
05:18:47 <shapr> hey swiert, get my email?
05:19:05 <swiert>  let me check
05:19:42 <swiert> which address did you send it?
05:22:07 <swiert> shapr: it says EditText and FindPage but no AttachFile
05:24:07 <shapr> Hm, weird
05:24:26 <shapr> You're logged in as WouterSwierstra, right?
05:24:54 <shapr> In the line underneath EditText and FindPage, do you see "Or try one of these actions: ..." ?
05:25:59 <swiert> how can I check whether I'm logged in?
05:26:48 <shapr> The top right of the wikipage should say WouterSwierstra and not UserPreferences
05:27:32 <boegel> shapr: mine says KennethHoste, is there something wrong with my system ? :p
05:27:36 <boegel> ;)
05:28:16 <shapr> Nah, that's right :-P
05:30:30 <swiert> hmm, I reckon I'm logged in. My user preferences says I'm logged in for ever.
05:32:23 <swiert> ah - I got it.
05:33:05 <swiert> I set a theme in my user preferences that somehow hid the link.
05:37:36 * boegel wanders around what to do
05:37:58 <swiert> shapr: great - it works.
05:46:39 <shapr> swiert: cool
05:50:33 <basti_> hi
05:55:06 <boegel> yo basti_
05:55:58 <swiert> shapr: when do you plan to release issue four?
05:56:09 <basti_> yow.
05:56:19 * basti_ has an itch to do a TMR article soon
05:57:32 * basti_ knows this is lame
05:59:51 * Itkovian thinks somebody will now rejoice
06:00:39 * basti_ reads what cartesian closed catergories are
06:01:31 * boegel just yawns
06:02:03 * basti_ puts a yi-emacs firecracker under boegel's butt
06:02:27 * boegel notices how the firecracker just fades out beneath his hairy butt
06:03:05 * basti_ notices the smell
06:03:07 <basti_> eww
06:03:23 <genneth> i guess there isn't enough oxygen to sustain combustion
06:16:08 <basti_> what do you people think about the "gentle introduction to category theory" by Fokkinga?
06:20:07 <vegai> sounds a little absurd
06:28:47 <tessier> Why didn't the Ada guys look at something functional? They are all about proveable correctness.
06:29:02 * tessier picks up his convo from three hours ago
06:29:25 <xs> because they still haven't got over algol 68?
06:29:31 <ski> tessier : not exactly same culture/traditions
06:29:53 <ski> tessier : more like direct heritage of algol and pascal
06:30:07 <ski> structured programming movement, etc
06:30:51 <ski> pre- and post-conditions, iteration invariant, hoare logic ..
06:31:05 <ski> (of course much carries over to FP)
06:32:10 <ski> (basti_ : hm, trying to find a non Z packed version of it ..)
06:33:13 <basti_> ski: i got one
06:33:20 <basti_> ski: i was asking about opinions?
06:34:15 <ski> only skimmed through it some time ago ..
06:36:10 <basti_> i c
06:38:27 <tessier> Has anyone written any web apps in haskell? Or tools for writing web apps?
06:38:42 <michaelw> tessier: google for WASH
06:39:11 <Muad_Dibber> hmm
06:39:45 <Lemmih> Or HSP.
06:41:02 <Lemmih> @google Haskell Server Pages
06:50:48 <tessier> hmm...WASH and HSP both seem relatively immature.
06:51:02 <tessier> I think I'll stick with zope for my web apps for now.
06:56:27 <basti_> http://www.unf-unf.de/show850.html < great music/cartoon swf
07:00:33 <Muad_Dibber> @google webfunctions Haskell
07:01:19 <kzm> When I import List qualified, should I be able to use its functions unqualified?  Surprisingly, it seems I can.
07:01:56 <TheHunter> many of the Data.List functions are already in the Prelude.
07:06:39 <kzm> Hmm..yes, but not this one (sortBy).  I.e. if I comment out the import, it gives an error.
07:07:17 <Igloo> Are you compiling your code or using ghci/hugs?
07:07:25 <kzm> Oh, drat.
07:08:04 <kzm> I used "import ... as ...", which seems to be just like regular "import".  The right syntax is of course "import qualified ... as ..."
07:08:12 <jacobian> What is a braided monad
07:08:20 <kzm> (so what does "as" do in my case?)
07:08:32 <kzm> (should this be a syntax error?)
07:08:39 <Igloo> No
07:08:47 <Igloo> It allows you to say Foo.bar
07:09:07 <Igloo> I think you can import 2 different bar's as long as you don't ambiguously refer to bar
07:10:00 <kzm> Ah, so it's a short form of "import Foo \n import qualified Foo as F"
07:10:53 <kzm> perhaps a good idea, especially with long and tedious module names and massive overloading of operations (Map & friends).
07:11:12 <kzm> Well - thanks.  Gotta go.
07:20:38 <boegel> basti_: cool
07:43:45 * tomdavie yawns
07:44:10 <Lemmih> Bored or tired?
07:44:51 <Muad_Dibber> or both..
07:45:31 <ski> or whichever we want of that (but only one of them) ?
07:46:24 <tomdavie> both
07:47:18 <tomdavie> Literature Survey to write... it's hard not to be bored with that on a friday afternoon
07:48:29 <Muad_Dibber> depending on the literature its about :P
07:50:36 <tomdavie> at the moment... all the excitement of forward animating imperitive languages
07:50:49 <tomdavie> (bored bored bored bored)
07:52:09 <Muad_Dibber> :D
07:52:11 <Muad_Dibber> that indeed is boring
07:53:02 <tomdavie> forward animatingy lavy functional languages, while slightly more interesting, is really fucking confusing and hence pointless anyway
07:53:05 <tessier> YAHT has so many typos...didn't anyone proofread this?
07:53:21 <Speck> I noticed a bunch too
07:53:46 <Speck> yet it remains an excellent resource
07:53:48 <mauke> if you're bored, solve http://spoj.sphere.pl/problems/SIZECON/
07:54:24 <tessier> mauke: 42
07:54:24 <metaperl> I think ingy on #perl6 has re-formatted and edited YAHT
07:54:32 <mauke> tessier: wrong, actually
07:54:41 <tessier> oh darn
07:56:34 <Speck> "the set of integers" as in the set of all integers?
07:56:51 <Speck> s/integers/positive integers
07:57:14 <mauke> no, the set of integers given on stdin
07:57:29 <Speck> oh
07:59:09 <Speck> a haskell solution would be pretty brief
08:01:09 <mauke> the best haskell solutions is 58 counted characters
08:01:44 <mauke> found by someone called "Konstantin"
08:01:54 <zyff> solution to what?
08:02:06 <Speck> oh snap they go by characters... and you got 6?!
08:02:31 <mauke> Speck: yeah, I brute-forced the solution. note that the "language" is plain text
08:02:45 <mauke> my perl solution isn't a cheat, though
08:03:06 <mauke> zyff: http://spoj.sphere.pl/problems/SIZECON/
08:03:08 * zyff apologizes for thinking loud
08:03:20 <Speck> I see... they give you the input ahead of time
08:06:04 <ski> ingy@#perl6 edit of yaht : http://svn.openfoundry.org/pugs/docs/yaht.kwid
08:07:14 <lstna_> 'noon ski
08:07:49 <zyff> mauke: what do you mean by "best"?
08:08:13 <mauke> shortest
08:09:03 <zyff> ah, ok
08:10:26 <wilx> Hmm, I am upgrading GHC from FreeBSD ports. I hope I won't have to reinstall all Haskell packages that I installed by hand...
08:11:00 <lstna_> How long is your perl versio mauke?
08:11:01 <Lemmih> Did you install them in your local package conf file?
08:11:20 <lstna_> s/versio/version/
08:11:32 <mauke> lstna_: see http://spoj.sphere.pl/ranks/SIZECON/ (the RESULT column)
08:12:15 <wilx> Hmm, I don't think so. I installed them as root globally.
08:12:27 <Lemmih> Then they're doomed.
08:12:56 <lstna_> 6? Wow! (/me decidedds not to mention my 21).
08:14:00 <ski> hiya lstna_
08:14:08 <basti_> wow.
08:14:20 * basti_ is AGAIN impressed by haskell
08:14:40 <basti_> I was coding a repeat command for yi-emacs.
08:14:49 <wilx> Damn.
08:15:05 <lstna_> Howdy ski.
08:15:16 <basti_> I finished the repeat handler (its pretty small), then noticed i need to do some refactoring... did that, as a result could build in the repeat handler... and it works!
08:15:36 <Speck> yi-macs :-P
08:16:20 <Speck> yi in chinese (ignoring tones) is pronounced exactly like the e in emacs
08:16:42 * lstna_ wishes he could like Haskell. :(
08:16:47 <basti_> Speck: send a patch to the yi trivia collection
08:17:15 <basti_> lstna_: i talked just like you, and now I taught a haskell editor behaving somewhat like emacs in < 400 lines
08:19:02 <lstna_> That's why I keep coming bacl basti_. Hoping that something will trigger the desire to continue trying to get to grips with it
08:19:32 <Speck> it's worth it, at least for an excercise in mind bending
08:19:43 <basti_> what are you interested in on the "funny computing" field?
08:19:53 <basti_> we had l-systems recently
08:20:05 <basti_> lstna_.
08:20:47 <irsirius> can someone help me? i try to install wxhaskell. i installed it and try to register the package with ghc-pkg -D wxhlibdir=/usr/lib/ghc-6.4/wxhaskell-0.9.4/ -ai wxcore.pkg
08:21:03 <irsirius> but i get Reading package info from "wxcore.pkg" done.
08:21:10 <irsirius> ghc-pkg: ${wxhlibdir}/imports doesn't exist or isn't a directory
08:21:36 <irsirius> but the imports-dir does exist...
08:22:13 <wilx> Sounds like your wxhlibdir is not defined.
08:22:18 <lstna_> Sorry basti_ I've got a big download running and it makes my thin pipe sluggish.
08:22:27 <Lemmih> ghc-pkg doesn't substitute macros any more.
08:22:35 <lstna_> l-systems? That's fractals right?
08:23:18 <Lemmih> irsirius: What platform are you on?
08:23:27 <irsirius> Lemmih: debian
08:23:45 <irsirius> Lemmih: where can if find docs for ghc-pkg?
08:24:11 <Lemmih> Can't you just do 'make install'?
08:25:02 <irsirius> no i cant compile it
08:25:25 <Lemmih> ghc-pkg docs: http://haskell.org/hc/docs/latest/html/users_guide/
08:25:33 <basti_> i NEED continuations in yi-emacs. I see them at the horizon
08:26:04 <Lemmih> You probably can't install it if you can't compile it...
08:26:10 <irsirius> wxc/include/wrapper.h:534: error: invalid type `const char[11]' for default
08:26:10 <irsirius>    argument to `const wxString&'
08:27:11 <ski> lstna_ : l-systems : http://chriscoyne.com/cfdg/ and http://www.ozonehouse.com/ContextFree/  (and http://en.wikipedia.org/wiki/L-system)
08:27:54 <Lemmih> irsirius: Check that your wx version is compatible with wxHaskell.
08:33:24 <lstna_> Thanks ski. Reminds me of doing COnway's game of life in Logo.
08:34:08 <ski> basti_ : you do ? :)
08:34:14 <ski> basti_ : for what ?
08:34:25 <basti_> ski: tab completion in the bottomline
08:34:44 <basti_> "bkspc" cc's
08:34:53 <ski> hm
08:34:58 <basti_> i think it could work
08:35:06 <basti_> that alone would be worth a try i think
08:35:06 <basti_> =)
08:35:20 <ski> ContT or something, i guess ?
08:35:35 <basti_> i dont know which sort specifically
08:35:47 <basti_> but it would make C advocates cringe, thats why i should do it
08:35:48 <basti_> =)
08:35:55 <ski> :)
08:36:01 <Speck> hee hee
08:36:46 <irsirius> Lemmih: it worked. simply defined the directory in the pkg-file
08:36:59 <tessier> Every time you do that Brian Kernighen kills a kitten.
08:37:05 <basti_> lstna_: yes l-systems is fractals
08:40:36 <lstna_> I played with fractals 20 years ago not long atfer Mandelbrot first released his paper on them. (I think I saw him in the canteen once).
08:41:12 <basti_> -g-
08:41:22 <basti_> well then dig that:
08:41:58 <basti_> @plugs do x<-"aaabaaa";case x of 'a' -> "a"; 'b'->"bbb"
08:42:19 <basti_> wheres lambdabot.
08:42:20 <Lemmih> No lambdabot.
08:42:29 <basti_> "aaabbbaaa"
08:42:34 <basti_> is the result
08:42:39 <lstna_> That was in C under DOS. (Hard work--thank dog for van Dam)
08:42:51 <basti_> why? and how do you make l-systems with that? :)
08:45:37 <lstna_> I don;t get that? x is a String (or [Char]) and your matching x against a Char?
08:46:06 <basti_> :)
08:46:14 <basti_> magic!
08:46:17 <musasabi> lstna_: that uses the list monad.
08:46:19 <basti_> :P
08:46:25 <basti_> musasabi: youre giving it away
08:46:32 <basti_> lstna_: do you know concat and map?
08:46:34 <musasabi> basti_: just a little hint.
08:46:42 <basti_> musasabi:  ;)
08:47:34 <lstna_> yep
08:47:49 <fraxtal> do you support monadic rights
08:48:21 <basti_> lstna_: think of "the list monad" as of "some magic thing that puts concat (map (stuff))" everywhere you need it.
08:48:33 <basti_> lstna_: can you see where it happened in my example?
08:49:16 <ski> @plugs [y | x<-"aaabaaa", y <- case x of 'a' -> "a"; 'b'->"bbb"]
08:49:22 <ski> arg
08:49:30 <lstna_> "magic" doesn't appeal much. I can guess where the magic is--but I'd much ratehr see it explicitly--then I wouldn't have to guess
08:49:46 <basti_> lstna_: well then let me reformulate.
08:50:35 <basti_> do "aaabaaa" >>= \x->case x of 'a' -> "a"; 'b'->"bbb"
08:50:42 <basti_> delivers the same result
08:51:15 <basti_> (do x<-.. ; ... is just "syntactic sugar" for do ..\x->...)
08:51:30 <basti_> oops >>= between .. and \x
08:53:44 <lstna_> I understand ski's list comprehension. Is you monadic version producing a new string or modifying the original (embedded in the monad?) in-place? (Should I care?)
08:54:15 <basti_> yes you should care
08:54:30 <basti_> in this case it isn't modified in-place
08:55:06 <basti_> there is a notion of monads being the container of stuff that happens "in-place" or "muteable"
08:55:32 <ski> lstna_ : basically, the list compr. version and the do-expression version (for *list* monad) means the same thing
08:55:43 <basti_> in this example, though, it is rather a semantic convention
08:56:14 <basti_> "list monads behave like comprehensions, defaulting to a product over every list"
08:56:30 <ski> ('product' ?)
08:56:32 <basti_> okay
08:56:34 <basti_> not a product
08:56:35 <basti_> =)
08:56:47 <lstna_> Okay. >>= is breaking the string "aaabaaa" into pieces, supplying them sequentially to the local var x and the "result" of the case is either "a" or "bbb" depending upon the value of x
08:56:51 <basti_> lets say a "computation" -g-
08:57:04 <basti_> lstna_: exactly.
08:57:10 <basti_> and these are concated.
08:57:19 <lstna_> But where to these "results" get recatenated and where do the go then?
08:57:30 <ski> in list monad, a "list-monad action" is something that might just return a single value, it might return many possibly values, it might return no values
08:57:34 <basti_> they just go "out"
08:57:54 <basti_> like when you (5+3) the 8 goes "out" of the braces
08:58:18 <basti_> in the do notation the result "comes out" of the complete do expression
08:58:22 <ski> e.g.   do a <- [2,3,5]; b <- [10,20]; return (a+b)    results in   [12,22,13,23,15,25]
08:58:45 <basti_> return is another topic, its just a little confusing.
08:58:57 <basti_> it does something, but basically it does nothing.
08:59:01 <basti_> or something along that lines ;)
08:59:08 <ski> (you can think of that as in some way similar to two nested for loops, only they are not nested :)
08:59:25 <basti_> they are. by the maps.
09:00:03 <ski> they are not syntactically nested
09:00:33 <basti_> no.
09:01:23 <lstna_> Okay, but...from what I read, the result of a monad is IO something, and I cannot (without resorting to unsafe....) get that result into functional code in order to do anything with it. So, (from my interpretation) once you get something in a monad, it has to stay there, and you can forget manipulationg it with FP code, and your so your program ends up being completely imperical. Which kind of defeats the poitn?
09:01:36 <lstna_> s/poitn/point/
09:02:00 <ski> e.g. you might have something like    do a <- select 1 5; b <- select 10 11; return (a * b)    giving  [10,11,20,22,30,33,40,44,50,55]
09:02:13 <ski> well
09:02:25 <ski> you can't get out of the *IO* monad, that's true
09:02:36 <ski> but you *can* get out of some other monads
09:02:51 <basti_> it depends on the monad if this is possible and/or makes sense
09:02:58 <lstna_> So, any program that sources data externally, id totally iterative?
09:03:04 <basti_> emacs can "destruct" some of the monads
09:03:08 <basti_> no why.
09:03:09 <lstna_> s/iterative/imperical/
09:03:20 <ski> basically, IO, or any monad buildt on IO is a no-escape-one ..
09:03:44 <basti_> you can read out an array while youre inside IO, and do whatever with it (without needing IO) and then write it back via IO.
09:04:15 <ski> you can always call non IO-monad code from IO-monad code
09:05:35 <lstna_> I *think* something just clicked.
09:06:25 <ski> lstna_ : but you're right that it's (more or less) because IO-monad code actually accesses things outside of the program, that you can't get out of it  (because those things are passed in from the outside, so to speak, and cannot be defined in-language ..)
09:06:37 <basti_> your brain feels like slow jelly that made "blob"? thats normal when you're learning this stuff
09:07:17 <ski> usually, one has a quite thin IO-layer at and a little below main part of program, and that then calls the non-IO code that does the bulk of the work
09:08:47 <lstna_> (till now) I (*think*) I got the pure fp stuff and the IO stuff, but I couldn't see how to use them together. The click that just occured is that I've been wanting to 'call' the IO stuff from the fp stuff--when i should be looking to do it the other way around?
09:09:03 <basti_> lstna_: your runtime does that for you, if you need it.
09:09:33 <basti_> the IO happens exactly when an IO value is evaluated.
09:09:35 <Speck> monads really clicked for me when I was reading "all about monads" and the "way of sequencing computations" explanation was made clear
09:09:39 <Speck> I forget what section
09:10:14 <basti_> and in a program you don't want to do IO not at top level.
09:10:29 <Speck> double negative alert!
09:10:33 <basti_> okay
09:10:43 <basti_> you DO want to do your IO stuff at top level
09:10:49 <basti_> ("outside")
09:11:17 <Speck> the main function has to return the IO unit, correct?
09:11:31 <Speck> if one is compiling with ghc at least
09:11:34 <basti_> it doesnt matter if the integers you sort are coming from the outside and going back there, but if you sort something, you should be pretty sure that everything is there and doesnt depend on IO
09:11:39 <basti_> Speck: i think IO a
09:11:55 <lstna_> That's (notionally) a problem basti_...many programs are (iteratively) conversational--read something, process it a bit, output something, read something else, process it a bit more...
09:12:37 <basti_> lstna_: its not... just the outermost loop will need to mention IO.. the algorithmic stuff can be done inside the monad (but without using monadic values)
09:12:47 <lstna_> And if the list of numbers is bigger than memory?
09:13:34 <basti_> your operating system will care about that.
09:13:59 <basti_> do {(putStr "test");let x=5+5 in do (putStr "tast");return x}
09:14:18 <ski> lstna_ : laziness can take care of the "bigger than memory" argument, in many cases
09:14:51 <basti_> this outputs "testtast" and computes 10. the computation is not touched at all by the IO monad (except in the end where i had to write return to tell the compiler that i actually want this non-monad value as a result)
09:15:14 <lstna_> That's what I've been trying to get to grips with ski--but I do not see how it works.
09:15:26 <ski> do theWholeStdIn <- getContents; putStr $ unlines . map reverse . lines $ thwWholeStdin
09:15:31 * basti_ just sent a new patch for yi-emacs to dons - bottom line feedback & repeat are kinda working now
09:15:34 <Speck> do you understand the >> and >>= combinators?
09:15:59 <lstna_> Now make that some an very last list of numbers read in and output the result?
09:16:18 <lstna_> s/some/sum/
09:16:21 <ski> basti_ : better do {(putStr "test"); let x=5+5; putStr "tast"; return x}
09:16:32 <basti_> ski: i tried that but hugs had a stroke
09:16:45 <basti_> PARSE ERROR
09:17:00 <ski> hm
09:17:09 <ski> do {(putStr "test"); let {x=5+5}; putStr "tast"; return x}  ?
09:17:16 <lstna_> Hey basti_ I'm good at those too :)
09:17:25 <ski> should work if indented instead, anyway
09:17:31 <basti_> lstna_: no internal! not like "hey you put a variable there" ;)
09:18:02 <basti_> Hugs.Base> do {(putStr "test"); let x=5+5; (putStr "tast"); return x}
09:18:02 <basti_> INTERNAL ERROR: parseInput
09:18:20 <basti_> works with {} in the let though
09:19:15 <basti_> dons: ping new patch ping
09:19:45 <lstna_> Oh well. So I'm not as accomplished as you (yet) :)
09:19:55 <ski> lstna_ : do {s <- getContents; let {numbers = map read $ unlines s}; print (foldl' (+) 0 numbers)}
09:20:30 <basti_> lstna_: you always think you've seen every one, and then GHC invents a new error message, just for you
09:20:42 <ski> ('sum' would possibly work instead if "foldl' (+) 0", depends on if it is implemented stupid or not ..)
09:21:25 <ski> Speck : who are you asking ?
09:21:49 <Speck> I meant to ask lstna_
09:22:02 <Speck> I know you two understand it
09:23:09 <ski> lstna_ : anyway, we want it to keep a running sum, as it goes along the list of numbers, and not just do all the additions when the function returns i.e. when it has seen the end of the input
09:23:48 <lstna_> Speck. I think so. >> says do the left hand side and if it succeeds, do the right hand side. >>= says do the left and if it succeeds, supply it's output as input to the right hand side.
09:23:50 <ski> (which suggests foldl rather than foldr)
09:23:54 <lstna_> (roughly).
09:23:59 <ski> yes
09:24:19 <Speck> yeah, sequencing
09:24:19 <ski> that's a good approximation
09:25:10 <lstna_> (Which looks to me like ';' in most langauges I've used :) )
09:25:24 <Speck> in do notation as well
09:25:33 <ski> except that it works for any monad, not just IO or state-monads
09:26:24 <Speck> do notation + layout is nice, but I find that using the explicit monadic combinators makes it easier to understand for people who want to
09:26:41 <Speck> certainly for me
09:26:55 <lstna_> ski: getContents -- where is the source in your example? stdin? a file? a pipe?
09:26:57 <ski> in list monad :  >>= means, find all the possible values of the thing to the left, pass each single such to the right thing (potentially calling it many times), each of these calls will possibly give a list of results, so we concatenate them into a list of results for the whole expression
09:27:00 <basti_> depends on the number of combinators. comes close to perl now and then
09:27:47 <ski> lstna_ : stdin, yes.  (here you stop inputting by submitting end-of-file. you could also e.g. check for string "done" or something ..)
09:28:49 <lstna_> Okay. Also, you said "(which suggests foldl rather than foldr)", but actually used foldl' in the example?
09:28:55 <ski> yes
09:29:14 * lstna_ goes off to look up foldl'
09:29:48 <ski> because (haskell is lazy) so it might not get that it actually needs to perform the additions, so it just sets then up as thunks (eating mucha memory) instead of performing them directly
09:30:06 <ski> foldl' is a variant of foldl that explicitely forces the partial results at each step
09:30:37 <ski> lstna_ : anyway, sum might already do this efficiently, in which case it's better to use that
09:31:25 <ski> i seem to recall at least previously, in hugs, sum being defined through  sum = foldr (+) 0  (or maybe foldl), and that would eat much space
09:31:47 <ski> lstna_ : you have ghc installed ? then you can try it out ..
09:32:25 * Speck notes that the type of the testtast example is:  Num a => IO a
09:32:27 <basti_> re lstna.
09:32:37 <Speck> the result 10 is stuck in an io monad
09:32:39 <lstna> Ah! Okay, cos google ignores puctuation (mostly) and that made looking it up hard. Could you used "foldl!"
09:33:15 <lstna> or $! ?
09:33:59 <basti_> <?=<!
09:37:29 <basti_> i think I'll think up a functor that has 9 parameters, and some 100 combinators, just to annoy people.
09:38:20 <Speck> we need lambdabot back :'(
09:38:28 <basti_> yes.
09:38:49 <basti_> you could install yi while we're waiting for it, and try the new emacs mode
09:38:57 <basti_> no, just after dons put the patch up
09:39:15 <Speck> I want to play with yi, so I definitely will
09:39:30 <basti_> whats your fav editor?
09:39:40 <basti_> besides yi
09:39:41 <Speck> I have used vim for a while
09:39:53 <basti_> and now?
09:40:02 <Speck> I'm comfortable with it, I like using it (vim).
09:40:07 <basti_> ah
09:40:24 <Speck> when I'm using a mac though, I like BBEdit
09:40:29 <basti_> well yi is like vi per default
09:40:35 <basti_> bbe is nice, i've seen it
09:41:26 <Speck> I was reading the yi paper
09:41:42 <Speck> I never finished it though, as I had to do actual work
09:41:53 <basti_> i see
09:42:15 <basti_> i just gave it a try, and see where im stuck now ;)
09:42:18 <basti_> brb
09:42:19 <Speck> has anyone written a gui on top of yi?
09:43:20 <Lemmih> Good morning, SyntaxNinja.
09:48:41 <SyntaxNinja> hi Lemmih
09:49:43 <Speck> has anyone here used haskell with h/direct to interface with com objects?
09:49:58 <Speck> or with another library if someone has a recommendation (hdirect just came up from google)
09:52:50 <basti_> re
09:53:51 * SyntaxNinja taps shapr on the shoulder and hides
09:56:09 * basti_ sees shapr tip over and fall
09:56:16 * basti_ has a look
09:56:23 <basti_> it wasnt shapr.... it was a statue that was looking like him
09:56:50 <Speck> damn polymorphic statues
09:56:59 <basti_> Speck: too much nethack man
09:57:55 * Speck remembers a story one of his professors told him, about a guy who renamed nethack to troff to avoid ps-spying
09:58:12 <basti_> uhm
09:58:13 <Speck> logged a lot of troff hours, so they considered him a troff expert
09:58:19 <basti_> lol
09:58:26 <reffie> argv[0] = "troff"
09:58:36 <reffie> ;
09:58:49 <reffie> no need to rename anything!
09:58:55 <Speck> I'm sure he didn't rename it
09:59:07 <Speck> just to simplify the story
10:00:54 <Speck> is hdirect maintained? the user guide is quite old, but maybe it's just done
10:01:27 <Speck> I ask because I'd like to write some code for work in haskell, but it needs to interface with a COM component
10:01:39 * basti_ does not even dare to think about it
10:01:54 <basti_> how about FFI to some COM lib?
10:02:16 <Speck> hdirect seems to be a compiler for a FFI-based DSL
10:02:24 <basti_> oh.
10:28:23 <araujo> Hello.
10:28:45 <araujo> How good is "Haskell: The Craft of FP" ?
10:34:25 <ski> araujo : i learned from it, and found it good enough (haven't checked the other books .. hudak, etc ..)
10:36:09 <araujo> ski, ok...
10:36:33 <araujo> Well, this would be actually my 3rd haskell book :-)
10:46:30 <ski> araujo : ok :)
10:50:46 <SyntaxNinja> craft of fp is quite good
10:55:52 <Frederick> how do I access a given position on a list? in ml
10:57:07 <ski> List.nth (2,[01,2,3,4,5])  ?  (or something similar, i think)
11:01:22 <xs> or list !! n, e.g., [1,2,3] !! 0 == 1
11:01:44 <Frederick> it isnt working
11:01:48 <xs> oh
11:01:50 <xs> sorry you said ml
11:02:07 <Frederick> ml doesnt hasa f*cking manual
11:02:22 <xs> haskell does
11:03:58 <SyntaxNinja> Frederick: google for "the standard ml basis library" and look at list
11:04:16 <SyntaxNinja> and I think it's nth (list, num)
11:05:06 <genneth> i see that lambdabot is still missing in action
11:05:40 <Frederick> ?
11:07:38 <genneth> Frederick: is that '?' at me or SyntaxNinja?
11:08:08 <Frederick> you
11:08:28 <genneth> lambdabot died sometime last night
11:08:30 <genneth> it's still not back
11:08:54 <genneth> i miss it :'(
11:09:10 <genneth> it's poetic replies to @moo
11:10:49 <Frederick> if (Char.isLower(lista[0]) or Char.isUpper(lista[0])) then
11:10:49 <Frederick>        TextIO.output (TextIO.stdOut, !c)
11:10:49 <Frederick> if (Char.isLower(lista[0]) or Char.isUpper(lista[0])) then
11:10:49 <Frederick> lista[0] inst  valid =/
11:10:49 <Frederick> I need something like array[0]
11:11:25 <SyntaxNinja> nth or head
11:11:45 <Frederick> SyntaxNinja how would be its syntax?
11:13:05 <Frederick> SyntaxNinja head doesnt seems to be defined in ml
11:13:32 <monochrom> http://www.standardml.org/Basis/
11:13:34 <ski> have you opened the List structure ?
11:13:51 <SyntaxNinja> oh, it's hd
11:14:07 <SyntaxNinja> clock on "list" and read: http://www.standardml.org/Basis/manpages.html
11:14:25 <Frederick> I got it but I see no example of susage
11:14:41 <SyntaxNinja> do you see this:
11:14:42 <SyntaxNinja>  nth (l, i)   returns the i(th) element of the list l,  counting from 0. It raises Subscript  if i < 0 or i >= length l. We have nth(l,0) = hd l, ignoring exceptions.
11:15:14 <monochrom> "nth (l, i)"  that's quite enough for an example.
11:15:38 <monochrom> Moreover you can try things out at the prompt.
11:17:48 <Frederick> nth doesnt seem to work
11:18:09 <monochrom> try "open List;"?
11:18:39 <SyntaxNinja> Frederick: have you read an ML tutorial?
11:18:47 <Frederick> ive defined the list like ["red","blue","black"];
11:19:09 <Frederick> SyntaxNinja many and most of them suck, cause they talk about how ml is cool without giving me examples
11:20:22 <Frederick> mosml official docs are poor
11:20:24 <SyntaxNinja> did you actually read them, or just look through for examples of what you're trying to do right now?
11:20:34 <monochrom> I'm inclined to believe you're bluffing.  You say there is none to drive us to find one for you.  I won't fall for it.
11:21:01 <Frederick> this is a little better -> http://www.dcs.napier.ac.uk/course-notes/sml/manual.html but still has no usefull examples
11:21:07 <monochrom> I know people who use it as a psychological trick to get others to work for them.
11:21:35 <Frederick> monochrom whatever Ive google and I really couldnt find a nice tutorial
11:21:50 <monochrom> http://www.smlnj.org/doc/literature.html#tutorials ?
11:21:58 <SyntaxNinja> hi CosmicRay
11:22:07 <CosmicRay> hey syntaxninja
11:22:09 <CosmicRay> ltns
11:22:39 <xs> is there meant to be any link between show and read? e.g., read (show x) == x?
11:22:55 <monochrom> There is no end to claiming things to be "not useful [for me]" once you've made up your mind to whine.
11:24:06 <Igloo> xs: I'd say yes, but there's nothing to force you to make that be true
11:24:33 <xs> Igloo: great, i want it to be true.. so that suits me :) thanks!
11:33:05 <Speck> damn taxes
11:33:28 <Speck> took 200USD off my 700USD pay check
11:34:04 <dcoutts> juhp, ping
11:41:16 <lstna> What do I need to import to get foldl'? Or is it enabled by glasgow extensions? (And can I enable glasgow extensions by default (through environment) or in the source via pragma?)
11:42:26 <Frederick> can anyone please give me a hand here -> http://rafb.net/paste/results/E2kjUy36.html
11:42:32 <Lemmih> lstna: Data.List
11:43:03 <lstna> Thanks Lemmih
11:44:52 <Frederick> I need turn that in something like this -> http://rafb.net/paste/results/ZvkuZu50.html
11:45:35 <Frederick> I want to check the first char of the strin given by explode but isLower and is.Upper only works with chars
11:47:58 <ski> explode shoud give a list of chars, in modern SML
11:48:54 <ski> but, you could use  "String.sub (c,0)", instead of "hd lista", methinks
12:28:08 <smott_> does anyone have a bit of time to help me with a strange issue i'm having?
12:29:40 <basti_> smott_: go ahead
12:31:22 <smott_> i'm trying to move a character across the screen, and uhm
12:31:33 <basti_> ...yes? :)
12:31:49 <smott_> i best show the code
12:32:01 <basti_> lisppaste2: @url
12:32:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:32:03 <basti_> paste it there
12:32:34 <lisppaste2> smott pasted "roguelike failures" at http://paste.lisp.org/display/9560
12:32:41 <basti_> stepcut?
12:33:00 <stepcut> yes?
12:33:22 <basti_> stepcut: i made a new yi-emacs patch
12:33:26 <stepcut> ah?
12:33:30 <smott_> now, if i make it 'h' -> a { p = (x-1,y) } it works, but not the code i pasted, which i think is pretty strange
12:33:36 <basti_> smott_: hum. how long are you doing haskell now?
12:33:46 <basti_> stepcut: email ad per msg?
12:34:10 <stepcut> basti_: ??
12:34:16 <basti_> smott_: i don't see the question yet.
12:34:32 <basti_> stepcut: do you want the patch +stop+ if so, please message me your contact information +stop+
12:35:06 <smott_> basti_: what's wrong with the movePlayer function? using it makes the character jump strangely across the screen
12:35:25 <basti_> hmm
12:35:31 <basti_> i'm thinking
12:36:46 <basti_> what's "at"?
12:37:25 <smott_> it adds some escape codes to display the string at x y
12:37:42 <basti_> hmm
12:37:51 <smott_> goto x y    = '\ESC':'[':(show y ++(';':show x ++ "H"))  ----
12:37:52 <smott_> at x y s  = goto x y ++ s
12:37:58 <basti_> k thanks
12:38:21 <basti_> I'm pretty blank
12:38:54 <basti_> have you tried checking the positions?
12:39:27 <basti_> as in, that "at" gets the right numbers?
12:39:58 <smott_> it works if i replace movePlayer with a { p = (x-1,y) }
12:41:05 <basti_> hmm
12:41:42 <smott_> would show the full code help?
12:41:49 <basti_> maybe.
12:42:00 <basti_> maybe with the working version in comments
12:45:08 <lisppaste2> smott annotated #9560 with "failures (2)" at http://paste.lisp.org/display/9560#1
12:46:31 * basti_ has a look
12:46:47 <smott_> also any suggestions how to better approach the writing of a very primitive roguelike are welcome :P
12:47:18 <basti_> =)
12:47:53 * basti_ trying to get it to run
12:48:53 <smott_> you'll need the file data/maps/1 which should be just a 100x100 array of dots (and some # to see that scrolling works)
12:49:36 <basti_> running
12:50:07 <basti_> uncommented works without scrolling
12:50:42 <smott_> but if you replace the st {..} with the commented code it'll jump the @ around somehow
12:50:52 <basti_> scolling doesnt work yes
12:50:56 <basti_> now lets have a look
12:51:14 <smott_> scrolling doesn't work?
12:51:23 <basti_> no the @ just runs out of the field
12:51:32 <basti_> or does it only in one direction?
12:51:49 <smott_> oh right. you scroll with the asdw keys, it doesn't follow the @ yet
12:52:04 <smott_> it will, one day.
12:52:05 <basti_> ahh
12:52:06 <basti_> okay
12:53:40 * basti_ is dumbstruck
12:53:42 <basti_> :)
12:53:45 <basti_> but I'm still looking
12:58:54 <basti_> ha ha ha
12:59:05 <basti_> movePlayer w@(State mp (x,y) _) a b =
12:59:05 <basti_>         if walkableMap mp (x+a) (y+b)
12:59:05 <basti_>                 then w { p=(x+a,x+b) }
12:59:06 <basti_>                 else w
12:59:10 <basti_> have a close look
12:59:37 <smott_> what?
12:59:40 <basti_> closer.
12:59:42 <basti_> =)
13:00:01 <basti_>                 then w { p=(x+a,x+b) }
13:00:10 <smott_> and?
13:00:18 <basti_>                 then w { p=(x+a,x+b) }
13:00:24 <basti_> ...?
13:00:40 <smott_> "player position = current position + offset"
13:00:50 <basti_> position consists of what value?
13:00:52 <basti_> s
13:01:05 <smott_> (Int, Int)
13:01:15 <basti_> how do you call these values usually?
13:01:30 <smott_> pairs?
13:01:35 <basti_> uhm
13:01:37 <monochrom> what to call (Int,Int)?  pair
13:01:37 <basti_> x and y?
13:01:52 <monochrom> coordinates?
13:01:55 <basti_> let us repeat silently: x and y.
13:02:07 <monochrom> row, column?
13:02:09 <basti_>                 then w { p=(x+a,>>>>>x<<<<<+b) }
13:02:16 <smott_> ah
13:02:25 * basti_ rings a bell
13:02:26 * smott_ dyslexic
13:04:20 <smott_> ooh it works
13:04:24 <smott_> thanks
13:04:27 <basti_> :)
13:39:54 <smott_> basti_: btw any suggestion on how to introduce randomness into the game? should i just get like 100 random ints at the top level and then pass them to the functions that create a new state?
13:42:31 <wilx> Hmm, use Haskell's random number generators?
13:43:27 <smott_> yeah, but where and how :p
13:44:46 <wilx> Hmm.
13:44:49 <wilx> @index random
13:45:10 <wilx> Hmpf, no lambdabot?
13:45:47 <wilx> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
13:47:00 <lispy`> smott_: inside the IO monad
13:47:12 <lispy`> smott_: or else you have to use the unsafePerformIO
13:47:19 <lispy`> smott_: but inside the IO monad is easy
13:48:04 <lispy`> just write all your code the way you normally would, then when you need random numbers use the do notation, do { x <- randInt; y <- randInt; stuff x y; }
13:48:22 <lispy`> (note randInt is just an example it would have to be written by you)
14:12:15 <ski> (lispy`,smott : using unsafePerformIO wouldn't be permissible here, i think ..)
14:18:22 <TheHunter> unsafePerformIO is possible, but very tricky.
14:19:51 <basti_> smott_: random generators are IO actions...
14:22:05 <TheHunter> if you don't want to use monads, you can possibly generate a stream of random numbers, and take advantage of lazy evaluation.
14:22:33 <monochrom> yeah
14:23:34 <monochrom> I should write and share a home-made monad for tossing out random numbers.
14:24:24 <monochrom> (a usual state monad with generator as state)
14:24:44 <TheHunter> or that one. it's really simple with generalized newtype deriving.
14:27:12 <ski> basti_ : ?
14:27:54 <basti_> ski: ?
14:28:09 <ski> :)
14:28:12 <ski> <basti_> smott_: random generators are IO actions...
14:28:24 <basti_> yes?
14:29:27 <ski> from what i see in System.Random you can use next (and possibly split) to generate random numbers, without having to call io actions all the time
14:29:56 <basti_> hmm.
14:31:11 <ski> (or possibly, e.g. random instead of next)
14:31:29 <arjanoosting> hmm, lambdabot is gone?
14:31:46 <ski> yes
14:32:02 <arjanoosting> SyntaxNinja: ping
14:32:25 <monochrom> yuck, can't try the latest Random tricks and show you right here :)
14:40:34 * lstna_ tried to read the docs on System.Random and show a random number from ghci and hit all the familiar problems :(
14:41:12 <ski> like ?
14:43:07 <lstna_> LIke being to dumb to understand the docs and error messages.
14:43:28 <lstna_> Ignore me ski: I've reached my limit again.
14:44:58 <TheHunter> hmm.
14:45:40 <TheHunter> @plugs 2 + 3
14:46:14 <smott_> the global generator always generates the same sequence though ...
14:48:11 <TheHunter> you can use it like (r :: Int) <- randomIO or gen <- getStdGen
14:49:11 <smott_> 	rnd <- getStdGen
14:49:12 <smott_> 	let r = take 10 $ (randomRs (1,10) rnd) :: [Int]
14:49:32 <smott_> if i loop this it's always the same
14:50:11 <TheHunter> ah, of course. It's because you don't actually change the rng state in pure code.
14:51:22 <lispy`> what are the constraints on this game?
14:51:26 * smott_ makes randomRIOs
14:51:35 <lispy`> i'd use the rollDice example
14:52:12 <lispy`> randomRIOs = [rollDice | _ <- [1..]]
14:52:16 <lispy`> something like that?
14:53:06 <smott_> pretty much so
14:53:35 <lispy`> you probably want to run sequence on it
14:53:42 <lispy`> randomRIOs = sequence [rollDice | _ <- [1..]]
14:54:03 <lispy`> if lambdabot were here i'd know for sure if you want sequence
14:54:24 <lispy`> smott_: what type of game is this?
14:54:36 <TheHunter> no, that's too strict.
14:54:45 <TheHunter> |replicateM 10 rollDice| will work.
14:54:46 <lispy`> oh
14:54:53 <lispy`> | ?
14:55:02 <smott_> roguelike
14:55:06 <TheHunter> just quoting.
14:55:11 <lispy`> TheHunter: what is too strict?  sequence?
14:55:22 <ski> someone with ghci access, please try "getStdRandom (randomR (1,6)) >>= print" at ghci prompt  (should complain about unresolved Num and Random instance, rather than complain about no Show (IO ()) found)
14:55:25 <TheHunter> |rollDice :: IO something|, isn't it.
14:55:37 <lispy`> ski: yes
14:55:40 <lispy`> ski: i've seen that as well
14:56:06 <ski> lispy` : you also get Show (IO ()) problem ?
14:56:26 <TheHunter> ski, it gives a defaulting warning and otherwise works fine here.
14:56:27 <lispy`> ski: i don't have ghci handy, but i have had that error when trying that getStd...
14:56:44 <lispy`> ski: iirc someone told me it was an old bug
14:56:51 <TheHunter> you can get a cvs ghc, it fixes that bug.
14:57:07 <ski> TheHunter : lstna_ here says he get complaints about IO () not being in show, which i find just weird
14:57:19 <TheHunter> works here without problems (except a defaulting warning).
14:57:33 <TheHunter> ski, yeah, that's a misleading error message in ghc-6.4
14:57:40 <smott_> No instance for (Show (IO [Int])) <- ?
14:57:58 <TheHunter> it's fixed now, but iirc, it only complained about wrong code.
14:58:18 <lispy`> smott_: you have a list of ints wrapped up in a monad, the easy explanation is that it's roughly like showing a function, what should it look like?
14:58:51 <lispy`> in this case it's the IO monad so that list of ints is like a bunch of little programs or computations that are ready to happy
14:58:53 <lispy`> er happen
14:59:25 <smott_> yeah, a <- randomRIOs; (putStr . show) a works
14:59:25 <lispy`> i hope that makes some semblance of sense :)
15:00:03 <lispy`> i tihnk print = putStrLn . show, so unless you are avoiding the new line you may find print easier
15:00:19 <lispy`> or maybe print returns IO()
15:00:23 <lispy`> i never can remember
15:00:36 <lispy`> heh, or maybe both are true statements
15:00:43 <lispy`> where is lambdabot when i need it :)
15:00:47 <TheHunter> lispy`, |sequence $ repeat something| won't return anything, because it waits for all io action in an infinite list to take place before it can return the value.
15:01:23 <TheHunter> both statements are true.
15:01:41 <lispy`> TheHunter: yeah, i figured that out from your strictness comment.  But the replicateM is okay because it's finite?
15:02:07 <TheHunter> yeah, though it has subobtimal performance if n is large.
15:02:24 <lispy`> i'll keep that in mind :)
15:02:33 <lispy`> is there a way to do sequence for inifinite lists?
15:02:53 <TheHunter> if you aren't afraid of unsafeInterleaveIO, yes.
15:02:57 <lispy`> oh
15:03:19 * lispy` isn't afraid of nothing :)
15:04:16 <TheHunter> unsafeSequence :: [IO a] -> IO [a]
15:04:16 <TheHunter> unsafeSequence []     = return []
15:04:16 <TheHunter> unsafeSequence (x:xs) = liftM2 (:) x (unsafeInterleaveIO $ unsafeSequence xs)
15:04:26 <SyntaxNinja> arjanoosting: pong
15:04:52 <TheHunter> or, if you don't care that the actions take place in the right order:
15:05:05 <TheHunter> evenUnsaferSequence xs = return . map unsafePerformIO
15:05:12 <TheHunter> s/xs//
15:05:39 <lispy`> TheHunter: well, that would be fine in the case of a random number generator right?
15:07:13 <TheHunter> yeah, that'd be fine
15:08:37 <TheHunter> except you require some other portions of your code that uses random numbers in the IO monad to behave deterministically
15:09:52 <lispy`> not sure what you mean
15:09:53 <TheHunter> there's no real unsafeness in this because you could do the same thing via threads.
15:10:21 <lispy`> have a thread that is always generating random numbers and then use laziness to read from that sequence?
15:11:56 <TheHunter> what i mean is that if you have code like |x <- randomIO; y <- randomIO| that it is possible that y doesn't use the rng state that the first randomIO put in there.
15:12:43 <TheHunter> usually, that's no problem.
15:13:28 <ski> do {g <- newStdGen; return (foo (unfold (Just . ran) g)) }  -- where foo :: [T] -> U  and  ran = random  or  ran = randomR (myMinBound,myMaxBound)
15:13:35 <ski> would that work ?
15:14:32 <TheHunter> what's T and U
15:14:33 <lispy`> TheHunter: they may be using different rng state?  whoa, i never realized that
15:14:38 <ski> just some types
15:14:46 <ski> (with T being in Random class)
15:15:00 <arjanoosting> Hi SyntaxNinja: did you have time to look at the DrIFT and HaXml packages yet?
15:15:26 <TheHunter> Prelude System.Random> :t Data.List.unfoldr (Just . random)
15:15:26 <TheHunter> Data.List.unfoldr (Just . random) :: forall a b. (Random a, RandomGen b) => b -> [a]
15:15:26 <TheHunter> P
15:17:09 <ski> R> do {g <- newStdGen; print (take 10 (unfoldr (Just . random) g) :: [Int]) }
15:17:09 <ski> [341905022,-737015637,987712960,-19034826,-366349477,-1174054291,146641618,-8297
15:17:09 <ski> 12767,772744076,1025954582]
15:17:18 <ski> seems to work
15:17:24 <TheHunter> unfoldr (Just . random) === randoms, it seems.
15:17:43 * ski notices randoms
15:19:13 <ski> lispy` : so, if you need a stream of randoms, you can use randoms
15:20:25 <SyntaxNinja> arjanoosting: I have not, but I'm digging myself out from after my vacation
15:20:26 <ski> lispy` : no need to have any threads or even unsafeInterleaveIO
15:21:12 <SyntaxNinja> next priority is fixing the cabal package, then your stuff, then making a cabal release, then a hackage release, and then I will officially be caught up, and Im' sure nothing new will come up by then.
15:21:41 <arjanoosting> SyntaxNinja: had a nice vacation?
15:21:47 <SyntaxNinja> arjanoosting: yeah, pretty good :)
15:21:52 <TheHunter> ski, there still is a problem
15:22:43 <lispy`> doesn't randoms need a generator still?  i had some reason to not use it...can't remember now
15:22:43 <ski> of getting the initial RandomGen ?
15:23:27 <ski> you can make a fresh StdGen by calling newStdGen
15:23:35 <TheHunter> Prelude System.Random> print =<< ((take 5 . randoms) `fmap` getStdGen :: IO [Int])
15:23:36 <TheHunter> [1228559459,-188495971,-1276661422,-1121726142,-120299641]
15:23:36 <TheHunter> Prelude System.Random> print =<< (randomIO :: IO Int)
15:23:36 <TheHunter> 1228559459
15:23:36 <TheHunter> Prelude System.Random> print =<< ((take 5 . randoms) `fmap` getStdGen :: IO [Int])                                                                              [-188495971,-1276661422,-1121726142,-120299641,1705978800]
15:23:37 <TheHunter> Prelude System.Random>
15:23:40 <arjanoosting> that's nice, what did you do?
15:24:38 <ski> TheHunter : you mean the first example starts with same number as the second example ?
15:24:39 <lispy`> TheHunter: the fmap is probably what i missed when i thought of using randms
15:24:48 <SyntaxNinja> arjanoosting: I drove across the country with my lady friend. I have a new interest in sherlock holmes stories and a new aversion to corn ;)
15:25:02 <TheHunter> ski, the problem is that both lists look awfully similar.
15:25:14 <SyntaxNinja> joking about the corn, I'm from Ohio and was already used to it.  driving through oregon along the columbia river gorge is incredible
15:25:21 <arjanoosting> an aversion to corn.. sound nice
15:25:25 <lispy`> TheHunter: heh, yeah i see that now
15:25:26 <ski> lispy` : you can just call getStdGen or newStdGen, directly, as i showed, too
15:25:42 <ski> TheHunter : try using newStdGen instead of getStdGen :)
15:25:51 <arjanoosting> :)
15:26:26 <lispy`> so does getStdGen create the same sequence per invocation?
15:26:31 <SyntaxNinja> arjanoosting: how have you been?
15:26:38 <lispy`> and newStdGen grabs a new seed whenever it's called?
15:26:53 <TheHunter> ok, newStdGen seems to split the rng state the other way.
15:26:57 <SyntaxNinja> I have been doing too much writing lately. hopefully that'l lbe done for a while and I'll do too much hacking.
15:27:03 <TheHunter> so that's fine.
15:27:06 <ski> yes
15:27:26 <lispy`> random numbers are deceptively difficult in haskell
15:27:30 <lispy`> that's my conclusion of this
15:28:26 <ski> what would be the difficulty ?
15:28:53 <lispy`> you can get the same sequence without meaning to
15:29:27 <lispy`> can you tell randoms to restrict to a range?
15:29:33 <lispy`> i bet that's the reason i used something else
15:29:35 <ski> you can with in an imperative lang, too, if you muck around with reading out, and later restoring rng state
15:29:38 <lispy`> i always need ranges
15:30:04 <ski> or, if it's the type of rng that requires you to pass the state explicitely, you have even more similarity
15:30:12 <lispy`> ski: that's a useful thing to be able to do, but not something that is usually what you want
15:30:21 <shrimpx_> is ghc's stritness analyzer documented somewhere?
15:30:33 <shrimpx_> er strictness
15:30:46 <ski> lispy` : randomRs :: (Random a,RandomGen g) => (a, a) -> g -> [a]
15:31:20 <ski> 'R' for Range, methinks
15:31:50 <lispy`> it tis
15:32:14 <lispy`> @type randomsRs (1,100) getStdGen
15:32:14 <ski> lispy` : right, so just use newStdGen instead of getStdGen and setStdGen
15:32:20 <ski> no lambdabot
15:32:24 <lispy`> oh right
15:32:27 <lispy`> i knew that
15:32:41 <lispy`> but that's the basic idea right?
15:32:52 <lispy`> that should give an infinite list in that range?
15:33:02 <lispy`> then you just dole out the numbers as need be?
15:33:26 <ski> do {g <- getStdGen; return (randomsRs (1,100) g)} :: (Random a,Num a) => IO [a]  -- iiic
15:33:42 <ski> yes
15:33:45 <lispy`> ah
15:33:51 <lispy`> that makes sense
15:34:31 <ski> (return . randomsRs (1,100)) `fmap` getStdGen   would be the same, i think
15:34:38 <lispy`> should i hack on darcs this weekend or an elisp interpreter?
15:34:57 <shrimpx_> depends on what the elisp interpreter is written in
15:35:03 <lispy`> shrimpx_: haskell
15:35:18 <TheHunter> randomRs (1,100) `fmap` getStdGen
15:35:24 <arjanoosting> well quite nice. Had some nice barbecues, went to a rock festival and next week a have another big barbecue (around 70 people)
15:35:24 <lispy`> for use with Yi until 'essential' emacs functionality is added :)
15:35:26 <shrimpx> darcs then
15:35:29 <shrimpx> =)
15:35:47 <ski> TheHunter : ah, right
15:36:02 <lispy`> shrimpx: just curious, what would have been an answer that made you say 'elisp interpreter' instead of 'darcs'?
15:36:05 <arjanoosting> should have studied more though :) And I have to start searching for a job...
15:36:54 <lispy`> that is a big bbq
15:37:50 <SyntaxNinja> heh barbecues are nice
15:38:34 <lispy`> shrimpx: iirc there is an elisp interpreter in CL
15:38:59 <lispy`> i bet they snarf'd a lot of CL functionality
15:39:28 <shrimpx> heh
15:39:59 <arjanoosting> yeah they are nice especially with the nice wheather we had in the Netherland
15:40:55 <lstna> ski: I had a sucess! this "main = ((getStdRandom (randomR (1,6)) ):: IO Int) >>= print" worked! Wonders will never cease.
15:42:45 <ski> lstna : nice ! :)
15:44:02 <SyntaxNinja> ahh, summer
15:44:17 <lstna> Not really. The syntax is horrible (but can probably be simplified), but the fact that the otion to try it popped into my head is the good bit. It means something is penetrating my thick skull.
15:44:34 <lstna> s/otion/notion/
15:45:04 <lispy`> it's weird that otion sounds like ocean
15:45:11 <lispy`> thanks english!
15:46:06 <ski> lstna : you canuse do-syntax instead of >>=, as i said before, though
15:46:16 <ski> main = do
15:46:28 <ski>   n <- getStdRandom (randomR (1,6))
15:46:33 <ski>   print (n :: Int)
15:47:04 <ski> lstna : and you can add { ; } if you feel better with them
15:48:44 <lstna> I dislike the need for the extra variable (?) in the do syntax. I like the >>= operator (i think)...I just using it that is the roblem
15:48:47 <lstna> problem
15:49:25 <lispy`> smott_: so how far have you made it with your rogue like game?
15:52:42 <lispy`> will it be multiplayer? :)
15:52:53 <lispy`> they tried that with angband, but it never went very far
15:53:24 <lispy`> it's suprisingly difficult to make a turn based game play the same way as a realtime game
15:54:03 <lispy`> i used to run a mangband server, but at some point i stopped
15:59:12 <lispy`> heh
17:16:29 <MachinShin> hey all
18:24:07 <cm> hej
18:32:23 * cm unsafePerformIOs shapr
18:52:17 <dons> was lambdabot really down for 18 hours?
18:53:13 <dons> looks like :/
18:53:44 <dons> problem was that he didn't quit. he just wan't joined either.
18:53:48 <metaperl> it's impossible to study Haskell seriously on a Friday... I think I'll go read Wadler's EoFP
18:54:01 <hyraxforytwo> wofp?
18:54:17 <wagle> @seen lambdabot
18:54:17 <lambdabot> Yes, I'm here.
18:54:24 <metaperl> EoFP - essence of functional programming
18:54:30 <hyrax42> 'tis a book?
18:54:38 <metaperl> article
18:54:47 <hyrax42> ah
18:57:29 <dons> @seen TheHunter
18:57:29 <lambdabot> I saw TheHunter leaving #haskell 1 day, 1 hour, 50 minutes and 31
18:57:29 <lambdabot> seconds ago, and I have missed 14 seconds since then.
18:57:41 <dons> only 14 seconds, eh?
18:58:05 <hyrax42> lol
18:58:46 <metaperl> hyrax42: http://www.hcoop.net/~terry/haskell/eofp/wadler92essence.pdf
18:59:06 <hyrax42> oh, thanks very muchly
18:59:31 <hyrax42> oooh.... time to put my newly recommssioned laser printer to work
19:36:54 * tessier is reading YAHT
19:37:21 <tessier> It is interesting that haskell has lisp-like cons (:) car (head) and cdr (tail)
19:38:41 <dons> haskell is strongly influenced by lisp
19:39:00 <dons> @where haskell98
19:39:01 <lambdabot> http://haskell.org/onlinereport/
19:39:31 <dons> "the
19:39:32 <dons> following languages were particularly influential: Lisp"
19:44:59 <wagle> YAHT?
19:45:35 <dons> wagle?
19:45:45 <wagle> 19:37  * tessier is reading YAHT
19:45:55 <dons> YetAnotherHaskellTutorial
19:46:10 <dons> how's code wagle?
19:47:06 <wagle> code?
19:47:18 <dons> as shapr would say :)
19:47:33 <wagle> never saw him say that
19:48:02 <dons> oh, it's one of his favourite conversation openers
19:48:49 <wagle> pondering minesweeper
19:49:09 <wagle> apparently its NP-complete
19:49:34 <dons> I think i might have read that somewhere
19:50:29 <wagle> http://www.claymath.org/Popular_Lectures/Minesweeper/
19:55:36 <cm-> wagle: that's cool :p
19:56:00 * wagle gets kicked out of coffee shop because the employees want to go home now..  8)
19:56:09 <wagle> gnite
19:56:13 <cm-> order a cappuccino!
19:56:14 <cm-> nn
19:58:36 <dons> @code
19:58:36 <lambdabot> Strict.hs: -----------------------------------------------------------------------------
19:58:40 <dons> @code
19:58:41 <lambdabot> Monad.hs: when p s          =  if p then s else return ()
19:58:45 <dons> better.
20:01:17 <cm-> what does it do? output some random code? ;)
20:01:19 <cm-> @code
20:01:20 <lambdabot> Strict.hs: -----------------------------------------------------------------------------
20:01:24 <cm-> ;\
20:01:29 <dons> @code
20:01:30 <lambdabot> Num.lhs: (S# i)     /=  (J# s d)   = cmpIntegerInt# s d i /=# 0#
20:01:36 <cm-> @code
20:01:37 <lambdabot> Chan.hs: modifyMVar_ read $ \read_end -> do
20:01:46 <dons> I just patched lambdabot
20:01:52 <dons> hopefully no more lines with -- in them
20:01:59 <cm-> :-)
20:02:02 <dons> @version
20:02:03 <lambdabot> lambdabot 3p40, GHC 6.4 (OpenBSD i386)
20:02:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:02:18 <dons> @version
20:02:19 <lambdabot> lambdabot 3p42, GHC 6.4 (OpenBSD i386)
20:02:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:02:56 <dons> cm-, any lambdabot plugins you'd like to see?
20:04:13 <cm-> don't know really, i'm not too often in here these days..
20:04:36 <cm-> vixen seems sick :)
20:04:50 <dons> well, I think that's true.
20:04:55 <dons> @vixen how sick are you?
20:04:56 <lambdabot> i dunno how so, it's just so
20:05:34 <cm-> @vixen tell me about shapr
20:05:35 <lambdabot> i dunno, what about?
20:05:39 <cm-> :/
20:06:00 <cm-> @todo
20:06:01 <dons> she's just a set of regexes. what else do you expect?
20:06:01 <lambdabot> 0. dons: Release lambdabot 3.0
20:06:01 <lambdabot> 1. SamB: A way to get multiple results from a google search
20:06:01 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
20:06:01 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
20:06:01 <lambdabot> the command was given on
20:06:02 <lambdabot> 4. SamB: stop mangling long urls
20:06:04 <lambdabot> 5. dons: improve formatting of @dict
20:06:52 <cm-> i'm not sure, i didn't find the phrase book
20:07:01 <cm-> but the name sounds nasty :)
20:07:36 <cm-> @state
20:07:37 <lambdabot> world
20:13:29 <monochrom> haha #get-shapr
20:17:42 <dons> oh, it's summer  in the .eu right?
20:17:47 <dons> is that why it's so quiet?
20:22:01 <monochrom> weekend is the more important factor
20:23:09 <lstna> Is there a web interface to the haskell libraries source code anywhere?
20:24:06 <dons> @where hier
20:24:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:24:17 <dons> sorry, that's not the src code.
20:24:20 <dons> gimme a sec...
20:25:02 <dons> @where hiersrc
20:25:02 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/
20:25:24 <dons> there, lstna
20:25:44 <monochrom> yeah, the web interface to the cvs repo
20:26:51 <dons> another option would be the libraries darcs repo, if it existed..
20:29:40 <lstna> Thanks dons.
20:30:17 <lstna> No. That's shows exactly what I was looking for--not that I understand it, but...given time.
20:31:00 <dons> I find it useful to have a copy of the libraries src on my hd at all times
20:31:40 <dons> then you can grep and use your editor, more than you can with the web interface
20:31:48 <dons> also, @code uses the libraries src
20:31:49 <dons> @code
20:31:50 <lambdabot> Ptr.hs: showsPrec p (Ptr a) rs = pad_out (showHex (word2Integer(int2Word#(addr2Int# a))) "") rs
20:31:54 <dons> for example.
20:32:02 <dons> though @code could admittedly do with some work
20:32:56 <lstna> If i get into this stuff, I'll probably do that. For now, I'm just trying to get to grips with the language and I sometimes think that seeing how things work under the covers is easier than teh abstractions.
20:33:33 <lstna> That's just a random line from the sources?
20:33:38 <dons> yep,
20:34:00 <dons> but getting a useful random line is proving tedious with regexes
20:34:32 <dons> I should probably parse the top-level defns and dump them in an assoc list
20:34:36 <lstna> Avoiding blanks and comments and such?
20:34:41 <dons> yep
20:35:19 <lstna> Right. I was thinking that an ofline process that indexed the useful lines might work
20:36:04 <lstna> Or even, have @code take an argument and pull up the source for the argument if found.
20:36:57 <lstna> What does the construct (# a, b #) signify?
20:37:28 <cm-> a strict tuple? :o
20:37:55 <dons> unboxed tuple.
20:37:59 <dons> passed on the stack
20:38:50 <lstna> And # after a name means unboxed also?
20:39:08 <dons> no, its a convention though
20:39:22 <dons> sometimes # also means 'primtive'
20:39:27 <lstna> Ah. Good enough.
20:39:28 <dons> like unsafeCoerce#
20:39:43 <dons> also, ## is used for double-sized unboxed types
20:39:49 <dons> another naming convention
20:41:20 <dons> probably most useful to read GHC.Base, then GHC.List perhaps
20:41:28 <dons> then maybe Data.List Data.Char
20:41:35 <lstna> OKay. I don't think I encountered one of those yet.
20:42:29 <lstna> I'm in GHC.IOBase at the moment. I wanted to know how getContents was lazy
20:42:52 <lstna> which has led me to unsafeInterleaveIO :: IO a -> IO a
20:43:13 <lstna> It's a little disappointing--there is so little of it!
20:43:18 <lstna> :)
20:44:33 <dons> getContents just keeps filling an internal buffer
20:44:57 <dons> though the details of this can get a bit tricky, unsafeInterleaveIO is the essence of it
20:45:24 <dons> the crucial thing is to use 'let' -- i.e. suspend the IO computation till it is demanded
20:45:30 <dons> rather than a 'case'
20:45:59 <lstna> I googled for unsafeInterleaveIO and found several references to an IO thread--but I see no eveidence of that in the code?
20:46:25 <lstna> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
20:46:43 <dons> no (separate) IO thread.
20:48:33 <lstna> Google turned up this http://www.haskell.org/pipermail/cvs-hugs/2003-August/002056.html and the associated thread
20:50:49 <dons> this appears to be unrelated to the general implementation of lazy IO in ghc
20:53:05 <lstna> Probably. It was just what turned up.
20:54:06 <lstna> I'll admit that my foray into the source ahs done little to enlighten me how it is done.
20:55:07 <lstna> Now I'm gonna puzzle over this "the crucial thing is to use 'let' -- i.e. suspend the IO computation till it is demanded" :)
20:55:27 <dons> perhaps read the 'Spineless Tagless G-machine paper'
20:56:12 <lstna> I have that on my HD somewhre...
20:57:35 * lstna wishes I was more disciplined in where I put stuff.
21:03:55 <lstna> or maybe not.
21:04:21 <dons> @google spineless tagless g-machine
21:04:22 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
21:05:44 <lstna> You need membership to get from there or ACM.
21:07:05 <lstna> The one I've seen before is here http://ewic.bcs.org/conferences/1995/functional/papers/paper3.htm -- but I'm not sure it's the same one. "Integrating Multithreading into the Spineless Tagless G-machine"
21:07:08 <dons> it's on Simon's home page.
21:07:25 <dons> you can get it from:
21:07:29 <dons> @where ghc
21:07:30 <lambdabot> http://haskell.org/ghc
21:07:37 <dons> go to documentation and see the related papers
21:07:45 <lstna> Thanks.
21:12:00 <lstna> Grrr. You have to enabled javascript so that they can popup a window telling you that if you have a popup blocker you must disable it -- but that popup is the only popup that pops up!
21:12:13 <lstna> Cool ;)
21:17:56 <lstna> dons; Thanks, I got it. One last question. Is Haskell implemented in the STG languge (at some level)?
21:20:50 <dons> yep.
21:21:04 <dons> Haskell -> Core -> Stg -> Cmm -> {C,Asm}
21:21:52 <lstna> @google Cmm
21:21:54 <lambdabot> http://www.sei.cmu.edu/cmm/
21:22:05 <dons> c minus minus
21:22:58 <lstna> Ah. Not the Capabilities Maturity Model then :)
21:23:45 <lstna> Thanks again.
21:58:14 <lispy> what's happening party people?
22:00:02 <MachinShin> night all
