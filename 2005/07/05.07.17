00:01:20 <Gahhh> the full array should be allocated regardless of usage imho
00:02:23 <dons> yeah, it is. I'd forgotten that FFI-allocated values don't appear in profiling values
00:02:37 <dons> hence the memory usage of a constnt '7k'
00:02:41 <dons> for the FFI version
00:02:51 <Gahhh> ah
00:02:54 <dons> (even though 4M is allocated on the C side)
00:03:37 <dons> then i tweaked the loop a bit, and suddenly got 32M allocated on the Haskell side, purely from a lazy ptr addition in the inner loop
00:04:11 <dons> SimonM always says "optimise inner loops"
00:04:17 <Gahhh> if there's a space leak, I don't think it can reach those figures. isn't the leak proportional to call depth ?
00:04:43 <dons> in my case, it was proportional to depth, yes.
00:04:52 <Gahhh> I mean, to number of updates
00:04:54 <dons> 32M for 1M depth, and proportionally less back to n=1
00:05:14 <dons> *unlike* the constant 32M we were getting with IOUArray
00:05:17 <Gahhh> ah
00:06:07 <dons> so, in summary, normal arrays giive us 4M usage, FFI arrays give us 4M usage, but IOUArrays give us 8*4M usage.
00:06:19 <dons> is that right?
00:06:47 <Gahhh> yes
00:07:05 <Gahhh> and boxed arrays with unboxed ints also add no leak.
00:07:41 <dons> maybe get together the 3-4 versions, and the offending code, and post to glasgow-haskell-users@
00:07:52 <dons> my 2 versions are on the wiki
00:09:48 <Gahhh> yeah
00:11:58 <Gahhh> hmm I seem to have gone overboard
00:12:35 <dons> yeah?
00:12:49 <Gahhh> I replaced the update with reversing the array
00:12:57 <dons> hehe
00:12:59 <Gahhh> memory usage jumped (boxed arrays, unboxed ints)
00:13:42 <dons> lots of intermediate values being allocated though, right?
00:15:21 <Gahhh> hmm
00:15:48 <Gahhh> the update function is not unboxed
00:15:55 <Gahhh> there are so many permutations lol
00:27:20 <Gahhh> bah
00:29:14 <Gahhh> it doesnt matter if I unbox the ints in the reverseArray function.
00:31:50 <Mou> is there a ST monad hashtable somewhere, or would i have to write one?
00:54:32 <dons> there's an IO monad hash table
00:54:39 <dons> but everyone uses Data.Map :)
00:55:30 <dons> @type Data.HashTable.new
00:55:31 <lambdabot> forall val key.
00:55:31 <lambdabot>         (key -> key -> Bool)
00:55:31 <lambdabot>         -> (key -> GHC.Int.Int32)
00:55:33 <lambdabot>         -> IO (Data.HashTable.HashTable key val)
01:42:21 <pejo> Boggle. What is stg_ap_p_info used for?
01:48:41 <basti_> hi
02:13:29 <xerox> 'morning :)
04:00:45 <ski> @arr
04:00:46 <lambdabot> Aye Aye Cap'n
04:53:38 <SuperNewb> I've been learning Haskell for two days and I'm alreding using unsafePerformIO
04:54:08 <ski> that's prolly not very good, then ..
04:54:23 <ski> for what do you use unsafePerformIO ?
04:54:36 <SuperNewb> I'm doing a test exercise, and
04:54:46 <SuperNewb> it's about comparing the contents of two folders
04:54:57 <SuperNewb> So I build two trees of FileNames
04:55:09 <SuperNewb> but as I want to compare using the Eq class
04:55:25 <SuperNewb> I create a newType File out of Filename, and make this type an instance of Eq
04:55:43 <SuperNewb> so what does it mean for two files to be (==) ? If their contents are the same
04:55:51 <ski> how does is this tree type defined ?
04:56:09 <SuperNewb> The Tree is to be built using getDirectoryContents
04:56:18 <SuperNewb> it's the contents of the folder plus all the subfolders
04:56:19 <ski> by File, do you mean 'Handle' ?
04:56:28 <SuperNewb> newtype File = MakeFile FilePath
04:56:32 <ski> aha
04:56:40 <dons> hehe
04:56:55 <SuperNewb> and then
04:56:56 <SuperNewb> instance Eq File where....
04:57:15 <SuperNewb> is this all wrong in a pure functional style ?
04:57:19 <ski> yes !
04:57:21 <ski> indeed
04:57:39 <SuperNewb> suggestions? I want to learn to 'think' in the right way
04:57:53 <ski> the compiler is allowed to optimise your code so it returns unpredictable results
04:57:58 <ski> well
04:58:13 <dons> don't use anything with unsafe* on it, for one.
04:58:29 <ndm> SuperNewb: the best way to start with Haskell is to not do any IO - such as file tree comparison
04:58:39 <ndm> until you're more used to Haskell in general
04:58:41 <ski> to e.g. compare two types, you could take the FilePaths's, open the files (in the IO monad), getting two strings, which you can then compare
04:58:58 <ski> this might be useful to read http://www.haskell.org/hawiki/ThatAnnoyingIoType
04:59:06 <SuperNewb> ndm yay, but I had this practical need, and I thought it'd be cool to do it in Haskell instead of Java, for one
04:59:26 <SuperNewb> ski but then I get an IO bool
04:59:32 <ski> yes
04:59:32 <ndm> SuperNewb: its just Haskell IO still confuses me and I've been doing it for 3 years now!
04:59:39 <SuperNewb> ski and the Eq instance method (==) needs a Bool
04:59:45 <SuperNewb> ndm it's damn confusing, yes
04:59:46 <ski> SuperNewb : getting an IO Bool is not a problem
05:00:09 <dons> don't we have some tutorials out there?
05:00:13 <SuperNewb> ski still I don't see it, I need a Bool for Eq (==)
05:00:19 <ski> SuperNewb : you can't make a sane instance for Eq of FilePath (or your newtype of that)
05:00:31 <SuperNewb> aha
05:00:44 <SuperNewb> yeah because the program was looking so elegant
05:00:48 <ski> you just code in a different way
05:00:57 <ski> to solve to problem
05:00:59 <SuperNewb> I just had to build the two trees of FileNames and then say t1==t2
05:01:06 <dons> a FilePath is just the name of the file...
05:01:13 <SuperNewb> provided that the Tree type is an instance of Eq
05:01:18 <SuperNewb> dons right, I mean FileName
05:01:23 <SuperNewb> dons right, I mean FilePath
05:01:25 <SuperNewb> *
05:01:39 <dons> not anything to do with its contents
05:02:00 <SuperNewb> dons that's right
05:02:10 <ski> you can compare a FilePath with an index, which might refer to some element, given an array
05:02:30 <dons> @eval "a" == ("b" :: FilePath)
05:02:32 <lambdabot> False
05:02:48 <ski> you can of course compare FilePath's, to see if it's the same FilePath (just as for array indices)
05:03:01 <ski> but comparing file contents is another thing
05:03:13 <SuperNewb> that's why I have the newtype File
05:03:24 <SuperNewb> to take care of the semantic details
05:03:25 <ski> doesn't matter
05:03:42 <ski> to actually (safely) get the contents of a file, you have to use the IO monad
05:04:53 <dons> i.e. you need to open two files, read them, and then use String == on the result
05:05:14 <smott> how do you build a tree with getDirectoryContents anyway?
05:06:06 <ski> @type System.Directory.getDirectoryContents
05:06:08 <lambdabot> FilePath -> IO [FilePath]
05:06:20 <ski> a tree of what ?
05:06:25 <SuperNewb> smott I've not done that, yet
05:07:14 <SuperNewb> basically, with a something like foldTree that checks which FilePaths are folders and expands them to their contents I guess
05:08:27 <SuperNewb> but that seems like the easy part
05:09:13 <ski> what part do you have trouble with ?
05:09:47 <SuperNewb> since the result of comparing the contents will be an IO bool, and the Eq class operation (==) requires a simple bool
05:10:05 <SuperNewb> I can't make my type File an instance of Eq without using unsafe to unwrap the bool...
05:10:09 <dons> don't define == tha tway
05:10:42 <dons> just use the already defined == on the contents of files, when needed
05:10:43 <ski> why do you want to compare the files ? i.e. what do you want to do with the result Bool ?
05:11:23 <SuperNewb> ski I want to use it to implement (==), I'm sorry if I'm not clear
05:11:28 <dons> the approach is wrong. you want to have an unsafe Eq that maps filenames to a function that reads their contents. that's side effecting
05:11:55 <dons> instead, perhaps, change the type to:
05:12:04 <dons> data File = File FilePath Contents
05:12:11 <dons> type Contents = String
05:12:25 <dons> getFile :: FilePath -> IO File
05:13:05 <dons> getFile f  = do h <- openFile f ; s <- hGetContents h; return (File f s)
05:13:47 <SuperNewb> that's cool, I think I get it
05:14:12 <SuperNewb> and then this type can indeed be be given Eq semantics without using unsafe
05:14:16 <SuperNewb> right ?
05:14:29 <SuperNewb> thanks a lot
05:14:43 <dons> yeah. the File type has a nice pure derivable Eq instance
05:15:11 <SuperNewb> omg it is derivable right, I don't even have to code it :)
05:15:23 <SuperNewb> cool :)
05:16:04 <dons> you should probably close the handle in getFile.
05:16:37 <dons> also, this is kind of weird un-haskell. we just don't define new types for File, as we already have Handles when we need to talk to files :}
05:17:00 <SuperNewb> is Handle member of Eq ?
05:17:09 <SuperNewb> even if it is, it won't have the semantics I want
05:17:24 <dons> there's no magic == that compares file contents. but i'm saying that's ok
05:17:27 <ski> SuperNewb : consider this : let's say you have  'f0 = MakeFile "foo.txt"'   and 'f1 = MakeFile "bar.txt"', (and assume file 'foo.txt' is a copy of 'bar.txt') then say you call your (==) as 'f0 == f1' and you get a 'True' back, then you update (in the IO monad) the file 'bar.txt', then you call 'f0 == f1' again, and now you can get result 'False' (because the files are not the same any longer). this behaviour is against referential transparency :
05:17:27 <ski> a function (here '(==)') applied to the same arguments ('f0' and 'f1' which are 'MakeFile "foo.txt"' and 'MakeFile "bar.txt"'), should *always* give back the same answer
05:18:19 <dons> this is exactly the problem, and why there's no magic == that goes from FilePath to contents
05:19:14 <dons> so, the above File is ok for this, but you live with the fact that you read the file only once on introduction of the File type
05:19:26 <dons> you no longer refer to the actual file on disk after that
05:20:00 <SuperNewb> dons that is, in this case, what I need. But I understand the reasons for which this == doesn't really make sense in pure functional
05:20:07 <ski> every time you want to meddle in the outside world, you have to do some action in the IO monad
05:20:40 <dons> SuperNewb, ok :) otherwise you'd need to implement some sort of: cmp :: FilePath -> FilePath -> IO Bool
05:20:54 <ski> but, once you gotten some data out from such an action, you can pass it to non-IO-monad parts of your program, and it is just like an ordinary value (because it is one)
05:21:28 <SuperNewb> dons that's the other approach I considered. But I wanted to use the Eq class so that I could just use (==) on the list of Files
05:21:53 <SuperNewb> ski but you have to stay inside the IO monad, don't you
05:22:06 <ski> depends one what you mean by that
05:22:20 <ski> the top level(s) of your program is in IO-monad, yes
05:22:32 <SuperNewb> ski like before when I had this IO bool and I couldn't get a bool
05:22:39 <ski> but that can call underlying levels, which functions is non-IO ones
05:22:46 <SuperNewb> sry, I think I need to keep reading a bit, I'm getting lost
05:23:22 <ski> it's true you can't make a function that does some IO and not have it return 'IO Sometype'
05:23:27 <SuperNewb> but the help has been very appreciated, I'm not stuck anymore
05:23:33 <SuperNewb> thanks guys
05:23:36 <ski> but, you can still call non-IO functions
05:23:50 <ski> see http://www.haskell.org/hawiki/ThatAnnoyingIoType for an example of this
05:23:58 <astrolabe> Oh what a tangled web we weave, when first we practise not to proceed
05:24:27 <dons> SuperNewb, just play around in ghci. look at  the System.IO stuff, and remember that doing things  to the outside world forces you into a monad, which should be respected.
05:24:43 <dons> haskell is actually pretty good at systems programming. much better  than Java.
05:24:58 <dons> #!/usr/bin/runhaskell is my new favourite way to write scripts :)
05:25:14 <SuperNewb> dons I'm loving Haskell, it's just that Java doesn't force you to learn complicated math concepts to do IO
05:25:35 <SuperNewb> but, I repeat, I'm enjoying this
05:25:40 <dons> all you need to understand is side effects
05:25:48 <ski> you don't have to understand monads on a math-level, to understand how to use them for programming
05:25:52 <ski> yes
05:25:56 <dons> and why we want to control them.
05:26:02 <SuperNewb> ski yes, but who said that all abstractions leak ?
05:26:15 <dons> the results will be less sloppy code, and things that *just work*
05:26:28 <ski> SuperNewb : i don't know who said that
05:26:56 <dons> most haskell programs have a thin layer of IO right at the start, and then we drop into pure code as much as possible.
05:27:03 <SuperNewb> I mean, someone said that and it's right. You can't ignore the underlying math concept so easily
05:27:31 <ndm> SuperNewb: but you can avoid IO as much as possible - using IO isn't using Haskell for its strengths
05:28:04 <dons> ndm is right. learning haskell by doing IO is a perverse way to start
05:28:08 <ski> SuperNewb : in some sense, possibly. but i don't think you need to understand how a monad is a composition of adjoint functors, just to be able to program with them ;)
05:28:20 <dons> it's easily done, but not as much fun by far as playing with the pure world
05:28:33 <ski> SuperNewb : you could maybe say that monads are a design pattern (if that means anything, to you)
05:28:33 <dons> (with just a 'print' at the outer level)
05:29:00 <SuperNewb> really, I've been playing with Haskell a lot these two days withouth touching I/O and it was fine
05:29:17 <dons> ski, karma- for mentioning the evil words `design pattern'
05:29:17 <SuperNewb> well I come from Java, I know quite a few things about Patterns
05:29:18 <ski> well, i don't think there's necessarily bad to use IO early when learning haskell
05:29:38 <SuperNewb> in Java you just can't live without them, be that good or evil
05:29:42 <ski> just that for most of the programming, IO isn't so important
05:30:12 <dons> yeah, I'm a bit reticent. people teach Java without teaching System.blah.blah.prinln buffered IO blah blah for several weeks ;)
05:30:29 <ski> it's more important to get a good grip on variables, functions, types, patterns, recursion first, i think
05:30:47 <dons> so IO is good to know to get anything done, but it's also kind of boring and ugly
05:31:12 <dons> and there's so many more new interesting things other than IO to learn about.
05:31:12 <ski> of course you also need to understand how to work with (at minimum) the IO monad
05:35:47 <ndm> ski: i did a 10 week introductory programming course in Haskell, and IO and Monads were never even mentioned, not even in passing
05:36:44 <pejo> ndm, heh. Thats why people think it's impossible to do anything real in Haskell, like Philippa pointed out the other day.
05:37:04 <SuperNewb> pejo indeed. I've been reading tutorials, books, and doing course exercises. But it has been my local need to compare two folders what has put me in trouble with Haskell
05:37:23 <ndm> pejo, on the contrary. we did lots of intresting stuff, its just you can learn a lot without ever touching IO
05:37:35 <ndm> after you have understood all the basics, then is the right time to think about IO
05:39:02 <astrolabe> I'm struggling with starting to use IO myself at the moment.  I'm hoping it is a 'knack' that you pick up with practice, because it seems very difficult at the moment.
05:39:47 <SuperNewb> astrolabe where are you leaerning from?
05:41:00 <astrolabe> I read some web tutorials, but the best thing is I read "The haskell school of expression" by Paul Hudak:  A fun book.
05:41:32 <SuperNewb> cool, I should get myself a copy of that one
05:41:52 <SuperNewb> because I've been using Hudak tutorial
05:42:05 <SuperNewb> until it got too complicated at the end
05:42:29 <astrolabe> I think some of these things require you to bash your head against them multiple times
05:42:43 <SuperNewb> the chapter on Monads definitely does
05:43:06 <SuperNewb> and the chapter on Read and Show, two seemingly simple classes, does too..
05:44:12 <astrolabe> I've been trying to come up with a dictionary of Haskell concepts against C++ concepts, without a huge amount of progress.
05:45:04 <pejo> ndm, happen to have a link to a course homepage for that class or similar?
05:45:35 <astrolabe> I think a haskell type-class is a bit a C++ class with no data members and only public virtual functions
05:45:40 <ndm> pejo: http://www-course.cs.york.ac.uk/fun/
05:45:55 <ndm> I'm not sure its accessible from outside the uni, but have a go
05:45:59 <pejo> ndm, can't view that page without authorization.
05:46:10 <pejo> ndm, err, authentication.
05:46:13 <ndm> yeah, i thought that might be the case
05:46:17 <SuperNewb> astrolabe: there is some stuff about that in the tutorial I was reading "A gentle introduction to Haskell"
05:46:43 <astrolabe> Hmm perhaps I should look it over again
05:46:49 <ndm> pejo: sorry, doesn't look like its available publically
05:46:55 <SuperNewb> "The classes used by Haskell are similar to those used in other object-oriented languages such as C++ and Java..." and it goes on
05:47:24 <ski> astrolabe,SuperNewb : have you looked at the YAHT ?  (because people say the 'gentle' tutorial is necessarily so gentle, for FP-newbies  ..)
05:47:46 <SuperNewb> ski I found out the hard truth by myself
05:48:13 <SuperNewb> nxt weekend I'll start with the YAHT
05:48:15 <ski> the classes is haskell is not similar to those in most other OO langs, e.g. C++, Java
05:48:35 <ski> surely, thinking af abstract bases classes in C++ or interfaces in Java help
05:49:00 <ski> s/similar/very similar/
05:49:04 <ndm> classes in Haskell aren't a massively important thing to understand either - some systems (Helium i think) don't even support classes
05:49:54 <ski> (though, i think Helium skips classes, because it aims to give newbie-friendly and helpful error messages, and classes complicate that)
05:50:23 <pejo> ndm, Helium is aimed at teaching fp to beginners though, isn't it? Bastian Hee.. (sp?) did a bunch of research on delivering good error messages for type errors iirc.
05:50:43 <ndm> pejo, yep - the reason classes disappear is because they complicate error messages
05:50:57 <ndm> although i know they were trying to put them back in
05:51:02 <SuperNewb> I've been using Helium and I found it very helpful
05:51:18 <SuperNewb> I wish it supported type classes because too often, I couldn't use it because of that
05:51:37 * Lemmih points out that there is no "gentle tutorial" and that the 'Gentle introduction' actually *is* a gentle introduction to the Haskell98 report.
05:54:12 <pejo> ndm, http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/ is the basic fp class at chalmers.
05:55:27 <ndm> pejo, our course was a lot more "fragmented"
05:55:30 <pejo> ndm, and the advanced is http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/schedule.html
05:55:47 * SuperNewb says goodbye for today
05:55:51 <ndm> the exercises were all "write a function to do"
05:56:28 <ndm> going from sum to pascals triangle, predicate simplifers etc.
05:56:44 <ndm> unfortunately there is no advanced FP course at York :(
06:10:03 <pejo> ndm, heh, I feel your pain. We don't have it here either.
06:10:35 <ndm> pejo, i was looking at http://www.cs.uu.nl/wiki/Afp/CourseDescription earlier in awe
06:12:58 <pejo> ndm, hm, looks useful, indeed.
06:25:53 <Philippa_> pejo: you wanted to ask me questions about Impure Thoughts?
06:29:07 <pejo> Phil, yeah, had any pointers to any material about type systems and how they solve problems in real time systems?
06:40:45 <astrolabe> Do I have to order my declarations in Haskell as I do in C so that I don't refer to things defined futher down the file?
06:41:01 <Lemmih> Nope.
06:41:18 <astrolabe> Yay!
06:41:51 <Lemmih> Hurrah (:
06:44:03 <Philippa_> pejo: not much, no. I'm loosely aware that one could type more strictly for space usage (consider an extension of the region code where regions have all the variables in them declared at the start and the type system propagates space info?), and that one could do similar for time
06:44:40 <Philippa_> more strongly, if it's possible to prove the relevant properties and have a computer check the proof, it can be done with a sufficiently powerful dependant typing system
06:45:13 <Philippa_> for some simple examples though, you could encode restrictions on interrupt handlers or their higher-level equivalents...
06:45:28 <Lemmih> benmos: It's hard to quit, eh?
06:45:52 <Philippa_> oh, and apologies for the delayed reply - I had to go shower, got folks due round shortly
06:55:40 <pejo> Philippa, no worries about delay. I have the impression that in a strict language it wouldn't be too hard to do the time analysis.
07:06:48 <smott> ewgh, two hours later and i finally have a FilePath -> IO (Tree FilePath) function
07:07:37 <basti_> smott: recursing subdirectories?
07:08:10 <smott> it makes a tree of directories
07:09:12 * basti_ nods
07:09:26 <basti_> why do you think it did take so long?
07:12:07 <astrolabe> It has taken me all morning, but I've escaped from the IO Monad!
07:12:29 <basti_> astrolabe: o0
07:12:31 <smott> basti_: no idea, it seems to easy now!
07:12:38 <basti_> smott: then it's good ;)
07:26:13 <vegai> astrolabe: safely?
07:27:32 <astrolabe> vegai:  I imagine so, I wouldn't know how to do it otherwise.  What I mean is that I've coded up my IO stuff using calls to non-IO functions.
07:28:14 * astrolabe is a newbie
07:29:06 <basti_> ah, that.
07:30:35 <basti_> yesterday i wanted to know how my terminal translates Meta-keypresses. So i did: do sequence $ repeat $ getChar>>=putStr.show and found out.
07:31:21 <vegai> yeah, that's pretty safe
07:32:22 * astrolabe steals basti's neat syntax
07:46:04 <smott> can anyone tell me what i'm doing wrong here: http://elatae.net/dv/113d.hs ? the code works just fine except that at the line "hPutStrLn h (req++" : USERID : UNIX : "++rnd)", the req part isn't being printed
07:47:09 <basti_> maybe req just doesn't contain what you would it expect to?
07:49:47 <smott> just hPutStrLn h req works fine
07:50:39 <basti_> thats strange
07:50:54 <basti_> maybe req contains a newline and thus something gets confused?
07:52:52 <smott> if i put "hPutStrLn h req" before the other line, connect, and type "hello" then i get:
07:52:52 <smott> hello
07:52:52 <smott>  : USERID : UNIX : pie
07:52:55 <smott> Connection closed by foreign host.
07:53:09 <basti_> very strange
07:53:42 <basti_> it works on my system like you'd expect
07:53:47 <basti_> basti@deunan:~$ nc localhost 9999
07:53:47 <basti_> test
07:53:47 <basti_> test : USERID : UNIX : ryh
07:56:13 * Igloo hasn't look at the code, but you could see whether hSetBuffering h NoBuffering helps
07:56:24 <Igloo> (possibly also for stdout/stderr)
07:57:52 <smott> Igloo: yeah i have that
07:57:57 <smott> strange, it works with nc, but not telnet
07:59:48 <basti_> o0
07:59:58 <basti_> maybe problems with line endings?
08:01:19 <smott> just telnet being weird i guess
08:02:20 <Lemmih> Prelude> putStrLn "Hello\rWorld"
08:02:20 <Lemmih> World
08:04:47 <Lemmih> "Hello\r\n" will be "Hello\r" after hGetLine in binary mode.
08:05:17 <basti_> ahhhhh. that might explain some things yes.
08:36:47 <Emmiek> hi
08:43:38 <basti_> hi Emmiek
08:46:50 <kolmodin> does anyone know what to do when c2hs says c2hs: Error in C header file. /usr/include/sys/stat.h:215: (column 81) [FATAL] >>> Syntax error! The symbol `__asm__' does not fit here.     ?
08:50:38 * basti_ doesnt
08:51:49 <goron> kolmodin: I don't think __asm__ is standard C.
08:52:17 <goron> kolmodin: Since it's *C* to Haskell, it's rejected by the parser.
08:52:28 <goron> kolmodin: But I could be wrong.
08:52:31 <kolmodin> goron: ok
08:52:39 * basti_ votes for goron though
08:53:11 <goron> __asm__ isn't in ANSI C, right?
08:53:33 <basti_> it isnt for sure
08:53:43 <basti_> almost every C compiler has such an escape but they are all different
08:53:47 <Enveigler> kolmodin: See http://swox.com/list-archives/gmp-devel/2003-December/000318.html
08:53:50 <goron> Well, then that must be it.
08:53:58 <kolmodin> Enveigler: thanks
08:54:01 <goron> basti_: Yes, I heard about that horror.
08:54:29 <basti_> how lucky that you never actually had to experience it
08:56:27 <goron> Well, I have experience in sharing a printer connected to FreeBSD with Windows. I think that's even worse.
08:56:53 * goron thinks system configuration is a blackart. 
08:57:51 <goron> "the data region that was passed to a system call, is too small".
08:58:16 <basti_> @ghc
08:58:17 <lambdabot>  In a case expression, type of scrutinee does not match patterns
08:58:45 <goron> Very useful message(i.e. "we can't write drivers, but hey! We make money")
08:58:55 <kolmodin> so what is the next step? should I copy all .h files and replace all __asm__ to asm?
08:59:33 <basti_> kolmodin: hmm if asm works?
08:59:39 <goron> kolmodin: You could first try to find out what constitutes valid syntax according to c2hs
09:00:04 <goron> kolmodin: I am sure it's documented somewhere (or else grab the source).
09:00:23 <basti_> you could also just provoke it
09:00:31 <basti_> this should happen fairly early
09:00:31 <Igloo> It would be good to talk to teh authors to make sure they're aware of the problem
09:00:40 <kolmodin> goron: seems like a good idea
09:00:43 <basti_> maybe a file containing __asm__ { } triggers it
09:00:55 <goron> Igloo: so we don't have the problem anymore later on:)
09:01:02 <basti_> or void something() { __asm__ {} }
09:04:11 <marcot> Hello, I've already asked this here some days ago.
09:04:21 <marcot> I'm with a problem with cabal + c2hs:
09:06:04 <marcot> marcot@tonhao:~/gpc-haskell$ runghc Setup.hs build -v5
09:06:04 <marcot> Preprocessing library GPC-Haskell-2.31.0...
09:06:04 <marcot> /usr/bin/c2hs -o src/GPCHaskell.hs src/GPCHaskell.chs
09:06:09 <marcot> c2hs: does not exist
09:06:10 <marcot> *** Exception: got error code while preprocessing: GPCHaskell
09:06:10 <marcot> marcot@tonhao:~/gpc-haskell$ /usr/bin/c2hs -o src/GPCHaskell.hs src/GPCHaskell.chs || echo Error
09:06:12 <marcot> marcot@tonhao:~/gpc-haskell$
09:06:28 <marcot> Why is cabal seeing an error where there's none?
09:06:33 <pejo> marcot, does /usr/bin/c2hs exist?
09:07:57 <Igloo> strace it to check what it's running
09:08:06 <marcot> pejo: marcot@tonhao:~/gpc-haskell$ ls -Flha /usr/bin/c2hs
09:08:06 <marcot> -rwxr-xr-x  1 root root 1.4M Jul 14 15:15 /usr/bin/c2hs*
09:08:06 <marcot> marcot@tonhao:~/gpc-haskell$
09:08:10 <marcot> Igloo: ok.
09:12:34 <marcot> Igloo: it doesn't seem to try to open or exec /usr/bin/c2hs before giving this error.
09:12:57 <marcot> Igloo: I've pasted the strace result in a file, and the first time that c2hs appears is in the error message.
09:13:02 <marcot> Igloo: and the only one.
09:14:06 <marcot> Igloo: http://pastebin.com/315034
09:15:08 <musasabi> marcot: did you try upgrading cabal?
09:17:25 <musasabi> that might help, now have to go =>
09:25:32 <marcot> musasabi: thanks.
09:32:02 <kolmodin> I fixed it...wrote a two line .h wrapper:  #define __asm__(X)    #include <fuse.h>
09:32:11 <kolmodin> :) works nice :)
09:32:33 <basti_> :)
09:43:08 <Igloo> marcot: Did you use strace -f?
09:43:56 <marcot> Igloo: no... )=
09:47:34 <marcot> Igloo: http://pastebin.com/315054
09:47:44 <marcot> Igloo: Now it's with -f
09:47:57 <Lemmih> Updating Cabal will most likely fix the problem.
09:48:40 <Lemmih> The c2hs preprocessing code in 0.5 is definitely wrong.
09:49:04 <kolmodin> what distro are you running?
09:53:49 <Oejet> Greetings, pets and people.
09:55:29 <Lemmih> Hey Oejet.
09:55:32 <marcot> I'm running debian.
09:55:38 <marcot> Actually I must package it for debian.
09:55:53 <marcot> And it would be much better if I could use that version, which is the latest one in sid.
09:56:00 <marcot> But I'll try it with ghc-cvs
09:56:31 <Lemmih> You don't have to upgrade GHC.
09:57:56 <marcot> Lemmih: but there's a new version of cabal packaged for this version of ghc.
09:58:08 <marcot> Lemmih: for ghc6 package, the latest version is cabal 0.5
09:58:40 <Lemmih> You could install it from source.
10:01:48 <marcot> Lemmih: I'm not doing it just for me, I must generate a debian package from this program I'm making, then I need everything packaged in debian. I'm wondering about packaging the new version of cabal for ghc6, but I'll try with ghc-cvs just to see if it works.
10:09:55 <Beelsebob> buh
10:09:58 <Beelsebob> too... hot...
10:10:27 <Lemmih> @temp Beelsebob
10:10:28 <lambdabot>  @help <command> - ask for help for <command>
10:10:33 <Oejet> too sexy
10:10:46 <Igloo> Grr, ghc -M in 6.4 doesn't like having multiple Mains
10:10:51 <Beelsebob> I think it's about 30
10:11:26 <Oejet> Bah, the Danish summer is already over. :-(
10:12:06 <tic> same here in Swedne
10:12:16 <jlouis> where is Swedne located?
10:12:27 <Beelsebob> odd that we're still boiling
10:12:38 <tic> jlouis, pfft.
10:12:39 <tic> Sweden
10:12:44 <tic> Scandinavia.
10:13:31 <jlouis> we should team up with our old enemies on the other side of Oresund someday and create Scandinavia as a land
10:13:41 <jlouis> country even
10:14:19 <jlouis> if we could get Norwya to accept too, Swedne and Denmakr would have infinite oil resources
10:14:32 <jlouis> ehm, create Scandinavai even
10:15:19 <gzl> is "How to Think Like a Computer Scientist" a good book?
10:15:35 <Oejet> Yay, and the Danihs parlament would rule it all like in the old days.
10:15:37 <gzl> for someone who knows nothing about computers or programming
10:16:18 <Oejet> Why would you think like a computer scientist, f you are not one?
10:17:00 <gzl> because you're taking an intro programming course and the professor wants to teach you how to think and not how to write the factorial function in Java.
10:18:12 <sond> you should already know how to think when you come to class.
10:18:21 <gzl> realistically, few do.
10:18:29 <astrolabe> Does a haskell program give up its cpu time for other processes while getChar is waiting for input?
10:18:45 <Oejet> Well, I'd rather learn how to think like Lance A. or George W. B. or Albert A.
10:19:05 <sond> George W. B. ??
10:19:05 <gzl> ..
10:19:19 <gzl> that's just the title of the book
10:19:21 <sh10151> albert a?
10:19:35 <gzl> I think you're getting unnecessarily distracted by the title, frankly
10:20:09 <Oejet> Yeah, that would be quite interesting to know how they think.
10:20:44 <Oejet> gzl: Hm, I'm just talking, I don't know the book. :-/
10:21:01 <gzl> fair enough. I only really wanted to know about the book. :)
10:21:12 <Gahhh> astrolabe: yes, it uses the same os functions that c programs use to do io
10:21:28 <astrolabe> thanks
10:24:29 <frederik>         mfix f = StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
10:24:34 <frederik> what does "~" mean?
10:25:09 <basti_> thats a good question.
10:25:35 <frederik> does it have a good answer? :)
10:25:40 <basti_> hmm
10:25:47 <astrolabe> is it lazy pattern matching?
10:25:50 <basti_> where did you get that line from?
10:25:57 <basti_> i think all patterns are matched lazily?
10:26:06 <frederik> instance (MonadFix m) => MonadFix (StateT s m) where
10:26:15 <frederik> that's the line above. in State.hs in hugs distro
10:26:38 <basti_> mmmm k
10:27:06 <Lemmih> @google irrefutable pattern match
10:27:08 <lambdabot> http://www.haskell.org/tutorial/patterns.html
10:28:23 <frederik> oh, it's a lazy match. needed because the result of runStateT isn't known to be a pair by the compiler
10:28:50 <frederik> hot
10:29:41 <basti_> hummmm.
10:30:01 <basti_> my State.hs has a different line
10:30:37 <frederik> what is it?
10:30:59 <basti_>         mfix f = State $ \s -> let (a, s') = runState (f a) s in (a, s')
10:31:10 <basti_> oh yours is StateT
10:31:10 <basti_> sorry
10:31:23 <frederik> yeah
10:31:45 <basti_> yes its the same
10:33:59 <frederik> hmm. my MonadFix for WASH still doesn't work. i have it for WithHTML but when I submit the page it says <<loop>>. i wish it would give me a line number
10:35:50 <marcot> How can I check cabals version?
10:35:59 <marcot> runghc Setup.hs --version doens't work.
10:36:09 <basti_> frederik: hmm, this would be hard
10:36:21 <frederik> basti_: why?
10:36:24 <Lemmih> marcot: ghc-pkg list
10:36:36 <Lemmih> marcot: or 'ghc-pkg describe Cabal'
10:37:04 <basti_> first hand i don't know what <<loop>> exactly means
10:37:05 <basti_> ;)
10:37:26 <Igloo> It means your program does an infinite loop
10:37:30 <Lemmih> @plugs let loop = loop in loop :: ()
10:37:31 <lambdabot> Fail: <<loop>>
10:37:31 <lambdabot>  
10:37:53 <marcot> Lemmih: thanks.
10:37:56 <basti_> but how does it recognize infinite loops?
10:38:03 <Lemmih> @plugs let loop () = loop () in loop () :: ()
10:38:08 <lambdabot> Terminated
10:38:10 <basti_> it cant be solving the halting problem
10:38:17 <Igloo> It doesn't spot all of them
10:38:37 <basti_> hmm
10:38:51 <marcot> Strange:
10:38:52 <basti_> and then, maybe the loop condition could be built up across many lines?
10:39:00 <marcot> marcot@tonhao:~$ ghc-pkg list | grep Cabal
10:39:00 <marcot>     Cabal-1.0, parsec-1.0, haskell-src-1.0, network-1.0,
10:39:06 <Igloo> Yes
10:39:10 <marcot> So it seems to be Cabal-1.0..
10:39:24 <basti_> that would make giving a line number hard a bit
10:39:26 <Igloo> Compiling with -prof -auto-all and running with +RTS -xc might tell you where the problem is
10:39:27 <marcot> marcot@tonhao:~$ apt-cache show libghc6-cabal-dev | grep Version
10:39:28 <marcot> Version: 0.5-1
10:39:42 <marcot> Lemmih: can you understand that?
10:39:43 <Lemmih> marcot: 1.0 == 0.5 (:
10:39:56 <marcot> Lemmih: are you serious?
10:39:57 <marcot> hehehe
10:39:58 <basti_> the loop also might be composed at runtime?
10:40:02 <Igloo> But given you were talking about fix functions above I suspect you alredy know where it is  :-)
10:40:06 <Lemmih> marcot: Somebody got the version wrong when they released GHC 6.4
10:40:46 <marcot> Lemmih: you mean in debian, or this is a cabal ghc problem?
10:41:39 <Igloo> It was a miscommunication between the cabal devs and ghc devs, I think
10:41:53 <frederik> Igloo: it could be in one of two places
10:41:55 <Lemmih> It was a brainfart in GHC but GHC is law so Cabal jumped to 1.0 (:
10:45:32 <frederik> i hate that word
10:45:53 <Lemmih> Brainfart?
10:46:33 <frederik> yeah
10:48:15 <marcot> But anyway, isn't it the newest cabal version?
10:48:52 <Lemmih> 1.1.1 is the newest Cabal version.
10:49:18 <marcot> Lemmih: only in darcs repository, right?
10:49:35 <marcot> Lemmih: in the tarball from the website it's 1.0
10:50:00 <Lemmih> Nope. It the release candidate for 1.2.
10:50:28 <marcot> Lemmih: sorry?
10:50:43 <Lemmih> s/It/It's/
10:51:14 <marcot> 1.1... ok. But it's not available as a tarball right?
10:51:26 <marcot> Then it's only on the darcs repository, isn't it?
10:51:43 <Lemmih> Nope. You can get it at the Cabal downloading page.
10:52:17 <marcot> hum.. I was looking in the code page.
10:53:10 <marcot> Report bugs here. If you are a Debian user, you may report bugs against the haskell-cabal package.
10:53:16 <marcot> There's no haskell-cabal in debian.
10:53:24 <marcot> Lemmih: are you the mantainer of the website?
10:54:08 <Lemmih> Unfortunately not.
10:54:42 <marcot> Lemmih: if you could tell that to the mantainer.
10:55:49 <marcot> The correct name of the package is libghc6-cabal-dev
10:56:12 <Igloo> haskell-cabal is the source package name, I think
10:59:00 <marcot> Igloo: http://packages.debian.org/haskell-cabal
10:59:52 <Igloo> marcot: http://packages.debian.org/unstable/source/haskell-cabal
11:00:10 <astrolabe> I've got some code: gTPLinesIn = do {line <- gTPGetLine; lines <- gTPLinesIn; return (line:lines)}
11:00:16 <astrolabe> Could it be hanging?
11:02:41 <astrolabe> gTPGetLine uses getLine
11:04:19 <marcot> Igloo: ok, that's right.
11:15:57 <ski> astrolabe : hm, is that in IO-monad ?
11:16:08 <astrolabe> ski: yes
11:17:28 <ski> that looks like it will never actually return anything
11:17:52 <ski> maybe, what you want is unsafeInterleaveIO ..
11:17:57 <astrolabe> ski:  You seem to be correct.  Do you know how I can fix it?
11:18:06 <astrolabe> OMG that sounds scary
11:18:23 <ski> what more specifically is gTPGetLine doing ?
11:18:49 <ski> reading from some file ?
11:18:58 <astrolabe> Yes, reading from the standard input
11:19:26 <astrolabe> (the keyboard here)
11:20:08 <ski> hm, you could also consider getting the contents of stdin with getContents (that will give a string, in the IO-monad), you can then manipulate the string instead
11:20:38 <ski> (more or less, getContents is prolly internally using unsafeInterleaveIO)
11:21:15 <astrolabe> ski: Thanks I'll look into getContents
11:21:24 <ski> @index getContents
11:21:25 <lambdabot> System.IO, Prelude
11:21:34 <ski> @type getContents
11:21:35 <smott> @type lines
11:21:35 <lambdabot> IO String
11:21:36 <lambdabot> String -> [String]
11:21:43 <ski> there's also
11:21:46 <ski> @type hGetContents
11:21:48 <lambdabot> bzzt
11:21:54 <ski> @type System.IO.hGetContents
11:21:55 <lambdabot> GHC.IOBase.Handle -> IO String
12:06:17 <Lemmih> @seen Smerdyakov
12:06:18 <lambdabot> I haven't seen Smerdyakov.
12:14:43 <kenr> does anyone know if it is possible to do interactive (repl-style) programming with haskell with hopengl?
12:15:38 <Lemmih> Yes, that is possible.
12:16:30 <kenr> just to be clear -- and continue interactive once the main loop is called, right?
12:16:44 <Lemmih> The main loop?
12:16:59 <Lemmih> There's no main loop in HOpenGL.
12:17:19 <kenr> just a sec -- i'll take a look at the code i've looked at before and clarify
12:18:00 <kenr> take a look at the last line of http://www.haskell.org/HOpenGL/examples/Planet.hs
12:18:32 <Lemmih> (GLUT is a different monster)
12:19:04 <kenr> ahh -- so theres an alternate way to do windowing with hopengl?
12:19:19 <Lemmih> You can use SDL.
12:19:33 <kenr> does SDL still limit you to one window?
12:19:45 <Lemmih> Yeah. /-:
12:20:47 <kenr> bummer, but still... interactive even with one window is enough for now (i've been doing all my work in lablgl under ocaml and wanting to do some porting to haskell)
12:24:58 <kenr> just did some googling -- sounds like i'm talking to someone who might know a *little* bit about haskell sdl... :-) and looks like usage with ghci is explicit. cool.. thanks!
12:26:45 <genneth> @Autrijus
12:26:47 <lambdabot> Unknown command, try @listcommands.
12:26:51 <genneth> @seen Autrijus
12:26:53 <lambdabot> Autrijus is in #haskell. Last spoke 1 day, 12 hours, 19 minutes and
12:26:53 <lambdabot> 59 seconds ago.
12:27:07 <Lemmih> kenr: No problem. (:
12:27:07 <genneth> guess he's busy with interviews and writing pugs then :p
12:28:31 <autrijus> eh, the interview was a long time ago.
12:28:42 <autrijus> LtU's dupe rate is catching up with /.'s. ;)
12:29:35 <autrijus> genneth: what's it?
12:33:55 <autrijus> ...timeout. I'll go back to sleep :) &
12:34:55 <kenr> Lemmith: is it possible with have event handling done behind the scenes (by a thread or whatever) -- so events are handled and i can still work with the repl?
12:35:17 <kenr> (btw, sorry, typo, meant Lemmih)
12:40:07 <genneth> autrijus: oh nothing; i just read your interview on oreilly
12:43:43 <Lemmih> kenr: I think it's possible... haven't tested it though.
12:47:00 <kenr> lemmih: cool -- i'll dive in and do some hacking then. thanks
12:55:23 <frederik> i really need a way to find where <<loop>> is coming from - it's going to be some pattern match somewhere in the program that triggers the thunk loop detection
12:55:30 <frederik> anyone know how?
12:55:58 <frederik> i can e.g. recompile with some sort of profiling option if that works
12:57:13 <Lemmih> Recompile with -prof and run with +RTS -xs?
12:58:03 <astrolabe> hey SupeNewb.  I hope you're having more success than me.
12:58:20 <astrolabe> * SuperNewb
13:00:27 <frederik> Lemmih: cool, so you know that will work? how do i do it with a library that i'm building with cabal, do i need to compile the main app with -prof or just the library?
13:00:57 <Lemmih> Using GHC 6.4?
13:01:05 <frederik> yeah
13:01:43 <Lemmih> Too bad. -xc doesn't work in 6.4
13:02:06 <frederik> huh
13:02:08 <Lemmih> (-xs was a tyop)
13:02:20 <frederik> so i'm screwed?
13:02:57 <Lemmih> You can do refactoring or place some debug messages.
13:07:37 <frederik> what's a good way of putting debug messages in pure-functional code?
13:07:47 <Lemmih> It would be neat if GHCi was linked with a threaded RTS.
13:09:03 <Lemmih> There's Debug.Trace.trace.
13:10:24 <smott> astrolabe: problems?
13:13:47 <astrolabe> smott:  I just got round them thanks for asking.  I've just written my first (extremely) simple bit of interactive haskell code, and I'm exhilarated!
13:14:09 <frederik> Lemmih: neat, thanks
13:14:43 <xerox> astrolabe: what is it about? :-)
13:21:39 <astrolabe> xerox: It is going to be a 'Go Text Protocol' engine, but it is only a few lines of code so far.  I intend to do the GTP side first and keep the go playing trivial for the time being.
13:22:02 <xerox> Great :-D
13:30:44 <Lemmih> dcoutts: Hey.
13:30:48 <dcoutts> hello
13:31:00 <dcoutts> back from holiday :-)
13:31:09 <Lemmih> I believe I've found a bug in gtk2hs.
13:31:16 <dcoutts> + a wedding, all very nice
13:31:22 <dcoutts> oh ok
13:31:34 <Lemmih> Welcome back, then. (:
13:31:46 <dcoutts> symptoms / cause / (patch!) ?
13:33:09 <xerox> dcoutts!
13:33:10 <Lemmih> 'timeoutRemove' fails because it's unsafe and it calls Haskell from the C side.
13:33:15 <xerox> Did you enjoy them? :-D
13:33:54 <dcoutts> Lemmih, hmm interesting, how does it call back to Haskell land?
13:34:00 <dcoutts> xerox, yes thanks
13:34:19 <Lemmih> dcoutts: I have no idea. It's actually very weird (:
13:34:23 <dcoutts> Lemmih, I'll change it to be marked safe then
13:34:33 <Lemmih> Thanks.
13:35:34 <dcoutts> Lemmih, what's you app? (and would it be cheeky to beg for a screenshot? :-) )
13:44:52 <Lemmih> dcoutts: http://www.scannedinavian.org/~lemmih/hDiary3.png
13:45:39 <dcoutts> cool :-) I like the spell checking red underlining thing
13:45:58 <dcoutts> how did you do that then?
13:46:25 <xerox> Lemmih: then add a "blog" button? :-D
13:46:34 <Lemmih> I just used gtkspell (gtkspell.sf.net)
13:46:35 <xerox> dcoutts: there is a Gtk Widget for that
13:46:39 <kolmodin> no loading/saving... I guess that is as simple as possible :p
13:46:43 <Lemmih> xerox: I thought about that.
13:47:02 <xerox> Lemmih: it would be _great_
13:47:07 <dcoutts> Lemmih, did you write the gtkspell bindings by hand or use a generator?
13:47:09 <xerox> Maybe via XMLRPC.
13:47:29 <Lemmih> xerox: But I'm only using it for writing really personal stuff.
13:47:49 * xerox prays Lemmih  ;)
13:47:49 <Lemmih> dcoutts: Wrote it by hand. It was only like 4 functions.
13:47:58 <dcoutts> right
13:48:08 <Lemmih> xerox: I'll definitely hack it if you're interested.
13:48:54 <xerox> Lemmih: yes, I am - thank you very much!  I have to keep a blog for the SoC issue, your tool could be very handy.
13:49:16 <Lemmih> SoC?
13:49:36 <dcoutts> Google Summer of Code
13:49:37 <xerox> http://haskell.org/gtk2hs/
13:49:52 <xerox> dcoutts: that article finished on GNOME news, yay :-D
13:50:09 <xerox> (maybe "showed up" was better)
13:50:21 <xerox> http://planet.gnome.org/news/
13:50:36 <dcoutts> yes it is still there
13:51:30 <dcoutts> xerox, there are existing gnome desktop apps for doing blog posting if you need something that works now (or you can log in to the website directly)
13:51:51 <xerox> dcoutts: for example?
13:52:16 <kolmodin> dcoutts: now that you are back I have a question for you: I played with c2hs earlier today and it whined about __asm__ when it loaded /usr/include/sys/stat.h. something you seen before?
13:52:21 <dcoutts> http://www.gnome.org/~seth/gnome-blog/
13:52:30 <xerox> I was thinking hDiary was a nice idea because I would not have had to connect to manage it, or such, and then "sync" when connected.
13:52:42 <dcoutts> kolmodin, yes was in on Mac OS X 10.4 ?
13:52:58 <kolmodin> no, gentoo
13:53:24 <kolmodin> ">>> Syntax error! The symbol `__asm__' does not fit here."
13:53:29 <dcoutts> oh really! hmm I ought to be able to track it down then
13:53:34 <dcoutts> what libc are you using?
13:54:20 <kolmodin> like glibc?
13:54:27 <dcoutts> yes what version
13:54:33 <kolmodin> sys-libs/glibc-2.3.5
13:55:18 <dcoutts> ok, cheers I'll look into it. We'll be doing a 0.9.8.1 release with all the recent bug fixes
13:55:44 <kolmodin> oh, it wasn't while compiling gtk2hs
13:56:24 <dcoutts> ok, but it affects gtk2hs on OS X
13:56:29 <kolmodin> ok
13:56:35 <dcoutts> c2hs doesn't understand the asm keyword
13:56:40 <dcoutts> yet :-)
13:56:45 <kolmodin> :)
13:57:01 <kolmodin> I did a dirty workaround.... #define __asm__(X)
13:57:06 <kolmodin> worked great! :D
13:57:31 <dcoutts> yeah, that's essentially what we'll do in c2hs, parse it but ignore it
13:58:36 <kolmodin> I played with the idea of writing bindings to fuse (Filesystem in Userspace)... would be cool to write a fs in haskell :)
13:59:11 <astrolabe> I wish GHK would give more explicit messages than "parse error on input" and a location
14:00:26 <kolmodin> at least I wrote new ebuilds for cabal-1.1.1 and c2hs-0.14.1 :)
14:00:41 <dcoutts> kolmodin, cheers
14:00:58 <kolmodin> dcoutts: bye
14:01:02 <dcoutts> kolmodin, ever thought of joining the Gentoo Haskell Herd? :-)
14:01:39 <kolmodin> I'm at least in #gentoo-haskell :)
14:01:45 <musasabi> a cabal2ebuild script would be very nice.
14:01:54 <kolmodin> dcoutts: sure, sounds fun :)
14:02:03 <dcoutts> yes, it's an idea we've been thinking about
14:02:16 <dcoutts> we'd like to do it when one of us has a free moment
14:02:44 <frederik> hey, when i give "let loop = loop in loop :: ()" to ghci, it just hangs
14:02:51 <frederik> no "<<loop>>" message
14:03:08 <kolmodin> we could do pretty much with just an eclass written for cabal, right?
14:03:29 <musasabi> kolmodin: having a tool would be much nicer for the casual user.
14:03:51 <frederik> eclass?
14:03:56 <kolmodin> musasabi: sure
14:04:15 <kolmodin> frederik: take a look in your /usr/portage/eclass/
14:05:29 <dcoutts> kolmodin, we'd have an cabal2ebuild tool that would generate ebuilds that use the cabal eclass
14:06:07 <kolmodin> dcoutts: right. best of two worlds, eh? :)
14:06:11 <frederik> kolmodin: no such directory
14:06:26 <kolmodin> frederik: you are not running gentoo, are you?
14:06:37 <frederik> no
14:06:45 <dcoutts> kolmodin, yes, simple ebuilds that use the haskell-cabal.eclass are really very short
14:07:05 <dcoutts> frederik, then ebuild are not important to you! :-)
14:07:12 <kolmodin> frederik: then that is normal :)
14:07:33 <frederik> excellent
14:08:44 <dcoutts> musasabi, actually we do not invisage ordinary users using the cabal2ebuild tool, we'd just use it to make it much easier for us to add loads of cabalised packages
14:09:37 <kolmodin> dcoutts: I found some nice functions in cabal-0.5.ebuild...
14:10:18 <dcoutts> yes, we've pulled those out into an eclass
14:10:29 <dcoutts> it's not in portage yet however
14:10:48 <kolmodin> yeah, the users should ask us to add an ebuild so everyone can use the new ebuild
14:10:59 <dcoutts> yes
14:11:10 <dcoutts> it's not like cpan (yet)
14:11:31 <kolmodin> what is that?
14:11:41 <dcoutts> @google CPAN
14:11:43 <lambdabot> http://www.cpan.org/
14:11:50 <kolmodin> Comprehensive Perl Archive Network?
14:11:51 <kolmodin> cool
14:12:27 <dcoutts> there is a gentoo tool for turning cpan packages into ebuilds, and end users are expected to use that because there are 1000s of cpan packages
14:12:47 <dcoutts> so not all of them are in portage (only ones that are deps of apps that are in portage)
14:12:53 <kolmodin> ah
14:30:18 <kolmodin> well, good night everyone
14:30:51 <astrolabe> g'night
14:31:10 <dcoutts> bye
14:37:04 <basti_> lol two friends (engineer & mathematican) recently explained a (thus obviously stupid) CS guy how to solve the halting problem
14:37:35 <xerox> ^C ?
14:37:40 <Spark> heh
14:37:50 <basti_> ^c?
14:37:57 <Spark> just make your computer have a finite state, and use the pumping lemma, that should work shouldnt it
14:38:32 <basti_> -g-
14:41:32 <Philippa_> yeah, the halting problem can be solved by constraining the set of inputs to those for which it's solvable :-)
14:42:07 <Oejet> What's the problem then?
14:43:36 <Spark> "mechanical engineering is inherently finite"
14:46:19 <musasabi> Mechanical computers are inherently thus not turing complete ;)
14:46:42 <Oejet> =-O
14:47:41 <astrolabe> Hey we could have a haskell busy beaver competition
14:48:40 <dcoutts> how does that work?
14:48:59 <astrolabe> A valid entry would be any program that prints out a finite string of '1's and then halts
14:49:24 <dcoutts> print "1"
14:49:38 <dcoutts> @plugs "1"
14:49:41 <astrolabe> A record holder would be one that prints out a string at least as long as any program that is not longer
14:49:44 <lambdabot> "1"
14:50:22 <astrolabe> I guess we could just measure the length of the program by the number of characters it contains
14:51:26 <astrolabe> So dcoutts's entry is 8 characters long, and prints a list of 1 '1'
14:52:06 <Oejet> main = repeatN_ 10^10^10 (putStr "1")
14:53:08 <michaelw> Oejet: think ackermann function
14:53:08 <astrolabe> Woah I can see that haskell is going to pretty powerful for this.
14:53:56 <dcoutts> I've got a better one!
14:53:58 <dcoutts> main = repeatN_ 9^9^9^9 (putStr "1")
14:54:07 <astrolabe> LOL!
14:54:11 <dcoutts> one char shorter and with many more 1s
14:54:23 * Oejet is beaten.
14:55:39 <gzl> you could do something that iterates Knuth arrows
14:55:41 <gzl> that would be kind of fun
14:56:00 <wagle> main = do {putStr "1" ; main}
14:56:08 <dcoutts> no thats not finite
14:56:10 <astrolabe> I suspect that there is no scheme (ie computable sequence of functions of increasing length) that cannot be beaten for a high length
14:56:21 <wagle> it prints a finite number of 1's and then haltsd
14:56:25 <wagle> it prints a finite number of 1's and then haltsdhalts
14:56:31 <wagle> aigh
14:56:32 <wagle> halts
14:56:52 <astrolabe> wagle: How finite?
14:57:17 <Igloo> I don't think your problem is well defined
14:57:19 <wagle> i've never seen it run forever..  always halts one way or another
14:57:34 <wagle> *<8-D
14:57:50 <astrolabe> Igloo: Why not?
14:58:06 <Igloo> You could make one program that prints a fixed number of 1s then terminates and another that forks a thread that prints an infinite number but is killed by the main program after a time delay, where the two programs are of the same length
14:58:12 <wagle> there's never been an infinite computation carried out in the history of the universe..
14:58:13 <Igloo> Then which prints more would depend on the machine running it
14:58:52 <astrolabe> Igloo:  How about a 'pure' program?
14:58:52 <heatsink> Won't it be rather hard to compare results, when you have programs that cannot practically be run to completion?
14:58:53 <wagle> actually, i was more hoping for out-of-memory, or power failure
14:59:06 <Igloo> Then you can't print  :-P
14:59:14 <wagle> main = putStr "infinite number of 1's"
14:59:42 <astrolabe> Igloo:  ok How about then defining an integer
15:00:26 <astrolabe> makes it a nicer problem anyway
15:01:29 <astrolabe> heatsink: yes maths will be required for all but short entries, and would probably be too hard for long ones.
15:01:33 <Beelsebob> A turing machine does not need an infinite tape though
15:01:47 <Beelsebob> it merely needs a tape you can extend when you need more
15:02:07 <Philippa_> = a potentially-infinite tape
15:02:20 <Beelsebob> no
15:02:39 <astrolabe> an extendable finite tape
15:02:44 <Beelsebob> because with some garbage collection some programs that would need an infinte tape can be run in finite space
15:02:47 <wagle> what is repeatN_ anyway?
15:03:07 <dcoutts> it's not a standard function but you can imageine what it does
15:03:17 <Philippa_> that's not sufficient to stop it being potentially-infinite. There're plenty of finite programs without GC, too
15:03:26 <dcoutts> wagle, and probably define it in one line
15:03:40 <astrolabe> GC?
15:03:46 <Philippa_> garbage collection
15:04:13 <Beelsebob> indeed... but we can have a mechanical machine with a potentially infinite tape
15:04:19 <astrolabe> If a programe halts in finite time, then it only needs a finite tape
15:04:21 <Beelsebob> ... assuming the universe is infinite
15:04:51 <Beelsebob> ... which it must be if the program is infinite time
15:07:33 <wagle> @plugs  (((111111111111111111111111111 `div` 3) `div` 3) * 3) * 3
15:07:35 <lambdabot> 111111111111111111111111111
15:09:02 <Beelsebob> hmm... if I feed lambdabot an infinite computation, will this channel blow up?
15:09:44 <wagle> whats the largest integer of the form 1...1 with the smallest representation of its factorization?
15:09:54 <liyang> Beelsebob: no, we'll blow you up. :)
15:09:58 <kaol> @plugs repeat '1'
15:09:59 <lambdabot> "111111111111111111111111111111111111111111111111111111111111111111111
15:09:59 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:09:59 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:09:59 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:09:59 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:10:00 <wagle> @plugs x = x
15:10:02 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:10:02 <Beelsebob> lol
15:10:03 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:10:05 <lambdabot> [23 @more lines]
15:10:07 <lambdabot> parse error on input `='
15:10:16 <Beelsebob> haha... infinity is 23 lines long!
15:10:17 <wagle> @plugs let x = x in x
15:10:18 <lambdabot> Ambiguous type variable `a' in the top-level constraint
15:10:21 <jyp> omg
15:10:27 <wagle> @plugs let x = x in x :: Int
15:10:28 <lambdabot> Fail: <<loop>>
15:10:28 <lambdabot>  
15:10:51 <jyp> @more
15:10:52 <lambdabot> more: empty buffer
15:10:57 * jyp is evil
15:11:00 <Beelsebob> haha
15:11:46 <jyp> Anyone knows why 23 more lines btw ?
15:12:04 <jyp> (making a finite numer of 1's)
15:12:07 <wagle> @plugs repeat '1'
15:12:08 <Beelsebob> 30 line buffer
15:12:09 <jyp> ;)
15:12:09 <lambdabot> "111111111111111111111111111111111111111111111111111111111111111111111
15:12:09 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:09 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:09 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:09 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:10 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:13 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:14 <lambdabot> [23 @more lines]
15:12:17 <wagle> @more
15:12:18 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:18 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:20 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:22 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:25 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:26 <Beelsebob> @slap wagle
15:12:26 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:28 <lambdabot> 1111111111111111111111111111111111111111111111111111111111111111111111
15:12:30 <basti_> -.-
15:12:30 <lambdabot> [16 @more lines]
15:12:32 <lambdabot> Unknown command, try @listcommands.
15:12:44 <wagle> oh nm
15:12:52 <jyp> rofl
15:13:16 <cm> @plugs mhm
15:13:17 <lambdabot> Variable not in scope: `mhm'
15:13:32 <Beelsebob> @plugs let mhm = "spam spam loverly spam"
15:13:33 <lambdabot> parse error on input `)'
15:13:41 <Beelsebob> ... interesting
15:13:44 * wagle takes ten paces, and shoots at Beelsebob 
15:13:57 <Beelsebob> parse error on input it was not given
15:14:17 <Beelsebob> I asume the first step is to wrap everything in brackets
15:15:19 <astrolabe> for some reason  foldr1 ^ [1..1000] doesnt work
15:15:35 <Beelsebob> ... I wonder why
15:15:49 <Beelsebob> could it be the massive integer?
15:16:10 <astrolabe> I mean it won't even compile it
15:16:18 <Beelsebob> what error?
15:16:29 <Beelsebob> oh... I know
15:16:32 <Beelsebob> ^ is infix
15:16:37 <Beelsebob> stick it in brackets
15:18:12 <astrolabe> Beelsebob: right, and I should change the first 1 to 2 or the answer is 1!
15:18:32 <Beelsebob> yes... but computed for a long time
15:19:03 <Beelsebob> because it'll have to compute 2 ^ (3 ^ (4 ^ .........)) to find out what to rase it to the power of
15:19:20 <wagle> foldr1 ((^) . fromIntegral) [1..1000]
15:19:33 <astrolabe> @plugs foldr1 (^) [2..4]
15:19:36 <lambdabot> 2417851639229258349412352
15:19:48 <wagle> d'uh
15:20:16 <Beelsebob> @plugs 3 ^ 4
15:20:17 <lambdabot> 81
15:20:27 <Beelsebob> 2 ^ 81 is not an overflow
15:20:49 <Beelsebob> (surely)
15:21:06 <wagle> oh oh..  ^C doesnt work!  i'm doing an infinite computation!  aieee
15:21:06 <Beelsebob> I guess it would be actually
15:21:13 <Beelsebob> about 30 digits long
15:21:25 <Beelsebob> wagle: kill -9 time
15:21:42 <astrolabe> 25 digits
15:22:50 <Beelsebob> oh duh... that is the result... I thought we were staring at max int
15:22:59 <astrolabe> @plugs foldr1 (^) [2..5]
15:23:05 <lambdabot> Terminated
15:23:10 <Beelsebob> lame
15:23:13 <astrolabe> he he
15:23:21 <astrolabe> lambdabot is arnie
15:23:26 <wagle> @plugs foldr1 (^) [1..4]
15:23:28 <lambdabot> 1
15:23:28 <Beelsebob> @plugs foldr1 (^) [3..5]
15:23:30 <lambdabot> 3733918487410200435329597541848665882254097767837340077506369317220790
15:23:30 <lambdabot> 4061726525122999368893880397722046876506543147515810872705459216085858
15:23:30 <lambdabot> 1351336982809187314191748594262580938807019951956404285571818041046681
15:23:30 <lambdabot> 2887974029255176680123406172983965747316191523867230462351259348960585
15:23:30 <lambdabot> 9058828465479354050593620237654780744273058214452705898875625145281779
15:23:32 <lambdabot> 3413352141920744623027518729185432862375737063985485319476416926263819
15:23:34 <lambdabot> 972887006907013899256524297198527698749274196276811060702333710356481
15:23:35 <Beelsebob> WOO YAY!
15:25:29 <astrolabe> hmm I typed the [2..5] example into hugs and it is still running
15:25:39 <wagle> why does  foldr1 (^) [1..5] take forever?
15:26:11 <Beelsebob> because it's computing 2 ^ 3 ^ 4 ^ 5
15:26:14 <astrolabe> wagle because is has to work out foldr1 (^) [2..5]
15:26:20 <Beelsebob> to work out what to raise 1 to the power of
15:26:38 <wagle> sigh..  i was thinking foldl1
15:26:38 <Beelsebob> foldl on the other hand would be fast
15:27:10 <Beelsebob> woo yay... someone else bought defaulter... I get paid this month
15:27:36 <astrolabe> defaulter?
15:27:55 <Beelsebob> app that I write and sell
15:28:09 <Beelsebob> ... gives a small boost to my funding situation
15:30:10 <wagle> dusoft?
15:30:33 <astrolabe> looking at f [3..5], it is pretty clear that f [2..5] isn't going to finish, and if it did, it couldn't print out.
15:31:26 <Beelsebob> yes
15:31:45 <wagle> astrolabe: lol
15:41:02 <liyang> Here's a way to get ridiculously large numbers concisely: http://en.wikipedia.org/wiki/Conway_chained_arrow
15:44:19 <Philippa_> the formula itself isn't too concise though
15:47:13 <liyang> Philippa_: This is true. Ackermann? :-/
15:54:35 <Philippa_> let f x = foldr1 (^) [2..x] in f(f(f(f(f(f(9))))) ?
15:54:46 <Philippa_> oh, and another )
15:56:28 <cm> hi Philippa-san
15:57:04 <Philippa_> evenin'
15:57:18 <liyang> let f x = foldr1 (^) [2..x] in iterate f 9 !! 6
15:58:11 <Philippa_> 'course, if we're really being serious we should disallow the entire prelude and supply a standard Natural type...
15:58:26 <Philippa_> (define foldr1 yourself etc etc etc)
15:59:01 <liyang> Haskell golf. <_<
15:59:23 <Beelsebob> if one more person mentions golf they will be killed
15:59:46 <Igloo> I wonder how the number of Haskell program (up to alpha renaming) varies with length in characters
16:00:10 <Philippa_> weirdly
16:00:36 <Beelsebob> I would guess a fluctuating line tending toward some exponential function
16:00:43 <Igloo> Well, I was really wondering how cuikly it grows rather than the precise functino
16:00:51 <Igloo> "quickly" too
16:01:22 <Beelsebob> write a haskell program to compute it
16:02:26 <Philippa_> it depends a lot on whether there're an increasing number of "damn that's big" functions that can be expressed or you're just taking up the extra space typing the equivalent of extra 0s somewhere
16:02:57 <Beelsebob> indeed
16:03:07 <Beelsebob> I think you have to constrian the problem more
16:03:11 <Beelsebob> not just alpha renaming
16:03:21 <Beelsebob> but also no just changing constants
16:05:51 <Philippa_> you'll just get successive applications of a "make it bigger!" function instead then
16:06:02 <Beelsebob> good point
16:06:25 <Beelsebob> so probably it's 0 programs up to a small number of chars, and then infinite programs
16:07:22 <Beelsebob> in fact, beyond a certain point it deffinately is infinite...
16:07:28 <Beelsebob> because you could write an interpreter
16:07:38 <Beelsebob> and then generate random inputs for it
16:08:13 <Beelsebob> hmm, no... I'm thinking computation, not program
16:08:18 <Beelsebob> it's not infinite at all
16:28:21 <wagle> main = print $ ackerman(100,100)
16:29:10 <wagle> main = print $ ackerman(ackerman(100,100),ackerman(100,100))
16:29:58 <dcoutts> but isn't that roughly the same as ack 101 100 (or maybe it's ack 100 101, I can't remember)
16:30:22 <wagle> i dunno
16:31:40 <basti_> i know that ackermann(100,100) is far out of reach
16:32:53 <wagle> Tipler claims something like if the cosmological constant is under (over?) some threshold, then there will be infinite computational capacity at the end of the universe
16:32:56 <dcoutts> ack m n = ack (m-1) (ack m (n-1))
16:33:10 <dcoutts> for the case m/=0 and n/=0
16:33:24 <basti_> o0
16:34:04 <wagle> http://www-users.cs.york.ac.uk/~susan/cyc/a/ackermnn.htm
16:34:46 <dcoutts> so I was wrong, it'd be  ackerman(100,100) = ackerman(99,ackerman(100,99))
16:35:18 <dcoutts> by adding a call to ack in the first argument you make the answer significantly bigger
16:35:21 <wagle> http://home.earthlink.net/~mrob/pub/math/largenum.html
16:35:44 <jlouis> something producing Grahams number would be cool
16:39:10 <wagle> g_64!
16:40:04 <wagle> "The World Champion largest number, listed in the latest Guinness Book of Records, is an upper bound, derived by R. L. Graham, from a problem in a part of combinatorics called Ramsey theory."
16:40:59 <wagle> haha..  g_64 might be an upper bound for "6"
16:41:35 <wagle> we definitely "need" the ^^^^ notation, though
16:42:56 <MachinShin> hey all
16:44:34 <musasabi> hello
16:44:41 <Beelsebob> lo
20:06:22 <dons> @code
20:06:23 <lambdabot> Bits.hs: | otherwise  = x `posOr` y
20:06:29 <dons> @code
20:06:30 <lambdabot> Internals.hs: instance MArray IOArray e IO where
20:08:15 <Gahhh> hey dons
20:08:25 <Gahhh> I feel like a noobie
20:09:34 <dons> hey Gahh. why so?
20:09:55 <Gahhh> the output of the prof is not the peak heap allocation.
20:10:12 <dons> nope, it's total right?
20:10:32 <dons> to get peak allocs you need one of the fancier prof flags
20:10:43 <Gahhh> it's total including the stack alloc, etc.
20:11:09 <Gahhh> yeah it's -hc. And when you use hp2ps you see that heap usage stays at 4M constantly
20:11:19 <dons> yeah. in prof-heap.html
20:11:21 <dons> ah! right.
20:11:30 <dons> so that reveals a space leak?
20:11:38 <Gahhh> it doesn't. there is no leak.
20:11:44 <dons> (i'm assuming you're talking about the 32M code?)
20:12:00 <Gahhh> well, I never got to see the 32M again.
20:12:07 <dons> hmm!1
20:12:15 <dons> even with the IOUArray codeE?
20:12:25 <Gahhh> I have three versions: unboxed/boxed arrays and unboxed/boxed ints. There is no space or performance difference between them.
20:13:16 <Gahhh> I wrote a c version and it is 3x faster than those 3 versions.
20:13:32 <dons> oh ,that's not too bad at all.
20:13:40 <Gahhh> no that is pretty good for ghc imho
20:13:51 <dons> n.b. the FFI version is faster still
20:13:55 <Gahhh> as it should be
20:14:16 <Gahhh> so I moved on to my next target, which is still quite a bit slower than the C version
20:14:39 <dons> 3x C is ok. for some code you can beat C, but that's only 10% of the time, with a lot of profiling.
20:15:03 <Gahhh> I am generating permutations, and it's 10x slower right now.
20:15:21 <dons> still, with what you've learnt, do we have any idea where the 32M alloc was happening?
20:15:46 <Gahhh> That 32M was total, too. Not peak heap. So it could be legitimate.
20:16:03 <dons> hmm.
20:16:18 <Gahhh> Now I have a program that shows 600M total with peak heap at 1.5M, for example.
20:16:32 <dons> ah, ok.
20:16:47 <dons> that's interesting. I ought to do some more sophisticated profiling of Yi.
20:17:14 <dons> so what's your final version?
20:17:17 <Gahhh> now a question: what is the point behind freezing a MArray ? You get a "m (IArray)", so you have to remain in a do block.
20:17:20 <dons> can I have a look?
20:17:22 <Gahhh> sure
20:17:36 <Gahhh> I'll give you all three.
20:18:29 <Gahhh> ugh. how do I transfer the tarball to you  ?
20:19:11 <dons> email  or can you post it somewhere?
20:19:33 <dons> dons <AT>   cse.unsw.edu.au
20:20:23 <Gahhh> aight
20:21:29 <Gahhh> there you go
20:22:25 <dons> got it. cheers.
20:24:22 <dons> which one is the 'official' (== fastest) version?
20:25:23 <Gahhh> they are all pretty much at the same speed
20:27:05 <Gahhh> I'm under the impression that element access to a mutable array has some kinda overhead that dominates the run time.
20:27:47 <Gahhh> writes are more expensive than reads, but they both seem to cost a lot more than a C pointer dereference
20:28:06 <dons> probably the bounds check.
20:28:20 <dons> did you try the unsafe* versions of these ops?
20:28:26 <Gahhh> no
20:28:38 <dons> worth a try, I'd say
20:28:59 <Gahhh> I want to find the fastest safe way first to see how much difference being unsafe makes.
20:29:29 <dons> `unsafe' isn't really unsafe. since we have a side condition that we already know it's in bounds
20:29:42 <dons> the C versions are probably `unsafe' in this sense
20:30:02 <dons> it's just silly to do 1M bounds checks, right?
20:30:02 <Gahhh> yeah the C versions are very unsafe heh.
20:31:15 <Gahhh> so, what good is a conversion from MArray to m (IArray) ?
20:32:22 <dons> do mutable arrays have more operations available? (besides being nice and pure)
20:32:45 <dons> btw, I see you're haskell style is getting better :)
20:32:49 <dons> less ';' hehe
20:33:38 <Gahhh> you mean immutable ?
20:33:53 <dons> still more '{' '}' than I'd write in a  month, though.. :}
20:33:57 <dons> yeah, immutable.
20:35:18 <Gahhh> no, they have fewer actually (no writes), but I am thinking maybe the fact that it's pure may make some optimizations possible.
20:35:23 <Gahhh> or faster read access.
20:35:45 <dons> there's a paper on this, I think
20:35:52 <dons> on the arrays in Haskell
20:41:00 <dons> ok, I knocked a third off the mart2 test
20:41:19 <dons> using unsafeRead and Write, and a couple of INLINES
20:42:00 <dons> old mart2: paprika$ time ./a.out 10000000 1
20:42:01 <dons> ./a.out 10000000 1  0.30s user 0.05s system 99% cpu 0.352 total
20:42:12 <dons> new version: paprika$ time ./a.out 10000000 1
20:42:12 <dons> ./a.out 10000000 1  0.18s user 0.04s system 93% cpu 0.233 total
20:43:07 <dons> actually, just getting rid of redundant bounds checks did it
20:43:52 <Gahhh> inlines ?
20:44:26 <dons> I was wondering whether INLINEing reverseArray would help, but it didn't matter
20:44:33 <dons> anyway, mailed to you
20:44:59 <ozone> dons: hat are you working on?
20:45:01 <ozone> +w
20:45:32 <dons> umm. I think it's one of the language benchmark tests-- Gahhh, yes?
20:46:08 <ozone> ah
20:46:08 <dons> hehe. slows things down when profiling is on..
20:46:54 <ozone> just make sure you compile with -O :)
20:47:09 <ozone> arrays are ungodly slow without -O!
20:47:58 <Gahhh> yeah I am trying to redo fannkuch
20:52:07 <stefanw> ozone: dons is really in his element  :-) unsafe, unboxed, ...
20:53:54 <dons> :D
20:54:14 <ozone> what GHC needs is unsafeDestroyWorld#
20:55:46 <dons> Gahhh, did you get the version I mailed?
20:55:51 <Gahhh> yes
20:56:25 <Gahhh> my brain is mushy right now since I converted MArrays too fast into IArrays heh
20:57:26 <dons> the unsafe version seems much faster. close to 2x faster
20:57:55 <dons> s/unsafe/no redundant bounds checks/
20:58:31 <Gahhh> heh
20:59:10 <dons> just want to keep stefanw happy :)
21:00:20 <dons> "unsafe" doesn't have to mean "reaD[D[D[D[D[D[D[Dlly unsafe"
21:00:37 <dons> silly wireless
21:01:06 <Gahhh> ugh. converting MArrays into Arrays didn't speed up any, although it reclaimed a lot of code back into the pure world.
21:01:35 <Gahhh> conversion means a copy-conversion btw. There is, as usual, an unsafe one as well heh
21:10:25 <dons> hmm. seems much faster using an FFI-allocated chunk of bytes
21:12:21 <Gahhh> Would you like to play with my new objective ? It's still 10x slower at the moment :)
21:12:50 <dons> hmm: paprika$ time ./a.out 10000000 1
21:12:50 <dons> ./a.out 10000000 1  0.07s user 0.02s system 94% cpu 0.091 total
21:13:46 <dons> reverseArray arr size idx
21:13:46 <dons>         | idx *# 2# >=# size  -- bounds check
21:13:46 <dons>         = case idx -# 1#    of { pred     ->
21:13:47 <dons>           case size -# pred of { lowIndex ->
21:13:47 <dons>           case arr `plusPtr` (I# idx)      of { hiIdx ->
21:13:50 <dons>           case arr `plusPtr` (I# lowIndex) of { loIdx -> do
21:13:52 <dons>              highValue <- peek hiIdx :: IO CInt
21:13:55 <dons>              lowValue  <- peek loIdx :: IO CInt
21:13:58 <dons>              poke loIdx highValue
21:14:00 <dons>              poke hiIdx lowValue
21:14:02 <dons>              reverseArray arr size pred
21:14:05 <dons>           }}}}
21:14:07 <dons> :)
21:14:31 <Gahhh> are you sure the #'s really helping ?
21:14:48 <dons> I think the bounds check calculation is.
21:14:59 <dons> but switching to ptr manipulation via the ffi made a big differrence
21:15:13 <Gahhh> and you are *this* close to pure C heh
21:16:00 <lispy> being able to be close to C without the need to do it often is a nice feature of any language ;)
21:16:13 <lispy> C has it's uses....
21:16:23 <dons> hehe
21:16:55 <lispy> does anyone know of a good source from which i can cookup a simple 4th order markov model?
21:17:19 <lispy> there was a paper "Jelinek, 1986" that discusses it, but i can't seem to find that paper
21:20:08 <Pseudonym> http://citeseer.ist.psu.edu/cormack86data.html
21:20:09 <Pseudonym> ?
21:20:16 <Pseudonym> That's arbitrary order, not just 4th.
21:24:30 <lispy> Pseudonym: huh, interesting...
21:25:01 <Pseudonym> Dunno if that was quite what you were after.
21:28:45 <lispy> Pseudonym: i think i'm looking for a tutorial, something like, "Hey here we show you how to create a markov model."
21:29:59 <Pseudonym> Ah.
21:30:00 <Pseudonym> OK.
21:33:00 <dons> Gahhh, ok, so what's the next task?
21:34:06 <Gahhh> well
21:34:17 <Gahhh> I am trying to generate permutations really fast
21:34:19 <Gahhh> failing
21:34:49 <Pseudonym> At the risk of stating the obvious, no algorithm with factorial complexity is going to be fast.
21:35:18 <Gahhh> I am failing to make it close to 1/3 of C speed
21:37:26 <dons> approaching C is a worthy goal.
21:37:55 <Pseudonym> How are you comparing them?
21:38:01 <Pseudonym> By printing them out and diffing?
21:38:59 <Gahhh> execution time.
21:39:12 <Pseudonym> What does the program do with the permutations?
21:39:14 <Pseudonym> Print them out?
21:39:46 <Gahhh> nothing at the moment. It's a subpart of my rewrite of fannkuch benchmark. It's array based.
21:39:55 <Pseudonym> Ah, OK.
21:40:08 <Pseudonym> If it printed them out, I'd be tempted to say that it's I/O which is the problem.
21:40:25 <Gahhh> a la wc ?
21:41:56 <dons> I don't think we've reached I/O yet :)
21:42:11 <dons> at least I haven't.
21:42:16 <Gahhh> wow I supremely suck
21:42:30 <Gahhh> the pure version beats my array version
21:42:45 <dons> no, you don't suck, ghc is just good :)
21:42:49 <Pseudonym> There you go.
21:42:57 <Pseudonym> Knuth was right.
21:43:11 <dons> what did Knuth say on this matter?
21:43:43 <Gahhh> well, I attribute the current situation to my noobness than to Knuth's wisdom at the moment.
21:44:11 <Pseudonym> Premature optimisation.
21:44:44 <dons> ah, right. not complexity dominating whatever you can hack.
21:44:52 <dons> or, sort of.
21:44:57 <Pseudonym> Right, or something.
21:45:03 <lispy> heh
21:45:14 <lispy> this conversation maybe vague, or not
21:45:27 <Gahhh> am I correct in thinking that taking the length of the list of permutations is sufficient to have them all computed ?
21:45:45 <dons> or not, or something and D[Dor
21:45:50 <dons> damn wireless
21:46:00 <Gahhh> wow.
21:46:06 <dons> chopping up my control chars
21:46:15 <Gahhh> how could that be
21:46:26 <Pseudonym> Clouded, this conversation's future is.
21:46:37 <Pseudonym> Yoda am I not.
21:47:05 <Pseudonym> Gahhh: No.
21:47:17 <Pseudonym> Length evaluates the spine of a list, but not the elements.
21:47:33 <Pseudonym> @plugs length (take 10 (repeat bottom))
21:47:38 <lambdabot> Variable not in scope: `bottom'
21:47:51 <Pseudonym> @plugs length (take 10 (repeat undefined))
21:47:53 <lambdabot> 10
21:48:01 <lispy> man, i was trying to type that i was sympathetic with dons since i have often lost my wireless connection when talking to people and guess what happened?
21:48:10 * Pseudonym laughs
21:48:40 <Gahhh> that sounds right. because my array based fannkuch beats the pure version. It wouldnt make sense for it to hugely outperform just in the permutation generation part.
21:48:46 <lispy> thank god for screen....
21:48:57 <dons>  @plugs == @eval these days.
21:49:10 <lispy> it does?
21:49:14 <lispy> when didyou change that?
21:49:18 <dons> one day @eval will be taken by the dark side, and see it not you will
21:49:26 <dons> sorry, @plugs will go.
21:49:27 <lispy> @evil 1+2
21:49:28 <Gahhh> @eval 1_1
21:49:29 <lambdabot> 3
21:49:29 <lambdabot> Variable not in scope: `_1'
21:49:46 <dons> if you want lambda cal, use @lambda
21:49:47 <Gahhh> he would have won anyways. I picked my args wrong.
21:49:48 <lispy> i like that evil gets substituted for eval
21:49:49 <dons> for haskell, use @eval
21:50:58 <dons> at least I don't have to pay for bytes I send that get lost in the air
21:53:22 <lispy> @eval exec "rm -rf"
21:53:24 <lambdabot> Variable not in scope: `exec'
21:53:36 <Gahhh> what if that did work lol
21:54:00 <lispy> heh, well i didn't give a path, so it would have errored ;)
21:54:03 <Gahhh> @eval (begin (display "hello, world"))
21:54:04 <lambdabot> Variable not in scope: `begin'
21:55:19 <lispy> @eval putStrLn "Hello, world!"
21:55:21 <lambdabot> No IO allowed
21:55:35 <lispy> lambdabot: ah, c'mon just a little?
21:55:57 <Pseudonym> @eval readFile "/etc/passwd"
21:55:59 <lambdabot> No IO allowed
21:56:21 <Gahhh> how about just I ?
21:56:33 <Pseudonym> @eval system "/tmp/haxor-dons-machine"
21:56:34 <lambdabot> Variable not in scope: `system'
21:56:49 <SamB> I once had lambdabot read /etc/passwd, but it was someone elses exploit. I just wanted to make sure it was genuine ;-)
21:57:04 <SamB> I think it involved TH...
21:57:13 <dons> and much fun was had by all :)0
21:57:18 <Pseudonym> Indeed!
21:57:38 <SamB> of course, I wouldn't have done that if I wasn't confident that the system used shadow passwords ;-)
21:58:18 <dons> of course
21:58:33 <Pseudonym> Mind you, reading /etc/password would be a quick way to find out.
21:59:16 <dons> well, OpenBSD is a little differrent, so not quite so easy
22:00:36 <SamB> dons: what do you mean by that?
22:01:25 <SamB> isn't the definition of shadow passwords that the passwords aren't in /etc/passwd?
22:01:33 <dons> oh, I was assuming thhere is some kind of "/etc/password" (not `passwd') on linux, but then I reliased that's probably a typo, and worked out what P'nym actually meant.
22:02:55 <dons> in which case,  yes, reading /etc/passwd is a good way to find out if passwds are there or not
22:04:33 <Pseudonym> RIght.
22:05:14 <Pseudonym> I have a strong reflex to spell words correctly, which often puts me at odd with Unix.
22:05:23 <Pseudonym> odds
22:05:27 <Gahhh> lol
22:05:41 <Pseudonym> That would have been less funny if there wasn't a typo in it, I think.
22:06:24 <dons> hehe
22:07:05 <dons> so when reading Pseudonym statements, perform alpha-equivalence on identifiers up to spell-correctness to find out what he means.
22:08:12 <Pseudonym> My statements are correct, up to spelling isomorphism.
22:08:41 <dons> quite so.
22:09:35 <Gahhh> I thought it was a gesture towards Unix machines that he could in fact misspell intentionally, like an olive branch.
22:10:48 <Pseudonym> I find it difficult to creat such sentences.
22:11:01 * SamB read /etc/password as /etc/passwd ;-)
22:11:08 <SamB> heh
22:11:43 <Gahhh> if I think one more minute about haskell today I will grow a monad...
22:11:55 <dons> what out!
22:11:57 <SamB> umount is annoying. especially when you play with plan9 and have to switch between umount and unmount...
22:12:17 <Pseudonym> You need to learn to uremember it when appropriate.
22:13:11 <Pseudonym> Or learn to context swtch more effectively.
22:13:44 <SamB> now this is getting jst pln rdcls
22:16:11 <dons> @elite  This is just plain ridiculous
22:16:12 <lambdabot> t|-|I5 i$ ju5T P|AIN RiDi(ulOU5
22:17:31 <SamB> that is actually rather fancy ridiculous...
22:18:26 <Pseudonym> Actually, someone should make a unix plugin.
22:20:10 <SamB> unix is too unpredictable!
