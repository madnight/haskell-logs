00:10:33 <Itkovian_> tralalala
00:24:03 <lamnet> er
00:45:41 <dons> @code
00:45:41 <lambdabot> Internals.hs: foreign import ccall unsafe "HsBase.h __hscore_stat"
00:50:33 <dons> as suggested yesterdday: @eval -> @lambda, and @plugs -> @eval
00:50:49 <dons> @eval sort "eval is the new eval"
00:50:50 <lambdabot> "    aaeeeehillnstvvw"
00:51:11 <dons> @eval map Char.toUpper "long live @eval"
00:51:13 <lambdabot> "LONG LIVE @EVAL"
00:51:26 <dons> @lambda Y I
00:51:53 <lambdabot> out of fuel - use @resume to continue
00:51:56 <dons> my poor machine gets its head kicked yet again
00:52:48 <seafood> @quote lambdabot
00:52:49 <lambdabot>  lambdabot hasn't said anything memorable
00:53:18 * ski wonders what plugs stand for/means ..
00:55:52 <dons> hehe, this:
00:55:55 <dons> paprika$ ./plugs
00:55:55 <dons>            __
00:55:55 <dons>     ____  / /_  ______ ______
00:55:55 <dons>    / __ \/ / / / / __ `/ ___/     PLugin User's GHCi System, for Haskell 98
00:55:55 <dons>   / /_/ / / /_/ / /_/ (__  )      http://www.cse.unsw.edu.au/~dons/hs-plugins
00:55:57 <dons>  / .___/_/\__,_/\__, /____/       Type :? for help
00:56:00 <dons> /_/            /____/
00:56:03 <dons> Loading package base ... linking ... done
00:56:05 <dons> plugs> 1 + 2
00:56:07 <dons> 3
00:56:14 <dons> comes with hs-plugins, and used to implement @plugs
00:58:21 <ski> ic
00:59:06 <dons> :)
01:13:06 <earthy>  eval now evaluates haskell snippets? cool!
01:14:52 <dons> well, eval is now an alias for plugs, which has been evaluating haskell snippets for several months ;)
01:15:20 <dons> more importantly, the old lamdbda calc Eval is now @lambda, leading to less confusion hopefully
01:15:39 <vegai> how did eval work in the past, or didn't it?
01:15:39 <earthy> owh, I knew about plugs
01:15:43 <Heffalum1> cool
01:15:50 <vegai> oh, like that
01:18:30 <qpt|away> Hey
01:18:33 <qpt|away> I'm looking for Tirel.
01:18:38 <qpt|away> Tirel, why did you break our date tonight?
01:19:20 <dons> @seen Tirel
01:19:21 <lambdabot> I haven't seen Tirel.
01:19:29 <dons> wrong channel
01:19:30 <qpt|away> err its his name, not his nick
01:19:39 <qpt|away> he said he'd go out with me, my first real gay date
01:19:45 <dons> wrong channel x 2
01:19:45 <qpt|away> but he didn't show up
01:19:48 <qpt|away> and i'm pretty damn mad
01:20:15 <Itkovian> erm ...
01:20:18 <Itkovian> no comment
01:20:53 <Itkovian> hehe
01:21:07 * Itkovian refrains from making stupid comments
01:21:16 <qpt|away> smoot: are you there?
01:21:18 <qpt|away> smoot: answer me
01:21:28 <Itkovian> hi honey
01:21:31 <Itkovian> erm
01:21:39 <smoot_> hi honey
01:21:40 <smoot_> lol
01:21:49 <Itkovian> duh
01:21:56 <Itkovian> @seen smoot
01:21:58 <lambdabot> smoot is in #haskell. I don't know when smoot last spoke.
01:21:58 <vegai> that's not very good refraining :)
01:22:09 <Itkovian> yeah well, my hands have a will of their own
01:22:17 <qpt|away> smoot why did you break our date
01:22:22 <qpt|away> are you trying to make me go straight again, fag?
01:22:39 <Itkovian> erm, ignore that, it may lead you to not very erm, nice images
01:22:48 <vegai> !
01:22:48 <Itkovian> heh, smoot is running away from you it seems
01:23:04 <vegai> and perhaps never coming back with the same nick :P
01:23:06 <kosmikus> morning
01:23:16 <qpt|away> ...
01:23:20 <smoot> qpt|away: no, no, queer is good
01:23:55 <smoot> besides girls suck
01:23:59 <smoot> so do we
01:24:05 <Itkovian> aaaergh
01:24:08 <Itkovian> somebody stop me
01:24:49 <ski> Itkovian : maybe someone could ban you for a while ?
01:25:13 <qpt|away> hahaha
01:25:15 <qpt|away> that would be nice
01:25:24 <Itkovian> ski yeah sure
01:25:51 * Itkovian never realised this was a dating channel
01:26:42 <Heffalump> "Good programmer seeks pure and unspoiled programming language"
01:27:16 <Itkovian> for a curried relationship
01:28:46 * Itkovian just opened his mom's computer
01:28:51 * Itkovian is scared to death
01:29:12 <ski> unsafePerformIO takes on a different meaning
01:29:12 <Itkovian> when I turn it on, it says 'this is an emergency, we have a problem'. lol
01:29:14 <vegai> Itkovian: another gay joke coming?
01:29:20 <vegai> oh
01:29:22 <Itkovian> no ...
01:30:54 <Itkovian> the bloody thing is just so messed up. capacitors leaking juice on the mobo, the fan full of tar (my mom smokes), ... I hope the disk can be salvaged
01:32:45 * Itkovian is listening to the suicidegirls radio
01:32:56 <Itkovian> rotflmao
01:46:55 <juhp>  /topic: parse error missing "
01:46:58 <juhp> ;-)
01:47:08 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueFour","ICFP Contest! http://icfpc.plt-scheme.org/"]' by juhp
01:54:25 <jyp> lambdabot should manage the topic :)
01:58:31 <dons> @topic-tell #haskell
01:58:32 <lambdabot> ["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","
01:58:32 <lambdabot> http://www.haskell.org/learning.html","http://www.haskell.org/ghc/
01:58:32 <lambdabot> survey/start.cgi","http://www.haskell.org/tmrwiki/IssueFour","ICFP
01:58:32 <lambdabot> Contest! http://icfpc.plt-scheme.org/"]
01:58:35 <dons> cheers
02:09:16 <Itkovian> still so long to wait for the icfp results ...
02:11:20 <jyp> dons: ah cool
03:11:41 <TheHunter> does lex ever return multiple results?
03:17:32 <tromp> of course
03:18:03 <TheHunter> do you have an example?
03:18:03 <tromp> since you can implement you own
03:18:24 <TheHunter> @type lex
03:18:31 <lambdabot> ReadS String
03:19:33 <TheHunter> @type \(x :: forall m. Monad m => m a) -> ("a(((bc") `seq` ')' `seq` Control.Monad.liftM2 (,) x (Control.Monad.Trans.lift x)
03:19:34 <tromp> oh, wait. it's not part of ReadS...
03:19:34 <thbot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *).
03:19:34 <thbot> (Control.Monad.Trans.MonadTrans t, Monad m, Monad (t m)) =>
03:19:34 <thbot> (forall (m1 :: * -> *). (Monad m1) => m1 a) -> t m (a, a)
03:19:35 <lambdabot> forall m. Monad m => m a) -> ("a(((bc") `seq` ')' `seq` Control.
03:19:35 <lambdabot> Monad.liftM2 (,) x (Control.Monad.Trans.lift x) :: forall a
03:19:35 <lambdabot>                                            (t :: (*
03:19:35 <lambdabot>                                               -> *)
03:19:35 <lambdabot>                                              -> *
03:19:37 <lambdabot>                                               -> *)
03:19:37 <Heffalump> I can't think of any examples of the built-in types doing so
03:19:39 <lambdabot>                                            (m :: *
03:19:40 <lambdabot> [11 @more lines]
03:19:44 <Heffalump> or of a derived Read instance causing it
03:20:17 <TheHunter> ok, thanks. I need it to parse ghci output, so it should be valid haskell anyway.
03:20:33 <earthy> guys, we've got  a paste page
03:20:44 <ndm> TheHunter: In my experience, write your own lexer
03:20:59 <ndm> i have used nhc, ghc and hugs - all their lex's return different results
03:21:10 <ndm> particularly with # as an identifier name
03:21:19 <ndm> but also their treatment of other things is different
03:21:53 <ndm> http://www-users.cs.york.ac.uk/~ndm/darcs/hoogle/hi2hoo/Main.hs
03:21:56 <TheHunter> thbot, @type \(x :: (# Int, Int #)) -> undefined x
03:21:57 <thbot> bzzt
03:22:05 <ndm> lexRaw in that file is what i have used to do lexing
03:23:32 <TheHunter> ndm, thanks, i'll test a bit but i think ghc's lex should do. It needn't be too fancy.
03:24:20 <ndm> the problem isn't fancy, the problem is reliable behaviour under many implementations (the one i linked to is certianly slower and simpler)
03:24:24 <TheHunter> earthy, i didn't really expect anyone to say something while the bots spit out their answers. Using a paste page seemed to complicated.
03:24:56 <TheHunter> well, lambdabot won't compile under anything except ghc (probably even ghc-6.4), so that's not really an issue.
03:26:03 <ndm> ah well, shame that its so compiler specific though - i'm a fan of cross-haskell compiling
03:28:40 * TheHunter only uses ghc.
03:28:58 <TheHunter> anyway, i think @type works fine now, feel free to test thbot
03:31:24 <ski> hm, lambdabot seemed confused ..
03:32:37 <TheHunter> lambdabot breaks at the first " :: "
03:33:28 <ski> aha
03:34:35 <TheHunter> thbot lexes a bit and skips things in parens, and takes first "top-level" " :: ".
03:40:43 <frederik> ndm: what compilers do you use?
04:38:52 <frederik> la di da
04:42:22 <shapr> well la di da
04:43:11 <lambdabot> la di da di da!
04:47:27 <frederik> i'll take that as "ghc"
05:05:27 <shapr> f
05:05:33 <shapr> oops, wrong window
05:06:48 <Muad_Dibber> .. :P
05:52:00 <Igloo> JaffaCake: Are there any ghc-as-a-package docs anywhere?
05:55:19 <dons> Igloo, I have some mail on this topic I can forward to you
05:55:37 <Igloo> Yes please!
05:55:38 <dons> there's just a build.mk flag to set, and then you get ghc -package inplace, iirc
05:56:05 <Igloo> Oh, my ghc-cvs already has the actual whatsit
05:56:16 <Igloo> I was talking about docs on how to use it
05:56:26 <dons> oh! no docs, then.
05:56:37 <Igloo> OK  :-)  Thanks
05:57:09 <dons> I have some hints from Simon, and then there's been some recent stuff on GHC.hs on the mailing list
05:58:34 <dons> actually, I have (which seems now out of date):
05:58:35 <dons> but for now it's up to you to use existing interfaces in GHC.  In
05:58:35 <dons> order to use the frontend, you probably want to duplicate some of the
05:58:35 <dons> setup code from Main.hs (call initSysTools and read the package
05:58:35 <dons> configurataion, set up an empty HscEnv).
05:58:55 <dons> I think some of this is taken care of by GHC.hs these days
06:51:12 <SM_ax> Hmm... Why do I get  Kind error: `Reader e' is not applied to enough type arguments In the instance declaration for `MonadReader (Reader e)'"
06:51:28 <SM_ax> when trying to compile code for Reader in hawiki?
06:53:07 <JaffaCake> Igloo: sorry, no GHC as a package docs yet
06:54:24 <JaffaCake> the best reference is GHC's Main.hs and InteractiveUI.hs
06:56:51 <Igloo> OK, thanks
07:03:44 <TheHunter> SM_ax, fixed, i hope.
07:04:43 <Mon4345> if i have a record with functions, can they be mutual recursive?
07:05:09 <Mon4345> and if so, how do i reference a function in that record from within that record (when defining the other function)
07:05:21 <SM_ax> TheHunter, thanks
07:05:42 <tromp> you can define mutually recursive functions anywhere
07:05:55 <tromp> and then make a record containing them
07:06:02 <SM_ax> however, some other issues arose... ah, another time...
07:06:05 <Mon4345> but how would it work in the setting im describing
07:06:26 <Mon4345> M{bla=..., foo=bla} obviously doesnt work
07:06:46 <tromp> let bla=...; foo=... in  M{bla,foo}
07:07:22 <Mon4345> ah lift them out of the record
07:07:25 <Mon4345> that might work
07:07:33 <Mon4345> thanks, i'll try it
07:08:21 <liyang> On the topic of records... does anyone use BNFC?
07:09:13 <ndm> frederik: I use nhc, Hugs, ghc
07:11:08 <Mon4345> @pl \a b -> f a b
07:11:10 <lambdabot> f
07:11:14 <Mon4345> :D
07:11:30 <Mon4345> that calls for a coffeebreak
07:12:59 <Mon4345> @pl g . (\a b -> id) a $ b
07:13:00 <lambdabot> g id
07:13:17 <Mon4345> @pl \a b -> g . (\a b -> id) a $ b
07:13:18 <lambdabot> (g .) . const (const id)
07:24:04 <esap> Why do you think there are so few proven lower bounds on algorithmic complexity?
07:26:09 * esap phrases questions in unintelligible format :-(
07:30:15 <jyp> coz people care about upper bounds ?
07:30:54 <esap> Well, some people do :-)
07:32:05 <esap> I suppose for algorithms upper bounds are pretty important issue.
07:32:43 <frederik> why do you think there are few proven lower bounds?
07:32:59 <bbls> hello
07:33:10 <esap> frederik: It says so in http://www.claymath.org/millennium/P_vs_NP/Official_Problem_Description.pdf :-)
07:33:40 <bbls> i'd like to store a lisp-like pure functional language using curried functions/operators only
07:33:56 <bbls> anyone knows any already existing work?
07:36:25 <frederik> esap: well you can just give an algorithm to prove an upper bound. lower bounds require you to talk about all possible algorithms
07:36:36 <esap> frederik: It says, in particular: "However, all attempts to find even super-linear lower bounds for unrestricted Boolean circuits for "explicitly given" Boolean functions have met with total failure; The best such lower bound proved so far is about 4n"
07:37:25 <esap> frederik: But talking about all possible algorithms is not at all hard.
07:42:02 <esap> frederik: Here's a way to consider properties of arbitrary algorithms: First you choose a platform in which the algorithms must be implemented in. Then prove that all algorithms written on top of that platform have some particular properties.
07:43:13 <genneth> bbls: I'm not sure what you mean
07:43:59 <bbls> genneth it's possible to create a pure functional programming language where all functions are unary?
07:44:12 <esap> frederik: Then you can vary the platform to expand the scope of your results.
07:47:02 <frederik> emap: whatever. it's harder than giving a specific algorithm
07:48:09 <esap> frederik: Well I would say it just needs different methods. It's not necessarily harder, it's just different.
07:49:34 <tomdavie> ugh... it's too bloody hot
07:50:25 * esap agrees it's hot, 30 degrees C inside.
07:50:37 <tomdavie> fairly similar to here
07:50:57 <tomdavie> on the plus side... I have a frozen bottle of water
07:51:15 * esap has fruit juice and cola.
07:53:16 * jyp has sweat
07:53:40 <tomdavie> mmm... sweat
07:53:57 <genneth> bbls: yes, i believe so
07:54:04 <genneth> bbls: isn't haskell an example already?
07:55:40 <bbls> all haskell functions are unary?
07:55:53 <autrijus> some are nullary
07:56:13 <bbls> nullary?
07:56:18 <autrijus> takes no arguments.
07:56:27 <thedward> what two functions can you compose to get (+) ?
07:56:30 <bbls> ah, some constant functions
07:56:31 <bbls> ?
07:56:33 <tomdavie> they're CAFs not functions
07:56:41 <autrijus> what is main then.
07:56:51 <esap> main is a value.
07:56:55 <tomdavie> it's a constant
07:57:14 <Philippa> it's an IO computation which is a value which is not a function
07:57:29 <autrijus> oh. by "function" you mean types constructed with (->)
07:57:29 <genneth> main can be seen to throw away the first argument?
07:57:37 <tomdavie> yes...
07:57:40 <autrijus> then sure, it's all of the (a -> b) flavour.
07:57:49 <tomdavie> that's why that's called the function type :/
07:58:15 <autrijus> right. I guess main is more properly a "computation" or an "action".
07:58:22 <autrijus> sorry for the confusion.
07:58:50 <genneth> but for bbls' point; haskell can be seen to be a pure language containing only unary function?
07:59:01 <Philippa> yes
07:59:09 <autrijus> unary functions and values.
07:59:14 <Philippa> oops, yeah
07:59:15 <genneth> good; i'm not going mad then :D
07:59:16 <autrijus> we're not using church numerals.
07:59:32 * esap uses church numerals sometimes.
07:59:39 <Philippa> type-level ones?
07:59:44 <autrijus> okay, but 1 is not a church numeral :)
07:59:54 <autrijus> @type 1
08:00:00 <lambdabot> forall t. (Num t) => t
08:00:08 <autrijus> look, no -> in sight
08:00:29 <esap> philippa: sometimes. But I think more often at term level.
08:00:48 <genneth> @type const 1
08:00:50 <lambdabot> forall a b. (Num a) => b -> a
08:01:22 <Philippa> yeah, but const isn't id
08:01:39 <esap> but of course, Haskell numbers are not church numerals (fortunately, those would be hopelessly slow)
08:01:56 <autrijus> I guess it'd be possible to replace all values with their 'const' variant and all functions with higher order ones
08:02:10 <genneth> uhuh
08:02:14 <autrijus> and then claim that there's only unary functions in existence
08:02:31 <genneth> since we're all using monads anyway.... aren't everything higher order? *evil grin*
08:02:51 <ski> omega order ?
08:03:04 <autrijus> actually oftentimes I'm not using monads :)
08:03:33 * genneth clasps his ears to shut out the heathens
08:03:35 <Philippa> yeah, surprisingly enough me either
08:03:58 <jyp> monads are evil, after all
08:04:00 <Philippa> genneth: I think you'll find autrijus and I're most people's idea of "heavy/serious users of monads" :-)
08:04:15 <genneth> maybe everyone else knows some other great language for writing IO heavy programs....
08:04:32 <Philippa> maybe we're not always doing IO-heavy algorithm-light stuff?
08:05:04 <genneth> :p
08:05:20 * genneth likes pain
08:05:43 <autrijus> there's a reason that evil mangler is not written in painful haskell :)
08:05:44 * esap is designing a language (that would not be good for IO-heavy programs :-)
08:05:57 <Philippa> there're also folks in here who'd suggest I'm not the best person in here to tell you like pain ;-)
08:06:31 <bbls> esap what kind of programming language?
08:07:29 <esap> bbls: something based on category theory. Rather like Haskell :-)
08:08:11 <Philippa> esap: what kind of basis? I've kicked around a few ideas before
08:08:30 <genneth> autrijus: does the evil mangler still exist? i thought it was kicked out at some point?
08:08:33 <esap> Phillppa: Well for a start, I'm planning on implementing the Cat category.
08:09:08 <autrijus> genneth: last I checked GHC 6.5 still depends on perl.
08:09:12 <Philippa> heh. I sort-of had some call for that
08:09:34 <autrijus> not sure if it's for the mangler though
08:09:38 <genneth> autrijus: ouch; nuff said
08:09:45 <autrijus> but likely so
08:11:01 <autrijus> pugs will still depends on ghc for quite a long time. I wonder if ghc will still depend on perl5 by the time we finish bootstrap perl6 :)
08:11:13 <esap> philippa: I think that's not very easy, Cat is pretty complex [I'm not sure it's possible to implement it fully]
08:11:57 <Philippa> hence sort-of, it's probably not Cat itself I was looking at (and my category theory is way too damn hazy and the inspiration via programmer-oriented interpretations - I'd come via the 'generalising arrows further' path)
08:13:22 <ski> Cat as a 2Category ?
08:13:41 <esap> philippa: Well arrows are just one small part of it. I think the basic stuff is just objects, arrows, commuting diagrams, categories, functors, natural transformations, adjunctions, isomorphisms. Then extend that.
08:14:03 <esap> ski: yes.
08:14:57 <esap> philippa: oh actually, you also need modules.
08:14:59 <autrijus> esap: does your language have a name yet?
08:15:22 <esap> autrijus: No, I've been thinking of a good name for several years now with no success...
08:15:44 <autrijus> The Meow Language -- Because Cat Rocks
08:15:53 * esap laughs.
08:16:46 <ski> several *years* .. ?!?
08:16:56 * ski looks weird at esap
08:16:57 * esap has been doing this compiler for several years.
08:17:09 <ski> :)
08:18:07 * esap has code in the current codebase that was last changed in 2001.
08:18:25 <esap> ah actually even earlier, in 1999.
08:18:32 <ski> esap : it would be nice to have a lang where one e.g. can specify that one in some subsection uses the category Monoid, and so you get for free that the morphisms is real monoid homomorphisms, etc ..
08:19:21 <Leadhyena> hi!
08:19:31 <esap> ski: I'm planning on implementing user-defined categories, so I suppose that would do it.
08:19:44 <ski> esap : thinking along lines of defining e.g. morphisms from initial monoids via pattern-matching (e.g. folds)
08:19:51 <ski> hello Leadhyena
08:20:13 <Leadhyena> have a question for whomever can answer it
08:20:34 <ski> esap : so, one should get for free that it doesn't matter which defining equation one uses, because they should yield same result
08:20:46 <ski> Leadhyena : just state it
08:20:49 <Leadhyena> how do I do a list of instances of a class?
08:21:15 <esap> ski: yea, via isomorphisms of categories, perhaps.
08:21:39 <Leadhyena> example: I have a class Nameable, which has a getName and setName function assigned to it
08:21:46 <ski> do you want to have a list of things whose types all are instances of some class, but you don't want all those types to be necessarily the same type (just instances of the class) ?
08:21:55 <Philippa> oops, was looking elsewhere
08:21:58 <Leadhyena> correct
08:21:58 <Philippa> esap: wrong arrow :-)
08:22:01 <esap> ski: Of course, proving the isomorphisms may not always be easy. I'm actually currently having some trouble proving equivalence of categories.
08:22:43 <ski> data SomeNamable = forall a. Namable => MkNamable a
08:23:03 <Leadhyena> oh. wow.
08:23:25 <ski> you can also instance this type in class Namable, to not always have to use the constructor MkNamable
08:23:32 <ski> note you can't do like
08:23:35 <ski> [x,y]
08:23:39 <ski> but instead
08:23:47 <ski> [MkNamable x,MkNamable y]
08:23:53 <Leadhyena> right
08:24:11 <ski> (except if one of those are already of type SomeNamable, of course)
08:24:12 <Leadhyena> specifically I was looking at an inventory function for players in a text adventure
08:24:35 <esap> existentially quantified types are actually pretty hard to use. I've got all kinds of trouble trying to use pattern matching on existentially quantified data types.
08:24:39 <Leadhyena> and had a Possessable class... this'd do the trick I think
08:24:53 <Leadhyena> thanks!
08:24:59 <ski> if wonder, this feature (which is extension of Haskell98) is called "existential data type"
08:25:46 <ski> esap : hm, what kinda trouble ?
08:26:11 <esap> ski: Well then you need to prove what is the actual type, and that can be hard.
08:26:21 <ski> esap : pattern-matching should get you things of types mentioning unknown type, yes
08:26:26 <ski> ah, conversions
08:27:04 <esap> ski: Like I want to compare two objects inside two different existantial packages for equality.
08:27:19 <ski> think there was some paper that showed a way to do this with leibniz equality (but haven't tested much with it, so don't know possible problems/restrictions/etc ..)
08:27:32 <esap> ski: url?
08:27:37 <ski> hm
08:27:56 <ski> i don't even remember the name of the paper, rn
08:28:03 <ski> lemme see if i can find it
08:30:39 <Speck> Anyone know of a good hsakell blog or three?
08:30:47 <CosmicRay> Speck: check out sequence.complete.org
08:30:53 <Speck> I know of shapr's blog and sequence, but they aren't updated frequently enough for me
08:31:15 <CosmicRay> Speck: several people maintain blogs on sequence.  I don't know of anybody that blogs about haskell every day
08:31:22 <CosmicRay> well, that blogs solely about haskell
08:31:26 <Speck> yeah
08:31:36 <Speck> I have signed up to sequence, but I haven't written anything yet
08:32:03 <Speck> I came to haskell from the ruby world, where everyone is blogging all the time and I've picked up a lot of tips and tricks that way.
08:32:25 <CosmicRay> the haskell mailing lists are quite active
08:32:31 <CosmicRay> cafe is probably the best one
08:32:43 <CosmicRay> I do blog about haskell periodically
08:32:55 <Speck> ah, I'm in haskell@haskell.org, but it's pretty quiet
08:33:07 <CosmicRay> yeah, try the cafe
08:33:24 <CosmicRay> this link will get you my haskell posts: http://changelog.complete.org/taxonomy/term/20/9/
08:34:01 <Speck> Ah! I've read your blog.
08:34:02 <Cale> I'm on Haskell, Cafe, and Libraries, and have enough trouble keeping up with it :)
08:34:40 <JaffaCake> dons: you there?
08:34:53 <ski> esap : this one i think http://www.cs.uu.nl/people/arthurb/dynamic.html   (found this first, which seems to have some comments on previous one http://www.cs.bu.edu/~hwxi/academic/papers/CutElim/CutElim.pdf)
08:34:56 <CosmicRay> Cale: same here.  I don't even have time to read most threads
08:35:13 <CosmicRay> Speck: do you by any chance know python?
08:36:23 <Speck> I never learned python because I already knew ruby.
08:36:38 <CosmicRay> Speck: bummer.  I never learned ruby because I already knew python.
08:36:43 <esap> ski: thanks for the link.
08:36:46 <CosmicRay> Speck: I was going to see if you could compare the two for me :-)
08:36:50 <Speck> ruby is my dynamic language, the fps are my typed.
08:37:03 <CosmicRay> Speck: anyway, is there anything about haskell we can help you with?
08:37:09 <CosmicRay> "fps"?
08:37:16 <Speck> functional programming languages
08:37:19 <CosmicRay> ah
08:37:20 <CosmicRay> interesting
08:37:21 <Speck> haskell and ocaml specifically
08:37:25 <CosmicRay> haskell is both to me
08:37:35 <CosmicRay> even more interesting, I took a Python -> Ocaml -> Haskell path myself
08:37:36 <Speck> I can't do typed programming without inference
08:37:52 <CosmicRay> when I found haskell, it basically was everything I wished ocaml was, so I ditched ocaml
08:38:13 <Philippa> C++->[taught but hated]Java->taught Haskell->using Haskell in anger
08:38:20 <Speck> I've mostly ditched ocaml too, but every once and a while I need the performance and I don't know haskell well enough to get it.
08:38:20 <CosmicRay> heh
08:38:29 <CosmicRay> yeah I can understand that
08:38:36 <Cale> http://poignantguide.net/ruby/ is a fun guide to Ruby that I read not too long ago
08:38:50 <Cale> (after it was posted here, coincidentally)
08:39:08 <Speck> redhanded.hobix.com (the blog of the author of the poignant guide) is one of my regular reads
08:39:21 <CosmicRay> Speck: you'll find that we're a fairly open-minded bunch 'round here.  except when it comes to java. :-)
08:39:35 <Philippa> I'd love a strict-by-default haskell
08:39:50 * Oejet loves Java
08:39:59 <Speck> I find laziness to be more intuitive
08:40:03 * CosmicRay backs slowly away from oejet
08:40:31 * Oejet looks at CosmicRay with burning eyes.
08:40:49 <CosmicRay> Speck: btw, if you ever want a laugh, check out http://www.haskell.org/hawiki/MegaMonad
08:41:05 <CosmicRay> Oejet: Ha!  I forgot to cast from fire to eyes!  RuntimeException!
08:41:09 <CosmicRay> s/I/you/
08:41:33 <Philippa> Speck: that's not why I want the strictness
08:42:33 <Speck> Philippa, but its appealing to my intuition is why I use haskell in the first place
08:42:45 <Oejet> It is said that Java doesn't have real pointers; why then do I get null pointer exceptions all the time? (Retorical question of course.)
08:42:55 <CosmicRay> :-)
08:43:29 * Oejet was kickbanned from #java once.
08:43:29 <ski> NullObjectReferenceException ?
08:43:47 <CosmicRay> BadChoiceOfLanguageException, really.
08:43:50 <Philippa> Speck: understandable, I'd certainly not want to throw laziness away entireles
08:43:52 <Philippa> *entirely
08:43:57 <Philippa> geez, nice thinko there...
08:44:09 <CosmicRay> I think pervasive laziness is a nice property
08:44:12 <CosmicRay> ocaml has laziness in streams
08:44:22 <CosmicRay> but having it be separate from lists and everything else makes it annoying to work with
08:45:00 <ski> it's not transparent
08:45:05 <genneth> well then; the solution is simple; we just have to figure out how to combine lazy with eager; i expect we'll be done by lunch
08:45:21 <CosmicRay> heh
08:45:25 <Speck> Philippa, I believe it was you who was talking about metamorphic programming in haskell a while back. I read the paper (as well as I could understand it), and I found it very interesting.
08:45:32 <Philippa> CosmicRay: I'd want it potentially-pervasive - annotated the same way you annotate strictness now
08:46:23 * ski at times imagines a lang with lazy record/coalgebraic types and strict variant/algebraic types
08:47:45 * genneth scared himself the other way thinking about generating C++ templates with haskell
08:47:47 <ski> preferably with referential transparency and continuations and linearity/uniquness ;)
08:47:56 <jyp> Ain't there a language from Chalmers like that ?
08:48:00 <genneth> something about haskell makes a person not scared to metaprogam
08:48:01 <jyp> Purity or somesuch
08:48:24 <ski> not that i recall
08:48:33 <ski> Charity ?
08:48:52 <vegai> genneth: or too scared to program ..
08:49:55 <jyp> ski: yup that's what I had in mind
08:50:13 <jyp> I read about it long time ago
08:50:29 <ski> ok (not from Chalmers), Charity is interesting. (but seems not much happens recently)
08:50:35 <Speck> Is Epigram comperable to Charity?
08:50:43 <Speck> i.e., categorically based
08:50:49 <ski> not directly i think
08:51:02 <ski> Epigram is more dependent-types based, i think
08:51:14 <Philippa> yeah, that's exactly what Epigram's about
08:51:49 <lispy> so i read about attribute grammars, and frankly, the attribute grammar solutions look much harder to understand.  http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
08:51:51 <ski> (models of dependent-types is pretty complex, too iirc :)
08:52:22 <Speck> AGs look like AOP to me.
08:52:24 <ski> it gives a kind of modularity .. locality
08:52:32 <ski> yes, it's related
08:52:40 <Speck> data-centric AOP
08:52:55 <Philippa> whereas monads're code-centric AOP of a sort
08:53:00 <lispy> that article comments on AOP's relationship
08:53:14 <ski> computation/action -centric
08:53:21 <Philippa> ski: including PTS-based ones, JOOI?
08:53:32 <Philippa> ski: sure, but that's code
08:53:52 <ski> Philippa : sorry, don't know about those ?  PTS ? JOOI ?
08:54:09 <ski> depends on the definition of 'code', methinks :)
08:54:38 <Philippa> pure type systems, just out of interest
08:54:57 <ski> pure type system-based what ?
08:55:12 <ski> AOP ?
08:55:21 <Philippa> presentations of dependantly-typed programming
08:55:28 <Philippa> or models thereof, rather
08:55:44 * ski still doesn't understan Philippa's remark
08:56:54 * earthy thinks
08:57:09 <ski> (hm, re models of dep-types as internal categories ?)
08:57:09 <Philippa> ski: in a pure type system, types're just ordinary terms like any other
08:57:26 <Philippa> I'm wondering if that simplifies the model any
08:58:11 <ski> iirc it's complex because its a model in an *internal* category
08:58:45 * ski might though confuse dep-type models with models of system F -like thingies .. hm
08:58:59 * earthy thinks attribute grammars are dead simple
08:59:01 <earthy> then again...
08:59:18 * earthy has been steepened in grammars from the earliest possible moments of his CS education
08:59:53 * ski has pondered about having AG support in LP
09:00:50 <lispy> i think the main problem with attribute grammars in that article is that they require me to learn a new syntax and at least in the case of lenth, reinvent the wheel
09:00:54 <ski> Philippa : internal category e.g. being defined as two objects Obj,Mor in some category, then morphisms like  dom,cod : Mor --> Obj  id : Obj --> Mor  etc
09:01:00 <earthy> otoh: I do AG's to generate monadic functions
09:01:34 <earthy> lispy: not that much syntax involved in AG's.
09:01:41 <ski> lispy : one can do AGs directly in haskell. but then you don't get the extensibility-modularity (and locality) of native AGs
09:01:50 <Philippa> earthy: that's pretty much what I was thinking. AGs for funky folds, not for semantics
09:02:03 <earthy> @paste
09:02:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:02:06 <ski> lispy : but one can of course do it
09:03:31 <ski> earthy : ?
09:04:06 <earthy> philippa: look at the example on the pastepage
09:04:31 <earthy> precondition calculator
09:04:43 <earthy> dead simple
09:05:05 <earthy> ofcourse, there's some details underlying it that aren't quite as easy
09:06:20 <earthy> anyway, time to go home.
09:06:52 * ski wonders which one ..
09:08:46 <Speck> can AGs be polymorphic? e.g., instead of the list of Floats in the wiki page, a list of 'a's
09:09:16 * ski doesn't see why not
09:10:21 <Speck> or play nice with type classes... Num a => List a \ | Nil \ | Cons head : a  tail : List
09:14:26 <Akshaal> hi
09:14:48 <Itkovian> Hmm, if ghci says (/) :: (Fractional a) => a -> a -> a, then  why doesn't ghc see it that way?
09:15:17 <ski> Itkovian : you mean what ?
09:15:21 <ski> hiya Akshaal
09:15:33 <Itkovian> as r the last post on the cafe mailing list
09:15:44 <Itkovian> s/r/per/
09:17:03 <ski> Itkovian : named ?
09:17:09 <Itkovian> pompompom ...
09:17:21 <Itkovian> Re: [Haskell-cafe] Can't explain this error
09:17:39 <Itkovian> original post by Dinh Tien Tuan Anh
09:17:45 <ustenzel> Itkovian: of course (/) :: Fractional a => a -> a -> a
09:17:51 <Itkovian> reply by me and robert dockins
09:18:08 <Itkovian> ustenzel: yes, idd, but a Float is a Fractional, right?
09:18:30 <Itkovian> so why doesn't 1/(fromIntegral x) work?
09:18:36 <ustenzel> Itkovian: you cannot apply it at Integer (a == Integer) and get a Float (a == Float at the same time...)
09:19:05 <Itkovian> ok, ignore that, I had a bloody typo
09:19:41 <Itkovian> ustenzel: true
09:19:56 <Itkovian> Num, no?
09:20:00 <Itkovian> grr
09:20:02 <earthy> Speck: yes
09:20:07 <Itkovian> but 1 can be coerced to be any Num, no?
09:20:18 <ustenzel> it can.
09:20:29 <earthy> Speck: there is no restriction on the type of an attribute in an attribute grammar
09:20:50 <ustenzel> 1/fromIntegral x :: Fractional a => a -- this should work
09:22:26 <TheHunter> 1 can't be _coerced_ to anything. 1 is polymorphic.
09:22:53 <lightstep> sure it can be coerced
09:22:55 <ski> (overloaded)
09:22:55 <lightstep> fromInteger 1
09:23:20 <lightstep> the integer 1 is coerced to (forall a. Num a)
09:24:04 <ustenzel> lightstep: no, 1 is no Integer, it already has type Num a => a
09:24:18 <ski> @type let n = 1 in (n,fromRational 1)
09:24:20 <lambdabot> forall a a1.
09:24:20 <lambdabot>             (Num a, Fractional a1) =>
09:24:20 <lambdabot>             (a, a1)
09:24:54 <TheHunter> i'm no native speaker, so this might be wrong, but if i hear coerce, i'm thinking about something like unsafeCoerce#, and i'd call fromInteger a conversion.
09:25:17 * Lemmih greets SyntaxNinja.
09:25:45 <CosmicRay> morning syntaxninja
09:25:45 <lightstep> ustenzel, the 1 i used was an Integer
09:26:43 <Itkovian> ustenzel: yes that works, but I just thought I had a ghc compile erron on that, and not on 1.0 / (fromIntegral x) ...
09:26:46 <Itkovian> nevermind
09:27:05 <ustenzel> Itkovian: the .0 is redundant, no?
09:27:28 <Itkovian> ustenzel: yes, it is. my mistake
09:27:37 <TheHunter> @type 1.0
09:27:40 <TheHunter> @type 1
09:27:40 <lambdabot> forall t. (Fractional t) => t
09:27:42 <lambdabot> forall t. (Num t) => t
09:28:08 <ustenzel> okay, redundant in this case, not in general.
09:28:58 <Itkovian> ustenzel: it depends on what you want afaik. you can specialise it a bit ...
09:30:57 <SyntaxNinja> hi Lemmih, CosmicRay
09:37:00 * ski suffers in the heat
10:12:43 <basti_> hi
10:12:48 <Lemmih> Hey
10:13:01 <lispy> basti_: hi
10:13:12 <lispy> basti_: i've had progress on my elisp interpreter
10:13:38 <basti_> oh cool
10:13:41 <basti_> what does it do?
10:13:57 <lispy> well, so far just parsing and evaluation of a few builtin function
10:14:10 <lispy> i have +, car, cdr, eval and apply
10:14:16 <basti_> :)
10:14:43 <lispy> next on my list are let, lambda and setq
10:15:03 <basti_> im excited.
10:15:04 <basti_> :)
10:15:10 <lispy> thanks
10:15:44 <lispy> well, anyway, i'm off to work on stuff...
10:16:07 <basti_> k
10:56:12 <shapr> Wikipedia is addictive.
10:56:45 <basti_> yes it is
10:57:02 <basti_> i often find myself reading about bizarro plants of southern america or something
10:57:24 <basti_> but then, i used to read encyclopedias when i was younger.
10:58:08 <SyntaxNinja> have you seen unwikipedia or whatever it's called?
10:58:53 <basti_> uhm no
10:58:58 <shapr> I went from Sumo Wrestling to Pro Wrestling to Tim Burton
10:59:23 <SyntaxNinja> http://uncyclopedia.org/wiki/Main_Page
10:59:25 <SyntaxNinja> it's really funny
10:59:44 <shapr> flamewar manual?
10:59:49 <basti_> tim burton yes.
11:00:08 <shapr> Whoa this is interesting - http://uncyclopedia.org/wiki/Flamewar_Guidelines
11:00:09 <basti_> i know some "kamelopedia"
11:00:53 <basti_> lol the header
11:01:10 <shapr> "If you are a good enough flame warrior, you may even pick up combatants that join your cause. Inside jokes are addictive. Outside jokes should be brought in before they catch cold, unless they are vicious attack jokes, in which case they should be sent to joke obedience school."
11:01:13 * shapr laughs
11:01:31 <basti_> -.-
11:02:01 * shapr reads http://uncyclopedia.org/wiki/Crippled_Minnow and laughs more
11:02:47 <shapr> Sauron, Lord of the Dance
11:03:15 <basti_> This page is a sub-sub-sub-sub-stub, making it such a stub that it dwells an unholy 98 degrees northeast of Your Mom and needs to be wrenched from the dark side. Feel free to help (http://uncyclopedia.org/index.php?title=Minnus_Crippulus&action=edit) with the wrenching.
11:03:27 <basti_> sub^4 stub -g-
11:03:49 <shapr> It seems that the uncyclopedia believes that Jim Henson was in league with Cthulhu.
11:04:00 <SyntaxNinja> in order to make this on topic, someone must add a Haskell page.
11:04:34 <basti_> !!! :)
11:04:47 <Philippa> basti_: what, no dom-stubs?
11:04:49 <basti_> one could put the type-faculty program there
11:05:06 <basti_> Philippa: actually... if it makes you go... :)
11:05:27 <Philippa> heh. You should've seen the guy who messaged me on OKCupid earlier today...
11:05:50 <Philippa> the profile pretty much read "I'm a complete wanker, but give me a yell if you want to suck my dick"
11:06:09 <shapr> um
11:06:15 <SyntaxNinja> sounds great
11:06:40 <shapr> hi djlogan, learning Haskell?
11:06:45 <basti_> thats an offer isnt it
11:06:46 <djlogan> Man this language is challenging so far
11:06:48 <Philippa> yeah. Wrap that in a little scene-talk about looking for submissives and group sex and you pretty much have it. Suffice to say I'm not interested
11:06:58 <shapr> djlogan: Yes, challenge is our middle name.
11:06:59 <Philippa> 'lo djlogan, don't mind the pervs :-)
11:07:13 <djlogan> Trying to do stuff I could do in my sleep in C/C++, and can't even get the compiler happy, much less correct results :)
11:07:16 * basti_ sees Philippa turn red
11:07:19 <shapr> c'mon guys, take it to #haskell-youdontwanttoknow
11:07:32 <basti_> djlogan: what are you trying to do?
11:07:34 <shapr> djlogan: Read some Haskell intros?
11:07:44 <djlogan> I'm about halfway though a Haskell intro
11:07:47 <TFK> djlogan, (almost the) same here, only the sleep part involves Python :-/
11:08:00 <djlogan> python is easy enough
11:08:07 <shapr> My sleep part involves malbolge... wait, that was a nightmare...
11:08:45 * Philippa would make a further offer of help, but suspects a crowd of people yelling "how can I help you?" following comments about BDSM might be a little disturbing
11:08:46 <djlogan> I'm trying to create a set of function that takes a string, and returns the first word and the rest of a string as a two-element tuple
11:08:59 <TFK> (Not to sound like a total, uncultured ignoramous, but what's "malbolge"?)
11:09:08 <djlogan> getWord String -> (String, [String])   basically
11:09:12 <Philippa> word defined as "thing separated by spaces"?
11:09:16 <shapr> @google malbolge programming language
11:09:17 <djlogan> right
11:09:18 <lambdabot> http://en.wikipedia.org/wiki/Malbolge_programming_language
11:09:32 <Philippa> do you specifically want to do this from scratch?
11:09:37 <Philippa> Your tuple type's wrong
11:09:42 <TFK> Ah. I tried looking it up in a dictionary >_<
11:09:46 <Philippa> getWord :: String -> (String, String)
11:10:06 <djlogan> Philippa Yea, basically, not only for understanding, but I'll have a lot of parsing rules to do eventually. Trying to figure out the best way to do it
11:10:15 <Philippa> it'd be (String, [String]) if you wanted to return the first word and a list of all other words or something like that
11:10:30 <Philippa> the best way to do parsing IMO is Parsec
11:10:56 <Philippa> though I'm mostly parsing source code and the like, you might find something better for a significantly different problem
11:11:40 <djlogan> I keep getting: *** Type           : [Char] -> d ([Char],[Char])
11:11:41 <djlogan> *** Does not match : a -> ([b],[c])
11:11:43 <TFK> I believe that a function like that exists in that page on the wiki, housing BSD-licensed extra-functions.
11:11:45 <djlogan> )#$%(*#)%*(@#%)
11:11:58 <Philippa> TFK: he wants to write it himself
11:12:01 <TFK> what's d?
11:12:07 <lispy> one of the nice things about parsec is you can do more than just context-free
11:12:19 <TFK> So? He can read and understand the source.
11:12:20 <ski> djlogan : are you using 'return' ?
11:13:32 <TFK> A very naive solution would be to take everything up to the first space, and then drop everything up to the first space.
11:14:09 <djlogan> ski: yes
11:14:09 <Philippa> yeah, that works. Up to you whether you want to write take and drop yourself
11:14:14 <Philippa> don't use return
11:14:17 <ski> djlogan : then don't
11:14:19 <djlogan> I have no idea what d is
11:14:20 <Philippa> it probably doesn't do what you think it does
11:14:32 <Philippa> the type of the monad it thinks you're using because you used return
11:15:11 <djlogan> My latest attempt: http://24.8.61.156/getword.txt
11:15:12 <ski> djlogan : you only use 'return' with "Monads" and you don't need them for this function
11:15:16 <jlouis> usually, you can either parse by using the Prelude if the thing is simple. mutually recursive functions covers simple state-machines (3-4 states). Anything beyond that is what Parsec fixes, as Philippa suggests
11:15:17 * shapr throws monads
11:15:33 <ski> argh
11:15:43 <ski> remove the 'do's, as well
11:16:05 <TFK> do/return are monad stuff.
11:16:09 <ski> and put an "in" after "let r = getWord xs"
11:16:21 <TFK> You don't want monad stuff :-(
11:16:24 <djlogan> ah, in
11:16:27 <ski> djlogan : try that ..
11:16:38 <djlogan> oh, right, let ... in ...
11:17:04 <ski> if you want, you can put "in" in the front of "(x : fst r, snd r)" instead
11:17:06 <basti_> ski: actually i think in monads let without in and indention is allowed
11:17:15 <ski> basti_ : yes
11:17:19 <Philippa> basti_: it is, but we don't want monadic code here
11:17:27 <ski> basti_ : but he don't want do
11:17:48 <basti_> hmm
11:17:57 <basti_> well actually. yes.
11:18:10 * basti_ goes silent again
11:18:24 * shapr is silent.. oops
11:20:07 <ski> djlogan : how does you code fare now ?
11:21:52 <basti_> not at all? :
11:21:52 <basti_> :)
11:23:36 <TFK> quux.org is really , really slow :-(
11:23:43 <shapr> Talk to CosmicRay
11:23:59 <lispy> talk to the CosmicRay because the shapr don't listen ;)
11:24:00 <shapr> CosmicRay: hey, is the fptools darcs repo still regularly updated?
11:24:10 * shapr throws parentheses at lispy
11:24:26 * lispy can't see them
11:24:35 <TFK> Is CosmicRay the maintainer?
11:24:39 <jlouis> traffic shapr ?
11:24:47 * shapr squishes a nearby packet
11:25:02 * ski is reminded of simcity
11:25:43 <TFK> Send UFOs in the unsuspecting public...
11:26:02 <TFK> *on
11:26:08 <TFK> **unleash
11:27:30 <ski> Unidentified Functional Objects ?
11:27:47 <shapr> I'm reading this paper - http://lambda-the-ultimate.org/node/view/834 . I'm not impressed so far.
11:27:59 * TFK plays Revenge of the Chicken on hardcore level
11:33:06 <djlogan> ski: Still sucks. Won't compile :)
11:33:27 <djlogan> This language reminds me a bit of prologue
11:33:36 * TFK snickers
11:33:42 <TFK> Why Prolog?
11:33:52 <djlogan> prologue was rule based
11:34:09 <djlogan> You would write a whole bunch of specific rules
11:34:09 <shapr> Haskell is more about evaluation.
11:34:10 <TFK> Haskell is somewhat declarative.
11:34:12 <shapr> It's math based.
11:34:12 <Philippa> yeah, when I first learnt prolog I thought of it as "haskell backwards"
11:34:47 <ski> djlogan : can we see your new version ?
11:34:48 <Beelsebob> ... and untyped
11:34:50 <Philippa> if you want it to be /really/ like prolog, ask folks about the list monad and other fun stuff sometime
11:34:57 <ski> djlogan : what is the compile-error ?
11:35:02 <djlogan> ski: sure, hold on a moment, I'll put it on my site
11:35:03 <jlouis> shapr: dynamic+static typing is a rather old idea. There has been more than a handful of researchers involved in creating type systems where this happens
11:35:08 <TFK> Why not do it the easy way: breakWord string = (takeWhile (\ch -> ch /= ' ') string, dropWhile (\ch -> ch == ' ') string)
11:35:31 <Philippa> jlouis: I still fail to see what's wrong with static-typing-with-a-Dynamic-type, but hey
11:35:32 <jlouis> in fact, every lisp providing reasonably fast code tries basic hindley-milner type inference on the programs
11:36:01 <djlogan> ok, refresh http://24.8.61.156/getword.txt  and you'll see the latest version + the error
11:36:21 <jlouis> Philippa: the only con of such a system is the complexity of it. Apart from that, more options should not hamper the language per se
11:36:27 * TFK points at his own version
11:36:28 <shapr> jlouis: Yeah, I know, but the first few paragraphs of the paper are depressing.
11:36:43 <ski> djlogan : you still have a 'return' to delete
11:36:50 <ski> "return ([],xs)"
11:37:00 <jlouis> TFK: wouldn't splitAt or some variant be better?
11:37:08 <TFK> Beats me.
11:37:18 <TFK> (Probably)
11:37:23 <TFK> (It's very naive)
11:37:47 <ski> djlogan : ok
11:37:48 <ski> ?
11:38:01 <Philippa> jlouis: the extra complexity seems to be pretty much annotating all the places dynamic typing could fail though, which I'm not convinced is a bad thing
11:38:09 <djlogan> ski: How do I return x or y depending on the if?  just:  if x then (a,b) else (c,d)   ?
11:38:12 <jlouis> TFK: nah, splitAt is what it is called in SML, in Haskell, you want span
11:38:15 <jlouis> Prelude.span
11:38:18 <Philippa> djlogan: yup
11:38:21 <ski> djlogan : yes
11:39:15 <djlogan> lol the compile errors are gone. Now it just doesn't work :)   It returns ("","") regardless of the parameter
11:39:16 <shapr> I think I'll go ride my unicycle, yay!
11:39:17 <jlouis> Philippa: and the fact the programmer has to play with another primitive ;)
11:39:39 <jlouis> I agree it doesn't add much complexity
11:40:02 <ski> djlogan : 'null' in the first line doesn't do what you think
11:40:10 <ski> djlogan : it doesn't match the empty list
11:40:28 <ski> djlogan : it matches anything, so the second equation won't ever be used
11:40:42 <ski> djlogan : change 'null' to '[]'
11:41:18 <ski> djlogan : 'null' is just a variable name, like 'x' or 'xs' in the next equation
11:41:20 <djlogan> ski: ok. I tried null because it was treating [] and "" differently
11:41:42 <ski> strings are lists of characters, so, for strings [] and "" is the same
11:42:05 <ski> difference is that [] works for any list, while "" is just for string = list of characters
11:42:13 <djlogan> ski: it works
11:42:20 <Philippa> jlouis: that, and it's only primitive in the sense IO operations are primitive if you see where I'm coming from
11:42:20 <ski> nice :)
11:42:39 <Philippa> hell, given certain language features it's possible to implement Dynamic from scratch...
11:42:40 <TFK> 112k. Respect.
11:42:48 <djlogan> ski: I just have to figure out why this one works, and the other ones don't, and how to avoid the problems. Obviously there is some fundamental point I'm not yet understanding.
11:43:15 <ski> you can change the [] to "", if tou want, since the function only works for strings anyway (but you don't have to)
11:43:25 <jlouis> Philippa: I better ought to read the paper before I rant more, heh
11:43:41 <Philippa> fair enough
11:51:11 <djlogan> cool. I was able to add in a list of delimiters without too much trouble
11:52:19 <jlouis> ah, the authors are from the ''type systems are too advanced today'' school
11:52:50 <Heffalump> Erik Meijer is one of the guys behind the barbed wire and lenses paper
11:53:55 <Philippa> djlogan: yeah, that sort of thing haskell's good at. If you can think of something to parameterise on, you can
11:55:39 <Philippa> jlouis: there's a lot to be said for doing consolidation work once in a while, but yeah
11:56:08 <ski> djlogan : also, if you pass in a delimiter, instead of hardcoding ' ', you can use the function on lists of any kind, not just strings
11:59:52 <astrolabe> It would be nice to have the Haskell report in book form
12:02:29 <jlouis> Philippa: sure is
12:03:18 <Philippa> I should start on that type systems article for TMR
12:03:37 <djlogan> ski: Well, this particular one would only be strings
12:03:58 <djlogan> What I'm really doing is finding out if this language is really any different than any other language. If it's worth knowing or getting excited about at all
12:05:06 <Philippa> what's the conclusion so far?
12:05:12 <Philippa> (and what other languages've you played with?)
12:05:22 <pejo> djlogan, lots of places teach some sort of functional programming to the first year students. It's not without a reason, I'd guess.
12:05:54 <Philippa> pejo: those courses also put many people off haskell as a language to actually program in because they're busy trying to pimp a certain model of 'pure' FP
12:06:29 <jlouis> purity is fine... until you need to talk to the imperative world
12:06:47 <jlouis> and most courses forgets entirely to bridge the gap
12:07:04 <Philippa> yeah. Which is a real shame because haskell does impure better than any other language I've used
12:07:13 <Philippa> it can be impure in so many different ways! :-)
12:07:38 <djlogan> I play with all standard languages. Pretty much anything. Assembler, pascal, C/C++. I've played with prolog (years ago though), many scripting languages like perl, python, rebol, etc.
12:09:03 <djlogan> The jury is still out. I haven't been able to do much of anything yet, but I'm also only halfway through the tutorial. I read somewhere that this type of programming is significantly different than standard programming, so I'm working on being patient and learning.
12:09:15 <Philippa> I imagine you've met higher-order functions before then, and the pattern-matching probably doesn't seem too weird if you've done prolog
12:10:00 <djlogan> Well, like I said, it's been a long long time, so I'm having to relearn
12:11:00 <pejo> Philippa, shrug, we only did basic things in our course. But I became a better programmer out of it in total, although it was a lot less focused on data structures and stuff compared to SICP.
12:11:39 <Philippa> pejo: same here. But most of the folks who took it at my uni walked out convinced you couldn't do anything useful and that you had to jump through weird hoops just to do IO
12:12:42 <TFK> djlogan, it's different, alright...
12:13:22 <TFK> Philippa, wait, you don't?...
12:13:37 <CosmicRay> djlogan: Haven't seen traceback much, but:
12:13:43 <CosmicRay> Hugs.Base> :t []
12:13:43 <CosmicRay> [] :: [a]
12:13:43 <CosmicRay> Hugs.Base> :t ""
12:13:43 <CosmicRay> "" :: String
12:13:47 <CosmicRay> that may illustrate the difference
12:14:29 <TFK> CosmicRay, howdy, for some reason I was pointed to you regarding quux.org. It seems that it's very slow.
12:14:35 <CosmicRay> if you want a brief overview of what makes Haskell tick, http://www.freesoftwaremagazine.com/free_issues/issue_05/haskell/
12:14:55 <CosmicRay> TFK: yes, that is my site.  the server was offline for a few days (somehow I didn't notice) and is likely swamped today
12:15:12 <CosmicRay> djlogan: and the best online haskell tutorial, imho, is http://www.isi.edu/%7Ehdaume/htut/
12:15:32 <CosmicRay> TFK: is there anything in particular you're trying to reach?
12:15:38 <djlogan> that may be the one I'm using
12:15:42 <TFK> CosmicRay, ah, that would explain things :-)
12:16:00 <CosmicRay> djlogan: it's Yet Another Haskell Tutorial, comes in pdf only
12:16:00 <TFK> I was trying to get missingH, although eventually I was pointed to the debian source package.
12:16:02 <djlogan> yep, that's the one
12:16:14 <CosmicRay> TFK: you can also use darcs get http://darcs.complete.org/missingh
12:16:15 <TFK> And ps, and another format.
12:16:18 <CosmicRay> ah.
12:16:25 <TFK> (But not HTML! Oh no, we don't need HTML!)
12:16:29 <djlogan> of course, that was the *only* tutorial I was able to find, but I'm working through it
12:16:55 <TFK> djlogan, perhaps Gentle Introduction to Haskell would be better.
12:17:10 <CosmicRay> TFK: I found at least two words in the title of that tutorial to be misleading.
12:17:15 <astrolabe> djlogan:  Have you seen http://www.haskell.org/hawiki/LearningHaskell?
12:17:27 <TFK> "Gentle" and "Introduction"? :-P
12:17:33 <CosmicRay> TFK: yes :-)
12:17:46 <Philippa> CosmicRay: it worked as a gentleish reintroduction to it for me. Emphasis on reintroduction having been taught an FP course in haskell two years previously
12:18:04 <TFK> I think that seasoned programmers can handle it. Although there is certailny a need for something nicer.
12:18:14 <CosmicRay> Probably "Haskell: The Craft of Functional Programming" is the very best resource available
12:18:23 <CosmicRay> TFK: too much theory, too little code
12:18:40 <TFK> True.
12:18:47 <TFK> On the other hand, it's short :-P
12:18:51 <TFK> AND avaliable in HTML!
12:18:53 <Philippa> and it's really not nice if you've not done any kind of FP before, or used a language with pattern-matching
12:19:05 <Philippa> short is not necessarily a good thing in learning material
12:19:10 <TFK> pattern matching is the OK part.
12:19:15 <djlogan> the tutorial is almost 200 pages :)
12:19:16 <CosmicRay> right.  I learned OCaml first, which has a nice ("OCaml for C++/Perl/Java programmers" or some such) tutorial
12:19:22 <CosmicRay> and is similar in many respects to ocaml
12:19:26 <CosmicRay> err, to haskell
12:19:32 <TFK> I've tried reading that tutorial :-/
12:19:51 <TFK> I've reached the conclusion that monads are better than separate operators for ints and floats >_<
12:20:14 <CosmicRay> TFK: you don't say!  How about being able to open a file for reading *and* writing? :-)
12:20:25 <CosmicRay> and maybe even a seek in there somewhere!
12:20:46 <CosmicRay> ocaml I/O ****stinks****
12:21:07 <CosmicRay> it would probably work well enough if the thing you're doing I/O with is a tape
12:21:17 <TFK> :-D
12:21:54 <djlogan> I'm going to work on a tcp/ip client in Haskell at some point, see how it goes
12:21:58 <CosmicRay> and yes, the typeclasses in ocaml are an elegant solution to .+ or whatever the heck those ugly operators are
12:22:26 <CosmicRay> djlogan: it's fun.  if you want some example code, I have a FTP client in my MissingH library, as well as some infrastructure to help you write your clients
12:22:44 <CosmicRay> djlogan: I take it you've done TCP/IP in other languages?
12:23:17 <djlogan> yes, you could say that :)
12:23:18 <pejo> Philippa, about classes and what people think - I think it's pretty common that people didn't understand datastructures/algorithms-classes either, they just learnt how to compute some complexity and make some reductions and design some simple algorithms to pass the exam.
12:23:44 <CosmicRay> djlogan: haskell has pretty much a very thin layer around the C calls, just like everyone else except Java does
12:24:05 <CosmicRay> djlogan: so it should be no big chore for you.
12:24:19 <pejo> Philippa, so the problem is bigger than just the fp classes in the beginning. And it might not even be the teachers fault, I have no idea.
12:24:48 <djlogan> cool
12:25:11 <CosmicRay> djlogan: one nice thing about haskell is its lightweight threads.  essentially you get the semantics of select() for free, without having to actually use select() ni your code
12:25:22 <Philippa> pejo: algo&data struct classes don't tend to put people off the idea that algorithms and data structures are any use for anything though
12:25:25 <CosmicRay> sorta like green threads in java, but without all the ugly crap :-)
12:25:53 <CosmicRay> Control.Concurrent.forkIO
12:27:55 <Philippa> there're times I'd really like a sort of modified writeChan-and-yield...
12:28:08 <Philippa> the modification being that it only yields to the process(es) waiting on the Chan
12:28:20 <Philippa> not that I'm trying to do OO or anything, you understand
12:28:54 <djlogan> CosmicRay: Sounds promising, but it seems that it'll be a while before I am able to actually attempt that project :)
12:36:14 * TheHunter is pissed at sml
12:36:51 <djlogan> hmmm, so a loop is done by recursively calling itself? It doesn't run out of stack, huh
12:36:53 <TheHunter> who would've thought that |fn k => (a; b; c)| and |fn k => a; b; c| are different things.
12:37:18 <Philippa> djlogan: when the call is tail-recursive, yes. It just re-uses the stack frame
12:37:28 <djlogan> cool
12:37:40 <Philippa> (well, more typically there's no stack per se, but it uses the activation record still)
12:37:49 <ski> also, laziness make the issues somewhat different
12:38:24 <djlogan> hmmm, do I want to learn how haskell works under the hood? :)
12:38:41 <djlogan> I'm currently having enough trouble learning how the controls operate from the drivers seat
12:39:41 <Heffalump> errm, there is no guarantee in the standard of tailcalls being constant space.
12:39:47 <djlogan> I do, however, find it neat that the case statement has constants and variables together, much like perl regexp
12:40:10 <Philippa> Heffalump: ouch, I probably should've known that
12:40:11 <Heffalump> however, a simple tail call should always be 'free' in any current implementation
12:41:27 <pejo> djlogan, there's a bunch of articles written about GHC by Simon Peyton Jones and Simon Marlow. Depending on your interests it might be worth reading.
12:41:40 <Cale> djlogan: while it can help here and there to know what's going on under the hood here and there, even while learning, I'd focus on just figuring out how to write simple things in the language, how basic types work and such at first.
12:42:21 <pejo> djlogan, and SPJ has written a book which is avail online, "The implementation of functional programming languages" - http://www.research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
12:43:03 <djlogan> Thanks. I'll check them out. I'm always interested in knowing how it all works under the covers
12:43:57 <Cale> (depending on what you already know of course)
12:44:30 <Cale> If you know the basic syntax, just reading the prelude can be helpful.
12:49:54 <TFK> Are polymporhic types types that can morph into any other type (respecting explicitly given constraints) at will?
12:50:28 <Philippa> in a most general sense, or in a Haskell sense?
12:50:29 <basti_> existentials?
12:50:37 <TFK> In the Haskell sense.
12:50:39 <Philippa> In a haskell sense, they're types with type variables in them
12:51:03 <TFK> And what are type variables?
12:51:09 <astrolabe> Like [a]
12:51:22 <astrolabe> a list of something
12:51:26 <TFK> I know what it's like, but I need to know what it is.
12:51:46 <TFK> I was talking about type variables.
12:51:51 <TFK> (In general.)
12:52:37 <ski> e.g.  reverse :: [a] -> [a]   or rather  reverse :: forall a. [a] -> [a]  means that for all types a, reverse has type [a] -> [a]   so e.g. a can be Int so we have  reverse :: [Int] -> [Int]
12:52:53 <TFK> I know that.
12:53:01 <Philippa> TFK: they're names that can be substituted for values
12:53:11 <TFK> I know how they're used; but I don't know what they *are*.
12:53:15 <TFK> That simple?
12:53:18 <TFK> Nothing more to it?
12:53:48 <Philippa> that simple
12:53:50 <Philippa> oh, wait
12:53:51 <ski> a polymorphic type is a type with typevariables, where the typevariables can "morph" into any type (but all occurances of the same type variable must "morph" into the same type)
12:53:56 <Philippa> the value in question must be a 'monomorphic type'
12:54:19 <Philippa> that is, one that doesn't itself contain type variables
12:54:48 <ski> well, indeed  reverse :: [[a]] -> [[a]]
12:55:11 <ski> Philippa : so that depends on what you mean by 'type variables' :)
12:55:32 <TFK> So polymorhpic types don't morph into anything; but such a type contains a type variable which can [morph]. Right?
12:55:39 <ski> right
12:56:02 <gord> djlogan: I'm quite new to Haskell, too, and invested some time in reading about its implementation.
12:56:06 <Philippa> except that when that's happened, the entire type's different - [a] != [Int]
12:56:12 <ski> but  [a] -> [a]  can't morph into  [Int] -> [a]  or  [String] -> [Bool]
12:56:42 <ski> the type variable has to "morph" consistently into the same thing
12:56:51 <TFK> So in [a] -> [a], the types on both sides of the -> is actually the same type.
12:56:53 <djlogan> gord: it's all so confusing! :)
12:56:56 <gord> The basic idea is that (for GHC) everything is represented in the heap as a function pointer with some free variables (also function pointer etc) attached.
12:57:07 <ski> TFK : yes
12:57:34 <gord> The function pointer is only evaluated when the value is actually needed, and then its result is patched in to the original location (cached, so that it need not be evaluated again).
12:57:35 <astrolabe> djlogan: right.  Now you're getting it :)
12:57:48 <ski> gord,djlogan : fyi, reverse reverses any list (and gives back a list of the same type)
12:58:51 <gord> Then, garbage collection is the only way that these heap structures get freed.
12:59:12 <pejo> Hm. Doesn't "Basic polymorphic typechecking" by Cardelli give a quite comprehendable introduction to this, which is a bit less dense?
12:59:29 <Philippa> that, and an algorithm
12:59:35 <Philippa> it's a nice tutorial
13:00:04 <gord> So, laziness (only evaluating things when they're needed) and garbage collection (only reclaiming space when it's not needed) are the two opposing forces that let the computer do all the work of computation, and you only have to worry about describing the relationships between the functions.
13:00:12 <Beelsebob> bob's perhaps stupid question for the day...
13:00:50 <Beelsebob> why does the program: `main = print $ reverse []' cause a type error... surely all that matters is that there is a type that satisfies the type checker=
13:00:53 <Akshaal> yesterday, someone asked about alternative IO with classes... so it is: http://htoolkit.sourceforge.net/
13:00:55 <Beelsebob> ... in this case... any type
13:01:04 <Akshaal> ObjectIO
13:02:12 <Heffalump> Beelsebob: because the type checker isn't smart enough to realise that.
13:02:16 <djlogan> Now there is a term I've never heard before. I think it describes most of what I do: "pointless programming" :)
13:02:30 <Beelsebob> heffalump: I get that... but why not
13:02:47 <Heffalump> And in fact, because of the way show on lists works, two different types would give different results, so it is entirely justified in rejecting it.
13:03:04 <Heffalump> (consider [] :: [Char] and [] :: [Int] )
13:03:05 <TheHunter> Beelsebob, works fine here. The type of the list is defaulted to [Integer]
13:03:06 <jlouis> gord: what you mention plus a number of clever optimizations. You might actually not need to thunk anything which the strictness analyzer showed to be strict anyway
13:03:06 <ski> Beelsebob : because not all things can be printed, and the type of reverse [] is [a] (i.e. list of anything), and print doesn't realize that this won't actually contain any element of type a
13:03:13 <Akshaal> Beelsebob: becouse any type is not belong to Show class
13:03:23 <Beelsebob> ski:ah yes... that makes sense
13:03:33 <Heffalump> the type checker gets as far as figuring out that it wants something of class Show.
13:04:26 <Beelsebob> okay then... slightly different example...
13:04:42 <Beelsebob> why doesn't this typecheck `main = do x <- reverse []; putStrLn "Jam"'
13:05:00 <Akshaal> but then why type checker didn't restrict type of a to Show a? hmm
13:05:24 <Heffalump> because the type checker is too stupid to handle it. Type checkers can never handle all cases that in theory would be statically type checkable.
13:05:45 <Beelsebob> heffalump: yes... I get this... I want to know why *this* simple example is too complex
13:05:47 <TheHunter> because you mix two different monads, the list and the IO monad.
13:05:59 <Beelsebob> I do?
13:06:14 <Beelsebob> oh... yes... I do
13:06:42 <Beelsebob> hmm... dumb bob
13:06:52 <Heffalump> :-)
13:06:55 <Beelsebob> and sticking in a return $ does typecheck
13:07:03 <pejo> Heffalump, why not?
13:07:05 <Heffalump> only because of defaulting, though.
13:07:16 <Heffalump> pejo: it's a consequence of the halting problem.
13:07:18 * shapr says it's de fault of de compiler
13:07:30 <Beelsebob> shapr: no... it's the fault of the bob
13:07:31 <Heffalump> it's easy to write programs where you won't get defaulting.
13:07:39 <Heffalump> @type read . show
13:07:42 <pejo> Heffalump, then it doesn't sound like it's "statically type checkable".
13:07:44 <Beelsebob> shapr: correct... main = do x <- return $ reverse []; putStrLn "Jam"
13:07:47 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
13:07:57 <shapr> Bah, I was just trying to be funny :-P
13:07:58 <Heffalump> doh
13:08:00 <Heffalump> @type show . read
13:08:02 <lambdabot> String -> String
13:08:23 <Heffalump> hmm. I didn't think that was possible.
13:08:35 <Heffalump> obviously I'm wrong.
13:08:59 <ski> @eval (show . read) "42"
13:09:05 <lambdabot> Ambiguous type variable `a' in these top-level constraints
13:09:11 <ski> hm
13:09:19 <shapr> hm!
13:09:20 <Oejet> Haha
13:09:38 <Heffalump> pejo: For many programs P, there exists a type checker TC that can handle P.
13:09:52 <Heffalump> pejo: However, there does not exist a universal type checker UTC that can handle all such programs P.
13:09:59 <shapr> astrolabe: The H98 report does exist in book form.
13:10:03 <shapr> I'd like to have a copy also.
13:10:25 <shapr> CosmicRay: Hey, is the fptools darcs repo updated from cvs.haskell.org on a regular basis?
13:10:28 <astrolabe> shapr: Do you have a link?
13:10:51 <shapr> Here's pix of Heffalump's copy - http://www.scannedinavian.org/~shae/h98/
13:11:23 <astrolabe> OOOh shiny!
13:12:45 <TheHunter> hmm, code entered at the ghci prompt appears to default more things to Integer than code loaded from a file...
13:12:55 <Beelsebob> heffalump: what is it about that then that breaks the typechecker?
13:12:59 <shapr> TheHunter: There's a good reason for that.
13:13:11 <shapr> Oh wait, sorry... wrong thing.
13:13:22 * shapr goes back to flaking out in private
13:14:35 <Heffalump> beelsebob: the typechecker is unwilling to pick a default value for 'a' in types like (Show a, Read a) => String -> String
13:15:05 <Heffalump> the reason it is unwilling to do that is shown by the function (show.read), which would have a completely different meaning depending on which 'a' you picked
13:15:08 <Beelsebob> yes... but that's not the type that the typechecker thinks that (show . read) is
13:15:14 <Beelsebob> @type (show . read)
13:15:16 <lambdabot> String -> String
13:15:25 <Beelsebob> ...no qualifications
13:15:27 <Heffalump> I think ghci is a bit more willing to default than H98.
13:15:38 <Beelsebob> ah... okay
13:16:43 <Heffalump> or rather, the ghci prompt is
13:16:48 <pejo> Heffalump, ok, I'll take your word for that.
13:17:37 <Heffalump> pejo: I couldn't prove it formally without a lot of work, but it it should be possible to encode the property "is statically type checkable" as the halting problem.
13:17:52 <Heffalump> Beelsebob: both ghc(i) and hugs reject foo.hs containing
13:17:58 <Heffalump> foo :: String -> String
13:17:58 <Heffalump> foo = show . read
13:18:06 <Beelsebob> ... interesting
13:18:24 <Heffalump> and also if you remove the type signature
13:18:36 <Beelsebob> is there a theoretical reason why it's a bad thing to throw away the qualifications in certain situations?
13:18:46 <TheHunter> wow, i tested the same thing with the same file, also named foo.hs.
13:18:50 <Beelsebob> i.e. is there a reason for not doing this
13:18:52 <astrolabe> Got it.  http://www.amazon.co.uk/exec/obidos/ASIN/0521826144/qid%3D1121113113/202-7415052-7088637
13:18:56 <Heffalump> yes, the reason I gave above.
13:19:09 <Heffalump> depending on different choices for 'a', the behaviour of (show.read) is different.
13:19:20 <Heffalump> But this is in no way visible in the type, which is just String -> String
13:19:44 <Beelsebob> yes... but that shouldn't stop it typechecking
13:19:55 <Heffalump> a program that typechecks should run.
13:19:56 <Beelsebob> it will still always take a string and return a string
13:20:12 <Heffalump> And there is no safe implementation for that program.
13:20:15 <Heffalump> so it won't run
13:20:18 <Speck> @paste
13:20:18 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:20:25 <Heffalump> (by the definition of "safe" I outlined above)
13:20:26 <Beelsebob> ahh... so the problem is that Show and Read are not the same class
13:20:33 <Heffalump> no.
13:20:49 <Beelsebob> i.e. if you could guarentee that if you read it you can show it, then it *would* always run
13:20:57 <Heffalump> The problem is that the type of (show.read) requires picking an arbitrary value for a type variable not mentioned in the type.
13:21:14 <Heffalump> not without dynamic type information, which would be a completely different ball game.
13:21:24 <Beelsebob> yep... oky
13:21:40 <jynxzero> The problem is that the compiler has to pick which "show" and "read" function to use.  read doesn't actually return type a
13:22:29 <jynxzero> A particular instance of read and show have to be chosen, but there is not enough information in the program to pick which one.
13:22:56 <Speck> What's wrong with the code at the top of this page? http://www.haskell.org/hawiki/HaskellIrcPastePage
13:23:09 <Speck> well, I know what's wrong, but why and how do I fix it :-P
13:23:40 <TheHunter> where isn't allowed in do blocks.
13:23:44 <TheHunter> you can use 'let'
13:23:52 <CosmicRay> Speck: hint: at what level does "where" bind?
13:24:04 <TheHunter> let xs = [12,54,76,34]
13:24:11 <Speck> hm... where binds to the last statement, not the do block, eh?
13:24:12 <TheHunter>     ys = map read $ l...
13:24:13 <CosmicRay> Speck: (answer is at the level of the innermost function)
13:24:55 <CosmicRay> so, indeed a workaround is to use let as TheHunter is showing
13:25:30 <CosmicRay> better: split off the last three lines of main into a pure (no need for I/O) function.  Then, main = readFile "ys.txt" >>= print . procFunc
13:26:23 <Speck> procFunc being what I will have split off?
13:29:22 <pejo> Heffalump, hm. I don't doubt that "is statically type checkable" "is" a halting problem in itself. I guess my interpretation of your original statement was wrong. Did you basically claim that there isn't a TC that can handle all programs that "make sense"?
13:29:46 <Heffalump> yes.
13:29:59 <CosmicRay> Speck: yes
13:39:11 <Speck> @pl \ys -> zipWith (*) xs ys
13:39:13 <lambdabot> zipWith (*) xs
13:39:21 <Speck> of course
13:41:12 <Speck> CosmicRay, I updated the IrcPaste page with what I have now. Much better!
13:42:42 <basti_> can it do haskell hilight now?
13:50:33 <CosmicRay> Speck: nice
13:51:05 <Speck> type inference is so nice
13:51:43 <Speck> a friend of mine asked me how to do that in c++
13:52:36 <Speck> I tried writing it and it was just horrible, so I went to haskell and bam, a good solution
14:00:24 <TFK> Of course if you have dynamic typing...
14:00:48 <Philippa> then you get an inferior solution
14:02:29 <TFK> Can an arbitrary number of arguments be passed to functions? I gather that they can't in Haskell, but is this possible in principle with the Hindley-Milner type system? (That's what Haskell implements, right?)
14:03:06 <basti_> uhm?
14:03:10 <basti_> yes.
14:03:19 <shapr> TFK: Look at the polyvariadic args trick documented by Oleg and used in XmlRpc
14:03:41 <basti_> youre still about existentials?
14:03:52 <TFK> Link to something I can actually read?
14:04:11 <shapr> Polyvariadic args aren't that difficult :-P
14:04:26 <TFK> IO isn't *that* difficult, too, but...
14:04:50 <TFK> Well, there seem to be an awful lot of zip3, zip4, and whatever functions...
14:04:58 <TFK> liftM, liftM2, etc.
14:05:08 <shapr> Bringert's XmlRpc library uses polyvariadic args.
14:05:29 <shapr> Dang CosmicRay left.
14:05:52 <TFK> HaXR ?
14:06:07 <shapr> Yup
14:06:53 <TFK> Which function should I be looking at?
14:07:04 <Speck> zip3,4,5 annoys me
14:07:49 <basti_> why?
14:08:00 <shapr> You can do zipN with template haskell.
14:08:11 <Speck> I've read the template haskell papers
14:08:15 <shapr> Ah, ok.
14:08:17 <basti_> ah
14:08:17 <Speck> and it looks interesting, even promising
14:08:18 <basti_> okay
14:08:28 <basti_> yes its macros in haskell
14:08:31 <shapr> TH is quite nifty, but I want more!
14:08:36 <TFK> Well, template haskell is there, and H98 is here.
14:08:40 <basti_> if i ever need one i know where to get it
14:08:47 <TFK> Network.XmlRpc.Server.fun?
14:08:51 <Speck> basti_, it just has a kind of a code smell for me
14:09:01 <shapr> Network.XmlRpc.Server.really.lots.of.fun!
14:09:06 <basti_> you mean as in cryptography?
14:09:19 <TFK> shapr, yes, that's what the author probably thought...
14:09:28 <shapr> The author hangs out here, he's a really cool guy.
14:09:46 <shapr> The author did most of the organization for EuroHaskell 2004 along with andersca
14:10:06 <shapr> Is it my imagination or do I know most of the people in the Haskell community?
14:10:53 <TFK> Is that an example of a function which takes an arbitrary number of arguments?... It seems so but looks somewhat cryptic.
14:10:55 * shapr imagines all the people...
14:11:08 <shapr> Aanyway...
14:11:23 <SyntaxNinja> shapr: you imagine you know all the people, or you know all the imaginary people, or what?
14:11:33 <shapr> SyntaxNinja: It's all in my imagination anyway...
14:11:49 <SyntaxNinja> you're very creative to have come up with Igloo, IMO.
14:12:24 <TFK> So there's no way to do a generic zip in H98?
14:12:29 <frederik> what was "extra-ghc-arguments"? something you could specify with a package? what did it do?
14:13:10 <shapr> I'm really good at imagining people who work much harder than I do...
14:13:18 <Speck> I don't see how a haskell function can take a nonspecific number of arguments since we have currying
14:13:34 <basti_> hmm
14:13:51 <TFK> And template Haskell ignores currying?
14:14:07 <basti_> no but its cheating.
14:14:34 <TFK> Why am I not surprised.
14:14:36 <Speck> consider an addition function that works like scheme's. (+ 4 2 3 6 7) in haskell -> do we return the value or a function that takes more arguments?
14:14:46 <SyntaxNinja> frederik: you mean ghc-options?
14:14:58 <shapr> Speck: We always return a unary function.
14:15:03 <Philippa> Speck: we call the function sum and pass it a list :-)
14:15:45 <Speck> Philippa, I know we do that :-) I'm just wondering about haskell's (in?)ability to take a variable number of arguments
14:16:07 <shapr> Well, a list is a variable number of items.
14:16:18 <frederik> SyntaxNinja: maybe. Peter Thiemann referred to it
14:17:19 <basti_> TFK: TH specializes the code at compile time.
14:17:36 <basti_> Speck: hmm i bet you can build something like that the boilerplate approach
14:17:58 <Speck> I never got around to absorbing s.y.b., although I've glanced through the papers
14:18:00 <SyntaxNinja> frederik: look at that in the manual and see if it's what you need. are you packaging wash?
14:18:03 <TFK> shapr, of the same type.
14:18:13 <basti_> Speck: its really simple, in principle
14:18:23 <shapr> TFK: HList?
14:19:03 <SyntaxNinja> frederik: I'm isaac, we've been corresponding via email lately.
14:19:05 <Speck> yeah, it seems that way, and in combination with metamorphic programming we have a powerful idiom for data processing
14:19:31 <basti_> im typing an example
14:19:46 <Speck> I need to leave work soon
14:19:55 <basti_> i'll keep it
14:20:09 <shapr> autrijus: What's the title of your fabled article? Boil your ScratchPad with Style?
14:20:10 <Speck> cool, I should be back online when I get home
14:20:13 <Speck> later all
14:20:16 * shapr waves
14:20:54 <basti_> done already
14:21:07 <basti_> lisppaste2: @url
14:21:07 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:22:44 <lisppaste2> basti_ pasted "variable number of arguments - syb" at http://paste.lisp.org/display/9830
14:24:18 <TFK> Readable.
14:24:26 <basti_> my code?
14:24:54 <TFK> Yes.
14:25:13 <basti_> :)
14:25:56 <TheHunter> what's the advantage over a function taking a list?
14:26:43 <basti_> hmm you can give different types
14:26:51 <basti_> and recognize them at runtime
14:27:31 <TFK> So safety is still guaranteed? No runtime type errors?
14:28:00 <basti_> depends on your implementation
14:28:05 <basti_> you can bailout safely
14:28:18 <TheHunter> |[Either a b] -> r| can also do that, or am i mistaken?
14:28:33 <basti_> hmm
14:28:46 <frederik> SyntaxNinja: yeah, I vaguely remembered the connection between your names :)
14:28:50 <basti_> Actually yes.
14:29:32 <lightstep> for more advanced instances of this idiom, you'd need your own data type instead of list
14:29:57 <frederik> SyntaxNinja: yes, I'm packaging wash. I'm not sure what exactly Peter would have been using that for but I'll look
14:30:09 <shapr> hiya mike
14:30:18 <mikehammad> hey what's up
14:30:18 <basti_> the great advantage is imo that the types are carried at compile time
14:30:23 <shapr> You learning Haskell?
14:30:24 <basti_> but can be dynamic at runtime
14:30:30 <frederik> SyntaxNinja: i mean, I'm done packaging it. he referred to it when I suggested that moving WASH to hierarchical modules was a bad idea
14:30:34 <mikehammad> i'm learning template haskell
14:30:38 <shapr> Oh, good choice.
14:30:42 <basti_> you give the possible combinations, the compiler checks them, and at runtime you use them
14:31:08 <mikehammad> was going to ask about TH support in ghc 6.4
14:31:20 <frederik> SyntaxNinja: oh, no, not ghc-options from Cabal. this is something that he said went away in the new package system. i couldn't find it online
14:31:23 <shapr> TH in 6.4 is slighly different from 6.2, but also better.
14:31:28 <mikehammad> in particular, is it easy now to implement something like Fraskell in the current GHC?
14:31:31 <TFK> basti_, how would what work? The number/type of arguments is infinite.
14:31:51 <shapr> mikehammad: You may be able to ask the author of Fraskell if he's not busy.
14:32:08 <basti_> TFK: uhm? principially this would be correct because of induction
14:32:20 <basti_> except for functions that take infinite amounts of parameters
14:32:26 <TFK> GHC can do mathematical induction? Wow.
14:32:33 <basti_> no it cant
14:32:48 <TFK> So how can it check all combinations?
14:33:01 <mikehammad> igloo: is it difficult to port the Fraskell unrolling code to the new GHC?
14:33:06 <basti_> im not sure i know what you mean TFK.
14:33:19 <basti_> the number of combinations is limited in every step
14:33:20 <Igloo> Shouldn't be particularly difficult
14:33:21 <basti_> finite
14:33:34 <TFK> We were talking about arbitrary number of arguments, right? o.o;
14:33:40 <basti_> yes.
14:33:45 <basti_> so it might be infinite yes.
14:33:50 * Igloo might have already done it, I don't remember
14:33:52 <basti_> im aware of that.
14:34:27 <mikehammad> ok cool.
14:34:32 <TFK> So how can it verify type safety?
14:34:51 <basti_> besides bottom and infinite loop you mean?
14:35:15 <TFK> Yes.
14:35:39 <basti_> you will never encounter a type that isnt mentioned in your data declaration
14:36:16 <basti_> except for the variable type
14:36:29 <basti_> but then type checking would extend beyond your function too
14:36:41 <mikehammad> igloo: thanks, i'm going to see if it can be ported.  i'm doing a more specific type of unrolling.  it's for monadic arrays with unboxed elements.
14:37:37 <lisppaste2> lightstep pasted "alternative implementation" at http://paste.lisp.org/display/9832
14:37:39 <SyntaxNinja> frederik: maybe it was an old field, or a field in the ghc package.conf file or something
14:38:02 <SyntaxNinja> why is moving WASH to a hierarchical namespace a bad idea?
14:38:02 <shapr> mikehammad: oh sounds fun
14:38:17 <shapr> mikehammad: Have you seen Manuel Chakravarty's array unrolling?
14:38:22 <lightstep> basti_, is there benefit to either approach?
14:38:46 <TFK> Can that technique be used to zip arbitrary number of lists?
14:38:54 <basti_> well either is basically a custom datatype with exactly two arguments...
14:39:15 <basti_> so you can do exactly two kinds of functions, which in our case would be "takes a parameter" and "doesnt"
14:39:44 <basti_> so no advantage besides being there already
14:41:42 <basti_> Speck!
14:41:47 <Speck> back :-)
14:41:47 <shapr> Speck!
14:41:50 <basti_> that was quick
14:41:51 <basti_> http://paste.lisp.org/display/9830
14:41:53 <shapr> Mistah Goldman
14:42:03 <Speck> hehe
14:42:15 <mikehammad> functional array fusion?
14:42:17 <Speck> impressive shapr, people at work still call me goodman
14:42:26 <shapr> haha
14:42:29 <shapr> mikehammad: that's it
14:42:45 <mikehammad> yea, that's mainly for sparse matrices
14:42:55 <shapr> Speck: I saw you post to the haskell list, and I tend to remember people.
14:43:15 <Speck> I don't think I've posted to the haskell list; you probably remember it from the PArrows changelog
14:43:21 <mikehammad> i'm working on dense matrices.  so, it'll be hard to reuse his stuff
14:43:39 <shapr> Oh, maybe so
14:43:51 <mikehammad> at least i think it will
14:44:54 <Speck> basti_, what does that code do?
14:44:58 <mikehammad> does anyone know of a huge disadvantage to using the Word type in GHC?
14:45:10 <mikehammad> more specifically, Word32
14:45:13 <shapr> It uses the MS monad?
14:45:16 <basti_> Speck: it demonstrates a type that can keep variable-number-of-argument functions
14:45:19 <shapr> :: MS Word ?
14:45:22 * shapr cackles evilly
14:45:34 <tomdavie> haha
14:45:40 <Speck> hmm... maybe over my head :-/
14:45:42 * TFK still wonders about that zip
14:45:43 <tomdavie> so Microsoft is a Monad now?
14:45:52 <tomdavie> that would explain it's evilness
14:46:04 <basti_> maybe microsoft is a coarrow or something
14:46:20 <SyntaxNinja> frederik: you don't ujse Debian by chance, do you?
14:46:21 <shapr> Whoa, what's a coarrow?
14:46:33 <frederik> SyntaxNinja: i think it's a bad idea because he would do it by renaming all of the modules within WASH. i want him to wait for my module-namespace grafting proposal to be implemented and then just do it by setting a default graft point
14:46:46 <basti_> or a cococomonad
14:46:51 <frederik> i don't think modules should know their fully-qualified names
14:46:58 <lispy> microsoft monad?
14:47:01 <frederik> SyntaxNinja: i use debian why
14:47:27 <lightstep> shapr, aren't arrows symmetric? contain both monads and comonads?
14:47:46 * tomdavie is lost
14:47:51 <lightstep> probably a coarrow is just the same arrow with (>>>)=(<<<)
14:47:54 <shapr> I don't know enough about comonads to say anything about them.
14:48:17 <basti_> lol
14:48:36 <SyntaxNinja> frederik: because I'd welcome you to file bug reports and wishlist items using debian-bug against the haskell-cabal package. that's where I track cabal bugs.
14:48:51 <basti_> maybe its also (<)=<<<>>>=(>) or some other weird ascii art ;)
14:49:11 <tomdavie> ... wtf
14:49:23 <basti_> j/k
14:49:30 <lightstep> tomdavie, www.haskell.org/arrows
14:49:40 <frederik> SyntaxNinja: first you ask me to send you email rather than IRC, now you want me to use debian BTS rather than email :)
14:49:44 <tomdavie> ty lightstep
14:50:04 <tomdavie> I know if I actedi bemused enough I wouldn't have to use google *g*
14:50:11 <SyntaxNinja> frederik: you are welcome to send me email, and I'll decide which ones I want to file as bugs, or you can just file bugs directly and I won't forget about them ;)
14:50:22 <frederik> SyntaxNinja: are you forgetting the ones i sent you?
14:50:29 <SyntaxNinja> frederik: probably not ;)
14:51:11 <lightstep> tomdavie, you never have to use google when lambdabot has @google
14:51:49 <frederik> so, i gave WASH a MonadFix, in my version you should be able to put submit buttons before the things they submit... i haven't tested it yet but it was pretty simple
14:52:36 <tomdavie> hmm... wonders why the first function is needed... why not have an arrow that is partially id
14:52:57 <shapr> That is first.
14:53:19 <tomdavie> yes... but I don't get why you need a function specifically for that...
14:53:37 <lightstep> `first' creates this arrow
14:53:41 <tomdavie> after all, why is that any more logical than one that always adds 5 to the last part of the input
14:54:05 <SyntaxNinja> frederik: I have filed them as bugs
14:54:26 <frederik> SyntaxNinja: thanks. maybe someday i will understand the importance of bug tracking systems
14:54:51 <tomdavie> ohh... these look quite shiny
14:55:04 <lightstep> tomdavie, cause you can do that with myArrow>>>arr(+5)
14:55:12 <tomdavie> k
14:55:18 <shapr> arr is really pissing me off.
14:55:26 <lightstep> why?
14:55:27 <shapr> Somebody fix it!
14:55:29 <tomdavie> but... why can't I do it with myArrow>>>arr(id)
14:55:36 <shapr> Because of the 'black box' problem.
14:55:42 <tomdavie> ?
14:55:47 <shapr> Hang on...
14:56:44 <shapr> Black box - http://www.cs.helsinki.fi/u/ekarttun/haskell/blackhole.txt and the very end of http://kevin.atkinson.dhs.org/fg/FG.hs
14:56:46 <SyntaxNinja> frederik: how do you remember your bugs?
14:58:00 <shapr> Arrows are wonderful, as long as you can stick with pure arrow types. But that means you can't directly lift any functions into an arrow without losing the optimizations that arrows give you.
14:58:17 <shapr> so, Arrows are a superset of functions, they do more than that.
14:58:31 <tomdavie> okay
14:58:48 <tomdavie> I think I get enough to know I want to look at this in 4 days time
14:59:08 <shapr> Philippa has described a programming language that uses only arrows, it would be able to do cool things that are not possible with current languages.
14:59:48 <SyntaxNinja> frederik: you may choose whether you wish to email me or email the bts, the only question is, would you like me to spend time fixing the bugs, or browsing through my email looking for bugs :)
15:00:06 <shapr> Another interesting trick is that the whole Church-Turing results only apply to functions, so it's possible that languages based on pure category theory (arrows) will be able to do something outside of the Church-Turing limitations that we are all so familiar with.
15:00:24 * SyntaxNinja meeting &
15:00:31 <basti_> :-o
15:00:35 <basti_> that would be wow
15:01:07 <shapr> But, I have not been able to figure out how build languages based on pure category theory. The Category types would be primitives, but how to implement that sort of thing?
15:01:20 <basti_> but it could turn out to be generalized abstracted nonsense huh
15:01:34 <shapr> Yes, nonsensical far beyond anything seen before.
15:02:03 <tomdavie> so... this channel then?
15:02:05 <tomdavie> :P
15:02:23 <lightstep> FG seems cool. everything with arrows has so much more hype than monads
15:02:24 <shapr> The questions now are, 1. How to implement a Category primitive? 2. What laws must a category satisfy to operate with other Categories?
15:02:36 <shapr> It's not just hype, arrows really do awesome stuff.
15:02:37 <basti_> good questions.
15:02:45 * Spark doesnt even know what arrows are
15:03:01 <tomdavie> we just went through that one spark
15:03:03 <tomdavie> scrolly up
15:03:25 <shapr> Question Three is, is there some sane way to interface between the Turing world and the pure Category Theory world?
15:04:17 <Spark> tomdavie: what time?
15:04:26 <lightstep> 15 min ago
15:04:30 <tomdavie> 22:53
15:04:56 <shapr> Oh hey, maybe emulate the Turing world as a Category. That way you get all the concreteness and introspection of categories and all the abilities of Turing-ness?
15:04:59 <shapr> That might work...
15:05:45 <basti_> and run that on turing-alike things
15:05:51 <lightstep> if you have the Set categoty, thich corresponds to lambda calculus, and if you can implement the language on a utm, aren't the models equivalent?
15:05:58 <basti_> and then you get feedback and your brain explodes
15:06:54 <shapr> lightstep: Heck if I know, I'm just brainstorming here. I'm trying to eval thunks as I understand them.
15:07:10 <lightstep> i don't even understand CT
15:08:04 <Spark> arr :: (b -> c) -> a b c
15:08:07 <Spark> what does that mean?
15:08:11 <Spark> the "a b c" bit
15:08:19 <Spark> ive never seen application of type variables before
15:08:37 <shapr> a is the parameterized arrow type, it's a first class transformer from type b to type c
15:08:46 <lightstep> `a' is called a type constructor
15:08:57 <lightstep> like Either, or (->)
15:09:03 <Spark> ah right
15:09:05 <shapr> The `a' is much like the `m' in monad types.
15:09:59 <shapr> ghc 6.5 has new syntax for arrows, so it'd look like b ~> c
15:10:01 <Spark> i should learn haskell some day :)
15:10:29 <shapr> (though I could be wrong, feel free to correct me if you know more)
15:10:37 <Spark> i havent written code for 6 months, and no hobby projects for 12 :s
15:10:44 <shapr> Whoa, why not?
15:10:50 <Spark> busy with uni stuff
15:10:55 <Spark> reports, exams, and things
15:11:10 <Spark> im not good at having projects in parallel
15:11:20 <shapr> I'm really good at start projects.
15:12:03 <shapr> Anyway, I'm beginning to think that pure Category based programming languages will kick the crap out of anything else. If people can figure out how to implement them, that is.
15:12:17 <Speck> Charity?
15:12:35 <shapr> !
15:13:23 <basti_> well maybe in the case of the empty set the category buisiness comes out simple
15:14:59 <shapr> Hm, I can't tell if Charity is what I'm looking for
15:15:43 * lispy suspects charity doesn't mean charity
15:17:12 * shapr 's brain explodes while reading about "Strong Categorical Datatypes"
15:19:11 <Spark> acid trip
15:19:17 <basti_> CT?
15:21:46 <Speck> brb
15:39:32 <putter> I've an "imposible happened" on an old snapshot of 6-5.  Bugzilly suggests it's a "seen, but haven't been able to replicate" problem.  It looks like I won't be able to help replicate it either (it goes away too easily).  But while I have it repeatable on my machine, is there anything I should do to help clarify matters?
15:41:21 <putter> For the curious, the key phrase is  Maybe.fromJust: Nothing
15:53:21 <SyntaxNinja> putter: make a snapshot of the code which causes the problem, then email the ghc folks. they'll tell you how to help
15:59:34 <nothingmuch> if anyone knows a bit about pugs continuations I'd appreciate some guidance
16:17:23 <putter> SyntaxNinja: Thanks for your help.
17:17:39 <Speck> I showed my friend a program he wrote in 3 lines of expressive haskell and now he wants me to teach him :-)
17:17:50 <shapr> What was the program?
17:17:52 <Speck> *my version of a program he wrote
17:18:01 <shapr> How long was his program?
17:18:15 <Speck> he couldn't write it
17:18:28 <Speck> he had a bunch of c++ code that didn't work
17:18:41 <shapr> That's happened to me before.
17:19:15 <Speck> it takes a list of numbers from a file and zips them together with a hard-coded list on a function (some physics thing)
17:19:30 <shapr> Sounds easy enough.
17:19:50 <Speck> it was quite easy, and admittedly neither of us are very good with C++
17:20:05 * shapr neither
17:20:31 <Pseudonym> Maybe that's a slogan that Haskell should adopt.
17:20:38 <Pseudonym> Haskell: So you don't have to be very good with C++.
17:20:41 <shapr> Past job I had tried get me to learn C++, I just left the job instead.
17:21:17 <Speck> my job lets me use whatever I want :-)
17:21:26 <Pseudonym> Are they hiring?
17:21:34 <Speck> sadly, that's the only good thing about that job
17:21:40 <Pseudonym> Ah.
17:21:48 <Pseudonym> So you can write crap in whatever language you like.
17:22:52 <shapr> Pseudonym: You don't want to work with my former employer, I promise you.
17:23:13 <Pseudonym> I was asking Speck. :-)
17:23:22 <shapr> oh, sorry
17:23:24 <Pseudonym> I certainly do not want to work with your former employer, no.
17:23:31 <Pseudonym> You've mentioned them before.
17:23:34 <shapr> Yup
17:23:51 <shapr> They never paid me the last 2000 euro they owed me.
17:24:20 <Speck> of our high kloc application, 99% of it is in visual basic
17:24:38 <shapr> How many kloc?
17:24:39 <Speck> well, that's not really fair, there's a lot of business logic right there in the microsoft database
17:25:16 <Pseudonym> Yikes.
17:25:39 <Speck> I haven't done any actual calculations, but I could read the whole thing if my job was to read it every work day for 6 months
17:25:48 <Speck> 3000 database tables
17:25:57 <Speck> 800 stored procedures
17:26:04 <shapr> I worked on 65 kloc of vb4 for trust management.
17:26:29 <Speck> our application stores all the information for 8 colleges
17:26:30 <Pseudonym> I'd rather read our 2MLOC of C++.
17:26:39 <Pseudonym> But then, any amount of C++ is better than any amount of VB.
17:26:46 <Pseudonym> And that's saying something.
17:27:15 <shapr> Speck: I feel sorry for you.
17:27:27 * Pseudonym does too
17:28:01 <Speck> that's why I'm learning haskell; I'm pretty sure that with all the open development in fp, there'll be a lot of demand once the market grows
17:29:11 <shapr> Could be, but even if that doesn't happen you'll learn powerful techniques that you can use to befuddle large numbers of lesser devs.
17:29:59 <shapr> I use higher order functions lots in Python, and it blows the minds of other people on a regular basis.
17:30:19 <Speck> I was writing some C++ to help out my friend and I really felt trapped. no pattern matching alone hurt a lot.
17:30:37 * shapr hugs pattern matching
17:31:04 <Speck> I've coded some simple ruby apps at work, mostly data mining, but people were very impressed
17:31:56 <shapr> I like Ruby's OO model. I don't like explicit end, or the fact that higher order code isn't easy.
17:32:17 <shapr> Ruby's OO model is better than Python's OO model, imho.
17:32:42 <shapr> As for higher order code, gimme Haskell!
17:35:15 <Speck> I never got around to learning python, though I meant to, because I already knew ruby.
17:35:36 * shapr shrugs
17:35:52 <Speck> Haskell is definitely where it's at though.
17:35:59 <shapr> Maybe I'm a fanatic, but I don't see the need for Python or Ruby in my life when I have Haskell.
17:36:42 <Speck> I haven't used Haskell for anything "real," but given the chance I definitely would.
17:37:51 <Speck> Most of my work though is just, test so-and-so-non-programmer's vb code
17:41:24 <shapr> You can use Haskell for that too
17:42:53 * shapr waves a copy of QuickCheck
17:44:24 <Speck> the code in question is easier to read than make a computer read it
17:44:48 <shapr> oh
17:44:50 <shapr> ok then
18:08:20 <autrijus> shapr: it's "Boil your scratchpad", "Boil other people's scratchpads", and "Boil your scratchpad with prole"
18:10:17 <autrijus> the full name of the first one is "Boil your scratchpads - Genetic frogging in Haskell"
18:10:28 <dons> oh my
18:10:40 <Pseudonym> Aren't you supposed to boil a frog slowly?
18:11:04 <autrijus> right, that's why genetic frogging is slow
18:11:56 <dons> ah, I see. it is clear now
18:12:20 <dons> genetic frogging *is* slow
18:12:53 <Pseudonym> And what do the proles have to do with it?
18:14:01 <autrijus> hm, maybe "with destitutes"
18:14:54 <autrijus> the idea is no-one with class -- not even middle class -- will bother themselves with frog boiling
18:15:34 <autrijus> it offends their bourgeois taste; so need proles to do that
18:15:35 <dons> I see, boiling scratchpads without class
18:15:40 <autrijus> yup.
18:16:46 <wagle> "boiling scratchpads"?
18:17:05 <wagle> am i not scrolling back enough?
18:17:36 <autrijus> wagle: 05:20 < shapr> autrijus: What's the title of your fabled article? Boil your ScratchPad with Style?
18:17:57 <dons> I hope someone @quotes autrijus on this ..
18:18:20 <Pseudonym> You know how to do it.  Sheesh.
18:18:55 <dons> oh, right - that's true. bit busy atm.
18:19:11 <dons> phd review talk today
18:19:28 <Pseudonym> Ah.
18:19:39 <autrijus> good luck, dons
18:19:41 <Pseudonym> Are you going to show them lambdabot?
18:19:42 <Pseudonym> :-)
18:19:44 <dons> also known as: "how to convince people that haskell hacking is a valid phd"
18:20:04 <dons> well, I might drop lambdabot's name ;)
18:20:13 <Pseudonym> This reminds me of a friend of mine who around 1990 completed a Bachelor of Pretending COBOL is Structured.
18:20:32 <dons> heh
18:20:44 <dons> isn't Ralf Lammel some kind of god of COBOL?
18:21:00 <dons> @google ralf cobol
18:21:01 <lambdabot> http://www.cs.vu.nl/Cobol/
18:21:07 <Pseudonym> Does COBOL have deities?
18:21:40 <wagle> whoa..  i dont feel guilty any more..  thats was 19 pages of scrollback ago..  8)  thanks
18:21:43 <dons> see ralf's talk: Ralf Lmmel's presentation "Stop bashing COBOL"
18:21:56 <Pseudonym> Oh, I gotta read that.
18:22:16 <wagle> i have a book on structured cobol
18:22:18 <Pseudonym> And it has two pictures of Grace Hopper on the front page, too.
18:26:50 <Pseudonym> This just reinforces to me that the world needs a COBOL replacement.
18:26:59 <Pseudonym> I thought Java was going to be it for a while.
18:28:05 <autrijus> dons: http://autrijus.org/tmp/phd.png
18:29:05 <dons> hehe :)
18:29:19 <dons> hmm. can I use that as the closing slide for my talk?
18:29:29 <autrijus> sure!
18:29:31 <dons> getting some laughs at the  end is always good :}
18:29:52 <autrijus> I'd be honoured :)
18:30:16 <dons> :)
18:35:53 <juhp> LOL
18:41:11 <wagle> i see a lot of business programming in java
18:45:36 <stefanw> dons: do you really need such "tricks" to convince the audience ;-)
18:47:06 <dons> hehe. I usually but some kind of image on the final slide, instead of just "The End"
18:47:44 <dons> just seems a nicer way of opening up to questions
18:49:09 * stefanw is already thinking of some nasty questions for dons
18:49:48 <dons> thanks stefanw
18:53:15 <dons> lucky stefanw doesn't get reviewed this year
18:57:38 <wagle> i had a evolutionary biologist friend who let his slide tray our of his sight for a few minutes.  his friends took the opportunity to insert a two slides of them mooning the audience..
18:57:52 <wagle> this was for his phd defense
18:59:57 <dons> wow
19:14:18 <seafood> I've always enjoyed what Olin Shivers had to say about his PhD defense
19:16:08 <wagle> which was?
19:16:30 <seafood> http://www.cc.gatech.edu/~shivers/grad-advice.html
19:18:18 <wagle> rofl
19:18:42 <seafood> Olin Shivers *really* knows how to write.
20:50:23 <autrijus> the frogs are on QuotesPagenow
20:57:31 <Pseudonym> Now that's a scary thought.
21:02:42 <Speck> night all
22:32:53 <ski> morning #haskell
22:45:47 * ski listens to "Tnk om jag vore en skalrprodukt"
22:46:06 <ski> (emg. "What if I was a scalar product")
22:56:31 <shapr> Do you ever get those days when you just can't sleep?
22:57:40 <lament> nights
22:57:55 <lament> most days i can't sleep :)
22:58:06 <mwc> shapr: yeah, it's 2 am and I'm porting haskell packages
22:58:07 <Gahhh> hey shapr. how's code
22:58:27 <mwc> shapr: I find I sleep best from about 3 am onward anyways
23:02:01 <shapr> It's 8am, I'm giving up sleeping.
23:02:39 <Pseudonym> I feel so flattered to be a substitute for sleep.
23:02:45 <shapr> Gahhh: Code is slow, how's code with you?
23:03:37 <Gahhh> shapr: I wrote two lines of haskell today, which is why I joined heh. I haven't been able to do anything haskell related recently. Just reading LtU.
23:03:41 <mwc> shapr: are we in the 24 hours of sunlight yet?
23:04:13 <shapr> I've been there for months.
23:04:23 <shapr> But that's not why I can't sleep.
23:04:38 <Gahhh> this reminds me of the movie insomnia, heh. I'm glad you're doing better than Pacino...
23:04:48 <shapr> For some reason my inability to sleep is usually accompanied by smell hallucinations.
23:05:11 <ski> what kind of smells ?
23:05:21 <mwc> shapr: do you smell burnt toast? :P
23:05:40 <shapr> Nah, it can be anything. The worst was an entire week of celery.
23:06:10 <shapr> Last night was lemons and kangaroo steak for some unknown reason.
23:06:26 * shapr blames the aussies
23:06:52 <shapr> hoi shrimpx
23:07:01 <mwc> shapr: guess it's a canadian thing, there used to be a "heritage moment" commercial on TV. It was about Dr. Drake, the neurosurgeon. He cured a woman's epilipsy by poking her brain until she smelled burnt toast (accompanied seizeures.)
23:07:24 <shapr> That's bizarre.
23:07:31 <mwc> Oh, NO:
23:07:32 <mwc> c2hsLocal: Error in C header file.
23:07:32 <mwc> /usr/include/stdio.h:258: (column 42) [FATAL]
23:07:32 <mwc>   >>> Syntax error!
23:07:33 <mwc>   The symbol `__asm' does not fit here.
23:07:37 <mwc> why lord? why me?
23:08:43 <Gahhh> because you asked for it...
23:09:42 * mwc curls up and sobs like a little girl
23:10:10 <mwc> Gahhh: what's LtU?
23:10:37 <Gahhh> mwc: http://lambda-the-ultimate.org/
23:11:00 <mwc> ahhh, didn't recognize that TLA
23:11:05 <mwc> but know the site
23:11:05 <Pseudonym> shapr, that _is_ bizarre.  Nobody has lemon with kangaroo steak.
23:11:28 <mwc> Lemon is good for fish, I recommend pepper and garlic for red meat
23:11:44 <Pseudonym> Kangaroo is very strongly flavoured, like venison.
23:11:53 <mwc> mmm, sounds good?
23:11:57 <mwc> Like Venison, or something different?
23:12:09 * mwc only knows north american game
23:12:09 <Gahhh> Pseudonym: maybe people do bizarre things with 24 hour daylight ?
23:12:09 <Pseudonym> Very like venison.
23:12:23 <mwc> neat, I like Elk myself
23:12:33 <shapr> Pseudonym: I had some kangaroo steak once at an aussie-themed restaraunt in Birmingham, Alabama.
23:12:35 <Pseudonym> Gahhh: That is possible.  Putting lemon on kangaroo might be a symptom of seasonal affective disorder.
23:12:49 <Pseudonym> shapr: Did it taste like venison?
23:12:57 <Pseudonym> :-)
23:13:20 <shapr> It had a gamey taste, but it was different from venison.
23:13:26 * Pseudonym nods
23:13:30 <shapr> Less greasy too.
23:13:36 <shapr> Elk is really nice though.
23:13:38 <Pseudonym> We have a pie shop near us which sells all sorts of pies.
23:13:40 <mwc> Buffalo is the way to go
23:13:48 <Pseudonym> Like kangaroo, crocodile, emu, camel etc.
23:13:51 <shapr> Wow
23:13:56 <shapr> Camel pie?
23:14:00 <Pseudonym> Yup.
23:14:04 <Pseudonym> Never tried that one.
23:14:05 <shapr> I've never eaten camel at all. I'm jealous.
23:14:15 <Pseudonym> Crocodile does taste like whatever it last ate, I think.
23:14:21 <Pseudonym> Very primitive meat.
23:14:23 <Gahhh> lol
23:14:36 <mwc> I've heard squirrel meat is the wya to go, exceedingly low saturated fat
23:14:47 <Pseudonym> Kangaroo is extremely lean.
23:14:50 <Pseudonym> I do recommend it.
23:14:55 <Pseudonym> If you like gamey meat, anyway.
23:15:37 <Gahhh> this is 2005 and we still don't synthesize our food. Blah.
23:15:56 <monochrom> you've confused 2005 with 2500.
23:16:39 <vegai> "still"?
23:16:48 <mwc> Gahhh: hankering for some Soylent Green?
23:16:58 <Pseudonym> Mmmm... people...
23:17:23 <lament> Gahhh: why should i synthesize my own food? I leave that to lesser organisms.
23:17:30 <Gahhh> I wanna DCC some camel DNA to shapr so that he can have a nice lunch today. But the technology is just not there.
23:17:32 <shapr> I'd rather be as far up the food chain as possible.
23:17:42 <shapr> Makes me feel selfish.
23:17:54 <mwc> shapr: top of the foodchain accumulates all the environmental toxins
23:18:09 <shapr> hm, good point.
23:18:10 <Pseudonym> I'm also curious what you want the sharks to eat.
23:18:38 <mwc> Pseudonym: fish?
23:18:46 <Pseudonym> Possibly.
23:18:59 <Pseudonym> Mmmm... shark...
23:19:15 <Pseudonym> Standard fish & chip shop fish in Australia is school shark.
23:19:21 <mwc> I was watching open water with my girlfriend, and we got into an argument of if using the dive knife to slash the sharks' gills would have been a good idea
23:19:35 <mwc> I think if you calmly left , the sharks would frenzy in on the dead one
23:19:58 <Pseudonym> That's assuming you can calmly leave.
23:20:06 <mwc> heh, true
23:20:13 <mwc> just don't thrash around
23:20:15 <Gahhh> that's assuming you can calmly slash, too
23:20:29 * mwc is a ninja
23:20:39 <mwc> I don't go scuba diving wihtout my Katana
23:20:42 <Gahhh> underwater ninja. hello hollywood.
23:21:09 <mwc> it's 0222, and I hunger for steak
23:21:22 <mwc> damn all this meat talk
23:21:33 <Gahhh> that's how the fast food restaurants make money at night. People crave for burgers, etc.
23:21:42 <shapr> I've read that shark skin can sense an electrical charge (blood) two miles away.
23:21:45 <Gahhh> people that stay away from them during the day...
23:21:59 <mwc> Gahhh: did you know a high fat meal triggers the same chemical reward system as sex?
23:22:00 <shapr> Seems like a good thing to clone for cops, shark skin air sensors.
23:22:20 <Gahhh> mwc: I didn't. I heard that chocolate does the same thing, though.
23:22:30 <Gahhh> shapr: That's gotta be a very slow travelling wave, though.
23:22:35 * Pseudonym should contact the fast food joints and get kickbacks
23:22:51 <mwc> no, chocolate is emotional, fat is actually the same physical system as orgasm reward
23:22:56 <Gahhh> hmm
23:23:04 <mwc> you can crave fat like you crave sex.
23:23:17 <Gahhh> I know that fat increases your testosterone levels.
23:23:21 <mwc> comes from when humans needed lots of calories to feed their brains and bodies for hunting
23:23:39 <mwc> Gahhh: true, but cholesterol can clog up your heart and your johnson
23:23:42 <mwc> I don't know which is worse
23:24:07 <Gahhh> I think in the hunter gatherer sense, if you have fat food lying around, that means you're full and it is a good time for fun...
23:24:48 <mwc> Gahhh: did you know that hunter societies were vastly healthier and longer lived than farmers, until about the roman or later times?
23:25:06 <Gahhh> That's interesting. Was it the exercise ?
23:25:35 <mwc> no, the variety in diet
23:25:42 <mwc> a farmer ate their crop, right?
23:25:50 <mwc> a hunter ate different stuff every day
23:25:57 <Gahhh> the farmers had no animals ?
23:26:24 <mwc> the rich ones did
23:26:41 <Gahhh> maybe they indulged in cake.
23:26:45 <mwc> but they farmed the same few crops and ate them day in, day out
23:29:21 <Gahhh> Pseudonym: nVidia are still looking for a compiler guy. It's not too late, heh ;)
23:35:44 <Pseudonym> Gahhh: I want to move to Silicon Valley even less now.
23:37:56 <Gahhh> Pseudonym: It is likely that I will move out, as well.
23:38:36 <lament> but isn't the weather awesome?
23:38:50 <Pseudonym> How hot does it get?
23:39:20 <Gahhh> The weather is great.
23:39:39 <Gahhh> In centrigades, in winter it is about 10-15C. It is very common to have 20C.
23:39:59 <Gahhh> In summer, it reaches 35C in June, and around 30C in July & August, I'd say.
23:40:06 <lament> lovely
23:40:10 <Gahhh> very little rain
23:40:14 <Pseudonym> That does sound very mild.
23:40:23 <Pseudonym> The lack of rain is unfortunate, though.
23:40:26 <Pseudonym> It'd make water expensive.
23:40:31 <Pseudonym> I would imagine.
23:40:46 <Gahhh> Umm, probably, but with the housing costs that is the least of your concern heh
23:41:17 <lament> rain sucks.
23:41:39 <Gahhh> lament, are you from British Columbia ?
23:41:46 <lament> yes :)
23:41:53 <Pseudonym> I kinda like rain in moderation.
23:41:56 <Pseudonym> Don't like snow though.
23:41:58 <lament> so.. i know a few things about rain :)
23:42:01 <Gahhh> It is as rainy as Seattle I suppose
23:42:02 <Pseudonym> I really, REALLY detest heat.
23:42:21 <Pseudonym> I'm uncomfortable at about 32C, and seriously uncomfortable over body temperature.
23:42:29 <lament> In Vancouver, there's a Brazilian community newspaper called Vanchuver.
23:42:35 <Pseudonym> Optimal working temperature for me is 15C-25C.
23:42:38 <lament> Chuver meaning "rain" in Portuguese.
23:42:38 <Gahhh> Pseudonym: It gets too hot for a few days in June. Southern California is even milder: it never gets to 30C.
23:42:44 * Pseudonym nods
23:43:06 <Pseudonym> It doesn't help that California is full of Californians, though.
23:43:08 <mwc> Anybody here tell me why gtk2hs can't use an external c2hs?
23:43:28 <Gahhh> Pseudonym: especially Ahnold
23:43:31 <Pseudonym> Do you think they'd mind if I transported Vancouver to California?
23:43:40 <Pseudonym> I reckon that'd be optimal.
23:43:50 <lament> Yes please!
23:43:59 <lament> except, it has to stay Canadian.
23:44:05 <Pseudonym> Of course.
23:44:12 <mwc> lament: it's already owned by the Japanese
23:44:23 <Pseudonym> I reckon Vancouver's lifestyle with California's weather might be a pretty good deal.
23:44:29 <lament> mwc: you mean Chinese.
23:44:40 <Pseudonym> Melbourne is very like Vancouver, so I'm told.
23:44:52 <lament> Very very many chinese people here.
23:44:54 <Gahhh> A lot of hockey in Melbourne ?
23:45:03 <Pseudonym> No, we have our own code of football instead.
23:45:09 <mwc> lament: Banff at least is owned by the Japanese, isn't it?
23:45:18 <lament> Dunno about that.
23:45:35 <mwc> that's what I heard back about 1995 or so
23:45:38 <Pseudonym> Melbourne is extremely multicultural.  We have a bit of everything.
23:45:43 <mwc> been a while since I lived ouy west though
23:45:52 <Pseudonym> Last I heard, Melbourne was the largest Greek city in the world.  Ahead of Athens.
23:45:58 <mwc> now I'm one of those f#$%cking ontarians
23:46:33 <lament> yeah, vancouver is extremely multicultural as well
23:46:38 * Pseudonym nods
23:46:57 <Gahhh> Silicon Valley is extremely multicultural. For example, me.
23:47:08 <Pseudonym> Well, yes, but many of them aren't citizens.
23:47:10 <lament> I'm a russian jew :)
23:47:23 * Pseudonym is a mongrel
23:47:25 <Gahhh> Many are citizens, actually (not I, sadly)
23:47:54 <Pseudonym> Mostly British, but part Danish Jew.
23:48:07 <Pseudonym> Bit of Viking, probably.
23:48:31 <Pseudonym> As a friend of mine once said, war is humanity's way of deepening the gene pool.  Everyone is a bit of everything.
23:48:32 <mwc> I'm a half ukranian, half english boy
23:48:46 <Pseudonym> She said: "I'm full-blood Spanish.  That means Moor, Visigoth, Roman..."
23:49:03 <mwc> Pseudonym: yeah, case in point, the Ukrain. I have everything from Norse to Mongol from there
23:49:09 <Pseudonym> Right.
23:49:18 <Gahhh> It is said that 1 out of every 200 men in the world carry the genes of Genghis Khan.
23:49:29 <Gahhh> That guy had fun back in the day
23:49:43 <mwc> Gahhh: yeah, he used to kill the villages men and then inseminate their women
23:49:54 <Pseudonym> Probably ate too much fat.
23:50:36 <mwc> I just want to know how he kept it from getting bruised and painful during all that
23:51:00 <Gahhh> he had doctors. actually, he was obsessed with immortality.
23:51:30 <Gahhh> you have to be the special kind of megalomaniac to be able to do what he did anyways
23:53:19 <araujo> Genghis Khan was pretty smart though
23:54:09 <shapr> How so?
23:54:09 <mwc> incredible:
23:54:11 <mwc>  the amount of energy we receive with the crystal radio is measured in billionths of a watt. The human ear can detect sounds that are less than a millionth of even that.
23:54:18 <mwc> because knowledge is power
23:54:26 <shapr> Ya know, I've been thinking about that...
23:54:50 <shapr> I came up with a really cool idea for an advertising promo
23:54:56 * Pseudonym must know a few watts then
23:55:08 <mwc> burn and pillage a village and rape its women?
23:55:25 <Gahhh> shapr: Yeah, he was a smart guy. He recruited scientists, developed war tactics, etc.
23:55:32 <Gahhh> he just had bad morals heh
23:55:37 <Gahhh> and a lot of greed
23:55:46 <araujo> Well, those are like to say, the effects of being a prisoner by almost all your life
23:55:52 <Gahhh> reminds me of another smart famous guy heh
23:56:27 <shapr> Nah, give away earbuds that have a single song stuck into their ROM, and power the earbuds by receiving a wide range of wavelengths and using that electricity.
23:56:36 <mwc> heh
23:56:37 <mwc> cool
23:56:48 * araujo likes Espartacus ideology
23:56:52 <Gahhh> Hmm, I've just found a 10Gb free email provider with IMAP (no smtp, tho)
23:56:54 <Itkovian> who are we talking about, exactly?
23:57:00 <Pseudonym> Brings a new meaning to having a song stuck in your head.
23:57:03 <shapr> I've been trying to figure out how to get hermaphrodite earbuds that automatically 'change sex' so that two earbuds next to each other will automatically be one left and one right.
23:57:34 <hyrax42> that's not hermaphrodite
23:57:38 <hyrax42> that's sex-changing
23:57:41 <hyrax42> like those frogs
23:57:46 <mwc> ambisexual
23:57:50 <hyrax42> there ya go
23:57:53 <mwc> they go whichever way they need to be
23:57:54 <hyrax42> there's a word for everything
23:58:04 <Pseudonym> shapr: Don't forget to boil them slowly.
23:58:04 <shapr> The benefit of these earbuds will be that they're free, and able to receive digital audio from the nearest source. Obviously that would be your digital music player unless you're walking past a store that advertises strongly.
23:58:44 <shapr> So I figure the music companies would buy millions of these advertising earbuds.
23:58:49 <Itkovian> shapr: isn't the problem with those thingies that they're shaped to fit in your left - right ear?
23:59:31 <shapr> The everyday grocery store earbuds have the same shape for both sides.
23:59:37 <mwc> oh well, I'll settle the hash of this stupid c2hs tool tomorrow night
23:59:40 <mwc> adieu
