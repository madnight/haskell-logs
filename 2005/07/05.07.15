00:00:13 <Cale> cs <- hGetContents handle
00:00:45 * musasabi pastes an example to the wiki.
00:00:53 <Cale> (command, rest) <- parse commandParser "network" cs
00:00:58 <Cale> er
00:01:21 <Cale> rather, that's not in the IO monad
00:01:28 <dblhelix> see the paste page
00:01:33 <dblhelix> @paste
00:01:34 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
00:01:37 <Cale> case parse commandParser "network" cs of Left e -> print e; Right (command, rest) -> ...
00:02:47 <gord> Oh, cool!
00:03:34 <Cale> gord: As a nice little sidetrack, you might enjoy my article at http://www.haskell.org/hawiki/MonadsAsContainers
00:03:57 <dblhelix> I can't think of any reason of using a lazy IO stream instead of the lazy string in the example---right?
00:04:27 <dblhelix> /s/of using/for not being able to use
00:04:36 <Cale> it ought to work
00:04:49 <gord> My blunder was seeing "hGetContents -> IO String" and forgetting that "bind" leaves me with just a String.
00:04:55 <dblhelix> so, we're all happy? :)
00:05:12 <gord> I'll try it!  Many thanks to everybody for spending the last two hours talking about this. :)
00:05:25 <Cale> unsafeInterleaveIO is still behind the scenes inside hGetContents, but it should be safe enough at this point :)
00:06:08 <dblhelix> Cale: be welcome to write another efficient and safe implementation of hGetContents ;)
00:06:36 <Cale> right, hGetContents itself inherits some of the problems of unsafe IO.
00:07:38 <Cale> Since for instance you could be processing the string as the file pointed to by the Handle changes on disk.
00:08:24 <Cale> Shouldn't be too much of a problem with a stream like the network.
00:09:17 <dblhelix> well, it's not a perfect world, I guess
00:09:46 <dblhelix> it *is* almost weekend though and there's some things I want to have done before that, so ...
00:13:37 <earthy> grmlz. grm
00:14:00 <earthy> itkovian, you present?
00:14:04 <dblhelix> earthy: and a good morning to you :)
00:14:20 <earthy> owh, right. Good Morning #haskell!
00:14:33 <earthy> now, back to fixing my b0rken ghc
00:16:09 <dblhelix> earthy: why don't you just use the supplied Mac OS binary?
00:16:23 <earthy> dblhelix: that's what's b0rken.
00:16:28 <Cale> Good very-early-morning :) It's 3:17 here.
00:16:43 <dblhelix> earthy: ouch
01:01:45 <heatsink> No instance for (MonadCont IO)?!
01:03:02 <Itkovian> meuning
01:04:21 <heatsink> meowning
01:10:59 <earthy> Itkovian!!!
01:11:04 <earthy> friend! :)
01:11:08 <Itkovian> lol
01:11:10 <Itkovian> hi earthy
01:11:17 <earthy> did you manage to get GHC 6.4 to work on tiger or not?
01:18:47 <swiert> is there some way to set/get the width of the terminal from Haskell?
01:19:54 <musasabi> swiert: wrapping ioctls
01:21:45 <swiert> musasabi: is there any easier way?
01:21:59 <swiert> i.e. without ffi
01:26:44 <earthy> swiert: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System.Posix.Terminal.html
01:27:33 <earthy> is the closest you get
01:34:45 <swiert> earthy: that's close, but not quite...
01:34:54 * earthy knows ;)
01:35:06 <earthy> and itkovian is darn quiet on his ghc on tiger
01:35:07 <earthy> oh hell
01:35:11 <earthy> I'll use darwinports
01:35:32 <swiert> I guess I'll find something else
01:35:40 <Itkovian> earthy: yes, it works, but sadly not with gcc-4.0 (yet)
01:35:57 <earthy> itkovian: the package by wolfgang thaller works?
01:35:58 <earthy> how?
01:36:45 <earthy> or are you talking about the darwinports package (which is preconfigured to use gcc 3.3
01:36:49 <earthy> )
01:36:49 <Itkovian> I'll rebuild from CVS, when I have a few cycles to spare, and then rebuild again using gcc-4.0.0
01:37:02 <Itkovian> no, it's wolf's package all right
01:37:14 <earthy> and you do a gcc-select?
01:37:16 <earthy> or what
01:37:21 <Itkovian> when e.g. compiling darcs, ghc insert some ___DISCARD__ into the code, which annoys the hell out of gcc-4.0
01:37:28 * earthy nods
01:37:31 <earthy> seen that ;)
01:37:45 <Itkovian> so, basically, I'll alias gcc to gcc-3.3, build ghc, install ghc, and retry using gcc-4.0
01:37:57 <earthy> *right*
01:38:03 <Itkovian> any estimate on the duration of such a compilation?
01:38:05 <earthy> not the path I'm willing to take. :)
01:38:16 <Itkovian> I prolly need to build in the fptools base dir, right?
01:38:19 <earthy> I'll do the port install ghc
01:38:34 <Itkovian> earthy: well, when I have it compiled, you may have it ...
01:38:34 <earthy> well, compiling a ghc takes a number of hours on slow hardware
01:38:42 <Itkovian> I should be able to tar it.
01:38:54 <Itkovian> 1.5GHz G4 is what I have ...
01:38:56 <earthy> thing is, i want it to be easily installed and work :)
01:39:10 <Itkovian> unpack the tarball in /usr/local ?
01:39:16 <earthy> Itkovian: my guess would be 1 to 2 hours worth of compilation
01:39:30 <Itkovian> shit, I leave for lunch around 11.30 I think
01:39:34 <earthy> 'port install ghc' is simpler. ;)
01:39:53 <Itkovian> hmm ... but then you won't be able to use gcc-4.0, right?
01:40:01 <earthy> not with ghc no
01:40:07 <Itkovian> which is way more l33t than gcc-3.3 ;-)
01:40:11 <earthy> yeah
01:40:24 <earthy> I'll wait for Wolfgang to spend some love with ghc and gcc-4
01:40:33 <Itkovian> so, basically, I have a working ghc
01:40:42 <earthy> due to hackery. :)
01:40:46 <Itkovian> just not fit to compile everything
01:41:07 <Itkovian> nono, it works straigh out of the packege, just not with gcc-4.0
01:41:17 <Itkovian> grr, bloody typos
01:41:29 <earthy> yeah, but I hate having to doe gcc_select when I go using ghc
01:41:46 <earthy> I'd rather have ghc know to automatically take gcc 3.3
01:46:27 <gennet1> is there no way to select at runtime the path to the compiler that ghc should use?
01:46:30 <Itkovian> hmm, alias it, eh.
01:46:47 <swiert> earthy: is System.Console.Readline.getPoint broken for you as well?
01:47:09 <Itkovian> alias ghc="runghc.sh" and alias gcc and unalias it in that script
01:47:22 <earthy> !sigh
01:47:24 <Itkovian> gennert -pgmc I think
01:47:36 <Itkovian> gennet1: grr, -pgmc gcc-3.3 I think
01:47:42 <earthy> okay, when the bleep is this laptop going to sleep
01:47:47 <Itkovian> I was told yesterday, anyway iirc
01:48:02 <gennet1> would that not get you sorted out?
01:48:49 <Itkovian> gennet1: yes, temporarily, but I was also told that using ghc-CVS-head would solve the problem too
01:49:03 <gennet1> ah... also good
02:03:03 * Itkovian is making
02:05:57 <Lemmih> Making what?
02:18:15 <Itkovian> ghc
02:23:04 <earthy> let's see of -pgmc works
02:24:03 <msok> excuse me, i have 6 lines of code i'd like to ask a question about, can i paste it here or should i put it on a paste page?
02:24:16 <earthy> @paste
02:24:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:24:26 <msok> earthy: alright, at the top?
02:24:30 * earthy nods
02:27:21 <Itkovian> hmm, make didn't like the alias, and nowe I seem to be missing config.mk.in :-(
02:28:34 <msok> earthy: alright
02:28:46 <msok> basically, i'd like to know if that's the preferred way to do it
02:34:08 <Lemmih> msok: \h n -> fmap (flip (!!) n.lines) (hGetContents h)?
02:34:30 <msok> Lemmih: i'm sure i'll have a lot of fun figuring out what that does, heh ;)
02:35:19 <Lemmih> You need to read more from the Handle after the n'th line?
02:35:30 <Lemmih> @type \h n -> fmap (flip (!!) n.lines) (System.IO.hGetContents h)
02:35:37 <lambdabot> GHC.IOBase.Handle
02:35:37 <lambdabot>                      -> Int
02:35:37 <lambdabot>                      -> IO String
02:36:04 <msok> Lemmih: yeah, i may want to read from it again
02:38:53 <earthy> what lemmih said
02:39:29 <msok> heh, alright, thanks Lemmih and earthy
02:41:14 <Lemmih> @type ((fmap last . sequence) .) . flip replicate . System.IO.hGetLine
02:41:16 <lambdabot> GHC.IOBase.Handle
02:41:16 <lambdabot>                        -> Int
02:41:16 <lambdabot>                        -> IO String
02:42:09 <Lemmih> That'll keep the Handle in a usable state.
02:42:18 <msok> Lemmih: thanks
02:42:47 <msok> Lemmih: can you suggest the best source for reference documentation?
02:43:03 <Lemmih> This might be easier to read: \h n -> fmap last (sequence (replicate n (hGetLine h)))
02:43:28 <Lemmih> msok: http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:43:34 <msok> thanks
02:43:48 <msok> that's what i've been using
02:43:59 <Lemmih> Oh (:
02:47:18 * ski reads interesting slides on comonads and signal programming
02:48:52 * Oeje1 hasn't found a good online tutorial on Tutorial D yet. :-(  Any ideas?
03:04:13 * Itkovian goes to lunch
03:06:03 <Fri22537> in a lattice, the top was the value consistent with everything...so what was the bottom again...the value you would most likely want to end in?
03:07:28 <Lemmih> Oeje1: You want a tutorial for a tutorial?
03:09:06 <Fri22537> or maybe bottom was just the valid starting value
03:11:00 <Fri22537> hhhm, no that was the iota value...
03:11:01 <Fri22537> crap
03:11:37 <arjanb> afaik the bottom is a combination of values
03:12:12 <Fri22537> a combination of values....
03:12:22 <Fri22537> a bit general no?
03:12:22 <Fri22537> :D
03:13:25 <Fri22537> maybe it's just a representation of having the least amount of knowledge in the lattice
03:13:30 <Fri22537> i think that is correct
03:14:16 <arjanb> if something has different values in branches than the meet of that is bottom
03:14:38 <Fri22537> i think that is top actually
03:15:04 <Fri22537> ow no wait, that's when you *join* all branches
03:15:11 <Fri22537> meet moves you down in the lattice right?
03:15:17 <arjanb> yeah
03:15:26 <Fri22537> ok so then it's the thing with least information
03:15:56 <Fri22537> i.e. top is the thing consistent with everything, because joining two branches ends up in a value consistent with both branches
03:16:15 <Fri22537> if the lattice is complete that is
03:17:30 <Fri22537> hmmm arjanb, the meet of two values...is a new value consistent with both values? cause in that case...i think the meet IS the join, only the lattice has been turned upside down
03:18:29 * arjanb is confused now too
03:19:33 <Fri22537> too bad i forgot my program analysis book today, cause they explain the whole thing
03:20:24 <Fri22537> no i think the meet is the dual of the join
03:20:37 <Fri22537> it just finds one value from which both branches originated
03:21:04 <Oeje1> Lemmih: Hehe, well more precisely the query language "Tutorial D".
03:21:05 <Fri22537> so moving down along both branches until they meet
03:28:48 <MarcWeber> If nobody minds I'll create an experimental ebuild for jhc.. (and perhaps post it to bugs.gentoo.org.. ) Which license will jhc use?
03:31:01 <Fri22537> it gonna cost ya :P
03:31:25 <musasabi> MarcWeber: different parts have different licences.
03:31:53 <MarcWeber> Ok.. Then I'll make that ebuild just for me.. ;)
03:32:21 <Fri22537> @plugs (not .) . Data.Set.isSubsetOf $ (Data.Set.fromList [1]) (Data.Set.fromList [1..10])
03:32:26 <lambdabot> Variable not in scope: `Data.Set.isSubsetOf'
03:32:35 <musasabi> MarcWeber: I think the future is jhc being GPL and the libs BSD, but currently it is a little bit more complicated.
03:32:48 <Fri22537> @hoogle isSubsetOf
03:33:05 <MarcWeber> musasabi: I haven't found info on the wiki page and on the jhc page..
03:33:53 <Fri22537> i dont think john m. is a regular visitor here, otherwise you could have asked it himself
03:36:36 <musasabi> MarcWeber: It is about 3 things, 1) the main jhc code (GPL), 2) the thih code (this was BSD3 iirc), 3) marking that the libraries are BSD licensed (not yet done, the upstream is BSD but there are some modifications...)
03:37:30 <musasabi> I think the best course of action would be mailing john and ask for the information in a more clear format.
03:38:17 <MarcWeber> musasabi: Ok.. I first get it working.. And then I'll see ;)
03:54:29 <gennet1> MarcWeber: how usable is jhc these days?
03:55:59 <MarcWeber> gennet1: I don't know.. I want to test it.. And to have a easy to use deinstallation.. I wanted to create an ebuild..
03:56:11 <MarcWeber> gennet1: I even don't know haskell quite well, yet
03:56:47 <gennet1> okay; i was just wondering how much resource it really took to compile something
03:56:59 <gennet1> i'm guessing that ghc would be bigger than it could handle....
04:57:59 <musasabi> I am having problems with functional dependencies and type inference - for some reason variables that should unify fail to unify.
04:58:16 <musasabi> http://youzen.b2.fi/~musasabi/f.hs contains my example code (~ 10 lines).
04:59:14 <musasabi> The functional dependency seems to work on the outer level, but somehow it does not continue it.
05:08:59 <ski> data Foo2 a = Foo; data Wrap2 a = Wrap2 a; instance Imp2 (Foo2 a) (Wrap2 a);
05:09:01 <ski> 'foo' says 2nd arg 'Wrap' should have type 'forall a b. (Imp2 (ctx a) b) => a -> b', e.g. one possible instance of that type that it should be able to have is 'forall a b. a -> Wrap2 a' and 'Wrap' most certainly don't support that as an instance of it's type
05:09:31 <ski> (correction : 'data Foo2 a = Foo2; ...')
05:10:50 <ski> 'foo' wants it's second arg to have a general (polymorphic, class-constrained) type, and the given argument 'Wrap' doesn't have a type that general
05:10:52 <musasabi> ski: but ctx is fixed in the outer level.
05:11:15 <ski> hm
05:12:40 <musasabi> I think it needs to be told, that there are no more "instance Imp2 (Foo x) y" which should be clear from the functional dependencies (all such instances would violate them), but that is not inferred.
05:13:06 <ski> you may be right
05:13:25 <ski> it anyway seems not to draw that conclusion
05:14:57 <musasabi> I'll try the ghc HEAD (it has some functional dependency related fixes) and then send a mail to the -cafe.
05:15:06 <Fri22537> @hoogle bound
05:15:08 <lambdabot> Array.bounds :: Ix a => ((Array a b) -> (a, a))
05:15:08 <lambdabot> Prelude.minBound :: Bounded a => a
05:15:08 <lambdabot> Prelude.maxBound :: Bounded a => a
05:16:05 <ski> musasabi : ok
05:26:55 <poetix> @pointless acc n = newIORef n >>= \cell -> return $ \i -> (modifyIORef cell (+ i) >> readIORef cell)
05:26:57 <lambdabot> acc = (liftM2 flip (((>>) .) . (. (+)) . modifyIORef) readIORef `
05:26:57 <lambdabot> fmap`) . newIORef
05:35:13 <poetix> @type acc = (liftM2 flip (((>>) .) . (. (+)) . modifyIORef) readIORef `fmap`) . newIORef
05:35:25 <lambdabot> bzzt
05:35:30 <poetix> @type (liftM2 flip (((>>) .) . (. (+)) . modifyIORef) readIORef `fmap`) . newIORef
05:35:32 <lambdabot> bzzt
05:36:11 <poetix> @type newIORef n >>= \cell -> return $ \i -> (modifyIORef cell (+ i) >> readIORef cell)
05:36:13 <lambdabot> bzzt
05:36:25 <poetix> ???
05:36:41 <Lemmih> 'newIORef' and the others aren't in scope.
05:37:09 <poetix> Can the 'bot import modules?
05:38:16 <Lemmih> @type \n -> Data.IORef.newIORef n >>= \cell -> return $ \i -> (Data.IORef.modifyIORef cell (+ i) >> Data.IORef.readIORef cell)
05:38:18 <lambdabot> forall a.
05:38:18 <lambdabot>                                           (Num a) =>
05:38:18 <lambdabot>                                           a
05:38:20 <lambdabot>                                           -> IO (a
05:38:22 <lambdabot>                                             -> IO a)
06:05:14 <Fri22537> is there preference for (a,b,c) over {..=a, ..=b, ..=c} ?
06:05:20 <Fri22537> of vice versa
06:05:33 <Fri22537> in terms of speed/mem usage/etc
06:05:34 <Fri22537> ?
06:06:13 <musasabi> It mostly a stylistic question.
06:06:20 <Igloo> no
06:06:35 <Fri22537> no?
06:06:48 <Igloo> In answer to your question
06:06:53 <Fri22537> ow ok :D
06:06:59 <Fri22537> i thought you were negating musasabi
06:07:03 <Fri22537> his statement
06:07:12 <Igloo> I wouldn't dare  :-)
06:07:33 <Fri22537> I prefer records in this case because it provides a means for defaulting values
06:08:03 <Fri22537> but i was wondering if there was a penalty on mem/speed i guess not :) thanks
06:08:40 <musasabi> tuoles are records with a fancy syntax.
06:08:44 <musasabi> *tuple
06:09:22 <musasabi> "data (,,) a b c = (,,) a b c" (but that is not valid haskell)
06:10:28 <ski> Fri22537 : defaulting values ?
06:13:27 <Fri22537> making a default record...and then only overwriting certain values using default{ foo=...}
06:14:00 <Fri22537> musasabi, maybe so, but tuples dont support the overwriting syntax that i like
06:14:10 <Fri22537> not as nice in any case
06:15:24 <musasabi> Fri22537: true, but that is the same case with "data Foo = Foo a b c".
06:15:32 <shapr> musasabi: Isn't that called punning?
06:15:39 <musasabi> make that even data Foo a b c = ...
06:16:04 <musasabi> punning? (too hot to get any puns)
06:16:22 <ski> musasabi : i'd say tuples are algebraic datatypes with one constructor), with a fancy syntax
06:16:48 <shapr> I think there is 'overwriting syntax' that's called field punning or something.
06:17:12 <Fri22537> cu all, its weekend
06:17:14 <shapr> It's not in GHC though, but in another Haskell implementation, maybe nhc?
06:17:51 <musasabi> ski: exactly :-)
06:18:10 <ski> iirm punning is e.g.   absP2D (Point2D {x,y}) = sqrt (x*x + y*y)
06:18:20 <shapr> http://www.dcs.gla.ac.uk/mail-www/glasgow-haskell-bugs/msg01657.html
06:18:46 <ski> possibly there is also punning for functional record update (can't remember)
06:19:23 <Philippa_> damn, that should've been kept IMO unless I've missed a really good reason not to?
06:19:27 <shapr> http://research.microsoft.com/~simonpj/Haskell/records.html
06:19:40 <shapr> "Unlike Haskell 98, we allow punning: \n  f2 :: { x,y :: Int } -> Int \n  f2 { x, y } = x + y"
06:20:30 <shapr> SPJ certainly likes it.
06:20:44 <shapr> musasabi: How hot is it there?
06:20:50 <shapr> @temperaturein Helsinki
06:20:50 <lambdabot> Unknown command, try @listcommands.
06:21:21 <ski> if punning in pattern, me thinks punning in expressions should also be allowed (consistency, similarity of pattern and expressions)  e.g. foo x y = Point2D {x,y}
06:21:26 <shapr> @weather Helsinki
06:21:27 <lambdabot> Unknown command, try @listcommands.
06:22:10 <musasabi> shapr: about 27C inside at the moment.
06:22:23 <shapr> That is rather warm.
06:22:38 <ski> here it pours down .. :/
06:22:49 <musasabi> outside 23 - it is dropping slowly :-)
06:23:09 <ski> (19 degrees Celcius)
06:24:07 <ski> (shapr : found some slides which talks about signal transformers and comonads .. interested ?)
06:24:53 <shapr> Yes, definitely interested, but I'll wait and ask you again on Sunday. I'm planning to binge on FLM today and tomorrow.
06:25:05 <ski> sure
06:26:00 <tomdavie> shapr: you use QuickCheck don't you?
06:26:07 <shapr> tomdavie: Yeah, I've used it.
06:26:37 <tomdavie> what am I missing? When I try to compile a program that uses it I get errors about not finding the QuickCheck module
06:26:37 <shapr> You have some questions about it?
06:26:49 <tomdavie> I've used -package QuickCheck, and it's finding it
06:27:10 <basti_> hi!
06:27:13 <tomdavie> lo
06:27:15 * basti_ has vacations now
06:27:18 * basti_ bounces
06:27:20 <tomdavie> jammy git
06:27:23 <shapr> tomdavie: So, what's the problem? I don't understand.
06:27:28 <shapr> hiya basti_!
06:27:35 <basti_> hi shapr
06:27:39 <ski> tomdavie : Debug.QuickCheck ?
06:27:40 <tomdavie> sort.hs:1:0:
06:27:40 <tomdavie>     Failed to load interface for `QuickCheck':
06:27:40 <tomdavie>         Could not find module `QuickCheck':
06:27:52 <tomdavie> that may be it
06:28:30 <ski> (shapr : btw, haven't read those slides properly myself, yet)
06:28:35 <tomdavie> yep... that was it ski
06:28:45 * tomdavie smack on head
06:29:50 * ski leaves
06:30:16 <tomdavie>  /cookie ski
06:30:29 <tomdavie> hmm... time to build QC with hat
06:31:07 <shapr> Signals and Comonads and Arrows, Oh My!
06:35:27 <pejo> I put "GhcHcOpts += -DDEBUG" in build.mk, removed stage1 and did a make. Do I need to do anything to activate it or do I need to do a complete rebuild?
06:36:03 <pejo> ("+RTS -Ds -RTS" doesn't do much at all, except give an error message about -Ds option not existing).
06:37:22 <pejo> Oh yeah, I did a make clean in rts/ before rebuilding too.
07:04:49 * an_eerie_silence predominates
07:05:42 * shapr hops
07:06:05 * AtnNn hops after shapr
07:06:30 * shapr hops on a unicycle
07:07:23 * AtnNn hops on a monocycle
07:07:48 * the_black_knight hops
07:08:12 <poetix> Come back here! I'll bite your legs off!
07:08:18 <shapr> It's just a flesh wound!
07:08:26 <shapr> AtnNn: Are you at Chalmers?
07:08:40 <AtnNn> no, what is that?
07:08:51 <AtnNn> who?
07:09:17 <shapr> Chalmers is a university in GÃ¶teborg
07:09:28 <AtnNn> oh, sweden right?
07:09:40 <AtnNn> this is just a shell
07:09:48 <AtnNn> <-- canadian
07:10:30 <earthy> shae is a usanian, doesn't say he's in the usa...
07:16:19 <shapr> Yeah, I'm from Alabama, but I live in Sweden.
07:16:57 <AtnNn> im from canada but i live on irc
07:17:04 <earthy> :)
07:17:16 <shapr> I can dig it.
07:17:24 <shapr> I've been on irc since 1989.
07:17:32 <earthy> whoa!
07:17:35 * earthy bows to the old hand
07:18:28 <AtnNn> heh, im not that old
07:18:50 <earthy> well...
07:19:00 <AtnNn> oh, shapr, i knew id seen your nick somewhere before
07:21:34 <shapr> AtnNn: Where was it?
07:22:22 <shapr> I've only had the nick shapr since 1992 or so.
07:22:29 <jlouis> ideas for an TMR article?
07:22:51 <shapr> jlouis: You could show off the SMP abilities of the dev version of GHC
07:23:09 <shapr> jlouis: You could give a short intro of GHC internals for the bug/performance party.
07:23:20 <jlouis> ;)
07:23:42 <shapr> You could show how monad transforms have different semantics in different combinations.
07:23:51 <AtnNn> shapr: bash.org
07:24:00 <shapr> I can come up with a near infinite number of ideas.
07:24:03 <shapr> AtnNn: Oh, yeah...
07:24:25 <jlouis> shapr: that was 3
07:24:27 <jlouis> thanks
07:24:45 <AtnNn> i started around 96, like this: www.bash.org/?2121
07:25:36 <shapr> jlouis: Do you want more?
07:28:44 <jlouis> shapr: nope
07:28:52 <shapr> You could write demos for some of the rarely used features of GHC, you could hack the GHC build process so that everyday apps can have .hc files generated for them, start a coding contest based on existing problems, write up coding puzzles... or see http://www.haskell.org/tmrwiki/ArticleIdeas
07:29:56 <shapr> Jyp's article is looking nice: http://www.haskell.org/tmrwiki/PracticalGraphHandling
07:31:02 <shapr> AtnNn: So, are you using Haskell for for fun or for work?
07:32:27 <earthy> isn't work supposed to be fun as well?
07:34:50 <shapr> If it was fun people would pay others to do it.
07:36:47 <AtnNn> shapr: fun and prep for CS
07:40:31 <gennet1> am i right in thinking that the y combinator doesn't have a type?
07:40:50 <shapr> Yes, but you've got fix.
07:42:20 <earthy> um. uuuummmmm..
07:42:29 <earthy> the y combinator *does* have a type. just not in every typesystem.
07:42:46 <shapr> Oh, good point
07:42:49 <gennet1> not in haskell, then
07:46:01 <ndm> shapr: i talked to my supervisor, a TMR article is fine, but not for a few months
07:46:21 <ndm> i want to hack in class support and GHC libraries support before i put out a TMR article
07:46:34 <shapr> Awright, good to know.
07:46:35 <ndm> but if you give me details, i'll start writing bits of it slowly over time
07:46:48 <ndm> as long as its not published until its done
07:46:58 <ndm> so private on the wiki
07:47:04 <shapr> Well, not much details to give... create a user account and I'll add you to the AuthorGroup
07:47:32 <shapr> And make sure that your article has the ACL set to "-All:read"
07:47:51 <shapr> That way only other authors will be able to read the article, but not the public.
07:48:19 <shapr> That seems to work well for getting feedback on grammar and pointers to other info.
07:49:06 <ndm> shapr: NeilMitchell, account created
07:49:38 <tomdavie> anyone here care to suggest a linux irc client that doesn't involve emacs?
07:49:39 <ndm> oh, thats in the full haskell wiki, i guess i need a tmrwiki one as well
07:49:45 <ndm> eric
07:49:56 <ndm> tomdavie: eric, sucks but useable over ssh
07:50:21 <gennet1> tomdavie: xchat-2; it also has a ncurses client useable over ssh
07:50:45 <poetix> shapr: Suggestion for the graph handling article
07:50:46 <ndm> shapr: now NeilMitchell
07:51:12 <AtnNn> tomdavie: irssi
07:51:16 <shapr> poetix: What about it?
07:51:22 <shapr> ndm: Ok, you're in.
07:51:32 <shapr> hi cmb21
07:51:32 <cmb21> hello
07:51:37 * tomdavie prods chris with a sharb stick
07:51:38 <poetix> shapr: rename fold and unfold to foldG and unfoldG, so it's clear from earlier on that these are specialised functions for graphs
07:51:49 <tomdavie> and a sharp one
07:52:03 <shapr> poetix: Well, put in the feedback somewhere in the article, that's what I suggest.
07:52:10 <poetix> Will do
07:52:15 <shapr> poetix: Or talk to jyp when he's here on #haskell, he's the author.
07:52:32 <poetix> shapr: Would have done, only he's not here right now...
07:52:37 <shapr> ok
07:53:05 <poetix> The implementation of unfold is quite interesting
07:53:07 <shapr> ndm: Oh, it'll make life easier if you create a user page as well with at least minimal contact details.
07:53:23 <shapr> cmb21: Are you chris?
07:53:27 <cmb21> Yes
07:53:37 <tomdavie> yeh... but who wants an easy life
07:54:35 <shapr> ndm: Only authors will be able to read the page if the topmost line is: #acl -All:read Default
07:55:08 <ndm> http://www.haskell.org/tmrwiki/Hoogle
07:55:18 <ndm> i'll add contact details later - have to go now - thanks and bye
07:55:26 <shapr> Awright, thanks!
07:56:07 * shapr bounces cheerfully
07:56:11 <shapr> I'm glad TMR is doing well.
08:00:09 <tomdavie> where on earth does QuickCheck usually live?
08:00:18 <shapr> In Sweden?
08:00:26 <tomdavie> boom boom tish
08:01:07 <shapr> tomdavie: Usually it's Debug.QuickCheck
08:01:11 <shapr> hiya mwc, how's the leg?
08:01:16 <tomdavie> locate QuickCheck.hs found nothing in ghc land
08:01:28 <shapr> try "locate QuickCheck"
08:02:40 <tomdavie> ah yes
08:02:53 <tomdavie> hmm...
08:03:12 * tomdavie wonders why it isn't just the single module distributed on the QC webpage
08:03:29 <shapr> It is, sort of, but the GHC version includes some nifty utils.
08:04:54 <tomdavie> interesting... so if I hatify the QuickCheck module and dump it in include/hat/Hat/Debug/ it should work
08:08:11 * tomdavie wonders how to make an hi file
08:10:02 <Igloo> Compiling the module will make one
08:10:28 <tomdavie> yeh... that's what I thought
08:10:33 <tomdavie> I'd buggered it earlier though
08:10:36 <tomdavie> gtg
08:12:27 <poetix> Is there a document explaining the motivations and intended use of the ST Monad?
08:12:37 <xerox> shapr: what was the url of the Arrow article?
08:12:59 <Igloo> ST gives you the performance of the IO monad without actually having to be in the IO monad
08:13:33 <poetix> So mutable refs like IORefs, but with a way back out into non-monadic code?
08:13:36 <Igloo> So you can have a pure function that internally uses mutable arrays and mutable reference cells
08:14:13 <poetix> So unlike the State monad, that is still really pure internally, it encapsulates some real impurity
08:16:20 <poetix> Given that, why (or where) would you prefer the State monad to the ST monad?
08:16:23 <Igloo> I'm not sure exactly what you mean. If you runST the same computation twice you will get the same answer both times
08:17:24 <Igloo> The State monad is a bit simpler if you just want a state monad, I'd say
08:18:12 <poetix> Igloo: Difference in implementation (I'm guessing) - actual mutation of cell values versus just passing a state value from one computation to the next
08:18:33 <Igloo> right
08:19:11 <poetix> Really impure things happen in the ST monad, but the impurity is encapsulated so that runST is harmless
08:19:34 <poetix> I imagine an implementation based on IORefs and unsafePerformIO
08:22:34 <poetix> I guess you'd use IORefs rather than STRefs if you were already in the IO monad...?
08:26:14 <Igloo> Yes
08:28:25 <shapr> xerox: It's not done yet, but it's http://www.haskell.org/tmrwiki/ArrowsIntroduction
08:34:21 <shapr> hiya tmoertel, how's code?
08:34:41 <tmoertel> shapr: hi! things are good here. how about you?
08:35:09 <shapr> The code is flowing.
08:35:29 * tmoertel just noticed that WashNGo has been updated for GHC 6.4
08:35:45 <Igloo> Does anyone know of a decent Haskell MIME module, BTW?
08:36:12 <shapr> There's a passable MIME module that's part of WASH.
08:36:20 <CosmicRay> Igloo: WASH has some MIME stuff.
08:36:23 <Igloo> Aha, ta
08:36:30 <CosmicRay> Igloo: I believe I have intergrated it into MissingH
08:36:38 <CosmicRay> so if you don't want all of Wash, you can just steal it from there
08:37:01 <shapr> Igloo: btw, what did you end up doing for the tags?
08:37:13 <Igloo> Why is stealing it from there easier than from WASH OOI?
08:37:35 <Igloo> shapr: Waiting to see if Peter replies with anything useful
08:37:41 <CosmicRay> Igloo: wash is not the easiest to install everywhere (non-cabalized, odd build system)
08:38:04 <shapr> Yeah, it's a PITA.
08:38:11 <Igloo> By "steal" did you mean "compile with" or "copy the module from"?
08:38:28 <CosmicRay> whatever you prefer
08:38:39 <CosmicRay> I also have a mime.types module in MissingH
08:39:15 * Igloo has lost the thread, but I'll check out both WASH and MH anyway  :-)
08:39:15 <CosmicRay> and some wrapper code around what WASH gives you
08:39:26 <CosmicRay> The WASH stuff is in MissingH as MissingH.Wash
08:39:48 <CosmicRay> there's also MissingH.MIMETypes and MissingH.Email.Parser
08:40:29 <Igloo> shapr: For now I just have "instance Contains p e", so I can make invalid HTML, so it's not a show stopper while I'm just fiddling
08:40:43 <shapr> ok, just curious.
08:43:44 * CosmicRay gripes about there not being a working reiser4 patch for 2.6.12
08:43:46 <CosmicRay> err, ww
08:44:45 <shapr> I can't get one working for 2.6.11
08:46:19 <CosmicRay> shapr: ftp.namesys.com/pub/reiser4-for-2.6/2.6.11
08:46:34 <CosmicRay> shapr: I am a big reiser4 fan
08:46:46 <shapr> Yeah, I've been trying to do reiser4 myself.
08:47:54 <gennet1> isn't reiser4 already in -mm?
08:48:08 <CosmicRay> gennet1: yes, but I don't run -mm
08:48:17 <CosmicRay> I'm giong to have to though because 2.6.11 doesn't build with gcc43
08:48:20 <CosmicRay> err gcc4
08:48:26 <gennet1> fair enough
08:48:44 <gennet1> i'm on gentoo, which is still gcc 3.4 (you can go for 4, but that's a "you're out on your own" way)
08:48:47 <CosmicRay> anyway, x.org installing on my thinkpad, woohoo :-)
08:48:58 <CosmicRay> gennet1: isn't that what all of gentoo is? :-)
08:49:09 <shapr> CosmicRay: Hey, are you using nvidia drivers with xorg debs?
08:49:22 <CosmicRay> shapr: I will be on my desktop at home, once I get it upgraded
08:49:23 <takuan> CosmicRay: using debian?
08:49:30 <CosmicRay> takuan: yes
08:49:36 <takuan> tried xorg already?
08:49:52 <CosmicRay> shapr: have to use the nvidia drivers to get proper acceleration for playing HDTV streams from mythtv, you know ;-)
08:49:54 <takuan> or busy trying
08:49:57 <CosmicRay> takuan: just doing so now
08:50:04 <CosmicRay> I've used it before, but with homebrew packages, not debian's
08:50:30 <takuan> anything better or worse?
08:51:07 * CosmicRay doesn't understand the question
08:51:16 <CosmicRay> are you asking if xorg is better than xfree86?
08:51:18 <takuan> better or worse than xfree?
08:51:24 <CosmicRay> ah.  better.
08:51:29 <CosmicRay> x.org is all good.
08:51:36 <takuan> in what respect?
08:51:39 <CosmicRay> I can't think of a single bad thing about it, compared to xfree86
08:51:59 <CosmicRay> better hardware support is what I care about.  better internal architecture and all sorts of new eye candy extensions matter to others :-)
08:53:05 <takuan> hehe
08:53:32 <CosmicRay> also xfree86 changed their license, so many distros, including debian, were frozen at a particular point in time
08:53:40 <CosmicRay> plus all the really good xfree86 developers left to join x.org
08:53:42 <takuan> indeed
08:57:01 * CosmicRay got his first bluetooth phone yesterday
08:58:20 * CosmicRay builds a kernel with bt support
08:58:25 <shapr> haha
08:58:26 <CosmicRay> I forgot that my laptop supported bt :-)
08:58:36 <shapr> That'll be nifty.
08:58:37 <CosmicRay> I was about ready to start googling for usb dongles
08:58:58 <shapr> I've often wished for cell phones that support wifi so I can make free calls whenever possible.
08:58:59 <CosmicRay> now to find a couple of ring tones that sound like ringing
08:59:11 <CosmicRay> shapr: these are in the pipeline
08:59:32 * CosmicRay is ticked at phones that have only one crap-sounding ringtone that actually sounds like ringing
09:00:10 <CosmicRay> I want at least *two* crap-sounding ringtones that sound like ringing, dammit!  one for my wife and one for everyone else :-)
09:01:36 <CosmicRay> stupid old free phones can do that, WHY does the motorola v551 have nothing but musical ringtones?  grr.
09:02:02 <shapr> I want a linux based phone that's more like a tiny laptop.
09:02:09 <shapr> Then I can just fix the stupidities.
09:02:12 <CosmicRay> heh
09:02:41 <shapr> Same for my iriver digital music player.
09:04:18 <shapr> I want one button music play and one button record on my iriver. I'd also like to upload play info into audioscrobbler.
09:04:59 <mflux_> the recording should also be instantenous, buffering while spinning up the hd
09:06:01 <shapr> In any case, hackable hardware is *far* more valuable to me than an information 'appliance'
09:06:04 <mflux_> I also think iriver already has linux.. just limited hackability
09:06:33 <shapr> The same is true for my household appliances as well. I'd like to be able to tune my coffee maker, dishwasher, stereo system, etc
09:06:47 * CosmicRay is all with shapr, well mostly
09:06:54 <CosmicRay> I want my dishwasher to Just Work
09:07:03 <CosmicRay> I want to hack me thermostat to my heart's desire, though
09:07:06 <mflux_> shapr, yes, all that would be nice, but the thing is, such people are a minority ;)
09:07:07 <shapr> Yeah, until you think of some cool idea to make it better.
09:07:12 <CosmicRay> none of the digital thermostats are customizable enough
09:07:19 <shapr> mflux_: you think so?
09:07:30 <CosmicRay> and I want the two different heating/cooling systems in our house to be centrally administerable, remotely, from my asterisk box
09:07:32 <shapr> I really don't know. It's true that I haven't met so many.
09:07:53 <CosmicRay> so I could dial in, hit a code, and adjust the indoor temp before I get home.
09:07:57 <shapr> Thing is, I know enough to improve the performance of machines for my situation, and I have the motivation to do that too.
09:09:22 <shapr> I had a 1978 Dodge van, they have the engine between the driver and passenger. I'd drive around with the internal hood off and the distributor cap loose so that I could adjust the timing by hand for different situations.
09:09:50 <Igloo> CosmicRay: That's just a matter of spending cash on some X10 kit and a bit of time, isn't it?
09:10:31 <CosmicRay> Igloo: I refuse to buy from a company that pesters the entire 'net with popunders targetted at cheap voyeurs
09:10:58 <Igloo> Is X10 a company? I thought it was a standard or something
09:11:11 <CosmicRay> x10.com
09:11:39 <CosmicRay> maybe it is a standard.  I didn't know they did thermostats.
09:12:03 * CosmicRay boots into his shiny new bt-aware kernel.  hopefully.
09:12:06 <shapr> I'd like to start a free wikizine like Make. I'd call it something like Artificer, or Artisan, or something like that.
09:12:21 <CosmicRay> not TMR? :-)
09:12:23 <Igloo> http://en.wikipedia.org/wiki/X10
09:12:39 <CosmicRay> thanks igloo
09:12:42 <shapr> TMR is Haskell specific, I'm talking a zine that would discuss iriver hacks, etc
09:12:56 <CosmicRay> otoh this would require me to run AC power to my devices, it looks like
09:13:44 <CosmicRay> hm, or not
09:13:49 <CosmicRay> looks like there is a companion rf protocol
09:14:19 <Igloo> http://en.wikipedia.org/wiki/Home_automation lists a handful more standards
09:14:39 <CosmicRay> urgh, the official x10 website is x10.com
09:14:55 <Igloo> Err, but they include DECT, so they might not all be applicable
09:17:28 <CosmicRay> woohoo
09:17:31 <CosmicRay> X Window System Version 6.8.2 (Debian 6.8.2.dfsg.1-2 20050712162020 david@squee.
09:17:35 <CosmicRay> that was incredibly easy.
09:17:45 <CosmicRay> apt-get dist-upgrade, answer ONE question, and there's a working x.org.
09:40:04 <genneth> CosmisRay: xorg has been getting very much better at the self-configuration stuff
09:43:15 <ski> http://www.cs.chalmers.se/~magnus/haskell/
09:58:23 <SyntaxNinja> 'morning
09:58:38 <Igloo> Nope
10:14:16 <Lemmih> Hey SyntaxNinja.
10:18:17 <musasabi> SyntaxNinja: did you get the cabal haddock hidden modules idea/patch?
10:48:44 <BrazilPortuguese> Somebody understands of Scheme?
10:53:20 <Oeje1> BrazilPortuguese: I'm familiar with the syntax.
10:55:07 <Lemmih> heh
10:56:24 <earthy> um brasileiro!
10:56:29 <earthy> nao e'!
10:57:11 <jlouis> BrazilPortuguese: yes
10:57:26 <lightstep> Oeje1, what syntax?
10:57:37 <earthy> [] () car cdr? :P
10:58:07 <lightstep> [] vs () is a matter of lexing
10:58:16 <lightstep> car and cdr are a matter of semantic
10:58:17 <lightstep> s
11:00:05 <wagle> BrazilPortuguese: what do yhou need to know?
11:02:58 <wagle> he came.  he queried.  he faded into the void.
11:07:11 <lightstep> she provoked 6 persons to reply
11:14:33 <BrazilPortuguese> How functions the search for an element given in a binary tree?
11:16:27 <lightstep> a binary tree of what type?
11:17:17 <astrolabe> Is this related to the scheme question?
11:18:03 <BrazilPortuguese> astrolabe: yes
11:19:41 <lightstep> BrazilPortuguese, usually, you check the left subtree, then the right subtree
11:19:56 <BrazilPortuguese> lightstep: It is a binary tree where not necessarily the elements of the left tree are lesser of that the root. Therefore she is necessary to verify value for value.
11:20:26 <lightstep> so you need to go over the whole fringe anyway
11:20:32 <lightstep> in the worst case
11:21:08 <astrolabe> So, search the left subtree, and if its not there then search the right subtree?
11:21:18 <astrolabe> *it's
11:21:47 <BrazilPortuguese> astrolabe: yes
11:25:01 <astrolabe> BrazilPortuguese:  If that doesn't answer your question then I don't understand what the question was.
11:27:22 <BrazilPortuguese> Probably he is something seemed with: (define (buscar valor arvore) (if (null? arvore) 'não_encontrado (cond ((= valor (car arvore)) 'encontrado) ((= valor (cadr arvore)) 'encontrado) (else (buscar valor (cadr arvore)) (buscar valor (caddr arvore))))))
11:29:19 <chrisbro1n> hello
11:29:21 <lightstep> you're mixing representation with algorithm with specification
11:29:25 <lightstep> it's unclear
11:30:42 <lightstep> BrazilPortuguese, what is the format of the tree? are the values in the nodes? probably they're not on the fringe
11:34:05 <astrolabe> My guess is a tree is () or (valor treeL treeR)
11:35:09 <astrolabe> and that arvore means tree, valor means value, buscar is the find function.
11:35:27 <lightstep> also, it seems there is some infix space operator
11:36:14 <lightstep> which acts as an `or' for home-made booleans
11:36:46 <astrolabe> lightstep: where is that?
11:36:59 <lightstep> in the `else' clause
11:37:13 <lightstep> but i just glanced; idn't check the parens and stuff
11:37:50 <astrolabe> Ah, I knew there was some giveaway that it was lisp :)
11:39:00 <astrolabe> I've never heard of a space operator in lisp, maybe that's a bug?
11:39:26 <lightstep> i think it's a new r6rs feature, or a new srfi. they got envy of c++ having it
11:39:33 <araujo> probably a bit off-topic, what is a good program to create online-stores?
11:40:20 <yosemite> araujo: I have used interchange.  I really don't think it's that "good" though
11:40:27 <AtnNn> araujo: lisp
11:40:42 <yosemite> I'd probably just roll my own now
11:41:02 <araujo> AtnNn, well, i just would like to know if there exist already a good one...
11:41:05 <marcot> Hello, I'm trying to package a library with haskell, but I'm having the following problem:
11:41:17 <astrolabe> According to amazon, my Haskell report has just dispatched.
11:41:18 <araujo> yosemite, i wil check interchange, thanks
11:41:23 <marcot> Configure was ok, but in build I got:
11:41:41 <marcot> marcot@tonhao:~/gpc-haskell$ runghc Setup.hs build
11:41:41 <marcot> Preprocessing library GPC-Haskell-2.31.0...
11:41:41 <marcot> can't find source for GPCHaskell.chs in ["src/"]
11:41:45 <lightstep> I figured out what's with the offtopic discussions: the topic no longer contains "we put the funk in funktion"
11:41:46 <marcot> marcot@tonhao:~/gpc-haskell$ ls src/GPCHaskell.chs
11:41:47 <marcot> src/GPCHaskell.chs
11:41:47 <marcot> marcot@tonhao:~/gpc-haskell$
11:42:26 <marcot> Why it's not finding GPCHaskell.chs ?
11:43:22 <Lemmih> marcot: You should write the name of the module, not the name of the file.
11:43:32 <marcot> Lemmih: is it?
11:43:43 <musasabi> marcot: use GPCHaskell without the chs.
11:44:31 <marcot> Lemmih: musasabi: Ok, thanks.
11:46:33 <marcot> Now it's calling c2hs as:
11:46:46 <marcot> usr/bin/c2hs -o src/GPCHaskell.hs src/GPCHaskell.chs
11:46:50 <marcot> But it should call it as:
11:47:09 <marcot> c2hs new_form.h GPCHaskell.chs
11:47:54 <Lemmih> Can't you include new_form.h from GPCHaskell.chs?
11:48:43 <marcot> #include "new_form.h"
11:48:49 <marcot> This in GPCHaskell.chs ?
11:49:35 <Lemmih> I don't know. Haven't used C->Hs.
11:49:43 <marcot> hum..
11:49:48 <marcot> It worked.
11:49:56 <marcot> But now I got a strange problem.
11:50:05 <marcot> marcot@tonhao:~/gpc-haskell$ runghc Setup.hs build -v5
11:50:05 <marcot> Preprocessing library GPC-Haskell-2.31.0...
11:50:05 <marcot> /usr/bin/c2hs -o src/GPCHaskell.hs src/GPCHaskell.chs
11:50:09 <marcot> c2hs: does not exist
11:50:09 <marcot> *** Exception: got error code while preprocessing: GPCHaskell
11:50:09 <marcot> marcot@tonhao:~/gpc-haskell$
11:50:17 <marcot> But when I run it by hand:
11:50:30 <marcot> marcot@tonhao:~/gpc-haskell$ /usr/bin/c2hs -o src/GPCHaskell.hs src/GPCHaskell.chs
11:50:33 <marcot> marcot@tonhao:~/gpc-haskell$
11:50:36 <marcot> It works.
11:51:27 <marcot> What does he means with this c2hs: does not exist error message?
11:51:48 <musasabi> There was at least one bug related to c2hs in cabal.
11:51:57 <Lemmih> '#include "src/new_form.h"' or maybe '#include "../new_form.h"'?
11:52:31 <musasabi> if it is cabal failing and not c2hs.
11:54:01 <marcot> Lemmih: c2hs is running ok.
11:54:08 <marcot> The problem is when cabal calls it.
11:54:17 <marcot> musasabi: where can I get info about this bug?
11:57:36 <marcot> I'm leaving now, latter I'll try to debug this. Thanks.
12:31:20 <jyp> any Yi hacker hacker around ?
12:31:37 <jyp> errr, any Yi hacker around ?
12:31:46 <jyp> shapr, dons ?
12:32:46 <jyp> nm
12:38:29 <Itkovian> evening
12:38:54 <SyntaxNinja> hi
13:04:49 <ape> hello!
13:06:36 <jyp_> hi
13:08:07 <ape> what's up?
13:09:33 <jyp_> I got Yi compiled, now I try to understand the Emacs "keymap"
13:11:17 <ape> oh yeah, sweet... you're the yi dude
13:11:39 <jyp_> am I ?
13:12:15 <Philippa_> no, but dons&co're around
13:14:04 <jyp_> I was wondering if what is in Keymap/Emacs.hs is the state of the art, or if there was something newer to try out
13:14:12 <jyp_> anyone knows ?
13:14:40 <jyp_> The advertised author is "B.Zapf"
13:14:58 <jyp_> is he hanging out here ?
13:17:29 <Philippa_> dunno, I've not really kept up with it and won't 'til someone tells me there's a GUI version that builds easily under win32
13:20:17 <jyp_> ok
13:21:43 <sond> hi
13:22:06 <sond> what's the name of the pow() function in haskell?
13:22:40 <sond> ah.. ^
13:22:49 <sond> i just remembered now =)
13:22:58 <jyp_> @plugs 3 ^4
13:23:03 <lambdabot> 81
13:23:14 * jyp_ pats lambdabot 
13:29:35 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktional"]' by shapr
13:29:49 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion"]' by shapr
13:30:16 <shapr> jyp: Bastiaan Zapf is basti_
13:30:46 <musasabi> No new cabal with GHC 6.4.1 it seems.
13:30:51 <shapr> ape: hey, don't you go by the irc nick pipe also?
13:31:30 <musasabi> Cabal should also really have a "Cabal-Version: <version>" field.
13:31:47 <jyp> shapr: thanks
13:32:03 <shapr> musasabi: oh good point!
13:32:54 <SyntaxNinja> musasabi: some of the bug fixes will go in. I haven't given up hope of talking malcolm into it.
13:33:29 <Igloo> into putting it in nhc98?
13:33:33 <SyntaxNinja> er
13:33:35 <SyntaxNinja> simon
13:33:39 * SyntaxNinja nods slowly
13:33:44 <Igloo> OK  :-)
13:33:47 <ape> hi shapr
13:33:50 <SyntaxNinja> musasabi: you can build-depend on Cabal > 1.0 or something
13:34:09 <Igloo> That won't help if cabal can't parse your .cabal
13:34:11 <SyntaxNinja> although that's not quite right
13:34:14 <SyntaxNinja> hm.
13:38:07 <SyntaxNinja> musasabi: yeah, it could use a cabal-version field, but then 1.0 won't be able to parse it. hm. that sucks.
13:39:10 <musasabi> SyntaxNinja: could cabal be made parse unknown fields and just warn loudly?
13:40:21 <SyntaxNinja> possibly, though that doesn't help here.
13:41:05 <musasabi> It will help when e.g. a field for installing other files is added.
13:42:02 <SyntaxNinja> yeah
13:43:05 <Igloo> I think you should need to say -f/--force to make it continue regardless
13:43:30 <Igloo> And the cabal version field should be at the top so future cabals don't have to parse the whole thing to find it
14:07:31 * shapr throws monads
14:08:59 <ape> what's up shapr?
14:09:20 <shapr> That monad I just lifted!
14:10:31 <ape> cool, it's me btw
14:10:41 <shapr> you as in wolfman8k and pipe?
14:11:06 <ape> affirmative, but you should never say that nick out loud again please
14:11:56 <shapr> um, ok
14:13:16 <Cale> ape: why?
14:13:26 <ape> hi Cale! remember me?
14:13:29 <Cale> yes
14:13:53 <SyntaxNinja> are there functions for timers in haskell? I want something to happen every so often.
14:14:06 <takuan> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=318229 <= lol
14:14:13 <SyntaxNinja> something like these glut callbacks might do: file:///usr/share/doc/ghc6-doc/html/libraries/GLUT/Graphics.UI.GLUT.Callbacks.Global.html#t%3ATimerCallback
14:14:19 <SyntaxNinja> er.
14:14:19 <SyntaxNinja> heh
14:14:33 <SyntaxNinja> anyway, that's a file URL, but you get the idea... I feel like I've used something like that brefore.
14:14:52 <Cale> ape: you should probably change your username too if you don't want to be found with your old nick
14:15:26 <ape> Cale: nah, i'm just worried about channel logs
14:15:39 <shapr> takuan: I saw that guy show up on #debian-women (via tor) and say really nasty things.
14:15:47 <Cale> well, channel logs may include your join message, which includes your username
14:15:49 <shapr> ape: They show your username
14:16:02 <SyntaxNinja> haha the last part is the best
14:16:18 <takuan> shapr: didn't know there was #debian-women ;)
14:16:21 <SyntaxNinja> For the record, I am neither Debian's xorg maintainer, nor a woman.  Cheers, Daniel(le?)
14:16:40 <shapr> Yeah, that last part is funny :-)
14:17:41 <wagle> SyntaxNinja: i saw a SPJ paper on async exceptions in haskell
14:19:19 <Cale> SyntaxNinja: how accurate does it need to be? Is using threadDelay enough, or perhaps you might just make a loop with getClockTime
14:19:21 <ape> shapr: i don't see it in the web log in the topic
14:19:36 <Cale> or getCPUTime for that matter
14:19:46 <shapr> ape: It's there, really.
14:19:54 <wagle> or use Timber..  8)
14:20:36 <ape> shapr: hm... looks like you are correct
14:21:03 <SyntaxNinja> yeah, threadDelay is probably what I want
14:22:58 <Cale> http://meme.b9.com/~13ff24dbcdbc4f0b73a77aeb~/cview.html?channel=haskell&date=today -- search for "join: ape"
14:24:39 <ape> Cale: yeah, seen that
14:28:27 <jyp> night folks
14:30:12 <ape> so how are things going Cale?
14:34:02 <Cale> ape: okay :)
14:34:11 <ape> cool
14:35:43 <gord> Cale: I stayed up until 2:30 working on Parsec over an interactive TCP/IP connection. :)
14:35:51 <shapr> Did you get it working?
14:36:41 <gord> It works mostly... my parser parses a single packet and returns a tuple of the remaining lazy input string and an IO action to the main loop, which I evaluate.
14:37:46 <gord> The only bottleneck is that it seems to need one character too much of lookahead before it will return a successful parse.
14:38:03 <gord> Otherwise, the structure is really cool.  I can define commands like:
14:38:14 <gord> > fooCommand = do string "foo\r\n"
14:38:21 <gord> erm...
14:38:29 <gord> > fooCommand h = do string "foo\r\n"
14:38:41 <gord>                     hPutStrLn h "got foo command\n"
14:39:52 <sond> are there any 3d graphics libraries for Haskell with common 3d object intersection code?
14:40:33 <ape> sond: you doing 3d graphics with haskell?
14:40:37 <sond> ape, yeah
14:40:43 <ape> cool
14:40:54 <sond> hey, i'll just go find some raytracer written in haskell..
14:41:02 <ape> sond: there are a few raytracers that should have ray intersection functions
14:41:11 <ape> sond: i did a simple raytracer
14:41:27 <sond> okay :)
14:41:49 * basti_ is back
14:41:55 <ape> basti_: hi! remember me?
14:41:59 <yosemite> wasn't the icfp a raytracer a couple years back
14:42:00 <ape> basti_: i am pipe!
14:42:09 <sond> yosemite, yes it was
14:42:10 <ape> sond: http://benny.kramekweb.com/hrayt
14:42:11 <yosemite> there is probably some haskell ones there
14:42:14 <ape> sond: there is no code there though
14:42:17 <basti_> ape: yow.
14:42:24 <ape> sond: but there are 3 other haskell raytracers that i know of
14:42:37 <Igloo> SyntaxNinja: Does cabal's parser do something cunning to ensure necessary fields are supplied?
14:42:58 <ape> basti_: i've requested to transfter to combat engineer! o_O
14:43:10 <basti_> how sad.
14:43:19 <ape> :P
14:43:22 <basti_> no really
14:43:24 <sond> ape, ok.. don't worry i'll find one
14:43:35 <sond> gotta go now though
14:43:39 <basti_> you should have the choice, and not to request this sort of thing
14:43:45 <basti_> thats what some people call freedom
14:44:10 <ape> sond: check this out http://haskell.org/hawiki/H3D
14:44:27 <ape> basti_: eh?
14:45:04 <basti_> well for example, if i dont like a job, i'm free to quit it
14:45:16 <basti_> except for if im captured in fascist regimes
14:45:57 <SyntaxNinja> Igloo: yeah, I think it checks for required fields.
14:46:06 <SyntaxNinja> Igloo: but not in the parser, in the sanity checker.
14:46:29 <Igloo> OK, so you rely on required fields not being allowed to be some value like "" or 0?
14:47:20 <SyntaxNinja> yeah
14:47:23 <Igloo> OK, ta
14:47:36 <ape> basti_: well, i think that the army here needs a major reform and it should become volunteer, but what can you do.... anyway, i've decided that since i'm already stuck in the army i'm going hardcore all the way
14:47:54 <basti_> if that is what makes you happy :)
14:48:42 <gord> shapr: I have to say, I'm a big fan of Parsec.  I haven't seen any other language besides Haskell that allows me to express a nontrivial (i.e. non-regexp) grammar alongside my actions all in the same language. :)
14:48:57 <ape> i'm hoping that it will indeed apeal to my primitive pleasure sensors
14:49:01 <shapr> gord: I'm glad my suggestion has worked for you :-)
14:49:07 <SyntaxNinja> gord: yeah, parsec rules
14:49:22 <stepcut> Any idea how parrow compares to parsec ?
14:49:46 <gord> Next on the agenda, after getting the lookahead bug fixed, is to use STM as the basis for a transient database.
14:50:03 <shapr> stepcut: All the advantages of arrows, with the downside that you can't build dynamic parsers if you want those advantages.
14:50:45 <stepcut> interesting...
14:50:45 <shapr> stepcut: Daan uses this example in his Parsec paper: xml = do name <- openTag ; content <- many xml ; endTag name ; return (Node name content) <|> xmlText
14:51:08 <shapr> It's the blackbox problem, I'm surprised just how large a problem that really is.
14:51:27 <stepcut> heh
14:52:41 <shapr> Hey, maybe you *can* do "name <- openTag ; endTag name" and get the advantages of static information in arrows, at least, once the endTag name arrow is constructed. What do you think?
14:53:20 <stepcut> hrm, I think I would have to look into parrows more first
14:53:32 <shapr> You'll lose the static property optimizations when using an (endTag name) thunk elsewhere, but you'll get partial benefits.
14:53:34 <stepcut> I have not needed to parse anything since I found out about it :)
14:54:02 <shapr> I may have to write a rebuttal to Daan's Monads vs. Arrows section.
14:54:30 <stepcut> heh
14:55:39 <Cale> stepcut: You know a library is good when just reading about it removes the particular task it performs from your life altogether.
14:55:41 <musasabi> parrows also makes it possible to compile optimized parsers in Haskell with using TH but that is not implemented at the moment.
14:56:00 <stepcut> Cale: haha
14:56:39 <shapr> Cale: bwaha!
14:57:06 <ape> =]
14:58:47 <musasabi> of course parsec is a much more complete implementation, well documented and monadic syntax is nice.
14:59:25 <shapr> PArrows is much cooler though.
14:59:45 <shapr> I especially like the show instance, that kicks butt.
14:59:45 <ape> bleeding edge is always preferable i think
15:00:24 <shapr> Maybe I should cut my ArrowsIntroduction into a series, and do one part each issue.
15:00:37 <gord> Can I read it somewhere right now?
15:00:38 <astrolabe> Perhaps there should be a language extension for arrows?
15:00:45 <shapr> There is already.
15:01:06 <ape> shapr: you've written about arrows?
15:01:17 <astrolabe> Like the do notation?
15:01:28 <shapr> astrolabe: Yes, there's a really cool syntax like that.
15:01:40 <shapr> output <- myArrow -< input
15:02:15 <shapr> And you can use a ~> b for arrow types.
15:02:25 <astrolabe> It looks good.  When are you going to finish your article?  Or the first part of it?
15:02:39 <shapr> Well, if I switch to a series I can finish it now.
15:02:51 <astrolabe> That sounds like a good plan
15:04:23 <gord> shapr: When I figure out the rest of the details, would you like an article on Parsec for interactive applications (such as an Internet server or a CLI thing) for TMR?
15:04:37 <shapr> gord: very much so!
15:04:59 <gord> shapr: Cool.  Writing something up would help me solidify my own understanding, too. :)
15:05:30 <astrolabe> At the moment I'm trying to get my head round monadic parsers by reading "Monadic Parser Combinators" by Hutton and Meijer.http://www.cs.nott.ac.uk/~gmh/monparsing.pdf . It seems like a good paper.
15:05:58 <shapr> Yeah, that's the best way to get started understanding how monadic parsers work.
15:06:18 <gord> astrolabe: What I understand as the main efficiency difference with Parsec is that it doesn't do implicit backtracking.
15:08:29 <astrolabe> I don't have a feeling for how hard it would be to get similar parser functionality in C say.
15:09:01 <astrolabe> Without monads.
15:09:37 <ape> but you can do monads in c
15:09:46 <astrolabe> ape: sure
15:11:15 <musasabi> One can do monadic parsing in jave but the end result is quite painfull.
15:11:18 <musasabi> *java
15:11:55 <ape> at least with c++ you have operator overloading which might help a litte :)
15:12:24 <astrolabe> People wrote parsers before monads came along.  What is the advantage monads give?
15:13:00 <gord> For me, mixing the parsing with the reactions in the same language.
15:13:23 <astrolabe> I suppose they give a kind of algebra of parsers.
15:13:28 <astrolabe> Thanks gord.
15:16:37 <musasabi> monads make expressing recursive descent parsers very easy in the host language.
15:16:55 <musasabi> spirit is a C++ effort with a similar intent.
15:18:09 <jlouis> anyone up for a category theory exercise I cannot solve?
15:18:32 * shapr updates the http://www.haskell.org/hawiki/HaskellUserLocations images
15:18:43 <jlouis> I cannot solve this category exercise: if P is a preorder, define an equivalence relation on P by xRy iff x <= y and y <= x. Let P/R be the quotient category of P and let F: P -> Q be the quotient map. This is obviously a functor (continued...)
15:18:50 <jlouis> But then I have to show F is an equivalence of categories, ie, there exist nat. trans. m: id_P ==> GF and n: id_Q ==> FG such that their components are isomorphism
15:18:54 <jlouis> Q = P/R
15:18:58 <jlouis> The trouble is to find the pseudo inverse G
15:21:19 <astrolabe> jlouis: What is it called if you find a true inverse?
15:21:31 <jlouis> isomorphic
15:21:53 <jlouis> if FG = id and GF = id
15:22:34 <jlouis> here we only require components of m and n to be isomorphisms, so the statemnt is weaker
15:22:48 <astrolabe> jlouis: What goes wrong if you just choose G to be be an arbitrary right inverse of F?
15:24:16 <jlouis> if you take G to be the identity, then you can actually make the naturality square hold by using F as nat. trans. but F is not an isomorphism
15:24:45 <jlouis> the problem is F is forgetful if x <= y and y <= x
15:24:55 <jlouis> it throws away one of the pairs
15:26:30 <astrolabe> Elements of Q are equivalence classes of P, so I don't see how G can be the identity
15:27:38 <shapr> Lemmih: Unicycle?
15:27:41 <jlouis> exactly
15:27:45 <jlouis> it doesn't work
15:28:53 <jlouis> hmmm, more thinking needed
15:28:55 <astrolabe> What I am suggesting is for G to take q to an arbitrary representative.
15:29:16 <jlouis> oh, i'll work on that
15:30:33 <astrolabe> So FG=id_Q, and you only need to find m
15:30:59 <jlouis> yes
15:31:18 <jlouis> I've got so long with that solution too
15:32:22 <jlouis> but now, take some b which is in the same equivalence class as q. Then q is going to be picked by GF. So we need a nat. trans. mapping b to q
15:32:28 * gord updates HaskellUserLocations with beautiful Regina, Saskatchewan, Canada (but doesn't have an xearth to regenerate the picture)
15:32:37 <astrolabe> Well m takes p to the special representative of [p], so it is an iso
15:33:18 <jlouis> huh, m can only be iso if it has an inverse m^{-1}
15:33:25 <astrolabe> The equivalence classes partition P.  q isn't in one.
15:33:50 <jlouis> oh, fuck
15:33:52 <jlouis> see it
15:34:01 <astrolabe> :D
15:35:18 <basti_> did anyone of you ever need to use the "transfer matrix method"?
15:37:50 <jlouis> hmm, I do not see this
15:37:56 <jlouis> m is not injective
15:38:32 <jlouis> and what do you mean by q isn't in one?
15:39:23 <astrolabe> But isn't |Mor(p1,p2)| = 0 or 1, so aren't all morphisms injective?
15:40:05 <astrolabe> I meant that elements of P are in equivalence classes, elements of Q are not (because they are equivalence classes).
15:41:08 <jlouis> if p1 <= p2 tehen there is f: p1 -> p2
15:41:48 <jlouis> so yes, there are only 1 or 0
15:42:49 <jlouis> yeah, it works
15:43:01 <jlouis> now I see it, heh
15:43:26 <astrolabe> Don't think about anything else!  It will fall out of your head!
15:47:00 <jlouis> haha
15:47:22 <astrolabe> I'm only going by my experience with monadic parsers.
16:19:19 <Igloo> @seen bringert
16:19:20 <lambdabot> I saw bringert leaving #haskell 22 days, 9 hours, 46 minutes and 21
16:19:20 <lambdabot> seconds ago, and I have missed 13 days, 1 hour, 46 minutes and 32
16:19:20 <lambdabot> seconds since then.
16:48:28 <shapr> Igloo: bringert is on vacation. I think he's out of the country even.
16:48:34 <ape> nice
16:48:56 <Igloo> Aha, ta
16:49:41 <ape> shapr: what about jewel, and cm_?
16:52:00 <mwc> Anybody here gotten away with handing in Haskell source as pseudocode?
16:52:16 <KrispyKringle_> hahaha
16:52:25 <mwc> no, seriously, I'm gonna do it
16:52:47 <KrispyKringle_> No, you're all talk and no action. I don't believe you have the guts to pull it off.
16:53:30 <mwc> KrispyKringle_: then what's a good Haskell pretty printer for Latex? :P
16:54:01 <KrispyKringle_> beats me. I don't use LaTeX.
16:54:02 <mwc> lambdaTeX the best?
17:00:19 <Igloo> mwx: lhs2tex I think
17:00:29 <Igloo> Oh, he left. And I spelt his name wrong.
17:00:30 <gzl> I thought that only worked for literate haskell
17:00:35 <Igloo> Other than that I'm doing great.
17:33:30 <wagle> i just stumbled over Tim Sweeny's observation that linear logic and clifford algebra's seems very similar..  anyone heard that?
17:33:54 <cm> ltu.org?
17:34:55 <wagle> Tim Sweeney
17:35:01 <wagle> rather
18:02:58 <Speck> yum yum lambic
18:03:29 <Speck> the official drink of lambda calculus
18:04:40 <ape> that's it!
18:04:57 <ape> i can't believe i didn't think of it before!
18:05:07 <AtnNn> what is lambic?
18:10:09 <ape> i'm been thinking what i want to change my name to... and now i have it! Mr. Lambda!
18:16:43 <Lunar^> shapr: http://www.artlebedev.com/portfolio/optimus/
18:38:54 <shapr> Lunar^: Yeah, I saw it.
18:39:55 <dons> morning #haskell
18:40:39 <shapr> g'day dons
18:40:56 <Igloo> yo yo
18:40:57 <shapr> Hey dons, how would you do Yi-style loading with multiple CPUs?
18:41:58 <shapr> For example, do you think it could be extended to distributed setups, asymmetric multiprocessing, or something like a cross between continuations and smalltalk images?
18:43:39 <dons> can you elaborate further?
18:44:27 <dons> you mean Yi-style like dynamic update of code?
18:44:31 <shapr> Yeah
18:44:50 <shapr> It seems like an important part of state reloading is that everything can be persisted.
18:45:13 <shapr> You also mention state upgrading. Does Erlang already do that?
18:45:22 <dons> sort of. if you can reload the state, then you can also write it out. the state is `immortal'
18:45:56 <dons> yeah, I think Erlang handles this. though I've not seen the precise rules for when and what you can do during an upgrade
18:46:06 <dons> don't know if you can change the state type itself, for example
18:46:24 <shapr> I know that Erlang can keep older version of code in memory if data instances are still in use.
18:46:40 <dons> ah, that's right. yes.
18:47:25 <shapr> Anyway, hs-plugins is rapidly approaching Erlang, it's great :-)
18:47:56 <dons> :) yeah, I just got through my 2nd phd review, so there's at least 1 more year of dynamic updatey stuff to come.
18:48:01 <shapr> yay!
18:48:48 <shapr> Lunar^: The next step after the optimus is a dynamically reshaped keyboard, where it can extrude the keys in any shape needed. The technology already exists too, just that no one has put it together.
18:51:06 <shapr> Oh, I thought of a better way to do console controllers a few days ago. There's some inexpensive flexible plastic fiber optic ribbon that's used for sensing pressure. It's sensitive enough to notice a coin placed on top of it, and you can also weigh cars with it too, doesn't damage it. I figure that should be wrapped around the controller, and then you can define your own 'controls'.
18:52:54 <shapr> There's a neat organic liquid that turns into a plastic when subjected to high voltage, that should work for dynamically reconfigured keyboards.
18:56:35 <dons> bbc says "nearly 90% of swedes telecommute during summer"
18:56:57 <dons> now that sounds nice :)
18:59:30 <dons> how warm is summer in sweden, shapr?
18:59:50 <shapr> You don't need a jacket.
18:59:57 <shapr> Most of the time...
19:00:04 <dons> :}
19:00:26 * dons wonders how cold estonia is in september
19:00:30 <shapr> It's not true. Nearly 90% of the Swedes don't do anything during summer.
19:00:38 <dons> hehe
19:00:59 <dons> got soak up a year's supply of sunshine, right?
19:01:14 <shapr> It's sort of neat, the whole place shuts down. You can still buy food, but most nonessential businesses are closed for at least a few weeks.
19:01:15 <dons>  /got to/
19:01:26 <shapr> Yeah, you have to, you won't get much during the winter.
19:01:37 <shapr> I spent three hours unicycling today, for example.
19:03:05 <dons> that's cool. i guess we get most of our work done during winter here too. but our summer coincides with christmas anyway
19:03:42 <shapr> Winters are good motivation to have a regular schedule. Close to the solstice you get about an hour of almost sunlight around noon. If you miss that for a few days in a row it feels like I'm living underground even when I'm outside.
19:05:04 <dons> and here i am complaining when i'm only getting 8 hrs of sun in winter.
19:05:35 <shapr> The problem is that I can't soak up all the sunlight, I have to sleep during some of the summer. I'd rather live in a place where the maximum amount of sunlight still leaves with about six hours of darkness.
19:09:55 <desrt> shapr; word.
19:10:12 <shapr> y0
19:10:14 <dons> hey desrt.
19:10:20 <desrt> remember that idea you had about a dynamic keyboard?
19:10:29 <desrt> that would put the most useful keys closest to where you need them
19:10:36 <desrt> dons; hi :)
19:10:44 <desrt> have you seen dasher?
19:11:20 <desrt> the second i started playing with it i was like "woh... shae would love this"
19:13:49 <dons> bah, google earth only for windows :/ even though it's open gl
19:14:24 * desrt heard a great joke the other day
19:14:30 <desrt> they're writing a direct3d backend for cairo
19:14:55 <desrt> (it's gonna be called ditz)
19:18:11 <dons> oh, but the fancy high-end google earth runs on linux. doubleplus :/
19:28:30 <shapr> desrt: Yeah, I've seen dasher.
19:30:13 <Igloo> Bah. I need to be able to say   instance Foo a => Quux Flow a; instance Bar a => Quux Flow a   but ghc won't let me even if I tell it it can be incoherent  :-(
19:30:21 <metaperl> I have a quick-and-dirty tracing question: http://scannedinavian.org/~metaperl/haskell/craft-of-fp/q/trace2.txt
19:31:06 <desrt> Igloo; where is 6.4? :P
19:31:46 <Igloo> In Debian unstable if that's what you mean, although I think uninstallable and unbuildable.
19:32:09 <desrt>   ghc6: Depends: haskell-utils but it is not going to be installed
19:32:09 <desrt>         Depends: libgmp3 but it is not installable
19:32:11 <desrt> hmmm :)
19:32:29 <desrt> but Version: 6.2.2-2
19:32:32 <desrt> ubuntu lags
19:33:18 * Igloo doubts ghc6 will be sorted in unstable until 6.4.1 releases
19:43:01 * Igloo gives up on making this work tonight and sleeps
19:43:15 <dons> night!
19:48:36 <metaperl> I have a quick-and-dirty tracing question: http://scannedinavian.org/~metaperl/haskell/craft-of-fp/q/trace2.txt
19:58:13 <liyang> metaperl: re: ``So, I would like the first guard in siPointLogic() to be a print clause to print the incoming args''
19:58:31 <metaperl> liyang: yes...
19:58:38 <liyang> metaperl: use Debug.Trace.trace ?
19:58:53 <metaperl> liyang: that is not a part of HAT is it?
19:59:01 <liyang> Nope.
19:59:08 * metaperl checks it out
19:59:13 <metaperl> liyang: I will check it out. thanks
19:59:56 * liyang tries and fails to remember the appropriate lambdabot command
20:00:26 <metaperl> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
20:00:36 <metaperl> I dont know how to use it in this case
20:01:23 <liyang> Rewrite any expression e as trace ("foo" ++ show moo) $ e
20:01:38 <liyang> It's trace :: String -> a -> a  in any case.
20:01:43 <liyang> @listcommands
20:01:43 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
20:01:43 <lambdabot> dict dict-help docs dummy easton echo elements elite eurohaskell
20:01:43 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
20:01:43 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
20:01:43 <lambdabot> hoogle hoogle+ index jargon karma karma+ karma- kind lambda learn
20:01:45 <lambdabot> libsrc listchans listcommands listmodules lojban moo more paste pl
20:01:47 <lambdabot> pl-resume plugs pointless prelude quote remember repo-add repo-del
20:01:49 <lambdabot> [4 @more lines]
20:01:56 <liyang> :-/
20:03:10 <dons> @type Debug.Trace.trace
20:03:11 <lambdabot> forall a. String -> a -> a
20:03:34 <liyang> Cheers :)
20:04:22 <dons> lambdabot has a lot of plugins these days.
20:07:54 <shapr> Uyuu: logbot?
20:09:59 <metaperl> shapr: do you mind repeating the step after apt-get source hat-ghc6
20:10:14 <metaperl> I'm trying to apply the hat patch locally
20:12:38 <shapr> apt-get source hat-ghc6 creates a directory with the deb package source. You can apply the patch there and use dpkg-buildpackage to build a patched deb.
20:12:49 <metaperl> ah, dpkg-buildpackage... hanks
20:46:46 <metaperl> Igloo: I dont understand the nhc90 and ghc5 requirements to build hat-ghc6: http://scannedinavian.org/~metaperl/haskell/craft-of-fp/q/rebuild-hat
20:52:50 <mwc> KrispyKringle: you still around?
21:03:44 <dons> in C, how can I find what the current RWX settings of a page are?
21:06:04 <Gahhh> page ? memory page ?
21:06:24 <dons> yep. mprotect can set, how can I tell?
21:06:36 <dons> 'tell' as in read the current settings :)
21:06:37 <Gahhh> not with ansi c
21:07:06 <dons> so it's OS specific?
21:07:24 <Gahhh> I believe so. it's supposed to run on OS' that don't have protection, too
21:08:14 <Gahhh> Idont know if it is part of posix, tho
21:08:58 <Gahhh> "POSIX.1b says that
21:08:59 <Gahhh> mprotect can be used only on regions of memory obtained from mmap(2)"
21:09:01 <dons> righto. I'll look around the os man pages then.
21:09:41 <dons> oh hmm. that's right, i'd forgotten the mmap requirement
21:38:03 <tjaden> hello
21:38:43 <Gahhh> what is the point of boxing in arrays ?
21:46:23 <tjaden> i'm trying to implement an #include-style mechanism in a parser written with Parsec.  I would like to use the setInput function, but I still need to open the included file and read from it in the middle of a parse, and I don't know how to go about that
21:46:49 <tjaden> i wonder if someone here has an idea?
21:53:04 <Lemmih> @seen dcoutts_
21:53:05 <lambdabot> dcoutts_ is in #haskell. I don't know when dcoutts_ last spoke.
23:23:03 <autrijus> mm SGLR parsing does look very promising
23:28:02 <Speck> autrijus, where in taiwan are you from? I have visited taipei, but I stayed in taichung for a few months
23:29:23 <autrijus> Taipei.
23:29:42 <autrijus> I'm currently near ntu.edu.tw (national taiwan university)
23:31:03 <autrijus> hm. I wonder if it's the fact I've never learned or used a tokenizer/scanner that makes me biased
23:33:25 <Speck> taida?
23:33:51 <autrijus> yeah, taida, aka taiwan daxue
23:34:10 <Speck> yeah, I walked around that area. it's a nice campus
23:34:14 <autrijus> yup
23:34:21 <Gahhh> biased against scanners ?
23:34:34 <autrijus> Gahhh: yeah. never really saw the reason for them
23:34:51 <Gahhh> autrijus: the reason is speed I believe. They are not truly necessary
23:35:44 <autrijus> yeah but by the time I started programming seriously, it's already in the 90s, and I've never really felt scanerless methods slow  :)
23:36:04 <autrijus> I don't doubt that once upon a time they are truly neccessary
23:36:39 <Gahhh> well, compilation speed still matters a lot.
23:37:57 <autrijus> *nod* but the bottleneck tends not to be in the parsing part
23:37:58 <Gahhh> for some languages heh
23:37:58 <Gahhh> for "better" languages I'd say
23:37:58 <autrijus> for "modern" languages :)
23:38:05 <Gahhh> c# is modern
23:38:13 <autrijus> C# is very slow to parse?
23:38:27 <autrijus> or do you mean it's very easy to compile from?
23:38:29 <Gahhh> c# should not be much different from c++
23:38:35 <autrijus> or that its source code are huge?
23:38:56 <Gahhh> I meant parsing and code generation
23:39:15 <autrijus> *nod* and I mean it seems that codegen dominates parsing oftentimes
23:39:53 <Gahhh> it's still important. commercial software sometimes takes a full day to build. If you can cut half an hour, it is still worth it.
23:40:09 <Gahhh> also some open source stuff like firefox, etc.
23:44:29 <autrijus> *nod*
23:57:04 <Gahhh> when you do "let a = [1,2] in a ++ [3]", would optimization just append "3" at the end of a (since a is no longer referenced after this evaluation), or would it have to create a separate list for some reason ?
