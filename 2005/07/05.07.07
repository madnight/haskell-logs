00:06:59 <Helmutt> In a do statement or what you call it... Is it only allowed to group actions? Or are functions permitted? and if I only got one action, do I need a do?
00:07:35 <mflux_> you can write "let a = foo 42" inside a do statement
00:07:48 <mflux_> and then use a as you please later
00:08:36 <Helmutt> But not outside the do?
00:08:58 <mflux_> well according to normal scoping rules..
00:17:06 <Helmutt> If I do name <- getLine in a do block, does that variable exist only in the do? Or do I have to use let name <- getLine?
00:24:42 <earthy> @type (=<<)
00:24:44 <lambdabot> forall b (m :: * -> *) a.
00:24:44 <lambdabot>    (Monad m) =>
00:24:44 <lambdabot>    (a -> m b) -> m a -> m b
00:25:00 <earthy> @type (<<)
00:25:01 <lambdabot> bzzt
00:25:08 <michaelw> Helmutt: yes, no (your let is not valid Haskell syntax)
00:28:56 <wilx> @moo
00:29:05 <wilx> No moo? :(
00:45:32 <Helmutt> If I got than one result in a case statement wich should yield the same output, do I need to specify them individually, or can I do it on the same line?
00:48:42 <Helmutt> @yow
00:48:45 <lambdabot> I want to read my new poem about pork brains and outer space ...
00:57:30 <michaelw> musasabi: you might be interested in http://research.microsoft.com/~nick/stackstr.pdf
01:09:35 <gennet1> Helmutt: could you explain a bit more?
01:10:11 <kzm> It is possible that I need some darcs help.  When I pull and get a conflict, is there any way to back out of it again?
01:10:22 <kzm> (I.e. I had unrecorded changes in the working dir)
01:11:26 <kzm> Helmutt, I think you need individual specifications in the general case.
01:11:56 <kzm> But perhaps you can use guards instead?  (Arbitrary boolean exprs)
01:12:49 <Itkovian> meuning
01:13:59 <gennet1> moaning
01:21:44 <Itkovian> err ...
01:24:17 * gennet1 wonders if he's the only person left in the world that still watches "'allo, 'allo"
01:32:57 <earthy> nope, you're not
01:35:08 <Itkovian> nope
01:35:11 <Itkovian> we all do
01:35:25 <Itkovian> i shell say this unly unce
01:35:36 <earthy> it is I, LeClerc
01:35:50 <Itkovian> eeedddiiiiittthhh
01:35:54 <Itkovian> kncok knock
01:36:13 <earthy> Colonel Gruber!
01:36:32 <earthy> and ofcourse, the painting of the fallen madonna with the big boobies
01:36:36 <Itkovian> Where is my little tank?
01:36:38 * kzm doesn't have a TV.
01:36:44 <Itkovian> poor schmuck
01:36:53 <earthy> you have a monitor, right?
01:36:57 <Itkovian> or maybe lucky bastard
01:37:22 <kzm> Hehe.  Expected to cave in to popular demand RSN.
01:37:54 <Itkovian> btw, it's Lieutenant Gruber, eh
01:38:02 <earthy> oh, right
01:38:26 <earthy> and what were the names of those SSers...
01:38:27 <Itkovian> Shut up Von Smallhausen
01:38:29 <kzm> Pronounced "Leftenant", IIRC.
01:38:33 <Itkovian> Yeess Herr Flick
01:38:51 <Itkovian> yeah the english have weirtd ways of pronouncing Lieutenant
01:39:10 <Itkovian> those SSers were uber cool
01:39:41 <kzm> And "kernel" is apparently a military grade? :-)
01:39:50 <kzm> Weren't they Gestapo, though?
01:40:01 <earthy> um, yeah
01:40:19 <earthy> and Helga, ofcourse
01:40:37 <earthy> and it was Colonel Von Strohm
01:40:51 <earthy> and General von Klinkerhoffen!
01:41:18 <Itkovian> Yes, Gestapo, or SS, all the same scum to me
01:41:37 <Itkovian> kernel is definitely a military grade
01:41:51 <Itkovian> KERNEL VON KLINKERHOFEN!
01:42:03 <Itkovian> whatever
01:42:18 <Itkovian> also the heil and the klop are cool
01:42:32 <earthy> fun! :)
01:42:43 <Itkovian> heil hitler heil hitler ... klop
01:42:44 <Itkovian> ;-)
01:43:25 <Itkovian> and the Italian ... bertorelli or something
01:49:02 <earthy> Captain Bertorelli of the Italian Army!
01:49:13 <earthy> Heil Mussolini!
01:53:09 <Itkovian> It's more "Heille Moesoelienie"
01:54:10 <Itkovian> ... mesieu alphone, undertaakeerrr
01:55:16 <earthy> Alphonse
01:55:25 <earthy> always proposing to Fanny
01:56:18 <Itkovian> yeah ... he _is_ an undertaker after all :-)
01:56:32 <Itkovian> and the bloody singing ...
01:56:33 <musasabi> michaelw: thanks for the link.
01:56:50 <Itkovian> Reneee ... what are you doing with that servant girl in your arms ?!
01:56:54 <Itkovian> YOU STUPID WOMAN!
01:56:57 <Itkovian> ;-)
01:57:09 <Itkovian> Can't you see that ...
01:57:11 * earthy laughs
01:57:56 <earthy> now, how to tie this reminiscing into Haskell...
02:03:46 <Itkovian> well ... erm ...
02:04:28 <earthy> can't really be done, eh? :)
02:04:29 * gennet1 wonders about the painting of fallen sjp with the big comonads
02:04:51 <earthy> SPJ that would be then
02:04:59 <xs_> so this is what category theory does to people.
02:11:27 <Itkovian> gennet1: hide it in yr trousers!
02:17:57 * gennet1 wear nice large shorts. he reckons he can offer political asylum to a family of racoons comfortably
02:19:25 <Itkovian> haha
02:19:42 <tomdavie> fine then, just laugh at me
02:19:54 <Itkovian> and do you have defensive measures to protect the family heirloom?
02:21:04 <Itkovian> tomdavie: eh?
02:21:52 <tomdavie> You rejoined the room. 10:23
02:21:52 <tomdavie> Itkovian 10:23 haha
02:24:52 * earthy grins
02:24:56 <Itkovian> tomdavie:  check the logs
02:25:04 <earthy> the haha was for gennet1's remark about his shorts ;)
02:25:35 <tomdavie> yeh, I was being a sarcy git
02:59:52 <TFK> Hello, good people of #haskell!
03:00:03 <tomdavie> lo
03:00:29 <autrijus> yo
03:06:41 <tomdavie> thank god
03:06:48 <tomdavie> my sister finally rang me
03:11:34 <xs_> she's in london? :/
03:11:43 <tomdavie> yeh... right in the middle of it all
03:12:59 <xs_> shit, well, thank goodness she's ok
03:15:27 <tomdavie> indeed... I just got a dazed phone call from her going "why were you worried???" -- it's not like her morning journey goes through Kings Cross and Edgeware Road or anything
03:17:59 <xs_> it's easy to forget that london is quite big
03:18:08 <xs_> but there've been at least two explosions, right?
03:18:48 <xs_> 6, heh!
03:18:56 <tomdavie> 5 tube stations
03:18:58 <tomdavie> a buss
03:19:01 <tomdavie> bus
03:19:07 <tomdavie> and a train crash
03:22:13 * df_ loves all the different accounts coming up
03:23:21 <tomdavie> heh
03:23:33 <tomdavie> probably all different because it's 6 different events
03:26:24 <gennet1> wow; my laptop just bsod'ed
03:27:09 <gennet1> time to make a disk backup methinks
03:46:37 <Itkovian> noon
03:47:01 <TFK> noon #2
03:48:06 <Itkovian> erm... what happened?
03:48:37 <TFK> A terror attack in London.
03:48:53 <df_> `bang'
03:51:30 <Itkovian> yes, I'm reading the BBC website right now ...
03:52:48 <Itkovian> holy smoke
03:52:55 <gennet1> it's definitely not good
03:53:37 <Itkovian> so it seems ... any word on casualties?
03:59:01 <TFK> 'Some fatalities', apparently.
03:59:32 <xs_> 2 so far afaik.
04:04:48 <Itkovian> I just heard 90 death in one of the metros
04:05:06 <Itkovian> hmm, correction 90 casualties
04:05:57 <Itkovian> this sucks
04:06:00 <Itkovian> morons
04:09:30 <SM_ax> Itkovian, are you from London?
04:09:35 <Pseudonym> People spoil an otherwise lovely world.
04:09:39 <Pseudonym> Anyway, gotta go.
04:10:03 <Itkovian> SM_ax: nope, Ostend, Belgium
04:10:09 <Itkovian> But it still sucks all the same.
04:10:31 <SM_ax> sure...
04:14:31 <Itkovian> SM_ax: you from london?
04:14:51 <Itkovian> so much for work today then ...
04:15:20 <SM_ax> Itkovian, no, not from London. Moscow, Russia
04:15:35 <Itkovian> ah, well, you've had your share then a while ago, eh.
04:15:57 <SM_ax> Itkovian, a BIG one I must say..
04:16:04 <Itkovian> true
04:16:18 <Itkovian> unimaginable what some people sem prepared of doing
04:16:23 <Itkovian> they'd better code a bit
04:16:59 <tromp> no haskell programmer has ever comitted a terror act...
04:17:06 <tromp> that we know of:(
04:17:11 <Itkovian> heh
04:17:48 <Itkovian> some could cause terror by showing their desk environment I guess
04:17:53 <TFK> SM_ax, земляк :-P
04:18:07 <Itkovian> and now in English ...
04:18:19 <SM_ax> TFK, moscow too?
04:18:25 <TFK> Itkovian, or exposing parts of their body in public.
04:18:43 <Itkovian> let's not go down that train of thought
04:18:56 <Itkovian> a vivid imagination can be a curse at times :-)
04:19:03 <TFK> SM_ax, Jerusalem actually, but I don't know the word for "expatriate" in Russian :-/
04:19:40 <SM_ax> TFK, it is expatriate afaik :)
04:19:56 <TFK> I was born in Moscow, fwiw ;-)
04:20:25 <TFK> That doesn't sound very natural in Russian.
04:22:06 <TFK> Mmm, "ear-cleaning tesuji" o.o;;
04:22:19 <SM_ax> expatriate = экспатриант, not very natural, but this word exists
04:22:40 <SM_ax> TFK, and I play go too :))
04:22:40 <Itkovian> heh, anybody of you know what the girl on "Moscow - Rammstein" sings? I mean, the russian, not the translation
04:23:00 <TFK> SM_ax, hmm, I'll keep that in mind, thanks :-)
04:23:09 <TFK> SM_ax, I'm a 24k nub at KGS :-/
04:23:25 <TFK> Itkovian, never heard the song :-/
04:23:33 <Itkovian> hmm ...
04:23:51 <SM_ax> Itkovian, i don't know. You can google it up, though
04:24:19 <Itkovian> SM_ax: hmmm ... prolly
04:24:47 <Itkovian> but I'd like in in 'normal' alphabet, not cyrillic
04:24:50 * Itkovian googles
04:25:34 <SM_ax> Itkovian, there must be plenty of translations
04:25:50 <Itkovian> nono, the translation, I have ... it's the original words I lack
04:25:53 <TFK> Or even the original lyrics.
04:26:14 <tromp> i play go three
04:27:33 <SM_ax> Itkovian, hm, those may be hard to find
04:27:40 <Itkovian> Это песня о самом красивом
04:27:40 <Itkovian> городе в мире. Москва!
04:27:48 <TFK> tromp, nidan, eh?
04:27:56 <Itkovian> can you give the pronouciation?
04:28:08 <Itkovian> Раз, два, три!
04:28:09 <Itkovian> Moskau
04:28:09 <Itkovian> Посмотри!
04:28:09 <Itkovian> Пионеры там и тут,
04:28:09 <Itkovian> песни Ленину поют.
04:28:11 <TFK> Itkovian, this is a song about the most beautiful/city in the world. Moscow!
04:28:20 <Itkovian> yeah well, it's not all positive ...
04:28:34 <Itkovian> how does one pronounce those words?
04:28:56 <TFK> Look, / [Russian equivalent for scouts] everywhere / singing songs to honor Lenin
04:29:16 <Itkovian> TFK: not the translation, the pronounciation
04:29:21 <SM_ax> Itkovian, Eto pyesnya o samom krasivom gorode v miere. Moskva!
04:29:24 <TFK> That would be difficult.
04:29:27 <Itkovian> ok
04:29:32 <Itkovian> SM_ax: thx
04:29:50 <TFK> Many Russian sounds don't exist in English.
04:29:53 <SM_ax> Itkovian, But I really, really doubt that you can pronounce it right from what I've written.... :)
04:30:07 <Itkovian> I don't care, I want to jodle along in my car :-)
04:30:10 <TFK> I'd say "mire" instead of "miere", but hey...
04:30:33 <TFK> Posmotri! Pioneri tam i tut, pesni leninu poyut.
04:30:52 <Itkovian> heh, I got the lenin part right then ;-)
04:31:12 <Itkovian> and 1,2,3?
04:31:23 <TFK> ras, dva, tri
04:31:29 <Itkovian> ras twa tri? as I understand the girl singing
04:31:36 <Itkovian> nice thx
04:31:41 <tromp> yep, dutch 2 dan
04:32:16 <TFK> tromp, hey, I should be able to beat you with, oh, 26 handicap stones? :-P
04:32:39 <tromp> or 4 stones on 9x9
04:38:31 <SM_ax> it seems that every programmer plays go and every go player is a programmer :)
04:39:48 <TFK> A peculiar isomorphism indeed.
04:39:49 <tromp> except shapr
04:40:05 <tromp> but he's too busy unicycling
04:45:11 * Itkovian would love to play go, but lacks an oponent
04:45:32 <TFK> But shapr is listed as a player o_O
04:45:48 <TFK> Itkovian, the only pro in Europe? :-P
04:46:02 * Itkovian never played ...
04:46:19 <TFK> Same stick, different end.
04:46:26 * earthy does not play go\
04:47:33 <TFK> Blasphemy!
04:48:28 <SM_ax> earthy and Itkovian have broken my worldview
04:48:53 <Itkovian> haha!
04:49:38 <TFK> But are they programmers?
04:50:17 <SM_ax> Itkovian, who's laughing now? :)
04:51:12 <Itkovian> *slik*
04:51:23 <TFK> Speaking of programming, did anyone produce faster-than-Python code for that Lychler problem? :-P
04:53:24 <SM_ax> TFK, what is it?
04:54:12 <SM_ax> @wikipedia Lychler problem
04:54:15 <lambdabot> No result found.
04:54:37 <SM_ax> :)
04:54:39 <TFK> http://mathschallenge.net/index.php?section=project&ref=view&id=55 <--- the challenge; http://rafb.net/paste/results/1ZKnmh57.html <--- my Python solution; http://hbin.dyndns.org/pastebin/67.html <--- my Haskell solution; http://hbin.dyndns.org/pastebin/69.html <--- poetix' Haskell solution
04:55:07 <TFK> Poetix said that he would time his solution against mine, but he isn't here, unforunatelly.
04:55:59 <TFK> Meanwhile, my Python solution seems fastest.
05:00:13 <gennet1> TK: your python solution seems to be 404'ed
05:00:40 <TFK> Stupid rafb :-/
05:00:55 <TFK> http://rafb.net/paste/results/Ob89BL34.html
05:01:24 <gennet1> hmm; interesting
05:02:03 <SM_ax> in what respect it is fastest? plain processor time?
05:02:12 <TFK> wall-clock time.
05:02:28 <gennet1> ghc binary?
05:02:31 <TFK> On my machine, that Python solution runs under a second, the GHC exe for ~4 seconds.
05:02:41 <gennet1> have you prof'ed the binary?
05:02:50 <TFK> Nope.
05:02:53 <SM_ax> -O' ed ?
05:03:03 <TFK> (prof'ed - profiled?)
05:03:09 <gennet1> TKF: yep
05:03:12 <TFK> -O2, as a matter of factly.
05:03:12 <tromp> surely there's more interesting programs to speed up:-?
05:03:31 <gennet1> tromp: thou dost speak against the light of natural reason!
05:03:34 * TFK shrugs
05:03:47 <tomdavie> http://www.winsper.org.uk/photos/glasto2005/fullimage.php?file=DSC00288.JPG&size=640x480
05:04:13 <TFK> It is a cute problem and I was surprised by the results.
05:04:39 <TFK> After all, we all know that Python is a slow scripting language that always gets pound to dust at GLS.
05:04:42 <TFK> ;-)
05:05:17 <gennet1> tis true; i wonder what the result would be if you included psycho in the python
05:05:42 <TFK> I doubt it would give a major speedup, but everything's possible.
05:06:05 <TFK> (this is because the solution uses generators heavily, which Psyco doesn't optimise (yet))
05:06:11 <gennet1> true
05:06:11 <jlouis> are you allowed to hammer on the math?
05:06:25 <gennet1> but it would jit the calculations quite well
05:07:06 <TFK> It doesn't optimise map as well. The docs warn against map, actually, so I may as well use an LC.
05:07:17 <TFK> Meanwhile it works just fine without Psyco :-P
05:08:32 <tromp> to make it fast, you should turn it into a pure string problem
05:09:03 <tromp> the conversion from binary to decimal and back is slower than just adding decimal strings
05:09:03 <TFK> But you will need to add the strings somehow.
05:09:04 <gennet1> TFK: profiling seems to suggest that 50% of the time is spent inside revNum
05:09:16 <gennet1> TFK: actually, make that 99%
05:09:26 <tromp> it's trivial to write your own stringadd
05:09:49 <TFK> tromp, makes sense. But my Python solution uses the same technique, so conceptually it suffers the "same" overhead.
05:09:56 <gennet1> i'm guessing that the the show / read pair isn't that good
05:10:01 <TFK> gennet1, that would make sense, too ;-)
05:10:21 <TFK> A safe bet, but how to make it better, without making it a string problem?
05:10:34 <TFK> Although writing a stringAdd doesn't sound bad.
05:10:49 <gennet1> i don't think the performance would be better
05:11:04 <TFK> You never know until you try ;-)
05:11:08 <gennet1> why not make revNum just work on the integer?
05:11:15 <TFK> But I won't try, I'll be lazy and wait for poetix to give the verdict on his solution :-P
05:11:19 <gennet1> :p
05:11:25 <TFK> gennet1, how would I reverse the integer?
05:11:44 <gennet1> i'm thinking something like split the integer into a list of digits, rev the list
05:11:51 <TFK> I need to check if it's a palindrome, after all.
05:12:08 <gennet1> sure
05:12:19 <TFK> rev the list and what, foldl?
05:12:37 <TFK> At any case, it needs some thought and experimentation.
05:12:38 <gennet1> well, that would be one way to get the integer back
05:13:35 <TFK> gennet1, does the null check on rs behave lazily?
05:13:53 <TFK> i.e., does it need to evaluate all of the 50 elements I take?
05:14:04 <gennet1> i have no idea :p
05:14:14 <gennet1> my background is mainly computational stuff in C++
05:14:19 * gennet1 is still learning haskell
05:14:30 <TFK> heh
05:15:02 <TFK> Interseting, many seekers of enlightment here, it seems. A few months ago I thought I was the only one o_O
05:15:45 <lisppaste2> michaelw pasted "rev_num" at http://paste.lisp.org/display/9707
05:16:32 <TFK> Will that really be faster?
05:16:39 <Itkovian> TFK: I think it does behave lazily ...
05:17:18 <TFK> But are you sure? ;-)
05:17:58 <Itkovian> TFK: I've been assured it does :-)
05:18:08 <Itkovian> I use 'any' and that short circuits afaik
05:18:25 <Itkovian> @pastepage
05:18:26 <lambdabot> Unknown command, try @listcommands.
05:18:29 <Itkovian> @paste
05:18:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:18:55 <Itkovian> see the top entry there
05:19:03 <TFK> hbin.dyndns.org
05:19:10 <TFK> Don't you like HBin? :-(
05:20:22 <Itkovian> hmm, I always use that page ... seems logical
05:20:48 <TFK> Pastebin in a wiki - ugh :-/
05:21:04 <TFK> (Not to diss the wiki, the syntax highlighting or the utility of such an idea)
05:21:11 <Itkovian> whatever ... it was what was recommended to me when I first dropped in here
05:21:39 * TFK promotes a partisan view of things
05:21:40 <gennet1> TFK: i've got a quick mock up; takes the running time from 5 seconds to 0.56
05:22:00 <TFK> gennet1, wow! What about the Python solution?
05:22:05 <gennet1> haven't tried
05:22:15 <earthy> mock up of reversing without going via a string?
05:22:31 <TFK> A tenfold speedup seems very convincing.
05:22:40 <michaelw> gennet1: did you use what i pasted?
05:22:43 <TFK> Can you time the Python code as well, please?
05:23:18 <gennet1> http://hbin.dyndns.org/pastebin/70.html
05:23:40 <gennet1> michaelw: no, but at a glance it's the same thing
05:24:28 <gennet1> TFK: i can't test the python, it seems; i've only got 2.3...
05:24:29 <tomdavie> you really should use or and filter on that list... you'll cut the common case run time significantly
05:24:29 <michaelw> gennet1: you are going via lists, why?
05:24:45 <gennet1> michaelw: no reason; i just thought that owuld be easier
05:24:51 <TFK> gennet1, oh, I use genexps which are new in 2.4. I'll try to time it myself, then.
05:26:26 <gennet1> michaelw: your code may well be even faster
05:28:04 <gennet1> the current break down is 7:4 between itolr:ltoi; revNum is still taking up over 95% of the cpu time
05:28:49 <xs_> wouldn't revNum also be faster with revNum :: Int -> Int?
05:28:51 <earthy> hm. that's interesting
05:29:08 <gennet1> xs_: yes; but the current code uses Integer all over, and I decided against any unboxing
05:29:09 <earthy> the revNum going through [Integer] is *slower* on GHC 5.04.3
05:29:41 <xs_> gennet1: i thought Int was still boxed? it was Int# that wasn't?
05:29:42 <gennet1> earthy: oh wow; i guess somewhere GHC got really got at cons?
05:30:08 <gennet1> xs_: oh yeah... hmm; i guess it's just me being lazy and not bothering to change any types then :p
05:30:36 <xs_> gennet1: well, Int has a more limited range.. so if you're going for the One True Solution To Rule Everything, it's probably better ;)
05:32:39 <Itkovian> TFK: with michaelw his code, I get now about 1.2 seconds for unoptimized ghc code
05:32:55 <gennet1> Itkovian: what did you get before?
05:33:00 <Itkovian> 4.5
05:33:07 <michaelw> :)
05:33:38 <TFK> Yup, looks very fast.
05:33:45 <Itkovian> I think I can still scrap a few hudred milliseconds, by eliminating the other show
05:34:09 * Itkovian does 1000 iterations
05:34:22 <Itkovian> used to take 10 minutes
05:35:25 <TFK> I'll inline some timing code and see how it fares.
05:35:43 <TFK> so I'll use michaelw's code as-is?
05:35:55 <gennet1> it looks good
05:37:14 <Itkovian> it does
05:38:22 <earthy> utter weirdness
05:38:51 <earthy> ghci 5.04.3 really is a *lot* faster going through strings than using either gennet1's or michaelw's revNum
05:39:06 <earthy> but michaelw's revNum is faster than gennet1's
05:39:56 <gennet1> i'd guess that ghc 5 wasn't so good with arithmetic?
05:40:15 <gennet1> or it might be having trouble dealing with the tail calls?
05:40:19 <earthy> it's ghci...
05:40:25 <gennet1> oh i see
05:40:39 <earthy> but that *still* makes it weird
05:40:49 <gennet1> indeed
05:43:05 <earthy> okay, compiling makes it more sensible
05:43:14 <earthy> suddenly your revNum is twice as fast as going through strings
05:45:15 <lisppaste2> beelsebob pasted "Jam" at http://paste.lisp.org/display/9708
05:45:31 <tomdavie> That seems to be the fastest I go on my machine...
05:45:42 <tomdavie> ...without memorisation
05:47:31 <lisppaste2> beelsebob pasted "Jam3" at http://paste.lisp.org/display/9709
05:47:40 <tomdavie> actually... that's slightly faster
05:47:42 <tomdavie> but not much
05:48:08 <michaelw> tomdavie: there is this little annotate button (right bottom)...
05:48:31 <tomdavie> hmm?
05:48:44 <tomdavie> doesn't do what I expected it to do... sorry
05:49:02 <tomdavie> i.e. I thought before it let you add comments to a paste
05:49:06 <lisppaste2> earthy annotated #9709 with "Try this:" at http://paste.lisp.org/display/9709#1
05:50:00 <earthy> oh, that has a closing brace too many
05:50:04 <tomdavie> pretty similar
05:50:17 <tomdavie> couldn't tell any difference
05:50:20 <earthy> similar, but cuts earlier in the number of iterations
05:50:24 <earthy> so, should be slightly faster
05:50:25 <tomdavie> yeh?
05:50:27 <tomdavie> cool
05:50:40 <earthy> thanks to lazyness :)
05:50:52 <tomdavie> :)
05:51:07 <lisppaste2> michaelw annotated #9709 with "factoring" at http://paste.lisp.org/display/9709#2
05:51:31 <tomdavie> indeed... that's stunningly obvious
05:52:04 * earthy kicks michaelw
05:52:14 <earthy> you've just invalidated the solution
05:52:16 <tomdavie> ... but wrong
05:52:35 <michaelw> oops
05:52:53 <earthy> no problem. if you state makeRev = tail $ iterate addRev
05:52:55 <earthy> you're fine
05:53:32 <michaelw> ah, i'm consuming the list differently, yes.
05:54:01 <tomdavie> you mean tail . iterate addRev
05:54:23 <TFK> picosecond is how much? 10^9-th of a second?
05:54:39 <lisppaste2> beelsebob annotated #9709 with "Current best..." at http://paste.lisp.org/display/9709#3
05:55:02 * TFK will time the current best after he figures out System.Time >_<
05:55:04 <earthy> yeah, I meant that
05:55:15 <tomdavie> hehe
05:55:40 <Itkovian> TFK: use perfex if you are on an x86 ...
05:55:51 <Itkovian> it will give you 99.99% accurate cycle time
05:55:57 <TFK> perfex?
05:56:04 <Itkovian> @google perfctr
05:56:05 <TFK> I need time in seconds.
05:56:06 <lambdabot> http://user.it.uu.se/~mikpe/linux/perfctr/
05:56:14 <TFK> I'm on win32.
05:56:16 <Itkovian> TFK: well, divide by the clock speed then, eh
05:56:20 <Itkovian> too bad
05:56:23 <Itkovian> :-)
05:56:30 <Itkovian> AMD?
05:56:41 <TFK> How much is a picosecond? 10^9-th of a second?
05:56:43 <Itkovian> use codeanalyst or some such
05:56:46 <Itkovian> TFK: yes
05:56:53 <Itkovian> erm no
05:56:57 <Itkovian> 10^{-12}
05:57:00 <kzm> tfk: no - 10^-12
05:57:04 <Itkovian> nano is 10^{-9}
05:57:14 <TFK> ah, then there's the minus part. Thanks.
05:57:39 <kzm> The minus is the most important part :-)
05:57:52 <TFK> Indeed ^_^;;
05:58:15 <Igloo> 10^9-th of a second == 10^{-9} seconds
05:59:38 <TFK> How do I convert an integer to a float o_O?
05:59:49 <Igloo> fromIntegral
05:59:58 <TFK> sankty
06:00:53 <tomdavie> I get 1.8 secs on my crappy old laptol
06:00:55 <tomdavie> laptop
06:01:14 * TFK is getting silly diff results...
06:01:27 <tomdavie> huh?
06:02:26 <TFK> http://hbin.dyndns.org/pastebin/71.html <--- I'm even getting negative results there :-/
06:02:48 <TFK> or is it...
06:02:49 <tomdavie> @hoogle getCPUTime
06:02:51 <lambdabot> CPUTime.getCPUTime :: (IO Integer)
06:02:51 <Itkovian> hmm
06:03:04 <tomdavie> gets the amount of time spent on the CPU so far
06:03:43 <Igloo> Use `div` instead of / and don't use fromIntegral
06:03:47 <Itkovian> TFK: if you are on an AMD you may use http://www.amd.com/us-en/Processors/DevelopWithAMD/0,,30_2252_3604,00.html
06:04:05 <lisppaste2> beelsebob annotated #9709 with "Use this" at http://paste.lisp.org/display/9709#4
06:04:59 <TFK> time.clock() works in Python, btw
06:05:05 <Itkovian> anybody any XP with CHUD on MacOSX?
06:05:39 <tomdavie> A little... depends on the tool
06:07:46 <TFK> Igloo, I'm getting 0 now, using yours and tomdavie's method :-/
06:07:57 <tomdavie> eh?
06:08:14 <Igloo> Does it take less than a second?
06:08:20 <tomdavie> did you put the from integral in the right place?
06:08:21 <TFK> yes
06:08:32 <TFK> nope, I used `div` instead.
06:08:36 <tomdavie> that's why
06:08:41 <tomdavie> it's just rounded down
06:08:43 <TFK> Yup. Your method works :-)
06:08:48 <tomdavie> use the timing code I pasted
06:09:18 <Igloo> Oh, sorry, forgot you'd want the fractional result
06:09:28 * gennet1 wonders how much faster C could be
06:09:40 <gennet1> can't be that much any more, surely
06:09:49 <TFK> Python solution (the one I posted, no changes) lowest exec time - ~0.7 secs, GHC binary -O2 - ~0.65 secs
06:09:58 <Igloo> Doing the division on Rationals and then converting to Double would probably be the best way
06:10:01 <TFK> gennet1, it would be way, way faster.
06:10:17 <gennet1> TFK: care to try? :-P
06:10:23 <tomdavie> tfk: which haskell solution is that?
06:10:25 <TFK> My C is kinda rusty :-/
06:10:43 <TFK> http://paste.lisp.org/display/9709#3 <--- this one, I believe
06:10:52 <tomdavie> k
06:10:57 <gennet1> the problem is that at this kinda of time scale, runtime variability is getting significant
06:11:12 <gennet1> maybe we should bump the limit up an order...?
06:11:27 <tomdavie> could do
06:11:28 <Itkovian> TFK: you should do atleast a hundres runs ... and average out
06:11:31 <TFK> gennet1, say, to up to 50,000?
06:11:48 <Itkovian> make that 100K
06:11:51 <TFK> I'd have to write a Python script to do that :-/
06:11:54 <Itkovian> and more max iterations too
06:12:00 <TFK> Easier to just bump the numbers.
06:12:01 <gennet1> TFK: sure; but are we sure that 50 iterations of the palindrome is enough?
06:12:07 <Itkovian> TFK: then still ...
06:12:16 <tomdavie> gennet: reasonably so
06:12:20 <TFK> You tell me.
06:12:24 <Itkovian> gennet1: for under 10000, it yields the same results as 1000 iterations
06:12:35 <TFK> 100k naturals and 50 iterations? Is this the consensus?
06:12:42 <tomdavie> yep
06:12:59 <lisppaste2> michaelw annotated #9709 with "one revNum per iteration" at http://paste.lisp.org/display/9709#5
06:12:59 <TFK> good >-)
06:13:25 <Itkovian> TFK: more iterations imo
06:13:41 <TFK> more iterations of what?
06:13:57 <TFK> of the solution runs themselves?
06:14:31 <Itkovian> TFK: of the runs and of the reverse+add stuff
06:14:36 <TFK> woo! I'm getting a negative count on lychrel numbers :-P
06:14:42 <Itkovian> on an unloaded machine
06:14:56 <tomdavie> yeh... that's about 60% of the run time
06:15:03 <tomdavie> good speed up michael
06:15:03 <TFK> Oh, I'm just silly o.o
06:15:16 <TFK> So what am I timing? michaelw's code?
06:15:28 <tomdavie> his new version
06:15:41 <tomdavie> http://paste.lisp.org/display/9709#5
06:15:59 <TFK> roger that.
06:16:17 <lisppaste2> michaelw annotated #9709 with "uncurry" at http://paste.lisp.org/display/9709#6
06:16:25 <TFK> BAH! Decide already!
06:16:57 <gennet1> why not just get pl to produce the point-free version... :p
06:16:59 <tomdavie> that's no faster!
06:17:16 <tomdavie> hmm... maybe it is... by a hair
06:17:39 * TFK will test http://paste.lisp.org/display/9709#5
06:17:41 <michaelw> tomdavie: at least nicer if nothing else
06:17:45 <tomdavie> true
06:18:32 <SM_ax> why am I not allowed to read "Why Attribute Grammars Matter" from recent TMR?
06:19:09 <TFK> C:\haskell\tests>lychrel.exe
06:19:10 <TFK> 6208
06:19:10 <TFK> 8.59375
06:19:31 <SM_ax> says "you are not allowed to view this page"...
06:19:37 <tomdavie> and python?
06:20:10 <Itkovian> SM_ax: because somebody forgot to set it world readable
06:20:11 <TFK> C:\haskell\tests>lychrel.py
06:20:11 <TFK> 6208
06:20:11 <TFK> 13.047862787
06:20:18 <tomdavie> woo yay!
06:20:23 <tomdavie> what about compiled python?
06:20:24 <TFK> *coughshaprcough*
06:20:29 <TFK> tomdavie, I'm yet to optimize it.
06:20:36 <TFK> Laughs best who laughs last.
06:20:56 <tomdavie> mmm... yoda become you have
06:21:01 <SM_ax> Itkovian, who can fix it then?
06:21:14 <Itkovian> the author and shapr afaik
06:21:51 <TheHunter> as far as i know, tmr isn't officially released yet.
06:22:11 <TFK> It's actually slower with Psyco :-/
06:22:35 <earthy> okay, where was the python again? :)
06:23:09 <TFK> The solution?
06:23:15 <earthy> yup
06:23:34 <TFK> http://rafb.net/paste/results/Ob89BL34.html <--- but I'm going to play around with it.
06:23:37 <michaelw> tomdavie: it would be even faster without going through makeRev, I guess *shrug*
06:24:02 <tomdavie> hmm? how do you mean?
06:24:22 <TheHunter> what is makeRev anyway? read . reverse . show ?
06:24:46 <michaelw> tomdavie: without using a stream
06:24:53 <michaelw> TheHunter: that's revNum
06:25:31 <TheHunter> revNum right. My guess would be that's the bottleneck.
06:25:50 <earthy> and in the tested code, revNum is quite a bit more efficient than that
06:25:55 <basti_> heya.
06:26:49 <TheHunter> python probably tries to be much less fancy than haskell when reading integers and Haskell's Read instances aren't famous for their speed.
06:27:20 <earthy> as I stated: the revNum we use is *not* read . reverse . show
06:27:46 <TheHunter> ah, ok.
06:28:45 <TheHunter> what's the revNum you use?
06:29:05 <earthy> revNum :: Integral a => a -> a
06:29:05 <earthy> revNum = acc 0
06:29:05 <earthy>    where acc a 0 = a
06:29:05 <earthy>          acc a x = let (d,r) = x `divMod` 10
06:29:05 <earthy>                    in acc (a*10 + r) d
06:29:33 <TheHunter> thanks.
06:31:34 <tomdavie> somehow, I think this is wrong... tatd2$ ./isLychrel
06:31:34 <tomdavie> 12
06:31:35 <tomdavie> 0.173818
06:32:01 <michaelw> maybe i broke it again
06:33:16 <basti_> base conversion?
06:34:00 <tomdavie> no... it was me that broke it
06:43:09 <tomdavie> poo... something isn't lazy
06:47:21 <Itkovian> erm, we all are ...
06:48:04 <TFK> C:\haskell\tests>lychrel.py
06:48:05 <TFK> 6208
06:48:05 <TFK> 4.6651806305
06:48:14 <TFK> C-style code, naive rev_num implementation.
06:48:19 <TFK> (Psycoed)
06:49:05 <TFK> Now let's see how I can leverage Psyco's arithmetic skills and skip the string part >-)
06:56:06 * Itkovian is off ... gotta catch a train
06:56:49 <basti_> guys
06:56:54 <basti_> if there is a continuation monad
06:56:58 <basti_> ...
06:57:07 <basti_> is there a "this is compiled code" monad or something?
06:57:15 <basti_> i mean would this make sense?
06:57:35 <tromp> not to  e
06:57:36 <basti_> like for describing ffii calls
06:57:37 <tromp> me
06:57:50 <basti_> oh but they do
06:58:01 <basti_> its just the IO monad
06:58:58 <basti_> hmmm
06:59:37 <basti_> and monads are arrows
07:06:57 <TFK> oy vey o.o
07:07:53 <TFK> the naive rev_num turned out better than my custom one.
07:08:19 <basti_> huh?
07:08:57 <TFK> But it is still faster than the Haskell solution :3
07:09:08 <TFK> Although I used a cheap and dirty trick and wrote it C-style.
07:10:28 * tomdavie is working on a new haskell one... that may or may not be faster
07:10:37 <TFK> http://rafb.net/paste/results/vckBui65.html
07:10:55 <TFK> Now, written in C, this would be blazingly fast.
07:11:18 <TFK> ...provided there is a good implementation for integers of arbitrary length :-/
07:11:23 <basti_> :)
07:11:35 <basti_> how about show.reverse.read?
07:11:48 <basti_> or no
07:11:48 <basti_> wait
07:11:53 <basti_> read.reverse.show
07:11:55 <basti_> !
07:12:14 <tromp> in C you'd definately use byte arrays instead of bigints
07:12:14 <TFK> basti_, SLOW.
07:12:37 <tromp> all the conversions between binary and decimal just slow you down
07:12:38 <basti_> TFK: hmm
07:12:54 <tromp> and have nothing to do with the problem
07:13:04 <basti_> what are you trying to do?
07:13:12 <TFK> basti_, there's a long backlog regarding the issue ;-)
07:13:19 <tromp> in C, you wouldn't even do any reversing
07:13:37 <TFK> tromp, are you saying that C rocks? o.o;
07:13:45 <tromp> just write the add routine to add a[i] to a[n-i]
07:14:45 <tromp> for this particular problem, c is more suited than haskell
07:16:04 <tromp> that's usually the case if you can write something in 10 lines of C :)
07:16:32 <TFK> Is this really ten lines of C?
07:17:29 <tromp> the essential code is just one line
07:17:33 <TFK> It's also a bit strange that Psyco prefered two (!) function calls to pure arithmetic code.
07:19:48 <tromp> something like
07:19:49 <tromp> for (i=c=0;i<=n;i++) if (c=((b[i]=a[i]+a[n-i]+c)>=10) b[i]-=10;
07:20:01 <TFK> My eyes, MY EYES!
07:20:22 <tomdavie> bah... I appear to be getting polynomial slowdown... :/
07:20:32 <TFK> tomdavie, your solution?
07:20:53 <tomdavie> yeh... which is odd... it should be linear at worst
07:21:25 <TFK> So Python is still faster :-P
07:21:26 <tromp> haskell is great if you can afford to ignore performance:)
07:21:31 <TFK> (in this case)
07:22:18 * TFK waits for the bigshots of Haskell to erect tens of unsafe calls and pointer manipulations against his poor Python script
07:22:23 <TFK> :-P
07:23:00 <TFK> tromp, there's a saying in Russian, "to combine the pleasent with the useful" ;-) judging from the GLS, Haskell ain't all that slow.
07:23:25 * TFK scratches that "to" from the proverb
07:23:51 <tromp> but to get haskell running that fast you must write ugly code and spend lots of effort optimizing it
07:24:13 <tromp> so you might as well use c in the first place then
07:24:22 <TFK> That's why GLS has two sections, for ugly code and less ugly code. Although at this point I am a very bad judge about "ugly" and "not ugly" in Haskell.
07:25:10 <tromp> i wrote a connect 4 solver in pretty haskell and it's 20 times slower than c
07:25:46 <TFK> What was the wall-clock time?
07:25:54 <tromp> actually, i optimized it as much as i could without getting too ugly
07:26:20 <tromp> to solve the game takes about 20mins for the C version
07:26:32 <TFK> O_O
07:26:51 <TFK> That's a lot of time indeed.
07:27:23 <tromp> i'd kill for a haskell implementation that's half as fast as ocaml:)
07:27:54 <tromp> which is competitive with c
07:28:20 <tomdavie> hmm... it this seems to be just as fast as the old one... but it's probably got a couple of places it can be optimised
07:28:24 * TFK waits for PyPy to produce miracles
07:29:20 <lisppaste2> beelsebob annotated #9709 with "Erq!" at http://paste.lisp.org/display/9709#7
07:29:31 <tomdavie> anyone care to try to optimise that?
07:29:43 <TFK> tomdavie, oh my...
07:29:54 <tomdavie> I think the bulk of the optimisations can be found in getLys
07:30:04 <tomdavie> hehe... oh my indeed
07:30:08 <tomdavie> but it's fast
07:30:20 <TFK> Is it now?
07:30:30 <tomdavie> at least as fast as the old solution
07:31:04 <TFK> Oh, my Python solution is still naive, in the sense that it doesn't use a sieve (several Haskell implementations tried to).
07:31:15 <tomdavie> hehe
07:31:21 <TFK> Although I don't know if the overhead will justify itself.
07:31:25 <tomdavie> yes... mine does sive
07:31:55 <tomdavie> well... my unoptimised version is as fast as the old optimised version... so probably
07:33:12 <tomdavie> hahahahahaha... CR rocks... "In the Era of Monadic Enlightenment, obfuscated imperative programming is the Way To Go.  :-\  :-)"
07:33:30 * TFK would like to point at spoj.sphere.pl again, to all those interested in algorithmic challenges
07:33:47 <TFK> Enlightment my while loop.
07:34:10 <xs_> cr?
07:34:21 <tomdavie> Colin Runciman
07:34:27 <TheHunter> TFK, what point exactly are you trying to make? I'm trying to do some stuff equery/emerge on gentoo right now and i have to say the performance of their python scripts sucks big time.
07:34:34 <xs_> oh yeah, that sounds like him :)
07:34:44 <tomdavie> indeed
07:35:45 <TFK> TheHunter, yup. Don't ask me why :-) I'm not trying to make any globals points, I just found this particular problem interesting.
07:38:17 <TheHunter> well, the performance-relevant part of your implementation (like reversing) are definitely written in C. And maybe it uses a different bignum lib. The performance benifits of delegating everything to C are not really surprising.
07:38:45 <TFK> Indeed, that's probably what str()/int() does.
07:40:05 <TFK> So yes, maybe that problem isn't that interesting after all :-/
07:40:40 <TheHunter> i'm somewhat surprised, though, that generators don't have a huge performance penalty
07:41:05 <TFK> They were twice as slow as my C-style implementation.
07:41:35 <TFK> Although, my C-style implementation was also "lazy".
07:50:03 <tomdavie> hmm... that'll have been the oposite of an optimisation then
08:01:38 <lisppaste2> beelsebob annotated #9709 with "teeny bit better" at http://paste.lisp.org/display/9709#8
08:01:49 <tomdavie> hehe... saved a tiny amount
08:15:17 <egg|patented> nice URIs ... ^^
08:15:27 <tomdavie> ?
08:15:34 <egg|patented> (bookmarks)
08:16:16 <danb> so i'm trying to use overlapping/undecidable instances with functional dependencies...
08:16:25 <danb> the following program gives the subsequent error:
08:16:35 <danb> class Foo a b | a -> b
08:16:40 <danb> instance Foo (a -> b) (a -> [b])
08:16:44 <danb> instance Foo a a
08:16:58 <danb>     Functional dependencies conflict between instance declarations:
08:17:02 <danb>       Bug.hs:5:0: instance Foo (a -> b) (a -> [b])
08:17:06 <danb>       Bug.hs:6:0: instance Foo a a
08:17:17 <danb> EOF
08:19:17 <danb> but the ghc user's guide says, about overlapping instances, "The -fallow-overlapping-instances flag instructs GHC to allow more than one instance to match, provided there is a most specific one. ... If there is no most-specific match, the program is rejected."
08:19:35 <danb> and the program is accepted if the functional dependency is omitted
08:20:46 <danb> i think i understand the "functional dependencies conflict" error, since with the overlapping instances, a does not uniquely determine b
08:21:31 <danb> but as per the overlapping instances selection criteria, the most specific match should be selected, at which point a _does_ uniquely determine b
08:22:01 <danb> so it seems that functional dependencies conflicts are being checked before the overlapping instance resolution
08:22:15 <danb> is this a bug, or am i confused?
08:22:30 <danb> (brb)
08:30:29 <danb> (re)
08:30:50 <basti_> (hi)
08:57:32 * Muad_Dib was wondering, is there a haskell sdf grammar?
08:59:37 <tomdavie> mwuhuhuhuhuhuhuhuhu!
09:00:01 <tomdavie> my latest one runs as fast... but finds 12500 lychrel numbers when searching those beneath 10000
09:01:19 <basti_> hmm
09:01:24 <basti_> thats quite a few
09:01:57 <tomdavie> hehe... they're all lychrel numbers... they're just not all less than 10,000
09:02:16 <tomdavie> it searches those less than 10000, and finds some others, just for good measure
09:02:34 <basti_> cool.
09:02:37 <xs_> memoising?
09:02:46 <tomdavie> yeh
09:03:17 <xs_> nice, i didn't quite get how to impose a 50 limit on mine, i'm sure there's an elegant way :)
09:04:00 <xs_> hello shapr! what is the shap operator?
09:04:25 <shapr> I suspect you could accuse my fiancee of operating me, if that's what you're asking.
09:04:41 <shapr> I am but a puppet.
09:04:44 * basti_ head.hurts.
09:04:53 <shapr> basti_: Too much CT? or too much vodka?
09:04:57 <shapr> xs_: What were you asking?
09:05:08 <basti_> too much exposure to bad jokes.
09:05:13 <xs_> shapr: i read shapr as shap right. i was wondering what shap was
09:05:13 <shapr> danb: y0! How's code?
09:05:25 <shapr> oh, I see. foldr - shapr
09:05:28 <lisppaste2> beelsebob annotated #9709 with "woo yay... sillyness" at http://paste.lisp.org/display/9709#9
09:05:36 <xs_> it wasn't intentional? oh.. sorry!
09:05:42 <shapr> Actually shapr is short for shaper which is short for synesthesist.
09:05:54 <xs_> that makes sense :)
09:05:55 <basti_> it is?
09:05:59 <tomdavie> that last one is really fast now :)
09:06:04 <shapr> basti_: Yeah, what did you think/
09:06:16 <shapr> Greetings Mr Hoogle, when will the source be released?
09:06:37 <tomdavie> evening neil
09:07:05 <basti_> shapr: uhm.. i think shaper is a word of its own rights
09:07:24 <basti_> wouldnt know why someone could percieve it as short for synaeslongword
09:07:25 <shapr> basti_: Yes, but in my case it's not.
09:07:33 <basti_> hmmm okay.
09:07:42 <danb> shapr: ahoy. i'm doing more reading than coding, these days
09:07:49 <shapr> Reading interesting stuff?
09:07:50 <ndm> oh, ah - talking to me :)
09:08:07 <ndm> its already up in darcs
09:08:17 <shapr> oh cool, where at?
09:08:24 <shapr> @google hoogle darcs
09:08:26 <Muad_Dib> so, nobody knows if there exists a haskell sdf?
09:08:26 <ndm> http://www-users.cs.york.ac.uk/~ndm/darcs/hoogle/
09:08:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/_darcs/inventory
09:08:32 <ndm> nope, not documented at all
09:08:44 <shapr> Muad_Dib: You mean SDF2 the MetaEnvironment thingy?
09:08:49 <ndm> i will document, refactor, write extra at some point
09:08:52 <danb> shapr: yes: pure type systems and neal stephenson's diamond age
09:09:28 <shapr> Oh, Diamond Age is great.
09:09:33 <tessier> Diamond Age is way cool
09:09:42 <shapr> I've often wished for a real "Young Lady's Primer"
09:09:44 * tessier has that book sitting right on his desk next to the laptop
09:09:48 <tessier> shapr: Are you a young lady?
09:09:53 <ndm> what happened to the attribute grammar article in TMR?
09:10:01 <danb> hehe
09:10:04 <shapr> But I could live with a dependency chart for the math section of wikipedia.
09:10:07 <Muad_Dib> shapr : yeah, if thats the  modular syntax definition formalism
09:10:21 * tessier is trying to understand continuations
09:10:24 <danb> shapr: does such a thing exist?
09:10:25 <shapr> Muad_Dib: If you need integrate you can use the Haskell ATerm library.
09:10:30 <tessier> There is a lot of math in learning haskell
09:10:48 <basti_> yes especially category theory
09:11:05 <tessier> Which I know nothing about.
09:11:06 <shapr> danb: There's Haskell. I've ended up piling systems on top of each other in my head to understand Haskell's inner workings.
09:11:06 <Muad_Dib> shapr: i was talking about parsing haskell by feeding the sdf file into a parser generator :P
09:11:11 <shapr> ohhh
09:11:29 <Muad_Dib> talking == thinking
09:11:47 <shapr> I don't know if there's a Haskell parser in SDF2 format.
09:11:57 <shapr> tessier: I am an old man.
09:12:09 <shapr> dang, I was just going to talk to ndm.
09:12:18 <shapr> Since I'm Mr TMR.
09:12:28 <shapr> food time, bbl
09:12:30 * shapr &
09:18:37 * tomdavie yawns
09:19:44 <tomdavie> why is every passpart photo machine in canterbury fucked?
09:21:04 <basti_> you should ask the man who fucked them
09:21:16 <tomdavie> boom boom tish
09:33:29 * basti_ drops a needle
09:33:44 * tomdavie pokes basti with it
09:34:01 <basti_> hey.
09:35:27 <Speck> hoisted by your own petard
09:36:01 <basti_> "petard"... what a word...
09:36:19 <tomdavie> @google "define: petard"
09:36:21 <lambdabot> http://ml.islandnet.com/pipermail/dixielandjazz/2002-July/001639.html
09:36:38 <basti_> i vaguely remember it
09:36:42 <tomdavie> i see
09:37:00 <basti_> its "farter" literally isnt it?
09:37:10 <tomdavie> would be useful if lambdabot pulled out definitions rather than links then
09:37:37 <basti_> oh yes.
09:38:09 * tomdavie wonders...
09:38:13 <tomdavie> @google 5 + 6
09:38:14 <lambdabot> No result found.
09:38:18 <tomdavie> bah
09:39:05 <Speck> is lambdabot screenscraping or does it use the api?
09:39:14 <tomdavie> pass
09:39:28 <tomdavie> I'm guessing it hunts for the first URL
09:39:45 <tomdavie> (first non-google URL)
09:42:25 <tessier> @google poofter
09:42:27 <lambdabot> http://www.peevish.co.uk/slang/p.htm
09:44:51 <Itkovian> hi all
09:44:57 <Itkovian> back for a few minutes
09:45:06 <tomdavie> itkovian
09:45:23 <tomdavie> were you getting involved in the grand lachrel number piss about earlier?
09:46:07 <Itkovian> nope
09:46:14 <tomdavie> fair enough
09:46:18 <Itkovian> well, that depends on what you mean...
09:46:28 <Itkovian> I was on till 15.52 CET
09:46:31 <Itkovian> :-)
09:46:37 <Itkovian> and it's lychrel ;-)
09:46:41 <tomdavie> lol
09:46:47 <tomdavie> http://paste.lisp.org/display/9709#9
09:47:00 <Itkovian> anyway, got some ironing to do
09:47:06 <tomdavie> do you think I went complex enough with the solution?
09:48:37 <danb> Speck: lambdabot might use the "I'm Feeling Lucky" url and just grab the redirect url
09:48:48 <tomdavie> ah, that would make sense
09:48:54 <danb> http://google.com/search?q=foo&btnI
09:49:17 <tomdavie> @google foo
09:49:19 <lambdabot> http://www.foofighters.com/
09:49:22 <tomdavie> same result
09:49:28 <danb> :)
09:49:50 <danb> now run it through QuickCheck to test the theory more thoroughly ;)
09:50:01 <tomdavie> heh
09:50:23 <tomdavie> mmm... and then through hat-delta to fine where divergances are caused...
09:50:31 <tomdavie> damn... haven't written hat-delta yet
09:52:11 <Itkovian> holy smoke tomdavie
09:52:17 <tomdavie> hehe
09:52:26 <tomdavie> it may be complex... but it's fast
09:52:54 <Itkovian> how fast?
09:52:56 <tomdavie> and it can be made to produce more lychrels in the same time... if you remove the tweak to stop it overproducing
09:53:18 <tomdavie> about 10% faster than the easy one... *grins and ducks*
09:53:55 <tomdavie> I think actually, it'll get faster for larger inputs
09:54:00 <basti_> youre still trying to find palindromes?
09:54:12 <tomdavie> yeh
09:56:16 <tomdavie> although... it doesn't appear to be linear... which I expected it to be
09:56:29 <basti_> i remember something about that
09:56:34 <basti_> vaguely
09:56:40 <tomdavie> either that or it is worst case 50n, and is getting lucky with the lower numbers
09:56:50 <basti_> hum
09:56:56 <basti_> 50 n = n
09:56:58 <basti_> =)
09:57:06 <tomdavie> yes
09:57:21 <tomdavie> but my point is that from external observations it doesn't appear linear
09:57:33 <basti_> well i remember it being superlinear
09:57:38 <tomdavie> but I wonder if that's because it's tending towards 50n as n goes up
09:57:42 <basti_> n^2 even, although im not sure
09:57:51 <basti_> have you tried statistical fitting stuff?
09:57:51 <tomdavie> it shouldn't be...
09:58:01 <tomdavie> I haven't
09:58:05 <tomdavie> but I can't be arsed
09:58:20 <basti_> not.
09:59:31 <tomdavie> actually... having tried a few more data points... I think it is linear
09:59:37 <tomdavie> it's just getting lucky early on
10:00:25 <basti_> hmm
10:00:40 <basti_> yes maybe the problem i remember wasnt "is this whole thing a palindrome"
10:00:49 <basti_> but maybe "finding the maximum subpalindrome" or whatever
10:01:09 <tomdavie> that sounds exponontial at first thought
10:01:24 <basti_> vague.
10:01:24 <basti_> :)
10:01:46 <tomdavie> I'm pretty sure mine is taking about 2.5s for each 10k numbers... but 1.1 for the first 10k
10:02:12 <basti_> hmm
10:02:27 <basti_> have you made some profiles?
10:02:39 <tomdavie> no
10:03:05 <basti_> maybe this coincides with something
10:07:29 <basti_> haskell code is a little like yeast dough
10:07:37 <basti_> locked in a tupper box.
10:07:59 <tomdavie> and on top of a radiator?
10:08:37 <Itkovian> :-)
10:08:39 <basti_> yes. and in 10x playback speed
10:08:48 <basti_> you put it in your memory
10:08:50 <basti_> and WOW it rises
10:08:54 <tomdavie> heh
10:09:01 <basti_> pulses... eats everything it gets
10:09:09 <basti_> until it hits the lid
10:09:23 <basti_> then it starts to foul a little in the middle.
10:23:09 <Lemmih> Yo SyntaxNinja.
10:23:18 <SyntaxNinja> y0
10:25:26 <basti_> http://deimos.dynalias.org/kommutativdistributiv.pl < what do you guys say about that?
10:26:18 <wilx> That you smoke too much weed ^_^
10:26:27 <basti_> aww.
10:26:41 <basti_> really?
10:26:52 <wilx> And that you should make your Perl programs using strict;
10:27:12 <basti_> this program is to be taken with a grain of salt
10:27:51 <wilx> I know :)
10:28:11 <basti_> do you see the lambda calculus logic?
10:28:24 <basti_> $t and $f?
10:29:01 <wilx> Nope but I am not formally trained in it...
10:29:36 <basti_> in perl? actually thats a good thing.
10:31:26 <wilx> Heh, not Perl, though I am not trained in it either, I meant lambda calculus.
10:32:00 <basti_> i see
10:32:15 <basti_> but you know what currying is?
10:41:27 <wilx> Making foo (x, y) into foo x y?
10:54:14 <basti_> wilx: yes. thats applied lambda calc
11:06:32 <astrolabe> do {x<- #haskell; goodEvening x}
11:08:55 <basti_> uhm
11:08:58 <metaperl> goodEvening astrolabe
11:09:40 <adept> good(?) evening(?)
11:10:02 <metaperl> that goodEvening should be a function of messageRecipient timeZone
11:10:05 <metaperl> :)
11:10:35 <basti_> hard to implement
11:10:38 <adept> and return Maybe Bool
12:39:26 <Itkovian> pompompom
12:39:43 <TFK> pampampam
12:40:56 <basti_> lamlamlam
12:41:23 * TFK hums the llama song
12:41:38 <basti_> badgerbadgerbadgerbadgerbadgerbadgerbadgerbadgermushroommushroom
12:50:51 <jlouis> mushrooms!
12:51:35 <basti_> mushrooms?
12:51:40 <basti_> psilocybe spp.?
13:25:49 <Igloo> Does anyone know the python for   os.environ['MAKE'] or 'make'   ?
13:34:42 <CosmicRay> Igloo: er?  didn't you just give python there?
13:35:17 <CosmicRay> oh, I see, you meant "or" to be the python operator...
13:35:25 <CosmicRay> if 'MAKE' in os.environ:
13:35:29 <CosmicRay>     then os.environ['MAKE']
13:35:36 <CosmicRay> bah
13:35:39 <CosmicRay> I'm thinking in Haskell
13:35:45 <CosmicRay> the if statement is correct anyway :-)
13:35:51 <Matt-W> this would be the right channel for it
13:35:56 <Matt-W> and I think  Python doesn't have the 'then'
13:35:56 <CosmicRay> heh
13:36:08 <Matt-W> but I'm not entirely sure... I don't do much with Python
13:36:09 <Igloo> ick. OK, thanks
13:36:17 <Matt-W> which reminds me, must learn Boo
13:36:17 <CosmicRay> matt-w: yeah, I was writing out a Python expression in Haskell syntax
13:36:31 <Matt-W> CosmicRay: not quite... sort of Pythonish syntax
13:36:33 <CosmicRay> Matt-W: which, incidentally, sounds like a thesis for someone :-)
13:36:35 <CosmicRay> Matt-W: heh
13:36:44 <Matt-W> nah, I already have a thesis project
13:37:12 <CosmicRay> Igloo: you could also say:
13:37:13 <CosmicRay> try:
13:37:17 <CosmicRay>    return os.environ['MAKE']
13:37:25 <CosmicRay> except KeyError:
13:37:27 <CosmicRay>     return 'make'
13:37:38 <Igloo> I was hoping it would be something small, but the obvious things (or, ||, ?:) didn't work
13:37:55 <CosmicRay> right, because the expression generates a KeyError, not a false value
13:38:47 <Igloo> Oh, I hadn't even thought about that. They didn't work as in didn't "compile", but they wouldn't have done what I wanted anyway
13:39:15 <TFK> Igloo, "MAKE" in os.environ and os.environ["MAKE"] or 'make'
13:39:24 <CosmicRay> there we go
13:39:40 <CosmicRay> however, there is a caveat to that in that it is not generalizable in the full manner of ?: in C
13:39:42 <TFK> Although, it won't work if os.environ["MAKE"] is '' (well, it will, but it will return 'make' instead)
13:39:45 <CosmicRay> so this works here but won't always
13:39:49 <TFK> Yes, it is a hack.
13:40:00 <TFK> There is no conditional expression in Python.
13:40:07 <Igloo> Really? Why did os.environ["MAKE"] or 'make' not compile then?
13:40:09 <CosmicRay> there is even an entry in the python faq about this method, iirc
13:40:23 <TFK> Igloo, "not compile"?
13:40:28 <TFK> As in, SyntaxError?
13:40:29 * Igloo didn't pay attention to the error, unfortunately, and can't test easily now
13:40:57 <Igloo> Oh, could have been the not-in-env runtime error, actually; I wasn't expecting to get that so wasn't looking for it
13:41:08 <TFK> The only compile-time errors I'm aware of is SyntaxError.
13:41:31 <TFK> At any case, os.environ["MAKE"] or 'make' won't work.
13:41:35 * Igloo has decided just to assume it's defined, anyway, which I suspect is the case
13:41:41 <TFK> Oh, there's a much better way.
13:41:50 <TFK> make = os.environ.get("MAKE", 'make')
13:42:08 <TFK> :-)
13:42:29 * TFK wonders why he chattered for half a screen before remembering the .get method...
13:42:30 <Igloo> Ah, I should have read past the first thing on the doc page then  :-)  Thanks
13:42:47 <Matt-W> oh that's much cooler
13:55:56 <CosmicRay> TFK: I wondered if it had a default option but I was too lazy to look itup :-)
13:56:17 <CosmicRay> TFK: see what happens after 6 months of hacking with haskell instead of python?  sheer laziness :-)
13:56:23 * TFK has the idle shell loaded up most of the time
13:56:34 <TFK> I need another ram stick, though ;_;
13:56:46 * CosmicRay has hugs :-)
13:57:00 * TFK has GuiCi
13:58:23 <TFK> So I'm guessing that building a state of the art, blazingly fast abstract shooter in Haskell is not a problem?
13:59:30 <TFK> (With HOpenGL and all)
14:05:22 <sond> abstract shooter? :)
14:06:11 <TFK> Yup. Are you familiar with them?
14:07:05 <sond> hmm. do you mean those aestethic shoot-em-ups with lots of flat shaded stuff?
14:07:28 <TFK> Not sure about the "flat shaded" part, but they're supposed to be aesthetic, yes.
14:07:48 <sond> ah okay, got ya
14:08:20 <sond> those are definitely possible to make
14:08:48 <sond> I think it's possible to make any game in Haskell ;)
14:09:02 <TFK> *no comment*
14:09:33 <wagle> (1) write C interpreter in Haskell (2) run it on the source for the FPS
14:09:50 <wagle> or.
14:09:52 <sond> maybe not state of the art games that are very cpu intensive.. but anything else
14:09:59 <wagle> (1) write x86 interpreter ...
14:10:12 <TFK> I was just thinking that since there are OpenGL bindings and Haskell should work well with all that abstract mathy stuff ;-), then it should be possible to create a packed abstract shooter that would run fast.
14:12:26 <sond> tfk, yep
14:12:29 <sond> :)
14:14:29 <TFK> I mean, a really packed shooter, that would run real fast :-P
14:16:34 * TFK will stop asking silly questions
14:31:22 <gaal> hi! i'm trying to diagnose problems with IO
14:31:53 <gaal> I'm calling IO.hTell on a handle which clearly isn't in position 0, but it's failing.
14:32:02 <gaal> how can i trace this?
14:32:18 <gaal> sorry, System.IO.hTell
14:34:59 <Lemmih> How does it fail?
14:36:20 <gaal> doesn't return a useful value. hmm, not catching the failure is probably a good idea :)
14:38:29 <gaal> how do i try this from inside ghci?
14:38:42 <gaal> this prints nothing: System.IO.Unsafe.unsafePerformIO $ do { x <- System.IO.openFile "t" System.IO.ReadMode ; return $ System.IO.hTell x }
14:39:15 <SyntaxNinja> unsafe hmm
14:39:27 <SyntaxNinja> you want to try that in ghci?
14:39:35 <Igloo> Lose the unsafePerformIO and print at the end of the do block
14:39:37 <monochrom> Why do you need unsafePerformIO?
14:39:46 * SyntaxNinja agrees with Igloo
14:39:49 <SyntaxNinja> as usual
14:39:52 <Igloo> I don't really see why it should print nothing, though
14:40:22 <SyntaxNinja> why should it?
14:41:15 <monochrom> your do{...} has type IO (IO Int) or some such, doesn't it?
14:41:41 <Igloo> Ah, yes. Without the return it'll print something
14:42:23 <gaal> okay, this does work correctly: do { x <- System.IO.openFile "t" System.IO.ReadMode ; y <- System.IO.hTell x ; putStrLn $ show y }
14:42:28 <gaal> (thanks)
14:42:44 <xs> openFile "hello.hs" ReadMode >>= hTell >>= print -- also works just fine.
14:42:47 <Igloo> putStrLn $ show is the same as just print
14:42:56 <gaal> cool
14:43:18 <gaal> now to make it fail in the real code.
14:47:09 <gaal> interesting!
14:47:11 <gaal> hGetPosn: illegal operation (seek operations on text-mode handles are not allowed on this platform)
14:47:29 <gaal> a Win32 issue, no doubt?
14:47:57 <TFK> A GHC on Win32 issue, perhaps.
14:48:38 <gaal> there's some other code that ought to have put the handle in binary mode, i'll see why that didn't happen.
14:48:38 <Igloo> Presumably because it doesn't know where to seek to without knowing how many \r's there are
14:48:46 <Igloo> Opening in binary mode would presumably fix it
14:48:58 <gaal> right.
14:49:57 <TFK> Seems to work in Python...
14:53:50 <Igloo> If the file contains "foo\r\nbarbaz" then does seeking to 8 and printing the next character give the same output for both text and binary modes?
14:55:44 <gaal> seek doesn't work either in text mode on w32.
14:55:50 <gaal> (in GHC)
14:56:29 <Igloo> I meant in python
14:56:52 <gaal> oh. dunno.
14:56:54 <TFK> Igloo, it appears so.
14:57:27 <TFK> (It prints 'r' on both)
14:58:56 <Igloo> OK, which is the 8th character (why isn't that off by one?) when you read the file in binary mode, but the 7th if you read it in text mode
14:59:12 <Igloo> So I assume ghc forbids it so you don't get that confusion
15:00:05 <TFK> I'm afraid I'm not familiar with win32 peculiarities :-(
15:08:09 * Beelsebob yawns
15:08:17 <gaal> okay, my current problem is that hIsWritable seems to lie
15:08:32 <gaal> i open a file in ReadMode, but hIsWritable is true.
15:09:22 <gaal> hey wait, not in ghci.
15:09:38 <gaal> hmm, i wonder what i'm doing wrong then.
15:12:44 <monochrom> You're hallucinating!
15:13:03 <Mou> does anyone know if Util.Memo will be ported over to the hierarchical libraries?
15:14:44 <SyntaxNinja> what's Util.Memo?
15:15:24 <jlouis> hah, now the TMR article is a lot nicer
15:18:20 <TheHunter> it implements memoization using a hashtable of pointers iirc.
15:19:04 <wagle> gaal: can you actually write to it?
15:20:06 <wagle> gaal: how old is your hugs?
15:20:08 <wagle> see http://www.mail-archive.com/haskell@haskell.org/msg14639.html
15:21:40 <Mou> is the source for Util.Memo available somewhere?
15:21:52 <Mou> or would i have to copy and convert it from sjp's paper?
15:21:57 <TheHunter> it's in fptools
15:22:00 <SyntaxNinja> gaal: I think hIsWritable probably refers to the premissinos of the file on disk, not the state of the handle
15:22:01 <wagle> @index Util.Memo
15:22:02 <lambdabot> bzzt
15:22:08 <SyntaxNinja> gaal: but that's just a guess
15:22:09 <wagle> @index Memo
15:22:10 <lambdabot> bzzt
15:22:13 <Mou> spj
15:22:14 <wagle> 8(
15:23:48 <TheHunter> @google "Memo.lhs.gz"
15:23:50 <lambdabot> No result found.
15:24:00 <TheHunter> wow.
15:24:09 <wagle> @type hIsWritable
15:24:10 <Beelsebob> @google "Memo.lhs"
15:24:15 <lambdabot> bzzt
15:24:17 <lambdabot> http://www.haskell.org/pipermail/cvs-hslibs/2004-October/002031.html
15:24:39 <SyntaxNinja> irc == your web browser
15:24:56 <TheHunter> @google Memo.lhs site:cvs.haskell.org
15:24:58 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hslibs/lang/Attic/Exception.lhs
15:25:06 <wagle> /Users/wagle/class/fp-cse502/SOE-Code/Memo.lhs
15:25:20 <wagle> SOE is the text
15:25:30 <wagle> /sw/share/hugs/lib/exts/Memo.hs
15:25:39 <TheHunter> that's it: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hslibs/util/Memo.lhs?rev=1.8
15:25:50 <wagle> @google Memo.hs
15:25:52 <lambdabot> http://www.haskell.org/pipermail/cvs-nofib/2001-August/000091.html
15:26:07 <TheHunter> module Memo {-# DEPRECATED "This module is unmaintained, and will disappear soon" #-}
15:26:59 <wagle> huh:
15:27:01 <wagle> % $Id: Memo.lhs,v 1.7 2002/10/08 18:42:38 panne Exp $
15:27:21 <SyntaxNinja> rawSystem "head" "-" $ fst @google Memo.hs
15:28:23 <Mou> seems a pity to lose
15:28:48 <Mou> thanks, grabbed the source from fptools
15:31:26 <Mou> exit
15:31:33 <Mou> argh
15:45:58 <gord> shapr: Have time to chat?
15:48:29 <gord> Does anybody here have experience with rHaskell (or Timer or O'Haskell)?
15:48:48 <gord> Erm, _Timber_, not _Timer_.
16:45:36 <wagle> gord: i know something of timber
17:08:48 * gord wonders again if there are any rHaskell, O'Haskell or Timber people out there.
17:11:04 <Pseudonym> <wagle> gord: i know something of timber
17:11:10 <Pseudonym> You weren't here at the time. :-)
17:14:13 <gord> Pseudonym: Ahh, good.  Sorry for logging off at the wrong moment. :)
17:15:20 <gord> I'm basically coming to Haskell as somebody who is entrenched in the reactive objects model of programming.  I was implementing something similar as a C library, but it looks like rHaskell is what I want.  So, I'm curious what your experience with reactive objects is.
17:20:45 <Pseudonym> You could also look at Fudgets and Haskell ports.
17:20:59 <Pseudonym> @google haskell ports
17:21:01 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ports/
17:21:13 <Pseudonym> @google fudgets
17:21:15 <lambdabot> http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/
17:21:46 <gord> Hmm... that's interesting, I'll look at those now.
17:24:55 <dcoutts> I like the idea of Manuels ports, the details confuse me however :-)
17:25:09 <Pseudonym> Well they're very like Erlang.
17:25:13 <dcoutts> I should look at it again some time
17:25:14 <Pseudonym> Only strongly typed. :-)
17:26:02 <dcoutts> I've also been looking at FG which is another GUI abstraction implemented on top of Gtk bindings
17:50:49 <gord> dcoutts: Where can I find FG?
17:52:27 <dcoutts> gord, http://kevin.atkinson.dhs.org/fg/
17:53:17 <dcoutts> see also a couple email discussions starting with these messages:
17:53:18 <dcoutts> http://www.haskell.org/pipermail/haskell/2005-March/015541.html
17:53:25 <dcoutts> http://www.haskell.org/pipermail/haskell/2005-March/015573.html
17:53:46 <dcoutts> actually the discussion was only in response to that first email
17:56:21 <gord> Hmm.  It really looks like the functional interface to graphics systems is a controversial topic, with no clear winners (at least for Haskell).  Too bad. :(
17:56:53 <dcoutts> well, when one wins we'll implement it on top of Gtk2Hs :-)
17:57:15 <gord> Good. :)
18:04:18 <Pseudonym> I think it's generally true that interfaces to graphics systems is a controversial topic.
18:04:35 <Pseudonym> In any language which provides good support for more than one paradigm, anyway.
18:05:30 <dcoutts> I think it's interesting that people really want a declarative/functional graphics system but are quite happy with the IO monad for file/text based IO
18:06:22 <Pseudonym> There's a feeling, I think, that interfaces should be "fire and forget".
18:06:29 <dcoutts> in fact we abandoned declarative I/O (interact etc) for the IO monad
18:06:38 <dcoutts> Pseudonym, how do you mean?
18:06:41 <mflux_> @timein washington
18:06:52 <Pseudonym> I mean you set up the interface, and then you just let it do the rest.
18:07:00 <wagle> mflux_: state of wash?
18:07:04 <Pseudonym> GUI toolkits in other languages are going that way.
18:07:10 <Pseudonym> For example, signal/slot-based systems.
18:07:23 <mflux_> oh
18:07:25 <dons>  hmm. @timein could do with some tweaks. it doesn't handle spaces in city names, for example
18:07:29 <dons> or multiple matches
18:07:34 <dons> e.g. for 'washington'
18:07:51 <wagle> its 6:09 in the state of washington
18:07:54 <wagle> pm
18:09:39 <dcoutts> Pseudonym, yes it'd be nice, rather than saying "when this happens do that" and more like "sync this bit of time varying state to that bit of time varying state using this translation function"
18:10:01 <dcoutts> (which is sort of what Manuels ports are supposed to do)
18:12:02 <Pseudonym> Right.
18:12:24 <Pseudonym> Fudgets has the problem that the arrow stream processors aren't readily reconfigurable.
18:12:25 <Pseudonym> Ports are.
18:13:48 <dcoutts> the limitiation of ports last time I looked is that they don't seem to work well for the case of the time-varying state being large, eg a list or tree of things, or a text buffer, where you want to know what changed rather than just the new state
18:14:21 <dcoutts> for small things, eg a bool, integer states, then the new state is just fine
18:14:51 <dcoutts> for other things you really need the sequence of commands/updates that give the changed states
18:15:12 <dcoutts> that's the only way I can see to make the stuff effecient
18:19:56 <dcoutts> in a "send diffs" system, the "send new state" style can be a special case where the update command is just "make the new state be 3"
18:24:12 <gord> I'm looking at Ports now, and it seems quite interesting.  What's to prevent a port of deltas?
18:25:02 <gord> I mean, you could have linked ports, one of which keeps a periodic snapshot of all the state, and the other of which is just the deltas.
18:25:33 <dcoutts> ok, so it'd be possible just a tad inconvenient perhaps
18:26:23 <dcoutts> I'd have to look at the ports idea (and implementation) again, I'm not sufficiently familiar with it
18:27:13 <gord> I may be wrong about the linkage... it may require the same number of state changes for each port.
18:28:07 <dcoutts> I'm not sure I follow
18:34:38 <gord> Hrmm, I may just be losing coherency. ;)  More to look at, anyway.  I've got to go.
19:52:53 <MachinShin> hey all
20:33:16 <Spark__> damnit, i just spilt wine on my operational semantics
20:49:39 <tessier> Spark__: I'm sure they will still work just fine. Just take a shower and wash them off.
20:50:27 <Spark__> theyre in biro so everythings going to be ok
20:53:31 <Pseudonym> I prefer clean semantics.
20:54:35 <Spark__> it was white wine
20:54:41 <Spark__> since i said its actually dried perfectly
20:56:05 <Pseudonym> As the quotes page says, don't drink and derive.
20:56:16 <Spark__> heh
20:56:19 <Spark__> ive not heard that one before
20:56:50 <dons> @quote Pseudonym
20:56:51 <lambdabot>  Well, personally, I don't think dumb people should be let near a
20:56:51 <lambdabot> programming language.
20:56:53 <dons> @quote Pseudonym
20:56:55 <lambdabot>  Well, personally, I don't think dumb people should be let near a
20:56:55 <lambdabot> programming language.
20:56:57 <dons> @quote Pseudonym
20:56:58 <lambdabot>  Lazy evalution is really, really trippy.
20:57:00 <Spark__> @quote dons
20:57:00 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and
20:57:00 <lambdabot> ugly
20:57:08 <dons> bah. too many quotes from Pseudonym..
20:57:09 <dons> @quote Pseudonym
20:57:09 <Spark__> @quote dons
20:57:10 <lambdabot>  don't drink and derive.
20:57:10 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and
20:57:10 <lambdabot> ugly
20:57:24 <Spark__> @quote shapr
20:57:25 <lambdabot>  I've tried to teach people autodidactism, but I've realized they
20:57:25 <lambdabot> have to learn it for themselves.
20:57:27 <Pseudonym> Oh?  How many am I up to?
20:57:31 <Pseudonym> @quote Pseudonym
20:57:32 <lambdabot>  Well, personally, I don't think dumb people should be let near a
20:57:32 <lambdabot> programming language.
20:57:37 <dons> well, 3 at least ;)
20:57:39 <Spark__> @quote Spark
20:57:40 <Pseudonym> @quote dons
20:57:41 <lambdabot> Spark hasn't said anything memorable
20:57:41 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and
20:57:41 <lambdabot> ugly
20:57:52 <Pseudonym> @quote Pseudony,m
20:57:53 <lambdabot> Pseudony,m hasn't said anything memorable
20:57:54 <Pseudonym> @quote Pseudonym
20:57:55 <lambdabot>  Lazy evalution is really, really trippy.
20:57:56 <Spark__> @moo
20:58:01 <dons> no moo for you!
20:58:06 <Spark__> :<
20:58:47 <Pseudonym> This is the quote from the quotes page:
20:58:52 <Pseudonym> <tez> Anyway, I think the lesson is "don't drink and derive".  Or something.
20:59:03 <Pseudonym> So I can't claim it.
20:59:19 <dons> @remember tez I think the lesson is "don't drink and derive".
20:59:50 <dons> it seems to me that mzscheme is kind of hungry: Swap: 302M
21:03:49 <Pseudonym> Is there a way to query lambdabot about how many quotes each person has?
21:03:51 <Pseudonym> @quote
21:03:52 <lambdabot>  says:
21:03:55 <Pseudonym> Oooh.
21:04:02 <Pseudonym> I reckon that should pick one at random.
21:04:17 <dons> @quote
21:04:18 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly
21:04:18 <lambdabot> responsible for hastening the adoption of functional programming
21:04:18 <lambdabot> languages by providing a caricature of procedural OO.
21:04:24 <Pseudonym> Hmmm.
21:04:28 <dons> hmm :/
21:04:30 <Pseudonym> @quote
21:04:31 <lambdabot> skew says: We don't believe in constant factors.
21:05:00 <dons> there's no other interface, other than @quote, @quote <nick>
21:05:14 <dons> feel free to darcs send yadda yadda ;)
21:11:40 <Spark__> java is a caricature of shite syntax
21:18:35 <Pseudonym> @remember Spark java is a caricature of shite syntax
21:18:40 <Pseudonym> Done.
21:27:29 <seafood> @quote
21:27:30 <lambdabot> blackdog says: i'm not encouraged by the comment "i don't know
21:27:30 <lambdabot> haskell, but CL is much better", though. it doesn't suggest careful
21:27:30 <lambdabot> thought and objectivity...
21:31:48 <Pseudonym> @quote lambdabot
21:31:49 <lambdabot> lambdabot hasn't said anything memorable
21:31:56 <Pseudonym> Ain't that the truth.
21:32:17 <Pseudonym> @remember lambdabot lambdabot hasn't said anything memorable
21:33:34 <seafood> @quote lambdabot
21:33:34 <lambdabot>  lambdabot hasn't said anything memorable
21:33:54 <seafood> Pseudonym: Extensionally equivalent
21:34:02 <Pseudonym> True.
21:34:22 <Pseudonym> @quote
21:34:24 <lambdabot> jlouis says: Q: When does one know he has programmed too much
21:34:24 <lambdabot> Haskell? A: When he uses == and /= in everyday IRC chat or when he
21:34:24 <lambdabot> tries to fix a relationship by passing himself as a continuation
22:09:01 <lispy> heh, that's a great quote
22:18:22 <lispy> what is the command for using parsec with ghc again?
22:18:37 <lispy> ghc Toyparser.hs -package text.parsec
22:18:56 <lispy> that and just parsec (without the text) give errors
22:19:07 <lispy> unknown package: text.parsec
22:19:27 <lispy> oh
22:19:35 <lispy> -package text
22:20:56 <Speck> test.parsercombinators.parsec
22:21:03 <dons> -package parsec ?
22:21:05 <Speck> *text
22:21:48 <lispy> -package text is what i needed
22:58:48 <dons> @code
22:58:49 <lambdabot> Err.lhs: %*********************************************************
22:58:54 <dons> @code
22:58:55 <lambdabot> Ix.hs: -----------------------------------------------------------------------------
22:58:58 <dons> bah!1
22:58:59 <dons> @code
22:59:00 <lambdabot> ReadPrec.hs: instance Functor ReadPrec where
22:59:04 <dons> @yow
22:59:05 <lambdabot> Let me do my TRIBUTE to FISHNET STOCKINGS ...
23:15:43 <pejo> Ok. How do i get the register representation of a "Reg" in GHC? (cmmRegRep wants a CmmReg, not a Reg)
23:16:17 <pejo> And how do I convert from a BlockId to a CLabel?
23:50:23 <dons> hmm. can you even go from a BlockId back to a CLabel?
23:50:34 <dons> don't we only go the other way?
23:51:34 <dons> oh. no. they don't represent the same things
23:51:43 <dons> CLabels are identifiers, like variable names
23:51:50 <dons> block ids are cmm blocks
23:52:24 <dons> newtype BlockId = BlockId Unique
23:54:49 <dons> pejo, been a while since i've been poking around this code
23:56:05 <dons> but it looks like BlockIds are specifically designed to be separate from CLabels
