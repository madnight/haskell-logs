00:00:17 <dons> @hep index
00:00:18 <lambdabot>  @index
00:00:30 <dons> oh
00:00:40 <dons> :}
00:02:01 <soysauce> hm, is it possible to have multiple mutable arrays which are sequenced with respect to each other?
00:02:16 <soysauce> I have 4 or 5 arrays, basically I want to know if I can keep them in the same ST monad
00:02:23 <soysauce> but I'm guessing the answer is no
00:10:14 <Cale> soysauce: yes, it is possible
00:10:19 <Cale> very possible
00:10:39 <Cale> ST allows arbitrary mutable references and STArrays
00:11:08 <Cale> But you're only allowed to compute what are actually pure functions
00:11:37 <Cale> @type Control.Monad.ST.runST
00:11:38 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
00:12:59 <dons> yep, just a few STRefs would do the trick
00:13:27 <Cale> Well, if you're using the ST monad, why not use STArrays? :)
00:15:04 <Cale> Especially as it sounds like there's mutation going on
00:24:34 <araujo> index rawSystem
00:24:42 <araujo> @index rawSystem
00:24:43 <lambdabot> System.Cmd, Distribution.Compat.RawSystem
00:28:04 <soysauce> I am using STUArrays
00:38:43 <araujo> rawSystem "cut" ["-d", "' '", "-f4", "test.txt"]
00:38:58 <araujo> Anybody could tell me why that doesn't work?
00:39:20 <araujo> It looks like it isn't passing ' ' correctly.
00:39:55 <araujo> Though i also tried to escape it
00:44:52 <boegel|home> araujo, you want to pass the string ' ', or just a space ?
00:45:06 <araujo> Just a space.
00:45:15 <boegel|home> why not use " " then ?
00:45:42 <araujo> oh, it doesn't work either :-/
00:46:22 <araujo> oh, yup.. it works
00:46:31 <boegel|home> well, I always pass a space like that, so there's shouldn't be any problem
00:46:32 <araujo> dam, i thought i already had tried that :-P
00:46:37 <boegel|home> see? ^_^
00:49:47 <ricebowl> you could just write "cut" ["-d -f4 test.txt"] couldn't you? :p
00:52:43 <boegel|home> ricebowl: no, that's not the same
00:52:54 <boegel|home> a String is an array of type Char, not of type String
00:53:28 <ricebowl> the types are the same
00:53:45 <ricebowl> > unwords ["-d", "' '", "-f4", "test.txt"]
00:53:46 <lambdabot> "-d ' ' -f4 test.txt"
00:53:54 <ricebowl> @type ["-d", "' '", "-f4", "test.txt"]
00:53:54 <lambdabot> [[Char]]
00:55:25 <araujo> @type rawSystem
00:55:26 <lambdabot> Not in scope: `rawSystem'
00:55:37 <ricebowl> @type System.Cmd.rawSystem
00:55:38 <lambdabot> String -> [String] -> IO GHC.IOBase.ExitCode
00:55:39 <araujo> @type System.Cmd.rawSystem
00:55:39 <lambdabot> String -> [String] -> IO GHC.IOBase.ExitCode
00:55:47 <araujo> there it is...
00:58:01 <boegel|home> ricebowl: what you were doing, is of type String -> String -> ExitCode, which is not the same :)
00:58:11 <ricebowl> no
00:58:16 <ricebowl> @type ["-d -f4 test.txt"]
00:58:17 <lambdabot> [[Char]]
00:58:51 <boegel|home> oh, yeah, well ok
00:58:56 <boegel|home> but it's not the same :P
00:59:03 <ricebowl> I just coagulated the string
00:59:21 <ricebowl> I suspected that the end result was not quite the same, but also expected that the system would "do the right thing"
00:59:33 <ricebowl> so on a high level they are semantically equal.
00:59:52 <boegel|home> ok nvm :)
01:02:11 <Heffalump> you shouldn't do that
01:02:31 <Heffalump> if you pass one long argument string, it has to invoke a shell to parse it
01:02:39 <Heffalump> whereas if you pass arguments one by one, it doesn't
01:02:51 <ricebowl> ah, I see; I didn't realize that they come preparsed
01:03:03 <Heffalump> the former makes you rather more vulnerable to people playing silly games with shell escapes etc
01:38:04 <kosmikus> morning
01:38:59 <Speck> is anyone here familiar with Coq?
01:46:54 <ProfTeggy> Moin
01:50:28 <xinming> evening all,
01:50:44 <xinming> which Monad you all think is hardest to grasp please? :-)
01:52:32 <TuringTest> One which provides partial continuations.
02:02:02 <takuan> is there something like a polynomial data type in Haskell?
02:02:15 <ricebowl> [Int] seems like a good one to me
02:05:26 <cpatrick> depending on what your polynomials are defined over
02:12:27 <takuan> well
02:12:51 <takuan> we want to use them together with vectors, the latter being represented like a list
02:16:30 <takuan> damn
02:16:48 * takuan is forgetting the simple usefull functions all the time
02:17:14 <takuan> which function do we use to apply a function to all the elements of a list with an accumulating state?
02:17:18 <Azmo> if one has a data type with a constructor that uses the same name, how can one export both from a module? e.g "module A(T) where data T = T Int" gives "Warning: Defined but not used: data constructor `T'" since it is not used in the module because it is not exported.
02:21:52 <cpatrick> takuan: fold(l|r|M) usually
02:24:03 <Azmo> ah. solved it. "module A(T(T)) where data T = T Int"
02:25:40 <bojohan> T(..) exports the type with its constructors
02:26:42 <Azmo> yep :]
02:40:36 <ricebowl> @type length
02:40:37 <lambdabot> forall a. [a] -> Int
02:40:48 <ricebowl> @hoogle [a] -> b
02:40:49 <lambdabot> Data.List.head :: [a] -> a
02:40:49 <lambdabot> Data.List.last :: [a] -> a
02:40:49 <lambdabot> Prelude.head :: [a] -> a
02:41:00 <ricebowl> @hoogle Integral b => [a] -> b
02:41:01 <lambdabot> Data.List.length :: [a] -> Int
02:41:01 <lambdabot> Prelude.length :: [a] -> Int
02:42:00 <ricebowl> @pl fromIntegral . length
02:42:00 <lambdabot> fromIntegral . length
02:42:29 * drrho is away: airport
02:43:05 <ProfTeggy> ricebowl, looking for genericLength :: (Num a) => [b] -> a   ?
02:43:20 <ricebowl> yes!
02:44:09 <ricebowl> thanks
02:44:19 <ProfTeggy> np
03:20:55 <ricebowl> @pl f (x, y) = x <= y
03:20:56 <lambdabot> f = uncurry (<=)
03:29:08 <araujo> Good morning.
03:31:32 <Azmo> i think there is some way to specify GHC compilation flags within a haskell file. anyone know the syntax for that?
03:33:05 <ski> {-# OPTIONS ... #-}
03:33:15 <Azmo> thx
03:37:26 <Azmo> hm... does not seem to work. does it only work with GHC? because GHCI seems to ignore "{-# -W -fwarn-name-shadowing -fwarn-missing-signatures #-}".
03:38:21 <xs_> {-# OPTIONS -fwarn-name-shadowing ... #-} ?
03:38:35 <Azmo> ah, ok. thanks.
03:45:24 <xs_> why does mplus for transformers run the inner monad for all alternates? doesn't seem very lazy.
03:46:30 <ski> (maybe your transformer isn't very lazy ..)
03:47:41 <xs_> hm. i was looking at ListT and also MaybeT from pugs.
03:49:00 * araujo off to breakfast
03:52:32 <Gs30ng> does Gtk2hs module do nothing in ghci?
03:52:55 <xs_> heh ErrorT does it lazily. weird.
03:53:47 <Gs30ng> what's wrong with my ghci... i don't see any gtk+ window :(
04:16:13 <kzm> @seen
04:16:13 <lambdabot> Lately, I have seen boegel, kzm, ski and speck.
04:17:36 <ricebowl> @pl f fs = (sum (map fst fs)) > (sum (map snd fs))
04:17:37 <lambdabot> f = ap ((>) . sum . map fst) (sum . map snd)
04:18:21 <ricebowl> @pl f xs = foldl1 (\(x1, y1) (x2, y2) -> (x1+x2, y1+y2)) xs
04:18:22 <lambdabot> f = foldl1 (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (.
04:18:22 <lambdabot> (+)) . flip . (((.) . (,)) .) . (+)))
04:18:25 <ricebowl> gah
04:19:01 <ricebowl> @pl f xs = let (as, bs) = unzip xs in (sum as) > (sum bs)
04:19:01 <lambdabot> (line 1, column 6):
04:19:01 <lambdabot> unexpected "="
04:19:01 <lambdabot> expecting variable, "(", operator or end of input
04:19:25 <Lor> Hm, it would be interesting to see @pl use arrow combinators.
04:19:40 <Lor> (.) is (>>>), of course.
04:19:58 <Lor> (Well, arguments reversed, of course)
04:20:22 <ricebowl> @pl f xs = (sum (fst (unzip xs))) > (sum (snd (unzip xs)))
04:20:22 <lambdabot> f = ap ((>) . sum . fst . unzip) (sum . snd . unzip)
04:20:55 <cpatrick> is there a good tutorial somewhere on profiling with ghc?
04:21:33 <ricebowl> http://support.informatik.uni-freiburg.de/manuals/ghc/profiling.html
04:22:09 * kzm is getting desperate: Anybody here know (the statistics package) R?
04:23:19 <feucht> http://www.r-project.org/ , whats your problen
04:25:25 <cpatrick> ricebowl: thanks
04:25:32 <ricebowl> np
04:26:08 <cpatrick> what does it mean that I'm spending 8x as long GC'ing than actually running my code?! (if I'm reading the output right)
04:26:17 <ricebowl> what is the output?
04:26:19 <cpatrick> too much laziness?
04:26:25 <cpatrick>   MUT   time   21.73s  ( 23.24s elapsed)
04:26:26 <cpatrick>   GC    time  162.56s  (172.22s elapsed)
04:26:32 <ricebowl> ah
04:26:39 * ricebowl isn't too familiar with it but assumes you're right
04:27:06 <ricebowl> how lengthy is your code?
04:27:36 <ricebowl> and have you tried profiling 'generally' or whatever you would call it?
04:27:49 <ricebowl> if it's just GC time then I'd assume that the creator of the most garbage is responsible
04:28:01 <cpatrick> longish, >1000 lines
04:28:02 <ricebowl> which is ultimately going to be something in an inner loop somewhere that's creating needless objects
04:28:23 <cpatrick> yeah, that's probably the case
04:28:53 <cpatrick> if there's something consuming a list as it's being created, that should be okay though, right?
04:29:20 <ricebowl> depends--what do you mean by 'consuming a list as it's being created'?
04:30:42 <cpatrick> e.g. map foo (map bar (....)) - will that create a whole new list then GC it, or is it the same as (map (foo.bar) ....) memory-wise?
04:31:04 <ricebowl> my understanding has always been that it's the same as map (foo.bar)
04:31:31 <ricebowl> since map is a good producer and a good consumer, IIRC
04:33:04 <ricebowl> really, though, just look at the profiler output
04:33:11 <ricebowl> that will tell you who is creating the most garbage
04:33:28 <ricebowl> and if you want to know for sure, put an SCC on that expression
04:33:33 <cpatrick> SCC?
04:33:44 <ricebowl> whatever it's called, something Cost Center
04:34:02 <cpatrick> ahh
04:35:04 <cpatrick> Random.randomRIO seems to be generating most of the garbage !? :(
04:35:26 <ricebowl> I guess creating it in the IO monad is (relatively) expensive?
04:35:53 <cpatrick> I originally had it outside the IO monad and then and then my own rnd function was listed as the culprit
04:36:08 <ricebowl> *nods*
04:36:14 <ricebowl> well, maybe the library impl. could be improved
04:36:32 <cpatrick> but that's stupid because I'm not calling it that often (tens of thousands of times)
04:36:37 <ricebowl> I'm sure if you optimized it and made a patch, presuming that the maintainers felt it was worthwhile (likely?) they would incorporate it
04:36:50 * cpatrick sighs and looks at GHC source
04:41:11 <Gs30ng> ok
04:41:34 <Gs30ng> gtk2hs totally does not works
04:42:37 <Gs30ng> i've tried some demo .hs files on my ghci and nothing happened. no gui window appears
04:42:41 <Gs30ng> and so do in ghc
04:43:00 <cpatrick> ouch. *** glibc detected *** double free or corruption (!prev): 0x0820d178 ***
04:43:07 <ricebowl> :o
04:43:11 <cpatrick> I shouldn't be seeing that from a haskell program, right! :O
04:43:12 <ricebowl> ouch is right
04:43:43 <Gs30ng> i don't know why every gui modules don't work on my machine
04:44:01 <ricebowl> Gs30ng - you're unlucky it would seem :p
04:44:05 <cpatrick> only get it when profiling. it's too late at night for me to file a sane GHC bug now though
04:44:12 <Gs30ng> wxHaskell says "i need ghc6.4.0 but you only have ghc6.4.1 so i'm gonna terminate bye"
04:44:13 <ricebowl> cpatrick ;)
04:44:43 <Gs30ng> gtk2hs says everything is ok but it IS not ok there's no gui window 
04:44:52 <ProfTeggy> Gs30ng, at least it tries to be friendly
04:45:41 <dcoutts> Gs30ng, what's the problem exactly?
04:45:59 <Gs30ng> i installed ghc and then gtk2hs
04:46:16 <Gs30ng> and tried one demo file of gtk2hs in my ghci and ghc
04:46:28 <dcoutts> Gs30ng, what platform are you on?
04:46:39 * dcoutts is the Gtk2Hs maintainer
04:46:42 <Gs30ng> dcoutts, windows xp
04:46:48 <dcoutts> ah, ok
04:47:04 <ricebowl> always nice when you can talk to the maintainer of a package about an issue ;)
04:47:16 <Gs30ng> the thing is that on the command line window it says everything's done
04:47:47 <dcoutts> oh, oyu mean it opens a command line window and then quits
04:47:54 <dcoutts> oyu/you
04:48:30 <Gs30ng> well no
04:48:35 <Gs30ng> prompt comes
04:49:11 <dcoutts> so the prompt returns without anything seeming to have happened
04:49:14 <dcoutts> so which GHC, Gtk+, Gtk2Hs version did you install exactly?
04:49:28 <Gs30ng> ghc-6.4.1
04:50:27 <Gs30ng> and gtk+is...
04:50:50 <Gs30ng> gtk-win32-devel-2.8.8-rc2
04:51:02 <Gs30ng> gtk2hs-0.9.10
04:52:05 <Gs30ng> hmm wait
04:52:21 <Gs30ng> i tried typing "main" on that prompt
04:52:28 <Gs30ng> and now there's something like an error message
04:53:07 <Gs30ng> Loading package glib-0.9.10 ... can't load .so/.DLL for: glib-2.0 (addDLL: unknown error)
04:53:13 <Gs30ng> it says
04:57:18 <ski> goddagens, shapr
04:57:44 <dcoutts> Gs30ng, right. It doesn't work in GHCi. It will work with GHC-6.4.2
04:57:59 <dcoutts> Gs30ng, but it should work when compiled as a stand-alone .exe
04:58:06 <Gs30ng> 6.4.2?
04:58:10 <shapr> hej ski
04:58:23 <dcoutts> Gs30ng, GHC 6.4.2 will be the next minor release
04:58:40 <dcoutts> I submitted a patch to allow us to load the Gtk+ .dlls properly
04:58:59 <Gs30ng> then
04:59:03 * shapr hops
04:59:22 <Gs30ng> i should compile it whenever i want to test my gtk+ program?
04:59:27 <shapr> mi-ke: Are you the irc'er formerly known as phubuh?
04:59:31 <Gs30ng> i cannot just interpret the program?
04:59:34 <dcoutts> Gs30ng, right
04:59:44 <Gs30ng> that is inconvenient
04:59:48 <dcoutts> Gs30ng, eg: ghc.exe --make HelloWorld.hs
05:00:14 <Gs30ng> i've already tried it and it makes hello.hi and hello.o
05:00:18 <dcoutts> Gs30ng, yeah, sorry. That's why I've submitted a patch to GHC to make it work in the next version.
05:00:21 <Gs30ng> where's the .exe file?
05:00:52 <dcoutts> Gs30ng, if you say: ghc.exe --make Hello.hs -o foo
05:01:08 <dcoutts> then it'll be foo.exe, if you don't specify then it defaults to Main.exe
05:02:17 <Gs30ng> oh
05:02:18 <Gs30ng> ok
05:02:26 <Gs30ng> this is great
05:02:54 <Gs30ng> i can ask something about gtk2hs to the package maintainer
05:02:57 <Gs30ng> whoa
05:03:41 * shapr luvs #haskell
05:04:42 <ski> Haskell !!
05:04:45 <shapr> whee!
05:05:13 <ricebowl> Haskell!! :: Int -> (a -> b)
05:06:03 <jlouis> yay, Conjure updated! Lots of good stuff there, included that the should should (note the should) work ;)
05:06:11 <jlouis> s/should/seeding/
05:06:16 <ski> (ricebowl : isn't that C ? :)
05:06:27 <ricebowl> um?
05:06:46 <ricebowl> @type (!!)
05:06:46 <lambdabot> forall a. [a] -> Int -> a
05:06:58 <ski> (for any number, you can get a function taking whatever you want, and returning whatever you want (by casting number to function pointer))
05:07:12 <ricebowl> hah
05:07:24 <ricebowl> mayhaps
05:10:19 <dcoutts> Gs30ng, so it all works now?
05:10:45 <Gs30ng> yeap
05:10:46 <dcoutts> (appart from it not workign with GHCi which I know about)
05:10:48 <dcoutts> ok, cool
05:10:53 <Gs30ng> thanks a lot
05:12:03 <dcoutts> Gs30ng, did you notice the windows install notes?
05:12:04 <shapr> jlouis: yay!
05:12:05 <dcoutts> http://haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/
05:12:18 <dcoutts> Gs30ng, could it be more obvious on the gtk2hs web site?
05:12:29 <dcoutts> http://haskell.org/gtk2hs/download/
05:12:41 <Gs30ng> i checked that page
05:12:47 <Gs30ng> installation guide
05:13:10 <dcoutts> at the bottom of that page it says how to compile and that GHCi does not work
05:13:17 <dcoutts> perhaps it should be labeled better
05:13:25 <dcoutts> "quick start" guide or something
05:13:32 <dcoutts> what do you think?
05:14:46 <Gs30ng> oops.
05:15:01 <Gs30ng> i actually stopped reading that article when i met "You’re done!".
05:15:33 <dcoutts> right
05:15:53 <dcoutts> I'll add a new heading "Quick Start guide" for the rest of it
05:16:13 <dcoutts> http://haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/
05:16:16 <dcoutts> better now?
05:16:36 <Gs30ng> http://haskell.org/gtk2hs/documentation/
05:16:58 <Gs30ng> that hello world-blah section
05:17:09 <Gs30ng> should include notice about it
05:17:14 <dcoutts> good idea
05:19:50 <Cale> @djinn (a -> (b -> c)) -> ((a -> b) -> (a -> c))
05:19:51 <lambdabot> f a b c = a c (b c)
05:20:22 <Heffalump> @type Control.Monad.fix
05:20:23 <lambdabot> Not in scope: `Control.Monad.fix'
05:20:27 <Heffalump> @type Control.Monad.Fix.fix
05:20:28 <lambdabot> forall a. (a -> a) -> a
05:20:34 <Heffalump> @djinn (a -> a) -> a
05:20:34 <lambdabot> -- f cannot be realized.
05:20:51 <Heffalump> @. djinn type Control.Monad.fix.fix
05:20:52 <lambdabot> Cannot parse command
05:20:52 <lambdabot> Cannot parse command
05:20:57 <Heffalump> @help @.
05:20:57 <lambdabot>  @help <command> - ask for help for <command>
05:21:03 <Heffalump> @help .
05:21:04 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
05:21:04 <lambdabot> f
05:21:17 <ricebowl> huh, interesting
05:21:22 <Heffalump> @. @djinn @type Control.Monad.fix.fix
05:21:22 <lambdabot> compose module failed: Parse error: "@djinn"
05:21:31 <gour> dcoutts: ping
05:21:33 <Heffalump> @. (djinn,type) Control.Monad.Fix.fix
05:21:34 <lambdabot> compose module failed: Parse error: "(djinn,type)"
05:21:39 <Heffalump> bah.
05:22:03 <dcoutts> gour, pong
05:22:28 <gour> dcoutts: have you got my pm yesterday?
05:22:41 * dcoutts looks
05:23:12 <dcoutts> gour, oh, to delete comments marked as spam after 7 days?
05:23:16 <dcoutts> that seems fine to me
05:23:50 <gour> dcoutts: ok, let me activate it then, lot of grains on the sack :-)
05:24:05 <dcoutts> thanks gour 
05:24:40 * gour notices that dcoutts likes to see fishes in adriatic see only
05:27:19 <gour> dcoutts: there are few sql errors, we're paying the fee for old mysql :-(
05:27:32 <dcoutts> hmm
05:28:09 <takuan> why do I get an error like this
05:28:10 <takuan> LatticeRules.hs:135:25: parse error on input `<-'
05:28:16 <takuan> when I enable glasgow extensions
05:28:16 <takuan> ?
05:28:19 <jlouis> takuan: indentation?
05:28:33 <takuan> the offending line is 
05:28:34 <takuan>   cum = accum [p|(p,_) <- x]
05:28:43 <takuan> jlouis: why's that?
05:28:55 <takuan> do the glasgow extensions change the identation style?
05:29:03 <jlouis> takuan: just a bet, doesn't seem so with what you have there
05:29:16 <ricebowl> isn't that the same as map fst x?
05:29:28 <ricebowl> @pl f xs = [p | (p,_) <- xs]
05:29:28 <lambdabot> (line 1, column 6):
05:29:28 <lambdabot> unexpected "="
05:29:28 <lambdabot> expecting variable, "(", operator or end of input
05:29:44 <ski> doesn't understand list compr.
05:29:55 <ricebowl> ah
05:30:08 <ski> @pl f xs = xs >>= \(p,_) -> return p
05:30:08 <lambdabot> f = (fst `fmap`)
05:30:31 <takuan> x in this case is a list full of pairs (p,q) of which we only need to have the p
05:30:40 <takuan> without glasgow extensions there's no problem there
05:30:57 <takuan> and I wonder why there's suddenly a problem using the extensions
05:31:54 <ski> hm
05:32:07 <xerox> Oi!
05:32:17 <ricebowl> yo
05:32:23 <ski> hiya xerox
05:32:35 <ski> takuan : what is context to this line ?
05:33:15 <takuan> not much
05:33:29 <takuan> all the other list comprehensions compile without a problem
05:33:44 <ski> seems odd
05:34:00 <takuan> very odd
05:35:11 <ProfTeggy> takuan, what is x in that definition? It's a free variable in your examples...
05:35:28 <ProfTeggy> I assume it's bound in that scope
05:35:30 <takuan> welp
05:35:40 <takuan> adding a space in front of | makes it compile
05:35:54 <ProfTeggy> takuan, may be realted to parallel list comprehension syntax
05:35:59 <ProfTeggy> related, even
05:36:22 <takuan> :D
05:36:24 <takuan> probably
05:37:52 <kosmikus> no, it's a Template Haskell syntax conflict
05:39:21 <ProfTeggy> Aha!
05:41:15 <gour> dcoutts: ok, i manually removed all the entries, but automatic purging does not work due to old mysql. it would be handy if you can impress someone on haskell.org to update mysql a bit (on gentoo 5.0.16 is the latest)
05:41:46 <dcoutts> gour, I think that'll be difficult.
05:42:19 <gour> dcoutts: btw, i hope to be able to finish this week one of my books, so i can resume my haskell study on a regular basis
05:42:36 <dcoutts> great
05:42:36 <gour> dcoutts: why, some compatibility reasons?
05:43:10 <dcoutts> well that's the version that comes with RHAS
05:43:26 <dcoutts> there are not updated official rpms
05:43:33 <gour> huh, so old...
05:43:34 <dcoutts> we'd need to build it specially
05:43:36 <dcoutts> yeah
05:44:13 * gour forgot everything about rpms after switching to gentoo :-)
05:49:20 <xinming> ski: ping
05:49:48 * xinming forgot everything about rpms afer switching to debian :-P
05:50:19 * ricebowl forgot everything about rpms after switching to Windows
05:50:58 <ricebowl> @hoogle (a -> b -> (a,c)) -> a -> [b] -> a
05:50:59 <lambdabot> No matches, try a more general search
05:51:18 <xinming> well, you might even lost the convience of typing in ghci
05:51:29 <xinming> if you are in windows
05:51:30 <ndm> that hoogle should give some results!
05:51:40 <ricebowl> xinming - huh?
05:51:54 <ndm> the web one gives foldl and mapAccumL
05:52:15 <ricebowl> foldl is definitely not what I'm looking for...but very close
05:52:20 <ricebowl> I think I'll just write this one m'self
05:52:37 <xinming> I tried ghc on windows today, it seems that, you can use C-p C-n C-b C-f
05:52:50 <xinming> s/can/can't/
05:52:58 <ricebowl> xinming - what do those do?
05:53:16 <ricebowl> I never knew about them
05:53:31 <xinming> ricebowl: up down back-char forward-char
05:53:49 <ricebowl> er? Why wouldn't you use the arrow keys for that?
05:53:51 <xinming> it's a pain to use ghci in windows.
05:54:06 <xinming> ricebowl: It's faster while you editing the one-liner
05:54:37 <xinming> certainly, you must be confortable with it
05:55:26 <ricebowl> doesn't seem any different to me, just different keys for scrolling
05:55:40 <shapr> I really enjoy reading "Types and Programming Languages"
05:55:50 <ski> xinming : pang
05:55:53 <ricebowl> I think Ctrl+arrow is far more useful
05:55:58 <araujo> shapr, link
05:56:02 * shapr prefers Control.Arrow
05:56:06 <ricebowl> hah!
05:56:09 * araujo throws lambdas at everywhere
05:56:10 * shapr snickers
05:56:24 <ricebowl> hola araujo
05:56:49 <shapr> araujo: http://www.cis.upenn.edu/~bcpierce/tapl/
05:56:50 <araujo> hi ricebowl !
05:56:54 <araujo> Thanks shapr 
05:57:25 <xinming> ski: for the last Monad in tutorial please... :-P
05:57:26 <shapr> That's a great book, I like it. It references lots of work that I wish I could read.
05:57:33 <ski> xinming : which is ?
05:57:33 <ricebowl> yeah, that looks very, very interesting
05:57:34 <shapr> hej MrBraker, lär du dig Haskell?
05:58:02 <xinming> ski: Cont
05:58:08 * ski admits to not having read that tutorial fully ..
05:58:12 * shapr orders more unicycle bits and pieces from Karlstad.
05:58:20 <xinming> ski: by the way, which is the hardest Monad to learn?
05:58:25 <ricebowl> oh, come to think of it
05:58:28 <shapr> xinming: The ones you make yourself :-)
05:58:33 <ricebowl> shapr - how is it buying hardware over there?
05:58:35 <ski> xinming : er, a bit hard to say
05:58:54 <ricebowl> it tends to be substantially more expensive, no?
06:00:10 <ski> newtype Cont o a = Cont {runCont :: (a -> o) -> o}  -- ski assumes this is in Control.Monad.Cont
06:02:31 <xinming> newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }
06:02:34 <xinming> right
06:02:39 <xinming> It's correct
06:03:48 <ski> so, you wanted to ask what about this ?
06:05:44 <xinming> return a       = Cont $ \k -> k a
06:06:07 <ski> indeed
06:06:21 <ski> runCont (return a) k = k a
06:07:30 <ricebowl> @hoogle IArray a e => (i -> e -> e) -> a i e -> a i e
06:07:31 <lambdabot> No matches, try a more general search
06:08:52 <eNTi> hi. could someone probably exlpain the \x -> exp in easy terms. somehow this principle won't fit into my brain.
06:09:02 <ski> f x = ..exp..
06:09:05 <ski> means same as
06:09:11 <ski> f = \x -> ..exp..
06:09:41 <ski> '\x -> ..exp..' is the function, that when given an argument, which we internally call 'x', returns the value of '..exp..'
06:09:44 <jlouis> eNTi: think ``anonymous function''
06:09:54 <jlouis> or unnamed function
06:09:59 <eNTi> ,hm
06:10:06 <ski> > let  square x = x * x  in  map square [0..9]
06:10:07 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
06:10:13 <ski> > let  square = \x -> x * x  in  map square [0..9]
06:10:14 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
06:10:25 <ski> > map (\x -> x * x) [0..9]
06:10:26 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
06:10:38 <eNTi> k. thx.
06:10:41 <jlouis> > (\x -> x + 5) 9
06:10:42 <lambdabot> 14
06:10:49 <xerox> > map (join (*)) [0..9]
06:10:50 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
06:10:53 <xerox> :-)
06:11:08 <jlouis> xerox: >:->
06:11:13 <xerox> ^_^
06:11:44 <xinming> ski: callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
06:13:01 <ski> runCont (callCC f) k = runCont (f jump) k
06:13:02 <xinming> the Cont Monad is a bit like Reader, But which value in the Monadic action is a function, right?
06:13:05 <ski>   where
06:13:06 <ski>   runCont (jump a) _ = k a
06:13:24 <ski> hm
06:13:59 <ski> i'm not sure i see the Reader connection
06:17:54 <xinming> what does jump do in above example
06:18:18 <ski> it's just the function passed to f, but named
06:19:03 <ski> when passed a value 'a' it will ignore it's current continuation '_', and instead pass 'a' on to 'k', which was the current continuation of the 'callCC' call
06:21:46 <ricebowl> @type Data.Array.IArray.newArray
06:21:47 <lambdabot> Not in scope: `Data.Array.IArray.newArray'
06:22:37 <ricebowl> weird
06:22:51 <rgrig> ?
06:23:00 <ricebowl> nothing
06:23:33 * shapr grumbles
06:23:55 <shapr> ricebowl: As I was saying, buying hardware is easy, paying taxes is hard.
06:24:43 * shapr wurbles quietly
06:25:46 <ricebowl> ah
06:25:54 <ricebowl> yes, but it's expensive, isn't it?
06:26:08 <ricebowl> relatively speaking...
06:26:25 <ricebowl> and launch dates aren't as rigorous
06:26:25 <shapr> Swedish taxes are expensive. Hardware prices aren't different.
06:26:29 <shapr> huh?
06:26:31 <ricebowl> *nods*
06:26:44 <shapr> Launch dates?
06:27:01 <ricebowl> well, you can only buy what they will sell you is what I meant
06:27:10 <ricebowl> so if something new is out, it might not be in the store for a while
06:28:04 <shapr> The nearest 'big' city is half an hour's bus ride away, so I don't shop in physical stores.
06:28:35 <ricebowl> well, I wasn't even thinking of physical stores, though they tend to be worse...
06:29:58 <shapr> If you shop on the web, you can get anything. You may have to buy from the US for specialty items (aerospace quality unicycle hubs :-) but the only real difference is shipping, both time & cost.
06:30:20 <ricebowl> *nods*
06:30:32 <ricebowl> but generally US shops don't ship internationally, no?
06:30:55 <ricebowl> I suppose it's good to know that you can still obtain things and for roughly the same price, taxes aside
06:31:32 <shapr> Probably 80% of the online shops I've seen ship internationally. Some charge too much for int'l shipping, but you can nearly always get it.
06:32:02 <ricebowl> ah, curious
06:32:24 <shapr> Even so, lots of UK shops specialize in cheap shipping to anywhere in the EU and markup items from the US to twice the price.
06:32:31 <ricebowl> nice
06:32:43 <shapr> For example, I've been trying to find tireflys for a sane price with no success.
06:33:22 * shapr wants a tirefly or three for his unicycles.
06:36:31 <shapr> I wanted to ask a question here about type theory, too bad I've forgotten it.
06:37:05 <ricebowl> @eval map (4,) [0,1,2,3]
06:37:06 <lambdabot>  parse error on input `)'
06:37:14 <ricebowl> @eval map ((,) 4) [0,1,2,3]
06:37:15 <lambdabot> [(4,0),(4,1),(4,2),(4,3)]
06:37:19 <shapr> I do have a more general question, how do I approach the field of proof programming? I want to go from proof assistant to generated program. I've found NuPRL, but else is there?
06:38:27 <shapr> Is there a TaPL mailing list, wiki, etc?
06:38:43 <shapr> I'd like to find implementations of the calculi in Haskell.
06:40:17 <xinming> ski: do you mean that `callCC f` will use f instead of the global function k?
06:40:19 <shapr> Oh, I remember my question... is it possible to float the strong normalization property either in or out past a fixpoint?
06:41:36 <Heffalump> are you asking if the addition of fix to a language preserves strong normalization?
06:43:16 <shapr> Heffalump: No, I know that fix kills termination ... but Barry Jay (?) mentioned that a good way to design languages was to make them terminating / strongly normalizing and then to add fix to get a turing complete language.
06:43:54 <shapr> So I was wondering if there's some way to keep a single 'fix' at the top level, compose programs by putting them inside that fix call.
06:44:05 <shapr> I don't think I'm explaining this well...
06:44:38 <Heffalump> yes, you could
06:44:43 <Heffalump> not sure what it'd gain you
06:45:49 <shapr> I have a good idea of the gains, but am currently unable to explain them in English...
06:46:23 <shapr> Sort of like 'mostly normalizing' or 'mostly terminating'
06:47:11 <shapr> If you know that each step inside the fix call is normalizing/terminating, you get some extra benefits.
06:47:27 <Heffalump> I don't think you do.
06:47:34 <Heffalump> cos you have no idea if the fix will terminate
06:49:31 <shapr> I think it would be easier to see why something doesn't terminate, if it doesn't.
06:49:39 <Heffalump> I don't.
06:49:59 <Heffalump> the fix operation will be passing a huge amount of data (potentially) back into the program
06:50:13 <ski> xinming : huh ?
06:51:00 <xinming> still don't understand the callCC :-/
06:51:37 <ski> xinming : have you programmed some in CPS ?
06:51:44 <ski> (or do you understand it ?)
06:52:02 <shapr> Let's say you built this on top of JHC, which strips unused code nicely. A stripped version of several steps that do not terminate, would give a much better understanding of what's goin gon.
06:52:49 <shapr> Heffalump: Anyway, do you know of any papers that discuss floating past fixpoints like thta?
06:53:19 <xinming> ski: I think I understand what CPS does, It's a bit like, fun( v, f) = { bla,ble.blo... -> v', f v'}
06:53:24 <xinming> ski: am I right?
06:53:25 <Heffalump> not OTTOMH
06:53:36 <ski> xinming : yes
06:53:42 <Heffalump> and I think you'll find that doing that floating will inhibit the removal of dead code
06:53:44 <shapr> I'm looking for something like let floating for fix.
06:54:03 <shapr> I don't think so.
06:54:57 <ski> xinming : do you  understand, conceptually, what 'callCC' is supposed to do ?
06:55:57 <shapr> Also, I'm looking for information on the opposite of pointless. What's it called? Is there literature on both the @pl transformation and its opposite number?
06:56:15 <shapr> I think both @pl and its opposite number fit nicely into spoken programming.
06:56:29 <xinming> (Cont c) >>= f = Cont $ \k -> c (\a -> runCont (f a) k), for this example, the final result will be...
06:57:18 <xinming> Cont \k -> c (\a -> k (f a)
06:57:58 <xinming> ski: don't understand. :-/
06:58:02 <ski> err
06:58:13 <ski> what example ?
06:58:31 <xinming> (Cont c) >>= f = Cont $ \k -> c (\a -> runCont (f a) k)
06:58:46 <ski> that is the definition of (>>=)
06:59:20 <xinming> yea, I know,
07:00:39 <ski> runCont (ma >>= f) k = runCont ma andThen
07:00:43 <ski>   where
07:00:44 <ski>   andThen a = runCont (f a) k
07:01:01 <ski> do you understand the definition of (>>=) ?
07:01:45 <xinming> No. :-/
07:02:02 <ski> do you understand the definition of 'return' ?
07:02:27 <xinming> It seems, that there will be 2 function,
07:02:35 <xinming> ski: I know it, It's easy.
07:02:41 <ski> ok
07:03:03 <ski> in '(>>=)' .. we have
07:03:09 <ski> c :: (a -> o) -> o
07:03:22 <ski> f :: a -> Cont o b
07:03:36 <ski> k :: b -> o
07:03:37 <xinming> yes
07:03:40 <ski> agree ?
07:03:59 <ski> (Cont c) >>= f = Cont $ \k -> ...
07:04:05 <ski> ... :: o
07:04:35 <xinming> why is the type of k (b -> 0)
07:04:38 <xinming> :-/
07:04:41 <xinming> hold on plz
07:05:27 <shapr> Heffalump: What do you think about spoken programming?
07:07:58 <shapr> heya poetix!
07:07:59 <shapr> Wassup?
07:08:19 <poetix> Christmas is coming, the goose ain't getting thinner
07:08:35 <shapr> That's good. Paint thinner is not good for geese.
07:08:45 <poetix> I heard they made a special kind of pate that way
07:09:06 <poetix> You don't eat it - just sniff it until you pass out
07:09:07 <shapr> Mental dissonance paté?
07:09:29 <xinming> since the Cont need 2 types to get the result type,
07:10:07 <Heffalump> shapr: in what sense
07:10:07 <Heffalump> ?
07:10:24 <shapr> Heffalump: Anything that comes to mind.
07:10:34 <ski> (Cont c) >>= f :: Cont o b
07:10:45 <Heffalump> I have no idea what it is.
07:10:51 <ski> so
07:10:51 <poetix> I had an idea for a Haskell project...
07:10:51 <ski> (Cont $ \k -> ...) >>= f :: Cont o b
07:11:03 <ski> so
07:11:13 <ski> (\k -> ...) >>= f :: (b -> o) -> o
07:11:19 <shapr> poetix: Oh tell me more.
07:11:20 <ski> k :: b -> o
07:11:25 <ski> ... :: o
07:11:29 <ski> xinming : clear ?
07:11:39 <poetix> shapr: A very high-level macro assembler targetting the JVM
07:11:59 <shapr> Oh, sounds neat.
07:12:07 <ski> xinming : err .. s/(Cont $ \k -> ...) >>= f :: Cont o b/(Cont $ \k -> ...) :: Cont o b/
07:12:10 <poetix> I was playing with Reflection.Emit in C# the other day, writing CLR bytecode to build classes on the fly
07:12:22 <Heffalump> pseudonym was talking about making an assembler in Haskell
07:12:26 <poetix> I thought "this would be more fun in Haskell"
07:12:55 <poetix> and also "I need - for boring professional reasons - to know more about Java - why not start with the internals?"
07:13:09 <xinming> so, k should be o, not o -> b :-/
07:13:17 <xerox> Brrr, poetix, wash your hands please
07:13:25 <shapr> poetix: Oh hey, did you see my blog entry about asufficiently anonymous distributed VM beating the cheating client problem?
07:13:40 <poetix> Yes...
07:13:40 <ski> xinming : nope
07:13:47 <shapr> poetix: Any thoughts on the matter?
07:13:51 <ski> xinming : k :: b -> o
07:14:06 <xinming> (Cont $ \k -> ...) :: Cont o b
07:14:10 <ski> xinming : #haskell-overflow ?
07:14:21 <poetix> Almost none. Actually, I'm deeply confused by the relationship between URLs and your blog posts
07:14:28 <shapr> poetix: There was some code to generate JVM bytecodes from GHC ... I don't know if it's there still.
07:14:32 <poetix> http://www.scannedinavian.com/ is not the same as http://www.scannedinavian.com/blog
07:14:38 <shapr> er
07:14:40 <shapr> huh?
07:14:48 <xinming> ski: may I has a private chat with you please?
07:14:58 <ski> xinming : #haskell-overflow ?
07:14:59 <shapr> I didn't even know that second url was used at all.
07:15:16 <poetix> There is a "Jaskell", which is meant to provide a JVM back-end for GHC
07:15:21 <xinming> ok, get here. :-)
07:15:28 <shapr> Oh, that must be a bad rsync call.
07:15:47 <shapr> I'll write a shell script to fix my rsync problems...
07:16:16 <shapr> poetix: Ok, /blog is gone.
07:16:27 <poetix> I don't especially want to compile Haskell to run on the JVM. What I would like is some tools for playing around with little languages
07:16:43 <shapr> Right, so something that generates JVM bytecodes?
07:16:45 <poetix> And maybe for doing exceedingly hackish things to Java class files
07:16:55 <poetix> Yep. I'm thinking like a Writer monad
07:17:07 <poetix> But then you build combinators and stuff on top of that
07:17:57 <poetix> So it's an assembler as a DSL
07:18:12 <poetix> An EDSL, more to the point
07:18:16 <poetix> Sorry, DSEL
07:18:25 <shapr> For more fun, you could parse and emit bytecodes.
07:18:43 <poetix> Yes, I think it would be cool to be able to transform existing code
07:18:45 <shapr> Then you could optimize and clean up existing class files.
07:18:56 <shapr> And obfuscate, and ...
07:19:17 <poetix> For optimisation, I doubt there's much I could do that would beat what Sun's engineers already do in the JITter
07:20:45 <poetix> But obfuscation, yes, and "aspect"-oriented stuff...
07:20:55 <poetix> And maybe some really freaky control-flow manipulation
07:20:55 <shapr> Last I checked, obfuscators could optimize by doing de bruijn indexing.
07:21:32 * poetix wikipedes
07:21:34 <shapr> That is, class files include big long names directly, renaming them to single letters can be faster.
07:22:43 <poetix> Some reverse engineering tools could be nice, too.
07:22:48 <poetix> i18n after the fact, for instance
07:23:03 <shapr> yup
07:23:36 <poetix> Company X doesn't produce a Portuguese-language version of their software, and won't give you the source - no problem, we'll generate string tables and rewire everything to use them...
07:25:02 <poetix> Anyway, in the first instance what I need is to be able to pass the class file format - which is not too hard
07:25:56 <poetix> But I also need to be able to look inside jar files to get the definitions of classes in other libraries, especially the standard libraries
07:26:12 <shapr> Jars are just zip, right?
07:26:33 <poetix> Zip plus a "META-INF" file, yes
07:27:01 <shapr> You could call an external unzipper to start with, I don't remember if Inflate is the same as zip.
07:27:10 <poetix> I think if you want to create an object of some class, you need to read the class file in which it's defined in order to be able to produce the correct byte code for instantiating that object and calling methods on it
07:28:23 <shapr> I think someone posted a way to parse binary files with Parsec in the last few months.
07:28:58 <poetix> In the case of C#, you get the class constructor and other method info by reflecting over assemblies, which obviously the runtime already has mechanisms for loading and introspecting. That's a major bit of machinery that a non-Java program won't have access to, and will have to duplicate to some degree
07:29:31 <poetix> Basically it's a question of locating the right class file, and being able to read the headers that describe the class and its methods
07:29:45 <shapr> Doesn't the JVM bootstrap itself by reflection?
07:29:53 * shapr tries to remember...
07:30:43 <poetix> Reflection is essential to things like dynamic class loading
07:32:18 <poetix> I can imagine a Java program sending a request for some custom class out to a Haskell class builder, and being given the custom class in binary form - that would be an interesting form of cross-environment exchange
07:32:39 <poetix> Or it could ask some Haskell tool to security check a class it was being asked to load...
07:32:52 <eNTi> can someone please give me an easy example for "number of first occurance of a in [a]" where Eq a => a->[a]->Int?
07:32:54 <xerox> class class class..  I'm lost.
07:32:54 <shapr> Have you looked at the Haskell to JVM bridge?
07:33:19 <poetix> No, that might actually make life a lot easier - I could ride on the back of the existing reflection libraries
07:35:13 <shapr> It has ClassFormat.hs, cool.
07:35:14 <lispy> eNTi: perhaps index of first occurance
07:35:49 <shapr> hiya lispy, how's code?
07:36:06 <lispy> eNTi: i'd start with index a xs = indexHelper a xs 0 where indexHelper = ...
07:36:12 * shapr sighs
07:36:16 <poetix> indexOfFirst p = length . takeWhile (\x -> x /= p)
07:36:17 <shapr> CVS is so much trouble.
07:36:18 <lispy> shapr: hmm...not that good, i want to do more of it :)
07:36:30 <shapr> I know that feeling.
07:36:45 <lispy> poetix: that would be the easy way,yes :)
07:37:13 <eNTi> thx
07:37:27 <poetix> @eval length . takeWhile (5 \=) $ [1,2,3,4,5,6,7]
07:37:28 <lambdabot>  Not in scope: `\='
07:37:33 <poetix> @eval length . takeWhile (5 /=) $ [1,2,3,4,5,6,7]
07:37:34 <lambdabot> 4
07:38:04 <lispy> the question is what should it return if a is not founD?
07:38:16 <lispy> and should it be zero based to work with (!!)
07:39:03 <lispy> well off to work for me
07:40:11 <eNTi> poetix> could you maybe elaborate what you are doing there a little. i know takeWhile and \x-> but what is actually giving back the index?
07:40:33 <poetix> The (.) is probably the important part there
07:40:42 <eNTi> function concatenation.
07:40:47 <eNTi> er...
07:40:51 <poetix> It's composing length and takeWhile
07:40:55 <eNTi> composition :)
07:41:11 <poetix> Here it is again in longhand:
07:41:40 <poetix> indexOfFirst p xs = length (takeWhile (\x -> p/= x)) xs
07:42:04 <eNTi> what does p/=x do?
07:42:18 <poetix> It's how Haskell says p != x
07:42:24 <eNTi> ah
07:42:25 <shapr> poetix: It looks like the haskell java bridge has code for most of what you want to do.
07:42:45 <poetix> shapr: Is that the one on sourceforge?
07:43:09 <poetix> eNTi: We can drop the xs:
07:43:24 <poetix> indexOfFirst p = length (takeWhile (\x -> p/=x))
07:43:41 <eNTi> alright.
07:43:48 <poetix> And, for the same reason, we can shorten the \x -> p/=x to p/= :
07:43:56 <poetix> indexOfFirst p = length (takeWhile (p/=))
07:44:08 <eNTi> so it's taking the length of the list, takeWhile builds up, while it takes out elements that are not the one i'm looking for.
07:44:33 <ProfTeggy> poetix, that's not "the same reason"
07:45:15 <poetix> OK, a similar reason
07:45:42 <poetix> @t 5/=
07:45:42 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
07:45:42 <lambdabot> null topic-snoc topic-tail topic-tell type .
07:45:46 <poetix> @type 5/=
07:45:46 <lambdabot> parse error (possibly incorrect indentation)
07:45:51 <poetix> @type (5/=)
07:45:51 <shapr> poetix: yup
07:45:52 <lambdabot> forall a. (Num a) => a -> Bool
07:46:09 <poetix> @type (/=)
07:46:10 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:46:43 <poetix> By supplying one of the arguments of (/=), we get a partial application of the function that returns a new function requiring only the other argument
07:46:50 <ricebowl> > let sortnub xs = foldl (\ys x -> if x /= (head ys) then x:ys else ys) (head (sort xs):[]) (tail (sort xs)) in sortnub [0,1,5,3,1,2,0,3,4]
07:46:50 <cmunier> I'm to design a list datatype which allows both insertion of elements at the end and the beginning of a list without recursion, i.e. so that you don't have to use (++), for insertion at the end of a list - which is slow due to recursion. Currently, I have an abstract datatype which has constructors for an empty list, for list elements and for concatenation of two lists. But as I'm building my list from a native haskell list, I get parent
07:46:50 <cmunier> hesis detaining me from working with the list as I'd like. Any ideas?
07:46:51 <lambdabot> [5,4,3,2,1,0]
07:47:28 <ricebowl> @hoogle (a -> a -> Ordering) -> [a] -> [a]
07:47:29 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:47:29 <lambdabot> Data.List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:47:29 <lambdabot> Data.List.scanl1 :: (a -> a -> a) -> [a] -> [a]
07:47:55 <xerox> > let sortnub = sort . nub in sortnub [0,1,5,3,1,2,0,3,4]
07:47:56 <lambdabot> [0,1,2,3,4,5]
07:48:13 <poetix> @type nub
07:48:14 <lambdabot> Not in scope: `nub'
07:48:15 <ski> cmunier : what's the parenthesis problem you have ?
07:48:19 <ricebowl> @type List.nub
07:48:20 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:48:20 <xerox> @type List.nub
07:48:21 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:48:42 <poetix>  nub [1,2,3]
07:48:48 <poetix> > nub [1,2,3]
07:48:49 <lambdabot> [1,2,3]
07:48:52 <poetix> ???
07:48:59 <ricebowl> > let sortnub xs = let xs' = sort xs in foldl (\ys x -> if x /= (head ys) then x:ys else ys) (head xs':[]) (tail xs') in sortnub [0,1,5,3,1,2,0,3,4]
07:49:00 <lambdabot> [5,4,3,2,1,0]
07:49:12 <ProfTeggy> poetix, nub removes duplicate list elements
07:49:15 <ricebowl> > let sortnub xs = let xs' = List.sortBy (flip . compare) xs in foldl (\ys x -> if x /= (head ys) then x:ys else ys) (head xs':[]) (tail xs') in sortnub [0,1,5,3,1,2,0,3,4]
07:49:15 <lambdabot> Couldn't match `b -> c' against `Ordering'
07:49:17 <Cale> > nub [1,1,1,2,2,1,3,3,3]
07:49:18 <lambdabot> [1,2,3]
07:49:22 <ricebowl> er
07:49:26 <ricebowl> > let sortnub xs = let xs' = List.sortBy (flip compare) xs in foldl (\ys x -> if x /= (head ys) then x:ys else ys) (head xs':[]) (tail xs') in sortnub [0,1,5,3,1,2,0,3,4]
07:49:27 <lambdabot> [0,1,2,3,4,5]
07:49:37 <ricebowl> supar
07:49:52 <ricebowl> xerox - I don't think nub is O(n)
07:49:53 <Cale> > let sortnub = (map head . group . sort) in sortnub [0,1,5,3,1,2,0,3,4]
07:49:54 <lambdabot> [0,1,2,3,4,5]
07:50:02 <ricebowl> after the list is sorted, nub is *extremely* cheap
07:50:13 <Cale> nub is O(n^2)
07:50:14 <eNTi> 2qSort (x:xs) = qSort [u|u<-xs,u<x] ++ [x] ++ qSort [u|u<-xs,u>=x]" this a code for quicksort. can somone explain me, what [u|u<-xs, u>=x] is doing and how it's achieving it? i mean it's pretty damn slick, but i just don't get it (again) :D. btw, thx for all your help, you're great guys :).
07:50:21 <Cale> sortnub is O(n log n)
07:50:31 <ricebowl> heh ;)
07:50:33 <poetix> eNTi: you need the Tour
07:50:38 <eNTi> Tour?
07:50:42 <ricebowl> > nub [0,1,4,3,2,0,0,4]
07:50:43 <lambdabot> [0,1,4,3,2]
07:50:53 <poetix> Who's tourguide at the moment?
07:50:57 <Cale> eNTi: [u | u <- xs, u < x] is the list of u in xs such that u < x
07:51:02 <ricebowl> is the order of nub's output defined?
07:51:03 <Cale> where xs is a list
07:51:12 <cmunier> ski, e.g. a list in my type would be (El 1) :*: ((El 2) :*: ((El 3) :*: ((El 4) :*: ((El 5) :*: Nil))))), corresponding to [1,2,3,4,5] as a native haskell list. The problem is adding an element add the end of this structure without cycling recursively through my list.
07:51:14 <flux__> ricebowl, I think it's the same as the input's
07:51:22 <ricebowl> yes, but is it *defined* to be that?
07:51:31 <ricebowl> or just a side-effect of the implementation?
07:51:37 <ProfTeggy> it would be stablenub then ;-)
07:51:42 <flux__> I can't imagine an implementation which had that side-effect :-o
07:51:59 <cmunier> Or is this approach to the problem unfavorable? ;-)
07:52:07 <ProfTeggy> flux, this might be due to your lack of imagination, though
07:52:11 <eNTi> Cale> thx. but how do i "read" it? what does u|u state?
07:52:11 <flux__> yes :)
07:52:15 <ProfTeggy> hehe:)
07:52:22 <flux__> but the obvious implementation would be sorting and removing adjacent duplicates
07:52:24 <Cale> eNTi: read | as "such that"
07:52:29 <ski> cmunier : 'data List a = Nil | El a | List a :*: List a' ?
07:52:29 <ProfTeggy> *nod*
07:52:40 <poetix> eNTo: it's a variant of set theory notation
07:52:42 <ricebowl> flux__ - essentially the question is whether sortnub would be a valid general replacement
07:52:54 <ProfTeggy> flux, but what about hashing and throwing colliding elements away?
07:53:03 <cmunier> ski, indeed
07:53:05 <Cale> > [x | x <- [1,2,3,4,5,6,7,8], x < 4]
07:53:06 <lambdabot> [1,2,3]
07:53:11 <Cale> > [x | x <- [1,2,3,4,5,6,7,8], even x]
07:53:12 <lambdabot> [2,4,6,8]
07:53:24 <Cale> > [x | x <- [1,2,3,4,5,6,7,8], x `mod` 3 == 0]
07:53:25 <lambdabot> [3,6]
07:53:38 <poetix> > [(x, y) | x <- [1,2,3], y <- [1,2,3]]
07:53:39 <lambdabot> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:53:57 <Cale> > [x^2 | x <- [1..10]]
07:53:58 <lambdabot> [1,4,9,16,25,36,49,64,81,100]
07:54:02 <ski> cmunier : then why not just '((El 1) :*: ((El 2) :*: ((El 3) :*: ((El 4) :*: ((El 5) :*: Nil))))) :*: El 42' ?
07:54:03 <poetix> > [(x, y) | x <- [1,2,3], y <- [1,2,3], x < y]
07:54:04 <lambdabot> [(1,2),(1,3),(2,3)]
07:54:26 <cmunier> ski, okay - but how to convert this back to a haskell list? This is where I'm stuck.
07:54:37 <flux__> profteggy, you would still need to worry about valid collisions
07:54:51 <flux__> profteggy, well, I suppose that would not be a problem
07:54:52 <eNTi> wow.
07:54:56 <eNTi> that's pretty powerful
07:54:57 <poetix> :)
07:54:59 <flux__> and you could use a binary tree for the hash values
07:55:02 <ProfTeggy> flux, of course.  Nobody saves you from (some) comparisons here.
07:55:04 <flux__> I do wonder why, though :)
07:55:35 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
07:55:36 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
07:55:38 <ProfTeggy> eNTi, you have just entered a larger world.  Welcome. :-)
07:55:40 <flux__> I suppose it could use actual hash tables in some ST monad
07:56:10 <flux__> profteggy, I think the biggest problem is that the values are of class Eq, not Hashable (if that exists)
07:56:14 <ski> cmunier : using '(++)' ?
07:56:26 <eNTi> w00t.. my brain melts.
07:56:36 <poetix> > take 5 [(x, y, z) | x <- [1..], y <- [1..], z <= [1..], x^2 + y^2 = z^2]
07:56:36 <lambdabot>  parse error on input `='
07:56:43 <poetix> > take 5 [(x, y, z) | x <- [1..], y <- [1..], z <= [1..], x^2 + y^2 == z^2]
07:56:44 <lambdabot>  Not in scope: `z'
07:56:51 <poetix> > take 5 [(x, y, z) | x <- [1..], y <- [1..], z <- [1..], x^2 + y^2 == z^2]
07:56:54 <Cale> <= ?
07:56:54 <lispy> i think the last time i asked about hashtables in haskell i was told that finite maps were usually better
07:56:56 <lambdabot> Terminated
07:57:00 <flux__> profteggy, the implementation provided by haskell prelude seems to be O(n^2)..
07:57:00 <Cale> poetix: won't work :)
07:57:07 <flux__> (and preserves the order)
07:57:10 <poetix> Why not...?
07:57:11 <Cale> poetix: you need to diagonalise for that :)
07:57:11 <ProfTeggy> flux, yes,
07:57:20 <poetix> Oh, of course...
07:57:21 <Cale> because x = 1 forever
07:57:31 <flux__> but it does not say anything about it, though, unless the act of removing duplicates is interpreted as that it does nothing else
07:57:49 <flux__> I would imagine that any replacement would need to give the same result as the prelude's, though
07:58:01 <poetix> OK, here's one...
07:58:21 <Cale> I wish there was a proper integer square root function in the prelude :)
07:58:35 <flux__> of course you could encode the sortedness-status of a list into its type, and then optimize the sorting stages away ;)
07:58:47 <lispy> Cale: yeah, i've bumped into that as well
07:58:59 <Cale> there's a nice one on the wiki
07:59:15 <poetix> [(x, y, z) | x <- [1..], y <- [1..], z <- [1..], n <- [3..], x^n + y^n = z^n]
07:59:21 <Cale> on the LambdaLifting page of all places
07:59:33 <Cale> poetix: hehe
07:59:35 <lispy> i think i borrowed (cut and paste) some code from the Prelude which did it, but was not exposed by the module system
08:00:07 <lispy> > take 10 [1..]
08:00:09 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
08:00:25 <lispy> oh, i expected that to be == ones
08:00:29 <lispy> > take 10 ones
08:00:30 <lambdabot>  Not in scope: `ones'
08:00:34 <Cale> > take 10 [1,1..]
08:00:35 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
08:00:45 <Cale> > take 10 [1,5..]
08:00:46 <lambdabot> [1,5,9,13,17,21,25,29,33,37]
08:00:51 <lispy> let ones = 1:ones
08:01:05 <Cale> > let ones = 1 : ones in take 10 ones
08:01:06 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
08:01:33 <cmunier> ski, thank you. I guess I was blind.. :-)
08:01:47 <Cale> > let y f = f (y f); ones = y (1 :) in take 10 ones
08:01:48 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
08:01:50 <eNTi> why does length.take ... not work?
08:02:03 <lispy> @type take
08:02:04 <lambdabot> forall a. Int -> [a] -> [a]
08:02:07 <lispy> @type length
08:02:08 <lambdabot> forall a. [a] -> Int
08:02:08 <Cale> > let y f = f (y f); ones = y (1 :) in length . take 10 $ ones
08:02:10 <lambdabot> 10
08:02:23 <Cale> > length . take 10 $ [1,5..]
08:02:24 <lambdabot> 10
08:02:35 <eNTi> what's that $
08:02:37 <Cale> > (length . take 10) [1,5..]
08:02:38 <lambdabot> 10
08:02:46 <Cale> f $ x = f x
08:02:46 <lispy> eNTi: it's like parens, but you only need one :)
08:02:55 <poetix> length . take == id
08:02:59 <poetix> @Type length . take
08:03:00 <lambdabot>   Expecting a function type, but found `b'
08:03:00 <lambdabot>   Expected type: Int -> [a]
08:03:01 <Cale> $ has really low precedence
08:03:19 <poetix> @Type (length . take)
08:03:20 <lambdabot>   Expecting a function type, but found `b'
08:03:20 <lambdabot>   Expected type: Int -> [a]
08:03:31 <Cale> that composition doesn't make sense
08:03:50 * poetix slaps forehead
08:03:56 <eNTi> ok thank you guys. i hope all this info is any help in my following exam :)
08:03:57 <Cale> you have to apply take first
08:03:58 <poetix> length . take /= id
08:04:07 <lispy> @pl \x -> length . (take x)
08:04:08 <lambdabot> (length .) . take
08:04:14 <Cale> take 20 [1..5]
08:04:14 <Cale> > take 20 [1..5]
08:04:15 <lambdabot> [1,2,3,4,5]
08:04:43 <Cale> > length . take 20 $ [1..5]
08:04:44 <lambdabot> 5
08:04:49 * poetix lowers his newly-bruised forehead into a bowl of trifle
08:05:19 <lispy> ((length .) . take) 5 [1..]
08:05:23 <lispy> > ((length .) . take) 5 [1..]
08:05:24 <poetix> mmm...trifle...[drooling noises]
08:05:25 <lambdabot> 5
08:05:42 <Cale> @pl \n -> ((length .) . take) n [1..]
08:05:42 <lambdabot> flip (length .) [1..] . take
08:05:52 <lispy> oh flip
08:06:08 <poetix> @type flip (length .) [1..] . take
08:06:09 <lambdabot> Int -> Int
08:06:10 <jethr0_> *yuch*
08:06:10 <lispy> but i would expect take to be flipped
08:06:23 <lispy> @type flip take
08:06:24 <lambdabot> forall a. [a] -> Int -> [a]
08:06:32 <Cale> I wouldn't, for some reason
08:06:39 <lispy> @type length . flip take
08:06:40 <lambdabot>   Expecting a function type, but found `b'
08:06:40 <lambdabot>   Expected type: a1 -> [a]
08:07:09 <lispy> oh well, i'm at work
08:07:20 <lispy> i should be doing work instead of messig with haskell :)
08:07:20 <jethr0_> @seen shapr
08:07:21 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 21 minutes and 29
08:07:21 <lambdabot> seconds ago.
08:07:34 <lispy> @quote
08:07:35 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level
08:07:35 <lambdabot> than syntax is perl
08:07:38 <Cale> lispy: Timesheet updated.
08:07:58 <lispy> Cale: heh
08:08:28 <lispy> i'm the only one in the office this morning and i was out of projects on Friday
08:08:33 <lispy> so, that's part of why i'm here
08:08:40 <lispy> just need to sniff out some work
08:09:22 <poetix> @quote
08:09:22 <lambdabot> conjure says: BitTorrent client in (hopefully) 10,000 lines: darcs get
08:09:22 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
08:09:40 <Cale> @quote
08:09:40 <lambdabot> autrijus says: Well, ever since the monadic revolution of '98 Haskell
08:09:40 <lambdabot> people have started to do real world apps
08:09:46 <Cale> hehe
08:10:11 <Cale> I wouldn't say it was '98. There's material from before then on monads
08:10:23 <lispy> ocaml even has monads
08:10:35 <lispy> man, so many project ideas, so little time
08:10:48 <Cale> yeah, but Haskell without monads is much less practical than ocaml without monads :)
08:10:50 <jethr0_> cale, revolution doesn't mean it's new, just that there was a change of use patterns :)
08:10:57 <Cale> I suppose :)
08:11:11 <lispy> i wanted to write Haskell -> Ocaml syntax converter so I could measure the difference between the ocaml compiled code (with ocaml semantics) vs. haskell compiled code with haskell semantics
08:11:35 <Cale> Write a Haskell -> Ocaml compiler that preserves syntax :)
08:11:36 <ricebowl> um, help :o
08:11:36 <Cale> er
08:11:40 <Cale> semantics
08:11:43 <ricebowl> http://www.rafb.net/paste/results/0kmNus43.html <-- why does my array end up unmodified?
08:11:50 <malcolm> I have a student who is supposed to be doing exactly that (haskell->ocaml)
08:12:08 <lispy> malcolm: cool
08:12:11 <ricebowl> I'm calling fwiu from the debugger and getting back an array that's identical to the input
08:12:33 <Cale> ricebowl: what are you writing?
08:12:44 <malcolm> lispy: sadly, not much progress this term yet
08:12:53 <lispy> Cale: partially i was curious about the cost of laziness, so having a transalation that preserves laziness and one that does not would be interesting
08:13:08 <ricebowl> Cale - I rewrite the matrix N times where the matrix has dimensions NxN
08:13:15 <ricebowl> it's Floyd-Warshall's algorithm...
08:13:30 <jethr0_> i'm trying to do:  "g( g( g( g( f a) b) c) d) e" for a given args a..e. i'm sure there's a fold in there somewhere...
08:13:34 <Cale> lispy: I get the sense that not preserving laziness would kill quite a few Haskell apps :)
08:13:49 <lispy> malcolm: tell him/her that they will have to hurry or lispy will get the scoop on them :)
08:14:02 <Cale> ricebowl: ah
08:14:27 <malcolm> jethr0_: foldl f g [a,b,c,d,e]
08:14:29 <lispy> malcolm: which actually i wouldn't because i'm too busy with other stuff :)
08:14:54 <lispy> Cale: hmm...good point.  It wouldn't be fair unless the algos were retooled
08:15:02 <Cale> why are the parameters to foldr/l in reverse order?
08:15:15 <ricebowl> Cale - there's another function I have which is a thin wrapper around Data.Array.IArray.listArray. I pass it the list [0,1,10,10,0,1,1,10,0]
08:15:30 <ricebowl> this should obviously result in the matrix [0,1,2,2,0,1,1,2,0]
08:15:40 <ricebowl> but instead I get the original matrix back :|
08:15:48 <ricebowl> I think it's throwing away my changes and giving me the original matrix
08:15:50 <ricebowl> but I don't know why.
08:16:03 <jethr0_> malcolm: huh? g is supposed to be a function... i'm not sure that's correct
08:16:37 <Cale> (fw a' xs) >> a'
08:16:47 <Cale> hmm
08:16:52 <malcolm> @type foldl
08:16:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:17:30 <malcolm> jethr0_: you are right
08:17:44 <lispy> del.icio.us is down and i can barely stand it
08:17:54 <lispy> i've moved all my bookmarks there :)
08:19:18 <Cale> @type sequence_
08:19:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:19:27 <Cale> @type foldl1' (>>)
08:19:28 <lambdabot> Not in scope: `foldl1''
08:19:32 <Cale> @type foldl1 (>>)
08:19:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
08:19:40 <Cale> @type sequence
08:19:40 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:19:46 <Cale> ah, right
08:19:58 <Cale> oh, but you're ignoring the result anyway
08:20:16 <Cale> @type mapM
08:20:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
08:21:02 <Cale> fw' (k:ks) ijs a = do mapM (fwstep a k) ijs)
08:21:02 <Cale>                       fw' ks ijs a
08:21:20 <ricebowl> hmm, I see what I did wrong
08:21:35 <ricebowl> fw a xs = a >>= (\a' -> (fw' xs [(x, y) | x <- xs, y <- xs] a') >> return a')
08:21:54 <ricebowl> otherwise the modifications are thrown away
08:22:26 <goron> Even the Debian ghc-cvs package is broken.... 
08:22:32 <lispy> goron: hm...
08:22:36 <goron> (source package)
08:22:39 <Cale> ricebowl: use do notation!
08:22:48 <goron> So... GHC CVS is broken....
08:23:30 <lispy> ricebowl: aren't you still returning the wrong a'?
08:23:44 <lispy> ricebowl: shouldn't you return the result of fw'?
08:23:58 <goron> And I also can't install the ghc-cvs binary package, since I have broken dependencies. Way to go guys...
08:24:22 <lispy> goron: sudo apt-get install -f
08:25:18 <Cale> lispy: it doesn't matter, the result gets ignored anyway
08:25:25 <goron> lispy: that helps nothing.
08:25:35 <goron> Or Nothing if you only read Haskell ;)
08:26:23 <lispy> hmm...
08:26:31 <lispy> why is nothing returned?
08:27:03 <Cale> lispy: it's only evaluating for side effects
08:27:09 <Cale> (mutating that array)
08:27:26 <lispy> @type fw a xs = a >>= (\a' -> (fw' xs [(x,y) | x <- xs, y <- xs] a') >> return a')
08:27:27 <lambdabot> parse error on input `='
08:27:31 <Cale> s/evaluating/executing/
08:28:02 <Cale> fw a xs = do a' <- a
08:28:02 <Cale>              fw' xs [(x, y) | x <- xs, y <- xs] a'
08:28:02 <Cale>              return ()
08:28:27 <lispy> @type \xs a -> a >>= (\a' -> (fw' xs [(x,y) | x <- xs, y <- xs] a') >> return a')
08:28:28 <lambdabot> Not in scope: `fw''
08:28:54 <lispy> @type let fw a xs = a >>= (\a' -> (fw' xs [(x,y) | x <- xs, y <- xs] a') >> return a') in fw
08:28:55 <lambdabot> Not in scope: `fw''
08:29:01 <lispy> on nevermind
08:29:04 <lispy> ;)
08:29:16 <lispy> Cale: that version you typed definitely returns nothing
08:29:35 <Cale> yes
08:29:41 <Cale> it shouldn't return anything
08:29:44 <lispy> Cale: but, are they really equivalent?
08:29:56 <Cale> yes, because of the way that fw is being called
08:29:58 <lispy> shouldn't you last line be "return a'"
08:30:04 <Cale> it's the first parameter to >>
08:30:13 <Cale> so the monadic result is getting dropped
08:30:20 <shapr> jethr0_: You called?
08:31:10 <jethr0_> hehe, just wondering if i should put my TH thingey on tmr or not...
08:31:26 <shapr> Sure yeah
08:31:39 <jethr0_> can't create pages over there
08:32:24 <ricebowl> yay it "works"
08:33:00 <shapr> jethr0_: Assuming the same username on tmrwiki, you can now.
08:33:07 <jethr0_> he, thx
08:36:20 <Cale> ah, you actually do want to capture the result
08:44:02 <neologism> can you explain me what is "spelling" ?
08:44:08 <neologism> I mean the competition
08:44:14 <Cale> hm?
08:44:22 <Cale> like a spelling bee?
08:44:43 <neologism> probably
08:45:25 <Cale> Basically, it's a competition to see who is better at spelling esoteric English words.
08:45:59 <neologism> they really do say one letter after the another?
08:46:04 <Cale> Contestants are asked to spell words in turn. They're usually permitted to hear the word used in context, and to get a definition.
08:46:07 <Cale> yes
08:46:09 <neologism> thats competition?
08:46:18 <neologism> its hard to spell word?
08:46:20 <neologism> words?
08:46:32 <Cale> Apparently :)
08:46:39 <ricebowl> can be
08:46:44 <neologism> what is hard about it?
08:46:55 <Cale> English isn't phonetic.
08:46:58 <neologism> I just cannot imagine anything difficult in it
08:47:26 <neologism> well.. I know all words in my language and much more
08:47:33 <neologism> and I cannot imagine someone doesnt know all words
08:47:36 <ricebowl> your language is spelled phonetically
08:47:40 <Cale> spell: antidisestablishmentarianism
08:47:55 <Cale> actually, that's not so tricky :)
08:48:22 <Cale> since all of those are common pre/suffixes
08:48:41 <neologism> hm.. its very hard for me to imagine competition in this
08:48:57 <Cale> sarsaparilla
08:49:10 <Cale> that has a silent r
08:49:24 <Cale> (well, silent in many areas)
08:49:34 <ricebowl> "committed" <-- one might try to spell this as "comitted" or "commited"
08:49:39 <goron> Does anybody have a ghc cvs checkout lying out caring to do "cvs up" and then autoreconf;./configure;make, and see whether it also hangs on make?
08:49:51 <goron> out->around
08:49:54 <jethr0_> there are some pretty mean words in english. like totally unused greek once, etc
08:51:01 <ricebowl> "millennium" <-- interestingly, the "class of 2000" at my high school attempted to call themselves the millennium class, except that they misspelled this word.
08:51:07 <ricebowl> much to their embarrassment.
08:51:37 <Cale> how did they spell it?
08:51:50 <goron> Cale: Do you have a checkout of ghc?
08:52:01 <ricebowl> I forget; they omitted one of the doubled letters
08:52:02 <Cale> goron: not at the moment
08:52:07 <ricebowl> I think they wrote "milennium"
08:52:11 <araujo> millenium more likely
08:52:21 <araujo> hah
08:52:45 <ricebowl> anyway, it is a trivial matter to misspell English words
08:52:46 <araujo> ricebowl, geez, but nobody had a dictionary at hand :-P
08:53:09 <jethr0_> words like "appoggiatura." are not so easy anymore. not so english either :)
08:53:17 <araujo> ricebowl, good to know it doesn't happen to me only ;-)
08:53:56 <araujo> beauracracy
08:54:01 <ricebowl> araujo - engineers are notorious for poor spelling, grammar, and handwriting
08:54:04 <xerox> appoggiatura?
08:54:07 <xerox> appoggio
08:54:08 <araujo> @babel en es beauracracy
08:54:10 <lambdabot>  beauracracy
08:54:11 <jethr0_> there should be an "o" in there, araujo
08:54:18 <araujo> @babel en es beaurocracy
08:54:19 <lambdabot>  beaurocracy
08:54:25 <xerox> bureaoucracy
08:54:29 <jethr0_> xerox: it's a word from a spelling bee
08:54:34 <xerox> uh?
08:54:51 <Cale> bureaucracy
08:55:02 <araujo> @babel en es bureaucracy
08:55:04 <lambdabot>  burocracia
08:55:05 <Cale> from bureau
08:55:06 <ricebowl> araujo - that is to say that your spelling is probably quite exceptional when compared to that used by some native speakers...
08:55:06 <araujo> good
08:55:12 <araujo> always had problems with that workd
08:55:21 <Cale> or bureaux
08:55:25 <jethr0_> bureaucracy
08:55:39 <jethr0_> but i had to look it up too :(
08:56:10 <ricebowl> obviously borrowed from French; who else would cram billions of silent vowels into the middle ;)
08:56:15 <araujo> ricebowl, indeed, i know engineers that just can't write :-P
08:56:17 <shapr> How about onomatopoeic ?
08:56:45 <araujo> @babel en es onomatopoeic
08:56:46 <lambdabot>  onomatopoeic
08:56:50 <araujo> @babel en es onomatopeic
08:56:51 <lambdabot>  onomatopeic
08:56:59 <xerox> onomatomeica
08:57:05 <xerox> err :)
08:57:07 <shapr> Can you guess how to say Thibodeaux in New Orleans?
08:57:08 <ricebowl> someone wrote that English has 12 or 13 different ways to represent the sound sh...they quickly pointed out that this is a bug, not a feature ;)
08:57:15 <araujo> @babel en es onomatopeyac
08:57:21 <lambdabot>  onomatopeyac
08:58:02 <Cale> onomatological
08:58:02 <neologism> still.. its strange for me to imagine something like that
08:58:09 <neologism> I'd laugh a lot on such comeptition
08:58:22 <shapr> Or how about slough, though, ought, bough, and worcestershire?
08:58:37 <araujo> Ive always found spelling words very easy for my native language.
08:58:38 <araujo> Since i was a child.
08:58:42 <ricebowl> shapr - those are all easy except the last
08:58:42 <shapr> (sluff, tho, ot, bo and wooster)
08:58:50 <ricebowl> araujo - gee, wonder why that is :p
08:58:52 <Cale> onychophoran
08:58:55 <neologism> araujo: yur native being wht?
08:59:01 <araujo> spanish
08:59:09 <neologism> I dont know spanish
08:59:13 <ricebowl> araujo - I've met enough Spanish speakers who can't spell it though
08:59:18 <ricebowl> which is very funny ;)
08:59:19 <shapr> ricebowl: ough is spoken at least four different ways.
08:59:29 <araujo> I used to spell whole passphrase forward adn backward :-)
08:59:37 <ricebowl> shapr - one day when I was bored I found 8 different renderings of the single vowel a
08:59:48 <araujo> ricebowl, yes, that's something i don't understand
08:59:56 <ricebowl> that is the case for a lot of combinations in English
09:00:01 <shapr> Written and spoken Finnish matches close to 100%. You may have no idea what a word means, but you can always read it or spell it.
09:00:03 <neologism> english is not well engineered ;)
09:00:08 <araujo> I mean, i think it is comprehensible with a foreign language.. but your native language?!
09:00:17 <neologism> shapr: same with czech
09:00:38 <ricebowl> araujo - please tell me that this is equally unintelligible to you, too: "ma idoa volver loco"
09:00:52 <araujo> ricebowl, That is a disaster for me :-P
09:00:56 <ricebowl> yes, thank you!
09:01:05 <araujo> I guess he says: me he ido a volver loco
09:01:18 <ricebowl> yes
09:01:20 <araujo> Which it isn't still well structured.
09:01:25 <ricebowl> something like that
09:01:30 <ricebowl> well I was just trying to make something up
09:01:38 <Cale> oppignoration
09:01:39 <shapr> On the downside, words in Finnish can mean entirely different things in different contexts.
09:01:45 <araujo> It ios like to say, ive gone to become crazy
09:01:50 <Cale> man, there are some obscure words :)
09:01:52 <ricebowl> I know :p
09:02:01 <neologism> shapr: context sensitive? :)
09:02:16 <araujo> shapr, That happens with spanish too.
09:02:23 <ricebowl> haha this one person always writes "haber" instead of "a ver"
09:02:27 <ricebowl> always confuses the heck out of me
09:03:06 <ricebowl> that's like confusing "they're", "there", and "their" :S
09:03:16 <araujo> ricebowl, even worse :-P
09:03:51 <ricebowl> I wish they would write properly; it's extremely difficult for me to understand when they don't
09:04:01 <ricebowl> the same has happened to me a time or two in English
09:04:24 <ricebowl> but fortunately most English-speakers I know online are reasonably intelligent and reasonably-well educated ;)
09:04:28 <jethr0_> it's funny, when learning a lanuage and noticing a pecularity, i think: those are weird people having the same word for two things. and then it hits me, that german does the exact same thing :)
09:04:48 <Cale> The Number of Words in the English Language: 961,958 (estimate 3:44 pm Pacific 11 Dec 2005)
09:05:01 <ricebowl> awesome
09:05:16 <ricebowl> let's adopt an ideographic script so that nobody can understand a word
09:05:17 <araujo> shapr, Those are the words which are written the same and pronounced the same but got different meaning depending on the context.
09:05:17 <jethr0_> ya well, but including all french, greek, latin, italian synonyms...
09:05:24 <araujo> I don't recall their name.
09:05:35 <ricebowl> homonyms?
09:06:03 <jethr0_> yes
09:06:30 <shapr> Finnish has some neat words like älärääkkääkkään
09:06:38 <jethr0_> HAHA
09:06:54 <araujo> ricebowl, mm.. i think we have other name for them....
09:07:01 * xerox laughs
09:07:02 <xerox> @. eval babel it en (id) est dove est = 1
09:07:04 <lambdabot> 1
09:07:32 <jethr0_> but german can produce pretty long ones (like this slightly artificial but perfectly sensible one): Donaudampfschifffahrtsgesellschaftsraddampferkapitnskajtentrsicherheitsschlssel
09:08:07 <ricebowl> a parse, please!
09:08:13 <xerox> write Haskell in your natural language!
09:08:29 <ricebowl> better yet, learn a natural language with Haskell's syntax
09:09:19 <jethr0_> the "safety" key for the captain's cabin's door at a steamboat of the danube steamboard company
09:09:27 <araujo> hah, yeah, i studied german for a while, and i noticed they have pretty big words :-]
09:09:50 <jethr0_> i mean this is artificial, but in legal texts we've got pretty long used ones!
09:10:23 <ricebowl> liebensmittel!
09:10:28 <ricebowl> or something
09:11:26 <ricebowl> http://www.wheresgeorge.com/ <-- wtf, btw :p
09:11:31 <jethr0_> lebensmittel, it means sth like foodstuffs, but isn't all that long for german standards :)
09:12:07 <neologism> I kno wthat turkish has some 600 bilions of forms of shaping words
09:12:15 <neologism> while english has 13 which covers 99% of the cases
09:12:42 <jethr0_> shapr: what does lr... mean?
09:13:31 * ricebowl hat hunger :S
09:13:56 * jethr0_ wird sich gleich etwas zu essen machen
09:14:15 <ricebowl> danke
09:14:24 <jethr0_> i find it funny how anglophones make fun of the german "ch"...
09:14:32 <ricebowl> eh?
09:14:40 <ricebowl> which one?
09:15:00 <xerox> ahahah
09:15:02 <jethr0_> it seems to be _very_ how to pronounce for them because there's no equivalent in english.
09:15:03 * xerox laughs evilly.
09:15:09 <xerox> @compose eval babel it en let vivi = vita; vita = tu vita; in (vita :: Int)
09:15:11 <lambdabot> Exception: <<loop>>
09:15:13 <jethr0_> s/how/hard
09:15:13 <ricebowl> the sh-like sound?
09:15:14 <xerox> Eh.
09:15:34 <jethr0_> ricebowl: yes, but it's not sh-like at all :)
09:15:56 <ricebowl> xerox - translation is "let to live = life; life = your life; in (life :: Int)"?
09:16:16 <ricebowl> jethr0_ - that's why I asked which one...the 'ch' in "ich" and "nicht" is very sh-like
09:16:28 <ricebowl> but in machen it's the /kh/ sound
09:16:41 <xerox> haha.
09:16:44 <ricebowl> and kh is very easy
09:16:48 <jethr0_> true, but in nicht, it's also different from "sh"
09:16:56 <xerox> It is poetry!
09:16:56 <ricebowl> xerox - how close?
09:17:00 <xerox> Live life,  your life,  in life.
09:17:05 <xerox> And it makes:
09:17:06 <ricebowl> ah
09:17:10 <xerox> @compose eval babel it en let vivi = vita; vita = tu vita; in (vita :: Int)
09:17:11 <lambdabot> Exception: <<loop>>
09:17:16 <xerox> _that -^ ahah
09:17:22 <shapr> Cale: You think HaskellNewbie should be prominently linked from the learning page?
09:17:27 <xerox> shapr: isn't that *cool*
09:17:31 <ricebowl> jethr0_ - yes, it is different, but it's still similar to my ear...
09:17:36 <jethr0_> :)
09:17:59 <Cale> shapr: might be a plan :)
09:18:01 <jethr0_> xerox: how does it know where one command ends and the other starts?
09:18:04 <ricebowl> jethr0_ - which sound do they make fun of?
09:18:12 <Cale> and the IRC channel info :)
09:18:15 <jethr0_> the /kh/ one
09:18:19 <xerox> jethr0_: just two commands
09:18:24 <ricebowl> oh, that's the easier of the two, go figure
09:18:33 <ricebowl> Russian and Georgian and Lojban all have that sound
09:18:40 <ricebowl> usually transliterated as kh or x
09:18:41 * xerox is sad nobody notices his poetry skills
09:18:48 <shapr> xerox: It's cool.. confusing, but cool.
09:18:49 <xerox> But it happenss to every poet, I fear
09:18:58 <Cale> English people make fun of the kh sound in any language :)
09:19:02 <jethr0_> it's so funny how you can people to pronounce anything until they've seen how it's written!
09:19:23 <jethr0_> s/can/can teach/
09:19:24 <jethr0_> *argh*
09:19:30 <xerox> \o/
09:19:44 <shapr> hi SamK, learning Haskell? :-)
09:20:17 * shapr boings
09:20:31 <ricebowl> jethr0_ - I always write it as x, i.e. "xorosho" when transliterating Russian
09:20:39 <ricebowl> s/i.e./e.g./
09:20:59 <ricebowl> Spanish x used to be that sound, or so I read.
09:21:23 <jethr0_> you mean like in mexico
09:21:34 <ricebowl> exactly, except it's an h sound now
09:21:56 <jethr0_> the "j" is similar to the "ch". like in alejandro
09:22:10 <ricebowl> huh? No way
09:22:15 <jethr0_> if there were such a name
09:22:31 <ricebowl> j is an h sound
09:22:50 <jethr0_> but there a spanish speakers that would pronounce alejandro with more than a silent "h"
09:23:33 <jethr0_> "es muy leja de aqui" would also be more than a simple "h"
09:24:13 <ricebowl> maybe in some dialect...but not in international Spanish
09:24:20 <jethr0_> hmm, okay
09:24:48 <jethr0_> how do you pronouce "javier" then?
09:24:58 <jethr0_> bad example, take "leja"
09:28:07 <tennin> hmm, isn't Spanish x pronounced differently in different words?
09:28:19 <ricebowl> yes
09:28:24 <ricebowl> sometimes ks, sometimes h
09:29:02 <ricebowl> AFAIK. It has been about a decade since I heard the language consistently.
09:29:13 <ricebowl> reading doesn't count
09:30:32 <araujo> x might be pronounced quite different between many words
09:31:02 <ricebowl> araujo - "exepto" is pronounced similar to "except" in English, isn't it?
09:31:17 <ricebowl> basically the same, except the Spanish version has -o on the end
09:31:26 <araujo> ax, ack, z ......
09:31:32 <araujo> yes
09:31:38 <ricebowl> ok, thought so
09:31:52 <araujo> Pretty similar the pronounciation.
09:32:04 <araujo> exception too
09:32:10 <araujo> excepción
09:32:44 <ricebowl> the stress is different, and that causes a vowel shift in English...
09:33:14 <jethr0_> ikceppshen
09:33:34 <ricebowl> eksepshun (where u denotes schwa)
09:33:49 <ricebowl> hmm, I think that is common denoted with y
09:33:54 <ricebowl> eksepshyn
09:34:19 <jethr0_> yes, but the initial "e" tends towards an "i". for many, at least
09:34:38 <ricebowl> not for me
09:35:01 <jethr0_> he
09:58:45 <basbom> is there a function for splitting a string. Let's say I want to split at every occurence of a space character.
09:59:25 <basbom> words
09:59:29 <basbom> found it
09:59:35 <basti_> :D
10:00:00 <basbom> maybe something more configurable than words?
10:00:23 <basbom> where I can supply my own split characters.
10:00:24 <basti_> we had that question quite often
10:00:29 <basbom> aha
10:00:29 <basti_> I'm trying to get it together
10:00:55 <xerox> iterate splitAt I'd say
10:01:40 <basti_> mmmph
10:03:44 <basti_> I can't get it together anymore, but I'm tired too
10:08:59 <basbom> instead of having to type "words s" i would like to just say splits = word s. Is that possible?
10:09:10 <basti_> yes
10:09:15 <basti_> just not in interaction
10:09:40 <basbom> but I get "undefined variable "s" in winhugs
10:09:55 <basti_> yes.
10:09:59 <basti_> it won't work in interaction.
10:10:10 <basti_> and it won't work without a variable s either
10:10:10 <basbom> what mean interaction?
10:10:20 <basti_> hugs or ghci are interactive environments
10:10:31 <basbom> ok, i have a script
10:10:54 <basbom> the point is that i want to write splits!!2 and so on.
10:11:05 <basbom> not (words s)!!2
10:11:08 <basti_> yes.
10:11:14 <basti_> so do you have a variable s?
10:11:17 <xerox> basti!
10:11:21 <xerox> > let wordsBy k xs = groupBy (const $ (/= k)) xs >>= clean where clean (' ':xs) = [xs]; clean xs = [xs] in wordsBy ' ' "ciao come va"
10:11:22 <lambdabot> ["ciao","come","va"]
10:11:34 <basbom> yes the string i want to split
10:11:36 <xerox> > let wordsBy k xs = groupBy (const $ (/= k)) xs >>= clean where clean (' ':xs) = [xs]; clean xs = [xs] in wordsBy '_' "aaa_bbb_ccc_d"
10:11:37 <lambdabot> ["aaa","_bbb","_ccc","_d"]
10:11:42 <xerox> uh sorry.
10:11:50 <xerox> > let wordsBy k xs = groupBy (const $ (/= k)) xs >>= clean where clean (k:xs) = [xs]; clean xs = [xs] in wordsBy '_' "aaa_bbb_ccc_d"
10:11:51 <lambdabot> ["aa","bbb","ccc","d"]
10:11:54 <xerox> Yes.
10:12:11 <basti_> xerox: great.
10:12:18 <xerox> thanks much!
10:12:23 <jethr0_> i still wonder why some of these nifty string function ain't in the standard
10:12:40 <basti_> basbom: so if s isn't declared, there is something wrong, isnt there?
10:13:09 <basbom> yes, but I thought I had seen something like this somewhere..
10:13:29 <basbom> it's like a nested "where"
10:13:39 <basbom> except that doesn't seem to work
10:14:08 <basti_> first, "assignments" (declarations) won't work in interactions
10:14:19 <basti_> that is, they work not as you expect
10:14:20 <basbom> i don't have interactive mode
10:14:23 <basti_> thats good
10:14:27 <basti_> then, did you declare s?
10:14:36 <basbom> like this
10:14:39 <basbom> putStrLn "Finished"
10:14:39 <basbom>           where
10:14:39 <basbom>             makecmd s = cmd ++ s ++ " -ab32 " ++ splits!!2 ++ "-" ++ splits!!4 ++ ".mp3"
10:14:39 <basbom>             where
10:14:39 <basbom>               splits = words s
10:14:43 <xerox> basti_: like that?
10:15:26 <basti_> basbom: that should be possible yes, modulo indentation issues
10:15:59 <xerox> Be careful with (!!)
10:16:04 <basbom> ok the second where has to be indented for some reason
10:16:10 <basbom> why careful with !!
10:16:12 <basbom> ?
10:16:22 <basti_> !! has a very low priority
10:16:24 <xerox> > [] !! 10
10:16:25 <lambdabot> Add a type signature
10:16:29 <xerox> > [] !! 10 :: Int
10:16:30 <lambdabot> Exception: Prelude.(!!): index too large
10:16:36 <basti_> and that, too.
10:16:39 <xerox> > [1,2,3] !! (-1) :: Int
10:16:40 <lambdabot> Exception: Prelude.(!!): negative index
10:16:42 <basbom> that's what I just hot
10:16:43 <basbom> ot
10:16:45 <basbom> got
10:16:49 <xerox> thought
10:16:52 <xerox> ok :P
10:17:01 <basbom> i thought I was out of array bounds
10:18:48 <basti_> yes you are, when you get these messages
10:26:44 * shapr is tired
10:26:50 * xerox toooo
10:27:01 * basti_ too
10:27:08 * shapr rebuilds conjure.
10:27:18 * xerox stretches and yawns a little more
10:30:52 <shapr> Did the cabal field Extensions become something else?
10:31:50 <shapr> Oh hey, my girlfriend said she wants to learn Haskell from the Hudak book. This should be fun.
10:32:32 <xerox> Why learn it from book when you have a living sensei in the house!
10:32:54 <shapr> I seem to be a crappy teacher for people who have zero programming experience.
10:33:06 <xerox> Dang.
10:33:31 <shapr> We tried that once, she got frustrated, so I suggested she try either the Thompson or Hudak book, since I have them both.
10:33:47 <musasabi> shapr: yes, that seems to be quite hard. (having had to teach my gf some things for programming courses)
10:33:52 <basbom> I would like to modify getDirectoryContents so that it prepends each file with the parent directory name. Is this possible?
10:34:47 <musasabi> basbom: 1) get the name of the parent directory, 2) getDirectoryContents, 3) concatenate parent to each of the results strings.
10:35:08 <gour> shapr: which one (book) you like more*
10:35:20 <shapr> musasabi: Part of the problem is that I try to give a thorough answer to questions like "Why does it do that?" when probably I should say "Right now, you don't need to know."
10:35:49 <musasabi> getDirectoryContentsWithParent path = mapM (\d -> path ++ "/" ++ d) =<< getDirectoryContents path
10:36:28 <shapr> gour: In my opinion, Hudak's "Haskell School of Expression" book is better as teaching books go, but its required graphics library is mostly bitrotted on windows.
10:36:42 <musasabi> shapr: and those questions just open new questions.
10:36:45 <shapr> Happily, dcoutts wrote a cairo port of the library, so I'll see if that works.
10:37:05 <shapr> musasabi: and then my students get frustrated when I try to teach them lambda calculus.
10:37:14 <dcoutts> shapr, feedback welcome of course :-)
10:37:15 <shapr> To start out, they just want code that does *something*.
10:37:35 <mjl69> @type foldr1
10:37:36 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:37:41 <gour> shapr: but you learnt from thompson?
10:37:45 <syntaxfree> for every type a, there is a corresponding type IO a, right?
10:37:54 <basti_> syntaxfree: yes.
10:38:04 <basbom> musasabi: what are we doing here. You are mapping the function (\d -> path ++ "/" ++ d) against what? Is it possible to express this with only let and <- ?
10:38:08 <shapr> gour: Yes, because I have zero math background. Even the basic geometry stuff in Hudak was beyond me at the time.
10:38:12 <musasabi> most of the time I try to explain things in a concrete way with pen and paper rather than use nice concise mathematical explanations
10:38:31 <musasabi> basbom: yes:
10:38:31 <syntaxfree> it sounds like there is an IO functor.
10:38:53 <xerox> I don't think so
10:39:02 <basti_> i do.
10:39:10 <musasabi> getDirectoryContentsWithParent path = do ps <- getDirectoryContents path; return $ map (\d -> path ++ "/" ++ d) ps
10:39:22 <mjl69> so foldr1 takes two args, the first is a function that takes two args of the same type and yields a result of the same type.  The second is a list of this same type.  Overall, foldr1 then yields a result of this same type a.
10:39:25 <Saulzar> Hmm, are there any value in the various books over everything available on the net? It seems that there's a massive amount of great material for haskell around.
10:39:29 <syntaxfree> is IO a functor?
10:39:32 <shapr> Sofia was able to make her own types and do pattern matching with those, so at least I taught her something :-)
10:39:33 <xerox> uh
10:39:33 <ski> @type fmap :: (a -> b) -> IO a -> IO b
10:39:34 <lambdabot> (a -> b) -> IO a -> IO b :: forall a b. (a -> b) -> IO a -> IO b
10:39:43 <xerox> triangles map to triangles for io then, right
10:39:45 <ski> @type (fmap :: (a -> b) -> IO a -> IO b)
10:39:45 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
10:39:46 <gour> shapr: huh, that sounds great (your math backg.) considering you are still able to use monads :-)
10:39:56 <ski> syntaxfree : yes .. all monads are functors
10:40:01 <syntaxfree> ok.
10:40:08 <mjl69> so it should not bother me when the second arg of foldr1 is a list comprehension which reduces to a list, right?
10:40:12 <xerox> @type (liftM :: (a -> b) -> IO a -> IO b)
10:40:13 <lambdabot> Not in scope: `liftM'
10:40:19 <xerox> @type (Control.Monad.liftM :: (a -> b) -> IO a -> IO b)
10:40:20 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
10:40:25 <mjl69> It just seems a little strange at first.
10:40:29 <syntaxfree> is there a "reverse" functor for IO?
10:40:31 <musasabi> Saulzar: the books may be better if you don't have experience from other languages, but the net resources are fine if you have good grasp of basic programming consepts.
10:40:35 <xerox> OI?
10:40:37 <ski> (syntaxfree : however, e.g. data Foo a = F (a -> Bool) is not a functor)
10:41:03 <syntaxfree> ski: sure. that's just a space of functions.
10:41:14 <shapr> gour: Monads are easier than geometry.
10:41:31 <basbom> musasabi: very nice. but i guess i have to define that function. there is no way to do it in the workflow of my other code.
10:41:32 <ski> (syntaxfree : otoh. data Bar a = B (Bool -> a) is a functor)
10:41:50 <syntaxfree> ski: now I'm lost. What are the categories involved in that functor?
10:41:58 <ski> syntaxfree : what would a 'reverse' functor do ?
10:42:13 <syntaxfree> well, composed with the original functor, it'd yield an id functor.
10:42:22 <syntaxfree> In this case, it'd take IO Num to Num. 
10:42:32 <ski> syntaxfree : the usual, i.e. the category of haskell types and functions
10:42:42 <syntaxfree> I'm guessing referential transparency or whatever prohibits getting a Num out of an IO Num.
10:42:51 <musasabi> basbom: of course you can just define that "inline" in your other code, but most of the time it makes sense to keep functions short so testing things becomes easier (also nice for refactoring)
10:42:52 <ski> yes
10:43:29 <syntaxfree> I'm not sure what <- does.
10:43:31 <gour> shapr: to use or understand?
10:43:42 <ski> syntaxfree : where ?
10:43:46 <basbom> musasabi: I was thinking about the return part in your function.
10:43:51 <syntaxfree> well, in something like x<-getLine
10:44:05 <ski> syntaxfree : that's sugar in the do-notation
10:44:09 <mjl69> x<-xs is a generator
10:44:21 <mjl69> in a list comprehension
10:44:23 <syntaxfree> ski: what does it mean?
10:44:41 <syntaxfree> ah, yes. I forgot about list comprehensions. They're just sugar for maps, filters and zipwiths.
10:44:44 <ski> do {x <- foo; ...}  =  foo >>= \x -> do {...}
10:44:56 <ski> do {foo; ...}  =  foo >> do {...}
10:45:00 <musasabi> basbom: well you can certainly live without return, but I think that the code is just more pretty that way.
10:45:12 <ski> do {let x = foo; ...}  =  let x = foo in do {...}
10:45:15 <musasabi> syntaxfree: rather they are syntactic sugar for the list monad.
10:45:21 <ski> do {foo} = foo
10:45:25 <mjl69> I don't fully get Monads and do notation yet, but I sense that there is a connection with list comprehensions somehow.
10:45:25 <syntaxfree> @type (>>)
10:45:26 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
10:45:54 <ski> mjl69 : yes .. actually, first wadler extended list comprehensions to monad comprehensions (same syntax)
10:46:11 <syntaxfree> Wadler is a master of paper naming.
10:46:31 <musasabi> mjl69: it has a connection as list is a monad etc
10:46:32 <syntaxfree> "Theorems for free!" caught my eye, even though I didn't get the first word of it.
10:46:50 <syntaxfree> I wasn't interested in Haskell or anything back then. I just stumbled into it while looking for something else.
10:46:54 <ski> mjl69 : [foo | x0 <- bar0 , let x1 = bar1 , ...]  =  do {x0 <- bar0; let x1 = bar1; ...; return foo}
10:47:13 <mjl69> cool.  I am taking my time working my way slowly towards that stuff.
10:47:25 <mjl69> ski: yeah, that's what I was thinking of.
10:47:43 <syntaxfree> anyway, back to study.
10:47:49 <mjl69> me too :-)
10:48:02 <ski> mjl69 : the main difference is that when converting from list compr. to do-notation (with list monad), you put what to return last, and wrapped in 'return'
10:48:24 <joelr1> howdy folks
10:48:31 * ski goes back to sleep
10:48:34 <syntaxfree> any simple way to find out what functions are defined for a given type class?
10:49:10 <ski> ':i Num' works in both hugs and ghci, here
10:49:12 <araujo> hello joelr1 
10:49:19 <araujo> joelr1, spanish?
10:49:23 <joelr1> Cale: ping
10:49:27 <musasabi> hello joelr1 
10:49:28 <joelr1> araujo: not really
10:49:38 <syntaxfree> ok!
10:49:39 * joelr1 needs some array optimization help
10:49:52 <araujo> joelr1, oh well, i was about to invite you to #haskell.es :-)
10:49:53 <musasabi> syntaxfree: use :i NameOfClass in ghci
10:50:12 <joelr1> araujo: i'm not much of a spanish speaker when computer terms are involved
10:50:28 <musasabi> joelr1: unsafe{Read,Write} + STUArray + no bugs
10:50:31 <syntaxfree> oh. cool!
10:50:38 <araujo> joelr1, me neither ;-)
10:50:58 <joelr1> musasabi: why ST? why not IO?
10:51:11 <musasabi> (because that does not check whether you violate array indexes and other such small things)
10:51:26 <joelr1> musasabi: hmm... how very interesting
10:51:37 <musasabi> joelr1: IO-arrays are just wrapped ST arrays, the performance difference is usually quite small though.
10:51:47 <joelr1> musasabi: would you be willing to take a look at what i'm doing? profiling report attached
10:52:23 <syntaxfree> Haskell really needs sugar for n-times function application. Yes, I know it can be emulated with simple recursion.
10:52:38 <ski> 'n-times' ?
10:53:01 <syntaxfree> ntimes f 1 = f; ntimes f n = f . (ntimes f (n-1))
10:53:05 <musasabi> joelr1: if you ask me in 2.5 hours, have two hours to get some work code done (which is why I shouldn't be ircing)
10:53:06 <ski> ncompose :: Int -> (a -> a) -> (a -> a)
10:53:07 <ski> ?
10:53:33 <joelr1> musasabi: that would be at 21:30 my time, ok :)
10:53:38 <joelr1> dons: ping
10:53:49 <joelr1> array performance is killing me :(
10:54:06 * syntaxfree starts #lambdarockers :P
10:54:07 <ski> syntaxfree : yes such a function would be nice (btw, better basecase is to return 'id' when number is '0') .. (but i don't see how special syntax would be warranted)
10:54:18 <syntaxfree> I can't get to work with arrays in Haskell or Scheme. It's too limiting.
10:54:37 <syntaxfree> ski: maybe just an infix function
10:54:49 <syntaxfree> (@) looks fine.
10:54:56 <syntaxfree> @hoogle (@)
10:54:57 <lambdabot> No matches found
10:55:12 <ski> '@' is syntax
10:55:16 <ski> in patterns
10:55:26 <basti_> i think hoogle is a bit broken, btw.
10:55:30 <syntaxfree> oh, true.
10:55:32 <syntaxfree> lemme thing.
10:55:38 <basti_> or i don't get the syntax at all.
10:56:06 <syntaxfree> @hoogle (__)
10:56:07 <lambdabot> Prelude.undefined :: a
10:56:07 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
10:56:07 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:56:27 <syntaxfree> @hoogle (#)
10:56:28 <lambdabot> No matches found
10:56:37 <syntaxfree> (#) is good!
10:56:48 <syntaxfree> Do you prefer f # 10 or 10 # f?
10:57:37 <araujo> # f 10
10:57:38 <araujo> :-P
10:58:20 <syntaxfree> maybe (^) should be overloaded. 
10:58:30 <ski> i guess 'f # 10' fits best with the reading as exponentiation
10:58:34 <basti_> what are you talking about?
10:58:45 <syntaxfree> about a syntax for n-times function composition.
10:58:50 <basti_> oh
10:59:03 <basti_> yes i think the number should be right
10:59:16 * ski sometimes wants haskell to allow infix ops to take right arg as first, and left as second .. or taking them in a pair
10:59:23 <syntaxfree> (#) f 0 = id; (#) f n = f . (f # (n-1))
10:59:40 <astrolabe_> What would the type of # be?
10:59:55 <ski> f # 0 = id; f # n = f . (f # (n-1))
10:59:57 <syntaxfree> (a->a)->(a->a)
11:00:05 <syntaxfree> You can't have (a->b) composed with itself.
11:00:09 <ski> (#) :: (a -> a) -> Int -> (a -> a)
11:00:23 <syntaxfree> true.
11:00:30 <syntaxfree> (a->a) -> Int -> (a->a)
11:01:22 <astrolabe_> We should have a #haskell preludePlus or something.
11:01:40 <syntaxfree> I can do the organization job.
11:01:56 <astrolabe_> It might be difficult to agree what goes in :)
11:01:59 <syntaxfree> keep the wiki page and all. There has to be a cabal deciding what gets in and what doesn't.
11:02:10 <syntaxfree> I propose we vote for a triumvirate :)
11:02:19 <ski> @wiki PreludeExts
11:02:19 <lambdabot> http://www.haskell.org/hawiki/PreludeExts
11:02:24 <ski> @wiki LicencedPreludeExts
11:02:25 <lambdabot> http://www.haskell.org/hawiki/LicencedPreludeExts
11:02:39 <astrolabe_> You can be Caeser then
11:02:48 <ski> syntaxfree : i vote for Curry in the triumvirate
11:03:00 <syntaxfree> there is a Curry in this channel?
11:03:09 <ski> Haskell Brooks Curry
11:03:49 <syntaxfree> oh. Haskell, the man, the citizen, the mathematician.
11:03:57 <ski> and, the logician
11:04:13 * ski almost said, the programmer
11:04:28 <basti_> he almost was
11:04:30 * syntaxfree too.
11:04:44 <ski> maybe if we invoke Curry-Howard, he was
11:05:27 <joelr1> http://wagerlabs.com/array.tgz if anyone cares to take a look
11:05:33 <joelr1> profiling report included
11:05:51 <syntaxfree> It'd be fun if someone took the hawiki prelude extensions to academic conferences.
11:08:53 <syntaxfree> infixl 0 # -- infixl (-1) would probably be better but it's impossible
11:08:53 <syntaxfree> x # f = f x
11:08:54 <syntaxfree> oh,  grrr.
11:09:46 <Heffalump> syntaxfree: took them to conferences and did what with them?
11:10:09 * ski 's off
11:10:16 <syntaxfree> maybe try to  make them into formal proposals, I  guess.
11:10:46 <Heffalump> academic conferences tend to be a bit deeper than random bits of Haskell code :-)
11:11:27 <syntaxfree> sure.
11:11:40 <syntaxfree> I guess a Haskell extension proposal needs to be a lot deeper than a bit of code at a wiki too.
11:13:41 <shapr> Some of the PreludeExts deserve to be at an academic conference, imo.
11:14:18 <Lokadin_> say
11:14:23 <Lokadin_> how do i make a branch?
11:14:26 <basbom> how to "flatten" a list of lists?
11:14:34 <Lokadin_> er declare it rather
11:14:56 <Cale> Lokadin: a branch of what sort?
11:14:57 <musasabi> basbom: concat
11:15:00 <joelr1> is it possible to cast a mutable array into a Ptr Word8?
11:15:03 <basbom> musasabi: thx
11:15:06 <Lokadin_> data BinaryTree = Leaf a | Branchh (BinaryTree a) a (BinaryTree a)
11:15:09 <Lokadin_> Branch*
11:15:18 <musasabi> > concat [["foo","bar"],["baz"]]
11:15:19 <lambdabot> ["foo","bar","baz"]
11:15:28 <Cale> Branch (Leaf 5) 7 (Leaf 6)
11:15:35 <Lokadin_> Cale: thanks :D
11:15:37 <Saulzar> joelr1, I have been using StorableArray 
11:15:50 <joelr1> Saulzar: what does that give you?
11:16:24 <joelr1> Saulzar: that's cool
11:16:30 <Saulzar> It gives you a function "withStorableArray" which provides a Ptr a, though not Word8
11:16:35 <musasabi> StorableArrays are only needed if you use FFI
11:16:54 <joelr1> Saulzar: casting allowed. it says that it's slower than IOUArray, though
11:16:57 <joelr1> well
11:17:01 <joelr1> in my case it goes like this
11:17:06 <musasabi> joelr1: for ugly code look at http://cs.helsinki.fi/u/ekarttun/SerTH/SerTH/Codec/Serialize/SerTH/BPtr.hs
11:17:15 <joelr1> i retrieve a IOUArray of 50k with hGetArray
11:17:30 <joelr1> this has a header of, say, 6 bytes to tell me that it's a compressed command
11:17:56 <joelr1> then i take the rest of the buffer, copy it into a new chunk with allocaBytes (which, btw, uses arrays underneath) and then decompress
11:18:02 <joelr1> and then i repeat the copy on the way out
11:18:08 <joelr1> it's absolutely killing me
11:18:22 <musasabi> joelr1: why are you doing all the copying?
11:18:30 <musasabi> joelr1: also conside memcpy from FFI
11:18:34 <musasabi> *consider
11:18:41 <Saulzar> Hmm
11:18:47 <joelr1> musasabi: i do not know how to cast IOUArray to pointer. uncompress is a ZLib function
11:18:53 <joelr1> it takes a Ptr Word8
11:19:21 <joelr1> i basically need to uncompress what's returned by hGetArray
11:19:43 <musasabi> joelr1: you could use something like BPtr + hGetBuf
11:20:31 <joelr1> musasabi: sounds like you are suggesting moving away from arrays and using pointers
11:21:01 <musasabi> joelr1: for serialization using pointers is usually the way to go.
11:21:18 <musasabi> joelr1: at least I have had better results with them.
11:21:19 <joelr1> musasabi: but my code is already damn full of array stuff :(
11:21:37 <joelr1> musasabi: i just posted to haskell-cafe asking for help. code at http://wagerlabs/array.tgz
11:21:45 <joelr1> i wonder if i can optimize it somehow
11:22:02 <musasabi> well you can do lots of stuff with arrays too, it is just a little bit more painfull
11:22:10 <basbom> how to get the " character into a string?
11:22:21 <musasabi> > "\""
11:22:22 <lambdabot> "\""
11:22:40 <joelr1> musasabi: i'll be back later
11:23:17 <Lokadin_> Cale: just out of curiosity,, do you ever sleep? :)
11:24:31 <astrolabe_> Apparently, he does.
11:24:37 <Lokadin_> lol
11:24:49 <Lokadin_> doses off occasionally at the computer terminal? lol
11:25:07 <Lokadin_> hmmm, i do that sometimes
11:29:39 <basbom> > "\""
11:29:40 <lambdabot> "\""
11:29:56 <basbom> > "hello\""
11:29:57 <basbom> > "hello""
11:29:57 <lambdabot> "hello\""
11:29:58 <lambdabot>  lexical error in string/character literal
11:30:04 <basbom> i don't want the \
11:30:33 <basbom> > ""hello""
11:30:34 <lambdabot>  Not in scope: `hello'
11:30:51 <basbom> > '"hello"'
11:30:51 <lambdabot>  lexical error in string/character literal
11:31:34 <sieni> > http://62.75.240.12/~peliserverit/corded/
11:31:34 <lambdabot>  parse error on input `}'
11:31:38 <sieni> oops
11:31:47 <sieni> > do putStrLn "hello\"";
11:31:48 <lambdabot> No IO allowed
11:31:53 <sieni> ahh
11:32:25 <astrolabe_> I don't know why it's leaving the \
11:32:41 <astrolabe_> > '\"'
11:32:42 <lambdabot> '"'
11:32:56 <sieni> astrolabe_: probably, because it outputs the string in a format that can be read back in?
11:33:23 <sieni> > map (\x -> [x]) "Hello\""
11:33:24 <astrolabe_> >length "hello\""
11:33:39 <lambdabot> plugs module failed: thread killed
11:33:46 <astrolabe_> We've confused it
11:34:22 <astrolabe_> >length "hello\""
11:34:33 <astrolabe_> Ah, it was me :(
11:34:59 <sieni> map (\x -> [x]) "Hello\""
11:36:00 <flux__> > 0
11:36:01 <lambdabot> 0
11:36:06 <flux__> it's alive!
11:36:11 <sieni> > map (\x -> [x]) "Hello\""
11:36:12 <lambdabot> ["H","e","l","l","o","\""]
11:37:11 <astrolabe_> I don't understand
11:37:38 <basbom> i think that char can only be printed as \"
11:37:45 <sieni> astrolabe_: What part you don't understand?
11:37:53 <basbom> but on the screen it will be ok
11:38:47 <astrolabe_> I don't understand why I broke l
11:39:01 <astrolabe_> and I don't understand 10lambdabot: 01["H","e","l","l","o","\""]
11:39:03 <flux__> > map (\x -> (x, 0)) "Hello\""
11:39:04 <lambdabot> [('H',0),('e',0),('l',0),('l',0),('o',0),('"',0)]
11:39:07 <Lemmih> @vixen Are you broken?
11:39:08 <lambdabot> yes
11:39:12 <Lemmih> oh ):
11:39:28 <jethr0_> > zip "Hello\"" [0,0..]
11:39:29 <lambdabot> [('H',0),('e',0),('l',0),('l',0),('o',0),('"',0)]
11:41:56 <sieni> > "'"
11:41:57 <lambdabot> "'"
11:42:17 <sieni> > map (\x -> (x,0)) "'"
11:42:18 <lambdabot> [('\'',0)]
11:49:08 <Saulzar> > [['H'], ['e'], ['l'], ['l'], ['l'], ['o']]
11:49:09 <lambdabot> ["H","e","l","l","l","o"]
11:50:47 <araujo> > map (: []) "Hello"
11:50:48 <lambdabot> ["H","e","l","l","o"]
11:51:33 <Saulzar> Heh, Prelude> show "Foobar \"" 
11:51:35 <Saulzar> "\"Foobar \\\"\""
11:52:03 <resiak> It's been done...
11:52:08 <resiak> > iterate show "foo"
11:52:09 <lambdabot> ["foo","\"foo\"","\"\\\"foo\\\"\"","\"\\\"\\\\\\\"foo\\\\\\\"\\\"\"","\"\\
11:52:09 <lambdabot> \"\\\\\\\"\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\
11:52:09 <lambdabot> \"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\
11:52:09 <lambdabot> \\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"
11:52:09 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:52:11 <lambdabot> [23 @more lines]
11:52:51 <resiak> :-)
11:57:18 <Saulzar> > take 10 $ map length $ iterate show "foo"
11:57:19 <lambdabot> [3,5,9,17,33,65,129,257,513,1025]
11:58:12 <syntaxfree> > take 10 $ map (\x->2^x+1) [1..]
11:58:13 <lambdabot> [3,5,9,17,33,65,129,257,513,1025]
11:58:17 <joelr1> allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
11:58:17 <joelr1> allocaBytes (I# size) action = IO $ \ s ->
11:58:27 <joelr1> what does the \s -> mean?
11:58:56 <joelr1> is that an alternative to the do notation?
11:59:09 <Saulzar> It's constructing an IO action directly...
11:59:28 <joelr1> Saulzar: same as do ... no?
11:59:40 <joelr1> except lazily
11:59:42 <joelr1> correct?
12:01:34 <Saulzar> Not sure. Presumably you can create primitive IO actions this way
12:05:58 <Lemmih> '\s -> ..' is just a lambda function.
12:06:29 <joelr1> Lemmih: i'm not dumb, it's just the first time i see the IO $ \ x -> combination
12:06:43 <xerox> they're the internals, in the end
12:06:51 <joelr1> my hunch is that using the do notation here would make it strict or something
12:07:01 <joelr1> whereas returning the lambda makes it lazy
12:07:04 <joelr1> dunno
12:07:05 <xerox> @index IO
12:07:05 <lambdabot> System.IO, Prelude
12:07:14 <xerox> @kind System.IO.IO
12:07:15 <lambdabot> * -> *
12:07:27 <Lemmih> joelr1: No. The author has just unrolled the function for performance reasons.
12:07:47 <joelr1> Lemmih: unrolled from?
12:09:01 <Lemmih> A function using do or >>=.
12:09:23 <joelr1> Lemmih: but how does making it into IO $ \s -> make it faster?
12:09:53 <int-e> the compiler has more opportunities to do inlining and stuff
12:10:14 <joelr1> that's some rocket science
12:10:24 <Lemmih> joelr1: It's called inlining.
12:10:35 * joelr1 is converting pickling from MutByteArray to Ptr Word8
12:10:47 <joelr1> Lemmih: i see
12:12:33 <resiak> Out of interest, why does a lambda allow more optimizations than a function, given that surely the two are functionally and semantically identical and so could be optimized in the same way? (I will confess that I know very little about the workings of compilers.)
12:12:40 <musasabi> Is there really no "hGetNBytes :: Handle -> Int -> IO String" ?
12:13:35 <Lemmih> @hoogle Handle -> Int -> IO String
12:13:36 <lambdabot> System.IO.hShow :: Handle -> IO String
12:13:36 <lambdabot> System.IO.hGetLine :: Handle -> IO String
12:13:36 <lambdabot> System.IO.hGetContents :: Handle -> IO String
12:14:44 <int-e> resiak: the point is that the function is defined in another module (thus compiled separately) and probably has a noinline annotation.
12:15:07 <resiak> int-e: AH, that makes sense. Thank you. :)
12:15:10 <int-e> resiak: (I didn't check that though)
12:15:21 <resiak> int-e: Sure, but I should have thought of that. Cheers.
12:15:24 <int-e> resiak: I mean the annotation.
12:15:45 <resiak> int-e: yep.
12:16:20 <Lemmih> @type let hGetNBytes h n = Foreign.allocaBytes n $ \ptr -> do l <- System.IO.hGetBuf h ptr n; Foreign.C.peekCStringLen (ptr,l) in hGetNBytes
12:16:21 <lambdabot> GHC.IOBase.Handle -> Int -> IO String
12:17:58 <Lemmih> @pl hGetNBytes h n = Foreign.allocaBytes n $ \ptr -> System.IO.hGetBuf h ptr n >>= \l -> Foreign.C.peekCStringLen (ptr,l)
12:18:00 <lambdabot> hGetNBytes = liftM2 (Foreign .) allocaBytes . flip flip (((((Foreign . C)
12:18:00 <lambdabot> .) . peekCStringLen) .) . (,)) . (liftM2 ((>>=) . ((System . IO) .)) .) .
12:18:00 <lambdabot> flip . hGetBuf
12:18:17 <Lemmih> Bah.
12:18:19 <int-e> @type flip flip
12:18:20 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
12:18:47 <Lemmih> lambdabot: Foreign.C is /not/ 'Foreign . C'
12:19:44 <int-e> @pl hGetNBytes h n = Foreign_allocaBytes n $ \ptr -> System_IO_hGetBuf h ptr n >>= \l -> Foreign_C_peekCStringLen (ptr,l)
12:19:45 <lambdabot> hGetNBytes = ap Foreign_allocaBytes . flip flip ((Foreign_C_peekCStringLen
12:19:45 <lambdabot> .) . (,)) . (liftM2 (>>=) .) . flip . System_IO_hGetBuf
12:26:39 <joelr1> musasabi: what did you say the memcopy function was called?
12:27:16 <joelr1> copyBytes/moveBytes?
12:32:27 <musasabi> joelr1: it is called foreign import ccall unsafe "memcpy" memcpy :: Ptr () -> Ptr () -> Int -> IO ()
12:32:48 <musasabi> joelr1: you could just look at SerTH sources, that is BSD3 licensed
12:33:44 <xerox> g'nite
12:34:52 <joelr1> musasabi: i suspect copyBytes/moveBytes do the same. did you look at Foreign.Marshal.Utils?
12:35:58 <joelr1> musasabi: does it allow commercial use? (don't have the BSD3 license handy)
12:36:31 <musasabi> joelr1: yes, it allows commercial use.
12:37:09 <musasabi> copyBytes is more or less the same
12:37:11 <joelr1> musasabi: does it do cycle detection or something like that? i think krasimir said it was slow because of that
12:37:39 <musasabi> joelr1: krasimir also contributed a version without cycle detection
12:37:43 <syntaxfree> @pl f a x = elem x (upto a)
12:37:43 <lambdabot> f = flip elem . upto
12:37:57 <syntaxfree> @pl f x a = elem x (upto a)
12:37:58 <lambdabot> f = (. upto) . elem
12:38:05 <joelr1> musasabi: is that incorporated /without/?
12:38:29 <joelr1> musasabi: i'm considering switching. my serializations sucks unless i convert it to Ptr Word8
12:39:09 <joelr1> then again, i think i'm stuck. i have 250+ records (constructors) and 30-40 nested sub-record
12:39:12 <joelr1> s
12:39:27 <syntaxfree> @type flip
12:39:28 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
12:39:40 <syntaxfree> @type flip elem
12:39:41 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
12:41:27 <musasabi> joelr1: Well you can use SerTH code or if you like I have other code that is 0.5-2 * acyclic SerTH performance depending on the data. (344 lines)
12:41:30 <syntaxfree> @pl map findAll a x = map find [1..x]
12:41:30 <lambdabot> map = fix (const . const . (. enumFromTo 1) . ($ find))
12:41:41 <syntaxfree> @pl map findAll x a = map find [1..x]
12:41:41 <lambdabot> map = fix (const . (const .) . (. enumFromTo 1) . ($ find))
12:42:00 <joelr1> musasabi: i think i'll just convert my own to ptr. did that once before, don't know why i switched to arrays :(
12:42:16 <joelr1> but thanks for the offer!
12:42:20 <syntaxfree> @pl map findAll a x = map find a [1..x]
12:42:20 <lambdabot> map = fix (const . flip flip (enumFromTo 1) . ((.) .) . ($ find))
12:43:33 <musasabi> joelr1: http://cs.helsinki.fi/u/ekarttun/haskell/binser.tar.gz if you want ideas. (That is extremely short and quite fast)
12:43:45 <joelr1> musasabi: thanks!
12:43:53 <musasabi> joelr1: BSD3 - i.e. you may use it in commercial projects.
12:44:17 <syntaxfree> hey.
12:44:59 <syntaxfree> isn't findAll  = (map find a) . (enumFromTo 1)  equivalent to  findAll a x = map find a [1..x]
12:45:07 <syntaxfree> @pl 's version is strange.
12:45:07 <lambdabot> (line 1, column 1):
12:45:07 <lambdabot> unexpected "'"
12:45:07 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
12:45:07 <lambdabot> expression
12:48:01 <int-e> syntaxfree: it should be 'findAll a = ...'
12:48:31 <int-e> syntaxfree: and I suppose you want map (find a) instead of map find a
12:48:53 <syntaxfree> ah, I see. I forgot to take the "a" out.
12:49:08 <int-e> err, or that. yes
12:50:50 <syntaxfree> @pl findAll a = flip (.) (enumFromTo 1) (map (find a))
12:50:51 <lambdabot> findAll = (. enumFromTo 1) . map . find
12:51:17 <syntaxfree> simple. of course.
12:51:22 <syntaxfree> I don't really need to flip (.)
12:51:38 <int-e> well. (. foo) is flip (.) foo
12:52:34 <syntaxfree> @pl upto a  = filter (/=0) . concat . take a . levels . invTree 1
12:52:35 <lambdabot> upto = ((filter (0 /=) . join) .) . (. (levels . invTree 1)) . take
12:52:45 <syntaxfree> now there's something.
12:52:48 <syntaxfree> @type join
12:52:49 <lambdabot> Not in scope: `join'
12:52:54 <syntaxfree> @hoogle join
12:52:54 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
12:52:54 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
12:52:54 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
12:53:15 <syntaxfree> leave that for a while :)
12:58:21 <mjl69> to make it clear that a function parameter is a function, it looks like you need brackets that can't be removed by right association in the type definition.
12:58:32 <mjl69> @type foldr1
12:58:33 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:59:17 <mjl69> 1st arg is definitely a function
12:59:42 <Lemmih> I don't understand the question.
12:59:46 <mjl69> @type (.)
12:59:47 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
13:00:23 <mjl69> also clearly requires 2 functions as args
13:01:16 <mjl69> so foldr1 (.) xs, xs must be a list of functions, right?
13:01:32 <Lemmih> @type foldr1 (.)
13:01:33 <lambdabot> forall c. [c -> c] -> c -> c
13:02:59 <Lemmih> > foldr1 (.) [succ, pred, succ, (*)2] 10
13:03:00 <lambdabot> 21
13:03:47 <int-e> @djinn [c->c]->c->c
13:03:47 <lambdabot> f _ a = a
13:04:40 <Saulzar> @djinn [a->b]->[b->a]->a->b
13:04:41 <lambdabot> -- f cannot be realized.
13:04:50 <mjl69> so it reduces a list of functions to a single function?
13:05:08 <Saulzar> @djinn (a->b)->(b->a)->a->b
13:05:09 <lambdabot> f a _ b = a b
13:05:19 <mjl69> so if foldr1 (.) comes before a list comprehension...
13:06:16 <Lemmih> > foldr1 (.) [ (*) n | n <- [1..3]] 10
13:06:17 <lambdabot> 60
13:07:27 <mjl69> Lemmih: so a list comprehension is considered to be a list of functions? is there a general type for all list comprehensions?
13:07:43 <mjl69> I mean what it reduces to
13:08:00 <mjl69> [a->a]?
13:08:02 <Lemmih> Well, [a].
13:08:55 <resiak> where a is the type of the thing before the | ?
13:09:15 <Lemmih> Yeah.
13:09:21 <resiak> Makes sense.
13:09:33 <mjl69> oh, that's it
13:14:48 <mjl69> [1*,2*,3*] => (1*(2*(3*)))10
13:15:29 <mjl69> so everything before the ten is like the kind of function generated by (*) to handle the second arg.
13:16:10 <franka> 'lo.
13:18:05 <mjl69> thanks Lemmih and resiak, the type of the LC list members was the missing thing in my understanding here.
13:19:38 <mjl69> so if the front thing is a function that takes two args and you give it one, you generate a list of anonymous functions waiting for that second arg.
13:22:05 <franka> Yes.
13:22:13 * franka looks at log.
13:24:38 <mjl69> franka, thanks for checking 
13:25:00 <mjl69> things like this get thrown into 'easy' tutorials with little or no explanation for what is really happening.
13:25:54 <franka> Well, if you know what currying is, and you know what list comprehensions are, then you just put two and two together.
13:26:55 <mjl69> are you the author of the 12 q&a lessons? :)
13:27:05 <franka> No.
13:27:06 <PupenoL> Anyone familiar with dh_haskell ? I am getting the error "sed: -e expression #1, char 82: unterminated `s' command"
13:27:30 <mjl69> just kidding
13:28:45 <mjl69> it was the matter of typing the elements of the generated list that I have not seen documented anywhere yet.  everything fell into place from there
13:29:37 <franka> If you understand the semantics of list comprehensions, you can derive the typing rule yourself.
13:30:00 <franka> I'm not criticizing, mind you; it's just an observation.
13:37:04 <shapr> hiya franka 
13:37:56 <franka> Heya, shapr.
13:46:49 <mjl69> no problem.  now I try to keep multiple tutorials and references open at once in Firefox tabs.  thanks!
14:02:37 <snk_kid_uncurry> ahoy hoy
14:03:26 * Philippa rolls behind snk_kid_uncurry and sets off an SDM
14:03:54 <snk_kid_uncurry> what is exactly is a discriminating hacker anyways?
14:04:10 <dons> one with taste
14:04:11 <Philippa> one who discriminates between good tools and bad
14:04:14 <Philippa> exactly
14:04:40 <snk_kid_uncurry> fair enough :P
14:06:24 <Philippa> anyway, did I get the right SNK, or does your nick refer to something else?
14:06:59 <snk_kid_uncurry> oh yeah, i've only just clicked on ;)
14:09:58 * Philippa didn't start playing SNK's stuff until fairly recently. Bit of a shame, that
14:11:01 <musasabi> good connotations associated with discriminating does not seem very common
14:11:16 <Philippa> discerning might be a better choice of word now
14:11:35 <Philippa> I've even had to smack down idiots who think you're not supposed to discriminate on any basis at all...
14:12:21 * Oejet quickly begins discriminating out of fear for Philippa.
14:12:24 <musasabi> just force them to use cobol for a few months
14:12:33 <cjb> The common definition if discriminate is something like "take action based on a prejudice".
14:12:43 <Philippa> cjb: the now-common definition is...
14:13:02 <cjb> Why would I be talking about a past-common definition?  :)
14:13:15 <Philippa> but that's because the original argument went "you're not supposed to discriminate on grounds of race/sex/<insert -ism here>"
14:13:20 <musasabi> because past-common definitions are in dictionaries
14:13:29 <Philippa> because past-common definitions are still in current use
14:14:12 <cjb> Of course, I understand that this wasn't always the case.  But I think not accepting the now-common meaning is misguided, just as not accepting the dictionary definition would be.
14:14:26 <Philippa> not accepting the now-common meaning as /one/ meaning is, sure
14:15:33 <Philippa> it's a shame that so many people are actually unaware of the previously-most-common meaning
14:16:11 <Philippa> or to put it another way, that the connotations it gained because of its use in explaining the damage caused by prejudice have made it difficult to use the previous meaning without said connotations
14:16:25 <cjb> Okay.
14:18:00 <jethr0_> "discriminate between" two things has 1.9M hits on google. so "discriminate" isn't all about racism, anyways
14:20:05 <Oejet> "discriminate against" has 4.5M hits on Google. :)
14:21:08 <Lemmih>  
14:22:45 <franka> The case-expression is also called case-discrimination.
14:23:03 <franka> It is too close to race discrimination for my sensitive sensibilities!!!
14:23:47 <franka> Oops, I mean "delicate".
14:23:48 <Oejet> Heh, I tried real hard to misread it as race, but I didn't succeed.
14:23:54 <franka> Try harder.
14:24:16 <franka> You are on the #git channel.
14:24:31 <franka> Isn't that a bit self-deprecating?
14:24:47 <jethr0_> not if linus is too :)
14:25:16 <franka> Linus Torvalds can eat my shorts.
14:25:55 <jethr0_> have you just sullied our collective icon?
14:25:58 <franka> What is the #git channel anyway?
14:26:07 <franka> Not my icon.
14:26:12 <jethr0_> just joking
14:26:36 <jethr0_> my guess would be that it's dedicated to linus' bitkeeper "replacement"
14:27:40 <franka> Is it shaping up?
14:28:29 <jethr0_> haven't used it. and i'm pretty sure it has none of the niceties of BK, but i guess they've been using it for months now
14:28:50 <franka> It's very quiet on #git.
14:29:00 <jethr0_> i can imagine
14:29:22 <franka> Linus must be hacking elsewhere.
14:29:42 <franka> Isn't it great how we are all on a first name basis with this icon?
14:29:54 <jethr0_> i think he just wrote it in a day or two and then left it alone. but for any more detail, you'd have to ask someone the actual channel :)
14:30:23 <jethr0_> it's because noone knows how to write his last name...
14:31:28 <franka> I saw a film with a Finlander named Torvalds.  He was a spy.
14:31:37 <franka> I mean, the character was called Torvalds.
14:31:41 <jethr0_> that must have some deeper meaning
14:32:28 <jethr0_> what were you doing on the git channel anyways? is the word "git" actually known outside of the UK?
14:33:05 <dons> it's well known in .au. don't be a git ;)
14:33:27 <jethr0_> ah, ok, i didn't think of the "former" colonies :)
14:33:43 <jethr0_> but i meant the US... nobody would understand it there, right?
14:33:59 <franka> Yes, the deeper meaning is that the scriptwriter couldn't think of any Finnish people besides Linus Torvalds..
14:34:01 <Heffalump> I'm sure Linus did..
14:34:02 <dons> I seem to recall that the US was a colony..
14:34:13 <jethr0_> but longer ago
14:34:20 <Heffalump> yeah, we sent our religious nutters there and the convicts to .au
14:34:29 <franka> Americans understand the word "git"; they just don't use it..
14:34:31 <Heffalump> thus leaving the UK as a nation of sane, well-balanced people
14:34:32 <jethr0_> hehe, don't discriminate!
14:34:43 <dons> hehe
14:34:59 <Philippa> and we kept all the good beer to ourselves ;-)
14:35:08 <Philippa> (not that I imagine any national exports of ours're any good either)
14:35:26 <franka> This discussion belongs on #haskell-blah.
14:35:28 <jethr0_> well, the convicts did a _much_ better job of finding their way to legality than the "rel. nutters" did
14:35:32 <dons> fortunately, all the sick and ill temperted died on the boats, leaving only a super-fit gene pool 
14:35:52 <jethr0_> (towards separation of church and state)*
14:36:12 <jethr0_> who's ever died of an ill temper?
14:36:32 <dons> well, if you had an ill temper, that would be 100 lashes for you!
14:36:45 <dons> ye scurvy dog
14:36:47 <jethr0_> and for a mild temper?
14:37:39 <musasabi> 50?
14:38:07 <musasabi> since lashing is fun even when there is no reason
14:38:08 <dons> I think they just chained you up below deck for 3 months
14:38:16 <dons> musasabi, very true.
14:38:59 <jethr0_> i think i would've opted out of the chaining part
14:39:39 <franka> "Ensign, nail that man's foot to the deck!"
14:40:13 <franka> Ship society is no democracy.
14:40:33 <Philippa> some pirate vessels were pretty close
14:40:42 <franka> My English is very odd tonight...
14:41:11 <franka> Mm, I have heard some things about Chinese pirates...
14:41:46 <Oejet> franka: Git 1.0 is done in a couple of days.
14:42:02 <franka> Was amazed to learn there was a female pirate boss.
14:42:18 <franka> Oejet: Cool.
14:42:34 <Philippa> actually that doesn't surprise me at all
14:42:36 <franka> Oejet: Not that I actually know anything about Git..
14:42:50 <franka> In Chinese society???
14:43:00 <Philippa> once you recognise that direct shows of strength aren't the only way to resolve conflicts, it makes a lot of sense
14:43:12 <Philippa> She'd have been pretty damn tough
14:44:41 <franka> The problem with women is... they have too much power in our society.
14:44:49 <Philippa> er, yerwhat?
14:44:53 <franka> We men are all helpless before them..
14:45:12 <Philippa> bullshit, you're still getting more pay, better positions and better jobs
14:45:31 <franka> Yeah, on the surface, you would like us to believe that.
14:45:39 <franka> It is all part of your insidious plans.
14:45:58 <Philippa> I'm still having to deal with rabid sexism elsewhere, I may not be in the mood for this
14:46:21 <franka> heh, OK.  Just stirring things up. :)
14:46:41 <Oejet> franka, that's a girls name, isn't it?
14:47:08 <franka> In my case, "franka" is short for "Frank A."
14:47:17 <Oejet> Oh.
14:47:17 <franka> So, no.
14:47:56 <franka> Philippa: You didn't take me seriously, did you?
14:48:19 <Philippa> franka: not entirely
14:48:51 <Philippa> but... well, one of the problems with any -ism is it's a lot easier for one side to accept the other's joking than vice versa
14:49:29 <franka> I don't see us as being on different sides, Philippa.
14:50:17 <franka> Especially considering at the moment i am listening to Bananarama - Robert De Niro's Waiting.
14:50:21 <musasabi> gender roles make life difficult for both men and women.
14:50:32 <snk_kid_uncurry> i read that GHC had a fork with speculative evaluation but i can't find it anyway, anyone have a link to it?
14:50:34 <Philippa> yes, that's true
14:50:43 <Philippa> there's still such a thing as 'male priviledge' though
14:50:50 <dons> snk_kid_uncurry, that's the spec-eval branch of ghc
14:51:11 <dons> check out Robert Ennal's papers.
14:51:15 <snk_kid_uncurry> dons: is it still active and is there a link to it ;)
14:51:18 <franka> And female privilege.
14:51:32 <dons> it's not still active
14:51:49 <Philippa> yes. But the latter doesn't outweigh the former by any means
14:51:54 <dons> google should turn up a link ;)
14:52:05 <franka> Depends on how you weight it.
14:52:09 <musasabi> Philippa: well that also depends on the person.
14:52:22 <franka> Though I think males have the dominant role in society still.
14:52:29 <Philippa> musasabi: it doesn't work on an individual level though, that's the thing
14:52:38 <snk_kid_uncurry> dons: i've briefly struggled with google looking but thanks for the heads up anyways ;)
14:53:41 <Philippa> franka: substantially so. The only thing I can think of for female privilege that isn't a mirror of an equivalent piece of male privilege is the tendency for custody to go to the mother coupled with sometimes rabid child protection agencies
14:54:18 <Philippa> the male priveleges tend to extend to the areas where legal, economic and similar magnitude decisions are made, too
14:54:30 <franka> Mirror of an equivalent privilege?  Hm, never thought about it, but you might have something there.
14:55:03 <franka> I was thinking about how males tend to compete with the threat of violence.
14:55:09 <Philippa> men won't get blamed for a messy house as much because the women are "supposed" to do the cleaning, women get blamed less for a too-small house because men are "supposed" to be the breadwinners
14:55:29 <Philippa> that's also an issue, but not as much alone as in combination with a largely male-run legal system
14:55:48 <Philippa> it's taken a long time for the law to get any good at dealing with domestic abuse, and it's got a long way to go
14:55:59 <Philippa> (not that women are never the abusers, I know of cases where it's happened to friends)
14:56:11 <musasabi> males are supposed to 1) to be men (army, sports, cars etc), 2) het, 3) be the side to earn money etc, 4) be in charge, and many more sickening things.
14:56:30 <Philippa> everybody's supposed to be het. Though yeah, guys're more scared of each other in that regard so that's worse
14:56:35 <franka> You really ought to watch "Naked".  I am curious what you would think now..
14:56:47 <Philippa> OTOH, non-het women are "expected" to be there for men's pleasure still thanks to the dear "adult entertainment" industry
14:57:02 <Philippa> (and that's not half as nasty to its guys on average as it is to the women)
14:57:12 <musasabi> at least here it seems that for women L/B is quite acceptable, but for men it is quite non-acceptable.
14:57:42 <jethr0_> L/B? het?
14:57:48 <musasabi> to the extent of violence.
14:57:51 <Philippa> it seems to be as much campness that's unacceptable for guys as the sexuality per se
14:57:54 <franka> Hm, yeah.  I remember when I mentioned to some friends once that this girl who liked me was bi.  And the both said (in unison!), "Threesome!"
14:57:57 <musasabi> lesbian, bi-sexual, heterosexual
14:58:18 <franka> I was really surprised 'cause it hadn't even occurred to me.
14:58:42 <musasabi> but maybe we should go back to -blah
14:59:22 <Philippa> the only time it's really occurred to me, I was close friends with one girl and falling in love with another and they both liked each other - it still wasn't going to happen though, and the fact it wasn't going to happen also meant it didn't appeal really because it wouldn't work on an emotional level
15:00:08 <franka> I think among many males there is an equivalence bi = poly.
15:00:16 <franka> If the bi is female.
15:00:31 <franka> Dunno what they think about bi guys.
15:00:33 <Philippa> yeah. Well, anyway, but there's more /hope/ if they're female
15:00:49 <franka> heh, Interesting choice of words.
15:01:11 <franka> Implying those guys are all desperate.
15:01:53 <Philippa> for a threesome, yeah
15:02:07 <franka> I'm not sure about that.
15:02:25 <Philippa> to clarify: for an FFM threesome. Or maybe just to watch and enjoy.
15:02:27 <franka> In general, perhaps.
15:02:28 <musasabi> well if there is a large group of desperate bi-sexual men, then very soon the group of desperate ones will be much smaller ;)
15:02:50 <franka> musasabi: No, desperate het guys.
15:03:08 <musasabi> yep.
15:03:17 <Philippa> desperation gives you a lot of time to fantasise in
15:03:31 <franka> Don't I know it! :)
15:04:19 <franka> But, yeah, in a way, that's my point.
15:04:43 <franka> To them bi = loose because that is the only thing they see in their fantasies.
15:05:02 <Philippa> that, and in fairness because also queernesses tend to clump together
15:05:10 <franka> Yes.
15:05:25 * Philippa needs a pair of t-shirts - "bi poly switch - not indecisive, just greedy" and "bi poly switch - and I still don't want to sleep with you"
15:05:37 <Philippa> or maybe both slogans, the greedy one on the front and the don't wanna on the back
15:05:56 <franka> The latter may cut down on your success rate.
15:06:17 <franka> Hell, I would never wear a shirt, "I won't sleep with you."  heh
15:06:45 <franka> Why tempt fate?
15:06:55 <franka> Fate
15:06:57 <musasabi> franka: well then you can tell them that you do an exception just for them.
15:07:04 <musasabi> makes them feel special etc
15:07:07 <franka> Bah.
15:07:14 <franka> Pretentious..
15:07:29 <franka> Oh shit, this is being logged.
15:07:52 <Philippa> heh
15:08:21 <Philippa> your supervisor has a problem with mansluts or something? :-)
15:08:26 * Oejet greps for that line in the logs.  :)
15:08:46 <franka> Nah..
15:09:08 <franka> AFAIK, my supervisor is pretty laid back.
15:09:17 <franka> Besides I am not a slut by any means.
15:09:54 <franka> @bot
15:09:54 <lambdabot> :)
15:10:03 <franka> Hm.
15:11:08 <franka> @quote franka Besides I am not a slut by any means.
15:11:08 <lambdabot> franka Besides I am not a slut by any means. hasn't said anything
15:11:08 <lambdabot> memorable
15:11:18 <franka> Crap.
15:13:15 <franka> @quote-add franka Besides I am not a slut by any means.
15:13:16 <lambdabot> Unknown command, try @listcommands.
15:13:23 <franka> Geez.
15:13:53 <jethr0_> @quote franka
15:13:53 <lambdabot>  " I don't like it if it's too hard"
15:13:59 <jethr0_> HAHA
15:14:08 * franka rolls eyes.
15:19:54 <jethr0_> @quote franka
15:19:55 <lambdabot>  " I don't like it if it's too hard"
15:19:57 <jethr0_> @quote franka
15:19:58 <lambdabot>  " I don't like it if it's too hard"
15:20:02 <jethr0_> *damn*
15:21:39 <franka> quote is not listed on listcommands.
15:21:39 <franka> And neither is quote-add.
15:30:37 <jethr0_> i think it might be quote+
15:31:53 <franka> @quote+ franka Besides I am not a slut by any means.
15:31:54 <lambdabot> franka Besides I am not a slut by any means. hasn't said anything
15:31:54 <lambdabot> memorable
15:32:11 <franka> Nope.
15:32:58 <dons> I'll remove it from the logs for you.
15:33:17 <dons> s/logs/quote state/
15:33:47 <franka> Eh??
15:37:58 <franka> Was that a joke?
15:38:00 <franka> dons
15:38:03 <jethr0_> addquote?
15:45:02 <franka> Forget it.
15:45:58 * shapr yawns
16:01:20 <jethr0_> i hate it when the channel goes this quiet
16:01:38 <jethr0_> and btw, meta-meta-programming is more mind-bending than you might think :)
16:02:15 <franka> Why?
16:02:32 <jethr0_> why what?
16:03:22 <musasabi> jethr0_: you should come to #haskell-blah, where we are active
16:03:28 <jethr0_> :)
16:03:38 <franka> Why do you say it is so mind-bending?
16:04:15 <musasabi> M-x doctor?
16:04:39 <jethr0_> well passing types as values and deciding to act upon them in the next lower level is pretty much as abstract as i can think :)
16:06:17 <Philippa> you've not tried building a category-of-languages and working to build languages within it (which are also categories) and using that to write actual code?
16:06:29 <Philippa> (at least theoretically - never done it for real as of yet)
16:07:01 <jethr0_> hehe, no, i'm writing a program to auto-generate a tree-walker for the haskell AST to use for my AOP thingey
16:07:14 <jethr0_> but by the looks of it, that's one abstraction too many for me :)
16:08:39 <jethr0_> i have a function that gets a name and its type. if the the type is (Maybe + T) then i generate code to "fmap myfunc name"
16:08:54 <jethr0_> but i'm not moving forward as fast as i'd like to ^_^
16:10:34 <franka> The problem with metaprogramming is that it is too syntax-oriented.
16:10:58 <jethr0_> hmm, there are people who say the same about haskell *g*
16:10:59 <franka> Instead of building language phrases, we should be building semantic objects.
16:11:57 <jethr0_> i'm not sure i can follow you
16:12:38 <franka> When you transform syntax, you are not preserving equalities between the phrases.
16:12:38 <jethr0_> isn't an abstract syntax tree already a semi-semantic object? how would you annotate semantics?
16:12:56 <franka> Everything is a "semi-semantic" object.
16:13:04 <jethr0_> obviously, that's why it's called "transforming"
16:13:13 <Philippa> a better question would be: "what does a semantic object look like?"
16:13:23 <jethr0_> yes, but ASTs are already _way_ better than text-only-macros
16:13:24 <franka> The point is that if you have a function that takes, say, (\x.x) to y, then it should also take the identifier id to y..
16:13:29 <jethr0_> that's what i meant
16:13:42 <jethr0_> hmm
16:14:01 <jethr0_> franka: you might be able to do that if you had a uniquely defined normal form
16:14:08 <franka> Yes.
16:14:27 <franka> But then you have to reduce an entire program, and you can only reduce closed terms.
16:14:53 <franka> And it's inefficient, since the normal form may be hyperexponetially larger than the original term.
16:15:14 <jethr0_> yup
16:15:59 <franka> The first issue to tackle is higher-order syntax.
16:16:19 <franka> Then you have to deal with semantic equalities like beta-equivalence.
16:16:46 <franka> And then issues like type equivalence.
16:17:25 <jethr0_> i guess language like extended lambda calculus make this kind of thing much easier than complex ones like haskell
16:17:25 <Philippa> and then the halting problem for an encore ;-)
16:17:35 <Philippa> Haskell *is* an extended lambda calculus
16:17:57 <Philippa> just one with a lot of sugar
16:18:03 <jethr0_> hmm, ok, but with a few exceptions (like evaluationg IO objects, ...)
16:18:15 <jethr0_> or is that done "outside" of haskell?
16:18:19 <Philippa> bingo
16:18:29 <Philippa> that's what the RTS does with programs, if you like
16:18:36 <jethr0_> well, but it strongly affects the whole-program semantics
16:18:36 <Cale> evaluating IO actions is inside Haskell, executing them is outside
16:18:38 <Philippa> you can think of the RTS as an "IO interpreter"
16:18:58 <jethr0_> you will want to argue about side-effects too, i guess
16:19:05 <jethr0_> yes, that's how i pictured it
16:19:10 <Philippa> plenty of impure lambda calculi out there
16:19:22 <jethr0_> ok
16:20:24 <franka> Part of the problem there is that I/O is implementation-defined..
16:20:35 <franka> No one has an abstract semantics of Unix file I/O, for example.
16:20:54 <franka> So there is no good way to reason about it.
16:20:59 <Philippa> it kinda has to be, in one way
16:21:07 <Philippa> you can't reason about an asteroid hitting your substrate system
16:21:33 <Philippa> except in terms of "so what's the range of potential fuckups in response to that, how can the system attempt to indicate the resulting degradation, etc etc"
16:22:07 <franka> Sure, but you can come up with a semantics which is based on the premise that the system is operating properly.
16:22:23 <Philippa> yeah. That's not necessarily sufficient for every task though
16:22:30 <franka> Which is the case 99.9% of the time.
16:22:34 <Philippa> (I agree such a semantics is useful to have either way)
16:22:56 <musasabi> Time is usually important and quite hard to include in abstract semantics.
16:22:59 <franka> Well, nothing is sufficient for every task... certainly the alternatives aren't.
16:24:02 <franka> You can obtain asymptotic bounds in certain systems...
16:27:16 <Philippa> that's true and useful
16:29:22 <Philippa> in the failure handling scenario you really want some notion of probability of error to work with too, so that you can reason about whether a given design makes failure of the overall system more or less likely
16:30:18 <franka> Yeah, I think a big problem with current systems is that there is no way to quantify incorrectness.
16:32:15 <musasabi> well having a specification which IO calls are blocking would go a long way (of course that is impossible and blocking is not well-defined)
16:38:55 <palomer> we should add some Pi-calculus to haskell
16:39:10 <palomer> who's with me?
16:39:28 <shapr> What about join calculus?
16:39:35 <Spark> yawn
16:39:41 <palomer> what's the join calculus?
16:40:01 <Spark> its what chords are based on
16:40:19 <shapr> @google join calculus haskell joinhs
16:40:20 <lambdabot> http://www.haskell.org/tmrwiki/JoinHs
16:40:42 <palomer> anyways, with the Pi-calculus, we can deal with things like blocking
16:40:57 <Spark> in general though, the join calculus and hte pi calculus are too crippled for real-world message-passing algorithms
16:41:07 <Spark> and you dont need language support for message passing either
16:41:55 <Spark> of course condition variables are cripped as well but thats another matter
16:43:36 <jethr0_> pi calculus was with streams, right?
16:44:26 <palomer> err no
16:45:49 <jethr0_> damn, now i'll have to look that up too :)
16:46:43 <Spark> pi calculus has "channels"
16:46:52 <Spark> that you can create and send around the place
16:47:04 <Spark> as well as write to and receive from
16:47:10 <Spark> i think that pretty much sums it up
16:47:34 <Spark> annoyingly, it doesnt have a construct with a pi in it, unlike the lambda calculus
16:54:22 <Lokadin_> what does map do?
16:54:33 <Lokadin_> @map
16:54:34 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
16:54:38 <Lokadin_> :|
16:54:46 <musasabi> Lokadin_: apply a function to all list elements and return the resulting list.
16:54:54 <musasabi> map function [] = []
16:55:20 <musasabi> map function (element:rest) = (function element) : (map function rest)
16:56:05 <Lokadin_> :|
16:56:18 <Lokadin_> ummm
16:56:22 <musasabi> yes?
16:56:31 <Lokadin_> so what's it for?
16:56:58 <musasabi> > map (*3) [1..4]
16:56:59 <lambdabot> [3,6,9,12]
16:57:05 <jethr0> > map even [1..20]
16:57:06 <lambdabot> [False,True,False,True,False,True,False,True,False,True,False,True,False,
16:57:06 <lambdabot> True,False,True,False,True,False,True]
16:57:09 <Lokadin_> o okay
16:57:13 <Lokadin_> thanks :D
16:57:18 <Lokadin_> i get ya
16:57:23 <shapr> If you have a function that operates on one input, map turns that into a function that operates on an entire list.
16:57:39 <Lokadin_> crazy
16:57:46 <shapr> It gets better.
16:57:51 <Lokadin_> haskell is mind boggling lol
16:57:57 <Lokadin_> makes me cry sometimes
16:58:00 <Lokadin_> lol
16:58:07 <Lokadin_> from frustration :(
16:58:08 <Lokadin_> lol
16:58:32 <shapr> If you have a function that puts two inputs together and gives one result, fold lets you use that function to boil a list down to a single result.
16:58:54 <shapr> > foldr1 (+) [1,1,1]
16:58:55 <lambdabot> 3
16:59:39 <jethr0> if you have a predicte (i.e. a function that produces True or False) you can select item from a list that satisfy this predicate
16:59:44 <jethr0> > filter even [1..20]
16:59:45 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
17:00:02 <Lokadin_> o
17:00:07 <Lokadin_> ok
17:00:10 <Lokadin_> hmmm
17:00:23 <shapr> If you want to see the steps that happen during a fold, you can use scan.
17:00:23 <Cale> http://vx.hn.org/autoshare/folds.png
17:00:26 <Lokadin_> well i was trying to figure out how to make map in cps
17:00:33 <Cale> have a look there :)
17:00:40 <shapr> > scanr1 (+) [1,1,1,1,1]
17:00:41 <lambdabot> [5,4,3,2,1]
17:00:48 <shapr> > scanl1 (+) [1,1,1,1,1]
17:00:49 <lambdabot> [1,2,3,4,5]
17:01:41 <shapr> The Haskell Prelude has a bunch of these combinators. I sometimes call them 'traversal essences' because they're the most basic ways to approach a problem.
17:01:51 <shapr> Cale discovered a new one recently.
17:01:51 <palomer> filter notSumOfTwoPrimes (filter even [4..])
17:03:18 <palomer> foldl1 isn't a very original name
17:03:19 <palomer> (nor insightful)
17:03:36 <Cale> It's good
17:03:41 <jethr0> i like it too
17:03:55 <dons> it folds, left, and needs 1 element. a good name.
17:03:55 <palomer> what does the 1 represent?
17:04:06 <shapr> > let swing f c a = (f ($ a)) c in swing map 1 [(+ 2),(+ 3)]
17:04:07 <dons> @type foldl1
17:04:07 <lambdabot>  add an instance declaration for (Num [[a -> a] -> b])
17:04:08 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
17:04:12 <dons> @type foldl
17:04:13 <jethr0> that it takes the list's first value as initial one
17:04:13 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:04:14 <shapr> Foo, how do I get swing to work interactively?
17:04:21 <Cale> the fact that the identity is taken care of
17:04:41 <palomer> > foldl (+) []
17:04:42 <lambdabot>  add an instance declaration for (Show ([[a]] -> [a]))
17:04:49 <palomer> > foldl (+) 1 []
17:04:50 <lambdabot> 1
17:04:57 <palomer> > foldl1 (+) []
17:04:58 <lambdabot> Exception: Prelude.foldl1: empty list
17:04:59 <Cale> I should make a diagram of the scans as well
17:05:12 <palomer> > foldl1 (+) [1]
17:05:13 <lambdabot> 1
17:05:24 <Cale> perhaps show the sharing when it exists
17:05:47 <dons> see, it's a good name. karma-- for saying a good name is bad ;)
17:06:06 <shapr> Adding a ' after the name tends to mean it's strict.
17:06:43 <palomer> it's _not_ a good name
17:06:45 <Cale> One thing about folds in Haskell is that for large inputs, using them to fold down to a small value is bad.
17:06:54 <Cale> palomer: oh?
17:07:10 <Lokadin_> can someone explain to me what continuation passing style means?
17:07:24 <Lokadin_> i mean how different can a map function be
17:07:32 <palomer> Lokadin: in CPS, a function never returns
17:08:03 <Lokadin_> ?
17:08:08 <Lokadin_> you mean it has no output?
17:08:08 <Cale> palomer: it eventually does
17:08:17 <Cale> that's a lie :)
17:08:29 <palomer> well a CPSified program never needs to return
17:08:37 <Cale> palomer: huh?
17:08:43 <Lokadin_> :|
17:08:52 <shapr> Lokadin_: with CPS the function to call with the result of the computation is one of the arguments.
17:08:54 <Cale> palomer: then what's the point of evaluating it?
17:09:14 <Lokadin_> okay well a normal map is: map f (x:xs) = f x : map f xs
17:09:18 <palomer> Cale: like anything, IO
17:09:27 <Cale> palomer: oh, with side effects
17:09:44 <Cale> yeah, I suppose if there were side effects to evaluation, sure
17:10:03 <palomer> Cale: well, no, you have primitive IO functions that take continuations as arguments
17:10:03 <Cale> (but there aren't :)
17:10:17 <Lokadin_> shapr: can you rephrase that?
17:10:25 <Cale> palomer: there are no IO functions :)
17:10:44 <Cale> (at this point, I'm just being difficult :)
17:11:39 <palomer> Cale: eh?
17:11:45 <Lokadin_> shapr: please? :$
17:12:10 <Cale> palomer: functions don't have side effects
17:12:27 <dons> hehe
17:12:44 <palomer> Cale: right, so you have this function getInput which takes a continuation and passes the input to that continuation
17:12:52 <palomer> how do you think the IO monad is implemented:O!
17:12:58 <Lokadin_> shapr: !!! :'(
17:12:58 <Cale> palomer: but that can't be a function :)
17:13:03 <palomer> why not?
17:13:15 <Cale> palomer: because it has a side effect
17:13:22 <jethr0> Lokadin_: may i be of service?
17:13:28 <palomer> it satisfies referential transparency
17:13:36 <palomer> Cale: so does the IO monad!
17:13:47 <Lokadin_> can someone rephrase what shapr what trying to say what was cps
17:13:55 <Lokadin_> jethr0: ? maybe you :)
17:14:02 <Lokadin_> cause i just don't understand
17:14:22 <Cale> Lokadin_: just that you pass in a function which will take the result
17:14:46 <Lokadin_> o
17:14:47 <Cale> addC a b f = f (a + b)
17:15:14 <bojohan> http://en.wikipedia.org/wiki/Continuation_passing_style
17:15:19 <Lokadin_> thanks
17:15:21 <jethr0> in cps you'd say "func1(cont, a, b, c) = cont (do something with a b c)" instead of "x = func1(a, b, c); func2(x)"
17:15:39 <Cale> it's called a "continuation" because it specifies how to "continue" evaluating. Even though here, it will be the first thing to get evaluated
17:15:50 <Lokadin_> jethr0: o
17:15:56 <Cale> I suppose that name has its origin in strict evaluation
17:16:50 <Lokadin_> hmm kk well i'll have a lookt thanks :D
17:16:55 <jethr0> np
17:17:19 <Cale> palomer: I disagree.
17:17:35 <Cale> palomer: well, what's the type of getInput?
17:17:38 <Lokadin_> first like of wiki: Continuation passing style (CPS) is a term used within functional programming to describe a style of programming wherein functions never return
17:17:48 <Lokadin_> *shrugs*
17:17:52 <Cale> Yeah, I don't like that description :)
17:18:04 <Lokadin_> lol kk  jst wondering
17:18:10 <palomer> Cale: (char->alpha)->alpha
17:18:25 <Cale> palomer: so what is  getInput id ?
17:18:40 <palomer> oh , scratch that
17:18:40 <Cale> It ought to be a character
17:18:40 <palomer> (char->alpha)->()
17:18:40 <jethr0> well, unless you pass a continuation that explicitly "exits"... but it doesn't help at all in understanding CPS
17:19:21 <dons> I think that is an unusual definition of CPS, too.
17:20:58 <jethr0> what a good thing, that it is a wiki :)
17:21:12 <dons> anyway, the key point is that the next computation is passed as an argument.
17:21:44 <Cale> palomer: What's the type of putStr ?
17:21:59 <palomer> Cale: char -> ()
17:22:30 <dons> almost ;)
17:22:39 <Cale> That's going to be a problem
17:22:46 <palomer> [char]->()
17:22:51 <palomer> Cale: how so?
17:23:06 <Cale> You're going to end up with side effects dependent on evaluation order.
17:23:13 <jethr0> CPS helps in implementing continuations (what irony) and if tail call optimized you can replace function calls by goto's
17:23:29 <Cale> It gives you a bunch of values of type () with different side effects attached to their evaluation.
17:24:22 <palomer> Cale: you make them strict or something
17:24:30 <palomer> Cale: aren't these similar to the functions which the IO monad implement?
17:24:38 <Cale> With strict evaluation it would be okay
17:25:09 <Lokadin_> if we lived a few hundred years ago, i think everyone here would be burned as a witch or some such, if you had a discussion like this say on a porch
17:25:25 <jethr0> HAHA
17:25:40 <Lokadin_> lol, well it's true :P
17:25:41 <musasabi> Lokadin_: not to mention other sins we would be burned for
17:25:43 <jethr0> Lokadin_: what makes you think we won't be anymore?
17:26:05 <Lokadin_> well we stopped the whole burning thing a while ago :P
17:26:06 <Cale> <franka> Besides I am not a slut by any means.
17:26:19 <Lokadin_> and people are used to not understanding what is happening or what they are hearing
17:26:25 <Lokadin_> so it's fine
17:26:30 <Cale> hehe
17:26:49 <musasabi> Lokadin_: well there are still quite many people who like to threaten other with physical violence just because one happens to have a sexual orientation that they find offending.
17:26:58 <Lokadin_> it's just the level here is soo far beyond what you see in any other chat room i've ever been to.. it just seems crazy comparitavly
17:27:08 <jethr0> depends where you are. stoning to death and hacking of limbs for minor crimes seems like a hot thing in the middle east and china
17:27:15 <Lokadin_> musasabi: well that's in america
17:27:26 <Lokadin_> hmmm
17:27:38 <Cale> palomer: IO doesn't get executed due to evaluation -- it's executed by the RTS.
17:27:55 <musasabi> Lokadin_: happens in europe too sometimes, but larger european cities are usually mostly tolerant.
17:28:32 <Lokadin_> i would imagine, yea rural areas even in canada aren't free from some form of discrimination
17:28:48 <Frederick> hi folks do you thing a functional language would be easier to a children to learn?
17:29:04 <Lokadin_> not with the terminology these people use
17:29:04 <Cale> Frederick: yeah, actually :)
17:29:05 <Lokadin_> lol
17:29:13 <palomer> Cale: the Monad instance of IO have similar types to the ones I've described, no?
17:29:25 <Cale> palomer: hm?
17:29:36 <Lokadin_> but it is more natural the basics anyways
17:29:37 <musasabi> Frederick: yes, but there is very little in material that is intended for that purpose.
17:29:44 <jethr0> Frederick: yes, sth like scheme or haskell might be a good starting language
17:29:50 <palomer> no.
17:29:51 <Lokadin_> i taught my gf basic haskell :D!
17:30:11 <palomer> hot first date?
17:30:11 <Cale> I taught monads to 11 year olds :)
17:30:14 <Frederick> Lokadin, is she stll your gf?
17:30:16 <mjl69> when you look at it in terms of boxes of fruit, it
17:30:21 <mjl69> is easy :)
17:30:25 <jethr0> Frederick: are you familiar with PLT scheme / drscheme?
17:30:27 <Lokadin_> lol, well we've been going out for three years
17:30:39 <Frederick> jethr0, no but it isnt a big deal
17:30:48 <Cale> palomer: the point is that getLine isn't a function, it's just an inert value which represents that action. Evaluating it doesn't do much of anything at all.
17:31:27 <palomer> ok, I'm going to fully understand haskell IO
17:31:31 <palomer> then I'll get back to you
17:31:32 <musasabi> Cale: by that definitions integers are not functions either?
17:31:43 <Cale> musasabi: right
17:31:55 <musasabi> Cale: doesn't that just make the semantics clunky?
17:32:17 <Cale> The only things which are functions in my current terminology are those whose top level type constructor is (->)
17:32:48 <musasabi> Many times it makes sense just to treat constants as nullary functions.
17:32:56 <Cale> yeah
17:33:03 <Cale> but that would obscure my point here
17:33:09 <jethr0> "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live." - John F. Woods :)
17:33:21 <JohnMeacham> this darcsweb is really really nice! http://repetae.net/dw/ is my jhc repo. 
17:33:22 <dons> oh, I like that, jethr0
17:33:28 <JohnMeacham> we should get this set up for fptools.
17:33:29 <jethr0> me too :)
17:33:35 <musasabi> jethr0: try to make sure he commits suicide before coming to hunt you?
17:34:07 <Cale> hehe
17:34:09 <jethr0> "Assignment leads to mutation. Mutation leads to pointers. Pointers lead to suffering!" - Anton van Straaten
17:34:15 <musasabi> JohnMeacham: I have been rewriting Ho.hs, except something in a few days.
17:34:36 <jethr0> expect?
17:34:40 <JohnMeacham> musasabi: cool. what sort of changes? to support libraries?
17:35:00 <dons> I say, always code as if the whole world is darcs getting your repository
17:35:23 <JohnMeacham> musasabi: I have been meaning to start caching more in it, in particular partially optimized GRIN as well as core for speedier non-optimized compiles.
17:35:30 <dons> JohnMeacham, yeah darcsweb is very nice.
17:35:39 <musasabi> "Wir sind froh, dass die Absolventen schon Java knnen. Programmieren mssen wir denen halt noch beibringen." :-)
17:36:07 <JohnMeacham> I have been rewriting the typechecker to support rank-n and impredicative types.
17:36:17 <musasabi> JohnMeacham: to support libraries and make the logic more clean. (When compiling libraries we want to not automatically compile modules not listed on the command line etc)
17:36:32 <jethr0> musasabi: you wouldn't be on felleisen webpage, would you?
17:36:49 <jethr0> @babel de en Wir sind froh, dass die Absolventen schon Java knnen. Programmieren mssen wir  denen halt noch beibringen
17:36:49 <musasabi> jethr0: googled it after the first citation
17:36:50 <lambdabot>  We are glad that the graduates know already Java. To program we must
17:36:50 <lambdabot> still teach stop to those
17:37:10 <jethr0> hehe
17:37:12 <JohnMeacham> and incidentally it will give much much better error messages.
17:37:30 <musasabi> the type-classes.txt looked very cool
17:38:02 <JohnMeacham> musasabi: ah. I was saving that for a TMR article :) I need to rewrite it some, I got some feedback from SPJ, some of my terminology is off.
17:38:45 * musasabi waits eagerly for the article
17:39:17 * jethr0 has no idea what's going on, but he still eagerly awaits the next TMR
17:41:25 <JohnMeacham> cool. the repo is unstable now because it is using the new typechecker, but if you just change the reference from FrontEnd.Tc.Module to TI
17:41:48 <JohnMeacham> TIModule in FrontEnd.FrontEnd then it will use the old typechecker again.
17:42:20 <JohnMeacham> I am growing to like these hierarchical names.
17:42:42 <JohnMeacham> now that we are using darcs for fptools, we can hierarchicalize ghc.
17:42:50 <musasabi> well basic jhci works and I am working quite independent of the type layer. (will probably hit that when getting to the stage of creating libraries from fptools)
17:43:34 <musasabi> btw it would be nice to have typenames in common modules rather having import a ton of modules to get at those
17:44:23 <musasabi> I feel like code has to include 20+ modules and typically just use 1-2 name from each.
17:44:54 <JohnMeacham> ah. I prefer it that way actually. I don't like modules that reexport stuff from other modules, it feels unclean to me.
17:46:07 <musasabi> makes it harder to see what a module really depends on when it has a ton of imports
17:46:20 <JohnMeacham> it depends on exactly those things it imports :)
17:46:30 <JohnMeacham> using a typename from something is depending on it.
17:47:50 <JohnMeacham> I am trying to make Util.Interact very general, it provides a lot of general features which might be nice in ghci, like auto-completion of haskell names. I am working on making it context depedendent so it will only autocomplete types in type locations etc...
17:48:18 <JohnMeacham> and the saved history is quite nice for debugging...
17:48:49 <JohnMeacham> okay.. now it is that I just pushed a bunch of patches.
17:48:50 <Lokadin_> so is cps faster ?
17:48:53 <musasabi> I only briefly tried jhci (work stuff has been keeping me busy, and the ho-stuff is long overdue)
17:50:53 <palomer> cps isn't, erm, faster, since it's possible to cps any code, and the classic cpsification has a left inverse
17:51:06 <palomer> which has a galois correspondence with CPSify
17:51:11 <JohnMeacham> I am finding it very useful for debugging rather than coming up with a ton of '-d' flags since I can just print out relevant stuff for each function. even though it doesn't actually interpret anything yet, being able to query various things about the environment is really nice.
17:51:55 <jethr0> Lokadin_: CPS helps in implementing continuations (what irony) and if tail call optimized you can replace function calls by goto's
17:53:13 <JohnMeacham> though, using qualified imports would help with the figuring out what things depend on. I have been trying to get in the habit of using qualified imports when something depends on just one or two things from a module.
17:53:35 <JohnMeacham> but this has not always been the case.
17:55:11 <JohnMeacham> hmm.. but now I want the parser to support haddock comments so jhci can automatically print out the usage information for a function when you get a type error...
17:55:42 <musasabi> don't those add quite a lot of extra productions?
17:55:53 <JohnMeacham> yes they would.
17:56:09 <Lokadin_> jethr0: o
17:56:26 <jethr0> Lokadin_: do you need this for anything specific?
17:56:30 <musasabi> how about instead providing a :source command?
17:56:57 <JohnMeacham> I looked a little at switching to the ghc parser someone seperated out, but it is very complicated. I actually might branch happy to make one which auto-annotates everything with its srcspan, so error messages will always be in terms of the original text. it would save a lot of hassle trying to preserve things like type synonyms for error messagse.
17:57:01 <musasabi> that displays the source of a thing + attached comments
17:57:17 <JohnMeacham> that is what adding them to the parser would allow.
17:57:42 <musasabi> why not just relook at source/
17:57:53 <Lokadin_> jethr0: was just wondering
17:58:03 <musasabi> since one cannot hold things like indentation and parens anyway (or it makes no sense at least)
17:58:05 <JohnMeacham> because I need to figure out exactly where things start and end to pull out the appropriate bit of source.
17:58:24 <Lokadin_> jethr0: if it would be more optimal to write in cps rather than normal code, say if i need performance
17:59:00 <JohnMeacham> yes. that is what I want to do. that is why I want to modify happy to always store the srcspan (i.e. beginning and end bytes) so I can pull out the orignal text from the source. but I still have to parse it to find out where those locations are.
17:59:32 <jethr0> hmm, i would worry about that when finished writing code and after profiling. in general they might mess up the compiler's heuristics more than speed things up.
17:59:46 <musasabi> if you are looking at alternatives there is also Frown although I haven't used it much
17:59:48 <jethr0> also, CPS _can_ make your code less readable
18:00:00 <Lokadin_> jethr0: kk thanks :)
18:01:35 <JohnMeacham> I like 'pappy' actually. but it is not quite feature complete.
18:02:58 <Cale> Lokadin: I'd recommend against CPS unless you're really really sure that it's what you want.
18:03:17 <Cale> And if you're going to use it in Haskell, you might as well use a continuation monad.
18:03:32 <JohnMeacham> hmm. though frown looks interesting too. and might be an easier transition
18:11:42 <lispy> i always feel like i should have a better grasp of CPS, but i can never think of a concrete instance where i would want to use it
18:13:42 <JohnMeacham> I never really liked CPS. it feels quaint compared to monads.
18:15:04 <jethr0> lispy: how about writing a scheme interpreter in C :)
18:15:21 <JohnMeacham> you can probably write one in haskell in 50 lines.
18:15:22 <Lokadin_> so wait is elements2 f n (Branch left x right) = elements2 f (elements2 f x (left)) (right) 
18:15:25 <Lokadin_> cps?
18:15:34 <jethr0> hmm
18:15:37 <Lokadin_> or normal style?
18:15:53 <jethr0> JohnMeacham: you can write a scheme interpreter in scheme in about 50 lines too :)
18:16:24 <JohnMeacham> good point.
18:16:29 <JohnMeacham> but how many lines to write a C interpreter?
18:16:36 <jethr0> many 100s
18:16:47 <jethr0> well, maybe few hundreds
18:16:56 <jethr0> Lokadin_: why don't you start with something a _lot_ simpler?
18:17:12 <Lokadin_> what you mean?
18:17:28 <jethr0> JohnMeacham: have you seen the "scheme to c in 90 minutes" slides?
18:17:36 <Lokadin_> i'm just going chapter by chapter through the tutorial 
18:17:39 <Lokadin_> YAHT
18:17:44 <Lokadin_> @YAHT
18:17:44 <lambdabot> Unknown command, try @listcommands.
18:17:47 <Lokadin_> hmmm
18:17:48 <Lokadin_> o well
18:17:51 <jethr0> Lokadin_: ah, i thought you were still doing CPS
18:17:57 <Lokadin_> yea
18:17:58 <Lokadin_> cps
18:18:08 <Lokadin_> is what i'm on
18:18:08 <musasabi> scheme -> C, is much easier than C -> scheme
18:18:17 <Lokadin_> i just can't really understand what the difference is
18:18:22 <Lokadin_> like it wants me to remake map
18:18:23 <Lokadin_> in cps
18:18:24 <JohnMeacham> nope.
18:18:35 <jethr0> hmm, but CPS is hard enough by itself. try it out on _simple_ examples
18:18:43 <musasabi> JohnMeacham: well outside call/cc
18:18:51 <Lokadin_> currently it is map f (x:xs) = f x : map f xs
18:19:12 <jethr0> Lokadin_: i guess you would pass a continuation into map, and it would call itself until the list was empty and then call the continuation
18:19:15 <syntaxfree> @seen ski
18:19:15 <lambdabot> ski is in #haskell-overflow, #haskell-blah and #haskell. I don't know
18:19:15 <lambdabot> when ski last spoke.
18:19:36 <Lokadin_> well so what would be some simple examples?
18:19:41 <Lokadin_> where can i get them?
18:19:46 <musasabi> in the wiki?
18:19:55 <Lokadin_> those are scheme examples
18:20:20 <jethr0> let map cont _ [] res = cont res; map cont func (x:xs) res = map cont func xs (func x:res)
18:20:44 <jethr0> but that's butt ugly
18:20:48 <musasabi> http://haskell.org/hawiki/ContinuationPassingStyle
18:21:00 <Lokadin_> thanks
18:21:02 <Lokadin_> :)
18:22:26 <jethr0> > let map cont _ [] res = cont res; map cont func (x:xs) res = map cont func xs  (res++[func x]) in map show (+1) [1,2,3,4] []
18:22:27 <lambdabot> "[2,3,4,5]"
18:23:05 <jethr0> > show (map (+1) [1,2,3,4])
18:23:06 <lambdabot> "[2,3,4,5]"
18:25:15 * syntaxfree tries to get lambdabot to join his channel.
18:25:39 <jethr0> @vixen do you want to join syntaxfree's channel?
18:25:40 <lambdabot> yes, and i always get what i want
18:25:57 <jethr0> see, just ask
18:26:51 * syntaxfree beats lambdabot into submission.
18:27:12 <jethr0> @vixen just tell me and i'll protect you from this maniac
18:27:12 <lambdabot> *giggles*
18:27:53 <jethr0> would actually be pretty easy to make a @join and @leave plugin
18:28:18 <Lemmih> @help join
18:28:18 <Lokadin_> Disclaimer: An advanced topic follows. Haskell newbies should not read on.
18:28:18 <lambdabot> join <channel>
18:28:19 <syntaxfree> or make it respond to /invite
18:28:27 <Lokadin_> :D 
18:28:29 <jethr0> see, pretty easy
18:28:44 <jethr0> Lokadin_: did you see my map example?
18:28:51 <jethr0> is that what you had in mind?
18:29:02 <Lokadin_> yes i do see it, not that i can say that i understand it at all
18:29:11 <jethr0> want me to explain it?
18:29:16 <Lokadin_> that would be nice :D
18:29:40 <jethr0> ok, in CPS a function has no return value instead calls another function when it's "finished"
18:29:49 <syntaxfree> 12:35 AM  lambdabot: Not enough privileges
18:29:50 <syntaxfree> :'(
18:29:53 <Lokadin_> k
18:30:01 <jethr0> this goes on, until a function _does_ return
18:30:28 <jethr0> also, in CPS you always have to pass in at least one function that should be called when the current one is done.
18:30:29 <Lokadin_> well could we start with what does let map cont _ [] res = cont res; mean?
18:31:09 <jethr0> sure, it means that when map has no more elements to apply to "[]", it will call the given continuation with the accumulated result
18:31:55 <Lokadin_> hmmm
18:31:56 <Lokadin_> hold on
18:32:00 <jethr0> sure
18:36:42 <Lokadin_> okay well i dont' seem to understand the workings of let
18:37:01 <jethr0> hmm, i'll write it out.
18:37:11 <Lokadin_> kk :)
18:37:28 <jethr0> map cont _ [] res = cont res
18:37:33 <jethr0> map cont func (x:xs) res = map cont func xs  (res++[func x])
18:37:42 <jethr0> map show (+1) [1,2,3,4] []
18:38:00 <jethr0> sry, disregard the last one for now
18:38:05 <Lokadin_> kk
18:38:19 <jethr0> talk to me, that way i can help you better :)
18:38:56 <Lokadin_> hmmm
18:39:04 <Lokadin_> i'm just looking through it sorry
18:39:08 <jethr0> np
18:39:09 <Lokadin_> my gf just called :S
18:39:29 <syntaxfree> I just spent 10 entire days with my gf.
18:39:32 <syntaxfree> I miss her already.
18:39:43 * syntaxfree 's lonely hearts club band.
18:42:03 <palomer> we want you all to know
18:42:14 <palomer> someone give me a city or country or first name that starts with at
18:42:23 <syntaxfree> Atkinson
18:42:28 <palomer> err, ends with at
18:42:39 <syntaxfree> Muriat
18:42:39 <palomer> two syllables
18:42:47 <palomer> what the hell is muriat?
18:42:50 <syntaxfree> Pat
18:42:55 <palomer> nice
18:42:56 <syntaxfree> Paul Muriat, famous french singer.
18:43:35 <jethr0> riat
18:43:43 <jethr0> how do write that :)
18:43:46 <jethr0> rijad
18:45:13 <syntaxfree> al-Riyjadh
18:45:28 <jethr0> ya, well
18:46:09 <syntaxfree> j/k.
18:46:10 <jethr0> nat king cole
18:46:28 <glasser> hmm, i'm getting a little rusty on my haskell.  i'm trying to do something like "type Randomized a = Int -> (a, Int)"  and then "instance Monad Randomized where"
18:46:28 <syntaxfree> > chr(65)
18:46:29 <lambdabot> 'A'
18:46:46 <glasser> but it's not quite working... I guess I want to be doing something with data instead?
18:46:57 <syntaxfree> > [chr(x):"at" | x<-[65..90]]
18:46:58 <lambdabot> ["Aat","Bat","Cat","Dat","Eat","Fat","Gat","Hat","Iat","Jat","Kat","Lat","
18:46:58 <lambdabot> Mat","Nat","Oat","Pat","Qat","Rat","Sat","Tat","Uat","Vat","Wat","Xat","
18:46:58 <lambdabot> Yat","Zat"]
18:47:03 <glasser> can I not declare something made with "type" to be an instance?
18:47:07 <jethr0> i would have suggested sth of the kind, but i really don't know
18:47:18 <jethr0> syntaxfree: you are _im_possible ^_^
18:47:26 <jethr0> not everything can be automated away!
18:47:45 <jethr0> > [x:"at" | x<-['A'..'Z']]
18:47:46 <lambdabot> ["Aat","Bat","Cat","Dat","Eat","Fat","Gat","Hat","Iat","Jat","Kat","Lat","
18:47:46 <lambdabot> Mat","Nat","Oat","Pat","Qat","Rat","Sat","Tat","Uat","Vat","Wat","Xat","
18:47:46 <lambdabot> Yat","Zat"]
18:48:04 <syntaxfree> clevah.
18:48:59 <glasser> like, I want to say that "Int -> (a, Int)" is something that I can use the monad operations like >>= and so on on.  does that just not work?  Do I have to wrap it in some data?
18:49:36 <Cale> glasser: yeah, since the typeclass system needs to be able to dstinguish which set of operations you want
18:49:46 <syntaxfree> > zipWith (\x y->x:y:"at") ['A'..'Z'] ['a'..'z']
18:49:47 <lambdabot> ["Aaat","Bbat","Ccat","Ddat","Eeat","Ffat","Ggat","Hhat","Iiat","Jjat","
18:49:47 <lambdabot> Kkat","Llat","Mmat","Nnat","Ooat","Ppat","Qqat","Rrat","Ssat","Ttat","
18:49:47 <lambdabot> Uuat","Vvat","Wwat","Xxat","Yyat","Zzat"]
18:49:52 <Cale> btw, that type already has a name, it's  State Int a
18:49:54 <syntaxfree> no no.
18:49:59 <glasser> I guess that makes sense
18:50:02 <glasser> Cale: Yup, I know
18:50:25 <glasser> I'm trying to build up a state monad (with random built in) step by step for pedagogical purposes
18:50:48 <jethr0> > map (++"at") $ sequence [['A'..'Z'], ['A'..'Z']]
18:50:49 <lambdabot> ["AAat","ABat","ACat","ADat","AEat","AFat","AGat","AHat","AIat","AJat","
18:50:49 <lambdabot> AKat","ALat","AMat","ANat","AOat","APat","AQat","ARat","ASat","ATat","
18:50:49 <lambdabot> AUat","AVat","AWat","AXat","AYat","AZat","BAat","BBat","BCat","BDat","
18:50:49 <lambdabot> BEat","BFat","BGat","BHat","BIat","BJat","BKat","BLat","BMat","BNat","
18:50:49 <lambdabot> BOat","BPat","BQat","BRat","BSat","BTat","BUat","BVat","BWat","BXat","
18:50:51 <lambdabot> [25 @more lines]
18:50:53 <glasser> i've got a month to go before giving some haskell classes and I'm hoping I can get a nice monad explanation in
18:51:10 <Cale> glasser: have you read my monad explanation?
18:51:16 <glasser> Which is yours?
18:51:23 <Cale> MonadsAsContainers
18:51:32 <glasser> Yup, it's great
18:51:34 <palomer> I've created a monster
18:51:51 <palomer> you'd have to cross reference those against a dictionary
18:51:54 <glasser> The funny part is after a month or so since my first time of playing around with Haskell I remember how monads work pretty well
18:52:06 <glasser> It's the "how to declare types and data and instances" that's confusing me
18:52:39 <glasser> (like, I worked out a version of >>= and return under other names from first principles for this system in about half an hour.  but trying to actually make it a capital-M Monad is hurting my head)
18:53:25 <glasser> like, before I had:
18:53:25 <glasser> type Randomized a = Int -> (a, Int)
18:53:25 <glasser> randomLetter :: Randomized Char
18:53:26 <glasser> randomLetter seed = (toEnum (fromEnum 'a' + nextSeed `mod` 26), nextSeed)
18:53:26 <glasser>    where nextSeed = randomInt seed
18:53:31 <glasser> oops maybe that's too much paste
18:53:36 <Cale> not a problem
18:53:42 <glasser> now I have 
18:53:42 <glasser> data Randomized a = RF (Int -> (a, Int))
18:54:01 <glasser> but I'm not really sure how to retool the definition of randomLetter to "slip in" the RF in the right place
18:54:19 <glasser> I mean, I guess randomLetter = RF (\seed -> ... but that's kind of ugly
18:54:27 <glasser> (and isn't letting me keep my wherE)
18:54:38 <Cale> well, you have to implement at least one of the random operations like that
18:54:56 <Cale> but you can just use the monad operations together with whichever one you choose thereafter
18:55:16 <palomer> someone give me a first name that ends in ote
18:55:31 <glasser> Oh, I see, that makes sense
18:55:46 <palomer> or city or country
18:56:17 <jethr0> palomer: you sure this is the right place?
18:56:37 <palomer> where would the right place be?
18:56:42 <palomer> anyways, you guys have nothing better to do
18:57:07 <jethr0> true, but maybe haskell-blah is better suited
18:58:59 * syntaxfree suggest #lambdarockers for the rocking-est lambda people :)
19:00:42 <glasser> Bah, all these RFs make my code much more ugly.  I like my where :(
19:00:46 <glasser> But it works! ThanksCale
19:01:27 <Cale> glasser: you should only have one or two
19:01:35 <Cale> in implementing your primitives
19:01:48 <Cale> and then you probably shouldn't even expose RF to the user
19:01:50 <glasser> Yeah, it's in the primitives
19:01:56 <Cale> (i.e. not export it from the module0
19:01:57 <Cale> )
19:02:23 <glasser> I'll be sure to make my notes/slides for this class somewhere public
19:02:24 <Cale> you can still use where
19:02:26 <palomer> > foldl1 (++",") ["louise","mary"]
19:02:27 <lambdabot>   Expecting a function type, but found `[a]'
19:02:27 <lambdabot>   Expected type: [Char] -> [Char] -> [Char]
19:02:27 <lambdabot>   Inferred type: [Char] -> [Char]
19:02:35 <glasser> preferably before the class so you can all tell me how wrong I am :)
19:02:39 <palomer> > foldl1 (++ ",") ["louise","mary"]
19:02:39 <lambdabot>   Expecting a function type, but found `[a]'
19:02:39 <lambdabot>   Expected type: [Char] -> [Char] -> [Char]
19:02:39 <lambdabot>   Inferred type: [Char] -> [Char]
19:02:43 <Cale> I'm not completely sure what you mean by that
19:02:49 <palomer> @type (++,",")
19:02:50 <lambdabot> parse error on input `,'
19:02:53 <palomer> @type (++ ",")
19:02:54 <lambdabot> [Char] -> [Char]
19:02:56 <Cale> (about the where)
19:03:07 <glasser> well if you recall from before I had
19:03:10 <Cale> @type ((++), ",")
19:03:11 <lambdabot> forall a. ([a] -> [a] -> [a], [Char])
19:03:17 <glasser> randomLetter :: Randomized Char
19:03:17 <glasser> randomLetter seed = (toEnum (fromEnum 'a' + nextSeed `mod` 26), nextSeed)
19:03:17 <glasser>    where nextSeed = randomInt seed
19:03:30 <glasser> which I changed to
19:03:30 <palomer> Cale: how is that expression even well formed?
19:03:30 <glasser> randomLetter = RF (\seed -> let nextSeed = randomInt seed
19:03:30 <glasser>                             in  (toEnum (fromEnum 'a' + nextSeed `mod` 26), nextSeed))
19:03:47 <glasser> I tried to do a similar thing with "where", but the where didn't end up inside the \seed so it didn't work
19:03:52 <palomer> > foldl1 (\x y -> x ++ "," ++ y) ["louise","mary"]
19:03:53 <lambdabot> "louise,mary"
19:04:01 <palomer> > foldl1 (\x y -> x ++ "," ++ y) ["louise","mary","bert"]
19:04:02 <lambdabot> "louise,mary,bert"
19:04:20 <palomer> > foldr1 (\x y -> x ++ "," ++ y) ["louise","mary","bert"]
19:04:21 <lambdabot> "louise,mary,bert"
19:04:25 <Cale> randomLetter = RF randomLetter' where...
19:04:28 <palomer> that's awesome.
19:04:38 <glasser> oh right
19:06:25 <jethr0> > concat . intersperse "," $ ["louise","mary","bert"]
19:06:27 <lambdabot> "louise,mary,bert"
19:07:21 <palomer> what does that last $ do?
19:07:51 <jethr0> > (concat . intersperse ",") ["louise","mary","bert"]
19:07:52 <lambdabot> "louise,mary,bert"
19:08:06 <jethr0> it's an parens eradicator :)
19:08:11 <palomer>  > concat . intersperse ","  ["louise","mary","bert"]
19:08:15 <palomer> > concat . intersperse ","  ["louise","mary","bert"]
19:08:15 <lambdabot>   Expecting a function type, but found `[a]'
19:08:15 <lambdabot>   Expected type: a1 -> [[a]]
19:08:15 <lambdabot>   Inferred type: [a2]
19:08:28 <palomer> but application is left associative
19:08:32 <syntaxfree> a $ b $ c $ d is equivalent to a(b(c(d)))
19:09:17 <palomer> a b c = ((a b) c)
19:09:35 <palomer> so (concat . intersperse ",") ["louise","mary","bert"] = (concat . intersperse ",") ["louise","mary","bert"] 
19:09:43 <palomer> so (concat . intersperse ",") ["louise","mary","bert"] = concat . intersperse "," ["louise","mary","bert"] 
19:09:48 <palomer> ignore the first one
19:11:01 <Cale> (concat . intersperse ",") ["louise","mary","bert"] = concat (intersperse "," ["louise","mary","bert"])
19:11:30 <palomer> but application is left associative!
19:12:00 <syntaxfree> > (concat . intersperse ",") ["Amigos", "no", "more", "tears"]
19:12:01 <lambdabot> "Amigos,no,more,tears"
19:12:14 <jethr0> dot binds less strongly than application (?)
19:12:45 <palomer> does it?
19:12:50 <palomer> that would be screwed up
19:12:58 <Korollary> lambdabot needs a @parenthesize to show the abstract syntax
19:13:08 <palomer> > (concat . intersperse) "," ["Amigos", "no", "more", "tears"]
19:13:09 <lambdabot>   Expecting a function type, but found `b'
19:13:09 <lambdabot>   Expected type: a1 -> [[a]]
19:13:09 <lambdabot>   Inferred type: a1 -> [a1] -> [a1]
19:13:10 <jethr0> (filter even . map (+1)) [1..5]
19:13:14 <palomer> nope, that's not it
19:13:16 <jethr0> > (filter even . map (+1)) [1..5]
19:13:17 <lambdabot> [2,4,6]
19:13:35 <jethr0> if "dot" bound more than application you would have to parens everying "dotted"
19:13:51 <palomer> yeah, good point
19:13:54 <palomer> so what's the explanation?
19:14:05 <jethr0> well, explanation is "precedence"
19:14:14 <jethr0> i guess
19:14:55 <dons> @pretty (concat . intersperse ",") ["louise","mary","bert"]
19:14:55 <lambdabot> "Parse error" at column 52
19:15:00 <dons> @pretty let _ = (concat . intersperse ",") ["louise","mary","bert"]
19:15:01 <lambdabot> "Parse error" at column 60
19:15:11 <dons> @pretty let x = (concat . intersperse ",") ["louise","mary","bert"] in x
19:15:11 <lambdabot>  i = let x = (concat . intersperse ",") ["louise", "mary", "bert"]
19:15:11 <lambdabot>    in x
19:15:17 <dons> hehe
19:15:26 <jethr0> hmm, well
19:15:28 <dons> @pretty let x = concat . intersperse "," $ ["louise","mary","bert"]
19:15:28 <lambdabot> "Parse error" at column 60
19:15:31 <dons> @pretty let x = concat . intersperse "," $ ["louise","mary","bert"] in x
19:15:32 <lambdabot>  i = let x = concat . intersperse "," $ ["louise", "mary", "bert"]
19:15:32 <lambdabot>    in x
19:15:35 <dons> oh well
19:15:53 <jethr0> well, it's "pretty". just not limited in width
19:15:57 <palomer> I still don't get it
19:16:30 <dons> @pretty case () of 1 | True -> () | False -> () 
19:16:31 <lambdabot> "Parse error" at column 41
19:16:35 <jethr0> Korollary: that would be easily done
19:16:38 <dons> @pretty case () of 1 | True -> (); | False -> () 
19:16:39 <lambdabot> "Parse error" at column 36
19:16:40 <dons> bah
19:16:51 <dons> @pretty let x = case () of 1 | True -> () | False -> () 
19:16:51 <lambdabot> "Parse error" at column 49
19:16:54 <Korollary> @type (concat . intersperse) ","
19:16:55 <lambdabot> Not in scope: `intersperse'
19:16:56 <jethr0> hehehe
19:17:05 <Korollary> @type (concat . Data.List.intersperse) ","
19:17:06 <lambdabot>   Expecting a function type, but found `b'
19:17:06 <lambdabot>   Expected type: a1 -> [[a]]
19:17:13 <Korollary> @type (concat . Data.List.intersperse)
19:17:14 <lambdabot>   Expecting a function type, but found `b'
19:17:14 <lambdabot>   Expected type: a1 -> [[a]]
19:17:15 <jethr0> dons, i'll send in some fixes to @pretty if i'm not held up by xmas
19:17:26 <Korollary> I think that's the problem
19:17:29 <dons> yeah, I broke @pretty in a big rewrite of lambdabot the other day
19:17:37 <Korollary> @type (concat . (Data.List.intersperse "something")
19:17:38 <lambdabot> parse error (possibly incorrect indentation)
19:17:41 <palomer> @type \x y z -> (x .y) z
19:17:41 <dons> I need to think about the output formatting issues
19:17:41 <Korollary> @type (concat . (Data.List.intersperse "something"))
19:17:42 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:17:42 <lambdabot> [[Char]] -> [Char]
19:17:46 <jethr0> never mind, it's an ugly kludge at the moment anyhow
19:17:51 <palomer> @type \x y z -> x .(y z)
19:17:52 <lambdabot> forall b c a t. (b -> c) -> (t -> a -> b) -> t -> a -> c
19:17:55 <palomer> @type \x y z -> x .y z
19:17:56 <lambdabot> forall b c a t. (b -> c) -> (t -> a -> b) -> t -> a -> c
19:18:06 <jethr0> dons, what did you rewrite?
19:18:13 <palomer> well, . binds less tightly than application
19:18:20 <dons> the Module type class method `process'
19:18:28 <dons> has a new interface, and is optional
19:18:39 <dons> with a more lightweight option now being `process_'
19:18:43 <jethr0> ok, i'll get the version :)
19:18:48 <dons> and plugins should not do their own ircPrivMsg now
19:19:00 <dons> they return [String], which the Base module handles 
19:19:17 <dons> so plugins construct [String], with the rendering handled by the Base module
19:19:27 <dons> though I'm sort of inclined to pass rendering to a Filter module
19:19:37 <dons> needs thinking
19:19:51 <dons> there's some other ideas to pass typed values around, rather than just [String]
19:19:57 <dons> would make plugin composition more sane
19:20:03 <dons> though more difficult ;)
19:20:11 <jethr0> is composition working yet?
19:20:24 <dons> sure
19:20:31 <jethr0> nice
19:20:37 <dons> @compose pl djinn a -> b -> ((a,b),(b,a))
19:20:37 <lambdabot> f = ap (ap . ((,) .) . (,)) (flip (,))
19:20:45 <dons> @compose elite . pl djinn a -> b -> ((a,b),(b,a))
19:20:46 <lambdabot> f = ap (4P . ((,) .) . (,)) (fLip (,))
19:20:53 <dons> @compose elite . elite . pl djinn a -> b -> ((a,b),(b,a))
19:20:54 <lambdabot> ph = 4p (Ap . ((,) .) . (,)) (F1Ip (,))
19:20:58 * dons laughs
19:21:16 <dons> @compose elite . elite . id yow
19:21:17 <lambdabot> i HA\/3 +|-|3 Po\/\/ER +0 HA1t PRODuc+ion on a|1 73Ena93 Zex co/\/\3dI35!!
19:21:40 <dons> so it's sort of a mini-language for plugin composition, with only the '.' operator
19:21:47 <syntaxfree> hmm.
19:21:50 <syntaxfree> @hoogle elite
19:21:51 <lambdabot> No matches found
19:21:51 <dons> lambdas would be nice though
19:22:08 <dons> then we could name different points, and do flip and such.
19:22:24 <jethr0> @yoq
19:22:24 <lambdabot> Did I do an INCORRECT THING??
19:22:25 <jethr0> @yow
19:22:25 <lambdabot> Go on, EMOTE!  I was RAISED on thought balloons!!
19:22:56 <jethr0> @compose elite . google haskell 
19:22:57 <lambdabot> compose module failed: Parse error: "haskell"
19:23:11 <dons> @. elite google haskell
19:23:12 <lambdabot> HtTp://wWW.|-|AzK3l1.0r9/
19:23:17 <jethr0> haha
19:23:19 <dons> @compose elite google haskell
19:23:19 <Cale> @compose google yow
19:23:19 <lambdabot> hT7P://w\/\/w.|-|a5xEll.oRg/
19:23:20 <lambdabot> http://cbs5.com/
19:23:25 <dons> hehe
19:23:28 <Cale> @compose google yow
19:23:29 <lambdabot> http://mt.middlebury.edu/middblogs/pamsbary/Digital%20Editions/archives/
19:23:29 <lambdabot> 575_mbsec_27_terabyt.html
19:23:34 <syntaxfree> @. vixen
19:23:35 <lambdabot> Not enough arguments to @.
19:23:39 <syntaxfree> @. elite vixen
19:23:39 <lambdabot> \/\/hER3 oN A /\/\AP i$ PaNAMA?
19:23:51 <dons> @. elite vixen
19:23:52 <lambdabot> 4re u HOrnY?
19:23:54 <jethr0> @. vixen elite
19:23:54 <lambdabot> why don't you guess?
19:24:06 * jethr0 laughs his ass off
19:24:10 <dons> it's all untyped, so you don't get told when things don't make sense
19:24:11 <Cale> @. elite vixen
19:24:12 <lambdabot> waNNa hE4R A S7oRy?
19:24:17 <Cale> @. elite vixen
19:24:17 <lambdabot> EVER JuST 93t +he URGE T0 GO ou7 aNd KIlL a PupPy?
19:24:18 <jethr0> hehe
19:24:40 <Cale> @compose google yow
19:24:42 <lambdabot> http://www.shootybangbang.com/pinhead.cgi?q=180
19:25:04 <Cale> heh, that's rather appropriate
19:25:09 <jethr0> @djinn (Maybe a) -> a
19:25:10 <lambdabot> -- f cannot be realized.
19:25:17 <dons> @. google where hmp3
19:25:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
19:25:23 <jethr0> @djinn (a->b) -> (Maybe a) -> (Maybe b)
19:25:24 <lambdabot> f a b =
19:25:24 <lambdabot>   case b of
19:25:24 <lambdabot>   Nothing -> Nothing
19:25:24 <lambdabot>   Just c -> Just (a c)
19:25:35 <jethr0> @. pretty djinn (a->b) -> (Maybe a) -> (Maybe b)
19:25:36 <lambdabot> "Parse error" at column -13
19:25:41 <dons> there are some compositions that don't work.
19:25:52 <dons> for example, multi-line answers from djinn confused @pl and @pretty
19:25:59 <jethr0> understandable
19:26:15 <dons> also, type . djinn == id, but it doesn't
19:26:31 <dons> since djinn spits out decls, not exprs
19:26:34 <dons> it's all a bit tedious
19:26:52 <dons> djinn . hoogle doesn't work, but should
19:27:20 <dons> hence we need either (1) types, (2) hacks to make things work, (3), a sed composition language
19:28:39 <dons> but it's nice, anyway. since we have a form of reflection, and a really basic runtime scripting module
19:29:33 <dons> ideally I'd like to use @eval, and be able to refer to plugins in the eval code. but i need to think a bit harder on how to make that work safely
19:29:44 <Cale> yeah, that would be nice :)
19:30:08 <Cale> @compose elite localtime dons
19:30:09 <lambdabot> Say again?
19:30:10 <lambdabot> Local time for dons is Tue Dec 20 14:25:05 2005
19:30:19 <dons> ah, and certain plugins are magic :)
19:30:33 <dons> ones that fork off callbacks don't fit the model, for example
19:30:43 <dons> since they immediately return [], and later do their own IO
19:32:46 <jethr0> @elite Haskell is still the language of choice for discriminating hackers
19:32:46 <lambdabot> hAsxEL1 i$ S+ilL t|-|3 LanguaGE Oph c|-|Oic3 ph0r DIsCRI/\/\iNA+iNG |-|4(
19:32:46 <lambdabot> xeRz
19:32:56 <icb> how up-to-date is the ghc user guide?
19:33:11 <dons> very
19:33:31 <dons> particularly the cvs/darcs version. it just follows changes as they're made
19:33:31 <icb> dons, i am running through the profiling example in the user manual
19:33:42 <icb> and i am getting different results
19:33:43 <dons> yep, profiling is accurate, afaik. 
19:34:15 <dons> well, are you using the ghc user's guide version for your compiler?
19:34:51 <icb> i am using the 641 mac binary build on the site, and looking at the "latest" html
19:35:41 <dons> what does "different results" mean?
19:36:00 <icb> look at the second example, where it does f 25 + g 25
19:36:27 <dons> yup?
19:36:31 <icb> my profile results still gets everything under the nfib instead of the two nfibs shown on the page
19:36:45 <dons> doesn't matter does it?
19:36:54 <dons> that example may have been generated a while ago
19:36:56 <SlowByte> @. google vixen
19:36:57 <lambdabot> http://use.perl.org/~TorgoX/journal/4699
19:36:59 <dons> the compiler has changed since
19:37:12 <icb> i figured that much
19:37:22 <dons> i would worry too much about having exactly the same profile output as the doc
19:37:31 <dons> just as long as you get output.
19:37:53 <icb> make sense
19:42:27 <icb> i am just trying to convince myself yampa is the right way to go
19:43:18 <icb> oh, btw, i heard back from paul, the memb9 registration thing is fixed 
19:43:19 <Saulzar> What are you working on?
19:43:40 <icb> a 3d ide
19:44:35 <Saulzar> How does that work? :)
19:45:06 <icb> well the architecture should look pretty close to a 3d game, so it should be similar to frag as using hopengl as the rendering layer
19:45:41 <icb> i have been swimming in yampa papers the past few weeks
19:45:46 <Saulzar> But what is a 3D ide? You mean like a modeller, not editing code?
19:46:12 <icb> editing code
19:46:36 <icb> think of it as a reactive editor, it changes the visual layout as you code 
19:47:03 <Saulzar> Hmm, cool - where does the 3D part come in?
19:47:35 <icb> i plan to use lod and transparency to resolve the temporal complexity of large codebase
19:48:07 <glasser> that's kind of scary
19:48:13 <attaayakat> lod?
19:48:14 <glasser> i'd like to see it though !
19:48:23 <icb> lod = level of detail
19:48:30 <attaayakat> ah
19:48:33 <Saulzar> I've been reading on Yampa too, interesting stuff
19:49:02 <icb> definitely when i get something working
19:49:21 <jethr0> me too, but impressive as frag is, the yampa doesn't make it more readable. but maybe that's a question of coding style
19:49:58 <icb> saul, i was just saying a minute ago, the conal elliot extended FRP implementation paper is a very debilitating read 
19:50:14 <Saulzar> debilitating?!
19:50:30 <icb> he went on and on about how this didn't work, that didn't work ...
19:50:56 <icb> he is a real badass, not afraid to admit the flaw in his research
19:51:21 <icb> pointing people to the future
19:51:36 <Saulzar> Hmm, what were the main problems? 
19:51:45 <icb> time/space leak
19:51:55 <Saulzar> I've not even poked at any of the FRP stuff
19:51:56 <dons> @seen conal
19:51:56 <lambdabot> I saw conal leaving #haskell 7 days, 10 hours, 1 minute and 30 seconds
19:51:56 <lambdabot> ago, and I have missed 3 hours, 4 minutes and 49 seconds since then.
19:52:09 <dons> icb, you can tell him he's a badass next time him drops by
19:52:18 <icb> i sure will!
19:52:25 <Saulzar> Isn't that what Yampa is supposedly meant to solve?
19:52:41 <icb> that's my take too so far
19:52:54 <icb> but i am an inheriant skeptic
19:53:05 <Saulzar> Though I'm not sure I understand what a time or space leak actually means
19:53:17 <icb> i don't just take other people's words, i want to understand how is the problem solved
19:53:30 <attaayakat> FWIU, it's easy to fall into leak problems with FRP, because you're operating on infinite streams
19:53:43 <attaayakat> if you hang onto just a little too much data, it quickly accumulates without bound
19:54:05 <icb> yampa seems to solve the problem by using another level of indirection
19:54:06 <attaayakat> and if you fall behind in processing events and they start queueing up, you can never catch up
19:54:38 <Saulzar> Oh, so it's not an issue with numerics, but an issue with the particulars in FRP?
19:54:52 <icb> making one to make a network of signal processors using given combinators
19:54:55 <attaayakat> I don't really know -- haven't read the paper
19:55:44 <icb> the original FRP is extremely elegant
19:57:42 <icb> very soon i will be able to crank out some real yampa code to verify my assumptions
19:59:58 <Saulzar> Hmm, I should take a look.. right now i'm still wiring up my little program and have written very little of yampa code. I'm dealing with a considerably simpler problem than you :)
20:17:02 <araujo> Helo.
20:17:54 <jethr0> MAIL FROM:
20:18:03 <Pseudonym> EHLO
20:18:15 <jethr0> hehe
20:20:51 <jethr0> Connection closed by foreign host.
20:23:56 <Pseudonym> +++ATH0
20:24:02 <Pseudonym> Unfortunately that doesn't work any more.
20:27:29 <jethr0> what did it do?
20:29:08 <Pseudonym> Back in the day when people used modems without IP-over-modem-thingy, and when badly-built modems ignored frame boundaries when looking for Hayes commands, it would cause some peoples connections to drop.
20:29:16 <Pseudonym> ATH0 is the Hayes command for "hang up".
20:29:51 <jethr0> *yuch*, i remember those times. i never could figure out whether my modem was a z-modem or a y-modem, because it sometimes seemed to work with both settings. *bad times*
20:30:25 <unsaved> zmodem and ymodem were transfer protocols....
20:30:30 <Pseudonym> Yes.
20:30:35 <Pseudonym> Same with xmodem, kermit etc.
20:31:12 <jethr0> unsaved: yes, i don't remember so well because i was only 14. but the net i was dialing into, combined with my modem would only support "y" _or_ "z" at times
20:32:12 * unsaved was 11, but has no life except for remembering these things
20:32:23 <jethr0> hehe
20:33:16 <Pseudonym> This is back when I read Usenet.
20:33:22 <Pseudonym> At 9600 baud.
20:35:12 <jethr0> i went into sth call fidonet (maybe germany specific) and tried some BBSs. but non-local calls were prohibitively expensive, so before discovering the "internet" i didn't get too much done this way!
20:35:40 <jethr0> i remember surfing the WWW with 14k and the then-simple pages downloading forever...
20:35:52 <unsaved> there was fidonet everywhere.  I used to read some feeds.
20:35:55 <Pseudonym> Oh, this was before the web.
20:36:12 <jethr0> yes, i used fidonet in '94
20:36:31 <Pseudonym> I'm probably the only person who used the net _before_ fidonet.
20:36:46 <jethr0> yes, you most likely are :)
20:36:53 <Pseudonym> I had an Internet account before I had Fidonet access.
20:40:03 <unsaved> it's funny that, even way back in the bbs era, there was a huge amount of free scanned pornography around.  And pyramid schemes/phony offers.  Two constants in the entire online saga.
20:40:54 <Spark> human nature
20:40:55 <unsaved> I really wanted to try that "send a dollar to five people" thing.  I just knew I was gonna get rich.
20:41:00 <Pseudonym> There wasn't spam, though.
20:41:05 <Spark> is it any coincedence that all spam is either a) sex b) money c) drugs
20:41:09 <Pseudonym> I remember Canter and Siegel.
20:41:14 * Pseudonym spits
20:41:54 <jethr0> true, porn was an early adopter of the internet. and warez too; they must have existed on BBSs for years before the internet. an uncle of a friend of mine used to trade streamers full of games/apps and initially i'm sure they came from BBSs.
20:41:57 <Pseudonym> Spark: Not true.  There's also phishing.
20:42:14 <Spark> d) fucking other people over
20:42:15 <Spark> :)
20:42:18 <Pseudonym> :-)
20:42:38 <Pseudonym> For those who haven't seen it: http://www.spamusement.com/
20:42:40 <unsaved> jethr0: yep, lots of warez on BBSs as well.  (though I don't think we called it that, then)
20:42:50 <jethr0> "we"?
20:43:16 <unsaved> we, as in the people who were calling up the BBSs and trading commercial software.
20:44:03 <jethr0> ah, you seem to have had an active phase at age 11 ^_^
20:44:49 <unsaved> oh yeah... every night after my parents went to bed I strung a 30 foot telephone cord from our computer into the kitchen phone jack.  I never got any sleep.
20:45:42 <stepcut> my parents got a second phone line after people started calling the phone company and reporting our phone line was "broken"
20:46:11 <unsaved> (then, we moved to a different city, where not all 7-digit telephone numbers were free, but no one told me that...)
20:46:14 <jimapple> Why isn't there an instance declaration for Monad ((->) a)
20:46:22 <jimapple> I made one, and GHC liked it just fine:
20:46:31 <jethr0> hehe, yes, but i wasn't so bad either. learnt "cracking" and even removed some 10s of copy protections from programs. quite some immersion in assembly, disassembling and live debugging
20:46:40 <jimapple> instance Monad ((->) x) where
20:46:40 <jimapple>     return = const
20:46:40 <jimapple>     p >>= q = \r -> q (p r) r
20:47:35 <jethr0> jimapple: sry, can't help ya, still struggling with the whole monad issue
20:49:14 <jimapple> The monad laws check:
20:49:14 <jimapple> 1. (return x) >>= f <==> \r -> f (const x r) r <==> \r -> f x r <==> f x
20:49:40 <stepcut> jimapple: perhaps simply because no one has bothered to submit one yet ?
20:50:24 <jimapple> m >>= return <==> \r -> const (m r) r <==> \r -> m r <==> m
20:56:32 <jimapple> 3. (m >>= f) >>= g <==> (\r -> f (m r) r) >>= g <==> \s -> g (f (m s) s) s <==> \s -> (\x r -> g (f x r) r) (m s) s <==> m >>= (\x r -> g (f x r) r) <==> m >>= (\x -> f x >>= g)
20:56:42 <jimapple> @google monad laws
20:56:43 <lambdabot> http://www.nomaware.com/monads/html/laws.html
20:57:23 <jimapple> @type (id id, id id)
20:57:24 <lambdabot> forall a a1. (a -> a, a1 -> a1)
20:58:28 <Cale> jimapple: that instance is in Control.Monad.Reader
20:58:40 <jimapple> thanks.
20:58:53 <stepcut> Cale: i thought I had seen it somewhere, but I couldn't find it in the docs :p
20:59:21 <Cale> stepcut: yeah, it seems to be an easter egg
20:59:22 <jimapple> @google Control.Monad.Reader
20:59:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-
20:59:24 <lambdabot> Reader.html
20:59:31 <stepcut> Cale: heh
20:59:40 <jimapple> I don't see it in the haddock
21:00:01 <Cale> MonadReader r ((->) r)
21:00:25 <Cale> which implies that it has to be an instance of Monad too
21:00:45 <Cale> I don't know why Haddock is so sneaky about it
21:02:08 <Cale> It's documented about as little as it possibly could be without being completely undocumented.
21:02:39 <stepcut> heh
21:02:44 <Cale> Meanwhile, that instance should probably just be in the Prelude.
21:02:52 <shapr> Good morning #haskell!
21:03:00 <Cale> morning shapr!
21:03:03 <stepcut> shapr!
21:03:09 <tmoertel> morning, shapr!
21:03:27 <shapr> How's it goin? Lotsa fine code this dark but motivating morning?
21:03:33 <stepcut> is there some tool for taking my darcs repos and automatically generating webpages with changelogs, rss feeds, tarballs, etc ?
21:03:52 <shapr> stepcut: Yes, but not tarballs.
21:04:02 <jimapple> shapr: where do you live? isn't it dark until afternoon?
21:04:21 <shapr> jimapple: Yes, especially this close to the solstice.
21:04:33 <stepcut> shapr: where at ?
21:05:01 <shapr> stepcut: darcs.cgi handles rss feeds, and you can ask for changes between certain versions.
21:05:39 <jimapple> where can I find the source for the MTL library? I want to look at Control.Monad.Reader, here: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Control/Monad/Attic/Reader.hs
21:05:45 <stepcut> shapr: hrm, I am looking more for something for the main project homepage
21:05:47 <Cale> Control.Monad.Reader's description in the docs seems a bit off too: Declaration of the Monoid class,and instances for list and functions
21:05:51 <shapr> Or you can check out the latest version of darcsweb, here's JohnMeacham's http://repetae.net/dw/ setup.
21:06:23 <Cale> I can't wait for everything to be nicely darcs-ized
21:06:42 <shapr> @karma+ darcs
21:06:42 <lambdabot> darcs's karma raised to 2.
21:06:58 <jimapple> @listcommands karma
21:06:58 <lambdabot> karma provides: karma karma+ karma-
21:07:07 <jimapple> @karma darcs
21:07:07 <lambdabot> darcs has a karma of 2
21:07:11 <Cale> If nothing else, the docs would improve greatly
21:07:12 <jimapple> @karma shapr
21:07:12 <lambdabot> shapr has a karma of 16
21:07:16 <shapr> wow
21:07:20 <jimapple> @karma jimapple
21:07:20 <lambdabot> You have a karma of 0
21:07:25 <Cale> aww
21:07:27 <shapr> @karma+ jimapple
21:07:28 <lambdabot> jimapple's karma raised to 1.
21:07:31 <jimapple> @karma lambdabot
21:07:31 <lambdabot> lambdabot has a karma of 8
21:07:48 <jimapple> @karma @karma
21:07:48 <lambdabot>  @karma has a karma of 0
21:07:59 <jimapple> heavy, man
21:08:11 <jimapple> @listcommands
21:08:11 <lambdabot> use listcommands [module|command]. Modules are:
21:08:11 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
21:08:11 <lambdabot> help hoogle karma localtime more pl plugs poll pretty quote search seen
21:08:11 <lambdabot> spell state system todo topic type version vixen where
21:08:16 <cpatrick> @karma @dogma
21:08:16 <lambdabot>  @dogma has a karma of 0
21:08:23 <jimapple> @dogma @karma
21:08:24 <lambdabot> Unknown command, try @listcommands.
21:08:32 <Cale> heh, we should have an @dogma
21:08:44 <jimapple> can anyone write a quite in lambdabot?
21:08:52 <jimapple> @quine lambdabot
21:08:53 <lambdabot> Maybe you meant: quit quote
21:09:28 <jethr0> jimapple, you could ^_^
21:10:09 <Cale> it used to seem possible before they changed the error reporting
21:10:13 <jimapple> does lambdabot ever respond with something beginning with '@'
21:10:17 <Cale> > error "Hello"
21:10:17 <lambdabot> Add a type signature
21:10:20 <Cale> > error "Hello" :: Int
21:10:21 <lambdabot> Exception: Hello
21:10:42 <jimapple> > Exception: Hello
21:10:42 <lispy> @quote
21:10:42 <lambdabot>  Not in scope: data constructor `Hello'
21:10:42 <lambdabot> Heffalump says: CPP leads to suffering
21:10:54 <jimapple> @quote
21:10:55 <lambdabot> xerox says: you know, befunge is probably the only language I've seen
21:10:55 <lambdabot> where you can run code pasted from IRC with the <nick> tags still in
21:10:55 <lambdabot> place ;-)
21:11:26 <Cale> @listcommands quote
21:11:26 <lambdabot> quote provides: fortune yow arr
21:11:35 <Cale> @listcommands
21:11:35 <lambdabot> use listcommands [module|command]. Modules are:
21:11:35 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
21:11:35 <lambdabot> help hoogle karma localtime more pl plugs poll pretty quote search seen
21:11:35 <lambdabot> spell state system todo topic type version vixen where
21:11:38 <jimapple> @quote arr
21:11:38 <lambdabot> arr hasn't said anything memorable
21:11:47 <jimapple> @quote yarrrr!!!!
21:11:48 <Cale> @listcommands fact
21:11:48 <lambdabot> yarrrr!!!! hasn't said anything memorable
21:11:48 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-
21:11:48 <lambdabot> update
21:12:01 <jimapple> @quote lambdabot
21:12:01 <Cale> @fact fact
21:12:01 <lispy> @quote shapr
21:12:01 <lambdabot>  lambdabot hasn't said anything memorable
21:12:01 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
21:12:01 <lambdabot>  Windows users are like the wives of alcoholics, they'll take any amount
21:12:01 <lambdabot> of abuse and come right back.
21:12:10 <Cale> @fact @fact
21:12:10 <lambdabot> I know nothing about @fact
21:12:19 <Cale> @fact: @fact
21:12:19 <lambdabot> I know nothing about @fact
21:12:35 <jimapple> @quote yow
21:12:36 <lambdabot> yow hasn't said anything memorable
21:12:37 <Cale> @fact-set @fact @fact
21:12:37 <lambdabot> Fact recorded.
21:12:42 <Cale> @fact: @fact
21:12:43 <lambdabot>  @fact: @fact
21:12:48 <jimapple> @arr
21:12:48 <lambdabot> Aye Aye Cap'n
21:12:49 <Cale>  @fact: @fact
21:12:54 <jimapple> @arr
21:12:54 <lambdabot> I'll keel haul ya fer that!
21:13:06 <jimapple> @yow
21:13:06 <lambdabot> I wonder if I ought to tell them about my PREVIOUS LIFE as a COMPLETE
21:13:06 <lambdabot> STRANGER?
21:13:15 <Cale> there's a "quine" :)
21:13:22 <Cale> modulo a single space
21:13:43 <jimapple> what is?
21:13:51 <Cale> @fact: @fact
21:13:52 <lambdabot>  @fact: @fact
21:13:57 <jimapple> nice
21:14:04 <shapr> @msg #haskell @msg #haskell
21:14:04 <lambdabot>  @msg #haskell
21:14:18 <shapr> foo
21:14:23 <jimapple> @msg listcommands
21:14:23 <lambdabot> Not enough privileges
21:14:29 <jimapple> @listcommands msg
21:14:30 <lambdabot> system provides: echo listchans listcommands listmodules uptime
21:14:59 * shapr boings cheerfully
21:15:01 <shapr> It's morning again!
21:15:31 <shapr> I have another chance to write beautiful code, learn powerful concepts, and flirt with a gorgeous woman.
21:15:51 <jimapple> I don't know what just happened, but apparently at Midnight the bald clown starts talking to me through the intarweb
21:16:06 <jimapple> that's probably my cue
21:16:32 <shapr> jimapple: That's definitely quotable.
21:16:56 <jimapple> [bows]
21:17:09 <jimapple> g'night, y'all
21:17:16 <shapr> g'nite jimapple 
21:19:16 <shapr> So, any cool code this morning?
21:19:21 <stepcut> yes
21:19:27 <shapr> ooh, what?
21:20:08 <Saulzar> I've written code for 2 days wtihout attempting to run it - it must be about time to wage war on the typechecker :)
21:20:16 <stepcut> I wrote yet another pickling/serialization library that can derive picklers/unpicklers for arbitrary data types, and a beginnings of a binding to berkeley db 4.4
21:20:46 <stepcut> so, now I can stick arbitrary haskell values in a berkeleydb and get them back
21:20:52 <shapr> neato
21:21:08 <Saulzar> pickling = binary serialization?
21:21:24 <stepcut> Saulzar: in this case, yes
21:21:32 <stepcut> not sure if it has other meanings
21:24:06 <jethr0_> shapr: my autogenerated tree-walker is done. i can already add code inside any expression (like automatically adding trace commands for specific functions)
21:24:53 <jethr0_> and it's only 67 lines of code ^_^
21:25:10 <shapr> Wow cool!
21:25:32 <jethr0_> i'm not sure whether it'll ever be usable for AOP, but it was worth a try
21:26:28 <shapr> Niftiness counts for much.
21:26:44 <stepcut> shapr: I am also working on something similar to haskelldb -- except it does all the query optimizations in the relational algebra domain. I may later tie the two together and make a relational database that can store arbitrary haskell datatypes and use haskell expressions in the queries
21:26:55 <jethr0_> exactly. and although writing meta-code that produces meta-code can produce quite the headache, it makes for _dense_ code
21:28:33 <Pseudonym> Must away.
21:28:34 <Pseudonym> Nytol!
21:31:21 <Saulzar> jethr0_, By autogenerated tree walker you mean folds/maps etc. over trees or?
21:32:12 <jethr0_> i mean code that will traverse a TemplateHaskell AST and apply transformations, automatically generated by TH :)
21:33:32 <Cale> It would be really cool to be able to serialise thunks to disk.
21:33:53 <Saulzar> Hmm, ok - I don't really follow, but I don't know what TemplateHaskell is :)
21:34:24 <Cale> Saulzar: compile-time metaprogramming for Haskell -- you can manipulate syntax trees at compile time
21:34:26 <lispy> is it hard to start a company?
21:34:53 <shapr> nah
21:34:55 <Saulzar> Serialising functions seems rather hard 
21:35:06 <jethr0_> lispy: i guess it's hard to keep it alive until it's producing revenue. and you'd need some initial capital
21:35:08 <lispy> Cale: serialize thunks?  for what swapping them out?
21:35:09 <shapr> lispy: Starting a company and writing code is easy.
21:35:28 <lispy> shapr: sweet!
21:35:36 <Cale> lispy: say, to save the state of your program without forcing further evaluation
21:35:57 <shapr> lispy: It's also easy to find scut work that'll keep you from starving. Becoming more successful is hard though.
21:36:01 <lispy> Cale: but the OS already does that many times a second :)
21:36:17 <lispy> shapr: what is scut?
21:36:23 <shapr> drudge work
21:36:25 <Cale> lispy: yes, but it would be nice to control it :)
21:36:26 <lispy> ah
21:36:36 <dons> stepcut, got a link for your pickle code?
21:36:56 <lispy> shapr: but i do druge work now....
21:37:06 <shapr> Like, I get paid to build websites. I do not get paid to exploit the curry-howard isomorphism. But maybe I lack the right contacts, and maybe you don't.
21:37:15 <lispy> it would be fun to write COOL programs using something fun like Haskell
21:37:26 <shapr> Yeah, but cool work doesn't pay so much.
21:37:43 <Cale> It would be fun to write a program which exploits the Curry-Howard isomorphism to build websites.
21:37:49 <lispy> shapr: i was thinking my clients should be superheros
21:37:50 <Cale> hehe
21:37:52 <shapr> I've increased my fun quotient by using for my daily paying work, my xmlrpc unit tests are one recent example.
21:38:11 <shapr> "using Haskell"*
21:38:15 * lispy nods
21:38:24 <lispy> i may be using xmlrpc at work, not sure tho
21:38:31 <lispy> lots of VB programming so far
21:38:31 <shapr> lispy: On the other hand, I work from home, and that totally rocks.
21:38:42 <shapr> My commute time is however long it takes me to fold my futon up into a couche.
21:38:50 <lispy> hehe
21:39:30 <shapr> I have a gorgeous woman sleeping next to me right now while I do paying work.
21:39:33 <lispy> VB is a not fun language, but at the same time, i don't miss micromanaging memory
21:40:08 <stepcut> Cale: i sounds to me like these people have figured out the hard parts of saving thunks to disk -- since they appear to be able to send them over the network: http://www.macs.hw.ac.uk/~trinder/papers/TFP03-mhaskell.pdf
21:40:24 <Cale> stepcut: :)
21:40:24 <shapr> lispy: I repeat this mantra to myself "Any kind of programming is more fun than digging ditches."
21:40:35 <lispy> only a computer scientist would view the network and a disk as the same objects :)
21:40:41 <dons> unless those ditches exploit the curry-howard isomorphism
21:40:44 <lispy> shapr: yup
21:40:47 <shapr> true!
21:40:54 <stepcut> dons: hold on, I was about to add the pickling code to darcs and push it to my server
21:41:14 <lispy> dons: my brother digs ditchs and he has yet to mention Curry, Howard or isomorphisms
21:41:26 <lispy> pickling?
21:41:35 <lispy> stepcut: what is this darcs enhancement i hear?
21:41:43 * lispy perks up an ear
21:41:58 <shapr> Oh, one big advantage of programming is that even a PHP job can be 'amplified' by the good practices like ubiquitous automation, code generation, version control, etc.
21:42:25 <lispy> i wish we had version control at work.  I'm told to stay away from it unless we have a big projec
21:42:36 <dons> told to stay away from it? 
21:42:38 <dons> oh wow
21:42:39 * lispy plans to install darcs on thursday
21:42:45 <shapr> lispy: That's total fornication, INSTALL DARCS.
21:42:54 <Cale> stepcut: something like that would turn Haskell into the perfect network language :)
21:43:26 <sieni> lispy: wtf?
21:43:32 <shapr> lispy: 1. Buy a copy of The Pragmatic Programmer. 2. Convert your coworkers.
21:43:39 <lispy> shapr: only thing i'm worried about is that i'm on windows and darcs is flakiest in winders
21:43:50 <sieni> lispy: the people at your work are idiots
21:44:03 <shapr> Seriously, can you afford a copy of tPP?
21:44:04 <lispy> shapr: that one missed my christmas list, but maybe i'll get some christmas cash and buy it
21:44:11 <sieni> lispy: even cvs is better than nothing at all
21:44:29 <lispy> well, they use visual source safe for the two big projects
21:44:37 <stepcut> dons: darcs get http://www.n-heptane.com/nhlab/repos/BerkeleyDB
21:44:50 <shapr> VSS is crap.
21:45:11 <Cale> hmm, oh
21:45:23 <Cale> they just smash things into normal form before communication
21:45:28 <sieni> I wouldn't trust visual source safe
21:45:45 <shapr> I used VSS for a coupla years, we lost the whole repo six or eight times.
21:45:57 <shapr> Had to rebuild from whatever checkouts we had.
21:45:57 <lispy> they are most familiar with cvs, so i told them at a minimum they should start using subversion
21:46:29 <stepcut> dons: the code is not really ready for use, and the template haskell code is a nightmare to read
21:46:30 <shapr> Yeah, svn would be better than vss or cvs for a centralized company setup.
21:46:41 <shapr> stepcut: Want to publish it as a TMR article?
21:46:49 <dons> stepcut, just wanted to get an idea.
21:47:06 <shapr> jethr0_ wrote a cool Template Haskell Tutorial recently.
21:47:15 <jethr0_> *yeah*
21:47:19 <shapr> We could have a TH themed TMR issue.
21:47:19 <stepcut> shapr: eventually, there is still a fair bit of work to get it ready, but my unixs pipes library may be about read to publish -- i think I have squashed the last know bug
21:47:27 <lispy> stepcut: what does your code do?
21:47:33 <shapr> I *really* want a TMR issue for Xmas!
21:47:54 * lispy had an idea for a haskell extension, but hasn't had time to work out any details
21:47:57 <jethr0_> shapr: not much time til xmas...
21:48:01 <Cale> ah, but they don't do it for functions
21:48:03 <Cale> okay
21:48:05 <shapr> jethr0_: Yeah, I know.
21:48:13 <stepcut> dons: Binary contains the pickling code, DStore has the TH code to derive new picklers 
21:48:17 <Cale> So I suspect that it's optional anyway :)
21:48:20 <shapr> Who can I ask for TMR articles?
21:48:22 <stepcut> lispy: which code ?
21:48:45 <dons> stepcut, so you've implemented a Binary class parameterised by a monad?
21:48:55 <jethr0_> i looked at the dates of the prior TMRs and there's some kind of irregularity between the last one and the extrapolated next one. if i could only figure out what it is :)
21:48:59 <stepcut> dons: something like that
21:49:14 <lispy> stepcut: you mentoined darcs
21:49:18 <shapr> jethr0_: I publish whenever there are more than five articles.
21:49:27 <shapr> jethr0_: And I try to aim for the first of the month.
21:49:31 <dons> stepcut, what benefit does the monad parameter provide? what was the motivation?
21:50:05 <dons> do you need other m's, where m /= IO ?
21:50:25 <stepcut> lispy: I just meant I was using darcs to store my code, and that would allow dons to do a darcs get on it shortly :p
21:50:33 <stepcut> dons: let me look at it an see :p
21:50:40 <dons> ah, this overlap with Storable is interesting
21:50:48 <jethr0_> shapr: some of the prior articles were awsome... thanks for the idea
21:51:22 <jethr0_> the idea of having sth like TMR, that is
21:51:27 <shapr> lispy: If you want to start your own company, completely kick ass at your existing job, then do contract work for them after you leave. That builds your social contacts and gives you some bread and butter work.
21:51:46 <dons> hehe, stepcut, and we have yet another name for the two class methods: binary/unbinary, to go with get/put and serial/deserial :)
21:51:49 <shapr> jethr0_: I had the idea, but boegel pushed me to make it real. boegel contributed lots of cheerleading and work for the first issue.
21:52:02 <dons> I think SerTH has another set of names as wel.
21:52:24 <shapr> jethr0_: And the many TMR authors get credit for the work they've done.
21:52:35 <Cale> heh, the opposite of pickling should be cucumbering
21:52:36 <stepcut> dons: if I understand your question correctly, the answer is something like this -- the serialization code just worries about converting a haskell value into a stream of Word8 -- but it does care where those bytes go or where they come from. I wanted to be able to serialize directly to a (Ptr Word8) for example
21:52:42 <shapr> jethr0_: For example, you!
21:52:55 <jethr0_> sure, but i'd still hope that sth like this could be maintained. it's a pretty cool institution
21:52:56 <shapr> Cale: Hey, want to write a laziness article before xmas?
21:53:02 <dons> stepcut, yep. I see. very nice :)
21:53:13 <shapr> jethr0_: I'm hopeful, but it's getting harder and harder to find authors.
21:53:20 <Cale> shapr: Philippa was talking about doing an article with me
21:53:21 <stepcut> dons: writing to a Ptr Word8 may require you to be in the IO monad, but just returning a [Word8] does not
21:53:23 <lispy> shapr: okay, thanks for the advice
21:53:26 <Cale> shapr: on monads
21:53:31 <Cale> (another one :)
21:53:40 <jethr0_> writing a tutorial as you learn the subject is taxing and rewarding at once... hopefully i can do it again sometime
21:53:43 <stepcut> dons: oh the names are horrible, that is one of the first things I am going to change
21:53:45 <shapr> I stop bugging people if they've written one article for TMR, I feel like they've paid their dues sort of.
21:53:59 <dons> no no, the names are ok :) just noting that every binary library uses different names
21:54:00 <Cale> hehe
21:54:21 <stepcut> dons: yeah -- and to make things worse, I maintain NewBinary :p
21:54:27 <shapr> Oh! I need some clueful sound engineer person for the next TMR.
21:54:32 <shapr> I have SPJ saying "Haskell"
21:54:39 <dons> stepcut, oh true! 
21:54:40 <stepcut> shapr: I am somewhat clueful
21:54:55 <Cale> shapr: how does he pronounce it? :)
21:54:58 * araujo doesn't feel like doing anything
21:55:03 <araujo> I am lazy.
21:55:06 <shapr> stepcut: Cool, can you clean up and snip apart the sound sample?
21:55:13 <lispy> araujo: i want to do a ton, but it's actually my bed time...
21:55:13 <stepcut> shapr: sure
21:55:20 <shapr> g'nite lispy!
21:55:22 <lispy> i got stuck shopping tonight instead of doing cool stuff
21:55:23 <stepcut> shapr: jeremy at n-heptane dot come
21:55:50 <shapr> stepcut: http://www.scannedinavian.org/~shae/spj-haskell.wav
21:56:03 <araujo> lispy, not me... i think i would just like to watch the clouds at most.....
21:56:03 <shapr> Cale: As opposed to http://www.scannedinavian.org/~shae/shapr-haskell.wav
21:56:38 <shapr> I can't ever stop, but Ritalin lets me cut that energy into half hour chunks into of thirty second chunks.
21:57:00 <lispy> heh
21:57:49 <stepcut> dons: my code is a bit of a combination between SerTH and NewBinary -- using SerTH to serialize a lot of small values was painful, it seems more tuned to serializing one big thing
21:57:50 <Cale> shapr: I pronounce it more like SPJ
21:57:52 <shapr> stepcut: SPJ said Haskell a bunch of times, can you clip out and clean up your choice of the best time?
21:58:02 <stepcut> shapr: sure
21:58:16 <shapr> stepcut: And if you want clean up mine, I'll include it for humorous contrast.
21:58:19 <stepcut> shapr: tomorrow (it is almost 10pm here)
21:58:37 <shapr> Sure, sometime in the next five days is fine. I want an Xmas issue of TMR.
21:58:40 <Saulzar> It all depends on the length of the "ell"
21:58:49 <shapr> Anyone want to make a christmas logo? :-)
21:59:02 <shapr> Cale: Think you can do an article by xmas? 
21:59:09 <jethr0_> a lambda might be a nice basis for some kind of tree :)
21:59:24 <stepcut> dons: the other thing I have been thinking about is the difference between pickling things vs parsing binary formats (like wav files, network data, etc)
22:00:18 <stepcut> dons: in pickling, you can read and write data however you feel -- ignore endianess, etc. But to read a .wav file, you have to be able to read both big and little endian integers :-/
22:00:26 <lispy> shapr: i only get, "Hi my name"
22:00:29 <dons> yeah, it's a little more tricky
22:00:51 <shapr> lispy: works for me, try downloading again?
22:00:55 <Cale> shapr: hmm -- ask Philippa about it, as what she was mentioning sounded like something I'd like to collaborate on. If I was to do one on laziness, what should the length be like?
22:00:59 <dons> but something that would be nice to tackle in a good typeclassy haskelly way
22:01:05 <lispy> shapr: yeah, downloaded it twice now
22:01:45 <stepcut> dons: I am not sure if the two should be keep completely seperate, or somehow merged -- but, currently the naming pickle/unpickle hopefully prevents people from thinking they can read 'arbitrary' binary data with it
22:01:49 <shapr> Cale: 'Begin at the beginning, go to the end, then stop.' as Lewis Carrol said.
22:01:57 <Cale> hehe
22:02:03 <shapr> Cale: Somewhere between one page and seventy five pages.
22:02:12 <lispy> shapr: 44kb
22:02:53 * stepcut goes off for a bit
22:03:06 <lispy> http://dvdrewinder.com/index.php?main_page=product_info&cPath=1&products_id=1
22:03:11 <lispy> that's a nice gift
22:03:12 <shapr> lispy: yup, 44k and "Hi my name is Shae Erisson, and I pronounce Haskell as Haskell."
22:03:25 <Cale> aha, I do still have an account -- I'd just forgotten what my password was :)
22:04:30 <lispy> hask-kell
22:04:34 <lispy> er has-kell
22:04:45 <lispy> i'm more of a haskul sayer
22:05:01 <lispy> shapr: it was a problem with mplayer i guess
22:05:05 <Cale> haskl
22:05:21 <shapr> HASkl
22:05:22 <Cale> well, really, there's a little schwa in there
22:05:28 <shapr> That's sort of how SPJ says it.
22:05:32 <araujo> shapr, you pronounce it similar to me!
22:05:39 <shapr> I've been saying hasKL for years, but it's WRONG!
22:06:01 <shapr> Oh, I spent a few hours searching for actual sound recording of Haskell B. Curry's name, with no luck.
22:06:14 <shapr> If anybody knows of something, that would fit perfectly into this TMR issue.
22:06:15 <araujo> hAskell
22:06:27 <araujo> HAskell
22:06:30 <araujo> Better...
22:07:34 <jethr0_> i guess obscure mathematician/logicians weren't the hottest topic of radio conversation at the time
22:07:36 <Cale> shapr: that "output left in -" bug in the syntax highlighter is annoying. As you might have noticed, you can work around it by chopping long code blocks into segments.
22:08:00 <Cale> I wonder if it happens with python scripts
22:08:52 <lispy> what if find odd is saying Pascal vs. Haskell
22:09:07 <lispy> say Pascal 10 times fast, then say Haskell 10 times fast
22:09:08 <Saulzar> shapr, But there seem to be others with the name (google always seems to show up random unrelated people called Haskell)
22:09:19 <Cale> they sound rather different the way that I say them
22:09:43 <shapr> Cale: I think it's a problem with the way the enscript.py plugin is called.
22:09:50 <lispy> Cale: yes, but i find that i want to end with the wrong sound when i say both of them often
22:10:38 <shapr> Cale: There's a 95% chance the problem is in my code since I hacked the enscript.py from an older version of moin, and hacked it to handle haskell as well. I'd much rather switch to HsColour from malcolm and ndm.
22:11:10 <jethr0_> Saulzar: true, it's a real nuissance; all these random people adding noise to my google search *grr*
22:11:26 <lispy> maybe wikipedia has something about it
22:11:31 <Saulzar> Not so many people with Monad and Haskell in their name though.
22:11:47 <lispy> if it doesn't then whatever you find out about the correct way to say it should be on wikipedia :)
22:12:12 * lispy gets an "I <3 Monads" tattoo
22:12:25 <shapr> haha
22:12:30 <lispy> ">>= 4 Life"
22:12:54 <lispy> or maybe that should be 4 >>= Life
22:16:12 <lispy> i think i might want to be a technical directory and work for someone like Pixar
22:16:21 <lispy> but next well i'll have other dreams and hopes...
22:16:52 * lispy can't type
22:16:58 <lispy> of course i meant "technical director"
22:18:30 <jethr0_> lispy: how about CTO of a multi-million dollar corporation? would that suit you :)
22:18:38 <SlowByte> return 4 >>= Life ;)
22:18:46 <lispy> SlowByte: haha, nice
22:18:47 <shapr> lispy: Just make sure you keep working towards your dreams.
22:18:55 <lispy> jethr0_: probably not.
22:18:59 <shapr> And don't get stuck in a job that sucks you dry.
22:19:05 <lispy> shapr: ah yeah
22:19:05 <jethr0_> :(
22:19:22 <lispy> jethr0_: i'm not really into being a manager
22:19:49 <jethr0_>  but wouldn't a technical directory have to do some managing as well?
22:20:02 <lispy> yeah, maybe...
22:20:44 <lispy> the description i heard was: they work between the artistic people and the software to help automate things and write a lot of one off scripts for people
22:21:33 <jethr0_> writing small perl scripts doesn't sound very director-like to me
22:21:34 <lispy> my dream would be to do something with FP and languages, but had a cool end product such as video games or 3d content
22:22:07 <jethr0_> i'd be content with finding a job in FP, no questions asked
22:22:19 <lispy> jethr0_: academia!
22:22:21 <jethr0_> 3d content?
22:22:26 <shapr> I just can't stand to deliver crappy software.
22:22:35 <lispy> shapr: true
22:22:49 <lispy> shapr: i'll hire you as the Q/A guy!
22:22:52 <jethr0_> lispy: nah, writing my masters thesis was torture to me.
22:23:16 <lispy> jethr0_: i may have lost my chance at a masters by giving up on my topic
22:23:24 <lispy> my topic was lame
22:23:34 <jethr0_> what was your topic?
22:23:38 <lispy> and i decided that a well funded masters that i despised was not worth it
22:23:52 <lispy> jethr0_: something in HCI
22:23:56 <Saulzar> lispy, I guess that is the most unlikely job to ever exist - games people are well entrenched with C++, those with an "open" mind go for C# :)
22:24:17 <lispy> Saulzar: yeh, but ocaml gives C++'s performance
22:24:20 <jethr0_> well, there _is_ naughty dog with their lisp/scheme based  games
22:24:30 <shapr> What about Frag?
22:24:39 <shapr> I think Yampa would rock for an RTS game.
22:24:42 <lispy> shapr: frag is cool
22:24:58 <jethr0_> is there actually a whole-program compiler for haskell?
22:25:15 <jethr0_> mlton's benchmark results are _amazing_
22:25:33 <lispy> yeah, but would you want to use ml's syntax?
22:25:47 <jethr0_> never tried. it didn't look all that gruesome to me at first glance
22:25:48 <lispy> it's semicolon craziness with lists
22:26:08 <pejo> jethro, doesn't that partically come from the lack of laziness? 
22:26:11 <Saulzar> shapr, I think haskell would be just fine for that kind of work too, but games people love to write assembler for 2D pong to get 4002 fps instead of 3500 :)
22:26:11 <jethr0_> hmm, i'm pretty flexible when it comes to syntax.
22:26:22 <lispy> jethr0_: ocaml isn't that far from haskell, but when you compare the two you can tell that haskell would be a lot nicer to work with
22:26:47 <jethr0_> pejo: maybe, but with a smart compiler much of the cost of lazyness might be optimized away (i'm just blabbering naively :)
22:27:00 <pejo> jethro, err, partially. It's too early in the morning for me.
22:27:02 <lispy> Saulzar: well, until recently video game industry has been all about proof of concept.
22:27:02 <jethr0_> lispy: i did and decided to go with haskell
22:27:40 <araujo> Haskell is cleaner than ocaml i'd say
22:27:43 <Saulzar> I hated the mutability with ocaml... it lets me write code like C++ too easily, and haskell's syntax was too appealing :)
22:27:52 <lispy> i think if i'm doing interactive things that ocaml is probably a safer choice where performance matters. But Haskell is so nice to work with...
22:28:01 <Saulzar> lispy, What do you mean?
22:28:27 <shapr> Frag looked pretty interactive to me.
22:28:34 <shapr> hiya ccshan 
22:28:38 <lispy> Saulzar: my (admittedly limited) experience with interactive performance driven things shows that haskell is much slower than C++
22:28:45 <ccshan> hi shapr
22:28:54 <jethr0_> the hardware stuff will have to be opengl and some c anyways. but anything on top could well be written in a well-optimized functional language
22:29:03 <lispy> shapr: yeah, frag is cool :)
22:29:11 <dons> yeah, it's just opengl anyway
22:29:29 <shapr> I haven't gotten around to reading Mun's thesis yet though.
22:29:38 <lispy> there is quite a bit of non-opengl too in a 3d game engine
22:30:01 <Saulzar> Most of the performance issues in games is in the rendering, and you can rig that up just as easily with Haskell. But things like physics, pathfinding etc. is all CPU intensive too
22:30:05 <dons> and all the logic you really want to write in haskell anyway
22:30:05 <araujo> I am probably not from this planet.. but ive never paid attention to a language because of its speed.
22:30:24 <jethr0_> i looked at the frag code to find out how to invert mouse y-axis, and the mouse events are taken from opengl and put back into opengl. so at the moment (at least for me) it was hard to do any changed to those IORefs
22:30:35 <araujo> It is not like the universe is gonna be destroyed because my appli run 0.0001 slower than yours.
22:30:57 <dons> oh araujo, sssh! you'll spoil the fun ;)
22:31:01 <Pupeno> Hello araujo.
22:31:05 <jethr0_> araujo: well, haskell can be many 10s times slower than C...
22:31:06 <shapr> Anyway, I think that code as communication beats anything else.
22:31:10 <jethr0_> unoptimized that is
22:31:15 <lispy> araujo: no, but with games the fun could be decreased if you get 12 fps instead of 24
22:31:16 <araujo> I care more that you can express your idea just like you thought them
22:31:25 <araujo> dons, :-)
22:31:27 <araujo> Hello Pupeno 
22:32:01 <pejo> araujo, many agree on that standpoint. Too bad there aren't more people working on how to get efficient code out of it. :-)
22:32:08 <Pupeno> I used not to care about performance untill I used Zope (a web server, written in Python, that needs lot's of CPU and memory). So, I am not performance-fanatic/driven, but I take a look at it.
22:33:40 <Saulzar> Hmm, is it possible to make primitive types in Haskell from C/asm which are "pure"? Rather than driving everything through IO?
22:34:05 <dons> yep
22:34:17 <Cale> Saulzar: well, if the C functions are pure, then yes
22:34:17 <dons> you can import pure foreign stuff, if you like.
22:34:19 <Saulzar> Good math libraries where it matters in C would probably help no end for things like games
22:34:41 <Saulzar> Ah, cool.
22:34:43 <dons> @version
22:34:43 <lambdabot> lambdabot 3p259, GHC 6.5.20050806 (Linux i686)
22:34:43 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:34:51 <araujo> lispy, games are not the only programms.
22:35:24 <lisppaste2> jethr0 pasted "meta-meta-code" at http://paste.lisp.org/display/14830
22:35:32 <araujo> lispy, I meant, they are not the only programms who should define what you do with a computer.
22:35:43 * Pupeno has just packaged network-alt for (k)ubuntu.
22:35:47 <lispy> Saulzar: yes, but then you're suggesting writing should be a beautiful algorithm using C! :)
22:35:48 <araujo> s/who/that/
22:36:22 <Saulzar> lispy, Well, just things like vectors, matrices... maybe intersection tests (bounding boxes and whatnot)
22:36:30 <lispy> araujo: no, but i was talking about making games and game like things using FP and saying that i left ocaml was a more natural choice for that than haskell :)
22:36:46 <lispy> s/left/felt
22:36:49 <araujo> lispy, i don't agree. Have you tried House?
22:37:10 <Saulzar> I'm sure my haskell raytracer was several times slower than an equivalent simple C++ raytracer
22:37:16 <araujo> lispy, It comes with a GUI written in Haskell , and it perfomaces very well.
22:37:19 <lispy> araujo: the microkernel from ghc sources?
22:37:23 <araujo> Yes.
22:37:36 <lispy> araujo: i haven't tried it
22:37:42 <araujo> Give it a try.
22:37:45 <araujo> It is nice.
22:38:00 <Pupeno> microkernel ?
22:38:13 <araujo> I am not too much into GUI programmng _yet_ , but that shows it is possible to have a jnice GUI written in Haskell.
22:38:44 <lispy> araujo: i might, i like to play with OSs but i don't have a machine to play with it on at the moment.  Maybe I can use bochs, but that won't give me a performance feel
22:39:07 <Saulzar> Several times slower than C can still perform very adequately for simple graphics I'm sure
22:39:12 <araujo> There is a benchmark page also, that shows that GHC does as good as the JSDK.
22:39:15 <lispy> Pupeno: it's a kernel that does the least a kernel can do and the rest is written in "user space"
22:39:19 <jethr0_> lispy: qemu works with house too, i think
22:39:42 <araujo> lispy, It is something very straightforward, you can use qemu or boot from a floppy disk.
22:39:50 <Pupeno> lispy: thanks, I know about the concept, I didn't know there was a microkernel written on haskell
22:40:07 <araujo> They even got this nice qemu image in the web-site now.
22:40:49 <lispy> Pupeno: ah sorry.  Yeah, they use the ghc runtime on the bare metal
22:41:06 <shapr> lispy: You could just play with the pure Haskell TCP/IP stack.
22:42:17 <Pupeno> it seems to be very developed!
22:42:32 <shapr> jethr0_: Hey, you could post a link to your TemplateHaskell TMR article to the template haskell list and ask for feedback.
22:43:29 <jethr0_> shapr: very good idea, i'll do that!
22:44:57 <lispy> so are drivers still written in C?
22:45:09 * Pupeno whishes qemu supported dvorak keyboards.
22:45:33 <lispy> i feel your pain.  I hate it when dvorak is not an option
22:45:46 * shapr agrees aoeuthns
22:46:55 <lispy> man, i was watching videos at videos.google.com and i stumbled on some videos where sexy bikini models teach you basic calculus.
22:47:04 <lispy> there is some seriously weird stuff on the net
22:47:36 <jethr0_> lispy: there are few drivers as of now, but pretty much everything is written in haskell
22:47:40 <shapr> I'd rather be taught by bikini models.
22:47:59 <SlowByte> lispy: URL! URL! ;)
22:48:24 <shapr> My girlfriend teaches me saxophone and Swedish, and that's quite successful.
22:48:32 <lispy> SlowByte: www.howtodogirls.com
22:48:54 <SlowByte> haha, that name certainly is... ambiguous
22:49:03 <lispy> yeah :)
22:49:13 <lispy> and the site is really slow
22:50:45 <shapr> All the episodes are available by BitTorrent though.
22:51:09 <lispy> and google video
22:51:34 <shapr> Wow, mathpr0n
22:51:41 <shapr> Never thought I'd see such a thing.
22:52:14 <stepcut> i saw some really awful video with a girl showing you how to hack computers with nmap once..
22:52:32 <stepcut> http://www.insecure.org/nmap/nmap_haxxxor.html
22:53:33 <stepcut> haXXXor porn -- no longer floppy
23:02:33 <jethr0_> i very much doubt that you'll learn any maths from those videos *tststs*
23:04:16 <SlowByte> hmm, can anyone comment on "The Topos of Music"? looks like an interesting book, about topology *and* music theory (double what you learn! ;)
23:04:48 <SlowByte> it's a hefty ~1.4kpages
23:12:17 <lispy> is the haskell top level grammar pretty tight or is there a lot of room for adding stuff?
23:13:46 <jethr0_> lispy: i don't even understand the question. do you want to extend haskell at compiler level?
23:13:55 <lispy> jethr0_: yes
23:14:11 <lispy> i wanted to add something optional for function bodies
23:14:24 <lispy> something at the same level as type signatures for functions that is
23:14:50 <lispy> ah, here it is section 9.5 of the report i think
23:14:57 <jethr0_> :)
23:20:05 <lispy> looks like i could add a production to gendecl and be okay
23:21:01 <Cale> lispy: what would this be?
23:21:37 <Cale> (what are you adding?)
23:24:24 <tennin> lispy, do you have anything specific in mind for a game project?
23:30:45 <lispy> tennin: nope, i was most recently thinking it would be fun to implement radiosity
23:31:02 <lispy> Cale: i'm playing with syntatic sugar for pre and post conditions
23:31:29 * shapr wonders, unicycling now or later?
23:31:56 <lispy> shapr: both!
23:32:12 <shapr> Good idea!
23:32:15 <sieni> unicycle might be quite a respectable way of transportation on our office corridors
23:34:26 <jethr0_> ok g'nite
23:34:27 <lispy> well, night all
23:34:27 <shapr> With unicycles, speed depends on wheel size.
23:34:35 * shapr starts real work...
23:41:29 <ski> Cale : palomer is right about that in pure CPS, there is no returning ... 'getChar :: (Char -> Answer) -> Answer'  'putChar :: Char -> Answer -> Answer'
23:48:51 <audreyt> @seen dons
23:48:51 <lambdabot> dons is in #haskell. Last spoke 1 hour, 14 minutes and 8 seconds ago.
23:48:52 <Cale> ski: but it doesn't seem to me that such things are actually functions
23:48:57 <audreyt> dons: hsplugins-release-p?
23:49:15 <ski> Cale : depends on what you mean by 'function' :)
23:49:37 <ski> pre-monad haskell actually did I/O in this way
23:50:00 <ski> (in a way)
23:50:35 <ski> (Cale : but .. palomer was wrong to use '()' answer type)
23:50:47 <ski> (s/answer/as answer/)
23:51:05 <Cale> Can one ever get hold of a value of type Answer?
23:51:10 <ibid> wasn't the pre-monad haskell IO in the style main :: [Respose] -> [Request]
23:51:48 <ski> ibid : yes
23:52:02 <ski> here, Answer = Dialogue = [Respose] -> [Request]
23:52:50 <Cale> hmm
23:53:05 <ski> there are several interesting points, here
23:53:24 <Cale> how does putChar know how to modify the dialogue function?
23:53:56 <Cale> Or does it return a constant function which makes the necessary request?
23:54:31 <ski> putChar c k ~(PutOk:resps) = PutChar c : k resps
23:54:43 <ski> something like that, iirc
23:54:46 <ibid> ski: yes, it supports both styles actually
23:55:10 <ski> ibid : yes .. though it's easier not to screw up, using the CPS style
23:55:23 <ski> (and of course that style can be captured in a monad)
23:55:30 <ibid> Cale: see the haskell 1.2 report, page 69 onward
23:55:34 <Cale> okay
23:55:39 <ibid> ski: true :)
23:55:41 <ski> newtype IO a = MkIO ((a -> Answer) -> Answer)
23:56:09 <ibid> Cale: http://haskell.org/definition/haskell-report-1.2.ps.gz
23:56:13 <Cale> Well, that answered my question :)
23:56:19 <jethr0_> i'm trying to find the title of the book about typing autrijus mentioned in one his interviews. tppa or tpaa or sth
23:56:24 <ski> Cale : anyway, this pre-monad-haskell relates to CPS
23:56:35 <ski> but, in pure CPS, no function ever return
23:56:51 <ski> or rather, we are not dealing with functions, but rather continuations :)
23:56:52 <ibid> newtype IO a = MkIO ([Response] -> ([Request, a))
23:56:56 <ibid> :)
23:57:07 <ski> (instead of functions simulating continuations)
23:57:14 <Cale> ski: it's really the use of the term "function" that I'm more concerned with :)
23:57:21 <ibid> hmm, or does that work?
23:57:24 <ibid> probably
23:57:32 <jethr0_> ski: what about the function that doesn't call its continuation?
23:57:35 <ski> Cale : a -> Void  ~=  Cont a
23:58:01 <ski> jethr0_ : what about it ?
23:58:23 <Cale> ski: If a is nonempty, there are no functions of that type.
23:58:27 <ski> (jethr0_ : except that it's not a real pure function, i.e.)
23:58:39 <ski> Cale : right
23:58:59 <ski> a -> b  ~=  Cont (a,Cont b)
23:59:03 <Cale> and if a is empty, there's just one, and it's not very interesting :)
23:59:09 <ski> (s/Cont/Not/ if you like)
23:59:46 <jethr0_> ski: well it returns, doesn't it
23:59:48 <ski> a function is a continuations that accepts a pair of a value of type 'a' and a continuation that accepts value of type 'b'
