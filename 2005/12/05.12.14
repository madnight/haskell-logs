00:00:06 <jethr0> it has to be a legal declaration or expression
00:00:07 <Taral> $pretty a = do { if x then do { return 1 } else z }
00:00:07 <jethr0_bot> #  a = do if x then do return 1 else z
00:00:14 <Taral> $pretty a = do { if x then do { m; m; o } else z }
00:00:15 <jethr0_bot> #  a = do if x then
00:00:15 <jethr0_bot> #           do m
00:00:15 <jethr0_bot> #              m
00:00:15 <jethr0_bot> #              o
00:00:15 <jethr0_bot> #           else z
00:00:18 <Taral> hm
00:00:20 <jethr0> hehe
00:00:26 <Taral> seems reasonable
00:00:36 <Taral> I don't personally indent that way, but the do { if then else} problem is annoying
00:00:37 <jethr0> hmm, still improvable :(
00:00:48 <Taral> I keep wanting to align the else with the if and it won't let me
00:00:54 <Taral> so I end up with stuff like
00:00:55 <Taral> if cond
00:00:57 <Taral>   then
00:00:58 <jethr0> the then/else indentation is still bad
00:00:59 <Taral>     ...
00:01:00 <Taral>   else
00:01:02 <Taral>     ...
00:01:18 <jethr0> i'll have to work on that
00:01:43 <jethr0> $pretty fun x | x < 5 = 2 | x < 7 = 3 | x == 8 = 6 | otherwise = 7
00:01:43 <jethr0_bot> #  fun x  | x < 5 = 2
00:01:43 <jethr0_bot> #         | x < 7 = 3
00:01:43 <jethr0_bot> #         | x == 8 = 6
00:01:43 <jethr0_bot> #         | otherwise = 7
00:01:47 <jethr0> ahh
00:02:16 <Taral> what's with the extra space after "fun x"?
00:02:22 <jethr0> never mind
00:02:38 <jethr0> language.haskell.pretty is not exactly configurable :(
00:02:52 <jethr0> i'm happy it works as well as it does
00:03:09 <jethr0> $pretty fun longVar = 3; fun _ = 2
00:03:09 <jethr0_bot> #  fun longVar = 3
00:03:09 <jethr0_bot> #  fun _ = 2
00:03:21 <jethr0> although the equal signs should be aligned *grr*
00:04:03 <Korollary> Gah, I seem to have missed the OOP bashing session. Oh well.
00:04:19 <jethr0> you can carry it on with me :)
00:04:36 <jethr0> let's have a premeditated flamewar!
00:04:55 <Korollary> I have to pick apart the classes that some moron thought would be a good design at work.
00:05:03 <Taral> when was the OOP bashing sessioN?
00:05:15 <jethr0> some hours ago
00:05:20 <Korollary> Taral: about two hours ago judging by the scrollback
00:05:34 <moonfish> is it a scheduled, regular event? ;)
00:05:53 <Korollary> Ok, who in his right mind would register a class' private method as a callback? What's he thinking?
00:05:54 <jethr0> OOP software that i know tends to degrade disgracefully :)
00:06:10 <Speck> instance Monad m => Arrow (Kleisli m)   <-- does this mean I can make an arrow instance for any monad 
00:06:26 <jethr0> korollary, why not? that's by far not the worst i've seen!
00:06:49 <jethr0> yes
00:06:56 <Korollary> jethr0: yeah, I've seen worse (a la www.dailywtf.com), but this was not supposed to happen.
00:07:12 <jethr0> i'm not sure whether private callback is a wtf
00:08:15 <Korollary> Well, passing a pointer to a private method of yours contradicts with the encapsulation you're trying to achieve when you made it private in the first place.
00:08:42 <jethr0> ok, when you see it like that? what language?
00:08:49 <jethr0> that!*
00:09:06 <Korollary> C++. This is puzzling. How does *this get passed in to such a callback? Hmmm.
00:09:25 <Korollary> maybe it was a static method as well. I don't remember.
00:09:52 <jethr0> i'm not sure whether access control is done at runtime at all... so i'd guess this wouldn't be affected. but then i've no idea what i'm talking about :)
00:09:53 <Taral> Korollary: No, passing a private method as a callback is not an encapsulation violation.
00:10:11 <jethr0> c++ has no member function "pointers"...
00:10:22 <Korollary> Taral: I didn't mean a violation in the language sense. I meant it in the principle sense.
00:10:24 <Taral> gnu c++ has some extension to support that, I believe.
00:10:26 <jethr0> or at least not trivially
00:10:30 <Taral> Korollary: I meant that too.
00:10:40 <jethr0> STL allows mem_fun_ptr and stuff
00:10:44 * Speck wonders if there is any use in an kleisli arrow instance over the STM monad
00:10:54 <jethr0> *aahh*
00:11:04 <Taral> private methods are not arbitrarily callable by outsiders
00:11:10 <jethr0> it's not gonna make things easier!
00:11:14 <Taral> but they can be called by outsiders if explicitly exported as a member function pointer
00:11:15 <jethr0> taral, sure?
00:11:29 <Gs30ng> > listArray ((0,0), (2,2)) [1..]
00:11:30 <lambdabot>  Not in scope: `listArray'
00:11:37 <Gs30ng> > Array.listArray ((0,0), (2,2)) [1..]
00:11:38 <lambdabot>  Not in scope: `Array.listArray'
00:11:44 <jethr0> i thought if you could get hold of a "pointer" to one, you could call it from wherever you liked
00:12:04 <jethr0> @type Data.Array.listArray
00:12:05 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
00:13:05 <Taral> jethr0: Yes, but only on the instance that was exported
00:13:17 <Taral> and generally only for the lifetime of the call that received it.
00:13:33 <Korollary> Taral: That's still language semantics. It's like returning a pointer to your private members. When I look at a private var, I don't want to think if there are any pointers exported allowing access to it. Well, that's my principle anyway.
00:13:34 <jethr0> sure?
00:13:42 <Taral> Korollary: True.
00:13:59 <Taral> jethr0: It's all about how you define your semantics, as Korollary implies.
00:13:59 <Gs30ng> the index goes like [((0,0),1),((0,1),2),((0,2),3), ...], and i want it to go like [((0,0),1),((1,0),2),((2,0),3), ..]. i mean, x-coord to increase first
00:14:13 <Gs30ng> can i achieve this with normal listArray function?
00:14:22 <Taral> Generally, any callback parameter has specific lifetime and use semantics.
00:14:42 * araujo gets some ice-cream
00:15:16 <Taral> I also note that generally you cannot use a PMF where a standard function pointer is expected.
00:15:43 <jethr0> taral, you might be right...
00:16:00 <jethr0> gs30ng, the indices are sorted by Array that way!
00:16:10 <Taral> PMFs have declaration "returntype (Class::*name)(params)"
00:16:14 <jethr0> independently of the order you put them in there
00:16:36 <Gs30ng> i mean with listArray function
00:16:39 <Korollary> Taral: Right, the implicit *this.
00:16:47 <Gs30ng> it's like "123\n456\n789"
00:16:53 <Taral> @type listArray
00:16:54 <lambdabot> Not in scope: `listArray'
00:16:57 <Taral> @index listArray
00:16:57 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
00:16:59 <Cale> Gs30ng: no, you have to use array for that
00:17:02 <Taral> @type Data.Array.IArray.listArray
00:17:03 <lambdabot> forall e i (a :: * -> * -> *).
00:17:03 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
00:17:03 <lambdabot> (i, i) -> [e] -> a i e
00:17:07 <Taral> @type Data.Array.IArray.array
00:17:08 <lambdabot> forall e i (a :: * -> * -> *).
00:17:08 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
00:17:08 <lambdabot> (i, i) -> [(i, e)] -> a i e
00:17:11 <Gs30ng> Cale, I don't get you
00:17:17 <jethr0> gs30ng, as soon as you get them out as list again they'll be sorted (first then second, ascending)
00:17:21 <Gs30ng> i never said i would not use array
00:17:34 <Taral> Gs30ng: If you use array, you can put the indices in any order you want.
00:17:34 <Cale> the 'array' function
00:17:41 <Gs30ng> i mean how can i convert a string to array with it's proper coord index
00:17:56 <jethr0> ??
00:18:01 <Taral> string?
00:18:03 <Cale> strings are usually 1-d
00:18:06 <Taral> where do strings appear?
00:18:07 <jethr0> proper?
00:18:24 <Gs30ng> "123\n456\n789" to be [((0,0),1), ((0,1),4), ...]
00:18:27 * jethr0 is amused by all these questions
00:18:34 <Korollary> ooh
00:18:41 <Korollary> now, decode this
00:18:43 <jethr0> > lines "123\n456\n789"
00:18:44 <lambdabot> ["123","456","789"]
00:18:53 <Gs30ng> since 123 has same y-coord value
00:18:55 <Gs30ng> right?
00:19:21 <Korollary> Do you get the first digit of "123" to form "(0,1),1" ?
00:19:29 <Korollary> err (0,0),1
00:19:36 <Gs30ng> yeah
00:19:41 <Taral> > [ ((x, y), c) | (x, l) <- zip [0..] (lines "123\n456\n789"), (y, c) <- zip [0..] l ]
00:19:42 <lambdabot> [((0,0),'1'),((0,1),'2'),((0,2),'3'),((1,0),'4'),((1,1),'5'),((1,2),'6'),(
00:19:42 <lambdabot> (2,0),'7'),((2,1),'8'),((2,2),'9')]
00:19:47 <jethr0> > transpose . lines $ "123\n456\n789"
00:19:48 <lambdabot> ["147","258","369"]
00:19:52 <Speck> > map ( \((a,b),c) -> ((b,a),c) ) [ ((0,x),x) | x <- [1..] ]
00:19:53 <lambdabot> [((1,0),1),((2,0),2),((3,0),3),((4,0),4),((5,0),5),((6,0),6),((7,0),7),((
00:19:53 <lambdabot> 8,0),8),((9,0),9),((10,0),10),((11,0),11),((12,0),12),((13,0),13),((14,0),
00:19:53 <lambdabot> 14),((15,0),15),((16,0),16),((17,0),17),((18,0),18),((19,0),19),((20,0),
00:19:54 <lambdabot> 20),((21,0),21),((22,0),22),((23,0),23),((24,0),24),((25,0),25),((26,0),
00:19:54 <lambdabot> 26),((27,0),27),((28,0),28),((29,0),29),((30,0),30),((31,0),31),((32,0),
00:19:55 <lambdabot> [24 @more lines]
00:19:58 <Speck> oops
00:20:03 <Gs30ng> transpose seems to work
00:20:06 <Gs30ng> thanks
00:20:12 <jethr0> *yeah*
00:20:16 <Taral> > [ ((x, y), c) | (y, l) <- zip [0..] (lines "123\n456\n789"), (x, c) <- zip [0..] l ]
00:20:17 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((0,1),'4'),((1,1),'5'),((2,1),'6'),(
00:20:17 <lambdabot> (0,2),'7'),((1,2),'8'),((2,2),'9')]
00:20:36 <jethr0> nicely done, taral
00:21:00 <jethr0> althoug a bit long
00:21:03 <Gs30ng> that's the way... i should have been aware of list comprehension
00:21:05 <Taral> what can you do?
00:21:12 <Taral> it's not a trivial build
00:21:21 * jethr0 thinks there's a shorter version
00:25:13 <Taral> be my guest
00:25:25 <jethr0> > zipWith (\x -> zipWith (\y -> (,) (x, y)) [0..]) [0..] (transpose . lines $ "123\n456\n789")
00:25:26 <lambdabot> [[((0,0),'1'),((0,1),'4'),((0,2),'7')],[((1,0),'2'),((1,1),'5'),((1,2),'8'
00:25:26 <lambdabot> )],[((2,0),'3'),((2,1),'6'),((2,2),'9')]]
00:25:38 <jethr0> *damn*
00:25:55 <Taral> > concat $ zipWith (\x -> zipWith (\y -> (,) (y, x)) [0..]) [0..] (lines $ "123\n456\n789")
00:25:57 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((0,1),'4'),((1,1),'5'),((2,1),'6'),(
00:25:57 <lambdabot> (0,2),'7'),((1,2),'8'),((2,2),'9')]
00:26:05 <Taral> nice
00:26:18 <Taral> still longer though
00:26:26 <jethr0> @pl concat $ zipWith (\x -> zipWith (\y -> (,) (x, y)) [0..]) [0..] (transpose . lines $ "123\n456\n789")
00:26:27 <lambdabot> join (zipWith (flip zipWith [0..] . ((,) .) . (,)) [0..] (transpose (
00:26:27 <lambdabot> lines "123\n456\n789")))
00:26:34 <jethr0> hehe
00:26:39 <ProfTeggy> :-)
00:26:41 <Taral> don't bother transposing
00:26:45 <Taral> just swap the coords
00:26:59 <jethr0> @pl concat $ zipWith (\x -> zipWith (\y -> (,) (y,x)) [0..]) [0..] (lines $ "123\n456\n789")
00:27:00 <lambdabot> join (zipWith (flip zipWith [0..] . ((,) .) . flip (,)) [0..] (lines "123\
00:27:00 <lambdabot> n456\n789"))
00:27:04 <jethr0> concat $ zipWith (\x -> zipWith (\y -> (,) (y,x)) [0..]) [0..] (lines $ "123\n456\n789")
00:27:10 <Gs30ng> > [((x, y), v)| y <- [0..2], x <- [0..2] | v <- "123456789"]
00:27:11 <jethr0> > concat $ zipWith (\x -> zipWith (\y -> (,) (y,x)) [0..]) [0..] (lines $ "123\n456\n789")
00:27:11 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
00:27:12 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((0,1),'4'),((1,1),'5'),((2,1),'6'),(
00:27:12 <lambdabot> (0,2),'7'),((1,2),'8'),((2,2),'9')]
00:27:24 <jethr0> not standard
00:27:27 <Gs30ng> > [((x, y), v)| y <- [0..2] | x <- [0..2] | v <- "123456789"]
00:27:28 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
00:27:44 <Gs30ng> [((x, y), v)| y <- [0..2], x <- [0..2] | v <- "123456789"] works on my hugs interpreter
00:28:00 <Taral> Gs30ng: But where did the \n's go?
00:28:05 <C-Keen> re
00:28:16 <Taral> what if the input is "1234\n5\n678\n9"?
00:28:40 <Gs30ng> Taral: well in this case it's no matter for me
00:28:50 <Taral> Gs30ng: Then why do you have a string?
00:28:54 <jethr0> > concat $ zipWith (zip [0..]) [0..] (lines $ "123\n456\n789")
00:28:54 <lambdabot>   Expecting a function type, but found `[(a, b)]'
00:28:54 <lambdabot>   Expected type: [b] -> b1 -> [a]
00:28:54 <lambdabot>   Inferred type: [b] -> [(a1, b)]
00:29:00 <Gs30ng> since the x-length and y-length is known to me
00:29:12 <Gs30ng> Taral: because i'm parsing a txt file
00:29:14 <Taral> is it always rectangular?
00:29:19 <Gs30ng> Yeap.
00:29:30 <Gs30ng> like a chess board or something
00:29:42 <Taral> ok
00:30:00 <Gs30ng> but lambdabot says it's illegal
00:30:10 <Taral> lambdabot isn't running with glasgow extensions
00:30:15 <Taral> doesn't support parallel comprehensions
00:30:32 <Gs30ng> well while Hugs supports it?
00:30:37 <Taral> yes
00:30:38 <Gs30ng> maybe my hugs is weird
00:30:43 <Taral> no
00:30:48 <Taral> lambdabot is ghc based, not hugs based
00:31:15 <Gs30ng> hmm
00:32:28 <Gs30ng> Taral, is there any way to convert the parallel comprehension to standard without any loss? i don't need this right now but just curious
00:32:52 <Taral> Gs30ng: Using zip, the way I was doing it.
00:33:04 <Taral> you have something like...
00:33:17 <jethr0>  > let fun ls = [0..length ls - 1] >>= \x -> [0..length ls - 1] >>= \y -> return ((x,y), ls!!y!!x) in fun (lines $ "123\n456\n789")
00:33:18 <Taral> zip [(x, y) | y <- [0..2], x <- [0..2]] "123456789"
00:33:24 <jethr0> > let fun ls = [0..length ls - 1] >>= \x -> [0..length ls - 1] >>= \y -> return ((x,y), ls!!y!!x) in fun (lines $ "123\n456\n789")
00:33:25 <lambdabot> [((0,0),'1'),((0,1),'4'),((0,2),'7'),((1,0),'2'),((1,1),'5'),((1,2),'8'),(
00:33:25 <lambdabot> (2,0),'3'),((2,1),'6'),((2,2),'9')]
00:33:26 <Taral> > zip [(x, y) | y <- [0..2], x <- [0..2]] "123456789"
00:33:27 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((0,1),'4'),((1,1),'5'),((2,1),'6'),(
00:33:27 <lambdabot> (0,2),'7'),((1,2),'8'),((2,2),'9')]
00:33:34 <Taral> LOL
00:34:03 <Gs30ng> seems like it's successful
00:34:18 <jethr0> taral, i wrote that solution before...
00:34:35 <jethr0>  > zip [(x, y) | y <- [0..2], x <- [0..]] "123456789"
00:34:43 <jethr0> > zip [(x, y) | y <- [0..2], x <- [0..]] "123456789"
00:34:44 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((3,0),'4'),((4,0),'5'),((5,0),'6'),(
00:34:44 <lambdabot> (6,0),'7'),((7,0),'8'),((8,0),'9')]
00:35:05 <mwc> Anybody played around with trying to add support for using Haskell for stored procedures in PostgreSQL?
00:35:14 <Gs30ng> anyway thanks everyone! i always feel the channel is quite grateful for both newbies and experts
00:35:20 <jethr0> :)
00:37:05 * Speck is still toying with making it smaller
00:37:23 <jethr0> smaller than the "zip" version will be hard!
00:37:26 <Speck> (without assuming rectangularity)
00:37:40 <Speck> I think that's more fun
00:37:52 <Taral> jethr0: It's kind of cheaty :)
00:37:57 <jethr0> hehe, that's easy, just give the dimensions to the zip
00:38:00 <jethr0> why?
00:38:55 <Speck> @djinn [[a]] -> [((Int,Int),a)]
00:38:55 <lambdabot> -- f cannot be realized.
00:39:00 <Speck> worth a try
00:40:09 <jethr0> why not use listArray? you just have to rearrange the list for that!
00:41:29 * Itkovian decides to hang out here more often
00:42:08 <jethr0> why doesn't the eval guy know listArray?
00:46:20 <jethr0> basically you only need to do: "listArray $ concat . transpose . lines
00:47:05 <jethr0> Data.Array.listArray ((0,0),(2,2)) (concat . transpose . lines $ "123\n456\n789")
00:50:34 <jethr0> > zip (map reverse $ sequence [[0..2],[0..2]]) "123456789"
00:50:35 <lambdabot> [([0,0],'1'),([1,0],'2'),([2,0],'3'),([0,1],'4'),([1,1],'5'),([2,1],'6'),(
00:50:35 <lambdabot> [0,2],'7'),([1,2],'8'),([2,2],'9')]
00:51:33 <jethr0> > zip (map (\[x,y] -> (y,x)) $ sequence [[0..2],[0..2]]) "123456789"
00:51:34 <lambdabot> [((0,0),'1'),((1,0),'2'),((2,0),'3'),((0,1),'4'),((1,1),'5'),((2,1),'6'),(
00:51:34 <lambdabot> (0,2),'7'),((1,2),'8'),((2,2),'9')]
00:53:21 <jethr0> it's funny how similar these are:
00:53:40 <jethr0> (map (\[x,y] -> (y,x)) $ sequence [[0..2],[0..2]]
00:53:58 <jethr0>  zip [(y, x) | x <- [0..2], y <- [0..2]]
01:01:16 <Taral> @type Data.Array.IArray.array
01:01:17 <lambdabot> forall e i (a :: * -> * -> *).
01:01:17 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
01:01:17 <lambdabot> (i, i) -> [(i, e)] -> a i e
01:02:10 <Taral> > Data.Array.IArray.array (0, 1) [(0, 0)]
01:02:11 <lambdabot>  Not in scope: `Data.Array.IArray.array'
01:02:14 <Taral> ugh
01:02:15 <jethr0> taral, how do you like my sequence version?
01:02:19 <Taral> jethr0: Cute.
01:02:22 <jethr0> :)
01:02:33 <Taral> cmp unix_debug_64.481736_0545A_53H_NOxmalloc unix_debug_64.new
01:02:36 <Taral> oops
01:02:42 <Taral> random paste buffer garbage
01:02:59 <Taral> > sequence [[0..2],[0..2]]
01:03:00 <lambdabot> [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
01:03:06 <Taral> > [0..2]>>=[0..2]
01:03:07 <lambdabot> Couldn't match `a -> [b]' against `[a1]'
01:03:10 <Taral> > [0..2]>>[0..2]
01:03:11 <lambdabot> [0,1,2,0,1,2,0,1,2]
01:03:37 <jethr0>  > [0..2]>>=\x -> [0..2] -> return . ((,) x)
01:03:39 <jethr0> > [0..2]>>=\x -> [0..2] -> return . ((,) x)
01:03:40 <lambdabot>  parse error on input `->'
01:03:47 <jethr0> > [0..2]>>=\x -> [0..2] >>= return . ((,) x)
01:03:47 <lambdabot>  parse error on input `->'
01:04:17 <Taral> *shrug*
01:04:33 <Taral> > [0..2] >>= \x -> [0..2] >>= return . ((,) x)
01:04:34 <jethr0> > [0..2]>>= \x -> [0..2] >>= \y -> return (x,y)
01:04:35 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
01:04:35 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
01:04:48 <jethr0> weird
01:05:08 <jethr0> > [0..2] >>= \x -> [0..2] >>= return . (x (,))
01:05:09 <lambdabot>   add an instance declaration for (Num ((a1 -> b1 -> (a1, b1)) -> a -> b))
01:05:09 <lambdabot>   In an arithmetic sequence: [0 .. 2]
01:05:31 * jethr0 hates the damn comma non-operator
01:22:26 <yozora> @djinn a->a
01:22:26 <lambdabot> f x1 = x1
01:22:33 <yozora> @djinn Int->Int
01:22:34 <lambdabot> f x1 = x1
01:22:38 <yozora> @djinn Int->String
01:22:39 <lambdabot> -- f cannot be realized.
01:22:44 <yozora> @djinn Int->a
01:22:45 <lambdabot> -- f cannot be realized.
01:22:50 <yozora> @djinn a->Int
01:22:51 <lambdabot> -- f cannot be realized.
01:24:29 <Itkovian> hmm, how does djinn decide what function to give back? I mean [a] -> a could mean a whole lot of thingies
01:24:38 <Itkovian> @djinn [a] -> a
01:24:38 <lambdabot> -- f cannot be realized.
01:24:42 <Itkovian> hmm
01:24:45 <Itkovian> well yeah
01:40:38 <mwc> Hahahah, good lord
01:40:43 <mwc> http://entertainment.tv.yahoo.com/news/wwn/20051209/113414040002.html
01:41:40 <jethr0> imagine finding out you dirty-talked with your mother online
01:41:57 <dcoutts> that's realy disturbing
01:42:51 <dblhelix> ouch
01:43:39 <triplah> ahaha
01:44:12 <jethr0> @pl \x -> x * x
01:44:12 <lambdabot> join (*)
01:44:19 <jethr0> @type join
01:44:20 <lambdabot> Not in scope: `join'
01:44:25 <jethr0> @hoogle join
01:44:26 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
01:44:26 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
01:44:26 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
01:44:44 <jethr0> why does join work on numbers??
01:44:58 <jethr0> or is that an error of lambdabot's?
01:45:43 <Taral> @pl \f x -> f x x
01:45:44 <lambdabot> join
01:46:37 <Taral> Monad ((->) a)
01:46:46 <jethr0> ah
01:47:27 <tibbe> @where lhs2TeX
01:47:27 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
01:48:37 <kosmikus> I should move that to haskell.org, I think
01:50:29 <humasect> is yampa deprecated?
01:50:38 <jethr0> i don't think so
01:50:42 <jethr0> what should've superseded it?
01:50:49 <humasect> hmm
01:50:59 <Speck> yampa+gadt
01:51:12 <jethr0> hmm
01:53:02 <chrisbrown> morining
01:54:46 <tibbe> anyone know why lhs2TeX stops LaTeX from making new paragraphs automatically?
01:55:08 <TuringTest> @djinn a->a->a
01:55:09 <lambdabot> f _ x2 = x2
01:55:29 <kosmikus> tibbe: ?
01:57:30 <tibbe> kosmikus, there's no vertical space between code blocks and regular paragraphs
01:57:54 <tibbe> kolmodin, I've tried using both the > and \begin{code} styles
01:57:55 <kosmikus> ah, I've completely misunderstood your question then
01:59:46 <TuringTest> @djinn (a->a->a)->a->(a->a)
01:59:47 <lambdabot> f x1 x2 x3 = x1 x2 x3
02:00:11 <tibbe> kosmikus, It's a bit strange because there's space around code blocks in the lhs2TeX manual in there very first example
02:00:33 <TuringTest> @djinn (a->a->a)->a->a->a
02:00:34 <lambdabot> f x1 x2 x3 = x1 x2 x3
02:00:38 <kosmikus> tibbe: it's configurable
02:00:49 <kosmikus> tibbe: actually, you should download https://svn.cs.uu.nl:12443/viewcvs/lhs2TeX/lhs2TeX/trunk/Library/polycode.fmt?rev=139
02:01:40 <kosmikus> tibbe: if you put this file into /usr/share/lhs2tex (or in you document directory) and then say "%include polycode.fmt" after "%include lhs2TeX.{fmt,sty}", you should get much better default settings
02:02:54 <tibbe> kosmikus, great, I'll try that
02:04:59 <tibbe> kosmikus, looks much better
02:09:09 <tromp_> @djinn a->a->a
02:09:09 <lambdabot> f _ x2 = x2
02:09:36 <tromp_> still, i prefer f x1 _ = x1 :)
02:10:11 <jethr0> f a b = randomChoice a b
02:10:19 <araujo> mmm....
02:10:56 <araujo> http://haskell.org/hashell/ , my just uploded code! 
02:11:07 <jethr0> cool
02:11:17 <araujo> suggestions, comments , criticisms, flames, etc etc , redirect to me 
02:11:19 <araujo> :-]
02:11:27 <dcoutts> JaffaCake, I don't suppose you know of any spare nightly build capacity. I was thinking it'd be useful to have a gentoo-based nightly build using a ghc-darcs ebuild. It could also then build all the other Haskell ebuilds with that compiler. It'd give us early warning of breakage and great coverage of programs people use.
02:11:29 * araujo now off to eat something 
02:11:29 * humasect downloading
02:11:30 <jethr0> why not hshell
02:11:46 <JaffaCake> araujo: looks cool
02:11:53 <araujo> Hello JaffaCake 
02:11:53 <tromp_> i like the name, araujo
02:11:58 <araujo> Thanks :-]
02:12:05 <araujo> Kind of buggy stuff _yet_ pals
02:12:16 <araujo> But there we go....
02:12:29 <JaffaCake> dcoutts: you need a machine running Gentoo, presumably?
02:12:33 <dcoutts> araujo, hmm the web page is a bit dark looking. Black text on dark grey/blue.
02:12:38 <dcoutts> JaffaCake, or a VM.
02:13:02 <humasect> aw no posix
02:13:14 <JaffaCake> we don't have any spare capacity here, except on the x86_64 machine
02:13:42 <JaffaCake> on x86_64 we have 2 CPUs * about 5 hours per night
02:13:48 <araujo> dcoutts, really?, it looks nice here
02:13:48 <tromp_> maybe http://haskell.org/hashell/documentation.html shld say under construction:)
02:14:03 <araujo> Oh, yeah, hold on....
02:14:20 <dcoutts> JaffaCake, how long do your normal nightly builds take on that x86_64 machine?
02:14:37 <Heffalump> dcoutts: how much CPU does the build need?
02:15:10 <JaffaCake> STABLE takes about 4.5 hours, HEAD takes about 6 hours, IIRC
02:15:21 <JaffaCake> HEAD takes longer because it is building & testing SMP
02:15:44 <musasabi> lennart: About cyclic datatypes, if we limit ourselves to inductively defined datatypes wouldn't it be possible to make proofs about finite cases?
02:15:46 <dcoutts> Heffalump, whatever ghc needs + a bit more for the other ebuilds (happy, haddock, alex, cpphs, drift, etc whatever we'd want to include in the testing set)
02:17:01 <musasabi> lennart: basically prove that it is true for N_0 and then that P(k) => P(k+1).
02:17:24 * araujo off to eat something and then back to code a bit
02:18:08 <musasabi> lennart: does this sound sensible?
02:19:55 <lennart> musabi: many things are possible. but they don't fit easily into the current theorm prover :)
02:20:24 <dcoutts> JaffaCake, 4.5 hours seems like a lot. What takes the extra time compared to an ordinary build? You're running the nofib tests of course.
02:20:35 <JaffaCake> the testsuite mainly
02:20:44 <JaffaCake> hang on, I'll check the times
02:21:22 <JaffaCake> stage1 takes 1h 15m
02:21:47 <JaffaCake> stage2 takes about 15m
02:22:01 <JaffaCake> stage3 22m
02:22:30 <JaffaCake> testsuite takes 1h 20m
02:22:53 <JaffaCake> and 5 nofib runs taking 15min each
02:23:20 <JaffaCake> that's all STABLE
02:24:48 <dcoutts> JaffaCake, perhaps if we did an ebuild based nightly test rather than duplicate the work of the nofib tests it'd be better just to build more real apps/libs. (eg latest cabal, darcs, c2hs, Gtk2Hs, haxml, lhs2tex, wxHaskell, hs-plugins)
02:25:10 <JaffaCake> that would be really useful, yes
02:26:32 <dcoutts> I don't think it'd be too hard to set up the test (at least after a gentoo install is done). It should be just a matter of cleaning out all the Haskell ebuilds and then emerging ghc-darcs and all the other packages in one go. Portage already does logging.
02:27:31 <dcoutts> it's also possible to include extra tests in ebuilds
02:27:41 <Speck> @pl concatMap (\(x,l) -> zip [(x,y) | y <- [0..]] l) . zip [0..]
02:27:42 <lambdabot> (uncurry (zip . return . (<- [0..]) . (| y) . flip (,) y) =<<) . zip [0..]
02:27:47 <JaffaCake> ok, trouble is I can't give anyone access to the machine here
02:28:11 <dcoutts> mmm, not strictly necessary
02:28:32 <JaffaCake> yes, except that means *I* have to do all the work :)
02:28:38 <dcoutts> we keep an overlay of our Haskell ebuilds
02:28:42 <dcoutts> so it can be automated
02:28:55 <dcoutts> it justs darcs pulls from the overlay before running the test
02:29:06 <dcoutts> to get the latest versions of the ebuilds
02:30:13 <dcoutts> perhaps they've got capacity at galios
02:30:24 <JaffaCake> possible
02:30:38 <dcoutts> galios/galois
02:30:55 <dcoutts> it would make maintainance easier with access of course
02:31:30 <dcoutts> none of us gentoo folk have spare machines that are always on
02:31:50 <JaffaCake> I have a laptop running gentoo, but it's not always on either
02:32:26 <dcoutts> heh, I could use my sparc box in my office :-)
02:32:34 <dcoutts> but it takes 12 hours to build ghc
02:32:39 <JaffaCake> :(
02:32:55 <JaffaCake> not so much a nightly build as a weekly build
02:32:59 <dcoutts> hah!
02:33:02 <dcoutts> yeah
02:33:50 <dcoutts> which wouldn't help so much for tracking down which patch broke ghc on sparc linux
02:35:32 <JaffaCake> sparc/linux problem is probably related to gcc, I'm guessing
02:37:22 <dcoutts> oh, I don't mean there is a problem.
02:37:31 <dcoutts> it works fine for me (6.4.1)
02:37:35 <JoshTriplett> Hmmm; interesting behavior of lambdabot:
02:37:36 <JoshTriplett> @pl withPtrTo value func = do ptr <- mallocForeignPtr ; withForeignPtr ptr $ \ptr -> do poke ptr value ; func ptr
02:37:37 <lambdabot> (line 1, column 51):
02:37:37 <lambdabot> unexpected ";"
02:37:37 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
02:37:59 <JaffaCake> dcoutts: http://cvs.haskell.org/trac/ghc/ticket/591
02:38:09 <JaffaCake> thought you were referring to that
02:38:20 <jethr0> "$ \ptr"    <-- is that right?
02:38:31 <jethr0> hmm, ya, maybe
02:38:54 <jethr0> but maybe parens would be nicer
02:39:08 <JoshTriplett> jethr0: Works locally here with ghc.
02:39:22 * JoshTriplett used $ specifically to avoid needing parens. :)
02:39:26 <dcoutts> JaffaCake, I don't get that. I built darcs using 6.4.1 and use it often. (I just meant that were it to break, a weekly build isn't much use for tracking such things down)
02:39:38 <JaffaCake> yes, I see
02:39:51 <jethr0> ok, i didn't realize the "with...". i'm just not used to "dollar lambda"
02:40:06 <JoshTriplett> Yeah, withForeignPtr is a bit strange. :)
02:40:29 <JoshTriplett> "dollar lambda -> do" is odd too. :)
02:40:39 <dcoutts> JaffaCake, I don't see anythign obvious in the debian bug report. I'm using the same version of gcc as they are, 3.3.5
02:41:01 <JaffaCake> hmm, weird
02:42:49 <dcoutts> JoshTriplett, I've been trying to find you. Your code from yesterday has a subtle bug.
02:42:59 <JoshTriplett> dcoutts: Really?
02:43:11 <JoshTriplett> dcoutts: How so?
02:43:14 <dcoutts> JoshTriplett, yep, in the with ptr thing
02:43:30 * araujo back
02:43:31 <dcoutts> JoshTriplett, where's your code again (I can't find it)
02:43:50 <JoshTriplett> dcoutts: http://psas.pdx.edu/~josh/haskell
02:44:23 <dcoutts> rand_rList seed = withPtrTo seed $ repeatIO . rand_r
02:44:32 <dcoutts> so you can't do that. It'll not work.
02:44:36 <JoshTriplett> Why not?
02:44:51 <dcoutts> the ptr you allocate will dissapear as soon as the function returns
02:45:00 <JoshTriplett> As soon as which function returns?
02:45:10 <dcoutts> rand_rList
02:45:28 <dcoutts> but you need it to hand about until the list you return is no longer used
02:45:33 <dcoutts> hand/hang
02:45:40 <JoshTriplett> Hmmm.
02:45:44 <dcoutts> so a Ptr is not ok
02:45:52 <dcoutts> since it is not managed by the GC
02:45:58 <dcoutts> you need a ForeignPtr
02:46:02 <JoshTriplett> It isn't a Ptr, it's a ForeignPtr
02:46:17 <dcoutts> nope, you're taking the Ptr out of the ForeignPtr
02:46:30 <JoshTriplett> Using withForeignPtr, which I thought was safe to use?
02:46:35 <dcoutts> the repeatIO . rand_r part is being give a Ptr
02:46:55 <dcoutts> yes, it's safe to use withForeignPtr so long as the ptr is not used after it returns
02:47:02 <dcoutts> but what does repeatIO do?
02:47:15 <dcoutts> it uses unsafeInterleaveIO to delay the processing
02:47:19 <JoshTriplett> Doh.
02:47:31 <dcoutts> that's why unsafeInterleaveIO is unsafe :-)
02:47:38 <dcoutts> so we can fix it
02:47:44 <jethr0> ok, off to bed
02:47:46 <musasabi> Is there a reason why manual recursion seems to be faster than replicateM (or sequence_ + replicate) ?
02:47:50 <jethr0> g'nite
02:47:55 <JoshTriplett> musasabi: Can you give an example?
02:47:57 <araujo> night jethr0 
02:48:11 <JoshTriplett> dcoutts: How could it be fixed?
02:48:42 <dcoutts> JoshTriplett, make a wrapper for rand_r that takes a ForeignPtr rather than a Ptr
02:48:53 <dcoutts> JoshTriplett, that wrapper will use withForeignPtr
02:49:31 <JoshTriplett> dcoutts: withForeignPtr's documentation seemed to indicate that the pointer would be freed after withForeignPtr exits.
02:49:40 <dcoutts> JoshTriplett, exactly
02:49:48 <dcoutts> and that's the problem
02:49:59 <JoshTriplett> dcoutts: But if I'm calling withForeignPtr for each call to rand_r...
02:50:31 <dcoutts> JoshTriplett, ok, actually that's not quite the rule.
02:50:37 <JoshTriplett> OK.
02:50:39 <dcoutts> JoshTriplett, let me find the docs...
02:51:05 <JoshTriplett> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
02:51:12 <dcoutts> "The foreign object is kept alive at least during the whole action"
02:51:17 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AwithForeignPtr
02:51:42 <dcoutts> JoshTriplett, the ForeignPtr remains alive as long as you have a reference to it.
02:52:12 <JoshTriplett> dcoutts: But isn't there a reference to it in the delayed thunk?
02:52:21 <musasabi> JoshTriplett: http://youzen.b2.fi/~musasabi/bb.hs
02:52:35 <dcoutts> JoshTriplett, right, which is why the ForeignPtr will be kept alive.
02:52:40 <dcoutts> this is what we want
02:52:47 <JoshTriplett> dcoutts: No, I mean in the current code.
02:53:00 <dcoutts> where as if the relaed thunk just has a reference to the Ptr then it is not kept alive
02:53:11 <JoshTriplett> Ah.
02:53:12 <dcoutts> JoshTriplett, a Ptr type does not have it's lifetime managed by the GC.
02:53:23 <dcoutts> that's what the ForeignPtr wrapper is for
02:53:49 <dcoutts> rand_rList seed = withPtrTo seed $ repeatIO . rand_r
02:54:10 <JoshTriplett> dcoutts: So the issue is that the delayed thunk holds a reference to the Ptr from the inside of the withForeignPtr block?
02:54:12 <dcoutts> so with the above the Ptr is taken out of the ForeignPtr and passed into a delayed thunk
02:54:24 <dcoutts> which will get evaluated after withPtrTo has returned
02:54:26 <handongseong> How can i define Eq on my own data type?
02:54:29 <dcoutts> and so the Ptr will have gone
02:54:38 <dcoutts> JoshTriplett, exactly
02:54:48 <JoshTriplett> handongseong: The easy way is to add "deriving Eq" to the end of the data declaration.
02:54:49 <handongseong> i wrote "data Gender = Male | Female" and tried "Male == Female"
02:55:19 <JoshTriplett> handongseong: That gives you structural equality checking: Foo x == Foo y if x == y
02:55:30 <dcoutts> JoshTriplett, so we can fix it by passing the ForeignPtr to the delayed thunk and using withForeignPtr each time we need to use it. So we only use the Ptr temporarily inside a withForeignPtr block.
02:55:52 <JoshTriplett> dcoutts: So much for the convenient withPtrTo wrapper. :)
02:55:56 <dcoutts> heh
02:56:33 <handongseong> JoshTriplett, thanks now it works
02:56:44 <dcoutts> JoshTriplett, So rand_rList will mallocForeignPtr and do the withForeignPtr ptr $ \ptr -> poke ptr value
02:57:01 * JoshTriplett is realizing how much checking unsafeInterleaveIO leaves up to the coder. :)
02:57:03 <ski> handongseong : 'data Gender = Male | Female deriving Eq'
02:57:05 <dcoutts> JoshTriplett, but then you'll pass the ForeignPtr to the rand_r_wrapper
02:57:45 <ski> handongseong : or 'instance Eq Gender where <implementation of (==) for Gender>'
02:57:53 <TuringTest> @djinn [a]->[a]
02:57:54 <lambdabot> f x1 = x1
02:57:55 <dcoutts> JoshTriplett, that's what unsafe* generally means in Haskell. "You've got something to prove to ensure that your program is not going to break horribly"
02:58:04 <TuringTest> @djinn [a]->a
02:58:05 <lambdabot> -- f cannot be realized.
02:58:19 <JoshTriplett> @help djinn
02:58:20 <lambdabot> Generates Haskell code from a type.
02:58:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:58:41 <handongseong> ski: amazing. how can it work? i've only added 'deriving Eq' and now this data type can be compared.
02:58:53 <TuringTest> @djinn (a->c)->(b->c)->Either a b->c
02:58:54 <lambdabot> f x1 x2 x3 =
02:58:54 <lambdabot>   case x3 of
02:58:54 <lambdabot>   Left v6 -> x1 v6
02:58:54 <lambdabot>   Right v7 -> x2 v7
02:59:07 <handongseong> i mean, i haven't defined how it should be compared
02:59:14 <TuringTest> @djinn (a->b)->[a]->[b]
02:59:15 <lambdabot> -- f cannot be realized.
02:59:26 <ski> handongseong : basically, 'deriving' generates the more explicit 'instance' declaration .. 'deriving' only works in a few cases, though
02:59:35 <dcoutts> JoshTriplett, though just how horrible it might be can vary. The most horrible is unsafePerformIO of course, followed by unsafeInterleaveIO since these can make your program segfault. The other unsafe* things you mgiht find about generally just make you get the wrong answer or an error message but don't screw up memory management etc.
02:59:49 <ski> handongseong : it just assumes you want the obvious structural equality
03:00:13 <ski> handongseong : if you want other, you need to code an explicit instance yourself
03:00:20 <handongseong> aha
03:00:49 <JoshTriplett> handongseong: deriving Eq also works in more complex cases; for example, if you have: data Tree a = Branch (Tree a) (Tree a) | Leaf a deriving Eq
03:00:49 <ski> (also, it can't derive Eq if you include stuff which has no Eq in the type, like functions)
03:00:57 <Speck> @djinn (a->b)->(b->a)->a->a
03:00:57 <lambdabot> f x1 x2 x3 = x2 (x1 x3)
03:00:59 <handongseong> you mean, with extra codes, i can make 'Male' and 'Female' recognized as if they are same?
03:01:08 <JoshTriplett> handongseong: Right.
03:01:32 <JoshTriplett> handongseong: Or you could implement things like three-valued boolean logic.
03:01:41 <dcoutts> JaffaCake, the other thing I found yesterday after you went home is that the ar format is really pretty simple. I wrote a 50 line Haskell program to parse the contents of a .a file.
03:01:41 <handongseong> wow
03:01:44 <ikegami--> Djinn is very interesting to me
03:01:49 <ski> (dcoutts : somehow, i like Mercury's 'promise' name convention more .. not sure how easy to adapt here, though)
03:02:20 <dcoutts> ski, promisePerformIO ? :-)
03:02:27 <ski> no :)
03:02:38 <dcoutts> ski, sure, that makes more sense for things with preconditions, eg the input list must be sorted ,etc
03:02:39 <ski> mayhaps promisePureIO
03:02:49 <JaffaCake> dcoutts: that's interesting, maybe it wouldn't be too hard to support then
03:03:15 <dcoutts> JaffaCake, an ar file is basically a bunch of other files catted together with a little bit of header info between them
03:03:26 <ski> (the 'promise' name more explicitely says that here we rely on programmer asserting somthing, which is possibly not checked by compiler)
03:03:27 <JaffaCake> yes, that's what I thought
03:03:43 <dcoutts> JaffaCake, I used this as a reference: http://en.wikipedia.org/wiki/Ar_(Unix)
03:04:03 <JaffaCake> oh neat
03:04:10 <ski> dcoutts : hm, example of how unsafeInterleaveIO can make the program go wrong ?
03:04:21 <dcoutts> JaffaCake, the only special bits are for long names (which we probably don't care about anyway) and symbol index entries.
03:04:25 <JoshTriplett> ski: How about the code I posted? :)
03:04:39 * JoshTriplett hasn't seen it segfault, though. :)
03:04:51 <JaffaCake> dcoutts: I think we might care about long names
03:04:55 <dcoutts> JaffaCake, most .a files have a special entry for the ranlib synbol index. But that can be ignored.
03:04:59 <ski> JoshTriplett : that's more about withForeignPtr, i think
03:05:01 <joelr1> good morning everyone
03:05:13 <dcoutts> JaffaCake, it's the long name of the .o file in the .a file. Is that used at all? I doubt it.
03:05:15 <JoshTriplett> ski: Not so much; it wouldn't be wrong without the unsafeInterleaveIO.
03:05:30 <dcoutts> JaffaCake, eg "Storable__1.o"
03:05:33 <joelr1> i'm looking for that paper comparing the various languages in a department of defense shootout
03:05:40 <JaffaCake> dcoutts: IIRC, Text.ParserCombinators.HughesPJ.blah overruns the limit :)
03:05:41 <JoshTriplett> ski: withForeignPtr alone couldn't let you violate the convention, since you have no way to save off the internal Ptr after the block exits.
03:05:58 <joelr1> the one where they were tracking objects for a ship defense system
03:06:00 <joelr1> anyone?
03:06:29 <dcoutts> JaffaCake, of course, but I don't think we'd ever need to know the names of the .o files. You'd use the .a name as the unique identifier in the linker. Otherwise you'd get loads of clashes.
03:06:49 <joelr1> found it!
03:06:49 <ski> JoshTriplett : how about storing it in an IORef ?
03:06:54 <JaffaCake> dcoutts: true
03:07:07 <dcoutts> JaffaCake, eg modules Foo.Bar Baz.Bar both generate Bar.o in the .a file.
03:07:47 <dcoutts> JaffaCake, (which is actually something that the ghc build system doesn't take account of when it calls xargs | ar cru)
03:08:09 <JoshTriplett> dcoutts: So, is there any reason I couldn't just use: rand_rList seed = withForeignPtrTo seed $ repeatIO . flip withForeignPtr rand_r
03:08:14 <JaffaCake> that's right, fortunately it's never been a problem
03:08:35 <dcoutts> JaffaCake, I discovered that when doing split-objs for gtk2hs which does have modules like the Gtk.Types, Gtk.Pango.Types
03:08:50 <ski> (JoshTriplett : '(`withForeignPtr rand_r)')
03:08:58 <ski> (JoshTriplett : '(`withForeignPtr` rand_r)')
03:09:10 <JoshTriplett> ski: That seems less clear to me.
03:09:17 <musasabi> JaffaCake: would you be willing to accept an optimized implementation of replicateM_ to the libraries tree?
03:09:31 <JaffaCake> musasabi: sure
03:09:34 <JoshTriplett> ski: (Normally I'm not a fan of flip, but it seems more obvious than the use of a section for a non-operator.)
03:09:54 <JoshTriplett> ski: Re: IORef, I'm not familiar with them, so I don't know what they'd let you get away with.
03:10:02 <JaffaCake> dcoutts: BTW, you have a commit bit for CVS
03:10:04 <musasabi> http://cs.helsinki.fi/u/ekarttun/haskell/replicateM_.patch
03:10:07 <dcoutts> JaffaCake, anyway, so the point is that the name of the .o file isn't important.
03:10:09 <ski> JoshTriplett : they are asignable cells
03:10:13 <dcoutts> JaffaCake, huh? I do?
03:10:30 <JaffaCake> dcoutts: you sent me too many patches :)
03:10:38 <dcoutts> JaffaCake, oh. :-)
03:11:08 <JoshTriplett> dcoutts: Would that code be semantically correct?
03:11:11 <JaffaCake> feel free to run stuff by me or the list, but small patches can go straight in
03:11:23 <ski> JoshTriplett : do ref <- newIORef Nothing; withForeignPtr fptr (\ptr -> do writeIORef ref (Just ptr)); Just ptr <- readIORef ref; ...
03:11:32 <dcoutts> JaffaCake, Maybe I'll wait for the full conversion to darcs.
03:11:37 <chrisbrown> does anyone know oy any good texts on programming language theory?
03:12:25 <dcoutts> JoshTriplett, withForeignPtrTo does what?
03:12:26 <JoshTriplett> ski: Ah; I didn't know you could write an IORef in the inner block and extract it in the outer block.
03:12:47 <ski> it's same monad, so it's possible
03:13:11 <JoshTriplett> dcoutts: Same as withPtrTo except it calls the function with the ForeignPtr rather than the Ptr.  (Come to think of it, that means it would be far easier to just return the ForeignPtr. :) )
03:13:34 <dcoutts> JoshTriplett, in that case it's ok I think.
03:13:48 <JoshTriplett> dcoutts: Cool.
03:13:58 <JoshTriplett> dcoutts: Many thanks for the explanation.
03:14:31 <dcoutts> JoshTriplett, so you've done what I suggested, but you've expanded the rand_r wrapper in place.
03:18:02 <ski> (JoshTriplett : so .. i've not seen (imo :) yet that unsafeInterleaveIO is unsafe)
03:19:03 <JoshTriplett> dcoutts: Actually, I'd be curious as well; is there a simple example which uses unsafeInterleaveIO to provoke a segfault?
03:19:40 <ski> (unsafeInterleaveST, otoh ..)
03:19:47 <joelr1> JoshTriplett: do you specifically want interleave or would regular unsafe io do?
03:20:02 <ski> joelr1 : interleave
03:20:09 <JoshTriplett> joelr1: Ditto.
03:21:04 <dcoutts> JoshTriplett, wellI'm sure that temporarily allocating a wadge of memory and then using unsafeInterleaveIO to delay randomly writing all over it would evantually cause a segfault as it corrupts the GHC heap.
03:21:17 <ski> we have several different meanings of unsafe, here .. a) wrong (crash,segfault,data and mem corruption,etc)  b) impurity
03:22:53 <ski> dcoutts : but that's not much different to keeping an action that is later executed
03:23:03 <dcoutts> JoshTriplett, unsafeInterleaveIO is generally not so dangerous. It's just that in combination of allocating temporary low level FFI-style resources you've got to think very carefully about the lifetimes of things.
03:23:22 <ski> dcoutts : difference is that forcing of value outside of IO can trigger it
03:23:48 <dcoutts> right
03:24:58 <dcoutts> unsafeInterleaveIO can often be really useful, eg retreiving data from a file, records from a db recordset, recursivly walking a directory tree.
03:25:35 <JoshTriplett> dcoutts: Well, I've fixed the code, and it got simpler in the process. :)
03:25:43 <dcoutts> good!
03:26:00 <JoshTriplett> dcoutts: I updated it at the same address; would you mind taking a look?
03:27:13 <dcoutts> JoshTriplett, looks good
03:27:21 <JoshTriplett> dcoutts: Thanks.
03:27:32 <ski> s/foreignPointerTo/foreignPtrTo/
03:27:46 <JoshTriplett> ski: Ah, thanks. :)
03:27:50 * ski also wonders if there's no better name for that
03:27:59 * JoshTriplett hates when comments disagree with the code. :)
03:28:19 <dcoutts> JoshTriplett, there's another way of writing what you've got. If you're interested. Using unsafePerformIO. :-)
03:28:28 <JoshTriplett> ski: It seems to read well when I write code which uses it: do ptrSeed <- foreignPtrTo seed ; ...
03:28:31 <dcoutts> and actually it's a safe use of unsafePerformIO!
03:28:38 <JoshTriplett> dcoutts: I'd be interested to see it at least. :)
03:29:39 <JoshTriplett> ski: What did you have in mind?
03:29:49 <JoshTriplett> ski: I'm open to suggestions.
03:30:41 * JoshTriplett wonders if unsafeInterleaveIO could be just written as return . unsafePerformIO
03:30:52 <JoshTriplett> Or if the actual behavior is more complex than that. :)
03:30:59 <JoshTriplett> I know the actual implementation is.
03:31:55 <ski> hm .. considering 'new :: Storable a => a -> IO (Ptr a)', one could suggest s/foreignPtrTo/newForeignPtr/ .. only that's taken for 'newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)'
03:32:10 <joelr1> is it shared transactional memory or shared transaction memory?
03:33:11 <JoshTriplett> ski: I thought about mallocForeignPtrTo, since it is basically a mallocForeignPtr followed by a store, but just plain foreignPtrTo read better as part of an expression, whereas mallocForeignPtrTo reads more imperatively.
03:33:21 * ski ponders .. hm 'newForeign' ??
03:33:51 <ski> JoshTriplett : i'm not so happy with the 'To' there ..
03:34:15 <JoshTriplett> ski: Kinda like "if fooProp blah == fooish then" versus "if getFooProp blah == fooish then"
03:34:19 <JoshTriplett> ski: Why not?
03:34:46 <ski> 'toForeignPtr' would be better imo
03:35:03 <ski> (or maybe 'intoForeignPtr')
03:35:31 <JoshTriplett> If I were going to go that route, I'd tend to use "asForeignPtr"
03:35:49 <ski> if it ends with 'To', then i read it as converting 'from' ForeignPtr, 'To' something else
03:36:27 <JoshTriplett> Ah; so you're reading the "to" as "convert x *to* y" rather than "pointer *to* location"?
03:36:37 <ski> yes
03:36:46 <ski> x being ForeignPtr
03:36:56 <JoshTriplett> Perhaps "foreignPtrFor" then?
03:37:03 <JoshTriplett> Or "foreignPtrAt"?
03:37:06 <ski> (didn't even realize the other reading was possible)
03:37:14 <ski> maybe 'Of' ?
03:37:37 <ski> foreignPtrOf
03:37:51 <dcoutts> JoshTriplett, ok, I've got the pure version...
03:38:12 <JoshTriplett> ski: That was the original intent: "ptrSeed <- foreignPtrTo seed" was to be read as "ptrSeed gets a ForeignPtr to seed"
03:38:15 <dcoutts> rand_r_pure :: CUInt -> (CInt, CUInt)
03:38:15 <dcoutts> rand_r_pure state = unsafePerformIO $ 
03:38:15 <dcoutts>   with state $ \statePtr -> do
03:38:15 <dcoutts>   rnd <- rand_r statePtr
03:38:15 <dcoutts>   state' <- peek statePtr
03:38:16 <dcoutts>   return (rnd, state')
03:38:38 <dcoutts> JoshTriplett, and then the next bit is easy:
03:38:40 <dcoutts> rand_rList_pure :: CUInt -> [CInt]
03:38:40 <dcoutts> rand_rList_pure = unfoldr (Just .  rand_r_pure)
03:38:55 <dcoutts> becuase it's pure. No IO.
03:39:03 <JoshTriplett> Nice.
03:39:27 <dcoutts> so do you see what's going on with the rand_r_pure :: CUInt -> (CInt, CUInt)
03:39:37 <dcoutts> we can make the C function pure
03:39:50 <JoshTriplett> dcoutts: Yeah, exactly; since the only impure action of rand_r is to modify its argument, if you return the new argument you're pure.
03:39:56 <dcoutts> right
03:40:07 <ski> dcoutts : could possibly use Control.Monad.State
03:40:14 <JoshTriplett> dcoutts: Seems like you might be able to use mapAccumL then.
03:40:31 * JoshTriplett ponders how that would work.
03:41:12 <JoshTriplett> Hmmm, nevermind.
03:41:13 <dcoutts> JoshTriplett, I think unfoldr is simpler
03:41:23 <JoshTriplett> @type unfoldr
03:41:24 <lambdabot> Not in scope: `unfoldr'
03:41:32 <dcoutts> @type List.unfoldr
03:41:33 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
03:41:44 <dcoutts> unfoldr is under apreciated
03:41:49 <JoshTriplett> Hmmm; that's less than illuminating.
03:41:52 <dcoutts> especially compared to foldr
03:42:13 <dcoutts> JoshTriplett, it's the opposite of foldr
03:42:17 <ski> (JoshTriplett : maybe you could also make it an instance of RandomGen)
03:42:38 <ski> @type Control.Monad.mapAccumL
03:42:39 <lambdabot> Not in scope: `Control.Monad.mapAccumL'
03:42:44 <ski> @type mapAccumL
03:42:45 <lambdabot> Not in scope: `mapAccumL'
03:42:50 <ski> @type Data.List.mapAccumL
03:42:52 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:42:59 <dcoutts> it uses a function of type (b -> Maybe (a, b) to get a value out of something and return the updated something
03:43:18 <dcoutts> which matches exastly what you're doing with a random number state
03:43:31 <dcoutts> you get a randome number out and return the new state
03:43:39 <dcoutts> the Maybe is so that the list can terminate
03:44:05 <dcoutts> but in our case it's an infinite list, so we use (Just . rand_r_pure)
03:44:50 <JoshTriplett> ski: I'm not actually attempting to make a random generator; it was just a random (heh) C function which used an explicit state and generated different results on each call.
03:45:10 <dcoutts> the function of type (b -> Maybe (a, b)) is used to decide if the next part of the list will be a cons (Just (element, newstate)) or the end of the list [].
03:45:20 <JoshTriplett> dcoutts: Wow.  That's perfect in so many ways.
03:45:35 <shapr> JaffaCake: I've seen some test suites sped up by starting with a single top level end-to-end test for a certain chunk, and only executing detailed tests if the top level test fails. Could that approach be used to speed up GHC testing?
03:45:40 <JoshTriplett> dcoutts: That exactly matches just about every use case I can see for repeatIO. :)
03:46:15 <JaffaCake> shapr: probably... it's not something I want to spend a lot of time on though
03:46:16 <dcoutts> JoshTriplett, well repeatIO is for when the thing really does have side effects.
03:46:41 <dcoutts> JoshTriplett, in this case we were abel to make the C function pure. That's not always possible.
03:46:41 <JoshTriplett> dcoutts: I just mean that in every case, I may eventually want to terminate the list; Maybe is a great way to express "maybe there's another element".
03:46:56 <dcoutts> JoshTriplett, oh right. Yes.
03:47:22 <dcoutts> JoshTriplett, we need unfoldM !
03:47:24 * JoshTriplett throws some appreciation in the general direction of the underappreciated unfoldr. :)
03:47:32 <shapr> JaffaCake: Might be worth advertising on the tracker as an easy task that can be done incrementally , someone else may pick it up.
03:47:47 <JoshTriplett> dcoutts: That sounds promising.
03:47:55 <JaffaCake> shapr: yes, good idea
03:48:04 * Oejet has an interesting concurrency question.
03:48:20 <JoshTriplett> dcoutts: unfoldM would be a strict superset of the functionality of repeatIO.
03:48:22 <Oejet> @paste
03:48:23 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:48:29 <dcoutts> JoshTriplett, right
03:48:40 <JaffaCake> shapr: although it's hard to reliably construct an end-to-end test that covers everything the smaller tests do
03:48:52 <JoshTriplett> dcoutts: If you don't need any state, you just ignore the state argument, and if you don't need new state every time, you just use the old state as the new state.
03:49:10 <JoshTriplett> dcoutts: Most useful cases, though, will need an initial state and state propogation.
03:49:18 <JoshTriplett> dcoutts: For example, my calls to iterator-style functions
03:49:19 <JoshTriplett> .
03:49:20 <JaffaCake> also, we don't want to make it harder to add tests, that would be counter-productive
03:49:44 <shapr> Right, but even if it's three top level tests instead of ten detail tests, that'll speed up the whole process.
03:50:47 <shapr> Kent Beck used to use this sort of trick to speed up test suites on the C3 project, I can probably find more information on how he did it.
03:50:58 <JoshTriplett> dcoutts: Is unsafePerformIO . unsafeInterleaveIO strictly equivalent to unsafePerformIO?
03:51:10 <JoshTriplett> dcoutts: Seems like it should be.
03:51:14 <JaffaCake> I think a viable approach would be to go through the testsuite and pick out say 20% of the most important ones; so you can quickly tell whether things are mostly working
03:51:28 <shapr> Yeah, I agree.
03:51:42 <JoshTriplett> JaffaCake: Yeah, many test suites have a "fast" subset.
03:51:48 <shapr> You don't want to make it hard to run the tests, otherwise they won't get used.
03:52:12 <shapr> And hard can also mean 'takes too long'
03:52:18 <JaffaCake> yes
03:52:24 * joelr1 just mentioned JaffaCake in his blog
03:52:27 <JaffaCake> I bet a fast subset could run in a couple of minutes
03:52:31 <joelr1> shapr: got an update ;)
03:52:41 <shapr> joelr1: Cool, thanks :-)
03:52:59 <JaffaCake> joelr1: where's your blog? I'm nosy :)
03:53:08 <joelr1> shapr: i shall mention your QuickCheck tutorial sometime in the near future ;)
03:53:09 <shapr> http://wagerlabs.com/
03:53:14 <joelr1> JaffaCake: the premier haskell blog 
03:53:15 <joelr1> hehehe
03:53:18 <dcoutts> JoshTriplett, hmm. Not sure. Probably.
03:53:39 <joelr1> shapr: i got a cool new blog theme too
03:53:50 <shapr> Yeah, I see it.
03:54:07 <joelr1> i think the little tree and thing (while japanese) goes with tenerife
03:54:19 <joelr1> haven't seen any bamboo shots locally, though
03:55:04 <JoshTriplett> dcoutts: So, just to get an idea, what would the type signature of unfoldM be?
03:55:30 <shapr> joelr1: Your 'extended answers' link is broken.
03:55:34 <dcoutts> @type List.unfoldr
03:55:35 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
03:55:39 <joelr1> shapr: huh?
03:55:51 <Oejet> I am trying to implement a barrier using STM and my own algorithm, but it doesn't work.
03:55:56 <joelr1> shapr: what's extended answers? 
03:55:58 <JoshTriplett> unfoldM :: Monad m => (b -> m Maybe (a, b)) -> b -> m [a]
03:55:59 <JoshTriplett> ?
03:56:11 <joelr1> shapr: i just installed this theme so i'm not 100% familiar with all the features
03:56:22 <shapr> joelr1: "I fell in love with Haskell while reading the Composing Financial Contracts paper by [link extended answers] to your difficult questions"
03:56:31 <joelr1> oh
03:56:31 <joelr1> sec
03:56:34 <JoshTriplett> The initial state certainly doesn't need the monad.
03:56:53 <dcoutts> unfoldM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m [a]
03:57:05 <dcoutts> JoshTriplett, oh yes, what you said. :-)
03:57:20 <shapr> joelr1: Nice looking theme.
03:57:21 <dcoutts> (except for th missing bracket)
03:57:35 <Oejet> The main idea of the barrier is to have a global count of threads passing the barrier: if (passed `mod` 10 == id)   then writeTVar tv (passed+1)   else retry.
03:57:43 <musasabi> joelr1: btw I had experimental kqueue support with FreeBSD but it seems that FreeBSD5 + kqueue + threading + SMP + GHC is not a good combination.
03:58:12 <joelr1> musasabi: interesting
03:58:18 <joelr1> i'm having some trouble with networking now
03:58:23 <ski> @type \f -> let foo s = f s >>= \m -> case m of {Nothing -> return [];Just (a,s') -> foo s' >>= \as -> return (a:as)} in foo
03:58:24 <lambdabot> forall a b (m :: * -> *).
03:58:24 <lambdabot> (Monad m) =>
03:58:24 <lambdabot> (b -> m (Maybe (a, b))) -> b -> m [a]
03:58:32 <joelr1> maybe something to do with select and going over 1024 connections
03:58:36 <joelr1> sockets
03:58:43 <joelr1> shapr: thank you!
03:58:53 <shapr> JaffaCake: A two minute test suite would have me running a nightly build and encouraging other users to do the same via my next TMR editorial.
03:59:00 <musasabi> mmh, I should get an UP FreeBSD machine to get meaningfull benchmarks.
03:59:15 <musasabi> (since kqueue SMP problems are documented elsewhere)
03:59:39 <JaffaCake> shapr: am I being bribed? :)
03:59:45 <shapr> heh
03:59:57 <Oejet> So, my question is, why doesn't it work?
04:00:46 <dcoutts> shapr, it's a good point though. If a nightly build test were 2 hours rather than 5 then it'd be feasable to run it regularly on an ordinary home machine.
04:01:04 <shapr> A two minute test suite would be fast enough that even slow offbeat machines could handle the build and the tests.
04:01:14 <musasabi> (my current test machine is a Dell SMP box, and OpenBSD does not like booting on it, so that means kqueue support is still some time in the future)
04:01:39 <musasabi> or rather - the code works fine, but I am not ready to commit to it yet before making it faster than select(2)
04:01:40 <joelr1> shapr: how do you quote # to say #haskell?
04:02:00 <shapr> Um, do you need to?
04:02:15 <shapr> You're asking for an html entity?
04:02:40 <ski> @type let fixInterleaveIO f = f (System.IO.Unsafe.unsafeInterleaveIO . fixInterleaveIO f) in fixInterleaveIO
04:02:41 <lambdabot> forall a a1. ((a -> IO a1) -> a -> IO a1) -> a -> IO a1
04:03:03 <joelr1> shapr: a huge chunk of  my post is missing for some wierd reason
04:03:22 <shapr> joelr1: You missed a double quote
04:03:53 <shapr> It should be: http://research.microsoft.com/Users/simonpj/">Simon%20Peyton-Jones</a>
04:04:03 <shapr> but you have http://research.microsoft.com/Users/simonpj/>Simon%20Peyton-Jones</a>
04:04:16 <JoshTriplett> ski: How might one use that?
04:04:28 <joelr1> shapr: yeah! thanks a lot!
04:05:02 <JaffaCake> joelr1: the link "extended answers" on that blog entry is b0rked
04:05:20 <joelr1> JaffaCake: refresh the page, you are in now!
04:05:20 <joelr1> :D
04:05:29 <joelr1> JaffaCake: shapr pointed out a missing double-quote
04:05:39 <JaffaCake> aha
04:05:40 <ski> @type let fixInterleaveIO f = System.IO.Unsafe.unsafeInterleaveIO . f (fixInterleaveIO f) in fixInterleaveIO
04:05:41 <lambdabot> forall a a1. ((a -> IO a1) -> a -> IO a1) -> a -> IO a1
04:05:46 <ski> (that's better)
04:05:52 <ski> JoshTriplett : if you have an unknotted version of a function, you could pass it to that to make it interleave recursive results
04:06:03 <shapr> JaffaCake: Anyway, no need to bribe me. I advertise Haskell and GHC flagrantly whenever given the chance, and I know how much of GHC's spiffiness comes from the work of the Simons. If you would like me to advertise for a particular thing in TMR, I'm happy to help.
04:06:46 <shapr> But for now, it's time to unicycle and code.
04:07:06 <JaffaCake> I really need to write an article on conc Haskell and why it's the future for multicores, at some point
04:07:08 <shapr> joelr1: Hey, do you have the urge to write a TMR article on tips for squashing laziness?
04:07:39 <JoshTriplett> ski: Ah, I see.  However, I don't think I need an unsafeInterleaveIO call on every recursive call, just on the top-level call.
04:07:45 <shapr> If you can give me an outline of what you'd like to say, I might be able to ghostwrite part of such an article.
04:07:50 <ski> repeatIO = fixInterleaveIO $ \repeatIO f -> do x <- f ; xs <- repeatIO f; return (x:xs)
04:07:56 <ski> (if i'm not mistaken)
04:08:01 <JoshTriplett> I stand corrected.
04:08:05 <JoshTriplett> Ah, I see now.
04:08:13 <joelr1> shapr: hmm... you are making the offer unresistable
04:08:24 <shapr> I've been exhorting GHC to add SMP support ever since I saw multi-cores coming a few years back.
04:08:28 <joelr1> shapr: of course i could link to the article from my blog. hmm...
04:08:38 <joelr1> shapr: TMR comes out on a schedule, right?
04:08:46 <JoshTriplett> ski: However, I'm not sure that's clearer.
04:08:50 <ski> i just thought maybe fixInterleaveIO could be useful, at times, if you have unknotted version of a func lying around, and want to interleave rec. calls, without modifying the func
04:08:52 <shapr> joelr1: Yes, but you can write the article whenever, and link to it immediately.
04:09:09 <JoshTriplett> ski: I rarely have the unknotted version of a function laying around. :)
04:09:22 <ski> heh
04:09:50 <ski> (just an idea .. prolly not worth it in this case)
04:10:06 <joelr1> shapr: the real pity is that i did not profile after each major change so now i just have a hunch that more laziness was squashed after moving to single-slot mailboxes than after switching pickling to unboxed arrays from [Word8]
04:10:11 * JoshTriplett understands lambda-calculus recursion and the Y combinator, and thus feels perfectly comfortable letting the Haskell compiler handle the details while I just use named functions as a "let rec" equivalent.
04:10:21 <shapr> joelr1: Are you using source control? Can you rollback?
04:10:43 <joelr1> shapr: darcs all the way, from the very beginning
04:11:02 <joelr1> but i still have not figured out how to see the history of changes to an individual file
04:11:13 <JoshTriplett> ski: Under what circumstances might you have an unknotted function normally laying around? :)
04:11:22 <JoshTriplett> ski: Just out of curiosity.
04:11:37 <joelr1> shapr: the issue is that i think i commited the whole batch of changes, mailboxes and unboxed arrays together
04:11:38 <ski> JoshTriplett : maybe if you want to do memoing stuff, or other things in between each rec. call
04:11:42 <joelr1> so i can't quite roll back
04:11:50 <shapr> Ah, too bad.
04:12:17 <joelr1> shapr: don't think it matters too much
04:12:30 <joelr1> the issue was using a bottomless pit of a TChan 
04:12:43 <joelr1> and threads not keeping up with extracting messages from it
04:12:45 <ski> JoshTriplett : possibly the latter could be useful with http://www.haskell.org/hawiki/IndirectComposite, too
04:12:46 <JoshTriplett> ski: Ah, excellent point.  factorial = fix factorial' ; factorialMemoized = fix (memoize factorial')
04:13:21 <joelr1> JaffaCake: have you thought of introducing thread priorities into the scheduler?
04:13:39 <JaffaCake> joelr1: thought about it, decided to try to avoid it if possible
04:14:10 <JaffaCake> joelr1: it's a bit of a minefield, with priority inversion for example
04:14:12 <mlh> is isUpper not in the ghci Prelude?
04:14:26 <JoshTriplett> ski: Interesting.
04:14:28 <ski> @index isUpper
04:14:29 <lambdabot> Data.Char
04:14:39 <joelr1> JaffaCake: what's priority inversion? some big mine?
04:15:01 <JaffaCake> when a high priority thread is waiting on some resource being held by a low-priority thread
04:15:22 <JaffaCake> try googling for it if you're interested
04:16:08 <joelr1> JaffaCake: thanks will do
04:16:54 <joelr1> but this has been solved by the erlang people i think. i posted an email from ulf wiger to haskell-cafe recently
04:17:04 <joelr1> maybe i'll dig into it deeper in the future
04:17:13 <shapr> joelr1: Anyway, if such an article interests you, get back to me.
04:17:43 <dcoutts> joelr1, yeah I think priority inversion is possible to solve in the scheduler but that makes it even more complex. iirc.
04:17:44 <joelr1> shapr: i will. soon. i started updating my blog, as promised. so i'll definitely get to the article.
04:18:07 <shapr> spiffy
04:18:10 <JaffaCake> joelr1: from your message, I don't think they tackled priority inversion
04:18:25 <JaffaCake> I might be wrong, though
04:18:29 <mlh> ski: thanks, but the 'tour of the prelude' doesn't mention that
04:18:37 <joelr1> JaffaCake: hmm... i'll ask about that specifically. 
04:18:54 <joelr1> dcoutts: i haven't looked at it yet
04:19:27 <joelr1> i'm just seeing some funny behavior in my program. i launch poker bots and, for example, things really start slowing down at above 1100 connections
04:19:42 <joelr1> maybe 1024? just the thread launches even
04:20:07 <joelr1> of course 1000 connections in my case would be about 3 times as many threads, maybe 4 times
04:20:20 <joelr1> and there's TCP traffic going all the time from the 1000 bots
04:20:35 <JaffaCake> joelr1: http://www.erlang.org/ml-archive/erlang-questions/200104/msg00072.html
04:20:52 <JaffaCake> mentions priority inversion, but doesn't say what they did about it, if anything
04:21:01 <JaffaCake> maybe it's not an issue for them
04:21:14 <joelr1> right
04:21:16 <shapr> JaffaCake: Would you want to write a 'real' paper or a TMR article about why conc Haskell is the future for multicores?
04:21:37 <JaffaCake> shapr: it's more article material than research paper, I guess
04:21:43 <shapr> Spiffy!
04:22:01 <joelr1> JaffaCake: i asked uffe, lets see what he replies
04:22:02 <JaffaCake> I just feel we ought to have something out there that people can point to
04:24:16 <eivuokko> JaffaCake, I have poked libgmp into a dll a bit, and it appears rts sets gmp allocators.  I have (or rather will have) multiple plugins written in haskell (base system is c++) and all those plugins have their own hs root...that's likely to be a problem, right?  Would it be hard to awaken rts as dll...lots of stuff seems to be done on build-system level.
04:25:38 <JaffaCake> eivuokko: not sure I fully understand.. are you asking whether it's ok to have mutliple copies of the RTS in a single running program?
04:26:01 <eivuokko> Hmh
04:26:40 <eivuokko> I was asking few things.  I have multiple DLLs, written in haskell, those all have hs root of their own (staticaclly linked rts in each dll, in Windows)
04:26:58 <JaffaCake> ok
04:27:05 <eivuokko> If gmp is dll, each of those hs root inits sets gmp allocators, and they mix up their heaps, right?
04:27:54 <JaffaCake> yes, they'll get mixed up
04:27:55 <eivuokko> So, as I am seeing it, if gmp is dll, rts should be dll as well.
04:28:00 <eivuokko> :-(
04:28:03 <JaffaCake> you should statically link GMP into each DLL
04:28:25 <eivuokko> Well, that leads to too much trouble, socially because of license.
04:28:38 <JaffaCake> I don't see how putting the RTS into a DLL will help
04:28:54 <eivuokko> Then those plugins share it, being in one process.
04:28:58 <JaffaCake> oh, you could share it, you mean?
04:29:03 <JaffaCake> right
04:29:06 <eivuokko> Yes.
04:29:28 <JaffaCake> that would work... except we can't put the RTS in a DLL right now :(
04:29:52 <eivuokko> There's configure and makefile machinery for it, tho
04:30:00 <shapr> I'm a big fan of declarative concurrency. I've mentioned that the Cell cpu has a roadmap that scales up to 64 Cells on a die. That's 576 cores alone on a consumer motherboard, probably in the next ten years. I seriously doubt that the explicit hand-built threading approach of C will scale up to that.
04:30:03 <JaffaCake> eivuokko: it's bit-rotted
04:30:37 <eivuokko> JaffaCake, any estimation how much work would it be (I'm willing to give it a go) to refresh it?
04:31:53 <JaffaCake> probably quite a lot of work, I imagine.   There's a new framework in the compiler for shared libraries, that's partially working
04:32:10 <JaffaCake> and it doesn't have DLL support yet
04:33:55 <eivuokko> Well, as I see it, there are diffrent parts: memory/heap/io+other primitives and actual haskell symbols that need to be shared.  Would it be possible to split rts into such parts?
04:34:37 <eivuokko> Because I only need the heap etc sharing, I don't need, or actually want, to share haskell symbols.
04:35:16 <JaffaCake> if you just want to put the RTS into a DLL, that's a simpler task (that supporting DLLs properly in GHC).  It's a matter of making sure that all references to RTS symbols from Haskell code go via indirections, and then just adding the right machinery to build the DLL
04:39:23 <eivuokko> I am suprised that there isn't people who want to use haskell as I do...statically linking gmp isn't comfortable.
04:40:01 <eivuokko> Thanks, I'll try to poke it a bit more, but it seems even more work, again :-(
04:43:32 <dcoutts> JaffaCake, how close are we to doing that on Unix? Ie rts as .so
04:49:47 <cbus> @index mapAccumL
04:49:47 <lambdabot> Data.List
04:52:53 <aleator> Anyone else have a feeling that ghci lacks few essentials?
04:53:22 <dcoutts> aleator, eg?
04:53:45 <aleator> Matlabs diary command if foremost in my mind now..
04:54:03 <GnuVince> What's that command?
04:54:29 <aleator> Thingy that logs what you write in repl.
04:54:31 <dcoutts> I suspect many additionl features that people want for ghci should go into an IDE.
04:54:55 <joelr1> JaffaCake: can you suggest anything? i'm launching a thread to launch thousands of others. as the number of launched threads gets above 3k or so (1k launched bots with network traffic) the launcher slows down drastically
04:55:36 <musasabi> joelr1: do you need 3 threads / bot ?
04:55:49 <JaffaCake> joelr1: I wonder if it's GC cost
04:56:06 <joelr1> musasabi: maybe not. but what i do is set up a separate channel into the bot, a mailbox for the network reader/writer which is itself 2 threads
04:56:17 <joelr1> JaffaCake: i'm profiling as we speak. -hc -sgcstat
04:56:35 <JaffaCake> joelr1: you might try tweaking +RTS -k
04:56:39 <joelr1> JaffaCake: but it's not that the launcher is getting thousands of times less priority, is it?
04:56:50 <joelr1> to give it a big heap from the start?
04:56:52 <dcoutts> joelr1, perhaps it's just that your launching thread is then competing with all the threads it launched.
04:56:54 <joelr1> i'll tr y that next
04:57:17 <dcoutts> joelr1, perhaps you should block the launched threads until they're all launched, then let them go.
04:57:19 <JaffaCake> dcoutts: that would certainly happen, yes
04:57:19 <joelr1> dcoutts: right, my thinking
04:57:37 <joelr1> dcoutts: this is gonna be a pain in the rear and would overwhelm the server
04:57:54 <joelr1> dcoutts: the accept queue is only so long and i have to space my launches even now
04:57:57 <joelr1> by 1 second
04:58:36 <xerox> Howdy
04:58:58 <kowey> hi haskellers
04:59:25 <joelr1> dcoutts, JaffaCake: so what do you suggesT?
04:59:25 <JaffaCake> joelr1: +RTS -k3k might help
04:59:53 <joelr1> JaffaCake: what does that mean? /looking up the options/
05:00:09 <JaffaCake> -k is the default stack size
05:00:19 <joelr1> JaffaCake: oh, up from 1k?
05:00:24 <joelr1> how does that help?
05:00:26 <JaffaCake> if you make it bigger than 2k, but smaller than 4k, each thread gets its own block in the storage manager
05:00:43 <JaffaCake> which prevents it from being copied during GC
05:00:47 <joelr1> JaffaCake: wow
05:00:54 <joelr1> that advice is priceless
05:00:58 <JaffaCake> it's only a thought, I'd be interested if it helps
05:01:34 <joelr1> JaffaCake: will try that next. I'm trying with -threaded first :D
05:01:43 <musasabi> joelr1: why not just do the IO in the bot thread? (can either make things better or worse depending on your patterns)
05:01:50 <joelr1> JaffaCake: i compiled my library with -threaded but did not link the program with -threaded at the time
05:02:12 <joelr1> musasabi: io meaning the socket io? well, i like the STM way of polling for input on the different channels
05:02:17 <JaffaCake> gotta disappear for a bit, later folks
05:02:28 <joelr1> musasabi: if i don't do it the stm way then i think my bot will block 
05:02:33 <musasabi> mmh
05:02:49 <joelr1> and i will have to resort to timeouts, i.e. the timed read from the socket that gets killed after a while
05:03:03 <joelr1> right now i just have a thread read, post to a TMVar, loop
05:07:32 <joelr1> musasabi: what do you think/
05:11:32 <musasabi> joelr1: without seing the code it is quite hard to make informed opinions.
05:12:39 <joelr1> musasabi: let me show you the code
05:14:32 <bracx> Hi, I am learning haskell and have a question?
05:14:46 <bracx> I am trying to understand variables in haskell
05:15:01 <bracx> One of the tutorials said that everything is a function
05:15:13 <bracx> so is y = 4 really just
05:15:16 <bracx> y = ((\x -> x) 4)
05:15:51 <Oejet> bracx: Or, y(x) = 4.
05:15:59 <tromp_> i'd say  ((\x -> x) 4) is just 4 :)
05:16:31 <joelr1> musasabi: ping
05:16:43 <joelr1> musasabi: please take a look at paste
05:17:37 <Oejet> Hm, y(x) = 4 is wrong, since then y takes one argument.
05:17:38 <bracx> but how is the variable y evaluated is it a function that returns 4 or just 4
05:17:43 <Oejet> @info const
05:17:43 <lambdabot> Unknown command, try @listcommands.
05:19:09 <Oejet> Well, it's a function, since I think, it doesn't even look at 4 before it's needed.
05:19:48 * Oejet doesn't know. :'(
05:20:00 <tromp_> if you say let y=4 in ...., then y is a name for the number 4 in the remainder
05:20:10 <bracx> ok so the same with local variables then
05:20:23 <tromp_> and 4 is a constant, which you may consider a 0 argument function
05:20:43 <bracx> a function like
05:20:58 <bracx> cube x =
05:21:13 <bracx> let sq = x * x
05:21:19 <tromp_> except cube is not a constant
05:21:25 <bracx> in sq * x
05:21:32 <bracx> is really  just
05:21:42 <bracx> cube = (\x -> ((\sq -> sq * x) (x * x)))
05:21:58 <bracx> is that right?
05:22:24 <tromp_> yep
05:22:32 <xinming> why not use  x * x * x? :-/
05:23:16 <musasabi> pong
05:23:19 <bracx> trying to understand local variables how they are initiated and used
05:23:30 <joelr1> musasabi: take a look at paste please
05:23:32 <bracx> so that was just a test function
05:23:38 <tromp_> let x=y in z is shorthand for (\x->z) y
05:23:51 <musasabi> paste, where? (was doing work stuff)
05:24:00 <joelr1> @paste
05:24:01 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:24:14 <tromp_> except that you can only use x in y
05:24:22 <joelr1> musasabi: do you code haskell for a living?
05:25:20 <musasabi> joelr1: partially.
05:25:42 <bracx> thanks :)
05:25:59 <joelr1> musasabi: i will fix the exception handling in writeLoop and readLoop as per haskell-cafe, haven't gotten to it yet
05:29:14 <musasabi> joelr1: is all the locking really necessary in that fashion?
05:29:38 <joelr1> musasabi: what locking are you referring to?
05:29:42 <joelr1> musasabi: ah!
05:29:52 <joelr1> musasabi: well, that's cause i want either thread to clean up
05:30:18 <joelr1> musasabi: both the reader and the writer share the same ssl context and socket handle
05:30:42 <joelr1> musasabi: it used to be that the first thread to die killed the other one
05:30:56 <joelr1> but right now they just send an event to the parent
05:31:45 <musasabi> why not just use a "MVar (IO ())" and finalizing is "modifyMVar_ mv $ \act -> act >> return ()", then they can both unconditionally finalize.
05:32:00 <joelr1> which proceeds to kill them. also, after i put exception handling around the "forever loop" one of the threads will just exit and clean up and then the parent will try to kill both and the other thread will try to clean up, etc.
05:32:13 <joelr1> musasabi: thinking
05:32:56 <joelr1> musasabi: so you mean one lock around the whole finalizer instead of individual locks around each resource?
05:32:59 <handongseong> i want a pattern matching like (3 || 4), both 3 and 4 meet the pattern. can i do this with pattern or should i use guards?
05:33:51 <joelr1> musasabi: please feel free to modify the code, btw
05:35:06 <musasabi> yes, something like that.
05:35:22 <musasabi> have to get other code done today.
05:35:22 <joelr1> musasabi: any other suggestions?
05:36:26 <joelr1> musasabi: thanks :D
05:40:04 <Oejet> handongseong: Do it with guardes.   I think, it cannot be done with pure pattern matching, at least not without extentions to the language.
05:40:55 <Philippa> that, or dispatch both 3 and 4 to the same named function
05:41:11 <Philippa> (but guards're probably preferable here)
05:42:29 <dblhelix> mmm... can it be that setPosition in Parsec is broken?
05:43:39 <dcoutts> Yay! The UUAG system is now cabalised. And we've got a gentoo ebuild ready!
05:43:49 <joelr1> what's UUAG?
05:43:52 <dcoutts> @where uuag
05:43:53 <lambdabot> I know nothing about uuag.
05:44:04 <dcoutts> @where+ uuag http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
05:44:05 <Philippa> the Utretch University Attribute Grammar system
05:44:05 <lambdabot> Done.
05:44:14 <joelr1> interesting
05:44:14 <Philippa> er, Utrecht even
05:46:18 <kowey> shapr: did you get my mail re: the darcs wiki, btw? (i'm asking because you had mentioned some antispam system)
05:56:42 <Oejet> Anyone mind looking at a small program, I wrote?  It's on the paste page.  I'm a bit stuck.
05:59:52 <tromp_> where's paste page again?
06:00:03 <Oejet> @paste
06:00:04 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:01:21 <Oejet> main launches ten worker threads, who are synchronized with a barrier.
06:02:49 <Oejet> The problem is, the barrier doesn't help, and I can't realize why.
06:18:10 <TuringTest> @djinn  (b -> Maybe (a, b)) -> b -> [a]
06:18:11 <lambdabot> -- f cannot be realized.
06:21:13 <TuringTest> @type Data.List
06:21:15 <lambdabot> Couldn't find qualified module.
06:21:15 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:21:15 <lambdabot> \\)?
06:21:53 <TuringTest> @type List.List
06:21:54 <lambdabot> Not in scope: data constructor `List.List'
06:22:10 <ski> TuringTest : what're you trying to do ?
06:22:20 <ndm> @where hacle
06:22:21 <lambdabot> I know nothing about hacle.
06:22:22 <TuringTest> See if djinn can handle List better.
06:22:34 <TuringTest> It does Either well, but not List
06:22:37 <ndm> @where+ hacle http://www-users.cs.york.ac.uk/~mfn/hacle/
06:22:38 <lambdabot> Done.
06:22:42 <ndm> @where hacle
06:22:43 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/hacle/
06:22:50 <xerox> What does 'breadth first' mean?
06:23:20 <tromp_> expore shallow nodes before deeper nodes
06:23:36 <tromp_> so, layer by layer in a tree
06:27:18 <xerox> tromp_: is ther an idiomatic way of doing it in Haskell?
06:27:22 <xerox> there, even
06:34:58 <tromp_> there's Data.Graph.Inductive.Query.BFS
06:35:07 <Oejet> xerox: Breadth first algorithms are usually described with mutable nodes, that is, they change the colour of the nodes, as they visit them.  This makes it a bit harder in Haskell.
06:36:00 <tromp_> or you can easily implement your own BFS with Data.Queue
06:36:17 <xerox> I want to do it for the classical: data Tree a = Leaf a | Branch a (Tree a) (Tree a)
06:38:11 <tromp_> see levels in Data.Tree
06:39:53 <xerox> @libsrc Data.Tree
06:39:54 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Tree.hs
06:41:37 <musasabi> Is there a way to do Data.Map.insertOrUpdate :: Ord k => (Maybe v -> v) -> k -> Map k v -> Map k v ?
06:42:24 <ibid> @type Data.Map.insertWith
06:42:25 <lambdabot> forall a k.
06:42:25 <lambdabot> (Ord k) =>
06:42:25 <lambdabot> (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
06:42:50 <musasabi> ibid: that does not help, because my values are not Eq
06:43:20 <ibid> musasabi: uh, how does that need Eq?
06:43:22 <musasabi> and there is no identity values.
06:43:33 <ibid> ?
06:43:53 * musasabi misthinked
06:43:58 <ibid> bah, bus time, bbl
07:01:52 <adept> am I right that record label right now are not first-class and could not be made first-class?
07:03:52 <adept> i have Record { a::Int, b::Int, c::Int } , and use it as a state for StateT. Thus i have a lot of things like "state <- get; put $ state { a = 5 }". I wanted to make a syntax sugar to be able to do "set a 5", however, it turned out that I cannot pass record name as parameter. Am I doomed? :)
07:09:04 <tromp_> you can define a seta
07:09:54 <adept> tromp_: could you expand a bit? what is "seta"?
07:10:41 <tromp_> seta a = modify (Record {_,b,c} -> Record {a,b,c})
07:11:01 <ski> seta x = do state <- get; put $ state {a = x}
07:11:37 <tic> that's the only way, right? not possible at all to do what he asked for?
07:11:39 <adept> ah.
07:11:39 <tic> (also curious)
07:12:12 <adept> thats the only way, right? Right now I have, like, 20 fields there and it is plain tedious to define 40 functions.
07:19:15 <tromp_> you don't have to name the functions
07:19:49 <xerox> tromp_: missing a '\' before?
07:19:59 <tromp_> modify (\state -> state {a = 5})
07:20:16 <tromp_> nod
07:22:02 <adept> @index modify
07:22:03 <lambdabot> Control.Monad.State, Control.Monad.RWS
07:22:13 <adept> @type modify
07:22:14 <lambdabot> Not in scope: `modify'
07:22:28 <adept> @type Control.Monad.State.modify
07:22:29 <lambdabot> forall (m :: * -> *) s.
07:22:29 <lambdabot> (Control.Monad.State.MonadState s m) =>
07:22:29 <lambdabot> (s -> s) -> m ()
07:23:05 * adept feels stupid
07:23:13 <adept> should read more docs :)
07:29:59 <Pupeno> How do I compile a program that contains "foreign import ...", I get syntax error before import (some FFI extension) ?
07:30:46 <xerox> -fffi
07:31:18 <beelsebob_> :O!!!!!!
07:31:29 * beelsebob_ appears to have written a non-deterministic haskell program
07:31:33 <beelsebob_> ... how the fuck 
07:31:38 <Pupeno> xerox: and how do I specify that in a .cabal file ?
07:32:02 <xerox> beelsebob_: that's doable :-)
07:32:16 <xerox> Pupeno: 'ffi' in some 'depend' section?
07:32:30 <beelsebob_> xerox: without using the IO monad except the interact function?
07:32:44 <xerox> @typeinteract
07:32:45 <lambdabot> Unknown command, try @listcommands.
07:32:51 <xerox> @type interact
07:32:52 <lambdabot> (String -> String) -> IO ()
07:32:55 <beelsebob_> I have a purely functional piece of code exhibiting non-determinism
07:32:56 <Pupeno> xerox: I get "cannot satisfy dependency ffi-any", I could make a ghc option, but then maybe it won't work on other implementations.
07:33:21 <xerox> Pupeno: I don't know much about cabal, check its documentation, I'd say :-(
07:33:27 <xerox> beelsebob_: show us!
07:33:40 <xerox> ..hide your unsafePerformIOs before ;-)
07:33:43 <beelsebob_> haha
07:34:03 <beelsebob_> there are unsafePerformIOs in the code - but the hat traces show they are never demanded
07:34:26 <xerox> o_O
07:35:02 <beelsebob_> the hat traces show the result of detect being "stuff stuff stuff <end highlight char>\n" on the first run, and "stuff stuff stuff \n<end highlight char>" on the second run
07:35:11 <beelsebob_> with no IO within the call
07:35:55 <xerox> Well... the order of evaluation can be everything, if it matters (?)
07:36:16 <beelsebob_> yeh... but the order of evaluation is defined in the Haskell standard
07:36:24 <beelsebob_> left to right outside to inside
07:36:26 <xerox> Is it?
07:36:33 <beelsebob_> oh... no it isn't
07:36:36 <beelsebob_> that's just what ghc does
07:36:36 <chrisbrown> im not sure it is
07:36:40 <chrisbrown> yeah
07:36:44 <beelsebob_> not even lazyness is defined
07:36:52 <beelsebob_> but... yeh... ghc always does that
07:36:58 <xerox> I don't know :-)
07:37:02 <chrisbrown> perhaps a bug in ghc?
07:37:09 <chrisbrown> its not the first time ive seen a bug in ghc
07:37:23 <beelsebob_> but... once it's compiled, surely it's impossible to get non-deterministic behaviour?
07:37:25 <xerox> Well, thoe unsafe* ?
07:37:55 <sdjp> beelsebob_, you runinng on an SMP or hyperthreading system?
07:38:17 <beelsebob_> sdjp: nope, iBook 1.33 Ghz single processor
07:38:29 <sdjp> Ah well, so much for that theory!
07:38:39 <beelsebob_> if I run with yhc it gives a consistant result
07:38:47 <chrisbrown> must be ghc then
07:38:50 <beelsebob_> indeed
07:39:06 <beelsebob_> well... or my laptop is breaking the laws of physics
07:39:15 <beelsebob_> hang on... I'll try it on a linux box
07:39:50 <xerox> ..can you produce a testcase?
07:40:07 <beelsebob_> not immediately... I'll do one if I can't figure it out
07:40:12 <beelsebob_> it's kinda embedded in hat
07:43:27 <beelsebob_> hmm, I must go and meet olaf, I'll be back in a bit when I've talked to him about it
07:45:31 <glauber_sp> hi guys =) I'm reading the craft of functional prograaming and I uses hugs. I installed ghc. I tryed : load Script.lhs and there's a syntax error in the line that starts with #####. is it not possible to load literate scripts?
07:46:16 <chrisbrown> what is the syntax error? make sure there is a newline between lines with > and lines without
07:46:35 <glauber_sp> it's the first line of the file
07:46:40 <glauber_sp> ###############################
07:46:41 <glauber_sp> just it
07:46:45 <chrisbrown> is there a new line after that line
07:46:54 <glauber_sp> yes
07:47:06 <chrisbrown> i.e 
07:47:06 <chrisbrown> ##########################
07:47:06 <chrisbrown> > module Blah....
07:47:06 <lambdabot>  parse error on input `module'
07:47:26 <glauber_sp> ###########################################################
07:47:26 <glauber_sp>   FirstLiterate.lhs
07:47:26 <glauber_sp>   Simon Thompson, June 1998
07:47:27 <chrisbrown> is there a '>' character at the start of that line?
07:47:37 <glauber_sp> ops, there are new lines
07:47:55 <glauber_sp> no, just like I paste
07:48:17 <chrisbrown> there is no haskell in the module?
07:49:07 <glauber_sp> there is, but only 10 lines after the ######
07:49:41 <chrisbrown> but is there a blank line seperating the comments from the code? and does each line of code start with a '>' character?
07:50:16 <glauber_sp> yes
07:50:27 <glauber_sp> I just got the code from the site
07:50:45 <chrisbrown> what does the line that ghc is complaining about say?
07:51:07 <glauber_sp> FirstLiterate.lhs:1:1: lexical error
07:51:33 <chrisbrown> what does the line in the source code say where the module is defined?
07:51:38 <ski> hm, i think you shouldn't put '#' as first char in the file
07:51:57 <ski> (that's for scripts)
07:52:08 <glauber_sp> the file is file.lhs
07:52:11 <chrisbrown> shouldn't make much difference - its a comment
07:52:15 <glauber_sp> is a litetare script
07:52:30 <glauber_sp> the line is just #######################
07:52:30 <ski> maybe '#' scipt stuff still applies to lhs ..
07:52:35 <chrisbrown> its a plain text file which ghc parses, its not being run as a script
07:53:06 <chrisbrown> glauber_sp: the line where you define the module - what does it say?
07:53:07 <ski> no, but files that are scripts shouldn't have to be edited to load into ghci
07:53:21 <chrisbrown> they do if there is a syntax error
07:53:25 <ski> glauber_sp : try putting an empty line above first line in file
07:53:30 <glauber_sp> well, the lines ########### I changed to --######### and notw it works
07:53:43 <chrisbrown> cool
07:53:51 <ski> glauber_sp : or, really, change so that first char of file isn't '#'
07:54:05 <glauber_sp> ski, I tryed the new line, complains the same way, just change de line number
07:54:56 <glauber_sp> well, as I can see here, in any line the first char may be #
07:55:09 <glauber_sp> changing to anything else works
07:55:55 <ski> hm
07:56:04 <ski> maybe 'twas first nonempty line ..
07:57:00 <glauber_sp> ski, there are 2 lines with ###### and the second is some lines under the first. it complains too
07:57:17 <glauber_sp> putting a letter like d######### workd
07:57:25 <ski> did you try with an *empty* first line ?
07:57:28 <glauber_sp> maybe # should not start any line
07:57:49 <glauber_sp> ski, yes. an empty first line and the second one with ####
07:57:54 <ski> ok
07:58:00 <glauber_sp> it complains the same error, just change the line
07:58:02 <glauber_sp> =)
07:58:02 <chrisbrown> it still doesnt work?
07:58:09 <ski> so, i guess, first nonempty line shouldn't start with '#', then
07:58:13 <glauber_sp> chrisbrown, it works
07:58:22 * chrisbrown confused
07:58:38 <glauber_sp> chrisbrown, I changed the #### for -###
07:58:59 <glauber_sp> anything before the # make it works
07:59:34 <ski> anyway, this is so you could e.g. have as first (nonempty) line '#!/usr/bin/runghc', and setting the executable flag on the file
08:00:07 * Oejet waits for moderation on haskell.cafe...
08:00:16 <chrisbrown> ski: i didn't realise that would make a difference - i mean its just a comment, it can be any combination of characters surely?
08:00:31 <glauber_sp> chrisbrown, I thouhg it too
08:00:34 <chrisbrown> or it for a ghc processor directive?
08:00:43 <ski> except it's not a comment if first line starts with '#' .. special exception
08:00:43 <chrisbrown> very strange
08:00:44 <glauber_sp> but I guess # is not a "good' char heeh
08:00:49 <chrisbrown> but why?
08:00:59 <chrisbrown> its a haskell file - its not being run by the shell
08:01:35 <glauber_sp> well, it the first line is #!/bin/bash
08:01:37 <ski> [slj@Tsaia][~/haskell]> cat > Main.hs
08:01:37 <ski> #!/usr/bin/runghc
08:01:37 <ski> main = print "abc"
08:01:37 <ski> [slj@Tsaia][~/haskell]> chmod u+x Main.hs
08:01:37 <ski> [slj@Tsaia][~/haskell]> ./Main.hs
08:01:37 <ski> "abc"
08:01:39 <glauber_sp> it works ok
08:01:39 <ski> [slj@Tsaia][~/haskell]>
08:01:59 <NLoRD> hello
08:02:01 <chrisbrown> well - there you are running it as a shell script
08:02:03 <ski> chrisbrown : shell calls runghc, here
08:02:07 <ski> indeed
08:02:12 <chrisbrown> on its own its just a plain text file which ghc parses
08:02:32 <chrisbrown> and '#' as i see is a valid character in a comment
08:02:40 <NLoRD> is it possible to create a (n x n) table at haskell?
08:02:43 <ski> and, it'd be unreasonable to require removing the '#!' stuff, just to be able to load in normally into ghci
08:03:02 <ski> NLoRD : yes .. use (Int,Int) as index type
08:03:24 <chrisbrown> hmmm not sure i agree. but hey - i leraned something new! :)
08:03:51 <glauber_sp> guys, here I cannot use # as the first char, except if I use #!/blablalbla
08:03:58 <SamB> chrisbrown: eh
08:04:10 <glauber_sp> in any line
08:04:10 <ski> chrisbrown : though, maybe it could be argued that this shouldn't apply to literate files .. hmm
08:04:35 <SamB> ski: what difference does it make?
08:04:49 <glauber_sp> chrisbrown, if I put a space as the first char and then the ####, it works
08:05:14 <chrisbrown> the way i see it is this - the first line just so happens to be a comment with the first character is a '#'. when ghc parses this it should recognise it as a comment, hence if you leave the #! in,  it will still compile in ghc as it will think it is a comment
08:05:20 <NLoRD> ski I was thinking about a list that contains lists to create a n x n table
08:05:20 <SamB> ski: the programs which would object to shabang lines in literate scripts aren't Haskell implementations anyways
08:05:21 <glauber_sp> so the first char can be # only in the first line in the form #!/bla/bla
08:05:33 <SamB> chrisbrown: no
08:05:43 <ski> SamB : i was thinking, since it'd normally be a comment in literate, anyway (as opposed to in normal mode)
08:05:55 <SamB> chrisbrown: at least, I don't like that ;-)
08:06:00 <chrisbrown> SamB: why not?
08:06:07 <ski> NLoRD : yes, a list of lists is also possible
08:06:18 <SamB> ski: oh, well, so it doesn't make much difference how the Haskell implementation ignores it
08:06:41 <SamB> chrisbrown: I think it should just ignore the first line of the file when it starts with #!
08:06:45 <ski> > let n = 3 in [[ 10*y + x | x <- [0..n-1]] | y <- [0..n-1]]
08:06:46 <NLoRD> is there a guide or e-book that can help me create a list of list?
08:06:46 <lambdabot> [[0,1,2],[10,11,12],[20,21,22]]
08:06:56 <chrisbrown> SamB: thats not standard haskell though
08:07:09 <SamB> chrisbrown: this can be rememedied
08:07:25 <chrisbrown> and i cant rememember the standard saying anything about having #! at the start of literate files
08:07:51 <SamB> the standard doesn't need to, those are only going to bother formatters anyway
08:08:33 <chrisbrown> the point is if i write a haskell compiler i shouldn't need to check whether the first line is a #! or not
08:08:41 <SamB> because non-comment lines either have to be a) preceded by blank lines and prefixed with '>' or b) preceded by a "\begin{code}" line
08:09:03 <SamB> chrisbrown: you are lazy
08:09:06 <SamB> that is not hard
08:09:11 <chrisbrown> hahaha
08:09:15 <chrisbrown> never said it wasnt
08:09:24 <chrisbrown> does programatica check for that?
08:09:27 <chrisbrown> or hugs?
08:09:51 <SamB> well, runhugs doesn't mind them
08:09:55 <SamB> I think
08:10:29 <SamB> in any case, doesn't Cabal pretty much mandate that shabang lines work?
08:11:15 <ski> NLoRD : you can also, of course, build a list of lists of, recursively
08:24:25 <xerox> http://jjinux.blogspot.com/2005/12/haskell-breadth-first-tree-traversal.html#comments
08:24:33 <xerox> Hm.  Without '#comments'.
08:32:52 <kowey> i'm having some inconsistent behaviour with executeFile... could anybody help?
08:33:12 <kowey> sometimes, it goes fine, and sometimes it does 'executeFile: unsupported operation (Operation not supported)'
08:33:19 <kowey> and this is the same file i'm trying to execute
08:33:30 <SamB> huh
08:34:08 <SamB> @index executeFile
08:34:09 <lambdabot> System.Posix.Process, System.Posix
08:34:16 <SamB> @doc
08:34:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:34:39 <Lemmih> How about using System.Process?
08:34:46 <kowey> i'd love to
08:34:46 <kowey> but...
08:35:10 <kowey> when i use System.Process, i get this weird behaviour where the thing i'm executing never comes back
08:35:41 <kowey> it's stumped me forever, i hate keeping around this old ugly code with the forks and what nots (since i know vaguely that System.Process does the same thing, but smarter)
08:35:49 <kowey> yet it works "better"
08:36:27 <SamB> never comes back?
08:36:32 <kowey> here is the ugly code i hate keeping around btw: http://www.loria.fr/~kow/darcs/Geni/src/geni/SysGeni.lhs
08:36:54 <Oejet> Perhaps related to buffering?
08:36:56 <kowey> yeah... never comes back... if i look at it in top
08:37:03 <kowey> you can tell that it's no longer doing any work
08:37:06 <kowey> the subprocess
08:37:15 <kowey> but it just does not want to die
08:37:30 <cmunier> I'm to design a list datatype which allows having functions for element insertion at the beginning and the end of the list structure without working recursively, i.e. doing multiple steps. My first attempt was to define this via three constructors (empty list, element of a certain datatype, and concatenation of two of my list types). but as I'm building my list from a native haskell list, I get parenthesis detaining me from working with 
08:37:31 <cmunier> the list as I'd like. Any ideas?
08:37:33 <SamB> maybe you need to wait on it somehow?
08:37:37 <Lemmih> Perhaps it was a zombie process.
08:38:06 <kowey> well... i'm using runInteractiveProcess and waitForProcess
08:38:16 <kowey> strange thing is that it works for graphviz
08:38:28 <kowey> but when i try calling a shell script doing the same thing, i get this never-come-back behaviour
08:38:53 <SamB> cmunier: I don't understand the problem very well
08:39:16 <SamB> though I must point out that your lists sound inefficient to access...
08:39:24 <kowey> here is the offending code (the never-come-back code: http://www.loria.fr/~kow/darcs/Geni/src/geni/Geni.lhs )
08:39:34 <kowey> if you search for "runPiped"
08:40:00 <kowey> you can see that once upon a time, i tried to use System.Process's runInteractiveProcess, followed by its waitForProcess
08:40:25 <kowey> but since that didn't work, i switched back to my ugly forky stuff, and now the inconsistent behaviour with executeFile... :-/
08:40:41 <SamB> kowey: did this process produce output or want input on stdout or stdin?
08:41:07 <SamB> cmunier: perhaps you could paste some code?
08:41:13 <kowey> the process reads stdin and put stuff on stdout
08:41:21 <kowey> and i try to read the stuff that it puts on its stdout
08:41:21 <cmunier> SamB, uh, okay. The cons operator on native Haskell lists allows non-recursive insertion of elements at the start of a list. It might be desirable being able to insert elements at the end of the list as well, but i.e. without (++), 'cause it's not as fast as cons. So I'd like to have a list type where this function can be as fast as cons..
08:41:52 <SamB> cmunier: maybe you should read okasaki ;-)
08:42:11 <cmunier> Huh? :-)
08:42:27 <SamB> he's a purely functional datastructure guru
08:43:12 <cmunier> Hm. Where do I find him?
08:43:17 <dcoutts> Okasaki's book is excelent.
08:43:31 <dcoutts> "Purely Functional Data Structures"
08:43:39 <dcoutts> @google Purely Functional Data Structures
08:43:42 <cmunier> *giggles* oh-kay, a book. Thank you. :-)
08:43:42 <lambdabot> http://www-2.cs.cmu.edu/~rwh/theses/okasaki.pdf
08:43:48 <dcoutts> hmm
08:44:09 <dcoutts> oh that's his thesis, not his book
08:44:22 <SamB> the two *are* related
08:44:28 <SamB> the thesis is what I actually meant
08:44:30 * cmunier smirks.
08:45:29 <cmunier> Alas, for the time being I have to leave. Farewell & thanks. :-)
08:49:25 <kowey> sniff... geni: internal error: mallocBytesRWX: failed to protect 0x0x84f9fd0
08:50:00 <SamB> ???
08:50:14 <adept> I have "data A = A | B [Int]". I want to have "instance Arbitrary A where" such that "B" will be constructed ONLY with lists of Int's >= 0. What is the proper way to go about that?
08:50:27 <kowey> i was trying to see what goes on under Linux with the process stuff, and i get this ghc internal error
08:50:35 <kowey> oh la la...
08:50:50 <adept> right now I hacked something around "elements [ 0, 1, 2, 3, 4, 5]", but it doesnt feel right
08:51:39 <adept> @type resize
08:51:40 <lambdabot> Not in scope: `resize'
08:51:46 <adept> @index resize
08:51:47 <lambdabot> Test.QuickCheck, Debug.QuickCheck
08:51:56 <adept> @type Test.QuickCheck.resize
08:51:57 <lambdabot> forall a. Int -> Test.QuickCheck.Gen a -> Test.QuickCheck.Gen a
08:52:20 <SamB> adept: whatcha upto?
08:52:31 <adept> SamB: huh? :)
08:53:08 * adept is SO non-native english speaker
08:53:12 <tromp_> use [Word], adept
08:53:12 <SamB> oh, what are you doing with all this quick-checkery?
08:53:27 <SamB> tromp_: now thats an idea!
08:53:41 <adept> SamB: QC for bitfield encoding/decoding in wireprotocol
08:54:07 <SamB> adept: ah
08:54:17 <SamB> is this for the encoding part?
08:54:56 <adept> SamB: and for decoding as well. I have strong feeling that I made some mistake there
08:55:05 <SamB> maybe we should change PieceNum to be Word?
08:56:05 <ski> adept : maybe define alternate "arbitrary" for Ints ?
08:56:20 <adept> ski: just overriding instances?
08:56:36 <ski> no, i meant another function, of same type
08:56:47 <adept> SamB: cool idea, though I fear to change int to word there and press C-c C-r :)
08:56:59 <ski> @index arbitrary
08:57:00 <lambdabot> Test.QuickCheck, Debug.QuickCheck
08:57:09 <ski> @type Debug.QuickCheck.arbitrary
08:57:10 <lambdabot> forall a. (Test.QuickCheck.Arbitrary a) => Test.QuickCheck.Gen a
08:57:23 <ski> s/function/action/
08:57:30 <adept> ski: ah. i see.
08:58:04 <ski> define 'arbitraryNonNeg :: Gen Int' and use that (possibly even unfolding it ..)
08:58:22 <SamB> adept: don't be so scared of change
08:58:34 <SamB> the type errors will guide your path and keep you safe ;-)
08:59:43 <SamB> or you could just (liftM fromIntegral (arbitrary :: Gen Word))
08:59:48 <adept> SamB: I tried. First, it means "import Data.Word" everywhere
08:59:51 <SamB> er. no.
09:00:04 <SamB> adept: oh, does it?
09:00:06 <SamB> ouch.
09:00:18 <SamB> maybe it should be a whole new integral type?
09:00:42 <kowey> oh happy very confused day!
09:00:49 <SamB> or maybe you really need something different from what you think you need?
09:00:59 <SamB> like, there shouldn't be any dupes in this list either.
09:01:04 <kowey> all of a sudden, runInteractiveProcess and waitForProcess work
09:01:12 <SamB> kowey: hehe
09:01:14 <kowey> maybe something changed between ghc 6.4 and 6.4.1...
09:01:21 <SamB> most likely!
09:01:26 <SamB> 6.4 has a lot of breakage
09:01:33 <kowey> yay! i can dump my ugly forks now!
09:01:51 <SamB> and buy nice sparkling new ones!
09:02:06 <kowey> hehe
09:02:41 <SamB> have you ever wondered why, when you pass a fork in the road, you don't go both ways?
09:03:45 <SamB> I haven't.
09:03:57 <SamB> hmm
09:03:59 <SamB> a simon
09:04:14 <SamB> ... with an Unknown realname.
09:04:39 <ski> could be a Sigurd ..
09:04:48 <SamB> ADEpt: hullo
09:05:05 <SamB> ADEpt: so, shouldn't these piece numbers be in a specified range
09:05:09 <SamB> and have no duplicates?
09:05:13 <ADEpt> SamB: yep. I fell over the board :(
09:05:25 <ADEpt> SamB: yep, they should
09:05:36 <ADEpt> SamB: are you thinking what i am thinking? :)
09:06:05 <SamB> yes, brain, but where are we going to get a working Self for x86?
09:06:20 <ADEpt> :))))))))
09:06:39 <ADEpt> SamB: so, what ELSE are you thinking?
09:06:43 <SamB> hmm.
09:07:27 <ski> http://research.sun.com/self/
09:07:29 <SamB> that we want something of type [a] -> Gen [a]?
09:07:34 <ADEpt> SamB: right before i got disconnected i was going to say that i'm scared of Word simply because i haven't used it before
09:07:38 <SamB> ski: thats for PPC and SPARC
09:07:53 <SamB> the x86 versions are trickier to come by
09:07:56 <SamB> ADEpt: hehe
09:08:28 <ADEpt> SamB: Word is a machine word, right?
09:08:56 <ski> SamB : right .. saw that now
09:09:33 <ski> Word is unsigned Int, i think
09:11:01 <ADEpt> @docs Word
09:11:02 <lambdabot> Word not available
09:11:12 <ADEpt> @docs Data.Word
09:11:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
09:11:44 <ADEpt> ski: indeed
09:11:55 <ADEpt> SamB: So maybe I'll change it to Word, then
09:23:13 <kowey> uh-oh
09:23:23 <SyntaxNinja> woowoo
09:23:24 <kowey> the not-coming-back behaviour returns!
09:23:42 <kowey> it seems that it's when i've got a graphical interface that it does that
09:25:07 <dcoutts> SyntaxNinja, we were wondering earielr if there were any machines at your work place that might have some sparce capacity for running overnight builds/test of ghc?
09:26:01 <dcoutts> SyntaxNinja, we were talking to JaffaCake eariler about the idea of building a whole bunch of gentoo ebuilds using an ebuild of ghc taken freshly from darcs each night.
09:26:45 <dcoutts> SyntaxNinja, the point is it'd give a differnet kind of coverage compared to the nofib testsuite.
09:26:54 * ADEpt can do debian-x86-based builds-tests
09:27:38 <dcoutts> eg we'd build things like darcs, haxml, cpphs, hs-plugins, wxHaskell, gtk2hs, etc etc
09:28:07 <dcoutts> latest version of cabal... etc
09:29:29 <frederik_> is there a type with no values?
09:29:39 <SyntaxNinja> dcoutts: interesting. I had hoped to do soemthing like that w/ hackage at some point. everyone provides a ./setup test command and we run the test suite overnight.
09:29:54 <SyntaxNinja> dcoutts: what kinda hardware we talkin' here?
09:29:55 <tromp_> every type has value undefined
09:30:33 <dcoutts> SyntaxNinja, right, and something like cabal-get or gentoo portage makes that kind of "build loads of packages" easier to run.
09:30:46 <SyntaxNinja> yeah
09:31:00 <dcoutts> SyntaxNinja, any ordinary box or VM on an ordinary box
09:31:01 <frederik_> tromp_: that doesn't sound like a value to me :)
09:31:17 <frederik_> tromp_: but in that case, is there a type with only the undefined value?
09:31:20 <dcoutts> SyntaxNinja, preferably networked and on 24/7
09:31:37 <dcoutts> SyntaxNinja, and ideally with ssh access for maintainance
09:31:57 <kowey> frederik_, is () what you're looking for?
09:32:01 <frederik_> nope
09:32:10 <tromp_> () has value ()
09:32:14 <dcoutts> SyntaxNinja, that's the problem with the box that JaffaCake's got - no outside ssh access allowed. So the maintainance would fall to him.
09:32:16 <SyntaxNinja> dcoutts: an i386 then? why should it be here, ooi?
09:32:36 <SyntaxNinja> dcoutts: would we have to maintain it?
09:32:42 <tromp_> hmm, i don't know how you'd define a type without any constructoes
09:32:45 <tromp_> tors
09:32:47 <SyntaxNinja> suddenly pump has stopped working :(
09:33:27 <dcoutts> SyntaxNinja, not sure. depends on what you'd want to arrange. We were thinking of a box or VM running gentoo so we can use the ebuild infrastructure.
09:33:29 <frederik_> oh that's it
09:33:32 <frederik_> `Foo' has no constructors (-fglasgow-exts permits this)
09:33:44 <frederik_> thanks tromp_
09:33:47 <SyntaxNinja> an abstract type
09:33:49 <tromp_> what Foo?
09:33:52 <dcoutts> SyntaxNinja, it's just that none of our home machines are sufficiently available
09:33:52 <SyntaxNinja> FOO!
09:34:00 <SyntaxNinja> dcoutts: yeah. hmm.
09:34:08 <frederik_> it was an example i tried
09:34:13 <frederik_> doesn't that make it uninstantiable?
09:34:20 <dcoutts> SyntaxNinja, and we like to have working compilers on our machines :-)
09:34:37 <dcoutts> SyntaxNinja, dedicated machines (or VM images) make that kind of testing easier.
09:34:56 <SyntaxNinja> dcoutts: so we could probably provide hosting for a box, we could perhaps provide a vm on hackage (or a chroot or whatever)
09:35:01 <SyntaxNinja> hackage.haskell.org that is
09:35:05 <dcoutts> SyntaxNinja, otherwise we can think about something smaller that could more easily be run on normal people's boxes.
09:35:19 <SyntaxNinja> dcoutts: no promises, btw, I have no auth here, but I can ask...
09:35:32 <frederik_> tromp_: i just put "data Foo" in a file
09:35:33 <dcoutts> SyntaxNinja, sure, no promises. It's just an idea.
09:35:34 <SyntaxNinja> dcoutts: if someone got us a box, we could probably host it
09:35:39 <tromp_> i guess you can define a function foo : Foo
09:35:43 <tromp_> foo = foo
09:35:49 <dcoutts> SyntaxNinja, a VM or chroot would be fine.
09:35:58 <tromp_> ghc doesn't like data Foo without constructors
09:36:07 <SyntaxNinja> tromp_: it's an extension
09:36:20 <frederik_> why do people call computers boxes
09:36:27 <tromp_> ah, ok
09:36:30 <frederik_> soon we will be studying box science
09:36:33 <dcoutts> frederik_, because they are cuboid?
09:36:45 <frederik_> mine is shaped like an "L"
09:36:49 <dcoutts> heh
09:37:19 <SyntaxNinja> frederik_: I was actually just talking about a cardboard box. I'm not sure what dcoutts was talking about
09:37:30 <dcoutts> hah!
09:37:30 <frederik_> ... for "L"aptop
09:38:01 <frederik_> yeah this is why we have lawyers write contracts
09:38:01 <dcoutts> SyntaxNinja, I'll send you a flat-packed cardboard box for you to host.
09:38:28 <SyntaxNinja> dcoutts: do you think there's any chance of someone donating a computer to the effort? chroot on hackage is a possibility, but probably harder.
09:38:46 <dcoutts> SyntaxNinja, not sure.
09:39:28 <SyntaxNinja> it's always the case that there are lots of computers not being used, but no one wants to get rid of them until no one wants them.
09:39:32 <dcoutts> SyntaxNinja, the Gentoo Haskell team don't have any hardware apart from our desktop boxes I think. That's why I was asking around.
09:40:00 <SyntaxNinja> I would actually prefer to move hackage.h.o off of cvs.h.o
09:40:02 <dcoutts> SyntaxNinja, we don't need anything fast.
09:40:26 <kowey> sorry to keep coming back to this thing... i've got a waitForProcess issue... maybe somebody has ideas how to attack this (recap coming up)
09:40:28 <SyntaxNinja> so maybe we could get a dedicated machine to the "community" effort; or I could ask our sysadmin to divide it up into 2-3 virtual machines.
09:40:36 <kowey> i'm using waitForProcess to invoke some subprocess
09:40:48 <SyntaxNinja> kowey: if no one here answers, you might try a mailing list, like haskell-cafe.
09:41:10 <SyntaxNinja> dcoutts: did you package cabal-get, btw?
09:41:14 <kowey> if i run it on the command line, it does its thing and comes back in like 15 seconds (thx, SyntaxNinja, never occured to be to try)
09:41:34 <dcoutts> SyntaxNinja, not yet. How are recent versions doing?
09:41:45 <kowey> but if i run it as a subprocess using waitForProcess, it takes forever, never comes back and it top, seems to be processing a lot
09:42:24 <kowey> how do i even go about trying to figure out what's going wrong? (and contrary to last statement; it's got nothing to do with guis)
09:42:30 <dcoutts> SyntaxNinja, we had some concerns about packages installed by cabal-get and those installed by portage. Ideally we'd like to keep them seperate, or rather to make sure they don't interfear.
09:42:36 <SyntaxNinja> dcoutts: no real progress except it's easier to install.
09:42:41 <dcoutts> SyntaxNinja, eg always using /usr/local/
09:42:44 <SyntaxNinja> dcoutts: yeah, nice idea :)
09:43:24 <dcoutts> SyntaxNinja, we've got an ebuild for it but it's not generally available in portage yet.
09:43:26 <SyntaxNinja> kowey: can you paste the code somewhere?
09:43:31 <SyntaxNinja> dcoutts: OK. just checking.
09:43:33 <kowey> sure...
09:43:50 <kowey> the subprocess is being called from here: http://www.loria.fr/~kow/darcs/Geni/src/geni/Geni.lhs
09:43:50 <SyntaxNinja> dcoutts: I'm working on a tool called cabal-install that I want to reimplement cabal-get in terms of, or convince Lemmih to do it.
09:44:08 <dcoutts> SyntaxNinja, on the other hand our "hackport" tool it pretty cool. We're just waiting for more packages to turn up in Hackage.
09:44:12 <kowey> now, the runInteractiveProcess and waitForProcess are commented out, but that's because i've not done a record
09:44:32 <kowey> this is the thing i'm trying to invoke - it never comes back: http://www.loria.fr/~kow/darcs/Geni/bin/runXMGselector
09:45:09 <SyntaxNinja> what does hackport do?
09:45:10 <kowey> strangely, this other thing i'me trying to invoke does come back: http://www.loria.fr/~kow/darcs/Geni/bin/runXMGfilter (which is why i first thought everything is ok)
09:45:19 <SyntaxNinja> dcoutts: we have a bootstrapping problem w/ getting stuff in hackage.
09:45:43 <kowey> ooops, the function calling the subprocess is runSelector
09:45:45 <SyntaxNinja> kowey: you have checked to see that they actually terminate?
09:45:51 <dcoutts> SyntaxNinja, not only does our hackport tool generate ebuilds from packages in hackage, it also gives us reports on packages that are in hackage but not in our ebuild collection.
09:45:53 <SyntaxNinja> kowey: are they blocking on input or something?
09:46:03 <SyntaxNinja> dcoutts: wow, cool!
09:46:23 <SyntaxNinja> I should just start uploading everything to hackage and let people take over the packages later.
09:46:28 <dcoutts> SyntaxNinja, yeah. So like I said, we jsut waiting for more cool packages to appear in hackage.
09:46:34 <kowey> SyntaxNinja: i'm not sure how to introspect on this... 
09:46:36 <SyntaxNinja> dcoutts: why not upload some?
09:47:04 <kowey> SyntaxNinja: i can tell you that it seems to be eating up lots of CPU cycles when i look at it under top (the subprocess)
09:47:06 <SyntaxNinja> i was wrong about pump being broken, btw.
09:47:06 <dcoutts> SyntaxNinja, I'm not author of any cabalised packages. It'll be a little while before gtk2hs gets there.
09:47:27 <SyntaxNinja> Lemmih: feel like doing more hacking on the cabal-get stuff?
09:47:58 <Igloo> SyntaxNinja: Talking of which, do we have cabal-put in Debian yet?
09:48:17 <SyntaxNinja> dcoutts: it's driving me nuts. we're so close, but we just have this problem that people won't try out cabal-get until there are more packages.
09:48:28 <dcoutts> heh, yeah
09:48:29 <SyntaxNinja> Igloo: no. it's like 10 packages, so it's a PIA
09:48:43 <dcoutts> how easy is it to upload packages now?
09:48:54 <SyntaxNinja> just cabal-put foo-1.1.tgz
09:49:05 <SyntaxNinja> if you don't have a key, it'll ask you for one.
09:49:10 <SyntaxNinja> I mean, generate one
09:49:22 <SyntaxNinja> kowey: sorry, this is too complicated for me to look at right now.
09:49:25 <dcoutts> So we should get cabal-get and cabal-put tested and into portage.
09:49:47 <kowey> SyntaxNinja: no problem, thanks for the advice so far (same to rest of folks in channel)
09:50:11 <SyntaxNinja> kowey: no problem.
09:50:12 * Igloo jumps up and down pointing at the connection between packages not being cabal-put, and cabal-put not being easily available
09:50:19 <dcoutts> SyntaxNinja, and for cabal-get/install and dep chasing, you should talk to kosmikus. He's writing a portage-like program in Haskell.
09:50:43 <SyntaxNinja> dcoutts: oh really? 
09:50:49 <SyntaxNinja> dcoutts: does it use cabal or somethign else?
09:50:53 <GnuVince> Hello guys.
09:50:59 <dcoutts> SyntaxNinja, it uses ebuilds
09:51:08 <SyntaxNinja> ahh
09:51:09 <dcoutts> kosmikus, you about?
09:51:15 * SyntaxNinja pokes kosmikus
09:51:25 <SyntaxNinja> Igloo: I know. 
09:51:29 <dcoutts> SyntaxNinja, ebuilds are more complicated and fiddly than cabal packages.
09:51:38 <SyntaxNinja> of course!
09:51:39 <SyntaxNinja> ;)
09:51:52 <GnuVince> I have a question: I wrote a map2 function, but I think I basically just reimplemnted zipWith with another name.  Could you tell me if it's the case? http://gnuvince.net/?p=163
09:52:09 <GnuVince> Because from what I can understand in the documentation, both do exactly the same thing
09:52:21 <dcoutts> GnuVince, is that zipWith ?
09:52:26 <dcoutts> @type zipWith
09:52:27 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
09:52:56 <dcoutts> looks the same to me
09:53:05 <GnuVince> dcoutts: yeah?  Okay, thanks.
09:53:24 <GnuVince> Different namings.  That method is called 2map in Factor and mapWith: in Smalltalk.
09:53:37 <dcoutts> GnuVince, you don't need the map2 f [] [] = [] case. It's already covered.
09:53:37 <GnuVince> Thanks for the help
09:53:51 <GnuVince> It is?
09:53:51 <GnuVince> Ah
09:54:01 <dcoutts> see?
09:54:03 <GnuVince> Yes
09:54:14 <GnuVince> _ [] can represent both empty lists
09:58:33 <SyntaxNinja> dcoutts: does your fancy hackagePort tool see anything new? :)
09:58:41 * dcoutts checks
10:00:08 <SamB> hmm, GHC's version of C-- doesn't appear to have paramaters?
10:04:26 <dcoutts> SyntaxNinja, so where's the latest versions of hackage-client & cabal-get ?
10:04:54 <dcoutts> SyntaxNinja, still hackage-client-0.1.0 & cabal-get-0.2.1 ?
10:07:11 <ADEpt> SamB: see! once one of us says something about Word, he immediately drops off the channel :)
10:07:15 <musasabi> Is there a nice fold with read combinator ?
10:07:44 <musasabi> basically: foldRead :: Read a => String -> ([a],String)
10:07:51 <SamB> ADEpt: heh
10:08:11 <ADEpt> SamB: I Did It. And found the bug, btw.
10:08:43 <ADEpt> SamB: meaning, I did instance of arbitrary. Int => Word transition is still too scary.
10:08:56 <SamB> ADEpt: cool
10:09:32 <jethr0> @type foldRead
10:09:33 <lambdabot> Not in scope: `foldRead'
10:10:21 <ADEpt> ski: your advice was invaluable. I basically did another "arbitrary" and "vectorOf" and used them
10:11:33 <SamB> ADEpt: and you get no dupes?
10:11:58 <dcoutts> SyntaxNinja, hackport diff; hackport update; hackport diff;
10:12:00 <dcoutts> Packages in hackage, but not in the overlay:
10:12:00 <dcoutts>         djinn-2005-12-13
10:12:09 <dcoutts> (and a few others)
10:12:17 <dcoutts> but djinn is new
10:12:40 <ADEpt> SamB: i am eliminating dupes. Pull and see
10:12:51 * SamB tries
10:12:53 * dcoutts thanks der_eq & kolmodin for writing hackport
10:13:24 <jethr0> @listcommands
10:13:25 <lambdabot> use listcommands [module|command], please. Modules are:
10:13:25 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
10:13:25 <lambdabot> hoogle karma localtime more pl plugs poll quote search seen spell state
10:13:25 <lambdabot> system todo topic type version vixen where
10:13:35 <SyntaxNinja> dcoutts:yeah
10:15:07 <SyntaxNinja> dcoutts: and the .cabal file was bad on the first upload. now I need a simple tool to make sdist, unpack and try to build it :)
10:16:09 <dcoutts> SyntaxNinja, well I'm trying the ebuild that hackport generated
10:17:01 <SamB> why do we hava an instance of Show for (Int -> Bool)?
10:17:15 <jethr0> > even
10:17:15 * pesco jumps into the channel.
10:17:16 <lambdabot>  add an instance declaration for (Show (a -> Bool))
10:17:24 * pesco throws his arms into the air.
10:17:29 <dcoutts> SyntaxNinja, is "2005-12-13" a valid version number ?
10:17:35 <dcoutts> Version:	2005-12-13
10:17:36 <jethr0> *yeah* pesco
10:17:40 <SamB> jethr0: wrong we
10:17:44 <pesco> Yeah! I'm here.
10:17:48 * dcoutts thought it had to be 2005.12.13
10:17:58 <jethr0> wrong we?
10:18:11 <SamB> jethr0: in conjure
10:18:22 <pesco> (pesco just convinced his cable modem to supply Internet to his flat.)
10:18:37 <jethr0> no ideawhat you're on about...
10:18:50 <SyntaxNinja> dcoutts: well, technically, but it probably doesn't mean what he thinks it does.
10:19:04 <dcoutts> SyntaxNinja, hmm because it messed up hackport. :-(
10:19:21 <SyntaxNinja> dcoutts: version numbers have the form 1.2.3-asdf-asdf-sdf
10:19:41 <dcoutts> SyntaxNinja, oh really? oh ok. We'll have to deal with that.
10:19:46 <dcoutts> somehow.
10:20:04 <dcoutts> we can't really do non-numeric version numbers
10:20:13 <SamB> whats wrong with 0.0.20051213?
10:20:25 <dcoutts> except for some restricted cases, like _rc1 _pre etc
10:21:48 <SyntaxNinja> dcoutts: I uploaded a versin w/ a better version number
10:22:13 <dcoutts> SyntaxNinja, well appart from that problem (2 line fix needed in the ebuild) it works perfectly.
10:22:17 <SyntaxNinja> Lemmih: alive?
10:22:22 <SyntaxNinja> dcoutts: cool
10:22:37 <SyntaxNinja> dcoutts: the -asdf-asdf part can be pretty much ignored. they're tags for humans
10:22:52 <dcoutts> SyntaxNinja, they're not significant in the ordering?
10:23:14 <SyntaxNinja> dcoutts: correct
10:23:18 <dcoutts> SyntaxNinja, perhaps that could be noted in the spec and enforced in the tools.
10:23:19 <SamB> ADEpt: this is really starting to come together ;-)
10:23:44 <TuringTest> @djinn a -> Maybe a
10:23:45 <lambdabot> f = Just
10:23:50 <dcoutts> SyntaxNinja, if we don't enforce things in the tools there's no interoperability and nothing can be automated.
10:23:59 * dcoutts has said that many times before :-)
10:24:00 <SamB> I mean, we could use this on a TV show and nobody would know that it didn't work!
10:24:01 <SyntaxNinja> dcoutts: I'd be surprised if that's not the case?
10:24:03 <TuringTest> @djinn a->[a]
10:24:04 <lambdabot> -- f cannot be realized.
10:24:33 <TuringTest> hmmm...Am I missing something about Lists and djinn here?
10:24:53 <SyntaxNinja> dcoutts: I just uploaded fps
10:25:27 <ibid> thanks to everyone who helped me create exercises last week. here's a repayment: http://vegai.ravissant.net/fo05/d7/T13_15.hs :) (one of the sample solutions;)
10:26:07 <SyntaxNinja> hm, but fps doesn't quite work either. cursed sdist
10:26:10 <SamB> TuringTest: djinn, last I heard, was not going to understand recursive types any time soon
10:26:15 <ADEpt> SamB: yep
10:26:19 <TuringTest> Ah
10:26:47 <ADEpt> SamB: btw, you were absolutely right about unneeded asynchronity - nothing but troubles from it
10:27:16 <SamB> ADEpt: and here I was just thinking it would be inconvenient
10:28:07 <SyntaxNinja> there, fps works now
10:28:14 <dcoutts> SyntaxNinja, the new Djinn in hackage works first time now
10:28:42 <SyntaxNinja> Lemmih: cabal-put remove Djinn doesn't work :(
10:29:46 <SyntaxNinja> dons: hmp3 doesn't build, can't find P.PS?
10:29:48 <ADEpt> SamB: you should've seen it... If IST thread is busy with something, delays with requests for "gimme next piece" cause PeerThread to ask again and again. Only to get all 100 answers 3 seconds later :)
10:29:56 <SyntaxNinja> dcoutts: cool
10:30:45 <SamB> ADEpt: yeah. synchronization is important ;-)
10:31:38 <dcoutts> SyntaxNinja, and so does fps, including docs.
10:34:04 <SyntaxNinja> sweeeet
10:34:21 <SamB> now you know why query/responce is such a common pattern ;-)
10:34:51 <SamB> with blocking, even
10:34:56 <TuringTest> @djinn (a->b)->(Maybe a)->(Maybe b)
10:34:57 <lambdabot> f x1 x2 =
10:34:57 <lambdabot>   case x2 of
10:34:57 <lambdabot>   Nothing -> Nothing
10:34:57 <lambdabot>   Just v8 -> Just (x1 v8)
10:36:20 <wearpants> @pl \(x, y) f -> (x, f y)
10:36:21 <lambdabot> uncurry ((. flip id) . (.) . (,))
10:36:25 <SamB> I'm planning to use this technique in my ZMachine interpreter for communication between the frontend and the interpreter proper
10:37:36 <jethr0> turingtest, djinn seems to be coming along nicely... that is already nice generated code
10:37:39 * jethr0 is impressed
10:37:52 <xerox> Isn't it Control.Arrow.second ?
10:38:11 <jethr0> yes
10:38:12 <SamB> xerox: so fix pl
10:38:15 <TuringTest> I am just playing with it -- I read about elsewhere.
10:38:29 <jethr0> @type  \(x, y) f -> (x, f y)
10:38:30 <xerox> @pl \f (x,y) -> (x, fy)
10:38:31 <lambdabot> forall a b b1. (a, b) -> (b -> b1) -> (a, b1)
10:38:31 <lambdabot> const (flip (,) fy . fst)
10:38:34 <jethr0> @type Control.Monad.Arrow
10:38:35 <lambdabot> Not in scope: data constructor `Control.Monad.Arrow'
10:38:37 <xerox> @pl \f (x,y) -> (x, f y)
10:38:37 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
10:38:40 <jethr0> @type Control.Arrow.second
10:38:41 <lambdabot> forall (a :: * -> * -> *) c d b.
10:38:41 <lambdabot> (Control.Arrow.Arrow a) =>
10:38:41 <lambdabot> a b c -> a (d, b) (d, c)
10:38:45 <xerox> eh.
10:39:39 <wearpants> I was hoping that @pl would have given me that answer, but it doesn't really matter
10:39:49 <wearpants> it's just more convenient to have point-free code, sometimes
10:39:54 <jethr0> @help pl
10:39:55 <lambdabot>  @pointless <expr> - play with pointfree code
10:40:01 <jethr0> @listcommands
10:40:02 <lambdabot> use listcommands [module|command], please. Modules are:
10:40:02 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
10:40:02 <lambdabot> hoogle karma localtime more pl plugs poll quote search seen spell state
10:40:02 <lambdabot> system todo topic type version vixen where
10:40:02 <SamB> ADEpt: hmm, nice idea.
10:40:11 <jethr0> @listcommands pl
10:40:12 <lambdabot> pl provides: pointless pl-resume pl
10:40:30 <ADEpt> SamB: which one? :)
10:40:51 <SamB> let the PeerThread just report its whole status at a time, instead of having both PeerThread and the master seperately update their idea of the status
10:41:30 <lennart> @pl \ x -> case x of Nothing -> 0; Just y -> y+1
10:41:31 <lambdabot> (line 1, column 26):
10:41:31 <lambdabot> unexpected ">" or "-"
10:41:31 <lambdabot> expecting variable, "(", operator or end of input
10:41:50 <ADEpt> SamB: i think that peerthread has also report his identity along, otherwise master will not be able to distinguish reports from different children
10:42:25 <lennart>  @pl \ x -> case x of { Nothing -> 0; Just y -> y+1 }
10:43:01 <jethr0> @type curry
10:43:02 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
10:43:07 <SamB> ADEpt: well, my initial plan was to have a Chan (NodeId, PReport) or something like that
10:44:38 <SyntaxNinja> dcoutts: Frown uploaded
10:46:30 <dcoutts> SyntaxNinja, we've already got it :-)
10:46:44 <dcoutts> SyntaxNinja, it was added to portage eariler today
10:48:46 <dcoutts> SyntaxNinja, if you're looking for others to add: c2hs-0.14.5, haxml-1.13, uulib-0.9.1, uuagc-0.9.1, cpphs-0.9
10:56:08 <SamB> ADEpt: the where clause on runThread is too big
10:56:36 <SamB> and it looks like most of the stuff in it doesn't depend on any of the arguments to peerThread...
10:56:40 <SamB> er, I meant peerThread.
10:56:52 <SamB> runThread is fine.
11:00:54 <tibbe> yeah, my interpreter is done
11:02:23 <SamB> ADEpt: oh, any particular reason why we are using a channel for messages from the peer?
11:03:30 <SamB> oh, I see.
11:04:42 <SamB> hmm. why are we both reporting our status to the master whenever it changes and when the master asks?
11:04:49 <SamB> and why is the latter asynchronous?
11:06:11 <SyntaxNinja> cpphs doesn't seem to be properly cabal'd
11:06:19 <SyntaxNinja> I uploadedc haxml though
11:08:30 <wearpants> @type mapAccumL
11:08:31 <lambdabot> Not in scope: `mapAccumL'
11:08:34 <wearpants> @type List.mapAccumL
11:08:36 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:09:38 <wearpants> > List.mapAccumR (\x y -> (x+y, x+y)) 1 [3,2,1]
11:09:40 <lambdabot> (7,[7,4,2])
11:09:48 <wearpants> awesome.
11:10:12 <SyntaxNinja> dcoutts: cpphs uploaded
11:12:15 <SamB> @pl (\x y -> (x+y, x+y))
11:12:15 <lambdabot> ap (ap . ((,) .) . (+)) (+)
11:12:29 <wearpants> pfft. I was just experimenting to see if it worked like I thought. ;)
11:12:32 <SamB> @pl (\(x, y) -> (x+y, x+y))
11:12:33 <lambdabot> uncurry (ap (ap . ((,) .) . (+)) (+))
11:12:46 <xerox> nahw.
11:12:48 <wearpants> is there any way to give @pl a stub definition for a function so that it can rewrite?
11:12:55 <SyntaxNinja> can ppl please try to install cabal-get: darcs get http://hackage.haskell.org/darcs/cabal-get-bootstrap
11:13:16 <ibid> stub definition?
11:13:22 <wearpants> i.e. I have a function called insnid that operates on my ADT
11:13:27 <xerox> > let dup = (id &&& id) in uncurry (+) >>> dup $ (1,2)
11:13:28 <lambdabot> (3,3)
11:13:28 <wearpants> but there's too much text to plug into pl
11:14:08 <wearpants> xlat' next (Block  is)                 = List.mapAccumR (\next i -> (insnid i, xlat' next i)) next is
11:18:51 <wearpants> is there no way to do that?
11:19:14 <wearpants> to give the type of xlat' and insnid without the definitions, and for pl to still be able to factor the lambda
11:28:06 <araujo> Hello!
11:28:15 <wearpants> hola araujo
11:28:28 * wearpants va a #haskell.es
11:28:34 * araujo thinks he knows wearpants 
11:28:36 <araujo> :-]
11:32:15 <wearpants> yay for laziness
11:32:18 <wearpants> this is pretty neat
11:33:11 <jethr0> spongebob wearpants
11:33:15 <wearpants> haha
11:33:28 * Oejet goes and creates #haskell.dk
11:33:35 * wearpants == soysauce
11:34:04 <wearpants> this is pretty neat
11:34:36 <jethr0> what is?
11:35:14 <jethr0> do you align the semicolons in a do block under the do or under the "content"?
11:35:23 <jethr0> let x =do hello
11:35:33 <jethr0>        ; holla
11:36:12 <araujo> Under the content.
11:36:37 <jethr0> thx, i'll have to experiment with that a little
11:41:38 <Saulzar> Why not just at the end of the lines?
11:44:26 <jethr0> saulzar, i don't know... i think it's supposed to allude to the monad bind pattern
11:44:38 <jethr0> let x = operation1
11:44:45 <jethr0>         >>= operation2
11:45:08 <jethr0> or the concatenation pattern
11:45:16 <jethr0> let x = function1
11:45:23 <jethr0>         . function 2
11:45:24 <jethr0>         . function 3
11:46:27 <Saulzar> But it could easily be 
11:46:28 <Cale> operation 1 >>= \k ->
11:46:29 <Saulzar> operation1 >>=
11:46:32 <Cale>   operation2
11:46:33 <Saulzar>  operation2 
11:46:41 <jethr0> aaahh
11:46:48 <Cale> hehe
11:46:56 <Cale> try to de-splice those :)
11:47:03 <Saulzar> Hehe
11:47:07 * jethr0 was confused for a second
11:47:38 <Cale> you want the lambda to start on the same like as operation 1
11:47:41 <jethr0> i quite like putting the operator in front to denote a line continuation, but i guess it depends on the circumstances
11:47:42 <Cale> line*
11:47:47 <Saulzar> Hmm
11:47:51 <Cale> operation 1 >>= \k ->
11:47:54 <Cale>  operation 2
11:48:00 <Cale> since it corresponds to
11:48:06 <jethr0> i quite like:
11:48:07 <Cale> do k <- operation 1
11:48:10 <Cale>    operation 2
11:48:20 <jethr0>      operation 1
11:48:21 <Saulzar> I think I prefer the operator at the end for other things too
11:48:23 <jethr0>      operation 1
11:48:27 <Saulzar> a * b * c +
11:48:31 <Saulzar> d * e * f
11:48:32 <jethr0> *argh*
11:48:34 <Cale> hehe
11:48:40 <Saulzar> Reminds me of learning pascal - the turbo pascal compiler complained about missing semi-colons at the start of the line
11:48:46 <Cale> IRC sucks for layout :)
11:48:51 <flux__> hmm.. irc-client could have a non-clutter-feature
11:49:04 <Cale> yeah, it would be kind of nice
11:49:04 <Saulzar> So, not knowing better - we all started puting semi-colons at the start of the lines
11:49:28 <flux__> /declutter and it would sort first by nick, then by time, maybe limited by some thresholds ;)
11:49:29 <Cale> but it's hard to tell what the dependencies of the conversation are :)
11:49:40 <jethr0> $pretty operation1 >>= \x -> operation2 x >>= return . operation3
11:49:40 <jethr0_bot> "Parse error" at column 16
11:49:41 <Saulzar> Who goes first? :)
11:49:56 <jethr0> $pretty let x = operation1 >>= \x -> operation2 x >>= return . operation3
11:49:56 <jethr0_bot> "Parse error" at column 66
11:50:20 <jethr0> weird
11:50:35 <Cale> where did you get the parser?
11:50:46 <Cale> oh
11:50:49 <Cale> hehe
11:50:50 <jethr0> it's language.haskell.parser and it works quite nicely
11:50:53 <Cale> there's no 'in'
11:51:03 <jethr0> $pretty let x = operation1 >>= \x -> operation2 x >>= return . operation3 in x 5
11:51:04 <jethr0_bot> #  i = let x = operation1 >>=
11:51:04 <jethr0_bot> #                \ x -> operation2 x >>= return . operation3
11:51:04 <jethr0_bot> #        in x 5
11:51:08 <jethr0> *brr
11:52:09 <jethr0> $pretty fun x | x < 3 = 2 | x < 5 = 1 | x ==0 = 8 | otherwise = 10
11:52:10 <jethr0_bot> #  fun x  | x < 3 = 2
11:52:10 <jethr0_bot> #         | x < 5 = 1
11:52:10 <jethr0_bot> #         | x == 0 = 8
11:52:10 <jethr0_bot> #         | otherwise = 10
11:53:14 <Cale> It should line up the = signs too, possibly
11:53:30 <jethr0> cale, i know, but it was hard enough to get it working this well :(
11:53:42 <jethr0> language.haskell.pretty is a misnomer!
11:53:50 <Cale> jethr0: are you using document combinators?
11:53:54 <Cale> ah
11:54:02 <jethr0> language.haskell.mediocre would be much more fitting
11:54:09 <Cale> hehe
11:54:36 <Cale> you could do it manually, and exert more control over things, but it would be more work to get something baseline
11:54:38 <Saulzar> I think they could do a better job at mediocre formatting too
11:54:41 <jethr0> cale, i guess by writing my own pretty printer using the combinators this might be solvable, but that sounds like quite a lot of work
11:54:56 <jethr0> on the other hand, i'd only need to fix the problems and let language.haskell.pretty do the rest
11:54:58 <jethr0> hmm...
11:56:15 <SamB> those combinators don't seem to be adequate for handling the layout rule nicely...
11:56:58 <jethr0> what you really want is some kind of block-thingey that carries an amount of initial indentation with it until closed
11:57:31 <Cale> I thought that Text.PrettyPrint.HughesPJ had one of those
11:57:31 <jethr0> and matching the "=" inside different blocks is left as an exercise to the reader :(
11:57:50 <jethr0> cale, maybe, but language.haskell.pretty is using that already
11:58:50 <jethr0> it's actually non-trivial to align multiple things in multiple lines (plus figuring out what is at equivalent semantical depth)
11:58:53 <Cale> see nest and hang
11:59:06 <Cale> yeah, that seems harder
11:59:15 <Cale> er, hmm
11:59:39 <jethr0> although working on the AST helps a lot!
12:00:09 <jethr0> the problem is just that figuring out lengths and string representations depend on each other cyclicly
12:00:51 <jethr0> i'm gonna go and eat a little...
12:01:12 <Cale> what you need is a beside combinator which meshes lines together
12:01:26 <jethr0> hmm
12:01:47 <jethr0> you'd have to do some heavy duty weaving.
12:02:03 <jethr0> OR i just can't seem the simple solution, yet
12:02:44 <Cale> I'm not sure that it's possible without using the lower-level representation
12:02:49 <joelr1> evening
12:03:06 <joelr1> is there a shorter way to write this: filterWithKey (\(_, k) _ -> k == "a") x
12:03:07 <Cale> possibly changing the lower-level representation to support such a thing
12:03:07 <jethr0> what do you mean "lower level"
12:03:36 <Cale> jethr0: the "Doc" type
12:03:40 <jethr0> ah
12:03:48 <Cale> joelr1: hmm
12:04:41 <jethr0> joelr1, i can't find one right now. maybe some hackery with arrows :)
12:04:49 <jethr0> like control.arrow.second
12:05:05 <joelr1> haha
12:05:09 <joelr1> ok, thanks!
12:05:17 <Cale> @pl \(_, k) _ -> k == "a")
12:05:18 <lambdabot> (line 1, column 22):
12:05:18 <lambdabot> unexpected ")"
12:05:18 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`
12:05:18 <lambdabot> elem`", "`notElem`" or end of input
12:05:24 <Cale> @pl \(a, k) a -> k == "a"
12:05:25 <lambdabot> const . ("a" ==) . snd
12:05:32 <Cale> that's not terribly good
12:05:33 <Cale> hehe
12:05:40 <Cale> makes sense though
12:05:47 <joelr1> i just need a predicate :)
12:05:49 <jethr0> well, at least it hasn't got thousands of "dots" in it
12:05:53 <Cale> hehe
12:06:01 <joelr1> based on two arguments, key and value that has /= in it
12:06:10 <joelr1> so that i can use it with pred "a"
12:06:15 <Cale> yeah
12:06:27 <joelr1> but there's no snd for arguments :D
12:06:27 <Cale> you could separate out the test and put it in the where clause
12:06:28 <jethr0> would be easier with out the second param
12:06:37 <Cale> flip const
12:06:37 <Cale> hehe
12:06:40 <joelr1> :D
12:06:47 <joelr1> ok, thank you cale
12:07:22 * jethr0 was just about to rewrite @pl's answer *blush*
12:07:50 <jethr0> \_ -> ("a"==) . snd
12:08:04 <jethr0> no, that's wrong
12:08:10 <jethr0> so, gotta eat
12:10:05 <dcoutts> SyntaxNinja, oh, actually cpphs-1.0 is out :-)
12:10:11 <dcoutts> http://www.cs.york.ac.uk/fp/cpphs/cpphs-1.0.tar.gz
12:11:39 <dcoutts> SyntaxNinja, argh! the .cabal in the cpphs-1.0 tarball says version 0.9 !
12:14:58 <dcoutts> I'll email Malcolm
12:22:14 <Mussorgsky> I'm trying to compile Yi (from darcs)
12:22:25 <Mussorgsky> what's this dependency base-any ?
12:22:50 <humasect> haskell 98 library
12:22:59 <humasect> +ghc ...
12:23:50 <Mussorgsky> I have ghc installed
12:24:07 <humasect> i mean haskell 98 library with glasgow exts if applicable
12:24:22 <Mussorgsky> hm... how do I get this in ubuntu?
12:24:29 <wearpants> @type empty
12:24:30 <lambdabot> Not in scope: `empty'
12:24:36 <wearpants> > List.empty []
12:24:36 <lambdabot>  Not in scope: `List.empty'
12:24:42 <wearpants> @type null
12:24:43 <lambdabot> forall a. [a] -> Bool
12:24:45 <wearpants> ah
12:24:48 <wearpants> > null []
12:24:49 <lambdabot> True
12:24:50 <wearpants> > null [1]
12:24:52 <lambdabot> False
12:25:01 <Mussorgsky> alas
12:25:10 <Mussorgsky> it's fps-any that's failing, not base-any
12:26:02 <Lemmih> @where fps
12:26:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:26:17 <Mussorgsky> hm... thanks
12:27:11 <Cale> hmm
12:31:50 <CosmicRay> Stupid Cabal question: how to I use a .hsc file for a module that is not exported?
12:32:19 <CosmicRay> it seems to just not recognize these otherwise
12:32:52 <dcoutts> CosmicRay, add it to other-modules ?
12:34:40 <frederik_> Ix says: Minimal complete instance: range, index and inRange.
12:34:47 <frederik_> but Ord a => Ix a
12:34:51 <CosmicRay> ah.
12:34:56 <CosmicRay> I thought it found those automatically
12:34:58 <CosmicRay> but that makes sense.
12:34:59 <frederik_> can't inRange be defined with Ord?
12:37:18 <Heffalump> @type inRange
12:37:19 <lambdabot> Not in scope: `inRange'
12:51:21 <SyntaxNinja> dcoutts, malcolm: so is this the 1.0 version that just claims to be 0.9? http://hackage.haskell.org/ModHackage/Hackage.hs?action=info&pkg=cpphs&pkgVersion=0%2e9
12:51:58 <SyntaxNinja> CosmicRay: email me if you have cabal-ized junk you want me to upload to hackage, or upload it yourself :)
12:52:07 <SyntaxNinja> CosmicRay: feel like packaging cabal-get and friends?
12:52:10 <SyntaxNinja> (for debian)
12:52:39 <malcolm> SyntaxNinja: errm, dunno, since 0.9 and 1.0 look identical in their .cabal files...
12:53:28 <SyntaxNinja> actually, just point me to the latest tarball :)
12:53:38 <malcolm> SyntaxNinja: probably best to go for 1.1 anyway
12:53:45 <dcoutts> malcolm, ta. 
12:54:37 <wearpants> @type List.mapAccumR
12:54:38 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:54:47 * malcolm is about to stuff cpphs into darcs once he can find the conversion script to get the CVS history
12:54:50 <dcoutts> malcolm, if you use Cabal's sdist feature it should do the right thing with the tarballs & names etc
12:55:37 <dcoutts> malcolm, oh, if you find out what the right tailor commands are would you mind pointing me at them, I've got to do the same thing with Gtk2Hs.
12:55:51 <malcolm> dcoutts: I'm not really a cabal user yet.  that part was contributed by someone else (Ross I think)
12:56:02 <dcoutts> malcolm, ah I see
12:56:15 <dcoutts> malcolm, so a cabal package needs a Setup.lhs file
12:56:36 <wearpants> @type foldr
12:56:37 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:57:05 <dcoutts> malcolm, then you can say: runhaskell Setup.lhs {configure|build|install|sdist}
12:57:07 <malcolm> I'm thinking I might hack hmake to read a .cabal file as an alternative to needing a Setup.hs
12:57:47 <dcoutts> malcolm, however some cabal packages use hooks in the Setup.(l)hs to customise things
12:58:58 <malcolm> to be honest, I'm not sure what a hook is
13:00:32 <dcoutts> malcolm, it's some code that gets run before/during/after some phase of the build.
13:01:11 <malcolm> dcoutts: that is exactly the extent of my knowledge.  no more and no less
13:01:35 <dcoutts> malcolm, the details are in the Distribution.Simple library API
13:02:47 <malcolm> dcoutts: i haven't found the time to look at any of the APIs for over a year
13:03:09 <malcolm> dcoutts: but one day, I'll get there...
13:03:20 <dcoutts> there's been some flux in the api too...
13:05:32 <SyntaxNinja> malcolm: hmake shouldn't ignore the Setup.hs file.  at least for now, they're required.
13:05:54 <SyntaxNinja> malcolm: I'm thinking of relaxing that restriction, though.
13:05:58 <SyntaxNinja> see recent mails to libraries@
13:06:43 <malcolm> SyntaxNinja: no, my idea was to eliminate Setup.hs by using the .cabal file like a traditional makefile, with hmake as the engine which reads it and issues build commands
13:07:39 <SyntaxNinja> malcolm: yeah, I understand
13:07:42 <malcolm> SyntaxNinja: but it is only a half-formed idea, based on a very cursory knowledge of the .cabal file format
13:07:57 <malcolm> SyntaxNinja: there are probably lots of reasons it wouldn't work
13:08:02 <SyntaxNinja> well, all you have to do is call "defaultMain" in that directory, so it'd be trivial to modify hmake to do it, IMO
13:08:04 <dcoutts> malcolm, the url doesn't work for me: http://www.cs.york.ac.uk/fp/cpphs/cpphs-1.1.tar.gz 
13:08:06 <SyntaxNinja> but there are reasons not to do it ;)
13:14:32 <malcolm> dcoutts: sigh, looks like I forgot to do quite a lot of things when I made the 1.1 release!
13:17:18 <SyntaxNinja> cabal needs to start coming w/ cattle prods.
13:18:42 <dcoutts> SyntaxNinja!?
13:19:18 <SyntaxNinja> dcoutts: you know, so people stop doing bad things.
13:19:24 <Saulzar> alkathene cabal
13:19:42 <dcoutts> SyntaxNinja, ah, yes. I definately agree.
13:19:47 <dcoutts> SyntaxNinja, and Hackage.
13:20:09 <dcoutts> hackage: "You can't do that! Go back and sort it out!"
13:20:38 <SyntaxNinja> cabal-install needs to have a test command which will sdist and then try to build the tarball.
13:20:48 <dcoutts> hackage: "Did you really mean -----? I don't think it means what you think it means."
13:20:49 * SyntaxNinja pokes Lemmih
13:20:53 <SyntaxNinja> heh
13:21:03 * SyntaxNinja pokes CosmicRay
13:21:07 <malcolm> dcoutts: tarball of cpphs now properly available
13:21:15 <dcoutts> malcolm, yay!
13:22:15 * CosmicRay appears out of thin air
13:23:53 <Heffalump> if you were in thin air before, how'd he poke you?
13:24:14 <CosmicRay> Heffalump: there's a nobel prize in this for you if you figure it out
13:24:24 * dcoutts pokes the air in front of him
13:24:34 <CosmicRay> oo!  air currents!
13:25:54 <SyntaxNinja> CosmicRay: what would you think of packaging cabal-get & friends for debian
13:26:05 <CosmicRay> SyntaxNinja: that would be nice
13:26:12 <SyntaxNinja> CosmicRay: we have a bit of a bootstrapping problem w/ getting ppl to use cabal-get
13:26:25 <SyntaxNinja> part of the problem is that it requires like 10 packages
13:26:28 <CosmicRay> is libghc6-cabal-dev up-to-date these days?
13:26:31 <Heffalump> can cabal-get automatically make Debian packages?
13:26:38 <CosmicRay> well ideally those packages should be in sid anyway
13:26:39 <SyntaxNinja> Heffalump: almost ;)
13:26:45 <CosmicRay> so I'd say they should be compiled and installed in sid
13:26:51 <SyntaxNinja> CosmicRay: yeah. there's some chance that Lemmih altered them, though.
13:27:02 <SyntaxNinja> CosmicRay: yeah, libghc6-cabal-dev has 1.1.3.
13:27:06 <CosmicRay> you mean, he has a local branch?
13:27:07 <CosmicRay> SyntaxNinja: cool
13:27:12 <dcoutts> Heffalump, well you can write a prog usign the same underlying libs as cabal-get to do that. We've done that for Gentoo.
13:27:23 <SyntaxNinja> CosmicRay: possibly
13:27:45 <CosmicRay> SyntaxNinja: well that is a problem for the larger community too then.  he should work that out and get is patches accepted into the canonical trees
13:27:54 <SyntaxNinja> CosmicRay: I agree, but he's being a brat ;)
13:28:13 <SyntaxNinja> CosmicRay: someone needs to sit down and get it all straightened out, but I haven't gotten a chance to do it, and I can't talk anyone else into it.
13:28:31 <CosmicRay> well then, we need to convince him to behave otherwise ;-)
13:28:47 <SyntaxNinja> but I did modify cabal-get-bootstrap to work w/ ghc 6.4.1 and / or cabal-install, though I haven't released the cabal-install-requiring one
13:29:17 <PupenoL> Is there an extension that can be specified on a .cabal file that would be the same as specifing -fffi to ghc ?
13:29:30 <dcoutts> SyntaxNinja, ideally we'd have it so that cabal-get came with each compiler so it'd be easy for users to get other libs after getting their Haskell implementation.
13:29:34 <wearpants> @type scanl
13:29:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:29:35 <SyntaxNinja> PupenoL: FFI
13:29:42 <PupenoL> SyntaxNinja: thanks.
13:29:43 <SyntaxNinja> I think, maybe ForeignFunctionInterface
13:29:53 * PupenoL tried ffi.
13:30:07 <dcoutts> PupenoL, but that goes inside the .cabal file in a particular field.
13:30:14 <SyntaxNinja> dcoutts: that would be nice indeed, but well, we can't keep saddling compiler authors with more requirements.
13:30:20 <wearpants> @type List.mapAccumL
13:30:21 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:30:29 <dcoutts> SyntaxNinja, eg perl comes with the cpan tool right?
13:30:31 <SyntaxNinja> dcoutts: cabalw as written to be very independent, but cabal-get is not, unfortunitely.
13:30:33 <PupenoL> dcoutts: what do you mean ?
13:30:48 <Heffalump> dcoutts: yes, it does
13:30:48 <SyntaxNinja> dcoutts: see recent emails to libraries@
13:31:09 <CosmicRay> SyntaxNinja: I don't see how it's saddling them; if you maintain the code in the darcs repo, what is it to them?
13:31:11 <SyntaxNinja> dcoutts: JohnMeacham doesn't want compilers to require cabal, for one.
13:33:23 <dcoutts> PupenoL, you add "extensions: ForeignFunctionInterface" to the .cabal file.
13:33:38 <PupenoL> dcoutts: yes, that is what I want, thanks.
13:33:43 <dcoutts> http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#buildinfo
13:34:30 <wearpants> @type fail
13:34:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
13:35:01 <PupenoL> dcoutts: I read that, but nothing there tells me what 'extension' is -fffi, I now see the Extension link, but I get a 404.
13:35:24 <dcoutts> PupenoL, complain to SyntaxNinja about the broken link
13:35:40 <dcoutts> the correct link is:
13:35:41 <dcoutts> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html#t:Extension
13:36:59 <SyntaxNinja> yow
13:37:06 <dcoutts> SyntaxNinja, I don't understand why JohnMeacham thinks this are a problem: 'run
13:37:06 <dcoutts> runhaskell Setup.lhs, unless your runhaskell points to jhc, in which
13:37:06 <dcoutts> case do runghc Setup.lhs, oh, create a link from runhaskell to your
13:37:06 <dcoutts> proper compiler'
13:37:28 <dcoutts> because whichever complier/interpreter runhaskell points to it should work
13:37:42 <SyntaxNinja> dcoutts: I think his point is that runhaskell might point to jhc which doesn't have cabal.
13:37:46 <dcoutts> Setup.lhs is just Haskell code using the Cabal libs
13:37:48 <dcoutts> oh
13:38:13 <dcoutts> so why shouldn't each compiler provide standard libs?
13:38:36 <SyntaxNinja> dcoutts: the issue is whether cabal should be part of the standard libs.
13:38:43 <dcoutts> right
13:38:54 <SyntaxNinja> dcoutts: and if you cabal fans out there think it should be, you should raise your voices :)
13:39:11 <dcoutts> it is difficult when the api keeps changing
13:39:15 <SyntaxNinja> bah
13:39:21 <dcoutts> and I'm one of the ones who thinks it should change!
13:39:24 <SyntaxNinja> did you read my email?
13:39:27 * Igloo would prefer not until it has settled down and works
13:39:41 <dcoutts> Igloo, it won't work till it's changed :-)
13:39:47 <SyntaxNinja> heh
13:39:53 <Igloo> I mean I'd prefer it doesn't come with the compilers
13:39:55 <dcoutts> (that's only partly true of course)
13:39:58 <SyntaxNinja> it is indeed a bit of a catch-22
13:40:00 <Igloo> I'm all for change
13:40:15 <wearpants> > last [1,2,3]
13:40:16 <lambdabot> 3
13:40:25 <wearpants> what's the complement of last?
13:40:27 <wearpants> > first [1,2,3]
13:40:28 <lambdabot> Couldn't match `a b' against `[]'
13:40:31 <wearpants> :|
13:40:34 <SyntaxNinja> wearpants: heads
13:40:34 <SyntaxNinja> head
13:40:40 <wearpants> > head [1,2,3]
13:40:41 <lambdabot> 1
13:40:46 <wearpants> no, I want to get [1,2]
13:40:48 <Cale> > init [1,2,3]
13:40:50 <lambdabot> [1,2]
13:40:53 <JohnMeacham> It is more that we are setting ourself up for a lot of headache for no reason.
13:40:57 <wearpants> ah, init, thanks.
13:41:10 <SyntaxNinja> JohnMeacham: howso?
13:41:18 <Cale> wearpants: btw, init and last are quite inefficient
13:41:23 <wearpants> I'm well aware
13:41:40 <wearpants> but efficiency isn't that big of a deal. These are called just once, so they contribute O(n) to something that is already pretty inefficient
13:41:43 <JohnMeacham> every new haskell user that tries 'runhaskell Setup.lhs' and it doesn't work right away is one we lose. it is just a very brittle setup and good design says we should make things robust.
13:41:45 <SamB> Cale: init moreso, right?
13:41:47 <Cale> wearpants: ah
13:41:51 <Cale> SamB: yeah
13:41:59 <dcoutts> JohnMeacham, you apreciate the bootstrap problem though? You've got your brand new shiny jhc and now you want to install some libs from this big online collection.
13:42:14 <Cale> SamB: well... :)
13:42:16 <wearpants> il2str :: [Int] -> String
13:42:17 <Cale> a little
13:42:19 <SyntaxNinja> JohnMeacham: I disagree that it's that extreme, that we lose users every time or anything like that.  
13:42:19 <PupenoL> I so far like cabal, but, does it have to come with the compiler ? I prefeer small idependent packages.
13:42:20 <JohnMeacham> 'cabal -c jhc build' 'cabal install'
13:42:23 <wearpants> il2str ilst = foldr (\n s -> (fromIntegral n) ++ (' ':s)) (fromIntegral (last ilst)) (init ilst)
13:42:27 <SamB> hmm, I think my favorite init is reverse . tail . reverse
13:42:29 <wearpants> similar to perl's join function
13:42:42 <SyntaxNinja> PupenoL: thta's what we're talking about
13:42:42 <CosmicRay> yes, I detest instructions that say to use "runhaskell"
13:42:45 <CosmicRay> that is a recipe for trouble.
13:43:03 <wearpants> er, s/fromIntegral/show/
13:43:04 * dcoutts doesn't like runhaskell either actually
13:43:09 <Oejet> Is there a channel for Cabal?
13:43:10 <SamB> JohnMeacham: Python's distutils is great
13:43:11 <SyntaxNinja> JohnMeacham: my proposed solution is to have cabal come w/ the compilers and provide cabal-install separately
13:43:15 <SyntaxNinja> Oejet: just this one
13:43:36 <SyntaxNinja> JohnMeacham: but honestly, it's just sad that we don't have a workable #! (:
13:43:44 <JohnMeacham> I mean, there is no reason the library couldn't coexist. but a much more robust first thing should be available. that and programatic processing of cabal scripts would be a lot easier if they were declarative.
13:43:48 <SamB> SyntaxNinja: fixorate!
13:43:55 <Igloo> #! should work fine with lhs, shouldn't it?
13:44:05 <SyntaxNinja> Igloo: if runhaskell were reliable
13:44:05 <Cale> ilst2str = concat . intersperse " " . map show
13:44:23 <Cale> wearpants: ^^
13:44:29 <wearpants> Cale - either way. It's already written and works. ;)
13:44:33 <Cale> :)
13:44:34 <dcoutts> SyntaxNinja, actually one place where runhaskell goes wrong in the current situation is that some people import modules from packages in their Setup.lhs that are in their build-depends. You can see how this is going to break if runhaskell is say hugs.
13:44:34 <SamB> write extension report, publish on Haskell.org next to FFI and Heirarchical Namespace, prod implementors repeatedly
13:44:36 <wearpants> I don't care about efficiency
13:44:43 <wearpants> otherwise I would...use C ;)
13:44:44 <JohnMeacham> why? if it is the exact same code for each. users who upgrade their cabal are going to have to know to do it for every compiler? or know which one their runhaskell points to?
13:45:00 <SyntaxNinja> JohnMeacham: it's declarative as much as it can be, and when it can't, then the Setup scripts are necessary.
13:45:02 <Cale> wearpants: so you must care about readability :)
13:45:08 <wearpants> nope
13:45:11 <wearpants> ease of implementation!
13:45:13 <dcoutts> SyntaxNinja, it's not clear that you can't use any old package in your Setup.lhs.
13:45:18 <SamB> hmm
13:45:18 <SyntaxNinja> SamB: in all my spare time ;)
13:45:23 <JohnMeacham> 'runhaskell' should be a compiler independent script which trys the elements of $RUNHASKELL in order, else "runghc:runhugs:runjhc" or somesuch.
13:45:33 <SamB> SyntaxNinja: it'd be a one-page affair
13:45:44 <JohnMeacham> but now I have a christmas party to get to. I will catch up later.
13:45:50 <Cale> "readability" and "ease of implementation" are the same thing in my head :)
13:45:51 <SamB> Maybe one paragraph
13:45:55 <SyntaxNinja> JohnMeacham: have fun!
13:46:04 <wearpants> ah, well
13:46:13 <SyntaxNinja> SamB: I've been writing that paragraph repeatedly for the last year or more ;)
13:46:14 <wearpants> perl has ease of implementation, but it's not necessarily readable.
13:46:21 <Cale> sort of :)
13:46:22 <wearpants> so there is a difference ;)
13:46:37 <Cale> I sort of think that claim holds for small bits of code
13:46:47 <SyntaxNinja> dcoutts: yeah, people shouldn't do that :)
13:46:51 <SamB> SyntaxNinja: so put it in LaTeX, slap on a title, and stick it up next to the others ;-)
13:46:52 <SyntaxNinja> dcoutts: cattle prods
13:47:12 <wearpants> Cale - like the obfuscated perl contests that produce ~200 character MD5 implementations? ;)
13:47:23 <SyntaxNinja> SamB: OK fine.
13:47:38 <dcoutts> SyntaxNinja, but when we use runghc to run the Setup.lhs there's not way of enforcing it. Because runghc is like ghc --make. It pulls in any exposed package.
13:47:46 <dcoutts> SyntaxNinja, perhaps we could do with an even simpler bootstrap script that reads the .cabal file and then itself selects the right compiler to use to build the Setup.lhs file (and the right version of the Cabal package).
13:48:33 <wearpants> Cale - BTW, I don't care so much about the O(n) stuff since I have an O(n^3) loop right before it, and n is much, much larger. Up to 10,000, IIRC. ;)
13:48:38 <SyntaxNinja> dcoutts: like cabal-install? well, that just uses runhugs or runghc depending on the cli
13:48:45 <dcoutts> SyntaxNinja, that'd be one way of letting the Cabal api change. So long as the bootstrap prog can read future versions of the .cabal file without barfing.
13:48:48 <Cale> wearpants: :)
13:48:54 <wearpants> ah, maybe it's only n^2. Either way, very nasty.
13:49:03 <dcoutts> SyntaxNinja, and would allow the Setup.lhs to be optional.
13:49:36 <dcoutts> SyntaxNinja, so what does cabal-install do?
13:49:46 <Cale> ilst2str = unwords . map show
13:49:48 <Cale> actually
13:49:49 <Cale> hehe
13:49:57 <wearpants> haha, nice
13:49:58 <SyntaxNinja> dcoutts: cabal-install --user --prefix=/tmp --with-runhugs=/tmp/myrunhugs foo-1.1.tgz 
13:50:14 <SamB> I suppose if most of the Setup.{hs,lhs} files say the same thing they *are* arguably useless...
13:50:15 <Cale> I always forget about unwords for that special case
13:50:16 <wearpants> > foldr (flip (:)) [] ["Hello, ", "world!"]
13:50:17 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
13:50:17 <lambdabot>   Expected type: c -> [c] -> c
13:50:17 <lambdabot>   Inferred type: c -> [c] -> [c]
13:50:29 <wearpants> er, oops
13:50:31 <SyntaxNinja> SamB: but not all of them say the same thing
13:50:44 <Cale> > foldr (flip (++)) [] ["Hello, ", "world!"]
13:50:45 <wearpants> > foldr (flip (:)) [] "Hello, world!"
13:50:45 <lambdabot> "world!Hello, "
13:50:45 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
13:50:45 <lambdabot>   Expected type: c -> [c] -> c
13:50:45 <lambdabot>   Inferred type: c -> [c] -> [c]
13:51:03 * wearpants tries to remember what he was doing
13:51:04 <SamB> well. I mean, theres no point in having those that do.
13:51:07 <SyntaxNinja> if we relax the Setup requirement, we'll be adding an additional requirement that people install something like cabal-install.
13:51:07 <Cale> > foldl (flip (:)) [] "Hello, World!"
13:51:08 <lambdabot> "!dlroW ,olleH"
13:51:15 <dcoutts> SyntaxNinja, if we're going to let the Setup.lhs be optional then we'll have to have a different primary interface than "runhaskell Setup.lhs blah"
13:51:16 * PupenoL actually likes general building tools, like Scons. Is there a particular reason not to use something like Scons ?
13:51:18 <wearpants> ah, I guess I don't need the flip
13:51:22 <SyntaxNinja> dcoutts: right.
13:51:27 <dcoutts> SyntaxNinja, oh yeah, you said that. :-
13:51:35 <SyntaxNinja> :)
13:51:45 <SamB> SyntaxNinja: well, you can relax it starting at some later Cabal version
13:51:50 <SyntaxNinja> so it's tough. maybe I should write up something that clearly outlines the design choices
13:51:52 <SyntaxNinja> SamB: that's the idea.
13:52:02 <dcoutts> SyntaxNinja, and such a thing would be a good place do deal with the fact that the .cabal file format get's extended over time, and the cabal api changes.
13:52:07 <SamB> and put the script in the Cabal package
13:52:08 <dcoutts> the library API I mean
13:52:18 <SyntaxNinja> SamB: it's already there :)
13:52:28 <SamB> oh
13:52:32 <wearpants> > foldr (\x y -> (show x) ++ y) "" ["Hello, ", "world!"]
13:52:34 <lambdabot> "\"Hello, \"\"world!\""
13:52:34 <ADEpt> SamB: i'm back
13:52:34 <SamB> so whats to install?
13:52:43 <SyntaxNinja> SamB: but actually, it runs the Setup script
13:52:43 <wearpants> > foldr (\x y -> (show x) ++ y) "" [1, 2, 3]
13:52:45 <lambdabot> "123"
13:52:47 <wearpants> ah, there!
13:52:54 <SamB> ADEpt: hello hello
13:53:07 <SyntaxNinja> SamB: well, ghc and hugs would have to come w/ an extra executable, cabal-install or whatever
13:53:10 <ADEpt> SamB: you asked why there is a channel for messages from the peer. You mean channel between peerthread and peer socket listener?
13:53:11 <Cale> > (concat . map show) [1,2,3]
13:53:12 <lambdabot> "123"
13:53:13 <SamB> ADEpt: I've a couple of smallish patches
13:53:19 <Cale> concatMap show [1,2,3]
13:53:21 <Cale> > concatMap show [1,2,3]
13:53:22 <lambdabot> "123"
13:53:22 <SamB> one of which should be rather useful
13:53:24 <dcoutts> SyntaxNinja, for example, in the gentoo cabal infrastructure were in a good position because we've got lots of control over how we use the Setup.lhs file.
13:53:27 <Cale> > [1,2,3] >>= show
13:53:28 <lambdabot> "123"
13:53:44 <SamB> SyntaxNinja: I suppose the biggest problem is that you'd need to somehow arbitrate who gets to install it
13:53:49 <SyntaxNinja> dcoutts: what's that an example of?
13:53:57 <SyntaxNinja> SamB: don't follow
13:54:05 <SamB> ADEpt: I figured it out
13:54:18 <dcoutts> SyntaxNinja, we can make sure we're using it with a working ghc, with a version of the Cabal library that is API compatible with the one that the package expects.
13:54:34 <ADEpt> SamB: pulling ...
13:54:59 <SamB> SyntaxNinja: well, its not good if both GHC and hugs want to install a file to /usr/bin/cabal-thingy
13:55:16 <ADEpt> SamB: about the 'where' clause - completely agree. It could be made 30% smaller, and some of the functions could be made into their own self
13:55:23 <SyntaxNinja> SamB: yeah, the compilers should checkt o make sure it doesn't already exist.
13:55:28 <SyntaxNinja> or something
13:55:57 <SyntaxNinja> dcoutts: yeah, and any distributino is going to have the same ability.  the problem is the general population without powerful package systems already ;)
13:56:04 <dcoutts> SyntaxNinja, our eclass selects the right ghc version, the right -package Cabal-x.y.z and works with Setup.hs as well as .lhs (which several packages use)
13:56:12 <PupenoL> SyntaxNinja: that is not nice for packagers. When you build a package you normally install to a location that is a chroot and then tar that up to install it elsewhere.
13:56:47 <dcoutts> SyntaxNinja, so my point is that the point of entry should be a script/prog with those abilities. That allows for versioning and greater reliability.
13:57:28 <PupenoL> SyntaxNinja: why not providing a program packaged separately of any compiler and that can be compiled with any of them and then use any other or the same to compile other packages by looking for a file where it is run (like make or scons) ?
13:57:34 <SyntaxNinja> PupenoL: packagers should have some other system, like debian does, for deciding whether to install it.
13:58:07 <dcoutts> SyntaxNinja, so we grant the general population with the advantages of the layer of indirection that the packaging system gives us.
13:58:09 <PupenoL> SyntaxNinja: what system has Debian to help in such a case ?
13:58:18 <SyntaxNinja> PupenoL: that's attractive, except that it's an extra step that everyone has to take.  I guess I'm becoming convinced, to an extent, that it's worth it, but I'm not positive.
13:58:19 <SamB> SyntaxNinja: or could use a cross between diversions and alternatives
13:58:25 <SyntaxNinja> PupenoL: the alternatives system
13:58:49 <PupenoL> SyntaxNinja: I see (regarding alternatives).
13:58:51 <SamB> (but then you need to install each with a different name)
13:59:04 <SyntaxNinja> SamB: so it's something the packagers have to know about and handle. 
13:59:07 <PupenoL> SyntaxNinja: the extra step is installing a separate program from the compiler ?
13:59:12 <SyntaxNinja> but yeah, none of these are particularly nice solutions
13:59:14 <SyntaxNinja> PupenoL: yeah
13:59:38 <SyntaxNinja> although part of hte problem is that the compilers use cabal as part of the build system for their own libraries and stuff.
13:59:57 <PupenoL> SyntaxNinja: but people is doing that daily with gcc, g++, make, autotools and the fact that they are separate is not a problem.
14:00:03 <SyntaxNinja> so this whole confusing mess is the reason that we require Setup files for now, and we may relax that later.
14:01:02 <SyntaxNinja> PupenoL: yeah, maybe it's not so bad. 
14:01:37 <PupenoL> SyntaxNinja: gcc surely uses make (or some other tool) and make is written in C, it is not much of a problem after it is bootstraped; isn't it ?
14:02:05 <dcoutts> heh, try bootstrapping a system without gcc + make
14:02:20 <SyntaxNinja> PupenoL: right, but C and make are expected on just about any old box these days.  getting a user to install Haskell is hard enough, now we have to get them to install cabal as well
14:02:38 <dcoutts> gentoo bootstraps by unpacking a huge great tarball which contains gcc & make (& lots of other stuff)
14:03:25 <PupenoL> SyntaxNinja: any sane OS has a packaging system (Linux *, *BSD, even MacOS X, with fink) that solves that problems.
14:03:48 <PupenoL> SyntaxNinja: that leaves windows, for with HaskellInABox might be a solution.
14:03:48 <dcoutts> PupenoL, yeah for systems with package managers its ok
14:04:00 <dcoutts> but not all our users are on such systems
14:04:05 <PupenoL> SyntaxNinja: have you seen LispInABox ?
14:04:34 <dcoutts> and some popular distros like SuSE, Mandrake etc do not have ghc packages
14:04:44 <PupenoL> dcoutts: I know, that is what I mention the InABox solution.
14:05:25 <PupenoL> dcoutts: that should be solved by making packages of them, not by making a complex build system, or it can also be solved with a InABox solution for Linux.
14:05:42 <dcoutts> there's also the windows users to think about :-(
14:05:48 <SyntaxNinja> poor windows users
14:05:58 <SyntaxNinja> dcoutts: siggy is working on a windows-installer-from-cabal thing
14:06:00 <PupenoL> dcoutts: I already covered that with the in-a-box solution.
14:06:12 <SyntaxNinja> honestly, I don't see the current situation as all that broken.
14:06:14 <dcoutts> what's in-a-box ?
14:07:18 <PupenoL> lisp-in-a-box is a file acompaning the book "Practical Common List" that you install/uncompress on a window box and you get a lot of goodies, from Common Lisp interpreters/compilers to lot's of libraries to even a copy of Emacs (what else you would be editing Lisp on ? notepad ?)
14:07:32 <dcoutts> SyntaxNinja, no, it's not too bad. Speaking just for Gentoo, the cabal infrastructure is working fine. Our packages are much less cmplex than they used to be.
14:07:48 <SyntaxNinja> dcoutts: yay
14:08:01 <dcoutts> PupenoL, so it's the bundle everything together model.
14:08:22 <rg> are there any error tolerant html parsers for haskell?
14:08:28 <PupenoL> dcoutts: it is the bundle everything together model *as an exception, not as the rule*.
14:08:33 <dcoutts> SyntaxNinja, and we're well placed to cope with changes in the Cabal API, should that happen.
14:09:11 <malcolm> rg: HaXml has one
14:09:13 <dcoutts> PupenoL, so according to that we should bundle the cabal-get tool with the compiler. So people can install other libs easily.
14:09:50 <PupenoL> Slate is following that rute as well making SlateInABox for those poor Window users, the rest of us just use packages or even the tarball of slate, because the other tools are already packaged and easily instalable (gcc, make, etc).
14:10:08 <rg> malcolm: i couldn't find anything about it being error tolerant on its web-page. i'll look again. thx.
14:10:41 <dcoutts> SyntaxNinja, could cabal-get be simplified to the point where it'd be realistic to bundle it with ghc?
14:10:49 <PupenoL> dcoutts: according to that compiler and libraries should be separate packages (like make is a separate package of gcc) that end up being separate packages on most OSs and as an exception a bundle should be provided, for windows.
14:11:05 <dcoutts> PupenoL, that's ok by me
14:11:27 <SyntaxNinja> dcoutts: not likely, IMO
14:11:56 <PupenoL> if you want a counter-example, take a look at what happened when libffi was merged into gcc.
14:12:15 <dcoutts> SyntaxNinja, eg does cabal-get really need to use xmlrpc ?
14:12:17 <SyntaxNinja> PupenoL: what heppened?
14:12:31 <SyntaxNinja> dcoutts: eh
14:12:36 <SyntaxNinja> dcoutts: idono
14:12:44 <SyntaxNinja> obviously we could do without it,but it would be more work.
14:12:54 <SamB> XML-RPC
14:12:59 <PupenoL> two mainstream versions of libffi are used, the old one before the merge, still around because LOTs of programs use it before it was merged or because people doesn't want to upgrade gcc to use libffi and just picks the old one.
14:12:59 <SamB> ?
14:12:59 <SamB> Why?
14:13:00 <dcoutts> SyntaxNinja, though that still leaves gnupg as a difficult dep
14:13:04 <SyntaxNinja> yeah
14:13:33 <SamB> dcoutts: gnupg is a runtime dep
14:13:40 <SyntaxNinja> dcoutts: I'm hoping to solve part of hte problem using cabal-install.  you can say "cabal-instal foo.tgz bar.tgz bang.tgz" and it just does the right thing
14:13:41 <PupenoL> the new one before after the merge which is much nicer and better to use, which is use by some programs (that require a new version of gcc just because of libffi).
14:14:05 <SyntaxNinja> SamB: so we don't have to invent our own protocol?
14:14:18 <PupenoL> Now people are re-distributing libffi, the new version outside gcc and there's a big mess with tens of diferent versions all incompatible.
14:14:30 <SamB> SyntaxNinja: there is that
14:14:51 <SyntaxNinja> PupenoL: I have never run into this situation
14:15:11 <SyntaxNinja> PupenoL: so cabal-get-bootstrap is kinda like cabal-get-in-a-box
14:15:40 <SyntaxNinja> I just have to try to remember that this is all a problem of too much success for cabal... 
14:16:03 <PupenoL> I don't know what is cabal-get-bootstrap (sorry for my newbiness in the matter).
14:16:30 <PupenoL> Besides, the release cycle of cabal may be shorter/faster than that of ghc/hugs.
14:16:39 <SyntaxNinja> PupenoL it's faster
14:16:52 <SyntaxNinja> PupenoL: but really this hasn't been such a big problem.
14:16:55 <SamB> well, libffi is hardly the same thing as cabal...
14:17:50 <Speck> I wonder if there is anything to be learned from rubygems
14:17:55 <PupenoL> SamB: if you merged make into gcc, you'll get the same I believe.
14:18:04 <SamB> won't be a problem until the invention of dynamic packages
14:18:28 <SamB> PupenoL: that would be stupid
14:18:41 <PupenoL> SamB: I agree :D deeply.
14:18:42 <SamB> because then you'd have multiple makes which were probably just about the same...
14:19:48 <PupenoL> anyway, I have to go home now, see you in half an hour.
14:20:52 <rg> @djinn (a->b->a)->a->[b]->a
14:20:53 <lambdabot> f _ x2 _ = x2
14:22:01 <SyntaxNinja> l8r PupenoL
14:24:24 <SamB> ADEpt: hmm, at some point we are going to have to switch to doing most things at block granularity...
14:24:36 <Cale> rg: It currently doesn't handle recursive types.
14:25:12 <SamB> ADEpt: oh, how come we don't have a command for indicating interest?
14:26:06 <ADEpt> SamB: i am being slightly dense now. What do you mean by "block granularity"?
14:26:57 <ADEpt> SamB: re command for interest: you mean, from master thread? I thought that peerthread could manage that itself
14:27:22 <SamB> ADEpt: no.
14:27:26 <SamB> er, wait.
14:27:26 <SamB> you are right.
14:27:36 * SamB is silly
14:27:42 * SamB gets interest and choking mixed up sometimes
14:28:04 * SamB wishes he was not so lagged, so he could stop feeling so silly a little sooner
14:29:45 <ADEpt> SamB: i think that I got this "choke"/"interest" stuff straightened out. Want a short tour? :)
14:30:38 <SamB> ADEpt: its probably fine ;-)
14:31:08 <ADEpt> SamB: fine as is or it is fine to have a tour? 
14:31:58 <SamB> ADEpt: fine as it is.
14:32:07 <SamB> I'm not sure I want a tour when I'm as lagged as I am
14:33:39 <SamB> hmm, we need to add some way of communicating with the store at some point...
14:35:00 <SamB> ah, FSMessages are probably good
14:35:30 <SamB> except for they are not fine-grained enough...
14:36:19 <ADEpt> SamB: so, what do you mean by "block granularity"?
14:37:00 <SamB> ADEpt: well, I mean, each block is downloaded in little pieces, correct?
14:37:25 <ADEpt> SamB: yes
14:37:49 <ADEpt> SamB: in our current terminology, it's rather other way around. Large pieces, small blocks
14:38:26 <SamB> er.
14:38:26 <SamB> yes.
14:38:38 <SamB> I said that backwards.
14:38:45 <SamB> Stupid BT for using the name Piece in the protocol...
14:39:19 <ADEpt> SamB: yep. wiki.theory.org is better in this respect. So ... ?
14:39:19 <SamB> anyways.
14:39:51 <SamB> *most* clients don't insist on downloading all the little blocks from the same peer
14:40:51 <SamB> and most of them also probably shuttle them back and forth between the thread and the store in little pieces...
14:41:04 <SamB> erg.
14:41:20 <SamB> it is hard to talk without using the word "pieces" by mistake
14:43:24 <ADEpt> SamB: ah, i see. You mean that the we should throw out the notion of "large pieces" (except for sha1-checking) and use "small block" everywhere?
14:43:50 <ADEpt> SamB: that will require us to store (or lose) additional metadata alongside the torrent
14:44:22 <SamB> ADEpt: thats true
14:44:44 <SamB> we would need additional metadata, if we want to keep track of that between sessions
14:45:01 <SamB> we don't need it right off the bat, though
14:46:06 <jethr0> from slashdot: Paramount had the police seize his four computers, but nothing was found. The tech-novice maintains his innocence. 
14:46:10 <jethr0> somehow "four computers" and "tech-novice" doesn't add up!
14:46:16 <SamB> ADEpt: the question is, how shall we refer to blocks?
14:46:18 <ADEpt> SamB: at the first glance, we need to modify IST to operate on "blocks" (16K), not "pieces", and that's it
14:46:52 <ADEpt> SamB: hm... by (piece, offset) ?
14:46:57 <SamB> ADEpt: is that the thread that hands out assignments?
14:47:09 <ADEpt> SamB: yes it is
14:47:42 <SamB> ADEpt: so we are going to assume a certain length always then?
14:47:54 <SamB> Suppose thats probably best
14:47:59 <SamB> (for now, as always)
14:48:50 <ADEpt> SamB: IST could be parametrized by block length upon creation, then we can make it configurable
14:49:19 <ADEpt> SamB: folks at #bittorrent say that 16K is used by almost every other client nowadays
14:50:19 <SamB> well, we don't currently have a way to pass around configuration info, so...
14:52:20 <ADEpt> SamB: i suppose that peerthread could continue to track "what other peer has" in terms of large pieces, but IST will hand him down tasks in iterms of (piece, offset, length). Which will remove enqueueBlock from PeerThread. 
14:55:06 <SamB> ADEpt: well, I'm changing FS.Piece and FS.FSThread to work with this arrangement
14:55:54 <ADEpt> SamB: cool. I could tackle IST, if you dont mind.
14:56:06 <SamB> as soon as I get this to pass the tests ;-)
14:58:04 <SamB> including the all-important "will haddock run on it" test
15:01:29 <ADEpt> SamB: why haddock does not like '/', by the way?
15:01:48 <SamB> ADEpt: I think it indicates italics or something
15:01:55 <SamB> and needs to come in pairs
15:04:17 <ADEpt> ah
15:05:05 <SamB> ADEpt: okay
15:05:17 <SamB> you can pull now
15:06:47 * Pupeno is back.
15:07:32 <SamB> what happened to shapr?
15:07:49 <SyntaxNinja> Pupeno: so are you going to take over cabal-get maintenance? ;) 
15:08:02 <SyntaxNinja> SamB: he probably got distracted
15:08:22 <Pupeno> SyntaxNinja: mh ?
15:08:25 <SamB> SyntaxNinja: that doesn't explain him not being in the channel at all
15:09:08 * Cale wonders why there's no Text.PrettyPrint.Wadler
15:09:18 <Pupeno> SyntaxNinja: what is cabal-get ?
15:09:31 * ADEpt pulls and then goes to sleep. bb!
15:09:53 <SamB> ADEpt: if you'll look in FS.FSThread, you'll see I'm using your idea of using a -> IO () instead of TChan a or MVar a or Chan a...
15:09:59 <Pupeno> SyntaxNinja: I consider tools like cabal-get to be useless and sometimes harmefull.
15:10:24 <SamB> in places that could possibly benefit from asynchronicity
15:10:42 <ADEpt> SamB: to give someone a proper credit, this idea is taken from cafe. Probably Bulat said that.
15:11:02 <SamB> the secret to creativity is hiding your sources well
15:11:18 <jethr0> cale, are you still at the pretty printing :)
15:11:45 <Cale> looking at it :)
15:11:55 <jethr0> any new insights?
15:11:55 <SamB> Cale: because wadler hasn't got around to updating it to use the heirarchical libraries?
15:12:21 <Cale> oh, did it exist before?
15:12:45 <Cale> Shouldn't that be as easy as changing the module declaration?
15:13:12 <SamB> its a lame attempt at humour ;-)
15:13:25 <SamB> presumably he wrote them at SOME point...
15:17:22 * ADEpt pulled and really goes to sleep now. bb
15:17:28 <jethr0> bb
15:20:37 <Saulzar> Hmm, using Maybe with IO doesn't seem so flash. Much better to use exceptions I guess.
15:21:47 <jethr0> hmm, Either could contain the "exception" in one branch...
15:22:12 <Saulzar> But you end up threading it everywhere...
15:22:14 <jethr0> and how about the Error monad
15:22:57 <jethr0> but i thought you could lift a monad into another... and then the threading would be (monadically) transparent again
15:23:29 <Saulzar> Ah hah.. 
15:23:35 <Saulzar> ErrorT 
15:23:56 <Saulzar> Hmm
15:24:02 <jethr0> hmm
15:24:48 <SyntaxNinja> Pupeno: so that's a 'no' then?
15:27:35 <Saulzar> ErrorT does not seem so convenient as exceptions, though it seems you cannot so easily give a value with an exception
15:30:14 <Lemmih> Pupeno: How so?
15:30:31 <SamB> Saulzar: tried throwDyn?
15:30:48 <SamB> though admittedly thats not a good way to use exceptions
15:30:56 <Saulzar> I was just looking at that, which is why I said "so easily" :)
15:31:19 <Saulzar> Yeah, seems a slightly strange thing to do
15:32:02 <SamB> ErrorT probably isn't as bad as it might seem when you get down to it...
15:33:22 <Saulzar> Hm, you're right - I'll give that a go - it must be better than IO Maybe Foo
15:33:31 <jethr0> is it "haskell" or "Haskell"?
15:33:33 <Saulzar> Which is not fun
15:33:39 <SamB> jethr0: in what context?
15:33:54 <jethr0> when i write "haskell code"...
15:34:04 <SamB> Haskell is generally the way to go, I guess
15:34:06 <jethr0> in my TH tutorial :)
15:34:11 <SamB> ah, definately Haskell
15:34:13 <Saulzar> Is it a proper noun?
15:34:30 <SamB> Well, there's a guy named Haskell Curry...
15:34:34 <jethr0> B.
15:36:03 <Saulzar> There might have been a guy called Mike Wheelbarrow too, but none the less I think it would still be wheelbarrow :)
15:36:38 <jethr0> but it is "Fahrenheit", right?
15:37:28 <Speck> I think uppercase
15:37:39 <Speck> actually, scratch that; all caps
15:37:58 <Saulzar> Haha.
15:38:16 <jethr0> today, we are witnessing an outside temperature of 90 degrees FAHRENHEIT.
15:38:22 <SyntaxNinja> aha! it's lemmih
15:38:33 <SyntaxNinja> Lemmih: so what would you think about doing some cabal-get hacking?
15:38:37 <triplah> jethr0: where?
15:38:47 <triplah> jethr0: its been getting up around that here recently
15:39:20 <jethr0> triplah, what do you mean?
15:39:33 <Saulzar> All caps to indicate you are still using backward imperial units.
15:39:40 <jethr0> hehe
15:39:53 <jethr0> it's like a markup of deprecation :)
15:39:59 <jethr0> s/of/for/
15:40:15 <triplah> jethr0: its been getting that hot here
15:40:16 <triplah> :)
15:40:38 <Speck> 23 degrees FAHRENHEIT over here
15:40:44 <jethr0> ah, no, that was wishful thinking in my part. it's more like 30 fahrenheit over here..
15:40:50 <jethr0> na, maybe 40
15:41:40 * Cale has Wadler's combinators working
15:41:42 <Cale> hmm, how to add alignment markers to this :)
15:41:59 <Speck> Cale: which combinators?
15:42:09 <Cale> Pretty printing
15:42:17 <jethr0> no idea, i was just using "language.haskell.pretty". never even looked at how they worked internally :)
15:42:38 <jethr0> i still think that aligning multiple things over multiple lines is hard!
15:45:51 <Cale> I added a feature where line breaks store what to replace themselves with if flattened.
15:46:02 <jethr0> very cool!
15:46:16 <jethr0> monadic or arrows?
15:46:21 <Cale> neither
15:46:25 <jethr0> aha
15:46:28 <Cale> It's actually pretty simple :)
15:46:34 <jethr0> just plain old combinator functions
15:46:44 <Cale> yeah
15:46:57 <jethr0> but don't they have to communicate about their contents' lengths?
15:47:38 <Cale> the lengths are computed when pretty printing the tree.
15:47:46 <jethr0> hmm, maybe it's all possible in a bottom-up single-pass kinda way
15:53:33 <Cale> http://vx.hn.org/autoshare/Wadler.hs
15:54:40 <jethr0> except for the "best" function that is pretty simple code :)
15:55:13 <dons> @where+ diet http://web.engr.oregonstate.edu/~erwig/diet/
15:55:14 <lambdabot> Done.
15:55:19 <Cale> Even 'best', if you look at it closely, is not too bad.
15:55:33 <jethr0> ya, it's just dispatching on type
15:55:52 <SyntaxNinja> hi dons. I uploaded fps to hackage.
15:56:14 <Cale> It's a very clever design though, and has lots of nice properties.
15:56:26 <dons> SyntaxNinja, cool. re. hmp3, it needs the darcs version of fps.
15:56:30 <Cale> It's kind of scary to add things to it, for fear of breaking them :)
15:56:37 <SyntaxNinja> ahh
15:56:39 <dons> but there's now a snapshot, that it can use
15:56:57 <dons> the fps-051204.tar.gz one
15:57:54 <jethr0> > curry (+) (3,2)
15:57:55 <lambdabot>   add an instance declaration for (Show (b -> ((a, b1), b) -> ((a, b1), b)
15:57:55 <lambdabot> ))
15:57:57 <SyntaxNinja> is that really the versin number?
15:57:57 <jethr0> > uncurry (+) (3,2)
15:57:58 <lambdabot> 5
15:58:10 <SyntaxNinja> dons: you shuld get cabal-put and start uploading stuff :)
15:58:19 <dons> SyntaxNinja, nope. just the darcs dist number, iirc.
15:58:44 <dons> yes!
15:59:13 <SyntaxNinja> man. I wish I weren't so busy. I want to release a cabal + cabal-install, and maybe cabal-get at the samet ime.
15:59:17 <SyntaxNinja> people might start using it then
16:02:31 <ihope> Ahoy-hoy
16:02:53 <Cale> hi
16:03:27 <ihope> My installation of Hugs seems to have gone missing, or maybe I never had it in the first place?
16:03:37 <ihope> Anyway, I'm about to install it.
16:03:51 <Cale> ihope: maybe ghci?
16:04:06 <ihope> Good idea.
16:04:07 <Cale> (and ghc)
16:05:32 <Cale> hmm
16:06:00 <jethr0> let f = \a -> \b -> \c -> a+b+c
16:06:06 <jethr0> is that "curried" form or "uncurried"
16:06:13 <Cale> curried
16:06:16 <jethr0> i never can remember which is which
16:06:17 <jethr0> thx
16:06:44 <dons> cool, lambdabot integration into hoogle
16:06:48 <ihope> Uncurried looks normal, curried is normal ;-)
16:07:09 <Cale> heh
16:07:24 <dons> oh, so now lambdabot depends on hoogle, and hoogle depends on lambdabot..
16:07:35 <dons> we'll need .cabal-boot files soon ;)
16:07:45 <SyntaxNinja> NoooooOOOOO0000000!!!!!
16:08:12 <SyntaxNinja> .cabal-looks-like-a-hammer-and-everything-looks-like-a-nail
16:08:21 <dons> hehehe. recursion is only natural, SyntaxNinja
16:08:36 <jethr0> but not infinite!
16:08:40 <Cale> hoogle depends on lambdabot?
16:09:00 <dons> check out haskell.org/hoogle and search for some @where strings
16:09:03 <dons> like 'ghc' or 'yi'
16:09:33 <Cale> haha
16:09:40 <SyntaxNinja> @hoogle 
16:09:40 <lambdabot> HOOGLE - Haskell API Search
16:09:40 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
16:09:40 <lambdabot>  
16:09:44 <SyntaxNinja> @hoogle catch
16:09:45 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
16:09:45 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
16:09:45 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
16:09:55 <ihope> @hoogle putChar
16:09:55 <lambdabot> Prelude.putChar :: Char -> IO ()
16:09:55 <lambdabot> System.IO.putChar :: Char -> IO ()
16:09:55 <lambdabot> System.IO.hPutChar :: Handle -> Char -> IO ()
16:09:58 <Cale> oh, I knew about that direction
16:10:24 <Cale> @hoogle yi
16:10:24 <lambdabot> Control.Concurrent.yield :: IO ()
16:10:24 <lambdabot> GHC.Conc.yield :: IO ()
16:10:24 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
16:11:06 <ihope> Is it just me, or is GHC 
16:11:10 <ihope> "big"?
16:11:15 <Cale> It's big
16:11:31 <Cale> and you shouldn't try to compile it unless you're really really certain that you want to :)
16:11:46 <ihope> :o)
16:11:49 <ihope> Three hundred or so megabytes, somehow packed into a tenth of that size?
16:12:01 <dons> luckily the recursion is tied by lambdabot's  hoogle not yet being updated to the version that in turn uses lambdabot
16:12:43 <luqui> I compiled, since I'm on gentoo.  Get a two-hour movie, start compiling at the beginning, it's almost done at the end!
16:13:09 <ihope> Almost, eh?
16:13:10 <Speck> took me 2 days to compile :-(
16:13:12 <Cale> luqui: dcoutts put a binary of 6.4.1 in gentoo :)
16:13:14 <Saulzar> dons, Both dynamically load each other?
16:13:18 <Cale> (just recently)
16:13:23 <luqui> that would have been nice ;-)
16:13:37 <luqui> Speck, two days!!?? are you on a mac?
16:13:49 <Speck> yes, a 400MHz G4
16:13:55 <dons> Saulzar, ah, that would work. I'mm not sure how ndm is calling lambdabot from hoogle though..  I wonder..
16:13:59 <luqui> ghc's speed really really suffers on macs
16:14:01 <ihope> (putStr . concat . repeat) "W00t\n"
16:14:04 <luqui> I'm not sure why
16:14:14 <dons> um, line buffering maybe?
16:14:18 <ihope> W0Interrupted.
16:14:22 <dons> try something other than IO..
16:14:43 <jethr0> anyone know how to get a single newline in the hawiki (i.e. not a paragraph)?
16:14:56 <Saulzar> I downloaded the binary, it took me half an hour :)
16:15:10 <ihope> Took me a few minutes...
16:15:25 <ihope> About four.
16:15:28 <dons> 2 days on a 400MHz g4. hmm...
16:15:45 <dons> since it only takes 30 hrs on a 33Mhz m68k, I wonder what's up with that then...
16:15:52 <dons> maybe macs are reallly slow.
16:15:57 <luqui> I remember on my G4 laptop it would take hours to compile pugs
16:15:57 <Speck> this one is
16:16:02 <ihope> Where's the RAM?
16:16:10 <luqui> whereas I'd get back to my AMD desktop and it would take about 15 minutes
16:16:17 <Speck> it has 2GB of RAM, this one does
16:16:30 <Speck> I take it back, 1.5
16:16:30 <dons> hmm. something's weird
16:16:38 * luqui agrees
16:16:42 <luqui> about the m68k
16:16:56 <luqui> how does that possibly have enough ram?
16:17:08 <dons> 36M is enough.
16:17:15 <dons> with swap ;)
16:17:40 <dons> ghc isn't java, you know ;)
16:18:15 <Igloo> dons: You can compile ghc in 30 hours on an m68k? Is that registerised?
16:18:21 <luqui> I guess it isn't if you don't turn on optimization :-)
16:18:21 <dons> but this is still very strange. we used to do nightly builds on macs, which would complete in under 12 hrs.
16:18:32 <Igloo> dons: Oh, that'll be from .hc files, right?
16:18:39 <dons> not registerised. and it's been several years, Igloo. yes, from .hc files
16:18:51 <dons> last  time I tried was 5.04.2, iirc.
16:18:51 <Igloo> OK, that makes more sense then  :-)
16:19:31 <dons> how long do the package builds take on debian?
16:19:43 <dons> do you get fast m68ks to play with?
16:19:47 <Igloo> The last ghc6 build was 137 hours
16:19:58 <dons> hehe
16:19:59 <Speck> it might have to do with the way darwinports set  up the build, or that my computer is 4-5 years old
16:20:15 <dons> Speck, but reallyy it should run faster than a 15 yo mac
16:20:39 <dons> get an amd64 box ;)
16:20:57 <Speck> I'm getting a PC soon, specifically for Haskell work.
16:21:11 * luqui didn't have much luck with amd64
16:21:24 <Speck> I want to get a multicore/multiprocessor computer tho, to mess with STM
16:21:26 <luqui> I'm on amd64 right now, but running in 32 bit mode specifically for haskell
16:21:27 <dons> even unregisterised amd64 beats my p4
16:21:34 <dons> oh, why?
16:21:36 <dons> 64 bits are fine.
16:21:47 <luqui> it would randomly crash while compiling
16:21:49 <ihope> So... how do I pop a new type into GHCi?
16:21:53 <luqui> and no ghci :-(
16:22:02 <dons> we do have amd64/ghci, for a while now...
16:22:02 <luqui> ihope, make a file, I think
16:22:09 <luqui> huh.  weird
16:22:13 <ihope> And how do I load it?
16:22:15 <luqui> this was a couple months ago
16:22:19 <luqui> ghci <filename>
16:22:27 <triplah> i use amd64 ghci
16:22:39 <dons> since a lot of people out there are using it, I'd suggest you try again, luqui :)
16:22:49 <dons> simon marlow has an amd64 on his desk..
16:23:03 <luqui> yeah maybe... though I'll probably keep 32 bit mode for a bit.  there are other perks...
16:23:04 <dons> so you can personally complain to him if 6.4.1 crashes
16:23:07 <triplah> can linux ghci open windows dll's ?
16:23:25 * luqui doubts it...
16:23:47 <Igloo> The last 3 builds are 144 hours on an "Amiga 3000UX 68060/50 128M", 120 and 137 hours on what I think is an "Amiga 1200 68060/50 256M"
16:23:54 <ihope> Okay. Works!
16:24:10 <dons> that's so not going to happen, triplah.
16:24:19 <dons> Igloo, cool, yeah I was wondering if you had 060s to play one.
16:24:28 <dons> s/e.$//
16:25:20 <Igloo> Looks like they vary from 68040/25 to 68060/56
16:25:43 <ihope> Now how do I do this: data Foo a = (Foo (b -> a)) :-P (Foo b)
16:26:26 <Igloo> You need b on the LHS if using Haskell 98
16:27:41 <Speck> hmm, I should get a "Quad" 2.5GHz for multicore/multiprocessor study :-|
16:27:42 <ihope> ...Aha. I see.
16:30:46 <dons> @djinn-ver
16:30:46 <lambdabot> Djinn version 2005-12-15.
16:33:24 <ihope> ...No, I don't. Why couldn't it be bound when the data constructor takes it?
16:34:25 <dons> @djinn a -> a
16:34:26 <lambdabot> f = id
16:34:27 <dons> :)
16:34:35 <dons> @type flip
16:34:36 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
16:34:40 <dons> @djinn (a -> b -> c) -> b -> a -> c
16:34:41 <lambdabot> f = flip
16:34:53 <ihope> @djinn (a -> b -> c) -> (a -> b) -> a -> c
16:34:53 <lambdabot> f x3 x4 x5 = x3 x5 (x4 x5)
16:35:07 <ihope> > ap
16:35:07 <lambdabot>  add an instance declaration for (Show (m (a -> b) -> m a -> m b))
16:35:31 <ihope> @type ap
16:35:31 <lambdabot> Not in scope: `ap'
16:36:24 <ihope> > error "> error \"Meh.\" :: a" :: a
16:36:25 <lambdabot> Add a type signature
16:36:33 <ihope> > error "> error \"Meh.\" :: Int" :: Int
16:36:34 <lambdabot> Exception: > error "Meh." :: Int
16:36:40 <dons> defeated ;)
16:36:41 <ihope> Hmm :-)
16:36:54 <ihope> But would it have worked before?
16:37:00 <dons> npoe
16:37:07 <dons> lambdabot ignore itself
16:37:09 <ihope> Thought not.
16:37:31 <ihope> Otherwise, I could turn lambdabot into a spambot.
16:37:41 <Cale> however, if there was another lambdabot on the channel
16:37:51 <Cale> you could get messages bouncing back and forth
16:38:10 <ihope> Ooh...
16:38:39 <Cale> Bots are supposed to use Notices to communicate, but there are lots of really broken IRC clients which render them in irritating ways
16:39:05 <ihope> ..Just what is a notice?
16:39:08 <Cale> Notices are basically supposed to look like ordinary talking
16:39:13 -Cale(n=cale@toronto-HSE-ppp4255100.sympatico.ca)- hello
16:39:19 <Cale> that is
16:39:27 <ihope> Ah
16:40:08 <dons> so there's a long story about how we fixed llambdabot to use notices, as per the rfc, but then people complain, with sucky clients, and we had to revert back
16:40:26 <ihope> Ah.
16:40:34 <dons> i think gaim was the chief offender
16:40:36 <ihope> Just how might these be rendered?
16:40:41 <dons> it actualy popped up new windows (?)
16:40:56 <Oejet> Gaim is maybe still broken, but they know about the problem!
16:41:26 <triplah> egads
16:41:31 <triplah> gaim is the worst irc client ever
16:42:03 <ihope> So gaim *is* the problem?
16:42:27 <dons> it doesn't implement the irc rfc, so yep.
16:43:01 <dons> and due to its market share, messes it up for the rest of us . luckily its not a very serious problem at all
16:43:30 <triplah> i dont know how people use it
16:43:44 <triplah> irssi looks better than gaim's irc client
16:43:47 <Speck> irssi renders it quite nicely: in a different color, (bold "Cale") ++ " #haskell  " ++ "hello"
16:44:04 <triplah> although, irssi is probably my favourite irc client
16:44:05 <triplah> ;)
16:44:08 <triplah> using xchat atm
16:44:09 * pesco considers switching back to irssi.
16:44:12 <ihope> > bold
16:44:13 <lambdabot>  Not in scope: `bold'
16:44:15 <ihope> ;-)
16:44:32 * dons considers a merge of lambdabot and hmp3 into a new hirc
16:44:32 <triplah> > e
16:44:33 <lambdabot>  parse error on input `'
16:44:43 <Speck> I forgot to import my typesetting library
16:44:57 <triplah> > error "boldword"
16:44:57 <lambdabot>  parse error on input `'
16:44:59 <triplah> argh
16:45:19 <triplah> > error " boldword"
16:45:19 <lambdabot>  lexical error in string/character literal
16:45:27 <triplah> bah, oh well :)
16:45:39 <Speck> > error "boldword"
16:45:40 <musasabi> triplah: you need to quote the escape sequence probably
16:45:40 <lambdabot>  lexical error in string/character literal
16:45:51 <triplah> musasabi: yep
16:46:11 <triplah> > error "\bold"
16:46:12 <lambdabot>  lexical error in string/character literal
16:46:16 <triplah> :(
16:46:17 <ihope> Hmm, what's the bold code?
16:46:26 <triplah> ctrl b in xchat
16:46:30 <araujo> Hello!
16:46:32 <Speck> same for irssi
16:46:34 <triplah> note sure on the code
16:46:38 <triplah> not*
16:46:44 <jethr0> not
16:46:47 <jethr0> cool
16:47:11 <Speck> > print "underline?"
16:47:12 <lambdabot>  lexical error in string/character literal
16:47:15 <jethr0> ctrl-i in xchat did not do what i expected
16:48:13 <Cale> hehe, 3 people replied to my notice so far :)
16:48:21 <ihope> Notice?
16:48:30 <Cale> I sent one to #haskell
16:48:33 <ihope> Aha.
16:48:40 -ihope(n=ihope@c-67-172-99-160.hsd1.mi.comcast.net)- Like this?
16:48:41 <Cale> >#haskell< hello
16:48:43 <dons> saying what? don't send me notices?
16:48:45 <Cale> yes
16:48:52 <Cale> like that
16:49:09 <Cale> on my client (XChat) it renders as "-ihope- Like this?"
16:49:25 <Cale> in #haskell
16:49:29 -int-e(n=noone@td9091c22.pool.terralink.de)- I could've seen it but I was idle.
16:49:33 <Speck> wasn't there a haskell irc client? hercules or something?
16:49:35 <ihope> Here it's [ihope].
16:49:37 <Cale> but some clients treat it like a private message :)
16:49:42 <dons> @where hircules
16:49:42 <lambdabot> I know nothing about hircules.
16:49:47 <dons> @google hircules
16:49:49 <lambdabot> http://freshmeat.net/projects/hircules/
16:50:07 <dons> yes, based on a fork of lambdabot
16:50:07 <Speck> is it usable?
16:50:46 <dons> @where+ hircules http://freshmeat.net/projects/hircules/
16:50:47 <lambdabot> Done.
16:50:49 <dons> not sure.
16:51:03 <int-e> Cale: why would anyone do that? hehe.
16:51:21 <dons> but I thought there was a curses one. maybe I'm thinking of some CosmicRay gopher tool
16:51:53 <Speck> I'd like to be able to extend my IRC client in Haskell...
16:52:59 <dons> I should write a little howto, on extending foreign apps with haskell plugins.
16:53:21 <Speck> I'd read it
16:53:32 <ihope> > let { ack 0 n = n+1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 1
16:53:37 <lambdabot> Terminated
16:54:28 <dons> Speck, you could read the hs-plugins paper. the basic idea is in there.
16:54:41 <Speck> I've read it some time ago. I should revisit it.
16:54:42 <dons> but a neat little wrapper library, and some examples, would be useful I think
16:55:32 <dons> the hs-plugins paper has an example of an objective C app extended with haskell parser plugins
16:55:55 <Speck> oh, that would be good for me, I use a lot of objc apps
16:55:57 <ihope> How do I do the evaluation tracey thingy in GHCi?
16:56:28 <jethr0> dons, where's the hs-plugins paper located?
16:56:43 <jethr0> ah, got it
16:56:52 <dons> @google Plugging Haskell In
16:56:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
16:56:56 <dons> :)
16:57:11 <dons> ihope, is that +s ?
16:57:24 <dons> Speck bah. the general idea is identical. you just need an ffi.
16:57:25 <jethr0> it's just that last time i looked for hs-plugins in google it didn't come up with very much...
16:57:34 <dons> @google hs-plugins
16:57:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
16:57:38 <dons> ?
16:58:22 <dons> @google hmp3 haskell
16:58:23 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg17700.html
16:58:24 <Speck> dons: ic, but the c/objc app needs to know about the plugins?
16:58:27 <jethr0> no, i found your page, but i'd hoped to find other pages "talking" about it
16:58:27 <dons> oh well.
16:58:48 <dons> Speck, well, yeah. why wouldn't it?
16:58:53 <jethr0> how's the performance of on-the-fly compiling compared to other interpreters?
16:59:02 <jethr0> is there an added notable latency?
16:59:04 <dons> > "works fine"
16:59:05 <lambdabot> "works fine"
16:59:20 <Speck> dons: dunno. just not really thinking too hard about the problem
16:59:21 <dons> yes, slight latency, but then your plugin runs at native code speed.
16:59:46 <dons> jethr0, @eval/> is implemented with compiled plugins underneath
16:59:51 <jethr0> true, so for non-trivial applications it might just as well cancel out...
17:00:12 <jethr0> dons, i know, i've looked at the code in lambdabot :)
17:00:24 <dons> yep. for throw away code, an interpreter might be better. for plugin style apps, compiled code seems better.
17:00:30 <dons> really depends on the lifetime of the code
17:00:41 <jethr0> and its complexity
17:01:04 <dons> anything non-trivial you may as well compiled anyway, right.
17:04:35 <Speck> @where hIDE
17:04:36 <lambdabot> http://www.haskell.org/hawiki/hIDE
17:06:21 <Speck> I wonder if composable memory transactions will make it easier to build a threaded hIDE from smaller parts (read: plugins)
17:06:44 <dons> hmm. interesting idea.
17:07:12 <SyntaxNinja> please stop msging me everyone!
17:07:19 <SyntaxNinja> (notice) I don't need more open tabs
17:07:31 * Speck points and laughs
17:07:33 <dons> hehe
17:07:48 <SyntaxNinja> we once discovered we could make somone's IRC client emit a system beep. that was fun.
17:07:57 <dons> oh man. that would be cool.
17:08:11 <SyntaxNinja> he was obsessed w/ running everything in the terminal. X is evil.
17:08:14 * Igloo wonders why SyntaxNinja is so popular tonight
17:08:22 * dons dreams of @beep-you <nick>
17:08:24 <SyntaxNinja> Igloo: you mean about all my msgs
17:08:30 <Igloo> Yeah
17:08:44 <Cale> %007
17:08:46 <dons> the notice games Cale was playing...
17:08:46 <Cale> er
17:08:52 <ihope> Muahaha?
17:09:06 <Speck> 3:-C
17:09:06 <Cale> hmm, %7
17:09:08 <Cale> no
17:09:28 <Igloo> ITYM 
17:09:35 <Cale> hehe, XChat is *supposed* to be able to convert ascii codes :)
17:10:49 <ihope> > error "\a"
17:10:50 <lambdabot> Add a type signature
17:10:54 <ihope> > error "\a" :: Int
17:10:55 <lambdabot> Exception: 
17:10:58 <Cale> 
17:11:02 <ihope> :-)
17:11:07 <Cale> there we go
17:11:13 <ihope> Didn't work over here.
17:11:20 <Lor> My machine beeped. :)
17:11:25 <SyntaxNinja> haha
17:11:28 <ChilliX> Worked here, what did you type, cale?
17:11:32 * Lor had forgotten to run xset -b.
17:11:37 <Cale> Ctrl-Shift-007
17:11:49 <SyntaxNinja> now lor is gonig to have to try to ignore his beeping terminal for the next 10 minutes
17:11:55 <ihope> [INFO] Font size is default
17:11:55 <Lemmih> SyntaxNinja: Some cabal-get hacking could be nice. Perhaps it would even calm my nerves.
17:11:56 <jethr0> try again, didn't have my headphone on
17:12:10 <Cale> 
17:12:13 <SyntaxNinja> Lemmih: excellent :)
17:12:14 <Lor> headphone, bah, you don't have areal beeper?
17:12:17 <jethr0> nah, nothing
17:12:29 <SyntaxNinja> Lemmih: can you grab the latest cabal and take a look at haskell-install? 
17:12:43 <Oejet> Lemmih: Why are you upset?
17:12:56 <ihope> > error (repeat 'r') :: Int
17:13:00 <SyntaxNinja> Lemmih: I'd like to move some of the multi-package resolution functionality to haskell-install, maybe just have a function that inputs a list of package descriptions and outputs the dependencies in order.
17:13:04 <SyntaxNinja> that's pretty easy
17:13:09 <SyntaxNinja> but I think you'll see what I mean.
17:13:30 <SyntaxNinja> I kinda think that cabal-get should download the stuff & talk to hackagedb, but cabal-install should do the actual installation.
17:13:31 <Lemmih> Oejet: Mailed my college application to the student administration a week ago.
17:13:49 <Lemmih> SyntaxNinja: I'll poke into it tomorrow. Gotta get some sleep now. Good night.
17:13:59 <Speck> dons: which is the most recent yi repo?
17:14:02 <SyntaxNinja> 'ngiht Lemmih
17:14:12 <Oejet> Good night, Lemmih. :-)
17:14:45 <ihope> 'thgin?
17:14:49 <ihope> > reverse
17:15:45 <mjl69> is there a guide anywhere to lambdabot?  The wiki says I should ask here.
17:16:13 <ihope> Lambdabot seems to have stopped functioning.
17:16:25 <ihope> Or maybe it's simply ignoring me.
17:16:30 <dons> @bot
17:16:55 <ihope> *Now* it reponds to the "@arr".
17:17:14 <mjl69> oh, it's not just me then.
17:17:43 <Speck> maybe you all made lambdabot uncontrollably beep, leading to suicide
17:17:51 <Speck> (for shame)
17:18:50 <mjl69> I was looking for a haskell interpreter for Pocket PC.  a quick google search didn't reveal much.  I am looking for an easy way to quickly try out simple examples while I read from my book.
17:18:57 <dons> @version
17:18:58 <lambdabot> lambdabot 3p238, GHC 6.5.20050806 (Linux i686)
17:18:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
17:19:13 <dons> mjl69, what lambdabot questoins do you have?
17:19:34 <ihope> (putStr . take (9^9^9^9) . repeat) '\a'
17:19:38 <dons> mjl69, re pocket pc, probably hugs would be the best way to go
17:19:46 <dons> @where hugs
17:19:48 <lambdabot> http://haskell.org/hugs
17:19:54 <araujo> dons, hi hi!
17:19:58 <dons> heya araujo
17:20:00 <mjl69> oh, hugs for Pocket PC?  cool... I'll go look, thanks
17:20:22 <araujo> dons, just uploaded my shell today morning!
17:20:28 <dons> cool :)
17:20:32 <araujo> dons, haskell.org/hashell checkout!
17:20:43 <SyntaxNinja> araujo: is it cabal-ized? i'll upload it to hackage :)
17:20:52 <araujo> SyntaxNinja, yes it is
17:21:06 <araujo> That'd be cool :-]
17:21:33 <mjl69> hmm. don't see PocketPC there.  I guess I would need a Linux PDA maybe.
17:22:17 <SyntaxNinja> d'oh, hs-plugins isn't in hackage yet
17:22:30 <dons> oh, I need to release the cabalised version.
17:22:43 <dons> so many people asking :/ better do it, I guess
17:22:43 <araujo> dons, do it do it!
17:22:45 <araujo> :-)
17:22:51 <Pupeno> how do you do install arbitrary files with cabal ? like a script or an image ?
17:23:22 <Speck> dons: which? the paper-spec version, or yi+gtk?
17:24:00 <Speck> because yi+gtk is cabalized
17:24:28 <dons> Speck? which yi do you want, curses or gtk?
17:24:29 <dons> @where yi
17:24:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:24:31 <dons> ^^ curses
17:24:35 <dons> @where yi+gtk
17:24:35 <lambdabot> darcs get http://www.scannedinavian.org/repos/yi/
17:24:44 <Speck> I'd prefer the gtk one, and getting all of hIDE into hackage
17:24:47 <dons> and that one.
17:24:54 <dons> not sure if its ready...
17:25:27 <Pupeno> araujo: hello, hashell looks intesting.
17:25:56 <Speck> that's true, but I don't see too much issue for listing a not-completely-ready program on a not-completely-ready package db
17:26:13 <SyntaxNinja> Pupeno: I don't think you can do that w/ any released versin
17:26:18 <dons> @where+ hashell haskell.org/hashell
17:26:19 <lambdabot> Done.
17:27:33 <araujo> Pupeno, hello there, yeah, :-]
17:28:05 <araujo> Still buggy, mainly to deal with special chars.
17:28:47 * araujo looking for an uniform way to deal with them
17:29:03 * araujo off to eat, brb
17:29:29 * ihope wants to do hIDE GUI stuff
17:30:06 <Speck> I'd like to help with hIDE also, but I don't know where to start -- probably getting it to compile
17:31:01 <dons> get it to compile, find something that annoys you, try to fix it.
17:31:14 <ihope> I guess I could do that.
17:31:19 <dons> or add something, say djinn support
17:31:36 <Speck> I spent about 2 weeks trying to get hIDE and all it's dependencies to compile and eventually schoolwork caught up with me
17:31:36 <ihope> But will it look silly with the psuedonym "IhopePsuedonym"?
17:32:07 <Speck> djinn stub code generation would be a cool feature
17:32:27 <dons> or @pl as a plugin?
17:32:33 <dons> or HaRe support.
17:32:35 <Speck> yeah
17:32:54 <dons> there's a todo list on the website as well.
17:32:55 <Speck> a structural editor view based on a generic zipper
17:35:14 <jethr0> does hIDE use yi?
17:35:22 <Speck> yes
17:35:30 <jethr0> ah, cool
17:35:47 <dons> it's just a plugin 
17:35:56 <SyntaxNinja> dons: your mission is to make it so I can cabal-get install yi ;)
17:36:22 <dons> well, this should work for the curses yi. it's just been cabalised by Taral.
17:36:30 <dons> for hIDE, that would be the big one
17:36:37 <SyntaxNinja> dons: so upload it to hackage :)
17:37:00 <Speck> hIDE and plugins is so customizable during compilation
17:37:36 <dons> I'm going to release hs-plugins a first. get that up there. and hmp3 0.3 just got released 10 mins ago... so i'll get those up first.
17:38:09 <dons> araujo, hmp3 0.3 is available for you to package  :)
17:38:24 <dons> it should run on linux/ppc now (I think) and on other weird archs
17:40:54 <dons> it would be nice if hackage somehow supported darcs repoos that have been cabalised
17:41:08 <dons> so you could, if you want, click on the darcs version, and it would get that
17:41:21 <dons> maybe it wouldn't be nice for users, but it sounds nice to me.
17:42:35 <Speck> sounds like it would be nice
17:43:22 <SyntaxNinja> dons: I want to support something like that :)
17:43:32 <SyntaxNinja> we have to walk before we can run
17:43:35 <dons> right.
17:46:42 <musasabi> Is there a good page what one must do to support hackage? (In particular how do I automate a makefile/shell script/darcs tag to push an updated package)
17:46:43 <Cale> jethr0: hehe, why didn't I notice that implementation before? :)
17:48:00 <SyntaxNinja> musasabi: cabal-put is the tool you need. it's self documenting ;)
17:48:17 <SyntaxNinja> sorry there's no good write-ups as of yet.  get cabal-get-bootstrap, then cabal-get install cabal-put, then play w/ cabal put.
17:48:31 <SyntaxNinja> someone just needs to bundle this stuff nicely and write a README!
17:48:42 <ihope> I'd love a good natural language parser.
17:49:10 <luqui> wouldn't we all
17:49:11 <Speck> so would spammers :-!
17:49:12 <musasabi> mmh, any package that uses it as part of the release system? (so I could just look there)
17:49:29 * luqui plans to do his graduate research in NLP
17:50:24 <jethr0> cale, which one?
17:51:14 <jethr0> speck, but if spammers had it, and _we_ had, then this knowledge might cancel each other out... *hopefully*
17:51:32 <Speck> jethr0: yes, interesting
17:51:50 <SyntaxNinja> musasabi: just cabal-ize your package and someone can upload it to hackage
17:51:57 <SyntaxNinja> that's all you need to do.
17:52:00 <Speck> either that or we would discover what the postmodernists have been saying all along, that semantics don't really exist
17:52:10 <SyntaxNinja> musasabi: if you've cabal-ized it, email it to me and i"ll upload it :)
17:52:20 <ihope> Semantice don't exist, eh?
17:52:27 <ihope> > semantics dont exist
17:52:31 <lambdabot>  Not in scope: `exist'
17:52:39 <jethr0> > semantics
17:52:40 <lambdabot>  Not in scope: `semantics'
17:52:43 <jethr0> hehe
17:52:45 <ihope> Oh...
17:52:48 <Speck> lambdabot is precisely correct. exists doesn't exist
17:52:59 <ihope> > Not in scope: `exist'
17:52:59 <lambdabot>  parse error on input `in'
17:53:07 <Speck> neither do: be, is, were, understand
17:53:11 <ihope> > parse error on input `in'
17:53:11 <lambdabot>  parse error on input `}'
17:53:18 <ihope> > parse error on input `}'
17:53:19 <lambdabot>  parse error on input `}'
17:53:19 <jethr0> i wonder why he took exception at "exits"... shouldn't a parser report the absolute _first_ error location?
17:53:38 <dons> @seen psi
17:53:39 <lambdabot> psi is in #haskell. I don't know when psi last spoke.
17:53:42 <Spark> > pain
17:53:44 <lambdabot>  Not in scope: `pain'
17:53:54 <Spark> > 1 + 1
17:53:56 <lambdabot> 2
17:53:57 <ihope> GHC reports all of them
17:54:07 <ihope> @arr
17:54:07 <lambdabot> Aye
17:54:14 <dons> twb, how'd you go building hmp3 on the ppc?
17:54:17 <dons> or did you give up?
17:54:20 <Spark> > ((\x.xx) (\x.x)) 4
17:54:21 <lambdabot>  parse error on input `.'
17:54:32 <Spark> > ((\x -> xx) (\x -> x)) 4
17:54:33 <lambdabot>  Not in scope: `xx'
17:54:36 <Spark> > ((\x -> x x) (\x -> x)) 4
17:54:37 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:54:37 <lambdabot>   Expected type: t
17:54:37 <lambdabot>   Inferred type: t -> t1
17:54:47 <Spark> gut ted
17:55:42 <ihope> > error "W00t!" :: Int
17:55:43 <lambdabot> Exception: W00t!
17:55:49 <jethr0> > ((\x -> x x) (\x -> x)) (const 4)
17:55:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:55:49 <lambdabot>   Expected type: t
17:55:49 <lambdabot>   Inferred type: t -> t1
17:55:59 <ihope> > \x -> x x
17:55:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:55:59 <lambdabot>   Expected type: t
17:55:59 <lambdabot>   Inferred type: t -> t1
17:56:04 <ihope> Bing.
17:56:11 <Spark> > ( let I = \x -> x in I I ) 4
17:56:12 <lambdabot>  Not in scope: data constructor `I'
17:56:15 <Spark> err
17:56:20 <Spark> whats the syntax for let?
17:56:23 <jethr0> @where gtk2hs
17:56:23 <lambdabot> http://haskell.org/gtk2hs/
17:56:36 <ihope> ( let i = \x -> x in i i ) 4
17:56:45 <ihope> > ( let i = \x -> x in i i ) 4
17:56:46 <lambdabot> 4
17:56:53 <Spark> thats why the let expression exists
17:57:49 <dons> psi, do you think you could build hmp3-0.3 for me? just grab it from here: http://www.cse.unsw.edu.au/~dons/hmp3/hmp3-0.3.tar.gz
17:58:05 <dons> and send me the .bz2'd  binary, I'll stick it up on the website.
17:58:12 <ihope> > (\_ -> _) 3
17:58:13 <lambdabot>  Pattern syntax in expression context: _
17:58:29 <Spark> > (\_ -> 3) _
17:58:31 <lambdabot>  Pattern syntax in expression context: _
17:58:40 <Spark> > (\_ -> 3) 4
17:58:41 <lambdabot> 3
18:03:55 <elk> so haskellSense isn't using yi ?
18:04:41 <dons> yi is using haskellSense
18:04:52 <dons> theyre' separate thingies
18:05:34 <elk> so i should run hIDE with both plugins ?
18:06:23 <dons> haskellsense is a colorising plugin, yi is and editor plugin. you'd need both to have colorised editing
18:07:23 <jethr0> hIDE without yi might be a bit dull
18:07:48 <Pupeno> does cabal run ghc in --make mode ?
18:08:11 <elk> hmm, when I run hIDE with yi only, I still got syntax highliting - probably from GTK SourceView
18:08:55 <dons> right.
18:09:15 <elk> and when I run it with haskellSense I get different colors + plus error -checking
18:09:24 <jethr0> autoconf'ing of gtk2hs gives me: configure.ac:26: error: possibly undefined macro: AM_INIT_AUTOMAKE
18:09:31 <jethr0> :(
18:09:44 <dons> elk, yep, it runs ghc package to do type checking and such.
18:10:07 <elk> right, but does it still uses yi for editing ?
18:11:38 * ihope can't figure it out
18:11:42 <dons> elk, yep.
18:11:57 <dons> colorising the buffer is independent of editing the buffer
18:12:06 <dons> anyone got and amd64 ?
18:12:12 <Saulzar> jethr0, Try aclocal first
18:12:23 <ihope> I don't think I have one.
18:12:39 <Saulzar> and autoheader... 
18:13:04 <jethr0> saulzar, thx a lot
18:13:15 <elk> dons: oh cool, so I better see how Yi works first
18:13:31 <Saulzar> It had me fooled for quite a while :)
18:13:58 <elk> dons: i have amd 64, although I run 32 bit ubuntu on it
18:15:34 <dons> oh ok. no 64 bit amd then?
18:16:40 <jethr0> saulzar, any idea what aclocal and autoheader do? never had to use them before... why can't they be called automaticall?
18:16:42 <jethr0> y?
18:17:17 <dons> do you need to run autoreconf ?
18:17:21 <dons> insttead of autoconf.
18:17:52 <jethr0> don't know, but aclocal + autoheader + automake + autoconfig + ./configure did the job :)
18:18:05 <dons> ah, sounds like you should have run: autoreconf ; ./configure
18:18:10 <jethr0> hehe
18:18:32 <dons> as it says in INSTALL..
18:18:51 <dons> "Building the CVS HEAD proceeds as normal building, except that you need to
18:18:58 <dons> run "autoreconf" with sufficiently new versions of the automake/autoconf
18:18:58 <dons> toolsuite installed. (automake 1.8.x, autoconf 2.59)
18:19:31 <dons> i don't know why people bother writing readmes and install docs. noone reads them anyway.
18:20:17 <Cale> jethr0: printAST ast = runQ ast >>= print
18:20:31 <jethr0> cale, cool
18:20:46 <Cale> jethr0: you're in the middle of an edit?
18:20:59 <Saulzar> Hehe - autoreconf is an awful name...
18:21:06 <jethr0> dons, sry for bothering you with trivia, seriously
18:21:08 <jethr0> cale, yes
18:21:14 <jethr0> just a sec
18:21:16 <Cale> In case you were wondering why in the above code the contructors
18:21:24 <Cale> typo :)
18:21:25 <Saulzar> I never knew it existed, if I ever read that in an INSTALL file I would not notice the "re"
18:21:44 <jethr0> cale, all yours :)
18:22:43 <jethr0> i haven't done the final cleanup of the text yet, but i'm getting there
18:23:15 <jethr0> cale, i'm desperate for some criticism concerning layout and readability...
18:28:18 <jethr0> ping
18:28:23 * Cale edits :)
18:28:37 <Cale> just lots of minor things
18:28:38 <jethr0> just wondering whether irc had just died on me...
18:28:55 <jethr0> np, i welcome any improvements!
18:29:19 <Cale> It's getting pretty readable, I think :)
18:30:37 <jethr0> thx
18:30:52 <jethr0> oh, you mean due to _your_ improvement :)))
18:31:16 <Cale> no :)
18:31:25 <Cale> my improvement is small
18:31:55 <jethr0> still, concrete criticism about general structure/approach would be cool with me...
18:32:04 <jethr0> done?
18:32:09 <Cale> yeah, I think so :)
18:33:27 <Cale> Apart from a bunch of tiny things, I moved the description of a piece of code closer to the code itself, as another paragraph had gotten inserted in between
18:33:59 <jethr0> yah, i know. i wasn't sure how to put that...
18:34:37 <Cale> is there a particular reason for the semicolon-at-start of line thing?
18:35:01 <jethr0> no... happy to change. i'd just seen this kind of formatting elsewhere and found it cute
18:35:16 <jethr0> but i'd be happy to do sth more idiomatic, i.e. less idiotic
18:35:22 <Cale> are the semicolons needed at all?
18:35:29 <jethr0> no
18:35:43 <Cale> I'd probably just drop them :)
18:36:25 <jethr0> your word in god's ear
18:36:39 <jethr0> (which only has 409 hits on google?!?)
18:36:57 <jethr0> maybe it's a german idiom
18:53:25 <Speck> what is it in german?
18:54:00 <jethr0> Dein Wort in Gottes Ohr, and that has got 180.000 hits on google :)
18:54:31 <jethr0> speck, are you german?
18:56:32 <Speck> nope
18:56:51 <Speck> just curious
18:56:59 <jethr0> just asking, 'coz your nick means bacon in german :)
18:57:21 <Speck> hahaha
19:00:19 <Saulzar> A tiny speck of bacon
19:00:32 <jethr0> haha
19:01:17 * Speck made his turkey this year with a few strips of bacon placed over the breast. Nice and crispy!
19:01:20 <jethr0> i think d o n s is really angry at me for asking about the autoconf :(
19:01:26 * Speck loves bacon/lard
19:02:11 <mjl69> 'white belt' question: why is this a non-exhaustive pattern? http://www.rafb.net/paste/results/qlx69261.html
19:02:16 <jethr0> or rather :-C
19:02:18 <Cale> I think he knows how to spell his own name jethr0 :)
19:02:18 <dons> jethr0, why?
19:02:33 <jethr0> dons, you seemed quite emotional...
19:02:38 <Saulzar> Hmm, it fooled me too .. I read the doc but I didn't notice the "re", so I searched for every single auto-xyz and ran it :)
19:02:39 <dons> oh, i wasn't at all. 
19:02:50 <dons> it was a joke. without smileys :)
19:02:52 <dons> sorry.
19:02:58 <jethr0> saulzar, that's actually funny :)
19:03:01 <Speck> :'( so emotional - all by myself )':
19:03:19 <jethr0> dons, np, i just hate it myself when people ask questions they could've easily read in a README or FAQ someplace
19:03:38 <Saulzar> Actually I first tried creating half the files manually, but after fixing about 106 errors I decided I wasn't going to see the end of it
19:03:45 <jethr0> hehe
19:03:57 <dons> nah, don't worry. no one reads readmes anyway.
19:04:01 <jethr0> fixing autoconf/automake files manually seems like a lost cause
19:04:36 <jethr0> i really _do_ wonder why install/readme files are always that verbose, when the pertinent information can most often be captured by "./configure;make;install"
19:04:47 <jethr0> why not put the special cases at the end of the file?
19:05:29 <Saulzar> gtk2hs seems really cool though, HOpenGL too .. I can use gtk to load images for textures :)
19:05:45 <jethr0> nice
19:06:12 <jethr0> is sourceview-any a haskell binding or is it just the normal gtk stuff?
19:07:44 <dons> normal gtk
19:08:30 <Speck> I'd like "cabal install yi+gtk" to determine if gtk2hs was compiled with sourceview, and if I don't have gtk2hs, to install it with that option enabled
19:08:53 <SamB> Speck: maybe it should ask questions?
19:09:20 <Speck> well, if I'm trying to install a working yi+gtk, I need to have sourceview or else it won't compile
19:09:35 <Speck> at least last time I tried it
19:09:53 <SamB> jethr0: I push for getting the common build commands into the first 23 lines ;-)
19:10:22 <jethr0> hehe, you mean putting them in there just for good measure :)
19:10:35 <SamB> hmm?
19:10:59 <SamB> they go there because nobody wants to have to scroll down to get to them
19:11:10 <jethr0> you mean to say that cabal can resolve source dependencies? why does noone tell me nuttin' ever :)
19:11:39 <jethr0> samb, i get it. i thought you meant executing all auto* commands in Setup.lhs or sth
19:13:04 <SamB> all I meant is that, when the subject comes up, I mention that the relevant build commands should be in the first screenful, which, in less under a default-sized xterm, is 23 lines
19:13:23 <jethr0> true
19:15:52 <SamB> usually, the subject comes up when I have trouble building correctly ;-)
19:16:57 <araujo> dons, oh yeah, geez... almost forget to package hmp3
19:17:16 * araujo next to do that
19:17:45 <SamB> what is the difference between cabalizing and packaging?
19:18:13 <dons> cabalising is rewriting the build system, packaging means someone makes it available in a distro package system.
19:18:13 <SamB> dons: haven't changed much lately have you?
19:18:16 <jethr0> cale?
19:18:26 <SamB> I thought that was called "uploading"
19:18:36 <dons> only 40-odd patches, and no changes in the last week, so that's stable enough for me.
19:18:42 <SamB> sometimes also "building"
19:19:02 <dons> uploading? nah, you still have to write build scripts to pacakge it. binaries built this way are known as packages in some distros
19:19:22 <dons> particulary bsd and gentoo, I would think.
19:19:45 <Cale> jethr0: hi
19:19:55 <jethr0> did you unindent my code at the bottom?
19:20:05 <Cale> unindent?
19:20:28 <jethr0> never mind, i could've sworn the code blocks were indented relative to the text...
19:21:11 <Cale> oh, it does seem to be choosing different levels of indentation
19:21:23 <Cale> I didn't know that it indented code blocks at all
19:21:43 <jethr0> weird... i'm just writing up my loop unrolling case study :)
19:23:27 <jethr0> it doesn't automatically, but i thought it might be a nice touch
19:24:46 <Cale> oh
19:24:51 <jethr0> oh?
19:25:05 <Cale> I meant that I didn't know that you could affect the indentation of code blocks at all
19:25:29 <jethr0> yup, although i am seriously missing a feature for single newlines (i.e. not paragraphs)
19:25:37 <jethr0> in phpwiki that is "%%%"
19:27:24 <araujo> dons, also, please, ping me when you cabalize hs-plugins :-]
19:27:41 <dons> it's cabalised, just not released as a new tarball
19:27:47 <dons> you need a tarball, right?
19:27:51 <araujo> dons, yeah...
19:28:12 <araujo> dons, i just don't want to make a tarball if you are gonna release one soon
19:28:56 <dons> right. I'll probabaly release a new version of fps, hs-plugins and yi around Jan 4.
19:29:15 <araujo> dons, i tweaked the non-cabalized tarball to install in the right path, so everything works fine nevertheless
19:29:25 <araujo> Good, i can wait :-]
19:29:30 <dons> ok cool.
19:36:19 <mysteriousentity> Hello. How can I write a program that repeats an action until a key is pressed?
19:36:46 <Cale> shouldn't be too hard with forkIO and an MVar
19:36:53 <dons> right
19:37:08 <Cale> I'll write a little example
19:37:16 <dons> throw an exception on a keypress, perhaps.
19:37:16 <dons> witha tryTakeMVar
19:37:41 <mysteriousentity> forkIO, MVar eh? I don't know that that is but I'll google it.
19:37:43 <jethr0> mysteriousentity, at least it's not trivial!
19:37:55 <dons> or just stick something in an MVar, as Cale is suggesting
19:38:10 <Cale> mysteriousentity: Do you need the list of results of performing the action?
19:38:10 <dons> you have a forkIO thread that writes a result into an MVar
19:38:24 <dons> meanwhile the main thread loops, polling the MVar, returning once it's full.
19:38:45 <dons> sort of the inverse of the usual scenario, where the  thread blocks until an Mvar is full
19:39:06 <mysteriousentity> Hold on, does this actually come with ghc?
19:39:10 <dons> sure.
19:39:28 <Cale> er, actually, you don't even need as much as that
19:39:30 <dons> it's maybe 2 lines of code.
19:39:38 <dons> is thaere a nice functional way?
19:39:38 <Cale> you can just kill the thread :)
19:39:44 <dons> yeah, right
19:39:53 <SamB> dons: last time I said 5, it was more like 10
19:39:56 <jethr0> nice functional way of doing pure IO?? maybe not.
19:40:20 <dons> forkIO loop ; c <- hGetChar ; killThread;  roughly.
19:40:52 <jethr0> nice approach :)
19:41:08 <dons> fillinng in the gaps: tid <- forkIO (fix $ \f -> do action >> f) ; c <- hGetChar ; killThread tid
19:41:13 <dons> s/do //
19:41:39 <Speck> IO in Haskell is not only easy, it's super great.
19:41:44 <dons> whaddya reckon, Cale?
19:41:51 <Cale> dons: looks right
19:41:56 * Speck had to dispell any rumors
19:41:58 <mysteriousentity> Thanks! This is much better than the answer I got when I asked this question yesterday.
19:42:19 <Korollary> Would you like to fill out this survey?
19:42:20 <jethr0> we gotta post that solution on a java/c++/... board and have a look at their faces.
19:42:22 <Cale> though in my test, the putStrLn's in the loop didn't stop for a while after the key was pressed
19:42:28 <Speck> dons: could you use mdo notation instead?
19:42:29 <jethr0> waiting for keypress is quite ugly in many languages!
19:42:35 <Cale> (though it might just be backed up terminal IO)
19:42:37 <dons> mdo.. oh my.
19:42:40 <Korollary> jethr0: killing the thread is not the most elegant way, though.
19:42:44 <jethr0> i know
19:42:49 <dons> Speck wins a prize if he needs to use mdo.. :)
19:43:07 <dons> killThread just throws an exception. it's clean.
19:43:17 <Speck> well it's built on top of Monad.Fix.fix right?
19:43:17 <dons> it throws a KillThread exception to the thread.
19:43:21 <Speck> which you used
19:43:23 <dons> the thread can catch it.
19:43:25 <jethr0> Korollary, but i'm sure that a "clean" version would likely be quite readable too!
19:43:39 <Korollary> jethr0: amen. Let's all press keys in glory.
19:43:40 <twb> I was wondering...
19:43:41 <dons> oh, I was thinking of recursive do.
19:43:47 <Cale> of course, you don't need to use fix if you write the loop separately
19:43:54 <jethr0> Korollary, are you mocking _me_ or haskell?
19:43:57 <Speck> dons: I thought it used fix
19:44:03 <twb> Is there somethign that can take a haskell expression and typeset it as LaTeX math code?
19:44:08 <dons> I like: repeatM_ a = a >> repeatM_ a
19:44:14 <Korollary> jethr0: Hah. I'm just messing around.
19:44:18 <jethr0> twb, what if it isn't pure math?
19:44:23 <dons> twb, lambdaTex?
19:44:24 <twb> jethr0: dunno
19:44:32 <twb> jethr0: just thinking aloud
19:44:34 <twb> dons: URL?
19:44:41 <Cale> dons: I can't believe that's not in Control.Monad already
19:44:48 <twb> http://www.cse.unsw.edu.au/~patrykz/lambdaTeX/
19:45:08 <dons> yeah, weird isn't it.
19:45:19 <Korollary> how does haskell code look typeset as math? There are no superscripts or greek symbols in it.
19:45:23 <dons> @where+ lambdatex http://www.cse.unsw.edu.au/~patrykz/lambdaTeX/
19:45:24 <lambdabot> Done.
19:45:48 <Cale> Korollary: lambda
19:45:53 <jethr0> doesn't seem to be for arithmetic, but more for pseudocode. but still quite nice!
19:46:31 <jethr0> having longer-than-one variable names in latex math mode tends not to look so nice. not even with text{} tricks
19:47:03 <jethr0> @where tex
19:47:03 <twb> dons: actually, what I was thinking of using it for is to avoid having to implement a math mode in my docutils clone.
19:47:03 <lambdabot> I know nothing about tex.
19:47:10 <Korollary> Cale: Haskell-prime should allow the lambda symbol in source files, then.
19:47:19 <Cale> Korollary: it really should
19:47:22 <jethr0> lambdabot should have a @where-search feature for substrings and the like
19:47:23 <Cale> and arrows
19:47:26 <Korollary> Cale: and arrows
19:47:47 <Cale> and unicode characters as operators/in variable names
19:47:58 <Korollary> well, that's a given.
19:47:58 <Cale> I'd like to use greek letters for type variables
19:48:03 <twb> The idea being that you give a ascii-type definition of a formula, and the typesetting is inferred.
19:48:32 <twb> (like when to use \frac and when to use /)
19:48:39 <jethr0> _|_ and T would be nice too!
19:49:05 <SamB> Haskell prime should also fix Emacs and/or nxml-mode/rng-validate-mode to support unicode properly all together
19:49:21 <twb> SamB: haskell prime?
19:49:24 <Korollary> SamB: That sounds more like an emacs problem?
19:49:38 <SamB> Korollary: well, okay, so yeah.
19:49:43 <twb> Emacs23 will be Unicode under the hood.
19:49:47 <SamB> but I don't want to be left out in the coooold.
19:49:51 <SamB> is there a 22?
19:49:55 <twb> Not yet :-)
19:50:02 <Korollary> screw emacs. Long live yi/hIDE
19:50:05 <twb> 22 is the current CVS.
19:50:14 <Korollary> and hmp3
19:50:15 <SamB> planning awfully far ahead then, aren't they?
19:50:16 <twb> Korollary: when it can read mail, let me know.
19:50:34 <Korollary> twb: ew. read email from an IDE?
19:50:38 <SamB> I can't edit XML documents with on-the-fly validation in hmp3!
19:50:38 <jethr0> wasn't emacs the one approaching PI as version number?
19:50:47 <twb> Korollary: what else would you use?
19:50:49 <SamB> jethr0: thats TeX
19:50:51 <jethr0> ayh
19:50:54 <jethr0> right
19:51:09 <dons> SamB, oh, that's sad :(
19:51:09 <SamB> I think METAFONT is approaching e or something
19:51:20 <SamB> or Yi!
19:51:26 <twb> SamB: well, there is a unicode fork in progress.  It's scheduled to be merged back in for the 23 release.
19:51:27 <SamB> or emacs with mule-ucs!
19:51:28 <Korollary> twb: I don't like using emacs for everything, although I am a emacs user as well.
19:51:28 <jethr0> could get pretty messing when approaching the limit... *loooooong* version number!
19:52:30 <twb> Korollary: I don't like it either, but what's the alternative?
19:52:40 <SamB> twb: is james clark still alive to update nxml- and rng-validate- modes to work with it?
19:52:45 <twb> Korollary: a separate mail reader that doesn't have incremental searching, etc.?
19:52:53 <twb> SamB: no idea.
19:53:25 <SamB> the email on his website is broken :-(
19:53:59 <SamB> it gives me errors and disk full messages!
19:54:44 <twb> SamB: maybe ask in #emacs after Xah leaves.
19:54:52 <Korollary> twb: what's wrong with non-incremental searching?
19:54:58 <Korollary> twb: lol
19:55:00 <twb> Korollary: it sucks.
19:55:15 <twb> incremental regexp searching, I should have said.
19:55:20 <cpatrick> Korollary: even vim and firefox isearch these days :)
19:55:34 <cpatrick> twb: nah, I don't speak fluent regexp
19:55:41 <twb> Bah.
19:55:54 <Korollary> I don't search my mail much. I don't know why.
19:56:02 <twb> cpatrick: You never took a unit on finite automata?
19:56:19 <cpatrick> twb: nah, I'm not studying CS and intend to keep it that way
19:56:30 <twb> Oh yeah, you're a math student.
19:56:46 <cpatrick> (yep.) though understanding how the regexp algorithm works is on my "todo" list
19:56:56 <twb> Which regexp algorithm?
19:57:22 <twb> Anyway, man 7 regex is all you need... :-)
19:57:42 <cpatrick> the one where they build a non-deterministic FSM and convert it to a deterministic one etc etc
19:57:50 <cpatrick> oh, I can grok basic regexp syntax
19:57:51 <twb> Ah, that stuff.
19:58:02 <twb> It's not complicated, just tedious.
19:58:25 <SamB> I can never remember which delimiters to escape and which to leave alone!
19:58:39 <twb> SamB: yeah, that's a problem with varying dialects.
19:58:43 <Korollary> SamB: I think it changes from implementations
19:58:44 <cpatrick> SamB: yup. and then there's all the perlre extensions
19:58:57 <Korollary>  from = with
19:59:00 <SamB> oh, well, I don't do a whole lot of perl
19:59:06 <SamB> Korollary: yes, it does.
19:59:16 <twb> Wossname did a scary CL implementation.
19:59:17 <SamB> even sometimes within an implementation
19:59:40 <SamB> I mean, sometimes a single implementation will support a couple of dialects...
19:59:57 <twb> "If compiled with CMUCL it outperforms Perl's highly optimized regex engine (written in C) which to my knowledge is faster than most other regex engines around."
20:00:05 <twb> http://www.weitz.de/cl-ppcre/
20:00:14 <SamB> yeah, I know about that one
20:00:39 <SamB> does it use first-class functions?
20:00:48 <twb> The first line is a defclass.
20:00:50 <SamB> or second-class, as the case may be...
20:00:53 <twb> I stopped reading after that.
20:00:57 <SamB> oh, boy.
20:01:01 <SamB> scary stuff!
20:01:12 <twb> Yeah, some CLers are addicted to OOP.
20:01:26 <SamB> and incomprehensible OOP at that!
20:01:36 <twb> incomprehensible, but powerful :-)
20:01:44 <SamB> thats the WORST part
20:01:50 <twb> Hehe
20:02:14 <SamB> you really don't want such powerful things to be at the same time incomprehensible
20:02:31 <SamB> it makes it impossible to figure out what the code is doing!
20:02:49 <twb> Saying that makes me think of CL as alien technology.
20:02:58 <SamB> stuff that messes with C-ish string implementations, that can be incomprehensible if it likes...
20:03:14 <SamB> its not like you need to understand the code to know what it is doing, after all...
20:03:16 <twb> Push the red button for eternal peace, green button makes the sun go supernova.
20:03:36 <SamB> ... only you have to code your own buttons
20:03:38 <SamB> with macros
20:04:23 * SamB wonders if he pushed the green button by mistake
20:04:37 <twb> *(!&@#NO CARRIER
20:04:43 <SamB> heh
20:04:59 <jimapple> @seen lennart
20:04:59 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
20:06:05 <dons> hmm, this works very nicely in ghci, but not when compiled.  hmm.. do t <- forkIO $ fix (action >>) ; getChar ; killThread t
20:06:10 <dons> oh well.
20:10:25 <tautologico> any gentoo users here?
20:11:12 <int-e> a few
20:11:15 * luqui raises his hand
20:11:57 <jethr0> is it possible to share a "where" over multiple function declarations?
20:12:00 <jethr0> fun 0 = 1
20:12:04 <jethr0> fun x = y
20:12:04 <tautologico> well, I believe cabal is included with ghc 6.4.1, right? then why it's not here in my installation? should I get the separate cabal package?
20:12:07 <jethr0>   where y = x
20:12:18 <dons> no. where is like a let
20:12:35 <luqui> tautologico, well, there is a separate cabal package
20:12:38 <jethr0> dons, yes, but in the AST multiple function declarations are treated as one
20:12:43 <jethr0> and they have to be adjoining, too
20:13:03 <luqui> tautologico, so it makes sense that you would get that...
20:13:05 <tautologico> yes, there is (a masked one btw), but it's supposed to be included in ghc, I believe
20:13:07 <jethr0> by rewriting the above with guards it is possible!
20:13:13 * luqui doesn't know
20:13:15 * luqui puts down his hand
20:13:19 <dons> doesn't matter. where is a local binding.
20:13:25 <jethr0> hmm, ok, thx
20:13:44 <tautologico> what the hell, I'll install it
20:13:48 <dons> @pretty main = do t <- forkIO $ fix (action >>) ; getChar ; killThread t
20:13:49 <lambdabot> #  main = do t <- forkIO $ fix (action >>)
20:13:49 <lambdabot> #            getChar
20:13:49 <lambdabot> #            killThread t
20:13:58 <dons> ah nicce. but why the '#' chars?
20:14:03 <dons> seems ugly.
20:15:07 <tautologico> dons, is it me or the emacs mode in yi is not currently working?
20:15:13 <dons> use --as=mg
20:15:17 <dons> or --as=emacs2
20:15:29 <tautologico> oh, I see... thanks
20:15:30 <jethr0> dons, i couldn't figure out a way to disable the indentation filter of lambdabot, cleanly, just for my module
20:15:41 <dons> ircPrivmsg' ?
20:15:43 <dons> I think that's it.
20:15:53 <dons> or just mapM_ (ircPrivmsg src)
20:15:57 <jethr0> ircPrivmsg doesn't filter many other things and only prints single lines
20:16:01 <jethr0> hmm
20:16:08 <dons> mapM_ ;)
20:16:31 <jethr0> but in the long run, it would also be nice to be able to refer to filters by name... but that's a design issue
20:16:39 <jethr0> didn't want to fiddle with that!
20:17:59 <jethr0> and sometimes i wish one could compare function bindings...
20:18:20 <dons> i've done the patch anyway.
20:18:27 <jethr0> np
20:19:31 <jethr0> cale has tried something with an implementation of wadlers pprint paper... maybe i'll try using those, because language.haskell.pretty is not all that pretty
20:20:03 <Cale> jethr0: you still can't seem to express what I want to :)
20:20:16 <Cale> We need a pretty printer for tabular data
20:20:42 * jethr0 doesn't get the "express what i want to" part
20:20:49 <jethr0> i'd like that!
20:21:30 <jethr0> will it be easy to transform the AST into a tabular structure?
20:22:08 <Cale> well, for things like function definitions
20:22:22 <Cale> you want to line up guards and = signs
20:22:28 <jethr0> i know that!
20:22:33 <Cale> which is basically like a table
20:22:45 <Cale> if the table is expressed nicely enough :)
20:22:57 <Pupeno> Is the -f option when using the -M option as described here: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html something newer than ghc 6.4.1 ?
20:23:02 <jethr0> i see that the _result_ is like a table. but fitting the source, i.e. the AST into a tabular form is maybe hard!?
20:23:02 <SamB> Cale: ooh! implement Lout!
20:24:30 <Cale> I was thinking that it should be possible to add something like alignmentGroup :: Doc -> Doc, align :: Doc
20:24:44 <jethr0> hmm
20:24:48 <Cale> hmm
20:24:55 <Cale> maybe need more
20:25:05 <jethr0> right now i'm not following you, but that might be because i'm in template haskell mode :)
20:25:07 <Cale> one more level
20:25:30 <Cale> well, the idea is that align is like the empty document
20:25:42 <Cale> except that it will line up with other aligns
20:25:56 <Cale> (corresponding ones in other groups)
20:27:44 <SamB> Cale: you read about Lout?
20:28:29 <Cale> SamB: yeah, a bit
20:29:12 <SamB> Cale: that actually sounds a lot like Lout to me...
20:29:12 <SamB> in some ways, at least
20:29:36 <dons> @dynamic-reload pretty
20:29:37 <lambdabot> Module "dynamic" produced error: unknown or static module
20:29:59 <dons> @quit stupid bot
20:30:26 <jethr0> huh?
20:30:26 <dons> @pretty main = do t <- forkIO $ fix (action >>) ; getChar ; killThread t
20:30:35 <lambdabot>  main = do t <- forkIO $ fix (action >>)
20:30:38 <lambdabot>            getChar
20:30:40 <lambdabot>            killThread t
20:30:42 <jethr0> *aahh*
20:30:50 <SamB> yeah.
20:31:00 <SamB> thats what I was talking about with the layout rule before...
20:31:10 <jethr0> dons, there are still some pretty pathologic cases, but i'll try to fix those over time :)
20:31:23 <dons> ok, cool.
20:31:46 <SamB> @pretty do x; y; z
20:31:47 <lambdabot> "Parse error" at column 11
20:31:52 <SamB> @pretty foo = do x; y; z
20:31:53 <lambdabot>  foo = do x
20:31:53 <lambdabot>           y
20:31:53 <lambdabot>           z
20:31:56 <jethr0> must be declaration or let
20:32:02 <dons> fair enough.
20:32:06 <dons> not just an expr?
20:32:15 <dons> youu could retry, if decls fails..
20:32:33 <SamB> see! it should use semicolons, but it can't, 'cause the pretty printing library is not smart enough to do that!
20:32:35 <jethr0> nah, language.haskell.parser needs to have a module as input, and i've work-arounded it :(
20:32:48 <SamB> because, guess what, they never thaught of trying to apply this to *HASKELL*
20:32:54 <dons> SamB, why should it use semis, if it is usind layout mode?
20:33:10 <dons> you can get explicit semsi everytime in non-layout mode
20:33:13 <dons> but that's ugly.
20:33:26 <jethr0> samb, there's a mode to force semis, but i didn't choose it!
20:33:38 <jethr0> even layouted
20:33:49 <dons> jethr0, can't you just call the expr parser, or the decl parser? or is there no such back door?
20:33:50 <jethr0> i think
20:34:09 <jethr0> don't know... i'll have another look. but for now it's working :))
20:34:38 <jethr0> officially it only has parseModule
20:35:20 <SamB> jethr0: yeah, but it can't choose between them and layout based on whether it fits horizontally or not
20:35:26 <jethr0> yup
20:35:54 <jethr0> dons, maybe i could use the parser hs-plugin uses
20:36:28 <dons> that uses two. one is language.haskell the other is hsx, the extended parser. then there's also ghc's that Lemmih packed up..
20:36:30 <SamB> jethr0: hs-plugins parses interface files, last I knew...
20:36:41 <jethr0> i mean what @eval uses
20:36:56 <SamB> doesn't that just dump the code into a file?
20:37:01 <jethr0> right, i might have a look at hsx, but that's not in standard ghc, right?
20:37:12 <SamB> you have to grab it
20:37:21 <dons> no no. @eval does no parsing.
20:37:24 <jethr0> samb, yes, but it somehow deals with expressions!
20:37:32 <jethr0> well, at some point...
20:37:43 <dons> hs-plugins uses a parser for merging plugins.
20:38:14 <dons> jethr0, I think using Language.Haskell is *fine*
20:38:29 <luqui> @pl \x y -> y >>= (\r -> x >> return r)
20:38:30 <lambdabot> (=<<) . (. return) . (>>)
20:38:37 <jethr0> :)
20:38:55 <SamB> @pretty let in (=<<) . (. return) . (>>)
20:38:56 <lambdabot>  i = let in (=<<) . (. return) . (>>)
20:38:59 * jethr0 waves his hand: "credits will do fine"
20:39:13 <luqui> "let in" ?
20:39:14 <SamB> that is just as ugly as before!
20:39:16 <SamB> fix it!
20:39:23 <SamB> luqui: empty binding list
20:39:24 <jethr0> what did you expect??
20:39:27 <dons> we're unlikely to push it hard enough to break  it often enough that the heavier dependency is worth while.
20:39:33 <SamB> I didn't think it was going to work, really...
20:39:37 <luqui> SamB, what does that buy you?
20:39:47 <jethr0> empty let, huh
20:39:53 <SamB> luqui: it saves me from having to give the expression a name
20:40:05 <luqui> oh...kay
20:40:05 <SamB> jethr0: I've never ever tried that before
20:40:12 <dons> > let in 1 + 2
20:40:13 <jethr0> while glancing over my code i just spotted a problem:
20:40:14 <lambdabot> 3
20:40:17 <SamB> I'm not sure anyone else has either
20:40:19 <dons> there you go.
20:40:20 <jethr0> @pretty letter = 10
20:40:21 <lambdabot> "Parse error" at column 8
20:40:21 <SamB> I could be the first!
20:40:29 <luqui> I see
20:40:33 <jethr0> i'm looking for prefix "let" instead of "let "
20:40:42 <jethr0> *grr*
20:40:43 * dons notes this down as an obfuscation trick.
20:40:51 <jethr0> hehe
20:41:46 <jethr0> @hoogle let
20:41:47 <lambdabot> Text.ParserCombinators.Parsec.Char.letter :: CharParser st Char
20:41:47 <lambdabot> Language.Haskell.TH.Lib.letS :: [DecQ] -> StmtQ
20:41:47 <lambdabot> Language.Haskell.TH.Lib.letE :: [DecQ] -> ExpQ -> ExpQ
20:42:01 <jethr0> hehe
20:55:26 * jethr0 just realized that one could do nice automatic tracing using template haskell *cool*
20:56:17 <jethr0> the only thing that annoys me is that there are so many parsers/ASTs for haskell out there :(
20:56:33 <elk> hmm, looks like current version of PageRegistry doesn't support multiple handlers
20:57:04 <elk> so yi plugin essentually disables commonSence and thus haskellSence
20:57:52 * elk is wondering if he has the latest versionof hIDE
20:59:32 <sieni> jethr0: choice is bad!
20:59:42 <mjl69> finally, I put together a function without peeking in my book: http://www.rafb.net/paste/results/rHC2iW51.html
20:59:46 <elk> yep, no remote changes to pull
20:59:54 <mjl69> getting the basics sort of
21:00:12 <jethr0> sieni, no, but when you want to parse a haskell file into template haskell's AST, and there's no apparent way to do so, that's unfortunate
21:00:27 <jethr0> especially since all the haskell AST essentially represent the exact same thing!
21:00:50 <jimapple> @seen lennart
21:00:51 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
21:01:26 <sieni> Maybe Haskell should have adopted an s-expression syntax after all ^_^
21:01:33 <jethr0> *g*
21:02:06 <dons> s/no apparent way/the function Haskell -> THaskell hasn't been written
21:02:11 <jethr0> walking a typed tree is actually nicer than s-expressions. someone would just have to unify the ASTs! without any severe changes, even
21:02:42 <jethr0> yes, i thought of doing it myself, but it seems like _lots_ of work and i didn't come up with a way of automating it!
21:03:09 <dons> why lots? the data types are almost identical, aren't they?
21:03:12 <jethr0> you can produce trees for the same code and they'll have almost the same structure, but the difference might make inferring similarities harder
21:03:17 <jethr0> _almost_
21:03:45 <jethr0> i guess a few hours for the basics and 20-30 hours for the whole thing
21:03:54 <jethr0> until _everything_ works flawlessly
21:04:10 <jethr0> but then they support different sets of non-standard extensions, etc
21:04:29 <jethr0> the nicer solution would be to unify them!
21:05:23 <jethr0> but the ability to use TH transparently on pure haskell modules would be awesome!
21:05:51 <jethr0> you could do stuff like whole program optimizations in "userland" :)
21:07:15 <dons> 20-30 hours!!
21:07:30 <dons> why not just write a parser for modules into TH?
21:09:40 <dons> btw, have you asked on the TH mailing list about your problem? 
21:10:40 <jethr0_> sry, stupid ISP
21:18:12 <elk> dons: so yi and haskellSence plugins are not working together yet, right?
21:22:08 <ricebowl> man that sucked
21:22:13 <ricebowl> my Windows box crashed :(
21:22:25 <jethr0_> hopefully you lost no work...
21:22:31 <ricebowl> inevitably I did
21:22:37 * ricebowl pulls out hair
21:22:48 <Cale> what are you working on?
21:23:12 <ricebowl> learning the Georgian script Mxedruli and the language, learning Russian, and various other things
21:23:26 <ricebowl> a ton of various linguistic articles on Wikipedia
21:23:34 <dons> elk, um, I thought they did. check with Lemmih
21:23:55 <dons> ricebowl, well, you know the solution to crashing windows boxes, right?
21:24:42 <dons> @where openbsd
21:24:44 <lambdabot> http://openbsd.org/
21:24:57 <ricebowl> dons - I was hoping you were going to say Linux
21:25:06 <ricebowl> because I was going to kindly point out that my Linux machine has been far less reliable ;)
21:25:26 <ricebowl> one of these days I will make it a point to construct an FBSD-based box and eventually use it for packet routing
21:25:33 <elk> dons: the PageRegister supports only one handler so yi apparently overrides commonSense
21:25:47 <ricebowl> dons - FWIW I think it was a hardware issue
21:25:51 <cpatrick> the wireless drivers on my laptop crash the machine hard whenever signal strength gets low :(
21:25:58 <elk> @seen Lemmih
21:25:59 <lambdabot> Last time I saw Lemmih was when I left #flippi, #gentoo-haskell, #haskell,
21:25:59 <lambdabot> #haskell', #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and
21:25:59 <lambdabot> #scannedinavian 4 hours, 54 minutes and 15 seconds ago, and I have missed
21:25:59 <lambdabot> 46 minutes and 36 seconds since then.
21:26:03 <dons> wow, cpatrick. that's bad bad bad
21:26:08 <ricebowl> but...after 190 days of uptime it's fairly depressing :(
21:26:09 <jethr0_> my Template Haskell tutorial is almost finished... check it out: http://www.haskell.org/hawiki/TemplateHaskellTutorial
21:26:33 <ricebowl> that's the second reboot this year, and the first was to install hardware
21:26:51 <cpatrick> dons: yeah. oh, and X segfaults when I try to do dual-head with the LCD and VGA port. however Linux seems to be best of a bad bunch
21:27:26 <cpatrick> ricebowl: my server at home has been up for ~300 days (which was when I put the UPS in :)
21:28:17 <ricebowl> cpatrick - I was hoping that this box would have run at least for another month when I would have to shut it down, anyway
21:28:54 * ricebowl is moving in a month
21:29:24 <ricebowl> technically I could carry it out with the UPS and drive over to the new place, but I don't feel like going to all that effort just for my ego
21:29:41 <cpatrick> :-)
21:31:45 <sieni> you do know that uptime and the frequency of getting laid are inversely correlated, don't you? :-)
21:32:37 <jethr0> http://dev.gentoo.org/~lewk/img/vim.gif
21:33:21 <jethr0> hehe
21:33:41 <ricebowl> sieni - does that mean that I should go back to running Win9x?
21:34:30 <soysauce> rofl, that's an awesome animation
21:34:34 <jethr0> http://www.ritsumei.ac.jp/~akitaoka/rotsnake.gif
21:34:51 <jethr0> this one's been bugging me forever... i could swear they are moving *arg*
21:34:52 * soysauce wonders if ricebowl crashed
21:35:13 <jethr0> hmm, seems so
21:35:19 <jethr0> at least he's not here to deny it!
21:35:24 <ricebowl> yeah, so it would seem
21:35:27 * ricebowl == soysauce
21:35:30 <ricebowl> just another box.
21:35:50 <jethr0> hahaha, very funny
21:36:13 <jethr0> why would you be present in a channel with two active nicks?
21:36:21 <sieni> http://www.psy.ritsumei.ac.jp/~akitaoka/donwave.gif
21:36:49 <sieni> that one moves also really violently
21:36:49 <soysauce> jethr0 - laziness
21:36:54 <jethr0> that is also very annoying, although not as bad as the snakes
21:37:05 <soysauce> jethr0 - they're 2 different boxes...sooo...I run 2 different IRC clients :p
21:37:11 <soysauce> and 3 when I'm using my laptop
21:37:23 <jethr0> yes, but why would you be chatting actively on both?
21:37:31 <cpatrick> soysauce: you need to discover screen then
21:37:36 * jethr0 is getting nausea
21:37:44 <soysauce> because I use the "reliable" box for e-mail, IM, etc., and I do some development on it too
21:37:53 <soysauce> but I do as much development on this one as well
21:38:00 <jethr0> an irc demultiplexer would be cool then :)
21:38:07 <soysauce> yeah, that would be pretty nifty
21:38:12 <sieni> jethr0: I had the snakes once as a desktop wallpaper... for two hours :-)
21:38:22 <cpatrick> sieni: wheee .. still trying to work out if that's my eyes or an animated gif .. ;)
21:38:29 <Cale> It's your eyes :)
21:38:43 <jethr0> soysauce, not that hard to write. just set up your own irc server, let a bot sit in a channel and echo everything to the world :)
21:39:06 <soysauce> jethr0 - laziness is again the key ;)
21:39:16 <jethr0> try staring at a fixed point. would have to be a pretty smart animated gif to know where you're looking :)
21:40:08 <soysauce> jethr0 - what I want to be able to do is to "move" running apps from one machine to the other
21:40:16 <soysauce> but I don't know of any system that lets you do that
21:40:19 <jethr0> ya, don't we all.
21:40:38 <Cale> If I unfocus my eyes just a bit, the effect goes away
21:40:49 <jethr0> in theory X can do it. and someone even wrote an app for it. but somehow it never was made available :(
21:41:12 * soysauce shrugs
21:41:19 <soysauce> I'm just going to write a Windows/Linux replacement
21:41:32 <soysauce> (like the other millions of junior students out there)
21:41:38 <jethr0> the other ones on this site are pretty neat too
21:42:23 <jethr0> soysauce, vmware can move application while running between hosts. without interruption
21:42:24 <cpatrick> jethr0/soysauce: cryopid ... http://cryopid.berlios.de/ - does process migration and even supports X
21:42:30 <jethr0> but that doesn't solve your GUI problem
21:42:36 <cpatrick> (written by a friend of mine, not sure if the X stuff is released yet)
21:42:40 <jethr0> no, i meant xen
21:43:11 <soysauce> cpatrick - doesn't work with networked processes
21:43:13 <jethr0> nice
21:43:30 <cpatrick> soysauce: you need the TCP Connection Passing kernel patch
21:43:30 <jethr0> how in the world do you want to serialize network state?
21:43:38 <jethr0> aaahhh
21:43:40 <cpatrick> soysauce: it definitely works with irssi even without the patch
21:43:53 <cpatrick> (since it notices the connection has been dropped and reconnects)
21:44:20 <soysauce> ah, interesting
21:46:01 <soysauce> however, it's Linux, and largely useless to me... ;)
21:46:08 <cpatrick> also somewhat frightening. e.g it can use a setuid helper to fiddle /dev/kmem to resume processes with the same PID they had originally
21:46:12 <cpatrick> soysauce: feel like porting it? ;)
21:46:39 <jethr0> cpatrick, only too bad if you have conflicts in pids :)
21:46:44 <soysauce> I think 'porting' would involve 'rewriting'
21:46:57 <soysauce> Windows isn't structured the same way at all
21:47:05 <jethr0> you don't say :)
21:47:07 <soysauce> and I doubt CryoPID is POSIX-compliant
21:47:11 <cpatrick> soysauce: quite possibly. it's less unportable than it was originally though
21:47:24 <jethr0> you could use windows alleged posix layer
21:47:52 <jethr0> after all, windows NT was posix "compatible", or something
21:48:29 <soysauce> yes, it is, but I don't think it would be possible for CryoPID to work in a POSIX-only environment.
21:48:49 <cpatrick> it uses ptrace. I'm pretty sure that's posix
21:48:51 <soysauce> POSIX makes guarantees about your environment but not its implementation
21:49:12 <cpatrick> you'd just need to fix the assembly bits that do the system call intercepting etc
21:49:18 <cpatrick> also the stuff that examines /proc
21:49:20 <soysauce> jethr0 - POSIX compliance does not mean that Win32 apps are POSIX ;)
21:49:49 <soysauce> NT can be POSIX-compliant though it isn't out of the box AFAIK
21:50:04 <soysauce> cpatrick - indeed
21:50:06 <jethr0> assembly? hopefully OS system calls aren't called in asm
21:50:16 <soysauce> jethr0 - huh?
21:50:32 <cpatrick> jethr0: it rewrites part of the victim's address space as part of the freezing space
21:50:46 <cpatrick> e.g. calling lseek as the target to find out file descriptor offsets
21:50:52 <jethr0> hmm, could still do that on /dev/mem, but i get your point
21:51:16 <jethr0> cpatrick, but you'd call lseek from C
21:51:18 <cpatrick> it does more terrifying stuff when you migrate processes from 2.6 to 2.4 (rewriting certain bits of libc IIRC)
21:51:24 <jethr0> *yuch*
21:51:43 <jethr0> that's so nasty that i wouldn't have supported it!
21:51:51 * cpatrick grins
21:51:58 <jethr0> imagine porting between gcc 2 and 3
21:52:08 <jethr0> no 2.2 and 2.4, wasn't it?
21:52:12 <jethr0> i forgot
21:52:35 <jethr0> the incompatible abi switch
21:52:55 <cpatrick> gcc 2.95 and 3.something, then again with 3.3 and 3.4. but that was only for C++ code
21:53:28 <jethr0> yes, but i guess _someone_ writes applications in c++ :)
21:54:24 <cpatrick> yeah but cryopid shouldn't depend on what language the app was coded in
21:55:25 <jethr0> huh? abi is incompatible for c++ => resulting object code can't switch between libraries!
21:55:49 <jethr0> or are we talking "linked" here?
21:55:52 <jethr0> *brrrr*
21:56:44 <cpatrick> oh, it doesn't handle differing library versions. just differing kernel versions
21:57:33 <jethr0> yes, but i am amazed it works at all. imagine all the memory mappings of libraries that have to be duplicated *brr*
21:58:51 <cpatrick> if I'm interpreting that right .. you can parse /proc/$$/maps for that. but yeah.
22:15:01 <elux> hi
22:15:01 <elux> how can i use the lhs file?
22:15:01 <Cale> elux: hm?
22:15:01 <dons> use it?
22:15:01 <elux> in terms of organizing my code in the file
22:15:01 <elux> is there a page somewhere in the haskell handbook how to use lhs properly
22:15:01 <Cale> Oh, which style of literate code are you writing?
22:15:01 <elux> no idea
22:15:01 <elux> id like to learn about that tho
22:15:01 <Cale> Either use > before code lines
22:15:01 <Cale> or use \begin{code} ... \end{code}
22:15:01 <elux> yea.. ill do that
22:15:01 <Cale> the latter being compatible with LaTeX
22:15:01 <elux> shoot
22:15:01 <elux> vim doesnt understand \begin{code} ... \end{code} for lhs files and leaves it commented
22:15:01 <elux> the syntax highlighting is correct when using >'s in front tho
22:15:01 <dons> elux, use highlighting files from haskell.org
22:15:01 <elux> for vim?
22:15:01 <dons> yes.
22:15:01 <elux> ohh awesome. where can i find em exactly?
22:15:01 <elux> nevermind found it
22:15:01 <elux> http://www.haskell.org/libraries/haskell.vim
22:15:01 <dons> ah, there's a lhaskell.vim file I wrote. let me  find it for you..
22:15:01 <elux> http://www.haskell.org/libraries/lhaskell.vim
22:15:01 <dons> it uses TeX to colour the code blocks. oh, maybe that's it.
22:15:01 <elux> that one?
22:15:01 <elux> its not very big tho
22:15:12 <dons> ftp ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/syntax/lhaskell.vim
22:15:38 <elux> thank you so much!
22:16:08 <jethr0> did i mention that TH is fun?
22:16:09 <dons> so you need to stick that in ~/vim/syntax/
22:16:16 <dons> ~/.vim/syntax
22:16:47 <elux> i dont have a ~/.vim folder
22:16:56 <dons> you make it  :)
22:16:56 <elux> i have a .vimrc and .viminfo
22:17:00 <elux> ahh i c
22:18:22 <elux> looks great!
22:18:22 <elux> thanks
22:20:45 <dons> cool
22:23:37 <soysauce> blah, it's not possible to have an unboxed array of tuples :(
22:24:18 <jethr0> unboxed tuples?
22:24:22 <cpatrick> speaking of arrays ... why is DiffArray so much slower than UArray?
22:24:34 <soysauce> jethr0 - I don't think so
22:24:45 <jethr0> neither do i
22:24:58 <soysauce> jethr0 - there has to be an instance of IArray for it
22:25:22 <dons> soysauce, try using two arrays, for the fst and snd components. perhaps.
22:25:27 <dons> or a Storable array
22:25:29 <soysauce> dons - that's what I'm doing now
22:25:31 <soysauce> it's just annoying
22:25:34 <dons> or pack them into Word64s
22:25:38 <dons> it makes sense though
22:25:44 <soysauce> Word64 isn't worth the effort
22:25:57 <soysauce> dons - it does make sense, but these data should be grouped logically together
22:26:40 <dons> the effort would be fairly low for a Storable array. depends on what you want to do though
22:26:44 <soysauce> in the C version of the code, since C lacks tuples, they were separate arrays but both part of the same data structure
22:26:57 <soysauce> well, I just want an efficient representation of the data
22:27:15 <soysauce> I have to map over it several times. Laziness doesn't make sense in my case.
22:27:38 <soysauce> it's really nitpicking since it's a small part of the program
22:27:59 <soysauce> but it annoys me a little that I can't do what I want
22:28:15 <dons> have you looked at Storable arrays?
22:28:34 <soysauce> nope
22:28:34 <dons> you can pack the data however you want..
22:28:39 <elk> @google mg editor
22:28:39 <dons> don't get annoyed, get informed.
22:28:40 <lambdabot> http://www.milligazette.com/Archives/2004/01-15Jun04-Print-Edition/011506200497.htm
22:29:04 * elk doubts it
22:29:44 <dons> elk, I'm not sure mg has a website.
22:30:21 <dons> since it's circa May 15, 1988
22:31:02 <dons> @google mg usr.bin openbsd
22:31:04 <lambdabot> http://gobsd.com/code/openbsd/usr.bin/mg/
22:31:41 * soysauce is off to bed
22:31:56 <soysauce> I probably won't bother looking at Storable arrays. I just want to finish this @#!@#! assignment.
22:31:57 <elk> ok i have found some info  - micro gnu, huh
22:32:18 <dons> use a Map then.
22:32:42 <soysauce> after that it is unlikely that I will write much code in Haskell... have too many other things to do
22:33:16 <dons> ok, i'll note that down.
22:33:24 * soysauce sighs
22:33:28 <soysauce> that wasn't an insult you know :p
22:34:31 <soysauce> but there aren't any good Haskell references available, the tools aren't spectacular, and I'm already very familiar with C. I will miss a lot of things, but I can't really see any practical, daily use for it
22:34:50 <soysauce> and it's too painful to try and keep learning
22:35:38 <dons> really, none? no spectacular tools? no practical use, eh?
22:35:42 <Korollary> There's no reason to complicate matters if you can use C..
22:36:05 * elk seems to remember when he thought he can write *any* program in BASIC
22:36:40 <dons> if you like writing 5x the amount of code, and having 10x the bugs, eh Korollary.
22:37:05 <soysauce> like I said, there are things I will miss
22:37:14 <Korollary> dons: It's not a sweeping statement. Under time pressure, nobody likes having to learn new stuff.
22:37:24 <soysauce> but fighting with the type system unsuccessfully for 5 hours is not one of them
22:37:24 <dons> true. except joelr.
22:37:56 <dons> don't fight it, you must just obey it. it's right anyway.
22:37:57 <Korollary> dons: I have no idea what joelr is up to, heh. SimonM has been incredibly helpful to him, which impresses me.
22:38:10 <Korollary> and others
22:38:11 <soysauce> dons - I'd be happy to oblige, if only I knew what I was doing wrong
22:38:32 <soysauce> Korollary - it's not time pressure. My assignment must be done in Haskell, regardless.
22:38:33 <Korollary> soysauce: You can come back to learning when you have more time and energy.
22:38:36 <Korollary> ah
22:38:37 <Korollary> oops
22:38:51 <soysauce> but I'm picking up about 5 or 6 spoken languages and working on several different programming projects
22:39:07 <soysauce> for me Haskell has taken an exorbitant amount of time and energy to make progress in
22:39:10 <Korollary> soysauce: why are you doing all those at the same time?
22:39:19 <soysauce> I don't know
22:39:36 <Korollary> soysauce: Heh. Superman!
22:39:37 <soysauce> maybe for fun...
22:40:05 <soysauce> well, I'm going to continue Spanish and Swedish, and since I started German I want to continue with that, too. I've always wanted to learn Russian, and a friend has coerced me to start Lojban.
22:40:17 <soysauce> and I'm also trying to learn Georgian
22:40:18 <Korollary> Wow...
22:40:42 <Korollary> How many languages do you speak fluently at the moment?
22:40:50 <soysauce> as for the programming projects, I've been wanting for several years to work on a toy operating system, and for that OS I plan on creating a language + compiler
22:41:04 <soysauce> just English, although some of my Latin friends try to convince me that I'm fluent in Spanish
22:41:34 <soysauce> I can hold conversation for hours, but my vocabulary isn't expansive
22:43:20 <Korollary> Well, I can guarantee you that if you learn 3 more languages, unless you allocate big chunks of time in the future for them, they'll be gone in a few years.
22:43:29 <soysauce> yep
22:44:14 <soysauce> recently I had to throw myself into projects for school, and I noticed that I was having trouble keeping pace when speaking Spanish
22:44:33 <soysauce> it's just hard to switch back and forth
22:44:40 <Korollary> Well, do you think you can spare so much time for each of these languages?
22:44:58 <soysauce> I don't know. Spanish is top priority since I'm furthest along in it, and Russian comes second on my list.
22:45:25 <Korollary> I'd say that's a big investment with an uncertain future, then.
22:45:47 <soysauce> it is, but I was thinking about moving to Argentina in a few years, so the Spanish will pay off
22:46:02 <soysauce> learning is the hardest part
22:46:21 <Korollary> Wow. Talk about uncertainty... Why move? Why Argentina?
22:46:34 <soysauce> for fun I guess
22:47:44 <soysauce> I don't want to write code for a living...I can't stand it. I love writing code, just not when I can't fix bugs.
22:48:11 <Korollary> Your own bugs?
22:48:35 <soysauce> yeah, basically
22:48:45 <soysauce> although really any bugs
22:49:54 <Korollary> Are you in your senior year?
22:49:57 <soysauce> yep
22:50:06 <Korollary> Well, that's a grim realization then, eh?
22:50:18 <soysauce> no, not really
22:50:53 <Korollary> Well, you're trained in CS but you don't want to do it.
22:51:06 <soysauce> I didn't say I didn't want to do it--just that I don't really want to work in the industry
22:51:25 <soysauce> but where I'm at now is ok
22:51:29 <Korollary> Would you be ok in academia (even though you will still write some bugs)?
22:53:04 <soysauce> writing bugs isn't what bothers me
22:53:13 <soysauce> it's writing bugs and pushing them under the rug a la Microsoft
22:53:25 <soysauce> I have thought about going into academia
22:53:37 <Korollary> ah, you're problem is not with debugging, it's with industry practices?
22:53:41 <soysauce> exactly
22:53:58 * Korollary is amazed that he too makes stupid "your/you're" mistakes...
22:54:48 <Korollary> soysauce: There are software companies whose bugs hurt only themselves...
22:55:24 <soysauce> well, there are reasonable companies out there, just not a lot of them. And there are always internal tools. etc.
22:55:32 <soysauce> but ultimately it's profit-motivated
22:55:37 <soysauce> and I'm a perfectionist
22:55:39 <Korollary> well, it's a business
22:56:50 <Korollary> so you not only have problem with stuffing customers with buggy applications, but also not fixing bug even for internal tools.
22:57:07 <soysauce> well, when it's internal usually the bugs are higher priority ;)
22:57:12 * Korollary can't write, spell, argh...
22:57:16 <palomer> hey guys
22:57:22 <Korollary> palomer: yo
22:57:23 <soysauce> at the place where I work now I helped to write such an internal tool
22:57:30 <palomer> I'm going to give a talk to my students tomorrow
22:57:33 <palomer> and I need a cool stream example
22:57:40 <palomer> something simple with a wow factor
22:57:48 <soysauce> and we maintain it when we find bugs. It's really a nightmare to maintain, but it's just a complex piece of software.
22:58:46 <soysauce> it's not bad
22:59:06 <soysauce> since we're service-based, usually we can justify fixing bugs
22:59:25 <Korollary> soysauce: If I were you, I would pursue an MS, and get my head clearer about what I want to do. Moving to Argentina and doing something other than programming is a bit too risky.
22:59:29 <soysauce> and I've at times actually put my own unpaid effort into the tool when it wasn't justifyable
22:59:39 <soysauce> why risky?
22:59:43 <soysauce> I was thinking about teaching English
22:59:47 <palomer> something a little more evolved than the fibonacci sequence
23:00:09 <palomer> anyone got any ideas?
23:00:22 <tennin> I spent my whole adolescence wanting to make video games, until I realized how much I'd come to hate games and the games industry
23:01:01 <Korollary> tennin: did you work as a game dev?
23:01:14 <soysauce> Korollary - it doesn't have to be Argentina; but I want to travel.
23:01:31 <soysauce> but since I'm nearly-fluent in Spanish already, that's an easy move
23:01:57 <astrolabe> palomer: would erastosthenes filter count as a stream example ?
23:01:58 <Korollary> soysauce: Oh, yeah. Definitely travel. It's worth the experience. Moving on the other is a whole lot harder :)
23:03:37 <palomer> astrolabe: that's a good one...but what's the quickest way to build this stream?
23:03:51 <soysauce> Korollary - yeah, I know
23:04:33 <soysauce> but being a tourist is kind've dorky
23:04:35 <Korollary> soysauce: I moved to Seattle two months ago. When somebody says "moving: fun!" my veins pop ;)
23:04:39 <soysauce> haha
23:04:50 <soysauce> well, I figure on travelling light
23:05:03 <astrolabe> palomer: some hints here http://www.cs.chalmers.se/~rjmh/Teaching/Fysiker/hugs2.html#Primes
23:05:07 <soysauce> sell all my stuff and live in basically a hole-in-the-wall sort of place
23:05:08 <tennin> Kor.: no (unless amateur team projects count) but I had friends who did
23:05:26 <soysauce> then it's easy to pack up and go on to the next place
23:05:52 <palomer> ah, I see
23:06:11 <Korollary> tennin: From what I read, they just suck the life out of you at game companies. They work harder than most people at startups, heh.
23:06:19 <palomer> and how do I build the stream of all numbers?
23:06:44 <palomer> all numbers greater or equal to 0
23:07:12 <palomer> @type hd
23:07:14 <lambdabot> Not in scope: `hd'
23:07:15 <palomer> @type head
23:07:16 <lambdabot> forall a. [a] -> a
23:07:35 <palomer> @type allNumbers = 1:(1+(head allNumbers))
23:07:36 <lambdabot> parse error on input `='
23:07:41 <palomer> > let allNumbers = 1:(1+(head allNumbers))
23:07:42 <lambdabot>  parse error on input `}'
23:07:50 <palomer> > let allNumbers = 1:(1+(head allNumbers)) in allNumbers
23:07:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:07:52 <lambdabot>   Expected type: [[a]]
23:07:52 <lambdabot>   Inferred type: [a]
23:07:55 <tennin> all real numbers?
23:08:02 <palomer> all integers
23:08:11 <palomer> and hwy couldn't that type check?
23:09:34 <soysauce> Korollary - EA people recruiting at my school vehemently denied that accusation
23:09:38 <dons> :t 1  + head ;)
23:09:39 <soysauce> but I've heard that as well
23:10:24 <palomer> dons: but I'm not adding one to head
23:10:34 <palomer> I'm adding 1 to the head of allNumbers
23:10:37 <Korollary> soysauce: It's possible for more mature companies to follow a more structured development cycle with human workhours.
23:10:51 <tennin> doesn't y need to be a list, in x:y ?
23:10:59 <palomer> oh, righto
23:11:09 <sieni> > let allNumbers = 1:(map (1+) allNumbers) in take 10 allNumbers
23:11:11 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
23:11:29 <astrolabe> palomer check page 19 http://www.cs.mu.oz.au/670/lec/presentation-fplazy,fpclass.pdf
23:11:35 <soysauce> Korollary - but still not make their deadlines, it would seem ;)
23:11:38 <dons> just what I was going to say, sieni, take 10 $ let all = 0 : map (+1) all in all
23:12:02 <rep> i hear working at game companies sucks
23:13:44 <tennin> I might be able to live with long hours etc. if I had much hope of some kind of creative satisfaction
23:14:57 <rep> i dunno
23:15:00 <palomer> astrolabe: that's good stuff
23:15:05 <Korollary> tennin: Do you get any creative satisfaction from your job now? What is it?
23:16:01 <dons> @pl \x -> Just (x, x+1)
23:16:02 <lambdabot> Just . ap (,) (1 +)
23:16:14 <dons> > take 10 $ unfoldr (\x -> Just (x, x+1)) 0
23:16:16 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
23:16:35 <tennin> working with physical and chemical simulation software
23:16:55 <astrolabe> @type unfoldr
23:16:56 <lambdabot> Not in scope: `unfoldr'
23:17:04 <dons> @type List.unfoldr
23:17:06 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
23:17:17 <tennin> not really creative satisfaction, but that's ok if I'm doing something actually useful
23:17:29 <astrolabe> dons: that's a nice function
23:17:30 <tennin> well, theoretically useful anyway
23:17:38 <soysauce> intellectual stimulation isn't a bad tradeoff.
23:18:25 <rep> what do you mean by intellectual stimulation?
23:18:31 <rep> like working on cool stuff?
23:18:37 <Korollary> Well, there are places to apply creative input in a lot of kinds of jobs. The game industry is just one of them.
23:20:12 <soysauce> rep - like doing things that require a lot of thinking
23:20:17 <soysauce> and problem solving
23:20:39 <rep> i dunno i get very tired after working on things that require me to think a lot :(
23:21:05 <soysauce> I don't...I just get very frustrated if I can't make progress
23:22:36 <tennin> I have a very hard time staying focused when that happens
23:23:16 <Korollary> It's natural. You either need help, or move on. No reason to bang your head against a wall...
23:24:03 <astrolabe> I find banging my head against a wall repeatedly is often an effective way to make progress.
23:24:20 <Korollary> astrolabe: That's twisting my semantics ! 
23:24:40 <astrolabe> Is it?
23:25:24 <palomer`> astrolabe: can you repaste the link?
23:25:26 <Korollary> astrolabe: Well, by "banging one's head against a wall" I mean a task impossible to accomplish. If you do make progress, then it was not impossible.
23:25:40 <astrolabe> What I meant is, if you don't make progress, just repeatedly trying to solve the problem can effectively help.
23:25:59 <astrolabe> Korollary.  But at the time, how do you know if it's possible or not?
23:26:17 <astrolabe> palomer: http://www.cs.mu.oz.au/670/lec/presentation-fplazy,fpclass.pdf
23:26:52 <Korollary> astrolabe: Our perceptions of what is possible may change with time, of course. And sometimes we prove ourselves wrong and succeed.
23:28:13 * soysauce wishes he understood why he was getting type errors in GHC
23:28:54 <Korollary> soysauce: Do you use any type annotations or is it all inferred?
23:29:11 <soysauce> I use type annotations on almost everything
23:29:21 <soysauce> it got to be a bit tedious in where clauses, but most of the types are inferrable
23:29:30 <soysauce> this particular error comes from using type classes
23:29:48 <Korollary> ah, probably a language lawyer question.
23:29:51 <soysauce> if I made everything explicit, then it would work. I chose, however, to generalize this to type classes
23:30:22 <soysauce> GHC swears to me that this one particular variable must be of type Word32, and I don't see why
23:30:48 <Korollary> paste it
23:30:56 <soysauce> it's lengthy, but ok
23:31:30 <soysauce> actually, give me a couple minutes; let me isolate more of the function in another definition.
23:32:15 <soysauce> @pl \((x, y), d) -> ((x-1, y-1), d)
23:32:16 <lambdabot> uncurry (uncurry (((,) .) . (. subtract 1) . (,) . subtract 1))
23:32:25 <soysauce> ah, too complex, oh well
23:32:30 <palomer> has anyone here ever heard of covariant/contravariant subtying?
23:33:08 <soysauce> yes
23:33:14 <palomer> what does it mean?
23:33:16 <soysauce> but only in the context of OOP languages
23:33:24 <palomer> yeah, what does it mean in OOP languages
23:33:25 <soysauce> it has to do with type heirarchies
23:33:39 <soysauce> well, let's say that you have classes A and B where B is a subclass of A.
23:33:51 <soysauce> let's define a useless function called self which just returns the "this" pointer
23:33:53 <Korollary> I think it came up recently regarding Java's generics
23:34:12 <soysauce> the definition for A::self might be: A *A::self() { return this; }
23:34:31 <soysauce> you would normally expect that B::self would be this: A *B::self() { return this; }
23:34:45 <soysauce> since B is a subtype of A, it is actually safe to write this: B *B::self() { return this; }
23:34:57 <soysauce> anyone expecting an A back gets it since all B's are also A's.
23:35:19 <soysauce> but if you have an object of type B or one of its subclasses, then you know that you're getting back a B
23:35:23 <soysauce> and you can extend that out
23:35:55 <soysauce> covariance is when a derived class returns a sub-type of the return value used in the parent class
23:36:38 <palomer> which isn't allowed
23:36:50 <soysauce> it is in some languages
23:36:55 <soysauce> I can't remember which, though.
23:37:12 <elk> scala ?
23:37:14 <palomer> not in java
23:37:17 <soysauce> contravariance is related; it works exactly the same way but in reverse. IIRC contravariance applies to function parameters. In a derived class, the function parameters can be more general.
23:37:38 <soysauce> A::consume(B *foo) and B::consume(A *foo)
23:37:58 <soysauce> I *think*. I forget exactly.
23:39:25 <palomer> so the method is said to be contravariant, right?
23:39:45 <ski> (co- and contra- variance is related to subtyping ..)
23:39:53 <sieni> palomer: but isn't it allowed in c++?
23:39:55 <palomer> how woud I use the adjective
23:40:03 <palomer> sieni: not sure
23:40:10 <palomer> I've stayed away from C++'s oo features
23:40:17 <palomer> you can get a surprising amount done by just using the STL
23:40:30 <soysauce> I believe it is allowed in C++, but not sure.
23:40:31 <soysauce> I can check
23:40:45 <palomer> so co/contravariant is an adjective which applies to methods
23:41:14 <palomer> or is the type system covariant?
23:41:30 <ski> no
23:41:44 <ski> type constructors can be co- or contra- variant
23:41:47 <soysauce> yep
23:41:49 <palomer> (this is a grammatical question)
23:41:55 <soysauce> both covariance and contravariance seem to work in C++
23:42:09 <palomer> what's the type constructor here?
23:42:17 <ski> 'function type' prolly
23:42:26 <soysauce> ski - how? They aren't overloadable.
23:42:28 <Korollary> C++'s virtual methods can't differ on return types.
23:42:45 <soysauce> oh, d'oh, I didn't make my methods virtual
23:42:49 <palomer> so it's covariant but not contravariant
23:43:00 <soysauce> Korollary - it would seem that they can
23:43:05 <ski> e.g. (immutable) list type is covariant in the element type
23:43:27 <Korollary> soysauce: Nope, I'm looking at a reference right now.
23:43:30 <ski> and function types are covariant in result type, but contravariant in argument type
23:43:38 <soysauce> Korollary - well, all I know is that this code compiles
23:43:47 <sieni> Korollary: which reference?
23:44:03 <palomer> ski: so a function is covariant in the result type iff... ?
23:44:13 <sieni> http://www.freshsources.com/newcpp.html
23:44:28 <sieni> That one mentions covariant return type
23:44:28 <sieni> s
23:44:35 <ski> function type *is* covariant in result type
23:44:52 <palomer> what does that mean?
23:45:12 <palomer> it means that a generalization of the result type gives a subtype of the function?
23:45:30 <Korollary> sieni: I was looking at Thinking in C++
23:45:48 <ski> (a <: b) => ((x -> a) <: (x -> b))
23:45:49 <ski> iirc
23:46:03 <ski> otoh
23:46:09 <palomer> don't you mean the other way around?
23:46:16 <ski> possibly
23:46:33 <ski> i can't remember the direction of the implication
23:46:52 <palomer> we need a judgement here
23:47:03 <sieni> Korollary: If it's an old book, then it might be that it doesn't contain everything that C++98 standard contains.
23:47:12 <ski> in any case, in 'covariant' the parts varies in same direction as the whole .. in 'contravariant' it varies in opposite direction
23:47:26 <Korollary> sieni: I also found it in the ISO 97 draft.
23:47:30 <palomer> so typeconstructor T is contravariant iff (a<b) => (T(x,a)<T(x,b))
23:47:46 <ski> no
23:48:01 <ski> (a <: b) => (T b <: T a)
23:48:07 <Korollary> ah, ok it could be covariant...
23:48:08 <Korollary> "The return type of an overriding function shall be either identical to
23:48:08 <Korollary>   the return type of the  overridden  function  or  covariant  with  the
23:48:08 <Korollary>   classes  of  the  functions.   If a function D::f overrides a function
23:48:08 <Korollary>   B::f, the return types of the functions are covariant if they  satisfy
23:48:11 <Korollary>   the following criteria:"
23:48:16 <palomer> ski: got it)
23:48:20 <ski> (or maybe s/=>/<=/ .. like i said i have trouble remembering the dir)
23:48:22 <Korollary> (sorry about pasting like that)
23:48:58 <palomer> ski:  I think you mean (a<:b) => (T a <: T b)
23:49:08 <ski> that would be covariant
23:49:32 <palomer> you said it's contravariant in the return type, right?
23:49:36 <ski> no
23:49:48 <ski> (or at least, if i said that, i meant the opposite)
23:49:48 <palomer> oh, it's covariant in the return type
23:49:52 <ski> right
23:49:59 <ski> contra in argument
23:50:18 * soysauce is off to bed this time for real
23:50:26 <soysauce> blah @ the type system
23:50:41 <palomer> so -> is covariant in the return type
23:50:42 <palomer> got it
23:51:07 <palomer> err, x->
23:51:08 <ski> a continuation (negation) type constructor would be contravariant, also
23:51:25 <ski> (like 'cont' in SML/NJ)
23:51:46 <palomer> thx
23:51:48 <palomer> gotta run!
23:51:58 <ski> (this variance is realted to functors, too ..)
23:52:36 <Korollary> ski: Are you the one who was talking to me about non-state side effects?
23:52:48 <ski> maybe
23:54:04 <ski> (wanted to discuss it ??)
23:54:08 <palomer>  wait, shouldn't we say: the type constructor a |-> x -> a  is co/contravariant in its return/parameter type?
23:54:21 <ski> palomer : indeed
23:54:27 <ski> or
23:54:30 <palomer> you said function type
23:54:35 <palomer> function type is a type constructor?
23:54:48 <Korollary> ski: I think you were going to find me some links describing what you meant.
23:54:52 <ski> 'a |-> x -> a' is 'covariant', suffices
23:55:09 <ski> palomer : a bit imprecise speech above, i admit
23:55:11 <palomer> actually, we should say something of the sort a |-> x-> a is covariant and a |-> a-> x is contravariant
23:55:36 <palomer> so when you say contravariant in its return type, we're implicitly defining a type constructor
23:55:49 <ski> (Korollary : yes .. i've been too busy and tired to hunt them down yet .. but i haven't forgotten)
23:56:15 <ski> palomer : right
23:57:43 <ski> (CT ppl would possibly say (_ -> a) is covariant and (a -> _) is contravariant (possibly with '-' (or a dot there) instead of '_'))
23:58:25 <ski> (we could day (-> a) is a section on type level, also)
