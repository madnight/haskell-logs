00:00:06 <perry-apsis> @type Control.Monad.mapM
00:00:07 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
00:00:08 <Lemmih> twb: getState is monadic.
00:00:21 <twb> Lemmih: ah, so I have to bind it first?
00:00:37 <twb> Lemmih: thanks.
00:00:43 <perry-apsis> can't next monadic expressions like that..  
00:00:51 <perry-apsis> s/next/nest/
00:00:54 <Lemmih> twb: Try: updateState succ.
00:01:05 <twb> Ooh!
00:01:12 <lispy> reading code can be really hard
00:01:26 <lispy> return (map fst $ head $ ((optimize_patchset [ps1']) ++ [[]]) , [ex1] , [ex2])
00:01:32 <perry-apsis> Lemmih: ick!
00:01:33 <lispy> that line leaves me so confused
00:01:56 <lispy> for example, what is the first parameter to map?
00:01:59 <twb> Lemmih: I get "Unresolved top-level overloading".  Is this that top-level monomorphism thing?
00:02:05 <lispy> is it fst, or something else?
00:02:32 <perry-apsis> map f v
00:02:37 <lispy> @type (++[[]])
00:02:38 <lambdabot> forall a. [[a]] -> [[a]]
00:02:48 <lispy> perry-apsis: yes, what is f?
00:02:54 <perry-apsis> @eval map (+1) [1,2,3]
00:02:55 <lambdabot> [2,3,4]
00:03:08 <lispy> perry-apsis: is it fst or fst $ head or what?
00:03:36 <perry-apsis> i'm not sure i understand the question, but :
00:03:41 <perry-apsis> @type map
00:03:42 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
00:04:01 <lispy> is that line equivalent to return (map fst (head ((optimize_patchset [ps1']) ++ [[]])), [ex1], [ex2])
00:04:11 <lispy> the $ notation is really hard to read for me
00:04:37 <perry-apsis> map (not mapM) takes a function, f, and applies it to each element of a list, and returns the result list with the old values replaced with the new
00:04:51 <twb> lispy: I think the parens would probably be harder.
00:04:58 <lispy> perry-apsis: yes, i understand map quite well ;)
00:05:02 <perry-apsis> whats optimize_patchset?
00:05:14 <lispy> perry-apsis: it's a function in the darcs source
00:05:21 <perry-apsis> lispy: as i said, i dont understand the question
00:05:43 <perry-apsis> ohhhhh
00:05:53 <perry-apsis> return (map fst $ head $ ((optimize_patchset [ps1']) ++ [[]]) ,  [ex1] , [ex2])
00:05:58 <lispy> is  return (map fst (head ((optimize_patchset [ps1']) ++ [[]])), [ex1], [ex2]) equivalent to return (map fst $ head $ ((optimize_patchset [ps1']) ++ [[]]) , [ex1] , [ex2])
00:06:04 <perry-apsis> return (map fst ( head $ ((optimize_patchset [ps1']) ++ [[]]) ,  [ex1] , [ex2]))
00:06:12 <perry-apsis> return (map fst ( head ( ((optimize_patchset [ps1']) ++ [[]]) ,  [ex1] , [ex2])))
00:06:29 <twb> What's K called again?
00:06:40 <perry-apsis> did i answer the question?
00:06:48 <lispy> twb: the problem with $ notation is that i can never tell where the closing paren goes, and i need it to parse the expression correctly in my brain
00:07:00 <twb> lispy: ah, ok.
00:07:01 <perry-apsis> looks like i said yes, but my vision may be faultyh
00:07:23 <lispy> if that's the case we're mapping fst, which makes sense
00:07:25 <lispy> thanks
00:07:31 <Saulzar> lispy, At the end of the expression
00:07:50 <twb> What are S, K, I called?
00:08:02 <lispy> lambda abstractions? ;)
00:08:18 <twb> No no, I mean what names are they bound to in haskell.
00:08:19 <perry-apsis> end of indentation or something like like..  i havent read the formal definition of haskell's indentation trick since..  umm..  errr..  1988
00:08:20 <twb> I = id
00:08:28 <Cale> K = const
00:08:38 <Cale> and there's no direct equivalent of S
00:08:40 <perry-apsis> S K and I are combinators
00:09:03 <twb> Are there direct equivalents for U and Y?
00:09:20 <perry-apsis> there are two Y's..  
00:09:32 <perry-apsis> @type fix
00:09:33 <lambdabot> Not in scope: `fix'
00:09:37 <perry-apsis> 8(
00:09:44 <perry-apsis> @index fix
00:09:45 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
00:09:45 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
00:09:45 <lambdabot> Error
00:09:55 <lispy> so, this function has type Either a b, but it appears to only ever return b
00:10:15 <perry-apsis> i dont remember what U is
00:10:21 <twb> U is like a baby Y.
00:10:37 <twb> It's an anaphoric lambda, IIRC.
00:10:50 <Saulzar> lispy, Where is it used? Could be for Error
00:10:54 <perry-apsis> though i did touch barandregt's lambda calc book earlier today 8-D
00:11:00 <twb> U f = f f
00:11:06 <twb> in untyped lambda calculus.
00:11:28 <lispy> Saulzar: what do you mean by error?
00:11:38 <Cale> you can write y f = f (y f)
00:12:18 <Saulzar> lispy, Returning errors, with the Error monad
00:12:22 <lispy> Saulzar: yeah, actually since it never calls left or right i guess the returned thingy is coming from some other function
00:12:33 <Cale> > let y f = f (y f) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
00:12:35 <lambdabot> 3628800
00:12:56 <lispy> guess i need to look at optimize_patchset
00:13:12 <lispy> oh well, that's enough coding for tonight
00:13:14 <lispy> thanks all
00:14:21 <perry-apsis> @eval let y f = f (y f) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) (100 :: Int)
00:14:22 <lambdabot> 0
00:14:26 <perry-apsis> >)\
00:14:42 <Cale> @eval let y f = f (y f) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) (100 :: Integer)
00:14:43 <lambdabot> 933262154439441526816992388562667004907159682643816214685929638952175999932
00:14:43 <lambdabot> 299156089414639761565182862536979208272237582511852109168640000000000000000
00:14:43 <lambdabot> 00000000
00:15:17 <perry-apsis> sometimes Int can be implies...
00:15:22 <perry-apsis> sometimes Int can be implied...
00:15:39 <perry-apsis> "Haskell is unsafe!  news at 11"
00:15:43 <Cale> only when it occurs in a type signature
00:15:50 * perry-apsis tries to run, but trips and falls
00:15:59 <Cale> unresolved overloading of Num types results in Integer by default
00:16:20 <perry-apsis> there are a number of library functions with Int in their type sigs
00:16:27 <Cale> yeah
00:16:28 <twb> nod
00:16:33 <twb> I had problems with that before.
00:16:36 <twb> e.g. take
00:16:48 <Cale> I actually kind of hate that, even if it is slightly faster
00:17:11 <twb> Surely it should be Integer, and later optimized to Int where possible?
00:17:39 <perry-apsis> kinda hard to prove without human assistance
00:17:41 <Cale> well, getting the compiler to determine that statically is impossible
00:17:57 <Cale> But Integer uses machine ints already as much as possible
00:17:59 <perry-apsis> impossible is a strong word
00:18:10 <Cale> It's an undecidable problem
00:18:14 <perry-apsis> Cale it does?
00:18:17 <Cale> yeah
00:18:22 <twb> perry-apsis: *is
00:18:54 <perry-apsis> oh, the representation is prolly something similar to bignum=[int]
00:18:55 <Cale> It only switches to GMP integers when values get large enough
00:19:26 <Pupeno> Good morning.
00:19:27 <perry-apsis> Cale: some subsets are decidable
00:19:29 <Cale> Prelude> :info Integer
00:19:29 <Cale> data Integer
00:19:29 <Cale>   = S# GHC.Prim.Int# | J# GHC.Prim.Int# GHC.Prim.ByteArray#
00:19:29 <Cale>         -- Imported from GHC.Num
00:19:31 <Pupeno> I have function that return IO Label l or IO EOL (end-of-labels), is there a function that given that previous function would run acumulating the Labels in a list until EOL is found, ultimately giving me IO [Label] with all the Labels ending in an EOL ?
00:20:04 * shapr boings cheefully
00:20:18 * perry-apsis blinks
00:20:50 <lispy> Pupeno: i can't think of anything to do what you want, but i bet sequence could be composed with other stuff
00:21:02 <Cale> Pupeno: are those types?
00:21:27 <lispy> could you do [IO Label] -> IO [Label]?
00:21:36 <lispy> @type sequence
00:21:37 <Pupeno> Cale: Label is a type with two contructors, Label String and EOL.
00:21:37 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
00:21:45 <lispy> oh
00:21:47 <Cale> Pupeno: ah
00:22:10 <perry-apsis> (label ~ maybe)
00:22:31 <lispy> > sequence [[1]]
00:22:32 <lambdabot> [[1]]
00:22:41 <perry-apsis> there's a whole bunch of "sequence" functions..  browse them
00:22:44 <Cale> > sequence [[1,2,3],[4,5,6],[7,8]]
00:22:46 <lambdabot> [[1,4,7],[1,4,8],[1,5,7],[1,5,8],[1,6,7],[1,6,8],[2,4,7],[2,4,8],[2,5,7],[
00:22:46 <lambdabot> 2,5,8],[2,6,7],[2,6,8],[3,4,7],[3,4,8],[3,5,7],[3,5,8],[3,6,7],[3,6,8]]
00:22:52 <lispy> > sequence [[1], [2]]
00:22:54 <Pupeno> thanks.
00:22:54 <lambdabot> [[1,2]]
00:23:13 <Cale> Pupeno: sequence won't quite cut it, because you want to cut the side effects short
00:23:40 <Cale> you could just write the loop explicitly by recursion
00:24:29 <perry-apsis> make Label the Maybe monad and nest the seqs
00:25:06 <perry-apsis> Nothing (EOL) cuts things short
00:25:44 <Cale> IO is strict though.
00:27:54 <perry-apsis> @eval [1..]
00:27:56 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
00:27:56 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
00:27:56 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
00:27:56 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
00:27:56 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
00:27:58 <lambdabot> [24 @more lines]
00:29:50 <perry-apsis> something seems wrong if he has to roll his own loops
00:31:56 <twb`> @pl \x -> [x]
00:31:57 <lambdabot> return
00:32:11 <perry-apsis> bzzzt
00:32:20 <twb`> @pl (\x -> [x]) 2
00:32:20 <lambdabot> return 2
00:32:27 <twb`> That's not right, surely?
00:32:37 <perry-apsis> depends
00:32:37 <twb`> @djinn x -> [x]
00:32:38 <lambdabot> -- f cannot be realized.
00:32:48 <Cale> > return 2 :: [Integer]
00:32:50 <lambdabot> [2]
00:33:06 <perry-apsis> return 2 :: Maybe Int
00:33:15 <Cale> > return 2 :: Maybe Integer
00:33:15 <perry-apsis> > return 2 :: Maybe Int
00:33:16 <lambdabot> Just 2
00:33:17 <lambdabot> Just 2
00:34:00 <Cale> @type return 2 
00:34:02 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
00:34:05 <perry-apsis> @type return
00:34:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
00:34:25 <perry-apsis> @type (\x -> [x])
00:34:26 <lambdabot> forall a. a -> [a]
00:34:31 <glasser> What's the arrow in the forall doing?
00:34:49 <glasser> Basically just saying that the monad can't just appear by itself, but needs to be applied to another type?
00:35:44 <perry-apsis> i'd need to look at the manual
00:37:00 <Cale> whileM p x = do v <- x; if p v then do vs <- whileM p x; return (v:vs) else return []
00:37:53 <perry-apsis> Cale: there ya go!
00:37:54 <Cale> Pupeno: see whileM which I wrote there
00:38:19 <perry-apsis> Cale: oh..  i think i've seen something like that, though
00:38:29 <perry-apsis> @index whileM
00:38:30 <lambdabot> bzzt
00:38:35 <perry-apsis> awww
00:38:54 <Cale> @hoogle (Monad m) => (a -> Bool) -> m a -> m [a]
00:38:55 <Pupeno> Cale: thank you.
00:38:55 <lambdabot> No matches, try a more general search
00:39:00 <Cale> @hoogle (a -> Bool) -> m a -> m [a]
00:39:01 <lambdabot> No matches, try a more general search
00:39:06 <Cale> @hoogle (a -> Bool) -> IO a -> IO [a]
00:39:08 <lambdabot> No matches, try a more general search
00:39:40 <perry-apsis> can you use mplus?
00:40:17 <Cale> I doubt it would be terribly useful here. IO isn't a MonadPlus
00:41:04 <perry-apsis> ok..  just that "while" seems similar
00:41:32 <Cale> and you can't use sequence, because you need to have a list of actions to begin with then, but you don't know how long that list is going to be until you execute the actions, which is impossible
00:41:41 <perry-apsis> ..  i'm confused, nm..  
00:42:58 <glasser> i wonder if you can't just use something like "repeat" with some sort of "take" like thing
00:43:05 <perry-apsis> [ Just 1, Nothing, Just 2] -~-> [1]
00:43:28 <Cale> if you don't mind running the side effects past the point where you get Nothing
00:43:35 <Cale> r <- newIORef 0
00:43:41 <Cale> let q = do {v <- readIORef r; putStrLn $ if v <= 3 then "Hello!" else "Goodbye."; writeIORef r (v+1); if v <= 3 then return (Just v) else return Nothing }
00:43:50 <perry-apsis> [ Just 1, Nothing, Just 2] -~-> Just 1 >> Nothing >> Just 2 ...
00:44:24 <perry-apsis> what function am i thinking of?  (havent looked at haskell for a couple months until now)
00:44:40 <Cale> map fromJust (takeWhile isJust) ?
00:44:41 <glasser> hmm, laziness won't help?
00:44:42 <Cale> er
00:44:54 <Cale> map fromJust . takeWhile isJust ?
00:45:15 <Cale> it certainly won't help in the case of IO
00:45:36 <perry-apsis> my memory of the nomaware tutorial feels very similar to this problem
00:45:58 <perry-apsis> are you stuck with IO?
00:46:28 <Cale> Well, you have some IO (Maybe a), and you want to run it repeatedly until you get Nothing
00:47:30 <Cale> if you do something like run it forever, and then take the results up until the first Nothing, well, you'll still never finish running the IO actions for their side effects.
00:47:52 <Cale> You have to actually weave in some check for Nothing which decides if you continue or not.
00:48:07 <perry-apsis> so lift maybe
00:48:23 <perry-apsis> (?)
00:48:50 <perry-apsis> (you know what you are doing, i don't.. i'm very rusty)
00:49:21 <Cale> hmm, perhaps you could get something out of a monad transformer
00:49:43 <Cale> but I don't think there's anything directly in the libraries right now which solves this problem
00:49:56 <Cale> Control.Monad needs some work :)
00:50:16 <Cale> There are lots of control patterns which you'd like to see there
00:50:33 <Cale> there's replicateM, but no repeatM
00:50:54 <perry-apsis> there were several odd ones in there 6 months ago when we were doing that contest site
00:51:06 <lisppaste2> Pupeno pasted "whileM, improved ?" at http://paste.lisp.org/display/15220
00:51:19 <glasser> contest?
00:51:31 <perry-apsis> spoj..
00:51:49 <Cale> Pupeno: sure, that'll work :)
00:52:19 <Pupeno> In there some conventions about where to put in one's package something like whileM ?
00:52:48 <Pupeno> like a module named Utils or something like that L
00:52:50 <Pupeno> ?
00:52:56 <Cale> Pupeno: whatever you like
00:54:23 <Cale> goodnight
00:54:56 <Pupeno> Cale: good night. Thank you.
00:59:08 <twb> Is there a way to have a "function" with free variables?
00:59:47 <twb> e.g. (\x -> f,\x -> 1 + f) where f = 2 + x
01:00:27 <glasser> You want the x from the lambdas to make sense in the where part?
01:00:38 <twb> Yes.
01:00:46 <twb> Although they are of course different xs.
01:01:16 <twb> The alternative is (\x -> f x,\x -> 1 + (f x)) where f x = 2 + x
01:02:05 <glasser> or something like (f, (1+) . f) where f x = 2 + x
01:02:21 <twb> Yes.
01:02:45 <glasser> As far as I know, the answer is no
01:03:08 <pierre-> hello
01:03:46 <twb> glasser: Oh well.  It was worth a shot.
01:12:17 <perry-apsis> gnite
01:19:43 <Pupeno> Can NewBinary (de)serialization be tested with QuickCheck ?
01:20:44 <xerox> (f *** (1+) . f)
01:26:06 <lispy> @type takeWhile
01:26:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:26:25 <lispy> ah, whileM is like a generalized takeWhile
01:26:39 <lispy> @inde takeWhileM
01:26:40 <lambdabot> bzzt
01:28:03 <Pupeno> can I create a loop Handle ? everything I put in I can get out ?
01:29:48 <rep> ah, hai bisogno di ricordarti di due valori allora
01:29:50 <rep> err
01:29:55 <xerox> heh
01:37:12 <twb> Heh.  I just noticed that verbs in English are curriable.
01:37:40 <twb> give subject indirectSubject object = ...
01:41:32 <shapr> Have you seen lojban?
01:41:45 <shapr> twb: That's a neat point, I've thought of similar stuff myself.
01:41:47 <C-Keen> the artificial language?
01:42:01 <twb> shapr: I know of it.
01:42:10 <shapr> Yeah, lojban is ... well, predicate based.
01:42:10 <twb> It looks like Welsh to me :-)
01:42:36 <shapr> lojban is sort of like lambda calculus with optional arguments and definitions with a set meaning.
01:42:41 <twb> "O coi' i dag berden" type stuff.
01:43:08 <twb> My favourite orthography at the moment is Korean.
01:43:14 <twb> Or rather, Hangeul.
01:43:41 <shapr> Here's one lojban predicat: gunka gun gu'a work x1 [person] labors/works on/at x2 [activity] with goal/objective x3
01:43:45 <shapr> @seen taral
01:43:45 <lambdabot> I saw taral leaving #haskell 1 day, 9 hours, 24 minutes and 15 seconds
01:43:45 <lambdabot> ago, and I have missed 1 minute and 22 seconds since then.
01:43:50 <shapr> Taral is much better at lojban than I am.
01:44:00 <shapr> I met him first in the lojban community some years back.
01:53:34 <twb> Do other people often do abstractions like mkFn in http://twb.ath.cx/tmp/tmp.hs ?
01:53:40 <twb> Or am I just an aberration?
01:56:26 <xerox> twb: State usually makes people `aberrate' that way :-\
01:58:50 <xerox> ...in fact there is this one:
01:58:52 <xerox> @type Control.Monad.State.modify
01:58:54 <lambdabot> forall (m :: * -> *) s.
01:58:54 <lambdabot> (Control.Monad.State.MonadState s m) =>
01:58:54 <lambdabot> (s -> s) -> m ()
01:59:12 * twb blinks
01:59:19 <twb> I don't get it.
01:59:58 <xerox> modify (u :: Int -> Int)
02:00:10 <xerox> ...somehow, but it isn't helpful in some occasions.
02:01:06 <twb> Incidentally, is there an X window manager written in haskell?
02:01:25 <twb> I tried to translate tinywm.c a while back, but it is just one big monad.
02:03:37 <araujo> Good morning!
02:43:20 <twb> How do I set the exit status?
02:50:00 <araujo> Quickly,
02:50:09 <araujo> Which one do you recommend me from these? 
02:50:09 <araujo> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
02:50:38 <araujo> One to enjoy reading while travelling
02:53:28 <gour> araujo: How to declare an imperative, although i didn't really touch monads so far..
02:54:53 <lisppaste2> Pupeno pasted "Better way to write this ?" at http://paste.lisp.org/display/15223
02:55:31 <Pupeno> Is there a better way to write that ? particularly: [oneof [elements dnsLetter]] ++ (replicate len (elements dnsLetDigHyp)) ++ [oneof [elements dnsLetDig]]
02:56:53 <araujo> Tjhanks gour 
02:57:31 <gour> araujo: let me know how you enjoyed it ;)
02:58:39 <Saulzar> Pupeno, Looks fine to me - I have no idea what "oneof" does or what monad is used, but I can understand what you're doing :)
02:58:58 <Pupeno> well, that's good.
02:59:28 <Saulzar> Hmm, actually .. that's a little strange, you're making tripples of letter, letter + hyph, letter + digit + hyph ?
02:59:52 <basti_> "whatever makes you go" I'd say...
03:00:47 <Pupeno> Saulzar: yes, a label is [a-zA-z][a-zA-z0-9-][a-zA-z0-9] (as a regexp)
03:01:32 <Pupeno> anyway, it seems I can't do io actions on quickcheck, so, I can't really use this code. :(
03:04:58 * Pupeno goes for HUnit then.
03:05:01 <Pupeno> Good night!
03:07:32 <xerox> How would you do this one:
03:07:42 <xerox> Given k sorted streams where each stream could possibly be infinite in length, describe an efficient algorithm to merge the k streams into a new stream (also in sorted order). 
03:08:32 <araujo> gour, :-)
03:08:44 <araujo> Ok, bye everyone, next to travel!!!
03:08:46 <xerox> Bye!
03:08:50 <araujo> Happy new year!
03:08:52 <araujo> :-)
03:12:17 <Saulzar> Hmm, what kind of stream xerox? (Haskell has such a construct?)
03:12:43 <xerox> Saulzar: I think Haskell lists are good enough.
03:12:54 <basti_> xerox: i think you'd need some kind of tree-like comparison (much like in a sort algorithm)
03:13:05 <sylvan> xerox, extract the heads of all streams, find the minimum, append this to the result of merging the rest of the streams (the only modified stream is the one with the minimum)
03:13:11 <flux__> xerox, algorithm for merging two streams is straight-forward, and that can easily be generalized into n streams?
03:13:15 <flux__> or is that not efficient
03:13:16 <basti_> sylvan: the tricky part is "find the minimum"
03:13:18 <xerox> sylvan: that's how I did it, in fact.
03:13:22 <sylvan> O(k)
03:13:23 <sylvan> ?
03:13:24 <xerox> basti_: is it?
03:13:28 <basti_> my point is:
03:13:35 <basti_> imagine 100000 streams with 1 datum each
03:13:41 <sylvan> you could sort
03:13:44 <sylvan> I suppose
03:13:49 <basti_> youd end up doing O(n²) comparisons
03:13:52 <xerox> sylvan: minimumBy is enough.
03:13:53 <basti_> you can do that part better though
03:14:08 <basti_> so in haskell I'd use Set and min
03:14:38 <basti_> and in every datum, memorize the stream, so that i can put the next datum in when i took one out
03:14:41 <Saulzar> Though overkill if you have just a few..
03:14:43 <xerox> Sets can't contain equal elements more than one time, right?
03:15:01 <flux__> xerox, you can zip them with a serial number or something
03:15:04 <Saulzar> Is there a multi set?
03:15:04 <basti_> xerox: well they don't need to be equal when their streams aren't ^^
03:15:12 <sylvan> you need to annotate each key with a "number" (how many of them) maybe
03:15:12 <Saulzar> Hmm
03:15:13 <basti_> but i think there's also a multiset somewhere
03:15:14 <xerox> flux__: right.
03:15:23 <xerox> Also, the streams are *sorted*
03:15:37 <flux__> so the heads of each list would be in the set, and always pick the minimum, remove it from the set, add a new value from the stream the value was from, and repeat until nothing is in the set
03:15:48 <sylvan> xerox, that's why you only take the minimum of the heads, which guarantees the result is sorted as well
03:15:52 <basti_> flux__: yea thats what i'm suggesting
03:16:03 <xerox> sylvan: and that's what I did, I wonder why picking up the Sets, tho
03:16:24 <sylvan> you wouldn't have to "recompute" the minimum part each step
03:16:31 <sylvan> since only a single elements change in the "heads" set
03:16:41 <basti_> xerox: as i said, if you have k streams with 1 element you got O(k^2) with the naive approach
03:16:50 <basti_> you should be O(k log k) though
03:16:51 <xerox> sylvan: how comes.
03:16:55 <sylvan> so you build a set of "heads" the first step, and then remove the min, and insert the next element from the stream that min came from
03:17:03 <xerox> sylvan: if you take away the minimum, you have to compute the new one.
03:17:16 <sylvan> yes, but the set can do that for you
03:17:25 <xerox> You still do it :)
03:17:25 <sylvan> you still save a lot of computations
03:17:39 <sylvan> no, because it's just a reordering, you don't do all k insertions again
03:17:41 <sylvan> just one
03:17:54 <sylvan> petter yet, use a priority queue
03:17:58 <sylvan> better
03:17:59 <xerox> Hmm.
03:18:02 <flux__> only O(log k) steps to find minimum, when normally it would be O(k)
03:18:04 <xerox> minimumBy does k insertions?
03:18:08 <rep> if you keep a heap of the heads you can find the next element of the final stream in O(log k)
03:18:17 <sylvan> minimumBy does a linear search
03:18:40 <sylvan> so have a priority queueue with the (head, stream) pair
03:18:45 <xerox> What does the Set do?
03:18:47 <rep> exactly
03:18:57 <sylvan> each step: remove minimum, and build a new (head,stream) pair from the stream associated with it, and insert
03:18:59 <sylvan> recurse
03:19:49 <xerox> What does the Set do instead?
03:19:52 <basti_> xerox: Set is a balanced tree
03:20:01 <sylvan> it can doulbe for a poor man's prioirty queue
03:20:03 <basti_> its O(log n) insert, remove and find
03:20:20 <sylvan> whereas a priority queue is O(1) for everything except one of the ops
03:20:26 <sylvan> (an optimal one at least)
03:20:28 <basti_> which one?
03:20:33 <rep> insert
03:20:37 <sylvan> depends
03:20:44 <basti_> ah
03:20:45 <sylvan> in the one I wrote deleteKey is log n
03:20:54 <rep> hm
03:21:02 <sylvan> but as long as one of them is the whole "sort in O(n log n)" is preserved
03:21:04 <xerox> how do you estimate 'log n' ?
03:21:14 <rep> estimate?
03:21:25 <xerox> 'count' ?
03:21:27 <basti_> "count digits"
03:21:54 <basti_> (log_10_x = number of digits of x)
03:22:13 <rep> because of the way heaps are made, at each level, you divide the number of elements that have to be searched by 2
03:22:22 <xerox> rep: ah, thanks.
03:23:55 <rep> xerox http://www.amazon.com/gp/product/0201485419/qid=1136028057/sr=8-1/ref=pd_bbs_1/103-6530245-0855825?n=507846&s=books&v=glance
03:24:26 <xerox> $$$
03:24:36 <rep> you just received $4500 didn't you?
03:24:51 <xerox> ...they said 'January', let me check the account.
03:25:01 <sylvan> This one is _really_ good: http://www.amazon.com/gp/product/0321295358/qid=1136028115/sr=2-3/ref=pd_bbs_b_2_3/103-7770966-3397407?s=books&v=glance&n=283155
03:26:02 <xerox> Not yet.  :(
03:27:05 <rep> it's too bad taocp doesn't talk about greedy algorithms and dinamic programming
03:27:09 <rep> dynamic
03:27:37 <rep> and NP-completeness etc
03:27:54 <xerox> And what does it talk about in THREE ENORMOUS BOOKS ?
03:28:07 <tic> bah, hardcovers... :)
03:28:09 <rep> a lot of things
03:28:13 * tic looks at his print-out.
03:30:03 <xerox> Wah.
03:30:32 <rep> i just hope he'll be able to finish the 4th volue
03:30:34 <rep> volume
03:31:25 <rep> i think it'll talk about what i mentioned earlier
04:13:48 <shapr> For whatever reason, my south park avatar is hit number 42 for 'south park' on images.google... I've used so much bandwidth this month :-/
04:15:25 * shapr boings discriminately.
04:20:31 <benny> shapr: hey
04:20:54 <shapr> y0
04:21:01 <shapr> How's code?
04:23:54 <benny> moving along.... i've started using yampa
04:26:19 <xerox> hah, searching for south park haskell...
04:26:35 <xerox> http://www.haskell.org/tishler/co_h_gal.htm
04:26:39 <xerox> wtf? let me say.
04:27:06 <benny> hm...
04:27:32 <maitscha> hallo, what is the easiest way to check if a list has duplicate entries?
04:28:47 <neologism> strip the duplicates and check if the resulkting list is the same as the original one? :)
04:29:36 <shapr> nub?
04:29:49 <xerox> > hasDuplicates = (/=) . ap id nub in hasDuplicates [1,2,2,3]
04:29:50 <lambdabot>  parse error on input `='
04:29:51 <gour> or check if list of duplicates is non-empty :-)
04:29:55 <xerox> > let hasDuplicates = (/=) . ap id nub in hasDuplicates [1,2,2,3]
04:29:56 <lambdabot> Couldn't match `[a]' against `a1 -> b'
04:29:59 <xerox> ops :)
04:31:02 <sieni> > (\x -> length x == (length $ List.nub x)) [1,2,3,4]
04:31:04 <lambdabot> True
04:31:14 <sieni> > (\x -> length x == (length $ List.nub x)) [1,2,2,4]
04:31:16 <lambdabot> False
04:33:12 <Lemmih> > not . null $ takeWhile (\x -> case x of [_] -> False; _ -> True) $ group $ sort [3,2,1]
04:33:13 <lambdabot> False
04:33:15 <Lemmih> > not . null $ takeWhile (\x -> case x of [_] -> False; _ -> True) $ group $ sort [3,2,2,1]
04:33:16 <lambdabot> False
04:33:21 <xerox> > (length &&& length . nub) >>> uncurry (/=) $ [1,2,2,3]
04:33:22 <lambdabot> True
04:33:23 <xerox> > (length &&& length . nub) >>> uncurry (/=) $ [1,2,3]
04:33:25 <lambdabot> False
04:34:10 <basti_> wtf?
04:34:12 <Lemmih> > not . null $ filter (\x -> case x of [_] -> False; _ -> True) $ group $ sort [3,2,1,1]
04:34:13 <lambdabot> True
04:34:21 <xerox> :)
04:35:09 <shapr> Lemmih: That one takes advantage of laziness too, yeah?
04:35:58 <benny> Lemmih: hi!
04:36:27 <xerox> Gotcha.
04:36:28 <xerox> > any (not . null . tail) . group . sort $ [1,2,2,3]
04:36:29 <lambdabot> True
04:36:30 <xerox> > any (not . null . tail) . group . sort $ [1,2,3]
04:36:31 <lambdabot> False
04:36:57 <xerox> dot dot dot dot dot...
04:37:12 <maitscha> i think "duplicate a = length a /= (length (nub a))" is one of the easiest to understand one.
04:37:33 <Lemmih> > let dubs = dubs' S.empty; dubs' s [] = False; dubs' s (x:xs) | S.member x s = True | otherwise = dubs' (S.insert x s) xs in dubs (cycle [1,2,3])
04:37:34 <lambdabot> True
04:37:45 <Lemmih> Hi benny.
04:38:19 <benny> Lemmih: have you considered adding small utility functions to SDL bindings?
04:38:55 <Lemmih> What small utility functions?
04:39:33 <benny> Lemmih: things like this collectEvents that i wrote:
04:39:54 <lisppaste2> benny pasted "collectEvents" at http://paste.lisp.org/display/15228
04:40:13 <xs_> > log (10^545)
04:40:15 <lambdabot> Infinity
04:40:19 <xs_> :(
04:43:27 * xerox fot another
04:43:30 <xerox> > snd . foldl (\(xs,k) x -> (x:xs, x `elem` xs || k)) ([],False) $ [1,2,3]
04:43:31 <lambdabot> False
04:43:34 <xerox> > snd . foldl (\(xs,k) x -> (x:xs, x `elem` xs || k)) ([],False) $ [1,2,2,3]
04:43:35 <lambdabot> True
04:43:44 <xerox> ...adjust for take advantage of laziness :-)
04:43:57 <xerox> Lunch.  And then run.  Have fun, and a happy new year.
04:44:18 <Lemmih> Happy new year, xerox.
04:45:44 <Lemmih> benny: If you clean it up and mail me a patch, sure.
04:47:24 <xs_> is there an efficient way to find the number of digits in an Integer?
04:47:34 <basti_> xs_: floor.log_10
04:48:09 <xs_> there's log_10 for Integer?
04:48:34 <xs_> (don't you mean ceiling?)
04:48:43 <basti_> well you could use round.floor.log_10.fromIntegral couldn't you?
04:48:51 <basti_> or
04:48:54 <xs_> no, because:
04:48:55 <basti_> @type floor
04:48:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
04:49:00 <basti_> maybe also ceiling, yes.
04:49:01 <xs_> > log (10^500)
04:49:03 <lambdabot> Infinity
04:49:04 <basti_> you dont even need the round
04:49:09 <basti_> uhm
04:49:17 <basti_> > log (10^10)
04:49:19 <lambdabot> 23.025850929940457
04:49:29 <basti_> ...?
04:49:36 <xs_> @type 10^500
04:49:38 <lambdabot> forall a. (Num a) => a
04:49:46 <basti_> > (log (10^10))/(log 10)
04:49:47 <lambdabot> 10.0
04:49:54 <basti_> what log is that?
04:49:55 <basti_> > log 10
04:49:57 <lambdabot> 2.302585092994046
04:50:04 <xs_> hm. but 10^500 :: Integer, yet log (10^500) /= 500?
04:50:06 <basti_> ah ok.
04:50:16 <basti_> xs_: 10^500 is beyond float limit.
04:50:21 <basti_> though still in double i think
04:50:26 <xs_> right.. so is there a way around that? :)
04:50:29 <xs_> hmmm
04:50:44 <xs_> seems to be out of double too.
04:50:49 <basti_> > ((fromIntegral (10^500))::Double)
04:50:51 <lambdabot> Infinity
04:50:53 <basti_> yea
04:51:11 <xs_> so there is no method for counting the digits of an Integer?
04:51:19 <basti_> besides, well, counting the digits? ^^
04:51:22 <xs_> (other than, say, unfolding into a list)
04:51:32 <xs_> i meant efficiently.
04:51:40 <basti_> how are Integers stored? not as base-256 numbers?
04:52:07 <xs_> hm, aren't they gmp ints?
04:52:11 <basti_> gmp?
04:52:24 <xs_> the gnu multi-precision integer library
04:52:32 <basti_> oh
04:52:40 <basti_> let's look up how they do it
04:54:40 <basti_> http://www.swox.com/gmp/manual/Internals.html#Internals
04:55:22 <xs_> hmm, yeah mpz_sizeinbase looks nice
04:55:29 <basti_> ok it's base k numbers
04:55:47 <twb> Aren't there problems with GPL contamination from GMP?
04:56:46 <xs_> gmp is lgpl
04:56:51 <twb> Ah, OK.
04:57:08 <twb> I remember the Lisp people are a-feared of libreadline for that reason.
04:57:20 <twb> But libreadline is GPL, not LGPL.
04:57:59 <xs_> hmm.. ghc links with libreadline.
04:58:31 <twb> It might be because programs compiled with ghc don't contain libreadline.
04:59:01 <Saulzar> is GHC GPL ?
04:59:54 <xs_> no. bsd
05:03:25 <pierre-> hello
05:04:22 <benny> Lemmih: cool, are there any other existing functions in the SDL bindings that aren't direct wrappers of one of the C SDL functions?
05:06:11 <pierre-> is there GHC port on arm architecture?
05:08:02 <Heffalump> I don't think it's working at the moment.
05:08:23 <twb> pierre-: check http://packages.debian.org/ghc6
05:08:50 <twb> No arm package listed :-(
05:09:33 <Heffalump> ARM is quite a hard platform to get decent compute power for.
05:09:41 <Heffalump> Though doing something with qemu might help.
05:09:55 <xs_> basti_: hm. seems like the best is to iteratively log_10 up to the max of double. hmm.
05:10:07 <twb> Heffalump: surely you can crossport to anything GCC supports?
05:10:27 <Heffalump> twb: yes, but then you need to bootstrap
05:10:31 <Heffalump> which always has little problems
05:10:39 <twb> Okie.
05:10:39 <Heffalump> I think some of the RTS has some assembler in it, too
05:10:52 <pierre-> :-( i has linux powered pda, and i found only hugs for it, no real compiler.
05:10:55 <Heffalump> and I think you have to fix the evil mangler even for -via-C builds
05:11:06 <twb> I don't know ghc's bootstrap process, but I can believe it's gnarly.
05:11:32 <twb> pierre-: s/has/have/
05:11:37 <basti_> xs_: no why? when you can count digits in any base, you can translate that to digits in a different base
05:11:55 <pierre-> twb: thx, my english is very bad :-)
05:12:01 <twb> pierre-: no worries.
05:12:10 <xs_> basti_: but interfacing with gmp seems like a pain.
05:12:20 <xs_> basti_: plus is very non-portable
05:12:26 <Heffalump> pierre-: you could of course try to help sort out the port.
05:12:31 <Heffalump> I believe it's not that far off working.
05:13:06 <xs_> basti_: apparently Double isn't bounded. heh.
05:13:27 <pierre-> Heffalump: and how can i help?
05:13:30 <Heffalump> what pda is it, anyway, a Zaurus?
05:13:35 <pierre-> yes
05:14:08 <Heffalump> I think the GHC page has some stuff about porting it.
05:14:11 <basti_> xs_: huh?
05:14:20 <xs_> > maxBound :: Double
05:14:21 <lambdabot>  add an instance declaration for (Bounded Double)
05:14:21 <lambdabot>   In the expression: maxBound :: Double
05:14:21 <lambdabot>   In the definition of `ual': ual = maxBound :: Double
05:14:31 <basti_> of course Double is bounded.
05:14:40 <xs_> not according to haskell.
05:14:43 <basti_> yea
05:14:45 <basti_> maybe
05:14:48 <basti_> but what does haskell know?
05:14:57 <xs_> so it would seem :p
05:18:50 <Heffalump> pierre-: http://www.haskell.org/ghc/docs/latest/html/building/sec-porting-ghc.html
05:20:24 <pierre-> Heffalump: thx
05:29:38 <Lemmih> benny: kinda, there's a couple of 'with*'.
05:33:29 <Saulzar> No, Double just goes to Infinity once sufficiently large... does that count as bounded?
05:33:45 * {Arias} Buenos dias. Good morning.
05:35:34 <benny> Lemmih: ok, i just think that the way one almost always uses SDL_PollEvents in C is with a while loop and the logic of dealing with each event inside the loop. This IMO isn't very nice style for haskell code and I think that my collectEvents function is much cleaner
05:49:31 <shapr> Man I love unicycling.
05:50:08 * shapr waits for his toes to thaw...
05:53:25 * shapr wishes for nonstop GC
05:55:31 <Heffalump> what for?
05:55:53 <tic> shapr, you should eat nonstop, not GC them.
05:56:27 <shapr> Because incremental GC will likely exploit multicores.
05:56:54 <shapr> Stop and collect sounds like a BKL.
06:05:11 <benny> hm... sorry for newbie quesiont: i have: foo :: IO [Bar] how can i reverse the resulting list?
06:05:28 <shapr> @type liftM reverse
06:05:29 <lambdabot> Not in scope: `liftM'
06:05:33 <shapr> @type Control.Monad.liftM reverse
06:05:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a]
06:05:34 <benny> i tried foo >>= liftM reverse
06:14:46 <xs_> @type \foo -> foo >>= return . reverse
06:14:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a] -> m [a]
06:16:01 <xs_> liftM f m = m >>= return . f 
06:16:38 <benny> hm... thanks
06:16:46 <neologism> I see new years' eve mood here :)
06:19:57 <Saulzar> It's already 2006 :)
06:20:05 <neologism> depends on location
06:31:24 * benny has a feeling that 2006 is gonna suck big eggs
06:31:40 <neologism> it cannot be worse then 2005
06:31:52 <basti_> well it can
06:32:04 <neologism> its hard to imagine
06:32:08 <shapr> If you're here to complain, 2006 could be worse :-)
06:32:14 <neologism> as this year was a distaster
06:32:16 <neologism> shapr: :)
06:33:51 <Saulzar> If you ask me it feels quite like 2005, though I'm more tired :)
06:34:03 <neologism> you never know in advance
06:34:35 <Saulzar> It is 2006, I can compare with 4 hours ago :P
06:34:55 <benny> anyone have any ideas how to improve the code of this function?
06:34:56 <lisppaste2> benny pasted "clean this shit up" at http://paste.lisp.org/display/15230
06:42:03 <Saulzar> Looks fine to me
06:42:25 <Saulzar> @pl collectEvents' [] >>= return . reverse
06:42:26 <lambdabot> reverse `fmap` collectEvents' []
06:45:43 <Lemmih> benny: use 'liftM reverse' instead of 'return . reverse'.
06:46:11 <Lemmih> Or even: 'return (reverse l)'
06:46:37 <Lemmih> And then document it.
06:55:39 <shapr> tromp_: ayh?
06:56:01 * shapr had an especially nutty idea yesterday...
06:56:38 <basti_> again
06:57:20 <shapr> If this one works, which I won't bet it will, it's a limited method of getting around the halting problem.
06:57:32 <audreyt> @pl \cls repr -> return (MkObject 0 cls (mkMap repr))
06:57:33 <lambdabot> (return .) . (. mkMap) . MkObject 0
06:57:45 <audreyt> mm, nicely symmetrical
06:57:48 <basti_> it can't work, then.
06:57:59 <shapr> basti_: I think it might work anyway.
06:58:28 <shapr> I've read some of the accompanying documentation, but I'd like to ask tromp_
06:58:32 <basti_> I'm just commenting
06:58:40 <basti_> not telling you what to do or not
06:58:41 <basti_> :D
06:58:53 <shapr> My idea is a simple extension of an existing method of getting around the halting problem.
06:59:10 <basti_> you mean on memory-limited machines?
06:59:27 <shapr> Basically, I think I've found a way to extend the Busy Beaver approach, but I'm not sure it's generally applicable.
06:59:49 <basti_> "approach"?
07:00:01 <shapr> @wikipedia busy beaver
07:00:01 <basti_> you mean the mental masturbation around busy beavers and haltin problems? ;)
07:00:02 <lambdabot> http://en.wikipedia.org/wiki/Busy_beaver
07:00:10 <basti_> i know what you're referring to
07:00:19 <basti_> when you know the BB number, you can solve the halting problem
07:00:23 <maitscha> hallo, i am searching a generic like comparable in java. this means all types inherited from this generic should be comparable.
07:00:53 <basti_> maitscha: elements from types among themselves or to elements of other types?
07:01:08 <shapr> basti_: Right, so I have a crazy idea about how to turn real code (or at least simple proofs) into known busy beavers.
07:01:54 <basti_> shapr: you know that BB-numbers beyond BB4 (or 5?) are unknown?
07:02:06 <maitscha> basti_: i have a function like reflexiv :: Num a => (a -> a -> Bool) -> Bool
07:02:07 <maitscha> reflexiv f = f 1 1
07:02:14 <shapr> Yup, but my idea does not require them.
07:02:42 <maitscha> but i think Num a is too much special for this function.
07:02:56 <maitscha> the function should be used for alle types which are comparable.
07:03:08 <basti_> maitscha: well there is Ord
07:03:15 <shapr> basti_: Of course, that probably makes my idea obvious now that I've said that much :-)
07:03:16 <basti_> or Eq
07:03:29 <maitscha> basti_: ord sounds good.
07:03:31 <basti_> shapr: not really, no.
07:03:54 <Heffalump> @seen arjanoosting
07:03:55 <lambdabot> I haven't seen arjanoosting.
07:04:18 <maitscha> when I use Ord or Eq I get Inferred type is not general enough
07:04:51 <basti_> maitscha: well if you define reflexiv f = f 1 1, then i'd expect a Num constraint
07:04:54 <basti_> tbh
07:05:51 <basti_> maitscha: are you a classmate of reddi?
07:08:09 <Cale> @type 1
07:08:10 <lambdabot> forall t. (Num t) => t
07:08:22 <Cale> maitscha: the Num constraint comes from that type there
07:09:32 <Cale> You won't be able to apply a function without having a value of its domain though, so it might be tricky to write a function like that which is more general.
07:10:00 <stesch> <20051231134905.GA9746@apotheon.com>:  According to Nat Torkington, the Perl source is "an interconnected mass of livers and pancreas and lungs and little sharp pointy things and the occasional exploding kidney."
07:10:37 <Cale> hehe
07:10:45 <Cale> which Perl?
07:10:53 <stesch> The one written in C.
07:11:16 <stesch> This was an answer to somebody who had problems understanding the C code of the Ruby interpreter.
07:12:58 <Cale> I don't know what posesses people to write interpreters and compilers in C. I can see the point if you're writing a C compiler, perhaps, but for anything else, C just isn't the language you're looking for.
07:13:25 <stesch> They have lex and yacc. And a book which explains the tools.
07:13:53 <stesch> And years of C history.
07:13:55 <Cale> Even so, it's quite silly :)
07:14:02 <Heffalump> what's the point if you're writing a C compiler, apart from being able to do convergence testing?
07:15:35 <Cale> Well, if you're writing a C compiler, there's probably a good reason, like you're on a new architecture which doesn't already have a C compiler, and it's nicer to keep the thing bootstrapped that way.
07:16:10 <Heffalump> true.
07:16:38 <Heffalump> though our C compiler is a cross-compiler, so that argument doesn't apply.
07:17:20 <ibid> well, writing a compiler in C for any language makes it potentially maximally portable (this holds doubly for interpreters)
07:19:44 <basti_> you could write the compiler in haskell, and compile that to C
07:21:22 <Heffalump> yeah, but .hc isn't necessary fully portable, I don't think
07:21:45 <Heffalump> in practice, anyway
07:22:03 <basti_> ^^
07:22:40 <ibid> basti_: an idea i've been toying with is writing a compiler collection in haskell that compiles both haskell and c...
07:23:45 <basti_> hmm
07:24:30 <ibid> (perhaps even by translating c into the same high-level functional intermediate language as haskell;)
07:24:38 <basti_> yes sure, it IS possible
07:24:42 <Cale> hehe, that would be interesting :)
07:25:05 <stesch> Into Compiles into Parrot Intermediate Representation. :-)
07:26:02 <ibid> but then one would probably need a "de-monadifier" pass at the HLFIL :)
07:26:36 <Cale> I'd like to see a toy OO language and a toy functional language which compile into each other by some dualisation process :)
07:27:28 <mahogny> it's sad state but if you write a program that can be used by everyone, you need a language that everyone has, and haskell isn't one of them
07:27:56 <ibid> hmm, time to go buy food
07:28:24 <Cale> mahogny: you can distribute binaries
07:29:16 <ibid> Cale: that's even less likely to work for "everyone"
07:29:22 <mahogny> Cale, yeah. that's what you usually get to do. the shit hits the fan though if you have weird dependencies. I know how many complained about my old C programs for using some libs
07:29:53 <mahogny> actually, you don't even have to link to a weird lib. it's enough to take the wrong version
07:30:14 <Cale> ibid: well, people with strange systems will probably not be too hesitant to add a strange compiler :)
07:31:06 <mahogny> it would be a good start if someone made a better toolset than mingw, so that one could even download RPMs etc on windows. windows is certainly the major problem right now
07:31:08 <stesch> So take a baseball bat and _make_ everyone use Haskell. Easy like that.
07:31:08 <ibid> Cale: well, less hesitant than taking some obscure binary from a nobody :)
07:31:52 <ibid> stesch: tsk tsk tsk, you're suggesting using imperative techniques to advance functional programming
07:33:51 <mahogny> if someone wants to advance the use of haskell, then they should consider giving us better tools to install tools and resolving dependencies, that works on all systems, not only unix
07:34:41 <ibid> mahogny: don't use operating systems with deficient install tools ;)
07:34:49 <mahogny> not only haskell has the trouble. any minory tool/lib/language has this problem
07:35:26 <mahogny> ibid, well. that's quite a lot to demand from the general public that finds it ok to even run OS' that supports viruses
07:35:46 <ibid> mahogny: yeah, but what makes you think haskellists can change that?
07:35:57 <tuomov>  actually, it's most peoples' stupidity that suppots viruses
07:36:03 <mahogny> we can't. we have to work around it
07:36:14 <tuomov> real viruses are rarer these days than in the dos days probably
07:37:33 <mahogny> well, not only. it's spooky just the fact that not even today 2005/6 we have eliminated all buffer overflow attacks that from a CS point of view is a triviality
07:37:47 <tuomov> if linux had something like outlook (maybe it has) that almost everyone used, the situation would be no different
07:38:40 <mahogny> I can agree. in this case it is the engineers fault for not taking enough care
07:40:12 <mahogny> it's not hard to figure out that this is the problem. a quick glance at thedailywtf.com should be enough :)
07:40:51 <tuomov> actually, it's the management's fault
07:41:13 <tuomov> they hire the crappy coders and give them impossible deadlines
07:41:16 <mahogny> everything always boil down to management
08:25:33 <fabs> can somebody help me?  [(floor (some_func_that_evals_to_float arg)) .. (ceiling (some_func_that_evals_to_float arg))] gives me this error:  No instance for (Integral Float)
08:25:36 <fabs>       arising from use of `floor' at Geometry.hs:50:9-13
08:25:59 <Cale> fabs: could you paste the code somewhere?
08:26:03 <Cale> lisppaste2: url
08:26:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:26:31 <fabs> alright, one moment
08:27:49 <Pupeno> Hello.
08:28:12 <Pupeno> Happy new year to those already getting it.
08:28:34 <lisppaste2> fabs pasted "geometry" at http://paste.lisp.org/display/15234
08:28:49 <tromp_>                                                                 _
08:28:50 <tromp_>  _   _                     _    _             _  _             | |
08:28:50 <tromp_>  |___|  _   _    _         | \  |  _         /   |  _   _  ,_   _
08:28:50 <tromp_>  |   | / | | \  | \  / |   |  \ | /_\ / / |  \___|//_\ / | | ` / \
08:28:50 <tromp_> \|   |/\_|/|_/_/|_/_/\_|  \|   \| \__/\_\_|     /| \__/\_|/|   \_/
08:28:52 <tromp_>      '     |    |     /|        `              ( |
08:28:56 <tromp_>            |    |     \|                        \|
08:29:52 <ibid> tromp_: #freenode-newyears is thataway --> :)
08:30:09 <fabs> Cale: the line with the mapM_ doesn't work.
08:30:20 <Cale> what's the type of draw_y_ScaleLine ?
08:30:23 <tuomov> new years' sucks.
08:31:15 <tuomov> all these festivals just mean that the grocery shops are DDOSsed on the day of the eve, and DOSsed on the next day
08:31:39 <tuomov> which is annoying
08:31:40 <basti_> yea that sucks completely about holidays
08:31:49 <basti_> oh wow it's easter, lets prepare for a war
08:34:50 * JKnecht will wait for the year of the Dog.
08:38:05 <musasabi> tuomov: of course if one skips shopping on both days, things become simple.
08:38:54 <tuomov> that already means one has to plan for it and stock food for more than two days
08:39:16 <tuomov> which is also an annoyance
08:40:49 <musasabi> mmh, point. usually we have enough dry food, so that won't be a problem.
08:42:40 <Pupeno> If I have a function that has a do inside, is it possible to return something that is not a monad (a Bool, plain Bool) ?
08:43:03 <Lemmih> That depends on the monad.
08:43:21 <Lemmih> > let x = do return () in case x of Just y -> y
08:43:22 <lambdabot> ()
08:43:56 <ibid> Pupeno: which monad are we talking about?
08:44:04 <Pupeno> What I am tring to do is do IO inside a property check of QuickCheck.
08:44:10 <fabs> Cale: I'm not quite sure what type dc has...
08:44:24 <Lemmih> Pupeno: You may wanna look at unsafePerformIO, then.
08:44:33 <Pupeno> Lemmih: thanks.
08:45:06 <fabs> Cale: but I've tried it with the list [0 .. 2] and that worked fine...
08:45:32 <fabs> just this list doesn't work: [(floor (csys_min_y co)) .. (ceiling (csys_max_y co))]
08:46:21 <Cale> fabs: yeah, I see that. Could you ask GHCi or hugs for the type of draw_y_ScaleLine?
08:46:59 <Lemmih> > [floor (1.5 :: Float) .. ceiling (2.5 :: Float)]
08:47:00 <lambdabot> [1,2,3]
08:47:28 <Cale> @type floor
08:47:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:48:11 <musasabi> Pupeno: there is no "good" solution, unsafePerformIO is a bad one.
08:48:16 <Cale> floor will convert to an Integral type, and if  draw_y_ScaleLine dc co fwidth fheight  wants something which is, say, a Float, you'll need an extra conversion
08:48:51 <Cale> try:  mapM_ (draw_y_ScaleLine dc co fwidth fheight . fromIntegral) [(floor (csys_min_y co)) .. (ceiling (csys_max_y co))]
08:48:57 <musasabi> Pupeno: how did you end up implementing the decompression with NewBinary?
08:50:30 <fabs> Cale: that worked!
08:50:52 <fabs> Cale: can you please explain this to the newbie I am?
08:51:17 <Cale> Well, can you load the code in ghci/hugs?
08:51:25 <fabs> yes. ghci
08:51:33 <Cale> try typing  :t draw_y_ScaleLine
08:51:40 <Cale> what does it give?
08:51:57 <fabs> draw_y_ScaleLine :: DC a
08:51:57 <fabs>                     -> CoordSys
08:51:57 <fabs>                     -> Int
08:51:57 <fabs>                     -> Int
08:51:57 <fabs>                     -> Float
08:51:59 <fabs>                     -> IO ()
08:52:14 <Cale> Note that the last parameter there is a Float
08:52:14 <fabs> oh, so that's how I can get to to give me the type, neat.
08:52:26 <fabs> ah... that's right.
08:52:37 <fabs> So we're converting from Int to Float
08:52:52 <goron> wxHaskell?
08:52:53 <Cale> but floor/ceiling convert to an Integral type (which Float isn't)
08:52:54 <fabs> because that list is a list of Ints.
08:53:05 <Cale> yeah
08:53:06 <fabs> ah, yeah, I get it. Thanks!
08:53:20 <fabs> goron: yes
08:53:37 <fabs> I just started using it 2 days ago ;)
08:53:57 <goron> Isn't wxHaskell a dead project?
08:54:03 <Cale> goron: ?
08:54:12 <Cale> Why do you think that?
08:54:15 <goron> Cale: no new releases.
08:54:39 <Cale> I think people are still working on it
08:54:57 <Cale> There was a release last May
08:55:03 <fabs> goron: and there's traffic on the mailing-list. Project seems active
08:55:27 <goron> fabs: ok, then it prob. isn't dead.
08:55:28 * benny likes gtk2hs better then wxHaskell :=
08:55:48 <goron> I also think gtk2hs is more supported. 
08:56:07 <goron> (and has less dependencies)
08:56:48 <goron> fabs: good luck, anyway.
08:56:57 <Pupeno> musasabi: sorry, I was away. If unsafePerformIO is a bad solution, is there a better one ?
08:58:10 <musasabi> Pupeno: not really, there is QuickCheckM, but I don't think many people have had luck with that.
08:58:25 <musasabi> shapr was doing something similar, you might want to ask him.
08:59:12 <fabs> goron: thank you.
09:00:13 <Pupeno> musasabi: I haven't implemented compression yet. I am still working on the basics although I have given some thought to it. One idea was to store some kind of offset into the data structures as I read it and each step updates the offset of the step below to have the real offset at the end. Were a pointer can ocurr I'd have a Pointer construct which would get the offset. Then I would have a decompress :: Message -> Message function. I am n
09:01:20 <musasabi> was cut off at "I am n"
09:01:36 <Pupeno> I am not sure if it'll work though.
09:02:25 <Heffalump> hi pierre- 
09:02:43 <pierre-> hi again
09:02:54 <Heffalump> did you try anything with ghc?
09:03:06 <pierre-> with arm port?
09:03:17 <Heffalump> yeah
09:03:20 <pierre-> no
09:03:28 <Pupeno> musasabi: does it sound like something that might work ? the contrary ?
09:04:08 <Heffalump> oh well :-)
09:06:47 <musasabi> Pupeno: it sounds like you will need to make changes to the Binary library, and the end result is going to look like the higher level parsing code I linked for you, if I understood you right.
09:10:23 <Pupeno> musasabi: ok. Then I'll look again at your code :)
09:23:02 <benny> how can i give preference to a specified module when an identical symbol is imported from multiple modules? so that i don't have to do ModuleName.Symbol everytime and i can just do Symbol?
09:26:21 <musasabi> import A hiding(foo)
09:26:34 <musasabi> import qualified A(foo) as SomeName
09:26:39 <musasabi> import B
09:26:57 <musasabi> where B and A both define foo and you want to give the B definition preference.
09:27:18 <musasabi> now foo -> B.foo and SomeName.foo -> A.foo
09:28:31 <audreyt> hm. I've been using mdo notation for Pugs for a week now
09:28:37 <audreyt> it still feels like magic every time I use it.
09:30:50 <musasabi> it is very nifty, when things work out :-)
09:31:37 <audreyt>     clsClass  <- newClass clsClass $ mkClassMethods "Class" [("add_method", addMethod)]
09:31:41 <audreyt>     clsScalar <- newContainerClass clsClass "Scalar" (newScalarObj clsScalar)
09:31:59 <audreyt> which all taken place in another 4-layer very sideeffectful monad
09:32:32 <audreyt> I still had not really understood how it works, except that it works :)
09:33:18 <benny> musasabi: problem is it's imported automatically from Prelude
09:34:27 <musasabi> benny: import Prelude hiding(foobar)
09:35:26 <musasabi> audreyt: yes, the underlaying machinery is much more complex, but usually it just works. There were some slides wich explained it quite well.
09:35:55 <benny> musasabi: thanks
09:36:50 <audreyt> musasabi: www.cse.ogi.edu/~magnus/mdo-callcc-slides.pdf ?
09:40:59 <musasabi> http://www.cse.ogi.edu/PacSoft/projects/rmb/mvr.pdf
09:41:11 <musasabi> http://www.cse.ogi.edu/PacSoft/projects/rmb/ contains also papers.
09:43:13 <audreyt> thanks!
09:43:21 <audreyt> @pl \(x,y) -> (x:y:)
09:43:22 <lambdabot> uncurry ((. (:)) . (:))
09:43:33 <audreyt> hm, not at all shorter
09:44:20 <musasabi> np, I think that one is simpler as it does not have the continuation cruft.
09:55:48 <lisppaste2> Pupeno pasted "unsafePerformIO, like this ?" at http://paste.lisp.org/display/15238
09:56:20 <Pupeno> I wrote a property check using unsafePerformIO, it works, but, is it ok ? any improvements ?
09:57:46 <musasabi> Pupeno: yes, that is ok, as long as serDeser does not depend on state outside the property.
09:58:06 <Heffalump> it puts the file handle back where it was?
09:58:13 <Pupeno> musasabi: it shouldn't.
09:58:17 <Heffalump> oh, bh is new
09:58:23 <Heffalump> looks ok to me
09:59:35 <musasabi> Pupeno: yes, that one is ok.
09:59:44 <Pupeno> Thank you. :)
10:29:19 <musasabi> Is there a purpose for which Chans are really good except multicasting?
10:29:52 <basti_> dataflow-style programming?
10:31:02 <musasabi> basti_: something where newtype MyChan a = MyChan (MVar ([a],[MVar a])) won't beat them?
10:31:54 <basti_> well no, why?
10:32:04 <basti_> you mean like, a multi-word-chan?
10:32:17 <musasabi> just the implementation.
10:32:24 <musasabi> it seems slow for most purposes
10:32:31 <basti_> oh
10:32:48 <basti_> hmm i think the simplicity is a major point
10:32:59 <basti_> I'd hope hardware industry would optimize for them, sooner or later
10:33:04 * basti_ grunts very softly
10:34:08 <musasabi> hmm, but the Chan is more complex than that.
10:34:35 <basti_> hmm? 
10:36:03 <musasabi> http://cvs.haskell.org/darcs/libraries/base/Control/Concurrent/Chan.hs vs e.g. Ch in http://haskell.org/hawiki/ChameneosEntry
10:38:55 <basti_> hmm
10:41:47 <basti_> STM?
10:49:03 <musasabi> the STM equivalent would be even shorter
10:49:38 <basti_> yea i used STM multicast chans as an example in my seminar talk
10:49:46 <musasabi> altough making it perform well might be harder.
10:50:31 <basti_> thats true
11:28:12 <benny> does ghc have an option for checking a souce file for errors, without compiling it?
11:28:56 <Heffalump> -E ?
11:28:57 <basti_> -E ?
11:28:59 <basti_> lol
11:29:00 * Heffalump is guessing
11:29:05 <basti_> stereo morons
11:29:05 <Heffalump> I suspect preprocessing wouldn't be enough
11:29:06 <Lemmih> -fno-code?
11:29:34 <Lemmih> --make -fno-code -no-link?
11:30:20 <benny> hm... thanks
11:31:37 <benny> a function that modifies the state of some object, like: foo :: Object -> Parameter -> Object
11:32:08 <benny> and now a function that modifies the state of some object and also returns an additional result, bar :: Object -> Parameter -> (Object, Int)
11:32:17 <benny> should it return (Object, Int) or (Int, Object) ?
11:33:11 <_Codex> benny: depends how you use fst and snd for?
11:33:29 <benny> i'm wondering if there is some sort of standard convention
11:33:31 <ski_> foo :: Parameter -> State Object ()
11:33:32 <ski_> bar :: Parameter -> State Object Int
11:33:57 * benny doesn't really understand monads yet so is avoiding them for now
11:34:21 <ski_> iirc, the internal of State uses '(Int,Object)', in this case
11:34:44 <ski_> but, there's no preferred convention, from what i know
11:36:08 <benny> ok thanks. another question: if i write all my code now in the style that i've described, will i be able to create a State wrapper or something for it later?
11:41:11 <lscd> Hi.  I'm reading YAHT, and there's an example of map: map Char.toUpper "Hello World"; it says it doesn't work in hugs due to the qualified type and to just use toUpper instead of Char.toUpper, but when I try that, I'm told that toUpper is an undefined variable; what am I doing wrong?  Hugs.Base> map toUpper "Hi world"
11:41:11 <lscd> ERROR - Undefined variable "toUpper" 
11:41:37 <Cale> benny: well, yeah -- though you might find it worthwhile to go and learn about the state monad right off (if not monads in general)
11:42:02 <benny> hm....
11:42:31 <Cale> lscd:  :also Char  seems to help
11:42:49 <benny> thanks, another question: can i have many .hs source files create a single module?
11:42:58 <Cale> lscd: I've always found hugs to be a bit strange wrt modules, so you might find ghci a bit more consistent
11:43:20 <lscd> Cale: i'd use that, but ghci isn't built by default on gentoo/amd64 when I emerge ghc :/
11:43:24 <Cale> benny: I don't think so, apart from using the C preprocessor to splice things together
11:43:42 <benny> Cale: hm.... that kind of sucks
11:44:17 <lscd> and ah, yeah; :also Char fixed it; thanks :)
11:44:33 <Cale> benny: well, you can also create a bunch of modules which a single module imports and then reexports all the definitions from
11:44:47 <benny> Cale: yeah i guess that's what i need to do
11:45:18 <Heffalump> if you have mutually recursive groups of things, you'll need mutually recursive modules too
11:45:23 <Heffalump> which can be a bit of a pain
11:46:45 <Cale> I sort of think that modules are too closely tied to files, though not permitting them to be split across multiple files seems to make sense to me. It would be nice though if multiple modules could be put in a single file, as the syntax seems to hint at that.
11:47:06 <Heffalump> yes
11:47:15 <Heffalump> that would be really useful
11:47:33 <Heffalump> I don't think the standard stops that, either
11:47:41 <Cale> It doesn't prevent it
11:47:58 * encoded invites everyone to #freenode-newyears
11:48:18 <Cale> It's just that all the existing implementations use the filesystem structure to determine where to look for modules
11:51:57 <benny> ok i have my master module called X, should i name my submodules, X.Y, X.Z?
11:52:48 <benny> hm... that doesn't seem to work
11:53:10 <Heffalump> you'll have to put them in X/Y.hs, X/Z.hs etc
11:54:21 <benny> cool
11:54:41 <benny> ouch, ghc really does use the filesystem structure :'(
12:02:06 <SamB> you are welcome to try and fix it...
12:02:49 <SamB> dunno how much success you'd have getting such a patch accepted...
12:11:30 <musasabi> jhc checks X.Y.{lhs,hs} and X/Y.{lhs,hs} for X.Y
12:29:06 <psnl> anyone done any network programming in haskell?
12:31:35 <Cale> not me, (at least nothing significant) but I'm sure some people around here have :)
12:32:30 <Cale> > map (^2) [1..10]
12:32:32 <lambdabot> [1,4,9,16,25,36,49,64,81,100]
12:32:33 <psnl> I'm just wondering if you have to use sockets if you want to open a perament connection to a host, rather than use the higher level network lib
12:33:32 <musasabi> why would you need a socket?
12:33:33 <Cale> connectTo seems to create a permanent connection
12:34:00 <musasabi> if you need permanency as in reconnecting if the connection goes down etc then you want to wrap it
12:34:09 <musasabi> but no reason not to use the highlevel api
12:34:20 <musasabi> the only thing to remember is to take care of buffering
12:35:03 <psnl> ok, cool
12:35:04 <Cale> musasabi: I think he just means permanent relative to sendTo/recvFrom, which only send/receive a single string.
12:35:15 <psnl> Cale: yeah, thats it, thanks
13:11:18 <benny> how many columns should my haskell source file have?
13:12:14 <musasabi> 4 spaces for indentation is what some people like, but it is a matter of preference.
13:12:30 <musasabi> however be careful not to mix tabs and spaces
13:12:46 <benny> i've noticed that some people use 2 spaces
13:14:24 <musasabi> yes, it is a matter of preference.
13:14:47 <musasabi> some people like red flowers other like white flowers, but which ones are better?
13:15:18 <benny> ok cool, but i meant to ask how many total columns in my textfile should i use?
13:16:27 <musasabi> Haskell doesn't care. If you use too few people will come complaining about verbose code, if you use too long lines they will come with a rope to hang you ;)
13:17:08 <musasabi> 80 was an old rule of thumb for that, but many people use sometimes longer lines if they feel it makes sense.
13:17:17 <benny> that's why i'm asking here.... so that everyone will be happy :)
13:17:26 <benny> 80 seems a bit tight
13:18:03 <musasabi> yes
13:18:38 <musasabi> there is no universal rule. If you are contributing to an existing application/library look if they have style guidelines or look at the existing source.
13:18:58 <JKnecht> a relic of tab (i.e. Hollerith 80 column cards).
13:20:02 <lscd> I generally try pretty hard to stick to 80-char or less lines, but I'm not a haskeller [yet]
13:20:04 <benny> if i decide i want more then 80 then how many should i go for?
13:20:30 <lscd> JKnecht: and 80-character text consoles; I still use those at times
13:20:49 <JKnecht> the green screens got it from tab.
13:21:34 <lscd> JKnecht: yeah; it's just a (minor) reason to stick to the convention; more people probably use 80-char screens than punchcards 
13:22:57 <JKnecht> You'd think with it's layout some Haskell package would have text flowing capabilities. I tend to like longer lines, at least 120 or more.
13:24:04 <lscd> hmm, is that typical of haskell code / a common view among haskellers [120+ char lines]?
13:24:35 <JKnecht> And tabs probably still around someplace; especially maybe on some AS400 whose owners go back to system 3.
13:24:50 <JKnecht> albeit in virtual form.
13:25:41 <JKnecht> lscd: no, just my pref. Like to get as much in a screen as possible.
13:35:30 * SamB likes to stay below 80... he likes to have a lot of windows on the screen at once
13:38:10 <JKnecht> yeah, actually for Haskell I think that's more appropriate. Also short lines tend to be more associated with terseness than verbosity, consistent with Haskell aesthetic.
13:39:22 <benny> "Haskell aesthetic" ?
13:41:35 <SamB> also, think of the savings in filesize (due to less indentation)
13:41:53 <JKnecht> right, maybe even that of FP languages generally where concision and terseness are implicit. Long lines work better though in the Algol-like langs (for me anyway).
13:43:31 <lispy> SamB: same here, regardless of language
13:44:02 <lispy> but code editors like visual studio and xcode encourage long lines since they open so wide and don't let you know what column you are in
13:48:48 <JKnecht> bottom line is I think other than what layout contexts speced imply when using layout sensitivity, should be left to (reasonable) personal pref.
13:53:01 <psnl> what does $ do?
13:53:09 <benny> @type ($)
13:53:10 <lambdabot> forall b a. (a -> b) -> a -> b
13:53:29 <Lemmih> f $ b = f b
13:54:21 <Lemmih> > lines $ "hello\n" ++ "world\n"
13:54:23 <lambdabot> ["hello","world"]
13:54:29 <Lemmih> > lines ("hello\n" ++ "world\n")
13:54:30 <lambdabot> ["hello","world"]
13:55:15 <SamB> JKnecht: well... there are these things called "projects"
13:55:19 <SamB> so moderation is good too
13:56:18 <psnl> Lemmih: thanks
13:56:28 <Lemmih> Hi lscd. Nice to see you in #haskell.
13:56:43 <Korollary> happy new year eastern eu
13:57:27 <Lemmih> @localtime Korollary 
13:57:28 <JKnecht> SamB: Agreed. And second order moderation too to prevent mediocrity :)
13:57:29 <lambdabot> Local time for Korollary is Sat Dec 31 13:54:58 2005
14:03:00 <benny> hm... um happy new year to me i guess :\
14:03:30 <ibid> happy new year :)
14:07:32 <psnl> any guesses as to what to do when ld returns errors?
14:11:54 <benny> psnl: paste them :)
14:12:16 <psnl> to here?
14:12:57 <benny> yeah, or pastebin if they are more then 3 lines
14:14:25 <psnl> http://pastebin.com/485650
14:14:47 <psnl> can you compile a haskell module without a main method?
14:15:42 <benny> looks like you need -package flag
14:16:13 <benny> yeah, ghc -c
14:16:26 <SamB> psnl: yes, but it needs a module name besides Main
14:16:52 <psnl> thanks, seems to work now
14:34:11 <SamB> @index <<
14:34:12 <lambdabot> Text.Html
14:34:49 <SamB> @index >>
14:34:50 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
14:34:50 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
14:34:50 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
14:34:59 <SamB> @type (<<)
14:35:00 <lambdabot> Not in scope: `<<'
14:35:10 <SamB> @index =<<
14:35:11 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
14:35:11 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
14:35:11 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
14:44:06 <palomer> anyone here used PArrows?
14:44:18 <benny> palomer: what's that?
14:44:28 <palomer> it's an arrows based parser
14:45:07 <benny> ghc has had builtin support for arrows parsing for quite a while
14:45:39 <benny> oh
14:45:54 <benny> oops
14:46:51 <palomer> how long of a while?
14:47:01 <musasabi> palomer: I have used it at times ;)
14:47:14 <palomer> musasabi: does it have left recursion?
14:50:57 <musasabi> p = char 'a' >>> (p <+> char 'b') works fine.
14:51:43 <musasabi> b  = b <+> char 'b' causes problems
14:52:15 <palomer> something like: expression = application | lambda,  application = expression ' ' expression
14:52:41 <palomer> expression = application | lambda | variable
14:57:05 <musasabi> palomer: that seems ambigous
14:57:42 <palomer> how so?
14:58:27 <palomer> it's the standard lambda calculus grammar
14:59:15 <musasabi> "a b c" == (Application (Var "a") (Application (Var "b") (Var "c")), and "a b c" == Application (Application (Var "a") (Var "b")) (Var "c")
14:59:55 <palomer> oh, good point
15:00:02 <palomer> expression is left associative
15:01:26 <musasabi> well if you tell it that then it is quite straightforward to simply tell that the first component is Expr - Application, thus killing the left recursion.
15:02:03 <palomer> so application = application ' ' expression | expression
15:02:10 <palomer> that works, right?
15:02:54 <musasabi> application = sepBy1 ' ' expression ?
15:03:42 <palomer> sepBy1?
15:05:45 <palomer> wait, that's still ambiguous
15:06:47 <palomer> application = application ' ' expression | atom, atom = lambda | variable
15:07:02 <palomer> no, wait, still ambiguous
15:07:35 <Cale> well, after the sepBy1, you get a list of expressions, which you can associate however you like
15:07:44 <palomer> what's sepBy1?
15:08:02 <Cale> provided that it's possible to determine where the expressions start and end unambiguously
15:08:18 <musasabi> the same as parsec.
15:09:16 <Cale> (sepBy1 p sep) parses one or more occurrences of p, separated by sep, and returns a list of values returned by p.
15:09:43 <palomer> application = application ' ' atom, atom = lambda | variable
15:09:46 <palomer> there, not ambiguous anymore
15:10:09 <palomer> I don't mind factoring my grammar to include associativity by hand
15:10:16 <palomer> Cale: would this work using parsec?
15:10:47 <musasabi> palomer: the style of combinator parsing is against explicit recursion.
15:10:48 <Cale> probably, yeah
15:12:05 <SamB> well. not much more so than Haskell is.
15:12:36 * benny is glad to report that so far it seems that haskell is indeed 2006 compliant
15:12:44 <SamB> heh
15:12:49 <lscd> i second that
15:12:52 <SamB> do you even use time?
15:12:58 * SamB does not often
15:13:00 <musasabi> so one does not say "A = A , basecase | basecase" but rather "A = sepBy basecase (char ',')"
15:14:37 <SamB> well probably you'd fold over the list
15:14:48 <SamB> unless you just wanted the list
15:19:34 <palomer> and why is it not recommended to use explicit recursion?
15:21:45 <SamB> because it is ugly!
15:21:52 <SamB> which is to say, combinators rule
15:23:02 <palomer> what does sep stand for?
15:23:18 <musasabi> also explicit recursion makes analyzing the grammar harder
15:25:10 <SamB> seperated
15:25:38 <SamB> musasabi: that is the same thing as "is ugly", at a more formal level
15:25:44 <palomer> oh, and what and what does the 1 stand for?
15:25:56 <SamB> (potentially)
15:26:42 <musasabi> palomer: the 1 variants of the combinators match "one or more"
15:26:46 <SamB> it means it will parse at least one of the things that are seperated by something
15:27:13 <musasabi> palomer: e.g. many p matheches zero or more occurences of p, while many1 p matches one or more occurences of p
15:27:44 <palomer> ugh, explicit recursion doesn't work in haskell
15:28:09 <palomer> err, in parsek
15:28:10 <SamB> palomer: say what?
15:28:13 <SamB> it does.
15:28:21 <musasabi> > ones = 1 : ones
15:28:22 <lambdabot>  parse error on input `='
15:28:28 <musasabi> > let ones = 1 : ones in ones
15:28:30 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
15:28:30 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
15:28:30 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
15:28:30 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
15:28:30 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
15:28:32 <lambdabot> [23 @more lines]
15:28:35 <musasabi> now, it works.
15:28:40 <palomer> application = do {x<-application;                 space;                 z<-term}
15:28:44 <palomer> this loops infinitely
15:28:53 <SamB> well duh
15:29:02 <palomer> so  I have to use sepBy1
15:29:05 <SamB> the first thing it does is call itself unconditionally
15:29:28 <palomer> yeah
15:29:30 <palomer> which sucks:O
15:29:36 <palomer> does PArrows have this problem?
15:29:54 <monochrom> application = do {z<-term;                 space;                 x<-application}
15:29:55 <SamB> if you don't want to factor it the other way, you need to use combinators that are already factored that way
15:30:05 <monochrom> That is explicit recursion and it will not loop.
15:30:07 <palomer> like sepBy1
15:30:21 <palomer> monochrom: but it makes application right associative
15:30:25 <monochrom> So, I'm saying you're extremely imprecise.
15:30:59 <musasabi> palomer: so use sepBy1 + fold to get whatever associativeness you want
15:31:20 <monochrom> All top-down descent parsers have this problem.
15:31:37 <palomer> is PArrows top-down descent?
15:31:48 <SamB> what do you think?
15:32:02 <palomer> I don't know, never used it
15:32:43 * palomer wonders how I could ask the compiler what type it infered for an expression
15:32:55 <musasabi> palomer: PArrows can be compiled into not top-down descent (but the code rarely made sense), but then the analysation pass will have to give up and use top-down recursive pattern when you use explicit recursion ;)
15:33:01 <SamB> palomer: is it buried deeply?
15:33:13 <musasabi> palomer: like :t in ghci?
15:33:44 <palomer> SamB: deely enough
15:33:48 <palomer> musasabi: yeah, but this is for ghc
15:33:57 <palomer> and I want the type of a piece of code
15:34:08 <SamB> well...
15:34:21 <SamB> short of adding a pragma...
15:34:34 <SamB> ... I have no idea
15:34:40 <monochrom> load it up in ghci anyway, then :t
15:34:41 <musasabi> palomer: I usually add a bogus type signature and then look at the error.
15:34:51 <musasabi> monochrom: that does not work.
15:35:14 <SamB> monochrom: what part of "buried deeply" evades you?
15:35:24 <palomer> now now, no need to get nasty
15:35:35 <palomer> we should add a ?? operator to ghc
15:36:01 <SamB> how about {-# TRACETYPE -}
15:36:08 <SamB> er.
15:36:11 <SamB> forgot a #.
15:36:31 <musasabi> for now the type error route works quite well
15:36:42 <musasabi> it is not pretty, but for practical purposes it server well
15:37:07 <monochrom> I misread.
15:38:02 <palomer> http://www.rafb.net/paste/results/6JImzL92.html <--still goes into a wacky loop
15:39:00 <earthy_> haskelly happy new year for the mainland europeans!
15:39:10 <earthy_> and best wishes for those still waiting to get there :)
15:39:28 <musasabi> palomer: change the order of variable and application in expression.
15:39:40 <SamB> waiting? whats to wait for?
15:39:59 <monochrom> local time
15:40:09 <palomer> musasabi: but why would it go into a loop?
15:40:20 <palomer> musasabi: sepBy1 should fail and everything is ok
15:40:35 <SamB> no, I mean, it will come whether we wait or not
15:40:43 <palomer> musasabi: still no go
15:40:57 <monochrom> typeString = ... <|> do x <-typeString  -- whee!
15:41:08 <palomer> http://www.rafb.net/paste/results/0QF3TZ53.html <--still n ogo
15:41:12 <palomer> monochrom: but I never call typeString
15:42:34 <musasabi> palomer: usually when writing a parser you test each small component and then combine them.
15:42:53 <musasabi> palomer: thus you will know immediately if something does not work.
15:43:59 <palomer> well, application "a b" doesn't work as well
15:46:08 <palomer> and (sepBy1 variable "a b") returns [Variable "a"]
15:46:46 <palomer> which is very strange
15:47:11 <monochrom> How deterministic is Parsek, esp. when it comes to <|> ?
15:47:31 <palomer> oh, that's because I picked shortest result
15:47:47 <palomer> longestResult returns [Variable "a",Variable "b"]
15:48:02 <palomer> monochrom: try by default
15:48:38 <monochrom> I am a bit worrying about expression = ... <|> application; application = sepBy1 expression space.
15:50:09 <palomer> yay, it works
15:50:19 <monochrom> What changed?
15:50:24 <palomer> yeah, sepBy1 tries expression
15:50:30 <palomer> which, in turn, tries application
15:50:36 <palomer> I made it like so:
15:51:14 <palomer> application = (sepBy1 term space) , term = lambda <|> variable <|> do{char '('; x<-expression; char ')'; return x}
15:52:03 <palomer> btw, what do we do when we have to parse expressions with + - * / ?
15:52:42 <SamB> palomer: various things
15:52:50 <monochrom> Something along the line of sepBy1 term (char '+')
15:53:21 <SamB> you can use chain[rl]1?
15:53:35 <palomer> what does that do?
15:53:46 <palomer> @hoogle stateT
15:53:47 <lambdabot> Control.Monad.State.StateT :: StateT s m a
15:53:47 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
15:53:47 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
15:53:49 <monochrom> Where can I read about parsek?
15:54:11 <palomer> monochrom: there's not much to read, it's really just parsec with try by default (saves typing) and other small things
15:54:47 <SamB> does it still have the fantastic error handling?
15:55:03 <monochrom> Ah, so "x <|> y" in parsek becomes "try x <|> try y" in parsec?
15:55:14 <palomer> monochrom: yeah
15:55:18 <SamB> monochrom: there is no point in the try y...
15:55:29 <Cale> It's ReadP with a parsec-like interface
15:56:53 <monochrom> I am still trying (hehe) to understand the recent problem.  So suppose you use "lambda <|>  variable <|> application" upon "b".  It would seem to me that "variable" would succeed and therefore "application" would not be considered.
15:57:19 <palomer> monochrom: sure
15:57:36 <monochrom> So now I don't understand why the program looped.
15:57:59 <palomer> actually, no, it doesn't do that
15:58:13 <palomer> monochrom: I think it's because it's trying to find other possible parses
15:58:14 <monochrom> Ok, hehe.
15:58:17 <palomer> and it'll pick the longest one
15:58:52 <palomer> or shortest ones
15:59:07 <palomer> parsek accepts ambiguous grammars, and will parse all possible parses
15:59:08 <palomer> methinks
15:59:41 <monochrom> So you see why I want all the fine prints of parsek.  Apparently we don't know its semantics at all.
16:00:41 <palomer> the documentation is sparse
16:00:57 <palomer> you'll have to read the 10 line comment on top of the source
16:02:30 <Lemmih> Happy new year and good night, #haskell!
16:03:04 <Cale> I'm pretty sure it's just like ReadP.
16:04:24 <palomer> hrm, I still prefer the parser generators and lexical analyzers
16:05:33 <monochrom> top-down descent parsers have their infinite loops to debug.
16:05:47 <monochrom> parser generators have their "shift-reduce conflicts" to debug.
16:05:50 <palomer> I'm not sure how to deal with newlines, spaces and tabs with parsek
16:07:28 <monochrom> Personally, I understand infinite loops (programming 101), but I don't understand shift-reduce conflicts.
16:07:35 <musasabi> night, Lemmih
16:07:39 <palomer> monochrom: you don't?
16:07:50 <monochrom> I don't.
16:08:15 <palomer> ok, you can think of the parser as generating these lists
16:08:33 <palomer> at each point in the computation, it can do two things:
16:08:38 <monochrom> Parsec has "oneOf".  oneOf "abc" will accept 'a' or 'b' or 'c' and return which one it is.  Perhaps Parsek has a similar thing.
16:08:55 <palomer> collapse the list(reduce) or tag on something to the list (shift)
16:09:08 <Cale> monochrom: yep, it does
16:09:16 <Cale> http://www.cs.chalmers.se/ComputingScience/Research/Functional/MultiLib/koen/Parsek.hs
16:09:33 <dons> happy new year #haskell
16:09:48 <palomer> so, say you have [expression,op*,expression], it will collapse to expression
16:09:56 <palomer> or, rather, [expression]
16:10:38 <palomer> since we always shift on the right, we always collapse on the right
16:10:47 <palomer> monochrom: is this clear?
16:11:03 <monochrom> Parsek has "spaces" too.  I think that's what you want.
16:11:39 <palomer> dons: happy new year
16:11:52 <palomer> dons: any luck on the yi input speedup?
16:12:04 <palomer> it's really the only thing stopping me from using yi
16:12:12 <Cale> lambdabot should generate fanfare every hour
16:12:38 <palomer> does parsec have a parser for "1 or more spaces, tabs or newlines"?
16:12:40 <monochrom> Makes sense so far.
16:13:27 <Cale> palomer: 'spaces'
16:13:33 <monochrom> I guess "space; spaces" will do.  spaces = skipMany space.
16:13:34 <palomer> so, let's parse 2 + 3 * 4 using the standard recursive grammar 
16:13:38 <Cale> palomer: actually, that's zero or more
16:14:14 <monochrom> Oh haha, there's skipMany1 too, I guess you can skipMany1 spaces
16:14:21 <monochrom> err skipMany1 space
16:14:33 <palomer> space includes newlines?
16:14:39 <Cale> yeah
16:14:44 <palomer> and tabs
16:14:48 <Cale> yep
16:14:48 <palomer> now you tell me
16:14:53 <dons> palomer, not yet. but it's on my todo list. 
16:15:01 <palomer> but still, I don't like having (many1 space) everywhere in my grammar
16:15:09 <monochrom> Yes.  To be precise, space = satisfy (isspace).  isspace is defined in Char.
16:15:12 <Cale> parseTest (do spaces; char 'a') "\n\t \n a"
16:15:16 <Cale> that succeeds :)
16:15:41 * palomer can't believe spaces is zero or more
16:15:52 <palomer> spaces = many space ?
16:16:10 <monochrom> skipMany space.  Doesn't keep or return the actual spaces.
16:17:01 <phys_rules> happy new year people ;)
16:17:03 <monochrom> If I wanted "2+3" and "  2   +3" to be treated the same, I would appreciate spaces = skipMany space, rather than skipMany1 space.
16:22:10 <palomer> monochrom: good point
16:23:03 <monochrom> 00t, Ubuntu can get me files on my "windows network" at home, I just have to click open a few things.  I'm happy.
16:23:23 <Cale> gnome is getting good at that these days
16:23:34 <palomer> http://www.rafb.net/paste/results/0I1cTV68.html
16:23:38 <wilx> Hardly :/
16:23:43 <palomer> here's what the Let grammar looks like
16:23:48 <palomer> let production
16:23:58 <palomer> quite ugly:O!
16:24:11 <monochrom> It's kind of important because I have downloaded (painstakingly) eclipse on another computer (windows) and want to copy it over the network to my Ubuntu laptop.
16:24:30 <basti_> np: Kirlian Camera - Eclipse
16:25:42 <palomer> is there a standard mini haskell programming language one can play around with?
16:25:59 <monochrom> Heh yeah that's a long one.
16:26:09 <benny> don't see how you could minimize haskell any more than it already is
16:26:45 <musasabi> haskell is quite large.
16:27:14 <palomer> one that can be implemented in a day
16:27:15 <benny> lots of it is syntax sugar related?
16:27:16 <palomer> for students
16:27:20 <musasabi> palomer: data + top level value definitions + no classes ?
16:27:55 <musasabi> no record syntax either or anything complex.
16:28:28 <palomer> yeah, really easy syntax
16:29:08 <musasabi> source = many def; def = data | val; data = 'data' many1 (constructor >> many type); val = name '=' expr
16:29:33 <SamB> standard?
16:29:39 <SamB> why would there be a standard?
16:29:44 <musasabi> or just use lambdacalculus
16:30:24 <palomer> by standard I mean ubiquitous
16:30:44 <SamB> this sort of thing is rarely ubiquitous...
16:32:00 <palomer> miniML is pretty ubiquitous for sml
16:33:59 <palomer> pfft, parsek doesn't give an error when it gives up
16:34:51 <palomer> is there a parser for a - b (strings of a minus strings of b)
16:35:57 <dons> wow, STM shows up on the openbsd journal.
16:37:54 <dons> hmm, current temp: 40.4°
16:39:15 <musasabi> F/C?
16:39:41 <dons> C! :)
16:40:01 <basti_> australians suck.
16:40:16 <palomer> basti_: here here!
16:40:18 <musasabi> well?
16:40:33 <musasabi> dons: ouch, sounds quite painful
16:41:08 <palomer> I remember when I was a first year student, I was always wondering why we don't simply define the whole grammar in terms of BNF
16:41:12 <palomer> ie get rid of tokens
16:41:16 <palomer> today I found out.
16:41:45 <palomer> (the silly comp sci teachers told me it was because of performance, pish posh!)
16:42:14 <SamB> it might be nice to do it both ways, when possible.
16:42:40 <SamB> of course, then you'd need some kind of formal anaylsis to make sure they were equivalent
16:42:56 * palomer votes parsek off the island
16:43:15 <SamB> palomer: good job! it has no error messages.
16:43:24 <palomer> yeah
16:43:26 <palomer> seriously
16:43:40 <palomer> aww man, this means I have to go back to parsec
16:44:21 <SamB> and?
16:44:41 <palomer> well, I have to change my code and add try everywhere
16:44:53 <SamB> everywhere?
16:44:59 <palomer> everywhere I have <|>
16:45:13 <SamB> why do you need to do that?
16:45:36 <palomer> well, I don't have that many <|> lying around
16:45:43 <palomer> SamB: because or else it wouldn't make sense
16:46:00 <palomer> expression = try lambda | try application | try variable | try letP | try fun
16:46:13 <palomer> imoff!
16:46:36 <SamB> I betcha you can do better than that...
16:52:46 <palomer> what if have try c = try a <|> b, a = do {char '('; try e}
16:52:56 <palomer> so ( gets eaten up but then e fails
16:52:58 <palomer> will it try b?
16:53:30 <SamB> ?
16:55:28 <palomer> it tries a, then it tries e, fails on e
16:55:34 <palomer> will it then try b?
16:55:53 <SamB> whats b?
16:56:06 <palomer> c = try a <|> b
16:56:28 <SamB> anyway, the point is...
16:56:57 <palomer> is there a combinatorial library for creating a lexical analyzer?
16:56:58 <SamB> why do you want to parse parentheses at two different places?
16:57:13 <palomer> SamB: I'm only parsing parentheses in a
16:57:37 <palomer> like, parsec is to happy what <blah> is to alex
16:59:27 <SamB> Lexers?
16:59:57 <palomer> never heard of it
17:00:41 <Cale> you could use parsec
17:01:04 <palomer> to create a lexer?
17:01:06 <SamB> would b be able to parse anything with parens in anyway?
17:01:07 <Cale> yeah
17:01:21 <palomer> SamB: I don't know what b does, this is a hypothetical question
17:01:28 <Cale> just don't introduce backtracking, and produce a stream of tokens.
17:01:38 <SamB> hypothetical questions of this kind are useless
17:01:54 <palomer> I want to know if try propagates
17:02:47 <SamB> no...
17:02:56 <SamB> I'll show you exactly what try does
17:06:06 <lisppaste2> SamB pasted "what try does" at http://paste.lisp.org/display/15246
17:07:47 <palomer> I don't understand that:O
17:08:27 <SamB> yeah, me either.
17:10:12 <SamB> basically it sticks a finger into the input list at that point and then if its arg fails parsing but consumes something, it resumes parsing there...
17:18:03 <palomer> what's the haskell equivalent to a makefile?
17:18:16 <SamK> what do you msg lambdabot to get it to talk to you?
17:18:29 <dons> anything.
17:18:30 <monochrom> You don't need "try" everywhere.  Take lambda<|>variable for example.  lambda starts with char '\\'; variable starts with letter.  Please behave like try.
17:18:52 <palomer> ok, in certain cases I don't need try
17:19:04 <palomer> but it's easier (and doesn't cost anything) to just put it everywhere anyways
17:19:31 <monochrom> No, there is a reason to refrain from try, naming error messages.
17:19:41 <monochrom> err s/naming/namely
17:20:37 <monochrom> Suppose you use lambda<|>variable upon "\\x -> 1".  The error message will be clear and specific.  In a supposedly lambda expression something bad happens in the body.
17:21:16 <monochrom> But if you use (try lambda <|> try variable) then the error message will also say "or maybe it's a bad variable, I don't know which case it is".
17:21:47 <palomer> good point
17:22:48 <palomer> ghc keeps telling me that compliation IS NOT required
17:22:52 <palomer> even when it obviously is
17:23:19 <SamB> try certainly costs something
17:23:34 <SamB> try profiling for retainers...
17:25:50 <dons> use -no-recomp palomer, but probably you're doing something weird.
17:26:23 <benny> anyone know about MissingH?
17:26:35 <SamB> clock problems?
17:26:47 <SamB> benny: it is a collection of things that were missing
17:26:54 <benny> SamB: is it useful?
17:27:01 <SamB> probably!
17:27:12 <SamB> they were also noticed and wanted by *someone*...
17:29:01 <palomer> how do I export a datatype and all of its constructors?
17:30:06 <SamB> Datatype(..)
17:30:17 <SamB> same for importing
17:30:59 <SamB> also works for typeclasses and their methods
17:59:56 <palomer> hrm
18:00:06 <palomer> how does happy know which production is the top level production?
18:03:29 <wilx> In yacc/bison it is defined by %start non_terminal_symbol
18:07:38 <Cale> palomer: The %name directive takes an optional second parameter which specifies the top-level non-terminal which is to be parsed. If this parameter is omitted, it defaults to the first non-terminal defined in the grammar.
18:37:02 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
18:37:02 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
18:37:02 --- names: list (clog_ CosmicRay cjb ex__nor ski Pupeno nnunley_ pediddle lisppaste2 monochrom mjl69 binary42 mauke SamB psnl cmeme lscd fabs sproingie pesco wilx Philippa Nioate Twigathy jwp resiak kpreid_ Nomius carp pepegg Lokadin cjs tessier glasser wolverian audreyt wli clog tewk takuan mahogny cbus ibid Cale Khisanth sieni shapr lambdabot cjs__ integral kpk eno-away neologism spamsch chucky ex_nor djw Trixsey|Laptop palomer benny Debolaz Lor cmm musasabi)
18:37:02 --- names: list (johs borism Lunar^ dany2k JohnMeacham dv Iome ValarQ earthy_ kzm goodchilde C-Keen _shawn Chilli boegel kala__ astrolabe JKnecht stesch juhp sylvan noj tic Azmo drbean dhpeterson tuomov gdsx cpatrick kolmodin emu pejo Matt-W dcoutts_ jlouis seafood Ferret cooz alch` Heffalump tumm rep WillKW norpan cathper_ Spark SlowByte xerox cods lispy ricebowl flux__ ulfdoz svens cognominal Lemmih fatbrain gzl tic|school tromp_ eivuokko moonlite magagr)
18:37:02 --- names: list (gaal Igloo dcoutts samx CLxyz thedward dons Wallbrak1r kosmikus Korollary nik_ jp-autark arguile mattam AtnNn sethk lennart_ skylan eyck jiing ksandstr)
18:45:13 <palomer> @hoogle getContents
18:45:14 <lambdabot> Prelude.getContents :: IO String
18:45:14 <lambdabot> System.IO.getContents :: IO String
18:45:14 <lambdabot> System.IO.hGetContents :: Handle -> IO String
18:46:41 <Cale> Remember not to apply hClose to a handle to which you've applied hGetContents.
18:47:45 <palomer> how does alex know to ignore white spaces?
18:50:20 <Cale> It knows to ignore white space?
18:51:34 <palomer> yeah
18:51:59 <palomer> 5           +                    8
18:51:59 <palomer> CExp1 (Plus (Term (Factor (Int 5))) (Factor (Int 8)))
18:52:05 <palomer> that's from the standard alex example
18:53:34 <Cale> Is there a rule that matches whitespace?
18:54:02 <Cale> $white+ ; or some such
18:54:09 <palomer> http://www.rafb.net/paste/results/FOk4ly77.html
18:54:23 <palomer> ah yes, there is
18:54:28 <Cale> yeah, that first rule matches whitespace
18:54:36 <palomer> so that's what white meant:P
19:02:46 <palomer> what does the %token directive do?
19:03:08 <palomer> in happy
19:03:44 <palomer> syntactic sugar?
19:03:51 <Cale> The %token directive is used to tell Happy about all the terminal symbols used in the grammar. Each terminal has a name, by which it is referred to in the grammar itself, and a Haskell representation enclosed in braces. Each of the patterns must be of the same type, given by the %tokentype  directive.
19:03:59 <palomer> where do you get this stuff:o
19:04:01 <Cale> http://www.haskell.org/happy/doc/html/sec-directives.html :)
19:04:14 <palomer> but, erm ,what's the point of %token
19:04:47 <palomer> (still don't get it)
19:04:56 <Cale> To give a mapping between terminals in the grammar and Haskell values.
19:05:47 <palomer> ah
19:14:00 <Cale> lisppaste2: url
19:14:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:14:32 <lisppaste2> Cale pasted "Parsec lexer" at http://paste.lisp.org/display/15248
19:15:25 <palomer> oh my, you're right
19:15:30 <palomer> parsec is ideal for lexing
19:15:38 <palomer> you should put this on the wiki
19:16:04 <palomer> imoff!
19:16:06 <palomer> happy new year
19:16:08 <Cale> later
19:16:12 <Cale> happy new year
19:38:33 <m3ga> anyone care to answer a beginner question?
19:39:47 <m3ga> i'm working from the Haskell for C programmers tutorial
19:39:52 <m3ga> it has :
19:40:05 <m3ga> type Mass = Double
19:40:07 <m3ga> type Pos = (Double, Double, Double)
19:40:12 <m3ga> type Obj = (Mass, Pos)
19:40:28 <m3ga> Now how do I construct an Obj?
19:40:31 <m3ga> I've tried:
19:40:37 <m3ga> a = (Mass 1.0, Pos (1.0,  1.2, 1.1))
19:41:08 <m3ga> which is sort of ocaml like,but ghc doesn't like it.
19:41:44 <benny> a = (1.0, (1.0, 1.2, 1.1))
19:41:56 <Cale> oh
19:42:08 <Cale> type just defines type synonyms
19:42:19 <Cale> data Mass = Mass Double
19:42:31 <Cale> data Pos = Pos Double Double Double
19:42:42 <Cale> then you could write
19:42:44 <m3ga> benny: that doesn't work : parse error on input `='
19:42:51 <Cale> a = (Mass 1.0, Pos 1.0 1.2 1.1)
19:43:06 <benny> > let a = (1.0, (1.0, 1.2, 1.1)) in a
19:43:07 <Cale> m3ga: where are you typing this?
19:43:08 <lambdabot> (1.0,(1.0,1.2,1.1))
19:43:27 <m3ga> into a file which I'm compiling with ghc
19:43:30 <Cale> okay
19:43:31 <Cale> hmm
19:43:46 <Cale> type Obj = Obj Mass Pos
19:43:48 <Cale> data Obj = Obj Mass Pos
19:43:50 <Cale> rather
19:44:10 <Cale> a = Obj (Mass 1.0) (Pos 1.0 1.2 1.1)
19:44:25 <Cale> try that -- with the 3 data declarations I mentioned
19:45:13 <Cale> why are you reading the one for C programmers if you know o'caml? :)
19:45:42 <m3ga> :-). because I couldn't find "Haskell for Ocaml programmers" 
19:46:29 <Cale> The Gentle intro might even do, though it's not gentle. Yet Another Haskell Tutorial is probably my favourite
19:47:52 <m3ga> ok, I'll try that one, but I'd still like to figure this one out.
19:47:58 <Cale> okay
19:48:02 <m3ga> Where's that paste thing?
19:48:06 <Cale> lisppaste2: url
19:48:07 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:49:33 <lisppaste2> M3ga pasted "type vs data" at http://paste.lisp.org/display/15249
19:50:47 <Cale> oh, you can't make that declaration part of main
19:51:00 <m3ga> oh?
19:51:10 <Cale> main has to be defined to be a value of type IO a (for any type a)
19:51:20 <Cale> IO () usually
19:51:40 <Cale> you could do something like
19:52:01 <Cale> main = let a = Obj (Mass 1.0) (1.0, 1.2, 1.1) in print a
19:52:28 <Cale> note that using type, you don
19:52:35 <Cale> you don't get a new type constructor
19:52:46 <Cale> it just renames another type
19:53:05 <m3ga> so a constructor requires data rather than type?
19:53:09 <Cale> Further, the type system will treat the synonym exactly the same as the original type
19:53:09 <Cale> yeah
19:53:46 <Cale> data Obj = Obj Mass Pos
19:53:58 <Cale> data Mass = Mass Double
19:54:12 <Cale> the first 'Mass' there names the type, and the second names the constructor
19:54:51 <Cale> you could just as well type  data Mass = M Double, which would give a type named 'Mass' and a data constructor 'M'.
19:55:00 <Cale> M :: Double -> Mass
19:55:47 <m3ga> ok, better, now I get "No instance for (Show Obj)"
19:56:13 <Cale> ah, add " deriving Show" to the end of each of your data declarations
19:56:32 <Cale> which will write the "obvious" Show instance for them
19:57:08 <m3ga> brilliant, thanks Cale.
19:57:30 <Cale> You could also write  deriving (Show, Eq)  to get an equality test for free too.
19:57:45 <m3ga> I always find working through the bits that don't work far more enlightening than the bits that do work :-)
20:03:18 <musasabi> Cale: re: haskell-cafe, GHC not properly flushing filehandles is a "feature" of 6.4
20:04:39 <m3ga> musasabi: that was actually me :-). AFAIAC its pretty much expected behavior for unix systems.
20:07:55 <hulahub> n8
20:08:07 <musasabi> mm, ok :-)
20:12:21 <cjb> Hm.  Anyone happen to use zsh with a persistent (across logins) directory stack?
20:24:33 <Cale> m3ga: Yeah, also, I was confused by the fact that GHCi does a different thing than compiled GHC.
20:25:10 <Cale> I did notice after the fact that it had that behaviour when the program is compiled.
20:28:37 <m3ga> Cale: it wasn't that surprised. I  sorta expect stdout to be line buffer like it is in C, Python,Ocaml etc
20:29:40 <Cale> Buffered output is kind of annoying though. :) It's turned off when running your program from GHCi at least.
20:31:22 <monochrom> stdout is not always line-buffered.
20:32:00 <Cale> monochrom: well, my response mentioned how to set it to NoBuffering
20:33:28 <Cale> What is line buffering actually good for? It would seem to me that you'd either want no buffering at all for interactive apps, or block buffering for performance
20:34:08 <monochrom> Before there was readline, line buffering was poor man's readline.
20:35:35 <Cale> ah, that makes sense for input anyway
20:35:57 <monochrom> what is the name of the haskell-cafe thread?
20:36:08 <Cale> Bug in "Haskell for C programmers" tutorial?
20:36:29 <monochrom> It started with fib...
20:36:38 <Cale> yeah
20:36:51 <Cale> there are a few other bugs too
20:38:22 <monochrom> Ha, I see the problem.  The C++ people has also puzzled over it.  They call it "tying cin with cout".
20:38:51 <Cale> hm?
20:39:32 <Cale> Yeah, you can't have line buffered output when you want prompts on the same line as input.
20:40:06 <Cale> (well, you can, but you'd need to manually flush the buffer in that case)
20:40:49 <m3ga> its obvious for anyone who has seen this problem in any other language.
20:43:07 <monochrom> Thus, let's say cin and cout are to the terminal, and so by default line-buffered.  Somehow, cout << "question? "; cin >> answer; did not print out "question? " immediately.  This was the case at one stage of the development of the iostream library.
20:44:14 <Cale> I seem to recall doing  cout << "question? " << flush;  or something like that, it was a long time ago :)
20:44:21 <monochrom> Eventually they introduced a procedure called tie.  Tying an input stream i and an output stream o means that whenever i waits for input, i flushes o first.
20:45:06 <monochrom> And by default, at startup, cin and cout are tied.  Subsequently, you can also tie other pairs of streams (e.g., of your own, or after redirection).
20:45:12 <m3ga> typical c++ fudgy hack to make it work
20:45:52 <Cale> Well, it is at least kind of general :)
20:46:19 <Cale> (it doesn't just apply to stdin/out)
20:46:52 <monochrom> I am not sure it is a fudgy hack.  It is factoring out and making explicit a behaviorial expectation hitherto not thought of before.  "line buffering" alone does not fully specify our expectation.
20:48:40 <Cale> Isn't it almost the same as having line buffered input and non-buffered output?
20:49:56 <monochrom> What if I want output to be still somewhat buffered?  What if my prompt string is 2MB long (yes silly but still) and it would be more efficient to buffer until the last minute?
20:51:20 <Cale> I can potentially imagine some obscure use for it, but certainly not for an interactive program. When dealing with large amounts of data, you probably don't want line buffering at all, but block buffering anyway.
20:52:01 <Cale> Why not just allow any sort of callback to be attached?
20:52:16 <monochrom> Aha, 2MB prompt is not silly.  Suppose I'm writing a shell.  User would enter "ls" for a large directory.  Shell would have to output probably 2MB of listing before asking for the next input.
20:53:59 <monochrom> Hohoho, so now you can say I should switch into block mode before listing, then back into no mode before the next prompt.
20:54:21 <Cale> no, you just run ls and it sets whatever kind of buffering it wants
20:54:52 <monochrom> Let's say "ls" is part of the shell.  Hell let's say it's not "ls" it's "help" and my help screen is 2MB.
20:54:57 <Cale> hehe :)
20:56:16 * Cale imagines an ANSI animation involving a rocket ship, the moon, and a strangely familiar paperclip
20:56:56 <monochrom> You know, 50 years later people will be saying "2MB of help content is *tiny*!"  (It's written in xhtml, you just dump it to /dev/tty, the hardware knows how to render it.)
20:57:03 <Cale> :)
20:57:35 <Cale> But sure, there are some cases where you might want to tie things like that. But why not allow more general actions to be tied to requests on handles?
20:57:49 <monochrom> an xhtml rendering device driver or hardware.  now that's a thought for the new year.
20:57:58 <Cale> This would just be a special case of tying the flush for one handle onto the read event for another.
20:58:04 <Cale> :)
20:58:44 <monochrom> "modprobe geForce-xhtml" ...
20:58:54 <audreyt> hm, is Einar Karttunen around on #haskell?
21:00:15 <monochrom> I think I see how your generalization goes.
21:00:18 <Cale> musasabi: hello?
21:00:41 <Cale> musasabi: audreyt is looking for you
21:00:59 <monochrom> (Doesn't it solve all synchronization problems in concurrent programming?)
21:01:20 <monochrom> (I'm thinking you have a new programming paradigm right there.)
21:01:25 <Cale> hehe
21:04:06 <monochrom> Microsoft is monitoring this channel and will be stealing my idea.  DirectXHTML they'll call it.  Now we are doomed.
21:05:51 <audreyt> oh heh, I neverlinked Einar with musasabi :)
21:06:37 <audreyt> musasabi: I've made a lot of improvements on PArrows, and would like to talk with you on how to (or whether to) incoporate them back
21:07:13 <audreyt> in particular, it now operates on dons's FastPackedStrings, does backtracking, and can hook to other parsers wuch as parsec
21:07:20 <audreyt> s/wuch/such/
23:58:47 <pierre-> hello
23:59:04 <Cale> hi
