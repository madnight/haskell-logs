00:35:55 <xinming> f >>= g >>= h
00:36:10 <xinming> is >>= right associative?
00:36:28 <xinming> f >>= g >>= h then will become f >>= (g >>= h)
00:38:19 <Cale> infixl 1  >>, >>=
00:38:24 <Cale> left associative
00:38:49 <Cale> f >>= (g >>= h) is usually a type error
00:39:13 <Lemmih> @type \f g h -> f >>= (g >>= h)
00:39:14 <lambdabot> forall (m :: * -> *) a a1 b.
00:39:14 <lambdabot> (Monad m, Monad ((->) a)) =>
00:39:14 <lambdabot> m a -> (a -> a1) -> (a1 -> a -> m b) -> m b
00:40:14 <xinming> Cale: So, Do we have to use ( f >>= g ) >>= h ?
00:41:17 <xinming> since function f will return a monad.
00:41:21 <xinming> :-/
00:41:31 <Lemmih> eh?
00:41:33 <Cale> f is a monadic value
00:41:37 <Cale> g is a function
00:41:41 <Cale> h is a function
00:42:36 <xinming> Cale: hmm, yes, what I mean is more or less the same. :-P
01:06:40 <ski> ( ma >>= amb ) >>= bmc  =  ma >>= (\a -> amb a >>= bmc)
01:23:54 <xinming> hmm, for Maybe type, x `mplus` y `mplus` z, since x,y and z isn't Nothing, Which will return ?
01:25:00 <lisppaste2> Saulzar pasted "Robot interface " at http://paste.lisp.org/display/14324
01:29:53 <aleator> Saulzar : Seen tautau?
01:30:06 <Saulzar> Nope, what's that?
01:30:28 <aleator> It's a robot programming game done in haskell.. 
01:30:44 * aleator tries to find it.
01:31:02 * aleator fails.
01:31:07 <Saulzar> Ah - cool. 
01:31:28 <Saulzar> Google doesn't seem to show it up...
01:31:29 <aleator> Well I still got one screenshot at: http://www.cc.jyu.fi/~aleator/me/tautau.html (Nevermind the language of the page)
01:31:52 <aleator> Shows a screenshot and "language" used to for robot programming.
01:32:42 <Saulzar> Hmm, strange looking 
01:33:40 <Saulzar> That is scripting right, not haskell?
01:34:22 <aleator> Yes. There is a special scripting language implemented in the game. (We didn't know about hs-plugins back then)
01:34:34 <aleator> It is bit like forth or joy.
01:34:43 <aleator> Ie. Read it backwards.
01:35:33 <ski> xinming : x
01:36:17 <Saulzar> Hmm, never met either of those languages. Good fun?
01:38:30 <aleator> Kinda.. The game was fun to make, but not so fun to play. Ie. the scripting language, though quite powerful, lacks primitives..
01:39:19 <aleator> Hmm.. I should really look into using hs-plugins to make it so that bots can be programmed in haskell..
01:40:02 <flux__> omega was nice.
01:40:17 <flux__> although I'm not sure if I want to write a robot in vorth ;)
01:41:07 <aleator> Yeah. Vorth is bit.. um. strange.
01:41:26 <aleator> Though it has assembly like attraction at times..
01:41:47 <flux__> does it have records?
01:42:10 <aleator> no.
01:42:41 <flux__> I think neither did omega, but maybe I want something more these days ;)
01:43:03 <aleator> Would it be any fun for anyone if that thingy would be haskell programmable?
01:43:13 <flux__> it could still be.
01:43:36 <flux__> infact the interface should be some socket, so you could use any language
01:44:57 <flux__> we used to have a worm game with that idea at work, except it used dynamically linked binaries.. we haven't played it for quite some time though.
01:45:18 <aleator> flux: I experimented on those - the major downside is that you then need quite much broilerplate for building the bots.
01:45:25 <Saulzar> Hmm, well that's what I'm trying to figure out ... idea is to try and make some little thing similar to robocode
01:45:31 <flux__> aleator, you can write a library that covers all that
01:46:15 <aleator> flux: True, but that is also bit laboursome.
01:46:24 <Cale> Functional reactive robocode :)
01:47:28 <aleator> My small advice. Try to make it easy to program bots. Thats what most programming games are weak on. :)
01:47:44 <Saulzar> Hmm, I thought it could be done somewhat simply by having a little imperitive language (monadic) to direct the robot 
01:48:15 <Saulzar> That's where robocode was great, you could just have a really stupid robot up in running in no time
01:48:46 <Cale> Saulzar: looked at yampa?
01:49:19 <Saulzar> Cale, No - I've seen it but not looked closely...
01:49:29 <aleator> Saulzar: Yeah. That was nice. But I found it quite nasty for building anything bigger. (Considering that I was doing it just for nonproductive fun)
01:50:08 <Saulzar> Well, it seemed there was two types of robot - the basic robot where you used foward backward rah rah
01:50:28 <Saulzar> The more complicated robot where you did everything by state, eg. setFoward, setTurn ...
01:50:50 <aleator> The state was eevil to program. :/
01:51:00 <aleator> imo
01:51:01 <Saulzar> Which seemed ok to me - I made a little robot which could destroy my friends robots :)
01:52:02 <Saulzar> Why's that? It's up to the programmer to then build higher level abstractions - ie. gotoPosition,  dodgeBullet  or whatever
01:53:57 <Saulzar> Anything short of being able to adjust the robot behaviour exactly at each turn means you lose control .. 
01:54:14 <aleator> Saulzar: Well, it might have been that I disliked java, but I got the feeling of spending lot of time programming the boring parts.
01:54:34 <aleator> It still does not need to be state machine even if you use all functions of the bot at the same time.
01:56:22 <Saulzar> Hmm, true.. you could leave it to the programmer to define all the actions each time I guess, if a convenient way could be found to do that
01:56:59 <Saulzar> Though clearly some things, position etc. have to be stateful :)
01:57:23 <aleator> Yeah. 
01:57:31 <Cale> sort of, at least
01:57:55 <aleator> The tautau solution was heavy concurrency. You could have separate simultaneusly running "subsystems"
01:58:07 <Saulzar> How do you mean Cale?
01:58:15 <aleator> Saulzar: But perhaps computation on those states does not need to be stateful?
01:58:24 <Cale> well, you could pass the robot its state as a parameter
01:59:28 <Saulzar> Yeah, I see 
02:00:57 <Saulzar> Hmm
02:01:51 <Cale> However, it's probably easier to use a reader monad in that case.
02:02:42 * Oejet really needs to grok the reader monad some day.
02:02:52 <Cale> It's just half a state monad
02:03:07 <Cale> Where you can read, but not write
02:04:28 <Saulzar> Ok well I think I will do a little more reading and have another think
02:07:07 <aleator> saulzar: http://sourceforge.net/projects/tautau/
02:08:22 <Oejet> Cale: Isn't it like an environment, where values can be "overlayed" in an inner scope, and in that scope only the latest value can be read?
02:08:45 <aleator> saulzar: http://sourceforge.net/project/screenshots.php?group_id=114524
02:10:20 <Cale> Oejet: yes
02:10:42 <araujo> Good morning Haskell'ers!
02:10:48 <Cale> of course, that's sort of a nested usage of it
02:10:51 <dcoutts> morning araujo
02:11:00 <araujo> Hi hi dcoutts !
02:11:16 <Cale> since there's a way out of the reader monad, of course, so you can run another reader monad computation inside your first
02:11:57 <Cale> but to get out, you have to have an environment to pass
02:12:17 <Oejet> Cale: Ok, I think, I understand it a bit more now.
02:21:09 <joelr1> good morning everyone!
02:21:43 <Cale> morning :)
02:21:50 <Cale> (I didn't sleep :)
02:22:02 <joelr1> i tried not to but did not fair well 
02:24:17 <joelr1> i rewrote the pickling to use Storable last night. i guess i'm facing a debugging nightmare now
02:24:23 <joelr1> a very efficient one, though :D
02:26:09 <Cale> hehe
02:26:17 <Cale> did it help?
02:26:25 <Cale> did you get my email?
02:26:41 <joelr1> it will surely help. i'm finishing the rewrite.
02:27:08 <joelr1> got your email, Cale, but it's the command that unpickles so it makes sense that i generates lots of data
02:27:10 <boegel> @seen astrolabe 
02:27:11 <lambdabot> astrolabe is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
02:27:11 <lambdabot> 10 hours, 22 minutes and 29 seconds ago.
02:29:22 <joelr1> Cale: i'm trying to figure out how to add sizing to picklers
02:29:26 <joelr1> i don't think i did it right
02:29:34 <joelr1>      appP :: (a, Ptr Word8) -> IO (Ptr Word8), 
02:29:34 <joelr1>      appU :: Ptr Word8 -> IO (a, Ptr Word8),
02:29:34 <joelr1>      appS :: a -> IO Int
02:29:40 <joelr1> sizeup :: PU a -> a -> IO Int
02:29:40 <joelr1> sizeup p value = appS p value
02:32:14 <Cale> sizeup = appS ?
02:32:26 <joelr1> well, the issue is here
02:32:36 <joelr1> sequ :: (b -> a) -> PU a -> (a -> PU b) -> PU b 
02:32:36 <joelr1> sequ f pa k = PU sequP sequU sequS
02:32:36 <joelr1> ...
02:32:41 <joelr1>           sequS b = 
02:32:41 <joelr1>               do let a = f b
02:32:41 <joelr1>                      pb = k a
02:32:41 <joelr1>                  appS pb b
02:32:58 <joelr1> lift :: a -> PU a 
02:32:58 <joelr1> lift x = PU (return . snd) (\s -> return (x, s)) (\_ -> return 0)
02:33:06 <joelr1> so there needs to be a plus somewhere
02:33:11 <joelr1> to add up the sizes
02:33:19 <joelr1> for pairs, for example
02:33:30 <Cale> yeah
02:33:33 <joelr1> pair :: PU a -> PU b -> PU (a,b) 
02:33:33 <joelr1> pair pa pb = sequ fst pa (\ a -> sequ snd pb 
02:33:33 <joelr1>                           (\ b -> lift (a, b)))
02:33:44 <joelr1> can't figure out where
02:34:55 <joelr1> Cale: do you have any suggestions?
02:35:22 <Cale> hmm
02:36:42 <Cale> I wish I was more familiar with that library
02:36:57 <reddi> hi, how can i sort a list of strings by there length?
02:37:02 <reddi> sort (map length  ["hallo","x"])
02:37:12 <Cale> that sorts the lengths
02:37:14 <lightstep> @plugs sort (map length  ["hallo","x"])
02:37:15 <lambdabot> [1,5]
02:37:20 <reddi> i want as an output the string, not the length
02:37:36 <lightstep> @type sortBy
02:37:37 <lambdabot> Not in scope: `sortBy'
02:37:38 <ProfTeggy> reddi, pair the strings with lenghts in a tuple
02:37:40 <lightstep> @type List.sortBy
02:37:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:37:46 <Cale> > sortBy (\x y -> compare (length x) (length y)) ["hallo","x"]
02:37:47 <lambdabot> ["x","hallo"]
02:37:56 <reddi> thx
02:37:59 <reddi> this is much better ;-)
02:38:13 <Cale> a useful function to define is  comparing p x y = compare (p x) (p y)
02:38:23 <Cale> then you can write  sortBy (comparing length) ...
02:38:53 <lightstep> isn't this function in the quasi-standard libraries already?
02:41:18 <Cale> lightstep: yeah
02:41:21 <Cale> er
02:41:22 <Cale> maybe
02:42:05 <Cale> er, doesn't look like it
02:42:26 <Cale> Eventually, there should be a Data.Ord with that function in it.
02:45:41 * ski_ wonders if 'data O a where MkO :: Ord a => a -> O a' is possible
02:46:52 <lightstep> not yet, i think
02:47:27 <ski_> it will be ?
02:48:18 <lightstep> i read some complaint about it not working, in some HWN, i think
02:49:16 <ski_> hm ..
02:49:32 <ski_> .. wonder if that would allow Set as monad
02:49:41 <lightstep> i don't understand these enough to know what it's good for
02:49:45 <lightstep> it would
02:55:20 <Saulzar> aleator, tautau was 3D (or 2.5D) ?
02:56:51 <joelr1> dcoutts: any idea how to add sizing to picklers?
03:06:39 <ski_> Ya Hya Chouhada
03:17:41 <tic> moo
03:23:56 <ADEpt> % cat > test.hs 
03:23:56 <ADEpt> main = putStrLn "Hello, world!"
03:23:56 <ADEpt> % runghc test.hs
03:23:56 <ADEpt> Hello, world!
03:23:56 <ADEpt> % runghc -package base test.hs
03:23:57 <ADEpt> <interactive>:1:80:
03:23:59 <ADEpt>     Failed to load interface for `Main':
03:24:01 <ADEpt> 	Could not find module `Main':
03:24:03 <ADEpt> 	  it is not a module in the current program, or in any known package.
03:24:15 <ADEpt> why runghc does not work in the second case?
03:38:22 <Oejet> Suppose I have a thread blocking on the line "(handle, hostName, portNumber) <- accept socket".  How would I interrupt it?  By sending a signal or an exception?
03:39:30 <Oejet> ADEpt: Try:  cat > test.hs  \n  module Main where  \n   main = putStrLn "Hello, world!"
03:39:54 <Heffalump> Oejet: I think an exception would work
03:40:12 <Heffalump> signals are application-wide, not thread-specific
03:43:40 <ADEpt> Oejet: but report says that "An abbreviated form of module, consisting only of the module body, is permitted. If this is used, the header is assumed to be `module Main(main) where'. If the first lexeme in the abbreviated module is not a {, then the layout rule applies for the top level of the module."
03:44:26 <ADEpt> Oejet: so the big question is why runghc is not happy with abbreviated form only when "-package xyz" is submitted on command line
03:45:03 <sieni> Oejet: usually people use select() or poll() system call on Un*x and you set up a pipe that you listen in your select() or poll() as well. If you want to interrupt, you write some crap to the pipe and the select() or poll() returns
03:46:06 <Oejet> I'll try my luck with forkIO, throwTo and catch.
03:46:35 <Oejet> sieni: That sounds ugly. :-)
03:46:36 <joelr1> Cale: ping
03:46:40 <joelr1> dcoutts: ping
03:46:47 <Oejet> ADEpt: Good question.
03:46:59 <lightstep> ADEpt, one idea is that if you specify -package, you're working with modules already
03:47:14 <dcoutts> joelr1, I think it's going to be easier to change the unpickeling side without changing the api at all
03:47:36 <dcoutts> the other side would probably require introducing a monad
03:47:50 <joelr1> dcoutts: i already did. i just reduced memory usage 5 orders of magnitude by moving to Storable in the pickler and advancing the pointer
03:48:06 <dcoutts> joelr1, oh well done
03:48:11 <sieni> Oejet: well, I don't know if the library supports that :-)
03:48:12 <joelr1> dcoutts: from 110mb to 20mb. is that 5 orders of magnitude? :)
03:48:20 <dcoutts> um no :-)
03:48:25 <Oejet> How would one make a new kind of exception like InterruptAcceptException?
03:48:34 <joelr1> dcoutts: dang :) i was hoping!
03:48:34 <joelr1> hehe
03:48:41 <dcoutts> it depends if we're using base 10 or base 2 orders of magnitude :-)
03:48:56 <dcoutts> it's nearly one base 10 order of magnitude
03:48:59 <joelr1> allright, so it's like, what, 400%?
03:49:19 <joelr1> dcoutts: anyway, i think i can do even better because i left one bit where a packet is just a chunk of memory
03:49:48 <joelr1> dcoutts: it would be better to pass the Ptr to that chunk, properly advanced 
03:49:55 <dcoutts> joelr1, so you've only changed the unpickling side?
03:49:55 <joelr1> right now i still convert that to a list of bytes
03:50:02 <joelr1> dcoutts: correct
03:50:09 <dcoutts> the pickling side is stil [Word8]
03:50:17 <joelr1> dcoutts: no, no
03:50:20 <dcoutts> oh?
03:50:23 <joelr1> i understood you wrong
03:50:30 <joelr1> it's strictly pointers now
03:50:34 <dcoutts> oh ok
03:50:41 <joelr1>      appP :: (a, Ptr Word8) -> IO (Ptr Word8), 
03:50:42 <joelr1>      appU :: Ptr Word8 -> IO (a, Ptr Word8),
03:50:42 <joelr1>      appS :: a -> IO Int
03:50:45 <dcoutts> right
03:50:46 <joelr1> it was easier than i thought
03:50:52 <joelr1> dcoutts: tell me something...
03:51:02 <dcoutts> but it does change your record picklers right?
03:51:11 <joelr1> no, it does not change anything
03:51:17 <joelr1> totally within that pickling module
03:51:19 <dcoutts> oh ok, even better
03:51:23 <joelr1> assume i got a Ptr from mallocBytes and i want to attach a finalizer
03:51:41 <joelr1> so i convert that to a foreign ptr with free and pass than around, right?
03:52:03 <dcoutts> I'd avoid adding a finaliser if possible
03:52:16 <joelr1> dcoutts: i cannot avoid it, i don't know when the packet is gonna go away
03:52:28 <dcoutts> you can copy it
03:52:31 <joelr1> but it will still be better than converting to [word8] and passing that around
03:52:42 <joelr1> the packet has a [word8] in it right now
03:52:50 <joelr1> but it's basically a chunk of memory
03:52:54 <dcoutts> joelr1, the memory allocated by mallocBytes is automatically garbage collected
03:52:57 <joelr1> dcoutts: what would a copy give me?
03:53:06 <joelr1> dcoutts: that's not what the doc says
03:53:18 * dcoutts double checks
03:53:34 <joelr1> The memory may be deallocated using free or finalizerFree when no longer required.
03:53:42 <joelr1> mallocBytes :: Int -> IO (Ptr a)	
03:53:42 <joelr1> Allocate a block of memory of the given number of bytes. The block of memory is sufficiently aligned for any of the basic foreign types that fits into a memory block of the allocated size.
03:53:56 <joelr1> maybe it does not exclude it being automatically deallocated
03:54:29 <dcoutts> mallocForeignPtrBytes is what you want
03:54:37 <dcoutts> "The memory will be released automatically when the ForeignPtr is discarded."
03:54:44 <joelr1> dcoutts: hmm
03:54:46 <Oejet> Ah, I see Dynamic exceptions.
03:54:58 <dcoutts> mallocForeignPtr is equivalent to
03:54:58 <dcoutts>     do { p <- malloc; newForeignPtr finalizerFree p }
03:54:58 <dcoutts> although it may be implemented differently internally: you may not assume that the memory returned by mallocForeignPtr has been allocated with malloc
03:55:04 <joelr1> dcoutts: where's the module?
03:55:09 <joelr1> dcoutts: err, what module is that?
03:55:10 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html
03:55:27 <joelr1> dcoutts: ok, and i would do with $ to operate on it, right?
03:55:47 <dcoutts> you'd use withForeignPtr
03:55:56 <dcoutts> and Sotrable operations
03:56:10 <dcoutts> Sotrable/Storable
03:56:15 <joelr1> so can i get the Ptr within, advance it and keep it around?
03:56:24 <joelr1> is that kosher?
03:56:50 <dcoutts> the pointer within is a value not a reference
03:57:08 <joelr1> dcoutts: so then it's kosher
03:57:18 <dcoutts> you'd have to keep an offset from the ForeignPtr
03:57:26 <joelr1> dcoutts: oh, i see
03:57:31 <joelr1> understood now
03:57:36 <dcoutts> an offset withing the block pointed to be the ForeigjPtr
03:57:53 <joelr1> allright, let me just commit what i have and do this one final change
03:57:59 <joelr1> then memory usage will be nothing
03:57:59 <dcoutts> because otherwise it'd mess up the GC if you could change the base pointer of the memory block
03:58:24 <dcoutts> however I'd still suggest IOUArray rather than Ptr + Storable
03:58:44 <dcoutts> it's easier since it does not involve Ptrs at all
03:58:48 <joelr1> dcoutts: no, i was thinking that if my advanced Ptr would still be a reference to the original ForeignPtr then i could keep the advanced Ptr around instead of ForeignPtr + offset
03:58:53 <joelr1> dcoutts: i do not know how to do that
03:58:58 <dcoutts> and is pure Haskell so there are no Finalisers and things
03:59:08 <joelr1> dcoutts: i'm not familiar with IOUArray at all
03:59:20 <dcoutts> it's much easier to use
03:59:31 <joelr1> dcoutts: i can send you my current code, though, if you care to show me how
03:59:33 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
03:59:45 <joelr1> dcoutts: i read the docs but can't wrap my head around it
03:59:50 <joelr1> in the pickler scenario anyway
03:59:55 <dcoutts> there is a mutable array interface and IOUarray Word8 is an instance of that
04:00:16 <dcoutts> you then just use readArray / writeArray with an index into the Array of Word8
04:00:35 <joelr1> dcoutts: right, but there's no Storable
04:00:36 <tic> I have g a b = ..., and then I want to do f a = g a x, but by defining f = something g x. what's -something- ?
04:00:42 <dcoutts> internally an IOUArray of Word8 is just a block of memory
04:00:51 <dcoutts> it's all unpacked
04:00:52 <tic> g $ flip x?
04:00:58 <joelr1> dcoutts: so it beats me how i would write a short or a int or int64 into the array
04:01:17 <dcoutts> joelr1, the same way you did with the [Word8] version
04:01:29 <joelr1> dcoutts: plus, it would produce a new array for every change, no?
04:01:29 <Lemmih> tic: f = flip g x
04:01:42 <Lemmih> @pl f a = g a x
04:01:43 <lambdabot> f = flip g x
04:01:47 <joelr1> dcoutts: all my ops are in the IO monad now, btw, 
04:01:49 <dcoutts> joelr1, the MArray interface stands for Mutable array
04:02:12 <dcoutts> the MArray interface is parameterised over a monad
04:02:22 <joelr1> dcoutts: but how is that implemented internally?
04:02:23 <dcoutts> the IOArray instance of MArray uses the IO monad
04:02:25 <tic> lambdabot thanks.
04:02:28 <tic> err, Lemmih
04:02:32 <joelr1> dcoutts: does it do peeks and pokes?
04:02:39 <Lemmih> tic: (:
04:02:43 <joelr1> dcoutts: or does it copy the array every time i change an element?
04:02:55 <dcoutts> joelr1, right, it uses a primitive to read / write bytes
04:03:03 <dcoutts> joelr1, so there's no copying
04:03:16 <joelr1> dcoutts: care to guide me? let me post my current version
04:03:39 <lisppaste2> joelr1 annotated #14302 with "picklers V2" at http://paste.lisp.org/display/14302#6
04:03:45 <dcoutts> joelr1, the pure arrays usually need to make a copy when they modify an array. The mutable versions do not, which is why they have to live in a suitable monad.
04:04:25 <joelr1> @paste
04:04:26 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:05:52 <joelr1> dcoutts: let me paste that to the paste page
04:06:04 <dcoutts> joelr1, s'ok, I got it
04:06:09 <joelr1> ok
04:07:32 <joelr1> dcoutts: so if i keep around the internal Ptr of a ForeignPtr, does that make a reference? i.e. is the fptr around until ptr is collected?
04:09:47 <dcoutts> joelr1, taking the Ptr out of a ForeignPtr is in general unsafe
04:09:57 <dcoutts> you have to use withForiegnPtr or similar things
04:09:58 <joelr1> dcoutts: ok
04:10:16 <lisppaste2> joelr1 annotated #14302 with "the endian side of things" at http://paste.lisp.org/display/14302#7
04:10:25 <dcoutts> because otherwise the GC would nodice the last use of the ForeignPtr and GC the memory block that the Ptr still points to.
04:10:35 <joelr1> dcoutts: this is the missing part, used heavily
04:13:48 <Oejet> I don't understand the class Typeable.  I'm trying to make a new exception to throw to another thread.  So far I have this:
04:13:56 <Oejet> data AcceptException = AcceptException
04:14:14 <Oejet> instance Typeable AcceptException where	typeOf = [AcceptException -> TypeRep]
04:14:26 <Oejet> throwDynTo threadID AcceptException
04:15:09 <Oejet> How do I create an instance of a TypeRep?
04:18:30 <tic> I need something like unlift.. I have the following: type DocumentState a = StateT Env Document a, and f :: DocumentState () -> DocumentState(), but I need to get hold of the Document part of DocumentState to use it for something. How do I do that?
04:18:50 <tic> d' <- d => d' becomes (), which is not what I want.
04:19:04 <dcoutts> joelr1, I'd use types like:
04:19:05 <dcoutts>      appP :: IOUArray Int Word8 -> Int -> a -> IO Int,
04:19:05 <dcoutts>      appU :: IOUArray Int Word8 -> Int -> IO (a, Int),
04:20:17 <joelr1> dcoutts: does it work for you?
04:21:05 <dcoutts> joelr1, the appU_num / appP_num is the tricky bit
04:21:15 <joelr1> dcoutts: right
04:21:16 <dcoutts> true, the Storable does make that easier
04:21:26 <joelr1> the list version is in that same paste
04:22:19 <joelr1> dcoutts: how do you copy a chunk of memory from a Ptr into another Ptr?
04:22:33 <dcoutts> and the unpackBits concatBits would probably want to be changed to work with IOUArrays directly
04:22:45 <joelr1> dcoutts: right (unpack/concat)
04:23:01 <dcoutts> copyBytes/moveBytes
04:23:05 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html#v%3AcopyBytes
04:23:16 <dcoutts> depending on wether the areas can ever overlap
04:23:19 <joelr1> dcoutts: thanks
04:25:42 <joelr1> dcoutts: i would love to switch to arrays, i think i would be able to print their contents too, right?
04:25:58 <joelr1> dcoutts: it just seems like a good bit of work and i'm too unfamiliar with arrays at the moment
04:26:45 <dcoutts> yes you can print their contents, and you can convert them to pure arrays which makes them even easier to work with
04:26:56 <dcoutts> see freeze/thaw
04:27:17 <joelr1> dcoutts: maybe a project for later on then 
04:27:21 <dcoutts> and you can do IO directly
04:27:26 <joelr1> dcoutts: unless you are willing to give it a go :D
04:27:42 <dcoutts> hGetArray / hPutArray
04:27:48 <tic> Hi. I have a problem with my StateT. Could someone please have a look at http://rafb.net/paste/results/b3Q5Qe64.html ?
04:29:14 <joelr1> dcoutts: so memory allocated by mallocBytes is _not_ garbage collected?
04:30:27 <tic> aha. maybe I nee to do evalState?
04:30:31 <tic> that feels... awkward.
04:30:51 <tic> That'll be horribly wrong :-/
04:32:39 <dcoutts> @hoogle mallocBytes
04:32:39 <lambdabot> Foreign.Marshal.Alloc.mallocBytes :: Int -> IO (Ptr a)
04:32:39 <lambdabot> Foreign.Marshal.Pool.pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
04:32:48 <tic> Hah! solved it. Haha, I'm so silly. :)
04:33:00 <dcoutts> joelr1, that's right, it needs to be explicitly freed
04:33:04 <joelr1> dcoutts: the funny thing is that allocaBytes is implemented on top of arrays 
04:33:08 <joelr1> damn
04:36:36 <dcoutts> joelr1, well with the appP and appU with the types above and a slight change in the definition of lift and sequ, everything types correctly
04:36:58 <joelr1> dcoutts: the devil is in the details, i'm afraid
04:37:12 <dcoutts> I've not implemented appU_num / appP_num but they should have the types: 
04:37:12 <dcoutts> ppU_num :: (Bits a, Integral a) => IOUArray Int Word8 -> Int -> IO (a, Int)
04:37:17 <dcoutts> appP_num :: (Integral a, Bits a) => IOUArray Int Word8 -> Int -> a -> IO Int
04:37:22 <dcoutts> joelr1, sure.
04:37:47 <dcoutts> the point is the only mutable bit is the index Int
04:38:03 <dcoutts> the IOUArray is just an input
04:38:16 <joelr1> dcoutts: that's interesting
04:38:44 <joelr1> dcoutts: how do you stuff an IOUArray into another array, copy it from a particular index?
04:38:50 <dcoutts> the fiddly bit will be changing the appU_num appP_num to use the IOUArray rather than [Word8]
04:38:54 <joelr1> dcoutts: starting with a particular index
04:39:06 <dcoutts> since you've done it for several integer types
04:39:18 <dcoutts> joelr1, right, initially starting from 0
04:39:19 <joelr1> dcoutts: damn, i mean copy it fully into a target array starting with an offset in the target array
04:39:34 <dcoutts> huh?
04:39:45 <joelr1> dcoutts: ok, so i allocate a big array for my whole packet
04:39:53 <dcoutts> joelr1, right
04:40:02 <joelr1> but my big packet is just a few bytes for a header and then another IOUArray which is the payload
04:40:29 <dcoutts> you don't know the size of the packet right?
04:40:38 <joelr1> so i would need to stuff the header into the big array and then stuff the payload after the header. copy it over
04:40:49 <joelr1> dcoutts: i don't know the equivalent of copyBytes for IOUArray
04:41:04 <dcoutts> joelr1, well it's not difficult to implement
04:41:18 <joelr1> dcoutts: efficiently?
04:41:23 <dcoutts> it's just a loop with readArray & writeArray
04:41:32 <joelr1> dcoutts: ok
04:42:17 <joelr1> dcoutts: ok, doing it
04:42:30 <joelr1> dcoutts: trying to rewrite with arrays, will surely have lots of questions
04:42:45 <dcoutts> joelr1, another more complex implementation strategy would be to use a list of blocks rather than a single bit array. That would be easier for reading stuff from a socket in chunks, but would be a bit more tricky to implement.
04:42:53 <dcoutts> bit/big
04:43:10 <joelr1> dcoutts: i don't need to read in chunks, i read a 4-byte size and then read the packet itself
04:43:18 <dcoutts> ok
04:43:20 <joelr1> dcoutts: how do i allocate a new IOUArray of a particular size?
04:43:29 <dcoutts> newArray or newArray_
04:43:34 <dcoutts> see http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
04:43:45 <joelr1> ah, ok, so they work on top of MArray
04:44:06 <dcoutts> right
04:44:12 <dcoutts> you mostly use the MArray interface
04:44:29 <joelr1> dcoutts: so i use 0 for the starting index and then size -1?
04:44:34 <joelr1> (0, size - 1)?
04:44:36 <dcoutts> right
04:44:39 <dcoutts> IOArray only provides a couple additional functions
04:44:44 <dcoutts> for doing IO
04:47:03 <joelr1> dcoutts: i guess i could just shiftR to store the bytes
04:47:35 <joelr1> byteSize would give me the number of bytes and then i would just shiftR as many times as needed, storing each byte into the array and advancing the index
04:47:43 <dcoutts> joelr1, it should be the same as when you were using [Word8]
04:48:06 <joelr1> dcoutts: why do you say that it's tricky then?
04:48:11 <dcoutts> but instead of 4 list elements for an Int32 or whatever, you perform 4 reads / writes
04:48:28 <dcoutts> well not that tricky, but I didn't have the code to hand to look at,
04:48:39 <dcoutts> it's more time consuming than the bits I changed
04:50:01 <joelr1> dcoutts:      appP :: ByteArray -> Int -> a -> IO Int,
04:50:08 <joelr1> what's the first Int for? the offset?
04:50:24 <dcoutts> right
04:50:34 <dcoutts>      appP :: IOUArray Int Word8 -> Int -> a -> IO Int,
04:50:34 <dcoutts>      appU :: IOUArray Int Word8 -> Int -> IO (a, Int)
04:50:46 <dcoutts> the array is a constant parameter
04:50:52 <joelr1> dcoutts: ok
04:50:57 <dcoutts> the Int is an input an output parameter
04:51:03 <dcoutts> because the offset gets updated
04:51:20 <dcoutts> just like in your previous version you had Ptr as an in and out parameter
04:51:39 <dcoutts> of course a Ptr embodies the data and the offset
04:51:55 <dcoutts> where as we split those two into a constant data and mutable offset
04:52:02 <joelr1> pickle :: PU a -> a -> ByteArray -> Int -> IO Int
04:52:02 <joelr1> pickle p value array ix = appP p array ix value
04:52:16 <dcoutts> right
04:52:34 <dcoutts> where ByteArray = IOUArray Int Word8 I suppose
04:52:42 <joelr1> dcoutts: yeah, a shortcut
04:53:06 <dcoutts> I quite like putting the 'a' at the end:
04:53:13 <dcoutts> pickle :: PU a -> ByteArray -> Int -> a -> IO Int
04:53:28 <dcoutts> because it emphasises the symetry between:
04:53:40 <dcoutts> pickle :: PU a -> a -> IOUArray Int Word8 -> Int -> IO Int
04:53:41 <dcoutts> unpickle :: PU a -> IOUArray Int Word8 -> Int -> IO (a, Int)
04:53:48 <joelr1> it will be done!
04:53:48 <dcoutts> err...
04:53:53 <dcoutts> pickle :: PU a -> IOUArray Int Word8 -> Int -> IO Int
04:53:59 <dcoutts> ug
04:54:03 <dcoutts> pickle :: PU a -> IOUArray Int Word8 -> Int -> a -> IO Int
04:54:06 <dcoutts> unpickle :: PU a -> IOUArray Int Word8 -> Int -> IO (a, Int)
04:54:12 <dcoutts> yeah, that's it
04:54:23 <dcoutts> along with:
04:54:34 <dcoutts> appP :: IOUArray Int Word8 -> Int -> a -> IO Int,
04:54:34 <dcoutts> appU :: IOUArray Int Word8 -> Int -> IO (a, Int)
04:54:51 <dcoutts> type Offset = Int
04:54:51 <joelr1> unpickle :: PU a -> ByteArray -> Int -> IO (a, Int)
04:54:51 <joelr1> unpickle p array ix = appU p array ix
04:55:00 <joelr1> yeah
04:55:04 <dcoutts> type ByteArray = IOUArray Int Word8
04:55:17 <dcoutts> appU :: ByteArray -> Offset -> IO (a, Offset)
04:56:54 <boegel> hey ageorges, new here ? want a tour ? ^_^
04:57:25 <dblhelix> *grin*
04:57:32 <tic> I've defined DocumentState a = StateT Integer Document a, but when I do evalStateT, GHCi thinks it's in fact of type StateT Integer [] (Document a)?
04:57:37 <joelr1> dcoutts: I actually prefer Index to Offset
04:57:41 <tic> how's that`
04:57:46 <dcoutts> joelr1, yeah fair enough
04:57:47 <MarcWeber> Can you tell me again which option to use to add another module include path for ghc?
04:57:47 <joelr1> because then i can use ix instead of offs :D
04:57:57 <dcoutts> it's a better term when working with arrays anyway
04:58:15 <dcoutts> you take offsets into raw memory chunks but indexes into arrays
04:58:56 <joelr1> lift :: a -> PU a 
04:58:56 <joelr1> lift x = PU (\_ ix _ -> return ix) (\_ ix -> return ix) (\_ -> return 0)
04:58:59 <joelr1> looks right?
04:59:11 <dcoutts> I think so
04:59:16 <joelr1> a bit ugly, though
04:59:23 <joelr1> doing the sequ
04:59:46 <dcoutts> joelr1, btw you should definately specilaise your 'num' for all the integer types you expect to use it with
05:00:00 <joelr1> dcoutts: why?
05:00:11 <joelr1> dcoutts: integral and bits does not work?
05:00:16 <dcoutts> there's the danger of it using the slow polymorphic version in all cases
05:00:27 <joelr1> dcoutts: how would i specialize?
05:01:12 <dcoutts> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
05:01:53 <joelr1> dcoutts: how would i use it here?
05:02:01 <dcoutts> it allows each specilaised version (eg for Int, Word32, Word8, etc) to be optimised better
05:02:09 * joelr1 is moving to hackerdom level 3 here
05:02:17 <dcoutts> we get several optimisedd copies rather than one slow generic version
05:02:18 <joelr1> specialized version of num?
05:02:23 <dcoutts> right
05:02:31 <dcoutts> because num is doing low level bit twiddling
05:02:34 <joelr1> dcoutts: can you spell it out for me?
05:02:46 <dcoutts> so the overheads of doing it generically are rather high compared to what it is doing
05:03:02 <dcoutts> joelr1, well look at the types that you are using num at
05:03:14 <dcoutts> num :: (Integral a, Bits a) => PU a
05:03:23 <joelr1> dcoutts: no, i mean the pragma itself
05:03:26 <dcoutts> but you'll be using that at several types right?
05:03:31 <dcoutts> so what are they
05:03:36 <dcoutts> then you can write the pragma
05:03:46 <joelr1> int32, word32, word8, word16, word64
05:03:49 <dcoutts> ok
05:03:52 <joelr1> and int16 i suppose
05:04:54 <joelr1> dcoutts: i rather like the array version so far
05:05:07 <dcoutts> good :-)
05:05:18 <dcoutts> it's easier than FFI
05:05:23 <joelr1> num :: (Integral a, Bits a) => PU a
05:05:26 <joelr1> right?
05:05:40 <dcoutts> yes
05:05:48 <joelr1> dcoutts: yes, and familiarity with that is gonna help me immensely when i move to apply haskell to search for similarities in time series
05:06:55 <dcoutts> my general advice is to not use arrays unless performance demands it, and if possible use pure arrays. Uboxed arrays are great however.
05:06:59 <hulahub> hey
05:07:23 <joelr1> dcoutts: so bounds gives me the size of the array, right?
05:07:39 <dcoutts> well it gives the index of the first and last elements
05:07:48 <dcoutts> so size is probably that + 1
05:07:52 <joelr1> ok
05:07:57 <dcoutts> since you're indexing from 0
05:08:08 <joelr1> bytearray :: PU ByteArray :-)
05:08:34 <dcoutts> joelr1, but the payoffs can be dramatic, I had a simulator that went from taking 5min to taking 5 sec after fully converting it to use unboxed mutable arrays (with unsafe indexing)
05:09:05 <joelr1> a simulator of what?
05:10:18 <joelr1> and what were you using initially?
05:11:06 <dcoutts> it was the ICFP '04 task
05:11:12 <joelr1> oh
05:11:15 <dcoutts> it was using FiniteMaps initially
05:11:23 <joelr1> so where did arrays apply? 
05:12:01 <dcoutts> instead of a finite map of records I change it to a record of unboxed mutable arrays
05:12:13 <joelr1> interesting
05:12:42 <joelr1> dcoutts: the copy array fun, would you just write it with recursion?
05:13:03 <dcoutts> joelr1, yes
05:13:26 <dcoutts> rather than: sequence_ [ do ... <- ]
05:13:45 <dcoutts> because the latter does not always deforrest correctly I have found
05:13:53 <joelr1> copyArray :: ByteArray -> Index -> ByteArray -> IO ()
05:14:00 <joelr1> where the first array is the destination one
05:16:29 <MarcWeber> How can I tell ghc to include a module beeing situated in another directory?
05:17:20 <Lemmih> -idir
05:18:45 <lisppaste2> joelr1 annotated #14302 with "copyArray" at http://paste.lisp.org/display/14302#8
05:18:50 <joelr1> dcoutts: good enough?
05:20:08 <dcoutts> joelr1, yep
05:23:11 <joelr1> bytearray :: Int -> PU ByteArray
05:23:11 <joelr1> bytearray sz = (\array ix a -> 
05:23:11 <joelr1>                     do copyArray array ix a
05:23:11 <joelr1>                        return $ ix + sz)
05:23:43 <joelr1> i was thinking if i really need to pass the size in, it's stored in the byte array already but i think i need the size for unpickling to create the new array
05:24:40 <joelr1> but i can just ignore the size when pickling and go with this instead
05:24:40 <joelr1> bytearray sz = (\array ix a -> 
05:24:41 <joelr1>                     do (0, last) <- bounds a
05:24:41 <joelr1>                        copyArray array ix a
05:24:41 <joelr1>                        return $ ix + last + 1
05:32:22 <musasabi> morning
05:32:34 <tromp> afternoon:)
05:32:34 <joelr1> hi musasabi 
05:32:57 <musasabi> hello
05:36:12 <MarcWeber> Is somone using hdirect on windows? I have some problems installing the lib/ compiling one of the example example
05:39:07 <joelr1> @index shift
05:49:21 <triplah> :)
05:56:28 <Sven_Moller_Fah> Hello everyone
05:57:11 <Sven_Moller_Fah> can anyone help with a small problem?
05:58:53 <Oejet> Sven_Moller_Fah: Sure, just ask.
06:00:04 <Sven_Moller_Fah> well im tryong to turn ["1","something"...... ], into (1,"something"),(........)
06:00:28 <Lemmih> What should ["1"] give?
06:00:46 <Sven_Moller_Fah> a list of strings where the 1st,3rd,5th etc...are numbers, and the 2nd,4th,6th etc are names
06:01:50 <Sven_Moller_Fah> ans turn those things into for example: [(1,"name"),(8,"name"),(2,"name")]
06:01:59 <Lemmih> > "test"
06:02:11 <Lemmih> What happended to lambdabot?
06:02:28 <Sven_Moller_Fah> giving ["1","name","8","name","2","name"]
06:02:32 <Sven_Moller_Fah> understand?
06:03:12 <Lemmih> Sven_Moller_Fah: Familiar with pattern matching and recursion?
06:03:14 <Oejet> So perhaps something like:  case list of n:s:lst -> (read n, s): ...
06:03:15 <MarcWeber> turnintotuple number:string:remaininglist = (number,string):(turnintotuple remaininglist) ? (not tested)
06:03:49 <Sven_Moller_Fah> hmm ill try that
06:03:52 <Sven_Moller_Fah> gimme a sec
06:04:03 <Oejet> Sven_Moller_Fah: Quickly, quickly.
06:04:59 <Sven_Moller_Fah>  Undefined variable "list" 
06:05:08 <Sven_Moller_Fah> ??
06:05:16 <Sven_Moller_Fah> should i import something?
06:05:31 <Lemmih> What did you write?
06:05:53 <Lemmih> Try writing this in your interpreter: Control.Monad.Fix.fix (\f l -> case l of (x:y:xs) -> (x,y):f xs; _ -> []) [1,2,3,4,5]
06:06:45 <Sven_Moller_Fah> ERROR - Undefined qualified variable "Control.Monad.Fix.fix"   
06:07:34 <Lemmih> Or more mundane: let zipper (x:y:xs) = (x,y):zipper xs; zipper _ = [] in zipper [1,2,3,4,5]
06:07:48 <Sven_Moller_Fah> [(1,2),(3,4)]  
06:08:08 <Sven_Moller_Fah> is this right?
06:08:33 <Sven_Moller_Fah> but its not a list of numbers
06:08:33 <Lemmih> Yeah, isn't it?
06:08:46 <Sven_Moller_Fah> the problem is that its [String] -> [(Int, String)]
06:08:59 <Sven_Moller_Fah> giving ["1","name","8","name","2","name"]
06:09:09 <Sven_Moller_Fah> ans turn those things into for example: [(1,"name"),(8,"name"),(2,"name")]
06:09:12 <Oejet> If it's a list of strings, you can on the resulting list of pairs do:  map (\(a,b) -> (read a :: Int, b)) result
06:09:13 <tromp> it cld also be defined in terms of everyOther
06:09:35 <tromp> which picks every other element from a list
06:09:36 <Lemmih> Sven_Moller_Fah: You can turn a string into a number with the function 'read'.
06:09:43 <Sven_Moller_Fah> ah nice
06:09:50 <Sven_Moller_Fah> ill try using read
06:10:11 <tromp> zipper l = zip (everyOther l) (everyOther (tail l))
06:10:33 <Sven_Moller_Fah> jesus...
06:10:40 <Oejet> @index everyOther
06:10:47 <Sven_Moller_Fah> im realy sorry guys, its just that i am only starting to learn haskell
06:11:03 <Sven_Moller_Fah> so what u are saying seems rather chinese to me (i am not chinese :P)
06:11:14 <Sven_Moller_Fah> cant it be made with something more simple?
06:12:19 <tromp> i dont see how you'd break down everyOther into simpler things
06:12:23 <Lemmih> Sven_Moller_Fah: It /is/ simple. Try going through the 'zipper' function step by step.
06:12:38 <Sven_Moller_Fah> ok
06:12:50 <Oejet> Sven_Moller_Fah: Try to fill in the rest of:  
06:12:50 <Oejet> pairUp [] = []
06:12:50 <Oejet> pairUp (n:s:lst) = (read n, s): ...
06:13:09 <tromp> everyOther (a:b:t) = a;everyOther t
06:13:12 <tromp> everyOther _ = []
06:13:47 <Oejet> I think, we are providing Sven "killer" help. :-)
06:13:55 <Sven_Moller_Fah> nseik :: [String] -> [(Int, String)]
06:13:55 <Sven_Moller_Fah> nseik [] = []
06:13:55 <Sven_Moller_Fah> nseik (n:s:lst) = (read n, s): nseik lst
06:13:59 <Sven_Moller_Fah> can i be like this?
06:14:12 <Oejet> Try it. ;-)
06:14:48 <Sven_Moller_Fah> it works!!
06:14:54 <Sven_Moller_Fah> thx a lot everyone!
06:15:15 <Sven_Moller_Fah> my problems was the turning string into Int part
06:15:54 <Sven_Moller_Fah> nseik :: [String] -> [(Int, String)]
06:15:54 <Sven_Moller_Fah> nseik [] = []
06:15:54 <Sven_Moller_Fah> nseik (n:s:lst) = (digitToInt n, s): nseik lst
06:16:01 <Sven_Moller_Fah> i had this, but obviously it didnt work
06:16:10 <Sven_Moller_Fah> read did the trick
06:16:53 <Oejet> Sven_Moller_Fah: Great. :-)
06:17:33 <Pupeno> Hello.
06:17:52 <Pupeno> If my first contact with Haskell was ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf I would have droped instantly.
06:20:43 <Lemmih> How so?
06:22:03 <Pupeno> Lemmih: because it specifies the types of everything not even saying that it can be avoided and the compiler can do it for you (something I like doing).
06:22:21 * dcoutts likes to specify the types of everything
06:22:40 <dcoutts> though sometimes I let the compiler infer it and then add it in afterwards
06:23:03 <dcoutts> sometimes I wish we could specify partial types
06:23:19 <dcoutts> foo :: ??? -> Int
06:23:46 <dcoutts> foo :: _ -> Int
06:23:49 <Saulzar> That's one thing I really like about 'normal' haskell practice
06:24:30 <integral> dcoutts: can't you do: foo x = (... :: Int)
06:24:39 <Saulzar> Otherwise you end up getting errors in places you really don't expect
06:24:49 <dcoutts> integral, yeah, sometime you can specify types in the body
06:24:57 <integral> sometimes?
06:25:00 <dcoutts> but sometime tey involve polymorphic bits
06:25:05 <integral> oh, when it's polymorphic
06:25:18 <integral> there's a glasgow extension for that I think: foo (x :: a) = (... :: a)
06:25:46 <dcoutts> yeah, but it doesn't work quite the way you'd expect, and it's harder to use than a top level type
06:25:53 <Saulzar> I tried learning OCaml mid way through the year, one thing which kept on biting me was that the standard practice was to leave types off
06:26:04 <integral> dcoutts: what's the caveat?
06:26:27 <Saulzar> So I accidentally put a "," in the wrong place, and get a strange error in some other function because the return type suddenly changed
06:26:31 <dcoutts> integral, I recall there's some subulty to it but I can't fully remember
06:26:49 <Saulzar> Where as if I put a type signature on my function it would spot that the return type and what I was actually trying to return were wrong
06:26:58 <dcoutts> Saulzar, yeah I found that problem bit some of our students doing an OCaml practical
06:27:23 <integral> hmm
06:27:31 <dcoutts> Saulzar, the only sensable way to track down the problem was to add a type annotation to the function
06:28:19 <dcoutts> because a mistake earlier in the body of the function (using the function recursively at the wrong type) was detected later when the function was used at the correct type.
06:28:37 <Saulzar> dcoutts, Yep, it also makes the intention of the function much more clear. The pattern match can be fairly garbled looking
06:28:47 <dcoutts> yeah
06:40:57 <lisppaste2> joelr1 annotated #14302 with "ambiguous type" at http://paste.lisp.org/display/14302#9
06:41:12 <joelr1> can someone clue me in please?
06:41:32 <dcoutts> joelr1, the 'a' is not in scope
06:41:38 <dcoutts> desipite apperances
06:41:40 <joelr1> dcoutts: hmm
06:41:46 <joelr1> dcoutts: how do i fix it?
06:41:55 <dcoutts> that is: (0 :: forall a. a)
06:42:02 <dcoutts> which is not what you want
06:42:03 <joelr1> dcoutts: ah! i know
06:42:06 <Pupeno> Where do I start to make network programs with haskell (those that open sockets or similar) ?
06:43:19 <joelr1> dcoutts: this does not work either
06:43:19 <joelr1> readBits array ix =
06:43:19 <joelr1>     readBits' array ix ((bitSize (0 :: a)) - 8) 0
06:43:32 <joelr1> readBits :: (Num a, Bits a) => ByteArray -> Index -> IO a
06:43:32 <joelr1> readBits array ix =
06:43:32 <joelr1>     readBits' array ix ((bitSize (0 :: a)) - 8) 0
06:43:45 <sebell> Pupeno: http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
06:43:58 <Pupeno> sebell: thanks.
06:44:02 <dcoutts> like I said, what you've written is: (0 :: forall a. a)
06:44:14 <joelr1> dcoutts: how do i get the size of a then?
06:45:03 <dcoutts> getting it when it's a return type is harder than an argument, but...
06:45:13 <joelr1> forall a.
06:45:20 <joelr1> i had it there before, i think
06:45:39 <joelr1> dcoutts: yeah, that does the trick
06:45:45 <dcoutts> but that's not right
06:45:50 <joelr1> dcoutts: why not?
06:45:55 <dcoutts> that's an arbitrary 'a'
06:45:58 <joelr1> readBits :: forall a.(Num a, Bits a) => ByteArray -> Index -> IO a
06:46:05 <joelr1> it's not arbitrary, it's constrainted
06:46:09 <joelr1> constrained
06:46:32 <dcoutts> oh I see, that's a recent ghc extension
06:46:50 <dcoutts> to allow the 'a' specified in a type spec with forall to scope over the body
06:46:57 <dcoutts> it didn't use to be that way
06:47:05 <joelr1> dcoutts: ok
06:47:13 <dcoutts> joelr1, it's that way since 6.4.x
06:47:23 <joelr1> i never knew different
06:47:35 <dcoutts> previously you needed bigger contortions (which I was about to demo)
06:47:53 <dcoutts> joelr1, btw as a style point..
06:48:17 <dcoutts> instead of (0 :: blah) we'd usually say (undefined :: blah)
06:48:30 <dcoutts> it makes it clear that it's the type that we are passing rather than a value
06:49:10 <dcoutts> (jhc has a syntactic extension which allows one to say (_ :: blah) instead)
06:50:25 <joelr1> dcoutts: i changed that
06:53:07 <joelr1> dcoutts: how do i disable this silly warning?
06:53:15 <joelr1>     Warning: This binding for `sz' shadows an existing binding
06:53:26 <joelr1> i want -Wall but without the shadowing warning
06:53:29 <Oejet> Pupeno: A small example to get you started is at http://rafb.net/paste/results/LoQkfL64.html .
06:53:48 <Pupeno> Oejet: thanks! that will be helpful!
06:54:21 <dcoutts> joelr1, check the manual, see if that wanring can be turned on/off individually (it probably can)
06:54:49 <Oejet> I hope, it's readable.
06:56:07 <dcoutts> joelr1, http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id3129835
06:56:15 <dcoutts> -fno-warn-name-shadowing
06:56:38 <jethr0> oeject, "language c++" ;-)
06:57:42 <joelr1> dcoutts: thanks alot! i'm done with basic pickling, need to change endian now
06:57:45 <Oejet> jethr0: I no longer concern myself with syntax.
06:58:08 <jethr0> and rightly so. syntax is for the weak of mind *g*
06:58:41 <Oejet> Syntax is the straight jacket of typing monkeys.
06:58:54 <ProfTeggy> Woah
06:58:58 <jethr0> well, let's not get ahead of ourselves
06:58:58 * ProfTeggy takes a note.
06:59:20 <jethr0> @quote+ Oejet Syntax is the straight jacket of typing monkeys.
06:59:23 <dcoutts> joelr1, well done
06:59:36 <joelr1> dcoutts: with your kind help ;)
06:59:45 <jethr0> @quote oejet
06:59:56 <dcoutts> hopefully when it's over you'll be able to compare the [Word8] and Bytearray versions on performance and clarity of implementation
06:59:59 <joelr1> dcoutts: if this works out it's gonna be haskell forever !
07:00:08 <dcoutts> joelr1, good luck!
07:00:09 <Pupeno> How can I do this:   data Polynomial = Polynomial2 Float Float Float | Polynomial3 Float Float Float Float   without restricting myself to Float (any Num would be right) ?
07:00:19 <joelr1> dcoutts: it's all in that paste :-) the one i have annotated over and over :-)
07:00:46 <Oejet> Not even being woahed by a real professor can lift my eyebrowes any more.
07:00:58 <dcoutts> joelr1, right, but a little write up with a summary of the performance changes would probably useful/interesting to many people.
07:01:01 <Saulzar> Pupeno, data Polynomial a = Polynomial2 a a a etc.
07:01:35 <dcoutts> joelr1, when your deadline is over of course. I think people found your last postmortem quite interesting.
07:01:39 <joelr1> dcoutts: oh, yeah. my blog is getting stale and i have been waiting for good stuff to post
07:01:42 <jethr0> saulzar, wouldn't you need a (Num a =>) or so?
07:01:52 <ProfTeggy> Oejet, this is the case for virtually all students I know
07:01:56 <Pupeno> Saulzar: I see, what is the goal of the first a ? just to be a kind of viarable holding the type ?
07:02:04 <joelr1> dcoutts: i'm salvaging whatever is left of my reputation now :-) the deadline is long gone and this is a fixed-price project too. 
07:02:13 <Saulzar> Pupeno, Right
07:02:17 <int-e> Pupeno: to get the Num constraint, data Num a => Polynomial a = ... are you sure you don't just want a list?
07:02:24 <joelr1> dcoutts: i think i'll combine that postmortem with these one 
07:02:26 <Saulzar> jethr0, I was just going to suggest that :)
07:02:28 <joelr1> that will be complete
07:02:35 <Oejet> ProfTeggy: The part about typing monkey, or the eyebrows? :-P
07:02:43 <Pupeno> int-e: sure (I am tring to learn about datatypes).
07:02:49 <ProfTeggy> Oejet, the latter, the latter.
07:03:19 <joelr1> dcoutts: i still haven't figured out the specialization bit
07:03:22 <Pupeno> Saulzar: so, you put as many variable as different tyes you have there, no matter how many 'members' the datatype has ?
07:03:42 <dcoutts> joelr1, you read that section in the manual?
07:04:01 <jethr0> oejet, i like the part about the "real professor", because some in this channel might know more about (functional programming) than quite a few professors ;-)
07:04:10 <jethr0> (functional)*
07:04:17 <joelr1> dcoutts: not yet, too busy :-) 
07:04:18 <Pupeno> Saulzar: like datatype Person a b = Person a a b a    (it'd be name, lastname, age, email) ?
07:04:20 <dcoutts> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
07:04:22 <joelr1> dcoutts: too much to absorb today
07:04:26 <Saulzar> Pupeno, How do you mean? You could have different number types for each member, but that isn't going to be easy to work with
07:04:35 <joelr1> dcoutts: i do have the page open, thanks
07:04:37 <dcoutts> joelr1, it's only one paragraph
07:05:00 <joelr1> dcoutts: will read soon
07:05:08 <dcoutts> {-# SPECIALIZE num :: PU Int #-}
07:05:09 <Saulzar> Pupeno, Right (though perhaps name etc. would not be useful as any type)
07:05:12 <dcoutts> {-# SPECIALIZE num :: PU Word32 #-}
07:05:13 <dcoutts> etc
07:05:18 <joelr1> dcoutts: oh, that's all?
07:05:21 <dcoutts> couldn't be simpler
07:05:41 <Pupeno> Saulzar: thank you (I am slowly starting to understand datatypes).
07:05:46 <joelr1> dcoutts: does my endian stuff need to be specialzied as well?
07:05:48 <jethr0> dcoutts, you got an url where i can read about those compiler pragmas?
07:06:17 <ProfTeggy> jethr0, stop being nasty, OK? ;-)
07:06:39 <Sven_Moller_Fah> is there any function that tests if a certain thing is an INT?
07:06:55 <Sven_Moller_Fah> a certain string i mean
07:06:58 <jethr0> profteggy, present company excluded, of course. 
07:07:51 <jethr0> but teaching and supervising research often don't go hand-in-hand with practical programming. at least not in germany
07:07:55 <ProfTeggy> jethr0, thanks -- I start to feel better already.
07:08:07 * ProfTeggy hacks almost every day
07:08:23 <dcoutts> joelr1, http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
07:08:35 * jethr0 finds that cool and considers becoming a prof at profteggy uni.
07:08:44 <jethr0> ;-)
07:08:46 <ProfTeggy> jethr0, and I have been a PhD student not sooo long ago
07:08:53 <joelr1> ok
07:09:20 <jethr0> what do you hack at?
07:09:41 <ProfTeggy> An XQuery to relational algebra compiler.  Written in Haskell.
07:09:45 <dcoutts> joelr1, the interesting optimisation ones are INLINE, SPECIALIZE, UNPACK, and RULES (but RULES is much more complicated to use)
07:10:09 <joelr1> unpack? i'll have to look at that
07:10:32 <jethr0> cool, although i have no idea what you are talking about *gg*
07:11:15 <dcoutts> ProfTeggy, that's for accessing xml that is stored in a traditional database I suppose?
07:11:45 <ProfTeggy> dcoutss, yes.  The relational algebra program operates over a relational encoding of XML fragments.
07:12:05 <jethr0> ok, now it's clearer to me
07:12:16 <dcoutts> ProfTeggy, sounds useful :-)
07:12:25 <jethr0> but why is the xquery special to the compiler. wouldn't a generic one do as well?
07:12:27 <ProfTeggy> dcoutts, it's useful and fun.
07:12:28 <dcoutts> unlike most of the code I write :-(
07:12:36 <ProfTeggy> I consider myself a lucky person to be ale to work on this stuff.
07:12:39 <dcoutts> well my code is fun, but not useful :-)
07:12:46 <jethr0> dcoutts, you mean the usefull or the fun part?
07:12:55 <joelr1> dcoutts: do you code haskell for a living?
07:13:11 <ProfTeggy> jethr0, if you write a compiler, its inner workings normally depend on source AND target language
07:13:17 <dcoutts> joelr1, I'm a Phd student and I teach, so sort-of
07:13:20 <SamB> dcoutts: aren't you the Gtk2Hs maintainer?
07:13:29 <joelr1> dcoutts: cool
07:13:36 <dcoutts> SamB, yep. That's the most useful coding I do. :-)
07:13:48 <dcoutts> SamB, my other stuff is much less useful. But fun.
07:14:06 <Sven_Moller_Fah> is there any function that tests if a String thing is an Int?
07:14:06 <SamB> dcoutts: well, still, thats a non-trivial amount of code and is rather useful ;-)
07:14:19 <dcoutts> SamB, I'm glad you think so! :-)
07:14:35 <jethr0> sven_moller_fah: not quite it, but how about (read a :: Int)
07:14:43 <SamB> I may not be too good at using it yet, but it is useful!
07:14:46 <dcoutts> @type reads
07:14:50 <Sven_Moller_Fah> ill try that
07:14:51 <Sven_Moller_Fah> thx
07:14:52 <jethr0> or (reads a :: Int)
07:15:01 <dcoutts> lambdabot?
07:15:04 <Pupeno> What is the meaning of => in Haskell ?
07:15:04 <dcoutts> @botsnack
07:15:04 <SamB> dcoutts: oh, do you have wrappers for common file browser use cases?
07:15:09 <jethr0> lambdabot's not here ;-(
07:15:23 <dcoutts> SamB, yeah
07:15:33 * SamB goes to pull latest lambdabot, build, and start if nobody else wants to
07:15:46 <SamB> dcoutts: where?
07:16:00 <SamB> I meant in the library!
07:16:25 <SamB> I did not mean in the file chooser demo program!
07:16:26 <dcoutts> heh
07:16:28 <dcoutts> no, not in the library yet
07:16:37 <dcoutts> that's from a different prog actually
07:16:44 <dcoutts> it's not clear yet exaclty what the api should be
07:16:45 <SamB> it looks quite similar
07:16:48 <Saulzar> Pupeno, Type constraint as far as I know - Num a =>   means that forall a.  a is of typeclass Num
07:16:58 <jethr0> > let f s = not . null $ (reads s :: [(Int,String)])
07:17:01 <SamB> dcoutts: thats a good point
07:17:04 <jethr0> > let f s = not . null $ (reads s :: [(Int,String)]) in f "32"
07:17:09 <dcoutts> SamB, yeah, I probably copied it from there :-)
07:17:09 <Pupeno> Saulzar: thanks.
07:17:23 <dcoutts> SamB, there's quite a scale of options and everyone will want slightly different things
07:17:48 <dcoutts> SamB, but we could probably add a basic one and a more cusomisable one.
07:17:58 <dcoutts> SamB, feel free to darcs send us a patch :-)
07:18:10 <jethr0> sven_moller_fah: let f s = null . snd . head $ (reads s :: [(Int,String)]) in f "32"
07:18:25 <dcoutts> SamB, I'm working on tree/list/view things at the moment
07:18:26 <Sven_Moller_Fah> ?!
07:18:28 <Sven_Moller_Fah> what?!?
07:18:38 <SamB> Sven_Moller_Fah: what what?
07:18:38 <jethr0> that is a function to determine whether s is an Int
07:18:48 <Sven_Moller_Fah> hmm
07:18:58 <Sven_Moller_Fah> im trying to make another version of words
07:19:17 <jethr0> reads takes a string and tries to parse it, returning the parsed and the remaining string [("32", "rest")]
07:19:25 <gour> dcoutts: ping
07:19:30 <dcoutts> gour, pong
07:19:34 <jethr0> the "null . snd . head" tests whether the "rest" is empty or not
07:19:38 <gour> dcoutts: how do you do?
07:19:43 <dcoutts> ok thanks
07:19:58 <gour> i'm pretty buy these days with my studies
07:20:04 <dcoutts> jethr0, can't one just test: null . reads
07:20:12 <gour> not so much time for haskell  :-(
07:20:29 <gour> dcoutts: i wanted to ask you regarding our darcs mirror
07:20:36 <dcoutts> gour, ah yes
07:20:39 <jethr0> damn, my code is still wrong
07:21:03 <gour> dcoutts: i was checking on haskell.org, but there is still old (system) python
07:21:17 <jethr0> dcouts, yes, i wanted to do that, but (reads "32i" :: [(Int, String)]) return [("32", "i")]
07:21:25 <gour> dcoutts: otoh, i saw ghc provides for the mirror with tailor
07:21:55 <gour> dcoutts: however my question is whether you think about moving 100% to darcs?
07:22:21 <gour> dcoutts: if darcs can handle ghc tree, it can (probably) gtk2hs too
07:22:34 <Sven_Moller_Fah> for example: i need "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n" to come like this: ["1","Tartaruga Teresa","2","Lebre Laura","3","Mosca Maria"], and words wont do that
07:23:05 <dcoutts> gour, I wonder if we could just try re-tailinring the cvs repo that might get past the current sticking point of the utf8 in the changelog
07:23:31 <dcoutts> gour, ghc switching will probably help to persuade Axel. We'll see. It's not just my decision.
07:24:00 <gour> dcoutts: have you 'fixed' changelog?
07:24:26 <gour> dcoutts: why would axel wanting to stay?
07:24:28 <SamB> does GHC build from darcs yet?
07:24:38 <gour> dcoutts: is he does not familiar with darcs?
07:24:41 <dcoutts> gour, because it works and is familiar
07:24:42 <jethr0> sven_moller_fah: reads does this once, but not N times
07:24:51 <jethr0> so you'd have to apply reads again and again
07:24:53 <dcoutts> gour, I don't think he is very familiar with darcs
07:25:20 <dcoutts> gour, I think that the problem might be just that the utf-8 appeared in a commit message
07:25:32 <gour> dcoutts: but darcs is so simple one can start using it in 5 min, so for someone mastering haskell, it is peanuts ;)
07:25:36 <Sven_Moller_Fah> but i tried like this: | read s :: Int = divide lst
07:25:37 <Sven_Moller_Fah> 	| otherwise = s ++ ' ' : divide lst
07:25:42 <jethr0> otherwise you can just read the string char by char
07:25:53 <Sven_Moller_Fah> but it doesnt work
07:26:05 <gour> dcoutts: yes, that could be, but i wonder why it works on my local machine but it fails on haskell.org
07:26:11 <dcoutts> gour, well sure, but people have greater attachment to their tools than that. You know what it's like.
07:26:16 <jethr0> alternating "takeWhile (isAlpha)" and "takeWhile (isNum)" or so
07:26:29 <dcoutts> gour, I think it'd be woth trying a fresh tailorisation
07:26:36 <SamB> dcoutts: have him try it in some other project or something
07:26:50 <dcoutts> SamB, yeah
07:27:00 <dcoutts> it's a good way to start
07:27:30 <gour> dcoutts: to ditch present repo and try from a scratch or keep backup of present repo somewhere?
07:27:31 <jethr0> alternating "takeWhile (isDigit)" and "takeWhile (not . isDigit)"
07:27:42 <SamB> they say the best way to learn darcs is to start a project in it; I'm not sure if it is or not, but I'm positive it isn't to migrate something existing to darcs...
07:27:52 <dcoutts> gour, we can keep a backup if you like
07:27:53 <SamB> or mirror
07:29:18 <jethr0> sven_moller_fah, "read s :: Int" is alright, but it will return an error on failing
07:29:46 <gour> dcoutts: i'm not attached to the backup, just wonder what if it does not work with the new either'
07:29:54 <gour> s/'/?
07:30:16 <dcoutts> gour, then we're in the same situation as we are now: no up-to-date darcs mirror
07:31:04 <gour> dcoutts: ..and we can move to darcs (then) ?
07:31:33 <dcoutts> gour, that really depends on the views of all devs
07:31:51 <dcoutts> gour, if the full ghc conversion goes ok then that might be persuasive.
07:32:10 <gour> dcoutts: is the dev list proper place to discuss it?
07:32:18 <dcoutts> gour, yes
07:32:41 <gour> dcoutts: ok, i'll there and try (now) to produce a new mirror
07:32:43 <dcoutts> but the refreshing of the tailor is a seperate issue
07:32:59 <dcoutts> gour, ok cool, thanks very much.
07:33:06 <gour> dcoutts: sure, but i won't go into that (now :-)
07:33:21 <gour> dcoutts: will let you know what will happen
07:34:13 <Pupeno> What does "Kind error: `Polynomial' is not applied to enough type arguments^MIn the instance declaration for `Eq Polynomial'" mean ? (the code is: instance Eq Polynomial where)
07:35:15 <dcoutts> gour, ok, thanks
07:35:15 <SamB> whats the suggested usage of darcs tag?
07:35:28 <SamB> i.e., what should I call the tag?
07:35:45 <dcoutts> SamB, how about the release version number
07:36:06 <SamB> dcoutts: ok, I thought maybe
07:36:49 <Pupeno> SamB: I use branches (separate directories) for 0.1, 0.2, 0.3, 1.0, 1.1, 2.0, etc.
07:37:25 <Pupeno> SamB: And tags for 0.1.0, 0.1.1, 0.1.2, 0.2.0, 0.2.1, 0.3.0, 1.0.0, 1.0.1, 1.0.2, etc.
07:38:02 <joelr1> dcoutts: ping
07:38:09 <dcoutts> joelr1, pong
07:38:20 <joelr1> dcoutts: how do you Show the ByteArray?
07:38:45 <dcoutts> joelr1, iterate over it and show each element
07:38:48 <musasabi> mmh, why does haddock die on an export declaration like "(:+:)(..)" and how to fix it?
07:38:57 <joelr1> dcoutts: i see
07:39:50 <dcoutts> joelr1, or getElems and show that
07:40:09 <dcoutts> (the latter is easier)
07:40:11 <joelr1> dcoutts: that works for me
07:40:26 <SamB> musasabi: because they are hard to parse? maybe it doesn't support infix type constructors?
07:40:26 <joelr1> dcoutts: hmmm
07:40:36 <joelr1> dcoutts: but getElems is in a monad
07:41:00 <dcoutts> joelr1, that is true. Because the IO array is mutable
07:41:01 <SamB> musasabi: you could use #if !defined(HADDOCK) or whatever its called
07:41:09 <dcoutts> so every read/write is an IO action
07:41:23 <SamB> I'm not sure if thats the real problem...
07:41:25 <joelr1> dcoutts: ok, so i would need unsafePerformIO then to show the array?
07:41:32 <SamB> but that should be okay for now
07:41:32 <boegel> in unix, how can I replace a word containing a '-' by something ?
07:42:04 <dcoutts> joelr1, you can freeze a mutable array to get a pure array, but of course even freezing is an action inside the monad.
07:42:14 <SamB> boegel: be more specific
07:42:16 <joelr1> dcoutts: yep
07:42:28 <SamB> GNU programs interpret -- to mean "no more flags"
07:42:33 <ADEpt> boegel: perl -pe 's/\b\w*-\w*\b/something/'
07:43:04 <dcoutts> joelr1, so a mutable array cannot be made an instance of Show
07:43:26 <joelr1> dcoutts: unsafePerformIO
07:43:29 <boegel> ADEpt: I can't use '-' in a character class, can I ?
07:43:33 <musasabi> SamB: that kind of makes it hard to generate documentation for that thing.
07:43:35 <dcoutts> joelr1, well that's a nasty hack
07:43:44 <ADEpt> boegel: you can
07:43:45 <joelr1> dcoutts: ;)
07:43:47 <SamB> musasabi: well, consider it a stopgap measure
07:43:51 <dcoutts> joelr1, can't you just do: getElems >>= print
07:44:08 <boegel> ADEpt: using single quotes ?
07:44:10 <ADEpt> boegel: first, it could be first char in a class, and then , you can escape it: [a-z\-]
07:44:19 <joelr1> dcoutts: no, i have ByteArray in a record that's derived from show
07:44:53 <boegel> ADEpt: ok, thanks
07:44:55 <dcoutts> joelr1, perhaps you should freeze the byte array before putting it into the record
07:45:15 <dcoutts> joelr1, it only needs to be mutable while you're pickling/unpickling
07:45:44 <dcoutts> joelr1, I'd use a type PureByteArray = UArray Int Word8
07:45:48 <joelr1> dcoutts: true, but what advantage does that give me?
07:45:59 <joelr1> dcoutts: aha
07:46:04 <dcoutts> joelr1, it can be made an isntance of Show
07:46:05 <joelr1> dcoutts: would that be showable?
07:46:07 <joelr1> ok
07:46:10 <dcoutts> and you can index it in pure code
07:46:35 <dcoutts> (type MutableByteArray = IOUArray Int Word8)
07:46:37 <Lemmih> Good night, #haskell.
07:46:40 <SamB> joelr1: yeah, thats basically what I suggested before
07:46:46 <dcoutts> g'night Lemmih
07:46:49 <SamB> Lemmih: good morning
07:47:38 <hulahub> re
07:47:43 <gour> Lemmih: good night? where are you?
07:47:58 <SamB> gour: not here, anymore
07:47:59 <dcoutts> joelr1, pure arrays can just be indexed with: arr ! i
07:48:04 <SamB> @map
07:48:17 <dcoutts> gour, he lives by a strange clock.
07:48:36 <gour> dcoutts: :-)
07:48:44 <SamB> dcoutts: I thought the sun determined night/day
07:48:45 <SamB> ?
07:48:53 <joelr1> dcoutts: cool
07:49:08 <dcoutts> SamB, na, he's nocturnal
07:49:13 <gour> dcoutts: i tried with the mirror, but same error
07:49:38 <gour> dcoutts: do you know if Changelog is the only 'offending' file?
07:49:39 <dcoutts> joelr1, like I said, in general one should use pure arrays if possible and mutable ones if necessary.
07:49:43 <SamB> then shouldn't he say "good morning, I'm off to bed?
07:50:15 <dcoutts> gour, hmm, the AUTHORS is probably the same
07:51:00 <dcoutts> gour, oh, actually the AUTHORS file is ok
07:51:06 <gour> dcoutts: what do you think about e.g. mirroring the repo to some other machine and then rysnc from that machine to the present repo?
07:51:53 <gour> dcoutts: maybe you could mirror from dev-repo (not anonym.) and then rsync to haskell.org?
07:52:00 * SamB thinks new repo should have new URL to avoid confusion when attempting to pull
07:52:36 <joelr1> @index UArray
07:52:49 <joelr1> oops
07:52:51 <SamB> Data.Array.Unboxed
07:52:55 <joelr1> cool
07:52:55 <SamB> don't say oops
07:52:59 <joelr1> thanks SamB 
07:53:04 <joelr1> why shouldn't i say oops
07:53:13 <SamB> because lambdabot is the one at fault
07:53:17 <dcoutts> gour, that'd be ok
07:53:27 <joelr1> oh
07:53:38 <dcoutts> gour, we could ask what the ghc people are doing with tailor and utf-8
07:53:58 <gour> dcoutts: i also wonder
07:54:15 <gour> dcoutts: cvs.haskell.org is on another machine?
07:54:33 <Pupeno> lisppaste2: url
07:54:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:54:33 <SamB> goodchilde: I think it is a virtual subdomain
07:54:37 <SamB> er, gour 
07:55:11 <SamB> maybe not ;-)
07:55:18 <gour> SamB: so the same machine?
07:55:20 <dcoutts> gour, that's true, it is a different machine
07:55:27 <SamB> you could use host to find out in any case
07:55:43 <dcoutts> $ host cvs.haskell.org
07:55:43 <dcoutts> cvs.haskell.org is an alias for haskell.galois.com.
07:55:55 <lisppaste2> Pupeno pasted "What am I missing ?" at http://paste.lisp.org/display/14328
07:55:55 <dcoutts> $ host haskell.org
07:55:55 <dcoutts> haskell.org has address 128.36.229.215
07:56:05 <gour> cvs.haskell.org is an alias for haskell.galois.com
07:56:28 <Pupeno> Can anybody tell me what I am missing in that piece of code, I get an error (also pasted), the error starts with: Could not deduce (Num a) from the context (Eq (Polynomial a))...
07:56:44 <gour> dcoutts: so this explains everything
07:56:58 <joelr1> dcoutts: since all my data is fixed i think i'll switch to using arrays instead of lists everywhere in the records. after i switch basic pickling to arrays
07:57:03 <SamB> Pupeno that means you need to add Num a to the context
07:57:05 <dcoutts> gour, or ghc has no unicode
07:57:12 <gour> dcoutts: i mv-ed gtk2hs_bak to gtk2hs, but we have broken mirror
07:57:24 <dcoutts> gour, ok
07:57:25 <gour> dcoutts: ohh, another good reason
07:57:25 <Pupeno> SamB: How do I do that ?
07:57:42 <SamB> Pupeno: stand by while firefox swaps back in
07:57:51 <gour> dcoutts: so i'm going to ask on dev-list for a change to darcs
07:57:58 <Pupeno> SamB: ok.
07:58:25 <gour> dcoutts: my Moon is in Aries, so (sometimes) i'm pushing things forward :-)
07:58:47 <dcoutts> gour, heh, good luck :-)
07:59:11 <gour> dcoutts: well, i'm counting on some support from the back
08:00:00 <SamB> Pupeno: apparantly putting constraints on data types doesn't do a whole lot for you...
08:00:33 <SamB> I mean, put that constraint on your instance instead of your data declaration and it should work...
08:00:47 <Pupeno> SamB: I am just tring to learn.
08:01:06 <Pupeno> SamB: on the instance ?
08:01:45 <SamB> move "Num a => " from data Polynomial a = to instance Eq (Polynomial a)
08:02:47 <SamB> I agree that it makes little sense that this is needed, given that the compiler did not reject it on the data declaration...
08:02:57 <Pupeno> SamB: I see, thanks! (I can have it on both, the data and the instance declarations).
08:03:26 <dcoutts> gour, I'm sure I'll chip in.
08:03:30 <SamB> Pupeno: yes, but I find that it is confusing to have them on data declarations when I don't know what they do for me...
08:03:44 <gour> dcoutts: thanks, i'm writing a post
08:03:48 <joelr1> dcoutts: so how do i assing a new array when initializing a record?
08:03:53 <hulahub> i use data HTree = Node HTree Float HTree | Leaf Char Float
08:03:53 <hulahub>      deriving (Show) to be abe to see what happens in interactive mode - is there a way to use show without a data declaration? so that i am able to 'show' everything in the file
08:04:03 <joelr1> type ByteArray = UArray Int Word8
08:04:11 <joelr1> say i have data Foo = Foo ByteArray
08:04:32 <joelr1>     SrvSSLHandshakeData 
08:04:32 <joelr1>     {
08:04:32 <joelr1>      payload = newArray_ (0, 0),
08:04:32 <joelr1>      sslType = SSL_None
08:04:35 <joelr1>     }
08:04:38 <joelr1> this does not work
08:04:53 <joelr1>     Couldn't match `Word8' against `a i e'
08:04:53 <joelr1>       Expected type: ByteArray
08:04:53 <joelr1>       Inferred type: Data.Array.Base.UArray Int (a i e)
08:04:53 <joelr1>     In the application `newArray_ (0, 0)'
08:07:19 <SamB> Pupeno: I can't even find why that is allowed at all
08:07:23 <jlouis> @where conjure
08:07:53 <dcoutts> joelr1, newArray_ is in the monad
08:08:14 <joelr1> dcoutts: i figured that much but how do i intiialize a pure array?
08:08:34 <dcoutts> joelr1, oh, sorry, for a pure array it's not in the monad
08:08:38 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
08:09:00 <lisppaste2> jethr0 pasted "string splitting" at http://paste.lisp.org/display/14330
08:09:03 <dcoutts> pure arrays follow the IArray interface rather than the MArray interface
08:09:18 <joelr1> i missed that, my bad
08:09:22 <dcoutts> joelr1, so you can use array, listArray or accumArray to build a new array
08:09:39 <jethr0> sven_moller_fah: have a look at the url above...
08:11:34 <joelr1> dcoutts: i wonder how low (in memory usage) can i go if i switch to arrays in records as well
08:11:36 <SamB> maybe that is actually Haskell 98, which would explain why it doesn't do much, but not why it is allowed...
08:13:05 <dcoutts> joelr1, arrays of what? and rather than what?
08:13:09 <jethr0> anyone know a function that does "func pred val = if pred then Just val else Nothing"?
08:13:20 <joelr1> dcoutts: well, apart from pickling i use arays in my records
08:13:24 <joelr1> dcoutts: err, lists
08:13:33 <dcoutts> lists of?
08:13:37 <joelr1> dcoutts: like when receiving a list of poker tables and associated info
08:13:39 <jethr0> "pred val"*
08:13:41 <dcoutts> how big are the elements
08:13:59 <joelr1> i always get the number of items (read it first) and then a chunk of memory representing an array of those items
08:14:13 <joelr1> dcoutts: a few hundred bytes per item possibly
08:14:23 <dcoutts> joelr1, you'll only save space if the elements themselves are small and uboxable
08:14:24 <joelr1> dcoutts: but the program runs constantly you see
08:14:40 <joelr1> dcoutts: i'm not looking for unboxing with the record items
08:14:47 <dcoutts> joelr1, if each list/array element is large then lists is probably better
08:14:53 <joelr1> dcoutts: but you think there will be no use converting lists to arrays then
08:15:06 <joelr1> dcoutts: allright, step by step. pickling first
08:15:52 <dcoutts> joelr1, indeed, if each list item is large then there is little advantage, especially if you're processing each element in turn rather than randomly (in which case the arrays fast indexing would be an advantage)
08:16:26 <dcoutts> for ordinary pure arrays you only save about 4 bytes per element if you use an array rather than a list
08:16:38 <dcoutts> and there is no improvement in cache locality
08:16:46 <joelr1> dcoutts: how do i convert a mutable array to a pure one? freeze, right?
08:16:53 <dcoutts> joelr1, right
08:17:00 <joelr1> or possibly even unsafeFreeze
08:17:13 <dcoutts> possibly, that reqires a bit of thinking
08:17:15 <joelr1> since i won't be modifying the contents
08:17:29 <joelr1> freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
08:17:31 <dcoutts> leave it as safe freeze to start with
08:17:40 <joelr1> but why the monad ?
08:17:53 <dcoutts> joelr1, because it examines the contents of the array
08:17:56 <joelr1> because i have to freeze in the I/O monad?
08:17:57 <dcoutts> so it must be in the monad
08:18:26 <joelr1> dcoutts: i need to write a wrapper so that pure arrays are serialized as mutable
08:18:27 <dcoutts> it's probably not where your performance hot spot is so the unsafeFreeze will probably not buy you anything
08:18:33 <joelr1> dcoutts: ok
08:18:59 <dcoutts> joelr1, you don't need to convert them to mutable when you pickle them
08:19:09 <joelr1> dcoutts: i do not?
08:19:17 <dcoutts> you just copy their elements into the output mutable byte array
08:19:29 <joelr1> true
08:19:33 <joelr1> so the wrapper is a copy
08:19:40 <joelr1> i need to think about this a bit
08:19:42 <dcoutts> you've got one copy function for copying from one mutable byte array to another
08:19:46 <SamB> joelr1: its not like you are saving the actual objects, just the data ;-)
08:20:03 <dcoutts> it'd be easy to make another that copies from a pure byte array to a mutable byte array
08:20:47 <SamB> dcoutts: isn't there already one of those?
08:20:47 <SamB> no?
08:20:52 <gour> dcoutts: posted, btw, how are you satisfied with evolution? i plan to move my contacts to it (from kontact), but i'm thinking about using it for email too (i'm still using mutt, getmail...but maybe it's time to simplify the whole setup a bit) 
08:20:57 <joelr1> dcoutts: yes, i guess that's what i'll need to do
08:21:42 <gour> joelr1: you are still debugging your crash(es) ?
08:21:57 <joelr1> gour: no, i'm optimizing memory usage
08:22:10 <gour> joelr1: so you fixed your crashes?
08:22:20 <joelr1> gour: cause my program mostly spends time generating garbage and collecting it
08:22:35 <joelr1> gour: i have had so many crashes that i don't even know which ones you are referring to
08:22:38 <gour> joelr1: it was (is) a win32 problem only?
08:22:50 <dcoutts> gour, yeah I'm happy with evolution, except for it's spam filtering feature
08:23:03 <joelr1> gour: sorry
08:23:10 <gour> joelr1: the one you're asking on haskell lsit, providing traces, url for testing...
08:23:39 <gour> dcoutts: it cannot use SA directly?
08:23:47 <joelr1> gour: that one was a thread-unsafe version of getHostByName apparently
08:24:05 <dcoutts> gour, it does use SA
08:24:14 <gour> joelr1: well, i tried to dive into it, but it was way about my head
08:24:54 <gour> joelr1: i just wanted to say that it is very 'optimistic' (for a haskell noob) to see masters having such problems :-)
08:24:57 <joelr1> gour: that's ok, i felt the same way but now i can examine the haskell stack and stuff like that :-)
08:25:06 <gour> dcoutts: what's wrong then?
08:25:21 <joelr1> gour: you must be kidding me ;) i learned haskell over the course of the project and the past two months
08:25:50 <dcoutts> gour, well by default it spawns too many SA processes which use up loads of RAM. and it still seems to let quite a bit of spam through.
08:26:23 <dcoutts> gour, and the SA checking is rather slow, so downloading 100's of email if I'm away for a day or two takes ages.
08:26:38 <gour> joelr1: me? not at all, but i'm wrestling with the language with quite some time and i'm still on 14th chapter (ok, time-constraints are there, but still...you pretty quickly hit a not so thin wall)
08:27:01 <joelr1> gour: true, true
08:28:11 <gour> dcoutts: hmm, then i'm better to stay with the present setup - getmail works very nicely and scan for viruses (clamav), spam (SA) & use maildrop to sort everything, evolution can be used only for reading, composing & sending
08:28:29 <joelr1> erlang is pretty powerful but i like haskell more
08:28:53 <joelr1> i hope i have achieved mastery of haskell binary io with this last conversion to arrays 
08:29:07 <joelr1> if everything works out then i'll try a networking proxy in haskell
08:29:21 <gour> joelr1: i also got hanged for haskell, but would like that designers (either of tools or the language) fix things a bit, so that it is not so scary for beginners
08:29:39 <joelr1> gour: hmm... interesting idea
08:29:39 <dcoutts> joelr1, yeah, we're really in need of a standard flexable binary IO / pickling framework
08:29:47 <joelr1> gour: try applying that to c++ ;)
08:29:59 <jethr0> joelrl, i guess erlang is suited better for mirroring distributed processes than haskell, no?
08:30:13 <joelr1> dcoutts: yes, and we need to couple that with flexible records ;)
08:30:31 <jethr0> s/mirroring/implementing/
08:30:40 <dcoutts> joelr1, heh, yeah
08:30:50 <gour> joelr1: when i was on the university many years ago i used zortech c++, but today, afaik,  the language evolved into huge & ugly monster
08:30:52 <joelr1> jethr0: erlang is distributed, yes. that's key. i can't even begin to think how i would implement distributed thread monitoring 
08:31:17 * joelr1 reminesces about programming on a PDP-11
08:31:25 <joelr1> hey, and i'm only 31 :D
08:31:54 <joelr1> that was in '89-90 in russia
08:32:21 <gour> joelr1: hmm, i'm something older than you, but it look like computers wasted some of your childhood-pastimes-time 
08:32:54 <gour> '89-90 there was also zortech c++ compiler for the pc
08:33:08 <joelr1> gour: yes, i remember that one
08:33:39 <joelr1> gour: well, a lot of my childhood pastime :)
08:33:41 <gour> joelr1: that was a time when you got the whole library in the form of dead-trees
08:33:59 <gour> joelr1: with a few big floppies
08:34:02 <joelr1> gour :D
08:34:12 <joelr1> i remember 8" floppies! and punch cards
08:34:46 <gour> joelr1: i was also using (in the school) ibm punch cards - ahhh....those keyboards :-)
08:36:05 <gour> joelr1: and knows a guy called "Mr Cancel" waiting lot of time before IBM machines to get the message "the job was cancelled" (PL/1)
08:36:39 <SamB> I remember 5.25" floppies!
08:36:44 <joelr1> i tried learning PL/1 for fun when i was a kid, good idea i had no place to practice
08:36:52 <joelr1> SamB: 8" are .... bigger!
08:36:59 <SamB> I remember 3.5" floppies!
08:37:13 <joelr1> 10Mb hard disks were awesome too
08:37:17 <SamB> I remember 5.25" hard drives!
08:37:35 <gour> joelr1: Cobol was (still) a king then & FORTRAN
08:37:37 <SamB> I remember drive B:!
08:37:41 <joelr1> SamB: yeah, i think the 10Mb hard drives were 10.5" or something
08:37:55 <joelr1> SamB: you must be 20-25 then :D
08:38:09 <SamB> joelr1: I don't think I saw one smaller than 20
08:38:09 <gour> zx81 ;)
08:38:19 * jethr0 is only 25 and had a brand new 25mb 5.25 harddrive, which was twice the now usual height...
08:38:19 <gour> old sinclair
08:38:24 <SamB> I'm actually 19
08:38:38 <joelr1> :-)
08:38:41 <jethr0> you could  actually kill someone with that drive. it weight a few kilos
08:38:48 <SamB> and my dad is a computer programmer
08:38:51 <jethr0> weighed*
08:38:56 <joelr1> did anyone pay attention to the age distribution in the haskell questionaire? in the results that is
08:39:05 <joelr1> i did not find a lot of people around 30 for some reason
08:39:07 <jethr0> no, what did it say?
08:39:32 <joelr1> seemed like a lot of people in their early 20s and a lot closing on 40
08:39:46 <dcoutts> gour, heh, I didn't realise you were older than me! :-)
08:39:47 <SamB> joelr1: maybe they are too busy working to fill in questionaires at that age?
08:39:48 <samx> students and their teachers :-)
08:39:50 <jethr0> well, maybe you have to grow up with computers to appreciate haskell's inner beauty
08:39:54 * kosmikus is 29
08:39:55 <jethr0> but i really don't think so ;-)
08:40:11 <gour> joelr1: i'm in the 2nd category :-)
08:40:11 <hulahub> is there a way to access a element of a list like myList[2] for the thrid element
08:40:17 <SamB> or maybe they fell prey to Windows
08:40:26 <dcoutts> hulahub, myList !! 2
08:40:29 <gour> according to the age, not a (haskell) teacher
08:40:50 <dcoutts> hulahub, but avoid it if you can since it's a linear time operation
08:41:07 <hulahub> ok
08:41:23 <SamB> hulahub: if you need indexing, consider some kind of array
08:41:54 <SamB> hulahub: what else do you need to do?
08:41:59 <kosmikus> or a finite map
08:42:34 <hulahub> nothing else
08:43:04 <gour> dcouts: really. what do you thought of me?
08:43:10 <SamB> okay then, if that is absolutely all you need than an array will be exactly what you want ;-)
08:43:20 <hulahub> ok
08:43:35 <dcoutts> gour, not sure :-)
08:43:40 * dcoutts is 24
08:44:29 <gour> dcoutts: i can almost be your father :-}
08:44:56 <dcoutts> gour, I always find it interesting that age matters so much less in online discussions compared to face-to-face ones.
08:44:58 <SamB> hulahub: so what kind of data are you storing?
08:45:12 <hulahub> SamB: just ints
08:45:20 <dcoutts> gour, scary huh?
08:45:24 <gour> dcoutts: (sometimes) it does not matter even in face-to-face :-)
08:45:26 <joelr1> online no one knows you are a dog
08:45:27 <hulahub> SamB: its a "Table" at the moment i use [[Int]]
08:45:32 <SamB> hulahub: then you'll like UArray
08:45:39 <gour> dcoutts: scary? what?
08:45:41 <dcoutts> joelr1, nice
08:45:51 <jethr0> dcoutts, maybe it's a matter of status. online everyone starts out with the same "karma", while in RL age demands respect, which is not always justified and thus creates tension...
08:45:52 <jethr0> maybe..
08:45:58 * joelr1 is a golden retriever
08:46:05 <SamB> hulahub: assuming you don't define it recursively
08:46:10 <hulahub> @type UArray
08:46:29 <hulahub> where is lambdabot? :D
08:46:31 <dcoutts> jethr0, I think that's pretty much true.
08:46:35 <jethr0> on vacation
08:46:55 <SamB> joelr1: hehe
08:47:02 <samx> I finished my first (almost) Haskell program yesterday; an othello/reversi game. The sources can be found at http://www.pcuf.fi/~sam/Othello.hs    Would anyone here mind taking a look at it, and give hints on how I could make the code nicer ?
08:47:14 <hulahub> > [1,2] ++ [3]
08:47:17 <jethr0> dcoutts, i really like talking to people on irc and determine whether 
08:47:21 <hulahub> fuck it :D
08:47:36 <dcoutts> jethr0, not sure about the "not always justified..." but certainly everyone starts on the same respect level, irrespective of age which is not true in RL.
08:47:38 <gour> dcoutts: the post appeared on dev list
08:47:44 <dcoutts> gour, ok
08:48:05 <jethr0> they have something to say or are just talking a lot...
08:48:26 <SamB> samx: are you saying it is almost a program, or almost your first?
08:48:42 <gour> dcoutts: now i have to go to do my daily quota of studying jyotish (somehow i'm behind my schedule)
08:48:49 <jethr0> dcoutts, what i meant was that we have a society, where age is supposed to be proportional to wisdom. while in new technologies it's often antiproportion (domain-specifically).
08:49:20 <gour> dcoutts: btw, what about your course?
08:49:37 <dcoutts> gour, you make a good argument in your email, we'll see what Axel says
08:49:38 <jethr0> and (really) old people might demand respect in technical matters from people who are younger, but actually more qualified then them
08:49:45 <gour> jethr0: people are not living in such a way to become wise with the age, just the opposite
08:50:01 <dcoutts> gour, the course is over. It finnished on Friday. It went well I think. We'll do it again next year.
08:50:07 <samx> samb, :-)   almost my first.. I've written one or two before, but those suited functional style easily.. othello/reversi is something that usually suits imperative style easier, so it was somewhat more of a challenge
08:50:30 <dcoutts> jethr0, yes that's an interesting point
08:50:31 <gour> dcoutts: something for the next (spring) semester?
08:50:36 <jethr0> :P
08:51:09 <dcoutts> gour, perhaps a compilers course with some GUI for visualising certain complier algorithms.
08:52:11 <gour> dcoutts: do you know haskell-visual-plugin for vs is having some success?
08:52:17 <dcoutts> gour, btw, I'm working on tree/list/view stuf, which might help your DB apps.
08:52:28 * gour grins
08:52:30 <dcoutts> gour, don't know really.
08:52:53 <dcoutts> it requires an unrelased version of ghc which restrict takeup quite a bit
08:53:07 <dcoutts> the same is true of hIDE though
08:53:36 <gour> dcoutts: let me know when you start doing gnomedb bindings (lol)
08:54:10 <dcoutts> gour, well this would be more helpful to the technique where an existing Haskell DB api is connected up to a GUI
08:54:11 <gour> dcoutts: so hIDE is frozen atm, waiting for a (new) ghc release?
08:54:29 <dcoutts> gour, what I'm working on at the moment will also help hIDE
08:54:31 <tromp> looks fine, samx
08:54:37 <tromp> very easy to follow
08:54:56 <gour> dcoutts: i didn't catch the 1st one (haskell db...)
08:55:47 <tromp> but i'd use a 1-dimensional board representation
08:56:20 <gour> dcoutts: you mean, when working without gnomedb?
08:56:24 <samx> tromp, why is that?
08:56:27 <dcoutts> gour, right
08:56:39 <tromp> makes for more concise code
08:56:42 <dcoutts> gour, eg using HSQL or some existing Haskell DB API
08:56:49 <tromp> that's just as easy to follow
08:56:52 <gour> dcoutts: the catch is that one 'loses' its widgets
08:57:02 <dcoutts> gour, yeah
08:57:26 <gour> dcoutts: so, i still consider having them is worth enough
08:57:40 <gour> dcoutts: especially seeing native mac port on the way
08:57:59 <musasabi> How should one mix generics and monads?
08:58:00 <gour> dcoutts: i believe mac os will receive some of the win32 refugees
08:58:14 <Oejet> samx: It seems you have 8x8 places on your board.  That'll make for a nice Word64-representation. :-)
08:58:34 <jethr0> tromp, i see your point, but array is faster and can convert to list!
08:58:43 <musasabi> I want to define a class like "class Foo a where parser :: Parser a" (where Parser is a monad) and do the generics stuff with respect to a.
08:58:46 <gour> dcoutts: and having (complete) gnome bindings in haskell is a 'thumb up' for the language
09:00:18 <tromp> i'm not suggesting to give up the array
09:00:24 <tromp> just make it 1-dim
09:00:34 <tromp> and isValidDir looks like it has a bug
09:00:38 <jethr0> samx: i wonder if there ain't another way of checking for boundaries.
09:01:00 <samx> tromp, it does?
09:01:16 <jethr0> i haven't come up with one yet, but i'm sure there exists a beautiful way of checking (lx < x < gx)
09:01:26 <dcoutts> gour, what do you think the really useful DB widgets are?
09:01:35 <jethr0> tromp, i couldn't understand it either ;-)
09:02:05 <tromp> Nothing should be Square (Just p)
09:02:53 <samx> tromp, I think it's working :-)
09:03:27 <jethr0> like having a monad that steps over vectors, which contain an element outside of bounds
09:03:38 <jethr0> but as i said, i haven't quite figured it out yet
09:03:41 <hulahub> data Tree = SNode [Tree] |Node Int [Tree] | Leaf Int   
09:03:46 <hulahub> whats wrong with ths ?
09:04:05 <tromp> no, it's bugged:(
09:04:07 <jethr0> hulahub: except for the weird "A", nothing really
09:04:22 <hulahub> "A" ?
09:04:23 <tromp> you can move adjacent to any stone of yours
09:04:29 <jethr0> 
09:04:36 <hulahub> hmm
09:04:40 <gour> dcotts: GnomeDbSelector
09:04:40 <hulahub> i dont see that
09:04:51 <samx> tromp, no you can't
09:04:52 <hulahub> you ar enot using utf-8 ?
09:04:54 <jethr0> it's right after the first "|"
09:05:11 <hulahub> ah
09:05:14 <samx> tromp, the right part of the first matching rule checks that it can't be done
09:05:14 <jethr0> don't know, but there is _something_ behind your first pipe
09:05:14 <hulahub> invisible char
09:05:17 <hulahub> grr
09:05:20 <hulahub> yep thats the prob
09:05:21 <jethr0> not to me ;-)
09:05:24 * jethr0 sees all
09:05:49 <gour> dcouts: GnomeDbForm, GnomeDbGrid
09:05:51 <joelr1> how do you treat a IArray as a Ptr Word8?
09:06:10 <joelr1> i need to call some foreign functions
09:06:16 <jethr0> joelrl, is that even possible?
09:06:21 <joelr1> beats me
09:06:24 <joelr1> thus my asking
09:06:24 <musasabi> I don't think that is possible.
09:06:41 <joelr1> so i need to allocate a chunk of memory and then copy byte by byte?
09:06:42 <joelr1> hmm
09:06:43 <jethr0> is IArray even definitely contiguous?
09:06:49 <joelr1> allocaBytes is implemented on top of arrays
09:06:51 <joelr1> let me see
09:06:53 <tromp> what does       Square (Just p) | p == piece -> getSquare board (y, x) /= Square Nothing do?
09:07:19 <jethr0> joelrl, you could work an allocated array in haskell, from the start.
09:07:20 <jethr0> ;-)
09:07:26 <gour> dcoutts: e.g. GnomeDbCanvasDbRelations is (maybe) more useful for designing db application, but tools like mergeant can (should) be used for that
09:07:31 <lisppaste2> joelr1 annotated #14302 with "allocaBytes" at http://paste.lisp.org/display/14302#10
09:07:43 <tromp> you alrd know that (y,x) /= Nothing...
09:08:04 <gour> dcoutts: or am i speaking nonsense?
09:08:23 <samx> tromp, "If the (cy, cx) square is yours and the square next to is is empty -> you are trying to put it on an adjacent square, and it should fail".. "If the (cy, cx) square is yours, but the adjacent square is populated, there are opponent pieces between, and the move is ok"
09:08:28 <jethr0> sry, can't figure that out so easily...
09:09:16 <tromp> oh, you still haven't put your piece at (y,x)!
09:09:17 <samx> tromp, you don't know that (y,x) /= Nothing.. as the counters (cy, cx) get incremented before checking the square
09:09:30 <samx> tromp, yes!
09:09:35 <tromp> i assumed you put the piece there before testing validity:)
09:09:44 <tromp> my mistake:(
09:10:09 <tromp> still, this test is only needed in the first iteration
09:10:28 <jethr0> samx, the algo is actually quite simple. pick a stone of your color and a direction. if the next stone is empty or same color, stop. else look for an empty field after the row of other colors
09:10:30 <jethr0> *puh*
09:12:12 * SamB starts old version of lambdabot rather than wait for latest to pull...
09:12:13 <jethr0> isvalid pt dir = let next = pt+dir in case next of empty -> False; sameColor -> False; otherwise -> findEmptyAfterRowOfOtherColor next dir
09:13:45 <joelr1> dcoutts: ping
09:14:40 <araujo> Hello Haskell'ers!
09:14:47 <jethr0> hello araujo
09:14:48 * kzm_ grunts.
09:16:17 <araujo> Hello jethr0 kzm_ 
09:16:20 <araujo> What's up? :-)
09:17:19 <jethr0> nut'n much. we'd hoped you bring the action with you...
09:17:37 <dcoutts> joelr1, yarr!
09:17:41 <kzm_> Even the lambdabot is asleep, it seems.
09:17:48 <araujo> haha
09:17:50 <joelr1> dcoutts: i need to use a foreign function like this
09:17:56 <kzm_> @botkick
09:17:57 <_samb_lambdabot> Unknown command, try @listcommands.
09:18:04 <araujo> jethr0, Well, i bring a lot of hungry (got back from univ.)
09:18:11 <araujo> hunger*
09:18:14 <joelr1> foreign import ccall unsafe "uncompress" uncompress_ ::
09:18:14 <joelr1>     Ptr Word8 -> Ptr CULong -> Ptr Word8 -> CULong -> IO CInt
09:18:26 <psi> yay, the gtk2hs build problem i had yesterday has vanished
09:18:26 <araujo> dcoutts, hi!
09:18:28 * kzm_ kicks the bot, but the expected <clank> isn't heard.
09:18:28 <joelr1> but i have a IOUArray Int ... 
09:18:37 <joelr1> dcoutts: how do i go to a Ptr Word8?
09:18:43 <kzm_> @seen
09:18:44 <_samb_lambdabot> I haven't seen .
09:18:54 <kzm_> @karma KZM
09:18:55 <_samb_lambdabot> KZM has a karma of 0
09:18:58 <kzm_> @karma kzm
09:18:59 <_samb_lambdabot> kzm has a karma of 0
09:19:04 <jethr0> well, samb's lambdabot doesn't know much
09:19:06 <dcoutts> gour, I was thinking the data-bound widgets like the combo-box and form and grid would be most useful. And those are exactly the ones that would be possible to do with what I'm working on in the tree/list/view stuff.
09:19:10 <kzm_> @karma LambdaBot
09:19:11 <_samb_lambdabot> LambdaBot has a karma of 0
09:19:14 <jethr0> @karma+ samb
09:19:15 <_samb_lambdabot> samb's karma raised to 1.
09:19:18 <kzm_> @karma lambdabot
09:19:19 <_samb_lambdabot> lambdabot has a karma of 3
09:19:25 <hulahub> how to use UArray? x :: UArray ... no...
09:19:40 <kzm_> bah.  Old code.
09:19:43 <SamB> @karma SamB
09:19:44 <_samb_lambdabot> You have a karma of 1
09:20:03 <SamB> @index UArray
09:20:05 <_samb_lambdabot> Data.Array.Unboxed
09:20:14 <SamB> okay, it at least does the basics
09:20:49 <SamB> oh, I don't think you can use the "> " notation
09:21:00 <SamB> use @eval instead
09:21:18 <SamB> > "hello"
09:21:36 <gour> dcoutts: that's fine, what about supporting libgda functions?
09:21:41 <int-e> @eval take 10 $ 1:scanl (+) 1 xxxx
09:21:45 <_samb_lambdabot> (line 1, column 20):
09:21:45 <_samb_lambdabot> unexpected "+"
09:21:45 <_samb_lambdabot> expecting simple term
09:21:47 <hulahub> SamB: Data.Array.Unboxed... .... ... but how to init a function using this data ? :D i imported Data.Array but x :: [UArray] does not work
09:21:47 <dcoutts> joelr1, well I'd use allocaArray or withArray, see http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
09:22:22 <dcoutts> gour, the point is we'd not need to bind libgda, just use an existing Haskell SQL/DB api
09:22:22 <SamB> hmm, apparantly my @eval is the ancient non-Haskell version
09:22:22 <SamB> use @plugs instead
09:22:27 <phys_rules_> hoi everyone ;)
09:22:32 <int-e> @plugs take 10 $ 1:scanl (+) 1 xxxx
09:22:38 <_samb_lambdabot> Fail: /usr/lib/ghc-6.2.2/package.conf: openFile: does not exist (No
09:22:38 <_samb_lambdabot> such file or directory)
09:22:38 <_samb_lambdabot>  
09:22:39 <joelr1> dcoutts: that works with lists, though
09:22:46 <SamB> oh right
09:22:48 <int-e> eek :)
09:22:50 <SamB> okay, so I have no features
09:22:58 <SamB> somebody else build with features
09:23:26 <dcoutts> joelr1, so there are two ways, use withArray and use getElems on the array
09:23:34 <dcoutts> joelr1, which goes via a list
09:23:54 <joelr1> dcoutts: that's 1 way, no?
09:24:01 <joelr1> dcoutts: because withArray takes a list
09:24:01 <kzm_> :-)
09:24:08 <joelr1> @index withArray
09:24:15 <dcoutts> or use allocaArray and then in aloop use poke + advancePtr
09:24:18 <_samb_lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
09:24:22 <gour> dcoutts: sounds good...however i'm not too much familiar with the whole gnomedb stuff
09:24:35 <dcoutts> gour, me neither
09:24:36 <SamB> also, I am often badly lagged
09:24:47 <joelr1> dcoutts: i think withArray + getElems is easier, what do you recon?
09:25:27 <dcoutts> joelr1, that is easier. The other way might be faster. Do the first unless you find that part of the program is a performance hot-spot.
09:26:54 <Sven_Moller_Fah> i know im a pain in the ass but i have been trying for hours to do this...can someone PLEASE tell me how to go from ["1 Tartaruga Teresa","2 Lebre Laura","3 Mosca Maria"], to ["1","Tartaruga Teresa","2","Lebre Laura","3","Mosca Maria"]....ill put you all on my christmass list...i promisse ill leave!!!
09:27:24 <SamB> Pupeno: I think I figured out why you need that context in the instance declaration
09:27:40 <gour> dcoutts: so i cannot say what is really required, although i'd like to use e.g. sqlite3 database in my application and have the whole database management stuff on disposal
09:28:09 <gour> dcoutts: i do not know if you're e.g. familiar with some chess-database applications...
09:28:45 <gour> dcoutts: you have a separate chess-engine (used for playing the game), plus database capabilities
09:28:56 <dcoutts> gour, ACCEPT_KEYWORDS="~x86" USE="sqlite" emerge -pv hsql
09:28:56 <SamB> in the report it says that that contexts of that type apply when calling or pattern matching against the data constructors of the type they are given for
09:29:02 <gour> dcoutts: so, it's not just a question of showing something
09:29:23 <SamB> nothing about implication of such context in type sigs, which actually makes a great deal of sense...
09:29:49 <gour> dcoutts: i'm still "~amd64", did that, but didn't get into it (too early), i'm still designing my application in mind only :-)
09:30:25 <gour> dcoutts: or let's say i'm learning the stuff which should be part of the 'engine' itself ;)
09:31:10 <SamB> isn't there already a chessboard/chess engine protocol?
09:31:33 <shapr> There's a standard machine readable notation.
09:31:42 <SamB> yeah, thats what I thought
09:31:51 <shapr> lambdabot had a chess playing plugin for awhile.
09:32:01 <SamB> shapr: how did it work?
09:32:02 <gour> SamB: yes, xboard & uci
09:32:11 <SamB> maybe I have it ;-)
09:32:14 <joelr1> dcoutts: how would you go back from a chunk of memory to a mutable byte array?
09:32:22 <shapr> alpha beta search, iirc
09:32:23 * SamB has a really old lambdabot
09:32:24 <SamB> @version
09:32:25 <_samb_lambdabot> lambdabot 3p465, GHC 6.4 (Linux i686)
09:32:25 <_samb_lambdabot> darcs get /home/naesten/hacking/haskell/lambdabot/base
09:32:28 <dcoutts> joelr1, same process, copy it.
09:32:28 <joelr1> ah, peekArray
09:32:44 <gour> SamB: however, i'm just using example of chess, don't have intention to write one more
09:32:54 <SamB> ah
09:33:01 <shapr> I think the chess plugin was in the pre-1.0 version of lambdabot, you can find that in haskell-libs.
09:33:23 <SamB> @listmodules
09:33:24 <_samb_lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
09:33:24 <_samb_lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
09:33:24 <_samb_lambdabot> spell state system todo topic type version vixen where
09:33:26 <gour> SamB: the point is whether 'gtk2hs' needs bindings for gnomedb stuff or not
09:33:38 <gour> Samb: what do you think?
09:34:11 <SamB> gour: well, I think I have no idea whether those are particularly more useful than the existing haskell database stuff
09:34:48 <SamB> I mean, are there any particular features that gnomedb has, besides being available almost wherever GNOME is?
09:35:11 <gour> SamB: the 'consensus' is we miss gnomedb widgets
09:35:27 <SamB> what do they look like, and what are they for?
09:36:04 <dcoutts> SamB, gnomedb provides some conventient widgets which you can directly connect to a DB model and use that to display and edit data from a query etc
09:36:12 <gour> SamBSamB: see http://www.gnome-db.org/docs/libgnomedb/ch06.html
09:36:28 <dcoutts> SamB, it makes it quicker to build gui db apps.
09:36:32 <joelr1> @index advancePtr
09:36:33 <_samb_lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
09:37:03 <dcoutts> SamB, the kind of thing that VB is actually quite good at: quickly throwing together a little custom DB viewer / editor.
09:37:31 <SamB> hmm
09:37:34 <dcoutts> SamB, the alternative is to implement data-bound widgets in Haskell using a Haskell DB API.
09:37:45 <gour> dcoutts: and we could have a 'uniform' style, the same as for e.g. gtk+
09:37:52 <dcoutts> it's not obvious which is harder
09:37:59 <SamB> well, how does the API look?
09:38:15 <gour> dcoutts: and if we make another higher-level api for gtk2hs...
09:38:26 <dcoutts> actually I think the gnomedb api is not great. It's complex.
09:38:51 <dcoutts> but it'd be quite a lot of work to re-implement in Haskell.
09:39:20 <SamB> well, you don't need to reimplement the same API...
09:39:58 <dcoutts> in particular it's not obvious if it'd be harder to make a high level api on top of gnomedb widgets or to implement similar features on top of gtk2hs + hsql (or some other Haskell DB API)
09:40:41 <gour> when you say 'harder' does it mean 'it requires more time' or something else?
09:41:27 <dcoutts> yeah, I mean time and thought
09:41:36 <gour> or let's say it in different way: if you would have complete gnomedb bindings available today, what would you use for db application?
09:41:57 <kolmodin> about conjure: is it ok to add a preprocessor flag, QUICKCHECK, to avoid compiling and depending on QuickCheck when building for release? or should any attempt of that be stoppend and the author of that be shot?
09:43:21 <gour> dcoutts: i consider that having gnome db ready, mean one can use 'normal' gnome way of doing things like in the case of gtk+, but if higher-level api is provided, even better, sort of 'standard'
09:43:51 <kolmodin> SamB: I though you might have an oppinion on that, what do you think?
09:44:45 <gour> it looks nobody is doing Qt bindings, so having gnomedb would make a complete gnome framework in haskell
09:48:43 <dcoutts> gour, well I'm not planning on working on gnome db bindings soon, but I'd be happy to include them if you decided to have a go.
09:51:13 <gour> dcoutts: fair
09:52:10 <SamB> kolmodin: where is QuickCheck depended on?
09:52:34 <SamB> anyway, we are nothing like ready for release
09:52:36 <kolmodin> nowhere, yet
09:53:01 <kolmodin> but to write a proper Gen for InterestTable we need the internal contsructors to it
09:53:14 <kolmodin> which aren't (and shouldn't be) exported
09:53:19 <SamB> ah
09:53:57 <SamB> just do it
09:54:04 <SamB> I mean, depend on QuickCheck
09:54:21 <SamB> you can put in and #ifdef QUICKCHECK if you like, but no worries
09:55:21 <SamB> btw, make sure to generate reasonably big tables
09:55:41 <SamB> that is, a fair number should have more than 10 pieces
09:56:17 <kolmodin> sure
09:56:32 <SyntaxNinja> woot
09:56:51 <SamB> you may notice the "5*n+1" formula in the current Gen?
09:56:52 <dcoutts> SyntaxNinja, success?
09:57:01 <kolmodin> SamB: right
10:00:06 * SamB thinks darcs should have a repo transfer format
10:00:26 <Heffalump> SamB: was it you I compressed a repo for some time back?
10:00:35 <jethr0> samb: i'm trying to have "do" inside a let, but ghci keeps annoying about indentation...
10:00:38 <SamB> Heffalump: I believe so
10:00:47 <SamB> maybe it would take too long to unpack, though
10:00:55 <Heffalump> I was thinking about making something along those lines after that.
10:01:02 <SamB> I guess I could mail someone a CD...
10:01:02 <jethr0> any ideas?
10:02:48 <SyntaxNinja> dcoutts: always
10:03:05 <SyntaxNinja> I had a cabal idea, but I think it might just be One More Feature.
10:03:28 <SyntaxNinja> we could generate a file, something like PackageName.CabalInfo, and then compile it into all libs and executables
10:03:42 <SyntaxNinja> so then programs could have access to stuff like their own version number, package name, etc.
10:04:00 <SyntaxNinja> but I don't know why anyone would need most of that info, except version number maybe.
10:04:16 <SyntaxNinja> you could turn this feature on w/ the .cabal file.
10:04:23 <SyntaxNinja> so it wouldn't always get generated.
10:05:05 <SyntaxNinja> but maybe you'd want the synopsis for the command-line --help output or something?
10:06:58 <SyntaxNinja> tap tap. this thing on?
10:07:19 <SyntaxNinja> Sven_Moller_Fah: ask questions here.
10:07:24 <Sven_Moller_Fah> i tried...
10:07:31 <kolmodin> dcoutts is away
10:07:44 <Sven_Moller_Fah> ive been here for hours
10:08:22 <Sven_Moller_Fah> PLEASE tell me how to go from ["1 Tartaruga Teresa","2 Lebre Laura","3 Mosca Maria"], to ["1","Tartaruga Teresa","2","Lebre Laura","3","Mosca Maria"]
10:08:39 <SyntaxNinja> @type take
10:08:45 <_samb_lambdabot> forall a. Int -> [a] -> [a]
10:08:53 <kolmodin> @type lex
10:08:56 <SyntaxNinja> @type splitAt
10:08:57 <_samb_lambdabot> ReadS String
10:09:00 <_samb_lambdabot> forall a. Int -> [a] -> ([a], [a])
10:09:14 <SyntaxNinja> > splitAt 2 "1 foobar" 
10:09:37 <SyntaxNinja> Sven_Moller_Fah: who has been helping you here?
10:09:53 <Sven_Moller_Fah> well about 3 hours ago someome did, cant remember name
10:09:53 <jethr0> sven, i had pasted a solution a while ago. hopefully i put it on lisppaste...
10:10:07 <Sven_Moller_Fah> u did?
10:10:13 <Sven_Moller_Fah> let me scroll
10:10:46 <SyntaxNinja> Sven_Moller_Fah: what have you tried so far, and where have you run into trouble?
10:10:46 <jethr0> http://paste.lisp.org/display/14330
10:10:52 <SamB> jethr0: well, your indentation is probably messed up
10:11:07 <SamB> (hows that for a helpful answer?)
10:11:09 <Sven_Moller_Fah> well ive tried everything
10:11:18 <jethr0> hmm, thx. but how does haskell differentiate between the end of a let and the end of a do?
10:11:32 <SamB> jethr0: it doesn't
10:11:36 <SamB> they are the same
10:11:44 <SamB> well, except a let has to have an in
10:12:14 <jethr0> sven, i'm pretty sure there's a nicer solution (maybe even a standard func), but this is the best i could do ;-))
10:12:31 <jethr0> samb, so how can i possible indent it correctly?
10:12:41 <jethr0> let x = do
10:12:54 <jethr0>   y <- v
10:12:59 <jethr0>   return v * 2
10:13:29 <SamB> well, you can't indent the "y <- v" line less than the "x = do"
10:13:40 <SamB> in fact, you must indent it more
10:13:58 <SamB> you could do
10:14:05 <jethr0> aahhh, so indentation starts at "x ="
10:14:09 <jethr0> hadn't realised that!
10:14:12 <SamB> yes, yes
10:14:26 <jethr0> thx
10:14:28 <SamB> let me show you what the report says, it may be interesting if you can understand any of it
10:15:02 <SamB> http://www.haskell.org/onlinereport/syntax-iso.html#layout is the definition
10:15:14 <SamB> http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout is an informal discussion
10:15:21 <Sven_Moller_Fah> can u tell me why this doesnt work?
10:15:21 <Sven_Moller_Fah> divide :: String -> [String]
10:15:21 <Sven_Moller_Fah> divide (s:lst) 
10:15:21 <Sven_Moller_Fah> 	|read s :: Int = s : divide lst
10:15:21 <Sven_Moller_Fah> 	|otherwise = divide lst
10:15:23 <SyntaxNinja> Sven_Moller_Fah: is this homework?
10:15:28 <Sven_Moller_Fah> no
10:15:59 <jethr0> sven: as i said before, read will fail if given a type with wrong content
10:16:13 <jethr0> > read "sdf" :: Int
10:16:21 * SamB has to wonder how many people who say no are honest -- after all, while those in the know know that it is best to tell the truth in this, those who don't know don't know
10:16:27 <jethr0> samb, where did your lambdabot go?
10:16:33 <int-e> reads does a slightly better job here
10:16:36 <SamB> go?
10:16:39 <SamB> isn't it here?
10:16:42 <Sven_Moller_Fah> but what you posted is so complicated...its no use if i dont understand it
10:16:48 <Sven_Moller_Fah> it must be a simpler way
10:16:50 <SamB> oh, it is an old version :-(
10:16:54 <jethr0> i can explain it!
10:16:59 <SamB> jethr0: you can compile a newer version
10:17:02 <jethr0> and it already solve your whole problem
10:17:08 <SamB> @hugs read "sdf" :: Int
10:17:08 <int-e> map (reads :: ReadS Int) ["foo", "42bar", "23 foo bar", "bar 42"] --> [[],[(42,"bar")],[(23," foo bar")],[]]
10:17:10 <_samb_lambdabot> Fail: /usr/lib/ghc-6.2.2/package.conf: openFile: does not exist (No
10:17:10 <_samb_lambdabot> such file or directory)
10:17:10 <_samb_lambdabot>  
10:17:11 <jethr0> haha, why's yours gone?
10:17:36 <jethr0> @lambda eval "read "sdf" :: Int"
10:17:38 <SamB> jethr0: it isn't! it just doesn't support that notation
10:17:38 <_samb_lambdabot> Unknown command, try @listcommands.
10:17:45 <jethr0> @eval "read "sdf" :: Int"
10:17:46 <_samb_lambdabot> type error
10:17:46 <SyntaxNinja> Sven_Moller_Fah: his solution looks fine to me
10:17:52 <SamB> huh?
10:18:04 <SamB> jethr0: its @eval is not Haskell
10:18:07 <SamB> its that old
10:18:15 <jethr0> whatever ;-)
10:18:40 <SamB> about all its good for is @index and @docs
10:18:45 <SamB> and @google
10:18:49 <SamB> afaict
10:19:39 <SamB> at least any of the people who had priveledged access when I last pulled can tell it to @quit
10:19:54 <Sven_Moller_Fah> ok thx ill leave...realy realy realy sorry to bother you all
10:19:55 <Sven_Moller_Fah> cya
10:20:07 <jethr0> n/p
10:20:22 <SamB> don't you hate it when they do that?
10:20:23 <jethr0> wtf is his problem?
10:20:35 <jethr0> was that sincere or sarcastic. i really can't tell
10:20:52 <SamB> the most bothersome thing he did was quit unexpectedly
10:21:00 <SamB> afaict
10:21:07 <jethr0> what more can i do than paste a perfectly good solution and offer to explain it?
10:21:24 <SamB> jethr0: bug other people to help him?
10:21:34 <SamB> thats all I can think of ;-)
10:21:36 <jethr0> ??
10:21:58 <jethr0> but i didn't. didn't speak to a soul about helping heim
10:21:58 <jethr0> him*
10:22:13 <SyntaxNinja> I didn't get him
10:22:16 * int-e wants a version of Text.Regex.splitRegex that keeps the matched parts in the list ...
10:22:19 <SyntaxNinja> what a brat
10:22:25 <jethr0> hehe
10:22:33 <SyntaxNinja> it was sarcastic. he msg'd me begging for help and I told him to ask here.
10:22:35 <SamB> you said "what more can I do", and I told you the only thing I could think of ;-)
10:22:49 <jethr0> ah, ok
10:23:18 <int-e> (such a modified splitRegex would also help with this problem)
10:23:49 <jethr0> yes, true
10:24:16 <jethr0> a generic "split a string at whitespace and return a list of strings" would be nice too
10:24:18 <SamB> int-e: that would be good, yes
10:24:27 <jethr0> alternatively substitute whitespace with a predicate
10:24:28 <SamB> jethr0: we have that
10:24:34 <jethr0> isnt' there such function?
10:24:45 <SamB> @eval words "hello world"
10:24:46 <_samb_lambdabot> unbound variable: words
10:24:48 <jethr0> samb, didn't find it on first glancs
10:24:49 <SamB> hmm
10:24:57 <jethr0> true, words does exactly that *gg*
10:25:00 <SamB> not in evalI guess
10:25:02 <Oejet> He did wait several hours for an aswer to a question, but such is the environment of an IRC channel.
10:25:25 <jethr0> oejet, i pasted a solution shortly after his asking...
10:25:32 <SamB> Oejet: he didn't ask every hour did he?
10:26:04 <SamB> I suppose maybe he had to split and it wasn't his computer...
10:26:12 <jethr0> ;-)
10:26:25 <jethr0> enough of the guy everyone misunderstood (and maybe vice-versa)
10:26:40 <Oejet> SamB: I don't know.
10:27:01 <maitscha> hallo. i have two types. type Graph = [(Int,[Int])] and newtype WGraph a = WG [(a,[(a,Int)])] deriving Eq. How can I convert a Graph to type WGraph?
10:28:32 <SamB> maitscha: well, what do things mean there?
10:31:02 <maitscha> Graph and WGraph are the same, but WGraph also stores weights.
10:31:30 <SamB> ah
10:31:49 <SamB> how are you going to calculate weights?
10:32:06 <maitscha> I dont
10:32:24 <maitscha> I don't know how I will calculate weights in the future
10:32:58 <maitscha> I will convert WGraph to Graph.
10:33:10 <maitscha> I want convert WGraph to Graph.
10:33:33 <SamB> lets see
10:34:42 <int-e> @pl 1+1
10:34:43 <_samb_lambdabot> 2
10:35:33 <SamB> is this homework?
10:35:46 <maitscha> homework?
10:35:55 <SamB> I guess that is a "no"
10:36:06 <maitscha> hehe, no homework.
10:36:15 <int-e> @pl f re s = maybe [s] (\(p,m,t,_) -> p:m:f re t) (matchRegexAll re s)
10:36:16 <_samb_lambdabot> (line 1, column 8):
10:36:16 <_samb_lambdabot> unexpected "="
10:36:16 <_samb_lambdabot> expecting variable, "(", operator or end of input
10:36:56 <SamB> g2wg xs = WG [(node, [(arc, 1) | arc <- arcs]) | (node, arcs) <- xs]
10:37:06 <SamB> that should work
10:37:10 <SamB> or nearly so
10:38:16 <maitscha> hmmm.... I will try your basic approach, thx.
10:38:46 * SamB hopes maitscha doesn't run off unexpectedly
10:48:10 <jethr0> can anyone tell me where to find the irc channel logs?
10:48:35 <int-e> the topic
10:50:04 <int-e> there's also http://meme.b9.com/cdates.html?channel=haskell
10:50:14 <jethr0> sry and thx
10:53:33 <SamB> don't say sorry, that topic is a mess!
10:53:56 <int-e> indeed
11:00:59 <maitscha> what could be the reason for a "illegal type in constuctor application" error?
11:06:15 <SamB> maitscha: well, what is the whole error?
11:06:22 <astrolabe> I'm guessing, but if you have a type constructor, it expects to be followed by certain types
11:06:25 <SamB> there is a reason why GHC includes context in error messages
11:06:36 <astrolabe> if you use the wrong ones, you'll get an error.
11:09:06 <maitscha> hmmm... I think I should read again the chapter about type definitions...
11:09:29 <maitscha> transform :: Eq a =>  (WGraph a) -> Graph
11:09:29 <maitscha> transform (WG g) = [(knoten, [(kante) | (kante,gewicht) <- kanten]) | (knoten, kanten) <- g]
11:10:25 <maitscha> all beginning is hard
11:11:18 <maitscha> Inferred type is not general enough
11:12:41 <maitscha> So I will use Int, and all works fine.
11:13:27 <int-e> ah, because a Graph has Ints as labels ...
11:13:38 <int-e> (see your type for Graph)
11:17:12 <SamB> oh, did I do the transformation backwards?
11:19:39 <joelr1> how can you shorten this?
11:19:41 <joelr1>               do bytes <- readBIO fb
11:19:43 <joelr1>                  bytes' <- freeze bytes
11:19:56 <joelr1> is there something like freeze << readBIO fb?
11:20:09 <maitscha> SamB: yes, but no problem. I have it already.
11:20:22 <SamB> joelr1: are you writing it everywhere?
11:20:32 <joelr1> SamB: not really, just curious
11:20:43 <SamB> I don't know of one...
11:20:56 <SamB> oh, you mean can you do something like that
11:21:08 <joelr1> yes
11:21:30 <joelr1> if you are in the IO monad and have two actions where one feeds into another
11:21:36 <SamB> you could try "bytes <- unsafeFreeze =<< readBIO fb"
11:21:47 <SyntaxNinja> bytes <- readBIO fb >>= freezeBytes
11:22:07 <joelr1> that surely looks funky. thanks SyntaxNinja 
11:22:11 <SamB> @index freezeBytes
11:22:12 <SyntaxNinja> er s/freezeBytes/freeze
11:22:12 <_samb_lambdabot> bzzt
11:22:20 <SyntaxNinja> bytes <- readBIO fb >>= freeze
11:22:31 <SamB> SyntaxNinja: why freeze?
11:22:32 <SyntaxNinja> >>= is the "feed one monadic operator into the next" function
11:22:42 <SyntaxNinja> SamB: because that's what his example was?
11:22:43 <SamB> unsafeFreeze can be non-copying
11:22:52 <SyntaxNinja> @type (>>=)
11:23:01 <_samb_lambdabot> forall (m :: * -> *) b a.
11:23:01 <_samb_lambdabot>    (Monad m) =>
11:23:01 <_samb_lambdabot>    m a -> (a -> m b) -> m b
11:23:41 <SamB> @ghci "Hello"
11:23:42 <_samb_lambdabot>  Inaccessible case alternative
11:23:49 <SamB> hmm?
11:23:49 <SamB> @ghci "Hello"
11:23:51 <_samb_lambdabot>  Inferred type is less polymorphic than expected
11:23:57 <SamB> oh, thats just the @ghc
11:29:52 <SamB> musasabi: did you get a patch together yet for any of what you did?
11:30:11 <SamB> you have enough at this point that you probably should get a patch out
11:30:26 <SamB> "early and often" and all that
11:59:01 <SamB> note that my lambdabot is going to be off until it can get the nick it wants, apparantly
12:20:42 <helm> hi reddi
12:20:50 <reddi> hi ;-)
12:21:44 <helm> could somebody help me to solve a problem 
12:21:46 <helm> how to
12:21:51 <helm> filter a list?
12:22:22 <helm> filter(\(x,_)->x==e) some_list works fine
12:24:31 <helm> filter(\(x,y)->x==e && y==w)  some_list gives me 
12:24:34 <helm> ERROR "Aufgabe6.hs":60 - Inferred type is not general enough
12:24:47 <helm> any hints?
12:25:20 <helm> fyi some_list is a list of tuples
12:31:45 <Igloo> You'll need to give us more info
12:32:08 <wilx> @type List.filter
12:32:14 <wilx> Ah.
12:32:20 <_samb_lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:32:23 <wilx> Oh.
12:36:28 <helm> some_list is of type [(a,Int)]
12:37:30 <helm> thank you, guys!
12:37:48 <helm> i found the reason for the error-message
12:39:15 <helm> the problem was that i did not take into account
12:39:34 <helm> that the 2nd part of my tuple is of type Int 
12:39:39 <helm> thank you!
12:40:37 <SamB> musasabi: where can I download your patches?
12:40:55 <SamB> dons: did you notice lambdabot died again?
12:51:20 <maitscha> ERROR "Graph.hs":65 - Inferred type is not general enough
12:51:34 <maitscha> *** Expression    : viceVersa2
12:51:34 <maitscha> *** Expected type : Graph -> (a,[a]) -> Bool
12:51:34 <maitscha> *** Inferred type : Graph -> (Int,[Int]) -> Bool
12:51:35 <SamB> maitscha: more of the message, please?
12:51:39 <SamB> ah, there we go
12:51:55 <SamB> okay, you wrote a type signature somewhere?
12:52:10 <maitscha> type Graph = [(Int,[Int])]
12:52:11 <SamB> which is relevant to this error?
12:52:34 <maitscha> viceVersa2 :: Graph -> (a,[a]) -> Bool
12:53:22 <SamB> well, what is the (a,[a]) for?
12:54:58 <SamB> I mean, why isn't it Graph?
12:59:10 <maitscha> (a,[a]) is only a node with some vertex
13:01:51 <reddi> maitscha: tu vienna?
13:02:07 <reddi> knoop gg?
13:02:44 <SamB> maitscha: you at least need to replace (a,[a]) with (Int,[Int])
13:04:34 <maitscha> reddi: right
13:04:56 <maitscha> reddi: you are not alone
13:09:37 <SamB> @seen musasabi 
13:09:47 <_samb_lambdabot> musasabi is in #haskell. I don't know when musasabi last spoke.
13:16:00 <astrolabe> SamB ping
13:17:14 <SamB> astrolabe: ping.
13:17:14 <SamB> er, pong
13:17:54 <SamB> what is the purpose of this ping/pong?
13:18:24 <astrolabe> I think yesterday, you thought you might have a paper relevant to my problem
13:18:45 <SamB> astrolabe: what was your problem?
13:19:09 <astrolabe> Which was: given a set of vectors, and a target vector, find a subset of the set with sum as close as possible to the target.
13:19:46 <SamB> astrolabe: oh, no, sorry!
13:20:03 <astrolabe> Ah, misunderstanding.  ok.
13:20:28 <SamB> I was mostly talking to joelr
13:20:53 <SamB> I wondered why you wanted me to let you know if I found something
13:20:59 <astrolabe> hmmpf.  boring poker problems :)
13:21:37 <sieni> astrolabe: that sounds like integer programming
13:21:47 <sieni> or something like that
13:21:51 <SamB> astrolabe: well, we don't help with the poker stuff
13:22:07 <astrolabe> sieni: thanks, I'll google it.
13:22:21 <SamB> astrolabe: I have no idea what the proper way to do that sort of thing is
13:22:24 <sieni> sort of
13:22:55 <sieni> http://en.wikipedia.org/wiki/Linear_programming#Integer_unknowns
13:23:01 <astrolabe> SamB: me neither, and I'm a mathematician :(
13:23:25 <SamB> however, I know how to write a function on lists that computes all the subsets
13:24:00 <astrolabe> Ah, well, thanks, but I was after something more efficient :)
13:25:10 <SamB> try #math yet?
13:25:44 <astrolabe> no.  I s'pose that would be more logical.  There seems to be something in sieni's link
13:26:53 <astrolabe> NP-hard :(
13:27:56 <sieni> astrolabe: indeed, your problem is exactly called 0-1 integer programming in mathematics
13:28:41 <sieni> well, maybe not quite, but close enough
13:28:51 <SamB> subsets [] = [[]]; subsets (x:xs) = subsets xs ++ map (x:) (subsets xs)
13:28:54 <jeffno> NP problems usually have "good-enough" approximations.
13:28:56 <SamB> thats the easy definition ;-)
13:31:40 <Heffalump> jeffno: go on then, what's a good enough approximation for factoring large numbers? :-)
13:32:03 <jeffno> *usually* :)
13:32:18 <SamB> then you just do "snd $ head $ map (sum &&& id) $ map (target:) (subsets set)"
13:32:20 <astrolabe> That's not np-hard is it?
13:32:37 <astrolabe> at least not known to be
13:33:10 <Heffalump> true.
13:33:11 <Cale> Well, naive algorithms actually work reasonably well if the large numbers aren't contrived in some way
13:33:22 <jeffno> That's public-private key what encryption hinges on.
13:33:34 * jeffno reformats that sentence.
13:34:19 <Cale> afaik, it's not actually known that factoring integers is hard, it's just not known to be easy
13:34:28 <SamB> hehe
13:35:19 <SamB> astrolabe: try that! maybe it works?
13:36:05 <SamB> oh, only s/target/(-target)/
13:36:13 <astrolabe> SamB:  I'm not into obfuscating my code :p
13:36:15 <SamB> and sort
13:36:46 <SamB> oh, well, thats not intentionally obfusticated. just that its hard to write one-liners without points-free style
13:37:08 <SamB> and writing non one-liners is difficult in a one-line text-entry
13:37:12 <astrolabe> Also, I'm going to spend some time looking for a faster algorithm.  But thanks anyway.
13:37:17 <SamB> hehe
13:37:37 <SamB> you are supposed to do the simplest thing that could possibly work!
13:37:45 <astrolabe> Sorry, anything with '&&&' in is too complicated for me.
13:37:53 <SamB> that is like easy
13:38:06 <SamB> just because it comes from Control.Arrow doesn't make it bad
13:38:25 <astrolabe> SamB: I've heard that, but I don't think that could possibly work, it's too slow.
13:38:35 <SamB> try first!
13:38:49 <SamB> unless your sets are known to be huge
13:38:58 <astrolabe> Your first function was fine :)
13:39:42 <astrolabe> My sets are moderately big ~100 vectors, but 2^100 = *&^%$
13:40:00 <SamB> uh huh
13:40:06 <SamB> that does sound a bit big
13:40:20 <astrolabe> Also, my algorithm will use that lots of times.
13:40:23 <SamB> so what is "close enough"
13:40:25 <SamB> ?
13:40:40 * astrolabe thinks
13:40:42 <SamB> and where do these vectors come from?
13:41:20 <sieni> astrolabe: if you want to find something "good enough", you might try e.g. simulated annealing or something similar
13:42:25 <SamB> I think that algorithm is probably pretty close to the best one, only without the ++...
13:42:35 <astrolabe> sieni: LOL.  that is exactly what I'm trying to avoid
13:43:00 <SamB> well, you should try to find some less expensive means of avoidance
13:43:55 <astrolabe> Ok, my real problem is that I have a set of binary variables, and a cost function on the set of values of those variables, ie on {0,1}^n
13:44:01 <dons> moin moin
13:44:09 <SamB> dons: lambdabot is dead
13:44:15 <SamB> fixorate
13:44:22 <sieni> astrolabe: you want to avoid simulated annealing or a "good enough" solution
13:44:23 <dons> fixorating!
13:44:25 <SyntaxNinja> hi dons
13:44:27 <SamB> my build is too old
13:44:31 <SamB> it doesn't know anything
13:44:50 <SamB> @eval words "is not haskell"
13:44:52 <_samb_lambdabot> unbound variable: words
13:45:08 <astrolabe> I can write the cost fn as a sum of +ve defn quadratics, and hence the whole thing as a +pse definite quadratic (well, non-negative definite to be accurate)
13:46:01 <PupenoL> lambdabot is written in Haskell ?
13:46:14 <SamB> @quit
13:46:15 <lambdabot> Not enough privileges
13:46:28 <wilx> PupenoL, yes.
13:46:33 <SamB> > "Hello again!"
13:46:34 <PupenoL> wilx: nice.
13:46:34 <lambdabot> "Hello again!"
13:46:48 <dons> @version
13:46:49 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
13:46:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
13:46:55 <dons> you can get it from there ^^
13:47:01 <kzm_> @botkick
13:47:02 <lambdabot> Unknown command, try @listcommands.
13:47:10 <kzm_> Hmm... important functionality is missing, dons :-)
13:47:27 <PupenoL> A new parameter for comparing languages: go to its channel and see how smart is the local bot (when developed in the language itself).
13:47:28 <kzm_> (sorry about that, btw.  Didn't mean no disrespect)
13:47:31 <dons> oh, Iii meant to ask, what's the url for your repo?
13:47:46 <dons> kzm_, probably it would be best for you to `darcs send' patches anyway
13:47:54 <dons> then they get processed with my morning coffee :)
13:48:19 <SamB> dons: about that, why does lambdabot space out like that?
13:48:25 <kzm_> No, I think you got all the ...I hesitate to call them 'important', but for lack of a better word ... ones
13:48:33 <dons> it doesn't know how to reconnect in certain cases
13:48:55 <dons> so the network flaked, but lambdabot was blissfully unaware
13:49:03 <dons> and then was just stuck in limbo.
13:49:15 <SamB> dons: apparantly it was sitting here the entire time, though!
13:49:18 <kzm_> @botsnack
13:49:18 <lambdabot> :)
13:49:24 <lambdabot> You're not the only one who needs a morning coffee, you know.
13:49:25 * kzm_ pats lambdabot on its head.
13:49:57 <dons> SamB, but it gets no further messages after the disconnect happens
13:50:09 <SamB> what disconnect?
13:50:55 <dons> there is some point where there's, say, a network dropout. and the irc hubs do something that lambdabot doesn't know about, I guess.
13:52:04 <SamB> you mean netsplits?
13:52:23 <Pseudonym> Might be worth logging all IRC protocol traffic and waiting for a network dropout.
13:52:29 <Pseudonym> This is freenode.  You wouldn't have to wait long.
13:52:34 <dons> not sure. i don't know exactly what the situatoin is.
13:52:39 <dons> Pseudonym, yeah, good idea.
13:52:43 <SamB> you could ask lilo to do some special ;-)
13:52:50 <dons> heh
13:53:40 <Pseudonym> Or even better, demand that he not.
13:54:08 <SamB> ooh!
13:54:23 <SamB> or, we could split up and try both approaches!
14:01:11 <dons> @seen phys_rules
14:01:12 <lambdabot> I saw phys_rules leaving #haskell-blah and #haskell 1 day, 21 hours, 22
14:01:12 <lambdabot> minutes and 36 seconds ago, and I have missed 1 day, 14 hours, 46 minutes
14:01:12 <lambdabot> and 2 seconds since then.
14:05:17 <bosie> howdy
14:07:27 <arguile> Hrm, I think my brain is melting
14:07:45 <Cale> arguile: :)
14:07:48 <Cale> what's up?
14:09:05 <arguile> I'm trying to generate the list of all numbers (float) bound on the upper range by n, that can be created by adding [Float] together
14:10:00 <arguile> For example start with [8,11] and the final set should be [8,11,16,17,22,24,27,32,33,34,35, 40] if n = 40
14:10:17 <SamB> hmm
14:10:32 <SamB> iterate something?
14:10:40 <SamB> @type iterate
14:10:41 <lambdabot> forall a. (a -> a) -> a -> [a]
14:11:09 <SamB> or do you mean you just add the original numbers together?
14:11:14 <SamB> that sounds hard anyways
14:11:15 <bosie> hmm guys, i have that problem:
14:11:15 <bosie> isWellformedWG (WG graph) =
14:11:15 <bosie> transform (WG graph)
14:12:01 <SamB> hmm, suspicious
14:12:20 <bosie> i will paste it
14:12:26 <SamB> you are using the same constroctor name as maitscha was!
14:12:32 <bosie> yea
14:12:37 <bosie> we both work on the same thing
14:12:40 <SamB> ah
14:12:45 <bosie> we are like best friends
14:12:53 <SamB> so you aren't the same person or anything
14:12:56 <SamB> ;-)
14:13:00 <bosie> i hope not
14:13:01 <bosie> ;)
14:13:08 <arguile> SamB: Yes, a*x + b*y + c*z ... d*z' <= n. For some arbitrary list of numbers
14:13:26 <bosie> but we both take the same course at univ and struggle with the same problem and well... teacher is an ass :(
14:13:27 <arguile> I was hoping for something sexy, I might just settle for a bunch of iterates
14:13:28 <Cale> arguile: um, 19?
14:13:29 <SamB> arguile: well, much the same as in any other language I suppose...
14:13:42 <SamB> bosie: oh?
14:13:49 <arguile> Cale: Err 17 == 19 if not typo
14:13:55 <SamB> maitscha said it was not homework...
14:13:56 <SamB> iirc
14:14:02 <bosie> nop
14:14:07 <bosie> we never have homework
14:14:12 <SamB> ah
14:14:34 <bosie> but since we just make theory in the course but the exam is pure haskell coding... you have to practice the theory throughout the year
14:15:56 <bosie> can we turn off the interrogation light please, SamB ? :D
14:16:59 <arguile> Heh, at least iterate will be better than what the list comprehension method turned into (it was originally just two floats)
14:17:06 <SamB> that is really ass-like behaviour!
14:17:24 <SamB> giving no homework but having an exam in pure Haskell
14:17:53 <bosie> hm, i am thankful we have no homework
14:17:59 <SamB> prof never heard of optional homework?
14:18:02 <bosie> but teaching just theory is the problem ;)
14:18:09 <bosie> lol whats optional HW?
14:18:14 <Cale> > let fix f x = let y = f x in if x == y then x else fix f y; sortNub = map head . group . sort; step n xs = takeWhile (<n) . sortNub $ xs ++ do x <- xs; y <- xs; return (x + y) in fix (step 40) [8,11]
14:18:16 <lambdabot> [8,11,16,19,22,24,27,30,32,33,35,38]
14:18:22 <SamB> oh
14:18:37 <bosie> what elite univ are you attending that there is optional homework?
14:18:38 <Cale> that's the first way I could think of
14:18:51 <SamB> none!
14:18:59 <bosie> even better! :D
14:19:02 <SamB> but it seems like such a simple concept!
14:19:09 <bosie> true
14:19:09 * jeffno agrees with SamB.
14:19:20 <Cale> I've had optional homework assignments
14:19:24 <SamB> aka "exercises"
14:19:35 <bosie> but with 500 students taking one course.... you have to get paid to correct the optional homework
14:19:49 <SamB> did I say anything about correcting it?
14:19:51 <jeffno> Why would you correct optional homework?
14:19:58 <bosie> hm
14:19:58 <SamB> what do you think the typechecker is for?
14:20:03 <dons> you'd just put up the solutoins somewhere, surely?
14:20:05 <dons> if that.
14:20:16 <bosie> what good will a not-corrected homework do?
14:20:20 * jeffno thinks all textbooks should come with fully provided solutions.
14:20:30 <SamB> it will give you an idea where to go in your practicing
14:20:40 <bosie> hm
14:21:16 <Cale> bosie: The corrections aren't the important part, it's the thinking.
14:21:47 <bosie> Cale hm i dont agree on that one, i think correction is important, since you can learn alot from the corrections
14:21:55 <bosie> if done by a person who knows haskell well
14:21:59 <sieni> bosie: well, at the math department at the university of helsinki, all the homework was (and probably still is) optional, although on some courses you can get bonus points, which are added to your exam total
14:22:00 <SamB> well, it might be a NICE THING
14:22:32 <Cale> Well, at the end of the day, you should be able to see if your program is working or not.
14:22:32 <SamB> but it is by no means critical to the value of doing the work
14:22:39 <Cale> If it's a programming course
14:22:55 <bosie> sieni we never have any homework except the course is 100% excercises. but for lectures ( i hope thats the right word) we never have :(
14:22:55 <Cale> but yeah, sure the corrections can be useful
14:23:27 <bosie> SamB as for the thinking... i do think cos i create my own problems i wanna solve with haskell... thats like an optional homework isnt it? :)
14:23:47 <SamB> bosie: thats like optional homework without any of the questions
14:24:04 <SamB> and, you know, its better to have some of the questions than all of the answers
14:24:35 <bosie> hehe normally i solve old exams, so i get an idea what the questions might be ;)
14:24:43 <SamB> ah
14:25:15 <bosie> guess why matischa and i are having the same newtype? ;)
14:25:42 <SamB> (that quote, as far as I know, is not related to school)
14:25:48 <Cale> arguile: does that code I pasted make sense?
14:25:51 <SamB> it was in an old exam?
14:26:10 <bosie> actually it was in the theory we learned today
14:26:47 <Cale> which newtype?
14:26:57 <bosie> newtype WGraph a = WGraph [(Int,[(Int,Int)])] deriving Eq
14:27:01 <Cale> ah
14:28:45 <arguile> Cale: Yes, thanks. It's sparked a "oh duh" moment. I'm pretty sure I can change my original method to fit with that
14:28:52 <arguile> Danke
14:28:59 <Cale> no problem
14:29:04 <bosie> arguile danke?
14:29:16 <arguile> boise: "Thank you" in german
14:29:20 <arguile> Though missing the accent
14:29:21 <SamB> bosie: actually, you didn't do it the same
14:29:29 <SamB> and it was WG
14:29:33 <bosie> SamB he was more creative?
14:29:39 <SamB> and you are supposed to use a somewhere
14:30:22 <SamB> like, maitscha used "newtype WGraph a = WG [(a, [(a, Int)])]", iirc
14:30:23 <bosie> yea it was WG but i tried WGraph now
14:30:42 <bosie> if he used it straight from the pdf yes
14:30:49 <bosie> arguile yo donk da sche i was ;)
14:32:19 <bosie> though i dont really understand why my functions wont work, if i may ask?
14:33:44 <SamB> bosie: what was the question again?
14:33:52 <SamB> (I didn't get it the first time)
14:33:54 <bosie> i havent asked so far
14:33:58 <SamB> oh
14:34:12 <SamB> that would explain why I don't understand the question ;-)
14:34:41 <dons> SamB, 42hrs with 0.2. I'm just going to leave it running till 0.3 comes out :)
14:35:10 <SamB> dons: I suppose I should grab hmp3 and start testing the latest then...
14:35:17 <bosie> well i wanna use the newtype thingie and we learned it that way:
14:35:17 <bosie> newtype WGraph a= WGgraph ... deriving EQ
14:35:17 <bosie> test :: Eq a => (WGraph a) -> Bool
14:35:17 <bosie> now i try to use that:
14:35:18 <bosie> test2 :: Eq a => (WGraph a) -> Bool
14:35:20 <bosie> test2 (WGraph graph) = test graph
14:35:34 <SamB> I've got 66:12 on 0.1p133
14:37:05 <dons> cool.
14:37:32 <SamB> I'm going to close it now and rebuild, if thats okay
14:37:50 <bosie> SamB i hope after you answered my question :DD
14:38:37 <SamB> bosie: no I'm not leaving, I'm just going to close my MP3 player
14:38:57 <SamB> oh, it doesn't seem to be quiting right
14:39:03 <SamB> might want to have a look at that...
14:39:03 <bosie> it isnt
14:39:18 <bosie> even test (WGraph graph) doesnt work due to ambigous type variable 'a'
14:39:20 <bosie> but why ?!?
14:40:12 <SamB> bosie: no idea!
14:40:17 <integral> a
14:40:30 <SamB> sounds wierd
14:40:40 <SamB> does the code compile?
14:40:44 <bosie> no
14:40:56 <bosie> Ambiguous type variable `a' in the constraint:
14:40:56 <bosie>   `Eq a'
14:41:04 <SamB> oh?
14:41:17 <bosie> no idea, i never worked with constraints ;)
14:41:34 <SamB> bosie: maybe its because you never use the "a" anywhere?
14:41:50 <bosie> oh
14:41:56 <bosie> hang on
14:42:40 <palomer> erm
14:42:54 <SamB> usually when I get that it means that some intermediate value could not have a single type inferred...
14:43:03 <palomer> my prof claims that you can't do  type inference with GADTs
14:43:04 <palomer> is this true?
14:43:25 <SamB> palomer: good question.
14:43:29 <dons> wasn't there a thread about this last week?
14:43:33 <SamB> why don't you read the documentation?
14:43:34 <bosie> SamB well, i even get it when i use the graph
14:43:43 <palomer> documentation on GADTs?
14:43:44 <SamB> bosie: no idea!
14:43:53 <SamB> palomer: GHC has docs, you know
14:44:01 <dons> um. but there's a paper: "Wobbly types:
14:44:07 <dons> practical type inference for generalised algebraic data types"
14:44:09 <dons> ..
14:44:28 <SamB> well, yeah.
14:44:29 <SamB> oh
14:44:50 <SamB> good point
14:45:01 <SamB> I even tried to read that paper
14:45:02 <SamB> never figured out what made the types wobbly though, iirc...
14:45:36 <Heffalump> it's true that you can't infer the types
14:45:42 <Heffalump> or rather, you have to give a top-level type signature
14:45:47 <Heffalump> and then type inference can take care of the rest
14:45:56 <dons> palomer, btw, http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
14:45:58 <SamB> ah
14:46:13 <lightstep> in "implementing functional languages: a tutorial", they use lambda-lifting, and so discard lambdas in their implementations. why not discard 'let' the same way?
14:46:16 <Heffalump> it's like most type system extensions; type inference doesn't break down completely, but you need a few well-place annotations to make things work
14:46:47 <dons> right. and that seems perfectly reasonable, since it's good form to write top level sigs anyway
14:51:14 <bosie> SamB thanks for the good old chat, i am off
14:51:46 <SamB> okay
14:51:52 <palomer> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html <--how does the pair constructor work here?
14:52:39 <SamB> palomer: the (,) in the type is phantom
14:52:47 <palomer> ho hum, I might do my thesis on GADTs
14:52:55 <palomer> (a professor has proposed it to me)
14:53:06 <palomer> SamB: but where does b pop in?
14:53:19 <SamB> "Term b"
14:53:19 <palomer> it's not a parameter
14:53:20 <dons> palomer, would be a pretty cool phd area to work in
14:53:37 <palomer> dons: masters
14:53:47 <palomer> she wants to see if type inference can be done with GADTs
14:53:48 <dons> still cool ;)
14:53:56 <SamB> palomer: the type variables in the sigs aren't bound at the top
14:54:02 <SamB> they are bound in the sigs
14:54:26 <palomer> so why is tha datatype signature Term a?
14:54:46 <SamB> well, it looks nicer than kind annotation...
14:55:08 <SamB> Indeed, one can write a kind signature instead:
14:55:08 <SamB>   data Term :: * -> * where ...
14:55:15 <dons> oh, SamB, come on .. kind annotations are beautiful :)
14:55:19 <SamB> or even a mixture of the two:
14:55:24 <SamB>   data Foo a :: (* -> *) -> * where ...
14:55:30 <SamB> The type variables (if given) may be explicitly kinded, so we could also write the header for Foo like this:
14:55:31 <palomer> gah!
14:55:32 <SamB>   data Foo a (b :: * -> *) where ...
14:55:34 <dons> all those ascii bits and blobs :)
14:55:48 <newsham> hi
14:56:01 <SamB> okay, so it is arguably prettier
14:56:06 <SamB> and arguably less pretty
14:56:07 <newsham> recommendations on http://www.lava.net/~newsham/x/machine/mand.lhs.txt ?
14:56:11 <palomer> I'm very confused
14:56:25 <SamB> palomer: do you know about kinds?
14:56:55 <palomer> slightly
14:57:10 <palomer> it's a type constructor, no?
14:58:01 <SamB> Term is indeed
14:58:26 <palomer> Term is a kind
14:58:26 <SamB> and it has kind * -> *
14:58:40 <palomer> right, shouldn't it be * -> * -> *?
14:58:56 <SamB> @kind Maybe
14:58:57 <lambdabot> * -> *
14:59:14 <palomer> shouldn't it be data Term whocares  where = ... ?
14:59:23 <SamB> could be
14:59:30 <SamB> but that looks uglier than
14:59:40 <SamB> data Term :: * -> * where
14:59:48 <palomer> yeah
14:59:54 <palomer> my problem is that a was bound twice in the expression
14:59:58 <palomer> quite confusing
15:00:10 <palomer> well, bound in 2 different scopes
15:01:40 <palomer> so there are two valid ways to construct datatypes
15:01:58 <palomer> data Foo :: * -> * where and data Foo where
15:02:09 <palomer> right?
15:02:40 <palomer> omg I have to learn haskell
15:02:59 <palomer> this is my christmas project
15:03:13 <newsham> :)
15:03:16 <newsham> merry christmas 
15:04:45 <Pupeno> Hello.
15:06:02 <Pupeno> C++ is add-hoc polymorphism, right ?
15:06:24 <Pseudonym> C++ supports all sorts of polymorphism.  Ad-hoc is but one.
15:07:10 <sieni> well, c++ has templates, which are kind of cool
15:07:11 <Heffalump> is there a name for template specialisation?
15:07:22 <Pupeno> bbl.
15:07:24 <Heffalump> (templates themselves presumably count as parametric polymorphism)
15:07:56 <Pseudonym> Instatntiation.
15:07:59 <Pseudonym> Instantiation
15:08:10 <Pseudonym> Yes, it's parametric polymorphism.
15:08:35 <Pseudonym> It's an early-binding form of parametric polymorphism, but it's still parametric polymorphism.
15:08:55 <Heffalump> fair enough
15:09:09 <Heffalump> btw, thanks for the placement new advice, it worked out really well
15:09:13 <newsham> anyone wanna look at my code and give me pointers?
15:09:15 <Pseudonym> Cool.
15:09:24 <newsham> (or rewrite the same thing for me to compare against)
15:09:28 <Pseudonym> newsham: If you wrote your code properly, it shouldn't have any pointers.
15:10:40 <newsham> it doesnt, thats why i need some
15:13:39 <Pseudonym> You're welcome to put your code on the paste page.
15:13:44 <Pseudonym> @paste
15:13:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:13:50 <newsham> > recommendations on http://www.lava.net/~newsham/x/machine/mand.lhs.txt ?
15:13:51 <lambdabot>  parse error on input `}'
15:13:55 <newsham> already in /last log
15:13:55 <Pseudonym> Ah, OK.
15:14:30 <tbfg> hi!
15:14:42 <Pseudonym> First thing, it's considered good style to put in type signatures.
15:18:41 <Pseudonym> Second comment:
15:18:45 <Pseudonym> > mandFunc cap x = cappedLength cap (mandSeries x)
15:18:46 <Pseudonym> > juliaFunc cap c x = cappedLength cap (juliaSeries c x)
15:18:46 <lambdabot>  parse error on input `='
15:18:47 <lambdabot>  parse error on input `='
15:18:56 <Pseudonym> Stupid lambdabot.
15:19:07 <newsham> or perhaps too clever :)
15:19:07 <Pseudonym> I see a pattern here.
15:19:21 <Pseudonym> But the pattern is even more obvious if you change the argument order:
15:19:31 <Pseudonym> juliaFunc c cap x = cappedLength cap (juliaSeries c x)
15:20:00 <Pseudonym> How about this instead:
15:20:27 <Pseudonym> iterationFunc f cap x = cappedLength cap (f x)
15:20:43 <Pseudonym> mandFunc = iterationFunc mandSeries
15:20:52 <Pseudonym> juliaFunc c = iterationFunc (juliaSeries c)
15:21:31 <Pseudonym> "iterationFunc" isn't a good name, but you get my drift.
15:24:15 <newsham> sounds reasonable except its only used those two times.
15:25:03 <Pseudonym> It is at the moment.
15:25:14 <Pseudonym> What about when you want to replace it with, say, a Newton fractal?
15:25:33 <Pseudonym> At any rate, it's better IMO to keep the argument order consistent.
15:25:44 <Pseudonym> "juliaFunc c cap x" rather than "juliaFunc cap c x"
15:25:54 <Pseudonym> Because it lets you do this kind of currying later if you want to.
15:25:56 <newsham> hmm.. how is that more consistent?  isnt that less consistent?
15:26:06 <newsham> since c and x are used together elsewhere
15:26:13 <Pseudonym> Where?
15:26:22 <Pseudonym> In mandFunc, cap and x are used together.
15:26:31 <newsham> sqSum for example
15:26:51 <Pseudonym> But that's a different x.
15:27:02 <Pseudonym> In sqSum, x is modified by the loop.
15:27:14 <Pseudonym> And in mandFunc, c means something different, too.
15:27:29 <Pseudonym> But the thing is, the link between juliaFunc and mandFunc is much tighter.
15:28:03 <Pseudonym> BTW, I'm being really anal here.  The code is quite good.
15:28:17 <Pseudonym> You know your code is good when the only comments are nitpicky ones.
15:28:38 <newsham> s'ok, i like nitpicky.. helps me learn
15:28:41 <Pseudonym> :-)
15:28:57 <Pseudonym> Oh, one more comment.  You've put in a lot of useless parentheses.
15:29:00 <Pseudonym> e.g.:
15:29:08 <Pseudonym> asciiChar n = toEnum ((fromEnum 'a') + (n `mod` 26)) :: Char
15:29:14 <Pseudonym> You could write that as:
15:29:31 <Pseudonym> asciiChar n = toEnum (fromEnum 'a' + n `mod` 26) :: Char
15:29:33 <Pseudonym> Or even better:
15:29:36 <Pseudonym> import Data.Char
15:29:52 <Pseudonym> asciiChar n = chr (ord 'A' + n `mod` 26)
15:30:03 <Pseudonym> Alternative:
15:30:07 <Pseudonym> asciiChar :: Int -> Char
15:30:13 <Pseudonym> asciiChar n = toEnum (fromEnum 'a' + n `mod` 26)
15:30:22 <Pseudonym> Then you don't need the explicit ::Char cluttering your code.
15:30:23 <newsham> ok, updated to use a 'divergeCount' function
15:30:42 <newsham> *nod*, except its an extra line.. thats my main reason for using the inline typing :)
15:30:43 <newsham> ugly hack
15:30:47 <Pseudonym> "bounded" uses extra parentheses, too.
15:31:03 <newsham> ahh, yes. thanks
15:31:08 <Pseudonym> Well, goodness.  If you cared about extra lines, why are you using a literate script?!
15:31:15 <Pseudonym> :-)
15:32:01 <Pseudonym> In fact, you could avoid mandFunc and juliaFunc altogether:
15:32:02 <newsham> i like ot occasionally grep '^>" and admire it?  ;-)
15:32:12 <newsham> but yah, changed to have signature for numToChar
15:32:17 <Pseudonym> main = putStr (asciiPlot (f 256) (-1.75) 0.75 (-1.5) 1.5 75 24)
15:32:24 <Pseudonym> Hang on.
15:32:24 <newsham> goal #1 is clarity, goal #2 is terseness 
15:32:30 <Pseudonym> main = putStr (asciiPlot (divergeCount f 256) (-1.75) 0.75 (-1.5) 1.5 75 24)
15:32:42 <Pseudonym>     where f = juliaFunc (0.3 :+ 0.5)
15:32:54 <Pseudonym> That's even nicer.  That's one line gone. :-)
15:34:49 <Pseudonym> And then you could just inline divergeCount.
15:34:52 <Pseudonym> If you wnated to.
15:35:23 <Pseudonym> Since it's only used once.
15:35:27 <newsham> sure, but i think it loses clarity.
15:35:31 * Pseudonym nods
15:35:42 <newsham> starting to look like lisp.  if you wrote it, its obvious but if you're a reader, its not.
15:36:03 <Pseudonym> Yeah.
15:36:16 <Pseudonym> Haskell encourages giving things names.
15:36:28 <Pseudonym> Pointless programmers and I disagree on this point.
15:36:46 <Pseudonym> That's because I think like an engineer. :-)
15:36:59 <dons> @remember ghc ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
15:37:03 <Pseudonym> Giving something a name makes it readable.
15:37:05 <sh10151> most of my Haskell programming is pointless
15:37:12 <sh10151> but my functions do have parameters
15:37:14 <newsham> <- BSEE
15:37:14 <Pseudonym> dons: Woohoo!  You did a jump across a superblock!
15:37:16 <sh10151> ba-dum bum CRASH
15:37:23 <Pseudonym> How did you manage that?
15:37:40 <newsham> me?
15:37:41 <dons> trying to compile Setup.hs for cabal on a mips64 box :)
15:37:46 <Pseudonym> No, dons. :-)
15:38:09 <dons> gotta hate those branch instructions ;)
15:38:14 <newsham> pseudo: updated code with your suggestions.. danke.
15:38:19 <Pseudonym> Bitte.
15:38:25 <newsham> psuedo: if you were going to write this program, would you take a different approach?
15:38:43 <Pseudonym> Kind of.
15:38:51 <newsham> good, how would you do it? :)
15:38:52 <Pseudonym> It'd be similar in spirit.
15:39:08 <Pseudonym> First off, I'd use more do-expressions.
15:39:11 <Pseudonym> main
15:39:14 <Pseudonym>   = do
15:39:28 <newsham> could I trouble you to write it? ;-)
15:39:28 <Pseudonym>     let s = asciiPlot (mandFunc 256) (-1.75) 0.75 (-1.5) 1.5 75 24
15:39:32 <Pseudonym>     putStrLn s
15:39:40 <Pseudonym> And I'd give all those magic numbers names.
15:39:59 <newsham> I originally had a main with a multi-armed let statement but then I decided i want to have a general function for doing ascii plots of different types
15:40:05 * Pseudonym nods
15:40:09 <Pseudonym> No, I can't write it right now.
15:40:29 <newsham> i had   let  (width,height) = (70,24);  (left,right) = (-1.5,1.5), .. etc..
15:41:13 <Pseudonym> I need to go see someone who is getting married in Japan this weekend, and his plane leaves tonight.
15:41:39 * SamB likes to give things names when it makes the program easier to understand, otherwise not so much
15:41:41 <Pseudonym> Need to get a brain dump from him.
15:41:55 <Pseudonym> I agree with SamB.
15:42:05 <Pseudonym> If it's important, it should have a name.
15:42:17 <SamB> like, if the name would be longer than the thing, then no, I'm not going to name it
15:42:20 <newsham> i'm sure everyone agrees with samb.  the disagreement is in what makes the programer easier to understand :)
15:42:21 <Pseudonym> Also, if it may need to change, it should have a name.
15:42:28 <SamB> (unless the thing is too short)
15:42:37 <Pseudonym> "75" is a magic number.  What does it MEAN?
15:42:48 <Pseudonym> And what is the effect of changing it?
15:42:59 <Pseudonym> So that's a number which should have a name.
15:43:07 <SamB> I was thinking more along the lines of (map . map)
15:43:12 <SamB> or whatever
15:43:14 * Pseudonym nods
15:43:14 <Pseudonym> Right.
15:43:21 <Pseudonym> I think this:
15:43:25 <Pseudonym> bounded x = magnitude x < 2
15:43:30 <Pseudonym> Is probably something which doesn't need a name.
15:43:32 <Pseudonym> For example.
15:43:38 <newsham> asciiPlot clearly binds 75 to width :)
15:43:47 <Pseudonym> I'd write this instead:
15:43:50 <SamB> that name is definately not very useful
15:43:59 <Pseudonym> cappedLength cap s = length $ takeWhile (\x -> magnitude x < 2) $ take cap s
15:44:04 <Pseudonym> Or more likely:
15:44:12 <Pseudonym> cappedLength cap s = length . takeWhile (\x -> magnitude x < 2) . take cap $ s
15:44:21 <SamB> @pl (\x -> magnitude x < 2)
15:44:23 <lambdabot> (< 2) . magnitude
15:44:23 <Pseudonym> Or possibly even:
15:44:29 <Pseudonym> cappedLength cap = length . takeWhile (\x -> magnitude x < 2) . take cap
15:44:59 <Pseudonym> I like cappedLength, BTW.
15:45:07 <Pseudonym> It's a good use of intermediate forms.
15:45:29 <newsham> > divergeCount f cap x = length $ takeWhile bounded $ take cap $ f x
15:45:30 <lambdabot>  parse error on input `='
15:45:30 <SamB> yes
15:45:43 <newsham> heh, i just got rid of capped length :)
15:45:46 <Pseudonym> :-)
15:45:55 <Pseudonym> Either way, it's STILl a good use of intermediate forms.
15:46:15 <dons> SyntaxNinja, I can confirm cabal builds on a mips64/irix machine :)
15:46:26 <Pseudonym> I don't know if this idiom has a name.  I call it "data pipeline", which makes it sound low-level.
15:46:44 <SamB> Pseudonym: listful programming?
15:46:52 <Pseudonym> No, I mean code like this:
15:47:00 <Pseudonym> f . g . h . foo . bar . waz $ x
15:47:09 <Pseudonym> Where the intermediate forms need not be lists.
15:47:15 <SamB> oh
15:47:25 <SamB> thats called pointless ;-)
15:47:35 <Pseudonym> It would be if the "x" wasn't there.
15:47:36 * SamB kids
15:47:49 <Pseudonym> @wiki PipeliningFunctions
15:47:49 <SamB> okay, its called "almost pointless"
15:47:50 <lambdabot> http://www.haskell.org/hawiki/PipeliningFunctions
15:48:13 <SamB> anyway, the stuff before the $ is all pointless
15:48:21 <Pseudonym> But it need not be.
15:48:22 <newsham> btw, how inefficient is   takeWhile pred $ take n   in practice?
15:48:24 <SamB> true
15:48:27 <Pseudonym> f . (\x -> foo x 2) . g
15:48:29 <SamB> how about compositional?
15:48:38 <Pseudonym> newsham: In jhc, it's REALLY efficient.
15:48:42 <Pseudonym> :-)
15:48:47 <newsham> cool.  thats what I wanted to hear.
15:49:09 <Pseudonym> You'd be surprised, though.  The "deforestation shortcut" that GHC does can make it as efficient as a hand-coded loop.
15:49:42 <Pseudonym> OK, gotta go.
15:49:46 <Pseudonym> Need to get this brain dump.
15:49:52 <Pseudonym> I'll be back in a couple of hours.
15:49:54 <SamB> go in GHC.Base down to "foldr/build"
15:49:56 <Pseudonym> Fare well.
15:51:19 <SamB> there, you will learn how abstraction is used to improve performance ;-)
15:51:41 <SamB> I wish I could remember the paper closest to that code
15:52:05 * SamB wonders if the code remembers
16:02:15 <Axioplase> Hi
16:03:01 <SamB> hi
16:03:11 * SamB wonders where shapr is
16:03:20 * SamB thinks shapr would know which paper it was
16:04:37 <Heffalump> what paper are you asking about?
16:05:01 <Heffalump> or rather, what is the thing you are talking about that you want the paper for
16:05:09 <SamB> Heffalump: the in depth one about RULES and foldr/build
16:05:46 <Heffalump> "playing by the rules", or something like that?
16:06:12 <Heffalump> http://www.informatik.uni-bonn.de/~ralf/hw2001/10.html
16:06:17 <SamB> I don't think thats quite the one
16:06:30 <Heffalump> there's a more theoretical one about foldr/build
16:07:16 <SamB> I thought there was a practical one about foldr/build and its associated RULES?
16:07:32 <dons> one of the ghc papers?
16:07:51 <SamB> maybe
16:07:58 <SamB> its definately about GHC
16:09:00 <Axioplase> Hum.. I have a question. I'm doing a quicksort (you know, the one exaample on Haskell's page). however, I need to count how many recursions I do on one call. But I have no idea on how to modify the code to count since it has two recursive calls.
16:09:08 <SamB> I remember that remarkably little had changed between the paper and the actual implementation (though there had been a fair amount that had changed)
16:09:31 <dons> secrets of the inliner, perhaps?
16:09:33 <newsham> have each recursive call return both the sorted list and a count
16:09:44 <newsham> then mix the two counts before returning it (ie. take the max?)
16:10:07 <Axioplase> and is "last" complexity O(1) or a "hidden" O(n) ?
16:10:23 <Heffalump> O(n)
16:10:28 <Axioplase> thanks.
16:10:37 <Heffalump> you can tell by reading the definition
16:10:41 <Heffalump> which will be something like
16:10:46 <newsham> let (l1,c1) = quicksortCount (... args ...)   (l2,c2) = quickSortCount (... args ..)  in  ....
16:10:46 <Heffalump> last [x] = x
16:10:50 <Heffalump> last (x:xs) = last xs
16:11:02 <SamB> dons: no.
16:11:03 <Heffalump> so you can see that it has to traverse the entire list
16:11:08 <Axioplase> which I didn't read... But I though haskell might store it somewhere. whatever.
16:11:13 <SamB> however, maybe its in the same dir as that one on my disk.
16:11:37 <Axioplase> newsham: ok. I'll try something like that.
16:12:28 <newsham> (or you could write a function which takes in the two tuples and mixes them appropriately)
16:12:39 <jethr0> hi, is there a way of "hiding" a constructor without resorting to modules?
16:12:44 <SamB> jethr0: no!
16:12:49 <SamB> resort to them!
16:12:54 <SamB> they are very luxurious!
16:12:59 <jethr0> quick answer, unhappy jethr0 ;-)
16:13:13 <newsham> bitter pills
16:13:20 * jethr0 's not sure that luxurious has a good notation in programming...
16:13:34 <jethr0> more pills
16:13:38 <SamB> you're supposed to trust yourself to not use your own constructors unless you want to
16:14:05 <jethr0> hmm, but it is _really_ easy to forget somewhere and *wush* there go all your implicit constraints...
16:14:22 <Axioplase> hum. What is the number_to_string fucntion ?
16:14:33 <jethr0> i did this manual style for vectors and forgot to create a unit vector
16:14:48 <jethr0> and it was _very_ hard to find why the offending function failed...
16:16:21 <SamB> dons: no, still no.
16:17:01 * SamB wants fermat's last bookshelf
16:17:06 <Heffalump> jethr0: modules are there for hiding things (amongst other stuff) :-)
16:17:39 <jethr0>  samb: is that the one with the thousands of unproven speculations?
16:17:55 <jethr0> ;-)
16:18:08 <SamB> jethr0: no, its the one to help you find your books and papers ;-)
16:18:20 <jethr0> ah, so you want the _empty_ bookshelf...
16:18:38 <SamB> ever heard of fermat's last margin?
16:18:53 <jethr0> no
16:19:17 <jethr0> ah, you mean the one where he had too little space to write down the _whole_ proof?
16:19:38 <SamB> actually its a project shapr is working on
16:19:45 <jethr0> that was _way_ funny. i will most definitely pull something like that in my books
16:20:20 <newsham> .. or leave extra room in case fermat is reading
16:20:39 <SamB> newsham: but he's dead!
16:21:31 <jethr0> "hey, today i casually came upon a proof of P==NP; i started from eliptic curves and then [omitted]"
16:22:01 <jethr0> that will be MY legacy
16:23:18 <SamB> @localtime musasabi 
16:23:21 <lambdabot> Local time for musasabi is Tue Dec  6 02:22:57 2005
16:23:35 <jethr0> hey, lambdabot is finally back
16:23:44 <SamB> jethr0: lambdabot has been back
16:23:57 <newsham> samb: talking to dnm?
16:23:58 <SamB> since soon after dons said "moin moin"
16:24:45 <SamB> which he apparantly says every morning when he gets up
16:25:48 <jethr0> samb, it's a customary greeting in northern germany and can actually be used throughout the day
16:26:09 <jethr0> which baffles many, as it literally mean "morning morning"
16:26:22 <Axioplase> Hum.. trying to get n pairs of random floats. What's wrong with http://rafb.net/paste/results/CpUKxs66.html (except that I guess I should use monads or something like that I didn't get yet..)
16:26:34 <SamB> jethr0: dons lives in australia
16:27:07 <dons> ah, but I work with germans :) and besides, moin is customary in #haskell ;)
16:27:13 <SamB> hehe
16:27:40 <jethr0> axioplase: what's the type of pairToPoints?
16:27:43 <SamB> and anyway, he could say anything he wanted when he got up in the morning, including "good night"
16:27:44 <Axioplase> and the error: http://rafb.net/paste/results/f5dEhq65.html (pairToPoint takes a and b, and returns (MyPair a b)
16:28:03 <Axioplase> jethr0: It takes Doubles
16:28:19 <jethr0> does it take a pair of doubles or rather two doubles?
16:28:26 <Axioplase> jethr0: takes two
16:28:36 <jethr0> @type getStdRandom
16:28:37 <lambdabot> Not in scope: `getStdRandom'
16:28:55 <dons> @index getStdRandom
16:28:56 <lambdabot> System.Random
16:29:07 <Axioplase> I though my random would be [IO MyPoint]
16:29:22 <Axioplase> thought
16:29:24 <jethr0> @type System.getStdRandom
16:29:26 <lambdabot> Not in scope: `System.getStdRandom'
16:29:31 <jethr0> @type System.Random.getStdRandom
16:29:33 <lambdabot> forall a.
16:29:33 <lambdabot> (System.Random.StdGen -> (a, System.Random.StdGen)) -> IO a
16:29:43 <Axioplase> @type Random.getStdRandom
16:29:45 <lambdabot> forall a.
16:29:45 <lambdabot> (System.Random.StdGen -> (a, System.Random.StdGen)) -> IO a
16:30:06 <jethr0> axioplase. one problem is that you have to push the resulting stdgen through to the next double/call.
16:30:19 <jethr0> otherwise it will IMO return the same value over and over, no?
16:30:25 <Axioplase> jethr0: oh yes. Indeed.
16:30:55 <jethr0> and also, right now you get a (MyPair of IOs) not an (IO of  MyPair)
16:31:07 <jethr0> or even an "IO [MyPair]"
16:31:39 <jethr0> AND your pairs contain the resulting stdgen.
16:32:45 <Axioplase> ok. What should I do then? All I want is get a list of MyPairs randomly generated...
16:34:12 <jethr0> i would have to learn about it first. anyone else here to help?
16:34:38 <Axioplase> Ha. Dammit. Can't stay. Friend of mine died :/
16:35:20 <jethr0> use randomIO
16:35:35 <jethr0> how's that for a casual remark...
16:36:08 <ows> what's the best haskell IDE with auto-complete (freeware or open source)?
16:36:54 <wolverian> vim ;)
16:37:15 <ows> oh really? :P
16:37:21 <wolverian> no, probably not.
16:37:37 <wolverian> who needs autocomplete, anyway? people with too long variable names.
16:38:09 <dons> vim is easy, ^P :)
16:38:19 <dons> wolverian, libs tend to have long names
16:38:25 <dons> for identifiers
16:38:26 <ows> no, I mean API suggestion
16:38:40 <ows> Java code
16:38:45 <ows> String string;
16:38:49 <ows> string.
16:38:56 <ows> and it gives some suggestion after
16:39:14 <wilx> Emacs.
16:39:49 <ows> wilx: does Emacs do that?
16:40:12 <wilx> Sort of.
16:40:19 <wilx> M-/ does that.
16:45:12 <dons> @remember ghc ld64: INFO    171: Multigot invoked. Gp relative region broken up into 2 separate regions.
16:46:51 <ows> wilx: ok, tkx
16:47:08 <ows> a general question: when should I use haskell?
16:47:10 <ows> :)
16:48:08 <dons> on an empty stomach?
16:48:30 <dons> twice daily, before meals?
16:51:54 <ows> to test maths algos?
16:52:09 <sh10151> whenever your heart desires
16:53:57 <ows> it doesn't seem a good choice to develop real time systems :P
16:54:35 <gzl> it's good for mathy stuff
16:54:57 <gzl> also good for stuff that involves parsing or implementing domain-specific languages
16:55:22 <SamB> ah, I give up! I'm not going to find the paper I seek!
16:55:25 <gzl> those are some strengths that come to mind, though you could use it in many places (but I dunno about real-time systems)
16:55:41 <dons> SamB, ask on -cafe@ ?
16:57:12 <SamB> dons: wouldn't it be easier to just ask spj?
16:57:15 <gzl> Cale: around?
16:57:22 <SamB> I don't have to sign up for a mailing list to do that.
16:57:37 <SamB> or, I could do it on haskell-libraries...
16:58:04 <SamB> on the theory that GHC.Base, GHC.List, and Data.List are part of the library and therefor on topic
16:58:04 <ows> gzl: is it better than python for scripting?
16:58:13 <dons> about which paper you're seeking? -cafe would be the fastest, I think.
16:58:26 <gzl> ows: that question isn't really answerable.
16:58:39 <SamB> dons: but I don't want to subscribe to it
16:59:09 <ows> gzl: and 'bout this one: is it better than mathematica for mathy stuff
16:59:11 <gzl> ows: I would imagine that depending on what kind of script it is, Haskell could be more or less convenient than Python.
16:59:56 <gzl> ows: again it depends on what you mean by mathy stuff. Haskell doesn't have sophisticated math tools built in like Mathematica does (e.g. symbolic integration)
17:00:09 <sebell> ows: More often than not, a programming language should suit the programmer, and be able to adapt to many problem domains, rather than the programmer have to adapt to many languages for different problem domains
17:00:29 <gzl> ows: these kinds of questions are too general to be able to answer. it depends on the exact task at hand and it depends on your personal tastes.
17:01:40 <sh10151> sebell: I don't know, isn't that at odds with the notion of DSLs?
17:01:41 <JohnMeacham> How is this for a Haskel motto "making easy things unneccesary and difficult things easy"
17:02:12 <gzl> it's ok.
17:02:12 <ows> so, if it hasn't good built-in function like mathematica or even c numerical recipes, can you say some math examples that haskell is good on
17:02:15 <dons> impossible things merely difficult? ;)
17:02:30 <JohnMeacham> that is the logical extension, yes.
17:02:47 <gzl> ows: mathematica isn't a normal programming environment, C doesn't have any of the stuff I'm talking about either
17:02:52 <JohnMeacham> we will call that 'dons's correllary'
17:02:55 <sieni> ows: do you have a specific question in mind?
17:03:05 <JohnMeacham> but everything spelled correctly.
17:03:17 <sebell> sh10151: At odds? I think it's another way to describe DSLs. (And I mean specifically derivative DSLs, not discrete ones.. IE: DSLs built in Lisp or Haskell)
17:03:37 <gzl> sieni: he just wants to know when using Haskell really pays off
17:03:46 <ows> sieni: doing math stuff with transforms
17:03:55 <sebell> sh10151: So that at all times one has access to the features of the base language, while building up layers of abstraction
17:04:37 <sebell> sh10151: Unless your domain is REALLY small ;)
17:04:49 <Igloo> SyntaxNinja: Are you here?
17:04:56 <JohnMeacham> and John's lemma. I need more lemmas.
17:05:08 <sieni> ows: Mathematica is quite usable especlially if you find their libraries usable
17:05:09 <Igloo> Or does anyone else know OTTOTH how to make cabal link with -threaded?
17:05:20 <gzl> ows: what kind of transforms?
17:06:01 <ows> fourier for instance
17:06:16 <gzl> ows: by being good at mathy stuff, I mean that Haskell generally allows you to express mathematical concepts pretty directly, not that it comes with a built-in Fourier transform module
17:06:56 <gzl> unless you have some desire/need to rewrite a Fourier transform library, you might as well just use Mathematica then
17:07:44 <sieni> ows: if the fourier transform you need to know has been given to you as an exercise, then probably it is meant that you should solve it yourself and anyway Mathematica probably solves your problem much better than haskell (maybe)
17:08:16 <gzl> well, the mathematica one would be more sophisticated, and the "haskell one" would be whatever you're able to come up with :)
17:08:26 <gzl> in the given amount of time
17:08:54 <sieni> if you want to understand mathematics or physics, you really should try to take some time and try to learn the stuff yourself
17:09:09 <sh10151> Zorn's lemma
17:09:32 <flux__> hmm.. infact isn't (f)ft something that could be elegantly expressed in haskell? it might lose in speed to mathematica, though ;)
17:10:03 <sieni> ows: if you are in a business or law school, then it is time to learn about ethical business practicess and pro bono work
17:10:30 <sieni> an after learning that, you can refer to the previous answer
17:11:17 <ows> sieni: ok, so is haskell good for theorem proving isn't it?
17:11:52 <SyntaxNinja> hi Igloo
17:11:54 <gzl> if you're doing automated theorem proving you'd probably want to use a package made for that
17:12:04 <sieni> it probably won't help you with fourier series or transforms unless you know how to program them
17:13:01 <sieni> you might be able to find libraries suited for that
17:13:04 <Igloo> SyntaxNinja: Can I make cabal link with -threaded?
17:13:11 <SyntaxNinja> theorem provers tend to get written in functional languages :)
17:13:13 <Igloo> SyntaxNinja: And can I put comments in a .cabal, BTW?
17:13:24 <SyntaxNinja> Igloo: -- at the beginning of the line for comments
17:13:27 <ows> ok, fellows
17:13:33 <ows> tkx for your help
17:13:35 <Igloo> Ah, should have guessed that  :-)
17:14:00 <SyntaxNinja> Igloo:  ghc-options -threaded -Wall
17:14:10 <SyntaxNinja> er ghc-options: -threaded -Wall
17:14:13 <sieni> ows: your pen is your friend <3
17:14:16 <dons> Igloo, in ghc-options:  :)
17:14:21 <Igloo> OK, that's what I've done, but I think it ought to be an extension
17:14:58 <dons> btw, to auto-strip executables, rather than hacking Setup.lhs, I've found the following ghc-extension nice: -optl-Wl,-s
17:15:26 * Igloo isn't clear on whether you could have something that you would want to link with -threaded with ghc but could still use with, say, hugs, in which case it ought to be something else instead (or as well)
17:15:58 <dons> hmm. yes. it's certainly possible to write something that just won't work without -threaded
17:16:18 <dons> something that'll just block and do nothing without it
17:16:25 <autrijus> dons: hello from melbourne :)
17:16:30 <SyntaxNinja> hi autrijus
17:16:37 <SamB> -threaded is not needed for forkIO, but for forkOS, right?
17:16:38 <Igloo> What is it that is making cabal say "Setup.hs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly"?
17:16:40 <dons> hey autrijus!
17:17:01 <SyntaxNinja> Igloo: something in your first stanza makes cabal think that you think there's a library
17:17:03 <SamB> Igloo: it means you need to expose modules, I guess
17:17:11 <dons> SamB, if you want blocking foreign calls to run in an io manager thread, iirc
17:17:16 <Igloo> Sorry, I don't want to have a library
17:17:20 <SyntaxNinja> so either you need to expose modules, as Samb says, or you need to remove a library-related field from the first stanza
17:17:22 <SamB> dons: and that
17:17:30 <dons> which hmp3, for example, requires
17:18:26 <SyntaxNinja> Igloo: hm. yeah, seems to make sense as an extension. then cabal could give an error if you tried to build it w/ hugs.
17:19:35 <Igloo> SyntaxNinja: Oh, I see, I need to move my ghc-options to the executable stanza. That makes sense.
17:30:16 <SyntaxNinja> Igloo: cool.
17:30:53 <SyntaxNinja> I wish that error message were better; it should say "ghc-options field provided in library (first) stanza, but no exposed modules"
17:30:56 <Pupeno> To get the parameters passed when running the program I have to run args <- getArgs, right ?
17:31:07 <SyntaxNinja> Pupeno: yeah
17:31:30 <SyntaxNinja> main = getArgs >>= print -- to see them.
17:38:18 <Pupeno> Can the Network module do UDP ? Or I'll have to use Network.Socket for that ?
17:39:46 <SamB> dons: how come FPS doesn't support fusion?
17:40:12 <mwc> top
17:40:17 <mwc> er, sorry, wrong terminal
17:41:06 <SamB> mwc:  3694 root       5 -10  127m  19m  71m S  8.8  7.8   3314:59 XFree86           
17:41:41 <Igloo> SyntaxNinja: How can I make wrap.o be included in a cabal library?
17:41:42 <mwc> I'd like to request a wiki page on precisely what that forall qualifier means
17:42:41 <JohnMeacham> why it's the universal quantifier of course.
17:42:48 <dons> SamB, umm. no one tried. it's going to be replaced by simon's code, so I'm not too worried ;)
17:43:06 <SamB> dons: ok then
17:43:07 <mwc> JohnMeacham, yeah, but I can't find any useful documentation on what it actually meants
17:43:13 <JohnMeacham> sorry for the glib response. java programers are eating my brain.
17:43:16 <mwc> it seems to me that it would be completely redundant
17:43:23 <SamB> dons: and why is it GPLed again?
17:43:42 <SamB> (no, I didn't ask before)
17:43:45 <mwc> how is map :: (a -> b) -> [a] -> [b] not universally qualified over all types a and b?
17:43:56 <autrijus> @type map
17:43:57 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
17:44:02 <mwc> okay
17:44:10 <JohnMeacham> mwc: forall is always redundant in programs that can be typed within haskell 98. but when you add things like polymorphic components or rank-n types then you need to be able to explicitly quantify which variables are polymorphic
17:44:12 <SamB> mwc: see! it is.
17:44:17 <SyntaxNinja> Igloo: what's wrap.o?
17:44:27 <SamB> @type GHC.Base.build
17:44:28 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
17:44:30 <dons> SamB, since the darcs code is GPLd. but it's also BSD, if you like that :) you just have to ask
17:44:32 <Igloo> SyntaxNinja: It's an object file that appears by magic
17:44:41 <mwc> JohnMeacham, okay, thanks, that what's I was wondering about
17:44:52 <dons> SamB, did you read the license in the file: -- License     : BSD-style
17:44:55 <Cale> mwc: any type signature with free variables left in it automatically has those variables universally quantified
17:45:06 <SamB> dons: oh?
17:45:09 <mwc> Cale, so it is redundant?
17:45:26 <Pupeno> Is it possible to simulate, from ghci, the parameters that would be sent from the shell to the compiled program ?
17:45:26 <Cale> yeah -- in fact, Haskell 98 doesn't allow explicit forall's
17:45:27 <mwc> since my map signature would get turned into the forall'd version behind my back?
17:45:28 <SyntaxNinja> Igloo: I don't think there is any way. you can specify c files that you want to get built, and it'll link those .o files in.
17:45:28 <JohnMeacham> mwc: grumble.. scoped type variables... grumble.
17:45:32 <Cale> that's an extension
17:45:38 <Cale> yeah
17:45:49 <Igloo> Bah, OK, thanks
17:45:57 <SamB> dons: you oughtn't to have files called LICENSE entitled "GNU GENERAL PUBLIC LICENSE" if the license can be BSD!
17:46:07 <dons> ok, legacy then.
17:46:07 <mwc> Cale, okay, so basically I don't need to worry about it until I need to worry about it
17:46:14 <Cale> map :: (a -> b) -> [a] -> [b] is the same as  map :: forall a b. (a -> b) -> [a] -> [b]
17:46:17 <Cale> yeah
17:46:20 <mwc> fair enough
17:46:22 <mwc> time to eat
17:46:26 <JohnMeacham> to avoid issues with scoped type variables you should always use an explicit forall on any expression bound type signatures. not quite haskell 98, but more future and extension proof.
17:46:34 <dons> i started off wanting it to be gpl, but since people wanted to use it for lots of things, decided bsd is probably better
17:46:37 <Cale> you only need to worry about explicit forall if you want to *force* a parameter to be polymorphic
17:46:46 <mwc> alright
17:46:53 <mwc> Cale, that makes sense to me now
17:46:55 <mwc> thanks
17:46:59 <Cale> like, you don't want them passing a function  Char -> Int -> Char, but rather a function a -> b -> a
17:47:07 <mwc> yeah
17:47:13 <JohnMeacham> by expression bound type signatures I mean things like "(id :: forall a . a -> a) 'x'" not ones at the top level.
17:47:14 <SyntaxNinja> Igloo: you could add an "extra linker objects" field or something
17:48:03 <JohnMeacham> Cale: yup. if you have rank-n types that is.
17:48:09 <Cale> JohnMeacham: right
17:48:22 <palomer> does haskell have existential types?
17:48:26 <Cale> yes
17:48:30 <palomer> example?
17:48:30 <SamB> dons: so, fix it to say BSD in the files!
17:48:32 <JohnMeacham> yes. but with a crappy syntax.
17:48:51 <JohnMeacham> though, actually use the GADT syntax for them if you don't mind being ghc specific, it is more correct.
17:49:21 <dons> SamB, darcs send..
17:49:22 <palomer> when would existential types be useful?
17:49:29 <JohnMeacham> data Foo = forall a . Foo a (a -> a)  -- note, the forall should be exists but isn't.
17:49:44 <dons> palomer, for hiding implementation types
17:50:02 <SamB> ok
17:50:06 <palomer> JohnMeacham: eh?
17:50:24 <JohnMeacham> eh??
17:51:06 <JohnMeacham> or the implementation of Data.Dynamic which needs to store any type. or you can do OO style stuff, storing a type and a bunch of routines that act on it in a constructor.
17:51:39 <Cale> data Showable = forall a. Show a => Showable a
17:51:39 <Cale> instance Show Showable where
17:51:39 <Cale>     show (Showable x) = show x
17:51:48 <Cale> *Main> [Showable 5, Showable "Hello"]
17:51:48 <Cale> [5,"Hello"]
17:52:42 <Cale> Of course, you need -fglasgow-exts
17:52:48 <SamB> somebody ought to implement a warning for using exists as a type variable...
17:53:32 <JohnMeacham> SamB: indeed. Omega uses exists, but perhaps GADT syntax will catch on.
17:53:44 <Cale> somebody ought to write support for the use of exists :)
17:54:22 <JohnMeacham> it has been brought up on the mailing list before, I don't think anyone is terribly happy with the current syntax.
17:54:35 <JohnMeacham> I'd like to see 'exists' as a keyword, we might find uses for it in other places.
17:54:54 <palomer> why don't existential types have an existential quantifier?
17:54:58 <Pupeno> http://haskell.org/hoogle/ doesn't seem to have indexed System, am I wrong ? http://www-users.cs.york.ac.uk/~ndm/hoogle/ have.
17:55:07 <Cale> data Showable = forall exists. Show exists => Showable exists
17:55:07 <Cale>  -- hehe
17:55:31 <SamB> palomer: we don't know. we think that they should. okay?
17:55:40 <palomer> okay!
17:55:55 <Cale> forall was already in the syntax
17:56:11 <Cale> So I think it's partly laziness
17:56:31 <dons> and not polluting the namespace
17:56:41 <palomer> exists would not be polluting the namespace
17:56:43 <palomer> !
17:56:52 <dons> but then, I've never seen 'exists' as an ident :)
17:56:58 <Cale> who uses exists as a type variable? :)
17:57:00 * autrijus hands palomer #define and -cpp
17:57:13 <Cale> haha
17:57:14 <dons> palomer, it would be a new keyword, so that's one less you can use.
17:57:17 <Igloo> AFAIK it's not laziness, it was just to avoid potentially breaking existing code
17:57:27 <palomer> in system F, exists is syntactic sugar if I remember correctly
17:57:30 <Igloo> I think SPJ thinks it was the wrong decision in retrospect
17:57:41 <SamB> Igloo: thats laziness!
17:57:56 <SamB> breaking my head is worse than breaking my code
17:58:06 <dons> hehe
17:58:17 <autrijus> heads are considerably harder to refactor
17:58:25 <Igloo> It's not laziness of the implementors
17:58:32 <JohnMeacham> palomer: sort of syntatic sugar. there are isomorphic types that only use forall, but they may not be in the representation you want.
17:58:43 <Cale> could we get a change in that decision then?
17:58:49 <SamB> no, its the implementors assuming laziness of the users
17:59:06 <SamB> yes, we should break all the code
17:59:26 <Cale> I sort of doubt any code will break
17:59:36 <palomer> exists X.A <=> forall Y. (Y->X)->A I think
17:59:41 <palomer> I'd have to work it out (too lazy right now)
17:59:44 <SyntaxNinja> we need to get all code on hackageDB so we can see what code will break under what changes :)
17:59:53 <JohnMeacham> convince the various implementors. I will put it in jhc when I get around to existential types.
18:00:02 <palomer> JohnMeacham: do it!
18:00:08 * Igloo would like to see less backwards compatibility, but I doubt it will happen until/if Haskell 2 happens
18:00:08 <Cale> it's not like you're taking exists and forall from the data-variable namespace
18:01:14 <dons> > let forall = 1 in forall
18:01:15 <lambdabot> 1
18:01:31 <lumimies> Hi, are you people OK with "why doesn't this work" questions?
18:01:31 <Cale> I'd like to see some things get put back the way they were pre-H98.
18:01:36 <SyntaxNinja> lumimies: sure.
18:01:43 <Cale> lumimies: yeah :)
18:01:47 <lumimies> I have one such :P
18:01:52 <SyntaxNinja> Cale: you should post your thoughts to the haskell-cafe mailing list :)
18:02:25 <SyntaxNinja> lumimies: but we don't like meta questions about what questions we like.  those are the only ones, though.
18:02:29 <lumimies> Is there a pastebot in the theatre?
18:02:34 <lumimies> Oh, sorry, I'll be off then
18:02:45 <SyntaxNinja> lumimies: NO WAIT
18:02:46 <SyntaxNinja> @paste
18:02:47 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:02:48 <lumimies> Ohhh
18:02:50 <palomer> Cale: for example?
18:02:54 <SyntaxNinja> paste
18:03:03 <dons> listpaste, are you there?
18:03:08 <dons> lisppaste?
18:03:11 <Cale> SyntaxNinja: I've been fairly vocal about it in the past. It's mostly the obvious things. map :: (Functor f) => (a -> b) -> (f a -> f b), Monad being a subclass of functor, MonadZero being brought back, fail removed from Monad
18:03:31 <Cale> We should move (++) to Monoid
18:03:52 <Igloo> Cale: What's wrong with fmap?
18:03:52 <Cale> Generalise the types of numeric functions
18:04:11 <Igloo> For monad comprehensions, say, I can see the argument as there is syntactic sugar involved
18:04:11 <Cale> Igloo: it seems silly that we have 3 mapping functions on lists.
18:04:24 <Cale> map, fmap, liftM
18:04:26 <lumimies> That page doesn't want me editing it
18:04:30 <Igloo> But why complicate types for newbies when you could just have a separate more general function?
18:04:35 <Cale> they should all be one
18:04:47 <Cale> Igloo: hm?
18:04:55 <Igloo> s/types/type errors/
18:04:57 <Cale> seperate less-general function?
18:05:18 <Igloo> I meant fmap, I guess you mean map?
18:05:24 <Cale> Why not just specialise the type errors?
18:05:50 <Cale> I mean to get rid of map :: (a -> b) -> [a] -> [b], and only have the general version
18:06:07 <Cale> and rename that general version to map
18:06:34 <Igloo> I understand what you mean
18:06:36 <Cale> We can tell newbies what Functors are, it's really not that hard to grasp
18:06:59 <Cale> You really need to learn about typeclasses right off the bat anyway
18:07:07 <Cale> there's a lot of stuff with Ord and Eq and Num
18:07:08 <dons> I wonder if anyone's done a study on what errors confuse beginners most?
18:07:10 <Igloo> Just specialising the type errors isn't easy. The eventual error can be far away from the (f)map instance
18:07:19 <dons> where did the map/fmap dichotomy come from?
18:07:23 <JohnMeacham> I believe the helium people did.
18:07:35 <JohnMeacham> their stuff is really interesting.
18:07:38 <dons> ah, maybe maybe.
18:07:44 <Igloo> I'm not sure we were taught type classes in the UG course I did
18:07:49 <Cale> And if all else fails, add a beginner-mode switch to the compilier
18:07:53 <Cale> compiler*
18:07:59 <lumimies> It's up on the wikipage
18:08:01 <dons> -haskell1A ;)
18:08:13 <dons> or -1A, like -98
18:08:27 <jethr0> dons: most annoying "error" for newbies: missing type coercion of numerics
18:08:40 <Igloo> I'd probably be in favour of different maps depending on what modules you have in scope, but I don't see the benefit of removing a useful function (map constrained to lists)
18:08:45 <JohnMeacham> writers of functions can actually specify a function specific type inference order that will give the best error messages (and provide custom error messages for common errors)
18:08:49 <dons> yeah, fromIntegral is probably the most frequent responnse we provide on this channel
18:09:01 <jethr0> ;-)
18:09:15 <Igloo> dons: Closely followed by "No, Integral is a class, you really do want fromIntegral"  :-)
18:09:35 <lumimies> I've tried going through it step by step, it seems fine until I set up "hit", whereupon it tells me that it wants a FiniteMap of some sort to be instance of Num
18:09:40 <dons> hehe
18:09:54 <Cale> This is, I think more a problem with the tutorials than a problem with the compiler.
18:09:58 <Cale> or the language
18:10:05 <lumimies> Which means that I'm stupid in some way I can't fathom
18:10:06 <jethr0> dons, do you know whether randioRIO is done via FFI or other non-haskell tricks?
18:10:38 <dons> the std random gen is done with a mutable variable, iirc
18:10:49 <Cale> lumimies: sorry, where is your code?
18:10:54 <Korollary> Cale: Yes, the tutorials are bass-ackwards in some places.
18:10:56 <JohnMeacham> you can also specify that certain types will never be in certain classes, so the compiler can quit with an error right away when it sees a non-sensical class constraint rather than propegating the odd constraint outward and only complaining once it does the context reduction at the top level.
18:10:58 <lumimies> Um sorry, first on the wikipage
18:11:02 <lumimies> Topmostest
18:11:05 <dons> an IORef, jethr0
18:11:13 <SamB> dons: huh?
18:11:18 <SamB> oh, you mean keeping track of it?
18:11:24 <Cale> lumimies: I don't see anything in recentchanges
18:11:32 <Cale> www.haskell.org/hawiki/ ?
18:11:36 <lumimies> Ugg
18:11:38 <JohnMeacham> I am hoping some will turn into ghc pragmas. we have the RULES pragma for specifying custom optimizations, why not custom type inference algorithms? (it's hard is the answer, but that hasn't stopped us before)
18:11:45 <dons> rather than threading around a generator, the random gen in IO uses an IORef to keep track of the global generator
18:11:49 <lumimies> Fathomable stupidity this time, confusing preview with post
18:11:56 <SamB> theStdGen :: IORef StdGen
18:12:04 <dons> right.
18:12:17 <jethr0> yes, but if it ain't passing it, how can it keep the state?
18:12:25 <dons> in a global variable
18:12:35 <dons> a global, mutable var
18:12:38 <dons> like I said ;)
18:12:39 <JohnMeacham> is the darcs fptools writable? like, if I do a darcs send will it go somewhere that will eventually make it into the repo?
18:12:40 <jethr0> ah, so that is in a way FFI-like?
18:12:51 <dons> not really. no foreign calls are made
18:12:58 <dons> but it's a bit evil, yes,
18:13:04 * dons shurgs
18:13:04 <jethr0> ok, thx, gotta look into IORef then
18:13:08 <Cale> only as far as IORefs and unsafePerformIO are
18:13:18 <Igloo> JohnMeacham: It doesn't have a place to go I believe
18:13:20 <SamB> JohnMeacham: you have to give your own address
18:13:31 <SamB> and I don't know if it will make it to the repo or not
18:13:53 <Cale> Igloo: why not rename the list-specific version to lmap or something?
18:14:33 <Igloo> Cale: Or Data.List.map, which is what I meant by "different maps depending on what modules you have in scope"
18:14:41 <SamB> Cale: cause that looks a lot worse than fmap?
18:14:44 <Cale> We don't have specialised names for + and * for all our separate number types
18:15:08 <Igloo> No, but people probably screw up with them less often
18:15:34 <Cale> fromIntegral :)
18:15:46 <SamB> Igloo: or at least, the screwups aren't of the same type
18:15:52 <jethr0> igloo, but wouldn't that cause lots of name collisions by "import Data.List"
18:16:18 <Igloo> jethr0: That's the way we're going, e.g. see import Data.Set
18:16:29 <SamB> I don't want my types to suddenly become less polymorphic if I import Data.List
18:16:36 <SamB> and Data.Set is more special-purpose
18:16:57 <SamB> I don't think map should be generalized at this time.
18:17:05 <Cale> SamB: why not?
18:17:08 <SamB> maybe tomorrow night I will change my mind ;-)
18:17:23 <Igloo> They wouldn't become less polymorphic, they'd just give errors
18:17:42 <Igloo> I was actually going to propose a way to specify a function as being a type-restricted version of another function, but then I realised it causes principal type issues
18:17:52 <SamB> too many amgibuity errors
18:18:07 <Igloo> e.g. if undefined restricted to Int and to Bool are both in scope and undefined itself isn't then undefined has no principal type
18:18:46 <SamB> that sounds overcomplicated
18:19:22 <Igloo> I wanted it for providing a generalised IO library without conflicting with the existing one
18:20:06 <lumimies> It actually is up now
18:20:31 <SamB> isn't it easier to import Prelude ()?
18:21:16 <Cale> lumimies: FiniteMap is deprecated, by the way
18:21:31 <SamB> okay, so the BSD3 is the one with three bullet points ?
18:21:36 <lumimies> Oh? Okay.. By what?
18:21:41 <Cale> Data.Map
18:21:44 <lumimies> m
18:21:52 <Igloo> Yes, re BSD3
18:22:16 <Igloo> I don't think the "import Prelude ()" route would fly with the community
18:22:16 <SamB> er, not quite bullet...
18:22:20 <SamB> enumeration
18:22:31 <SamB> no, probably not.
18:22:52 <SamB> would be nice if you could do something like
18:23:02 <SamB> import Prelude hiding (module System.IO)
18:25:09 <SamB> hmm
18:25:36 * jethr0 agrees with samb to make the situation appear less awkward
18:26:05 <Cale> lumimies: you've nested the finite maps 2-deep, so the plusFM_C has to take a combining function which combines 2 finite maps
18:26:45 <Igloo> Huzzah, minstrel builds! Now I can listen to music again  :-)
18:27:02 <lumimies> Oh, mu
18:27:55 <araujo> Hello Haskell'erX!
18:28:03 <Igloo> Although relying on cabal compiling C files after Haskell modules isn't ideal
18:28:20 <dons> yikes! how'd it break?
18:28:40 <lumimies> Heh, O frabjous day, eureka
18:28:45 <Igloo> dons: Was that to me?
18:28:56 <lumimies> Thank you, Cale
18:29:04 <Cale> lumimies: you're attacking the problem rather directly. You might consider an approach where you build up a new type with operations that suit your problem
18:29:11 <palomer> man, I'm so writing a haskell binding for sablecc over the christmas vacation
18:29:46 <lumimies> I'm kinda stuck in procedural land, I guess
18:30:14 <lispy> > ((: "a little surprise.") =<<) "Oh, look! "
18:30:16 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
18:30:16 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
18:30:16 <lambdabot> little surprise.!a little surprise. a little surprise."
18:30:37 <jethr0> wtf
18:30:44 <Cale> makes sense :)
18:30:48 <lispy> http://codersbase.com/index.php/Haskell
18:30:52 <Cale> =<< is concatMap
18:30:53 <dons> Igloo, yes
18:31:23 <Cale> > concatMap (: "a little surprise.") "Oh, look! "
18:31:24 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
18:31:24 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
18:31:24 <lambdabot> little surprise.!a little surprise. a little surprise."
18:31:45 <Cale> > "Oh, look! " >>= (: "a little surprise.")
18:31:46 <lambdabot> "Oa little surprise.ha little surprise.,a little surprise. a little
18:31:46 <lambdabot> surprise.la little surprise.oa little surprise.oa little surprise.ka
18:31:46 <lambdabot> little surprise.!a little surprise. a little surprise."
18:31:48 <Igloo> dons: Broken PSU -> replace machine -> change arch -> binary incompatible. Coupled with bitrot, I decided to cabalise it rather than just fixing the bits that broke
18:31:50 <Cale> hehe
18:32:06 <lispy> another way to look at it, is that ((: []) =<<) is the identity function for lists :)
18:32:22 <Igloo> (actually I might have been able to get the binary to work anyway, but I felt I ought to fix it anyway)
18:32:24 <jethr0> cale, what does "(:" do?
18:32:36 <Cale> jethr0: that's a section with cons
18:32:38 <lispy> @type (:)
18:32:39 <lambdabot> forall a. a -> [a] -> [a]
18:32:57 <Cale> > (: "ello") 'h'
18:32:59 <lambdabot> "hello"
18:33:09 <dons> Igloo, oh fun fun :)
18:33:13 <lispy> @type (. (:))
18:33:14 <lambdabot> forall a c. (([a] -> [a]) -> c) -> a -> c
18:33:31 <araujo> @hoogle (!)
18:33:32 <lambdabot> No matches found
18:34:13 <Igloo> It actually wasn't too bad apart from various cabal deficiencies, and now I have some generic cabal packaging stuff
18:34:19 <palomer> @type .
18:34:20 <lambdabot> parse error on input `.'
18:34:24 <palomer> @type (.)
18:34:26 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
18:34:28 <lispy> @type .(.).
18:34:30 <lambdabot> parse error on input `.'
18:34:35 <lispy> oh...
18:34:38 <palomer> @type (.)(.)
18:34:38 <jethr0> now i get it. of course i know (:), just hadn't seen it sectioned of like that...
18:34:39 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
18:34:53 <palomer> (.)(.) and (_|_) look suspicious
18:35:00 <lispy> heh
18:35:08 <lispy> @type (^)(^)
18:35:10 <lambdabot> forall a b b1.
18:35:10 <lambdabot> (Integral b1, Num (a -> b -> a), Integral b, Num a) =>
18:35:10 <lambdabot> b1 -> a -> b -> a
18:35:32 <palomer> @type (:(-))
18:35:34 <lambdabot>   Expecting a function type, but found `[a]'
18:35:34 <lambdabot>   Expected type: [a]
18:35:39 <SamB> dons: okay, patch sent
18:35:51 <dons> danke
18:35:55 <palomer> @type (:)(-)
18:35:57 <lambdabot> forall a. (Num a) => [a -> a -> a] -> [a -> a -> a]
18:36:09 <SamB> there are a couple of instances of "REGENTS" in the disclaimer though
18:37:11 <lispy> @type (.)(!)(.)
18:37:13 <lambdabot> Not in scope: `!'
18:37:17 <lispy> @type (.)(!!)(.)
18:37:18 <lambdabot>   Expecting a function type, but found `b'
18:37:18 <lambdabot>   Expected type: (b -> c) -> [a]
18:37:26 <lispy> hmm...
18:37:27 <Lemmih> Hi.
18:37:31 <lispy> hi
18:37:51 <Lemmih> What's up, lispy?
18:37:54 <SamB> @type (!!).(!!)
18:37:56 <lambdabot>   Expecting a function type, but found `b'
18:37:56 <lambdabot>   Expected type: [a1] -> [a]
18:38:12 <lispy> Lemmih: well, i'm dropping out of school and working for a while starting on monday
18:38:45 <Korollary> to hell with the academia anyways...
18:38:58 <lispy> out of funding, and i'm painfully bored with my research group
18:39:01 <SamB> Korollary: they seem pretty determined to get there, don't they?
18:39:11 <lispy> "Yay, Can I have another dose of psychology blah?"
18:39:19 <lispy> hehe
18:39:43 <Korollary> the technical term is psychobabble
18:40:11 <lispy> no kidding
18:40:40 <lispy> HCI researchers like human studies because they can mean whatever the researcher wants them to
18:41:16 <Korollary> Hey,  in physics at least you have to get your hands dirty fudging the data.
18:41:32 * lispy prefers math
18:41:57 <lispy> you can make up a flaw proof if you want, but then someone will find the hole
18:42:34 <SamB> or decide your proof is too long to trust for a thing
18:42:49 <lispy> heh, i wonder if that's what they did with Wiles
18:42:58 <lispy> i've looked for his proof, but i couldn't find it
18:43:27 <Korollary> the NSA must have destroyed it.
18:43:32 <Cale> lispy: hmm... It's rather long. I'm not even sure if it's online
18:43:45 <Cale> I think you'd have to order a copy
18:44:01 <SamB> Cale: hardcover or paperback?
18:44:08 <jethr0> is there a way to skip a step in a loop "monad style"?
18:44:30 <Cale> SamB: It's something like 3 books.
18:44:43 <SamB> hardback then?
18:44:47 <Korollary> I thought it was 80 pages or so.
18:44:51 <Cale> yeah, most likely
18:44:57 <jethr0> like "do [(some kind of loop) x<- lalal]" which skips a step when "x == Nothing"
18:45:10 <Cale> Korollary: really? I seem to recall that there was a lot of setup involved
18:45:28 <Korollary> Cale: Let's consult Google.
18:45:29 <lispy> jethr0: when?
18:45:39 <jethr0> who the f*ck is gonna proofread a proof of 80 pages after typesetting?
18:46:11 <lispy> jethr0: someone will have to, or else it will not be accepted
18:46:12 <SamB> jethr0: who is going to read a 3-volume proof?
18:46:25 <lispy> iirc there is a seven year probation
18:46:26 <jethr0> or imaging saying "heck, why don't i get a good sip of whiskey and start on this 80 page proof over here"
18:46:47 <Korollary> Cale: "Wiles. proof was 200 pages long and had required more than ..."
18:46:52 <Cale> hey, that's nothing. The Classification Theorem for finite simple groups is estimated at 15000 pages.
18:47:00 <Korollary> (I don't wanna open the pdf that has that sentence...)
18:47:04 <Cale> Korollary: hmm
18:47:06 <jethr0> but that _really_ doesn't scale up.
18:47:29 <jethr0> imagine having this proof as basis for your work. _that_ takes some prep time!
18:47:41 <Cale> I'm sure that it's broken into smaller theorems
18:47:47 <Korollary> There's a 240 page book that is like a study guide.
18:48:09 <jethr0> _study guide_ for the gifted and those with too much time
18:48:17 <Cale> Perhaps it was divided into 3 sections somehow
18:48:24 <Korollary> well, those who are a kind of reviewer.
18:48:37 <Cale> I recall the number three was involved somehow in the organisation of the work.
18:48:37 <Cale> hehe
18:48:55 <jethr0> lispy, i am pondering the matter of the game "othello" and how to catch vectors that are not on the board with a monad...
18:49:06 <jethr0> right now i'm using maybe, but it's just too verbose!
18:49:28 <lispy> jethr0: can they be mzero and then do a msum?
18:49:55 <lisppaste2> jethr0 pasted "othello testing ground" at http://paste.lisp.org/display/14355
18:50:02 <Korollary> Cale: 1) Prologue 2) a thousand year's of head scratching 3) Oh well, now what? ;)
18:50:22 <lispy> nice
18:50:34 <Cale> Korollary: the abc conjecture, of course :)
18:50:38 <Pupeno> How do I check if a string can be read into an integer ?
18:50:58 <jethr0> hmm, but "isValid" and "colorThenOppColor" are _way_ too long!
18:51:02 <lispy> 1) Prolog (note the spelling) 2) a thousand yera's of head scratching 3) my seven years of head scratching
18:51:15 <jethr0> and "checkpoint" far too little flexible
18:51:19 <lispy> Pupeno: huh?
18:51:30 <Korollary> > (read "156") :: Integer
18:51:32 <lambdabot> 156
18:51:37 <Korollary> > (read "lol") :: Integer
18:51:39 <lambdabot> Prelude.read: no parse
18:52:05 <Pupeno> Korollary: I don't want my program to error, I want to my program to do something different.
18:52:09 <lispy> jethr0: what's wrong with isValid?
18:52:11 <Pupeno> lispy: ?
18:52:43 <jethr0> checkPoint always returns "False" when reaching the outside of the board.
18:52:43 <Lemmih> > reads "156lol" :: [(Integer,String)]
18:52:44 <lambdabot> [(156,"lol")]
18:53:07 <jethr0> but i might want to use it with function that return "True" for the off-board.
18:53:13 <Korollary> Yeah, you can check if the list is empty
18:53:22 <Korollary> > (reads "lol") :: Integer
18:53:23 <lambdabot> Couldn't match `Integer' against `[(a, String)]'
18:53:27 <Korollary> oops
18:53:38 <jethr0> anyway, i still have to do a loop over all directions from a given point and want to skip resulting points off the board
18:53:41 <Korollary> > (reads "lol") :: [(Integer, String)]
18:53:43 <lambdabot> []
18:53:53 <jethr0> and had hoped that there was a neat monadic way of doing that ;-)
18:53:54 <Korollary> there ya go
18:54:12 <jethr0> > (read "12df") :: [(Integer, String)]
18:54:13 <lambdabot> Prelude.read: no parse
18:54:19 <jethr0> > (reads"12df") :: [(Integer, String)]
18:54:20 <lambdabot> [(12,"df")]
18:54:27 <Cale> jethr0: the list monad?
18:54:33 <lispy> heh
18:54:36 <Cale> with filter?
18:54:38 <lispy> yeah, use a list comp
18:55:04 <jethr0> nono, the simple way i am aware of. i want to do some monad magic
18:55:04 <Lemmih> > let readM s = case reads s of [(v,_)] -> return v; _ -> fail "No read" in readM "123" :: Maybe Int
18:55:05 <lambdabot> Just 123
18:55:08 <Lemmih> > let readM s = case reads s of [(v,_)] -> return v; _ -> fail "No read" in readM "lol" :: Maybe Int
18:55:09 <lambdabot> Nothing
18:55:15 <Korollary> jethr0: you can also recurse and skip some using a case statement.
18:55:19 <jethr0> thus making checks for offboard positions as transparent as possible
18:55:57 <lispy> you could storte the onboard positions as a list and use `elem`
18:55:58 <jethr0> you know, as a further step to "do x <- Nothing; ..."
18:57:28 <lispy> this is one of those times when having a Bool type class would be nice.  Then, then otherColor = not
18:57:36 <Korollary> ?
18:57:47 <lispy> i have too many "then"
18:57:58 <Cale> Bool typeclass?
18:58:00 <jethr0> ?
18:58:05 <lispy> if colors were an instance of bool (only black and white of course)
18:58:20 <Korollary> why not make color an instance of Eq or something.
18:58:26 <lispy> haven't you ever wanted a bool type class?
18:58:32 <Cale> not really
18:58:41 <lispy> ah, i've wanted one several times
18:58:42 <jethr0> korollary, and how would i then get the opposite color?
18:58:42 <Korollary> Is "white" "true" ? heh.
18:59:03 <Cale> and [White, Black]
18:59:08 <lispy> i've wanted it for the boolean algebra not for the truth
18:59:13 <Korollary> jethr0: you can make your own typeclass that is a sub of Eq.
18:59:27 <Korollary> comparison and complement
18:59:35 <jethr0> cool, complement
19:00:10 <jethr0> "instance Eq Color where a ==b = ...; not a = case ..."?
19:00:28 <Korollary> nope
19:00:30 <Cale> data Color ... deriving Eq
19:00:34 <Korollary> @type not
19:00:36 <lambdabot> Bool -> Bool
19:00:46 <lispy> @type if
19:00:48 <lambdabot> parse error (possibly incorrect indentation)
19:00:56 <Korollary> you need to define a new function. e.g. complement White = Black, etc.
19:01:03 <lispy> oh right, if' should be part of prelude
19:01:13 <jethr0> that function i have
19:01:23 <Cale> if' seems mostly useful for obfuscation :)
19:01:32 <jethr0> @type if'
19:01:34 <lambdabot> Not in scope: `if''
19:01:43 <lispy> Cale: but sometimes if' is easier than rolling a lambda
19:01:44 <jethr0> what does it do?
19:01:52 <Cale> @pl \i t e -> if i then t else e
19:01:53 <lambdabot> if'
19:01:54 <lispy> it's the function version of if
19:02:01 <jethr0> cool
19:02:15 <lispy> @type \i t e -> if i then t else e
19:02:17 <lambdabot> forall t. Bool -> t -> t -> t
19:02:35 <Korollary> it's like the ? operator in C.
19:02:40 <lispy> anyway, i wish Bool was a typeclass so that i could create my own booleans
19:02:59 <lispy> "if" is one of the reasons
19:03:08 <Korollary> lispy: what would an instance of a Bool class be like?
19:03:17 <lispy> red
19:03:20 <lispy> shiny
19:03:40 <Cale> Would an instance of Boolean be required to be a distributive lattice?
19:03:55 <Cale> I think there should be various lattice classes
19:04:08 <Cale> That would take care of it
19:04:11 <lispy> Cale: what is a distributive lattice, i haven't studied latices
19:04:26 <Cale> http://en.wikipedia.org/wiki/Distributive_lattice
19:04:38 <lispy> haskell should definitely have more algerbra based type classes
19:05:05 <lispy> ah...
19:05:07 <lispy> interesting
19:05:52 <Pupeno> What's wrong with "case (reads s) of", I get the error: Ambiguous type variable `a' in the constraint: `Read a' arising from use of `reads'.
19:05:57 <lispy> oh, hmm...the natural numbers form a distributive lattice with gcd as meet and lcm as join
19:06:15 <lispy> it doesn't know what type to read
19:06:44 <Cale> lispy: thinking of natural numbers as bags of primes
19:06:51 <Pupeno> lispy: was that to me ?
19:06:53 <Korollary> Pupeno: reads is an overloaded function with multiple output types. Is it clear otherwise what it should produce?
19:06:55 <lispy> Pupeno: i think, "case (read s : Integer) of" would help
19:07:01 <Cale> ::
19:07:08 <Korollary> it
19:07:18 <Korollary> it's probably [(SomeType, String)]
19:07:32 <jethr0> pupeno: (reads s : [(Integer, String)]) or so
19:07:52 <lispy> oh, except it's :: as cale pointed out
19:08:00 <jethr0> no doesn't work for "reads "23 32 sdf"
19:08:01 <jethr0> sry
19:08:09 <Pupeno> lispy: that throws an error when s is not an Integer in a String.
19:08:25 <jethr0> > (reads "23 23 sdf" :: [(Integer, String)]
19:08:26 <lambdabot>  parse error on input `}'
19:08:30 <jethr0> > (reads "23 23 sdf" :: [(Integer, String)])
19:08:31 <lambdabot> [(23," 23 sdf")]
19:08:37 <jethr0> ah, ok
19:08:38 <Cale> Pupeno: you need to read potentially faulty input?
19:09:03 <Cale> Pupeno: you may be better off learning about something like Parsec if what you're doing is especially sophisticated
19:09:09 <Pupeno> Cale: no, I need to do something different if the input is a string or if it is a integer.
19:09:11 <Cale> (or even if it's not)
19:09:15 <Cale> ah
19:09:29 <SamB> Pupeno: in that case, all isDigit?
19:09:33 <Pupeno> Cale: I don't think it is specially sophisticated (a daytime cilent).
19:09:36 <lispy> i'm also in the camp where you just try it, and catch the exception when  it fails
19:09:39 <SamB> > all isDigit "123"
19:09:40 <lambdabot> True
19:10:45 <Pupeno> SamB: Thanks.
19:10:58 <lispy> > all \x -> True []
19:10:59 <lambdabot>  parse error on input `\'
19:11:07 <lispy> > all (\x -> True) []
19:11:08 <lambdabot> True
19:11:27 <lispy> > all (\_ -> True) "Lispy is teh cool."
19:11:28 <lambdabot> True
19:11:34 <lispy> oh yeah
19:11:39 <SamB> lispy: are you doing poetry?
19:11:52 <lispy> SamB: heh, next i'll do a haiku! ;)
19:11:55 <SamB> try iambic pentameter
19:12:30 <lispy> hmm...me thinks someone should code up an iambic pentameter generator
19:14:35 <lispy> furthermore, do it 50 lines or less not counting the dictionary file
19:15:17 <lispy> Go!
19:15:41 <lispy> getting caught playing Websudoku is a 2 line penalty
19:16:57 <Cale> hehe
19:17:02 <Cale> How about getting caught playing Simon Tatham's implementation of sudoku?
19:17:24 <lispy> not familiar with that
19:17:43 <Cale> he maintains a great collection of puzzle games
19:17:53 <Cale> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/
19:18:21 <Cale> I'm particularly fond of pattern, bridges, and loopy
19:19:35 <lispy> hmm...he doesn't have sudoku  yet
19:19:40 <Cale> solo
19:19:43 <Cale> it's there
19:20:03 <lispy> ah, he changed the name
19:32:38 <Pseudonym> Oh, I like bridges.
19:33:10 <Pseudonym> And loopy.
19:36:59 <SamB> @localtime musasabi 
19:37:02 <lambdabot> Local time for musasabi is Tue Dec  6 05:36:38 2005
19:37:06 <SamB> hmm
19:37:33 <SamB> still too early :-(
19:38:14 <mwc> Anybody tried building ghc with -j2 or the like?
19:41:01 <mwc> I've seen it break an ocaml build
19:46:59 <Pseudonym> Yay, these puzzles work beautifully under wine.
19:48:02 <Cale> under wine?
19:48:11 <Cale> why not compile them natively?
19:48:40 <SamB> Cale: too much work
19:48:51 * SamB is making it up
19:49:11 <Cale> hehe
19:51:32 <SamB> ooh, svn
19:51:43 <SamB> % svn get svn://ixion.tartarus.org/main/puzzles 
19:51:44 <SamB> unknown command: 'get'
19:52:15 <SamB> svn is clearly defective!
19:52:22 <Pseudonym> Indeed!
19:52:44 <Cale> there's a tarball of the source
19:53:18 <musasabi> SamB: you asked? (I don't like to release early)
19:53:53 <jethr0> musasabi, but it seems you like to get up early ;-)
19:53:58 <musasabi> Any hints on how to optimize this code - http://youzen.b2.fi/~musasabi/t.hs
19:53:58 <SamB> so, should we port these to DOS?
19:54:19 <musasabi> 4 lines, and my largest cost centre.
19:54:20 <xah> if you are on firefox, goto http://www.pugscode.org/, click on the learn haskell (.xul)
19:54:23 <xah> pretty cool
19:54:49 <jethr0> no idea, it's all gibberish to me ;-(
19:54:50 <SamB> musasabi: yes, I did.
19:54:50 <SamB> what are you doing up so early?
19:56:14 <SamB> @localtime musasabi 
19:56:17 <lambdabot> Local time for musasabi is Tue Dec  6 05:55:53 2005
19:56:31 <jethr0> how did transposing a list go again? ["abc", "def", "ghi"] => ["adg", "beh", "cfi"]
19:56:58 <Cale> > transpose ["abc", "def", "ghi"]
19:56:59 <lambdabot> ["adg","beh","cfi"]
19:57:07 <jethr0> that _certainly_ helped
19:57:20 <SamB> musasabi: well, have you profiled by closure type?
19:57:21 * jethr0 blushes and vows to shut up for a while
19:58:16 <Saulzar> Cale, I had a look at that Yampa stuff breifly, looks like that could be a great way to go, or at least something similar.
19:58:33 <Cale> Saulzar: I thought it might :)
19:59:25 <musasabi> SamB: late, not early.
19:59:45 <SamB> jethr0: next time you remember the imperative verb for something you want to do, try it as a function ;-)
20:00:03 <SamB> Cale: what is Yampa?
20:00:21 <Cale> SamB: A functional reactive programming library in Haskell
20:00:56 <SamB> Cale: oh, okay, whatever that means.
20:01:05 <Saulzar> The switching approach looks cool - you could use a simple RobotState -> RobotOutputs funciton, but the Arrow matching stuff seems to make it really simple
20:01:23 <SamB> is it like a generalized fran or something? not that I know much of anything about fran.
20:01:34 <jethr0> you mean like: "Crucio", "Imperio" or "Avada Kedavra" ;-)
20:02:17 <SamB> jethr0: in english, thank you
20:02:43 <Saulzar> SamB, It looks like it was designed for controlling robotics - I want to make an AI game for controlling robots :)
20:02:49 <SamB> they haskell libs are not in latin or hatever
20:02:57 <musasabi> SamB: -hy shows very small allocation.
20:03:00 <SamB> erg.
20:03:08 <SamB> musasabi: oh
20:03:21 <SamB> musasabi: so its just time that is the issue?
20:03:33 * musasabi checks retainers
20:04:10 <musasabi> 37% of time, 72% of allocation.
20:05:14 <musasabi> or rather -hb
20:05:48 <SamB> musasabi: but is it faster than the old version?
20:06:23 <musasabi> no drag objects either :-(
20:06:45 <SamB> note that you need not worry about pieces for sending much, because we're going to farm that out to another module anyways...
20:07:07 <SamB> (a module closer to the store)
20:07:07 <musasabi> SamB: that code serializes about 5 megabytes / sec on my machine.
20:07:49 <SamB> if its better than what we had before, and doesn't make the code too ugly, its fine ;-)
20:15:26 <jethr0> how do you filter in list monad?
20:16:24 <Cale> filter :)
20:16:34 <Cale> or guard
20:16:40 <Cale> @type guard
20:16:42 <lambdabot> Not in scope: `guard'
20:16:46 <Cale> @type Control.Monad.guard
20:16:47 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
20:16:59 <jethr0> thx
20:31:11 <SamB> musasabi: your code sounds fine to me
20:44:00 <mysteriousentity> What's a good debugging tool for Haskell?
20:44:34 <mysteriousentity> Hood/Hat/Feja/Buddha?
20:45:40 <palomer> quickcheck!
20:45:47 <palomer> I don't care what you say, it's a debugging tool to me
20:45:55 <palomer> (though I've never used it)
20:46:06 <mysteriousentity> spoken like a true purist
20:49:08 <mysteriousentity> I guess I'll just find out the hard way :)
20:49:45 <lispy> from what i hear around the channel, hat and buddha are your best bets
20:50:29 <mysteriousentity> thnks
21:01:56 <mysteriousentity> Is it possible to install on Windows under Cygwin?
21:02:39 <Cale> ghci is a pretty decent debugging tool actually :)
21:04:08 <Cale> The only trouble is when you have a huge lot of data flowing through your algorithm and it's hard to reconstruct some input which causes it to fail
21:04:18 <mysteriousentity> But it would be nice to see what functions reduce to.
21:04:32 <mysteriousentity> And their state just before something went wrong
21:04:58 <Cale> their input you mean?
21:06:06 <mysteriousentity> just reading throught the Hat descrition
21:06:12 <mysteriousentity> stuff like this looks cool
21:06:21 <mysteriousentity>  hat-observe Example
21:06:21 <mysteriousentity>                 hat-observe 2.04    (:h for help, :q to quit)
21:06:21 <mysteriousentity> hat-observe> main
21:06:21 <mysteriousentity> 1  main = IO (print (8,_|_))
21:06:21 <mysteriousentity> hat-observe> print
21:06:21 <mysteriousentity> 1  print (8,_|_) = IO (print (8,_|_))
21:06:24 <mysteriousentity> hat-observe> last'
21:06:25 <mysteriousentity> 1  last' [8,_,_] = _|_
21:06:27 <mysteriousentity> 2  last' [_,_] = _|_
21:06:29 <mysteriousentity> 3  last' [_] = _|_
21:06:31 <Cale> yeah, I just wish it was more compatible
21:06:31 <mysteriousentity> 4  last' [] = _|_
21:06:34 <mysteriousentity> hat-observe> :quit
21:07:38 <Cale> It would be nice to have it more integrated with GHC so it would keep up extensions and libraries-wise.
21:08:16 <Cale> then again, you perhaps wouldn't really want to tie it completely to ghc.
21:08:58 <mysteriousentity> does GHC really have much competition?
21:09:19 <Cale> well, there are some neat implementations in the works
21:09:37 <Cale> apart from hugs, there's jhc and yhc
21:10:11 <Cale> jhc does some really interesting optimisations
21:10:18 <autrijus> there's also helium and ehc, but their use are more educational
21:10:23 <mysteriousentity> I thought hugs was "obsolete". That's what a lecturer told me once. never heard of the other two
21:10:27 <Cale> yhc compiles to platform independent bytecode
21:10:43 <Cale> hugs isn't exactly obsolete -- it still has developers
21:10:58 <Cale> but people do tend to use ghc quite a bit more
21:11:15 <mysteriousentity> what is independent bytecode?
21:11:30 <autrijus> think java ;)
21:11:31 <Cale> platform-independent
21:11:40 <autrijus> "write once, run away"
21:11:44 <autrijus> er I mean, "run anywhere"
21:11:50 <mysteriousentity> wouldn't that make it even slower?
21:12:00 <Cale> not necessarily
21:12:14 <autrijus> mysteriousentity: there's JIT and AOT possibilities even with bytecode
21:12:16 <Cale> it has performance somewhere in between hugs and ghc right now
21:12:26 <autrijus> and the slowdown is not critical usually
21:12:27 <Cale> and it's just started
21:13:53 <mysteriousentity> interesting. I'll keep an eye out for that.
21:15:09 <Cale> mysteriousentity: there's more potential for getting comparable performance from bytecode since even the compiled implementations have a lot of runtime overhead right now anyway
21:17:31 <lispy> what are we talking about?
21:17:45 <Cale> Haskell implementations
21:17:52 <lispy> JIT for haskell?
21:18:24 <Cale> Yhc is a bytecode compiler for Haskell.
21:18:29 <lispy> do we have tools for doing space analysis (finding leaks caused by laziness or inexperienced haskellers)
21:18:57 <Cale> ghc has profiling tools
21:19:07 <lispy> aye, i've used 'em a little
21:19:12 <Cale> they're quite good once you figure out how to read the output
21:20:13 <lispy> man, emacs needs a more aggressive gc.  It was just up to 390 megs before i restarted it
21:22:40 <jethr0_> hi, i have "data Field = Stone Color | Empty" and i want to make Field an instance of monad
21:22:45 <Cale> It feels like gnome apps all slowly leak memory to me. My non-cache memory usage slowly increases over time until I restart it, regardless of what apps I'm running.
21:23:07 <Cale> Field isn't a type constructor
21:23:09 <jethr0_> but for that i have to tie down on type in monad's kind, or something
21:23:12 <Cale> so it can't be
21:23:16 <jethr0_> ;-(
21:23:39 <jethr0_> so, when i write "data Field a = Stone a | Empty", how can i bind "a" to "Stone"
21:23:44 <Cale> Have you read MonadsAsContainers btw?
21:23:49 <jethr0_> yes
21:23:57 <jethr0_> but reading and understanding are two separate things
21:23:59 <Cale> then it would be isomorphic to Maybe
21:24:07 <lispy> yay!
21:24:16 * lispy loves it when Maybe gets a cool use
21:24:22 <jethr0_> i know, but i have a Maybe in a Maybe and that gets totally unreadable
21:24:25 <Cale> What do you mean by "bind a to Stone"?
21:24:41 <Cale> you can always get rid of those
21:24:43 <jethr0_> so i wanted to have different names for "Just" and "Nothing" to make the semantic difference
21:24:50 <lispy> jethr0_: in that case, just follow the same idea to implement your Field monad
21:25:08 <jethr0_> i have an array of the current Field
21:25:12 <lispy> jethr0_: eg., look up the maybe monad definition
21:25:27 <Cale> > join (Just (Just 5))
21:25:29 <lambdabot> Just 5
21:25:36 <jethr0_> so, how would i have to declare it with "data Field a"? "Array.array ... ... (Field Stone)" ??
21:25:38 <Cale> > join (Just Nothing)
21:25:40 <lambdabot> Add a type signature
21:26:04 <lispy> > join (Just (Nothing :: Int))
21:26:05 <lambdabot> Couldn't match `Int' against `Maybe a'
21:26:18 <lispy> hmm...
21:26:23 <Cale> > join (Just (Nothing)) :: Maybe Int
21:26:25 <lambdabot> Nothing
21:26:33 <lispy> oh right
21:26:48 <lispy> jethr0_: i'm not following you
21:26:49 <jethr0_> all i want is to have different names for the two nested Maybes
21:27:14 <lispy> jethr0_: then why do you need a monad?
21:27:16 <jethr0_> i have type "Maybe Field" which right now translates to "Maybe (Maybe Color)"
21:27:39 <jethr0_> but unpacking that becomes a readability nightmare, because one never knows which Maybe is meant
21:27:57 <lispy> jethr0_: what about joining them as Cale demonstrated?
21:28:04 <jethr0_> so, it would be nicer to have "Just (Stone Black)" rather than "Just (Just Black)"
21:28:35 <jethr0_> only for readability
21:28:38 <lispy> jethr0_: in that case, just fixup your data contsructor and you're done, right?
21:28:55 <lispy> data Field a = Stone a | Empty
21:28:57 <jethr0_> yes, but i don't know how to declare the array
21:29:05 <Cale> Why a Maybe Field?
21:29:07 <lispy> what array?
21:29:20 <jethr0_> sorry, for having caused such confusion
21:29:27 <jethr0_> i'll post some code
21:29:31 <lispy> cool
21:29:33 <jethr0_> just a sec
21:29:53 <Cale> newtype Board = DiffArray (Int,Int) (Maybe Stone)
21:29:56 <lispy> i've been really unproductive tonight
21:30:07 <Cale> data Stone = White | Black
21:30:11 <Cale> er
21:30:16 <Cale> newtype Board = Board (DiffArray (Int,Int) (Maybe Stone))
21:30:19 <lisppaste2> jethr0 pasted "othello v2" at http://paste.lisp.org/display/14360
21:30:27 <lispy> yeah, i'm with Cale on this one
21:30:32 <lispy> take the maybe out of the stone
21:31:34 <jethr0_> sorry for missing type declarations... bad habits die hard ;-)
21:32:46 <lispy> jethr0_: actually, a lot of people new to haskell over constrain the types
21:33:06 <lispy> so, if you relax that and let the type checker do the work you can learn from it to an extent
21:33:24 <jethr0_> sure, but for posting code type declarations clarify a lot!
21:33:50 <Pupeno> How do I build a PortID out of a string that contains the digits of a port number ?
21:34:14 <jethr0_> cale, i had "type Field = Maybe Stone" before, but am considering to change for the said reasons.
21:34:22 <Korollary> Pupeno: you have to turn the string into an integer
21:34:28 <Lemmih> Pupeno: PortNumber (read str)
21:34:38 <jethr0_> but obviously i will submit to the channels cumulative wisdom *gg*
21:34:48 <Cale> jethr0_: where does Maybe Field come up?
21:35:11 <lispy> jethr0_: i'd say get rid of your monad instance.  Are you using it anywhere?
21:35:40 <jethr0_> sorry, it's a non-working (old) version of the code *srysrysry*. imagine "type Field = Maybe Monad"
21:35:49 <jethr0_> if you want to i can clean it up and repost it!
21:36:04 <jethr0_> although it's mostly working (95%)
21:36:22 <Pupeno> Korollary: I tried that, it didn't work (running (Network.PortNumber (read "13"))): No instance for (Read Network.Socket.PortNumber) arising from use of `read' at <interactive>:1:21-24
21:36:31 <lispy> jethr0_: what initField for?
21:36:33 <Pupeno> Lemmih: idem.
21:36:38 <lispy> jethr0_: i don't get it
21:36:49 <Lemmih> Pupeno: PortNumber (fromIntegral (read str))
21:37:12 <jethr0_> initField initialised the four centerpieces of the othello board
21:37:31 <lispy> ah
21:37:43 <jethr0_> sorry, i didn't realise it's so convoluted... should i repost a working version?
21:38:20 <lispy> jethr0_: can you get rid of the case?
21:38:29 <lispy> jethr0_: just directly use pattern matching?
21:38:34 <Pupeno> What is an Integral exactly ?
21:38:51 <Korollary> Pupeno: It's a typeclass, which PortNumber belongs to.
21:39:44 <Korollary> @type fromIntegral
21:39:45 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:40:04 <jethr0_> lispy, yes, i could and i will, thx
21:40:44 * Pupeno doesn't really get it, well, maybe that'll change with time and study.
21:41:24 <lisppaste2> jethr0 annotated #14360 with "working version" at http://paste.lisp.org/display/14360#1
21:41:40 <Korollary> Pupeno: Actually the key here is that PortNumber is an instance of Num as well. Once you understand typeclasses, it's pretty simple.
21:42:34 <Pupeno> Korollary: I thought I understood them, but I keep hitting walls here.
21:42:43 <lispy> dim = 8 ?
21:42:54 <lispy> jethr0_: are you sure you want global data?
21:42:55 <jethr0_> it's the dimension of the board
21:43:36 <jethr0_> don't want to pass it in _every_ function
21:44:18 <lispy> well, that would be a good place for a monad
21:44:30 <lispy> the random number monad is an example of this
21:45:28 <jethr0_> hmm
21:46:47 <lispy> granted, i can't visualize how we would apply that to your code and have it be nice
21:46:55 <Cale> use a State Board monad, but newtype it, (deriving Monad, Functor), and then implement the relevant operations on it
21:47:09 <Cale> and don't export the data construtor for the newtype
21:47:19 <lispy> ah, well there we have have
21:47:20 <lispy> it
21:47:25 * lispy can't type
21:47:33 <lispy> actually, should go back to working on other stuff
21:47:46 <lispy> i have a final exam in the morning as well as a portfollio due
21:48:01 <jethr0_> sure thing, thx for your help
21:48:11 <Cale> does that make sense?
21:48:19 <Cale> Want an example?
21:48:32 <jethr0_> yes, makes sense
21:48:38 <Cale> http://www.haskell.org/hawiki/MonadRandom
21:49:08 <jethr0_> but what i'm trying to do right now is clean up "isValid" and "findOwnColor"
21:49:09 <lispy> jethr0_: np, good luck
21:49:09 <Cale> there's a nice example using that technique to construct a monad/monad transformer in which random values are available
21:49:30 <jethr0_> them being so convoluted in the first place, because i wanted to max out using Monads ;-))
21:49:45 <jethr0_> i've seen and used random monad.
21:50:08 <lispy> jethr0_: what does isValid need to do?
21:51:03 <jethr0_> it checks whether the current field is empty, whether the next field is (invert color) and then calls findOwnColor
21:53:54 <Pupeno> lisppaste2: url
21:53:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:54:37 <lisppaste2> Pupeno pasted "Daytime client" at http://paste.lisp.org/display/14363
21:55:00 <Pupeno> Any hints on improvements from that daytime client implementation in Haskell ?
21:56:07 <jethr0_> pupeno, looks really good to me
21:56:26 <Pupeno> jethr0_: awesome! :D
21:56:48 <jethr0_> although you might do: "1 -> getTime (...) >>= putStrLn"
21:56:53 <Pupeno> Thank you for taking a look at it.
21:57:26 <Pupeno> jethr0_: Thanks.
21:57:34 <jethr0_> the "-> ... <-" looks a bit scary to me. but that might be the usual way to do it, i really wouldn't know
21:57:54 <Cale> It looks okay to me :)
21:58:38 <Korollary> yeah it is ok
21:59:01 <lisppaste2> Pupeno annotated #14363 with ">>= is nice" at http://paste.lisp.org/display/14363#1
21:59:06 <Korollary> my isp is super slow for some reason
21:59:25 <lispy> jethr0_: if it does two distinct things, maybe it wants to be two distinct functions
21:59:28 <Pupeno> thank you all of you for taking the time to look at my boring code.
21:59:37 <jethr0_> ;-)
22:00:28 <jethr0_> lispy, you might be right. but part of the problem is the blockiness of the code that this crazy use of monads brings with it
22:00:49 <jethr0_> indented with if/then/else's it looks much more like a single function
22:06:01 <lispy> jethr0_: to be honest i can't figure it out
22:06:17 <lispy> you have "when (field /= Nothing) Nothing"
22:06:24 <jethr0_> i can understand that. after finishing the code, i was disappointed myself by the unreadability ;-((
22:06:25 <lispy> it's like, er?
22:06:44 <jethr0_> i was trying to use as much of the Maybe short-circuiting as possible
22:06:49 <palomer> someone write me a fixed point operator in haskell
22:06:51 <palomer> quick!
22:06:57 <jethr0_> fix
22:07:10 <palomer> > fix
22:07:11 <lambdabot>  add an instance declaration for (Show ((a -> a) -> a))
22:07:16 <jethr0_> and with many things magic-like this didn't improve understandability much
22:07:28 <palomer> > fix 2
22:07:30 <lambdabot>  add an instance declaration for (Num (a -> a))
22:07:36 <jethr0_> > take 10 $ fix (1:)
22:07:38 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
22:07:53 <palomer> @type fix
22:07:54 <lambdabot> Not in scope: `fix'
22:07:59 <lispy> jethr0_: what does that line do?
22:08:04 <jethr0_> @type Control.Monad.Fix.fix
22:08:05 <lambdabot> forall a. (a -> a) -> a
22:08:09 <lispy> jethr0_: abort the monad when it's not a field?
22:08:15 <jethr0_> which line?
22:08:26 <lispy> jethr0_: the "when ..." line
22:09:22 <jethr0_> "do a <- x; b a" notation is syntactic sugar for "x >>= b"
22:09:27 <lispy> jethr0_: i think the lack of comments contributes to the reabability :)
22:09:38 <lispy> yes
22:09:40 <jethr0_> and "Nothing >>= f = Nothing"
22:09:58 <jethr0_> therefore "do (anything that produces Nothing); ..." with result in Nothing
22:10:13 <jethr0_> lispy, it's work in progress and a feasability study...
22:10:20 <jethr0_> but sorry anyways
22:12:29 <jethr0_> experiments in code terseness don't lend themselves well to reading *g*
22:12:32 <lispy> @type Monad.when
22:12:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:13:16 <lispy> jethr0_: does that line do what you think it does?
22:13:26 <jethr0_> when p s = if p then s else return ()
22:13:42 <jethr0_> yes, the code is working just fine
22:13:54 <lispy> right so you're saying, if (field /= Nothing) then Nothing else return ()
22:14:25 <jethr0_> i've since changed it to "guard (field == Nothing)", which does the same thing
22:14:27 <jethr0_> yes
22:14:53 <lispy> so you want the field to be nothing
22:14:56 <lispy> hmm...okay
22:15:33 <jethr0_> this is shorter for "if (field /= Nothing) then Nothing else let next ... in ..."
22:16:20 <jethr0_> yes, i know it's not exactly beautiful, hence the "guard"
22:17:18 <lispy> it's okay, i'm just trying to figure out what you're expressing
22:18:33 <lispy> there must a be a way to shorten the "nextF <- .. do nextCol <- nextF"
22:20:48 <lispy> hmm..it's not coming to me
22:20:57 <jethr0_> yes, it's "nextCol <- getField next board >>= id"
22:21:02 <jethr0_> as used in the more recent version
22:21:08 <jethr0_> but also painfully obscure
22:21:14 <lispy> oh, od i need to reload?
22:21:19 <jethr0_> hmm
22:21:27 <jethr0_> but as i said, little has changed...
22:21:33 <jethr0_> i'll upload an ever newer version...
22:22:02 <lisppaste2> jethr0 annotated #14360 with "more working" at http://paste.lisp.org/display/14360#2
22:22:22 <jethr0_> monads, reloaded
22:22:38 <lispy> ah, much better
22:22:43 <lispy> those guards help a ton
22:23:45 <jethr0_> exactly...
22:25:37 <jethr0_> lisppaste should have haskell highlighting... reading it highlighted is _much_ nicer than plain...
22:27:43 <lisppaste2> Pupeno annotated #14363 with "A server as well" at http://paste.lisp.org/display/14363#2
22:27:43 <lisppaste2> lispy annotated #14360 with "maybe?" at http://paste.lisp.org/display/14360#3
22:27:55 <Pupeno> there, my daytime server :)
22:28:18 <lispy> jethr0_: i thought it did have haskell, anyway, i don't like case, so i've changed a few things to the way i try to code
22:29:42 <lispy> jethr0_: i bet you can do better than initField
22:29:49 <lispy> i bet you can use a list comp
22:30:09 <jethr0_> for what? possibleMoves? of course, but would that be as much fun? ;-)
22:31:47 <jethr0_> cool, thx, implementing your changes right now ;-)
22:34:08 <jethr0_> hmm, but the list comp. for initField would be so long and unwielding...
22:34:10 <lisppaste2> lispy annotated #14360 with "list comp?" at http://paste.lisp.org/display/14360#4
22:34:26 <lispy> it's not actually a list comp
22:34:32 <lispy> but, maybe you likeit better?
22:34:38 <jethr0_> unwieldy
22:35:06 <lispy> oh, typo too
22:35:14 <lispy> get rid of initField
22:36:07 <lisppaste2> lispy annotated #14360 with "fixo for typo" at http://paste.lisp.org/display/14360#5
22:36:17 <lispy> you find that unweildy?
22:36:28 <jethr0_> hmm, i see your point, although i only part from initField with difficulty
22:37:07 <jethr0_> no, i though you meant: "[..., case (x,y) of (4,4) -> ; ...; ...; ...]"
22:37:33 <lispy> ah
22:38:46 <lispy> findOwnColor would be next on my list to shorten
22:38:58 <lispy> but, alas i should for reals do other things ;)
22:39:04 <jethr0_> i wonder if you can tell "Array.array" what to return on undefined elements
22:39:37 <jethr0_> i am happy that you're helping me, but don't let me keep you from exam preps/sleeping
22:40:45 <lispy> jethr0_: i think there is a shorter init for array that you could be using
22:40:54 <jethr0_> aha? do tell
22:43:10 <lispy> hmm...i guess not
22:43:17 <lispy> http://www.haskell.org/onlinereport/array.html
22:45:28 <jethr0_> i am actually quite happy with the current code. but that might just be conditioning and everyone else will likely still jump back disgustedly ;)
22:45:44 <lispy> heh
22:45:58 <lispy> i think findOwnColor could be nicer
22:46:05 <lispy> but other than that, i like it too
22:46:17 <jethr0_> thx a lot.
22:46:27 <lispy> np
22:46:29 <lispy> i'm off to bed
22:46:31 <lispy> good luck
22:46:39 <jethr0_> nite
23:33:06 <mwc> Question about this tutorial here: http://www.nomaware.com/monads/html/. I have a solution to an exercise parent s = mother s `mplus` father s
23:33:21 <mwc> whereas their solution paranthesis the field extract functions on s
23:33:39 <mwc> Is that necessary for some subtle reason?
23:35:31 <Cale> hm?
23:37:01 <Cale> oh
23:37:13 <Cale> no, the parentheses aren't necessary
23:53:20 <mwc> good, I figured field extraction functions had function-level precedence
