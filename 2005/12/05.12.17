00:33:58 <dons> 19:28 @dons:: @. pl djinn a -> a -> Either a ()
00:33:59 <dons> 19:28  donsbot:: f = const Left
00:34:01 <dons> :D
00:35:17 <xerox> Wow.
00:45:52 <dons> @quit super-cool happy fun
00:51:31 <dons> @compose pl djinn a -> b -> ((a, Either b a), (b, Maybe a))
00:51:32 <lambdabot> f = (`ap` flip (,) Nothing) . ((,) .) . (. Left) . (,)
00:51:35 <dons> hehe
00:52:56 <dons> @. eval id 1 + 2
00:52:57 <lambdabot> 3
00:54:20 <xerox> @. ?!
00:54:21 <lambdabot> Not enough arguments to @.
00:54:24 <xerox> hey
00:54:30 <xerox> You're -crazy- dons.
00:55:21 <xerox> @compose id compose eval id 1 + 2
00:55:22 <lambdabot> 3
00:55:25 <xerox> hahaha.
00:56:54 <dons> oh, I hadn't thought about compoosing compose
00:57:23 <dons> @. id . eval id 1 + 2
00:57:24 <lambdabot> 3
00:57:39 <xerox> yay
00:59:40 <Heffalump> woot!
00:59:57 <Heffalump> dons++
01:00:03 <xerox> right
01:00:04 <Heffalump> @karma+ dons
01:00:04 <lambdabot> dons's karma raised to 19.
01:00:06 <xerox> @karma+ dons
01:00:06 <lambdabot> dons's karma raised to 20.
01:00:17 <dons> yay!!
01:00:56 <Heffalump> did you change the interface type of plugins to do it?
01:01:53 <dons> yep.
01:02:24 <Heffalump> what happens with things that output multiple lines?
01:02:50 <xerox> @pretty let a = b; b = a; in ()
01:02:51 <lambdabot>  i = let a = b
01:02:51 <lambdabot>    b = a
01:02:51 <lambdabot>    in ()
01:03:00 <xerox> @. id pretty let a = b; b = a; in ()
01:03:01 <lambdabot>  i = let a = b         b = a       in ()
01:03:08 <xerox> :)
01:03:11 <dons> compose :: (String -> LB [String]) -> (String -> LB [String]) -> (String -> LB [String])
01:03:19 <dons> compose f g xs = g xs >>= f . concat
01:03:23 <dons> quick hack, just a concat.
01:03:33 <dons> should be an unlinnes, maybe
01:03:37 <Heffalump> ok
01:03:53 <Heffalump> as long as the output can't blow up
01:07:56 <dons> we may have to tweak some plugins so their output is more @. friendly.
01:08:10 <dons> and then there's much further we can take this idea.
01:09:35 <xinming> (Reader r) >>= f = Reader $ \e -> f (r e) e 
01:09:41 <xinming> what does this function do please?
01:09:52 <xerox> it is bind for the reader monad
01:09:55 <xerox> so..
01:10:21 <xinming> I know it's bind, But I don't know what it do exactly. :-/
01:10:47 <joelr1> morning!
01:11:00 <xerox> xinming: can you paste how does return look like?
01:11:00 <joelr1> anyone up already?
01:11:01 <joelr1> :D
01:11:17 <xerox> hey there.
01:11:26 <xinming> xerox: return a         = Reader $ \e -> a 
01:11:38 <xinming> It's from <<All about monads>>
01:11:41 <xerox> ah :-D
01:11:45 <xerox> @google All About Monads
01:11:46 <lambdabot> http://www.nomaware.com/monads/html/
01:11:52 <xinming> :-/
01:12:00 <xerox> @. eval reverse . google All About Monads
01:12:01 <lambdabot> composemodule failed: No such command: "reverse"
01:12:01 <xinming> I just wish to understand reader monad.
01:12:10 <xerox> @. (eval reverse) . google All About Monads
01:12:11 <lambdabot> composemodule failed: No such command: "(eval"
01:12:19 <xerox> it would have been fun :P
01:12:28 <xerox> @. reverse . google All About Monads
01:12:29 <lambdabot> composemodule failed: No such command: "reverse"
01:13:06 <xerox> The return function creates a Reader that ignores the environment and produces the given value.
01:13:09 <joelr1> @paste
01:13:09 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:13:16 <xerox> The binding operator produces a Reader that uses the environment to extract the value its left-hand side and then applies the bound function to that value in the same environment.
01:14:01 <xerox> ...does that make sense to you?
01:14:27 <xerox> Keep in mind that r :: e -> a
01:15:08 <joelr1> can someone please help  me with paste?
01:15:28 <xerox> uh.
01:15:54 <dons> xerox, it's not a haskell interpreter.. ;) (@compose isn't .. .yet)
01:16:27 <xinming> what does `f (r e) e` mean?
01:16:49 <xerox> xinming: f is applied to two arguments, namely `(r e)' and `e'.
01:17:18 <xerox> dons: parens support and we're done :-)
01:17:34 <dons> lambdas would be good tooo
01:17:39 <xerox> uuuuuuh.
01:17:57 <xerox> Contemplate the moment, Haskell is emerging from the ground up another time.
01:18:03 <dons> hehe
01:18:16 <xinming> xerox: So, this means that the function will need to deal with the value, and the value which tightly bind to the monad?
01:18:22 <dons> I'll just think about how to hook it into @eval
01:18:23 <xinming> hm, I mean f
01:18:31 * xerox hugs dons
01:18:48 <xerox> xinming: sorry I don't understand the question
01:18:48 <takuan> what does . do?
01:19:13 <joelr1> dons: can you please give me a hand?
01:19:14 <xerox> takuan: it composes plugins :-)
01:19:24 <xinming> xerox: I mean the `f (r e) e`, which is in right part of the bind function.
01:19:25 <takuan> i.e.?
01:19:28 <xerox> @. pl djinn a -> b -> a
01:19:28 <lambdabot> f = const
01:19:33 <xerox> hehehe.
01:19:40 <xerox> xinming: what about it.
01:20:18 <xinming> xerox: does that mean the function which have to do with the real value for it's first argument, and the value from monad for the second argument?
01:20:32 <dons> joelr1,  got to go, sorry.
01:21:08 <joelr1> xerox: can you take a look at  my bit of code, please?
01:21:12 <takuan> xerox: ok, got it
01:21:45 <joelr1> i'm trying to figure out how i can eval the whole list (make it strict) before returning it
01:21:55 <dons> oh, use length.
01:21:56 <xerox> joelr1: deepSeq?
01:22:07 <joelr1> but where do i insert it?
01:22:16 <joelr1> so that it actually gets evaluated 
01:22:29 <joelr1> as opposed to, say, omitted because it's never used 
01:22:45 <dons> use a forkIO
01:22:56 <dons> forkIO (Control.Exception.evaluate (length output) >> return ())
01:23:06 <joelr1> launch a thread? to return a list? i can't this is pure code
01:23:12 <joelr1> umm
01:23:14 <joelr1> actually it's not
01:23:15 <dons> ok. then use a seq.
01:23:32 <joelr1> how about just return $! length ... 
01:23:34 <joelr1> would that work?
01:23:49 <xerox> xinming: hehe, I don't know what to answer.
01:24:16 <xerox> (length output) `seq` ..
01:26:00 <joelr1> thank you guys
01:27:00 <xinming> xerox: hmm, for example, return(a) >>= f, in the returned Monad, there infact, contains 2 values, Should the function which can deal with these 2 values instead of one?
01:27:14 <xinming> `f`
01:27:58 <xinming> I mean the reader Monad
01:28:43 <xerox> @type \x f -> (return x :: Reader Int Int) >>= f 
01:28:44 <lambdabot> Not in scope: type constructor or class `Reader'
01:28:50 <xerox> @type \x f -> (return x :: Control.Monad.Reader Int Int) >>= f 
01:28:51 <lambdabot>   Not in scope: type constructor or class `Control.Monad.Reader'
01:28:56 <xerox> @type \x f -> (return x :: Control.Monad.Reader.Reader Int Int) >>= f 
01:28:57 <lambdabot> forall b.
01:28:57 <lambdabot> -> (Int -> Control.Monad.Reader.Reader Int b)
01:28:57 <lambdabot> -> Control.Monad.Reader.Reader Int b
01:29:17 <xerox> ah, doh.
01:30:48 <xerox> maybe:
01:30:50 <xerox> > runReader (Reader $ \x -> x + 1) 1
01:30:51 <lambdabot> 2
01:31:04 <xinming> How about function `f`
01:31:16 <dons> @quit  []
01:32:01 <gour> dcoutts: ping
01:32:48 <gour> _metaperl: hi, may i ask you a question?
01:32:48 <xerox> > runReader (do { v <- asks (lookup 'x'); return v}) [('x',1),('y',2)]
01:32:49 <lambdabot> Just 1
01:34:16 <xinming> amazing to see how you can do that. But I don't understand. :-(
01:34:58 <mwc> Was just browsing through the wiki, What's the likelyhood of seeing dependent types in HaskellTwo?
01:35:06 <xerox> > let getV = do { v <- asks (lookup 'x'); return v } in runReader (do { a <- local (\xs -> ('x',0):xs)) getV; b <- getV, return (a,b)}) [('x',1),('y',2)]
01:35:06 <lambdabot>  parse error on input `)'
01:35:09 <xerox> ok :P
01:35:42 <xerox> > let getV = do { v <- asks (lookup 'x'); return v } in runReader (do { a <- local (\xs -> ('x',0):xs) getV; b <- getV; return (a,b)}) [('x',1),('y',2)]
01:35:44 <lambdabot> (Just 0,Just 1)
01:35:54 <xerox> Isn't it quite straightforward to use?
01:36:11 <xerox> Using the `local' and `asks' functions, that is.
01:36:16 <xerox> ask, anyway.
01:36:58 <xinming> I don't wish to know only how to use, I want to know the base composition of that. :-)
01:37:10 <xerox> > runReader (asks (reverse)) "gnimnix"
01:37:11 <lambdabot> "xinming"
01:37:55 <xerox> > "gnimnix" >>= return . reverse
01:37:56 <lambdabot> Couldn't match `[a]' against `Char'
01:38:06 <xerox> > ["gnimnix"] >>= return . reverse
01:38:07 <lambdabot> ["xinming"]
01:38:19 <xerox> Yawn sorry.  I'm too sleepy today.
01:38:53 <xinming> xerox: I will try to catch the example you show. :-)
01:39:00 <xinming> xerox: thanks anyway
01:48:52 <ski> morning #haskell
01:49:19 <boegel|home> yo ski
01:51:20 <araujo> Hello Haskell'ers.
01:53:53 <boegel|home> yo araujo 
01:54:50 <araujo> Hello boegel|home 
01:55:06 <araujo> Seems quiet around......
01:56:28 <joelr1> i should be able to post a solid profiling tutorial soon :D
01:56:32 <boegel|home> it wasn't half an hour ago :)
01:57:30 <xerox> joelr1: on TMR?
01:57:30 <joelr1> i'm recording everything that i'm doing, step by step
01:58:00 <joelr1> xerox: no, recording it locally for now
01:58:28 <joelr1> shapr wants me to write a tmr article and i want to post to my blog so i'll just link to the tmr article from my blog i think
01:59:05 <joelr1> this should be of good use to everyone, tightening up heavily-used serialization code
02:00:47 <joelr1> i made a huge mistake initially that could have derailed the project and that certainly delayed me by a few weeks :( i assumed that when you passed -p to cabal (1.1+ i think) to create both regular and profiled version it also passed in -auto-all 
02:00:51 <joelr1> it doesn't
02:08:42 <astrolabe> joelr1: That would be useful.  We need more tutorials I think.
02:27:45 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","Haskell libraries top 10: http://haskell.org/tmrwiki/TopTenHaskell"]'
02:27:45 --- topic: set by CosmicRay on [Tue Nov 29 13:15:49 2005]
02:27:45 --- names: list (clog JKnecht Lokadin bpalmer jiing jesse99 cooz_ fanopnaic tromp_ resiak Igloo Lunar^ arguile cmeme drbean sethk tic eivuokko tessier Heffalump Azmo kaol eyck kelan wolverian ceatinge musasabi magagr ChilliX JohnMeacham norpan emu flux__ tuomov jp-autark gzl dhpeterson tic|school neologism wli gdsx dcoutts erxz_paste kpk johs djw pejo cathper SlowByte AtnNn Spark tumm ksandstr jlouis kala juhp aheller kosmikus dcoutts_ soysauce zamez seafood)
02:27:45 --- names: list (audreyt rep integral PupenoL shawn_ WillKW astrolabe noj genneth sieni metaperl ctrlsoft mattam boegel eno-away triplah Ferret GnuVince tmoertel vincenz earthy Lor ValarQ ulfdoz cpatrick yaarg Korollary lispy marcuss Si\Un1 dany2k|uni-off moonlite lome shapr Khisanth takuan lennart wilx ex_nor cjs kmag skylan C-Keen Philippa_ Cale _metaperl Wallbraker TFK xerox chucky cbus kpreid_ borism ramkrsna TheHunter ibid jimapple kbtest spamsch mornfall)
02:27:45 --- names: list (pengo SamB jethr0_ binary42 cognominal rq Saulzar seerhut Nomius_ elk svens twb gour xinming scw joelr1 lambdabot datenmaulwurf boegel|home ski araujo boro)
02:39:32 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","Haskell libraries top 10: http://haskell.org/tmrwiki/TopTenHaskell"]'
02:39:32 --- topic: set by CosmicRay on [Tue Nov 29 13:15:49 2005]
02:39:32 --- names: list (clog Lokadin praseodym jesse99 cooz_ fanopnaic tromp_ resiak Igloo Lunar^ arguile cmeme drbean sethk tic eivuokko tessier Heffalump Azmo kaol eyck kelan wolverian ceatinge musasabi magagr ChilliX JohnMeacham norpan emu flux__ tuomov jp-autark gzl dhpeterson tic|school neologism wli gdsx dcoutts erxz_paste kpk johs djw pejo cathper SlowByte AtnNn Spark tumm ksandstr jlouis kala juhp aheller kosmikus dcoutts_ soysauce zamez seafood audreyt)
02:39:32 --- names: list (rep integral PupenoL shawn_ WillKW astrolabe noj genneth sieni metaperl ctrlsoft mattam boegel eno-away triplah Ferret GnuVince tmoertel vincenz earthy Lor ValarQ ulfdoz cpatrick yaarg Korollary lispy marcuss Si\Un1 dany2k|uni-off moonlite lome shapr Khisanth takuan lennart wilx ex_nor cjs kmag skylan C-Keen Philippa_ Cale _metaperl Wallbraker TFK xerox chucky cbus kpreid_ borism ramkrsna TheHunter ibid jimapple kbtest spamsch mornfall pengo)
02:39:32 --- names: list (SamB jethr0_ binary42 cognominal rq Saulzar seerhut Nomius_ svens twb gour xinming scw joelr1 lambdabot datenmaulwurf boegel|home ski araujo boro_ bpalmer iblechbot)
02:42:22 <xinming> anyone here can explain the Reader Monad for me please? :-/
02:47:40 <ski> xinming : what are you wondering about ?
02:49:38 <ski> the 'effect' that the reader/environment monad is about, is distributing down some context/config info, implicitely
02:52:33 <xinming> runReader $local (\x -> x+3 ) (return 3) $ 5
02:52:41 <xinming> why not this example work?
02:53:57 <xerox> > runReader (local (\x -> x+3) (ask)) 5
02:53:58 <lambdabot> 8
02:54:49 <xerox> > runReader (do { one <- ask; two <- local (\x -> x+3) (ask); three <- ask; return (one,two,tree)) 5
02:54:50 <lambdabot>  parse error on input `)'
02:54:58 <xerox> > runReader (do { one <- ask; two <- local (\x -> x+3) (ask); three <- ask; return (one,two,tree) }) 5
02:54:59 <lambdabot>  Not in scope: `tree'
02:55:03 <xerox> > runReader (do { one <- ask; two <- local (\x -> x+3) (ask); three <- ask; return (one,two,three) }) 5
02:55:04 <lambdabot> (5,8,5)
02:55:09 <xerox> Right on.
02:56:31 <ski> m, yes
02:57:24 <ski> xinming : i think you shouldn't write 'f $ m $ x' if you mean 'f m x' (since the former means 'f (m x)')
02:57:54 <ski> @type Control.Monad.Reader.runReader $ Control.Monad.Reader.local (\x -> x+3 ) (return 3) $ 5
02:57:55 <xerox> > runReader (ask `mplus` local (+1) ask `mplus` ask) (-1)
02:57:55 <lambdabot> forall r a. (Num (Control.Monad.Reader.Reader r a)) => r -> a
02:57:56 <lambdabot>  add an instance declaration for (MonadPlus (Reader r))
02:58:24 <xerox> > runReader (ask `(mplus :: [a] -> [a] -> [a])` local (+1) ask `mplus` ask) (-1)
02:58:24 <lambdabot>  parse error on input `('
02:58:29 <xerox> dunno :)
02:58:50 <xerox> Maybe ReaderT []
02:58:55 <xerox> Which is a Writer right?
02:59:15 <ski> 'Num (Control.Monad.Reader.Reader r a)' is bad, since we don't want the monadic action to be in class Num, here
02:59:23 <ski> xinming : ok ?
03:00:06 <ski> @kind Maybe Control.Monad.Reader.ReaderT []
03:00:07 <lambdabot> Kind error: `Maybe' is applied to too many type arguments
03:00:17 <xerox> uh.
03:00:20 <xinming> Still not, Sorry for my uncleverness. :-/
03:00:29 <xerox> Why Maybe?
03:00:47 <xerox> @kind Maybe (Control.Monad.Reader.ReaderT [])
03:00:48 <lambdabot>   `[]' is not applied to enough type arguments
03:00:48 <lambdabot>   Expected kind `*', but `[]' has kind `* -> *'
03:00:58 <xerox> @kind Maybe (Control.Monad.Reader.ReaderT [] a)
03:00:59 <lambdabot> Not in scope: type variable `a'
03:01:02 <ski> xinming : what you probably wanted above is 'runReader (local (\x -> x+3 ) (return 3)) 5' .. and you can't rewrite that with '$' in the way you tried
03:01:06 <xerox> @kind forall a. Maybe (Control.Monad.Reader.ReaderT [] a)
03:01:07 <lambdabot>   `[]' is not applied to enough type arguments
03:01:07 <lambdabot>   Expected kind `*', but `[]' has kind `* -> *'
03:01:11 <ski> xerox : you said the 'Maybe'
03:01:11 <xerox> Okay.
03:01:28 <xerox> ski: ahah no, it is part of the conversation
03:01:29 <ski> <xerox> Maybe ReaderT []
03:01:33 <ski> oh
03:01:37 <ski> aha
03:01:41 <xerox> haahah :-)
03:02:27 <xinming> ski: But `runReader (local (\x -> x+3 ) (return 3)) 5` doesn't work either
03:02:45 <ski> > runReader (local (\x -> x+3 ) (return 3)) 5
03:02:46 <lambdabot> 3
03:02:49 <xinming> Ooops. It works. :-/
03:02:53 <ski> seems to work
03:03:14 <xerox> sure it does
03:03:43 <Oejet> Hello all.
03:04:11 <xerox> Hi!
03:05:26 <xinming> But the function doesn't add 5
03:05:53 <xinming> > runReader (local (\x -> x+3 ) (return 4)) 5
03:05:55 <lambdabot> 4
03:06:53 <Oejet> > runReader (local id (return 7)) 8
03:06:55 <lambdabot> 7
03:09:55 <ski> > runReader (local (\x -> x+3 ) ask) 5
03:09:57 <lambdabot> 8
03:10:19 <ski> xinming : it will ignore the environment, if you don't use 'ask' (or 'asks')
03:12:40 <xerox> indeed
03:16:56 <xinming> hmm, so in example `runReader (local (\x -> x+3 ) ask) 5`, here 5 will be the environment, right?
03:17:38 <xerox> xinming: right
03:17:54 <xerox> then you execute a local action (ask) with the environment modified by the function \x -> x+3
03:20:08 <xinming> for the function `ask`, It's impelemention is  ask       = Reader id 
03:20:19 <xinming> How can I think of it here? :-/
03:21:39 <Oejet> xinming: "It's" is wrong grammar, it should be "its implementation".
03:21:41 <xerox> r = id
03:21:54 <xerox> in (r e)
03:22:02 <xerox> means just that it will return the environment
03:24:11 <xinming> Oejet: Sorry for my poor English. :-)
03:24:29 <TFK> Oejet, привет!
03:32:04 <xinming1983> Ok, go for supper first, bbl
03:41:03 <jimapple> @djinn-env
03:41:04 <lambdabot> data () = ()
03:41:04 <lambdabot> data Either a b = Left a | Right b
03:41:04 <lambdabot> data Maybe a = Nothing | Just a
03:41:04 <lambdabot> data Bool = False | True
03:41:04 <lambdabot> data Void
03:41:06 <lambdabot> type Not x = x -> Void
03:41:28 <jimapple> @djinn Not a -> (Maybe a -> Maybe Void)
03:41:28 <lambdabot> f x1 x2 =
03:41:28 <lambdabot>   case x2 of
03:41:28 <lambdabot>   Nothing -> Nothing
03:41:28 <lambdabot>   Just v7 -> void (x1 v7)
03:42:53 <Oejet> ТФК: Привет, как дела?
03:43:01 <jimapple> @djinn Not a -> Not (Maybe a)
03:43:01 <lambdabot> -- f cannot be realized.
03:43:20 <jimapple> @djinn Not (Maybe a) -> Not a
03:43:21 <lambdabot> f x1 = void (x1 Nothing)
03:43:30 <xerox> Not x ?!
03:44:00 <jimapple> ?
03:44:13 <xerox> What is the type Void ?
03:44:17 <xerox> 'data Void' ?
03:44:19 <TFK> Oejet, живу потихоньку :-) а у тебя?
03:45:09 <jimapple> it has no constructors
03:45:47 <xerox> @type void
03:45:48 <lambdabot> Not in scope: `void'
03:46:01 <xerox> void = undefined :: Void ?
03:46:02 <jimapple> there are no values of type Void, saving _|_, or, as the Haskell prelude calls it, undefined
03:46:08 <jimapple> @kind Void
03:46:15 <lambdabot> Not in scope: type constructor or class `Void'
03:46:18 <xerox> makes sense
03:46:19 <jimapple> yeah, I think it's only defined in djinn
03:46:37 <xerox> Thanks
03:46:57 <jimapple> @seen lennart
03:47:01 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
03:50:06 <ski> hm
03:50:11 <basti_> netquake.
03:50:53 * xerox grumbles
03:50:55 <ski> xerox
03:50:58 <xerox> Oi
03:50:58 <ski> i think
03:51:06 <ski> void :: forall a. Void -> a
03:51:16 <xerox> ski: wow.
03:51:17 <ski> void v = case v of { }
03:52:02 <xerox> and it actually makes sense?
03:52:08 <ski> @djinn Not a -> (Maybe a -> Maybe Void)
03:52:08 <ski> @djinn Not (Maybe a) -> Not a
03:52:09 <xerox> @type \v -> case v of {}
03:52:09 <lambdabot> f x1 x2 =
03:52:09 <lambdabot>   case x2 of
03:52:09 <lambdabot>   Nothing -> Nothing
03:52:09 <lambdabot>   Just v7 -> void (x1 v7)
03:52:10 <lambdabot> f x1 = void (x1 Nothing)
03:52:11 <lambdabot> parse error on input `}'
03:52:14 <xerox> @type \v -> case v of { }
03:52:15 <lambdabot> parse error on input `}'
03:52:15 <twb> @djinn Void -> a
03:52:16 <lambdabot> f = void
03:53:09 <ski> xerox : i don't think it's actually valid syntax to have a case with zero branches
03:53:25 <ski> but, a deconstruction on Void should be like that
03:53:29 <xerox> so it's like void = undefined :: Void -> a
03:53:43 <twb> ski: so void can't be defined in Haskell?
03:53:46 <dons> yeah, what's the type of a case with no branches?
03:53:53 <twb> ski: i.e. it has to be a primitive?
03:53:58 <ski> dons : polymorphic, of course
03:54:02 <xerox> I think so
03:54:31 <ski> (case v of { }) :: forall a. a
03:54:37 <dons> > case () of { }
03:54:38 <lambdabot>  parse error on input `}'
03:54:51 <dons> > case () of 
03:54:52 <lambdabot>  parse error on input `}'
03:55:00 <xerox> o-O
03:55:00 <dons> > let in ()
03:55:01 <lambdabot> ()
03:55:12 <xerox> > let it = be
03:55:13 <lambdabot>  parse error on input `}'
03:55:18 <ski> xerox : yes, it's more or less like 'undefined'
03:55:25 <xerox> \o/
03:55:31 <ski> twb : what has ?
03:55:39 <twb> ski: void
03:56:00 <ski> it's only because of syntax that one can't define it with a 'case'
03:56:51 * araujo wonders if he should go and gets some empanadas or eats eggs instead
03:58:11 <ski> @arrg netsplit
03:59:08 <dons> hmm, the report says the alts list in a case can be n >= 0..
03:59:23 <ski> dons : hmm .. really
03:59:25 * ski checks
03:59:29 <dons> 3.13
04:00:23 <cpatrick> but if the alts list is empty it'll always produce a pattern-match error when it gets evaluated, right?
04:00:25 <dons> well, it says alt1 ; .. ; altn n>=0 which is a bit weird.
04:00:38 <dons> but then an alt maybe be mepty as well.
04:00:42 <dons> cpatrick, why?
04:00:57 <lambdabot> I heard andersca is a pirate
04:01:55 <ski> alts 	 -> 	 alt1 ; ... ; altn 	 (n>=1)
04:02:22 <dons> oohh, i have my old report again.
04:02:25 <ski> constrs 	 -> 	 constr1 | ... | constrn 	 (n>=1)
04:02:51 <cpatrick> dons: isn't it an error when a case statement doesn't match one of the branches??
04:02:53 <dons> I should really stop referring to this 1999 version of the report.
04:03:51 <ski> cpatrick : run-time error, yes
04:03:54 <ski> partiality
04:05:09 <ski> (cpatrick : anyway note, if we didn't have _|_ in every type, then such a 'case' with no branches would still be ok)
04:05:40 <dons> ah, much better, the revised report makes more sense
04:05:45 <cpatrick> ski: yep. run time error != _|_, right?
04:05:59 <ski> nope
04:06:29 <dons> you can still have empty alternatives. hmm.
04:07:05 <ski> cpatrick : or, hm ... i guess i meant nontermination with '_|_' , above
04:07:40 <dons> hmm, why not a case with 1 empty alt then.
04:07:46 <ski> hmm
04:08:02 <ski> @type \v -> case v of { ; }
04:08:03 <lambdabot> parse error on input `}'
04:08:05 <dons> I can't seem to get ghci to accept an empty alt
04:08:08 <dons> or hugs
04:08:19 <ski> @type \v -> case v of { _ -> v ; ; _ -> v}
04:08:20 <lambdabot> forall t. t -> t
04:08:20 <xerox> @type \v -> case v of { _; }
04:08:22 <lambdabot> parse error on input `;'
04:08:32 <xerox> @type \v -> case v of { _ -> _; }
04:08:33 <lambdabot> Pattern syntax in expression context: _
04:08:34 <ski> i guess that's an empty alternative
04:08:36 <xerox> heh
04:08:39 <dons> xerox, that's not an empty alt.
04:08:42 * ski is not sure
04:09:34 <cpatrick> ski: surely _ matches anything, an empty alt would match nothing
04:09:41 <dons> ah, "each alternative must have at least one body"
04:09:54 <ski> cpatrick : hmm ?
04:10:10 <ski> dons : hmm ..
04:10:31 <ski> cpatrick : m, right, i think
04:10:55 <dons> no match is explicitly bottom
04:11:27 <dons> what's the empty alt good for? hmm.
04:11:32 <ski> dons : hm, what's 'body', here ?
04:11:39 <ski> dons : was wondering the same
04:11:47 <xerox> @type let bot = bot in case () of { _ -> bot }
04:11:48 <lambdabot> forall t. t
04:11:56 <xerox> @type let bot = bot in \v -> case v of { _ -> bot }
04:11:57 <lambdabot> forall t t1. t -> t1
04:12:00 <xerox> yay
04:12:02 <dons> yeah. there's no concrete example of body.
04:12:28 <ski> @type let bot = bot in \v -> case v of { _ | False -> bot }
04:12:29 <lambdabot> forall t t1. t -> t1
04:12:29 <dons> oh, maybe the rhs of an alt?
04:12:33 <ski> that's better
04:12:37 <xerox> great
04:12:56 <ski> @type \v -> case v of { _ | False -> undefined }
04:12:57 <lambdabot> forall t a. t -> a
04:13:03 <xerox> I like it.
04:13:12 <ski> also works fine, since that 'undefined' won't be evaluated, anyways
04:13:28 <ski> i guess this is the nearest we can come zero branches
04:14:28 <ski> anyway, since there shouldn't exist any value of type Void, it's safe and ok to provide no branches, when handling / pattern-matching it
04:14:37 <ski> just like we can use two branches with Either
04:15:16 <ski> Void is the left and right unit of Either  (if we ignore _|_ and other partially defined things)
04:15:34 <ski> just like () is the left and right unit of (,), in the same sense
04:15:46 <dons> looking at ghc's parser, it requires at least one non-empty alt.
04:15:57 <xerox> ski: good explanation
04:16:42 <ski> 'each alternative must have at least one body' .. doesn't this disallow uses of empty 'alt's ?
04:17:25 <ski> @djinn Either (Not a) (Not b) -> Not (a,b)
04:17:26 <lambdabot> f x1 =
04:17:26 <lambdabot>   case x1 of
04:17:26 <lambdabot>   Left v4 -> \ (v6, _) -> v4 v6
04:17:26 <lambdabot>   Right v8 -> \ (_, v11) -> v8 v11
04:17:42 <ski> @djinn (Not a,Not b) -> Not (Either a b)
04:17:42 <lambdabot> f (v2, v3) x4 =
04:17:42 <lambdabot>   case x4 of
04:17:42 <lambdabot>   Left v7 -> v2 v7
04:17:42 <lambdabot>   Right v8 -> v3 v8
04:17:45 <dcoutts> gour, pong
04:18:06 <ski> @djinn (a -> Not b) -> (b -> Not a)
04:18:06 <lambdabot> f x1 x2 x3 = x1 x3 x2
04:18:30 <ski> xerox : those are nice examples of using Not and Void in constructive logic
04:18:51 <xerox> O_o
04:19:20 <xerox> I wonder what does it mean O_o
04:19:52 <ski> (note that one can't define inverses of the first two, here .. while all these are equivalences in classical logic)
04:19:56 <dons> "A case expr must have at least one alt, and each alt must have at least one body" so no empty alts.
04:20:02 <ski> xerox : which ?
04:20:06 <xerox> ski: the last one
04:20:11 <xerox> ah wayt
04:20:28 <xerox> no, no idea.
04:20:35 <ski> xerox : it's a variant of "contraposition" .. if a implies b is false, then b implies a is false
04:21:00 <xerox> wat doe sit pragmatically do?
04:21:04 <ski> @djinn (a -> b) -> (Not b -> Not a)
04:21:04 <lambdabot> f x1 x2 x3 = x2 (x1 x3)
04:21:10 <ski> that's another form
04:21:29 <Lor> @djinn Void -> a
04:21:30 <lambdabot> f = void
04:21:40 <dons> @compose pl djinn (a -> b) -> (Not b -> Not a)
04:21:42 <lambdabot> f = flip (.)
04:21:47 <ski> (which indicates that 'Not' is probably a covariant functor, too)
04:22:01 <xerox> @djinn (a -> b,b -> c) -> (a -> c)
04:22:01 <lambdabot> f (v2, v3) x4 = v3 (v2 x4)
04:22:42 <ski> xerox : what does *which* pragmatically (operationally, i'd say) do ?
04:22:44 <xerox> "If a implies b, and b implies c, a implies c" ?
04:22:48 <ski> yes
04:22:52 <xerox> cool
04:23:05 <xerox> hhm, they call me for lunch, see you a bit
04:23:09 <ski> this is Curry-Howard Correspondence
04:23:22 <xerox> (it's so cool)
04:23:34 <xinming> hmm, for `id 3` which will return 3, and `test x = id x` which will return x, What does ask function do please?
04:23:40 <xinming> Since I can't understand.
04:23:42 <ski> xerox : then better warm it up :)
04:23:52 <ski> xinming : Reader ?
04:24:24 <xinming> ski: yes
04:24:39 <xinming> the implementiono of ask is `ask = Reader id`
04:24:44 <ski> return :: a -> Reader e a
04:24:45 <ski> return a = Reader (\_ -> a)
04:24:50 <ski> do you understand this ?
04:25:19 <xinming> yes, return a Reader type
04:25:35 <ski> to 'return' 'a', you construct an action, which when given the environment, it just discards it (the '_') and returns 'a'
04:25:55 <ski> so, each action gets as argument it's environment
04:26:28 <ski> xinming : should i show (>>=) in same way, too ? or get directly to 'ask' ?
04:26:58 <xinming> ski: will be happy if you give me a free online lesson. :-)
04:27:05 <ski> hehe
04:27:06 <xinming> ski: go on please.
04:27:34 <ski> ok, i'll give '(>>=)' and 'join' just to reinforce understanding of this monad, then
04:28:01 <ski> btw, did you have any question/comment on the expl. on 'return' above ?
04:29:35 <xinming> hmm, I will tell what I think of return, for this function, It need an argument, and then, turn it into a lambda which will return the argument, and hold this lambda in Reader type constructor.
04:29:36 <xinming> right?
04:29:48 <ski> yes
04:30:05 <ski> alos note that the lambda ignores the environment which will be given to it
04:30:13 <ski> return a = Reader (\e -> a)
04:30:16 <ski> is same thing
04:30:18 <ski> 'e' is not used
04:30:32 <xinming> yes. :-)
04:30:44 <ski> so, 'return (...)' will do the same thing, regardless of what the environment is
04:30:58 <ski> (just as 'return' in any monad is effectively effectless)
04:31:14 <ski> ok, on to (>>=), then ?
04:32:09 <xinming> ski: go on please, I can understand. :-)
04:32:16 <ski> ok
04:32:24 <ski> (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b
04:32:28 <ski> Reader e_a >>= k = Reader (\e -> let Reader e_b = k (e_a e) in e_b e)
04:32:56 <ski> here we want to "sequence" two actions, and second action can depend on result of first one
04:33:22 <ski> so, second is actually a function from any possible result of the first action, to the real second action
04:33:28 <ski> ok ?
04:33:58 <ski> in the first action we extract 'e_a'
04:34:02 <ski> e_a :: e -> a
04:34:03 <ski> here
04:34:20 <ski> i.e. it will return the result of that action, when given the environment
04:34:48 <xinming> hmm, sorry to interrupt you, hmm, should I call the "function" k "action" here?
04:34:49 * ski waits for xinming to respond
04:35:07 <ski> 'k' is not strictly speaking an action
04:35:24 <ski> it will give the second action, when we give result of first action to it
04:35:51 <ski> so to speak, it won't neccesarily decide what to do, until it has seen what the "previous" action returned
04:36:58 <xinming> Ok, I think I understand.
04:37:11 <ski> ok
04:37:14 <ski> so, the rhs
04:37:29 <ski> we want to return a new combined action
04:37:42 <ski> so, we write 'Reader (\e -> ...)'
04:37:47 <xinming> and make another lambda. :-)
04:37:54 <xinming> hold in Reader.
04:38:00 <ski> so, this will get the environment into 'e'
04:38:01 <ski> yes
04:38:14 <ski> 'Reader' is just to pack it inside this type
04:38:30 <ski> it's not essential to the concept
04:38:34 <ski> anyway
04:39:05 <ski> Reader e_a >>= k = Reader (\e -> let a = e_a e; Reader e_b = k a; b = e_b e in b)
04:39:10 <ski> this is the same thing
04:39:13 <ski> spelled out a bit more
04:39:16 <xinming> ski: So, It's not able to get the env out of the Monad inside the >>= combination, right?
04:39:33 <ski> no, au contraire
04:40:01 <ski> the environment will come from outside, and this (>>=) will ensure it gets passed down to both parts
04:40:23 <xinming> Yes, it's a bit like State Monad.
04:40:25 <ski> (btw, s/the Monad inside/the monadic action inside/, i think you mean)
04:40:28 <tic> reader's like state w/o the get?
04:40:28 <ski> yes
04:40:39 <ski> except we don't return state
04:40:46 <tic> (only it gets passed to each function explicitly instead of w/ get, right?)
04:40:50 <ski> tic : no, without the put
04:40:50 <Cale> Half a state monad
04:40:53 <tic> ski, err, right.
04:41:04 <Cale> Writer is kind of like the other half :)
04:41:14 <tic> write-only ;)
04:41:15 <xinming> ski: go go go go on please... :-)..
04:41:17 <ski> also, the input is handled a bit different in (>>=)
04:41:40 <ski> xinming : heh
04:41:43 <ski> ok
04:41:48 <ski> Reader e_a >>= k = Reader (\e -> let a = e_a e; Reader e_b = k a; b = e_b e in b)
04:41:49 <ski> so
04:42:10 <ski> 'e_a e' <- here we pass the environment to the first action
04:42:22 <ski> and, we can call the result 'a'
04:42:55 <ski> then, the second part (i.e. 'k :: a -> Reader e b') first wants the result of the previous action
04:43:05 <ski> so, we do 'k a'
04:43:33 <ski> this will return the real second action, i.e. when it's determined what it wants to do, possibly based on result of first action
04:43:38 <ski> xinming : do you follow ?
04:43:44 <xinming> I can follow.
04:44:18 <ski> so, this returns an action in the 'Reader' monad .. so we extract the real part out from the constructor
04:44:19 <xinming> hold on plz
04:44:23 <ski> Reader e_b = k a
04:44:26 <ski> ok
04:45:03 <xinming> this will return the real second action,
04:45:09 <xinming> which is the real second action?
04:45:24 <xinming> e_b e?
04:45:43 <ski> no, 'e_b'
04:46:43 <ski> in 'e_b e' we give the second action the *same* environment (this is different from State monad), and get back it's result 'b' (which we return as result of the full action '(>>=)' returns)
04:47:21 <ski> Reader e_a :: Reader e a
04:47:27 <ski> e_a :: e -> a
04:47:35 <ski> k :: a -> Reader e b
04:47:39 <xinming> Ok, Since `Reader e_b = k a` will extract the lambda, and bind the lambda to the name `e_b`(hope what I say is understandable), and ... I think I can understand >>= now. :-)
04:47:46 <ski> k a :: Reader e b
04:48:11 <ski> xinming : yes, that sounds right :)
04:48:35 <ski> but, it's important to notice that we pass *same* environment 'e' to both actions
04:48:54 <xinming> Yes, I know, all are e
04:49:01 <ski> this will affect how the monad works, and the "feel/intuition" of it
04:49:08 <ski> anyway
04:49:26 <ski> these two basic monadic operations just distribute down same environment
04:49:35 <ski> into each monadic part
04:50:04 <ski> we also need monad-specific ops, to be able to use in interesting ways
04:50:11 <ski> i.e. 'ask' and 'local'
04:50:17 <xinming> Yes.
04:50:21 <ski> i'll take 'ask' now, then
04:51:09 <ski> ask :: Reader e e
04:51:09 <xinming> because the bind and return isn't enough. :-)
04:51:10 <ski> ask = Reader (\e -> e)
04:51:38 <ski> right, except for the Identity monad, since that's not supposed to do anything special .. it's the trivial monad
04:51:41 <ski> anyway
04:51:45 <ski> note the type of 'ask'
04:52:09 <ski> it monadically returns something of same type as the environment
04:52:49 <ski> this gives a clue that it in some way uses the environment .. which is of course just what it does :)
04:52:54 <ski> ok ?
04:53:10 <ski> now, the definition of it ..
04:53:50 <ski> we just define it to be the action, that when it's given environment 'e', decides to monadically return that 'e'
04:55:25 * ski btw is somewhat unhappy about this using same name for the type contructor as for the data constructor .. both spells 'Reader'
04:55:36 <ski> xinming : what do you think ?
04:56:26 <xinming> I was trying this, runReader (return 3 >>= ask) 8
04:57:23 <xinming>  runReader (Reader (\e -> return 3 >>= ask)) 8
04:58:15 <ski> the problem is ..
04:58:46 <ski> .. '(>>=)' wants not an action as right argument ..
04:59:25 <ski> but, a function (often literal lambda expr) that when given result of left action, will decide what right action should do
04:59:32 <ski> so
04:59:50 <ski> 'return 3 >>= \n -> ask' is an ok action
05:00:30 <ski> 'n' will get the result of the left action (i.e. 'return 3', in this case, the result will always be '3', so that's what 'n' will be)
05:00:37 <ski> understand ?
05:01:10 <ski> > runReader (return 3 >>= \n -> ask) 8
05:01:12 <lambdabot> 8
05:01:51 * xinming still don't know how ask can get the environment here.
05:02:11 <ski> 'here' being ?
05:02:21 <xinming> I mean in lambda
05:02:25 <xinming> \n -> ask
05:02:35 <ski> 'n' will not be the environment
05:02:49 <ski> the environment is implicit in the actions (that's the point of using this monad)
05:02:55 <xinming> ski: yes, I know, n is the value of Monad
05:03:15 <ski> 'return 3' is an action that implicitely takes an environment, then discards it, and returns '3'
05:03:48 <ski> '\n -> ask' is a function, that waits for result of first action, calls that 'n', and then returns the second action ..
05:04:08 <ski> .. and *that* second action takes an implicit environment, and in this case, returns the value of that
05:04:20 <ski> s/the value of //
05:06:14 <ski> so 'return 3 >>= \n -> ask' is an action, that will implicitely take an environment, pass it down to left action, pass result of that to the function to the right, which will return the right action, and that action is then given same environment (by '(>>=)'), and then that returns it's result, which is also what whole thing returns as monadic result
05:07:18 * xinming is still thinking...
05:07:53 <ski> it's somewhat complicated by that right part depends on result of left part, so needs to be passed that (i.e. the '\n ->')
05:08:14 <ski> s/depends/could possibly depend/
05:09:27 <xerox> @kind Control.Monad.Writer.Writer
05:09:28 <lambdabot> * -> * -> *
05:09:33 <ski> > runReader (return 3) 8
05:09:34 <lambdabot> 3
05:09:44 <ski> > runReader ((\n -> ask) 3) 8
05:09:46 <lambdabot> 8
05:09:54 <ski> > runReader (return 3 >>= \n -> ask) 8
05:09:55 <lambdabot> 8
05:10:24 <ski> hm, maybe that's a nice way of thinking about it ..
05:11:16 <ski> xinming : tell if/when you want more response
05:12:08 <xinming> ski: Sorry, I was just now thinking, But I think I catch the feeling.
05:12:11 <xinming> ski: thanks, :-)
05:12:26 <xinming> I think the left part is to thinking myself. :-)
05:12:33 * ski actually thinks this idea for explanation i got is really nice .. (if only haskell had "Message-Dispatching" syntax ..)
05:12:54 <xinming> ski: are you a teacher? :-/
05:12:59 <xerox> > runWriter (Control.Monad.Writer.tell 1)
05:13:00 <lambdabot>  Not in scope: `Control.Monad.Writer.tell'
05:13:02 <xerox> hm?
05:13:03 <ski> xinming : not by trade :)
05:13:16 <ski> > runWriter (tell 1)
05:13:17 <lambdabot>  Not in scope: `tell'
05:13:20 <ski> hm
05:13:20 <chris2> say you have a fairly good understanding of basic haskell and now would like to write some code with ghc... is there an introduction to the additional libraries and packages ghc provides?
05:13:20 <xerox> You see :(
05:14:30 <xerox> @libsrc Control.Monad.Writer
05:14:31 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Writer.
05:14:31 <lambdabot> hs
05:14:59 <yozora> there are the hierarchical libraries
05:15:01 <xerox> Hmm
05:15:07 <xerox> It is not exported, is it?
05:15:16 <yozora> http://www.haskell.org/ghc/docs/latest/html/libraries/
05:15:29 <xinming> > runReader ((\n -> Reader (\e -> e)) 3) 8
05:15:31 <lambdabot> 8
05:15:40 <chris2> yozora: but that's more like reference than introduction, no?
05:15:50 <ski> xerox : actually, i was surprised to see Reader was in scope ..
05:15:55 <yozora> yeah, there are papers on bits of them
05:15:59 <xerox> > runReader (Reader $ id) 8
05:16:00 <lambdabot> 8
05:16:02 <ski> @type Control.Monad.Writer.tell
05:16:03 <lambdabot> forall (m :: * -> *) w.
05:16:03 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
05:16:03 <lambdabot> w -> m ()
05:16:07 <yozora> like the ST monad paper, the STM paper
05:16:08 <xerox> ski: I like it
05:16:22 <yozora> parsec has a tutorial on the site i think
05:16:25 <xerox> ski: I mean that 'tell' is even not in the export list.
05:16:34 <ski> xerox : sure it's exported, but it's not imported into lambdabot's '> ', it seems
05:16:36 <yozora> and quickcheck has one too
05:16:58 <chris2> yozora: okay, i guess i'll have a look at the papers then and have a closer look at what looks useful to me
05:17:13 <xinming> > runReader ((\n -> Reader id) 3) 8
05:17:13 <xerox> ski: http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Writer.hs
05:17:15 <lambdabot> 8
05:17:31 <ski> xinming : yes, those are valid expansions
05:17:36 <xerox> ski: ah, in the MonadWriter(..) ?
05:17:48 <ski> yes
05:17:54 <ski> it's overloaded, actually
05:18:08 <xerox> hmm
05:18:09 <xinming> ski: Does id = (\x -> x) ?
05:18:16 <ski> yes ! :)
05:18:21 <xerox> @type Control.Monad.Writer.runWriter
05:18:22 <lambdabot> forall w a. Control.Monad.Writer.Writer w a -> (a, w)
05:18:23 <ski> @pl \x -> x
05:18:23 <lambdabot> id
05:18:23 <xinming> hahah, I know the truth. :-)
05:18:27 <xerox> > runWriter
05:18:28 <lambdabot>  Not in scope: `runWriter'
05:18:36 <xerox> Ah, I see.
05:18:50 * xinming holds ski's hands tightly, and say... Thank you very much...
05:18:51 <ski> @compose (djinn,type) id
05:18:51 <lambdabot> compose module failed: No such command: "(djinn,type)"
05:19:13 <ski> @compose djinn type id
05:19:14 <lambdabot> -- f cannot be realized.
05:19:18 <ski> hm
05:19:27 <ski> xinming : do you want to see the idea for expl. i had .. it's more oriented to what you get when running actions, as opposed to how they are implemented (though this is more or less a matter of pov :)
05:19:52 <xerox> ski: is there a Monoid instance for something ski?
05:19:57 <ski> @type id
05:19:58 <lambdabot> forall a. a -> a
05:20:11 <ski> (ah, i thin djinn didn't like the 'forall')
05:20:12 <xinming> ski: yes
05:20:24 <ski> xerox : 'something' ?
05:20:31 <xerox> ah
05:20:33 <xerox> [] has.
05:21:02 <ski> newtype Endo a = MkEndo (a -> a)
05:21:07 <ski> that could also be made instance
05:21:18 <xerox>  > runWriter (tell [1] >> tell [2] >> tell [3] >> return 0)  ==>  (0,[1,2,3])
05:21:24 <ski> s/ //
05:21:30 <xerox> Ah I see that.
05:21:50 <musasabi> Was there a place where the docs from HEAD branch of GHC are in the web?
05:21:51 <ski> xerox : looks ok, i think
05:21:59 <xerox> mzero = id; mappend = (.)
05:22:12 <ski> yes
05:22:13 <xinming> ski: I don't think it's a matter that constructor's name and Type name are the same. :-)
05:22:17 <xerox> quite cool
05:22:32 <xerox> ski: How do you use MkEnd in actual code?
05:22:37 <ski> xinming : except that it can be somewhat confusing at times, especially to beginners
05:23:00 <ski> xerox : we spoke of same instance, basically
05:23:41 <xerox> ski: would GHC use the Monoid instance for (a -> a) even if not explictly typed 'Endo a' ?
05:24:04 <ski> xerox : instance Monoid (Endo a) where mzero = MkEndo id; MkEndo ea0 `mappend` MkEndo ea1 = MkEndo (ea0 . ea1)
05:24:15 <xerox> I know that yes
05:24:20 <xerox> It means no
05:24:37 <ski> xerox : yes
05:25:29 <ski> i misremembered what kind 'Monoid's argument had, so i a monent thought i had to wrap it to get kind '* -> *'
05:25:41 <xerox> @index Monoid
05:25:42 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
05:25:44 <ski> xinming : anyway ..
05:25:49 <xerox> @kind Data.Monoid.Monoid
05:25:50 <lambdabot> Class `Data.Monoid.Monoid' used as a type
05:25:53 <xerox> err.
05:26:08 <ski> the other expl. idea focusess on what happens when you run various actions
05:26:34 <ski> xerox : i'd prolly say 'Monoid :: * -> instance' or something like that :)
05:26:49 <xerox> sorry, it's mempty
05:26:58 <ski> ok
05:27:03 <ski> xinming : runReader (return a) e = a
05:27:13 <ski> xinming : runReader ask e = e
05:27:43 <ski> xinming : runReader (ma >>= amb) e = runReader (amb (runReader ma e)) e
05:27:57 <ski> xinming : how about those ?
05:28:07 <xinming> are you writing formulas. >_<
05:28:37 <ski> well, with my MessageDispatching syntax idea, we could actually define 'return' and '(>>=)' and 'ask' in this way :)
05:28:55 <joelr1> Cale: ping
05:29:05 <ski> in any case, it can be used to explain what the actions here do, independent of the implementation
05:29:21 <ski> runReader (return a) e = a
05:29:28 <joelr1> folks, would anyone be willing to take a look at my profiling reports? seems like i have hit a mental block and can't figure it out
05:29:43 <ski> this says that if you run an 'return a' action, with environment 'e', then result is 'a'
05:30:09 <ski> runReader ask e = e  -- this says that if you run an 'ask' action, with environment 'e', then the result is 'e'
05:30:25 <joelr1> arjanb: do you have anything to do with dazzle?
05:30:47 <ski> runReader (ma >>= amb) e = runReader (amb a) e
05:30:48 <ski>   a = runReader ma e
05:30:51 <ski> um
05:30:53 <ski> runReader (ma >>= amb) e = runReader (amb a) e
05:30:54 <ski>   where
05:30:56 <ski>   a = runReader ma e
05:32:07 <ski> this says that to run an 'ma >>= amb' action, with environment 'e', then you run 'ma' with environment 'e', getting result 'a', pass that to 'amb' to get second action 'amb a', and then run that with environment 'e' to get the total result of this '(>>=)' call
05:32:12 * xerox mumbles
05:32:22 <ski> xinming : is this explanation understandable at all ?
05:33:05 <ski> xerox : can't hear you :)
05:33:09 <xinming> If I think It is a formula, then the answer is yes. If It is treated as bind, the answer is no. :-P
05:33:16 <xerox> :-D
05:33:20 <ski> 'bind' ?
05:33:21 <xerox> I'm thinking..
05:33:43 <ski> do you mean '(>>=)' with 'bind' ?
05:34:26 <xinming> It's understandable, :-)
05:34:33 <xinming> I understand it now.
05:34:47 <ski> ok
05:34:57 <xinming> but really sorry for my poor mathematic brain. :-/
05:35:05 <ski> ?
05:36:03 <xinming> I mean, I wish to have a brain which will get better thinking in math
05:37:03 <ski> mhm
05:38:08 * ski ponders again how to possibly extend syntax so above would be valid definitions ..
05:38:27 <xerox>     Can't make a derived instance of `Monad Endo'
05:38:27 <xerox>     (even with cunning newtype deriving:
05:38:27 <xerox>      the eta-reduction property does not hold)
05:38:28 <xerox>     When deriving instances for type `Endo'
05:38:30 <xerox> heh
05:39:07 <ski> you're trying to derive 'Monad Endo' ?
05:39:12 <xerox> Yep
05:40:11 <ski> runEndo (return a) _ = a
05:40:36 <xerox> hm?
05:41:18 <ski> runEndo (ma >>= amb) b = let a' = runEndo ma (?? :: a) in runEndo (amb a') b
05:41:19 <ski> ?
05:41:25 <ski> seems not to be definable
05:41:58 <ski> xerox : just tried to define 'return' and '(>>=)' ..
05:42:13 <Philippa> define a datatype...
05:42:27 <Philippa> data Endo = Return f | Bind comp func
05:42:44 <Philippa> return = Return, >>= = Bind
05:42:50 <Philippa> then carry on the obvious way
05:43:23 <ski> how'd that be Endo ?
05:43:48 <Philippa> point. But that's all you can do - you need a representation of bind and return, or you can't pattern-match
05:44:09 <ski> oh
05:44:09 <xerox> ski: how can I use an 'Endo a' to compute something?
05:44:10 <ski> nono
05:44:21 * ski wasn't trying to pattern-match at all  :)
05:44:31 <Philippa> ah, my bad
05:44:46 * ski was trying to "message-dispatch' :)
05:44:57 * Philippa nods
05:45:15 <Philippa> back to FP land ;-)
05:45:16 * ski has written some half-baked ideas on that, on the wiki
05:46:02 * ski considers "message-dispatching" to be 'FP' ..
05:46:12 <xerox> ah, gotcha.
05:46:25 <ski> or at least ..
05:46:30 <ski> .. it could be :)
05:48:41 <xerox> heh
05:48:57 <Philippa> it can be, but you have to have a concept of message first
05:49:05 <Philippa> which isn't the same thing as a function
05:49:29 <xerox> *Endo> runEndo $ runWriter $ do {tell (MkEndo (+10)); tell (MkEndo (*2)); return 1}
05:49:33 <xerox> 12
05:49:33 <xerox> heh
05:49:46 <ski> Philippa : message is just deconstructor/selector
05:50:26 <xerox> Which is quite an hack
05:51:46 <xerox> ski: it could have a use, maybe.
05:51:56 <xerox> ski: navigating trees for example?
05:52:02 <xerox> you 'tell' the way out :-)
05:52:10 <xerox> Let's put it together
05:52:29 <ski> xerox : put what together ?
05:52:35 * ski was absent a few moments
05:52:37 <xerox> With a Writer (Endo a) a you can `tell' your way out of a tree.
05:53:15 <xerox> Good for a quote, heh
05:53:29 <xinming> hmm, by the way, will the syntax of haskell II brand-new? :-/ Or, It is just add the new feature with the current grammar
05:53:34 <ski> xerox : are you commenting on "message-dispatching" also, or just 'Endo' ?
05:53:39 <xerox> Endo.
05:53:46 <xerox> let me show you
05:54:15 <ski> xinming : possibly some changes ..
05:54:23 <Philippa> xinming: future standards'll always retain at least some backwards compatability. AIUI they're aiming for rather a lot with Haskell06
05:54:25 * xinming just wonder, if haskell II will be like perl 5 -> perl 6.
05:54:26 <ski> xinming : in any case, we don't know yet
05:54:58 * Philippa wonders how long it'll be before we have an FPL called Simons
05:55:22 <ski> hehe
05:55:28 <ski> hm
05:55:39 <ski> 'SimonAndSimon'  ?
05:55:47 <xs> sassy.
05:55:53 <xerox> Sound like M&Ms
05:55:55 <xinming> functional programming is a challenge to many people I think. :-)
05:56:02 <xerox> ski, did you see the code?
05:56:18 <tennin> Haskell06?  Is that official?
05:56:25 <araujo> xinming, well.. perl6 is being written in...? ;-)
05:56:26 <ski> (xerox : yes, but not had time to look at it yet)
05:56:40 <xerox> (ski : ok sorry)
05:57:01 <Philippa> tennin: it's sort of a provisional plan that's being discussed - 06 as a conservative extension, with a Haskell 2 at a later date
05:57:11 <ski> hm, i've heard next version called 'HaskellPrime' and 'Haskell 1.6', too
05:57:18 * xerox boings up and down
05:57:36 <xinming> araujo: perl 6 will be written in perl 6, But the initial perl 6 will be written in haskell. :-/
05:58:12 <tennin> oh
05:58:14 * xinming thinks, that good thing is always worth to wait...
05:58:15 <Philippa> ski: I believe the choice of 06 is to encourage people to actually get a spec out in the next 12 months :-)
05:59:10 <ski> Philippa : ah .. good idea :)
06:00:01 <ski> concrete ideas for what could go in next version is good
06:01:08 <xinming> but concrete ideas are always to master. :-(
06:01:23 <ski> 'to master' ?
06:02:20 <xinming> hmm, to learn or to understand.
06:02:24 <xinming> :-/
06:02:39 <Philippa> if you don't want to learn or understand the new version, why have it?
06:03:15 <ski> xinming : did you intend to write an 'hard' or 'easy' in that sentence ?
06:03:24 <musasabi> Having the most common extensions standardized would make a lot of sense.
06:03:37 <musasabi> As most of the Haskell code written today is not Haskell98
06:03:51 <ski> yes
06:04:00 <musasabi> Which makes things very hard for tool developers
06:04:05 <Philippa> ski: sounded to me more like there was a "there" or similar missing - that there's an obligation to learn things
06:04:34 <Philippa> I get the impression we're not going to see fundeps standardised just yet, there've been "oops, got that wrong!" issues within the past year IIRC
06:04:52 <musasabi> yes, fundeps are too complex.
06:05:04 <Philippa> OTOH, having things like the ST monad and rank-n polymorphism standardised would be a big help
06:05:17 <musasabi> not even GHC and hugs agree on them and they don't seem to be very consistent
06:05:19 <xinming> add a 'hard', But I found, learning such ideas is really interesting, especially you catch what I means. :-)
06:05:30 <joelr1> assuming ids is a list, would "length ids `seq` ids" force evaluation of the list?
06:05:36 <ski> fundeps interacts/interferes with newtypes in strange ways ..
06:05:44 <musasabi> making "instance Foo (T a b c)" valid would be also nice
06:06:01 <ski> xinming : hehe
06:06:10 <musasabi> joelr1: that forces the evaluation of the list spine
06:06:24 <ski> joelr1 : it would force all cells in the list
06:06:32 <tenni1> I just want a standard I can comply with while still being able to use the standard monad libraries. =\
06:06:38 <musasabi> forceList [] = []; forceList (x:xs) = x `seq` forceList xs
06:06:58 <joelr1> musasabi: hmm
06:07:25 <musasabi> tenni1: won't happen.
06:07:27 <joelr1> deepseq for lists... thanks musasabi 
06:07:39 <xerox> I told you this morning"
06:07:44 <xerox> Nobody listens to xerox :(
06:07:56 <joelr1> xerox: told me?
06:08:01 <Philippa> is there a strict map in the List module?
06:08:02 <musasabi> tenni1: at least Control.Monad.State has a fundep
06:08:08 <xerox> 09:21 <xerox> joelr1: deepSeq?
06:08:08 <xerox> 14:07 <joelr1> deepseq for lists... thanks musasabi
06:08:11 <xerox> ^_^
06:08:32 <joelr1> xerox: but you did not provide the implementation :D and i don't have deepSeq 
06:08:41 <joelr1> xerox: thank you, thouhg
06:08:58 * xerox hugs joelr1 
06:09:05 <joelr1> hmm
06:09:07 <musasabi> joelr1: You want to read http://users.aber.ac.uk/afc/stricthaskell.html
06:09:13 <joelr1> musasabi: i did
06:09:28 <joelr1> musasabi: the strategies approach seemed interesting
06:09:54 <musasabi> joelr1: that has a deepseq implementation
06:09:59 <musasabi> http://users.aber.ac.uk/afc/stricthaskell.html#deepseq
06:10:14 <musasabi> no reason to reinvent the whole wheel
06:10:25 <musasabi> (usually reinvented wheels end up square)
06:10:29 <joelr1> musasabi: why not just use your `seq`?
06:10:36 <joelr1> err, forceList
06:11:00 <xerox> @remember musasabi <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually reinvented wheels end up square)
06:11:11 <xerox> @quote-add musasabi <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually reinvented wheels end up square)
06:11:12 <lambdabot> Unknown command, try @listcommands.
06:11:15 <xerox> Bah.
06:11:37 * joelr1 is grabbing deepSeq
06:12:36 <musasabi> joelr1: well think about what happens if you have [[Int]], then the inner list is only seq:ed with forceList while deepSeq seqs the whole thing.
06:13:00 <joelr1> musasabi: true
06:13:10 <joelr1> lets see if this will help me
06:13:12 <musasabi> btw has anyone used the monads library (as opposed to mtl) 
06:13:29 <musasabi> it seems much easier to make standard complicant
06:13:34 * joelr1 is working on the (in)definitive profiling guide for haskell
06:14:29 <ski> @quote musasabi
06:14:30 <lambdabot>  <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually
06:14:30 <lambdabot> reinvented wheels end up square)
06:15:15 <ski> musasabi : which ?
06:17:06 <musasabi> ski: http://cvs.haskell.org/darcs/libraries/monads/, although it seems that it has the fundeps too, just hidden in one place :-(
06:18:49 <ski> is that the one with O(n^2) instance declarations ?
06:20:59 * musasabi does not remember, at least it has Trans as:
06:21:00 <musasabi> class Trans t where
06:21:00 <musasabi>   -- | Lift a computation in the underlying monad, to the constructed monad.
06:21:01 <musasabi>   lift             :: Monad m => m a -> t m a
06:21:18 <musasabi> which is the same as mtl
06:22:29 <ski> yes
06:24:00 * araujo spies #perl6
06:25:34 * beelsebob_ farts loudly
06:26:04 <musasabi> What is the correct way to provide a patch for GHC (send mail to cvs-ghc, add a {bug,task} to trac, something else) ?
06:27:25 <joelr1> musasabi: are you working on the 6.4.1 tree (don't have an answer to your question)
06:31:10 <musasabi> joelr1: HEAD (from darcs)
06:31:37 <musasabi> then again the things should merge to 6.4.1 with litle problems
06:31:58 <joelr1> musasabi: so only head is in darcs, right? not 6.4.1?
06:32:03 <musasabi> both
06:32:09 <joelr1> head is is what, 6.6 these days?
06:32:32 <joelr1> musasabi: how do i get 6.4.1 for meself? i'd like to try my hand at adding profiling for STM
06:32:37 <joelr1> i use darcs
06:32:39 <musasabi> It is 6.5 and will be called 6.6 once released
06:32:59 <musasabi> http://cvs.haskell.org/darcs/ghc.ghc-6.4/ http://cvs.haskell.org/darcs/libraries.ghc-6.4/
06:33:49 <joelr1> musasabi: oh, i thought you said that was in darcs
06:33:55 <joelr1> ah
06:33:58 <joelr1> never mind
06:34:01 <joelr1> let me retrieve these
06:41:20 <musasabi> joelr1: remember to use --partial
06:41:40 <joelr1> musasabi: nah, i'd rather do complete once. pulling 13k patches
06:44:00 <xs> hm. is it possible to have pattern bindings that aren't constructors? e.g., f (atom a) = a, instead of f (Atom a) = a?
06:46:25 <araujo> @index partition
06:46:28 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
06:48:44 <Di-Fosfor> Hi all, I need a little help with classes.. I've made http://lazyfox.org/temp/SolverClasses.lhs and now I want to make an instance of the Game class.
06:49:00 <Di-Fosfor> I can't quite figure it out.. am I totally misunderstanding the use of classes?
06:49:11 <musasabi> xs: no, that is not possible. You might want to look at pattern guards. Views were quite a lot like what you want.
06:49:14 <ski> xs : nope ..
06:49:56 <ski> xs : .. well you can say 'f 42 = ...' and 'f (x + 8) = ...' ,,
06:50:08 <ski> but, that's kind of an exception
06:50:15 <xs> yeah :/
06:50:29 <musasabi> Di-Fosfor: consider using data/newtype instead of type for the type declarations.
06:50:30 <ski> (and is sortof what views was supposed to generalize .. in any case the latter example)
06:50:33 <xs> views require a type change, though?
06:50:58 <musasabi> GHC does not implement views.
06:51:16 <xs> oh okay. thanks!
06:51:21 <Di-Fosfor> musabi: ok, I'll try that
06:52:39 <Pupeno> Good morning.
06:53:44 <ulfdoz> Ich will auch eine Internetgewehr zum Pornos Schieen.
06:53:49 <ulfdoz> ECHAN, sorry
06:54:09 <xerox> @babel de en Ich will auch eine Internetgewehr zum Pornos Schie\uffffen.
06:54:13 <lambdabot>  I want also InterNet rifle to the Pornos a Schie\uffffen.
06:54:15 <xerox> gh.
06:54:53 <ulfdoz> hrhr, quite near. schieszen == to shoot
06:57:20 <ski> xs : 'type change' ?
06:58:31 <xs> ski: oops, i meant, constructor change
06:58:49 * ski still doesn
06:58:54 <ski> 't get what was meant
06:59:34 <xs> if i have a complex number, with two views, cartesian and polar, don't i expose each view using a different constructor?
06:59:49 <ski> ah, yes
07:00:57 <ski> (xinming : hm, i forgot to explain 'local' previosuly .. should i do that ?)
07:01:37 <xinming> ski: thanks. :-P go on...
07:01:49 <ski> hm
07:02:36 <ski> local :: (e -> e) -> Reader e a -> Reader e a
07:02:37 <ski> local f (Reader e_a) = Reader (\e -> e_a (f e))
07:03:16 <ski> so, this takes an environment transformer/modifier 'f', and also an action, with contents being 'e_a' ..
07:03:58 <ski> .. and returns a new action, that when given environment 'e', will first transform that with 'f' before passing it down to the action argument
07:04:03 <ski> ok ?
07:04:15 <xinming> hmm, so the function deals with the environment with function, and return the Monad. right? :-)
07:04:40 <ski> returns the monadic action, yes
07:05:19 <araujo> hah, the less i was expecting to find when looked at the Main.hs of pugs was a spanish poem....
07:05:26 <xinming> thanks. :-) haskell is streight if you understand it, But It's too complicated sometimes. :-/
07:05:28 <araujo> This seems fun.
07:05:45 <ski> ('monad' is a concept, on type level, '(monadic) action' is on value-level .. something of type 'm a' for some monad 'm' is called a (monadic) action, in that monad)
07:05:54 <ski> anyway
07:06:00 <ski> consider the action
07:06:12 <araujo> xinming, complicated!? , what!? 
07:06:13 <araujo> ;-)
07:06:59 <ski> ask >>= \first -> local (+ 10) ask >>= \second -> ask >>= \third -> return (first,second,third)
07:07:20 <xerox> :-D
07:07:59 <ski> it's important to understand that 'local' only modifies the environment for the sub-action, under it (second 'ask' here), .. it does *not* affect e.g. the third 'ask' (unlike state monad)
07:08:05 <ski> > runReader (ask >>= \first -> local (+ 10) ask >>= \second -> ask >>= \third -> return (first,second,third)) 8
07:08:06 <lambdabot> (8,18,8)
07:08:28 <araujo> xinming, you can think of a Monad , as a container.
07:08:38 <ski> xinming : i'll write the alternative way of explaining 'local' too
07:08:59 <ski> runReader (local f ma) e = runReader ma (f e)
07:09:06 <xinming> get the environment, and pass it to the first, and apply (+ 10) to first, and then, get it and bind it to second. and the same for the third... and return 10,10,10 if the initial environment is 0. :-)
07:09:22 <ski> btw, the above example is same as
07:09:43 <xinming> hmm, No, the result should be 0,10,10
07:09:47 <ski> > runReader (do first <- ask; second <- local (+ 10) ask; third <- ask; return (first,second,third)) 8
07:09:48 <lambdabot> (8,18,8)
07:10:04 <ski> 'first' is the result of the first action ('ask')
07:10:19 <ski> 'second' is the result of the second action ('local (+ 10) ask')
07:10:26 <ski> 'third' is the result of the second action ('ask')
07:10:28 <ski> um
07:10:31 <ski> 'third' is the result of the third action ('ask')
07:10:55 <ski> in general we might have
07:11:21 <ski> do first <- (..blah..); second <- local (+ 10) (..bleh..); third <- (..bloh..); return (first,second,third)
07:11:28 <xinming> ski: hmm, So, action is a function which will return Monad, right?
07:12:09 <ski> then both '..blah..' *and* '..bloh..' sees unmodified environment .. *only* '..bleh..' sees the environment which has been modified by 'f'
07:12:25 <ski> xinming : s/Monad/monadic action/
07:12:55 <ski> each action here have type like 'Reader e a'
07:13:53 <xinming> ski: hmm, So, for Reader Monad, It will never update the env
07:14:30 <ski> it only "updates" *locally*
07:14:46 <ski> when the 'local' action returns, it will have forgotten the local modification
07:14:49 <ski> it has reverted back
07:15:18 <ski> that's why the third 'ask' above monadically returns '8' and not '18'
07:15:29 <ski> do you understand ?
07:15:44 <xinming> ski: Yes.
07:15:56 <xinming> ski: An upgraded version of understanding. :-)
07:16:00 <xinming> ski: thanks
07:16:08 <ski> (btw, Reader could be simulated with State, .. if we remembered the old value of 'e' and set it back, after a 'local')
07:16:57 <ski> (this is also a possible implementation/optimisation of reader/environment monad)
07:17:27 <ski> (xinming : hm .. would you happen to know any Common or Emacs Lisp ?)
07:17:36 <ski> hi Buggaboo
07:18:00 <xinming> ski: I just know the parenthesis. :-P
07:18:15 <Buggaboo> hey ski
07:18:16 <ski> ok, nevermind that then ..
07:19:11 <ski> (xinming : if you've heard about "implicit parameters" extension in haskell, then that's a bit like Reader monad, only more lightweight .. and separate named "environments", instead of one monolithic one)
07:20:49 <xinming> ski: In fact, I think this is a bit like attribute in lisp (IIRC)
07:22:05 <ski> it's like "dynamically scoped" variables
07:22:35 <ski> ('attribute' might be that, i'm not sure)
07:25:03 <mjl69_> @commands
07:25:03 <lambdabot> Unknown command, try @listcommands.
07:25:09 <mjl69_> @listcommands
07:25:09 <lambdabot> use listcommands [module|command]. Modules are:
07:25:09 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
07:25:09 <lambdabot> help hoogle karma localtime more pl plugs poll pretty quote search seen
07:25:09 <lambdabot> spell state system todo topic type version vixen where
07:25:34 <ski> g'day triplah
07:26:01 <xinming> ski: hmm, Monad is a bit like a name for this thinking, But Monadic action is used in functions, right?
07:26:39 <ski> yes, Monad is the concept
07:26:48 <ski> monadic actions are values
07:26:53 <ski> ask :: Reader e e
07:26:57 <ski> that's a monadic action
07:27:13 <xinming> so, return is also a monadic action?
07:27:20 <mjl69_> this made me jump over to Cale's MonadsAsContainers on the wiki to see if I get it now.
07:27:50 <ski> monadic actions have type 'm a' where 'm' is the monad's type constructor, and 'a' is the monadic return type of the action (i.e. the type of what it monadically will return)
07:28:06 <ski> return :: a -> Reader e a
07:28:17 <ski> return "abc" :: Reader e String
07:28:23 <ski> that last is a monadic action
07:28:37 <ski> 'return' takes a value, and returns a monadic action
07:30:01 <ski> if you have an expression of type 'Reader Foo Int', then this returns a monadic action
07:30:40 <ski> if we want to speak about the integer thats "inside", i usually say that the action "monadically returns" an integer (i.e. something of type 'Int')
07:30:49 <xinming> hmm, How do I translation of the monadic action? the action of this Monad?
07:30:56 <ski> that's how i use that construction "monadically returns"
07:31:07 <ski> xinming : sorry ?
07:31:13 <ski> can you rephrase ?
07:33:07 <xinming> hmm, I mean, In fact, What I learn about Monad, I will try to translate into Chinese. So, I wonder, the meaning of monadic action. Since, In my understanding for now, monadic action is a computation which compose the value, and return the monad.
07:33:15 <ski> if you have '..foo.. >>= \x -> ..bar..', then i say '..foo..' monadically returns 'x', which can then be used in '..bar..'
07:33:43 <ski> (and '..foo.. >>= \x -> ..bar..' = 'do x <- ..foo..; ..bar..', using do-notation, syntax)
07:34:23 <ski> xinming : i think you can certainly call things the way you do .. but strictly it's not correct
07:34:33 <ski> *nothing* "returns" the monad
07:34:37 <ski> it's not possible
07:35:18 <ski> the monad doesn't exists at the value level of language (same level as numbers and strings and lists and functions and IO-actions, etc exists on)
07:35:19 <xinming> hmm, so, all are monadic actions?
07:35:23 <ski> yes
07:35:23 <basti_> but, the monadic computations return monadic values.
07:35:32 <basti_> at least thats how i call them
07:35:37 <ski> yes, you can say monadic values, too
07:35:40 <basti_> i agree that you can't "return a monad"
07:36:17 <basti_> (you can't pass values of other than 0-ary type in haskell)
07:36:21 <xinming> hmm, I think I should say, return a container which won't make people unhappy. >_<
07:36:24 <basti_> or can you?
07:36:27 <basti_> no that was nonsense
07:36:28 <basti_> lol
07:36:41 <ski> xinming : think of the *type* 'Int', e.g. .. you can't have a function that returns *that* type (in haskell) .. you *can* otoh have functions that returns *values* of that type
07:37:08 <basti_> you can't pass types in haskell programs.
07:37:18 <ski> basti_ : right
07:37:39 <basti_> so you can't pass the monad either. but you can pass a value that has a monadic type
07:38:19 <ski> xinming : sure, if you use the analogy of monadic actions as containers (or monads as container types), then you could say it returns a container
07:39:06 <xinming> the monadic computations return monadic values.
07:39:20 <xinming> basti_: your words makes sense to me. :-)
07:39:38 <ski> the thing to notice is .. 'monad' concept exists on type-level (together with 'Int','Maybe','String','IO') .. not on value-level (where '42','Nothing','"abc"','getLine' live)
07:39:47 <xinming> ski: hmm, monadic action isn't understandable to that one. :-)
07:40:23 <xinming> s/to/compare with/
07:40:33 <basti_> why monadic computations are analogous to "actions" is a different topic
07:40:47 <xinming> ....
07:40:59 <basti_> thats because you can thread them in certain ways only
07:41:08 <basti_> >>= restricts you
07:42:19 * xerox >>=s basti_ 
07:42:28 <basti_> >>= yourself.
07:42:34 <xerox> haha
07:42:38 <xinming> ...
07:43:27 <musasabi> monadic computations = monadic values
07:44:21 <xinming> haha, right... They all return the same type. :-/
07:47:12 <ski> one way to think of it is like : monadic values represent effectful computations
07:51:11 <xinming> ski: do { line <- getLine; return line }; for the example here, line should be called monadic action. right?
07:51:32 <ski> no, 'getLine
07:51:39 <flux__> also the whole thing is a monadic action
07:51:39 <ski> ' is an IO-action
07:51:47 <ski> 'line' is a string
07:51:56 <flux__> composed of doing getLine
07:52:26 <ski> ("s/\n//")
07:52:54 <flux__> sed cannot remove newlines (with such notation) ;)
07:53:11 <musasabi> @seen shapr
07:53:12 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 3 hours, 44 minutes and
07:53:12 <lambdabot> 51 seconds ago.
07:53:30 <flux__> that line breaking stuff can be distracting sometimes
07:53:42 <musasabi> Is shapr the one responsible for Trac things on hackage.haskell.org ?
07:53:43 <flux__> "seen shapr 51 seconds ago? no way!"
07:55:46 <ski> flux__ : hehe, was worth a try
07:56:52 <xinming> ski: hmm, For Reader monad, return will be called Reader-action, and the whole composited with other actions, will called monadic action.
07:56:59 * xinming hopes that he is right.
07:58:07 <xinming> Ok, anyway, thanks ski, I just now read part of the older part of <<All about monad>>, It is really understandable to me. :-)
07:59:32 <ski> xinming : well
08:00:10 <ski> 'monadic action' is a general name, either when we don't talk about a specific monad, or for some reason want to use the general name anyways
08:00:21 <ski> in the IO monad : monadic action = IO-action
08:00:29 <ski> in the Reader monad : monadic action = Reader-action
08:00:31 <ski> etc
08:00:34 <ski> xinming : ok ?
08:00:55 <ski> @type getChar
08:00:56 <lambdabot> IO Char
08:01:01 <ski> that's an IO-action
08:01:05 <ski> @type putChar
08:01:06 <lambdabot> Char -> IO ()
08:01:34 <ski> that's a function that given a char given back an IO-action (most often run directly but not necessarily)
08:01:35 <xinming> putChar is still an IO-action
08:01:49 <ski> strictly speaking, putChar is a function
08:01:53 <xinming> ....
08:01:58 <ski> @type putChar 'Q'
08:01:59 <lambdabot> IO ()
08:02:05 <ski> that's an IO-action
08:02:23 <ski> but, yes, in casual speak, one could call 'putChar' an IO-action
08:02:36 <ski> @type sequence
08:02:37 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:02:45 <xinming> I think I catch the idea...
08:03:09 <ski> this takes a list of monadic actions, and gives back a composite monadic action that runs them in order, and collects the results in a list
08:03:27 <ski> @type sequence [putChar 'a',putChar 'b']
08:03:29 <lambdabot> IO [()]
08:03:34 * xinming thought if ski can give this online lesson earlier, he won't waste over 4 days.
08:03:56 <ski> here you don't run the actions immediately, but first store them in a list .. then 'sequence' will run them
08:04:04 <ski> xinming : heh
08:07:22 <xinming> then, the implement of sequence will be, sequence (x:xs) = x >>= \x' -> x':sequence xs
08:07:23 <xinming> :-P
08:08:09 <ski> almost, yes
08:08:24 <ski> sequence (x:xs) = x >>= \x' -> liftM (x':) $ sequence xs
08:08:26 <ski> or
08:08:30 <xinming> certainly, there will be a sequence [] = []
08:08:41 <ski> sequence (x:xs) = x >>= \x' -> sequence xs >>= \xs' -> return (x':xs')
08:08:48 <ski> sequence [] = return []
08:08:48 <Oejet> A fold perhaps?
08:08:50 <ski> :)
08:09:01 <mjl69_> a type class is a grouping of types and functions that are defined on those types.  To add a new type to a class, the functions of that class must be defined on the new type.  Is that correct?
08:09:07 <ski> Oejet : think so, yes
08:09:29 <ski> mjl69_ : yes, more or less
08:09:32 <xerox> It needs mplus
08:09:40 <xerox> Ah, it doesnt
08:09:50 <xerox> sequence = foldr (mplus) mzero
08:10:02 <mjl69_> Monad is a type class, correct?
08:10:09 <xerox> Right.
08:10:15 <ski> mjl69_ : s/To add a new type to a class/To add a new group of types to a class/  s/must be defined on the new type/must be defined on the new types/
08:10:31 <ski> msum = mplus mzero
08:10:41 <xerox> heh
08:10:46 <xerox> good one.
08:10:47 <ski> err
08:10:52 <xerox> `mplus` ?
08:10:53 <ski> msum = foldr mplus mzero
08:10:54 <ski> !
08:10:57 <xerox> aaah.
08:10:59 <mjl69_> @type (>>=)
08:11:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
08:11:01 <xerox> makes even more sense
08:11:12 <basti_> msum = foldr1 mplus
08:11:25 <xerox> @index msum
08:11:25 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
08:11:25 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
08:11:25 <lambdabot> Control.Monad.Error, Control.Monad.List
08:11:29 <xerox> @libsrc Control.Monad
08:11:30 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
08:11:30 <xinming> or sequence = map (flip (:))
08:11:31 <xinming> :-P
08:11:38 <xinming> am I right? :-P
08:11:39 <mjl69_> so >>= is a function of the type class Monad?
08:11:39 <ski> sequence = foldr (\ma mas -> ma >>= \a -> mas >>= \as -> return (a:as)) (return [])
08:11:45 <xerox> xinming: you have to put >>= on fire, though
08:11:55 <ski> sequence = foldr (\ma mas -> ma >>= \a -> mas >>= return . (a:)) (return [])
08:12:01 <ski> hm
08:12:09 <ski> @type let sequence = foldr (\ma mas -> ma >>= \a -> mas >>= \as -> return (a:as)) (return []) in sequence
08:12:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:12:16 <ski> right type, anyways
08:12:23 <xinming> Oh, yea, use (>>=)
08:12:30 <xinming> really funny...
08:12:36 <xerox> -- | This generalizes the list-based 'concat' function.
08:12:36 <xerox> msum        :: MonadPlus m => [m a] -> m a
08:12:36 <xerox> {-# INLINE msum #-}
08:12:37 <xerox> msum        =  foldr mplus mzero
08:12:42 <ski> @type let sequence = foldr (\ma mas -> ma >>= mas >>= (.) return . (:)) (return []) in sequence
08:12:42 <xerox> heh.
08:12:43 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
08:12:43 <lambdabot>   Expected type: [b] -> [b] -> b
08:12:45 <xinming> x + y = z; y + x = z
08:12:56 <ski> @type let sequence = foldr (\ma mas -> ma >>= (mas >>= (.) return . (:))) (return []) in sequence
08:12:56 <mjl69_> and 'do' is shorthand for >>= (a lambda expression) ?
08:12:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:12:57 <lambdabot>   Expected type: [a] -> a
08:13:13 <ski> hrm
08:13:26 <ski> mjl69_ : yes
08:13:54 <ski> @type let sequence = foldr (liftM2 (:)) (return []) in sequence
08:13:57 <lambdabot> Not in scope: `liftM2'
08:14:00 <xerox> eh.
08:14:05 <ski> @type let sequence = foldr (Control.Monad.liftM2 (:)) (return []) in sequence
08:14:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:14:10 <ski> that's it !
08:14:13 <xerox> indeed.
08:14:16 <ski> sequence = foldr (Control.Monad.liftM2 (:)) (return [])
08:14:30 <ski> note that another name for 'return' would be 'liftM0'
08:14:48 <xerox> This sounds new.
08:15:03 <basti_> thats obvious
08:15:17 <xerox> To me :-D
08:16:05 <ski> @pl \ma mas -> ma >>= \a -> mas >>= \as -> return (a:as)
08:16:06 <lambdabot> liftM2 (:)
08:16:10 <ski> hehe
08:16:36 <ski> (mjl69_ : yes to both questions)
08:21:14 <mjl69_> ski: thanks! back to ghc experiments...
08:22:27 <ski> (mjl69_ : though .. do actually can expand 'let' (and there's one more detail) .. but that's the rough picture)
08:31:40 <benny> hello, i'm checking out Haskell XML Toolbox and in the docs there's an example using applyBottomUp function, but I can't find any information about this function and it doesn't seem to exist anywhere!
08:32:53 <ski> @index applyBottomUp
08:32:54 <lambdabot> bzzt
08:32:56 <ski> hm
08:33:15 * ski hasn't used that xml thing
08:33:30 <ski> in what context is this applyBottomUp used ?
08:33:37 <ski> or, what's it's type ?
08:33:51 <ski> hm .. maybe it's in fptools library or something ??
08:35:44 <xs> benny: isn't it part of the toolbox? google suggests it's :: TFilter Node -> TFilter Node
08:38:06 <benny> here's the example i'm reading: http://www.fh-wedel.de/~si/HXmlToolbox/thesis/x1438.html
08:38:39 <benny> xs: yeah, that's it's type apparently, but i can't seem to find it's implementation anywhere
09:01:35 <joelr1> folks, how would you rewrite this to include full evaluation of "i"?
09:01:36 <joelr1> wrap :: (a -> b, b -> a) -> PU a -> PU b 
09:01:36 <joelr1> wrap (i, j) pa = sequ j pa (lift . i) 
09:02:33 <joelr1> @type seq
09:02:34 <lambdabot> forall b a. a -> b -> b
09:02:38 <joelr1> hmm
09:04:07 <benny> hm... oh well, asking here was worth a shot i guess :)
09:05:00 <ski> (benny : hmm, mail author ?)
09:05:24 * benny is too embarasses for that
09:08:01 <ski> "The source code of the example application is included in the doc/cookbook directory of the distribution"
09:08:06 <benny> it's time for battle of the bands anyway :)
09:08:10 <ski> hm
09:09:08 <benny> ski: thing is, the function is listed here: http://www.fh-wedel.de/~si/HXmlToolbox/thesis/x1178.html
09:09:12 <musasabi> joelr1: wrap (i, j) = i `seq` sequ j pa (lift . i)
09:09:46 <joelr1> musasabi: thanks
09:09:54 <benny> i think Haskell XML Toolbox might be over my head anyway. it uses a State monad and I don't understand monads yet
09:10:24 <joelr1> musasabi: i got my memory usage down drastically
09:10:28 <musasabi> Haskell XML Toolbox has also a nifty arrow interface with the possiblity to use arrow transformers ;)
09:10:39 <musasabi> joelr1: congratulations :-)
09:10:57 <benny> musasabi: yeah i apparently think that arrows are way cool but i don't understand them either :)
09:11:02 <joelr1> musasabi: but i think i'm up against thread priorities or something like that now
09:11:03 <benny> anyway gotta go to battle of the bands now
09:11:13 <musasabi> joelr1: those are simple round robin.
09:11:38 <joelr1> musasabi: i know but i think this is adversely affecting me
09:11:50 <musasabi> mmh
09:12:01 <musasabi> btw how much do you need the kqueue thing?
09:12:07 <joelr1> musasabi: i'm trying to launch 4k bots
09:12:16 <joelr1> musasabi: i would be a good beta-tester probably :)
09:12:34 <joelr1> since i'm developing on freebsd (mac osx) and deploying on freebsd (intel)
09:12:40 <musasabi> joelr1: well doing it properly means 6.6 (I think I may well hack that)
09:13:07 <joelr1> musasabi: do you think there's an issue with connectTo retaining memory or something like that?
09:13:09 <musasabi> joelr1: but if you are fine with a hacky solution (which won't be in mainline) I can provide something for 6.4
09:13:43 <joelr1> musasabi: i would take it one step at a time. i don't think select is what's killing me now
09:13:47 <joelr1> not sure yet at least
09:13:59 <musasabi> joelr1: hopefully those freebsd boxes are not 5.x with SMP (because kqueue sucks with that setup)
09:14:56 <musasabi> joelr1: ok, bug me if it becomes a major issue because a hacky patch for kqueue is not hard (since I already have kqueue working with Haskell)
09:15:27 <neologism> post the patch somewhere to be intergrated to the ports
09:15:49 <joelr1> can you do me a favor and look at this? http://wagerlabs.com/randomplay.ps
09:16:20 <joelr1> @paste
09:16:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:17:12 <musasabi> joelr1: do you use threaded?
09:17:22 <joelr1> musasabi: no, why? not in this case
09:17:27 <kzm__> @babel es en coto
09:17:28 <lambdabot>  boundary
09:17:42 <joelr1> musasabi: i switched to -threaded but then had strange crashes
09:17:56 <musasabi> joelr1: ok. (I had some ideas for -threaded related memory leaks)
09:18:08 <joelr1> musasabi: i just pasted my pokerClient#2
09:18:28 <joelr1> do you see pokerClient#2 on that list? i pasted it
09:22:19 <musasabi> yes, it looks good.
09:22:32 <joelr1> looks good? but why the memory retained?
09:22:58 <joelr1> i mean, it looks good to me too, the pokerClient#2 at least but i do not understand why it shows on the memory retained report
09:23:08 <joelr1> i did not launch a lot of clients by that time, btw
09:23:12 <joelr1> maybe 100 or 200
09:23:52 <musasabi> I would confirm whether it is really a problem with something else than -hr
09:24:27 <musasabi> (-hr can be quite misleading)
09:24:40 <joelr1> musasabi: well, i'm not saying there's a problem, it's just that that piece of code seems to retain memory for whatever reason
09:24:45 <joelr1> wierd
09:25:06 <musasabi> btw you have three nested exception handlers there ;)
09:25:22 <jimapple> @seen lennart
09:25:22 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
09:25:23 <joelr1> musasabi: come again?
09:25:39 <musasabi> 1) withMVar, 2) catchError, 3) inside connectTo 
09:26:33 <musasabi> (of course killing the whole Control.Monad.Error would make things faster)
09:26:34 <joelr1> musasabi: well, i want 1) a lock around connectTo and 2) report a specific error
09:26:57 <joelr1> musasabi: but would that buy me anything? killing the whole control.monad.error thing
09:27:21 <joelr1> musasabi: you think the memory would stop being retained? let me try that
09:27:53 <joelr1> done
09:27:58 <joelr1> will see if there's any difference
09:28:20 <musasabi> joelr1: I have had performance improvements from killing Control.Monad.Error
09:29:07 <musasabi> joelr1: the exception handlers are probably quite small constant overhead, just more a matter of style and micro-managing.
09:29:08 <joelr1> i think i don't have a thread priority issue
09:29:26 <joelr1> musasabi: i think i have a queueing issue
09:29:33 <joelr1> did you see the queue i posted to haskell-cafe?
09:31:29 <joelr1> well, the implementation does not matter, it's a bounded queue
09:32:05 <joelr1> i had very good results with using single-slot mailboxes (TMVar's) for each event queue and several event queues overall
09:32:35 <joelr1> one for keyboard input (to send that quit command), one for network events, one for script events, one for timers, etc.
09:33:20 <musasabi> joelr1: I would just use something like, MVar SomeQueueImplementation
09:33:22 <joelr1> but you cannot do retainer profiling with stm so i took it out. now, i used to have `orElse` to take an event from either of those single-slot mailboxes
09:33:32 <joelr1> and that worked well
09:33:37 <musasabi> joelr1: e.g. data SimpleQueue a = SQ Int [a] [a]
09:33:50 <joelr1> while taking STM out i switched to a bounded queue but that in itself is not the problem
09:34:14 <musasabi> yes, but why the Chan instead of a normal functional queue?
09:34:20 <joelr1> the fact that the queue is bounded _is_. now the queue can be full of network events and i will block my script while trying to post a scripting event into it :(
09:34:49 <joelr1> which means that i should really have a separate network queue and now need to take an event from ether of the two queues i have 
09:35:11 <joelr1> what's an efficient way of doing that without STM? doing a try, another try and then going for a loop?
09:35:28 <joelr1> if no event was retrieved
09:35:52 <joelr1> actually, what i should probably do is plug in the priority queue that ben sent me 
09:36:02 <joelr1> then i can have different bounds for different priorities
09:36:03 <jlouis> joelr1: which kind of prioq?
09:36:06 <musasabi> joelr1: MVar [SomeQueue] ?
09:36:07 <joelr1> which would be exactly what i want
09:36:30 <joelr1> i do this right now
09:36:30 <joelr1> writeQ :: Queue a -> a -> IO ()
09:36:31 <joelr1> writeQ (Queue sem q) x = 
09:36:31 <joelr1>     do waitQSem sem
09:36:31 <joelr1>        writeChan q x
09:36:31 <musasabi> with the queues for different event priorities
09:36:49 <joelr1> but i really ought to have one semaphor per "channel"
09:37:03 <musasabi> have to run ->
09:37:10 <joelr1> cheers!
09:38:20 <jlouis> My preferred functional priq is a pairing heap
09:38:42 <jlouis> if merging is important, lazy binomial heaps or something like that
09:43:09 <elux> hey
09:43:17 <elux> how can i handle bit manipulation in haskell?
09:43:34 <tromp_> see Data.Word
09:43:51 <elux> i am trying to write a pdf parser, so i'll need to create a data structure that is defined by bit/bytes
09:45:05 <elux> is there a Bit datatype?
09:45:08 <elux> so i can have a list of bits for example
09:45:21 <elux> i see Word, Word8, Word16, Word32, Word64 .. all handy
09:45:26 <elux> but i also need a bit datatype
09:46:34 <benny> how about Data.Bits?
09:46:52 <benny> or you might want to use Bool
09:46:54 <elux> perfect thanks
09:47:01 <elux> yea i guess a list of bool's would work too
09:47:12 <elux> but i think Data.Bits is more appropriate
09:56:44 <HaskNoob> is there a glossary somewhere?
09:56:58 <ski> for what ?
09:57:08 <HaskNoob> There are a lot of special terms in the haskell report and the tutorials
09:57:16 <HaskNoob> it would be useful i think
09:57:21 <HaskNoob> if there isnt one
09:57:27 <ski> hm, yes, could be useful
09:57:36 * ski doesn't know of one
09:57:43 * ski hasn't looked, though
09:58:10 <ski> the wiki gives some help on this, though, i think
09:58:17 <palomer> a glossary would be very, very cool
09:58:42 <HaskNoob> we could start it maybe as an addition to the wiki
09:59:03 <HaskNoob> i'm very very new to haskell.. like a day new
09:59:16 <palomer> wikipedia should have subpedias
09:59:28 <palomer> then we could start a haskell subpedia in wikipedia
09:59:31 <jlouis> HaskNoob: then you are not a newbie anymore ;)
10:00:06 <xerox> palomer: it does, doesn't it?
10:00:11 <xerox> wikibooks, or whatever are calleds
10:00:12 <HaskNoob> i'm not sure what you mean, but i still feel like one
10:00:18 <Saulzar> Hmm, I think there's some pretty good information on the wiki
10:00:28 <xerox> -s
10:00:35 <palomer> wikibooks is about books
10:00:47 <HaskNoob> you mean the haskell wiki, i'm getting confused because someone mentioned wikipedia
10:01:02 <desrt> Igloo; ping.
10:01:44 <ski> ('the wiki' here is usually the haskell wiki)
10:03:05 <ski> (HaskNoob : hm, did you wonder about something rn ?)
10:03:23 <HaskNoob> rn?
10:03:27 <HaskNoob> whats rn?
10:03:34 <helmer> how can I concat 2 integers? as in 2 and 3 give out 23
10:03:46 <ski> rn = right now
10:03:50 <HaskNoob> oh
10:03:58 <jlouis> > concatMap show 2 3
10:03:58 <lambdabot>   The function `concatMap' is applied to three arguments,
10:03:58 <lambdabot>   but its type `(a -> [b]) -> [a] -> [b]' has only two
10:03:58 <lambdabot>   In the definition of `ocb': ocb = concatMap show 2 3
10:04:12 <ski> > 10 * 2 + 3
10:04:12 <jlouis> > concatMap show [2, 3]
10:04:13 <lambdabot> 23
10:04:14 <lambdabot> "23"
10:04:20 <HaskNoob> well i want to struggle a bit more with the docs before i ask things here.. dont want to be accused of not reading enough or something hehe
10:04:22 <xerox> concatMap show [2,3]
10:04:25 <xerox> cool.
10:04:48 <ski> > read (concatMap show [12,345,6789])
10:04:49 <lambdabot> Add a type signature
10:04:52 <ski> > read (concatMap show [12,345,6789]) :: Int
10:04:53 <lambdabot> 123456789
10:05:13 <helmer> thanks
10:05:29 <HaskNoob> hmmm
10:05:35 <xerox> > read . (>>= show) $ [12,345,67,89]
10:05:38 <lambdabot> Add a type signature
10:05:42 <xerox> > read . (>>= show) $ [12,345,67,89] :: Int
10:05:43 <lambdabot> 123456789
10:06:27 <ski> > read (do n <- [12,345,67,89]; show n) :: Int
10:06:28 <lambdabot> 123456789
10:06:45 <HaskNoob> you know, maybe since i'm reading the docs anyway, i should compile a list of terms that could be expounded upon in a glossary.. if noone has started such a project..
10:06:57 <ski> could be nice
10:07:12 <benny> HaskNoob: which docs are you reading?
10:07:19 <xerox> > read . concat . (`fmap` show) $ 
10:07:19 <ski> (HaskNoob : anyway, ppl here are usually happy to answer questions ..)
10:07:20 <lambdabot>  parse error on input `}'
10:07:21 <xerox> ops
10:07:28 <benny> HaskNoob: there are several haskell tutorials that should explain everything from zero without needing to know a lot of terms
10:07:37 <HaskNoob> mostly the report, and the gentle tutorial meant to accompany it
10:07:47 <HaskNoob> oh
10:07:55 <ski> @hoogle yaht pdf
10:07:56 <lambdabot> Prelude.undefined :: a
10:07:56 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
10:07:56 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:08:00 <ski> er
10:08:01 <HaskNoob> maybe you should point me to some.. might be better than what i have
10:08:02 <ski> @google yaht pdf
10:08:04 <lambdabot> http://cs.annauniv.edu/~portal/files/dev/haskell-yaht.pdf
10:08:21 <xerox> @google Yet Another Haskell Tutorial pdf
10:08:22 <ski> @google yet another haskell tutorial pdf
10:08:22 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
10:08:23 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
10:08:35 * ski smiles
10:08:42 <HaskNoob> ah.. i think i have an aversion to pdf files.. thats my problem
10:08:43 <xerox> :)
10:08:50 <xerox> @google Yet Another Haskell Tutorial ps
10:08:51 <lambdabot> http://haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage
10:08:56 <xerox> @google Yet Another Haskell Tutorial filetype:ps
10:08:57 <lambdabot> http://www.haskell.org/communities/11-2002/report.ps
10:09:01 <ski> http://www.isi.edu/~hdaume/htut/tutorial.ps
10:09:02 <xerox> Hmpf :-)
10:09:07 <HaskNoob> welll i like plain old html
10:09:09 <xerox> yeah :-P
10:09:27 <HaskNoob> but anyway i'll check these out
10:09:27 <ski> anyway, 'tis said that one is pretty good
10:10:04 <TFK> mmm, docs in HTML...
10:10:17 <xerox> @google All About Monads
10:10:18 <xerox> :-)
10:10:18 <lambdabot> http://www.nomaware.com/monads/html/
10:10:28 <ski> that's not a haskell tut :)
10:10:35 <xerox> @wiki HaskellDemo
10:10:38 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
10:10:44 * ski scolds xerox
10:10:54 <ski> yes that last is short and simple
10:11:00 <HaskNoob> what i have benefitted the most from so far, is just sample programs
10:11:18 <Rolling> do you have the printable version of "all about monads"?
10:11:19 <xerox> :(
10:11:20 <ski> HaskNoob : do you know any other FPL ?
10:11:28 <HaskNoob> FPL?
10:11:32 * xerox scolds ski
10:11:39 <TFK> I don't like the fact that while introducing different monads, "All About Monads" says "welp, here's the monad, but you can't understand it with Haskell 98" :-/
10:11:44 <ski> fpl = functional programming language
10:11:47 <HaskNoob> oh
10:11:49 <xerox> Acronyms are newbie-unfriendly for definition.
10:11:49 <ski> xerox : danke :)
10:11:50 <Pupeno> Running: `ghc -M -optdep-f -optdep.ShSap.o.dep  ShSap.o -v` I get the error: Could not find module `'. What does that error mean ? module `' ?
10:11:53 <xerox> :-)
10:11:59 <Rolling> do everyone have the printable version of "all about monads"?
10:12:05 <HaskNoob> yeah, i messed with ocaml for a while, and then scheme
10:12:09 <ski> Rolling : yes
10:12:18 <Rolling> where?
10:12:25 <HaskNoob> now i'm messing with haskell
10:12:28 <HaskNoob> hehe
10:12:32 <xerox> HaskNoob: good choice.
10:12:48 <xerox> HaskNoob: do you have any specific question yet?
10:12:58 <xerox> Feel free to ask, in case, people is helpful herearound.
10:13:03 <HaskNoob> i will real soon
10:15:02 <ski> HaskNoob : ok, then possibly the "gentle" tutorial won't be as hard for you, then ..
10:15:23 <ski> Rolling : can you take dcc ?
10:15:28 <HaskNoob> in ocaml, i found the type inference was neat.. but at the same time, i felt like it was often not worth it.. like i still had to think about types anyway.
10:15:47 <TFK> So where is the printable version of All About Monads, really?
10:15:51 <araujo> HaskNoob, Thinking about types is good!
10:15:59 <int-e> how can you code and not think about types?
10:16:02 <HaskNoob> and the ability to not specify them just made it less clear in my code
10:16:13 <flux__> you can specify types if you want
10:16:23 <HaskNoob> well, in scheme for example, i dont find i have to think about them as much
10:16:26 <flux__> infact, at times you might be encouraged to, so the compiler can check if it agrees with you
10:18:09 <HaskNoob> i like that haskell has type signatures, i'm not sure they are required or not..
10:18:36 <basti_> HaskNoob: in some cases you need them
10:18:44 <basti_> (and in many more, they make your life much more easier
10:18:46 <ski> usually they are not required
10:18:50 <HaskNoob> yeah
10:18:56 <HaskNoob> i think i'll just always use them
10:19:07 <basti_> its good practice to use them for toplevel functions
10:19:15 <HaskNoob> when i was first introduced to type inference in ocaml, i was taking too much advantage of it
10:19:17 * ski usually always uses them on toplevel, and sometimes in inner scopes
10:19:29 <int-e> adding them helps getting the type errors to the place where the actual bug is :)
10:19:39 <basti_> int-e: yes.
10:19:54 <Saulzar> HaskNoob, I found the same problem, I think it is very common :)
10:20:10 <HaskNoob> i guess because none of the other languages i knew had that ability, so i wasnt quite accustomed to using it appropriately
10:20:18 <ski> often, though, it can be good to see if system can infer more general type
10:20:30 <basti_> you can use it in a way that is not appropriate?
10:20:32 <ski> then one can paste that in (or an instance of it)
10:20:59 <HaskNoob> basti_: well, i can neglect to actually write what types a function operates on
10:21:07 <HaskNoob> things like that
10:21:25 <HaskNoob> and i would have to keep it in my mind anyway, but its never clearly stated anywhere
10:21:27 <ski> for very simple functions, i sometimes don't bother
10:21:30 <ski> like
10:21:36 <ski> (>.>) = flip (.)
10:21:48 <basti_> HaskNoob: you can ask ghci for the types of expressions
10:21:57 <ski> @type flip (.)
10:21:59 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
10:22:02 <HaskNoob> ghci?
10:22:10 <basti_> thats the interactive environment of ghc
10:22:11 <ski> ghci is ghc interactive
10:22:12 <HaskNoob> let me see if i have that
10:22:14 <HaskNoob> oh
10:22:19 <basti_> its a lot like a lisp REPL
10:22:19 <ski> ghc is a compiler
10:22:20 <HaskNoob> ok
10:22:22 <ndm> HaskNoob, windows or unix?
10:22:24 <HaskNoob> i have hugs and ghc
10:22:27 <ski> hugs is an interpreter
10:22:29 <HaskNoob> i'm on debian
10:22:32 <HaskNoob> stable
10:22:46 <HaskNoob> i think i'm using the packages from debian too, so things might be old
10:22:52 <ndm> i prefer hugs, but most people seem to use ghc/ghci
10:23:04 <Korollary> ndm: why do you prefer hugs?
10:23:06 <ndm> both have a command for displaying types, :t map, for example
10:23:08 * ski uses hugs often
10:23:20 <ndm> Korollary, because its a LOT faster - maybe 100x or more
10:23:21 * sieni hugs often, but uses ghci
10:23:33 * ski hugs HuGS
10:23:36 <xerox> GHC++
10:23:42 * basti_ doesnt bother that ghci is slower...
10:23:44 <ndm> and because it has a beautiful windows front end, which makes me laugh at console users :)
10:23:49 <xerox> @karma+ GHC
10:23:49 <Korollary> ah
10:23:50 <lambdabot> GHC's karma raised to 1.
10:24:06 <HaskNoob> hmmm i use hugs in the console
10:24:15 <HaskNoob> but i didnt even know about ghci
10:24:19 <ndm> on linux there is no gui to hugs
10:24:19 <xerox> I've more than tree fingers, nice GUI.
10:24:38 * Korollary deforests xerox' hands
10:24:46 <ndm> the only linux haskell interpreter with a gui is Yhc, and i don't recommend that (yet)
10:25:00 <xerox> Trolls cutting my fingers!  Flame, flame!
10:25:04 <Korollary> hIDE all the way
10:25:28 * Korollary praises tools he has never even seen
10:25:38 <ski> ndm : hm, could WinHugs2 be ported, do you think ?
10:25:40 <xerox> That's perfectly OK ;-)
10:25:49 <ndm> ski, to GHC or to Linux?
10:26:07 <ndm> either would be quite a bit of work
10:26:09 <ski> ndm : Linux
10:26:15 <ndm> it may run under Wine
10:26:19 <ski> ndm : (re above) WinHaskell ?
10:26:29 <ndm> and if it doesn't, if people tell me why it doesn't, then i'd happily fix it
10:26:56 <xerox> Programming under Wine sounds silly
10:27:04 <ndm> ski: WinHaskell is my project for a better than WinHugs interface, which does Hugs and Yhc at least
10:27:12 <benny> it should be really easy to make a gui version of ghci
10:27:28 <xerox> benny: how would you like it?
10:27:37 <ndm> you may want to check out gyhe, its a GUI which is cross platform and cross compiler
10:27:38 <HaskNoob> i really love scheme's cut and cute.. now haskell has real currying.. but is there a way to just "curry upon" the middle parameter, like cut lets you do in scheme?
10:27:46 <ski> ndm : yes .. was that what you meant by gui for yhc, above ?
10:27:49 <Saulzar> Hmm, not sure it is really worth it under Linux
10:27:54 <xerox> HaskNoob: in some sense, yes
10:28:02 <Korollary> I dont even remember what hugs' GUI front end did.
10:28:10 <ndm> ski: yes, gyhe is the gui for yhe, but in reality it doesn't even use yhc yet, it uses ghc
10:28:15 <HaskNoob> i noticed "flip"
10:28:23 <xerox> HaskNoob: another good effect is 'sections'
10:28:25 <benny> none of the people capable of making a ghci gui are interested in one :)
10:28:31 <HaskNoob> when i did a curry with (+1) it put a flip in there
10:28:41 <Saulzar> Why use a gui as an interface to a console app?
10:28:44 <HaskNoob> oh
10:28:48 <xerox> > map (\x -> x * 2) [0..9]
10:28:49 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
10:28:56 <HaskNoob> hmm havent learned anything about sections yet
10:29:08 <xerox> > map (\x -> (*) 2 x) [0..9]
10:29:09 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
10:29:09 <ski> ndm : the 'e' standing for ?
10:29:14 <ndm> Saulzar, WinHugs makes me twice as productive as with a standard console - its a better interface to give higher productivity
10:29:17 <ndm> ski: evaluator
10:29:21 <xerox> > map (*2) [0..9]
10:29:22 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
10:29:23 <HaskNoob> the hugs i have is compiled with readline support and thats nice
10:29:25 <xerox> ^- this is a section
10:29:31 <Saulzar> ndm, Really? What does it do?
10:29:37 <HaskNoob> nicer than any gui interface i can think of
10:29:45 <ski> @pl \z -> f x y z
10:29:45 <lambdabot> f x y
10:29:48 <ski> @pl \y -> f x y z
10:29:49 <lambdabot> flip (f x) z
10:29:50 <ndm> Saulzar, hyperlinks to error messages, so you can click and jump to the error in your editor
10:29:52 <ski> @pl \x -> f x y z
10:29:52 <lambdabot> flip (flip f y) z
10:29:56 <ndm> automatic reloading of modified files
10:30:04 <ndm> nice pretty colours
10:30:06 <Saulzar> ndm, Ahh - so it is somewhat of an IDE?
10:30:24 <ndm> Saulzar, that would be massively overstating it, but its maybe 10% of the way there
10:30:44 <Saulzar> I see, cool.
10:30:58 <tuomov> so what's needed is an error message parser for the shell buffer of an editor
10:31:12 <tuomov> although the shell buffer sucks compared to a real terminal usually
10:31:33 <ndm> tuomov, and not all editors have shell buffers
10:31:48 <tuomov> many do that people actually use for programming
10:31:52 <tuomov> I don't use one, though
10:32:01 <tuomov> I mean, I don't use the shell buffer
10:32:04 <ndm> not on windows, very few have shell buffers, very few have good ones
10:32:11 <xerox> Emacs!
10:32:21 <tuomov> it's much more convenient to switch to the command line with ^KZ as I prefer running the editor in the terminal
10:32:41 <tuomov> and for C compilation there's of course error parser
10:32:43 <xerox> C-c C-l and you get the file loaded up in ghci, or reloaded if needed
10:32:44 <HaskNoob> i'm a vimist
10:32:49 <tuomov> and this doesn't need the interactive shell
10:33:06 <HaskNoob> i do a lot of vim
10:33:09 <xerox> If there are errors, it brings you up to the exact place (parsing the error)
10:33:32 <HaskNoob> i like it better than emacs.. arguably i havent given emacs enough of a chance tho.
10:33:38 <tuomov> emacs sucks.
10:33:45 <benny> check this out guys: http://img317.imageshack.us/img317/143/stringprocgui0057fn.png
10:33:54 <tuomov> all editor sucks, though, but emacs isn't even configurable enough.
10:33:57 <tuomov> not easily anyway
10:34:04 <HaskNoob> oh i isnt?
10:34:09 <HaskNoob> i wouldnt have guessed that
10:34:15 <tuomov> it doesn't even have decent syntax hl!
10:34:20 <ski> (ndm : is there any info on gyhe on web ?)
10:34:24 <tuomov> it doesn't allow mapping ^C to something else 
10:34:32 <tuomov> all modes remap ^C
10:34:37 <HaskNoob> hmm
10:34:39 <HaskNoob> yeah
10:34:46 <tuomov> ^C is kill-buffer!
10:34:55 <tuomov> not some fscking mode prefix
10:34:56 <ndm> @wiki Yhc/Yhe
10:34:58 <lambdabot> http://www.haskell.org/hawiki/Yhc/Yhe
10:35:09 <tuomov> and it doesn't colourise operators and numbers in most syntax hl modes
10:35:45 <tuomov> http://modeemi.fi/~tuomov/ion/screenshots/ion2-4.png <-- can't get that kind of syntax hl in emacs
10:35:51 <tuomov> not without uber hacks anyway
10:36:15 <tuomov> (that's jed, btw)
10:36:20 <xerox> benny: cool!
10:36:24 <xerox> benny: did you write it?
10:36:36 <benny> xerox: yeah
10:36:53 <xerox> benny: what graphic library did you use?
10:36:59 <benny> xerox: gtk2hs
10:37:16 * xerox shakes benny's hand
10:37:57 <benny> it's a really simple program
10:38:11 <xerox> does it use hs-plugins?
10:38:18 <benny> with a little work, one could easily make a complete gui haskell environment like hugs or ghci
10:38:21 <benny> xerox: yeah
10:38:40 <xerox> Go for it!  I'd say.
10:38:46 <tuomov> stick that gui want to know where?
10:38:50 <xerox> Maybe darcsgetting hIDE?
10:39:04 * tuomov curses GUIs to oblivion
10:39:29 <tuomov> things that don't need graphics output capabilities should be written so that they can be run in terminals
10:40:28 <benny> tuomov: i see where you are coming from, but i think that you should be more open to the possibilites that guis can bring. they don't have to mean "for stupid people"
10:40:46 <benny> but for the record i use vim in xterm for all my editing needs :)
10:40:50 <tuomov> guis mean unusability given the current toolkits
10:40:56 <tuomov> and not integrating well with the shell
10:40:57 <HaskNoob> i say if some ppl like it, then its cool.. its extra work to support gui and command line, so if the programmer doesnt feel like it.. you know, thats fine with me
10:41:04 <benny> tuomov: yeah, i agree with you that most gui toolkits suck
10:41:34 <tuomov> hey, you know what I'd really like, a terminal that can display graphics!
10:41:41 <HaskNoob> yeah
10:41:44 <tuomov> xmlterm isn't it. it's too complicated.
10:41:56 <benny> tuomov: it's called a gui :D
10:41:59 <xerox> Hmm.
10:42:03 <tuomov> no, GUI==WIMP GUI in common usage
10:42:06 <xerox> a-la cl listener?
10:42:10 <HaskNoob> well in linux there is the framebuffer
10:42:12 <ski> one should be able to automatically do every function that's possible with gui
10:42:20 <ski> i.e. automate
10:42:20 <benny> ski: yep
10:42:54 <HaskNoob> so you could display graphics there, if you use frame-dev, and you could display graphics by popping a window or using a special terminal in x, but i think, the real problem is a lack of standardization for displaying graphics in terminals.
10:43:00 * ski hates that his pocket calculator provides lots of stuff only accessible through menus, interactively ..
10:43:09 <HaskNoob> i mean fbdev
10:43:14 <HaskNoob> whatever it is
10:43:19 <tuomov> actually, arbitrary XIDs (pixmaps, windows) should be displayable in the xterm stream
10:43:32 <tuomov> both inline and full-width (cmp. latex $x$ and \[foo\] math)
10:43:53 <tuomov> and that's all; nothing more complicated is needed
10:44:46 <benny> problem with adding graphical output capablities to command line programs is that it makes it near impossible to do things like piping
10:45:00 <HaskNoob> well as soon as you introduce it, you know it might evolve to become more complicated
10:45:32 <HaskNoob> after a while
10:45:51 <tuomov> all that is needed is  \esc[put-this-window-id-here
10:46:05 <basti_> benny: curses-style programs don't pipe very well either
10:46:07 <HaskNoob> yeah, ideally it should be pipe-able.. that means we're talking about more than just a terminal modification
10:46:29 <Saulzar> Consoles force you to remember everything at once, you lose the ability to pick out some function without memorising it first
10:46:52 <benny> basti_: yep, that's why it's sad that people uses curses programs even though they are sitting at a machine that is a graphics beast
10:47:13 <HaskNoob> not really
10:47:15 <tuomov> curses programs are usually more usable thatn wimp gui shit.
10:47:16 <HaskNoob> well
10:47:16 <benny> kind of like what i'm doing now with irssi ;)
10:47:17 <HaskNoob> sort of
10:47:26 <tuomov> there's actually thought been put into keyboard usage
10:47:32 <benny> tuomov: yes, that is why i am indeed using irssi :)
10:47:33 <Saulzar> tuomov, You sound a _tad_ prejudiced :)
10:47:38 <HaskNoob> yeah, but you can run these ncurses things inside GNU Screen and such
10:47:43 <tuomov> that's just a fact.
10:47:55 <benny> tuomov: yeah, but that's just the current situation
10:47:56 <HaskNoob> and that can be very handy
10:48:01 <Saulzar> "wimp shit" doesn't sound like objective talking :P
10:48:09 <tuomov> wimp is shit.
10:48:15 <tuomov> guis can be usable, wimp guis can't
10:48:21 <tuomov> wimp==mouse
10:48:24 <benny> tuomov: we just need creative people to make gui programs that aren't based on the traditional "wimp" ideas
10:48:35 <HaskNoob> is wimp an acronym?
10:48:44 <tuomov> yep, windows, icons, menus and a pointing device
10:48:49 <ski> window icon mouse pointer
10:48:49 <tuomov> or some variant of that
10:48:54 <HaskNoob> i see
10:49:03 <ski> yes, menu
10:49:13 <tuomov> benny: yep, like Ion :-P
10:49:17 <Saulzar> What's wrong with a gui where you can say, use keyboard 99% of time then you have a mouse around for when you get lost or do something rare?
10:49:24 <benny> tuomov: exactly! or even better wmii! :D
10:49:32 <tuomov> none, but that's not how wimp guis are designed
10:49:44 <joelr1> musasabi: ping
10:49:48 <tuomov> you need to _design_ things for keyboard usage, not just glue on a few keyboard bindings
10:49:51 <joelr1> has anyone built ghc from cvs?
10:49:57 <Korollary> There are some GUI's designed for the sake of being a gui, not for being any help.
10:50:12 <HaskNoob> well, its not that its wrong really, its just there is room for improvement, thats the way i look at guis.. so i'm not religious against them.. they need more time to evolve tho.
10:50:24 <HaskNoob> on the other hand i use them anyway
10:50:31 <HaskNoob> i'm in fluxbox right now
10:50:50 <HaskNoob> using xchat
10:50:52 <HaskNoob> lol
10:51:11 <palomer> ugh
10:51:26 <HaskNoob> but i use the keyboard exclusively almost
10:51:28 <Korollary> I'm on windows xp, staring at irssi running in screen
10:51:28 <Saulzar> Hmm, I use one of these so called "wimp" guis (kde), but I rarely use the mouse, consoles for most things
10:51:36 <palomer> finding a realistic hand position given at least 1 finger position is hard stuff
10:52:09 <HaskNoob> i actually find i like touchpads better than mouses
10:52:11 <tuomov> you can often use the kb almost exclusively, but it isn't particularly convenient
10:52:16 <eivuokko> I think the problem isn't mouse vs keyboard.  Most GUIs aren't really designed from usability pov imo.  Typically there's just ways to do something, without especially making choices visible or easily accessible.
10:52:24 <tuomov> tabbing through dialogs when the active object jumps around it from one side to the other
10:52:26 <Saulzar> There are some applications which just can't be done with purely keyboard though, say... playing 1 0 chess :)
10:52:48 <Korollary> Saulzar: or FPS games
10:53:04 <benny> tuomov: ah, i just thought of a good example, have you used blender?
10:53:24 <tuomov> fps isn't that bad from carpal tunnel syndrome POV as you don't don't need very accurate pointing
10:53:28 <HaskNoob> i agree eivuokko, but i find fluxbox very easily configurable, and it keeps on improving.
10:53:32 <tuomov> it's more natural than hunting for buttons
10:54:00 <HaskNoob> whats fps?
10:54:05 <tuomov> first-person shooters
10:54:06 <Korollary> First Person Shooter
10:54:08 <HaskNoob> oh
10:54:21 <HaskNoob> i like the touchpads on laptops
10:54:44 <HaskNoob> better  than the mouses i used to use on desktops and which are optional on laptops
10:54:49 <Korollary> HaskNoob: Yeah, I got used to it. I don't connect mice any more.
10:54:57 <tuomov> benny: yes, I've used blender and it has a decent although difficult to learn UI, and I agree there are apps that simply can't be used from the keyboard
10:55:06 <tuomov> but most could if they were designed with that in mind
10:55:07 <HaskNoob> yeah, i think when you are used to it, its actually much nicer than a mouse
10:55:34 <Korollary> HaskNoob: proximity to the keyboard is nice. the mouse takes my hand off for clicking on stuff.
10:55:52 <tuomov> I don't like touchpads at all
10:55:58 <tuomov> the nipple is much better
10:56:09 <tuomov> although it wears thumbs quickly
10:56:09 <Korollary> tuomov: some touchpads blow. My work laptop's tp sucks.
10:56:10 <benny> tuomov: well, my point about blender wasn't that the mouse is good for some apps, but that gui's can have a very streamlined keyboard based interface. with blender you work with one hand on the keyboard and one hand on the mouse. all commands are selected with the keyboard. the mouse is only used for manipulation, not for going through menus and clicking buttons and shit
10:56:12 <HaskNoob> you dont have to reach as far.. its always in the same spot... and you can tap it, its like having an extra button, i set up vim so that if i tap the touch pad it goes to normal mode.
10:56:37 <Saulzar> I hate both of them, they drive me crazy - it takes me 10 times as long to click on anything
10:56:41 <HaskNoob> i love that
10:56:47 <tuomov> benny: yeah, but try writing (code, text) and using the mouse at the same time
10:56:59 <HaskNoob> maybe next time i buy a keyboard i should just get one wiht a touch pad
10:57:04 <tuomov> such programs should be designed with keyboard primarily in mind
10:57:26 <benny> tuomov: that's what i'm saying! if the blender gui designers were to make a text editor they wouldn't use the mouse at all!
10:57:36 <tuomov> blender and fps are indeed examples where using both is the best
10:57:40 <benny> tuomov: but they wouldn't use console either!
10:57:42 <Korollary> this discussion won't end until somebody figures out a way to jack a Firewire cable into their necks.
10:58:32 <HaskNoob> lol
10:59:01 <HaskNoob> you know they do have technology now to interface with the brain.. there was a guy with a chip implanted and he could remote control his computer
10:59:22 <benny> tuomov: btw, if you like ion, check out wmii. "Wimp is dead!"
10:59:27 <goron> Is ghc-cvs the GHC6.5 package?
10:59:32 <tuomov> benny: /whois tuomov
10:59:32 <HaskNoob> and they hooked his computer up to the doors and things in the house, so it was like having telepathy.
11:00:08 <Korollary> I predict that in 15 years, solid state implants will be as common as cellphones.
11:00:18 <HaskNoob> scary
11:00:25 <HaskNoob> maybe tho
11:00:31 <tuomov> (and then check the address of the Ion home page if that didn't tell anything)
11:00:40 <HaskNoob> i think we will take more time to get used to that idea.. its more invasive than a cell phone by far.
11:00:53 * benny checks because it didn't tell him anything
11:01:04 <HaskNoob> but eventually
11:01:17 <HaskNoob> probably people will get implants.. i can see that happening, the direction we are heading.
11:01:20 <benny> hm.... interesting
11:02:07 <benny> :O
11:02:20 <Korollary> It makes more sense than the silicon implants some people have been getting heh
11:02:25 <benny> ok... so you don't "like" ion. you *are* ion
11:02:27 <HaskNoob> and then once it starts going, people without an implant might feel disadvantaged, so it creates further pressure
11:02:54 <benny> tuomov: are you also the guy who wrote that article about making frontends to core software?
11:03:01 <tuomov> vis, yes
11:03:10 <HaskNoob> but the company which created the technology is aiming first primarily at quadraplegics and things like this.
11:03:26 <HaskNoob> so they can remote their wheel chairs and so forth.
11:03:32 <HaskNoob> or whatever it is
11:04:03 <tuomov> There's actually some updated information regarding Vis at http://modeemi.fi/~tuomov/b/archives/2005/12/16/T23_40_03/
11:04:07 <HaskNoob> and interface with their computers and so on
11:04:36 <benny> tuomov: ok so you know what you talking about :]
11:06:20 <araujo> mm...
11:06:33 <araujo> benny, you developing a GUI written in Haskell?
11:07:23 <benny> araujo: not really but i am thinking of doing so
11:07:48 <araujo> That'd be something good really.
11:08:06 <benny> araujo: yeah i have a lot of ideas :) but i gotta learn some more haskell first
11:08:07 <araujo> And i think Haskell is pretty much ready for something like that.
11:08:44 <benny> araujo: i think so too, but the only thing missing is a super ub3r optimizing compiler :)
11:08:54 <araujo> I recommend you the R. Bird book
11:09:04 <benny> araujo: which one is that?
11:09:19 <araujo> Introduction to Fucntional Programming 2nd Edt.
11:09:41 <araujo> Oh well... GHC doesn't do that bad....
11:09:52 <benny> ok
11:10:28 <benny> yeah, GHC is awesome, but if you use lots of high level constructs and large amounts of data then i found that you get a lot of memory usage
11:11:02 <benny> anyway, my design for a gui is to be based on vi keys :)
11:11:22 <araujo> It could surely run faster, but ive not found any terrible problem with it so far.
11:11:33 <araujo> I think it has pretty much what it is needed for a nice GUI now.
11:12:04 <araujo> benny, have you seen Ion?
11:12:15 <benny> well, i wrote a raytracer using high level constructs, it runs pretty good, but i think if made a low level c implementation i could get it about 5-10 times faster
11:12:18 <benny> audreyt: yeah
11:13:08 <benny> araujo: yeah
11:13:20 <benny> araujo: but i'm using wmii now which is also cool
11:13:29 <benny> anyway, gotta eat shit bbiab
11:14:07 <araujo> something like that would be nice in Haskell 
11:14:17 <araujo> later
11:14:42 <xerox> programmable/customizable approach works better I think
11:15:10 <araujo> xerox, easy easy :-]
11:17:17 <goron> Igloo: ping
11:17:24 <araujo> House's GUI is pretty nice
11:17:59 <SamB> benny: extra laziness is often a big part of that sort of problem, or so I hear...
11:18:27 <goron> benny: GHC is based on the STG machine, which was designed with efficiency in mind.  
11:18:48 <goron> benny: The use of higher-order functions etc. is *always* "expensive". 
11:19:16 <goron> benny: But in GHC they are relatively inexpensive. (when compared to e.g. Lisp implementations)
11:20:49 <goron> Anyone using the ghc-cvs package (Debian)? I could compile ghc from source... but it takes so long...
11:22:01 <araujo> hah, yes it does
11:22:43 <xinming> goron: Compile ghc is a pain, and compile it on a 256M ram machine is a nightmare... :-)
11:22:55 <xinming> you will always hear the hard disk working... :-)
11:23:31 <goron> xinming: The problem is that libgmp3 can't be installed for some stupid reason.
11:23:53 <goron> xinming: I have compiled ghc multiple times, and on Linux it's pretty simple.
11:24:04 <goron> xinming: (and I have >>256 MB mem)
11:24:23 <xinming> yes, the compile process is simple, but it takes lots of time.
11:24:58 <araujo> Only try to disable support you don't or won't use.... like for example OpenGL , that saves a bit of time.
11:26:57 <xinming> ski: you might make me smile while I was sleeping. :-P Just now, I refer to the <<All about monad>>, It's so understandable. :-)
11:31:34 <ski> xinming : ?
11:31:53 <Korollary> oh man. that can be quoted sooo out of context
11:32:18 <jlouis> < xinming> ski: you might make me smile while I was sleeping. heh
11:32:40 <jlouis> I sense a new #haskell-blah topic
11:32:44 <xinming> I'm happy to understand the Monad, hmm, for now, If I see the example given there, 
11:32:54 <xinming> :-P
11:33:07 <ski> ok, good
11:33:28 <xinming> well, It's a specal thanks to all you here. :-)
11:33:46 <xinming> ok, time for reading.
11:33:47 <xinming> &
11:38:20 <jlouis> major additions to Conjure. adept and SamB has done a lot of work. I have done almost nothing, sadly, but I hope to hack away tomorrow
11:38:58 <jlouis> and by the way, map pred "ubsbmAubsbm/ofu" is an **extremely** cool haskell hacker!
11:39:02 <jlouis> @where conjure
11:39:03 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
11:45:57 <ski> "ubsbmAubsbm/ofu" ?
11:46:26 <astrolabe> @ eval map pred "ubsbmAubsbm/ofu"
11:46:28 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
11:46:28 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
11:46:28 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
11:46:28 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
11:46:28 <lambdabot> fact-snoc fact-update foldoc fortune gazetteer get-shapr ghc google help
11:46:28 <lambdabot> [8 @more lines]
11:46:55 <Lemmih> > map (chr.pred.ord) "ubsbmAubsbm/ofu"
11:46:56 <lambdabot> "taral@taral.net"
11:47:51 <Korollary> > chr.pred.ord 'a'
11:47:52 <lambdabot>   Expecting a function type, but found `Int'
11:47:52 <lambdabot>   Expected type: a -> b
11:47:52 <lambdabot>   Inferred type: Int
11:47:54 <ski> ah .. thought 'pred' was some unspecified predicate
11:48:07 <Korollary> > (chr.pred.ord) 'a'
11:48:08 <lambdabot> '`'
11:49:43 <Pupeno> I compile a .hs to a .o: ghc -c ShSap.hs -o ShSap.o, and then the .o to an executable file: ghc ShSap.o -o ShSap but I get undefined symbols (undefined reference to `__stginit_ZCMain' and `ZCMain_main_closure'), what am I doing wrong ? (yes, I know there are shorter/easier ways to acomplish the same, but I am a 'complicated guy')
11:50:26 <Lemmih> Does ShSap contain the Main module?
11:50:45 <Pupeno> Lemmih: err, thanks. ;)
11:51:01 <Pupeno> I forgot that detail.
12:13:59 <SamB> jlouis: did you get that last doc tweak?
12:14:15 <SamB> > map pred "ubsbmAubsbm/ofu"
12:14:16 <lambdabot> "taral@taral.net"
12:14:55 <SamB> hmm...
12:15:14 * SamB didn't realize that was an email address :-(
12:15:15 <Saulzar> Heh, now his email address is going to turn up in the IRC logs and the spambots will find it :)
12:15:55 <SamB> hopefully the quotation marks will throw them off
12:16:24 <jlouis> SamB: yes and it has been applied too !
12:17:17 <SamB> jlouis: cool
12:17:27 <SamB> did you see how close we are to seeding now?
12:17:36 <jlouis> SamB: yes, indeed!
12:18:01 <jlouis> I'll hack on it the whole day tomorrow
12:18:11 <SamB> is that really a good idea?
12:18:22 <SamB> I usually find that I'm rather spent before the day is through
12:18:50 <jlouis> It'll be on/off
12:18:59 <SamB> hehe
12:19:10 <jlouis> Hack for 45 minutes or something. Go do something else. Repeat
12:19:30 <SamB> what shall we do about InterestTable and IST?
12:20:11 <SamB> personally I think it might be best to scrap them...
12:20:44 <jlouis> That might be a possibility. If it does not fit -> scrap.
12:21:24 <SamB> well, the main reason being that InterestTable is so hard for me and adept to understand, and also rather big...
12:21:36 * jlouis nods
12:21:58 <SamB> it might help that adept has no idea what endgame is ;-)
12:22:10 <jlouis> InterestTable is a very specific data structure for keeping track of the next piece to download
12:22:32 <jlouis> nothing but that. It simply just supports rarest-first retrieval, more or less
12:22:47 <SamB> hmm, were you by any chance basing it off of Bram's client?
12:22:50 <jlouis> endgame is when you are close to having the whole file. You change request tactic there
12:23:00 <SamB> I know what endgame is ;-)
12:23:07 <jlouis> SamB: Yes, it was based on something in Bram's client
12:23:17 <SamB> I suspected as much!
12:23:29 <SamB> because it was not quite as unreadable.
12:23:45 <jlouis> but close enough, heh ;)
12:24:12 <SamB> yeah, much too complicated for us now.
12:24:34 <SamB> Hmm, I also don't understand what Slots are for in FS.Storage
12:25:02 <SamB> oh. did you notice we now have some things working on block granularity?
12:25:22 <jlouis> Slots was meant to be a way to store a piece in a location which was not originally meant for it and move it to the right spot later
12:25:44 <SamB> did you also notice how cool it is for people to be able to collaberate even in your absence ;-)
12:25:52 <SamB> darcs is the best
12:26:05 <xerox> Agreed.
12:26:09 <jlouis> yes, the choice of darcs is magnificient
12:26:34 <SamB> not that anyone would have joined the project if you'd used something else...
12:26:37 <jlouis> and why slots? Because the file system semantics might not be that forgiving
12:27:08 <SamB> I think we'll need some kind of datastructure to keep track of the mapping between pieces and slots
12:27:09 <jlouis> SamB: Openness is the key to an Open Source project
12:27:17 <jlouis> Data.Map ?
12:27:20 <SamB> eh.
12:27:31 <flux__> hmm.. what makes darcs better than, say, svn or cvs, in regards to collaboration?
12:27:52 <SamB> flux__: well, we don't need a server...
12:27:59 <jlouis> flux__: decentralized development. If you want that, darcs,svk,monotone etc rocks
12:28:02 <SamB> I mean, not a specially configured svn server
12:28:11 <SamB> and decentralization too
12:28:30 <SamB> well, thats really the same thing I guess ;-)
12:28:42 <jlouis> and the fact that the entry level for providing patches is extremely low even for beginners. You don't have to play around with patch/diff. You just darcs send/darcs apply
12:28:43 <SamB> though I do hope shapr sets up that repo soon...
12:28:59 <SamB> and the beginners don't need to do the darcs apply
12:29:42 <SamB> me and adept have actually been using repositories unreliably available via HTTP
12:30:13 <jlouis> Heh, I'll have to run again. See you on monday
12:30:20 <jlouis> (or something around there)
12:30:22 <SamB> so we can transfer patches when jlouis is not around ;-)
12:30:23 <flux__> so, decentralization and ease of sending patches?
12:30:32 <SamB> yes
12:31:40 <SamB> also the fact that there is not really any distinction between commiters/non-commiters
12:32:35 <SamB> I mean, sure you *can* set up auto-apply for a GPG keyring or whatever, but still
12:33:46 <SamB> once the patches are in, a patch is as good as what it does ;-)
12:34:33 <flux__> however, the sender can't be sure that the patch will apply to the receiver's tree?
12:34:45 <flux__> hm, well I suppose he can, if the tree is also available
12:34:49 <SamB> flux__: well, there might be a conflict
12:35:05 <SamB> and the tree must be visible or you can't send a patch for it ;-)
12:35:33 <SamB> all the dependencies also have to be sent
12:35:57 <lennart> howdy
12:36:06 <SamB> like, I sent jlouis a bundle of 39 patches earlier today ;-)
12:36:30 <SamB> many of which I had previously pulled from adept's repo
12:36:34 <lennart> @seen ski
12:36:35 <lambdabot> ski is in #haskell, #haskell-overflow and #haskell-blah. Last spoke 48
12:36:35 <lambdabot> minutes and 40 seconds ago.
13:07:29 <JoshTriplett> I'm currently researching Arrows, and I mostly understand the concept; however, I was wondering if anyone could recommend some good explanation of how you connect arrows to everything else, much like with IO you call a series of IO actions "main".
13:09:09 <chucky> joshtriplett: I don't know much about monads myself, but have you tried looking at how yampa uses arrows?
13:09:18 <JoshTriplett> chucky: Somewhat.
13:09:20 <chucky> s/monads/arrows
13:09:58 <JoshTriplett> chucky: I guess I was hoping for a more basic starting point, much like many monad explanations start off with a Maybe example rather than IO.
13:10:37 <chucky> hmm yes that sounds like a good idea
13:23:01 <JoshTriplett> @hoogle embed
13:23:02 <lambdabot> No matches found
13:24:06 <Saulzar> JoshTriplett, Well, functions are arrows
13:28:49 <Saulzar> > (+1) >>> (^2) $ 4
13:28:51 <lambdabot> 25
13:33:28 <franka> Arrows are connected via composition.
13:33:31 <franka> :)
13:33:53 <franka> Oh, that message was from half an hour ago...
13:36:19 <chucky> :)
13:38:28 <xerox> (>>>) = flip (.)
13:43:28 <Cale> hyperion3: you okay?
13:46:45 <basti_> heh
14:14:51 <boro_> puuks
14:15:41 <basti_> what?
14:15:53 <boro_> nothing :))
14:16:36 <basti_> mmmk
14:56:34 <sdjp> Anyone know if GHC will emit vector instructions (e.g. SSE / MMX on X86), or does it only assemble to scaler instructions?  
14:56:48 <Philippa> AFAIK only scalar
14:57:17 <Philippa> I don't know how hard it'd be to make it emit vector instructions for specific vector types - it doesn't have any as of yet though
14:58:00 <Philippa> it'd be hard to vectorise lazy code unless I've missed something though
14:59:25 <sdjp> You'd actually vectorise speculativly - that is, if you can (say) evaluate the next two entries in a list at once by vector instrcutrions, then do that, and use the second one when it's needed, or discard it.
15:00:07 <sdjp> Only useful in certain circumstances though.  Mind you, they're exactly the circumstances where it'd make a noticable performance boost...
15:00:54 <musasabi> it would mostly make sense for unboxed arrays I think
15:01:25 <musasabi> and with those it is quite hard to see that one is doing operations to multiple elements (at least the mutable ones)
15:03:45 <musasabi> maybe PArray comprehensions could be good candidates for such transformations?
15:04:05 <benny> what's a really good monad tutorial for newbies, that's available in one-page html or pdf, for printing?
15:05:51 <greenrd> musasabi, I don't know how much in the way of strictness analysis ghc does, but it seems clear that if e.g. (foldl (+) 0 foo) is demanded, all of foo needs to be demanded, so you could do simple strictness analysis like that.
15:05:52 <musasabi> benny: I would just get the nomaware tutorial as .tar.gz and then run a html->postscript software on it and then just print the resulting postscript files (or concatenate them and print the result)
15:06:30 <benny> musasabi: hm.... sounds like a good idea, but complex for me
15:06:40 * benny gets down on his knees and begs someone to do it for him
15:06:46 <greenrd> musasabi, and then optimise the implementation of foo (assuming foo is a constant, or inlined) so that it returns an array instead of a list
15:06:53 <musasabi> greenrd: except that foo can be e.g. cyclic or contain errors at some position and (+) may not be strict in all casese.
15:06:55 <SamB> sdjp: does GCC even emit MMX instructions without specific (I.E. using the builtin functions as listed in gcc.info) instructions to do so?
15:07:27 <musasabi> the NCG does not generate MMX/SSE.
15:07:27 <greenrd> MMX is obsolete on x86_64 :)
15:07:35 <musasabi> on i386
15:07:58 * SamB has a pre-SSE processor...
15:08:33 <musasabi> GHC on amd64 uses a subset of SSE2
15:09:04 <greenrd> musasabi, OK, so for strict (+) instances, and if foo is cyclic or contains errors, well, you find that out when you try to convert its result to an array, and behave as foldl would do!
15:09:20 <SamB> didn't jethr0 or someone convert the nomaware tutorial to PDF?
15:09:34 <Saulzar> SamB, I think it can, but it will just use one of the components
15:09:37 <SamB> @google AllAboutTheMonads
15:09:38 <lambdabot> No result found.
15:10:02 <Saulzar> There is some work in gcc 4.0 for auto-vectorising loops
15:10:11 <SamB> Saulzar: last I knew it dared not do MMX...
15:10:23 <musasabi> greenrd: so the code would work like "try to deepSeq N first elements of the list and if the list is of that length or less then convert it to an array and perform vector calculations on it"?
15:11:31 <greenrd> no, just convert the list to an array. If it fails or loops infinitely, then foldl would have done the same, so that's OK.
15:11:58 <Philippa> speceval will be too slow
15:12:08 <musasabi> greenrd: no, the foldl could have been a success (at least if the fold is a map-like fold)
15:12:09 <Philippa> the branch'll cost you all you'd gain in vectorising most of the time
15:12:34 <SamB> which is why you always use foldl'...
15:13:22 <musasabi> don't the vector instructions help more for mapping than folding in general?
15:13:44 <Philippa> yep
15:14:09 <Philippa> but really, the times they most help? You'd be able to use a specific vector type anyway
15:14:39 <SamB> or you could at least call out to C ;-)
15:14:44 <musasabi> or a dirty library that someone else(tm) has written
15:14:50 <musasabi> or fortran ;)
15:14:52 <SamB> hmm.
15:15:24 <SamB> you could develop multiple personality disorder, and write it as someone else(tm) yourself...
15:15:56 * SamB wonders if sisal would work too
15:18:27 <greenrd> musasabi, no, I was specifically talking about the case of foldl (+) 0 where (+) is strict
15:18:37 <SamB> hmm...
15:19:52 <musasabi> greenrd: that is quite nontrivial to vectorize
15:21:03 <Philippa> you end up with a quadtree scheme, and a bunch of crap going on every time there's less'n'four children for a non-leaf node
15:21:10 <Philippa> = many stupid branches
15:21:37 <Philippa> probably slower than just doing the additions normally
15:22:52 <musasabi> for something easy to vectorize you could look at: zipWith (+) listA listB
15:23:14 <musasabi> (and even in that case I don't think it is worth the effort usually)
15:23:46 <Saulzar> Lists seem awkward for that kind of thing...
15:23:53 <Philippa> yep
15:24:14 <sdjp> Well, if they're list of Floats or Doubles, and you're doing mostly numeric computations, that would be a big win to vectorise.
15:24:42 <musasabi> and with arrays the read, write and (+) are quite far from each other with the ST cruft.
15:25:07 <musasabi> sdjp: if one is mostly doing performance critical numeric computations why should one use lists?
15:26:01 <sdjp> Because they're infinitly long.  For example, energy levels in an atom or similar.
15:27:15 <musasabi> why not use lists of arrays?
15:27:52 <Saulzar> Arrays are always better for raw number mashing
15:29:10 <sdjp> I don't see how a list of arrays models the real situation - you thinking of manually chunking it into arrays of fixed length or similar?
15:38:54 <Igloo> desrt: ?
16:02:03 <desrt> Igloo; can you add a vendor patch to ghc?
16:02:29 <desrt> Igloo; the current debian ghci (on ubuntu, at least) panicks on startup
16:02:54 <Igloo> I'm not sure what you mean by the first question
16:03:27 <Igloo> The only odd thing I can think of about the Debian ghci on powerpc is that it isn't registerised, but I haven't been able to investigate yet
16:04:25 <desrt> it is registerised.
16:05:59 <Igloo> No it isn't
16:06:09 <desrt> Igloo; ghci 6.4.1 is broken on powerpc (therefore debian's current package is)  i have a patch that i pushed into cvs head a few days ago that fixes it.
16:06:40 <desrt> i've talked to the ubuntu maintainer who said he'd apply the patch to the package but that he'd prefer you did it since currently the ubuntu package only differs from the debian one by a single line
16:06:43 <Igloo> Ah, OK. Have you got a URL handy?
16:06:59 <desrt> not sure.....
16:07:44 <desrt> http://desrt.mcmaster.ca/random/Linker.diff
16:08:15 <desrt> it's this issue: http://cvs.haskell.org/trac/ghc/ticket/439
16:09:24 <Igloo> And also http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=343428 I imagine?
16:09:37 <desrt> ah.  indeed.
16:09:45 <desrt> i'd checked ubuntu for bug reports but not debian :)
16:10:24 <desrt> ah.  only reported 2 days ago even.  this could appear to be responsive!
16:11:01 <Igloo> Thanks for the patch
16:11:17 <desrt> + thanks to you too.
16:11:28 <Igloo> I'm not sure when I'll be able to apply it, between xmltex being broken and being xmas stuff, unfortunately  :-(
16:11:55 <desrt> can i comment on the bug?
16:12:12 <Igloo> Feel free
16:12:25 <desrt> it wasn't a 'may it'.  i seriously don't know how debbugs works :)
16:12:37 <desrt> *may i
16:12:49 <Igloo> Ah  :-)   Mail to 343428@bugs.debian.org
16:12:55 <desrt> thanks
16:13:00 <desrt> can i attach?
16:13:10 <Igloo> I can't remember if that goes to the submitter or if you need to CC them if you want them to see it
16:13:13 <Igloo> Yes
16:13:17 <desrt> elite.
16:16:19 <desrt> k.  email sent.  thanks again.
16:46:30 <Saulzar> Wow, no pain to delete a directory with darcs - very nice :)
17:13:52 <musasabi> The typeclasses as GADT implementation model seems nice
17:17:49 <musasabi> (jhc has very nice docs of it)
17:20:52 <SamB> musasabi: you talkin about GRIN?
17:22:26 <musasabi> SamB: docs/type-classes.txt
17:23:21 <arjanb> musasabi: is that the same as in this paper? http://pauillac.inria.fr/~fpottier/biblio/pottier_abstracts.html#pottier-gauthier-hosc
17:35:12 <musasabi> arjanb: that seems to explore much of the same consepts.
17:35:29 <musasabi> arjanb: except that in system F it seems much more cluttered than in lambdacube.
17:35:30 <arjanb> hmm it seems another implementation model though it also uses GADTs
17:37:50 <musasabi> mmh, ok
17:37:52 <arjanb> a GADT for each class instead of representing types as a GADT
17:38:20 <lennart> howdy
17:39:17 <musasabi> mmh
17:39:28 <musasabi> The JHC way seems simple and clean :-)
17:39:56 <musasabi> Then again it is not new, just easily readable without a PhD
17:40:49 <lennart> why do you need a GADT for a class?  a record with polymorphic fields should work
17:41:44 <tic> howdy lennart
17:41:45 <musasabi> lennart: the point is to avoid record passing.
17:42:22 <musasabi> (I don't know about the paper arjanb linked)
17:43:29 <lennart> hmmmm, ok, i'll have to read it
17:48:03 <arjanb> so using GADTs the GRIN variant of jhc could be embedded in haskell?
17:48:39 <dons> morning lennart
17:49:25 <lennart> morning :)
17:49:45 <dons> @compose pl djinn a -> b -> ((a,b),(b,a))
17:49:45 <lambdabot> f = ap (ap . ((,) .) . (,)) (flip (,))
17:49:48 <dons> a new plugin :)
17:49:58 <dons> pointfree djinn :)
17:51:08 <dons> we already had this fun @pl refactoring plugin, and now we can comppose plugins, the most fun of which is  pl . djinn, I think.
17:51:32 <dons> @. pl djinn a -> a
17:51:32 <lambdabot> f = id
17:51:52 <dons> @. pl djinn a -> b -> (a,b)
17:51:53 <lambdabot> f = (,)
17:52:16 <dons>  @pl doess a pretty good job of simplifiying the (one liner) djinn responses.
17:52:50 <lennart> yeah, i saw @compose.  very nifty!
17:53:26 <lennart> can @pl deal with case?
17:54:05 <musasabi> @compose pl djinn (a -> c) -> (b -> c) -> Either a b -> c
17:54:06 <lambdabot> (line 1, column 39):
17:54:06 <lambdabot> unexpected ">" or "-"
17:54:06 <lambdabot> expecting variable, "(", operator or end of input
17:54:51 <dons> I think @pl can't deal with case, but there's no good reason for that.
17:55:09 <dons> @pl \x y -> let z = x in y z
17:55:10 <lambdabot> flip id
17:55:59 <lennart> dons: except that you can't make case point free :)
17:56:26 <dons> ah. hmm. maybe that's it.
17:58:29 <musasabi> one would need automatic unboxing functions.
17:58:34 <musasabi> (like either for Either)
17:59:31 <lennart> yes
17:59:42 <lennart> elimination functions
18:09:13 <yozora> @djinn (a,Bool,b) -> (Bool, (a, a))
18:09:14 <lambdabot> f (v2, v3, _) =
18:09:14 <lambdabot>   case v3 of
18:09:14 <lambdabot>   False -> (False, (v2, v2))
18:09:14 <lambdabot>   True -> (True, (v2, v2))
18:09:32 <yozora> @compose elite djinn (a,Bool,b) -> (Bool, (a, a))
18:09:33 <lambdabot> f (v2, \/3, _) = Caz3 \/3 0F FALsE -> (pha1$E, (V2, \/2)) 7RUE -> (+RuE, (
18:09:33 <lambdabot> V2, V2))
18:11:06 <musasabi> hmm @compose elite quote might be evil
18:15:05 <ihope> I like Haskell because it's easy to express really big numbers in it.
18:15:19 <ihope> ...And for other reasons too, of course.
18:19:01 <Lemmih> @. elite arr
18:19:02 <lambdabot> Y3h scUrVY D0g...
18:20:47 <ihope> @arr
18:20:47 <lambdabot> Arrr!
18:20:51 <ihope> It works.
18:20:54 <ihope> @help .
18:20:54 <lambdabot>  @. f g xs == g xs >>= f
18:21:15 <Lemmih> @arr >>= elite
18:21:16 <lambdabot> I want me grog!
18:23:43 <ihope> @. elite arr
18:23:43 <lambdabot> T|-|is I5 tH3 3nD phoR You, YoU Gu+TER-Cr4w1in9 (uR!
18:23:59 <ihope> Me likes.
18:27:19 <ihope> > let { compose 0 _ val = val ; compose num fund val = func (compose (num-1) func val) ; set x = x^x ; side x y = xompose y x y ; sides x y = compose x side set y } in sides (sides 2 2) 2
18:27:19 <lambdabot>  Not in scope: `xompose'
18:27:26 <ihope> > let { compose 0 _ val = val ; compose num fund val = func (compose (num-1) func val) ; set x = x^x ; side x y = compose y x y ; sides x y = compose x side set y } in sides (sides 2 2) 2
18:27:26 <lambdabot>  Not in scope: `func'
18:27:35 <ihope> > let { compose 0 _ val = val ; compose num func val = func (compose (num-1) func val) ; set x = x^x ; side x y = compose y x y ; sides x y = compose x side set y } in sides (sides 2 2) 2
18:27:40 <lambdabot> Terminated
18:32:11 <Cale> @. pl djinn (b -> c) -> (a -> b) -> (a -> c)
18:32:12 <lambdabot> f = (.)
18:32:29 <Cale> @. pl djinn (a -> b -> c) -> (a, b) -> c
18:32:30 <lambdabot> f = (`ap` snd) . (. fst)
18:33:10 <Cale> @. pl djinn (a -> c) -> (b -> c) -> (Either a b) -> c
18:33:11 <lambdabot> (line 1, column 39):
18:33:11 <lambdabot> unexpected ">" or "-"
18:33:11 <lambdabot> expecting variable, "(", operator or end of input
18:33:17 <TheHunter> @help pretty
18:33:18 <lambdabot> Echo haskell code in a pretty-printed manner
18:33:23 <Cale> @. djinn (a -> c) -> (b -> c) -> (Either a b) -> c
18:33:24 <lambdabot> compose module failed: No such command: "(a"
18:33:27 <Cale> djinn (a -> c) -> (b -> c) -> (Either a b) -> c
18:33:32 <Cale> @djinn (a -> c) -> (b -> c) -> (Either a b) -> c
18:33:33 <lambdabot> f x1 x2 x3 =
18:33:33 <lambdabot>   case x3 of
18:33:33 <lambdabot>   Left v6 -> x1 v6
18:33:33 <lambdabot>   Right v7 -> x2 v7
18:33:38 <Cale> oh
18:34:12 <dons> to have multi-line stuff work in @pl, we'd either have to tweak @pl, or flatten @djinn with explicit layout.
18:34:12 <TheHunter>  @pl doesn't like that, but I intend on throwing away the parsec-parser anyway.
18:34:40 <TheHunter> *intend to throw
18:35:11 <TheHunter> @pretty f x1 x2 x3 = case x3 of { Left v6 -> x1 v6; Right v7 -> x2 v7 }
18:35:12 <lambdabot>  f x1 x2 x3  = case x3 of
18:35:12 <lambdabot>        Left v6 -> x1 v6
18:35:12 <lambdabot>        Right v7 -> x2 v7
18:35:36 <TheHunter> i guess i will just have to have a look at @pretty then :)
18:35:55 <ihope> @pretty let { compose 0 _ val = val ; compose num func val = func (compose (num-1) func val) ; set x = x^x ; side x y = compose y x y ; sides x y = compose x side set y } in sides (sides 2 2) 2
18:35:55 <lambdabot>  i = let compose 0 _ val = val
18:35:55 <lambdabot>    compose num func val = func (compose (num - 1) func val)
18:35:55 <lambdabot>    set x = x ^ x
18:35:55 <lambdabot>    side x y = compose y x y
18:35:55 <lambdabot>    sides x y = compose x side set y
18:35:57 <lambdabot>    in sides (sides 2 2) 2
18:36:20 <musasabi> @. pretty djinn a -> a
18:36:20 <lambdabot>  f x1 = x1
18:36:49 <musasabi> @. pl pretty djinn a -> a
18:36:50 <lambdabot> "Parse error" at column 9
18:43:15 <sdjp> if I have a function f :: a -> b is there a way I can transform that with a higher order function to give something of type a -> [b] (i.e. apply f to the argument, and then pack it into a list)
18:43:27 <dons> @. pl . pretty djinn a -> a
18:43:28 <lambdabot> f = id
18:43:44 <ihope> Just compose it with \x -> [x].
18:44:14 <arjanb> @djinn (a -> b) -> a -> [b]
18:44:15 <lambdabot> -- f cannot be realized.
18:44:37 <ihope> ((\x -> [x]).)
18:46:15 <ihope> @pretty ((\x -> [x]).)
18:46:16 <lambdabot> "Parse error" at column 15
18:46:25 <ihope> Eh.
18:46:34 <ihope> @pretty (undefined.)
18:46:35 <lambdabot> "Parse error" at column 13
18:46:37 <sdjp> Ah! that's it.  Though there was some nice way, just being a little noob-ish here.
18:46:54 <ihope> @pretty (.) (\x -> [x])
18:46:55 <lambdabot> "Parse error" at column 16
18:46:58 <ihope> !!
18:47:28 <dons> pretty takes only decls.
18:47:39 <dons> not exprs.
18:47:39 <ihope> Ah
18:47:41 <dons> add a `let'
18:47:52 <ihope> ...Where?
18:48:18 <ihope> @ let {} in (.) (\x -> [x])
18:48:19 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
18:48:19 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
18:48:19 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
18:48:19 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
18:48:19 <lambdabot> fact-snoc fact-update foldoc fortune gazetteer get-shapr ghc google help
18:48:21 <lambdabot> [8 @more lines]
18:48:27 <ihope> @pretty let {} in (.) (\x -> [x])
18:48:27 <lambdabot>  i = let in (.) (\ x -> [x])
18:49:17 <ihope> @djinn a -> b
18:49:17 <lambdabot> -- f cannot be realized.
18:49:19 <pediddle> ((:[]) .)
18:49:45 <ihope> Ook! Points-freeness!
18:49:55 <ihope> @pretty let in ((:[]) .)
18:49:56 <lambdabot>  i = let in ((: []) .)
18:50:28 <pediddle> what is pretty supposed to do? looks the same
18:50:35 <ihope> It added a space.
18:50:47 <pediddle> oh ok :)
18:50:52 <pediddle> yes, much prettier now
18:51:16 <ihope> @pretty let omgwtfbbq = lol in roflmao
18:51:17 <lambdabot>  i = let omgwtfbbq = lol in roflmao
18:51:18 <Cale> @pretty callCC x1 x2 = x1 (\ c15 _ -> x2 c15) (\ c11 -> x2 c11)
18:51:19 <lambdabot>  callCC x1 x2 = x1 (\ c15 _ -> x2 c15) (\ c11 -> x2 c11)
18:52:36 <ihope> @pretty arr
18:52:36 <lambdabot> "Parse error" at column 4
18:52:57 <ihope> @. (. elite elite) arr
18:52:57 <lambdabot> compose module failed: No such command: "(."
18:53:03 <ihope> I knew that wouldn't work.
18:53:07 <ihope> @. elite elite arr
18:53:08 <lambdabot> 4RR
18:53:15 <ihope> Heh
18:53:22 <ihope> @. . elite elite arr
18:53:22 <lambdabot> compose module failed: No such command: "31i73"
18:53:30 <ihope> Nice!
18:53:43 <ihope> @. ( . elite elite ) arr
18:53:43 <lambdabot> compose module failed: No such command: "("
18:53:47 <ihope> Hmm.
18:55:48 <Lemmih> A small language for composing plugins would be nice.
18:56:26 <ihope> (plugin . plugin) plugin plugin (plugin plugin)
18:56:32 <dons> @. elite . elite . elite  arr
18:56:33 <lambdabot> compose module failed: No such command: ""
18:56:41 <TheHunter> And I think plugins shouldn't communicate via strings.
18:56:53 <ihope> How should they communicate?
18:57:12 <TheHunter> using haskell datatypes, which can be converted into each other when needed.
18:57:13 <ihope> Bool, Just (), Either () ()?
18:57:39 <ihope> Haskell datatypes... what are these plugins for?
18:57:46 <Lemmih> So the plugins should be typed?
18:58:07 <TheHunter> I'm thinking dynamically typed, but we could also consider statically.
18:58:08 <Lemmih> '@pretty' :: HsSyn -> Doc?
18:58:10 <ihope> Typed, punched or writted, I don't care.
18:58:15 <ihope> *written
18:58:47 <TheHunter> '@pl' :: HsSyn -> HsSyn
18:58:49 <dons>  @. elite . elite arr ""
18:58:57 <ihope> @help pl
18:58:57 <lambdabot>  @pointless <expr> - play with pointfree code
18:59:11 <ihope> @pl ap id id
18:59:11 <lambdabot> join id
18:59:31 <ihope> @type join
18:59:32 <lambdabot> Not in scope: `join'
18:59:47 <Lemmih> That would be very neat. So, who's gonna hack it?
18:59:50 <dons> @. elite . elite arr ""
18:59:50 <lambdabot> 347 /\/\4GG07y |-|aRd7acK, y3 uNKEmP+, JeNnY p|-|reQuentiN', z0N OPH a
18:59:50 <lambdabot> 9Un.
19:00:13 <dons> yes, a typed framework would be very nice. not too hard (I think).
19:00:19 <ihope> @. elite bot
19:00:19 <lambdabot> compose module failed: No such command: "bot"
19:00:22 <ihope> @bot
19:00:22 <lambdabot> :)
19:00:25 <dons> they'd need a Doc or Pretty instance to render.
19:00:28 <yozora> @. elite yow
19:00:28 <TheHunter> The basic idea being that I don't need to duplicate the @pretty code when writing the new @pl parser.
19:00:29 <lambdabot> I'm A1SO PR3-p0uReD pRE-medI+4T3d aND PR3-Rap|-|4E|It3!!
19:00:46 <ihope> @yow
19:00:46 <lambdabot> Nobody brings small problems into a laundromat.
19:01:03 <ihope> @. elite . elite . elite . elite . elite yow
19:01:03 <lambdabot> u|-|-0|-|!! i 7|-|INx x3N iS0Rs 0\/3R-Du3 0n |-|i5 r.\/. P4y/\/\3N75 4nD |
19:01:03 <lambdabot> -|3'5 |-|4\/in9 4 n3R\/0U$ 8r34Xd0\/\/n +00!! H4 |-|4.
19:01:16 <ihope> Probably doesn't do too much more.
19:01:20 <yozora> this compose command is awesome
19:01:21 <dons> regarding the compose language. we could either embed a little lambda calculuse, or I'mm thinking of using eval in some way.
19:01:36 <ihope> Unlambda!
19:01:45 <ihope> @elite testing
19:01:46 <lambdabot> 7ESTin9
19:01:51 <ihope> @elite testing
19:01:51 <lambdabot> 73s7Ing
19:02:18 <ihope> > y r u ignrng me/
19:02:19 <lambdabot>  parse error on input `}'
19:02:28 <ihope> > lol
19:02:29 <lambdabot>  Not in scope: `lol'
19:03:05 <ihope> It's not responding to the /msg.
19:04:47 <Lemmih> You must be registered to send PMs.
19:06:00 <ihope> I am.
19:09:14 <TheHunter> using eval would be cool, but it would force us to either use unsafePerformIO or to make the compose language monadic.
19:14:10 <Lemmih> Many (most?) of the commands aren't pure.
19:16:22 <TheHunter> but shouldn't the compose language be impure?
19:18:40 <Di-Fosfor> Good evening all.. quick question: I'm looking for a charToInt function; suggestions?
19:18:57 <Cale> @index digitToInt
19:18:58 <lambdabot> Data.Char
19:19:08 <Cale> > digitToInt '5'
19:19:09 <lambdabot> 5
19:19:15 <Cale> like that?
19:19:32 <Cale> or perhaps you're looking for ord
19:19:35 <Cale> @index ord
19:19:36 <lambdabot> Data.Char
19:19:41 <Cale> > ord '5'
19:19:42 <lambdabot> 53
19:19:44 <Cale> > ord 'A'
19:19:46 <lambdabot> 65
19:19:47 <Di-Fosfor> >Ah yes
19:19:50 <Di-Fosfor> ord it is
19:20:00 <Di-Fosfor> import Data.Char then I suppose?
19:20:03 <Cale> yep
19:20:09 <Di-Fosfor> thanks a bunch :)
19:20:12 <Cale> no problem
19:20:20 <Cale> @hoogle Char -> Int
19:20:21 <lambdabot> Data.Char.digitToInt :: Char -> Int
19:20:21 <lambdabot> Data.Char.ord :: Char -> Int
19:20:21 <lambdabot> Text.Regex.Posix.regExtended :: Int
19:20:48 <Cale> hehe, it recommends similarly to me
19:21:06 <Cale> I have no idea why regExtended is in there though
19:21:38 <Di-Fosfor> that lambdabot is pretty handy
19:26:56 <TheHunter> > fromEnum 'A'
19:26:58 <lambdabot> 65
19:28:40 <Cale> ah, that's a decent way too
19:30:08 <Di-Fosfor> ah.. that won't require import
19:41:48 <Di-Fosfor> @hoogle Int -> Char
19:41:49 <lambdabot> Data.Char.intToDigit :: Int -> Char
19:41:49 <lambdabot> Data.Char.chr :: Int -> Char
19:41:49 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
19:52:27 <soysauce> @pl \(x, y) -> (x+1, y+1)
19:52:28 <lambdabot> (1 +) *** (1 +)
19:52:36 <soysauce> @type (***)
19:52:37 <lambdabot> Not in scope: `***'
19:52:43 <soysauce> @type (Control.Arrow.***)
19:52:44 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
19:52:44 <lambdabot> (Control.Arrow.Arrow a) =>
19:52:44 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
19:53:57 <soysauce> @pl \a (x, y) -> (a!!x, a!!y)
19:53:58 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (!!)) (!!)
19:54:19 <soysauce> hm
19:54:24 <soysauce> @pl \(x, y) -> (f x, f y)
19:54:25 <lambdabot> f *** f
20:09:41 <Cale> @type \f -> f *** f *** f *** f
20:09:42 <lambdabot> Not in scope: `***'
20:09:42 <lambdabot>  
20:09:42 <lambdabot> <interactive>:1:14: Not in scope: `***'
20:10:00 <Cale> @type \f -> f Control.Arrow.*** f Control.Arrow.*** f Control.Arrow.*** f
20:10:01 <lambdabot> forall (a :: * -> * -> *) b c.
20:10:01 <lambdabot> (Control.Arrow.Arrow a) =>
20:10:01 <lambdabot> a b c -> a (b, (b, (b, b))) (c, (c, (c, c)))
20:10:13 <Cale> heh, qualified infix operators are ugly
20:14:06 <soysauce> yeah
20:14:29 <soysauce> can you use let with @type and @pl?
20:14:44 <Cale> yep
20:15:01 <Cale> Perhaps let should be extended to be able to do local imports
20:15:06 <soysauce> @type let foo xs = head xs in foo [0,1,2]
20:15:06 <lambdabot> forall a. (Num a) => a
20:15:35 <Cale> oh, I suppose it can
20:15:55 <soysauce> @type let *** = Control.Array.*** in \f -> f *** f *** f *** f
20:15:56 <lambdabot> parse error on input `***'
20:16:00 <Cale> @type let (***) = Control.Arrow.(***) in \f -> f *** f *** f *** f
20:16:01 <lambdabot> Couldn't find qualified module.
20:16:01 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
20:16:01 <lambdabot> \\)?
20:16:01 <soysauce> @type let (***) = Control.Array.*** in \f -> f *** f *** f *** f
20:16:02 <lambdabot> parse error on input `Control.Array.***'
20:16:12 <Cale> @type let (***) = (Control.Arrow.***) in \f -> f *** f *** f *** f
20:16:13 <soysauce> hmm
20:16:13 <lambdabot> forall (a :: * -> * -> *) b c.
20:16:13 <lambdabot> (Control.Arrow.Arrow a) =>
20:16:13 <lambdabot> a b c -> a (((b, b), b), b) (((c, c), c), c)
20:16:19 <Cale> Arrow, not Array
20:16:21 <soysauce> ah, I thought that looked strange
20:16:26 <soysauce> er, right
20:16:37 <soysauce> lack of sleep and so forth.
20:17:21 * soysauce has 1 assignment left to finish in order to end the semester and 0 motivation
20:17:29 <Cale> which assignment
20:17:30 <Cale> ?
20:17:44 <soysauce> this stupid assignment that I have to write in Haskell which is driving me nuts.
20:17:53 <Cale> What's it have to do?
20:18:24 <soysauce> minimum distance between all nodes in a graph (Floyd-Warshall) and maximum flow through the graph (Ford-Fulkerson)
20:18:28 <soysauce> the first part is done
20:18:32 <soysauce> the second I have coded in C
20:18:46 <yozora> @. type djinn (a,b)->(b,a)
20:18:47 <lambdabot> parse error on input `='
20:19:03 <yozora> @djinn (a,b)->(b,a)
20:19:04 <lambdabot> f (v2, v3) = (v3, v2)
20:19:15 <soysauce> shouldn't type (djinn x) == x?
20:19:35 <yozora> it tries to parse the entire definition
20:19:42 <yozora> rather than the RHS, i guess
20:19:49 <Cale> soysauce: you wouldn't get many marks using Data.Graph.Inductive.Query.MaxFlow
20:20:04 <soysauce> Cale - no, probably not. I already thought about that.
20:25:31 <soysauce> @eval let f xs = [(x, y) | x <- xs, y <- xs] in f [0,1,2]
20:25:32 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:37:43 <Cale> liftM2 (,) [0,1,2] [0,1,2]
20:37:45 <Cale> > liftM2 (,) [0,1,2] [0,1,2]
20:37:46 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:38:11 <Cale> @pl \x -> liftM2 (,) x x
20:38:11 <lambdabot> join (liftM2 (,))
20:39:24 <Cale> > join (liftM2 (,)) [0,1,2]
20:39:25 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:39:47 <Cale> two different monads :)
20:42:31 <Cale> > (+3) >>= (*) $ 2
20:42:32 <lambdabot> 10
20:50:50 <Cale> > (join . liftM2) (*) (+3) 5
20:50:52 <lambdabot> 64
20:51:09 <yozora> @type 10e6
20:51:10 <lambdabot> forall t. (Fractional t) => t
20:51:20 <yozora> @type 10e6::Int
20:51:21 <lambdabot>   No instance for (Fractional Int)
20:51:21 <lambdabot>   arising from the literal `1.0e7' at <interactive>:1:0-3
20:51:34 <Cale> er, wha
20:51:43 <Cale> oh
20:51:47 <Cale> I see what it did
20:52:16 <Cale> (rewrote the literal in scientific notation)
20:53:46 <Cale> @pl \f g x -> f (g x) (g (g x)) (g (g (g x)))
20:53:47 <lambdabot> (`ap` ap (.) (join (.))) . (ap .) . (`ap` join (.)) . liftM2
20:54:50 <gzl> Cale: hi, can I privmsg you?
20:54:53 <Cale> yeah
21:55:01 <stepcut> is there any easy way to create instances of Storable for new data types I create ? Using TH perhaps ?
21:56:43 <stepcut> the SerTH seems to be very bent on dealing with streams of data, not just quickly converting from a -> Ptr () and back again
21:57:41 <stepcut> or more specifically, it seems to be designed for serializing/deserializing one big thing, whereas I want to serialize/deserialize thousands of different values
21:58:35 <rep> http://people.freebsd.org/~ssouhlal/stuff/my_bed.jpg
21:59:02 <stepcut> mmm
22:06:19 <sethk> stepcut, I hae needs for this also, so if you come up with something, don't keep it a secret
22:09:49 <stepcut> :p
22:20:42 <Saulzar_> Hmm, I wonder why darcs requires my password 3 times to access a repo over ssh
22:21:14 <sethk> Saulzar_, probably the motivation is to avoid holding on to even a hashed version of the password
22:21:44 <stepcut> Saulzar_: probably because you did not setup your ssh keys :p
22:21:57 <stepcut> + ssh-agent
22:22:10 <stepcut> but, still, I wonder the same thing...
22:23:09 <stepcut> my guess is the command is made up of three smaller primitives that each need to access the repository, and they don't share the session
22:23:13 <Pupeno> I believe because it make various accesses, one to find out what is there, on the other side, to know what to show as possible aditions, then another to commit the additions you choose.
22:23:16 <Saulzar_> Hmm..
22:24:09 <Pupeno> stepcut: probable the primitives to access a repository are called from three different steps to do different things, makes sense, ssh-agent is handy.
22:40:49 <Saulzar> No more passwords, thanks :)
22:50:55 <MarcWeber> Good morning! I get this error: dist\build\./PointerPrim.o: getModificationTime: does not exist (No such file or directory)
22:51:15 <MarcWeber> When running my runhaskell Setup.hs build command.
22:51:47 <MarcWeber> Is this due to \./ in path above? getModificationTime isn't used in any file of this package. So I think it must belong to cabal..
22:54:11 <jimapple> @seen lennart
22:54:12 <lambdabot> I saw lennart leaving #haskell 4 hours, 52 minutes and 13 seconds ago.
23:06:19 <palomer> damnit
23:06:29 <palomer> I wish I could see the colour wheel with RGB values
23:06:59 <MarcWeber> Perhaps I'm wrong as ghc is beeing called (ghc -v output http://www.rafb.net/paste/results/IEvS4m87.html
23:07:12 <MarcWeber> The error line is 115
23:07:26 <MarcWeber> palomer: What's your problem? No color display?
23:08:56 <palomer> I need to pick 12 highly distinguishable colours
23:09:00 <palomer> then, I need to find their RGB values
23:11:06 <MarcWeber> palomer: Perhaps try using 4 bit palette? Or pie charts from spreadsheed programs they should have solved this problem, too.. Just use 12 data rows and make a chart and pick up the color values..
23:11:21 <palomer> oooh, that's a good idea
23:12:15 <MarcWeber> palomer: Do you have any idea what's wrong concerning my compilation problem? I don't have any ideas left.
23:13:21 <palomer> oh my, I've never compiled ghc before
23:13:39 <palomer> but it seems it's looking for a file that doesn't exist
23:14:00 <palomer> check to see if PointerPrim.o is in another directory
23:14:16 <MarcWeber> I'm not compiling ghc.. I'm trying to compile hdirect.. to say my cabal version to get rid of link errors
23:15:01 <MarcWeber> PointerPrim is a hs file. I've grepped the whole directory but there is no getModificationDate at all. That's confusing me.
23:17:46 <MarcWeber> palomer: You might also consider using any pixel graphic program to create a gif (having a palette with 12 colors).. Should use distinct colors as well..
23:20:52 <palomer> I can choose my pallette?
23:21:14 <palomer> getModificationDate is probably a function which is looking for PointerPrim
23:21:30 <palomer> and someone most probably forgot to include the compilation directives for PointerPrim
23:22:43 <MarcWeber> It depends on the program you use.. You can also let the program create the palette using different algorithms...
23:24:32 <palomer> oh, I'll use anything
23:24:40 <palomer> just as long as I can get the palette
23:25:35 <palomer> how do I do it with, say...the gimp?
23:26:04 <MarcWeber> Wait..
23:30:19 * musasabi wonders why people do not use tags, would make darcs partial gets much more faster
23:32:34 <MarcWeber> palomer: Image/Mode/Indexed.. The problem is that I would try using optimum palette (or the first colors from the default palette).. If using optimum you should use a image containg much colors (such as a gradient..) But that depends wether you just want different colors (then use a HSV gradient with saturation=255) or wether you also want to have dark/light colors.. (eg black white)
23:40:48 <palomer> ok, now how do I get the colours?
23:41:55 <palomer> how do I setup a gradient?
23:42:13 <MarcWeber> Which do you want to try? Chart, palette? In either case just make a screen copy (you can use gimp) and then use the ..
23:42:13 <palomer> and, er, I can't have anything resembling white or black in the palette
23:42:36 <palomer> it would be nice to draw the palette onto the image
23:42:44 <palomer> then I could extract the rgb values
23:42:51 <palomer> (or is there an easier way to extract the rgb values?)
23:43:09 <palomer> (I really just need the rgb values:O!)
23:43:23 <MarcWeber> Then got to the color dialog and use the small vertical rectangle representing all colors..
23:43:56 <palomer> there are  way too many colours
23:44:09 <Saulzar> You could lookup the formula for HSV -> RGB
23:44:26 <palomer> oh, HSV is fine
23:44:29 <Saulzar> Then chose 12 hue values
23:44:36 <palomer> of the same colour?
23:44:45 <Saulzar> No, hue values will be different colours
23:44:55 <palomer> easily distinguishable?
23:44:57 <Saulzar> But not black, or white - and equally "bright"
23:44:58 <Saulzar> Yes
23:45:10 <palomer> oh nice
23:45:16 <palomer> I'll have 12 bright and 12 dark ones
23:45:33 <palomer> will it be a pretty palette?
23:45:49 <Cale> should look nice :)
23:45:51 <Saulzar> I believe it is used in image programs 
23:46:43 <Saulzar> HSV gives you a distribution which is intuitive to humans, but no good for anything else :)
23:46:50 <palomer> oh wait, java doesn't support HSV
23:46:59 <Saulzar> You don't need to...
23:47:11 <palomer> yeah, I'll have to use a formula
23:47:36 <palomer> man, my graphics course was supposed to teach me about colour
23:47:42 <palomer> instead, I learned about monitor calibration
23:47:48 <Cale> HSV is at least as natural as RGB :)
23:47:54 <Saulzar> Hehe
23:49:15 <Cale> Really, the idea that colour can be represented by so little data at all has to do with the fact that human vision has essentially 3 (perhaps 4) components.
23:49:16 <Saulzar> Graphics course here corresponds to "Hardcoding in C with OpenGL"
23:49:59 <Saulzar> Well there's only one physical component to colour, right? :P
23:50:15 <Cale> Well, you have spectra
23:50:18 <Saulzar> True
23:51:24 <Cale> Magenta doesn't correspond to any particular wavelength :)
23:51:47 <palomer> some of us have 4?
23:52:46 <Saulzar> Some definately have < 2, those who chose brown and red colour schemes for vim.
23:52:56 <Cale> hehe
23:53:24 <palomer> I rather hardcode in C than learn about monitor calibration
23:56:55 <palomer> the teacher didn't know that third degree polynomials were solvable in terms of radicals
23:57:03 <palomer> he's like "why don't we learn this stuff in school"
23:57:38 <Cale> heh
23:58:13 <Cale> Though you'd be better off with Newton's method as far as numerical stability is concerned.
23:58:50 <Cale> (assuming that you're looking for an approximation)
