00:00:06 <ski> Cont (a, Cont b)  ~=  a -> b
00:00:28 <ski> function decomposes into continuation accepting argument and return continuation
00:00:37 <Cale> I sort of disagree with allowing functions with side effects, since it's so well understood how to capture side effects like IO using monads.
00:00:37 <Taral> that even works with not
00:00:49 <Taral> ~(a (*) ~b) = ~a * b = a -> b
00:00:54 <ski> Cale : i don't think this requires side-effects
00:01:19 <Taral> Okay, so you have a useful not operation. Yay.
00:01:20 <Cale> ski: I'm pretty sure that ~a is quite boring otherwise.
00:01:20 <Taral> :)
00:01:29 <ski> ('~a (+) b' for middle formula, using my notation)
00:01:38 <Taral> eh? oh, yes.
00:01:39 <ski> Cale : i don't think so
00:01:44 <Cale> no?
00:02:00 <Cale> Okay, so show me an interesting value of type ~Char
00:02:14 <ski> there are no global such, i think
00:02:27 <ski> (locally, otoh)
00:02:27 <Cale> I don't think there are any such values.
00:02:32 <ski> right
00:02:36 <Taral> I think Cale is right. You can define negation (and thus mult. disj.) but it's not useful.
00:02:46 <Taral> CLL is all you really need.
00:02:54 <ski> think of  'Not (Not a) -> a'
00:03:05 <ski> or, say
00:03:07 <Cale> You can't ever make use of the fact that it's continuing unless you have side effects
00:03:14 <ski> think of  '(Not a -> Bot) -> a'
00:03:30 <ski> with this, you can locally, construct a value of type 'Not a'
00:03:46 <ski> foo :: (Not a -> Bot) -> a
00:03:53 <ski> foo = ...
00:04:06 <ski> bar :: X -> Char
00:04:06 <Pupeno> Cale: Thank you!
00:04:10 <Cale> What's Bot?
00:04:18 <Cale> (as a data declaration)
00:04:26 <Taral> non-terminating computation, a function that does not return a value
00:04:29 <ski> bar x = foo (\(nc :: Not Char) -> ...)
00:04:38 <Cale> Taral: as a value, that's what it is
00:04:43 <ski> 'Bot' is multiplicative false
00:04:55 <Cale> ski: as a type, what is it?
00:05:08 <Cale> (not as a logical construction)
00:05:16 <Taral> ski: (Not a -> Bot) -> a = a -> a
00:05:42 <ski> Taral : yes, 'foo' should be provable in CLL
00:05:51 <Taral> but it's not *useful*
00:05:58 <Cale> CLL?
00:06:04 <ski> 'nc' above is a local value of type 'Not Char'
00:06:09 <ski> CLL = Classical Linear Logic
00:06:13 <Taral> as opposed to ILL
00:06:17 <Taral> which I'm advocating here
00:06:18 <ski> ILL = Intuitionistic Linear Logic
00:06:18 <Cale> okay
00:06:26 <Taral> ILL doesn't have mult. disj. or the ? modal
00:06:35 <ski> Cale : so, there you have your value of type 'Not Char'
00:06:56 <ski> Cale : it's not global, granted
00:07:02 <Taral> you can do contortions to construct Not a forms, but they're still not useful.
00:07:04 <Cale> ski: where's a proof of foo?
00:07:15 <Taral> Now, if you have a side-effecting system, then it becomes useful.
00:07:30 <ski> 'foo' is basically double negation elimination, which is doable here
00:07:48 <Cale> what are foo's operational semantics?
00:08:07 <ski> Cale : proof depends on in which form you want it .. i can construct it in sequent calculus .. but this expression-oriented syntax is still a bit hazy
00:08:11 <Taral> foo x = callCC (\c -> x c)
00:08:16 <ski> almost
00:08:16 <Cale> aha!
00:08:23 <Cale> callCC isn't a function
00:08:26 <ski> calCC duplicates it's current continuation
00:08:33 <ski> that means callCC is not pure
00:08:40 <Taral> callCC :: (Not a -> a) -> a
00:08:48 <ski> right
00:08:56 <ski> 'foo' does not duplicate
00:09:05 <Cale> that, or you'll never have a value to apply it to
00:09:13 <Taral> where does 'foo' get its 'Not a' from then?
00:09:14 <ski> but, operational semantics is quite similar to 'callCC', yes
00:09:20 <soysauce> how can one generate the string "\0"?
00:09:25 <soysauce> > "\0"
00:09:26 <lambdabot> "\NUL"
00:09:31 <soysauce> > "\\0"
00:09:33 <lambdabot> "\\0"
00:09:34 <ski> Taral : it captures it's current continuation
00:09:37 <Cale> callCC's domain is empty as far as I'm concerned.
00:09:39 <ski> and packages that as a value
00:09:40 <Taral> ski: Oh, I see. Your 'foo' is a pure variant on callCC
00:09:46 <ski> yes
00:09:51 <Taral> still not useful.
00:10:12 <Taral> except in a side-effecting system like a monad.
00:10:20 <ski> it only reifies the continuation, i.e. lifts it up from implicit to explicit .. it does not leave it as implicit continuation
00:10:22 <Taral> where one might store the continuation and fetch it later.
00:10:43 <ski> Taral : many uses of continuations are linear .. e.g. coroutines
00:11:07 <Cale> Anyway, I was saying that negation is useless without side effects, and I haven't yet seen any code which shows otherwise :)
00:11:13 <Taral> Isn't it possible to rewrite pure coroutines to eliminate continuations?
00:11:43 <Taral> I don't think languages should permit undelimited continuations anyway.
00:12:02 <Taral> > () :: 1
00:12:03 <lambdabot> Couldn't match `GHC.Base.Unit' against `()'
00:12:25 <ski> i think it's not so disruptive, if they are linear
00:12:42 <Taral> If they're linear, they can be delimited.
00:12:58 <ski> delimited as in shift/reset ?
00:13:01 <Taral> yes
00:13:09 <Cale> I don't like shift/reset either :)
00:13:20 <ski> they are effectful, surely
00:13:29 <Taral> shift/reset are nice because they're static.
00:13:43 <Taral> they preserve purity, which is a very nice feature
00:13:54 <ski> one can reflect every representable monad as a side-effect with help of shift/reset
00:13:56 <Cale> Um, I would tend to disagree with that
00:13:57 <Taral> if you *have* to have continuations, shift/reset is a lot less risky than callCC or 'foo'.
00:14:10 <Cale> what's the type of shift?
00:14:13 <ski> 'preserve purity' huh ?
00:14:19 <Taral> that's what I understood of it.
00:14:24 <Taral> reset (...) is pure
00:14:32 <Cale> what's it's type?
00:14:41 <Taral> the stuff inside is impure, but transformable.
00:14:42 <Cale> its*
00:14:55 <Taral> type of what?
00:14:59 <Cale> reset
00:15:05 <Taral> reset :: a -> a
00:15:14 <Cale> then it's id :)
00:15:15 <Cale> hehe
00:15:18 <ski> shift :: ((a -> b) -> c) -> a / b --> c
00:15:18 <ski> iirc
00:15:19 <Taral> no, no
00:15:23 <ski> something like that
00:15:27 <Taral> shift/reset are not functional
00:15:29 <Taral> they are syntactic
00:15:39 <ski> they are not pure
00:15:39 <Cale> hence the laugh :)
00:15:47 <Taral> I never said they were pure.
00:15:51 <Taral> I said they preserved purity.
00:16:09 <Cale> Surely they don't preserve the purity of a language which one adds them to :)
00:16:21 * ski took that to mean that, if subexpressions are pure, then whole expressions are also pure
00:16:24 <Taral> Unlike callCC, they contain the impurity to a specific lexical area.
00:16:33 <Cale> okay
00:16:33 <Taral> Oh, no, I didn't mean that.
00:16:50 <ski> if shift/reset adds impurity, even if subexprs are pure, then they don't preserve purity, in this sense at least
00:17:00 <ski> ok
00:17:14 <ski> Taral : maybe you meant something more alike effect-masking ?
00:17:14 <Taral> It's clear that subexpressions of reset are not pure.
00:17:22 <Taral> effect-masking is a good way to put it.
00:17:37 <C-Keen> re
00:17:42 <Taral> they're kind of like the ST monad... they don't have persistent side-effects.
00:17:50 <Cale> okay
00:18:01 <Cale> Why not just use a monad then?
00:18:12 <ski> one could
00:18:17 <Taral> you can use monads instead
00:18:20 <Cale> Then one probably should :)
00:18:27 <Taral> just like you can use monads to implement callCC.
00:18:33 <Cale> right
00:18:49 <Taral> I think someone did write a shift/reset monad.
00:18:52 <Cale> we should try to preserve as many properties of (->) as possible
00:19:02 <Taral> so why are we talking about (Not a)?
00:19:06 <ski> one point might be that shift/reset based impl. of monads can be quite efficient
00:19:27 <Cale> hm?
00:19:34 <ski> i.e. only executing '(>>=)' when reifying
00:19:45 <Taral> Why bother even considering adding (Not a) to the language we were discussing?
00:19:56 <Taral> It seems like we're all in agreement that continuations are not a good thing.
00:19:59 <Cale> Not a will occur in any language with an empty type
00:20:12 <ski> i.e. e.g in an exception monad, one don't have to interpret the result to see if it's exception, and in that case, reraise every time, until we come to a handler
00:20:13 <Taral> Does Haskell have an empty type?
00:20:32 <dcoutts> ()
00:20:35 <ski> can be done, if you ignore '_|_'
00:20:37 <Taral> that's not empty
00:20:42 <dons> data A
00:20:44 <Cale> data Void
00:20:44 <dons> :)
00:20:49 <Taral> hm, okay.
00:20:51 <Taral> that's empty
00:20:53 <Cale> that still has _|_
00:21:02 <dons> sneaky undefined.
00:21:08 <ski> we should have a way to declare new unboxed types :)
00:21:09 <Taral> _|_ is False, it doesn't occupy the type.
00:21:13 <dons> ski!
00:21:14 <ski> data# Void#
00:21:18 <Taral> LOL
00:21:33 <dons> hmm. yeah, then we wouldn't need the State# toen
00:21:37 <dons> or RealWorld#
00:21:37 <Taral> You could add Bot or False to your type system, representing an assertion that a computation does not terminate.
00:21:39 <Cale> Taral: depends on the way you think about it :)
00:22:02 <dons> ski, just needs the right kind annotations
00:22:07 <Cale> A properly empty type might be handy
00:22:19 <dcoutts> I don't think you can't have empty types and general recursion
00:22:26 <dons> data (A :: #) = umm.. something ...
00:22:30 <dcoutts> see eppigram etc
00:22:32 <ski> dons : yes .. and allow result kind to be other than '*'
00:22:41 <Cale> Pattern matches against  Either a Null  could reasonably ignore Right
00:22:46 <Taral> So, what about this linear logic PL? CLL or ILL?
00:22:51 <Cale> dcoutts: hm?
00:23:03 <Cale> dcoutts: as in, the theorem proving becomes undecidable?
00:23:11 <Taral> do you provide a truly empty type or not?
00:23:14 <dcoutts> Cale, right
00:23:17 <Cale> okay
00:23:48 <dons> dcoutts, I thought you were on pudding sabbatical ;)
00:23:49 <ski> an unboxed 'Void#' wouldn't even have '_|_' as "element"
00:23:52 <Cale> Well, certainly you can't infer them
00:23:58 <dcoutts> dons, I am!
00:24:05 * dcoutts goes away again
00:24:10 <earthy> ;)
00:24:11 <Cale> pudding?
00:24:12 * dons leaves for pudding sabbatical tomorrow.
00:24:16 <Taral> ski: That would affect strictness, right?
00:24:20 * dcoutts was just checking train times
00:24:32 <earthy> cale: christmas pudding, ofcourse
00:24:38 <ski> Taral : yes, since it's unboxed, it's strict
00:24:50 <Cale> ah
00:24:51 <Taral> Hm.
00:24:53 <ski> (which is prolly wanted here)
00:24:58 <dons> right, so the # kind implies all sorts of interesting things.
00:25:10 <Taral> The only reason to define an empty type like this in a PL is to represent non-returning functions.
00:25:21 <Taral> e.g. main
00:25:32 <ski> (anyway, this would more correspond to '0' rather than 'Bot' ..)
00:25:32 <Taral> and exit
00:25:46 <dons> what about pure type-level computation
00:25:48 <Taral> I'm talking about Bot/False
00:25:57 <dons> funny types are made up all the time for typeclassed type games
00:25:59 <Taral> type-level computation is evil.
00:25:59 <ski> '0' is the empty type
00:26:07 <Taral> what is 0 the unit of?
00:26:14 <Cale> Taral: one could do it for purely categorical reasons :)
00:26:14 <ski> it has zero constructors
00:26:19 <dons> Taral, it's just theorem proving, and what's evil about that? ;)
00:26:20 <ski> Taral : add. disj.
00:26:26 <Cale> Taral: it's the unit of either.
00:27:34 <dons> Taral, http://www.cse.unsw.edu.au/~dons/qs.transcript
00:27:39 <dons> typical haskell program ;)
00:27:52 <Taral> Cale: No, 1 is the unit of either.
00:28:06 <Cale> Taral: no it isn't :)
00:28:10 <Taral> it is.
00:28:11 <Cale> Either a ()
00:28:15 <Taral> that's 1
00:28:16 <Cale> that's not the same as 'a'
00:28:20 <Taral> it's equivalent
00:28:33 <Cale> no, it's the same as Maybe a
00:28:36 <Taral> @djinn Equiv a (Either a ())
00:28:36 <lambdabot> -- f cannot be realized.
00:28:39 <Taral> ?
00:28:45 <Taral> Oh.
00:28:47 <Taral> Hm!
00:28:49 <Cale> @djinn Equiv (Maybe a) (Either a ())
00:28:49 <lambdabot> -- f cannot be realized.
00:28:52 <Cale> er
00:29:03 <Cale> @djinn-env
00:29:03 <lambdabot> data () = ()
00:29:03 <lambdabot> data Either a b = Left a | Right b
00:29:03 <lambdabot> data Maybe a = Nothing | Just a
00:29:03 <lambdabot> data Bool = False | True
00:29:03 <lambdabot> data Void
00:29:05 <lambdabot> type Not x = x -> Void
00:29:06 <Taral> right
00:29:09 <Taral> 0 is the unit of either
00:29:20 <ski> @djinn Maybe a -> Either a ()
00:29:20 <lambdabot> f a =
00:29:20 <lambdabot>   case a of
00:29:20 <lambdabot>   Nothing -> Right ()
00:29:20 <lambdabot>   Just b -> Left b
00:29:24 <Taral> () is the unit of (,)
00:29:27 <ski> @djinn Either a () -> Maybe a
00:29:28 <Taral> ?
00:29:28 <lambdabot> f a =
00:29:28 <lambdabot>   case a of
00:29:28 <lambdabot>   Left b -> Just b
00:29:28 <lambdabot>   Right _ -> Nothing
00:29:34 <ski> Taral : yes
00:29:37 <Taral> @djinn Equiv a (a,())
00:29:37 <lambdabot> -- f cannot be realized.
00:29:38 <Cale> @djinn-add type Equiv a b = (a -> b, b -> a)
00:29:43 <Taral> @djinn Equiv a (a,())
00:29:44 <lambdabot> f = (\ a -> (a, ()), \ (b, _) -> b)
00:29:46 <Taral> there
00:29:53 <Cale> right
00:29:57 <ski> (Taral : this is ignoring '_|_' though)
00:30:04 <Taral> yes
00:30:15 <Taral> I'm trying to find type-system equivalents for all of the operators
00:30:20 <Taral> add. disj. = Either
00:30:22 <Cale> really, we have that (a,Void) is the same as a
00:30:23 <ski> yes
00:30:33 <Cale> where Void = { _|_ }
00:30:35 <ski> add. false = Void
00:30:45 <Taral> ?
00:30:48 <ski> (still ignoring '_|_')
00:30:52 <Taral> :(
00:30:59 <Taral> mult. false = Void
00:31:04 <ski> no
00:31:07 <Taral> why?
00:31:20 <ski> the mult. false and disj. are harder to understand
00:31:29 <Taral> Void = 0?
00:31:33 <ski> yes
00:31:35 <Taral> okay
00:31:39 <Taral> so what is Bot?
00:31:42 <Cale> Void in Haskell is 1 though :)
00:31:43 <ski> the empty type 'Void' is the unit of 'Either'
00:31:44 <Taral> mult. false = Bot
00:31:49 <ski> right 
00:32:06 <Taral> so is (,) the mult. conj. or add. conj.?
00:32:23 * Cale really wishes that people would use category theoretic terms :)
00:32:30 <Cale> hehe
00:32:31 <Taral> Cale: Never studied category theory.
00:32:32 <ski> mult. false is also know as 'par' .. i've heard this was named such since it seems to have to do with parallelism in some way
00:32:42 <ski> (at least in game theoretical semantics)
00:32:45 <Taral> mult. disj. is very closely related to par.
00:32:53 <Cale> Taral: I've never studied this strange linear logic stuff :)
00:33:02 <ski> Taral : 'related' ?
00:33:20 <Taral> the parallel operator in computability logic is very similar to LL's mult. disj.
00:33:25 <Taral> s/operator/disjunction/
00:33:26 <ski> yes, indeed
00:33:34 <Taral> I didn't like comp. logic much.
00:33:38 <Taral> It makes my brain hurt.
00:33:39 <ski> but, mult. disj. in LL is also sometimes called 'par'
00:33:42 <Taral> why?
00:33:50 <ski> mult. conj. is called 'tensor'
00:33:55 <ski> Taral : ask Girard ?
00:34:00 <Taral> heh
00:34:05 <Taral> anyway
00:34:07 <ski> (about naming, i.e.)
00:34:08 <Taral> so is (,) the mult. conj. or add. conj.?
00:34:16 <ski> depends on use
00:34:25 <Taral> ?
00:34:27 <Cale> there are projections
00:34:46 <Cale> @djinn (a,b) -> a
00:34:47 <lambdabot> f (a, _) = a
00:34:50 <Cale> @djinn (a,b) -> b
00:34:51 <lambdabot> f (_, a) = a
00:34:53 <ski> both intuitions of add conj. and mult. conj. are present in '(,)' in haskell (or intuitionistic logic)
00:35:03 <ski> since you can discard and copy freely
00:35:04 <Taral> well, given that (a, b) -> a is derivable, (,) is add. conj.
00:35:12 <Cale> yeah, that's what I'd say
00:35:24 <ski> .. these two conjunctions becomes one
00:35:25 <Taral> hm!
00:35:27 <Taral> you're right
00:35:31 <Taral> we'd have to split (,)
00:35:34 <ski> yes
00:35:37 <Cale> hm?
00:35:38 <ski> that's what Girard did
00:35:43 <Taral> (,) is the general conjunction
00:35:53 <Taral> it's both multiplicative and additive
00:36:00 <Taral> you have to split it for LL
00:36:05 <Cale> Isn't multiplicative conjunction where you're only allowed one of the projections?
00:36:07 <ski> in intuitionistic (and classic) (normal) logic, yes
00:36:13 <Taral> Cale: No, other way around.
00:36:16 <ski> Cale : other way around
00:36:16 <Taral> mult. conj. is you have both
00:36:20 <Taral> add. conj. is you only have one
00:36:28 <Cale> oh, sort of :)
00:36:29 <ski> (you have a choice)
00:36:35 <Taral> yes, you have a choice
00:36:48 <ski> in 'Either' someone else has a choice, instead :)
00:36:52 <Taral> right
00:37:06 <Cale> with additive conjuction, you *must* use only one?
00:37:12 <Taral> yes
00:37:13 <ski> Cale : right
00:37:17 <Cale> and with multiplicative you *must* use both?
00:37:19 <Taral> you have functions (a, b) -> a and (a, b) -> b
00:37:22 <ski> Cale : yes
00:37:24 <Taral> whereas for mult. conj. you have
00:37:28 <Cale> okay, that's just silly :)
00:37:29 <ski> Cale : it's linear :)
00:37:33 <Taral> a * b -> (a -> b -> c) -> c
00:37:45 <Cale> I don't understand why you'd ever want that.
00:37:49 <ski> Taral : yes, that's basically curring at work
00:37:58 <ski> Cale : to represent resources
00:37:59 <Taral> Cale: In a resource model, you want it.
00:38:16 <Taral> (echo, echo, echo)
00:38:42 <Taral> could we reasonably define it this way then?
00:38:44 <Taral> MC: (*)
00:38:48 <Taral> AC: (,)
00:38:51 <Taral> AD: Either
00:38:53 <Cale> But how does that relate to programs?
00:38:54 <ski> e.g., it's not free to discard garbage .. and it's not free to copy money .. in usual math, it's however free to both copy and discard assumptions (as well as other values)
00:39:01 <Taral> Cale: Think locks or allocated memory
00:39:08 <Taral> You're not allowed to discard these things
00:39:19 <ski> or arrays
00:39:20 <Taral> you have to pass them to destructor functions
00:39:21 <ski> or RealWorld
00:39:42 <Taral> or return them (e.g. RealWorld)
00:39:50 <ski> yes
00:40:16 <Taral> openFile = RealWorld -> String -> RealWorld * File
00:40:23 <Taral> er, s/=/::/
00:40:25 <ski> s/=/::/
00:40:29 <Taral> hehehehe
00:40:43 <ski> that's basically what Clean gives you for opening a file
00:40:46 <Taral> yup
00:40:50 <Taral> I like the LL version better
00:41:07 <ski> Taral : ?
00:41:19 <Cale> It still seems rather unnatural, as most of the time it seems like something which would just be frustrating.
00:41:20 <Taral> in clean you have that yucky * annotation
00:41:30 <Taral> Cale: Are you familiar with Clean?
00:41:39 <Cale> Taral: not that familiar
00:41:40 <Taral> It's worth a look.
00:41:49 <Taral> Their uniqueness types are similar to what we're trying to do here.
00:41:54 <ski> Cale : you have 'of course' (and 'why not') connectives, to get back controlled copying and discarding
00:42:15 <Taral> freezeArray :: MArray -> !IArray
00:42:21 <ski> Taral : yes, except we want to use more stuff from LL that they
00:42:23 <Taral> where ! means you have as many as you want.
00:42:28 <ski> right
00:42:53 <Cale> To have a function which returns a pair which you can choose whether or not you want to use the components, you have to return a choice between the multiplicative or additive pair
00:43:01 <Cale> that seems pretty annoying
00:43:13 <ski> Cale : or, return 'of course' the pair
00:43:28 <ski> 'of course' = '!'
00:43:48 <Taral> Cale: Most things are non-linear in that you want to be able to copy/discard them at will
00:43:55 <Taral> Things like integers.
00:43:59 <Cale> Taral: right
00:44:06 <Taral> These are dealt with by the modal ! operator.
00:44:13 <Taral> You can copy/discard !A.
00:44:18 <ski> Cale : did you look at the short introduction paper linked at bottom of the wikipedia page ?
00:44:22 <Taral> The paper is good.
00:44:24 <Cale> Why not only explicitly introduce linearity?
00:44:32 <Taral> Cale: That is the alternative, and we might go that route.
00:44:34 <Taral> Clean did.
00:44:38 <ski> well
00:44:45 <ski> strictly, it's not possible
00:45:08 <Taral> no?
00:45:10 <ski> Clean changes '!' from a connective to an annotation on other connectives
00:45:25 <Taral> Yeah, I didn't like it.
00:45:31 <Taral> all that u: v: w: xyzzy: stuff
00:45:32 <ski> that annotation can be either 'shared' or 'nonshared' (or a sharing variable, for polymorphism)
00:45:58 <ski> and, they happen to use syntax so that if you want 'shared' you write no extra characters in your file
00:46:06 <ski> while, to use 'nonshared'
00:46:12 <ski> you use '*' as annotation
00:46:21 <ski> Start :: *World -> *World
00:46:23 <Taral> yes
00:46:26 <ski> Taral : yes
00:46:40 <Taral> yes
00:46:41 <Taral> :)
00:46:48 <Cale> I'd like to see a category theoretic description of this sort of thing.
00:46:49 <Taral> The question is, how to avoid those sharing variables?
00:46:55 <ski> but, if we want a real connective, then linear has to be default
00:47:05 <Taral> yeah, I think so
00:47:17 <ski> Taral : for what reason ?
00:47:28 <Taral> They are ugly.
00:47:32 <Taral> Anyway, they're not necessary.
00:47:34 <ski> a bit, yes
00:47:42 <Taral> You don't need polymorphism over sharing in linear logic.
00:47:49 <ski> Mercury uses multiple modedeclarations, instead
00:47:57 <ski> Taral : true
00:48:06 <Taral> if a function is A -> A (for example), then I can derive !A -> !A
00:49:01 <Taral> I mean, that's what the !L and !R rules _do_.
00:49:15 <Taral> okay, that's awesome.
00:49:16 <ski> Taral : but they want to have (in source) *one* function append, which, depending on whether arguments are shared or not, gives back shared resp. nonshared result (and also updating in place, in the nonshared case)
00:49:51 <Taral> but that doesn't work in linear logic
00:50:07 <ski> (but, Mercury's uniqueness system is not fully done yet, otoh .. the impl. doesn't yet support nested uniqueness)
00:50:20 <ski> Taral : not directly, no
00:51:05 <ski> at least Mercury's uniqueness system (don't recall about Clean) is not very much based on Linear Logic at all (if at all, then just very loosely)
00:51:48 <ski> i.e. they came up with idea that a static system for controlling sharing could be good to handle update-in-place (over e.g. arrays and the world)
00:52:04 <Taral> I see.
00:52:28 <Taral> So how do you handle update-in-place with linear logic?
00:52:39 <ski> iirc Wadler had some early paper about how to possibly exploit linear logic in type systems
00:52:49 <Cale> Taral: well, you know that things can't be reused
00:52:57 <Taral> I suppose you could lift the shared-ness to the type system...
00:53:11 <Cale> Taral: or are you talking about something else?
00:53:30 <Taral> The problem is that if you have A, you can't guarantee that !A isn't hanging around somewhere.
00:53:48 <ski> yes, that's one problem Wadler had, i think
00:53:58 <Taral> So something like...
00:54:09 <Taral> class A
00:54:17 <Taral> instance A SharedA
00:54:17 <ski> foo :: !A -> ...    foo a = bar a      bar :: A -> ...
00:54:20 <Taral> instance A UnsharedA
00:54:34 <Taral> freeze :: UnsharedA -> !SharedA
00:55:05 <Taral> polymorphic functions can be A a => a -> a
00:55:11 <Taral> so append becomes
00:55:29 <Taral> List a => a -> a -> a
00:55:39 <ski> 'List' ?
00:55:52 <Taral> List, a type class with instances UnsharedList and SharedList
00:56:01 <ski> hrm
00:56:22 * ski 'd like the arg of that class to have kind '* -> *', then i think
00:56:34 <Taral> but then you need some kind of type awareness (e.g. jhc's CoC) to allow different implementations.
00:56:51 <Taral> And you're basically back to Clean's *-notation
00:56:54 <ski> Clean does it with same list type
00:57:20 <Taral> I kind of like the idea of making types first-class.
00:57:41 <Cale> How possible/impossible is it to infer that variables are only used in a linear fashion?
00:57:43 <Taral> Thus allowing specialization without evil hacks.
00:57:50 <ski> (Clean's way is sortof a kind of bounded overloading, at implementation level, but only one source implementation)
00:58:00 <Taral> ski: Yes.
00:58:09 <ski> (same in Mercury, except, it's not bounded, in same sense)
00:58:09 <Taral> Cale: Infer? Possible.
00:58:16 <Cale> It seems like something that would be difficult to show in general, but which in practice, you could infer a lot of the time.
00:58:37 <ski> yes, aliasing is undecidable
00:58:41 <Cale> and then simply let the compiler take care of that optimisation rather than the programmer
00:58:44 <Taral> We could add a uniqueness connective *.
00:58:48 <ski> we can make good approximations
00:58:52 <Taral> So *A is a guaranteed unique A.
00:58:57 <ski> yes
00:59:10 <ski> Taral : make that an annotation, not connective
00:59:13 <Taral> But you end up with the same polymorphism problems that Clean did.
00:59:22 <Taral> what is the difference between annotation and connective?
00:59:42 <Cale> a connective is something which is connecting 2 or more things, usually
01:00:14 <ski> Taral : think about nonshared references lying inside a structure which is shared
01:00:35 <Cale> hmm, perhaps 1 or more :)
01:00:52 <ski> something is really nonshared only if it's nonshared references, all the way
01:01:01 <Cale> I've never seen "not" referred to as a connective, but it seems to be in some places.
01:01:24 <ski> Cale : it can be a connective, yes
01:01:40 <ski> (Cale : in one formulation of lin.log., it isn't)
01:02:12 <ski> Cale : imo, the units of the binary connectives are also (zeroary) connectives
01:02:17 <Cale> er
01:02:20 <Taral> ski: what is the difference between annotation and connective?
01:02:56 <Cale> ski: as in, it's not part of logical statements?
01:03:24 <ski> Cale : ?
01:03:30 <Cale> I suppose that if you want to call "connective" anything which builds up larger statements from atoms, then it's a connective :)
01:03:52 <Taral> Ah, * is not a connective because it has no logical effect?
01:03:56 <Cale> My original thinking was that "connective" implied "binary"
01:04:16 <Cale> but that doesn't seem true in usage
01:04:18 <ski> Taral : if you have a part of a substructure, and it's annotation says it's nonshared .. then it's really nonshared only if the whole structure is nonshared .. otoh, if you use a '!' connective, then if a part of a substructure is marked with that, that says it's (possibly) shared, and it really is
01:04:33 <Taral> ok
01:04:39 <Taral> so...
01:04:52 <ski> Cale : i use 'connective' as the things that build up formulae from smaller formulae (and atoms)
01:04:57 <Cale> ski: okay
01:05:26 <ski> Cale : often, i say 'Forall' is a conective, too (possibly this is strictly somewhat incorrect)
01:05:36 <Taral> it looks like the problem here is really caused by implicit copying.
01:05:42 <ski> yes
01:06:22 <Cale> ski: well, it would be a quantifier, but whether quantifiers count as connectives is up to the way you define them
01:06:25 <ski> Taral : it has to do with that 'default' (in a sense) has to be 'nonshared
01:06:29 <ski> '
01:06:30 <Taral> yes
01:06:33 <Taral> I agree.
01:06:36 <Cale> (and how you define 'connective' :)
01:06:42 <ski> Cale : :)
01:07:12 <Taral> and shared-things have to be disjoint from unshared-things unless they're value objects.
01:07:26 <Taral> so lists, for example, will have to be shared-lists and unshared-lists.
01:07:38 <Taral> there's no way around it.
01:07:43 <ski> Taral : another take on it .. '!' is a real type constructor, with kind '* -> *' (haskell-speak), but Clean's '*' is not a type-constructor
01:07:52 <Taral> ski: Yes, I got that.
01:08:02 <Taral> arg, it's 3 am.
01:08:06 <Taral> I have to go sleep.
01:08:16 <ski> i'm not sure we need inherently different types for those two kinds of lists
01:08:29 <ski> yes
01:08:30 <Taral> How do you keep someone from deallocating your list on you?
01:08:41 <Taral> (or overwriting it)
01:09:04 <ski> yes, it's not fully clear ..
01:09:16 <Taral> unless...
01:09:31 <Taral> unless we insert an implicit copy when creating A from !A.
01:09:38 <ski> yes, that'd be an option
01:09:56 <ski> haskell does that with IArray and MArray, i think
01:09:59 <Cale> If monads will suffice to express code which is restricted in this fashion, and a major goal is optimisation, another option is to simply provide a monad with special treatment from the compiler.
01:09:59 <Taral> yes
01:10:05 <Taral> but the copy is not implicit :)
01:10:08 <Taral> is it?
01:10:19 <ski> Taral : right, it isn't
01:10:20 <Taral> Cale: Dunno if monads will do.
01:10:37 <Cale> Taral: I think that some monad would.
01:10:39 * ski thinks the 'why not' connective is a monad
01:11:02 <Cale> why not?
01:11:07 <Taral> the idea is that a function !A -> !A can be auto-specialized to A -> A
01:11:09 <Taral> er
01:11:10 <Cale> er
01:11:12 <Cale> "why not"?
01:11:13 <Taral> the idea is that a function !A -> A can be auto-specialized to A -> A
01:11:17 <ski> one advantage to using explicit linearity, is to not single-thread everything
01:11:43 <ski> Cale : 'why not' = '?' is the dual of 'of course' = '!'
01:11:59 <Taral> ski: ? doesn't exist in ILL.
01:12:02 <Cale> ?!a = a ?
01:12:09 <Taral> heh
01:12:14 <Cale> heh
01:12:14 <Taral> not (!a) = ?(not a)
01:12:18 <Cale> ah
01:12:37 <ski> Cale : it's the other of the connectives in CLL that's hard to get intuition about (prolly because there's no corresponding (even if conflated) intuition in intuitionistic logic)
01:12:38 <Taral> ?a will consume zero or more a's
01:12:53 <ski> no
01:13:04 <Taral> no?
01:13:05 <Cale> ski: I don't even find intuitionistic logic intuitive at all. :)
01:13:07 <ski> '?' seems related to backtracking, in some way
01:13:15 <Taral> no.
01:13:18 <ski> Cale : hehe
01:13:23 <Taral> a |- b => a |- b, ?c
01:13:23 <bojohan> `There's no way to avoid huge amounts of copy and paste. Java's version of "once and only once" appears to be: "N times and only N+1 times."'
01:13:29 <ski> Cale : and yet you find Haskell intuitive ?
01:13:45 <Cale> ski: there are still things which catch me :)
01:14:09 <Cale> however, I tend not to think of functions as theorems except in a very vague sense
01:14:11 <Taral> ?c is like a restricted 1, it eats extra resources
01:14:21 <Cale> I tend to think of functions as functions :)
01:14:29 <Cale> (i.e. arrows in Set)
01:14:30 <Taral> anyway, back to my auto-specialization
01:14:30 <ski> Cale : i meant the way with coding with values, passing them around and casing and calling and creating lambdas and discarding and copying
01:14:51 <ski> functions in Set are quite intuitionistic, i think
01:14:57 <Cale> ski: yeah, that's all familiar from mathematics
01:15:00 <Cale> no they're not :)
01:15:03 <Taral> ...
01:15:09 <ski> well
01:15:18 <Cale> Actually, there are lots of functions in Set which don't occur in Haskell
01:15:31 <Cale> which is where I tend to get tripped up :)
01:15:48 <Taral> okay, so it is possible to take a version of append :: [a] -> [a] -> [a] which overwrites and auto-convert it to a non-overwriting version ![a] -> [a] -> [a]
01:16:03 <ski> you've got evil stuff like ..  er what's the name .. 
01:16:08 <Taral> this requires inference on the implementation of append.
01:16:13 <Taral> can it be done?
01:16:16 <Cale> I'm pro-choice :)
01:16:28 <ski> Cale : right, Axiom of choice :)
01:17:04 <Cale> It's not evil at all -- you're saying that the product of nonempty sets is possibly empty? :)
01:17:08 <Cale> hehe
01:17:11 <ski> Cale : but, what i meant was more like, in Set you can't capture continuations .. while that's partly what classical logic is about (in comparing with intuitionistic logic)
01:17:46 <Cale> hm?
01:18:08 <ski> (or at least i think you can't .. there may be some relation between AC and continuations, not sure)
01:18:12 <Taral> okay, you people are not paying attention to my revelations, I'm going to bed.
01:18:12 <Taral> nini.
01:18:19 <ski> Taral : sorry
01:18:22 <Taral> :)
01:18:23 <Taral> s'ok
01:18:26 <Taral> I need to sleep.
01:18:27 <ski> Taral : good night to you ..
01:18:40 <Cale> Continuations aren't a concept in ordinary mathematics, so it just never comes up :)
01:19:13 <ski> continuations are related to double-negation-elimination, which is one of the points of classical logic
01:19:27 <ski> i.e. proof by contradiction
01:19:45 <Cale> perhaps, but not in any way which a mathematician would notice
01:19:51 <Cale> hehe :)
01:20:37 <Cale> I'm not sure I properly see the connection between them even.
01:21:02 <ski> nonconstructivities of such proofs have more to do with implicit use of and '!' and '?' rather than double-negation-elimination, i think
01:21:32 <Cale> In common mathematics, sets and functions are not tied as directly into a logical system as you're discussing them here.
01:21:49 <ski> right
01:21:59 <ski> this is partly an idealization
01:22:13 <ski> (or rephrasing)
01:22:41 <Cale> Have you read anything about model theory?
01:22:50 <Cale> You might enjoy that
01:23:00 <ski> no, i haven't
01:23:03 <ski> perhaps i should
01:23:21 <Cale> I'm not sure about any kind of connection with reality :)
01:23:37 <Cale> But as an abstraction it's surprisingly powerful
01:23:39 <ski> who's talking about "reality" ?
01:23:49 <Cale> CS is reality to a mathematician :)
01:24:03 <ski> (or, did you mean "mathematical reality" ?)
01:24:22 <Cale> i.e. if something is useful in theoretical computer science, then it's useful in "reality"
01:24:27 <ski> here, CS means computability/constructivity, i think
01:24:34 <Cale> or "the real world" :)
01:24:40 <Cale> hehe
01:25:28 * ski considers theoretical computer science a field of math
01:25:33 <Taral> aha
01:25:34 <Cale> I was quite stunned that something like category theory, especially something like monads, would have practical applications.
01:25:35 <Taral> the annotation you need is 'const'
01:25:36 <ski> wb Taral
01:25:39 <Cale> Oh, it is :)
01:26:00 <Taral> @[a] is a list that will not be modified, but can be unique
01:26:00 <lambdabot> Maybe you meant: lam map
01:26:12 <Cale> But in a sort of tongue in cheek way, it's connected to "practical" matters.
01:26:26 <Taral> so head :: @[a] -> a
01:26:29 <ski> Taral : i'm not sure about your 'append' question ..
01:26:35 <Taral> ski: Don't worry about that.
01:26:52 <ski> Taral : i think that's closest to what Clean and Mercury are trying to do
01:27:05 <Taral> The idea is that if I have ![a], then I can pass it to head without a copy
01:27:20 <ski> Cale : so is monads :)
01:27:22 <Taral> but if I pass it to append :: [a] -> [a] -> [a], it has to be copied because append doesn't have a const annotation.
01:27:41 <Cale> ski: yes, which I found quite surprising :)
01:27:47 <Taral> okay, I'm happy now
01:27:50 <Taral> if I forget, it'll be in the logs.
01:27:51 <Taral> nini.
01:27:57 <ski> Taral : hehe
01:27:58 <Cale> Anyway, model theory can rival category theory in expressiveness and generality, though it does so from a very different perspective.
01:28:06 <ski> Taral : explain it later to me, ok ?
01:28:08 <Taral> ok
01:28:14 <Taral> I'll try to write it up.
01:28:14 <ski> Cale : mhm
01:29:01 <Cale> The idea is the somewhat metamathematical one of representing your formal system for doing mathematics, as a construction of set theory.
01:29:12 <ski> i've heard about stuff like models of ZF, etc .. is this related to model theory (i assume it is)
01:29:16 <Cale> yes
01:29:31 <ski> (btw, iirc Lawvere talks about categories as models)
01:29:37 <Cale> A model of ZF is just something which satisfies the axioms of ZF
01:29:50 <ski> right
01:30:30 <Cale> There are some things about all this which seem philosophically troubling, but I wouldn't worry too much about them :)
01:31:01 <ski> (about meta-systems ? or specifically about model theory ?)
01:31:11 <Cale> both
01:31:50 <Cale> model theory is basically a way of putting formal systems in terms of set theory and talking about statements in them set-theoretically.
01:32:14 <ski> is the model a set (in meta-ZF) there ?
01:32:27 <Cale> yeah
01:32:30 <ski> ok
01:32:33 <Cale> well, basically
01:32:37 <Cale> It's a bunch of functions
01:32:48 <ski> which are sets, in ZF
01:32:51 <Cale> yeah
01:32:52 <ski> well
01:33:05 <Cale> (that's true)
01:33:08 <ski> maybe not if domain is a proper class
01:33:21 <Cale> oh, but ZF doesn't have proper classes
01:33:30 <ski> right
01:33:53 <ski> you could have a system with functions that have as domain a class of sets
01:33:54 <Cale> You get some pretty funky theorems. The compactness theorem states that a set of sentences S is satisfiable, i.e., has a model, if every finite subset of S is satisfiable.
01:34:03 <ski> iirc, some foundation of CT used something like that
01:34:45 <ski> Cale : is that related to topology ?
01:34:47 <Cale> You have an interpretation, which is a map from components of your formal language to actual sets and functions
01:35:02 <ski> yes
01:35:14 <Cale> ski: the only way in which I see that it's connected to topology is pretty informal
01:35:23 <ski> (formal language being something like an initial F-algebra)
01:35:33 <ski> (Cale : ok)
01:35:40 <Cale> Well, usually we actually use something pretty concrete
01:35:52 <Cale> with a recursive definition in terms of strings
01:35:57 <ski> strings ? :)
01:36:02 <ski> (yuck)
01:36:12 <Cale> well, trees, more like it
01:36:21 <Cale> but finite discrete structures anyway
01:36:28 <ski> yes
01:36:47 <ski> with "syntactic structure" (like datatypes in haskell)
01:36:51 <Cale> yeah
01:37:19 <ski> (i.e.  'Add Zero One' is not the same term as 'One')
01:37:20 <Cale> they tend to be recursively defined, and for a long time, all the proofs are really boring proofs by induction
01:37:37 <Cale> :)
01:37:54 <Cale> but anyway, this compactness theorem is interesting
01:37:57 <ski> (didn't Miranda have "laws" that did something like this ?)
01:38:00 <ski> mhm
01:38:12 <ski> why ?
01:38:20 <Cale> I'll give you a nice example :)
01:38:24 <ski> k
01:39:04 * ski wonders whether we should move to other channel, so as not to inhibit/hog discussion here (since it's only a little bit related to haskell)
01:39:04 <Cale> I can construct a language containing the usual logical stuff, together with =, +, *, 0, 1, -, ^(-1), and <
01:39:07 <Cale> hehe
01:39:09 <Cale> okay
01:39:15 <ski> #haskell-overflow ?
01:39:18 <Cale> sure
01:44:58 <[CotL]Godofe_Kei> mornin
01:45:35 <ski> morning [CotL]Godofe_Kei
01:55:48 <ski> morgen, shapr
01:56:01 <shapr> yay, #haskell is back!
01:56:18 <ski> did it disappear, at some time ?
01:56:40 <shapr> Yup, split from irc.ipv6.freenode.net
01:57:50 <ski> a-ha
01:59:13 <shapr> Can someone tell me if the free algebras mentioned in http://lambda-the-ultimate.org/node/view/1183#comment-12896 are the same as http://en.wikipedia.org/wiki/Free_algebra ?
02:00:03 <Lemmih> @seen jlouis
02:00:03 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
02:00:03 <lambdabot> spoke.
02:01:08 <araujo> Good morning everyone!
02:01:11 <shapr> hola
02:01:27 <araujo> Hola shapr 
02:01:28 <araujo> :-)
02:03:35 <[CotL]Godofe_Kei> Sup ppl?
02:03:50 <shapr> Nay, I have not yet supped this day.
02:03:55 <[CotL]Godofe_Kei> can anyone explain me how to go from 00:00:34.582 ---> 0,0,34,582
02:04:17 <[CotL]Godofe_Kei> ive been busting my head off and i just cant do it
02:04:18 <shapr> Replace the characters?
02:04:34 <[CotL]Godofe_Kei> the problem is to take the :
02:04:37 <[CotL]Godofe_Kei> and put ,
02:05:00 <[CotL]Godofe_Kei> > read 00 :: Int
02:05:01 <lambdabot>  add an instance declaration for (Num String)
02:05:21 <[CotL]Godofe_Kei> > read "00" :: Int
02:05:22 <lambdabot> 0
02:05:43 <araujo> > let f (a:b:':':c:d:':':e:f:'.':r) = [read [a],read [c], read (e : f : []), read r] :: [Int] in f  "00:00:43.322" 
02:05:44 <lambdabot> [0,0,43,322]
02:05:53 <[CotL]Godofe_Kei> wow
02:06:00 <araujo> ugly and dirty though
02:06:01 <[CotL]Godofe_Kei> lemme see if i can get it
02:06:24 <araujo> But if they are always gonna follow the same pattern, well....
02:06:26 <Itkovian> I think a simply tr or sed would do just fine, prior to giving that to haskell
02:06:39 <araujo> Itkovian, c'mon
02:06:42 <araujo> ;-)
02:06:44 <[CotL]Godofe_Kei> thx a lot m8
02:06:53 * araujo goes to get some morning juice
02:06:55 <Itkovian> s/simply/simple/
02:07:49 <shapr> @seen cale
02:07:49 <lambdabot> cale is in #haskell-overflow and #haskell. Last spoke 9 seconds ago.
02:07:54 <Cale> hi
02:08:04 <Cale> @localtime cale
02:08:11 <shapr> Would you happen to know if the free algebras I mentioned are the same thing?
02:08:30 * Cale looks
02:08:57 <Cale> no, unfortunately, I'm fairly sure it's not :)
02:09:39 <shapr> Bah, I was 80% sure they were, since Free Algebra on wikipedia has a 'Category Theory' tag.
02:09:49 <Cale> yeah, hmm...
02:10:11 <Cale> That's likely just because while abstract, they're not quite *that* abstract yet.
02:10:32 <shapr> "One of the things in the former case is in CT one of the main uses of monads is for algebras as one would come across in universal algebra. Most of the monads in Haskell are free algebras. For programming the most nature thing that corresponds to the term algebra in universal algebra is an AST." ?
02:10:55 <shapr> Derek said he might tur this into a TMR article. I'd definitely like that.
02:11:15 <Cale> yeah
02:11:34 <[CotL]Godofe_Kei> Araujo
02:11:37 <[CotL]Godofe_Kei> wher r u from?
02:11:37 <Cale> let me see if I can find a better reference
02:11:48 <ski> that 'Free algebra' on wikipedia uses 'algebra' in a non-general sense
02:12:06 <Cale> right
02:12:09 <[CotL]Godofe_Kei> can anyone tell me why this doesnt work?
02:12:10 <araujo> [CotL]Godofe_Kei, venezuela
02:12:10 <[CotL]Godofe_Kei> kkcoisa :: String -> (Int,Int,Int,Int)
02:12:10 <[CotL]Godofe_Kei> kkcoisa s = let f (a:b:':':c:d:':':e:f:'.':r) = [read [a],read [c], read (e : f : []), read r] :: [Int] in f s
02:12:18 <Cale> well, I'd see it as an altogether different sense
02:12:19 * shapr looks at the universal algebra page.
02:12:21 <[CotL]Godofe_Kei> oh ok i cant make it work m8
02:12:33 <araujo> You are returning a list
02:12:40 <araujo> need*
02:12:42 <Cale> this kind of algebra and that kind only have superficial connections with one another
02:12:49 <[CotL]Godofe_Kei> ??
02:12:56 <araujo> String -> [Int]
02:13:02 <[CotL]Godofe_Kei> hmm
02:13:17 <[CotL]Godofe_Kei> lo
02:13:18 <[CotL]Godofe_Kei> thx
02:14:20 <ski> or, you want to return a quadruple
02:14:42 <araujo> yeah, it is up to you
02:15:01 * araujo recommends list though
02:15:39 <ski> depends on what intended use is
02:15:46 * shapr gets lost in http://en.wikipedia.org/wiki/Category:Abstract_algebra
02:16:05 <ski> maybe this is hour:minute:second.seconddecimals
02:16:07 <Cale> :)
02:16:33 * araujo throws a lambda-savelife at shapr 
02:16:42 <Cale> shapr: http://www.math-atlas.org/ might help in general with getting lost
02:16:53 <shapr> Ok, thanks.
02:17:07 <Cale> i.e. it will help you to get more lost :)
02:17:19 <shapr> It's always fun to dive into a new field of study that could furnish me with years worth of toys.
02:18:46 <Cale> aha
02:18:48 <Cale> found one
02:18:56 <Cale> in MacLane's book, no less
02:25:16 <joelr1> morning!
02:25:16 <araujo> Hola joelr1 
02:27:48 <shapr> @where darcs-cgi
02:27:52 <lambdabot> I know nothing about darcs-cgi.
02:28:02 <shapr> hmm
02:28:18 <kolmodin> good morning
02:29:56 <shapr> hiya
02:30:32 <kolmodin> just had my 10h "nap". now: coffie :)
02:30:39 <joelr1> Cale: ping
02:30:45 <Cale> hi
02:30:58 <joelr1> Cale: do you never sleep or something? :D
02:31:03 <joelr1> @localtime Cale
02:31:04 <lambdabot> Local time for Cale is Wed Dec 21 05:30:41
02:31:13 <joelr1> hmm
02:31:17 <joelr1> Cale: where are you?
02:31:27 * shapr emails more caffeine to Cale
02:31:27 <Cale> Brantford Ontario
02:31:34 <Cale> I've been taking naps
02:31:42 <shapr> I think Cale does polyphasic sleep.
02:31:46 <joelr1> Cale: i was gonna ask if you had anymore tweaks to the picklers
02:32:23 <Cale> joelr1: well, nothing at the moment, but I'll look at it
02:33:13 <Cale> I'm not sure if that library is quite designed to be up to the task of doing what you're trying to do in an efficient way
02:34:28 <joelr1> Cale: how come everyone focuses on _that_ ? :-) it's quite efficient in that it runs in under 1s in proper circumstances ;)
02:34:45 <Cale> :)
02:34:49 <Cale> well, that's true
02:34:56 <joelr1> Cale: but... i would gladly go with something like musasabi 's binser or SerTH except that my wire format differs from my haskell representation
02:35:06 <Cale> You do admit then that you're pushing it rather hard :)
02:35:29 <earthy> ;)
02:35:51 <musasabi> @seen Pupeno
02:35:52 <lambdabot> I saw Pupeno leaving #haskell 2 hours, 26 minutes and 57 seconds ago.
02:38:30 <joelr1> Cale: yes, i do. i have no choice. 
02:38:51 <joelr1> Cale: can you help me figure out how to retrofit it for use with musasabi 's binser?
02:38:56 <joelr1> @google binser
02:38:57 <lambdabot> http://www.ameinfo.com/68943.html
02:39:02 <joelr1> no, wrong
02:39:10 <Cale> I'm almost completely unfamiliar with both, but I could try :)
02:39:13 <joelr1> musasabi: where's binser on the web?
02:39:38 <joelr1> Cale: the concept that musasabi uses is basically the same, he has converters (wrap), endian things, etc.
02:40:07 <joelr1> the only difference is that he builds the spec as a list of a :+: b :+: NIL
02:40:42 <joelr1> http://cs.helsinki.fi/u/ekarttun/haskell/test.hs
02:40:45 <joelr1> this is an example
02:41:14 <joelr1> and then there's 
02:41:14 <joelr1> http://cs.helsinki.fi/u/ekarttun/haskell/test.hs
02:41:16 <joelr1> err
02:41:19 <joelr1> this bit
02:41:20 <joelr1> http://cs.helsinki.fi/u/ekarttun/haskell/test.hs
02:41:32 <joelr1> instance (Serializable a, Serializable b) => Serializable ((:+:) a b) where
02:41:32 <joelr1>   encode (a :+: b) = encode a >> encode b
02:41:32 <joelr1>   decode = do a <- decode
02:41:32 <joelr1>               b <- decode
02:41:32 <joelr1>               return (a :+: b)
02:41:35 <joelr1> there
02:42:21 <joelr1> why i fail to grasp is how to convert from that and into my constructors
02:42:41 <kzm> @seen shapr
02:42:42 <lambdabot> shapr is in #haskell and #ScannedInAvian. Last spoke 10 minutes and 59
02:42:42 <lambdabot> seconds ago.
02:42:48 <shapr> kzm: You screamt?
02:42:55 <kzm> Whoops
02:43:07 <kzm> You startled me :-)
02:43:13 * shapr boings furiously.
02:43:44 <kzm> I was wondering about wiki policy - is there any rules for how/when/what to update? 
02:44:00 <kzm> (You've probably seen my message to the list?)
02:44:14 <shapr> The message about page ownership?
02:44:16 <Cale> joelr1: hmm
02:44:19 <shapr> I've been meaning to respond to that one...
02:44:39 <kzm> Okay.  I hesitate to mangle other people's stuff.
02:44:56 <shapr> Well, it's not other people's stuff, it's the community's stuff, and you're part of the community.
02:45:29 <shapr> So I'd say it's more your obligation to improve community content when such an improvement will benefit the newbies of the future.
02:46:00 <kzm> Well, personally, I'd object to people modifying my archived messages to the list - even if it would benefit newbies.  
02:46:10 <shapr> Not me.
02:46:18 <greenrd> wiki pages generally don't have owners
02:46:36 <kzm> Well, they are often signed, and the wiki encourages that practice, I think.
02:46:38 <Cale> kzm: if there's a discussion, you can delete it if you summarize it completely
02:46:41 <shapr> In fact, I'd happily modify just about anything if I felt it would benefit the greater good (and remain legal).
02:47:04 <Cale> the signatures are just to let people know who they're talking to, it's not really to stake a claim
02:47:25 <kzm> Cale, and if I don't summarize it completely?
02:47:34 <shapr> kzm: For me at least, a signature means "If you find info that is better/clearer/etc than this, you might consider sending me a message so I can know that too!"
02:47:51 <shapr> g'day ForgeAus, learning Haskell?
02:47:52 <ForgeAus> hacksell? is that like a hack of pascal or something?
02:47:54 <Cale> kzm: then you probably should try to keep the old version around, or at least the bits of it which would otherwise be lost
02:47:59 <shapr> ForgeAus: Yeah, something like that.
02:48:03 <ForgeAus> learning, um... sure whats about it?
02:48:07 <ForgeAus> I know some pascal does that help?
02:48:12 <greenrd> I think it would be ok to just remove a signature if you modify some signed text. so as to not imply that that person wrote this version.
02:48:13 <Cale> hehe
02:48:13 <shapr> It could help you, yes.
02:48:27 <Cale> ForgeAus: it's actually quite a different programming language from Pascal :)
02:48:34 <kzm> I stumbled on "HaskellNewbie_2fHaskellInterpreterUsage" - I think it is a good example.  How would one summarize such a hodge-podge of questions, tips, random musings, etc?
02:48:55 <ForgeAus> Cale... most languages I come across allow you to dimension/set/whatever a variable/identifyer... 
02:49:09 <shapr> kzm: You just make the improvements you see, and leave the rest for someone else to improve.
02:49:09 <ForgeAus> run a function/procedure/subroutine/whatever u wanna call it in that language
02:49:20 <ForgeAus> and um.. assign values... 
02:49:25 <Cale> ForgeAus: you're going to find Haskell different then :)
02:49:28 <ForgeAus> (thats kinda the simplest bit)
02:49:31 <shapr> ForgeAus: What about math equations? Can they do that too?
02:49:44 <ForgeAus> shapr, why? they're not like postfix or something are they?
02:49:48 <greenrd> ForgeAus, You can do all those things in Haskell... just not in the way you'd expect
02:50:07 <Cale> kzm: the safest thing to do is to add a summary at the top
02:50:12 <shapr> Can you run functions, assign values, etc in an equation?
02:50:15 <ForgeAus> (afterall all the operators really are is a function)
02:50:21 <Cale> kzm: and let it devolve into all that later on
02:50:22 <kzm> shapr, okay.  But I think you really should post a reply to the mailing list, as there is at least one person who felt the same way.
02:50:23 <ForgeAus> in C++/C# you can
02:50:30 <ForgeAus> if (x=3)>5 is valid
02:50:41 <ForgeAus> it obviously isn't bigger than 5 tho
02:50:57 <ForgeAus> still the expression evaluates without syntactical error
02:51:04 <kzm> Chances are there are more lurking.
02:51:26 <shapr> kzm: Personally, I advocate the hack and slash approach. Go forth and do what you think will improve the world. If my wiki improvements are not agreed with, or felt to be non-optimal, I expect others to repair/fix/undo/whatever.
02:51:41 <Cale> kzm: A lot of the HaskellNewbie pages are an attempt to declutter such discussion
02:51:42 <shapr> ForgeAus: But what about an equation, like, in school?
02:51:46 <greenrd> ForgeAus, sure
02:51:53 <kzm> Cale, and do they succeed?
02:51:56 <ForgeAus> shapr, give me an example
02:52:02 <Cale> kzm: at one point there was a single Pangaea HaskellNewbie page
02:52:03 <greenrd> ForgeAus, you can use things like STRefs in Haskell, which are kind of like variables, but that's something that people would only use to speed up their Haskell code.
02:52:05 <ForgeAus> like f(x) = x^2 + 1?
02:52:09 <boegel> if I want to make sort work on some datatype I created, which Ord actions should I implement ?
02:52:10 <shapr> ForgeAus: Yeah, like that.
02:52:21 <Cale> kzm: so, you can imagine, 20 or 30 times as much clutter
02:52:30 <Cale> I spent a couple of days sorting it out :)
02:52:38 <ForgeAus> well thats just an assignment of an expression
02:52:40 <Cale> But it's not perfect
02:52:50 <shapr> boegel: iirc, compare is the only required method of typeclass Ord
02:52:57 <boegel> is it enough to implement (<) and (==) ? because i'm getting a stack overflow now, and when i implement
02:52:57 <greenrd> ForgeAus, Haskellers generally try to avoid programming in a style which uses assignment statements, because of various advantages that can give you
02:53:02 <[CotL]Godofe_Kei> how do i turn [(Int, String)] -> (Int, [String])???
02:53:09 <kzm> Cale: that is the solution then - just split everything up small enough?  (It's like refactoring in Fortran - just draw a line every N lines, and make it a subroutine) :-)
02:53:18 <tromp_> the number of legal 17x17 Go positions is 9895749638558742166 modulo 18446744073709551577 :)
02:53:19 <Cale> kzm: Preserving the question/answer history is sometimes useful, but summarizing is also important
02:53:23 <ForgeAus> variable = variable2 (squared) + 1
02:53:31 <kzm> Cale: a couple of days is too much for most potential contributors.
02:53:32 <greenrd> ForgeAus, e.g. programs written without assignments can be easier to debug, because of referential transparency
02:53:37 <Cale> kzm: yes
02:53:42 <ForgeAus> Fortran.. wow thats old language isn't it?
02:53:44 <Cale> kzm: which is why I did it :)
02:53:51 <shapr> ForgeAus: ok, so ... consider a language that works like equations in math. Statements just evaluate or simplify.
02:53:54 <kzm> The main problem is, IMHO, that the pages do not always have a clear goal.
02:53:57 <ForgeAus> referential transparency, whats that?
02:54:06 <shapr> kzm: Should they?
02:54:07 <tromp_> morning, folks
02:54:11 <Cale> kzm: well, the wiki isn't just a reference
02:54:11 <shapr> hoi tromp_
02:54:14 <ForgeAus> so its kinda like recursive functions?
02:54:21 <Cale> kzm: it's also a communication mechanism
02:54:30 <greenrd> ForgeAus, it means, you can substitute expressions for other expressions which return the same value.
02:54:32 <boegel> shapr: hmm, but I should get it to work with only implementing (<) and (<=), shouldn't I ?
02:54:34 <shapr> @remember tromp the number of legal 17x17 Go positions is 9895749638558742166 modulo 18446744073709551577 :)
02:54:43 <[CotL]Godofe_Kei> how do i turn [(Int, String)] -> (Int, [String])???
02:54:44 <ForgeAus> variables ARE substitution
02:54:55 <kzm> Compare to wikipedia, where pages represent encyclopedic articles.  Everybody has a - mostly similar - view on what they should look like, and aim towards that.
02:55:00 <greenrd> ForgeAus, You can't do that in C or C# or C++ because evaluating the expression might have side-effects (it might call "procedures" which do IO, for example).
02:55:09 <Cale> ForgeAus: rand()
02:55:17 <kzm> shapr, yes, I think they should.  In particular, they shouldn't try to be a web forum or mailing list.
02:55:24 <shapr> kzm: Why?
02:55:25 <Cale> ForgeAus: I can't substitute rand() with its return value.
02:55:42 <Cale> ForgeAus: or getChar
02:55:46 <ForgeAus> Cale, you can assign rand() to a value and use that static value .. not to random tho
02:56:00 <kzm> shapr, because otherwise they end up in a rats nest of information, questions, and unrelated stuff.  It is hard to find what you look for, and hard to clean up or improve.
02:56:04 <Cale> ForgeAus: well, I can't do it and preserve the meaning of my program
02:56:15 <ForgeAus> still its assigned to a variable (that kinda works as a constant from then on without rerunning the rand() assignment again)
02:56:34 <tromp_> you can turn  [(Int, String)] into ([Int], [String])
02:56:39 <shapr> kzm: Well, everything is related from some viewpoint.
02:56:41 <boegel> [CotL]Godofe_Kei:: you can't, which value would you give to the int ?
02:56:41 <Cale> ForgeAus: Haskell doesn't have this sort of thing (it handles random numbers and IO differently)
02:56:47 <araujo> @index all
02:56:48 <lambdabot> Data.List, Prelude
02:56:55 <ForgeAus> kewl
02:57:12 <ForgeAus> so is hello world complex?
02:57:26 <tromp_> print "hello, world"
02:57:29 <kzm> shapr, cale: Fair enough - I think I've made my point, so I won't press it.
02:57:35 <shapr> kzm: For example, the original wiki has programming as its subject, but it also has pages on TheMentalStateCalledFlow, since that relates, and AttentionDeficitDisorder is related to attention, and...
02:57:35 <ForgeAus> thats simple :)
02:57:35 <Cale> ForgeAus: if you evaluate a function in your code, and get a value, you could splice in that value in place of the function call, and be sure that your program is the same
02:57:40 <sieni> ForgeAus: Haskell is a functional programming language (http://en.wikipedia.org/wiki/Functional_programming). As opposed to Lisp and Scheme (which uses strict evaluation ("call by value") and dynamic typing) and SML/Ocaml (which use call by value and static typing), Haskell uses lazy evaluation ("call by name") combined with static typing
02:57:43 <ForgeAus> looks like logo
02:57:49 <ForgeAus> ahh PYTHON can be functional!
02:57:57 <ForgeAus> I didn't get what it meant about that tho
02:58:05 <Cale> ForgeAus: but not quite to this extent
02:58:08 <sieni> does Python have real closures?
02:58:09 <ForgeAus> I dunno much about sml, scheme or lips
02:58:16 <shapr> kzm: Yes, but I think that a wiki is just a collaborative editing tool. It's not an anythingpedia or a mailing list or whatever. You can do anything you want with it.
02:58:19 <Cale> let's have a look at some real haskell code :)
02:58:19 <ForgeAus> closures? whats them?
02:58:24 <Cale> > map (+1) [1,2,3,4,5]
02:58:25 <lambdabot> [2,3,4,5,6]
02:58:28 <ForgeAus> I just know you can do some functional programming in python thats all
02:58:34 <kzm> shapr, I'm not really talking about a restriction of topic, but an agreement of form and perhaps scope (of individual pages).
02:58:46 <Cale> > let f x = x * x in map f [1,2,3,4,5]
02:58:47 <lambdabot> [1,4,9,16,25]
02:58:53 <sieni> ForgeAus: http://en.wikipedia.org/wiki/Closure_(computer_science)
02:58:59 <Cale> ForgeAus: that's some example Haskell code for you
02:59:09 <shapr> kzm: You are free to apply your ideas of structure to the existing wiki content.
02:59:15 <Cale> here, I have a function map, which takes a function, and a list
02:59:21 <kzm> shapr, technically, yes, but in practice, I think it is more useful if there is some structure to it.
02:59:31 <shapr> Why?
02:59:35 <Cale> and it returns the result of applying that function to every element of the list
02:59:58 <ForgeAus> erm that language is a bit over my head on the closure webpage
03:00:00 <shapr> kzm: I'm being devil's advocate, not trying to be irritating :-)
03:00:10 <kzm> shapr, sure, I can mold it in my image, but that is *exactly the problem*.  Everybody can follow their own standard.
03:00:14 <Cale> ForgeAus: don't worry too much about that for now
03:00:31 <Cale> ForgeAus: if you'd like to play with Haskell...
03:00:32 * kzm is not annoyed.
03:00:36 <shapr> kzm: Also, I live on the edge of chaos in my everyday, life and I personally see very little need for 90% of the structure I see in daily life.
03:00:54 <kzm> shapr, but do you understand what I am saying?
03:00:57 <Cale> ForgeAus: there's the bot here, which evaluates simple expressions, but I'll recommend the following wiki page as a starting point
03:01:04 <shapr> kzm: So, why not just let people mold stuff into their own image? After awhile, conventions will emerge.
03:01:05 <kzm> If you don't agree, that's fair enough.
03:01:08 <Cale> http://haskell.cs.yale.edu/hawiki/FirstSteps
03:01:14 <Cale> er
03:01:20 <Cale> yeah, that URL works
03:01:30 <ForgeAus> ahh GHC, got that!
03:01:46 <shapr> kzm: I don't disagree, you may be right for the majority of Haskellers, but that specific conclusion is not right for me.
03:02:03 <kzm> shapr, ...after a while, you will have lost everybody who disagrees. :-/
03:02:10 <Cale> ForgeAus: I highly recomment "Yet Another Haskell Tutorial"
03:02:38 <shapr> kzm: Nah, the wiki is not the only community resource. There's #haskell, the mailing lists, newsgroups, static documents, research papers, and much more.
03:02:41 <kzm> It is important to have low barriers.  For me it is *much* easier to hack a darcs'ified program, than something less easily available.
03:02:45 <Cale> kzm: structure is good, but it's better worked out after we know what the content is :)
03:02:45 <ForgeAus> wow just clicked on that link
03:02:57 <ForgeAus> this is weird you can do stuff on the lhs of ur assignment!
03:03:20 <Cale> ForgeAus: it's not an assignment :)
03:03:26 <ForgeAus> oh ok
03:03:37 <shapr> kzm: Funny anecdote... the dirt paths around my house don't follow the sidewalks. I heard that when MIT builds a new building, they wait for a few weeks and put sidewalks on top of the resulting dirt paths.
03:03:40 <ForgeAus> the = has another function in haskell?
03:03:48 <Cale> ForgeAus: think about = from math
03:03:56 <Cale> it's closer to that
03:04:13 <ForgeAus> ok wlel I know what = is (or oyu mean more like == aka equivalence?)
03:04:28 <kzm> Well, I'm just trying to point out that the wiki probably loses edits by not having a lower (psychological) threshold for modification.  If that is a conscious decision, I'm not telling anybody to do otherwise, but I do want to hear that, yes, it is indeed a conscious decision.
03:04:30 <shapr> kzm: For me, more structure means less easily available.
03:04:32 <Cale> math doesn't distinguish between those
03:04:43 <[CotL]Godofe_Kei> whats that web page wher u can paste ou code?
03:04:48 <shapr> @paste
03:04:48 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:04:49 <ForgeAus> well then "is equal to"
03:04:52 <shapr> lisppaste2: url
03:04:52 <Cale> In Haskell, when you write f x = x + 2
03:04:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:04:55 <ForgeAus> hows that diff from assignment?
03:05:04 <Cale> you're asserting that x + 2 and f x are the same thing
03:05:07 <joelr1> Cale: i just had a revelation!!!
03:05:18 <Cale> Really, there is more to it than that
03:05:40 <Cale> When defining a function, it has to go on the LHS so that Haskell knows what thing it is that you're defining
03:05:48 <Cale> x + 2 = f x is a definition of +
03:05:49 <shapr> kzm: Though I readily admit that most people need to work within a known framework.
03:06:12 <shapr> Though I find that idea silly, I am aware that I am not the average person.
03:06:15 <Cale> ForgeAus: x = x + 1 is an infinite loop
03:06:29 <Cale> because then x = (x + 1) + 1
03:06:38 <kzm> shapr, I must admit I have a hard time believing that less structure is better.  Did you ever read a book by cutting it up and randomly assembling its pages?  Or ask for a dictionary where words are in no particular order?
03:06:38 <Cale> and then x = ((x + 1) + 1) + 1
03:06:42 <ForgeAus> yeah
03:06:48 <ForgeAus> in math.... 
03:06:54 <Cale> ForgeAus: and in Haskell
03:06:57 <ForgeAus> its easier to express it as y = x + 1
03:06:58 <greenrd> Haskell is math! ;-)
03:07:04 <Cale> > let x = x + 1 in x
03:07:05 <lambdabot> Exception: <<loop>>
03:07:06 <kzm> Anyway, I shall have to take lunch.
03:07:07 <ForgeAus> for whatever value of y
03:07:15 <kzm> Tschüß!
03:07:16 <Cale> ForgeAus: well, that's not the same thing :)
03:07:21 <shapr> kzm: Ah, but I don't learn from books, and I do randomly read words from a dictionary.
03:07:27 <ForgeAus> cale, ok... 
03:07:34 <Cale> > let y x = x + 1 in y 5
03:07:35 <lambdabot> 6
03:07:41 <ForgeAus> w'ere basically talking infinite recursion here tho
03:07:45 <Cale> yeah
03:07:48 <ForgeAus> with x = (x+1) +1
03:07:53 <Cale> right
03:07:59 <shapr> I learn by doing, and fitting the results into my single mental conceptual map.
03:08:08 <Cale> now, a neat thing about haskell is that it can handle this sometimes
03:08:18 <Cale> > let x = 1 : x in x
03:08:19 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
03:08:19 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
03:08:19 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
03:08:19 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
03:08:19 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
03:08:22 <lambdabot> [23 @more lines]
03:08:31 <greenrd> only 23?
03:08:35 <Cale> : is the operator which adds an element to the front of a list
03:08:41 <ForgeAus> is lambdabot the output of ur expression Cale?
03:08:43 <Cale> (the bot chops output after a while)
03:08:49 <Cale> ForgeAus: yes
03:08:59 <ForgeAus> whats x in x mean?
03:09:04 <Cale> let ... in ...
03:09:05 <ForgeAus> I get let x=1
03:09:10 <Cale> lets you define things locally
03:09:10 <ForgeAus> thats bits obvious
03:09:12 <greenrd> ForgeAus, no you're reading it wrong
03:09:14 <Cale> x = 1 : x
03:09:14 <Lemmih> greenrd: @eval == take 2048 (show expr).
03:09:22 <Cale> : is an operator
03:09:28 <Cale> > 1 : [2,3,4,5]
03:09:29 <lambdabot> [1,2,3,4,5]
03:09:38 <Cale> it adds an element to the start of a list
03:09:39 <ForgeAus> your adding 1  to the start of the list?
03:09:42 <Cale> yeah
03:09:44 <Cale> x = 1 : x
03:09:55 <ForgeAus> so your adding x=1 to the start of the list x? 
03:09:56 <Cale> this means that x is the result of adding 1 to the start of x
03:10:04 <greenrd> so it says "To find out what x is, start with 1, and then compute x".
03:10:09 <Cale> I'm adding 1 to the start of x
03:10:13 <ForgeAus> wait so hows the compiler know where to start?
03:10:20 <Cale> it starts at the start
03:10:22 <greenrd> "...and then add 1 to the start of x."
03:10:23 <ForgeAus> it adds 1 on the front of something undefined
03:10:28 <Cale> right
03:10:31 <Cale> exactly
03:10:34 <Cale> :)
03:10:39 <sieni> ForgeAus: that's the "call by name" thingie
03:10:39 <ForgeAus> uh? I'm confused
03:10:44 <greenrd> It's magic ;)
03:10:51 <Cale> and then it looks at that undefined thing, and hey look, it has a definition
03:10:52 <Cale> !
03:10:59 <ForgeAus> yeah
03:11:03 <ForgeAus> but it never ends
03:11:08 <Cale> it's a 1 added on to something else
03:11:17 <ForgeAus> so how does it actually ever get to an actual evaluation?
03:11:19 <sieni> > take 10 $ let x = 1 : x in x
03:11:20 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
03:11:22 <Cale> but we don't need to work it out to the end
03:11:26 <Cale> to just print the start of the list
03:11:38 <sieni> > take 10 $ let x = 1 : (map (+1) x) in x
03:11:39 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
03:11:54 <Cale> Haskell has the property that it never computes anything which it doesn't need for output
03:12:08 <ForgeAus> isn't that a bit premature?
03:12:13 <Cale> hm?
03:12:23 <ForgeAus> hangon, not sure I can think of an example tho
03:12:25 <ForgeAus> so maybe not
03:12:29 <lisppaste2> Gok pasted "gok" at http://paste.lisp.org/display/14868
03:12:29 <Cale> :)
03:12:30 <ForgeAus> wow.. headspin :)
03:12:33 <Cale> :)
03:12:40 <Cale> it has that effect on people :)
03:12:42 <[CotL]Godofe_Kei> http://paste.lisp.org/display/14868
03:12:55 <Cale> > map (*2) [1,2..]
03:12:56 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
03:12:56 <lambdabot> 52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
03:12:56 <lambdabot> 100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,
03:12:56 <lambdabot> 136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,
03:12:56 <lambdabot> 172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,
03:12:58 <lambdabot> [24 @more lines]
03:12:58 <ForgeAus> (I'm more used to recursive functions the opposite way around)
03:13:12 <ForgeAus> whats map do?
03:13:14 <Cale> I can multiply the infinite list of positive integers by 2
03:13:22 <Cale> it applies a function to every element of a list
03:13:30 <ForgeAus> ok
03:13:41 <ForgeAus> and *2 was the function (expression?)
03:13:44 <Cale> yeah
03:13:52 <Cale> (*2) is a function which multiplies by 2
03:13:56 <ForgeAus> and the ...?
03:14:00 <ForgeAus> before the ]
03:14:03 <ForgeAus> sorry 2 periods
03:14:07 <Cale> oh, that's notation for sequences
03:14:15 <Cale> > take 10 [1,3..]
03:14:16 <lambdabot> [1,3,5,7,9,11,13,15,17,19]
03:14:19 <Cale> > take 10 [1,2..]
03:14:20 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
03:14:21 <ForgeAus> ie in math 1..5?
03:14:22 <Cale> > take 10 [1,1..]
03:14:23 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
03:14:28 <Lemmih> > [1..5]
03:14:29 <lambdabot> [1,2,3,4,5]
03:14:30 <Cale> > [1..10]
03:14:31 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
03:14:37 <Cale> > [2,4..10]
03:14:38 <lambdabot> [2,4,6,8,10]
03:15:03 <Cale> should give you some idea :)
03:15:19 <Cale> It works with other kinds of numbers and enumerations too.
03:15:23 <Cale> > ['a'..'z']
03:15:23 <SlowByte> > take 10 $ repeat "spam"
03:15:24 <Forgacius> (I got dissed)
03:15:24 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
03:15:25 <lambdabot> ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam"]
03:15:27 <SlowByte> :)
03:15:36 <Forgacius> yeah I get 'a'..'z'
03:15:42 <shapr> Forgacius: So like I said, it's a lot like Pascal ;-)
03:15:43 <Forgacius> its like in math 1..5 = set of 1,2,3,4,5
03:15:43 * shapr grins evilly
03:15:48 <Forgacius> yeah Pascal arrays
03:15:55 <Cale> shapr: hehe
03:16:12 <[CotL]Godofe_Kei> in case anyone hasnt noticed ---> http://paste.lisp.org/display/14868
03:16:34 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
03:16:35 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
03:16:35 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
03:16:35 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
03:16:35 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
03:16:35 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
03:16:37 <lambdabot> [24 @more lines]
03:16:43 <Lemmih> [CotL]Godofe_Kei: I can't make sense of what you've pasted.
03:16:50 <ski> that's the infinite list of all primes
03:16:50 <Forgacius> so take 10 obviously limits how many in the array whats the $ symbol?
03:16:51 <[CotL]Godofe_Kei> lololol
03:16:51 <Cale> there's the infinite list of primes :)
03:16:56 <Lemmih> [CotL]Godofe_Kei: It looks like a bunch of numbers to me.
03:17:01 <[CotL]Godofe_Kei> turn one thing iinto another
03:17:07 <[CotL]Godofe_Kei> if u look closely
03:17:08 <ski> Forgacius : 'take' extracts some intitial part of a list
03:17:14 <Forgacius> heeh haskall sounds like it'd be kewl for evaluating pi! :)
03:17:16 <ski> > take 10 [0..20]
03:17:17 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
03:17:20 <ski> > take 10 [0..]
03:17:21 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
03:17:22 <Cale> $ is just function application, but it has really low precedence, lets you avoid parens
03:17:28 <[CotL]Godofe_Kei> there are a bunch that start with 1, otherw with 2 and others with 3
03:17:31 <Cale> f $ x = f x
03:17:43 <Cale> but it's like f and x are in parens
03:17:54 <Cale> (if they happen to be whole expressions)
03:17:54 <[CotL]Godofe_Kei> i want to gather all the ones that start with 1 inside [(1, .............),2(............]
03:17:55 <[CotL]Godofe_Kei> etc
03:18:03 * ski thinks it's not necessary to introduce '$' at this point
03:18:09 <Cale> ski: he asked
03:18:12 <Forgacius> so can haskell do  relations?
03:18:20 <Forgacius> like x + y = 4? (for a circle)
03:18:20 <Cale> > 5 < 7
03:18:21 <lambdabot> True
03:18:23 <Cale> oh
03:18:34 <Cale> well, you're limited somewhat
03:18:42 <SlowByte> equations, you mean?
03:18:46 <ski> Forgacius : itym 'x*x + y*y = 4'
03:18:51 <Forgacius> slowbite, relations are special equations
03:18:56 <Cale> there's still a difference between declaration and equality testing
03:19:03 <Forgacius> oh yeah
03:19:04 <Forgacius> sorry
03:19:08 <Forgacius> forgot the ^2
03:19:14 <Lemmih> > groupBy (\a b -> fst a == fst b) [(1,"hello"),(1," world"),(2,"txt")]
03:19:15 <lambdabot> [[(1,"hello"),(1," world")],[(2,"txt")]]
03:19:29 <[CotL]Godofe_Kei> hmm
03:19:30 <[CotL]Godofe_Kei> no
03:19:39 <Cale> x + 3 = 5 (perhaps unfortunately), won't let you say that x = 2
03:19:44 <Lemmih> > map (concatMap snd) $ groupBy (\a b -> fst a == fst b) [(1,"hello"),(1," world"),(2,"txt")]
03:19:45 <lambdabot> ["hello world","txt"]
03:19:49 <Cale> well, hehe
03:19:49 <ski> > take 10 (let x = 1 : x in x)
03:19:50 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
03:19:56 <Cale> I'm getting caught up in notation :)
03:19:57 <ski> > let x = 1 : x in take 10 x
03:19:58 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
03:20:06 <ski> Forgacius : those give same thing
03:20:23 <Forgacius> hmmm
03:20:44 <[CotL]Godofe_Kei> it should return  [(1,["hello"," world"]),(2,"txt")]
03:21:09 <Cale> If x + 3 = 5, then I can replace x with 2, but it's not going to solve the equation for me :)
03:21:23 <Lemmih> > map (\((n,x):xs) -> (n,x:map snd xs)) $ groupBy (\a b -> fst a == fst b) [(1,"hello"),(1," world"),(2,"txt")]
03:21:24 <lambdabot> [(1,["hello"," world"]),(2,["txt"])]
03:21:36 <[CotL]Godofe_Kei> thx m8
03:21:41 <Forgacius> damn that would be handy if u wanted to factorize polynomials :)
03:21:52 <Cale> also, if it occurs on the right hand side like that, it's really a formal parameter, and it means  for all x, x + 2 = 5
03:21:58 <Forgacius> you could find all ur factors ezy
03:22:00 <Cale> (in a declaration)
03:22:04 <ski> Forgacius : equations are used to define functions and other values, in haskell .. one can't define general relations, in same way (that's be logic programming)
03:22:16 <[CotL]Godofe_Kei> whats the $
03:22:17 <[CotL]Godofe_Kei> ??
03:22:31 <Cale> however, Haskell still lets you do some interesting things in this regard :)
03:22:56 <ski> [CotL]Godofe_Kei : 'f x (g a b (h y))' is the same as 'f x $ g a b $ h y'
03:22:56 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
03:22:57 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:23:05 <Cale> check that out :)
03:23:08 <ski> [CotL]Godofe_Kei : it's a shorthand
03:23:12 <[CotL]Godofe_Kei> oh god
03:23:17 <Forgacius> whats the |?
03:23:23 <Cale> such that
03:23:27 <Forgacius> and the -<
03:23:31 <Forgacius> grr <- lol
03:23:32 <ski> ([CotL]Godofe_Kei : if you wanna know details, then it's an operator)
03:23:40 <[CotL]Godofe_Kei> hmm ok thx
03:23:42 <Cale> Do you remember set-builder / set-comprehension notation from math?
03:23:52 <Cale> { x | x < 10 }
03:23:54 <Cale> and such?
03:24:02 <Forgacius> set? no I didn't do set theory
03:24:07 <ski> > [x | x <- [0..10] , even x]
03:24:08 <Forgacius> I know little about them
03:24:09 <lambdabot> [0,2,4,6,8,10]
03:24:14 <Cale> oh, okay
03:24:14 <joelr1> Cale: what do you think of having the sequ's, etc. generate Storable instances?
03:24:24 <ski> > [x | x <- [0..10] , x > 3 , x < 8]
03:24:25 <lambdabot> [4,5,6,7]
03:24:26 <Forgacius> just taht a set is usually a group of numbers
03:24:27 <Cale> joelr1: hmm... you mean, using TH?
03:24:31 <ski> > [x | x <- [0..10]]
03:24:32 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10]
03:24:37 <Forgacius> (theres intersections and unions too)
03:24:45 <Forgacius> but for that you need multiple sets right?
03:24:50 <Cale> yeah
03:24:55 <Forgacius> just extracts same (or diff?) numbers from sets
03:24:56 <ski> > [(x,y) | x <- [0,1,2] , y <- [30,40]]
03:24:57 <lambdabot> [(0,30),(0,40),(1,30),(1,40),(2,30),(2,40)]
03:24:58 <joelr1> Cale: well, no, just modifying the backend and triggering generation or something. in a separate compile/run
03:25:02 <Cale> this notation is called list comprehension notation
03:25:04 <ski> > [x + y | x <- [0,1,2] , y <- [30,40]]
03:25:05 <lambdabot> [30,40,31,41,32,42]
03:25:11 <ski> Forgacius : those are some examples
03:25:16 <Cale> joelr1: hmm :)
03:25:44 <Forgacius> ski thats like matricies
03:25:45 <Forgacius> ur first one anyhow
03:25:55 <ski> Forgacius : you could think of the '<-' as making a loop, so to speak .. so when i use two '<-' there, it's like nested loops
03:26:22 <Forgacius> so x <- [0,1,2] is like for x = 0 to 2 do?
03:26:24 <[CotL]Godofe_Kei> any web page i can read about groupBy?
03:26:38 <Cale> Forgacius: yeah, and the part before the | is what to return
03:26:41 <Forgacius> just each value is separately literate
03:26:43 <ski> Forgacius : yes, that's what it does more or less, here
03:26:52 <Cale> > [ x^2 | x <- [0,1,2] ]
03:26:53 <lambdabot> [0,1,4]
03:26:54 <Forgacius> grr literal
03:27:01 <Cale> > [ x^2 | x <- [0..10] ]
03:27:02 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100]
03:27:15 <Forgacius> so its basically backwards c
03:27:19 <Cale> hehe
03:27:21 <Forgacius> (loops are anyhow)
03:27:22 <ski> "for each value of x taken from [0..10], make the list of squares of x"
03:27:36 <ski> > [ x^2 | x <- [0..10] , even x]
03:27:37 <lambdabot> [0,4,16,36,64,100]
03:27:39 <Forgacius> ski that I get
03:27:46 <ski> "for each value of x taken from [0..10], that is also even, make the list of squares of x"
03:27:54 <Cale> yeah, and instead of executing a bunch of code, it just produces a value in the list.
03:28:04 <Forgacius> even how, even numbers, 2, 4, 6, 8? or something else?
03:28:22 <ski> even x = (x `mod` 2 == 0)
03:28:25 <Cale> well, the part before the | could kind of be considered the code to execute, but you're limited to expressions :)
03:28:36 <Forgacius> ski uh?
03:28:41 <Cale> yes
03:28:47 <Cale> > even 0
03:28:48 <lambdabot> True
03:28:49 <Cale> > even 1
03:28:49 <ski> even is just a function that returns bool
03:28:50 <lambdabot> False
03:28:52 <Cale> > even 2
03:28:53 <lambdabot> True
03:28:58 <ski> > map even [0..10]
03:28:59 <lambdabot> [True,False,True,False,True,False,True,False,True,False,True]
03:29:02 <Forgacius> yeah I know true and false
03:29:10 <Forgacius> ahh so even numbers return true
03:29:17 <Cale> yes
03:29:35 <ski> Forgacius : to the right of '|', there, we can put '<-' thingies (called generators), and also we can put boolean tests
03:29:45 <Forgacius> kinda like just looking at the last digit of consecutive binary :)
03:29:51 <Forgacius> only opposite
03:29:52 <Cale> Forgacius: yep
03:30:14 <ski> > [ x^2 | x <- [0..10] , x > 3 , x < 8]
03:30:15 <lambdabot> [16,25,36,49]
03:30:19 <Cale> (well, depends on how you map 0 and 1 to true and false :)
03:30:24 <Forgacius> whats the , ?
03:30:29 <ski> "for each value of x taken from [0..10], that is larger than 3, and also lesser than 8, make the list of squares of x"
03:30:33 <Forgacius> lol cale true
03:30:37 <ski> Forgacius : read it as "and"
03:30:40 <Forgacius> it gets confuzzling in reverse tho
03:30:51 <ski> you can also read it as
03:30:59 <Cale> If you read it like ski is saying, it's not in reverse :)
03:31:08 <Cale> well
03:31:11 <Cale> [ x^2 | x <- [0..10] , x > 3 , x < 8]
03:31:16 <ski> "collect the squares of x in a list, when x is taken from [0..10], that is larger than 3, and also lesser than 8"
03:31:21 <Forgacius> so for x is the values 1 , 2, 3, 4, 5, 6, 7, 8 ,9 ,10 and x > 3 and x < 8 do x= x^2?
03:31:32 <Forgacius> shouldn't instead of it being and be where???
03:31:36 <Cale> the list of x^2 where x is drawn from [0..10], x is greater than 3 and x is less than 8
03:31:45 <ski> yes, better
03:32:05 <Forgacius> so each consecutive , is kinda like a where also 
03:32:10 <Cale> > [x^2 | x <- [0..10], x > 3 && x < 8]
03:32:11 <lambdabot> [16,25,36,49]
03:32:18 <Cale> you can still do it that way too
03:32:20 <Forgacius> so it ignores the 0,1,2 right?
03:32:28 <Cale> right
03:32:36 <Forgacius> and 9,10 obviously
03:32:37 <Cale> and then 4 > 3
03:32:46 <Cale> so you get 16 = 4^2
03:32:57 <Cale> and then 5,6,7, and not the others
03:33:34 <Forgacius> brb
03:33:42 <Cale> lists in Haskell basically take the place of loops in many other programming languages
03:35:36 <ski> > map (* 10) [0..9]
03:35:37 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
03:35:47 <ski> > [x * 10 | x <- [0..9]]
03:35:48 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
03:38:59 <Cale> well, half the place of them anyway, the other half being the higher order functions like map which bring them to life :)
03:39:09 <ski> Forgacius : btw, the '[x * 10 | x <- [0..9]]' stuff with an '|' (and some '<-'-generators and/or tests) is called 'list comprehensions'
03:42:35 <ski> > let foo x = (x > 3 && x < 8) in filter foo [0..9]
03:42:37 <lambdabot> [4,5,6,7]
03:42:51 <ski> > [x | x <- [0..9] , (x > 3 &6 x < 8)]
03:42:52 <lambdabot>  Not in scope: `&'
03:42:59 <ski> > [x | x <- [0..9] , (x > 3 && x < 8)]
03:43:00 <lambdabot> [4,5,6,7]
03:43:05 <ski> hm
03:51:53 <dblhelix> (see haskell-cafe) shouldn't Daniel be invited to #haskell?
03:57:13 * araujo abck from breakfast
04:00:20 <tromp_> recurrence :: [Integer] -> [Integer] -> [Integer]
04:00:20 <tromp_> recurrence coeff basis = rec where
04:00:20 <tromp_>  rec = basis ++ rest
04:00:20 <tromp_>  rest = foldl (zipWith (+)) [0,0..] $ zipWith (map.(*)) coeff $ tails rec
04:00:50 <tromp_> fib = recurrence [1,1] [0,1]
04:02:45 <tromp_> nice that you can efficiently compute any recurrence without arrays
04:03:25 <tromp_> legal1 = recurrence [1,-1,3] [1,1,5]
04:03:41 <tromp_> that's number of legal 1xn Go positions:)
04:10:33 <xinming> ski: ping
04:10:56 <ski> xinming : pang
04:12:33 <xinming> ski: Now, I understand about >>= for Cont Monad more, But there I was still in confusion about why the k will be called last.
04:13:43 <ski> Cont c >>= f = Cont (\k -> c (\a -> runCont (f a) (\b -> k b)))
04:14:14 <ski> 'c' will call it's continuation (lambda expr given as arg), passing 'a'
04:14:47 <ski> 'f a' is the second action, 'runCont' just unwraps the constructor, then that will call it's continuation, passing 'b'
04:14:58 <ski> and that will then continue with 'k', passing 'b' on to it
04:15:18 <xinming> hold on please... I am writing what I was thinking in formula. :-/
04:15:24 <ski> sure
04:19:06 <xinming> ski: haskell-overflow?
04:19:20 * araujo thought this bugs wasn't that easy to fix
04:19:31 * araujo boings
04:19:55 <ski> xinming1983 : if you want
04:23:34 <shapr> Wow, I found a neat bug in imagemagick.
04:24:27 <shapr> When shrinking a 254k png to a smaller image size, the output image is 3.2 mb.
04:24:31 <ProfTeggy> shapr: share
04:24:33 <ProfTeggy> ok
04:24:41 <shapr> ProfTeggy: Hiya! What's up in query land?
04:25:12 <ProfTeggy> shapr: all alive and well (I like query land better than update land because of the apparent lack of side effects ;-)
04:25:17 * shapr grins
04:25:31 <ProfTeggy> Deep into grant proposal writing, though
04:25:44 <ProfTeggy> Need to raise money for the good guys working with me
04:25:53 <shapr> Oh hey, can you tell me where I can find more information on why Oleg's left-fold enumerator query is cooler than the alternatives?
04:26:18 <ProfTeggy> I haven'r read about such a device until today
04:26:21 <ProfTeggy> Let me google
04:26:23 <shapr> http://okmij.org/ftp/Haskell/#takusen
04:26:29 <ProfTeggy> click
04:26:39 <shapr> "The distinguished feature of Takusen is processing query results using a left-fold enumerator."
04:26:40 <ForgeAus> back
04:26:45 <shapr> g'day ForgeAus 
04:26:52 <ForgeAus> gday shapr :)
04:26:54 <shapr> Would you like to learn Haskell? ;-)
04:26:59 <ForgeAus> would I?
04:27:06 <ForgeAus> for what purpose?
04:27:11 <araujo> For fun.
04:27:15 <ski> wb ForgeAus
04:27:20 <ForgeAus> ahh my number 1 purpose :)
04:27:20 <araujo> Plus, all the cool kids are doing.
04:27:43 <ForgeAus> plus I actually have interactive help here
04:27:51 <ForgeAus> how can I say no?
04:27:54 <araujo> :-)
04:28:10 <ski> > [x * 10 | x <- [0..9]]
04:28:11 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:28:11 <shapr> Plus #haskell never asks you to go steady...
04:28:19 <ForgeAus> lol
04:28:22 <ski> > map (* 10) [0..9]
04:28:23 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:28:28 <shapr> I use Python in my daily paying work.
04:28:29 <sieni> nice books about haskell would be nice if they existed
04:28:34 <ski> ForgeAus : those two amounts to the same
04:28:35 <ForgeAus> I like python
04:28:42 <ForgeAus> easy functions, just use def! so simple
04:28:43 * sieni uses C
04:28:51 <shapr> Python was my first love, but I want to marry Haskell.
04:29:13 <araujo> > [0 .. 9] >>= return . (* 10)
04:29:13 <ForgeAus> Pascal was my first love
04:29:14 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:29:18 <ForgeAus> Python my second.. 
04:29:27 <gour> shapr: and stay forever together?
04:29:31 <sieni> I'll probably get married with SML :-)
04:29:32 <xinming1983> I will marry both(perl and haskell)... :-)
04:29:33 <ForgeAus> unfortunately basic my companion :(... C... the prize I wanted... 
04:29:33 <sieni> *ducks*
04:30:03 <shapr> gour: Probably...
04:30:17 <shapr> But I'm casting flirtatious eyes at the proof programming world these days.
04:30:30 <shapr> Too bad it doesn't really exist.
04:30:37 <ForgeAus> proof programming?
04:30:40 <gour> shapr: do you, shapr, present here, promise to marry haskell and stay with ... until the end of your life?
04:30:43 <shapr> I guess I'll have to manufacture my own mistress in that case.
04:30:44 <ForgeAus> hmmm isn't aspect oriented all the rage?
04:30:59 <shapr> ForgeAus: Dude, emacs has been doing AOP for decades.
04:31:11 * gour notices shapr is not 100% sure he found his love :-)
04:31:14 <ForgeAus> I Wouldn't know, emacs is foreign to me
04:31:26 <ForgeAus> plus AOP is also foreign to me... 
04:31:33 <shapr> AOP is just pre,post, and around calls.
04:31:57 <earthy> um. no.
04:32:09 <shapr> Proof programming is where you use a proof assistant to create a mathematical proof and then generate executable code from that.
04:32:14 <shapr> earthy: Ok, talk to me...
04:32:22 <ForgeAus> shapr you mean programming by contract?
04:32:36 <shapr> Nah, that's design by contract from Eiffel.
04:32:43 <ForgeAus> heeh yeah eiffel
04:32:48 <araujo> ForgeAus, that is not mathematical proofs.
04:32:49 <ForgeAus> kinda pascal-like
04:33:01 <earthy> AOP is the ability to hook into the program execution, and modify code at certain predefined points in the execution
04:33:13 <shapr> earthy: Right, pre/post/around hooks.
04:33:25 <bojohan> [AOP] `After he delivered the punchline solution he stopped and looked at us expectantly. We all just sat there. He waited. We sat. Finally he almost complained: "When I show this to Java users they stand up and cheer." We sat.' -- comp.lang.lisp
04:33:26 <earthy> this can be e.g. in pre function call, post function call, around function call positions
04:33:54 <earthy> but it can also be e.g. in class instantiation positions, or expression evaluation positions
04:33:58 <ForgeAus> lol bojahan if I understood that it'd most definitely be humerous!
04:34:27 <shapr> Personally, I believe that monads do lots more than AOP. Maybe I'll write more about that sometime.
04:34:35 <ForgeAus> monads?
04:34:42 <araujo> shapr, sometimes not, do it now!
04:34:49 <shapr> ForgeAus: They're the power tools of Haskell.
04:34:50 <earthy> um, functional programming generally does not really need AOP
04:35:01 <shapr> ForgeAus: You have to be patient until you get to the the *really* cool parts.
04:35:09 <pejo> earthy, so you can add an aspect to "add x y" which always sets x = 1, regardless of input?
04:35:14 <kolmodin> > liftM (*10) [0..9]
04:35:15 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:35:19 <earthy> however, having hooks into the reduction machinery can still be usefule
04:35:31 <ForgeAus> they do say patience is a virtue
04:35:35 <earthy> pejo: that would be one possible use of aspect oriented programming, yes.
04:35:40 <shapr> Not that I've ever been patient.
04:35:54 <ForgeAus> I've been A patient
04:35:56 <shapr> The most common motivational example of AOP is a logging framework.
04:35:59 <shapr> heh!
04:36:04 <ForgeAus> hospitals aren't all that fun
04:36:14 <shapr> ForgeAus: Hey, I like your kind of humor...
04:36:32 <ForgeAus> I just like to play with words
04:36:33 <shapr> Sick puns... fresh from the hospital.
04:37:17 <shapr> ForgeAus: Anyway, do you know the Curry-Howard correspondance?
04:37:23 <shapr> aka the Curry-Howard isomorphism?
04:37:28 <ForgeAus> um... nope
04:37:34 <ForgeAus> its not familiar at least not by name
04:37:41 <shapr> ProfTeggy: Any idea why takusen is cool? I really don't dig it.
04:37:57 <shapr> ForgeAus: http://en.wikipedia.org/wiki/Curry-Howard
04:38:07 <shapr> Roughly, mathematical proofs and computer programs are the same thing.
04:38:39 <shapr> ForgeAus: And you thought today would be boring...
04:38:50 <ForgeAus> lambda calculus.. wow.. now that IS over my head
04:38:56 <ForgeAus> I never got that far in maths
04:39:04 <shapr> ForgeAus: No way, lambda calculus is about as hard as tic tac toe.
04:39:06 <ForgeAus> heck I had to teach myself logarithms!
04:39:26 <shapr> Me too!
04:40:02 <shapr> Anyway, lambda calculus has abstraction and application...
04:40:10 <ski> (scary names)
04:40:10 <ForgeAus> is that what the lambda keywoard in Python means?
04:40:15 <shapr> ForgeAus: you got it..
04:40:16 <ski> yes
04:40:31 <ForgeAus> (hehe I only noticed the relationship I don't know how it works)
04:40:51 <shapr> abstraction means 'set us up the arguments' and application means roughly 'execute'
04:41:10 <ski> ForgeAus : did you want to see some more small examples of code in haskell with list comprehensions ?
04:41:14 <ForgeAus> I also know it as a greek letter but thats something else
04:41:20 <ForgeAus> sure ski
04:41:25 <shapr> For example, \x -> x means get an argument x, and evaluate to the x.
04:41:43 <shapr> application is something like (\x -> x) 1
04:41:47 <ski> > [x * 10 | x <- [0..9]]
04:41:48 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:41:54 <ski> ForgeAus : you got that example, right ?
04:42:05 <shapr> Then the 1 gets put into the place of the x, and the result is... 1
04:42:18 <ForgeAus> wait wait too much at once (still reading wikipedia on lambda calculus)
04:42:26 <ForgeAus> just catching up here
04:42:45 <twb> \x->x is the same as Church's \x.x
04:42:51 <shapr> ForgeAus: You've got two pieces in lambda calculus, or three if you count parens.
04:43:11 <ForgeAus> the \ symbol and ur expression
04:43:14 <twb> shapr: function definition, function application and function composition (that's the parens)
04:43:19 <shapr> yup
04:43:21 <ForgeAus> still ski's example I understand
04:43:29 <ForgeAus> we talked about tha before like a simple for loop
04:43:32 <ski> > map (* 10) [0..9]
04:43:34 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:43:42 <araujo> > [0 .. 9] >>= return . (* 10)
04:43:44 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
04:43:51 <shapr> twb: Yeah, I liked the introduction in TaPL.
04:43:53 <ForgeAus> hangon wait map is doing the same
04:43:57 <ski> araujo : don't confuse him, now :)
04:44:02 <ski> ForgeAus : yes
04:44:04 <ForgeAus> hmm ho wmany ways can you get the same result?
04:44:12 <ski> intinitely
04:44:15 <earthy> timtowtdi. :)
04:44:15 <ForgeAus> map applies the function ot all its elements
04:44:18 <twb> TaPL?
04:44:19 <ski> but most of them are very large
04:44:23 <ForgeAus> we mentioned that before
04:44:27 <ski> yes
04:44:33 <araujo> ski, :-]
04:44:34 <shapr> twb: Types and Programming Languages by Pierce, it's way cool.
04:44:40 <shapr> Oh, my unicycle is calling me...
04:44:42 <ForgeAus> [ 0 .. 9 ] >>= return . (*10) I didn't understand tho
04:44:51 <shapr> joelr1: Unicycles!
04:44:55 <earthy> forgeaus: no problem. that's horribly convoluted anyway
04:44:58 <ski> ForgeAus : that's just araujo confusing you, now
04:45:00 <joelr1> folks, how can i unrecord patchs in my darcs repo?
04:45:02 <ForgeAus> hehe 
04:45:06 <ski> now, we might want to do other things than just multiply by 10
04:45:10 <twb> shapr: is it available online?
04:45:10 <araujo> ForgeAus, didn't want you to confuse :-(
04:45:13 <ForgeAus> ski I find if I understand the complex, the simplep becomes easy
04:45:16 <shapr> joelr1: darcs help unrecord
04:45:21 <joelr1> liked say i severely f...d things up but it was several levels of patches ago
04:45:26 <ski> > [x * x | x <- [0..9]]
04:45:27 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:45:34 <joelr1> shapr: doesn't that do 1 level?
04:45:35 <shapr> joelr1: And always work on a copy of your repo.
04:45:41 <ski> ForgeAus : now lets rewrite this to use 'map' instead, ok ?
04:45:48 <joelr1> shapr: i have a copy of my repo
04:46:08 <shapr> joelr1: Look at the help, you can use regexes, or the last N patches, or etc
04:46:11 <xinming1983> > map (\x -> x*x) [0..9]
04:46:12 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:46:14 <shapr> twb: Nope, but it's worth buying.
04:46:14 <joelr1> shapr: i'm just trying to figure out how i can unrecord the various patches
04:46:20 <joelr1> shapr: ok, thanks
04:46:21 <ski> xinming1983 : too fast :)
04:46:35 <twb> shapr: I am but a poor student.
04:46:37 <xinming1983> ski: ;-)
04:46:44 <shapr> twb: At this point I recommend three books to all beginning programmers: SICP, tPP, and TaPL.
04:46:47 <pejo> twb, the better reason to only buy the good books!
04:46:47 * twb hugs SICP
04:46:59 <ski> > let foo x = x * x  in  map foo [0..9]
04:47:00 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:47:01 <shapr> Yeah, I'm not exactly rich myself.
04:47:10 * shapr whines about Swedish taxes...
04:47:15 <xinming1983> twb: if you are not rich, many sites are useful documentation for haskell. :-)
04:47:19 * ski 's trying to be pedagogical
04:47:46 <xinming1983> twb: not all people are rich, But If you want to learn, just take any chance to learn. :-)
04:47:51 <araujo> shapr, do you have the site to that book at hand?
04:47:57 <shapr> twb: Seriously though, TaPL totally kicks ass if you're even the least bit interested in type theory.
04:47:59 <ski> ForgeAus : with the help of 'let' i define a function that squares .. then i pass that to 'map' to square every number in the list
04:48:13 <araujo> the link site i meant.
04:48:19 <shapr> http://www.cis.upenn.edu/~bcpierce/tapl/
04:48:23 <araujo> thanks
04:48:34 <ForgeAus> ok
04:48:56 <pejo> shapr, only ~33%!
04:49:01 <sieni> hmm... that has semi-been on my to-buy list
04:49:16 <joelr1> shapr: how can i see the tags on my repo?
04:49:17 <ForgeAus> ski ur function is pretty simple
04:49:19 <shapr> pejo: Unless you're self employed...
04:49:20 <sieni> isn't there a second part to that book as well or something?
04:49:22 <ForgeAus> brings it all together
04:49:30 <ski> ForgeAus : so, the good thing about functional programming languages is that functions are values, too  and you don't need to name every number you have, so why should you need to name every function ?
04:49:47 <ski> 'foo x = x * x' defines a function 'foo'
04:49:52 <araujo> mm...
04:49:53 <earthy> tPP, shaper?
04:49:58 <ForgeAus> ski, because its easier for me to think of a function as a name
04:50:04 <shapr> The Pragmatic Programmer
04:50:08 <earthy> ah
04:50:10 <ski> '\x -> x * x' *is* a squaring function
04:50:11 <pejo> shapr, 'arbetsgivaravgift'?
04:50:12 <ForgeAus> (the name describes it purpose usually)
04:50:15 <twb> ski: no, it binds a function \x-> x*x to foo.
04:50:24 <ski> > let foo = (\x -> x * x)  in  map foo [0..9]
04:50:26 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:50:28 <ForgeAus> can I bind it to square?
04:50:38 <ski> twb : yes, i'm simplifying somewhat
04:50:39 <sieni> or
04:50:46 <ski> ForgeAus : sure
04:50:50 <joelr1> shapr: do you know?
04:50:54 <ForgeAus> square \x-> x*x ???
04:50:54 <sieni> > map (\x -> x * x) [0..9]
04:50:55 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:50:56 <shapr> pejo: I dunno exactly where all the costs go, but the rule of thumb I was given is, after costs, 50% of your income goes to taxes. It really does work out that way.
04:50:58 <ski> > let square = (\x -> x * x)  in  map square [0..9]
04:50:59 <lambdabot> [0,1,4,9,16,25,36,49,64,81]
04:51:08 <shapr> joelr1: Not off the top of my head, but darcs help will probably tell you.
04:51:10 <ForgeAus> can I reuse square?
04:51:15 <ski> ForgeAus : but, as you see from sieni's example, you don't need to name it at all
04:51:16 <ForgeAus> for a diff map?
04:51:27 <ForgeAus> ski I understand I don't NEED to name it
04:51:35 <ski> ForgeAus : you can, if you make it a toplevel definition in your source file
04:51:35 <pejo> shapr, it's probably pretty accurate. Income tax+moms+.., etc.
04:51:56 <ForgeAus> toplevel definition you mean like global?
04:52:21 <ForgeAus> yeah like in ms excel how you can name cells
04:52:32 <ski> ForgeAus : often functions are good to reuse, so one names them .. other times, a function will only every be used once, so it can be clearer to just write it as an anonymous function, using lambda, instead of giving it a name
04:52:43 <ski> '\' is lambda in haskell
04:52:50 <ForgeAus> (basically same as using variables income - tax = nett)
04:53:02 <shapr> pejo: I paid fewer taxes in the USA. I don't really know if I get enough benefit to to offset the lack of control that comes with gov't owned/operated services.
04:53:02 <joelr1> shapr: how can you see all the tags on your repo?
04:53:12 <shapr> joelr1: I don't remember.
04:53:21 <ForgeAus> ski, depends on what better suits program readability I guess uh?
04:53:47 <ski> ForgeAus : in Pascal, you have variables and functions defined at toplevel, but you can also define variables (and functions) inside functions, and those latter are not toplevel .. they are local
04:54:00 <ski> 'let' in haskell makes local definitions
04:54:10 <shapr> pejo: Health conglomerates in the USA were (are?) a lot of trouble, but at least I got to choose whichever one I wanted :-)
04:54:18 <ForgeAus> yeah so haskell's local = let... 
04:54:25 <ForgeAus> thats easy
04:54:52 <shapr> earthy: Have you read tPP, SICP, & TaPL? Any other books you'd recommend?
04:54:53 <gour> joelr1: something like darcs changes -t tagname*
04:55:12 <shapr> Oh, I should check my mail to see if my new unicycle hardware has arrived yet.
04:55:23 <ski> > map (\x -> x + 100*x) [1..9]
04:55:24 <lambdabot> [101,202,303,404,505,606,707,808,909]
04:55:24 * shapr wants to run linux on his unicycle.
04:55:31 <ForgeAus> is (or can) haskell OOP?
04:55:38 <joelr1> but i want to see the tags themselves :)
04:55:40 <ForgeAus> (classes, etc?)
04:55:42 <joelr1> just a list of tags
04:55:53 <shapr> ForgeAus: Yes, but monads do 95% of what OOP does, so you probably won't need it.
04:55:58 <xinming1983> ForgeAus: It might doesn't need oop. :-P
04:56:23 <shapr> @where OOHaskell
04:56:24 <lambdabot> I know nothing about oohaskell.
04:56:27 <shapr> hrm
04:56:36 <ForgeAus> so whats monads?
04:56:47 <ForgeAus> atomic functions/classes?
04:56:48 <sieni> ForgeAus: if you really want oo, then you should look at http://homepages.cwi.nl/~ralf/OOHaskell/
04:57:03 <shapr> @where+ oohaskell http://homepages.cwi.nl/~ralf/OOHaskell/
04:57:03 <lambdabot> Done.
04:57:35 <ski> monads are a bit hard to describe .. (hm, maybe Parsec would be a good example)
04:57:38 <shapr> ForgeAus: Monads are an abstraction.
04:57:52 <xinming1983> ForgeAus: hmm, you could learn the basic of haskell first, and then, learn Monad, and understand it, It's a kind of computation which is really amazing
04:58:04 <shapr> Objects are one approach to composing your problem, monads are another.
04:58:16 <ForgeAus> lol overlooked object system
04:58:24 <ski> Parsec is a library for writing parsers, in a quite intuitive style
04:58:26 <ForgeAus> abstraction? you mean like encapsulation?
04:58:37 <shapr> Nah, encapsulation is one part of abstraction.
04:58:43 <twb> ForgeAus: encapsulation is orthogonal to abstraction.
04:58:45 <ForgeAus> oh you mean the whole box n dice?
04:59:04 <ForgeAus> encapsulation + aggregation + association + etc etc?
04:59:10 <twb> Encapsulation is actually pretty poor in Haskell, except  between modules.
04:59:14 <ForgeAus> (inheritance? .. polymorphism?)
04:59:25 <shapr> Abstraction just means something that lets you hide the boring code so you can work on the interesting part of the problem.
04:59:41 <ForgeAus> lol shapr...
04:59:59 <shapr> You only want to look and think about the code that's involved in whatever you're doing right now.
05:00:01 <dons> @where+ ranged-sets http://sourceforge.net/projects/ranged-sets/
05:00:01 <lambdabot> Done.
05:00:29 <Cale> What do people think of my replies on IO to Haskell cafe?
05:00:35 <ForgeAus> thts what modular programming is all about
05:00:36 <shapr> dons: What about having the url as the first argument and free text as the rest of the @where+ command, then you could do levinshin(sp?) distance, etc
05:00:44 <Cale> Is that a good way to explain things to beginners?
05:00:46 <ForgeAus> using re-usable modules ... 
05:00:59 * gour keeps some of Cale's replies in his archive
05:01:04 <shapr> ForgeAus: Exactly. An abstraction is a way of hiding the infrastructural code in a predictable manner so that you can effectively ignore it.
05:01:06 <twb> Levenstein.
05:01:13 <shapr> twb: thanks.
05:01:17 <Cale> gour: :)
05:01:20 <xinming1983> ForgeAus: trust me, the only one language which I really learn and surprised me is haskell, perl is good enough, but It's the same as C while you must thinking in sequence, but for haskell, you don't,
05:01:23 <ForgeAus> only with oop functions can be included not just the data structure
05:01:23 <dons> shapr, yeah, that's a good idea.
05:01:27 <twb> @google site:monash.edu.au levenstein
05:01:28 <lambdabot> http://journal-ci.csse.monash.edu.au/ci/vol01/blanct01/html/
05:01:35 <twb> @google site:monash.edu.au lloyd levenstein
05:01:36 <lambdabot> search module failed: connect: does not exist (Connection refused)
05:01:42 <twb> Bleh.
05:02:07 <dons> @google lambdabot levenshtein
05:02:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/Util.hs
05:02:08 <Cale> @quit
05:02:15 <Cale> hmm
05:02:19 <dons> Cale?
05:02:21 <Cale> that last one worked
05:02:28 <ForgeAus> ie a queue can be a whole unit...  not just the datatype it is stored in... but the ability to pop, push, etc to/from the queue
05:02:33 <shapr> ForgeAus: Monads are a bit of both... that is, both data structure and function.
05:02:44 <ski> ForgeAus : yes, that's modules
05:02:56 <Cale> dons: just in case lambdabot was in some kind of bad state -- see the odd message from google :)
05:03:04 <dons> yeah, it's an odd message
05:03:08 <araujo> I also like the analogy of a monad being a collector.
05:03:09 <sieni> state? :-)
05:03:23 <sieni> There is no state :-)
05:03:28 <shapr> Haskell separates Church and state.
05:03:29 <Cale> @listcommands
05:03:30 <lambdabot> use listcommands [module|command]. Modules are:
05:03:30 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
05:03:30 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
05:03:30 <lambdabot> seen spell state system todo topic type version vixen where
05:03:33 <shapr> Alonzo, that is.
05:03:36 <Cale> @help state
05:03:36 <lambdabot>  @state - we all know it's evil
05:03:38 <twb> A function with data is a closure.  A closure is a way to implement an object.
05:03:40 <Cale> @state
05:03:52 <shapr> @state Nebraska
05:03:58 <shapr> @state Oklahoma
05:03:59 <lambdabot> Nebraska
05:04:01 <twb> Of course, it's different in a *purely* functional language.
05:04:06 <ForgeAus> twp that actualy makes sense
05:04:07 <shapr> Ok, that is the @state command I wrote years ago...
05:04:25 <ForgeAus> (about the closure being a way to implement an object)
05:04:44 <Cale> ForgeAus: how are you finding things? :)
05:04:50 <shapr> state was the third lambdabot plugin ever written. The first plugin was @hello and the second was a postgresql interface =)
05:04:57 <Cale> hehe
05:04:58 <ForgeAus> sounds kinda like a antecedent vers of instantiation
05:05:10 <ForgeAus> finding things? hmmm.. interesting
05:05:24 <dons> @remember shapr Haskell separates Church and state
05:05:27 <shapr> ForgeAus: Yeah, there's a Zen koan that says "Closures are poor man's objects, but objects are a poor man's closures."
05:06:04 <dons> and now lambdabot has about 40 plugins :)
05:06:16 <shapr> My favorite Zen koan is "The metaclass object in Smalltalk is an instance of an instance of itself."
05:06:26 <Cale> dons: especially as it seems to take you on the order of 10 minutes to write one :)
05:06:32 * shapr grins
05:06:33 <ForgeAus> lol 
05:06:50 <dons> :)
05:06:54 <ForgeAus> smalltalk is like lisp and scheme right?
05:07:08 <shapr> ForgeAus: One thing I prefer about closures over objects is that closures have a 'finite future'
05:07:29 <shapr> ForgeAus: Have you gotten to partial application yet?
05:07:36 <ForgeAus> shapr no
05:07:49 <ForgeAus> print "Hello World!" is the closest I got sofar!
05:08:18 <dons> btw,  lambdabot hit 10k loc sometime in the last week :)
05:08:23 <ski> > map (map (++"!")) ["haskell","is","fun"]
05:08:24 <lambdabot> Couldn't match `[Char]' against `Char'
05:08:26 <ForgeAus> mostly we just been discussing expressions
05:08:26 <Cale> dons: wow
05:08:34 <shapr> Ok, Alonzo Church figured out that any function in lambda calculus that took multiple arguments could instead take one argument and return a new function that takes the rest of the arguments. That works in Haskell as well.
05:08:38 <ski> er
05:09:00 <ski> > map (map (++"!")) [["haskell","is"],["fun"]]
05:09:01 <lambdabot> [["haskell!","is!"],["fun!"]]
05:09:02 <dons> it's now 10,905 loc, 3691 comments (we're catching up, it used to be worse)
05:09:14 <ForgeAus> lol ski
05:09:17 * ski blushes
05:09:18 <xinming1983> > concat $map (map (++"!")) [["haskell","is"],["fun"]]
05:09:19 <lambdabot> ["haskell!","is!","fun!"]
05:09:28 <ski> yes
05:09:30 <ForgeAus> ahh I like the concat vers
05:09:46 <ForgeAus> can you concat them into one string? no ,'s?
05:09:52 <ski> sure
05:10:01 <Cale> (map (++"!")) >>= [["haskell","is"],["fun"]]
05:10:01 <ForgeAus> (with a space between)
05:10:04 <Cale> > (map (++"!")) >>= [["haskell","is"],["fun"]]
05:10:05 <lambdabot> Couldn't match `[[Char]] -> [[Char]] -> b' against `[a]'
05:10:06 <ski> > concat (concat (map (map (++"!")) [["haskell","is"],["fun"]]))
05:10:07 <lambdabot> "haskell!is!fun!"
05:10:12 <Cale> oops
05:10:21 <ForgeAus> so  "! " prolly
05:10:22 <shapr> A simpler demo is the function addOne = (+1)
05:10:32 <Cale> > (map (++"!")) =<< [["haskell","is"],["fun"]]
05:10:33 <lambdabot> ["haskell!","is!","fun!"]
05:10:35 <ski> > unwords (concat (map (map (++"!")) [["haskell","is"],["fun"]]))
05:10:36 <lambdabot> "haskell! is! fun!"
05:10:40 <ForgeAus> yeah
05:10:42 <shapr> let addOne = (+1) in map addOne [1,92,63]
05:10:47 <shapr> > let addOne = (+1) in map addOne [1,92,63]
05:10:49 <lambdabot> [2,93,64]
05:10:53 <ski> @type unwords
05:10:54 <lambdabot> [String] -> String
05:11:06 <ski> @type concat
05:11:07 <Cale> > let add x y = x + y in map (add 1) [1,2,3]
05:11:07 <lambdabot> forall a. [[a]] -> [a]
05:11:08 <lambdabot> [2,3,4]
05:11:11 <shapr> In most languages, the + requires both of its arguments at the beginning, or it complains bitterly.
05:11:31 <ForgeAus> > let timesTwo = (*2) in map timesTwo [1, 3, 9]
05:11:32 <lambdabot> [2,6,18]
05:11:45 <mysteriousentity> Does the function writeFile write to a binary file? Where can I find the source for System.IO?
05:12:01 <ForgeAus> well + is a binary operator, usually
05:12:04 <dons> it just writess to a file.
05:12:15 <Cale> mysteriousentity: it writes a string
05:12:21 <Cale> (into a file)
05:12:36 <shapr> ForgeAus: One advantage to partial application instead of an object is that you know 1) values won't change behind your back and 2) the 'future' of this application is limited.
05:12:37 <dons> @where fptools
05:12:37 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
05:12:42 <shapr> er wait, that was two advantages...
05:12:43 <ski> mysteriousentity : text mode, iirc
05:12:43 <ForgeAus> haskell just relegates the second operand to another kinda structure
05:12:47 <dons> hmm. odd url.
05:12:47 <shapr> I can do monads, but I can't count :-(
05:12:58 <Cale> @type (+)
05:12:59 <lambdabot> forall a. (Num a) => a -> a -> a
05:13:05 <ForgeAus> lol shapr
05:13:09 <ForgeAus> thats ok I can't count either
05:13:14 * shapr grins
05:13:25 <dons> ok, i'm off for about 8 days, not much net access. have fun, and don't bite lambdabot too much!
05:13:27 <ForgeAus> whats the . mean?
05:13:31 <shapr> dons: Have fun!
05:13:36 <mysteriousentity> But is it equivalent to opening a file using 'openFile' or 'openBinaryFile'?
05:13:36 <Cale> which .?
05:13:40 <Cale> after forall?
05:13:45 <ForgeAus> yeah
05:14:07 <shapr> ForgeAus: It's a picky detail that probably won't help you understand more right now.
05:14:14 <ForgeAus> lol
05:14:19 <Cale> but the . there is just syntax
05:14:30 <Cale> it separates the 'a' just before from the rest
05:14:52 <Cale> let's pretend that (+) :: Integer -> Integer -> Integer
05:15:03 <ForgeAus> uh? is that BNF?
05:15:09 <Cale> not quite :)
05:15:32 <Cale> this means that (+) is a function which takes two integers and returns an integer
05:15:34 <Cale> or
05:15:40 <Cale> (+) :: Integer -> (Integer -> Integer)
05:15:50 <Cale> this is the same in Haskell, as -> is right associative
05:15:51 <ForgeAus> the operator + requires an operand, (the operation is the +) and a second operand... and returns a result
05:16:29 <Cale> So (+) is a function which takes an Integer, and returns a function which takes an Integer and returns an Integer
05:16:35 <ForgeAus> hangon, how do you get 2 input one output from integer -> integer -> integer?
05:16:52 <Cale> @type (+) 5
05:16:53 <lambdabot> forall a. (Num a) => a -> a
05:16:53 <ForgeAus> ahh ok
05:16:54 <[CotL]Godofe_Kei> what does the error:  Cannot find "show" function for: means?
05:16:56 <Cale> @type (+) 5 6
05:16:57 <lambdabot> forall a. (Num a) => a
05:16:57 <ForgeAus> the return is implied?
05:17:08 <Cale> @type toUpper
05:17:09 <lambdabot> Not in scope: `toUpper'
05:17:12 <Cale> @type Char.toUpper
05:17:13 <lambdabot> Char -> Char
05:17:23 <ski> [CotL]Godofe_Kei : you have no 'instance Show'
05:17:41 <ski> [CotL]Godofe_Kei : possibly you can add 'deriving Show' if you have a datatype you want to show
05:17:47 <Cale> If a and b are types, then a -> b is the type of functions which take a parameter of type a and return a value of type b.
05:18:00 <[CotL]Godofe_Kei> hmm
05:18:05 <[CotL]Godofe_Kei> how do i add that?
05:18:15 <Cale> -> is right associative, which means that a -> b -> c means a -> (b -> c)
05:18:28 <[CotL]Godofe_Kei> but its weird
05:18:31 <ski> [CotL]Godofe_Kei : like 'data MyType = X Int | Y Bool String  deriving Show'
05:18:32 <ForgeAus> so integer div integer = real right? so real -> (integer -> integer) ???
05:18:33 <[CotL]Godofe_Kei> cause separately they all work
05:18:55 <ski> [CotL]Godofe_Kei : hm
05:19:00 <[CotL]Godofe_Kei> when i use them separately one after another the functions work
05:19:08 <[CotL]Godofe_Kei> i put them in the another function
05:19:11 <[CotL]Godofe_Kei> they compile
05:19:14 <Cale> If we had something like that, it would read:  div :: Integer -> Integer -> Real
05:19:17 <[CotL]Godofe_Kei> but it gives that error
05:19:19 <ski> > 15 `div` 7
05:19:20 <lambdabot> 2
05:19:24 <ski> > 15 / 7
05:19:25 <lambdabot> 2.142857142857143
05:19:29 <[CotL]Godofe_Kei> lePassagens s c = map asd (agrupa (leCorredores s))
05:19:29 <ForgeAus> lol I had it back to front
05:19:30 <Cale> but div actually doesn't have that type :)
05:19:37 <[CotL]Godofe_Kei> is it because im not using the argument c?
05:19:41 <Cale> (it's integer division :)
05:19:45 <[CotL]Godofe_Kei> only the s?
05:19:50 <[CotL]Godofe_Kei> i dont need the c for anything
05:19:55 <ski> ForgeAus : we prefer to be explicit about converting between int and real
05:19:56 <ForgeAus> ok...
05:20:17 <Cale> @type fromIntegral
05:20:18 <lambdabot> forall b a. (Num b, Integral a) => a -> b
05:20:33 <Cale> now, I should explain that bit that says (Num b, Integral a) =>
05:21:00 <Cale> what that means is that it requires the type 'b', whatever type it is, to be a type of Number
05:21:03 <ski> > let x :: Int; x = 5 in x `div` 2
05:21:04 <lambdabot> 2
05:21:07 <Cale> oh
05:21:18 <Cale> connection dropped again
05:21:28 <shapr> He seems to be enjoying this though :-)
05:21:29 <ski> m
05:21:54 <ski> [CotL]Godofe_Kei : what are you trying to show ?
05:22:09 * shapr is always happy to introduce new people to the #haskell world of cool toys.
05:22:15 <Cale> :)
05:22:20 <Cale> It's fun :)
05:22:38 <Cale> You get to rediscover them for yourself another time
05:22:58 <[CotL]Godofe_Kei> hmm
05:23:07 <[CotL]Godofe_Kei> its a bit complicated
05:23:08 <Cale> welcome back :)
05:23:11 <Pupeno> I install a handler, I run my server (which forks or something like that), now, what can I do to prevent my program from finishing ?
05:23:17 <ForgeAus> `div` vs / ? <ForgeAus> `div` is what? as opposed to /? div gives whole number does it somehow convert to absolute or does it recognise 15 and 7 as integers?
05:23:47 <Cale> div :: Integer -> Integer -> Integer (or close to it)
05:23:48 <kzm> I updated FirstSteps on the Wiki - please check it out, and fix/complain as appropriate
05:23:49 <[CotL]Godofe_Kei> i will post the code
05:23:52 <[CotL]Godofe_Kei> give me a minute
05:24:11 <Cale> whereas (/) works on reals of various sorts
05:24:19 <Cale> (but specifically not on integers!)
05:24:31 <ski> e.g. (/) :: Float -> Float -> Float
05:24:44 <Cale> > (5 :: Integer) / (4 :: Integer)
05:24:45 <lambdabot>  add an instance declaration for (Fractional Integer)
05:24:45 <lambdabot>   In the definition of `vhk': vhk = (5 :: Integer) / (4 :: Integer)
05:24:45 <lambdabot>   In the definition of `v':
05:24:55 <shapr> Cale: Oh, I've been having fun with sgt-puzzles - http://www.scannedinavian.com/2005-12-21.html
05:24:58 <ski> @type ((/) :: Float -> Float -> Float)
05:24:58 <lambdabot> Float -> Float -> Float
05:25:26 <shapr> kzm: I definitely like your usage of change messages.
05:25:30 <Cale> shapr: untangle runs stupidly slow on my machine for some reason
05:25:30 <ski> ForgeAus : that error basically says that you can't take real division on integers
05:25:41 <Cale> shapr: but that's pretty cool :)
05:25:52 <ForgeAus> ok
05:25:56 <[CotL]Godofe_Kei> http://paste.lisp.org/display/14870
05:26:04 <Cale> http://vx.hn.org/autoshare/Level-50-ridiculous.png
05:26:05 <Cale> :)
05:26:07 <ski> > fromIntegral (5 :: Integer) / fromIntegral (4 :: Integer)
05:26:08 <lambdabot> 1.25
05:26:16 <ski> @type fromIntegral (5 :: Integer)
05:26:17 <lambdabot> forall b. (Num b) => b
05:26:24 <ski> @type (fromIntegral (5 :: Integer) :: Float)
05:26:25 <lambdabot> Float
05:26:26 <Cale> http://vx.hn.org/autoshare/Level-20.png -- I got bored after that :)
05:26:49 <ski> ForgeAus : 'fromIntegral' is used to convert from integers to various other kinds of numbers
05:27:12 <shapr> hiya roconnor 
05:27:14 <ForgeAus> is there fromFloat? and fromStr, etc?
05:27:17 <roconnor> hey
05:27:24 <shapr> Cale: nifty!
05:27:37 <ForgeAus> kinda like Ctype in vb or coercion (type)var in C++
05:27:43 <shapr> Cale: I'd like to write programs to solve those puzzles.
05:27:56 <Cale> ForgeAus: well, not with those names as such
05:28:13 <Cale> ForgeAus: and you can't blindly coerce, say Float to Integer
05:28:18 <ForgeAus> well if theres from, is there to?
05:29:01 <ski> @type toRational
05:29:02 <lambdabot> forall a. (Real a) => a -> Rational
05:29:14 <ski> > toRational 12.25
05:29:15 <lambdabot> 49%4
05:29:23 <Cale> ForgeAus: well, not consistently :) fromIntegral is fairly general and covers 99% of all the cases when you need to coerce numbers :)
05:29:24 <roconnor> I remember being surprised to learn that all planer graphs can be drawn with straight lines.
05:29:35 <ForgeAus> Cale ok... 
05:29:46 <ForgeAus> (I just tend to be one of those people who come across the unusual case)
05:29:54 <Cale> for strings however...
05:29:56 <Cale> @type show
05:29:57 <lambdabot> forall a. (Show a) => a -> String
05:30:06 <ski> > show 123
05:30:07 <Cale> > show 57
05:30:08 <lambdabot> "123"
05:30:08 <lambdabot> "57"
05:30:12 <ski> > show False
05:30:13 <lambdabot> "False"
05:30:14 <Cale> > show [1,2,3,4]
05:30:15 <lambdabot> "[1,2,3,4]"
05:30:19 <ski> > show "hello"
05:30:20 <lambdabot> "\"hello\""
05:30:24 <roconnor> > show show
05:30:25 <lambdabot>  add an instance declaration for (Show (a -> String))
05:30:25 <lambdabot>   In the definition of `hmk': hmk = show show
05:30:25 <lambdabot>   In the definition of `v': v = let hmk = show show in take 2048 (show
05:30:25 <lambdabot> hmk)
05:30:31 <ForgeAus> > show "Hello World!"
05:30:32 <Cale> there's also read
05:30:32 <lambdabot> "\"Hello World!\""
05:30:33 <ski> roconnor : naughty
05:30:39 <ski> > read "123" :: Int
05:30:40 <Cale> > read "57" :: Integer
05:30:40 <lambdabot> 123
05:30:41 <lambdabot> 57
05:30:48 <Cale> hehe, lambdabot seems to like ski
05:30:53 <ForgeAus> can I convert a "1" into a 1?
05:31:02 <ski> ForgeAus : see just above
05:31:09 <Cale> yes, that's what read does
05:31:17 <ForgeAus> I see
05:31:18 <Cale> note that we're telling it the type
05:31:27 <Cale> in a real program, you'd rarely have to do this
05:31:38 <roconnor> > read "123.45" :: Int
05:31:38 <Cale> because it could usually tell what type you wanted from context
05:31:39 <lambdabot> Exception: Prelude.read: no parse
05:31:39 <ForgeAus> > read "123" + read "234"
05:31:40 <lambdabot> 357
05:31:49 <Cale> > read "123.45" :: Float
05:31:50 <lambdabot> 123.45
05:32:09 <Cale> @type read
05:32:09 <lambdabot> forall a. (Read a) => String -> a
05:32:11 <shapr> I wish google reader would update my hawiki recent changes cookie somehow.
05:32:21 <ski> > read "\"hello\"" ++ " world"
05:32:22 <lambdabot> "hello world"
05:32:29 <roconnor> I don't like read.  It should be (Read a) => (Monad m) => String -> m a
05:32:45 <Cale> @type reads
05:32:46 <lambdabot> forall a. (Read a) => ReadS a
05:32:52 <Cale> roconnor: write your own :)
05:33:11 <ski> > read "abc" :: Int
05:33:12 <lambdabot> Exception: Prelude.read: no parse
05:33:20 <Cale> roconnor: actually, it shouldn't be Monad m
05:33:26 <Cale> But MonadZero m
05:33:34 <[CotL]Godofe_Kei> anyone saw my paste?
05:33:40 <ForgeAus> > (read "123" :: Int) + (read "234" :: Int)
05:33:41 <lambdabot> 357
05:33:44 <Cale> (or perhaps MonadPlus m, if we're adamant about dropping MonadZero)
05:34:16 <shapr> Cale: What do you think about the connection between Free Algebra and polyinline caching in Self? Do you think it's valid?
05:34:18 <roconnor> yes
05:34:31 <Cale> shapr: I know nothing about the latter
05:35:06 <Cale> (and only a slight amount about the former)
05:35:28 <Cale> [CotL]Godofe_Kei: looking
05:35:42 <ForgeAus> Self! (like in Python... same as me.  in VB or this. in C#?)
05:35:52 <ForgeAus> where Super = parent?
05:35:57 <Cale> ForgeAus: Self is a language
05:36:01 <ForgeAus> oh
05:36:03 <ForgeAus> ok
05:36:40 <[CotL]Godofe_Kei> lePassagens is the one that gives the error
05:36:51 <shapr> You said "an evaluation map for the monad at a specific type" which sounds like polymorphic inline caching... lemme find a summary of PICs
05:37:05 <ForgeAus> (dunno bout C# but Super in VB = MyBase.)
05:37:43 <ForgeAus> (I think in C# you probably just reference the base function like you normally call it??)
05:37:48 <twb> ForgeAus: real men don't admit knowledge of VB.
05:37:58 <twb> Or C#.
05:38:02 <ForgeAus> twb I teach it, so I aught to know!
05:38:13 <twb> You're not making any friends.
05:38:14 <shapr> I have Integrality.
05:38:18 <Cale> lePassagens [] [] = []
05:38:18 <Cale>  isn't needed
05:38:33 <ForgeAus> if people reject me just for knowing something about VB I prolly didn't want them as friends
05:38:36 <shapr> Cale: http://research.sun.com/self/papers/pics.html 
05:38:38 <Cale> (it's covered by the other two cases)
05:38:41 <ForgeAus> VB doesn't define who I am!
05:38:42 <shapr> ForgeAus: heh, smart.
05:38:45 <twb> ForgeAus: fair enough.
05:38:47 <shapr> Perceptive too.
05:38:52 <ski> ForgeAus : you're right
05:39:15 <twb> ...o 'course, I said "admit to knowing", not "know".
05:39:15 <Cale> Hey, I know VB (or did when I was younger anyway)
05:39:27 <[CotL]Godofe_Kei> it gives the error
05:39:32 <ForgeAus> well (mine's worse.. the .NET variety!)
05:39:51 <shapr> Cale: In short, at runtime, for every method call, compile and cache a type specialized version when a method is called.
05:39:59 <twb> ForgeAus: you should at least teach Python and Perl.
05:40:02 <Cale> shapr: hmm...
05:40:12 <ForgeAus> twb, show me some demand for it...
05:40:15 <ForgeAus> I'd love to teach it!
05:40:22 <twb> Fuck demand.
05:40:23 <ForgeAus> except that I know nothing about Perl
05:40:28 <Cale> shapr: it's not so much like that, though that would be potentially one instance of it.
05:40:38 <twb> Since when do education types actually care what is useful?
05:40:49 <shapr> Is demand cute?
05:41:05 <Cale> shapr: Well, I was talking about T-algebras in general, I don't really know about the free one
05:41:07 <shapr> twb: Am I an education type? :-)
05:41:14 <shapr> g'day Tomcat, learning Haskell?
05:41:17 <twb> shapr: Who knows.
05:41:20 <ForgeAus> twb I don't get paid if I don't got students
05:41:37 <twb> ForgeAus: Oh, a vocational school.
05:41:39 <ForgeAus> what the institute doesn't know is I enjoy teaching, would do it for free! lol
05:41:44 <shapr> twb: In any case, I think that Haskell is more useful than any other language at the moment.
05:41:52 <shapr> ForgeAus: Oh, you'll fit right in here.
05:41:58 <Cale> shapr: You get more freedom than you would in a map  m a -> a, since it's less polymorphic
05:42:01 <twb> shapr: it's a better compromise than Python, I'll say that.
05:42:21 <shapr> twb: But not until recently... Haskell has enough libraries nowadays.
05:42:29 <twb> It has an FFI.
05:42:34 <shapr> I think Epigram will be the next one...
05:42:36 <Tomcat> shapr: Yeah, how did you guess?
05:42:37 <twb> That should be sufficient :-)
05:42:48 <shapr> Tomcat: My lambda-fu is superior!
05:42:56 <ForgeAus> hehe 
05:43:10 * shapr tokes on a lambda
05:43:10 <shapr> mmm
05:43:15 * ForgeAus executes a tatsumakisenpuukyaku on shapr's lambda-fu..
05:43:22 <shapr> As I always say, the first lambda comes free...
05:43:41 <shapr> minä en tieda!
05:43:56 <Cale> Tomcat: looking for resources?
05:44:03 <shapr> Yes, how may we assist you?
05:44:10 <Cale> Tomcat: have any questions?
05:44:15 <shapr> I would offer you the grand tour, but I have to attend to my unicycle...
05:44:21 <ForgeAus> lol
05:44:41 <twb> I'll do the introduction!
05:44:43 <shapr> ForgeAus: Seriously - this is me - http://www.scannedinavian.com/images/shae-sj.png
05:44:51 <shapr> twb: Go for it! w00!
05:45:07 * shapr wobbles away into the solstice...
05:45:10 <wolverian> what the hghuhguhglahl oh that isn't some weird plastic/leather cock mold
05:45:13 <twb> Tomcat: what can I do for you?
05:45:56 <[CotL]Godofe_Kei> Help me!!!
05:45:59 <[CotL]Godofe_Kei> :(:(:(:(
05:46:03 <twb> cognominal: never!
05:46:08 <twb> Er, [CotL]Godofe_Kei
05:46:28 <ForgeAus> shapr u a circus performer or something?
05:46:38 <ForgeAus> just need the white + red facepaint and the big shoes!
05:46:47 <ski> [CotL]Godofe_Kei : hm, what are you trying to do ?
05:46:48 <shapr> ForgeAus: Nah, I do mountain unicycling.
05:46:56 <ForgeAus> ahh mountains... 
05:46:59 <twb> http://twb.ath.cx/~twb/img/photo/me-air.jpg
05:47:05 <ForgeAus> gotta have good balance!
05:47:07 <Tomcat> twb: I don't need any help just yet, but thanks for offering
05:47:30 <shapr> twb: Wah cool, what is that?
05:47:36 <[CotL]Godofe_Kei> it gives me that error
05:47:44 <twb> shapr: http://dirtsurf.com
05:47:45 <[CotL]Godofe_Kei> no shw functions or something
05:47:56 <twb> shapr: not very good site, I'm afraid.
05:48:01 <Tomcat> Cale: I found resources at www.haskell.org, is there anywhere else I should be looking for libraries etc.
05:48:12 <shapr> twb: Cool looking critter, too bad it requires flash.
05:48:26 <ski> [CotL]Godofe_Kei : http://paste.lisp.org/display/14868 ?
05:48:40 <shapr> twb: If you get the urge to try unicycling, I'm happy to help :-)
05:48:49 <twb> Tomcat: they are mostly distributed with the compilers.
05:49:17 <ForgeAus> I had a skateboard once.. but the wheels didn't turn very well!
05:49:30 <ForgeAus> (they were too stiff... no freerolling)
05:50:04 <[CotL]Godofe_Kei> yes
05:50:14 <tromp_> @quote tromp
05:50:14 <lambdabot>  the number of 13x13 go positions is 37249792307686396442294904767024517674
05:50:14 <lambdabot> 249157948208717533254799550970595875237705
05:50:15 <[CotL]Godofe_Kei> Ski: Yes
05:50:20 <tromp_> @quote tromp
05:50:20 <lambdabot>  The base of liberties in Go is 2.975734192
05:50:27 <tromp_> @quote tromp
05:50:27 <lambdabot>  the number of legal 17x17 Go positions is 9895749638558742166 modulo
05:50:27 <lambdabot> 18446744073709551577 :)
05:50:34 <Cale> http://www.haskell.org/hawiki/FirstSteps
05:50:45 <Cale> Tomcat: that url might be helpful
05:51:10 <shapr> tromp_: Now, what's the formula to go from N by M to number of legal positions?
05:53:09 <Tomcat> Cale: thanks
05:53:24 <tromp_> legal m n = alpha * beta**(m+n) * lambda**(m*n) where
05:53:28 <tromp_> alpha  = 0.850639925845833
05:53:32 <tromp_> beta   = 0.96553505933836965
05:53:36 <tromp_> lambda = 2.97573419204335725
05:53:54 <tromp_> of course that's just approximately
05:54:00 <kzm> shapr, on the wiki, I could've sworn there used to be a small toolbar of icons at the top?
05:54:01 <shapr> nifty!
05:54:02 <tromp_> but scarily accurate...
05:54:08 <shapr> kzm: There usually is...
05:54:18 <shapr> tromp_: Is there some way to interpolate further?
05:54:42 <kzm> shapr, ah, sorry, it was a user pref
05:54:56 <tromp_> by the time we finish L(17,17) we may know a few more digits of those constants
05:55:07 <tromp_> how would you want to interpolate?
05:55:30 <shapr> Could you find more digits of those constants by randomly picking smaller sizes and checking to see what constants they give?
05:55:46 <tromp_> no way
05:55:47 <shapr> Or is the constant resolution limited by the total area or something?
05:55:55 <musasabi> shapr: You wouldn't go who is responsible for Trac issues on haskell.org ?
05:56:04 <tromp_> the constants are limits of a convergent series
05:56:17 <shapr> musasabi: Probably SimonM for the GHC tracs, and SyntaxNinja for the galois tracs.
05:56:28 <musasabi> mmh, ok
05:56:39 <musasabi> have just wait till SimonM comes back from holidays
05:56:44 <kzm> shapr, is it possible to change the message you get if you try to edit without logging in?  Ideally, it should say you need to log in, not just that you can't edit the page.
05:56:44 <tromp_> the smaller sizes give worse approximations
05:56:49 <shapr> musasabi: Though I did introduce Trac to the community (gour introduced trac to me), I am not responsible for the installations.
05:57:05 <shapr> kzm: Hm, could be, I never thought of that.
05:57:07 <tromp_> for really small sizes, we have exact recurrences thouggh
05:57:35 <tromp_> the order of the recurrence grows pretty fast though
05:58:12 <tromp_> for example, legal3 = recurrence [-5,73,100,-1402,1014,-5352,-2490,6018,-4020,1766,9083,-19993,22072,-16646,9426,-3750,1171,-233,33] [1,15,489,12675,321689,8180343,208144601,5296282323,134764135265,3429075477543,87252874774409,2220150677358587,56491766630430761,1437433832683612783,36575525011037967769,930664771769562054147,23680778803620700205625,602557764897193682879119,15332091188757329557096929]
05:59:01 <shapr> tromp_: I was just wondering if extremes of smaller N by M sizes would give some sort of extra definition to the constants, for example, whether 3 by 96 would give a different resolution to those constants than 17 by 17 would give.
05:59:32 <tromp_> no, the accuracy seems to depend on the minimum of m and n
05:59:33 <ForgeAus> data = type statement?
05:59:42 <ForgeAus> like record?
05:59:48 <ForgeAus> or struct
05:59:53 <shapr> Sort of like struct.
06:00:05 <tromp_> we did compute the number of 9x100000 boards though (modulo some huge primes)
06:00:07 <shapr> Er, maybe Haskell records are more like struct?
06:00:22 <ForgeAus> haskell has records too?
06:00:24 <tromp_> that was needed to compute the order of the 9xn recurrence
06:00:27 <ForgeAus> as well as data?
06:00:37 <shapr> @wiki HaskellDemo -- I think this includes a demo of Records
06:00:38 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo -- I think this includes a demo
06:00:38 <lambdabot> of Records
06:00:39 <ForgeAus> if then looks simple :)
06:01:09 <shapr> tromp_: Nifty, one day I'll get around to reading all your writings and related references.
06:01:19 <ForgeAus> thats using data keyword.. hangon whats deriving?
06:01:28 <shapr> tromp_: I'd still like to get a TMR article about your work if you ever get the time and interest.
06:02:01 <tromp_> i only use haskell for the chinese remainder theorem:)
06:02:07 <shapr> ForgeAus: Oh hey, you might like TMR - http://www.haskell.org/tmrwiki/
06:03:33 <shapr> twb: Did you do those Inkscape pix ?
06:03:38 <tromp_> although it could be an excuse to present the recurrence definition:)
06:04:45 <shapr> Sure, if you want :-)
06:05:35 <Cale> http://www.haskell.org/hawiki/IntroductionToIO -- this is a spliced copy of my recent messages to the list. Any feedback?
06:06:21 <Pupeno> How do I wait for a thread to finish indefinitely ?
06:06:27 <Cale> I linked it from the end of the discussion about hello world on the FirstSteps page, because it seemed like a fairly natural continuation of that discussion.
06:06:39 <Cale> Pupeno: perhaps use an MVar?
06:06:49 <Cale> or, don't use a thread?
06:06:54 <Cale> hehe
06:07:01 <Cale> well, that's unlikely :)
06:07:06 <twb> shapr: yep.
06:07:08 <Pupeno> Cale: runDgramServe runs a thread, I can't avoid that.
06:07:19 <Cale> oh
06:07:22 <shapr> twb: You did the gnu, discordia, etc?
06:07:27 <shapr> twb: Those are way cool.
06:07:28 <Cale> do you just want the program to block?
06:07:31 <twb> shapr: not the originals.
06:07:40 <Pupeno> runStreamServer too. I want to wait for it to finish.
06:07:41 <twb> I vectorized them.
06:07:45 <Pupeno> Cale: yes.
06:07:46 <shapr> twb: Yeah, but you went from bitmap to vector, yeah?
06:08:00 <Cale> You could just put a getChar or something to wait for the user to press a key, or just loop
06:08:25 <shapr> twb: Is the xwd dir a cronjob of screenshots?
06:08:36 <twb> Not a cron job.
06:08:38 <shapr> I've wanted to do something like that, a desktop webcam...
06:08:40 <twb> Just a dumb script.
06:08:42 <Cale> Pupeno: I'm unfamiliar with runDgramServe
06:08:56 <shapr> The problem I have is that I deal with a surprising amount of confidential information.
06:09:14 <Cale> Pupeno: is it your own function?
06:09:15 <twb> e.g. while read X; do import -window root `date -Iseconds`.png; done
06:09:20 <Pupeno> this should be a server running in background withou user intervention. Wouldn't an infinite loop consume too many resources ?
06:09:48 <Pupeno> Cale: no: http://www.cs.helsinki.fi/u/ekarttun/network-alt/doc/Network-Alt-Server.html
06:10:07 <Cale> You don't have permission to access /u/ekarttun/network-alt/doc/Network-Alt-Server.html on this server.
06:10:24 <Cale> odd, I can go up and click to it just fine
06:10:35 <Cale> oh, it's got a different name
06:10:37 <shapr> Cale: referrer maybe?
06:10:39 <shapr> oh
06:10:51 <shapr> twb: Would you happen to know how to get firefox deerpark to display svg inline?
06:10:58 * shapr is very fond of SVG
06:10:59 <twb> shapr: I don't use firefox.
06:11:22 <twb> shapr: you have to compile it in.
06:11:27 <shapr> Would you happen to know how to get pstoedit to output decent svg versions of ps files?
06:11:37 <Pupeno> Cale: runStreamServer takes a function and some other details for opening a network port and whenever a connection is stablished, it runs the function, but runStreamServer returns immediatly and I want to block to let it work.
06:11:41 <twb> Nope.
06:11:52 <twb> pstoedit with svg output is not Free, IIRC.
06:12:13 <shapr> There is a free version in debian/unstable, it uses some bizarre combination of gnuplot and something else ...
06:12:17 <Pupeno> In fact, I should control it, but untill I manage to not exit immediatly I can't hope for any control.
06:12:44 <shapr> Pupeno: Why not use a loop like lambdabot does?
06:12:54 <kzm> Cale: what is the difference between UsingIO (Hannah) and IntroductionToIO (you, I think)?
06:13:00 <Cale> Pupeno: an easy way to block forever is just  atomically retry
06:13:10 <Pupeno> shapr: loop = loop ?
06:13:40 <kzm> Cale: suggestion: 'Using' as a simple quick and dirty, here's how to do it, and 'Introduction' as a more elaborate work?
06:14:02 <ski> ForgeAus : 'deriving Show' makes so that the 'show' function works on this new datatype
06:14:15 <shapr> hiya CosmicRay 
06:14:17 <ski> > show ([1,2,3],"abc",False)
06:14:19 <lambdabot> "([1,2,3],\"abc\",False)"
06:14:55 <CosmicRay> dons: ping
06:14:59 <CosmicRay> morning shapr
06:15:00 <Cale> kzm: actually, I'd intended the opposite. UsingIo is a longer discussion of IO as far as I can tell.
06:15:02 <ForgeAus> ok
06:16:48 <shapr> CosmicRay: dons just went out of town for eight days or so.
06:16:55 <CosmicRay> oh.  drat.
06:17:47 <SlowByte> shapr: shrinking png's with a tiny palette generally makes them bigger since the filtering/antialiasing adds a lot of entries to the palette :)
06:18:13 <CosmicRay> shapr: you trying to compress down some photos?
06:19:06 <shapr> PLog calls imagemagick for image resizing, and it generated a huge image when shrinking a png.
06:19:53 <shapr> 254k png when shrunk becomes a 3.2mb output image.
06:19:57 <kzm> Cale, okay. It wasn't clear from cursory reading which was which, and I think they should be different.
06:20:32 <kzm> Hannah's piece seemed a bit more detailed (teaspoon mode)
06:20:50 <SlowByte> shapr: are you sizing down by powers of 2, and with what filter?
06:20:51 <Cale> kzm: they do cover a lot of the same ground
06:20:52 <shapr> Oh boy, the new unified display connector will integrate DVI and HDTV and include the Digital Content Protection!
06:21:04 <shapr> SlowByte: heck if I know...
06:21:14 <shapr> SlowByte: I just threw in the original.
06:21:24 <SlowByte> oh, right :)
06:21:55 <shapr> I wish that I were allowed to use my hardware as I want, with no added monopoly protection hardware.
06:22:26 <ForgeAus> DRM sux
06:22:31 <Cale> It seems so funny that people work so hard to protect content which is just going to be shown to the viewer anyway.
06:22:36 <shapr> Yeah
06:23:02 <shapr> But they're working on ways to include a digital watermark in the shown picture, and watermark detection in all cameras, so that it will not display watermarked data.
06:23:04 <ForgeAus> Cale, yeah just convert it to diff format
06:23:08 <Cale> If it can be seen and heard, then it has to be decoded, which means that it can be captured and copied. How hard is that to figure out?
06:23:23 <ForgeAus> if WMV has DRM protection convert it to MPEG! lol
06:23:46 <shapr> If they do that, I will immediately start producing t-shirts and bumper stickers with those watermarks.
06:23:49 <shapr> Oh even better...
06:24:20 <shapr> I'll make fabric that includes those watermarks and write blog posts about how you can now commit crimes anonymously.
06:24:35 <shapr> DMCA violating evidence should not be admissible in court, right?
06:25:00 <Cale> in the US?
06:25:04 <shapr> yup
06:25:20 <ForgeAus> palladium uh?
06:25:47 <Cale> I don't know the rules on evidence there. Probably it couldn't be obtained via illegal means.
06:25:52 <ForgeAus> funny thing is microsoft will put DRM on Vista as a selling point, like its a good thing!
06:26:06 <ForgeAus> ppl don't want it, its likely to decrease sales !
06:26:36 <shapr> I think photoshop already includes code to detect some watermarks... for counterfeiting maybe?
06:26:47 <Cale> shapr: yes, for money
06:27:21 <shapr> It would be great fun to see if the police image enhancement apps are based on Photoshop... just wear clothing with those watermarks, right?
06:27:32 <Cale> iirc, it actually had some pretty sophisticated mechanisms in place
06:27:39 <shapr> This sounds like a great CafePress shop idea.
06:28:23 <ForgeAus> eazier just to get some magazine paper and photocopy a voucher lol!
06:28:31 <ForgeAus> or doctor one (as long as it loox official)
06:29:18 <Cale> shapr: a shirt with the Euro dots would be cool
06:29:37 <ForgeAus> get ur good/service at half price or something.. instead of tracable conterfeit money to pay for it
06:29:52 <shapr> I know the new Acrobat Reader includes lots of Javascript support, even to the point of phoning home... I wonder if I could write a PDF virus that adds DRM watermarks to files...
06:31:02 <Cale> http://en.wikipedia.org/wiki/EURion_constellation
06:32:36 <shapr> nifty
06:33:51 <Cale> http://www.wildspark.com/eurionize/
06:33:52 <Cale> heh
06:33:56 <Cale> that's funny
06:35:17 <ForgeAus> gota go sleep
06:35:21 <ForgeAus> past midnight here
06:36:13 <Pupeno> On linux, ctrl-c sends a sigterm, right ?
06:36:44 <CosmicRay> Pupeno: SIGINT
06:37:01 <Pupeno> thanks.
06:39:49 <xerox> ikegami--++
06:40:43 <ikegami--> hello
06:40:51 <shapr> I'd like to print t-shirts with the DRM symbols, but I'd need to make sure they are uncopyable...
06:40:56 <shapr> hiya zooko, long time no see.
06:41:41 <SamB> shapr: just use wierd colors and an interference pattern
06:41:54 <CosmicRay> I still have a tshirt with the RSA cryptosystem in 5 lines of perl, in both human-readable and barcode form
06:41:59 <CosmicRay> a giant barcode on the front
06:42:13 <CosmicRay> back in the day where it was illegal to wear such a shirt in the presence of foreign nationals
06:42:21 <SamB> ah.
06:42:30 <CosmicRay> on the back, it said "THIS SHIRT IS AN ILLEGAL MUNITION", which was great.
06:42:47 <CosmicRay> got asked lots of questions in high school about it ;-)
06:43:00 <zooko> Howdy.
06:43:06 <SamB> you could encrypt a program to build the shirt's images on the back of the shirt?
06:43:23 <shapr> zooko: Learning Haskell?
06:43:29 <CosmicRay> hey zooko
06:43:33 <zooko> What's the status of the converting-GHC-repos-to-darcs project?
06:43:41 <CosmicRay> shapr: zooko has done some various hacking on tailor
06:43:41 <zooko> shapr: well, actually just learning how to build GHC on windows.
06:43:42 <shapr> Ask CosmicRay, he's the man.
06:43:55 <CosmicRay> zooko: it looks like simon is presently checking with other ghc committers
06:44:04 <CosmicRay> zooko: the darcs mirror of the cvs repo is updating daily via cron
06:44:06 <SamB> zooko: apparantly some people have gotten GHC to build from darcs
06:44:09 <CosmicRay> zooko: haven't had any trouble with that
06:44:16 <zooko> Where is the darcs mirror?
06:44:22 <CosmicRay> SamB: including simon, who is building at least some of the nightly builds that way
06:44:26 <zooko> What tool do you use to automatically translate.
06:44:32 <CosmicRay> zooko: see darcs.haskell.org, directories ghc, libraries, testsuite
06:44:42 <SamB> zooko: but I think they had to do it without --partial
06:44:57 <CosmicRay> oh, and nofib
06:45:01 * kpreid_ waves to zooko
06:45:01 <CosmicRay> zooko: taqilor
06:45:05 <CosmicRay> tailor
06:45:10 <zooko> Cool!
06:45:47 <CosmicRay> zooko: yeah, I think you helped me set it up ;-)
06:46:00 * SamB is sad that jlouis has apparantly not done anything to conjure since he (SamB) added tentative seeding
06:46:05 <CosmicRay> it was lelit and someone -- I think you -- that were coming up with all these insane hacks for converting a branch starting halfway through
06:46:45 <CosmicRay> one of which worked ;-)
06:46:50 <xerox> SamB: poke him!
06:46:57 <zooko> CRay: great!
06:47:06 <zooko> What do you mean without --partial?
06:47:10 <CosmicRay> you can see the result in the *.ghc-6.4 directories
06:47:18 <zooko> Wow.  13137 patches in the ghc-6.4...
06:47:21 <SamB> CTCP jlouis poke
06:47:41 <CosmicRay> SamB: no, simon is building the daily snaps from a --partial repo
06:47:48 <CosmicRay> zooko: yup
06:47:50 <zooko> I guess I should do the same!
06:47:50 <adept> SamB: i'll join back in at the end of the week. Too much work right now :(
06:47:52 * zooko kills this darcs get.
06:47:54 <SamB> CosmicRay: cool
06:48:02 <SamB> adept: ah
06:48:16 <CosmicRay> yes, very few people want to do a darcs get of ghc without using --partial ;-)
06:48:41 <SamB> CosmicRay: and those that do probably don't want to do it remotely more than once...
06:48:51 <SamB> in fact, maybe they don't want to do it remotely at all.
06:49:03 <SamB> maybe they would prefer to recieve the repository on CD
06:49:07 <zooko> I sometimes use tar;scp instead of darcs get in a case like that...
06:49:08 <CosmicRay> heh
06:49:27 <CosmicRay> yeah, and all of these people that care to get it have a shell on darcs.haskell.org and can tar it up for themselves
06:49:45 <SamB> well, they still might prefer a CD
06:51:10 <SamB> anyone want to try out my patch?
06:51:27 <Cale> SamB: what's your patch?
06:51:48 <SamB> Tue Dec 20 18:30:16 EST 2005  Samuel Bronson <naesten AT gmail.com>
06:51:48 <SamB>   * SpikeSolution seeding
06:53:39 <SamB> It builds on my startup code for FSThread and jlouis's partial addition of block reading to FSThread
06:53:45 <Cale> okay, I have no idea what that is :)
06:53:54 <SamB> for Conjure
06:53:59 <Cale> ah
06:54:21 <adept> SamB: wow. Seeding! cool!
06:54:24 <Cale> heh, on context, I thought it was a patch to GHC :)
06:54:31 <Cale> ah, seeding in that sense :)
06:56:08 <ski> DRM makes me feel sick
06:56:12 <ski> (literally)
06:57:23 <SamB> so, like, yesterday I ran BitTornado on a test torrent whose file was already present, but told it to download to a different filename, then ran Conjure on it, and as soon as Conjure had finished checking pieces, BitTornado got the file quite quickly.
06:58:31 <adept> SamB: so, conjure could already be self-hosting :)
07:01:52 <SamB> well, after I modified the tracing on sent messages to use showMessage rather than show...
07:03:59 <SamB> of course, as of now seeding does not interact at all with downloading and throwing away all the pieces...
07:04:49 <SamB> oh, and Conjure still does not to my knowledge accept connections properly...
07:11:50 <boegel> CosmicRay: any replies for HWN ?
07:12:02 <CosmicRay> boegel: yes, dons has volunteered to maintain it
07:12:07 <CosmicRay> which I think is great
07:13:09 <boegel> CosmicRay: yeah, it is
07:13:11 <boegel> that's neat
07:13:22 <boegel> go dons !
07:13:33 <CosmicRay> indeed
07:13:37 <CosmicRay> I think he'll do a better job with it than I did
07:13:41 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]' by boegel
07:13:49 <xerox> haha, agreed.
07:13:54 <boegel> we'll see ;)
07:13:57 <CosmicRay> hehe
07:14:12 * CosmicRay runs for jester in the dons court
07:15:32 <zooko> So I did darcs get --partial on happy.  Now the instructions say to run ./configure, but there isn't one.
07:15:47 <zooko> I tried running "automake", "autoconf" and "autoconf-2.13" and all to no avail.
07:16:37 <Igloo> You probably want autoreconf
07:16:57 <Igloo> Which instructions?
07:18:22 <zooko> http://www.haskell.org/ghc/docs/latest/html/building/winbuild.html
07:19:05 <zooko> autoreconf gives an error, and autoreconf-2.13 returns without comment but still there is no ./configure.
07:19:18 <Igloo> That's assuming you are using a happy tarball
07:19:25 <zooko> I see.
07:19:30 <Igloo> What error?
07:19:43 <zooko> autoreconf-2.5x: `configure.ac' or `configure.in' is required
07:19:43 <zooko>  
07:20:01 <Igloo> Where's the darcs repo?
07:20:21 <zooko> time darcs get -v -v -v --partial http://darcs.haskell.org/happy
07:20:21 <zooko>  
07:21:34 <Igloo> Doesn't look like it is designed to be buildable standalone with configure/make. Building with cabal is probably what you are meant to do
07:22:01 <zooko> Thanks.
07:45:42 <xinming> is there a library which can accept a string which contains the haskell code and then run it?
07:46:44 <integral> sounds like hsplugins perhaps
07:47:29 <xinming> integral: It's the same as eval 'something...' in perl
07:47:50 <integral> Oh, you already know it?   You want something different?
07:48:12 <xinming> integral: No, I don't know anything about hs-plugin. :-/
07:54:01 <integral> Oh, sorry, I'm a bit confused
07:54:36 <integral> You want something which takes a string of haskell code, compiles it, and runs it?   Which is what perl's eval does afaik... so if you say hs-plugins does that, umm
07:56:30 <xinming> hmm, I mean, I want to know if there is a way that make a program which can dynamicly load somefiles if I want
07:57:14 <Trevion> xinming, yes, the hs-plugins that integral has mentioned will do that.  Try http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:57:26 <xinming> Trevion: thanks
07:58:26 <xerox> Yes, there is, and it is that, heh.
08:01:09 <SamB> it can also do this:
08:01:18 <SamB> > "Hello, world!"
08:01:19 <lambdabot> "Hello, world!"
08:03:36 <CosmicRay> I should not that hs-plugins is not entirely portable.
08:03:46 <SamB> hmm, my changes need error checking
08:03:51 <CosmicRay> it works only on platforms that ghci supports (which is smaller than the set of platforms that ghc supports)
08:04:05 <SamB> for linking reasons
08:04:16 <CosmicRay> I should also mention that ghci and hugs can effectively "source" haskell files at runtime.
08:04:52 <SamB> but ghci doesn't do anything much different from what hs-plugins does, does it?
08:05:07 <CosmicRay> well, hs-plugins can do more than ghci automatically does
08:05:15 <CosmicRay> including loading arbitrary strings at runtime
08:05:20 <SamB> well yes
08:05:33 <CosmicRay> ghci will let you import a file, in the standard haskell way, which is executed at start time
08:05:52 <SamB> what?
08:05:53 <CosmicRay> it can't re-parse it while you're already running
08:06:05 <CosmicRay> well, let's say you're storing configuration in a valid haskell file.
08:06:13 <CosmicRay> put it on ghci's path and just import it in th eusual way
08:06:18 <CosmicRay> ditto for hugs
08:06:24 <SamB> ah
08:06:26 <CosmicRay> so in some simple cases, you may not need hs-plugins
08:06:30 <SamB> true ;-)
08:06:40 <CosmicRay> but hs-plugins makes things much more convenient and adds some features
08:07:00 <CosmicRay> he probably wants hs-plugins.  i'm just saying, for the record, that ghci and hugs can do some rudimentary things like this already.
08:07:27 <SamB> but if you do that, it will prevent all importers (direct or otherwise) of the config file from being compiled
08:07:45 <CosmicRay> the other thing I should mention is that he may not need this at all.  if he's serializing data structures, show and read may already do what he needs.
08:07:57 <CosmicRay> SamB: indeed.
08:08:02 <CosmicRay> SamB: not an issue for hugs ;-)
08:08:06 <SamB> and yeah, GHCi can do bytecode, hs-plugins does not
08:08:14 <SamB> CosmicRay: true!
08:08:27 <SamB> seeing as the issue for hugs is that nothing can be compiled
08:08:32 * araujo gets up from a nap
08:08:44 <CosmicRay> hehe
08:08:49 <CosmicRay> morning araujo
08:09:12 <araujo> Hello CosmicRay :-)
08:10:22 * CosmicRay does some more hdbc hacking.
08:10:49 <CosmicRay> I hope Haskell can become the language of choice for database work.
08:10:56 <CosmicRay> I think it stands a quite decent change of this happening.
08:11:05 <CosmicRay> combining lazy I/O with SQL queries smells very powerful to me.
08:12:30 <earthy> typesafe querying sounds pretty darn powerful as well
08:12:44 <int> hello all! can someone help me with building nhc98 with gcc?
08:13:27 <CosmicRay> earthy: yeah I'm currently trying to figure out how to do this.
08:13:36 <CosmicRay> earthy: basically most databases have a C api for it.
08:13:48 <CosmicRay> earthy: so you can send it a query that says SELECT * FROM FOO WHERE BAR = ?
08:13:59 <CosmicRay> and then you "bind" a value and type to that question mark
08:14:08 <CosmicRay> say "bar" is an integer column.
08:14:19 <CosmicRay> most sql engines will let you bind a string, or an int, to that column
08:14:21 <earthy> CosmicRay, have you seen HaskellDB?
08:14:25 <CosmicRay> and the engine will figure out how to DTRT with it
08:14:26 <CosmicRay> earthy: yes
08:14:32 * earthy likes that. ;)
08:14:41 <CosmicRay> earthy: I hope that eventually HDBC could replace HSQL as the layer underneath HaskellDB
08:14:51 <CosmicRay> s/eventually/soon/ ;-)
08:14:55 <earthy> sounds like a Swell Idea
08:15:25 <araujo> CosmicRay, Haskell will take over the world!
08:15:25 <CosmicRay> nothing against HSQL -- I think krasimir did us all a great service by writing it -- but I think that it gets several things wrong 
08:15:29 <CosmicRay> bwahaha
08:15:34 <earthy> ;)
08:15:48 <zooko> Hm.  Using the ghc 6.4.1 release doesn't build the cabal from darcs.haskell.org:
08:15:55 <araujo> No.
08:15:56 <zooko> ./Distribution/Simple/Utils.hs:430:10: parse error on input `]'
08:15:56 <zooko>  
08:16:05 <CosmicRay> zooko: I'd write to syntaxninja about that
08:16:07 <earthy> Araujo: we want world domination. And scantily clad females, ofcourse. Who cares if it's below 0 outside. (Free after Linus Torvalds :))
08:16:20 <araujo> :-)
08:16:26 <zooko> What's syntaxninja's e-mail address?
08:16:29 <CosmicRay> zooko: or grab a tarball from haskell.org/cabal
08:16:35 <zooko> Or perhaps I should open a ticket on sf.net/projects/ghc?
08:16:50 <earthy> zooko: make that the trac site for ghc then
08:16:50 <CosmicRay> zooko: probably not, there's a separate bts for cabal
08:17:04 <CosmicRay> I don't think the latest cabal is in the ghc tree yet
08:17:05 <earthy> but, what CosmicRay states
08:19:27 <araujo> 30 years of imperative programming is enough now. 
08:19:53 <araujo> I think declarative programming is/will be the way to go from now on.
08:20:35 <earthy> araujo: history seems to disagree
08:20:42 <zooko> So is it that the cabal from darcs.haskell.org is too new for ghc 6.4.1 or too old?  And should I go to a bts or e-mail syntax ninja?  And which bts or which e-mail address should I use?
08:21:45 <CosmicRay> zooko: well, the cabal repo is likely the development repo, which may be broken at any given moment
08:22:10 <CosmicRay> use the bts from this page http://hackage.haskell.org/trac/hackage
08:22:50 <CosmicRay> but I'd really suggest using a tarball from http://www.haskell.org/cabal/download.html
08:22:53 <CosmicRay> which are stable releases
08:23:41 <araujo> earthy, history about what?
08:24:24 <zooko> CRay: I would like to explore the darcs and unstable side of things.  If bug reports or help requests from such exploration are unwelcome then I'll do it quietly.  :-)
08:24:40 <zooko> For example, right now I'm thinking of using "darcs obliterate" to try to get a version of cabal that builds... 
08:24:41 <CosmicRay> ok, no problem
08:24:48 <CosmicRay> I think they would be plenty welcome
08:24:56 <CosmicRay> I thought you were just trying to Get Something That Works
08:25:05 <CosmicRay> since that's not the case, ignore me ;-)
08:25:18 <zooko> :-)
08:25:29 <zooko> Yes, if I wanted something that Just Works then I would use Will Glozer's darcs.exe's.  :-)
08:25:33 <earthy> araujo: in the 60's and 70's of the previous century the same observations have also been made
08:25:47 <earthy> we're *still* seeing swathes of programmers programming imperatively
08:25:50 <araujo> earthy, There was a big difference by those days.....
08:25:59 <araujo> earthy, I wasn't alive 
08:26:04 <earthy> ;)
08:26:04 <araujo> ;-)
08:26:18 <earthy> me either :) (well... not until halfway into the 1970's :))
08:26:33 <araujo> I think the Haskell community got a good "conspiracy" down here.. i don't know.....
08:27:12 <earthy> I think there is a deeper issue at play
08:27:18 <earthy> look at e.g. cook books
08:27:33 <araujo> For example, it is very difficult for me to get .. say.. Lisp books here in the bookstores, but i can easily find Haskell stuff.
08:27:41 <araujo> Which makes me happy. *grins*
08:27:50 <earthy> there's the popular ones, wherein you can read recipes that look like imperative programs
08:28:05 <earthy> then, there's professional ones. those are much more declarative
08:28:16 <araujo> A Haskell cook-book would be sweet.
08:28:38 <earthy> it seems that the human mind understands lists of ordered actions quite easily
08:28:47 <earthy> whereas declarative specifications are slightly harder
08:30:06 <earthy> otoh, humans tend to be good at giving vague declarative specifications...
08:30:22 <earthy> 'the car should be fast enough and yellow'
08:31:10 <araujo> I read Brian Kernghan once saying that declarative programming is just too 'close' to mathemtics for most of the people. And so, the declarative approach never fully went out of the academy.
08:31:27 * SamB wants to see recipe books with dependancy graphs
08:31:28 <araujo> I think Haskell is getting out... it is getting out baby and be careful with the lambdas
08:31:29 <araujo> :-)
08:31:51 * xerox throws a lambda-shuriken just above the top of araujo's head
08:31:56 <araujo> haha
08:32:55 <zooko> araujo: can you give me a reference ot that quote from Kernighan?
08:32:57 <Philippa> earthy: IME the human mind understands lists of prerequisites OK too
08:33:23 <araujo> zooko, oh, wait, it was long time ago.. let me goolg it
08:33:25 <Philippa> which is a far more declarative or expression-oriented thing
08:33:30 <araujo> google it*
08:33:34 <SamB> dependancy graphs!
08:33:37 <Philippa> exactly
08:33:43 <SamB> I want recipes with depandancy graphs!
08:34:29 <SamB> like, I messed up making chilly the last time because the recipe was too much like an imperative program!
08:34:36 <CosmicRay> hehe
08:34:54 <SamB> it came out okay anyway, though
08:34:55 <Trevion> Recipes always seem to depend on implicit parallelization...
08:35:44 <jlouis> peek!
08:35:49 <SamB> dependancy graphs would help me to see the parallism and plan for a level of parallasm compatible with my pipeline
08:35:49 <jlouis> hi SamB, you screamt
08:35:57 <SamB> jlouis: not exactly
08:36:06 <jlouis> you poked
08:36:09 <SamB> yes I did
08:36:22 <SamB> I seem to have somewhat broken conjure
08:36:32 <SamB> isn't why I poked though
08:36:56 <jlouis> ok
08:37:10 <jlouis> well, I haven't had time to look at it yesterday
08:37:22 <jlouis> But maybe this afternoon or something like that
08:37:55 <SamB> anyways, it doesn't like much when you start it without a file, and it dies when you start it with no peers...
08:38:08 <araujo> nice i found it!
08:38:15 <araujo> "But my sense is that the functional languages come out of a fairly mathematical community and require a fairly mathematical line of reasoning and therefore are difficult for the people on the street." -- BK
08:38:24 <SamB> (I only did the former, though)
08:38:24 <zooko> Did you find the fuller context, though?
08:38:27 <araujo> http://www.cs.cmu.edu/~mihaib/kernighan-interview/index.html
08:38:30 <zooko> Thanks.
08:38:36 <araujo> Welcome.
08:39:04 <araujo> Let's take Haskell out to the street!
08:39:35 <SamB> give me a laptop!
08:39:37 <araujo> zooko, He also offers interesting point of views about ML.
08:39:41 <araujo> SamB, haha
08:39:48 <SamB> also a wifi card and an access point
08:40:03 <jlouis> SamB: heh, maybe I should look deeper at it and fix stuff
08:40:14 <SamB> shouldn't be too hard
08:40:33 <araujo> earthy, coming back to you... i think "declarative" reasoning is easier for human beings....
08:40:48 <SamB> I moved some stub code from Conjure to Conjure.MasterThread, which should help with the latter...
08:41:00 <araujo> It is just that in a society where imperative p. are predominants, that seems impossible to believe.
08:41:08 <SamB> oh, also I answered your comment in FSThread
08:41:15 <jlouis> ;)
08:41:27 <jlouis> Work's hard
08:41:54 <Philippa> araujo: historically, declarative programming in a manner appropriate to 'real world' systems is not something that's been well-taught
08:42:16 <araujo> Philippa, Yes, tat's where i see Haskell making a good difference.
08:42:20 <Philippa> even today, that's often the case because people're so busy teaching FP they never teach you how to get down'n'dirty in the IO monad even though it can do every last filthy thing C can
08:42:33 <Philippa> and yes, Haskell is *very* good at that
08:42:41 <SamB> no!
08:42:43 <SamB> it cannot!
08:42:46 <Philippa> enough so that you don't feel you're "just" doing imperative code in another language
08:42:49 <SamB> it cannot lay out structs for you
08:43:07 <Philippa> SamB: give me a few hours of boredom and the FFI and I'll fix that for you
08:43:07 <araujo> Yes, like i sadi... it is difficult for me to get a Lisp book here, but i have bought all my Haskell books in local stores.
08:43:20 <SamB> or at least, not without libraries that are missing
08:43:23 <Philippa> the "just" criticism is aimed largely at the ML family, btw :-)
08:43:30 <Philippa> although I guess the lisps're even worse
08:43:41 <SamB> admitedly, you can't do that in libraries in C
08:43:43 <Philippa> Haskell's a lot nicer syntactically than most of the MLs, too
08:43:50 * Philippa nods
08:43:52 <xerox> agreed
08:43:54 * araujo would like to see a Haskell Cookbook
08:44:08 <Philippa> the thing is, all the things we can't do in the IO monad now can be built
08:44:12 <jlouis> I grint a bit about why they did not like to use Haskell for teaching here
08:44:22 <jlouis> Integral a => ... is too hard ;)
08:44:26 <SamB> maybe not quite all
08:44:32 <jlouis> for beginning programmers.... they say
08:44:33 <Philippa> they might occasionally need a bit of TH or something to be comfortable, but you can do the lot
08:44:40 <SamB> but those probably require inline ASM or GNU extensions anyway
08:44:48 <mjl69_> I am finding it confusing learning Haskell when terminology that is common in other popular non-functional languages is used with different meanings.  At least I think the meanings are different.
08:44:54 <Philippa> and you can still call those things from the IO monad, if you see my point
08:44:57 <neologism> I read about some research project - they taught prolog to <10 yrs old children
08:45:00 <SamB> mjl69_: such as?
08:45:03 <SamB> true!
08:45:04 <neologism> to see wheter logic programing is ahrd or not
08:45:06 <Philippa> mjl69_: any good examples other than functor?
08:45:08 <araujo> Well, O'Caml syntax is like hitting your head against a wall , "you don't know what you are doing until you start bleeding" 
08:45:12 <SamB> FFI is cool
08:45:32 <SamB> I was going to say that sometimes you might want to just use C for those bits ;-)
08:45:33 <CosmicRay> araujo: what about lisp syntax then? ;-)
08:45:49 <Philippa> mjl69_: I guess the different use of 'variable' springs to my mind, and most people think pattern-matching is something you only do on text...
08:46:00 <palomer> hrmph
08:46:08 <araujo> CosmicRay, Really, O'Caml might get uglier :-P
08:46:09 <palomer> I wish xchat would priv message me everytime someone uses my name
08:46:21 <CosmicRay> araujo: you realize that camlp4 has a scheme parser, right? ;-)
08:46:30 <araujo> haha
08:46:36 <SamB> lisp syntax is too little; ocaml syntax is too much?
08:46:49 <mjl69_> pattern matching makes me thing of regular expressions.  Constructors make me think of functions that are methods of a class that create a class instance.  Classes make me think of user defined types.
08:46:49 <CosmicRay> ocaml syntax is... too weird.
08:46:51 <shapr> palomer: You can get it to beep and turn the tab a different color.
08:46:52 <palomer> ocaml introduced 100 or so new productions in their syntax so they could have dynamic dispatch
08:46:56 <araujo> SamB, yes, it gives me that impression.
08:47:09 <CosmicRay> ocaml looks like it really wants to be haskell, but isn't so sure about the whole laziness thing
08:47:19 <palomer> shapr: yeah, but the channel buffers are only so big
08:47:26 <shapr> huh?
08:47:32 <CosmicRay> also it looks like it really wants to do I/O, but isn't so sure about this whole notion of interacting with things
08:47:38 <araujo> haha
08:47:38 <xerox> shapr!
08:47:41 <shapr> palomer: You can change buffersize, and turn on logging.
08:47:43 <palomer> shapr: so the line of text gets erased
08:47:46 <shapr> hiya xerox 
08:47:50 <CosmicRay> I/O in OCaml is really, really crappy.
08:47:55 <CosmicRay> I mean extremely bad.
08:47:59 <CosmicRay> terrible horrible and ugly.
08:48:03 <palomer> CosmicRay: but fast!
08:48:12 <CosmicRay> yes, fast, if it can do what you want to do.
08:48:21 <CosmicRay> but woe to you if you want to open a file for reading and writing.
08:48:24 <araujo> palomer, C is faster!
08:48:29 <shapr> And OCaml Int is also machine specific and silently overflows.
08:48:36 <palomer> araujo: not really
08:48:42 <CosmicRay> shapr: not to mention that it is one bit smaller than the machine int in C.
08:48:42 <araujo> And i'd dare to say.. less ugly? ;-)
08:48:55 <palomer> ocaml and C are usually as fast as each other, sometimes ocaml is faster for IO
08:49:00 <CosmicRay> yes that's right folks, ocaml's int is 31 bits.
08:49:02 <Philippa> mjl69_: there's a reason that typeclass is short for class. Constructors're actually closely analogous to OO constructors though - we just get extra info from their use
08:49:02 <araujo> Well, being fast or slow is not a language feature at all.
08:49:10 <shapr> Haskell can be faster than both OCaml and C if you use amortized algorithms.
08:49:12 * ski wonders what's that ugly in OCaml ..
08:49:16 <Philippa> er, class short for typeclass even
08:49:22 <CosmicRay> ski: read up on their I/O functions
08:49:29 <neologism> shapr: amortized algorithms?
08:49:35 <CosmicRay> ski: also note that ocaml has a lazy list type -- a stream -- but most everything expects a regular list.
08:49:40 <shapr> Laziness can let you use less memory than a strict language if you use it right.
08:49:43 * ski meant syntax
08:49:45 <CosmicRay> so you have to reimplement things like map and whatnot to work with the lazy list.
08:49:47 <xerox> heh!
08:49:57 <araujo> That's up to the impolementation. I am quite surprised how goo GHC does in: http://shootout.alioth.debian.org/
08:49:58 <CosmicRay> which I did in my MissingLib library.
08:50:04 <shapr> @google okasaki amortization
08:50:04 <araujo> good*
08:50:05 <lambdabot> http://citeseer.ist.psu.edu/okasaki96role.html
08:50:23 <shapr> neologism: Lazy is good, it lets you do thing at the very last moment.
08:50:39 <mjl69_> Philippa: maybe it's more like template classes in C++?  When I read 'generic programming' I thought of that.  I also heard Bjarne Stroustrup in an interview from a few years back has an interest in functional programming.
08:50:46 <xerox> shapr: haha that's a description that fits us.
08:50:47 <neologism> I just didnt know what amortized algo is
08:51:18 <Philippa> mjl69_: type classes're sort of analogous to abstract base classes in C++ - it doesn't have an equivalent language-level consturct
08:51:21 <Philippa> *construct
08:51:31 <ski> (or interfaces in Java)
08:51:44 <Philippa> Constructors are *very* analogous to C++ constructors - they're just functions that build values
08:51:57 <Philippa> it's just that in Haskell, we can always tell which constructor a value was built with
08:52:11 <ski> that's not 'just'
08:52:26 <Philippa> depends on your POV :-)
08:52:38 <xerox> and your RAY
08:52:39 <ski> (difference between algebraic datatypes and coalgebraic datatypes)
08:52:44 <shapr> neologism: Okasaki showed that algorithms with amortized versions have better complexity than strict version. But, not all algorithms can be amortized, and you can fake it in a strict language with explicit laziness (though that sucks).
08:52:50 <xerox> ski: that is fun.
08:52:55 <Philippa> ski: no. Difference between algebras and initial algebras.
08:53:08 <xerox> ski: got around implementing the coalgebraic madness?
08:53:24 <Philippa> C++ constructors have junk and confusion :-)
08:53:27 <ski> Philippa : methods more or less is deconstructors in coalgebras
08:53:39 <araujo> Philippa, That's what C++ is all about
08:53:42 * araujo giggles
08:54:01 <Philippa> ski: I know. They're also not really relevant to what I'm discussing, and ... *bah*
08:54:22 * Philippa was about to point out that coalgebras don't give you any means of constructing an instance
08:54:28 <mjl69_> Philippa: that's helpful to think of abstract base classes.
08:54:36 <Philippa> C++ objects are not /just/ coalgebraic datatypes
08:57:20 <palomer> O'Caml is a good example of what happens to a language when you decide to add the latest and greatest thing
08:58:06 <Oejet> Greetings.
08:58:09 <Philippa> I think there're places where that's a bit unkind
08:58:27 <shapr> palomer: I dunno, there's template haskell, GADTs, and more in GHC, and it's still decent.
08:58:28 <Philippa> it's an amalgam of things that were generally considered desirable at the time, with some newish techniques for implementing them
08:58:46 <Philippa> shapr: you say that only because nobody's silly enough to touch implicit parameters ;-)
08:58:56 <shapr> Well, true...
08:59:12 <xerox> uh? :(
08:59:18 * xerox feels TheHunter
09:00:08 <Philippa> YKWIM though
09:00:25 <Philippa> almost any use counts as considerably nastier than any of the stuff I've pulled in real code
09:00:37 <Philippa> (I really, really should comment more though)
09:00:57 <Philippa> ski: was just saying on the way out that C++ objects aren't /just/ coalgebraic datatypes, that the means of construction is also highly important
09:01:15 <Philippa> I'm wondering if I've understood bialgebras well enough...
09:01:42 <Philippa> it's certainly fair play to describe the use of constructors in C++ as resembling (non-initial) algebras
09:02:10 <ski> granted
09:02:52 <Philippa> similarly I wonder if the functions on a type in haskell constitute a non-final coalgebra, I guess
09:03:29 <ski> (hm, right, i should have said initial algebraic datatypes and terminal coalgebraic datatypes)
09:03:45 <Philippa> I knew what you meant when you said datatypes
09:04:08 <Philippa> the point is they're datatypes built around the notion of a specific variety of algebra or coalgebra, 'sall
09:04:34 <Philippa> not our fault if the commonly adopted usage is insufficiently specific :-)
09:04:47 * ski feels an urge to make a syntax-extension to haskell
09:05:33 <Philippa> oh?
09:06:06 <ski> just more "declarative" syntax for methods
09:06:43 <ski> but, i should try to actually implement it
09:07:11 * ski wonders which haskell-parser he should start from ..
09:07:14 <Philippa> a good extensible Haskell parser'd be great
09:07:26 <ski> yeah, it could be
09:07:34 <CosmicRay> one that could emit a pretty-printed tree as well
09:07:38 * CosmicRay thinks of camlp4 here
09:07:42 <Philippa> heh
09:07:44 <ski> hehe
09:13:07 <ski> (Philippa : terminal coalgebras give a means for constructing instances)
09:15:05 <Philippa> ski: I'd understood that, although I've not seen an actual example and probably should sometime. AIUI there's a reason we don't use 'em though :-)
09:15:12 <Philippa> (except, er, records?)
09:15:31 <ski> Head (as0 /\/ as1) = Head as0
09:15:31 <ski> Tail (as0 /\/ as1) = as1 /\/ Head as0
09:15:31 <ski> ?
09:16:07 <Philippa> assume I'm a complete newbie for a mo and run me through the syntax?
09:16:10 <ski> meaning same as current
09:16:13 <ski> as0 /\/ as1 = Cons
09:16:13 <ski>   { head = as0
09:16:13 <ski>   , tail = as1 /\/ head as0
09:16:13 <ski>   }
09:16:32 <ski> (/\/) is your OO class "constructor"
09:17:38 <ski> those two linea above descibes what happens when one apply various methods/deconstructors/field-accessors to a object constructed by (/\/)
09:17:53 <ski> does that suffice as explanation ?
09:18:33 <Philippa> um. Not entirely sure. Why is Head (as0 /\/ as1) = Head as0 rather than as0?
09:18:52 <ski> (/\/) :: Stream a -> Stream a -> Stream a
09:19:06 <ski> head of the resulting stream is head of the first stream
09:19:16 <Philippa> ah
09:19:42 * Philippa often does her head in on stream representations due to being used to thinking "it's just a list with no Nil involved"
09:19:47 <ski> (this is possibly not a terribly useful example, but should show the syntax)
09:20:35 <ski> point is, the LHS of '=' needn't have function defined in it's left-most application position
09:20:48 <ski> i.e. Head isn't being defined above, (/\/) is
09:21:04 * Philippa nods
09:21:11 <Philippa> you understand why I said what I did about records though?
09:21:17 <ski> so, it sortof patternmatches both on inside (arguments) and on outside (how result is used)
09:21:42 <ski> Philippa : didn't understand your intent there, no
09:22:31 <ProfTeggy> Have a nice evening/rest of the day, all
09:22:38 <ski> m
09:22:45 <shapr> Silly question, when something says 'use a radian mode here' how do I convert it to boring Haskell code?
09:23:10 <ski> radian mode ?
09:23:35 <shapr> I'm trying to write a module that calculates the amount of daylight, using http://mathforum.org/library/drmath/view/56478.html
09:23:50 <ski> degreeToRadian = (* pi) . (/ 180)
09:23:50 <ski> ?
09:23:54 <Philippa> ski: you build a record (sort-of) by specifying the answer to each way you could take it apart
09:24:10 <ski> Philippa : yes
09:24:46 * ski thinks lazy records fits good for this
09:25:06 <Philippa> what's the laziness?
09:25:30 * shapr grumbles
09:25:52 <Philippa> shapr: ?
09:25:57 <Philippa> "radian mode"?
09:25:58 <ski> well, if a field is / methof returns say a list, then it won't be forced until we extract that field / call that method
09:26:12 <Philippa> don't existing records do that?
09:26:17 <ski> sure
09:26:34 <ski> but in a lang with strict records, it wouldn't
09:27:07 <ski> (note that methods in OCaml classes which have non-functional type is still not evaluated until method call)
09:27:10 <xerox> shapr: cool
09:27:30 <shapr> What's wrong with this? http://www.scannedinavian.org/~shae/Daylight.hs
09:27:38 <shapr> lisppaste2: url
09:27:38 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:28:08 * ski is mostly after this syntax for (hopefully) different thinking and viewpoints about code (and possibly easier reasoning)
09:28:25 <Philippa> fair enough
09:28:35 <Philippa> I... think I have an unusual way of thinking about records by now anyway :-)
09:28:45 <shapr> ok, I put it on the paste page - http://www.haskell.org/hawiki/HaskellIrcPastePage
09:28:59 * ski would prefer reading the multi-equation definition-style for records over the current style, in many cases, he thinks
09:29:01 * Philippa needs to sit down and implement that language with strict and lazy monads and a 'canonical' value representation...
09:29:03 <shapr> Did I translate the equation incorrectly?
09:29:14 <ski> Philippa : sounds interesting :)
09:29:16 <shapr> Am I confused about how to convert degrees to radians?
09:29:26 <Philippa> ski: it wasn't that complicated, but likely to be a syntactic PITA
09:29:31 <Philippa> brb, NMI ;-)
09:29:37 <ski> hehe
09:30:17 <ski> (Philippa : which wasn't that complicated ?)
09:31:03 <xerox> > minimum $ zip (map shaelocation [1..365]) [1..365]
09:31:03 <xerox> (12.055194494184398,356)
09:31:03 <lambdabot>  Not in scope: `shaelocation'
09:31:58 <shapr> Yeah, but ... the maximum isn't very different, meaning I've done something wrong.
09:32:03 <shapr> Hiya SyntaxNinja, how's life?
09:32:32 <shapr> Also, I checked another website that says that I get 2 hours 43 minutes sunlight here.
09:32:44 <shapr> This is my reference - http://www.exptech.com/sunrise.htm
09:34:32 <Philippa> ski: the language
09:34:42 <Philippa> though I think I've just given myself a nasty little moment of headfuck now
09:34:58 <Philippa> better dig up the plans I'd had...
09:35:07 * ski is still curious
09:35:12 <Philippa> really the hard part is remembering to thread the monad association through with /every/ value
09:35:29 <Philippa> I keep wanting to use Int as sugar for m Int
09:35:59 <ski> maybe you could relate some of the basic ideas ?
09:36:32 <ski> (using 'Int' instead of 'm Int' in attempts at embedding in haskell ?)
09:36:44 <Philippa> argh, can't find the text file I'd been dumping it into
09:36:50 <Philippa> hope like hell it wasn't lost in yesterday's crash
09:37:55 <ski> hmhm
09:38:00 <ski> maybe later then
09:42:30 * ski thinks he'll leave for misty dream land
09:42:56 <Philippa> ski: found the text file...
09:44:37 <SyntaxNinja> heya shapr. pretty good.
09:45:18 <Philippa> ah yes, the idea was that an Int was essentially an Int#, but you probably dealt with a Strict Int or a Lazy Int most of the time
09:59:24 <zooko> "I will oversimplify a lot, and probably offend my friends, by saying that the only thing people do with ML is to make ML compilers. [laughing] I'm overstating intentionally, but it has some of that flavor, and I don't really understand why." <-- from the Kernighan interview
09:59:36 <zooko> I was thinking along these lines during the earlier discussion of language adoption and so forth on this channel.
09:59:49 <zooko> I was thinking something like "Until darcs, the only thing people did with Haskell was write Haskell compilers".
09:59:53 <Philippa> the other stuff doesn't get noticed against all the equivalent projects in other languages
10:00:13 <Philippa> it's true that compilers and interpreters are a really natural home ground for Haskell
10:00:20 <Philippa> hence the other well-known project being Pugs
10:01:59 <SamB> some day I'd like to get Self going again
10:02:01 <neologism> I happily use haskell for doing my math exercises ;)
10:02:33 <SamB> anyways, Parsec is not good for Haskell compilers, so Haskell must be used for SOMETHING else...
10:02:45 * musasabi uses happily haskell for network application
10:02:49 <Philippa> other compilers - it's good enough for Pugs ;-)
10:02:50 <musasabi> +s
10:02:50 <SyntaxNinja> shapr: how's life w/ you?
10:03:00 <Philippa> yeah, and it's good for web apps give or take the libraries that still need work
10:03:29 <SamB> probably the main reason is that parsec isn't terribly convenient to use with tokenizers...
10:03:40 <musasabi> Philippa: much work in my opinion, still got to catch PHP. (records would help a lot)
10:03:41 <SamB> and that its too slow for GHC, probably...
10:04:07 <Philippa> musasabi: true. OTOH, I wouldn't be using PHP on principle - for someone like me, Haskell ain't bad as-is
10:04:22 <Philippa> SamB: I don't think speed is the issue
10:04:25 <musasabi> could one use TH to optimize parsec parsers?
10:04:33 <Philippa> I *do* think postdating GHC's existing parser won't have helped :-)
10:04:38 <Philippa> you probably could, yes
10:04:53 <Philippa> the first-order fragment is just PEGs if I've understood correctly
10:05:10 <Philippa> and you can firstify the lot if there's no input dependance
10:05:25 <musasabi> Philippa: then again most of the time things like "what languages do other admins understand" and "what languages are the libraries written in" make the decisions.
10:05:59 <Philippa> yeah. Which is the thing causing the most problems
10:06:03 <neologism> the code in english :)
10:06:06 <Philippa> you need a shell account to have haskell hosting in effect
10:08:33 <musasabi> and in a multiperson project pick a language that most people understand
10:08:41 <musasabi> which usually means perl or php
10:08:52 <musasabi> (for web things)
10:08:58 * Philippa nods
10:09:18 <Philippa> I think haskell's most likely to make a splash in classes of web app that take good coders and're too easy to fuck up in langs like perl or PHP
10:09:29 <Philippa> the space where you're paying for pros anyway
10:09:41 <musasabi> true
10:10:03 <musasabi> Currently one problem is database access
10:10:57 <Philippa> yeah, really I should do more stuff with databases generally. I'm good for typical here's-how-you-build-a-database-kiddies stuff and that's about it
10:11:12 <Philippa> (oh, that and if you make me play with the relational algebra or calculus for a while I'll get scary, but hey)
10:11:12 <musasabi> HaskellDB is very nice but types get larger than code with the lack of proper records
10:12:08 <musasabi> relational algebras and calcules are fun :-) 
10:12:10 <Philippa> sometimes I'd like the ability to add top-level type variables and constraints
10:12:25 <Philippa> declare a new type variable that I constrain to be the type of some function and then use elsewhere, stuff like that
10:12:48 <Philippa> I get the impression that could be v.helpful for working with huge types?
10:13:02 <musasabi> yes to some extent
10:13:12 <musasabi> typelevel functions would be another solution
10:13:28 <musasabi> proper records would just solve the problem for databases etc
10:13:55 <Philippa> the top-level tyvar thing occurred to me while thinking about how ugly the types in Flippi's PageIO system get :-)
10:14:08 <Philippa> I *think* it can even be given sane semantics...
10:14:19 <musasabi> how long?
10:14:21 <Philippa> though it might get bitten by mutual recursion
10:14:29 <musasabi> multipage monsters?
10:14:40 <Philippa> not all that long. But they could use a certain kind of factoring
10:14:48 <musasabi> brings back memories from C++
10:14:50 <chucky> philippa: I think people have been discussing this before, but I can't remember when
10:15:11 <Philippa> eg so the transformer records have field types like funcNameType -> funcNameType rather than expanding out the type of funcName explicitly
10:15:11 <chucky> I think it came up a few times while we were working on haskelldb
10:15:45 <chucky> it does sound like a very sane extension.
10:15:54 <Philippa> it's also occurred to me that perhaps I want modules to be bound to monads or some other kind of notion of computation, s.t. it's legit to do top-level things with identity in an IO module...
10:16:29 <Philippa> ...but that's a bit more bluesky. And a lot more powerful in the context of something like Epigram, so probably better explored there
10:17:15 <Philippa> I *think* all it wants is the top level tyvar definition (one new keyword) and an extension to type annotations so they can contain the equivalent of union types but only "return" the top one
10:17:15 <zooko> later, folks.
10:17:20 <Philippa> f :: actualtype
10:17:27 <Philippa>   :+ othertype
10:17:27 <musasabi> Philippa: would that help with types like http://www.cs.helsinki.fi/u/ekarttun/hswebforms/doc/html/WebForm.HaskellDB.html ?
10:17:29 <Philippa> f = ...
10:17:56 <xerox> ..what is this type madness useful for, sorry?
10:18:14 <Philippa> xerox: producing type expressions that make effective use of 'name abstraction'
10:18:36 <xerox> synonyms?
10:18:45 <musasabi> xerox: automatically doing usefull stuff for data whose exact type is unknown.
10:18:50 <Philippa> synonyms and more effective ways to bind them to fragments of types
10:19:11 <musasabi> synonyms don't help for the explosion of class constraints
10:19:21 <Philippa> unfortunately no, they don't
10:19:29 <xerox> what does it mean?
10:19:50 <Philippa> they... might if they can be kept on the inside of a given expression, but GHC's type system doesn't work like that yet
10:19:58 <xerox> if you're willing to explain it
10:20:26 <Philippa> given the example I gave with f...
10:20:39 <musasabi> xerox: foo :: (Bar a n f a, Foo a a f a g, Zzz (B a) (C d), ...) => a -> b, where the types just get longer and longer
10:20:56 <xerox> uh.
10:21:04 <Philippa> you'd match f's type against actualtype, and /then/ match against othertype as well. The intention is that othertype causes some unifications with type variables from an outer scope
10:21:07 <xerox> and how would it look thanks to the :+ ^
10:21:14 <xerox> s/^/?/
10:21:38 <Philippa> my proposal doesn't really attack that, because it can't hit the class constraints
10:22:13 <musasabi> Philippa: one could force class constraints with GADTs perhaps?
10:22:19 <Philippa> perhaps
10:22:25 <musasabi> anyway, got to run. back in an hour
10:22:37 <Philippa> really I think going full System F + constraints-with-the-foralls is the way to go, but hey
10:22:46 <joelr1> how do you create a StorableArray?
10:22:55 <joelr1> howdy
10:23:17 <joelr1> wow, what a split
10:23:39 <xerox> netquake
10:29:30 <Philippa> joelr1: er, good question
10:29:50 <joelr1> it's supposed to have the MArray interface
10:30:09 <joelr1> so i wonder if it's just array :: Storable ... = newArray ...
10:30:17 <Philippa> quite possibly
10:30:21 <Philippa> try it and see if it works?
10:30:33 <joelr1> right
10:32:16 <joelr1> is there a shorter way to write 
10:32:16 <joelr1>     peek ptr = peek ptr >= \a -> return $ byteToCard a
10:32:17 <joelr1> ?
10:32:33 <joelr1> something like peek ptr >= return . byteToCard maybe?
10:32:59 <Philippa> yeah
10:33:33 <Philippa> @pl peek ptr = peek ptr >= \a -> return $ byteToCard a
10:33:33 <lambdabot> peek = fix (flip flip (return . byteToCard) . ((>=) .))
10:33:46 <Philippa> maybe not /that/ pointless :-)
10:34:04 <Philippa> did you intend the recursion?
10:34:51 <joelr1> Philippa: well, no
10:35:00 <joelr1> Philippa: i thought it would go by type
10:35:02 <Philippa> peek' ptr = peek ptr...?
10:35:12 <joelr1> byteToCard :: Word8
10:35:33 <Philippa> ah, peek's in a typeclass?
10:35:36 <joelr1> and there's a peek defined for Word8
10:35:40 <joelr1> Storable, yes
10:35:40 <Philippa> right
10:36:07 <Philippa> you might need to give it some type annotation, because that looks like it's gonna recurse forever to me
10:36:48 <joelr1> Philippa: but wouldn't it infer the type automatically? based on the fact that Card and Word8 are different types?
10:37:14 <Philippa> what's the type of peek?
10:37:27 <joelr1> it depends
10:37:28 <joelr1> @type peek
10:37:29 <lambdabot> Not in scope: `peek'
10:37:36 <Philippa> because barring a MPTC, that's gonna recurse endlessly
10:37:37 <joelr1> @type Foreign.Storable.peek
10:37:39 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
10:38:12 <Philippa> so ptr is a Ptr <whatever we infer>
10:38:15 <joelr1> so how do i properly resolve this? i obviously want peek :: Word8 to be used the second time around
10:38:22 <Philippa> if <whatever we infer> doesn't match it'll just fail to typecheck
10:39:07 <Philippa> AFAICT, for any given free variable ptr in the expression (peek ptr) there's no way to get a different result type out
10:39:24 <joelr1> oh, well
10:39:37 <Philippa> you appear to be intending an implicit cast of some sort?
10:39:53 <Philippa> what's the type you're defining peek on there?
10:39:54 <joelr1> Philippa: well, yes, i want peek (Ptr Word8
10:39:56 <joelr1> err
10:40:16 <joelr1> peek :: Ptr Word8 -> IO Card
10:40:28 <Philippa> you can't do that
10:40:39 <joelr1> and to get there i need to peek a Word8 first and then convert that to Card 
10:40:46 <Philippa> you can define a generalised peek in a typeclass with an input and an output type
10:40:56 <Philippa> you can have a peek' that works properly
10:40:57 <joelr1> err
10:40:58 <joelr1> never mind
10:41:13 <joelr1> peek :: Ptr Card -> IO Card b
10:41:20 <Philippa> *ah*
10:41:25 <joelr1> b(ut) i i need to peek a byte first 
10:41:32 <joelr1> and then call a conversion fun on that byte
10:41:36 <Philippa> (er, you're missing a b in the LHS of the -> there?)
10:41:47 * Philippa nods
10:41:53 <Philippa> do you know where that byte is from the Card?
10:42:03 <joelr1> toByte/fromByte
10:42:04 <Philippa> or to put it another way, are you happy you know what you're doing now? :-)
10:42:04 <joelr1> err
10:42:10 <joelr1> byteToCard/cardToByte
10:42:50 <joelr1> i'm just looking for a shorter notation than do { a :: Word8 <- peek (castPtr ptr); return byteToCard a }
10:43:18 <Philippa> all I can offer's the usual advice of bind it to a shorter name
10:43:34 <joelr1> ok
10:44:41 <ihope> > let x * 2 = 6 in x
10:44:41 <lambdabot>  Not in scope: `x'
10:45:15 <Philippa> ihope: doesn't work in haskell
10:45:22 <Philippa> would work in prolog
10:45:29 <ihope> I guess that explains it.
10:45:47 <Philippa> the LHS of the = is a pattern, just like in a case statement or a function pattern
10:45:53 <SamB> ihope: you confused by n+k patterns
10:45:56 <SamB> ?
10:46:00 <Philippa> looks like it
10:46:06 <Philippa> bloody special cases confusing people :-)
10:46:17 <ihope> SamB: http://en.wikibooks.org/wiki/Programming:Haskell_Preliminaries
10:46:39 <ihope> I suppose the "-- This is Math, not Haskell" should have pointed that out to me...
10:46:44 <Philippa> yes, it should
10:46:51 <ihope> :-)
10:47:43 <SamB> yet another reason why n+k patterns should die
10:47:56 <ihope> Aye.
10:48:25 <ihope> I tried to use an n++k++m pattern once.
10:48:35 <SamB> heh
10:48:37 <Philippa> SamB: were you there for the argument about views last night?
10:48:44 <SamB> some of it at least
10:48:45 <Philippa> I found something beautiful in the paper that proposed pattern guards...
10:48:51 <Philippa> pat!func
10:48:58 <ihope> Anyway: what happens if you conbine an infixl and an infixr?
10:49:01 <Philippa> do I need to explain the intended semantics of that pattern? :-)
10:50:11 <Igloo> Was this confusion actually caused by knowing about n+k patterns?
10:50:11 <Philippa> sadly that never made GHC, but I think it kinda renders views as a feature redundant and if anything damaging
10:50:14 <SamB> ihope: fixity error?
10:50:19 <SamB> er, associativity that is?
10:50:20 <Philippa> (do I make it a view, or an ordinary datatype?)
10:50:31 <ihope> SamB: that's what I thought.
10:51:01 <SamB> Philippa: ooh, that looks fantistic
10:51:14 <xerox> Philippa: explain it!
10:51:44 <Philippa> xerox: runs the thing being matched through func, then matches pat against the result
10:51:47 <Philippa> 'scalled a transformational pattern
10:51:52 <SamB> that sounds exactly like the way to do exactly what whats-his-name was saying
10:51:59 <Philippa> er, me? ;-)
10:52:03 <SamB> hmm.
10:52:03 <xerox> Philippa: sounds way cool
10:52:16 <Philippa> or solve the problems with it Heffalump was complaining about, yeah
10:52:18 <xerox> ...is it good for streams and the alike?
10:52:32 <SamB> the one who was arguing against views, on the basis that you could use toView and case over it instead
10:52:39 <Philippa> that was me :-)
10:52:42 <SamB> oh
10:53:01 <Philippa> in particular, I get cranky about that because some people seem to assume you don't need a toView function somewhere...
10:53:03 <SamB> see, I don't remember who was on which side, just what was argued ;-)
10:53:09 <Philippa> heh, that's okay
10:53:37 <Philippa> the problem with views is you have to mark out datatypes as 'views' rather than data, which starts to get really icky
10:53:37 <SamB> well, as far as I know, you could get away with a matchView function...
10:53:47 * Philippa nods
10:54:06 <Philippa> Heffalump's complaints were all syntactic - needing a two-layer function to dispatch through all the views, stuff like that
10:54:29 <ihope> Why isn't (==) associative?
10:54:45 <SamB> I was thinking you could use function names and special magic glue
10:54:55 <Philippa> anyway, I thought you'd find it amusing that the debated'd been had and essentially resolved 5 years ago and that /that/ was probably the reason nobody working on or close to GHC wants views any more :-)
10:55:12 <SamB> what was the resolution?
10:55:19 <SamB> they need to put it up somewhere public
10:55:24 <Philippa> "transformational patterns + pattern guards > views"
10:55:25 <Philippa> it is
10:55:27 <SamB> where people will notice it
10:55:33 <SamB> like, say, the wiki
10:55:42 <Philippa> It's a SimonPJ paper
10:55:43 <Philippa> http://research.microsoft.com/~simonpj/Papers/pat.htm
10:55:53 <SamB> and then we can bother them about not having implemented transformational patterns instead ;-)
10:56:07 <xerox> ihope: 'cause it's not a -> a -> a, I think, but a -> a -> Bool
10:56:09 <Philippa> transformational patterns are admittedly potentially a little icky to make go fast
10:56:23 <ihope> xerox: Bool -> Bool -> Bool?
10:56:35 <xerox> nope, Eq a => a -> a -> Bool
10:56:55 <ihope> But Bool is in Eq.
10:57:10 <SamB> I don't care about icky in the fast
10:57:17 <xerox> But you can't compare different things.
10:57:37 <xerox> I.e. they're 'a', but they've to be equal.
10:57:39 <SamB> they are ugly to write now, I'd prefer that they be prettier sooner rather than faster later and prettier at the same time...
10:58:07 <ihope> If x, y and z are all booleans, wouldn't (x == y) == z and x == (y == z) be the same?
10:58:07 <xerox> ...if you've got a list of Bools you can get along with any/all, either.
10:58:18 <xerox> Sure.
10:58:28 <xerox> Err
10:58:32 <SamB> you could make == associative, but it would be confusing...
10:58:41 <xerox> kWould it?
10:58:42 <ihope> True...
10:58:57 <SamB> specially cause I don't think those are the same
10:59:04 <xerox> No, it wouldn't
10:59:20 <SamB> quick, whats the QuickCheck for that?
10:59:55 <xerox> I mean they would give the same result, but it's wrong in the False,False,False case I think
11:00:13 <ihope> False?
11:00:38 <xerox> (False == False) == False  =>  True == False  =>  False
11:00:52 <flux__> hmm.. debian really should have more haskell packages. it does have quite a satisfying set of ocaml packages, though ;)
11:00:52 <xerox> False == (False == False)  =>  False == True  =>  False
11:00:58 <SamB> what, huh
11:01:06 <SamB> Prelude Test.QuickCheck> let boolEqAssoc x y z = ((x == y) == z) == (x == (y == z))
11:01:09 <SamB> Prelude Test.QuickCheck> quickCheck boolEqAssoc
11:01:09 <SamB> Loading package QuickCheck-1.0 ... linking ... done.
11:01:09 <SamB> OK, passed 100 tests.
11:01:17 <xerox> O_o
11:01:43 * xerox scratches head
11:01:44 <ihope> Hmm, cool.
11:02:08 <ihope> So it's associative? >:-)
11:02:26 <xerox> > Test.QuickChec.quickCheck \x y z -> ((x == y) == z) == (x == (y == z))
11:02:26 <SamB> well, quickCheck certainly seems to think so
11:02:26 <lambdabot>  parse error on input `\'
11:02:35 <xerox> > Test.QuickChec.quickCheck $ \x y z -> ((x == y) == z) == (x == (y == z))
11:02:35 <lambdabot>  Not in scope: `Test.QuickChec.quickCheck'
11:02:37 <ihope> It is!
11:02:39 <xerox> err
11:02:43 <xerox> > Test.QuickChek.quickCheck $ \x y z -> ((x == y) == z) == (x == (y == z))
11:02:44 <lambdabot>  Not in scope: `Test.QuickChek.quickCheck'
11:02:49 <xerox> > Test.QuickCheck.quickCheck $ \x y z -> ((x == y) == z) == (x == (y == z))
11:02:49 <lambdabot>  Not in scope: `Test.QuickCheck.quickCheck'
11:02:53 <xerox> Okay.
11:03:28 <xerox> > let x = False; y = x; z = y; in ((x == y) == z) == (x == (y == z))
11:03:29 <lambdabot> True
11:03:41 <xerox> > let x = False; y = x; z = y; in (((x == y) == z),(x == (y == z)))
11:03:42 <lambdabot> (False,False)
11:03:46 <xerox> You see...
11:04:28 <ihope> ...I do...
11:04:44 <SamB> hmm.
11:04:52 <xerox> Eh.
11:05:21 <SamB> how do I get non-empty lists...
11:05:31 <xerox> (x:xs) ?
11:05:33 <ihope> By putting something between the brackets?
11:06:08 <xerox> If you mean a check in a list comprehension, you can do (y:ys) <- return xs
11:06:59 <SamB> Prelude Test.QuickCheck> let boolEqAssoc xs = not (null xs) ==> foldr1 (==) xs == foldl1 (==) xs
11:06:59 <SamB> Prelude Test.QuickCheck> quickCheck boolEqAssoc
11:06:59 <SamB> OK, passed 100 tests.
11:08:06 <xerox> ==> ?!?!
11:08:20 <xerox> I mean, ok, but the semantics are screwed up.
11:08:33 <ihope> Why???
11:09:12 <ihope> > 1*!
11:09:12 <ihope> > 1*1
11:09:13 <lambdabot>  parse error on input `}'
11:09:14 <lambdabot> 1
11:09:38 <ihope> @type (*)
11:09:38 <lambdabot> forall a. (Num a) => a -> a -> a
11:09:46 <ihope> Weird.
11:09:57 <SamB> xerox: whats the problem?
11:12:26 <ihope> In GHCi for a moment, _*2 was 6 and _*_ was an error.
11:13:22 <xerox> > take 5 $ map (foldl1 (==) &&& foldr1 (==)) $ zipWith ($) (repeat (\n -> take n $ cycle [True,False])) [1..]
11:13:23 <lambdabot> [(True,True),(False,False),(False,False),(True,True),(True,True)]
11:13:49 <xerox> > take 10 $ map (foldl1 (==)) $ zipWith ($) (repeat (\n -> take n $ cycle [True,False])) [1..]
11:13:50 <lambdabot> [True,False,False,True,True,False,False,True,True,False]
11:13:55 <ihope> > map (foldl1 (==) &&& foldr1 (==)) $ zipWith ($) (repeat (\n -> take n $ cycle [True,False])) [1..]
11:13:56 <lambdabot> [(True,True),(False,False),(False,False),(True,True),(True,True),(False,
11:13:56 <lambdabot> False),(False,False),(True,True),(True,True),(False,False),(False,False),(
11:13:56 <lambdabot> True,True),(True,True),(False,False),(False,False),(True,True),(True,True)
11:13:56 <lambdabot> ,(False,False),(False,False),(True,True),(True,True),(False,False),(False,
11:13:56 <lambdabot> False),(True,True),(True,True),(False,False),(False,False),(True,True),(
11:13:58 <lambdabot> [24 @more lines]
11:14:01 <xerox> > take 20 $ map (foldl1 (==)) $ zipWith ($) (repeat (\n -> take n $ cycle [True,False])) [1..]
11:14:02 <lambdabot> [True,False,False,True,True,False,False,True,True,False,False,True,True,
11:14:02 <lambdabot> False,False,True,True,False,False,True]
11:14:08 <xerox> You see.
11:14:22 <ihope> What do I see?
11:14:33 <CosmicRay> way too many bools.
11:14:40 <CosmicRay> way, way too many.
11:15:48 <xerox> The pattern has a meaning
11:16:11 <ihope> Is it binary for 42?
11:16:25 <CosmicRay> hehe
11:16:38 <ihope> Nah, [True,False,True,False,True,False] is.
11:16:44 <CosmicRay> ihope: carefull, you'll sound like igloo
11:16:48 <resiak> @type (&&&)
11:16:49 <lambdabot> Not in scope: `&&&'
11:16:54 <CosmicRay> long lists of bools for binary arithmetic ;-)
11:17:37 <resiak> xerox: What is this &&& ?
11:17:44 <xerox> @type (Control.Arrow.&&&)
11:17:45 <lambdabot> forall (a :: * -> * -> *) c' c b.
11:17:45 <lambdabot> (Control.Arrow.Arrow a) =>
11:17:45 <lambdabot> a b c -> a b c' -> a b (c, c')
11:17:59 <ihope> m [True,True,False,True,False,False,True] = 297?
11:18:09 <xerox> (f &&& g) x = (f x, g x)  in it's simplest form
11:18:16 <ihope> @djinn [Bool] -> Int
11:18:16 <lambdabot> -- f cannot be realized.
11:18:21 <xerox> then you got like
11:18:24 <ihope> I knew that wouldn't work...
11:18:35 <xerox> (f *** g) (x,y) = (f x, g y)
11:18:53 <xerox> first f (x,y) = (f x,y)
11:19:03 <xerox> second f (x,y) = (x,f y)
11:19:18 <xerox> >>> = flip (.)
11:19:49 <ihope> flip (.) eh?
11:20:02 <xerox> eh yeah
11:20:17 <xerox> (f . g) x = f (g x)
11:20:29 <xerox> (f >>> g) x = g (f x)
11:20:38 <ihope> Yay!
11:20:39 <resiak> xerox: Oh, handyhandy!
11:20:46 <xerox> resiak: hell yeah!
11:21:07 <ihope> I just took the factioral of 100000 and got a bunch of zeroes.
11:21:18 <ihope> Or zeros, if you prefer that spelling.
11:21:49 <Taral> xerox: That's the Arrow (->) instance.
11:21:55 <xerox> Taral: right on.
11:22:10 <Taral> ihope: The end of it has a lot of zeroes.
11:22:30 <ihope> Almost all factorials end with a lot of zeroes...
11:22:36 <xerox> Taral: do you know any other cool instance?
11:22:40 <Taral> Think about how many powers/multiples of 10 there are in the numbers from 1 to 100000
11:22:55 <ihope> Don't forget the 2's and 5's.
11:22:56 <Taral> xerox: Monad m => Arrow (Kleisli m) is interesting.
11:23:01 <ihope> > product [1..5]
11:23:02 <lambdabot> 120
11:23:07 <xerox> Taral: what does 'Kleisli' mean?
11:23:13 <Taral> It's a category theory term.
11:23:16 <Taral> So I dunno.
11:23:30 <tromp_> it's the name of a person
11:23:30 <ihope> > [ product [1..a] | a <- [1..] ]
11:23:31 <lambdabot> [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,
11:23:31 <lambdabot> 87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
11:23:31 <lambdabot> 121645100408832000,2432902008176640000,51090942171709440000,112400072777760
11:23:31 <lambdabot> 7680000,25852016738884976640000,620448401733239439360000,155112100433309859
11:23:31 <lambdabot> 84000000,403291461126605635584000000,10888869450418352160768000000,
11:23:33 <lambdabot> [23 @more lines]
11:23:35 <xerox> Can you elaborate on it?  I'm deeply interested
11:23:40 <mjl69_> > foldr1 (flip (.)) [(-) x|x<-[1..10]] 1
11:23:41 <lambdabot> 6
11:23:52 <mjl69_> foldr1 (.) [(-) x|x<-[1..10]] 1
11:24:03 <mjl69_> > foldr1 (.) [(-) x|x<-[1..10]] 1
11:24:04 <lambdabot> -4
11:24:54 <Taral> well, first you define Monad m => Kleisli m a b = Kleisli (a -> m b)
11:24:58 <Taral> then you have:
11:25:02 <Taral> arr f = Kleisli (return . f)
11:25:22 <Taral> Kleisli f >>> Kleisli g = Kleisli (\a -> f a >>= g)
11:25:34 <xerox> uh.
11:25:48 <xerox> Can you explain a bit about Kleisli by itself?
11:25:55 <Taral> it's a transformation from monads to arrows
11:26:24 <Taral> converting b -> m c into a b c
11:26:35 <Taral> in this case, (Kleisli m) b c
11:26:46 <Taral> if m is a Monad, Kleisli m is an Arrow.
11:26:54 <xerox> ...any interesting purposes other than that?
11:27:24 <Taral> No...
11:27:30 <xerox> Ah ok ok :-)
11:27:44 <ihope> Well... what are arrows?
11:28:05 <Taral> Arrows are transformations
11:28:14 <Taral> a b c, where a is an arrow, transforms b into c
11:28:17 <xerox> What a description :-P
11:28:22 <Taral> Best I can do.
11:28:27 <Philippa> Arrows are a generalisation of monads. You probably don't want to know more right now :-)
11:28:32 <xerox> Sorry, no harm meant
11:28:34 <ihope> No, I don't.
11:28:38 <Philippa> they get used a lot less than looked likely a short while ago
11:28:44 <xerox> Why so, the Arrow (->) instance is great
11:28:47 <Philippa> I think Yampa's the only really /good/ use I've seen
11:28:48 <xerox> dup = (id &&& id)
11:28:48 <Taral> That's because they're clumsy.
11:29:07 <Philippa> yeah, but it's great without invoking arrows IYSWIM
11:29:12 <ihope> I don't suppose there are Bows as well?
11:29:15 <Taral> Even the do syntax is clumsy.
11:29:15 <Philippa> nope
11:29:25 <Philippa> it's not just because they're clumsy, it's because they don't offer enough
11:29:30 <Trevion> Arrows are a demonstration that not everything in category theory makes functional programming easier.  (-;
11:29:51 <Philippa> Trevion: did you see what I mentioned earlier about transformational patterns btw?
11:29:59 <Philippa> I think implementing those would be far, far better than implementing views
11:30:04 <Trevion> I did.  I need to read the paper.
11:30:28 <ihope> Well, so why can't I define:
11:30:30 <ihope> data Foo a = Bar (Foo (b -> a)) (Foo b)
11:30:32 <Philippa> short version: they do what I said they do ;-) Better than views due to being more generic at no significant additional cost
11:30:48 <Trevion> My interest in views is primarily syntactic, though.
11:31:04 <Philippa> pat!expr not sufficiently sweet syntax for you?
11:31:15 <Philippa> pat!expr-that-is-effectively-a-view-name?
11:31:16 * Trevion needs to read the paper.
11:31:26 * ihope too
11:31:48 <tromp_> Arrows don't deliver as much bang for the buck as Monads do...
11:31:50 <xerox> Which paper?
11:32:03 <ihope> Well, there's both bang and buck.
11:32:22 <Philippa> case i of {2!sqrt -> -- i is 4}, pretty much
11:32:23 <ihope> The a type has neither bang nor buck, and () has buck but not bang.
11:32:34 <Philippa> buck that
11:32:52 <Philippa> tromp_: it's not just that, half the good examples are, er, also monads
11:33:40 <tromp_> indeed, there are few convincing uses of Arrows that go beyond Monads
11:33:41 <Trevion> It always seemed to me like there was a compelling reason to use the monad representation -- Moggi's original paper -- and that there was never any equivalent demonstration for arrows.
11:34:29 <Philippa> never will be, because the class of language described by an arrow is outside the common chunk of the design space
11:34:43 <Philippa> it's what happens when you want something on the 'outside' to not support higher-order computations
11:35:08 <Philippa> (in the same sense that IO is on the 'outside' of ordinary haskell)
11:38:19 <musasabi> back
11:38:49 <ihope> I want an IO monad that has a data constructor.
11:38:56 <Philippa> no you don't
11:39:06 <Philippa> you *think* you do...
11:39:10 <Taral> ihope: it does, it's called "return"
11:39:25 <Philippa> OK, OK, I want a complete implementation of one with a data constructor. But I'm not going to get it
11:39:38 <Philippa> the reason for that is I could write a function to win the lottery for me by telling me next week's numbers...
11:39:49 <ihope> Hmm?
11:40:04 <ihope> As in the halting problem?
11:40:14 <Philippa> you'd build a computation that gets you next week's lottery numbers, and then just deconstruct it from "the present"
11:40:28 <Philippa> no, as in the "reality doesn't work that way" problem
11:40:41 <ihope> It'd be tricky to pass the present as a parameter to a function.
11:40:51 <Philippa> but that's exactly how the IO monad works, semantically speaking
11:41:10 <ihope> Mmh...
11:41:11 <Philippa> it's a wrapper around a function from a universe-state to a (universe-state, result) tuple
11:41:46 <ihope> And with the data constructor monad, you could get that function?
11:42:35 <Philippa> right
11:43:09 <ihope> So you would pass it the current state of the universe, and get a future state of the universe?
11:43:13 <Philippa> bingo
11:43:21 <Philippa> note that real hardware *can't do this*
11:43:43 <Philippa> hence why we use the IO monad, and Clean uses uniqueness typing to prevent you using a given state of the universe more than once
11:43:43 <ihope> But wouldn't universe-state pretty much be the same as memory-state?
11:43:47 <Philippa> no
11:43:58 <Philippa> when you do IO, you effect things outside the computer
11:44:11 <ihope> But you do that via memory, don't you?
11:44:20 <Philippa> yes, that's relevant how?
11:44:29 <Philippa> changing back the bits doesn't undo the fact you just launched a nuke
11:44:31 <basti_> not only.
11:44:38 <ihope> ...That would make universe-state and memory-state the same.
11:44:43 <Philippa> no, it would not
11:44:47 <basti_> not only via memory.
11:44:48 <ihope> Since memory is the interface to the universe.
11:44:54 <basti_> ihope: it is not.
11:45:02 <Philippa> the universe self-effects
11:45:11 <basti_> there's assembler primitives for peripheral actions
11:45:15 <Taral> ihope: universe-state includes things beyond memory, like other computers
11:45:16 <Philippa> I can have my computer do *nothing*, and the universe's state changes
11:45:19 <ihope> Really?
11:45:22 <Philippa> yes
11:45:25 <basti_> yes.
11:45:40 <Philippa> remember, I said the semantic representation?
11:45:56 <ihope> Um...
11:46:02 <Philippa> that's "the bit that lets you treat IO as a function and thus lets you do IO in a language with no other constructs"
11:46:22 <Philippa> obviously your computer doesn't actually contain a Theory of Everything simulator
11:46:29 <MenTaLguY> hello
11:46:33 <Philippa> that's *why you can't expose that function*
11:46:40 <Philippa> and thus why the IO monad remains an abstract datatype
11:46:50 <Philippa> 'snone o' your business what's going on inside, and fundamentally so
11:46:58 <Philippa> you want to know, write your own Haskell implementation (or borrow one ;-)
11:47:07 <Philippa> your code will, of course, then be implementation-specific
11:47:12 <Philippa> 'lo MenTaLguY
11:47:27 <MenTaLguY> I've got a sort of interesting problem...
11:47:27 <PupenoT> Hello.
11:47:45 <MenTaLguY> I'm hoping there's an existing solution to this and that I'm just trying to reinvent the wheel..
11:48:11 <ihope> Haskell has many wheels of many shapes.
11:48:53 <ihope> So what's the problem?
11:49:36 <Oejet> We also do dating counseling. :)
11:49:57 <MenTaLguY> Basically I want to define a type class something like:
11:49:57 <MenTaLguY> class (Monoid a) => Thingy a b c | b c -> a where
11:49:57 <MenTaLguY>   stuff :: a -> b -> c
11:50:36 <ihope> Well, you lost me already. Good luck.
11:51:31 <Philippa> you sure you don't want an a b combination to determine a c?
11:51:43 <Philippa> (that aside, carry on)
11:52:01 <MenTaLguY> The downstream goal is to be able to wrap a type like (d -> e) and then definite appropriate instances of Monoid and Thingy for it
11:52:25 <MenTaLguY> so the type of a determines b and c, yes
11:52:51 <Philippa> you mean a -> b,c then?
11:52:59 <MenTaLguY> ah, I guess I do
11:53:18 <MenTaLguY> I've still not quite got the hang of fundeps
11:53:24 <Philippa> and, wouldn't the monoid be on (d -> d), with d -> e as your 'b' and e as your c?
11:53:50 <MenTaLguY> nope
11:54:01 <Philippa> I can't see how to define a monoid on d->e...
11:54:08 <MenTaLguY> you can't _generally_
11:54:22 <Philippa> then you can't, no?
11:54:30 <MenTaLguY> you can do it for more specific types
11:54:49 <MenTaLguY> if you've got an appropriate mappend
11:54:53 <Philippa> then don't give us an example we can't use?
11:55:16 <MenTaLguY> well, I don't want to define a monoid on d -> e
11:55:27 <MenTaLguY> but rather a type that wraps a specific d -> e
11:55:51 <Philippa> then we cease to care what's in the monoid 'til you give us grounds to, no?
11:56:06 <MenTaLguY> for example, a -> IO Bool
11:56:16 * Philippa nods
11:56:44 <Philippa> then you end up with a as Thingy's b, feed it in and go from there?
11:57:13 <MenTaLguY> eh.. sort of.  maybe I should venture a concrete examlpe
11:57:20 <Philippa> yes
11:57:32 <Philippa> your abstractions seem to be overly generic and thus missing enough info to make it work
11:58:13 <MenTaLguY> lessee, what's the pasteboard URL these days?
11:58:29 <MenTaLguY> !paste
11:58:30 <Philippa> @paste
11:58:31 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:58:40 <MenTaLguY> thanks
11:59:25 <MenTaLguY> hrm
12:00:14 <MenTaLguY> how about one that I'm allowed to edit?
12:00:36 <MenTaLguY> ah, paste.lisp.org should work
12:00:51 <MenTaLguY> except that's dead...
12:01:05 <musasabi> maybe @paste should be changed now that hawiki is registered user only?
12:02:00 <MenTaLguY> that might be wise
12:04:04 <Stinger> ghci uses readline right?
12:04:44 <musasabi> yes
12:07:05 <MenTaLguY> Philippa: here you go: http://pastebin.com/473558
12:07:24 <MenTaLguY> hopefully that actually works; I haven't tested it
12:07:49 <musasabi> SyntaxNinja: is the "setup haddock does not read buildinfo files" fixed in CVS cabal?
12:08:06 <Philippa> MenTaLguY: I get the idea, at least
12:08:08 <MenTaLguY> the other thing is I've not proven that it observes the monoid laws
12:09:14 <Philippa> once you've got the fundep the right way round that should work
12:09:24 <MenTaLguY> ok
12:10:09 <MenTaLguY> ah, yes, and I do need to unwrap the functions too
12:10:13 <MenTaLguY> in mappend
12:10:20 <MenTaLguY> but yeah, you got the idea
12:11:31 <MenTaLguY> so I should read a -> b,c as "a determines b and c" ?
12:11:42 <Philippa> IIRC, yes
12:11:48 <Philippa> certainly it's LHS determines RHS
12:12:19 <MenTaLguY> ok
12:15:54 <dsacode> Haskell is amazing language, why doesn't everyone programming it ? :-(
12:16:08 <ValarQ> dsacode: dunno, thats a mystery to me
12:16:44 <MenTaLguY> the introductory material is pretty bad for folks who aren't coming from an academic (or equivalent) background
12:16:52 <Heffalump> slow, hard to learn, not very portable
12:16:53 <dsacode> ValarQ, all other language (exclude Erlang, LISP and some others) are absolulety sucks :(
12:17:07 <dsacode> i really have fun programming Haskell, it's great pleasure for me
12:17:21 <MenTaLguY> Philippa: while I've got your ear, have you seen anything like this already existing:
12:17:23 <MenTaLguY> http://pastebin.com/473577
12:17:25 <MenTaLguY> ?
12:17:35 <sethk> dsacode, well, the purpose of a programming language is not to have fun, it is to produce programs.
12:18:12 <Lemmih> Hiya.
12:18:18 <Heffalump> MenTaLguY: I thought MonadRef was a standard class
12:18:23 <ValarQ> Lemmih: welcome
12:18:23 <Heffalump> (in the GHC libs, anyway)
12:18:43 <dsacode> sethk, i can produce program! and those programs looks simple and amazing, i can't reproduce any of my programs in imperative languages
12:18:56 <binary42> sethk: bah. all wrong. producing programs can be fun. Orthogonal to me.
12:19:06 <MenTaLguY> Heffalump: if it is that'd be great... I didn't see it browsing through the library docs
12:19:06 <dsacode> sethk, one and only one weak side is perfomance
12:19:07 <Cale> no, that's not a standard thing
12:19:18 <MenTaLguY> what do I need to import to get it?
12:19:20 <Philippa> MenTaLguY: 500 variants and no consensus
12:19:22 <Cale> though it ought to be
12:19:25 <sethk> dsacode, I use haskell quite extensively, but that's foolishness.  The set of computable programs is the same for haskell and an imperative langauge.
12:19:37 <sethk> binary42, absolutely, that's my point
12:19:45 <sethk> binary42, whether or not it is fun is completely irrelevant
12:19:57 <Philippa> sethk: that which is theoretically possible != that which a given person can do
12:20:03 <binary42> then which you be your primary axis. I program because I enjoy myself. :)
12:20:08 <MenTaLguY> I guess my other question is whether the type of newMRef is going to get me into trouble, given that m and r only appear in its result type?
12:20:34 <dsacode> sethk, i don't know, i feel disgusted when forced to program C/C++ or something similar
12:20:43 <ValarQ> is there a trick for having multiple references to something in a tree?
12:20:47 <musasabi> I think it is usually quite easy to get good performance in Haskell
12:20:51 <Cale> MenTaLguY: Consider 'return' in the Monad class :)
12:20:56 <sethk> dsacode, so?  what do your feelings have to do with anything?
12:21:01 <ValarQ> i'm having some problems implementing a quadtree in haskell
12:21:03 <sethk> musasabi, I didn't say anything about performance
12:21:18 <dsacode> sethk, nothing, sorry
12:21:43 <MenTaLguY> Cale: ok... just wondering if requiring fundeps means I have to deal with additional weirdness
12:21:50 <Philippa> sethk: I assume you've never had to cope with severe motivational problems if you say that?
12:21:51 <lennart> sethk, you can't have much of a fun life if you don't optimize for fun :)
12:21:59 <Philippa> lennart: that too :-)
12:22:05 <Cale> MenTaLguY: no, they reduce the weirdness :)
12:22:15 <Philippa> they're a weirdness resolution mechanism
12:22:28 <MenTaLguY> urgh
12:22:28 <sethk> Philippa, I've been doing this for about 35 years.  I've had to cope with anything that anyone else has had to cope with.
12:22:33 <MenTaLguY> a -> b,c gives me a parse error
12:22:35 <musasabi> fundep semantics are not yet entirely clear in corner cases, but if you are using multiparameter classes then using them should not be a problem
12:22:41 <Taral> no comma
12:22:47 <Taral> a -> b c
12:23:08 <MenTaLguY> yay, no errors
12:23:13 <MenTaLguY> thanks Philippa!
12:23:21 <MenTaLguY> and Taral!
12:23:23 <Taral> np
12:23:41 <MenTaLguY> I guess my last question is what I should call Thingy
12:23:45 <Heffalump> musasabi: how do you define 'good performance'?
12:23:56 <MenTaLguY> ComposableFunction ?
12:24:07 <dsacode> btw, can someone advice me soom good editor that supports Haskell syntax, indentation and other useful things?
12:24:14 <dsacode> s/soom/some
12:24:21 <Trevion> dsacode, try Emacs
12:24:49 <Philippa> sethk: unless you've experienced every mental disorder known to humanity, you might want to reconsider that statement
12:25:00 <dsacode> Trevion, Emacs is too big and bloated for my taste
12:25:16 <sethk> Philippa, I have.  everybody is trying to kill me, including aliens from the planet cobol
12:25:21 <Trevion> What platform are you working on?
12:25:36 <Philippa> sethk: I'm pretty sure some of them're mutually exclusive :-)
12:25:58 <Philippa> I'm serious though, there're plenty of ways someone can end up finding it all but impossible to bring themselves to do something
12:26:11 <Philippa> and those damn well do affect what they can achieve
12:26:28 <Taral> dsacode: then try vi
12:26:41 <Taral> well, some variant of vi anyway
12:26:43 <Taral> vim or yi or something
12:27:03 <musasabi> Heffalump: usually fast enough i.e. not much slower than similar purpose code in C.
12:27:26 <dsacode> argh, vi uses some weird keybindings :) i like small emacs-like editors such as joe, jed.. but there's no good support for Haskell :-(
12:27:41 <MenTaLguY> any better names than ComposableFunction ?
12:28:07 <CosmicRay> ok everyone, I'd like some help with brainstorming something.  Both Haskell and SQL are typed languages.  In my interface layer, I need to support that somehow.
12:28:13 <musasabi> of course I wouldn't use haskell for DSP, but for the purposes I am using it.
12:28:27 <CosmicRay> now, most SQL engines are not strongly typed.  That is, I can send them a string for an integer field, and as long as the string can be parsed as an integer, this works fine.
12:28:51 <Taral> CosmicRay: class SQLType a where toSQL :: a -> String
12:28:53 <CosmicRay> similarly, they can send back all results as strings and then it is my job to parse them into whatever is wanted (or to request them in that form to start with)
12:28:56 <sethk> CosmicRay, that's a requirement of the SQL standard
12:28:57 <Heffalump> CosmicRay: before you get any further, presumably HaskellDB is not the answer?
12:28:58 <CosmicRay> so I am thinking of:
12:29:07 <CosmicRay> class (read a, show a) => SqlType a where
12:29:07 <CosmicRay>     toSQL :: a -> SqlValue
12:29:07 <CosmicRay>     fromSQL :: SqlValue -> a
12:29:07 <CosmicRay> data SqlValue = SqlInt Int | SqlString String ....
12:29:08 <sethk> CosmicRay, to be compliant they have to accept strings in that situation
12:29:25 <Taral> CosmicRay: I wouldn't constrain sqltype on read/show
12:29:26 <CosmicRay> Heffalump: no, haskelldb is not the answer.  This is a replacement for HSQL, which HaskellDB depends upon
12:29:42 <tuomov> dsacode: I have a partial haskell syntax file for joe
12:29:52 <Taral> are you the one doing the new sql interface I saw on haskell@?
12:29:54 <CosmicRay> sethk: what exactly is a requirement?  That the client library has to always accept strings and provide strings?
12:29:57 <CosmicRay> Taral: yes
12:29:59 <Taral> heh
12:30:05 <sethk> CosmicRay, yes
12:30:06 <Taral> CosmicRay: What about...
12:30:21 <dsacode> tuomov, hehe, that's great! can you post it to joe-devel@ when you'll be done?
12:30:22 <sethk> CosmicRay, not just strings
12:30:33 <sethk> CosmicRay, just about any type translation that makes any sense
12:30:45 <CosmicRay> sethk: ok, so a basic interface would be what Taral suggested...  but I'd like to let people, say, pass Ints through without having to convert to/from strings first
12:30:48 <musasabi> CosmicRay: haskelldb defines those exact things.
12:30:48 <MenTaLguY> ok, dumb haskell question now
12:31:02 <MenTaLguY> do I need to do anything special to export instances of a type class I'm exporting from a module?
12:31:10 <CosmicRay> musasabi: are you sure?  because hsql does too
12:31:11 <musasabi> in addition to the fancy query stuff.
12:31:20 <tuomov> dsacode: it's still missing proper preprocessor support code, escape parsing for characters (joe's modes tend to further highlight escapes within strings), and an emacs-like at-start-of-line hack for function definition colourisation
12:31:32 * CosmicRay pulls up HaskellDB.
12:31:34 <sethk> CosmicRay, yes, you have to do that as well
12:31:38 <tuomov> dsacode: but I'll post it when it is ready
12:31:44 <musasabi> CosmicRay: I think so, but it is a few months since I last looked at the source so I may not remember correctly.
12:31:48 <musasabi> But I think so.
12:31:54 <CosmicRay> musasabi: is haskellDB's workable on a layer akin to HSQL, where we know nothing about the type of data in the DB at compile time?
12:32:10 <sethk> CosmicRay, and you have to allow (to be compliant that is) translations between binary types.  putting an integer database value into a float in a program, for example.
12:32:30 <CosmicRay> sethk: is there a place I could read about this?
12:32:44 <sethk> CosmicRay, the SQL '92 standard document
12:32:50 <musasabi> CosmicRay: HaskellDB has the typestuff and doing the conversions from the types to Strings
12:32:56 <sethk> CosmicRay, it's hundreds of pages long, unfortunately
12:33:29 <tuomov> dsacode: before implementing the character escape stuff, I'd rather wait for "joe" to do something about the parametrisation issues I mentioned on the ML, as both chars and strings need the same code
12:33:37 <musasabi> the best way to think about it is C. There are types + implicit conversions.
12:33:40 <CosmicRay> musasabi: I found http://haskelldb.sourceforge.net/api/Database.HaskellDB.FieldType.html, but it seems to be for working with names of types only, not for binding values and the like
12:33:46 <Taral> CosmicRay: If you want to be able to pass ints through, then you want:
12:34:00 <Taral> class SQLType a where
12:34:04 <Taral>     toSQL :: a -> SQLValue
12:34:08 <Taral>     fromSQL :: SQLValue -> a
12:34:11 <Taral> instance Num a => SQLType a
12:34:14 <Taral> instance Rational a => SQLType a
12:34:17 <Taral> instance SQLType String
12:34:45 <CosmicRay> Taral: that sounds pretty much like what I was thinking of
12:34:47 <musasabi> CosmicRay: look at how queries are converted and constants handled
12:34:48 <Taral> yup
12:34:58 <CosmicRay> would your SQLValue be what I was thinking of as well?
12:35:04 <CosmicRay> data SqlValue = SqlInt Int | SqlString String ....
12:35:20 <CosmicRay> and of course, a fromSQL could convert an SqlInt to a String.
12:35:28 <Taral> SQLValue would be based on what the underlying system wants, but that definition is likely.
12:36:01 <CosmicRay> Taral: I have to have one global definition because the core library and public types have to work with all databases.
12:36:22 <Taral> *nod*
12:36:29 <CosmicRay> but I figure that if I'm using something like, say, sqlite -- which doesn't have date/time types -- I can always convert to a string in a specific format
12:36:42 <musasabi> Usually the database client interface API only supports strings.
12:36:44 <bisby> Thompson in his book, has a fixity declaration for the forward composition operator, >.>, infixl 9 >.>   . Can anyone explain why forward composition should associate to the left?
12:37:26 <CosmicRay> musasabi: I'm finding that most of them are supporting other basic types as well
12:37:33 <CosmicRay> musasabi: sqlite, postgres, and unixodbc at least do
12:37:52 <CosmicRay> here I'm talking about binding values to '?' columns in queries, as well as looking at results coming back.
12:39:04 <Taral> musasabi: Most database client APIs support native types, not just strings.
12:39:04 <musasabi> CosmicRay: yes, but the C client API will only deal with string values.
12:39:18 <CosmicRay> no, I am takling about the C cilent API
12:39:19 <Taral> mysql, postgresql, sqlite, all have native type support
12:39:21 <musasabi> Taral: do they? sqlite? postgresql?
12:39:26 <CosmicRay> musasabi: yes
12:39:32 <CosmicRay> musasabi: even unixodbc
12:39:36 <musasabi> Taral: since when does postgresql have that?
12:39:36 <Taral> and native encoding for the wire protocol
12:39:40 <Taral> since ages
12:39:48 <musasabi> Taral: are you sure?
12:39:52 <sethk> it's certainly an ODBC requirement
12:40:13 * musasabi was thinking of libpq
12:40:19 <Taral> Yes.
12:40:25 <Taral> I've written enough pgsql client stuff
12:40:35 <CosmicRay> musasabi: http://www.postgresql.org/docs/8.1/static/libpq-exec.html#LIBPQ-EXEC-MAIN
12:40:41 <CosmicRay> see paramTypes
12:41:26 <CosmicRay> err, and paramFormats
12:41:58 <musasabi> hmm PQexecParams 
12:42:12 * musasabi worked with postgresql too long ago it seems
12:42:17 <musasabi> 6.x and so on
12:42:43 <Taral> gah, 6.x is oooold
12:42:47 <Taral> PQgetvalue now says:
12:43:01 <Taral> "For data in text format, bla bla bla. For data in binary format, the value is in the binary representation ..."
12:43:05 <musasabi> Taral: well it was brand new in those days
12:43:10 <CosmicRay> heh
12:43:13 <Taral> I know, I worked with 6.x too.
12:43:19 <Taral> Back in 1999.
12:46:46 <musasabi> CosmicRay: now I understand the point much better :-)
12:47:00 <CosmicRay> :-)
12:47:22 <CosmicRay> musasabi: do you agree with the idea that Taral and I both came up with? ;-)
12:55:55 <araujo> There exist a function to do this kind of mapping: map (\ a b -> a + b) [1,2,3,4] => [3,7] ? in the Prelude 
12:57:33 <tromp_> nope
12:57:51 <Heffalump> @type iterate
12:57:52 <lambdabot> forall a. (a -> a) -> a -> [a]
12:58:48 <Heffalump> > map (\[a,b] -> a+b) $ iterate (take 2) [1,2,3,4]
12:58:49 <lambdabot>  Non-exhaustive patterns in lambda
12:59:02 <Heffalump> > map (\[a,b] -> a+b) $ takeWhile (/=[]) $ iterate (take 2) [1,2,3,4]
12:59:03 <lambdabot>  Non-exhaustive patterns in lambda
12:59:21 <Heffalump> > takeWhile (/=[]) $ iterate (take 2) [1,2,3,4]
12:59:22 <lambdabot> [[1,2,3,4],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,
12:59:22 <lambdabot> 2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]
12:59:22 <lambdabot> ,[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[
12:59:22 <lambdabot> 1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,
12:59:22 <lambdabot> 2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]
12:59:24 <lambdabot> [23 @more lines]
12:59:27 <Heffalump> oops..
12:59:33 * Heffalump is clearly incompetent and should give up
12:59:54 <Cale> > takeWhile (/=[]) $ iterate (drop 2) [1,2,3,4]
12:59:55 <lambdabot> [[1,2,3,4],[3,4]]
13:00:10 <Heffalump> err, yeah, that's what I meant.
13:00:11 <Cale> > map (take 2) $ takeWhile (/=[]) $ iterate (drop 2) [1,2,3,4]
13:00:12 <lambdabot> [[1,2],[3,4]]
13:00:16 <Heffalump> I've done this before, I just thought a bit more first.
13:00:41 * Heffalump is playing with his Christmas tree.
13:01:23 <araujo> mm.. ok.. that means there is none in the Prelude :-]
13:01:30 <Cale> > map (take 2) $ takeWhile (not . null) $ iterate (drop 2) [1,2,3,4]
13:01:31 <lambdabot> [[1,2],[3,4]]
13:01:45 * araujo probably should draft a concatMap2 function too
13:02:14 <musasabi> CosmicRay: yes, it seems sensible.
13:05:32 <tromp_> how about a nice definition of evens [a,b,c,d,e,...] = [a,c,e,...]
13:06:13 <tromp_> then odds = evens.tail
13:06:51 <Stinger> goddamn ghci takes a while to compile
13:08:22 <Cale> Stinger: hacking on GHC?
13:08:31 <Cale> evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs
13:08:42 <Cale> mutual recursion works nicely enough here
13:09:01 <tromp_> evens = map snd . filter fst . zip (cycle [True,False])
13:09:02 <Stinger> no trying to fix odd readline behaviour, I dont think this recompile will do that though : /
13:09:05 <Cale> you could write those as foldrs
13:09:47 <CosmicRay> musasabi: great, thanks
13:11:09 <tromp_> where is fix defined?
13:12:02 <Cale> @index fix
13:12:03 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
13:12:03 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
13:12:03 <lambdabot> Error
13:15:28 <syntaxfree> simply put, how do I come up with a list of N random numbers?
13:16:01 <syntaxfree> I'm thinking of something like mapM (\x->do pick up randomness here) [1..n], but there's a missing piece.
13:17:36 <Lemmih> Prelude System.Random Control.Monad> print =<< replicateM 10 (randomRIO (0,9))
13:17:36 <Lemmih> [5,8,7,9,6,2,4,8,2,2]
13:19:15 <syntaxfree> what is wrong with  mapM (\k->do x<-num <- Random.randomRIO (1::Int, 100); print x;) [1..15]?
13:20:09 <Taral> nothing
13:20:12 <Lemmih> x <- num <- Random, eh?
13:20:19 <Taral> you're still better off with replicateM_
13:21:04 <syntaxfree> what's the difference between replicateM and replicateM_ ?
13:21:14 <Taral> replicateM_ doesn't gather up the results
13:21:17 <Taral> @type replicateM
13:21:18 <lambdabot> Not in scope: `replicateM'
13:21:21 <Taral> @index replicateM
13:21:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
13:21:22 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
13:21:22 <lambdabot> Control.Monad.Error, Control.Monad.List
13:21:24 <Taral> @type Control.Monad.replicateM
13:21:25 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
13:21:25 <Taral> @type Control.Monad.replicateM_
13:21:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
13:21:52 <syntaxfree> hmm. There's one aspect of the problem I overlooked.
13:22:04 <syntaxfree> What I actually need is a random _ordering_. I can't have repeated numbers :~
13:23:08 <Taral> um...
13:23:13 * Taral hunts up random permutation algorithms.
13:23:45 <Taral> the C version is something like...
13:24:09 <Taral> for (i = 0; i < n; i++) a[i] = i; for (i = 0; i < n-1; i++) swap(a[i], a[rand(i+1, n)]);
13:24:19 <Taral> oops
13:24:22 <Taral> for (i = 0; i < n; i++) a[i] = i; for (i = 0; i < n-1; i++) swap(a[i], a[rand(i, n)]);
13:24:43 <Taral> skip the init step if you want a random permutation of a given sequence
13:25:51 <syntaxfree> hmm. 
13:25:54 * syntaxfree thinks.
13:26:18 <Lor> do i <- rand (fact (length l)); return (permutations l !! i)
13:26:49 <Lor> Probably not the fastest way to do it, though. :)
13:26:51 <syntaxfree> :t permutations
13:26:53 <Taral> > splitAt 1 [1,2,3]
13:26:54 <lambdabot> ([1],[2,3])
13:27:02 <Lor> That was pseudocode.
13:27:08 <Lor> You have to define rand, fact and permutations.
13:27:14 <tromp_> map snd $ sort $ zip randomlist [1..n]
13:27:21 <Taral> @type randomlist
13:27:22 <lambdabot> Not in scope: `randomlist'
13:27:29 <Taral> @index randomlist
13:27:30 <lambdabot> bzzt
13:27:35 <syntaxfree> @hoogle randomList
13:27:36 <lambdabot> No matches found
13:27:41 <Lor> tromp, eargh, no perlisms, please
13:28:57 <Taral> shuffle :: RandomGen g => g -> [a] -> [a]
13:28:58 <Taral> shuffle g [] = []
13:28:58 <Taral> shuffle g l =
13:28:58 <Taral>     let (i, g') = randomR (0, length l - 1) g
13:28:58 <Taral>         (x, y:z) = splitAt i l
13:28:58 <Taral>     in y : shuffle g' (x:z)
13:29:18 <Taral> can be sped up by caching (length l)
13:29:31 <Lor> The compiler will do it for you.
13:29:37 <syntaxfree> clever.
13:29:39 <Taral> it will?
13:29:48 <Taral> I mean inductive caching
13:30:08 <Taral> knowing that the self-call's l is one shorter
13:30:25 <Lor> Ah, right.
13:30:37 <Taral> syntaxfree: You're better off using STArray for speed though.
13:30:47 <tromp_> question is if you can get linear time without using STArray
13:30:51 <Lor> Never mind, though, since splitAt is linear just like length is.
13:31:18 <Taral> Lor: Yup.
13:31:19 <syntaxfree> I'm trying to scramble text keeping the first and last letter of a word fixed.
13:31:32 <syntaxfree> Sinrlrsigpuy, it's slitl pttrey rdlaaebe
13:31:36 <Taral> syntaxfree: If you're expecting the text to be readable, it won't be.
13:33:37 <syntaxfree> well, therein lies the experiment.
13:34:14 * syntaxfree struggles with dvorak
13:35:06 <CosmicRay> is (fromIntegral . truncate) the canonical way to convert a Double to an Int?
13:35:08 <Taral> Look it up online.
13:35:11 <Stinger> wow that did fix it : / delete key works
13:35:12 <Taral> For example: "A dootcr has aimttded the magltheuansr of a tageene ceacnr pintaet who deid aetfr a hatospil durg blendur."
13:35:15 <Taral> is not easily read
13:35:51 <Taral> and as you split double-consonants and consonant clusters, it gets worse.
13:36:26 <syntaxfree> I can decipher most of that,
13:36:35 <Taral> With difficulty, yes.
13:36:42 <Taral> The point of the original thing is that people can read it easily.
13:36:45 <Taral> It's just not true.
13:36:51 <syntaxfree> except for magltheuansrv
13:36:56 <Taral> You have to be careful how you scramble the words if you want it easily readable.
13:37:33 <Taral> http://www.mrc-cbu.cam.ac.uk/~mattd/Cmabrigde/
13:38:07 <syntaxfree> i think it's a matter of word length.
13:38:23 <Taral> yes, and word function, and transposition distance
13:38:38 <Taral> the original word was "manslaughter"
13:39:18 <Saulzar> CosmicRay, What do you need fromIntegral for? Just truncate will do, no?
13:39:33 <CosmicRay> apparently so
13:39:40 <Taral> scrambling that as "mnsaluateghr" is easier than "magltheuansr".
13:39:41 <CosmicRay> I had just noticed that
13:40:08 <Taral> the latter splits "gh" and moves the "n" to the other end of the word, for example.
13:40:59 <syntaxfree> tht's bcs wst f th tm y cn gt wy wtht vwls.
13:41:00 <CosmicRay> hmm.
13:41:09 <CosmicRay> why is Int in Haskell have a range lower than a 32-bit integer?
13:41:18 <syntaxfree> s/wst/mst.
13:41:44 <CosmicRay> also, what is difference between Int64, Word64, and CInt64?
13:42:06 <Saulzar> CosmicRay, I think some implementations will use some bits for things like laziness, gc 
13:42:24 <Taral> Int64 signed, Word64 unsigned, CInt64 foreign
13:42:52 <Saulzar> Apparently ghc uses 32 bit ints (I've asked this around here before) it's just not required by standard
13:43:02 <CosmicRay> hmm.
13:43:12 * syntaxfree switches to a simpler project, de-vowel, and attempts it on the cmabridge text.
13:43:37 <CosmicRay> Taral: can I cleanly fromIntegral an Int32, store it in a Word32, and use it as an int in a C program expecting an int?
13:43:46 <CosmicRay> (on a 32-bit machine)
13:44:28 <bisby> I cant get this getDirectoryContentsWithParent to work
13:44:30 <bisby> getDirectoryContentsWithParent path = mapM (\d -> path ++ "/" ++ d) =<< getDirectoryContents path
13:44:54 <musasabi> CInt != Int
13:45:02 <CosmicRay> yes, I am seeing that
13:45:10 <CosmicRay> but, CInt usually == Int32, right?
13:45:16 <CosmicRay> and can be safely stored in a Word32
13:45:37 <syntaxfree> Wrnokig wtih rdnoam nuberms in Hklasel is hrad.
13:45:41 <CosmicRay> fptools docs say " For coercing between any two integer types, use fromIntegral, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign."
13:46:06 <musasabi> CInt = usually either Int32 or Int64
13:46:19 <CosmicRay> right
13:46:32 <musasabi> and there is always unsafeCoerce# 
13:46:44 <Saulzar> Hmm, I guess if you are going from haskell ints through the word types the word types will always preserve full range
13:47:50 <MarcWeber> Any ideas how to fix this ghc-pkg problem? http://www.rafb.net/paste/results/F8qvEW91.html
13:48:58 <Taral> what syntax is that?
13:49:05 <Taral> Doesn't ghc-pkg take a .conf style file?
13:49:11 <musasabi> MarcWeber: some fields have not been replaced by constants?
13:49:38 <musasabi> (also the syntax difference between 6.2 and 6.4)
13:49:46 <MarcWeber> Taral: Don't know. ghc-pkg should be invoked like this: ghc-pkg.exe -u < com.pkg
13:50:17 <Taral> http://haskell.org/ghc/docs/latest/html/users_guide/packages.html#installed-pkg-info
13:50:24 <Taral> the format is wrong
13:51:38 <Saulzar> > (2^31, 2^31 - 1) :: Int
13:51:38 <lambdabot> Couldn't match `Int' against `(a, b)'
13:51:44 <Saulzar> > (2^31, 2^31 - 1) :: (Int, Int)
13:51:45 <lambdabot> (-2147483648,2147483647)
13:53:27 <Igloo> CosmicRay: If doing what you said above is safe then the fromIntegral should be optimised out, so you might as well write typesafe code
13:54:15 <CosmicRay> Igloo: you missed the context awhile back, which is in the situation of not knowing exactly what type a C database API will be requiring
13:54:23 <CosmicRay> or what type a Haskell program will be providing
13:54:33 <CosmicRay> I think I've got the fromIntegral OK though, thanks
13:55:11 <Igloo> Why do you not know what type the C database API wants?
13:55:48 <CosmicRay> Igloo: because I am writing a generic layer that will work with multiple C APIs
13:55:53 <CosmicRay> Igloo: I'm replacing HSQL
13:56:36 * syntaxfree gives up learning dvorak for the nth time.
13:56:46 <a-zwei> I'm trying to compile GHC on Mac OS X for x86, and the porting instructions say I need the HC files from a compilation in a supported OS, so I compiled in FreeBSD, but it didn't create any *.hc files; how do I get these?
13:56:46 <Igloo> So each backend has a specific type (e.g. CInt), and you fromIntegral to that type in the middle
13:57:00 <CosmicRay> Igloo: right, that's my plan.
13:57:40 <CosmicRay> I wanted to be able to go from, say, Int, Int32, Int64, Word32, Word64 to C APIs that use int, unsigned int, long long, unsigned long long, etc,. and do the right thing in the maximum number of cases.
13:59:26 <Igloo> If you want to catch truncation you need to do some more work, incidentally
13:59:40 <Lemmih> a-zwei: Using a binary GHC is a lot easier.
13:59:53 <CosmicRay> Igloo: out of curiosity, how would one do that?
14:00:13 <CosmicRay> a-zwei: GHC is written in Haskell.
14:00:24 <CosmicRay> a-zwei: so the easiest way is to start with a ghc binary for your platform, which exist.
14:00:39 <a-zwei> yes, but I don't know of any binaries for OS X x86
14:00:42 <Igloo> The simplest way would be to convert, convert back and check for equality, I think
14:00:53 <CosmicRay> a-zwei: ah, I missed that part.
14:00:55 <CosmicRay> that may be true.
14:01:04 <CosmicRay> there is a GHC porting manuall... let me get you the URL...
14:01:11 <MarcWeber> Taral: Do you think it's correct now? http://www.rafb.net/paste/results/qQ5P1X92.html Is still get an error
14:01:20 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/building/index.html
14:01:26 <CosmicRay> a-zwei: that manual covers those questions
14:02:11 <a-zwei> that's what I've been reading
14:03:10 <Taral> MarcWeber: You still need to replace those ${...} tags, and it's "name: com", not "name : com"
14:03:12 <a-zwei> Section 10.1 seemed like the answer, but when I compiled in FreeBSD, no HC files were produced
14:03:35 <Taral> what is hs-libraries : "HScom"?
14:03:48 <robdockins> a-zwei: there is a port for GHC in darwinports.  that is the easiest way to get GHC built on OS X that In know of
14:04:09 <a-zwei> ohh, I think I found it -- in 10.2, they use the flag '-keep-hc-files'
14:04:40 <MarcWeber> Taral: Thanks a lot it was the " " before :
14:04:59 <a-zwei> I tried darwinports first, but it tries to bootstrap with a PPC binary, which doesn't seem to work
14:05:57 <bisby> how does 'return' know to which monad class it should lift it's argument to?
14:07:04 <Taral> bisby: By the magic of polymorphism
14:07:25 <Taral> (and type classes)
14:07:43 <bisby> is there a way to explicitly say that I want to lift something to let's say IO?
14:07:50 <CosmicRay> is there a way to convert a string such as "1234.567" directly to a Rational?
14:07:56 <CosmicRay> read won't accept that
14:08:39 <Taral> > read "1234.567" :: Float
14:08:41 <lambdabot> 1234.567
14:08:57 <CosmicRay> ahh, but what I should have said is a string such as "123.412341231613451234"
14:09:04 <a-zwei> ok, I'm going to boot FreeBSD and give it a shot with those flags
14:09:06 <CosmicRay> going through a float would lose precision
14:09:27 <Taral> > read "123.412341231613451234"  :: Double
14:09:28 <lambdabot> 123.41234123161345
14:09:41 <CosmicRay> ha
14:09:47 <CosmicRay> :-)
14:09:47 <Taral> what?
14:09:51 <syntaxfree> http://www.opamerica.com/product_info.php/products_id/781
14:09:53 <Taral> Oh, you want a Fractional!
14:09:54 <CosmicRay> the double will lose precision too.
14:09:57 <CosmicRay> just not as soon.
14:10:33 <Taral> > read "123.412341231613451234"  :: Ratio Integer
14:10:34 <lambdabot> Exception: Prelude.read: no parse
14:10:37 <Taral> hm
14:10:53 <CosmicRay> that wants something like "12341 % 100"
14:11:00 <CosmicRay> > read "12341 % 100" :: Rational
14:11:02 <lambdabot> 12341%100
14:11:12 <Igloo> You need to hack the string around yourself AFAIK
14:11:15 <Taral> yup
14:11:31 <CosmicRay> ok, in that case I am going to officially not care about picoseconds in clocktimes ;-)
14:11:32 <Taral> @type break
14:11:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:11:59 <Taral> use rationals unless you really need infinite precision
14:12:06 <Taral> most computers can't time to the picosecond anyway
14:12:25 <Cale> > read "61706170615806725617%500000000000000000" :: Rational
14:12:26 <lambdabot> 61706170615806725617%500000000000000000
14:12:45 <Taral> clock_t % CLOCKS_PER_SEC
14:12:59 <Cale> > fromRational (read "61706170615806725617%500000000000000000" :: Rational) :: Double
14:13:00 <lambdabot> 123.41234123161345
14:13:34 <Taral> where are you getting picosecond time values from anyway?
14:13:45 <CosmicRay> getClockTime
14:13:46 <Cale> bisby: liftIO
14:13:50 <Cale> @type liftIO
14:13:51 <lambdabot> Not in scope: `liftIO'
14:13:55 <Taral> @index getClockTime
14:13:56 <lambdabot> System.Time
14:13:59 <Cale> @type Control.Monad.Trans.liftIO
14:13:59 <lambdabot> forall (m :: * -> *) a.
14:13:59 <lambdabot> (Control.Monad.Trans.MonadIO m) =>
14:13:59 <lambdabot> IO a -> m a
14:14:21 <CosmicRay> Prelude System.Time> getClockTime >>= (\(TOD _ y) -> print y)
14:14:22 <CosmicRay> 444787000000
14:14:33 <Taral> CosmicRay: And diffClockTimes is not good enough?
14:14:35 <Cale> bisby: oh, looking at context, that's not what you want :)
14:14:42 <CosmicRay> Taral: I am converting this times to other things.
14:14:53 <Cale> bisby: in practice, what you're talking about is never an issue
14:15:07 <Cale> but you can give return an explicit type signature if you want
14:15:07 <Taral> well, I suppose you could do
14:15:22 <Cale> > (return :: a -> [a]) 5
14:15:23 <lambdabot> [5]
14:15:24 <Taral> \(TOD s p) -> s + (p % 1000000000000)
14:16:02 <Cale> bisby: does that help?
14:17:32 * palomer is starting to get excited about monads!
14:17:41 <Cale> palomer: :)
14:21:22 <bisby> Cale: yes I figured that it may never be an issue in practise.
14:22:03 <syntaxfree> mapM and replicateM sure are cool.
14:22:19 <bisby> There is a function called getDirectoryContents
14:22:19 <syntaxfree> and liftM is not bad ;-)
14:22:30 <bisby> :t getDirectoryContents
14:22:41 <Cale> @type getDirectoryContents
14:22:42 <lambdabot> Not in scope: `getDirectoryContents'
14:22:51 <bisby> @type Directory.getDirectoryContents
14:22:52 <Cale> @index getDirectoryContents
14:22:52 <lambdabot> FilePath -> IO [FilePath]
14:22:53 <lambdabot> System.Directory, Distribution.Compat.Directory
14:23:25 <bisby> I was doing my own getDirectoryContentsWithParent
14:23:52 <bisby> and the type became  [Char] -> IO [[Char]]
14:24:11 <bisby> but I guess that could be solved with a signature
14:24:35 <Cale> yeah, FilePath is just another name for String
14:25:19 <bisby> getDirectoryContentsWithParent path =  getDirectoryContents path >>= mapM(\d->return((path++"/"++d)):) 
14:25:58 <Cale> :)
14:26:01 <bisby> looking at this defintion. I'm wondering how return can now that it should lift to IO
14:26:12 <bisby> know I mean
14:26:26 <Cale> because of the type of getDirectoryContents and >>=
14:26:47 <Cale> but mostly just getDirectoryContents
14:26:54 <bisby> since @type return
14:27:01 <bisby> @type return
14:27:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
14:27:13 <Cale> @type (>>=)
14:27:13 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:27:48 <Cale> applying >>= to something of type IO [[Char]] will force the function on its right to result in something in IO
14:28:15 <bisby> what if i just write return "hello"
14:28:29 <bisby> @type (return "hello")
14:28:30 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
14:28:46 <Cale> It stays polymorphic :)
14:29:23 <Cale> You can write some pretty significant code which works over any monad.
14:30:06 <Cale> This is often a really neat technique, as then you can change the monad after the fact and get different kinds of results from the same algorithm
14:30:44 <bisby> What is the mechanism that can conclude which monad 'return' should give?
14:31:31 <Cale> Type inference
14:31:37 <bisby> aha
14:38:51 <palomer> Cale: is there a fundamental reason why we don't have function overloading in haskell?
14:39:09 <Taral> we have type classes instead
14:39:11 <tic> isn't that handled by type classes?
14:39:13 <Cale> palomer: we have typeclasses
14:39:42 <Cale> Which are a very nice way to get finely controlled overloading of functions
14:39:53 <Cale> look at Text.Printf if you think it's inflexible :)
14:40:18 <palomer> Cale: yeah, but sometimes type classes is overkill
14:40:27 <palomer> but, erm, I'm not advocating function overloading
14:41:04 <palomer> printIntOrString (x:string) => print x | (x:int) => print (IntToString x)
14:41:39 <palomer> besides, every type can only implement a typeclass once
14:42:03 <palomer> anyways, back to the point, could it make things ambiguous?
14:42:20 <basti_> palomer: ?
14:42:44 <basti_> palomer: what are you trying to do?
14:42:55 <palomer> just wondering
14:43:14 <basti_> are you searching for existential types?
14:43:24 <palomer> nope, but what are existential types exactly?
14:43:49 <lennart> palomer: in your printIntOrString example, would you expect this to be resolved at compile time or run time?
14:43:55 <basti_> it's like: "this element is one of typeclass x"
14:44:21 <palomer> lennart: compile time
14:44:44 <basti_> for example, you could make a list of things that are "showable"
14:45:32 <palomer> basti_: so show, which is a member of showable, would have type : there exists x. x -> string?
14:45:49 <basti_> uhmm.
14:45:51 <basti_> no.
14:45:51 <basti_> ;)
14:45:59 <palomer> give me a concrete example!
14:46:06 <basti_> the formulation does not employ "exists", confusingly.
14:46:18 <basti_> type test = [forall (Show a).a] would be one.
14:46:54 <palomer> you can emply exists for clarity
14:47:15 <basti_> hmm?
14:47:39 <palomer> s/employ/emply
14:47:46 <palomer> I give up
14:47:53 <basti_> what?
14:48:14 <palomer> though exists isn't employed, you can use exists in your examples
14:48:27 <basti_> you can?
14:48:54 <palomer> no, you can
14:49:15 <palomer> I give you permission
14:49:24 <basti_> you mean i should?
14:49:31 <basti_> i don't know if it's possible
14:49:43 <basti_> the example i gave was wrong anyway
14:49:47 <basti_> wait I'll give a correct one
14:49:51 <basti_> and then explain why it's forall
14:50:17 <palomer> but, erm, I thought everyone agreed that we should write exists for existential types
14:50:20 <palomer> right cale?
14:50:24 <lennart> look at http://haskell.org/hawiki/ExistentialTypes
14:50:29 <Cale> palomer: yeah
14:50:55 <palomer> Cale: where's your tutorial again?
14:51:01 <Cale> on monads?
14:51:09 <Cale> @wiki MonadsAsContainers
14:51:10 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
14:51:25 <basti_> lisppaste2: @url
14:51:26 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:51:47 <lisppaste2> basti_ pasted "existential type with confusing forall" at http://paste.lisp.org/display/14886
14:51:59 <basti_> palomer: do you know that "forall" is the dual of "exists"?
14:52:24 <basti_> instead of "forall" you can say "not exists not"
14:52:54 <palomer> basti_: I know about the logical interpretation of forall, yes
14:53:06 <Philippa> the type-level interpretation pretty much /is/ the logical interpretation
14:53:12 <Philippa> curry-howard strikes!
14:53:18 <palomer> Philippa: lies and you know it
14:53:28 <Philippa> palomer: think about it
14:53:36 <palomer> oh, I've thought about it
14:53:46 <lennart> so what's the lie?
14:54:27 <basti_> palomer: you claim, "for all a i can do x." And now i come and claim "there exists an a" and challenge you to do x
14:55:04 <palomer> the logical interpretation of formula states the following: "if a fromula is provable (habitated), it is true in all models" and "if a formula provably implies false, it is false in all models"
14:55:40 <palomer> there are many habitated types in haskell which are not true in all models
14:56:00 <palomer> heck, haskell has the fixed point operator
14:56:05 <Taral> you mean "inhabited"
14:56:28 <palomer> oh, right, translating from french
14:56:29 <Philippa> are you familiar with the value known variously as "bottom", "_|_", "error" etc etc?
14:56:36 <basti_> yea
14:56:42 <basti_> ^^
14:56:50 <palomer> Philippa: I do
14:56:51 <lennart> yes, if you get picky it's a bit of a lie.  but ignoring bottom gives insight in this case
14:57:11 <Philippa> unsafePerformIO and the like is a lie, yes
14:57:22 <palomer> anyways, the connection between haskell types and formula is practically non existent
14:57:26 <Philippa> it's *not* the case of systems like System F
14:57:28 <basti_> its not?
14:57:46 <palomer> System F is very much different
14:57:55 <palomer> and even then, models of system F are not intuitive
14:58:00 <palomer> and you can't do much in system F
14:58:02 <basti_> i often formulate types like trade transactions
14:58:04 <lennart> palomer> the connection between Haskell types and formulas is very tight
14:58:05 <Philippa> "not set-theoretical", you mean? :-)
14:58:19 <MarcWeber> Anyone in here having managed to install hdirect on windows with SUPPORT_TYPELIBS=YES ?
14:58:19 <Philippa> System F + recursion still works, you just get bottom again
14:58:28 <palomer> lennart: give me one statement which is true for both haskell types and formulae
14:58:34 <Philippa> and System F + recursion is GHC's core language, essentially
14:58:45 <Philippa> define "formulae" here, first. Formulae in what?
14:58:55 <lennart> as I said, you need to ignore bottom.  All Haskell types are inhabited.
14:59:11 <lennart> but that doesn't mean there isn't a strong connection.
14:59:15 <palomer> Philippa: Second order logic with 0-ary predicates
14:59:19 <palomer> Philippa: ie system F
14:59:53 <lennart> if you take a Haskell type and view it as a formula and prove it in constructive logic you know that a non-bottom Haskell program of that type exists
15:00:14 <palomer> lennart: that's pretty much the extent of the connection right there
15:00:45 <palomer> besides, most haskell types aren't even valid System F formulae
15:00:47 <Philippa> you can go a bit further and do the BHK thing, no?
15:00:55 <palomer> BHK?
15:01:01 <lennart> and if you can write a total function of a Haskell type you know that the formula is constructively true
15:01:14 <Philippa> no, but there's a translation from Haskell with type classes into System F
15:02:24 <palomer> lennart: are you sure about that one?
15:02:40 <palomer> lennart: \x -> x + 1
15:02:57 <lennart> Yes, it provs Int->Int
15:03:17 <lennart> Not an interesting logical statement
15:04:13 <lennart> most haskell types are uninteresting formulae
15:04:28 <palomer> \x -> x > 0
15:04:40 <palomer> Int -> Bolo is not constructively true
15:04:48 <Lor> Yes it is.
15:05:02 <lennart> what is Int? what is Bool?
15:05:10 <palomer> lennart: predicates
15:05:18 <lennart> not in my world
15:05:19 <palomer> Lor: show me the proof
15:05:33 <Lor> palomer, you showed it yourself.
15:05:40 <palomer> ok, in system F Int is usually forall X. (X -> (X->X) ->X)
15:05:42 <Lor> "If there is an Int, there is a Bool"
15:06:01 <lennart> Bool is a () + ()
15:06:14 <lennart> for instance
15:06:28 <palomer> and Bool is forall X.(X->X->X)
15:06:43 <palomer> oh, crap, bool is provable
15:06:46 <Lor> :)
15:06:54 <lennart> or we we can take System F, where, say, Nat->Bool is true
15:06:56 <palomer> fine fine, Int -> Bool is provable
15:07:07 <palomer> anything -> Bool is provable
15:07:16 <basti_> are you sure you're talking about programming? ^^
15:07:16 <lennart> yes
15:07:18 <Philippa> that's a tad unfortunate, yes
15:07:37 <basti_> \ _ -> False
15:07:40 <Philippa> there's a reason /useful/ proofs tend to require something akin to dependant types
15:08:02 <palomer> bah, I'm still sure that total functions don't have constructively provable types
15:08:22 <basti_> ?
15:08:28 <palomer> necessarily
15:08:37 <basti_> like in coq you say
15:09:23 <palomer> Cale: what's your take on this?
15:09:27 <basti_> where you prove functions by constructing them
15:10:42 <palomer> isn't there a total function of type  ((A->B)->A)->A?
15:10:43 <Lor> ..._without_ using general recursion.
15:11:05 <basti_> yea without that.
15:11:09 <palomer> Lor: is that an extra condition to my statement?
15:11:20 <Lor> No, to basti's.
15:11:43 <basti_> but still, thats a lot
15:11:51 <Philippa> palomer: think about it. The "middle" function hasn't got an a, but it's expected to return one
15:11:59 <Philippa> assuming A and B to be type variables here
15:12:29 <palomer> fine, I'll take your word for it
15:13:06 <Lor> palomer, that's a call/cc axiom.
15:13:09 <palomer> the lambda terms typed by System F are all those which have a normal form
15:13:24 <palomer> that's it.
15:15:15 <palomer> ok, this is total: \x -> if (1>2) then loop to infinity else x+1
15:15:22 <palomer> yet it does not have a normal form
15:15:29 <palomer> thus it isn't typeable in system F
15:15:59 * palomer does a little dance
15:21:13 <dany2k> > :t chr
15:21:14 <lambdabot>  parse error on input `:'
15:21:33 <dany2k> @t chr
15:21:34 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
15:21:34 <lambdabot> null topic-snoc topic-tail topic-tell type .
15:21:40 <basti_> @type chr
15:21:41 <lambdabot> Not in scope: `chr'
15:21:46 <basti_> @type Data.Char.chr
15:21:47 <lambdabot> Int -> Char
15:21:51 <basti_> @index chr
15:21:52 <lambdabot> Data.Char
15:21:53 <basti_> etc.
15:22:11 <dany2k> thx.
15:22:17 <dany2k> >  map chr [103,111,111,100,32,110,105,116,101]
15:22:18 <lambdabot> "good nite"
15:22:25 <basti_> :D
15:22:36 <basti_> and now you do rot13
15:22:53 <palomer> map and join should be the monad primitives!
15:23:00 <dany2k> ;-)
15:24:30 <jimapple> @seen lennart
15:24:31 <lambdabot> lennart is in #haskell. Last spoke 17 minutes and 14 seconds ago.
15:30:48 <Cale> palomer: sorry, was eating
15:30:55 <Cale> palomer: my take on what exactly?
15:31:11 <Cale> the Curry-Howard isomorphism?
15:32:36 <Lemmih> @seen jlouis 
15:32:37 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
15:32:37 <lambdabot> spoke.
15:32:40 <Cale> I agree that map, return and join really ought to be the primitives
15:36:28 <Comrade_Vladimi1> sethk  u here?
15:37:30 <palomer> Cale: total functions have constructively provable types
15:37:39 <palomer> Cale: (according to everyone in this channel)
15:38:07 <Cale> yes, that's true
15:38:19 <sethk> Comrade_Vladimi1, I have to go for a bit.  I'll check with you in a while.  (sorry)
15:38:23 <palomer> ok, this is total: \x -> if (1>2) then loop to infinity else x+1 <--this is total
15:38:47 <palomer> oh wait, it does have a constructive proof
15:39:02 <Cale> Integer -> Integer ?
15:39:19 <Cale> but I'm not sure that's "total"
15:39:47 <Cale> returning bottom doesn't quite count :)
15:40:22 <Cale> otherwise, any type is provable
15:40:28 <Cale> @type undefined
15:40:28 <lambdabot> forall a. a
15:40:53 <Cale> So you have to be able to guarantee termination
15:40:55 <palomer> so any total function which doesn't return bottom is provable
15:41:03 <Cale> I think that
15:41:10 <Cale> I think that's the sense of "total" here
15:41:17 <palomer> I know that any normalizable term has a constructive proof
15:41:27 <Cale> i.e. a function is total iff it always terminates
15:41:28 <palomer> set of proofs = normalizable terms
15:41:35 <palomer> normalizable != total
15:42:08 <palomer> Cale: I understand the tutoral, but I still don't see the point of monadic IO
15:42:14 <palomer> (versus CPS IO)
15:42:29 <Cale> did you see the other IntroductionToIO page I wrote?
15:42:37 <palomer> nope
15:42:41 <Cale> @wiki IntroductionToIO
15:42:42 <lambdabot> http://www.haskell.org/hawiki/IntroductionToIO
15:44:16 <palomer> oh, I think I see the point of monads
15:44:18 <Cale> that's a really brief intro
15:44:33 <palomer> monads exist because we don't know the order of execution, is this correct?
15:44:38 <Cale> basically, the reason why we use monads to describe IO is because we can
15:44:48 <Cale> otherwise we'd just use some combinator library
15:44:59 <Cale> we don't know the order of evaluation
15:45:20 <Cale> and evaluation in Haskell doesn't have side effects
15:45:28 <mjl69> I am finding so far that any holes in my understanding of monads is coming from my incomplete understanding of classes, types, constructors, pattern matching etc... in my rush to jump ahead and learn it all right away.  Little by little, it's all starting to make some sense. 
15:45:53 <Cale> only execution of IO actions has side effects, but evaluation can't cause this execution to occur
15:46:01 <Cale> (without massive cheating)
15:46:02 <palomer> Cale: printing to the screen is a side effect, no?
15:46:05 <Cale> yes
15:46:10 <mjl69> It's all about the mind body connection and Main is the pineal gland.  That's what I get so far.
15:46:20 <mjl69> or is the monad the pineal gland...
15:46:23 <palomer> Cale: but you just said that evaluation doesn't have side effects!
15:46:29 <Cale> printing to the screen is an example of something which never occurs during evaluation
15:46:51 <mjl69> thinking about it is ok.  doing it is a side effect.
15:46:52 <xs__> but without it, would evaluation ever occur?
15:47:01 <mjl69> only Main can do stuff.
15:47:03 <Cale> It only occurs as the result of executing an IO action. The only thing which executes an IO action is the runtime system.
15:47:28 <Cale> which you can't get at, except by providing an IO action called main
15:47:43 <palomer> Cale: and it does it when you evaluate putStrln "hello"
15:47:49 <Cale> no
15:48:00 <Cale> evaluating putStrLn "hello" doesn't print "hello"
15:48:02 <palomer> evaluating main prints something to your screen!
15:48:07 <Cale> executing it does
15:48:11 <Cale> no
15:48:12 <palomer> difference?
15:48:28 <Cale> The difference is that evaluation can't cause execution.
15:48:39 <Cale> Only the other way around :)
15:48:52 <cpatrick> palomer: evaluating main is returns an action (an IO ()) that _if it was executed_ would make your program run
15:48:58 <Cale> It's like there are two Haskell machines going on.
15:49:06 <Cale> There's an evaluation machine, and an execution machine.
15:49:06 <palomer> cpatrick: ah hah!
15:49:11 <palomer> why didn't you guys say so earlier
15:49:17 <palomer> so haskell takes IO () and executes it
15:49:22 <Cale> that's what I've been trying to say :)
15:49:23 <mjl69> and the monad is the tray on the conveyor belt that brings it all together...
15:49:25 <Cale> hehe
15:49:55 <Cale> mjl69: well, the monad is more the kind of trays :)
15:49:57 <palomer> so execute:: (Monad m) => m () -> () ?
15:50:06 <Cale> yeah, notionally
15:50:15 <Cale> well
15:50:19 <Cale> IO () -> ()
15:50:20 <mjl69> yeah, that's it.  I love reading all of the different analogies.
15:50:26 <palomer> gotcha
15:50:42 <Cale> For arbitrary monads, you need different methods
15:50:48 <Saulzar> Hmm, when I read that conveyor belt/tray analogy it made no sense to me
15:50:55 <palomer> how does the IO datatype look like?
15:50:56 <cpatrick> there's a function unsafePerofrmIO http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html#v%3AunsafePerformIO
15:51:01 <Cale> Saulzar: how about the container analogy?
15:51:02 <cpatrick> that does exactly that, IO a -> a
15:51:12 <Saulzar> Cale, That helped a lot :)
15:51:16 <cpatrick> palomer: AFAIK it just gets optimised out by the compiler in practice
15:51:23 <Cale> but unsafePerformIO is an example of massive cheating :)
15:51:31 <cpatrick> true true
15:51:54 <Cale> anyway, I should run :)
15:51:57 <palomer> cya!
15:52:27 <mjl69> The only thing about calling something a container is that from a C++/Java background, you think of a container as being a structure that allocates/deallocates physical memory for various methods of storage.
15:52:30 <palomer> so IO () has constructors putStrln and getLine, etc... ?
15:52:44 <palomer> man, this makes so much sense now
15:53:19 <palomer> IO must be a massive datatype
15:53:29 <palomer> since it needs to take care of ALL IO
15:53:40 <Saulzar> They're not constructors as such, but constructors are just Something -> IO x anyway
15:53:48 <palomer> they're not?
15:54:04 <Saulzar> No, they're functions returning an IO action
15:54:23 <palomer> ok
15:54:28 <palomer> so they're constructors you can't match against
15:54:31 <palomer> >:O
15:54:33 <palomer> ie functions
15:55:09 <snk_kid_lambda^> you notice there is some kind of correlation between type classes and C++ *Concepts* and in contrast with dynamic typed languages with duck typing. Whats funny is in the next standard revision of C++ Concepts will become first-class entities (for the sake of Concept Checking and better error messages).
15:55:15 <Cale> It's best to just think of them as abstract :)
15:55:17 <palomer> > let data int = z | s int
15:55:18 <lambdabot>  parse error on input `data'
15:55:26 <Cale> hehe, just wanted to make one more comment
15:55:58 <palomer> > data int = z | s int
15:55:58 <lambdabot>  parse error on input `data'
15:56:18 <Cale> The only time it's safe to use unsafePerformIO is when you don't mind if your IO gets run arbitrarily many times, or never at all
15:56:39 <Saulzar> snk_kid_lambda^, There's only so many 5 page error messages one can take :)
15:56:41 <Cale> and at any time in the running of your program
15:56:45 <palomer> Cale: that's nuts!
15:56:57 <Cale> and you don't mind if compiler optimisations affect this
15:57:04 <palomer> so unsafePerformIO is useless
15:57:07 <Cale> so basically, it's marked unsafe for a reason
15:57:24 <snk_kid_lambda^> Saulzar: give it another 20 years then you'll have better, shorter ones ;)
15:57:36 <palomer> man, I so much better understand haskell IO
15:57:40 <Cale> it's only safe for converting pure IO things (like functions from C which are really pure) into pure things
15:58:15 <palomer> is there a paper or article about how to write an intepreter in haskell?
15:58:32 <Saulzar> snk_kid_lambda^, and hopefully by that stage it will be re-written from scratch and simplified :)
15:59:38 <Cale> a monadic interpreter?
15:59:40 <snk_kid_lambda^> Saulzar: if there gonna go that far and reinvent type classes mayaswell have the whole sink ;)
16:00:00 <Cale> I think some of the original motivating papers for monads by Wadler had monadic interpreters in them
16:00:13 <Cale> anyway, I'm really off this time :)
16:00:16 <palomer> cya
16:00:19 <Cale> later
16:01:05 <samx> Anyone have examples on how to add debugging code (e.g. printouts?) to your Haskell code in a clean way. I know of Trace.debug, but it seems to break purity, so I'm left wondering, if Haskell is really a strong/expressive enough to be able to do this in a nice clean way
16:02:04 <Saulzar> writer Monad ?
16:02:25 <Cale> heh, maybe not quite yet
16:02:30 <palomer> yay for cale!
16:02:43 <SyntaxNinja> samx: printout style debugging is pretty much fundamentally no-fun in haskell.
16:02:49 <palomer> comonads look evil
16:02:58 <palomer> how does one determine if a function is infix or not?
16:02:59 <SyntaxNinja> samx: I decided that the "pure" debugging is writing lots of unit test cases.
16:03:03 <Cale> the guy who was giving me a ride to this party isn't ready to go yet
16:03:10 <palomer> or, rather, if a function name is infix or not
16:03:24 <Cale> palomer: a function is infix if it contains symbol characters
16:03:43 <palomer> oh, that's easy
16:03:48 <Cale> well, any function can be made infix with backticks
16:03:57 <Cale> > 12 `mod` 7
16:03:59 <lambdabot> 5
16:04:04 <Cale> > mod 12 7
16:04:05 <lambdabot> 5
16:04:08 <palomer> why do people find monads hard?
16:04:20 <Cale> palomer: because many people explain them poorly
16:04:22 <samx> syntaxninja, doesn't that get complicated quickly, if you are doing real world programs, with lots of monadic information hiding?
16:05:00 <lennart> palomer: just to get back to the earlier discussion.  depending on your point of view there could be total functions in Haskell that do not show that the corresponding formula is true constructively.  if your proof of totality of the Haskell function can only be made using classical logic then the correspondance fails.  but i claim these are very rare.
16:05:12 <Cale> palomer: they were much less well understood even a couple years ago
16:05:23 <palomer> what's the most newbie friendly parsing library?
16:05:33 <lennart> but then if you're a constructivist you'd never make such a proof. :)
16:05:34 <Cale> Parsec
16:05:49 <palomer> lennart: ah hah! so I was right
16:05:51 <tic> meep.
16:05:55 <palomer> parsec is newbie friendly?
16:06:00 <Cale> I think so :)
16:06:07 <palomer> pfft
16:06:14 <palomer> I've never written a complete haskell program
16:06:31 <Cale> okay, so maybe try writing some small programs before diving into parsec
16:06:37 <monochrom> You need some comfortability with monads.
16:06:43 <palomer> hullo monochrom 
16:06:51 <lennart> palomer: yes, but exhibiting a total function of that kind isn't easy
16:06:54 <Cale> I wasn't comfortable with monads until I tried Parsec :)
16:06:56 <tuomov> nah, parsec is quite easy
16:07:01 <monochrom> Ha!
16:07:26 <monochrom> My statement does not yet contradict those of Cale and tuomov :)
16:07:32 <Cale> :)
16:08:06 <Cale> palomer: you should probably play with IO and pure functions a while
16:08:16 <Cale> and maybe some other basic monads
16:08:33 <Cale> the list monad being a fairly important example
16:08:50 <Cale> but Parsec has really good documentation
16:08:52 <tuomov> parsec's like regular expressions.. just much better
16:08:57 <monochrom> The ReadS approach may be more transparent. You need only think in terms of lists and nondeterminism.
16:09:00 <lennart> but the list monad is one of the weirder ones :)
16:09:05 <tuomov> if you know regular expressions, you know how to write parsec
16:09:21 <tuomov> just check the manual for all the functions and a basic example to get started
16:09:27 <Cale> lennart: I consider the list monad to be quite possibly the most straightforward monad :)
16:09:47 <Cale> Probably the best example
16:10:19 <Saulzar> Maybe, too
16:10:27 <Cale> Maybe is also a really good one
16:10:41 <Cale> Maybe is a submonad of list :)
16:10:42 <lennart> I think Maybe is the easiest one
16:10:45 <Cale> hehe
16:10:55 <monochrom> But I still recommend investing in monads, whether you think it's the most natural thing (category theory pun) or the weirdest thing in the world.  The do-notation will pay off, as many things can be made monads, and then you enjoy the syntactic sugar.
16:11:21 <Cale> and the semantic sugar of the monad library :)
16:11:24 <tuomov> just do it!
16:11:46 <Saulzar> Maybe, List and State and IO  I have found all useful in tiny places without specifically trying
16:11:49 <monochrom> Tactical theorem provers (or really checkers) are best expressed in the do-notation.
16:12:01 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html -- parsec documentation, but note that in GHC, it's been moved to Text.ParserCombinators.Parsec
16:12:58 <Cale> monochrom: yeah, I often write simple solvers for puzzles which use the list monad for backtracking
16:13:01 <Saulzar> Ok so IO in not-so-tiny places :)
16:13:08 <Cale> Saulzar: :)
16:13:21 <palomer> oh my god
16:13:25 <palomer> I wrote my first haskell program
16:13:26 <palomer> booya
16:13:28 * palomer hugs cale
16:13:29 <Cale> :)
16:13:32 <monochrom> I wrote a boring propositional tactical proof checker to demonstrate writing and benefitting from monads. http://www.cs.toronto.edu/~trebla/fp/prover/index.html
16:13:37 <Cale> what did you write?
16:13:43 <palomer> a game
16:13:47 <palomer> it loops until I type 5
16:13:50 <Cale> cool :)
16:13:57 <palomer> :o!
16:14:02 <palomer> ok, time to write an interpreter
16:14:06 <palomer> how do I find library functions
16:14:17 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
16:14:18 <palomer> for example, I need to know how to manipulate strings effectively
16:14:21 <lennart> I wish there was a Control.Monad.BFS.  Maybe I should contribute one.
16:14:26 <Cale> ah, you'll want Data.List
16:14:32 <palomer> Cale: why?
16:14:39 <Cale> String = [Char]
16:14:51 <palomer> oh, righto
16:15:00 <palomer> so List is part of the Data module?
16:15:10 <palomer> btw, how do I use :t for things inside modules?
16:15:17 <monochrom> Forward constraint propagation for constraint-satisfaction problems.  Here I use the do-notation over lists (nondet and bt).  http://www.cs.toronto.edu/~trebla/ForwardSearch.lhs
16:15:18 <Cale> well, there's a whole bunch of stuff in the Prelude
16:15:24 <palomer> <interactive>:1:0: Not in scope: data constructor `Data.List'
16:15:31 <Cale> Data.List is a module
16:15:44 <Cale> :m + Data.List  in ghci will load it
16:16:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
16:16:48 <monochrom> Perhaps I should update my proof checker to use parsec for parsing. (It was using ParseLib)
16:16:53 <Cale> a lot of the things in Data.List are already in the Prelude
16:17:07 <Cale> (the Prelude reexports them)
16:17:49 <palomer> why does haskell use == for equality?
16:17:49 <monochrom> http://www.cs.toronto.edu/~trebla/calculator.lhs  has some ordinary math functions, if you are that newbie to haskell.
16:18:01 <Cale> palomer: what should it use? :)
16:18:04 <palomer> =
16:18:11 <monochrom> Because it was an odd day of the month when the choice was made.
16:18:28 <Cale> well, equality testing and declaration binding are different
16:18:48 <Cale> @type (==)
16:18:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:19:00 <palomer> Cale: but it's never ambiguous, is it?
16:19:02 <Cale> whereas = isn't even a function, but part of the syntax
16:19:05 <Cale> hmm...
16:19:09 <Cale> It can be :)
16:19:13 <palomer> for example?
16:19:14 <monochrom> I think it has to do with the guard notation.  f x | x==0 = 0
16:19:28 <palomer> oh, that explains it
16:19:42 <Cale> (x:xs) == (y:ys) = x == y && xs == ys
16:19:54 <lennart> x = y = z
16:20:14 <lennart> is that x == y = z  or  x = y == z ?
16:20:27 <palomer> parsec comes with ghc now?
16:20:32 <Cale> palomer: yep :)
16:20:32 <monochrom> YES!
16:20:35 <palomer> lennart: or x==y==z?
16:21:10 <lennart> yes, if in an expression
16:21:26 <monochrom> import Text.ParserCombinators.Parsec
16:22:04 <SyntaxNinja> audreyt: no longer Autrijus?
16:22:09 <palomer> is it possible to get emacs to compile and run programs?
16:22:17 <palomer> (with ghc)
16:22:19 <audreyt> SyntaxNinja: aye, see wikipedia
16:22:25 <SyntaxNinja> audreyt: link?
16:22:31 <SyntaxNinja> audreyt: you didn't edit your OWN entry did you? ;)
16:22:36 <audreyt> http://en.wikipedia.org/wiki/Audrey_Tang
16:22:44 <audreyt> as a fact I did a page move :)
16:23:10 <audreyt> (most of the contents are added by other people)
16:23:25 <palomer> monad2.o: In function `__stginit_Main_': : undefined reference to `__stginit_TextziParserCombinatorsziParsec_'
16:23:37 <Cale> palomer: maybe, but I never used that feature if it was there -- I usually just load my program in ghci in a separate terminal, and hit :r  to reload the file when I save it
16:23:46 <Igloo> palomer: -package parsec
16:23:47 <SyntaxNinja> audreyt: it doesn't say why you changed it
16:23:59 <Cale> palomer: or just compile with --make
16:24:06 <palomer> Cale: :r ?
16:24:15 <Cale> :r reloads the source file
16:24:17 <Cale> in ghci
16:24:35 <monochrom> http://www.haskell.org/libraries/#emacs  may be of use
16:24:37 <palomer> how do I set the source file?
16:24:39 <audreyt> SyntaxNinja: mm, the history and category indicates I'm transgendered (and is going on with transexual process)
16:24:52 <Cale> palomer: pass it as a parameter on the commandline, or use :load
16:25:15 <Cale> :?  for help on commands
16:25:51 <Cale> :h and :help also work to get help :)
16:25:55 <palomer> cool
16:25:58 <palomer> thx
16:26:28 <SyntaxNinja> audreyt: I see.  didn't notice the pronouns when I was reading.
16:26:45 <palomer> how do I get out my main in ghci?
16:26:59 <Lor> get out?
16:27:08 <palomer> oh, nevermind
16:27:12 <palomer> I thought it was running my main
16:27:18 <palomer> so ghci knows to execute my main?
16:28:11 <Lor> Well, if you say "main" to it...
16:30:06 <palomer> gotcha
16:32:41 <Cale> ghci will run an IO action if you give it one. Otherwise, if the value you give it is of a type which is in the class Show, it will 'print' the value, and if neither of those is true, it will give you an error complaining that it doesn't know how to show whatever you typed.
16:32:45 <Cale> @type print
16:32:46 <lambdabot> forall a. (Show a) => a -> IO ()
16:36:00 <palomer> parsec reminds me of http://pdos.csail.mit.edu/~baford/packrat/
16:37:07 <palomer> well, the | in expression grammar resembles the <|> in Parsec
16:37:25 <Cale> yeah, that's intentional :)
16:37:54 <Cale> also, http://pdos.csail.mit.edu/~baford/packrat/icfp02/Parse.hs has Parsec-inspired structure
16:38:12 <palomer> so parsec is an expression grammar parser?
16:39:00 <Cale> Parsec is a parser combinator library. The algorithms it uses are LL(k)
16:39:17 <palomer> even if <|> is deterministic?
16:39:37 <Cale> well, LL(infinity), really
16:40:07 <Cale> It has explicit nondeterminism.
16:40:30 <Cale> @type Text.ParserCombinators.Parsec.try
16:40:31 <lambdabot> forall a st tok.
16:40:31 <lambdabot> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:40:31 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:40:32 <lennart> Personally, I prefer Koen Claessens Parsek.  It has a commutative choice operator. :)
16:40:48 <Cale> GenParser tok st is a monad
16:41:18 <musasabi> mmh yet another parser
16:41:41 <musasabi> Someone should write a wikipage describing all the haskell parser combinator libraries and generators.
16:42:18 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html -- ReadP is also nice
16:42:22 <palomer> is there a parser generator that takes an EBNF and generates a function which takes a string and returns a tree representing the parsed input?
16:42:31 <Cale> that might be the same as Parsek
16:42:41 <Cale> palomer: Happy does that
16:43:04 <Cale> palomer: but most people do parsers with monadic parser libraries in Haskell
16:43:25 <lennart> Parsek is compatible with Parsec, but uses the same technique as ReadP
16:43:32 <palomer> why would one do such a thing when EBNFs were designed for exactly this purpose?
16:43:32 <Cale> lennart: ah
16:44:06 <Cale> palomer: it's handy to be able to write your parser conveniently in the same language as the rest of your program
16:44:10 <lennart> palomer: EBNF has no abstraction facilities
16:44:21 <Cale> you also get the advantage that parsers are first class values
16:44:32 <musasabi> So we have Happy, Packrat, Frown and for the libraries Parsec, ReadP, Parsek, PArrows ?
16:44:33 <Cale> you can stick a bunch of parsers in a list, and map functions over them
16:44:38 <palomer> Happy looks like fun
16:44:59 <Cale> (or fold them into one parser)
16:45:20 <Cale> You can also build parsers from input at runtime
16:45:33 <lennart> I really miss being able to define functions operating on parsers in Happy.
16:45:45 <tuomov> Happy was a preprocessor right?
16:45:57 <tuomov> I prefer not using a preprocessor..
16:46:39 <palomer> man, happy makes you write your lexer?
16:46:41 <palomer> pfft
16:46:47 <Cale> Parsek is really nice. It should get added to the Hierarchy
16:47:07 <palomer> is it possible to tell happy to write its own lexer?
16:47:43 <musasabi> there is Alex
16:48:57 <Cale> But seriously, try Parsec or one of the other combinator libraries -- I suspect you'll be impressed :)
16:49:24 <musasabi> parsec is quite good for most purposes
16:49:40 <palomer> Cale: parsec seems harder to read without any real advantage
16:49:43 <musasabi> Cale: do you think a parse{c,k} optimized could be written with TH?
16:49:50 <Cale> Parsec probably has the best documentation, but all the other parser combinator libraries look at least a little like it (with the possible exception of PArrows)
16:50:17 <Cale> palomer: there are real advantages, and it's not really any harder to read
16:50:35 <lennart> palomer: I think Parsec is easier than Happy.  You don't have to learn a new language.
16:50:45 <musasabi> PArrows is good if you want to tinker with arrows and parsers, but not if you just want to have simple working parser.
16:50:53 <palomer> you can't even write sillyProduction = "(a)" <|> "(b)" !
16:50:58 <palomer> this is the kind of stuff I take for granted
16:51:06 <palomer> (well, atleast, it doesn't do what I'd expect)
16:51:13 <Cale> string "(a)" <|> string "(b)"
16:51:20 <Cale> well
16:51:34 <Cale> with parsec, you'll run into an ambiguity problem there
16:51:43 <Cale> parsek wouldn't have any trouble
16:51:57 <musasabi> How is parsek performance?
16:52:05 <palomer> would it be able to parse "(b)" ?
16:52:12 <Cale> says that it's close to parsec's
16:52:20 <musasabi> palomer: yes.
16:52:25 <musasabi> (if it is like ReadP)
16:52:33 <Cale> palomer: parsek would, with parsec, you'd need "try"
16:52:36 <Cale> later
16:52:40 <Cale> gotta go :)
16:52:42 <palomer> so parsek > parsec ?
16:53:04 <lennart> The only big disadvantage with all(?) combinator libraries is the lack of left recursive grammars.  Or has someone fixed that now?
16:53:21 <audreyt> what's this parsek thing?
16:53:56 <audreyt> lennart: yes, just use the "chainl" combinator in parsec
16:54:03 <musasabi> http://www.cs.chalmers.se/ComputingScience/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../koen/Parsek.hs
16:54:28 <lennart> audreyt: that's not a solution, that's a workaround :)
16:54:44 <audreyt> *shrug* to this coding monkey they look the same
16:55:00 * palomer bites the bullet and uses happy
16:55:01 <palomer> ugh.
16:55:03 <lennart> but if you use left recursion by mistake you're in trouble
16:55:46 <audreyt> parsek = try by default and can't commit?
17:00:26 <palomer> the parens example on the parsec page is, erm, wrong
17:00:35 <palomer> run parens "(()()))" doesn't fail
17:02:05 <UncleD> http://www.isi.edu/~hdaume/htut/ linked to on the main haskell learning page has a "code examples link" which is 404.
17:03:47 <jimapple> That these are bad hits makes me sad
17:03:47 <jimapple> @google haskell faq
17:03:47 <jimapple> @google haskell evangelism
17:03:48 <lambdabot> http://www.haskell.org/ghc/documentation.html
17:03:49 <lambdabot> http://www.zoominfo.com/Directory/default.asp?page_id=3756
17:05:09 <palomer> does parsec have regexps?
17:05:10 <Pupeno> Hello.
17:05:45 <lennart> jimapple: I see that you've been using djinn :)
17:06:18 <jimapple> lennart: it's great for exploring
17:06:45 <jimapple> I'd like to put in a bunch of types involving negation and see which imply which
17:06:45 <lennart> yeah, more useful as a theorm prover than as a code generator
17:07:30 <jimapple> It helps me think the CH iso
17:07:31 <palomer> how would I parse an identifier in parsec?
17:08:32 <jimapple> Has anyone explored oleg's inverse type-checker yet?
17:08:43 <jimapple> (to see how it compares to djinn)
17:09:13 <jimapple> I'd like to manipulate my djinn results when I get them back
17:09:27 <lennart> you mean oleg's scheme program?
17:09:40 <jimapple> no, the one here (goes to find it)
17:10:19 <jimapple> http://www.haskell.org/pipermail/haskell/2005-March/015423.html
17:11:15 <lennart> ah, the one coded using Haskell type classes as Prolog :)
17:11:55 <jimapple> I swear, one of these days I'm going to switch to Chameleon
17:12:17 <lennart> It only gives you one possible answer, as far as I know.  And I suspect it's slow.  But otherwise I think the power is equivalent.
17:12:58 <syntaxfree> is there a cannonical way to abstract away a recursion like findMinAux pred c = if pred c then c else findMinAux (c+1); findMin = findMinAux 0?
17:13:20 <syntaxfree> well, reverse the order of arguments @ findMinAux.
17:13:36 <lennart> while?
17:13:44 <jimapple> @type while
17:13:45 <lambdabot> Not in scope: `while'
17:13:58 <lennart> @type until
17:13:59 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:14:33 <syntaxfree> I can't use that!
17:14:35 <lennart> i guess it's called until
17:14:44 <syntaxfree> I was hoping for (a->Bool)->a->a
17:14:46 <syntaxfree> @type until
17:14:47 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:15:05 <lennart> while pred (+1) 0
17:15:07 <syntaxfree> what is the (a->a) doing there?
17:15:10 <jimapple> @hoogle (a->Bool) -> a -> a
17:15:11 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
17:15:11 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
17:15:19 <syntaxfree> not everywhere.
17:15:35 <lennart> syntaxfree: you need a function to chanhe the loop variable
17:15:42 <syntaxfree> ahh.
17:15:48 <syntaxfree> > while (<10) (+1) 0
17:15:48 <lambdabot>  Not in scope: `while'
17:15:52 <jimapple> @djinn (a -> Bool) -> a -> a
17:15:52 <lambdabot> f _ a = a
17:15:57 <syntaxfree> > until (<10) (+1) 0
17:15:58 <lambdabot> 0
17:16:04 <syntaxfree> oops.
17:16:08 <syntaxfree> > until (>10) (+1) 0
17:16:09 <lambdabot> 11
17:16:13 <syntaxfree> good!
17:16:14 <syntaxfree> thanks :)
17:18:11 <syntaxfree> @pl minLevelCollatz x = until (findCollatz x) (+1) 0
17:18:11 <lambdabot> minLevelCollatz = flip (flip until (1 +) . findCollatz) 0
17:18:22 <syntaxfree> nah, too weird.
17:18:57 <syntaxfree> @hoogle unfoldTree
17:18:58 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
17:18:58 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
17:18:58 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree
17:18:58 <lambdabot> a)
17:20:10 <MenTaLguY> hello again
17:20:44 <syntaxfree> hmm. Why the hell am I getting this message, then? learntree.hs:8: Variable not in scope: `unfoldTree'
17:20:45 <syntaxfree> Failed, modules loaded: none.
17:20:51 <syntaxfree> I did import Data.Tree
17:21:57 <Saulzar> @hoogle unfoldTree
17:21:58 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
17:21:58 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
17:21:58 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree
17:21:58 <lambdabot> a)
17:22:13 <syntaxfree> > Data.Tree.unfoldTree (\x->(x, [x+1, x-1])) 
17:22:14 <lambdabot>  add an instance declaration for (Show (b -> Tree b))
17:22:27 <syntaxfree> > Data.Tree.unfoldTree (\x->(x, [x+1, x-1]))  1
17:22:28 <lambdabot> Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {
17:22:28 <lambdabot> rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = [Node {
17:22:28 <lambdabot> rootLabel = 5, subForest = [Node {rootLabel = 6, subForest = [Node {
17:22:28 <lambdabot> rootLabel = 7, subForest = [Node {rootLabel = 8, subForest = [Node {
17:22:28 <lambdabot> rootLabel = 9, subForest = [Node {rootLabel = 10, subForest = [Node {
17:22:30 <lambdabot> [25 @more lines]
17:22:32 <syntaxfree> etc. etc.
17:22:41 <palomer> @hoogle a-> a
17:22:42 <lambdabot> Prelude.id :: a -> a
17:22:42 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:22:42 <lambdabot> Control.Parallel.par :: a -> b -> b
17:22:42 <syntaxfree> why doesn't it work here? I've seen it work before ;-(
17:23:16 <Saulzar> Some kind of bad syntax? :)
17:23:37 <syntaxfree> it says "variable not in scope".
17:23:48 <palomer> @hoogle a->_|_
17:23:48 <lambdabot> hoogle: Unexpected character when parsing: |_
17:23:48 <lambdabot>  
17:24:25 <jimapple> @hoogle a -> b
17:24:26 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:24:26 <lambdabot> Prelude.id :: a -> a
17:24:26 <lambdabot> Prelude.undefined :: a
17:24:28 <Saulzar> syntaxfree, Put it on the paste site maybe
17:24:48 <jimapple> @hoogle a -> (forall b . b)
17:24:48 <lambdabot> hoogle: Unexpected character when parsing: . b)
17:24:48 <lambdabot>  
17:25:20 <palomer> @hoogle a -> (forall b.b)
17:25:21 <lambdabot> Prelude.id :: a -> a
17:25:21 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:25:21 <lambdabot> Control.Parallel.par :: a -> b -> b
17:27:11 <palomer> hrm
17:30:13 <Lor> Hee.
17:30:19 <Lor> @djinn ((a -> b) -> a) -> a
17:30:19 <lambdabot> f a =
17:30:19 <lambdabot>   case em of
17:30:19 <lambdabot>   Left b -> b
17:30:19 <lambdabot>   Right c -> a (\ d -> void (c d))
17:30:56 <lennart> @djinn-env
17:30:57 <lambdabot> data () = ()
17:30:57 <lambdabot> data Either a b = Left a | Right b
17:30:57 <lambdabot> data Maybe a = Nothing | Just a
17:30:57 <lambdabot> data Bool = False | True
17:30:57 <lambdabot> data Void
17:30:58 <lambdabot> type Not x = x -> Void
17:31:00 <lambdabot> em :: Either a (Not a)
17:31:14 <Lor> I just added it. Seems to work fine.
17:31:38 <lennart> well, sorta
17:32:02 <lennart> @djinn ((c->d)->c)->c
17:32:02 <lambdabot> -- f cannot be realized.
17:32:25 <Lor> It didn't generalize em?
17:32:28 <lennart> djinn has no foralls
17:32:50 <Lor> No axiom schemas, that is. Hrmph.
17:33:01 <lennart> that's right
17:33:11 <jimapple> we might as well
17:33:11 <jimapple> @djinn-add type EM a = Either a (Not a)
17:33:17 <lennart> in general, that makes it undecidable
17:33:41 <jimapple> then add it as an axoim!
17:33:41 <jimapple> @djinn (EM a) -> ((a -> b) -> a) -> a
17:33:42 <lambdabot> f a =
17:33:42 <lambdabot>   case em of
17:33:42 <lambdabot>   Left _ -> \ b ->
17:33:42 <lambdabot>      case a of
17:33:42 <lambdabot>      Left c -> c
17:33:44 <lambdabot>      Right d -> b (\ e -> void (d e))
17:33:46 <lambdabot>   Right f -> case a of
17:33:48 <lambdabot>      Left g -> void (f g)
17:33:50 <lambdabot>      Right h -> \ i -> i (\ j -> void (h j))
17:34:01 <jimapple> d'oh
17:34:06 <lennart> heh!
17:34:13 <jimapple> @djinn-clr
17:34:13 <jimapple> @djinn-add type EM a = Either a (Not a)
17:34:19 <jimapple> @djinn (EM a) -> ((a -> b) -> a) -> a
17:34:19 <lambdabot> f a b =
17:34:19 <lambdabot>   case a of
17:34:19 <lambdabot>   Left c -> c
17:34:19 <lambdabot>   Right d -> b (\ e -> void (d e))
17:34:23 <jimapple> ahhhh
17:34:39 <jimapple> @djinn (EM a) -> ((c -> b) -> c) -> c
17:34:39 <lambdabot> -- f cannot be realized.
17:34:47 <Lor> @djinn EM a -> EM b -> (a->b) -> Either (Not a) b
17:34:48 <lambdabot> f a b c =
17:34:48 <lambdabot>   case a of
17:34:48 <lambdabot>   Left d -> case b of
17:34:48 <lambdabot>      Left _ -> Right (c d)
17:34:48 <lambdabot>      Right e -> Left (\ f -> e (c f))
17:34:50 <lambdabot>   Right _ -> case b of
17:34:52 <lambdabot>      Left g -> Right g
17:34:54 <lambdabot>      Right h -> Left (\ i -> h (c i))
17:35:19 <lennart> not even an absurtity elemination!
17:35:47 <jimapple> Although 
17:35:47 <jimapple> @djinn ((a->b) -> Either (Not a) b) -> EM b -> EM a
17:35:48 <lambdabot> -- f cannot be realized.
17:36:25 <jimapple> lennart: do you mean:
17:36:25 <jimapple> @djinn Not (a, Not a)
17:36:26 <lambdabot> f (a, b) = b a
17:36:47 <lennart> I meant, no use of void
17:36:56 <jimapple> or perhaps
17:36:56 <jimapple> @djinn Either (Not (Not a)) (Not a)
17:36:57 <lambdabot> -- f cannot be realized.
17:36:57 <jimapple> ahhh
17:37:19 <lennart> which is the absurdity elimination rule
17:37:33 <jimapple> @djinn EM a -> (a->b) -> Either (Not a) b
17:37:33 <lambdabot> f a b =
17:37:33 <lambdabot>   case a of
17:37:33 <lambdabot>   Left c -> Right (b c)
17:37:33 <lambdabot>   Right d -> Left d
17:37:50 <Lor> Heh.
17:38:05 <jimapple> I guess b is the absurdity eliminator here
17:38:14 <Lor> It took the longer path when it was available.
17:38:19 <jimapple> @djinn EM b -> (a->b) -> Either (Not a) b
17:38:20 <lambdabot> f a b =
17:38:20 <lambdabot>   case a of
17:38:20 <lambdabot>   Left c -> Right c
17:38:20 <lambdabot>   Right d -> Left (\ e -> d (b e))
17:38:22 <Lor> The proof search is depth-first?
17:38:33 <lennart> it tries to use all bound variables
17:38:45 <syntaxfree> @pl findCollatz x a =  elem x (upto a)
17:38:45 <lambdabot> findCollatz = (. upto) . elem
17:38:55 <lennart> yes, it's a kind of depth first
17:39:05 <lennart> it is depth first
17:39:15 <lennart> with some heuristics on where to search
17:41:34 <Lor> Is there a way to add an opaque type?
17:41:54 <lennart> just use a name
17:42:14 <lennart> @djinn Foo -> Bar
17:42:15 <lambdabot> -- f cannot be realized.
17:42:26 <lennart> @djinn Foo -> Foo
17:42:27 <lambdabot> f a = a
17:44:47 <Lor> Hm, but... "void" has a polymorphic type, how come?
17:45:04 <lennart> because it's built in
17:46:03 <lennart> actually, it's not really built in, it's just pretty printing 'case x of { }' as 'void x'
17:46:09 <Lor> Right.
17:46:50 <lennart> and the Void type is just the nullary disjunction
17:48:14 <Lor> All right, this is really just propositional logic with a Falsum.
17:48:34 <lennart> intuitionistic
17:48:40 <Lor> Right.
17:48:58 <lennart> yes, indeed, that's what it is :)
17:49:16 <lennart> but with proof witnesses
17:50:39 <Lor> Eek! I have lost my neato pretty-printing patches to pesca!
17:51:05 <Lor> Ah, no.
17:53:12 <syntaxfree> @help djinn
17:53:12 <lambdabot> Generates Haskell code from a type.
17:53:12 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:53:18 <syntaxfree> cool :)
17:53:43 <syntaxfree> @djinn Tree a -> a
17:53:43 <lambdabot> -- f cannot be realized.
17:54:09 <syntaxfree> @djinn (Integral b) [b]->b
17:54:09 <lambdabot> -- f cannot be realized.
18:00:17 <syntaxfree> @djinn [b]->b
18:00:18 <lambdabot> -- f cannot be realized.
18:00:35 <syntaxfree> @djinn (a->b)->[b]->[b]
18:00:35 <lambdabot> f _ a = a
18:00:53 <syntaxfree> @djinn (a->b)->[a]->[b]
18:00:53 <lambdabot> -- f cannot be realized.
18:00:57 <syntaxfree> isn't that map?
18:01:18 <Lor> djinn doesn't know about lists, or about recursive types in general.
18:01:30 <syntaxfree> hmm. What does it know about?
18:01:47 <syntaxfree> @type map
18:01:48 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:03:12 <syntaxfree> @djinn a->b
18:03:13 <lambdabot> -- f cannot be realized.
18:03:20 <syntaxfree> @djin (a->b)->a->b
18:03:21 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
18:03:21 <lambdabot> ver
18:03:32 <syntaxfree> @djinn (a->b)->a->b
18:03:32 <lambdabot> f a = a
18:03:43 <syntaxfree> @djinn (a->a)->b->a
18:03:43 <lambdabot> -- f cannot be realized.
18:04:05 <syntaxfree> @djinn (b->a)->b->a
18:04:06 <lambdabot> f a = a
18:04:34 <syntaxfree> @djinn-env
18:04:35 <lambdabot> data () = ()
18:04:35 <lambdabot> data Either a b = Left a | Right b
18:04:35 <lambdabot> data Maybe a = Nothing | Just a
18:04:35 <lambdabot> data Bool = False | True
18:04:35 <lambdabot> data Void
18:04:36 <lambdabot> type Not x = x -> Void
18:04:38 <lambdabot> type EM a = Either a (Not a)
18:23:45 <MarcWeber> Thanks @ll! It's working!! Yeahhh jipiehhh h juchuhhhh .. Let's jump and dance!
18:27:36 <Saulzar> What is working? and how much have you had to drink? :)
18:29:05 <MarcWeber> Saulzar: I've managed to compile hdirect on windows with SUPPRT_TYPELIBS... At the moment I've got only one bottle of juice and some tea.. and of cause water from the tape ;-) It wasn't much... Just adding some libs and such things.. but I had to learn how it's done in haskell first..
18:31:40 <Saulzar> Ahh, cool. It does feel great to pass that barrier...
18:33:32 <MarcWeber> It took me a little more than 3 month.. ;-) Wow. Let's do something useful.. 
18:34:54 <Saulzar> I see how you might be quite happy, what are you using it for?
18:39:27 <MarcWeber> Don't listen.. *g* I want to do some DAO scripting.. I jobbed for some people using access for project management and so on.. I tried writing some script comparing two access databases using VBA but I failed .. better to say I felt it was to time consuming using VBA.. So I'll try now hdirect and haskell..
18:40:32 <Saulzar> Ouch :P
18:43:09 <MarcWeber> Will go to bed now.. and have some sleep
19:07:57 <ForgeAus> hey all sup?
19:08:50 <monochrom> hey inf
19:09:07 <ForgeAus> inf?
19:09:36 <monochrom> sup = supremum, inf = infinum
19:10:13 <ForgeAus> oohhh kay.. 
19:10:32 <ForgeAus> I'm a newbie, so that don't mean a hell of a lot to me
19:10:55 <monochrom> oohhh kay..
19:11:39 <jimapple> @seen lennart
19:11:39 <lambdabot> lennart is in #haskell. Last spoke 1 hour, 22 minutes and 23 seconds ago.
19:12:03 <xah_> of interest: http://opal.cabochon.com/~stevey/sokoban/
19:12:21 <ForgeAus> sobokan, thats a pretty famous game... 
19:12:48 <ForgeAus> wow jhyton :) nice
19:38:15 <syntaxfree> Chip's Challenge is a superset of Sokoban.
19:38:27 <syntaxfree> I wish there was C'C for OS X.
19:39:07 <ForgeAus> whats C'C?
19:41:39 <jimapple> chip's challenge, i suppose
19:41:44 <jimapple> @hoogle a -> b
19:41:45 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:41:45 <lambdabot> Prelude.id :: a -> a
19:41:45 <lambdabot> Prelude.undefined :: a
19:44:25 <jimapple> djinn does not like ((¬¬P → P) → (P ∨ ¬P)) → (¬¬P ∨ ¬P)
19:45:23 <monochrom> I probably don't like it either.
19:45:48 <jimapple> @djinn-add type Taut a = Either (Not a) a
19:45:48 <jimapple> @djinn-add type Weak a = Either (Contr a) (Not a)
19:45:48 <jimapple> @djinn-add type Rev a b = (a -> b) -> Either (Not a) b
19:45:48 <jimapple> @djinn-add type Peirce a b = ((a -> b) -> a) -> a
19:45:48 <jimapple> @djinn-add type Goedel a b = Either (a -> b) (b -> a)
19:45:49 <jimapple> @djinn-add type Contr a = Not (Not a)
19:45:51 <jimapple> @djinn-add type Put a b c = (Not a -> Either b c) -> Either (Not a -> b) (Not a -> c)
19:45:53 <jimapple> @djinn-add type Scott a = (Elim a -> Taut a) -> Weak a
19:45:55 <jimapple> @djinn-add type Elim a = Contr a -> a
19:45:57 <jimapple> @djinn Rev a b -> Scott a
19:45:58 <lambdabot> -- f cannot be realized.
19:46:11 <jimapple> @djinn Elim a -> Scott a
19:46:12 <lambdabot> f a b =
19:46:12 <lambdabot>   case b (\ c -> a (\ d -> void (c d))) of
19:46:12 <lambdabot>   Left e -> Right e
19:46:12 <lambdabot>   Right f -> Left (\ g -> g f)
19:46:19 <jimapple> @djinn Rev a b -> Elim a
19:46:20 <lambdabot> -- f cannot be realized.
19:46:44 <jimapple> also, my machine is slow
19:49:00 <jimapple> @djinn Put a b c -> Scott a
19:50:52 <syntaxfree> hmm. djinn is just like @fact and others.
19:51:04 <jimapple> @fact @fact
19:51:07 <jimapple> @fact djinn
19:51:12 <jimapple> uhoh
19:51:26 <jimapple> @localtime jimapple
19:51:35 <jimapple> @pl f a = a
19:51:38 <jimapple> @type id
19:51:45 <jimapple> I killed lambdabot :-(
19:52:14 <jimapple> it didn't happen before:
19:52:14 <jimapple> (22:42:51) jimapple: @djinn Put a b c -> Scott a
19:52:14 <jimapple> (22:43:07) lambdabot: djinn module failed: thread killed
19:52:20 <jimapple> I just wanted to show you guys
19:53:07 <jimapple> arise, lambdabot, arise from your grave
19:53:11 <monochrom> We should rename lambdabot to Kenny.  Then we will get to say "you killed Kenny again!" every two weeks.
19:53:25 <jimapple> you bastartd
19:54:06 <jimapple> In this case, it was Hilary Putnam and Dana Scott who have killed lambdabot
19:54:33 <gzl> Hilary Putnam and Dana Scott killed lambdabot?
19:54:49 <monochrom> I know that Scott domain stuff would kill.
19:57:07 <jimapple> monochrom: how did you know? I don't really understand the axiom's implications, other than Weak a, obviously
19:59:14 <jimapple> Well, I should go
19:59:30 <jimapple> Be careful with the genie, kids
19:59:40 <monochrom> heh
19:59:55 <jimapple> and always remember the danger of depth-first search.
20:07:30 <ForgeAus> jimapple is it in a bottle (the genie)?
20:28:40 <syntaxfree> what is wrong with Hilary Putnam?
20:31:21 <monochrom> nothing wrong. we're just joking.
21:10:41 <gzl> huh. so Phil Wadler is visiting my department, but I won't be there. dammit.
21:43:26 <machack666> How would one go about multiplying an Int and Float?
21:44:42 <ForgeAus> use fromInt? maybe?
21:45:00 <ForgeAus> or toFloat? (if there is one?)
21:45:20 <machack666> tried those, but it looks like it's fromIntegral
21:45:20 <ForgeAus> > toFloat 3
21:45:51 <ForgeAus> yeah.. prolly fromIntegral
21:46:02 <ForgeAus> > fromIntegral 4
21:46:16 <dons> lambdabot got picked on...
21:46:28 <ForgeAus> yeah not opped so prolly script don't work
21:46:39 <Cale> @bot
21:46:43 <Cale> no bot
21:47:02 <ForgeAus> lambdabot is in the nicklist tho
21:47:07 <ForgeAus> just not @ list
21:47:28 <Cale> It's never in the op list
21:47:34 <ForgeAus> actually nobody here in @'s (nless my clients lying to me)
21:47:38 <Cale> right
21:47:55 <Cale> People only take ops when necessary
21:48:28 <ForgeAus> I like that system :)
21:51:41 <dons> grr, lambdabot can't reconnect until freenode realises lambdabot isn't connected
21:51:53 <Cale> ghost it
21:52:04 <Cale> (after all, you know its password)
21:55:05 <dons> ghost it?
21:55:09 <dons> how do I do that.
21:55:24 <Cale>  /msg nickserv ghost lambdabot <password>
21:55:42 <dons> cool
21:56:46 <dons> so someone typed a bunch of gunk into @djinn, which confused djinn, I think.
21:56:56 <dons> we need a generic way to kill forked processes
21:57:08 <dons> currently, we have an ad-hoc signal kill for @eval and @lambda
21:57:26 <dons> but djinn would need it to. this would stop a couple of other issues where processes don't terminate properly
22:15:29 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
22:15:29 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
22:15:29 --- names: list (clog qnix_ greenrd Twigathy tromp_ aheller xinming soysauce Speck alch` djw Khisanth Touqen yaarg Philippa gaal dcoutts cognominal_ araujo chucky JohnMeacham wolverian wli_ cooz johs earthy mornfall Ferret verve_ jimapple sproingie _metaperl chadronius ramkrsna shapr ulfdoz Pupeno samx seafood jlouis dcoutts_ jiing sieni Matt-W pejo jesse99 Cale cathper Igloo takuan emu_ Lemmih kpk Azmo noj Lunar^ integral waltz musasabi noclouds dany2k|sleep)
22:15:29 --- names: list (ibid flux__ Iome ValarQ Lor Nomius_ cjs_ svens_ audreyt kpreid_ roqp saudade syntaxfree neologism borism tuomov lambdabot juhp ForgeAus exsisonek lisppaste2 resiak spamsch lennart thedward kosmikus ksandstr eyck MrBraker kala scw gdsx cpatrick kolmodin zamez)
22:43:08 * lispy wants more time
22:43:24 <lispy> why doesn't life have a cheat code for infinite time ;)
22:44:54 <aleator_> I would settle for save-load... :/
22:47:47 <palomer> man
22:47:53 <palomer> ever since I learned about haskell IO I love it
22:47:54 <palomer> love it!
22:51:30 <palomer> haskell really is very pure
22:56:18 <araujo> Hello.
22:57:27 <ricebowl> laziness would be impossible were Haskell not pure
23:00:10 <lispy> i was annoyed today when i received a type error at run-time
23:00:19 <lispy> but i was using VB not Haskell!
23:01:45 * araujo saluda a Nomius 
23:02:47 <Nomius> Buenas araujo 
23:02:50 * soysauce lanza una lambda a Nomius por araujo
23:04:55 <araujo> hah
23:22:27 <Saulzar> lispy, Though I haven't had the misfortune to use VB lately, one thing I really enjoy is not fixing 1+ Segmentation Fault's every modification
23:23:10 <lispy> Saulzar: you had segfaults in VB?
23:23:21 <lispy> i've done a lot of VB programming and never had a segfault
23:23:27 <Saulzar> No - but just about always with C++
23:23:31 <lispy> Ah
23:23:44 <lispy> yeah, with C++ I try to use STL as often as possible...
23:24:09 <lispy> when i use vector i use .at(index) instead of [index] as it bounds checks...
23:24:37 <Saulzar> I try to as well, but I will always go for [index] :)
23:24:46 <lispy> :)
23:25:05 <Saulzar> Haskell, I blunder away .. don't know what I'm doing, fix type errors for half an hour and it just seems to work...
23:25:05 <lispy> my code tends to have a lot of "assert( blah )"
23:25:14 <lispy> heh
23:29:09 <ricebowl> up to a certain size I rarely get segfaults in C++
23:29:31 <ricebowl> and usually they are trivial to find and fix. That's for small projects, of course...
23:30:38 <Saulzar> Hmm, I guess there's some truth in that... the C++ code I work on is usually much bigger than anything I have toyed with in haskell.
23:32:16 <ricebowl> *nods*
23:32:32 <ricebowl> Haskell does have the advantage of being far more terse
23:32:54 <araujo> Saulzar, That's because C++ is bloated.
23:32:56 <lispy> i really like that haskell has tuples
23:33:17 <ricebowl> yes, I miss tuples every time I use C++ :(
23:33:28 <Saulzar> Pattern matching is the key, tuples in C++ just aren't the same
23:33:30 <lispy> i needed to put something in a hashtable in VB and I needed to create a class just for the keys.  It was a total pain
23:33:38 <ricebowl> currying less often, but I have encountered situations where currying would have been extremely useful
23:34:11 <ricebowl> Saulzar - one can get by without pattern matching, though it is less convenient; without tuples, however, you have to create a record (struct/class) type
23:34:31 <ricebowl> *however* the small project I am working on right now would benefit immensely from the pattern matching in Haskell :p
23:34:37 <Saulzar> There are tuples in C++ though, at least pair etc. or more with boost
23:35:14 <ricebowl> sure, but they're far more complex to manipulate
23:35:22 <ricebowl> and they're still not built-in
23:35:25 <Saulzar> Yup..
23:35:29 <ricebowl> and, more to the point, I don't have boost here
23:35:29 <lispy> Saulzar: hmm..maybe i just overlooked them
23:36:04 <Saulzar> I don't like them much without the pattern matching anyway.
23:36:23 <ricebowl> it's a lot nicer than requiring the caller to pass in a bunch of pointers
23:37:02 <Saulzar> Hmm, but a struct gives you names.
23:38:49 <Saulzar> It just gets dull and takes all the fun out of everything :)
