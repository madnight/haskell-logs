00:00:09 <Taral> Xianianol: That will give you a list with the sequence of steps.
00:00:57 <Taral> @type unfoldr
00:00:57 <lambdabot> Not in scope: `unfoldr'
00:01:03 <Xianianol> Humm, seems to be a infinite one.
00:01:05 <Taral> @type List.unfoldr
00:01:06 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
00:01:58 <Xianianol> If I use "take", I would need an extra function that calculates the steps needed for the expression.
00:02:09 <Taral> Xianianol: huh?
00:02:14 <Taral> what I gave you should not be infinite
00:02:23 <Taral> unless there are infinite steps
00:02:34 <Taral> (i.e. nonterminating evaluation)
00:02:36 <Xianianol> humm
00:02:39 <twb> OK, explain this:
00:02:42 <twb> escapedChar = try ( do { char '\\'; anyChar; } )
00:02:42 <twb>               <|> anyChar
00:02:50 <twb> parseTest escapedChar "\\" ===> '\\'
00:03:09 <Taral> errr
00:03:22 <twb> Is it using the second form?
00:03:41 <Taral> yes
00:03:47 <Taral> don't use try
00:03:55 <Taral> do { char '\\'; anyChar } <|> anyChar
00:04:00 <twb> try was me trying to debug :-)
00:04:08 <Taral> what happens is this:
00:04:12 <Taral> char '\\' succeeds
00:04:15 <Taral> anyChar fails
00:04:18 <Taral> try resets to the start
00:04:21 <Taral> anyChar succeeds
00:04:26 <Taral> without the try, you will fail on "\\"
00:04:37 <twb> Good, fixed it.
00:04:42 <twb> Use noneOf "\\"
00:04:44 <Taral> because <|> only tries the second part if the first part doesn't consume any imput
00:04:47 <Taral> er, input
00:04:48 <Taral> nono
00:04:52 <Taral> you shouldn't need noneOf
00:04:59 <Xianianol> Humm, I think my evalStep function is causing that problem then, this field: evalStep env (Nat n) = Nat n
00:05:04 <twb> I'll try again.
00:05:16 <twb> Hmm, you're right.
00:05:16 <Taral> Xianianol: I don't think so -- eval shouldn't pass Nat n to evalStep
00:05:29 <Taral> twb: Understanding <|> is key to parsec
00:06:06 <twb> Still not good in the larger case, though.
00:06:10 <Taral> once a branch has consumed some input, it is committed
00:06:10 <Xianianol> Humm, why shouldn't it ?
00:06:16 <Taral> Xianianol: Because of the ordering
00:06:22 <Taral> eval env x@(Nat _) = [x]
00:06:23 <twb> prop_escapedChar_allEscapes xs = mkProp_parser (many escapedChar) xs (escapeAll xs)
00:06:23 <twb>     where types = xs::[Char]
00:06:23 <twb>           escapeAll xs = '\\' : intersperse '\\' xs
00:06:23 <Taral> is first
00:06:31 <twb> That fails when xs is "".
00:06:56 <twb> Also needs:
00:06:56 <twb> mkProp_parser' combinator output input =
00:06:56 <twb>     case (parse combinator "" input) of
00:06:56 <twb>       Left o -> error "foo"         -- failed to parse.
00:06:56 <twb>       Right o -> o
00:07:24 <Xianianol> Will my evalStep be causing that problem then ?
00:07:40 <Taral> Xianianol: What problem are you seeing?
00:07:49 <Xianianol> Infinite long list.
00:07:55 <Taral> That's not enough to debug the problem
00:07:57 <Taral> what is in the list?
00:08:19 <Taral> twb: Um, it doesn't work?
00:08:20 <Xianianol> Well, the steps of the evaluation, and the repeating one that repeats many time is the final result.
00:08:26 <Taral> what is the repeating one?
00:08:47 <twb> Taral: Falsifiable, after 0 tests: ""
00:09:00 <Taral> twb: Oh, your escapeAll function is broken
00:09:02 <Xianianol> For example: eval [] (Nat 5 :+ Nat 6), the reapeating one is Nat 11
00:09:18 <twb> Taral: well, yes.
00:09:21 <twb> I suppose...
00:09:25 <Taral> twb: try using escapeAll xs = concatMap (\c -> ['\\'. c]) xs
00:09:33 <Taral> twb: try using escapeAll xs = concatMap (\c -> ['\\', c]) xs
00:09:48 <twb> Taral: or escapeAll [] = []
00:09:53 <Taral> that works too
00:10:05 <Taral> Xianianol: Did you list the eval lines in the right order
00:10:09 <Taral> There are two eval definitions
00:10:24 <Taral> eval env x@(Nat _) = [x]
00:10:30 <Taral> eval env x = x : eval env (evalStep env x)
00:10:51 <Taral> you need both, and in that order
00:11:06 <Taral> the first one terminates the recursion when we see an expression of form (Nat _)
00:11:07 <Xianianol> Oh, I missed the first one :-/
00:11:31 <Taral> heh
00:12:07 <Taral> working now?
00:12:17 <Xianianol> Yes!
00:12:24 <Taral> :)
00:12:29 <Xianianol> What does x@(Nat _) means ? the "x@"
00:12:40 <Taral> it means "something of form (Nat _), which I will call x"
00:12:54 <Xianianol> Oh, thanks.
00:12:56 <Taral> :)
00:13:01 <soysauce> Taral - thank you, by the way; my program seems to be working
00:13:05 <soysauce> against all odds
00:13:06 <Taral> soysauce: Awesome.
00:13:13 <Xianianol> Since I need to understand the code or I will have nightmare using it :P
00:13:21 <Taral> Xianianol: Of course.
00:13:21 <soysauce> mutate a i f = (readArray a i) >>= \x -> writeArray a i (f x)
00:13:34 <soysauce> I use that small function in a bigger one which populates my array
00:13:41 <soysauce> it's similar to Array.array, I suppose
00:13:56 <Taral> soysauce: Yes, that works well.
00:14:19 * soysauce is translating this code from C
00:14:38 <twb> soysauce: probably not the best idea.
00:14:40 <Taral> soysauce: You might want to do:
00:14:42 <soysauce> probably not
00:14:47 <soysauce> @pl \(x, y) -> (y, x)
00:14:47 <lambdabot> uncurry (flip (,))
00:15:06 <Taral> newListArray (low, high) (map f $ range (low, high))
00:15:19 <twb> soysauce: perhaps instead you should work out what functionality the C code provides, then reimplement it with a functional design.
00:15:36 <soysauce> twb - it's approximately the same
00:15:50 <soysauce> @hoogle newListArray
00:15:51 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
00:15:51 <lambdabot> m (a i e)
00:16:09 <Taral> soysauce: newListArray prepopulates the array efficiently
00:16:15 <Taral> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html#v%3AnewListArray
00:16:19 <soysauce> twb - I've written both separately, already; am just having another go at the functional version
00:16:29 <twb> soysauce: OK.
00:16:37 <soysauce> Taral - mine aren't sorted
00:16:45 <Taral> huh?
00:16:53 <soysauce> "Constructs a mutable array from a list of initial elements. The list gives the elements of the array in ascending order beginning with the lowest index."
00:17:00 <Taral> Um...
00:17:02 <twb> Can Parsec handle unicode input?
00:17:07 <Taral> map f $ range (low, high) will be sorted
00:17:10 <soysauce> oh, I see
00:17:26 <soysauce> sorry, just very tired
00:17:35 <Taral> Of course, if you're doing that, then you might want to use standard arrays for a more functional form
00:17:50 <soysauce> f :: (Int, Int) -> Int64?
00:17:56 <twb> @index word
00:17:57 <lambdabot> bzzt
00:17:58 <Taral> soysauce: No.
00:18:01 <twb> @index words
00:18:02 <lambdabot> Data.List, Prelude
00:18:04 <Taral> @type Data.Ix.range
00:18:05 <lambdabot> forall a. (GHC.Arr.Ix a) => (a, a) -> [a]
00:18:14 <Taral> f :: i -> e
00:18:17 <Taral> in your case, Int -> Int64
00:18:18 <twb> Ah, neat.
00:18:22 <soysauce> no, my a is (Int, Int)
00:18:31 <Taral> ?!
00:18:33 <soysauce> it's an NxN matrix
00:18:36 <Taral> O.o
00:18:52 <Taral> okay
00:18:59 <Taral> then yes
00:19:15 <soysauce> sorry; I'm populating a square matrix and running Floyd-Warshall's algorithm to find the shortest path between nodes. (The matrix represents the paths between each node.)
00:19:28 <soysauce> well, something like that, anyway
00:19:30 <Taral> um
00:19:42 <Taral> Is it a dynamic programming algorithm?
00:19:58 <soysauce> I don't think so... it has constant running time of O(n^3)
00:20:01 * twb inserts Matrix film joke.
00:20:03 <Taral> gah, no then
00:20:15 <soysauce> but IIRC Dijkstra's algorithm is sometimes called a dynamic programming algorithm
00:20:20 <Taral> Did you look at Data.Graph?
00:20:24 <soysauce> no
00:20:35 <Taral> it has many graph algorithms implemented very efficiently
00:20:42 <Taral> -package fgl for ghc
00:20:54 <soysauce> but in this case I have to compute the distances between all nodes
00:21:06 <Taral> dynamic programming algorithms use memoization to reduce run-time
00:21:10 <soysauce> something like this: List.nub (Array.elems (fw (newArray ...)))
00:21:18 <soysauce> I know
00:21:38 <soysauce> you store computations in an array and then reuse them later
00:21:44 <Taral> http://en.wikipedia.org/wiki/Dynamic_programming
00:21:48 <Taral> good article
00:22:03 <soysauce> I think FW classifies as dynamic programming, intuitively
00:22:18 <twb> My haskell-based lecturer told me Haskell memoizes automatically.
00:22:31 <Taral> DP is usually something of "solve a sub-problem, then use the sub-solutions to solve the main problem"
00:22:35 <Taral> twb: Almost automatically :)
00:22:45 <soysauce> yeah
00:22:45 <twb> Taral: how much is almost?
00:22:49 <Taral> twb: For example:
00:23:01 <twb> Taral: in CL, you just put memoize around the defun.
00:23:33 <Taral> twb: Is memoize a special form?
00:23:34 <twb> in CL I was contemplating (declare (purely-functional t)).
00:23:38 <twb> memoize is a macro.
00:23:44 <soysauce> > let fib n = 1:1:[fib n | n <- [3 ..]] !! n in fib 5
00:23:45 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:23:45 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:23:45 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:23:45 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:23:45 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:23:48 <lambdabot> [23 @more lines]
00:23:49 <Taral> It would have to be, since memoization is a source-to-source transform
00:23:51 <soysauce> well, maybe not
00:24:00 <twb> Taral: correct.
00:24:13 <soysauce> er, d'oh
00:24:19 <twb> But macro-expansion is done at compile time.
00:24:21 <Taral> > let fib n = 1:1:[fib (n-1) + fib (n-2) | n <- [3..]] !! n in fib 5
00:24:22 <lambdabot>  add an instance declaration for (Num [a])
00:24:22 <lambdabot>   In the definition of `not':
00:24:22 <lambdabot>    not = let fib n = 1 : (1 : (([... | n <- ...]) !! n)) in fib 5
00:24:33 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! n in fib 5
00:24:38 <lambdabot> Terminated
00:24:48 <soysauce> > let fib n = 1:1:[fib (n-1) + fib (n-2) | n <- [2 ..]] !! n in fib 5
00:24:49 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 5
00:24:49 <lambdabot>  add an instance declaration for (Num [a])
00:24:49 <lambdabot>   In the definition of `dmv':
00:24:49 <lambdabot>    dmv = let fib n = 1 : (1 : (([... | n <- ...]) !! n)) in fib 5
00:24:50 <lambdabot> 5
00:24:59 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 5
00:25:00 <lambdabot> 5
00:25:03 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 1
00:25:04 <lambdabot> 1
00:25:06 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 2
00:25:07 <lambdabot> 1
00:25:09 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 3
00:25:10 <lambdabot> 2
00:25:12 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 4
00:25:13 <lambdabot> 3
00:25:14 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 5
00:25:15 <lambdabot> 5
00:25:16 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 6
00:25:17 <lambdabot> 8
00:25:18 <Taral> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in fib 7
00:25:19 <lambdabot> 13
00:25:20 <soysauce> nice
00:25:22 <Taral> okay, done spamming
00:25:39 <soysauce> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in map fib [1..]
00:25:44 <lambdabot> Terminated
00:25:54 <soysauce> well, that wasn't very nice.
00:25:55 <Taral> > let fib = (1:1:[fib !! (n-1) + fib !! (n-2) | n <- [2..]]) in take 7 fib
00:25:56 <lambdabot> [1,1,2,3,5,8,13]
00:26:14 <Taral> *that* is the right way
00:26:21 <soysauce> > let fib n = (1:1:[fib (n-1) + fib (n-2) | n <- [3..]]) !! (n-1) in map fib [1..10]
00:26:22 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
00:26:27 <Taral> make fib a CAF so it caches correctly
00:26:42 <soysauce> *nods*
00:26:49 <Taral> if you make fib a lambda, it won't cache
00:26:54 <Taral> -> no memoization
00:27:00 <soysauce> ah, that makes sense
00:27:05 <Taral> twb: got the idea?
00:27:23 <soysauce> > let fib' = (1:1:[fib !! (n-1) + fib !! (n-2) | n <- [2..]]); fib n = fib' !! n in map fib [1..]
00:27:24 <lambdabot>   The equation(s) for `fib' have one argument,
00:27:24 <lambdabot>   but its type `t_a1DB' has none
00:27:24 <lambdabot>   In the definition of `bza':
00:27:34 <twb> Taral: I think so.
00:27:39 <soysauce> > let fib' = (0:1:[fib' !! (n-1) + fib' !! (n-2) | n <- [2..]]); fib n = fib' !! n in map fib [1..]
00:27:41 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
00:27:41 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
00:27:41 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
00:27:41 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
00:27:41 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
00:27:43 <lambdabot> [24 @more lines]
00:27:54 <twb> CAFs are auto-memoized, but other forms must be memoized explicitly.
00:27:59 <soysauce> and the peasants rejoiced
00:28:02 <Taral> twb: Yes.
00:28:33 <Taral> soysauce: Of course, that's the same as this:
00:28:37 <Taral> > let fib = (1:1:[fib !! (n-1) + fib !! (n-2) | n <- [2..]]) in fib
00:28:39 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
00:28:39 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
00:28:39 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
00:28:39 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
00:28:39 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
00:28:41 <lambdabot> [24 @more lines]
00:28:44 <soysauce> true
00:29:13 <Taral> there are even faster ways...
00:29:33 <twb> I talk to the trees... / That's why they put me away...
00:29:44 <twb> Well, I gotta get home.
00:29:57 <Taral> let fib = 1:1:fib' 1 1; fib' x y = (let z = x+y in z : fib y z) in fib
00:29:59 <Taral> > let fib = 1:1:fib' 1 1; fib' x y = (let z = x+y in z : fib y z) in fib
00:29:59 <lambdabot>   The function `fib' is applied to two arguments,
00:29:59 <lambdabot>   but its type `t_a1tE' has none
00:30:01 <Taral> oops
00:30:07 <Taral> > let fib = 1:1:fib' 1 1; fib' x y = (let z = x+y in z : fib' y z) in fib
00:30:08 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
00:30:08 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
00:30:08 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
00:30:08 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
00:30:08 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
00:30:10 <soysauce> > let fib n = let fib' a b n = if n == 0 then b else fib' (a+b) a (n-1) in fib' 1 0 n in fib 8
00:30:10 <lambdabot> [24 @more lines]
00:30:12 <lambdabot> 21
00:30:37 <Taral> of course, that's cheating, since I'm not memoizing anymore, I'm building the list directly :)
00:31:20 <soysauce> true
00:31:25 <Taral> let fib = fib' 1 1; fib' x y = x : fib' y (x+y) in fib
00:31:32 <Taral> > let fib = fib' 1 1; fib' x y = x : fib' y (x+y) in take 20 fib
00:31:33 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
00:31:35 <Taral> nifty
00:31:55 <soysauce> that is pretty cool
00:32:03 <Taral> actually, it's still memoizing (CAF), but not dynamic programming (not using the CAF)
00:32:59 <Taral> hm
00:33:21 <Taral> I suppose it is dynamic programming, since it is reusing earlier sequence elements, but I'm just not using the (slow) !! operator to get them
00:33:41 <soysauce> that's not dynamic programming, though
00:33:44 <Taral> it is
00:33:45 <soysauce> it's something else
00:33:58 <Taral> look at the bottom of http://en.wikipedia.org/wiki/Dynamic_programming
00:34:05 <soysauce> hum...
00:34:27 <Taral> DP is where you use solutions to earlier subproblems (the arguments to fib' in my thing above) to compute solutions to larger problems
00:34:30 <Xianianol> erm, sorry again, I am trying to display the list of steps in a nice way to the user, so I:
00:34:30 <Taral> s/earlier/smaller/
00:34:34 <Xianianol> showSteps [] = ("" :: [Char])
00:34:34 <Xianianol> showSteps (x:xs) = showExpr(x)
00:34:40 <soysauce> oh well
00:34:49 <Taral> Xianianol: what is the type of showExpr?
00:34:56 <Xianianol> String
00:35:00 <Taral> use map
00:35:06 <Xianianol> I was wondering how do I tell it to continue
00:35:06 <Taral> map showExpr (eval env x)
00:35:21 <Taral> oh, wait
00:35:25 <Taral> you want to display one at a time?
00:35:28 <Xianianol> Yes
00:35:32 <Taral> um...
00:35:35 <Xianianol> Separated by a newline
00:35:41 <Taral> oh, okay
00:35:46 <twb> So "dynamic programming" is essentially what is colloquially known as  "divide and conquer"?
00:35:54 <Taral> twb: divide and conquer is an instance of DP
00:36:06 <Xianianol> Something like:
00:36:06 <Xianianol> showSteps [] = ("" :: [Char])
00:36:06 <Xianianol> showSteps (x:xs) = showExpr(x) ++ "\n"
00:36:15 <Taral> showSteps [] = ""
00:36:18 <Xianianol> But I need to recall the showSteps function recursively
00:36:23 <Taral> showSteps (x:xs) = showExpr x ++ "\n" ++ showSteps xs
00:36:30 <kzm> twb: I disagree
00:36:42 <twb> kzm: you disagree with a question?
00:36:51 <Taral> that's what I was thinking :)
00:37:04 <kzm> Yes. :-)
00:37:13 <Taral> heh
00:37:25 <kzm> I disagree with the assertion that your question consists of.
00:37:29 <twb> Really?  I was thinking that wearing underpants with metal studs is a really bad idea if you put them on inside-out.
00:37:39 <Taral> twb: Ha.
00:37:50 <soysauce> twb - divide and conquer is not DP
00:37:50 <Taral> twb: Did you read the wikipedia article?
00:37:55 <soysauce> DP is referentially transparent
00:37:57 <twb> Taral: I skimmed it.
00:38:06 <soysauce> or rather, it uses referential transparency
00:38:10 <Taral> D&C can be DP if the subproblems are instances of the larger problem.
00:38:16 <Taral> soysauce: Huh?
00:38:27 <soysauce> well, that is what I thought, anyway
00:38:41 <Taral> soysauce: Nah, DP is applicable to any language
00:38:47 <twb> Now let's talk about what OOP is!  And Monads! :-)
00:38:54 <Taral> Oh, monads.
00:38:56 <soysauce> sorting half of an array doesn't help you with the other half, though
00:39:02 <Taral> soysauce: Exactly.
00:39:11 <kzm> I think the point is that with DP you replace a function call with a table lookup.
00:39:23 <Taral> kzm: Um, sometimes that's true.
00:39:27 <Taral> kzm: But not always.
00:39:28 <soysauce> that's why I said referential transparency
00:39:30 <kzm> which sort of requires ref transparency
00:39:48 <kzm> taral, assume a wide definition of "table"?
00:39:48 <Taral> no.
00:39:54 <Taral> kzm: Okay, fine.
00:40:00 <Taral> But I can do DP in C, which has no RT
00:40:15 <Taral> @quote Taral But I can do DP in C, which has no RT
00:40:15 <lambdabot> Taral But I can do DP in C, which has no RT hasn't said anything memorable
00:40:18 <soysauce> sure it does, it's just not guaranteed
00:40:20 <Taral> @remember Taral But I can do DP in C, which has no RT
00:40:25 <Taral> Ha.
00:40:44 <Taral> In that case, yes, but I don't think it really has any serious bearing on the technique.
00:41:03 <soysauce> FWIW there is a GCC extension that allows you to hint to the compiler that an external function is referentially transparent
00:41:05 <Taral> The domain of problem solution is inherently RT
00:41:07 <Xianianol> weird, my newline is not working
00:41:15 <Taral> You give it a problem, it gives you a solution
00:41:29 <Taral> if it's deterministic, it will always give you the same solution for the same problem
00:41:32 <Taral> i.e. ref trans
00:41:37 <Xianianol> Is there any problem with the way I put "\n" ? : showSteps (x:xs) = showExpr(x) ++ "\n" ++ showSteps (xs)
00:41:44 <Taral> Xianianol: No, that's a newline.
00:42:04 <soysauce> well, as I read the wiki, it explains that the crux of DP is that the same result is recomputed multiple times. DP saves that result and reuses it so that it is only computed once.
00:42:05 <Taral> what do you mean by "not working"?
00:42:12 <soysauce> divide-and-conquer does not fall into that strategy
00:42:14 <Taral> soysauce: Yes.
00:42:20 <Taral> soysauce: I was mistaken earlier.
00:42:21 <soysauce> not generally, at least
00:42:22 <Xianianol> Weird, my hugs gives me back something like: "(22 + 17)\n39\n"
00:42:32 <soysauce> a merge sort isn't DP but *is* DnC
00:42:36 <Taral> > fromEnum $ head "\n"
00:42:38 <lambdabot> 10
00:42:40 <Taral> that's a newline
00:42:43 <Taral> Oh!
00:42:47 <Taral> hugs is showing you the representation
00:42:51 <Taral> Try using "print $ ..."
00:42:55 <Taral> er
00:42:56 <soysauce> I've always mentally generalized DP to the idea of caching results in a table and using lookups
00:42:59 <Taral> Try using "putStr $ ..."
00:43:03 <Xianianol> or it would jsut work if I use prinStrLn ?
00:43:09 <Taral> @type putStr
00:43:10 <lambdabot> String -> IO ()
00:43:17 <Taral> you want putStr, not putStrLn
00:43:21 <Taral> you already have your newlines :)
00:43:27 <Xianianol> heh, true...
00:43:28 <Xianianol> Thanks
00:43:32 <kzm> DP = recursion + tabulation (Giegerich et al.)
00:43:35 <Taral> of course, if you're doing that...
00:43:50 <Taral> try mapM_ (putStrLn . showExpr) (eval env x)
00:44:02 <Taral> kzm: Yup.
00:44:08 <Taral> For a wide enough definition of "table"
00:44:14 <Taral> :)
00:45:26 <Taral> kzm: D&C is not DP because it does not use overlapping subproblems
00:45:39 <soysauce> yeah, essentially
00:45:49 <Taral> the point of DP is to avoid recomputation
00:46:11 <kzm> Sounds reasonable: that's the point of the "divide" part.
00:46:18 <Taral> Yup.
00:46:52 <kzm> What is this? Agreement?! What happened to the debate?
00:47:03 <kzm> Better hurry over to OO
00:47:41 <Taral> Heh.
00:48:00 <Taral> You know, I've just abandoned OO. I prefer type classes now.
00:48:20 <Taral> anyway...
00:48:29 <Taral> soysauce, look at http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Query-SP.html
00:49:03 <soysauce> Taral - thanks, but the point of this assignment was to implement that myself...
00:49:14 <Taral> aw, ok
00:49:24 <soysauce> yeah
00:49:25 <Taral> so
00:49:31 <Taral> import MyProblemAlreadySolved (solution)
00:49:33 <Taral> main = solution
00:49:34 <soysauce> haha
00:49:35 <Taral> isn't allowed?
00:49:43 <soysauce> to be honest, I don't think he would really care
00:49:47 <Taral> LOL
00:50:03 <soysauce> but, being stubborn, independent, and inquisitive, I've set out to implement this m'self
00:50:10 <Taral> ok
00:50:13 <Taral> anyway, nini all
00:50:34 <soysauce> Floyd-Warshall's algorithm is actually cheaper than Dijkstra's, BTW
00:50:37 <soysauce> g'night
00:52:44 <musasabi> Has anyone tried to hook up Djinn to the emacs Haskell mode?
00:56:42 <palomer> OMG
00:56:45 <palomer> I finished my assignment
00:56:48 <soysauce> helo
00:56:48 <palomer> holy crap that took a long time
01:02:52 <soysauce> @type uncurry (<=)
01:02:53 <lambdabot> forall b. (Ord b) => (b, b) -> Bool
01:02:57 <soysauce> @pl \(x, y) -> x <= y
01:02:58 <lambdabot> uncurry (<=)
01:03:00 <soysauce> hah
01:03:02 <Lemmih> @seen ncalexan
01:03:03 <lambdabot> I saw ncalexan leaving #haskell 50 minutes and 14 seconds ago.
01:04:15 <soysauce> > sum [(0, 1), (2, 3)]
01:04:15 <lambdabot>  add an instance declaration for (Num (a, b))
01:04:15 <lambdabot>   In the definition of `wdx': wdx = sum [(0, 1), (2, 3)]
01:04:15 <lambdabot>   In the definition of `v':
01:04:53 <soysauce> @pl \((x1, y1), (x2, y2) -> (x1 + x2, y1 + y2)
01:04:54 <lambdabot> (line 1, column 22):
01:04:54 <lambdabot> unexpected "-"
01:04:54 <lambdabot> expecting operator, "," or ")"
01:04:59 <soysauce> @pl \((x1, y1), (x2, y2)) -> (x1 + x2, y1 + y2)
01:05:00 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+
01:05:00 <lambdabot> )) . flip . (((.) . (,)) .) . (+)))
01:05:05 <soysauce> ugly.
01:05:15 <Lemmih> @djinn (a -> c) -> (b,a) -> c
01:05:15 <lambdabot> x :: (a -> c) -> (b, a) -> c
01:05:15 <lambdabot> x x1 (_, v4) = x1 v4
01:09:11 <ski> @djinn id :: a -> a
01:09:12 <lambdabot> Cannot parse command
01:09:18 <ski> @djinn a -> a
01:09:19 <lambdabot> x :: a -> a
01:09:19 <lambdabot> x x1 = x1
01:09:55 <Lemmih> @djinn id ? a -> a
01:09:55 <lambdabot> Cannot parse command
01:10:28 <Lemmih> hm.
01:11:11 <dons> it's not exposing all of djinn yet. on its way...
01:13:39 <ski> @djinn ((o -> p) -> (o -> o) -> p) -> (o -> p) -> p
01:13:40 <lambdabot> x :: ((o -> p) -> (o -> o) -> p) -> (o -> p) -> p
01:13:40 <lambdabot> x x1 x2 = x1 (\ c14 -> x2 c14) (\ c10 -> c10)
01:16:35 <palomer> I so just got an A in my graphics class
01:19:14 <soysauce> 'grats
01:19:57 <musasabi> now if Djinn is teached about algebraic datatypes it will become a very very usefull tool ;)
01:20:19 <musasabi> (it supports either so it should not be impossible)
01:21:13 <ski> how about structural recursion ?
01:23:26 <dons> yep, I'm adding the interface now to teach it new types
01:23:38 <ski> sessions ?
01:27:33 <Gs30ng> can i ask a question about SKI combinators?
01:28:01 <mq_mattr> certainly, but who can answer such a question?
01:28:31 <Gs30ng> well it's simple
01:28:36 <ski> Gs30ng : just state the question
01:29:17 <Gs30ng> i wonder whether there is way to execute something repeatedly with SKI
01:29:17 <dons> you should ask ski
01:29:42 <ski> Gs30ng : loop/recursion ?
01:29:47 <Gs30ng> yeap
01:29:55 <ski> yes, the Y combinator
01:30:26 <ski> you know it ?
01:30:32 <Gs30ng> i mean only with SKI
01:30:40 <Gs30ng> without defining any extra function
01:30:41 <ski> it can be expressed with SKI
01:30:51 <Gs30ng> oh
01:31:16 <Gs30ng> i should look up wikipedia with Y combinator
01:31:34 <dons> \\f.U(\\g.f(U g)),  U == \\f. f f
01:31:54 <ski> any closed expression in pure lambda calculus can be expressed with SKI combinators
01:32:26 <Gs30ng> hmm thanks
01:32:29 <ski> U = S I I
01:45:34 <ski> Gs30ng : Y = S (K U) (S (S (K S) K) (K (S (K U) I))), if i'm not mistaken
01:46:11 <Gs30ng> S combinator is kinda brain-flushing
01:46:54 <ProfTeggy> Morning
01:47:04 <mq_mattr> evening
01:47:12 <ProfTeggy> Ah, combinatorial logic is on the plate.  The right time to join.
01:47:15 <tromp_> there's shorter ones
01:48:35 <ski> (.. typechecker agrees with me, anyway ..)
01:49:44 <ski> (tromp_ : ackerman ?)
01:50:15 <ski> (or just more optimised ?)
01:51:04 <tromp_> shorter Y in SKI
01:51:37 <ski> yes, but ..
02:18:36 <wilx> @djinn foo :: [[a]] -> [[[b]]]
02:18:36 <lambdabot> Cannot parse command
02:18:41 <soysauce> @pl \f (x, y) -> (f x, f y)
02:18:42 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:18:48 <soysauce> @pl \(x, y) f -> (f x, f y)
02:18:49 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
02:19:12 <wilx> @djinn f[[a]] -> [[[b]]]
02:19:12 <lambdabot> -- x cannot be realized.
02:19:14 <wilx> @djinn [[a]] -> [[[b]]]
02:19:15 <lambdabot> -- x cannot be realized.
02:19:21 <soysauce> won't work with arrays.
02:19:26 <wilx> Ah.
02:19:26 <soysauce> @djinn a -> [a]
02:19:26 <lambdabot> -- x cannot be realized.
02:19:31 <wilx> Interesting toy though :)
02:19:33 <soysauce> yeah
02:19:44 <soysauce> it doesn't work with Maybe, but it does work with Either
02:19:51 <soysauce> @djinn a -> b -> Either a b
02:19:51 <lambdabot> x :: a -> b -> Either a b
02:19:51 <lambdabot> x x1 _ = Left x1
02:19:57 <soysauce> though not necessarily brilliant code.
02:20:32 <soysauce> I think it always chooses Left unless there is no possible way to do that
02:22:02 <kosmikus> looks like it should be possible to program djinn as a Generic Haskell function
02:22:53 <Heffalump> what do datatypes list [] correspond to in propositional logic?
02:22:58 <Heffalump> s/list/like/
02:24:07 <ski> classical ?
02:24:28 <ski> @djinn (a -> o) -> (b -> o) -> (Either a b -> o)
02:24:28 <lambdabot> x :: (a -> o) -> (b -> o) -> Either a b -> o
02:24:28 <lambdabot> x x1 x2 x3 = case x3 of
02:24:28 <lambdabot>      Left l4 -> x1 l4
02:24:28 <lambdabot>      Right r5 -> x2 r5
02:24:40 <ski> @djinn Either a b -> Either b a
02:24:41 <lambdabot> x :: Either a b -> Either b a
02:24:41 <lambdabot> x x1 = case x1 of
02:24:41 <lambdabot>    Left l2 -> Right l2
02:24:41 <lambdabot>    Right r3 -> Left r3
02:25:04 <ski> @djinn (a,Either b c) -> Either (a,b) (a,c)
02:25:04 <lambdabot> x :: (a, Either b c) -> Either (a, b) (a, c)
02:25:04 <lambdabot> x (v2, v3) = case v3 of
02:25:04 <lambdabot>      Left l4 -> Left (v2, l4)
02:25:04 <lambdabot>      Right r5 -> Right (v2, r5)
02:25:14 <ski> @djinn Either (a,b) (a,c) -> (a,Either b c)
02:25:15 <lambdabot> x :: Either (a, b) (a, c) -> (a, Either b c)
02:25:15 <lambdabot> x x1 = case x1 of
02:25:15 <lambdabot>    Left l2 -> case l2 of
02:25:15 <lambdabot>         (v4, v5) -> (v4, Left v5)
02:25:15 <lambdabot>    Right r3 -> case r3 of
02:25:17 <lambdabot>         (v8, v9) -> (v8, Right v9)
02:26:45 <wilx> :)
02:26:50 <ski> @djinn () -> ((),())
02:26:51 <lambdabot> x :: () -> ((), ())
02:26:51 <lambdabot> x _ = ((), ())
02:27:03 <ski> not relevant
02:27:19 <ski> @djinn () -> ()
02:27:19 <lambdabot> x :: () -> ()
02:27:19 <lambdabot> x _ = ()
02:27:50 <ski> it should give as relevant answer as possible, methinks
02:30:23 <ski> @djinn (forall a. (forall o. (a -> o) -> o) -> a) -> ((a -> b) -> a) -> a
02:30:23 <lambdabot> -- x cannot be realized.
02:32:55 <ski> @djinn (forall a. a -> b) -> b -> a
02:32:56 <lambdabot> -- x cannot be realized.
02:33:01 <ski> @djinn (forall a b. a -> b) -> b -> a
02:33:02 <lambdabot> -- x cannot be realized.
02:33:08 <ski> bah
02:33:48 <ski> morning Buggaboo
02:34:06 <Buggaboo> morning ski
02:35:04 <ski> @djinn forall a. a -> a
02:35:05 <lambdabot> -- x cannot be realized.
02:35:30 <ski> @djinn (a -> b -> c) -> ((a -> b) -> (a -> c))
02:35:30 <lambdabot> x :: (a -> b -> c) -> (a -> b) -> a -> c
02:35:30 <lambdabot> x x1 x2 x3 = x1 x3 (x2 x3)
02:36:14 <Saulzar> What is it doing? Finds any function body from the types given?
02:37:49 <tibbe> anyone have experience in writing an interpreter for an imperative language that allows saving of continuations (think setjmp(), jmp())?
02:38:14 <Buggaboo> how's life ski?
02:38:34 <wilx> The Pugs guys in #perl6?
02:39:13 <ski> Saulzar : yes, more or less
02:39:48 <ski> (Buggaboo : trying to author a post ..)
02:40:57 <Buggaboo> post on what?
02:41:22 <ski> LtU
02:41:30 <Buggaboo> ...?
02:41:47 <ski> (Lambda the Ultimate)
02:42:52 <ski> (re monads ..)
02:46:54 <Buggaboo> hm, I'll read the thing when you're done.
02:47:06 <Buggaboo> I don't know much about gonads.
02:47:09 <Buggaboo> monads even.
02:49:38 <tibbe> how could one, in principle, save a continuation monad to execute it later?
02:49:44 <tibbe> using a State for example?
02:50:28 <ski> (monads aren't executed, monadic actions are executed)
02:50:55 <ADEpt> tibbe: but you could use continuation as a state and save it in Statel.
02:58:26 <tibbe> ADEpt, how would I get hold of the continuation so to speak
02:58:45 <ski> callCC ?
02:59:15 <tibbe> dunno, what would be the type of what I'm saving, Cont _ _ something?
02:59:35 <ADEpt> tibbe: you could save value of type (a -> b), for example
02:59:50 <tibbe> lets say I would like to put it into a tupple together with and identifier, like (String, ContSomething)
02:59:57 <ski> @index callCC
02:59:57 <lambdabot> Control.Monad.Cont
03:00:04 <ski> @type Control.Monad.Cont.callCC
03:00:05 <lambdabot> forall (m :: * -> *) a b.
03:00:05 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
03:00:05 <lambdabot> ((a -> m b) -> m a) -> m a
03:00:56 <tibbe> how can I get the current continuation within say a do contruct?
03:00:57 <ski> @kind Control.Monad.Cont.Cont
03:00:58 <lambdabot> * -> * -> *
03:01:12 <ski> callCC $ \k -> do ...
03:01:29 <tibbe> and then save k right?
03:01:35 <ski> yeah
03:01:51 <tibbe> and if I later called k callCC would return with that value?
03:02:00 <ski> yep
03:02:03 <tibbe> thanks
03:02:18 <ski> you might want to preserve polymorphism, though
03:02:24 <tibbe> ?
03:02:29 <ski> depends on what you want to do with k
03:02:54 <ski> k :: forall b. a -> Cont o b
03:03:01 <tibbe> actually I want k to be the statement I'm currently evaluating so I can later jump back to that point again
03:03:35 <tibbe> something like a goto
03:03:42 <ski> an interpreter ?
03:03:51 <tibbe> yeah
03:04:08 <ski> then you could possibly fix 'b', with no harm
03:04:08 <tibbe> I've already have a state monad that I can use to save stuff
03:04:23 <tibbe> yeah
03:04:31 <ski> what is 'a' ? '()' ?
03:04:38 <tibbe> evaluating a statement returns nothing so a () would do right
03:04:43 <ski> m
03:05:38 <tibbe> I've already have a data typ for values (of variables), like: data Value = VInt Int | VStr String | Cont ? ? ?
03:06:04 <tibbe> do I need to add some type variables to the Value type? that would really mess upp other parts of the code
03:06:28 <ski> probably not needed
03:06:42 <ski> are you allowing continuations as values ?
03:07:26 <tibbe> no, but I want to save them in variables
03:07:34 <tibbe> to use the values as jump locations later
03:07:56 <ski> ordinary variables ?
03:08:13 <ski> or a special 'label' syntactic class ?
03:08:33 <tibbe> well, I thought it could be handy to use the already existing variable functionality to save the jump "locations"
03:09:09 <reddi> hi short question
03:09:13 <tibbe> I need to change location, back in 15min, thanks for the help
03:09:21 <reddi> i have made by myself a substring function in haskell
03:09:28 <reddi> so far so good
03:09:57 <reddi> i pass the function the string and 2 parameters and it cuts the BETWEEN
03:10:07 <reddi> Main> pm_ss("[TextOder]Text",1,9)
03:10:08 <reddi> "[]Text"    
03:10:24 <reddi> so i thought i could use (\\) to get the outside
03:10:58 <reddi> Main> (\\) "[TextOder]Text" "[]Text"
03:10:59 <reddi> "OderText" 
03:11:21 <ski> > "[TextOder]Text" \\ "[]Text"
03:11:22 <lambdabot> "OderText"
03:11:47 <reddi> TextOder
03:11:53 <reddi> this is what i want ;-)
03:11:56 <ski> (lennart : how about making djinn return more relevant answers ?)
03:12:06 <reddi> i think i cannot use my function
03:12:18 <ski> hm
03:12:25 <lennart> ski, yes.  but as it stands it only generates a few of them.
03:12:48 <lennart> and aving djinn generate all is impossible, since there might be infinitely many
03:12:50 <Gs30ng_> is there anything like python str.split function in prelude? i can't find one in my prelude guide
03:12:53 <Oejet> reddi: How did you implement pm_ss?
03:12:55 <ski> (lennart : 'few' ?)
03:13:17 <reddi> pm_ss :: (String,Int,Int) -> String
03:13:17 <reddi> pm_ss (text,min, max) = take min text ++ drop max text
03:13:18 <lennart> yes, few :)
03:13:21 <Oejet> @type break
03:13:22 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:13:50 <reddi> i would like to have an function which makes the opposite from pm_ss
03:13:57 <lennart> ski, it's on my TODO list
03:14:00 <ski> which gives the inside ?
03:14:10 <reddi> and this is probably not possible if it is the "wrong" string
03:14:29 <reddi> sometimes it works like i want ( --> (\\) )
03:14:30 * ski 'd prolly like affine answers, when possible, too
03:14:41 <Oejet> reddi: How about first dropping the initial part of the string and then the end part?
03:15:02 <Gs30ng_> for example, "abc!abc!abc".split("!") returns ["abc", "abc", "abc"]
03:15:16 <ski> s/affine/nonaffine/
03:15:35 <reddi> hm what if there are more than 2 !?
03:15:54 <lennart> I have some ideas on how to order the answers.
03:16:09 <ski> > "abcba" \\ "bca"
03:16:10 <lambdabot> "ba"
03:16:22 <reddi> Oejet: i think that it will work than only sometimes too ;-(
03:17:10 <ski> reddi : i think (\\) is for (multi-)sets as lists
03:17:14 <reddi> is there no easy way to get the value BETWEEN the indexes i pass a function
03:18:16 <Oejet> > let l = drop 3 [1,2,3,4,5,6] in take 2 l
03:18:17 <lambdabot> [4,5]
03:18:17 <ski> > take (9-1) .drop 1 $ "[TextOder]Text"
03:18:18 <lambdabot> "TextOder"
03:18:47 <reddi> hm.... 
03:19:08 <reddi> this could work ;)
03:19:14 <Oejet> reddi: You are close now. :-)
03:19:46 <reddi> ski: can u shortly explain what the $ and the second 1 meansﬂ
03:19:50 <reddi> . means function composition
03:20:24 <ski> take (9-1) . drop 1 $ "[TextOder]Text"  =  (take (9-1) . drop 1) $ "[TextOder]Text"  =  (take (9-1) . drop 1) "[TextOder]Text"  =  take (9-1) (drop 1 "[TextOder]Text")
03:20:36 <ski> f $ x = f x
03:20:43 <ski> (f . g) x = f (g x)
03:21:30 <Oejet> > let pm_ss s i1 i2 = take (i2-i1) . drop i1 in pm_ss "[TextOder]Text" 1 9
03:21:31 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
03:21:53 <Oejet> Hm.
03:22:09 <ski> 's' is unused
03:22:28 <Oejet> > let pm_ss s i1 i2 = (take (i2-i1) . drop i1) s in pm_ss "[TextOder]Text" 1 9
03:22:29 <lambdabot> "TextOder"
03:22:29 <ski> (i.e not relevant function)
03:22:49 <reddi> i would not get THAT by myself
03:22:52 <reddi> lol thx
03:22:55 <Oejet> ski: Aha, thanks.
03:23:04 <reddi> i thought my solution would work with the (\\)
03:23:13 <reddi> but then my example was tested
03:23:21 <reddi> and now i know: IT DOES NOT WORK ALWAYS ;-)
03:23:37 <Pupeno> Hello.
03:23:59 <Oejet> reddi: \\ is a set operator, you are dealing with strings, not sets.  But I guess you realized that now.
03:24:09 <Oejet> Pupeno: Hello.
03:24:21 <ski> @remember reddi and now i know: IT DOES NOT WORK ALWAYS ;-)
03:24:43 <reddi> i realized it ;-)
03:25:57 <soysauce> @type sequence
03:25:57 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:26:15 <soysauce> @hoogle [m a] -> m a
03:26:16 <lambdabot> Data.List.head :: [a] -> a
03:26:16 <lambdabot> Data.List.last :: [a] -> a
03:26:16 <lambdabot> Prelude.head :: [a] -> a
03:26:31 <soysauce> @type foldl1 (>>)
03:26:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
03:27:03 <ski> @type liftM head . sequence
03:27:04 <lambdabot> Not in scope: `liftM'
03:27:07 <kosmikus> @type Control.Monad.msum
03:27:07 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [m a] -> m
03:27:07 <lambdabot> a
03:27:12 <ski> @type Control.Monad.liftM head . sequence
03:27:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
03:30:54 <Pupeno> What facilities are there to program web sites using Haskell ? What do you recommend ?
03:32:55 <soysauce> @type \ks -> fw' a' ks [(i, j) | i <- ks, j <- ks]
03:32:56 <lambdabot> Not in scope: `fw''
03:32:56 <lambdabot>  
03:32:56 <lambdabot> <interactive>:1:11: Not in scope: `a''
03:33:00 <soysauce> er, hm.
03:33:12 <soysauce> @type \ks -> ks [(i, j) | i <- ks, j <- ks]
03:33:13 <lambdabot>   Couldn't match `[a] -> t' against `[a1]'
03:33:13 <lambdabot>   Expected type: [a] -> t
03:33:20 <ski> @type \ms a -> Control.Monad.foldM (\a -> Control.Monad.liftM ($ a)) a ms
03:33:21 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m (b -> b)] -> b -> m b
03:33:23 <soysauce> @type \ks -> (ks, [(i, j) | i <- ks, j <- ks])
03:33:24 <lambdabot> forall a. [a] -> ([a], [(a, a)])
03:33:56 <soysauce> @type map (\ks -> (ks, [(i, j) | i <- ks, j <- ks]))
03:33:57 <lambdabot> forall a. [[a]] -> [([a], [(a, a)])]
03:36:57 <ski> (Pupeno : has heard of wash .. hasn't used it, though)
03:40:23 <dcoutts> @djinn (a -> b) -> [a] -> [b]
03:40:24 <lambdabot> -- x cannot be realized.
03:40:55 <ski> @djinn [a]
03:40:55 <lambdabot> -- x cannot be realized.
03:40:56 <dcoutts> I suppose lists have too much structure
03:41:06 <ski> not done yet, in any case
03:41:26 <ski> just functions,pairs,Either, yet, from what i understand
03:41:48 <ski> @djinn (x1,x2,x3) -> x1
03:41:49 <lambdabot> x :: (x1, x2, x3) -> x1
03:41:49 <lambdabot> x (v2, _, _) = v2
03:41:53 <ski> ok, tuples
03:42:20 <dcoutts> btw, dons that was quick work! 1 hour 20 min from the release announcement!
03:42:40 <kosmikus> @djinn (a -> a) -> a
03:42:40 <lambdabot> -- x cannot be realized.
03:43:12 <ski> @type \x -> case x of { }
03:43:13 <lambdabot> parse error on input `}'
03:43:46 <ski> @djinn (forall a. a) -> b
03:43:46 <lambdabot> -- x cannot be realized.
03:47:49 <dons> dcoutts , lennart caught me with my morning coffee. all work gets done after coffee :)
03:49:05 <dcoutts> heh heh
03:51:24 <lennart> dons, you should get the latest version of djinn.  it properly rejects when people write foralls
03:51:33 <lennart> rejects it as a syntax error
03:51:38 <dons> @djinn a -> b -> ()
03:51:39 <lambdabot> x :: a -> b -> ()
03:51:39 <lambdabot> x _ _ = ()
03:53:11 <dons> lennart, ok. cool.
03:53:29 <dons> i'm also going to finish the interface so that it keeps track of the djinn environment properly
03:54:26 <dons> huh, `ping' just said: wrong data byte #32 should be 0x18 but was 0x7e
03:54:31 <dons> that's a bit weird.
04:01:53 <twb> dons: aren't you in NSW?
04:02:48 <dons> yep.
04:02:50 <Stinger> whois says so
04:02:57 <twb> Funny time of morning.
04:03:21 <dons> ? dcoutts was referring to sometime around 14 hrs ago
04:03:27 <twb> Oh.
04:03:53 <dons> in fact, to exaactly: Mon Dec 12 10:28:37 EST 2005  dons@cse.unsw.edu.au
04:03:58 <dcoutts> heh heh
04:04:02 <dons>   * A plugin for Lennart's Djinn program
04:04:08 <dons> :)
04:06:45 <prionic> hello, i forgot the url to the FilePath darcs repository, can someone help me?
04:06:56 <enlived> hello
04:07:13 <rgrig> @darcs FilePath
04:07:13 <lambdabot> FilePath not available
04:07:19 <twb> prionic: cat _darcs/prefs/repos
04:08:02 <enlived> anyone can tell me how i can make winhugs produce output instead of a blank line after running a program?
04:08:10 <Lemmih> prionic: http://scannedinavian.org/~lemmih/FilePath
04:08:42 <twb> enlived: with wishes and dreams.
04:08:57 <twb> enlived: and the "print" procedure.
04:09:32 <enlived> good
04:09:35 <enlived> no violence then?
04:09:54 <twb> Violence can be arranged.
04:10:44 <twb> Try to remap the caps lock key and you'll soon become violent.
04:10:58 <dons> oh, it's not that hard ;)
04:11:06 <twb> dons: he's using windows
04:11:13 <Gs30ng_> set is a group of elements where the order is meaningless
04:11:16 <dons> oh ok. violence is fine then.
04:11:23 <Gs30ng_> can i implement this in haskell?
04:11:23 * enlived is confused
04:11:32 <dons> in fact, violence might be the only way.
04:11:34 <twb> Gs30ng_: {1,2,3,4}
04:11:40 <Gs30ng_> oops
04:11:44 <Gs30ng_> already exists
04:11:47 <twb> Oops, that doesn't work.
04:11:57 <dons> @docs Data.Set
04:11:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
04:13:19 <pengo> codata, comonad, coalgebra, co-variety, cofree, codomain, co-extension
04:13:21 <dons> > S.singleton 'x'
04:13:22 <lambdabot> {'x'}
04:13:52 <dons> > S.fromList [1,2,3,4]
04:13:53 <lambdabot> {1,2,3,4}
04:14:08 <twb> > it
04:14:08 <lambdabot>  Not in scope: `it'
04:14:14 <twb> Hmm.
04:14:15 <dons> ;)
04:14:18 <dons> as if.
04:14:36 <dons> twb, what you trying to do?
04:15:04 <twb> Heh.  In SLIME, you can refer to any value ever evaluated at the toplevel.
04:15:13 <dons> you want the last computation, like ghci?
04:15:16 <dons> ah, in ghci too
04:15:40 <gus> Anyone here that knows anything about the "jump island"-bug in ghc 6.4 for ppc?
04:15:48 <dons> psi does.
04:15:52 <dons> I think he fixed it (?)
04:15:58 <dons> at least ghci now works.
04:16:23 <dons> or SamB fixed it, and psi confirmed the fix. something like that.
04:16:58 <dons> @seen phys_rules
04:16:59 <lambdabot> I saw phys_rules leaving #haskell-blah and #haskell 8 days, 11 hours, 38
04:16:59 <lambdabot> minutes and 17 seconds ago, and I have missed 3 days, 6 hours, 56 minutes
04:16:59 <lambdabot> and 29 seconds since then.
04:17:12 <dons> bah, he reported a bug. I think I fixed it, then phys_rules disappears
04:18:32 <dons> @where+ ranged-sets https://sourceforge.net/projects/ranged-sets/
04:18:32 <lambdabot> ranged-sets ~> https://sourceforge.net/projects/ranged-sets/
04:19:26 <twb> sourceforge.net can be abbreviated to sf.net, y'know.
04:20:14 <dons> just taking it from the announce msg. who am i to mangle his url
04:20:30 <twb> You're dons.
04:20:41 <twb> I thought that was obvious.
04:20:54 <dons> oh, true . hmm. i need to remember my name tag.
04:21:07 <twb> Quite right, Bruce.
04:21:21 <dons> right.
04:38:24 <musasabi> I should have specified on Haskell-cafe "I know it is wrong, but I still want to do it"
04:39:10 <dcoutts> musasabi, heh yeah
04:39:29 <dcoutts> well your unlock file hack should work with ghc
04:39:40 <dcoutts> otherwise use the lower level IO functions
04:43:01 <musasabi> dcoutts: except the code has to work on win32 too.
04:43:32 * musasabi does not remember which bits are available there
04:44:28 <musasabi> GHC.Handle.openFd and System.Posix.IO.openFd being entirely different functions can be confusing.
04:44:44 <prionic> lemmih: thanks!
04:45:01 <eivuokko> Uhm, you need multiple handles to one file in Windows?
04:47:07 <dcoutts> musasabi, yeah, that's going to be tricky.
04:47:54 <musasabi> My current understanding is 1) openFile uses GHC.Handle.openFd, 2) GHC.Handle.openFd locks, 3) System.Posix.IO.openFd does not lock, 4) fdToHandle locks the file.
04:48:35 <musasabi> the last one makes the System.Posix story to not help at all
04:49:17 <dcoutts> musasabi, unless you use System.Posix for the reading too
04:49:25 <dcoutts> reading + writing
04:50:34 <musasabi> dcoutts: except I am using binary IO with Ptrs, which is only supported for Handles
04:51:27 <dcoutts> musasabi, yeah, you look stuck :-(
04:52:00 * dcoutts would have thoguht that System.Posix.IO would support the lower level read/write forms
04:52:15 <musasabi> no, and it is quite evil
04:52:38 * musasabi thinks the standard libs should have a low level IO interface without all the intelligence
04:53:45 <musasabi> (and on top of that the intelligent Handles for easy IO tasks)
05:00:11 <benny> does haskell have a function: f x = 1.0 / x
05:00:28 <tromp_> it's called (1.0 /)
05:00:45 <benny> does it have a name?
05:01:27 <voickas> benny:recip
05:02:00 <benny> THANKS
05:03:47 <benny> what about: f x = 1.0 / (sqrt x)
05:05:39 <tromp_> recip.sqrt
05:06:09 <benny> yeah, but again, does it have a name? :)
05:06:16 <tromp_> no
05:07:19 <tromp_> see http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Prelude.html
05:09:19 <ski> > let recip_sqrt = (** (-0.5)) in recip_sqrt 16
05:09:20 <lambdabot> 0.25
05:10:02 <joelr1> good morning
05:10:15 <tromp_> g'afternoon:)
05:10:39 * joelr1 finally freed up to update his blog and recount the haskell travails
05:10:41 <joelr1> :D
05:10:55 <ski> > let recip_sqrt = flip (**) . negate . recip $ 2 in recip_sqrt 16
05:10:56 <lambdabot> 0.25
05:13:58 <ski> pengo : ?
05:16:25 * Pupeno hates packages that modify files.
05:26:39 <pengo> hi ski
05:27:33 <benny> @seen dcoutts 
05:27:33 <lambdabot> dcoutts is in #haskell, #haskell-blah, #haskell-overflow and #gentoo-
05:27:33 <lambdabot> haskell. Last spoke 19 minutes and 34 seconds ago.
05:27:52 <dcoutts> @yarr!
05:27:52 <lambdabot> Aye Aye Cap'n
05:27:57 <dcoutts> hia benny 
05:28:11 <benny> hey... are you the "Administrator" guy in the gtk2hs website/blog ?
05:28:22 <ski> (pengo : why the dual-words ?)
05:29:25 <dcoutts> benny, sometimes. Axel seems to stay logged in as the admin user. I usually use my own user account. But I do have admin access.
05:29:49 <pengo> ski, i found them amusing and i encourage anyone nerdy enough to develop a drinking game around them when reading "Codata and Comonads in Haskell"
05:30:05 <dcoutts> benny, why?
05:30:48 <ski> pengo : 'drinking game' ?
05:31:10 <benny> dcoutts: no reason i guess.... his website is "http://"
05:31:17 <pengo> ski, have a shot every time you read a coword. including 'coercion' and 'coexist'
05:31:27 <benny> dcoutts: did you say, "Alas, we haven't done the animation functions in Pixbuf yet. Tell us if you want them!" ?
05:31:31 <ski> 'code'
05:31:32 <resiak> pengo++ # sounds good
05:32:05 <wilx> Hmm, sombody should make a Comonads tutorial similar to existing Monads tutorial.
05:32:20 <ski> cohen,conan,cobolt
05:32:53 <dcoutts> benny, that as Axel.
05:32:56 <dcoutts> as/was
05:33:03 <benny> k
05:33:11 <pengo> someone shold write wikipedia pages for codata, co-variety, cofree, and co-extension
05:33:30 <musasabi> mmh comadic codrinking?
05:34:04 * ski calls 'coextend' 'preserve'
05:34:25 <pengo> conserve?
05:35:21 <musasabi> hmm evil. handleToFd closes the handle.
05:35:38 <ski> mayhaps
05:36:13 <musasabi> is there a "unsafePleaseJustGiveMeTheFD :: Handle -> FD" ?
05:37:46 * Oejet would also like unsafePleaseJustGiveMeTheFD.
05:38:12 <Heffalump> I think it does exist and isn't even unsafe.
05:38:18 <Heffalump> oh, sorry.
05:38:23 * Heffalump reads up two more lines
05:38:28 <Heffalump> yeah, really annoying that.
05:42:20 * musasabi writes a summary of that to haskell-cafe
05:56:09 <Saulzar> Wohoo, darcs gtk2hs compiled :)
05:56:21 <rgrig> what is ffee?
05:56:36 <rgrig> i guess it is the dual of coffee... :)
05:57:10 <rgrig> (sorry for the bad joke - i just saw people talking about many co-things)
05:57:59 <ski> ca la
05:58:37 <Saulzar> I found it amusing
06:09:09 <shapr> Wow, Alex Martelli posted to ghc-bugs.
06:10:05 <shapr> Spiffy
06:12:48 <musasabi> the Python person?
06:12:54 <tic|school> yeah.
06:13:00 <tic|school> he's becoming a convert? :(
06:13:18 <shapr> tic|school: What's bad about learning new stuff?
06:13:28 <musasabi> tic|school: if we convert the people writing Python libraries to Haskell we can solve many problems
06:14:05 <shapr> I like to think "What we have now is nothing like what we will have in one hundred years. I want to steal the future and bring it here now."
06:14:48 <tic|school> shapr, everything! :)
06:14:54 * shapr grins
06:15:04 <shapr> Hey, did you ever see the point of arrows as I described it?
06:15:06 <tic|school> shapr, j/k. I guess it's nice, if he can time-share between doing Python and Haskell stuff.
06:15:10 <tic|school> shapr, me?
06:15:11 <ValarQ> musasabi: that would be neat :)
06:15:29 <ValarQ> musasabi: start with the twisted and divmod people ;)
06:15:36 <tic|school> *fak*
06:15:39 <tic|school> err, afk.
06:15:48 <shapr> tic|school: yes you
06:15:58 <shapr> Anybody who wants to learn...
06:16:09 <tic|school> shapr, no, I didn't see your description.
06:16:15 <tic|school> I'll nag you about it later.
06:16:24 <tic|school> school stuff  now. :)
06:16:26 <shapr> In short, arrows can be compared to each other, letting you shortcut lots of stuff.
06:16:27 <shapr> Ok
06:18:32 * shapr has to check to remember if this is freenode or opn.
06:18:47 <Heffalump> it's freenode, the opn name disappeared ages ago.
06:19:00 <shapr> Yeah, looking at the server buffer showed me that, but I still forget.
06:19:02 <Heffalump> I just think of it as OPN cos I'm slow and cos I think the name change is a joke.
06:19:25 <shapr> OPN was a nice name.
06:19:27 <Heffalump> did you read the HW paper on biarrows, btw? That was quite cool.
06:19:30 <Heffalump> (biab)
06:19:47 <shapr> I read about biarrows for comonads, is that the one?
06:19:56 <shapr> Hiya bracx, learning Haskell?
06:20:09 <Pupeno> Does QuickCheck obsoletes HUnit ?
06:20:46 <shapr> Not at the moment. It could though.
06:20:56 <Pupeno> shapr: is that for me ?
06:21:14 <shapr> In the meantime http://www.haskell.org/tmrwiki/SoftwareTestingWithHaskell
06:21:24 <musasabi> I think the HWN paper didn't talk about comonads
06:21:38 <Pupeno> shapr: thanks.
06:21:39 <musasabi> it had some generic haskell stuff in it
06:21:53 <bracx> shapr yes, just starting though
06:21:57 <musasabi> s/HWN/HW/
06:22:34 <shapr> musasabi: cool, I'll look it up.
06:22:45 <xerox> hi.
06:22:48 <shapr> bracx: Welcome to the world of big ideas and small code! Would you like the short tour?
06:22:55 * musasabi only has the paper version
06:23:15 <shapr> I hope there's an online version.
06:23:18 <jlouis> musasabi: comonads seems fun
06:23:39 <musasabi> it is fun
06:23:41 <bracx> shapr: Where's the short tour.
06:24:01 <musasabi> jlouis: combining comonads and GADTs makes for very spiffy things
06:24:12 <shapr> You just have to say, "shapr, give me the tour!" and away we'll go.
06:24:29 <jlouis> musasabi: heh, your research project at the moment?
06:24:50 <shapr> Sometimes I think musasabi is researching everything in the Haskell world at once :-)
06:25:14 <musasabi> jlouis: I wish, work + sleeplesness => no thinking about complex things, just mindless zombie-haskell
06:25:17 <bracx> shapr, give me the tour!
06:25:23 <jlouis> each
06:25:27 <jlouis> musasabi: what do you work with?
06:25:31 <shapr> bracx: OK! I'll be your tour guide today, on this shout tour of #haskell and Haskell.
06:25:54 <shapr> First off we have lambdabot, everybody's favorite fun toy.
06:26:18 <shapr> It has useful tools for examining, finding, and executing Haskell source.
06:26:22 <shapr> @where conjure
06:26:22 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
06:26:26 <musasabi> jlouis: programming. It is quite fun, except the lack of sleep is starting to affect me.
06:26:28 <shapr> @type 1 + 1
06:26:29 <lambdabot> forall a. (Num a) => a
06:26:38 <shapr> > 1 + 1 + 1
06:26:39 <lambdabot> 3
06:27:22 <shapr> Next we have the channel topic which includes urls to interesting places, including the channel logs, the wiki, and the communities and activities report.
06:27:53 <shapr> @wiki HaskellNewbie is a good place to start on the Haskell wiki.
06:27:53 <lambdabot> http://www.haskell.org/hawiki/HaskellNewbie is a good place to start on the Haskell wiki.
06:28:06 <xerox> Milli-olegs, eh.
06:28:08 <shapr> @learn Last but not least, the "Learning Haskell" page on haskell.org is really handy.
06:28:09 <lambdabot> http://www.haskell.org/learning.html
06:28:47 <shapr> @wiki HaskellDemo if you want to see a short syntax demo for Haskell, this is a good place to start.
06:28:48 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo if you want to see a short syntax demo for Haskell, this is a good place to start.
06:29:18 <shapr> bracx: That concludes your short tour of #haskell and Haskell, if you have any questions, feel free to ask me or someone else on the hcannel.
06:29:53 <benny> how can i make a unicode string?
06:30:02 <bracx> shapr: thanks for the tour. I'll check those links out
06:30:26 <shapr> bracx: Do you have any questions right now?
06:31:21 <Heffalump> shapr: biarrows for reversible computation or something like that
06:31:39 <xerox> Heffalump: a-la prolog?
06:31:55 <Heffalump> http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
06:32:07 <dcoutts> musasabi, re: your cabal patch to hide modules from haddock; instead of munging the .hs files you can pass a command line flag to haddock (as of haddock 0.7) to specify which files to hide. This might be a nicer solution.
06:32:23 <Heffalump> oh, they didn't put their paper online, that sucks
06:32:29 <xerox> Generic Haskell?
06:32:42 <shapr> Oh yeah, I haven't read this paper because it's not available.
06:32:45 <Heffalump> I don't think GH usage was essential, but I forget.
06:32:57 <bracx> shapr: no questions at the moment, may have some as I work through the tutorials
06:33:15 <shapr> bracx: Ok, have fun, and feel free to ask questions.
06:33:50 <benny_> How can I make a unicode string?
06:34:21 <shapr> Oh hey, I remember what I was going to write in my blog now, how Elsevier/Springer-Verlag/ACM/etc remind me of microsoft in the ODF debate.
06:35:01 <musasabi> dcoutts: yes, I know.
06:35:09 <Cale> bracx: I recommend "Yet Another Haskell Tutorial" usually -- it's unfinished, but it's a pretty decent tutorial
06:35:14 <musasabi> dcoutts: the patch is older than haddock version 0.7
06:35:18 <Cale> @google Yet Another Haskell Tutorial pdf
06:35:19 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
06:36:09 <bracx> Cale: thanks
06:36:34 <dcoutts> musasabi, oh I see, reading the patches again I see that was the solution used in the end. Sorry to bother you. :-)
06:36:50 <Pupeno> Why are libraries like HUnit and QuickCheck copied to GHC ? which should I use, mainstream or GHC's ?
06:37:28 <ADEpt> @seen jlouis
06:37:28 <lambdabot> jlouis is in #haskell and #haskell-blah. Last spoke 12 minutes and 1
06:37:28 <lambdabot> second ago.
06:37:31 <musasabi> np
06:38:00 <Saulzar> Pupeno, I guess it's somewhat easier if there is one package containing most commonly used libs
06:38:26 <ADEpt> jlouis: are you there? I have troubles pulling from your repo ... "darcs: failed to read patch in get_extra: ..." Ever seen this?
06:38:39 <Pupeno> Saulzar: from my perspective, it's messier, but ok, which ones should I use ?
06:38:54 <Saulzar> Pupeno, May as well use the GHC ones unless you need a specific version
06:40:46 <musasabi> btw Krasimir Angelow contributed changes to SerTH which make cycle detection optional and make it much faster (a wide array of optimizations)
06:42:47 <shapr> Pupeno: Usually the GHC versions are the latest. GHC started including lots of libraries before Cabal was designed. 
06:43:06 <shapr> Once cabal works smoothly, I think GHC won't include all the libs.
06:43:24 <Pupeno> shapr: that'd be nice.
06:43:56 <Pupeno> so, cabal is like going to be the de-facto way to build Haskell libraries and programs ?
06:44:04 <musasabi> yes
06:45:50 <Pupeno> Importing Test.HUnit didn't work, I got: Could not find module `Test.HUnit'..., but importing Test.QuickCheck did work. Any idea ?
06:47:17 <shapr> What version of GHC?
06:47:32 <benny> dcoutts: you know all about the cairo bindings?
06:47:40 <dcoutts> benny, yes
06:48:00 <benny> dcoutts: wouldn't it be cool if textExtents function were pure?
06:48:24 <shapr> Speaking of HUnit, is there some way to tell it to expect failure? I'm using ,(CE.catch (remote un1 "authping" :: IO String) (\_ -> return "failed")) ~>= "failed" but it seems like HUnit should have some way to expect failure directly.
06:48:36 <dcoutts> benny, hmm. It depends on the current font settings.
06:48:49 <benny> dcoutts: supply those as a parameter
06:48:54 <dcoutts> it needs the Cairo context as a parameter
06:49:39 <dcoutts> the Render monad is precisely the Cairo context
06:50:02 <benny> yeah, but the context isn't really required. maybe an additional pure utility function could be created
06:50:07 <dcoutts> so it'd either be fontExtents :: Render FontExtents or :: RenderContext -> FontExtents
06:50:09 <Pupeno> shapr: 6.4.0 I believe.
06:50:22 <dcoutts> benny, no, the context really is required
06:50:36 <dcoutts> since it tells you what font and scaling is in use at the moment
06:50:53 <dcoutts> and various other settings
06:51:01 <benny> ok, so a pure utility function could take as parameters all these settings :)
06:51:25 <dcoutts> but then you'd need functions to get all these parameters
06:51:35 <dcoutts> and they would all need to work in the Render monad :-)
06:51:48 <dcoutts> so that'd make it several times harder to use! :-)
06:51:57 <benny> not if you know what settings are going to be used
06:52:25 <dcoutts> and it depends on the font backen in use
06:52:36 <dcoutts> which varies from one context to another
06:52:44 <dcoutts> eg FT2 or Pango or win32
06:52:53 <benny> hm.... i guess that would be a problem
06:53:14 <dcoutts> and is not sometihing that one is supposed to know, it's hidden behinf the cairo context abstraction
06:53:33 <shapr> Pupeno: I know Test.HUnit works for me in 6.4.1. It might have been different in 6.4.0 ?
06:54:04 <Pupeno> shapr: I don't know, the interfaces and .o are there.
06:54:53 <shapr> In that case, something's wrong :-)
06:54:59 * shapr is master of the obvious!
06:56:20 <musasabi> maybe you need -package HUnit or somesuch
07:00:36 * shapr hops
07:01:11 * ValarQ skips and jumps
07:02:44 * xerox codes
07:03:11 * Oejet hangs the FreeBSD boot ISO.
07:03:13 * shapr tests
07:03:42 <shapr> Hm, I bet I can partially apply catch to build a shorter test of expected exception.
07:05:11 * shapr has fun refactoring his unit tests.
07:05:42 * musasabi notes that bugs in unit tests seem more common than bugs in code
07:06:09 <shapr> I like it: expectfailure = flip CE.catch (\_ -> return "failednicely")
07:06:28 <Pupeno> The Network module is only TCP, right ? for UDP I should use Network.Socket ?
07:07:09 <musasabi> Pupeno: yes, Handles make little sense with datagrams usually
07:07:49 <Pupeno> Isn't there another high-level API, like Network, but for UDP ? (not using handles)
07:08:51 <musasabi> network-alt has some such stuff
07:10:02 <Pupeno> Thanks.
07:10:26 <[COTL]Godofe_Kei> Sup everyone?
07:10:28 <shapr> musasabi: Test driven development seems likely to catch more bugs in unit tests.
07:10:32 <shapr> ceilings.
07:10:40 <shapr> Ceilings are definitely up.
07:11:25 <[COTL]Godofe_Kei> can anyone tell me how to apply one whole list to another whole list?
07:11:37 <musasabi> shapr: I agree they are usefull, one just usually consentrates more on the actual code, which makes unitest errors too common. (Of course it would help if one would first debug the unit test not the code which looks like failing)
07:11:58 <Saulzar> What do you mean apply? map ?
07:12:02 <[COTL]Godofe_Kei> hmm
07:12:45 <[COTL]Godofe_Kei> i can apply the first element of the first list to the other list
07:12:45 <shapr> > zipWith ($) [(+1),(+2)] [2,3]
07:12:46 <lambdabot> [3,5]
07:13:02 <[COTL]Godofe_Kei> i dont think that helps
07:13:12 <[COTL]Godofe_Kei> for example
07:13:15 <[COTL]Godofe_Kei> you have:
07:13:35 <[COTL]Godofe_Kei> [1,2,3,4,5] and [7,5,7,8,1,6,3]
07:13:49 <[COTL]Godofe_Kei> i can check if 1 exixts on the other list
07:13:55 <[COTL]Godofe_Kei> but how do i test 2?
07:13:58 <shapr> musasabi: I try to make my unit tests simple enough that any bugs would be obvious.
07:14:11 <ADEpt> [COTL]Godofe_Kei: first, it is not called "apply" :)
07:14:20 <Cale> apply?
07:14:27 <[COTL]Godofe_Kei> ok, wrong term
07:14:50 <ADEpt> [COTL]Godofe_Kei: let first_list=...; second_list=... in map (check_in_list second_list) first_list
07:15:13 <ADEpt> [COTL]Godofe_Kei: wrong term ==> wrong answer ;)
07:15:19 <[COTL]Godofe_Kei> lol
07:15:28 <Cale> all (`elem` secondList) firstList
07:15:43 <[COTL]Godofe_Kei> how can i put this...
07:15:48 <[COTL]Godofe_Kei> im a moron, see?
07:15:52 <Cale> > all (`elem` [1,2,3,4,5]) [7,5,7,8,1,6,3]
07:15:52 <[COTL]Godofe_Kei> so i cant understand that
07:15:53 <lambdabot> False
07:16:04 * shapr boings cheerfully
07:16:04 <Cale> > all (`elem` [1,2,3,4,5]) [1,1,3,4,1,5,2]
07:16:05 <lambdabot> True
07:16:11 <[COTL]Godofe_Kei> lol
07:16:11 <rgrig> and what would be the right term? i still don't understand what you want to do.
07:16:16 <[COTL]Godofe_Kei> hmm
07:16:18 <xerox> > (sort . nub) [1..5] == (sort . nub) [5,4..1]
07:16:19 <lambdabot> True
07:16:24 <[COTL]Godofe_Kei> i want to do this:
07:16:27 <shapr> It sounds like you want to find common elements?
07:16:56 <ADEpt> shapr: rather, test for total set inclusion of the first list into second list
07:16:56 <Cale> intersect [1,2,3,4,5] [7,5,7,8,1,6,3]
07:16:59 <Cale> > intersect [1,2,3,4,5] [7,5,7,8,1,6,3]
07:17:00 <lambdabot> [1,3,5]
07:17:10 <xerox> <Interrupted by Cale>
07:17:11 * ADEpt . o O (oh, my english is horrbile)
07:17:12 <[COTL]Godofe_Kei> if the the first element exists on the second list, then do some operation
07:17:38 <[COTL]Godofe_Kei> let me put this on the web....
07:17:42 <[COTL]Godofe_Kei> give me 1 min
07:18:09 <[COTL]Godofe_Kei> where is thatpage where we can post our codes?
07:18:12 <[COTL]Godofe_Kei> for others to see?
07:18:17 <rgrig> > :t nub
07:18:17 <lambdabot>  parse error on input `:'
07:18:24 <rgrig> @type nub
07:18:25 <lambdabot> Not in scope: `nub'
07:18:48 <rgrig> what's nub?
07:18:50 <Cale> lisppaste2: url
07:18:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:18:52 <ADEpt> lisppaste2: @help
07:18:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:19:14 <Cale> lisppaste2: foo
07:19:21 <dcoutts> Cale, btw we've now got ghc-bin-6.4.1 in portage. You were asking about it the other day.
07:19:21 <Cale> nope :)
07:19:29 <Cale> dcoutts: yeah :)
07:22:04 <rgrig> how can i get a list of all lambdabot commands? is there a web page?
07:22:10 <[COTL]Godofe_Kei> http://paste.lisp.org/display/14556
07:22:27 <[COTL]Godofe_Kei> see if u can understand it
07:22:47 <[COTL]Godofe_Kei> Livro means Book
07:22:55 <[COTL]Godofe_Kei> so ISBN is the code of the book
07:22:57 <Lemmih> rgrig: @listcommands
07:23:13 <rgrig> @listcommands
07:23:14 <lambdabot> use listcommands [module|command], please. Modules are:
07:23:14 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
07:23:14 <lambdabot> hoogle karma lambda localtime more pl plugs poll quote search seen spell
07:23:14 <lambdabot> state system todo topic type version vixen where
07:23:33 <rgrig> @listcommands search
07:23:34 <lambdabot> search provides: google wikipedia
07:24:09 <rgrig> ok. how can i ask lambdabot to search the docs for a function name?
07:24:20 <rgrig> that is, if i can
07:24:21 <shapr> @index sepBy
07:24:21 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec,
07:24:21 <lambdabot> Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
07:24:27 <rgrig> thanks
07:24:28 <ADEpt> [COTL]Godofe_Kei: so, can you write a function for ISBN -> Library -> Library ? 
07:24:32 <rgrig> @index nub
07:24:32 <lambdabot> Data.List
07:24:34 <[COTL]Godofe_Kei> yes
07:24:57 <ADEpt> [COTL]Godofe_Kei: if so, you can use it to build a function that operates over a list of ISBNs
07:25:18 <ADEpt> [COTL]Godofe_Kei: for that, youll need foldl
07:25:22 <ADEpt> @type foldl
07:25:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:25:29 <ski> @type Data.List.nub
07:25:30 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:25:30 <[COTL]Godofe_Kei> hmm
07:25:35 <[COTL]Godofe_Kei> ok ill try with that
07:25:37 <[COTL]Godofe_Kei> thx!
07:26:10 <ADEpt> [COTL]Godofe_Kei: here 'a' is Library, and 'b' is ISBN
07:27:36 <msm106> @hoogle a -> [(a, b)] -> b
07:27:37 <lambdabot> No matches, try a more general search
07:27:44 <msm106> @hoogle a -> [(a, b)] -> Maybe b
07:27:45 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:27:45 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:28:12 <rgrig> @hoogle nub
07:28:12 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
07:28:12 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
07:28:57 <rgrig> forgive me for having fun with lambdabot
07:29:10 <rgrig> @google haskell kmp
07:29:11 <lambdabot> http://haskell.org/hawiki/RunTimeCompilation
07:29:21 <rgrig> @google don
07:29:22 <lambdabot> http://www-cs-faculty.stanford.edu/~knuth/
07:29:25 <rgrig> wow
07:29:40 <rgrig> i'm starting to really like your bot :)
07:31:30 <xerox> It's your bot too
07:33:13 <shapr> Yeah, Pseudonym wrote the very first version of lambdabot, then I was maintainer and hoster for awhile. dons has done great things with lambdabot since then.
07:33:29 <shapr> Lots of different people have written plugins.
07:34:19 <rgrig> just out of curiosity: how is google queried? thru theri web service interface or by parsing the html?
07:34:54 <xerox> rgrig: it uses the 'I'm feeling Lucky!' facility, and parses the HTTP headers of the reply.
07:36:36 <benny> dcoutts: do you know if the pattern stuff in cairo is supposed to work?
07:36:47 <rgrig> xerox, interesting.
07:36:51 <dcoutts> benny, should do
07:36:55 <tromp_> can you use pattern matching as a guard in list comprehension?
07:37:09 <xerox> tromp_: yes!
07:37:17 <tromp_> i tried with let, but that is irrefutable
07:37:27 <dcoutts> benny, if anything doesn't work we'd like to know about it (xerox and I)
07:37:33 <xerox> > [x | Just x <- [Nothing, Just 1, Nothing]]
07:37:34 <lambdabot> [1]
07:38:49 <tromp_> but how do i use the non-emptiness of a list as a guard?
07:38:57 <tromp_> while matching head/tail at the same time?
07:39:05 <benny> dcoutts: is this the correct way? withRGBPattern 0 1 0 (\p -> Cairo.fill)
07:39:07 <tromp_> | let (x:use')=use, ... doesn't work
07:39:08 <joelr1> shapr: ping
07:39:31 <xerox> > let f xs = [x | _ <- return xs, x <- xs] in f []
07:39:32 <lambdabot> Add a type signature
07:39:37 <xerox> > let f xs = [x | _ <- return xs, x <- xs] in f [] :: [Int]
07:39:38 <lambdabot> []
07:39:52 <xerox> It was something like that...
07:40:10 <xerox> I think ski knows it.
07:40:21 * ski knows what ?
07:40:28 <musasabi> joelr1: I'll answer the STM thing tomorrow, when I have had time to dig up code.
07:40:30 <tromp_> my definition is:
07:40:32 <tromp_> orderseq used use (n+1) = [x:s | x <- used, s <- orderseq used use n] ++
07:40:32 <tromp_>                        [x:s | let (x:use')=use, s <- orderseq (x:used) use' n] 
07:40:33 <xerox> ski: what tromp_ asked
07:40:42 <xerox> ski: did you use something in the permutations code?
07:40:42 <ski> let is irrefutable
07:40:47 <ski> use <- [...]
07:41:00 <tromp_> but i want to have a guard equivalent to the let
07:41:13 <ski> xerox : yes, i used '.. <- return (..)'
07:41:14 <dcoutts> benny, yes.
07:41:26 <tromp_> i can't use <-, x shld be the head
07:41:32 <xerox> (x:use') <- return use ?
07:41:40 <ski> yes
07:41:41 <dcoutts> benny, though I'd usually say:
07:41:42 <dcoutts> withRGBPattern 0 1 0 $ \pattern -> do
07:41:43 <dcoutts>  ...
07:41:53 <ski> return use = [use]
07:41:56 <ski> in list monad
07:42:03 <tromp_> i can do [x:s | not (null use),  let (x:use')=use, ... but that looks a bit ugly
07:42:12 <benny> dcoutts: right... problem is it doesn't seem to work, i get the fill using the previously set color, not the pattern color
07:42:28 <ski> [x:s | x:use' <- [use], ...]
07:42:33 <tromp_> ah, yes, i'll try (x:use') <- return use
07:42:46 <xerox> :-D
07:43:08 <tromp_> still it seems a bit ugly:(
07:43:59 <joelr1> musasabi: sure, no rush. i'm just gearing up to do a lot of STM work so i'm trying to learn as much as i can from what other people are doing
07:44:20 <jethr0> @seen shapr
07:44:21 <lambdabot> shapr is in #haskell, #haskell-blah and #ScannedInAvian. Last spoke 10
07:44:21 <lambdabot> minutes and 52 seconds ago.
07:44:29 <genneth> joelr1: what are you planning on?
07:44:42 <joelr1> bringing erlang closer to haskell :D
07:44:58 <joelr1> just writing an email on that to haskell-cafe
07:45:28 <shapr> jethr0: you screamt?
07:45:32 <dcoutts> benny, you need to use setSource
07:45:40 <xerox> @djinn (a -> b) -> (c,a) -> (c,b)
07:45:41 <lambdabot> x :: (a -> b) -> (c, a) -> (c, b)
07:45:41 <lambdabot> x x1 (v3, v4) = (v3, x1 v4)
07:45:41 <shapr> joelr1: hm?
07:45:48 <joelr1> shapr: updated my blog re: haskell ;-) will keep doing it going forward
07:45:49 <dcoutts> benny, http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html#v%3AsetSource
07:45:56 <shapr> ah, excellent!
07:46:10 * shapr looks
07:46:21 <jethr0> shapr, did i now?
07:46:23 <benny> dcoutts: ah ok thanks
07:46:45 <jethr0> just wanted to complain that progress with "my" TH tutorial was slow :(
07:46:52 <jethr0> steady though :)
07:47:02 <shapr> Sadly, I don't have time to help.
07:47:15 <jethr0> didn't want to ask for help... just yammering
07:47:31 <shapr> I'd like to help, I know TH will get a big usage boost from a good tutorial.
07:47:55 <shapr> The archives of the TH mailing list and the various TH papers are the best source of information.
07:48:09 <musasabi> joelr1: I think I just created a TChan and did a thread which did (loop tchan = atomically (readTChan tchan) >>= writeCommitToLogAndPostResult >> loop
07:48:14 <jethr0> one good reason to write it. hopefully i'll get somewhere with it within the next few days because otherwise xmas might turn out to be disruptive to the whole enterprise *g*
07:48:31 <shapr> You may also want to check out TH using software like Ulf Norell's IOHCC submission, musasabi's SerTH, and something Lemmih wrote (but I forget the name, doh).
07:48:38 <joelr1> musasabi: my question was whether simon m's answer helped you
07:48:47 <jethr0> shapr, TH mailing has _very_ limited pertinent material (almost none) as far as i could see
07:49:02 <joelr1> i don't know who said TH was simpler than lisp macros
07:49:07 <joelr1> way off ;-)
07:49:07 <jethr0> yup, i'll have a look at those
07:49:26 <musasabi> joelr1: then just made the transactions as: atomically ((work >>= writeTChan tchan) 'orElse' abortComp)
07:49:28 <shapr> TH isn't simpler than lisp macros, but lisp macros don't have typechecking.
07:49:29 <jethr0> although lisp macros _can_ require you to be a guru too :)
07:49:40 <joelr1> i had no trouble picking up lisp macros. scheme macros would be after lisp in difficulty and then TH
07:49:52 <musasabi> joelr1: I have code based on the Simons reply somewhere, but I have to dig it up
07:50:03 <Philippa_> shapr: to go a step further, TH can do typechecking on both levels if you really really *need* to
07:50:09 <shapr> Both levels?
07:50:14 <joelr1> musasabi: please post when you do. i would appreciate it!
07:50:21 <Philippa_> code and metacode
07:50:32 <Philippa_> you can insist on the type of the output matching something
07:50:39 <xerox> It's like typesafe macros?
07:50:42 <joelr1> this is all nice and fine but i'm talking about easy of use and implementation :D
07:50:57 <Philippa_> admittedly the range of possible constraints is less hot, but you can do it
07:51:00 <joelr1> what good is a great fine facility to me when i can't comprehend it ?
07:51:16 <musasabi> it is quite hard to use and undocumented
07:51:37 <musasabi> oh and differs from the pieces of documentation to make things nicer ;)
07:51:42 <shapr> musasabi: TH or STM?
07:51:43 <xerox> Who can we blame^Wask for comments?
07:51:46 <musasabi> shapr: TH
07:51:59 <shapr> Yeah, TH changed significantly between 6.2 and 6.4
07:52:12 <shapr> That's one reason a tutorial is sorely needed.
07:52:20 <musasabi> shapr: STM is very good, the nested transaction problem is the only larger problem and that will be fixed in 6.6
07:52:34 <shapr> Did you figure out STM and IO?
07:53:07 <musasabi> shapr: I think I got a story that works.
07:53:17 <xerox> Whoopee.
07:53:22 <joelr1> shapr: that's doable if you go through a TVar
07:53:24 <xerox> What is it about?
07:53:25 <shapr> cool
07:53:37 <musasabi> shapr: of course next I want to have my own hooks for deciding whether to commit or not ;)
07:53:40 <shapr> Yeah, I want to hear about integrating STM and IO when you get time.
07:53:47 <joelr1> as per simon's readOrTimeout example
07:53:56 <joelr1> that's what i plan on doign
07:53:58 <joelr1> doing
07:54:11 <shapr> Commit hooks sound cool, what would you use them for?
07:55:04 <dcoutts> JaffaCake, I'm glad it looks like we might get cabal-1.x.usable with ghc-6.4.2.
07:55:31 <JaffaCake> sometimes the rules just don't make sense :)
07:55:34 <musasabi> shapr: distribuited transactions ;)
07:55:42 <joelr1> musasabi: yes, yes!
07:55:51 <joelr1> erlang, erlang!
07:56:13 <xerox> Howdy, xah!
07:56:31 <musasabi> JaffaCake: I have the network locking code ready, just testing it for a few days before submitting.
07:56:32 <xah> hx xerox
07:56:37 <xah> just got up!
07:56:42 <xah> gonna have milk
07:56:46 <JaffaCake> musasabi: great, thanks!
07:57:07 <joelr1> musasabi: maybe i can add my "processes" once i get them done right
07:57:14 <gour> dcoutts: ping
07:57:16 <joelr1> musasabi: then we will have ... haskerl :D
07:57:18 <xerox> Hmm.  I want some tea.
07:57:26 <musasabi> joelr1: :-)
07:57:28 <dcoutts> JaffaCake, yeah. We (gentoo packagers) should take another look at having multiple versions of Cabal available at once. I recall it caused some problems.
07:57:48 <gour> dcoutts: congrats fot putting c2hs so fast in portage
07:57:53 <dcoutts> gour, heh
07:57:59 <JaffaCake> dcoutts: it probably does cause some problems, yes
07:58:15 <dcoutts> JaffaCake, well you might get some bug reports. :-)
07:58:17 <gour> dcoutts: and it looks you're a great fisherman too ;)
07:58:41 * dcoutts is a vegetarian. He does not fish. :-)
07:59:36 <shapr> I want tea too.
07:59:40 <shapr> But I'll have coffee instead!
07:59:46 <xerox> Nooow.
07:59:47 <dcoutts> mmm, more tea.
08:00:05 <xerox> I ough to go downstairs to prepare one.
08:00:20 <shapr> I just bought some arabica from arabia. Oddly enough, it says "ground brazilian coffee" and "100% arabica" too. Is that confusing or what?
08:00:36 <shapr> I can't read the arabic though.
08:01:02 <musasabi> arabica is a kind of coffee I think
08:01:26 <joelr1> musasabi: I just posted to haskell-cafe re: bringing Erlang to haskell
08:01:42 <joelr1> once thing that's missing is "processes" and a facility to track them
08:01:49 <shapr> Brazilian arabica seems like an oxymoron, but I'll tell you how it tastes.
08:02:08 <joelr1> another thing is making those processes distributed and propagating exceptions back and forth
08:02:40 <gour> dcoutts: then it must be you are preparing a new aquarium :-)
08:05:38 <ndm> dons: ping
08:08:29 <shapr> I wonder if QuickCheck would fit into Epigram's types.
08:08:39 <musasabi> I already have a distributed message passing thing, but doing a new better one could be fun.
08:09:01 * musasabi goes to check h-c
08:12:26 <Philippa_> shapr: it can almost certainly be made to somehow
08:12:39 <lennart> Brazilian arabica sounds a bit like Norwegian Swiss.  A cheese I bough in the US. :)
08:12:55 <Philippa_> you'd probably have to figure out how to build union types, but once you have them it's pretty obvious how to do it from there
08:13:06 <Philippa_> er, intersection even
08:13:19 <Philippa_> just take the intersection of "has the intended type" and "passes all the tests"
08:13:42 <xerox> Philippa_: is Epigram worth diggin' into?
08:13:58 <Philippa_> xerox: for what value of 'worth' at this point?
08:14:06 <Philippa_> it's nowhere near ready for building production systems with yet
08:14:18 <xerox> Philippa_: I don't really mind 'production'
08:14:20 <Philippa_> OTOH, it's certainly interesting to play with
08:14:29 <Philippa_> right now I don't think there's any IO yet
08:19:45 <Pupeno> Are there some functions to manage command line arguments easily ?
08:20:32 <tibbe> what's the type of the continuation exit in callCC $ exit -> -- etc... ?
08:20:49 <tibbe> I need to store it somewhere (in my state vars) for later
08:20:51 <xerox> 'standard' one
08:21:08 <tibbe> Cont r a?
08:21:11 <xerox> Oh, type in Type System sense. 
08:21:17 <tibbe> yeah
08:21:17 <xerox> @index callCC
08:21:18 <lambdabot> Control.Monad.Cont
08:21:23 <xerox> @type Control.Monad.Cont.callCC
08:21:24 <lambdabot> forall (m :: * -> *) a b.
08:21:24 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
08:21:24 <lambdabot> ((a -> m b) -> m a) -> m a
08:21:29 <ski> a -> Cont o b
08:21:34 <xerox> @kind Cont
08:21:35 <lambdabot> Not in scope: type constructor or class `Cont'
08:21:36 <ski> exit :: a -> Cont o b
08:21:42 <xerox> @kind Control.Monad.Cont.Cont
08:21:42 <lambdabot> * -> * -> *
08:21:44 <tibbe> thanks
08:21:52 <tibbe> I need to store that somehow
08:22:03 <ski> prolly you just store
08:22:10 <ski> exit :: () -> Cont o ()
08:22:14 <ski> or something like that
08:22:14 <tibbe> yeah, need to define a datatype to store it in
08:22:28 <tibbe> ski, yeah I'm trying to make a goto
08:22:33 <ski> (not sure what your 'o' is)
08:22:45 <tibbe> ski, but then my data type must be parameterized over o right?
08:23:09 <tibbe> ski, Value probably, or (), I'm executing statements and they aren't supposed to return anything
08:23:12 <araujo> Hello!
08:24:27 <ski> @hello
08:24:27 <lambdabot>  @help <command> - ask for help for <command>
08:24:53 <ski> tibbe : possibly you have fixed 'o', not sure
08:25:15 <ski> @type Control.Monad.Cont.runCont
08:25:16 <lambdabot> forall r a. Control.Monad.Cont.Cont r a -> (a -> r) -> r
08:25:34 <ski> @type (`Control.Monad.Cont.runCont` id)
08:25:35 <lambdabot> forall a. Control.Monad.Cont.Cont a a -> a
08:25:38 <ski> so
08:25:45 <ski> Cont o o -> o
08:26:02 <ski> if you're calling it at toplevel with trivial cont
08:26:16 <ski> so, then o is prolly not ()
08:26:32 <tibbe> ski, I'm in a ContT State MyState () monad
08:26:42 <ski> (though, maybe you in actuality use ContT, where the pic is a bit different)
08:26:43 <ski> ok :)
08:26:50 <Cale> [COTL]Godofe_Kei: That sounds like you want to do something like  vendaDeLivros isbn ls = map (\(t,a,n,i,p) -> if i `elem` isbns then (t,a,n-1,i,p) else (t,a,n,i,p))  -- this would be made simpler by record syntax
08:27:08 <tibbe> ski, combining the two really makes my head hurt
08:27:19 <ski> @type Control.Monad.Cont.runContT
08:27:20 <lambdabot> forall r (m :: * -> *) a.
08:27:20 <lambdabot> Control.Monad.Cont.ContT r m a -> (a -> m r) -> m r
08:27:28 <ski> @type (`Control.Monad.Cont.runContT` return)
08:27:29 <lambdabot> forall (m :: * -> *) a.
08:27:29 <lambdabot> (Monad m) =>
08:27:29 <lambdabot> Control.Monad.Cont.ContT a m a -> m a
08:27:38 <dcoutts> dons, I was wrong about the pango api. It would be possible to control extra space between glyphs, which would allow you to do things with non-monospace fonts, or eg make the unicode arrow take up the same amount of space as "->".
08:28:25 <ski> ContT () (State MyState) () -> State MyState ()
08:28:31 <ski> so, 'o' is ()
08:29:14 <tibbe> ski, woa, is that the type of what I need to save?
08:29:26 <mariodemon_11> hello
08:29:31 <tibbe> ski, of exit?
08:30:02 <tibbe> ski, data Value = VInt Int | ... | VCont ContT () (State MyState) () -> State MyState () ?
08:30:12 <ski> () -> ContT () (State MyState) ()
08:30:14 <ski> i think
08:30:16 <mariodemon_11> a quick question, is hugs98 able to compile haskell code to machine code?
08:31:03 <ski> of course, no need to store the function, store instead
08:31:09 <ski> exit () :: ContT () (State MyState) ()
08:31:24 <ski> mariodemon_11 : no
08:31:38 <ski> it's an interpreter
08:31:43 <Cale> mariodemon_11: for that, you should use ghc
08:31:48 <ski> (byte-compiler, iirc)
08:31:56 <shapr> lennart: You could put a picture of the cheese on your webpage. ralejs keeps a picture of a sausage on his webpage for some reason: http://www.cs.chalmers.se/~josefs/eckrich.jpg
08:32:45 <ski> eckrich ?
08:33:02 <ski> (ah brand name)
08:33:35 <tibbe> ski, hmm, I've got a circular module dependency now I think :(
08:33:40 <mariodemon_11> so, hugs>byte-code compiler, ghc>machine code compiler?
08:34:31 <Cale> mariodemon_11: well, yeah. I'd think of hugs as an interpreter myself, though it might be doing more than that (I haven't actually looked at how it works)
08:34:45 <tibbe> ski, can't you have circular dependencies?
08:34:52 <Cale> ghc also comes with ghci which is an interactive environment for loading haskell code, a lot like hugs
08:34:54 <ski> you can, sortof
08:34:55 <shapr> lennart: Do you know of an introduction to Michael Dummet that's slanted towards someone with a computer science background? I'd like to learn more about the extension of the Curry-Howard correspondance into philosophy via Dummet's work.
08:35:20 <mariodemon_11> Cale: thanks
08:35:22 <Cale> ghci will notice if compiled versions of the code are around, and load those if they're available, and otherwise interpret the code
08:35:52 <Cale> (compiled versions meaning .o files)
08:36:34 <tibbe> ski, I have two data types in different modules that depend on each other, the AbstractSyntax module defines the Value type that the State module uses and it in turn is imported as it's used in the Value type declaration
08:37:02 <lennart> shapr: I've not heard of anything like that, I'm afraid.
08:37:19 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
08:37:41 <ski> you could try that
08:38:16 <shapr> I'll keep looking.
08:38:18 <Cale> Mutually recursive modules are a pain though. It usually seems easier just to factor things out.
08:38:24 <ski> (otherwise, you could maybe try not putting the conts in Value, if possible)
08:43:38 <Philippa_> Cale: I got a situation where they're obligatory in Flippi. But there's a 'static plugin' situation going on and it's generally not your typical code
08:44:08 * shapr burbles frumiously
08:44:35 <xerox> dum de dum..
08:44:42 <shapr> joelr1: Your blog entry is entertaining.
08:44:49 <joelr1> really?
08:44:51 <joelr1> how so?
08:45:00 <xerox> length!
08:45:10 <shapr> It sounds sort of like "ow ow ow, this is fun!"
08:45:59 <shapr> joelr1: You list a lot of the pain of writing in Haskell, what are the rewards?
08:46:23 <shapr> er 'some' not 'a lot'
08:46:26 <shapr> poor choice of words.
08:47:11 <joelr1> shapr: well, i gotta leave SOMETHING for later, no?
08:47:15 <shapr> hah
08:47:22 <joelr1> shapr: plus, i have not decided yet
08:47:26 <shapr> I'm in suspense! I admit!
08:47:33 <joelr1> the main reward is the pleasure of coding in haskell, really
08:47:41 * Philippa_ nods
08:47:45 <joelr1> and the fact that if it compiles it will basically works
08:47:50 <shapr> Yeah, but can you quantify that more?
08:47:51 * Cale gives up on keeping up with the mailing list
08:47:59 <shapr> What's pleasurable about coding in Haskell?
08:48:00 <joelr1> oh, yeah, and the nice --- comments!
08:48:03 <Philippa_> I've started to do things where the "if it compiles it works" rule gets broken more often than not
08:48:17 <joelr1> shapr: pleasure is a feeling you know
08:48:23 <joelr1> which is particular to each individual
08:48:24 <shapr> Cale: There has been a serious explosion of cafe traffic, I have 261 unread messages in cafe.
08:48:32 <Philippa_> joelr1: assume a "for you" quantifier :-)
08:48:36 <joelr1> shapr: check out my last one!
08:48:57 <joelr1> i assume this thread is gonna be long and i named it appropriately
08:49:16 * joelr1 takes great pleasure in stirring the pot
08:49:36 <joelr1> shapr: the subject is "Safely polymorphic unsafePerformIO" 
08:49:37 <joelr1> hehehe
08:49:47 <joelr1> Philippa_: me too
08:49:58 <joelr1> the rule gets broken but not too ofteh, sometimes
08:50:11 <joelr1> Philippa_: it's kind of silly, actually
08:50:21 <joelr1> Philippa_: Erlang has a lot of {{ }}}} etc
08:50:23 <joelr1> :D
08:50:41 <joelr1> haskell code looks deceptively clean and simple
08:50:57 <joelr1> but you can twist your brain understanding it
08:51:40 <joelr1> i guess it gives me pleasure to attempt to twist peoples brains (where do you put that apostrophe?) although i'm not advanced enough to be good at it. i just like clean and simple code
08:52:08 <joelr1> programming in haskell is actually quite fast. it's fast to go from idea to code.
08:52:23 <joelr1> then post that code on haskell-cafe and have bulat and tomasz gang up on you for your bad coding practices
08:52:33 <Philippa_> heh
08:52:35 * shapr grins
08:53:08 <joelr1> what else
08:53:15 <Philippa_> joelr1: I've sent shapr into a spin a couple of times. There's a bit in Flippi where I'm effectively doing AOP and forgot to include a comment that that's what I'm doing...
08:53:31 <joelr1> i fell in love with haskell over spj's modelling financial contracts paper
08:54:22 <shapr> Yeah, I like the fast ideas to code transformation.
08:54:24 <joelr1> i'm planning to do something similar very soon, that's gonna be my own personal commercial product. consulting can only get you so far. 
08:54:33 <[COTL]Godofe_Kei> vendaDeLivros :: [ISBN]-> Livraria -> Livraria
08:54:33 <[COTL]Godofe_Kei> vendaDeLivros [] [] = []
08:54:33 <[COTL]Godofe_Kei> vendaDeLivros (x:xs) l = venda x l : vendaDeLivros xs l 
08:54:33 <[COTL]Godofe_Kei> venda :: ISBN -> Livraria -> Livraria
08:54:33 <[COTL]Godofe_Kei> venda _ [] = []
08:54:33 <[COTL]Godofe_Kei> venda x ((t,a,n,i,p):ys)
08:54:35 <[COTL]Godofe_Kei> 	|x == i = (t,a,n-1,i,p) : venda x ys
08:54:39 <[COTL]Godofe_Kei> why doesnt this work?
08:54:43 <joelr1> i have seen no other language in which ideas like that could be expressed as cleanly
08:54:55 <shapr> [COTL]Godofe_Kei: Anything over three lines is more politely done with a paste service.
08:54:58 <shapr> @paste
08:54:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:55:02 <shapr> lisppaste2: url
08:55:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:55:04 <[COTL]Godofe_Kei> oh sry
08:55:05 <[COTL]Godofe_Kei> my bad
08:55:09 <Cale> [COTL]Godofe_Kei: you need another guard, don't you?
08:55:14 * joelr1 goes to write down someplace why he loves haskell
08:55:18 <Cale> for the otherwise case
08:56:39 <[COTL]Godofe_Kei> http://paste.lisp.org/display/14561
08:57:05 <[COTL]Godofe_Kei> |otherwise = (t,a,n,i,p) : venda x ys
08:57:09 <[COTL]Godofe_Kei> forgot to copy it
08:57:31 <tibbe> why is "ContT () (State MyState) ()"   =   Kind error: `State' is applied to too many type arguments
08:58:16 <[COTL]Godofe_Kei> venda works
08:58:26 <shapr> tibbe: Did you want StateT there?
08:58:32 <Oejet> What is the contex switch overhead in Haskell compared to Erlang?  How would I even measure it with GHC?
08:58:33 <joelr1> `orElse` is called the ...?
08:58:50 <[COTL]Godofe_Kei> |otherwise = (t,a,n,i,p) : venda x ys
08:59:06 <tibbe> shapr, no, sorry nevermind, it refered to my State module when I thought it refered to the State monad
08:59:08 <joelr1> Oejet: beats me. I have yet to run tests on this but the scheduler works differently, i think. otherwise my poor lonely logger thread would not get overwhelmed
08:59:21 <Cale> [COTL]Godofe_Kei: you're returning a [Livraria] from vendaDeLivros
08:59:21 * joelr1 puts studying the ghc scheduler somewhere on his list
08:59:35 <shapr> I know that Lunar^ wanted scheduler priorities for hOp.
09:00:06 <[COTL]Godofe_Kei> then how do i apply it?
09:00:09 <dcoutts> joelr1, it's not the scheduler, with your logger thing you're not putting any constraint on the length or rate of delivery in the logger message queue.
09:00:11 <shapr> greetz SamB, how's code?
09:00:27 <joelr1> shapr: what's the `orElse` notation called? postfix?
09:00:33 <basti_> "infix"
09:00:34 <xerox> infix
09:00:39 <joelr1> dcoutts: well, there's no such constraint in erlang 
09:00:46 <joelr1> thank you, yes, infix, love that
09:01:02 <dcoutts> joelr1, so when you've got N threads generating messages and 1 thread consuming them, and no limits then it's not suprising that the message queues get rather long.
09:01:12 <joelr1> dcoutts: even without such a constraint in erlang my logger process would _not_ be overwhelmed
09:01:21 * JKnecht thanks joelr1 for http://www.itu.dk/people/elsborg/isola04.pdf++simon+OR+peyton+OR+jones+%22modeling+financial+contracts%22&hl=en&lr=lang_en
09:01:38 <joelr1> JKnecht: me? why me? you gotta thank SPJ for that!
09:01:41 <musasabi> joelr1: you can solve this by implementing priority inversion in the scheduler.
09:01:42 <dcoutts> joelr1, are you sure there's no constraint in the erlang version? Is it perhaps part of the erlang process abstraction?
09:01:48 <lennart> perhaps the Erlang scheduler takes mail box lengths into consideration?
09:01:58 <JKnecht> 'im too :)
09:02:12 <joelr1> he was kind enough to explain to me how Haskell constructors work when I called him from Sweden :) that was a couple of months ago and I did not know any Haskell at that time
09:02:21 <joelr1> musasabi: how?
09:02:23 <[COTL]Godofe_Kei> Cale: how do i apply venda in vendaDeLivros then?
09:02:27 <joelr1> dcoutts: yes, i'm sure
09:02:41 <joelr1> the erlang scheduler takes _something_ into consideration
09:02:42 <dcoutts> joelr1, I don't beleve it, sorry.
09:02:58 <joelr1> dcoutts: i'll get you the hard answers from the erlang people
09:03:01 <dcoutts> right, it takes something into consideration, perhaps mailbox length
09:03:04 <tibbe> could anyone have mercy on me and help me understand how I could store a continuation (using State)? I'm really not getting it!
09:03:18 <Cale> [COTL]Godofe_Kei: you want to apply venda x to the list, for each x in the list of ISBNs
09:03:28 <Cale> foldr will help
09:03:31 <Cale> bbiab
09:03:45 <dcoutts> joelr1, as I said, it's not suprising that you got the behaviour you did, considering the lack of constraints in the system you built.
09:03:51 <xerox> Oh, there was the Djinn here.
09:04:10 <joelr1> dcoutts: yes, but i built it this way because i was expecting it to work like in Erlang. my obvious bad.
09:04:49 <dcoutts> In Erlang the process abstraction is built into the system right? It's not implemented in a library?
09:04:49 <musasabi> joelr1: the basic problem is this: If a thread sends message the rest of its timeslice should be given to the receiver.
09:05:00 <musasabi> joelr1: but the GHC scheduler is fair.
09:05:12 <shapr> joelr1: You called up SPJ?
09:05:15 <musasabi> joelr1: which means that no such thing takes place.
09:05:55 <Philippa_> how is GHC's scheduler likely to react if threads other than the logger yield a lot?
09:05:57 <SamB> shapr: oh, I haven't done anything since saturday really... been playing with lilypond.
09:06:02 <joelr1> shapr: yeah
09:06:10 <shapr> SamB: Hey, that's code enough for me, how do you like it?
09:06:35 <joelr1> Philippa_: i hope to find out and investigate this more
09:06:38 <shapr> joelr1: imho, one of the most pleasing parts of Haskell is its user community, which is typified by the helpful nature of people like SPJ and Hughes.
09:06:55 <SamB> shapr: considering the complexity of the task it attempts, I'd say it does a pretty good job, but it also leaves much to be desired
09:06:57 <joelr1> I also sent the question re: Erlang's scheduler to one of my expert friends
09:07:09 <musasabi> Philippa_: in a fair round robin fashion I think.
09:07:13 <joelr1> shapr: yes, and #haskell too! 
09:07:15 <joelr1> :D
09:07:21 <shapr> Most people with a list of publications like SPJ probably wouldn't explain constructors in Haskell to some random person who called them up.
09:07:47 <joelr1> shapr: well, i got introduced, you see :D
09:07:49 <Philippa_> musasabi: it might be nice to have a "yieldTo" sometimes
09:07:55 <shapr> Oh cool, who introduced you?
09:08:00 <Philippa_> as in "let this thread take up the rest of my timeslice"
09:08:08 <joelr1> shapr: it's a long story. the erlang expert i roomed with :D
09:08:13 <[COTL]Godofe_Kei> Cale: i cant make it work...foldr can be used like this? 
09:08:23 <shapr> Who is it? Ulf Wiger, Joe Armstrong, Luke Gorrie?
09:08:28 <joelr1> shapr: uffe
09:08:32 <musasabi> Philippa_: yes, that is essentially priority inheritance, but most of the time the threadid to yieldTo would not be known.
09:08:38 <SamB> Philippa_: ooh, yes!
09:08:42 <dcoutts> Philippa_, yes I can imagin yieldTo being useful.
09:08:42 <[COTL]Godofe_Kei> Cale: isnt it just used to aply a certain operation to a single list?
09:08:56 <Philippa_> musasabi: 'tis possible to blackbox it in a lot of circumstances
09:09:05 <joelr1> i once left a message on john hugh's door at chalmers but he was away at the time so i never got to meet him
09:09:09 <musasabi> Philippa_: rather you want to have "give the rest of my timeslice to the receiver of this message"
09:09:09 <shapr> You roomed with Ulf? Should I even ask how that happened?
09:09:10 <Philippa_> like any time you're effectively using message passing concurrency to simulate something OOish
09:09:14 <joelr1> and i missed a beer with luke as well
09:09:19 <shapr> John Hughes is way cool.
09:09:23 <shapr> Luke is way cool too.
09:09:33 <joelr1> shapr: it's a long story
09:09:35 <Philippa_> musasabi: send the receiver an MVar in which to place its own ThreadId
09:09:56 <Philippa_> problem is, that, er, doesn't work 'til you've yielded :-)
09:10:20 <shapr> I started chatting with Luke years ago when he hung out on efnet#python and ran vegetable.org
09:10:22 <Philippa_> but yeah. Let people build their own arch to figure that one out
09:10:30 <SamB> so, like, "yield to the getter of this MVar"
09:10:44 <Philippa_> SamB: even that's too late. You have to go round the scheduler once
09:10:46 <shapr> Did you ever see his active wiki with a scheme interpreter written in javascript?
09:10:55 <SamB> Philippa_: hmm?
09:11:10 <Philippa_> SamB: for the thread to try getting the MVar it has to be already running
09:11:17 <joelr1> shapr: i was applying for political asylum in sweden (gotheborg) and that's how i dropped by chalmers. then they moved me to flen and my daugther came over from the states and they did not let her stay and uffe was kind enough to offer me the spare room he had :D
09:11:20 <shapr> joelr1: Oh hey, you may be the kind of person to ask about venture capital in Sweden? Have you seen my wimax widget idea?
09:11:27 <SamB> Philippa_: no, it would have blocked on the MVar
09:11:32 <Philippa_> ah, yeah, that does work
09:11:41 <joelr1> shapr: i did go through a VC round but that was in the states :D
09:11:43 <shapr> joelr1: Man, I thought my life was exciting, but noo...
09:11:44 <Philippa_> yield-to-receivers-on-write Chans being a result of that
09:11:51 <musasabi> Philippa_: yep, one will need mdo, and things get quite complicated if there is a pool of receiver threads instead of a single one.
09:12:01 <shapr> joelr1: I didn't know you have a daughter, and I'm curious about political asylum too.
09:12:05 <jethr0> shapr, any ideas how to get to standard/builtin operators nicely in TH?
09:12:16 <shapr> Show me?
09:12:18 <joelr1> shapr: and jane walerud didn't like me since i put down www.kreditor.com
09:12:23 <jethr0> (varE (mkName "+")) for addition operator doesn't seem nice
09:12:29 <joelr1> shapr: so no venture capital in sweden for me
09:12:36 <SamB> Philippa_: of course, that would only work if the channel was already empty
09:13:13 <jethr0> samb, how's your BF article coming?
09:13:16 <joelr1> shapr: check out the uptick section of my blog, my biographical summary should be somewhere in there. together with a picture of my brand-new (at that time) landrover :D
09:13:27 <joelr1> hehehe
09:13:28 <shapr> I saw the landrover, looked nice.
09:13:34 <musasabi> well Channels are not really message boxes.
09:13:36 <SamB> jethr0: as I said, I was playing around with lilypond yesterday
09:13:48 <shapr> I had to sell my '65 mustang to cover my debts at one point, so I know the feeling of losing a beloved vehicle.
09:13:53 <SamB> (plus there was church and the church christmas party)
09:13:54 <dcoutts> Philippa_, so when you write to an MVar that has readers blocking on it, the reader that gets to do the read would be awakened and put at the front of the runqueue and would inherit the writers timeslice. Then if within that same timeslice the reader goes back to reading from the same MVar than the original writer should get back the remainer of the timeslice. Right?
09:13:57 <joelr1> shapr: gave it up in bancruptcy proceedings ;)
09:13:59 <jethr0> ah
09:14:14 <shapr> jethr0: No, I don't remember if there's an easier way.
09:14:15 <musasabi> a message box is a lot more like "MVar (Sequence a)"
09:14:18 <Philippa_> dcoutts: the latter is... nice if you can manage it, but in the worst case can be treated as "timeslice over"
09:14:23 <dcoutts> Philippa_, that'd make it all sort-of sequential
09:14:30 <joelr1> dcoutts: is that how that happens? timeslice
09:14:45 <Philippa_> dcoutts: you could have a different MVar type that behaves that way
09:14:53 <SamB> dcoutts: the writer getting the rest of the rest would be tricky...
09:15:09 <dcoutts> Philippa_, rather than "delay this work for some other thread and carry on until my timeslice is over"
09:15:10 <SamB> because it isn't blocking on the MVar yet
09:15:41 <shapr> joelr1: Are you interested in a Y Combinator application?
09:15:59 <joelr1> shapr: that's in my uptick section also ;)
09:16:14 <shapr> Right, but my question was more like, are you still interested in ...
09:16:20 <SamB> actually, this kind of thing would have a lot of situations in which it wouldn't really work...
09:16:20 <joelr1> shapr: i decided not to go ahead with it. i also decided to do uptick in haskell, getting to it slowly
09:16:35 <dcoutts> SamB, right perhaps it'd just work by the reader thread returning to it's previous location in the runqueue when it goes back to blocking. That would then leave the original writer at the top of the runqueue.
09:16:56 <joelr1> dcoutts: i think the way the haskell scheduler works and being unable to use TChan would prevent emulating asynchronous messages in haskell.
09:16:56 <musasabi> GHC performs many of those things to MVars.
09:17:08 <dcoutts> though that would give the original writer a whole new timeslice which would not be fair.
09:17:11 <musasabi> joelr1: a Chan is quite different from a message box.
09:17:20 <musasabi> the semantics are quite different
09:17:28 <shapr> I have some Haskell based ideas I'd like to submit to the next Y Combinator round. And I'm tired of being a consultant also.
09:17:35 <joelr1> musasabi: could you elaborate?
09:17:41 <joelr1> shapr: why do you want y combinator?
09:17:54 <joelr1> i was told to get a co-conspirator in the us, btw
09:17:58 <joelr1> but that's not the point
09:18:08 <joelr1> i think you would do much better on your own
09:18:15 <dcoutts> we've got a Y combinator.
09:18:20 <joelr1> since there's not a lot you could do with 20k over the summer
09:18:20 <musasabi> joelr1: if you don't need multicasting a "TVar (Sequence a)" will almost allways be faster than "TChan a"
09:18:33 <shapr> dcoutts: Paul Graham's startup startup is called Y Combinator.
09:18:40 <dcoutts> shapr, ah. Cool.
09:18:43 <joelr1> musasabi: TChan is a single-linked list. what;s a Sequence?
09:18:56 <musasabi> joelr1: any functional sequence type.
09:19:18 <shapr> joelr1: I want Y Combinator because I've got the tech, but not the management/money clue.
09:19:21 <joelr1> musasabi: right. my point was that you just cannot use bottomless hole due to the way the scheduler works
09:19:35 <joelr1> shapr: hmm... and how do you see this working?
09:19:54 <joelr1> shapr: 20k is not a lot, really. specially if your tech is hardware-based (wimax?)
09:20:25 <joelr1> shapr: and they will not give you the management clues, i think. you are still supposed to put out a prototype or something. 
09:20:40 <joelr1> that seed money is really for prototype development if i understand it correctly
09:21:32 <shapr> Hm, I think I could develop a prototype for 20k or less.
09:21:42 <SamB> a prototype of what?
09:21:49 <shapr> A wimax widget.
09:22:00 <SamB> what is wimax?
09:22:06 <Philippa_> next wifi standard
09:22:10 <SamB> ah
09:22:11 <shapr> It's 802.16
09:22:23 <ProfTeggy> widget or gadget?
09:22:23 <Philippa_> and... really, the thing with wimax is that it's a clear development of an existing technology...
09:22:29 <shapr> It has a line of sight range of 50km and a max speed of something large.
09:22:36 <SamB> I think you need to expand on the "widget" part
09:22:37 <ProfTeggy> Woah
09:22:45 <ProfTeggy> 50km?
09:22:48 <SamB> and what do you care about the wimax part for?
09:22:59 <shapr> In reality, you probably only get 10km and 8Mbps, but that's enough for what I want.
09:23:14 <Azmo> does anyone know whats wrong in my failure of installing hs-plugins-0.9.10 ? (see http://rafb.net/paste/results/mDavC750.html)
09:23:23 <SamB> line of sight?
09:23:24 <shapr> I think they claim 72Mbps and 50km in the specs (but everybody knows that gezeik).
09:23:30 <SamB> that hardly sounds useful
09:23:48 <Philippa_> SamB: they mean that range is less if bouncing's required
09:23:54 <shapr> I think they claim 30km without LoS.
09:23:55 <SamB> ah
09:24:02 <Philippa_> you can't give an accurate range on a tech like that without specifying the environment
09:24:13 <SamB> so, is it really more line-of-bouncing?
09:24:37 <shapr> In any case, I'd like to make a wimax mesh network node that looks and works like a mobile phone.
09:24:47 <joelr1> does anyone know why i would receive error 64 form IOCP on Windows?
09:24:48 <joelr1> 2005.12.12 16:44:52 - IOCPReadRequest closing a socket: 1221DF10. request:
09:24:48 <joelr1> 00D0F3B8 WSAError: 64 socketError:0
09:24:56 <joelr1> error 64 is "The specified network name is no longer available. "
09:25:07 <shapr> You'd have free voice calls to anyone in the surrounding ~30km and free data messages to anyone reachable via the mesh.
09:25:09 <Lemmih> Azmo: Some of it was apparently compiled with GHC-6.4.
09:25:11 <joelr1> this is what the C++ server logs when my haskell code connects to it
09:25:35 <shapr> I realized that I spend a hundred euro a month calling people who are usually within 5km.
09:25:58 <SamB> does wimax have many channels?
09:25:58 <Azmo> Lemmih: ah, so if i try again with GHC-6.4 it should work?
09:26:10 <Lemmih> Azmo: And you shouldn't call 'configure' and 'make' directly.
09:26:13 <shapr> After asking many acquaintances, I realized they spend less money a month, but call people within the same radius.
09:26:44 <Azmo> Lemmih: hm.. it said so in the installation notes..
09:26:46 <shapr> SamB: http://www.scannedinavian.com/2005-11-21.html
09:26:55 <Lemmih> Azmo: Clean it (runhaskell Setup.hs clean), then follow the build guide in the README.
09:28:09 <Azmo> Lemmih: ok, but readme says http://rafb.net/paste/results/hcmTli93.html
09:28:28 <shapr> So the idea is, mesh networks where the nodes have a decent range will beat both mobile phone providers and last-mile telecom providers, so how to put that functionality into a package that gives consumers value right out of the box?
09:29:52 <shapr> It might be simpler to sell the wimax mesh node as a box that takes a battery but also has bluetooth. Then you could sell it along with a bluetooth earbud/microphone gadget.
09:31:30 <shapr> Anyway, I don't really care if someone else makes this happen, I'm just tired of paying so much money to my mobile phone provider when they could easily let me talk for free to other phones talking to the same base station.
09:32:07 <shapr> SamB: What do you think?
09:33:09 <SamB> sounds like a cool idea
09:35:06 <shapr> Of course I wonder how much people spend each month on mobile phone calls to people within a radius of 30km. If I could find a good average amount, I'd know how much I could afford to price each wimax phone.
09:35:29 <shapr> Also, this is just one step in my larger plan of rabid decentralization.
09:35:40 <joelr1> musasabi: ping
09:35:57 <SamB> I spend a total of $0.00
09:37:58 <Philippa_> shapr: I'd still need my mobile anyway. Two pocket gadgets rather than one is a bad thing :-(
09:40:02 <genneth> shapr: same here; i can't even use the free minutes i get per month
09:41:17 * SamB doesn't even have a cellphone
09:41:42 <SamB> and yes, you'd need to work on the problem of having to also carry a cellphone...
09:41:44 * xerox has got many - not that he uses any, my dad is addicted to them
09:41:52 <xerox> 'his', 'his'.
09:42:03 <shapr> genneth: Yeah, but how much did those free minutes cost?
09:42:18 <shapr> Philippa_: Why would you need your mobile anyway? You make longer distance calls?
09:42:36 <SamB> shapr: well, what if one of those people is out of range for some reason?
09:42:39 <SamB> what if it rains?
09:42:58 <shapr> You can send them a voice message.
09:43:00 <Philippa_> shapr: bingo. Like "the train'll get in at time foo" or something
09:43:17 <Philippa_> or when Damien or I're away...
09:43:44 <shapr> It's also possible that multi-hop realtime voice will work, I just can't count on that.
09:43:52 <tibbe> have anyone ever managed to store a continuation and not just use it inside the "body" of callCC?
09:43:59 <musasabi> joelr1: pong
09:44:17 <joelr1> do you work with windows servers at all?
09:44:26 <SamB> tibbe: I don't think that makes any sense
09:44:42 <shapr> tibbe: You want to serialize continuations?
09:45:04 <musasabi> joelr1: I test code with them from time to time, but it is quite painfull.
09:45:17 * xerox boings up and down furiously
09:45:23 <joelr1> i'm getting a lot of connection reset by peer :(
09:45:24 <SamB> shapr: I think by "store" is meant something more like "use it after runContT returns"
09:45:31 <Philippa_> shapr: YAreinventing the internetAICM£5 :-)
09:45:31 <joelr1> and it's WSA Error 64 on the other end
09:45:33 * kowey marvels at his own stupidity
09:45:34 <musasabi> joelr1: once a few months I'll look "has anything broken windows builds"
09:45:58 <kowey> i just replaced a reverse $ tail $ dropWhile foo $ reverse
09:46:10 <joelr1> musasabi: right, ok, thanks
09:46:10 <kowey> by a takeWhile foo $ tail 
09:46:16 <shapr> Philippa_: Yes, exactly. With the difference that we don't really have mobile internet right now.
09:46:26 <SamB> kowey: don't you need a not . in there somewhere?
09:46:44 <SamB> besides which, those aren't anything like the same...
09:47:04 <shapr> In fact, I'd much rather have a roaming ISP contract and use a wimax widget as my 'connect to any ISP base station within 30km'
09:47:21 <genneth> shapr: i get ¬£5 per month; 300 (or might be 500...) free minutes
09:47:23 <kowey> hmm... the foo was actually (/= 'x')
09:47:29 <musasabi> joelr1: WSAEHOSTDOWN ? That should never occur.
09:47:42 <kowey> and i was basically trying to extract from x0xSomeString the 0
09:47:42 <shapr> genneth: Did you get a deal with your phone?
09:47:49 <genneth> shapr: it seems that market forces will eventually catch up and make voice calls essentially free
09:47:54 <genneth> shapr: the phone was free too
09:48:00 <joelr1> that's the thing
09:48:04 <genneth> shapr: 3g phone too
09:48:06 <joelr1> it's not that but just 64 it appears
09:48:19 <joelr1> i'm told to type "net helpmsg 64" to get a description
09:48:48 <SamB> which end do you get 64 on?
09:48:51 <kowey> so before, i would reverse that into gnirtSemoSx0x, drop off all the non x's to get x0x and then tail the x away
09:48:58 <Philippa_> shapr: the mobile industry's going to go data in the long run
09:49:04 <kowey> which is stupid, because if someString contains 'x'...
09:49:11 <joelr1> windows has 64 from WSAGetLastError, haskell on mac osx has "connectionr eset by peer"
09:49:25 <shapr> genneth: Yeah, but market forces don't work so well where there aren't any base stations.
09:49:35 <shapr> Philippa_: Sure, I agree, I just want to make that happen *now* !
09:50:05 <kowey> oh, SamB, i left off a tail in the first expression, that's why they didn't look the same
09:50:10 <Philippa_> being outside the main phone network'll make it hard for you to exert sufficient market forces on them. That leaves you competing with the wifi hotspot crowd
09:50:43 <musasabi> joelr1: have you checked that the packets are not actually lost somewhere?
09:50:57 <joelr1> lost? this is running on a lan
09:51:03 <shapr> An earlier iteration of this idea was to run a city-wide wireless ISP where I would setup wifi hotspots on every streetlight, the same way San Francisco does it. Then you allow in-city traffic for free, and charge a credit card per traffic for traffic into and out of the internet proper.
09:51:26 <joelr1> musasabi: ok, a wireless lan in my case but i think the client has a regular lan
09:51:58 <musasabi> joelr1: sounds weird, I am sorry but not very many clues.
09:51:59 <SamB> joelr1: consider investing in some wires
09:52:08 <shapr> Philippa_: Nah, it's a whole different market. If these wimax widgets were cheap enough that high schoolers could purchase them, they'd be able to talk to each other for free.
09:52:11 <musasabi> joelr1: maybe #winprog on EFNet may help you.
09:52:16 <shapr> At least, I think so...
09:52:42 <joelr1> musasabi: going, thanks
09:52:53 <Philippa_> shapr: if it works without a base station then yeah
09:53:06 <SamB> shapr: well, why would anyone get one when nobody else had one?
09:53:06 <joelr1> musasabi: what server do i use for EFNet?
09:53:27 <joelr1> is freenode EFNet?
09:53:40 <musasabi> nope.
09:53:41 <Muad_Dibber> no
09:54:45 <musasabi> http://www.efnet.org/?module=servers
09:55:11 <joelr1> thanks
09:55:29 <shapr> SamB: Advertising? Hackability?
09:55:51 <shapr> Plus wimax is already a standard, so it'd talk to any other wimax node.
09:56:02 * SamB wonders why jlouis wants to send TChans in messages to the FS thread
09:56:54 * SamB would think MVars were more appropriate
09:56:58 <ADEpt> SamB: yep. better send functions IMO.
09:57:33 <SamB> ADEpt: functions?
09:58:15 <SamB> oh, and what is this SHA1 problem jlouis is so worried about?
09:58:41 <shapr> It takes forever to do a naive sha1 in Haskell.
09:59:02 <SamB> well, he said the results were wrong or something....
09:59:10 <shapr> oh?
09:59:19 <ADEpt> SamB: yep. instead of "TChan SomeThing" pass "(SomeThing -> IO ())". This way actual communication could be constructed on TChans, MVars, or whatnot, without modifying function itself.
09:59:31 <SamB> ADEpt: eh.
09:59:48 <SamB> I think that would make the client code more complicated...
09:59:51 <shapr> Yay, I got paid!
09:59:59 <SamB> for what?
10:00:17 <shapr> For last months work.
10:00:27 <SamB> anyway, the SHA1 code we have here works fine for infohashes...
10:00:33 <shapr> Now I can buy that unicycle tire I've been lusting after :-)
10:00:56 <ADEpt> SamB: why more complicated? istead of "someFunc tchan" you will write "someFunc (sendMessage tchan)", and that's it
10:01:22 <SamB> ADEpt: well, what I want to know is why use a tchan in the first place?
10:02:57 <ADEpt> SamB: as a good STM exercise? It seems that MVars will be harder to use in case of "N writers, 1 reader patter", no?
10:03:58 <SamB> ADEpt: hmm.
10:04:27 <SamB> well, it seems a bit overkill in the case of PieceAvail at least...
10:06:22 <ADEpt> SamB: maybe, that's for added asynchronity? So that calee will not block on "call" to PieceAvail?
10:06:56 <SamB> when would callee not want to do this, exactly?
10:09:14 <ADEpt> SamB: hm. good question. depends on who the calee is.
10:09:29 <ADEpt> SamB: but, no, I can't think up an example.
10:09:35 <ADEpt> jlouis: and you? ;)
10:09:45 <Taral> Hihi.
10:09:53 <Taral> @karma+ Haskell
10:09:53 <lambdabot> Haskell's karma raised to 4.
10:10:03 <SamB> most of the time you'd need to know the answer right away so you could choose what to do next
10:10:20 <SamB> so, maybe you shouldn't have to ask the FSThread about that
10:10:34 <SamB> dunno
10:10:42 <Taral> what's up?
10:10:58 <SamB> talking about conjure
10:11:52 <jlouis> SamB, ADEpt: I would like to go with the Function solution
10:12:01 <jlouis> I do not think it complicates the code any more
10:12:23 <SamB> jlouis: it looks like something is very wrong with the way FS.Piece looks at Torrents
10:12:32 <SamB> hmm, perhaps not..
10:12:46 <SamB> (re: function solution complicating code)
10:12:49 <jlouis> and regarding the SHA1 problem. My small reports a different sha1 sum than the infohash
10:12:53 <jlouis> I wonder why? 
10:13:12 <SamB> jlouis: do you know what the infohash is?
10:13:14 <jlouis> SamB: theres probably a lot of stuff wrong with FS.Piece
10:13:25 <jlouis> SamB: its the sha1-hash over the pieces string
10:13:43 <jlouis> pieces being the b-encoded string in the .torrent dictionary
10:13:59 <ADEpt> jlouis: and so far it was being calculated properly
10:14:29 <jlouis> I am talking about an individual piece. Its probably a bug of mine. I'll just have to hunt it down
10:14:33 <jlouis> >;-)
10:14:39 * ADEpt has not understood the essence of problem with sha1, though
10:14:48 <SamB> its actually the sha1 hash of the "info" branch of a torrent when b-encoded
10:14:55 <SamB> nothing to do with pieces per-se
10:15:02 <jlouis> SamB: yeah, you're right
10:15:48 <jlouis> my problem concerns loading individual pieces and sha1-checking them
10:15:58 <jlouis> there, I get differing sha1 values
10:16:11 <rgrig> @help karma
10:16:11 <lambdabot> return a person's karma value
10:16:26 <SamB> well, were you using FS.Piece to do it?
10:16:26 <rgrig> @karma rgrig
10:16:26 <lambdabot> You have a karma of 0
10:16:42 <SamB> because that code says the same wrong thing you just said about infohashes
10:17:03 <jlouis> SamB: yes, I did
10:17:06 <jlouis> ;)
10:17:20 <SamB> let me try to fix it
10:17:39 <jlouis> Be my guest. I would like my bugs fixed, hehe
10:18:04 <ADEpt> jlouis, SamB: while we are at it, maybe we can decide the proper place (module) for "pieceSize:: PieceNum -> Int"? :)
10:18:27 <ADEpt> jlouis: and one other thing. Some old commit messages says that Pieces are numbered from 1. Is it really so?
10:18:42 <palomer> man, I still can't believe that I finished that assignment
10:18:51 <palomer> imagine taking a piece of incomprehensible code and making it work
10:18:53 <SamB> if that SHA1 code didn't work or if infohashes were not being calculated correctly, then it would be difficult to communicate with the tracker...
10:19:31 <jlouis> SHA1 works. I think its the input to SHA1 thats bad. 
10:19:31 <palomer> do modules have "signatures" or "interfaces" or "prototypes" (or whatever you want to call them)
10:19:36 <palomer> "contracts"
10:19:55 <SamB> palomer: functions have signatures
10:19:59 <SamB> and modules have functions
10:20:14 <palomer> SamB: right, but a module also has an abstract description
10:20:28 <SamB> palomer: you mean like a haddock?
10:20:35 <jlouis> Re pieceSize: I do not know. 
10:20:38 <palomer> I don't know what a haddock is
10:20:50 <palomer> I'm talking about a mapping from strings to types
10:20:55 <SamB> @docs Data.Map
10:20:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
10:21:02 <xerox> We're just waiting for an md5col.c for SHA1 :-\
10:21:18 <jlouis> Re the piece numbering: I think it is 1.., but i am not sure. I'll add a ``need to find out'' to my TODO list
10:21:26 <palomer> the synopsis is the "module signature"
10:21:35 <palomer> can you check a module against a "signature"?
10:21:48 <jlouis> signature in the SML sense?
10:21:48 <SamB> xerox: doesn't really matter unless other clients try to forge pieces
10:21:52 <palomer> jlouis: yeah
10:23:14 <SamB> arg, stupid commit tests...
10:23:26 <ADEpt> jlouis: it should be from 0, because bt proto docs say so.
10:23:35 * SamB already concluded that there aren't tests for this, anyway
10:23:40 <SamB> which should be fixed, btw
10:23:56 <jlouis> palomer: well, the ``signature'' is spread out in the module itself. There is no separation between the 2 (sadly)
10:24:05 <palomer> jlouis: oh my god!
10:24:09 <jlouis> ADEpt: okie! I'll try to hunt bugs down
10:24:27 <palomer> jlouis: the idea of signatures is so useful, it lets you swap code seemlessly
10:24:53 <flux__> palomer, you're talking about a module system like in ML?
10:24:54 <SamB> well, you could still put all your sigs at the top...
10:24:55 <jlouis> palomer: Yup, I've written big big SML projects. I know.
10:25:17 <SamB> you can swap just as seamlessly with Haskell, if both modules export all the same things...
10:26:22 <palomer> flux__: yeah
10:26:27 <palomer> jlouis: how big?
10:26:35 <jlouis> palomer: 15k+ lines
10:26:36 <Saulzar> He's talking about so called "functors" (which have to have the most awfully misleading name)
10:26:42 <palomer> nonono
10:26:47 <palomer> no functors, just signatures
10:26:59 <SamB> what good are signatures without functors?
10:27:07 <palomer> SamB: what if the new one exports more?
10:27:08 <jlouis> Saulzar: no, he is not. A functor does not have misleading name if you regard your structures as categories, eh ;)
10:27:09 <Saulzar> (Was half way through the same question)
10:27:20 <SamB> palomer: a compat module will solve the problem
10:28:13 <SamB> (or importing only what you want always)
10:28:30 <Saulzar> jlouis, Yeah but clearly when dealing with programming languages it is best not to re-use widely known terms :)
10:28:43 * SamB sends patch
10:28:54 <SamB> Saulzar: but it does make sense!
10:28:56 <jlouis> Saulzar: I do not like the name that much either. Functor is too greatly overloaded
10:29:03 <Saulzar> Or you alienate anyone coming from C++ (Hmm... maybe they have a clever plan!)
10:29:06 <palomer> but modules really do look like categories
10:29:23 <SamB> they have something called that in C++?
10:29:29 <SamB> then its their own fault.
10:29:46 <Philippa_> the ML usage is a lot more appropriate than the C++ usage
10:30:02 <palomer> in C++, a functor is a class which implements operator()
10:30:21 <SamB> okay, admittedly C++ users aren't responsible for the terms C++ misuses...
10:30:28 <SamB> palomer: in Python those are called callables
10:30:36 <Philippa_> SamB: they are when it was never a part of the C++ standard
10:30:47 <SamB> Philippa_: hmm
10:30:50 <SamB> I suppose so
10:31:17 <Saulzar> It seems appropriate if you have never heard of catagory theory :)
10:31:23 <SamB> anyway, ML had it way before C++, most likely...
10:31:48 <rgrig> they clearly don't mean the categorical notion. they just "invented" a name for a function that sounds like you are naming a thing. it is a coincidence.
10:31:52 <jlouis> most likely. The module system was formalized in SML97..
10:32:10 <SamB> jlouis: they had it before then though, right?
10:32:12 <rgrig> because a object is a "thing"
10:32:21 <tic> I'm thinking of taking an Advanced Advanced Functional Programming class.. Deals with category theory. Is there a nice introduction to cat. theory?
10:32:40 <rgrig> tic, I like Barr & wells
10:32:47 <jlouis> SamB: probably quick a while before.
10:33:00 <jlouis> quite....
10:33:00 <tic> rgrig, I'll look that up. Thanks.
10:33:04 <SamB> like decades before?
10:33:21 <Saulzar> Maybe catagory theory re-used a term the term too?
10:34:07 <jlouis> Maybe it got ``lifted'' from another branch of mathematics
10:34:18 <Saulzar> func¬∑tor n. One that performs an operation or a function.
10:34:22 <Philippa_> Saulzar: possibly, but if so it will've generalised it
10:34:34 <Philippa_> actually, I think it did
10:34:36 <SamB> Saulzar: never believe the dictionary
10:35:49 <SamB> jlouis: so, does that patch fix things for you?
10:38:53 <SamB> oh, that inventory is getting a bit unwieldy in size...
10:39:18 <jlouis> SamB: I'll check later (Ithas not passed the geylisting barrier yet)
10:39:30 <SamB> greylisting, you mean?
10:39:47 <jlouis> yes
10:41:13 <SamB> so, how do you get darcs to split an inventory file?
10:41:17 <SamB> checkpointing?
10:41:40 * ADEpt made himself a DSL which provides a target compiler with input that segfaults it. "Nice"
10:42:06 <SamB> whats the domain?
10:42:19 <SamB> and what is the target?
10:43:12 <ADEpt> SamB: domain is description of the IT landscape (kind of UMC Collaboration Diagram, but simplier). Target is "dot" from graphviz.
10:43:27 <SamB> ah
10:43:40 <SamB> so maybe segfaulting it isn't too impressive
10:45:39 <ADEpt> SamB: I previously used it, f.e., to track dependencies in rather large C code (>2000 nodes), so actually it is impressive for me :)
10:46:25 <SamB> ADEpt: well, sure.
10:46:34 <SamB> but probably it is finicky
10:49:47 <SamB> make sure your labels properly escaped and such...
10:49:58 <SamB> s/labels/labels are/
10:50:30 <SamB> jlouis: got through yet?
10:51:54 <ADEpt> SamB: thing is, it make several optimization iteration and then goes kaboom ... /me just hates to debug code in C/C++, but who asks?
10:52:01 <SamB> ah
10:52:23 <SamB> wierd
10:52:29 <SamB> it isn't your fault
10:53:13 <SamB> how many nodes do you have?
10:54:02 <ADEpt> 200+
10:54:16 <ADEpt> oh wait. less than that
10:54:21 <SamB> huh
10:54:27 <SamB> are they tangled badly?
10:55:08 <ADEpt> like 20. And yes, they are tangled badly.
10:58:09 <SamB> do any of the other filters do digraphs?
10:58:39 <ADEpt> SamB: aha! it doesnt like my cluster. Ok, will do without clusters ...
10:58:47 <ADEpt> SamB: no, AFAIR they do not
10:59:44 <Taral> bittorrent in Haskell?
10:59:57 <SamB> Taral: yup
11:00:01 <SamB> doesn't work yet though
11:00:13 <SamB> but it is coming together
11:00:25 <Taral> SamB: Re: darcs split -- inventories are split on tags. Use optimize --reorder if there's a tag but it's not splitting.
11:00:49 <Taral> SamB: Anything you can use help on?
11:01:15 <SamB> Taral: probably
11:01:32 <Taral> :)
11:02:06 <SamB> its hard to do anything more without the storage code, though
11:02:18 <Taral> code?
11:02:23 <Taral> er, url?
11:02:30 <SamB> @where conjure
11:02:31 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
11:02:53 <Taral> why do you have .hi files in there?
11:03:36 <SamB> I'm guessing thats just jlouis's working directory, perhaps rsynced
11:03:57 <SamB> one time he forgot to add a file to the repo and I grabbed it from there and added it myself
11:04:13 <Taral> arg
11:04:18 <Taral> why do people check in configure scripts?!
11:04:23 <SamB> arg?
11:04:25 <Taral> they're huge + bulky + autogenerated
11:04:40 <SamB> true
11:04:50 <SamB> but there are reasons
11:05:27 <Taral> I have EVP.hsc for SHA1 via openssl if you want it.
11:05:45 <Taral> hash :: MDEngine -> [Word8] -> [Word8]
11:05:48 <Taral> hashMem :: MDEngine -> Int -> Ptr Word8 -> IO [Word8]
11:05:51 <SamB> eh.
11:05:58 <Taral> it's in the TODO :)
11:06:04 <ADEpt> Taral: because it's hard to guess HOW to generate them in each particular case, and they are needed to make tests run upon "darcs record"
11:06:14 <Taral> ADEpt: autoreconf!
11:06:33 <SamB> oh, well, jlouis thought the SHA1 code was broken
11:06:55 <Taral> It looks like the configure.ac could be substantially reduced if you switch to Cabal.
11:06:57 <ADEpt> Taral: not on every platform, unfortunately. BTW, there is a "thread" about that in the commit logs :)
11:07:15 <SamB> when really he was extracting the wrong SHA1 hash from the torrent
11:07:21 <Taral> ha
11:07:36 <Taral> darcs curl library is yuk
11:07:50 <Taral> we have minihttp, why is that still in TODO?
11:07:58 <SamB> Taral: no idea!
11:08:03 <CosmicRay> what's minihttp?
11:08:14 * SamB decides to actually look at todo
11:08:15 <ADEpt> Taral: fix & send :)
11:08:17 <Taral> ha
11:09:08 <Taral> OMG
11:09:15 <Taral> why are you typechecking bencoding directly?
11:09:24 * Taral sets off to write a bdecoder
11:09:42 <SamB> Taral: whats wrong with what we have?
11:09:55 <Taral> You have a type system, use it!
11:10:00 <SamB> true.
11:10:09 <Taral> Fun, fun, I get to play with type classes!
11:10:37 <SamB> but what about keys that we don't know about?
11:10:42 <SamB> anyway, we are using the type system
11:10:54 <Taral> Um, kinda. :)
11:11:14 <SamB> not for that stuff, sure...
11:11:36 <SamB> also, have you ever tried to read without specifying a type to read at?
11:11:43 <Taral> ?
11:11:50 <shapr> Is there a ghc6 deb that supports amd64?
11:11:51 <SamB> > read "1"
11:11:52 <lambdabot> Add a type signature
11:11:53 <Taral> I wanted to write class BDecode a where bdecode :: String -> a
11:12:08 <Taral> SamB: So?
11:12:45 <SamB> well, lots of torrents and tracker responses include key-value pairs we know nothing about...
11:12:50 <Taral> hm, maybe I'll make it bdecode :: String -> Maybe a
11:12:59 <Taral> O.o
11:13:02 <Taral> Hm....
11:13:07 <SamB> and that type inference code is strictly for debugging, btw
11:13:13 <Taral> Let me think about that one
11:14:13 <Taral> Yeah, the type system won't be able to check dictionary keys
11:14:21 <SamB> did you make it down to BDecodable yet?
11:14:43 <Taral> SamB: Cute.
11:14:51 <Taral> Why have two layers?
11:15:07 <SamB> it makes each simpler
11:15:28 <Taral> so the typechecker I saw... isn't being used?
11:15:44 <SamB> I used it ;-)
11:15:53 <Taral> *shrug*
11:15:55 <Taral> Oh, well, next idea.
11:15:57 <SamB> and the checker is being used
11:16:01 <Taral> why?
11:16:19 <funky> hi
11:16:21 <SamB> to tell whether a torrent meets certain qualifications
11:16:31 <Taral> why not just try to decode it with the expected type?
11:16:43 <astrolabe> hi funky
11:17:32 <SamB> hmm, I think the relevant code might be in Conjure.Torrent now...
11:17:49 <SamB> no?
11:17:59 <Taral> However, Linux doesn't have sendfile(2), so we need to use its corking
11:18:00 <Taral> ?!
11:18:03 <Taral> Linux has sendfile(2)
11:18:24 <Taral> and kqueue(?) is abstracted by libevent
11:18:45 * shapr wonders...
11:18:46 <Taral> but libevent might be difficult to use wrt the RTS's own threading methods
11:18:51 <SamB> Taral: well, its not the same sendfile(2)
11:18:56 <shapr> Do I buy a new PC, or should I go for a unicycle instead? It's so hard to choose!
11:19:12 <Heffalump> do you have a unicycle?
11:19:17 <shapr> Three actually.
11:19:21 <Taral> ha
11:19:26 <SamB> Heffalump: what a silly question
11:19:27 <Taral> Do you have more PCs than unicycles?
11:19:34 <shapr> Taral: Oh definitely.
11:19:35 <SamB> you don't think he sold it or broke it?
11:19:37 <shapr> But most of them are old.
11:19:42 <Taral> Okay...
11:19:49 <SamB> if he hadn't one anymore, he would know what to do, anyway...
11:19:54 <Taral> Do you have more usable/useful PCs than usable/useful unicycles?
11:20:00 <shapr> My recent PCs include a dual Athlon MP 1.5 GHz and a 2.4GHz P4.
11:20:09 <SamB> shapr: old shmold
11:20:14 <SamB> that sounds nice to me
11:20:15 <Taral> shapr: Buy an investment.
11:20:19 <Taral> Not a PC or unicycle.
11:20:21 <shapr> About the same actually, two mountain unicycles and two usable PCs.
11:20:39 <SamB> buy me a PC
11:20:49 <shapr> But I could buy a nice Athlon 64 X2 with 4GB of ram...
11:21:14 <SamB> ah, Conjure.TorrentType
11:21:27 <shapr> That would give me dual 2.2 GHz 64 bit cpus.
11:21:54 <shapr> But it's only worth it if I can get debian and especially ghc6 for amd64.
11:22:28 * shapr sends his 40MHz Toshiba laptop to SamB
11:22:44 <shapr> SamB: How fast is your PC?
11:23:21 <Taral> shapr: Yes.
11:24:03 <shapr> I would very much like to play with the smp support in ghc6.5 on a dual amd64. Are there amd64 debs for ghc6?
11:24:28 <Taral> wtf/
11:24:32 <Taral> MiniHTTP.hs has this code:
11:24:38 <Taral> x `elem` map ord [ ... ]
11:25:00 <Taral> brownie points for the first to spot the WTF
11:25:21 <shapr> parens needed?
11:25:29 <shapr> x `elem` (map ord [...]) ?
11:25:32 <Taral> no
11:26:19 <shapr> Switch to filter to make it lazy?
11:26:22 <Taral> chr x `elem` "..."
11:26:33 <shapr> Oh good point.
11:26:43 <Taral> what's worse is that afterwards it says:
11:26:48 <Taral>         -- wouldn't it be nice if the compiler
11:26:48 <Taral>         -- optimised the above for us?
11:26:55 <Taral> O.o *blam blam blam*
11:26:57 <shapr> Taral: Have you read Rabhi & Lapalme's FP Algorithms book?
11:27:02 <Taral> shapr: No.
11:27:05 <shapr> You'd probably like Burstall & Darlington.
11:27:48 <Taral> Whoever wrote that code in MiniHTTP didn't realize that instance Ord Char
11:28:12 <SamB> shapr: my debian box has a 450 MHz PII
11:28:18 <Heffalump> shapr: do you have an dual amd64?
11:28:43 <shapr> Igloo: I found a ghc6 deb for amd64, and yet, I've read many places that amd64 in 64-bit mode is not an officially supported arch. Is the amd64 deb you maintain a 32 bit or 64 bit binary?
11:29:12 <SamB> shapr: can't file tell you that
11:29:15 <SamB> ?
11:29:15 <ADEpt> Taral: fix & send! :)
11:29:22 <shapr> Heffalump: Not at this moment, but if I click "till kassan" I will.
11:29:54 <Heffalump> and how much poorer will you be? :-)
11:29:56 <shapr> But before I purchase such a PC, I'd like to know if I can run debian/unstable, and especially ghc6, in 64 bit mode.
11:30:16 <shapr> 11741 kronor poorer.
11:30:45 <Heffalump> urchin is a dual Xeon with EM64T. You can have an account on it if that would help you not want to buy a machine of your own :-)
11:31:19 <shapr> That includes 4GB of pc3200 corsair ddr dimms and a passable nvidia graphics card...
11:31:21 <Heffalump> (it runs i386 stable userland, but uses a 64 bit kernel and has chroots for doing other stuff)
11:31:34 <SamB> shapr: wget, ar, tar, & file can tell you what kind of binary it is
11:31:35 <shapr> I wish OpenGraphics were ready, I'd spend 500 euro on one of the FPGA dev boards instantly.
11:31:39 <shapr> SamB: good point!
11:31:42 <gour> shapr: gentoo?
11:31:46 * gour grins
11:32:17 * gour runs away
11:32:17 <shapr> gour: No thanks, I prefer apt-get and binary packages.
11:32:51 <jethr0> heffalump, i've not been too happy with "debian amd64 unstable ghc"
11:32:53 <shapr> Heffalump: Thanks for the offer, but I already have an SMP desktop, I just want to go 64 bit and buy more ram.
11:33:15 <Heffalump> jethr0: no, I haven't bothered trying it yet either.
11:33:17 <shapr> Sadly, my SMP desktop requires registered ECC memory, which is insanely expensive.
11:33:30 <Heffalump> shapr: you know that EM64T is the amd64 arch?
11:33:36 <Heffalump> or sub-arch or whatever
11:33:37 <SamB> shapr: "... and has chroots for doing other stuff"
11:33:44 <jethr0> heffalump, i have, but am using chrooted 32bit version at the moment :(
11:33:47 <Taral> Which one is more efficient? foldl or foldr?
11:33:57 <Heffalump> Taral: depends
11:33:59 <SamB> Taral: foldr
11:34:03 <Heffalump> what are you doing? Is the thing strict?
11:34:11 <shapr> g'day SyntaxNinja 
11:34:12 <Taral> Not really.
11:34:24 <Taral> It could be without penalty, but it's not written that way
11:34:29 <Taral> It's a String -> String
11:34:34 <SamB> if you want an efficient left-associative strict fold, foldl' is your function
11:34:50 <Taral> @type foldl'
11:34:51 <lambdabot> Not in scope: `foldl''
11:34:56 <Taral> @type List.foldl'
11:34:57 <lambdabot> Not in scope: `List.foldl''
11:35:02 <Heffalump> foldl' is only useful with a strict operation
11:35:04 <Taral> @hoogle foldl'
11:35:05 <lambdabot> Prelude.undefined :: a
11:35:05 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
11:35:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:35:05 <Cale> you almost never want a left-associative non-strict fold.
11:35:09 <Taral> ?!
11:35:13 <SamB> @type Data.List.foldl'
11:35:13 <Taral> I hate that.
11:35:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:35:22 <Cale> There are cases of course
11:35:39 <Heffalump> making your operation strict and using foldl' is probably best.
11:35:42 <Cale> but usually you want foldr, and when you don't want that, you usually want foldl'
11:35:52 <Heffalump> next best is using foldr
11:36:18 <Taral> hm
11:36:18 <Heffalump> (where best = most efficient, which was the criterion you stated)
11:36:27 <Taral> for list processing, foldl is not happy
11:36:30 <Cale> foldr will work on infinite input lists
11:36:45 <SamB> > foldl' (flip (:)) [] "Hello, World!"
11:36:46 <lambdabot> "!dlroW ,olleH"
11:36:47 <SyntaxNinja> hi shapr
11:36:58 <Taral> > foldl' (:) [] "Hello world"
11:36:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:36:59 <lambdabot>   Expected type: a -> [a] -> a
11:36:59 <lambdabot>   Inferred type: a -> [a] -> [a]
11:37:02 <Taral> heh
11:37:05 <Taral> yeah, no go for me
11:37:10 <Taral> foldl' has a tendency to reverse the list
11:37:11 <soysauce> how can foldr work on infinite lists? Doesn't it have to start bottom-up?
11:37:12 <Cale> http://vx.hn.org/autoshare/folds.png -- folding diagram
11:37:23 <Cale> foldr is very natural
11:37:24 <Taral> soysauce: It's lazy.
11:37:37 <soysauce> laziness doesn't help when you start at the bottom of an infinite list
11:37:37 <SamB> Taral: isn't that tendancy so perfectly realized in the foldl'-based reverse?
11:37:41 <soysauce> it takes a long time to get there
11:37:49 <Cale> soysauce: foldr is the one that doesn't have to start at the end
11:38:07 <Cale> (see the folds diagram)
11:38:38 <Heffalump> oh, if you want to process your answer incrementally (and that's possible) then foldr is always best
11:38:44 <Taral> hehehe
11:38:45 <Taral> urlEncode s = foldr (\c cs ->
11:38:46 <Taral>     if isReserved c then
11:38:46 <Taral>         let (a, b) = ord c `divMod` 16 in '%' : intToDigit a : intToDigit b : cs
11:38:46 <Taral>     else
11:38:46 <Taral>         c:cs) [] s
11:38:52 <Heffalump> soysauce: you start at the top, not the bottom.
11:38:54 <SamB> soysauce: if fold an operation that doesn't consume its entire argument in evaluating to WHNF, you can handle infinite lists fine
11:38:54 <Cale> If f can return something after just looking at its left parameter, the thing will work on infinite lists
11:38:55 <soysauce> oh, heh, I see...
11:38:59 <Heffalump> From the point of view of demand, that is, which is how laziness work.
11:39:39 <SamB> Taral: urlEncode is *not* a bottleneck
11:39:49 <Cale> Laziness is outermost leftmost evaluation with sharing.
11:39:51 <SamB> that probably only gets called about once every ten seconds
11:39:57 <soysauce> > foldr1 (:) [] [1,2,3]
11:39:58 <Taral> SamB: So?
11:39:58 <lambdabot> Couldn't match `[t -> t1]' against `t -> t1'
11:40:02 <Taral> It was FUN.
11:40:04 <soysauce> > foldr1 (:) 0 [1,2,3]
11:40:04 <lambdabot> Couldn't match `[t -> t1]' against `t -> t1'
11:40:12 <SamB> Taral: well, if you are going for clarity or prettiness, cool ;-)
11:40:13 <soysauce> > foldr (:) [] [1,2,3]
11:40:14 <lambdabot> [1,2,3]
11:40:17 <Taral> :)
11:40:25 <Taral> The old one was YUK
11:40:34 <soysauce> weird, that's very, very difficult to understand, but I see how it works now.
11:40:35 <Cale> > let m f = foldr ((:) . f) [] in m (*10) [1,2,3]
11:40:36 <lambdabot> [10,20,30]
11:40:47 <soysauce> you can process an infinite list because you don't really have to hit the bottom first
11:40:52 <Cale> right
11:41:02 <SamB> though I'd suggest using a named function rather than a lambda
11:41:05 <soysauce> it's the same as 1:foldr (:) [] [2,3]
11:41:13 <Cale> yep
11:41:30 <Cale> and if you only care about the first element, that's as far as the evaluation goes
11:41:40 <soysauce> yeah, I see
11:41:52 <Taral> jlouis is using greylisting
11:41:56 <Heffalump> soysauce: whereas you would have to with foldl
11:42:07 <SamB> Taral: yes
11:42:10 <Heffalump> cos the evaluation of foldl just calls foldl again until you run out of list
11:42:14 <Taral> SamB: Bah, I sent it already
11:42:16 <SamB> oh, do I need to do something about it?
11:42:21 <Taral> no
11:42:24 <Taral> I was just noting
11:42:30 <soysauce> @type sum
11:42:30 <Taral> it'll take longer for my patch to get there
11:42:31 <lambdabot> forall a. (Num a) => [a] -> a
11:42:35 <soysauce> !
11:42:38 <soysauce> @type zipWith
11:42:39 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:42:43 <SamB> I mean I sent him a patch earlier
11:43:06 <soysauce> this is what I get for attempting to code while half-dead
11:43:19 <soysauce> ah, hm
11:43:28 <soysauce> @pl \(x, y) -> (sum x, sum y)
11:43:28 <lambdabot> sum *** sum
11:43:36 <soysauce> @type (***)
11:43:37 <Taral> What happens to programs if you convert lists into their equivalent functional type?
11:43:37 <lambdabot> Not in scope: `***'
11:43:49 <Taral> @hoogle (***)
11:43:50 <lambdabot> No matches found
11:43:51 <Cale> @type (Control.Arrow.***)
11:43:52 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
11:43:52 <lambdabot> (Control.Arrow.Arrow a) =>
11:43:52 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
11:44:02 <Cale> note that (->) is an instance of Arrow
11:44:08 <SamB> Taral: what is the difference?
11:44:14 <Cale> so that type specialises to
11:44:16 * SamB points at foldr/build
11:44:19 <soysauce> pretty slick.
11:44:31 <Taral> [a] vs (a -> b -> b) -> b -> b
11:44:31 <Cale> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
11:44:33 <soysauce> @pl \(x, y) -> (sum x) > (sum y)
11:44:33 <SamB> Taral: I suppose you need to use build.
11:44:34 <lambdabot> uncurry ((. sum) . (>) . sum)
11:44:40 <Taral> @type build
11:44:41 <lambdabot> Not in scope: `build'
11:45:03 <Heffalump> build g = g (:) []
11:45:19 <Taral> mmm, yeah, basically
11:45:25 <Taral> but what is the form of g?
11:45:26 <Heffalump> build :: (forall b . (a -> b -> b) -> b -> b) -> [a]
11:45:32 <Heffalump> well, unfoldr is a build
11:45:54 <SamB> build totally needs to be added to the standard, or at least the heirarchical libs...
11:45:59 <Taral> I was imagining some interesting optimizations involving autoconverting code using pattern match on lists to using the functional lists...
11:46:01 <Heffalump> g c e = c 1 (c 2 e) is the equivalent of [1,2]
11:46:33 <Taral> no, no, that's not what I'm talking about
11:46:33 <Heffalump> Taral: that's sort of what foldr-build does
11:46:35 <SamB> Taral: well, foldr/build may be a bit less glamerous, but has the advantage of working
11:46:37 <Taral> I mean something like:
11:46:51 <Taral> case x of { [] -> a; y:ys -> b }
11:46:52 <soysauce> @pl \xs -> (\(x, y) -> (sum x, sum y)) unzip xs
11:46:53 <lambdabot> (sum (fst unzip), sum (snd unzip))
11:47:02 <Taral> turns into x (\y ys -> b) a
11:47:17 <Heffalump> you could do that, yes
11:47:28 <Taral> then it might be possible to inline x?
11:47:29 <Heffalump> foldr-build fusion is a special case of that that is actually done today.
11:47:37 <Taral> Yes, I know about foldr/build
11:47:41 <Taral> but foldr is more restrictive
11:47:58 <ADEpt> SamB: how about I make WireProtocol -> Conjure.WireProtocol transition?
11:48:08 <Heffalump> the optimisation you describe is perfectly possible
11:48:10 <SamB> Taral: what is wrong with foldr?
11:48:16 <Taral> @type foldr
11:48:17 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:48:17 <SamB> ADEpt: sure
11:48:18 <Heffalump> but it's probably hard to implement, as with full deforestation.
11:48:22 <SamB> be sure to darcs mv
11:48:22 <Heffalump> Because you have to make sure to terminate.
11:48:28 <SamB> or move or whatever its called
11:48:31 <Taral> Heffalump: Ah.
11:48:45 <Taral> foldr tries to process the whole list
11:48:47 <Heffalump> this is why short-cut deforestation (foldr/build) caught on
11:48:53 <soysauce> @hoogle foldr1'
11:48:54 <lambdabot> Prelude.undefined :: a
11:48:54 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
11:48:54 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:48:56 <Heffalump> because it's easier to implement
11:49:02 <Taral> What is deforestation?
11:49:03 <Heffalump> no termination issues, just some rewriting
11:49:03 <SamB> foldr doesn't insist on processing a whole list...
11:49:13 <Heffalump> roughly speaking, it's the optimisation you just described.
11:49:20 <SamB> Taral: well, foldr/build is "a short cut to deforestation"
11:49:21 <Taral> SamB: Use foldr to implement tail.
11:49:23 <Heffalump> Take a producer of (:) and [], and a consumer of them.
11:49:31 <Cale> @type GHC.Exts.build
11:49:31 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
11:49:37 <Heffalump> and fuse the two together by inlining
11:49:48 <Taral> Heffalump: Yeah, I've seen that in the GHC code.
11:49:49 <Taral> They use rules.
11:49:52 <Heffalump> the precise mechanics aren't quite what you describe, but the principle is the same.
11:49:56 <SamB> > let tail = foldr (flip const) in tail "Hello"
11:49:56 <lambdabot>  add an instance declaration for (Show ([a] -> [Char]))
11:49:58 <Heffalump> Taral: right, to do foldr-build deforestation.
11:50:07 <Heffalump> which is a special case, that doesn't have termination issues
11:50:15 <SamB> > let tail = foldr (\_ xs -> xs) in tail "Hello"
11:50:16 <lambdabot>  add an instance declaration for (Show ([a] -> [Char]))
11:50:19 <Heffalump> whereas with full deforestation you have to be quite careful when unfolding definitions.
11:50:20 <SamB> erg,
11:50:25 <SamB> I see what you mean.
11:50:28 <Taral> :)
11:50:28 <SamB> sort of.
11:50:31 <Heffalump> too little and you don't optimise anything, too much and you go into an infinite loop
11:50:37 <Taral> foldr wants to be recursive
11:50:38 <Heffalump> SamB: it's not possible, don't bother trying
11:50:55 <Taral> Heffalump: I understand.
11:51:00 <soysauce> SamB - don't you need an initial parameter to foldr?
11:51:05 <soysauce> unless you want foldr1
11:51:06 <Taral> I don't mind insisting that my programmer provide a termination proof before I do the optimization.
11:51:07 <soysauce> which it looks like
11:51:08 <Cale> Taral: foldr isn't recursive?
11:51:11 <Taral> I just want the optimization available.
11:51:18 <Taral> Cale: It is recursive.
11:51:23 <Taral> I want a non-recursive provider of (:) []
11:51:33 <Taral> in fact...
11:51:37 <Cale> er...
11:51:40 <SamB> provider?
11:51:42 <soysauce> > let tail = foldr1 (\_ xs -> xs) in tail "Hello"
11:51:43 <lambdabot> 'o'
11:51:46 <Heffalump> Taral: well, most interesting cases involve recursive providers.
11:51:51 <Taral> Heffalump: I see that.
11:51:57 <Heffalump> lists of statically known length aren't very useful
11:52:21 <Cale> Well, without the static guarantees they're not anyway
11:52:42 <Taral> But if I have make_some_list, and WPA shows that the only user of make_some_list is an expression (make_some_list !! 2), I want that optimized.
11:53:04 <Taral> but !! is not eligible for foldr/build
11:53:14 <Cale> Well, it's not that bad
11:53:24 <SamB> hmm
11:53:34 <SamB> foldl?
11:53:43 <Cale> You build at most 3 cons cells.
11:53:49 <SamB> no, probably not.
11:54:00 <Taral> Cale: In this case, yes, but in general?
11:54:13 <Taral> @type cycle
11:54:14 <lambdabot> forall a. [a] -> [a]
11:54:22 <Taral> (cycle [1]) !! 5000000
11:54:23 <Cale> !! doesn't work well with large arguments the way it is anyway
11:54:31 <Taral> that is optimizable, no?
11:54:41 <Cale> if you're really clever, sure
11:54:46 <Taral> I WANT THAT. :)
11:54:46 <Cale> but that's not typical
11:54:55 <SamB> its important to have an application in mind when discussing optimization
11:54:56 <Taral> Now that I think of it...
11:55:06 <Taral> I would like to be able to provide optimizations in my code.
11:55:07 <Cale> Usually that sort of analysis won't help too much
11:55:11 <Cale> you can
11:55:18 <Taral> ?
11:55:19 <SamB> RULES
11:55:19 <Cale> at least, with GHC
11:55:21 <xerox> > take 3 . intersperse 'o' . cycle $ "l"
11:55:22 <lambdabot> "lol"
11:55:30 <Cale> yeah, you can use the RULE pragma
11:55:36 <Taral> Are there things you can't do with rules?
11:55:43 <Taral> Say... automemoization?
11:56:02 <Cale> It basically lets you rewrite code arbitrarily, by the looks of it
11:56:10 <SamB> I added one to FPS because dons was writing packAddress "foo"# where I wanted to see pack "foo", which effectively translates the latter to the former...
11:56:15 <Cale> in a totally unsafe fashion
11:56:26 <soysauce> @hoogle foldl'
11:56:26 <Taral> But I don't think you can restrict the domain of rules -- they apply to everything
11:56:27 <lambdabot> Prelude.undefined :: a
11:56:27 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
11:56:27 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:56:28 <Cale> though you shouldn't do automemoisation that way
11:56:31 <soysauce> @type foldl'
11:56:32 <lambdabot> Not in scope: `foldl''
11:56:36 <SamB> Taral: nah
11:56:37 <Taral> @type Data.List.foldl'
11:56:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:56:39 <Cale> write a memo function
11:56:42 <soysauce> ah
11:56:42 <SamB> only to the functions named in the LHS
11:56:44 <Taral> Hm.
11:56:46 <Taral> ML has memoize
11:56:49 <Cale> using unsafePerformIO
11:56:54 <Taral> it's a special form
11:57:01 <Taral> er, macro
11:57:01 <Cale> you can write a whole variety of memoisers
11:57:07 <Taral> converts the function into a memoized form
11:57:09 <SamB> so if you restrict the visibility of the functions on the LHS, there is no problem about the rule escaping...
11:57:22 <soysauce> @type Data.List.foldr1'
11:57:22 <lambdabot> Not in scope: `Data.List.foldr1''
11:57:25 <soysauce> @type Data.List.foldr'
11:57:26 <lambdabot> Not in scope: `Data.List.foldr''
11:57:29 <Cale> The reason we don't have one of those is that it's hard to say what properties you want it to have
11:57:37 <Taral> I suppose.
11:57:43 <SamB> Taral: well, in Haskell, you need to be more specific about exactly what memoization you want
11:57:49 <Cale> How many of the last sequence of calls do you want to memoise?
11:57:53 <Cale> Infinitely many?
11:58:01 <Cale> What kind of structure will you keep them in
11:58:02 <Cale> ?
11:58:02 <soysauce> crap.
11:58:14 <Cale> This puts constraints on the types involved too
11:58:16 <Taral> Hm! More to think about then.
11:58:20 <SamB> and !! is a lousy way to memoize
11:58:37 <Cale> The thing to do is to write generic memoisers of varying kinds
11:58:53 <Cale> There's a whole paper on how to do it :)
11:59:01 <Taral> Do they transform the function source?
11:59:04 <SamB> what happened to the library?
11:59:06 <Cale> no
11:59:11 <SamB> Taral: of course not
11:59:12 <Taral> How do they deal with a recursive function?
11:59:41 <Cale> memo :: (Something a) => (a -> b) -> (a -> b)
11:59:51 <Cale> so in some sense you're transforming the function
11:59:54 <xerox> @djinn (a -> b) -> (a -> b)
11:59:55 <lambdabot> x :: (a -> b) -> a -> b
11:59:55 <lambdabot> x x1 x2 = x1 x2
12:00:04 <Cale> just wrapping it with a memo table check
12:00:12 <Cale> and something to write into a memo table
12:00:20 <Taral> See, but I want to transform the function f such that all recursive calls go via the memo table too
12:00:33 <Taral> And I want to do it in a way that provably doesn't change the semantics of the function.
12:00:35 <Cale> they will
12:00:42 <Cale> and you can
12:00:42 <Taral> Cale: ?
12:00:47 <SamB> Taral: that sounds like something for an "impure thaughts" column
12:00:52 <SamB> er, thoughts
12:00:54 <Taral> SamB: Huh?
12:01:05 <Taral> Cale: They won't in your memo function
12:01:11 <SamB> Taral: in TMR
12:01:17 <Taral> heh
12:01:32 <Taral> Cale: Consider a fib function:
12:01:34 <Taral> fib 1 = 1
12:01:36 <Taral> fib 2 = 1
12:01:41 <Taral> fib n = fib (n-1) + fib (n-2)
12:01:52 <Taral> memo fib will not rewrite those recursive calls
12:03:00 <Cale> fib = memo ufib; ufib 0 = 1; ufib 1 = 1; ufib n = fib (n-1) = fib (n-2)
12:03:06 <Taral> that's not what I wrote though
12:03:09 <Taral> nor is it what I want
12:03:14 <SamB> Taral: shoulda used the "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)" version...
12:03:14 <Sine2UNI> i've got this function, but i want it to return an error if N is bigger than the length of the string...
12:03:15 <Taral> I want the memoization separate from the function definition
12:03:15 <Cale> okay
12:03:23 <Sine2UNI> http://pastebin.com/461303
12:03:32 <Sine2UNI> does anyone know how to implement that?
12:04:01 <dcoutts> SyntaxNinja, the latest version of cabal doesn't like programs being specified without a full path. At least for the haddock part.
12:04:12 <SamB> could you stand doing the function definition in [d| |] brackets?
12:04:18 <Sine2UNI> i tried suffixesint _ >(length _) = error "whatever" but that didnt work
12:04:25 <Taral> SamB: I was thinking of TH too.
12:04:26 <xerox> Sine2UNI: what should it do?
12:04:37 <Cale> well, you could do it with a rule, I think
12:04:40 <Taral> But TH isn't for verified correct S-S transforms.
12:04:53 <Sine2UNI> xerox: well, it should report an error if the int is bigger than the length of the string
12:05:02 <Sine2UNI> its not necessary but i think it would be a nice thing to implement
12:05:24 <dcoutts> SyntaxNinja, in Distribution.Simple the haddock function is using rawSystemProgram which requires a fully qualified path for the executable.
12:05:48 <Saulzar> Sine2UNI, You would do best to match on [] for the empty string 
12:06:03 <xerox> > let f xs n | n > length xs = "Ow, noo!" in f "hi!" 4
12:06:04 <lambdabot> "Ow, noo!"
12:06:15 <SamB> Taral: well, there isn't much for that
12:06:30 <Igloo> shapr: 64bit
12:07:05 <Sine2UNI> xerox: suffixesint _ (n > length _) = error "test"
12:07:07 <Sine2UNI> ?
12:07:07 <Taral> Thanks everyone for helping me work through this.
12:07:33 <Taral> It's clear what I want is a source-to-source transformer for haskell linked with some proof engine :)
12:07:38 <Sine2UNI> or is that completely off
12:07:45 <Taral> Sine2UNI: You want a guard
12:07:46 <xerox> Sine2UNI: <name> <arg1> .. <argN> | <condition1> = <expression1> | .. | otherwise = <expressionN>
12:07:57 <dcoutts> SyntaxNinja, rawSystemProgram uses rawSystemVerbose which requires a full path to the program. I was going to send a patch to use rawSystemPath but that assumes it is not a full path. We need one that works with either.
12:08:05 <Cale> Taral: also, most of the time in Haskell, you fight against things being memoised too much anyway
12:08:11 <Taral> Cale: True.
12:08:17 <Sine2UNI> ah ok, thanks a lot guys
12:08:22 <Sine2UNI> i'll get working on it and hand it in
12:08:27 <SamB> Cale: what things are memoized too much?
12:08:33 <ADEpt> jlouis: what's better - send or you pull from me?
12:08:34 <shapr> Igloo: thanks!
12:08:41 <Cale> SamB: every space leak is essentially just that
12:08:52 <SamB> Cale: hmm
12:09:02 <dcoutts> SyntaxNinja, we used to be able to say --with-ghc=ghc-6.4.1 and it'd work. With the latest Cabal it doesn't work, at least for the haddock phase.
12:09:10 <Cale> You have values that are being held unevaluated due to laziness, say
12:09:25 <Heffalump> Taral: why do you write programs with constant arguments to !!, anyway?
12:09:28 <ADEpt> SamB, jlouis, Taral: i've done another bit of my make-shift peer-thread construction.
12:09:34 <Cale> well, often it's due to sharing
12:10:09 <shapr> Too bad I can't buy a cell based workstation. That would be way nifty.
12:10:27 <xerox> shapr: build it?
12:10:35 <Heffalump> bah, get something with lots of ARMs instead :-)
12:10:52 <SamB> save the money to develop wimax nodes with ;-)
12:11:10 <xerox> I'd buy an Apple laptop :)
12:11:11 <shapr> Heffalump: Does linux support clumps of ARMs?
12:11:43 <Cale> Taral: anyway, this paper is probably of interest to you :) http://research.microsoft.com/Users/simonpj/Papers/weak.htm
12:11:55 <shapr> I'd be fine with a mainboard that holds eight or sixteen smaller CPUs that runs Linux.
12:12:08 <Heffalump> no idea. I doubt it, since I don't think silicon for the SMP ARMs exists yet.
12:13:09 <shapr> I just want Linux on lots of CPUs. I'm not picky about the arch.
12:13:37 <Heffalump> I don't think Cell is a good choice for that.
12:13:43 <Muad_Dibber> i'm not picky either...if its amd, 64 bit, and at least 3000+.
12:13:45 <Heffalump> a vector processor is not a general purpose CPU
12:13:48 <dcoutts> shapr, SUN are doing 8x4 sparc chips
12:13:53 <Heffalump> so you won't run Linux very well on the SPEs
12:13:56 <Heffalump> (if at all)
12:14:07 <shapr> Right, but I could use PArr on the SPEs.
12:14:21 <dcoutts> shapr, once linux works on those they'd be nice
12:14:37 <Janni> Hi. Long time no see. Have a lot to do lately.
12:14:38 <shapr> dcoutts: That's the new Niagara chips?
12:14:41 <SamB> so is Cell basically a replacement for shaders in the GPU?
12:14:44 <shapr> heya Janni
12:14:50 <dcoutts> though they are a little more expensive at about $3,000 for a system
12:14:59 <Janni> Nevertheless, can anybody tell me how to generate GHC's source documentation?
12:15:28 <Janni> Haven't found any useful information about that neither in the web nor in the sources.
12:15:31 <dcoutts> shapr, yes. 8 cores and 4 threads per core. Ordinary Sparc instruction set etc.
12:15:36 <SamB> Janni: I don't think it works anymore
12:15:55 <Janni> Ah...
12:16:07 <SamB> this is just a guess, though
12:16:09 <Janni> Hmm. A bit unsatisfactory
12:16:16 <dcoutts> shapr, they're selling those now. And the next version of the chip will do 8 threads per core and will have more floating point units.
12:16:18 <SamB> I have never seen it referenced either
12:16:32 <shapr> SamB: Not exactly. It's one weenie PPC and ~eight mostly vector processors. It's really good for pipelined execution since each sidekick cpu can move data to the next sidekick in just a few cycles.
12:16:45 <Janni> These are .lhs files, some kind of mutilated latex format.
12:17:04 <SamB> shapr: well, what are they for, if not for shaders?
12:17:21 <shapr> dcoutts: 3k is a bit much for me. I can get a dual core 2.2GHz amd64 with 4gb of ram for 1k.
12:18:14 <dcoutts> shapr, so for 3x that you can get 16x more simultanious threads.
12:18:29 <dcoutts> shapr, actually I'm relativly impressed with the idea of multiple threads on a single core. If it's done well it could be quite good for stuff like Haskell.
12:18:41 <dcoutts> shapr, because it hides the latency of main memory
12:19:16 <dcoutts> while one thread is stalled doing a main memory operation another can be making progress.
12:19:19 <shapr> SamB: From my viewpoint, the Cell is crying out for declarative parallelism.
12:19:58 * shapr looks for niagara details.
12:20:12 <dcoutts> shapr, Cray have a machine like that. It has something like 128 threads on one core. Every time a thread would stall due to a memory op it switches to the next thread.
12:20:47 <shapr> That's nifty, does it require a large cache to do that?
12:20:53 <dcoutts> Apparently it's great so long as you've got lots of threads.
12:20:56 <int-e> dcoutts: are you saying that Intel isn't actually being innovative? *g*
12:21:08 <dcoutts> shapr, yeah, it's probably got wadges of cache.
12:21:32 <dcoutts> it keeps the memory link well utilised
12:21:40 <shapr> dcoutts: I think the Cell cpu is another worthwhile way to speed up memory accesses.
12:21:43 <SamB> shapr: well, clearly something not integrated into a GPU is likely to be more flexible
12:22:07 <shapr> Each sidekick cpu has a chunk of local memory, call it cache or ram, whichever you like.
12:22:16 <shapr> iirc, it's small enough to be called L1 cache.
12:22:38 <Taral> Cale: That paper is interesting...
12:22:40 <soysauce> shapr - I read that an 8-node Cell has (up to) 64MB of local memory shared among the processors, so it can't be *that* small.
12:22:47 <Taral> I don't know why he's using IO when ST works.
12:22:51 <dcoutts> shapr, so the real question is, is controling the L1/L2 cache behaviour in software a performance / simplicity win?
12:23:17 <shapr> Personally, I'd like to build CPUs in a tiled square and octagon pattern on the die, where the squares are CPUs, and the octagons are local memory. Then you could sell the whole die and price it according to the how much actually works :-)
12:23:26 <araujo> http://dev.gentoo.org/~araujo/hashell.example 
12:23:42 <araujo> For those interested on a tiny haskell shell :-]
12:23:42 <dcoutts> soysauce, but each of the small cpus only has a very small local memory. On the chip as a whole there might be quite a bit.
12:23:42 * araujo should release this dirty code now
12:24:09 <shapr> dcoutts: Depends on what you're writing I think. You can't really control it from C or Haskell. But you could get Haskell to generate SSA machine code, thereby letting the CPU do more optimizations.
12:24:46 <shapr> SSA machine code would be immediately beneficial to multithreaded cores.
12:25:00 <dcoutts> I don't immediately see it
12:25:16 <jlouis> ADEpt: anything ;)
12:25:18 <Cale> Taral: ST doesn't work, as far as I can tell, because STRefs don't last long enough.
12:25:22 <soysauce> dcoutts - I was under the impression that local memory was so fast that they didn't have L1 caches. Plus caches are complex to build.
12:25:28 <Taral> STRefs last as long as a reference exists, no?
12:25:35 <soysauce> so effectively local memory itself was a slow cache.
12:25:49 <Taral> They're implemented the same way as IORefs in the backend.
12:25:53 <shapr> dcoutts: If you know a register won't be written to, you can ignore it rather than saving its state.
12:26:03 <Cale> well, references only exist inside a call to runST
12:26:18 <Cale> they're gone after the value is returned
12:26:25 <ADEpt> jlouis: then pull from me :) (do you know URL?)
12:26:30 <soysauce> although now that I think about it, you really need memories that have sub-ns latencies...so I guess a cache would be vital.
12:26:30 <Taral> Cale: Says who?
12:26:32 <shapr> That'll save writes when saving a thread, writing back to cache/main memory/etc
12:26:47 <jlouis> ADEpt: yes
12:26:59 <soysauce> shapr - hasn't that been done before?
12:27:01 <shapr> dcoutts: Does that make sense? Credits to Pseudonym for explaining that to me btw :-)
12:27:06 <Cale> Taral: well, there's no way to capture them, so they become garbage
12:27:10 <shapr> soysauce: What, generating SSA machine code?
12:27:22 <soysauce> no, saving only part of the register set
12:27:26 <Taral> Cale: Huh?
12:27:29 <dcoutts> soysauce, right, I think the point is that instead of automatic L1 cache they have local memory (same bandwidth/latency as L1 cache) that is software controled.
12:27:39 <Taral> runST $ newSTRef 0
12:27:55 <soysauce> dcoutts - L1 cache has 3 cycles latency. Good luck getting a 64MB local memory at that speed.
12:28:03 <Cale> yeah, that's equivalent to 0
12:28:05 <soysauce> er, 2-4 cycles latency generally, sorry.
12:28:07 <shapr> I don't know, but SSA machine code would let you do a state save with fewer writes.
12:28:19 <soysauce> from what I understand, most CPUs have 3-cycle L1 caches.
12:28:31 <dcoutts> soysauce, no, the local memory on each SPU is very small. L1/L2 cache sized. Something like 256K.
12:28:58 <soysauce> well, I don't know, then. 256K won't run at 3 cycles, though.
12:29:03 <shapr> Yup, 256k last I heard.
12:29:06 <dcoutts> shapr, a state save? You mean for switching threads? or something?
12:29:24 <Taral> Cale: No, it's equivalent to something of type... oops
12:29:28 <Taral> :(
12:29:33 <dcoutts> shapr, unless you've got a massive register file I don't see that it's a great saving.
12:29:38 <Taral> you can't share STRefs across runSTs.
12:29:44 <shapr> On the goodside, It also can do DMA writes to main memory, and easy writes to the local memory of the SPEs on either side.
12:29:48 <Cale> right
12:30:07 <Taral> ok, makes sense now
12:30:37 <Taral> (incidentally, you can share them if you're using stToIO)
12:30:43 <Cale> yeah :)
12:31:25 <Cale> er, right, that's not 0, that's a type error :)
12:31:36 <Taral> nah, it's just a weird object
12:31:38 <shapr> dcoutts: The idea is to make writable and read-only values explicit so that the CPU hardware that does pipelining/reordering/hardware threading/whatever can do more optimizations.
12:31:40 <Taral> STRef s Int
12:32:04 <dcoutts> shapr, right
12:32:06 <soysauce> shapr - I don't think that would help too much
12:32:07 <Cale> @type Control.Monad.ST.runST (Data.STRef.newSTRef 0)
12:32:08 <lambdabot>   Inferred type is less polymorphic than expected
12:32:08 <lambdabot>   Quantified type variable `s' escapes
12:32:39 <soysauce> they already assume all reads are non-overlapping with writes and then simply restart a read when a write that came earlier in the program completes after the read completes
12:32:51 <shapr> dcoutts: As much as C programmers say they like to program the bare metal, they're actually nowhere close... CPU pipelines do so much under the hood that you can't really touch the bare metal anymore.
12:32:57 <soysauce> so if your reads and writes don't overlap, then you get good performance
12:33:05 <Cale> the higher rank polymorphism forces you to pass something polymorphic in state type
12:33:27 <dcoutts> shapr, yeah, C grows further and further from the bare metal. Haskell is more or less the same distance it's always been.
12:33:42 <jethr0> how can i get the ghc sources to build them? i can't seem to find the cvs address
12:33:52 <soysauce> shapr - it's a lot more deterministic than that. C doesn't come close, but you can still control the pipelines to a large extent.
12:33:57 <dcoutts> shapr, perhaps yhc might be a good test case of seeing if Haskell could adapt to a call-like arch.
12:33:59 <shapr> soysauce: I think it would make a serious difference, but I'm always looking for more information on the subject.
12:33:59 <soysauce> from assembly
12:34:36 <araujo> Haskell grows horizontally instead of vertically like most of imperative languages.
12:34:36 <soysauce> shapr - there's a whitepaper regarding the P4 and its "replay" feature
12:34:47 <dcoutts> shapr, have bytecode interpeters run on each spu. Defer to the central cpu for primitive IO ops.
12:35:05 <shapr> dcoutts: that would be cool!
12:35:28 <shapr> soysauce: Can you give a summary?
12:35:42 <soysauce> already did, but to clarify, I'll repeat
12:35:50 <soysauce> basically all ops proceed unmolested through the core
12:36:01 <dcoutts> shapr, or better. Restructure the yhc runtime so that like ghc it has an IO manager thread and all IO goes to the IO manager which runs on the centeral cpu.
12:36:14 <soysauce> whenever it detects an op dependent on a read, it schedules it so that it executes in the same cycle that data arrives from the L1 cache (2 cycles on older P4s, 3 or 4 on newer ones)
12:36:23 <Taral> @where yhc
12:36:24 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
12:36:33 <soysauce> the problem is that reads and writes are reordered, and the CPU has no way to detect when they overlap
12:36:35 <Taral> @where+ yhc http://www.cs.york.cs.uk/~ndm/yhc
12:36:36 <lambdabot> Done.
12:36:39 <Taral> @where yhc
12:36:40 <lambdabot> http://www.cs.york.cs.uk/~ndm/yhc
12:36:41 <soysauce> so it assumes that they never do.
12:36:49 <jethr0> taral, is that for ghc?
12:36:51 <dcoutts> shapr, then the main part of the yhc runtime like GC etc would run on the main CPU. Each SPU would only run a minimal version of the bytecode interpreter.
12:36:56 <Taral> jethr0: No, yhc.
12:37:13 <jethr0> any idea where i can checkout ghc/
12:37:14 <soysauce> *if* a write completes and it detects that a read completed earlier but comes later in the program order, then it will restart the read
12:37:14 <jethr0> ?
12:37:18 <Taral> @where+ yhc http://www.cs.york.ac.uk/~ndm/yhc
12:37:18 <lambdabot> Done.
12:37:24 <Taral> I am durrrr
12:37:33 <soysauce> which is relatively expensive, but since reads and writes rarely overlap, it helps
12:37:41 <dcoutts> shapr, so the centeral cpu would spend most of it's time managing memory requests for the spus, doing GC and IO.
12:37:50 <soysauce> which is something like what you were describing
12:37:54 <shapr> soysauce: Ok, so that's the P4, but... is that true of CPU piplines in general?
12:38:09 <shapr> dcoutts: Sounds like the perfect structure.
12:39:16 <shapr> Are there some cpu pipelines that can tell when reads and writes overlap?
12:39:17 <soysauce> shapr - it's only slightly more advanced than competing architectures (Athlon et. al.)
12:39:21 <soysauce> no
12:39:29 <soysauce> it's never possible, so it's usually assumed that they don't
12:39:30 <shapr> Is there some way to explicitly tell which reads and writes overlap?
12:39:37 <soysauce> it's a shoot-first-ask-questions-later sort of system
12:39:55 <shapr> I wonder if EPIC lets you do that.
12:40:02 <soysauce> nope, not AFAIK
12:40:19 <soysauce> you can do a speculative load on IA-64
12:40:24 <soysauce> but that's a bit different.
12:40:49 <soysauce> it's basically a request to fetch memory into the caches, similar to preload instructions on x86. It can't cause exceptions.
12:41:06 <soysauce> IIRC on IA-64 it will actually populate the register if no exception occurs
12:41:40 <soysauce> I read an article 2 years ago that talked about x86. Many people in the industry are of the opinion that x86 is a bloated, archaic piece of crap. They're probably right.
12:42:00 <soysauce> however, it was appropriately noted that there is a silver lining to having a legacy CISC piece of hardware: instruction density.
12:42:03 <shapr> Does it cost fewer cycles to do a hardware thread swap of fewer changed registers?
12:42:16 <soysauce> I really doubt that. There is only one x86 CPU that can do that, anyway.
12:42:26 <shapr> Ok, outside of x86?
12:42:35 <soysauce> I don't know
12:42:52 <soysauce> it depends; it seems to me that the register files would be directly wired together
12:43:14 <soysauce> in the case of the P4, I *believe* it doesn't even "save" the thread state
12:43:32 <soysauce> it just has a register file of 128 registers and ops from each thread are dispatched
12:43:37 <soysauce> they share that internal register file
12:43:45 <soysauce> so there is no concept of saving the thread's registers
12:44:23 <shapr> Hm, I'll have to email Boquist again.
12:44:47 <soysauce> machines like IA-64 and SPARC might implement it differently, though. SPARC has too many registers, and IA-64 has even more. (Are there even multithreaded IA-64 cores?)
12:46:00 <soysauce> x86 is relatively easy because there are only 8 registers of import. The P4 has 128 registers to cover all in-flight instructions, and since that doesn't change with SMT, they don't need to add any more registers or even save state.
12:46:17 <shapr> lennart: Hey, you might know the answer ... Boquist's GRIN thesis says on page 194 "too much work on the GRIN back-end had already been done before we realised the real benefits of SSA also at the machine code level." Do you have any idea why SSA machine code is beneficial?
12:46:59 <soysauce> SPARC has like 512 registers...
12:47:29 <soysauce> 512+8 registers available to applications
12:47:56 <int-e> Well, that's a clear sign that there are too few multithreaded benchmarks.
12:48:17 <shapr> Actually, that's exactly why I want to get a bunch of cores...
12:48:58 <soysauce> heh, just don't get a P4 because it's a piss-poor implementation
12:49:01 <shapr> I strongly suspect I can demonstrate that declarative parallelism kicks the crap out of any sort of explicitly threaded system in terms of scaling from one to one thousand cores.
12:49:03 <int-e> still it'd be nice if context switches on a single core wouldn't be so expensive. which reminds me, the Transputer had 3 registers, if I remember correctly.
12:49:09 <soysauce> 8K L1 cache was already small enough; now both cores share that 8K L1.
12:49:29 <shapr> soysauce: Not only that ... oh I won't go into the details of the crappy P4 multi-core design.
12:49:52 <soysauce> int-e - that's why Cell does away with the MMU
12:50:09 <shapr> The amd64 X2 cores I'm looking at both come with 512k L1 cache.
12:50:12 <soysauce> and that was also (part of) the motivation behind single-address space operating systems
12:50:20 <soysauce> shapr - heh :-)
12:50:23 <soysauce> I'm familiar with it
12:50:42 <shapr> Wait, doesn't each SPE have it's own DMA/MMU ?
12:50:56 <soysauce> I bought a P4-D to play around with, but it was mainly to have another machine as well as to play with AMD64
12:51:09 <soysauce> shapr - there are no MMUs in Cell architecture
12:51:27 <shapr> Hm, then the wikipedia page is wrong...
12:51:36 <soysauce> it could have changed since I read about it
12:51:58 <soysauce> there's an MMU, just not in the traditional sense. There is no virtual memory...
12:52:20 <soysauce> since there is no mapping being done, memory accesses just go straight through (fast) and there is logic to check for exceptions
12:52:29 <shapr> "The MFC DMA engine has an MMU for address translation and protection using the standard PowerPC segment table and page table model." from http://www-128.ibm.com/developerworks/power/library/pa-celldmas/
12:52:36 <int-e> hmm. there's a lot you could do with tagged TLBs. I'm not sure I'd be happy without an MMU.
12:52:40 <shapr> No clue if that matches what you said or not... but it appears relevant :-)
12:53:22 <soysauce> int-e - memories are large enough these days that, if programmers were not so comfortable with their inefficiencies, virtual memory would be obsolete
12:54:16 <SamB> soysauce: so how do you do memory mappings?
12:54:17 <soysauce> shapr - I meant that the SPEs do not have MMUs. There is an MMU for the whole unit, itself.
12:54:22 <soysauce> SamB - you don't
12:54:37 <shapr> soysauce: That quote is for the MFC for each SPE.
12:54:38 <soysauce> er, oh, in reference to my comments about virtual memory?
12:54:50 <soysauce> shapr - look at the system diagram
12:54:56 <shapr> "Dedicated DMA engines of each of the SPEs can move streaming data in and out of the local stores in parallel with the program execution. Each MFC contains the DMA control unit and the Memory Management Unit (MMU) for that SPE."
12:55:07 <soysauce> yeah, I see
12:55:11 <soysauce> hm, I don't know...
12:55:15 <int-e> ok. good bye, shared libraries then ...
12:55:16 <tuomov> umm.. it's useful to have read-on-access for stuff from the disk
12:55:21 <tuomov> isn't that virtual memory?
12:55:28 <shapr> soysauce: You definitely know more than I do, I'm just quoting the page...
12:55:29 <SamB> P4s don't even support AMD64, I hear...
12:55:29 <SamB> but only EMT64
12:55:30 <soysauce> tuomov - yes
12:55:33 <SamB> which is apparantly not quite identical
12:55:40 <soysauce> shapr - but my information is outdated ;)
12:55:50 <soysauce> when I last read up on Cell, there were no L1 caches
12:56:02 <soysauce> int-e - no, shared libraries are still possible
12:56:14 <soysauce> SamB - EMT64 == AMD64 for all practical purposes
12:56:40 <soysauce> I saw the differences, once. It was something retarded. They don't support syscall/sysret in 32-bit mode, and I think that was the only difference.
12:56:51 <soysauce> plus they have SSE3 which is not strictly part of AMD64.
12:57:38 <soysauce> int-e - you're thinking in terms of current designs. In SAS, all processes reside in a *single* shared, protected address space. If you want to share memory with another process, then you ensure that it has access to that memory, and you pass it a pointer to the memory.
12:57:42 <musasabi> argh. Yet more Handle cripling.
12:58:16 <soysauce> int-e - think "DOS" if you recall those days. You can write anywhere. The only difference is that SAS mandates hardware protection, so where you can read/write is limited.
12:58:35 <int-e> soysauce: hmm. I guess there are two main differences then. a) there's no address translation b) the granularity of protection is much coarser.
12:58:45 <musasabi> hTell checks whether Haskell thinks it should seek the Handle and if not, no position information ;_;
12:59:06 <int-e> soysauce: (compared to current VM systems)
12:59:07 <SamB> soysauce: swapping might not be so useful these days, but there remains mmap
12:59:14 <soysauce> int-e - yes, there is no translation, but I don't think the granularity of protection necessarily differs. It could even be smaller since you save a lot of data.
12:59:23 <soysauce> well, yes, nothing can beat a true VM
12:59:49 <int-e> soysauce: if you get the same granularity of protection, you can implement memory mapped files. you said you couldn't do that.
12:59:57 <soysauce> BTW, "no translation" is what I say, but SAS does not mean that there is no translation
13:00:07 <soysauce> it just means that there is only one set of page tables
13:00:10 <SamB> ah
13:00:17 <SamB> but, tagged entries?
13:00:29 <int-e> for protection ... most likely.
13:00:42 <jethr0> i say potato and you say potata, i say SSA and you say SAS, *lalila*
13:00:58 <soysauce> if you Google for SAS research, most SAS systems use their 64-bit address space with translation to implement distributed systems and persistent objects
13:01:03 <SamB> SSA is Single Static Assignment...
13:01:07 <int-e> oh. you could do the protection on a different level ... like using segment registers on x86 (yuck)
13:01:07 <jethr0> i know
13:01:41 <soysauce> Cell doesn't do translation, though, or at least not according to what I had read.
13:01:47 <SamB> int-e: well, the idea is nicer than the implementation
13:02:25 * int-e actually knows a kernel that does exactly this, Pistachio for 'small address spaces'.
13:03:34 <int-e> but x86 has this awful automatic MMU that does not support partial flushes (has this improved in any of the newer processors?)
13:03:42 <dcoutts> shapr, wrote it up here: http://haskell.org/hawiki/Yhc_2fIdeas
13:03:48 <soysauce> int-e - Opteron/Athlon64 do partial flushes
13:04:09 <SamB> partial flushes?
13:04:37 <int-e> well, it's a TLB, and you usually have some TLBs that don't change over a context switch
13:04:38 <soysauce> there are 3 ways to flush the cache: task switch, reload the cr3 (page directory pointer) register, or the newer clflush instruction. On K8 (Opteron/Athlon64) the first two are no-ops. ;)
13:04:41 <SamB> jlouis: apply patches!
13:04:44 <int-e> so you'd like to keep them.
13:04:57 <int-e> (even in an untagged TLB design)
13:04:57 <shapr> dcoutts: cool
13:04:58 <soysauce> when you write to a page table entry in memory, the CPU automatically updates the TLB
13:05:02 <SamB> Taral: do you have a web-accessibly repo?
13:05:15 <soysauce> this is what I read, at least.
13:06:36 <soysauce> http://www.chip-architect.com/news/2003_09_21_Detailed_Architecture_of_AMDs_64bit_Core.html#3.16
13:06:48 <soysauce> "Until now there was only one way to guarantee TLB coherency:  Flush the TLB's if it may be possible that any of the entries is not identical anymore to the memory resident tables. Many actions in the x86 architecture result in an automatic flush of the TLB's, often unnecessary. A new feature in the Opteron: The TLB flush filter can avoid these costly flushing in many occasions."
13:06:50 <jlouis> SamB: Oh fuck! What did I do in that patch, hehe ;)
13:07:53 <soysauce> hm, I guess it doesn't automatically update, but it can prevent unnecessary flushes
13:08:58 <jlouis> SamB: Conjure updated, all patches applied. Will check later when I have time
13:09:11 <soysauce> int-e - BTW, a feature that has been around in the x86 MMU for a while are "global pages" which are never flushed. On Windows, the kernel is kept in global pages, and it is possible to have some parts of the OS kept in large pages as well to conserve TLB entries.
13:09:41 <dcoutts> Anyone know where to sned Cabal bug reports? I thought there was a trac database now, but I can't find any refernce on the Cabal web pages.
13:10:37 <araujo> dcoutts, as far as i know libraries@haskell.org
13:11:20 <dcoutts> araujo, yeah, though there is a bug db. Perhaps it's still the debian one.
13:11:53 <jlouis> SamB, ADEpt: Now I know what you talked about re infohash and piecehash
13:12:02 <jlouis> (Thanks to SamB's patch)
13:12:41 <shapr> How often do you find your own code from long ago when searching for a solution on google?
13:12:45 * shapr grumbles...
13:13:32 <SamB> jlouis: if you look, you'll notice the infohash is calculated by bencoding the info table and hashing it
13:13:55 * jlouis nods
13:14:08 <jlouis> shapr: haha
13:14:13 <jlouis> google++
13:14:29 <SamB> @karma google
13:14:30 <lambdabot> google has a karma of 0
13:14:39 <SamB> hmm, that must be #perl6 syntax
13:14:48 <Taral> SamB: I don't have a repo :(
13:15:00 <SamB> Taral: why not?
13:15:07 <ADEpt> SamB, jlouis: so, what are the short-term plans? :) 
13:15:12 <Taral> Because I don't have anything to repo.
13:15:16 <Taral> What were you thinking of?
13:15:20 <SamB> Taral: darcs get it
13:15:32 <shapr> dcoutts: http://hackage.haskell.org/cgi-bin/trac/trac.cgi/roadmap
13:15:33 <Taral> darcs get what?
13:15:33 <SamB> then, you'll have it
13:15:37 <SamB> Taral: conjure
13:15:43 <SamB> which you did already
13:15:47 <Taral> Oh, I did that, yes.
13:15:51 <SamB> 'cause you can't record without one...
13:16:02 <jlouis> ADEpt: 2 sec, lets see
13:16:28 <SamB> if you look in AUTHORS, you'll notice that jlouis, ADEpt, and I have "Repo:" lines
13:16:29 <dcoutts> shapr, I suppose it'd be too much to ask that that link be added somewhere to the Cabal web page. It's impossible to find otherwise.
13:16:30 <Taral> hm, something wrong with my send command
13:16:35 <Taral> SamB: No, no repo.
13:16:40 <dcoutts> SyntaxNinja, would that be possible?
13:16:43 <Frederick> yo folks
13:16:44 <Taral> I don't know if I'm going to be doing that much work on it.
13:16:56 <SamB> Taral: point
13:17:02 <SamB> Frederick: long time no see!
13:17:14 <dcoutts> shapr, thanks for the link! (sorry for grumbling :-) )
13:17:17 <Frederick> SamB, Im studig crazy for the finals :(
13:17:18 <SamB> for some reason I'm not scared to see you again
13:17:24 <Frederick> btw a question brings me here :p
13:17:31 <jlouis> ADEpt: I am going to make FS.* into something useable. Now SamB took out my bug, I'll check it for more errors (and probably try to cook up some QC arbitrarys)
13:18:07 <jlouis> After that, I'll take a look on writing pieces back to the disk
13:18:31 <SamB> just being able to read pieces will do wonders ;-)
13:18:41 <jlouis> and after that, I am going to implement a cp(1) via the FS.* structure, copying random data
13:18:46 <ADEpt> jlouis: maybe, it will be easier to try and get "seeding" client running first?
13:19:05 <jlouis> ADEpt: oh, that is a good idea
13:19:19 <jlouis> If we can read data, we can seed
13:19:27 <Frederick> folks I got this -> http://rafb.net/paste/results/eDi17T44.html question it is not haskell it is about probabilities but I know you know the stuff :p so you you have a spare time please take a brief look :)
13:19:30 <jlouis> That is the goal for sure then
13:19:50 <ADEpt> jlouis: which reminds me, that right now the piece of code that accepts connection is a shameless stub which will do nothing after first handshake. 
13:20:06 <jethr0> @where ghc
13:20:06 <lambdabot> http://haskell.org/ghc
13:20:10 <jethr0> @where fptools
13:20:11 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
13:21:14 <SamB> jlouis: well, you can do other stuff while me and ADEpt work on sharing
13:21:39 * jlouis nods
13:21:48 <jlouis> Sounds like a plan
13:21:55 <SamB> Frederick: have you tried also #math?
13:22:06 <Frederick> SamB, yep both here and efnet
13:22:28 <ADEpt> SamB: sound like a plan. You want to tackle something in particular?
13:23:19 <SamB> ADEpt: I'm not sure
13:24:21 <SamB> I'll probably want to do whatever I can figure out at that point
13:24:31 <ADEpt> SamB: do you have any idea how to make a "bind-listen-dispatch" stuff in haskell (sorry for being probably obscure)?
13:24:58 <ADEpt> SamB: In other words, can you do a wire protocol client?
13:25:02 <SamB> ADEpt: what is the "dispatch" part?
13:25:30 <SamB> ADEpt: you mean the port listener?
13:25:59 <SamB> don't we still have a stub for that?
13:26:28 <ADEpt> SamB: re dispatch: The way I see it, some thread listens on the 6881 port, receives Wire Protocol messages, processes them, and he has to communicate with N peers, so for each new peer there should be some sort of "control dispatch" after initial handshake.
13:26:42 <ADEpt> SamB: we the the smalles stub possible. In Conjure.hs
13:27:22 <SamB> ADEpt: you mean spawning the thread?
13:27:34 <SamB> and hooking it into the peer table?
13:28:10 <SamB> well, I think we have the bind-listen part down...
13:28:46 <ADEpt> SamB: yep, something like that. 
13:29:58 <SamB> ADEpt: well, considering we don't have a peer table at this point, I'm not too sure how that would work
13:31:33 <ADEpt> SamB: but do we have to have one? Gut feeling says we should, but I am not sure. After looking at "original bittorent" sources, I am not sure how that thing works at all without breaking up - without scarcely a line of comments.
13:33:08 <shapr> heh
13:34:18 <dbremner> ADEpt - maybe it has been debugged into existance like sendmail.
13:34:23 <ADEpt> SamB: have you seen http://www.nitro.dk/~jonas/bittorrent/bittorrent-rfc.html ?
13:35:38 <SamB> ADEpt: well, we'll have to have some way to keep track of what peers we are connected to, how to communicate with the thread, the thread id, and various statistics
13:36:27 <SamB> dbremner: but python's debugger is utter trash
13:37:16 <ADEpt> SamB: OTOH, "master thread" should keep track of connected peers as well, so maybe it's high time to rip out part of the Conjure.hs into it's own file and start MasterThread.hs?
13:37:54 <SamB> ADEpt: well, yes, thats where I was thinking the table would be
13:38:50 <benny> what's better Xaskell XML Toolbox of HaXml?
13:39:19 <SamB> Haskell XML Toolbox is cool
13:39:56 <benny> HaXml seems to have a cool utility program DtdToHaskell for translating DTD into haskell types
13:40:07 <benny> does Haskell XML Toolbox have something similar?
13:40:48 <SamB> I don't think it has in the latest versions...
13:47:51 <ADEpt> SamB: i also wonder if it would be better to do all the data-related stuff not on the piece level, but on the wire protocol block level ...
13:49:18 <JoshTriplett> Is it possible to interact with foreign functions while retaining laziness?  In particular, I'd like the ability to write a lazy function of type [a] -> [b], and make use of that function from C.
13:49:43 <benny> so what's the difference between Haskell XML Toolbox and XaXml? which one is better?
13:49:45 <araujo> Interesting question...... 
13:49:55 <JoshTriplett> The idea is to construct a graph of functions of that type, some of which are written in haskell.
13:50:32 <SamB> ADEpt: oh, probably for a lot of it
13:50:42 <SamB> benny: it depends
13:51:19 <benny> one is not clearly better then the other?
13:51:30 <SamB> HXT tries to improve on HaXml and HXML as far as its representation goes
13:51:46 <JoshTriplett> Along those lines, one possibility I'm attempting to explore is to call a C function repeatedly to get a lazy list.  I tried "repeatM = sequence . repeat" and "do l <- repeatM rand ; print $ take 10 l", but the sequencing properties of IO seem to force all the rand calls to occur.
13:51:48 <SamB> but then it may be missing things like DtdToHaskell
13:51:59 <SamB> which you may or may not care about
13:52:41 <JoshTriplett> Is there some way I can take a foreign function and call it repeatedly to get a lazy list, but a given function call doesn't occur until the corresponding element is looked at?
13:53:00 <benny> hm.... but HaXml is still really good, right?
13:53:12 <SamB> also, HXT already supports Relax NG, so if you want to implement Relax NG, HXT may not be your best choice of library ;-)
13:53:40 <Heffalump> JoshTriplett: possibly with unsafePerformIO
13:54:00 <SamB> one notably missing feature is SGML support
13:54:18 <benny> don't need relaxng, don't need sgml
13:54:22 <SamB> hehe
13:54:35 <SamB> none of them support SGML anyway
13:54:58 <SamB> what do you want to do?
13:55:33 <benny> make an xhtml renderer
13:55:41 <benny> a simple one
13:55:53 <benny> and then add css3 support little by little
13:56:56 <SamB> I'd use HXT
13:57:02 <benny> why?
13:58:10 <SamB> well, for lack of a reason not to?
13:58:36 <SamB> it has better support for traversal, afaict
13:59:10 <benny> well, HaXml has this DtdToHaskell thing, so i thought i could run it on the xhtml 1.0 DTD and automatically get a haskell html tree type
13:59:34 * xinming hits his head onto the wall while learning state monad. :-/
14:00:36 <SamB> benny: eh, I think XHTML is a bit big for that
14:00:45 <benny> why?
14:01:08 <pesco> Hoi hoi.
14:01:27 <Saulzar> Automatically generated types for a big DTD might look like the dogs breakfast
14:01:39 <SamB> also, how are you going to do CSS with arbitrary Haskell values rather than an XMLish tree?
14:02:20 <benny> don't know... haven't thought at all about css yet, first i want to get regular html of the working
14:02:46 <benny> but don't you guys think that haskell is the perfect language for a web browser?
14:02:54 <SamB> ...
14:03:01 <SamB> I'm not sure there is one.
14:03:14 <benny> what does haskell lack?
14:03:25 <SamB> I mean, web may be too complicated.
14:03:50 <benny> yeah, html,css,javascript make up a bloated piece of turd
14:04:01 <SamB> Haskell might be cool for this
14:04:04 <benny> but that's why i'm just going to use a subset of the simple things
14:04:25 <SamB> definately a nice experiment
14:04:36 <xinming> bindState m k = \st -> let (st', a) = m st ; m' = k a in m' st'
14:04:46 <xinming> hmm, what does m st do here?
14:04:54 <SamB> what GUI toolkit are you gonna use?
14:04:56 <benny> i figure i convert the xhtml document into a haskell html tree type, then i convert that into a haskell graphics tree type and then just render that shit
14:05:06 <benny> SamB: gtk2hs and cairo for the actual rendering
14:05:27 <xinming> It's a example from yet_another_haskell_tutorial
14:06:01 <xinming> type State st a = st -> (st,a)
14:06:09 <SamB> benny: well, HXT uses tree types extensively
14:06:21 <SamB> thats like the point of HXT's creation
14:06:25 <benny> SamB: so you think that i definetly should go with HXT?
14:06:26 <Saulzar> xinming, Runs the previous state transition I think 
14:06:45 <SamB> benny: unless it starts to grate
14:06:51 <benny> grate?
14:07:09 <SamB> irritatate in an irritating fashion
14:07:41 <benny> i see
14:10:14 <Saulzar> Hmm - how fast is rendering with cairo? Quick enough for animation?
14:10:30 <benny> don't know
14:10:39 <xinming> Saulzar: How about m' = k a then?
14:10:40 <Saulzar> I imagine it would have to be reasonable to deal with web pages, though not so fast...
14:10:51 <dcoutts> Saulzar, it depends on how complex a drawing you're doing
14:11:35 <dcoutts> Saulzar, maozilla uses cairo for drawing svg
14:12:11 <Saulzar> maozilla ... hehe.
14:12:25 <SamB> mozilla has SVG support again?
14:12:31 <dcoutts> maozilla? is that the browser of choice for chineese dictators?
14:12:42 <dcoutts> SamB, yep
14:12:51 <SamB> maozilla *is* the chinese dictator
14:13:07 <Saulzar> xinming, That is making the next transition - since k is a function (a -> State b)
14:13:12 <dcoutts> SamB, I think it's turned on by default in firefox 1.5
14:13:40 <xinming> SamB: Do you mean Mr. Mao? :-/
14:13:57 <xinming> oops
14:14:03 <xinming> sorry for my misunderstanding.
14:14:30 <SamB> only in a convenient web-browser packaging
14:14:52 <dcoutts> firefox 1.5 also has a <canvas> element for doing drawing with java-script. That's implemented using cairo too.
14:14:52 <Saulzar> xinming, I think there is a less confusing piece of code here, with less random symbols http://www.nomaware.com/monads/html/statemonad.html
14:15:21 <Saulzar> I don't know about you, but as soon as there are 4 or 5 different 1 letter variables on one line my mind just explodes
14:15:26 <JoshTriplett> Heffalump: Ouch.  I'd prefer to avoid that if possible.
14:15:42 <Heffalump> JoshTriplett: there's no way you could avoid that, I don't think.
14:15:50 <Heffalump> but unsafePerformIO is explicitly part of the FFI spec
14:15:50 <JoshTriplett> Heffalump: Hmmm.
14:15:55 <Heffalump> not sure if it's recommended for that, though.
14:16:16 <JoshTriplett> Heffalump: So the idea is that if I want to control when I'm performing the IO operation, I need to use unsafePerformIO as the "force thunk" operation?
14:16:23 <Heffalump> but fundamentally, you want to turn something pure and semantically unobservable (demand for a lazy value) into something impure - IO.
14:16:27 <dcoutts> JoshTriplett, you want unsafeInterleaveIO
14:16:50 <Heffalump> dcoutts: I'm not convinced that's enough.
14:16:55 <dcoutts> you do one IO operation to get the infinite list of values
14:17:00 <Heffalump> how??
14:17:06 <dcoutts> that list will then be calculated lazily
14:17:17 <Heffalump> does the FFI specify how to return a lazy list?
14:17:20 <Heffalump> in one operation
14:17:25 <JoshTriplett> Heffalump: Having read it, no. :)
14:17:30 <dcoutts> not in one op
14:17:45 <Heffalump> oh, I think I see.
14:17:47 <dcoutts> just implement it the same way the getContents works
14:17:59 <dcoutts> a loop using unsafeInterleaveIO
14:18:01 <Heffalump> foo :: IO [Int]
14:18:12 <Heffalump> foo = do x <- getOneElem
14:18:24 <Heffalump>          xs <- unsafeInterleaveIO foo
14:18:30 <Heffalump>          return (x:xs)
14:18:48 <Heffalump> where getOneElem is a FFI call that returns one element, obviously.
14:18:57 <dcoutts> no, foo = unsafeInterleaveIO $ do { x <- getOneElem; xs <- foo; return (x:xs) }
14:19:08 <Heffalump> yeah, ok. Off-by-one error from me.
14:19:21 <dcoutts> so even the first element is retrieved lazilly
14:19:28 <Heffalump> anyway, unsafeInterleaveIO has unsafePerformIO under the hood, it's just a bit less unsafe.
14:19:34 <JoshTriplett> So, I guess I'm not clear what unsafeInterleaveIO is doing there.
14:19:40 <dcoutts> it's quite a bit less unsafe
14:19:47 <dcoutts> it might even have some semantics
14:19:58 <dcoutts> in terms of partial orders on actions
14:20:03 <Taral> @type fixIO
14:20:04 <lambdabot> Not in scope: `fixIO'
14:20:06 <dcoutts> actions/side-effects
14:20:31 <Heffalump> JoshTriplett: it's allowing evaluation of the list to be delayed.
14:20:34 <Taral> what about foo = mfix $ \xs -> getOneElem >>= \x -> return (x : xs)
14:20:54 <dcoutts> JoshTriplett, unsafeInterleaveIO does some IO action and returns a delayed value.
14:21:12 <dcoutts> JoshTriplett, only when that value is demanded is the IO action actually executed.
14:21:44 <JoshTriplett> dcoutts: OK; that sounds like exactly what I want then.  So the "unsafe" here just refers to the fact that it breaks the IO guarantee on ordering of IO actions?
14:21:50 <Heffalump> yes
14:21:50 <dcoutts> right
14:22:20 <Taral> imagine:
14:22:27 <dcoutts> instead of guaranteeing that the side-effects happen before returning it allows them to happen at any point afterwards
14:22:30 <JoshTriplett> Which is exactly what I want to do, since I "know" that my IO action depends on *some* state of the world but doesn't need to be ordered with other IO actions other than itself.
14:22:41 <dcoutts> but only once and possibly no times if the value is not demanded
14:22:51 <JoshTriplett> dcoutts: Right.
14:22:56 <Taral> JoshTriplett: So long as the state manipulated by getOneElem is "private" to foo, you're find.
14:22:58 <Taral> *fine.
14:23:12 <Taral> what about my mfix variant?
14:23:20 <Taral> @type fmix
14:23:20 <ADEpt> @docs StateIO
14:23:21 <lambdabot> Not in scope: `fmix'
14:23:21 <lambdabot> StateIO not available
14:23:22 <Taral> @type mfix
14:23:23 <lambdabot> Not in scope: `mfix'
14:23:28 <Taral> @type Data.Monad.Fix.mfix
14:23:28 * JoshTriplett is currently trying to understand it.
14:23:28 <Heffalump> taral: I don't see how it would actually terminate.
14:23:29 <lambdabot> Couldn't find qualified module.
14:23:29 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
14:23:29 <lambdabot> \\)?
14:23:36 <Taral> @type Data.Monad.mfix
14:23:36 <lambdabot> Couldn't find qualified module.
14:23:36 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
14:23:36 <lambdabot> \\)?
14:23:37 <ADEpt> @hoogle StateIO
14:23:37 <lambdabot> No matches found
14:23:43 <Taral> @hoogle mfix
14:23:44 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
14:23:55 <JoshTriplett> @type System.IO.fixIO
14:23:55 <lambdabot> forall a. (a -> IO a) -> IO a
14:24:09 <Taral> Heffalump: The argument to mfix is lazy in its first argument
14:24:19 <Taral> so it terminates
14:24:30 <dcoutts> JoshTriplett, eg one can write a action to get a directory tree of the whole file system. Obviously we don't want to do that eagerly since it'll take ages. So long as we only use parts of the returned tree then only that much of the file system will be searched.
14:24:35 <Heffalump> Taral: hmm. Still not convinced.
14:24:46 <Heffalump> I think an unsafeInterleaveIO is still required.
14:25:14 <Taral> Heffalump: ha, fixIO calls unsafeInterleaveIO
14:25:21 <Heffalump> ah :-)
14:25:23 <JoshTriplett> dcoutts: Right.  And as long as you don't depend on the ordering of the directory search with other actions (even modifications of the file system), you're fine.  So if another action is creating a file, then the search may or may not include it.
14:25:26 <Heffalump> ok, you win then :-)
14:25:29 <dcoutts> JoshTriplett, on the other hand if we're depending on files having changed or not changed since we generated the list then we'd be in trouble.
14:25:36 <dcoutts> JoshTriplett, right
14:26:17 <JoshTriplett> Taral: So, I'm not quite clear on what the semantic of fixIO is.
14:26:25 <Taral> it's a fixpoint
14:26:26 <JoshTriplett> Taral: I understand unsafeInterleaveIO.
14:26:38 <Taral> basically, mfix feeds the result of a computation back into that computation
14:26:44 <Heffalump> I think it turns out to be the same as dcoutts' solution.
14:26:50 <JoshTriplett> OK; fixpoints I understand.
14:26:57 * JoshTriplett reads the definition again.
14:27:12 <Heffalump> JoshTriplett: let xs = 1:xs in xs is a fix point producing a stream of xs.
14:27:15 <Heffalump> IM a stream of 1s
14:27:30 <Heffalump> the fixIO solution basically does the same thing, but in IO with unsafeInterleaveIO.
14:27:38 <Taral> it's cute... they use an ioref. :)
14:27:52 <Taral> the direct solution (with uIIO) is more efficient.
14:27:56 <Heffalump> but it's just the same as dcoutts' solution, using a fixpoint combinator.
14:27:57 <JoshTriplett> Heffalump: I'm just not clear what the function you pass to fixIO is.
14:28:08 <Taral> JoshTriplett: Look at the type
14:28:15 <Taral> @hoogle mfix
14:28:15 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
14:28:25 <Heffalump> it's the thing that takes the tail of the list and returns IO list
14:28:30 <Heffalump> > fix (1:)
14:28:31 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:28:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:28:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:28:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:28:31 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:28:33 <lambdabot> [23 @more lines]
14:28:40 <Heffalump> just like with the non-monadic fix above
14:28:51 <JoshTriplett> *AH*
14:28:55 * JoshTriplett gets it now.
14:29:33 <Taral> It amuses me that mfix isn't marked unsafe in any way, even though it completely borks monadic side-effect ordering.
14:29:40 <JoshTriplett> I know the semantics of mfunc given func; I just didn't know there was a "fix" function. :)
14:29:58 <Heffalump> it's only unsafe for IO, isn't it?
14:30:00 <Taral> @pl \f -> let g = f g in g
14:30:00 <lambdabot> fix
14:30:18 <JoshTriplett> What is "@pl"?
14:30:19 <Taral> Heffalump: It's unsafe for any stateful monad.
14:30:29 <SamB> dcoutts: most people just use the locate database
14:30:37 <Heffalump> taral: not true, it just calculates a fixpoint in the state
14:30:37 <Taral> Okay, I go home now
14:30:47 <Taral> Heffalump: Hm... you might be right.
14:30:54 <Taral> I wonder what happens if you use mfix in ST?
14:30:55 <JoshTriplett> Taral: Thanks for the explanation.
14:31:03 <Taral> JoshTriplett: my pleasure
14:31:04 <Heffalump> JoshTriplett: something that finds an equivalent to a function given in terms of library functions.
14:31:21 <JoshTriplett> Heffalump: Awesome.
14:31:22 <Heffalump> (and gets rid of lambda abstraction using sneaky transformations)
14:31:31 <dcoutts> SamB, heh, it depends on what you're doing. :-)
14:31:34 <JoshTriplett> @pl sequence . replicate
14:31:35 <lambdabot> sequence . replicate
14:31:46 * JoshTriplett hoped for replicateM there. :)
14:31:49 <Heffalump> :-)
14:31:58 <Heffalump> it's aiming for "point free" ness
14:32:03 <Heffalump> so sequence.replicate already has that
14:32:11 <dcoutts> SamB, I wrote a <30 line program to calculate the number of bits required to index every file on my hard drive using an indexing system I'd thought of.
14:32:12 <Heffalump> @pl \f g x -> f (g x)
14:32:12 <lambdabot> (.)
14:32:32 <Taral> JoshTriplett: I cheated. I know that "fix" is one of the combinators that @pl uses to construct point-free expressions.
14:32:50 <dcoutts> SamB, it nicely split the calculation from the directory walk by doing the directory walk lazilly using unsafeInterleaveIO
14:32:54 <Taral> @type replicate
14:32:55 <lambdabot> forall a. Int -> a -> [a]
14:32:57 <JoshTriplett> Heffalump: So it stops once it has pointsfreeness, and doesn't try to find an existing function which is semantically equivalent?  That makes sense.
14:33:02 <Taral> @type replicateM
14:33:03 <lambdabot> Not in scope: `replicateM'
14:33:04 <dcoutts> SamB, and the answer is 83 bits.
14:33:05 <Taral> @type Data.Monad.replicateM
14:33:06 <lambdabot> Couldn't find qualified module.
14:33:06 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
14:33:06 <lambdabot> \\)?
14:33:10 <Taral> @type Monad.replicateM
14:33:11 <lambdabot> Not in scope: `Monad.replicateM'
14:33:14 <Taral> @hoogle replicateM
14:33:15 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
14:33:15 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
14:33:28 <Taral> @pl \x -> liftM (replicate x)
14:33:29 <lambdabot> fmap . replicate
14:33:35 <Taral> ?
14:33:42 <Taral> @type fmap . replicate
14:33:42 <lambdabot> forall (f :: * -> *) a. (Functor f) => Int -> f a -> f [a]
14:33:47 <Taral> heh
14:33:57 <Taral> okay, bye all'
14:34:39 <jethr0> anyone know what the (+) operator is called in prelude? is there maybe a parallel to "subtract"?
14:35:35 * palomer is going to read the wobbly types paper tonight
14:35:40 <JoshTriplett> jethr0: subtract only exists because it means "subtractFrom"; it is "flip (-)"
14:35:43 <Heffalump> jethr0: what's wrong with (+) ?
14:35:58 <JoshTriplett> jethr0: So "subtract 5" is the function which subtracts 5 from something.
14:36:01 <dons> Moin
14:36:03 <Heffalump> subtract is needed to express what would be (-1) except for the ambiguity with negative one.
14:36:15 <jethr0> heffalump, not sure, but TH is not all too happy with "GHC.Num.+"
14:36:18 <JoshTriplett> jethr0: What Heffalump said. :)
14:36:27 <JoshTriplett> jethr0: Just type (+)
14:36:32 <jethr0> hmm
14:36:44 <Heffalump> jethr0: GHC.Num.(+)
14:36:53 <Heffalump> nope.
14:36:58 <Heffalump> I struggled with this one a while back.
14:37:16 <JoshTriplett> > zipWith (+) [1,2,3] [1,2,3]
14:37:17 <lambdabot> [2,4,6]
14:37:32 <Heffalump> though yeah, in the case of things in the Prelude, there's no issue.
14:37:44 <JoshTriplett> Which implementation is lambdabot using?
14:37:48 <JoshTriplett> GHC?  Hugs?
14:38:30 <dcoutts> ghc
14:39:10 <dons> @version
14:39:11 <lambdabot> lambdabot 3p222, GHC 6.5.20050806 (Linux i686)
14:39:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
14:41:50 <astrolabe> what is the opposite of 'parse'?
14:42:32 <jethr0> :)
14:42:41 <jethr0> concatenation
14:42:42 <Philippa_> 'prettyprint'
14:43:12 <jethr0> philippa_, only if the source was "pretty" to begin with :)
14:43:29 <astrolabe> hmmm.  maybe I just mean read.
14:43:30 <Philippa_> er, no
14:43:49 <Philippa_> the point of a prettyprinter is that it doesn't have to use the same layout as the source had
14:43:51 <jethr0> @type prettyprint
14:43:52 <lambdabot> Not in scope: `prettyprint'
14:44:03 <Philippa_> @type parse
14:44:04 <lambdabot> Not in scope: `parse'
14:44:10 <Philippa_> see, they're dual! :-)
14:44:13 <dons> hehe
14:44:15 <Philippa_> astrolabe: show, then
14:44:38 <astrolabe> Ah yes, that's what I meant I might have meant :)
14:45:27 <jethr0> did anyone write a prettyprinter for Template Haskell's AST?
14:45:30 <jethr0> yet?
14:46:37 <shapr> jethr0: I think someone requested it, don't know if it's been done or not.
14:46:54 <jethr0> i wonder how hard it would be to get 100% right...
14:47:05 <SamB> jethr0: doesn't it come with one?
14:47:12 <shapr> 90% right would be a start.
14:47:18 <jethr0> samb, i mean AST => haskell source code
14:47:26 <SamB> maybe not 100% correct, though...
14:47:27 <jethr0> and no, not that i know of
14:47:34 <shapr> Oh hey
14:47:36 <jethr0> shapr, would it?
14:47:42 <SamB> jethr0: dons said something agout PPR earlier
14:47:44 <shapr> Lemmih has done something like that.
14:47:49 <jethr0> ppr?
14:48:00 <SamB> er, Ppr maybe
14:48:08 <shapr> Lemmih wrote a cool tool that lets you generate TH sources, and completely disconnect them from the TH lib itself.
14:48:18 <jethr0> samb, the serialization thingey?
14:48:31 <SamB> jethr0: that is actually a pretty printer
14:48:35 <jethr0> ah
14:48:43 <shapr> I forget the tool name, but Lemmih's tool is mentioned in the most recent HC&AR.
14:48:56 <jethr0> you and your acronyms *tststs*
14:49:33 <shapr> It's above freezing here. Global warming sure is happening fast. I shall take advantage of this by unicycling at midnight in bike shorts in what should be a very cold part of the year.
14:50:27 <shapr> Oh, I just ordered the 3.7 inch tire! It should be here by Xmas! w00!
14:51:10 <dons> bad dcoutts, spreading malicious rumours about .hc builds ;)
14:51:30 <jethr0> ppr rocks! why didn't anyone tell me about it earlier?
14:51:44 <dcoutts> dons, but it's true! (itsn't it?)
14:51:46 <jethr0> and why didn't i look inside the funny Ppr.hs earlier
14:51:52 <dons> dcoutts, nope. see my reply.
14:52:00 <dcoutts> dons, oh
14:52:01 <jethr0> shapr, HC&AR?
14:52:02 <dons> OpenBSD builds from .hc files
14:52:07 * dcoutts does reads
14:52:07 <shapr> @where hc&ar
14:52:08 <lambdabot> I know nothing about hc&ar.
14:52:11 <shapr> @where hcar
14:52:11 <lambdabot> http://www.haskell.org/communities/
14:52:41 <shapr> jethr0: The moral of this story is.. look in all the source files, especially ones you don't know what they do.
14:52:52 <dcoutts> dons, for a couple years!?
14:52:56 <dons> .hc building was even in the nightly regression test until I broke it.
14:53:01 <shapr> The next moral is... make sure to use filetype:hs and filetype:lhs on google.
14:53:07 <shapr> @google template haskell filetype:hs pretty print
14:53:08 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/haskell-src/Language/Haskell/THSyntax.hs
14:53:16 <dons> dcoutts, since 5.02 ?
14:53:20 <dcoutts> dons, I was sure people asked for this less than a year ago and JaffaCake said it was not going to happen.
14:53:27 <dons> hmm
14:53:37 <dcoutts> dons, I thought it worked in 5.04 and then didn't work in 6.x
14:53:43 <jethr0> shapr, ya right...
14:53:50 <dons> and then we fixed it :)
14:54:00 <dons> and made it far far more portable
14:54:00 <dcoutts> dons, cool. when was that?
14:54:09 <dcoutts> dons, how easy is it to do?
14:54:28 <shapr> jethr0: Or maybe the moral is, "ask on #haskell." You've definitely taught me stuff about Haskell I didn't know.
14:54:47 <dcoutts> dons, we (gentoo) might switch to that if it's not too hard and produces full registerised builds.
14:54:53 <jethr0> did i? didn't know i had stopped asking dumb questions, yet
14:55:08 <shapr> jethr0: What you think I've stopped that? ;-)
14:55:09 <dons> you build the .hc tar ball. and post it on some ftp site. untar it over a src tree, and make configure with --enable-hc-boot
14:55:16 <jethr0> :)
14:55:41 <dons> well, check out the openbsd build script.
14:56:16 <dons> the only hard part is the package maintainers producing the .hc tar balls. but you just follow the rules in the porting guide for producing such bundles
14:56:50 <dons> remember, we have this distrib/hc-build script
14:56:57 <dons> that does the whole thing
14:58:16 <dons> ok, it's been building like this on openbsd since 2years, 4 months ago, according to cvs :)
14:59:06 <dcoutts> dons, hmm. That doesn't sound too much harder than building binary packages.
14:59:26 <JoshTriplett> Hmmm; so why is it that "repeatIO f = unsafeInterleaveIO $ do x <- f ; xs <- repeatIO f ; return (x:xs)" works but not "unsafeInterleaveIO . sequence . repeat".
14:59:57 <dons> I think it is easier than producing a binary bootstrap compiler
15:02:00 <sdjp> Hrm.  A rather extreme newbie question, but:  What's a good way of extracting the first n items in a list?
15:02:20 <JoshTriplett> sdjp: take n list
15:02:29 <dons> > take 4  [1..10]
15:02:31 <lambdabot> [1,2,3,4]
15:02:40 <dcoutts> sdjp, do you just want to know the answer or understand how to write a function youself that does it?
15:03:32 <sdjp> Ah, take.  Just looking for any built in way.  I know how to build one, but reckoned there was a better way.
15:06:52 <jethr0> dons, you said sth earlier about Ppr, i heard?
15:07:21 <dons> @index  Ppr
15:07:21 <lambdabot> Language.Haskell.TH.Ppr, Language.Haskell.TH
15:07:28 <jethr0> ya, got a followup :)
15:07:41 <dons> oh, I made it up, did I? maybe I made it up.
15:07:59 <dons> ah, seems so. I usually write:
15:08:01 <dons> class Pretty a where
15:08:01 <dons>         ppr :: a -> Doc
15:08:15 <dons> I thought it was built in, but seems I keep writing it for each new project
15:08:16 <jethr0> i'm trying to "reify" and then a "pprint", but 
15:08:19 <jethr0> runQ (reify (mkName "map")) >>= putStrLn . pprint
15:08:26 <jethr0> doesn't work, because reify isn't allowed in IO
15:08:28 <dcoutts> dons, at the url you gave I only see ghc-6.2.2
15:08:29 <dcoutts> http://www.openbsd.org/cgi-bin/cvsweb/ports/lang/ghc/
15:08:39 <dons> yeah, I haven't updated yet
15:08:59 <dcoutts> oh ok
15:11:15 <ADEpt> @type sequence_
15:11:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:24:27 <glauber_sp> guys, I want to start learning haskell. should I use ghc or hellium?
15:24:36 <basti_> ghc
15:24:43 <jethr0> isn't helium a different language?
15:24:55 * basti_ doesnt know helium
15:25:16 <pesco> helium, IIRC, is an interpreter for a subset of Haskell.
15:26:01 <musasabi> helium has nice error messages but lacks iirc polymorphism
15:26:07 <glauber_sp> ok, I'll install ghc and emacs mode
15:26:28 <astrolabe> I agree with ghc
15:26:29 <dons> no type classes 
15:26:42 <glauber_sp> helium is a subset of haskel without polymorfism, as I've read
15:27:00 <astrolabe> how does it do IO?
15:27:34 <glauber_sp> well, which book sould I read. I want one that is not to basic or that does not foccus only in basic stuff =)
15:27:51 <astrolabe> glauber_sp: check this
15:27:54 <astrolabe> @learn
15:27:54 <lambdabot> http://www.haskell.org/learning.html
15:28:04 <Philippa_> musasabi: thought it was typeclasses it lacked?
15:28:29 <glauber_sp> astrolabe, I've seen the site. I just don't know which one to start reading
15:28:43 <astrolabe> glauber_sp: I learned from http://www.haskell.org/soe/ and thought it was good
15:29:14 <astrolabe> but there are some good web tutorials on my first link.
15:29:33 <glauber_sp> astrolabe, hum, ok. I'll read the tutorials, so. just to start =)
15:32:53 <jethr0> dons, you know lemmih's real name... that HC&AR is _long_!
15:34:30 <ADEpt> @type mod
15:34:31 <lambdabot> forall a. (Integral a) => a -> a -> a
15:35:39 * SamB thinks measures bear a suspicious resemblance to binary trees
15:36:50 <basti_> SamB?
15:37:10 <SamB> basti_: you know, musical measures?
15:37:17 <SamB> in 4/4 time, anyways
15:37:49 <basti_> ah.
15:38:26 <basti_> well
15:38:31 <basti_> what about triplets?
15:40:24 <SamB> well, its a resemblance
15:40:32 <twb> This is wrong: data RomanNumeral = 'I' | 'V' | 'X' | 'L' | 'C' | 'D' | 'M'
15:40:34 <SamB> I didn't say they were quite identical
15:40:36 <twb> What should I be writing?
15:40:43 <basti_> heh
15:40:45 * shapr hugs twb 
15:40:50 <integral> twb: lose the 's maybe?
15:41:00 <twb> integral: that won't work.
15:41:02 <shapr> twb: What about data RomanNumeral = I | V | X | L | C .. ?
15:41:06 <dons> you're defining constructors.
15:41:07 <twb> They need to be treated as characters.
15:41:12 <dons> add a Show instance then.
15:41:17 <shapr> and a read install
15:41:19 <shapr> instance
15:41:38 <shapr> data RomanNumeral = I | V | X | L | C | D | M deriving (Show,Read)
15:41:41 <twb> And if I use I | V | X | L | C | D | M, then I can't use those letters for other datatypes.
15:41:43 <integral> twb: umm, well you can't define a type from a subset of the values inhabiting another type
15:41:44 <dons> or just a fn :: RomanNumerial -> Char ?
15:41:57 <basti_> actually i wouldn't call that RomanNumeral
15:42:02 <twb> integral: that's exactly what I want...
15:42:03 <SamB> twb: write a special show instance that shows lists of them with no [] or ,?
15:42:08 <dons> jethr0, he's under 'Lemmih' in the hcar
15:42:13 <jethr0> thx
15:43:47 <dons> twb, define your type, and then define a bijection from youur type to a subset of Char. that's basically what we're all saying.
15:43:47 <twb> integral: I need subset types, for unit testing of my parser.
15:43:58 <shapr> Hey, I just had a neat thought... maybe I could make a simple speech interface by leveraging the speex codec?
15:44:49 <jethr0> subset types?
15:45:03 <twb> jethr0: as in, RomanNumeral is a subset of Char.
15:45:18 <shapr> Why not make Char an instance of RomanNumeral?
15:45:33 <twb> That's what I'm gonna have to do, I think.
15:45:41 <dons> @google roman numeral haskell
15:45:42 <lambdabot> http://www.kx.com/listbox/k/msg03894.html
15:45:50 <shapr> You could even freely convert from Num to Char with a roman numeral class.
15:45:51 <twb> Wait, that's not what I was thinking.
15:45:56 <shapr> @google filetype:hs roman numeral
15:45:57 <lambdabot> http://www.cs.york.ac.uk/ftpdir/pub/haskell/contrib/Roman.hs
15:46:14 <shapr> @google filetype:lhs roman numeral
15:46:15 <lambdabot> No result found.
15:46:22 <shapr> @google filetype:hs roman numerals
15:46:23 <lambdabot> http://www.cs.york.ac.uk/ftpdir/pub/haskell/contrib/Roman.hs
15:46:47 <SamB> shapr: wouldn't it be easy to do that with just Integral and roman numeral<->Integer conversions?
15:46:51 <shapr> Seems pretty straightforward.
15:47:02 <shapr> Appears to be what Malcolm did.
15:51:01 <pesco> Phew, done reading email.
15:51:24 <shapr> hiya pesco 
15:51:31 <pesco> Ahoj shapr.
15:51:57 <shapr> Speex sounds surprisingly good at 4kbps.
15:52:12 <pesco> Hm, cool. :)
15:52:30 <SamB> hence the name?
15:52:47 <Lor> I would really really like a speex-capable digital dictating machine.
15:53:03 <mwc> Doesn't surprise me, human language is pretty redundant. Even spoken stuff is a very narrow bound of frequencies
15:53:30 <basti_> :-o
15:53:37 <basti_> compared to what?
15:54:16 <mwc> music
15:54:54 <basti_> how do we define "redundant" now? "is recognizeable" or "sounds the same"?
15:54:54 <mwc> Think about it, we make the same basic sounds over and over again with very little in the way of changing them. Think of it as a 26-tone MIDI
15:55:10 <mwc> basti_, written, english has an information content of 1 bit / 5 letters on average
15:55:12 <basti_> human language does not have 26 phonemes
15:55:13 <pesco> I'm thinking about adding some specialized lhs-support to Haddock. How good an idea do you (plural) think this is?
15:55:27 <mwc> basti_, yeah, I was being lazy
15:55:42 <basti_> mwc: counting emotion, stresses and intonations too?
15:55:58 <shapr> I was just trying to think of ways to make my wimax widget a cool hacker's toy. I wonder if a speech interface would work on an embedded Linux device with ~64 mb of ram and 32 mb of rom. For example, I'd like to try a simple spoken shell scripting language.
15:56:14 <mwc> That's just pitch and volume modulation
15:56:19 <basti_> i won't be able to stop you shapr 
15:56:20 <twb> The festival package does TTS...
15:56:28 <basti_> mwc: which transfers exactly how much information?
15:56:37 <shapr> Yeah, but how much cpu/ram does festival require?
15:56:42 * shapr investigates
15:56:44 <twb> A fair bit.
15:57:00 <shapr> Does that mean 64mb or what?
15:57:04 <mwc> Probably not that much. Think about how well we can reconstruct it after a lossy, noisy channel
15:57:07 <twb> I don't know.
15:57:10 <shapr> hey japple 
15:57:16 <twb> It runs easily on a Mac Mini.
15:57:24 <shapr> Also, can I compress the festival sound samples with speex?
15:57:37 <twb> shapr: I think they use something weird.
15:57:42 <shapr> hello again japple 
15:57:44 <basti_> mwc: well i think this is subjective now. I think there's a lot more to spoken words than what we write down. 
15:58:05 <basti_> mwc: people delude themselves into thinking that language has only the meanings we write down.
15:58:10 <japple> @djinn () -> (a -> ())
15:58:11 <lambdabot> x :: () -> a -> ()
15:58:11 <lambdabot> x _ _ = ()
15:58:48 <basti_> mwc: on the contrary though. try intonating a poem just the right way, and you'll see what i mean.
15:59:19 <shapr> aha, flite is festival lite, designed to be festival in embedded systems!
15:59:20 <twb> How do I load a local .hs, rather than a module?
15:59:26 <benny> has anyone experienced trouble when compiling and using ghc with gcc 4.0.2?
15:59:39 <twb> benny: no.
15:59:46 <shapr> twb: In ghci, or what?
15:59:59 <mwc> basti_, yeah, but all that meaning occurs in the brain
16:00:02 * shapr isn't sure which gcc his ghc uses.
16:00:04 <twb> shapr: in an .hs, which is loaded in ghci with :l
16:00:31 <mwc> i'm talking about the actual manifestation of the words as speech
16:00:35 <dons> @pll \st -> dropSpace s : st
16:00:35 <lambdabot> (dropSpace s :)
16:00:36 <ADEpt> @hoogle startsWith
16:00:37 <lambdabot> No matches found
16:00:46 <shapr> twb: import Foo where Foo.hs (containing module Foo) is in the path.
16:00:57 <twb> shapr: how do I modify the path?
16:01:07 <shapr> jimapple: Do you still have that cool haircut you had on the cumberland trip?
16:01:12 <basti_> mwc: you want to say "i'm talking about denotations", and for that, the statement is true.
16:01:18 <shapr> twb: :set -i /home/twb/src/haskell/mymodules
16:01:26 <shapr> er, without the space betwene -i and /
16:01:49 <basti_> mwc: reducing language to denotations is like reducing sex to couples rubbing genitals at each other
16:01:55 <jimapple> the cumberland trip?
16:02:00 <basti_> qed.
16:02:02 <mwc> that's what it is on camera :P
16:02:11 <basti_> ^^
16:02:27 <basti_> ah we're talking about recordings?
16:02:37 <basti_> well, then language uses just as much information as music
16:02:41 <jimapple> shapr: ah, to COlumbia U. No, I had to find a job, and they don't like afros as much as my peers
16:02:43 <mwc> basti_, yeah, that's different though. I'm considering how much bandwidth I'd need to carry all the information in recordable speech
16:02:47 <basti_> well maybe a little less, given that you can compress its effectively
16:03:02 <mwc> basti_, yeah, but I think language is more like a MIDI
16:03:05 <basti_> like, maybe, 1/4th of music for comparable quality
16:03:17 <mwc> Not to mention the brain is very adept at reconstructing garbled speech
16:03:20 <basti_> if we're talking mp3 and the likes
16:03:21 <shapr> jimapple: Sorry, there's a Cumberland in TN where I used to live.
16:03:24 <jimapple> @pl \x -> \y -> \z -> if x then y else z
16:03:24 <lambdabot> if'
16:03:33 <twb> mwc: that's true for TTS speech, but not recorded human speech.
16:03:38 <shapr> I now see that CUMB is not short for cumberland.
16:04:24 <shapr> jimapple: I'm lucky, I have a job and hair both - http://www.scannedinavian.com/images/shae-sj.png
16:05:12 <mwc> shapr, judging by your knees, you were still working on that unicycling thing
16:06:00 <shapr> mwc: Actually that was skin worn off from the kneepads I was wearing.
16:06:11 <dons> @seen lennart
16:06:11 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
16:06:12 <benny> whoah dude you really need a haircut!
16:06:26 <dons> lennart, djinn doesn't remove type synonyms with :delete?
16:06:37 <shapr> benny: oh yeah? http://www.scannedinavian.com/images/need_haircut.jpg
16:07:23 <benny> eek
16:07:33 <benny> that's actually not as bad. not as big
16:07:35 <astrolabe> LOL
16:08:20 <mwc> shapr, just be glad you didn't by a cup from that manufacturer
16:08:23 <shapr> Some people say I have fuzzy thinking... but really, it's just my hair.
16:08:24 <Pupeno> I am tring to make a set of functions and datatypes to easily handle program options. My basic unit is data Option value = Option [String] value, where value can be one of String, Bool or Num, how do I do that ?
16:08:24 <mwc> *buy
16:08:30 <shapr> mwc: ouch!
16:08:41 <shapr> Reminds of Spartan jockstraps.
16:08:53 <shapr> You know the story of the child who epitomized spartan ideals?
16:08:54 <Heffalump> Pupeno: what's the problem?
16:08:55 <mwc> oh well, I should probably go study for that exam I have tomorrow
16:09:06 <mwc> Adios
16:09:09 <shapr> He had his testicles chewed off by a fox without complaining.
16:09:23 <shapr> And they make jockstraps named after spartans??
16:09:33 <shapr> But the cluelessness of greek names gets better...
16:09:42 <shapr> Trojan condoms...
16:09:52 <Pupeno> Heffalump: for example, how do I make a list of options (that is called Command).
16:10:12 * Pseudonym makes a note not to emigrate to ancient Sparta
16:10:31 <moonlite> i'm trying to install HaskellDB from cvs which is cabalized. When trying to install something called driver-dynamic i use "./Setup.hs configure" which find hs-plugins (among others). However "./Setup.hs build" fails with: "Could not find module `System.Plugins.Utils'" and "it is hidden (in package plugins-0.9.10)". Does anyone have a clue of what is wrong?
16:10:39 <shapr> Shall I go on and describe how the Oracle of Delphi tortured people for years before they realized the answer to their original question was that their life would be horrible?
16:10:48 <shapr> Now don't you want to install Oracle and ask it questions?
16:10:59 <shapr> This whole greek names thing is nuts.
16:11:05 <shapr> chewed off...
16:11:14 * shapr goes back to coding...
16:11:19 <Pseudonym> Next introspective language I invent will be named Narcissus.
16:11:23 * earthy still likes the shoe-shops called 'Oedipous'
16:11:23 <shapr> haha!
16:12:22 <Pseudonym> At least "Nike" makes some sort of sense.
16:12:25 <Pupeno> I tried data Command = Command [Option [String] value], but of course, value is not defined, and if I do data Command value = Command [Option [String] value], then I can have only one type of values on the options.
16:12:35 <shapr> True, there are good uses of greek names.
16:12:53 * earthy likes the use of Haskell better. :)
16:13:04 * shapr waves a lambda
16:13:07 <Pseudonym> My favourite Greek misuse is teachers who refer to "pedagogy".
16:13:11 <Pseudonym> A pedagogue was a slave.
16:13:28 <Heffalump> Pupeno: ah, right.
16:13:34 <basti_> as long as they don't refer to themselves as pedophiles.
16:13:36 <Cale> Pupeno: Perhaps you're looking for existential types?
16:13:36 <Heffalump> one option is to use an existential type
16:13:44 <shapr> I like pesco's quote about the root word for 'deprecate' being 'to ward off by prayer.'
16:13:50 <Pupeno> Cale: existential types ?
16:13:51 <Heffalump> another is to make a datatype that lists all the possible concrete option types
16:14:04 <Heffalump> e.g. data Options = IntOption (Option Int) | ...
16:14:24 <earthy> pseudonym: ah, but it was a 'slave who supervised children and took them to and from school'
16:14:28 <Pseudonym> Yes.
16:14:32 <Pseudonym> But even so.
16:14:40 <Pseudonym> That's not the role of a teacher.
16:14:50 <earthy> true enough
16:14:59 <shapr> And 'computer' used to be a job occupation.
16:15:09 <earthy> but the word has been taken into a number of current languages with a different meaning
16:15:14 <Pseudonym> As did "printer" and "conductor".
16:15:27 * jethr0 also like "academos" who was a god of war :)
16:15:38 <Pseudonym> But an electronic computer is really the automatic equivalent of a human computer.
16:15:45 <Pseudonym> The analogy isn't too bad.
16:16:00 <shapr> Then we have the root word for 'slave' being slavic...
16:16:16 <pesco> Oh, time to leave the internet cafe...
16:16:18 * pesco waves.
16:16:21 * shapr waves
16:16:21 <jethr0> bye
16:16:32 <Pseudonym> The worst of all, though, is English swear words.
16:16:41 <Pseudonym> They are, for the most part, normal Saxon words.
16:16:51 <Pupeno> Heffalump: ok, data Option = StringOption [String] String | IntegerOption [String] Integer | BoolOption [String] Bool deriving (Show), how do I make Command ? the list of Options ?
16:17:00 <Pseudonym> By treating them as bad words, we perpetuate the cultural genocide perpetrated by the Norman invaders.
16:17:01 <basti_> Pseudonym: examples, on -blah, maybe? ;)
16:17:09 <Pseudonym> Sure.
16:18:46 <earthy> Pupenu: newtype Command = Command [Option]
16:19:29 <Pupeno> earthy: thanks.
16:20:04 <earthy> or even type Command = [Option]
16:20:23 <ADEpt> SamB, jlouis: I got in the mood, and conjure now actually downloads the whole file and ... throws it away! ;)
16:20:38 <earthy> the latter would allow you to use the normal list operations on things of type Command
16:20:56 <shapr> ADEpt: still an improvement!
16:22:32 <ADEpt> shapr: indeed! as soon as jlouis will have all the comlicated FS layer ready, we will see wether those files are downloaded correctly
16:24:10 <shapr> cool!
16:24:19 <shapr> Is your repo online?
16:24:32 <Pupeno> earthy: and if I have: data Num n => Option n = StringOption [String] String | NumberOption [String] n | BoolOption [String] Bool  ? How do I make the list ?
16:24:32 <SamB> shapr: look in AUTHORS
16:24:32 <shapr> I have real paying work to do, and so am desperately looking for something else to do.
16:24:36 <shapr> ah right
16:25:09 <shapr> Oh, I was going to setup eivuokko's darcs-cgi-push on scannedinavian...
16:25:11 <SamB> I added them after getting tired of doing cat _darcs/prefs/repos
16:25:24 <shapr> heh
16:26:07 <shapr> ya know, that's really handy.
16:26:34 <shapr> Now I need to hack the darcs zsh autocompletion to read repos from AUTHORS
16:26:49 * shapr has all the focus of a chipmunk on speed.
16:26:59 <SamB> yeah. the only thing handier that I can think of would be a script which could be invoked as eg "./pull jlouis"
16:27:31 <shapr> What about CosmicRay's pullall.sh ?
16:27:40 <shapr> That would pull from all of the repos
16:27:49 <SamB> thats fine if you have broadband
16:31:15 <ADEpt> SamB: i have scipts './jlouis' and './SamB' just for that :)
16:32:01 <SamB> ADEpt: do they extract the urls from AUTHORS?
16:35:50 <moonlite> what does "ghc-pkg expose" do? I'm thinking since System.Plugins.Utils seem to be "hidden". "ghc-pkg expose plugins" would do the trick, but it seems it doesn't
16:39:51 <Igloo> dons: Do you have numbers for compiling ghc from .hc vs from source?
16:40:02 * shapr a sudden inspiration on how to invert static transducers for dramatically better sound.
16:42:40 <dons> hmm. used to. around twice as fast, iirc.
16:42:55 <dons> since it's mostly gcc going nuts.
16:43:02 <Igloo> OK, ta
16:43:05 <dons> there's some comments in the openbsd commit logs, let me see.
16:46:43 <dons> my commit log says "roughly halved the build time"
16:46:54 <Igloo> OK, thanks
16:50:58 <sdjp> I'm having diffuclty with some code.  I've stuck it on http://haskell.org/hawiki/HaskellIrcPastePage at the top (Module Why).  I'm getting an error that suggest putting an explicit type signature on ... but I've no idea where to put it (or, indeed, what it should be to fix the problem).  Any suggestions?
16:53:21 <jethr0> Probable fix: give these definition(s) an explicit type signature
16:53:42 <jethr0> no, seriously, would it be ok for you to work on floats all the way through?
16:54:29 <Igloo> Hmm, isn't Num a superclass of some or all of those?
16:55:04 <sdjp> Well, Double, but that would be fine.  However, I'm mostly wondering what the root cause it.
16:55:21 <jethr0> missing "fromIntegral" would be my guess, but i'm not sure
16:55:30 <Igloo> I guess by the letter of the report that means it shouldn't be defaulted, but intuitively it ought to be
16:55:52 <sdjp> So, if I make everything a function in Double (or a Num), that should sort it?  Will try that.
16:59:03 <SamB> so, does Haskore do scores well?
16:59:34 <moonlite> dons: sorry to bug you, but how do i expose the hidden module System.Plugins.Utils ? The package plugins is exposed but i also need that module to be exposed.
16:59:47 <dons> hmm. did I hide it?
16:59:51 <SamB> Igloo: would be really nice, yes
16:59:56 <moonlite> yeah it seem so
17:00:04 * Igloo is confused by what's going on
17:00:08 <moonlite> ghc-pkg field plugins hidden-modules says so at least
17:00:14 <dons> moonlite, are you using the darcs version?
17:00:19 <SamB> Igloo: ought to be a way to specify that a class should be defaulted like those
17:00:26 <moonlite> dons: nah 0.9.10
17:00:29 <dons> moonlite, use the darcs repo, it's not hidden there.
17:00:42 <moonlite> ok thanks
17:04:21 <SamB> @where Haskore
17:04:21 <lambdabot> I know nothing about haskore.
17:05:02 <Igloo> OK, this breaks:
17:05:05 <Igloo> test1 = (undefined :: (Integral a, Floating a) => a)
17:05:07 <Igloo> this works:
17:05:12 <Igloo> test2 = (undefined :: Integral a => a)
17:05:33 <Igloo> which doesn't gel with my memory of the report
17:06:20 <Heffalump> breaks with monomorphism restriction complaints?
17:06:35 <Igloo> Yes
17:07:03 <dons> > (undefined :: (Integral a, Floating a) => a)
17:07:05 <lambdabot> Add a type signature
17:07:10 <dons> heh
17:07:38 <Igloo> (and hugs agrees with ghci)
17:07:58 <Heffalump> my report has gone walkies
17:08:08 <Heffalump> oh no, just buried
17:08:45 <Igloo> Oh, duh, none of the types do satisfy both
17:09:05 <Heffalump> I was about to ask :-)
17:09:10 <Heffalump> cos the report says that the first one should.
17:09:18 <dons> @djinn ((a -> C b) -> C a) -> C a
17:09:19 <Igloo> What first one?
17:09:20 <lambdabot> f :: ((a -> C b) -> C a) -> C a
17:09:20 <lambdabot> f x1 x2 = x1 (\ c15 _ -> x2 c15) (\ c11 -> x2 c11)
17:09:23 <Heffalump> IM that you should get the first one that does.
17:09:28 <Igloo> Right
17:09:44 <Heffalump> default really is a terrible hack.
17:10:18 * Igloo was just thinking one of the types subsumed the context of the others, for no good reason
17:10:23 <SamB> @GOD
17:10:24 <lambdabot> Unknown command, try @listcommands.
17:10:40 <dons> @djinn a -> S s a
17:10:41 <lambdabot> f :: a -> S s a
17:10:41 <lambdabot> f x1 x2 = (x1, x2)
17:10:44 * SamB waits for stack overflow
17:11:02 <dons> @djinn S s a -> (a -> S s b) -> S s b
17:11:02 <lambdabot> f :: S s a -> (a -> S s b) -> S s b
17:11:02 <lambdabot> f x1 x2 x3 =
17:11:02 <lambdabot>   case x1 x3 of
17:11:02 <lambdabot>   (v4, v5) -> case x2 v4 v5 of
17:11:02 <lambdabot>       (v6, v7) -> (v6, v7)
17:11:19 <Heffalump> what's S?
17:11:19 <Igloo> Is S state here?
17:11:26 <dons> yep
17:11:30 <Heffalump> can it do lists yet?
17:11:35 <Heffalump> or are recursive types too hard?
17:11:39 <Heffalump> @djinn a -> Maybe a
17:11:40 <lambdabot> -- f cannot be realized.
17:11:49 <dons> I've added @djinn-add, which lets you add new function sigs and type synonyms
17:12:00 <dons> @djinn-add id :: a -> a
17:12:05 <dons> @djinn a -> a
17:12:06 <lambdabot> f :: a -> a
17:12:06 <lambdabot> f x2 = id x2
17:12:10 <jethr0> hehe
17:12:10 <dons> well, close :)
17:12:16 <Heffalump> @djinn-add type Maybe a = Either a ()
17:12:19 * Igloo spent a few seconds trying to work out how S-the-combinator made that make sense  :-)
17:12:30 <Heffalump> @djinn a -> Maybe a
17:12:30 <lambdabot> f :: a -> Maybe a
17:12:30 <lambdabot> f x2 = Left (id x2)
17:12:32 <Heffalump> yay
17:12:36 <Heffalump> even if that is a bit confusing
17:12:42 <Heffalump> @djinn Maybe a
17:12:43 <lambdabot> f :: Maybe a
17:12:43 <lambdabot> f = Right ()
17:12:56 <jethr0> @djinn Maybe (a,b) -> Maybe (b,a)
17:12:57 <lambdabot> f :: Maybe (a, b) -> Maybe (b, a)
17:12:57 <lambdabot> f x2 =
17:12:57 <lambdabot>   case x2 of
17:12:57 <lambdabot>   Left (v5, v6) -> Left (v6, id v5)
17:12:57 <lambdabot>   Right _ -> Right ()
17:13:06 <Heffalump> do you have a @djinn-remove, or an easy way to remove stuff?
17:13:07 <jethr0> huh?
17:13:14 <dons> yep, @djinn-del
17:13:18 <Heffalump> good.
17:13:23 <Heffalump> @djinn-add magic :: a -> b
17:13:25 <jethr0> why is Left and Right in Maybe?
17:13:35 <Heffalump> @djinn (x,y) -> (z,w)
17:13:36 <lambdabot> -- f cannot be realized.
17:13:38 <Heffalump> hmph!
17:13:50 <dons> it doesn't unify type synonyms
17:13:54 <int-e> lambdabot: id v5, eh?
17:13:56 <Heffalump> jethr0: cos I made up a type synonym
17:13:56 <dons> @djinn a -> b
17:13:57 <lambdabot> f :: a -> b
17:13:57 <lambdabot> f x3 = magic x3
17:14:03 <Heffalump> @djinn c -> d
17:14:04 <lambdabot> -- f cannot be realized.
17:14:04 <jethr0> he
17:14:11 <Heffalump> oh. It just knows about the *named* types a and b.
17:14:16 <jethr0> cool, then my example worked *yeh*
17:14:19 <dons>  Djinn does
17:14:19 <dons> *not* instantiate polymorphic function.
17:14:26 <dons> according to the readme :)
17:14:35 <Heffalump> @djinn Maybe (a -> a)
17:14:35 <lambdabot> f :: Maybe (a -> a)
17:14:35 <lambdabot> f = Left (\ c8 -> id c8)
17:14:42 <jethr0> @djinn (a,a) -> (b,b)
17:14:43 <lambdabot> f :: (a, a) -> (b, b)
17:14:43 <lambdabot> f (v4, _) = (magic v4, magic v4)
17:14:51 <dons> ah, nice.
17:14:55 <int-e> @djinn b->a
17:14:55 <lambdabot> -- f cannot be realized.
17:15:00 <Heffalump> it could at least alpha-rename.
17:15:03 <jethr0> what an idiot :)
17:15:03 <Heffalump> oh well
17:15:11 <dons> darcs send ;)
17:15:13 <Heffalump> @djinn-del magic :: a -> b
17:15:26 <dons> oh, but magic was fun :)
17:15:36 <jethr0> dons, like there is a chance in hell that _i_ am going to fix a theorem prover........
17:15:39 <Heffalump> @djinn-del type Maybe a = Either a ()
17:15:46 <Heffalump> yeah, but confusing for other people who come along later
17:16:00 <dons> well, magic is, umm, magic. what more is there to say :)
17:16:20 <SamB> so @djinn is a curry-howard prover?
17:16:25 <sdjp> Re my eariler type problem: Yeah, a fromInteger in the correct place fixed all the type inferenceing.  Still very impressed with the inferencing, even if it;s not perfect ;)
17:16:32 <dons> unfortunately, type synonyms aren't deleted. bug in djinn.
17:16:37 <Heffalump> samb: I believe so.
17:16:57 <jethr0> sdjp, *yeah* i got it right. pity though that i have no idea where it had to go :)
17:16:58 <Heffalump> what will I do to it if I add type Foo = Foo ?
17:17:24 <dons> accroding to the readme: "Warning: Type synonyms are treated as macros and are not checked in
17:17:27 <dons> any way (e.g., for recursive definitions)"
17:17:37 <SamB> can someone cabalize Haskore please?
17:17:39 <Heffalump> so I'll probably cause it to run away.
17:17:40 <dons> so, who knows? eventually the plugin will "screw up" as it says.
17:17:43 <SamB> lilypond is getting unwieldy
17:17:44 <Heffalump> And by extension, lambdabot.
17:17:48 <sdjp> jethr0, it had to do in front of round, becuase that can only produce an Integer (logically enough)
17:17:54 <twb> Why doesn't ['x','!'..'~'] DWIM?
17:17:55 <dons> nah, lambdabot will kill it after 30 seconds
17:17:57 <jethr0> :)
17:17:57 <dons> maybe...
17:17:58 * int-e wants to quote SamB in a non-Haskell context.
17:18:06 <Heffalump> oh, you run all stuff under a timeout?
17:18:13 <SamB> int-e: what did I say?
17:18:13 <dons> right.
17:18:14 <jethr0> > ['x', '!'..'~']
17:18:16 <lambdabot> ""
17:18:26 <Heffalump> > ['a' .. 'z']
17:18:27 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
17:18:30 <jethr0> > map ord "x!~"
17:18:32 <lambdabot> [120,33,126]
17:18:33 <int-e> SamB: "can someone cabalize Haskore please?"
17:18:33 <Heffalump> > ord '!'
17:18:34 <lambdabot> 33
17:18:51 <Heffalump> > ['x'] ++ ['!' .. '~']
17:18:52 <jethr0> always good to consult the almighty ascii table
17:18:53 <lambdabot> "x!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`
17:18:53 <lambdabot> abcdefghijklmnopqrstuvwxyz{|}~"
17:18:56 <SamB> int-e: why do you want to quote that? it won't make any sense!
17:19:00 <twb> That's odd.
17:19:03 <twb> It works for integers...
17:19:06 <int-e> SamB: yes. that's why.
17:19:07 <Heffalump> twb: what did you want, the result I gave?
17:19:09 <twb> > [1,2..10]
17:19:11 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
17:19:18 <jethr0> > [120,33..126]
17:19:19 <Heffalump> twb: that may not be doing what you think
17:19:19 <lambdabot> []
17:19:25 <Heffalump> > [1,3..10]
17:19:25 <twb> Heffalump: yes, but why doesn't it work the other way?
17:19:26 <lambdabot> [1,3,5,7,9]
17:19:32 <twb> Oh.
17:19:33 <int-e> SamB: <xxx> hurr what to the who with the which?
17:19:41 <twb> Heffalump: what is that doing?
17:19:42 <Heffalump> in [x,y..z] it counts from x to z in steps of (y-x)
17:19:46 <twb> Aha.
17:19:51 <int-e> SamB: that's what I got back :)
17:19:52 <twb> (from y to z by x)
17:19:54 <Heffalump> it's not [x] ++ [y..z], cos you can write that that way.
17:20:00 <SamB> int-e: what context was that?
17:20:11 <Saulzar> > [1, 3 .. 10]
17:20:13 <lambdabot> [1,3,5,7,9]
17:20:16 <twb> > [2,'a'..'z']
17:20:17 <lambdabot>  add an instance declaration for (Num Char)
17:20:17 <lambdabot>   In an arithmetic sequence: [2, 'a' .. 'z']
17:20:17 <lambdabot>   In the definition of `yno': yno = [2, 'a' .. 'z']
17:20:26 <dons> all calls into modules get run under a 30 second timeout: mapLB (timeout $ 30*1000*1000) act
17:20:30 <jethr0> > [chr 2, 'a'..'z']
17:20:31 <lambdabot> "\STXa"
17:20:32 <Heffalump> no, it really does count in steps of (y-x).
17:20:42 <int-e> SamB: does not matter. It had nothing to do with Haskell at all. Nor with coding, actually.
17:20:45 <Heffalump> > ['a','c'..'z']
17:20:46 <jethr0> huh?
17:20:46 <lambdabot> "acegikmoqsuwy"
17:21:06 <twb> Oooh.
17:21:08 <twb> Now I see.
17:21:09 <Heffalump> > ['z','x'..'a']
17:21:10 <lambdabot> "zxvtrpnljhfdb"
17:21:23 <twb> [x,y,z] ===> (from x to z by (- y x))
17:21:33 <Heffalump> YM [x,y..z]
17:21:38 <Heffalump> and I'm sure I said that above :-)
17:21:40 <twb> Yeah.
17:21:52 <twb> My brain is slow.
17:22:57 <Heffalump> let tenmeeeeeeeeelion = 10000000 in [1,1000000..tenmeeeeeeeeelion]
17:23:03 <Heffalump> > let tenmeeeeeeeeelion = 10000000 in [1,1000000..tenmeeeeeeeeelion]
17:23:04 <lambdabot> [1,1000000,1999999,2999998,3999997,4999996,5999995,6999994,7999993,
17:23:04 <lambdabot> 8999992,9999991]
17:23:31 <jethr0> > let tenmeeeeeeeeelion = 10000000 in [0,1000000..tenmeeeeeeeeelion]
17:23:33 <lambdabot> [0,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,
17:23:33 <lambdabot> 9000000,10000000]
17:23:45 <Heffalump> has anyone asked for lambabot's line breaking point to be be changed to allow for timestamps too?
17:23:53 <Heffalump> so reduced by 8 chars or so
17:24:40 <twb> Your terminal isn't 300chars wide? ;-)
17:24:43 <dons> no one has asked for this.
17:24:57 <jethr0> my terminal is ca. 80 chars wide
17:25:06 <twb> It shouldn't wrap at all.
17:25:13 <twb> That should be up to the IRC client.
17:25:32 <jethr0> hmm
17:25:54 * jethr0 would love multiline/indented code for ">"
17:25:58 <Heffalump> twb: IRC clients don't know good wrapping points
17:26:01 <Heffalump> lambdabot does
17:26:01 <dons> not sure. wrapping was introduced for a reason. but maybe our use of lambdabot has changed over time.
17:26:09 <twb> Heffalump: maybe *your* IRC client doesn't :-)
17:26:31 <dons> lambdabot does haskell-sensitive breaks, which is an improvement 
17:26:44 <Heffalump> dons: if you're going to keep wrapping, could you reduce the point at which it wraps by 8 chars?
17:26:46 <twb> With a bit of effort, I could make mine use haskell mode for anything lambdabot says.
17:27:16 <Heffalump> twb: lambdabot says stuff that isn't Haskell too, though
17:27:21 <twb> True.
17:27:26 <Heffalump> so you'd have to work out which was and which wasn't. Whereas lambdabot knows.
17:27:32 <dons> Heffalump, it would break at 67chars,  is that ok?
17:27:39 <jethr0> you could prefix lambda answers with ">"
17:27:42 <int-e> hmm. I doubt there's a line length that suits everyone.
17:27:44 <Heffalump> it's doing it at 75 now?
17:27:47 <dons> yup
17:27:50 <jethr0> s/lambda/haskell/
17:28:06 <twb> Heffalump: just tell your client to s/<lambdabot>/<\>/
17:28:07 <dons> unless i have a different setting on the #haskell bot, let me check..
17:28:09 <Heffalump> int-e: yeah, but doing it at 80 - length "[01:23] <lambdabot> " is probably a good default
17:28:23 <Heffalump> > 80 - length "[01:23] <lambdabot> "
17:28:24 <lambdabot> 60
17:28:26 <twb> That would remove exactly 8 chars.
17:28:38 <Heffalump> twb: true.
17:28:57 <int-e> Heffalump: I include seconds in the timestamp (but I'm using xchat so it doesn't really matter - in fact lambdabot's line length is ideal right now for my window width)
17:28:57 <Heffalump> well, if other people object to changing the wrapping number, that's fine.
17:29:17 <Heffalump> but if it's not a big deal for anyone, then 60 would be better for me.
17:29:33 <Heffalump> and I think as long as it doesn't get ridiculously small, then less is better than more.
17:29:34 <twb> It seems to me that <<80 chars will make lambdabot say too many lines.
17:29:51 <Heffalump> because it looks really ugly when it wraps a few characters onto the next line
17:30:14 * palomer contemplates writing a first order theorem prover in haskell
17:30:23 <palomer> anyone know how to do unification using monads?
17:30:24 <rep> good luck
17:30:31 <dons> can be done as a lab exercise palomer.
17:30:36 <dons> let me find you a ref
17:31:09 * Heffalump --> bed
17:31:48 <dons> in this course, we build them http://www.cse.unsw.edu.au/~kleing/teaching/thmprv-05/index.html
17:32:12 <dons> there's slides and links and stuff that would be useful
17:33:47 <int-e> @index newSTRef
17:33:48 <lambdabot> Data.STRef.Lazy, Data.STRef, Data.STRef.Strict
17:34:59 <twb> What's the inverse of ord in Haskell?
17:35:00 <jethr0> is there a debian package for cabal...
17:35:21 <twb> jethr0: there's an unofficial Debian repo for haskell packages.
17:35:22 <jethr0> i am kinda unused to building _everything_ from scratch
17:35:24 <twb> jethr0: I forget where.
17:35:26 <palomer> that looks like a fun course
17:37:22 <shapr> hej WillKW
17:37:26 <WillKW> Hi, small question: I'm trying to join 2 lists, and expecting : to work, but failing (I'm using tail[list] : head[list]). Am I doing something terribly stupid? (I'm currently fighting the 'I could do it in perl!' scream)
17:37:30 <WillKW> Hello shapr 
17:37:45 <WillKW> Gosh, I am typing oddly today. I feel like somebody who learned english out of a book
17:37:55 <shapr> What about using ++ ?
17:38:04 <shapr> > [1..5] ++ [5 .. 9]
17:38:05 <lambdabot> [1,2,3,4,5,5,6,7,8,9]
17:38:13 <jethr0> willkw, (tail lst) ist a list, while (:) expects a value as first param
17:38:30 <dons> @type (:)
17:38:32 <lambdabot> forall a. a -> [a] -> [a]
17:38:33 <dons> @type (++)
17:38:35 <lambdabot> forall a. [a] -> [a] -> [a]
17:38:59 <jethr0> maybe you want (head lst):(tail lst), but that not much good is it :). maybe reverse...
17:39:04 <palomer> type (:).(++)
17:39:09 <palomer> @type (:).(++)
17:39:11 <lambdabot> forall a. [a] -> [[a] -> [a]] -> [[a] -> [a]]
17:39:16 <WillKW> *nod* I'm new to the languge, and trying to learn. The slope is steep, but I think I'm getting my head around some of the concepts.
17:39:34 <jethr0> huh?
17:39:45 <int-e> @type ((:).).((++).)
17:39:46 <lambdabot> forall a a1. (a -> [a1]) -> a -> [[a1] -> [a1]] -> [[a1] -> [a1]]
17:39:53 <shapr> @learn
17:39:54 <lambdabot> http://www.haskell.org/learning.html
17:39:57 <shapr> @wiki HaskellDemo
17:39:58 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
17:40:03 <shapr> @wiki HaskellNewbie
17:40:04 <lambdabot> http://www.haskell.org/hawiki/HaskellNewbie
17:40:41 <int-e> @pl \x y z -> x:(y++z)
17:40:42 <lambdabot> (. (++)) . (.) . (:)
17:40:49 <shapr> WillKW: bor du i g√∂teborg?
17:41:05 <palomer> let successor = \n x f -> f (n f x); zero = \x f -> x in successor zero
17:41:10 <palomer> <let successor = \n x f -> f (n f x); zero = \x f -> x in successor zero
17:41:12 <palomer> >let successor = \n x f -> f (n f x); zero = \x f -> x in successor zero
17:41:24 <twb> What's the inverse of ord in Haskell?
17:41:29 <palomer> > let successor = \n x f -> f (n f x); zero = \x f -> x in successor zero
17:41:30 <shapr> chr
17:41:30 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:41:30 <lambdabot>   Expected type: (t -> t1) -> t2 -> t
17:41:30 <lambdabot>   Inferred type: (t -> t1) -> t2 -> t -> t1
17:41:45 <palomer> eh? you can't type church numerals in haskell?
17:41:45 <twb> shapr: ah, it was because I wasn't importing all of Char.
17:42:12 <twb> palomer: it's because of the type unification algorithm.
17:42:16 <int-e> palomer: you can type the individual numerals but not succ
17:42:18 <twb> palomer: you have to do it in a roundabout way.
17:42:32 <int-e> @type \f x -> f (f (f x))
17:42:33 <lambdabot> forall t. (t -> t) -> t -> t
17:42:34 <palomer> so, erm, the unification algorithm is flawed?
17:42:47 <int-e> palomer: no. succ is not a member of typed lambda calculus.
17:42:48 <dons> umm. you're trying to do untyped lambda calculus.
17:42:58 <palomer> oh, it isn't:O!
17:42:59 <twb> palomer: no, it just has edge cases that behave oddly.
17:43:11 <palomer> edge cases?
17:43:15 <twb> That's what I found for U and Y, anyway.
17:43:24 <int-e> hmm
17:43:32 <twb> palomer: I mean it mostly does what you want.
17:43:49 <int-e> > let successor = \n x f -> f (n x f); zero = \x f -> x in successor zero
17:43:50 <lambdabot>  add an instance declaration for (Show (t -> (t -> t1) -> t1))
17:43:53 <palomer> Y isn't typable in typed lambda calculus either
17:43:57 <palomer> yet it's typable in haskell
17:44:02 <Cale> Haskell isn't the same as the untypel lambda calculus
17:44:04 <int-e> on the other hand you might just want to get your parameter order correct
17:44:07 <int-e> my fault.
17:44:10 <Cale> untyped*
17:44:14 <int-e> > let successor = \n x f -> f (n x f); zero = \x f -> x in successor zero 0 (+1)
17:44:15 <lambdabot> 1
17:44:33 <Cale> (\x -> x x) doesn't have a type
17:44:40 <Cale> (for one)
17:44:40 <palomer> Cale: yes! it does
17:44:49 <palomer> Cale: we went over this 3 weeks ago
17:44:52 <Cale> not in Haskell
17:44:53 <palomer> someone found a type for it
17:44:55 <palomer> yes!
17:45:02 <jethr0> @type fix (1:)
17:45:04 <lambdabot> Not in scope: `fix'
17:45:12 <jethr0> @type Control.Monad.Fix.fix (1:)
17:45:13 <lambdabot> forall a. (Num a) => [a]
17:45:17 <palomer> Cale: if you annotate it, haskell will find a type for it
17:45:59 <Cale> Does this use an extension?
17:46:10 <palomer> Cale: I don't know
17:46:18 <Cale> what type then?
17:46:21 <palomer> I forget
17:46:27 <Cale> I can't see how it could have a non-infinite type
17:46:31 <int-e> > let two = \f x -> f (f x) in two two (+1) 0
17:46:33 <lambdabot> 4
17:46:41 <int-e> > let two = \f x -> f (f x) in two two two (+1) 0
17:46:41 <palomer> I don't see how forall a. (Num a) => [a] is inhabited
17:46:42 <lambdabot> 16
17:46:44 <palomer> so we're even
17:46:52 <int-e> > let two = \f x -> f (f x) in two two two two (+1) 0
17:46:54 <lambdabot> 65536
17:46:55 <int-e> fun :)
17:47:03 <palomer> this (+1) annoys me
17:47:25 <palomer> I can't see how Y doesn't have an infinite type either
17:47:43 <palomer> what's the best book to learn unification from?
17:47:57 <Cale> oh, you could use a higher rank type
17:48:07 <Gs30ng> can i add tuples, like (1, 1) + (0, 1) = (1, 2) ? prelude function zipWith works on only lists
17:48:19 <int-e> palomer: no lambda term for Y is typable. (which follows as a corrollar from the strong normalization property of typed lambda calculus)
17:48:22 <Cale> @type \(x :: (forall a. a)) -> x x)
17:48:23 <lambdabot> parse error on input `)'
17:48:36 <Saulzar> Gs30ng, You can make an instance of Num for tuples, then you can
17:48:43 <Cale> @type \(x :: (forall a. a)) -> x x
17:48:45 <lambdabot> forall t. (forall a. a) -> t
17:48:45 <palomer> int-e: Y is typable in haskell
17:48:50 <palomer> Cale: see!
17:49:10 <int-e> palomer: Haskell has recursion.
17:49:18 <frederik> is there any difference between "(a->r)->r" and "a", i mean, can we like find a total bijection between the domains of those types
17:49:37 <Cale> yeah, that's a bit odd, almost anything could be made to have a type like that
17:49:43 <int-e> palomer: that's an important difference from pure lambda calculus (be it typed or not)
17:49:54 <palomer> frederik: I don't see how those types are similar
17:50:00 <Cale> (that's a Glasgow extension)
17:50:10 <palomer> frederik: but associating (a->r)->r with a is called "pierce's law
17:50:12 <palomer> "
17:50:15 <jimapple> fred: well, there is certainly an injection
17:50:31 <jimapple> fred: but the trivial injection doesn't have an inverse
17:50:31 <palomer> but seriously, how is (a->r)->r and a similar?
17:50:43 <Cale> the only valid value you can pass that function is 'undefined'
17:50:50 <jimapple> @djinn a -> ((a->r)->r)
17:50:51 <Cale> (if you give it that type, at least)
17:50:51 <lambdabot> Cannot parse command
17:50:51 <lambdabot> Cannot parse command
17:50:51 <lambdabot> f :: a -> (a -> r) -> r
17:50:51 <lambdabot> f x3 x4 = x4 (id x3)
17:50:58 <palomer> Cale: so every term is typable in haskell?
17:51:06 <Cale> maybe in GHC
17:51:16 <palomer> that's silly:O!
17:51:19 <Gs30ng> hmm. i can simply make a function
17:51:25 <frederik> palomer: if x::a then (\f -> f x)::(a->r)->r
17:51:31 <jethr0> > @type (\x -> x x) undefined
17:51:32 <lambdabot>  parse error on input `@'
17:51:34 <Cale> palomer: you have to really go out of your way
17:51:36 <Gs30ng> move (x, y) (a, b) = (x+a, y+b)
17:51:37 <jethr0> @type (\x -> x x) undefined
17:51:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:51:38 <lambdabot>   Expected type: t
17:51:43 <Gs30ng> there i can add tuples
17:51:49 <frederik> and you can always pass 'id' to the continuation to get something of type "a" back, what's wrong with that?
17:51:51 <Cale> well, actually no, some things will just contain type errors, of course
17:51:54 <jethr0> *yeh*
17:52:01 <jimapple> @djinn ((a->r)->r) -> a
17:52:02 <lambdabot> Cannot parse command
17:52:02 <lambdabot> Cannot parse command
17:52:02 <lambdabot> -- f cannot be realized.
17:52:03 <Pupeno> lisppaste2: url
17:52:04 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:52:08 <Cale> but every pure lambda term, perhaps
17:52:22 <Cale> even if some of them get stupid types like that
17:52:27 <jimapple> so, djinn doesn't know how to go backwards
17:52:30 <jethr0> @type (\x -> x x) id
17:52:31 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:52:31 <lambdabot>   Expected type: t
17:52:34 <Cale> @type (\(x :: (forall a. a)) -> x x) undefined
17:52:35 <lambdabot> forall t. t
17:52:40 <jethr0> hehe
17:52:49 <Cale> the explicit type signature isn't optional
17:52:52 <SamB> jimapple: I hope not!
17:53:02 <frederik> ooh what's this djinn thing?
17:53:09 <Cale> frederik: it writes code
17:53:16 <Cale> based on the type you give it
17:53:23 <frederik> who made it?
17:53:24 <jimapple> yes, it would worry me, too. I was just trying to answer fred
17:53:24 <jethr0> @djinn (a,b,c) -> (c,a,b)
17:53:25 <lambdabot> Cannot parse command
17:53:25 <lambdabot> Cannot parse command
17:53:25 <lambdabot> f :: (a, b, c) -> (c, a, b)
17:53:25 <lambdabot> f (v4, v5, v6) = (v6, id v4, v5)
17:53:32 <lisppaste2> Pupeno pasted "ProgramOptions" at http://paste.lisp.org/display/14586
17:53:33 <Cale> @djinn (b -> c) -> (a -> b) -> (a -> c)
17:53:34 <jimapple> Lennart Augustson (sp?)
17:53:34 <lambdabot> Cannot parse command
17:53:34 <lambdabot> Cannot parse command
17:53:34 <lambdabot> f :: (b -> c) -> (a -> b) -> a -> c
17:53:34 <lambdabot> f x3 x4 x5 = x3 (x4 x5)
17:53:42 <Cale> what's with the errors?
17:53:44 <jimapple> why is djinn complaining?
17:53:47 <Pupeno> Any hints about how to improve ProgramOptions ?
17:53:50 <Cale> they weren't there before
17:54:08 <jethr0> maybe he doesn't like out "id" definition
17:54:12 <int-e> hmm, did anyone add bogus declarations to djinn? using djinn-add maybe?
17:54:30 * jethr0 shakes his head energetically *nooooooho*
17:55:02 <Cale> @listcommands djinn
17:55:03 <lambdabot> djinn provides: djinn djinn-add djinn-del
17:55:09 <Cale> hmm...
17:55:14 <Cale> no djinn-list
17:55:17 <int-e> @djinn-del
17:55:23 <jethr0> @djinn-del id
17:55:29 <dons> oh, someone stuck something bad in the environment.
17:55:32 <jethr0> @djinn (a,b,c) -> (c,a,b)
17:55:33 <lambdabot> Cannot parse command
17:55:33 <lambdabot> Cannot parse command
17:55:33 <lambdabot> Cannot parse command
17:55:33 <lambdabot> f :: (a, b, c) -> (c, a, b)
17:55:33 <lambdabot> f (v2, v3, v4) = (v4, v2, v3)
17:55:38 <frederik> what is magic?
17:55:39 <dons> fixing...
17:55:42 <jethr0> *o,o*
17:55:50 <frederik> @djinn (a->b->a)->a->[b]->a
17:55:51 <lambdabot> Cannot parse command
17:55:51 <lambdabot> Cannot parse command
17:55:51 <lambdabot> Cannot parse command
17:55:51 <lambdabot> f :: (a -> b -> a) -> a -> [b] -> a
17:55:51 <lambdabot> f _ x2 _ = x2
17:55:53 <jethr0> it adds new errors with each "add"/"del"
17:55:57 <jethr0> @djinn-del id
17:56:00 <jethr0> @djinn (a,b,c) -> (c,a,b)
17:56:01 <lambdabot> Cannot parse command
17:56:01 <lambdabot> Cannot parse command
17:56:01 <lambdabot> Cannot parse command
17:56:01 <lambdabot> f :: (a, b, c) -> (c, a, b)
17:56:01 <lambdabot> f (v2, v3, v4) = (v4, v2, v3)
17:56:05 <jethr0> or not
17:56:14 <frederik> hey that wasn't what it told me in private
17:56:15 <dons> just chill out for a second and let me fix it...
17:56:20 <int-e> @djinn-del id :: a -> a
17:56:38 <int-e> poor lambdabot
17:56:52 <jimapple> hm. Is there an iso from (forall r . (a -> r) -> r) to a? probably, by Pierce. But Haskell doesn't have negation types or continuations, so we can't proove it with a well-typed term
17:56:55 <palomer> frederik: palomer: if x::a then (\f -> f x)::(a->r)->r <--what does this mean?
17:57:03 <jethr0> int-e, i already delete "id" and djinn stopped using it superflously
17:57:10 <palomer> frederik: oh, nevermind
17:57:11 <jethr0> s/super.*/wantonly/
17:57:16 <palomer> I was thinking of :: as sml's :
17:57:18 <jethr0> :)
17:57:47 <int-e> @listcommands djinn
17:57:50 <palomer> anyways, if you want to check out the connection between a and (a->r)->r check out CPS
17:58:06 <lambdabot> djinn provides: djinn djinn-add djinn-del
17:58:10 <frederik> jimapple: but what about the term (\c -> c id)
17:58:32 <palomer> so noone has any good books on unification?
17:58:54 <jimapple> @type (\c -> c id)
17:58:56 <lambdabot> forall a t. ((a -> a) -> t) -> t
17:58:57 <frederik> palomer: it sounds like it would just be mentioned in some other book. 
17:59:09 <frederik> palomer: like on prolog or theorem proving
17:59:22 <jimapple> fred: what about it?
18:00:05 <Cale> I'm not sure I completely understand negation types.
18:00:15 <jimapple> I think Pierce's law is equiv to ((a -> b) -> a) -> a
18:00:18 <dons> @pl \a -> fst a /= i
18:00:19 <lambdabot> (i /=) . fst
18:00:20 <palomer> Cale: negation types are (a->r)->r ?
18:00:20 <jimapple> Yeah, I certainly don't
18:01:08 <Cale> I've seen something like ~a = a -> 0, where 0 is the empty type. -- but isn't that necessarily empty itself?
18:01:18 <Cale> I suppose unless a = 0
18:01:30 <frederik> jimapple: but there should be other ways to type that with universal quantifiers
18:01:44 <Cale> perhaps I'm missing something though
18:02:31 <jimapple> I'm not too good at forall manipulations - which way are you thinking of?
18:03:02 <palomer> ~a = forall b. a->b
18:03:15 <Cale> ah, okay
18:03:24 <Cale> that's somewhat different
18:03:39 <palomer> actually, no
18:03:40 <jimapple> is is? forall b . a -> b = a -> (forall b . b)
18:03:40 <jimapple> ?
18:03:50 <palomer> ~a = a -> forall b.b
18:04:22 <jimapple> who wrote pointless? is it separable from lambdabot?
18:04:37 <frederik> @type (\c::(forall r. (a->r)->r) -> c id)
18:04:38 <lambdabot>   Inferred type is less polymorphic than expected
18:04:38 <lambdabot>   Quantified type variable `r' is mentioned in the environment:
18:04:45 <frederik> i must be missing something
18:04:49 <Cale> hmm, there's not many elements of that type though
18:05:12 <palomer> Cale: there are many elements of a -> forall b.b?
18:05:19 <Cale> I can't see many
18:05:33 <palomer> I can't see any
18:05:55 <Cale> forall b. b usually has bottom as an element, at least here
18:05:57 <palomer> however, ~~a is interesting
18:06:12 <palomer> very, very interesting
18:06:18 <shapr> jimapple: TheHunter, and yes.
18:06:37 <Cale> really?
18:06:39 <palomer> in fact, if a is inhabited, then ~~a types everything!
18:06:57 <Cale> ~~a = (a -> forall b.b) -> forall b.b
18:07:18 <palomer> yeah
18:07:20 <dons> jimapple, it is a lambdabot plugin written by TheHunter.
18:07:26 <palomer> if a is inhabited, then a -> forall b.b is not
18:07:34 <Cale> palomer: why?
18:07:42 <Cale> is forall b. b empty?
18:07:45 <dons> anything with an '@' prefix is a call to a command in a lambdabot plugin.
18:07:55 <palomer> Cale: ah, I was starting with the assumption that it was
18:08:03 <palomer> what's in forall b. b?
18:08:08 <Cale> bottom
18:08:13 <Cale> at least, in Haskell
18:08:13 <palomer> darn you bottom!
18:08:25 <palomer> but bottom isn't even a haskell value (is it?)
18:08:32 <dons> > undefined  :: ()
18:08:33 <Cale> yes, it's part of the semantics
18:08:33 <lambdabot> Undefined
18:08:36 <dons> sure.
18:08:40 <palomer> > undefined
18:08:40 <Cale> > undefined :: Int
18:08:41 <lambdabot> Add a type signature
18:08:42 <lambdabot> Undefined
18:08:46 <Cale> > undefined :: [Char]
18:08:48 <lambdabot> Undefined
18:08:59 <Cale> > undefined :: [(Int, [Char])]
18:09:01 <lambdabot> Undefined
18:09:10 <dons> > undefined :: 1
18:09:11 <Cale> @type undefined :: [(Int, [Char])]
18:09:11 <jimapple> so, if a is uninhabited, what's in a -> 0 besides \_ -> _|_
18:09:12 <lambdabot>  add an instance declaration for (Show GHC.Base.Unit)
18:09:12 <lambdabot> [(Int, [Char])] :: [(Int, [Char])]
18:09:17 <frederik> it's my favorite value
18:09:21 <palomer> well, I don't see any simple interpretation of haskell types
18:09:30 <palomer> but in system F everything is so clean!
18:09:39 <jimapple> except for inference . . . 
18:09:40 <frederik> it's like a chameleon
18:09:47 <palomer> screw inference:O!
18:09:48 <dons> it's all system F, except for the extensions, palomer.
18:09:51 <shapr> yeah, except for inference...
18:09:59 <dons> but its the extensions where the fun is at.
18:10:04 <palomer> dons: but that changes the interpretations of system F
18:10:52 <dons> hmm. how? you can still program in the F subset.
18:11:09 <jimapple> I will ask a better way: what inhabits ~a if a in uninhabited?
18:11:17 <dons> don't stiick GADTs and so on in your code.
18:12:27 <benny> "It is not the intention of this section to run down these great projects."
18:12:36 <palomer> jimapple: everything?
18:12:46 <Cale> jimapple: just one thing
18:13:30 <palomer> we should just move to AF2 and be over with
18:13:32 <Cale> hmm
18:13:34 <Cale> 0 -> 0
18:13:51 <Cale> Is 0 empty here though?
18:14:11 <WillKW> Hmm. Perhaps an easier question. How can I return the last item on a list
18:14:15 <Cale> or are we really dealing with 1 -> 1 ?
18:14:30 <Cale> WillKW: you had another?
18:14:36 <Cale> (sorry if it was missed)
18:14:41 <Cale> > last [1,2,3,4,5]
18:14:42 <lambdabot> 5
18:14:58 <jimapple> 0->0 would be fine, but what if there are two uninhabited types?
18:15:07 <WillKW> *headsmack* It's this kind of thing I dislike learning. The basic-basics.
18:15:10 <WillKW> Cale: Thank you
18:15:17 <Cale> WillKW: no problem
18:15:31 <palomer> > let realSlimShady [a] = a; realSlimShady a:b = realSlimShady b in realSlimShady [1,2,3]
18:15:31 <lambdabot>  Parse error in pattern
18:15:38 <palomer> eh?
18:15:57 <jimapple> dons: is 
18:15:57 <jimapple> f ::  (forall a . a -> t a) -> b -> t (t b)
18:15:57 <jimapple> f g x = g (g x)
18:15:57 <jimapple> in F?
18:16:12 <palomer> in system F?
18:16:15 <jimapple> right
18:16:33 <palomer> system F doesn't have parametric types
18:16:34 <palomer> so no
18:16:35 <palomer> :O!
18:16:38 <jimapple> F2?
18:16:49 <palomer> AF2 has better than parametric types: dependent types
18:17:05 <Cale> > let realSlimShady [a] = a; realSlimShady (a:b) = realSlimShady b in realSlimShady [1,2,3]
18:17:06 <lambdabot> 3
18:17:16 <palomer> oh, righto
18:17:32 <palomer> why did my previous one parse incorrectly?
18:18:00 <palomer> last [1..1000]
18:18:03 <palomer> > last [1..1000]
18:18:04 <Cale> realSlimShady a:b is something like ((realSlimShady a) :) b
18:18:04 <lambdabot> 1000
18:18:12 <Cale> though that's not treated as a section :)
18:18:18 <palomer> > last [1..100000]
18:18:19 <lambdabot> 100000
18:18:22 <palomer> > last [1..1000000]
18:18:23 <lambdabot> 1000000
18:18:26 <palomer> > last [1..10000000]
18:18:28 <lambdabot> 10000000
18:18:36 <rep> last [1..] ?
18:18:38 <jimapple> the suspense is killing me
18:18:44 <palomer> oh my
18:18:48 * WillKW worries he might be trying to find the last element of an infinite list
18:18:53 <palomer> haskell can do 10^7 calls in 1 second
18:18:55 <Cale> > last [1..]
18:18:55 <palomer> that's not bad.
18:18:59 <lambdabot> Terminated
18:19:02 <jimapple> > time -p last [1 .. realdamnbig]
18:19:03 <lambdabot>  Not in scope: `realdamnbig'
18:19:05 <Cale> > last [1..10^8]
18:19:10 <lambdabot> Terminated
18:19:14 <palomer> aw shucks
18:19:48 <palomer> considering my processor runs at 3*10^9 instructions per second, that's not bad at all
18:20:53 <palomer> 300 instructions per call:O!
18:22:07 <jethr0> doesn't darcs remember where it "got" code from so that one can do a simple "darcs update" or so?
18:22:46 <jethr0> ah, "pull" seems to work
18:24:08 <twb> What's MEMBER called in Haskell?
18:24:19 <twb> a -> [a] -> Bool
18:24:19 <int-e> > 3 `elem` [1,2,3,4,5]
18:24:20 <lambdabot> True
18:24:24 <twb> Thanks.
18:25:08 * palomer can't wait until haskell '06 and its revamped module system comes out
18:26:01 <jethr0> darcs version of hs-plugins doesn't "configure" with "(postConf defaultUserHooks)' is applied to too few arguments in the call"
18:26:03 <jethr0> any ideas?
18:26:23 <twb> Can I access the non-exported symbols in a module, a la CL's package::symbol?
18:26:25 <jethr0> @hoogle a -> [a] -> Bool
18:26:26 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
18:26:26 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
18:26:26 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
18:26:33 <twb> jethr0: cool!
18:26:46 <jethr0> :)
18:27:01 <palomer> @hoogle forall a.a
18:27:02 <lambdabot> Prelude.undefined :: a
18:27:02 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
18:27:02 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:27:08 <SamB> palomer: so you are an optimist?
18:27:27 <palomer> SamB: you can't actually think they won't revamp the module system
18:27:30 <jethr0> @hoogle [a] -> [a] -> [a]
18:27:31 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
18:27:31 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
18:27:31 <lambdabot> Data.List.(\\) :: Eq a => [a] -> [a] -> [a]
18:27:35 <jethr0> nice
18:27:42 <palomer> 3 functions inhabit forall a.a ? that's nuts!
18:27:49 <SamB> palomer: no, I meant about calling it "haskell 2006"
18:27:52 <palomer> hoogle is  the best thing in the world
18:28:50 <WillKW> My prof has done this coursework in 30 lines. If I can debug this one error, I might get it in 5
18:29:03 <palomer> @hoogle forall a. ((a-> forall b.b) ->forall b.b) -> a
18:29:04 <lambdabot> No matches, try a more general search
18:30:01 <palomer> @hoogle [a]->a
18:30:03 <Saulzar> What's wrong with the module system? I know you think functors are the best thing since sliced bread... but typeclasses do the same thing
18:30:03 <lambdabot> Data.List.head :: [a] -> a
18:30:03 <lambdabot> Data.List.last :: [a] -> a
18:30:03 <lambdabot> Prelude.head :: [a] -> a
18:30:26 <jethr0> darcs version of hs-plugins doesn't "configure" with "(postConf defaultUserHooks)' is applied to too few arguments in the call"
18:30:35 <jethr0> any ideas?
18:30:42 <palomer> Saulzar: oh, I don't care THAT much about functors (though sometimes it is best to do things at the module level), but module signatures are very important
18:31:09 <palomer> like, I want to do something like module M = (myFriendsImplentation restricted to signature S)
18:31:24 <Saulzar> The one thing which I find great about haskell is the 'uniformity', instead of providing 10 redundant ways to do the same thing
18:32:14 <palomer> functors and type classes solve different problems. using one to solve the other's problem is awkward
18:32:19 <palomer> I admit that there is an intersection
18:32:29 <Saulzar> palomer, You can do import Foo (X, Y, Z) ... where's the big deal?
18:32:30 <palomer> anyways, I still think that signatures is the best thing since sliced bread
18:32:45 <Cale> palomer: how does all that work with separate compilation?
18:32:52 <palomer> Saulzar: and those functions go in the namespace?
18:33:09 <Saulzar> import qualified Foo (X, Y, Z) as Bar
18:33:11 <palomer> Cale: good question
18:33:33 <palomer> Saulzar: and how do you know X, Y and Z have the types I expect?
18:34:31 <Saulzar> Um - you chose the module and X, Y, Z - you'll get an error as usual where you try to mis-use them :)
18:34:41 <dons> jethr0, Cabal bug. uncomment   {- xx -} in the Setup.lhs file
18:34:51 <dons> s/bug/version issue/
18:35:21 <palomer> Saulzar: or, say, I've written something and then I tell someone else to implement it. in SML I would say "implement this signature"
18:35:21 <jethr0> ha, thx, i finally uncommented the whole postConf part and that work too :)
18:35:50 <palomer> Saulzar: signatures are also a good place to put documentation
18:36:22 <jethr0> mixing debian packages and self-compiled modules doesn't go too well with ghc-pkg :(
18:37:00 <Saulzar> Doesn't seem terribly useful without functors, your abstract datatype can't be substituted without search-replace
18:37:23 <palomer> Saulzar: my abstract datatype?
18:37:34 <palomer> Saulzar: the datatypes are in the signatures
18:37:59 <Saulzar> Well I presume that's what you're atlking about when you say "implement this siganture" .. you want to make an abstract module (usually a data type)
18:38:28 <Saulzar> Instead you make a type class, and tell somone to make an instance :P
18:38:55 <palomer> "implement this signature" means "write a module that has these values with these types"
18:39:02 <Cale> I wonder if a sufficiently powerful extensible record system would be indistinguishable from a first-class module system :)
18:39:20 <palomer> Saulzar: usually you tell someone to implement modules, not create instances!
18:39:21 <jethr0> what do you mean by record? the {} thingeys?
18:39:30 <palomer> Cale: yeah, I was thinking about that too
18:39:42 <Cale> jethr0: well, that, but more powerful
18:39:52 <Cale> (that sort of thing though)
18:39:55 <Saulzar> palomer, Why? 
18:40:10 <jethr0> @where hoogle
18:40:11 <lambdabot> http://www.haskell.org/hoogle
18:40:43 <Cale> http://haskell.org/hawiki/TrexStyleRecords -- this sort of thing would be closer
18:41:55 <palomer> Saulzar: well, for one, to limit namespaces
18:42:21 <Cale> hmm... http://research.microsoft.com/Users/simonpj/Papers/first-class-modules/
18:42:38 <Saulzar> Usually I would make one data type (or related) per module anyway, I can't see the issue
18:42:42 <palomer> yeah
18:42:55 <palomer> Cale: that's sml style modules in haskell
18:43:02 <Cale> yeah
18:44:13 <Saulzar> I can see the point in signatures/functors used together, but somehow having "bits" of them indepedantly doesn't seem so useful to me
18:44:37 <Cale> palomer: okay, and that actually proceeds by extending the record system
18:45:05 <palomer> so why don't they do it!!
18:45:23 <Cale> it seems to describe some pretty severe changes
18:45:34 <palomer> for a good cause
18:45:42 <Cale> for example, allowing existentials without a data constructor
18:47:05 <Saulzar> less is more? :)
18:47:31 <Cale> error: Skolemized type "f'" introduced in open of "s" escapes scope of binding in type "f' Int"
18:49:27 <jethr0> dons, where can i find which channel lambdabot connects to?
18:49:37 <Cale> Config.hs
18:49:38 <jethr0> somehow the server get's no ident :(
18:50:02 <palomer> is tiny haskell lazily evaluated?
18:54:37 * lispy has a Haskell to Java (or C#) manual translation question
18:54:59 <jethr0> hehe
18:55:00 <lispy> does anyone here have experience in rewriting haskell programs into imperative languages?
18:55:03 <Cale> hehe
18:55:17 <lispy> stop laughing! ;)
18:55:18 <Cale> Well, what is it that you're trying to translate?
18:55:20 <jethr0> no, but i'd be interested to hear your question
18:55:31 <Cale> GHC does that
18:55:40 <Cale> It rewrites Haskell into C
18:55:41 <Cale> :)
18:55:47 <lispy> well, a friend of my wrote a system in haskell with a nice clear spec
18:56:05 <lispy> and now he needs to hire someone else to implement a commercial version in Java or C#
18:56:19 <lispy> he's trying to get an estimate of how much time/work that would take
18:56:22 <Cale> why not use the Haskell version if it works?
18:56:23 <jethr0> couldn't he just ForeignFunctionInterface it from C#?
18:56:35 <Cale> Probably more time/work than it's worth
18:56:44 <lispy> the assumption is that the hired programmers will not know Haskell
18:56:52 <gzl> can you get GHC to spit out the C source?
18:56:56 <Cale> Yes
18:57:01 <gzl> neat
18:57:02 <jethr0> yes, but you seriously don't wanna read it!
18:57:03 <lispy> yes, but it's unreadable :)
18:57:08 <gzl> even for short programs?
18:57:12 <jethr0> yes
18:57:14 <gzl> oh. damn.
18:57:23 <Cale> very unreadable :)
18:57:30 <sploo22> gzl: use ghc -C
18:57:41 <gzl> ok. sounds like I don't want to though. :)
18:58:11 <Saulzar> Hehe, output the C code and get the hired programmer to maintain that :)
18:58:17 <lispy> heh
18:58:22 <sploo22> gzl: if you use foreign export declarations you can get a nice clean C interface
18:58:24 <lispy> i bet they'd rather learn haskell :)
18:58:34 <SamB> lispy: no kidding
18:58:46 <SamB> that stuff looks like ASM
18:58:51 <jethr0> cale, you have any idea whether the source of the lambdabot network-fickleness is known? i'd love to fix it, but have no idea where to start
18:58:56 <gzl> sploo22: ok
18:58:59 <jethr0> or how to simulate those network undefinednesses
18:59:15 <lispy> "So, do you want to maintain this code?  *unveils ghc generated C*, or THIS CODE! *unveils elegant haskell*"
18:59:25 <palomer> some things in haskell are very hard to rewrite
18:59:31 <Cale> jethr0: I had the same problem with my previous bot.
18:59:43 <SamB> palomer: you should see this lilypond I have here
18:59:50 <lispy> palomer: well, fortunately they have a spec and will probably not use the actually haskell source
18:59:52 <jethr0> well, couldn't one just ping now and then and fix it in the IRC part?
18:59:52 <Cale> palomer: especially into something like Java
18:59:53 <Saulzar> Just tell them that you forgot what the variables mean, their first task is to remedy this :)
18:59:55 <palomer> lilypond?
19:00:03 <SamB> palomer: musicsetting package
19:00:18 <palomer> I've used lilypond
19:00:21 <SamB> unfortunately it sounds broken but I can't figure out why
19:00:52 <palomer> how did you know I was into digital music:O?
19:01:13 <palomer> (then again, some things in java are non trivial in haskell)
19:01:21 <palomer> well, haskell98 anyways
19:01:32 <SamB> no, I meant it seems hard to rewrite ;-)
19:01:35 <jethr0> palomer like what?
19:01:53 <lispy> the nice thing about java is the huge api
19:01:53 <palomer> SamB: rewrite lilypond in haskell?
19:02:02 <SamB> palomer: no, this one file
19:02:03 <Cale> lispy: I suppose it depends on how much it relies on Haskell's features. Most Haskell programs would be impossible to directly translate, even in rough design terms.
19:02:08 <lispy> i say we rewrite haskell in haskell
19:02:15 <palomer> jethr0: try writing the SICP circuit simulator in haskell
19:02:25 <SamB> I thought you meant haskell code that was hard to refactor
19:02:28 <Cale> If it's sufficiently complex, it may be simpler to teach people Haskell in order to modify the program.
19:02:31 <jethr0> i've seen something similar in monads/arrows
19:02:37 <jethr0> tying the knot
19:02:42 <jethr0> but not sure how well that went
19:02:49 <lispy> Cale: i agree.  I think is this case since they assume the new hires won't know haskell that we can ignore the fact that there is an exising implementation except as a blackbox reference.
19:03:01 <palomer> jethr0: could it handle recursive circuits?
19:03:13 <jethr0> yup, more or less
19:03:33 <palomer> was it a pain to write?
19:03:36 <Cale> lispy: basically. Though it seems stupid to me to do a rewrite of that kind.
19:03:37 <jethr0> arrows can definitely handle some of it... but this "tying the knot" or however one writes that is all about making cyclic data types in haskell
19:03:41 <lispy> hehe,i would ask this question in #java and see if they ask what haskell is :)
19:04:00 <lispy> Cale: i totally agree, but for some reason, the people in charge want to do it that way
19:04:02 <Cale> ask away -- I'd like to see the response :)
19:04:04 <palomer> jethr0: cyclic values, not types
19:04:05 <SamB> arrows make combinators trickier
19:04:06 <jethr0> http://haskell.org/hawiki/TyingTheKnot
19:04:57 <palomer> yeah, streams lets you do anything which would have required mutability
19:05:04 <palomer> but, erm, the translation is non trivial
19:05:19 <SamB> palomer: do you know of a decent music package besides lilypond?
19:05:31 <lispy> Cale: done :)
19:05:34 <palomer> SamB: abc
19:05:45 <SamB> palomer: abc?
19:05:46 <palomer> but it really depends what you want to do
19:06:01 <Korollary> lispy: think of the simpler problem. How hard would it be to write a C to Java converter? Wouldn't that sell like crazy? I bet a haskell to java converter would be awfully hard, and the generated java code would be unfriendly.
19:06:13 <Cale> lispy: hehe
19:06:23 <palomer> http://abcplus.sourceforge.net/
19:06:29 <Cale> lispy: out of curiosity, how many lines of Haskell is it?
19:06:29 <SamB> I've a looong piece (12 page) with lots of bits repeated
19:06:41 <SamB> sometimes slightly different
19:06:47 <lispy> i wonder if we should look at the line count, multiply by the estimated java line count and then get an estimate from that
19:06:55 <palomer> SamB: what's the initial format?
19:07:00 <lispy> Cale: not sure, and my friend who has the source is not online, atm
19:07:01 <jethr0> korollary, i'd guess that transforming "down" yields better code than transforming "up"...
19:07:02 <SamB> palomer: sheet music
19:07:10 <SamB> well, PDF really...
19:07:17 <Cale> I'd say for well-written haskell code, you can expect 10 to 15x the line count.
19:07:26 <palomer> SamB: you know there is a tool for converting pdf to digital sheet music
19:07:29 <palomer> SamB: but it costs
19:07:38 <SamB> palomer: this is for fun
19:07:42 <jethr0> hmm, sounds a lot, and will start a discussion about lines, expressions, etc again
19:07:55 <palomer> lilypond won't convert pdf to digital sheets!
19:07:57 <Cale> lispy: and a lot more difficulty, for some applications
19:08:17 <SamB> palomer: I don't expect it to do that
19:08:42 <palomer> http://www.neuratron.com/photoscore.htm
19:08:45 <palomer> or smartscore
19:08:54 <SamB> not paying money
19:08:56 <Cale> I find it interesting that #java is telling you the same thing as #haskell :)
19:08:59 <SamB> would never use it anyway
19:09:05 <palomer> SamB: just telling you what's out there
19:09:10 <palomer> SamB: where do you get your sheet music?
19:09:25 <lispy> Cale: yeah!
19:09:26 <palomer> SamB: so you're going to copy the pdf note by note? try rosegarden
19:09:32 <SamB> hmm, my sister printed this piece out from animescores.com
19:09:45 <Cale> lispy: do you know what the code does?
19:09:55 <palomer> rosegarden is probably your best bet
19:10:02 <palomer> 12 pages is long though
19:10:05 <palomer> be prepared to spend half a day
19:10:11 <SamB> only half?
19:10:20 <jethr0> cale, this lambdabot issue. you think it's rooted in the IRC code, in your opinion?
19:10:37 <lispy> Cale: yeah, it's for UCheck, you can google for papers on it if you like
19:10:50 <Cale> jethr0: I don't know -- from what I could tell, no notification of the disconnect was happening at all.
19:10:50 <lispy> Cale: it's for finding errors is excel spreadsheets, basically
19:10:54 <Korollary> jethr0: well, when you're transforming down, the features/idioms in the upper level don't exist in the lower level, so you have to produce a lot of emulation support. That would be unfriendly.
19:11:11 <Cale> jethr0: This happens to me in XChat too
19:11:16 <palomer> SamB: yeah, half hour a page is largely enough
19:11:49 <palomer> and if half a day is too long, you can get the shareware of smartscore and use that
19:11:56 <jethr0> korollary yes, but in terms of code quality this emulation layer is still _far_ better than having to deal with super-low-level c code and trying to push that into java's type system!
19:11:58 <SamB> huh
19:12:01 <palomer> or the shareware of photoscore
19:12:27 <jethr0> a friend of mine nearly lost it when trying to handle network packets in java, because untyped memory blobs are not a forte of java's.
19:12:31 <WillKW> I could do it in perl!!
19:12:33 <jethr0> and are definitely use _too much_ in c
19:12:53 <palomer> imoff!
19:13:21 <lispy> to see the wizard?
19:13:43 <Cale> the wonderful wizard of Oz?
19:14:06 <jethr0> Pay no attention to that man behind the curtain
19:14:25 <SamB> they have a wizard?
19:14:39 <SamB> I thought they had a tutorial like everyone else
19:14:51 * SamB shudders
19:15:16 <pengo> jethr0, wow. i happen to be writing an untyped memory blob handler in java :)
19:15:38 <SamB> palomer: do you mean rosegarden2?
19:15:49 <jethr0> pengo, how's that going?
19:16:06 <pengo> jethr0, slowly. untyped memory blobs are not java's forte :)
19:16:10 <jethr0> hehe
19:16:16 <jethr0> how do you do it at all?
19:16:42 <pengo> jethr0, you write a hex editor with its own type system
19:16:58 <palomer> SamB: rosegarden4
19:17:15 <palomer> it's actually a half decent tool
19:17:21 <palomer> though I can't get software midi to work on it
19:17:22 <pengo> jethr0, there's a lot of shifting and masking action
19:17:27 <palomer> I just send everything to my keyboard
19:17:34 <jethr0> no, i mean getting the blob into an array (or whatever), doing pointer arithmetic and getting parts of the blob into typed java values?
19:17:55 <SamB> four is it?
19:18:00 <jethr0> i thought java wouldn't let you cast _anything_
19:18:06 <SamB> emu: Couldn't find package rosegarden4
19:18:12 <SamB> huh
19:18:21 <SamB> that was SUPPOSED to be an E
19:18:43 <palomer> jethr0: I've done that, in scheme!
19:18:45 <palomer> what a pain:O
19:19:23 <pengo> jethr0, no you can't cast.. you can only take bytes and stick them together into ints (with some shifting and masking and logical ORing) and then use those as variables
19:19:23 <palomer> rosegarden4 - music editor and MIDI/audio sequencer
19:19:27 <jethr0> palomer, but in scheme you at least haven't the type system to fight against!
19:19:31 <SamB> palomer: I have no synthesizer save a lousy FM
19:19:34 <lispy> thanks all
19:19:38 <jethr0> pengo :)
19:19:42 <SamB> I long for the long-lost days of windows when things actually worked...
19:19:48 <pengo> jethr0, or you could write your own byteloader
19:19:49 <lispy> time for dinner and then the bar
19:20:01 <SamB> and people had soundcards
19:20:09 <palomer> jethr0: you don't fight against it! you don't (and can't) directly cast anything,you simply use classes as structs
19:20:20 <jethr0> pengo, the JVM can handle all kinds of things... just write the byte loading stuff in haskell/java, python/java, whatever and be done with it :)
19:20:33 <palomer> SamB: you can convert to midi and play the midi with timidity or something
19:20:43 <SamB> palomer: yes, of course
19:20:53 <palomer> SamB: some people have gotten rosegarden to work with software synth
19:20:55 <palomer> not me though
19:21:12 <SamB> alsa is supposed to be able to do that...
19:21:15 <palomer> anyways, now I'm really off!
19:21:17 <jethr0> palomer, i've seen that done in CL and it was actually quite nice! anonymous on-the-fly classes...
19:21:36 <palomer> java has anonymous classes!
19:21:40 <palomer> ok, now I'm really, really off
19:22:04 <SamB> (of course, things may have worked in windows, but it was impossible to get things done anyways)
19:22:31 <jethr0> palomer, http://groups.google.com/group/comp.lang.lisp/msg/4fe888b58ffa83b8?hl=en
19:22:36 <pengo> jethr0, i'm trying to do something bigger and more generic but thanks :)
19:23:04 <jethr0> palomer, nono, _really_ anonymous, i.e. their type is built on-the-fly... anonymous meta-classes so to speak
19:23:29 <SamB> jethr0: you can do that
19:23:36 <SamB> Jython does
19:24:03 <SamB> it has to, to support overriding Java methods from Python classes
19:24:10 <SamB> ... potentially on the fly
19:24:15 <jethr0> yup, but i was quite impressed by the lisp code in the URL above... it's not understandable, but so is dense haskell code *g*
19:25:18 <jethr0> took me a _long_ time to understand _how_ he was doint it...
19:25:59 <jethr0> samb, metaclass support is one of the few niceties of python. but although i am no professional on metaclasses i don't think they implemented the whole idea very cleanly :(
19:26:59 <SamB> jethr0: not that
19:27:09 <frederik> what latex libs do people use to publish haskell papers? is there some latex source i can look at for reference?
19:27:23 <jethr0> ?
19:27:46 <SamB> I don't remember if Jython (based on 2.2 as it is) even *has* any sort of metaclasses
19:28:10 <jethr0> it really should because they are quite central to python's "type system"
19:29:47 <twb> jethr0: you mean classes like Instance, Class, Attribute, etc?
19:29:58 <twb> And methods like defineMethod.
19:30:38 <jethr0> i think so...
19:31:02 <twb> CL calls them the Metaobject Protocol, for some reason.
19:31:43 <jethr0> i know. supposedly quite complex! and it dates back to the early 80s or something...
19:31:56 <twb> Bah.
19:32:05 <twb> Smalltalk was around long before then! :-)
19:32:13 <SamB> actually, Jython is based on 2.1
19:32:17 * jethr0 wants to someday read "the art of metaobject protocol", but haskell is really a lot nicer than CL, so maybe he won't ever :(
19:32:28 <SamB> and 2.2, iirc, is when they introduced metaclasses
19:32:45 <SamB> and yes, metaclasses are REALLY NASTY in python
19:32:55 <twb> SamB: what a surprise.
19:32:57 <SamB> the C nature of Python really shows through
19:33:45 <jethr0> i don't get why they didn't adopt stackless python. it runs pretty fast and allows stuff like microthreads and continuations
19:34:18 <jethr0> but then again they want to get rid of "lambda" and "map"...
19:34:46 <SamB> stackless would be a great application for darcs...
19:35:06 <jethr0> frederik, just came across pphs - a pretty printer for latex documents...
19:35:17 <jethr0> samb ?
19:35:55 <jethr0> stackless python would also have made serializing the program state much easier!
19:36:00 <frederik> jethr0: thanks
19:36:05 <SamB> jethr0: well, currently it has its own seperate CVS tree with the modified sources...
19:36:19 <frederik> where is pphs?
19:36:30 <SamB> it would be a lot easier to manage them with darcs, no?
19:36:39 <jethr0> @google pphs haskell
19:36:40 <lambdabot> http://www.haskell.org/ghc/docs/4.06/users_guide/pphs.html
19:37:06 <jethr0> you mean easier than CVS?? no, how could it ;)))
19:37:18 <frederik> $ pphs --help
19:37:18 <frederik> Error: /undefinedfilename in (pphs.ps)
19:37:21 <frederik> great
19:38:04 <jimapple> @where pl
19:38:04 <lambdabot> I know nothing about pl.
19:38:15 <jimapple> @pl commands
19:38:16 <lambdabot> commands
19:38:21 <jethr0> haskell has a real documentation problem. whenever i'm looking for examples for sth there is _nothing_ to be found :((
19:38:30 <jimapple> @pl \f -> \x -> f x
19:38:31 <lambdabot> id
19:38:39 <jethr0> wtf
19:39:07 <SamB> jethr0: well, darcs is fantastic for that sort of thing
19:39:08 <jethr0> looks like a bug to me!
19:39:21 <jethr0> (\f -> \x -> f x) (+5) 3
19:39:26 <jethr0> > (\f -> \x -> f x) (+5) 3
19:39:27 <lambdabot> 8
19:39:35 <jethr0> how is that "id"??
19:39:57 <jethr0> @pl (\f -> (\x -> f x))
19:39:57 <SamB> hmm, I'm not going to be able to explain this while downloading rosegarden
19:39:57 <sploo22> > (+5) 3
19:39:57 <lambdabot> id
19:39:58 <lambdabot> 8
19:40:10 <jethr0> hmm, true, but weird
19:40:21 <Korollary> jethr0: There's quite a bit of code on the wiki. But yeah, in general few people => few examples.
19:40:23 <jethr0> ah, i get it...
19:40:29 <sploo22> jethr0: \x -> f x is equivalent to f
19:40:38 <jimapple> yay, eta equivalence
19:40:50 <jimapple> damn you, monomorphism restriction!
19:41:00 <SamB> jethr0: what looks like a bug
19:41:02 <jethr0> yah, i'm still not used to "id f x" and think it should be "(id f) x"... way to go, jethr0!
19:41:03 <SamB> jethr0: > id (+5) 3
19:41:05 <jethr0> never mind
19:41:07 <SamB> > id (+5) 3
19:41:08 <lambdabot> 8
19:41:18 <SamB> jethr0: hehe
19:41:24 <SamB> also ($) = id
19:41:30 <SamB> @pl ($)
19:41:30 <lambdabot> id
19:41:47 <jethr0> > ($) (+5) 3
19:41:48 <lambdabot> 8
19:41:51 <jethr0> unreadable!
19:42:51 <sploo22> SamB: it should be, but it isn't quite
19:42:54 <sploo22> > id 1 + id 2
19:42:55 <lambdabot> 3
19:42:59 <sploo22> > ($) 1 + ($) 2
19:43:00 <lambdabot>  add an instance declaration for (Num (a -> b))
19:43:15 <jimapple> no thank you!
19:43:25 <SamB> sploo22: types permitting, of course
19:43:54 <SamB> @type id
19:43:55 <lambdabot> forall a. a -> a
19:43:57 <SamB> @type ($)
19:43:58 <lambdabot> forall b a. (a -> b) -> a -> b
19:44:11 <jimapple> @type id :: (a -> b) -> (a -> b)
19:44:12 <lambdabot> (a -> b) -> (a -> b) :: forall a b. (a -> b) -> a -> b
19:45:29 <sploo22> SamB: ok, so I guess $ is restricted to functions in order to thwart my attempts at obfuscation :)
19:45:50 <SamB> sploo22: yes, exactly ;-)
19:46:05 <jethr0> @type (id $)
19:46:06 <lambdabot> forall a. a -> a
19:46:20 <jimapple> @type \f -> \x -> f `id` x
19:46:21 <lambdabot> forall t t1. (t -> t1) -> t -> t1
19:46:34 <SamB> jethr0: thats a section
19:46:38 <jethr0> i know
19:46:39 <SamB> @type (id .)
19:46:40 <lambdabot> forall b a. (a -> b) -> a -> b
19:46:53 <jimapple> @type Monad.ap
19:46:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
19:47:02 <jethr0> @type ((((id $) $) $) $)
19:47:03 <lambdabot> forall a. a -> a
19:47:04 <SamB> so, id on $ and ., strangely enough, gives you the other ;-)
19:47:23 <SamB> okay, not quite
19:47:25 <sploo22> @type (id ($))
19:47:26 <lambdabot> forall a b. (a -> b) -> a -> b
19:47:27 <SamB> but something like that
19:47:43 <jimapple> @type \f -> \x -> f `Monad.ap` x
19:47:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:48:10 <jimapple> @type \x -> id `Monad.ap` x
19:48:11 <lambdabot> forall a b.
19:48:11 <lambdabot> (Monad ((->) (a -> b))) =>
19:48:11 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
19:48:25 <jimapple> that's no good!
19:49:47 <Cale> ($) is id
19:49:52 <Cale> with a restricted type
19:59:36 * araujo next to hack a bit
20:05:13 <TheHunter> @type \x -> id `Control.Monad.Reader.ap` x
20:05:14 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
20:07:34 <Cale> @djinn ((a -> b) -> a) -> (a -> b) -> b
20:07:35 <lambdabot> f :: ((a -> b) -> a) -> (a -> b) -> b
20:07:35 <lambdabot> f x1 x2 = x2 (x1 (\ c7 -> x2 c7))
20:07:39 <jethr0> anyone got any ideas whether/how to convert Language.Haskell.Syntax to Language.Haskell.TH.Syntax?
20:10:01 <int-e> ah, djinn knows nothing about eta reduction.
20:10:36 <jethr0> @help
20:10:37 <lambdabot>  @help <command> - ask for help for <command>
20:10:39 <jethr0> @commandlist
20:10:40 <lambdabot> Unknown command, try @listcommands.
20:10:43 <jethr0> @listcommands
20:10:43 <lambdabot> use listcommands [module|command], please. Modules are:
20:10:43 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
20:10:43 <lambdabot> hoogle karma localtime more pl plugs poll quote search seen spell state
20:10:43 <lambdabot> system todo topic type version vixen where
20:10:50 <Cale> @pl f x1 x2 = x2 (x1 (\ c7 -> x2 c7))
20:10:50 <lambdabot> f = ap id
20:11:30 <Cale> hehe, and we're back at TheHunter's implementation, modulo eta
20:11:48 <int-e> heh. do you think it'd be wise to hook up djinn with pl?
20:12:15 <Cale> It would be nice if we could plug the output of one command into another :)
20:12:35 <Cale> something like @pl @djinn ((a -> b) -> a) -> (a -> b) -> b
20:13:05 <soysauce> it seems to me that @pl (djinn ...) would be more Haskellish
20:13:25 <TheHunter> @pl . @djinn $
20:13:26 <lambdabot> (line 1, column 1):
20:13:26 <lambdabot> unexpected "."
20:13:26 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
20:13:26 <lambdabot> expression
20:13:43 <int-e> @pl djinn x = x x
20:13:43 <lambdabot> djinn = join id
20:15:07 <jimapple> @type join id
20:15:08 <lambdabot> Not in scope: `join'
20:15:18 <jimapple> @type Monad.join id
20:15:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
20:15:19 <lambdabot>   Expected type: a -> a -> a1
20:15:28 <jimapple> huh?
20:15:40 <jimapple> @pl f x = x x
20:15:40 <TheHunter> @type let djinn x = x x in x
20:15:40 <lambdabot> f = join id
20:15:41 <lambdabot> Not in scope: `x'
20:15:43 <soysauce> pl allows you to make functions that are impossible
20:15:46 <TheHunter> @type let djinn x = x x in djinn
20:15:47 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:15:47 <lambdabot>   Expected type: t
20:15:47 <int-e> jimapple: @pl does not know much about types.
20:16:01 <jimapple> ah
20:16:05 <jimapple> quite interesting
20:16:10 <jimapple> @type Monad.join
20:16:11 <soysauce> there is no such x for which djinn x = x x would be valid
20:16:11 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:16:31 <int-e> (does it know anything? it's just a term rewriting system, right?)
20:16:33 <TheHunter> @type \x y -> Control.Monad.Reader.join x y
20:16:34 <lambdabot> forall t a. (Monad ((->) t)) => (t -> t -> a) -> t -> a
20:16:44 <soysauce> indeed
20:16:57 <jimapple> Is join id typeable with impredicativity, and m = Id
20:17:42 <TheHunter> We can't have m = Id.
20:18:24 <TheHunter> djinn is already typeable right now.
20:18:37 <TheHunter> @type \x -> x x
20:18:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:18:38 <lambdabot>   Expected type: t
20:18:44 <TheHunter> @type \(x :: forall a. a -> a) -> x x
20:18:45 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
20:19:40 <int-e> what good is a type with just one inhabitant?
20:19:58 <jimapple> consistency!
20:20:16 <soysauce> hm
20:20:30 <int-e> besides it has been pointed out that higher order types are not part of Haskell 98 ... and personally I have no firm understanding of them so I'd rather ignore them.
20:20:36 <soysauce> what's a good, efficient way to evaluate a list of computations and then use the result of the final one?
20:20:47 <soysauce> I was doing foldl' (>>) [...]
20:21:04 <jimapple> @type Monad.sequence
20:21:05 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
20:21:20 <soysauce> yeah, but is that efficient like a fold?
20:21:23 <int-e> @type foldr' (>>)
20:21:23 <lambdabot> Not in scope: `foldr''
20:21:28 <TheHunter> @type \(x :: forall a. a -> a -> a) -> x x
20:21:29 <lambdabot> forall a.
20:21:29 <lambdabot> (forall a1. a1 -> a1 -> a1) -> (a -> a -> a) -> a -> a -> a
20:21:29 <int-e> @type foldr (>>)
20:21:30 <soysauce> there is no such thing as foldr'
20:21:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> [m a] -> m b
20:21:33 <int-e> @type foldr1 (>>)
20:21:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
20:21:36 <TheHunter> this type has a lot of inhabitants.
20:21:59 <soysauce> foldl' is more efficient than foldr, though, isn't it?
20:22:16 <TheHunter> for strict functions, yes. for lazy ones, no.
20:22:30 <soysauce> in my case I'm working with an unboxed array which has to be populated, so strict computations are definitely what I want.
20:22:55 <TheHunter> > head $ foldl' (++) [] [1..100000000000]
20:22:56 <lambdabot>  add an instance declaration for (Num [a])
20:22:56 <lambdabot>   In an arithmetic sequence: [1 .. 100000000000]
20:23:11 <TheHunter> > head $ foldl' (++) [] $ map return [1..100000000000]
20:23:16 <lambdabot> Terminated
20:23:30 <TheHunter> > head $ foldr (++) [] $ map return [1..100000000000]
20:23:30 <soysauce> yes, I see ;)
20:23:31 <lambdabot> 1
20:23:37 <TheHunter> soysauce, most probably yes.
20:23:47 <soysauce> most definitely yes
20:24:06 <soysauce> I'm implementing Floyd-Warshall's algorithm
20:24:21 <soysauce> so I make a lot of updates to this array, and they all count
20:24:23 <int-e> soysauce: look at foldl1 (>>) (map print [1..]) :: IO ()   vs.  foldr1 <same tail>
20:24:53 <int-e> soysauce: the first never prints anything (and consumes more and more memory); the second starts printing immediately.
20:25:07 <soysauce> the first crashes GHCi ;)
20:25:21 <soysauce> I know that foldl has to recurse to the bottom before you get back any input
20:25:25 <soysauce> er, output rather
20:25:45 <soysauce> but my list of actions is finite, and it has to all be evaluated
20:26:05 <int-e> it has to do with the fact that >> can use up its left argument completely before using the right argument, so foldr is a better choice.
20:26:37 <soysauce> I have written this:
20:26:37 <soysauce> fw' a (k:ks) ijs = Data.List.foldl' (>>) (fw' a ks ijs) (map (fwstep a) ijs)
20:26:57 <soysauce> but now I want to know about order of evaluation
20:27:15 <soysauce> that will fold everything on the left *before* the right argument is ever evaluated, yes?
20:27:38 <soysauce> er
20:27:44 <soysauce> I'm referring to the (>>)
20:28:17 <soysauce> basically if my map expands out to [act1, act2, act3] then my computation becomes act1 >> act2 >> act3 >> (fw' a ks ijs) and is executed in exactly that order, correct?
20:28:40 <int-e> soysauce: >> satisfies ((a >> b) >> c) == (a >> (b >> c))
20:28:42 <soysauce> I have a sneaking suspicion that I'm going to get act1 >> (act2 >> (act3 >> fw' a ks ijs))
20:28:57 <soysauce> yes, but when dealing with side-effects, order of evaluation matters
20:29:07 <int-e> the monad does the sequencing
20:29:11 <soysauce> hmm, okay
20:29:16 <int-e> a is 'executed' first, then b, then c.
20:29:50 <soysauce> then it should hold that it always executes as ((a >> b) >> c) >> d
20:29:58 <soysauce> it would logically *have* to
20:32:48 <jethr0> @unknown
20:32:49 <lambdabot> Unknown command, try @listcommands.
20:33:01 <int-e> well. not really. a >> b says (for sequencing monads) 'execute a fully, then b'
20:33:22 <int-e> and it doesn't matter if it's ((a >> b) >> c) >> b or a >> (b >> (c >> d))
20:33:48 <int-e> semantically
20:33:52 <soysauce> no
20:34:14 <soysauce> writeArray a 0 1 >> writeArray a 0 2 >> writeArray a 0 3
20:34:23 <soysauce> or, better yet
20:34:41 <soysauce> I wrote a function, here is the type: mutate :: (Data.Array.MArray.MArray a e m, Ix.Ix i) => a i e -> i -> (e -> e) -> m ()
20:34:58 <int-e> do it with prints - (print 1 >> print 2) >> print 3 does the same as print 1 >> (print 2 >> print 3)
20:35:06 <soysauce> mutate a 0 (+1) >> mutate a 0 (*3) >> mutate a 0 (+2) -- order matters
20:35:08 <soysauce> ok
20:35:47 <soysauce> hmm, I guess I see, since the left is always executed first the parentheses don't matter
20:35:49 <int-e> you have to distinguish evaluation, to a Monad value (say, IO ()) and the actual execution of that monad operation.
20:36:08 <soysauce> I was thinking for some reason that the part in parentheses would be executed first
20:36:50 <int-e> it does not matter in what order the IO () values are computed - those calculations have no side effect. it's the execution in the monad that matters and there the order is assured by the monad's implementation of >>
20:37:05 <soysauce> yeah, I see
20:37:27 <mwc> I was scared when I finally "got" monads
20:37:35 <int-e> now because the execution happens from left to right, it makes sense to also provide the values from left to right, which is what foldr does.
20:37:53 <int-e> (but you should benchmark the code to be really, really sure)
20:38:37 <int-e> Part of the depth of Monads is that they're so simple ... it does not require much to make a monad.
20:38:51 <soysauce> foldl1' seems like what I want
20:41:38 <jethr0> #test
20:42:18 <Cale> mwc: scared?
20:43:04 <soysauce> monads make sense, but I'm accustomed to reasoning about Haskell assuming everything is referentially transparent...and everything else, except monads cheat by hiding state from you
20:43:21 <soysauce> ah well...
20:43:24 * soysauce keeps struggling with it
20:43:40 <int-e> > [1,2] >>= \x -> [3,4] >>= \y -> return (x+y)
20:43:41 <lambdabot> [4,5,5,6]
20:43:44 <mwc> Cale, yeah, kind of like the first time on a freeway with a sports car
20:43:49 <mwc> giddy would be a better word
20:43:51 <Cale> hehe
20:44:26 <mwc> Cale, how would you go about trying to show any group of order 12 is solvable? I'm trying to justify it having a subnormal series but can't get it to work
20:44:31 <Cale> soysauce: well, they're not really cheating (except IO, that's cheating)
20:44:33 <int-e> soysauce: I'd still use foldr1 ;)
20:44:53 <mwc> soysauce, nonsense, State monad doesn't cheat at all to hide state
20:44:54 <soysauce> Cale - heh :p
20:45:08 <soysauce> mwc - cheating in the sense of hiding a lot of the gory details
20:45:44 <mwc> ah, I reckon that's just playing smart
20:45:52 <sieni> mwc: wtf?
20:46:03 <Cale> soysauce: it's only cheating if you think about it one way
20:46:08 <mwc> cheating vs. playing a game smartly
20:46:23 <mwc> like counting cards at a casino isn't cheating
20:46:36 * int-e wonders why 'modify' isn't part of the StateM class ...
20:46:47 <Cale> if you think of a function  a -> m b  like a function  a -> b  only with side effects, then yeah, they cheat
20:47:23 <sieni> mwc: nothing :-)
20:47:43 <mwc> int-e, couldn't you do that by binding in a function that mucks your state and passes the value on unchanged?
20:47:49 * int-e wants to make ReaderT (MVar a) IO an instance of StateM and it turns out that modify is easier to implement directly instead of in terms of get and put. (and put would be best implemented in terms of modify)
20:49:13 <mwc> Cripes, exam tomorrow, must not get distracted by IRC
20:49:41 <int-e> int-e: the State module defines a modify function, as do x<-get; put (f x) ... but for the MVar that means I take the value twice and put it twice while I could get away with doing both only once.
20:49:56 <int-e> mwc: sorry, you. not myself.
20:50:20 <int-e> mwc and because it's not part of the type class, I can't easily redefine it.
20:51:06 <soysauce> http://www.rafb.net/paste/results/PrddyY43.html
20:51:10 <soysauce> can someone explain those errors?
20:51:33 <soysauce> @type Data.Array.MArray.readArray
20:51:34 <lambdabot> forall e (m :: * -> *) i (a :: * -> * -> *).
20:51:34 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.MArray a e m) =>
20:51:34 <lambdabot> a i e -> i -> m e
20:54:20 <palomer> it says here that neither of  Term a -> a -> Int  or Term a -> Int -> Int is more general than the other
20:54:26 <palomer> the first seems more general than the other
20:55:48 <int-e> nah. there's a natural bijection between the two types
20:56:10 <int-e> Term a -> b -> Int would be more general than Term a -> Int -> Int ... for me.
20:56:18 * int-e doesn't know how it's defined.
20:56:37 <palomer> oh wait, you're write, neither is more general
20:56:37 <palomer> hrm
20:56:39 <palomer> this is a problem
20:56:55 <palomer> this means that with GADTs, we may have no general type
20:57:14 * int-e doesn't understand soysauce' error
20:57:31 <soysauce> I don't either :(
20:58:52 <int-e> and in fact it loads without problems in my ghci
20:59:14 <int-e> with: import Data.Array.MArray, import Data.Ix as Ix
21:00:03 <int-e> (import Ix works, too, but I believe Data.Ix is preferred)
21:00:28 <soysauce> oh, I think I know why it's broken, but it still makes no sense
21:00:35 <soysauce> import qualified Data.Array.MArray;
21:00:38 <soysauce> readArray = Data.Array.MArray.readArray
21:00:38 <soysauce> writeArray = Data.Array.MArray.writeArray
21:01:00 <int-e> ah!
21:01:00 <soysauce> basically I wanted to be able to access Data.Array.MArray.* and then import those two functions into my namespace
21:01:11 <soysauce> but why would that cause these problems?
21:01:12 <int-e> you need to add type signatures for readArray and writeArray then
21:01:28 * int-e chants "monomorphism restriction"
21:01:39 <int-e> but why don't you add a line
21:01:53 <int-e> import Data.Array.MArray (readArray, writeArray)
21:01:53 <int-e> ?
21:02:09 <soysauce> because then I can't access anything else from MArray, right?
21:02:21 <int-e> in addition to the qualified import
21:02:24 <soysauce> ah
21:02:34 <int-e> you *can* import the same module twice. there's no problem with that.
21:02:39 <soysauce> *nods*
21:04:30 <soysauce> awesome, thanks
21:05:02 <int-e> funnily, this also fixes the problem:
21:05:06 <int-e> readArray a i = Data.Array.MArray.readArray a i
21:05:09 <int-e> writeArray a i v = Data.Array.MArray.writeArray a i v
21:05:14 <int-e> (without type signatures)
21:07:28 <int-e> and the same, but with only one parameter (a) in each line.
21:09:49 <soysauce> @pl \x -> (x, x)
21:09:49 <lambdabot> join (,)
21:10:02 <soysauce> @pl \(x, y) -> ((x, x), (y, y))
21:10:03 <lambdabot> join (,) *** join (,)
21:10:19 <soysauce> @pl \x y -> ((x, x), (y, y))
21:10:20 <lambdabot> (. join (,)) . (,) . join (,)
21:12:46 <sieni> in finnish by the way "pl" is short for "perusl‰tk‰", which is an euphemism for (medium to low quality) hash
21:16:09 <soysauce> that is an incredibly long type signature.
21:16:11 <soysauce> cowinit :: (MArray a e m, Ix i, Enum i, Num i, Integral e, Integral j) => i -> [((i, i), j)] -> m (a (i, i) e)
21:16:52 <soysauce> I don't understand how it worked before. I had the type signature wrong. It was returning a plain array, and the index was incorrect. But it did compile...wtf.
21:18:36 <pediddle> @moo
21:18:36 <lambdabot> Maybe you meant: map more msg todo yow
21:18:49 <Cale> @yow
21:18:50 <lambdabot> All right, you degenerates!  I want this place evacuated in 20 seconds!
21:18:59 <Cale> wow, that's harsh
21:23:08 <soysauce> @type Data.List.foldl1'
21:23:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
21:23:23 <soysauce> oh, d'oh
21:23:54 <palomer> that's foldl?
21:24:08 <soysauce> yes, of course...but I was trying to figure out why it wasn't in my namespace
21:24:18 <soysauce> and it was because I ... wasn't importing it
21:25:30 <int-e> > foldl (\a b -> "(" ++ a ++ " op " ++ b ++ ")") "init" ["first", "second", "third"]
21:25:31 <lambdabot> "(((init op first) op second) op third)"
21:25:56 <int-e> > foldl1 (\a b -> "(" ++ a ++ " op " ++ b ++ ")") ["first", "second", "third"]
21:25:57 <lambdabot> "((first op second) op third)"
21:26:00 <palomer> @type foldl
21:26:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:26:18 <palomer> @hoogle (a->b->a) -> a ->[b]->a
21:26:19 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
21:26:19 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
21:26:19 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
21:26:26 <int-e> and foldl1' is the same as foldl1, except that it does strict evaluation for the 'a's
21:26:34 <palomer> what the hell is foldl' and why is it exported?
21:26:36 <soysauce> which means tail recursion which is cheap
21:27:06 <int-e> similarily, foldl' does strict evaluation on the 'a's, too.
21:29:06 <Cale> If you want foldl in the first place, you usually want foldl'
21:29:10 <int-e> this is noticable on examples like foldl' (+) 0 [1..1000000]  vs.  foldl (+) 0 [1..1000000]. the first version is noticably faster; the second produces a stack overflow here ... hmm.
21:32:35 <int-e> > foldl (+) 0 [1..1000000]
21:32:36 <lambdabot> Exception: stack overflow
21:32:41 <int-e> > foldl' (+) 0 [1..1000000]
21:32:43 <lambdabot> 500000500000
21:32:53 <int-e> lambdabot agrees :)
21:33:59 <jethr0_> what do you think of a code pretty printer?
21:34:02 <jethr0_> $pretty fun x = case x of {3 -> "hello" ; 5 -> "world" ; _ -> "else"}
21:34:02 <jethr0_bot> fun x
21:34:02 <jethr0_bot>  = case x of
21:34:02 <jethr0_bot>    3 -> "hello"
21:34:02 <jethr0_bot>    5 -> "world"
21:34:02 <jethr0_bot>    _ -> "else"
21:34:08 <int-e> Cale: heh, can you think of an example where foldl is better than foldl'?
21:34:27 <Cale> hmm...
21:34:59 <int-e> maybe: foldl1 (flip const) [1..10]
21:35:19 <int-e> i.e. last in terms of foldl.
21:36:24 <int-e> we don't want that to be strict :)
21:36:40 <Cale> yes
21:37:31 <int-e> but foldr1 seems more appropriate for that.
21:37:44 * int-e shrugs.
21:40:16 <int-e> ghc produces better code for foldl1 though.
21:40:29 <int-e> funny
21:46:03 <dons> int-e, anything that has an undefined in the list?
21:46:58 <int-e> dons: yes, that was the train of thinking that lead me to implementing 'tail' :)
21:47:28 <int-e> err. last.
21:48:00 <jethr0_> is it possible to tell the bot to reload a plugin?
21:48:04 <dons> yes
21:48:11 <dons> @help dynamic
21:48:12 <lambdabot> dynamic is a module.
21:48:17 <dons> bah
21:48:19 <dons> @help dynamic-reload
21:48:19 <lambdabot>  @dynamic-[load,unload,reload] <module>, interface to dynamic linker
21:48:23 <dons> @list-commands dynamic
21:48:24 <lambdabot> dynamic provides:
21:48:24 <jethr0_> cool
21:48:39 <jethr0_> dons, what do you think of the code pretty printer?
21:48:47 <dons> pretty printers are fun :)
21:49:00 <jethr0_> should i submit it as a patch for lambdabot?
21:49:10 <dons> did you try the standard library pretty printer, or are you writing one from scratch?
21:49:34 <jethr0_> i used language.haskell.pretty... it's like 15 characters of code :)
21:49:44 <dons> yep. that's the one I was thinking of
21:50:14 <dons> well, hmm, I guess it could be a bit verbose for #haskell
21:50:28 <dons> it would be useful to some though, I suspect
21:50:33 <jethr0_> although i wonder how to get language.haskell.syntax to language.haskell.th.syntax... seems a pretty good idea, but there don't seem to be any functions for it :(
21:50:45 <dons> they're differrent data types
21:50:50 <dons> you'd have to write the injection
21:50:53 <jethr0_> dons, i thought it might be usefull when explaining to newbies what guards are, etc
21:51:03 <jethr0_> injection?
21:51:20 <dons> the function to inject values into the TH type from PPr type
21:51:50 <jethr0_> i know they are different data types and writing a projection seems trivial, but it's so usefull that i'd have thought somebody had already done it...
21:52:19 <dons> I think there's more been talk on combinging the two types. 
21:52:23 <dons> no ones done this 
21:52:49 <jethr0_> hmm, what an opportunity for me to earn some community credit :)
21:53:38 <dons> yeah, go for it
21:54:16 <jethr0_> unless there is a way to get at the internal representation of modules within TH itself. but as far as i can see, TH can only reify the types :(
22:05:16 <Pseudonym> Aha.
22:42:40 <soysauce> @type Data.Array.MArray.thaw
22:42:41 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
22:42:41 <lambdabot> (Data.Array.Base.MArray b e m,
22:42:41 <lambdabot> Data.Array.Base.IArray a e,
22:42:41 <lambdabot> GHC.Arr.Ix i) =>
22:42:41 <lambdabot> a i e -> m (b i e)
22:48:24 <palomer> a kind is really a parametric datatype, is it not?
22:49:04 <palomer> thaw has the ugliest type I've ever seen
22:49:27 <Cale> most of that crap is optional
22:49:31 <soysauce> most array types are similar
22:49:43 <soysauce> s/array types/types of functions that operate on arrays/
22:50:10 <Cale> It's really just (MArray b e m, IArray a e, Ix i) => a i e -> m (b i e)
22:50:27 <palomer> cleaner
22:50:40 <Korollary> palomer: a kind is a classification of types
22:51:03 <soysauce> do explain kinds again; I got lost the last time that discussion was held
22:51:14 <soysauce> but I am very curious
22:51:45 <Cale> Kinds are generated by two constructions.
22:52:21 <Cale> 1) * is the kind of types -- that is, any value in your program will have a type which is in this kind
22:52:59 <soysauce> there is also ? and ??, is there not?
22:53:40 <Cale> The situation with unboxed values gets more complicated
22:54:08 <Cale> 2) if k and l are kinds, then  k -> l  is the kind of type constructors taking a type constructor of kind k and giving a type constructor of kind l.
22:54:09 <Korollary> soysauce: this is a paper with a nice intro to that subject: http://www.cs.pdx.edu/~sheard/papers/PutCurryHoward2WorkFinalVersion.ps
22:54:52 <soysauce> Cale - what other kinds are there?
22:55:09 <Cale> Well, since * is a kind, we get the kind * -> *
22:55:30 <Cale> that's the kind of type constructors which take a type parameter and return a type.
22:55:43 <soysauce> *nods*
22:55:47 <Cale> @kind Maybe
22:55:48 <lambdabot> * -> *
22:55:50 <Cale> @kind Maybe Int
22:55:51 <lambdabot> *
22:55:56 <Cale> @kind Int
22:55:57 <lambdabot> *
22:56:35 <soysauce> rather abstract, but I have a shallow understanding now.
22:56:55 <Korollary> @kind (->)
22:56:56 <lambdabot> ?? -> ? -> *
22:57:12 <soysauce> (->) is a constructor?
22:57:33 <Korollary> it's a type constructor
22:57:42 <soysauce> ah
22:59:07 <Korollary> the paper I posted makes it pretty clear in its first 2 pages. The rest is also interesting if you are into GADT's.
22:59:20 <soysauce> ok
22:59:27 <soysauce> I'll read it when I have the chance
22:59:40 <soysauce> exam week this week...I'm trying to finish up a project so I don't fail this class heh
22:59:47 <Korollary> which class?
23:00:16 <soysauce> Haskell, actually
23:00:21 <soysauce> I forget the official name of the class
23:00:25 <soysauce> something about functional language programming
23:00:29 <soysauce> but we just learn Haskell
23:00:35 <Gs30ng> > ord ' '
23:00:36 <lambdabot> 32
23:00:38 <Korollary> heh
23:00:41 <soysauce> the professor is relatively new to Haskell, so it was...interesting
23:00:44 <soysauce> it was largely self-study
23:00:48 <Gs30ng> hugs98 doesn't have ord function?!
23:00:48 <Korollary> wow, that must suck
23:00:50 <soysauce> but I've thoroughly enjoyed it and learned a lot in the process
23:00:54 <soysauce> yes, in some ways ;)
23:01:23 <Korollary> man, how is the rest of the class doing? haskell is pretty hard for self-study...
23:01:26 <soysauce> but it doesn't suck when your professor thanks you for contributing to his understanding of the subject
23:01:55 <soysauce> I have a copy of GHC checked out from CVS, from pouring through some of the library code I learned a *lot*
23:02:15 <soysauce> he had asked about some of the magic behind why certain functions were fast and others slow, e.g. the Integer type
23:02:25 <soysauce> since his experiences with it in other languages has been that it's frequently very slow
23:02:39 <soysauce> so I pointed him to the definition for the type, the two cases S# and J#
23:02:55 <soysauce> and since it's GMP on the back-end, that explains a lot of the speed
23:03:11 <soysauce> the M must stand for Magic
23:03:27 <Korollary> is this an undergrad class?
23:03:29 <soysauce> yeah
23:03:45 <soysauce> it's the first year that it's been offered, and I doubt it will be offered again.
23:03:50 <Korollary> which uni?
23:04:12 <soysauce> people are too pragmatic. Computer Science really ought to be renamed Software Engineering, although that is a separate degree program here. But nobody does CS for CS theory.
23:04:23 <soysauce> Florida Institute of Technology, http://www.fit.edu/
23:04:39 <Korollary> As Alan Kay said, it should be renamed to "Java Vocational Training".
23:04:44 <soysauce> haha
23:04:47 <soysauce> that's pretty accurate
23:05:10 <Gs30ng> i'd love to learn the real CS, but sometimes i'm forced to be a lot pragmatic
23:05:22 <soysauce> I'm fortunate to have grown up with a father who programs, so I learned C and C++ around 1992.
23:05:48 <soysauce> and with a C/C++ background you can read Java fluently
23:05:56 <Cale> At Waterloo, CS was a department of the Mathematics faculty. It recently has changed its status to a "school", whatever that means, but things are still very mathematical.
23:05:56 <soysauce> although I've learned to write it, too. But it's not fun.
23:06:09 <soysauce> ah, that must be nice...a real CS program
23:06:33 <soysauce> the only positive thing that I can say about my uni is that we're accredited, but that doesn't mean a whole lot.
23:06:39 <Cale> There's a separate computer engineering program
23:06:44 <soysauce> *nods*
23:07:05 <Cale> That's mostly about high-level systems design things though, from what I understand.
23:07:06 <Korollary> being accredited is good for things like grad school.
23:07:29 <soysauce> it's good to be pragmatic, but if I were pragmatic then I'd probably not have come to uni anyway. I was fully capable of writing code prior, and I really haven't learned a *lot* of practical value here.
23:07:46 <soysauce> practical value is very relative, of course
23:08:02 <Korollary> well, there is more to CS than just languages, e.g. OS, networks, etc.
23:08:23 <soysauce> yes, right, but I wrote an OS while I was in high school...there is good theory, but you don't really need to understand the theory to get your hands dirty.
23:08:33 <Cale> It's sort of neat that at waterloo, everyone in math gets a bit of CS too.
23:09:03 <Cale> I was in pure mathematics, and I had to write a compiler (even if it was a simple language)
23:09:03 <soysauce> I think math is egregiously missing. I really wish that my education had taught me more about reasoning about programs--something that Dijkstra was interested in.
23:09:10 <Korollary> it's still good to get some structured training in it. I don't think it's time efficient to learn it all by yourself.
23:09:30 <soysauce> it's not time-efficient, but when you're in high school that doesn't really matter
23:09:31 <Gs30ng> afaik soysauce is an Asian food. it's really nice to meet an Asian stuff in Haskell channel
23:09:36 <soysauce> haha
23:09:53 <Korollary> there are quite a few asian #haskell'ers
23:10:00 * soysauce is not Asian
23:10:10 <soysauce> CAUCasian maybe
23:10:12 <Korollary> @userlocations
23:10:13 <lambdabot> Unknown command, try @listcommands.
23:10:20 <Korollary> ugh
23:10:26 <Korollary> too lazy to look it up
23:10:27 <soysauce> sorry to disappoint
23:10:30 <Korollary> @where userlocations
23:10:31 <lambdabot> I know nothing about userlocations.
23:10:40 <Korollary> @google haskell user locations
23:10:41 <lambdabot> http://www.cse.unsw.edu.au/db/publications/by_year/2004.html
23:10:45 <Gs30ng> it seems to be only 3 haskell programmers in Korea
23:10:49 <Korollary> mama...
23:11:05 <Gs30ng> including me
23:11:54 <soysauce> Korollary - I think anyone with enough time/patience and competance can teach themselves how to do things such as write OSes. True, it is good to avoid treading the same path that others have already taken, but it is most important to understand the system of things.
23:12:14 <soysauce> in order to be *capable* of novel research
23:12:29 <Gs30ng> Java and Flash rules, since here in Korea, embedded stuffs consists quite a big market rather than conventional application development
23:12:34 <soysauce> or even to be somewhat intelligent in conversation
23:12:59 <soysauce> Gs30ng - which half of Korea?
23:13:13 <Gs30ng> of course south
23:13:21 <soysauce> I was expecting that, but just curious
23:13:21 <Korollary> soysauce: well, I didn't mean to say that. I just meant that having a prof teaching you saves quite a bit of time and headache. I learned quite a bit by self-study as well. It's an economic issue.
23:13:43 <soysauce> Korollary - fair enough...I think generally I learn more efficiently on my own, though
23:14:37 <soysauce> Gs30ng - I eat a lot of rice and have a taste for Chinese cuisine, or at least what is sold under that label here in the U.S.
23:14:38 <Korollary> soysauce: through college I learned most things on my own because I was a lazy student. If I had been any wiser, I would have studied the chapter before the lecture and squeezed the profs brains in the class. Oh well :)
23:14:40 <soysauce> hence the name
23:14:57 <soysauce> Korollary - ;)
23:15:06 <Gs30ng> a developer told me that, a Korean company tried to launch an instant messenger service, and it took a year only to find proper development team/company to do that in Korea
23:15:21 <Korollary> Gs30ng: Whats the population of S Korea?
23:15:21 <soysauce> I did that my freshman year; I struck a deal with one guy and taught him how Windows NT worked, and in return he taught me how to write my own OS and let me sit in on his OS class
23:15:23 <soysauce> it was a lot of fun
23:15:42 <Gs30ng> about 50,000,000
23:16:27 <jethr0> $pretty fun x | x == 0 = 4 | x < 3 = if x == 1 then 2 else 1 | otherwise = 0
23:16:28 <jethr0_bot> fun x
23:16:28 <jethr0_bot>  | x == 0 = 4
23:16:28 <jethr0_bot>  | x < 3 = if x == 1 then 2 else 1
23:16:28 <jethr0_bot>  | otherwise = 0
23:16:31 <Korollary> Gs30ng: Yeah, that's a bit unusual.
23:16:35 <soysauce> http://www.cia.gov/cia/publications/factbook/geos/ks.html
23:16:39 <jethr0> *yeah*, senseless pretty printing...
23:18:01 <Gs30ng> Republic of Korea, aka South Korea has world's top cell-phone technology, but is kinda graveyard of PC software development
23:18:10 <soysauce> Korollary - you also learn a ton just by hanging out with bright/educated people...
23:19:58 <Gs30ng> so there are only few resources in Korean, like reference documents, etc.
23:19:58 <Korollary> soysauce: nah, they introduce you to things like haskell, which brings you down while reading c++ code at work.
23:20:00 <Cale> jethr0: nice :)
23:20:04 <soysauce> haha
23:20:17 <Gs30ng> that's why i'm trying to write a Haskell tutorial in Korean
23:20:29 <soysauce> well, perhaps if somebody introduced the C++ committee to Haskell, they would stop screwing up and get it right
23:20:39 <jethr0> thx, cale, feel free to try it out *g*
23:20:39 <Korollary> Gs30ng: are you going to have ghc target one of those cellphones?
23:20:49 <Gs30ng> http://gs30ng.exca.net/haskell/   -- i'm still working on it
23:20:59 <Gs30ng> haskell guide in Korean
23:21:33 <Cale> $pretty liftState t = do v <- get
23:21:34 <Cale> ; let (x, v') = t v
23:21:34 <Cale> ; put v'
23:21:34 <Cale> ; return x
23:21:34 <jethr0_bot> "Parse error" at column 26
23:21:38 <Cale> oops
23:21:49 <Cale> hehe, stupid invisible newlines :)
23:21:49 <jethr0> nah, on one line!
23:21:50 <Gs30ng> Korollary, sounds great...
23:21:58 <Cale> (problem with my client)
23:22:11 * jethr0 laugs at cale's "invisible" newlines
23:22:44 <Cale> $pretty liftState t = do v <- get; let (x, v') = t v; put v'; return x
23:22:44 <jethr0_bot> "Parse error" at column 53
23:22:53 <Cale> hmm
23:23:04 <Cale> $pretty liftState t = do { v <- get; let (x, v') = t v; put v'; return x }
23:23:04 <jethr0_bot> "Parse error" at column 55
23:23:10 <Cale> erm
23:23:22 <jethr0> wait a sec, i'll have a look what the problem is...
23:23:45 <Korollary> @type do v <- get; let (x, v') = t v; put v'; return x
23:23:46 <lambdabot> parse error on input `;'
23:23:55 <Korollary> @type do { v <- get; let (x, v') = t v; put v'; return x }
23:23:56 <lambdabot> parse error on input `;'
23:24:00 <Korollary> ok
23:24:25 <Cale> $pretty liftState t = get >>= \v -> let (x, v') = t v in put v' >> return x
23:24:26 <jethr0_bot> liftState t
23:24:26 <jethr0_bot>  = get >>= \ v -> let (x, v') = t v in put v' >> return x
23:24:27 <jethr0> weird
23:24:52 <Korollary> I think beauty is very much in the eye of the beholder here...
23:25:15 <jethr0> $pretty fun 0 = 1; fun 1 = 1; fun n = fun (n-1) + fun (n-2)
23:25:16 <jethr0_bot> fun 0 = 1
23:25:16 <jethr0_bot> fun 1 = 1
23:25:16 <jethr0_bot> fun n = fun (n - 1) + fun (n - 2)
23:25:39 <lispy> arg!
23:25:58 <lispy> why does fun look soo familiar
23:26:00 <lispy> hm....
23:26:02 <jethr0> korollary, i'm just using language.haskell.pretty... which isn't very configurable... it's mainly intended (from my side) for "cases" and multiples "lets"
23:26:09 <soysauce> lispy - ML?
23:26:35 <Korollary> jethr0: I see.
23:26:36 <lispy> soysauce: i was thinking it looked like fib
23:26:38 <soysauce> fun starts a lambda in ML, IIRC...
23:26:50 <soysauce> well, that function obviously *is* the fibonacci sequence
23:26:53 * jethr0 thinks so too
23:27:10 * Korollary wonders #haskell without fibonacci
23:27:23 <lispy> the function itself can't be the fibonacci sequence, since the fibonacci sequence is a sequence of numbers
23:27:26 <soysauce> it would be like imperative programs without "Hello, World"
23:27:42 <soysauce> lispy - a generator for that sequence, if you want to be pedantic
23:28:07 * lispy has been having fun with alcohol and feels like being pedantic :)
23:28:27 <lispy> i was just reading about D
23:28:34 <lispy> it seems like they worked really hard on cleaning up C
23:28:36 <jethr0> > let fibs = (1:1: zipWith (+) fibs (tail fibs)) in take 20 fibs
23:28:37 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
23:28:50 <lispy> well, C and C++, but i wonder if anyone is actualy using it
23:28:58 <soysauce> D is weird...it's much nicer than C++, I think, though I haven't used it
23:29:09 <Korollary> lispy: There's a commercial D compiler afaik. I don't think there are a lot of users, tho.
23:29:36 <soysauce> D has a lot of strange features, but it has some cool things like built-in string support
23:29:39 <lispy> > let fibs = (1:1: zipWith (+) fibs (tail fibs)) in take 10 (drop 100 fibs)
23:29:40 <lambdabot> [573147844013817084101,927372692193078999176,1500520536206896083277,
23:29:40 <lambdabot> 2427893228399975082453,3928413764606871165730,6356306993006846248183,
23:29:40 <lambdabot> 10284720757613717413913,16641027750620563662096,26925748508234281076009,
23:29:40 <lambdabot> 43566776258854844738105]
23:29:46 <soysauce> and it's a mostly-sensible approach to "cleaning up C"
23:29:54 <soysauce> far superior to C++ from what I have *read*
23:30:03 <jethr0> lispy, and now try to find "twin" fibonaccis *bfg*
23:30:35 <lispy> what is a twin in terms of fib?
23:30:46 <lispy> i know what it is in terms of primes
23:31:32 <lispy> D supports anonymous function, dynamic closures and nested functions.  so does that mean you have higher order functions?
23:31:32 <jethr0> lispy, i was just kidding...
23:31:58 <soysauce> http://www.rafb.net/paste/results/s2XQuz66.html <-- I need some help. I can't figure out why GHC is complaining or how to fix this.
23:32:27 <soysauce> lispy - higher-order functions would be a bit expensive...
23:32:43 <jethr0> does that mean its funcions are first-class citizens???
23:32:49 <Korollary> I have no idea what a dynamic closure is...
23:32:56 <soysauce> jethr0 - C's functions are first-class citizens.
23:33:13 <jethr0> hmm
23:33:32 <soysauce> Korollary - probably the ability to pass a closure of a nested function and the current environment to another function
23:33:34 <lispy> Korollary: they probably mean dynamically scoped variables within closures.  Basically, it's not a closure.
23:34:12 <soysauce> jethr0 - C has types for functions, you just can't curry/uncurry or do anything higher-order with them
23:34:15 <jethr0> soysauce, you are right, but using pointers is not what i had in mind :)
23:34:19 <soysauce> but you can return them and pass them around
23:34:21 <soysauce> I know
23:34:28 <Cale> soysauce: can functions construct new, distinct functions and return them?
23:34:44 <lispy> it supports programming by contract
23:34:45 <jethr0> what C misses is function creation at runtime... 
23:34:51 <lispy> http://www.digitalmars.com/d/dbc.html
23:34:52 <soysauce> Cale - you can't create them at runtime, I guess
23:34:59 <soysauce> but you can return them
23:35:17 <Cale> really, you can only return pointers to them, but I suppose that's close
23:35:33 <jethr0> cale, that is not necessary for first-class citizenship! FCC only need argument, return and value in structs/lists/...
23:35:35 <soysauce> well, there isn't really any difference between "by-value" and "by-reference"
23:35:49 <jethr0> C has no by-reference
23:36:00 <soysauce> indeed
23:36:01 <jethr0> well, yes, but not like C++ references :)
23:36:17 <soysauce> but functions can never be dereferenced, so they are always effectively passed by reference
23:36:50 <soysauce> my point was that the distinction between passing a reference to data or passing the data by-value itself is a totally unnecessary distinction in this context
23:37:06 <Cale> yeah, it's not really the main problem
23:37:22 <Korollary> the main problem is that C is old and irrelevant heh
23:37:30 <soysauce> as you probably already know, boost has lambdas
23:37:46 <Cale> when I saw them, they were fairly primitive
23:37:56 <soysauce> so apparently with templates it is possible to get some of the same behavior
23:38:28 <soysauce> it wouldn't surprise me. The boost approach of trying to extent the language with an extensive RTL is admirable, but it leaves a bad taste in my mouth.
23:39:08 <lispy> @type map
23:39:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:39:22 <Korollary> Hmm, you can read War & Peace via Project Gutenberg...
23:39:22 <soysauce> anyway, http://www.rafb.net/paste/results/s2XQuz66.html <-- can anyone explain to me what I'm doing wrong?
23:39:42 <soysauce> it complains about the topmost line in the paste
23:40:26 <Cale> There were some pretty severe limitations. You can't use lambdas with your own types, for example
23:40:48 <Cale> and I think the number of parameters were limited
23:41:47 <jethr0> soysauce, you sure your foldl has right type?
23:42:00 <soysauce> yeah
23:42:05 <soysauce> @type foldl
23:42:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:42:23 <soysauce> a is ST s ()
23:42:30 <soysauce> b is [Word32]
23:43:10 <soysauce> I suppose that I should have explicitly labelled the type of fwfold, but I kept moving it around and had some other problems.
23:43:14 <jethr0> is xs a list of lists?
23:43:17 <soysauce> yes
23:43:33 <soysauce> fw :: UArray (Word32, Word32) Int64 -> [[Word32]] -> UArray (Word32, Word32) Int64
23:43:44 <jethr0> *yuch*
23:43:54 <soysauce> GHC says this: fwfold :: ST s (STUArray s (Word32, Word32) Int64) -> ST s a -> [Word32] -> ST s ()
23:43:58 <soysauce> hm?
23:44:18 <jethr0> i'd start by explicitely typing all expressions.. that often helps in finding the problem
23:44:42 <soysauce> yeah. I think that was the only one that wasn't typed, besides fw.
23:45:03 <soysauce> it doesn't help in this case, though
23:45:28 <jethr0> @type Control.Monad.thaw
23:45:29 <lambdabot> Not in scope: `Control.Monad.thaw'
23:45:40 <soysauce> @type Data.Array.MArray.thaw
23:45:41 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
23:45:41 <lambdabot> (Data.Array.Base.MArray b e m,
23:45:41 <lambdabot> Data.Array.Base.IArray a e,
23:45:41 <lambdabot> GHC.Arr.Ix i) =>
23:45:41 <lambdabot> a i e -> m (b i e)
23:45:59 <soysauce> ugly, but it just transforms an immutable array into a mutable array inside a monad
23:46:16 <soysauce> in my case m = ST s, b = STUArray s (Word32, Word32) Int64
23:46:18 <jethr0> are the return type of "thaw" and the first param of fwfold compatible?
23:46:25 <soysauce> yes
23:47:20 <jethr0> these types are too complex for me, sry. it's too late for this kind of type muddling.
23:47:25 <soysauce> fw2 a = fwfold (thaw a) (return ()) []
23:47:31 <soysauce> GHC doesn't complain about fw2
23:48:59 <soysauce> it's runSTUArray that causes the problem
23:49:17 <soysauce> @type Data.Array.ST.runSTUArray
23:49:18 <lambdabot> forall e i.
23:49:18 <lambdabot> (GHC.Arr.Ix i) =>
23:49:18 <lambdabot> (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e))
23:49:18 <lambdabot> -> Data.Array.Base.UArray i e
23:49:55 <soysauce> @type Data.Array.MArray.freeze
23:49:56 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
23:49:56 <lambdabot> (Data.Array.Base.IArray b e,
23:49:56 <lambdabot> Data.Array.Base.MArray a e m,
23:49:56 <lambdabot> GHC.Arr.Ix i) =>
23:49:56 <lambdabot> a i e -> m (b i e)
23:50:14 <soysauce> huh...
23:50:19 <soysauce> @type Data.Array.MArray.thaw
23:50:20 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
23:50:20 <lambdabot> (Data.Array.Base.MArray b e m,
23:50:20 <lambdabot> Data.Array.Base.IArray a e,
23:50:20 <lambdabot> GHC.Arr.Ix i) =>
23:50:20 <lambdabot> a i e -> m (b i e)
23:50:34 <soysauce> oh, I see
23:51:08 <jethr0>  ah, ok
23:51:42 <xerox> thaw?!
23:51:51 <soysauce> 'lo
23:54:38 <soysauce> @hoogle a -> b -> b
23:54:39 <lambdabot> Control.Parallel.par :: a -> b -> b
23:54:39 <lambdabot> Control.Parallel.seq :: a -> b -> b
23:54:39 <lambdabot> GHC.Conc.par :: a -> b -> b
23:56:20 <soysauce> oh well, I'm tired, g'night
23:57:56 <jethr0> nite
23:58:06 <jethr0> hey xerox
23:58:36 * araujo reading about net of processes
23:58:43 <xerox> Howdy, jethr0.
23:58:58 <araujo> Haskell makes it looks so easy :-]
23:59:08 <jethr0> $pretty fun x | x == 0 = 4 | x < 3 = if x == 1 then 2 else 1 | otherwise = 0
23:59:08 <jethr0_bot> fun x
23:59:08 <jethr0_bot>  | x == 0 = 4
23:59:08 <jethr0_bot>  | x < 3 = if x == 1 then 2 else 1
23:59:08 <jethr0_bot>  | otherwise = 0
23:59:22 <xerox> URGH.
23:59:31 <jethr0> hehe
23:59:38 <xerox> f x | <..> = <..> -- please :-)
