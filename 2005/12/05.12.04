00:00:15 <jethr0> but anticipatory lookahead will still win over such a computer algo hands down!
00:00:25 <Cale> It's a perfect blend of intuition and logic
00:00:46 <yozora> i've played shougi, how does go compare to that?
00:00:47 <Cale> You have to reason about emotion.
00:00:48 <jethr0> cale: too little logic for me. too few corners to cut on your way to glory!
00:01:11 <Cale> go is an altogether different kind of game from shougi
00:01:12 <jethr0> buggaboo, so what is your approach?
00:01:34 <Cale> but I'm not sure how much strategy transfer you'd get, it may be significant
00:01:58 <Cale> I haven't actually played a game of shougi, though I was told the rules at one point.
00:02:10 <yozora> i'm just curious as to whether in your view how interesting shougi is in terms of the above
00:02:16 <Buggaboo> mmm, I read something about simulated annealment, now trying to figure out how to use it.
00:02:38 <yozora> i stopped playing chess after someone compared it to finding the square root of 2
00:02:42 <Cale> shougi seems like an interesting game, but go seems bigger in some sense. The placement rule in shougi is interesting though.
00:02:44 <jethr0> but doesn't that solve a totally different problem?
00:02:48 <Buggaboo> I heard about someone using a 3x3 with it proof-of-conceptish project.
00:03:16 <Cale> yozora: playing go has changed the way that I think, definitely.
00:03:25 <yozora> really? how so?
00:03:47 <jethr0> lose small to win big ;-)
00:03:52 <Cale> go teaches you a lot of hard to otherwise convey things
00:04:03 <Buggaboo> Cale: do you surround your enemies and cut off their supplies :P
00:04:05 <jethr0> cut your losses early!
00:04:10 <Cale> Buggaboo: hehe
00:04:44 <Cale> jethr0: I'd put that as "apologise when you were wrong" :)
00:04:52 <yozora> what's a good windows implementation to practise on?
00:05:01 <yozora> or more like learn on
00:05:06 <Cale> a computer opponent?
00:05:09 <yozora> apart from watching Hikaru no Go
00:05:11 <Cale> hehe
00:05:25 <Cale> Well, if you want, we can have some 9x9 games on KGS
00:05:28 <jethr0> from what i heard the computer algo only get up to 12 kyu or so
00:05:41 <yozora> what's KGS?
00:05:42 <Cale> gnugo is terrible :)
00:05:48 <Cale> Kiseido Go Server
00:05:54 <jethr0> yozora: playing against a computer spoils you terribly
00:05:59 <Cale> http://kgs.kiseido.com/
00:06:06 <jethr0> i tried it and it really spoilt my game style to no end
00:06:07 <Buggaboo> I heard gnugo is pretty strong?
00:06:30 <jethr0> the computer algos are all too weak to show the intelligence even bad players will have
00:06:34 <Cale> Buggaboo: in even games, I either force it to resign, or win by about 80 points, and I'm an intermediate level amateur.
00:06:52 <yozora> argh i have to install java :P
00:07:12 <Buggaboo> o.  I should try it then, before believing anything I hear.
00:07:14 <jethr0> cale: how about with an advance of 9?
00:07:35 <jethr0> against gnugo
00:07:57 <Cale> that might be hard, considering that 9 stones are worth ~180 points.
00:08:10 <Cale> however, I should try it :)
00:08:28 <jethr0> well, i would think you'd beat it, if you are a 1 kyu.
00:08:38 <Cale> I'm not sure what rank I am
00:08:46 <Cale> I haven't played rated games in ages
00:09:01 <jethr0> well, it's not something to lose easily.
00:09:14 <Cale> but I was in the single digit kyus last time I was playing rated games
00:16:21 <Cale> do you have an account on kgs?
00:20:05 <jethr0> igs or kgs, i don't remember
00:20:28 <jethr0> i was too stupid to figure out how to get an account on kgs
00:20:40 <jethr0> and i didn't want to install java for the d*mn client
00:21:02 <Cale> oh, you just log in as a guest, and then click User -> Register
00:21:12 <jethr0> _with_ the java client
00:21:16 <Cale> ah
00:21:30 <Cale> um, is there another?
00:21:41 <Cale> there's the applet, but that's also java
00:21:46 <jethr0> i might install it. but don't get your hopes up. 'coz you're way ahead of me in this game
00:21:50 <Cale> hehe
00:22:03 <Cale> I'd be happy to teach
00:22:03 <jethr0> i don't think so...
00:22:23 <Cale> the webstart client is nice
00:22:35 <Cale> you don't have to worry about updating it
00:22:58 <jethr0> hmm, i don't have a working firefox-java-thingey
00:23:14 <Cale> which distribution?
00:23:18 <jethr0> you know what. maybe another time. i'm not the most awake person right now
00:23:23 <Cale> sure
00:23:27 <jethr0> debian pure64
00:23:42 <jethr0> x86-64
00:24:22 <Cale> There are lines which you can add to your apt sources.list to have java installed nicely
00:25:13 <Cale> lines which apparently I don't have in my apt sources.list :)
00:25:30 <Cale> heh, I must have installed java by hand at some point
00:25:41 <jethr0> hmm, but the 64-bit-only distribition makes that a bit of a pain. i 've been wanting to switch, but never can't be bothered to throw away a nicely running system
00:25:50 <jethr0> as have i
00:27:26 <yozora> gotta go, cyas
00:27:39 <jethr0> cyall
00:27:42 <jethr0> ;-)
00:35:34 <Cale> heh, I like it when games solve NP-complete problems to make your playing experience a little bit nicer.
00:35:57 <Cale> This implementation of minesweeper has an "ensure solubility" option
00:36:44 <Korollary> Let's double the map size and see if it can still ensure ;)
00:38:26 <jethr0> isn't finding one solution already a solubility proof.
00:38:40 <jethr0> and with a good heuristic and backtracking finding one solution should be doable
00:39:02 <Cale> well, it does 60x60 with 3500 mines reasonably quickly
00:39:45 <jethr0> > 3500 / (fromIntregral $ 60 * 60)
00:39:46 <lambdabot>  Not in scope: `fromIntregral'
00:39:53 <jethr0> > 3500 / (fromIntegral $ 60 * 60)
00:39:54 <lambdabot> 0.9722222222222222
00:40:08 * jethr0 is definitely stupid
00:40:35 <jethr0> but the computer knows which fields are occupied and only has to try the empty ones
00:40:46 <jethr0> so it might go faster with 3500 bombs than with 1 ;-)
00:40:53 <jethr0> not really, but you see my point.
00:41:06 <Cale> yeah, that might be a little high :)
00:41:28 <Cale> 2000 mines is harder
00:41:56 <jethr0> actually "solubility" for minesweepers is a dumb idea...
00:42:04 <Cale> why?
00:42:28 <Cale> when you click the first spot, it generates the puzzle
00:43:01 <jethr0> and the question is whether it can be deterministically solved.
00:43:33 <jethr0> sry, hadn't though of situations where you have to guess. still have to use backtracking
00:43:37 <Cale> well, possibly with backtracking
00:43:40 <Cale> yeah
00:43:49 <jethr0> but 97% will not be the slowest.
00:43:53 <Cale> right
00:43:55 <Cale> it's not :)
00:43:57 <jethr0> my guess would be at 85 or so
00:44:14 <skew> is it possibly a question of percolation theory?
00:44:19 <Cale> 2000 mines is a good lot slower, but reasonable
00:44:51 <jethr0> hmm, sounds reasonable
00:44:56 <jethr0> @google percolation theory
00:44:57 <lambdabot> http://mathworld.wolfram.com/PercolationTheory.html
00:45:17 <Cale> though the algorithm is a bit funny, and seems to tend to give you a really large starting area
00:46:35 <Cale> you'd ideally want to control the distance between mines too
00:47:01 <jethr0> yes, definitely
00:47:14 <jethr0> either too far apart or too clustered sucks
00:47:42 <jethr0> a mean distance of 2 or something with some variance should be good
00:48:30 <jethr0> coming to think of it, high variance is more important than mean; you really want to have loose clusters.
00:50:34 <Cale> heh, yeah, this is a little cheezy, this algorithm is too greedy
00:51:27 <Cale> let's just say it didn't take long to solve on those settings :)
00:51:58 <Cale> anyway, I like 'bridges' and 'pattern' better :)
00:52:13 <jethr0> bridges and pattern?
00:52:30 <Cale> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/
00:53:01 <Cale> loopy is also quite good
00:53:16 <Cale> and of course, solo, the sudoku implementation
00:53:28 <Cale> and map is rather fun
00:53:33 <Cale> (map colouring)
00:54:54 <Cale> Untangle would be good, but I'm too good at it, and the implementation isn't fast enough to deal with the sizes I'd like to play at
00:55:44 <Cale> actually, I think I may know what it's doing...
01:05:29 <skew> Cale: how big are you trying to run it? 100 seems to do fine here
01:05:46 <Cale> dragging the points is slow when there's ~50 or so
01:06:07 <skew> What operating system are you using?
01:06:10 <Cale> linux
01:06:12 <Cale> debian
01:06:26 <skew> hmm, no problems here with release 6474
01:06:49 <rep> anyone with windows, by any chance?
01:07:58 <Cale> skew: ah, I have slightly older, I'll try the new release
01:11:57 <Cale> okay, well *that* was simply ridiculous
01:12:27 <Cale> hmm
01:13:17 <Cale> well, dragging points definitely uses 100% cpu
01:13:47 <Cale> I can't get the system to crash again, not sure what that was... perhaps overheating.
01:14:49 <Cale> but I doubt it was overheating somehow, since it was only about a second that I'd dragged the point, and usually I only have problems with heat when computations take several minutes
01:15:34 <Cale> skew: does moving points eat 100% cpu?
01:17:03 <Korollary> I've been running with no swap. Amazing...
01:17:37 <Cale> Korollary: I did that for quite a while.
01:18:18 <Korollary> Cale: I did it intentionally on winxp for a while. But this is on linux. I moved harddrives around and lost the swap partition with the drive I discarded.
01:18:48 <Cale> Now I tend to keep a bit of swap in the hopes that if a process has run away, I'll have some time to kill it.
01:19:25 <Cale> this kernel seems to do really poorly when the system runs out of memory
01:20:15 <Cale> I have 1GB of ram though, so I rarely need swap.
01:22:01 <skew> no, more like 7
01:22:34 <Cale> skew: okay, probably something strange about the way that it's compiling then.
01:50:15 <skew> I wrote a program that will work to solve that pattern game
01:50:34 <cakoose> Has GHC or Hugs ever supported a method-call-like syntax?  I'm looking some sample Haskell code that does s.last to get the last letter of the string in variable "s".  http://pleac.sourceforge.net/pleac_haskell/strings.html
01:51:01 <cakoose> I can't figure out how to get either Hugs or GHC to accept that.
01:51:16 <skew> import Prelude hiding (.), and then redefine .
01:52:15 <skew> I think they redefine it as x . f = f x
01:55:17 <Cale> cakoose: pleac_haskell is extremely unconventional Haskell code
01:55:28 <cakoose> Wonder why they do that.  It does look nice.
01:55:33 <xinming> putStrLn, Waht does Ln mean here?
01:55:36 <xinming> Line-new?
01:55:38 <Cale> line
01:55:48 <xinming> Ok,thanks
02:01:10 <fworp> unconventional is one thing, but overloading standard functions and not stating it is kindof dubious
02:01:42 <dsacode> Hello! I defined function with type F :: A -> A -> A -> A, where A is (Integer, Integer, Integer); then i defined it as F (u1, u2, u3) (v1, v2, 0) (t1, t2, t3) = (u1, u2, u3), but Hugs give me error "F multiply defined", where's my mistake?  
02:02:26 <int-e> dsacode: function names must start with a lower case letter
02:02:34 <ulfdoz> dsacode: Identifiers have to start with lower-case letters.
02:02:52 <int-e> dsacode: you gave a signature for a data constructor; I'm not sure what ghc would do with that later (after the code is parsed)
02:03:00 <dsacode> This function called "extGCD_eval", i just used F..
02:03:51 <dsacode> int-e: hmm, can't understand, what's signature?
02:05:05 <lightstep> dsacode, a type signature is a statement "value :: Type"
02:05:45 <int-e> dsacode: did you give the type signature twice, perhaps?
02:06:33 <dsacode> int-e: no, i'm not.. i'll put my script on-line, wait a sec
02:09:08 <dsacode> argh, it seems that i found error
02:16:51 <shapr> SamB: Any idea when scannedinavian went down?
02:17:34 <xerox> The moon was rising and the stars were in the right position...
02:18:16 * shapr grumbles
02:18:21 <shapr> I wonder what happened this time.
02:24:38 <dsacode> int-e: http://revenge.botik.ru/~karma/euclidean.lhs <-- i don't know why 'extGCD_eval' multiply defined :(
02:26:16 <int-e> dsacode: you have to move the subVect helper function
02:27:07 <dsacode> int-e: great!
02:27:17 <dsacode> int-e: but why it works now?
02:27:32 <dsacode> int-e: what was bad about subVect position?
02:29:51 <shapr> Foo, I think my ISP lost part of their network.
02:29:54 * shapr grumbles.
02:30:04 <shapr> cakoose: Hiya, long time no see.
02:30:25 <shapr> hola joelr1 
02:30:38 <joelr1> hi shapr 
02:30:42 <shapr> How's code?
02:30:47 <joelr1> do you know how to troubleshoot laziness?
02:31:16 <dons> in what way is laziness hurting?
02:31:31 <joelr1> let me post an example, give me a minute please
02:31:36 <dons> if its unevaluated cthunks, you use heap profiling.
02:31:45 <lightstep> dsacode, there are rules that limit the mixing of definitions and type declarations of functions (i'm not sure what exactly)
02:31:49 <joelr1> dons: no, it's something else, i think
02:32:01 <lightstep> dsacode, the usual practice is to have each definition right after the signature
02:32:10 <dons> it it's needlessly lazy, then check the strictness of functions in the core, and strictify where needed
02:32:50 <dons> generally I do:   fix $ \hack -> code >> profile >> hack     ;)
02:33:33 <xinming> will `do{ var <- monadGen; monadFun var }` be translated into `(>>=) monadGen (\x -> monadFun x)` ?
02:33:37 <dons> trying the different heap profilings is useful -hc and then retainer profiling, als profiling by type or module can be useful.
02:33:41 <xinming> internally
02:33:57 <dons> yes.
02:34:01 <xinming> so
02:34:05 <dons> it's just syntactic sugar for that form.
02:34:29 <dons> or, as it's usually written: monadGen >>= \x -> monadFun x
02:34:33 * xinming wonders if var hold the lambda (\var -> monadFun var)
02:34:40 <lisppaste2> joelr1 pasted "laziness at work?" at http://paste.lisp.org/display/14281
02:35:29 <joelr1> i found another bug in haskell, btw, related to heap profiling. i cannot profile with -hcvoid because some invalid closure is generated
02:35:54 <joelr1> but take a look at my paste please, for some reason it takes 3 minutes to jump 1 line
02:36:13 <xinming> or, the do is just a hint for haskell interpreter to translate the `do something`.
02:36:33 <lisppaste2> joelr1 annotated #14281 with "missing bits" at http://paste.lisp.org/display/14281#1
02:36:36 <dons> hmm, if that 3 minutes is in haskell, not sitting on the network, it should show up in the .prof, right joel?/
02:36:50 <joelr1> dons: how so?
02:37:14 <dons> what do you suspect it's doing for the 3  minutes?
02:37:14 <Heffalump> what if gc takes 3 mins?
02:37:25 <dons> hmm. then the GC stats will be bad
02:37:25 <xinming> dons: That's why I was confused about, If Monad is a container, why can't we return the value out of the container. :-/
02:37:31 <joelr1> dons: why would it show up in prof? the difficulty i have, btw, is that prof is only generated when the program quites (at least in my case) 
02:37:50 <joelr1> since my program does not quit (bots play in a loop) i can only get gcstats
02:37:55 <dons> yes, that's annoying joel! also, Posix.exitImmediately kills profiling too :/
02:38:05 <xerox> xinming: because a container is just a datatype, thus, via pattern-matching.
02:38:13 <Cale> xinming: it's only a container insofar as those operations mentioned are there.
02:38:23 <xerox> xinming: the fact that is a monad means that return and bind will work on it.
02:38:24 <joelr1> dons: so what do you think? anything obvious?
02:38:56 <xerox> xinming: that is, you instantiate the type in the Monad type-class, you see?  so no black magic is actually happening.
02:39:07 <Cale> It may not have every operation which you ever wanted from a container :)
02:39:53 <dons> joelr1, I don't see anything obviously wrong.
02:40:13 <dons> you'll need to add a hook (perhaps a signal handler?) to get it to exit cleanly, so you can get a profile
02:40:19 <dons> or maybe it's a network timeout?
02:40:23 <joelr1> dons: so suppose i were to generate profiling
02:41:09 <joelr1> dons: there should be no network timeouts in this case since it's within the function. notice that one prints connected and goes to stop the timer (which does not get stopped i think) and the next printout is right after
02:41:16 <joelr1> dons: how would this show up in prof?
02:43:29 <dons> well, what could possibly be the cause of a 3 minute stoppage?: threads blocking, networks, GC, some heavy computation. you'd get a clue at least about whether there was any GC or computation going on.
02:44:34 <dons> if reasoning about the code can't spot the bug, then profiling is a good way to get hints, I reckon.
02:45:03 <joelr1> dons: what i do not understand is the options to get profiling to show this
02:45:10 <joelr1> dons: what options would you use?
02:45:31 <joelr1> and also where would i look to see the cause of this? threads blocking? where does that show in profiling?
02:45:43 <dons> oh, I'd jsu tstart with -p, just to rule out something eating up a lot of time computing something, and then check for GC behaviour
02:46:40 <joelr1> dons: -p? you mean the -p option to cabal?
02:46:44 <joelr1> err, to configure 
02:46:50 <joelr1> i already did that
02:46:52 <dons> +RTS -p at runtime
02:46:56 <joelr1> ah
02:47:19 <dons> and then if that isn't helpful, try a producer profile: +RTS -p -hc
02:47:37 <joelr1> dons: i don't see that option in http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
02:47:58 <dons> which option?
02:48:06 <joelr1> -p
02:48:33 <dons> oh, -p is just the most general profiling flag to give you a .prof file
02:48:42 <dons> for time and allocation profiling
02:48:45 <dons> not heap profiling
02:49:10 <joelr1> ok
02:49:51 <joelr1> dons: so how would thread blocking manifest itself?
02:51:19 <dons> it wouldn't be obvious in a profile, but you'd be able to rule out, e.g. lazinness
02:51:33 <dons> however, you'd at least know what was on top of the call stack
02:51:42 <joelr1> right
02:51:56 <joelr1> dons: so exitImmediately kills profiling
02:52:03 <dons> sure does.
02:52:05 <joelr1> dons: what about any other time of exit?
02:52:18 <joelr1> i'm looking for the system call to use in the -HUP signal handler
02:52:18 <dons> exitWith Foo is ok. so is return ()
02:52:33 <joelr1> actually
02:52:37 <xerox> @index signal
02:52:37 <lambdabot> bzzt
02:52:38 <joelr1> what's the signal for ^C
02:52:46 <joelr1> gotta catch that one i think
02:52:53 <dons> sigINT
02:53:02 <dons>     flip mapM_ [sigINT, sigHUP, sigABRT, sigTERM] $ \sig -> do
02:53:02 <dons>             installHandler sig (Catch (do
02:53:02 <dons>                 Control.Exception.catch (shutdown Nothing) (\f -> hPutStrLn stderr (show f))
02:53:05 <dons>                 exitWith (ExitFailure 1) )) Nothing
02:53:09 <xerox> dons: why are you writing a bunch of "^?" before each phrase? :-)
02:53:24 <dons> doh, is that happening again?
02:53:26 <int-e> xerox: they're ASCII delete (0x7f) characters.
02:53:30 <joelr1> dons: cool, thanks /xerox i don't see that/
02:56:08 <dons> oh, I see it happened twice. it's when I try to edit something remotely (my irssi instance runs remotely) but the network goes flakey half way through, and the deletes get printed, instead of editing the minibuffer. sorry.
02:59:38 * joelr1 grumbles
02:59:48 <joelr1> i should have written the damn thing in ruby or something
02:59:50 <xerox> (no problems, just asking)
03:00:09 <joelr1> but then i wouldn't have spent two glorious months learning haskell... damn
03:00:38 <twb> Are there stack and dictionary/assoc-list datatypes?
03:00:50 <xerox> @type List.lookup
03:00:51 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
03:00:53 <dons> @docs Data.Map
03:00:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
03:01:00 <xerox> :-)
03:01:25 <dons> @type Data.Map.lookup
03:01:26 <lambdabot> forall a (m :: * -> *) k.
03:01:26 <lambdabot> (Ord k, Monad m) =>
03:01:26 <lambdabot> k -> Data.Map.Map k a -> m a
03:01:46 <dons> not just a Maybe ;)
03:01:53 <xerox> I mean, [(a,b)] works as a stack... :-)
03:02:06 <twb> Yeah.
03:02:23 <dons> yeah, a [a] is a good stack
03:02:49 <twb> I was thinking of "type Stack e = [e]" for clarity.
03:03:21 <neologism> I jsut saw a video about MS singularity OS
03:03:23 <xerox> I just pointed out that Lit.lookup is in the hierarchical lib.
03:03:36 <xerox> neologism: any url, maybe not in czech? ;-)
03:03:37 <neologism> its interesting that they solve memory problems by using imperative languages
03:03:41 <neologism> xerox: in english
03:04:16 <neologism> the same story all over again - we corrupt memory cause imperative languages are bad with this so we put there some more abstraction which tries to protect the memory
03:04:21 <neologism> and fails so we put even more abstraction
03:04:33 <neologism> http://channel9.msdn.com/Showpost.aspx?postid=141858    
03:04:36 <neologism> its 1 hour video
03:05:33 <xerox> Woot, I'm dowloading at 300kb.
03:05:39 <xerox> (per second)
03:05:44 <triplah> :(
03:05:53 <neologism> using referential transparency would be much better I think
03:06:02 <neologism> I dont understand why they keep using such languages 
03:06:18 <twb> neologism: because that's what The Kids are taught.
03:06:39 <neologism> might be
03:07:03 <twb> The world would be a better place if SICP was the first-year CS textbook.
03:07:08 <neologism> but the people who do this research project should be educated quite well
03:07:14 <neologism> what is SICP?
03:07:14 <triplah> twb: damn straight
03:07:18 <twb> ...instead of K&R, I mean.
03:07:23 <triplah> wish i had been taught it :(
03:07:25 <neologism> what is SICP?
03:07:26 <xerox> twb: it is, somewhere!
03:07:32 <triplah> probably MIT
03:07:33 <triplah> :P
03:07:35 <twb> neologism: http://mitpress.mit.edu/sicp
03:07:58 <neologism> what is it about?
03:07:59 <xerox> Yeah.
03:08:08 <neologism> the title doesnt say much
03:08:11 <xerox> neologism: Haskell basics ;-)
03:08:11 <triplah> an excellent computer science text used in introductory courses at MIT.
03:08:14 <triplah> :P
03:08:19 <twb> Is there a way to define a type that is the same as String, but not allowing whitespace characters?
03:08:45 <neologism> triplah: I mean.. what does it say ;)
03:08:47 <triplah> String is a list of chars
03:08:48 <xerox> No invariants in Haskell, I swear.
03:09:00 <triplah> so you could make an enumeration type of all the cars you want allowed in ur type
03:09:03 <triplah> i guess :\
03:09:05 <triplah> thats nsaty tho
03:09:07 <triplah> nasty*
03:09:33 <twb> Boo for non-hierarchical type systems :-(
03:09:38 <xerox> Maybe some Oleg's work does that, but I doubt you want to do it _that_ ways
03:09:51 <triplah> neologism: it teaches about functional programming, something people should be familiar with in earrly stages of CS education
03:10:01 <triplah> but unfortunatly most unis tech java to first years
03:10:02 <triplah> :\
03:10:05 <triplah> teach*
03:10:19 <neologism> in local university they also teach people functionl programming in the first year
03:10:29 <neologism> but everyone cheats on that course
03:10:30 <neologism> and hate it
03:10:36 <neologism> so its quite useless in the end ;(
03:10:40 <int-e> Hmm, how about newtype Mychar = Mychar Char; charFromMychar (Mychar c) = c; makeMychar c = if c == ' ' then error "No spaces allowed." else Mychar c ... and then export it from a module hiding the 'constructor'.
03:10:41 <neologism> people are just dumb
03:11:09 <triplah> ehe
03:11:13 <dsacode> Just question about coding style; For example, i have task to solve equation ax+b = 0; What's good style to write this?
03:11:22 <dsacode> eq1 :: Float -> Float -> Maybe Float
03:11:23 <dsacode> eq1 0 b = Nothing
03:11:23 <dsacode> eq1 a b = Just (-b / a)
03:11:23 <twb> int-e: that looks kinda difficult.
03:11:25 <dsacode> is it ok?
03:11:46 <triplah> twb: i think its pretty elegant actually :P
03:11:51 <triplah> to define a type so easily
03:12:02 <triplah> given nothing to inherit
03:12:10 <twb> triplah: unlike DEFCLASS? ;-)
03:12:18 <triplah> twb: true :(
03:12:26 <int-e> dsacode: btw, sorry - a function definition has to be all in one piece; there are no declarations allowed in the middle of one - to answer your question of half an hour ago.
03:12:45 <dsacode> int-e: ok, thanks
03:15:01 <jethr0> dsacode: that didn't make any sense to me.
03:15:04 <jethr0> what is your task?
03:15:13 <jethr0> BTW: is it homework?
03:15:28 <dsacode> jethr0: no, i just want to know how to write elegant code, and it's simple example
03:15:53 <twb> Are Nothing and Just like SML's NONE and SOME?
03:16:16 <dsacode> twb: Maybe a = Nothing | Just a
03:16:18 <dsacode> twb: think so
03:16:23 <twb> dsacode: yeah.
03:16:29 <jethr0> dsacode, i understand now. yes, that seems like a good solution!
03:16:49 <jethr0> if the math is right ;-)
03:16:53 <dsacode> hehe :)
03:17:08 <triplah> anyone know of a good monad tutorial?
03:17:33 <dsacode> triplah: there's good monad definition at wikipedia
03:17:51 <jethr0> triplah: to be honest, i learned more in here about monads than with all the tutorial out there
03:17:57 <dsacode> triplah: you just need to understand definition, and it will be ok
03:18:08 <triplah> hmm
03:18:10 <jethr0> for me, just reading it didn't help. seeing applications did a lot more
03:18:21 * fworp knows how they work, but cant make heads or tails of the definitions
03:18:43 <jethr0> and, questions are much better for learning than answers. i want to find out, why/how the list monad works, so i am gonna look it up sometime
03:18:43 <dsacode> fworp: so you don't know what is monad, probably :)
03:18:52 <jethr0> > "abc" >>= "def"
03:18:53 <lambdabot> Couldn't match `Char -> [b]' against `[Char]'
03:18:56 <xerox> uh.
03:18:57 <fworp> sure i do
03:19:01 <jethr0> how did this work?
03:19:12 <jethr0> again?*
03:19:41 <xerox> > "abc" >>= \x -> "def" >>= \y -> return [x,y]
03:19:43 <lambdabot> ["ad","ae","af","bd","be","bf","cd","ce","cf"]
03:19:50 <jethr0> yeah, right, just remembered it.
03:20:23 <joelr1> dons: in your signal handling example where does shutdown come from? (shutdown Nothing)
03:20:25 <jethr0> in fact, i am gonna look it up _right_ now. because it bothers me not to know how that works
03:20:48 <twb> Using quickcheck, I get "No instance for (Arbitrary Char)".
03:20:52 <dons> no no. shtudown is a function in my hmp3 player. you just can ignore that.
03:21:15 <jethr0> thx, xerox
03:21:20 <xerox> You're welcome!
03:21:32 <dons> it was just an example of how to stick an arbitraary function in a signal handler
03:21:40 <twb> I don't understand the Arbitrary instantiation stuff at http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html
03:21:42 <joelr1> dons: so Catch $ exitWith ... then?
03:22:05 <dons> maybe that will work for you, if you're not catching Exit exceptions somewhere explicitly
03:22:10 <dons> twb: for free:
03:22:11 <dons> instance Arbitrary Char where
03:22:12 <dons>   arbitrary = oneof $ map return
03:22:12 <dons>                 (['a'..'z']++['A'..'Z']++['1'..'9']++['\n','\t','0','~','.',',','-','/'])
03:22:15 <dons>   coarbitrary c = coarbitrary (ord c)
03:22:17 <dons> :)
03:22:21 <twb> dons: thanks.
03:22:28 <fworp> ive written several, but greek letters scare me.
03:22:59 <dons> now, back to my talk on what a type system is, for chemistry students..
03:23:05 <twb> dons: why is '0' separate from '1'..'9'?
03:23:26 <mysteriousentity> Hello. Is there a function in haskell that is equivalent to (\x min max -> if x < min then min else if x > max then max)?
03:23:32 <twb> Does Haskell only guarantee ordered contiguity for 1 through 9?
03:23:35 <dons> twb, not sure.
03:24:05 <dons> @pl \x min max -> if x < min then min else if x > max then max else x
03:24:05 <lambdabot> ap (flip . ((.) .) . join . (if' .) . (<)) (flip =<< join . (if' .) . (>))
03:24:06 <Cale> @pl (\x min max -> if x < min then min else if x > max then max)
03:24:06 <lambdabot> (line 1, column 60):
03:24:06 <lambdabot> unexpected ")"
03:24:06 <lambdabot> expecting letter or digit, variable, "(", operator or "else"
03:24:20 <dons> twb, I'm not sure why '0' is separate.
03:24:24 <dons> there's no reason for it to be.
03:24:33 <Cale> @pl (\x min max -> if x < min then min else if x > max then max else x)
03:24:33 <lambdabot> ap (flip . ((.) .) . join . (if' .) . (<)) (flip =<< join . (if' .) . (>))
03:24:44 <xerox> HM..
03:25:10 <twb> dons: is it portable to just write ['\0'..'~']?
03:25:35 <dons> > Char.ord '0' : Char.ord '1' : []
03:25:37 <lambdabot> [48,49]
03:25:44 <Cale> @pl \x a b -> min (max a x) b
03:25:45 <lambdabot> (min .) . max
03:25:48 <dons> twb, if you want to generate all that stuff, yes. [\0 .. \255] would be ok.
03:25:51 <xerox> That was simple.
03:25:59 <Cale> that's shorter, but still not so obvious :)
03:26:00 <twb> dons: cool!
03:26:09 <xerox> Cale: it's doable :-D
03:26:14 <Cale> yeah
03:26:26 <Cale> but I wouldn't write it into an actual program, I don't think
03:26:29 <dons> I had particular reasons to not generate all the ctrls chars, hence the special care
03:26:34 <dons> Cale, really?
03:26:34 <twb> But I expect it's not polite for other encodings (e.g. UTF-8).
03:26:54 <Cale> dons: I prefer the lambda term there
03:27:12 <dons> well, just have a CAF and be done with it :)
03:27:18 <xerox> \x a b -> min (max a x) b
03:27:18 <xerox> \x a -> min . (max a x)
03:27:18 <xerox> \ -> (min .) . max
03:27:59 <twb> I don't understand what coarbitrary does, though.
03:28:02 <jethr0> xerox: i don't really grok the last step
03:28:05 <mysteriousentity> thank you, that's very insightful
03:28:18 <jethr0> is there a step in between to clarify?
03:28:20 <int-e> @pl \a b x -> min a (max b x)
03:28:21 <lambdabot> (. max) . (.) . min
03:28:45 <jethr0> shouldn't that be simpler than the above?
03:29:05 <jethr0> @type (min .)
03:29:06 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> b -> b
03:29:09 <jethr0> @type min
03:29:10 <lambdabot> forall a. (Ord a) => a -> a -> a
03:29:28 <xerox> \x a b -> min (max a x) b
03:29:29 <xerox> \x a -> min . (max a x)
03:29:29 <xerox> \x a -> min . (max x a)
03:29:29 <xerox> (and given  \a b c d e -> f a b c d e  is  f)
03:29:32 <xerox> \ -> (min .) . max
03:29:33 <int-e> @pl \a b x -> min (max a x) b
03:29:33 <lambdabot> flip . (min .) . max
03:29:54 <xerox> @pl \b a x -> min (max a x) b
03:29:55 <lambdabot> flip (flip . (min .) . max)
03:29:57 <xerox> gh.
03:30:04 <jethr0> ok, i guess my beef is with (func .)
03:30:11 <jethr0> @type even
03:30:11 <lambdabot> forall a. (Integral a) => a -> Bool
03:30:17 <jethr0> @type (even .)
03:30:18 <lambdabot> forall b a. (Integral b) => (a -> b) -> a -> Bool
03:30:18 <xerox> It took a while to grasp it for me too, but it's kinda simple.
03:30:41 <int-e> \a b -> min a . max b  seems fine to me.
03:30:59 <xerox> @type \a b -> min a . max b
03:31:00 <lambdabot> forall a. (Ord a) => a -> a -> a -> a
03:31:05 <int-e> (I realize that the order of arguments is different from Cale's)
03:31:05 <Cale> that's probably the best way to write it
03:31:06 <xerox> Cool.
03:31:23 <xerox> Let's see that Singularity video now.
03:31:29 <musasabi> Haskell makes things too simple sometimes. When looking at a protocol with just an Integer as a key and out-of-order acknowlegments one usually has 1) current place, 2) list of out of order completions.
03:31:35 <jethr0> @type \a b -> min a . max
03:31:37 <lambdabot> forall a t. (Ord (a -> a), Ord a) => (a -> a) -> t -> a -> a -> a
03:31:52 <jethr0> huh?
03:32:07 <xerox> missing a param
03:32:08 <Cale> @type \a b -> min a . max b
03:32:09 <lambdabot> forall a. (Ord a) => a -> a -> a -> a
03:32:11 <musasabi> Now I understood that a simple notUsed = [1..] + delete for done requests does this in an elegant fashion.
03:32:16 <jethr0> ah, sure
03:32:18 <xerox> @type \a b -> (min a .) . max
03:32:19 <lambdabot> forall a t. (Ord a) => a -> t -> a -> a -> a
03:32:23 <xerox> @type \a -> (min a .) . max
03:32:24 <lambdabot> forall a. (Ord a) => a -> a -> a -> a
03:32:24 <xerox> sorry
03:32:28 <xerox> You see that?
03:33:01 <jethr0> i don't get it.
03:33:16 <jethr0> can you please explain how i can understand (func .)?
03:33:21 <Cale> (f .) is section notation, like (3 +)
03:33:38 <Cale> (f .) g = (f . g)
03:33:43 <jethr0> yes, but (3+) is _much_ less abstract. at least for me right now ;-)
03:33:48 <jethr0> cool
03:34:01 <xerox> \x -> f . (g x)
03:34:01 <xerox> \x -> (f .) (g x)
03:34:01 <xerox> \x -> ((f .) . g) x
03:34:01 <xerox> \ -> (f .) . g
03:34:04 <int-e> (3 +) 4 = 3 + 4 ... it's the same really
03:34:05 <fworp> actually, the wikipedia definition /is/ pretty straight forward, once you work your way to the right one.
03:34:08 <xerox> You see?
03:34:30 <Cale> xerox: I wouldn't write the lambda at all in the last line :)
03:34:35 <jethr0> cool, i think i got it now. thx a bunch
03:34:37 <xerox> Cale: indeed.
03:34:42 <xerox> jethr0: my duty!
03:35:12 <jethr0> for queen and country
03:36:27 <triplah> so if i want a function to do something after something else has been done
03:36:32 <triplah> i can use >> ?
03:36:45 <xerox> triplah: talking of functions, composition seem enough
03:36:48 <Cale> triplah: if you want to sequence two IO actions together
03:36:59 <Cale> @type (>>)
03:37:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
03:37:05 <Cale> @type (>>=)
03:37:06 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
03:37:12 <triplah> with my parallel tables, i can addentrytable1 >> addentrytable2
03:37:15 <Cale> IO is an instance of Monad
03:37:28 <Cale> triplah: is this in the IO monad?
03:37:30 <triplah> ahh this isnt IO
03:37:33 <xerox> Yeah.
03:38:00 <jethr0> triplah: you'll know when you are in IO. because the first question on your mind will be: how do i get out again
03:38:03 <Cale> It has to be happening in some monad at least, for >> to apply
03:38:04 <jethr0> ;-)
03:38:09 <Cale> hehe
03:38:15 <xerox> triplah t = addEntryTable2 (addEntryTable1 t)
03:38:15 <xerox> (given addEntryTable# :: Table -> Table
03:38:19 <xerox> Close paren.
03:38:36 <Cale> hehe, written that way, it looks like a builtin
03:38:41 <twb> How is set-difference spelt in Haskell?
03:38:47 <Cale>  \\
03:38:48 <xerox> Cale: hehe, I mean '#' as a number.
03:38:56 <twb> Cale: cheers.
03:38:58 <Cale> list difference
03:38:58 <xerox> > {1,2,3} \\ {2}
03:38:58 <lambdabot>  parse error on input `{'
03:39:04 <xerox> > {1,2,3} Data.Set.\\ {2}
03:39:05 <lambdabot>  parse error on input `{'
03:39:16 <twb> Hmm, does it work on ordered sets?
03:39:18 <xerox> > (read "{1,2,3}") Data.Set.\\ (read "{2}")
03:39:19 <lambdabot>  Not in scope: `Data.Set.\\'
03:39:20 <twb> i.e. [1,2,3]?
03:39:21 <xerox> :-P
03:39:32 <xerox> > (read "{1,2,3}") Data.Set.(\\) (read "{2}")
03:39:33 <int-e> > S.\\
03:39:34 <lambdabot>  Not in scope: data constructor `Data.Set'
03:39:34 <lambdabot>  parse error on input `S.\\'
03:39:38 <xerox> > (read "{1,2,3}") S.(\\) (read "{2}")
03:39:39 <lambdabot>  Not in scope: data constructor `S'
03:39:40 <int-e> > (S.\\)
03:39:41 <lambdabot>   add an instance declaration for (Show (Data.Set.Set a
03:39:41 <lambdabot>                -> Data.Set.Set a
03:39:41 <lambdabot>                -> Data.Set.Set a))
03:39:42 <jethr0> all these different languages... isn't it braces in clean?
03:39:45 <xerox> > (read "{1,2,3}") (S.\\) (read "{2}")
03:39:46 <lambdabot>   add an instance declaration for (Read ((Data.Set.Set a
03:39:46 <lambdabot>                 -> Data.Set.Set a
03:39:46 <lambdabot>                 -> Data.Set.Set a)
03:39:49 <jethr0> [1,2,3] \\ [2]
03:39:52 <jethr0> > [1,2,3] \\ [2]
03:39:53 <lambdabot> [1,3]
03:39:57 <xerox> > (S.\\) (read "{1,2,3}") (read "{2}")
03:39:58 <lambdabot>  add an instance declaration for (Read (Data.Set.Set a))
03:40:02 <xerox> ...
03:40:05 <Cale> there's no read instance
03:40:10 <xerox> Strange!
03:40:17 <dons> twb, noone understands what coarbitrary is for ;)
03:40:21 <xerox> Oh, I see.
03:40:25 <int-e> > S.fromList [1,2,3] S.\\ S.fromList [2]
03:40:26 <lambdabot> {1,3}
03:40:33 <xerox> > (S.\\) (S.fromList [1,2,3<Interrupted by int-e>
03:40:34 <lambdabot>  parse error on input `}'
03:40:42 <dons> maybe John Hughes, that's about it ;)
03:40:51 <Cale> read the paper
03:41:03 <dons> (it's required to generate arbitrary functions, by the way)
03:41:08 <int-e> (scoped inline operators look strange)
03:41:13 <int-e> infix
03:41:18 <xerox> (something more in parens)
03:42:05 <int-e> ((let's have a discussion about using parens to mark subdiscussions in chat environments))
03:42:43 <ick> They do that in #lisp all the time.
03:42:53 <xerox> (((let's meta-discuss that other discussion)))
03:42:55 <dons> twb, seriously, it's used to produce random functions. so it takes a function from a -> generator of random b, and gives you a generator of random functioC[C[C[C[C[Cns from (a -> b)
03:43:14 <Cale> (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
03:43:23 <jethr0> (i (propose (a (break))))
03:43:26 <twb> dons: Um, you're spewing escape codes.
03:43:52 <dons> oh, yay. sorry. i'll try to type more slowly so as not to break my wifi :S
03:44:00 <twb> Heh.
03:44:08 <xerox> > let say xs = repeat '(' ++ xs ++ repeat ')' in say "true, Cale."
03:44:09 <lambdabot> "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
03:44:09 <lambdabot> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
03:44:09 <lambdabot> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
03:44:09 <lambdabot> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
03:44:09 <lambdabot> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
03:44:11 <lambdabot> [23 @more lines]
03:44:16 <dons> xerox wins!
03:44:22 <xerox> \o/
03:44:38 <jethr0> dons, this broken wifi gives me the creeps. how can you live with the fact that anything you write could be garbled?
03:45:00 <int-e> that's omega ... lets .. uhm ... concat (repeat (reapeat '(')) <rest snipped> use omega^2 parens :)
03:45:10 <dons> no, it's not like that. It's some interaction between irssi and buffering and some such
03:45:12 <xerox> int-e: UH?
03:45:39 <jethr0> still, all those protocols in between shouldn't let this through1
03:45:40 <jethr0> !
03:45:49 <dons> the chars go through literally (ie. arrow escapes or delete chars) instead of editing  the buffer they're supposed to
03:45:56 * Cale votes for epsilon_0 parens
03:45:58 <twb> jethr0: all it has to do is drop/insert "not" in convenient places :-)
03:46:14 <jethr0> ah, so it's to do with your IRC client, and not the wifi?
03:46:17 <xerox> Don't be elitist {Cale,int-e} !!! :-)
03:46:42 <flux__> dons, I think it has something to do with irssi's paste detection
03:46:43 * int-e refrains from writing down omega^omega parens.
03:46:44 <dons> I think so, due to a weird delay/buffering of packets introduced by bad wifi this weekend (and some other times)
03:46:55 <dons> flux__, oh, that's an interesting idea!
03:47:13 <dons> could be triggering time outs of escape codes, perhaps.
03:47:14 <xerox> Now we deserve an explanation, you two.
03:47:49 <dons> so an escape key comes in, then there's a timeout will the signal fixes itself, then the char gets inserted literally, rather than being dealt with as a meta char
03:48:07 <dons> would make sense, since it's only chars that produce multi-byte \ESC sequences that go wrong
03:48:36 <triplah> how would i do something where recursion is the snd of a pair? :(
03:48:39 <int-e> xerox: it's a joke. repeat '(' creates a ( for each natural number. repeat '(' ++ "(" has an additional parenthesis for the first infinite ordinal number, omega. and so on.
03:48:43 <flux__> I think irssi's paste code just has some bug, in that it allows control codes to be inserted into the command line whenever it detects a burst
03:49:19 <xerox> int-e: is 'omega' related to 'aleph's ?
03:49:33 <triplah> (a,(fst,recursivestep)) would give (a,(fst,(a,(fst,recurivestep))))
03:49:35 <dons> ah, interesting. I could try updating my irssir, it's a bit old I think.
03:49:35 <triplah> :\
03:49:43 * xerox foresees arrows
03:49:47 <int-e> xerox: related but different. (heh, didn't Cale give a talk about this recently?)
03:49:47 <triplah> irssi 0.8.9 (20031210 2316)
03:49:56 <Cale> was it me?
03:49:59 <xerox> int-e: uh, did he?
03:50:02 * jethr0 thinks that time should have nothing to do with deciding between printable and control chars!
03:50:02 <int-e> Cale: I'm not sure.
03:50:05 <Cale> maybe
03:50:08 <Cale> It's possible
03:50:09 * xerox hands Cale some memory pills
03:50:11 <dons> flux__, as things do arrive in bursts, after the signal corrects itself, the buffered chars get dumped all at once.
03:50:12 <Cale> hehe
03:50:26 <flux__> so like 'burst detected' let's wait does this input trigger the paste detection thresholds while adding characters into buffer, ok it wasn't a paste because it was so short, let's insert the keys to the command line"
03:50:34 <Cale> well, it wouldn't have been that recently
03:50:46 <flux__> and that insertion doesn't anymore go through the command line editor
03:50:53 <dons> jethr0, well, talk to the terminal handler code guys abotu why \ESC was used a the prefix for multi-char keycodes ;)
03:51:30 <dons> flux__, yes, this sounds plausible. I wonder how I could work around it then?
03:51:38 <flux__> disable the mechanism
03:51:39 <jethr0> hehe, they were young and needed the cash ;-)
03:51:42 <flux__> I'm not sure how, though ;)
03:52:23 <dons> I'll look into this flux__, thanks for the hints
03:52:30 <flux__> maybe by reducing paste_detect_time to 0
03:52:41 <flux__> or negative?
03:53:34 <int-e> Cale: ok, it was an old one. it was held in March and you were quite embarrassed about it.
03:54:08 <int-e> http://www.efnet-math.org/~david/mathematics/ordinals.pdf are your notes about it.
03:57:29 <jethr0> @index ap
03:57:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
03:57:30 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
03:57:30 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
03:57:30 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
03:58:11 <xerox> Embarassed? heh.
03:59:12 <jethr0> cale: "incompetence constraints" - i like that ;-)
03:59:55 <dons> are they like incoherent instances?
04:00:22 <dons> I sometimes write really incoherent instances, esp. late on friday nights
04:00:30 <triplah> @mingdex ap
04:00:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
04:00:30 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
04:00:30 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
04:00:30 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
04:00:35 <triplah> hrm :>
04:00:47 <jethr0> @taple even
04:00:48 <lambdabot> forall a. (Integral a) => a -> Bool
04:02:09 * jethr0 states that Control.Monad.List is less readable than he hoped
04:03:41 <xerox> @libsrc Control.Monad.List
04:03:41 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/List.hs
04:04:08 <jethr0> no idea where runListT is implemented
04:04:16 <xerox> It's the newtype!
04:04:30 <xerox> newtype ListT m a = ListT { runListT :: m [a] }
04:04:38 <xerox> It's just a function unpacking a ListT
04:04:49 <xerox> runListT :: ListT -> m [a]
04:04:55 <jethr0> ah, it's an accessor function for structure with _one_ element
04:04:56 <xerox> err
04:05:00 <xerox> runListT :: ListT m a -> m [a]
04:05:13 <xerox> jethr0: yes, like a Maybe a and its Just :: Maybe a -> a
04:05:19 <jethr0> @type runListT
04:05:20 <lambdabot> Not in scope: `runListT'
04:05:29 <jethr0> @type Control.Monad.List.runListT
04:05:29 <xerox> @type Control.Monad.List.runListT
04:05:30 <lambdabot> forall a (m :: * -> *). Control.Monad.List.ListT m a -> m [a]
04:05:30 <lambdabot> forall a (m :: * -> *). Control.Monad.List.ListT m a -> m [a]
04:06:40 <jethr0> hmm, maybe i'll start with another monad...
04:07:16 <xerox> @google all about monads
04:07:17 <lambdabot> http://www.nomaware.com/monads/html/
04:07:29 <xerox> That has the code you're looking at, and examples, and explanations.
04:07:40 <jethr0> xerox, i read that before, but maybe with my newly acquired skills, it will do some more good
04:07:51 <jethr0> thx
04:07:58 <xerox> Indeed!
04:10:13 <jethr0> @zgozgel all about monads
04:10:14 <lambdabot> Unknown command, try @listcommands.
04:10:24 <jethr0> @zgozgle all about monads
04:10:25 <lambdabot> http://www.nomaware.com/monads/html/
04:13:23 <Trixsey|Laptop> I'm making an UML, anyone got time to look at it? Need a few tips on how to do with relations toward interfaces and stuff
04:23:57 <Lemmih> UML?
04:24:10 <ulfdoz> User Mode Linux, I suppose.
04:24:53 <jethr0> unified modeling language
04:25:14 <jethr0> a function in list monad multiplying integers, returning 0 when 0 is encountered... any ideas?
04:26:02 <jethr0> *damn you, list monad* ;-)
04:26:09 <ulfdoz> I don't regard UML (the language) as suitable for designing functional programms. But UMLinux suffers from the same problem. :)
04:26:19 <triplah> haha
04:26:23 <triplah> probably more so
04:26:39 <dons> Use More Lambdas?
04:27:13 <triplah> but if you wanted someone to critique a language, you wouldnt ask a java programmer
04:27:18 <triplah> ask FPers
04:27:20 <jethr0> it suffers from the same problem, lifted to another domain
04:28:11 <twb> triplah: I'd ask Riastradh :-)
04:29:01 <triplah> twb: indeed!
04:29:09 <triplah> didnt think of him actually
04:29:28 <phys_rules> java is bad but not too bad, don't offend it too much ;)
04:29:36 <twb> phys_rules: bah.
04:29:36 <kala> I'm still troubled by the trees. given the definitions and code http://pastebin.com/448186, I don't understand why hugs apply Leaf to two arguments, although I have specifically enclosed the them in parenthesis. 
04:29:54 <triplah> phys_rules: im not knocking the language, merely the people who cant see past it
04:29:57 <triplah> :P
04:30:01 <twb> phys_rules: that's like saying "Java is good, because you only need to stick *one* flaming skewer up your arse!"
04:30:08 <musasabi> Has anyone got simple demonstration code for hFoldr (from HLists) ?
04:30:49 <dons> @remember twb Java is good, because you only need to stick *one* flaming skewer up your arse!
04:30:53 <phys_rules> btw, there should be a huge amount of code snippets for haskell, that would be great for newbies
04:31:10 <triplah> @quote
04:31:11 <lambdabot> reffie says: yi is clearly the editor of the future.
04:31:17 <triplah> bah :)
04:31:23 <int-e> . o O ( Java has a strong point, where both PHP and VB fail - it's a programming language )
04:31:23 <dons> reffiie is very wise ;)
04:31:28 <triplah> @seen
04:31:28 <lambdabot> Lately, I have seen dons, int-e, kala, musasabi, phys_rules, triplah and
04:31:28 <lambdabot> twb.
04:31:28 <phys_rules> like, reading a directory, using MissingH, using fps, using mtl, ...
04:31:38 <jethr0> dons: that was bad quoting
04:32:20 <triplah> int-e: php is a scripting language. and its good at it, which set it distinctly apart from VB
04:32:21 <jethr0> @seen
04:32:22 <lambdabot> Lately, I have seen dons, int-e, jethr0, phys_rules and triplah.
04:32:25 <triplah> sets*
04:32:29 <jethr0> hmm
04:33:03 <triplah> languages all serve a purpose, except for VB
04:33:24 <phys_rules> yes, VB is lame =)
04:33:29 * jethr0 doesn't like the short @seen timeout on lambdabot
04:33:30 <triplah> even brainfuck is better, simply on the merit that its more interesting
04:33:32 <jethr0> @seen
04:33:33 <lambdabot> Lately, I have seen jethr0, phys_rules and triplah.
04:33:49 <musasabi> Seems like the implementation of HLists differs from the paper in small ways which make getting the instances right hard.
04:34:01 <jethr0> triplah, i dare you to write _any_ sensible application in brainfuck
04:34:10 <jethr0> under that metric, java wins hands down!
04:34:16 <dons> jethr0, submit a patch.. it's a 1 byte change ;)
04:34:18 <phys_rules> It was so funny to see how a VB cool hax0r programmer was posting on a forum saying "Where are the VB sources for gtalk, I want to improve it"
04:34:21 <triplah> jethr0: i dont recall listing sensible application as one of its merits :P
04:34:22 <jethr0> although BF is more of a challenge, granted
04:34:22 <dons> look in Plugins/Seen.hs
04:34:25 <dons> @version
04:34:25 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
04:34:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
04:34:53 <jethr0> dons ;-)
04:35:01 <dons> it should be more like the last 60 minutes, perhaps.
04:35:06 <dons> or even 2 hrs
04:35:11 <triplah> @herdsion
04:35:12 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
04:35:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
04:35:31 <jethr0> @ervson
04:35:32 <lambdabot> Unknown command, try @listcommands.
04:35:35 <triplah> @herdlion
04:35:36 <lambdabot> Unknown command, try @listcommands.
04:35:37 <dons> jethr0, seriously, lambdabot is a good way to get into nasty haskell hacking ;)
04:35:41 <triplah> boo :)
04:35:43 <int-e> jethr0: BF is a great programming language if you like spending 10 hours on a 333 character program
04:35:49 <jethr0> dons, i'm darcsing as we speak
04:35:53 <twb> That should probably have --partial
04:35:55 <dons> excellent :)
04:35:59 <triplah> anyone seen  whitespace?
04:36:03 <jethr0> 333 characters. that's one big monster application!
04:36:05 <dons> yeah, --partial is a good idea.
04:36:08 <triplah> just when you thought indentation in python was bad
04:36:09 <triplah> :P
04:36:15 <dons> I'm more of an unlambda kind of guy.
04:36:47 <triplah> ehe
04:37:15 <phys_rules> dons: which one of the mpg123 or mpg321 you recommend for hmp3 ?
04:37:21 <twb> mpg321
04:37:25 <twb> But it should be configurable.
04:37:29 <dons> mpg321, by far.
04:37:34 <twb> (mpg123 is not Free, IIRC)
04:37:37 <dons> mpg123 seems a bit flakey
04:37:48 <dons> one's GPL, ones BSD, iirc
04:38:04 <phys_rules> GPL kind of sucks a bit, BSD Is better
04:38:10 <jethr0> so, which one is the less free?
04:38:15 <twb> dons: Hmm, maybe one is linked to a non-free library?
04:38:22 * shapr yodels
04:38:26 <dons> I think mpg123 used to be a commerical app
04:38:35 <shapr> phys_rules: I prefer GPL myself.
04:38:35 <flux__> I don't think mpg123 is bsd
04:38:39 * twb is swallowed by avalanche.
04:38:43 <dons> or somehow not free is an expensive beer kind of way
04:38:49 <shapr> But we've had that discussion here :-)
04:38:54 <dons> no, mpg321 is bsd.
04:39:05 <triplah> mpg123 is "as-is"
04:39:05 * jethr0 clubs twb with the stallman stick
04:39:20 <phys_rules> but the last mpg321 is from 2002 heheh =)
04:39:21 <triplah> mpg321 is gpl-2
04:39:24 <flux__> I've found that mpg123 plays better than mpg321, but that was eons ago
04:39:29 <shapr> I think everybody should make their own choices, but my preference is GPL.
04:39:33 <dons> yeah, it rocks phys_rules. it's stable. it works. it's solid.
04:39:40 * shapr hugs dons 
04:39:48 <shapr> @karma+ dons
04:39:48 <lambdabot> dons's karma raised to 19.
04:39:52 <shapr> For cool code
04:39:55 <flux__> and it affects only certain .mp3-files
04:39:59 <dons> oh, thanks you shapr :)
04:40:01 <jethr0> i think everyone should be liberal and who thinks otherwise is a nazi
04:40:33 <shapr> Isn't that like "All fanatics must die!" ?
04:40:41 <jethr0> yes
04:40:49 <shapr> ok then :-)
04:40:54 <dons> flux__, Lemmih noticed that mpg123 sometimes does odd things when under zombie control by hmp3. it doesn't follow its own protocol properly.
04:41:02 * jethr0 apologises for having killed the channel
04:41:38 <flux__> so I guess music playing daemon is out of the question, in any case?
04:41:39 <triplah> always silence after you talk jethr0 :P
04:41:46 <jethr0> i realised
04:41:49 <triplah> your paranoia may be justified
04:41:49 * joelr1 is the champion of wierd ghc bugs reported 
04:41:50 <triplah> :)
04:41:52 <dons> flux__, not at all. it's quite possible
04:41:55 <dons> joelr1, totally!
04:42:02 <joelr1> dons: i installed the signal handler
04:42:06 <joelr1> dons: but check this out
04:42:08 <dons> you've personally broke more ghc's than I've compiled 
04:42:09 <flux__> support for multiple backends could be useful.
04:42:18 <flux__> mplayer can play mp3's too, you know
04:42:19 <joelr1> dons: randomplay: internal error: scavenge_stack: weird activation record found on stack: 0
04:42:22 <joelr1>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
04:42:30 <dons> yeah, I saw your posts
04:42:46 <joelr1> dons: i think the two posts are related somehow
04:43:02 <dons> well, what thread is the signal handler running in?
04:43:12 <dons> does it matter what thread is runnign when the signal is called? I'm not sure.
04:43:13 <phys_rules> flux__: I actually use mplayer to play my mp3s, but I think mplayer uses mpg321 =)
04:43:18 <jethr0> flux__, mplayer is dying a slow death.
04:43:21 <joelr1> dons: beats me
04:43:24 <dons> which thread gets the exit exception? these are things to consider.
04:43:32 <twb> jethr0: yeah :-/
04:43:37 <joelr1> dons: how do i tell?
04:43:37 <phys_rules> jethr0: no way, it's alive and kicking! ;)
04:43:39 <dons> maybe it's just ignored by some child thread, when it needs to get out too the main thhread.
04:43:46 <jethr0> last release months/years ago and ppl switching to xine in the thousands
04:43:51 <phys_rules> jethr0: it plays lots of weird files that vlc can hardly play
04:43:53 <flux__> too bad no other players seem to take the command line+customizability-approach then
04:43:56 <dons> joelr1, wrap catches over your threads and print exceptions as they're thrown
04:44:05 <dons> joelr1, and you can always print the current thread id
04:44:07 <joelr1> dons: i already do
04:44:11 <jethr0> xine has better a/v sync, as good codec support, ...
04:44:16 <dons> or throw to a specific thread
04:44:36 <jethr0> i am (historically) a strong supporter of mplayer, but lately development is just _too_ slow
04:44:36 <joelr1> dons: if an exception is thrown it gets caught upstream and the "script" that runs in that thread is reported as failed
04:44:39 <twb> jethr0: but can xine play BBC7 realaudio streams?
04:45:06 <joelr1> dons: but how is a signal handler related to exceptions?
04:45:25 <dons> your signal handler throws an exception some where, and ExitException, yeah?
04:45:34 <jethr0> don't know, but for a/v sync xine is hundred times more reliable! i'm constantly having trouble in mplayer (nobps, ...) and never had any with xine
04:45:46 <joelr1> dons: no way, i just do what you suggested
04:45:55 <joelr1> dons: or does exitWith throw an exception?
04:45:58 <dons> yes :)
04:46:03 <dons> an ExitException
04:46:11 <joelr1> ah
04:46:21 <dons> which you can also catch, or rethrow or ignore and so on.
04:46:37 <dons> if an exit exception makes its way to the main thread, and isn't caught, the program terminates with that code
04:46:45 <joelr1> dons: hmm... so given that i do not know what thread it gets thrown to what do i do then?
04:46:54 <flux__> but instead they require using fancy user interfaces which I don't need anyway.
04:47:01 <joelr1> dons: because that exception is not being caught anywhere
04:47:15 <dons> I'd try to print the thread id i nthe signal handler.
04:47:22 <joelr1> ah
04:47:31 <dons> and maybe try throwing to the main thread explictitly
04:47:37 <dons> with Control.Exception.throwTo
04:47:58 <dons> (you'd have to cache the main thread's id in the state somewhere)0
04:48:01 <flux__> do non-mplayers nowadays support screens with non-square pixels?
04:48:17 <joelr1> dons: let me try printing the thread id first
04:48:28 <jethr0> dons: patch should be in your inbox!
04:48:40 <jethr0> untested, _of course_
04:48:48 <dons> so rather than just exitWith, you could try throwTo mainThread (ExitFailure 1) 
04:49:04 <dons> which raises an exit exception in the main thread, which sounds like a nicer thing to do
04:49:28 <dons> and perhaps also try shutting down all the other threads before you throw your exit exception
04:49:34 <joelr1> dons: you know, i periodically think of just rewriting this project in something like ruby but
04:49:37 <dons> (this is what my shutdown function does)
04:49:59 <joelr1> dons: support from folks like you on this channel makes me think different :D
04:49:59 <dons> well, has haskell been the problem, or knowledge of haskell?
04:50:04 <dons> cool :)
04:50:18 <joelr1> dons: lets review this problem
04:50:39 <joelr1> dons: do you think it's knowledge of haskell or haskell itself? i think this must be some carnal knowledge
04:50:54 <dons> carnal? or arcane ;)
04:51:03 <joelr1> some entirely non-obvious arcane knowledge
04:51:15 <joelr1> sorry about carnal 
04:51:47 <dons> oh, hopefully not. it's just the standard stuff on how to do concurrent programming in haskell. it's not a big secret, except you've dived in the deep end without the required deep study of Peyton-Jones papers ;)
04:52:36 <joelr1> dons: shame on you, of course i read them
04:53:12 <dons> :p but concurrent programming is tricky to reason about, so I think it is just that.
04:53:14 <joelr1> dons: but i must not have read them with a magnifying glass or something because i do not remember a mention of signal handlers and needing to throw to the main thread or kill other threads first
04:53:20 <dons> also, you've had way way more ghc bugs than is healthy
04:53:35 <joelr1> dons: thank you
04:53:37 * joelr1 nods
04:53:38 <dons> oh, that magic is in the haddock docs for Control.Concurrent
04:53:49 <dons> @docs Control.Concurrent
04:53:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
04:53:59 <dons> see the stuff about daemonic threads
04:54:15 <joelr1> dons: looking
04:54:20 <dons> hhmm, but dealing with signals handlers is a bit arcane.
04:54:39 <joelr1> this is excorcism for sure (sp?)
04:54:43 <joelr1> exorcism
04:55:02 <dons> and the interaction between exceptions and signals is a bit icky
04:55:08 <dons> david roundy noted this too
04:56:30 <dons> you've really been stressing two less-supported ghc archs: the mac, and windows.
04:56:32 <joelr1> i see no mention of daemonic threads in control.concurrent
04:56:44 <dons> I hope windows users are sending you cheques for all the bugs you're exposing ;)
04:56:46 <joelr1> dons: possibly. i dumped windows, btw
04:56:58 <ndm> dons, no - i dumped ghc instead of windows ;)
04:57:00 <joelr1> and the last bug was a cross-platform one
04:57:18 <dons> ndm :p
04:57:21 <joelr1> dons: a non thread-safe getHostByName
04:57:22 <twb> No one likes OS X or Windows.
04:57:31 <ndm> twb, ahem - me
04:57:31 <dons> joelr1, daemonic threads is discussed after "runInUnboundThread"
04:57:52 <joelr1> fortunately we have people like Simon M. who can ssh directly into my laptop now :D
04:57:53 <phys_rules> hey ndm
04:57:55 <dons> "In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate." ..
04:58:01 <phys_rules> ndm: I compiled yhc on solaris :)
04:58:10 <ndm> phys_rules: way cool, any patches needed?
04:58:19 <phys_rules> ndm: nope
04:58:21 <joelr1> dons: well, i already use waitForChildren
04:58:24 <musasabi> joelr1: btw I have preliminary patches for the Network.BSD locking stuff.
04:58:29 * twb has never even *heard* of yhc
04:58:34 <ndm> @where yhc
04:58:35 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
04:58:40 <ndm> @wiki yhc/Ports
04:58:40 <lambdabot> http://www.haskell.org/hawiki/yhc/Ports
04:58:45 <ndm> @wiki Yhc/Ports
04:58:45 <lambdabot> http://www.haskell.org/hawiki/Yhc/Ports
04:58:55 <joelr1> musasabi: great, thanks. i think i'll delay applying it though. it seems that with a lock it's no longer crashing
04:59:00 <ndm> phys_rules, add yourself as solaris maintainer under ports!
04:59:02 <joelr1> musasabi: and i got different fish to fry now
04:59:15 <ndm> twb, its a haskell compiler, based on nhc
04:59:24 <phys_rules> ndm: if only I would remember my password on hawiki =)
04:59:35 <joelr1> dons: i'm using a TChan (STM) to communicate with threads now
04:59:36 <ndm> phys_rules: i'll do it for you
04:59:53 <phys_rules> ndm: the password it stored in a program in windows, so I'll have to reboot in windows to find it
04:59:54 <joelr1> and threads quit when a special event is sent
05:00:33 <ndm> phys_rules: do you have a link/name/identifer/home page or anything you want putting with your IRC name?
05:00:33 <joelr1> dons: i think i'll have forkChild (from Control.Concurrent) allocate the TChan and pass it to the thread being forked
05:00:35 <dons> ok, so perhaps your signal handler should shutdown your threads with this special event, and then toss an exitWith to the main thread
05:00:54 <joelr1> dons: the main thread will automatically exit when all the children are dea
05:00:57 <phys_rules> ndm: I'm IurieCn on hawiki aka phys_rules :)
05:01:05 <joelr1> main = 
05:01:05 <joelr1>     do initSnippets 
05:01:05 <joelr1>        forkChild $ launchScripts 5000 Random
05:01:05 <joelr1>        sleep_ 2000
05:01:05 <joelr1>        waitToFinish
05:01:10 <dons> ah, ok. it's jsut waiting on them?
05:01:11 <dons> cool.
05:01:16 <dons> that'd do then
05:01:17 <joelr1> dons: right, just waiting for them
05:01:31 * joelr1 is doing
05:02:05 <ndm> phys_rules, done - thanks very much
05:03:23 <phys_rules> ndm: np, other people will be able to do it as well, when I'll make a normal ghc-6.4.1 package for i386 solaris to put on haskell.org
05:03:45 <phys_rules> it's almost done, but physics books keep distracting me :)
05:03:58 <ndm> in a few weeks we hope to have yhc self-compiling, then ghc will not be required
05:05:07 <phys_rules> ndm: yeah, that would be great, but that would require the extension of the current base by quite a lot
05:05:33 <ndm> phys_rules: yes, but that work is already underway - and isn't that hard
05:05:37 <dons> ndm, does yhc run in plugs?
05:05:40 <dons> s/plugs/hugs/
05:05:47 <dons> freudian slip..
05:05:56 <ndm> dons, of course - thats how i develop it!
05:06:01 <dons> ah, right!1
05:06:02 <dons> I forget.
05:06:25 <ndm> under hugs its a bit too slow to compile much
05:06:38 <ndm> but for typechecking and parsing before running, its perfect
05:06:42 <dons> so it's the "64-bit clean, ultra-portable, pure Haskell 98 Haskell compiler" ? or what's the slogan going to be?
05:06:54 <phys_rules> ndm: but even nowadays base becomes very evil, too many #ifdef __GLASGOW...#ifdef NHC, HUGS, etc.. then what YHC, ZHC, UHC hehe :) it's not the solution...
05:07:32 <ndm> phys_rules, agreed - we're working on solutions to that - the yhc compiler has NO #ifdef's and works under all modern haskell compilers without modification
05:07:48 <ndm> dons, nope - those are all true, but not our best features
05:08:18 <ndm> well, ultra-portable probably survies, but Hat support will defineately get in there somewhere
05:08:24 <dons> oh, they seem like the best from my point of view.
05:08:33 <ndm> thats because Hat support hasn't been finished
05:08:34 <dons> ah, the only haskell compiler with an integrated debugger?
05:08:48 <ndm> image, you run a program, it gives "error: fromJust failed"
05:08:50 <skew> Hat? I'm interested
05:08:50 <dons> well, assuming nhc doesn't count.. hmm.
05:08:55 <joelr1> dons: what do you think would be a good way to introduce a per-child TChan into the children/waitForChildren scheme in Control.Concurrent?
05:09:08 <ndm> then you click on "show_stack" - it gives you a full stack trace
05:09:17 <phys_rules> yeah, stack trace is a major plus of java
05:09:24 <phys_rules> I mean HUGE plus
05:09:29 <dons> ndm, click?? what's this click? what do I type.. :p
05:09:33 <ndm> dons, nhc only had integrated debugging for a brief period, it got moved out to hat-trans quickly
05:09:39 <dons> ah, right.
05:09:46 <ndm> dons, you type "hat-stack Main"
05:09:54 <dons> ah, that's better :) I can live with that.
05:09:55 <ndm> @where Hat
05:09:55 <lambdabot> http://www.cs.york.ac.uk/fp/hat
05:10:19 <ndm> skew, Hat is a haskell debugger - its quite good but has a few issues - like creating a trace is a bit hard - yhc hopes to address them all
05:10:24 <dons> joelr1, not sure. haven't played with TChans much
05:10:29 <joelr1> dons: currently it seems to wait for the last child (first in the list) to exit and then loops. and it waits on an empty MVar. off the top of my head i think i should store the TChan in children but then the MVar won't be empty. 
05:10:36 <joelr1> dons: it's not particular to TChans
05:10:37 <phys_rules> ndm: would be even better not to type anything =)
05:10:39 <joelr1> the problem
05:10:46 <phys_rules> ndm: it would just give the darn trace =)
05:10:48 <joelr1> it's more like keeping a list of threads around
05:10:54 <joelr1> to communicate with them
05:12:02 <joelr1> dons: it seems like i would need to replace the takeMVar which waits for the MVar to become full with a "wait for MVar to have Nothing and proceed if it has Just". something like that. but there's no runtime call to wait for the MVar to have a particular value
05:12:14 <int-e> @where STM
05:12:15 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
05:12:31 <dons> joelr1, yeah, tryTakeMVar, right?
05:12:56 <xerox> @index takeMVar
05:12:56 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
05:13:04 <xerox> @type GHC.Conc.takeMVar
05:13:05 <lambdabot> forall a. GHC.IOBase.MVar a -> IO a
05:13:08 <xerox> @type GHC.Conc.tryTakeMVar
05:13:09 <lambdabot> forall a. GHC.IOBase.MVar a -> IO (Maybe a)
05:13:13 <joelr1> dons: that's different. it checks to see if mvar is empty. 
05:13:17 <dons>     x <- tryTakeMVar clockModified   -- immediate update
05:13:19 <dons>     when (isJust x) UI.refreshClock
05:13:24 <dons> :)
05:13:29 <xerox> Clean!
05:13:43 <joelr1> dons: but then the waitForChildren thread is gonna consume CPU cycles
05:13:52 <joelr1> dons: whereas right now it blocks on the MVar
05:14:10 <xerox> joelr1: pattern match on what you find inside?
05:14:26 <joelr1> xerox: same effect, looping around all the time instead of blocking
05:14:45 <dons> ok, so you need to wait on empty MVars only somehow. that's the only way
05:14:58 <xerox> Yeah, why do you need Maybe a ?
05:15:00 <dons> they should just write the MVars when the thread are done.
05:15:02 <joelr1> right, block on something
05:15:06 <joelr1> here's what i want
05:15:30 <xerox> brb.
05:15:45 <joelr1> i want to be able to talk to my threads. i'm already allocating a TChan internally so i think i can export the allocation of TChan outside, into forkChild
05:15:50 <joelr1> now i need to keep this TChan someplace
05:16:05 <joelr1> i guess i cannot have it in the list of children
05:16:08 <ndm> phys_rules, maybe for hat-stack yes - but there are about 10 hat trace viewing tools, all of which solve different problems
05:16:13 <joelr1> since then i would not block on the MVar
05:16:27 <dons> you don't have some global state with a list of MVars that the children will write to when done?
05:16:30 <ndm> for example, if you get a black-hole or non-termination, there are special debuggers for those things
05:16:39 <joelr1> so maybe just store a pair of (TChan, MVar) in children
05:17:00 <joelr1> dons: i do, a list of empty MVars that become full when threads die
05:17:13 <joelr1> i guess i will just store a pair of TChan and empty MVar
05:17:34 <skew> joelr1: maybe it would be easier with TMVar
05:18:03 <joelr1> the semantics on waitForChildren won't change then and to send messages to each thread from outside of waitForChildren i could just reiterate over the list of children and send  a message to those with an empty MVar
05:18:07 <joelr1> how is that?
05:18:13 <joelr1> skew: what would a TMVar buy me?
05:18:18 <skew> orElse
05:18:37 <joelr1> skew: and how do you see using orElse with, say, 4000 threads? :D
05:18:58 <skew> foldr orElse retry?
05:19:13 <joelr1> hmm
05:19:16 <skew> or is that just spelled msum?
05:20:02 <skew> If you are waiting for any to finish, it should work much better than running down the list calling tryTakeMVar everywhere
05:20:18 <joelr1> skew: i think it would solve a problem that does not exactly need solving now. i'm trying to figure out how to keep a TChan per thread in the list of chidlren
05:20:46 <skew> a TChan shared with the child?
05:20:52 <joelr1> i'm not calling tryTakeMVar now, i block on an empty MVar. see the docs for Control.Concurrent, i just took the waitForChildren, etc. code from there
05:21:06 <skew> how about creating it when you make the thread, and passing it into the child
05:21:09 <joelr1> skew: yes, a TChan shared with the child. the child reads from the TChan
05:21:28 <joelr1> skew: thank you! i mentioned that a few minutes ago :D now you are getting in the loop!
05:21:46 <joelr1> skew: i will do that but... how do i keep the TChan for each thread around? 
05:21:50 <skew> like, do chan <- newTChan; tid <- forkIO $ newChild chan; return (chan,tid)
05:22:06 <skew> and then however you are already getting the tid into the list
05:22:10 <joelr1> skew: my latest and greatest idea is to store a pair of (TChan, MVar) in children instead of just MVar
05:22:35 <skew> Is storage in the children really a problem?
05:22:55 <joelr1> then if i need to send something to each thread i just iterate over the list of children and do tryTakeMVar to see if the child is alive. if it is then i send  amessage down the TChan
05:23:35 <joelr1> skew: see the docs for Control.Concurrent, {-# NOINLINE children #-}
05:23:35 <joelr1> children :: MVar [MVar ()]
05:23:35 <joelr1> children = unsafePerformIO $ newMVar []
05:23:50 <joelr1> anyway, i'm gonna try this first
05:24:16 <joelr1> do children :: MVar [ (MVar (), TChan xx ) ]
05:24:28 <joelr1> i think it will work
05:25:46 <skew> do you only broadcast messages?
05:25:57 <joelr1> skew: that's all i need for now
05:26:12 <skew> oh, then you should use dupChan rather than messing around with all this stuff
05:26:30 <joelr1> skew: this TChan is getting passed to a couple of other threads later on but my issue is telling threads to terminate
05:26:39 <joelr1> skew: so i don't need dupChan for that
05:27:02 <skew> huh? You just said that the chans were just for broadcasting messages to all the threads
05:27:16 <joelr1> skew: that's not what you asked ;)
05:27:28 <joelr1> miscommunication ;)
05:27:55 <joelr1> skew: i use the chans in a 3 thread scenario where one thread has the logic and two other threads read/write from a socket
05:28:24 <joelr1> so the thread that reads from a socket posts events to that tchan and can post a quit event when the other side has closed the connection or something
05:28:42 <joelr1> so i want to send a quit event from a signal handler but for that i need to get hold of each thread's TChan
05:29:23 <joelr1> so i need to keep the TChans around, so i need to pass them to each new thread from my forkChild instead of allocating them further down, so i need to store a pair of (TChan, MVar) 
05:29:31 <joelr1> skew: does it explain everything?
05:29:47 <skew> you are trying to treat killing the whole program on a signal the same as EOF on one socket?
05:30:05 <joelr1> now when i catch a signal (sigINT) i can iterate through children, check the MVar to see if the child is dead and post a message if its not
05:30:19 <joelr1> skew: i gotta go do the work ;)
05:30:52 <joelr1> skew: but to preempt the discussion on why what i'm doing is wrong i need to tell you
05:31:22 <joelr1> that i'm catching the signal because otherwise profiling logs are not generated and i cannot just exit from the signal handler because of an obscure bug that i just posted to haskell-cafe
05:31:26 <joelr1> uff :D
05:31:52 <skew> Oh, I was assuming you needed a clean shutdown
05:32:07 <joelr1> yes, i do need a clean shutdown
05:32:18 <skew> but I can talk about what you're doing wrong after you finish doing it :)
05:32:22 <joelr1> but the signal is not caught in the main thread, rather in some other random thread
05:32:32 <joelr1> launched from the main thread
05:32:54 <joelr1> so the clean shutdown would be to tell other threads to exit and when they do waitForChildren will exit and the main thread will exit
05:33:20 <dons> joelr1, but there's also the possibility of a 'throwTo' the main thread, causing the main thread to exit immediately, whose daemonic behaviour will cause the children to die
05:33:43 <joelr1> dons: that would not be clean, though
05:33:43 <dons> so maybe even no need to halt the children explicitly (though it's probably a good idea..
05:33:49 <dons> true.
05:33:51 <joelr1> dons: i'd go with a good idea
05:34:02 <joelr1> of sending an event to each child thread
05:34:07 <skew> you could also just maintain a list of threadIds and throwTo them
05:34:31 <skew> or, have a separate broadcast channel dup'd and passed down to all the children, just for quit events
05:34:34 <dons> yeah, that's all I usually do: a mapM_ killThread threadIds
05:34:34 <joelr1> i prefer to keep a list of channels into each thread
05:34:52 <joelr1> and i do not need a separate channel just for quit events since my regular channel is already used for quit events
05:34:58 <joelr1> so i can just use one channel
05:35:03 <dons> killThread, which raises an async ThreadKilled exception in each child.
05:35:16 <skew> I think they're different sorts of events - but it could be a good idea to keep a channel to each child anyway
05:35:24 <joelr1> so, they are the same type of event
05:35:38 <joelr1> when i catch an aborted server connection i tell the logic thread to quit
05:35:48 <joelr1> this is the same quit in a way
05:35:59 <joelr1> i'm forcing the logic thread to quit all the same
05:36:02 <skew> anyway, I think it would be simpler to have dying threads remove themselves from the global table, rather than polling in the main thread
05:36:15 <skew> how are the records normally removed, or do you just leak memory?
05:36:56 <joelr1> skew: please read the haddoc docs for Control.Concurrent, this will put you on the same page with me. otherwise you are offering a lot of useful but non-applicable advice
05:37:00 <skew> there's no harm in sending a message on a Chan belonging to a dead thread anyway
05:37:17 <joelr1> skew: ok, so i won't do a try then
05:37:17 <skew> I think I'm pretty familiar with it, anything in particular?
05:37:30 <joelr1> skew: the code from it, which i'm using almost verbatim
05:37:42 <joelr1> which answers your question of how i'm normally removing records ;)
05:38:11 <skew> the nmergeIO code, maybe?
05:38:31 <joelr1> no, the forkChild and waitForChildren code
05:39:33 <phys_rules> grr, hmp3 doesn't compule :\
05:39:40 <phys_rules> compile thati s
05:39:52 <dons> phys_rules? 
05:40:08 <dons> what goes wrong (I bet your Cabal is too old..)
05:40:13 <phys_rules> dons: 1.0.4
05:40:23 <dons> ok, then what is the error?
05:40:29 <skew> joelr1: this is for some kind of network server, right? Lots of new threads for new connections?
05:40:42 <joelr1> skew: network client. a bot launcher
05:40:50 <dons> phys_rules: $ ghc-pkg list Cabal
05:40:50 <dons> /home/dons/lib/ghc-6.4.1/package.conf:
05:40:50 <dons>     Cabal-1.1.4
05:41:16 <skew> well, that code looks like it's meant for a fixed population of threads
05:41:31 <joelr1> skew: it is fixed. i launch a fixed number of them
05:41:34 <phys_rules> [ ~ ]$ ghc-pkg list Cabal                                   [ Sunday 04/12/05 ]
05:41:34 <phys_rules> /opt/other/lib/ghc-6.4.1/package.conf:
05:41:34 <phys_rules>     (Cabal-1.0), Cabal-1.1.4
05:41:38 <joelr1> and then the main thread waits for them to exit
05:41:44 <dons> ok. what's the error then, phys_rules?
05:41:58 <dons> before I fall asleep here in .au ..
05:42:06 <dons> :)
05:42:15 <phys_rules> curses.h gets nested
05:42:26 <dons> hmm. nested?
05:42:33 <phys_rules> and then looks like it doesn't resolve symbols from curses
05:42:58 <dons> do you have ncurses?
05:43:00 <phys_rules> bits/curses.h:16::16:2020::  #include nested too deeply#include nested too deeply
05:43:03 <phys_rules> yes
05:43:04 <phys_rules> of course
05:43:17 <dons> bits/curses.h? weird. what OS?/
05:43:31 <phys_rules> cbits/curses.h
05:43:31 <phys_rules> ;)
05:43:40 <phys_rules> Solaris x86
05:43:52 <dons> ah. untested, but should work! please submit any fix.
05:43:57 <dons> the relevant code is:
05:44:00 <dons> #if HAVE_LIBNCURSES
05:44:00 <dons> #include <ncurses.h>
05:44:00 <dons> #else
05:44:00 <dons> #include <curses.h>
05:44:00 <dons> #endif
05:44:08 <dons> so maybe work out why that doesn't work.
05:44:13 <phys_rules> k
05:45:11 <joelr1> dons: this is a silly question probably but why did you write it using curses? why not gtk2hs or something like that?
05:45:28 <dons> because I like terminal apps :)
05:45:37 <joelr1> right
05:45:59 <dons> and there must be a billion gazillion gtk mp3 players out there ;)
05:46:07 <dons> (maybe not in haskell though.)
05:46:31 <xerox> In fact something Haskell-based would be cool.
05:46:44 <joelr1> does anyone know how to catch a ResourceVanished exception?
05:46:48 <xerox> I mean, we can start doing crazy things like in... searches, hm? :-)
05:46:55 <joelr1> it's in GHC.IOBase but does not seem to be exported
05:47:11 <dons> joerl1, you pattern match on the exception thrown in the handler. it's just a constructor of the Exceptionn type, iirc.
05:47:22 <joelr1> dons: it does not seem to be exported, though
05:47:33 <joelr1> it's an IOErrorType, my apologies, not an exception
05:47:59 <joelr1> so i catch the IOException but it complains of an undefined constructor ResourceVanished
05:48:08 <dons> I usually have something like this: 
05:48:08 <dons> exitTime :: Exception -> Bool
05:48:08 <dons> exitTime e | isJust . ioErrors $ e   = False -- ignore
05:48:08 <dons>            | isJust . errorCalls $ e = False -- ignore
05:48:08 <dons>            | isJust . userErrors $ e = False -- ignore
05:48:11 <dons>            | otherwise               = True
05:48:43 <joelr1> dons: ok, thanks
05:48:45 <joelr1> i do something similar
05:48:53 <joelr1>     `Control.Exception.catch`
05:48:53 <joelr1>     (\e -> do trace_ $ show e
05:48:53 <joelr1>               trace_ " ---- Script failed ----"
05:48:53 <joelr1>               case e of
05:48:53 <joelr1>                 IOException ioex -> 
05:48:55 <joelr1>                     do trace_ " ---- Script restarted ----"
05:48:57 <joelr1>                        run hi ai script q
05:48:59 <xerox> dons: align those "$ e" :-D
05:49:00 <joelr1>                 _ -> return ()
05:49:02 <joelr1>     )
05:49:12 <joelr1> i'm basically restarting the "script" on an IO exception
05:49:26 <dons> joelr1, yeah, that's how I usually do things too.
05:49:31 <phys_rules> dons: Oh, I was wrong I don't have ncurses, just the curses.h but it seems that #include <curses.h> just includes the local curses.h rather than the /usr/include/curses.h
05:49:39 <dons> oh, bad.
05:49:54 <dons> and curses.h would probably work anyway, I don't think I require ncurses
05:50:04 <dons> but this sounds like a solaris cpp issues?
05:50:22 <phys_rules> nope, ghc uses gcc for preprocessing
05:50:35 <phys_rules> nope, doesn't work with curses.h doesn't find some WA_
05:50:50 <dons> ah. WA_* what?
05:51:18 <dons> WA_ATTRIBUTES or so?
05:51:20 <dons> I guess.
05:51:26 <phys_rules> WA_BOLD, attr_t
05:51:31 <dons> dooesn't work on Irix either. so no pretty colours.
05:51:32 <phys_rules> that kind of things
05:52:13 <dons> hmm. I could get hold of a curses.h and try to program to that, but faster for you would be to get hold of ncurses somehow.
05:52:30 <dons> i'll put it in the todo list though
05:53:08 <joelr1> how do you map IO () over a list? fmap?
05:53:18 <phys_rules> dons: ok, cool ;)
05:53:21 <dons> mapM_, joelr1
05:53:28 <joelr1> i.e. to rewrite this
05:53:28 <joelr1>     do broadcast' event children
05:53:29 <joelr1>            where broadcast' _ [] = return ()
05:53:29 <joelr1>                  broadcast' ev ((_, q):xs) =
05:53:29 <joelr1>                      do atomically $ writeTChan q ev
05:53:30 <dons> @type Monad.mapM_
05:53:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
05:53:31 <joelr1>                         broadcast' ev xs
05:53:54 <joelr1> aha
05:54:04 <xerox> They guys neologism spoke of this morning (Singularity people) do use STM!
05:55:23 <neologism> what is stm?
05:55:46 <xerox> Software Transaction Memory
05:55:49 <xerox> @where STM
05:55:50 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
05:55:57 <neologism> ah
05:55:59 <xerox> Let me point you to the paper.  It's Just Great.
05:56:16 <int-e> xerox: but is it the right one?
05:56:55 <joelr1> @type Monad.fmap
05:56:56 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
05:57:03 <xerox> int-e: seems so, they talk about "you say that this bunch of code goes atomically, aaaand.."
06:20:04 <SamB> darcs doesn't seem to like House much...
06:34:17 <araujo> Good Morning Haskell!
06:34:38 <xerox> Howdy.
06:44:51 <phys_rules> hehe http://www.haskellopera.org/
06:45:19 <phys_rules> all the good keyword, free, house, haskell, libraries
06:45:20 <phys_rules> :))
07:50:29 <tbfg> hi
07:50:34 <xerox> Hello!
07:50:37 <xerox> Learning Haskell?
07:51:17 <tbfg> i have the following type: newtype WGraph a = WG [(a,[(a,Int)])]
07:51:28 <xerox> Okay.
07:51:28 <tbfg> who do i match it ?
07:51:46 <tbfg> func exp og ((gi,[]):gs)
07:51:56 <xerox> First, it's a list, so (x:xs) will give you the head and the tail respectively in x and in xs.
07:52:18 <tbfg> okay, exp and og are other parameters
07:52:27 <xerox> Then, the 'x' is a tuple.
07:52:32 <tbfg> it the ((gi,[]):gs) pattern
07:53:02 <xerox> So something like ((x,y):xs) will give you:  x :: a  and  y :: [(a,Int)].
07:53:37 <tbfg> xerox that's the plan
07:53:47 <xerox> ((x,ys):xs) sounds more idiomaticc, too.
07:54:02 <xerox> tbfg: good so far!
07:54:11 <tbfg> xerox hugs says this:
07:54:13 <tbfg> *** Term           : (gi,[]) : gs
07:54:13 <tbfg> *** Type           : [(a,[b])]
07:54:13 <tbfg> *** Does not match : WGraph c
07:54:29 <xerox> tbfg: did you wrap the whole thing in parens?
07:54:35 <xerox> Oh, no sorry.
07:54:53 <xerox> You have another constructor to pattern-match: WG
07:55:05 <tbfg> right, but i can't see where ?
07:55:13 <tbfg> i guess at [] ?
07:55:18 <xerox> That is, it's not only "((x,xs):ys)" but "WG ((x,xs):ys)"
07:55:35 <xerox> Like you do in  foo (Just x) = ...  for example.
07:56:52 <tbfg> xerox i already tried, thats what hugs says:
07:56:53 <tbfg> *** Term           : gs
07:56:53 <tbfg> *** Type           : [(a,[(a,Int)])]
07:56:53 <tbfg> *** Does not match : WGraph b
07:57:35 <tbfg> i guess that the [] causes the conflict
07:58:22 <xerox> Tbfg> :t foo
07:58:23 <xerox> foo :: WGraph a -> a
07:58:49 <xerox> I just loaded a 'Tbfg.hs' module in hugs containing:
07:58:50 <xerox> newtype WGraph a = WG [(a,[(a,Int)])]
07:58:50 <xerox> foo (WG ((x,xs):ys)) = x
07:59:15 <tbfg> xerox and what about this:
07:59:23 <tbfg> foo (WG ((x,[]):ys)) = x
07:59:25 <tbfg> ?
07:59:43 <xerox> It does work.
08:01:28 <tbfg> strange, this (WG ((gi,[]):gs)) does not work for me
08:01:57 <xerox> That sounds strange, maybe some context would help.
08:02:17 <tbfg> *searching the pastebin*
08:02:32 <xerox> @paste
08:02:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:02:36 <xerox> lisppaste2: url
08:02:37 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:02:44 <xerox> Use what it fits you better :-)
08:03:42 <lisppaste2> tbfg pasted "pattern match problem" at http://paste.lisp.org/display/14290
08:04:36 <xerox> Uh.
08:04:46 <tbfg> is it bad code ?
08:09:12 <samx> I've just made my first (almost) Haskell program - an othello/reversi game. Would anyone be willing to take a look at it, and give me some hints on how to make the code 'nicer', as it seems pretty damn ugly to me at least :-)  It can be found at http://www.pcuf.fi/~sam/Othello.hs
08:09:13 <xerox> tbfg: yes
08:09:26 <xerox> tbfg: it is "isWellformedW (WG []) = True"
08:09:39 <xerox> tbfg: and "isWellformedW (WG g) = .."
08:09:43 <xerox> Gotta run now.
08:11:32 <dMaus> hi, everyone
08:11:43 <xerox> Hello, dMaus.
08:14:26 <dMaus> i've decided to play with opengl a little. I've managed to render some simple scenes with lighting and now i want to apply textures
08:15:20 <jethr0> samx: is your board 1-dimensional?
08:16:32 <xerox> dMaus: and we want to see :-)
08:16:48 <samx> jethr0, an array of arrays, so 2-dimensional.. wasn't sure if haskell has direct 2d arrays
08:16:56 <jethr0> also, i think you could be "deriving Eq" for on Piece and do without instancing Eq.
08:17:01 <xerox> samx: yes it has
08:17:13 <xerox> samx: i.e. you could use (a,a) as Ix type.
08:18:13 <dMaus> i have to transmit texture data to opengl. I just want to draw something like chessboard from redbook. And i cant figure out how to create it in memory
08:18:43 <jethr0> that would make array access much more readable!
08:18:51 <samx> jethr0, hmm.. how do i derive something ? :-)
08:19:02 <samx> xerox, I'll try that
08:19:14 <jethr0> data T = V deriving Eq
08:19:47 <samx> jethr0, thx
08:20:40 <jethr0> also, if updateBoard took the board parameter as its last, you could do simpler concatenation...
08:20:56 <jethr0> updateBoard a b c d board
08:21:09 <xerox> dMaus: what type of data do you need?
08:23:08 <dMaus> bytes i think. I need to set them to 0 and 255 in chessboard pattern
08:23:21 <dMaus> simple in C :)
08:24:27 <jethr0> it may not be elegant, but you could do without the board[1..4] and simply construct the board "backwards"
08:24:46 <jethr0> updateBoard a b c d $ updateBoard a b c d $ initialBoard
08:25:00 <xerox> dMaus: check for Ptr, peek, and poke.
08:25:09 <beelsebob_> lo again jethr0 - still up?
08:25:14 <dMaus> i can allocate the memory with Foreign.Marshal.Array.mallocArray. but i'll get a one dimensional array
08:25:26 <jethr0> OR, you create the array with the four stones already on it.
08:25:33 <jethr0> yup, beelsebob_
08:25:57 <beelsebob_> good going
08:27:18 <jethr0> hehe
08:28:16 <jethr0> samx: also, "let" can take several declaration, even when they refer to each other...
08:28:22 <jethr0> let a = 5
08:28:29 <dMaus> and i need a two dimensional one to operate with texels comfortable. 
08:28:30 <jethr0>     b = a + 1
08:28:32 * xerox prefers where.
08:28:53 * jethr0 too, but there's times for let as well ;-)
08:28:55 <phys_rules> let is goed ook ;)
08:29:14 <jethr0> @babel nl en let is goed ook
08:29:16 <lambdabot>  pay attention is well also
08:29:26 <jethr0> ;-)
08:29:35 <phys_rules> LOL :)
08:30:10 <phys_rules> @babel nl dit is niet goed
08:30:10 <lambdabot> Module "babel" produced error: Error: Language dit not supported
08:30:25 <phys_rules> @babel nl en dit is niet goed
08:30:26 <lambdabot>  this is not well
08:30:41 <xerox> @babel fi en humpa
08:30:41 <lambdabot> Module "babel" produced error: Error: Language fi not supported
08:32:15 <phys_rules> @babel nl en let op
08:32:16 <lambdabot>  pay attention to
08:32:27 <phys_rules> lamdabot is fun =)
08:33:00 <jethr0> samx: this one i don't understand: "Square (Just p) | p == piece -> let (Square s) = getSquare board y x in s /= Nothing"
08:33:32 <jethr0> @babel ja en watasha wa nihongo no gakuse des
08:33:33 <lambdabot>  Watasha wa nihongo no gakuse des
08:33:44 <xerox> Err.
08:33:48 <samx> jethr0, I didn't want to do another instance of 'Eq'. I think that would be unnecessary now with the 'deriving'
08:33:52 <jethr0> hmm, that worked surprisingly badly
08:34:19 <sh10151> i think babelfish works on Japanese
08:34:22 <sh10151> not romanju
08:34:25 <jethr0> but you wouldn't have to do the "instance Eq Piece where" part!
08:34:25 <sh10151> romanji, even
08:34:32 <jethr0> sure?
08:34:32 <sh10151> I could be wrong though
08:34:53 <dMaus> xerox: is there a way to get a pointer to data in 2-dimensional array? 
08:34:53 <sh10151> the use case is web page translation
08:34:59 <sh10151> no one writes web pages in Romanji
08:35:02 <jethr0> @babel en ja i am a student of japanese.
08:35:03 <samx> jethr0, yes. I got rid of it, but prior to few moments ago, I didn't know how to derive anything :-)
08:35:04 <lambdabot>  can't parse this language
08:35:12 <jethr0> ;-)
08:35:29 <jethr0> samx: this one i don't understand: "Square (Just p) | p == piece -> let (Square s) = getSquare board y x in s /= Nothing"
08:36:00 <samx> jethr0, which part of it do you not understand?
08:36:27 <jethr0> hmm
08:36:39 <jethr0> i don't get the logic, but never mind
08:37:14 <jethr0> all in all it looks stunningly similar to a java version of othello i did... maybe it's just the simplicity of the game asserting itself.
08:37:51 <jethr0> but i'm sure there can be some lazification done to it. i can't see it yet, though ;-)
08:41:42 <tbfg> xerox still there?
08:41:54 <tbfg> xerox for some reason the [] can't be matched?
08:43:37 <jethr0> samx: maybe renaming "piece" to "color" ;-)
08:45:43 <xerox> tbfg: it is (WG []) not [].
08:47:13 <tbfg> *** Expression     : WG ((gi,WG []) : gs)
08:47:14 <tbfg> *** Term           : (gi,WG []) : gs
08:47:14 <tbfg> *** Type           : [(a,WGraph b)]
08:47:28 <tbfg> can't i tell him that this emtpy list ist of tpye [a] ?
08:47:31 <jethr0> samx: in some places you might consider using more list oriented functions...
08:47:41 <tbfg> hugs assumes [b] and that doe not match [a]
08:48:26 <xerox> tbfg: in the first function!!!!!!!
08:48:45 <jethr0> like in countPieces: you could flatten the board (i.e. collect all stones of the board into a list)
08:48:58 <tbfg> xerox i fixed that
08:49:20 <jethr0> and then do: length . filter (==piece) . catMaybes
08:49:34 <jethr0> length . (filter (==piece)) . catMaybes
08:50:29 <jethr0> samx: with a 2-dimensional array that would be: length . (filter (==piece)) . catMaybes . (elems board)
08:50:34 <samx> jethr0, hmm.. maybe.. i'm still stuggling here trying to get this thing to use 2d arrays :-)
08:50:35 <jethr0> or something like that
08:50:59 <lisppaste2> tbfg annotated #14290 with "pattern match problem 2" at http://paste.lisp.org/display/14290#1
08:51:17 <samx> i've got everything else 2d now, other than 'showBoard'
08:51:21 <tbfg> xerox i've just updated the code snipplet
08:52:03 <tbfg> xerox and its the [] in the line i marked
08:52:07 <kala> what is the correct way of defining a record in haskell? data, type, newtype? 
08:52:18 <araujo> data
08:52:38 <tbfg> xerox deep buried in the pattern
08:52:54 <kala> data AttackNode = MakeAttackNode (String, Int) ? 
08:52:55 <tbfg> xerox i allready tried something line ([]::[a]) but hugs does not support this
08:54:06 <kala> well, then, what about this line: "showAttackNode MakeAttackNode (name, number) = "(" ++ name ++ " - " ++ show number ++ ")"" The hugs says that "Constructor "MakeAttackNode" must have exactly 1 argument in pattern"
08:56:36 <jethr0> samx: basically you could have showBoard just print the "elems" interspersed with newlines at the right points
08:59:52 <jethr0> concatMap (\((x,y), v) -> if x `rem`8 == 0 then [x,'\n'] else [x]) (assoc board)
08:59:55 <jethr0> or something of the kind
09:00:59 <jethr0> no, doesn't match type-wise. but something of this gist, maybe
09:07:35 <samx> ok.. i got it working with a couple of list comprehensions etc.. I think I'll take a break now before I get a headache :-) Thanks for all the suggestions jethr0
09:09:50 <jethr0> np, hope i haven't been a nuissance ;-)
09:10:27 <jethr0> @pl fn out inp = fn (out++[take 2 inp]) (drop 2 inp)
09:10:28 <lambdabot> fn = fix (flip flip (drop 2) . (ap .) . (. ((. (return . take 2)) . (++)))
09:10:28 <lambdabot> . (.))
09:10:52 <jethr0> anyone see a "foldr", foldl, fmap, etc in this??
09:11:55 * musasabi sees many points why it should not be used
09:12:37 * jethr0 wants to do:  [1,2,3,4,5,6]   =>   [[1,2], [3,4], [5,6]]
09:12:47 <jethr0> we had this problem yesterday, or day before, but i can't rememeber
09:12:51 <jethr0> mber*
09:13:51 <astrolabe> maybe use splitAt?
09:14:04 <astrolabe> @type splitAt
09:14:05 <lambdabot> forall a. Int -> [a] -> ([a], [a])
09:14:06 <jethr0> yes, but recursively...
09:14:15 <astrolabe> yeah
09:14:25 <jethr0> i can do it with my own function, but i'm looking for the cool "fold" solution ;-)
09:15:02 <Pupeno> Hello.
09:15:12 <astrolabe> hi Pupeno
09:16:02 <sieni> lambdabot: @eval map (\x -> [2*x-1,2*x]) [1..10]
09:16:03 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
09:16:12 <jethr0> > let fn [] = []; fn xs = let (x,y) = splitAt 2 xs in x:fn y in fn [1,2,3,4,5,6]
09:16:14 <lambdabot> [[1,2],[3,4],[5,6]]
09:16:16 <sieni> oops ;-)
09:16:41 <jethr0> sieni: it's not for integers in the end, but general lists ;-)
09:17:12 <jethr0> but one can always do the zipping trick
09:19:03 <jethr0> any ideas how to create [1,1,1,2,2,2,3,3,3]??
09:19:54 <jethr0> @type ap
09:19:56 <lambdabot> Not in scope: `ap'
09:20:00 <jethr0> @index ap
09:20:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
09:20:01 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
09:20:01 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
09:20:02 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
09:20:07 <jethr0> @type Control.Monad.ap
09:20:08 <Pupeno> I have here http://pupeno.com/miscellaneous/temporary/ four screnshots of my emacs with the same functions, all of them idently incorrecly by haskell-mode (the if/then/else it seems). Does this happen so someone else or is my config wrong ? The last screnshot show how haskell-made would indent it if I don't help it.
09:20:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
09:20:34 <sieni> lambdabot: @eval foldl (++) [] $ map (\x -> [x,x,x]) [1..3]
09:20:36 <lambdabot> [1,1,1,2,2,2,3,3,3]
09:20:59 <jethr0> pupeno, i don't use emacs, but i heard others have problems with haskell mode before...
09:21:17 <Pupeno> jethr0: what do you use to edit haskell sources ?
09:21:19 <pesco> > concatMap (replicate 3) [1..3]
09:21:20 <lambdabot> [1,1,1,2,2,2,3,3,3]
09:21:22 <jethr0> vim
09:21:29 <jethr0> cool, pesco
09:21:43 <pesco> Thanks.
09:23:31 <xerox> Something along this lines:
09:23:32 <xerox> > (\n ys -> take ((+1) . (`div` n) . List.genericLength . snd $ ys) $ map (fst) $ iterate (\(x,xs) -> splitAt n xs) ys) 2 ([],[1..6])
09:23:33 <lambdabot> [[],[1,2],[3,4],[5,6]]
09:23:36 <xerox> I'm too sleepy to clean it.
09:23:56 <jethr0> > let fn [] = []; fn xs = let (x,y) = splitAt 2 xs in x:fn y in fn [1,2,3,4,5,6]
09:23:58 <lambdabot> [[1,2],[3,4],[5,6]]
09:24:27 <jethr0> ;}
09:24:48 <jethr0> xerox, you should get some sleep sometime...
09:25:16 <sieni> lambdabot: @eval let foo [] = []; foo x = [[head x, head(tail x)]] ++ foo (tail (tail x)) in foo [1..6]
09:25:16 <jethr0> > zip [1,2,3,4,5,6] (concatMap (replicate 2) [1..3])
09:25:17 <lambdabot> [[1,2],[3,4],[5,6]]
09:25:18 <lambdabot> [(1,1),(2,1),(3,2),(4,2),(5,3),(6,3)]
09:25:35 <sieni> ugly but works :P
09:25:38 <jethr0> > group $ zip (concatMap (replicate 2) [1..3]) [1,2,3,4,5,6] 
09:25:39 <lambdabot> [[(1,1)],[(1,2)],[(2,3)],[(2,4)],[(3,5)],[(3,6)]]
09:25:48 <jethr0> > groupBy fst $ zip (concatMap (replicate 2) [1..3]) [1,2,3,4,5,6] 
09:25:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1, b)
09:25:49 <lambdabot>   Expected type: (t -> t1, b) -> (t -> t1, b) -> Bool
09:25:49 <lambdabot>   Inferred type: (t -> t1, b) -> t -> t1
09:26:27 <jethr0> :P, sieni
09:26:32 <xerox> ah-ha!
09:26:33 <xerox> > (\n ys -> take ((`div` n) . (uncurry (+)) . (length *** length) $ ys) $ map (fst) $ iterate (\(x,xs) -> splitAt n xs) ys) 2 (splitAt 2 [1..6])
09:26:35 <lambdabot> [[1,2],[3,4],[5,6]]
09:26:42 <xerox> More polishing in the workings.
09:27:17 <jethr0> > groupBy (\x y -> fst x == fst y) $ zip (concatMap (replicate 2) [1..3]) [1,2,3,4,5,6] 
09:27:18 <lambdabot> [[(1,1),(1,2)],[(2,3),(2,4)],[(3,5),(3,6)]]
09:27:26 <astrolabe> Why does the '***' not suprise me?
09:27:34 <xerox> Hah.
09:27:54 <jethr0> @pl \x y -> fst x == fst y
09:27:55 <lambdabot> (. fst) . (==) . fst
09:27:58 * xerox is happy to have introduced Arrow syntax in #haskell seamlessy with his snippets.
09:28:02 <jethr0> *grrr*
09:28:29 <xerox> jethr0: (uncurry (==)) . (fst &&& fst)
09:28:44 * jethr0 finds that xerox does a good job of subconciously introducting arrow to the channel
09:28:44 <xerox> Hm.
09:28:52 <jethr0> or _not_ so discreetely ;-)
09:29:32 <xerox> > let jethr0 = curry $ (uncurry (==)) . (fst *** fst) in jethr0 (1,undefined) (1,undefined)
09:29:34 <lambdabot> True
09:29:43 <jethr0> great
09:29:51 <tromp> Only the fool would take trouble to verify that this sentence was composed of ten a's, three b's, four c's, four d's, forty-six e's, sixteen f's, four g's, thirteen h's, fifteen i's, two k's, nine l's, four m's, twenty-five n's, twenty-four o's. five p's, sixteen r's, forty-one s's, thirty-seven t's, ten u's, eight v's, eight w's, four x's, eleven y's, twenty-seven commas, twenty-three apostrophes, seven hyphens and, last but not least, a single !
09:30:28 <astrolabe> tromp: wow
09:30:39 <jethr0> group $ sort "Only the fool would take trouble to verify that this sentence was composed of ten a's, three b's, four c's, four d's, forty-six e's, sixteen f's, four g's, thirteen h's, fifteen i's, two k's, nine l's, four m's, twenty-five n's, twenty-four o's. five p's, sixteen r's, forty-one s's, thirty-seven t's, ten u's, eight v's, eight w's, four x's, eleven y's, twenty-seven commas, twenty-three apostrophes, seven hyphens and, last but no
09:30:39 <jethr0> t least, a single !"
09:30:45 <tromp> should be easy to check in haskell:)
09:30:51 <joelr1> dons: ping
09:30:59 <jethr0> > group $ sort "Only the fool would take trouble to verify that this sentence was composed of ten a's, three b's, four c's, four d's, forty-six e's, sixteen f's, four g's, thirteen h's, fifteen i's, two k's, nine l's, four m's, twenty-five n's, twenty-four o's. five p's, sixteen r's, forty-one s's, thirty-seven t's, ten u's, eight v's, eight w's, four x's, eleven y's, twenty-seven commas, twenty-three apostrophes, seven hyphens and, last but 
09:31:00 <jethr0> not least, a single !"
09:31:00 <lambdabot>  lexical error in string/character literal
09:31:14 <joelr1> anybody with good memory profiling experience?
09:31:21 <jethr0> great, lambda doesn't like the quotes.
09:31:32 * xerox does..
09:31:50 <joelr1> xerox: can you take a look at http://wagerlabs.com/randomplay.ps
09:32:01 <joelr1> am i color-blind or is goToTable eating up a lot of memory?
09:32:24 <astrolabe> > sort "hello"
09:32:25 <lambdabot> "ehllo"
09:32:56 <tbfg> xerox won't attract your hate, but could you have a look at http://paste.lisp.org/display/14290#1 ?
09:33:11 <xerox> What are hypens?
09:33:16 <xerox> tbfg: just some minutes.
09:33:18 <tromp> -
09:33:27 <joelr1> xerox: are you asking me?
09:33:31 <joelr1> about hypens
09:33:48 <tromp> i wonder how to make a section of the pair function (,)
09:33:53 <jethr0> [(' ',73),('!',1),('\'',23),(',',26),('-',7),('.',1),('O',1),('a',10),('b',3),('c',4),('d',4),('e',46),('f',16),('g',4),('h',13),('i',15),('k',2),('l',9),('m',4),('n',25),('o',23),('p',5),('r',16),('s',41),('t',38),('u',10),('v',8),('w',8),('x',4),('y',11)]
09:34:37 <tromp> shld be 27 commas!
09:34:54 <jethr0> well, must have mispasted one
09:35:15 <astrolabe> tromp: what do you mean by section of the ...?
09:35:18 <jethr0> map (head Control.Arrow.&&& length) $ List.group $ List.sort
09:35:21 <tromp> and 24 o's
09:35:28 <jethr0> xerox, just for you an arrow
09:35:40 <tromp> you can express (\x->x+1) as (+1)
09:35:55 <int-e> > (,) 1 2
09:35:57 <tromp> i want to do the same for (\x->(x,1))
09:35:57 <lambdabot> (1,2)
09:36:18 <int-e> hmm. flip (,) 1  *shrugs*
09:36:26 <xerox> jethr0: oh yeah.
09:36:38 <int-e> > (`(,)`1) 2
09:36:38 <lambdabot>  parse error on input `('
09:36:39 <xerox> jethr0: you won!
09:36:41 <astrolabe> @pl \x -> (x,1)
09:36:41 <lambdabot> flip (,) 1
09:36:42 <xerox> I was trying to do the same
09:36:45 * xerox resigns.
09:36:47 <jethr0> *wooohooo*
09:36:49 <xerox> @karma+ jethr0
09:36:49 <lambdabot> jethr0's karma raised to 1.
09:36:54 <tromp> ah, ((,)1) works
09:36:55 <xerox> Silly me.
09:37:01 <tromp> cool
09:37:02 <jethr0> thx
09:37:03 <xerox> I was still using Monads.
09:37:04 <int-e> ((,)1) 3
09:37:09 <int-e> > ((,)1) 3
09:37:10 <lambdabot> (1,3)
09:37:16 * jethr0 reinstates xerox as king of the arrows
09:37:18 <xerox> Way old school.
09:37:23 <int-e> tromp: it's not what you wanted I think
09:37:40 <xerox> jethr0: you rock, no matter, time to pension for me.
09:37:46 <tromp> oops, you're right. it's not a section
09:37:52 <jethr0> you mean bed, i hope
09:38:01 <jethr0> what was your idea with monads?
09:38:15 <tromp> maybe (`(,)`1)
09:38:22 <xerox> alphabet >>= check tromp
09:38:53 <jethr0> tromp, i hope <tick><paren> doesn't make any sense...
09:39:06 <jethr0> > (,1) 2
09:39:06 <lambdabot>  parse error on input `1'
09:39:13 <jethr0> grr
09:39:30 <jethr0> @type (,)
09:39:31 <lambdabot> forall b a. a -> b -> (a, b)
09:39:38 <jethr0> @type `(,)`
09:39:39 <lambdabot> parse error on input ``'
09:39:43 <jethr0> @type ,
09:39:44 <lambdabot> parse error on input `,'
09:39:59 <jethr0> @type (,) 2
09:40:00 <lambdabot> forall a b. (Num a) => b -> (a, b)
09:40:09 <jethr0> ((,) 2) 1
09:40:10 <jethr0> > ((,) 2) 1
09:40:11 <lambdabot> (2,1)
09:40:49 <tromp> how to turn (,) into an infix operator?
09:40:55 <xerox> Pray
09:41:18 <jethr0> tromp, why won't ((,) 2) do?
09:41:43 <tromp> because it's (\y->(2,y))
09:41:52 <tromp> i want (\x->(x,2))
09:41:52 <jethr0> tromp, why won't (2 (,)) do?
09:41:58 <jethr0> > (2 (,))
09:41:59 <lambdabot>  add an instance declaration for (Num ((a -> b -> (a, b)) -> a1))
09:41:59 <lambdabot>   In the definition of `myzdmxsx': myzdmxsx = (2 (,))
09:41:59 <lambdabot>   In the definition of `v':
09:42:02 <jethr0> > (2 (,)) 3
09:42:03 <lambdabot>   add an instance declaration for (Num ((a -> b -> (a, b)) -> t -> a1))
09:42:03 <lambdabot>   In the definition of `jmausrdx': jmausrdx = (2 (,)) 3
09:42:03 <lambdabot>   In the definition of `v':
09:42:09 <tromp> because (,) is not an infix operator
09:42:10 * jethr0 is an idiot
09:43:12 <int-e> > let (<>) = (,) in (<> 1) 2
09:43:12 <jethr0> ((\x -> 2) Control.Arrow.&&& id)
09:43:13 <lambdabot> (2,1)
09:43:19 <astrolabe> tromp: why wont (flip (,) 2) do?
09:43:24 <jethr0> > ((\x -> 2) Control.Arrow.&&& id) 3
09:43:25 <lambdabot> (2,3)
09:43:35 <tromp> it works, but i was hoping for something prettier
09:43:39 <xerox> jethr0: that's const 2
09:43:39 <jethr0> xerox, did you see that?
09:43:40 <tromp> using section syntax
09:43:44 <jethr0> thx
09:44:03 <astrolabe> hmmm
09:44:06 <tromp> i just need to express (,) as infix operator
09:44:14 <astrolabe> @type (,)
09:44:15 <lambdabot> forall b a. a -> b -> (a, b)
09:44:16 * jethr0 will from this day forth use only the arrows
09:44:24 <xerox> let f = (,) in (2 `f`) 3
09:44:28 <xerox> > let f = (,) in (2 `f`) 3
09:44:30 <lambdabot> (2,3)
09:44:48 <jethr0> weird
09:44:51 <xerox> jethr0: we'll spread.
09:45:13 <jethr0> but i'll have to learn at _least_ one more than "&&&"
09:45:42 <xerox> jethr0: go for )
09:45:46 <xerox> (***) i mean.
09:46:26 <xerox> > let jethr0 = (+1) *** (subtract 1) in jethr0 (-1,1)
09:46:27 <lambdabot> (0,0)
09:46:36 <xerox> The last time calling them with your nick worked ;-)
09:47:12 <jethr0> hehe
09:48:04 <tromp> how did you define your letter count function, jethr0?
09:48:17 <jethr0> > ((+1) Control.Arrow.&&& ((+2) Control.Arrow.&&& (+3))) 4
09:48:18 <lambdabot> (5,(6,7))
09:48:34 <xerox> jethr0: Arrow is imported in >
09:48:34 <jethr0> tromp: map (head Control.Arrow.&&& length) $ List.group $ List.sort
09:48:48 <xerox> jethr0: you need to specify "Control.Arrow" only in @type
09:48:55 <jethr0> i know, but i have to try not to spam the channel all the time, so i test it in ghci
09:49:05 <xerox> map (head &&& length) . group . sort
09:49:22 <jethr0> *GRRR*
09:49:36 <jethr0> > Prelude.odd 2
09:49:37 <lambdabot> False
09:49:41 <xerox> jethr0: :m + Control.Arrow
09:49:45 <xerox> :m + Data.List
09:49:56 <jethr0> thx
09:50:46 <ndm> jethr0: open a private conversation with lambdabot to try it out
09:50:48 <jethr0> xerox, the shorter version above is actually really pretty, for what it is doing
09:51:06 <xerox> ...it's just yours.
09:51:23 <jethr0> ndm, thx, but /msg ing annoys me. i think i'll try to tweak xchat into accepting some leading character as private identifier
09:51:36 <jethr0> like "$lambdabot" or so
09:51:53 <kala> you could open a window on xchat?
09:52:14 <jethr0> ahh, you mean a whole session. well, that would be quite the idea too ;-))
09:52:30 <jethr0> kala, haven't checked, but i rather meant single messages
09:53:27 <tromp> at least the dutch version checks out
09:53:29 <xerox> I'm literally addicted to IRC.
09:53:32 <pesco> Hack up an xchat plugin to accept \> as shorthand for \msg lambdabot :)
09:53:41 <jethr0> what's the irc command for private conversation?
09:53:43 <tromp> "Dit pangram bevat vijf a's, twee b's, twee c's, drie d's, zesenveertig e's. vijf f's, vier g's, twee h's, vijftien i's, vier j's, een k, twee l's, twee m's, zeventien n's, een o, twee p's, een q, zeven r's, vierentwintig s's, zestien t's, een u, elf v's, acht w's, een x, een y en zes z's."
09:53:47 <pesco> jethr0: /query
09:54:08 <jethr0> well, $lambdabot would be quite good enough. i am not _that_ lazy a typist
09:54:26 <xerox> let jethr0 = map (head &&& length) . group . sort; in jethr0 ""Dit pangram bevat vijf a's, twee b's, twee c's, drie d's, zesenveertig e's. vijf f's, vier g's, twee h's, vijftien i's, vier j's, een k, twee l's, twee m's, zeventien n's, een o, twee p's, een q, zeven r's, vierentwintig s's, zestien t's, een u, elf v's, acht w's, een x, een y en zes z's."
09:54:29 <pesco> jethr0: No? Why not?
09:54:42 <jethr0> i like typing
09:54:45 <xerox> > let jethr0 = map (head &&& length) . group . sort; in jethr0 "Dit pangram bevat vijf a's, twee b's, twee c's, drie d's, zesenveertig e's. vijf f's, vier g's, twee h's, vijftien i's, vier j's, een k, twee l's, twee m's, zeventien n's, een o, twee p's, een q, zeven r's, vierentwintig s's, zestien t's, een u, elf v's, acht w's, een x, een y en zes z's."
09:54:47 <lambdabot> [(' ',55),('\'',20),(',',23),('.',2),('D',1),('a',5),('b',2),('c',2),('d',
09:54:47 <lambdabot> 2),('e',46),('f',5),('g',4),('h',2),('i',15),('j',4),('k',1),('l',2),('m',
09:54:47 <lambdabot> 2),('n',17),('o',1),('p',2),('q',1),('r',7),('s',24),('t',16),('u',1),('v'
09:54:47 <lambdabot> ,11),('w',8),('x',1),('y',1),('z',6)]
09:55:01 <jethr0> could you stop having variables bear my name. my whole screen is highlighted!
09:55:15 <xerox> It's for credit :-)
09:55:18 <jethr0> @babel nl en "Dit pangram bevat vijf a's, twee b's, twee c's, drie d's, zesenveertig e's. vijf f's, vier g's, twee h's, vijftien i's, vier j's, een k, twee l's, twee m's, zeventien n's, een o, twee p's, een q, zeven r's, vierentwintig s's, zestien t's, een u, elf v's, acht w's, een x, een y en zes z's."
09:55:20 <lambdabot>  "this pan gramme contains five a, two b's, two c's, three d's, forty-six
09:55:20 <lambdabot> e five f's, four g's, two h's, fifteen i's, four j's, one k, two l's, two
09:55:20 <lambdabot> m's, seventeen n's, one o, two p's, one q, seven r's, twenty-four s's,
09:55:20 <lambdabot> sixteen t's, you, eleven v's, eight w's, x, one y and six z's."
09:56:47 <pesco> een u = you?
09:57:14 <jethr0> > map (head &&& length) . filter (isAlpha . head) . group . sort $ "Dit pangram bevat vijf a's, twee b's, twee c's, drie d's, zesenveertig e's. vijf f's, vier g's, twee h's, vijftien i's, vier j's, een k, twee l's, twee m's, zeventien n's, een o, twee p's, een q, zeven r's, vierentwintig s's, zestien t's, een u, elf v's, acht w's, een x, een y en zes z's."
09:57:15 <lambdabot> [('D',1),('a',5),('b',2),('c',2),('d',2),('e',46),('f',5),('g',4),('h',2),
09:57:15 <lambdabot> ('i',15),('j',4),('k',1),('l',2),('m',2),('n',17),('o',1),('p',2),('q',1),
09:57:15 <lambdabot> ('r',7),('s',24),('t',16),('u',1),('v',11),('w',8),('x',1),('y',1),('z',6)
09:57:15 <lambdabot> ]
09:57:55 <jethr0> pesco: it's babel, what do you expect??
09:58:07 <pesco> I'm not expecting, I'm wondering!
09:58:55 <jethr0> most likely he dropped "een" and interpreted "u" as 1337-speak
09:59:20 <pesco> @babel en nl you
09:59:20 <jethr0> @babel nl en en u ne
09:59:21 <lambdabot>  u
09:59:22 <lambdabot>  and you ne
09:59:25 <tromp> "een u" means "one u"
09:59:37 <jethr0> i understand
09:59:59 <jethr0> dutch is _all_ that different from german ;-)
10:00:31 <moonlite> are there any good function for checking if a file exist from a FilePath variable?
10:00:38 <jethr0> tromp, did you translate/count either of these riddles by hand?
10:00:50 <jethr0> System.Posix.File
10:00:51 <tromp> nah, too lazy
10:00:51 <phys_rules> tromp: twei je ? =)
10:01:08 <jethr0> Files*
10:01:23 <moonlite> jethr0: thx
10:01:37 <jethr0> wait, i'll look for a function
10:02:46 <jethr0> System.Posix.File.getFileStatus
10:02:51 <jethr0> @type System.Posix.File.getFileStatus
10:02:52 <lambdabot> Couldn't find qualified module.
10:02:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
10:02:52 <lambdabot> \\)?
10:02:59 <jethr0> @type System.Posix.Files.getFileStatus
10:03:00 <lambdabot> FilePath -> IO System.Posix.Files.FileStatus
10:03:35 <jethr0> .fileExist
10:11:02 <jethr0> @seen
10:11:02 <lambdabot> Lately, I have seen jethr0.
10:11:29 <jethr0> @serene
10:11:30 <lambdabot> Lately, I have seen jethr0.
10:25:39 <tromp> ghci is weird...
10:25:52 <tromp> @type List.sort
10:25:53 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:26:03 <tromp> let srt = sort
10:26:11 <tromp> :t srt
10:26:11 <tromp> srt :: [Integer] -> [Integer]
10:26:28 <jethr0> huh?
10:26:43 <kosmikus> nothing to do with ghci; monomorphism restriction
10:26:46 <jethr0> @type let srt = sort in srt
10:26:47 <lambdabot> Not in scope: `sort'
10:26:54 <jethr0> @type let srt = List.sort in srt
10:26:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:27:22 <tromp> how do i get srt to be polymorphic?
10:27:31 <tromp> ah
10:28:14 <araujo> jethr0, found your way to get the function? :-]
10:28:21 <jethr0> which one?
10:28:43 <araujo> > let f [] = []; f (x:[]) = (:[]) [x]; f (x:y:xs) = [x, y] : f xs in f [1,2,3,4]
10:28:44 <lambdabot> [[1,2],[3,4]]
10:28:48 <araujo> That one.
10:29:21 <jethr0> yes, i had one similar to that.
10:29:36 <jethr0> but i still think that there _exists_ a really short fold-based one...
10:29:36 <xerox> araujo: that's not parametric on the length of the stubs
10:30:11 <xerox> It's more an {iterate,fix}-based one.
10:30:18 <jethr0> > let f [] = []; f xs = let (a, b) = splitAt 2 xs in a:f b in f [1..6]
10:30:19 <lambdabot> [[1,2],[3,4],[5,6]]
10:30:45 <araujo> jethr0, i see what you mean
10:30:49 <araujo> mmm...
10:31:16 <jethr0> i mean, written in an indented fashion this solution is pretty ok. but most likely there is one like:
10:31:37 <jethr0> ((foldr .) . (splitAt 2)) or so
10:33:04 <araujo> jethr0, oh, but you always wanna split at 2?
10:33:14 <xerox> OK.
10:33:16 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 3 [1..6]
10:33:18 <lambdabot> [[1,2,3],[4,5,6]]
10:33:21 <tromp> what's the function to map to lowercase?
10:33:23 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 2 [1..6]
10:33:25 <lambdabot> [[1,2],[3,4],[5,6]]
10:33:59 <araujo> tromp, map toLower 
10:34:12 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (splitAt n . snd) (splitAt n xs) in f 2 [1..6]
10:34:13 <lambdabot> [[1,2],[3,4],[5,6]]
10:34:14 <tromp> ah yes, just found it too:)
10:34:17 <xerox> Shorter.
10:34:29 <araujo> > map toLower "SMALL HASKELL"
10:34:30 <lambdabot> "small haskell"
10:34:49 <jethr0> no, i wanna split at N
10:34:57 <xerox> ?
10:35:28 <jethr0> araujo: no, i wanna split at N
10:35:43 <xerox> Do you like it?
10:36:06 <araujo> Oh, cmon, this is shorter
10:36:09 <araujo> > (\(a,b) -> [a, b]) $ splitAt 2 [1,2,3,4]
10:36:10 <lambdabot> [[1,2],[3,4]]
10:36:31 <araujo> i see
10:36:57 <araujo> > (\(a,b) -> [a, b]) $ splitAt 3 [1,2,3,4]
10:36:58 <lambdabot> [[1,2,3],[4]]
10:37:02 <araujo> There you have it 
10:37:12 <xerox> I don't think so.
10:37:13 <jethr0> hehe
10:37:18 <araujo> haha
10:37:21 <xerox> > (\(a,b) -> [a, b]) $ splitAt 3 [1..6]
10:37:22 <lambdabot> [[1,2,3],[4,5,6]]
10:37:24 <xerox> BUT
10:37:27 <xerox> > (\(a,b) -> [a, b]) $ splitAt 2 [1..6]
10:37:28 <lambdabot> [[1,2],[3,4,5,6]]
10:37:36 <sh10151> haskell golf
10:37:42 <xerox> While:
10:37:44 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 2 [1..6]
10:37:45 <lambdabot> [[1,2],[3,4],[5,6]]
10:37:57 <araujo> oh, i see :-P
10:38:40 <araujo> xerox, at 3 what does it get?
10:38:48 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 3 [1..6]
10:38:49 <lambdabot> [[1,2,3],[4,5,6]]
10:39:33 <xerox> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 9 [1..27]
10:39:34 <lambdabot> [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,
10:39:34 <lambdabot> 26,27]]
10:42:10 <araujo>  > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 4 [1..6]
10:42:27 <araujo> > let f n xs = take (length xs `div` n) $ map (fst) $ iterate (\(_,xs) -> splitAt n xs) (splitAt n xs) in f 4 [1..6]
10:42:28 <lambdabot> [[1,2,3,4]]
10:42:31 <pesco> @type unfold
10:42:31 <pesco> @type unfoldr
10:42:31 <pesco> bah
10:42:31 <lambdabot> Not in scope: `unfold'
10:42:32 <lambdabot> Not in scope: `unfoldr'
10:42:49 <xerox> iterate (splitAt n . snd) -- sounds better
10:43:03 <pesco> > let stop x y = if x==y then Nothing else Just x in unfoldr (stop ([],[]) . splitAt 2) [1..4]
10:43:04 <lambdabot> [[]]
10:43:09 <pesco> Oh no, did lambdabot die?
10:43:14 <xerox> No :-)
10:43:21 <pesco>  > let stop x y = if x==y then Nothing else Just x in unfoldr (stop ([],[]) . splitAt 2) [1..4]
10:43:33 <xerox> Whitespace.
10:44:06 <Korollary> it did output "[[]]"
10:46:53 <moonlite> are there any good regular expression-implementations for haskell?
10:47:12 <pesco> Define good.
10:47:17 <moonlite> :)
10:47:20 <xerox> pesco: define evil.
10:48:04 <moonlite> i wan't something that works and is easy for me to use (ie only download a file.hs-module)
10:48:16 <xerox> Let me..
10:48:26 <xerox> @hoogle RegExp
10:48:27 <lambdabot> No matches found
10:48:30 <xerox> I don't recall.
10:48:40 <pesco> moonlite: Check my website: http://www.scannedinavian.org/~pesco/
10:48:59 <pesco> There's Pesco.Regex, which could be what you want.
10:49:09 <moonlite> oh neat
10:49:17 <xerox> Dong.
10:49:21 <pesco> John Meacham has one also, at http://repetae.net/~john/, IIRC.
10:49:23 <xerox> There is a standard one too.
10:49:24 <moonlite> scannedinavian.org seems to be down though
10:49:25 <xerox> @docs
10:49:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:49:30 <pesco> Ah, fuck, right.
10:49:46 <xerox> @docs Text.Regex
10:49:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
10:49:51 <xerox> AH.
10:51:04 <pesco> moonlite: If you don't like bare Text.Regex (like me) you can also apt-get install libghc6-missingh-dev which contains Pesco.Regex also.
10:51:27 <pesco> I think under a different name though, Text.Regex.Pesco, I think.
10:53:35 <moonlite> oh neat
10:58:19 <jethr0> > let f n xs [] = [xs]; f n xs (y:ys) = if length xs == n then xs : f n [y] ys else f n (xs++[y]) ys in f 2 [] [1..6]
10:58:20 <lambdabot> [[1,2],[3,4],[5,6]]
10:58:23 <jethr0> oldschool
11:00:06 <jethr0> @pl f n xs (y:ys) = if length xs == n then xs : f n [y] ys else f n (xs++[y]) ys
11:00:22 <lambdabot> f = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip .
11:00:22 <lambdabot> ((.) .)) .) . ap (ap . (liftM2 (liftM2 ap) .) . ap (ap . (((.) . (.) . if'
11:00:22 <lambdabot> ) .) . (. length) . (==)) . (flip ((.) . (.) . (:)) .) . flip flip return
11:00:22 <lambdabot> . ((.) .)) (flip flip ((. return) . (++)) . (((.) . (.)) .)))
11:00:26 <xerox> crunch crunch crunch
11:00:26 <jethr0> ups
11:00:35 <xerox> You see, fix, I told you!
11:00:53 <jethr0> yes, i think this version fits better in the style of my framework...
11:01:33 <jethr0> what's going on with "(((.) . (.)) .)))"
11:01:39 <jethr0> @type (((.) . (.)) .)))
11:01:42 <lambdabot> parse error on input `)'
11:01:55 <xerox> (.) . (.) is for \f g x y -> f (g x y)
11:01:55 <jethr0> @type (((.) . (.)) .))
11:01:57 <lambdabot> parse error on input `)'
11:02:04 <xerox> @pl \f g x y -> f (g x y)
11:02:04 <lambdabot> (.) . (.)
11:02:06 <jethr0> @type (((.) . (.)) .)
11:02:07 <lambdabot> forall a b c a1 a2.
11:02:07 <lambdabot> (a2 -> b -> c) -> a2 -> (a -> a1 -> b) -> a -> a1 -> c
11:02:13 <xerox> So it's like
11:02:46 <xerox> @pl \f g h x y z -> f (g x y) (h z)
11:02:47 <lambdabot> ((flip . ((flip . ((.) .)) .)) .) . (.) . (.)
11:02:49 <xerox> Err.
11:02:54 <jethr0> hehe
11:02:57 <xerox> @pl \f g x y z -> f (g x y) z
11:02:58 <lambdabot> (.) . (.)
11:03:00 <xerox> Maybe?
11:03:03 <xerox> No.. uhm.
11:03:20 <jethr0> i can't imagine language junkies of any other language doing stuff as stupid as this *ggg*
11:03:46 <samx> :-)
11:03:47 <xerox> @pl \f g h x y -> h (f (g x y))
11:03:47 <lambdabot> (flip ((.) . (.)) .) . (.) . (.)
11:04:02 <xerox> @pl \f g h x y -> f h (g x y)
11:04:03 <lambdabot> flip . (((.) . (.)) .)
11:04:05 <xerox> dang.
11:04:12 <xerox> @pl \f h g x y -> f h (g x y)
11:04:12 <lambdabot> (((.) . (.)) .)
11:04:14 <xerox> :-D
11:04:22 <jethr0> :P
11:04:43 <xerox> @pl \f x g y z -> f x (g y z)
11:04:44 <lambdabot> (((.) . (.)) .)
11:04:46 <xerox> That is.
11:08:52 <xerox> Yawn.
11:09:41 <palomer> I dreamt I owed 700$ to the library
11:10:14 <palomer> oh my
11:10:17 <jethr0> i think partitioning problem is a prime example for advanced arrows.
11:10:22 <palomer> I do owe a large amount to the library
11:10:26 <palomer> thank you subconscious
11:10:33 <pesco> jethr0: It's not stupid! It's /advanced/!
11:11:19 <jethr0> xerox: isn't there supposed to be an arrow that feeds back into itself??
11:11:26 <palomer> hrm, seems gmail isn't what it's cut out to be
11:11:29 <xerox> I wonder if there are some short-circuit arrows.
11:11:37 <xerox> jethr0: dang.
11:11:44 <jethr0> yes, i read about those...
11:11:55 <jethr0> maybe i'll be able to implement something like this in haskell *hope*
11:12:14 <xerox> I mean, we thought the same thing.
11:12:14 <jethr0> that's like some semi-meta-recursion
11:12:16 <musasabi> jethr0: see ArrowLoop
11:12:39 <xerox> musasabi: where?
11:13:40 <palomer> man, I owe like 10$ to the library
11:13:43 <palomer> why didn't they send me a reminder?
11:14:08 <palomer> ack, like 20$!
11:14:17 <jethr0> musasabi: any idea whether there are examples anywhere? reading the specs/code is kinda hard with these things ;-))
11:14:21 <palomer> I'm going there right now and showing them the what's what!
11:14:48 <musasabi> Control.Arrow
11:14:58 <musasabi> see the arrow papers
11:15:14 <musasabi> I think it is one of the most hard to understand part of arrows.
11:15:30 <xerox> @where Arrows
11:15:30 <lambdabot> http://www.haskell.org/arrows/
11:15:54 <jethr0> hehe
11:16:22 <xerox> musasabi: [Hug00] ?
11:16:33 <Korollary> @where FastPackedString
11:16:33 <lambdabot> I know nothing about fastpackedstring.
11:16:38 <xerox> @where fps
11:16:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:16:40 <jethr0> it's pretty meta, alright. but that's the part of arrows i really like... unbounded fun of function composition ;-)
11:17:12 <xerox> I think I should eat some 100% cocoa chocolate now.
11:17:34 <xerox> musasabi: or what else?
11:18:06 <jethr0> anyone familiar with control.monad.fix.mfix?
11:18:17 <musasabi> xerox: I think the circuit design examples had some stuff on ArrowLoop
11:19:13 <musasabi> fix f = let x = f x in x
11:19:29 <musasabi> mfix f = mdox x <- f x; return x
11:19:34 <musasabi> (iirc)
11:19:40 <xerox> musasabi: any url?
11:20:10 <jethr0> xerox, don't be so greedy
11:20:50 <jethr0> @type fix (+1)
11:20:51 <lambdabot> Not in scope: `fix'
11:20:57 <jethr0> @type Control.Monad.fix (+1)
11:20:58 <lambdabot> Not in scope: `Control.Monad.fix'
11:21:09 <jethr0> @type Control.Monad.Fix.fix (+1)
11:21:10 <lambdabot> forall a. (Num a) => a
11:21:12 <musasabi> xerox: I'm in bed - no browser here.
11:21:15 <xerox> I thought it would have been greedy to attend for an explanation, not want to do it outself
11:21:26 <xerox> musasabi: whatever it means, okay :)
11:21:39 <jethr0> fix (+1) 2
11:21:43 <jethr0> > fix (+1) 2
11:21:44 <lambdabot>  add an instance declaration for (Num (t -> a))
11:21:54 <jethr0> > fix (+1)
11:21:56 <lambdabot> Loop
11:22:03 <musasabi> (it means that I irc from a text console and read - so no cut paste or opening a browser with bookmarks)
11:22:17 <musasabi> @type fix
11:22:18 <lambdabot> Not in scope: `fix'
11:22:24 <jethr0> @type Control.Monad.Fix.fix (+1)
11:22:25 <lambdabot> forall a. (Num a) => a
11:22:27 <jethr0> @type Control.Monad.Fix.fix
11:22:28 <lambdabot> forall a. (a -> a) -> a
11:22:36 <xerox> > fix (\f n -> if n > 10 then [n] else n : f (n-1)) 1
11:22:37 <lambdabot> [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-
11:22:37 <lambdabot> 20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-
11:22:37 <lambdabot> 38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-
11:22:37 <lambdabot> 56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-
11:22:37 <lambdabot> 74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-
11:22:39 <lambdabot> [24 @more lines]
11:22:43 <xerox> > fix (\f n -> if n > 10 then [n] else n : f (n+1)) 1
11:22:45 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11]
11:23:15 <jethr0> can be used for building inline rec. functions. is there more sense to it than that?
11:23:45 <xerox> jethr0: isn't its type lovely?
11:23:59 <jethr0> indeed
11:25:19 <jethr0> > fix (const 2)
11:25:21 <lambdabot> 2
11:25:45 <xerox> :-)
11:26:00 <jethr0> @tape const
11:26:01 <lambdabot> forall a b. a -> b -> a
11:26:07 <xerox> Hah, tape.
11:26:11 <benmos> Hi all. Does anyone know of any line-length limitations (256 chars) using "ghci" via emacs?
11:26:13 <jethr0> @serene xerox
11:26:14 <lambdabot> xerox is in #haskell.it, #haskell-overflow, #haskell-blah and #haskell.
11:26:14 <lambdabot> Last spoke just now.
11:26:55 <jethr0> musasabi, is "fix" related to the Y functor/operator?
11:27:48 <jethr0> isn't Y f = f f ??
11:28:01 <xerox> @get-definition Y
11:28:01 <lambdabot> Unknown command, try @listcommands.
11:28:25 <xerox> There was a time..
11:28:27 <jethr0> it's not haskell specific
11:28:51 <xerox> @lambda I 2
11:28:51 <lambdabot> Unknown command, try @listcommands.
11:28:55 <jethr0> http://okmij.org/ftp/Computation/fixed-point-combinators.html
11:31:53 <jethr0> @type self_apply
11:31:54 <lambdabot> Not in scope: `self_apply'
11:31:59 <jethr0> @index self_apply
11:32:00 <lambdabot> bzzt
11:35:46 <joelr1> autrijus: ping
11:42:21 <Pupeno_> Hello.
11:42:37 <Pupeno_> lisppaste2: url
11:42:37 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:43:25 <lisppaste2> Pupeno pasted "Implementation of lists (excercise 4.8)" at http://paste.lisp.org/display/14293
11:44:14 <Pupeno_> Is that implementation of list, foldl and foldr right ? anything that can be improved ? (I am doing exercise 4.8 of Yet Another Haskell Tutorial).
11:46:02 <jethr0> if you like you might put underscores instead of ununsed params
11:46:55 <Pupeno_> jethr0: thanks.
11:48:03 <jethr0> apart from not handling cases as head [] and tail [], it looks very good...
11:48:31 <arjanb> Pupeno_: you can use pattern matching in fold instead head and tail
11:48:48 <musasabi> jethr0: not really to Y.
11:48:53 <jethr0> and maybe add type signatures
11:49:05 <musasabi> for example ones = fix (1:)
11:49:27 <tic> what's fix?
11:49:27 <Pupeno_> jethr0: the exercise explictly specified no not do that. Thanks.
11:49:35 <Pupeno_> arjanb: oh! I'll do that!
11:49:42 <tic> fix f = fix (fix f?)
11:50:01 <musasabi> > let fix f = let x = f x in x in take 10 (fix (1:))
11:50:02 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
11:50:04 <jethr0> musasabi, well i'm really thrilled by fixpoint theory, but am mathematically retarded ;-). so i might grapple a while with it ;-)
11:50:07 <xerox> > filter (/='?') "fix f = fix (fix f?)"
11:50:08 <lambdabot> "fix f = fix (fix f)"
11:50:43 <tic> what was that for, xerox? :)
11:51:21 <tic> *brain-retarding TV*
11:51:24 <Pupeno_> arjanb: thanks, they are shorter and easier to understand. I am too new to pattern matching.
11:55:42 <jethr0> > let fix f = let x = f x in x in take 10 (fix (\x -> (x+1:))
11:55:43 <lambdabot>  parse error on input `}'
11:55:50 <jethr0> > let fix f = let x = f x in x in take 10 (fix (\x -> (x+1:)))
11:55:51 <lambdabot>   Expecting a function type, but found `t_a1ur'
11:55:51 <lambdabot>   Expected type: [a]
11:55:51 <lambdabot>   Inferred type: [[a]] -> [[a]]
11:56:13 <jethr0> ;-(
11:56:40 <jethr0> > let fix f = let x = f x in x in take 10 (fix (\x -> ((x+1):)))
11:56:41 <lambdabot>   Expecting a function type, but found `t_a1ur'
11:56:41 <lambdabot>   Expected type: [a]
11:56:41 <lambdabot>   Inferred type: [[a]] -> [[a]]
12:03:31 <jethr0> > Control.Monad.Fix.fix id
12:03:32 <lambdabot> Add a type signature
12:03:38 <jethr0> > Control.Monad.Fix.fix id :: Int
12:03:40 <lambdabot> Loop
12:03:42 <syntaxfree> @hawiki DiegoNavarro
12:03:43 <lambdabot> http://www.haskell.org/hawiki/DiegoNavarro
12:03:51 <syntaxfree> ;-)
12:04:52 <Trixsey|Laptop> My task was to create a game (In Java), which was easy to expand with new game classes. I made an interface for those games called "GameHub". Would you guys build the game this way? Or do you consider it bad? If so, why?
12:04:57 <Trixsey|Laptop> http://www.animania.nu/uml_ftw.jpg
12:04:59 <Trixsey|Laptop> What do you guys think? Does this class-diagram look okay? I'm looking for feedback on both var/method declarations and class relations! I'm kinda new in this area so I'm not too sure I got everything right!
12:05:31 <jethr0> > let fix f = f $ fix f in take 10 $ fix (1:)
12:05:32 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
12:06:33 <syntaxfree> @type fix
12:06:34 <lambdabot> Not in scope: `fix'
12:07:13 <jethr0> trixsey: get[Card/Dice]Score in client is a little awkward.
12:07:20 <syntaxfree> @pl grad color1 color2 n = zipWith3 (\x y z->x++y++z) (hueRange color1 color2 0 n) (hueRange color1 color2 2 n) (hueRange color1 color2 4 n)
12:07:21 <lambdabot> grad = ap (ap . (ap .) . ap (ap . (liftM2 (zipWith3 ((. (++)) . (.) . (++)
12:07:21 <lambdabot> )) .) . flip flip 0 . hueRange) (flip flip 2 . hueRange)) (flip flip 4 .
12:07:21 <lambdabot> hueRange)
12:07:24 <jethr0> @type Control.Monad.Fix.fix
12:07:25 <lambdabot> forall a. (a -> a) -> a
12:08:20 <syntaxfree> @hoogle ap
12:08:21 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:08:21 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
12:08:21 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
12:08:54 <Cale> Trixsey|Laptop: the type of startGame seems to vary, is that intentional?
12:09:02 <xerox> ...so, Cale appears :-)
12:09:03 <landro> Is there a predefindes function or operator which drops an element identified by an index from a list?
12:09:17 <landro> s/des/ed/
12:09:33 <Trixsey|Laptop> ah Cale
12:09:35 <Trixsey|Laptop> you are right
12:09:37 <Trixsey|Laptop> its not supposed to :p
12:09:49 <Trixsey|Laptop> I was going to type "Boolean" everywhere.. must have forgotten
12:09:49 <Trixsey|Laptop> lol
12:13:42 <Cale> > let f xs n = take n xs ++ drop (n+1) xs in map (f ['a'..'d']) [0..3]
12:13:43 <lambdabot> ["bcd","acd","abd","abc"]
12:14:05 <jethr0> > let deleteIdx n = (\(x,y) -> x ++ (drop 1 y)) . (splitAt n) in deleteIdx 2 [1..6]
12:14:06 <lambdabot> [1,2,4,5,6]
12:14:30 <Cale> there's nothing predefined, but there are a number of ways to write it
12:14:41 <jethr0> > let f n = (\(x,y) -> x ++ (drop 1 y)) . (splitAt n) in f 2 [1..6]
12:14:42 <lambdabot> [1,2,4,5,6]
12:14:55 <Cale> if you're going to do lots of such deletes, I'd suggest not using lists
12:15:12 <jethr0> it won't get much slower than the above ;-)
12:16:32 <Cale> > let f n xs = let (x,y) = splitAt n xs in x ++ (drop 1 y) in f 2 [1..6]
12:16:33 <lambdabot> [1,2,4,5,6]
12:17:24 <jethr0> > let f n = (map snd) . (filter ((/=n) . fst)) . (zip [0..]) in f 2 [0..6]
12:17:25 <lambdabot> [0,1,3,4,5,6]
12:19:39 <Cale> let f n xs = uncurry (++) . (id *** tail) $ (splitAt n xs) in f 2 [1..6]
12:19:43 <Cale> > let f n xs = uncurry (++) . (id *** tail) $ (splitAt n xs) in f 2 [1..6]
12:19:47 <lambdabot> [1,2,4,5,6]
12:20:03 <jethr0> nice touch
12:20:17 <xerox> The -> virus spread!
12:20:45 <jethr0> > let f n xs = uncurry (++) . (second tail) $ (splitAt n xs) in f 2 [1..6]
12:20:47 <lambdabot> [1,2,4,5,6]
12:21:00 <Cale> ah, yes
12:21:02 <jethr0> second = (id ***)
12:21:08 <Cale> yep
12:21:17 <Cale> way to use the arrow laws :)
12:21:30 <resiak> @type ***
12:21:31 <lambdabot> parse error on input `***'
12:21:36 <resiak> @type (***)
12:21:37 <jethr0> > let f n = uncurry (++) . (second tail) . (splitAt n) in f 2 [1..6]
12:21:38 <lambdabot> Not in scope: `***'
12:21:39 <lambdabot> [1,2,4,5,6]
12:22:24 <jethr0> Cale: tail is not safe, as opposed to "drop 1"!
12:22:32 <jethr0> > tail []
12:22:33 <lambdabot> Add a type signature
12:22:40 <jethr0> > tail [] :: Integer
12:22:41 <lambdabot> Couldn't match `Integer' against `[a]'
12:22:47 <Cale> ah, right
12:22:48 <jethr0> > drop 1 [] :: Integer
12:22:50 <lambdabot> Couldn't match `Integer' against `[a]'
12:22:52 <icb> good afternoon
12:22:53 <jethr0> *damn*
12:23:02 <xerox> > drop 1 [] :: [Int]
12:23:03 <Cale> > tail [] :: [Integer]
12:23:04 <lambdabot> []
12:23:04 <lambdabot> Prelude.tail: empty list
12:23:14 <jethr0> yup
12:23:32 <icb> i have been reading a few papers, i understand what point-free means, but can someone explain to me what does "point-wise application" mean?
12:24:40 <Cale> points are the things which functions act on in this sense
12:24:55 <Cale> f x  is the value of f applied to the point x
12:25:25 <Cale> This terminology ("points-free") comes from algebraic topology, where it first became popular.
12:25:28 <jethr0> > let f n = uncurry (++) . ((take (n-1)) &&& (drop n)) in f 2 [1..6]
12:25:29 <lambdabot> [1,3,4,5,6]
12:25:35 <Cale> Those guys like to work with spaces.
12:25:38 <jethr0> ups
12:25:57 <jethr0> > let f n = uncurry (++) . ((take n) &&& (drop (n+1))) in f 2 [1..6]
12:25:58 <lambdabot> [1,2,4,5,6]
12:25:59 <Cale> (and spaces are made up of points)
12:26:19 <Cale> icb: make sense?
12:26:28 <icb> so far, yes, spaces are continous right?
12:26:36 <Cale> not necessarily
12:26:39 <gzl> what do you mean by continuous?
12:26:50 <Cale> In topology, you only consider continuous maps between spaces
12:27:17 <gzl> yeah
12:27:35 <Cale> If you mean 'connected', then it's not usually required.
12:27:55 <icb> i think i need to overcome the concept of that points are discretization of the space
12:28:52 <icb> when we say f x, x is concrete right?
12:28:59 <Cale> in some sense
12:29:11 <Cale> even if it's a variable
12:29:27 <icb> that i understand
12:29:36 <Cale> We have the concept that we're applying f to *something* at least
12:29:53 <icb> okay
12:30:16 <icb> and point-free basically makes the application open-ended
12:30:57 <Cale> yeah, you don't actually talk about the point in your equation
12:31:14 <icb> right, so we rob the *something* from bothside of the equation
12:31:17 <Cale> you might say something like  f . g = id  rather than f (g x) = x
12:31:25 * icb nods
12:31:35 <Cale> have you seen @pl at work?
12:31:52 <Cale> @pl \x -> f (g x)
12:31:53 <lambdabot> f . g
12:32:02 <syntaxfree> @pl \x y->x**3 / (sin(y+x))
12:32:03 <lambdabot> ap ((.) . (/) . (** 3)) ((sin .) . (+))
12:32:09 <syntaxfree> it's teh coolness :)
12:32:19 <jethr0> there goes the point madness again
12:32:26 <icb> so when i read a passage that goes " the output signal is the point-wise application of f to the insput signal"
12:32:33 <Cale> ah
12:32:34 <Cale> okay
12:32:46 <icb> what does that mean
12:32:54 <Cale> that means "you're not applying f to the signal as a whole"
12:33:01 <Cale> but rather to each point
12:33:13 * SamB tries to figure out how to use a typeclass for currying
12:33:24 <Cale> output t = f (input t)
12:33:26 <Cale> or
12:33:33 <Cale> output = f . input :)
12:33:36 <syntaxfree> what IS uncurry?
12:33:42 <jethr0> hey, samb
12:33:57 <Cale> uncurry is the catamorphism on pairs
12:34:00 <gzl> icb: for example, if you say something like "the addition of functions is defined pointwise," you mean something like (f + g)(x) = f(x) + g(x)
12:34:11 <Cale> yeah
12:34:39 <icb> is this point the same point as in point-free?
12:35:03 <Cale> yeah
12:35:06 <gzl> yes
12:35:10 <gzl> same as what Cale said before
12:35:28 <icb> let me reread the paragraph and ponder for a minute
12:35:45 * SamB looks at evolution of a haskell programmer
12:35:52 <syntaxfree> oh, god.
12:35:59 <syntaxfree> I've written uncurry once.
12:36:36 <syntaxfree> I'm constantly rewriting Haskell.
12:36:43 <Cale> You don't really know Haskell until you've implemented at least half the prelude in your own code. :)
12:36:45 <syntaxfree> I wrote zipWith3 the other day.
12:37:12 <xerox> syntaxfree: me too, in some sense.  What do you think we need to lookup?
12:37:52 <Cale> just reading through the prelude and a few of the basic libraries will put a stop to lots of that
12:38:14 <syntaxfree> I did print out the prelude and put it in my backpack for reading in the bus.
12:38:19 <Cale> I've been having fun with trivial uses of Control.Arrow lately.
12:38:25 <syntaxfree> But I always end up looking through the window and daydreaming in the bus.
12:39:07 * xerox have been having fun with trivial uses of Control.Arrow the first day he came on #haskell :-)
12:39:38 <icb> so what's the opposite of applying a function point-wise?
12:40:30 <xerox> flip?
12:40:31 <syntaxfree> applying it to the whole domain?
12:40:50 <syntaxfree> for instance, if f(x)=2x, then f(R)=R
12:40:54 <syntaxfree> where R is the field of reals.
12:40:55 <Cale> well, there's not so much an opposite as there is lots of other, more complicated ways to apply it
12:41:18 <icb> so point-wise is basically a way to restrict the application domain
12:41:29 <icb> while retaining monotonicity?
12:41:37 <Cale> and to restrict the way in which things are being applied
12:41:45 <syntaxfree> I don't know. I'm the village idiot.
12:42:22 <Cale> like, if I say addition of functions is defined pointwise, I *don't* mean that (f+g)(x) = (f(x) + g(x))/2
12:42:37 <Cale> or that (f+g)(x) = f(x) g(x)
12:42:46 <syntaxfree> ahh. yes.
12:43:25 <syntaxfree> so point-wise combinator definitions keep the structure of the underlying functions?
12:43:34 <syntaxfree> I reeally need to get back into cat theory.
12:43:39 <Cale> I mean that it's defined by applying the operation of the same name to the points which one gets by applying f and g to the point.
12:44:00 <Cale> this is really an informality in mathematics which is usually never explained anywhere in particular
12:44:11 <Cale> you're just expected to pick it up :)
12:44:29 <syntaxfree> "operation of the same name" is really bad :-D
12:44:45 <Cale> well, it's a convenience
12:45:34 <syntaxfree> as far as I know mathematics, you need (+) and (*) defined over a set -- with the appropriate axioms -- to  make it a field. Analysis books generally have some example of function spaces being fields with appropriate definitions.
12:45:39 <Cale> After you've seen about 100 definitions where you're defining an action on functions by lifting an action on the points in their codomain, well, it gets tiring to spell it out over and over. 
12:46:06 <syntaxfree> I really need to get back to cat theory.
12:46:25 <Cale> Or even other topics in mathematics are quite fun :)
12:46:33 <Cale> Group theory is nice
12:46:49 <Cale> or ring theory
12:47:09 <stepcut> one ring to bind them all ???
12:47:09 <syntaxfree> I spent the past few months studying categorical systems in philosophy.
12:47:23 <sieni> well, in real analysis for example it is useful to say, that your multiplication is pointwise multiplication and not e.g. the convolution
12:47:30 <syntaxfree> "Category" in philosophy means something different from mathematical categories, but I suspect a deep relationship between these concepts.
12:47:49 <Cale> sieni: yeah
12:48:04 <icb> would it be accurate to say that if i am not narrowing or widdening the domain, then my function is point-wise?
12:48:13 <Cale> no
12:48:14 <syntaxfree> no.
12:48:20 <Cale> that doesn't quite capture it
12:48:42 <syntaxfree> a function  (between two function spaces) is pointwise if it keeps the structure of the corresponding function inside the function spaces.
12:48:47 <Cale> It means that you're lifting the definition of some operation from points to functions in the most obvious possible way
12:49:00 <sieni> although convolution and pointwise multiplication are related through the fourier transform
12:49:24 <Cale> Convolution is a lot less obvious than pointwise multiplication though :)
12:49:27 <syntaxfree> Cale: can  "lifting" be explained in lay terms quickly?
12:49:38 <icb> okay, those last 3 sentenses makes sense to me
12:49:38 <Cale> "turning into"
12:49:40 <Cale> ?
12:49:55 <Cale> only, it's a different part of speech
12:49:56 <Cale> hehe
12:50:12 <Cale> you're turning an operation on points into an operation on functions
12:50:21 <syntaxfree> OHH.
12:50:35 <syntaxfree> I just understood liftM.
12:50:40 <Cale> hehe
12:50:42 <syntaxfree> @type liftM
12:50:43 <lambdabot> Not in scope: `liftM'
12:50:48 <xerox> @type fmap
12:50:49 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:50:55 <syntaxfree> @type Control.Monad.liftM
12:50:56 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:51:28 <Cale> yeah, there you're lifting a function on points to a function on containers of those points.
12:51:46 <syntaxfree> I know the basic vocabulary of category theory. But what kind of categories are common in Haskell?
12:52:01 <palomer> CCCs!
12:52:08 <Cale> The category of Haskell types and Haskell functions
12:52:21 <syntaxfree> that's one category?
12:52:23 <Cale> is almost the only category you care about
12:52:30 <syntaxfree> so why do you have functors?
12:52:32 <palomer> the functions are the arrows
12:52:49 <Cale> Functors are endofunctors on that category
12:52:51 <palomer> Cale: do you write function application in polish notation (like many category theorists do)?
12:53:10 <icb> i think i partly got it, i will need to read more context to let it sink in, thank you guys for the clarification
12:53:16 <Cale> palomer: I've suggested it, but unless everyone is going to switch over, it's not worth it
12:53:26 <palomer> it's sooo much more intuitive
12:53:43 <Cale> palomer: another option is to write types the other way
12:53:52 <Cale> f : B <- A
12:54:03 <palomer> Cale: that's not intuitive at all!
12:54:07 <syntaxfree> so, um, a functor has to be defined both over functions and types?
12:54:12 <Cale> yeah
12:54:23 <Cale> fmap is the function part of the functor
12:54:28 <palomer> a functior is a "function" that sends arrows to arrows and points to points
12:54:28 <SamB> what is a catamorphism on pairs?
12:54:35 <palomer> s/functior/functor
12:54:36 <syntaxfree> let's say I have a combinator "double". double f = (*2)  . f
12:54:51 <syntaxfree> a functor is an arrow between categories. Am I wrong?
12:55:00 <Cale> syntaxfree: that's correct
12:55:12 <Cale> in the usual category of small categories
12:55:14 <palomer> Cale: do you think that right associativity makes more sense then left associativity for function application?
12:55:16 <syntaxfree> so, let's say I have a combinator called "double", where double = (*2) . f
12:55:25 <Cale> palomer: no
12:55:32 <Cale> :)
12:55:43 <palomer> pfft
12:55:48 <palomer> I find myself using $ more often than not
12:56:00 <syntaxfree> how am I gonna define a suitable operation  over types so I can make a functor? doublep x = 2*x? 
12:56:22 <Cale> um
12:56:23 <syntaxfree> I had the $ bug for a while. Now i explicitly avoid it for great justice.
12:56:40 <palomer> syntaxfree: justice?
12:56:42 <Cale> syntaxfree: The functor applies to types by being a type constructor
12:56:50 <sieni> palomer: it's useful in order to avoid lots of irritating superfluous parentheses
12:56:54 <Cale> and applies to functions between those types through fmap
12:56:54 <syntaxfree> palomer: oh, old gamer meme. Forget about it.
12:57:12 <syntaxfree> ok.
12:57:33 <syntaxfree> so,  um, uh. er. 
12:58:09 <Cale> [] is a functor which takes a type to the type of lists of elements of that type
12:58:20 <Cale> and acts on arrows by map
12:58:37 <palomer> [] is a very interesting functor
12:59:21 <syntaxfree> @wikipedia AYBABTU
12:59:23 <lambdabot> http://en.wikipedia.org/wiki/AYBABTU
12:59:31 <syntaxfree> that explains "for great justice", Palomer.
12:59:37 <palomer> Cale: has anything good come out of the categorical model applied to haskell?
12:59:44 <sieni> what happen?
12:59:48 <Cale> palomer: monads :)
13:00:21 <palomer> Cale: monads would have been "discovered" independently, methinks
13:00:28 <Cale> palomer: nope
13:00:33 <Cale> uh
13:00:38 <Cale> would have been?
13:00:46 <Cale> well, they weren't :)
13:00:47 <Cale> hehe
13:01:19 <palomer> anything else than monads?
13:02:07 <Cale> apart from monads and functors, I'm not sure exactly what influence it's had
13:02:34 <Cale> apparently caml started out from some category theoretic analysis
13:02:44 <palomer> caml is a poor man's haskell
13:02:57 <Cale> heh
13:02:58 <syntaxfree> isn't Caml eagerly evaluated?
13:03:05 <Cale> yes
13:03:08 <palomer> yeah, Caml's strict
13:03:39 <tic> mm haskell.
13:03:43 * syntaxfree thought Haskell was the poor man's (since it's free) version of Miranda (Miranda is a trademark of Research Software Inc.)
13:03:46 <palomer> though its type system is more powerful than haskell's
13:03:50 <xerox> I wonder, what's unintuitive in Haskell?
13:04:13 <tic> nothing is intuitive. breathing and eating is intuitive. ;)
13:04:16 <xerox> I was thinking that in fact Haskell is poor mans' language, in this sense.  It's built of 'simple' things.  So I asked.
13:04:19 <sh10151> the only intuitive thing is the nipple, so, everythin in Haskell except its nipples.
13:04:21 <tic> but I'd say the type system.
13:04:30 <tic> err, type classes.
13:04:32 <tic> (as a newbie)
13:04:40 <palomer> application order!
13:04:41 <xerox> tic: even with those arrows in it?  from there, to there.
13:04:47 <palomer> yay for polish notation!
13:04:59 <xerox> No real answer, eh.
13:05:05 <tic> xerox, instance Show Foo where...
13:05:06 <palomer> I'm being serious
13:05:08 <tic> xerox, that kind of stuff.
13:05:17 <tic> bah, who needs syntax anyway. (yay lisp)
13:05:26 <xerox> palomer: more or less.  Parens are kinda simple.
13:05:29 <syntaxfree> yay lisp!
13:05:32 <xerox> palomer: grouping together is pretty straightforward.
13:05:35 <syntaxfree> yay scheme.
13:05:39 <xerox> What else?
13:05:49 <palomer> seriously, putting the verb at the start of a sentence is unintuitive
13:05:54 <xerox> tic: what's behind instance Foo Bar, a set, and a thing in that set.
13:06:06 <tic> What I like about Haskell is that I can often code with pen and paper. But I'm not sure if the Haskell way is really smaller and more neat than a, say, Python implementation, because I seem to solve different problems in the different domains.
13:06:16 <tic> err, problems from different domains using the two languages.
13:08:08 <syntaxfree> I used to use Python for quick  mock-ups of numerical problems.
13:08:14 <syntaxfree> Well, quick  mock-ups is all I do anyway.
13:08:25 <syntaxfree> Lazy evaluation is quite handy for quick mock-ups.
13:08:38 <xerox> Any other ideas
13:09:11 <syntaxfree> Haskell is addictive.
13:09:19 <syntaxfree> I'm unable to program without higher-order functions nowadays.
13:09:19 <tic> Haskell rocks for embedded languages
13:09:37 <syntaxfree> my Python code ends up being all functional, and everyone knows how that sucks in Python.
13:09:57 <wolverian> especially in python3k ;)
13:10:07 <Pupeno_> What does h stands for in hClose, hIsEOF, hPutChar, etc ?
13:10:11 <tic> Pupeno_, handle
13:10:21 <tic> Pupeno_, as in, openFile :: FilePath -> Handle
13:10:28 <tic> (maybe with some mode thrown in)
13:10:33 <tic> @type openFile
13:10:34 <lambdabot> Not in scope: `openFile'
13:10:40 <xerox> @type System.IO.openFile
13:10:41 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
13:10:42 <tic> @type hOpenFile
13:10:43 <lambdabot> Not in scope: `hOpenFile'
13:10:46 <xerox> @type System.IO.hOpenFile
13:10:48 <lambdabot> Not in scope: `System.IO.hOpenFile'
13:10:48 <palomer> syntaxfree: oh, it does
13:10:50 <xerox> Dunno.
13:11:03 <tic> wolverian what about python3k?
13:11:24 <tic> syntaxfree, why does functional programming in Python suck? *curious*
13:11:40 <syntaxfree> Guido is removing functional programming facilities from Python to python3k.
13:11:42 <syntaxfree> tic: slow.
13:11:49 <wolverian> tic, it removes .reduce etc.
13:11:49 <syntaxfree> tic: veeeewwy slow.
13:11:56 <tic> syntaxfree, don't mind that. something else?
13:11:58 * xerox stares at lambda
13:12:01 <gzl> why's he removing them?
13:12:09 <tic> syntaxfree, reduce's just a function anyway.
13:12:39 <tic> The only thing is a lambda, which can easily be emulated using a named function, the scoping works now anyway.  lambdas in Python's always been crippled. :)
13:12:42 <syntaxfree> tic: well, slow.
13:12:55 <tic> syntaxfree, I'm mostly interested in the syntactic support.
13:13:02 <tic> syntaxfree, anything there that makes it bad for you
13:13:02 <tic> ?
13:13:31 <araujo> There exist a function in the prelude to split a list into elements like 'words' does, but specifying an element other than whitespace?
13:13:34 <syntaxfree> I hate "def" almost as much as I hate "defun", haha.
13:14:00 <Pupeno_> syntaxfree: amen!
13:14:21 <syntaxfree> defun removes all the fun.
13:14:37 <syntaxfree> Have you ever seen Lush?
13:14:54 <araujo> I have,
13:15:04 <araujo> syntaxfree, that's for GUI appli mainly?
13:15:08 <syntaxfree> in Lush, defun/define becomes just "de" 
13:15:17 <syntaxfree> Lush is for  numerical applications,  mostly.
13:15:28 <araujo> That sounds worse then.
13:15:46 <syntaxfree> people use it  for computer graphics and sound processing.
13:16:07 <psi> araujo, no such function in the prelude
13:16:08 <syntaxfree> it's orders of magnitude faster than mzscheme in my tests.
13:16:09 <joelr1> autrijus: ping
13:16:20 <psi> or standard list library
13:16:42 <joelr1> Cale: can you understand the autrijus example in the TH section of the haskell wiki?
13:16:50 <syntaxfree> the Lush docs suck, though.
13:18:49 <araujo> psi, Ok, thanks
13:19:11 <xerox> joelr1: url?
13:19:17 <joelr1> looking
13:19:24 <tic> I'd totally love Haskell-style pattern matching in Python
13:19:32 <joelr1> http://www.haskell.org/hawiki/TemplateHaskell
13:19:40 <araujo> tic, i don't 
13:19:43 <tic> Something like this: http://svnbox.mine.nu/public/utils/trunk/py-patmatch/patmatch.py
13:19:44 <araujo> :-]
13:19:50 <tic> (take a look at the end)
13:19:52 <joelr1> see Generic Constructor for Records
13:19:56 <tic> Works, but could be cleaner.
13:22:14 <sh10151> tic: my eyes
13:22:22 <sh10151> arg
13:24:23 <joelr1> xerox: what do you recon?
13:38:46 * SamB can't figure out how to build up tupling/uncurrying by induction
13:39:43 <astrolabe> template haskell?
13:39:53 <SamB> thats the easy way!
13:40:20 <astrolabe> that's the possible way :)
13:40:49 <SamB> except the part where you make it automatically the right type
13:41:15 <Philippa> SamB: what've you been asked to do, exactly?
13:41:16 <SamB> Cale said something about catamorphism on pairs
13:41:27 <Philippa> *ah*. Yes
13:41:33 <SamB> asked?
13:41:39 <Cale> ah
13:41:40 <Cale> yeah
13:41:41 <Philippa> sorry, looked like a homework question :-)
13:42:00 <joelr1> does anyone understand http://www.haskell.org/hawiki/TemplateHaskell 
13:42:08 <joelr1> the constructing records example by autrijus
13:42:12 <Cale> if you think about it, pairs are something like  data (,) a b = (,) a b
13:42:21 <SamB> Philippa: I *hope* people don't have to do homework like this, I would *so* hate the professor who inflicted such pain on me!
13:42:34 <SamB> yes!
13:42:34 <Cale> a catamorphism is something which takes each constructor and replaces it with a function of an appropriate type
13:42:40 <autrijus> joelr1: they are old-style TH I believe and does not work with 6.4 anymore
13:42:56 <joelr1> autrijus: would you by chance have more up-to-date code?
13:42:58 <autrijus> I should probably remove it
13:43:04 <autrijus> no... I switched to DrIFT
13:43:07 <autrijus> which is far saner
13:43:10 <autrijus> and actually works on AIX
13:43:19 <SamB> This doesn't work:
13:43:20 <Cale> (,) :: a -> b -> (a,b)
13:43:20 <SamB> tuple2 :: a -> b -> (a, b)
13:43:20 <SamB> tuple2 = (,)
13:43:20 <SamB> tuple3 :: a -> b -> c -> (a, (b, c))
13:43:20 <SamB> tuple3 x = (,) x . tuple2
13:43:20 <SamB> tuple4 :: a -> b -> c -> d -> (a, (b, (c, d)))
13:43:22 <SamB> tuple4 x = (,) x . tuple3
13:43:27 <joelr1> autrijus: i have something like 250 records that i can get over the network
13:43:38 <joelr1> autrijus: and would love an automated way to tackle them
13:43:40 <Cale> so that appropriate type is a -> b -> c
13:44:04 <Cale> uncurry :: (a -> b -> c) -> (a,b) -> c
13:44:12 * SamB is being smart and trying to just prototype the methd
13:44:22 <autrijus> joelr1: you get the records at runtime?
13:44:28 <joelr1> autrijus: how would i use DrIFT here?
13:44:32 <Cale> foldr :: (a -> b -> b) -> b -> [a] -> b
13:44:39 <SamB> Cale: yes, well...
13:44:39 <joelr1> autrijus: a C++ server sends stuff to me down the wire
13:44:59 <autrijus> joelr1: so it's at runtime... you can't do that at runtime anyway
13:44:59 <joelr1> and i'm supposed to launch thousands of clients that run forever
13:45:02 <Cale> maybe :: b -> (a -> b) -> Maybe a -> b
13:45:02 <autrijus> (not without hs-plugins)
13:45:02 <SamB> I want to do a deeper catamorphism
13:45:14 <joelr1> autrijus: the record format is predefined
13:45:19 <Cale> there is no deeper catamorphism, the type isn't recursive
13:45:25 <joelr1> i have haskell structures matching the C records
13:45:31 <joelr1> or matching the binary format anyway
13:45:32 <SamB> I want to do it in the type system
13:45:40 <autrijus> joelr1: so how many record types are there?
13:45:51 <joelr1> autrijus: uh... 250 something 
13:46:08 <joelr1> autrijus: i have a neat way of serializing them to/from lists of word8 but it's hampering me now
13:46:22 <joelr1> autrijus: i need to go to Binary IO or something like that to avoid generating lists
13:46:40 <joelr1> autrijus: and, unfortunately, my old neat way of serializing things no longer works :(
13:46:59 <SamB> joelr1: you can't use Storable?
13:47:01 <joelr1> not with the get bh style of doing things
13:47:47 <joelr1> SamB: i want to save some typing. a lot of typing
13:47:56 <joelr1> see if i can anyway
13:48:17 <SamB> joelr1: how hard is storable?
13:48:20 <joelr1> doing things manually with storable i would need to remember to increment the pointer for example
13:48:34 <autrijus> joelr1: you can derive Binary easily using DrIFT
13:48:40 <autrijus> I think that's the sanest way
13:48:46 <joelr1> autrijus: do you have any samples?
13:48:52 <autrijus> see the DrIFT source...
13:49:09 <joelr1> i'm looking at the manual
13:49:38 <SamB> DrIFT isn't much fun to extend, but using as-is should be fine
13:50:11 <joelr1> i'm having a hard time grokking drift upon first glance
13:50:33 <autrijus> joelr1: I have something like that in http://svn.openfoundry.org/openafp
13:50:36 <SamB> you don't actually need to grok it, iirc...
13:51:06 <autrijus> the "Binary" there isn't really Binary as it parses upstream AFP formats instead of using variant coding
13:51:15 <autrijus> instance generators are at src/OpenAFP/Prelude/instances.pl
13:51:51 <autrijus> as for using DrIFT... see maybe http://svn.openfoundry.org/pugs/src/Pugs/PIL1.hs-drift and http://svn.openfoundry.org/pugs/src/DrIFT/
13:51:54 <joelr1> so what is the point of drift again? assuming i have data Foo = Foo Word8 Word32 Word64, how can it help me?
13:52:08 <autrijus> the point of DrIFT is allowing "deriving" of any class
13:52:24 <autrijus> so if you put this in your source file
13:52:28 <autrijus> {-! global : GhcBinary !-}
13:52:33 <autrijus> and run drift as preprocessor
13:52:42 <autrijus> then it generates GhcBinary instances for all data structures
13:52:44 <musasabi> there is lots of small codes deriving various classes with either Drift or TH
13:52:58 <musasabi> and then you just choose a suitable serialization library to do the stuff.
13:53:06 <autrijus> if you don't care about on-the-wire format then you can just use SerTH
13:53:22 <musasabi> GADTs make for very nice serialization library format
13:53:28 <phys_rules> @where numberttheory
13:53:29 <lambdabot> I know nothing about numberttheory.
13:53:29 <joelr1> well, my on-the-wire format is fairly spefic
13:53:29 <SamB> autrijus: he said something about C
13:53:34 * musasabi has some code around that I should push out.
13:53:47 <SamB> musasabi: oh? code? to push?
13:54:09 <joelr1> like if a 0 is stored then there's nothing to read and if 1 then you would read, say, a Word32. a way of serializing Maybe Word32
13:54:43 <SamB> joelr1: in that case, that sounds like you ought to just put up with the lists...
13:54:44 <musasabi> SamB: I think I got the decoding encoding combinators right this time for fixed-wire protocol encoding/decoding with one piece of code.
13:54:59 <SamB> musasabi: oh?
13:55:07 <SamB> musasabi: let me see!
13:55:15 <joelr1> SamB: the problem with lists right now is that my program spends at least 50% of the time collecting garbage and i run out of memory still
13:55:38 <joelr1> and i cannot do retainer or bio profiling because of ghc bugs :(
13:55:42 <SamB> joelr1: hmm, well, do these particular lists show up in the heap profile?
13:55:58 <SamB> first off, do it by cost center
13:56:02 <musasabi> SamB: I two hours? (I'll polish the code and kill of dead code)
13:56:02 <joelr1> SamB: : shows at the top of the list :D
13:56:06 <joelr1> as in colon
13:56:23 <joelr1> W#8 or something like that is seconds. word8 must be
13:56:28 <joelr1> all my lists are word8
13:57:34 <SamB> joelr1: but by cost center?
13:58:09 <joelr1> SamB: i went through that and narrowed it down to my read proc
13:58:09 <joelr1> fun
13:58:15 <joelr1> the one that reads a packet from the net
13:58:21 <joelr1> and returns a haskell record
13:58:46 <SamB> joelr1: and why are these lists live for so long?
13:58:51 <joelr1> allocated ptr  to [Word8] and then pickling/unpickling
13:59:04 <joelr1> SamB: beats me. i cannot manage to find out since ghc barfs on me
13:59:15 <joelr1> randomplay: internal error: Invalid object in processHeapClosureForDead(): 68
13:59:15 <joelr1>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
13:59:21 <SamB> joelr1: well, you can try your head instead of profiling
13:59:30 <joelr1> SamB: did that
13:59:33 <joelr1> does not help
14:00:00 <SamB> I don't suppose you can let me see some code like yours?
14:00:12 <joelr1> sec
14:00:43 <SamB> oh, have you heard of list fusion?
14:00:57 <joelr1> actually, i posted all the code to haskell-cafe
14:01:01 <joelr1> all the relevant code
14:01:06 <SamB> what thread?
14:01:08 <joelr1> let me see if it's on the net
14:01:13 <joelr1> SamB: the code, long
14:01:26 <SamB> gmane has it as if on usenet
14:01:32 <SamB> so I'll just use Pan to find it
14:01:35 <joelr1> STM, Concurrent Haskell and network clients (long, code)
14:02:08 <joelr1> where does list fusion come in?
14:02:30 <SamB> well, how are you getting lists?
14:02:31 <joelr1> SamB: found the thread yet?
14:02:56 <SamB> I have to download headers
14:03:02 <SamB> okay, got headers
14:03:06 <joelr1> SamB: simple, i'm picking bytes from the buffer
14:03:19 <SamB> got article
14:03:49 <lisppaste2> joelr1 pasted "lists" at http://paste.lisp.org/display/14302
14:04:28 <SamB> joelr1: I think you can fuse that...
14:04:34 <SamB> not positive.
14:04:39 <joelr1> what for?
14:04:42 <joelr1> and how?
14:04:49 <SamB> well, that way you wouldn't have these lists at all
14:05:03 <joelr1> please explain
14:05:05 <SamB> well, only if your code is a good consumer...
14:05:13 <SamB> where is that paper
14:05:29 <joelr1> SamB: the issue is that the code doesn't even need all the data from all the records
14:06:02 <joelr1> pattern matching is used sometimes but most of the time i can just refer to these lazily i think
14:06:26 <SamB> joelr1: laziness might actually be the whole problem
14:06:30 <joelr1> that is convert to haskell data type from the list when the field is accessed
14:06:35 <joelr1> SamB: yeah, 100%
14:06:44 <joelr1> my program moves something like 20Gb of memory 
14:06:56 <joelr1> generated and garbage-collected. and some of that stays around 
14:06:56 <joelr1> :(
14:07:01 <joelr1> so what about list fusion?
14:08:42 <SamB> well, if you can get it to work, it will save you from having all these lists even exist
14:08:59 <joelr1> i don't know what you are talking about ;)
14:09:05 <joelr1> i know more about nuclear fusion in fact
14:09:15 <joelr1> and i only have cursory knowledge of that
14:09:19 <SamB> let me just find the article...
14:09:39 <astrolabe> Well, I hope it works better than that.
14:09:47 <dcoutts> list fusion will not save you if the lists are not collectable, which they must be if they are contributing to the 20GB
14:09:49 <SamB> astrolabe: which?
14:09:58 <dcoutts> list fusion is an optimisation
14:10:00 <SamB> hmm
14:10:05 <astrolabe> list f better than nuclear f
14:10:12 <dcoutts> not a space leak solution
14:10:15 <SamB> maybe what he needs is a good dose of strictness?
14:10:47 <joelr1> dcoutts: the lists show up in generated data (-hc)
14:11:02 <dcoutts> then they are being retained
14:11:04 <joelr1> a lot of stuff is collected in fact
14:11:09 <dcoutts> and list fusion will not help
14:11:34 <dcoutts> if the problem is a lot of time spent in GC, it's most likely because of a large heap
14:11:35 <SamB> wait, did he say they were in the object code?
14:11:36 <xerox> 'night.
14:11:43 <Cale> 'night xerox 
14:11:57 <joelr1> i thought that some stuff that shows up in -hc as generating heaps of data 
14:12:06 <SamB> oh, right,
14:12:06 <joelr1> it does not mean that data is not gc-d, right?
14:12:09 <SamB> +RTS -hc
14:12:11 <dcoutts> if the retained heap is not so big but there are a huge number of allocations then list fusion and similar things might help
14:12:29 <dcoutts> but with the 20GB, it sounds like a space leak
14:12:29 <joelr1> i have huge numbers of allocations
14:12:38 <joelr1> check out the paste
14:12:47 <dcoutts> your allocations are retained right?
14:12:54 <Cale> joelr1: where's the paste?
14:13:12 <lisppaste2> joelr1 annotated #14302 with "allocations" at http://paste.lisp.org/display/14302#1
14:13:29 <joelr1> dcoutts: i dunno. i cannot get a retainer report, bug in ghc
14:13:44 <joelr1> ./randomplay +RTS -hc -hbdrag,void
14:13:44 <joelr1> randomplay: internal error: Invalid object in processHeapClosureForDead(): 68
14:13:44 <joelr1>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
14:13:51 <Cale> 50,360,528 bytes maximum residency
14:13:53 <dcoutts> hmm
14:14:03 <Cale> is 50MB a problem?
14:14:13 <joelr1> Cale: i wasn't running long enough ;) 
14:14:20 <joelr1> Cale: that number grows
14:14:24 <Cale> ah, okay
14:14:29 <SamB> I suppose you can't really use FPS, it has that annoying BSD license... or can you?
14:14:35 <SamB> er, GPL
14:14:41 <SamB> BSD is the one I wish it had
14:14:50 <dcoutts> well the functions in: http://paste.lisp.org/display/14302 do look like they would allocate huge lists
14:14:52 <joelr1> client left the thing running over night and the program was killed on freebsd, nothing else was printed. just Killed
14:15:06 <Cale> yeah, it ran out of memory
14:15:10 <joelr1> i take that to mean the machine ran out of memory and it has 1Gb
14:15:19 <Cale> okay
14:15:27 <joelr1> we were trying to launch 4000 bots that would then run forever
14:15:29 <Cale> so what does your program actually do?
14:15:36 <Cale> hm
14:15:39 <joelr1> poker bots
14:15:48 <SamB> maybe you need more machines?
14:16:09 <joelr1> it's a library to write poker bots in haskell and my requirement is to run 4000 bots per machine. at least that many, hopefully 10000
14:16:19 <SamB> oh
14:16:25 <dcoutts> joelr1, yeah, looking at the code it does look like you're allocating lots of short lived lists
14:16:27 <joelr1> i'm at the point where i would just rewrite the whole thing in ruby :(
14:16:36 <Cale> can I see which code is allocating lots?
14:16:38 <joelr1> dcoutts: so what's the solution?
14:16:49 <dcoutts> arrays of Word8
14:16:51 <joelr1> Cale: look up this thread in haskell-cafe: 
14:16:53 <SamB> joelr1: so what did the cost-center heap profile tell you?
14:17:06 <dcoutts> and unboxed arrays of Word8 at that
14:17:18 <dcoutts> you can do IO directly with IOUArrays
14:17:24 <joelr1>  STM, Concurrent Haskell and network clients (long, code)
14:17:36 <dcoutts> and you can freeze/thaw them if you need to work on them purely
14:17:37 <SamB> hmm
14:17:40 <joelr1> SamB: that read() is allocating all the data
14:17:44 <bosie> how can i pass a file to another file in ghci?
14:17:48 <bosie> file1 < file2 ?
14:17:53 <bosie> which doesnt work btw
14:18:14 <dcoutts> readFile "file1" >>= writeFile "file2"
14:18:16 <joelr1> SamB: do you have the gmane link for Cale?
14:18:37 <Cale> I'm subscribed, I found it
14:18:40 <joelr1> Cale: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/9546
14:18:40 <dcoutts> @type readFile "file1" >>= writeFile "file2"
14:18:41 <lambdabot> IO ()
14:18:50 <bosie> writefile?
14:18:57 <SamB> unfortunately Pan doesn't seem to provide such a facility...
14:19:04 <dcoutts> @index writefile
14:19:04 <lambdabot> bzzt
14:19:08 <Cale> do you have profiling output with lots of cost centres?
14:19:15 <dcoutts> @hoogle writefile
14:19:16 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
14:19:16 <lambdabot> System.IO.writeFile :: FilePath -> String -> IO ()
14:19:18 <joelr1> Cale:  read :: Handle -> (SSL, BIO, BIO) -> IO Command  is the culprit
14:19:32 <joelr1> http://wagerlabs.com/randomplay.hs
14:19:36 <joelr1> check this out 
14:19:42 <Cale> how often is read called?
14:19:46 <joelr1> no, wait
14:19:59 <bosie> dcoutts_ i dont wanna write
14:20:00 <joelr1> basically, look at that PS and replace goToTable with read
14:20:08 <joelr1> because that's what it ultimately boils down to
14:20:14 <joelr1> let me see if i have a better PS
14:20:18 <Cale> http://wagerlabs.com/randomplay.hs -- 404
14:20:21 <dcoutts> bosie, you'll have to explain what you want
14:20:22 <joelr1> Cale: for every packet
14:20:28 <SamB> joelr1: did you compile with "-prof -auto-all"?
14:20:44 <dcoutts> joelr1, so can you use Data.Array.IO ?
14:20:44 <joelr1> SamB: yes
14:20:45 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IO.html
14:20:45 <bosie> dcoutts fair enough, i have a fail with testcases and i need file1 in which i have all the functions defined
14:20:54 <bosie> file
14:21:03 <joelr1> dcoutts: i probably can, should i? what would the difference be? 
14:21:07 <bosie> filetest should know the functions from file
14:21:14 <joelr1> dcoutts: it would require me to rework my pickling code :(
14:21:21 <joelr1> probably significantly
14:21:29 <joelr1> @google pickler combinators
14:21:29 <dcoutts> joelr1, it'd be fast. It'd not use allocate list elements.
14:21:30 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
14:21:42 <bosie> and i know there is a way to do it in ghci but i kind find how
14:21:45 <joelr1> dcoutts: i'm using this scheme, pickler combinators. it goes to/from a list
14:22:20 <joelr1> Cale: read is called to retrieve each command sent to me over the network. many times per second, probably
14:22:36 <astrolabe> bosie: do you want    :load    ?
14:22:43 <Cale> okay, but any one invocation shouldn't stick around too long
14:22:53 <joelr1> dcoutts: to switch to arrays i would need to probably add a appS to appU and appP to size an item
14:22:56 <SamB> joelr1: so you can't profile by cost center at all?
14:23:00 <joelr1> so that i can pre-allocate the array
14:23:12 <joelr1> SamB: i can, i already determined read() to be the culprit
14:23:16 <dcoutts> joelr1, pickling to/from [Word8] is pretty inevitably going to allocate lots and lots of temporary cons cells.
14:23:26 <joelr1> SamB: but i cannot do retainer profiling
14:23:33 <joelr1> Cale: shouldnt, right
14:23:43 <bosie> astrolabe i tried load but it tells me that i have defined module 'Main' multiple times
14:23:46 <joelr1> Cale: but something does stick around
14:23:46 <Cale> what's unstuff?
14:23:47 <bosie> in multiple files
14:23:53 <dcoutts> bosie, sorry, I have no idea what you are talking about.
14:24:13 <bosie> dcoutts_ i have a file full with
14:24:13 <bosie> elemsUnique [1,2,3] == True
14:24:13 <bosie> elemsUnique [1,2,4] == False
14:24:13 <bosie> elemsUnique [1,2,8] == True
14:24:23 <astrolabe> bosie: what is the name of the file?
14:24:24 <bosie> just to check if i break the function
14:24:26 <Cale> also, what's the Command type?
14:24:30 <bosie> testing.hs
14:24:36 <joelr1> dcoutts: so how would you do this with arrays? the pickler combinators
14:24:46 <bosie> but all my functions are defined in ex6.hs
14:24:54 <joelr1> Cale: command is a 250+ constructors, records
14:24:55 <astrolabe> bosie: have you put   module...... at the begining?
14:25:05 <bosie> astrolabe nowhere
14:25:06 <joelr1> Cale: for unstuff google for pickler combinators
14:25:13 <dcoutts> joelr1, I guess that instead of recursing over lists it'd need to index an array
14:25:27 <joelr1> my task seems to be to convert pickler combinators to using arrays
14:25:39 <astrolabe> bosie: all your files should start with module, except for the one where main is defined.
14:25:41 <dcoutts> joelr1, it would be more complex with arrays but there should be large performance benefits
14:26:00 <joelr1> dcoutts: so i would need to read an array from the socket and then read from that, advancing the indexm right? but to stuff into an array i guess i would need to pre-calculate the size of the whole thing
14:26:04 <joelr1> does that sound right?
14:26:10 <dcoutts> joelr1, there's extra complexity from the fact that you'd probably not just have one big array but some list of chunks
14:26:22 <bosie> astrolabe so how do i build a "unit-testing" file?
14:26:24 <joelr1> dcoutts: not quite
14:26:41 <joelr1> dcoutts: can you glance at the picklers paper?
14:26:48 <phys_rules> yay, guys, this is officially weird, I am on windows now, and just tried andrew's numbertheory package factorial function from Math.Combinatorial, in Solaris 10^6 runs in 39  seconds, in windows 64 seconds, that's quite a difference (both compiled with optimization on) same version of GHC
14:26:58 <astrolabe> bosie: I don't know, I think there is a library somewhere.
14:26:59 <dcoutts> joelr1, you could either pre-calculate or just use blocks of a certain size (eg 4k) and then only push down the pipe/socket the amount of data that you wrote
14:27:15 <joelr1> dcoutts: i think that if i add appS to get the size of the item being pickled then i could pre-allocate the array and stuff into it while advancing my index
14:27:22 <joelr1> but
14:27:39 <bosie> astrolabe nono i mean i have like this: one file with all functions and a second file with all the testings of the function
14:27:46 <joelr1> could i do that in pure code? probably not and then i'm hosed i think. i might as well use Storables and peek/poker to/from memory
14:27:46 <dcoutts> joelr1, have you got a url for the paper?
14:28:04 <Cale> joelr1: I don't see unstuff in that paper
14:28:05 <dcoutts> joelr1, you can use pure arrays
14:28:07 <joelr1> @google pickler combinators
14:28:08 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
14:28:12 <SamB> joelr1: if worse comes to worse you can invent a more regular protocol and write a translator in another language...
14:28:17 <SamB> s/worse/worst/
14:28:17 <bosie> function.hs: patternMatching :: Muster -> Text -> Text
14:28:17 <bosie> testing.hs: patternMatching "x" ["x","xx","xxx","xxxx"] == ["x"]
14:28:21 <bosie> how do i call that ?
14:28:33 <joelr1> SamB: i might as well write a translator from Haskell to Ruby ;)
14:28:40 <astrolabe> bosie: you will either need to put them in the same file, or make one of them a module, I guess the functions should be the module.
14:28:50 <bosie> astrolabe hm
14:29:11 <bosie> no i saw it with like 
14:29:11 <bosie> Prelude> testing.hs < functions.hs ...
14:29:16 <musasabi> How do I give a type signature for an expression like "(a,b) = foo" on the toplevel?
14:29:25 <musasabi> s/expression/declaration/
14:29:27 <lisppaste2> joelr1 annotated #14302 with "unstuff" at http://paste.lisp.org/display/14302#2
14:29:31 <joelr1> ruby, scheme, what have you
14:29:48 <joelr1> Cale: that annotation is for you
14:30:01 <Cale> musasabi: give types to 'a' and 'b'
14:30:11 <bosie> ok found it
14:30:25 <musasabi> thanks
14:30:46 <bosie> astrolabe functions.hs > testing.hs
14:31:20 <SamB> there is a library called HUnit
14:31:27 <joelr1> dcoutts: how can you purely modify arrays without using a monad?
14:31:38 <astrolabe> bosie: I don't understand, but if you're happy, good.
14:31:43 <SamB> but a lot of people just use quickCheck and a sh/hs script... 
14:31:56 <bosie> astrolabe hehe
14:31:58 <Cale> joelr1: by using diff arrays
14:32:19 <dcoutts> joelr1, it involves copying or using a diffarray or constructing the array in one go
14:32:22 <joelr1> so i would generate lots of arrays then :D what's the difference?
14:32:29 <Cale> I don't know
14:32:41 <Cale> I still don't know why this would be the problem
14:32:48 <Cale> can I see the whole profiling output?
14:32:51 <dcoutts> joelr1, the arrays are compact, and have much less GC overhead.
14:32:57 <SamB> joelr1: but writing a flat protocol and writing a translator in something else would be easier than getting a Haskell->Ruby translator to do anything for you...
14:32:59 <dcoutts> joelr1, in addition the IO will be fast
14:33:06 <joelr1> Cale: you mean *prof?
14:33:11 <Cale> yeah
14:33:21 <SamB> if anything, machine-translating your code from Haskell to Ruby would make things worse
14:33:30 <Cale> the nice list of what did how much allocation :)
14:33:55 <SamB> bosie: I think you are mixed up with shell and ghci
14:34:04 <joelr1> SamB: what bites is rewriting the structure formats, i.e. those 350 records and sub-records by hand
14:34:14 <joelr1> Cale: let me generate the profile
14:34:16 <bosie> SamB no, actually it works in ghci too
14:35:06 <Cale> joelr1: space leaks are generally caused by thunks being created and not getting consumed
14:35:39 <joelr1> SamB: and my "scripting language" also has to be pretty and easy to use. so the tough job would be to write out the scores of record definitions and the pickling code for them
14:35:44 <Cale> these Commands that are getting generated -- what do you do with them?
14:35:47 <joelr1> Cale: i cannot do a retainer profile
14:35:53 <joelr1> Cale: i check them... or don't
14:36:06 <joelr1> Cale: basically, they are events, they get sent to the thread
14:36:17 <Cale> okay, when are they thrown away?
14:36:28 <joelr1> the thread has a dispatcher that pattern matches on commands and only a few commands are matched
14:36:44 <Cale> what happens to the others? Could they still be accessed?
14:36:50 <joelr1> Cale: no idea when they are thrown away. right after being analyzed. the onces that do get analyzed
14:36:55 <dcoutts> joelr1, another way to check if you really are retaining a lot of data is to run with a smaller fixed size heap. ./a.out +RTS -M100m -RTS
14:37:09 <joelr1> Cale: i suppose not. take a look at this example usage
14:37:14 <dcoutts> and see how small you can make it without it actually running out of heap space
14:37:59 * ibid would say "good night", but then everybody would think i'm leaving. on the contrary :)
14:38:06 <lisppaste2> joelr1 annotated #14302 with "sample usage" at http://paste.lisp.org/display/14302#3
14:38:49 <joelr1> dcoutts: hmm... so what happens when i run out of heap space? what do i realize? i already know that i run out of heap space because it happened to me yesterday and to the client. i actually see the virtual memory and real memory size growing 
14:38:55 <SamB> ibid: just say "good morning"
14:38:57 <Cale> joelr1: so the commands go directly to the dispatcher?
14:39:07 <SamB> nobody will know the difference!
14:39:24 <ibid> SamB: too early for that, and i will be going to bed in a few hours:)
14:39:42 <dcoutts> joelr1, -Mxxm fixes a maximum heap size. The program will stop if it runs out of heap space, and it will tell you that it did so.
14:39:58 <joelr1> Cale: they get sent to a TChan, pulled out of the TChan, given to the dispatcher... end of story since the "driver" recurses to read another event from the TChan
14:40:02 <Cale> I'm just wondering if there's somewhere the commands could be going where they'd sit around doing nothing for a long time
14:40:06 <Cale> aha
14:40:21 <Cale> is it possible that the TChan isn't getting read quickly enough?
14:40:24 <joelr1> dcoutts: but what does that give me? i already know it will run out of space
14:40:38 <joelr1> Cale: no, that's not an issue. it's request/reply
14:40:49 <dcoutts> joelr1, well it tells you how much you're retaining
14:40:55 <joelr1> Cale: but... not always since the server notifies me about other things
14:40:57 <SamB> joelr1: what is this about "the ones that do get analysed"?
14:41:00 <Cale> perhaps you should force the Commands before dropping them into the TChan
14:41:10 <SamB> ibid: good evening?
14:41:14 <joelr1> dcoutts: i see. i'd rather know where not how much :-)
14:41:18 <ibid> SamB: it's past midnight :)
14:41:20 <Cale> like, seq them
14:41:27 <SamB> tchans, huh?
14:41:30 <dcoutts> as opposed to merely how much is being allocated and then reclaimed (which should be what is going on with the large lists [Word8])
14:41:33 <Cale> or deepSeq/rnf them
14:41:39 <joelr1> Cale: force to be evaluated? i think i do 
14:41:43 <Cale> though that will be a pain with 250 constructors
14:41:51 <joelr1>        {-# SCC "writeLoop#post" #-}post $! Cmd cmd
14:41:58 <Cale> hmm
14:41:59 <joelr1> SamB: see the paste annotation
14:42:03 <joelr1> dispatcher
14:42:03 <dcoutts> joelr1, if the retained size is very large then you've probably got a space leak rather than just doing lots of temporary list allocations.
14:42:11 <Cale> post $! (Cmd $! cmd) ?
14:42:21 <joelr1> dcoutts: i DO have a space leak
14:42:33 <joelr1> Cale: interestig idea, let me try
14:42:49 <dcoutts> joelr1, well then the lists & pickling is just a distraction
14:43:05 <joelr1> dcoutts: correct. that would be problem #xxxxx
14:43:21 <Cale> the first $! isn't going to do much but force the Cmd constructor there
14:43:32 <dcoutts> joelr1, can you do a time profile?
14:43:37 <joelr1> dcoutts: i'm not being told things need to run fast, i'm being told they just need to run. so long as i can run 10000 bots within 1gb of memory on a machine that does nothing else then i'm fine
14:43:49 <joelr1> dcoutts: you mean +RTS -Sgc-stats
14:44:17 <dcoutts> joelr1, I can't remember the exact command, but just an ordinary time profile.
14:44:24 <syntaxfree> paper.
14:44:35 <Cale> hmmm
14:44:38 <joelr1> dcoutts: hmm... i'll need to look it up
14:44:39 <Cale> actually, I have an idea
14:44:44 <stepcut> hrm.. too bad sin does not have the type sin :: (Floating a, Floating b) => a -> b
14:44:45 <joelr1> dcoutts: let me just do -hc first
14:45:13 <joelr1> let me just have this run for a few minutes to generate enough garbage
14:45:14 <dcoutts> joelr1, when I was debugging c2hs's space leak problems, the time profile was helpful
14:45:31 <Cale> joelr1: I take it that it would be a massive pain to write an NFData/DeepSeq instance for commands?
14:45:41 <joelr1> dcoutts: do you recall the +RTS option?
14:45:48 <joelr1> Cale: massive
14:45:55 <joelr1> Cale: they are already ! for each field
14:45:57 <dcoutts> joelr1, http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
14:46:10 <joelr1> and i'm doing Cmd $!
14:46:19 <joelr1> Cale: shouldn't that cover it?
14:46:21 <Cale> joelr1: okay
14:46:25 <Cale> yeah
14:46:29 <Cale> that should work
14:46:35 <Cale> see if that helps any
14:46:37 <dcoutts> joelr1, and there are heap profiles other than retainer set ones
14:46:43 <jethr0> samb: hi
14:46:57 <Cale> I get the impression that code is getting left unevaluated in the TChan.
14:47:00 <joelr1> dcoutts: give me a minute
14:47:11 <Cale> at least if it was evaluated, it would be small
14:47:41 <joelr1> dcoutts: i'm gonna generate a regular profile first, -hc
14:47:54 <joelr1> then the time profile. let me run this to generate enough garbage
14:47:58 <Cale> joelr1: are you often blocking because the TChan is empty, or are there almost always elements left in it? Could the TChan be filling up?
14:48:07 <joelr1> Cale: what does that mean? unevaluated in the TChan? 
14:48:21 <joelr1> Cale: shouldn't it be discarded after being retrieved and passed to the dispatcher?
14:48:32 <Cale> joelr1: I'm thinking it should be
14:48:41 <joelr1> Cale: i doubt it's filling up. all the dispatchers do is analyze the command and reply
14:48:55 <Cale> hmm
14:49:21 <joelr1> i'm doing +RTS -p -hc -S...
14:49:24 <Cale> like, everything else here looks really rather small to me
14:49:28 <joelr1> except i forgot the -p :(
14:49:33 <joelr1> need to re-run now
14:49:34 <joelr1> dang
14:49:44 <SamB> jethr0: hello
14:49:56 <jethr0> how are things?
14:50:35 <SamB> joelr1: dude, I thought the time/allocation profile was a regular profile
14:50:56 <joelr1> without -p .prof is not generated i think
14:51:09 <SamB> joelr1: true!
14:51:19 <joelr1> but i will post the gc stats and the postcript from hp2ps
14:51:22 <joelr1> s
14:51:25 <joelr1> need a minute
14:51:30 <SamB> however, which seems like a more "ordinary" way to profile? -p or -hc?
14:51:44 <joelr1> SamB: why does it matter? 
14:51:55 <joelr1> SamB: i'm not following you
14:52:34 <SamB> joelr1: you referred to -hc as ordinary
14:52:47 <joelr1> SamB: sorry, doing lots of things at the same time
14:52:50 <SamB> hehe
14:53:15 <SamB> well, its not "incorrect" per se, just rather strange
14:54:53 <Cale> hmm
14:55:26 <Cale> packet <- hGet h size -- how big is "size" likely to be?
14:55:44 <joelr1> size... up to 10k but no more, i thinik
14:55:49 <Cale> okay
14:55:51 <joelr1> i have not seen more than 2k in fact
14:56:01 <Cale> okay, that's still quite large
14:56:15 <joelr1> folks, can you download http://wagerlabs.com/randomplay-gc.txt.gz
14:56:54 <Cale> unstuff packet returns a Command, but if that Command isn't evaluated, you have to hang onto that list of 2k bytes
14:57:17 <joelr1> Cale: for how long?
14:57:23 <Cale> until the command is forces
14:57:26 <Cale> forced*
14:57:27 <joelr1> Cale: you mean if it's not eval'd right away?
14:57:29 <Cale> yeah
14:57:35 <joelr1> Cale: so we should see good results now then
14:57:39 <Cale> hopefully
14:57:41 <joelr1> Cale: since i'm forcing it to be evaluated
14:57:56 <joelr1> running +RTS -p -hc -S... now
14:58:00 <Cale> yeah, and lists have quite a lot of overhead
14:58:05 <joelr1> a few more minutes to let it generate stuff
14:58:10 <Cale> each of those Word8's is boxed
14:58:22 <Cale> and then you have cons cells
14:58:25 <SamB> joelr1: at the very least it ought to bump : and W# down from #1 and #2...
14:58:45 <joelr1> hmm... why would Word8 be boxed?!
14:58:47 <SamB> Cale: he has observed this ;-)
14:59:05 <SamB> joelr1: because of the kind of []
14:59:11 <SamB> @kind []
14:59:12 <lambdabot> * -> *
14:59:23 <joelr1> Cale: yeah, if i do a profile by constructore/closure i get : (colon) and W#8 at the top of the list 
14:59:32 <SamB> whereas
14:59:34 <SamB> @kind ->
14:59:35 <lambdabot> parse error on input `->'
14:59:39 <SamB> @kind (->)
14:59:40 <lambdabot> ?? -> ? -> *
14:59:52 <Cale> yeah, that's likely your problem then
14:59:54 <joelr1> ok, killing threads 
15:00:10 <Cale> joelr1: it's boxed because it's lazy
15:00:16 <joelr1> making them exit in an orderly fashion that is
15:00:25 <Cale> The evaluation of any particular Word8 can be deferred.
15:00:32 <joelr1> soon i'm gonna have my profile reports
15:00:37 <SamB> @kind GHC.Prim.Word#
15:00:38 <joelr1> got it
15:00:38 <lambdabot> #
15:00:53 <joelr1> should i tar up the gc stats and *hp or should i convert hp to ps?
15:01:01 <joelr1> Cale? dcoutts? SamB
15:01:01 <joelr1> ?
15:01:16 <SamB> joelr1: hp to ps
15:01:29 <SamB> its completely incomprehensible raw anyways
15:01:58 <SamB> I mean, the fileformat makes sense
15:02:26 <Cale> what I'm seeing in that text file is every once in a while, a big chunk of bytes is collected, which I think is probably a command being evaluated, and the huge list of Word8's getting dropped
15:02:37 <Cale> but it's not happening often enough
15:02:51 <SamB> well, okay, maybe it can be
15:03:10 <joelr1> http://wagerlabs.com/randomplay.tgz
15:03:18 <dcoutts> so the guess is that the pickeled form is being kept about for too long before being written out to the socket?
15:03:25 <joelr1> both the -hc postscript and the gc stats
15:03:37 <joelr1> this is with this
15:03:37 <dcoutts> and the pickeled form is very non-compact
15:03:44 <joelr1>        {-# SCC "writeLoop#post" #-}post $! Cmd $! cmd
15:04:04 <joelr1> dcoutts: the pickled form should be written out right away
15:04:11 <joelr1> but i had some funky behavior like this
15:04:24 <Cale> joelr1: does that look better to you?
15:04:34 <joelr1> goToTableT (State table) (Cmd SrvConnectGameOk {}) = 
15:04:34 <joelr1>     do trace 10 $ "Connected to game #" ++ show table
15:04:34 <joelr1>        stoptimer "goToTableT"
15:04:34 <joelr1>        postSnippetEvent $ JoinedTable table
15:04:34 <joelr1>        return Stop
15:04:38 <SamB> musasabi: how is that polishing going?
15:04:57 <Cale> joelr1: when did you start killing threads?
15:04:58 <joelr1> so it would print out the connected to... then two minutes would pass or three even and then it would print out what the snippet thing prints
15:05:06 <joelr1> postSnippetEvent a = 
15:05:06 <joelr1>     do trace 85 $ "Posting " ++ show a
15:05:06 <joelr1>        post $ Custom $ toDyn a
15:05:06 <SamB> if it isn't done, just record a patch called something like "JUNK PATCH" and let me pull it
15:05:18 <joelr1> Cale: does not look a lot better. let me look at the gc stats
15:05:32 <joelr1> Cale: what do you mean when? that's just a timer thread
15:06:04 <joelr1> Cale: i don't know if it's because i let it run longer but memory use actually increased 
15:06:09 <joelr1> according to the gc stats
15:06:16 <Cale> hehe, in order to interpret that memory usage
15:06:33 <joelr1> dcoutts: looking at the time profile
15:06:43 <Cale> it peaks around 6-7 seconds
15:06:53 <Cale> and then falls sharply
15:07:02 <Cale> and drops off
15:07:39 <joelr1> Cale: i ran it for longer than 6 seconds. a few minutes more like it but.. tail the gc stats file
15:07:47 <joelr1> the resident size is 110mb
15:08:50 <joelr1> dcoutts: i must be dumb, i see a reference to ghcprof under time profiling but not much else
15:08:58 <joelr1> i forgot to post the profile report
15:09:07 <joelr1> http://wagerlabs.com/randomplay.prof
15:09:28 <joelr1> dcoutts: what do you make of it?
15:09:59 <joelr1> dcoutts: is that what you wanted to see?
15:10:08 <Cale> hmm, what does reconnect do?
15:10:30 <joelr1> reconnect kills the network client threads and starts a new network client but
15:10:41 <joelr1> don't pay attention to that, it's all about read
15:10:53 <joelr1> i kept narrowing it down by inserting the cost center annotations 
15:11:03 <joelr1> and it boiled down to read in writeLoop
15:11:06 <Cale> ah, I see
15:11:21 <joelr1> writeLoop#read   Script.PokerClient                                   305         220  69.7   64.9    69.7   64.9
15:11:28 <joelr1> that's where most of the time seems to be spent as well
15:11:32 <joelr1> glorious program
15:11:47 <Cale> can you add some SCC's to read?
15:11:49 <joelr1> most of the time is spent reading packets and collecting garbage
15:12:02 <joelr1> or should i say generating garbage and then collecting it? :-)
15:12:08 <wilx> :)
15:12:28 <joelr1> Cale: i tried it before but it did not display any of the entries at the top of the list, etc. 
15:12:33 <joelr1> Cale: should i try again?
15:12:45 <Cale> um, yeah
15:12:49 <joelr1> ok
15:12:50 <joelr1> sec
15:13:05 <Cale> I'd just like to see the division of responsibility :)
15:13:40 <joelr1> recompiling
15:13:51 <Cale> It's funny, I've never actually profiled one of my own programs
15:13:51 <dcoutts> joelr1, so if the total size is just 110Mb then you probably don't have a space leak
15:14:05 <joelr1> dcoutts: why do you say so?
15:14:09 <Cale> dcoutts: look at the picture
15:14:37 <psi> dcoutts, i recall getting this error before when building gtk2hs: ghc-6.4.1: can't find file `glib/system/Glib/Types.hs'. i don't recall the fix...
15:14:38 <dcoutts> but I've noticed before a difference between the minimum heap size a program needs and the heap size the GC stats report.
15:14:55 <dcoutts> I found that with debugging c2hs's memory consumption problems.
15:15:25 <joelr1> dcoutts: which way was the difference?
15:16:05 * SamB prints out
15:16:08 * joelr1 is running the program with read divided by cost center
15:16:10 <dcoutts> joelr1, it would need 400Mb heap to run but the gc stats said it needed much less.
15:16:17 <joelr1> dcoutts: i'm dead
15:16:20 <joelr1> :(
15:16:23 <joelr1> busted
15:16:29 <joelr1> left to rewrite in scheme or ruby
15:16:30 <Cale> oh, supper
15:16:34 <joelr1> dcoutts: if that is the case
15:16:35 <Cale> I'll have a look after
15:16:40 <joelr1> :-)
15:17:03 <dcoutts> joelr1, from that profile I'd say it probably is just the [Word8] thing
15:17:20 <joelr1> my hope rests with Simon M. fixing up the retainer profile tomorrow 
15:17:35 <dcoutts> joelr1, in the abcense of a retainer profile telling us that there is a lot of stuff being retained by some part of the program
15:17:40 <joelr1> dcoutts: did you look at the pickler paper by chance?
15:17:46 <dcoutts> joelr1, yep
15:17:52 <joelr1> dcoutts: i did not generate a retainer profile!
15:17:59 <joelr1> dcoutts: i cannot, ghc crashes
15:17:59 <dcoutts> joelr1, I know
15:18:09 <joelr1> dcoutts: oh, ok
15:18:33 <joelr1> dcoutts: i would love to know how to rewrite pickler combinators to use arrays while keeping the whole thing pure
15:18:43 <joelr1> hopefully without changing the external interface
15:18:49 <joelr1> i can even contribute the code
15:18:49 <dcoutts> joelr1, it looks like one would just have to change the type St = String to use something based on an array
15:18:56 <joelr1> hang on
15:18:57 <dcoutts> and then chage the few primitive picklers
15:18:58 <joelr1> let me paste the code
15:19:15 <SamB> I notice "/recon" at the end of this first item on the heap profile graph...
15:19:25 <lisppaste2> joelr1 annotated #14302 with "pickler combinators" at http://paste.lisp.org/display/14302#4
15:19:45 <joelr1> dcoutts: ideally, i would like to keep the external interface the same 
15:19:53 <joelr1> so that i don't have to rewrite my 300 records
15:19:58 <dcoutts> sure
15:19:59 <joelr1> SamB: yes?
15:20:09 <joelr1> ok, i got a new run
15:20:11 <joelr1> second..,
15:20:19 <joelr1> one second to upload results
15:20:45 <dons> moin
15:21:06 <dcoutts> hia dons 
15:21:21 <dons> hey dcoutts
15:21:41 <joelr1> http://wagerlabs.com/randomplay.tgz
15:21:46 <SamB> joelr1: you could use typeclasses to write your scheme or ruby code for you ;-)
15:21:56 <joelr1> prof, ps and gc stats, so fresh i did not even look at it yet
15:22:04 <joelr1> SamB: argh
15:22:41 <dcoutts> joelr1, It'd probably even be possible to pickle/unpickle directly from a Handle without changing the external interface (except for the top level functions)
15:23:19 <joelr1> Cale: this bugs me, see. i put in the cost center annotations into read but they do not even show up
15:23:20 <jethr0> dons: moin moin
15:23:22 * SamB realizes why Cale seems to always be on
15:23:59 <joelr1> Cale: show up in the postscript that is
15:24:00 <moonlite> how do i convert EpochTime to something more usable?
15:24:24 <SamB> joelr1: I say you could generate code with Haskell to run in another language
15:24:29 <joelr1> dcoutts: you are talking while looking at my paste, right? the annotation titled picklers?
15:24:37 <dcoutts> joelr1, yep
15:24:38 <joelr1> SamB: yes, i understood you
15:24:52 <SamB> joelr1: well, if this doesn't work out, I mean
15:24:53 <jethr0> Cale: samb seems to have a problem with you listening to the channel while eating...
15:24:55 <joelr1> dcoutts: i tried this but could not figure it out without changing the external interface
15:25:24 <SamB> joelr1: are they exhaustive?
15:25:43 <joelr1> SamB: yes, but check this out... i already spent about 8 weeks on this, i billed the client for something like 3 weeks of work and this was a fixed-price project
15:25:55 <SamB> jethr0: no!
15:26:03 <joelr1> granted, i'm a decent haskeller now but still... i got cooler haskell projects to start next week
15:26:04 <jethr0> ;-)
15:26:11 <joelr1> SamB: what is exhaustive?
15:26:17 <SamB> let me look at the map
15:26:17 <SamB> @map
15:26:17 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:26:40 <SamB> joelr1: your SCCs
15:27:38 <lisppaste2> joelr1 annotated #14302 with "cost centers" at http://paste.lisp.org/display/14302#5
15:27:52 <joelr1> SamB: they show up on the PROF report but not in the heap report
15:28:26 <joelr1> so what was that about list fusion? it would not work for me? 
15:29:00 <joelr1> SamB: i'm supposed to start a collusion detection project next week, very much like dazzle, that would definitely be the job for haskell
15:29:12 <SamB> joelr1: hmm, I'd need to look at your pickler paper...
15:29:15 <joelr1> collusion detection in poker that is, data analysis
15:29:21 <joelr1> @google pickler combinators
15:29:22 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
15:29:25 * SamB looks
15:29:38 <joelr1> i gotta finish this one first, though
15:29:49 * joelr1 is praying for a miracle
15:30:21 <jethr0> joelrl, where do get these projects? are you freelancing them?
15:30:28 <jethr0> you
15:30:32 <joelr1> jethr0: 100%
15:30:36 <SamB> joelr1: I already had it right here on my disk, thank you ;-)
15:31:05 <jethr0> cool, and how do you advertise? i imagine it being hard to wait for people to let you solve their probs in haskell, no?
15:31:27 <joelr1> jethr0: i wrote poker software on my own for a year, living hand to mouth, etc. the venture was a commercial failure but i'm reaping dividends now
15:31:38 <SamB> joelr1: so, does your pickling reflect Fig. 2?
15:31:39 <jethr0> so you got visibility.
15:31:40 <joelr1> http://wagerlabs.com/ click on the openpoker category
15:31:47 <dcoutts> joelr1, appP and appU look very much like reader and writer monads
15:31:50 <joelr1> SamB: check the paste, it's there, paste #4, all the code
15:31:57 <jethr0> are you writing this next program for one of your poker "competitors"?
15:32:21 <joelr1> dcoutts: yeah, i tried making them into one :D but i tried to make them into one monad, though, my big mistake
15:32:28 <joelr1> jethr0: 100%
15:32:34 <dcoutts> joelr1, right, they are different monads
15:32:47 <dcoutts> but the actions are paired together
15:32:51 <joelr1> jethr0: i got some visibility,  yes
15:32:55 <joelr1> dcoutts: correct
15:33:13 <joelr1> dcoutts: the cool bit is being able to define the format once and then use it for pickling and unpickling
15:33:22 <joelr1> dcoutts: as opposed to defining get bh and put bh
15:33:28 <dcoutts> joelr1, and I imagine they could be layered over some handle IO monads
15:33:35 <jethr0> cool, so living hand to mouth has actually worked out for you. congratulations!
15:33:42 * joelr1 bows
15:33:50 * jethr0 bows even deeper
15:33:55 <joelr1> dcoutts: well... lets see
15:34:12 <dcoutts> joelr1, eg a HandleReader monad and a HandleWriter monad which allow one to read/write bytes to an embeded handle
15:34:24 <joelr1> dcoutts: i have a lot of code like this
15:34:25 <joelr1> puCommand (68, 1) =
15:34:25 <joelr1>     sequ name wstring
15:34:25 <joelr1>              (\a -> sequ regCode (enum byte)
15:34:25 <joelr1>               (\b -> lift $ 
15:34:27 <joelr1>                      SrvRegistrationFail a b
15:34:30 <joelr1>               ))
15:34:32 <joelr1> a LOT of code like that
15:34:44 <joelr1> i already rewrote it a couple of times and it was extremely unpleasant :(
15:35:16 <dcoutts> the IO should not be visible in any combinatros except the top level pickle and unpickle
15:35:33 <joelr1> dcoutts: show me the way!
15:35:46 <psi> http://pastebin.com/448934 <- it's a gtk2hs build error. i've had it before but i don't remember how i got rid of it.
15:36:37 <joelr1> dcoutts: can you perform a miracle? :D
15:37:57 <dcoutts> psi, try make clean
15:38:22 <dcoutts> joelr1, I'll have a go in the morning.
15:38:29 * dcoutts goes to bed
15:38:40 <joelr1> dcoutts: thanks
15:39:27 <psi> make clean doesn't help
15:39:57 <psi> in fact it was freshly extracted
15:41:28 <jethr0> ok, time for bed
15:41:32 <jethr0> nite @ll
15:42:48 <syntaxfree> pink.
15:42:58 <SamB> dcoutts: is make clean clean enough?
15:43:40 <astrolabe> he's gone to bed
15:44:45 * SamB supposes joelr1 might like to read a paper on list fusion to pass the time?
15:44:56 <joelr1> SamB: sure :-)
15:48:39 * SamB tries to find the right one
15:48:51 * SamB is pretty sure it has spj's name on it
15:48:51 * SamB could be wrong, though
15:50:21 <JohnMeacham> add yerselves http://www.frappr.com/haskellers
15:51:11 <joelr1> JohnMeacham: there's no zip code for tenerife :(
15:51:54 <joelr1> hey, i can see meself!!!
15:52:34 <SamB> JohnMeacham: Frappr is inferior! it does not allow sufficient resolution!
15:53:55 <JohnMeacham> probably true.
15:54:00 <SamB> okay, so it does have zoom...
15:54:10 <JohnMeacham> joelr1: you are in the ocean?
15:54:20 <joelr1> JohnMeacham: smack in the middle :D
15:54:30 <joelr1> canary islands
15:54:33 <SamB> but a lot of good that does when all you can say is what city you are in...
15:58:27 <Philippa> I wouldn't want to tell it any more than that anyway
15:58:59 <astrolabe> Given a set of vectors, and a target vector, how can I efficiently find the subset of the set whose sum is closest to the target?
15:59:26 * SamB explores citeseer to find it on his disk
15:59:59 <JohnMeacham> sounds like an odd multidimensional knapsack problem.
16:00:47 <astrolabe> Hmmm, maybe, but you have to get under the limit with the knapsack IIRC
16:01:12 <astrolabe> But I should think about the 1d case
16:02:44 <astrolabe> Even that seems hard
16:04:33 <astrolabe> I should go to bed.  SamB, if you find it, could you make a note, and I'll see you on here.  thanks.
16:04:41 <astrolabe> Night all.
16:04:44 <dons> @seen phys_rules
16:04:45 <lambdabot> I saw phys_rules leaving #haskell 28 minutes and 35 seconds ago.
16:04:49 <dons> doh!
16:09:30 * SamB wishes for a search engine that could index his own PS and PDF files
16:09:55 <gzl> well, spotlight searches pdfs.
16:10:45 <SamB> ah, here we go
16:10:45 <SamB> maybe it is "playing by the rules" ;-)
16:11:21 <SamB> dons: you should be interested in this too
16:11:27 <SamB> http://citeseer.csail.mit.edu/peytonjones01playing.html
16:11:40 <stepcut> how do I convert between CFloat and Float ?
16:13:04 <SamB> also http://research.microsoft.com/Users/simonpj/Papers/rules.htm
16:17:41 <SamB> dons: you know, its about those RULEs?
16:18:05 <Heffalump> stepcut: isn't CFloat a member of any useful type classes?
16:19:01 <ndm> @hoogle CFloat -> Float
16:19:02 <lambdabot> No matches, try a more general search
16:19:51 <joelr1> SamB: which type of array do you think i should choose to swap out [Word8] in picklers?
16:22:32 <SamB> joelr1: well, for reading, you can use IOUArray and unsafeFreeze it to UArray
16:22:55 <joelr1> SamB: how about STUArray?
16:23:07 <joelr1> SamB: or it does not matter?
16:23:33 <SamB> joelr1: that would work too
16:23:57 <stepcut> Heffalump: the best I can find is realToFrac ... but it seems to require an awful lot of processing power considering data CFloat = CFloat Float
16:23:58 <joelr1> SamB: did you look at the picklers paper?
16:24:13 <joelr1> i'm looking to plug in the ST monad
16:24:14 <stepcut> I just changed my code to use CFloats natively instead :p
16:24:21 <SamB> joelr1: yeah
16:24:28 <SamB> a little
16:24:51 <musasabi> SamB: http://cs.helsinki.fi/u/ekarttun/haskell/SerLang.hs
16:25:35 <joelr1> musasabi: how is memory usage with that?
16:25:56 * stepcut goes out for treats
16:26:18 <SamB> http://research.microsoft.com/Users/simonpj/Papers/andy-thesis.ps.gz
16:26:28 <musasabi> joelr1: that is of the pretty variety, I haven't done performance tweaks for that.
16:26:46 <SamB> joelr1: well, bittorrent protocol messages aren't nearly as complicated as those you will be dealing with
16:27:02 <joelr1> musasabi: can you read little-endian fields with that?
16:27:07 <SamB> and we aren't planning on more than 50 connections at a time, as far as I know
16:27:15 <joelr1> oh
16:27:21 <musasabi> joelr1: yes, but that does that in Haskell (you want to use FFI for that in real code)
16:27:34 <joelr1> but this looks very similar to what i'm doing
16:27:55 <musasabi> joelr1: if you want performance tweaked version you can look at http://cs.helsinki.fi/u/ekarttun/haskell/DNS/
16:28:06 <musasabi> MutableEnv.hs + LoWire.hs in special.
16:28:16 <joelr1> right down to this stuff
16:28:16 <joelr1> string= Conv (fmap (toEnum . fromEnum)) (fmap (toEnum . fromEnum)) (List w32be W8)
16:28:30 <musasabi> that is not as pretty but has quite good memory characterisc (the DNS one)
16:28:52 * joelr1 is wondering if he should use musasabi's code
16:29:29 <musasabi> feel free to scourge it if you want, BSD3 license for both that and the DNS one.
16:30:16 <joelr1> what i really need is to plugin in STUArray into the pickler combinators 
16:30:30 * musasabi likes Ptrs better
16:30:35 <joelr1> that would let me avoid changing the external interfaces
16:30:41 <musasabi> point
16:30:45 <joelr1> musasabi: i could do ptr too but i couldn't figure out how to
16:31:04 <joelr1> musasabi: basically, it requires me to pre-calculate the size of the record before pickling it
16:31:08 <SamB> musasabi: what does it do?
16:31:08 <joelr1> to allocate the memory buffer
16:31:36 <musasabi> SamB: short pretty extensible parser/prettyprinter in one.
16:31:40 <joelr1> musasabi: and then i need to define Storable a, Storable b => Storable (a, b), etc.
16:31:46 <SamB> also, what do we want with 16-bit numbers?
16:32:09 <musasabi> SamB: nasty protocols which use them on-wire.
16:32:49 <SamB> BT only uses 32 bit numbers in the wire protocol, iirc
16:33:13 <SamB> musasabi: so you want me to add this to the repo?
16:33:43 <SamB> I can't actually put it up on j.mongers.org or anything
16:34:24 <musasabi> SamB: for conjure? Sure you can use it if you want to.
16:34:38 <SamB> joelr1: a warning: that uses FPS, which is under the GPL...
16:34:53 <joelr1> ok
16:34:55 <SamB> musasabi: so that wasn't that thing you were doing for conjure?
16:34:56 <musasabi> SamB: of course there are versions of FPS which are free..
16:35:04 <SamB> musasabi: oh?
16:35:11 <joelr1> i'm actually trying to modify my pickling stuff to move away from lists
16:35:23 <musasabi> SamB: fps was relinces to GPL by dons.
16:35:31 <SamB> oh
16:35:37 <SamB> hmm.
16:35:45 <SamB> and do the others have repos?
16:35:59 <musasabi> or actually it was GHC (BSD) -> Darcs (GPL (and possiblity of BSD - or at least droundy said so iirc)) -> dons (GPL)
16:36:11 <SamB> ah
16:36:28 <musasabi> then JHC has it's own PackedString which comes from the GHC one (don't remember the license of that one)
16:36:46 * SamB supposes his little RULE isn't going to be covered by copyright anyways
16:37:08 <musasabi> The whole FastPackedString is ~5 lines there which can be converted to work with any of the implementations in a trivial way.
16:37:30 <SamB> so, what were you doing for conjure?
16:51:07 <musasabi> hmm, I thougth I was working on general purpose code for fixed thing serialization.
16:51:43 <Korollary> FPS is nice, but not enough.
16:52:14 <musasabi> The WireProtocol.hs looks already quite nice.
16:52:25 <Korollary> @where WireProtocol
16:52:26 <lambdabot> I know nothing about wireprotocol.
16:53:05 <Korollary> lambdabot is case insensitive in its rejections...
16:53:27 <musasabi> Korollary: I was talking about the conjure WireProtocol code which uses parsec.
16:53:42 <Korollary> what is conjure?
16:54:14 <musasabi> A haskell bittorrent client
16:54:19 <Korollary> shapr's ?
16:54:25 <musasabi> I could adapt that serialization code to conjure
16:54:45 <musasabi> Korollary: I think shapr did the initial code, but jlous is maintaining it now (I could be wrong)
16:54:58 <Korollary> ah
16:57:50 <Korollary> FPS.hGetContents stdin >>= FPS.hPut stdout (FPS.map id (FPS.reverse slurp))
16:58:13 <Korollary> bah
16:59:14 <Korollary> FPS.hGetContents stdin >>= (FPS.hPut stdout . FPS.reverse)
16:59:36 <Korollary> This is really fast. It gets done under a second for a 25M file.
16:59:53 <Korollary> FPS.hGetContents stdin >>= (FPS.hPut stdout . FPS.reverse . FPS.map id)
17:00:09 <Korollary> this takes 10 secs and uses 400M for the same input.
17:00:12 <SamB> shapr had the idea and did something with some of the code
17:02:44 <SamB> Korollary: well, what do you expect?
17:03:23 <SamB> you didn't expect map to be efficient over packed strings, did you?
17:03:33 <Korollary> SamB: It's FPS's own map.
17:03:38 <SamB> even so
17:03:49 <Lemmih> Korollary: You could write a rule for 'FPS.map id = id'
17:03:58 <SamB> but that would be silly
17:04:31 <SamB> musasabi: oh, I see
17:04:50 <Lemmih> Does FPS contain the 'map f . map g = map (f . g)' rule?
17:04:52 <SamB> musasabi: well, jlouis has been having some trouble keeping up lately
17:05:10 <SamB> Lemmih: no! it has, to my knowledge, exactly one RULE
17:05:31 <SamB> let me pull first to make sure, though...
17:05:33 <musasabi> SamB: Looking at the current wireprotocol I think the most important thing is lifting the Piece out of parsec + adding checks that pieces are below some reasonable size.
17:05:44 <Korollary> Lemmih: Actually I want to use a function other than id.
17:05:54 <Korollary> Lemmih: It was just an example.
17:05:58 <SamB> Korollary: you do?
17:06:30 <JohnMeacham> the one is jhc was modified from the ghc one in order to make it a CPR type and always store things in utf8 no matter what.
17:06:31 <Korollary> SamB: Yes, it's a table based character conversion. But of course it's slower than id.
17:06:37 <SamB> ah
17:07:33 * SamB is actually in that file hoping to add more RULEs and related things
17:07:47 <JohnMeacham> the jhc one can be used by anyone for any purpose, I didn't gpl my changes so it is still under the ghc (3bsd) license.
17:08:21 <lispy> JohnMeacham: does jhc have gc yet?  I'd like to play with it to see just how much faster it is than, say, ghc.
17:08:40 <SamB> lispy: who says it is going to have GC?
17:08:50 <lispy> heh
17:08:59 <lispy> i assumed
17:09:10 <SamB> I think he had more incomprehensible plans in that area
17:10:04 <lispy> maybe i should be asking how complete is jhc these days
17:11:10 * lispy find it on google
17:12:34 * SamB is astounded by the huge cases in a lot of these functions, and boggles as to how to possibly implement list fusion on them...
17:12:56 <JohnMeacham> it is not really faster at the moment except in a few cases where it can me drastically faster (and others where it is drastically slower) I have been working on the front end recently to get it ready for haskell-prime. you can compile with -fbohem to use the bohem GC.
17:13:27 <SamB> JohnMeacham: didn't you misspell his name?
17:13:35 <Korollary> Boehm?
17:13:49 <JohnMeacham> BTW, CPR types and {-# UNPACK #-} are key for speed in both ghc and jhc.
17:13:53 <lispy> ah, cool
17:13:57 <JohnMeacham> very likely, I misspell a lot of things.
17:14:04 <lispy> CPR?
17:14:18 <SamB> Korollary: you did compile with -O?
17:14:20 <JohnMeacham> data types with only one constructor.
17:14:35 <Korollary> SamB: Yes
17:16:04 <SamB> okay, I have no idea whats using so much space!
17:16:22 * SamB profiles
17:16:27 <SamB> what was that code again?
17:16:33 <Korollary> I'll paste it
17:16:56 <Korollary> lisppaste2: url
17:17:03 <Korollary> aaaa
17:17:10 <JohnMeacham> I am hoping jhc will be fully haskell-prime compliant as the spec is being developed.
17:17:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:17:27 <SamB> haskell-prime, eh?
17:17:58 <SamB> so is that to become Haskell 2.0?
17:18:04 <SamB> or 1.9 or something?
17:18:15 <lisppaste2> Korollary pasted "aaaa" at http://paste.lisp.org/display/14312
17:23:53 <JohnMeacham> SamB it is just the working title for the next revision of the standard. the comittee is already working on it. but we are in brainstorming phase trying to document all possible extensions
17:23:57 <gzl> what's haskell prime?
17:24:48 <SamB> JohnMeacham: you mean all existing ideas for extensions?
17:24:55 <SamB> or what?
17:25:04 <SamB> clearly all possible extensions would be a bit excessive
17:25:15 <Korollary> It's a documentation phase anyway
17:25:31 <SamB> are they even countable?
17:25:44 <Korollary> They probably are :)
17:26:19 <SamB> I don't think you have a very good imagination
17:26:27 <Korollary> This is something that would take a few years I reckon.
17:27:01 <JohnMeacham> all existing ideas yeah.
17:27:21 <gzl> oh, he just answered my question before I asked it.
17:27:33 <JohnMeacham> Yeah, Haskell 98 didn't come out til 2001 or so I think?
17:27:40 <SamB> oh? really?
17:27:43 <SamB> heh
17:27:54 <SamB> thats worse than Windows 95, isn't it?
17:28:09 <Korollary> still named better than Java
17:28:16 <JohnMeacham> so, calling it Haskell '06 seems somewhat presumptuous. haskell-prime was chosen as a neutral working title.
17:28:38 <SamB> good idea
17:28:40 <gzl> is there anything about it decided yet?
17:28:45 <SamB> it sounds better than Chicago, too!
17:29:51 <JohnMeacham> no. nothing decided for sure. but looking at ghcs extensions will give a good idea :) though, it will likely be conservative with only minor backwards incompatabilites.
17:30:14 <SamB> heirarchical modules are in though, right?
17:30:39 <JohnMeacham> most definitely. they are almost a part of the standard as it is being an approved addendum.
17:31:00 <SamB> it would be really silly if it was forgotten that they weren't already in and they were left out by mistake...
17:31:08 <JohnMeacham> but they might be improved some, like the qualified exports idea from the mailing list.
17:31:13 <Korollary> Nobody would let them forget that heh.
17:31:22 <SamB> no, I suppose not.
17:31:28 <SamB> unless they forgot too ;-)
17:31:31 <JohnMeacham> like punning in haskell 98 :(
17:31:42 <SamB> punning?
17:31:50 <Korollary> tasteless jokes?
17:32:25 * SamB supposes Korollary's program would finish sooner with input
17:33:00 <Korollary> SamB: The input contents don't matter. You can create a 25M file with 'dd'.
17:33:28 <SamB> Korollary: yes, but it doesn't work too well if you just run it with no redirections and leave it sit there
17:34:04 <Korollary> SamB: You could build this program and run it with arg=2500000 (2.5M) http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc&id=0
17:34:17 <Korollary> It generates a 25M file
17:34:37 <SamB> I'm just running it over my House tarball, which is supposed to be 26 megs
17:34:44 <Korollary> that would do
17:35:04 <Korollary> It takes 10 secs on my athlon 1GHz
17:35:32 * SamB forgot to build with -O
17:35:37 * SamB rebuilds, trys again
17:36:21 <palomer> ugh
17:36:28 <Korollary> JohnMeacham: Would JHC be usable for H98 before haskell-prime is finalized?
17:36:30 <palomer> half the class I'm TAing got the assignment wrong
17:36:37 <palomer> even when I supplied a way for them to test it
17:42:01 <SamB> Korollary: takes longer here for some reason...
17:42:25 <SamB> I mean, a lot longer
17:42:25 <Korollary> SamB: "top" shows about 380M for me.
17:43:11 <SamB> I'm seeing 102 Virt and 72 Res
17:43:24 <SamB> but growing
17:43:32 <Korollary> How much physical mem do you have?
17:43:37 <SamB> dons: I think FPS.map has a space leak
17:43:43 <SamB> Korollary: a lot less than you
17:43:47 <SamB> 256 MiB
17:43:49 <Korollary> I have 512M
17:43:53 <Korollary> ah
17:44:39 <Igloo> SamB: What are you doing with it?
17:44:45 <SamB> Igloo: nothing!
17:44:57 <SamB> just mapping id over a packed string
17:45:03 <SamB> a large packed string, but still
17:45:11 <Igloo> What's the code, I mean?
17:45:24 <Korollary> Igloo: http://paste.lisp.org/display/14312
17:45:28 <Korollary> We're reversing it as well
17:45:51 <SamB> well, I don't imagine reverse is the culprit
17:45:56 <SamB> but I shall see
17:46:35 <Korollary> no, reverse is ok by itself. If you take FPS.map out, it's very quick.
17:46:58 <SamB> maybe I should do this on a smaller file?
17:47:28 <SamB> the trouble with this is that it reads the whole file at once so I have no idea how far along it is...
17:47:37 <Korollary> right. go for 10M or so then.
17:48:06 <SamB> how about 3?
17:48:30 <Korollary> heh 
17:48:54 <SamB> I don't have any files with sizes between those in my haskell dir, apparantly...
17:56:13 <SamB> Korollary: note that map is implemented in terms of mapWords
17:56:56 <SamB> dunno if that has anything to do with anything or not
17:57:38 <Korollary> Hmm
17:57:58 <Korollary> I think that "word" means Word8
17:57:59 * SamB notices he forgot to redirect output to /dev/null
17:58:06 <SamB> yes, it does
18:02:20 <SamB> hmm, maybe you ought to profile it yourself.
18:02:39 <SamB> don't suppose you have a set of libs built for profiling?
18:03:13 <Korollary> I think FPS README says it is un-profilable
18:03:31 <SamB> oh really?
18:03:35 <SamB> we'll see about that!
18:03:47 <Korollary> "Remember that FastStrings are allocated in C land, so don't appear in the heap usage"
18:03:52 <SamB> I'll go watch some anime
18:04:04 <SamB> I'm not trying to profile the strings themselves
18:04:47 <SamB> the problem here is with ordinary heap objects, presumably
18:05:14 <SamB> because there are only two packed string objects of interest to the FPS.map invocation 
18:05:43 <SamB> dons: if for some reason an attempt to profile FPS will in fact never terminate, I'm of course interested to know this...
18:13:17 <dons> hmm, what's the problem?
18:14:10 <dons> what, unprofilable? hmm. you can profile fps. what's all this crazy talk?
18:14:25 <dons> most fps strings are on the heap anyway
18:14:56 <Korollary> dons: http://paste.lisp.org/display/14312
18:15:12 <Korollary> To eat a 25M file, it uses about 400M on my machine.
18:15:46 <dons> running map on it?
18:16:08 <dons> remember it has to peek and poke each element.
18:16:24 <Korollary> heh
18:16:53 <dons> why not mmapFile ?
18:17:09 <Korollary> it has to be stdin.
18:17:20 <dons> P.hGetContents stdin >>= P.hPut stdout
18:17:21 <dons> works for me.
18:17:31 <Korollary> That works for me, too
18:17:46 <Korollary> it's when I put the reverse and map
18:17:54 <Korollary> just reverse is fine as well
18:18:14 <dons> revererse allocates a new string, and copies it. very fast.
18:18:19 <dons> map will be much slower though
18:18:28 <skew> are you reversing all of stdin?
18:18:33 <Korollary> yes
18:19:47 <skew> what type is map running at?
18:19:53 <skew> Char -> Char?
18:19:58 <dons> if possible, avoid map and use one of the specialised functions instead
18:20:06 <Korollary> "id", actually for now, but it's supposed to be a table based lookup.
18:20:53 <Korollary> I was trying to speed this benchmark up using FPS: http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=all
18:21:09 <skew> can you give me a link to your FPS library?
18:21:09 <Igloo> Why is map so much slower? Because of all the abstraction in mapIndexedWords?
18:21:27 <Korollary> skew: http://www.cse.unsw.edu.au/~dons/fps.html
18:21:44 <Igloo> Oh, and going via Char will hurt, i guess
18:21:50 <dons> Igloo, hmm. I think usually it's just the cost of peeking and poking Chars
18:22:07 <Igloo> But reverse essentially has to do that anyway
18:22:10 <dons> so using the non-higher order functions is almost always better
18:22:25 <dons> reverse is implemented in a top-secret super-fast way
18:22:25 <Korollary> Igloo: that was FPS.reverse
18:22:54 <dons> i.e.     while (p >= from)
18:22:54 <dons>         *q++ = *p--;
18:22:55 <dons> ;)
18:23:01 <Igloo> That's peek and poke
18:23:58 <skew> oh, why does that go through mapIndexedWords?
18:24:29 <dons> probably to save me writing too much code
18:26:11 <skew> have you looked at how those functions compile?
18:26:28 <dons> I've profiled, but I don't think I looked at map, nope.
18:26:51 <skew> ok, no excuse not to do it then
18:26:55 <Igloo> Isn't the problem is space rather than time, anyway?
18:27:19 <skew> I'm wondering if things are properly inlined and dead-code-eliminated. If I could just find that dump core option
18:27:31 <dons> -ddump-simpl ?
18:29:01 <dons> @seen phys_rules
18:29:02 <lambdabot> I saw phys_rules leaving #haskell 2 hours, 52 minutes and 51 seconds ago.
18:29:50 <skew> with -E and -ddump-simpl I'm just getting an hspp file, which doesn't even seem to actually be preprocessed
18:30:14 <dons> why are you using -E?
18:30:33 <skew> FastPackedString needs to be preprocessed
18:30:46 <skew> That's the wrong option?
18:31:07 <skew> oh, I probably want -cpp
18:31:07 <Igloo> You want -cpp
18:31:08 <dons> it'll preprocess itself. doesn't -E mean "stop after preprocessing?"
18:31:18 <skew> yeah, that sounds right
18:41:16 <palomer> yay, finished correcting!
18:41:20 <palomer> raise the roof!
18:46:45 <JohnMeacham> Korollary: depends on what you mean by "usable" :)
18:49:52 <SamB> dons: for some reason I get a really curvacious allocation graph for this
18:50:27 <dons> for P.map id ?
18:50:44 <SamB> dons: yes
18:51:08 <SamB> do you have DCC support?
18:51:53 <dons> nope, but try this (in #haskell-overflow)
18:57:45 <skew> that needs a few imports and #defines
18:58:23 <dons> you could work it out though ;)
19:02:10 <skew> well, import GHC.IOBase, import Foreign.Storable, import Foreign.ForeignPtr (mallocForeignPtrBytes), and s/offPS/plusPtr/
19:03:26 <SamB> oh, I was pasting that into Data/FastPackedString.hs
19:05:15 <skew> but I don't know about CHARBYTES
19:05:27 <Korollary> CHAR_BIT?
19:06:02 <dons> oh, sorry:
19:06:03 <dons> #define CHARBYTES (CHARBITS `quot` 8)
19:06:25 <dons> #define CHARTYPE Word8
19:06:25 <dons> #define CHARBITS 8
19:07:29 <skew> also, the PS in that snippet has a different argument order than FastPackedString.hs in the darcs repository
19:08:22 <skew> yeah, much better
19:08:35 <skew> 4x or so
19:08:38 <dons> yes, this is Simon's code. it doesn't support slices.
19:08:41 <dons> ah. good.
19:08:54 <skew> slices?
19:09:00 <SamB> what is offPS?
19:09:03 <SamB> oh
19:09:05 <dons> oh, wait, it does.
19:09:49 <dons> I should finish the merge of simon's great code, with the extra functions from fps.
19:10:22 <skew> what are these slices?
19:10:26 <SamB> then all we need is list fusion... or do they have that already?
19:10:42 <dons> skew, O(1) take and drop
19:11:02 <dons> non-copying take and drop
19:11:04 <skew> oh, so that's the start and length arguments in the PS then?
19:11:09 <dons> yep
19:11:48 * Cale shows up again
19:11:49 <Cale> hello
19:11:59 <Cale> no Joel
19:12:06 <skew> mapping (const 'B') over a string of a million characters took about 140ms with the old map, 33ms with the new
19:12:13 * Cale looks at profiling
19:12:26 <dons> cool
19:12:30 <Cale> it is unstuff where the allocation is happening, as I suspected :)
19:14:56 <skew> I was suspicious about the ability of GHC to optimize that code
19:17:54 <skew> declaring map and map_ inline didn't help
19:18:25 * SamB goes to heap profile
19:19:07 <skew> I was hoping an INLINE pragma would make the body availible so my little argument could be inlined
19:20:21 <palomer> ok, everytime a chick gives me a number, she seems to have phone problems right after
19:20:24 <palomer> is this a coincidence?
19:20:28 <Korollary> no
19:20:39 <Cale> hehe
19:20:48 <palomer> so...there's something behind it?
19:20:56 <SamB> its a conspiracy among telephone companies around the world
19:21:03 <Korollary> Some chicks don't worry about giving fake numbers to get rid of guys
19:21:06 <SamB> they don't want you to have a girlfriend
19:21:07 <kapheine> hey palomer, i remember you from channels such as #ruby-lang :P
19:21:14 <Cale> The government wants to make sure you never reproduce, and they're taking steps to ensure this.
19:21:29 <Korollary> You can carry a cellphone and call their bluff right there & then, heh.
19:21:39 <Cale> hehe
19:21:43 <SamB> Korollary: but they aren't home to take the call then
19:21:44 <palomer> nonono, the number works, and I leave a message
19:21:55 <palomer> and then I get an email a week later saying they had phone problems
19:22:06 <palomer> and that if I had called then they have not received my message
19:22:06 <Korollary> that's unlifted B.S.
19:22:16 <palomer> why would they even bother sending me an email?
19:22:32 <Korollary> Are you asking me to explain women?
19:22:48 <SamB> well, how do they get your email address?
19:22:50 <Cale> palomer: why not just send back an email with an equivalent message?
19:22:57 <Cale> clearly their mail is working :)
19:23:16 <palomer> I don't do mail.
19:23:19 <SamB> Cale: well, if the message was something like "can we do something this friday..."
19:23:21 <Cale> what?
19:23:38 <Cale> SamB: yeah, but next Friday is probably also open :)
19:23:41 <palomer> seriously, If I'm going to ask a chick out on a date, it's by phone
19:23:51 <Cale> palomer: on an answering machine?
19:23:54 <palomer> or in person
19:24:00 <SamB> hmm
19:24:04 <palomer> erm,  the answering machine message is "call me back"
19:24:09 <Cale> ah
19:24:13 <Korollary> email is a bit, soulless for such matters when face to face or phone is available.
19:24:15 <SamB> you should email them "call me back"
19:24:39 <palomer> but then it wouldn't be calling back, it would be "send a call in response to this mail" back
19:24:51 <Cale> hehe
19:24:53 <Korollary> too complicated.
19:24:56 <SamB> palomer: no, no, you can say "call me back" anyway
19:25:05 <Cale> since you already called
19:25:15 <palomer> but they wouldn't be responding to the call
19:25:31 <Cale> I think they'll get the picture anyway
19:25:45 <SamB> or you can leave a message and then send an email saying "check your phone messages"
19:25:49 <Cale> If they can't manage to figure it out, maybe it's for the best
19:25:59 <Korollary> Put a message in a bottle
19:26:02 <SamB> don't be so particular
19:26:10 <SamB> it sounds nicer to say "call me back"
19:26:25 <SamB> regardless of its literal correctness
19:26:28 <skew> Or, you could find a suitable formalism for writing a machine-checkable statement of what you mean, if you really want to scare them
19:26:46 <SamB> skew: that wouldn't make any sense
19:26:56 <SamB> having a machine check it won't help people understand it!
19:26:59 <palomer> Cale: intelligence is not on my list of criteria
19:27:00 <Korollary> scaring them can be fun.
19:27:10 <Cale> palomer: why not?
19:27:18 <SamB> palomer: yeah, why not?
19:27:21 <palomer> Cale: because it doesn't fit with the rest of the list
19:27:22 <Korollary> It's overrated.
19:27:27 <palomer> and yeah, it's overrated
19:27:31 <SamB> hmm
19:27:43 <SamB> yes, I do recall it never praises intelligence in the bible...
19:28:07 <Cale> I don't think I'd want to stay with someone who I couldn't talk to about what I've been doing.
19:28:10 <skew> oh, you could say "please call me(palomer(phone#)) in response to this(timestamp/md5sum) email
19:28:28 <Cale> md5sums are insecure
19:28:38 <SamB> Cale: so?
19:28:41 <skew> actually, getting the md5sum of a message in the text of the message would be a nice little problem
19:28:41 <Korollary> use a verisign cert
19:28:57 <Cale> skew: you could probably do it now
19:29:24 <palomer> bah, I did meet someone who met all my criteria AND was a geek
19:29:26 <Cale> There are ways to construct collisions of md5 in a reasonable timeframe.
19:29:28 <skew> really? What's the state of the art? The worst attack I heard was generating collisions
19:29:34 <palomer> and I saw why women aren't into geeks
19:29:58 <Korollary> Cale: Not that reasonable to be done by our computers, tho
19:30:08 <palomer> they've found MD5 collisions I think
19:30:16 <palomer> they're going to find SHA-1 collisions soon too
19:30:40 <SamB> palomer: who said geek? intelligent /= geek!
19:30:57 <palomer> oh, but intelligent non geeks are no fun
19:31:04 <palomer> and thus fail to meet other criteria in my list
19:31:07 <Cale> let me find the nice website
19:31:12 <SamB> you are silly
19:31:15 <Korollary> "intelligent non geeks are no fun". What?
19:31:41 <palomer> if (you are not a geek) but (you are intelligent) then (you are no fun)
19:31:51 <Korollary> Damn
19:31:56 <Philippa> depends on your value of geek
19:31:56 <SamB> there are plenty of people who don't actually qualify as geeks who are relatively fun (like relatively prime) to geeks...
19:32:08 <SamB> well, okay.
19:32:11 <Cale> http://www.cits.rub.de/MD5Collisions/ -- here's a nice example
19:32:17 <palomer> I've yet to meet one
19:32:18 <SamB> if your idea of geek is too broad maybe not.
19:32:31 <Philippa> yeah. A friend of mine wouldn't be counted as a geek by most people but she geeks a bunch of language stuff sometimes for example
19:32:32 <Cale> two postscript files which hash to the same value
19:32:39 <palomer> They're always geeks in one way or another
19:32:50 <Philippa> as in "have something that they geek"?
19:32:51 <SamB> well, as much as there are that many intelligent people...
19:33:14 <Cale> one of which contains a letter of recommendation, and the other of which contains an order for security clearance :)
19:33:28 <Philippa> oh dear
19:33:53 <Korollary> PS is a bad choice for such letters anyways
19:33:58 <Cale> It took just a few hours on a customary PC.
19:34:15 <SamB> yes. you are supposed to send those on paper!
19:34:22 <SamB> try to forge an md5 signature on paper!
19:34:24 <Korollary> PDF
19:34:32 <SamB> thats got to be harder!
19:34:35 <Cale> PDF probably would fall to the same problem
19:34:45 <SamB> first, how do you check an md5 signature on paper
19:34:46 <Cale> of the ability to include text which doesn't render
19:34:46 <SamB> ?
19:34:48 <Korollary> PDF is not that easy to mess with since it's much more restricted.
19:34:57 <palomer> SamB: very carefully
19:34:57 <SamB> Korollary: I'm sure its not THAT hard
19:35:11 <Cale> I think you can still have comments in PDF files
19:35:21 <SamB> I've seen the spec, there is a lot of complexity at least in the string encoding
19:35:26 <Korollary> SamB: Hard in the 'complexity' sense. You may have to wait 10x more hours or something.
19:35:36 <SamB> and you can stick random unlinked objects in too
19:35:41 <Cale> yeah
19:35:45 <Cale> so it wouldn't be any harder
19:36:07 <SamB> and with those unlinked objects it would be drop-dead-easy...
19:36:31 <Korollary> Wow
19:36:48 <Cale> md5 is broken
19:36:57 <SamB> I guess so.
19:36:59 <palomer> how is md5 broken?
19:37:05 <SamB> how do you deprecate it?
19:37:13 <Cale> tell people not to use it
19:37:19 <SamB> palomer: well, okay, it isn't applied appropriately.
19:37:20 <Cale> for secure things
19:37:22 <palomer> is it vulnerable to an existential forgery?
19:37:33 <Cale> http://www.cits.rub.de/MD5Collisions/
19:37:40 <SamB> lets see. the orginal meaning of deprecate was "ward off by prayer", wasn't it?
19:38:25 <palomer> noone in their right mind uses MD5 for security. If you want security, go for SHA-1
19:39:07 <Philippa> SamB: you mean that's not the modern one?
19:39:10 <Cale> http://www.schneier.com/blog/archives/2005/02/sha1_broken.html
19:39:21 <SamB> Philippa: not exactly
19:39:41 <SamB> now it is more like "warn people not to use it in preparation for its removal"
19:39:51 <Philippa> and that differs how? ;-)
19:39:51 <palomer> Cale: but noone has found a collision yet!
19:40:00 <SamB> well, the removal part
19:40:10 <Cale> palomer: only a matter of time :)
19:40:18 <palomer> and even if you have 1 collision, who cares?
19:40:46 <Cale> The problem with these kinds of hash functions is that once you have one collision, you can construct lots more, with a little work
19:40:49 <SamB> how about you just use the pigeonhole principle to find a collission?
19:40:54 <Cale> SamB: hehe
19:41:06 <Cale> it's obvious that collisions exist
19:41:08 <SamB> you could hash all the hashes
19:41:28 <Cale> it's not obvious what those collisions are
19:41:29 <palomer> ok, but even if you have lots of collisions, who cares?
19:41:37 <palomer> you still can't get an existential forgery
19:41:38 <SamB> palomer: <Cale> The problem with these kinds of hash functions is that once you have one collision, you can construct lots more, with a little work
19:41:50 <palomer> SamB: but we don't even have 1!
19:41:59 <SamB> palomer: pigeonhole!
19:42:06 <Cale> palomer: but for SHA-1, we soon will
19:42:21 <Cale> SamB: no, unfortunately you actually have to know what the collision is
19:42:35 <Cale> you can construct forgeries, as the MD5 site demonstrates
19:42:35 <palomer> pigeonhole is not a constructive theorem, it merely proves existence
19:42:38 <SamB> Cale: how many bits is SHA1 again?
19:42:46 <Cale> 160
19:43:22 <skew> the best attack I've heard of will give a collision in 2^63 operations
19:44:21 * palomer finds it cool that constructive proofs lead to algorithms
19:45:03 <Cale> skew: that order of computation has been done before on other projects
19:45:06 <SamB> palomer: if they didn't, they would have no business being called "constructive"
19:45:41 <SamB> Cale: can it be distributed?
19:45:50 <Cale> SamB: I think so
19:46:06 <SamB> we should so do that!
19:46:09 <palomer> SamB: constructive proofs have existed before the link between constructivism and algorithms was discovered
19:46:20 <palomer> s/constructive proofs/constructivism
19:46:49 <SamB> palomer: what did they call them that for then?
19:47:22 <skew> Constructivism was always about giving "constructive" proofs, actually describing how to build the object you are talking about
19:48:06 <SamB> palomer: it sounds like algorithms just hadn't been invented yet to me!
19:48:59 <Cale> It's unsurprising that constructive proofs lead to algorithms. That's essentially what they are :)
19:49:36 <Cale> A constructive proof is an algorithm written in a peculiar language.
19:49:47 <palomer> what's even more surprising is that CH can be extended to actually produce these algorithms in lambda calculus
19:50:07 <SamB> palomer: not really
19:50:17 <Cale> Let me make sure that you're talking about the Curry-Howard isomorphism
19:50:27 <Cale> :)
19:50:30 <palomer> well, it's an extension of the curry howard isomorphism
19:50:42 <palomer> CH for second order logic, if you will
19:50:46 <SamB> I didn't think lambda calculus was typed
19:50:48 <SamB> per se
19:50:52 <Cale> that's not the first thing I think of when I hear "CH" :)
19:51:00 <palomer> the terms aren't typed
19:51:08 <palomer> which is why I said "CH can be extended"
19:52:01 <palomer> it's really fascinating stuff
19:52:03 <palomer> too bad it's french
19:52:22 <gzl> Cale: continuum hypothesis?
19:53:12 <gzl> or some other thing I can't think of
19:53:37 <palomer> the continuum hypothesis is soooo true
19:53:40 <palomer> I don't care what they say
19:53:54 <SamB> what is it?
19:54:24 <skew> Alep_1 = c, I think
19:54:35 <Cale> gzl: yeah
19:54:40 <SamB> in english?
19:54:58 <skew> The next biggest size of set after the set of integers is the set of reals
19:55:00 <Cale> "There's no cardinality between that of the naturals and that of the real numbers"
19:55:19 <SamB> sounds plausible enough
19:55:25 <Cale> It's formally undecidable
19:55:28 <SamB> I can't imagine any very well
19:55:44 <Cale> In ZF/ZFC anyway
19:55:51 <skew> not undecidable exactly, but independent of the aximos
19:56:00 <skew> independent of the ZF axioms
19:56:01 <Cale> that's what undecidable means :)
19:56:09 <Cale> at least, where I'm from
19:56:17 <SamB> it seems like it would be hard to tell which of two not-terribly-related sets was higher in cardinality
19:56:21 <skew> I think ZFC is ZF extended by assuming the continum hypothesis...
19:56:26 <gzl> no no
19:56:27 <Cale> no
19:56:28 <gzl> Axiom of Choice
19:56:33 <skew> oh, right
19:56:57 <gzl> it would be pretty goofy if CH was independent of ZFC then :)
19:57:06 <Cale> The axiom of choice tells you that cardinals are totally ordered
19:57:27 <twb> @hoogle exception
19:57:28 <lambdabot> Control.Exception.Exception :: Exception
19:57:28 <lambdabot> Control.Exception.ArithException :: ArithException -> Exception
19:57:28 <lambdabot> Control.Exception.ArrayException :: ArrayException -> Exception
19:57:44 <Cale> So without it, you can have two sets such that there's no injection from one into the other either way.
19:57:50 <twb> What's handle called, and what's its syntax?
19:57:53 <Cale> (i.e. with its negation)
19:58:03 <Cale> catch or try
19:58:24 <Cale> @type Control.Exception.try
19:58:25 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
19:58:35 <Cale> @type Control.Exception.catch
19:58:36 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
19:58:38 <skew> how does hoogle come up with (a -> Maybe b) -> [a] -> [b] for a search on (a -> b) -> [a] -> [b]?
19:58:44 <Cale> @type Control.Exception.tryJust
19:58:45 <lambdabot> forall a b.
19:58:45 <lambdabot> (GHC.IOBase.Exception -> Maybe b) -> IO a -> IO (Either b a)
19:59:03 <Lemmih> @type Control.Exception.handle
19:59:04 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
19:59:17 <Cale> ah, handle is there too
19:59:28 <Cale> it's just catch with the arguments swapped
19:59:51 <SamB> does the axiom of choice say how to order them?
20:00:07 <SamB> or does it say you're allowed to put them in any order you like?
20:00:19 <SamB> within reason
20:00:20 <Cale> SamB: it just implies that for any pair of sets, there's an injection from one into the other
20:00:26 <skew> it lets you break down S as x:(S-x), basically
20:00:28 <twb> So what would the translation of "0.0 = 1.0/0.0 handle divByZero => False" be?
20:00:31 <SamB> how does it do this?
20:00:40 <skew> by asserting that you can
20:00:46 <SamB> thats silly
20:00:51 <Cale> SamB: hm?
20:01:01 <skew> It says if you have a non-empty set, it has an element
20:01:10 <SamB> well, I guess thats what an axiom does...
20:01:20 <Cale> okay, the actual statement of the axiom of choice is that if you have a nonempty product of nonempty sets, then it contains an element
20:01:33 <Cale> skew: no
20:01:40 <Cale> skew: it doesn't say that
20:01:51 <Cale> That's actually already true :)
20:02:01 <gzl> hence 'nonempty'
20:02:07 <SamB> I can't imagine a non-empty set with no elements for sure...
20:02:12 <SamB> whats a product?
20:02:18 <Cale> Cartesian product
20:02:36 <SamB> I definately can't imagine the cartesian product of nonempty sets being empty
20:02:36 <gzl> if A and B are sets, the product of A and B is { (a,b) | a in A, b in B }
20:02:49 <SamB> that would be like multiplying 1 and 1 and getting 0
20:03:40 <Cale> If you have some collection of sets A_i for i in an index set I, then the product of those sets is the set of functions f from I to the union over i in I of A_i such that f(i) is in A_i.
20:03:54 <Cale> Basically, a generalisation of tuples.
20:04:28 <SamB> that is so very incomprehensible
20:04:44 <Cale> Okay, for pairs, you have an index set of side 2.
20:04:53 <Cale> size*
20:04:58 <SamB> I think I may have understood it at one point!
20:05:02 <Cale> say, I = {0,1}
20:05:10 <Cale> then you have two sets A_0 and A_1
20:05:23 <SamB> I was going through the beginning of some abstract algebra book I downloaded
20:05:30 <Cale> and the product is the set of functions f: {0,1} -> union over i of A_i
20:05:45 <Cale> with f(0) in A_0 and f(1) in A_1
20:05:54 <Cale> which are just the same as pairs
20:06:19 <Cale> your functions pick an element from each set in the collection
20:06:20 <skew> one statement of the axiom of choice says that given any collection of sets, you can find a set which shares just one element with each of those sets
20:06:40 <gzl> SamB: the image of i in a given function is like the ith coordinate of a given tuple in the product
20:06:41 <Cale> collection of nonempty sets
20:06:48 <Cale> :)
20:06:54 <SamB> skew: that sounds decidedly ill-typed
20:07:05 <skew> it's set theory, they do that
20:07:14 <Cale> Another thing which is equivalent to the Axiom of Choice is the well-ordering principle
20:07:17 <SamB> they explode my brain when they do that
20:07:31 <gzl> or zorn's lemon
20:07:42 <gzl> or about a zillion other things :)
20:07:43 <Cale> It says that for any set S, there exists a relation < on S which is a well-ordering.
20:07:44 <SamB> I bet he used that to think!
20:07:58 <Cale> That is, it totally orders the set
20:07:59 <Cale> and
20:08:09 <Cale> every subset of S will have a least element under <
20:08:13 <SamB> or did you mean that zorn's lemon was also equivalent to the Axiom of Choice
20:08:17 <gzl> I did
20:08:21 <Cale> Zorn's Lemma
20:08:36 <SamB> not that they explode zorn's lemon when they do such ill-typed things?
20:08:52 <gzl> oh, maybe he doesn't know I'm joking. zorn's lemon is the punchline to a really bad math joke
20:09:09 <gzl> the actual thing is zorn's lemma
20:09:11 <skew> What's purple and commutes?
20:09:22 <SamB> barny with an office job?
20:09:26 <gzl> an abelian grape
20:09:37 * gzl pokes skew
20:09:54 <Cale> That says that if you have a partially ordered set where every chain (that is, totally ordered subset) has an upper bound, then the set as a whole contains a maximal element.
20:10:03 <Cale> This is pretty technical :)
20:10:07 <skew> Zorn's lemon is "sour, yellow, and equivalent to the axiom of choice"
20:10:24 <Cale> but it does turn out to be a rather useful way to state AC
20:10:42 <Cale> As most of the uses of AC lend themselves to that kind of formulation.
20:10:56 <SamB> but who says that this < is lower-cardinality-then?
20:11:05 <Cale> oh, that's a different result
20:11:24 <gzl> it's kind of neat how many different things are equivalent to AC
20:11:42 <Cale> also, there is no set-of-all-sets
20:11:52 <Cale> so this doesn't apply directly
20:11:57 <SamB> its almost like the Axiom of Choice is that you get to choose your favorite equivalent of the Axiom of Choice
20:12:07 <Cale> and even if it did, your point is a valid one
20:12:07 <SamB> except that would probably be paradoxical
20:12:15 <Cale> you don't get full control over it
20:12:29 <Cale> SamB: hehe
20:12:43 <gzl> there's a nice line from Russell where he says that AC is necessary to select a set from an infinite number of socks but not an infinite number of shoes
20:12:46 <Cale> There were T-shirts around at Waterloo at one point which said:
20:12:48 <Cale>  PRO
20:12:56 <Cale>  (axiom of) -- in tiny letters
20:12:59 <Cale> CHOICE
20:13:09 <SamB> gzl: I don't get the joke
20:13:37 <Cale> SamB: you have a rule to pick from the pairs of shoes
20:13:38 <gzl> it's only kind of a joke. the point was sort of that you can simply distinguish left and right shoes but left/right socks are identical
20:13:50 <SamB> oh
20:14:18 <Cale> The Axiom of Choice is one of the most vicious producers of nonconstructive theorems in mathematics, but we love it anyway :)
20:14:32 <gzl> it's also one of the most vicious producers of bad mathematical jokes
20:14:34 <SamB> and why would russel have this problem, anyways? he's a male - its a well known fact that males do not have an infinite number of shoes
20:15:06 <gzl> maybe he was making a snide remark about Whitehead
20:15:10 <Cale> heh
20:15:42 <skew> This is a great form of the joke: http://www.anvari.org/shortjoke/Math/127.html
20:15:47 <Cale> by the way, the axiom of choice (or one of its equivalents) is needed to show that every vector space has a basis
20:16:00 <SamB> ah, no wonder I thought it seemed useless - it is nonconstructive
20:16:13 <gzl> "every vector space has a basis" is equivalent to AC
20:16:21 <Cale> yeah
20:16:34 <Cale> but that's a useful property
20:16:40 <Cale> it makes vector spaces nice
20:16:46 <gzl> yeah.
20:16:57 <gzl> I think it's also equivalent to "every category has a skeleton"
20:17:04 <SamB> in its closet?
20:17:11 <Cale> hmm
20:17:14 <gzl> sadly, no. right out in the open for everyone to see
20:17:29 <SamB> aww
20:17:49 <SamB> they ought to keep those in closets, where respectable people keep them!
20:19:09 <SamB> next thing, you'll say categories aren't people!
20:19:45 <Cale> It's possible to prove that all bases for a given vector space have the same cardinality without AC, but I think you still can't do it in ZF, you need a weaker version of AC, the ultrafilter lemma.
20:20:35 <Cale> "Every filter is a subset of some ultrafilter"
20:21:53 <gzl> if it's equivalent to AC, how could you do it without?
20:22:07 <Cale> it's not equivalent
20:22:12 <gzl> oh oh
20:22:13 <Cale> it's weaker
20:22:15 <gzl> I misread what you said
20:22:25 <gzl> I thought you were still talking about every vs has a basis
20:22:31 <Cale> ah
20:29:09 <Pupeno_> Does anybody know of a repository of haskell-related packages for (K)ubuntu ?
20:29:49 <skew> there's the haskell-unsafe.alioth.debian.org repository
20:30:04 <Pupeno_> unsafe ?
20:31:20 <skew> I'm not sure what that's about
20:31:54 <skew> One problem, their 6.4.1 package requires a slightly newer version of some libraries than Ubuntu provided, so I ended up converting my system to Debian
20:36:03 <Pupeno_> skew: you mean, you installed Debian or you used all their packages instead of Ubuntu's ?
20:36:26 <skew> I edited sources.list, and ran apt-get
20:38:00 <skew> I've also upgraded to a 2.6.12 kernel from the debian image, so I think the system is pretty much Debian now
20:38:37 <skew> you can probably do less drastic things, and building from source is usually pretty easy, though GHC takes a long time
20:38:59 <skew> getting 6.4 is a good idea, for STM if nothing else
20:39:18 <Pupeno_> skew: 6.4 is part of Ubuntu already.
20:39:35 <Pupeno_> skew: I might take those packages and rebuild them on Ubuntu.
20:39:56 <skew> oh, I guess they've upgraded in the meantime
20:40:57 <skew> I think most of the packages out of that repository worked, and if you understand how apt works, there are probably less drastic ways to satsify the dependencies with a few packages out of Debian testing
20:41:32 <Pupeno_> what library do you recommend to make GUI applications ? (Linux + X11)
20:42:01 <dons> gtk2hs
20:42:07 <dons> @where gtk2hs
20:42:08 <lambdabot> http://haskell.org/gtk2hs/
20:42:48 <bojohan> 6.4 is in ubuntu, 6.4.1 is not
20:43:22 <Pupeno_> dons: thanks.
20:43:31 <skew> ok, when I was setting my system up Ubuntu had some 6.2 release
20:44:51 <Pupeno_> If I decide to stay with Haskell, I'll try to improve ubuntu's packages.
20:45:07 <bojohan> if you run amd64 you want to get 6.4.1 as ghci doesn't work in 6.4
20:45:15 <skew> Pupeno_: there's also a wxWidgets binding, which has been used to good effect: http://www.cs.york.ac.uk/fp/darcs/Blobs/
20:45:37 <Pupeno_> awesome.
20:45:53 <skew> but, I've had annoying problems with layouts and sizers trying to write programs with it under ion
20:46:31 <Pupeno_> I don't care much abouth other platforms, and since multi-platform is THE goal of wxWidgets, by using Gtk directly I'll remove one layer of slowliness and nothing more than slowliness (for me).
20:50:40 <dons> phys_rules, I've done some things to make hmp3 work on solaris. can you try it out?
20:50:52 <SlowByte> riiiight
20:50:55 * SlowByte just got arrows
20:51:04 <Pupeno_> skew: you even have ghc-cvs on Ubuntu now :|
20:51:39 <skew> that should have some interesting stuff in it
20:51:54 <skew> like finally merging the Parallel Haskell stuff back into GHC, now that it has a multithreaded runtime
20:57:49 <Pupeno_> skew: GHC is getting paralelism ?
20:58:53 <skew> SMP support in 6.5. It's had user-space concurrency for a while
21:55:14 <Pupeno_> What do you think about The Haskell Road to Logic, Math and Programming ?
21:58:14 <Cale> It's a good book if you want to be gently introduced to logic and Haskell at the same tiem
21:58:16 <Cale> time*
21:58:58 <Cale> If you already know logic, you might find it a little tedious at times, though of course you can always go faster.
21:59:54 <Pupeno_> I think I know more Haskell than logic (and I am a Haskell newbie). I am not sure what logic is.
22:00:25 <Korollary> mathematical logic is rules and theorems regarding what can be proven and how, etc.
22:18:30 <Pupeno_> Thanks.
22:26:14 <newsham> hi
22:26:19 <Cale> hello
22:26:43 <newsham> besides :t is thhere any other introspection you can do from ghci or hugs?
22:26:49 <Cale> :info
22:26:55 <Cale> :?
22:27:05 <Cale> gives a list of the commands
22:27:46 <newsham> i'm familiar with the help stuff.. just wondering if the language has any builtin introspection stuff
22:27:57 <newsham> like for example dir() and help() in python
22:28:21 <Cale> :show bindings
22:28:24 <Cale> :show modules
22:29:36 <Cale> but they don't tell you that much
22:30:37 <newsham> those aren't available in hugs
22:30:47 <Cale> all that stuff is part of the interactive environment though
22:30:51 <Cale> not part of the language
22:31:13 <Cale> hugs and ghci are different
22:32:17 <Cale> hugs seems to have some extra stuff
22:32:20 <Cale> :names
22:32:22 <Cale> :browse
22:32:43 <Cale> try :also List, then :browse List
22:33:09 <Cale> ghci doesn't have that, but I've also never needed it
22:34:04 <Cale> documentation is available on the web
22:34:27 <Megzlna> In functional programming, what does "head" and "Tail" mean?
22:34:36 <Megzlna> fold(Seq, Prev, BinaryOp) := if (Seq is empty) then Prev else fold(tail(Seq), BinaryOp(Prev, head(Seq)), BinaryOp)
22:34:43 <Cale> head is the first element of a list, and tail is the rest
22:34:57 <Megzlna> ah...
22:35:00 <newsham> head:tail'
22:35:07 <Cale> > head [1,2,3,4,5]
22:35:08 <lambdabot> 1
22:35:10 <Cale> > tail [1,2,3,4,5]
22:35:12 <lambdabot> [2,3,4,5]
22:35:18 <Megzlna> Perfect. Thank you.
22:36:01 <Cale> that's a left fold by the looks of it
22:36:15 <Megzlna> I'm programming in C++ templates (the mpl language) and the MPL uses these terms from functional programming
22:36:21 <Cale> > foldl (+) 0 [1,2,3,4,5]
22:36:22 <lambdabot> 15
22:37:14 <Megzlna> It's an immutable language, and it has a full of of containers and algorithms to match C++'s stl.
22:37:21 <newsham> > scal (+) 0 [1,2,3,4,5[
22:37:22 <lambdabot>  parse error on input `}'
22:37:25 <newsham> > scal (+) 0 [1,2,3,4,5]
22:37:26 <lambdabot>  Not in scope: `scal'
22:37:36 <Megzlna> I should probably learn haskell just to get better with functional.
22:37:37 <newsham> > scanl (+) 0 [1,2,3,4,5]
22:37:39 <lambdabot> [0,1,3,6,10,15]
22:37:45 <newsham> i cant type
22:38:26 <Korollary> You should learn Haskell and probably read http://mitpress.mit.edu/sicp/ if you haven't.
22:38:34 <Cale> > foldl (\x y -> concat ["(", x, "*", show y, ")"]) "0" [1,2,3,4,5]
22:38:36 <lambdabot> "(((((0*1)*2)*3)*4)*5)"
22:39:11 <Cale> to give some idea of what it's doing :)
22:39:30 <newsham> except imagine that * is a + :)
22:39:34 <Cale> > foldl (\x y -> concat ["(", x, "+", show y, ")"]) "0" [1,2,3,4,5]
22:39:35 <lambdabot> "(((((0+1)+2)+3)+4)+5)"
22:39:37 <Cale> sure
22:39:52 <Megzlna> that's really a cool way to visualize the recursion
22:39:57 <Cale> I was thinking of * as an arbitrary unspecified operation
22:40:14 <newsham> who says its recursion? :)
22:40:29 <Megzlna> well um it's very simple recursion.
22:40:46 <Megzlna> I guess you guys program in this way so regularly that you don't even consider recursion to be recursion.
22:41:03 <Cale> > foldr (\x y -> concat ["(", show x, "+", y, ")"]) "0" [1,2,3,4,5]
22:41:05 <lambdabot> "(1+(2+(3+(4+(5+0)))))"
22:41:46 <newsham> one of thhe interesting thihngs (imo) is that you can abstract out the recursion/iteration so that you write little functions that dont often directly represent it
22:41:56 <Cale> Well, it's recursion alright, but really the recursion already happened when you made the list.
22:42:49 <Cale> foldr is just replacing cons-cells in that list with a particular function, and the empty list with a particular value
22:43:03 <Cale> > 1 : [2,3,4,5]
22:43:04 <lambdabot> [1,2,3,4,5]
22:43:14 <Cale> > 1 : 2 : 3 : 4 : 5 : []
22:43:15 <lambdabot> [1,2,3,4,5]
22:43:21 <newsham> isnt it possible thhat a compiler optimize out the recursion of a fold?
22:43:37 <Cale> newsham: well, if it's smart enough
22:43:42 <joelk> anyone else think it's strange that the docs calls mzero "the identity of mplus", when clearly it is not. wouldn't mproduct be a better mnemonic?
22:44:00 <Cale> joelk: what?
22:44:02 <Cale> It's not?
22:44:02 <joelk> ... for the associative op
22:44:14 <Cale> mzero `mplus` k = k
22:44:24 <Cale> k `mplus` mzero = k
22:44:28 <Cale> that's what it means
22:44:31 <joelk> > Nothing `mplus` Just 5
22:44:32 <lambdabot> Just 5
22:44:36 <Cale> yep
22:44:45 <Cale> > mzero `mplus` (Just 5)
22:44:47 <lambdabot> Just 5
22:44:56 <Cale> > (Just 5) `mplus` mzero
22:44:57 <lambdabot> Just 5
22:45:00 <joelk> oh! the doh
22:45:14 <joelk> cool.
22:45:42 <Cale> > [1,2,3] `mplus` [4,5]
22:45:43 <lambdabot> [1,2,3,4,5]
22:46:10 <Cale> > mzero :: [Integer]
22:46:12 <lambdabot> []
22:46:35 <joelk> ok, that's cool. don't know exactly how I got the impression it wasn't...
22:48:18 <Cale> http://vx.hn.org/autoshare/foldr.png -- here's a nice picture of foldr
22:53:22 <tismith> neat picture Cale - I like that way of thinking of foldr
22:56:28 <tismith> I suppose you can think of foldl in a similar way?
22:56:46 <Cale> yeah, though it's less natural looking
22:57:50 <newsham> hmm.. fmap maps in a monad, but lists are monads too, right?  so isnt map redundant?
22:57:55 <Megzlna> Why do you call it foldr ?
22:58:04 <Cale> yes
22:58:09 <Cale> fmap maps in a Functor
22:58:11 <newsham> meg: you can fold right or fold left
22:58:12 <Megzlna> Why ont foldup ?
22:58:17 <Megzlna> or fold forward
22:58:18 <Megzlna> or foldleft ?
22:58:21 <Cale> Megzlna: because it's right associative
22:58:24 <user317> there is a foldleft
22:58:28 <newsham> > fmap (+ 2) [1,2,3]
22:58:29 <lambdabot> [3,4,5]
22:58:29 <Cale> foldl is left
22:58:33 <newsham> > map (+ 2) [1,2,3]
22:58:34 <lambdabot> [3,4,5]
22:58:40 <Megzlna> yeah but why not cold foldl as "fold backward ?"
22:58:40 <Cale> newsham: exactly
22:58:44 <Korollary> Megzlna: typically lists are written left to right, and foldr starts from the right (tail).
22:59:02 <newsham> cale: so why both?
22:59:07 <Cale> newsham: I'd like to rename fmap to map and get rid of liftM entirely
22:59:13 <Korollary> Cale: amen
22:59:30 <Cale> newsham: The rationale was that newbies are confused by errors about Functors
22:59:47 <newsham> hhmm.. thats probably a good one :)
22:59:51 <newsham> being a newbie myself :)
23:00:18 <Cale> but are you confused?
23:00:32 <newsham> if i saww a weird error i might be
23:04:17 <Cale> really the errors don't get so bad
23:04:25 <Cale> if you know what Functor means, you'll be okay
23:05:14 <newsham> what does "seq" do?
23:05:15 <Korollary> after 2-3 months, errors don't puzzle you as much as they did in the first few weeks.
23:08:48 <Cale> newsham: The evaluation of (seq a b) forces the evaluation of a, and results in b
23:09:03 <newsham> so like the >> monad thingy?
23:09:14 <newsham> wait, no.. nevermind
23:09:23 <skew> yeah, it's kind of like that
23:09:26 <Cale> sort of, except that >> doesn't necessarily force evaluation
23:09:35 <Cale> seq is a slightly evil language primitive for making things strict
23:09:41 <skew> but >> sequences the effects
23:10:13 <Cale> (>> is strict in IO and ST, but not usually in other monads)
23:10:33 <Cale> there's a related item:
23:10:40 <Cale> f $! x = x `seq` f x
23:10:54 <Cale> which is actually a good example of how seq is used to make things strict
23:11:40 <Cale> f $! x will have the same result as f x, but will force the evaluation of x up to the point where the top level data constructor is determined before applying f
23:12:14 <Cale> If x :: Integer or something, this is exactly the same as strict evaluation
23:13:12 <newsham> so for example    f x   may terminate where   f $! x  may not (if x is an infinite seq for example) ?
23:13:31 <skew> what does "he" from pesco do? http://www.scannedinavian.org/~pesco/
23:13:49 <Cale> if the evaluation of x takes forever, then f $! x will take forever too
23:14:03 <Cale> but note that it's only evaluation to the *top level* data constructor
23:14:06 <newsham> but f x may not, correct?
23:14:14 <Cale> but f x might finish
23:14:20 <Cale> it might not even need x
23:14:20 <newsham> righhht
23:14:23 <skew> but if x in an infinite sequence, then $! just evaluates to the cons at the begining
23:14:24 <newsham> danke
23:14:29 <Cale> right
23:14:34 <skew> evaluates as far as the const at the beginning, at least
23:14:45 <Cale> > let ones = 1 : ones in head $! ones
23:14:47 <lambdabot> 1
23:14:51 <Cale> this is still okay
23:15:35 <Cale> > let loop = loop in const 5 loop
23:15:36 <lambdabot> 5
23:15:39 <Cale> > let loop = loop in const 5 $! loop
23:15:40 <lambdabot> Loop
23:17:40 <newsham> is taht lambdabot's way of indicating non-termination?
23:19:07 <ibid> no, it's its way of indicating evaluation of a black hole, i'd say
23:19:18 <ibid> it catches some cases of nontermination, but not all
23:19:41 <newsham> turing would be relieved
23:20:45 <Cale> http://vx.hn.org/autoshare/folds.png
23:20:50 <Cale> there you go :)
23:22:36 <newsham> i think the folds diagram is in thhe wiki somewhehre
23:23:16 <newsham> http://haskell.org/hawiki/WhatIsaFold
23:26:54 <newsham> > foldr (\x y -> concat ["(", show x, "++", y, ")"]) "[]" "test"
23:26:55 <lambdabot> "('t'++('e'++('s'++('t'++[]))))"
23:27:22 <Cale> > foldr (\x y -> concat ["(", show x, ":", y, ")"]) "[]" "test"
23:27:24 <lambdabot> "('t':('e':('s':('t':[]))))"
23:27:46 <Cale> > foldr (\x y -> concat ["(", show x, ":", y, ")"]) "[]" [1,2,3,4,5]
23:27:47 <lambdabot> "(1:(2:(3:(4:(5:[])))))"
23:27:50 <Cale> hehe
23:27:58 <newsham> > foldl (\x y -> concat ["(", show x, "++", y, ")"]) "[]" "test"
23:27:59 <lambdabot> Couldn't match `[Char]' against `Char'
23:28:08 <newsham> oops
23:28:12 <Cale> ++ wouldn't work
23:28:21 <newsham> yah, i know...
23:28:25 <newsham> i wanna visualize it
23:28:53 <Cale> > foldr (:) [] [1,2,3,4,5]
23:28:54 <lambdabot> [1,2,3,4,5]
23:29:27 <Cale> > let m f = foldr ((:) . f) [] in m (*2) [1,2,3,4,5]
23:29:28 <lambdabot> [2,4,6,8,10]
23:30:03 <Cale> @pl \f -> foldr ((:) . f) []
23:30:04 <lambdabot> flip foldr [] . ((:) .)
23:30:33 <Cale> hehe, not *quite* smart enough to know that's map
23:31:08 <newsham> map f = foldr ((:) . f) []    is what you're saying?
23:31:13 <Cale> yep
23:31:39 <twb> So is creating a new exception a sensible move?
23:32:10 <twb> The whole Data.Dynamic thing is a lot more confusing that "exception fooBar".
23:32:55 <Cale> well, if you can convey what you need to convey in a String, then error is fine
23:33:10 <twb> Can I catch it (for testing purposes)?
23:33:28 <Cale> catch what?
23:33:32 <Cale> calls to error?
23:33:35 <twb> The error/exception/condition
23:33:38 <twb> Yes.
23:33:41 <Cale> yes
23:33:46 <twb> Oh good.
23:34:02 <Cale> you have to force evaluation a bit sometimes though
23:34:32 <twb> @hoogle error
23:34:32 <lambdabot> Prelude.error :: String -> a
23:34:32 <lambdabot> Control.Monad.Error.Error :: Error a
23:34:32 <lambdabot> Graphics.Rendering.OpenGL.GLU.Errors.Error :: Error
23:34:47 <Cale> > error "Hello"
23:34:48 <lambdabot> Add a type signature
23:34:49 <Cale> > error "Hello" :: Int
23:34:50 <lambdabot> Hello
23:34:55 <Cale> hehe
23:35:01 <Cale> hmmm
23:35:06 <twb> Odd.
23:35:11 <Cale> > error "> 5" :: Int
23:35:12 <lambdabot> > 5
23:35:24 <Cale> nope, doesn't read its own output :)
23:35:54 <Cale> however...
23:36:12 <Cale> > error "> 5" :: Int
23:36:14 <lambdabot> > 5
23:36:14 <mbot> > 5
23:36:15 <mbot> 5
23:36:16 <lambdabot> 5
23:36:18 <Cale> hehe
23:37:58 <xinming> do{ line1 <- getLine; line2 <- getLine; putStr( line1++line2);}
23:38:18 <xinming> what will this be if written in >>= form?
23:38:35 <Lemmih> getLine >>= \line1 -> getLine >>= \line2 -> putStr (line1++line2)
23:38:43 <Cale> getLine >>= \line1 -> getLine >>= \line2 -> putStr (line1 ++ line2)
23:38:47 <Cale> hehe
23:39:03 <Lemmih> Hi Cale.
23:39:08 <Cale> hello
23:39:27 <xinming> do{ line1 <- getLine; line2 <- getLine; putStr( line1 ++ "\n" ); putStr( line2 ++ "\n"}
23:40:19 <Cale> getLine >>= \line1 -> getLine >>= \line2 -> putStr (line1 ++ "\n") >> putStr (line2 ++ "\n")
23:40:21 <xinming> getLine >>= \line1 -> getLine >>= \line2 -> putStr( line1 ++ "\n" ) >>= putStr( line2 ++"\n" )
23:40:32 <Cale> or
23:40:42 <Cale> getLine >>= \line1 -> getLine >>= \line2 -> putStr (line1 ++ "\n") >>= \dummy -> putStr (line2 ++ "\n")
23:40:56 <newsham> hhuhh, i didnt know (,) was an operator
23:41:02 <Cale> > (,) 1 2
23:41:03 <mbot> (1,2)
23:41:03 <lambdabot> (1,2)
23:41:07 <Lemmih> @type (,)
23:41:08 <mbot> forall b a. a -> b -> (a, b)
23:41:08 <lambdabot> forall b a. a -> b -> (a, b)
23:41:10 <newsham> yah i just did that
23:41:11 <Cale> hehe
23:41:21 <xinming> if I think that monad is used for a chained operation, am I right?
23:41:22 <Lemmih> > "echo"
23:41:23 <mbot> "echo"
23:41:23 <lambdabot> "echo"
23:41:24 <newsham> i'm reading through the prelude for the first time
23:41:26 <newsham> interesting stuff
23:41:34 <Cale> > error "> \"echo\""
23:41:35 <lambdabot> Add a type signature
23:41:35 <mbot> Add a type signature
23:41:38 <Cale> > error "> \"echo\"" :: Int
23:41:39 <lambdabot> > "echo"
23:41:40 <mbot> > "echo"
23:41:40 <mbot> "echo"
23:41:41 <lambdabot> "echo"
23:41:59 <Cale> anyone up for a quine?
23:42:07 <xinming> anyone would tell me if I am right?
23:42:23 <Cale> xinming: that's part of it
23:42:37 <xinming> monad is used for a chained operation which convert types between functions.
23:42:38 <Cale> [1,2,3] >>= \x -> [x+10,x+20]
23:42:40 <Cale> > [1,2,3] >>= \x -> [x+10,x+20]
23:42:41 <mbot> [11,21,12,22,13,23]
23:42:41 <lambdabot> [11,21,12,22,13,23]
23:43:20 <Lemmih> @version
23:43:21 <mbot> lambdabot 3p180, GHC 6.4.1 (Linux i686)
23:43:21 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:43:21 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
23:43:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
23:43:32 <Cale> hehe, I'm a little behind
23:43:34 <xinming> too many bot.
23:43:41 <xinming> s/bot/bots/
23:43:41 <Cale> mbot: @part
23:43:47 <Cale> mbot: @part #haskell
23:43:56 <xinming> lambdabot: @part #haskell
23:43:56 <lambdabot> Not enough privileges
23:43:58 <xinming> :-P
23:44:48 <newsham> > putStr "> putStr (show 5)"
23:44:49 <lambdabot> No IO allowed
23:45:41 <lisppaste2> twb pasted "What should prop_eval_sum_stackUnderflow be?" at http://paste.lisp.org/display/14320
23:47:54 <newsham> sleep..  thnanks for the hhelp all (and cale)
23:48:00 <xinming> do{ ('a':'d':'d':':':line1 <- getLine; line2 <- getLine; putStr( line1++line2);}
23:48:03 <xinming> how about this one?
23:48:06 <Lemmih> twb: You need a bit of unsafe IO and beware of laziness.
23:48:11 <xinming> do{ ('a':'d':'d':':':line1) <- getLine; line2 <- getLine; putStr( line1++line2);}
23:48:29 <xinming> for pattern match, how to convert into >>= form?
23:48:36 <Lemmih> getLine >>= \('a':'d':...) -> ...
23:48:46 <Cale> basically
23:48:49 <twb> Why do some people use braces around DO clauses, and some not?
23:48:52 <xinming> thanks. :-)
23:48:56 <Lemmih> (\(x:y:xs) -> xs) [1,2,3,4]
23:49:03 <Lemmih> > (\(x:y:xs) -> xs) [1,2,3,4]
23:49:04 <lambdabot> [3,4]
23:49:06 <Cale> though it currently inserts some junk to test for failed pattern matches
23:49:14 <Cale> and replace them with calls to fail
23:49:32 <Lemmih> twb: It's a matter of taste.
23:49:58 <Cale> I really think it should only fail pattern matches with mzero on the event that one is dealing with a MonadPlus
23:50:18 <Cale> (Or MonadZero, if they bring that back)
23:50:48 <Lemmih> xinming: Actually it translates to 'getLine >>= \p -> case p of ('a':'b':...) -> ...; _ -> fail "..."'
23:51:51 <Lemmih> Like Cale said.
