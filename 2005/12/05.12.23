00:54:38 <twb> Awfully quiet in here.
00:55:27 <Cale> Almost too quiet...
00:55:30 <twb> Are the parsec developers open to adding additional combinators to the library?
00:55:44 <Cale> I don't see why they wouldn't :)
00:56:20 <Lemmih> What are you missing?
00:56:50 <lisppaste2> twb pasted "parsec combinators" at http://paste.lisp.org/display/14938
00:58:18 * Saulzar adds noise.
00:58:29 <twb> Lemmih: those.
00:58:36 <Cale> :t replicateM
00:58:42 <Cale> @type Control.Monad.replicateM
00:58:43 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
00:59:11 <Lemmih> manyN /= count?
00:59:14 <Cale> @type Control.Monad.replicateM_
00:59:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
00:59:23 <twb> Lemmih: dunno.
00:59:46 <twb> Lemmih: ah, cool.
01:00:01 <Cale> twb: check those out too :)
01:00:16 <twb> Cale: monads are still a closed book to me.
01:00:41 <Cale> twb: you're using parsec, so not anymore :)
01:00:57 <twb> I'm using them in parsec, but I don't *understand* them.
01:01:08 <twb> I can drive a car, but I don't know how to make one.
01:01:58 <Cale> Shouldn't stop you from learning that (GenParser tok st) is a monad, and so for all the functions you see in Control.Monad, you can replace 'm' with 'GenParser tok st', and get a function which works on parsers :)
01:05:01 <twb> I also like before p q = do x <- q; lookAhead p; return x
01:16:14 <Cale> hmm, PArrows is approx twice as fast as parsec for my contrived example, which in turn is about twice as fast as parsek
01:16:59 <twb> Cale: is that parsec implemented on top of arrows?
01:17:10 <Cale> yeah
01:17:17 <Cale> roughly :)
01:17:19 <twb> Is the API the same?
01:17:29 <Cale> almost, not quite
01:17:39 <Cale> http://www.cs.helsinki.fi/u/ekarttun/PArrows/doc/
01:18:34 <Cale> compileJS :: JSCompiler -> MD i o -> IO JSFun
01:18:34 <Cale> Compile a parser into JavaScript. Returns a reference to the top-level Parsing function. The generated javascript function expects a String and a starting index for parsing. The result will be either the index of the rightmost character matched or -1 if the parser failed.
01:18:56 <Cale> that's cute
01:19:15 <twb> Meaning it outputs a parser written in ECMAscript?
01:20:58 <Cale> yeah
01:21:10 <Cale> based on the arrow you give it :)
01:21:36 <Cale> Also, there's an instance of Show
01:22:07 <Cale> Prelude Control.Arrow Text.ParserCombinators.PArrow> (many (char 'a' <+> char 'b'))
01:22:07 <Cale> ([ab])*
01:22:14 <twb> CharSet seems to assume ISO8859
01:22:48 <Cale> yeah, possibly
01:23:33 <Cale> It doesn't seem to actually use that for much though.
01:24:42 <Cale> ah, it's possibly for the funky show instance
01:26:31 <Cale> ah, it does use it internally for the obvious parsers
01:27:26 <alar> does anybody know the current state of hIDE project?
01:28:51 <Cale> alar: not terribly usable?
01:29:16 <alar> Cale: that's what I want to know
01:29:44 <araujo> Last time i heard, it was kind of stopped.
01:29:45 <alar> more concretely: is it more or less usable than WinHugs
01:29:54 <Cale> less
01:30:31 <alar> thanks
01:30:37 <Cale> considering that winhugs actually presumably does something useful (I haven't used it)
01:31:03 <Cale> there's a lot of cool code written in hIDE, but I don't think there's anything which you can actually use yet.
01:31:11 <Cale> Curses yi is usable though.
01:31:56 <twb> Emacs!
01:32:15 <Cale> Emacs is cool, but not as cool as yi as far as potential goes :)
01:33:02 <twb> Well, they have the same *potential*...
01:33:19 <Saulzar> Are you trying to damn yi? :)
01:33:20 <twb> But Emacs has a head start.
01:33:38 <cpatrick> Cale: for very loose values of "usable"
01:33:53 <Cale> Yi is entirely module based. The static core does almost nothing other than load modules.
01:33:59 <cpatrick> lately I have been reverting to vim after discovering that it does multi-buffer stuff with :b
01:34:09 <Cale> So it's more programmable than emacs!
01:35:42 <sieni> then there is also climacs, which looks interesting
01:35:57 <Saulzar> There's another project with some promise too, eclipsefp  - though last I tried it was fairly elementary too
01:35:59 <Cale> There are currently modules to make Yi feel like Vi, Vim, Nano, Mg, Joe, Ee, and two variants of Emacs
01:36:00 <twb> Climacs are cocksuckers.
01:36:16 <twb> They don't want an extensible platform, they just want an editor.
01:36:27 <takuan> can somebody come up with a non lazy version of the code I pasted on the paste page?
01:36:38 <twb> And they have *no* interest in a console version.
01:36:38 <takuan> that is, for iterateTillEnd
01:36:43 <Cale> http://common-lisp.net/project/climacs/ ?
01:36:47 <sieni> twb: a decent editor would be a good start
01:36:54 <takuan> I tried changing the last line in | otherwise =  let y = f x in y `seq` iter f (f x) x
01:36:57 <takuan> but it didn't work
01:37:09 <twb> @google lice lisp computing environment
01:37:11 <lambdabot> http://www.emmett.ca/~sabetts/
01:37:49 <Cale> takuan: first get rid of the typo :)
01:37:57 <sieni> twb: and a prerequisite for that is a decent extension language, be it sml, scheme, common lisp, lua or haskell, but NOT emacs lisp
01:38:08 <twb> sieni: agreed.
01:38:10 <takuan> Cale: meuh ;)
01:38:18 <takuan> translating code sucks ;)
01:38:18 <neologism> whats wrong withemacs lisp?
01:38:20 <Saulzar> What gui toolkit are they using? It looks like it could be tk or something awful.
01:38:45 <twb> Saulzar: climas is using CLIM.
01:39:01 <cpatrick> twb: woah woah woah, that's an _operating system_ ?  I see it really is fulfilling the emacs dream
01:39:08 <sieni> neologism: well dynamic scoping of variables and as a consequence it gets all the time confused when you have multiple frames, buffers or windows open
01:39:25 <takuan> Cale: it's gone
01:39:30 <neologism> ah
01:39:33 <neologism> I thought its "normal lisp"
01:39:57 <twb> neologism: elisp is "mocklisp", "the best we can do to emulate a lispm on a peecee"
01:39:59 * takuan is stupid
01:40:24 <neologism> hm.. I dont know lisp that much tounderstand what you said :)
01:40:41 <twb> neologism: it's like Windos -- it was never inteded to be good, only adequate.
01:40:45 <twb> *Windows
01:40:47 <neologism> hehe
01:40:47 <Cale> takuan: iter f x = let y = f x in y `seq` if greatestchange y x < change then x else iter f (f x)
01:40:57 <Cale> er
01:40:59 <Cale> takuan: iter f x = let y = f x in y `seq` if greatestchange y x < change then x else iter f y
01:41:09 <takuan> :D
01:41:11 <Cale> that'll strictify it
01:41:11 <twb> It's better to throw it out and start with a clean system, but there is *sooo* much inertia in windows'/emacs' applications.
01:42:55 <twb> e.g. there is no way I could use Yi as my editor until it had *at least* M-x dired and M-x shell equivalents.
01:43:22 <Cale> twb: write them! :)
01:43:36 <twb> Cale: rsn, in my copious free time.
01:45:01 <takuan> Cale: it still eats memory
01:45:22 <SlowByte> why does compileJS run in the IO monad? :)
01:45:24 <takuan> but that's probably due to the fact that doIterationStep is lazy
01:46:04 <takuan> or not?
01:46:09 <Cale> takuan: how large is the array?
01:46:16 <takuan> not that large
01:46:20 <takuan> 20x20
01:46:42 <Cale> okay, so the fact that you're using foldr there isn't a problem
01:46:55 <takuan> i don't think so
01:47:04 <Cale> foldl1' would be a better choice anyway
01:47:24 <takuan> doIterationStep uses an iteration scheme which uses, lazyly, values from the current iteration
01:47:32 <Cale> okay
01:47:34 <takuan> but I guess that shouldn't make a difference here
01:47:39 <Cale> do some profiling perhaps
01:48:09 <Cale> ah, hmm
01:48:16 <Cale> what kind of arrays are you using?
01:48:30 <takuan> usual haskell arrays since those turned out to be faster
01:48:58 <Cale> Faster than unboxed arrays?
01:49:12 <Cale> Or do you need recursive array definitions/strange types
01:49:26 <takuan> no
01:49:38 <takuan> well
01:49:40 <takuan> that is to say
01:50:05 <takuan> i'm using a scheme like this to change most of the values of the array
01:50:13 <takuan> res = t!(i,j) + c*(o!(i-1,j) -4*t!(i,j)+ t!(i+1,j) + o!(i,j-1) +t!(i,j+1))
01:50:26 <takuan> t is the array which is in the input of the function
01:50:34 <takuan> o is the array which comes out of the function
01:50:46 <Cale> ah
01:51:01 <Cale> so that's a recursive array definition
01:51:02 <Cale> hmm
01:51:03 <takuan> so o!(i,j) becomes res
01:51:06 <takuan> voila
01:51:28 <takuan> in place updates won't work there I guess
01:51:46 <takuan> or will they?
01:52:16 <Cale> Unboxed array types won't work.
01:53:47 <Cale> hmm
01:53:59 <Cale> But in that case, you will be hanging on to lots of arrays
01:54:07 <takuan> well
01:54:12 <takuan> not necessarily
01:54:15 <takuan> only two in fact
01:54:17 <Cale> because the elements of the current array depend on the elements of the last and so on
01:54:24 <Cale> all the way back to the start
01:54:35 <takuan> that's true
01:54:40 <takuan> as in most computations ;)
01:54:44 <Cale> since no evaluation of array elements happens until the end, when you print the thing
01:55:06 <Cale> it has to hold on to the arrays of thunks which describe how to compute their elements
01:55:22 <Cale> and nothing is ever garbage collected
01:55:49 <takuan> is there a solution around that?
01:56:16 <Cale> well, I suppose that at each iteration, you could explicitly force the entire array
01:56:45 <takuan> force it to be what?
01:56:50 <Cale> computed
01:56:52 <Cale> with seq
01:57:17 <takuan> aren't we doing that already with your idea?
01:57:21 <Cale> no
01:57:29 <{Arias}> hi
01:57:44 <takuan> hum
01:57:53 <Cale> we're only forcing the array, not any of its elements
01:57:57 <takuan> aha
01:58:06 <takuan> so I have to force it in the iteration code?
01:58:16 <Cale> one sec
02:00:40 <Cale> okay
02:01:11 <Cale> forceArray a = foldl' seq () (elems a) `seq` a
02:01:23 <Cale> foldl' is in Data.List
02:01:50 <takuan> where does that go?
02:01:56 <Cale> anywhere in your module
02:02:18 <Cale> now, you apply it to the array when you build the new iteration from the old one
02:02:27 <takuan> aha
02:02:44 <takuan> so I could use it in the place where "y = f x"?
02:02:48 <Cale> so if you were using (array ...) for that before, use (forceArray $ array ...)
02:02:53 <takuan> something like "y = forceArray (f x)
02:03:00 <Cale> oh, you could do that too
02:03:46 <Cale> what it does is to add instructions to the array to evaluate all the elements when the array itself is evaluated
02:03:53 <[CotL]Godofe_Kei> mornin!
02:04:05 <soysauce> @type (.) (Control.Arrow.&&&) (.)
02:04:07 <lambdabot> forall c' b c a.
02:04:07 <lambdabot> (b -> c) -> ((a -> b) -> c') -> (a -> b) -> (a -> c, c')
02:04:12 <Cale> which should force all the previous array's elements to become garbage
02:04:37 <Cale> @comp @pl @djinn (b -> c) -> ((a -> b) -> c') -> (a -> b) -> (a -> c, c')
02:04:38 <lambdabot> compose module failed: Parse error: "@pl"
02:04:42 <soysauce> óla Godofe_Kei
02:04:45 <Cale> @djinn (b -> c) -> ((a -> b) -> c') -> (a -> b) -> (a -> c, c')
02:04:46 <lambdabot> f a b c = (\ d -> a (c d), b c)
02:04:50 <[CotL]Godofe_Kei> ola!
02:04:52 <soysauce> Cale - @.
02:04:58 <Cale> @pl f a b c = (\ d -> a (c d), b c)
02:04:59 <lambdabot> f = ap . ((,) .) . (.)
02:05:08 <Cale> soysauce: ah
02:05:15 <soysauce> @. pl djinn (b -> c) -> ((a -> b) -> c') -> (a -> b) -> (a -> c, c')
02:05:16 <lambdabot> f = ap . ((,) .) . (.)
02:05:22 <Cale> @comp pl djinn (b -> c) -> ((a -> b) -> c') -> (a -> b) -> (a -> c, c')
02:05:23 <lambdabot> f = ap . ((,) .) . (.)
02:05:29 <soysauce> oh, neat
02:05:29 <Cale> it's just the @'s
02:05:33 <soysauce> *nods*
02:05:51 <Cale> so there's a monadic solution :)
02:06:06 <soysauce> how is that a monad?
02:06:08 <Cale> ap
02:06:10 <soysauce> @type ap
02:06:12 <lambdabot> Not in scope: `ap'
02:06:14 <Cale> @type Control.Monad.ap
02:06:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
02:06:25 <takuan> Cale: what does the () do?
02:06:34 <Cale> hm?
02:06:39 <soysauce> weird... so are (->) monads, too?
02:06:42 <Cale> yeah
02:06:45 <takuan> because it doesn't compile
02:06:57 <takuan> i get     Couldn't match `()' against `Double' Expected type: Diffusie2d () b Inferred type: Diffusie2d Double b1
02:06:58 <Cale> import Control.Monad.Reader
02:06:59 * araujo wonders if it ok to support the insanity of file names with whitespaces in the shell
02:07:02 <Cale> oh
02:07:05 <Cale> takuan: hm?
02:07:12 <[CotL]Godofe_Kei> I got a very siple question and its not even about haskell, its about mathematic, i cant solve this
02:07:26 <soysauce> Cale - BTW that's not actually a useful function, I was just screwing around to see what I would get :P
02:07:29 <Cale> in   "forceArray a = foldl' seq () (elems a) `seq` a" ?
02:07:34 <soysauce> Godofe_Kei - what's your question?
02:07:38 <[CotL]Godofe_Kei> i can change hours, minutes, secodnds and miliseconds into just miliseconds
02:07:42 <[CotL]Godofe_Kei> but noth the way around
02:07:46 <[CotL]Godofe_Kei> (a,b,c,d) = a*3600000 + b*60000 + c*1000 + d
02:07:53 <takuan> nope Cale 
02:08:00 <[CotL]Godofe_Kei> this turns all into mliliseconds, i cant do the reverse
02:08:15 <soysauce> Godofe_Kei - the reverse is harder in Haskell...
02:08:22 <[CotL]Godofe_Kei> yeah
02:08:22 <takuan> but the type of forceArray is Data.Array.Base.IArray a ()
02:08:23 <Cale> [CotL]Godofe_Kei: a `mod` b is the remainder after division by b of a
02:08:24 <soysauce> hm
02:08:31 <Cale> oh
02:08:32 <[CotL]Godofe_Kei> yes i know
02:08:34 <[CotL]Godofe_Kei> i tried this
02:08:43 <[CotL]Godofe_Kei> inverte x = (0,(x `div` 1000) `div` 60,(x `div` 1000) `mod` 100,x `mod` 1000)
02:08:47 <soysauce> (mins,millis') = (div millis 1000, mod millis 1000)
02:08:51 <[CotL]Godofe_Kei> hours is 0 cause i havent tried them yet
02:08:51 <takuan> the type of other functions I'm using has Data.Array.Base.IArray a1 e
02:08:57 <soysauce> er
02:08:58 <Cale> forceArray a = foldl1' seq (elems a) `seq` a
02:08:59 <soysauce> s/mins/secs/
02:09:02 <Cale> sorry
02:09:08 <soysauce> (mins,secs') = (div secs 60, mod secs 60)
02:09:09 <takuan> aha
02:09:11 <takuan> np Cale 
02:09:19 <soysauce> you could do it with a fold...
02:09:35 <[CotL]Godofe_Kei> fold?
02:09:36 <soysauce> well, List.mapAccumL!
02:09:42 <[CotL]Godofe_Kei> lol
02:09:46 <[CotL]Godofe_Kei> u love that one dont u?
02:09:49 <takuan> now it compiles
02:09:50 <soysauce> yeah
02:09:53 <Stinger> (you need to subtract what you've already accounted for when you move to the smaller divisions
02:10:40 <takuan> Cale: still eating memory though
02:10:42 <soysauce> 1 day, 1 minute, and 1 second:
02:10:51 <soysauce> > List.mapAccumL (\t d -> (div t d, mod t d)) 86461000 [1000,60,60,24]
02:10:53 <lambdabot> (1,[0,1,1,0])
02:11:02 <soysauce> ;)
02:11:09 <Cale> takuan: hmm
02:11:18 <Cale> profile :)
02:11:25 <soysauce> reading from right to left: 0 milliseconds, 1 second, 1 minute, 0 hours, 1 day
02:11:31 <Cale> takuan: also, how are you compiling it?
02:11:36 <soysauce> @pl \(x, y) -> x:y
02:11:37 <lambdabot> uncurry (:)
02:11:51 <takuan> ghc -O2
02:11:59 <Cale> takuan: hmm
02:12:08 <Cale> does -O2 do anything more than -O?
02:12:10 <soysauce> > zip ["days", "hours", "minutes", "seconds", "milliseconds"] ((uncurry (:)) (List.mapAccumL (\t d -> (div t d, mod t d)) 86461000 [1000,60,60,24]))
02:12:11 <lambdabot> [("days",1),("hours",0),("minutes",1),("seconds",1),("milliseconds",0)]
02:12:26 <soysauce> how's that?
02:12:30 <[CotL]Godofe_Kei> llol
02:12:30 <[CotL]Godofe_Kei> no
02:12:33 <takuan> no idea Cale 
02:12:35 <[CotL]Godofe_Kei> i need to give miliseconds
02:12:54 <soysauce> I don't follow
02:12:55 <[CotL]Godofe_Kei> and the function gives me how many hours,minutes, seconds, miliseconds
02:12:55 <Lemmih> soysauce: (\t d -> (div t d, mod t d)) == divMod
02:13:09 <soysauce> Lemmih - ah, I didn't know that
02:13:23 <[CotL]Godofe_Kei> for example: 1000 = (0,0,0,1)
02:14:01 <Cale> takuan: compile with -prof -auto-all, and run it with +RTS -p -RTS
02:14:09 <soysauce> > let time t = zip ["days", "hours", "minutes", "seconds", "milliseconds"] ((uncurry (:)) (List.mapAccumL divMod t [1000,60,60,24])) in time 1000000000
02:14:10 <lambdabot> [("days",11),("hours",0),("minutes",40),("seconds",46),("milliseconds",13)
02:14:10 <lambdabot> ]
02:14:35 <soysauce> you could convert it to a tuple, too
02:14:39 <{Arias}> :O
02:14:48 <soysauce> buenos días Arias :P
02:14:54 <{Arias}> buenos dias x)
02:15:22 <takuan> Cale: Failed to load interface for `Prelude':
02:15:22 <[CotL]Godofe_Kei> dude
02:15:28 <[CotL]Godofe_Kei> i dont need Days
02:15:33 <[CotL]Godofe_Kei> and i dont need the strings
02:15:38 <[CotL]Godofe_Kei> just ( , , , )
02:15:50 <{Arias}> remove the zip ...
02:15:50 <Cale> takuan: interesting
02:15:53 <soysauce> > let time t = snd (List.mapAccumL divMod t [1000,60,60,24])) in time 1000000000
02:15:54 <lambdabot>  parse error on input `)'
02:15:55 <soysauce> that gives you a list
02:15:56 <takuan> :D
02:15:57 <soysauce> er
02:15:59 <soysauce> > let time t = snd (List.mapAccumL divMod t [1000,60,60,24]) in time 1000000000
02:16:01 <lambdabot> [0,40,46,13]
02:16:05 <Cale> takuan: maybe add --make?
02:16:08 <{Arias}> yes
02:16:12 <{Arias}> without the zip... xD
02:16:19 <takuan> Could not find module `Data.List':
02:16:24 <soysauce> @pl \(a:b:c:d:[]) -> (a, b, c, d)
02:16:25 <lambdabot> (line 1, column 11):
02:16:25 <lambdabot> unexpected "["
02:16:25 <lambdabot> expecting natural, identifier, "_" or "("
02:16:32 <soysauce> @pl \(a:b:c:d:xs) -> (a, b, c, d)
02:16:36 <Cale> takuan: okay, that's broken :)
02:16:36 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((
02:16:36 <lambdabot> .) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (
02:16:36 <lambdabot> ((.) . (const .)) .)) .) . (,,,) . head) tail
02:16:40 <soysauce> ...wow!
02:16:44 <takuan> apparently the profiling doesn't exist for that module Cale 
02:16:49 <[CotL]Godofe_Kei> dude
02:16:50 <{Arias}> xDDDDDDDd
02:16:51 <[CotL]Godofe_Kei> thats wrong
02:17:08 <[CotL]Godofe_Kei> 1000000000 =/ [0,40,46,13]
02:17:19 <soysauce> do the math yourself :P
02:17:31 <soysauce> 0 milliseconds, 40 seconds, 46 minutes, 13 hours
02:17:40 <[CotL]Godofe_Kei> oh its in reverse
02:17:42 <soysauce> yeah
02:17:48 <soysauce> I made that mistake earlier :|
02:17:52 <takuan> Cale: those are seperate in this distro
02:17:57 <soysauce> here:
02:17:58 <Cale> takuan: ah!
02:18:07 <Cale> takuan: see if you can get those installed
02:18:11 <soysauce> > let time t = reverse (snd (List.mapAccumL divMod t [1000,60,60,24])) in time 1000000000
02:18:13 <lambdabot> [13,46,40,0]
02:18:15 <[CotL]Godofe_Kei> but it stil sint right
02:18:18 <takuan> Cale: they are installing ;)
02:18:22 <Cale> okay
02:18:27 <[CotL]Godofe_Kei> conta (13,46,40,0) = 49600000)
02:18:51 <soysauce> yes, that's because there were days
02:18:53 <soysauce> oh, I see
02:18:57 <[CotL]Godofe_Kei> conta (a,b,c,d) = a*3600000 + b*60000 + c*1000 + d
02:18:58 <soysauce> well, strip off the 24 then
02:19:14 <[CotL]Godofe_Kei> hmm
02:19:16 <[CotL]Godofe_Kei> isee
02:19:38 <[CotL]Godofe_Kei> but thats my problem
02:19:43 <[CotL]Godofe_Kei> cause i can almost make it work
02:19:49 <[CotL]Godofe_Kei> just not for every cases
02:19:51 <soysauce> > let time t = let (h,ms) = (List.mapAccumL divMod t [1000,60,60]) in ms ++ [h] in time 1000000000
02:19:53 <lambdabot> [0,40,46,277]
02:20:05 <[CotL]Godofe_Kei> when the seconds go over 60, its messed up
02:20:11 <soysauce> oh, and a reverse, too
02:20:16 <takuan> Cale: does the program has to end for profiling info to be assembled?
02:20:29 <soysauce> > let time t = let (h,ms) = (List.mapAccumL divMod t [1000,60,60]) in h:reverse ms in time 1000000000
02:20:31 <lambdabot> [277,46,40,0]
02:20:33 <Cale> takuan: hmm... I think that Ctrl-C will be enough :)
02:21:11 <soysauce> > foldl (uncurry (*)) (zip [60,60,1000,1] [277,46,40,0])
02:21:12 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> (b, b)
02:21:12 <lambdabot>   Expected type: b -> b -> b1 -> (b, b)
02:21:12 <lambdabot>   Inferred type: b -> b -> b
02:21:15 <takuan> ok :D
02:21:16 <[CotL]Godofe_Kei> well it works
02:21:43 <soysauce> oh, d'oh
02:21:54 <[CotL]Godofe_Kei> lol
02:22:13 <soysauce> > foldl () 0 (zip [60,60,1000,1] [277,46,40,0])
02:22:14 <lambdabot>   Expecting a function type, but found `()'
02:22:14 <lambdabot>   Expected type: a -> b -> a
02:22:14 <lambdabot>   Inferred type: ()
02:22:14 <soysauce> argh
02:22:18 <soysauce> stupid enter key, sorry :P
02:22:40 <soysauce> > foldl (\a (x, y) -> a+(x*y)) 0 (zip [60,60,1000,1] [277,46,40,0])
02:22:42 <lambdabot> 59380
02:22:50 <[CotL]Godofe_Kei> lol
02:23:14 <soysauce> oh
02:25:01 <[CotL]Godofe_Kei> cant it be done without mapAccuml?
02:25:11 <soysauce> sure, it's just less convenient
02:25:32 <[CotL]Godofe_Kei> i dont understand that mapAcuml
02:26:28 <soysauce> well, you understand the formula, right?
02:26:47 <soysauce> where millis is input, (secs,millis') = (div millis 1000, mod millis 1000)
02:26:56 <soysauce> which is the same as (secs,millis') = divMod millis 1000
02:27:26 <soysauce> and you repeat that to get the number of seconds, minutes, and hours
02:27:37 <[CotL]Godofe_Kei> but with 60
02:27:47 <soysauce> right
02:27:50 <[CotL]Godofe_Kei> hmm
02:28:17 <[CotL]Godofe_Kei> but that way sometimes seconds are gonna be bigger that 60
02:28:36 <[CotL]Godofe_Kei> right?
02:28:48 <soysauce> *initially*, yes
02:29:01 <soysauce> watch:
02:29:08 <tromp_> you're basically changing into a mixed-base number system
02:29:10 <soysauce> > (secs,millis) = divMod 1000000000 1000
02:29:11 <lambdabot>  parse error on input `='
02:29:20 <soysauce> > divMod 1000000000 1000
02:29:22 <lambdabot> (1000000,0)
02:29:34 <soysauce> > divMod 1000000 60
02:29:36 <lambdabot> (16666,40)
02:29:50 <soysauce> (notice that the second half of the tuple is the part that you want)
02:29:55 <soysauce> > divMod 16666 60
02:29:56 <lambdabot> (277,46)
02:29:59 <[CotL]Godofe_Kei> yes i know
02:30:02 <[CotL]Godofe_Kei> hmm
02:30:04 <tromp_> > divMod -2 3
02:30:05 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> (a, a)))
02:30:09 <[CotL]Godofe_Kei> let me thik
02:30:11 <soysauce> so that's 0 milliseconds, 40 seconds, 46 minutes, and 277 hours
02:30:17 <tromp_> > divMod (-2) 3
02:30:19 <lambdabot> (-1,1)
02:30:34 <soysauce> BTW
02:30:47 <soysauce> > foldl (\a (x, y) -> (a+y)*x) 0 (zip [60,60,1000,1] [277,46,40,0])
02:30:48 <lambdabot> 1000000000
02:30:52 <soysauce> :P
02:31:06 <[CotL]Godofe_Kei> >divMod 4500000 60
02:31:15 <[CotL]Godofe_Kei> > divMod 4500000 60
02:31:16 <lambdabot> (75000,0)
02:31:39 <[CotL]Godofe_Kei> > divMod 4500000 1000
02:31:41 <lambdabot> (4500,0)
02:31:52 <[CotL]Godofe_Kei> > divMod 4500 60
02:31:53 <lambdabot> (75,0)
02:31:55 <[CotL]Godofe_Kei> see?
02:32:00 <[CotL]Godofe_Kei> 75 seconds
02:32:13 <[CotL]Godofe_Kei> > divMod 75
02:32:14 <lambdabot>  add an instance declaration for (Show (a -> (a, a)))
02:32:17 <[CotL]Godofe_Kei> > divMod 75 60
02:32:18 <lambdabot> (1,15)
02:32:21 <[CotL]Godofe_Kei> OH!!!!!
02:33:02 <soysauce> :P
02:33:10 <soysauce> convenient, isn't it?
02:33:13 <[CotL]Godofe_Kei> i understand it
02:33:15 <[CotL]Godofe_Kei> thx m8
02:33:21 <soysauce> np
02:33:25 <[CotL]Godofe_Kei> very!
02:34:38 <Saulzar> Cool - my mysterious window corruption has dissapeared after using glade, now I I just get random menu corruption and items dissapearing :)
02:37:12 <{Arias}> jajaja
02:42:28 <Cale> Saulzar: talk to dcoutts :)
02:45:27 <{Arias}> what's de diference between data and newtype ?
02:45:38 <{Arias}> de = the
02:46:48 <Cale> {Arias}: newtype just sets up a new type in the type system which is implemented the same as another type
02:47:18 <Cale> together with a data constructor for values, which the compiler eventually removes
02:47:49 <Cale> data creates new types of structures altogether, which end up as actual structures in the compiled program
02:48:07 <Cale> As a result, if you have
02:48:19 <Cale> data D = mkD Integer
02:48:28 <Cale> newtype T = mkT Integer
02:48:42 <Cale> then (T undefined) is the same as undefined
02:48:49 <Cale> but (D undefined) is different
02:49:37 <Cale> that is
02:49:40 <{Arias}> mmm
02:49:45 <{Arias}> ok, thanks
02:49:48 <Cale> t (T x) = 5
02:49:57 <Cale> t (T undefined) = undefined
02:50:15 <{Arias}> ok
02:50:15 <Cale> (the latter being a result from the first definition)
02:50:20 <Cale> d (D x) = 5
02:50:27 <Cale> d (D undefined) = 5
02:50:38 <Cale> It's kind of subtle
02:50:51 <Cale> another cool difference in GHC
02:51:11 <Cale> is that you can use deriving to pull any classes which the old type supported through to the newtype
02:51:41 <Cale> this is really handy with Monads in particular
02:52:25 <{Arias}> mm
02:52:47 <Cale> You can use newtype to bundle up a bunch of monad transformers applied to your favourite monad, and pull through the instance of Monad, and any other MonadX classes (MonadState, MonadReader, etc)
02:52:50 <takuan> Cale:  the problem was not situated in that part of the code
02:52:55 <takuan> bleurg
02:52:58 <Cale> takuan: ah
02:53:22 <takuan> it was with another function which iterates a given amount of times
02:53:22 <{Arias}> ^^
02:53:49 <takuan> of which I presumed it ran fast enough not to be causing the problem
02:54:12 <takuan> without the `seq` stuff the iterateTillEnd doesn't even create any memory problems at all...
02:54:25 <araujo> Good morning.
02:54:47 <soysauce> buenos araujo
02:54:55 <Cale> takuan: ah
02:55:02 <araujo> Hola soysauce 
02:55:02 <soysauce> {Arias} - any luck?
02:55:17 <takuan> no rests to be understood why it presented any problems at all
02:55:21 <soysauce> araujo - what time is it in Venezuela?
02:55:30 <araujo> Fri Dec 23 06:54:57 VET 2005
02:55:33 <Cale> takuan: so you can fix it with the profiling info then?
02:55:42 <araujo> kind of early :-]
02:55:53 <soysauce> a bit; that's why I was surprised
02:56:02 <takuan> well, i'll see Cale 
02:56:10 <takuan> but normally I should be able to solve it
02:56:24 <Cale> takuan: cool, let me know if you run into any problems
02:56:32 <soysauce> 05:55 12/23/2005 :p
03:02:29 <takuan> Cale: we tried to be too unlazy ;)
03:02:37 <ForgeAus> hey all :)
03:03:04 <Cale> takuan: that's also possible
03:03:10 <takuan> or not
03:03:15 <ForgeAus> hey Cale :) sup?
03:03:28 <Cale> takuan: there are two ways to make a Haskell program more efficient: Make it stricter, and make it lazier
03:03:32 <takuan> mmm
03:03:34 <takuan> strange
03:03:34 <Cale> ForgeAus: not much :)
03:03:40 <ForgeAus> lol Cale 
03:03:43 <ForgeAus> sounds like a paradox
03:04:34 <Cale> By making it lazier, I mean, write each part such that it can produce the first part of its output with a smaller prefix of its input.
03:06:32 <takuan> now this is strange
03:07:21 <takuan> Cale: can you look at the pastepage
03:07:22 <takuan> ?
03:07:40 <takuan> do you see any differance in how the two functions iterate?
03:07:53 <takuan> the lower one throws a mem-eating party for 88 meg
03:08:02 <takuan> the first one keeps it on 4000 bytes...
03:10:19 * Cale looks
03:10:49 <Cale> can you paste the .prof?
03:11:06 <takuan> on the pastepage?
03:11:06 <Saulzar> Ugh, it won't happen for any old data, only the data from the depths of my program... and only in the right order. This one looks fun.
03:11:41 <Cale> Saulzar: is that data Show-able?
03:11:58 <Saulzar> Should be, yeah
03:12:11 <Cale> Use Debug.Trace
03:12:46 <Saulzar> It's in IO anyway
03:12:51 <takuan> Cale: on the paste page?
03:13:08 <Cale> takuan: sure
03:13:50 <Saulzar> There seems to be nothing wrong with the data .. it shows fine (draws to the screen that is)
03:14:06 <Saulzar> But causes something horrific to go wrong with other parts of gtk...
03:14:32 <takuan> Cale: pasted
03:14:40 <takuan> beware, the names of the functions are in dutch
03:14:51 <takuan> itereerTijd = iterateTime
03:15:05 <takuan> itereerTotEinde = iterateTillEnd
03:15:29 <takuan> zetIteratieStap=doIterationStep
03:15:46 <takuan> damn, time to eat
03:16:03 <earthy> just about, yes
03:20:32 <[CotL]Godofe_Kei> anyone knows a good compiler for haskell?
03:20:45 <Lemmih> @where ghc
03:20:46 <lambdabot> http://haskell.org/ghc
03:20:50 <[CotL]Godofe_Kei> yes
03:20:54 <[CotL]Godofe_Kei> but i cant paste there
03:21:10 <[CotL]Godofe_Kei> the amount of code i need to test is too big to put manually
03:21:25 <Lemmih> eh?
03:21:28 <[CotL]Godofe_Kei> and the Hugs98 i have wont let me write more than 2 lines of code
03:21:42 <earthy> huh?
03:21:47 <Lemmih> How about wring the code in a file?
03:21:47 <[CotL]Godofe_Kei>  [(1, [(0,5,3,433), (0,10,6,817), (0,15,9,271),
03:21:48 <[CotL]Godofe_Kei>           (0,20,12,488), (0,25,15,0)]),
03:21:48 <[CotL]Godofe_Kei>      (2, [(0,0,34,582), (0,1,1,332), (0,1,30,801),
03:21:48 <[CotL]Godofe_Kei>           (0,2,2,767), (0,25,15,13)]),
03:21:48 <[CotL]Godofe_Kei>      (3, [(0,1,3,198), (0,3,14,159)])]
03:21:51 <earthy> you have a textfile with the code, right?
03:21:55 <[CotL]Godofe_Kei> nop
03:21:58 <earthy> then just load *that* into hugs...
03:21:59 <[CotL]Godofe_Kei> how do i do that?
03:22:04 <earthy> open notepad
03:22:10 <earthy> paste the code into notepad
03:22:12 <tromp_> @paste
03:22:13 <earthy> save the file as code.hs
03:22:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:22:16 <[CotL]Godofe_Kei> lol
03:22:18 <[CotL]Godofe_Kei> oh that
03:22:22 <[CotL]Godofe_Kei> yes of corse i have that
03:22:34 <earthy> then why not just :load file.hs ??
03:22:35 <earthy> in hugs?
03:22:35 <[CotL]Godofe_Kei> but the arguments i need to insert to thes the code are too big
03:22:50 <earthy> then add definitions for those arguments to the file
03:22:56 <earthy> ie
03:23:17 <earthy> test1 = application_of_function to a huge bunch of arguments so I wont have to type them again
03:23:34 <earthy> then you load up the file
03:23:41 <earthy> and at the prompt just type
03:23:42 <earthy> test1
03:24:16 <earthy> shouldn't be too hard, right? :)
03:25:38 <[CotL]Godofe_Kei> *** Type           : [(Integer,[(Integer,Integer)])]
03:25:38 <[CotL]Godofe_Kei> *** Does not match : [(Int,[(Int,Int)])] 
03:25:42 <[CotL]Godofe_Kei> ?!?!?!?!?!?!
03:26:05 <[CotL]Godofe_Kei> i think the compiler is making fun of me
03:26:46 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] ADD 39 musasabi
03:26:50 <Stinger> one of them is a boundless integer and one is fixed bit width
03:27:08 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] DEL 39
03:27:14 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] DEL 39!*@*
03:27:24 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] ADD musasabi 39
03:27:30 <Stinger> as far as my limited knowledge of haskell tells me anyhow
03:27:34 <Lemmih> What's up, shapr?
03:27:50 * ricebowl supposed this is in response to yesterday
03:28:16 <shapr> Lemmih: y0
03:28:47 <shapr> I think I set verbose some long months ago, but had forgotten it worked quite that way.
03:28:49 <Tweakee> hey shapr :)
03:29:05 <shapr> g'day Tweakee, how're you liking Haskell?
03:29:15 <Tweakee> hehe its ForgeAus here... 
03:29:21 <earthy> CoTL: no, it isn't
03:29:23 <shapr> Yeah, I recognize your hostname.
03:29:24 <Tweakee> just felt like a nickchange
03:29:29 <sieni> > (\x -> (2::Integer) * x) 7::Int
03:29:31 <lambdabot> Couldn't match `Int' against `Integer'
03:29:32 <Tweakee> I see
03:29:39 <sieni> >  (\x -> (2::Integer) * x) $ fromIntegral(7::Int)
03:29:40 <lambdabot> 14
03:29:45 <shapr> Have you found any differences from Pascal? ;-)
03:29:57 <earthy> Int is a type of bounded integers between (at least) -2^29 and 2^29 -1
03:30:17 <Tweakee> lol many... but strangely many similarities too (well not really.. yet at least whole numbers are Integers in both! lol)
03:30:19 <earthy> Integer is an unbounded type of integers
03:30:30 <earthy> Tweakee: no. ;)
03:30:50 <earthy> Integers in Pascal are bounded, in Haskell they are not. ;)
03:30:54 <Tweakee> and I take it the if/then/else statements are similar (but then most languages are)
03:31:02 <Tweakee> bounded?
03:31:08 <shapr> Tweakee: Actually, if then else is a function in Haskell...
03:31:12 * Tweakee unstraps his number
03:31:18 <shapr> Because it's just a case statement under the hood.
03:31:35 <Lemmih> urk. statement/expression.
03:31:35 <shapr> So both branches must return the same type, unlike something like Python.
03:31:36 <Tweakee> yeah... well case, if then... I get it
03:31:51 <earthy> Tweakee: as in: there is a minimum Integer in Pascal, and a maximum Integer
03:31:57 <shapr> Lemmih: Right, statement implies side-effects, yes?
03:32:14 <shapr> My gf was sick last night, I didn't get much sleep.
03:33:23 <Tweakee> earthy I think theres a range, but its prolly implicit.. I'm sure I heard of a MAXINT value before for it
03:33:24 <Tweakee> lol numerically speaking, euphoria is the best that way, doesn't have int, float, etc.. it just got number ... no conversion necessary! lol
03:34:08 <Tweakee> (but then its designed for that kind of simplicity, somewhere along the line it prolly creates more problems)
03:34:22 <Tweakee> brb
03:36:02 <Tweakee> back
03:37:00 <Tweakee> so.. sup? am I dissed or is no1 chatting?
03:37:09 <shapr> I'm thinking about proof theory.
03:37:23 <Tweakee> lol another oxymoron uh?
03:37:51 <Cale> hehe
03:38:02 <shapr> I've realized that many deep thinkers on #haskell and other deep theory forums believe that the things they think up are obvious to everyone else.
03:38:03 <Tweakee> Cale, they my favourite kinda morons :)
03:38:21 <Tweakee> shapr, obviously :)
03:38:35 <Cale> shapr: haha
03:38:50 <Tweakee> its much harder to unlearn something than most ppl realize
03:39:03 <shapr> For example, the connections I make between the bits of knowledge I've learned don't seem unusually interesting to me.
03:39:25 <Tweakee> shapr thats why I love being a newbie with some things sometimes
03:39:39 <Tweakee> you get a whole new outlook to open up to you
03:39:43 <shapr> So I think it's more important for us to document the connections we make via blogs, journal, or something.
03:41:12 <Tweakee> grrr... this connection issue is getting to be a pain in the behind!
03:41:27 <Tweakee> no wonder shapr remembered my hostmask! lol
03:41:35 <Cale> hehe
03:41:42 <rep> http://www.penny-arcade.com/comic/2005/12/16
03:41:58 <Cale> rep: yeah, that one is pretty good
03:42:42 <araujo> rep, hahaha
03:42:48 <Tweakee> rofl
03:42:59 <Tweakee> stickipedia?
03:46:59 <Cale> shapr: The failure of Hilbert's program is one of the most mind blowing things ever devised by mathematics/logic.
03:47:55 <Tweakee> well not everything's about logic
03:48:04 <Tweakee> its just a tool.. that helps a bunch.. 
03:49:01 <takuan> Cale: did you look at the pastepage already?
03:49:22 <Cale> takuan: had a look
03:49:31 <takuan> any ideas?
03:49:47 <takuan> it's kinda strange isn't it?
03:49:48 <Cale> takuan: hoortTotDomein seems to be eating 50% of the time and allocation
03:49:53 <takuan> that's normal
03:49:59 <takuan> because I call it all the time
03:50:13 <Cale> hmm
03:50:26 <Cale> do you end up calling it with the same parameters?
03:50:32 <takuan> it determines whether a point of the matrix belongs to the domain or not
03:50:43 <takuan> well
03:50:50 <takuan> that i haven't done yet
03:50:50 <takuan> second
03:51:01 <shapr> Cale: eh?
03:51:57 <takuan> same stuff happening
03:53:48 <shapr> Cale: Sounds familiar, but I can't place it. What are you talking about?
03:54:44 <Cale> shapr: The idea that there might be a complete and consistent foundation for arithmetic, or mathematics in general, which we could verify in terms of finitary truths about numbers
03:55:39 <Tweakee> transfinite numbers are fun
03:55:41 <Cale> complete meaning that every statement or its negation is provable, and consistent meaning that you never prove both a statement and its negation
03:55:54 <takuan> Cale: could it be because of the fact that seconds create a kind of dependency?
03:56:05 <Cale> seconds?
03:56:07 <takuan> i mean, the n in apply
03:56:11 <takuan> 'n' that is ;)
03:56:17 <Cale> takuan: hmm
03:56:34 <Cale> takuan: how is hoortTotDomain defined?
03:57:02 <shapr> Cale: But this idea failed with GÃ¶del's incompleteness theorem, yes?
03:57:05 <takuan> it has nothing to do with the matrix
03:57:07 <Cale> shapr: yeah
03:57:25 <takuan> it just takes a position in doubles and checks whether that positions belongs to the domain or not
03:57:51 <tromp_> GÃ¶del kept all mathematicians in business, showing their work can't be automated:)
03:58:43 <takuan> that's the entire program http://rtega2.ath.cx:7892/thesis/programs/diff/Haskell/diffusion2d.hs
03:59:50 <Cale> hmm
03:59:51 <takuan> but still
03:59:59 <takuan> that hoorttotdomein function is not the problem
04:00:14 <Cale> takuan: add some extra SCC's to zetIteratieStap
04:00:22 <takuan> scc?
04:00:29 <takuan> sequencing stuff?
04:00:34 <Cale> profiling :)
04:01:01 <Cale>    {-# SCC "name" #-} <expression>
04:01:14 <Cale> you add them to expressions like that
04:01:27 <takuan> ok
04:01:28 <Cale> where "name" is how they'll show up in the profiling output
04:01:30 <takuan> where do you want them?
04:02:03 <Cale> just before array in losop2d would be good
04:02:13 <Cale> hmm
04:02:39 <Cale> and just before the call to bereken in the array definition
04:04:21 <Cale> takuan: what kind of monitor do you have by the way? :)
04:04:27 <takuan> monitor?
04:04:30 <takuan> 21 inch
04:04:33 <Cale> ah :)
04:04:39 <takuan> because of the width of the code? ;)
04:04:41 <Cale> that explains some of these lines :)
04:04:42 <Cale> yeah
04:04:48 * takuan hates linebreaks
04:04:57 <takuan> in haskell code that is
04:05:30 <Cale> I had that problem with the 23" Cinema HD displays we had where I was working :)
04:05:54 <takuan> http://rtega2.ath.cx:7892/thesis/programs/diff/Haskell/a.out.prof
04:05:57 <genneth> shapr: do you know of any blogging software written in haskell?
04:06:26 <Cale> my friend there would set his terminal at 80x25, and fill the screen with it. The characters were 200 pixels tall :)
04:06:53 <shapr> genneth: Yup, PLog and BloB
04:07:03 <Cale> takuan: surprising results there...
04:07:15 <takuan> why?
04:07:23 <shapr> genneth: I use PLog 0.0.6, bringert wrote BloB, you can find it on http://www.bringert.net/projects.html
04:07:24 <takuan> too big?
04:07:30 <Cale> takuan: too small
04:07:37 <shapr> genneth: In any case, I'd rather hack Flippi to generate an RSS feed.
04:07:48 <genneth> shapr: thanks!
04:07:51 <shapr> It makes more sense to me too update my blog entries when I learn more info.
04:10:22 <araujo> @index isSpace
04:10:23 <lambdabot> Data.Char
04:12:42 <shapr> The last part of your blog post is *really* funny.
04:13:04 <shapr> roconnor: er, that was meant for you :-)
04:13:09 * shapr is asleep
04:13:15 <takuan> Cale: any suggestions?
04:14:52 <roconnor> The NSA thing?
04:15:28 <shapr> yup
04:15:37 <roconnor> I want the factors damn it.
04:15:46 <shapr> I actually laughed out loud.
04:16:03 <roconnor> I find it a bit bizare that I know the number is composite, but I can't factor it.
04:16:38 <roconnor> I guess that you don't work for the NSA.
04:17:11 <shapr> roconnor: Definitely not. I doubt they'd hire me.
04:17:22 <Cale> takuan: hmm
04:17:53 <Cale> takuan: add SCC's until you find out what part of zetIteratieStap is eating all the time and space
04:18:05 <Cale> I'd have thought it would be the array
04:18:14 <Cale> but that's a smaller percentage
04:20:59 <roconnor> I wonder if anyone working for the NSA reads my blog.
04:21:15 <Cale> roconnor: why?
04:21:22 * araujo saluda a Nomius__ 
04:21:48 <roconnor> Because maybe they can the composate number that I posted.
04:21:54 <Cale> hehe
04:21:57 * araujo just added quote'd expressions support to hashell
04:22:16 <araujo> No you can remove insane files names :-]
04:22:53 <Cale> roconnor: oh, did you go to UW?
04:23:05 <roconnor> yes
04:23:17 <Cale> cool, I recently graduated from there
04:23:23 <roconnor> oh
04:23:34 <Cale> BMath in pure mathematics
04:23:37 <roconnor> I though you were European for some reason.
04:23:39 <Cale> hehe
04:23:52 <Cale> my strange waking hours probably
04:23:54 <roconnor> Like that you are awake now.
04:24:18 <Cale> I'm actually on what's closer to Australian time, as dons has noted in the past :)
04:24:24 <roconnor> ah
04:25:08 <Tweakee> 11.24pm here in aus
04:25:31 <Cale> Tweakee: yeah, I'm just starting to get a bit sleepy, but I need to stay up today.
04:25:31 <shapr> @localtime shapr
04:25:33 <lambdabot> Local time for shapr is Fri Dec 23 13:25:10 2005
04:25:33 <cpatrick> Tweakee: depends which side of aus you're on ;P
04:25:38 <Cale> I should reset my hours
04:26:30 <Tweakee> South-East coast (near Melbourne)
04:26:50 <Tweakee> @localtime Tweakee
04:26:56 <lambdabot> Local time for Tweakee is Fri Dec 23 23:26:26 2005
04:27:12 <Tweakee> ahh its in 24 hour!
04:27:19 <Tweakee> and does it via ctcp request!
04:27:26 <Tweakee> handy tho
04:27:45 <roconnor> @localtime roconnor
04:27:47 <lambdabot> Local time for roconnor is Fri Dec 23 13:28:17 2005
04:28:24 <cpatrick> yeah. I'm in a different timezone to my IRC box so it gets it wrong for me
04:28:28 <cpatrick> @localtime Cale
04:28:30 <lambdabot> Local time for Cale is Fri Dec 23 07:28:07
04:28:41 <Cale> cpatrick: haven't slept :)
04:28:44 <alar> @localtime ala
04:28:45 <alar> @localtime alar
04:28:47 <lambdabot> Local time for alar is Ïò äåê 23 15:27:24 2005
04:29:02 <cpatrick> Cale: ouchie.
04:29:23 <takuan> @localtime takuan
04:29:27 <alar> hehe, it doesn't work locale around
04:29:29 <lambdabot> Local time for takuan is Fri Dec 23 13:29:02 2005
04:29:36 <takuan> that's right
04:30:53 <Tweakee> how come alars a few mins short?
04:31:08 <shapr> needs to use ntp? :-)
04:31:55 <alar> synced local clock 2 months ago from GPS
04:32:52 <shapr> Yeah, but every clock chip has drift.
04:33:00 <shapr> That's why ntpd is used.
04:33:10 <shapr> That's also how the recent "identify any hardware regardless of OS" works.
04:34:06 <alar> our local ntp server is down, and I'm too lazy to adjust gateways/proxies for internet ntp server
04:34:45 <Tweakee> why don't they dump drivers (even manuals) on an eeprom chip? that way they wouldn't need to distribute a CD to go with ur device!
04:35:26 <Tweakee> or am I just too lazy?... or something?
04:35:33 <alar> Tweakee compare the size of typical EEPROM with the size of typical driver
04:35:54 <Tweakee> well they do chunk up the damn things too much don't they? lol
04:36:19 <alar> yes, those sizes are beyond normality
04:36:34 <Tweakee> all software seems to be these days
04:36:51 <Tweakee> howcome partition magic jumped from a few meg to hundreds?... 
04:36:58 <takuan> Cale: well, now I know that hoortTotDomein is a costly function
04:36:58 <Tweakee> just coz some cushy windows interface?.. 
04:37:19 <takuan> it computes essentially the same data over and over again
04:37:36 <takuan> but that alone does not explain the fact that the program allocates so much memory
04:37:45 <Tweakee> the actual partitioning and program itself, prolly only takes up less than 10 mb!.. 
04:38:01 <takuan> and when using the other function which uses iteratieStap also there's virtually no memory usage
04:38:03 <Tweakee> ahh memory allocation.. interesting
04:38:55 <alar> imho no sane code can be > 1MB
04:39:04 <alar> when there are no tables embedded
04:39:09 <twb> @info Either
04:39:10 <lambdabot> Unknown command, try @listcommands.
04:40:21 <Tweakee> well some big programs I can believe over 1 mb, like say a game - age of mythology or something... but most of the extra is themetic copying (ie different units using same method, just diff graphix and stats)
04:40:33 <alar> no
04:40:46 <alar> that's data that is > 1 MB
04:41:24 <alar> data tables can consume terabytes, but no _sane_ code
04:41:40 <alar> @get-shapr
04:41:41 <lambdabot> shapr!!
04:41:44 <alar> lol
04:41:44 <Tweakee> and why isn't there a game like starcraft as an fps -> vehiclular/mech -> flightsim ... 
04:41:54 <Tweakee> I mean theres starcraft Ghost... which has the FPS bit
04:42:45 <Tweakee> but wouldn't it be awesome to choose terran, zerg or protoss units, and have options to upgrade to bots/vehicles etc.. , then further to ships/flying...
04:42:50 <alar> starcraft uses lot of pictures, tables etc.
04:42:57 <Tweakee> yeah
04:43:04 <Tweakee> but that was when it was 2D strategy
04:43:09 <Tweakee> prolly needed it
04:43:23 <Tweakee> an fps vers would have to b 3D pretty much
04:43:30 <twb> Grr, another haskell-mode binding that can't be typed.
04:43:32 <alar> and now it creates pictures functiuionally? =)
04:43:39 <soysauce> libxml is bigger than 1MB, isn't it?
04:43:42 <alar> via cyber-drawer bot?
04:43:45 <Stinger> Tweakee battlezone 2
04:43:54 <Stinger> cool game :)
04:43:56 <soysauce> "Hello, world" as compiled by GHC is about 300KB on my machine, IIRC
04:43:59 <Tweakee> stinger? havn't heard of it
04:44:02 <soysauce> maybe it was 500KiB
04:44:14 <Stinger> its oldish now and it was pretty low key
04:44:20 <Tweakee> plus it sounds very warlike (I liked the storyline and sci-fi theme of starcraft)
04:44:26 <Tweakee> otherwise i'd be playing warcraft! lol
04:44:40 <alar> soyasauce, then you have the ratio: "hello world" has only a few hundred bytes of actual working code
04:44:43 <Stinger> its scifi
04:44:49 <alar> and lots of crap around
04:44:54 <cpatrick> alar: it gets worse for real code
04:45:17 <cpatrick> e.g. one app I've been writing is ~1600 lines of haskell (largely comments!) and a ~3mb executable
04:45:32 <cpatrick> (down to a mere 2mb when stripped)
04:45:54 <cpatrick> ghc produces bloaty code
04:46:03 <alar> cpatrick: in C the ratio gets better for real code: there's static overhead
04:46:12 <Tweakee> cpatrick perhaps someone needs to write an optimizer?
04:47:25 <genneth> i'm having difficulty installing haxml
04:47:36 <genneth> it bomb out when trying to register with ghc
04:47:54 <Tweakee> version difficulty?
04:48:01 <genneth> ghc-pkg says: Reading package info from stdin ... ghc-pkg: Line 1: Invalid syntax (no colon after field name)
04:48:28 <genneth> ghc is 6.4.1, haxml is 1.13
04:49:26 <Tweakee> is there a specification on haxml which one it works with?
04:50:01 <genneth> it claims anything above ghc 5...
04:50:23 <alar> the same here
04:50:24 <Lemmih> genneth: The build system changed a lot in GHC-6.4.
04:50:47 <alar> maybe MinGW version of GHC is somewhat different?
04:50:52 <Lemmih> All packages need to be repackaged.
04:50:59 <genneth> aha -- it seems that cabal is the way to go
04:51:32 <shapr> alar: You called?
04:51:44 <twb> Does cabal work easily with Debian's debian/rules?  It seems to me it should.
04:51:45 <alar> shapr: not actually
04:51:55 <alar> just found strange command of lambdabot
04:52:00 <shapr> ah ok
04:52:04 <alar> and wondered what it does
04:52:12 <shapr> It calls me!
04:52:16 <twb> dh-cabal would be cool.
04:52:24 <alar> shapr: how?
04:52:34 <cpatrick> twb: it already exists, dh_haskell
04:52:39 <twb> Aha.
04:52:41 <tic_> have you guys seen Koen Claessen around here? :)
04:52:53 <shapr> alar: I see the word shapr light up in bright green.
04:52:54 <shapr> tic_: never
04:53:14 <tic_> shapr, didn't think so.
04:53:22 <tic_> I want results from my exam damnit. :P
04:53:27 <alar> shapr: are you _the_very_special_person_ to complement lambdabot?
04:53:53 <shapr> What does that mean?
04:54:10 <alar> why does it call you? not someone else?
04:54:53 <alar> does lambdabot think that when it's incapable of doing something it should ask your help?
04:54:53 <genneth> hmmm... it seems that haxml 1.13 is supposed to work with ghc 6.4
04:54:55 <shapr> Someone recently said "Shae is everywhere in the Haskell community." That's something of an overstatement, but I do tend to know what's going on in most of the community, and I'm often involved as an organizer or implementor.
04:55:11 <alar> cool
04:56:09 <shapr> I started #haskell channel, I maintain the Haskell wiki, I started The Monad.Reader, I started haskell-libs on sourceforge (now mostly defunct). I host Haskell oriented users and projects on ScannedInAvian.org. I probably do some other stuff I've forgotten.
04:56:40 <Tweakee> shapr sounds like ur a busy dude
04:56:56 <tic> shapr, stop being so ¡$£¡$ ambitious; make us mere mortals feel bad about ourselves :P
04:56:59 <shapr> Oh, and I give tours and introductions on #haskell.
04:57:09 <twb> Tweakee: he probably has robot minions to assist hi.
04:57:11 <Tweakee> lol I noticed that bit
04:57:11 <twb> *him
04:57:15 <Tweakee> rofl twb
04:57:18 <shapr> tic: I'm not ambitious, I'm not even very organized. I just do what's fun.
04:57:20 <alar> @karma shapr
04:57:20 <lambdabot> shapr has a karma of 16
04:57:21 <Tweakee> actually thats a good thing
04:57:33 <shapr> I'm sort of getting tired of the organizational side of things lately. I'd rather hunker down and write some code.
04:57:37 <twb> Stupid slow terminals.
04:57:40 <Tweakee> hey sdfgs ... robotic minions assisting is quite handy I'd suggest
04:57:55 <Tweakee> (sdfgs that wasn't directed to you btw.. I was just saying hey)
04:58:06 <sdfgs> yo
04:58:10 <alar> then you might be the right person to promote #haskell_ru
04:58:10 <tic> shapr, yeah, just rub it in. :)
04:58:10 <Tweakee> lol yo
04:58:16 <shapr> My focus is shifting towards Epigram, dependent types, and proof programming in general.
04:58:22 <sdfgs> hiya MC :D
04:58:31 <tic> proof programming? what fun is that? :)
04:58:38 <Tweakee> what is proof programming?
04:58:38 <shapr> tic: 'ambition' is easier than you think. You just do what's fun, and then people think you work hard.
04:58:40 <twb> shapr: have to stay out of the mainstream, eh?
04:58:42 <alar> oh, then you're the one I need
04:58:53 <tic> shapr, maybe.  school's sucking out my energy.
04:59:08 <shapr> alar: I'd suggest you rename it to #haskell.ru and if you get popular you might be able to register the domain as well.
04:59:18 <Tweakee> tic, learn a physical skill ... (might help you build energy.. ) also diet...
04:59:49 <twb> Tweakee: he's dieting right now.
04:59:59 <shapr> tic: The secret is, don't let anything suck out your energy. But remember, I dropped of school after taking CS101 so I've followed my own advice somewhat to the exclusion of hireability.
05:00:00 <Tweakee> twb, I hope its a healthy one! :)
05:00:00 <tic> Tweakee, I'm fairly good at dancedancerevolution, I work out 3-4 days a week, and except for this last month I've been biking 70-100 km per week. It's not that :)
05:00:16 <Tweakee> tic, sounds kewl
05:00:18 <alar> there is the domain, but it lacks good content filling and I don't know who handles it
05:00:26 <twb> Tweakee: diet is a fancy word for conference, in case you missed it.
05:00:29 <tic> shapr, yup, I know. It's not much left of school now, so that's good.
05:00:31 <Tweakee> btw I am so unco, dance dance rev... I'd fall over every second beat!
05:00:47 <shapr> tic: Motivation is everything, so cultivate what you have.
05:00:50 <Tweakee> twb yeah well I never heard it used that way before
05:00:53 <tic> Tweakee, haha. practice makes perfect, you know! I sucked majorly at the beginning.
05:01:05 <tic> shapr, cultivate == ? (not quite sure in this context)
05:01:10 <Tweakee> tic, watch the chick on the screen dance, that capoeira rox!
05:01:20 <Tweakee> only emulating it is a little more difficult
05:01:27 <Tweakee> ok then ALOT
05:01:27 <shapr> tic: For example, I know you like BeOS and Python, so dive into those and do as much as your interest can push you to do.
05:01:39 <shapr> Yeah, capoeira is way spiffy.
05:01:42 <Tweakee> hmm Boo is like Python
05:01:46 <shapr> Oh, I mean in real life.
05:01:50 <Tweakee> just for #develop
05:01:52 * shapr wants to learn capoeira.
05:01:54 <tic> Hrm, I should _someday_ pick up Jiujitsu again.
05:02:00 <tic> school forced me to quit, sadl.
05:02:01 <Tweakee> yeah shapr I agree
05:02:18 <Tweakee> jiujitsu? really?... interesting
05:02:20 <tic> shapr, wow, didn't think you'd remember that trivia about a random guy like me.
05:02:24 <Tweakee> ancient samurai art right?
05:02:27 <tic> Tweakee, yeah, some ten years.
05:02:32 <tic> Tweakee, judo comes from jiujitsu
05:02:45 <Lor> Isn't the common transliteration nowadays "ju-jutsu"?
05:02:45 <shapr> tic: You're not just a random guy.
05:02:55 <Tweakee> tic is it like an antithesis to ninjitsu?
05:02:59 <Lor> (Or possibly without the hyphen.)
05:03:00 <Tweakee> (and Taijutsu)
05:03:05 <tic> Lor, different styles. jiujitsu is the softer form of jujutsu
05:03:14 <tic> Tweakee, not quite sure there..
05:03:20 <Lor> Are they written differently in Japanese?
05:03:39 <tic> Lor, I think so.  But in japanese, they'd be written more closely to zuzutsu
05:03:46 <tic> Tweakee, jujutsu is supposed to be what the samurais did when they lost their sword.
05:03:58 <tic> shapr, well, random enough. :) But thanks, I guess. 
05:04:00 <Tweakee> hehe a bit like aikido then I guess
05:04:22 <Tweakee> training with bo weapons is kewl tho... 
05:04:23 <tic> shapr, as a matter of fact, I'm moving to germany and yellowTAB in a couple of months to do my master's thesis. Python and BeOS. :)
05:04:27 <Philippa> more practically-focused than aikido is at the early stages. Plus a samurai'd be more likely to learn aikijutsu
05:04:31 <shapr> tic: I take everyone seriously unless they flip my bozo bit. You've compared Haskell and Python in interesting ways that I found enlightening.
05:04:41 <shapr> tic: Awesome! Follow your dreams!
05:05:03 <Tweakee> Philippa sounds kewl, I havn't heard of aikijutsu before..
05:05:26 <tic> shapr, [enlighting] I like discussing programming langages, glad someone likes my ramblings. :)  [dreams] yup, that's the plan!
05:05:27 <Philippa> Tweakee: it's the "just about the combat" art that aikido derived from
05:05:30 <Tweakee> plus although aikido is kewl the one thing I don't like about it is its mostly a hand-art.. not much kicking involved
05:05:36 <shapr> I'm looking for people to take over TMR, HaWiki, and other stuff. Any volunteers?
05:06:19 <Tweakee> Steven Segal did mostly Aikido (or some kinda variant), right?
05:06:33 <Philippa> kicking's a great way to get your kneecap dislocated or your knee outright broken
05:06:34 <Lor> Are we now going to get into deep discussions about the do/jutsu -distinction?
05:06:37 <tic> Tweakee, korrekt.
05:06:50 <Tweakee> Philippa, possibly... I wouldn't know
05:07:00 <Tweakee> lol sorry Lor
05:07:04 <Tweakee> I'm just interested thats all
05:07:06 <tic> kicking can be fun. punching too.  Like Sport-Jujutsu.  But generally, I like the jiujitsu stuff for the agility
05:07:09 <Philippa> Tweakee: if someone can block your kick, there's good odds that with the right training they can also pop your kneecap in the process
05:07:21 <Philippa> it doesn't actually take that much force to do
05:07:25 <tic> What would be fun is to try some shaolin-style
05:07:34 <Tweakee> kung fu
05:07:34 <shapr> I'm going unicycling, but if someone wants to jump onto TMR, HaWiki, etc talk to me.
05:07:37 <Philippa> yeah, fun if often impractical
05:07:40 <Philippa> 'swhat I used to study
05:07:43 <Tweakee> thats mostly based on animal forms
05:07:49 <shapr> I want to switch my effort to finishing stuff like Conjure, FLM, etc.
05:07:57 <tic> Tweakee, "kung fu" is like budo. It's basically means "martial arts" in chinese.
05:07:59 <Tweakee> like horse stance, drunken monkey style, white crane, etc etc....
05:08:13 <tic> Tweakee, shaolin is a style of kung fu. and there, you have San Da (more fighting) and others.
05:08:15 <tic> yo Lemmih
05:08:18 <tic> err, lennart
05:08:27 <Philippa> "shaolin" is, er, many styles really
05:08:36 <lennart> yo
05:08:37 <Tweakee> Philippa, yeah.. 
05:08:38 <Philippa> a lot originated in that temple
05:08:48 <Philippa> tic: "wu shu"'s more accurate for martial arts per se
05:08:50 <Tweakee> okinawa?
05:09:04 <Philippa> anyway, I need to shower and pack and stuff
05:09:09 <Philippa> I'm supposed to be on a train in 80 minutes
05:09:14 <Lor> And let's not get started about what is properly "budo" and what not...
05:09:28 <tic> Philippah,, ah, okay.
05:09:28 <Tweakee> yeah well back to Haskell  uh?
05:09:38 <Lor> (There's one school of thought that effectively excludes everything except some forms of karate and judo...)
05:09:41 <tic> Philippa, wasn't totally sure there
05:10:10 <tic> Lor, would budo be the sport styles? You said judo, so wouldn't that include jiujitsu as well, being the "parent" of judo
05:10:10 <tic> ?
05:10:38 <Lor> I said let's not... :)
05:11:03 <Lor> But no, whatever "true budo" is supposed to be, it's definitely not sport.
05:11:06 <Tweakee> judo is related to wrestling alot... 
05:11:25 <Lemmih> Hiya tic (:
05:11:35 <Tweakee> budo is like some religion almost I guess
05:11:49 <tic> Lemmih, well hi to you too. :)
05:11:58 <Lor> (Disclaimer: the only martial arts I've practiced are hapkido and western swordsmanship, so don't take my word for anything related to Japan...)
05:12:25 <Tweakee> yeah well the only thing I know about budo comes from Guy in Street Fighter Alpha games! rofl!
05:13:09 <Tweakee> ie, very little
05:13:36 <tic> Any of you guys done any Python hacking perchance? I'm curious about if it'd be possible to hack in juxtaposition and auto-currying in a nice way. (there seem to be a few of you coming from a Python world here)
05:16:05 <Tweakee> python rox, unfortunately I probly don't know enough to assist u
05:17:45 <tic> seems I managed to spawn a micro-discussion over at #python. :)
05:18:54 <Tweakee> need to be registered to join there tho
05:19:07 <tic> didn't know. 
05:19:14 <tic> so register. :)
05:19:19 <Tweakee> why?
05:19:34 <Tweakee> I'm mostly just interested in here for the moment anyhow
05:19:35 <tic> by registering you can also query people. can't do that otherwise.
05:19:58 <Tweakee> I see
05:21:27 <genneth> shapr: ever used HAppS for anything?
05:22:27 <Pupeno> good morning.
05:36:10 <ProfTeggy> Merry Christmas, pals.
05:36:16 <ProfTeggy> I'm off 
05:36:37 <ProfTeggy> Be seeing you next year.
05:47:38 <xs> hm. if data T m a = (C m b) => T (b a), and in class C, m -> b, why can't ghc bind b?
05:48:53 <shapr> genneth: A bit
05:49:44 <shapr> tic: I suspect you could implement a usable Starkiller in Haskell without much work.
05:49:46 <twb> I have "import Text.ParserCombinators.Parsec.Errors", but "SourcePos "" 0 0" still gives ERROR - Undefined data constructor "SourcePos".  Why?
05:50:02 <shapr> @index SourcePos
05:50:02 <lambdabot> Text.ParserCombinators.Parsec.Pos, Text.ParserCombinators.Parsec
05:50:08 <Cale> xs: hmm, b isn't in scope
05:50:14 <shapr> twb: .Pos instead?
05:50:32 <twb> shapr: I still get it.
05:50:39 <tic> shapr, what's Starkiller?
05:51:11 <shapr> tic: Michael Salib's static typing system for Python based on Self's polymorphic inline caching static typing. Cartesian types, I think it's called.
05:51:16 <Cale> xs: data T m a = forall b. (C m b) => T (b a)
05:51:24 <twb> tic: it's where you inject a semistable black hole into a star.
05:51:30 <tic> twb, pfft. :)
05:51:31 <Cale> xs: does that work?
05:52:10 <tic> shapr, yowza. Interesting stuff; I'm currently reading a paper on types and such, so I don't feel I'm really up-to-par yet.  :) But thanks for the advice.
05:52:22 <shapr> Cale, did you understand what Derek was writing about Free algebras? Do you have the intersection of time, interest, and sufficient sleep to explain it to me in greater depth?
05:52:42 <shapr> tic: BC Pierce's Types and Programming Languages is great.
05:52:43 <Cale> shapr: Well, I'm new to the idea of free algebras as well
05:52:53 <Cale> (at least, at that level of abstraction)
05:53:21 <Cale> I could try :)
05:53:33 <shapr> His post immediately made perfect sense to me. It looks like audreyt's ideas about the teachability of GADTs.
05:53:45 <shapr> But I don't know the next step after that.
05:54:09 <Cale> where was that post again?
05:54:40 <lisppaste2> twb pasted "Why isn't SourcePos bound?" at http://paste.lisp.org/display/14941
05:54:45 <shapr> Cale: http://lambda-the-ultimate.org/node/view/1183#comment-12896
05:54:48 <tic> shapr, this is what I'm reading: http://citeseer.ist.psu.edu/cardelli85understanding.html
05:54:57 <xerox> shapr: hey!
05:55:08 <shapr> hiya xerox 
05:55:12 <xerox> Yesterday I crafted a goban!  19x19 on one side, 9x9 on the flip side!
05:55:55 <Cale> xerox: cool!
05:56:09 <Cale> xerox: take some photos :)
05:56:16 <xerox> Yeah, now I have to find real people to use it with, too :)
05:56:19 <xerox> Will do! :-)
05:56:25 * twb whines and scratches at the door of knowledge.
05:56:31 <Cale> twb: hehe
05:57:05 <cpatrick> mmm, go
05:57:08 <shapr> tic: Yeah, cardelli is great.
05:57:08 <cpatrick> haven't attempted to play that in ages
05:57:17 <tic> shapr, indeed.
05:57:36 <cpatrick> twb: want a battering ram? ;)
05:57:38 <shapr> xerox: I bleached my hair yesterday! I have blonde streaks now.
05:58:08 <shapr> twb: The way I see, I erode away the frontiers of knowledge. After spending lots of time on something, it may not feel like I've made much progress, but the notes in my margins show a dramatic improvement in clue.
05:58:12 <Cale> shapr: Ah, heh, why didn't I think of that! Hehe, this free monad thing is nice :)
05:58:15 <xerox> shapr: whoopee.  I thought about coloring mine blue for long time, but now they're *too* long to try.
05:58:36 <shapr> Cale: This is what I've been talking to you about for days! :-)
05:58:41 * shapr hops!
05:58:56 <shapr> xerox: My hair is about midback, it's getting so long it takes real time to shower :-(
05:59:03 <xerox> Uh, free monad?  Please elaborate on that.
05:59:14 <xerox> shapr: same here, don't be sad
05:59:21 <Cale> shapr: yeah, I obviously haven't been unfocused enough to catch what it was that that code was saying up until now :)
05:59:39 <Cale> hehe
05:59:47 <Cale> (I haven't slept :)
06:00:06 <shapr> Oh my gf got me uberorbs for xmas, yay!
06:00:06 * xerox boingy-boings
06:00:40 <Cale> okay, so I think I understand this free monad thing, but I don't yet fully comprehend free T-algebras
06:00:51 <twb> So nobody knows why I can't import SourcePos and ParseError?
06:01:06 <shapr> twb: I don't, ask on haskell-cafe?
06:01:15 <twb> #haskell-cafe?
06:01:21 <shapr> Nah, the haskell-cafe mailing list.
06:01:27 * twb googles
06:01:31 <cpatrick> twb: I get ParseError just from Text.ParserCombinators.Parsec
06:01:32 <shapr> Slower response, but often deeper answers.
06:01:38 <xerox> it would be cool to name haskell-blah, haskell-cafe
06:01:44 <xerox> hehe, wouldn't it?
06:01:48 <Cale> Tweakee: I know
06:01:51 <Cale> er
06:01:53 <Cale> twb: I know
06:02:03 <Cale> twb: it's because they've been moved in GHC
06:02:21 <twb> Cale: bugger.  Where are they now?
06:02:39 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html -- and children
06:02:46 <shapr> hiya drbean
06:02:48 <shapr> er, droundy 
06:02:57 <droundy> :) Hi!
06:03:10 <shapr> How's patch theory treating you?
06:03:28 <shapr> droundy: Does Juliusz use irc?
06:03:34 <droundy> All right, just now I'm trying to work out how to define a nice class for ContextPatches.
06:03:49 <droundy> shapr: I've never seen Juliusz on irc.
06:03:51 <twb> Cale: er, IIUC that says they are exported from Text.ParserCombinators.Parsec.
06:04:28 <Cale> twb: yes
06:04:40 <shapr> Too bad, I'd like to throw out some of the crazy darcs ideas I've had and see if any of them have merit.
06:04:41 <twb> Cale: but I have that, and it still isn't bound!
06:04:48 <Cale> twb: oh?
06:04:58 <twb> Cale: http://paste.lisp.org/display/14941
06:05:05 <Cale> hmm
06:05:41 <shapr> Too bad Derek Elkins is so hard to get hold of, I'd like to get this free monads thing into TMR.
06:06:26 <Cale> shapr: well, it's a lot like the explicit recursion of types construction
06:06:42 * shapr blinks cluelessly
06:06:54 <shapr> I think I've seen something like that it TaPL.
06:07:40 <xerox> freemonads?  free monads?  people is giving out monads for free?
06:07:46 <twb> So... any ideas?
06:07:52 <tic> Hm. Any of you seen Stealth?
06:07:54 <shapr> xerox: sort of, yeah.
06:07:58 <Cale> newtype Mu f = In (f Mu f)
06:08:00 <Muad_Dibber> hey
06:08:02 <twb> xerox: possibly related to free variables?
06:08:02 <Cale> er
06:08:02 <Tweakee> how u use monads anyway?
06:08:04 <shapr> tic: If it's stealthy, how can we se it?
06:08:05 <Cale> newtype Mu f = In (f (Mu f))
06:08:07 <Muad_Dibber> if its free, give it to me! i'm dutch :P
06:08:09 <tic> pfft.
06:08:15 <shapr> Tweakee: You turn a type into a pipeline.
06:08:16 <tic> shapr,  ... that was low.
06:08:30 <xerox> Cale: mumble.
06:08:34 <shapr> tic: I went out to buy some high quality camoflauge pants, but I couldn't find anything.
06:08:39 <shapr> I guess that means they work.
06:08:49 <Cale> shapr: have you seen that definition before?
06:08:57 <tic> shapr, ouchie.
06:08:58 <shapr> I've tried to teach people autodidactism...
06:09:06 <shapr> but I've realized they have to learn it for themselves.
06:09:22 <twb> shapr: yesterday somebody replaced all my furniture with stuff that looked exactly the same.  I told my flatmate and he said "Do I know you?"
06:09:24 * shapr gives up on the silly jokes...
06:09:29 <shapr> twb: haha
06:09:35 <tic> shapr, bah. :)
06:10:08 <Cale> shapr: did you catch that?
06:10:10 <shapr> Cale: I've seen the opposite of that type done with arrows. Hyperoperators or something?
06:10:40 <Cale> shapr: it's basically the same trick as y f = f (y f), but at the type level
06:10:49 <Cale> data N c = Z | S c
06:10:53 <Cale> type Nat = Mu N
06:10:56 <shapr> Right, makes sense.
06:11:01 <shapr> It also makes sense that monads fit into that.
06:11:16 <Cale> So here, we're not using plain Mu
06:11:20 <shapr> That meshes perfectly with the original intuition of parser monads for example.
06:11:26 <Cale> but something with a little more structure
06:11:45 <Cale> Philippa was talking about something along these lines
06:12:01 <Cale> well, maybe not quite this, but related
06:12:03 <xerox> Give us some references to keep up with it :D
06:12:06 * shapr is always trying to catch up to philippa, cale, TheHunter, etc
06:12:34 <shapr> xerox: http://lambda-the-ultimate.org/node/view/1183#comment-12896 and two posts up too.
06:12:45 <xerox> thanks!!
06:13:11 <shapr> I won't even dream of trying to catch up to Derek Elkins. Can you believe he actually plays music as his primary occupation, and CS theory is just his hobby?
06:13:30 <Muad_Dibber> cool
06:13:39 <shapr> He's also 19 last I checked.
06:13:44 <tic> eek
06:13:49 <tic> that can really put someone down.
06:14:03 <tic> I wonder; is there any point trying to be best?
06:14:10 <tic> What does ordinary people do?
06:14:12 <shapr> Sure, but the best means the best that YOU can do.
06:14:23 <tic> No no, best as in BEST.
06:14:29 <shapr> There is no best like that.
06:14:41 * tic tries to convince his stubborn mind of that.
06:14:46 <roqp> You can just go ahead and assume that there exists at least one person better at any particular thing that you can do.
06:14:46 <Cale> tic: You learn humility quite quickly if you try that :)
06:14:52 <shapr> Because the people who accomplish the most in a given field each have totally different understandings of that field.
06:15:03 <shapr> Right, what roqp said.
06:15:22 <tic> roqp, so why not by the 2nd best then, instead of the 14314213th best?
06:15:45 <tic> Cale, how come?
06:16:02 <tuomov> who cares who's best?
06:16:12 <tic> I do!
06:16:13 <xerox> I do not personally care of 'being', I like doing things, expecially together
06:16:13 <tuomov> as long as you yourself get to do interesting things
06:16:21 * shapr hugs xerox 
06:16:24 <shapr> @karma+ xerox 
06:16:25 <lambdabot> xerox's karma raised to 11.
06:16:33 * xerox hugs shapr back
06:16:44 <tic> you're all right, of course.  I'm trying to defend my silly mind's thought train.
06:16:50 <Cale> tic: because, as the others have said, someone younger and faster than you will come along, and beat you at any particular thing. The best you can do is to have a unique selection of things which you do well, and come up with new ideas.
06:16:52 <tic> (which is rather pointless)
06:17:16 <tic> Cale, but that's the same thing! trying to find a set of unique things.
06:17:18 * twb turns his experimental hug field generator back to levels condoned by the FCC.
06:17:20 <tic> unique eq best, here.
06:17:28 <shapr> tic: There is a school of thought where people say that all music has been invented already. My response is, "I haven't heard it all yet, I haven't played it all yet. And even if I had, I'd still like some of it more."
06:17:57 <tuomov> all's been invented yet. it's called /dev/random
06:18:08 <tic> shapr, Maybe I should try to apply that to different things.
06:18:14 <shapr> yup
06:18:20 <Cale> /dev/random is too slow for me
06:18:21 <roqp> Whether you're the best or not, you still exist, so you can deal with that or rip out your hair.
06:18:32 <tic> roqp, it's the existing part that's the most troublesome.
06:18:43 <tic> roqp, existing in a lonely haze -- is it really worth the bother?
06:18:53 <roqp> Not if you don't think so.
06:18:58 <tic> woo!
06:19:01 <shapr> I'm just getting into proof programming, because I now understand enough that I can see it for the first time. And yet, papers have been written on the subject since the 1980s. I haven't even found the horizon of knowledge yet, much lest extended it.
06:19:02 * tic goes for the pills
06:19:23 <roqp> Just OD on heroine, it'll probably work better than random pills.
06:19:32 <mstevens> blue pill or red pill?
06:19:40 <droundy> Cale: try /dev/urandom?
06:19:59 <Cale> droundy: not enough entropy in that :)
06:20:04 <tic> shapr, that's another thing. There's an incredibly high threshold on learning some things I find interesting that you'll always be worse than everyone else for a long time. Guess I need to change my attitude towards that.
06:20:05 <roqp> Curiosity motivates me more than supremacy, so I don't have that problem.
06:20:26 <tic> for me it depends.
06:20:35 <shapr> tic: But if you enjoy what you do, keep on doing it. That's the secret.
06:20:51 <roqp> As it is I'm already going to die of old age before I learn everything I want to know.
06:20:57 <shapr> roqp: me too
06:21:23 <tic> shapr, I used to enjoy what I did. Then my girlfriend broke up. I went down. Slowly went back up. Then a week ago I went to a café with her. And now I've dropped 100 m again.  :)
06:21:25 <tuomov> every curious person
06:21:34 <Cale> shapr: hmm, this type isn't quite as general as I'd like
06:21:43 <shapr> tic: People who are smarter than you can act like slingshots to pull you forward. Rather than being depressed by these people, you can get bits of their mental software from interacting with them, and thereby improve yourself.
06:21:57 <tic> shapr, *nod*
06:22:09 * tic blames his mother for always making him aim as high as possible
06:22:25 <shapr> But, being better than others is not a high aim, imho
06:22:30 <shapr> Being better than yourself is
06:22:42 <tic> Ohh, interesting point of view!
06:22:59 <xerox> I just can't believe 'being better than the others'
06:23:20 <tuomov> having as much fan as possible is a high aim
06:23:23 <tuomov> s/fan/fun/
06:23:27 <xerox> that's right!
06:23:30 <Pupeno> I have this: type TimeFunction = IO String, can I make TimeFunction an instance of Show ?
06:23:39 <xerox> tuomov: hence, the abolition of work :-)
06:23:43 <tuomov> yep
06:23:57 <shapr> I make random creative connections better than almost anyone I've ever met, so being wonderful at that is no great thrill for me. But being good at organizing, (which I naturally suck at) that makes me feel good!
06:24:56 <roqp> It's always fun to 'win,' but that doesn't necessitate a big concern.
06:25:24 <shapr> Hm, should I wear my EuroHaskell t-shirt to meet my gf's relatives?
06:25:49 <araujo> yes
06:25:57 <araujo> And throw lambdas at them too
06:25:59 <roqp> How unimpressed would they be if you wore a t-shirt?
06:26:22 <neologism> shapr: saw the "suck my d1ck" t-shirts? :0
06:26:25 <shapr> roqp: They're already not sure how to handle a self-employed unicycle riding contract programmer.
06:26:39 <shapr> neologism: er, no?
06:26:56 <mstevens> do you program while riding the unicycle?
06:27:02 <roqp> Well if it's not some faux pas in this case that would be meaningful, why not?
06:27:28 <roqp> Some people/circumstances are more stuffy than others.
06:27:31 <shapr> mstevens: I don't actually write code while unicycling, but I do sometimes record audio notes on my iriver while unicycling. Does that count?
06:27:58 <neologism> shapr: just a t-shirt with "suck my d1ck" written on it - thats the best to visit your gf's relatives :)
06:28:01 <roqp> I think I could injure myself and unicycle at the same time, but little else.
06:28:01 <musasabi> Is there a valid pathname -> haskell module name transformation?
06:28:26 <mstevens> shapr: it's good
06:28:54 <tic> *food time*
06:29:58 <shapr> Cale: Hey, what did you think about my blog post "GÃ¶del's Incompleteness Theorem at the Grocery Store" ?
06:30:24 * Cale looks
06:30:47 <Cale> hehe
06:31:23 <soysauce> is there any particular reason why Haskell chose to use indentation to block scope? :|
06:31:33 <Cale> soysauce: because it's pretty?
06:31:47 <soysauce> that the only argument in favor?
06:32:01 <Cale> well, what other argument could one want?
06:32:21 <Cale> That's all that syntax has to be, basically
06:32:25 <soysauce> well, I thought all code was supposed to be 'pretty'
06:32:40 <soysauce> even in free-form languages
06:32:41 <Cale> you should look at O'caml ;)
06:32:44 <Cale> hehe
06:33:59 <alar> can someone enlighten me about Epigram?
06:34:12 <musasabi> soysauce: what would you prefer?
06:34:19 <Cale> shapr: it appears not every monad is isomorphic to one which is free -- in particular, it doesn't seem possible to construct the list monad.
06:34:20 <alar> what's the main feature of it? 
06:34:23 <xerox> (bye)
06:34:24 <musasabi> soysauce: you can still use semicolons if you are in love with them
06:34:28 <Cale> later xerox 
06:34:32 <alar> I see it's based on inductive definitions
06:34:39 <Cale> soysauce: and braces too!
06:35:12 <Pupeno> How do I make TimeHandler an instance of Show where type TimeHandler = IO String ?
06:35:13 <soysauce> musasabi - no...
06:35:33 <shapr> Cale: Ok, how can I tell which ones are isomorphic, and which ones aren't?
06:35:34 <musasabi> > take 3 (do { x <- [1..]; y <- [4..]; return (x,y) })
06:35:35 <lambdabot> [(1,4),(1,5),(1,6)]
06:35:38 <soysauce> I want to pull some stuff out of a where clause but I can't do it
06:35:47 <soysauce> not without reformatting twice
06:35:49 <musasabi> soysauce: use let?
06:35:50 <soysauce> which is painful
06:35:56 <soysauce> you're missing the point :p
06:35:59 <soysauce> I want to unit test it
06:36:08 <soysauce> I guess most people don't use where/let?
06:36:22 <musasabi> yes they do.
06:36:23 <Cale> shapr: If you find that you need the type parameter to the monad when constructing your signature type, then it seems impossible
06:37:14 <Cale> So basically, I think you get trees of various descriptions, potentially with vertices labelled with an arbitrary type.
06:37:34 * shapr stabs myspace with a rusty spoon
06:37:36 <Cale> (as you see in Either)
06:37:44 <soysauce> well, you can't refer to something defined in a where, can you?
06:37:52 <shapr> Why do these webforum weenies feel the urge to link to my blog images and eat all my bandwidth?
06:38:07 <Cale> soysauce: what?
06:38:11 <mjl69> hey check this one out.  I'm sure it's old news to you guys, but I thought it up this morning in bed...
06:38:17 <mjl69> > take 100 [x|x<-[3,5..],length([y|y<-[2..(x-1)],(mod) x y==0]) == 0]
06:38:19 <lambdabot> [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,
06:38:19 <lambdabot> 103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,
06:38:19 <lambdabot> 197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,
06:38:19 <lambdabot> 307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,
06:38:19 <lambdabot> 419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,
06:38:21 <lambdabot> 523,541,547]
06:38:34 <musasabi> soysauce: the trick is that 1) use small functions, 2) when you put it in the where it should work ;)
06:38:37 <mjl69> probably not the most efficient way to do it though
06:38:57 <musasabi> (or the unittest of the enclosing function will fail and you can fix it)
06:39:08 <Pupeno> Or how do I make data A = A {a :: Int, b :: Bool, c :: IO String } showable/printable ?
06:39:15 <Cale> > let primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes
06:39:16 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
06:39:16 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
06:39:16 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
06:39:16 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
06:39:16 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
06:39:18 <lambdabot> [24 @more lines]
06:39:20 <dcoutts> @seen Saulzar
06:39:21 <lambdabot> I saw Saulzar leaving #haskell 3 hours, 15 minutes and 42 seconds ago.
06:39:24 <musasabi> Pupeno: write instance Show for it.
06:39:54 <mjl69> cool!
06:40:25 <dcoutts> @seen elux
06:40:27 <lambdabot> I saw elux leaving #haskell 6 hours, 38 minutes and 40 seconds ago.
06:46:55 <shapr> Cale: Thanks, I'll think about that.
06:50:42 <Cale> shapr: Try creating the list monad in that framework and you should get it pretty quickly :) We'd kind of like 'a' to get passed to sig in Expr
06:50:59 <Cale> but this screws up all the kinds, so some rethinking is necessary :)
07:01:11 <yahoo> twb: Ah c'mon, I was going to join in with the famous Australian comedian bit...
07:01:21 * yahoo always liked yahoo serious
07:01:32 <Forgacius> hehe
07:01:33 <Forgacius> yeah
07:01:37 <Forgacius> so did I
07:01:50 <Forgacius> I loved how his movies always claimed to be "a serious production"
07:02:11 <shapr> heh
07:02:22 <shapr> I liked the bit about using nuclear energy to put bubbles into beer.
07:02:29 <Forgacius> rofl 
07:02:35 <twb> Er, yeah...
07:02:42 <shapr> He split the atom with a hammer and chisel.
07:02:43 <twb> I guess this would be a pop movie?
07:02:48 <Forgacius> the explosions weren't so bad either
07:02:51 <shapr> *tink* *tink* *BOOM*
07:02:58 <shapr> "Dad, I did it! Beer with bubbles!"
07:03:12 <Forgacius> lol shapr sounds like a song "boom shake shake shake the room, tink tink tink tink BOOM!
07:03:25 <twb> Everyone knows you eat beer with a spoon.
07:03:37 <twb> Anything else is just runny water.
07:03:44 <Forgacius> lol twb thats chunky soup.. wait... no chunky soup is with a fork
07:03:49 <Forgacius> personally I prefer splades...
07:04:01 <Yodacius> "luke use the spork"
07:04:03 <shapr> Guiness, the beer that drinks like a meal.
07:04:18 <twb> ghc is still being stupid about SourcePos.
07:04:18 <shapr> aanyway, I should get this code done before my client panics.
07:04:25 <twb> And hugs doesn't even have Parsec, apparently.
07:04:43 <Yodacius> far away Parsec must be
07:06:45 <twb> : Parsec distance far ;
07:07:04 <twb> ...if you wana be really har'core.
07:10:17 <twb> shapr: your client is a kernel?!
07:10:40 <Cale> *Main> (foldr mplus mzero . map return) [1,2,3,4,5] :: FreeMonad TreeSig Integer
07:10:40 <Cale> Expr (Branch (Return 1) (Expr (Branch (Return 2) (Expr (Branch (Return 3) (Expr (Branch (Return 4) (Expr (Branch (Return 5) (Expr Leaf))))))))))
07:11:16 <Yodacius> Lisplike parens do they look...
07:11:30 <Cale> hehe, getting mplus to autobalance the tree would be harder :)
07:13:07 * Cale wonders about what kinds of functors naturally give rise to MonadPlus instances
07:13:19 <Yodacius> hard it is not, answers: easy they are, questions: hard it is asking the right one.. 
07:14:07 <Cale> I think I can answer that much at least.
07:14:18 <Cale> hmm...
07:15:08 <twb> Yodacious p"ignorant of customs" you are ,
07:15:53 <Yodacius> agree Yoda does, strange this land is to Yoda, forgivness Yoda seeks
07:15:55 <twb> Yodacious syntax there is fyi , ,
07:16:47 <twb> Yodacius clases phrases and learn you should of ,
07:17:37 <twb> * Yodacius clases phrases learn you should and of ,
07:17:51 <ForgeAus> doh... I know my yodaspeak is overthetop somewhat.. but thats meant to be part of the charm of my Yodaciousness lol
07:18:13 <ForgeAus> so what I f*ck up the grammer a bit ... 
07:18:13 <twb> It wasn't over the top, it was grammatically incorrect.
07:18:32 <ForgeAus> well it all made sense to me... 
07:18:40 <twb> If you're going to use infix phrases or clauses, you should surround them with p"" and c"".
07:18:40 <ForgeAus> despite any incorrectness
07:19:00 <ForgeAus> is that a haskell thing or an english language one?
07:19:06 <twb> No.
07:19:13 <ForgeAus> because I'm pretty sure nothing there was ment infixed
07:19:29 <ForgeAus> just.. jumbled (purposefully)
07:19:47 <twb> ForgeAus: you used the word , infixly, for example.
07:19:55 <ForgeAus> ie although Starwars yoda always said "may the force be with you" .. my Yodacius says "the force, may with you it be"
07:19:55 <SamB> hmm, somebody said my name!
07:19:59 <SamB> who was it!
07:20:17 <twb> SamB: you did, just now.
07:20:22 <ForgeAus> lol
07:20:23 <musasabi> Any idea how ghci ends up complaining about: "During interactive linking, GHCi couldn't find the following symbol: UtilziArbitraryInstances_zdfArbitraryMaybe_closure" when using -no-recomp and a project that does not include any FFI at all?
07:20:26 <SamB> did not!
07:20:36 <twb> 02:19 <SamB> hmm, somebody said my name!
07:20:38 <SamB> I said "my name", which is *not* my name
07:20:39 <ForgeAus> well you indirectly referenced it
07:20:49 <twb> It depends on the quoting mechanism ;-)
07:20:55 <SamB> it does, however, mean my name
07:21:07 <twb> Or rather, the evaluation semantics.
07:21:16 <ForgeAus> in fact twb was the first to directly reference it that I noticed
07:21:26 <ForgeAus> but then thigns like that tend to slip me by quite easily
07:21:38 <Cale> "P" iff P
07:21:38 <twb> Don't call *me* wooden eye!
07:21:49 <SamB> in any case, x-chat does not highlight the tab yellow when someone says "my name"
07:21:59 <ForgeAus> twb plus it wasn't the referecne sam had in quesiton because it was after he asked
07:22:06 <musasabi> the module in question is "module Util.ArbitraryInstances() where ... instance Arbitrary a => Arbitrary (Maybe a) where ... "
07:22:18 <ForgeAus> SamB perhaps it was a coincidence?
07:22:19 <twb> SamB: just isearch-backwards-regexp!
07:22:21 <CosmicRay> it does for me
07:22:32 <twb> SamB: oh wait, not in Emacs.  Too bad :P
07:22:39 <SamB> it doesn't seem to be in the scrollback anyway
07:22:50 * twb M-x occur SamB's --twb *is* in Emacs
07:22:53 <Cale> SamB: someone could have added "my name" to the highlight list while you weren't looking, and you set it off unknowingly by mentioning that someone just said your name
07:23:24 <SamB> wait, I think x-chat uses blue for the tabs and yellow only for the actual occurrences
07:23:30 <twb> SamB: nobody said it while *I* was watching...
07:23:39 <SamB> hmm.
07:23:45 <ForgeAus> twb what if it picks up SamB* as SamB?
07:24:00 <ForgeAus> someone could have said anything like Sambucca and it'd highlight
07:24:04 <ForgeAus> stupid bots uh?
07:24:04 <twb> ForgeAus: I occurred for SamB.  That would pick up SamB* also.
07:24:26 <SamB> it isn't highlighting Sambucca
07:24:44 <ForgeAus> hmmm... strange then, I have no explaination
07:24:48 <twb> XChat probably hilights \<SamB\>
07:24:50 <ForgeAus> a bug perhaps?
07:25:05 <twb> *explanation
07:25:24 <SamB> either it is case sensitive, or it won't highlight the name if there are more letters on either side...
07:25:38 <twb> That's what I said.  \<SamB\>
07:25:44 <ForgeAus> well lets try SamBucca
07:25:45 <SamB> oh
07:25:51 <ForgeAus> hmm
07:26:00 <SamB> regex syntaxes are so confusing sometimes
07:26:04 <twb> (rx (and bow "SamB" eow))
07:26:06 <ForgeAus> at times yeah
07:26:27 <ForgeAus> but they are logical mostly
07:26:33 <twb> do bow; string "SamB"; eow
07:26:53 <SamB> what if I wanted to use a different concept of word?
07:26:56 <twb> Except bow can't match unless GenParser is stateful.
07:27:11 <SamB> hmm?
07:27:15 <SamB> heard of lookahead?
07:27:19 <SamB> oh, right...
07:27:28 <twb> You need lookBehind for bow.
07:27:34 <ForgeAus> Sam sounds like some kind of prefetch!
07:27:35 <SamB> hehe
07:27:42 <twb> bow = lookBehind $ satisfy isSpace
07:27:47 <ForgeAus> hmm postfetch?
07:27:57 <SamB> what we need is ParsecT
07:27:59 <twb> bow = lookBehind $ satisfy isSpace <|> bof
07:28:14 <ForgeAus> sounds like a mangled pokemon!
07:28:19 <twb> SamB: like Riastradh's implementation of Scheme?
07:28:23 <ForgeAus> no wait, thats Parasect!
07:28:38 <twb> ForgeAus: a sect for sects?
07:28:55 <ForgeAus> Scheme, Lisp, Smaltalk... hmm I sense a common theme here
07:29:15 <twb> Where?
07:29:16 <ForgeAus> lol twb, I guess thats one interpretation
07:29:17 <SamB> ooh, what is this about Smalltalk
07:29:23 <twb> What do all three have in common?  A REPL?
07:29:29 <twb> Scheme has no object system.
07:29:35 <SamB> Smalltalk doesn't Read, though
07:29:36 <twb> Lisp has no first-class continuations.
07:29:47 <SamB> neither does smalltalk
07:29:52 <twb> Really?
07:30:04 <SamB> well, at least, if it does they are hidden well
07:30:07 <ForgeAus> lol I think I just started a monster!
07:30:08 <twb> Isn't that why Seaside is supposed to be the bee's knees?
07:30:29 <ForgeAus> I didn't know Bees had knees as such
07:30:40 <SamB> I suppose they can be done...
07:30:42 <ForgeAus> though I wouldn't put it past them
07:30:58 <twb> ForgeAus: they have twelve, IIRC.
07:31:33 <SamB> but they aren't customarily used as far as I know...
07:31:44 <ForgeAus> I knew they had leg-segments just wasn't sure the vertices of which were technically knees or not... 
07:31:50 <SamB> except maybe in the debugger or something
07:32:18 <SamB> possibly the concurrency implementation...
07:32:20 <twb> @google seaside smalltalk continuations
07:32:21 <lambdabot> http://www.seaside.st/
07:32:41 <SamB> anyway, normal people don't have to know about them
07:32:45 <Pupeno> musasabi: is there any reason why you don't export Network.Alt.Server.Service ?
07:38:39 <Cale> *Main> start push 1 push 2 add push "Hello" len add end
07:38:39 <Cale> 8
07:42:09 <roconnor> what is the type of start?
07:42:19 <roconnor> and end.
07:42:47 <Pupeno> lisppaste2: url
07:42:47 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:42:48 <Cale> start :: (() -> t) -> t
07:42:55 <Cale> end :: (a, b) -> a
07:44:04 <lisppaste2> Pupeno pasted "making a function jump" at http://paste.lisp.org/display/14947
07:44:19 <Cale> push :: b -> a -> ((a, b) -> t) -> t
07:44:43 <roconnor> oh
07:44:53 <roconnor> hm
07:45:06 <roconnor> the type system knows the size of the stack.
07:45:10 <Cale> yes
07:45:18 <Cale> exch :: (a, (a1, b)) -> ((a1, (a, b)) -> t) -> t
07:45:19 <roconnor> can't end on an empty stack.
07:45:33 <Cale> right
07:45:47 <Cale> well, you can put 'id' in place of end to get the whole stack
07:45:55 <Cale> rather than the top element
07:46:03 <roconnor> this is clearly related to continuations somehow.
07:46:26 <roconnor> the notation is surprisingly nice.
07:46:41 <roconnor> the notation is disturbingly nice.
07:46:56 <Cale> It's moderately inflexible, but I managed to work out a good way to quote things
07:47:00 <Cale> infixl 5 !
07:47:00 <Cale> quote = flip
07:47:00 <Cale> x ! y = quote x y
07:47:06 <Cale> app1 f = quote push f ! app
07:47:06 <Cale> app2 f = quote push f ! app ! app
07:47:06 <Cale> add = app2 (+)
07:47:06 <Cale> len = app1 length
07:47:32 <twb> > Text.ParserCombinators.Parsec.Pos.SourcePos "" 0 0
07:47:34 <lambdabot>   Not in scope: data constructor `Text.ParserCombinators.Parsec.Pos.
07:47:34 <lambdabot> SourcePos'
07:47:53 <twb> > Text.ParserCombinators.Parsec.SourcePos "" 0 0
07:47:54 <lambdabot>   Not in scope: data constructor `Text.ParserCombinators.Parsec.SourcePos'
07:47:58 <Cale> app (f,(x,s)) k = k (f x, s)
07:49:12 <araujo> Merry Haskell everyone! and Happy New Lambda!
07:50:28 <jimapple> There's a *new* lambda?
07:50:28 <jimapple> /me throws out old lambda
07:50:39 <musasabi> Pupeno: because there is no need for the export.
07:50:43 <twb> Why doesn't ghc export SourcePos!  Grrrrrr!
07:50:50 <SamB> did shapr burn the old one?
07:51:02 <shapr> :-)
07:51:20 <mahogny> quick one: I need something like select() in C but when I read the concurrent haskell spec, it says that any C call would block. how would I go about to solve this?
07:51:22 <Pupeno> musasabi: why ? because it is too simple ? I find myself defining it on other modules (it is not that bad anyway).
07:51:34 <twb> mahogny: case
07:51:38 <mahogny> hm. ok
07:51:55 <twb> I assume you want the same syntax as C's select.
07:52:01 <mahogny> ah no
07:52:05 <twb> Or am I thinking of switch?
07:52:09 <mahogny> yes
07:52:13 <mahogny> select() is for sockets
07:52:15 <twb> Ah, sorry.
07:52:28 <SamB> well, what you REALLY want is forkIO
07:52:28 <mahogny> it takes a list of filedescriptors and check if any are ready for read/write
07:52:38 <mcnster> newb q:  i have a list s and i want to derive a sublist of elements e that satisfy f including the element that follows each e, maintining original order.  any clues from the wise?
07:52:41 <twb> mahogny: I hope you find your second 'a'.
07:53:04 <Cale> threadWaitRead/threadWaitWrite?
07:53:08 <twb> mcnster: foldl
07:53:15 <mahogny> hm. never heard of those. will check
07:53:25 <SamB> Cale: those only work in a certain configuration...
07:53:30 <SamB> afaik
07:53:45 <Cale> SamB: well, it does say that they're GHC only
07:53:45 <mcnster> twb, that's what i thought, but maybe i'm too tired to grok... can foldl return a list?
07:53:46 <twb> mcnster: foldl [] (\x xs -> if p x then x:xs else xs) s
07:53:57 <twb> Something likethat.
07:54:00 <mahogny> yeah. those might do. it means a bloody lot of threads but I guess thread*** is the only solution
07:54:01 <musasabi> Pupeno: I think I was trying to avoid polluting the global namespace needlessy, but no real technical argument for not exporting it.
07:54:26 <Pupeno> ok.
07:54:32 <SamB> Cale: I mean, I was under the impression that they are only used with the threaded rts, possibly only the smp rts...
07:54:34 <musasabi> Pupeno: if it would be exported then the sensible thing would be to move the definition to the Types module and use it in the Resolver module also.
07:54:57 <Cale> SamB: could be, it doesn't say anything about that in the docs though
07:54:59 <Pupeno> musasabi: indeed, I first looked for it in the Types module..
07:55:09 <mcnster> twb, that makes so much sense.  thanks!
07:55:20 <SamB> Cale: yeah, I know!
07:55:28 <SamB> I think people here told me or something
07:55:42 <musasabi> Pupeno: feel free to provide a patch if you want to. (I can fix that during the holidays, but it is not on top of my things needing to be done list)
07:56:17 <Pupeno> musasabi: I'll do.
07:56:24 <SamB> anyway, it seems like you need to forkIO however you go about it
07:56:27 <musasabi> ok :-)
07:57:44 <lisppaste2> twb pasted "mcnster: three common implementations" at http://paste.lisp.org/display/14948
07:59:40 <lisppaste2> twb pasted "wtf is going on?" at http://paste.lisp.org/display/14949
08:00:27 <mahogny> ok, here's an even harder question: if I want timeouts on the sockets, how would I do then? it seems haskell is really weak at this :/
08:00:28 <Cale> twb: use foldr, btw
08:00:44 <twb> Cale: ah, OK.  I never know which.
08:00:51 <Cale> and the arguments to foldl are backward
08:01:25 <musasabi> @seen JohnMeacham
08:01:26 <lambdabot> JohnMeacham is in #haskell and #haskell-blah. Last spoke 2 hours, 57
08:01:26 <lambdabot> minutes and 19 seconds ago.
08:01:39 <Cale> 90% of the time in Haskell, you want foldr, 9% of the time, you want foldl' (note the ') and the other 1%, other list folds :)
08:02:10 <musasabi> JohnMeacham: ghci seems to fail on me with jhc sources, any idea on UtilziArbitraryInstances_zdfArbitraryMaybe_closure related undefined symbols?
08:02:13 <Cale> that's perhaps an exaggeration, but it's roughly true
08:02:33 <Cale> foldl/foldl' don't work on infinite lists
08:02:41 <shapr> Man I love test driven development.
08:02:44 * shapr hops cheerfully.
08:03:06 <twb> I don't.
08:03:07 <shapr> araujo: Actually, there is a new tmr lambda...
08:03:14 <tic> nor on partial definite lists.
08:03:18 <twb> The tests are >>4 times bigger than the definitions.
08:03:26 <SamB> hmm. PeerThread seems to need serious refactoring before we can handle incoming connections...
08:03:32 <roconnor> What is the ' in fold'
08:03:41 <Cale> roconnor: strictness
08:03:44 <shapr> twb: my longest test looks like this: ,(remote url "deflocalrole" "projects" "group_shapr" "Owner" :: IO String) ~>= "projects group_shapr Owner\n" 
08:03:47 <roconnor> ah
08:03:48 <SamB> a prime mark
08:03:54 <roconnor> :P
08:04:09 <shapr> twb: My shortest test looks like (remote url "ping" :: IO String) ~>= "hello" -- Anybody out there?
08:04:21 * twb 's eyes glaze over.
08:04:34 <SamB> it means, "this is somehow not the same as other things with this name but a different number of prime marks"
08:04:54 <Cale> roconnor: you almost never want plain foldl in Haskell, since it's a bit unnatural to begin with. The only reason it's popular in other languages is the tail recursion, but laziness kills the benefit of that in Haskell in most of the cases you care about it.
08:05:10 <shapr> Ok everybody, the new holiday lambda contributed by jethr0 is at the top of his TemplateHaskell tmr article: http://www.haskell.org/tmrwiki/TemplateHaskell
08:05:15 <SamB> especially if you don't use the strict version, eh?
08:05:39 <shapr> twb: I'm using XmlRpc and HUnit to unit test my Plone code. It's pretty easy stuff. Want to see my sources?
08:05:40 <Cale> For example foldl (+) 0 over a list of numbers will build up an expression in memory which is the size of the original list, and then evaluate that expression
08:06:04 <Cale> which is exactly what you don't want, a good deal of the time
08:06:07 <twb> shapr: my tests look like this: http://twb.ath.cx/~twb/darcs/miscellaneous/parsewiki/Text/Restructured/Tests.hs
08:06:44 <shapr> twb: Nice, have you seen my TDD extension for QuickCheck?
08:07:04 * SamB hopes to finish his article sometime
08:07:18 <shapr> SamB: I want to publish a new year's TMR if possible...
08:07:36 <shapr> Though I suspect anything that's not written now won't be done before the 1st.
08:08:19 <roconnor> oh crap, the cafeteria is closed for the holidays.
08:08:24 <roconnor> No more eating for me for a week.
08:08:28 <shapr> oops
08:09:41 <Cale> roconnor: you don't have an alternate way to get food?
08:10:06 <roconnor> :) I'm sure I will figure something out.
08:12:07 <roconnor> Actually I will be in Berlin next week.
08:12:12 <Cale> *Main> start push 1 dup dup add cons dup decons add cons end
08:12:12 <Cale> ((1,2),3)
08:12:21 <Cale> this is amusing :)
08:12:23 <roconnor> I don't suppose anyone else will be there.
08:12:54 <shapr> Cale: What's that?
08:12:59 <Cale> Haskell
08:13:05 <Cale> :)
08:13:13 <shapr> It looks like one of Greg Buchholz' Joy implementations.
08:13:33 <roconnor> [16:46] <roconnor> the notation is disturbingly nice.
08:13:46 <shapr> Interesting that it's representing the stack as a tuple.
08:14:15 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:14:35 <shapr> Who wrote it?
08:15:01 <shapr> Man that's simple.
08:15:05 <Cale> I can't remember who/what gave me the original idea.
08:15:20 <Cale> but I just wrote that now
08:15:42 <shapr> huh
08:15:50 <shapr> I wonder if it's enough to write all of Joy that way....
08:16:03 <shapr> Too bad I have to 1) do paying work and 2) go meet my gf's difficult relatives
08:16:06 <Cale> hehe
08:16:32 <shapr> Happily, I have a secret weapon... I have no inhibitions about telling the truth on social occasions.
08:16:53 <Cale> heh, they'll never have you back?
08:17:09 <shapr> Yup, I rarely get invited to stiff formal parties twice.
08:17:21 <shapr> Not by the same people at least.
08:17:29 <shapr> On the other hand, relaxed formal parties are fine.
08:18:18 <shapr> Cale: Can push be implicit?
08:19:19 <Cale> hmm
08:19:23 <shapr> Cale: May I email this to Greg Buchholz?
08:19:27 <Cale> sure
08:19:28 <shapr> ok
08:20:26 <Cale> implicit in which sense?
08:20:45 <shapr> I want more Joylike behaviour.
08:20:53 <flux__> I guess in that you could just write numbers and they would be pushed?
08:21:03 <Cale> ah
08:21:09 <shapr> Joy would have "1 dup dup +"
08:21:13 <flux__> (btw, very cool thing you have there ;))
08:21:18 <shapr> Yeah, it's really nifty.
08:21:19 <Cale> hmm, that seems to have insane polymorphism
08:21:36 <Cale> (at least in this framework)
08:21:45 <acd> Hello! Is it some elegant one-line way to solve problem of converting decimal number X to list of his digits in  number system with base N ?
08:22:06 <shapr> Yeah, use the showBase code from NumExts.
08:22:25 <acd> shapr: using only Prelude, without Numeric
08:22:38 <sjanssen> acd: are you doing homework?
08:22:57 <acd> sjanssen: no, i just wrote piece of code, and want to know if I can improve it :)
08:24:22 <shapr> acd: If you want extra elegance, have you read Dead Reckoning by Doerfler?
08:26:38 <tromp_> you could play with mapAccumL (divMod N)
08:26:50 <acd> shapr: no, what's that?
08:26:57 <acd> shapr: can i find on-line copy?
08:28:17 <shapr> No, I don't think so. It's a book about efficient mental calculation. It includes lots of *really* cool number theory, and references to connected papers.
08:28:48 <acd> shapr: that's great! but I live in Russia, so it will be pretty hard to get it here :(
08:29:44 <shapr> For example, http://www.scannedinavian.com/2005-11-18.html
08:29:59 <shapr> "It happens that for a fraction s/t, a repeating decimal group will occur if t has one or more prime factors other than 2 or 5."
08:30:31 <shapr> So of course, I have considered using hexadecimal or other common number base with lots of factors for mental calculation.
08:31:01 <shapr> er wait..
08:31:11 <shapr> Hexadecimal wouldn't help, would it? It's only base 2.
08:31:34 <shapr> Base 210 maybe...
08:31:50 <shapr> or base 30
08:33:37 <sjanssen> base 120 sounds good, product of the first four primes
08:33:52 <sjanssen> oops, not right
08:33:56 <shapr> Isn't that base 210?
08:34:07 <sjanssen> yep
08:34:49 <shapr> > let primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in foldr1 (*) $ take 4 primes
08:34:50 <lambdabot> 210
08:35:23 <sjanssen> I have a feeling humans can't handle base 210
08:35:25 <shapr> Thing is, I can easily represent base 30 with 0 to 9 and the first twenty letters.
08:35:54 <araujo> Is 'tokenized' a proper english word?
08:35:55 <shapr> sjanssen: Ok then, how to make a base prime? :-)
08:35:57 <shapr> araujo: yes
08:36:33 <shapr> sjanssen: In which 0 is 1, 1 is 2, 3 is 5, 4 is 7...
08:36:51 * araujo boing and throws a box full of lambdas as a christmas present to shapr 
08:36:55 <shapr> yay!
08:37:18 <shapr> I wonder if base prime would be useful for anything.
08:38:05 <tromp_> for chinese remaindering
08:38:35 * shapr forgets what that is...
08:38:36 <acd> shapr: my current solution is http://pastebin.com/476729 ,but it's look ugly
08:39:51 <shapr> How do you handle base 30 or base 16?
08:40:26 <acd> shapr: how? what do you mean?
08:40:50 <roconnor> shrapr: f n=[x|x<-[2..n],all((0<).mod x)(f$x-1)]
08:41:27 <roconnor> http://bushong.net/dave/comparisons/primes-up-to.html
08:41:33 <sjanssen> @pl (\n -> if n == 0 then Nothing else let (q, r) = divMod n base in Just (r, q))
08:41:34 <lambdabot> (line 1, column 40):
08:41:34 <lambdabot> unexpected "("
08:41:34 <lambdabot> expecting natural, identifier or "in"
08:42:19 <shapr> roconnor: nifty
08:42:32 <shapr> acd: I mean that your code works for bases less than ten, but what about greater than ten?
08:42:40 <shapr> I do like the code though :-)
08:42:53 <shapr> I'd probably switch to pattern matching to use less chars.
08:42:58 <Cale> [1-0sv]sF[p]sA[dli%0=Flvli2+dsi!>I]sI[2-dddvsv3silIx=Ad3<J]dsJxf2p
08:43:29 <tromp_> sjanssen aiming for unfoldr :)
08:43:37 <sjanssen> tromp_: yes
08:43:43 <Cale> the input needs to be prime though :)
08:43:48 <sjanssen> it's gonna be ugly, but it will be one line
08:44:33 <tromp_> @pl (\n-> do guard n>0; return $ Just $ divMod n 10)
08:44:34 <lambdabot> (line 1, column 19):
08:44:34 <lambdabot> unexpected ";"
08:44:34 <lambdabot> expecting digit, variable, "(", operator, "==", "/=", "<", "<=", ">=", ">"
08:44:34 <lambdabot> , "`elem`", "`notElem`" or ")"
08:45:46 <acd> shapr: it will be just list of digits, so if i'll tranlate 31 to hex i'll get ['1','15']
08:45:56 <shapr> ah, right
08:46:06 <tromp_> ah yes, need to swap the pair
08:46:52 <tromp_> hmm, no predefined function \(a,b)->(b,a) ?
08:47:14 <sjanssen> tromp_: just uncurry (flip (,))
08:47:23 <shapr> acd: http://pastebin.com/476740
08:47:58 <Cale> @pl \(x,y) -> (y,x)
08:47:59 <lambdabot> uncurry (flip (,))
08:48:16 <tromp_> they could've define that as Prelude.swap
08:48:23 <shapr> I think it's in PreludeExts
08:48:31 <acd> shapr: ok, i'll use some pattern matching
08:48:38 <shapr> Along with box x = [x] and lots of other randomly useful bits of code.
08:48:46 <shapr> @wiki LicensedPreludeExts
08:48:47 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
08:48:52 <tromp_> box = return :)
08:49:01 <shapr> hm, right
08:49:15 <shapr> Maybe I can write a TMR artile about PreludeExts.
08:49:37 <tromp_> have you written on unicycling in haskell yet:-?
08:50:28 <shapr> Not exactly, but I have been trying to find equations to let me calculate contact patch size from tire size, and the squish factor of snow to see exactly what size tire I need to roll over snow with my current weight.
08:51:30 <shapr> I started by calculating volume of a torus, but that's way too generic to give me much info on how my new 3.7 inch by 26 inch tire will compare to my incumbent 3 inch by 26 inch tire.
08:51:47 <tromp_> @unicycle
08:51:49 <lambdabot> Unknown command, try @listcommands.
08:51:56 * shapr grins
08:51:59 <tromp_> that shld give something like
08:52:00 <tromp_>    _O
08:52:00 <tromp_>    (`
08:52:00 <tromp_>    |>
08:52:00 <tromp_>   ,|.
08:52:02 <tromp_>   `-'
08:52:16 <shapr> I could write an article about the inverse pendulum thingy.
08:52:18 <shapr> Yeah, truly :-)
08:53:24 <flux__> shapr, I imagine you might more easily get (some) results via simulation instead of analytical approach
08:53:30 <flux__> maybe not the correct results, though ;)
08:57:38 <shapr> My tire will be here in a few days, after which I'll go straight to the empirical evidence phase.
09:26:57 <roconnor> > scanr (*) 1 [x|x<-[2..],all((0<).mod x)[2..x-1]]
09:27:02 <lambdabot> Terminated
09:27:25 <roconnor> > take 5$scanr(*)1 [x|x<-[2..],all((0<).mod x)[2..x-1]]
09:27:30 <lambdabot> Terminated
09:27:47 <Cale> > scanl (*) 1 [x|x<-[2..],all((0<).mod x)[2..x-1]]
09:27:49 <lambdabot> [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,
09:27:49 <lambdabot> 7420738134810,304250263527210,13082761331670030,614889782588491410,
09:27:49 <lambdabot> 32589158477190044730,1922760350154212639070,117288381359406970983270,
09:27:49 <lambdabot> 7858321551080267055879090,557940830126698960967415390,407296805992490241506
09:27:49 <lambdabot> 21323470,3217644767340672907899084554130,267064515689275851355624017992790,
09:27:51 <lambdabot> [23 @more lines]
09:28:25 <roconnor> oh scanl
09:28:33 <roconnor> why is it scanl?
09:28:55 <Cale> because scanl only has to look at the initial fragment of the list to produce a result
09:29:16 <roconnor> why is it scanl, but foldl sucks?
09:30:09 <Cale> > scanr (:) [] [1,2,3,4,5]
09:30:10 <lambdabot> [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
09:30:16 <Cale> > scanl (:) [] [1,2,3,4,5]
09:30:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:30:17 <lambdabot>   Expected type: a -> [a] -> a
09:30:17 <lambdabot>   Inferred type: a -> [a] -> [a]
09:30:24 <Cale> heh
09:30:39 <Cale> > scanl (flip (:)) [] [1,2,3,4,5]
09:30:41 <lambdabot> [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
09:31:15 <roconnor> scanr seems backwards.
09:32:05 <shapr> superibor: hi, learning Haskell?
09:32:11 <Cale> It refers to the bracketing
09:32:21 <superibor> hi shapr
09:32:23 <Cale> (the r)
09:32:25 <superibor> I'm always learning Haskell
09:32:28 <shapr> Oh me too.
09:32:35 <superibor> I came with a noob question actually
09:32:49 <superibor> is there any trick to sort of refine the equations for an operation in an imported module ?
09:33:01 <Cale> since scanl only needs to look at the leftmost elements to produce its first result, it works on infinite lists
09:33:13 <Cale> its first results
09:33:35 <mjl69> and foldr can also?
09:33:38 <Cale> yeah
09:33:46 <superibor> in a way, adding more equations to an existing imported opeartion. Maybe renaming the original one to an alias and creating a new one with the same name ?
09:34:07 <Cale> foldr (:) [] [1,2,3,4,5]
09:34:09 <Cale> > foldr (:) [] [1,2,3,4,5]
09:34:10 <lambdabot> [1,2,3,4,5]
09:34:13 <mjl69> I can visualize foldr easier than foldl for some reason.  I guess I need practice.
09:34:18 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
09:34:20 <lambdabot> [5,4,3,2,1]
09:34:33 <superibor> To put a concrete example, what I want to do is to change the way GetOpt deals with unrecognized options...
09:34:40 <tromp_> yes, superibor, you'll have to define a new function
09:34:57 <tromp_> that can call the old one in certain cases
09:35:11 <Cale> http://vx.hn.org/autoshare/folds.png -- some pictures of folds, I'll do one with scans if you like
09:37:09 <superibor> tromp_ yes, but will the functions defined in the imported module use my redefinition? I'm guessing they won't
09:39:04 <mjl69> Cale: great pictures, thanks.
09:40:02 <tromp_> nope
09:40:28 <mjl69> I always imagine them as recursive brackets.  Maybe that's why foldr is easier for me.
09:44:11 <Cale> mjl69: foldr is easier in general
09:44:38 <Cale> foldr f z replaces (:) with f and [] with z
09:53:17 * Cale draws a beautiful scanl
09:57:32 <Cale> http://vx.hn.org/autoshare/folds.png -- refresh :)
09:58:11 <Cale> kind of hard to fit all the edges in, but this works :)
09:58:28 <Cale> and it shows how it reuses the previous results effectively
09:58:47 <mjl69> pretty!
09:58:58 <musasabi> Is there a reason ghci seems to not like instances defined in another module?
09:59:46 <musasabi> It dies with "<interactive>: ./Info/Binary.o: unknown symbol `EziStrictness_zdfTypeableSA_closure'" and other such errors, ghc --make works fine.
10:01:50 <musasabi> and ghci has a line like: "Skipping  E.Strictness     ( ./E/Strictness.hs, ./E/Strictness.o )" (where E/Strictness.o does define EziStrictness_zdfTypeableSA_closure)
10:08:44 <flux__> hmph, haskell xml toolbox seems really complex for the task of extracting the list of links from a html-document
10:10:09 <benny> flux__: i can't seem to figure out how to use it :)
10:10:24 <Cale> argh
10:10:39 <flux__> what it seems to be really good at is validating xml and printing it out, but.. ;)
10:11:01 <Cale> machine died with the save button *in its pressed state* -- I really need to reattach the heatsink with new thermal gunk
10:11:23 <flux__> (also I might try to use it on non-valid xml, so it might be altogether the wrong tool for me)
10:15:54 <benny> hm... my  phone just died
10:16:33 <benny> interesting, it restarted itself.... must have some auto-reset-if-kernel-panic function :)
10:26:55 <PupenoL> why is the type of "daytimeDatagramHandler timeHandler logger = \p w i sa -> do return ()" "TimeHandler -> Logger -> (GHC.Ptr.Ptr GHC.Word.Word8 -> Int -> SocketAddress -> t -> t1)" instead of "TimeHandler -> Logger -> (GHC.Ptr.Ptr GHC.Word.Word8 -> Int -> SocketAddress -> IO ())" ?
10:29:43 <glguy> Has anyone had any success developing Haskell applications with XCode?
10:31:29 <Cale> http://vx.hn.org/autoshare/folds.png
10:31:33 <Cale> new version :)
10:32:00 <flux__> do you use some sort of layout program to generate those?
10:32:07 <Cale> Inkscape
10:32:23 <Cale> > scanr (\x xs -> "(f " ++ (show x) ++ " " ++ xs ++ ")") "z" [1,2,3,4,5]
10:32:24 <flux__> oh, so you actually draw them
10:32:24 <lambdabot> ["(f 1 (f 2 (f 3 (f 4 (f 5 z)))))","(f 2 (f 3 (f 4 (f 5 z))))","(f 3 (f 4
10:32:24 <lambdabot> (f 5 z)))","(f 4 (f 5 z))","(f 5 z)","z"]
10:32:25 <flux__> boring ;(
10:32:27 <flux__> ;-)
10:32:56 <flux__> now, what would be cool, would be a program that converted functions into those pictures
10:33:23 <flux__> (but they are still pretty pictures ;))
10:34:00 <Cale> Believe me, if I had such a program, it would not be taking me nearly as long :)
10:34:04 <Cale> hehe
10:34:09 <PupenoL> Cale: nice, I'd print it and hang it on the wall.
10:34:50 <PupenoL> Cale: wouldn't it be possible to do using graphviz or something like that... it'd be an interesting project.
10:35:12 <flux__> tile them and make them into wallpaper.. actual wallpaper you could decorate your apartment with ;)
10:35:14 <Cale> Yeah, you might be able to do it with graphviz
10:35:21 <Cale> heh
10:39:36 <mjl69> t-$hirt$
10:39:43 <mjl69> http://www.cafepress.com
10:43:06 <PupenoL> yeah, tha busines!
10:43:42 <PupenoL> Cale: do you plan on doing more ? publishing it ?
10:43:47 <mjl69> I have one with the pythagorean theorem that Autrijus made up.  Can't find it now.  I also have Haskell and Perl 6 t-shirts.
10:44:13 <Cale> http://vx.hn.org/autoshare/folds.png
10:44:20 <Cale> there's all the folds and scans :)
10:45:23 <Cale> The nice thing about these pictures is that it's clear just how much work the scans actually do
10:45:40 <Cale> (things actually get shared like that in memory)
10:46:49 <Cale> > let mymap f = foldr ((:) . f) [] in mymap (*2) [1..5]
10:46:50 <lambdabot> [2,4,6,8,10]
10:47:15 <CosmicRay> mjl69: got a url for your haskell shirts?
10:47:42 <mjl69> let me see...
10:47:49 <acd> Arte there some papers on good coding style in Haskell?
10:47:54 <acd> s/Arte/Are
10:48:17 <ibid> hmm, i thought somebody had debian-packaged gtk2hs 0.9.10, but i can't find it anywhere besides mentors?
10:48:58 <alar> @seen adept
10:48:59 <lambdabot> adept is in #haskell. I don't know when adept last spoke.
10:49:01 <mjl69> http://www.cafepress.com/buy/haskell/-/pv_design_prod/p_haskellnewlogo.7154115/id_2841463/pNo_7154115/fpt_/opt_/c_/pg_
10:49:15 <mjl69> I think that's the exact one I have
10:49:41 <adept> alar: here i am
10:50:05 <alar> wilkommen zu haskell_ru :)
10:50:30 <acd> alar: ru == `russia'?
10:50:37 <Zert`> ja ja
10:50:45 <Zert`> das ist russland
10:50:49 <alar> exactly
10:50:50 <acd> nice :) i'm russian too
10:51:19 <Zert`> heh
10:51:22 <CosmicRay> what's the deal with speaking german (or is that dutch?) to the russians ;-)
10:52:01 <alar> CosmicRay: nothing more than speaking english to them ;)
10:52:06 <CosmicRay> heh
10:52:46 <sieni> acd: I don't think there is anything useful about Haskell for a person that wants to learn it systematically
10:53:06 <adept> acd: so join up
10:53:35 <sieni> like there are good books about C++ and there are good books about Lisp, but I have seen no decent books about Haskell (i.e. that don't treat the reader as a stupid teenager)
10:54:08 <Cale> well, there are papers :)
10:54:09 <mjl69> get every tutorial in html loaded into Firefox tabs and read all at once.
10:54:22 <adept> sieni: "all about monads"?
10:54:23 <acd> sieni: i remember some "Haskell: The craft of functional programming" published by Addison-Wesley
10:54:26 <Cale> and there's the Report
10:54:32 <adept> @seen SamB
10:54:33 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. I don't know
10:54:33 <lambdabot> when SamB last spoke.
10:54:38 <adept> @seen jlouis
10:54:39 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
10:54:39 <lambdabot> spoke.
10:55:11 <sieni> acd: I have that one and it's substandard compared to Paulson's "ML for the working programmer"
10:55:28 <ibid> sieni: i think the problem is that all the books are primarily intended as textbooks for a first programming course
10:55:28 <mjl69> acd: I just got that 'craft' book.  it's not bad.  like a big tutorial.
10:55:54 <mjl69> monads are not a major topic in it.
10:56:26 <ibid> sieni: there are no books, to my knowledge, that teach haskell as second or nth language
10:57:03 <ibid> (which is a problem when i teach haskell as second language:)
10:58:38 <sieni> ibid: it would be nice to have a similar book to Paulson's "ML for the working programmer" about Haskell with decent examples about monads as well
10:59:18 <ibid> sieni: haven't read that, but it sounds like "ML as nth language" :)
11:00:22 <sieni> ibid: Probably... I'm not qualified to speak about that, since I've been playing with computers since the age of 6 and that was about 25 years ago :-)
11:00:53 <sieni> and anyway I'm a mathematician by training and not a computer scientist
11:01:39 <ibid> well, i have had little guidance from the existing books when i designed my "haskell as second language" course
11:02:08 <ibid> with a lot of luck, i might eventually produce something suitable
11:06:13 <goron> ==fptools== make all -wr; in ~/fptools/ghc/compiler it printed in my terminal, and make uses 99% CPU, but besides that, there's no progress on the compilation... OTOH, the "nightly builds" of GHC don't seem to have this problem.... 
11:09:16 <Cale> shapr: you still about?
11:09:39 <sieni> ibid: take a look on "ML for the working programmer"
11:09:57 <sieni> ibid: I think it will be worth your while
11:11:47 <ibid> sieni: like a lot of other books as well
11:12:28 <flux__> benny, well, ocaml-expat was easy to enough to write first program within 5 minutes of introduction ;)
11:15:33 <sieni> ibid: I mean that the examples are such that you actually might want to read them, like showing how you functionally solve a system of linear equations with gaussian elimination and such
11:17:33 <sieni> Or to explain how a priority queue is implemented (with a heap)
11:18:06 <mjl69> I started with Haskell because I heard about it through pugs and now I'm hooked because it's fun.  Maybe I should get that ML book and play around with that too.
11:18:47 <sieni> mjl69: It's a nice book and probably a good idea for a Haskeller to go through
11:19:43 <sieni> and also another thing was that the book explained how permutations are enumerated in lexicographic order and I hadn't even heard about it even though I have a Ph.D. in math.
11:19:53 <mjl69> sieni: I'm going to get it.
11:21:08 <sieni> One of the annoying things is that ML and Haskell have opposite meanings for : and :: :-)
11:23:08 <PupenoL> ibid: have you found the package ?
11:23:34 <flux__> sieni, how do you figure?
11:23:48 <mjl69> Ph.D. in math?  that's really tough.  Just 100/year, right?
11:23:51 <flux__> in haskell 1:2:3:[] is the same as 1::2::3::[] in ocaml?
11:23:53 <sieni> flux__: about what?
11:24:04 <mjl69> maybe that's just in the US
11:24:29 <sieni> mjl69: what do you mean by 100/year?
11:24:36 <flux__> I don't think :: is a real operator in ocaml, though
11:24:51 <mjl69> 100 new Math Ph.D.'s every year.  I read that somewhere a while back.
11:24:54 <ibid> PupenoL: hm?
11:25:14 <PupenoL> ibid: gtk2hs' package
11:25:23 <ibid> sieni: well, for the data structures, there are other books :)
11:25:33 <mjl69> That's not very many people who make it.
11:25:36 <ibid> PupenoL: there's one in mentors
11:25:38 <sieni> flux__: I was talking about the real ML :-)
11:25:42 <flux__> ooh
11:25:57 <flux__> I hadn't thought there would be differences on that too :)
11:26:15 <sieni> mjl69: well, I don't live in the States and don't have any intention to (anymore :-)
11:27:07 <sieni> flux__: except that 1
11:27:25 <sieni> flux__: except that 1::2::3:
11:27:27 <sieni> fuck
11:28:01 <sieni> flux__: except that 1::2::3::[];; works perfectly well in ocaml
11:28:21 <mjl69> sieni: I majored in math in college, but I graduated back in '91.  I don't remember much because I haven't kept up with it.  That's why I like Haskell now.
11:28:42 <flux__> that was what I was saying. maybe I just misunderstood what you were ;-)
11:29:20 <flux__> haskell doesn't have a meaning for ::, so I thought that you meant that : in haskell has a different meaning from :: in ml, right?
11:29:41 <flux__> while I tried to say that they have the same meaning
11:32:21 <sieni> flux__: Well, at least in SML ':' is used for type annotation, whereas in Haskell the magic operator for the same use is '::', which happens to be the opposite convention as it is for consing
11:34:09 <sieni> But Ocaml has a Crappy License (R), so only Standard ML is supported and anyway MLton generates faster binaries than Ocaml.
11:35:49 <benny> flux__: but i like haskell :)
11:39:44 <sieni> And what I mean by Ocaml License is the following: If you make improvements to their compiler, they can take it and sell it commercially without giving you a dime or giving you any access to their further changes to your changes to the software
11:40:20 <sieni> sieni: in an objective sense it is considerably crappier license to both GPL and BSD license.
11:40:50 <sieni> Even Trolltech, who invited QPL provides Qt with GPL as an alternative license
11:41:58 <goron> sieni: you can buy the complete source if you want for $2K, IIRC. 
11:42:11 <goron> (that's next to nothing)
11:42:20 <sieni> goron: well, you can get the complete source for Ocaml for free
11:42:41 <goron> sieni: But not with the license you might want. 
11:43:55 <goron> I can't really find their license on their site anymore.
11:44:33 <audreyt> @pl \(f, s) -> (g f, s)
11:44:34 <lambdabot> first g
11:44:44 <audreyt> @index first
11:44:45 <lambdabot> Control.Arrow
11:44:50 <sieni> goron: I'm not whining that their code is unusable for commercial projects, but that it's not usable for free software projects, because they want immediately any right for any improvements for their codebase for free without any compensation
11:45:37 <goron> sieni: I am sure you can build a binary which is GPL, which e.g. optimizes their AST. 
11:45:48 <sieni> GPL is perfectly nice for me as is BSD, but QPL is almost equally evil as any EULA that Microsoft could invent
11:46:07 <sieni> goron: I'm talking about their compiler
11:46:11 <goron> sieni: do you have a link to their license?
11:46:16 <goron> sieni: me too. 
11:46:56 <goron> sieni: e.g. Stratego is build around that concept. I,e. that you have a transformation system. 
11:48:48 <adept> @where hIDE
11:48:49 <lambdabot> http://www.haskell.org/hawiki/hIDE
11:49:01 <sieni> goron: read the file LICENSE in ocaml main source package
11:50:42 <sieni> QPL is a complete ripoff, since the original authors want complete rights for any changes to the original software, but give nothing back. GPL, LGPL and BSD licenses are reasonable in that way
11:56:24 <adept> @where conjure
11:56:25 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
11:58:45 <CosmicRay> what is this conjure thing?
11:59:04 <CosmicRay> oo, a bt client.
11:59:05 <CosmicRay> sweet.
11:59:57 <adept> CosmicRay: join up :)
12:03:18 <CosmicRay> I've just pulled the code.  I see you are using the missingh logging framework.  Excellent. ;-)
12:03:31 <CosmicRay> And I see you have a shout out for volunteers to write something that uses ConfigParser.
12:03:44 <CosmicRay> I just may, once I get this postgresql binding for hdbc under my belt ;-)
12:03:58 <goron> Isn't MissingH GPL?
12:04:09 <CosmicRay> goron: I have a LGPL branch as well.
12:04:22 <goron> CosmicRay: ah, right, you were John Goerzen.
12:04:26 <CosmicRay> still am ;-)
12:04:49 <CosmicRay> adept: you guys out to slap a email file under _darcs/prefs on the server so that 'darcs send' will Do The Right Thing
12:05:22 <adept> CosmicRay: email should be there. WorksForMe, at leas
12:05:41 <adept> CosmicRay: that would be great if you wrote that!
12:05:42 <CosmicRay> oh. hmm.  I guess I was looking at the wrong directory.  you're right.
12:06:05 <CosmicRay> adept: I'm pleased somebody is actually finding code in missingh to be useful ;-)
12:06:41 <adept> CosmicRay: it would be nice if logging to stderr would be race-condition safe (see Conjure/Logging.hs) :)
12:06:45 <goron> CosmicRay: where's that LGPL branch?
12:06:56 <CosmicRay> goron: http://darcs.complete.org/missingh.lgpl
12:07:07 <CosmicRay> goron: it may be a bit outdated at the moment; I need to look at that soon.
12:07:27 <CosmicRay> goron: is is basically all the code I wrote, plus as much of the third-party code as is available under lgpl or bsd licenses
12:08:47 <goron> LGPL is compatible with BSD?
12:08:51 <CosmicRay> adept: good point.  I'll make a note to look at that.  should be fairly trivial to do.
12:09:02 <CosmicRay> goron: well, you can certainly use bsd code in lgpl programs.
12:09:09 <CosmicRay> the reverse is probably true as well.
12:09:26 <CosmicRay> well, of course the reverse is true.
12:09:32 <CosmicRay> it is with GPL even
12:09:40 <adept> CosmicRay: i hope that Logger.hs already does that. Should be trivial to cut-and-paste :)
12:09:51 * adept have to run
12:10:04 <CosmicRay> the difference is that you can distribute BSD code linked against LGPL code without having to guarantee the freedoms that the gpl guarantees.
12:13:28 <goron> GPL + BSD does not work, since BSD restricts the receiver of the code. 
12:14:21 <goron> You can't combine two works and distribute it to be "GPL". Since you can't change the rights given to you by an author of a BSD program. 
12:14:40 <goron> The new BSD license allows combinations, though.
12:15:45 <sieni> goron: no, you can relicense BSD code as (L)GPL or even a proprietary license as long as you give proper attribution for the original authors
12:17:58 <sieni> LGPL allows proprietary linking, but if you statically link your applications against an LGPL library you have to provide relevant .o files to relink the application against a modified version of the library
12:19:04 <CosmicRay> goron: that's incorrect.
12:19:15 <CosmicRay> GPL + BSD works fine.  the result is effectively under the GPL.
12:19:36 <CosmicRay> the BSD bits remain with a BSD license, but as part of the whole, fall under the GPL, since the BSD conditions are a perfect subset of the GPL conditions.
12:20:17 <sieni> There are also other corner cases:
12:20:27 <goron> CosmicRay: Uh, the BSD license says "you can't advertise with our names". GPL doesn't. 
12:21:14 <CosmicRay> goron: I guess I'd have to go back and check the GPL on that, but in any case, it's not a problem.
12:21:17 <CosmicRay> this is done all the time.
12:21:55 <goron> CosmicRay: What you can do is distribute some files as being GPL, and some as BSD. 
12:22:03 <CosmicRay> that last clause is basically a no-op anyway, since the activity it forbids is already illegal.
12:22:27 <CosmicRay> goron: and the entire work is distributable under the GPL.
12:22:54 <sieni> you can perfectly well distribute software that has a completely incompatible license with GPL, but unless you distribute the GPL software yourself, then...
12:23:33 <CosmicRay> goron: please see: http://www.gnu.org/licenses/gpl-faq.html
12:24:45 <goron> CosmicRay: That really does not make sense. You are saying that the moment I take a BSD file, I can redistribute it as GPL (thus removing e.g. all Copyright tags). 
12:25:06 <tuomov> http://iki.fi/tuomov/gpl_is_absurd.c
12:25:09 <goron> I am *not* talking about the new BSD license. 
12:25:22 <CosmicRay> you're talking about the original non-free 4-clause one?
12:25:22 <tuomov> that could theoretically violates the gpl.
12:25:26 <tuomov> s/could/code/
12:25:32 <tuomov> and yet it uses no gpl'd code
12:26:01 <goron> CosmicRay: yes, which still a lot of programs use. 
12:26:04 <CosmicRay> tuomov: how?
12:26:15 <tuomov> and the binary is at http://iki.fi/tuomov/gpl_is_absurd
12:26:22 <CosmicRay> goron: well I don't see what point there is in working with that one.  it's non-free anyway iirc
12:26:23 <tuomov> it is non-free, and uses a gpl'd library
12:26:35 <tuomov> but I am not distributing any part of othe library!
12:27:46 <tuomov> the point is that lgpl should be unnecessary
12:27:52 <tuomov> the differences that gpl has lgpl are absurd
12:27:56 <tuomov> +to
12:28:07 <CosmicRay> tuomov: I don't see what's absurd about this.
12:28:14 <goron> tuomov: No, but you link, which violates GPL, or do I miss something?
12:28:20 <CosmicRay> the whole point of the gpl is that everyone should have the right to modify things.
12:28:22 <tuomov> yes, and that's absurd
12:28:27 <CosmicRay> not just people that received it from the original author.
12:28:30 <tuomov> since I used nothing that is gpl'd in writing that code
12:28:31 <CosmicRay> no, that preserves freedom. 
12:28:56 <CosmicRay> that way, microsoft can't take your code, make a slight tweak, release a more popular version binary-only, and screw most people out of the code.
12:29:08 <tuomov> that's got nothing to do with this.
12:29:14 <CosmicRay> tuomov: well then you aren't creating a derived work and you have no problem.
12:29:15 <tuomov> did you look at that gpl_is_absurd.c?
12:29:18 <CosmicRay> tuomov: yes I did.
12:29:26 <tuomov> where do I use gpl'd code there?
12:29:31 <CosmicRay> tuomov: normally when people talk about linking, they assume you are actually using code in the library.
12:29:42 <tuomov> it's the _user_ that's using the code, not me
12:30:05 <CosmicRay> tuomov: using dlopen is no different than dynamic linking
12:30:07 <goron> I think tuomov's point is that he did not copied code in his source code. 
12:30:10 <tuomov> I just happen to have the strings "/lib/libreadline.so.5" and "readline" in the code
12:30:13 <CosmicRay> from the gpl perspective
12:31:18 <CosmicRay> you are using gpl'd code, though -- the readline function.
12:31:24 <tuomov> I'm not using it!
12:31:26 <tuomov> The user is.
12:31:37 <CosmicRay> your program is.
12:31:41 <CosmicRay> tuomov: this is silly.
12:31:45 <goron> I think the "static" linking is a bit stupid though. It assumes things about current computer systems. 
12:31:51 <tuomov> if the user has libreadline.so on the system, the program will work
12:32:01 <tuomov> if he doesn't, the program won't work
12:32:15 <tuomov> he could have some other libreadline.so what is not gpl'd
12:32:16 <CosmicRay> Gee, I'm not using the C library, the user is!
12:32:21 <tuomov> my code doesn't care what it does
12:32:25 <CosmicRay> I'm not using the GHC RTS, the user is!
12:32:28 <CosmicRay> this is a pointless argument.
12:32:35 <CosmicRay> nobodies code "cares"
12:32:44 <CosmicRay> your case is no different than anything else
12:33:00 <CosmicRay> if my bash is linked against libreadline.so.5, and that file doesn't exist on my system, bash doesn't work, otherwise it does.
12:33:08 <CosmicRay> you need to read the GPL & the faq
12:33:18 <CosmicRay> the GPL is based on the requirements of the program, not on how it is used
12:33:20 <tuomov> but you could have a non-gpl'd libreadline.so
12:33:23 <CosmicRay> the GPL explicitly says nothing about use
12:33:38 <CosmicRay> tuomov: and then you could link against that if you so choose, fine.
12:33:42 <tuomov> there are a zillion implementation of libc, you know.
12:33:51 <tuomov> I don't link against any specific implementation
12:33:57 <tuomov> the user does when the program is executed on his system
12:33:57 <goron> tuomov: good point!
12:34:37 <CosmicRay> please read http://www.gnu.org/licenses/gpl-faq.html#GPLIncompatibleLibs
12:34:37 <tuomov> I don't even use the headers
12:34:43 <CosmicRay> your example is invalid for several reasons
12:34:51 <tuomov> I don't care what FSF says, of couse they say you can't do this and that
12:34:56 <CosmicRay> err wait, wrong link
12:35:28 <goron> tuomov: maybe you could "warn" the users that they don't use a GPL version of that library. 
12:36:10 <CosmicRay> tuomov: the fact is that you are linking against GPL code.  I find your argument very flimsy.  You can't redefine what it means to "link" by simply doing yourself what the standard linker would normally do for you.
12:36:12 <goron> tuomov: but that's not even practical. I like hypothetical GPL-holes. This is a nice one. :D
12:36:21 <CosmicRay> anyway, back to coding...
12:36:44 <goron> CosmicRay: He is not linking to GPL code. He's linking to some file which happens to be GPL on a lot of systems.
12:37:54 <CosmicRay> goron: on every system.
12:38:01 <CosmicRay> I'm not aware of any non-GPL readline.
12:38:12 <tuomov> do you want me to write a primitive libreadline.so?
12:38:27 <tuomov> it's fgets.
12:38:28 <CosmicRay> if you link against that, then fine, there is no argument.
12:38:34 <goron> CosmicRay: well, you don't know the entire universe, so you can't prove it doesn't exist. 
12:38:36 <tuomov> I don't link against anything.
12:38:42 <goron> The user links.
12:38:43 <CosmicRay> (assuming doing so makes the application work as you want it to)
12:38:45 <araujo> Hello.
12:38:48 <araujo> What's up?
12:38:52 <CosmicRay> tuomov: yes you do, that's what dlopen does, and you wrote that code in your app.
12:39:02 <CosmicRay> goron: then what is he complaining about?  gpl doesn't cover use.
12:39:06 <CosmicRay> this is silly.
12:39:13 <CosmicRay> you both are intentionally twisting the meaning of the license.
12:39:24 <goron> Funny isn't it?
12:39:26 <CosmicRay> it is pretty clear that dlopen() is considered linking, and this has been explained in public before.
12:39:29 <tuomov> I'm saying that lgpl isn't needed if macros in headers aren't used etc.!
12:39:30 <monochrom> All complaints about licenses are silly.
12:40:16 <araujo> mm...
12:40:28 <monochrom> I say, if there is a dispute on what the license means, take it to the court.
12:40:46 <araujo> tuomov, LGPL is needed to link non-free code with GPL'ed code.
12:41:19 <tuomov> my example demonstrates that it isn't
12:41:29 <araujo> What is your example?
12:41:47 <tuomov> http://iki.fi/tuomov/gpl_is_absurd.c
12:42:35 <araujo> I don't see what part of the code demostrates it.
12:43:00 <tuomov> http://iki.fi/tuomov/libreadline.c
12:43:19 <goron> araujo: The point is that it links to *a* libreadline, not necessarily a GPL one.
12:43:57 <araujo> Sighs.
12:44:10 <goron> He, I didn't come up with it. 
12:48:16 <araujo> tuomov, i still don't see your point.
12:48:31 <araujo> readline is not a tradermark or something.
12:48:42 <araujo> you are not using GPL/LGPL code there.
12:48:56 <tuomov> araujo: exactly!
12:49:06 <araujo> Exactly what?
12:49:30 <tuomov> The user most likely uses a gpl'd library with my program, but not necessarily.
12:50:23 <araujo> If your user uses GNU readline with it, then it violates the GPL.
12:50:32 <araujo> And you should be blamed for that too.
12:50:44 <araujo> Considering that you are not warning or releasing your own version.
12:50:47 <tuomov> But I intended the program to be used with my libreadline!
12:50:49 <araujo> To the user.
12:50:56 <araujo> Then do so.
12:51:13 <araujo> warn to the user, and explicitly state that he needs your readline.
12:51:13 <goron> So, then warning should be enough according to you?
12:51:32 <araujo> goron, And installing tuomov's readline too.
12:51:59 <goron> araujo: Suppose the user sees tuomov's readline, and sees it doesn't work "fast enough". 
12:52:09 <araujo> If you don't release your readline and wanr the user about it, then you are doing it on purpose right? :-]
12:52:10 <goron> araujo: and then just deletes his readline.
12:52:21 <araujo> goron, He can't use the programm then.
12:52:31 <araujo> It violates the GPL.
12:52:34 <goron> araujo: Technically he can.
12:52:43 <goron> araujo: So who violates the GPL now?
12:52:49 <araujo> Technically you can practically whatever you want :-)
12:52:49 <goron> The user or tuomov?
12:52:53 <araujo> But that's not thepoint.
12:53:02 <araujo> goron, The user evidently.
12:53:20 <araujo> And tuomov is helping to that fact too.
12:56:57 <tuomov> http://modeemi.fi/~tuomov/b/archives/2005/12/23/T22_53_01/
12:56:57 <araujo> Actually what tuomov is doing, it's breaking the whole system of the user if you ask me :-]
12:57:07 <tuomov> that's not my problem!
12:57:14 <araujo> But it is to the user.
12:57:27 <araujo> So i doubt your appli would be too succesful 
12:58:53 <glguy> I'm coming into this conversation late, but I don't think that GPL considerations matter to most users
12:58:57 <araujo> "I have not violated the GPL anywhere, yet my program is not GPL'd and can use a GPL'd library."
12:59:04 <araujo> This is evidenyly incorrect.
12:59:07 <glguy> while other users really strive to run a "free" system
12:59:11 <araujo> You are not actually using a GPL library.
13:00:09 <tuomov> I have provided a public domain library with which the program should be used.
13:00:51 <araujo> public domain != GPL
13:01:04 <PupenoL> araujo: if you haven't released the sources nor the binaries maybe you are not breaking the GPL by having a program that is not GPL linked to a GPL library, of coures that's useless.
13:01:14 <PupenoL> araujo: except on web applications maybe.
13:01:14 <glguy> But could someone fill me in on the connection between this topic and the channel tho :)
13:01:20 <SyntaxNinja> 'mornin
13:01:27 <araujo> Hello SyntaxNinja 
13:02:16 <araujo> Pupeno, you need to release your own version binary or source of your own library.
13:02:44 <PupenoL> araujo: why ?
13:03:04 <araujo> Pupeno, Because you can't use GPL code linked to non-GPL'd
13:03:31 <araujo> If tuomov wants to use his own version of readline, taht's fine, as long as he releases his own version of course.
13:04:20 <goron> araujo: I don't agree. There's nothing wrong with creating a binary and distributing it and linking it to a non-existent library. 
13:04:42 <PupenoL> araujo: GPL doesn't force you to release, it forces you to release sources IF you release binaries.
13:04:57 <goron> E.g. the non-existing libtreadline. 
13:05:02 <goron> er read
13:05:10 <araujo> Pupeno, tuomov is releasing sources.
13:05:21 <araujo> Or well, ask him, i really don't know what it is his goal :-]
13:05:37 <goron> araujo: No, tuomov does not release sources. 
13:05:43 <goron> araujo: Under GPL, that is.
13:05:48 <araujo> goron, non-existen library?
13:05:52 <tuomov> I release soures, but they're non-free
13:05:53 <goron> * Most specifically this code is _not_ under the GPL. */
13:05:57 <goron> araujo: yes
13:06:13 <araujo> goron, I don't understand what you mean
13:06:30 <araujo> you mean, that the user doesn't have the tuomov's library?
13:06:38 <glguy> isn't this similar to what nVidia does with its drivers...? they don't link them to anything, you do?
13:06:55 <goron> araujo: You are claiming that it's illegal for tuomov to release a binary, that links to libdoesnotexists.so.5
13:07:11 <araujo> tuomov, you can do whatever you want with ouy code. 
13:07:12 <goron> araujo: And that can't be true, since there's no law which states that.
13:07:27 <araujo> No, i never said that.
13:07:40 <goron> araujo: but you imply that.
13:07:54 <goron> How about jumping back in time 30 years.
13:07:57 <araujo> I said that if tuomov's binary link (even by accident) to the GPL library, then it is clearly a violation.
13:07:58 <goron> There's no readline. 
13:08:10 <araujo> No, i am not implying that, i am being very precise in the context.
13:08:18 <araujo> goron, Then it is good.
13:08:26 <araujo> If the user doesn't have readline, good.
13:08:33 <araujo> Nothing to be worried.
13:08:50 <araujo> He7she only needs to install the tuomov's version and done.
13:08:55 <goron> araujo: And what exactly should the user do to comply with GPL?
13:09:24 <araujo> goron, That's up to the user, does he really want to use tuomov's application?
13:09:24 <goron> araujo: The user doesn't have the source of the tuomov program.
13:09:32 <araujo> Probably at the cost of breaking the whole system?
13:09:38 <goron> araujo: Of course! It's the best application ever.
13:09:41 <glguy> it's not illegal for the user to link to the GPL'd library
13:09:47 <glguy> assuming he doesn't distribute the app :)
13:09:57 <araujo> goron, Then he can do it, as long as he doesn't link to the GPL readline
13:10:17 <goron> araujo: The user is just plain old Joe User, and doesn't understand linking. 
13:10:19 <araujo> glguy, yes it is.
13:10:22 <glguy> and since the GPL's never been proven in court, it might not be illegal anyway!
13:10:45 <goron> glguy: That's diverging from the subject.
13:10:53 <glguy> No, the subject is Haskell
13:10:58 <PupenoL> glguy: it has been proven in court, update please.
13:11:00 <glguy> this is all off topic
13:11:08 <araujo> goron, SO?
13:11:14 <araujo> goron, That is up to the user :-]
13:11:33 <goron> araujo: Ok, that was a weak point. 
13:12:24 <goron> araujo: I think that the moment the user creates a "derived work", he complies with the GPL.
13:12:49 <araujo> "derived work" from what?
13:12:50 <tennin> I think the point is that if the GPL and nations' law codes were written in a strictly functional language, they'd be a lot easier to profile and debug.
13:12:52 <tennin> Or something.
13:12:58 <araujo> tennin, hah
13:13:07 <PupenoL> on the handler of runDgramServer (http://www.cs.helsinki.fi/u/ekarttun/network-alt/doc/Network.Alt.Server.html), how do I send back some data ?
13:13:13 <goron> araujo: from libreadline
13:13:26 <goron> araujo: The user does not distribute the program.
13:13:34 <araujo> goron, Not , if it is from the tuomov's readline.
13:13:44 <araujo> His code is in public domain.
13:13:57 <goron> araujo: no, it's the standard readline.
13:14:09 <araujo> I mean, techincally speaking, tuomov's code got nothing to do with the GPL.
13:14:20 <araujo> I don't see why we are discussing this :-]
13:14:29 <goron> araujo: that's the whole point of tuomov.
13:14:49 <araujo> To discuss about nothing? :-P
13:15:01 <goron> Sigh
13:15:21 <araujo> Really, i don't see any valid point.
13:15:35 <araujo> readline is not patented or trademarked.
13:15:58 <tuomov> the whole point is that GPL==LGPL
13:16:02 <araujo> tuomov can write his own readline code.
13:16:17 <araujo> tuomov, How do you make that point?
13:16:38 <sproingie> that's a very interesting interpretation, but RMS doesn't agree
13:16:40 <araujo> mm.. ok, for a minute i forgot this is #haskell, you can take the discussion to #gnu if you prefer.
13:16:41 <tuomov> I have a program that links to a GPL'd library without itself being GPL or violating GPL
13:16:58 <sproingie> LGPL has a clause that lets you change to GPL, but sure not the otherway around
13:17:09 <araujo> sproingie, that's the point.
13:17:12 <tuomov> now, if the GPL'd library has some macros in headers that may code uses, the situation is a bit different
13:17:18 <tuomov> s/may/my/
13:17:22 <PupenoL> tuomov: can I download it ?
13:17:32 <goron> http://modeemi.fi/~tuomov/b/archives/2005/12/23/T22_53_01/
13:17:45 <sproingie> is it written in haskell?
13:17:46 <glguy> There are non-GPL'd libreadline libraries... right?
13:17:47 <araujo> tuomov, Your programm isn't linking to a GPL library, because you *need* to release your library too.
13:17:52 <sproingie> glguy: libedit
13:18:03 <araujo> And which is in public domain.
13:18:20 <glguy> so.... he write the application using libedit... adds a config line to specify the name "/lib/libedit"
13:18:35 <glguy> and then the user decides to change that to "/lib/libreadline.so.5" later...
13:18:40 <glguy> what's the beef?
13:18:48 <araujo> You can better understand it like this... in your code, you have something like: 
13:18:49 <araujo> void *h=dlopen("/lib/libreadline.so.5", RTLD_LAZY);
13:18:58 <tuomov> no, the user doesn't need to edit my code, and isn't infact allowed to
13:19:06 <SyntaxNinja> it seems pretty clear that GPL does not intend to allow you to link to GPL libraries from non-GPL programs.
13:19:08 <araujo> Won't you release libreadline? , 
13:19:11 <sproingie> it's a matter of intent.  licenses are not executable code
13:19:19 <tuomov> but the user may decide to not install my libreadline, and suddenly my code will work with the gpl'd libreadline that the user most likely has
13:19:25 <sproingie> finding a technical loophole doesn't mean you found a licensing loophole 
13:19:43 <glguy> araujo: but if it was ...dlopen(lib_edit_filename, RTLD_LAZY)...
13:19:48 <araujo> tuomov, , no, he not 'may decide' , he *needs* to do it.
13:19:49 <tuomov> I *intent* my code to be linked against my public domain libreadline.
13:19:54 <SyntaxNinja> I seem to recall that libreadline is specifically mentioned on GNU's web site as an example of using GPL instead of LGPL.
13:20:11 <sproingie> if the user decides to use readline, they can't distribute under anything but gpl.  if you provide a generic interface and use libedit, you're fine
13:20:11 <tuomov> yes, libreadline is GPL, not LGPL
13:20:13 <PupenoL> SyntaxNinja: yes.
13:20:14 <araujo> glguy, it can't be, because tuomov's forbids to modify the code.
13:20:23 <glguy> araujo: how is it the authors responsibility what the user puts in that variable?
13:20:24 <sproingie> SyntaxNinja: it's ensuring readline's eventual demise is all it's doing
13:20:31 <araujo> glguy, uh?
13:20:31 <glguy> araujo: that can be read from a config file
13:20:36 <SyntaxNinja> sproingie: so? that's up to the authors.
13:20:51 <araujo> glguy, And tuomov won't tell to the user what kind of library should be there?
13:20:56 <araujo> Let's be serious abut this.
13:21:00 <sproingie> SyntaxNinja: indeed it is.  pragmatically speaking though, adhering to the gpl instead of lgpl has doomed readline
13:21:01 <glguy> araujo: he can tell them
13:21:09 <araujo> glguy, he *needs* to tell them.
13:21:11 <glguy> araujo: he can say that a library that does what libedit does needs to be there
13:21:18 <sproingie> now i need to find an alternative to gmp, also gpl'd
13:21:23 <SyntaxNinja> sproingie: huh?
13:21:47 * sproingie sighs.  not like any of this goes anywhere useful regardless of what channel it's on
13:21:49 <SyntaxNinja> sproingie: if the authors agree with you, and want libreadline to live on, then they can release it GPL.
13:21:51 <araujo> glguy, Then the user needs to check the license, and if it is GPLD, then he can use a GPL library, if not, then not.
13:22:10 <SyntaxNinja> yeah, let's take it off this channel, if ppl really want to have this conversatin, it's trivial to "/join #haskell-gpl" and have the convesration there.
13:22:19 <glguy> araujo: Okay, but at that point it's not tuomov's responsibility... right?
13:22:27 * glguy is done
13:22:27 <sproingie> come to think of it, what license is haskell under?
13:22:35 <araujo> glguy, If it is up to the user to choose the library, hey, it is also up to him to check for the license compatibility.
13:22:39 <PupenoL> on the handler of runDgramServer (http://www.cs.helsinki.fi/u/ekarttun/network-alt/doc/Network.Alt.Server.html), how do I send back some data ? That is, how do I get a socket back to the caler ?
13:22:44 <goron> sproingie: languages don't come with licenses.
13:22:44 <sproingie> er, license of ghc, i should say
13:22:49 <SyntaxNinja> glguy, araujo, sproingie, PupenoL, go to #haskell-gpl
13:22:51 <goron> LGPL
13:22:58 <araujo> SyntaxNinja, Sorry.
13:23:11 <glguy> SyntaxNinja: I'm not going to join that channel, but I'm not going to talk about that other stuff either, so we should be good
13:24:04 <SyntaxNinja> sproingie: ghc is under a BSD-style license. I believe the same is true for Hugs. 
13:24:15 <SyntaxNinja> all the libraries that GHC comes with are distributed under a BSD-style license.
13:24:37 <sproingie> so we're all good.  good.
13:25:14 <araujo> hah
13:25:54 <sproingie> been looking at this giant architectural edifice of an "xml pipeline" called netkernel
13:26:17 <sproingie> eyes glossed over for a while ... til i looked at haxml and realized i could do pretty much exactly the same thing with 1/100th the code and more power
13:26:47 <SyntaxNinja> haxml is LGPL, if I recall
13:27:35 <xerox> Goodnight
13:27:41 <SyntaxNinja> later xerox
13:27:52 <xerox> But before, you ever heard of: http://www.y-windows.org/ ?
13:27:56 <xerox> Bye :)
13:28:06 <sproingie> Y is still twitching?
13:34:45 <PupenoL> musasabi: are you there ?
13:42:11 <araujo> For those still interested to solve the doubt abut our small discussion of GPL/LGPL code. We'have got a FSF staffer inside #haskell-gpl
13:42:24 <araujo> So, tuomov , drop in :-]
13:44:29 <CosmicRay> question about foreignptrs
13:44:43 <CosmicRay> does the system guarantee that the finalizer is run exactly once?
13:44:56 <CosmicRay> that is, if I call finalizeForeignPtr, it won't run the finalizer again when the object goes out of scope?
13:45:04 <CosmicRay> or if I call finalizeForeignPtr twice, it won't re-finalize it?
13:45:55 <goron> CosmicRay: maybe you could write a patch for the documentation since *everyone* asks the same question (when you know the answer).
13:46:02 <CosmicRay> heh
13:46:23 <CosmicRay> so do you know the answer? ;-)
13:46:38 <flux__> 42? hmm, no I don't thin that's it..
13:47:30 <sproingie> i've always held that if you allow a finalizer to be called explicitly, you better code defensively if it gets called again
13:47:46 <sproingie> since nothing would otherwise stop someone from calling it twice, manually
13:50:00 <Saulzar> Hmm, bizzare. I install gtkglext to /opt/gnome (to fix some troubles with building) and the corruption stuff dissapears, I wonder if it was using an old version previously.
14:17:24 <goron> CosmicRay: no, I don't know, but I know everybody always asks the Simons.
14:17:44 <goron> CosmicRay: and I can imagine them becoming tired of it.
14:22:40 <danb> what's the difference between `StateT A StateT B` and `StateT B StateT A`?
14:22:51 <danb> do state monad transformers commute?
14:24:24 <danb> ...anyone alive? i know it's close to xmas, but i thought geeks and academics were immune to holidays :P
14:25:26 <Cale> hi
14:25:31 <danb> hello
14:25:41 <Cale> Monad transformers don't quite commute
14:25:45 <danb> in general, yes
14:25:51 <Cale> Those two are isomorphic
14:25:54 <danb> but special cases do
14:25:58 <Cale> but you have to use them differently
14:26:05 <danb> hmm, ok
14:26:09 <danb> makes sense
14:26:13 <danb> e.g. lift in different places
14:26:15 <Cale> right
14:26:31 <danb> but they "mean" the same thing?
14:26:59 <danb> like, `ListT StateT A` and `StateT A ListT` mean fundamentally different things
14:27:46 <danb> (hmm, i need more parens somewhere...)
14:27:49 <Cale> yeah, I'm pretty sure StateT will always commute with itself up to isomorphism
14:27:53 <danb> ok
14:28:09 <danb> just looking for a sanity check; thanks
14:28:18 <Cale> ListT as given in the libraries is kind of broken
14:28:23 <danb> hrm
14:28:33 <Cale> in the sense that it fails to produce monads
14:28:41 <danb> really?
14:28:58 <Cale> yeah, I recall various laws being broken
14:29:15 <danb> ah, hmm
14:29:25 <Cale> http://www.haskell.org/hawiki/ListTDoneRight
14:29:31 <Cale> http://www.haskell.org/hawiki/ListTDoneRight_2fAlternative1
14:29:47 <Cale> (also see http://www.haskell.org/hawiki/ContinuationsDoneRight)
14:30:02 <Cale> I have no idea why this code isn't in the hierarchical libs
14:30:39 <danb> interesting
14:30:49 <benny> anyone know where i can get the source code for Fruit?
14:31:45 <danb> Cale: thanks. ListT doesn't really concern me right now, so i'll avoid the distration. but i'll remember it for the future
14:32:01 <danb> happy holidays all
14:33:33 <Cale> http://haskell.org/fruit/
14:34:32 <Cale> http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
14:48:16 <benny> Cale: hm... thanks wonder how i missed that
15:00:26 <musasabi> PupenoL: now here.
15:16:22 <Cale> http://vx.hn.org/autoshare/folds.png -- latest version, in a somewhat more convenient size :)
15:17:42 <monochrom> haha
15:21:20 <Pupeno> Can I convert a IO String or String to a Ptr Word8 ? (it should be interpreted as ASCII).
15:22:11 <musasabi> Have you looked at Foreign.C.String ?
15:22:38 <Pupeno> musasabi: I had to modify Network.Alt.Socket to be able to make a udp server, I'll send you the patch in a minute.
15:23:04 <Pupeno> Cale: can we get the svg ? or a white background (inkjet friendly) version ?
15:23:10 <Cale> sure
15:23:59 <Cale> http://vx.hn.org/autoshare/folds.svg
15:24:04 <Cale> I'll do a white one
15:25:35 <musasabi> Pupeno: hmm, what was not working? having used it for UDP servers...
15:26:29 <Pupeno> musasabi: the handler of DgramServer doesn't receive the socket, am I missing something ? I need the socket to actually reply something.
15:27:13 <musasabi> Pupeno: you need to reply from the same port?
15:27:16 <sproingie> udp is connectionless.  you send your own datagram back
15:27:29 <Pupeno> musasabi: yes, from the same port to the same port.
15:27:44 <Pupeno> sproingie: I know.
15:27:56 <Pupeno> musasabi: daytime, echo, dns, all work that way.
15:28:08 <Cale> http://vx.hn.org/autoshare/folds-white-printable.svg
15:28:16 <musasabi> actually with DNS one can usually send the reply from a different port.
15:29:05 <Pupeno> musasabi: yes, but, I have to open another socket while there's one that works. Even then, I don't know the other computer's ip, nor the port.
15:29:49 <sproingie> that info should be in the datagram.  the ip anyway
15:29:56 <Cale> http://vx.hn.org/autoshare/folds-white-printable.png
15:30:00 <musasabi> mmh, I can see your problem.
15:30:02 <sproingie> if you're only getting the payload, that's a problem
15:30:32 <Pupeno> Cale: thanks.
15:31:06 <musasabi> Pupeno: you are given the socket address as parameter, but if that is not enough.
15:31:25 <mjl69_> so pattern matching...it's where you take the argument passed to a function and match it with a parameter of a function definition so Haskell will use the appropriate function definition based on the argument, right?  And you can match a value, an expression, a pattern, or a type constructor?
15:31:49 <Pupeno> musasabi: can I exctrat from that socket address the ip and port of the remote computer ? I couldn't find a way to do it.
15:31:53 <Cale> http://vx.hn.org/autoshare/folds.svg -- this is more viewable with firefox now :)
15:32:04 <sproingie> mjl69_: that's one thing pattern matching can do.  it's also useful in taking apart values
15:32:42 <mjl69_> sproingie: oh, I have to look at that, either I have not covered it yet or don't recognize it as such.
15:32:44 <sproingie> you can't necessarily "pattern match" arbitrary expressions.  there's guard predicates, but those aren't quite the same
15:33:49 <sproingie> tho for selecting a function to use, they're basically equivalent
15:33:50 <musasabi> Pupeno: you can use that in sendTo
15:34:15 <Cale> mjl69_: you can only pattern match things which are composed of data constructors (together with variables which match anything)
15:34:29 <Pupeno> musasabi: the same sa will work in sendTo and connect ?
15:34:57 <Cale> In some languages, like mathematica for instance, you can pattern match against anything at all, which is pretty flexible, but insane.
15:35:35 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/doc/Network.Alt.Socket.html#v%3AsendTo
15:35:39 <musasabi> and connect too.
15:35:55 <Pupeno> I'll try that again then.
15:35:55 <Cale> Evaluation becomes very tricky to reason about in such a language, and you always have trouble with functions that process their parameters in a nonstandard way.
15:36:34 <mjl69_> oh, so not expressions.
15:37:01 <mjl69_> then it's values, variables, patterns, and data constructors?
15:40:30 <Cale> yeah, well, patterns :)
15:40:40 <mjl69_> datatype constructors confused me a bit, because they are supposed to be functions or treated as functions, but I don't see that they can be defined to do anything.  They seem to just define the type that they 'construct'
15:40:45 <Cale> patterns are exactly what can be pattern matched :)
15:41:01 <Cale> They're a special kind of function
15:41:06 <Cale> @type (:)
15:41:07 <lambdabot> forall a. a -> [a] -> [a]
15:41:22 <Cale> @type Just
15:41:24 <lambdabot> forall a. a -> Maybe a
15:41:48 <Cale> Plain Haskell types are freely generated by their constructors.
15:41:54 <sproingie> are there any existential types lambdabot knows about?
15:42:25 <Cale> That is to say, every different application of the constructors to values will produce a different element of the type.
15:42:28 <sproingie> i have a hard time seeing how to use them without examples
15:43:22 <Cale> sproingie: well, you'd use them when you want a container which only cares that the types of things it's containing are in some particular classe(es)
15:44:14 <sproingie> Cale: wouldn't i just use a parametric type then?
15:44:47 <Cale> sproingie: but maybe you don't want to remember the original types of the things in your container -- this allows for things like heterogeneous lists
15:45:21 <monochrom> Some part of OOP is existential typing.
15:46:06 <Cale> {-# OPTIONS_GHC  -fglasgow-exts #-}
15:46:06 <Cale> data Showable where
15:46:06 <Cale>     Showable :: (Show a) => a -> Showable
15:46:06 <Cale> instance Show Showable where
15:46:06 <Cale>     show (Showable x) = show x
15:46:24 <sproingie> heterogeneous lists are good in a dynamic language, but when i can create my own types so easily, i don't see their use much
15:46:31 <sproingie> it's the OOP angle that interests me
15:46:33 <Cale> *Main> [Showable 5, Showable [1,2,3], Showable "Hello"]
15:46:33 <Cale> [5,[1,2,3],"Hello"]
15:47:14 <Cale> This sort of thing is handy, say, in a raytracer, where you might have a class Renderable
15:47:35 <Cale> with various methods used to determine ray intersections and such
15:48:36 <Cale> then you can, say, just store a sphere as a centre and radius, and make the Sphere type an instance of Renderable
15:48:43 <mjl69_> you know how in C++, template classes (generic programming) are mostly used for various kinds of containers?  Is that the main point of datatypes and their constructors?  Like trees?
15:48:51 <Cale> and then have your scene graph use existential typing
15:48:59 <sproingie> pretty much
15:49:06 <Cale> yeah
15:49:21 <tennin> ah, anyone have experience using hugs interaction mode under emacs?
15:49:33 <Cale> well, since Haskell is lazy, data structures have another view :)
15:49:54 <Cale> They also serve as control flow, if you'd like to think of them that way.
15:50:16 <Cale> For instance, lists in Haskell are basically the equivalent of an imperative language's loops.
15:50:38 <Cale> Only, you can't pass loop bodies around to functions usually in an imperative language :)
15:50:50 <Cale> er, entire loops, rather
15:50:59 <sproingie> i tend to sling generators around in python
15:51:01 <Cale> and you don't have higher order functions which transform them
15:51:03 <Cale> but yes
15:51:13 <Pupeno> I am making a set of libraries to make servers, what name do you like best NetServers, HasServers, HaServers ?
15:51:14 <Cale> generators in python are rather related
15:51:23 <Cale> but we also have other structures too ;)
15:51:28 <sproingie> yah, i have a comment in one of my apps
15:51:35 <sproingie> # it's like a super-verbose haskell here
15:53:02 <mjl69_> cool.  makes sense.
15:54:38 <Saulzar> Hmm, that's one very interesting point - that the abstractions available in functional languages are lower level than in OO or imperitive languages
15:55:41 <Saulzar> I have a friend at Uni who is constantly bagging Haskell, because (he says) you can do anything in other languages that you can do in haskell, but haskell is more restrictive.
15:56:16 <musasabi> Well you can do anything in Cobol or Visual Basic too
15:57:48 <mjl69_> all turing complete languages can be used for anything
15:58:04 <Saulzar> Refering to the flexibility gained through things like first class functions
15:58:16 <musasabi> @pl f a = (1,2,a)
15:58:16 <lambdabot> f = (,,) 1 2
15:58:22 <Saulzar> Instead (he says) classes and dynamic dispatch can provide the same level of flexibility
15:58:50 <musasabi> @pl f (a,b) = (a,b,1)
15:58:51 <lambdabot> f = uncurry (flip flip 1 . (,,))
15:58:54 <Saulzar> But I think he's wrong, functions are a lower level primitive, so you can do things like abstract the control structures. 
15:59:25 <mjl69_> there is a book out on C++ about going beyond using templates just for containers and using them to implement design patterns: http://www.amazon.com/gp/product/0201704315/qid=1135382137/sr=8-1/ref=pd_bbs_1/103-4936747-5480668?n=507846&s=books&v=glance
16:01:21 <Saulzar> I'm not sure it's about design patterns (in the OO sense), is it? 
16:01:34 <Saulzar> Template metaprogramming...
16:03:21 <benny> yeah, you really can do awesome things with c++ templates
16:03:51 <benny> c++ templates are in fact a functional programming language
16:04:08 <Saulzar> As well as drive you around the bend
16:05:33 <monochrom> I am a pragmatist when it comes to languages.  Suppose I have function f and I want it to be invoked over all members of a list/container.  Between "map f xs" and "xs.map(new Function() { public Object the_function(Object x) { return f(x); } })",  I think it's clear which one wins.
16:06:06 <JohnMeacham> they are like lisp with angle brackets instead of parens and odd odd syntax.
16:06:22 <monochrom> (Iterators are only more tedious.)
16:06:30 <mjl69_> and now Java gave in put them in.
16:07:20 <Saulzar> Not in the same way, Java generics are only useful for avoiding casts in containers
16:08:00 <mjl69_> oh, I didn't realize they weren't the same in the new version of Java.
16:09:26 <Saulzar> Yeah, they're nothing like templates
16:10:52 <araujo> @weather mcbo
16:10:53 <lambdabot> Unknown command, try @listcommands.
16:14:40 <Pupeno> lisppaste2: 
16:15:03 <Pupeno> lisppaste2: url
16:15:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:15:34 <lisppaste2> Pupeno pasted "compiling error" at http://paste.lisp.org/display/14957
16:15:52 <Pupeno> What I am doing wrong to get "Could not find module `Time'" ? (full error on paste)
16:18:26 <Lemmih> Can you access the Time module from GHCi?
16:18:33 <monochrom> You wrote "import Time"?
16:21:26 <Pupeno> monochrom: yes.
16:21:51 <Pupeno> monochrom: yes.
16:21:56 <Pupeno> Lemmih: yes.
16:22:24 <Pupeno> the courious thing is that it was working before I renamed my project and moved it to another dir.
16:24:05 <Pupeno> If I remove base from Build-Depends:, I get other errors, like Foreign.C.String not being found, while it was found before.
16:24:30 <musasabi> Pupeno: well Foreign.C.String is in the package base.
16:24:45 <Pupeno> Build-Depends: haskell98, base "solved" it. But it wasn't required before.
16:24:47 <musasabi> So if you don't have base in build-depends
16:24:59 <musasabi> Pupeno: yes, the old behaviour was wrong.
16:25:42 <Pupeno> oh! then it is ok (I might have been using the old cabal before then).
16:26:42 <benny> where'd Cale go?
16:28:01 <tenni1> hmm, "either f g" is basically the standard function from the coproduct of the domains of f and g to their common codomain, right?  is there an analogous standard Haskell function for products/tuples?
16:28:28 <dcoutts__> @type either
16:28:30 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
16:29:15 <tenni1> it would be forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
16:30:05 <dcoutts__> @type \f -> \g -> \x -> (f x, g x)
16:30:06 <lambdabot> forall a b t. (t -> a) -> (t -> b) -> t -> (a, b)
16:30:33 <dcoutts__> @djinn (a -> b) -> (a -> c) -> a -> (b, c)
16:30:34 <lambdabot> f a b c = (a c, b c)
16:30:47 <tennin> yeah, I know that works but is it standard?
16:31:19 <dcoutts__> there is no named function for that in the standard libs
16:32:47 <musasabi> "liftM2 (,)" ;)
16:33:41 <tennin> thanks
16:34:30 <skew> import Control.Monad.Reader for musasabi's to work
16:35:12 <tennin> (tuples are monads?)
16:35:25 <tennin> er, wait
16:35:33 <tennin> never mind =\
16:35:53 <musasabi> instance (Monad ((->) a)) does that
16:35:56 <benny> liftM, liftM2, liftM3, liftM4, liftM5.... too bad these liftM functions can't be generalized into a single function
16:36:23 <benny> haskell isn't powerful enough :;(
16:36:35 <musasabi> benny: rather that would be ambiguous.
16:36:55 <benny> why?
16:37:00 <musasabi> benny: you could solve it partly with fundeps but the endresult would not be very nice when you made type errors.
16:37:38 <benny> hm.... musasabi, do you know what villarceau circles are? (without looking it up)
16:38:16 <musasabi> doesn't ring any bells
16:38:33 <benny> ok when C gets back ask him... he knows everything :)
16:38:50 <lispy> C == Cale?
16:39:17 <benny> who else could it be?
16:39:22 <musasabi> mathworld tells me they are related geometry, not really my thing.
16:39:49 <benny> musasabi: yeah... C should know what they are without looking it up... the man knows everything :=
16:40:11 <lispy> heh, he does know a lot
16:57:06 <Cale> hello
16:58:33 <Cale> :)
17:00:00 <Cale> Villarceau circles? I've run into them once or twice before. They're certain circles on a torus.
17:00:28 <benny> "run into them"? when could you possibly need to use them?
17:00:51 <Cale> Use?
17:01:22 <Cale> I have no idea what practical application they might have, but most of the things I know about are like that :)
17:01:25 <Cale> hehe
17:01:38 <Cale> I have an undergrad degree in pure mathematics
17:01:48 <Cale> (as opposed to applied)
17:02:44 <benny> is pure mathematics fun? i want to get a phd in it...
17:03:31 <Cale> Yeah it is fun. Do you already have another degree?
17:03:41 <benny> no
17:04:15 <Cale> Well, do a bachelor's in it first :)
17:04:32 <benny> yeah, guess os
17:05:03 <Cale> But it's a beautiful area
17:05:31 <Cale> btw, liftMn are sort of generalisable
17:06:05 <Cale> > return (,) `ap` [1,2,3] `ap` [4,5,6]
17:06:07 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:06:18 <Cale> > liftM2 (,) [1,2,3] [4,5,6]
17:06:19 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:06:36 <Cale> you have to use `ap` between the parameters though
17:07:51 <yozora> > $([| 5 |])
17:07:53 <lambdabot>  parse error on input `$'
17:08:01 <musasabi> yozora: no TH in lambdabot
17:09:15 <yozora> hey, can TH create a compile time lookup table?
17:09:28 <Cale> benny: http://www.biwako.ne.jp/~hidekazu/materials/toruse.htm seems to have good pictures of Villarceau's circles
17:09:42 <yozora> i'm trying to learn Scheme to understand macros, but i'm more familiar with haskell
17:10:18 <Cale> yozora: Macros are easier in scheme, I think, but yeah, you can even do compile-time IO with TH.
17:10:21 <benny> Cale: cool... here's another good one: http://www.povray.org/community/hof/Villarceau_Circles-CSG.php
17:10:59 <Cale> ah, beautiful
17:11:04 <yozora> i don't know AOP well, but i have a suspicion it's a subset of what you can do with macros
17:11:44 <Cale> AOP seems to be a subset of what you can do with monads :)
17:12:39 <Cale> Though I don't really know it all that well either. It might be worthwhile making a real attempt at an AOP monad transformer, which extends a monadic language with cutpoints.
17:12:42 * benny is finally starting to understand monads :D
17:13:50 <Cale> benny: :)
17:14:08 <benny> but arrows are killing me :'[
17:14:53 <musasabi> try one at a time.
17:14:59 <yozora> it's great to know a language that already has everything built into it :)
17:15:10 <exsisonek> what is a good sequence of 'things to figure out how to write in haskell' to learn haskell?
17:15:14 <yozora> continuations monad, aop monad
17:15:26 <musasabi> that is just a library issue
17:15:38 <exsisonek> I'm familiar with logic but not functional programming
17:15:47 <Cale> yozora: it's just that Haskell is expressive enough to capture a lot of things
17:15:47 <exsisonek> (ie, logic programming)
17:16:03 <Cale> exsisonek: you'll likely enjoy the list monad :)
17:17:08 <yozora> yeah, no need to extend the base language to incorporate these things
17:17:19 <skew> There is a paper on AOP in Scheme that builds a macro like that
17:17:29 <yozora> i guess that must be what the lisp people have been thinking for the past few decades
17:18:00 <Cale> > do x <- [1..5]; y <- [5..10]; guard (odd (x + y)); return (x,y)
17:18:02 <lambdabot> [(1,6),(1,8),(1,10),(2,5),(2,7),(2,9),(3,6),(3,8),(3,10),(4,5),(4,7),(4,9)
17:18:02 <lambdabot> ,(5,6),(5,8),(5,10)]
17:18:37 <exsisonek> actually: is there a built in circular-list type in Haskell?
17:18:59 <Cale> exsisonek: not quite, though the standard list type supports circular lists
17:19:12 <Cale> (there's no way to enforce circularity though)
17:19:29 <musasabi> > let ones = 1 : ones in take 10 ones
17:19:30 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
17:19:52 <Cale> > take 20 (cycle [1,2,3])
17:19:54 <lambdabot> [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2]
17:20:07 <Cale> that only takes up ~3 elements worth of space
17:20:14 <Cale> and time
17:20:36 <Cale> (well, obviously, iterating through it takes longer, but only 3 elements will be constructed)
17:24:28 <Cale> *Main> :m + Debug.Trace
17:24:28 <Cale> *Main Debug.Trace> let t x = trace (show x) ()
17:24:28 <Cale> *Main Debug.Trace> take 20 $ cycle (map t [1,2,3])
17:24:28 <Cale> [1
17:24:28 <Cale> (),2
17:24:29 <Cale> (),3
17:24:31 <Cale> (),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
17:25:24 * monochrom cringes
17:25:28 <Cale> (the traces are interleaved with the printing of the list there, but you should get the picture that they only happen once)
17:26:49 <yozora> ahh, you use Language.Haskell.TH.lift
17:27:10 <yozora> evaluates then quasiquotes
17:27:19 <Cale> This sort of thing is fairly simple, but in fact with an appropriate datatype, you can even set up things like doubly linked circular lists.
17:27:25 <yozora> so can splice it in at compile time
17:28:11 <exsisonek> hmm
17:28:21 <exsisonek> that's worth looking into
17:28:50 <Cale> http://www.haskell.org/hawiki/TyingTheKnot
17:32:28 <Cale> Basically the trick is to think of all haskell values as pointers, since that's basically what they are: pointers to either code or data. The algorithm which you use to build circular structures is the same as that you'd use in an imperative language with pointers.
17:34:01 <Cale> One difference being that it uses let instead of updatable pointers, so you have to set the pointers to the right thing straight away.
17:34:56 <exsisonek> nice, once I wrap my head aroudn the language basics I'll check out the nuances
17:35:22 <ksandstr> that sounds a little too low-level. i prefer to think about variable bindings such as in python and lisp instead.
17:37:03 <Cale> The trouble is that the evaluation isn't quite possible in a strict fashion -- you're relying on the laziness to make things work. If you have references of any sort, you could do it similarly.
17:45:45 <Cale> hehe, I've posted this a lot already, but anyone who hasn't seen it: http://vx.hn.org/autoshare/folds.png :)
17:46:15 <Cale> a nice little visual dictionary of folds and scans on lists
17:54:57 <yozora> hmm can't lift floats or doubles in TH
18:00:31 <yozora> @. elite yow
18:00:33 <lambdabot> Don'+ hIT /\/\E!! I'/\/\ In T|-|e TwI|I9|-|+ sONe!!!
18:00:44 <yozora> @yow
18:00:45 <lambdabot> I'm having an emotional outburst!!
18:00:54 <yozora> @quote
18:00:55 <lambdabot> kolmodin says: i.e. I would rather lose my left arm than write it in
18:00:55 <lambdabot> Java
18:01:01 <yozora> @quote
18:01:03 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly
18:01:03 <lambdabot> responsible for hastening the adoption of functional programming languages
18:01:14 <yozora> @quote
18:01:15 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
18:02:33 <Lemmih> @quote
18:02:34 <lambdabot> adept says: I think I need cobrain to understand coeffects
18:02:50 <yozora> @quote
18:02:51 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks*
18:02:51 <lambdabot> I'll give you a cookie if you tell me how many letters that file has! -Oh,
18:02:51 <lambdabot> ok!
18:03:05 <yozora> @quote
18:03:06 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
18:03:11 <yozora> aww
18:03:12 <yozora> aww
18:03:13 <yozora> @quote
18:03:14 <lambdabot> Foo says: Bar
18:03:18 <yozora> @quote
18:03:20 <lambdabot> Foo says: Bar
18:03:38 <Lemmih> @quote
18:03:39 <lambdabot> Gahhh says: monads are usually a personal experience.
18:03:46 <Lemmih> @quote
18:03:47 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all software
18:03:47 <lambdabot> needs a fighting chance of correctness
18:03:59 <yozora> @quote
18:04:00 <Lemmih> @quote
18:04:00 <lambdabot> franka says: I don't like it if it's too hard
18:04:00 <lambdabot> Gahhh says: monads are usually a personal experience.
18:04:10 <yozora> :)
18:04:13 <Lemmih> @quote
18:04:14 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out
18:04:14 <lambdabot> right, "Hey, you know how you always have these bugs because what you
18:04:14 <lambdabot> thought was in the variable is not there?" And I get all of these nods of
18:04:14 <lambdabot> agreement. "Well, I've found a new language that solves that problem."
18:04:14 <lambdabot> Audience: "Ooooh! How?" Me: "There's no variables!" And then they all
18:04:16 <lambdabot> start moving away from me slowly....
18:04:35 <yozora> hehe
18:04:42 <yozora> @quote
18:04:43 <lambdabot> shapr says: Programming is the Magic Executable Fridge Poetry, it is
18:04:43 <lambdabot> machines made of thought, fueled by ideas.
18:04:57 <yozora> @quote
18:04:58 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell,
18:04:58 <lambdabot> but CL is much better", though. it doesn't suggest careful thought and
18:04:58 <lambdabot> objectivity...
18:05:32 <Lemmih> @quote
18:05:33 <lambdabot> franka says: I don't like it if it's too hard
18:05:41 <Korollary> not many quotes eh
18:05:47 <lispy> @quote lispy
18:05:48 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to
18:05:48 <lambdabot> tell my alarm clock how to snooze by using a list comprehension
18:06:13 <yozora> @quote Lemmih
18:06:14 <lambdabot> Lemmih hasn't said anything memorable
18:06:34 <stepcut> @quote lambdabot
18:06:34 <lambdabot>  of course i'm female
18:06:39 <yozora> @quote Korollary
18:06:40 <lambdabot> Korollary hasn't said anything memorable
18:06:45 <yozora> @quote stepcut
18:06:46 <lambdabot> stepcut hasn't said anything memorable
18:06:47 <lispy> @vixen how are you today?
18:06:48 <lambdabot> i am wonderful, thanks for asking!
18:06:51 <Lemmih> @quote SyntaxNinja
18:06:52 <lambdabot>  I think that the compiler authors will fly here from England just to
18:06:52 <lambdabot> kill me if I did that
18:07:02 <yozora> that's a good one
18:07:09 <Korollary> I think they're in Scotland, tho
18:07:16 <Korollary> Glasgow?
18:07:16 <yozora> :<
18:07:30 <Korollary> hmm, Cambridge research, right
18:07:42 <yozora> :)
18:07:46 <SyntaxNinja> Korollary: yeah. 
18:08:07 <Korollary> well, it's a 10 hour flight either way heh
18:08:29 <SyntaxNinja> historically they were at glasgow. now-a-days, ghc, nhc, and hugs masters are in england.
18:09:01 <Cale> SyntaxNinja: what exactly was it that you were thinking of doing?
18:09:02 <SyntaxNinja> well, the ghc guys were at glasgow, that is.
18:09:17 <yozora> @. vixen quote
18:09:18 <lambdabot> church is my favourite computer scientist.
18:09:19 <SyntaxNinja> Cale: somethign to do w/ cabal. at the time, GHC 6.4 was waiting on cabal to release.
18:09:35 <yozora> @. vixen quote
18:09:37 <lambdabot> what type of car do you drive?
18:10:57 <SyntaxNinja> gotta go!
18:11:19 <yozora> anyone know how to get a float into an ExpQ via something like lift?
18:22:37 <stepcut> yozora: maybe you just want [| 1.0 |] ?
18:23:27 <rep> dude CTM is fucking HUGE
18:23:48 <hula> n8
18:24:10 <yozora> i'm kind of looking for something that would take (sqrt 2)
18:24:17 <yozora> and give me the ExpQ of the result
18:24:28 <yozora> which is what lift does, I think
18:24:37 <yozora> but Float/Double isn't an instance
18:24:40 <benny> hm... yampa is some complicated shit
18:27:25 <Cale> yozora: did you read http://www.haskell.org/hawiki/TemplateHaskellTutorial by the way?
18:30:15 <yozora> bits of it, and a bit of the meta-haskell paper
18:30:28 <yozora> i was trying to learn syntax-case and then I thought I'd try Haskell again
18:30:40 <yozora> I have a feeling you can't create Float/Double expressions
18:32:23 <Cale> well, there aren't really float/double constants in Haskell
18:32:28 <yozora> I'd just like to have the warm fuzzy feeling that C++ can't do anything Haskell can't
18:32:50 <yozora> that's probably it, when I type in 2.3 it gets turned into a rational
18:32:55 <Cale> yes
18:33:05 <Cale> which is automatically generalised
18:33:37 <Cale> The floating point literal f is equivalent to fromRational (n Ratio.% d), where fromRational is a method in class Fractional and Ratio.% constructs a rational from two integers, as defined in the Ratio library. The integers n and d are chosen so that n/d = f.
18:33:56 <yozora> @type fromRational
18:33:58 <lambdabot> forall a. (Fractional a) => Rational -> a
18:34:10 <yozora> @type toRational
18:34:11 <lambdabot> forall a. (Real a) => a -> Rational
18:34:25 <yozora> so if I evaluate the sqrt then call toRational...
18:34:33 <Cale> yeah
18:35:26 <yozora> ahh!! take that C++!!
18:35:41 <yozora> thanks for that, Cale
18:35:45 <Cale> *Main> $(return $ LitE (RationalL (toRational (sqrt 2))))
18:35:45 <Cale> 1.4142135623730951
18:35:55 <yozora> that just made my day
18:36:42 <yozora> my ability to look down on C++ just increased :)
18:37:04 <Cale> hehe
18:40:22 <ForgeAus> C++ is clunky at times
18:40:23 <Korollary> that is a C++ library issue, tho
18:42:38 <yozora> I know that C++ uses templates to do parametric polymorphism and compile time metaprogramming,
18:43:06 <yozora> both of which Haskell can do much better, what else are they used for?
18:43:14 <Cale> Well, its type system looks klugey to me and its module system is nonexistent
18:43:54 <benny> namespaces :)
18:44:41 <Cale> okay, so they added namespaces, but it still relies on the C preprocessor to textually splice all your headers in.
18:46:34 <benny> i've never really seen that as a problem
18:46:40 <Cale> The object orientation seems a bit off too. Why not make everything an object? (at least abstractly) I think it suffers from trying to be too much like C.
18:46:52 <yozora> C++ uses templates to create namespaces??
18:46:58 <Cale> yozora: no
18:47:00 <benny> yozora: no
18:47:25 <Cale> It uses namespaces to create namespaces. I forgot about that because they were added after I stopped using C++.
18:47:47 <benny> Cale: not having everything as an object only has a few disadvantages
18:49:19 <Cale> benny: well, it can make lots of things rather nice actually. Have you looked at ruby, for example?
18:49:46 <benny> Cale: yeah, but C++ isn't supposed to be object oriented, it's supposed to be "multi paradigm" :)
18:49:49 <Cale> Ruby is a fairly nice example of a pure OO language, despite its lack of a type system
18:50:10 <Cale> C isn't a paradigm, it's a mess. :)
18:50:56 <Cale> I like the look of Objective C a lot more, though I haven't actually written anything in it.
18:52:04 <exsisonek> Obj-C is for application, C++ for system-heavy stuff, but C++ gets used for both...
18:57:02 <ForgeAus> Ruby's kinda itneresting
18:57:58 <benny> what about perl 6? it seems to have dozens of totally crazy cool features
18:58:00 <ForgeAus> Delphi is a nicer option imho, the code's more readable... 
18:58:26 <ForgeAus> I dunno much about Perl.. never really used it
18:58:36 <Cale> perl 6 has lots of neat looking features, many of them taken from Haskell, but it's still perl :)
18:58:49 <ForgeAus> Cale Perlskell?
18:58:57 <yozora> @seen autrijus
18:58:58 <lambdabot> autrijus has changed nick to audreyt.
18:58:58 <lambdabot> audreyt is in #haskell and #haskell-blah. Last spoke 7 hours, 14 minutes
18:58:58 <lambdabot> and 12 seconds ago.
18:59:01 <ForgeAus> or Hasperl?
18:59:14 <ForgeAus> what about Lua?
18:59:19 <Cale> http://www.dcs.gla.ac.uk/~partain/haskerl.html
19:01:47 <ForgeAus> I wish Visual Python for Visual Studio had IDE support (like as in System.Windows.Forms.Form functionality etc)
19:02:43 <ForgeAus> but its been pretty much discontinued
19:03:12 <Cale> Is there a glade binding for python?
19:03:36 <benny> Cale: pretty sure there is
19:04:20 <Cale> yep
19:04:30 <Cale> there's even a code generator
19:05:07 <Cale> so that ought to work well
19:05:55 <ForgeAus> theres also stuff like wxPython, etc..
19:06:03 <ForgeAus> or is it xwPython.. whatever...
19:06:38 <Cale> wx
19:07:32 <Cale> but Glade will give you the nice interface builder if that's what you're looking for
19:07:33 <ForgeAus> I think Boo is a better solution tho
19:07:56 <ForgeAus> (Python for #Develop basically)
19:08:44 <benny> Boo is cool, but it's pretty expirimental
19:09:07 <ForgeAus> yeah
19:09:44 <ForgeAus> I hope Microsoft take up Python, and add it to Visual Studio I heard some of the bigwigs over there really like it.. 
19:10:02 <benny> microsoft really likes haskell =]
19:10:10 <ForgeAus> awesome too :)
19:10:28 <ForgeAus> which might leave something like Ruby out in the cold?
19:10:46 <Cale> Well, both the Simons are working for MS
19:11:43 <benny> what i don't get is why MS employs them.... they don't seem to be contributing to any profit
19:11:58 <Cale> Actually, I kind of fear the popularity of Haskell. Haskell becoming popular makes it more resistant to change.
19:12:02 <benny> 99% of MS research doesn't seem to help MS in any way
19:12:20 <benny> "avoid success at all costs"
19:12:53 <yozora> C# seems to be heading more in a functional direction than Java
19:12:56 <ForgeAus> XAM or was it XUL or whatever, that next gen (DirectX++??) proggy might be interesting, they said they firmly believe the next revoltion in computing will be in software... 
19:12:58 <Cale> On the other hand, it's so obviously better than most of the junk that people use :)
19:13:22 <Cale> XUL is Mozilla
19:13:33 <Cale> XAML, I think was MS' thing
19:13:38 <ForgeAus> lol its got an X in it anyway
19:13:39 <benny> ForgeAus: the name you are thinking of is XAML, but the "technology" you are thinking of is avalon
19:13:52 <monochrom> Too many X*L out there.
19:13:52 <ForgeAus> nah XAML is a markup kinda thing isn't it?
19:14:18 <ForgeAus> nah I'm talking about some Gamer kinda thing X something... I think its related to XAML tho.. 
19:14:22 <benny> java is a horrible language imho
19:14:23 <Cale> XML is way overhyped
19:14:53 <Cale> benny: You won't find any disagreement with that here :)
19:15:20 <ForgeAus> Java is very similar to C++ most people say... 
19:15:25 <Saulzar> It serves it's purpose...
19:15:32 <gzl> I think the next generation DirectX thing is XGN.
19:15:32 <Cale> I think they're both terrible :)
19:15:32 <ForgeAus> and its quite popular
19:15:36 <benny> Java is C++ with 90% of the features shaved off
19:15:52 <benny> and the only feature added pretty much is reflection
19:15:59 <ForgeAus> XGN? hmm ok... doesn't ring a bell but possibly..
19:16:07 <exsisonek> mbot request in #math...
19:16:14 <Saulzar> I'm sure the next generation graphics stuff won't change much, maybe it will be more integrated in your average gui 
19:16:16 <monochrom> Also dynamic typing.
19:16:18 <Korollary> 90% is a tad high
19:16:37 <monochrom> err I guess reflection includes dynamic typing.
19:16:41 <ForgeAus> I knew it was 3 letters that started with X anyway.. 
19:16:45 <gzl> oh no
19:16:47 <gzl> it's XNA
19:16:49 <ForgeAus> thats it!
19:16:50 <gzl> haha
19:16:51 <ForgeAus> SNA!
19:16:53 <monochrom> Too many X?? out there.
19:16:54 <ForgeAus> grrXNA
19:16:54 <gzl> no, XNA.
19:17:00 <ForgeAus> yeah typo
19:17:03 <Korollary> X is the coolest letter one can have in a TLA
19:17:13 <Korollary> if your TLA doesn't have an X, I pity you
19:17:19 <ForgeAus> true, but I like Z only hard to make a TLA with a Z
19:17:25 <monochrom> XXX will be way cool, then.
19:17:26 <benny> C++ is ugly and messy and verbose and maybe isn't based on some kind of theory, but it is very powerful
19:17:32 <ForgeAus> lol monochrom :)
19:17:34 <Korollary> ForgeAus: ZIF for Zero Insertion Force
19:18:25 <ForgeAus> XZF Exclusively Zero Funds! :)
19:18:31 <gzl> monochrom: XXX has already made it bigger than any of the others ever will.
19:18:42 <Korollary> isn't it a domain now?
19:18:49 <gzl> I think they killed that idea at some point
19:18:51 <Korollary> we should get haskell.xxx
19:18:53 <Korollary> ah
19:18:57 <ForgeAus> lol
19:19:03 <monochrom> *cringe*
19:19:05 <ForgeAus> you mean titskel? 
19:19:29 <Korollary> a very poor idea for a top level domain. How about *.crim for all the criminal organizations?
19:19:31 <exsisonek> heh now with tits and haskell
19:20:06 <monochrom> Oleg's haskell code site should go to haskell.xxx
19:20:12 <Korollary> hah
19:20:16 <ForgeAus> yeah I wonder why I havn't heard of any xxx.<insert company>.com
19:20:16 <Korollary> Oleg rocks, tho
19:20:25 <ForgeAus> or www.<insert company>.xxx sites
19:20:29 <Cale> xxx.lanl.gov
19:20:38 <Saulzar> Have you tried xxx.microsoft.com?
19:20:42 <ForgeAus> no
19:20:58 <ForgeAus> but I guess I'm about to
19:21:15 * ForgeAus braces for impact! lol
19:21:19 <monochrom> Doesn't exist.
19:21:22 <ForgeAus> The requested URL could not be retrieved
19:21:26 <Korollary> %*&#^%$%#.vista.com maybe
19:21:43 <ForgeAus> are those legal characters in an URL?
19:21:45 <Saulzar> Isn't that what you get in the first 10 searches at altavista.com anyway?
19:21:47 <ForgeAus> I doubt it
19:22:01 <ForgeAus> lol Saulzar, most likely
19:22:12 <Korollary> altavista is a search engine? How 1990's...
19:22:22 <ForgeAus> I think he meant astalavista
19:22:26 <monochrom> Why does %*&#^%$%#.vista.com bring me to Barnes & Noble?
19:22:32 <ForgeAus> rofl!
19:22:34 <Korollary> ???
19:22:46 <ForgeAus> or just some box.sk site or something
19:22:49 <Korollary> ah, firefox
19:22:54 <Korollary> defaults to first google hit
19:23:01 <Korollary> but why is that the 1st hit
19:23:01 <monochrom> Damn.
19:23:08 <ForgeAus> actually I like altavista.... its passe but used to be my fav search engine at one point
19:23:21 <Korollary> it's not, actually.
19:23:32 <Korollary> why bn.com is beyond me...
19:24:20 <Korollary> teh intarweb is amazing
19:39:13 <ForgeAus> I might try eclipse
19:39:28 <ForgeAus> pydev can be plugged into it, hmmm is there haskell for eclipse?
19:39:38 <Korollary> I think so
19:39:49 <Korollary> eclipse-fp or something
19:40:18 <ForgeAus> its funny I came across PyDev by looking for Glade! rofl... somehow
19:49:53 <benny> does ghc 6.4.1 have arrow syntax built in?
19:51:13 <Saulzar> Yes
19:51:34 <benny> Saulzar: cool, do you remember which was the first ghc version that supported this?
19:51:47 <Saulzar> No idea, I've never used it before 6.4.1 :)
19:53:47 <Saulzar> Blargh - mutually recursive data types are extremely annoying. I'm finding that I have a bunch of data structures which refer to each other, and the only thing I can do is stack them all into one module - is there some way around this?
19:55:34 <Saulzar> I've looked at the .hs-boot stuff from GHC, but that still doesn't seem to help if the data structures themselves are inter-dependant
19:56:15 <Pupeno> @lastseen pupeno
19:56:15 <lambdabot> Unknown command, try @listcommands.
19:56:22 <Pupeno> @listcommands
19:56:23 <lambdabot> use listcommands [module|command]. Modules are:
19:56:23 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
19:56:23 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
19:56:23 <lambdabot> seen spell state system todo topic type version vixen where
19:56:50 <Pupeno> @listcommands seen
19:56:51 <lambdabot> seen provides: seen
19:56:57 <Pupeno> @seen musasabi 
19:56:57 <lambdabot> musasabi is in #flippi, #haskell-overflow, #haskell-blah and #haskell.
19:56:57 <lambdabot> Last spoke 2 hours, 37 minutes and 27 seconds ago.
20:41:59 <CosmicRay> is there any tool to count non-comment, non-whitespace lines of code in a haskell program?
20:46:36 <Lemmih> sloccount?
20:50:19 <CosmicRay> ah, good.
20:56:40 <CosmicRay> whee.
20:56:43 <CosmicRay> hdbc-postgresql is out.
20:56:59 <Cale> CosmicRay: yeah, saw that :)
20:57:21 <Cale> all these hdbc releases make me want to try writing a database app of some kind
20:59:54 <CosmicRay> :-)
21:00:02 <CosmicRay> they might slow down a bit until next week
21:00:10 <CosmicRay> I hope to get mysql and odbc bindings out then
21:00:14 <CosmicRay> and a missingh integration package
21:06:44 <Cale> :)
21:07:16 <CosmicRay> Cale: have you ever used sqlite?
21:07:56 <Cale> no, I've only used MySql for a search engine I wrote with a friend of mine at one point.
21:08:27 <Cale> I had a brief look at postgresql, but I didn't actually apply it to anything
21:08:31 <CosmicRay> sqlite is a local sql engine.  It's entirely contained in a .so and uses a single on-disk file.
21:08:39 <Cale> ah, cool
21:08:41 <CosmicRay> it is faster than any dbm engine I know of
21:08:47 <CosmicRay> and also smaller than some of them
21:08:50 <CosmicRay> very slick.
21:09:04 <Cale> yeah, it sounds nice
21:09:26 * benny likes postgres
21:10:05 <CosmicRay> me too.
21:10:10 <CosmicRay> I've been using it for quite a few years.
21:10:19 <CosmicRay> since the sql version of postgres first came out, I think.
21:10:31 <CosmicRay> back before mysql existed ;-)
21:12:06 <CosmicRay> I'm still mystified about why mysql is so much more popular.
21:12:20 <CosmicRay> I mean, it just now got support for transactions.
21:13:59 <Cale> Postgres seemed a bit harder to set up initially than I remember mysql being, though I managed okay.
21:14:23 <CosmicRay> I guess it's been awhile since I've tried either one on anything except debian, where both install in about 10 seconds with apt-get ;-)
21:14:57 <Cale> Oh, I'm on Debian too, but after they're installed, you still have to configure them.
21:15:05 <CosmicRay> yeah
21:15:12 <Pupeno> CosmicRay: marketing, both socially and technologicall (with MySQL it is just easier to start). Besides, MySQL used to be the fastest one.
21:15:49 <CosmicRay> I'm certain Mysql is still faster out of the box, though after 30 seconds of telling postgresql to use the same amount of ram for cache, it's a much closer race
21:16:20 <CosmicRay> sorta like all these reiserfs fans think ext3 sucks, but if you tell ext3 to stop flushing all its buffers every 5 seconds, things get a lot closer ;-)
21:16:56 <CosmicRay> but anyway, marketing is probably true.
21:17:01 <CosmicRay> postgresql doesn't have a company behind it.
21:18:53 <Pupeno> CosmicRay: for companies MySQL tend to be the solution because there's a company backing it up (people still don't understand that anyone can backup PostgreSQL and that there are companies doing it). And today, with the momentum, everyone uses MySQL because everybody else uses it as wall (that is the reason where I work, same for languages, they use PHP).
21:20:20 <benny> <wired into compiler>
21:22:48 <Pupeno> lisppaste2: url
21:22:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:23:13 <lisppaste2> Pupeno pasted "A better way ?" at http://paste.lisp.org/display/14965
21:23:17 <Pupeno> Is there a better way to write that ?
21:23:48 <CosmicRay> well, first off you're ignoring the Nothing case, yes?
21:24:13 <CosmicRay> I think there is a forceMaybe or something in Data.Maybe these days
21:24:19 <CosmicRay> that will raise an exception if you got Nothing
21:24:34 <stepcut> I think postgresQL used to have some serious large scale performance issues of few years ago, so people had to use MySQL despite its lack of features and wacky quirks
21:24:49 <stepcut> and now they are tied to mysql 
21:24:52 <Pupeno> When I get Nothing, I don't need to do anything. I am ignoring because that is what I want.
21:25:03 <stepcut> atleast that is what happened where I work :p
21:25:37 <CosmicRay> Pupeno: you will get an exception at runtime
21:25:45 <CosmicRay> something about incomplete pattern
21:25:53 <CosmicRay> heh
21:25:57 <CosmicRay> anyway time to run
21:26:05 <Pupeno> stepcut: I keep myself telling people to use cross-db wrappers, they keep doing it otherwise to not depend on another lib, or just not to have to learn another language, etc.
21:26:13 <Pupeno> How do I do it then ?
21:27:01 <Pupeno> another API I mean.
21:29:26 <benny> hm... i found some doc that has code:        \() -> constant 0
21:29:35 <benny> shouldn't that be:        \_ -> constant 0
21:29:37 <benny> ?
21:30:09 <Saulzar> I guess it doesn't matter especially..
21:30:21 <benny> are both forms totally identical?
21:30:26 <benny> i didn't think that () would work actually
21:30:27 <Saulzar> () will match (),  _ will match anything...
21:30:41 <benny> ah, ok now i get it thanks
21:30:55 <benny> () still confuses me
21:31:06 <benny> it's a value and a type
21:31:07 <stepcut> () rocks
21:31:09 <Saulzar> It's a tuple with no elements
21:31:22 <benny> hm..... now i am even more confused :(
21:31:37 <Saulzar> Just like (Int)  is a type and (0) is a value,  ()  is the type and () is a value
21:31:43 <stepcut> Benny: it is easy for something to be a type and a vaue --> data MyType = MyType
21:31:50 <benny> stepcut: yeah...
21:31:59 <benny> stepcut: that's excatly what () is: data () = ()    -- <wired into compiler>
21:31:59 <stepcut> data () = ()
22:06:13 <benny> what is fmap?
22:07:46 <skew> fmap f :: (F a) -> (F b) changes all the a's in the argument to b's by applying f (of type a -> b), for any functor F
22:07:52 <skew> it's a method of class Functor
22:08:13 <skew> like, fmap not (Just True) -> Just False, fmap (+1) [1,2,3] -> [2,3,4]
22:08:39 <skew> If you know category theory, it's the action of the functor on morphisms
22:09:25 * benny cries
22:10:55 <benny> what's a Functor?
22:11:07 <skew> Functor is a typeclass, and fmap is its method
22:11:45 <benny> what is special about types that are Functor types?
22:14:03 <Korollary> nothing
22:14:15 <Korollary> Functor is a typeclass like other typeclasses
22:16:10 <skew> for F to be a type constructor, it just needs this fmap function :: (a -> b) -> (F a -> F b), and fmap id has to be the identity function on any F a
22:16:32 <benny> hm... i mean: what does Functor mean?
22:16:32 <benny> hm... i guess i don't really need to know right now actually
22:47:17 <Saulzar> benny, I think it is just a structure which can be mapped over... 
22:47:40 <benny> ok makes sense i guess :)
22:50:48 <Saulzar> So I guess it is a kind of container
23:07:27 <benny> anyone familiar with yampa?
23:08:09 <skew> not really, but I could pretend
23:08:27 <skew> I know the basic ideas, but I haven't worked with it
23:09:44 <benny> yampa source adds some more arrow combinators, ^>> >>^ ^<< <<^ these seem to already be in the standard Arrow module though
23:10:09 <benny> i guess ghc thought they were useful and added them :) i just want to make sure that they are the same before i remove them from the yampa source
23:10:27 <skew> well, that depends how they are defined in yampa
23:10:37 <skew> does it use the Arrow class that's now in the GHC library?
23:11:18 <benny> yeah
23:11:43 <benny> too bad ghci doesn't show me the definition of functions
23:12:29 <skew> do you have a copy of of the library source?
23:12:51 <benny> no, it came part of ghc
23:13:04 <benny> they gotta be the same though
23:13:17 <skew> you can get the source to ghc
23:17:03 <skew> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Control/Arrow.hs?rev=1.8.2.1;content-type=text%2Fplain
23:17:23 <benny> hm... any unix people here... how do i grep for "^>>" string?
23:18:12 <skew> that's the url to the source for Control.Arrow.hs
23:18:28 <skew> '
23:18:31 <skew> '\^>>
23:18:42 <skew> '\^>>' for grep
23:19:17 <skew> '\' so grep doesn't think ^ means "start of line", and the quotes so the shell doesn't think the >> is trying to redirect the output
23:19:44 <benny> thanks, found it!
23:20:38 <benny> yes, they are identical
23:25:58 <benny> alright, compiled and installed the sucker, but can't figure out how to import it
23:28:09 <skew> what are you trying?
23:30:26 <skew> wow, the readme says it was tested against GHC 5.02.2
23:32:30 <skew> what source are you working on?
23:33:02 <skew> I grabbed the 0.9.1 bundle, but it's not building trivially
23:34:01 <benny> i got Yampa Core
23:34:19 <benny> built with no problems except for those few arrow functions i had to comment out
23:36:33 <benny> are you gonna give it a try?
23:42:22 <skew> I'm trying
23:42:24 <benny> i think the problem is that yampa hasn't been registered with ghc-pkg
23:42:30 <benny> cool :)
23:42:42 <skew> the makefile for the test just adds ../src to the search path
23:43:01 <benny> i didn't build the tests
23:43:13 <benny> i copied config-linux-local.mk to config.mk
23:43:36 <benny> then ran make, then when it gave me the errors about ^>> i commented those lines out in the source, continued the make and it succeeded
23:47:52 <skew> it looks like it install into /usr/local/lib/ghc, and my ghc lib directory is /usr/lib/ghc-6.4
23:49:34 <benny> yeah, installed there for me too, but my ghc directory is /usr/local/lib/ghc-6.4.1
23:49:48 <benny> the good news is that all the tests compile and succeed :)
23:51:48 <Tweakee> back (stupid ISP died on me for a few hours :( )
23:52:13 <ForgeAus> which also killed my Eclipse d/l :(
23:53:07 <skew> you should have used bittorrent
