00:00:28 <jethr0> well, the damn language.haskell.pretty isn't that configurable :(
00:00:29 <xerox>    | <..> = <..> -- then, etc
00:00:37 <xerox> Oh.
00:01:07 <jethr0> $pretty fun 0 = 1; fun 1 = 1; fun n = fun (n-1) + fun (n-2)
00:01:07 <jethr0_bot> fun 0 = 1
00:01:07 <jethr0_bot> fun 1 = 1
00:01:07 <jethr0_bot> fun n = fun (n - 1) + fun (n - 2)
00:01:13 <jethr0> better?
00:01:31 <ProfTeggy> pretty!
00:02:06 <jethr0> xerox, but even for the guards, the multiline version is more readable... although admittedly far from perfect
00:02:17 <xerox> jethr0: blech!
00:03:11 <xerox> abs x | x >= 0    =  x
00:03:12 <xerox>       | otherwise = -x
00:03:16 <xerox> ^_^
00:03:22 * jethr0 can't handle xerox's disapproval of his first plugin :)
00:04:14 <xerox> I'm sorry, but I really love well-indented code :-)
00:04:16 <jethr0> and the worst part is that multiple lets are also not aligned :(
00:04:19 <araujo> @index openFile
00:04:20 <lambdabot> System.IO
00:04:51 <jethr0> $pretty let fun 0 = 1; fun 1 = 1; fun n = fun (n-1) + fun (n-2) in fun 3
00:04:51 <jethr0_bot> i = let fun 0 = 1
00:04:51 <jethr0_bot>    fun 1 = 1
00:04:51 <jethr0_bot>    fun n = fun (n - 1) + fun (n - 2)
00:04:51 <jethr0_bot>   in fun 3
00:04:54 <jethr0> :(
00:05:15 <flux__> $not_pretty ;(
00:05:16 <jethr0_bot> Unknown command, try @listcommands.
00:05:16 <jethr0> xerox, me too, but seemingly it's not so easy a task for the so-called pretty printer
00:05:35 <jethr0> i guess i'll have to look for an alternative!
00:05:40 <xerox> ...or its internals?
00:05:47 <jethr0> hmm
00:06:47 <jethr0> now i'm depressed
00:09:17 <lispy> jethr0: i started my new job and they already have me wrting VB code :(
00:09:27 <lispy> beat that for depressed! :)
00:09:40 <jethr0> that's pretty harsh
00:10:09 <lispy> well, it's better than being asked to go count traffic at 7am, which is what they asked me to do on wednesday
00:10:19 <lispy> i was like *pout*
00:10:38 <lispy> it's NEW JOB, I'm supposed to be EXCITED about the NEW assignemst
00:10:44 <lispy> at least it's part time i guess
00:12:40 <jethr0> what kinda work is it? end user gui applications?
00:13:23 <lispy> jethr0: ya
00:13:42 <Cale> count traffic?
00:13:44 <lispy> oddly enough, i'm writing code to parse files
00:13:49 <lispy> Cale: yeah, that's what i said
00:13:59 <Cale> as in, street traffic?
00:14:04 <lispy> parsing in VB is like weird
00:14:06 <lispy> Cale: yeah
00:14:13 <lispy> Cale: at an intersection, for 4 hours
00:14:20 <Cale> what purpose could that possibly serve?
00:14:24 <Cale> wtf?
00:14:36 <Cale> Is that some kind of punishment?
00:14:51 <lispy> Cale: well, i guess they're doing it for a client
00:14:59 <Cale> odd
00:15:03 <lispy> Cale: the client needs the traffic data for their traffic simulation
00:15:09 <Cale> ah, okay
00:15:13 <lispy> my company does do traffic simulation software
00:15:14 <Cale> still, that's crazy
00:15:24 <lispy> yeah
00:15:35 <Cale> don't they have devices which you can place across the road for that?
00:15:38 <lispy> i don't have a car and the intersection is about 8 miles from my home
00:16:00 <lispy> Cale: yes, but this is a very ad-hoc measurement
00:16:20 <tuomov> hehe. day well spend getting some excercise going there and immediately back :)
00:16:26 <lispy> i thought i would have a car to borrow, but i dont.  so maybe i can get out of it by playing the "no car" card
00:16:43 <lispy> tuomov: no kidding
00:16:53 <Cale> Or by playing the "completely random number" card
00:16:58 <lispy> "You know how early i'd have to get up to get there by 7am??"
00:17:14 <Cale> It's not like it's going to be independently confirmed
00:17:24 <lispy> Cale: hehe, go to the library, look up the historical data :)
00:17:44 <lispy> "oh yeah, those numbers took me 4 hours"
00:18:08 <lispy> "four hours of counter-strike....er i mean, counting traffic"
00:18:25 <Cale> hehe
00:18:50 <lispy> well,i gotta crash
00:18:53 <lispy> night all
00:19:00 <jethr0> nite
00:19:03 <Cale> night
00:29:46 * araujo loooks in
00:42:34 <Gs30ng> damn hard to access to an element of a list of a list and replacing it
00:43:08 <Gs30ng> like, [[1,2,3],[4,5,6],[7,8,9]] to [[1,2,3],[4,0,6],[7,8,9]]
00:43:35 <xerox> > transpose [[1,2,3],[4,5,6],[7,8,9]]
00:43:36 <lambdabot> [[1,4,7],[2,5,8],[3,6,9]]
00:43:47 <xerox> Ah, replacing?
00:44:23 <Gs30ng> i got the original list, and m, n in `m-th element of n-th list'
00:44:31 <xerox> Gs30ng: when you're trying to do this kind of thing, it's sign that you have to either re-think the algorithm, or change your data structure.
00:44:50 <musasabi> replaceNth :: Int -> a -> [a] -> [a]; replaceNth 0 x (_:xs) = x:xs; replaceNth k x (_:xs) = replaceNth (k-1) x xs
00:44:53 <Gs30ng> you're probably right
00:44:57 <musasabi> or take + drop
00:45:04 * xerox pokes musasabi
00:45:12 <musasabi> hello xerox 
00:45:46 <Gs30ng> xerox, i got a 2-dimensional plane board
00:45:56 <Gs30ng> it's like chess board. x-cells and y-cells
00:46:10 <xerox> Oh!
00:46:21 <xerox> You can use an Array, with (Int,Int) indexes!
00:46:58 <Gs30ng> and i also have a string from which i should make this board
00:47:11 <Gs30ng> like, from "123\n456\n789"
00:47:45 <Gs30ng> 1 = (0, 0), 2 = (1, 0)
00:47:53 <Gs30ng> 4 = (0, 1)
00:47:58 <Gs30ng> and so on
00:52:47 <xerox> It's doable.
00:53:43 <Gs30ng> i'm looking up my haskell98 library reference. anyway thanks very much, xerox
00:54:36 <xerox> You're welcome :-)
00:56:38 <jethr0> ok, gotta go to bed too. nite everyone
00:57:09 <xerox> Goodnight!
01:05:35 <xerox> All the pair of natural numbers which sum to a given number n:
01:06:05 <xerox> > let f n = transpose [[0..n],[n,n-1..0]] in (f 0,f 2,f 4)
01:06:06 <lambdabot> ([[0,0]],[[0,2],[1,1],[2,0]],[[0,4],[1,3],[2,2],[3,1],[4,0]])
01:33:48 <JoshTriplett> Given a type "a", what is the appropriate way to obtain a "Ptr a" in an IO scope?  I found malloc and alloca from MarshalAlloc, but I don't really want to allocate new memory to hold the item, just get the pointer to the existing item.
01:34:14 <JoshTriplett> Or is that not possible?
01:34:21 <ibid> JoshTriplett: where do you get the item a?
01:34:33 <JoshTriplett> ibid: Function parameter.
01:34:42 <ibid> i suspect it's not possible without copying
01:35:19 <JoshTriplett> Doh; I just realized the reason.  If I could pass around a pointer to the original object, it could be changed without Haskell knowing.
01:35:25 <JoshTriplett> Which I don't actually want.
01:35:34 <JoshTriplett> ibid: Thanks. :)
01:35:38 <ibid> not copying is just a performance hack, because there's no guarantee that the a you get is the same underlying object as the one you're passed
01:36:16 <ibid> JoshTriplett: in my short experience, in cases where you think you need that, you probably actually need to pass in a Ptr a in the first place :)
01:36:34 <JoshTriplett> ibid: Right.  And I don't actually want the original to be modified.
01:36:37 <ibid> (and are just confused because of the mixing of the imperative and functional paradigms)
01:37:44 <JoshTriplett> Yeah, interfacing to foreign code is *interesting*. :)
01:37:51 * ibid is preparing a lecture on functional programming in Java, writing a LazyList class. it's trickier than i first thought
01:38:41 * JoshTriplett is trying to figure out how to design a data-centric architecture based on lazy lists, which works across several language boundaries including haskell and C. :)
01:39:17 <JoshTriplett> I want to design a system as a series of transformations on lazy lists, but I want to implement some of those transformations in haskell, some in C, possibly some in other languages.
01:41:15 <araujo> mmm.....
01:45:44 <dcoutts> JoshTriplett, in C or other languages your lazy lists could be represented as iterators
01:46:05 <dcoutts> JoshTriplett, so that's what you wanted unsafeInterleaveIO for yesterday.
01:46:08 <dcoutts> neat.
01:46:32 <JoshTriplett> dcoutts: It gets better; the data-centric architecture in question is for a GNU/Linux based flight computer for a rocket. :)
01:46:43 <dcoutts> cool!
01:46:46 <dcoutts> I'm sure you could create an FFI interface for lazy Haskell lists
01:46:57 * JoshTriplett is pondering that idea.
01:47:00 <dcoutts> something that exposes a lazy Haskell list as a C iterator
01:47:35 <dcoutts> in C you'd keep a stable pointer to the list head
01:48:05 <dcoutts> then call Haskell functions via the FFI to ask if the list is empty and advance to the next element
01:48:38 <JoshTriplett> dcoutts: Exactly.
01:48:44 <dcoutts> ie you export your special null, head, tail functions to C by foreign export
01:49:01 <dcoutts> JoshTriplett, you know about 'StablePtr's ?
01:49:03 <JoshTriplett> dcoutts: And then create a C wrapper which makes the resulting Haskell component look just like the components implemented in C.
01:49:10 <dcoutts> right
01:49:18 <dcoutts> sounds fun
01:49:28 <JoshTriplett> dcoutts: A bit, but I'd appreciate any insight you might be able to supply. :)
01:50:00 <JoshTriplett> dcoutts: AFAICT, they're just a pointer which will stay in one place and not disappear, so C can use it.
01:51:21 <dcoutts> right, and they can point to a Haskell value of any type
01:51:31 <dcoutts> including delayed thunks
01:51:33 <JoshTriplett> dcoutts: So C would use the StablePtr as an opaque handle for a given list?
01:51:38 <dcoutts> right
01:51:59 <dcoutts> or at least your wrapper scruct would contain a StablePtr
01:52:16 <xerox> ...so, GHC is going to FLY?
01:53:01 <dcoutts> JoshTriplett, I've got some example code for you...
01:53:18 <JoshTriplett> dcoutts: That would be awesome.
01:53:22 <JoshTriplett> xerox: It may well. :)
01:53:47 <dcoutts> http://cvs.sourceforge.net/viewcvs.py/gtk2hs/gtk2hs/gtk/Graphics/UI/Gtk/TreeList/Gtk2HsStore.h?rev=1.1&view=auto
01:53:54 <dcoutts> http://cvs.sourceforge.net/viewcvs.py/gtk2hs/gtk2hs/gtk/Graphics/UI/Gtk/TreeList/Gtk2HsStore.c?rev=1.1&view=auto
01:54:07 <dcoutts> that's the C parts, and the Haskell parts...
01:54:14 <Gs30ng> what is index type? i don't see any type named index, so probably it's an abstract notion applys on several types, and i can't catch it
01:54:18 <dcoutts> http://cvs.sourceforge.net/viewcvs.py/gtk2hs/gtk2hs/gtk/Graphics/UI/Gtk/TreeList/CustomStore.chs?rev=1.1&view=auto
01:54:31 <dcoutts> JoshTriplett, so that's a thing from Gtk2Hs.
01:54:45 <Gs30ng> or is it another name of type Ix?
01:55:03 <dcoutts> JoshTriplett, it's an implementation of a C interface that delegates all the methods to Haskell functions.
01:55:24 <ski> Ix is a type class
01:55:42 <dcoutts> JoshTriplett, so the C implementation holds an HsStablePtr to a Haskell record of functions which implement the methods of the interface.
01:55:49 <ski> @type (Data.Array.!)
01:55:50 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
01:56:00 <dcoutts> JoshTriplett, then for each method we call an exported Haskell function with the StablePtr
01:56:39 <dcoutts> JoshTriplett, on the Haskell side we dereference the StablePtr to get the record of functions and then we de-marshal the parameters and call the appropriate function.
01:57:04 <JoshTriplett> dcoutts: That code is very enlightening. :)
01:57:26 <dcoutts> JoshTriplett, so you see in the .h file we've got struct _Gtk2HsStore with a HsStablePtr     impl; member.
01:57:32 <JoshTriplett> dcoutts: Right.
01:58:08 <dcoutts> then in the .c file look at a simple one like gtk2hs_store_get_flags 
01:58:18 <dcoutts> it calls:
01:58:19 <dcoutts> gtk2hs_store_get_flags_impl(store->impl);
01:58:40 <dcoutts> where gtk2hs_store_get_flags_impl is the exported name of a Haskell foriegn export
01:58:40 * JoshTriplett is reminded of callback interfaces in C, which let you supply a void * to be passed along to the callback so it can find its data.
01:58:51 <JoshTriplett> Almost identical, with s/void */StablePtr/
01:58:54 <dcoutts> right
01:59:31 <dcoutts> and you've got to be similarly careful to use the StablePtr at the right type
01:59:47 <dcoutts> (like making sure you cast the void * to the right thing in C)
02:00:10 <JoshTriplett> dcoutts: Right, since otherwise you could easily use StablePtr and a C callback to implement coerce :: a -> b
02:00:20 <dcoutts> right
02:00:49 <dcoutts> because when you go via C you loose the type parameter of the StablePtr
02:01:15 <dcoutts> JoshTriplett, so then in the .chs file we've got customStoreGetFlags_static
02:01:20 <dcoutts> customStoreGetFlags_static storePtr = do
02:01:20 <dcoutts>   store <- deRefStablePtr storePtr
02:01:20 <dcoutts>   liftM (fromIntegral . fromFlags) $ customStoreGetFlags store
02:01:20 <dcoutts> foreign export ccall "gtk2hs_store_get_flags_impl"
02:01:20 <dcoutts>   customStoreGetFlags_static :: StablePtr CustomStore -> IO CInt
02:01:33 <dcoutts> so there's the name of the foreign export again
02:01:40 <JoshTriplett> What exactly is a .chs file?
02:02:06 <dcoutts> it's a .hs file with extra foriegn annotations which are processed by the c2hs FFI tool.
02:02:19 <JoshTriplett> Ah.
02:02:20 <dcoutts> c2hs turns .chs files into .hs files
02:02:24 <dcoutts> @where c2hs
02:02:24 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
02:02:52 <araujo> Gs30ng, check out:
02:03:02 <dcoutts> though actually I noice that I'm not really usign any c2hs hooks in that file at the moment
02:03:08 <araujo> > let row 0 j n (x:xs) = col j n x : xs where { col 0 n (x:xs) = n : xs ; col (j + 1) n (x:xs) = x : col j n xs } ; row (i + 1) j n (x:xs) = x : row i j n xs in row 2 1 89 [[1,3,5,7] , [2,3,4,5] , [3,4,56,6]]
02:03:09 <lambdabot> [[1,3,5,7],[2,3,4,5],[3,89,56,6]]
02:03:10 <xerox> Gs30ng: it is the Ix one
02:03:19 <xerox> araujo: ?!
02:03:24 <xerox> @docs Data.Array
02:03:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
02:03:39 <araujo> xerox, That _is_ not FuN!
02:03:41 <araujo> :-]
02:03:58 <xerox> Err?
02:05:26 <JoshTriplett> dcoutts: Thanks for all the help; I'll be sure to come back and show you the result when I get it working.
02:05:37 <dcoutts> cool
02:06:28 <araujo> xerox, thought that was what Gs30ng wanted anyway......
02:06:35 <xerox> araujo: brrr.
02:07:56 <araujo> haha
02:08:03 * araujo boings
02:08:10 <Gs30ng> that works
02:08:19 <Gs30ng> but i'd rather do it with array
02:08:46 <xerox> > Data.Array.indices $ Data.Array.listArray ((0,0),(1,1)) "abcd"
02:08:47 <lambdabot>  Not in scope: `Data.Array.listArray'
02:08:56 <Gs30ng> although i can't understand the standard document of array -_- too difficult english for me
02:09:19 <xerox> @type Data.Array.fomList
02:09:20 <lambdabot> Not in scope: `Data.Array.fomList'
02:09:22 <xerox> @type Data.Array.fromList
02:09:22 <lambdabot> Not in scope: `Data.Array.fromList'
02:09:27 <xerox> @type Data.Array.listArray
02:09:28 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
02:11:14 <xerox> > Data.Array.indices $ Data.Array.array ((0,0),(1,1)) [((x,y),k) | x <- [0,1], y <- [0,1], k <- "!"]
02:11:14 <lambdabot>  Not in scope: `Data.Array.array'
02:11:43 <xerox> Hm.
02:12:19 <araujo> See... that's too difficult :-P
02:12:33 <xerox> Nah.
02:14:45 <xerox> Prelude Data.Array> indices $ array ((0,0),(1,1)) [((x,y),k) | x <- [0,1], y <- [0,1], k <- "!"]
02:14:48 <xerox> [(0,0),(0,1),(1,0),(1,1)]
02:14:50 <xerox> It does work here.
02:15:47 <xerox> > elems $ array ((0,0),(1,1)) [((x,y),k) | x <- [0,1], y <- [0,1], k <- "!"] // [((1,0),'?')]
02:15:48 <lambdabot>  Not in scope: `//'
02:15:50 <xerox> "!!?!"
02:18:06 <araujo> :-P
02:18:11 * araujo off to breakfast
02:24:56 <xerox> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 9311
02:24:57 <lambdabot> 553886787615547023306799183971084730239839191799372049520816840830386364104
02:24:57 <lambdabot> 657648041032887203785017165245790432905069671403970509298911357951501142497
02:24:57 <lambdabot> 954402583689850377400889207087579678279728868394234630126634215407713140909
02:24:57 <lambdabot> 068111862324236416119804127176948032528135559901267357921454013011431380392
02:24:57 <lambdabot> 037892298242867506689729368242331813954969855043656280469253372325016707976
02:24:59 <lambdabot> [21 @more lines]
02:25:02 <xerox> ^- √prime
02:26:08 <tromp_> let recurrence basis coeff n = a!n where
02:26:08 <tromp_>  order = length basis
02:26:08 <tromp_>  a = array (0,max order n) (zip [0..order-1] basis ++
02:26:08 <tromp_>      [(i,sum (zipWith (\j -> (* a!(i-j))) [1..order] coeff)) | i<-[order..n]])
02:26:31 <xerox> uh-oh.
02:26:40 <tromp_> let fibs = recurrence [0,1] [1,1]
02:27:11 <tromp_> let onedimensionalGo = recurrence [1,1,5] [3,-1,1]
02:27:13 <tromp_> :-)
02:27:34 * xerox stares at tromp_ 
02:31:41 <tromp_> recurrences are useful enough to deserve a general definition:)
02:31:53 <dcoutts> JaffaCake, we were wondering, is -fasm ignored if the platform does not have a NGC? We were wondering if for the Gentoo ghc build we could always use "GhcStage1HcOpts = -O -fasm" to get a slightly better build time (but without makeing the final compiler any slower).
02:32:28 <JaffaCake> I think so
02:32:48 <JaffaCake> the only reason this isn't the default is that -fasm hasn't always been 100% reliable in the past
02:33:15 <dcoutts> oh, right
02:33:24 <dcoutts> do you think we'd be safe to do it?
02:33:40 <dcoutts> if it doesn't work how soon would we know? :-)
02:33:59 <dcoutts> when the stage1 compiler mis-compiles the stage 2 compiler?
02:34:03 * JaffaCake checks
02:34:19 <JaffaCake> oops, actually you'll get an error if GHC doesn't have an NCG
02:34:38 <JaffaCake> dcoutts: it's reliable these days
02:34:41 <dcoutts> oh, so we'd need to do it for just the arches with an NCG
02:34:47 <JaffaCake> yes
02:34:51 <dcoutts> and another minor Q. It's the stage 2 compiler that is usedto build the libs right.
02:35:01 <JaffaCake> no, stage1
02:35:11 <dcoutts> oh, ok.
02:35:20 <JaffaCake> on x86_64 you probably want to use -fasm all the time
02:35:50 <dcoutts> it produces better code than -fvia-C ?
02:36:01 <JaffaCake> yes, by a small margin (last time I checked)
02:36:22 <dcoutts> ok, thanks
02:36:27 <JaffaCake> if you use -fvia-C, you should also use -optc-O2
02:36:37 <JaffaCake> otherwise you get quite poor code
02:36:50 <JaffaCake> I should really change the defaults
02:37:20 <dcoutts> -O does not imply -optc-O2 then
02:37:25 <JaffaCake> we're using -fvia-C -optc-O2 for the libraries, BTW
02:37:28 <JaffaCake> no it doesn't
02:37:58 <eivuokko> Could GHC's -threaded fail on P4 hyperthreading?
02:38:35 <JaffaCake> eivuokko: what do you mean by fail?  hyperthreading shouldn't affect it
02:38:44 <dcoutts> JaffaCake, so the default is the equivalent of build.mk:GhcLibHcOpts=-O -fgenerics -fvia-C -optc-O2
02:39:01 <JaffaCake> yes
02:39:28 <JaffaCake> GhcLibHcOpts = -H32m -O2 -fvia-C -optc-O2 -dcore-lint
02:39:36 <JaffaCake> that's from our nightly build
02:39:52 <JaffaCake> oops, we're actually using -O2, not -O
02:39:57 <dcoutts> right
02:40:04 <JaffaCake> it helps a little, IIRC
02:40:09 <eivuokko> JaffaCake, I have hard time understand what -threaded actualyl does, is all.
02:40:50 <eivuokko> If -threaded and HT don't interact anyway, then -threaded is only for haskell threads and some ... wierd ffi stuff.
02:40:54 <JaffaCake> eivuokko: it makes 'foreign import safe' not block other Haskell threads, that's the main effect
02:41:51 <eivuokko> Hmmm.
02:43:08 <JaffaCake> eivuokko: it requires making use of OS threads in the  RTS, and making much of the RTS  thread-safe, hence the name -threaded
02:43:40 <JaffaCake> eivuokko: also, it makes forkOS work
02:43:47 <dcoutts> JaffaCake, can you remind us which platforms currently have a NCG? x86, x86_64. sparc? ppc? ppc64?
02:43:51 <eivuokko> It means that ffi calls are directed through an OS thread?
02:44:05 <JaffaCake> dcoutts: not sparc, and not ppc64
02:44:13 <dcoutts> thanks
02:44:14 <JaffaCake> only x86, x86_64, ppc
02:45:52 <JaffaCake> eivuokko: not exactly... we don't switch threads when making an FFI call
02:46:05 <JaffaCake> although that would be a possible implementation
02:46:28 <eivuokko> Okies, I'll grep rts and read it, maybe it'll make more sense.  Thanks.
02:46:33 <JaffaCake> eivuokko: it means that when a thread makes a foreign call, another OS thread can take over running the other Haskell threads
02:47:18 <eivuokko> I don't get it....if you have multiple OS threads, does how does it cope with multiple CPUs and HT?  Only one of them runs at any given time using haskell data structures?
02:51:24 <ski> data a -> b = forall x. Clos# (# x,(# x,a #) -># b #)
02:52:02 <xerox> hm?
02:52:03 <ski> (->#) :: (#) -> (#) -> #
02:52:09 <ski> just pondering closures
02:52:58 <ski> struct {void *data; T1 (*func)(void *data,T0 arg);}
02:53:39 <ski> function closure being a pair of some environment, and a lowlevel function taking that and an arg to the result
02:54:17 <ski> (mayhaps (->) type constructor could be implemented in that above way, in a haskell implementation)
02:55:32 <ski> (that 'void *' business with callbacks in C is basically existential quantification ..)
03:00:19 <JKnecht> does everyone call this: _|_ ? I want to call it 'perp'. If 'bottom' what's top?
03:00:46 <xerox> @type let bot = bot in const bot
03:00:47 <lambdabot> forall a b. b -> a
03:00:52 <JKnecht> s/_|_/_|_ bottom/
03:01:07 <ski> no general top
03:01:24 <ski> sometimes  top = () :: ()
03:01:56 <ski> 'perp' for 'perpetual' ?
03:02:27 <JKnecht> No perpendicular or perpetrator (of a fault/exception).
03:03:16 <JKnecht> and of course perplexed :)
03:05:25 <Cale> Top is a T shape
03:05:48 <xerox> Cale used inkscape way too much ;)
03:05:59 <Cale> hm?
03:06:00 <ski> maybe call '_|_' 'boukra' ?
03:06:21 <xerox> j/k
03:07:07 <ski> 'The Arabic word ‚Äúboukra‚Äù in literal translation is ‚Äútomorrow‚Äù. It can mean the next day, but more often ‚Äúsoon, at some undetermined time‚Äù.'
03:07:20 <ski> also used when you want to put something off
03:08:26 <JKnecht> you mean Arabic has a procrastination aspect?
03:08:32 <ski> '_|_' could be thought of as something which hasn't yet terminated
03:08:42 <ski> well, 'boukra' at least
03:10:21 <ndm> dons, ping
03:11:35 * JKnecht Yay for GPH!
03:37:02 <dcoutts_> ndm, so when are you starting the Cell port? :-) http://www.haskell.org/hawiki/Yhc_2fIdeas
03:38:31 <ndm> dcoutts_ that does indeed meet my definition of crazy!
03:38:41 <ndm> but yeah, it might be not too bad
03:39:02 <ndm> depends whether you want to do explicit parallelism, i.e TVar's etc.
03:39:16 <ndm> or if you want the runtime to automatically distribute the tasks
03:39:32 <dcoutts_> yeah, just explicit parallelism using the Concurrent Haskell library api
03:39:50 <dcoutts_> one could build something else on top of that
03:40:12 <shapr> Parallel arrays are explicit.
03:40:33 <dcoutts_> but the arch port proof comes from just getting the thing to run ordnary Haskell98 + Concurrent Haskell
03:41:41 <ndm> yhc has not parallel notion yet, but it wouldn't be that much work to add, alegedly
03:41:51 <ndm> we just don't have anyone with the time to do it
03:41:56 <dcoutts_> sure
03:41:57 <chrisbrown> hi all
03:42:36 * ndm detects a type checker related question coming along...
03:42:43 <dcoutts_> ndm, that's perfectly understandable. There are more immediate priorities.
03:42:46 <ndm> hi chris
03:43:07 <ndm> dcoutts_, yeah, we need a stable release still
03:43:19 <dcoutts_> ndm, I'm glad you added the crazy ideas page to the wiki :-)
03:43:55 <chrisbrown> ndm - no type checker questions today from me i'm afraid :)
03:44:07 <dcoutts_> ndm, shapr and I were musing yesterday about Haskell on a Cell-like cpu and figured yhc would be easier for a proof of concept than GHC.
03:44:24 <ndm> it certainly would be easier than GHC
03:44:32 <ndm> a port is about a 10 minute job
03:44:44 <ndm> getting it running on a parallel machine would be the bigger job
03:45:46 <dcoutts_> the tricky part about a Cell port is the asymetry between the cpus in the cluster.
03:46:15 <dcoutts_> how the SPUs are really very small and limited, but quite fast
03:46:40 <dcoutts_> the local memory aka explicit L1/L2 cache is the really hard part.
03:46:57 <ndm> yes, actually yhc might be ghc even ignoring complexity
03:47:06 <ndm> since in general its less memory hungry
03:47:39 <dcoutts_> ndm, how big is the whole rts when loaded in ram?
03:48:09 <dcoutts_> ndm, on ghc it's bigger than 256k so would not fit in the SPU's local memory
03:48:25 <dcoutts_> but then again one hopes that you'd not need the whole rts on each SPU
03:48:39 <ndm> the whole runtime is about 120kb, and about 75% of that is gmp
03:48:48 <dcoutts_> ah, gmp
03:49:18 <ndm> i'll just measure the runtime load
03:49:18 <dcoutts_> ok, Haskell98 - Integer type :-)
03:49:37 <ndm> indeed, its easy enough to say Integer = Int
03:49:52 <dcoutts_> ndm, and I'll bet that much of the rest of the rts is the IO system
03:50:29 <ndm> yes, the mutator (the core logic) is a few pages of C at most
03:50:49 <dcoutts_> I was guessing that all one would need on each spu is the bytecode interpreter + as much of the GC as is needed for a minor collection.
03:51:17 <dcoutts_> and some logic for communicating with the host cpu which would do the thread scheduler and major GCs
03:51:43 <dcoutts_> and IO and FFI and all the other complex stuff
03:51:44 <ndm> yeah, it could certainly be put in 30k
03:51:49 <JoshTriplett> dcoutts_: Check out http://psas.pdx.edu/~josh/haskell/Main.lhs ; it implements the construction of lazy lists based on calls to C functions.  Also see http://psas.pdx.edu/~josh/haskell/main.c , which is C code to generate exactly the same random sequences, to test that the Haskell code runs the C functions correctly.
03:51:55 <ndm> plus you'd need the local heap
03:52:36 <JoshTriplett> dcoutts_: You can test it with: ghc -ffi Main.lhs -o haskell && gcc main.c -o c && diff -u <(./haskell) <(./c)
03:52:42 <dcoutts_> ndm, right, you only get 256k for code + local heap generation + the swapped in parts of the global heap,
03:52:53 <dcoutts_> JoshTriplett, cool , I'll have a look.
03:53:12 <ndm> that should be doable, the code is pretty small as well - since its bytecode
03:54:23 <dcoutts_> doing the swapping in/out of bytecode and global heap might be tricky
03:54:56 <dcoutts_> it sounds like it'd be like a mini OS VM system
03:55:41 <ndm> yeah, and making sure garbage collections can occur, without messing up the heap
03:55:47 <ndm> swapping bytecode isn't that hard
03:55:51 <ndm> i guess
03:55:58 <ndm> since you can copy it with impunity
03:56:05 <dcoutts_> but you need to track all the chunks
03:56:07 <ndm> but the garbage collector would be a lot harder
03:56:26 <ndm> the bytecode is not that complex, and the chunks are quite well defined
03:56:33 <ndm> you'd just put a bytecode cache on each machine
03:56:38 <dcoutts_> perhaps it could be done by instead of the SPU calculating the colation of the chunks in main memory it could defer that the the main cpu
03:56:56 <dcoutts_> and it'd only need to track which bits of the main memory were currently swapping in to the local memory
03:56:58 <ndm> maybe
03:57:03 <dcoutts_> which is much less to keep track of
03:57:26 <ndm> or you could copy chunks of the heap, gc as normal, and then reinstate things later
03:57:40 <ndm> have the main processor alternately merge with each local gc
03:58:27 <dcoutts_> but don't you need to track the relationship between pages swapping in to the local memory and their lcoations in the globab memory?
03:58:52 * dcoutts_ ought to go
03:58:54 <JoshTriplett> dcoutts_: BTW, in Main.lhs, you might find the helper function withPtrTo useful; it takes a value and a withForeignPtr-style block function, allocates a ForeignPtr, opens a withForeignPtr block, stores the value in the Ptr, and then passes the Ptr to the function.  It is highly useful if you just need to wrap a value in a Ptr in order to pass it to a foreign function.
03:59:38 <JoshTriplett> dcoutts_: With it, I can write the infinite list of rand_r results based on an initial seed as: rand_rList seed = withPtrTo seed $ repeatIO . rand_r
03:59:45 <ndm> i'm not sure exactly what you do need to track, there are some nice tricks to play i'm sure
04:01:24 * JoshTriplett ought to go too.
04:04:07 <ski> (bah, JoshTriplett left)
04:20:43 <Oejet> ebar
04:30:42 <shapr> rabe?
04:31:02 <xerox> bare
04:31:42 <ski> aber
04:31:59 <xerox> bear :-)
04:32:28 <ski> brae
04:32:57 * dcoutts_ finds a bug in JoshTriplett's code
04:33:25 <dcoutts_> repeatIO does not do quite the right thing
04:33:35 <ski> (dcoutts_ : could you ask him if he wants finalizing in withPtrTo, later ?)
04:33:55 <dcoutts_> I also think withPtrTo is not necessary
04:34:07 <ski> hm, it doesn't ?
04:34:10 <dcoutts_> why the ForeignPtr ?
04:34:17 <dcoutts_> why not just 'with'
04:34:22 <dcoutts_> @type with
04:34:23 <lambdabot> Not in scope: `with'
04:34:28 <dcoutts_> @type Foreign.with
04:34:29 <lambdabot> forall b a.
04:34:29 <lambdabot> (Foreign.Storable.Storable a) =>
04:34:29 <lambdabot> a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
04:34:55 <dcoutts_> he's got withPtrTo :: Storable a => a -> (Ptr a -> IO b) -> IO b
04:34:58 <ski> hm, isn't that deallocated after the op ?
04:35:06 <xerox> hey
04:35:07 <dcoutts_> yes
04:35:13 <xerox> "yep" I meant
04:35:43 <ski> he don't want to deallocate the thing, at least not before the list (tail) is GCed, i think
04:36:08 <dcoutts_> ski, they're the same with respect to the lifetime of the temporary allocation
04:36:11 * boegel wonders if CosmicRay stopped doing HWN
04:36:43 <dcoutts_> ski, the ForeignPtr is unused after withForeignPtr returns
04:36:52 <dcoutts_> so it can be GC'ed
04:37:04 <dcoutts_> and the func had better not still be using that Ptr
04:37:19 <ski> it's using the Ptr for temp storage
04:37:29 <ski> of random seed
04:37:52 <ski> s/temp //
04:37:55 <dcoutts_> then alloca would be ok
04:38:56 <ski> rand_r updates through the Ptr, and rand_rList expects the seed to stay there 'til next forcing
04:39:07 <dcoutts_> hmm
04:39:56 <dcoutts_> I don't think that is ok
04:40:05 <ski> so, it seems to me it can't be temp allocated, and then deallocated ... either no dealloc, or GC deallocs when list tail is GCed
04:40:34 <dcoutts_> the memory allocated for the seed will go away as soon as "myList <- rand_rList 5" is done
04:40:47 <dcoutts_> but that seed is needed when I evaluate the head of myList
04:40:55 <ski> but should not, i think
04:40:59 <ski> right
04:41:05 <dcoutts_> that's what's unsafe about unsafeInterleaveIO
04:41:15 <ski> sorry ?
04:41:31 <dcoutts_> see the definition of repeatIO
04:41:38 <dcoutts_> http://psas.pdx.edu/~josh/haskell/Main.lhs
04:41:53 <ski> yes, but i see no direct prob in that
04:42:09 <ski> possible prob is in withPtrTo
04:42:26 <shapr> dons: ayh?
04:42:37 <shapr> boegel: Maybe we should jump in and contribute?
04:43:45 <dcoutts_> ski, right the definition of repeatIO is ok, but not in conjunction with the use of withPtrTo as in rand_rList
04:44:15 <dcoutts_> so yes, it's the use of withPtrTo that's dodgy
04:45:21 <boegel> shapr: I wish I had time :( I'm not blaming him, I'm just wondering
04:45:57 <shapr> How about a wiki page where you can just throw in news?
04:46:57 <boegel> dunno
04:47:11 <dcoutts_> ski, actually repeatIO is ok. My initial suspision was wrong. It's just more eager that I thought at first.
04:47:13 <boegel> I don't even have time to follow conversations in here anymore, so HWN is a blessing
04:47:26 <ski> dcoutts_ : 'tis ?
04:47:32 <dcoutts_> ski, I was thinking of this definition:
04:47:51 <dcoutts_> repeatIO f = do x <- unsafeInterleaveIO f ; xs <- repeatIO f; return (x:xs)
04:48:05 <dcoutts_> hmm, no
04:48:22 <dcoutts_> repeatIO f = unsafeInterleaveIO $ do x <- unsafeInterleaveIO f ; xs <- repeatIO f; return (x:xs)
04:48:24 <tennin> is there a standard function something like \fs -> (\x -> (map (\f -> f x) fs)) ?
04:48:26 <dcoutts_> or something like that
04:48:29 <ski> he wants to sequence all the actions associated with the list elems, in order
04:48:44 <ski> hm
04:48:50 <dcoutts_> ski, right
04:49:14 <ski> so, i think your two versions above would not work safely, with what he wants to do
04:49:18 <dcoutts_> ski, so forcing a cons evaluates the IO action in that cons cell
04:49:18 <tennin> i.e. takes a list of functions and returns a function that applies each function to a value?
04:49:21 <dcoutts_> ski, exactly
04:49:30 <ADEpt> @type apply
04:49:31 <lambdabot> Not in scope: `apply'
04:49:34 <ski> since if we force second elem, first elem should automatically be forced first
04:49:38 <ADEpt> @hoogle apply
04:49:39 <lambdabot> Data.Graph.Inductive.Query.Monad.apply :: GT m g a -> m g -> m (a, g)
04:49:39 <lambdabot> Data.Graph.Inductive.Query.Monad.apply' :: Monad m => GT m g a -> g -> m (
04:49:39 <lambdabot> a, g)
04:49:39 <lambdabot> Data.Graph.Inductive.Query.Monad.applyWith :: Monad m => (a -> b) -> GT m
04:49:39 <lambdabot> g a -> m g -> m (b, g)
04:49:40 <dcoutts_> ski, which is why I thought it was wrong at first. But he's not doing that, so it's ok.
04:49:59 <ski> agreed
04:50:16 <dcoutts_> ski, it would be possible to make it more lazy and still correct, but probably not worth it.
04:50:20 <ski> @type \fs -> (\x -> (map (\f -> f x) fs))
04:50:20 <lambdabot> forall b t. [t -> b] -> t -> [b]
04:50:24 <ADEpt> tennin: there is something, but I dont remember the name. You could try hoogle in private
04:50:34 <ski> @type \fs -> \x -> map ($ x) fs
04:50:35 <lambdabot> forall a b. [a -> b] -> a -> [b]
04:50:41 <tennin> thanks
04:50:52 <ski> @type \x -> \fs -> map ($ x) fs
04:50:53 <lambdabot> forall a b. a -> [a -> b] -> [b]
04:50:54 <shapr> tennin: foldr1 (.) ?
04:51:07 <shapr> Oh wait, maybe you want swing?
04:51:09 <ski> @type flip (map . ($))
04:51:10 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
04:51:20 <ski> @type flip (map . (flip ($)))
04:51:21 <lambdabot> forall b a. [a -> b] -> a -> [b]
04:51:28 <shapr> tennin: Do you want something like map that takes one value and a list of functions?
04:51:38 <tennin> sorry, applies each function and makes a list of the results
04:51:42 <tennin> yeah
04:51:49 <ski> dcoutts_ : maybe .. don't see that
04:51:51 <tennin> like map turned inside out
04:52:38 <shapr> You need the swing combinator.
04:52:42 <shapr> as discovered by Cale 
04:52:49 <dcoutts_> ski, it should be possible to construct the list such that you can walk down it without forcing the evaluation of the list elements, however forcing one of the list elements forces all earlier ones in order.
04:52:58 <shapr> @wiki LicensedPreludeExts
04:52:58 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
04:53:22 <dcoutts_> ski, but there's probably little point in the extra lazyness.
04:53:25 <shapr> tennin: swing is on LicensedPreludeExts, you'll be able to do swing map value [list,of,functions]
04:57:26 <shapr> boegel: Ok, if you see anything interesting happening on the lists or on #haskell, check to see if it's on the right page: http://www.haskell.org/hawiki/HaskellWeeklyNews_2fTwoThousandFive_2fDeCember_2fTwelveToEighteen
04:57:51 <tennin> hey, that's clever
04:58:08 <musasabi> @seen JaffaCake
04:58:09 <lambdabot> JaffaCake is in #haskell. Last spoke 2 hours, 11 minutes and 35 seconds
04:58:09 <lambdabot> ago.
04:58:29 <JaffaCake> musasabi: may I help you?
04:58:39 <musasabi> JaffaCake: is there a reason hTell has to check whether a file is seekable?
04:59:06 <shapr> Any good Haskell news for this week I should mention?
04:59:07 <musasabi> RawDevices don't seem to be seekable
04:59:09 <JaffaCake> as opposed to just trying it, and reporting the error, you mean?
04:59:13 <musasabi> yes
04:59:20 <shapr> So far, I wrote about Cabal Shipments, djinn, and ranged sets.
04:59:22 <JaffaCake> I don't know
05:00:40 <musasabi> hmm, SUSv3 seems to say that it is not wise :-(
05:00:44 <JaffaCake> I think it's to do with Windows: text-mode files on Windows will seek ok, but we don't want to allow that
05:00:59 <musasabi> "The behavior of lseek() on devices which are incapable of seeking is implementation-defined. The value of the file offset associated with such a device is undefined."
05:01:23 <musasabi> but it is defined to EPIPE with pipes, fifos and sockets.
05:01:41 <JaffaCake> right
05:02:29 <JaffaCake> I can't see why RawDevices would not be seekable, looking at the code
05:02:34 <musasabi> hmm I think I could use foreign import lseek for the moment.
05:03:11 * musasabi tries to write a small example
05:03:27 <xerox> @type (=<<) . flip (return .) :: a -> [a -> b] -> [b]
05:03:28 <lambdabot> a -> [a -> b] -> [b] :: forall a b. a -> [a -> b] -> [b]
05:03:34 <xerox> ^_^
05:03:37 <JaffaCake> hIsSeekable certainly returns True for a RawDevice
05:03:43 <ski> dcoutts_ hm, right .. yes
05:04:26 <ski> @type (=<<) . flip (return .)
05:04:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> m (a -> b) -> m b
05:04:58 <xerox> :-)
05:05:45 <boegel> shapr: cool
05:05:56 <ski> @type Control.Monad.liftM . flip ($)
05:05:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (a -> b) -> m b
05:06:20 <xerox> Super!
05:06:28 <rgrig> @hoogle yes
05:06:29 <lambdabot> No matches found
05:06:36 <musasabi> JaffaCake: http://youzen.b2.fi/~musasabi/h.hs
05:06:37 <ski> @hoogle no
05:06:37 <lambdabot> Control.Exception.NoMethodError :: String -> Exception
05:06:37 <lambdabot> Control.Exception.NonTermination :: Exception
05:06:37 <lambdabot> Data.Bool.not :: Bool -> Bool
05:06:47 <jimapple> @pl \f -> \x -> \y -> (f x) == (f y)
05:06:48 <lambdabot> flip =<< (((.) . (==)) .)
05:06:58 <xerox> @type compare
05:06:59 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:07:03 <shapr> y0 jimapple, wassup?
05:07:10 <shapr> jimapple: Do you have short hair now?
05:07:11 <jimapple> hi
05:07:22 <xerox> @type \f x y -> f x == f y
05:07:22 <jimapple> I do
05:07:23 <lambdabot> forall a t. (Eq a) => (t -> a) -> t -> t -> Bool
05:08:02 <jimapple> @pl \(f,g) -> \x -> (f x, g x)
05:08:02 <lambdabot> uncurry (liftM2 (,))
05:08:16 <xerox> @type \f -> curry (f Control.Arrow.*** f) >>> uncurry (==)
05:08:17 <lambdabot> Not in scope: `>>>'
05:08:26 <xerox> pl beat me.
05:08:37 <jimapple> @pl \f -> \g -> \x -> (f x, g x)
05:08:37 <lambdabot> liftM2 (,)
05:08:45 <jimapple> hm
05:08:53 <jimapple> adios!
05:09:25 <xerox> (&&&) = liftM2 (,)
05:09:48 <xerox> > liftM2 (,) $ (+1) (*2) 2
05:09:49 <lambdabot>  add an instance declaration for (Show (m a2 -> m (a1, a2)))
05:09:52 <shapr> Any good Haskell news for this week I should include?
05:10:00 <xerox> > (liftM2 (,)) (+1) (*2) 2
05:10:01 <lambdabot> (3,4)
05:10:10 <xerox> > (&&&) (+1) (*2) 2
05:10:11 <lambdabot> (3,4)
05:10:27 <JaffaCake> musasabi: ah, it's because RawDevices came after 6.4.1
05:11:28 <Gs30ng> > let f (x:xs) = x in f "123\n456"
05:11:29 <lambdabot> '1'
05:11:50 <Gs30ng> > let f (x++'\n'++y) = (x, y) in f "123\n456"
05:11:51 <lambdabot>  Parse error in pattern
05:11:57 <Gs30ng> why not ++
05:12:04 <Gs30ng> while : is possible
05:12:39 <eivuokko> : is constructor and ++ is a function.
05:13:06 <dcoutts_> ski, so I've fixed the withPtrTo mess. One has to use a ForeignPtr at each stage. That way the allocation lasts as long as the list is around.
05:13:38 <dcoutts_> rand_r' :: ForeignPtr CUInt -> IO CInt
05:13:39 <dcoutts_> rand_r' state = withForeignPtr state rand_r
05:14:02 <dcoutts_> rand_rList' :: CUInt -> IO [CInt]
05:14:03 <dcoutts_> rand_rList' seed = do
05:14:05 <musasabi> JaffaCake: ok, I'll just use force then.
05:14:29 <dcoutts_> ski, the key point is:   repeatIO (rand_r' stateForeignPtr)
05:14:38 <JaffaCake> musasabi: something is still strange, I get False for hIsSeekable on /dev/null
05:15:03 <dcoutts_> ski, so the ForeignPtr keeps the memory for the seed about as long as the list is retained.
05:15:31 <dcoutts_> JaffaCake, that's not very supprising is it?
05:16:11 <dcoutts_> JaffaCake, after all the file is 0 bytes long, (even conceptually, not just as reported)
05:16:36 <JaffaCake> dcoutts: but it according to the code, it should return True :)
05:17:23 <dcoutts_> hmm
05:18:03 <JaffaCake> ah wait, /dev/null is a character device, which GHC calls a Stream, not a RawDevice
05:18:20 <JaffaCake> my mistake, I thought RawDevice included character devices too
05:18:29 <xerox> eivuokko: (:) is a function
05:18:32 <musasabi> JaffaCake: I think I found the bug in 6.5
05:18:33 <JaffaCake> that makes more sense
05:18:38 <JaffaCake> musasabi: oh?
05:18:41 <ski> dcoutts_ : hm
05:18:55 <musasabi> JaffaCake: openFd in GHC.Handle returns "       | isReadWriteHandleType ht = mkDuplexHandle fd is_socket filepath binary
05:18:59 <xerox> Gs30ng: (:) :: a -> [a] -> [a]  while  (++) :: [a] -> [a] -> [a]
05:19:17 <musasabi> and:
05:19:18 <musasabi> wantSeekableHandle fun h@(DuplexHandle _ _ _) _act =
05:19:18 <musasabi>   ioException (IOError (Just h) IllegalOperation fun 
05:19:19 <musasabi> 		   "handle is not seekable" Nothing)
05:20:13 * JaffaCake check back through CVS history
05:20:32 <ski> xerox : data constructors (with args) are a kind of functions, yes
05:20:57 <xerox> ski: why 'a kind' ?
05:21:10 <ski> not all functions are data constructors
05:21:58 <JaffaCake> musasabi: yes, only Streams should be DuplexHandles
05:22:08 <ski> Gs30ng : what should 'let f (x++'\n'++y) = (x, y) in f "123\n456\n789"' return ?
05:22:18 <JaffaCake> this is a new bug brought in rev. 1.54 of GHC.Handle
05:22:31 <JaffaCake> lucky we caught it, because it was merged into 6.4.2 :)
05:22:36 <xerox> ski: what a subtle difference, though :-)
05:22:46 <ski> Gs30ng : '("123","456\n789")' or '("123\n456","789")' ?
05:23:04 <Gs30ng> you mean both meets the pattern?
05:23:08 <ski> yes
05:23:13 <ski> it's nondeterministic
05:23:24 <xerox> Sorry.  I see what's the problem.
05:23:41 <ski> Gs30ng : or rather, the input matches the pattern in more than one way
05:24:01 <Gs30ng> i hate that break function returns ("123", "\n456")
05:24:22 <Gs30ng> so i used tail function and it causes an error when []
05:24:52 <ski> > lines "123\n456\n789"
05:24:53 <lambdabot> ["123","456","789"]
05:25:05 <Gs30ng> so i tried to make tail function return [] when it took []
05:25:23 <Gs30ng> ski : slightly different
05:25:42 <Gs30ng> i have some another character that divides the string
05:25:46 <Gs30ng> not \n
05:25:50 <ski> mhm
05:25:51 <xerox> > words "123\n456\n789"
05:25:52 <lambdabot> ["123","456","789"]
05:26:21 <ski> dcoutts_ : hm, ok, i think
05:26:24 <JaffaCake> musasabi: I'm fixing the bug, don't bother trying to work around it
05:26:26 <dcoutts_> JaffaCake, btw, do you think my "extra-ghci-libs" patch will make it into 6.5 and 6.4.2 ?
05:26:37 <musasabi> JaffaCake: ok :-)
05:26:58 <JaffaCake> dcoutts_: 6.5 yes... is it backwards compatible for 6.4.2?
05:27:04 <dcoutts_> ski, you see what I'm getting at? with the allocation lifetime stuff
05:27:47 <dcoutts_> JaffaCake, I've not tried to apply it to 6.4.2. I could send you a seperate patch for that branch if you'd like if it turns out to be different.
05:27:58 <eivuokko> xerox, From my understanding, haskell has constructors and variables (of which we call functions those that can be applied with 1 or more parameters), and in case expression, we can only have constructors, but in function application-expression we can use both.
05:28:09 <dcoutts_> JaffaCake, but the idea should be ok for 6.4.2 as well.
05:28:34 <ski> dcoutts_ : i think
05:28:41 <JaffaCake> dcoutts_: ok, don't worry about redoing the patch, I'll just merge after committing to the HEAD
05:28:56 <dcoutts_> JaffaCake, that's where I'd like it of course, so that Gtk2Hs will work with GHCi 6.4.2 on win32.
05:29:04 <Gs30ng> and also
05:29:07 <dcoutts_> JaffaCake, thanks. :-)
05:29:18 <Gs30ng> > lines "123\n456\n789"
05:29:19 <lambdabot> ["123","456","789"]
05:29:22 <Gs30ng> > lines "123\n456\n789\n"
05:29:23 <lambdabot> ["123","456","789"]
05:29:26 <Gs30ng> damn it.
05:29:41 <Gs30ng> that last \n is valid for me
05:29:46 <flux__> > lines "\n\n\n"
05:29:47 <lambdabot> ["","",""]
05:29:49 <ski> you want a final "" ?
05:29:54 <Gs30ng> yeap
05:30:00 <flux__> > lines "a"
05:30:02 <lambdabot> ["a"]
05:30:08 <flux__> > lines "a\na"
05:30:09 <lambdabot> ["a","a"]
05:30:11 <flux__> > lines "a\na\n\n"
05:30:12 <lambdabot> ["a","a",""]
05:30:17 <Gs30ng> > lines "123\n456\n789\n\n"
05:30:18 <lambdabot> ["123","456","789",""]
05:30:21 <Gs30ng> > lines "123\n456\n789\n\n\n"
05:30:23 <lambdabot> ["123","456","789","",""]
05:30:29 <flux__> just always append \n?-)
05:30:36 <Gs30ng> why ignore last \n ?!
05:30:47 <xerox> It doesn't
05:31:01 <Gs30ng> lines "a"
05:31:03 <Gs30ng> > lines "a"
05:31:04 <lambdabot> ["a"]
05:31:06 <Gs30ng> > lines "a\n"
05:31:07 <lambdabot> ["a"]
05:31:11 <Gs30ng> arrgh
05:32:36 <ADEpt> Gs30ng: :) what are you trying to achieve? 
05:33:15 <ADEpt> Gs30ng: maybe, (lines x ++ "") is what you want?
05:33:47 <Gs30ng> ADEpt, there is a 2-dimensional board just like a chess board with x-cells and y-cells
05:34:35 <ski> > Data.List.unfoldr (\l -> if null l then Nothing else Just $ break (== '\n') (tail l)) . ('\n' :) $ "123\n456\n789"
05:34:36 <lambdabot> ["123","456","789"]
05:34:37 <ski> > Data.List.unfoldr (\l -> if null l then Nothing else Just $ break (== '\n') (tail l)) . ('\n' :) $ "123\n456\n789\n"
05:34:39 <lambdabot> ["123","456","789",""]
05:34:40 <ADEpt> Gs30ng: x- and y-coords, you mean?
05:34:45 <xerox> -_-
05:34:56 <Gs30ng> each cells contain a character and is represented by a txt file, with \n dividing the x-line
05:35:02 <ski> (that's a somewhat ugly solution)
05:35:12 <aleator> zip "123456789" [(x,y) <- [1..3], y <-[1..3]]?
05:35:26 * xerox is with aleator
05:37:00 <ski> > Data.List.unfoldr (\l -> do _:l' <- return l; Just $ break (== '\n') l') . ('\n' :) $ "123\n456\n789"
05:37:01 <lambdabot> ["123","456","789"]
05:37:10 <ski> > zip "123456789" [(x,y) <- [1..3], y <-[1..3]]
05:37:11 <lambdabot>  parse error on input `<-'
05:37:23 <ski> > zip "123456789" [(x,y) | x <- [1..3],y <- [1..3]]
05:37:25 <lambdabot> [('1',(1,1)),('2',(1,2)),('3',(1,3)),('4',(2,1)),('5',(2,2)),('6',(2,3)),(
05:37:25 <lambdabot> '7',(3,1)),('8',(3,2)),('9',(3,3))]
05:38:03 <flux__> that database you could query for [("ab\ncd\n", ["ab", "cd", ""]),("ab\cd", ["ab", "cd"])] would be great ;)
05:38:18 <flux__> ..especially if it could formulate algorithms live!
05:38:20 <Gs30ng> ADEpt, i should not just ++ [""] because i can't tell whether the source ended with \n or not
05:38:20 <flux__> why don't we have that ;(
05:38:52 <flux__> gs30ng, so does appending '\n' to the original string not work?
05:38:55 <WillKW> I got my loop working. Now I need to work out the I/O
05:39:19 <ski> (Gs30ng : how about something like my version ?)
05:39:37 <Gs30ng> actually i've already made a function 'line' does that, but it's really dirty hell evil code
05:39:50 <Gs30ng> line :: String -> [String]
05:39:50 <Gs30ng> line [] = [[]]
05:39:50 <Gs30ng> line xs = [fst once] ++ rec
05:39:50 <Gs30ng> 	where
05:39:50 <Gs30ng> 		once = break ('\n' ==) xs
05:39:51 <Gs30ng> 		back = snd once
05:39:53 <Gs30ng> 		rec | back == [] = [] | otherwise = line (tail back)
05:40:10 <aleator> Gs30ng: What was it that your doing again? Filling a array from text file?
05:40:16 <ski> s/[fst once] ++/fst once :/
05:40:35 <flux__> now just @pl that and it'll be perfect!
05:40:52 <Gs30ng> ski: oh well right
05:41:02 <Gs30ng> that's an element
05:41:14 <ski>   (front,back) = break ('\n' ==) xs
05:41:27 <ski> yes
05:41:35 <flux__> @pl \a -> case a of { 1 -> "foo"; 2 -> "bar" }
05:41:36 <lambdabot> (line 1, column 17):
05:41:36 <lambdabot> unexpected "{"
05:41:36 <lambdabot> expecting variable, "(", operator or end of input
05:41:48 <flux__> ;(
05:42:00 <ADEpt> Gs30ng: you mean that empty squares in your file are just that, empty? why not '-' or something?
05:42:06 <ski> flux__ : not a full parser in @pl, yet
05:42:08 <gour> dcoutts: ping
05:42:42 <flux__> @pl let undef = undef in \a -> if a == 1 then "foo" else if a == 2 then "bar" else undef
05:42:43 <lambdabot> ap (flip if' "foo" . (1 ==)) (flip (flip if' "bar" . (2 ==)) (fix id))
05:42:46 <flux__> cool
05:43:07 <Gs30ng> ADEpt: existence of the last empty one line is big deal for this problem... hard to explain the reason but it is
05:43:08 <flux__> @index fix
05:43:08 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
05:43:08 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
05:43:08 <lambdabot> Error
05:43:37 <flux__> @index if'
05:43:38 <lambdabot> bzzt
05:43:43 <flux__> ah, of course it needs to use such a function
05:43:54 <ADEpt> > lines "aaa\n\n"
05:43:55 <lambdabot> ["aaa",""]
05:44:09 <ADEpt> Gs30ng: see, last empty line is just that - empty
05:44:26 <ADEpt> Gs30ng: so, what's the problem?
05:44:32 <Gs30ng> ADEpt, i don't get you
05:44:59 <flux__> adept, but, it's still a special case. because the difference between "a" and "" could be interpreted to be that the first one is a line with 1 character and the second a line with 0 characters
05:45:04 <flux__> > lines ""
05:45:05 <lambdabot> []
05:45:13 <flux__> he wants that to return [""]
05:45:42 <flux__> adept, consider this: how do you reverse 'lines'-function?
05:45:55 <flux__> > unlines (lines "")
05:45:56 <lambdabot> ""
05:45:59 <flux__> > unlines (lines "foo")
05:46:00 <lambdabot> "foo\n"
05:46:10 <ADEpt> Gs30ng: what is a definition of "line" for you? for me, it a zero or more chars and then '\n' (newline). For you it seems to be something else. Does you line have clear "terminator"?
05:46:10 <flux__> appended a \n which didn't exist in the original
05:46:49 <flux__> he wants a function that can be reversed with map (++ "\n")
05:46:56 <ADEpt> flux__: it seems like whole problem is a matter of clear definition what is "input line", and what is not.
05:47:00 <Gs30ng> mhmmmm....
05:47:29 <Gs30ng> sorry for answering late because of my humble english
05:47:49 <Gs30ng> i'm struggling with what you guys said
05:48:49 <Gs30ng> both haskell and english are kinda foreign language for me and badly confuses me
05:50:49 <Gs30ng> OK. considering common definition of "line", function `lines' works well, and i should have select another proper word for this instead of line. this was the root of confusion between us. sorry.
05:52:01 <ADEpt> Gs30ng: so, you want to transform "ab\ncd\n" into 2x2 array, right? (or something liek that)
05:52:12 <Gs30ng> no
05:52:17 <Gs30ng> that's 2x3 array
05:52:36 <Gs30ng> \n is like comma
05:52:45 <Gs30ng> comma in (1,2,3) or something
05:53:05 <Gs30ng> you don need to say (1,2,3,) to represent 3 elements
05:53:57 <ADEpt> Gs30ng: and "\n" is NxN array, where N is undefined?
05:54:15 <Gs30ng> 0x2.
05:54:21 <ADEpt> Gs30ng: why you do not explicitly will blank cells with ' ' or something?
05:54:50 <Gs30ng> because all characters are valid value
05:54:54 <Gs30ng> even unicode characters
05:54:55 <ADEpt> Gs30ng: wait a sec. in "ab\ncd\n", las '\n' seems to be converted into '   ', right?
05:55:30 <Gs30ng> hmm
05:55:45 <Gs30ng> if that '   ' consists of chr 32, then no
05:56:38 <ADEpt> Gs30ng: the, again, how many lines of how many symbols are in the "ab\ncd\n"? first line is two symbols, 'a' and 'b', second is two again, 'c' and 'd', and last one - ... ?
05:57:20 <Gs30ng> third line, with, maybe zero symbol?
05:58:13 <Gs30ng> suppose "ab\n\ncd"
05:58:17 <Gs30ng> it's 3 lines
05:58:30 <Gs30ng> with second line, zero symbol
06:00:32 <Gs30ng> oops
06:04:50 <ADEpt> Gs30ng: so, "ab\n\ncd" is 3 lines, second empty. Now remove the last one, to have 2 lines, last empty. What will you get? "ab\n\n"! and how many lines "ab\n"? why?
06:05:55 <Azmo> perhaps better to encode '\n' as a character instead of nothing?
06:06:08 <Gs30ng> ADEpt, i know that it's weird to say "ab\n" has 2 lines
06:06:42 <Gs30ng> but i'm not making a word processor or something, i'm trying to implement something purely theoretical
06:07:16 <flux__> well, given a text editor with input "ab\n", how many lines can you access? two.
06:07:21 <ADEpt> Gs30ng: but your definitions contradict your own operations!
06:07:35 <Gs30ng> ADEpt: excuse me?
06:09:09 <Gs30ng> and to remove the last line, you should remove last \n too
06:09:27 <Gs30ng> from "ab\n\ncd" to "ab\n"
06:09:39 <Gs30ng> think you have a list [a,b,c]
06:09:46 <Gs30ng> and you'll remove the last element
06:09:52 <Gs30ng> then is it [a,b,]?
06:10:01 <Gs30ng> it's [a,b]
06:10:09 <Gs30ng> comma has gone with last element
06:10:36 <ibid> whew
06:10:36 <Gs30ng> just like this, last \n should dissappear when you are to remove the last line
06:10:43 <ibid> last substantial lecture done!
06:10:50 <ibid> did this there: http://www.mit.jyu.fi/antkaij/opetus/fo/2005-2006/luennot/1-14/Test.java
06:10:58 <ibid> (yes, i know, the laziness is broken:)
06:12:24 <zooko> kosmikus: we ought to the gentoo darcs package: http://packages.gentoo.org/ebuilds/?darcs-1.0.5 and the darcs wiki about gentoo: http://darcs.net/DarcsWiki/CategoryBinaries#head-f0c8ec05fbe194a94a5e15fd893a9e56096bc692
06:12:43 <zooko> Is it safe/correct for me to just replace "1.0.3*" with "1.0.5" on the wiki?  Further discussion in #darcs or private msgs.
06:17:31 <ADEpt> Gs30ng: lets define some operation. Suppose that (x) is some line. how dow we add another line to the end of (x)? (x ++ "\n" ++ l)? and to the front? (l ++ "\n" ++ x) ?
06:18:12 <ski> (also 'concat [x,"\n",l]')
06:18:40 <Gs30ng> iirc, c
06:19:22 <Oejet> ibid: The horror.
06:19:28 <ibid> Oejet: :)
06:19:37 <ibid> Oejet: did you test it?
06:19:41 <Gs30ng> i mean, if i remember correctly, correct
06:19:57 <ndm> shapr, as previously discussed - i started the library documentation project
06:19:58 <ski> ibid : maybe show a functional version of it, beside that ?
06:20:06 <ndm> @wiki LibraryDocumentation/Prelude
06:20:06 <lambdabot> http://www.haskell.org/hawiki/LibraryDocumentation/Prelude
06:20:10 <Oejet> ibid: No, I _looked_ at it.
06:20:32 <ibid> ski: they've seen it, we've done "take 5 ones" to death in previous weeks :)
06:20:47 <ibid> ski: both in coding and manually reducing it :)
06:21:16 <Oejet> ibid: Is it hard for them?
06:21:17 <ADEpt> Gs30ng: ok. and to remove line?
06:21:31 <ADEpt> Gs30ng: from the fron and from the back?
06:21:49 <ibid> Oejet: not anymore i hope
06:21:58 <ADEpt> Gs30ng: now lets start with "", add some lines, and then remove some.
06:22:18 <ski> ibid : ok .. so this is to show that it's hard to do in e.g. java ??
06:22:34 <ibid> today's topic was "functional programming and java". tried to show what functional idioms look like in java
06:22:50 <Gs30ng> ADEpt, i really don't catch what you are trying to say
06:22:53 <ibid> ... and also to discuss if and when they are appropriate in java programming
06:23:02 <ski> visitor stuff instead of case ?
06:23:22 <ibid> (i did expressedly discommend the style in Test.java, it was an attempt at a direct translation from haskell)
06:23:27 <ibid> ski: something like that
06:23:49 <Gs30ng> simply, there are (how many \n)+1 lines
06:23:55 <Gs30ng> actually it's gs-lines
06:27:42 <ADEpt> Gs30ng: i try to say that it makes sense to count line only in "well-formed" input. And well-formed input could be obtained by using operations "add line" and "remove line", starting from empty string.
06:28:28 <Gs30ng> ADEpt: again, i'm not making an word processor
06:28:43 <Gs30ng> it's more like a game map or chess board or something
06:29:22 <Gs30ng> and in my implementation, \n works as comma in list
06:30:54 <ADEpt> > takeWhile (/="") ( repeat (dropWhile (/='\n')) "ab\ncd\nef")
06:30:55 <lambdabot>   The function `repeat' is applied to two arguments,
06:30:55 <lambdabot>   but its type `a -> [a]' has only one
06:31:13 <ADEpt> > takeWhile (/="") ( iterate (dropWhile (/='\n')) "ab\ncd\nef")
06:31:14 <lambdabot> ["ab\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\
06:31:14 <lambdabot> ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef"
06:31:14 <lambdabot> ,"\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\
06:31:14 <lambdabot> nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\
06:31:14 <lambdabot> ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef","\ncd\nef"
06:31:16 <lambdabot> [23 @more lines]
06:35:57 <ADEpt> > takeWhile (/="") ( iterate ((drop 1).dropWhile (/='\n')) "ab\ncd\nef")
06:35:59 <lambdabot> ["ab\ncd\nef","cd\nef","ef"]
06:36:56 <ADEpt> > map takeWhile (/='\n') $ takeWhile (/="") ( iterate ((drop 1).dropWhile (/='\n')) "ab\ncd\nef")
06:36:57 <lambdabot>   Expecting a function type, but found `[b]'
06:36:57 <lambdabot>   Expected type: a -> b
06:36:57 <lambdabot>   Inferred type: [b1]
06:37:12 <ADEpt> > map (takeWhile (/='\n')) $ takeWhile (/="") ( iterate ((drop 1).dropWhile (/='\n')) "ab\ncd\nef")
06:37:13 <lambdabot> ["ab","cd","ef"]
06:37:26 <ADEpt> > map (takeWhile (/='\n')) $ takeWhile (/="") ( iterate ((drop 1).dropWhile (/='\n')) "ab\ncd\nef\n")
06:37:27 <lambdabot> ["ab","cd","ef"]
06:42:17 <ADEpt> > map (takeWhile (/='\n')) $ takeWhile (/="") ( iterate ((drop 1).dropWhile (/='\n')) "ab\ncd\nef\n\n")
06:42:18 <lambdabot> ["ab","cd","ef",""]
06:57:16 <shapr> ndm: nifty!
06:58:07 <ndm> shapr, it still needs a lot of reformatting, and i have all the data for Numeric/Char and a few other libs as well to  put on
07:03:58 <marcot> Hello there.
07:04:49 <marcot> I'm having a problem with gtk2hs, TreeView.
07:05:05 <marcot> I've followed the conceptual view of TreeList in the gtk reference manual.
07:05:12 <dcoutts> marcot, right
07:05:26 <marcot> dcoutts: Hey, how are you?
07:05:33 <dcoutts> fine thanks
07:05:39 <marcot> But I can't add data to the list.
07:06:23 <marcot> http://pastebin.com/462267
07:06:47 <marcot> In listStoreSetValue dados iter 0 $ GVstring $ Just "coluna0" I wanted to add coluna0 to the column in the list.
07:12:40 <dcoutts> marcot, so what's wrong?
07:13:19 <marcot> the treeview is being empty.
07:13:45 <marcot> It shows the column Titulo0 but with no fields.
07:16:27 <dcoutts> marcot, so you're not telling it which renderer attributes are set by which columns in the model.
07:16:37 <dcoutts> try:
07:16:51 <dcoutts> treeViewColumnNewWithAttributes "Titulo0" forma0 [("text",0)]
07:17:01 <dcoutts> rather than:
07:17:08 <dcoutts> treeViewColumnNewWithAttributes "Titulo0" forma0 []
07:17:11 <dcoutts> as you've got now
07:17:44 <dcoutts> marcot, btw, we know this stuff is all rather difficult and confusing at the moment
07:17:51 <dcoutts> we're working on improving the api
07:18:03 <marcot> dcoutts: Where can I get doc about this list parameters?
07:18:13 <marcot> dcoutts: But isn't this a gtk problem, instead of a gtk2hs?
07:19:13 <dcoutts> marcot, well we can make the Haskell API simpler without needing the underlyign gtk api to be different
07:19:41 <gour> dcoutts: hi
07:19:48 <dcoutts> hia gour 
07:20:14 <gour> dcoutts: i wonder whether i can dismantle this darcs-mirroring, it does not serve the purpose atm?
07:20:22 <dcoutts> gour, indeed
07:20:50 <dcoutts> marcot, you're right that the attributes/renderers is not well documented either.
07:20:52 <gour> dcoutts: i hope you will followup shortly (but not dimantling :-)
07:21:06 <dcoutts> marcot, it'll be better with the new api
07:21:11 <dcoutts> gour, ?
07:21:29 <gour> dcoutts: yes?
07:21:55 <dcoutts> gour, I didn't understand your last comment.
07:22:17 <marcot> dcoutts: ok... but I think that being similar to gtk is very important.
07:22:21 <gour> dcoutts: joke, i hope you will build something with darcs, not destroy :-)
07:22:35 <gour> dcoutts: i.e. provide proper darcs repo ;)
07:22:43 <dcoutts> marcot, it'll still be similar. We're not eliminating features / flexability.
07:22:54 <dcoutts> gour, right :-)
07:23:24 <dcoutts> gour, I just need to find some time to do the tailor conversion properly.
07:24:21 <gour> dcoutts: ok, i'll sweep python, tailor & other things from my $home
07:24:48 <marcot> dcoutts: hum, so I'll probably be very fine.
07:24:57 <Pupeno> anybody running/interested in a repository of updated packages related to Haskell for Ubuntu breezy (mainly packages from Ubuntu dapper) ?
07:26:13 * Lemmih would be interested.
07:28:58 <Pupeno> I'll see if there's any interest in having them on breezy-backports, otherwise it'll be my own repository (which once held Lisp-related packages ;)
07:30:03 <marcot> s/I'll/it'll
07:45:34 <mysteriousentity> Hello. If I want write a program that repeats an action until a key is pressed, how can I do it?
07:45:54 <mysteriousentity> Is there a function similar to keydown?
07:46:25 <xerox> @type System.IO.getChar
07:46:25 <lambdabot> IO Char
07:46:39 <xerox> @type until
07:46:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:46:45 <xerox> @type while
07:46:46 <lambdabot> Not in scope: `while'
07:46:50 <musasabi> main = do stopper <- launchAction; getChar; stopper
07:47:02 <xerox> Hm, there was something monadic, I feel.
07:48:40 <mysteriousentity> If I use getChar, won't that stop the program and ask for a character every single time it goes around the loop?
07:49:01 <xerox> Yep.
07:49:46 <mysteriousentity> But I want the program to go on if I'm not pressing a key.
07:50:16 <xerox> What about installing an handler for ^C ?
07:50:37 <mysteriousentity> What is "^C"?
07:50:47 <mysteriousentity> Oh, Ctrl-C.
07:50:51 <mysteriousentity> I see.
07:51:04 <mysteriousentity> How do I do that?
07:52:14 <mysteriousentity> Or rather, what do you mean by that?
07:52:29 <xerox> Rebing SIGINT to something else
07:52:34 <xerox> *Rebind
07:52:59 <musasabi> There was a CTRL-C discussion on Haskell-Cafe a few days ago.
07:53:00 <xerox> Maybe search the logs for dons explaining how he did it in Yi, some days ago.
07:53:04 * shapr boings
07:53:06 <xerox> I should gonow.
07:53:52 <mysteriousentity> Ok. Thank you.
08:00:00 <shapr> hiya bracx, how's code?
08:01:17 <bracx> shapr: Hi, working through the yet another haskell turorial
08:01:31 <shapr> Any questions?
08:02:44 <bracx> shapr: well, the language is different than C,  not use to the functional style
08:02:59 <bracx> shapr: have to think differently
08:03:03 <shapr> lennart: Do you have any idea why SSA machine code is beneficial? Urban Boquist's GRIN thesis says on page 194 "too much work on the GRIN back-end had already been done before we realised the real benefits of SSA also at the machine code level." but I'm not sure what those benefits are.
08:03:36 <jethr0> static single assignment?
08:03:51 <shapr> bracx: Truly, it's a different approach. Happily, stretching your brain will benefit your code in both functional and imperative worlds.
08:03:53 <shapr> jethr0: yup.
08:04:36 <jethr0> hmm, it's supposedly pretty great for code optimisations (common subexpressions, ...) which would translate into good resulting code!?
08:04:59 <shapr> Yeah, but why generate SSA machine code? What benefits does that give?
08:05:48 <jethr0> ssa machine code doesn't make any sense (to me). my guess he means the positive effects on object code of using SSA optimizations
08:06:10 <shapr> No, he's really talking about machine code, I've checked. It's page 194 of his PhD thesis.
08:06:16 <jethr0> machine code doesn't even have variables, so i wouldn't know how SSA defined there
08:06:18 <shapr> I sent him an email, but have gotten no reply.
08:10:35 <dcoutts> shapr, jethr0, perhaps it is to reduce "false dependencies" in the instruction stream
08:10:37 <dcoutts> http://www.chip-architect.com/news/2003_09_21_Detailed_Architecture_of_AMDs_64bit_Core.html#1.9
08:11:01 <dcoutts> if you've got SSA machine code perhaps you don't need "register renaming"
08:11:09 <dcoutts> and thus less complex CPUs
08:11:14 <mwc> When does intel think they'll have dual hyperthreading cores out?
08:11:25 * mwc has a hankering for some 4-way chip multithreading
08:11:36 <mwc> without paying for Sun gear
08:11:46 <jethr0> maybe
08:12:01 * dcoutts wants an 8x4 way Sun workstation
08:12:24 <mwc> my understanding is that the FP performance of those chips leaves a lot to be desired
08:12:35 <dcoutts> yep, only one FPU per chip
08:12:44 <dcoutts> the next version will have one per core
08:12:49 <dcoutts> ie 8 FPUs
08:12:58 <Pupeno> How much time may it take to compile ghc 6 on a P4 2.8GHz with 700+MB or RAM ?
08:13:17 <dcoutts> Pupeno, hour and a bit
08:13:39 <mwc> I wonder how those FPUs will play against the Opteron's or the G5's.
08:14:11 <Pupeno> dcoutts: thanks.
08:14:23 <dcoutts> it's not designed for FP stuff. It's for servers (web,db etc) which don't need many FP operations.
08:14:52 <dcoutts> but with the next version of the chip it mgiht be ok
08:15:04 <mwc> I figured. I'd just love to have some sort of "light big-iron" on my desktop
08:15:17 <dcoutts> it's obviously going to be slower per-thread
08:15:35 <JaffaCake> mwc: you can already get dual hyperthreading cores, I think
08:15:47 <JKnecht> definitely.
08:15:51 <JaffaCake> in the top-of-the-range chips
08:16:22 * JaffaCake isn't sure why you'd want one, though
08:16:24 <dcoutts> mwc, actually big-iron is often supprisingly lowly clocked. When I worked at Cray, their top vector chips were running in the range 500-800Mhz.
08:17:55 <dcoutts> mwc, that's because when you're using 64 entry vectors of 64bit values you don't need to clock it very high to saturate a very hugh bandwidth memory link.
08:18:23 <dcoutts> hugh/high
08:22:58 <musasabi> Usually exotic machines are cool until one gets fed up with software bugs and developers not caring about portablity.
08:23:18 <dcoutts> yeah
08:23:41 <dcoutts> all the world is not x86
08:24:52 <shapr> More like 95% of the world is x86.
08:25:13 <wilx> :))
08:25:21 <wilx> Let's round up!
08:27:20 <shapr> Still, the biggest problem is memory bandwidth.
08:29:02 <shapr> My suggested solution is to extend the Cell cpu approach to a quilt of cpu and cache ram, where each edge is a link to the next chunk. That would only work if there are multiple routes from main memory to the cache ram though.
08:29:55 <genneth> shapr: thinking more about the hexagonally close-packed monster again?
08:29:59 <genneth> :-p
08:41:20 <ndm> dons: ping
08:51:39 <JKnecht> where does Com.lhs live?
08:57:06 <jethr0> @seen dons
08:57:07 <lambdabot> dons is in #haskell. Last spoke 10 hours, 57 minutes and 29 seconds ago.
08:57:46 <ndm> have emailed dons now, so not needed anymore
09:01:35 <dcoutts> JaffaCake, was there a reason to write a linker that reads object files directly rather than using an abstraction library like libbfd? The license?
09:01:58 * dcoutts was wondering about GHCi using .a files
09:02:33 <JaffaCake> I'm not entirely sure, it may not have been possible to use libbfd at the time
09:03:14 <JaffaCake> I don't know whether it is now... do you think it would be?
09:03:51 <dcoutts> I expect it would but I'm not sure the licece would be ok
09:04:10 <dcoutts> it'd give .a files for free
09:04:13 <JaffaCake> no problem if you dynamically link
09:04:30 <dcoutts> because of the system lib exemption?
09:04:36 <dcoutts> and supports more platforms and formats that anything else
09:04:46 <JaffaCake> oh,is it GPL, not LGPL?
09:05:03 <dcoutts> it's not very obvious, let me find something definitive...
09:05:15 <jethr0> @hoogle gets
09:05:15 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
09:05:15 <lambdabot> System.Random.getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
09:05:15 <lambdabot> System.Random.getStdGen :: IO StdGen
09:05:36 <dcoutts> BFD is part of gnu binutils
09:06:01 <dcoutts> http://sourceware.org/cgi-bin/cvsweb.cgi/src/bfd/COPYING?rev=1.3&content-type=text/x-cvsweb-markup&cvsroot=src
09:06:07 <dcoutts> GPL
09:06:18 <JaffaCake> right, license is a problem then
09:07:05 <dcoutts> that's a shame
09:07:07 <dcoutts> oh well
09:07:21 <JaffaCake> I'd solve the .a problem by invoking 'ld --whole-contents' when GHCi starts up, to be honest
09:07:42 <JaffaCake> a lot simpler, but a bit slower
09:08:10 <JaffaCake> anyway, I've got to go, see you later
09:17:16 <neologism> anyone willing/able to help me with prolog? (have tried on #prolog - no success)
09:18:01 <jethr0> willing but not very able... is it manageably easy?
09:18:46 <neologism> I want a predicate which return sequence of number
09:19:10 <neologism> like foo(1, 3, Sequence).
09:19:12 <yaarg> sequence of number?
09:19:14 <neologism> Sequence - 1
09:19:14 <neologism> Sequence - 2
09:19:15 <neologism> Sequence - 3
09:19:17 <yaarg> ah
09:19:32 <jethr0> printed as side-effect or returned?
09:19:40 <neologism> returned
09:20:02 <neologism> I invented this
09:20:02 <neologism> listOfYrs(YR, YRS, Y):-         T is YR + YRS, Y < T.
09:20:07 <neologism> but this doesnt work :(
09:20:39 <jethr0> don't you have to "call" listOfYrs on the right side again?
09:20:58 <neologism> how?
09:21:07 <jethr0> hmm, lemme look it up
09:24:09 <jethr0> sth like (totally wrong syntax):
09:24:58 <jethr0> listOfYrs(from, to) :- [] if from == to
09:25:21 <jethr0> listOfYrs(from, to) :- [from | listOfYrs(from+1, to)]
09:25:36 <neologism> yes
09:25:37 <jethr0> i know this isn't helping very much... i'm not really all that prolog-savvy :(
09:25:42 <neologism> but this is haskell syntax
09:26:02 <jethr0> i know, but i think sth in this vein might work in prolog...
09:26:13 <neologism> prolog doesnt have set generators
09:26:19 <neologism> nor it has variables so...
09:26:33 <neologism> I mean... it doesnt return from functions
09:27:20 <jethr0> append([], L, L).
09:27:27 <jethr0> append([H| L1], L2, [H| L3]) :-  append(L1, L2, L3) .
09:27:40 <jethr0> and this somehow applied to your problem.
09:27:49 <jethr0> :(
09:27:54 <jethr0> s/(/)/
09:28:08 <neologism> the problem is "somehow"
09:28:24 <jethr0> working on it
09:28:28 <neologism> and I dont need array of the results
09:28:36 <neologism> I need the predicate to "return" one after the another
09:28:39 <jethr0> that's what i was asking earlier
09:28:49 <jethr0> *aaahhh*
09:29:16 <jethr0> i'm not sure that can work in prolog? isn't prolog referentially transparent?
09:29:26 <neologism> I dont know
09:29:35 <neologism> but it must be doable somehow
09:29:39 <jethr0> no, it's not
09:29:45 <neologism> why not?
09:30:00 <neologism> hm.. what about the list
09:30:11 <jethr0> "Prolog is not referentially transparent because it has a large variety of builtins that violate referential transparency."
09:30:28 <jethr0> but where is prolog supposed to keep the state about which elements it has already produced?
09:30:48 <neologism> I just need a sequence of numbers :(
09:31:40 <jethr0> what for?
09:32:05 <neologism> for the predicate I am doing
09:33:08 <jethr0> sry, can't help ya. and i'm not sure this "sequence" thing is possible in prolog :(
09:33:15 <neologism> hm...
09:33:19 <neologism> it must be doable somehow
09:33:37 <jethr0> why? it hardly is in haskell (except using stateful monads)
09:33:50 <neologism> [n...n+m]
09:33:52 <neologism> and its done
09:34:10 <neologism> well.. for semestrs I did it this way
09:34:12 <jethr0> yes, but that's a list and you said you wanted it to return an incremented number on each call
09:34:14 <neologism> listOfSemestrs(winter).
09:34:14 <neologism> listOfSemestrs(summer).
09:34:23 <neologism> and it works
09:34:29 <neologism> so I think it can be done also for number
09:34:34 <jethr0> building a list of elements shouldn't be a big problem
09:35:28 <neologism> lets tr it
09:37:51 <jethr0> app(from, from, L).
09:38:17 <jethr0> *arg*
09:38:47 <jethr0> app(from,from,L).
09:39:07 <jethr0> app(from, to, [from | X]) :- app(from+1, to, X).
09:39:13 <jethr0> except for the "from+1"
09:40:13 <jethr0> and maybe make that "app(from,from,[])" ??
09:40:34 <neologism> seems like help from #prolog arrived ;)
09:40:43 <jethr0> ;)
09:42:24 <shapr> genneth: Yup, what do you think of such a packing?
09:50:24 * shapr boings cheerfully
09:52:47 <jethr0> @pl (\x y -> if y == '\n' then x++"> " else x++[y])
09:52:47 <lambdabot> ap (ap . flip (if' . ('\n' ==)) . (++ "> ")) ((. return) . (++))
09:52:56 <soysauce> "Quantified type variable `s' escapes" <-- anyone have an intelligible explanation for what this means? :|
09:53:19 <jethr0> in what context?
09:53:58 <soysauce> http://www.rafb.net/paste/results/bZSRsu77.html
09:55:06 <jethr0> no idea
09:55:24 * soysauce cries
09:55:28 <soysauce> that's never a good thing.
09:55:44 <soysauce> this is homework that I've been trying to finish for way too long...
09:59:13 <SamB> soysauce: you are trying to do something with ST which you aren't allowed to do
09:59:13 <SamB> well, at least, thats when I always get that :-(
09:59:53 <soysauce> hmm
10:00:01 <soysauce> well, I don't understand why I'm not allowed
10:00:20 <soysauce> it's basically runSTUArray ((fold (>>) [a bunch of modifications to the array]) >> the array)
10:01:44 <SamB> soysauce: try freezing the array first
10:01:51 <SamB> @type Data.Array.MArray.unsafeFreeze
10:01:52 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
10:01:52 <lambdabot> (Data.Array.Base.IArray b e,
10:01:52 <lambdabot> Data.Array.Base.MArray a e m,
10:01:52 <lambdabot> GHC.Arr.Ix i) =>
10:01:52 <lambdabot> a i e -> m (b i e)
10:02:13 <SamB> no wait.
10:02:18 <adept> soysauce: please try to specify type signature for fw2 explicitly
10:02:18 <SamB> the . is the problem :-;
10:02:22 <SamB> er.
10:02:22 <SamB> ;-)
10:02:29 <int-e> runSTUArray does the freeze.
10:02:47 * SamB gives silly answers sometimes
10:03:19 <soysauce> SamB - why?
10:03:53 <SamB> adept: that isn't the problem
10:04:04 <adept> SamB: maybe :)
10:04:17 * adept gives silly answers more often than SamB
10:04:23 <SamB> soysauce: well, . messes up the higher-order quantification of s
10:04:41 * soysauce doesn't follow
10:05:21 <SamB> soysauce: well, observe:
10:05:29 <SamB> @type Data.Array.ST.runSTUArray
10:05:30 <lambdabot> forall e i.
10:05:30 <lambdabot> (GHC.Arr.Ix i) =>
10:05:30 <lambdabot> (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e))
10:05:30 <lambdabot> -> Data.Array.Base.UArray i e
10:05:59 <neologism> jethr0: interested in the result?
10:06:13 <jethr0> yup
10:06:18 <SamB> you see that forall INSIDE the parentheses around the type of the argument?
10:06:23 <soysauce> yes
10:06:35 <soysauce> I wasn't sure what the significance of that was
10:06:42 <neologism> listOfYrs(X, XS, Y):- XS > 0, Y is X.
10:06:42 <neologism> listOfYrs(X, XS, Y):- XS > 0, X2 is X + 1, XS2 is XS - 1, listOfYrs(X2, XS2, Y).
10:07:03 <SamB> that means that runSTUArray must take a value polymorphic in s
10:08:01 <SamB> soysauce: well, it keeps you from returning an array of STRefs
10:08:11 <jethr0> neologism, pretty much what i had in mind, with the exception of being completely ignorant about prolog :(
10:08:32 <soysauce> well, I'm fairly lost...can I show you the code?
10:08:43 <jethr0> but why do you cound X up _and_ XS down?
10:09:14 <soysauce> http://www.rafb.net/paste/results/llcWfw49.html <-- I'm just trying to make fw work
10:09:36 <jethr0> no, it's not what i had in mind... it's not list-based?
10:09:53 <soysauce> but I've not got a clue on how to fix it. I was trying with fw2 to break it into pieces so that I could figure out where the problem with fw was.
10:10:25 <neologism> jethr0: no its not list based
10:10:42 <jethr0> weird
10:10:47 <joelr1> evening folks
10:10:50 <joelr1> is there a way to allocate a top-level TVar?
10:11:02 <joelr1> i.e. unsafePerformIO $ atomically $ newTVar 0
10:11:12 <joelr1> it's not working for me
10:12:47 <adept> joelr1: i tried to find a way, and failed
10:13:02 <joelr1> adept == tomasz?
10:13:07 <joelr1> :-)
10:13:12 <adept> joelr1: no :)
10:13:18 <joelr1> ok
10:13:31 <joelr1> adept: did you come up with a workaround?
10:14:16 <adept> joelr1: no :(
10:14:27 <joelr1> ok 
10:14:30 <joelr1> thanks
10:14:31 <adept> joelr1: seems like it is impossible to do with STM
10:14:42 <joelr1> adept: right
10:15:45 <SamB> soysauce: just take out the dot
10:15:55 <SamB> joelr1: don't
10:16:13 <joelr1> SamB: i want to do a process registry
10:16:34 <soysauce> SamB - it doesn't work without the .
10:16:41 <soysauce> the types don't match
10:17:06 <soysauce> hm, strange
10:17:17 <soysauce> why doesn't it typecheck in my code? :(
10:17:46 <joelr1> SamB: how would you do it without STM and without passing it around?
10:18:01 <joelr1> hmm... as a monad maybe
10:18:11 <int-e> soysauce: did you try \x -> runSTUArray (fw2 x) ?
10:18:25 <soysauce> int-e - yes, that works for some reason, weird
10:18:37 <roconnor> Is there a binary tree type in ghc?
10:18:52 <int-e> soysauce: I don't fully understand how that's different from runSTUArray . fw2, but that seems to work.
10:19:10 <soysauce> http://www.rafb.net/paste/results/633nYj80.html
10:19:16 <soysauce> well, that's even weirder.
10:20:03 <soysauce> hm
10:20:04 <SamB> soysauce: well, you have to compensate for its loss too
10:20:17 <soysauce> well I'm really confused.
10:20:26 <SamB> like, what was that expression on the rhs of?
10:20:31 <soysauce> since everything is referentially transparent, the first bit of code in that paste ought to have worked
10:20:42 <soysauce> which?
10:21:26 <basvandijk> Hi guys, I have a quick question. I'm planning to buy a new AMD64 based PC. I tried running GHCi on the AMD64 PC of my brother but it retured an error saying: unsupported architecture. Then I read: http://haskell.org/ghc/docs/latest/html/building/sec-port-info.html. What does "unregisterised" mean?
10:22:30 <SamB> soysauce: dot messes up that sort of type, is all
10:23:38 <soysauce> SamB - but look at the newest paste
10:23:49 <SamB> soysauce: higher-order polymorphism is finicky that way
10:23:53 <soysauce> if I take the argument to runSTUArray and put it in another function, it works
10:23:58 <soysauce> if I inline it by hand, it doesn't.
10:24:12 <soysauce> GHC complains about s again, but it's a different error message
10:24:13 <SamB> basvandijk: its the opposite of registerised
10:24:19 <soysauce> "Inferred type is less polymorphic than expected..."
10:24:26 <int-e> SamB: so the type system can not generate higher-order types for subexpressions, only for explicit bindings?
10:24:44 <SamB> basvandijk: it has to do with calling conventions and that sort of thing...
10:25:13 <basvandijk> SamB: Do you know when the AMD64 registered port will be ready?
10:26:41 <dcoutts> basvandijk, since 6.4.1
10:26:50 <SamB> soysauce: hmm
10:26:58 <SamB> soysauce: okay, so add the types now
10:26:58 <SamB> int-e: I don't think thats it
10:27:03 <SamB> I'm a bit lagged
10:27:17 <joelr1> dcoutts: how would you implement a process registry? as a monad?
10:27:51 <dcoutts> If I knew what that meant I might have some idea
10:28:10 <joelr1> dcoutts: well, i'm trying to implement threads with mailboxes
10:28:13 <joelr1> an abstraction
10:28:30 <joelr1> i would like to be able to keep a list of such threads around to broadcast messages to them for example
10:28:42 <dcoutts> ok
10:28:54 <joelr1> and within each individual process i would like to use "receive" to retrieve messages from my own mailbox
10:28:58 <dcoutts> you want to avoid using a top level variable
10:29:11 <joelr1> i tried a top-level TVar but that doesn't work, is not supported
10:29:19 <joelr1> at least not in 6.4.1
10:29:52 * dcoutts thinks that's probably a good thing
10:29:58 <joelr1> :D
10:30:05 <joelr1> dcoutts: so what am i left with? a monad?
10:30:20 <dcoutts> top level IORefs and MVars have gotten people into bad habbits
10:30:23 <joelr1> i'm a bit afraid of nested monads, actually, but maybe i should not be
10:30:29 <basvandijk> dcoutts_: I installed GHC 6.4.4.1 on the AMD64 PC of my brother. When I execute ghci it complains: Loading package base-1.0 ... ghc-6.4: /usr/lib/ghc-6.4/HSbase.o: unknown architecture ghc-6.4: panic! (the `impossible' happened, GHC version 6.4): loadObj: failed
10:30:54 <ibid> there are cases where a top-level variable is indispensable
10:30:54 <dcoutts> basvandijk, you've got 6.4 installed. That's what the error message says.
10:31:10 <joelr1> but i think that if the process registry was created at the top level and I used runP or something like that so that everything ran in the "process monad" then it would work
10:31:11 <dcoutts> basvandijk, you said "panic! (the `impossible' happened, GHC version 6.4"
10:31:22 <dcoutts> basvandijk, so you'll need 6.4.1
10:32:01 <dcoutts> joelr1, sounds ok
10:32:04 <basvandijk> dcoutts_: isn't 6.4.4.1 higher then 6.4.1?
10:32:18 <dcoutts> basvandijk, there's no such version as 6.4.4
10:32:27 <dcoutts> basvandijk, the latest version is 6.4.1
10:32:31 <musasabi> Is there an elegant way of simulating record accessor while changing type?
10:32:54 <SamB> hmm, my FM synth has gone missing
10:33:02 <dcoutts> joelr1, do you need a monad or will something simpler do?
10:33:04 <musasabi> Something like: if foo rec == True then foo { rec = 'a' } else foo { rec = 'b' } ?
10:33:18 <basvandijk> dcoutts_: OK then I will check out the kubuntu GHC-cvs package. Maybe that will work.
10:33:23 <basvandijk> thanks
10:33:35 <dcoutts> basvandijk, or install the binary package
10:33:45 <musasabi> just a dedicated function?
10:34:06 <ibid> dcoutts: saw my scary java file? :)
10:34:35 <dcoutts> joelr1, eg why not just create a ProcessRegistry adt (containing a TVar of processes) and pass that about?
10:35:07 <dcoutts> ibid, I didn't. What's scary? You're implementing lazyness in Java?
10:35:25 <SamB> hmm, how do I get alsa to give me a /dev/snd/seq?
10:35:32 <resiak> modprobe snd-seq
10:35:41 <resiak> modprobe snd-seq-device might also help.
10:35:48 <ibid> it was an example in my last substantive lecture, in the style "this is a direct translation of haskell to java" (of course, my translation is faulty re laziness)
10:36:23 <ibid> dcoutts: http://www.mit.jyu.fi/antkaij/opetus/fo/2005-2006/luennot/1-14/Test.java :)
10:36:49 * dcoutts tries to understand :-)
10:37:55 <ibid> dcoutts: want a cheatsheet (ie. what it iis encoding)
10:37:57 <ibid> ?
10:38:13 <dcoutts> I'm getting it, slowly...
10:38:21 <dcoutts> I understand the ones example
10:40:09 <ibid> there is only one example there
10:40:12 <ibid> :)
10:40:15 <ibid> ones is a part of it
10:40:35 <dcoutts> it's pretty horrible :-)
10:40:37 <dcoutts> take 5 ones
10:40:46 <ibid> y
10:40:47 <ibid> :)
10:41:14 <jethr0> how can i pattern-match in a function definition?
10:41:22 <ibid> but last substantive lecture \o/
10:41:23 <jethr0> fun x | (Constr _ _ y) = y
10:41:27 <jethr0> ?
10:41:30 <ibid> (last lecture on thursday)
10:41:35 <dcoutts> ibid, I should show the prof who was teaching FP last term. I think he'd apreciate it.
10:41:36 <ibid> jethr0: fun (Constr _ _ y) = y
10:41:41 <ibid> dcoutts: oh?
10:41:47 <jethr0> i know, but isn't there a way with guards?
10:41:55 <dcoutts> ibid, we've been done for a week :-)
10:41:57 <ibid> you didn't ask that :)
10:42:04 <jethr0> sry
10:42:20 <ibid> dcoutts: remember to tell him that i didn't recommend that style for java programming and that i am aware the laziness is broken
10:42:37 <ibid> dcoutts: :)
10:42:44 <dcoutts> ibid, so how is the lazyness borken exactly. I didn't get that bit.
10:43:48 <ibid> dcoutts: any expression is eagerly evaluated to WHNF
10:43:53 <ibid> dcoutts: and there is no memoization
10:44:08 <dcoutts> mamoization is optional
10:44:25 <dcoutts> it gives us lazyness but non-strict is ok
10:44:26 <ibid> in haskell yes, but it's not lazy evaluation if you don't memoize
10:44:38 <ibid> dcoutts: i did say LAZINESS is broken ;)
10:44:43 <dcoutts> ok :-)
10:45:11 <ibid> dcoutts: doing true laziness proved to be trickier than i thought
10:45:16 <dcoutts> so why is it that expresions are eagerly evaluated to WHNF
10:45:38 <dcoutts> that isn't obvious to me from reading the implementation
10:46:10 <ibid> dcoutts: (if one tries to avoid a structure tree representation & evaluator architecture)
10:46:46 <ibid> dcoutts: well, i suppose if i added LazyFunction cons = ... it might work correctly
10:47:38 <ibid> dcoutts: but data constructors are encoded currently by new Type() { ... }
10:47:49 <ibid> dcoutts: that makes any such expression trivially WHNF
10:49:12 <ibid> dcoutts: but you didn't say why the professor would like this? ;)
10:49:20 <bringert> I want to pass a string from Haskell to a C library. the C library actually wants a file name or a FILE * to read the string from. any ideas for the best way to do this? My best bet so far is writing the data to a temp file and pass the path to it.
10:49:44 <dcoutts> ibid, because of the complexity of the encoding needed to to lazyness in an ordinary imperitive language.
10:49:57 <bringert> that seems wasteful and error-prone though. is there a way to create a FILE * that reads from a in-memory string?
10:50:10 <ibid> well, it would be simpler if i just succumbed to separating the evaluator from the expressions
10:50:41 <dcoutts> bringert, you can write through a pipe
10:50:53 <Lemmih> Hi SyntaxNinja.
10:51:22 <bringert> ah, right. I considered that. that would mean I would have a special haskell thread writing to to the pipe, right?
10:51:38 <bringert> or is there a way to avoid forking?
10:51:54 <dcoutts> using Haskell threads would make it simpler
10:52:03 <bringert> sure
10:52:06 <ibid> bringert: you might also consider select/poll
10:52:29 <bringert> it just feels like should be a really simple way to do it
10:52:31 <SamB> hmm, how do I get a MIDI port?
10:52:39 <dcoutts> bringert, otherwise you need to do non-blocking writes to the pipe in a loop
10:53:09 <bringert> something like a FILE *strstream(char *str) somewhere in libc
10:53:20 <dcoutts> bringert, or open a file in shared memory. That'll be quick.
10:54:03 * bringert is looking though stdio.h
10:54:19 <bringert> what about setbuf(3)?
10:54:50 <bringert> or setbuffer rather
10:55:00 <ibid> no go
10:55:07 <bringert> couldn't I open /dev/null and set the buffer to the string I want?
10:55:10 <ibid> can you assume unix?
10:55:13 <bringert> hacky as hell though
10:55:18 <bringert> no, not really
10:55:27 <bringert> why?
10:55:36 <ibid> on unix, you could open /dev/null and mmap the data to the file
10:55:46 <bringert> does that work?
10:55:57 <ibid> well, you actually probably need to copy the data in
10:56:03 <neologism> ibid: dont you mean /dev/zero ?
10:56:07 <ibid> yes
10:56:13 <ibid> and /dev/ is not the right answer
10:56:20 <ibid> yeah, tempfile it probably has to be :/
10:56:33 <dcoutts> open_memstream
10:56:36 <bringert> that or a pipe and a haskell thread
10:56:36 <ibid> there is no strstrem in standard c (but gnu libc might have it)
10:56:39 <dcoutts> #ifdef  __USE_GNU
10:56:52 <dcoutts> fmemopen
10:57:02 <bringert> dcoutts: sweet
10:57:11 <dcoutts> or even fopencookie
10:57:17 <dcoutts> but it's not portable
10:57:20 <dcoutts> it's GNU only
10:57:32 <ibid> #define _GNU_SOURCE
10:57:33 <ibid> :)
11:00:30 <bringert> I guess I'll go with tmpfile(3) for now, since it seems to be the easiest to implement, and probably the most portable
11:01:11 <bringert> I'll remember the other suggestions for the future
11:06:28 <Lor> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
11:06:29 <lambdabot> f :: (a -> b -> c) -> (a -> b) -> a -> c
11:06:29 <lambdabot> f x1 x2 x3 = x1 x3 (x2 x3)
11:06:46 <Lor> Pretty effin cool.
11:12:42 <shapr> lennart: Is proof programming a real 'paradigm' in that there are tools, mailing lists, discussion groups, whatever? I've found NuPRL, but not much else... Can you give me more pointers?
11:13:57 <shapr> Epigram seems to be closer to 'proof assistant' than 'programming language' in my view. But then, I've never used any proof assistants, so I can't be sure.
11:14:08 <lennart> shapr: I don't know how big the field of automatic search is, but using types as specifications is pretty big.
11:14:15 <SyntaxNinja> my dad got me & my brother confused and accidentally told me what he's getting me for xmas
11:14:35 <lennart> shapr: but you need more to make complete specifications with types *more as in dependent types)
11:14:52 * xerox shakes lennart hand complimenting for the Djinn.
11:15:25 <lennart> shapr: cayenne is a programming language rather than a proof assistant
11:15:38 <shapr> Yeah, Djinn is way cool. I just posted a story to LtU about Djinn: http://lambda-the-ultimate.org/node/view/1178
11:15:39 <lennart> tanks, xerox
11:15:43 <tic> ohh, celebs! Nifty. :)
11:16:04 <lennart> there will be a new version of djinn very soon.  it has data types now
11:16:19 <tic> yay, the oral exam schedule is up now as well. Nifty.
11:16:40 * tic picks a time
11:16:53 <jethr0> i tried to fix the pretty printing... it's a little better now, but still far from perfect
11:16:56 <jethr0> $pretty fun x | x < 0 = -1 | x == 0 = 0 | x > 0 = 1
11:16:56 <jethr0_bot> #  fun x  | x < 0 = - 1
11:16:56 <jethr0_bot> #         | x == 0 = 0
11:16:56 <jethr0_bot> #         | x > 0 = 1
11:17:06 <shapr> I haven't gotten around to trying Cayenne yet, but it would be nice to compare it to Epigram.
11:17:43 <tic> lennart, sorry for talking about "work". But what's going to be on the oral exam?
11:17:45 <lennart> shapr: they are very different in many ways
11:18:05 <lennart> tic: you think i'd tell you that?
11:18:20 <shapr> I want to know more about dependent types and proof programming/assistants.
11:18:37 <Lor> @djinn (forall r. (a -> r) -> r) -> a
11:18:38 <lambdabot> -- f cannot be realized.
11:18:38 <tic> lennart, haha. well, what -kind- of questions, then?  "explain the category-theory-view of a monad". Stuff like that? :P
11:18:42 <Lor> Bah.
11:18:46 <Lor> Sorry. :)
11:19:33 * bringert is playing with his own dependently typed language. It doesn't have a type checker yet. So it is probably the world's only dependently untyped language.
11:20:06 <shapr> Hey, I'm moving to Stockholm in the summer, are there ever open-to-the-public type theory or haskell gatherings at Chalmers?
11:20:23 <lennart> tic: some questions you can answer if you have followed the course and done the assignments
11:20:23 <bringert> shapr: Chalmers is in G√∂teborg :-P
11:20:44 <shapr> bringert: Yeah, I know, but it's not extremely far away by train. Unlike Boden...
11:20:53 <Lor> Aren't lectures in public institutions in principle open to everyone?
11:21:00 <lennart> yes
11:21:02 * shapr doesn't know
11:21:04 <lennart> kinda
11:21:09 <Lor> Yeah, kinda.
11:21:36 <bringert> I guess the problem is knowing where and when to be
11:22:43 <Lor> Aren't class schedules visible in the web?
11:23:22 <lennart> bringert: actually, I don't think your language is the only one.  as usual (Common) LISP can claim to be first ;)
11:23:53 <tic> lennart, cool. thanks. Enough bugging you. :)
11:24:03 <bringert> well, it doesn't pretend to be strongly typed
11:24:19 <bringert> LISP doesn't, that is
11:24:48 <lennart> be careful with what words you use, it's dynamically types, but as strongly types as Haskell :)
11:25:08 <lennart> s/types/typed/
11:25:15 <tic> category theory.. I want AAFP for LP3!
11:25:16 <bringert> hmm, right
11:25:35 * SamB thinks haskore would benefit from a compact notatation at the phrase level
11:25:45 <tic> same as in Python, where you have dynamically strong types?
11:26:01 <lennart> yes
11:26:26 <shapr> SamB: like what?
11:26:36 <SamB> eh, dynamic types aren't strong enough to handle type classes...
11:26:56 <SamB> shapr: well, maybe a bit like lilypond's notation
11:26:56 <bringert> I think we are using strong in different senses
11:27:13 <astrolabe> would it be theoretically possible to make a djinn that finds ALL functions of a type, if there are a finite number?
11:27:24 <lennart> yes, it's a terminology swamp
11:27:35 <shapr> I like Frank Atanassow's description of dynamically checked languages as just missing a library that allows them to be checked ahead of time.
11:27:51 <musasabi> /c/c
11:27:57 <lennart> astrolabe: I don't think it's decidable if there's a finite number of them :(
11:27:59 * shapr CCs musasabi 
11:28:21 <astrolabe> lennart: thanks
11:28:28 <lennart> astrolabe: so i think the answer is no
11:28:43 <bringert> maybe it could find and print all of them and then loop looking for more?
11:28:47 <astrolabe> lennart: it doesn't follow though does it?
11:29:03 <shapr> Can it return a lazy list of functions?
11:29:09 <lennart> i'm not certain, it;s just  hunch
11:29:20 <lennart> it does return a lazy list of functions
11:29:56 <shapr> ah, ok
11:29:58 <lennart> but djinn is terminating, so you will ever only get a finite number
11:29:58 * SamB doesn't want to have to say "use types" in every source file
11:30:04 * shapr hasn't looked at the source yet.
11:30:21 <roconnor> @djinn (a -> a) -> a -> a
11:30:22 <lambdabot> f :: (a -> a) -> a -> a
11:30:22 <lambdabot> f x1 x2 = x1 x2
11:30:30 <lennart> with the new djinn you can do ':set +m' to get many answers
11:30:30 <shapr> At least, not past finding keywords to stick into Google.
11:31:34 <lennart> the new djinn also sorts the answers by default, so you're more likely to get what you want first
11:31:42 <astrolabe> cool. Does that work with @djinn?
11:32:01 <lennart> i don't think dons has installed the new version
11:32:37 <lennart> i'll announce a new version as soon as i've written a kind checker to ensure that type synonym expansion terminates
11:32:51 <bringert> @djinn FilePath -> IO String
11:32:51 <lambdabot> -- f cannot be realized.
11:32:57 <roconnor> @djinn ((((a -> b) -> a) -> a) -> b) -> b
11:32:57 <lambdabot> f :: ((((a -> b) -> a) -> a) -> b) -> b
11:32:57 <lambdabot> f x1 = x1 (\ c13 -> c13 (\ c15 -> x1 (\ _ -> c15)))
11:33:09 <SamB> hmm, Haskore could use a lot of updating...
11:33:17 <SamB> it was apparantly written before monad transformers...
11:33:23 <bringert> hmm, didn't someone write something for looking up functions in the standard libs by type?
11:33:31 <shapr> SamB: Are you using Henning Thieleman's rewritten version from cvs.haskell.org?
11:33:36 <shapr> bringert: @hoogle
11:33:36 <roconnor> @hoggle FilePath -> IO String
11:33:37 <lambdabot> Prelude.readFile :: FilePath -> IO String
11:33:37 <lambdabot> System.IO.readFile :: FilePath -> IO String
11:33:37 <lambdabot> Prelude.getLine :: IO String
11:33:39 <shapr> by ndm 
11:33:47 <lennart> roconner, double negation of pierce axiom, eh?
11:34:02 <bringert> what if you compiled hoogle with djinn? 
11:34:03 <SamB> shapr: rewritten version?
11:34:03 <SamB> where?
11:34:12 <bringert> eh, s/compiled/combined/
11:34:19 <SamB> shapr: it needs linkage badly, methinks
11:34:28 <shapr> SamB: http://cvs.haskell.org/darcs/haskore/
11:34:36 <lennart> yes, a combination would be interesting
11:34:49 <shapr> lambdabot is reaching critical mass.
11:35:07 * shapr suspects the first AI will be purely functional, and spend its spare time on #haskell
11:35:18 <bringert> it already does
11:35:23 <bringert> @vixen don't you?
11:35:24 <astrolabe> Is there a simple example which makes djinn introduce a dummy variable, to help me think about it?
11:35:24 <lambdabot> what about me?
11:35:29 * shapr grins
11:35:32 <SamB> @where+ Haskore http://cvs.haskell.org/darcs/haskore/
11:35:32 <lambdabot> Done.
11:35:53 <shapr> SamB: The downside of the new Haskore is that it's no longer so very simple in implementation.
11:35:59 * bringert remembers that he should finish his misspelling engine
11:36:10 <shapr> The original Haskore had a beautifully transparent implementation.
11:36:10 <lennart> astrolabe: what do you mean by a dummy variable?
11:36:36 <SamB> shapr: probably due to the fact that much of it shows up in the tutorial?
11:36:39 <astrolabe> as in \x -> x+1
11:36:53 <shapr> Could be
11:37:05 <astrolabe> oh, maybe I'm asking nonsense.
11:37:06 <roconnor> lennart, yep
11:37:24 <shapr> I wish I could get hold of Dance, I want to apply type theory to martial arts.
11:37:36 <SamB> but I'd definately appreciate nice notation as well as nice code...
11:37:37 <roconnor> lennart, I want to use that function sometime.
11:37:41 <roconnor> but I don't know what it does.
11:37:42 <astrolabe> I mean a variable with a '\' in front of it.
11:37:52 <SamB> type theory to martial arts?
11:38:01 <lennart> roconnor> there's also the Void type for weird stuff
11:38:08 <SamB> how does haskore use type theory?
11:38:10 <shapr> Yeah, have you read about Hudak's Dance DSL?
11:38:16 <musasabi> lennart: the new djinn is very nice.
11:38:22 * musasabi just inferred maybe
11:38:28 <SamB> more than any other haskell app, I mean
11:38:33 <roconnor> Void type?
11:38:35 <lennart> @djinn ((Either a (a->Void) -> Void) -> Void
11:38:36 <lambdabot> Terminated
11:38:42 <musasabi> lennart: However it seems that Djinn does not like recursive datatypes.
11:38:53 <musasabi> data List a = Cons a (List a) | Nil
11:38:59 <musasabi> map ? (a -> b) -> List a -> List b
11:39:00 <SamB> shapr: this repo could use a checkpoint, methinks
11:39:06 <lennart> roconnor: the empty type, logical absurtity
11:39:19 <musasabi> dies with Stack overflow.
11:39:19 <lennart> recursion is right out!
11:39:51 <lennart> i've not put in the recursion check, just a warning in the docs :)
11:40:02 <roconnor> @djinn (forall a. a)
11:40:03 <lambdabot> -- f cannot be realized.
11:40:07 <ndm> bringert: i have already asked about combining djinn with hoogle, and its on the hoogle todo list
11:40:42 <musasabi> lennart: is it hard to do?
11:40:56 <SyntaxNinja> hi lennart!
11:41:03 <musasabi> that is implementing recursion, if we don't care about termination of the finished program
11:41:09 <musasabi> s/finished/generated/
11:41:19 <lennart> musabi: i need a kind checker.  should be a couple of hours at most
11:41:33 <lennart> oh, as i said, recusrion is right out!
11:41:42 <roconnor> @djinn ((Either b (b -> (forall a. a)) -> (forall a. a)) -> (forall a. a)
11:41:43 <lambdabot> Terminated
11:42:00 <lennart> roconnor> no foralls :(
11:42:21 <lennart> seems lambdabot is getting slower and slower
11:42:51 <lennart> ok, time to write the kind checker
11:50:25 <shapr> hey CosmicRay, any smoke damage?
11:50:59 <lennart> what happened?
11:51:19 <CosmicRay> lennart: http://www.lawnandlandscape.com/news/news.asp?ID=3995
11:51:27 <CosmicRay> basically, a compressor blew up near our power mains
11:52:23 <lennart> oops
11:52:58 <CosmicRay> yeah
11:53:18 <CosmicRay> so my irc session is being powered by a diessel generator the phone company brought over
11:54:34 <CosmicRay> so how many times have you had a call from a friend that soudns like this: "So, did you know your workplace is on fire and TV crews are out there?"  "Uhm, no...."
11:54:45 <CosmicRay> this was a first for me ;-)
11:55:53 <Philippa_> the last time it happened to a friend it was pretty much a normal day
11:55:57 <Philippa_> thing is, his luck *really* stinks
11:56:21 <Philippa_> having his workplace aflame was better than eg the time he got stung on his one remaining testicle by a bee...
11:56:45 <CosmicRay> uhm, that would really suck.
11:57:13 <CosmicRay> shapr: our network/servers are all fine.
11:57:25 <shapr> That's nice.
11:57:32 <CosmicRay> shapr: but they are in the basement, which is where all the sprinkler, fire truck, and broken water main runoff went.
11:57:46 <shapr> Are they swimming?
11:57:51 <CosmicRay> so we had a crew of 6 down here until midnight with squeeges defending the equipment
11:58:09 <CosmicRay> fortunately we kept all the water at least 6 inches away from the raised floor ;-)
11:58:18 <shapr> That's good to hear.
11:58:21 <Philippa_> CosmicRay: I'm pretty sure a similar word came to his mind, but "suck" wasn't it...
11:58:28 <CosmicRay> heh
11:59:04 <CosmicRay> so yeah, we're at a small lull while people are at lunch but I figured the chances of getting HWN out this week are looking depressingly slim
11:59:47 <chrisbro1n> evening all
12:00:48 <CosmicRay> at first it seemed that the T1 may have literally burned up
12:01:36 <CosmicRay> here is another funny call.  our ISP called my cellphone, while I was outside by the fire trucks: "Hey John, we noticed your T1 is down and have placed a call..."  "Don't bother.  It's on fire."  "Uhm, did you say 'on fire'?"  "Yes, there's a fire in the building."  "Ahhh...."
12:05:31 <SamB> shapr: that haskore doesn't like my GHC.Handle.openFd
12:07:45 <shapr> Send a patch?
12:08:45 <SamB> why is it using that, is what I want to know...
12:08:49 <SamB> looks quite low level...
12:09:31 <Heffalump> CosmicRay: lol
12:09:41 <Heffalump> (sorry to hear about the fire, though)
12:11:31 <shapr> I think the new Haskore integrates with csound.
12:12:12 <shapr> iirc, Bastiaan Zapf got the new Haskore to produce infinite streams for stuff like aural lorenz fractals.
12:12:34 <shapr> I think he did that with csound.
12:14:31 <chucky> cool
12:14:44 <tibbe> How do I run a State monad in the IO monad, IO (State s a)?
12:15:46 <SamB> shapr: hmm, the one I grabbed also claims Csound support
12:17:21 <SamB> @type Control.Monad.State.runState
12:17:22 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
12:17:33 <jethr0> > 3+2
12:17:35 <lambdabot> 5
12:17:48 <Taral> @hoogle replicateM
12:17:48 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
12:17:48 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
12:25:25 <Saulzar> Hmmm, has anyone used HOpenGL with textures? For the life of me I can't find where to generate a texture ID as per glGenTextures
12:25:40 <Saulzar> Everything else seems to be there.. but that seems to be a key one :)
12:26:43 <tibbe> @type lift
12:26:44 <lambdabot> Not in scope: `lift'
12:26:54 <shapr> Have you looked at the ported nehe tutorials by Lemmih and lispy ?
12:26:58 <tibbe> @type Control.Monad.Trans.lift
12:26:59 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
12:26:59 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
12:26:59 <lambdabot> m a -> t m a
12:29:14 <Saulzar> Ah hah, found it... a #haskell log between lispy and Lemmih as it turns out has the answer :)
12:34:22 <SamB> shapr: it claims I have a bad patch when I didn't touch any of the things whose tests fail...
12:37:59 <Taral> whee!
12:38:00 <Taral> TArray.hs
12:38:35 <SamB> Taral: what is that for?
12:38:43 <Taral> Control.Concurrent.STM.TArray
12:38:59 <SamB> what is the purpose of your wheeing?
12:39:05 <Taral> It's nifty.
12:39:20 <Taral> I wrote it.
12:39:24 <SamB> ah
12:39:28 <Taral> I'm not sure of the efficiency of the construction though:
12:39:33 <SamB> for what?
12:39:38 <Taral>     newArray b e = do
12:39:38 <Taral>         a <- replicateM (rangeSize b) (newTVar e)
12:39:38 <Taral>         return $ TArray (listArray b a)
12:39:44 <Taral> type is:
12:39:44 <Taral> newtype TArray i e = TArray (Array i (TVar e))
12:40:15 <SamB> Taral: not terribly efficient, about twice as bad as Array itself
12:40:25 <SamB> which isn't too bad itself...
12:40:38 <Taral> well, listArray gets rewritten to listArrayST
12:41:23 <SamB> assuming it has the desired semantics 
12:41:23 <Taral> Is there a way to let ST call back into STM?
12:41:23 <SamB> why ST?
12:41:25 <Taral> because I can build the array in ST
12:41:39 <Taral> if ST calls back into STM, I can remove the intermediary list.
12:42:22 <SamB> well, you could use unsafeIOToST or whatever it is called
12:42:38 <Taral> hm!
12:44:04 <Taral> @hoogle unsafeIOToSTM
12:44:05 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
12:45:05 <Taral> I could use unsafeIOToST (atomically (newTVar e))
12:45:20 <Taral> or...
12:45:28 <Taral> I could use newTVarIO
12:45:43 <Taral> since unsafe* . atomically crashes :)
12:46:49 <SamB> yeah, thats cause atomically isn't reentrant
12:47:51 <SamB> shapr: to whom shall I send this patch?
12:53:59 <lightstep> @wiki LibraryDocumentation/CPUTime   <-- the last example does not need print (and even if it needed, it should be eta-converted)
12:54:00 <lambdabot> http://www.haskell.org/hawiki/LibraryDocumentation/CPUTime   <-- the last example does not need print (and even if it needed, it should be eta-converted)
12:56:56 <Taral> @hoogle unsafeIOToST
12:56:57 <lambdabot> Control.Monad.ST.Lazy.unsafeIOToST :: IO a -> ST s a
12:56:57 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
12:56:57 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
12:57:14 <Taral> @type Control.Concurrent.STM.unsafeIOToSt
12:57:15 <lambdabot> Not in scope: `Control.Concurrent.STM.unsafeIOToSt'
12:57:16 <Taral> @type Control.Concurrent.STM.unsafeIOToST
12:57:17 <lambdabot> Not in scope: `Control.Concurrent.STM.unsafeIOToST'
12:57:49 <Taral> durr
12:58:27 <Taral> @hoogle listArray
12:58:28 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i
12:58:28 <lambdabot> e
12:58:28 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
12:58:28 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
12:58:28 <lambdabot> m (a i e)
12:58:47 <flux__> lambdabot is afraid of evaluating even the type for those scary functions.. ;)
12:58:55 <Taral> ?
12:59:13 <Taral> @type Control.Concurrent.STM.unsafeIOToSTM
12:59:13 <lambdabot> Not in scope: `Control.Concurrent.STM.unsafeIOToSTM'
12:59:15 <Taral> heh
12:59:21 <Taral> don't remember where that one hides
12:59:27 <Taral> @type  GHC.Conc.unsafeIOToSTM
12:59:27 <lambdabot> forall a. IO a -> GHC.Conc.STM a
12:59:29 <flux__> @index unsafeIOToSTM
12:59:29 <lambdabot> GHC.Conc
12:59:51 <xah> does anyone uses rss or atom?
13:01:18 * ADEpt made conjure REALLY download the whole file without violating the protocol
13:01:59 <ndm__> lightstep, please patch the CPU time example :) i don';t understand monads...
13:02:07 <flux__> so it's really close to being usable?-o
13:03:43 <ADEpt> flux__: well, as soon as jlouis will have FS-related code in "connectable" state... It almost is now. Almost, but not quite.
13:03:53 <ADEpt> flux__: right now it is usable only as fun toy :)
13:04:36 <Taral> @index newTVar#
13:04:37 <lambdabot> bzzt
13:10:47 <Taral> @version
13:10:48 <lambdabot> lambdabot 3p227, GHC 6.5.20050806 (Linux i686)
13:10:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
13:10:58 <Taral> @type GHC.Conc.newTVarIO
13:10:59 <lambdabot> Not in scope: `GHC.Conc.newTVarIO'
13:11:10 <Taral> ooh, too old
13:11:19 <Taral> need 20051206
13:14:29 <sdjp> Anyone know of any papers that give a decent overview of the performance of Haskell (particularly numeric performance)? google's not giving me anything other than ancedotes...
13:15:50 <neologism> I saw some interesting comparison of langauges
13:15:53 <neologism> but dont remember url :(
13:16:31 <flux__> sdjp, well, wildly misleading benchmarks may be found at language shootout (google it)
13:16:36 <flux__> but atleast you'll get some numbers!
13:17:10 <sdjp> Yeah, seen shootout.  but that's not quite rigourus.
13:17:13 <Saulzar> Not sure about papers, but there are some libraries (although I guess they're mostly interfaced to C) hmatrix
13:19:40 <ADEpt> sdjp: IMO, haskell performance will be more or less determined by speed of libgmp (if we are not talking about unboxed "real" ints doubles etc). So you could direct your reserch there.
13:20:59 <ADEpt> I've done code which communicates over network, but I am complete newbie at handling errors. Any hints (most interested in conn. refused and conn. closed)?
13:21:22 <dcoutts> ADEpt, that's only if you write code that uses the Integer type a lot. I rarely see code that uses Integer rather than Int.
13:21:41 <Saulzar> I guess there is numeric and then there is numeric computation
13:21:53 <eivuokko> Hehe, indeed.
13:25:24 <ADEpt> dcoutts: Int is platform-indep, Integer is platform-dep int, right? Or have I got it completely backwards?
13:28:10 <Saulzar> I guess Int is (mostly) native int 
13:28:25 <dcoutts> ADEpt, Int is a bounded integer. Integer is an arbitrary sized integer. Both are perfeclty portable.
13:28:54 <dcoutts> Int will usually be implemented with a native machine word
13:28:58 <dcoutts> so it's fast.
13:29:17 <dcoutts> Integer uses some other implementation that can deal with very large numbers.
13:29:28 <Saulzar> What is the story with the 30 bit thing? It is using 1 bit for GC and 1 for lazy?
13:29:35 <dcoutts> GHC use the gmp library to implement the Integer type
13:30:17 <dcoutts> Saulzar, the h98 spec says that Int but be at least a certain number of bits (I think it's 28 ot 30 or something)
13:30:34 <dcoutts> but GHC and hugs use a full 32 bits
13:30:58 <ADEpt> dcoutts: thanks
13:31:08 <dcoutts> an implementaion could reserve a bit or two for it's own purposes if it wanted to, but none do.
13:31:28 <Saulzar> Hmm. I See
13:31:39 <dcoutts> So with GHC, Int is 32 or 64 bit depending on the machien you're using.
13:37:09 <Heffalump> dcoutts: doesn't/didn't nhc do so?
13:38:06 <dcoutts> Heffalump, really? I didn't know about it.
13:39:20 <shapr> sdjp: Check out Simon Marlow's Haskell Webserver paper.
13:44:18 <tibbe> anyone know how to get good LaTeX type-setting of Haskell code?
13:44:35 <basti_> tibbe: there are 2 packages for that iirc
13:45:01 <sdjp> good call shapr; exactly the sort of thing I was looking for - well, most of it, anyway.
13:45:04 <basti_> http://www.cse.unsw.edu.au/~chak/haskell/haskell-style.html
13:45:19 <lennart> where's dons?  we need a new @djinn here :)
13:45:38 <dcoutts> @where lhs2tex
13:45:39 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
13:45:49 <dcoutts> tibbe, lhs2tex is the other good one
13:45:51 * kosmikus feels summoned
13:45:57 <dcoutts> heh
13:46:08 <tibbe> basti_, I've tried the listings package and it works but make standard types as well as keyword bold, I only want bold keywords
13:47:11 <tuomov> you can redefine keywords
13:47:18 <tibbe> tuomov, how?
13:47:21 <tuomov> and I think listings had two sets of keywords.. maybe you can just change the style
13:47:25 <tuomov> RTFM
13:48:10 <basti_> i think the two specialized packages are pretty good
13:48:27 <kosmikus> lennart: nice to see you on this channel
13:48:33 <basti_> recently one guy was like "how do i stop latex making a break before tabular's"
13:48:42 <Taral> is there a tangle/weave for haskell?
13:49:07 <lennart> ty, kosmikus
13:49:59 <SamB> shapr: I repeat: to whom shall I send this patch?
13:57:43 <tibbe> basti_, lhs2tex only works on literate haskell?
13:57:47 <shapr> Henning Thieleman is the maintainer, afaik.
13:58:43 <jethr0> tibbe, but it's trivial to convert .hs to .lhs, right?
13:58:52 <shapr> lennart: Dons often arrives on #haskell around midnight Swedish time.
13:59:36 <SamB> tibbe: why would you want to use it on illiterate Haskell?
13:59:54 <xerox> Goodnight.
14:00:18 <basti_> tibbe: -shrug-
14:00:21 <shapr> g'nite xerox 
14:02:42 <jethr0> $pretty fun x | x < 0 = -1 | x == 0 = 0 | x > 0 = 1
14:02:43 <jethr0_bot> #  fun x  | x < 0 = - 1
14:02:43 <jethr0_bot> #         | x == 0 = 0
14:02:43 <jethr0_bot> #         | x > 0 = 1
14:02:52 <jethr0> i partially fixed it :)
14:03:31 <shapr> So, anyone know of paying Haskell work that I can do remotely? :-)
14:03:41 * shapr is rather tired of working on Plone.
14:03:58 <kosmikus> tibbe: you're talking about a LaTeX document with Haskell code in it, which usually *is* Literate Haskell ...
14:04:01 * jethr0 is looking for paying haskell work anywhere...
14:04:40 <jethr0> kosmikus, basically prepending all lines with a ">" and i think one line of header will convert .hs into .lhs
14:05:56 <SamB> jethr0: ugh, bird feet..
14:07:05 <jethr0> samb, i couldn't figure out a way to cleanly disable lambdabot's indentation-scrambling
14:07:12 <jethr0> so i had to prefix with something non-' '
14:07:36 <jethr0> would you prefer '>' ?
14:07:38 <SamB> jethr0: I was referring to your comment about literate haskell
14:07:47 <jethr0> ah
14:08:02 <shapr> SamB: Does conjure use Igloo's SHA1 for FPS from darcs?
14:08:09 * kosmikus was thinking about \begin{code} ... \end{code}, but '> ' will do as well
14:08:11 <SamB> shapr: um, no
14:08:21 <shapr> Is conjure using FPS internally?
14:08:28 <SamB> not a whole lot yet
14:08:53 <tibbe> jethr0, yes but I just want to put some small code blocks in a larger tex document, not format whole files
14:08:56 <SamB> I'm still waiting for musasabi to get some sleep so he can finish his patch
14:09:00 <tibbe> SamB, style preference?
14:09:12 <shapr> Lemmih: The sha1.lhs from combinatorrent takes more than half an hour to check a 200mb torrent.
14:09:40 <tibbe> kosmikus, isn't literate haskell .lhs files with lots of >
14:10:21 <kosmikus> tibbe: .lhs has code lines either prepended with '> ' or surrounded by \begin{code} ... \end{code}
14:10:48 <kosmikus> tibbe: both works with lhs2TeX, so it should be relatively easy to use it on a LaTeX source file. that's what it's made for, after all
14:11:40 <tibbe> I get:
14:11:42 <tibbe> *** Error in file ./temp.lhs line 1:
14:11:42 <tibbe> `code' is not defined;
14:11:42 <tibbe> perhaps you forgot to include "lhs2TeX.fmt"?
14:12:01 <tibbe> the file is just a data type declaration with lines with >
14:12:26 <SamB> tibbe: well, presumably its translating to \begin{code}...\end{code}
14:12:54 <kosmikus> tibbe: the file must be a LaTeX file
14:13:08 <kosmikus> and you must include lhs2TeX.fmt and lhs2TeX.sty
14:13:53 <tibbe> kosmikus, I'm feeling a bit thick, where exactly should I include those, I'm running lhs2TeX on a "pure" .lhs file, that is, a code file
14:14:44 <kosmikus> ah, so you want to keep the Haskell files external?
14:15:27 <tibbe> kosmikus, well, not neccesarly
14:15:36 * SamB spanks jlouis for not having tests for FS.Piece
14:15:38 <tibbe> kosmikus, I only want small code blocks in my .tex document :)
14:17:32 * Saulzar declares victory vs. the type checker
14:17:45 <tibbe> kosmikus, should I have a \usepackage{lhs2TeX} ?
14:18:20 <Lemmih> SamB: How far along are you with the announcer thread?
14:18:26 <lisppaste2> kosmikus pasted "lhs2TeX minimal file" at http://paste.lisp.org/display/14613
14:18:43 <kosmikus> tibbe: ^^
14:18:44 <SamB> Lemmih: we have tracker client code
14:18:49 <SamB> which I wrote
14:19:02 <Lemmih> It's done?
14:19:21 <SamB> I don't think we're going to worry about the thread until we have something worth announcing, hehe
14:19:45 <tibbe> kosmikus, thanks
14:20:06 <SamB> There should be a note in the source indicating that it needs cleanup once we actually have an idea where it will be used, so that it doesn't need so many arguments
14:21:18 <SamB> the most important things on this list seem to be bugging jlouis about tests
14:21:28 <SamB> and the other most important thing is missing
14:21:35 <tibbe> kosmikus, and then run lhs2TeX report.tex > my-new.file.tex ?
14:23:46 <kosmikus> lhs2TeX --poly report.tex > my-new.file.tex
14:23:59 <kosmikus> or better: lhs2TeX --poly report.lhs > report.tex
14:24:50 <kosmikus> (assuming you're using 1.9 or 1.10pre)
14:26:10 <tibbe> kosmikus, I finally get it, stupid me, I blame the fact that I haven't have any tea yet ;) thanks
14:27:07 <SamB> I don't even really understand the TODO entry for an announcer thread
14:28:12 <SamB> Lemmih: you can pull the patch from my repo now
14:28:39 <ADEpt> SamB: agree about the announcer thread.
14:28:50 <jethr0> @hoogle eval
14:28:50 <lambdabot> Control.Exception.evaluate :: a -> IO a
14:28:50 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
14:28:50 <lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a,
14:28:50 <lambdabot> w)
14:29:03 <Taral> @djinn :environment
14:29:03 <lambdabot> Invalid command
14:29:04 <jethr0> where was that damn eval again?
14:29:05 <SamB> I mean, I would pretty much think that the announcer thread would just sit there and announce
14:29:11 <SamB> every ten seconds or so
14:29:21 <ADEpt> SamB: btw, PeerTread is almost ready to be made into "seeder thread"
14:29:23 <SamB> or is that minutes?
14:29:30 * SamB forgets
14:30:06 <Speck> what does it mean that Djinn now accepts haskell data types?
14:31:43 <SamB> @djinn [a]
14:31:43 <lambdabot> -- f cannot be realized.
14:31:46 <Lemmih> SamB: Where's your repo?
14:31:48 <SamB> @djinn [Num]
14:31:49 <lambdabot> -- f cannot be realized.
14:31:55 <SamB> Lemmih: AUTHORS tells all
14:32:34 <lennart> Speck: it means that in the new Djinn you can make data type definitions and use them
14:32:58 <SamB> @help djinn
14:32:58 <lambdabot> Generates Haskell code from a type.
14:32:58 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:33:01 <Taral> @djinn f ? a -> a -> a
14:33:01 <lambdabot> Terminated
14:33:04 <Taral> ?!
14:33:08 <basti_> :-o
14:33:09 <Taral> @djinn a -> a -> a
14:33:09 <lambdabot> f :: a -> a -> a
14:33:09 <lambdabot> f _ x2 = x2
14:33:14 <Taral> @djinn a -> a -> a
14:33:15 <lambdabot> f :: a -> a -> a
14:33:15 <lambdabot> f _ x2 = x2
14:33:16 <SamB> @help [Int]
14:33:16 <lambdabot>  @help <command> - ask for help for <command>
14:33:18 <Taral> @djinn f ? a -> a -> a
14:33:18 <lambdabot> Terminated
14:33:18 <SamB>  [Int]
14:33:23 <Taral> time to upgrade djinn!
14:33:25 <basti_> @djinn [a] -> Int -> a
14:33:25 <SamB> @djinn [Int]
14:33:26 <lambdabot> -- f cannot be realized.
14:33:26 <lambdabot> -- f cannot be realized.
14:33:31 <basti_> :/
14:33:31 <Taral> new release today
14:33:52 <lennart> lists still won't work.  no recursive typesare allowed
14:33:52 <Taral> basti_: djinn might not know about Int
14:33:59 <Taral> oh, no recursive types
14:34:19 <Taral> @djinn ((a -> b -> b) -> b -> b) -> Int -> a
14:34:20 <lambdabot> -- f cannot be realized.
14:34:28 <SamB> oh, right, [] is recursive
14:34:31 <Taral> @djinn ((Int -> b -> b) -> b -> b)
14:34:31 <lambdabot> f :: (Int -> b -> b) -> b -> b
14:34:31 <lambdabot> f _ x2 = x2
14:34:33 <basti_> ah
14:34:34 <lennart> I'll have to think hard about recursive types
14:34:35 <SamB> @djinn Int
14:34:35 <lambdabot> -- f cannot be realized.
14:34:49 <Taral> @djinn (a -> a) -> a -> a
14:34:50 <lambdabot> f :: (a -> a) -> a -> a
14:34:50 <lambdabot> f x1 x2 = x1 x2
14:34:58 <Taral> interesting
14:35:00 <Taral> not f _ x2 = x2
14:35:14 <Speck> lennart: could djinn be integrated into hIDE to generate code interactively? that would be cool.
14:35:15 <Taral> the latest version of djinn supports outputting multiple answers
14:35:29 <Taral> @index build
14:35:29 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.
14:35:29 <lambdabot> Exts
14:35:34 <lennart> Speck: I'm sure it could
14:35:36 <Taral> @type GHC.Exts.build
14:35:36 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
14:35:55 <Speck> generate correct stub code -- could be a boon for productivity :-D
14:36:08 <Taral> What's the inverse of build?
14:36:10 <Taral> @type foldr
14:36:11 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:36:16 <ndm> lennart: ping
14:36:20 <lennart> yes?
14:36:28 <Taral> @pl \l c n -> foldr c n l
14:36:28 <lambdabot> flip (flip . foldr)
14:36:33 <ndm> i got a compile error on djiin
14:36:33 <Taral> that's the inverse of build :(
14:36:37 <ndm> C:\Documents\Uni\contrib\Djinn>ghc --make Djinn
14:36:39 <ndm> Chasing modules from: Djinn
14:36:41 <ndm> Could not find module `Util.Digraph':
14:36:42 <ndm>   use -v to see a list of the files searched for
14:36:44 <ndm>   (imported from ./HCheck.hs)
14:36:52 <lennart> oops
14:36:54 <lennart> hang on
14:36:57 <Taral> lennart: Why not use the functional equivalent types like I was showing?
14:37:14 <Taral> [a] => (forall b. (a -> b -> b) -> b -> b)
14:37:20 <Taral> assuming you can deal with that predicate
14:38:44 <lennart> ndm> fixed
14:39:02 <ndm> lennart, thanks
14:39:14 <ndm> a few other questions - how likely is it to return a lot of results?
14:39:14 <lennart> Taral: no foralls
14:39:38 <ndm> and does it ever take a long time to run? if i'm running it on haskell.org for every hoogle query :)
14:39:38 <lennart> ndm: it very often returns a list, often with repetitions :)
14:40:14 <lennart> ndm: there's a constant cutOff that you might want to lower to limit the number of solutions it generates
14:40:39 <ndm> lennart, well for hoogle searching, 1 is probably the most i want, since it would only be a tip at the top
14:40:54 <lennart> foralls are as difficult as recursive definitions.  it's no longer decidable
14:40:55 <ndm> thanks, built successfully
14:41:43 <lennart> ndm: 5 or 10 probably isn't bad.  it can still take a very long time if you give it a tricky question with no answers
14:42:01 <ndm> ah well, occasionally thats fine - its not my server ;)
14:42:07 <lennart> he
14:44:41 <Taral> lennart: Is there not a best-effort solver for foralls?
14:48:24 <Taral> hm...
14:48:28 <Taral> coq is written in ocaml
14:48:35 <Taral> any proof assistants/theorem provers in Haskell?
14:49:01 <SamB> Agda is kindof one...
14:49:16 <Taral> @where Agda
14:49:16 <lambdabot> I know nothing about agda.
14:50:02 <kosmikus> http://www.cs.chalmers.se/~catarina/agda/
14:50:21 <SamB> @where+ Agda http://www.cs.chalmers.se/~catarina/agda/
14:50:21 <lambdabot> Done.
14:51:05 <SamB> I dunno if you want to count Omega or that other thing...
14:51:08 <Lor> And alfa, of course.
14:51:17 <SamB> Lor: well, yeah.
14:51:20 <Lor> And, well, pesca. :)
14:51:20 <tibbe> Catarina is one of my professors :)
14:51:24 <SamB> but where can you find those?
14:51:39 <SamB> and what will they build with?
14:52:05 <Taral> Agda doesn't look like a proof system
14:52:08 <SamB> might as well try to compile Cayenne or whatever its called
14:52:11 <kosmikus> Alfa is just an interface for Agda, isn't it?
14:52:16 <Lor> Yeah.
14:53:09 <SamB> Taral: looks can be decieving
14:53:28 <twb> Is there a built-in for this:
14:53:30 <twb> every f [] = True
14:53:30 <twb> every f (x:xs) = f x && every f xs
14:53:47 <kosmikus> all
14:53:48 <SamB> > all odd [1,3..]
14:53:51 <twb> Thanks.
14:53:53 <lambdabot> Terminated
14:53:54 <SamB> hmm
14:53:57 <twb> @t all
14:53:57 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
14:53:57 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
14:53:59 <SamB> perhaps not the best example...
14:54:02 <twb> @type all
14:54:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:54:11 <twb> @index (a -> Bool) -> [a] -> Bool
14:54:11 <lambdabot> bzzt
14:54:12 <SamB> > all odd ([1,3..] :: [Int])
14:54:17 <lambdabot> Terminated
14:54:25 <twb> @hoogle (a -> Bool) -> [a] -> Bool
14:54:26 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
14:54:26 <lambdabot> Data.List.all :: (a -> Bool) -> [a] -> Bool
14:54:26 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
14:54:28 <SamB> > all odd ([1,3..maxBound] :: [Int])
14:54:33 <lambdabot> Terminated
14:54:45 <SamB> > all odd [1,3..10000]
14:54:46 <lambdabot> True
14:55:11 <twb> I guess none f = all (not . f) ?
14:55:20 <twb> Er, wait.
14:55:25 <twb> I guess none f = any (not . f) ?
14:55:27 <SamB> > none odd [1,3..10000]
14:55:28 <lambdabot>  Not in scope: `none'
14:55:47 <astrolabe> @type any
14:55:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:55:52 <SamB> none = not . any
14:55:56 <SamB> or something like that
14:56:02 <SamB> none f = not . any f
14:56:03 <twb> Yeah.
14:56:11 <SamB> @pl none f = not . any f
14:56:11 <lambdabot> none = (not .) . any
14:56:28 <Cale> Taral: apparently lennart implemented my suggestion :)
14:56:41 <jimapple> @djinn a -> [a]
14:56:41 <kosmikus> twb's first choice should also be ok
14:56:41 <lambdabot> -- f cannot be realized.
14:56:53 <SamB> @djinn a -> b
14:56:53 <lambdabot> -- f cannot be realized.
14:56:55 <jimapple> @listcommands djinn
14:56:56 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env
14:57:01 <SamB> @djinn a -> (a, a)
14:57:01 <lambdabot> f :: a -> (a, a)
14:57:01 <lambdabot> f x1 = (x1, x1)
14:57:06 <jimapple> @djinn-env
14:57:06 <lambdabot> type S s a = (s -> (a, s))
14:57:06 <lambdabot> type C a = (a -> r) -> r
14:57:06 <lambdabot> type Not x = x -> Void
14:57:07 <SamB> @pl a -> (a, a)
14:57:08 <lambdabot> (line 1, column 3):
14:57:08 <lambdabot> unexpected ">" or "-"
14:57:08 <lambdabot> expecting variable, "(", operator or end of input
14:57:13 <SamB> @pl a = (a, a)
14:57:14 <lambdabot> a = fix (join (,))
14:57:19 <SamB> hmm
14:57:28 <Cale> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
14:57:28 <lambdabot> -- f cannot be realized.
14:57:36 <jimapple> @type fix (join (,))
14:57:36 <lambdabot> Not in scope: `fix'
14:57:36 <lambdabot>  
14:57:36 <lambdabot> <interactive>:1:5: Not in scope: `join'
14:57:45 <Cale> @djinn Either a () -> (a -> Either b ()) -> Either b ()
14:57:45 <lambdabot> f :: Either a () -> (a -> Either b ()) -> Either b ()
14:57:45 <lambdabot> f x1 =
14:57:45 <lambdabot>   case x1 of
14:57:45 <lambdabot>   Left d2 -> \ x4 ->
14:57:45 <lambdabot>      case x4 d2 of
14:57:46 <SamB> @index fix
14:57:46 <Taral> @djinn a -> Maybe a
14:57:47 <lambdabot> [3 @more lines]
14:57:49 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
14:57:51 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
14:57:52 <jimapple> @type fix (Monad.join (,))
14:57:53 <Cale> @more
14:57:53 <lambdabot> Error
14:57:55 <lambdabot> -- f cannot be realized.
14:57:57 <lambdabot> Not in scope: `fix'
14:57:59 <lambdabot> more: empty buffer
14:58:00 <Taral> um
14:58:42 <Taral> djinn doesn't know about Maybe?
14:58:45 <jimapple> @djinn a -> Bool
14:58:46 <lambdabot> -- f cannot be realized.
14:59:05 <jimapple> @djinn a -> Either () ()
14:59:05 <lambdabot> f :: a -> Either () ()
14:59:05 <lambdabot> f _ = Right ()
14:59:11 <jimapple> @more
14:59:11 <lambdabot> more: empty buffer
14:59:17 <jimapple> that's weird
14:59:41 <soysauce> Taral - not yet
14:59:54 * SamB changes more to say "no more"
15:00:25 <jimapple> so, I was thinking about negation types and Ralf Hinze's equality type forall f . f a -> f b
15:01:33 <jimapple> if a is uninhabited, is a -> 0 inhabited?
15:01:36 <jimapple> if so, by what?
15:02:09 <jimapple> id? does that mean that all uninhabited types are equal?
15:02:17 <SamB> @djinn a -> ()
15:02:17 <lambdabot> f :: a -> ()
15:02:17 <lambdabot> f _ = ()
15:02:41 <Taral> a -> 0 is inhabited by (const 0)
15:02:47 <Taral> not id
15:02:59 <Lor> No, 0 is the empty type here.
15:03:04 <Taral> bah, (const ()) then
15:03:11 <jimapple> and so, should I be able to prove (a -> 0) -> (forall f . f a -> f 0)
15:03:12 <Lor> No, that's the unit type.
15:03:30 <Taral> is there no instance of 0?
15:03:32 <SamB> Lor: whatever nonsense are you spouting?
15:03:36 <jimapple> I mean 0 as a type, as in forall a . a
15:03:45 <Taral> oh
15:03:48 <SamB> jimapple: oh, you mean that type Dynamic uses?
15:03:49 <Lor> samb, "0" as a type means the empty type.
15:03:58 <jimapple> it is uninhabited (except for _|_)
15:04:01 <SamB> *abuses
15:04:20 <Lor> jimapple, djinn probably doesn't consider bottom.
15:04:24 <Taral> jimapple: Yes, I think so.
15:04:25 <SamB> @kind 0
15:04:26 <lambdabot> Only unit numeric type pattern is valid
15:04:33 <Lor> samb, it's just a pseudo-notation.
15:04:44 <SamB> @kind 1
15:04:45 <lambdabot> *
15:04:45 <jimapple> I don't know Dynamic well enough to say, and I don't know what type you're talking about: 0 or forall f . f a -> f b
15:04:47 <Lor> newtype Void = Void Void
15:04:55 <Lor> That's inhabited only by _|_.
15:05:04 <SamB> we don't need psuedo-notating
15:05:18 <Taral> Lor: It's inhabited by let a = Void a in a
15:05:27 <Lor> Yes, that's _|_.
15:05:28 <jimapple> which is bottom
15:05:30 <Taral> ah
15:05:32 <Taral> okay
15:05:33 <Cale> yay, it's capable of deriving bind in the maybe monad now
15:05:37 <SamB> Lor: thats probably illegal
15:05:46 <SamB> if you want that
15:05:50 <SamB> data Void
15:05:55 <SamB> is what you want to say
15:05:55 <Cale> (Though I used (Either a ()) as Maybe a)
15:06:13 <jimapple> so, replace all the 0's in my question with Void or (forall a . a)
15:06:16 <Taral> jimapple: I think all uninhabited types are equal
15:06:20 <Cale> data Void = Void Void is legal
15:06:36 <Cale> but in ghc, so is  data Void
15:06:38 <SamB> (forall a . a) isn't the same...
15:06:56 <Taral> SamB: It isn't?
15:06:57 <Lor> cale, yes, but data Void = Void Void has two elements.
15:07:05 <Lor> Void _|_ and _|_
15:07:05 <Cale> Lor: yeah
15:07:07 <SamB> you can pretend a value of type (forall a . a) is of whatever type you want ;-)
15:07:28 <Taral> I don't see why Void doesn't have \aleph_1 elements.
15:07:37 <Taral> _|_, Void _|_, Void (Void _|_), etc.
15:07:49 <jimapple> I'm not sure. If they are equal, I'd like to prove it:
15:07:49 <jimapple> @djinn (a -> (forall b . b)) -> (forall f . f a -> f (forall c . c))
15:07:50 <lambdabot> Terminated
15:07:57 <Lor> taral, true, sorry.
15:07:58 <Taral> jimapple: No foralls
15:08:06 <jimapple> yeah.
15:08:07 <SamB> Taral: newtypes don't lift
15:08:10 <Cale> newtype Void = Void Void
15:08:18 <jimapple> also, I it's Aleph_0
15:08:19 <Lor> We were talking about the "data" here.
15:08:19 <Taral> Cale: Aha, that's different
15:08:23 <Cale> right
15:08:26 <Taral> jimapple: Oops, yes, \aleph_0
15:08:31 <Lor> Who is not confused yet?
15:08:33 <Heffalump> @djinn a -> b
15:08:34 <lambdabot> -- f cannot be realized.
15:08:45 <Cale> it's interesting what the default Show instance does for that newtype :)
15:08:48 <SamB> "data Void" with no = sign gives a type with just the various _|_s
15:08:50 <Lor> Can we define new types for djinn?
15:08:53 <Cale> when showing Void undefined :)
15:09:01 <jimapple> @listcommands djinn
15:09:02 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env
15:09:06 * Taral compiles coq again.
15:09:07 <jimapple> @djinn-env
15:09:07 <lambdabot> type S s a = (s -> (a, s))
15:09:07 <lambdabot> type C a = (a -> r) -> r
15:09:07 <lambdabot> type Not x = x -> Void
15:09:10 <Lor> @help djinn-add
15:09:11 <lambdabot> Define a new function type or type synonym
15:09:28 <Lor> Oh, there's Void already?
15:09:35 <Taral> that's the absurd Void
15:09:38 <Heffalump> @djinn Void -> Void
15:09:38 <lambdabot> f :: Void -> Void
15:09:38 <lambdabot> f x1 = void x1
15:09:43 <Lor> @djinn a -> Not (Not a)
15:09:44 <lambdabot> f :: a -> Not (Not a)
15:09:44 <lambdabot> f x1 x2 = void (x2 x1)
15:09:53 <Lor> All right, cool.
15:09:54 <SamB> @djinn-type void
15:09:55 <lambdabot> Unknown command, try @listcommands.
15:10:04 <Taral> void :: Void -> a
15:10:06 <Heffalump> I think @djinn-env is only listing type aliases
15:10:09 <jimapple> sadly,
15:10:09 <jimapple> @djinn Not (Not a) -> a
15:10:10 <lambdabot> -- f cannot be realized.
15:10:11 <Heffalump> which is wrong
15:10:20 <Cale> Is that wrong?
15:10:27 <Lor> No recursive types?
15:10:34 <Taral> Lor: No recursive types.
15:10:46 <Taral> Heffalump: It's right. djinn doesn't have anything but recursive types (and void)
15:10:47 <Lor> If there were even Mu...
15:10:51 <Taral> Mu?
15:11:00 <Heffalump> Taral: where did it get void from?
15:11:02 <SamB> Lor: Mu is unreachable, duh
15:11:03 <Cale> It's based on intuitionistic logic -- ~~a doesn't imply a
15:11:05 <Taral> Heffalump: builtin
15:11:08 <Heffalump> oh, right
15:11:15 <Taral> it's the absurd tactic
15:11:18 <jimapple> and
15:11:18 <jimapple> @djinn ((a->r)->a)->a
15:11:19 <lambdabot> -- f cannot be realized.
15:11:35 <Taral> @djinn Not (Not (((a->r)->a)->a))
15:11:35 <lambdabot> f :: Not (Not (((a -> r) -> a) -> a))
15:11:35 <lambdabot> f x1 =
15:11:35 <lambdabot>   x1 (\ c16 ->
15:11:35 <lambdabot>    void (c16 (\ _ -> void (x1 (\ c27 -> c27))) (\ _ ->
15:11:35 <lambdabot>                   void (x1 (\ c29 -> c29)))))
15:11:44 <jimapple> wow
15:12:10 <Cale> @djinn a -> b
15:12:10 <lambdabot> -- f cannot be realized.
15:12:14 <Cale> @djinn Not (a -> b)
15:12:15 <lambdabot> -- f cannot be realized.
15:12:21 <Taral> Cale, what do you want it to print?
15:12:22 <Lor> There's a transformation for provable classical sentences to provable intuitive sentences.
15:12:27 <Lor> s/for/from/
15:12:29 <jimapple> @pl \x1 -> x1 (\ c16 -> void (c16 (\ _ -> void (x1 (\ c27 -> c27))) (\ _ -> void (x1 (\ c29 -> c29)))))
15:12:29 <lambdabot> ap id ((void .) . ap (flip . flip id . const . void . ($ id)) (const .
15:12:29 <lambdabot> void . ($ id)))
15:12:35 <Taral> ha
15:12:43 <soysauce> Num implies Ord, doesn't it?
15:12:58 <Cale> Taral: just curious if it had a proof of Not (a -> b), seeing as it says a -> b can't be realised :)
15:13:09 <Taral> nope
15:13:13 <Taral> a-> b is neither true nor false
15:13:19 <Taral> since it depends on what you substitute
15:13:24 <Cale> ah, right
15:13:40 <twb> In parsec, how do you represent x <|> epsilon?
15:13:42 <Cale> I'd need a forall :)
15:13:53 <Cale> optional x ?
15:14:02 <Cale> @index option
15:14:02 <lambdabot> Text.Html, Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators
15:14:02 <lambdabot> .Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
15:14:03 <SamB> twb: epsilon?
15:14:05 <Cale> option
15:14:13 <twb> SamB: epsilon means "nothing".
15:14:17 <Taral> Cale: No foralls
15:14:24 <twb> Cale: thanks.
15:14:28 <Taral> foralls and recursive types make the problem undecidable
15:14:29 <Cale> @type Text.ParserCombinators.Parsec.Combinator.option
15:14:30 <lambdabot> forall a st tok.
15:14:30 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
15:14:30 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
15:14:31 <SamB> optional also
15:14:37 <Cale> @type Text.ParserCombinators.Parsec.Combinator.optional
15:14:38 <lambdabot> forall st tok a.
15:14:38 <lambdabot> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
15:14:38 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
15:14:39 <SamB> @type Text.ParserCombinators.Parsec.Combinator.optional
15:14:40 <lambdabot> forall st tok a.
15:14:40 <lambdabot> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
15:14:40 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
15:14:58 <twb> optional or option?
15:15:05 <twb> The documentation suggests the latter.
15:15:09 <SamB> twb: well, do you want a value
15:15:12 <SamB> or not?
15:15:32 <jimapple> @djinn (() -> Void) -> Void
15:15:32 <lambdabot> f :: (() -> Void) -> Void
15:15:32 <lambdabot> f x1 = void (x1 ())
15:15:35 <twb> In this case, i'm parsing a block which has zero-or-one heading.
15:15:42 <jimapple> @djinn Void
15:15:42 <SamB> hmm?
15:15:43 <lambdabot> -- f cannot be realized.
15:16:07 <jimapple> @type void
15:16:08 <lambdabot> Not in scope: `void'
15:16:10 <twb> do h <- heading; b <- block; Block (h, b)
15:16:13 <Cale> heh
15:16:19 <mwc> Hey Cale, can I bug you for another group theory hint?
15:16:30 <Cale> somehow it mangled the printout of the type for option
15:16:35 <Cale> option  :: a -> GenParser tok st a -> GenParser tok st a
15:16:44 <Cale> hang on
15:16:46 <Cale> brb
15:18:18 <twb> The docs don't list "optional" in the index, but "option" is sufficient.
15:18:56 <twb> @index Maybe
15:18:57 <lambdabot> Data.Maybe, Prelude
15:19:02 <twb> @type Maybe
15:19:03 <lambdabot> Not in scope: data constructor `Maybe'
15:19:19 <Cale> okay, what was the question?
15:19:24 <twb> How do I get "Maybe = bleh" again?
15:19:40 <Cale> :info Maybe in ghci
15:19:45 <twb> @info Maybe
15:19:46 <lambdabot> Unknown command, try @listcommands.
15:20:14 <twb> Thanks.
15:20:47 <mwc> Cale, I'm trying to prove that if G is a p-group of order p^n, then every proper subgroup appears in a composition series for G. I can see how every p-subgroup of order p^k has a normal subgroup of order p^k - 1 and so their quotient group would be simple (iso to Z_p)
15:20:49 <twb> So I can say "optional Nothing foo", where foo :: GenParser tok st (Maybe a)
15:20:54 <mwc> I just can't figure out how to reverse it
15:23:25 <mwc> the hint on the problem is to use induction on n
15:23:31 <mwc> I just can't figure out the inductive step
15:23:51 <Cale> hmm
15:24:12 <mwc> should probably continue this over in #math, but I saw you here first
15:24:15 <twb> mwc: have you state the part you're assuming (i.e. n = n)?
15:24:22 <mwc> yeah
15:24:34 <mwc> I just can't figure out how to use that to prove n = k+1
15:24:37 <twb> OK.  That's as much help as I know how to give :-)
15:24:55 <Cale> p^(k-1)
15:25:15 <Cale> no?
15:25:27 <Cale> (as opposed to p^k - 1
15:25:28 <Cale> )
15:25:36 <soysauce> is there a good implementation of union find in the GHC libraries?
15:25:57 <mwc> yeah, p^(k + 1)
15:25:59 <mwc> I'm being lazy
15:26:50 <Cale> yeah, all the factors will be Z/p
15:28:11 <mwc> I'm wondering this: since at the p^(k + 1) step
15:28:19 <mwc> I can pick ANY subgroup of p^k order
15:28:24 <mwc> and find a subnormal series
15:28:33 <mwc> that justifies thigns
15:28:50 <mwc> I think it does now that I've thought on it for an hour or so (eg, mulled it over while reading Hawiki)
15:29:32 <jethr0> @hoogle print
15:29:33 <lambdabot> Prelude.print :: Show a => a -> IO ()
15:29:33 <lambdabot> System.IO.print :: Show a => a -> IO ()
15:29:33 <lambdabot> Text.Printf.Print :: Print
15:39:19 <Cale> mwc: well, yeah, I think so
15:39:19 <mwc> Hmm, Cale I just can't show at the inductive step that for n = k + 1 any subgroup of order p^k is normal. Need to ponder that.
15:39:29 <Cale> yes that would do it
15:40:06 <Cale> all you have to do is to show that your group of order p^(k+1) has a normal subgroup of order p^k
15:40:29 <Cale> and the rest of the composition series will exist by induction
15:40:50 <mwc> actually, I need to show all groups of order p^k is normal
15:40:55 <Cale> oh
15:40:56 <Cale> right
15:41:03 <mwc> I'm trying to show that at any step I can pick any subgroup
15:41:15 <Cale> right "every proper subgroup"
15:41:31 <Cale> well, you already know what the quotient is :)
15:41:43 <mwc> yeaH
15:42:30 <mwc> I'm tryin to show the normalizer of a p^k subgroup in p^(k + 1) is equal to p^(k + 1)
15:42:38 <mwc> well, the group, N_G(H) = G
15:46:51 <soysauce> when is it safe to use unsafeFreeze?
15:46:59 <soysauce> that just casts the array, doesn't it?
15:47:09 <Taral> yes
15:47:34 <soysauce> well, I want to take a mutable array, freeze it for a little while and use it as an immutable array, and then continue using it later
15:47:39 <soysauce> but I suspect that this will not work
15:47:52 <Taral> unsafeFreeze is safe if you've initialized every element and you can ensure that the array will not be mutated after unsafeFreeze is called
15:47:55 <Cale> mwc: well, it occurs here as an exercise in my group theory text :)
15:48:06 <soysauce> ah, well, I didn't think it would be safe :|
15:48:14 <soysauce> but I suppose that makes sense
15:48:17 <Cale> (that if G is a group of order p^n then every subgroup of order p^(n-1) is normal)
15:48:17 <Taral> unsafeThaw is much harder to use right
15:48:34 <Taral> if you're exporting to a sequencing monad, then you might be able to use freeze/thaw
15:48:40 <soysauce> unsafeThaw would require all references to the array to be dead, no?
15:48:48 <Taral> pretty much
15:48:50 <soysauce> yeah, that's what I'm doing now
15:49:02 <soysauce> but I was thinking that this code would be much easier to read if it were a plain immutable array
15:50:12 <soysauce> you don't happen to know of a good union find impl. in the GHC libraries, do you? I didn't see anything in Data.Graph that looked promising
15:50:29 <soysauce> I've implemented it myself, but it's really, really slow.
15:50:30 <mwc> Cale, gives you any hints?
15:50:45 <Cale> yes actually
15:52:02 <Cale> there's a hint in the back which says to suppose that H /= x H x^(-1), and then use the fact (obtained in another exercise) that if H and K are subgroups of a finite group G, then |HK| = |H| |K| / |H /\ K|
15:52:14 <Cale> where by /\ I mean intersection :)
15:52:19 <mwc> Ah
15:52:21 <mwc> thankyou!
15:54:40 <Heffalump> ah, yes, I remember that
15:54:47 <joelr1> shapr: ping
15:54:51 <joelr1> evening everyone
15:56:32 <musasabi> evening joelr1
15:56:52 <joelr1> does anyone have a cabalized version of yampa?
15:57:18 <musasabi> yampa is scary
15:57:27 <joelr1> :-)
15:57:40 <joelr1> i wanna do yampa
15:58:02 <twb> Hey, I've found a bug (I assume) in ghci which doesn't manifest in ghc or hugs.
15:58:13 <twb> I'm using "The Glorious Glasgow Haskell Compilation System, version 6.4.1"
15:58:34 <SamB> hmm, how about a canabilized version of yampa?
15:58:48 <twb> SamB: "cannibalized"
15:58:51 <musasabi> twb: what kind of issue?
15:58:55 <SamB> twb: what does it do?
15:58:58 <twb> data D = D Char deriving Show
15:58:58 <twb> main = print f
15:58:58 <twb> f = D 'a'
15:59:07 <twb> Causes a segmentation fault when f is evaluated.
15:59:11 <SamB> twb: funnier my way
15:59:21 <twb> SamB: you wanna turn it into THC? ;-)
15:59:46 <musasabi> twb: works for me
16:00:02 <twb> musasabi: in ghci?
16:00:19 <musasabi> yes, saved that to a file and ran ghci on it.
16:00:29 <musasabi> running main worked too
16:00:32 <twb> Wait, I remember.
16:00:45 <twb> This problem only manifests when using it with haskell-mode.
16:01:06 <musasabi> twb: works from my haskell-mode
16:01:21 <twb> musasabi: What version of ghci, haskell-mode, emacs?
16:02:10 <musasabi> ghc 6.4.1
16:02:21 <musasabi> GNU Emacs 21.4.1
16:02:29 <Saulzar> joelr1, Got a project in mind for it?
16:02:40 <Saulzar> Hmm, that was good timing.
16:03:24 <joelr1> did someone just call my name?
16:03:36 <Saulzar> Yep, then you quit :)
16:03:46 <musasabi> 2.something (whatever debian unstable has)
16:03:51 <Saulzar> Saulzar joelr1, Got a project in mind for it? * joelr1 has quit ()
16:04:01 <joelr1> Saulzar: i was in the process of quitting :-)
16:04:05 <joelr1> Saulzar: yes, a couple
16:04:16 <twb> musasabi: I'm using emacs22, lemme try it with 21.
16:04:39 <joelr1> all involving poker :-) i'm wondering if poker bots can be written in yampa. i'm also wondering about modelling collusion detection on top of it
16:05:41 <Saulzar> Poker? Hmm, how would that work?
16:05:55 <Saulzar> Doesn't seem like something which would be continuous with time...
16:06:03 <Cale> @help djinn-add
16:06:03 <lambdabot> Define a new function type or type synonym
16:06:25 <Cale> @djinn-add data Maybe a = Nothing | Just a
16:06:25 <joelr1> Saulzar: well, yampa is being used for games and these use discrete events a swell
16:06:31 <Cale> no? :)
16:06:33 <jethr0> have you guys seen that 3d shooter in yampa?
16:06:34 <jethr0> frag
16:06:35 <Saulzar> Hmm, true
16:06:41 <joelr1> Saulzar: your kepboard events are not continuous in time
16:06:48 * joelr1 is compiling frag right now
16:06:56 <joelr1> linking actually
16:07:10 <jethr0> can't be long then...
16:07:12 <twb> musasabi: nope, I still get it in Emacs21.
16:07:41 <Saulzar> I've had a look, it's pretty impressive 
16:07:53 <musasabi> weird
16:08:15 <joelr1> Saulzar: what do yo give it as an argument?
16:08:18 <jethr0> although some of the code i looked at had pretty _huge_ functions in it... interspersed with arrow operators
16:08:19 <joelr1> leveleg? what's that?
16:08:27 <Saulzar> Hmm
16:08:29 <jethr0> from glancing at it, it could use a little refactoring in places
16:08:45 <Saulzar> Some of it's code does not look exciting!
16:08:55 <twb> musasabi: even with -q (i.e. no ~/.emacs)
16:08:55 <joelr1> i get a bus error
16:09:07 <twb> musasabi: what CPU arch are you using?
16:09:09 <jethr0> but i'm not complaining! great thing that someone finally did an arrow-based shooter in haskell :)
16:09:10 <Saulzar> I guess anything which requires (implicit) time varying state is a very good match for yampa...
16:09:20 <musasabi> twb: I tried that on i386-linux
16:09:32 <twb> musasabi: I'm on PPC -- maybe it's an arch-specific bug.
16:09:37 <joelr1> Saulzar: maybe, will find out
16:09:40 <Saulzar> I had a look inside one of the files and there was a function with something like 12 levels of nesting, very scary :)
16:09:46 <joelr1> over and out!
16:09:51 * twb digs around for an i386 box.
16:11:00 <Saulzar> His thesis was quite interesting too, I've been going over the space invaders code - and he explains how to add passing messages between entities
16:12:04 <twb> musasabi: confirmed, it works on i386.
16:12:22 <twb> musasabi: to whom should I report this bug?
16:14:27 <Taral> jimapple still around?
16:14:28 <musasabi> twb: http://cvs.haskell.org/trac/ghc/ (but making it reproducable is a good idea)
16:14:29 <Taral> @seen jimapple
16:14:29 <lambdabot> jimapple is in #haskell. Last spoke 58 minutes and 21 seconds ago.
16:14:34 <Taral> probably not
16:14:42 <Taral> I have no idea how to show (forall A : Prop, (A -> False) -> forall f : Prop -> Prop, f A -> f False)
16:14:54 <twb> musasabi: thanks.
16:15:14 <dons> Moin
16:17:45 <o_Rocky> hello
16:18:25 <o_Rocky> i'm trying to do an "instance", i've never made one so, i'm having troubles...
16:18:43 <o_Rocky> intance Show
16:19:11 <o_Rocky> i'm trying to print some unfinished contructor
16:20:07 <o_Rocky> Show (String -> Char)
16:20:13 <o_Rocky> p.e.
16:20:42 <o_Rocky> can someone help me out?
16:21:38 <Saulzar> o_Rocky, What have you got?
16:22:47 <lennart> Taral: what you want to show doesn't look true
16:23:07 <o_Rocky> instance Show (String -> Option) where
16:23:13 <sjanssen> @djinn (a -> a) -> a
16:23:14 <lambdabot> -- f cannot be realized.
16:23:19 <sjanssen> is this a known issue?
16:23:31 <lennart> known issue?
16:23:40 <lennart> it's the truth
16:23:54 <Saulzar> o_Rocky, So you want to be able to "show" functions of String -> Option ?
16:24:00 <o_Rocky> yes
16:24:39 <o_Rocky> showsPrec d (Filename) = "FileName"
16:24:48 <lennart> (a->a)->a is only realizable if you use recursion or some other fixpoint operation
16:25:01 <o_Rocky> Filename :: (String -> Option)
16:25:35 <sjanssen> lennart: yeah, I was hoping it would find a definition of fix
16:25:44 <o_Rocky> showsPrec d (Filename) = showString "FileName"
16:25:48 <sjanssen> lennart: but this is outside the scope of Djinn?
16:25:55 <lennart> you've not read the fine print ;)
16:26:14 <triplah> http://www.it.bond.edu.au/inft313/053/workshops/wk11.html <-- check out task 3. i think my lecturer is trying to point out how evil java is ;)
16:27:25 <lennart> djinn uses a decision procedure, deriving arbitrary recursive functions is undecidable in general
16:27:52 <lennart> but that doesn't mean i won't try it in the future :)
16:27:55 <Saulzar> o_Rocky, Are you sure you want to use showsPrec and not just show ?
16:27:59 <tic> *yawn*
16:28:06 <Saulzar> o_Rocky, you don't have to implement all the functions
16:28:08 <tic> stupid insomnia.
16:28:10 <o_Rocky> i don't know
16:28:30 <sjanssen> lennart: thanks for the pointer -- Djinn is a whole lot of fun
16:28:47 <Saulzar> o_Rocky, Try just overloading show, rather than the others (they have a default implementation)
16:29:05 <o_Rocky> o_Rocky: i guess so
16:29:14 <o_Rocky> Saulzar
16:29:16 <Saulzar> o_Rocky, instance Show (String -> Option) where  \  show x =  "...."
16:30:39 <o_Rocky> but i cant make show Filename = "filename"
16:30:59 <o_Rocky> because Filename :: (String -> Option)
16:31:36 <Saulzar> o_Rocky, Filename is not a data constructor so you can't match against it
16:31:57 <Saulzar> o_Rocky, Your argument to show is a function (that is: String -> Option)
16:32:08 <o_Rocky> yes
16:32:17 <Saulzar> show :: a -> String      where a = (String -> Option)
16:32:41 <o_Rocky> ok
16:33:06 <o_Rocky> but i have Filename, Input:: String -> Option
16:33:18 <o_Rocky> Filename, Input:: (String -> Option)
16:33:42 <o_Rocky> so i must differ the output of show
16:34:14 <twb> Argh, trac doesn't work in w3m :-/
16:34:17 <Saulzar> I see, to do that you must either use a newtype or a data type ..
16:34:38 <Saulzar> You can't match on them since they're both synonyms for the same thing
16:35:09 <o_Rocky> could i make deriving Eq?
16:36:04 <Saulzar> Yes..
16:37:10 <o_Rocky> bahhh
16:37:13 <o_Rocky> i give up
16:37:18 <o_Rocky> stupid haskell
16:38:13 <o_Rocky> i'm sure there must be a way to make this, i just don't know how
16:38:39 <dons> twb, it doesn't?
16:38:43 <dons> hmm. 
16:38:46 <o_Rocky> i will try to make a work around
16:39:42 <dons> twb, in what way doesn't it work?
16:40:00 <Saulzar> o_Rocky, data Foo = Filename (String -> Option) | Input (String -> Option)     ?
16:40:17 <dons> I seem to be able to browse all right, twb? where does it break?
16:40:32 <twb> Sorry, I was afk
16:40:42 <twb> http://cvs.haskell.org/trac/ghc/ticket/631#preview
16:41:03 <twb> dons: Oh, the Preview button doesn't work.
16:42:15 <dons> twb, you using ppc/linux?
16:42:20 <twb> dons: yes.
16:42:50 * twb hugs PPC's clean design.
16:43:48 <dons> do you have a workign ghci?
16:44:06 <twb> dons: apt-get install ghc7
16:44:11 <twb> dons: apt-get install ghc6, rather ^_^;
16:44:20 <dons> it works though?
16:44:25 <twb> Yep.
16:44:32 <twb> Apart from the bug I mentioned.
16:44:33 <dons> could you test some software for me then... ?
16:44:37 <twb> dons: sure.
16:44:42 <twb> no binaries, tho.
16:45:01 <dons> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/hmp3
16:45:11 <dons> psi reported this segfaulting on ppc/liinux
16:45:28 <dons> we in fact have a bug open for this problem
16:45:29 <SamB> dons: again?
16:45:40 <dons> SamB, not again. I just want to get more info.
16:45:53 <dons> since now I'm wondering if it  is psi's box that is broken.
16:45:55 <twb> dons: I ran ./configure; no makefile.
16:46:03 <dons> twb, it's cabalised.
16:46:04 <dons> check the README :)
16:46:39 <dons> you should probably only need to install fps, if you haven't yet.
16:46:43 <dons> @where fps
16:46:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:46:48 <twb> I'm missing a whole bunch of deps.
16:46:56 <dons> only fps is needed to make it build
16:47:07 <dons> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps
16:47:15 <dons> oh, unless your Cabal is old?
16:47:16 <twb> missing happy, alex, c2hs, cpphs, greencard.
16:47:27 <dons> oh, noo issue. that's just cabal playing games
16:47:33 <twb> Okie
16:47:55 <twb> How do I tell it where fps is?
16:48:10 <dons> you download and build fps.it registers itself
16:48:18 <dons> in the haskell package system
16:48:22 <twb> You want me to *install* something!?
16:48:31 * twb shivers.
16:48:32 <dons> such that ghc-pkg list will display it
16:48:52 <dons> well, it's just a standard packed string library. 1 module. fps-0.1
16:49:05 <dons> if that's a big deal, don't bother :)
16:49:08 <twb> Where's it gonna put it?
16:49:20 <dons> $PREFIX/lib/fps-0.1/*
16:49:21 <jethr0_bot> Unknown command, try @listcommands.
16:49:35 <dons> whever you set --prefix in the argument to ./Setup.lhs configure
16:49:42 <dons> could be /tmp/
16:49:45 <twb> Okie.
16:50:12 <dons> you can ghc-pkg unregister fps straight after; and delete that dir.
16:50:54 <dons> let me find this ppc ticket..
16:51:11 <twb> ghc-pkg: /usr/lib/ghc-6.4.1/package.conf: you don't have permission to modify this file
16:51:18 <SyntaxNinja> ./setup install --user
16:51:31 <SyntaxNinja> ./setup configure --user --prefix=/tmp && ./setup build && ./setup install --user
16:51:41 <dons> as SyntaxNinja says :)
16:51:42 <twb> Done.
16:51:47 <twb> Where's it put the dotfile?
16:51:55 <twb> Ah, got it.
16:51:57 <dons> ~/ iirc.
16:52:06 <twb> I can live with stuff in ~/, but not /usr :-)
16:52:07 <dons> so now ghc-pkg should list fps
16:52:11 <dons> me too.
16:52:21 <dons> I wouldn't ask you to mess with anything outside ~
16:52:54 <dons> hmp3 should build now, I think. (though it won't actually play music without mpg321). we may get some useful info though.
16:53:08 <twb> You should still have a Makefile with just "build:\n\t./Setup.lhs build", and similar.
16:53:46 <twb> dons: still getting "Setup.lhs: cannot satisfy dependency fps-any".
16:53:59 <dons> does ghc-pkg list fps display anything?
16:54:04 <twb> Ah, configure --user worked.
16:54:11 <dons> right
16:54:30 <dons> now, all you should need to do is 'build' and then try to run dist/build/hmp3/hmp3
16:54:34 <dons> (no need to install)
16:54:39 <dons> we'll see what happens
16:55:13 <dons> if you're up to it, you could try installing mpg321 (with apt) and playing some mp3s to see if that works. otherwise we can only test the segfault bug described on trac.
16:55:56 <dons> this one, http://cvs.haskell.org/trac/ghc/ticket/487
16:56:21 <dons> hmm /me wonders if we should have a trac plugin..
16:58:19 <jimapple> @look Taral
16:58:19 <lambdabot> Unknown command, try @listcommands.
16:58:24 <jimapple> @listcommands
16:58:24 <lambdabot> use listcommands [module|command], please. Modules are:
16:58:24 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
16:58:24 <lambdabot> hoogle karma localtime more pl plugs poll quote search seen spell state
16:58:24 <lambdabot> system todo topic type version vixen where
16:58:39 <jimapple> @seen Taral
16:58:40 <lambdabot> I saw Taral leaving #haskell 38 minutes and 43 seconds ago.
16:59:56 <jimapple> @seen lennart
16:59:56 <lambdabot> lennart is in #haskell. Last spoke 32 minutes and 4 seconds ago.
17:00:15 <jimapple> Lennart, you said that (forall A : Prop, (A -> False) -> forall f : Prop -> Prop, f A -> f False) doesn't look true
17:00:51 <jimapple> I had mentioned it earlier using Ralf Hinze's a :=: b = forall f . f a -> f b 
17:01:36 <jimapple> my question is then, if a is uninhabited, is it the same (by this Liebniz version of "same") as False?
17:02:17 <jimapple> if so, then ~a -> (a :=: False)
17:02:17 <jimapple> (a -> False) -> (a :=: False)
17:02:17 <jimapple> (a -> False) -> (forall f . f a = f False)
17:03:42 <jimapple> of course, I can't figure out how to populate that type
17:04:46 <dons> twb, does it build?
17:08:18 <jimapple> slow night . . .
17:10:16 * shapr snores quietly
17:10:37 <jimapple> Anybody here used Chameleon?
17:11:01 <SamB> @babel es en lo ciento
17:11:03 <lambdabot>  the one hundred
17:11:24 * SamB thinks his sister needs to work on her spanish spelling
17:11:33 <SamB> she claimed that meant "I'
17:11:36 <SamB> m sorry"
17:11:37 <jimapple> @babel en es I am sorry
17:11:38 <lambdabot>  Estoy apesadumbrado
17:12:59 <lennart> jimapple: yes, if a is uninhabited ad a :=:b then b must be empty too
17:13:00 <o_Rocky> lol
17:13:11 <jethr0> samb, she's right, though
17:13:21 <o_Rocky> @babel pt en desculpa
17:13:23 <lambdabot>  excuse
17:13:23 <SamB> jethr0: oh?
17:13:30 <o_Rocky> lol
17:13:35 <jethr0> "lo ciento" does mean "i'm sorry"
17:13:50 <SamB> she burst into a fit of laughter at that
17:13:53 <jethr0> although i'm not so sure about the "c"
17:13:55 <o_Rocky> desculpa == I'm sorry
17:13:55 <SamB> I think she is tired
17:13:58 <jimapple> I was going the other way, lennart: if a and b are uninhabited, is there a term of type a :=: b?
17:14:20 <jethr0> o_rocky, that doesn't prove me wrong :)
17:14:25 <lennart> well, what system are you using?
17:14:37 <o_Rocky> @babel en pt i'm sorry
17:14:38 <lambdabot>  eu sou pesaroso
17:14:42 <lennart> in System F, it must be so
17:14:44 <o_Rocky> lololololol
17:14:47 <jethr0> jeje
17:15:02 <o_Rocky> good nigth everybody
17:15:11 <jethr0> @babel es en yo lo siento mucho
17:15:13 <lambdabot>  I feel much
17:15:20 <jethr0> @babel es en lo siento
17:15:20 <o_Rocky> lololol
17:15:21 <lambdabot>  I feel it
17:15:34 <jimapple> lennart: great, now all I need (need?) is a term that proves it!
17:17:18 <lennart> jimapple: but it's just reflexivity.  or am i misunderstanding?
17:18:07 <lennart> or are these empty types obtained in different ways?
17:18:56 <jimapple> Of one, we have only the proof of emptiness: (a -> (forall b . b))
17:19:08 <lennart> I mean, you can give a general term that proves that a:=:b when a and b are empty.  it depends on a and b
17:19:23 <jimapple> you can?
17:19:36 <lennart> you CAN'T, sorry
17:19:47 <jethr0> samb, i've started working on enhancing shapr's TH tutorial... do you think the examples are too verbose/long/complicated? http://www.haskell.org/hawiki/TemplateHaskellTutorial
17:19:47 <jimapple> ah
17:20:02 <jethr0> i am not sure whether i've found the right approach yet
17:20:22 <jimapple> Why can't you?
17:21:25 <lennart> well, how do you know a and b are empty?
17:21:38 <lennart> do you have ~a and ~b ?
17:22:08 <jimapple> yes, or perhaps b is (forall c . c)
17:22:47 <lennart> yes, but perhaps its (Foo -> Bar -> Empty)
17:23:40 <lennart> but give me ~a and ~b and i think i can show it :)
17:24:43 <jimapple> is ~a equivalent to (a -> (forall c . c))? I have been assuming so. I don't know anything about negations in this side of the CH correspondence. 
17:24:59 <lennart> yes
17:25:37 <jethr0> anyone know how to see the change-history in the hawiki?
17:27:02 <jimapple> so, then, we'd like a term of type
17:27:02 <jimapple> @djinn (a -> (forall c . c)) -> (b -> (forall c . c)) -> (forall f . f a -> f b)
17:27:03 <lambdabot> Error: type varible not bound r
17:27:18 <jimapple> @listcommands djinn
17:27:19 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
17:27:19 <lambdabot> ver
17:27:30 <jimapple> @djinn-env
17:27:32 <lambdabot> data () = ()
17:27:34 <lambdabot> data Either a b = Left a | Right b
17:27:36 <lambdabot> data Maybe a = Nothing | Just a
17:27:38 <lambdabot> data Bool = False | True
17:27:40 <lambdabot> data Void =
17:27:42 <lambdabot> type Not x = x -> Void
17:27:51 <dons> @djinn-ver
17:27:52 <lambdabot> Djinn version 2005-12-13.
17:27:54 <dons> :)
17:28:23 <lennart> jimapple: yes
17:28:48 <Pseudonym> @djinn-add data List a = Cons a (List a) | Nil
17:28:57 <dons> hmm....
17:29:16 <jethr0> @seen cale
17:29:17 <lambdabot> cale is in #haskell-overflow and #haskell. I don't know when cale last
17:29:17 <lambdabot> spoke.
17:29:25 <jimapple> @djinn List a
17:29:26 <lambdabot> Error: Recursive types are not allowed: List
17:29:26 <lambdabot> -- f cannot be realized.
17:29:35 <dons> :D
17:30:17 <dons> @djinn-del List
17:30:21 <jimapple> lennart: any hints? :-)
17:31:04 <Pseudonym> @djinn (a -> b) -> (Maybe a -> Maybe b)
17:31:04 <lambdabot> f :: (a -> b) -> Maybe a -> Maybe b
17:31:04 <lambdabot> f x1 x2 =
17:31:04 <lambdabot>   case x2 of
17:31:04 <lambdabot>   Nothing -> Nothing
17:31:04 <lambdabot>   Just v8 -> Just (x1 v8)
17:31:10 <lennart> jimapple: maybe i spoke too soon.  the term you are looking for might not exist.  but it's double negation certainly does
17:31:41 <Pseudonym> @djinn (a -> b) -> (c -> d) -> (Either a c -> Either b d)
17:31:42 <lambdabot> f :: (a -> b) -> (c -> d) -> Either a c -> Either b d
17:31:42 <lambdabot> f x1 x2 x3 =
17:31:42 <lambdabot>   case x3 of
17:31:42 <lambdabot>   Left v6 -> Left (x1 v6)
17:31:42 <lambdabot>   Right v12 -> Right (x2 v12)
17:31:57 <Pseudonym> @djinn (a -> b, c -> d) -> (Either a c -> Either b d)
17:31:58 <lambdabot> f :: (a -> b, c -> d) -> Either a c -> Either b d
17:31:58 <lambdabot> f (v2, v3) x4 =
17:31:58 <lambdabot>   case x4 of
17:31:58 <lambdabot>   Left v7 -> Left (v2 v7)
17:31:58 <lambdabot>   Right v13 -> Right (v3 v13)
17:32:01 <jimapple> (((a -> (forall c . c)) -> (b -> (forall c . c)) -> (forall f . f a -> f b)) -> (forall c . c)) -> (forall c . c)
17:32:03 <jimapple> phew
17:32:13 <lennart> yes
17:32:18 <Pseudonym> @djinn (((a -> (forall c . c)) -> (b -> (forall c . c)) -> (forall f . f a > f b)) -> (forall c . c)) -> (forall c . c)
17:32:19 <lambdabot> Terminated
17:32:23 <Pseudonym> Ha!
17:32:43 <dons> Terminated isn't really 'terminated'. I think it's me remapping error messages.
17:32:49 * Pseudonym nods
17:33:18 <lennart> jimapple: you can prove that one by using f=id, i think
17:33:45 <lennart> djinn is more fun with data types :)
17:33:59 <lennart> @djinn Bool -> Bool
17:34:00 <lambdabot> f :: Bool -> Bool
17:34:00 <lambdabot> f x1 =
17:34:00 <lambdabot>   case x1 of
17:34:00 <lambdabot>   False -> True
17:34:00 <lambdabot>   True -> False
17:34:10 <jimapple> @more
17:34:11 <lambdabot> more: empty buffer
17:34:18 <Pseudonym> Interesting.
17:34:29 <Pseudonym> @djinn Maybe a -> Maybe Bool
17:34:29 <lambdabot> f :: Maybe a -> Maybe Bool
17:34:29 <lambdabot> f x1 =
17:34:29 <lambdabot>   case x1 of
17:34:29 <lambdabot>   Nothing -> Just True
17:34:29 <lambdabot>   Just _ -> Just False
17:34:35 <Pseudonym> @more
17:34:35 <lambdabot> more: empty buffer
17:35:01 <Pseudonym> @djinn Maybe Void -> Bool
17:35:02 <lambdabot> f :: Maybe Void -> Bool
17:35:04 <lambdabot> f x1 =
17:35:06 <lambdabot>   case x1 of
17:35:08 <lambdabot>   Nothing -> True
17:35:10 <lambdabot>   Just v7 -> void v7
17:35:17 <Pseudonym> Erm.
17:35:19 <jimapple> lennart: I still don't understand how
17:36:16 <Lemmih> @djinn b -> (a -> b) -> Maybe a -> b
17:36:17 <lambdabot> f :: b -> (a -> b) -> Maybe a -> b
17:36:17 <lambdabot> f x1 x2 x3 =
17:36:17 <lambdabot>   case x3 of
17:36:17 <lambdabot>   Nothing -> x1
17:36:17 <lambdabot>   Just v6 -> x2 v6
17:37:38 <Pseudonym> @djinn Either a b -> (a -> c) -> (b -> c) -> c
17:37:39 <lambdabot> f :: Either a b -> (a -> c) -> (b -> c) -> c
17:37:39 <lambdabot> f x1 =
17:37:39 <lambdabot>   case x1 of
17:37:39 <lambdabot>   Left v4 -> \ x5 _ -> x5 v4
17:37:39 <lambdabot>   Right v8 -> \ _ x10 -> x10 v8
17:39:16 <Lemmih> @djinn id ? a -> a
17:39:16 <lambdabot> Terminated
17:39:30 <lennart> jimapple: hmmm, i'm too tired to work it out now
17:39:39 <jimapple> :-)
17:39:43 <lennart> my enery went into djinn :)
17:39:51 <jimapple> thanks for that, BTW
17:40:29 <Pseudonym> @djinn ((a -> c) -> (b -> c) -> c) -> (a -> d) -> (b -> e) -> (a -> f) -> (b -> f) -> f
17:40:30 <lambdabot> -- f cannot be realized.
17:40:37 <Pseudonym> Oh, but it can!
17:40:48 <Pseudonym> @djinn ((a -> c) -> (b -> c) -> c) -> (a -> d) -> (b -> e) -> (d -> f) -> (e -> f) -> f
17:40:48 <lambdabot> -- f cannot be realized.
17:40:54 <Pseudonym> No, THAT one can. :-)
17:40:59 <Pseudonym> Hmmm.
17:41:04 <jimapple> Show us
17:41:08 <Pseudonym> @djinn ((a -> c) -> (b -> c) -> c) -> (a -> d) -> (b -> e) -> (d -> c) -> (e -> c) -> c
17:41:08 <lambdabot> f :: ((a -> c) -> (b -> c) -> c) -> (a -> d) -> (b -> e) -> (d -> c) -> (
17:41:08 <lambdabot> e -> c) -> c
17:41:08 <lambdabot> f x1 x2 x3 x4 x5 = x1 (\ c17 -> x4 (x2 c17)) (\ c13 -> x5 (x3 c13))
17:41:11 <Pseudonym> Ah, I see.
17:41:16 <Pseudonym> Duh, of course.  You need foralls.
17:42:16 <jimapple> @djinn-env
17:42:17 <lambdabot> Error: Recursive types are not allowed: List
17:42:17 <lambdabot> data () = ()
17:42:17 <lambdabot> data Either a b = Left a | Right b
17:42:17 <lambdabot> data Maybe a = Nothing | Just a
17:42:17 <lambdabot> data Bool = False | True
17:42:19 <lambdabot> data Void =
17:42:21 <lambdabot> type Not x = x -> Void
17:42:23 <lambdabot> data Either a b = Left a | Right b
17:42:25 <lambdabot> data Maybe a = Nothing | Just a
17:42:27 <lambdabot> data Bool = False | True
17:42:29 <lambdabot> data Void =
17:42:31 <lambdabot> type Not x = x -> Void
17:42:34 <lennart> Haskell should have Void and void (even if they are inhabited in Haskell)
17:42:35 <dons> @djinn-clr
17:42:45 <dons> my env handling is a bit wonky. hmm
17:42:48 <jimapple> @djinn-env
17:42:49 <lambdabot> data () = ()
17:42:49 <lambdabot> data Either a b = Left a | Right b
17:42:49 <lambdabot> data Maybe a = Nothing | Just a
17:42:49 <lambdabot> data Bool = False | True
17:42:51 <lambdabot> data Void =
17:42:53 <lambdabot> type Not x = x -> Void
17:43:21 <jimapple> @djinn Not (Not Bool)
17:43:22 <lambdabot> f :: Not (Not Bool)
17:43:22 <lambdabot> f x1 = void (x1 False)
17:43:37 <jimapple> @djinn Not Void
17:43:38 <lambdabot> f :: Not Void
17:43:38 <lambdabot> f = void
17:43:44 <jimapple> @djinn Void
17:43:45 <lambdabot> -- f cannot be realized.
17:43:54 <jimapple> @djinn Not (Not (Not Void))
17:43:56 <lambdabot> f :: Not (Not (Not Void))
17:43:56 <lambdabot> f x1 = void (x1 void)
17:44:07 <Pseudonym> @djinn (a -> a) -> a
17:44:07 <lambdabot> -- f cannot be realized.
17:44:12 <Pupeno> what is djinn ?
17:44:51 <jimapple> @listcommands djinn
17:44:52 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
17:44:52 <lambdabot> ver
17:44:58 <Pseudonym> @info djinn
17:44:59 <lambdabot> Unknown command, try @listcommands.
17:44:59 <jimapple> djinn populates types
17:45:03 <Pseudonym> @help djinn
17:45:03 <lambdabot> Generates Haskell code from a type.
17:45:03 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:45:04 <dons> @djinn-env
17:45:05 <lambdabot> data () = ()
17:45:07 <lambdabot> data Either a b = Left a | Right b
17:45:09 <lambdabot> data Maybe a = Nothing | Just a
17:45:11 <lambdabot> data Bool = False | True
17:45:13 <lambdabot> data Void =
17:45:15 <lambdabot> type Not x = x -> Void
17:45:23 <dons> hmm.
17:45:32 <jimapple> @djinn-add type Equal a b = forall f . f a -> f b
17:45:39 <jimapple> @djinn-env
17:45:41 <lambdabot> type Equal a b = forall f . f a -> f b
17:45:41 <lambdabot> data () = ()
17:45:41 <lambdabot> data Either a b = Left a | Right b
17:45:41 <lambdabot> data Maybe a = Nothing | Just a
17:45:41 <lambdabot> data Bool = False | True
17:45:43 <lambdabot> data Void =
17:45:43 <lennart> hahaha
17:45:44 <lambdabot> type Not x = x -> Void
17:45:55 <jimapple> @djinn Equal a a
17:45:56 <lambdabot> -- f cannot be realized.
17:46:10 <lennart> hmmm, why wasn't that rejected as a syntax error?
17:46:25 <Pseudonym> @djinn Equal Bool Bool
17:46:25 <lambdabot> -- f cannot be realized.
17:46:34 <dons> @djinn-env
17:46:35 <lambdabot> type Equal a b = forall f . f a -> f b
17:46:35 <lambdabot> data () = ()
17:46:35 <lambdabot> data Either a b = Left a | Right b
17:46:35 <lambdabot> data Maybe a = Nothing | Just a
17:46:35 <lambdabot> data Bool = False | True
17:46:37 <lambdabot> data Void =
17:46:39 <lambdabot> type Not x = x -> Void
17:46:39 <dons> @djinn-clr
17:46:44 <dons> @djinn-env
17:46:45 <lambdabot> data () = ()
17:46:45 <lambdabot> data Either a b = Left a | Right b
17:46:45 <lambdabot> data Maybe a = Nothing | Just a
17:46:47 <lambdabot> data Bool = False | True
17:46:49 <lambdabot> data Void
17:46:51 <lambdabot> type Not x = x -> Void
17:46:55 <dons> ^^ a patch to draw void the haskell way.
17:47:07 <dons> lennart, what do you reckon? ah, but I'll have to tweak the parser too?
17:47:33 <jimapple> @djinn-add data Equal a b = Equal { apply : forall f . f a -> f b }
17:47:38 <jimapple> @djinn-env
17:47:39 <lambdabot> data Equal a b = Equal { apply : forall f . f a -> f b }
17:47:39 <lambdabot> data () = ()
17:47:39 <lambdabot> data Either a b = Left a | Right b
17:47:39 <lambdabot> data Maybe a = Nothing | Just a
17:47:39 <lambdabot> data Bool = False | True
17:47:41 <lambdabot> data Void
17:47:43 <lambdabot> type Not x = x -> Void
17:47:45 <jimapple> youch
17:47:49 <lennart> the old djinn parser was broken.  it accepted . as an identifier
17:47:52 <jimapple> @djinn-clr
17:48:04 <jimapple> @djinn-add data Equal a b = Equal { apply :: forall f . f a -> f b }
17:48:10 <jimapple> @djinn-env
17:48:11 <lambdabot> data Equal a b = Equal { apply :: forall f . f a -> f b }
17:48:11 <lambdabot> data () = ()
17:48:11 <lambdabot> data Either a b = Left a | Right b
17:48:11 <lambdabot> data Maybe a = Nothing | Just a
17:48:11 <lambdabot> data Bool = False | True
17:48:13 <lambdabot> data Void
17:48:15 <lambdabot> type Not x = x -> Void
17:48:16 <dons> djinn-env just displays a module-internal list of strings. they'll get fed to djinn when you actually try to @djinn something. then the error gets detected.
17:48:23 <lennart> aha
17:48:27 <jimapple> @djinn Bool
17:48:28 <lambdabot> f :: Bool
17:48:28 <lambdabot> f = True
17:48:35 <lennart> so it's all s scam :)
17:48:36 <jimapple> @djinn Equal a a 
17:48:37 <lambdabot> -- f cannot be realized.
17:48:44 <Pseudonym> @djinn Maybe ()
17:48:44 <lambdabot> f :: Maybe ()
17:48:44 <lambdabot> f = Just ()
17:48:48 <lennart> to confuse people
17:48:59 <jimapple> like Haskell itself
17:49:04 <lennart> yep
17:49:14 <dons> right. it's not actually connecte do a djinn process permanently. it's restarting one each time.
17:49:25 <Pseudonym> Unfortunately, djinn is not yet capable of writing my program for me.
17:49:28 <dons> with an initial env populated from the module state.
17:49:32 <Pseudonym> @djinn IO ()
17:49:33 <lambdabot> -- f cannot be realized.
17:49:39 <lennart> maybe it should start one before adding to the environment
17:49:54 <dons> start one?
17:50:07 <lennart> start djinn and make sure it's an ok type
17:50:14 <dons> I think it should use djinn for all adds and deletses, yes.
17:50:28 <dons> and then resync with :environment.
17:50:33 <dons> this is how djinn-clr works.
17:50:35 <lennart> yes
17:56:39 <lennart> jimapple: so I can prove that ~a->~b->~~(a:=:b)
17:59:21 <Cale> jethr0: hello
17:59:21 <lennart> andeven djinn can show that (a->~~b)->~~(a->b) :)
17:59:25 <jethr0> hello
17:59:46 <jethr0> i saw you edited my changes to the TH tutorial... i am eager for (constructive negative) feedback :))
18:00:02 <jethr0> it all seems rather over-complicated still, doesn't it?
18:00:34 <Cale> Well, that might be a problem with TH itself :)
18:00:47 <Cale> But I didn't actually finish reading it yet
18:01:04 <jethr0> so, you think i should start off a little simpler or is the general speed of the tutorial acceptable?
18:01:35 <mwc> Cale, regarding that hint you gave me earlier, I don't see it. I can't figure out what group to compare against that subgroup
18:02:35 <jimapple> lennart: yeah? great!
18:02:52 <Cale> mwc: seeing as you're assuming that the group is distinct from one of its conjugates, I'd think you'd compare H (where |H| = p^(n-1)) with xHx^(-1)
18:03:26 <jimapple> @djinn (a -> Not (Not b)) -> Not (Not ( a -> b))
18:03:26 <lambdabot> f :: (a -> Not (Not b)) -> Not (Not (a -> b))
18:03:26 <lambdabot> f x1 x2 =
18:03:26 <lambdabot>   void (x2 (\ c26 ->
18:03:26 <lambdabot>      void (void (x1 c26 (\ _ -> void (x2 (\ c34 -> c34)))))))
18:04:37 <Cale> mwc: also, note that H (xHx^(-1)) = G
18:04:46 <mwc> Ahah, why?
18:05:03 <mwc> I know the conjugates are containted in G by Sylow II
18:05:23 <Cale> G being the whole group of order p^n
18:05:46 <Cale> By assumption |H| = p^(n-1)
18:05:56 <Cale> and so |xHx^(-1)| = p^(n-1) as well
18:05:59 <lennart> jimapple: to prove ~a->~b->~~(a:=:b) just use f=Not
18:06:33 <Cale> further, you know that |H xHx^(-1)| <= p^n, since it's a subgroup of G (x is in G)
18:06:46 <jimapple> I don't think I understand - how can I use an f, when :=: quantifies over all f's?
18:07:08 <Cale> also, since H and xHx^(-1) are assumed distinct, you know that |H xHx^(-1)| > p^(n-1)
18:07:13 <lennart> if it hold for all f it holds for Not as well
18:07:43 <lispy> math!
18:07:51 <lispy> omfg, math!
18:07:56 <Cale> (since the only way for it to be equal to p^(n-1) is for H to be equal to xHx^(-1))
18:08:27 <Cale> Also, you know that |H xHx^(-1)| divides p^n
18:08:35 <Cale> so it's got to be p^n
18:08:55 <Cale> (since p is prime)
18:09:30 <jimapple> @djinn ((a -> a) -> a) -> a
18:09:31 <lambdabot> f :: ((a -> a) -> a) -> a
18:09:31 <lambdabot> f x1 = x1 (\ c6 -> c6)
18:09:37 <lennart> or hve i lost myself in all the negations? :)
18:10:04 <Cale> lennart: is there a way to add data types to the bot? (I know we can do this in djinn proper)
18:10:21 <lennart> @help djinn
18:10:22 <lambdabot> Generates Haskell code from a type.
18:10:22 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:10:34 <lennart> @listcommand djinn
18:10:35 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
18:10:35 <lambdabot> ver
18:10:44 <Cale> jethr0: well, I'm okay with it :)
18:10:52 <Cale> lennart: ah, some of those look new :)
18:11:05 <lennart> @djinn-add data T x = (x,x,x)
18:11:12 <Cale> @help djinn-env
18:11:13 <lambdabot> Show the current djinn environment
18:11:19 <Cale> @djinn-env
18:11:20 <lambdabot> data T x = (x,x,x)
18:11:20 <lambdabot> data Equal a b = Equal { apply :: forall f . f a -> f b }
18:11:20 <lambdabot> data () = ()
18:11:20 <lambdabot> data Either a b = Left a | Right b
18:11:20 <lambdabot> data Maybe a = Nothing | Just a
18:11:22 <lambdabot> data Bool = False | True
18:11:23 <lennart> @djinn a -> T a
18:11:24 <lambdabot> data Void
18:11:26 <lambdabot> type Not x = x -> Void
18:11:28 <lambdabot> -- f cannot be realized.
18:11:42 <lennart> hmmmm
18:12:02 <lennart> @djinn-clr
18:12:09 <Cale> @djinn-env
18:12:10 <lambdabot> data () = ()
18:12:10 <lambdabot> data Either a b = Left a | Right b
18:12:10 <lambdabot> data Maybe a = Nothing | Just a
18:12:10 <lambdabot> data Bool = False | True
18:12:10 <lambdabot> data Void =
18:12:12 <lambdabot> type Not x = x -> Void
18:12:15 <lennart> @djinn-add data T x = (x,x,x)
18:12:28 <Cale> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
18:12:29 <lambdabot> f :: Maybe a -> (a -> Maybe b) -> Maybe b
18:12:29 <lambdabot> f x1 =
18:12:29 <lambdabot>   case x1 of
18:12:29 <lambdabot>   Nothing -> \ _ -> Nothing
18:12:29 <lambdabot>   Just v8 -> \ x9 ->
18:12:31 <lambdabot> [3 @more lines]
18:12:33 <Cale> @more
18:12:35 <lambdabot>      case x9 v8 of
18:12:35 <lambdabot>      Nothing -> Nothing
18:12:37 <lambdabot>      Just v16 -> Just v16
18:12:59 <jethr0> can't we teach it about fmap?
18:13:21 <lennart> not really :)
18:14:04 <jimapple> lennart: I dunno. I don't really see how we can substitute there, since, though the forall is on the LHS locally, it's on the RHS overall. If that makes any sense
18:15:18 <lennart> yeah, that's why i wondered if i was lost in negations.  i'll do it properly tomorrow
18:15:39 <jimapple> thanks for the help.
18:16:36 <Cale> lennart: could you explain type negation? I've seen ~a defined as a -> 0, where 0 is an empty type -- is 0 still assumed to contain _|_, or is it actually empty?
18:17:18 <lennart> it must be actually empty to make sense
18:17:32 <lennart> so you can't get it in haskell
18:17:46 <Cale> Does that mean that ~a doesn't have any elements unless a is itself empty?
18:17:55 <mwc> Cale, okay, so call K H conjugated by some x in G. Then |K| = |H| = p^k, where G = p^(k+1) Then by your earlier equation, |HK| = p^(k+1) = |H||K|/|H/\K| , so |H/\K| = p^(k - 1)
18:17:59 <mwc> what does that prove?
18:18:17 <lennart> Calse: yes
18:19:06 <Cale> lennart: okay -- I'm still not sure exactly what the purpose of it is :)
18:20:18 <Cale> mwc: hmm :)
18:20:33 <lennart> if you have a language without bottom it is very handy in some real programs. e.g. in a case analysis when you're in a branch that you cannot reach you can use void on the rhs
18:21:22 <jimapple> what languages are without bottom?
18:21:30 <jimapple> or rather, what type?
18:21:45 <jimapple> coq? charity? anything strict?
18:21:48 <lennart> well, coq doesn't have bottom
18:22:52 <mwc> Cale, I've come across some lecture notes that have for Sylow I two conditions: a) G contains a subgroup of order p^i for each 1 <= i <= n; b) every subgoup of order p^i is a normal subgroup of a subgroup or order p^(i+1), 1 <= i < n
18:22:56 <lennart> you need recursive functions to be terminating (and corecursive functions to be productive)
18:22:57 <mwc> I just need to find their proof
18:26:39 <Cale> jethr0: it does look like a nice start
18:27:05 <jimapple> I wish ESFP in Haskell were still alive and kicking
18:27:27 <jethr0> thx, i've got a code walker coming up next and some IO fun :)
18:29:08 <Cale> @djinn Not (s -> (s, Not s))
18:29:09 <lambdabot> -- f cannot be realized.
18:29:51 <Cale> right...
18:30:15 <Cale> @djinn Not (Not a) -> a
18:30:16 <jimapple> @djinn Not (s,Not s)
18:30:16 <lambdabot> -- f cannot be realized.
18:30:17 <lambdabot> f :: Not (s, Not s)
18:30:17 <lambdabot> f (v2, v3) = void (v3 v2)
18:30:40 <Cale> how is void defined?
18:30:48 <Cale> (the apparent function)
18:30:52 <jimapple> I dunno
18:31:00 <Cale> @djinn  a -> Not (Not a)
18:31:01 <lambdabot> f :: a -> Not (Not a)
18:31:01 <lambdabot> f x1 x2 = void (x2 x1)
18:31:32 <jimapple> @djinn a -> ((a -> Void) -> Void)
18:31:33 <lambdabot> f :: a -> (a -> Void) -> Void
18:31:33 <lambdabot> f x1 x2 = void (x2 x1)
18:31:52 <jimapple> void = id?
18:32:27 <jimapple> @djinn Not (Not (Not (s -> (s, Not s))))
18:32:28 <lambdabot> -- f cannot be realized.
18:32:57 <jimapple> @djinn Not (a -> a)
18:32:58 <lambdabot> -- f cannot be realized.
18:33:18 <Cale> @djinn Not(a -> Not a)
18:33:19 <lambdabot> -- f cannot be realized.
18:35:15 <lennart> Cale: well if Void was defined in Haskell as 'data Void ='  then the function would be 'void x = case x of { }'
18:35:46 <lennart> with type Void->a
18:36:17 <lennart> the case expression covers all constructors and all alternatives have the type they must have
18:37:40 <Cale> @djinn Not (s -> (s, Not a)) -> (s, s -> a)
18:37:41 <lambdabot> -- f cannot be realized.
18:37:53 <lispy> Cale: what is djinn?
18:37:53 <lennart> and when this is in a language where Void is really empty this is perfectly fine.  If you give me an element in the empty set i promise to give you anything.
18:38:11 <Cale> @djinn (b -> c) -> (a -> b) -> (a -> c)
18:38:12 <lambdabot> f :: (b -> c) -> (a -> b) -> a -> c
18:38:12 <lambdabot> f x1 x2 x3 = x1 (x2 x3)
18:38:20 <Cale> lispy: theorem prover
18:38:33 <dons> @help djinn
18:38:35 <lambdabot> Generates Haskell code from a type.
18:38:35 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:38:36 <lispy> Cale: shows existence of types?
18:38:37 <Cale> It writes Haskell code which is a witness of a type you give it
18:38:43 <lispy> ah
18:38:48 <dons> shows existence of functions :)
18:39:59 <jimapple> shows existence of god?
18:40:01 <Cale> @djinn Not (s, Not a) -> (s -> a)
18:40:02 <lambdabot> -- f cannot be realized.
18:40:13 <Cale> I suppose that's reasonable
18:40:21 <Pupeno> jimapple: do you know God's type ?
18:40:22 <Cale> hmm
18:40:42 <jimapple> semitic, married to joseph?
18:40:44 <lennart> @djinn Either toBe (Not toBe)
18:40:45 <lambdabot> -- f cannot be realized.
18:41:20 <jimapple> (a -> a) -> a
18:41:20 <jimapple> God doesn't terminate
18:41:20 <tennin> a -> Bool perhaps?
18:41:38 <lennart> @djinn Not (Not (Either toBe (Not toBe)))
18:41:39 <lambdabot> f :: Not (Not (Either toBe (Not toBe)))
18:41:39 <lambdabot> f x1 = void (x1 (Right (\ c23 -> void (x1 (Left c23)))))
18:42:13 <dons> lennart, Djinn> data () = ()
18:42:13 <dons> Cannot parse command
18:42:44 <lennart> dons: () is builtin, it cannot be given as a command
18:42:53 <dons> ok :)
18:43:04 <dons> so that means I can't pipe :environment >>= djinn
18:43:12 <dons> but it's easy enough to work around
18:43:17 <lennart> umm, not quite
18:43:25 <lennart> include a tail, or something
18:44:02 <dons> yup.
18:44:55 <Cale> hmm
18:45:06 <Cale> @djinn (s -> a) -> Not (s, Not a)
18:45:07 <lambdabot> f :: (s -> a) -> Not (s, Not a)
18:45:07 <lambdabot> f x1 (v3, v4) = void (v4 (x1 v3))
18:45:10 <Cale> aha
18:45:41 <rep>  /win 13
18:45:43 <rep> ..
18:47:13 <soysauce> hmm
18:47:27 <Cale> unusual logic :)
18:47:42 <soysauce> if I want to extract data from a mutable array, do I have to first freeze it?
18:47:50 <lennart> unusual?  constructive!
18:47:55 <Cale> yes
18:48:05 <Cale> constructive logic is quite unusual :)
18:48:18 <lennart> to me it's quite usual :)
18:49:33 <lennart> djinn is not very smart about void.  i think there's one more than you need in that proof
18:50:23 <Cale> @djinn Not (Not (s, Not a) -> (s -> a))
18:50:24 <lambdabot> -- f cannot be realized.
18:50:49 <Cale> hmm
18:51:03 <twb> I want a nethack locale!
18:51:13 <twb> "Your f has been eaten by a grue.
18:51:25 <Cale> for which instantiations of the variables does is  Not (s, Not a) -> (s -> a)  true?
18:51:55 <Cale> @djinn Not (Void, Not Void) -> (Void -> Void)
18:51:56 <lambdabot> f :: Not (Void, Not Void) -> Void -> Void
18:51:56 <lambdabot> f _ x3 = void x3
18:52:08 <Cale> that's unimpressive though :)
18:52:15 <Cale> @djinn Not (s, Not Void) -> (s -> Void)
18:52:17 <lambdabot> f :: Not (s, Not Void) -> s -> Void
18:52:17 <lambdabot> f x1 x3 = void (x1 (x3, void))
18:52:35 <Cale> @djinn Not (Void, Not a) -> (Void -> a)
18:52:37 <lambdabot> f :: Not (Void, Not a) -> Void -> a
18:52:37 <lambdabot> f _ x3 = void x3
18:52:48 <Cale> okay, so if either is Void, we get a proof
18:53:29 <Cale> @djinn (Either (a -> Void) (b -> Void)) -> Not (s, Not a) -> (s -> a)
18:53:30 <lambdabot> -- f cannot be realized.
18:53:33 <Cale> hmm
18:53:40 <Cale> er
18:53:43 <Cale> @djinn (Either (a -> Void) (s -> Void)) -> Not (s, Not a) -> (s -> a)
18:53:44 <lambdabot> f :: Either (a -> Void) (s -> Void) -> Not (s, Not a) -> s -> a
18:53:44 <lambdabot> f x1 =
18:53:44 <lambdabot>   case x1 of
18:53:44 <lambdabot>   Left v4 -> \ x5 x7 -> void (x5 (x7, \ c24 -> void (v4 c24)))
18:53:44 <lambdabot>   Right v19 -> \ _ x22 -> void (v19 x22)
18:53:44 <lennart> b?
18:53:49 <Cale> yeah
18:55:03 <lennart> bedtime, but you seem to be having fun, Cale :)
18:55:06 <Cale> :)
18:55:25 <Cale> I'm still not quite sure why that original type shouldn't have a proof
18:55:56 <Cale> Probably something to do with inability to eliminate double negations :)
18:56:04 <lennart> Well, just because P doesn\t have a proof doesn't mean that ~P does.  And vice versa.
18:56:27 <Cale> @djinn Not (s, Not a) -> Not (Not (s -> a))
18:56:28 <lambdabot> f :: Not (s, Not a) -> Not (Not (s -> a))
18:56:28 <lambdabot> f x1 x3 =
18:56:28 <lambdabot>   void (x3 (\ c27 ->
18:56:28 <lambdabot>      void (void (x1 (c27, \ _ -> void (x3 (\ c42 -> c42)))))))
18:56:33 <Cale> hmm, okay
18:56:44 <soysauce> @type void
18:56:46 <lambdabot> Not in scope: `void'
18:57:16 <lennart> but the double negation of any classically true formula is true constructively too.  just incomprehensible :)
18:57:28 * SamB is surprised that lilypond supports volta repeat marks in mid-measure
18:57:31 <lennart> void :: Void ->a
18:57:49 * SamB wonders whether this is a bug or a feature
18:58:05 <Cale> @djinn Not (Not (Not a)) -> Not a
18:58:06 <lambdabot> f :: Not (Not (Not a)) -> Not a
18:58:06 <lambdabot> f x1 x2 = void (x1 (\ c9 -> void (c9 x2)))
18:58:09 <Cale> aha
18:58:17 <Cale> so there's a limit to the double negations
18:58:33 <lennart> yes 2 is the limit
19:04:13 <soysauce> @djinn a -> b
19:04:14 <lambdabot> -- f cannot be realized.
19:10:03 <twb> If in my Main module I define "space", will the functions that refer to "space" in the Parsec module still use the definition of "space" from the Parsec module?
19:10:17 <SamB> twb: of course
19:10:20 <twb> Phew.
19:10:33 <SamB> heard of lexical scope?
19:10:41 <SamB> I hear its all the rage these days.
19:10:44 <twb> Yes, but you can't trust some languages.
19:10:52 <SamB> well, this isn't Lisp ;-)
19:10:57 <jethr0> can bound names function in pattern matching?
19:11:05 <SamB> we have a 100% genuine module system
19:11:13 <jethr0> under any circumstances?
19:11:17 <SamB> with 100% pure names
19:11:30 <SamB> jethr0: only if they are data constructors
19:11:38 <jethr0> ah, ok
19:11:44 <SamB> which can't be rebound
19:15:02 <twb> OK, here is an interesting question.
19:15:13 <twb> I'm reading how Parsec can handle context-sensitive grammars.
19:15:19 <jethr0> hmm
19:15:22 <soysauce> @type map fst
19:15:23 <lambdabot> forall a b. [(a, b)] -> [a]
19:15:28 <twb> So instead of newline = try string "\r\n" <|> char '\n' <|> char '\r'
19:15:31 <soysauce> @type fst . unzip
19:15:32 <lambdabot> forall a b. [(a, b)] -> [a]
19:15:35 <soysauce> hah
19:16:02 <twb> How to define a parser that looks for any type of newline, but after the first one only looks for that type of newline?
19:16:07 <Pseudonym> Now here's a strange thing.
19:16:21 <Pseudonym> The nice person who made my lunch commented that most women want their sandwiches cut, but most men do not.
19:16:23 <Pseudonym> Discuss.
19:16:38 <soysauce> haha
19:16:57 <Pseudonym> Theory 1: Women have smaller hands.
19:17:05 <Pseudonym> Theory 2: Women THINK they have smaller mouths.
19:17:06 <jethr0> twb, you could make a parser that returns a monadic parser
19:17:09 <soysauce> I think it's more pragmatic than that.
19:17:25 <soysauce> Theory 3: Women care more about aesthetics than effort. Men care more about effort than aesthetics.
19:17:33 <Pseudonym> That's a good theory.
19:17:35 <jethr0> thus, you parse until you've found a newline, continue with your generated parser and then "combine" their two results
19:17:50 <jethr0> but i'm sure there's a more straightforward way
19:17:56 <Pseudonym> The upshot is that if anyone is interested in an honours-level research project...
19:18:06 <Pseudonym> You could probably get published in AIR.
19:18:12 <soysauce> Cut sandwiches look nice. Uncut sandwiches do not. When I make a sandwich, I know that I'm going to eat it, so I don't care wtf it looks like.
19:18:19 <soysauce> haha
19:18:32 <twb> AI Report?
19:18:37 <SamB> hmm.
19:18:46 <SamB> is that anything like radio?
19:18:56 <twb> Anyway, that's my interesting problem of the day.
19:19:02 <soysauce> I think basically the same thing can be said about folding bedsheets, ironed clothes, etc.
19:19:20 <twb> I won't let women iron my shirts.
19:19:23 <soysauce> I was once told by a female friend that the way you tell a bachelor from a married man is whether or not his clothes are wrinkled
19:19:26 <twb> It's a criminal waste of time.
19:19:42 <twb> soysauce: sure, Doyle made the same observation.
19:20:05 <soysauce> actually I think it was my mum who said that to me <shrug> either way
19:20:19 <Pseudonym> Such people have never seen a geek couple.
19:20:21 <twb> I suspect Doyle still predates her.
19:20:30 <soysauce> twb - chances are high
19:20:32 <Pseudonym> Neither my wife nor myself could care less about ironing.
19:21:14 <SamB> Pseudonym: so, you don't own an iron and never will, or you use it only for things that most people have never heard of?
19:21:31 <twb> He has an iron!
19:21:35 <Pseudonym> I do have an iron.
19:21:37 <twb> How else do you melt solder?
19:21:41 <Pseudonym> True!
19:21:51 <Pseudonym> My wife has a curling iron.
19:21:54 <SamB> not that kind, silly
19:22:02 <SamB> the irony kind
19:22:02 <Pseudonym> Does that count?
19:22:16 <Pseudonym> We don't have a waffle iron.
19:22:18 * Pseudonym thinks
19:22:25 <soysauce> used waffles
19:22:33 <SamB> you are pretending not to know about the iron-shaped kind?
19:22:50 <Pseudonym> I have no golf clubs.
19:23:02 <Pseudonym> I have no livestock that require branding.
19:23:05 * luqui wonders what the heck anyone is talking about
19:23:05 * Pseudonym thinks
19:23:30 <soysauce> <Pseudonym> Neither my wife nor myself could care less about ironing.
19:23:31 <soysauce> <SamB> Pseudonym: so, you don't own an iron and never will, or you use it only for things that most people have never heard of?
19:23:43 <soysauce> that is how it started...sort've
19:23:46 <Pseudonym> As for the clothes iron, yes, we have one.
19:23:52 <luqui> soo desu ne
19:24:05 <soysauce> sodesuka
19:24:09 <Pseudonym> We use it for business shirts, which I never wear unless I have to go to a wedding or something.
19:24:23 <SamB> wouldn't that make them wedding shirts?
19:24:30 <Cale> How you tell a bachelor from an unmarried man, on the other hand, is you hire a philosopher.
19:24:32 <Pseudonym> They also work for funerals.
19:24:34 <SamB> around here they get called "dress shirts"
19:24:46 <soysauce> Cale - heh, amusing
19:24:48 <Pseudonym> Cale: That's right, because the philosopher is almost certainly single.
19:24:50 <SamB> (despite the lack of resamblance to a dress)
19:25:50 <Pseudonym> How you tell a bachelor from an unmarried man is to get a contact inside the registry of births, deaths and marriages.  As an added benefit, you can also tell born from unborn people, and alive from dead people using the same contact.
19:26:24 <soysauce> unmarried implying divorced?
19:26:26 <jethr0> pseudonym, hmm, recognizing the undead...
19:26:37 <Pseudonym> I believe that divorces are also registered.
19:26:57 <Pseudonym> You'd also need to be able to tell widows from unmarried.
19:27:01 <soysauce> I assumed the comment was in jest, since all bachelors are unmarried (though it remains to be said that all unmarried men are not bachelors, I think)
19:27:11 <Pseudonym> Hence death records are important.
19:27:26 * soysauce ponders
19:27:51 <Pseudonym> Your difficulty would be if the marriage or divorce took place in another jurisdiction.
19:27:56 <mwc> What's the difference between a pure mathematician and a philosopher?
19:27:56 <mwc> A pure mathematician only needs paper, some pencils, and a wastebasket to work. A philosopher won't be needing the wastebasket.
19:28:54 <soysauce> a pure mathematician is referentially transparent?
19:29:13 <Pseudonym> A less reliable but simpler method is to pose as a researcher, approach the person in question, and pretend to be conducting a survey.  If the person agrees, ask for marital status.  When they answer, run away quickly before they realise that you don't have any more questions.
19:29:14 <Korollary> no, the philosopher is write-only
19:29:16 <Cale> haha
19:29:28 <Pseudonym> The philosopher has automatic garbage collection.
19:29:53 <mwc> Cale, could you take a look at my latest problem in #math?
19:29:55 <soysauce> you would have to, when you only generate garbage
19:30:15 <Pseudonym> Ah, I see.  The philosopher basically has a memory leak because of dangling references.
19:31:24 <soysauce> 42
19:31:58 <Pseudonym> Or 41.9997138612 if you're computing it on a Pentium I.
19:32:33 <soysauce> tbf the error was much smaller and only in 5 entries in the ROM
19:33:01 <soysauce> there have been a number of much more egregious processor bugs
19:33:07 <Pseudonym> Oh, absolutely.
19:33:13 <Pseudonym> I had a Cyrix once.
19:33:15 <soysauce> haha
19:33:18 <Pseudonym> :-)
19:33:23 <soysauce> did you ever see the COMA bug?
19:33:29 <Pseudonym> You basically had to completely disable cache write-back.
19:33:49 <soysauce> I vaguely remember hearing about that one, too
19:34:00 <soysauce> but I was referring to flaws that allow you to root the OS
19:34:01 <Pseudonym> Oh, I've heard of it.
19:34:04 <soysauce> or at least denial-of-service
19:34:58 <soysauce> I know of several nasty DoS bugs. One was in the PIII. A friend showed me one night at his house. He had an XP box and a Win2K box both running on a PIII. When he ran his program, one of them locked up and the other kept running.
19:35:14 <Korollary> I'm not reading any articles in businessweek...
19:35:21 <soysauce> about?
19:35:37 <Korollary> anything, esp. about technology.
19:35:46 <soysauce> nevermind then
19:38:39 <soysauce> come to think of it, every Intel chip since the original Pentium has had a flaw in it that allows you to deadlock it. Cyrix had one, too. I don't know of one on the P4, but I'd bet it's there somewhere.
19:39:35 <soysauce> AMD had an awesome timing-dependent bug that would cause certain interrupted instructions to be incorrectly resumed after an interrupt
19:42:27 * cpatrick blinks
19:42:56 <cpatrick> twb`: are there any irc channels you're not on? ;)
19:45:09 <jethr0> soysauce, that's what you have an operating system for, right? :))
19:45:20 <twb`> cpatrick: hello hello hello
19:45:29 <twb`> I'm guessing from your nick that you're you.
19:45:43 <cpatrick> yeah, some of the time
19:45:47 <soysauce> jethr0 - fortunately, as it would seem
19:45:55 * jethr0 is not himself lately :)
19:45:56 <twb`> Most channels I'm in are #emacs offshoots.
19:46:07 <cpatrick> heh
19:46:21 <twb`> I'm playing with Parsec :D
19:46:25 <jethr0> oh, an emacs zealot i can start a flamewar with...
19:46:32 <cpatrick> parsec is pretty cool
19:46:39 <twb`> It's damn cool.
19:46:39 <soysauce> haha
19:46:43 <cpatrick> much nicer than anything bison-ic, anyway
19:46:59 <jethr0> twb`did you get any more helpful reponses to your question than mine?
19:47:01 <twb`> Riastradh tells me that MIT Scheme has something similar, but then you're locked in to that implementation :-(
19:47:08 <twb`> jethr0: don't think so.
19:47:15 <jethr0> but it _is_ possible
19:47:21 <cpatrick> trent- BTW I'll be visiting melbourne in a coupla weeks time
19:47:31 <twb`> cpatrick: I'll be in Perth in a week :-)
19:47:44 <cpatrick> I won't :P
19:47:49 <twb`> 21st to the 28th, IIRC.
19:47:53 <jethr0> twb`, you write a function that returns your monadic parser and give it a list of allowed newlines as argument
19:48:20 <jethr0> whenever you encounter the first newline you then call the function again with this newline and just have to make sure it's not calling itself again
19:48:38 <twb`> jethr0: I agree.  But I deferred that problem while I make it work for UNIX EOLs initially.
19:49:58 <jethr0> let fun allowNewlines doRecurse = ...; if doRecurse then fun currentNewline False else (rest)
20:08:18 <twb`> Is there a way to do load foo.hs and run a particular function in it, rather than having to define a "main" function?
20:08:36 <twb`> e.g. hugs foo.hs --eval "myfunc"
20:08:59 <jethr0> ghci allows passing of code to be evaluated.
20:09:02 <jethr0> just a sec
20:10:35 <jethr0> ghc -e "myfunc"
20:10:43 <jethr0> ghc foo.hs -e "myfunc"
20:10:49 <twb`> Yeah, just found it myself.
20:10:53 <jethr0> :)
20:11:24 <twb`> Whee: <interactive>: internal error: scavenge_one: strange object 32137
20:11:38 <Korollary> a ufo sighting...
20:11:46 <jethr0> *aaahhh*
20:11:59 <twb`> I also get "sh: turning off NDELAY mode", which I've never seen before.
20:12:08 <Korollary> whoa...
20:12:14 <Korollary> that's deep.
20:12:36 <twb`> Alien processess walk among or /procs...
20:12:46 <twb`> *our
20:12:48 <twb`> *processes
20:13:31 <Korollary> are you on freebsd?
20:13:43 <Pupeno> Does anybody know why the Debian/(K)Ubuntu package of washngo contains a bunch of new files on src/ that are not on the mainstream WashNGo ?
20:14:00 <Korollary> twb`: "That message comes up when sh notices that someone has set the
20:14:00 <Korollary> O_NONBLOCK flag on stdin.  sh resets it back to normal and prints the
20:14:00 <Korollary> above notice.  You usually see this when a curses or pthreads program
20:14:02 <Korollary> coredumps without resetting the terminal."
20:14:12 <twb`> Ah.
20:14:17 <Pupeno> maybe something to do with Cabal ?
20:14:25 <twb`> Korollary: Such as when it doesn't call the curses cleanup function.
20:14:34 <twb`> Korollary: ...because it's crashed.
20:15:02 <twb`> Pupeno: are they source files?
20:15:18 <Pupeno> twb`: yes, haskell source files, lots of them.
20:15:45 <twb`> Pupeno: maybe they are using the darcs head.
20:15:51 <Pupeno> I'll paste one, lisppaste2: url
20:15:59 <Pupeno> lisppaste2: url
20:15:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:16:07 <twb`> Pupeno: I have no washngo package in Debian/experimental, so we can safely blame Ubuntu.
20:16:48 <Pupeno> twb`: http://packages.debian.org/unstable/libdevel/libghc6-wash-dev
20:17:24 <twb`> Damn.
20:17:32 <Pupeno> twb`: I don't think it's darcs head, actually, it's kinda old. And the new files are on a directory, src/, which is not present on the original washngo.
20:17:35 <twb`> Ah, that'd be why "washngo" didn't match.
20:18:12 <Pupeno> twb`: indeed.
20:18:12 <twb`> Pupeno: Depends: ghc6 (< 6.4-999) but 6.4.1-1 is to be installed
20:18:20 <twb`> Pupeno: looks like it's way-old stuff.
20:18:35 <twb`> possibly prior to the tarball you're looking at.
20:19:10 <Pupeno> twb`: both, the version of washngo of the .deb and the new washngo doesn't have a src/ directory.
20:19:35 <Pupeno> twb: I am using ghc 6.4.1, I have just packaged for ubuntu.
20:19:35 <twb> OK, I give up.
20:19:52 <twb> Is "as" a reserved word in Haskell?
20:20:10 <Pupeno> I bet that if some experienced haskeller could take a look at the file, (s)he would figure it out fast.
20:20:16 <jethr0> twb, what does "as" do in haskell?
20:20:25 <twb> No idea, but Emacs made it blue
20:20:41 <shapr> import Foo qualified as Bar
20:20:47 <lisppaste2> Pupeno pasted "FileNames.hs" at http://paste.lisp.org/display/14624
20:20:47 <jethr0> ah, sure
20:21:14 <jethr0> what's the problem with it?
20:21:19 <twb> Nothin.
20:21:23 <shapr> It's amusing to see the conversation go from heavy duty type theory to whether you should let a woman iron your shirts.
20:21:24 <Pupeno> that is one of the of the files.
20:21:25 <twb> Just looks funny in th' editor.
20:21:46 <twb> shapr: if only it more often went the other way...
20:22:04 <jethr0> shapr, i got along quite well with "my" TH tutorial...
20:22:43 <shapr> jethr0: It's yours now.
20:22:47 <jethr0> :)
20:23:16 <shapr> I'm happy to see it!
20:23:28 <shapr> twb: Yeah, I so rarely get to talk about monads at dinner parties.
20:23:52 <jethr0> if you like, you could give some feedback about it appearance (not necessarily content)
20:24:14 <twb> shapr: obviously you go to the wrong dinner parties.
20:25:20 * jethr0 likes the idea of a program that when compiled prints itself... and not with some baloney quine function :))
20:25:44 <twb> jethr0: what, at compile-time? :-)
20:26:17 <jethr0> not necessarily... i mean it reads itself at compile time, splices the content into the program and outputs it at runtime
20:26:18 <jethr0> *yeah*
20:26:44 <twb> h.
20:26:46 <twb> *Oh.
20:26:56 <twb> Sort of like the reflections on trusting trust example.
20:27:36 <jethr0> huh? sort of like the reflect about your environment at compile-time example
20:27:51 <twb> nm
20:28:15 <jethr0> there's actually a paper where they chose an algorithm at compile time dependent on the local network/grid structure :)
20:28:28 <jethr0> using template haskell
20:32:45 <jethr0> @listcommands
20:32:46 <lambdabot> use listcommands [module|command], please. Modules are:
20:32:46 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
20:32:46 <lambdabot> hoogle karma localtime more pl plugs poll quote search seen spell state
20:32:46 <lambdabot> system todo topic type version vixen where
20:35:49 <jethr0> $pretty let fun x | x < 3 = 2 | x < 5 = 3 | x == 5 = 4 | otherwise = 5 in fun 4
20:35:50 <jethr0_bot> #  i = let fun x
20:35:50 <jethr0_bot> #            | x < 3 = 2
20:35:50 <jethr0_bot> #            | x < 5 = 3
20:35:50 <jethr0_bot> #            | x == 5 = 4
20:35:50 <jethr0_bot> #            | otherwise = 5
20:35:52 <jethr0_bot> #        in fun 4
20:36:19 <jethr0> $pretty fun x | x < 3 = 2 | x < 5 = 3 | x == 5 = 4 | otherwise = 5
20:36:20 <jethr0_bot> #  fun x  | x < 3 = 2
20:36:20 <jethr0_bot> #         | x < 5 = 3
20:36:20 <jethr0_bot> #         | x == 5 = 4
20:36:20 <jethr0_bot> #         | otherwise = 5
20:48:56 <triplah> we need jethr0_bot to take a pretty definition and feed it to lambdabot as a single line > let
20:48:58 <triplah> :D
20:49:14 <jethr0> :)
20:49:23 <jethr0> i've actually thought about that
20:49:33 <jethr0> but irc is pretty much a one-line medium :(
20:49:38 <triplah> yeah :\
20:49:46 <triplah> lots of stupid lineparsing
20:49:53 <triplah> to get rid of timestamps etc
20:49:54 <triplah> :P
20:50:03 <triplah> what is lambdabot written in?
20:50:06 <jethr0> the hard part is understanding where to start and where to stop
20:50:10 <jethr0> haskell
20:50:12 <triplah> what sockets does it use?
20:50:14 <triplah> ahh ok
20:50:27 <triplah> does it receive timestamps?
20:50:32 <jethr0> lineparsing is done, but start / stop marking is a problem
20:50:39 <triplah> hmm
20:50:40 <jethr0> don't know, but i guess so
20:50:59 <triplah> you'd want it dont in a way the requires no modification to original code
20:51:05 <triplah> but that'd be near impossible
20:51:09 <jethr0> keeping state and deciding when to scrap the state when no stop mark arrives *brr*
20:51:12 <triplah> especially with haskells syntax
20:51:13 <triplah> :)
20:51:45 <triplah> you could force use of ; i suppose
20:51:50 <jethr0> i don't see where there would be need for modifications
20:52:02 <jethr0> just the state-keeping / timeouting isn't so nice
20:52:03 <triplah> well what if i did this
20:52:29 <triplah> x n = 1 + 1
20:52:35 <triplah> where is my var name?
20:52:46 <triplah> is the where part of the statement, or part of my question?
20:53:17 <jethr0> yah, as i said start/stop markers and obviously the option to fail *g*
20:53:39 <triplah> yeah, thats what im saying, using ; might be an workaroundish way to fix that
20:53:42 <triplah> :P
20:53:52 <jethr0> (((fun 0 = 1
20:53:54 <triplah> wont work in all cases of course :\
20:53:57 <jethr0> fun n = 5)))
20:54:37 <jethr0> actually, i don't have such a big problem with giving single lines to lambdabot... but it's so damn unreadable!
20:54:52 <triplah> yeah haha
20:56:53 <twb> jethr0: there is a problem if it's over 256 characters of code...
20:57:09 <jethr0> where?
20:57:31 <triplah> irc lines cant be more than 265 chars
20:57:43 <triplah> ie, if hat you want to evaluate is a little longer
20:57:47 <triplah> what*
20:58:45 <jethr0> > length "fun averylongvariablenamemadeuptryingtoexceed256characters = averylongvariablenamemadeuptryingtoexceed256characters * averylongvariablenamemadeuptryingtoexceed256characters"
20:58:46 <lambdabot> 172
20:58:51 <jethr0> > length "fun averylongvariablenamemadeuptryingtoexceed256characters = averylongvariablenamemadeuptryingtoexceed256characters * averylongvariablenamemadeuptryingtoexceed256characters + averylongvariablenamemadeuptryingtoexceed256characters"
20:58:52 <lambdabot> 229
20:58:58 <jethr0> > length "fun averylongvariablenamemadeuptryingtoexceed256characters = averylongvariablenamemadeuptryingtoexceed256characters * averylongvariablenamemadeuptryingtoexceed256characters + averylongvariablenamemadeuptryingtoexceed256characters + averylongvariablenamemadeuptryingtoexceed256characters"
20:58:59 <lambdabot> 286
20:59:06 <jethr0> $pretty fun averylongvariablenamemadeuptryingtoexceed256characters = averylongvariablenamemadeuptryingtoexceed256characters * averylongvariablenamemadeuptryingtoexceed256characters + averylongvariablenamemadeuptryingtoexceed256characters + averylongvariablenamemadeuptryingtoexceed256characters
20:59:07 <jethr0_bot> #  fun averylongvariablenamemadeuptryingtoexceed256characters
20:59:07 <jethr0_bot> #      = averylongvariablenamemadeuptryingtoexceed256characters *
20:59:07 <jethr0_bot> #            averylongvariablenamemadeuptryingtoexceed256characters
20:59:07 <jethr0_bot> #            + averylongvariablenamemadeuptryingtoexceed256characters
20:59:07 <jethr0_bot> #            + averylongvariablenamemadeuptryingtoexceed256characters
21:00:20 <soysauce> @eval 9+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+
21:00:21 <lambdabot>  parse error on input `}'
21:00:24 <soysauce> bah
21:00:34 <soysauce> @eval 1+2
21:00:35 <lambdabot> 3
21:00:43 <soysauce> must have ended on a plus
21:00:46 <jethr0> $pretty  x = 9+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2
21:00:47 <jethr0> +2
21:00:47 <jethr0_bot> #  x = 9 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 +
21:00:47 <jethr0_bot> #        2
21:00:47 <jethr0_bot> #        + 2
21:00:47 <jethr0_bot> #        + 2
21:00:47 <jethr0_bot> #        + 2
21:00:49 <twb> soysauce: right.
21:00:49 <jethr0_bot> [197 @more lines]
21:00:51 <soysauce> @eval  10+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+
21:00:52 <lambdabot>  parse error on input `}'
21:00:53 <jethr0> *yuch*
21:00:56 <soysauce> ...or not
21:00:59 <Speck> eh
21:01:01 <jethr0> > 9+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2
21:01:03 <twb> soysauce: ended in + again.
21:01:06 <lambdabot> 443
21:01:10 <soysauce> oh, d'oh
21:01:17 <soysauce> @eval   11+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2
21:01:22 <lambdabot> 443
21:02:37 * Frederick falls hitten by a 2
21:02:44 <Frederick> *hit
21:04:09 <cpatrick> argh, my eyes
21:04:30 <Cale> The goggles! They do nothing!
21:27:54 <twb> fixed it.
21:28:08 <twb> I needed to use manyTill instead of many.
21:28:11 <twb> Sexy!
21:28:30 <jimapple> @djinn Not Void
21:28:31 <lambdabot> f = void
21:28:41 <twb> @djinn help
21:28:42 <lambdabot> -- f cannot be realized.
21:28:47 <twb> What is djinn?
21:28:48 <jimapple> @djinn Not (Not Void)
21:28:48 <lambdabot> -- f cannot be realized.
21:28:54 <jimapple> @help djinn
21:28:54 <lambdabot> Generates Haskell code from a type.
21:28:54 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:29:08 <jimapple> @djinn Not (Not a)
21:29:08 <lambdabot> -- f cannot be realized.
21:29:18 <araujo> Hello around.
21:29:55 <jimapple> @djinn Either a (Not a) -> (a -> b) -> Either (Not a) b
21:29:55 <lambdabot> f x1 =
21:29:55 <lambdabot>   case x1 of
21:29:55 <lambdabot>   Left v4 -> \ x5 -> Right (x5 v4)
21:29:55 <lambdabot>   Right v12 -> \ _ -> Left (\ c27 -> void (v12 c27))
21:30:01 <jethr0_> hi araujo
21:30:09 <twb> Grr.  What's the point of uppercasing the names of important files if people aren't going to set LC_COLLATE=C?
21:30:11 <araujo> Hello jethr0_ 
21:30:41 <jimapple> @djinn ((a -> b) -> Either (Not a) b) -> Either a (Not a)
21:30:41 <lambdabot> -- f cannot be realized.
21:30:47 <twb> @djinn a -> a
21:30:48 <lambdabot> f x1 = x1
21:30:49 <jimapple> @djinn ((a -> b) -> Either (Not a) b) -> Not (Not (Either a (Not a)))
21:30:50 <lambdabot> f x1 x2 =
21:30:50 <lambdabot>   case x1 (\ c30 -> void (x2 (Left c30))) of
21:30:50 <lambdabot>   Left v13 -> void (x2 (Right (\ c52 -> void (v13 c52))))
21:30:50 <lambdabot>   Right _ -> void (x2 (Right (\ c48 -> void (x2 (Left c48)))))
21:31:39 <jimapple> @djinn (Not (Not a) -> a) -> Either a (Not a)
21:31:40 <lambdabot> -- f cannot be realized.
21:32:00 <jimapple> @djinn EIther a (Not a) -> Not (Not a) -> a
21:32:01 <lambdabot> -- f cannot be realized.
21:32:18 <jimapple> @djinn Either a (Not a) -> Not (Not a) -> a
21:32:19 <lambdabot> f x1 =
21:32:19 <lambdabot>   case x1 of
21:32:19 <lambdabot>   Left v4 -> \ _ -> v4
21:32:19 <lambdabot>   Right v6 -> \ x7 -> void (x7 (\ c12 -> void (v6 c12)))
21:34:08 <jimapple> @djinn Not (a, Not a)
21:34:09 <lambdabot> f (v2, v3) = void (v3 v2)
21:35:23 <Cale> aha, that's a nice one :)
21:36:04 <Cale> @djinn (Not (Not a) -> a) -> Not (Not (Either a (Not a)))
21:36:05 <lambdabot> f x1 x2 =
21:36:05 <lambdabot>   void (x2 (Left (x1 (\ c39 ->
21:36:05 <lambdabot>         void (x2 (Right (\ c40 -> void (c39 c40))))))))
21:36:18 <Cale> hmm
21:36:27 <Cale> @djinn Not (Not (Either a (Not a)))
21:36:28 <lambdabot> f x1 = void (x1 (Right (\ c23 -> void (x1 (Left c23)))))
21:43:42 <twb> So I'm trying to work out how to create type classes.
21:43:45 <soysauce> @type ixmap
21:43:45 <lambdabot> Not in scope: `ixmap'
21:43:52 <soysauce> @type Ix.ixmap
21:43:53 <lambdabot> Not in scope: `Ix.ixmap'
21:43:57 <soysauce> huh
21:44:00 <jethr0> @hoogle ixmap
21:44:00 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j)
21:44:00 <lambdabot> -> a j e -> a i e
21:44:00 <lambdabot> Data.Array.ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e ->
21:44:00 <lambdabot> Array i e
21:44:24 <twb> like: instance DeWiki HTML where output (Emph x) = "<em>"++x++"</em" etc.
21:44:37 <soysauce> thanks
21:44:42 <jethr0> np
21:45:04 <soysauce> looks like "Array" is really a synonym for Data.Array.IArray
21:45:26 <soysauce> hey, wtf, how can that be a j e -> a i e?
21:45:31 <soysauce> shouldn't that be a i e -> a j e?
21:46:10 <jethr0> hmm, it supposedly has to be bijective!?
21:46:12 <soysauce> oh, I see
21:46:23 <twb> Are all haskell arrays of arity 2, then?
21:46:36 <soysauce> creates a new array with indexing type i and then maps each element onto an old index j and then copies
21:46:43 <Speck> aaaaaaaaaah
21:46:44 <soysauce> twb - 'arity'?
21:46:49 <twb> soysauce: er, dimension
21:47:00 <soysauce> you can go up to 5 or something like that.
21:47:09 <soysauce> you can go higher, too, if you provide the instance of Ix
21:47:31 <jethr0> speck, what's the matter?
21:47:48 * soysauce mumbles something incoherent about the lack of genericness in Haskell tuples
21:48:32 * jethr0 agrees but is sure that they are so inflexible for a specific (probably type-related) reason
21:48:46 <soysauce> likely
21:49:00 <Speck> jethr0: finals :-( had to yell but my roommates are sleeping so I yelled in the nearest alternate dimension, which happened to be irc 
21:49:01 <soysauce> I suppose it is worthwhile to distinguish between ((a, a), (b, b)) and (a, a, b, b)
21:49:10 <jethr0> hehe
21:49:37 <jethr0> definitely
21:49:52 <Speck> it works too
21:50:16 <jethr0> speck, what kind of finals? CS?
21:50:32 * soysauce has completed 2/4 finals :p
21:50:49 <soysauce> tomorrow is my Haskell "final" which is really a pizza party
21:50:54 <Speck> I'm an English major -- so essays. I have 62 pages to write by saturday
21:50:54 <jethr0> > 2.0/4.0 == 1.0/2.0
21:50:56 <lambdabot> True
21:51:06 <soysauce> Speck - wow, that's pretty crappy
21:51:09 <jethr0> aaaahhh, what about?
21:51:42 * soysauce was moaning about having to write a 6-page essay about a week ago... ;)
21:51:46 <Speck> mostly lit, and some history
21:51:57 <soysauce> what sort of history?
21:52:05 <soysauce> lit is boring, but history owns ;)
21:52:15 <Speck> soysauce: chinese law/society 17th-20th centuries
21:52:22 <soysauce> oh really? How interesting
21:52:33 <Speck> it's really interesting actually
21:52:36 <soysauce> I was just about to comment that I took a course on Chinese History
21:53:06 <Speck> (my best final is my only math class - http://lorentz.phl.jhu.edu/symlog/final_hmwk.pdf)
21:53:09 <soysauce> finished the final on Monday. It was the hardest class I have ever taken, but at the same time it was one of the more interesting ones. I can't say that it was the *most* interesting, but it definitely ranks high.
21:53:36 <soysauce> hm, how early in the 17th century? The beginning of the Qing dynasty?
21:53:44 <Speck> yeah
21:53:55 <soysauce> effectively the reign of Kang-xi
21:54:13 <soysauce> had to read an anthology of his life--was quite interesting.
21:54:41 * soysauce was impressed with his competance and capability as an emperor
21:55:15 <Speck> studying the legal system really compliments the history
21:55:25 <soysauce> I'd imagine
21:55:42 <soysauce> the most interesting part of their history is the last 2 centuries, though
21:55:42 <Speck> anyway, I should get back to work
21:55:47 <soysauce> *nods* good call ;)
21:55:49 <soysauce> good luck
21:56:00 <Speck> definitely -- especially because it all occured in the last 2 centuries
21:56:32 <soysauce> I was thinking more in terms of people like Empress Wu in the late 19th century and the radical reformers and counterreformers of the 20th century
21:56:36 <soysauce> and people like Mao
21:57:52 <soysauce> ixmap looks like it might be the *exact* thing that I need.
21:58:43 <jethr0> soysauce, you need to jumble your array around?
21:59:00 <soysauce> maybe
21:59:10 <soysauce> in the C version of the code I "sorted" it
21:59:43 <soysauce> I grouped columns and rows together so that it was substantially easier to iterate over the interesting parts
21:59:51 <jethr0> ah
22:00:03 <soysauce> I'm thinking that in the Haskell version it's worthwhile to simply create multiple smaller arrays
22:00:20 <soysauce> ixmap won't work, but I can do something similar to ixmap using listArray to create a mutable array
22:01:04 <soysauce> basically I have an undirected graph represented by an edge matrix. I want to sub-divide it into smaller connected graphs.
22:01:12 <soysauce> s/edge matrix/matrix of edges/
22:01:31 <jethr0> like an adjacency matrix
22:01:32 <jethr0> ?
22:01:36 <soysauce> yeah, essentially
22:01:55 <soysauce> once I have the connected graphs, I run Floyd-Warshall's algorithm to determine the distances between the nodes
22:02:19 <jethr0> sounds like a lot of testing ahead of you... unless you get it right, right away
22:02:36 <soysauce> I collect the resulting values and use them in a weird binary search that iterates the Fork-Fulkerson algorithm for maximum flow in a network
22:02:44 <soysauce> I guess
22:02:48 <soysauce> it's not *that* difficult
22:03:14 <soysauce> testing is the difficult part. When I was using vanilla arrays with copying, it was slow, but it was easy to construct an array quickly and test the components
22:03:18 <jethr0> few things are ever really difficult... for me it's most often my own stupidity that get's me :(
22:03:22 <soysauce> since they're all in the ST monad now, it's substantially more difficult
22:03:34 <soysauce> hehe, I wouldn't say few things are ever difficult
22:03:46 <soysauce> try finding a polynomial-time algorithm for an NP complete problem, for example ;)
22:04:24 <jethr0> no, i was speaking of programming tasks... humans make so many errors that *really* complex tasks are rarely started.
22:04:32 <soysauce> true
22:04:51 <jethr0> i've spent most of my programming with fairly straight-forward (relatively) tasks and still banged my head against the wall
22:04:52 <soysauce> well, it's not surprising that humans make so many errors
22:05:11 <soysauce> it's really simple to design a system top-down. It's really difficult to design a system bottom-up, and that's essentially what is required.
22:05:21 <soysauce> the larger system is so big and complex that no single person can fully understand it
22:05:29 <soysauce> and therefore it's impossible to understand interactions
22:06:13 <soysauce> my primary interests are program optimization and program verification. Unfortunately the first is NP-class, and the second is not computable. ;)
22:06:22 <jethr0> *gg*
22:06:25 <soysauce> in the general sense anyway
22:06:43 <soysauce> but I think that's why they're interesting. They're heuristical, so you keep searching for better heuristics.
22:07:00 <jethr0> well, it would be a start to verify those programs whose proof terminates in a realistic timeframe
22:07:09 <soysauce> true
22:07:47 <soysauce> I need to do a lot of reading. That's a bit difficult right now since I'm still working on my undergrad and trying to work full-time.
22:07:50 <jethr0> with current languages and their semantic restrictiveness it might turn out that most are computably proovable
22:07:52 <soysauce> ...and still be somewhat social
22:08:05 <jethr0> *bah*, social is so 90s
22:08:06 <flux__> soysauce, btw, have you tried acl2?
22:08:08 <soysauce> haha
22:08:11 <jethr0> haskell is the new social :)
22:08:12 <soysauce> flux__ - what is that?
22:08:26 <flux__> soysauce, it's a proof assistant with lisp syntax
22:08:52 <soysauce> flux__ - no...like I said, I need to do a lot of reading :)
22:08:58 <soysauce> I just find it an interesting topic
22:09:21 <flux__> google for acl2 flying demo, it was impressive to me ;)
22:10:20 <Korollary> there's also coq for the ml-oriented.
22:10:25 <soysauce> jethr0 - I was rather impressed with the success of Java and similar languages in proving *some* correctness, i.e. so long as the VM/compiler are correct, a program can never violate the type system, and thus memory accesses are always to valid memory *or* to null
22:10:47 <soysauce> I know that they aren't the first to have done that, but when I learned that I was still relatively ignorant of the long history of computing
22:11:00 * soysauce guesses that LISP was actually the first language with garbage collection
22:11:34 <flux__> soysauce, the demo provides code for insertion sort and with quite an easy proves that it works
22:11:36 <jethr0> yah, that is impressive, but seemingly reason enough for the .NET guys to include an unsafe mode :(
22:11:46 * soysauce shrugs
22:11:52 <soysauce> Haskell technically does that too, doesn't it?
22:11:53 <jethr0> backward compatibility to C will haunt us in decades to come
22:12:00 <soysauce> yeah
22:12:08 <jethr0> yes
22:12:16 <soysauce> well it's on their shoulders now to create a language that is fast like C but still safe
22:12:25 <soysauce> Java guys weren't trying to do that.
22:12:31 <soysauce> and the .NET guys aren't competant enough to do that.
22:12:45 <jethr0> i don't think so... there are some pretty smart guys working on .NET
22:13:04 <Korollary> I think the .net people are competant enough for what they're trying to do.
22:13:22 <jethr0> it's just that the demands don't coincide with what they might think would be best
22:13:25 <soysauce> Korollary - okay, I guess that's true. I keep forgetting that .NET is more of a business evangelism thing.
22:14:07 <jethr0> there's some _really_ good people at microsoft... their products just never seem to match the market or the companies aims
22:14:15 <soysauce> I've been told that most of the problems in Longhorn come from problems they've had with .NET
22:14:30 <soysauce> jethr0 - MS is about like any other company; there are bright people, but there's a lot of deadweight too
22:14:54 <Korollary> they have less deadweight than most
22:15:15 <soysauce> maybe. I don't have enough experience with "most" to really say. But there was a lot of deadweight.
22:15:17 <jethr0> yah, but their development guys are some of the best in CS _and_ they've got a budget of 6b$, but still it results in very little :(
22:15:40 <soysauce> I'm sure that corporate politics plays a lot into their problems, too.
22:15:47 <Korollary> jethr0: very little? Do you know how many distinct products MS has? It's nuts.
22:15:49 <soysauce> I'm still infuriated by a comment that one of the guys on the VS team made.
22:16:05 <rep> it's too bad you're married
22:16:09 <rep> ..to me!
22:16:12 <jethr0> korollary, i mean looking at their products up till now (especially OS-wise)
22:16:12 <soysauce> it boiled down to this: "We're not going to give customers a fix for this bug unless they explicitly request it, because it will cost too much."
22:16:29 <soysauce> Korollary - do you know how many of their products actually make money?
22:16:38 <jethr0> hearing about their debugging nightmare which go on for years and years makes my skin crawl
22:16:42 <jethr0> nighmares*
22:16:46 <rep> google is better :)
22:16:48 <soysauce> jethr0 - debugging nightmares?
22:17:12 <jethr0> yes, they've had problems with excel for years and dozens of people were trying to find/fix the problem
22:17:16 <soysauce> ah
22:17:30 <soysauce> I'm not surprised.
22:17:55 <jethr0> and when it was finally fixed, the patch never made it into the internationalized versions and soon after it was unpatched everywhere again
22:18:14 <soysauce> I interned there over a summer... I managed to find and fix a benign bug in the symbol handler + another bug that affected the watch window -- and still affects VS ;) 
22:18:22 <soysauce> I don't know if they fixed it in VS 8, but I reported it to them
22:18:28 <jethr0> at the time they had (for some reason) no core dumping facility, which kinda made it harder to analyze a heisenbug
22:18:41 <soysauce> haha
22:18:48 <soysauce> how long ago?
22:19:00 <soysauce> they're had minidump capability for some number of years now
22:19:11 <jethr0> the bug i'm talking about is about undo overflow. it would autosave every ten minutes and after running for 5 hours or so stack overflow occurred or sth
22:19:23 <soysauce> amusing!
22:19:43 <jethr0> don't know, 5 years ago or so... but still, i'm just amazed how bad some of their practices are!
22:19:48 <soysauce> how would that go uncaught, though?
22:20:03 <soysauce> well, that's MS Office. Are you surprised? ;)
22:20:14 <soysauce> most of that code is probably 15 years old
22:20:15 <jethr0> it wouldn't. users would just say it crashed and nobody had an idea it was correlated with runtime *go figure*
22:20:48 <jethr0> yes, much/most of the office code stems from this suite MS bought before Office 1, or sth
22:20:58 <soysauce> the first bug that I fixed was really, really retarded
22:21:12 <flux__> <monty python>Nobody expects for the runtime length bug!</monty python>
22:21:14 <rep> aren't most bugs retarded? :)
22:21:19 <soysauce> they converted the symbol library from using pascal-style strings to C strings or something like that
22:21:27 <flux__> you can't find them unless you think of them ;)
22:21:40 <soysauce> and the guy who did the conversion forgot to initialize a field denoting the length of a buffer
22:21:55 <flux__> infact quite some time ago I witnessed a bug that appeared if the system was inactive for 40 days or so..
22:22:20 <jethr0> _that's_ hard to reproduce :)
22:22:27 <jethr0> unless you have core dumps
22:22:28 <soysauce> haha
22:22:34 <flux__> but with that system it wasn't completely unrealistic
22:22:44 <soysauce> jethr0 - they do some pretty amazing things now
22:22:45 <flux__> and it didn't crash
22:22:48 <flux__> it just didn't work
22:23:04 <soysauce> I was privy to some statistics about the Watson dumps that people report after their machines BSOD
22:23:08 <soysauce> it was pretty scary.
22:23:26 <soysauce> some of the offenders I expected were there--and others that I hadn't realized were so horrible
22:24:25 <soysauce> they were talking about using managed drivers in the kernel
22:24:42 <soysauce> at least in Longhorn they finally allow userspace drivers, or at least userspace USB drivers
22:25:16 <soysauce> minimum system requirements: Athlon64 X2 4000+, 4GB ram, 1TB hard disk space to cache all the assemblies.
22:25:26 <rep> haha
22:25:49 <jethr0> they were talking about lots of things and most of them got delayed
22:26:04 <soysauce> oh, translate Athlon64 X2 into the equivalent Intel product, if there is one, since MS would never officially cheat on Intel
22:26:16 <soysauce> jethr0 - if by 'delayed' you mean 'dropped' then yes ;)
22:26:38 <jethr0> well, they said _delayed_. so i'd hoped for those features in the next release in 2020
22:26:54 <soysauce> jethr0 - I knew a guy in MSR at the same time I interned there, and he said that one of the higher-ups was very extremely unimpressed with Longhorn; they were scrambling to fix efficiency problems
22:27:03 <soysauce> 2020 might be appropriate
22:27:32 <soysauce> I think the fact of the matter is that they can't solve the problems, so they're just going to have to wait for hardware to advance enough that they can afford to be more inefficient.
22:27:33 <jethr0> they'll call it hindsight... "Hindsight _in_ 2020"
22:27:35 <rep> soysauce when did you intern there?
22:27:39 <soysauce> rep - summer '03
22:27:46 <rep> soysauce what'd you work on?
22:27:51 <soysauce> rep - WinCE
22:28:00 <rep> hm
22:28:14 <soysauce> jethr0 - that way their marketting dept. has time to create tons of benchmarks that "prove" that buying their product is cheaper in the long term than installing Linux
22:28:19 <jethr0> humbug, hardware is fast enough... it's backward compatibility with thousands of drivers/applications that bites them in the *ss
22:28:23 <soysauce> rep - why do you ask?
22:28:26 <twb> FPA "I am porting rep to WINCE"
22:28:29 <rep> soysauce just curious
22:28:35 <soysauce> ah
22:28:37 <rep> soysauce what do you now?
22:28:52 <soysauce> I work for a startup that was spun out of my university
22:28:59 <twb> (rep is a very nasty scheme interpreter)
22:29:03 <soysauce> http://www.securityinnovation.com/ I think
22:29:20 <rep> soysauce why didn't you go back to MS? they never made you an offer?
22:29:31 <soysauce> jethr0 - backward compatibility hurts, but I don't think it's that much of a limiting factor
22:29:37 <rep> (i'm not sure how internships work)
22:29:48 <rep> (do they give you an offer if they like you?)
22:29:58 <soysauce> rep - I was offered an internship here in summer of '04 so I chose not to even interview with MS. They asked me to interview for FTE and I declined that, too.
22:30:03 <soysauce> yeah, they do
22:30:11 <rep> FTE?
22:30:21 <soysauce> for graduating interns it's actually mandatory that they make you an offer unless they were dissatisfied with your performance
22:30:26 <soysauce> FTE = Full-time Employee
22:30:26 <jethr0> soysauce, doing a fast and clean OS is very doable. take a fast microkernel and implement all the daemons. there might be hard problems to solve, but you can't tell me it is inherently impossible
22:30:41 <jethr0> vms had some pretty decent systems for a while now
22:30:42 <soysauce> jethr0 - agreed
22:30:44 <twb> Isn't internship like work experience?
22:30:58 <twb> i.e. jobs like fetching coffee for real workers?
22:30:59 <rep> soysauce wait, why do you have to interview if they give you an offer?
22:31:01 <soysauce> but why would MS implement a fast & clean OS? They already did that. NT is big and bulky now, but they're not going to reinvent the wheel.
22:31:19 <soysauce> rep - oh, well I guess you don't interview if you want to work for the same group
22:31:42 <soysauce> I liked my group, but I wanted to interview for the VC++ team. I was going to work there, and I almost regret having turned down their offer
22:31:45 <jethr0> hmm, my point is that secure is not their priority... backward comp. is at any price!
22:31:54 <rep> soysauce was it a good offer?
22:32:18 <soysauce> jethr0 - internally there is a *lot* of pressure to engineer software quickly and cheaply. Backward compatibility is a very, very important thing, and my point is that for that reason they will *never* rewrite a piece of software.
22:32:22 <twb> I hear that MS research in Cambridge is OK, though.  Not at all like the main company.
22:32:25 <soysauce> not if it works, even if nobody understands how it works
22:32:43 <soysauce> rep - you don't receive an offer without interviewing, so I was never made an offer
22:32:48 <rep> soysauce oh.
22:32:52 <soysauce> when I interned in 2003 I wasn't going to graduate that year. I was a sophomore
22:32:57 <rep> i see
22:32:57 <soysauce> or rather had just finished my sophomore year
22:33:04 <soysauce> and I chose to interview with another group
22:33:27 <rep> so each group interviews independently
22:33:29 <soysauce> MSR is pretty big, I don't think it can be characterized like the rest of the co.
22:33:37 <soysauce> they play with OCAML and do other neat things in MSR
22:33:48 <soysauce> rep - yeah
22:34:01 <gzl> MSR generally only hires grad student interns, though
22:34:05 <soysauce> each group has N openings, if fewer than N are filled then they can accept interns
22:34:06 <gzl> and it's very different from MS :)
22:34:31 <soysauce> interns or full-time. Interns usually roll over into full-time, though.
22:34:33 <rep> soysauce how do you get an internship at MS? :)
22:34:38 <soysauce> apply for it
22:34:47 <rep> i tried :(
22:34:53 <twb> I still wouldn't like being a "Microsoft employee", even for MSR.
22:35:01 <rep> twb why not?
22:35:05 <twb> It'd be like having "traitor" tattooed to your forehead.
22:35:07 <soysauce> they did on-campus recruiting at my uni, so I just went out for that. The first year I was a freshman and they didn't really consider me. They offered me a position as an STE, but I turned it down.
22:35:12 <twb> MS is a stigma
22:35:18 <soysauce> twb - it's not that bad
22:35:22 <rep> soysauce that's when i tried
22:35:24 <soysauce> it's political just like IBM and Sun
22:35:29 <rep> i never even got interviewed or whatever
22:35:53 <rep> :(
22:35:55 <soysauce> working as a developer near the bottom rung isn't so bad except that the machine works against you to prevent you from writing quality software
22:36:04 <rep> why?
22:36:06 <soysauce> rep - which year were you when this happened?
22:36:09 <twb> to put things in perspective, atm I build Linux distros.
22:36:15 <rep> soysauce sophomore, iirc
22:36:17 <soysauce> rep - why fix bugs when you can be adding features? Features sell the product.
22:36:43 <rep> anyway, i now have a great job
22:36:45 <rep> so i'm happy :P
22:36:51 <soysauce> twb - well aside from the political edge of Microsoft, I don't see how it's any different.
22:37:00 <soysauce> rep - *nods*
22:37:24 <soysauce> heh I went to the VS2005 launch a week ago and it really epitomizes the attitude of the company
22:37:27 <twb> soysauce: do you have to work regular hours?
22:37:34 <soysauce> I now have a copy of VS2005 which is totally useless to me.
22:37:38 <soysauce> twb - no
22:37:42 <twb> soysauce: be physically present at the office?
22:37:51 <soysauce> at MS I came in around noon usually, and occasionally as late as 3 PM.
22:37:59 <soysauce> no
22:38:07 <twb> That's good.
22:38:12 <soysauce> I think working from home is discouraged (?), but it was certainly possible
22:38:25 <rep> noon?!?!?!
22:38:31 <rep> 3pm?
22:38:33 <rep> that's crazy
22:38:40 <rep> why'd you work at those hours?
22:38:50 <soysauce> rep - yeah. They didn't care when I came in. I tried to be in by 10:30 or 11 AM so that I could eat lunch with my group.
22:38:51 <jethr0> to stay up _this_ late :)
22:38:56 <Cale> you get to sleep in :)
22:38:58 <twb> Actually my point was more that the community in general has singled out Microsoft as "the evil empire", so anyone openly working for them is evil by association.
22:39:00 <rep> soysauce is lunch free?
22:39:06 <soysauce> no, but it's not expensive either
22:39:08 <Cale> I woke up at 5pm today :)
22:39:18 <jethr0> TINSTAAFL
22:39:19 <twb> I'm not saying that they are *the* evil empire, but that's the community's view.
22:39:24 <rep> i arrived at work at 10:30am today
22:39:25 <Cale> Maybe I'll have a nap at some point
22:39:29 <twb> jethr0: ain't, not isn't.
22:39:33 <soysauce> they have cafeterias in most clusters of buildings, but my group occasionally walked downtown and had lunch at a place that served Indian food
22:39:36 <jethr0> sry
22:39:37 <gzl> it would be funny for the Haskell community to have that view, considering the people who are developing Haskell
22:39:56 <twb> gzl: yeah.
22:39:56 <rep> soysauce were there a lot of indians in yoru group?
22:40:07 <soysauce> rep - if you want to be shocked, on many, many occasions at my present place of employment I have come in after hours and worked through the night and left as people were arriving
22:40:13 <soysauce> at any time of day or night
22:40:19 <rep> wtf
22:40:23 <soysauce> for extended periods of time I was arriving around 10 PM to midnight
22:40:24 <rep> why do you do that?
22:40:39 <soysauce> well, at the time I was extremely depressed and avoiding people ;)
22:40:41 <twb> I usually work from 2am til 7pm, but I only work three days a week.
22:40:51 <jethr0> soysauce i did the same thing. but in hindsight my productivity might have been better at more usual hours :(
22:40:53 <soysauce> but nobody bothered me about it. I just made sure to send an e-mail with my status.
22:41:11 <twb> Yeah, I hate people, too./
22:41:12 <jethr0> working 2pm to 7am is quiet, but not necessarily better!
22:41:19 <rep> i'm at work from 10am to about 7pm
22:41:25 <soysauce> jethr0 - mine wasn't. I was doing things that were way over the heads of all my coworkers. Well, not that they couldn't understand it, but I knew the most about the subject at hand, so they only slowed me down
22:41:52 <soysauce> rep - no, there was only 1 Indian in my group at MS
22:41:53 <jethr0> soysauce, i got things done too!
22:41:53 <gzl> what subject at hand?
22:41:59 <rep> soysauce oh ok
22:42:09 <soysauce> in retrospect it's ironic that there was an Indian and a Pakistani... ;)
22:42:11 <gzl> soysauce: what subject did you know more about?
22:42:14 <soysauce> gzl - driver development
22:42:49 <soysauce> Win9x drivers. Nobody else knew how to write them. I was tasked with doing it. If I hung around during the day, people wanted to know my progress, and that involved explaining what I knew about the driver model.
22:43:02 <soysauce> when I started the project, I knew nothing about Win9x drivers
22:43:19 <rep> drivers suck :)
22:43:23 <gzl> ok
22:43:24 <soysauce> so I read a lot of books and did a lot of reverse engineering
22:43:33 <twb> Heh.
22:43:40 <rep> how long did you intern there?
22:43:41 <twb> reverse engineering is illegal, isn't it? ;-)
22:43:45 <soysauce> nope
22:44:02 <soysauce> rep - just 3 months
22:44:09 <rep> do they pay well? :)
22:44:18 <soysauce> you know, *fortunately* a lot of drivers are written in C/C++ using toolkits, and they are compiled without optimizations
22:44:29 <gzl> rep: they pay pretty well
22:44:32 <soysauce> I can read unoptimized C/C++ code almost as well as I can read C/C++ itself
22:44:38 <twb> soysauce: or stripped, presumably.
22:45:04 <soysauce> rep - um, I think $60K is the going rate? But I don't know...it's not that great compared to the rest of the industry, but if you get into the right group then the work is fun, and that's what makes work bearable.
22:45:21 <rep> hm
22:45:22 <gzl> it's about 75 starting
22:45:32 <rep> for someone just out of college?
22:45:34 <soysauce> twb - DOS/Windows binaries are always stripped, I think
22:45:35 <gzl> yes.
22:45:40 <soysauce> or at least Windows binaries are
22:45:45 <twb> Zow.
22:45:46 <rep> with a bachelor?
22:45:48 <gzl> yes
22:45:48 <jethr0> soysauce, i'm in the process of looking for work (if possible in functional programming) after graduation... any ideas where to look/try?
22:45:50 <twb> That must make debugging a PITA.
22:45:51 <soysauce> they *can* contain symbols, but the MS tools always generate them in a separate file
22:45:56 <soysauce> no
22:46:00 <twb> Oh, I see.
22:46:05 <rep> jethr0 google :)
22:46:17 <twb> Not that I have any experience debugging without a REPL :-)
22:46:19 <rep> (although it won't be in functional programming)
22:46:23 <soysauce> the executable contains the name of the file with symbol information, so if you don't hand out that file then it's effectively stripped
22:46:25 <jethr0> rep, what for? there ain't that many haskell companies out there :(
22:46:28 <soysauce> REPL?
22:46:33 * rep l
22:46:38 <twb> REPL = toplevel
22:46:43 <jethr0> read eval print loop
22:46:44 <rep> jethr0 they are a nice company :P
22:46:48 <twb> Yeah.
22:46:48 <soysauce> jethr0 - nfi, I've never heard of a functional programming job offered
22:46:52 <twb> (loop (print (eval (read))))
22:46:54 <soysauce> but it seems like MSR would be a good place to look
22:47:01 <soysauce> twb - ah
22:47:25 <soysauce> rep - yeah, $60K or *thereabouts* for a BS CS
22:47:29 <twb> I think FP jobs are ones where no-one cares what language you write in.
22:47:42 <soysauce> my roommate was offered more, but he's extremely bright and talented
22:47:50 <jethr0> :), but hard to find... needle in the java/c# stack
22:47:55 <soysauce> hehe yeah
22:47:56 <twb> #darcs all quiet...
22:48:04 <twb> jethr0: yeah.
22:48:14 <jethr0> maybe i'll try looking for an erlang job...
22:48:15 <twb> jethr0: but do you *want* to work in java/C#?
22:48:37 <soysauce> Java/C# work wouldn't be so bad, just tedious and boring
22:48:41 <rep> soysauce what does he do?
22:48:49 <soysauce> rep - well he works at the same place that I do now
22:48:50 <jethr0> twb, my main point is coworkers. working with cool guys in small teams it doesn't really matter that much what environment you do it in...
22:48:52 <twb> I see a lot of PHP+SQL around here >spit< if you call them programming languages.
22:48:55 <soysauce> we worked together on a debugger for about a year
22:48:56 <rep> soysauce oh ok
22:49:12 <soysauce> rumor is that we're getting a contract to port it to Linux. I am looking forward to that.
22:49:22 <rep> userland debugger?
22:49:25 <soysauce> yep
22:49:28 <twb> Debugging what?
22:49:32 <soysauce> anything
22:49:37 <twb> ELF?
22:49:41 <rep> why not just use gdb? :)
22:49:42 <jethr0> php is pretty weird. i tried references to references once and the whole thing just broke right under my nose
22:49:48 <soysauce> haha, gdb blows
22:50:07 <jethr0> gdb might not be so bad, but frontends are sorely lacking
22:50:09 <Gs30ng> Hi. I've just found that haskell does not allow * on char nor string. How can i make n a's, like 'a'*n in python?
22:50:10 <twb> gdb + gub?
22:50:22 <rep> gub?
22:50:24 <soysauce> using gdb makes me cry. It's *horrendously* verbose. MS's debugger, ntsd, is a huge improvement over it. Ours doesn't really fit into the same category, though.
22:50:27 <jethr0> > replicate 5 'a'
22:50:27 <twb> grand unified debugger
22:50:28 <lambdabot> "aaaaa"
22:50:34 <Gs30ng> aha. thanks
22:50:59 <rep> i've never used MS's debugger
22:51:01 <jethr0> debugging inside VS is actually quite nice...
22:51:07 <twb> Bah.
22:51:08 <soysauce> I can script a debugging session in Python
22:51:18 <soysauce> jethr0 - it is, although there are interfaces on top of gdb that do the same thing
22:51:19 <twb> If it doesn't run inside Emacs, I don't wanna know.
22:51:24 <soysauce> haha
22:51:25 <rep> heh
22:51:29 <jethr0> soysauce, like which?
22:51:46 <twb> Unless it can implement everything Emacs has, and better than Emacs does.
22:51:46 <soysauce> jethr0 - I don't know. I don't code on *nix very often, and never anything big.
22:52:03 * jethr0 is intimidated by emacs's configurations structure!
22:52:10 <twb> jethr0: you are?
22:52:12 <soysauce> jethr0 - but I had friends who did, and there was some source-level tool, I believe integrated into KDevelop
22:52:21 <twb> jethr0: The GUI configurator, or the elisp?
22:52:21 <jethr0> soysauce, believe me, there's nothing comparable to the VS debugger under linux!
22:52:28 <soysauce> twb - and slower than Emacs does it? ;)
22:52:43 <soysauce> jethr0 - ah, well, guess that sucks
22:52:46 <twb> soysauce: If I wanted a crap clone of Emacs, I could install eclipse :-)
22:52:54 <jethr0> not the elisp, of course... figuring out where emacs stores its default values, ...
22:53:19 <rep> real men use nvi
22:53:23 <jethr0> tried to configure gnus using the gui thingey, which didn't work and couldn't find out for the life of me where it stored those friggin' configuration values
22:53:24 <soysauce> twb - interesting. What don't you like about Eclipse?
22:53:34 <rep> and real men don't need debuggers :)
22:53:36 <soysauce> I haven't used Eclipse much, but watching classmates use it, it looks pretty nice.
22:53:38 <twb> soysauce: I have an irrelevant phobia of OOP.
22:53:43 <soysauce> ah, gotcha
22:53:44 <twb> And mice.
22:53:47 <soysauce> well I don't blame you
22:53:59 <twb> And it doesn't run over ssh without X11.
22:54:11 * jethr0 is still scarred from using java based guis some years ago *brr*
22:54:12 <twb> (ssh -X sucks ass over public internet)
22:54:16 <soysauce> I get seriously pissed off at the incessant chanting of OOP mantras. Not *everything* fits into an object-oriented paradigm.
22:54:19 <twb> jethr0: that, too.
22:54:34 * jethr0 is disallusioned with OOP
22:54:45 <soysauce> and most Java apps that I have seen were written by exactly the sort of people that Java is targetted at. ;)
22:54:47 <twb> jethr0: Gnus is probably the nastiest part of Emacs.
22:54:58 <jethr0> they say "oh, it fits so well how we think", but i've _never_ modeled anything absolutely cleanly in OOP!
22:55:01 <twb> jethr0: "disillusioned"
22:55:11 <jethr0> what i meant!
22:55:18 <twb> jethr0: well, OOP *is* based on assignment.
22:55:24 <rep> i personally think programming sucks
22:55:33 <soysauce> jethr0 - yeah. Personally I would like to see something like D (which itself is something like C++) but with a lot of borrowing from Haskell.
22:55:40 <rep> especially programming applications
22:55:48 <dons> luckily we have programs to generate code for you,then rep (ie?)
22:55:51 <soysauce> rep - that's why I work in systems programming :p
22:55:52 <jethr0> try modeling chess in PURE OOP and you'll find out that it just doesn't work. you'll have to cut corners!
22:56:00 <jethr0> and that i can do with other paradigms just as well
22:56:01 <rep> soysauce me too, me too :P
22:56:07 <soysauce> rep - what do you do?
22:56:11 <dons> @djinn make -> some -> code -> Bool
22:56:12 <lambdabot> f _ _ _ = True
22:56:13 <rep> soysauce kernel stuff
22:56:20 * soysauce codes debuggers and drivers and reverse engineers stuff
22:56:25 <soysauce> ah, very cool, like what?
22:56:36 <rep> like fixing bugs that pop up :)
22:56:41 <soysauce> which kernel?
22:56:46 <jethr0> humans simply don't think in terms of entities sending each other messages!
22:56:49 <rep> well, my job is with linux
22:56:57 <rep> but i'm actually a freebsd developer
22:57:00 <dons> jethr0, maybe postmen think that way.
22:57:03 <soysauce> oh, pretty cool!
22:57:12 <twb> jethr0: luckily, Java programmers aren't human.
22:57:13 <jethr0> maybe
22:57:43 <jethr0> most OOP programs are not about messaging anyways... mostly it's about storing state all over the place *brr*
22:57:50 <soysauce> I had a friend who went back to India and works(-ed?) on the Linux kernel
22:58:04 <twb> Like I said, OOP is based on set!.  Sussman demonstrates this in SICP.
22:58:11 <rep> soysauce cool
22:58:14 <soysauce> he used to agitate all the Linux people by starting flamewars on the university list server about whether Windows was better than UNIX
22:58:24 <rep> haha
22:58:35 <soysauce> it was quite amusing
22:58:38 <twb> UNIX sucks, but windows sucks more.
22:58:48 <soysauce> nah, they're about the same
22:58:57 <jethr0> twb, i don't have a problem with that at an implementation level. but so called OOP programs are all about passing the entities nowadays instead of having them communicate with each other!
22:59:04 <twb> Emacs is a better platform than UNIX or Windows.
22:59:08 <soysauce> although judged purely on the programming model, I think Windows bests UNIX a bit
22:59:10 <soysauce> haha
22:59:17 <twb> I'm dead serious.
22:59:17 <rep> haha
22:59:19 <jethr0> COM
22:59:25 <twb> Emacs has better integration than UNIX or Windows.
22:59:38 <jethr0> emacs' configuration is intransparent
22:59:45 <jethr0> it's like the registry
23:00:12 <twb> You can add contacts to bbdb from w3m, for example.
23:00:35 <twb> It's harder to do that with curses applications and screen's copy, or whatever.
23:00:46 <rep> copy and paste?
23:01:08 <Saulzar> Emacs doesn't support backspace
23:01:17 <twb> Saulzar: haha, you must have a Mac.
23:01:27 <jethr0> i like emacs as an editor and as a platform for little stuff. but implementing the browser, the mail reader and the kitchen sink in it is not my cup of tea!
23:01:44 <twb> jethr0: it's better than implementing it in GTK...
23:01:45 <jethr0> emacs support for cvs is great for example!
23:02:30 <twb> Emacs doesn't support darcs as well, though.  I blame ESR for hard-coding CVS paradigms into vc-mode.
23:02:40 <rep> hah esr
23:02:43 <jethr0> but stuff like M-x morse-region is just silly!
23:02:47 <Saulzar> Actually I think that was on solaris back in my first year
23:02:50 <Saulzar> That was enough to drive me away forever, the indenter is great though :)
23:02:50 <rep> i personally think esr is an idiot
23:02:51 <jethr0> and it blows emacs up unnecessarily!
23:03:01 <twb> rep: esr *is* an idiot.
23:03:15 <rep> i guess i'm not the only one :)
23:03:16 <soysauce> who is ESR...?
23:03:21 <twb> catb.org
23:03:22 <rep> who thikns so
23:03:22 <jethr0> emacs' indenter ROCKS, but so do the vim's syntax highlighting files!
23:04:00 <Saulzar> I liked MS edit more than either of them :)
23:04:19 <rep> i personally recommend nvi
23:04:21 <jethr0> ms edit. white on blue, was it?
23:04:29 <twb> rep: what's wrong with mg?
23:04:33 * jethr0 uses "ed" exclusively
23:04:37 <jethr0> it's somehow functional :)
23:04:41 <rep> mg?
23:04:44 <twb> rep: it has a dired-mode?
23:04:48 <twb> rep: it has a dired-mode!, rather
23:04:48 <soysauce> Saulzar - MS edit replaces tabs with spaces, it's very annoying.
23:04:50 * tennin uses Emacs in VI emulation mode
23:04:58 <jethr0> that's just sick!
23:04:58 <rep> twb i don't need dired-mode :)
23:05:00 <twb> mg is a version of Emacs smaller than nvi.
23:05:11 <rep> nvi is great.
23:05:16 <twb> under 150kB, IIRC.
23:05:17 <soysauce> what's nvi?
23:05:24 <jethr0> anyone know how to switch between open buffers in vim?
23:05:25 <twb> soysauce: the BSD version of vi
23:05:28 <soysauce> ah
23:05:36 <jethr0>  :e is just killing me!
23:05:54 <rep> iirc it's something with :b
23:06:02 <rep> or something :)
23:06:07 <Cale> ^W
23:06:07 <jethr0> you don't seem to be using it that much :)
23:06:13 <rep> i don't use vim, no
23:06:20 <triplah> i'd rather use vi in sfu on windows than kde and its associated editors (from a gui point of view)
23:06:20 <jethr0> cale, and then?
23:06:30 <rep> sfu?
23:06:30 <Cale> arrow key
23:06:32 <twb> KDE is evil.
23:06:35 <triplah> services for unix
23:06:36 <soysauce> triplah - how is SFU? I've never used it, but I have it downloaded.
23:06:36 <twb> Ratpoison forever!
23:06:50 <jethr0> kdevelop is even worse than VS when it comes to creating superfluous project files
23:06:52 <soysauce> does it make use of the POSIX emulation in the kernel?
23:07:02 <triplah> soysauce: i actually havent tried it. but i've made my mind up about something that lets me use shell and vi in windows ;)
23:07:08 <triplah> and lets me use nfs
23:07:09 <jethr0> twb, are you seriously using ratpoison?
23:07:12 <soysauce> *nods*
23:07:15 <twb> jethr0: fuck yes.
23:07:20 <soysauce> yeah, I downloaded it for NFS support
23:07:21 <jethr0> *omg*
23:07:32 <twb> ratpoison is the nicest thing to hit X11 in ten years.
23:07:35 <Cale> at least use larswm or something :)
23:07:36 <triplah> id use evilwm over rat poision :P
23:07:44 <triplah> poison*
23:07:54 <moonfish> could somebody answer a quick do notation question for me, regarding the use of nested 'do's and monad combinators?
23:07:54 <twb> Cale: why?  That wastes screen space.
23:08:02 <soysauce> moonfish - ask away
23:08:13 <jethr0> maybe i should try ratpoison. but it looked like a joke when i first saw it...
23:08:23 <Cale> twb: ion?
23:08:26 <twb> jethr0: I added a whole bunch of functionality to it.
23:08:26 <moonfish> Here's the made-up test case:
23:08:27 <jethr0> maybe fluxbox _has_ too big a mem footprint :)
23:08:28 <moonfish> braceTest =
23:08:28 <moonfish>     do{ v1 <- return 1
23:08:28 <moonfish>       ; v2 <- return 2
23:08:28 <moonfish>       ; do print v1
23:08:28 <moonfish>         >>
23:08:29 <moonfish>         do print v2
23:08:31 <moonfish>       }
23:08:33 <moonfish>  
23:08:40 <Saulzar> I use KDE editors, they work and I can use backspace and type input with 1 character per keystroke - what a novelty eh?
23:08:42 <jethr0> aha
23:08:47 <moonfish> how can I write this without the braces?
23:09:01 <triplah> http://www.nongnu.org/ratpoison/shot2.png <-- its good if you dont mind the eyebleed when you see your background :)
23:09:19 <jethr0> moonfish, try deeper indentation
23:09:33 <jethr0> or parens around the >> stuff
23:09:42 <Cale> braceTest = do v1 <- return 1; v2 <- return 2; print v1 >> print v2
23:09:56 <soysauce> why do you need those nested do's?
23:10:00 <jethr0> yah, thought that might work too!
23:10:11 <soysauce> print v1 >> print v2 is the same as print v1; print v2
23:10:14 <moonfish> soysauce: not in this example, but in more complicated cases I do.
23:10:16 <Cale> yeah, it is
23:10:21 <Cale> braceTest = do v1 <- return 1; v2 <- return 2; print v1; print v2
23:10:24 <moonfish> ditto for the use of >>
23:10:40 <triplah> http://www.nongnu.org/ratpoison/keyboards/012-mange/ hahah
23:10:44 <triplah> :)
23:10:50 <soysauce> and the braces would never be required, anyway, since the block is determined by the level of indentation
23:11:33 <rep> do you think google is evil
23:11:44 <rep> how about yahoo?
23:11:47 <soysauce> Cale - do you know anything about ixmap?
23:11:49 <tennin> I use Gnome because other people used to MS-Windows need to use this computer
23:11:55 <soysauce> I'm wondering whether it actually creates a new array
23:12:03 <moonfish> The problem is to get the scoping of the >> right, i.e. it must apply to the just the 'do' before and after.
23:12:16 <Cale> soysauce: yes, it does
23:12:20 <soysauce> ack.
23:12:29 <jethr0> moonfish, tried parens? (print v1 >> print v2)?
23:12:38 <soysauce> is there any way to get an array that refers back to the original and just translates the indices?
23:12:45 <tennin> and last time I tried to install KDE it rendered my whole system unstable, though that probably was more my fault than its
23:13:00 <Cale> soysauce: is this a boxed or unboxed array
23:13:01 <Cale> ?
23:13:05 <jethr0> soysauce, access the array with the index-mutation function
23:13:10 <soysauce> unboxed, but does that really matter? I can change it
23:13:10 <Cale> soysauce: you shouldn't have to worry about that
23:13:11 <jethr0> array ! (func x)
23:13:13 <triplah> http://www.nongnu.org/ratpoison/keyboards/009-edi/
23:13:16 <triplah> wtf :S
23:13:26 <soysauce> jethr0 - ah hm, I see...well, I was hoping to avoid that
23:13:32 <Cale> soysauce: well, with a boxed array, the entries are all just pointers anyway
23:13:39 <soysauce> Cale - right
23:13:58 <soysauce> but I just want to create a new array object that really refers to the old one, because it will be very short-lived
23:14:00 <moonfish> parens do the trick.
23:14:25 <soysauce> I can find another way around it, I suppose
23:14:27 <jethr0> moonfish, "correct" indentation should've also worked
23:14:32 <Cale> hmm... actually
23:15:28 <Cale> soysauce: well, your 'a' is unboxed, so it makes no difference either way
23:15:38 <moonfish> jethr0: how do you 'correctly' indent it?
23:15:52 <Cale> soysauce: as soon as you evaluate one of the cells of the new array, it's going to force the evaluation of all of them
23:16:09 <Cale> (since that's how unboxed arrays work)
23:16:35 <jethr0> hmm, that's difficult. but indenting current block deeper than parent block is always a good start
23:16:36 <soysauce> @type all
23:16:36 <Cale> I wonder why ixmap isn't of type (i,i) -> (i -> j) -> a j e -> a' i e
23:16:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:16:42 <jethr0> i'm having difficulties with that myself still
23:17:20 <soysauce> Cale - yeah, but that shouldn't matter. All I want to do is create a new array where (!) is really (!) . f
23:17:39 <soysauce> @type and
23:17:40 <lambdabot> [Bool] -> Bool
23:17:44 <soysauce> aha!
23:17:54 <jethr0> http://www.nongnu.org/ratpoison/keyboards/013-gabriel/ ; look at how his keys are ordered ?!?!?!
23:18:01 <Cale> soysauce: well, that would basically be the situation if your array was boxed
23:18:47 <soysauce> Cale - yes, but calling another function is cheaper than copying the array ;)
23:19:00 <soysauce> Cale - I worked around it; it's just not as nice
23:19:15 <Saulzar> jethr0, Masochists...
23:19:22 <Cale> Don't optimise prematurely :)
23:19:27 <jethr0> hehe
23:19:29 <soysauce> I know
23:19:47 <Cale> How big are these arrays anyway?
23:19:56 <soysauce> not very big ;)
23:20:00 <soysauce> up to 200 elements
23:20:01 * jethr0 wouldn't even know where to optimize his haskell progs prematurely
23:20:08 <Cale> I wouldn't even worry about it then
23:20:20 <soysauce> *nods*
23:20:20 <Cale> Just use ixmap :)
23:20:47 <soysauce> well, I just passed a list of indices to the function instead of letting that list be the bounds of the array
23:21:06 <Cale> that works
23:21:12 <soysauce> trivial a1 a2 xs = and (map (\x -> (a1!x) <= (a2!x)) xs)
23:21:33 <jethr0> huh?
23:21:39 <jethr0> @hoogle (<=)
23:21:40 <lambdabot> No matches found
23:21:54 <jethr0> ah, looked like an op :)
23:21:55 <soysauce> <= would be less-than-or-equal, eh?
23:21:56 <Cale> hehe
23:22:00 <soysauce> hehe
23:22:00 <Cale> @type (<=)
23:22:01 <lambdabot> forall a. (Ord a) => a -> a -> Bool
23:22:10 * jethr0 hits himself on the head
23:22:24 <jethr0> i'm expecting all kinds of weird sh*t
23:22:28 <moonfish> jethr0: I can get rid of the parens by indenting the >> and second 'do' further than the first, but that is ugly.
23:22:47 <Cale> probably the "and" getting your head into logic-mode
23:22:52 <Cale> hehe
23:22:56 <Cale> and then the extra parens
23:23:23 <jethr0> > let (<=) = (.) in ((+1) <= (*2)) 3
23:23:24 <lambdabot> 7
23:23:49 <Cale> trivial a1 a2 xs = all (\x -> a1!x <= a2!x) xs
23:24:15 <moonfish> jethr0: and if I keep the parens then emacs gets the indentation wrong. So I either have to indent by hand, or keep the braces :(
23:24:22 <jethr0> :(
23:25:02 <Cale> moonfish: if it's any consolation, I found it much easier to just turn off smart indenting in emacs. Simple indent is much nicer
23:25:45 <jethr0> moonfish, you shouldn't need the do's and could simply write it on one line w/o parens.. (?)
23:26:19 <moonfish> jethr0: sure, in this example, but not in the more complicated cases.
23:26:26 <jethr0> like what?
23:26:35 <Cale> I can't think of any case where you should have to nest do-blocks in that way
23:26:37 <jethr0> in more complicated cases i'd welcome any extra parens!
23:27:12 <jethr0> and mixing ">>", ">>=" with do is questionable anyways...
23:27:27 <Cale> it is :)
23:27:33 <moonfish> jethr0: I just picked that as an example.
23:27:38 <moonfish> Here's the real code:
23:27:39 <humasect> is there an alternate c->hs "convertor" from c2hs? without needing .chs files like for c2hs
23:27:40 <moonfish> oeTest'' =
23:27:40 <moonfish>     do t <- newTVar 0
23:27:40 <moonfish>        u <- newTVar 0
23:27:40 <moonfish>        (do v <- readTVar t
23:27:40 <moonfish>            writeTVar u 1
23:27:40 <moonfish>            retry
23:27:42 <moonfish>         `orElse`
23:27:44 <moonfish>         do r <- readTVar u
23:27:46 <moonfish>            return r)
23:27:48 <moonfish>  
23:28:36 <jethr0> hmm, parens don't look so nice here :(
23:29:36 <jethr0> hmm, tricky
23:30:04 <jethr0> that's starting to look like some of the 12-hierarchies deep "frag" code *g*
23:30:23 <moonfish> jethr0: yep. but braces look worse, and indenting the `orElse` and last 'do' is the pinnacle of hideousness. So I think the above is as good as it gets.
23:30:40 <jethr0> yah, i'd agree (for now :)
23:30:43 <Cale> braces are good when you're applying operators to do-blocks
23:30:58 <Cale> that, or breaking out those sections and adding them to a where-clause
23:31:02 <soysauce> BBL, time for a nap, and then a lot of Haskell coding tomorrow (whee!)
23:32:11 <moonfish> Cale: can one have 'where' clauses inside a 'do'?
23:33:18 <Cale> moonfish: one can have where clauses after any function declaration or pattern binding. Inside a do, you can use a 'let'. There's a special extra syntax for let inside do
23:33:51 <moonfish> Cale: thanks. I know about 'let' inside 'do'.
23:34:02 <jethr0> cale, for some weird reason inside a TH splice $() there's only let allowed and not where. maybe because it's syntactic sugar for the monad!?
23:34:03 <araujo> @where hs-plugins
23:34:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
23:34:29 <Cale> jethr0: where is part of declaration syntax
23:34:30 * jethr0 was amazed at how relatively short hs-plugins is
23:34:33 <moonfish> Cale: the problem in this case is that I need t and u to be bound inside the blocks.
23:34:46 <Cale> jethr0: whereas let is part of expression syntax
23:35:02 <jethr0> hmm
23:35:46 <Cale> oeTest'' =
23:35:46 <Cale>     do t <- newTVar 0
23:35:46 <Cale>        u <- newTVar 0
23:35:46 <Cale>        let try1 = do v <- readTVar t
23:35:46 <Cale>                      writeTVar u 1
23:35:46 <Cale>                      retry
23:35:48 <Cale>            try2 = do r <- readTVar u
23:35:50 <Cale>                      return r
23:35:57 <Cale>        try1 `orElse` try2
23:36:14 <moonfish> Cale: that's quite pretty. I like it.
23:36:19 <jethr0> cale, don't you need two let's inside "do"?
23:36:24 <Speck> gnarl, what are the monadplus combinators?
23:36:29 <Cale> jethr0: hm?
23:36:33 <Speck> @type (++)
23:36:34 <lambdabot> forall a. [a] -> [a] -> [a]
23:36:47 <Speck> err, I need sleep X_X
23:36:48 <Cale> Spark: mplus, mzero
23:36:52 <Cale> er
23:36:53 <Cale> Speck: 
23:36:53 <jethr0> i thought (for some obscure reason) that inside "do" no multiple "lets" are allowed?
23:37:00 <Cale> no, that's not true
23:37:07 <Cale> it's just the same as any other let
23:37:10 <jethr0> weird
23:37:14 <Cale> only it doesn't have an 'in'
23:37:16 * jethr0 wonders where he get's his information
23:37:22 * moonfish declares Cale the winner of the "Prettiest 'do' notation" contest
23:38:52 <Speck> hmm, though it is valid, is it Haskell style to use mplus and mzero for STM monads? It seems kind of evil.
23:39:35 <Cale> It seems right
23:40:23 <Cale> I suppose retry and orElse are more descriptive
23:40:37 <Speck> I could understand the argument that it's better style to use retry and orElse for semantic reasons
23:41:31 <Cale> I kind of wonder a bit why they bothered defining separate names for them in the first place though.
23:41:46 <Speck> yeah
23:42:22 <Cale> I think initially it was to avoid extra discussion of MonadPlus in the paper.
23:42:33 <Speck> yeah, and to make it easier to digest for non-Haskellers
23:43:03 <jethr0> my guess is that mzero == retry. but that doesn't seem intuitive!
23:43:11 <Cale> well, that's right
23:43:12 <Speck> it is defined as such in GHC
23:43:30 <Cale> It seems intuitive to me
23:43:42 <Cale> mzero represents failure
23:43:46 <jethr0> well, i got a lot of learning to do when it come to state monads and transformers!
23:43:52 <jethr0> hmm
23:44:02 <Cale> > mzero :: [Int]
23:44:03 <lambdabot> []
23:44:29 <Speck> > mzero :: STM a
23:44:30 <lambdabot>  Not in scope: type constructor or class `STM'
23:45:15 <Taral> > mzero :: Control.Concurrent.STM.STM a
23:45:15 <lambdabot>  Not in scope: type constructor or class `Control.Concurrent.STM.STM'
23:45:23 <Taral> @hoogle STM
23:45:24 <lambdabot> GHC.Conc.STM :: STM a
23:45:24 <lambdabot> Language.Haskell.TH.Lib.StmtQ :: Q Stmt
23:45:24 <lambdabot> Language.Haskell.TH.Syntax.Stmt :: Stmt
23:45:30 <jethr0> it's not a concrete type!?
23:45:30 <Taral> > mzero :: GHC.Conc.STM a
23:45:31 <lambdabot>  Not in scope: type constructor or class `GHC.Conc.STM'
23:45:33 <Cale> > f x = if x > 5 then return x `mplus` return (x+1) else mzero in [1..10] >>= f
23:45:34 <lambdabot>  parse error on input `='
23:45:41 <Cale> > let f x = if x > 5 then return x `mplus` return (x+1) else mzero in [1..10] >>= f
23:45:42 <lambdabot> [6,7,7,8,8,9,9,10,10,11]
23:45:45 <Taral> it is, just lambdabot seems to filter a lot of things
23:45:50 <Taral> @type GHC.Conc.STM
23:45:52 <lambdabot> Not in scope: data constructor `GHC.Conc.STM'
23:46:01 <Taral> @type GHC.Conc.atomically
23:46:02 <lambdabot> forall a. GHC.Conc.STM a -> IO a
23:46:15 <Cale> @type \x -> if x > 5 then return x `mplus` return (x+1) else mzero
23:46:16 <lambdabot> Not in scope: `mplus'
23:46:16 <lambdabot>  
23:46:16 <lambdabot> <interactive>:1:55: Not in scope: `mzero'
23:46:19 <Taral> I don't think STM is an instance of MonadPlus
23:46:28 <Speck> http://darcs.haskell.org/libraries/stm/Control/Concurrent/STM.hs
23:46:29 <Cale> @type \x -> if x > 5 then return x `Control.Monad.mplus` return (x+1) else Control.Monad.mzero
23:46:30 <lambdabot> forall (m :: * -> *) a.
23:46:30 <lambdabot> (Ord a, Num a, Control.Monad.MonadPlus m) =>
23:46:30 <lambdabot> a -> m a
23:46:48 <jethr0> cale, at first i was confused by the code, but _now_ i get it :)
23:47:05 <Taral> Speck: Oh.
23:47:09 <Taral> useful site.
23:47:20 <Taral> Has fptools moved away from cvs finally?
23:47:34 <Speck> yeah, *pats SyntaxNinja*
23:47:38 <Taral> yay
23:47:41 <Speck> well, darcs mirror
23:47:44 <Taral> ew
23:47:48 <Taral> darcs mirror = bad
23:47:54 <Speck> it's more complicated than it seems
23:48:01 <Taral> anyway, I should eventually do that from-scratch reimplementation of darcs
23:48:11 <Speck> other repos are depending on the fptools libs cvs repo
23:48:26 <Speck> but cvs should be the mirror :P
23:48:40 <Taral> ha
23:48:43 <Taral> darcs -> cvs is hard
23:48:55 <Taral> just look at the godawful hackage that is darcs-git
23:49:47 <Speck> well why would anyone ever want to migrate from darcs?!
23:50:01 <jethr0> i guess oneway is doable. but passing back and forth seems like hell!
23:53:12 <moonfish> jethr0: 'tailor' is supposed to be able to do that.
23:54:39 * jethr0 wonders whether the fact that multiple top-level function declarations have to be defined next to each other is a hack...
23:55:01 <jethr0> is tailor a versioning system?
23:55:44 <moonfish> http://www.darcs.net/DarcsWiki/Tailor
23:57:51 <jethr0> $test braceTest =do{ v1 <- return 1; v2 <- return 2; {print v1 >>print v2}}
23:57:52 <jethr0_bot> Unknown command, try @listcommands.
23:58:09 <jethr0> $pretty braceTest =do{ v1 <- return 1; v2 <- return 2; {print v1 >>print v2}}
23:58:10 <jethr0_bot> "Parse error" at column 48
23:58:25 <jethr0> $pretty braceTest =do{ v1 <- return 1; v2 <- return 2; print v1 >>print v2}
23:58:25 <jethr0_bot> #  braceTest = do v1 <- return 1
23:58:25 <jethr0_bot> #                 v2 <- return 2
23:58:25 <jethr0_bot> #                 print v1 >> print v2
23:59:10 <jethr0> $pretty braceTest =do{ v1 <- return 1; v2 <- return 2; do {print v1; print v1} >> do {print v2; printv2}}
23:59:11 <jethr0_bot> #  braceTest = do v1 <- return 1
23:59:11 <jethr0_bot> #                 v2 <- return 2
23:59:11 <jethr0_bot> #                 do print v1
23:59:11 <jethr0_bot> #                    print v1
23:59:11 <jethr0_bot> #                           >>
23:59:13 <jethr0_bot> #                           do print v2
23:59:15 <jethr0_bot> #                              printv2
23:59:19 <Taral> ooh
23:59:32 <Taral> but that extra indenting is not pretty
23:59:37 <jethr0> not really
23:59:44 <jethr0> but hopefully it's legal
23:59:46 <Taral> $pretty do { if x then y else z }
23:59:47 <jethr0_bot> "Parse error" at column 26
23:59:51 <Taral> ?!
23:59:58 <Taral> $pretty a = do { if x then y else z }
23:59:59 <jethr0_bot> #  a = do if x then y else z
