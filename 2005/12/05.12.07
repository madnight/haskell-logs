00:00:17 <palomer> Cale: ahh, you've mad your point
00:00:37 <palomer> but the syntax for SomeClass a b c d e f might get hairy, right?
00:00:54 <Cale> palomer: I suppose it might, but I've never seen anything of the sort come up
00:00:59 <palomer> whereas with functors the syntax is very straight forward
00:01:15 <Cale> where are you going to end up with 6 type parameters?
00:01:22 <Korollary> well, as long as it compiles, I have no problem with ml-style functors for haskell.
00:01:41 <Cale> That's scarier than HList :)
00:01:52 <Cale> btw, have you seen HList?
00:02:03 <Cale> Strongly typed heterogeneous lists in Haskell
00:02:08 <Korollary> He wants to scare you openly...
00:02:13 <palomer> Cale: say a car is described by an engine, window, doors, wiper, and wheel 
00:02:40 <Cale> um, that sounds like a data declaration
00:03:12 <palomer> what's the syntax?
00:03:45 <Korollary> data Car = { engine :: EngineType; etc.. }
00:04:01 <Cale> or possibly like Korollary's but with some type parameters
00:04:04 <palomer> so, given any engine type, window type, door type and wheel type I have a car type
00:04:09 <Cale> yeah
00:04:26 <Cale> Car engine window doors wiper wheel
00:04:27 <kzm> @seen dons
00:04:28 <palomer> but I don't know what these types are
00:04:28 <lambdabot> dons is in #haskell. Last spoke 30 minutes and 25 seconds ago.
00:04:43 <palomer> all I know is that engines make things turn and whiper whipe the windshield and doors open
00:05:02 <palomer> s/whipe/wipe
00:05:15 <Cale> I think it would be a better design decision to group all those Car operations into one class
00:05:25 <Cale> have a class of cars
00:05:29 <Cale> or separate classes
00:05:42 <Cale> class Wipeable w where
00:05:52 <Cale> class Openable d where
00:06:15 <Korollary> palomer: you can have a class for engine types, then say data (WiperLike w, EngineLike e) Car w e = ... 
00:06:23 <palomer> so every time I want to create a new car type I have to declare an instance?
00:07:25 <Korollary> Yes. That's the difference. In C++ templates, the contract is implicit. In Haskell, new wipers must be intance of WiperLike.
00:08:35 <palomer> in sml, this is how I would declare a new car: struct type whiper = whiperType; type window = windowType; ...; end;
00:08:45 <palomer> well, that's a car structure, anyways
00:08:59 <palomer> ok, so we have a car structure and a family structure
00:09:13 <palomer> these two structures combined have all the capabilities for having a road trip
00:09:29 <palomer> furthermore, given the capabilities, one can write the code for the road trip
00:09:32 <palomer> so road trip is a functor
00:10:10 <palomer> with functions like: fun amuseKids () = Car.activateWhipers
00:10:23 <Cale> I find it amazing how many places the word Functor gets misused :)
00:10:30 <palomer> am I being clear?
00:10:32 <Cale> yes
00:10:34 <Korollary> palomer: Yes
00:10:50 <palomer> can this be done in haskell?
00:11:00 <Cale> Does that usage of the word functor have anything whatsoever to do with the category theoretic usage?
00:11:06 <palomer> of course
00:11:14 <palomer> don't ask me what it is though:O!
00:11:32 <Korollary> So how do you know it does :)
00:11:37 <palomer> so yeah, for some things I find functors _very_ convenient
00:11:42 <palomer> for others I wish I had type classes
00:11:50 <palomer> Korollary: I asked around
00:12:07 <palomer> but, basically, you can think of a structure as a category
00:12:13 <Korollary> how does a functor/struct work with type inference? How do you know if a certain function is overloaded for that type?
00:12:38 <palomer> right
00:12:56 <palomer> you have types of structures!
00:12:59 <palomer> (oh boy!)
00:13:06 <palomer> called signatures
00:13:37 <palomer> so you'd see something like Functor (a:carSignature,b:familySignature) = ...
00:13:57 <palomer> signatures are easily parameterized
00:14:03 <palomer> type inference is then quite easy
00:14:10 <Korollary> Ah
00:14:26 <palomer> a car signature would say "cars must have wheels and windows and breaks"
00:14:34 <Cale> How is a structure like a category?
00:14:35 <Korollary> Well, that's the overhead part, like having to define class instances in Haskell.
00:14:39 <palomer> "and a function star which starts the bloody car"
00:14:56 <palomer> Cale: it has a set of types and arrows between them
00:15:01 <kzm> Coming from OO, "functor" was a bit confusing.
00:15:03 <palomer> (being functions)
00:15:18 <Cale> hmm
00:15:21 <palomer> kzm: you mean C++ functors, no?
00:15:24 * kzm came from OO, not "functor"
00:15:28 <Korollary> kzm: Was STL's use of functor CT relatyed?
00:15:38 <Cale> Do you specify all the arrows yourself?
00:15:43 <kzm> Yes.  Just objects redefining operator().
00:15:49 <palomer> Cale: yeah, you have values in your structures too
00:15:53 <kzm> @spell relatyed
00:16:06 <Cale> and does it have to satisfy the category laws?
00:16:22 * kzm wonders what is up with the bot these days.
00:16:29 <Korollary> Cale: do haskell monads *have* to satisfy ct laws ? ;)
00:16:48 <palomer> Cale: as much as values/types do in ml
00:17:05 <Cale> Korollary: well, if they don't lots of things break
00:17:57 <Cale> palomer: so a structure is a restriction category of the category of ML types to a particular set of objects?
00:17:58 <Korollary> Well, I knew that some things were possible with structures because Oleg posted some ocaml code once, and I thought that if it was possible in haskell, he would have written it so.
00:18:06 <palomer> Korollary: defining the class is fine, it's the instances I'm worried about (functors probably have much cleaner syntax, like I showed)
00:18:24 <Cale> There's a paper on translating structures/functors from ML into Haskell
00:18:45 <palomer> Cale: and vice versa?
00:19:34 <Korollary> Cale: How about template haskell for structures/signatures?
00:19:34 <Cale> let me check
00:19:48 <Cale> Korollary: I don't think you need anything like that
00:19:50 <palomer> Cale: structures are functions assigning names to values and types, the image of this function is a restriction, sure
00:20:19 <Cale> ah, okay
00:20:42 <Cale> http://www.stefanheimann.net/diplom/Wehr_ML_modules_and_Haskell_type_classes.pdf
00:21:33 <Cale> they even seem to check that the translation has equivalent semantics
00:21:35 <palomer> anyways, I hope I've convinced you guys on the usefulness of structures/signatures
00:21:43 <palomer> and functors
00:21:57 <Cale> well, yeah, though I'll prefer not to call them that :)
00:21:58 <Cale> hehe
00:22:14 <palomer> this isn't a paper, it's a frigging book!
00:22:20 <stefanw_> Cale: there is no proof for an equivalent dynamic semantcs, only for the static semantics
00:22:41 <Korollary> Wow. TH looks scary.
00:22:46 <Cale> stefanw_: aha :)
00:22:55 <Cale> Korollary: it is
00:23:03 <palomer> dynamic semantics?
00:23:15 <Korollary> Why do I have so much reading to do...
00:23:23 <palomer> hrm
00:23:30 <palomer> I have to read and understand the wobbly types paper!
00:23:39 <palomer> and this, before knowing how to program in haskell
00:23:59 <Korollary> palomer: how long would it take you to learn haskell since you already know ml anyway?
00:24:05 <Cale> Korollary: TH is useful for a few things, but I'm not sure if it's worth all the extra compiler complexity.
00:24:08 <palomer> oh, not long
00:24:20 <Korollary> palomer: Just get it out of the way, then ;)
00:24:22 <palomer> it's the finer points I'm interested in
00:24:28 <palomer> Korollary: I need a project to do that
00:24:28 <Cale> Especially as you can't really extend the language in anything resemling a transparent way.
00:24:36 <palomer> I'm thinking : "implementing tiny-hs"
00:25:23 <palomer> or maybe "implementing a first order theorem prover"
00:25:32 <Korollary> palomer: You know the "lacking libraries" people talk of? there you go.
00:25:46 <palomer> oh, that's too big of a bite for me
00:26:36 <palomer> I need something somewhat academic
00:26:53 <Korollary> for school?
00:27:08 <palomer> no, I mean something which doesn't involve real world ugliness
00:27:52 <Cale> Haskell had lacking libraries when I started to use it 3 years ago. Now it seems to have a decent collection.
00:28:42 <Korollary> Cale: I don't think they are mature, though.
00:29:18 <Korollary> Cale: The user base is very small, so bugs are found very slowly.
00:29:22 <Cale> well, by definition they aren't
00:29:30 <Cale> because they're new :)
00:29:49 <Korollary> well, a perl library would have aged 10 times more in just a year ;)
00:29:56 <Cale> I think there are some very well designed libraries though
00:30:14 <Cale> so it will be bugs and not so much design problems
00:30:24 <palomer> oh, here's a real world example of the usefulness of functors before I leave. You have a structure map which maps keys to values. The keys must have an ordering. the values can be anything. you must be able to create a map, insert into a map, get the largest/smallest key of a map and foldl over a map. I'll omit the signature, and I'll give you an example of a structure which would satisfy the omitted signature
00:31:09 <Cale> palomer: functional dependencies take care of the same problem
00:31:09 <palomer> structure map = type k; type v; val insert = ...; val greatestKey = ...; val smallestKey = ...; end;
00:31:15 <Cale> in almost the same way
00:31:23 <Cale> but different syntax
00:31:46 <palomer> actually, wait, map should be a Functor
00:31:57 <palomer> which takes key, value pair
00:32:02 <palomer> wait, all this can be done with type classes
00:32:07 <Cale> hehe :)
00:32:17 <palomer> bah, I'll find an example, some day
00:32:41 <Korollary> isn't the ml userbase even smaller than haskell's ?
00:32:44 <Cale> are functors/structures Turing complete?
00:32:50 <palomer> oh, yes, I see the difference
00:33:21 <palomer> Cale: I don't think so, since I think that termination always completes in sml (though I could be wrong)
00:33:31 <Saulzar> Well, it could be useful for giving a different ordering over integers - where as in Haskell you'd need to make another type
00:33:41 <Cale> Saulzar: yeah
00:33:57 <Cale> There have been proposals for named type classes
00:33:57 <palomer> the difference is: given a structure, it implicitly satisfies tons of signatures
00:34:11 <palomer> whereas with classes, we need an instance for every class we want to satisfy
00:34:34 <palomer> either one has its uses
00:34:56 <Saulzar> The standard library has _oodles_ of instances for all the basic types
00:35:10 <palomer> right, but sml would generate these instances for you
00:35:15 <Cale> um, is the structure the explicit mapping of specific types and values to specific elements of the signature?
00:35:52 <Cale> I somehow thought it was something more generic
00:35:52 <palomer> Cale: a signature specifies which types the names can be mapped to, and the types of the values
00:35:57 <Cale> ah, okay
00:35:59 <Cale> yeah
00:36:09 <Cale> structures are like instances then
00:36:16 <Cale> and signatures like classes
00:36:18 <Cale> roughly
00:36:28 <palomer> structures are many instances
00:36:41 <Cale> hmm
00:36:42 <palomer> one structure is an instance of a large number of signatures
00:36:51 <Korollary> http://caml.inria.fr/pub/docs/manual-ocaml/manual004.html
00:37:06 <palomer> ocaml has different terminology
00:37:51 <palomer> so, for example, let's say we have a random access queue, this would probably satisfy some array signature as well
00:38:03 <palomer> the car structure would satisfy the whipeable signature
00:38:17 <palomer> which would be a subsignature of the car signature
00:38:38 <Saulzar> Trouble is with functors is that they're quite coarse grained, done at a module level, where as type classes can easily be specified per-function
00:38:56 <palomer> Saulzar: totally, for small stuff type classes are much cleaner
00:40:07 <palomer> anyways, I'm off
00:40:56 <palomer> actually, last thing: each structure defines a maximal signature
00:41:06 <palomer> and every signature it satisfies must be a subsignature of that signature
00:41:08 <palomer> night!
00:54:41 <gour> i forgot what is the nick of j. goerzen
00:54:55 <Lemmih> CosmicRay, I think.
00:55:12 <Cale> yes
00:55:18 <gour> thanks
00:55:50 <gour> i have some questions about offlineimap, it is his piece, i suppose
02:32:56 <araujo> Good morning Haskell!
02:37:05 <franz23> Hello! I am pondering what might be wrong with this statement: http://www.phpfi.com/90719
02:41:51 <Saulzar_> franz23, fst gives you the first element of a tuple - not the comparison between two tuples
02:45:51 <aleator> franz: you'd probably like to define "comparing f a b = compare (f a) (f b)" and then "sortBy (comparing fst"
02:46:42 <franz23> aah, thank you!
02:46:55 <franz23> I didnt get that I need to have a comparison function, etc.
03:29:26 <Oejet> Greetings, channel inhabitants.
03:42:26 <gour> dcoutts: ping
03:42:39 <dcoutts> gour, pong
03:43:13 <gour> dcoutts: axel says you're the one slowing migration to darcs :-)
03:43:19 <dcoutts> really?
03:43:22 * gour lol
03:43:37 <gour> see email
03:43:47 <dcoutts> I don't seem to get gtk2hs mailing list emails until 24 hours late
03:43:49 <dcoutts> grr
03:43:57 * dcoutts chekcs the SF.net archive
03:44:12 <gour> ahh, i got it cause it was cc-ed
03:45:02 <dcoutts> it's not in the SF.net archive yet
03:45:16 * dcoutts hates slow mailing lists
03:45:43 <gour> you mean SF lists?
03:45:56 <gour> why don't we switch to mailman on haskell.org?
03:46:16 <dcoutts> gour, that's an interesting point
03:46:49 <gour> that's my point on haskellforge project
03:47:37 <gour> s/on/of
03:48:22 <dcoutts> I wonder if it'd be possible to shift the email archive from SF.net too
03:48:57 <gour> dcoutts: i did some migration of mailman accounts in the past, although i had access to the archives
03:49:30 <dcoutts> well we have some access to the mailing list setup
03:49:37 <dcoutts> Axel has the admin account
03:49:47 <gour> then, mailman provides script for migration
03:49:56 <dcoutts> hmm, interesting
03:50:55 <dcoutts> it's certainly worth considering
03:51:02 <gour> i also think so
03:51:04 <dcoutts> we don't use SF.net for anything else anymore
03:51:35 <dcoutts> though their file release + mirroring system is nice
03:51:48 <dcoutts> and gives us some download stats
03:52:30 <gour> it must be in mailman faq
03:52:44 <dcoutts> did you know we're in the top 98% of active SF.net projects? :-)
03:53:08 <gour> really?
03:53:08 <boegel> dcoutts: the other 2% are dead projects ? :P
03:53:24 <dcoutts> boegel, hah!
03:53:41 <boegel> the top 98% ? that doesn't anything now, does it ?
03:54:14 <dcoutts> boegel, huh?
03:54:54 <kzm> boegel, the ambition doesn't end here.  Next year, we aim to be in the top 97%!
03:54:58 <boegel> the top 98% of projects, so the only 2% of the projects are less active than gtk2hs ?
03:54:58 <kzm> :-)
03:55:20 * gour searches in mailman faq
03:55:39 <dcoutts> boegel, no, the other way around, only 2% are more active.
03:56:03 <dcoutts> boegel, oh yeah sorry I sadi it odly at first, we're in the 98 percentile of active projects
03:56:53 <gour> dcoutts: i think i've found it - pls. check http://www.python.org/cgi-bin/faqw-mm.py?req=all#3.4
03:57:33 <boegel> dcoutts: okay, so gtk2hs is in the top 3% of active projects :)
03:58:19 <dcoutts> http://sourceforge.net/projects/gtk2hs/
03:58:26 <dcoutts> It says:  Activity Percentile (last week) : 98.64
03:59:20 <gour> dcoutts: is this boegel maybe from the wx camp? (lol)
03:59:57 <dcoutts> no, boegel has written quite a bit of stuff with Gtk2Hs
04:00:05 <dcoutts> and he wrote a tutorial!
04:00:25 <gour> just a joke ;)
04:00:34 * dcoutts thanks boegel for being such a good supporter :-)
04:00:40 <gour> but maybe he is a double-spy
04:03:37 <gour> dcoutts: haskell.org also gives us, imho, nicer front-end for searches
04:05:27 <joelr1> morning
04:06:03 <boegel> gour: a double-spy for who ? :)
04:06:06 <Oejet> joelr1: Hello.
04:06:57 <gour> boegel: here is the catch - since you're a double spy we do not know who is your original Majesty :-)
04:12:09 <lisppaste2> joelr1 annotated #14302 with "ambiguous type variable" at http://paste.lisp.org/display/14302#13
04:12:20 <joelr1> folks, could someone please give me a hand with the paste?
04:17:21 <Saulzar_> joelr1, Hmm, the data constructor Quit does not give any type for a 
04:17:32 <joelr1> right, exactly
04:17:47 <joelr1> i just tried it this way
04:17:48 <joelr1>     | Cmd Command
04:17:48 <joelr1>     | Show a => Custom a
04:17:48 <joelr1> instance Show a => Show (Event a) where
04:17:48 <joelr1>     show (Custom a) = show a
04:17:51 <joelr1>     show x = show x
04:17:54 <joelr1> but it did not help either
04:19:13 <Saulzar_> Hmm, what type is Quit anyway?
04:19:20 <joelr1> just that, Quit
04:19:21 <Saulzar_> a is always unspecified there
04:19:24 <joelr1> a constructor
04:19:58 <Saulzar_> I guess you can use Quit::(Event Int) or something, but that's nasty
04:20:14 <joelr1> dcoutts: ping
04:20:29 <dcoutts> joelr1, yarr!
04:20:42 <joelr1> dcoutts: would you kindly lend a hand?
04:20:49 <dcoutts> maybe :-)
04:20:58 <joelr1> http://paste.lisp.org/display/14302#13
04:21:18 <Saulzar_> What you really want is instead of forall a. Event ....  is Event Quit | forall a Custom  - but I know nothing about existentials :)
04:21:37 <joelr1> it did not help. see above ;)
04:21:52 <joelr1> right, exactly
04:21:53 <joelr1> i just tried it this way
04:21:53 <joelr1>     | Cmd Command
04:21:53 <joelr1>     | Show a => Custom a
04:21:53 <joelr1> instance Show a => Show (Event a) where
04:21:55 <joelr1>     show (Custom a) = show a
04:21:57 <joelr1>     show x = show x
04:22:00 <joelr1> but it did not help either
04:23:59 <Saulzar_> What about data Foo = A | forall a. Show a => B a
04:25:00 <dcoutts> joelr1, so you can see the problem is that we don't know which Show instance to select when you try to show Quit
04:25:00 * joelr1 scratches his head
04:25:16 <dcoutts> because there's an 'a' parameter which is not fixed
04:25:27 <joelr1> dcoutts: what are the choices? i thought all shows are created equal :D
04:25:54 <dcoutts> joelr1, well you can specify the type of Quit when you use it, eg Quit :: Event ()
04:26:04 <Saulzar_> It seems problematic to think about even without considering show...
04:26:05 <joelr1> interesting
04:26:10 <joelr1> but isn't that already known?
04:26:21 <dcoutts> joelr1, no. Quit :: Event a
04:26:31 <dcoutts> for any 'a'
04:26:43 <Saulzar_> Can you specify it in the constructor ?  
04:26:50 <joelr1>          _ -> do broadcast (Quit :: Event a)
04:26:54 <joelr1> this did not help
04:26:57 <Saulzar_> You could have Quit a   and use Quit ()  
04:26:57 <joelr1> specify what?
04:26:58 <dcoutts> joelr1, indeed
04:27:10 <dcoutts> joelr1, do broadcast (Quit :: Event ())
04:27:11 <joelr1> but i do not need a in Quit
04:27:21 <joelr1> i will have to add a to all the other constructors then
04:27:24 <dcoutts> joelr1, but it is parameterised by it nevertheless
04:27:40 <dcoutts> and so it is impossible to know which show isntance to use
04:27:42 <joelr1> so why does hthis not help?
04:27:42 <joelr1>          _ -> do broadcast (Quit :: Event a)
04:27:49 <Saulzar_> a is still not fixed
04:27:52 <dcoutts> because that's what it is already
04:28:05 <dcoutts> ie it leaves 'a' unknown
04:28:09 <joelr1> much wierdness
04:28:12 <Saulzar_> You need to chose some type for a...
04:28:26 <joelr1> but can i do it here, locally?
04:28:34 <dcoutts> so we don't know which show function to use for Event a
04:28:36 <joelr1> without changing the event
04:28:42 <dcoutts> because it depends on the 'a'
04:29:03 <Saulzar_> Really you want only the Custom to be associated with the type
04:29:14 <dcoutts> joelr1, look at it this way. How do you expect to show an Event a if you do not know the 'a' ?
04:29:31 <joelr1> Saulzar_: i did that
04:30:06 <lisppaste2> joelr1 annotated #14302 with "only custom" at http://paste.lisp.org/display/14302#14
04:30:15 <dcoutts> now it happens that many of the Event a values do not depend on the 'a', but in general a value of type Event a does depend on the 'a'
04:30:22 <dcoutts> hence the error
04:30:27 <Saulzar_> While you have it declared as "data Event a"  then the type is always Event a
04:31:14 <joelr1> so i remove the data Event a = ... right?
04:31:16 <dcoutts> joelr1, it would be easier if there were no Custom constructor, or if it took some concrete parameter
04:31:22 <joelr1> and leave it as data Event = 
04:31:25 <joelr1> right?
04:31:30 <joelr1> can i do that?
04:31:46 <lisppaste2> Saulzar annotated #14302 with "..." at http://paste.lisp.org/display/14302#15
04:31:56 <dcoutts> joelr1, it depends on if you need to know the type of the Custom value
04:32:09 <joelr1> dcoutts: i do of course
04:32:16 <joelr1> Saulzar_: cool, let me try that
04:32:25 <dcoutts> otherwise you'll need to add type annotations everywhere you use the non-Custom events
04:32:39 <joelr1> dcoutts: i like Saulzar_'s solution
04:32:41 <Saulzar_> But the trouble with that one is that then you have lost knowledge of what the Custom is, only that it is of Show a
04:32:52 <joelr1> hmm
04:33:00 <Saulzar_> Er only that it is of Show rather :)
04:33:05 <joelr1> arggh
04:33:15 <joelr1> that won't work for me, i want to pattern-match on Custom a
04:33:18 <joelr1> that was the whole point
04:33:37 <dcoutts> and what do you need to do with it once you've got it?
04:33:48 <joelr1> get the values, etc
04:33:55 <dcoutts> is the only thing you do with a Custom x to show it?
04:34:04 <Saulzar_> You could make a class for custom events ... 
04:34:09 <joelr1> dcoutts: not at all
04:34:30 <Saulzar_> forall a. Custom a => a
04:34:32 <joelr1> can I have a method-less class?
04:34:48 <dcoutts> certainly
04:34:52 <Saulzar_> Yes, but that's not going to do you any use :)
04:34:53 <dcoutts> but it might not help
04:34:55 <joelr1> ok, so class CustomEvent a  where {}
04:35:01 <Saulzar_> Since you can't use it...
04:35:04 <joelr1> let me try that
04:35:49 <joelr1> like this: 
04:35:49 <joelr1> class CustomState {} deriving Show
04:35:49 <joelr1> data State
04:35:49 <joelr1>     = Start
04:35:49 <joelr1>     | Stop
04:35:52 <joelr1>     | forall a.CustomState a => State a
04:35:55 <joelr1> right?
04:36:26 <dcoutts> joelr1, you might find it easier to just specify the types of the stuff when you pass it to broadcast
04:36:55 <joelr1> hmm
04:36:58 <Saulzar_> Yes, but then you can never use It for anything other than Show or the methods inside CustomState
04:37:04 <joelr1> class CustomState {} deriving Show
04:37:04 <joelr1> does not work
04:37:18 <dcoutts> but the basic design problem is that the Custom doesn't really fit well with the other stuff. There are probably better ways of expressing it.
04:37:27 <joelr1> how?
04:37:39 <dcoutts> I don't know what you are doing
04:37:40 <joelr1> all i want is for library users to be able to pass their custom state
04:37:49 <joelr1> or event
04:37:56 <Saulzar_> Then what do you need to do with it ?
04:37:57 <dcoutts> and what ops to those states support?
04:37:57 <joelr1> but i also want to be able to print these
04:38:07 <joelr1> i do not know the ops in advance
04:38:09 <Saulzar_> That's all?
04:38:17 <joelr1> but i still want to show 
04:38:21 <dcoutts> then all they support is showing
04:38:33 <joelr1> dcoutts: no, that's what I care about
04:38:43 <joelr1> these are records or something else, whatever the user wants
04:38:54 <joelr1> i cannot foresee that but do want to show the a
04:39:55 <dcoutts> do you ever need collections of Events?
04:39:57 <dcoutts> eg lists of them?
04:40:16 <joelr1> not really, i stuff them into TChan/TMVar, etc
04:40:33 <dcoutts> but then the Chan is parameterised by the 'a' too
04:40:33 <joelr1> but i do have a list of [(State, <something>)]
04:40:41 <joelr1> state having the same issue
04:40:56 <joelr1> dcoutts: yes, the TChan is parameterized, the list of State... is parameterized
04:40:58 <dcoutts> we're taling about Event here right? what is state
04:41:03 <joelr1> same stuff
04:41:18 <dcoutts> so it's "State a" ?
04:41:22 <joelr1> yes
04:41:36 <joelr1> State just has less constructors :)
04:41:37 <dcoutts> then you get (TChan (Event a))
04:41:42 <joelr1> right
04:41:53 <dcoutts> so the user can only have one kind of Custom event
04:42:08 <joelr1> dcoutts: i guess that's per module but yes
04:42:22 <dcoutts> Custom 1 and Custom "b" never need to be put in the same channel?
04:42:27 <joelr1> nope
04:42:31 <dcoutts> ok good
04:42:35 <joelr1> that's a restriction i'm willing to accept
04:42:42 <Saulzar_> Hmm
04:42:44 <joelr1> i had Custom Dynamic but could not pattern-match on that
04:43:00 <joelr1> so i decided to parameterize on a which got me into trouble
04:43:43 <dcoutts> so having a class of Events will not help
04:43:54 <Saulzar_> Using the existential would let you show them, and still have no parameter (but you could never do anything else with them except show)
04:43:54 <dcoutts> since then you cannot put different events into a channel
04:43:55 <joelr1> dcoutts: why not?
04:44:18 <joelr1> Saulzar_: would users be able to do anytthing with Custom a?
04:44:24 <joelr1> Saulzar_: like pattern match on it
04:44:37 <joelr1> i.e. the showing only applies to my library, right?
04:44:40 <musasabi> fromDyn, but nothing else.
04:44:43 <joelr1> the restriction
04:44:47 <dcoutts> joelr1, the simplest thing is just to specify the type Quit :: Event ()
04:44:52 <Saulzar_> Sure, users could - they can pass in any type which is of class a - but once you store it as that _you_ are restricted to the typeclass specified
04:44:53 <dcoutts> when you pass it to broadcast
04:45:01 <dcoutts> or do end users have to do that too?
04:45:11 <dcoutts> (ie is makes the interface ugly)
04:45:19 <joelr1> dcoutts: i think Saulzar_ is on to something
04:45:35 <joelr1> so, i the library writer do not need to do anything with Custom a but show a
04:45:46 <Saulzar_> Sorry - "any type which is of class show" - mising up my words
04:45:55 <joelr1> i want users of the library to do anything they want with a
04:45:57 <dcoutts> but the end user still cannot get the value out of the Custom constructor
04:46:02 <dcoutts> (except to show it)
04:46:10 <joelr1> dcoutts: right, that'a bad
04:46:23 <joelr1> dcoutts: let me try passing Event () to broadcast
04:46:30 <Saulzar_> Does the end user get Event 's?
04:46:46 <dcoutts> once you put something inside an exestential box then when you get it out again you can only use it's declared interface
04:46:48 <joelr1> data State a
04:46:49 <joelr1>     = Start
04:46:49 <joelr1>     | Stop
04:46:49 <joelr1>     | Show a => State a
04:46:51 <joelr1> liek this then?
04:47:00 <joelr1> Saulzar_: yes, they do
04:47:03 <Saulzar_> Ahhh
04:47:06 <joelr1> and they pattern-match on them
04:47:50 <Saulzar_> That's what I was missing. I think dcoutts is probably right
04:47:53 <dcoutts> joelr1, that State decleration is the same as you had before
04:48:15 * dcoutts wonders if GADTs might help
04:48:29 <joelr1> duncan wins the day!
04:48:34 <joelr1> with 
04:48:35 <joelr1>          _ -> do broadcast (Quit :: Event ())
04:48:55 <dcoutts> it's just a bit of a pain
04:49:10 <joelr1> well, yes, I have Show a => everywhere
04:49:17 <joelr1> and GADTs are a bigger pain
04:49:22 <dcoutts> probably
04:49:37 <joelr1> it HList was simple i would have used it instead of defining my records as haskell records
04:49:56 <joelr1> although next time i'm starting from scratch i'll try that again
04:50:01 <dcoutts> heh, but HList is anything but simple
04:50:10 <joelr1> if i have a requirement for records with shared fields
04:50:19 <joelr1> dcoutts: HList == GADT, no?
04:50:34 <dcoutts> no
04:50:59 <dcoutts> HList == extreme type class hackery
04:51:20 <joelr1> i thought GADT was what we were trying to figure out
04:51:20 <joelr1> the combo of existentials, fundeps, etc
04:51:43 <dcoutts> you can read the papers about GADTs
04:52:22 <joelr1> i thought i did. maybe i need to again
04:52:31 <joelr1> there seem to be quite a lot of them
04:52:40 <joelr1> and the whole thing seems like a very fuzzy subject
04:53:04 <joelr1> could be just me but it seems that if GADTs were easy and crisp everyone would be using them
04:53:08 <joelr1> instead of talking
04:55:26 <dcoutts> I think most people haven't taken the time to understand them yet (myself included)
04:55:41 <Saulzar_> Hmm, it would seem they let you have Quit automatically associated as Event ()
04:55:47 <joelr1> dcoutts: i'm in your camp
04:56:05 <Saulzar_> Just looking at the syntax..
04:56:32 <joelr1> i'm willing to read the papers. are they useable with ghc 6.4.1 or do we need to wait for 6.4.2 , etc
04:58:59 <Saulzar_> Ah - I guess it's experimental stuff, on the Haskell wiki it says 6.5
04:59:15 <joelr1> there
04:59:18 <joelr1> that's what i thought
05:00:22 <joelr1> this sucks
05:00:30 <Saulzar_> Is it so bad? :)
05:00:34 <joelr1> i have to parameterize EVERYTHING on a b now
05:00:45 <joelr1> where a is for State and b is for Event
05:00:50 <joelr1> let me just go through with it
05:01:03 <dcoutts> http://haskell.org/ghc/docs/6.4/html/users_guide/release-6-4.html
05:01:13 <dcoutts> joelr1, Saulzar_, it's in 6.4.x
05:01:22 <dcoutts> see the release announcement
05:01:26 <Saulzar_> Hmm, I guess I  was reading something else.
05:01:44 <Saulzar_> Ahh - GADT with records says the Haskell wiki.
05:01:49 <joelr1> Saulzar_: that must have been records
05:06:46 <Saulzar_> I wonder if the simple   RobotState -> [Event] -> RobotActions  would be fine for a little robot interface, this Yampa stuff seems somewhat convoluted for a newbie (I'd know - I am one)
05:08:04 <joelr1> i wanna do yampa
05:08:12 <joelr1> just as soon as i'm done with this project
05:08:24 <joelr1> in fact i'm wondering if yampa should be used for all event-driven systems
05:09:11 <musasabi> GADTs are nifty, but require good design.
05:09:24 <musasabi> type aliases can help to hide some extra parameters
05:09:34 <musasabi> but reboot time.
05:09:52 <Saulzar_> It looks quite neat, I guess I'll have to get some code down on disk, too much reading and not enough tinkering creates confusion
05:10:33 <joelr1> i got into trouble again
05:10:34 <joelr1> pasting
05:11:25 <lisppaste2> joelr1 annotated #14302 with "trouble" at http://paste.lisp.org/display/14302#16
05:12:03 <joelr1> how do i resolve this?
05:15:25 <musasabi> joelr1: that means that ghc infers a = b.
05:15:37 <joelr1> umm
05:15:42 <joelr1> but they are not the same
05:16:14 <musasabi> I would just comment that out and play with the types in ghci to see where I go wrong.
05:16:22 <joelr1> hmm ok
05:21:25 <SamB> joelr1: you know, you can instantiate Show manually...
05:22:17 <SamB> > "lambdabot. are you alive?"
05:23:47 <kzm> SamB, I think the answer is "no"
05:24:04 <SamB> yeah. I guessed.
05:24:23 <kzm> It was alive on the other channels, but seemed stuck here. 
05:24:25 * kzm shrugs.
05:24:34 <SamB> oh?
05:25:04 <SamB> oh, it seems to have quit
05:25:10 <kzm> At least, I got a response in #haskell-overflow a while ago, but none here.  Could've been a network fluke or something.
05:25:39 <kzm> I was thinking briefly about making a jabber-bridge module.
05:26:03 <kzm> So that I could check IRC from Gaim, and get hold of IM contacts from IRC :-)
05:26:19 <SamB> hew, wait a minute! if lambdabot has its own box, why is seafood on the same box it was on?
05:26:43 * kzm is waiting, looking at his watch.
05:26:59 * SamB groans
05:27:04 <kzm> :-)
05:27:06 <seafood> SamB: I use that box to run an irc proxy.
05:27:17 <SamB> seafood: ah
05:27:32 <seafood> There seems to have been a problem with the network at my university.
05:27:39 <SamB> yes
05:27:41 <SamB> again!
05:27:45 <seafood> :(
05:27:58 <kzm> How difficult would it be to make the bot network redundant?
05:28:18 <SamB> *something* has gone wrong like every night (here in EST)
05:28:25 * SamB has to go
05:28:34 <kzm> E.g. multiple bots syncing their persistent data, and one quietly assuming the status of official lambdabot when the other fails?
05:29:12 * kzm thinks the answer might be "very".
05:30:08 <Oejet> Hm, a redundant lambdabot.  Scary...
05:31:41 <mysteriousentity> I want to write a spider in Haskell. Could someone suggest some libraries/functions I should get acquainted with?
05:32:53 <Saulzar_> What is a spider?
05:33:25 <joelr1> SamB: does it have to do with Show?
05:33:38 <mysteriousentity> Something that downloads the tree of a webpage to your hard drive.
05:36:44 <Heffalump> kzm: I was thinking that yesterday too
05:36:50 <Heffalump> but I don't really have time to make it happen.
05:36:58 <Heffalump> it shouldn't be that hard.
05:37:28 <Heffalump> though probably each individual module would need extending to support the syncing of data
05:37:42 <kzm> Heffalump, that sounds hard to me :-)
05:38:36 <kzm> another option could be an assisting bot, keeping track of all state changing messages, and feeding them to the main bot on its resurrection
05:39:15 <kzm> Nah, forget it - the main thing would be to retain functionality, not to avoid loss of state-changes.
05:40:03 <kzm> We could just have a bot that sat quiet until \bot went away, and then started intercepting @-commands.
05:40:13 <kzm> We can live without @karma in the meantime, I think.
05:40:31 <Heffalump> well, that'd be the starting point.
05:40:52 <Heffalump> add support for "list of superior bots in whose presence I will be quiet"
05:40:54 <Heffalump> that's trivial
05:41:10 <Heffalump> (following their alternate nicks might be a bit harder, though)
05:45:54 <musasabi> Has anyone created a fancy logging plugin for lambdabot?
05:52:12 <boegel> musasabi: why would lambdabot do logging ? she's never here :P
05:53:28 <musasabi> boegel: I need something like that for yet an another project.
05:54:03 <boegel> oh, ok
05:54:11 <boegel> shoudln't be too hard I think
05:54:15 <boegel> why don't you try it ?
05:54:39 <musasabi> currently I have a cronjob which takes irclogs and formats them into a wiki
05:54:48 <musasabi> too many projects already
06:06:48 <dcoutts> hia xerox
06:07:04 <joelr1> dcoutts: i'm stuck again
06:07:21 <xerox> Hello!
06:07:29 * xerox does a little dance - Spivak's arrived :-D
06:07:46 <lisppaste2> joelr annotated #14302 with "strange stuff" at http://paste.lisp.org/display/14302#17
06:07:58 * xerox pokes Cale
06:10:12 <triplah> i got full marks for my haskell assignment
06:10:14 * triplah dances
06:10:23 <triplah> thanks anyone who helped me :)
06:10:41 <dcoutts> joelr1, you've not given us enough context to know what is going on or what the type of anything is
06:10:43 <xerox> Good!
06:10:46 * triplah returns to fighting beagle
06:10:59 <triplah> hardly works on my system :\
06:11:03 <xerox> Poor dog.
06:11:07 <triplah> aha
06:11:43 <lisppaste2> joelr1 annotated #14302 with "context" at http://paste.lisp.org/display/14302#18
06:12:23 <triplah> let whowins n = if n > 0.5 "triplah" else "beagle" in whowins n where n = random
06:12:31 <joelr1> this was part of the problem
06:12:32 <joelr1> liftIOTrap :: IO c -> (ScriptState a b) c
06:12:42 <joelr1> i had it as liftIOTrap :: IO a -> (ScriptState a b) a
06:12:42 <triplah> let whowins n = if n > 0.5 then "triplah" else "beagle" in whowins n where n = random
06:12:45 <joelr1> and that's wrong
06:12:57 <triplah> >let whowins n = if n > 0.5 then error "triplah" else error "beagle" in whowins n where n = random
06:13:06 <triplah> > let whowins n = if n > 0.5 then error "triplah" else error "beagle" in whowins n where n = random
06:13:10 <triplah> :(
06:13:15 <triplah> oh
06:13:20 <dcoutts> joelr1, what is this?: keepAlive :: (ScriptState a b) ()
06:13:27 <triplah> lambdabot, where for art thou :(
06:13:43 <dcoutts> joelr1, what is the type of send and mkClKeepAlive?
06:13:46 <joelr1> dcoutts: ignore me for a second, please, i think i had some old a-s hanging around in the type signatures
06:14:07 <joelr1> and then i did a global replace of ScriptState with (ScriptState a b)
06:14:11 <joelr1> thus the problems
06:23:02 <mysteriousentity> What function(s) can I use to connect to a URL and get the html?
06:23:50 <ADEpt> mysteriousentity: there are HTTP library which is named just that
06:28:51 <mysteriousentity> quite
06:30:27 <enlived> hello
06:31:21 * joelr1 feels /almost/ like a grizzled haskell hacker now
06:36:21 <kzm> Should I run my local bot until dons and his bot is back?
06:36:26 <joelr1> dcoutts: figured it out
06:36:46 <jethr0> hmm, what happens to lambdabot all the time?
06:37:00 <kzm> Not sure.  Network trouble, perhaps.
06:37:32 <joelr1> dcoutts: i had the a and b swapped around  in some places
06:37:37 <kzm> Would it be helpful to have a backupbot that shuts up when lambdabot is present?
06:42:09 <jethr0> good idea, but i'd prefer a solid lambdabot...
06:42:37 <kzm> Not better than nothing?
06:42:45 <kzm> @karma- jethr0 
06:42:45 <extrabot> jethr0's karma lowered to -1.
06:42:48 <kzm> Hmpf
06:42:58 <jethr0> thx a lot
06:43:13 <neologism> what is this karma good for?
06:43:15 <kzm> Of course, it's a bit limited withouth hs-plugins
06:43:21 <kzm> The afterlife, one presumes
06:43:23 <jethr0> good for you i am not the escalating type ;-)
06:43:36 <Lemmih> neologism: http://en.wikipedia.org/wiki/Karma
06:43:48 <neologism> I know what karma is ;)(
06:43:49 <kzm> Oh, yeah?  Them's fighting words!
06:43:54 <neologism> I dont know what karma is for here
06:44:00 <int-e> @karma+ extrabot 
06:44:00 <extrabot> extrabot's karma raised to 1.
06:44:09 <kzm> @karma+ int-e
06:44:10 <extrabot> int-e's karma raised to 1.
06:44:28 <int-e> karma is cheap nowadays
06:44:29 <jethr0> @type ((+) 4 (4))
06:44:30 <extrabot> forall a. (Num a) => a
06:44:40 <kzm> > ((+) 4 4)
06:44:40 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
06:44:44 <jethr0> @type ((+) 4 (+))
06:44:45 <extrabot> forall a. (Num (a -> a -> a), Num a) => a -> a -> a
06:44:46 <kzm> Sorry about that.
06:45:15 <kzm> Hmm.. any instances of Num (a->a->a)?
06:45:27 * jethr0 is now in the caste of people with neg. karma ;-(
06:45:35 <kzm> @karma kzm
06:45:35 <extrabot> You have a karma of 0
06:45:54 <kzm> I guess that is the biggest category, since I think I deleted the old values.
06:46:13 <kzm> @karma+ jethr0
06:46:13 <extrabot> jethr0's karma raised to 0.
06:46:22 <kzm> ...if you promise to be nice.
06:46:25 <kzm> :-)
06:46:28 <jethr0> yeah, karma promotion
06:46:44 <int-e> For all I remember, jethr0 is generally nice.
06:47:09 <jethr0> thx, but i'm only been in here for the last 3 days ;-)
06:47:17 <jethr0> i've*
06:51:56 <kzm> Okay, okay:
06:52:01 <kzm> @karma+ jethr0
06:52:01 <extrabot> jethr0's karma raised to 1.
06:52:17 * kzm hopes everybody is happy now.
06:52:18 <kzm> :-)
06:53:04 * jethr0 is overjoyed... although the extrabot universe might not last long enough to reap profit from my good karma
07:13:52 <kzm> I'm off, ask dons to @quit the bot when \bot is back online?
07:14:24 <jethr0> k, cu
07:24:16 <Pupeno> If I want to do QuickCheck of a function that takes integers from 0 to 255, how do I write the property ? do I need my own generator ?
07:25:35 <vincenz> Pupeno: you mean type it?
07:26:38 <Pupeno> vincenz: how do I type with arbitrary limits ?
07:26:48 <chucky> pupeno: you have to write your own generator
07:27:06 <chucky> something like "oneof [0..255]" should suffice
07:27:45 <chucky> sorry, that should be "elements [0..255]"
07:28:34 <Pupeno> ok. but, where do I put that ? QuickCheck documentation is not clear to me, sorry.
07:28:55 <kolmodin> forall (elements [0..255]) $ \i -> f i
07:29:04 <kolmodin> try that
07:29:53 <kolmodin> sorry, it's "forAll"
07:29:53 <Pupeno> kolmodin: as type ?
07:31:05 <kolmodin> prop_hi = forall (elements [0..255]) $ \i -> f i
07:31:15 <kolmodin> Pupeno: that will have type Property
07:31:46 <kolmodin> @type forAll
07:31:48 <extrabot> Not in scope: `forAll'
07:31:56 <kolmodin> @type Test.QuickCheck.forAll
07:31:57 <extrabot> forall b a.
07:31:57 <extrabot>          (Test.QuickCheck.Testable b, Show a) =>
07:31:57 <extrabot>          Test.QuickCheck.Gen a -> (a -> b) -> Test.QuickCheck.Property
07:32:12 <tic|school> kolmodin, lab5?
07:32:29 <kolmodin> tic|school: haven't looked at it yet
07:32:50 <ADEpt> Pupeno: x <- choose (0.255) .... ?
07:33:19 <ADEpt> choose(0,255) even
07:33:39 <tic|school> kolmodin, okay. just checking-
07:33:46 <Pupeno> kolmodin: thanks.
07:34:48 <kolmodin> Pupeno: np
07:35:30 <Pupeno> ADEpt: how is choose(0,255) used ?
07:36:53 <ADEpt> @type Test.QuickCheck.choose
07:36:54 <extrabot> forall a.
07:36:54 <extrabot>          (System.Random.Random a) =>
07:36:54 <extrabot>          (a, a) -> Test.QuickCheck.Gen a
07:37:38 <ADEpt> instance Arbitrary YourType where
07:37:38 <ADEpt>   arbitrary = do x<-choose (0,255); return x
07:37:38 <ADEpt> not tested :)
07:37:57 <ADEpt> Pupeno: and 'newtype YourType = YourType Int'
07:38:14 <Pupeno> ADEpt: What type ?
07:38:39 <kolmodin> Pupeno: you could use 'choose' like this;   prop_foo = forall (choose (0,255)) $ \i -> f i
07:38:52 <ADEpt> Pupeno: read the last section of QuickCheck docs. It's trick from there.
07:38:55 <Pupeno> kolmodin: thanks.
07:39:00 <Pupeno> ADEpt: thanks.
07:39:02 <ADEpt> kolmodin: thanks for correcting me.
07:39:47 <kolmodin> the difference is that with 'choose' you give it the range and with 'elements' you give it all the elements it should pick from
07:40:17 <kolmodin> np
07:40:52 <Pupeno> kolmodin: I got an error with that use of choose, 
07:40:58 <Pupeno> lisppaste2: url
07:40:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:41:15 <kolmodin> hmm
07:41:31 <Pupeno> I'll paste it.
07:42:32 <lisppaste2> Pupeno pasted "choose" at http://paste.lisp.org/display/14414
07:43:51 <ADEpt> Pupeno: you need to specify type for "x" from "\x", not from "prop_A x"
07:44:21 <kolmodin> yeah, you are using x twice
07:49:10 <Pupeno> How do you specify the type when using lambda notation ?
07:49:38 <kolmodin> i'm guessing here, try this:    $ \i::Int -> 
07:49:45 <kolmodin> and turn on -fglasgow-exts
07:50:31 <Pupeno> I tried that, Couldn't match `Int' against `Bool' (may I be specifing the return type by that ?)
07:50:52 <jethr0> (\i -> even i) :: Bool, maybe...
07:50:53 <Pupeno> \(y::Int) -> worked.
07:51:00 <kolmodin> ah, ok
07:51:11 <Pupeno> jethr0: I don't want to specify the result, but the parameter.
07:51:16 <jethr0> k
07:51:22 <xerox> (\i -> even i) :: Num n => n -> Bool
07:51:39 <jethr0> xerox, my bad
07:51:45 <Pupeno> choose is about 10 times faster than elements
07:51:46 <xerox> \i -> even i :: Num n => n -> Bool
07:51:51 <xerox> Anyway.
07:52:11 <jethr0> well, for one it will only use 100 elements instead of all 255...
07:52:20 <jethr0> one thing*
07:52:39 <Pupeno> jethr0: both said "OK, passed 100 tests."
07:52:45 <jethr0> hmm, ok
07:52:49 <kolmodin> Pupeno: yeah, it's faster when you have a whole range of numbers
07:53:22 <jethr0> maybe the laziness in [0..255] takes its toll, but i can't imagine that to be noticeable...
07:53:50 <jethr0> more likely you are doing (100*100) and (100*255) tests *gg*
07:53:56 <Saulzar_> Has anyone here had any experience with Yampa or the like? The more I look at it, writing a simple game with it is like trying to use a freight train to tow a matchbox
07:53:59 <kolmodin> Pupeno: 'elements' will first count how many elems it got and then pick one
07:54:28 <Pupeno> jethr0: I am working with 0..2^15
07:54:33 <jethr0> aahh
07:54:56 <kolmodin> ah..... :)
07:55:07 <jethr0> then picking a random element out of [0..2^15] _will_ be slow. at least if it uses (!)
07:55:46 <kolmodin> it uses (!!)
07:56:03 <jethr0> that's what i meant, anyways
07:56:11 <Saulzar_> You could convert it to an array first 
07:56:50 <kolmodin> yes, but the implementation wouldn't be as beatiful as this then:  elements xs = (xs !!) `fmap` choose (0, length xs - 1)
07:57:16 <kolmodin> :)
07:58:47 <xerox> Hm?
07:59:11 <xerox> Isn't it equal to elements xs = xs !! choose (0, length xs - 1)
07:59:49 <xerox> Or does choose return a list?
08:00:10 <xerox> Yeah, prolly.
08:00:23 <jethr0> saulzar_, i guess that after getting used to arrows (yampa), you wouldn't want to miss them... the trick is to get there!
08:03:42 <Saulzar_> jethr0, Hmm, I can see they might be useful for events - combining switching etc. Otherwise I'm scratching my head as to why they're so useful
08:06:28 <jethr0> have you read the arrow papers?? it's about a notation combining computations/algorithms...
08:06:51 <Saulzar_> I have been looking at some papers on yampa and the space invaders example
08:06:59 <jethr0> http://www.haskell.org/arrows/
08:07:05 <Saulzar_> The space invaders example seems like the most complicate space invaders game I have _ever_ seen
08:08:18 <jethr0> yes, arrows will build up their full potential the more complex the application (i think).
08:08:37 <Saulzar_> I'm strongly tempted to either write a mini-yampa (based on discrete time to simlify) or scrap any notion of using it at all
08:08:55 <jethr0> hmm, have you seen the examples of "haskell in space"
08:08:56 <jethr0> ?
08:09:11 <Saulzar_> Nope..
08:09:15 <jethr0> @google "haskell in space"
08:09:16 <extrabot> http://www.informatik.uni-bremen.de/~cxl/haskell-in-space/
08:09:29 <Saulzar_> I just googled :)
08:09:54 <jethr0> the assignment was to write "space invaders" and it includes some students solutions. not using a nice framework, but maybe worth looking at.
08:10:36 <jethr0> also, there is funGen and monadius
08:13:07 <Saulzar_> I have no problem envisioning a game in haskell - just this Yampa library gives me a headache as to the size and complexity of it :)
08:13:34 <jethr0> funGen is a haskell game library
08:14:04 <int-e> @where yampa
08:14:04 <extrabot> I know nothing about yampa.
08:15:06 <Saulzar_> Yampa was meant to be for simulating robots. I think the issue which turns me off, is that it is designed for heavy physical simulation. Where as the robots I envisioned where fairly ad hoc "for fun"
08:15:54 <Saulzar_> I think I'll try making a tiny library and incorperate some of the ideas, maybe then I can see why it is useful :)
08:16:04 <flux__> saulzar_, maybe the difference between discrete and continous world?
08:16:13 <Saulzar_> Yes
08:16:45 <o_Rocky> is there any library in Haskell for Parsing Arguments like getopt in C?
08:16:47 <Saulzar_> For a little AI game I think treating it as a physical simulation is too much
08:18:47 <Saulzar_> It is roughly continuous, but not to the same level. Acceleration is gone, for example
08:20:38 <flux__> o_rocky, ghc apparently has Distribution.GetOpt
08:20:50 <flux__> o_rocky, google will serve you well..
08:25:17 <Lemmih> Don't use Distribution.GetOpt
08:26:07 <o_Rocky> why?
08:27:15 <Lemmih> It will most likely go away soon.
08:27:20 <Lemmih> Use System.Console.GetOpt instead.
08:27:59 <Lemmih> (it's a part of Cabal which should be hidden, IMHO)
08:28:45 <o_Rocky> ?
08:28:57 <o_Rocky> what is Cabal?
08:29:04 <xerox> @where Cabal
08:29:04 <extrabot> I know nothing about cabal.
08:29:20 <xerox> @where+ cabal http://www.haskell.org/cabal
08:29:20 <extrabot> cabal ~> http://www.haskell.org/cabal
08:29:47 <Lemmih> It's a Haskell library used for building libraries and applications.
08:48:44 <araujo> Hello Haskell!
09:08:23 <Sven_Moller_Fah> good afternoon everyone
09:08:48 <Sven_Moller_Fah> could anyone plz tell me why this doesnt work?
09:08:49 <Sven_Moller_Fah> http://paste.lisp.org/display/14416
09:08:59 <Sven_Moller_Fah> i mean, they all work separatly
09:09:11 <Sven_Moller_Fah> and if i go one by one they do the job, but when i put them together they dont
09:09:25 <Sven_Moller_Fah> im usre im missing something rather simple
09:10:06 <Sven_Moller_Fah> oh and numero n = takeWhile isDigit n
09:18:03 <Sven_Moller_Fah> anyone plz?
09:18:50 <tromp_> why use mai?
09:19:09 <Sven_Moller_Fah> hmm
09:19:10 <tromp_> there is already maximum
09:19:27 <Sven_Moller_Fah> there is a function like that?
09:19:29 <tromp_> and numero is ugly:(
09:19:31 <Sven_Moller_Fah> didnt knew sorry
09:19:41 <Sven_Moller_Fah> lol
09:20:00 <tromp_> you should use (fst.head.reads)
09:20:39 <tromp_> in major, how can you apply lines to x?
09:20:39 <Sven_Moller_Fah> ?
09:20:51 <Sven_Moller_Fah> well
09:20:54 <Sven_Moller_Fah> x is a string
09:20:55 <tromp_> x is [String]
09:21:02 <tromp_> according to your type decl
09:21:06 <Sven_Moller_Fah> OH!
09:21:11 <Sven_Moller_Fah> lol
09:21:17 <Sven_Moller_Fah> thats whats wrong
09:21:59 <Sven_Moller_Fah> maximum does the same as mai?
09:22:32 <tromp_> why not simply take:
09:22:47 <tromp_> major = maximum . map (fst.head.reads)
09:23:00 <Sven_Moller_Fah> well, first i dont understand that
09:23:32 <Sven_Moller_Fah> so that wouldnt help me much
09:23:42 <Sven_Moller_Fah> it would work...but im into learning
09:23:43 <tromp_> Prelude> let major = maximum . map (fst.head.reads)
09:23:43 <tromp_> Prelude> :t major
09:23:43 <tromp_> major :: [String] -> Integer
09:23:43 <tromp_> Prelude> major ["17 blsdaf fjsdh ", "6 awefjh jferjh fj", "-65 12 re"]
09:23:43 <tromp_> 17
09:24:01 <Sven_Moller_Fah> whats the .
09:24:05 <Sven_Moller_Fah> what does it do?
09:24:20 <tromp_> (f.g) x = f (g x))
09:24:42 <Sven_Moller_Fah> hmm
09:24:49 <Sven_Moller_Fah> and fst.head.reads?
09:25:05 <tromp_> let major x = maximum $ map (fst.head.reads) x
09:25:33 <tromp_> let major x = maximum $ map (\y -> fst (head (reads y))) x
09:25:43 <Sven_Moller_Fah> oh
09:25:45 <Sven_Moller_Fah> ok
09:26:00 <Sven_Moller_Fah> whats fst?
09:26:22 <tromp_> look up haskell Prelude in google
09:26:34 <tromp_> most of these functions are defined in that file
09:27:01 <tromp_> see http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
09:27:52 <Sven_Moller_Fah> ok thx
10:04:43 <o_Rocky> Sven_Moller_Fah: boas portugal!
10:13:30 <Sven_Moller_Fah> :D:D
10:13:33 <Sven_Moller_Fah> es tuga?
10:13:36 <o_Rocky> ya
10:13:38 <Sven_Moller_Fah> lol
10:13:40 <Sven_Moller_Fah> es donde?
10:13:49 <o_Rocky> isso pergunto eu :P
10:13:53 <Sven_Moller_Fah> Evora e tu?
10:13:57 <o_Rocky> Braga
10:14:07 <Sven_Moller_Fah> bom tao e tas aki a fazer o k?
10:14:12 <Sven_Moller_Fah> percebes disto ?
10:14:20 <o_Rocky> +-
10:14:25 <o_Rocky> algumas cenas
10:14:34 <Sven_Moller_Fah> eu tou a fazer um trabalho p Univ
10:14:45 <o_Rocky> tb eu
10:14:48 <Sven_Moller_Fah> e entao knd ha cenas k n consigo compilar venho aki p ver s alguem m explica
10:15:00 <o_Rocky> eu tive a ver o link
10:15:00 <Sven_Moller_Fah> mas n peo a ninguemp m fazer as cenas lol
10:15:04 <Sven_Moller_Fah> ya pa
10:15:22 <Sven_Moller_Fah> tipo isso, fiz akilo sozinho, so k akele [String] tava-m a empatar akilo
10:15:29 <o_Rocky> n percebo o q queres pra fazer... n te importas de explicar?
10:15:33 <Sven_Moller_Fah> ah lol
10:15:43 <Sven_Moller_Fah> n keres falar em pvt'
10:15:44 <Sven_Moller_Fah> '
10:15:45 <Sven_Moller_Fah> ?
10:15:52 <o_Rocky>  melhor
10:17:42 <SyntaxNinja> Sven_Moller_Fah: you're back!
10:19:53 <Sven_Moller_Fah> SyntaxNinja: you want me to leave?
10:20:28 <Sven_Moller_Fah> im not bothering anyone just talking with someone from my country...
10:20:30 <SyntaxNinja> Sven_Moller_Fah: oh give  me a break.
10:20:51 <Sven_Moller_Fah>  break :: (a -> Bool) -> [a] -> ([a],[a])
10:20:57 <Sven_Moller_Fah> :D
10:21:07 <SyntaxNinja> Sven_Moller_Fah: if I wanted you to leave, you'd know by now.
10:21:18 <Sven_Moller_Fah> ok sry m8
10:21:38 <Sven_Moller_Fah> didnt mean to be rude
10:22:01 <Philippa_> if you're just talking to one person it's probably better to have a private conversation
10:22:07 <Sven_Moller_Fah> we are...
10:22:08 <Sven_Moller_Fah> :D
10:22:16 <Philippa_> (unless you're actively looking for people to join in, which... well, if you're not talking english it's unlikely)
10:22:21 <Sven_Moller_Fah> <Sven_Moller_Fah> n keres falar em pvt'
10:22:33 <Sven_Moller_Fah> this means: Wanna talk private?
10:22:51 <Philippa_> yeah, you can take my comment as applying in general
10:24:20 <Sven_Moller_Fah> well he doesnt say anything in private
10:24:34 <Sven_Moller_Fah> do you have some kind of private conversations blockage?
10:24:41 <Sven_Moller_Fah> like to prevent spam or something?
10:25:08 <o_Rocky> ?
10:25:15 <Sven_Moller_Fah> tas a falar cmg em pvt?
10:25:26 <o_Rocky> Private messages from unregistered users are currently blocked due to spam problems, but you can always message a staffer. Please register! ( http://freenode.net/faq.shtml#privmsg )
10:25:31 <Sven_Moller_Fah> ah
10:25:34 <Sven_Moller_Fah> LOL
10:25:43 <Sven_Moller_Fah> regista-te
10:25:51 <o_Rocky> eu j tou registado!
10:26:01 <Sven_Moller_Fah> e ja fizeste identify'
10:26:02 <Sven_Moller_Fah> ?
10:27:50 <kosmikus> huh, what's going on here?
10:27:57 * SamB might have suggested a more appropriate channel had he known what language that was and what its two-letter code was...
10:28:24 <jethr0> @babel en pt portuguese is a weird language
10:28:25 <extrabot>  o portugus  uma lngua estranha
10:28:32 <jethr0> ;-)
10:28:43 <jethr0> hmm, it even translated that quite well
10:28:46 * jethr0 is astonished
10:28:46 <kzm_> @karma+ jethr0
10:28:47 <extrabot> jethr0's karma raised to 2.
10:28:55 <o_Rocky> yeh
10:29:32 <o_Rocky> @babel pt en Monad
10:29:32 <Saulzar_> @babel pt en o portugus  uma lngua estranha
10:29:32 <extrabot>  Monad
10:29:33 <extrabot>  portugus  one lngua stranger
10:29:52 <o_Rocky> lol
10:29:57 <Sven_Moller_Fah> omg
10:30:05 <jethr0> @babel es pt pero es demasiado differente de espaol por etenderlo
10:30:06 <extrabot> Module "babel" produced error: Prelude.head: empty list
10:30:22 <Saulzar_> Haha
10:30:31 <SamB> @quote ghc
10:30:31 <extrabot> ghc hasn't said anything memorable
10:30:59 <SamB> @babel es en pero es demasiado differente de espaol por etenderlo
10:31:00 <extrabot>  but he is too differente of espaol by etender it
10:31:14 <jethr0> @babel es en pero es demasiado differente de espaol por entenderlo
10:31:15 <extrabot>  but he is too differente of espaol to understand it
10:31:47 <jethr0> but then, my spanish sucks! probably "de" is not correct here, anyway
10:37:30 <SamB> @bable en es but spanish is too different for him to understand it
10:37:31 <extrabot>  pero el espaol es demasiado diferente para que l lo entienda
10:37:53 <Taral> extrabot doesn't like UTF-8
10:50:08 <kzm_> Taral, I think it is a problem with parsing the web page output.
10:50:13 <kzm_> Haven't looked too closely.
11:01:09 <kzm_> Anybody grok google's page rank?
11:01:17 <kzm_> (Or know where to ask?)
11:01:29 <SamB> kzm: apparantly pagerank is a popularity contest
11:01:56 <SamB> why do you ask?
11:02:24 <kzm_> I was wondering what the criteria for convergence are.  In particular, what happens if you tweak the dampening factor.
11:02:49 * kzm_ will be implementing in Haskell, so it is on topic.
11:02:52 <kzm_> :-)
11:03:10 <SamB> are you reading some ancient paper?
11:03:19 <SamB> if so, that one is horrible, old, and crusty!
11:03:44 <SyntaxNinja> hi Philippa
11:03:48 <kzm_> Why is that a problem?
11:03:53 <SamB> which is still better than putting your search results in no particular order, but not by a whole lot...
11:04:51 <kzm_> Oh about a few billion dollars better than nothing?
11:05:08 <syntaxfree> I really enjoy Haskell.
11:05:20 <SamB> well, not anymore it isn't
11:05:27 <kzm_> If you have better algorithms, or newer papers, by all means, I'm all ears.
11:05:47 <SamB> hmm, not really!
11:05:57 <SamB> I suppose it works as a starting point...
11:05:58 <kzm_> I don't know much about the field, really.  I was just worried that a PR-like scheme would have problems with cycles.
11:06:03 <syntaxgraduate> I mean, I really dropped programming, except for hacking up things I needed, from, say, age 10 to 23. 
11:06:22 <syntaxgraduate> and Haskell has got me back in, putting together larger and more interesting things like I  had never been able.
11:06:25 <SamB> kzm: no idea how they deal with that
11:06:38 <kzm_> I think it is theoretically sound - it converges to the principal eigen vector for the connection matrix.
11:06:51 <syntaxgraduate> Of course part of it is because Haskell is just haskell-icious, but maybe part of it is because it enforces better programming habits and techniques.
11:07:15 <SamB> in truth, I'm mostly spouting propaganda from googlewatch
11:07:16 <syntaxgraduate> I was wondering -- what lessons can I learn from  Haskell when programming in more traditiona languages like PHP?
11:07:33 <kzm_> my weak attempt at something similar just grows beyond bounds, so clearly I must do some normalization somewhere.
11:07:38 <SamB> syntaxgraduate: PHP?
11:07:44 <syntaxgraduate> yup.
11:07:47 <SamB> I don't know if we can give you application ideas for PHP...
11:08:12 <syntaxgraduate> I'm doing something different in Haskell that enables me to build things I didn't previously think I could.
11:08:23 <syntaxgraduate> I'm trying to figure out what from that is not Haskell-specific.
11:08:39 <SamB> I think its the strong typing and purity
11:09:00 <SamB> well, purity isn't exactly haskell-specific...
11:09:27 <SamB> (nor is strong typing, but that requires language support)
11:11:26 <syntaxgraduate> explain purity.
11:11:56 <SamB> lack of side-effects
11:12:27 <neologism> a nice thing about haskell is that is declarative
11:12:41 <o_Rocky> or not
11:12:51 <syntaxgraduate> that probably can't be applied in a language without first-class functions.
11:12:52 <SamB> o_Rocky: or not what?
11:13:06 <SamB> syntaxgraduate: no, likely not
11:13:08 <o_Rocky> haskell is not declarative
11:13:17 <SamB> my suggestion would be not to use PHP
11:13:29 <syntaxgraduate> as I see it, Haskell is not quite as declarative as, uh, Icon?
11:14:01 <neologism> o_Rocky: uhm?
11:14:35 <Philippa> o_Rocky: it is for most meaningful values of the word
11:14:57 <Philippa> the ones that deliberately work to exclude haskell also exclude most if not all turing complete languages
11:16:10 <SamB> heh
11:16:57 <SyntaxNinja> haskell is such a great language
11:20:02 <o_Rocky> indeed!
11:20:45 <jose_da_bicla> hi ppl
11:20:49 <SamB> haskell is what kind of great language?
11:21:49 <jose_da_bicla> can anyone tell me if there is a way to force eval_ from hs-plugins to check if a file has been changed?
11:21:50 <rep> the great kind
11:23:25 <SamB> the great kind of great language?
11:24:22 <o_Rocky> @info System.Console.GetOpt
11:24:22 <extrabot> Unknown command, try @listcommands.
11:24:30 <o_Rocky> @listcommands
11:24:30 <extrabot> use listcommands [module|command], please. Modules are:
11:24:30 <extrabot> babel base code dice dict dummy elite fact haddock help hoogle karma localtime more pl plugs poll qu
11:24:45 <SamB> what version of Haskell introduced Monads?
11:25:40 <o_Rocky> @help System.Console.GetOpt
11:25:40 <extrabot>  @help <command> - ask for help for <command>
11:25:44 <o_Rocky> lol
11:26:13 <kzm_> @index GetOpt
11:26:13 <extrabot> bzzt
11:26:17 <SamB> @doc System.Console.GetOpt
11:26:17 <extrabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
11:26:19 * kzm_ sighs.
11:36:27 <syntaxgraduate> is there published work on the efficiency of algorithms in lazy-evaluated pure-funcitonal languages?
11:38:31 <Philippa> yeah. Chris Okasaki's got some interesting data structures+algorithms for lazy langs
11:41:10 <syntaxgraduate> nice. Thanks, Philippa.
11:41:56 <Philippa> you can pretty much assume pure if you have lazy-evaluated btw - the alternative is, er, not fun
11:42:20 <Philippa> well, that or ends up looking very much like how pure languages do impure things anyway, I guess
11:42:43 <syntaxgraduate> true.
11:52:58 <o_Rocky> anyone with System.Console.GetOpt
11:52:59 <o_Rocky> 
11:53:00 <o_Rocky> ?
11:53:45 <o_Rocky> anyone familiar with System.Console.GetOpt ?
11:53:53 <syntaxgraduate> @doc Control.Monad.liftM
11:53:53 <extrabot> Control.Monad.liftM not available
11:54:36 <_SamB_> @doc Control.Monad
11:54:37 <extrabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
11:59:49 <syntaxgraduate> what would you consider "minimal" Haskell, i.e., Haskell that can't be implemented in itself?
12:00:06 <syntaxgraduate> A lot of the Prelude can be easily written in Haskell.
12:00:19 <ibid> Haskell Core?
12:00:50 <Philippa> the language (!= libs) and a subset of the IO and ST monads
12:00:57 <syntaxgraduate> hmm. So Haskell Core is well-defined.
12:01:00 <Philippa> oh, and I'm not sure about seq
12:01:03 <benny_> what about things like Integer?
12:01:08 <syntaxgraduate> @google Haskell Core
12:01:08 <extrabot> http://etudiants.insia.org/~jbobbio/pafp/docs/haskell98/
12:01:14 <Philippa> oh, and do all the desugaring
12:01:22 <Philippa> (you can tell what's sugar from the Report anyway)
12:01:23 <tic> Integer's something like Succ^n Zero, right?
12:01:47 <Philippa> tic: if and only if you don't mind having to define all the constants in terms of it
12:01:57 <Philippa> er, values-of-literals even
12:02:05 <syntaxgraduate> Haskell lacks syntax sugar for n-times application of functions.
12:02:25 <tic> Philippa, isn't that done automatically by sugaring it? As Integer is endless.
12:02:46 <ibid> syntaxgraduate: Haskell Core is basically all that the report does not define by translation to core
12:03:24 <syntaxgraduate> I see.
12:03:29 <syntaxgraduate> I can write most of the Prelude, I think.
12:03:42 <Philippa> well yes
12:03:52 <Philippa> most of it's written in Haskell directly in most implementations
12:03:55 <ibid> tic: Integer is conceptually an infinite enumeration, not iterated Succ
12:04:05 <tic> ibid, aha. thanks.
12:04:13 <Philippa> ibid: point, that matters for pattern-matching
12:05:21 <syntaxgraduate> in the only actual programming class I had, we had to use a very minimal Lisp. The whole point was that we "discovered" recursion patterns as we were faced with problems.
12:05:42 <syntaxgraduate> I keep rewriting Prelude functions because I never think they'd be predefined.
12:06:33 <SamB> syntaxgraduate: have you written foldr?
12:06:47 <syntaxgraduate> I never needed foldr.
12:07:03 <SamB> I guess you don't think of that one by yourself...
12:07:15 <syntaxgraduate> Let me try ;-)
12:07:28 <SamB> but it is really handy once you know about it
12:07:31 <syntaxgraduate> just show me an example where foldl and foldr yield different results to aid intuition?
12:07:53 <SamB> > foldl (:) [] "hello"
12:07:53 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:08:06 <SamB> hmm, bad lambdabot! bad!
12:08:11 <SamB> not @botsnack for you!
12:08:17 <SamB> er, no!
12:08:43 <syntaxgraduate> where is good ole' lambdabot? :~
12:08:54 <SamB> unsw went down again...
12:09:04 <o_Rocky> lol
12:09:16 <SamB> it does this every night when I am asleep lately, or so it seems...
12:09:21 <syntaxgraduate> > foldl (:) [] "Hello"
12:09:21 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:09:39 <SamB> anyway, that won't typecheck
12:09:49 <o_Rocky> rigth
12:10:06 <Philippa> syntaxgraduate: one's strict and thus doesn't like infinite lists
12:10:11 <syntaxgraduate> > foldl (/) [3,4,7,9]
12:10:11 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:10:16 <Philippa> (whichever one wants to access the end of the list first)
12:10:23 <Philippa> > 1+2
12:10:24 <extrabot> Terminated
12:10:34 <ibid> >2+2
12:10:41 <SamB> > 2+2
12:10:41 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:10:46 <Philippa> I think that's broken somehow
12:11:00 <SamB> I'm guessing it can't find ghc?
12:11:05 <ibid> 2+2=5, everybody who's read 1984 knows that!
12:11:10 <Philippa> syntaxgraduate: one of them doesn't do the cute definition of reverse, either
12:11:12 <ulfdoz> Ach, das sind nur drei seiten. :\
12:11:13 <SamB> heh
12:11:20 <ulfdoz> ECHAN, sorry
12:11:30 <Philippa> (the definition most people hate as horribly obscure and I like as a neat use of 'what fold does')
12:12:02 <SamB> thats a great def, I love it
12:12:11 <SamB> its more obvious than the other one ;-)
12:12:21 <Philippa> I think it should be an early example of "what fold does"
12:12:24 <ibid> i like the fold-based def of length
12:12:25 <SamB> yes!
12:12:37 <Philippa> ibid: yeah, that one's cute
12:12:39 <SamB> we should post it on the wiki at the top of the page on folds
12:12:44 <SamB> is there a page on folds?
12:13:03 <syntaxgraduate> I have a cute factorial function with a fold.
12:13:08 <Philippa> a footnote as to the chosen direction of associativity being "so it puts the [] in the right place"
12:13:13 <xerox> > let len = foldr (const (+1)) 0 in len [1..10]
12:13:14 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:13:37 <Taral> > let len = foldr (const (+1)) 0 in len [1..2]
12:13:37 <extrabot> fd:9: hClose: resource vanished (Broken pipe)
12:13:40 <Taral> weeeeird
12:13:58 <Taral> > foldr (const (+1)) 0 [1..10]
12:13:59 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:14:09 <Taral> that sucks
12:15:19 <syntaxgraduate> fact n =  (foldl (.) id [\x -> x*k | k <- [1..n]]) 1
12:15:28 <Taral> I like how lists are of type (a -> b -> b) -> b -> b
12:15:33 <Taral> @type foldr
12:15:34 <extrabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:16:20 <syntaxgraduate> > let  fact n =  (foldl (.) id [\x -> x*k | k <- [1..n]]) 1 in fact 5
12:16:20 <Taral> fact n = foldl (*) 1 [1..n]
12:16:20 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
12:16:33 <syntaxgraduate> ah, come on. Mine is much more fun!
12:16:34 <xerox> It simply needs fixing.
12:16:45 <syntaxgraduate> list of functions are fun.
12:16:55 <syntaxgraduate> I'm doing stuff with images with lists of functions.
12:18:56 <SamB> most people just use one function for a whole image...
12:20:11 <neologism> lol
12:20:15 <neologism> I saw this signature:
12:20:16 <neologism> (let ((C call-with-current-continuation)) (apply (lambda (x y) (x y)) (map
12:20:16 <neologism> ((lambda (r) ((C C) (lambda (s) (r (lambda l (apply (s s) l))))))  (lambda
12:20:16 <neologism> (f) (lambda (l) (if (null? l) C (lambda (k) (display (car l)) ((f (cdr l))
12:20:16 <neologism> (C k)))))))    '((#\J #\d #\D #\v #\s) (#\e #\space #\a #\i #\newline)))))
12:20:22 <neologism> thats insane :)
12:22:20 <o_Rocky> fac = hyloRList (either (const 1) mul) nats
12:22:32 <SamB> that is an awful lot of work just to print his name...
12:22:49 <o_Rocky> this version of factorial is cute
12:23:17 <sieni> neologism: something like the one on my home page, I guess: http://www.hurmio.org/~ville
12:23:26 <SamB> this page looks sad:
12:23:34 <SamB> @wiki WhatIsaFold
12:23:34 <extrabot> http://www.haskell.org/hawiki/WhatIsaFold
12:24:28 <neologism> sieni: nice ;0
12:25:15 <sieni> unfortunately it uses many non-portable features
12:34:08 <syntaxgraduate> @wiki lambdabot
12:34:08 <extrabot> http://www.haskell.org/hawiki/lambdabot
12:34:27 <syntaxgraduate> does @wiki just prepend http://www.haskell.org/hawiki to text?
12:35:35 <chucky> @wiki veryimprobabletoexist
12:35:36 <extrabot> http://www.haskell.org/hawiki/veryimprobabletoexist
12:35:45 <chucky> apparently yes. :)
12:36:16 <SamB> syntaxgraduate, chucky: no! it actually prepends http://www.haskell.org/hawiki/
12:36:53 <xerox> wiki = ("http://www.haskell.org/hawiki"++)
12:38:13 <syntaxgraduate> For compiling with profiling on, or to compile a static binary (obviating the need for hs-plugins!), try
12:38:20 <syntaxgraduate> where?
12:38:45 <syntaxgraduate> I won't be needing @eval or @lambda, it's an ordinary irc channel. So I thought I could in fact obviate the need for hs-plugins where it ends up running.
12:39:15 <SamB> syntaxgraduate: modules are still nice...
12:39:28 <syntaxgraduate> hmm.
12:39:30 <SamB> and I have no idea how to compile it without these days
12:39:46 <SamB> @lambda
12:39:46 <extrabot> Unknown command, try @listcommands.
12:40:52 <syntaxgraduate> I wonder if there's a Linux livecd with Haskell.
12:41:17 <SamB> what is http://www.haskell.org/hawiki/LocalSpellingWords for?
12:41:18 <syntaxgraduate> Hey, would anyone compile lambdabot on Linux/x86 and send me binaries? I don't have a linux box here, and I need to run it on a remote site where I don't have ghcl.
12:42:26 <Taral> wiki (x:xs) = "http://www.haskell.org/hawiki"++(toUpper x : xs)
12:42:39 <Taral> @pl \(x:xs) -> "http://www.haskell.org/hawiki"++(toUpper x : xs)
12:42:40 <extrabot> ap ((("http://www.haskell.org/hawiki" ++) .) . (:) . toUpper . head) tail
12:42:44 <Taral> O.o
12:43:06 <syntaxgraduate> @wiki What does it do with spaces and interrogation marks?
12:43:06 <extrabot> http://www.haskell.org/hawiki/What does it do with spaces and interrogation marks?
12:43:12 <Taral> he
12:43:13 <syntaxgraduate> oh jesus.
12:43:20 <syntaxgraduate> it can  be easily improved with words/unwords.
12:43:33 <syntaxgraduate> if I just could get lambdabot to run on my mac, it'd be seeing quick improvement.
12:43:35 <Taral> or even just a straight port of the wiki link encoder
12:44:49 <SamB> syntaxgraduate: well, pages with spaces and question marks in the names are discouraged
12:45:10 <syntaxgraduate> I'd like "This text here" converted to "ThisTextHere".
12:45:23 <syntaxgraduate> it's the natural way to name MoinWiki pages.
12:45:36 <benny_> is anyone here by any chance familiar with cheetahtemplate?
12:45:59 <jethr0> filter isAlpha $ unword $ map (\(x:xs) -> toUpper x:xs) $ words ls
12:46:12 <syntaxgraduate> I once made a cheetah/tiger-themed powerpoint template for somene.
12:46:39 <syntaxgraduate> in exchange of a marginal increase in the small probability of obtaining sexual favors in some distant point in the future. Jesus, was I a stupid teenager.
12:46:46 <benny_> syntaxgraduate: what do you think about doing a clone of cheeatah but for haskell instead of python?
12:46:59 <benny_> oh wait, i just now got what you said
12:47:00 <syntaxgraduate> I don't know what cheetahtemplate is.
12:47:14 <benny_> nerd
12:47:30 <syntaxgraduate> [o | o] :)
12:48:20 <benny_> btw you guys remember i was here like 2 weeks ago complaining that i can't get past page 1 in my category theory book?
12:50:53 <Taral> did you get to page 2?
12:51:27 <benny_> no
12:51:29 <benny_> i got another book
12:52:09 <benny_> this one has a few introductory chapters about what i think is set theory
12:52:45 <yaarg> ahaha, yes that would help!
12:52:46 <benny_> and i got through a few pages and even managed to do some of the excersices(i think), but then he starts using all these terms that i don't understand
12:53:06 <Lor> funny, as category theory is one of the few branches of mathematics that cannot be explained in terms of set theory
12:53:26 <yaarg> indeed
12:53:37 <astrolabe> But it is a good idea to learn set theory first.
12:53:39 <Philippa> It can be informally so though, which right at the start Pierce's book does
12:53:58 <Philippa> "start with a (naive) set of objects and one of arrows..."
12:53:59 <astrolabe> what terms benny?
12:53:59 <yaarg> hrm
12:54:04 <benny_> pierce's book, "Basic Category THeory for Computer Scientists"?
12:54:07 <Philippa> yep
12:54:14 <benny_> Philippa: that's the one where i couldn't get past page 1
12:54:35 <Philippa> if it helps any, I know enough set theory to be dangerous and it still took me a year plus to get round to reading it properly. I still need to do exercises properly sometime
12:54:43 <astrolabe> Anyway, I always pretend my categories are 'small' categories.
12:55:13 * yaarg is currently working is way through barendregt's 'the lambda calculus'
12:55:18 * Lor wishes it would get out of print so bcp could (if he would) release it on the net.
12:55:28 <astrolabe> As long as I don't think about barbers I'm fine.
12:55:32 <Lor> yaarg, argh. How are you doing?
12:55:37 <yaarg> Lor: argh!
12:55:42 <Lor> Thought so. :)
12:56:38 <Lor> Is there anyone here who has actually read and grokked the whole thing? What does it really offer to the reader?
12:57:35 <Philippa> Lor: er... semi-grokked. I got to the point where I was starting to visualise some non-trivial stuff but I don't know how much the exercises gave me. I don't think it would've eg allowed me to read off the CT definition of 'monad' into semi-practical terms talking about languages and semantics thereof though
12:57:41 <Philippa> not without further insight
12:57:59 <Lor> No, I mean Barendregt's lambda bible.
12:58:02 <Philippa> ah
12:58:04 <Philippa> not read
12:58:15 <Philippa> is that available online?
12:58:20 <Lor> Nope.
12:58:27 <Lor> And it's bloody fucking expensive.
12:58:29 <Philippa> bah
12:58:33 <basti_> hi all
12:58:48 * yaarg has a library copy :)
12:58:49 <astrolabe> hi basti
12:59:22 <yaarg> I really need to get hold of the prerequisite books too
12:59:26 <SamB> maybe set theory makes a good example category?
12:59:43 <Philippa> SamB: several set-theoretic categories're used as examples
12:59:50 <Lor> I remember having a look at it once or twice, but it started off by defining models of lc as non-hausdorffian topological spaces or something like that, and went beyond my head pretty quickly.
13:00:01 <Lor> I now a bit more topology now, though.
13:00:04 <Philippa> CPOs and whichever class function on it gives you a useful denotational semantics, for example
13:00:20 <Philippa> ah. Not worth my while reading just yet, then
13:00:28 <Oejet> boegel|home: Good evening.
13:00:32 <boegel|home> Oejet: hey
13:00:54 <Lor> To my understanding, the topological sidenote was pretty irrelevant, it just served to confuse the reader.
13:30:13 <SamB> @listcommands darcs-patch-watch
13:30:14 <extrabot> No module "darcs-patch-watch" loaded
13:30:28 <SamB> @listmodules
13:30:28 <extrabot> babel base code dice dict dummy elite fact haddock help hoogle karma localtime more pl plugs poll qu
13:31:24 <bringert> I'm working on getting HaskellDB's dynamic driver loading working again, I'm getting this error: SQLite.o: unknown symbol `GHCziBase_unpackCStringzh_info'
13:31:52 <bringert> when trying to load SQLite.o with hs-plugins, current darcs version
13:32:06 <bringert> dons: any ideas?
13:32:21 <bringert> I haven't used hs-plugins for a long time
13:32:34 <SamB> GHC.Base.unpackCString# is used to implement string literals
13:32:40 <SamB> it is in GHC.Base, which is in the "base" package
13:32:58 <bringert> shouldn't hs-plugins load that automatically?
13:34:12 <SamB> you'd think!
13:34:40 <astrolabe> Does "the type system ... permits not only parametric polymorphism (using a traditional Hindley-Milner type structure) but also ad hoc polymophism, or overloading (using type classes)' imply that simply having multiple data constructors for a type is not considered polymorphism?
13:34:55 <SamB> does it work in ghci?
13:35:14 <bringert> you mean loading the .o-file in ghci?
13:36:16 <Philippa> astrolabe: pretty much
13:36:36 <Philippa> it doesn't allow you to trivially add new constructors without large amounts of code breaking
13:37:10 <Philippa> polymorphism is what you do when switch statements or pattern-matching doesn't scale
13:37:46 <astrolabe> Ah, ok. Thanks. I'll think about that.
13:38:31 <SamB> yes
13:39:10 <SamB> astrolabe: yes!
13:39:14 <SamB> thats called multiplication or some such, iirc
13:40:39 <boegel|home> astrolabe: yo (check pm)
13:40:52 <bringert> SamB: it was my fault, compiled the module the wrong way
13:40:55 <bringert> thanks
13:40:56 <astrolabe> There are so many options in haskell.  I find it hard to get them all lined up with their proper uses.
13:41:18 <astrolabe> boegel: you mean you can't see my replies?
13:42:34 <SamB> Philippa: or when what you want is polymorphism...
13:43:12 <astrolabe> SamB: So what IS polymorphism here?
13:43:13 <Philippa> astrolabe: IME most of them boil down to "completely type-agnostic" or "wants any type conforming to this" - parametric polymorphism for the former, constrainted parametric polymorphism (aka typeclasses) for the latter
13:43:30 <syntaxgraduate> What I find odd is that the channel and network and owners of lambdabot have to be chosen before you compile it!
13:43:37 <Philippa> SamB: well yeah. But you want polymorphism because you want to handle many cases without stating exactly how to cope with each
13:44:24 <Philippa> syntaxgraduate: that is odd. Patch it to take a Maybe type and not connect unless they're filled in?
13:44:32 <boegel|home> astrolabe: I can't, no... strange
13:45:06 <boegel|home> astrolabe: you'r not identified, that's why...
13:45:20 <boegel|home> s/you'r/you're
13:45:26 <astrolabe> Oh bloody thing!
13:45:50 <boegel|home> astrolabe: you can set client client to identify automatically you know :)
13:47:07 <astrolabe> what is the name of the name server again?
13:47:13 <boegel|home> nickserv
13:47:18 <boegel|home> astrolabe: what client are you using ?
13:47:23 <boegel|home> *which
13:47:37 <astrolabe> trillian
13:47:59 <boegel|home> can't you set a nickserv password in it ? that way you'll get identified automatically
13:48:20 <Axioplase> Hi
13:48:28 <boegel|home> hi Axioplase 
13:48:30 <astrolabe> I don't know.  It's all flashing lights and buttons to me.
13:48:48 <boegel|home> astrolabe: which OS ?
13:49:14 <astrolabe> windows of course.  Is there any other?   ;)
13:49:21 <boegel|home> 0_o
13:50:00 <boegel|home> wake up and smell the coffee... try GNU/Linux, it convinced me easily
13:50:40 <Philippa> I'm still windows-based, but happily convinced GNU/Linux is a fair alternative for most purposes
13:50:53 <astrolabe> I like games though.  Also, I can't be bothered to hack around with things that don't interest me, and I get the impression windows works better out of the box.
13:50:59 <boegel|home> Philippa: I get _far_ more work done using Linux
13:51:15 <boegel|home> astrolabe: Linux has matured in a great way the last few years
13:51:25 <Philippa> boegel: I didn't say there wasn't a minority where it's better, did I? :-)
13:51:33 <boegel|home> I tried it when I started uni, and switched back
13:51:42 <boegel|home> when I tried it again 3 years later, I was amazed
13:51:43 <Philippa> I wouldn't run any class of non-toy server on it, nor most classes of toy server
13:51:52 <syntaxgraduate> Mac OS X is a fair alternative for all purposes.
13:52:06 <SamB> syntaxgraduate: yes, that is quite odd.
13:52:07 <boegel|home> syntaxgraduate: I agree, that's why I'm saving for a PowerBook
13:52:11 <Philippa> not for gaming at present, it's lacking software
13:52:25 <syntaxgraduate> it's called VMWare ;-)
13:52:34 <boegel|home> with Mac OS X you have Unix (BSD), 1337 graphics and everything works on your system, the full deal
13:52:34 <syntaxgraduate> ops. on the Mac it's called Virtual PC.
13:52:41 <SamB> syntaxgraduate: I thought that was going to be *fixed*!
13:52:45 <Philippa> it's also called slow as fuck and no proper support for current 3d games if we're talking about VMWare
13:52:48 <astrolabe> But there is just more software for windows, isn't there?
13:52:50 <syntaxgraduate> and you have word/excel/powerpoint.
13:53:01 <boegel|home> astrolabe: hmm, I'd doubt it
13:53:06 <syntaxgraduate> What killed Linux for me was insufficient OOo support of Word documents.
13:53:12 <syntaxgraduate> I have to work  with the rest of the world.
13:53:35 <boegel|home> syntaxgraduate: OO has matured too, I can read most of the *.doc files I recieve without problems
13:53:46 <boegel|home> syntaxgraduate: you should try communicating using PDF ;)
13:54:13 <syntaxgraduate> It doesn't properly open equations.
13:54:30 <syntaxgraduate> and, you know, I cant just ask people to learn latex.
13:54:36 <twb> Why not?
13:54:57 <boegel|home> syntaxgraduate: there a good package for TeX for Windows, TexnicsCenter or something
13:54:59 <SamB> windows may *operate*. but where is the *system*?
13:55:04 <boegel|home> no need to learn latex using that
13:55:17 <syntaxgraduate> that's an editor. you still have to learn latex.
13:55:20 <syntaxgraduate> there's LyX.
13:55:21 <boegel|home> btw, using equations in Word just sucks
13:55:32 <boegel|home> I tried it once, it was horrific
13:55:33 <twb> boegel|home: damn straight
13:55:42 <SamB> astrolabe: windows comes in a box?
13:55:42 * Philippa uses LaTeX
13:55:44 <syntaxgraduate> but, still, I can't persuade people to learn new software because I want to be the black sheep and use a strange platform.
13:55:49 <SamB> how quaint!
13:55:50 <twb> Is there an X11 protocol library for haskell, or do people just use xlib via ffi?
13:55:51 * boegel|home does too
13:55:52 <Philippa> SamB: non-OEM versions do
13:55:58 <Axioplase> Hum... I have a list of (Double,Double) which I want to print each "d1 d2\n" on stdout. I managed to get it compile with no type error, but then, it prints nothing...
13:56:13 <boegel|home> syntaxgraduate: using Windows is no excuse for not using LaTeX if you're doing scientific work
13:56:20 <twb> Axioplase: you need to instantiate the Show class, IIUC
13:56:20 <Philippa> Axioplase: are you expecting show to display something?
13:56:27 <syntaxgraduate> oh, yes it is.
13:56:29 <astrolabe> boegel: yes it does suck!
13:56:32 <syntaxgraduate> even in equation-heavy fields.
13:56:35 <boegel|home> Axioplase: you should paste your code, that way we can help you
13:56:41 <joelr1> howdy
13:56:54 <Philippa> 'lo joel
13:56:56 <boegel|home> @paste
13:56:56 <extrabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:57:12 <joelr1> is there a way to derive Show for this data Foo = Foo | Show a => Bar a without defining show ... for each constructor?
13:57:13 <boegel|home> astrolabe: what sucks ? (and are you identified already ? :) )
13:57:21 <Axioplase> boegel|home: yes. wait.
13:57:27 <SamB> Philippa: wouldn't run servers on windows, or on linux?
13:57:39 <Philippa> on windows
13:57:45 <joelr1> i just spent most of the day chasing what i thought is a cool concurrency bug. turns out i'm an idiot :(
13:57:49 <Philippa> I use windows, but I'm not what you'd call a fan
13:58:03 <Philippa> joelr1: ah well, can't get 'em every time
13:58:12 <twb> I haven't met a Windows user in years that does so willingly.
13:58:21 <Axioplase> boegel|home: http://rafb.net/paste/results/fXNs2X82.html
13:58:24 <boegel|home> joelr1: it turns out that way almost every time for me
13:58:25 <twb> It's always because some legacy application is only available for Windows.
13:58:27 <Philippa> I'll trade you the bug I ran into in the win32 RTS the first time I tried writing an IRC client using wxhaskell and concurrency?
13:58:37 <Philippa> twb: I wouldn't describe games as 'legacy'
13:58:38 <joelr1> ?
13:58:41 <astrolabe> boegel: I'm identified, I hope.  And equations in Word suck.
13:59:10 <Philippa> joelr1: file under "cool" concurrency bug - there was a memory leak
13:59:36 <boegel|home> Axioplase: why the "return 0" ?
13:59:49 <astrolabe> sounds like C
13:59:52 <joelr1> Philippa: yeah, memory leaks forever. just reduced memory consumption by about 20 times :D
13:59:55 <joelr1> data Foo a = Foo | Show a => Bar a
13:59:55 <joelr1> instance Show a => Show (Foo a) where
13:59:55 <joelr1>     show (Foo a) = show a
13:59:55 <joelr1>     show x = show x
14:00:02 <joelr1> this is my repro case :D
14:00:09 <Philippa> twb: I do also suffer UI lockin and a substantial allergy to emacs's UI and the likes without major alteration
14:00:37 <joelr1> looked like a classic one guy thinks the MVar is full and blocks and the other one blocks because he thinks it's empty 
14:00:53 <Axioplase> boegel|home:  I once needed this code to have an expression as last instruction...
14:03:43 <SamB> twb: most people use GUI toolkits, not xlib
14:04:18 <boegel|home> print x is an expression
14:04:30 <SamB> Philippa: all the good games are legacy, dontcha know?
14:04:36 <boegel|home> Axioplase: you might have had a indentation problem before, it looks fine now
14:04:52 <Axioplase> boegel|home: all I want is a kind of printf "%f %f\n" a b
14:05:15 <boegel|home> Axioplase: looks fine... try removing the return 0, there's no need for it
14:05:23 <boegel|home> if you have an error, we'll solve it otherwise
14:05:36 <Axioplase> boegel|home: what I get is ["1 2\n","1 4\n",...] (with the "\n" as two chars)
14:05:39 <Philippa> SamB: maybe. Much as UFO:Enemy Unknown rocked, UFO:Aftershock's still worth playing
14:05:40 <SamB> Axioplase: and printf "%f %f\n" a b didn't work why?
14:05:58 <Axioplase> SamB: there is printf ?
14:06:04 <Axioplase> dammit :)
14:06:12 <boegel|home> Axioplase: oooooh
14:06:13 <boegel|home> :)
14:06:17 <xerox> Goodnight.
14:06:34 <boegel|home> @eval show "2\n"
14:06:34 <extrabot> fd:7: hClose: resource vanished (Broken pipe)
14:06:36 <SamB> Axioplase: the types are so complicated they'll give you a headache if you try to figure them out, but yes ;-)
14:06:38 <boegel|home> meh :s
14:06:41 <SamB> @index printf
14:06:41 <extrabot> Text.Printf
14:06:51 <xerox> @type Text.Printf.printf
14:06:52 <extrabot> forall r.
14:06:52 <extrabot>         (Text.Printf.PrintfType r) =>
14:06:52 <extrabot>         String -> r
14:07:00 <boegel|home> Axioplase: use this ^
14:07:07 <xerox> @kind Text.Printf.PrintfType
14:07:08 <extrabot> Class `Text.Printf.PrintfType' used as a type
14:07:11 <joelr1> so is there a nice way to derive Eq and show for this?
14:07:12 <joelr1> data State a
14:07:12 <joelr1>     = Start
14:07:12 <joelr1>     | Stop
14:07:12 <joelr1>     | (Show a, Eq a) => State a
14:07:16 <xerox> Uops.
14:07:24 <joelr1> apart from 
14:07:24 <joelr1>     Start == Start = true
14:07:25 <joelr1>     Stop == Stop = true
14:07:32 <SamB> xerox: yeah, I think it should do @kind on classes also
14:07:39 <SamB> but GHCi won't do it either
14:08:08 <xerox> There are multi-parameter typeclasses, but it's noticeable.
14:08:18 <xerox> ...anyway, 'night
14:09:16 <SamB> but, what kind of types do they take?
14:11:09 <Axioplase> SamB: it doesn't work with:  Ambiguous type variable `b' in the constraint: `PrintfType b' arising from use of `foo'
14:11:49 <Axioplase> (hum.. a and b are Integers in fact... I try to print them with %d)
14:11:55 <SamB> Axioplase: it can't infer the result type
14:12:01 <SamB> tell it :: String
14:12:54 <SamB> at least, I think thats the problem
14:13:45 <Axioplase> SamB: SamB well... it comiles but does not print anything
14:14:26 <SamB> Axioplase: oh, it just formats the string...
14:14:57 <SamB> or I think you could use it at type IO ()
14:15:06 <Axioplase> ha.. so I putStr (printf "%u %u\n" a b) ? 
14:15:45 <Axioplase> (no I don't...)
14:17:07 <SamB> Prelude Text.Printf> printf "%u %u\n" (1 :: Integer) (2 :: Integer) :: IO () 
14:17:07 <SamB> 1 2
14:19:03 <Axioplase> SamB: not better... bacause I'm mapping this func to the list maybe ?
14:20:54 <SamB> Axioplase: what do you get now?
14:22:02 <Axioplase> SamB: nothing at all. the program just returns
14:22:27 <SamB> Axioplase: well, what does it look like?
14:22:34 <SamB> the code, I mean
14:23:34 <Axioplase> SamB: http://rafb.net/paste/results/LYH9o795.html
14:27:08 <SamB> Axioplase: the problem there is that you aren't sequencing "bar"
14:27:26 <Axioplase> SamB: which means?
14:27:38 <SamB> none of the IO values in it get run...
14:27:56 <Axioplase> Ha??
14:28:52 <SamB> you have to sequence every action you want to happen
14:28:54 <Axioplase> ok. I got it.
14:29:02 <Axioplase> indeed. thanks..
14:29:38 <SamB> this ought to work: http://rafb.net/paste/results/QMpHMQ36.html
14:29:54 <Axioplase> I got it working by just replacing the putStr by "sequence bar"
14:30:12 <SamB> well, yeah, that works too
14:30:38 * SamB is glad he used a word that is also an appropriate function...
14:31:10 <SamB> mapM does the map and the sequence in one fell swoop ;-)
14:31:39 <Axioplase> I just read your paste. I'll do that. thanks a lot.
14:31:50 <glauber_sp> hi guys. Is there any paper that compares lisp, haskell, scheme and may others? I want to learn one of them but I don't know which one to choose.
14:31:50 <SamB> you are much welcome
14:32:06 <Philippa> glauber_sp: if you want a static type system, you want Haskell rather than Scheme
14:32:16 <Philippa> if you want lazy evaluation, you want Haskell rather than Scheme
14:32:23 <SamB> lisp is too long. scheme is too short. haskell is too easy.
14:32:28 <Philippa> if you want macros and fun stuff like that, you probably want Scheme
14:32:47 <Philippa> (note: values of "fun" may involve masochism)
14:32:54 <glauber_sp> ahah =)
14:32:58 <Pseudonym> If you want caustic arrogance, Scheme is also useful.
14:33:04 <yaarg> ml?
14:33:06 <Axioplase> glauber_sp: try Ocaml.
14:33:16 <Philippa> I can do caustic arrogance all on my own thankyouverymuch
14:33:18 <SlowByte> Pseudonym: wasn't that Common Lisp? ;)
14:33:26 <glauber_sp> yaarg, ml is another one I'm thinking
14:33:29 <Pseudonym> SlowByte: Any Lisp family member will do.
14:33:41 <Philippa> Common Lispers're the worst
14:33:49 <Philippa> I mean, who else insists they have the One True Lisp?
14:33:52 <Pseudonym> You're probably right about that.
14:34:04 <SamB> Philippa: hmm, people who talk funny?
14:34:22 <yaarg> glauber_sp: i wouldn't take other people's word, just trying writing something in each of them
14:34:30 <Philippa> no, they have the One True Lithp
14:34:47 <Pseudonym> Schemers have the More Beautiful Lisp.
14:35:02 <Philippa> nonono, they have the Less Ugly Lisp
14:35:26 <Axioplase> (let (me) (laugh ! !))
14:35:33 <glauber_sp> yaarg, I wanted to know if there was a place that compare these languages, like evaluating type, pure functional or not and so on
14:35:34 <Guest55514> L.U.B.S.N.V.N.L.L.
14:36:01 <Philippa> glauber_sp: Haskell's the only purely functional one you've listed
14:36:04 <SamB> are you implying that lisps are typed?
14:36:12 <Pseudonym> Lisps are dynamically typed.
14:36:15 <glauber_sp> Philippa, there is ML too, right?
14:36:21 <Lor> Not this one again..
14:36:28 <Philippa> glauber_sp: all the practical MLs are impure
14:36:31 <SamB> well, DSSSL is purely functional
14:36:34 <yaarg> glauber_sp: you could trawl through LtU
14:36:38 <yaarg> archives
14:36:40 <Philippa> except insofar as you can call Haskell an ML...
14:36:51 <Philippa> (it has one in its heritage, certainly)
14:37:06 <Pseudonym> It split off a long, long time ago.
14:37:06 <Lor> That's like calling Java a C.
14:37:15 <Axioplase> What I do like with ocaml, is that "let foo x y = x+y" can be applied as "foo 1 2" as well as "(foo 1) 2"...
14:37:16 <SamB> Philippa: what? you can single ought a particular ML as an ancestor of Haskell?
14:37:18 <Pseudonym> ML is circa 1976.  KL1, which is a more direct ancestor, was around 1980.
14:37:48 <Philippa> SamB: IIRC one of the guys involved in the original design had worked on a Lazy ML?
14:37:50 <Pseudonym> Or was it KL-ONE?
14:38:28 <Pseudonym> Ah, KRC.
14:38:41 <Pseudonym> KRC is circa 1982.
14:38:48 <SamB> I think hbc was written in Lazy ML
14:38:50 <Pseudonym> Oh!
14:38:53 <Pseudonym> I tell a lie!
14:38:59 <Pseudonym> SASL is circa 1976.
14:39:16 <Pseudonym> So actually, Haskell might not be a descendent of ML.  It might just be a cousin.
14:39:40 <Pseudonym> Because SASL directly descends from ISWIM.
14:40:09 <Pseudonym> ISWIM -> SASL -> KRC -> Miranda -> Haskell
14:40:14 <SamB> did ISWIM also spawn the short-lived ISINK?
14:40:20 <Pseudonym> Miranda is KRC with an ML-ish type system.
14:40:32 <yaarg> yes
14:40:43 <SamB> yes to what?
14:40:49 <Pseudonym> So no, Haskell is NOT an ML.
14:40:54 <yaarg> yes
14:41:06 <yaarg> yes Haskell is not an ML ad Miranda is KRC...
14:42:55 <Pseudonym> ISWIM was a predecessor of DWIM.
14:43:06 <SamB> Do What I Mean?
14:43:10 <Pseudonym> :-)
14:43:15 <Pseudonym> ISWIM == If you See What I Mean
14:44:09 <SamB> okay, lambdabot is revived.
14:44:27 <SamB> somebody kick/quit extrabot
14:44:33 <SamB> @seen extrabot 
14:44:34 <extrabot> Yes, I'm here. I'm in #ScannedInAvian, #flippi, #haskell-blah, #haskell-overflow and #haskell
14:44:34 <lambdabot> extrabot is in #ScannedInAvian, #haskell-overflow, #flippi, #haskell-blah
14:44:34 <lambdabot> and #haskell. Last spoke 44 seconds ago.
14:44:39 <Axioplase> How can I force Haskell to actually apply a function ?
14:44:43 <dons> for the 2nd night in a row, unsw got kicked off the net. bad bad.
14:44:54 <SamB> dons: only the second?
14:44:55 <dons> extrabot: @quit
15:07:08 <bringert> in hs-plugins, is there a way to load a package, and they look up a function in a module in that package?
15:07:13 <bringert> s/they/then/
15:07:16 <shapr> dons: Hey, do you have any examples of HUnit used to test IO functions?
15:07:36 <Axioplase> hum... I have a and b beeing Integers. How can i get ((a-b)/10000) ? It complains about Franctionnal integers. I just want the quotient..
15:07:49 <bringert> I want to load the package by package name, and not have to use any paths to object files etc.
15:08:23 <bringert> I tried "loadPackage package >> loadFunction_ module function, but it doesn't seem to work
15:10:35 <dons> shapr, sure: 
15:10:37 <dons>  testElems = do
15:10:37 <dons>         b <- newB "testbuffer" contents :: IO FBuffer
15:10:37 <dons>         s <- elemsB b
15:10:37 <dons>         assertEqual s contents
15:10:41 <dons> from yi
15:11:29 <bringert> dons: is there a way in hs-plugins to find a function given just package name, module name, and function name?
15:11:43 <bringert> i.e. without any paths to object files etc.
15:11:59 <dons> ah. you want to get a function out of a package?
15:12:04 <bringert> yes
15:12:10 <dons> this can be done, yes. let me see..
15:12:41 <dons> loadFunction_ ?
15:13:01 <bringert> I tried that
15:13:13 <bringert> Looking for <<DatabaseziHaskellDBziHSQLziSQLite_driver_closure>>
15:13:16 <bringert> but fails
15:13:47 <bringert> I called it as loadFunction_ "DatabaseziHaskellDBziHSQLziSQLite" "driver"
15:14:14 <bringert> after calling loadPackage "haskelldb-hsql-sqlite"
15:15:07 <bringert> I get the impression that the module needs to be loaded first, but can't find a way to do that
15:15:25 <dons> that seems ok. hmm, does it help to explicitly call resolveObjs after the loadPackage?
15:15:53 <dons> yes, you need to call resolveObjs
15:16:01 <dons> from hIDe:
15:16:02 <dons>                       -> do loadPackage pkgName
15:16:03 <dons>                             resolveObjs (unloadPackage pkgName)
15:16:03 <dons>                             status <- loadFunction_ (encode pluginMod) symbol
15:16:23 <bringert> why the unloadPackage?
15:16:40 <dons> resolveObjs takes a function to call in the event resolutoin fails
15:16:55 <bringert> ah
15:18:20 <Pupeno> can a function not get its parameters evaluated to process them in some way (like lisp macros), for example: blah (4 + 4), blah getting (4 + 4) instead of 8.
15:18:22 <Pupeno> ?
15:18:56 <shapr> Template Haskell has that sort of first class parse tree value.
15:19:06 <dons> not withut a metaprogramming extension
15:19:16 <dons> look at TH
15:19:53 <dons> > :t [| 4 + 4 |] 
15:19:53 <dons> [| 4 + 4 |] :: (Language.Haskell.TH.Syntax.Quasi m) =>
15:19:53 <dons>                m Language.Haskell.TH.Syntax.Exp
15:19:54 <lambdabot>  parse error on input `:'
15:20:08 <dons> > $( [| 4 + 4 |] )
15:20:08 <dons> 8
15:20:08 <lambdabot>  parse error on input `$'
15:20:29 <dons> so Pupeno, if you really want to manipluate syntax trees, TH is the way to go.
15:20:43 <Pupeno> dons: thanks!
15:20:56 <bringert> dons: this is what I've got now:
15:21:02 <bringert>     loadPackage pkgName
15:21:02 <bringert>     resolveObjs (unloadPackage pkgName)
15:21:02 <bringert>     loadFunction_ (encode moduleName) "driver"
15:21:11 <bringert> but it still fails
15:21:21 <bringert> is there anything I can do to debug it?
15:21:31 <bringert> do I need to do anything before this code?
15:21:34 <Pupeno> I'll look into it after my 4-days vacations that'll start in an hour.
15:21:49 <dons> have you compiled hs-plugins with -DDEBUG ?
15:22:07 <bringert> yes
15:22:24 <bringert>  haskelldb-hsql-sqlite []Looking for <<DatabaseziHaskellDBziHSQLziSQLite_driver_closure>>
15:22:33 <dons> manually check that the symbol exists exactly where you think it does, using `nm'
15:22:50 <dons> and that the name hs-plugins guesses is correct
15:23:35 <dons> check that it is loaded (you could add some debug stsmts to loadPackage)
15:27:31 <bringert> how do I check what packages are loaded?
15:29:23 <dons> other than by looking at the debug stmts?
15:30:46 <bringert> hmm, dunno. I'm looking  at the " haskelldb-hsql-sqlite []" I showed above
15:31:05 <bringert> looking at the code for loadPackage it looks like "dlls" is []
15:31:07 <Axioplase> How can I ask Haskell to *do* evaluate an application? I need it to know how long it takes for a bench
15:31:18 <musasabi> seq
15:31:28 <musasabi> but that is not deep.
15:31:51 <Axioplase> not deep?
15:33:14 <musasabi> > [error "foo"] `seq` ()
15:33:15 <lambdabot> ()
15:33:21 <musasabi> > error "foo" `seq` ()
15:33:22 <lambdabot> foo
15:33:48 <musasabi> dons: lambdabot has a bug with error.
15:34:01 <bringert> dons: ok, I printed the values of "libs" in loadPackage, it seems to be empty
15:34:28 <bringert> and so is "dlls"
15:34:36 <bringert> does this mean nothing is loaded?
15:34:52 <Axioplase> musasabi: I want to evaluate eC in http://rafb.net/paste/results/9NaT8C46.html but I don't need the result. I just eC `seq` () ?
15:35:09 <Axioplase> type error :/
15:35:15 <dons> bringer,t that would mean that your package isn't found in the package database
15:35:29 <dons> you're saying lookupPkg returns nothing?
15:35:36 <dons> musasabi, a bug with error?
15:35:44 <musasabi> > error "foo"
15:35:45 <lambdabot> Add a type signature
15:35:48 <bringert> yes, it returns ([],[])
15:35:52 <musasabi> > error "foo" :: ()
15:35:53 <lambdabot> foo
15:36:02 <shapr> bringert: I'm doing partial application of XmlRpc.Client.remote to put the auth info and base url in only one place. Any idea why that would cause an error like " Couldn't match `[Char]' against `Char' Expected type: [[Char]] Inferred type: [Char] In the application `remoteAuth "proto/ping"' ?
15:36:05 <dons> what error?
15:36:19 <musasabi> dons: it doesn't say an error has happened.
15:36:29 <dons> oh, the error is just printed.
15:36:32 <shapr> bringert: If I use 'remote fullbaseurl' in place of the partially applied remoteAuth, it works fine.
15:36:36 <musasabi> think about > error "()" `seq` ()
15:36:36 <bringert> dons: I tried loadPackage "readline", lookupPkg also returns ([],[])
15:36:45 <bringert> shapr: strange
15:37:01 <dons> bringert, what does ghc-pkg say about what packages are installed?
15:37:22 <dons> musasabi, you think this is a bug?
15:37:27 <dons> because it could be confusing?
15:37:32 <shapr> The Client.Remote typeclass isn't exported, so I can't try to force the typesignature.
15:37:57 <bringert> dons: thanks, that was it. stupid me. I should have included the verion number in the module name
15:38:04 <bringert> *version*
15:38:09 <dons> ah!
15:38:14 <bringert> sorry, package name
15:38:22 <dons> oh, that would help :)
15:38:24 <musasabi> dons: more like a feature request.
15:38:47 <musasabi> it is confusing to not see straight away that an error has happened.
15:38:54 <bringert> dons: it would be nice not to have to include the version number
15:39:16 <bringert> shapr: can I see your code?
15:39:25 <bringert> phone
15:39:30 <dons> ok. i'll fix it so it prtints :Exception *** foo
15:39:44 <shapr> bringert: sure
15:39:55 <dons> bringert, this is a feature since Cabal switched over to versioned libs.
15:40:02 <dons> probably should resolve them somehow
15:44:49 <Axioplase> I still can't evaluate my function without using it's result...
15:45:11 <dons> Axioplase, what are you trying to do?
15:45:26 <Axioplase> dons: benchmark a function.
15:45:30 <dons> eval something as a side effect?
15:45:42 <Axioplase> dons: I'm getting time, calling the func, getting time, printing the time diff 
15:45:59 <dons> ah. you'd need seq or deepSeq, I think
15:46:14 <shapr> bringert: Um, boiling the code down to the smallest possible error seems to have fixed it...
15:46:18 * shapr is confused
15:46:32 <Axioplase> dons: it's eC I want to bench at http://rafb.net/paste/results/9NaT8C46.html
15:46:46 <bringert> dons: maybe loadPackage should fail if the package wasn't found? that would have helped me find the problem faster
15:46:53 <dons> Axioplase, here's some code for you:
15:46:54 <dons> time :: (MonadIO m) => LogLevel -> String -> m a -> m a
15:46:54 <dons> time level s a = do
15:46:54 <dons>         start <- liftIO $ getCPUTime
15:46:54 <dons>         v <- a
15:46:56 <dons>         end   <- liftIO $ getCPUTime
15:46:59 <dons>         let diff = (fromIntegral (end - start)) / (10^12)
15:47:02 <dons>         liftIO $ log_ unknownLocation level
15:47:04 <dons>                    ("Computation time for " ++ s ++ ": " ++ (show diff) ++
15:47:07 <dons>                     " sec")
15:47:09 <dons>         return v
15:47:18 <bringert> shapr: it could be because of my crazy type class tricks maybe
15:47:21 <Axioplase> ha..
15:47:22 <dons> so ignore the liftIO and so on, the bare bones should be there.
15:47:56 <dons> bringert, ah, yes. good idea.
15:48:44 <dons> Axioplase, you'll need to force evaluatoin of the function somehow, within the time start and end period.
15:48:49 <dons> otherwise it might just lazily float out.
15:49:04 <dons> so Control.Exception.evaluate is one way, (if its a pure function)
15:49:10 <shapr> Ohh, I think I found the problem. My use of the partially applied function in a completely different part of the code inferred a different (but still legal?) type for all uses of the partially applied function.
15:49:11 <bringert> dons: you maye wanna have this in loadPackage too:
15:49:13 <bringert> +#if DEBUG
15:49:13 <bringert> +        putStr (' ':show libs) >> hFlush stdout
15:49:13 <bringert> +#endif
15:49:22 <bringert> shapr: ag
15:49:24 <bringert> ah
15:49:30 <dons> adding it bringert, cheers.
15:49:39 <dons> feel free to darcs send any other ideas..
15:50:18 <shapr> Strangely, the use that caused the weird type error is: (remoteAuth "ping") >>== "hello" ~? "doh it failed"
15:50:40 <musasabi> ">>==" ?
15:50:50 <shapr> and I've defined >>== as: a >>== b = do a' <- a;b' <- b; return $ a == b
15:51:10 <shapr> I'm trying to find a simple way to write xmlrpc hunit tests.
15:51:13 * musasabi got an association to >>=
15:51:29 <musasabi> >==> could be more logical. or .==.
15:51:34 <dons> Axioplase, that's the problem with your 'bar' function. you lazily allocate your eC with a 'let', then pass it to a lazy function that ignores the argument. so its never evaluated
15:51:56 <shapr> I don't mind the operator name, but I do wonder why it changed the type signature.
15:52:08 <dons> Axioplase, I.d instead do: Control.Exception.evaluate eC
15:52:52 <dons> > undefined :: IO ()
15:52:53 <lambdabot> No IO allowed
15:52:54 <Axioplase> dons: that works great. thanks a lot
15:53:01 <dons> > error "musasabi!" :: ()
15:53:02 <lambdabot> Exception: musasabi!
15:53:09 * shapr grins
15:53:18 <jethr0> what does "~?" do? is the the same as ">>= guard" ?
15:53:18 <Axioplase> dons: I didn't know how to do with (or without) this let...
15:53:36 <shapr> @type (Test.HUnit.Base.~?)
15:53:37 <lambdabot> forall t.
15:53:37 <lambdabot> (Test.HUnit.Base.AssertionPredicable t) =>
15:53:37 <lambdabot> t -> String -> Test.HUnit.Base.Test
15:53:52 <shapr> It takes an IO Bool and a string.
15:54:00 <jethr0> thx, didn't know it was hunit. i'll look that lib up, too, then
15:54:20 <shapr> There's a recent TMR intro to HUnit and QuickCheck.
15:54:42 <jethr0> i've used them before, just not with all the squiggly operators ;-)
15:55:00 <dons> the problem is that 'let' explicitly lazily allocates the suspended computation for eC, but you need to strictly evaluated it.  eC `seq` return () would probably work too, as would: bar x | x `seq` False = undefined ; bar x = printf "done" -- maybe
15:55:22 <shapr> I was hoping the squiggly ops would let me define one line xmlrpc unit tests. I can't quite figure out how to get around this weird type error though.
15:55:31 <Taral> coi shapr
15:55:38 <shapr> coi taral .i ma nuzba
15:56:23 <jethr0> shapr, have you tried using parens around ">>=="?
15:56:30 <Taral> not much.
15:56:36 <shapr> Is there another way to define liftM2 (==) in few chars?
15:56:39 <Taral> someone show me code?
15:56:49 <Taral> @pl liftM2 (==)
15:56:49 <lambdabot> liftM2 (==)
15:57:10 <Taral> @pl \x y -> do {x' <- x; y' <- y; return x' == y'}
15:57:11 <lambdabot> (line 1, column 12):
15:57:11 <lambdabot> unexpected "{"
15:57:11 <lambdabot> expecting variable, "(", operator or end of input
15:57:13 <Taral> ha ha ha
15:57:19 <jethr0> but it's shorter than (the above)
15:57:26 <dons> @pl \x1 x2 -> do { x1 <- m1; x2 <- m2; return ((==) x1 x2) }
15:57:27 <lambdabot> (line 1, column 14):
15:57:27 <lambdabot> unexpected "{"
15:57:27 <lambdabot> expecting variable, "(", operator or end of input
15:57:39 <shapr> Taral: http://www.scannedinavian.org/~shae/ProtoXml.hs
15:57:43 <jethr0> \m1 m2
15:57:48 <Taral> @pl \x y -> x >>= (\x' -> y >>= (\y' -> return x' == y'))
15:57:48 <lambdabot> (. ((. ((==) . return)) . (>>=))) . (>>=)
15:57:53 <Taral> O.o
15:58:07 <Taral> not shorter
15:58:22 <jethr0> @pl \m1 m2 -> do { x1 <- m1; x2 <- m2; return $ x1 == x2}
15:58:23 <lambdabot> (line 1, column 14):
15:58:23 <lambdabot> unexpected "{"
15:58:23 <lambdabot> expecting variable, "(", operator or end of input
15:58:45 <dons> (.((.((==).return)).(>>=))).(>>=) is fun though.
15:58:51 <Taral> yes, yes it is.
15:58:55 <Taral> let's see people work that one out.
15:59:04 <Taral> @pl \f x y -> x >>= (\x' -> y >>= (\y' -> return (f x' y')))
15:59:05 <lambdabot> liftM2
15:59:07 <Taral> LOL
15:59:16 <Taral> @pl \x y -> x >>= (\x' -> y >>= (\y' -> return ((==) x' y')))
15:59:17 <jethr0> nicely done
15:59:17 <lambdabot> liftM2 (==)
15:59:30 <Taral> @pl \x y -> x >>= (\x' -> y >>= (\y' -> return $ x' == y'))
15:59:31 <lambdabot> liftM2 (==)
15:59:43 <Taral> okay, looks like (.((.((==).return)).(>>=))).(>>=) is actually wrong
15:59:58 <shapr> foo, I get the same error.
16:00:02 <Taral> it's (return x') == y'
16:00:08 <Taral> shapr: what code?
16:00:09 <shapr> bringert: This must be the result of weird typeclass tricks.
16:00:15 <jethr0> @pl \m1 m2 -> m1 >>= \x1 -> m2 >>= (x1==)
16:00:16 <lambdabot> (. ((. (==)) . (>>=))) . (>>=)
16:00:29 <bringert> shapr: probably
16:00:31 <palomer> man firefox sucks
16:00:43 <Taral> @pl \m1 m2 -> m1 >>= \x1 -> m2 >>= (return . (x1==))
16:00:44 <lambdabot> liftM2 (==)
16:00:46 <bringert> though you could probably just give your partially applied thing an explicit type
16:00:53 <Taral> no fooling the @pl
16:00:55 <jethr0> right, sry
16:01:08 <jethr0> hehe
16:01:39 <palomer> what's pl?
16:01:41 <shapr> Taral: reload that url and you'll see the problem.
16:01:47 <jethr0> pointless
16:01:59 <Taral> url, url, what url?
16:02:00 <shapr> bringert: The Remote typeclass isn't exported from XmlRpc.Client
16:02:02 <palomer> rather, what's the pl?
16:02:04 <Taral> aha
16:02:07 <shapr> Taral: http://www.scannedinavian.org/~shae/ProtoXml.hs
16:02:19 <jethr0> palomer, it converts a given expression into pointless form
16:02:26 <jethr0> i.e. without explicit variables
16:02:33 <palomer> ahh
16:02:36 <palomer> I thought you were being funny
16:02:39 <jethr0> @pl \x y -> even x y
16:02:40 <lambdabot> even
16:02:44 <jethr0> i was
16:02:56 <Taral> shapr: What package?
16:03:08 <jethr0> @pl \x y -> x == y
16:03:08 <lambdabot> (==)
16:03:20 <palomer> @gl (\x -> x x) (\x -> x x)
16:03:24 <palomer> @pl (\x -> x x) (\x -> x x)
16:03:25 <lambdabot> ap id id (ap id id)
16:03:25 <lambdabot> optimization suspended, use @pl-resume to continue.
16:03:29 <shapr> Taral: http://www.haskell.org/haxr/
16:03:37 <palomer> @pl-resume
16:03:46 <shapr> That's bringert's XmlRpc server and client library.
16:03:48 <bringert> shapr: interesting
16:03:50 <palomer> > 2+2
16:03:56 <palomer> hah, I crashed lambdabot!
16:03:58 <palomer> raise the roof!
16:04:23 <Taral> grar!
16:04:28 <Taral> Setup.lhs: cannot satisfy dependency HaXml-any
16:04:33 <jethr0>  .@karma- palomer
16:04:37 <shapr> Yeah, you'll need HaXml, cryptolib, and http.
16:04:40 <Taral> ugh
16:04:43 <Taral> I don't want to download all that
16:04:44 <lambdabot> Module "pl" produced error: thread killed
16:04:49 <palomer> aww:(
16:04:50 <shapr> cabal-get was made for times like this.
16:04:51 <lambdabot> ap id id (ap id id)
16:04:51 <lambdabot> optimization suspended, use @pl-resume to continue.
16:04:52 <lambdabot> 4
16:05:11 <dons> lambdabot cannot be crashed ;)
16:05:17 <jethr0> yeah, right
16:05:23 <dons> @karma- palomer
16:05:23 <lambdabot> palomer's karma lowered to -1.
16:05:35 <dons> well, I haven't actually seen it crash in the last 2 years
16:05:39 <jethr0> dons, what's happening to lambdabot when he's not here?
16:05:42 <bringert> shapr: fixed in darcs now
16:05:47 <Taral> shapr: Bah, so not messing with trying to build this.
16:05:50 <Taral> What's the problem?
16:05:55 <palomer> what? why did my karma get lowered?
16:06:05 <jethr0> for blasphemy
16:06:06 <Taral> because you keep trying to crash the bot
16:06:20 <dons> false claims of crashing lambdabot are treated with disdain ;)
16:07:15 <dons> jethr0, when the network flakes out, lambdabot sometimes doesn't realise its not connected properly, and just sits there in silence
16:07:33 <shapr> bringert: thanks
16:08:06 <Chilli> Disdain?  No, you have to evaluate (length (repeat 'a')) on paper.
16:08:18 <dons> hehe
16:08:33 <Taral> shapr: remoteAuth isn't in haxr
16:08:59 <Taral> dons: Ping protocol not in place?
16:09:22 <bringert> dons: You've Got Patch!
16:09:46 <dons> Taral, yeah, it's something like that Taral. it's probably annoying enough to actually get fixed soon.
16:09:54 <dons> ah, thanks bringert
16:10:28 <shapr> Taral: Nah, it's in that file.
16:10:50 <shapr> It's just remote partially applied to a base url.
16:12:00 <jethr0> dons, so it's the IRC code at fault?
16:14:01 <dons> well, it will reconnect in some circumstances, but this particular problem does look like a ping issue, and lambdabot doesn't do any pings to the server
16:14:20 <dons> except right at the start
16:14:21 <Taral> --remoteAuth :: (Network.XmlRpc.Client.Remote a) => String -> (String -> a)
16:14:22 <Taral> wrong
16:14:28 <Taral> it's remoteAuth :: Remote a => String -> a
16:14:48 <Taral> (remoteAuth "ping" >>== "hello")
16:14:51 <Taral> is also wrong, you want
16:14:53 <Taral> (remoteAuth "ping" >>== return "hello")
16:15:36 <Taral> not sure why you're bothering, though, since you can more easily do something like
16:15:50 <dons> ah, I see lambdabot responds to pings, but should probably send its own as well.
16:15:50 <Taral> do {r <- remoteAuth "ping"; return r == "hello" }
16:15:52 <Taral> er
16:15:54 <Taral> do {r <- remoteAuth "ping"; return $ r == "hello" }
16:16:01 <Taral> dons: Yup, if it doesn't hear anything, yes.
16:16:12 <Taral> don't rely on the TCP layer sending prompt timeouts
16:16:26 <Taral> its timeout for established connections is often 90 minutes
16:16:33 <jethr0> or "remoteAuth >>= return . ("hello"==)"
16:16:40 <Taral> jethr0: Yes, if you want to be unreadable
16:16:56 <Taral> it's called pointless notation for a reason :)
16:17:02 <dons> ah, interesting Taral. a little timeout thread could solve this.
16:17:17 <jethr0> i don't find 'remoteAuth >>= return . (=="hello")' all that revulting.
16:17:28 <Taral> dons: Now if only Control.Concurrent supported read with timeout.
16:17:45 <dons> timeouts are easy enough to code up though.
16:17:50 <Taral> actually, I'd really like just arbitrary waitForEventsOnObjectsWithTimeout
16:18:16 <Taral> dons: Timeouts are hard to work with reads if you want atomicity.
16:18:22 <Taral> Imagine:
16:18:27 <Taral> Thread A: read (block)
16:18:31 <Taral> Thread B: sleep (block)
16:18:33 <Taral> Thread A: read complete
16:18:37 <Taral> Thread B: sleep complete
16:18:41 <Taral> Thread B: notify timeout
16:18:48 <Taral> Thread A is now stuck. Timeout has been sent, but data was read
16:19:18 <Taral> The problem is that there's a critical section between the completion of the read and the aborting of the timeout thread.
16:19:47 <Taral> if your timeout tends to kill off the read, that's fine, but it's bad for certain cases.
16:20:01 <Taral> readWithTimeout doesn't suffer this problem, but it does potentially suffer other problems.
16:20:15 <Taral> what you really want is waitForEventsOrTimeout
16:20:23 <Taral> i.e. poll()
16:20:28 <shapr> Taral: Actually, Remote wasn't exported from XmlRpc.Client until five minutes ago, so neither worked at that point.
16:20:35 <Taral> shapr: Heh.
16:20:48 <Taral> shapr: But your weird type error is probably due to >>== "hello"
16:20:53 <shapr> ah!
16:23:07 <shapr> No instance for (Eq (IO [Char]))
16:23:08 <shapr> ??
16:24:40 <Taral> um
16:24:46 <Taral> your >>== is broken?
16:24:51 <Taral> what is >>== defined as now?
16:25:09 <jethr0> gotta be ">>== return "hallo""
16:25:22 <Taral> shapr: Did you replace >>== with ==?
16:25:38 <jethr0> because it does "b' <- "hallo""
16:27:42 <shapr> Taral: oj vey, thanks
16:28:05 <shapr> tadah! it all typechecks.
16:28:07 * shapr smacks himself
16:32:20 <shapr> bringert: Ok, it was user error, not typeclass trickery.
16:32:46 <bringert> shapr: I've had a few similar experiences already today
16:32:55 <bringert> trying to find the problem for an hour
16:33:08 <bringert> then realizing I did somehitng silly
16:33:47 <shapr> Test driven development cuts out a lot of this sort of trouble. I just didn't think of applying it to my >>== function.
16:34:47 * bringert will now remove the configure / make system for HaskellDB which he spent many days crafting
16:34:57 <bringert> Cabal works well enough now
16:35:08 <bringert> well, it has for some time
16:35:11 <SyntaxNinja> cabal!
16:35:27 <bringert> I just found the motivation to fix this stuff
16:36:30 <shapr> yay cabal!
16:38:59 * boegel|home yawns
16:39:14 <boegel|home> actually, no I don't, but I should (almost 2am)
16:39:17 <jethr0> maybe you should go to "boegel|bed"
16:39:23 <boegel|home> hmm
16:39:33 <boegel|home> I'm still working though, so that's a good thing
16:39:40 <boegel|home> I'm not wasting my sleeping time
16:40:04 <jethr0> working or procrastinating in IRC?
16:40:08 <Taral> dons: Patch!
16:40:24 <boegel|home> jethr0: working dude (installing octave atm)
16:40:49 <dons> cheers
16:41:01 <shapr> hoi boegel|home
16:41:09 <boegel|home> hey shapr 
16:41:15 <shapr> How's code?
16:41:30 <dons> Taral, where'd the unix dependency come from in yi.cabal? it's not supposed to need unix.
16:41:34 <dons> and builds for me without it..
16:41:35 <boegel|home> well, besides the small Haskell program I wrote for aggregating my measurements, none
16:41:45 <Taral> dons: I added it because it was there for hmp3 and in yi.conf
16:41:47 <boegel|home> I'm throwing myself at my Phd work
16:41:54 <dons> ah. ok.
16:41:55 <Taral> If it works on non-unix systems, you can take it out
16:41:56 <boegel|home> it's getting more and more interesintg
16:42:00 <dons> it's gone!
16:42:30 <Taral> dons: So the new patch allows dumb users to do ./configure;make;make install and it works.
16:42:39 <Taral> also make clean/distclean/maintainer-clean do the right thing
16:42:41 <boegel|home> especially because it appears I have found a big mistake in a published paper (by my advisor ^_^)
16:42:43 <Taral> (better than Setup.hs clean)
16:43:11 <dons> ok. i've pushed your stuff into the main repo, except this new patch, I have to merge.
16:43:14 <jethr0> you sure that's a good thing?
16:43:35 <jethr0> ;-)
16:43:40 <shapr> boegel|home: No code for your PhD?
16:44:24 <boegel|home> shapr: erm, yeah, R code
16:44:31 <boegel|home> and scripting
16:44:45 <boegel|home> I try to use Haskell as much as I can though :)
16:48:33 <boegel|home> hey, no HWN this week ? are did I miss it ?
16:48:58 <Taral> HWN?
16:49:16 <boegel|home> Haskell Weakly News
16:49:22 <boegel|home> Taral: http://sequence.complete.org/hwn/
16:49:28 <jethr0> weakly?
16:49:30 <Taral> *groan*
16:49:34 <Taral> bad pun!
16:49:49 <boegel|home> hey man, it's 2am, so bugger off :P
16:49:57 <boegel|home> Weekly, ok ? *sigh
16:50:21 <Taral> yay, syndicated to lj :)
16:50:29 <Taral> I think Weakly is awesome.
16:51:00 * boegel|home watches while octave is still building
16:52:18 <Taral> http://www.livejournal.com/users/hwn/
16:53:42 <dons> Taral, ok. all good. the main repo is now in sync with all your changes.
16:55:13 <SyntaxNinja> hm. is it possible to create new types of IOErrors?
16:55:24 <Taral> yay!
16:55:31 <Taral> now if only optimize --reorder would work right
16:57:20 <benny_> i'm having trouble compiling a haskell program, i get the error:
16:57:26 <benny_> gcc: unrecognized option `-rpath'
16:57:54 <Taral> oops, it's --reorder-patches
16:57:55 <Taral> no wonder
16:58:11 <Taral> nope, not that
17:02:40 <benny_> does haskell have a multiline comment syntax?
17:02:48 <dons>  {- yes -}
17:02:59 <benny_> thanks
17:03:12 <benny_> {-# is some kind of compiler directive though?
17:03:17 <dons> yep
17:03:19 <shapr> bringert: Is there some way to get out of forcing the types like (remote url "addtwonumbers" (4 :: Int) (2 :: Int) :: IO Int) ?
17:03:24 <Taral> hm
17:03:32 <Taral> jhc looks interesting in concept, but the code is really hard to navigate
17:03:44 <shapr> What's hard about jhc?
17:03:52 <Taral> well, it took me 10 minutes to find the haskell parser
17:03:53 <shapr> Have you read through the GRIN thesis?
17:03:57 <Taral> not yet
17:04:15 <Taral> I might try reimplementing some of it, just to understand it better.
17:06:09 <bringert> shapr: no. I prefer declaing a function an giving it an explicit type, then using that function everywhere
17:06:45 <bringert> think of it as foreign import declarations
17:06:57 <benny_> is vim known to have syntax highlighting problems with {- -} comments?
17:07:05 <bringert> in fact, I was thinking of adding xmlrpc as a callconv to use with foreign import
17:08:04 <shapr> Ok, makes sense.
17:08:13 <bringert> I've fixed up HaskellDB a bit now if anyone wants to give it a spin. DBDirect and dynamic driver loading now seem to waork they way they ought to
17:08:28 <jethr0> benny_, sometimes gets confused by multiline comments in all languages. scrolling up and down should fix it ;-(
17:09:07 <bringert> I'm off to bed
17:09:10 <bringert> good night
17:09:10 <benny_> jethr0: yeah, but i am experiencing more then just a minor glitch.... it doesn't seem to be coloring it at all
17:09:19 <dons> :syntax on ?
17:09:24 <shapr> bringert: Thanks for the HDB.cabal, I'll use it!
17:09:40 <jethr0> hmm, works for me all right...
17:09:50 <bringert> it should work out of the box (CVS that is) now
17:09:56 <dons> ? :syn sync fromstart
17:12:16 <SyntaxNinja> cabal!
17:12:33 <SyntaxNinja> has anyone tried out cabal-install? it rules
17:13:02 <SyntaxNinja> cabal-install HDB.cabal --user --prefix=/home/foo/usr --hugs #does the right thing :)
17:14:07 <jethr0> gotta go, nite
17:14:47 <boegel|home> bye jethr0 
17:16:37 <shapr> @where cabal-install
17:16:38 <lambdabot> I know nothing about cabal-install.
17:19:23 <SyntaxNinja> get it from the cabal darcs repo
17:19:38 <SyntaxNinja> it comes w/ newish cabal 1.1.4s
17:20:04 <shapr> How do I use it?
17:20:17 <SyntaxNinja> darcs get (cabal repo)
17:20:24 <SyntaxNinja> cd cabal; sudo make install
17:20:40 <SyntaxNinja>  /usr/local/bin/cabal-install --help
17:20:54 <SyntaxNinja> you can feed it a .cabal file, a directory, or a (good) tarball
17:21:27 <shapr> I've used earlier cabal versions to install the latest cabal, seems it didn't install cabal-install.
17:25:14 <SyntaxNinja> eh?
17:25:20 <SyntaxNinja> how latest?
17:25:25 <SyntaxNinja> I wrote this like a week ago
17:25:41 <SyntaxNinja> but you have to use the makefile, or cd caba/cabal-install && ./setup configure #etc
17:34:04 <shapr> ok
17:34:42 <Pseudonym> Lunch.  BBL
17:36:53 <benny_> if i have a list can i use an integer index like i[2] ?
17:39:30 * boegel|home leaves for bed (finally)
17:39:35 <boegel|home> g'night everyone !
17:40:17 <benny_> night man.... anyone?
17:40:28 <SyntaxNinja> benny_: you can, but that's bad.
17:40:34 <SyntaxNinja> @type (!)
17:40:35 <lambdabot> Not in scope: `!'
17:40:44 <SyntaxNinja> @type List.(!)
17:40:45 <lambdabot> Not in scope: data constructor `List'
17:40:45 <lambdabot>  
17:40:45 <lambdabot> <interactive>:1:5: Not in scope: `!'
17:40:47 <SyntaxNinja> @type (!!)
17:40:48 <lambdabot> forall a. [a] -> Int -> a
17:40:58 <SyntaxNinja> there we go, so it's like i!!2
17:41:05 <benny_> sylvan: yeah it feels bad but i just want to hack this together to see if it will work at all
17:41:10 <benny_> ok cool i'll try
17:45:29 <benny_> sweet it worked thanks man :)
17:45:56 <benny_> so this Data.Array stuff.... it works only with IO monad?
18:04:13 <araujo> Hello Haskell!
18:06:16 <benny_> is there like a tutorial or something for arrays?
18:14:32 <Cale> benny_: hmm
18:15:04 <Cale> benny_: Well, they're not that hard to use -- have you looked at the documentation for IArray?
18:15:26 <Cale> @docs Data.Array.IArray
18:15:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
18:15:30 <benny_> Cale: sort of... my first problem is there seem to be so many different Array types i'm not sure which one to use
18:16:16 <Cale> Okay, well, that is an issue. :) What sort of access pattern do you want for your array? Are you going to create it once and read it a bunch of times?
18:17:46 <Cale> If that matches your usage, then you probably want an immutable array. Immutable arrays are extra nice because you can use them in a pure fashion, like most other data types in Haskell.
18:18:03 <Cale> If you need to do lots of writing to your array, then you want a mutable array type.
18:18:28 <Cale> Mutable arrays can only be modified or accessed from within the ST or IO monad.
18:18:37 <benny_> ok i think i want immutable then
18:18:54 <benny_> Cale: i am resuming work on that old raytracer that you helped with! :D
18:18:55 <Cale> There's also Diff arrays, which present an immutable interface, but allow for fast updates.
18:19:00 <Cale> ah
18:19:10 <Cale> you're that person :)
18:19:12 <Cale> hehe
18:19:26 <Cale> must have changed your nick since then :)
18:19:29 <benny_> Cale: i've started to add a gui using gtk2hs
18:19:34 <Cale> cool :)
18:19:45 <benny_> yeah... if you remember, then i was using [[RGB]] for the resulting image
18:19:53 <benny_> i'm wondering if i should use an array instead
18:21:03 <Cale> It's possible that you might do better that way. You should also make sure that the fields of the RGB type are strict
18:21:48 <benny_> data RGB = RGB !Word8 !Word8 !Word8 deriving (Show)
18:21:54 <Cale> yeah :)
18:22:23 <Cale> you might also want to turn on -funbox-strict-fields
18:22:59 <benny_> hm.... ok, but i want to first try getting multithreaded rendering working first
18:23:14 <musasabi> you have a SMP machine?
18:23:28 <musasabi> + ghc 6.5
18:23:37 <benny_> no, i mean seperate threads for the gui and the rendering, so you can push a cancel button
18:23:44 <musasabi> ah.
18:24:14 <benny_> unfortunately my machine is this crappy pentium 2 laptop :'( compiling hello world haskell takes almost a minute
18:24:26 <Cale> whoa
19:07:02 <syntaxfree> anyone here has Yahoo! Messenger?
19:12:45 <araujo> @pl (\ s -> (\ file -> writeFile (filter (/= ' ') file) s))
19:12:45 <lambdabot> flip (writeFile . filter (' ' /=))
19:12:52 * araujo dances
19:13:09 <dons> heh
19:13:15 <syntaxfree> No one?
19:13:22 <syntaxfree> please?
19:15:47 <araujo> dons, hello there :-]
19:16:36 <araujo> dons, i hope to take a look at hmp3 soon, i am just using it for the moment ;-)
19:17:40 <dons> cool
19:22:27 <syntaxfree> I need someone with Yahoo! Messenger..
19:22:38 <skew> I've got it
19:23:01 <syntaxfree> cool.
19:23:05 <syntaxfree> what's your id?
19:23:10 <syntaxfree> do you use the official client?
19:23:18 <skew> brandonn_m_moore - actually using gaim at the moment
19:23:37 <syntaxfree> do you have the official client around?
19:23:39 <skew> yes
19:23:49 <syntaxfree> I was hoping to test a webcam.
19:23:59 <syntaxfree> maybe you could help me with that?
19:44:03 <kgrapone> Given timeout :: Int -> IO a -> IO (Maybe a) and task :: StateT S IO Char can I lift timeout somehow to accept task for use within a 'StateT S IO' function?
19:44:55 <skew> yes, there should be some wrappers
19:45:20 <skew> what module is that, Control.Monad.State?
19:45:38 <kgrapone> I've tried using various combinations of lift, liftM and liftIO... can't quite get it.
19:45:48 <kgrapone> yep Control.Monad.State
19:46:50 <kgrapone> the lifts are in C.Monad and C.M.Trans
19:46:52 <skew> runStateT :: StateT s m a -> s -> m (a,s), and StateT :: (s -> m (a, s)) -> StatT s m a are the critical functions
19:47:15 <skew> you want to delay an IO action, or a StateT S IO action?
19:47:51 <skew> the first is something like let timeout' t ioaction = liftIO (timeout' t ioaction)
19:49:03 <skew> the second is let timeout' t act = StateT (\s -> timeout t (runStateT act s))
19:49:49 <skew> oh wait, that Maybe gets in the way a bit
19:49:56 <kgrapone> I've got a StateT S IO I want to prevent from running to long within a StateT S IO function, timeout only accepts IO and forks a thread inside
19:50:09 <skew> my second function is pretty close
19:50:25 <kgrapone> I thought I would have to lift timeout up to the same monad level
19:50:36 <skew> yeah, that's about right
19:51:00 <skew> except you need to bring the StateT S IO action back down to plain IO to pass it to timeout
19:51:27 <kgrapone> ok.  Dropping is what's got me stumped I think...
19:52:37 <kgrapone> I'll let the type checker beat me round the head with your second suggestion... see if I can figure it out.
19:52:45 <kgrapone> Thanks, skew.
19:54:55 <skew> timeout' t act = StateT (\s -> fmap (maybe (Nothing,s) (\(a,s) -> (Just a,s))) $ timeout t (runStateT act s))
19:55:45 <kgrapone> Whoah!  If that's the answer, the type checker will be beating me for a long time!
19:55:58 <skew> it probably looks better with do and case and stuff
19:56:10 <kgrapone> might need to digest that one for a moment
19:56:24 <skew> the whole fmap thing is just fixing up the result
19:57:51 * araujo wonders if he should just release this 'dirty' code.
19:58:29 * SamB wonders what they use for a path seperator in japanese versions of windows
20:03:01 <skew> if you start with timeout :: Int -> a -> IO a -> IO a, which takes a default result, you get a much simpler result
20:04:07 <skew> timeout' = StateT (\s -> timeout t (d,s) (runStateT act s))
20:05:00 <skew> the complexity in your example was turning the Maybe (a,s) into (Maybe a, s)
20:07:12 <kgrapone> Ok, thanks skew.  I'll try those out, and see if I can sensibly change timeout to use a default.  Cheers.
20:07:41 <skew> you can recover your old timeout with maybeTimeout t act = defaultTimeout t Nothing (fmap Just act)
20:10:04 <kgrapone> Nice.  Can't wait until I've managed to burn haskell in through my imperative-riddled brain.
20:14:35 * skew wants to run Haskell on a Sparc T1 (aka Niagara)
20:38:22 <Korollary> wow, some heated discussion on ghc.user...
20:39:38 <Taral> So I'm reading this GRIN paper... how much of this has gone/is going into ghc?
20:41:35 <Cale> Korollary: which?
20:41:43 <Cale> Optimizations for mutable structures?
20:41:47 <Korollary> Cale: Yes
20:41:55 * Cale has a look
20:48:34 <Korollary> @type intersperse
20:48:35 <lambdabot> Not in scope: `intersperse'
20:48:46 <Korollary> bah
20:48:55 <skew> @type Data.List.intersperse
20:48:56 <lambdabot> forall a. a -> [a] -> [a]
20:49:10 <Korollary> yes, that one heh
20:50:30 <skew> @hoogle intersperse
20:50:30 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
20:52:15 <Korollary> @
20:52:16 <lambdabot> Maybe you meant: all-dicts arr babel botsnack choice-add code devils dice
20:52:16 <lambdabot> dict dict-help docs dummy dynamic-load dynamic-reload dynamic-unload
20:52:16 <lambdabot> easton echo elements elite eurohaskell eval fact fact-cons fact-delete
20:52:16 <lambdabot> fact-set fact-snoc fact-update foldoc fortune gazetteer get-shapr ghc
20:52:16 <lambdabot> google help hitchcock hoogle hoogle+ index jargon join karma karma+ karma-
20:52:17 <lambdabot> [7 @more lines]
20:53:19 <Korollary>   wow
20:53:42 <Korollary> @hoogle [[a]] -> [a]
20:53:43 <lambdabot> Data.List.concat :: [[a]] -> [a]
20:53:43 <lambdabot> Prelude.concat :: [[a]] -> [a]
21:00:17 <araujo> @index find
21:00:17 <lambdabot> Data.List
21:18:41 <palomer> erm, can you change code on the fly in haskell?
21:18:49 <palomer> a la squeak?
21:19:27 <skew> you can do similar things with hs-plugins
21:20:18 <palomer> like, change code that's running?
21:20:30 <skew> not exactly, but load in new code and run that
21:21:15 <araujo> palomer, you can dynamically load plugins.
21:21:31 <araujo> Just as skew said.
21:21:52 <skew> you need a bit of architecture if you want to effectively replace parts of the program
21:24:48 <araujo> palomer, Though something bizarre, i'd like to see something a la squeak in haskell :-]
21:25:20 <skew> I think the ghci internals have a lot of the pieces you would need to do more thorough replacement
21:28:00 <newsham> hi
21:28:07 <skew> hello
21:29:25 <araujo> I think that's something possible with House
21:29:35 <araujo> Hi newsham 
21:30:31 <newsham> any good good readin' code for haskell around?
21:30:45 <newsham> repository of stuff?  users group type stuff?
21:32:05 <skew> I'm thinking mostly of papers
21:32:34 <newsham> papers shmapers.. show me the code :)
21:32:42 <skew> "The Design of a Pretty-printing Library" has some good stuff
21:33:44 <Korollary> newsham: You can check out the MissingH library code. That ought to be pretty straightforward reading.
21:34:02 <newsham> where?
21:34:41 <skew> there's quite a bit of good code in that paper
21:34:46 <Korollary> http://quux.org/devel/missingh
21:35:01 <skew> Taral: I don't know about GHC, but jhc uses a lot of the GRIN stuff
21:35:08 <Taral> hoogle is working again! woo!
21:35:25 <Taral> *nod*
21:35:30 <araujo> @where hawiki
21:35:31 <lambdabot> http://haskell.org/hawiki/
21:35:51 <araujo> newsham, ^^
21:36:29 <newsham> seen hawiki
21:37:18 <newsham> hmm.. thihs is a library..
21:37:27 <newsham> small programs would be more interesting
21:42:57 <Lemmih> @seen dons
21:42:57 <lambdabot> dons is in #haskell. Last spoke 2 hours, 25 minutes and 17 seconds ago.
21:43:02 <Lemmih> dons: ping.
21:43:46 <Lemmih> oh, nevermind.
21:44:22 <dons> yo
21:46:01 <Taral> I wonder how one pronounces "whnf".
21:46:09 <Taral> "whoonf" seems reasonable, if amusing.
21:46:19 <newsham> wunf?
21:46:25 <Taral> yeah
21:46:29 <Taral> whoonf == wunf
21:46:38 <ulfdoz> hrhr
21:46:51 <newsham> w-uh-nf?
21:47:00 <newsham> as in onef, twof, thhreef?
21:47:27 <araujo> newsham, there is some section in the hawiki with small programms
21:47:37 <ulfdoz> what about whenf, with "he" for "head".
21:47:46 <araujo> Or i think it is still being written....
21:48:19 <newsham> which part of the wiki?
21:49:07 <araujo> can't find the section now, but ive seen it before....
21:49:15 <newsham> http://haskell.org/hawiki/ShortExamples
21:49:19 <Korollary> reading SICP reviews at amazon.com is quite informative.
21:49:19 <araujo> i think it is still a work on progess
21:49:41 <araujo> newsham, that one
21:49:50 <Taral> nah, I like whnf = wnf (utf-8)
21:49:54 <newsham> http://haskell.org/hawiki/CodeOnTheWiki
21:50:39 <araujo> Oh, i meant TheGallery
21:50:52 <newsham> *nod8 the bf looks interesting
21:52:50 <ulfdoz> arg, damn rz.
22:18:08 <Korollary> This is weird. When exec'd from a ghc compiled haskell program, the two processes I'm running don't terminate. Run in a shell window, they do.
22:25:18 <Cale> hmm
22:25:31 <Cale> @index exec
22:25:31 <lambdabot> bzzt
22:25:38 <Cale> how are you calling them?
22:32:42 <Korollary> @index runProcess
22:32:43 <lambdabot> System.Process
22:33:16 <Cale> hmm
22:33:23 <Cale> are you reading their output?
22:33:29 <Korollary> no
22:33:35 <Cale> do they produce output?
22:33:42 <Korollary> yes. to unix pipes
22:33:50 <Korollary> one of them consumes
22:34:16 <Cale> Perhaps they don't terminate because they're blocked waiting to produce that output.
22:34:29 <Korollary> I realized that I call the producer with runInteractiveProcess, which returns handles as well, which I don't need.
22:35:05 <Korollary> They both just sit there. The producer should at least terminate.
22:36:03 <Cale> well, I think it's probably blocked waiting for something to read from that handle
22:38:34 <Korollary> no, the producer reads from the pipe. (for some reason I was passing its stdout to the consumer's stdin, but the consumer doesn't read stdin anymore)
22:38:49 <Korollary> err
22:39:08 <Korollary> the producer writes to the pipe, and there was no reason for it to exit.
22:39:23 <Korollary> ... no reason not to exit.
22:39:28 <Korollary> I can't type heh
22:39:39 <Cale> hmm
22:39:49 <Cale> by pipe, you mean a unix fifo?
22:39:53 <Korollary> yes
22:40:22 <Korollary> I'm decoding a a batch of flac files and encoding the output as mp3's.
22:40:50 <Korollary> it gets stuck on this particular track for some reason.
22:41:33 <Cale> programs that write to a fifo block until something reads the fifo
22:41:49 <Korollary> well, something is reading the fifo.
22:42:10 <Cale> hmm
22:42:16 <Cale> make sure that it finished
22:42:22 <Cale> finishes*
22:42:47 <Cale> hmm
22:42:57 <Cale> no, that doesn't even seem quite necessary
22:42:59 <Korollary> it works for 6 out of 7 tracks
22:43:05 <Cale> odd
22:43:25 <Korollary> it's always this last track and at 94% encoded.
22:45:41 <Korollary> Heh, I pass "Nothing" as the stdout & sdterr handle to them, yet they still print out to the parent's stdout
22:46:29 <Cale> maybe that just hooks them to the tty
22:46:52 <Cale> well, I suppose that doesn't have to exist
22:47:01 <Cale> interesting anyway
22:47:08 <Korollary> yeah, I would have passed parent's stdout if I wanted this behavior
22:49:08 <Cale> cvs is so confusing
22:49:35 <Cale> in particular, the fptools cvs, where there are tons of empty directories
22:50:06 <Cale> aha
22:50:15 <Korollary> cvs is, umm, old
22:50:26 <Cale> yeah, looking at the source for runProcessPosix, that's just what it does
22:50:37 <Cale> runProcessPosix fun cmd args mb_cwd mb_env mb_stdin mb_stdout mb_stderr
22:50:37 <Cale> 	mb_sigint mb_sigquit
22:50:47 <Cale>  = withFilePathException cmd $ do
22:50:47 <Cale>      fd_stdin  <- withHandle_ fun (fromMaybe stdin  mb_stdin)  $ return . haFD
22:50:47 <Cale>      fd_stdout <- withHandle_ fun (fromMaybe stdout mb_stdout) $ return . haFD
22:50:47 <Cale>      fd_stderr <- withHandle_ fun (fromMaybe stderr mb_stderr) $ return . haFD
22:50:54 <Cale> @type fromMaybe
22:50:55 <lambdabot> Not in scope: `fromMaybe'
22:51:07 <Korollary> that's a good one
22:51:07 <Cale> @type Data.Maybe.fromMaybe
22:51:08 <lambdabot> forall a. a -> Maybe a -> a
22:51:23 <Korollary> ugh
22:51:35 <Korollary> ah
22:51:45 <Korollary> if Nothing then first arg I bet
22:51:49 <Cale> yes
22:51:57 <Cale> > fromMaybe 0 (Just 5)
22:51:59 <lambdabot> 5
22:52:01 <Cale> > fromMaybe 0 Nothing
22:52:02 <lambdabot> 0
22:52:48 <Korollary> They're going to make me get a handle for /dev/null myself. Heh.
22:52:55 <Korollary> wow
22:53:07 <Korollary> They both terminated.
22:54:07 <Korollary> well, it was probably the fact that I passed the producer's stdout to the consumer, even though the consumer wasn't going to read it.
22:54:18 <Korollary> which should still have worked. Oh well.
22:55:04 <flux__> if the consumer didn't read the input, why would the producer not block?
22:55:32 <Korollary> the producer writes to a fifo, not to stdout.
22:55:52 <Korollary> so the whole stdout business was irrelevant.
22:56:05 <flux__> and who reads the other end of the fifo?
22:56:13 <Korollary> the consumer reads it
22:56:38 <flux__> oh well
22:56:42 <Korollary> yepper
22:56:45 <Korollary> s
22:58:57 <Cale> oh
22:59:07 <Cale> So the consumer was reading from an empty fifo?
22:59:44 <Cale> um
22:59:46 <Cale> hmm
22:59:48 <Cale> hehe
23:00:33 <Korollary> no
23:00:41 <Cale> <Korollary> well, it was probably the fact that I passed the producer's stdout to the consumer, even though the consumer wasn't going to read it.
23:00:47 <Cale> trying to understand that
23:01:06 <Korollary> I was passing the producer's stdout to the consumer's stdin, even though that was not necessary.
23:01:15 <Cale> ah, okay
23:01:55 <Korollary> I was originally running them without the fifo. But that turned out to be unreliable.
23:02:36 <Korollary> lame wants to seek the stream to detect if it's a wav or not, and pipes aren't meant to be seek-able (so I read). So it would die every now and then.
23:07:01 <Cale> My original version of mbot was a shellscript which used a fifo to tie things up in a nice loop. Sort of like computing the least fixed point of a command line :)
23:07:33 <Korollary> I didn't know that you wrote mbot.
23:07:46 <Cale> oh, yes, I wrote it :)
23:07:54 <Cale> It's now a lambdabot though
23:08:00 <Cale> with one extra plugin
23:08:04 <Korollary> I'd have guessed so.
23:08:20 <Korollary> #math powered by referential transparency.
23:08:39 <Cale> The shellscript version was getting tricky to maintain.
23:09:08 <Korollary> I am happy that I never had to write shell scripts.
23:09:52 <Korollary> I can't believe the people who enter ICFP using bash.
23:09:54 <Cale> Well, it was originally this one-off "wouldn't this be neat" sort of idea, and I didn't really bother to think about it too hard.
23:10:08 <Cale> Oh, that's certainly insane
23:13:47 <Korollary> This is a hundred line haskell script. 11 imports. heh.
23:14:09 <Cale> What does it do?
23:14:21 <Korollary> the batch flac/lame de/en-coding.
23:15:35 <Cale> I think that, at 100 lines, perhaps that would be better served by a shell script :)
23:15:44 <Korollary> The funniest was that I had to import System.Exit to inspect what System.Process.runProcess returned :)
23:15:52 <Cale> hehe :)
23:16:32 <Cale> There really ought to be a library which makes Haskell more convenient as a shell language.
23:16:37 <Korollary> actually, it's pretty acceptable as is.
23:17:00 <Cale> But that does sound like a 4 line shell script
23:17:05 <Korollary> about 10-15 lines in a do block
23:17:22 <Cale> maybe it's more complex than I'm thinking :)
23:17:24 <Korollary> no, there are a few details
23:17:48 <Korollary> there is a file that has the freedb output (track title, artist name, etc.)
23:18:16 <Cale> ah, you're trying to preserve metadata?
23:18:41 <Korollary> that is parsed. then it creates a directory structure, converts the file names to acceptable windows filenames, etc.
23:18:42 <Cale> usually I just id3convert -s everything
23:18:58 <Cale> ah
23:19:02 <Cale> okay
23:19:09 <Cale> That's sensible
23:19:32 <Korollary> a lot of the code is in let blocks
23:19:55 <Cale> I have 3 or 4 shell/perl scripts which I apply by hand to sort my music.
23:20:57 <Cale> One of them decides on capitalisations of filenames automatically, then I have a tool for applying a sed program to each filename, which is sufficiently general for most mass renaming tasks.
23:21:34 <Korollary> I sorta like the itunes approach actually
23:21:41 <Cale> like converting underscore to space, stripping redundant copies of the artist/album name
23:21:56 <Cale> what is that?
23:22:16 <Korollary> it builds a database with the id3 data so you don't even bother to know what the filenames are.
23:22:30 <Cale> Ah, I strip all the id3 data :)
23:22:33 <Korollary> in fact it stores them like dwefdwegfw.mp3 on the ipod.
23:22:43 <Cale> and store the information only in the filenames :)
23:23:12 <Korollary> why do you strip the id3 data? is it inaccurate?
23:23:17 <Cale> usually
23:23:44 <Cale> Even when it is accurate, it's not formatted uniformly
23:24:22 <Korollary> I don't really care how it's capitalized as long as it's correct heh
23:24:41 <Cale> 10541 items, totalling 47.3 GB
23:24:43 <Cale> :)
23:25:13 <Korollary> since you're such a neat freak, maybe I shouldn't introduce you to the concept of replaydb ;)
23:25:19 <Korollary> err replaygain
23:25:31 <Cale> I've heard about it
23:26:27 <Korollary> it really helps if you ever mix classical with heavy metal in a playlist.
23:26:40 <Cale> I wish that I could figure out how to get Reiser 4 to store metadata. It's supposed to support subfiles, but I never figured out how to get that working.
23:27:01 <Cale> I almost always listen to entire albums at a time.
23:27:36 <Cale> So I usually don't mind so long as the album has the right volume throughout.
23:27:51 <Korollary> if you could make reiserfs4 work, what metadata would you put there? the one that you stripped from the id3 fields? ;)
23:28:19 <Cale> Well, I might like to move date information out of the directory names
23:28:36 <Cale> Though it does help to keep things sorted nicely.
23:28:57 <Korollary> are you on a mac or a pc?
23:29:02 <Korollary> err windows
23:29:02 <Cale> Debian
23:29:04 <Korollary> ah
23:29:12 <Cale> Running Gnome + Enlightenment
23:29:22 <Korollary> xmms?
23:29:25 <Cale> yep
23:29:48 <Korollary> maybe xmms has a database plugin
23:29:54 <Cale> Though I would be easily convinced to switch to something else if it worked correctly and supported drag & drop
23:30:17 <Korollary> hmp3, heh. with haskelldb! 
23:30:22 <Cale> :)
23:30:32 <Cale> hmp3 doesn't play ogg yet though
23:30:41 <Korollary> that's no big deal
23:30:42 <Cale> and a great deal of my stuff is in ogg
23:30:51 <Cale> yeah, it should be easy to add
23:31:11 <Korollary> drag&drop over ncurses would be hard heh
23:31:23 <Cale> Basically, if things are in mp3 to begin with, I'll leave them like that, but if they're in any other format, I'll convert them to ogg.
23:31:30 <Cale> yeah
23:31:39 <Korollary> what other format?
23:31:52 <Cale> A lot of the stuff I get comes in APE and MPC
23:31:56 <Korollary> ah
23:32:16 <Korollary> yeah, I like ogg, but I don't do that because the ipods don't play it.
23:32:35 <Cale> I'm really getting tired of the full cd as one ape file together with a CUE sheet deal
23:32:44 <Cale> though I have a nice program to deal with it
23:32:57 <Korollary> I rip cd's to flac files and keep the flac files.
23:33:11 <dgdf> Me too.
23:33:22 <Cale> I usually would convert flac to ogg
23:33:43 <Cale> I don't care about losing what I don't hear :)
23:33:59 <Cale> since I'm not going to be editing the stuff anyway
23:34:11 <Cale> If I was editing it, then I might care
23:34:40 <Korollary> Heh. I can hear a bit of it, although there is probably nobody who can tell ogg or mp3 above 160k from the flacs.
23:34:41 <Cale> Then again, I'd probably also be complaining about the lack of resolution of CD audio.
23:35:09 <dgdf> I have no reason to degrade the quality of the CD's content.
23:35:13 <Cale> I have a real hard time telling ogg -q6 apart from the original source
23:35:38 <Cale> (as in, I can't do it)
23:35:49 <Korollary> dgdf: I just burn the flac files into a dvd-r. space is cheap heh.
23:35:54 <dgdf> Me too.
23:35:57 <flux__> atleast with lossless encoding you can safely re-encode it with whatever codec the current players support
23:36:03 <Cale> in fact, for a lot of the music I listen to, ogg -q3 would probably be sufficient
23:36:06 <dgdf> I find it more convenient than using the original CDs.
23:36:27 <Korollary> The original cd is actually not as reliable as a flac file.
23:36:43 <dgdf> It also doesn't hold as much music per disc either ;)
23:37:09 <Korollary> we're all in boring agreement here.
23:37:14 <dgdf> Plus then I don't damage the original CD with use.
23:37:40 <Korollary> dgdf: I think I am going to quit buying cd's tho.
23:38:27 <dgdf> Would that be because of the evil attempts by media companies to install software with their music?
23:38:54 <Korollary> dgdf: not exactly. I'd probably buy itunes and save myself the hassle of ripping, etc.
23:39:13 <Cale> I want a strongly typed filesystem :)
23:39:14 <dgdf> Ah. I'd rather have the physical media.
23:39:40 <Korollary> Cale: your filesystem is strongly typed. Files are not directories :)
23:40:07 <Cale> Korollary: I suppose that much is true, though actually, that's a distinction I'd rather *not* have.
23:41:00 <Korollary> Cale: but if your FS was typed, then you'd not be able to prototype with it!
23:41:09 <Cale> prototype?
23:41:14 <Cale> heh
23:41:36 <Korollary> I just love the interactive shell prompt where I can "touch" files without thinking about their extensions...
23:42:18 <Korollary> and the reflection capabilities provided by the file command!
23:42:54 <Cale> parametric polymorphism :)
23:43:51 <Korollary> And everything is a file from the bottom up. There are no 'primitives'.
23:44:09 <Cale> Well, that's sort of the problem. :)
23:44:20 <Megzlna> Do you guys have anything to help visualization of recursion?
23:44:30 <Korollary> Cale has a picture of a fold.
23:44:44 <Cale> actually, I have a picture of lots of folds now :)
23:44:55 <Megzlna> http://rafb.net/paste/results/IiGuDw75.html
23:45:02 <Cale> http://vx.hn.org/autoshare/folds.png
23:45:09 <Megzlna> I'm writing them out in text.
23:46:15 <Megzlna> Cale: For some reason that png doesn't help me at all.
23:46:19 <skew> oh, not recursion like that
23:46:27 <Cale> hmm, I recall that when I was at McMaster, my friend had a program for automatically visualising the recursion of a C program
23:46:29 <skew> but I think there are gcc options to help with that
23:46:40 <Megzlna> this is not recursion in C or anything
23:46:42 <Megzlna> its templates
23:46:45 <Megzlna> immutable
23:46:45 <Cale> yeah
23:46:55 <skew> You might try running examples through cfront
23:47:07 <Megzlna> I need a recursion visualization program.
23:47:17 <skew> Vital might be interesting http://www.cs.kent.ac.uk/projects/vital/
23:47:27 <Cale> Well, there are Haskell libraries for producing dot output
23:47:36 <Cale> which you could use to render graphs
23:49:24 <skew> what does vital use for a Haskell interpreter?
23:49:24 <Cale> itself
23:49:30 <Cale> It's a partial Haskell implementation
23:49:31 <kzm_> Cale: where!  Gimme!
23:49:54 * kzm_ is suddenly wide awake.
23:49:54 <Cale> kzm_: let me find it
23:50:25 <skew> Megzlna: Vital is an interpereter for some fraction of Haskell that draws pretty graphs of things
23:50:29 * kzm_ is feeling magnanimous today, and lets Cale find it.
23:50:31 <kzm_> :-)
23:50:42 <kzm_> @spell magnanimous
23:50:45 <kzm_> double :-)
23:53:09 * kzm_ stares hard at the lambdabot.
23:55:46 <kzm_> @yow
23:55:47 <lambdabot> ... the HIGHWAY is made out of LIME JELLO and my HONDA is a barbequeued
23:55:47 <lambdabot> OYSTER!  Yum!
23:56:28 <kzm_> Hmm... just @spell producing no output - or hanging?
23:56:38 <Korollary> @spell quik
23:56:49 <Korollary> @spe
23:56:50 <lambdabot> No word to spell.
23:56:59 <Korollary> as if you did something with it
23:57:12 <kzm_> ?
23:57:21 <Korollary> that was at lambdabot
23:57:35 <kzm_> Ah.
23:57:43 * kzm_ is relieved.
23:57:59 * Korollary thunders and lashes out at kzm_
23:58:12 * kzm_ cowers in terror.
23:58:27 <kzm_> @karma- Korollary
23:58:28 <lambdabot> Korollary's karma lowered to 0.
23:58:43 <Korollary> @magnanimous- kzm_
23:58:44 <lambdabot> Unknown command, try @listcommands.
23:58:50 <kzm_> @karma+ Korollary
23:58:51 <lambdabot> Korollary's karma raised to 1.
23:58:51 <kzm_> lol
23:59:17 <Cale> http://www.cas.mcmaster.ca/~kahl/Haskell/Dot.lhs -- aha, here is the module
23:59:24 <Cale> nothing too special, but it works
23:59:46 <kzm_> Thanks!
23:59:54 <skew> how about Data.Graph.Inductive.Graphviz?
