00:02:23 <Cale> that might also be handy :)
00:02:23 <Cale> http://www.cas.mcmaster.ca/~kahl/Haskell/HsDep.lhs -- this is a neat program for rendering the module dependencies of a Haskell project
00:02:23 <Megzlna> Cale: Dot graphs?
00:02:23 <Megzlna> is that for me?
00:02:36 <Cale> well, I mentioned it, and kzm_ seemed interested :)
00:02:52 <kzm_> I'm wget'ing all I can here...
00:02:52 <Megzlna> What does this do?
00:03:23 <Cale> It's a haskell library for producing input files to dot and neato, which are graph layout programs
00:03:23 <Megzlna> It says emacs
00:03:25 <kzm_> I read somewhere about SVG and javascipt, is that something to generate from Haskell?
00:03:41 <Megzlna> Ok, you guys are crazy
00:03:45 <kzm_> I guess I would like some user interaction through a web front end.
00:03:46 <Megzlna> dot and neato
00:04:00 <Cale> Megzlna: look up "graphviz"
00:04:17 <Cale> http://www.graphviz.org/
00:04:23 <kzm_> @google graphviz
00:04:24 <lambdabot> http://www.graphviz.org/
00:04:29 <kzm_> Whee
00:04:45 <Cale> would be perfect for rendering a trace of some recursion
00:04:45 <skew> kzm_: it looks like graphviz will produce svg
00:05:41 <Megzlna> I'm convinced that this channel is filled with platypusses, sloths, newts, dodo's
00:05:44 <kzm_> right, it's been a while, but I suspected that would be one backend.  I'm mostly curious what one can do with scripts in there, but I realize there are more appropriate forums :-)
00:05:58 <kzm_> Oh shit, we're found out!
00:05:58 <Megzlna> maybe a couple 2-headed snakes
00:06:13 <Cale> Megzlna: um, sorry, what?
00:06:16 <kzm_> And bananas and lenses!
00:06:32 <Cale> Are you having trouble seeing what's being suggested?
00:07:42 <Cale> The suggestion is essentially that if you want to visualise recursion, basically that means producing a graph
00:08:07 <Cale> So in Haskell, there are various tools to produce input for graph rendering programs
00:08:13 <Cale> the recursion is the easy part
00:10:15 <Cale> makes sense?
00:10:42 <Cale> of course, the assumption is that since you're asking in #haskell, you want a way to do this in Haskell.
00:10:43 <skew> pencil and paper works too
00:11:24 <Cale> Megzlna: makes sense?
00:11:28 <Megzlna> Yes.
00:12:19 <skew> really, sketching stuff out by hand is probably most efficient unless your problem is very huge. but you have got us playing with nice graph tools, which is fun for us
00:24:44 <skew> I heard about something newer, but like Vital
00:25:55 <skew> I think they were using the frontend from dazzle?
00:27:27 <Cale> Pivotal
00:27:40 <Cale> http://www.cs.kent.ac.uk/projects/pivotal/
00:35:16 * Cale wonders why someone removed all the 8k's from the http://www.haskell.org/hawiki/MegaMonad_2fPassingTuringTest page
00:36:18 <Cale> Perhaps I'm mistaken, but isn't that the person now known as benny anyway?
00:37:42 <Cale> ah, yeah, Benny Kramek, the guy with the raytracer in Haskell :)
00:38:56 <Megzlna> Is it possible to get a copy of MegaMonad to play with?
00:39:34 <Cale> CosmicRay should have a copy
00:39:43 <C-Keen> moin
00:40:23 <gilles> hi all
00:41:10 <Megzlna> It says it's a MegaHAL bot.
00:41:12 <Megzlna> Is that written in haskell...
00:41:28 <Megzlna> ah!
00:41:31 <Megzlna> found it ;)
00:45:51 <skew> Megzlna: did you look at Vital?
00:48:13 <gilles> what are you using to edit haskell? i'm going crazy with identation problems
00:48:34 <Cale> gilles: vim or emacs mostly
00:48:36 <skew> the emacs mode is usually acceptable
00:48:50 <gilles> with tab replaced by spaces?
00:48:51 <Cale> though the smart indent mode in emacs I find annoying
00:48:54 <Cale> yes
00:49:09 <gilles> does it matter how much ?
00:49:14 <skew> if you have too much trouble, you could use explicit grouping
00:49:15 <Cale> hm?
00:49:24 <gilles> how much spaces in a tab
00:49:34 <Cale> oh, the compiler treats it as 8
00:49:41 <gilles> hmm
00:49:49 <gilles> this explains that
00:50:00 <Cale> If you mix spaces and tabs, you're in for trouble
00:50:20 <Cale> though you can just use one or the other quite safely
00:50:43 <Cale> most people opt for spaces, since it's nice to be able to line things up
00:51:54 <gilles> i like spaces much better
00:52:24 <gilles> i don't know what happend but now it works
00:52:28 <gilles> very weird
00:52:40 <Cale> where did I get cut off?
00:52:48 <Cale> oops
00:53:14 <Cale> what was the last thing that I said before I got disconnected?
00:53:34 <Lemmih> 'most people opt for ...'
00:53:55 <Cale> Most editors have options for both converting tabs to spaces, and treating multiple spaces as tabs for the purposes of editing
00:54:19 <Cale> turning both those options on seems to work nicely
00:54:34 <gilles> yeah it seems it work know
00:54:41 <Lemmih> Hiya ProfTeggy.
00:54:50 <gilles> i think the problem is that i was trying to copy paste things from the web
01:01:37 <gilles> haskell's syntax is sometimes really weird to me
01:01:57 <Cale> what are you used to?
01:02:17 <gilles> I did a lot of Java and then a lot of ruby
01:02:30 <araujo> gilles, That's why :-]
01:02:45 <Cale> I suppose you could use the braces style :)
01:02:51 <gilles> things like that : request $ defaultGETRequest $ parse url
01:02:53 <gilles> are really great
01:02:54 <araujo> mm.. i'd blame more java though
01:03:03 * araujo loves $
01:03:20 <gilles> but now i want to replace defaultGETRequest with createRequest which takes two args
01:03:22 <Cale> $ and . are both really nice :)
01:03:25 <gilles> and i'm screwed :)
01:03:32 <gilles> back to the old braces style...
01:03:33 <araujo> Whenever i say it, people usually believe i refer to the other meaning of '4' :-]
01:03:34 <Cale> well, not really
01:03:40 <araujo> '$' ....
01:03:51 <Cale> request $ createRequest firstArg $ parse url
01:04:13 <Cale> gilles: by braces I mean { and }
01:04:22 <gilles> what if the uri should be the first arg?
01:04:35 <araujo> gilles, well, '$' would substitute ()
01:04:44 <gilles> hmm i haven't seen much code using {} but it seems really ugly
01:04:47 <Cale> well, then you'll need some parens
01:04:52 <Cale> gilles: yeah
01:05:07 <gilles> request $ createRequest (parse url) mySecondArg
01:05:08 <Cale> well, it's as ugly as in those other languages :)
01:05:09 <gilles> not bad
01:05:21 <gilles> i just need to get used to it :)
01:05:23 <Saulzar> Useful for ghci where you only get one line :)
01:05:37 <Cale> Saulzar: you can still avoid them there though
01:05:47 <Cale> usually it suffices to only use semicolons
01:06:03 <Saulzar> Ah, I didn't know that
01:06:09 <Cale> > do x <- [1,2,3]; y <- [10,20,30]; return (x+y)
01:06:10 <lambdabot> [11,21,31,12,22,32,13,23,33]
01:06:46 <Cale> let f x | x >= 10 = 10 | otherwise = x in map f [1..20]
01:06:53 <Cale> > let f x | x >= 10 = 10 | otherwise = x in map f [1..20]
01:06:54 <lambdabot> [1,2,3,4,5,6,7,8,9,10,10,10,10,10,10,10,10,10,10,10]
01:06:58 <araujo> braces are just not enforced, but you can (ab)use braces in Haskell too. 
01:08:05 <Cale> > case (Just 5) of Nothing -> 0; Just x | x >= 10 -> 10 | otherwise -> x
01:08:07 <lambdabot> 5
01:08:25 <Cale> Some contrived and probably poor examples :)
01:08:58 <gilles> gotta go... see you soon guys 
01:09:01 <gilles> and a big thank for the help !
01:09:02 <Cale> see you
01:09:05 <Saulzar> Hehe, I can see what you mean. Are there situations where braces are required then? (Nesting on one line or some such?)
01:09:06 <Cale> no problem :)
01:09:21 <Cale> Saulzar: yeah, I suspect that nesting would do it
01:09:26 <Cale> nested do-blocks
01:09:37 <Cale> or let-blocks
01:20:30 <kzm_> saluzar: I use it all the time in ghci
01:20:48 <kzm_> > let {x = 4; y = 5; z = x * y } in z+x
01:20:49 <lambdabot> 24
01:21:03 <kzm_> (if that was the question)
01:21:11 <Cale> > let x = 4; y = 5; z = x * y in z + x
01:21:12 <lambdabot> 24
01:21:20 <Cale> you don't *need* the braces there
01:21:46 <kzm_> Hmm..no?
01:21:50 * kzm_ blushes.
01:21:59 <kzm_> Well, I use them, any way.
01:22:02 <kzm_> :-)
01:22:10 <kzm_> > let x = 4; y = 5; z = x * y in z+x
01:22:11 <lambdabot> 24
01:22:28 <kzm_> I always grouped semicolons and braces in my mind.
01:23:06 <kzm_> > let x :: Int; x = 5 in take x [1..10]
01:23:08 <lambdabot> [1,2,3,4,5]
01:23:17 <kzm_> Hmm.
01:23:52 <kzm_> Great!  This will increase my piece of mind, and spare my shift key.
01:23:55 <kzm_> Thanks.
01:24:12 <Cale> no problem :)
01:25:22 <kzm_> It's a small piece, you know.  Doesn't take much to increase it.
01:25:41 <kzm_> (actually, it was a typo, but I find it more appropriate than my intended expression)
01:27:02 <kzm_> @seen JohnMeacham 
01:27:03 <lambdabot> JohnMeacham is in #haskell. I don't know when JohnMeacham last spoke.
01:27:17 <kzm_> Anybody know why thread local storage is expensive?
01:27:20 <Cale> <interactive>:1:10:
01:27:20 <Cale>     My brain just exploded.
01:27:20 <Cale>     I can't handle pattern bindings for existentially-quantified constructors.
01:27:43 <Cale> hm?
01:27:52 <kzm_> I fear mine would, as well.
01:28:29 <kzm_> (context: JM claims TLS is X on the list)
01:28:50 <Lor> kzm, what kind of tls?
01:29:27 <kzm_> The proposal was, I think, to make IORefs thread-local, and use MVars for thread communication. 
01:29:46 <Lor> What?
01:29:49 <kzm_> Then you can reorder code that use IORefs more freely.
01:30:18 <kzm_> (tls=thread local storage)
01:30:19 <Cale> I'd be happy enough with that, I think
01:30:37 <Lor> The mind boggles.
01:30:50 <kzm_> But JohnMeacham claimed it is "quite expensive", and I don't really see why.
01:30:52 <Cale> How do you statically prevent IORefs from getting used by multiple threads though?
01:31:04 <kzm_> Perhaps that is it?
01:31:07 <Lor> You mean whenever a new thread were spawned, it would get its own copies of all existing IORefs (conceptually)?
01:31:35 <kzm_> I don't know.
01:31:40 <Lor> TLS refs might make some kind of sense, but why should they be called IORefs?
01:31:43 <Cale> Either that, or have a runtime failure when it tries to read another thread's IORef
01:31:58 <Lor> Oh, that's quite different from TLS.
01:32:00 <kzm_> I've only programmed concurrent in C++, and my main contribution to that project consisted of bugs.
01:32:39 <Cale> heh
01:32:51 <kzm_> Come to think of it, the project was mainly bugs.
01:33:00 <Cale> :)
01:33:05 <Cale> Well, it was written in C++
01:33:23 <kzm_> Yes.  The compiler was buggy, too.  And the libraries (MFC).
01:33:28 <Cale> oh, haha
01:33:35 <Cale> yes, I'm familiar with those bugs
01:33:53 <kzm_> Thank god it was commercial.  Embarassing if anybody got to see the code.
01:33:54 <Cale> VS6 had a really broken implementation of the STL.
01:33:56 <kzm_> :-)
01:34:10 <Cale> and templates in general
01:34:24 <Cale> There were things in the STL which just plain didn't work.
01:34:25 <kzm_> But you were really supposed to use MS' own container classes.
01:34:47 <gilles> hi again
01:34:51 <kzm_> Lots of casting to/from void, IIRC, and half of MFC was #define'd constants anyay.
01:34:56 <Cale> heh
01:34:59 <Cale> yeah
01:35:07 * kzm_ shudders.
01:35:15 <eivuokko> FWIW, every prestandard C++ compiler was sucky in those regards.
01:35:32 <kzm_> And last week, I almost got a job on a project using MFC and C++...
01:35:33 <Lor> Constants should defined using enum.
01:36:19 <kzm_> A friend who works there is complaining about the (lack of) class design.  I told him they should have hired me, I worked for years on that kind of code :-)
01:37:18 <Cale> hehe
01:37:19 <kzm_> eivuokko, true enough.  And the problem with prestandard is that you develop a user base who come to expect things the way they are.  So you remain prestandard for a long time.
01:37:50 <sieni> Lor: not const?
01:37:53 <eivuokko> Yeah.  And Ms apparently made a mistake with their compiler team, too ;)
01:38:04 <Cale> Haskell needs to make some drastic changes soon, for fear of becoming too popular ;)
01:38:09 <Lor> sieni, no. If they are const then you can take their address.
01:38:12 <Saulzar> Even most "poststandard" C++ compilers still have quite a few differences... #ifdef #elseif ... #ifdef .. 
01:38:17 <Lor> And then it's not guaranteed that they get inlined.
01:38:19 <pejo> eivuokko, wasn't it only in the last year or two they started to be able to parse the entire language? iirc some company made a fuzz about having a standards compliant parser for sale (main customers would probably be compiler companies).
01:40:55 <eivuokko> pejo, Yeah.  And yeah, there is a company called EDG who sell compiler front-ends, and their C++ front-end is pretty amazing.
01:41:28 <Lor> What do these front-ends produce?
01:42:28 <eivuokko> Some intermediate lanaguage with types etc resolved, I'd hazard a guess.
01:43:12 <eivuokko> I wish Haskell got new spec, getting in multiparam classes etc, at least the basic stuff.
01:43:52 <Heffalump> Lor: a tree
01:44:01 <eivuokko> It'll be interesting to see if that makes Haskell more popular or not :)
01:44:05 <kzm_> eivuokko, we also suffer from the prestandard syndrome :-)
01:44:15 <kzm_> (even if there is a standard, of course)
01:44:27 <Cale> kzm_: see my comment above :)
01:44:31 <Heffalump> pretty much everyone but M$ uses the EDG front-end, AFAICT.
01:44:34 <eivuokko> Yeah.  But at least haskell spec is readily available and easy to read :)
01:44:40 <Lor> Heffalump, _everything_ is a tree, that's not very informative
01:44:56 <Heffalump> ok, a type-annotated parse tree. Happy now? :-)
01:45:02 <Heffalump> what would you expect a front-end to produce?
01:45:50 <Lor> That would depend on the compiler architecture. A _general-purpose_ front-end is a new concept to me.
01:45:57 <Heffalump> I think you also get some C++ to C lowering
01:46:02 <Heffalump> from EDG, that is
01:58:28 <pengo> how are integers stored or how big are integers?
01:58:51 <flux__> I think the exact value is 'very big'
01:59:35 <flux__> not sure about the storage format
01:59:44 <flux__> my guess would be 31 bits and one bit to indicate if there are more bits
02:00:19 <gilles> i again need some help with the IO monad...
02:00:26 <gilles> i'm trying to do that : main = do map browse (map doRequest requests)
02:00:56 <gilles> where requests is a list of Request (i'm using http lib)
02:01:09 <gilles> of course the result is a [IO ()]
02:01:19 <gilles> what can i do to get rid of the list?
02:01:24 <gilles> fold it ?
02:01:53 <Lemmih> @type mapM_
02:01:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
02:01:56 <Lemmih> @type mapM
02:01:58 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
02:02:02 <gilles> nice :-)
02:02:06 <gilles> thx
02:16:36 <Cale> pengo: in multiple ways
02:17:28 <Cale> a value of type Integer is a machine integer if remains small enough, and switches over to an arbitrary precision integer otherwise
02:17:46 <Cale> data Integer
02:17:46 <Cale>   = S# GHC.Prim.Int# | J# GHC.Prim.Int# GHC.Prim.ByteArray#
02:18:52 <Cale> an Int is always a machine integer
02:19:05 <Cale> well, at least on all present platforms
02:19:52 <Cale> Int covers at least the range [-2^29, 2^29 - 1].
02:20:51 <Cale> pengo: then there are explicitly sized Int and Word types in Data.Int and Data.Word
02:21:36 <pengo> thanks
02:21:39 <Cale> However, with all these types, you have an extra box
02:22:14 <Cale> a value of type Int in the program will be implemented with a 'box' which is basically a tag together with a pointer to either code, or a proper Int
02:22:25 <pengo> ah k
02:22:39 <Cale> this is part of how laziness is implemented
02:22:52 <pengo> that doesn't ever get optimized away?
02:23:14 <Cale> well, sometimes it does, but usually not without extra compiler flags and annotations
02:23:21 <Cale> we have what are called unboxed arrays
02:23:27 <pengo> ah k cool
02:23:32 <Cale> for only certain types
02:23:40 <pengo> i dont need them yet but just curious
02:23:50 <Cale> Unboxing things breaks laziness though
02:24:08 <pengo> yes
02:24:45 <Cale> An unboxed array (which itself will be boxed as a whole) is basically just a block of memory like a C array, and evaluation of any one of the elements will force the whole structure to get evaluated.
02:25:57 <pengo> you mean you can have lazy elements within the unboxed array? (that get evaluated together) cool
02:26:13 <Cale> Well, the array as a whole is lazy, but the elements aren't
02:26:23 <pengo> ah yeah
02:26:48 <pengo> you could state it the other way around, couldn't you?
02:27:01 <Cale> With the usual Array type, the array elements are individually boxed, which makes things like recursive definitions for the array elements possible.
02:27:19 <pengo> yep
02:27:28 <tromp_> like fibonacci
02:29:32 <gilles> i'm not sure my brain can do purely functional programming :)
02:29:38 <Cale> > let a = array (0,20) [(x,f x) | x <- [0..20]]; f 0 = 0; f 1 = 1; f n = a ! (n-1) + a ! (n-2) in a ! 20
02:29:39 <lambdabot>  Not in scope: `!'
02:29:42 <Cale> oh
02:29:50 <Cale> hmm, is the array module loaded somehow :)
02:30:16 <Cale> nope
02:30:17 <Cale> oh well
02:30:34 <Cale> that works anyway, if a is of the usual Array type :)
02:31:03 <Cale> this is a common way to do memoisation
02:32:29 <Cale> let a :: Array Int Integer; a = array (0,20000) [(x,f x) | x <- [0..20000]]; f 0 = 0; f 1 = 1; f n = a ! (n-1) + a ! (n-2) in a ! 20000
02:32:35 <Cale> this also works, and is fast
02:33:01 <tromp_> you forgot closing ], cale
02:33:15 <Cale> sorry, where?
02:33:23 <Cale> I just copied and pasted that from ghci
02:33:28 <tromp_> in first let a = ...
02:33:37 <tromp_> oh, sorry
02:33:45 <tromp_> i see now
02:34:44 <tromp_> you can also express it as
02:34:47 <Cale> let f 0 = 0; f 1 = 1; f n = f (n-1) + f (n-2) in f 20000 -- this is really slow due to the excessive recursion
02:36:01 <Cale> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); f n = fibs !! n in f 20000 -- this is a nice efficient version using the list to memoise
02:36:35 <Cale> (but it takes some brain twisting to get your head around the first time you see it :)
02:36:50 <tromp_> let a = array (0,20) $ (0,0):(1,1):[[a!(x-1_+a!(x-2) | x <- [2..20]]
02:37:04 <Cale> ah, yeah, that's nice :)
02:37:55 <tromp_> modulo some typos:(
02:38:06 <Cale> a = array (0,20) $ (0,0):(1,1): [(x,a!(x-1)+a!(x-2)) | x <- [2..20]]
02:40:57 <lisppaste2> gilles pasted "Browsing attempt" at http://paste.lisp.org/display/14437
02:41:10 <gilles> i went that far
02:41:41 <gilles> which is quite nice, but now i'm stuck... I need to pass a [Cookie] from one request to the other and I have *no* clue how to do that
03:16:07 <twb> Any haskell-mode (Emacs) users about?
03:17:06 <Cale> I've used it before
03:17:17 <yaarg> yup
03:17:25 <twb> I'm wondering if there's a find-haskell-function.
03:17:48 <twb> So I can see the definition of a Prelude function as well as it's type.
03:19:00 <Cale> hmm, I suppose it could do that with the hugs Prelude
03:19:31 <twb> See, atm I'm just using C-x C-f in the ghc source tree, which is... sub-optimal.
03:19:51 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
03:20:06 <Cale> there's that
03:20:55 <yaarg> M-x haskell-doc-show-prelude
03:21:43 <twb> yaarg: that doesn't seem to do anything.
03:22:30 <yaarg> twb: with the cursor over the bit you're interested in?
03:23:29 <twb> The point?  Yes.
03:25:14 * yaarg shrugs
03:25:23 <yaarg> need less to say, i haven't used it much :)
03:25:24 <twb> What's it supposed to do?
03:29:44 <twb> yaarg: ah, that just modifies whether the type is printed for prelude functions.
03:31:31 <yaarg> twb: yeah i see now
03:32:30 <twb> Actually when I said I wanted Prelude functions I was wrong.  I want to be able to see the definitions of module functions, too.
03:35:36 <twb> The first thing is to (programmatically) get the module of a given function.
03:41:53 <benny_> i don't want to start a flame war, but what's a good distro for haskell programming?
03:42:37 <tromp_> any one for which latest ghc is available
03:43:08 <benny_> what's a good distro other then: slackware, debian, redhat?
03:43:25 <xerox> Howdy.
03:43:36 <ProfTeggy> benny, gentoo
03:43:50 <xerox> ubuntu!
03:43:56 <benny_> other then gentoo also
03:43:57 <ProfTeggy> Yes, and that
03:44:01 <benny_> and other then ubuntu please :)
03:44:07 <ProfTeggy> benny....
03:44:09 <Igloo> CP/M!
03:44:25 <ProfTeggy> benny, don't make yourself look like a fool
03:44:25 <benny_> sorry, i just want to see if maybe there is a cool new distro that i haven't tried yet
03:44:49 <tromp_> uhm, try mac osx:)
03:45:12 * xerox checks tromp_'s blood pressure
03:45:19 <Saulzar> They're all the same in the end
03:46:23 <benny_> out of all the ones mentioned i am leaning to slackware, but it seems to have a lot of outdated software
03:52:22 <tuomov> only debian still has decent package management..
03:52:38 <benny_> yeah but i don't need any package management
03:52:46 <tuomov> sorry, but source-based packages just don't cut it
03:53:26 <benny_> i just want something that will install all the usual things like kde, gtk, firefox, and then the other things that i need(ghc) i will install myself
03:54:48 <tuomov> then slackware should be fine
03:55:09 <tuomov> at least it is close to the roots unlike the kludges that bigger distros are
03:56:16 <tuomov> I couldn't even imagine using anything other than Debian. I'm too lazy for that.
03:57:03 <boegel> benny_: fedora
03:57:08 <tuomov> and, yeah, "one-click-install" is too complicated. "single-command-fetch-and-install" is the least work.
03:58:12 <benny_> i'm using latest version of slackware here on this laptop. slackware is always good, but problem is that the software is old, it's still using linux 2.4 even :|
03:58:25 <tuomov> 2.4 is better than 2.6
03:58:28 <tuomov> 2.2 is better than 2.4
03:58:38 <tuomov> 2.0 I'm not sure if it is better than 2.2
03:58:54 <tuomov> the only problem is, the older kernels don't have all the drivers
03:59:38 <tuomov> (2.0 did have less problems with the cd-rom I had back then than 2.2, though)
04:00:19 <benny_> i thought that 2.6 had much better "desktop performance" then 2.4?
04:00:39 <tuomov> well, if "desktop performance" is imitating windows along with BSOD, then yes
04:00:55 <Cale> haha
04:01:28 <Cale> I've never had a kernel panic on 2.6, though the performance when you run out of memory is less-than-stellar.
04:01:47 <tuomov> I've never had a kernel panic, just logs full of stack traces and eventual hang of the system
04:02:13 <Cale> I've not had any of that either
04:02:41 <tuomov> sysctl vm/overcommit_memory=2
04:02:52 <tuomov> OOM-killing and memory-overcommitting is absolutely brain-damaged
04:03:07 <tuomov> sysctl vm/overcommit_ratio=80 (for example) perhaps as well
04:03:18 <tuomov> otherwise it will only allow 50% of mem and 100% of swap to be allocated
04:03:50 * SamB wonders why he was told to upgrade to 2.6 if 2.4 is better
04:03:50 * SamB wonders who told him that?
04:05:20 <SamB> tuomov: are you sure about that?
04:05:27 <tuomov> about what?
04:05:43 <boegel> @hoogle [[a]] -> [(a,a)]
04:05:44 <lambdabot> No matches, try a more general search
04:05:47 <tuomov> yes, there are problems with that solution as well, but OOM-killing is stupid nevertheless
04:05:50 <boegel> @hoogle [a] -> (a,a)
04:05:51 <lambdabot> No matches, try a more general search
04:06:06 <SamB> <tuomov> otherwise it will only allow 50% of mem and 100% of swap to be allocated
04:06:14 <tuomov> but Ion, for example, won't die on out-of-memory situation if you disable OOM-killing
04:06:19 <ProfTeggy> boegel, [a] -> ([a],[a]) maybe?
04:06:21 <tuomov> only crappy interactive programs will
04:06:43 <boegel> ProfTeggy: nah, I was just checking something out for the question posted on the mailing list
04:06:45 <tuomov> (and non-interactive, non-daemon programs may as well)
04:06:56 <tuomov> SamB: iirc overcommit_ratio=50 by default
04:06:59 <ProfTeggy> @hoogle [a] -> ([a],[a]) 
04:07:00 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
04:07:00 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
04:07:00 <lambdabot> Graphics.UI.ObjectIO.CommonDef.split :: Int -> [x] -> ([x], [x])
04:07:04 <SamB> tuomov: yes, thats true
04:07:20 <SamB> or at least, thats what I get from cat /proc/sys/vm/overcommit_ratio
04:07:31 <Cale> hmm
04:08:14 <boegel> ProfTeggy: he wants to go from [["a","b"],["b","c"],["d","e"]] to [("a","b"),("c","d"),("d","e")]
04:08:19 <kzm> tuomov, so is it the default tuning you object to?
04:08:54 <tuomov> the default setting is vm/overcommit_memory=0, which will essentially never fail on memory allocation except on absurd requests
04:09:02 <Cale> sysctl vm/overcommit_memory=2 seems to have had not-so-good effects
04:09:03 <SamB> ah
04:09:18 <Cale> bash: fork: Cannot allocate memory
04:09:20 <tuomov> and thus the memory runs out only when it is actually used, and OOM-killing becomes necessary
04:09:36 <tuomov> octave:1> inv(rand(6000));
04:09:36 <tuomov> error: memory exhausted -- trying to return to prompt
04:09:40 <tromp_> map listToPair
04:09:44 <SamB> well, I'll admit that overcommit is nastily dangerous when the address space actually gets used...
04:09:47 <xerox> @type unzip
04:09:47 <tuomov> with the default setting that would hang 2.6, and totally trash 2.4
04:09:48 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
04:10:08 <xerox> @type zipWith3
04:10:09 <tuomov> there are some really stupid tunings to the OOM-killer in 2.6 that makes it wait for something to happen etc.
04:10:09 <lambdabot> forall d c b a. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
04:10:09 <kzm> do you prefer no overcommit, then?
04:10:10 <SamB> hang?
04:10:15 <SamB> oh
04:10:15 <tromp_> listToPair [a,b]=(a,b)
04:10:17 <tuomov> of course, OOM-killing is lame
04:10:25 <SamB> kzm: who, me?
04:10:30 <SamB> RAM, yes.
04:10:35 <kzm> samb, tuomov :-)
04:10:50 <boegel> @type zip
04:10:51 <SamB> swap, only if the program says it wants to overcommit
04:10:51 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
04:11:30 <tuomov> that would be sane.. kill only over-committing programs when OOM
04:11:52 <boegel> @hoogle [[a,b]] -> ([a],[b])
04:11:53 <lambdabot> No matches, try a more general search
04:12:23 <SamB> yes. and make sure to keep enough memory free to actually fill the non-overcommiting program's requests...
04:12:30 <tuomov> yep
04:12:32 <SamB> though using it for cache would probably be fine
04:13:35 <Cale> vm/overcommit_memory=2 seems to be not such a good thing to type when the current memory usage inlcuding cache is at 100%
04:13:53 <SamB> overcommiting sounds great until you realize how much OOM killing resembles russian roulette
04:14:18 <tuomov> non-overcommitting is also russian roulette with badly written apps that unnecessarily die on OOM, etc.
04:14:26 <Cale> I wish the OOM killer was reasonably intelligent about which process to kill
04:14:27 <tuomov> but hopefully the important programs aren't badly-written
04:15:12 <Cale> usually I only run out of memory when some program I've written consumes memory very very quickly
04:15:14 <SamB> tuomov: well, at least the program that dies actually did try to allocate in that scenario
04:15:18 <tuomov> i.e. can handle memory running out when they allocate it, or preallocate what is necessary (for programs with small requirements)
04:15:34 <tuomov> yep, it is more likely kill the trashing program
04:15:37 <tuomov> +to
04:15:54 <Spark> how about "while (!ptr=malloc(...));" :)
04:17:31 <SamB> you know, a good OOM killer might just kill firefox/mozilla first ;-)
04:17:42 <tuomov> java
04:17:49 <SamB> well, if you have it running
04:18:04 <SamB> but firefox seems to actually have leaks...
04:18:12 <tuomov> no shit, sherlock!
04:18:24 <SamB> Java has a garbage collector, you know!
04:18:43 <SamB> why firefox isn't GCed is beyond me!
04:18:46 <tuomov> that doesn't stop java programs from consistently eating around 300M
04:19:01 <SamB> no, but you see it makes them *consistant*
04:19:11 <SamB> if they weren't GCed, it would grow and grow and grow
04:19:26 <tuomov> yep
04:19:43 <SamB> also, firefox is leaking X resources too
04:20:07 <SamB> fortunately, X *is* GCed
04:20:43 <Cale> hmm
04:20:59 <Cale> the overcommit ratio seems to include cache
04:21:04 <Cale> which seems silly
04:21:09 <SamB> yes!
04:21:11 <tuomov> hmm..
04:21:22 <SamB> maybe there is a good reason for it, though...
04:21:37 <Cale> which is why X died two or three times there
04:22:00 <tuomov> I wonder if it includes video memory
04:22:08 <SamB> though you'd think if there was they could fine-tune it to only worry about cache that is actually being read from...
04:22:21 <SamB> video memory?
04:22:33 <tuomov> done right, read-only mmaps to files and device mmaps shouldn't be included in allocated memory count
04:23:05 <SamB> yeah, any pages they use should be counted as cache
04:23:06 <tuomov> or, well, any mmaps?
04:23:33 <SamB> eh, only those that are either read-only or actually write to the file
04:23:56 <tuomov> are writable mmaps always backed on the mmaped file or are some copy-on-write?
04:24:43 <tuomov> yeah, MAP_SHARED vs. MAP_PRIVATE
04:24:47 <benny_> gcc3 or gcc4?
04:24:58 <tuomov> so MAP_SHARED maps and read-only maps should not be included in allocated memory count
04:25:15 <tuomov> ghc6!
04:26:19 <benny_> doesn't ghc use gcc though? which one is better for it, 3 or 4?
04:27:42 <SamB> and maybe COW mmaps should be allowed to be frozen?
04:28:24 <tuomov> frozen? mremap?
04:29:04 <SamB> frozen, so the kernel doesn't have to worry about the rest of the clean pages being copied?
04:29:37 <SamB> I suppose PIC is a better way to do it...
04:29:50 <xerox> PICs? http://members.ozemail.com.au/~bobpar/pichate.htm
04:30:04 <tuomov> I think (but don't know) mremap can be used to change such pages to read-only
04:30:05 <Cale> hmm, even overcommit_ratio=100 works reasonably, though it still includes cache which seems silly
04:30:06 <SamB> Position Independant Code
04:30:13 <xerox> :-)
04:34:57 <Cale> length [1..] is a good way to test out of memory conditions :)
04:38:01 <camio> Does anyone know of a built-in lib that can give me the filename part of a given path?
04:38:22 <tuomov> hmm.. it ran out of memory. bad GC.
04:38:28 <camio> The only one I've seen is in Cabal and I'm getting errors about it being hidden and such.
04:41:27 <tuomov> why doesn't ghc collect the traversed cells?
04:41:50 <tuomov> that program should run in constant memory, I think
04:43:03 <Cale> it's because of the definition of enumFrom, I think
04:43:07 <tuomov> oh, the implementation of length in prelude is stupid
04:43:23 <Cale> you're looking at the ghc prelude?
04:43:23 <Igloo> Cale: length [1..] uses (pretty much) constant space
04:43:30 <tuomov> in the haskell report
04:43:42 <tuomov> length []        =  0
04:43:42 <tuomov> length (_:l)     =  1 + length l
04:43:44 <Cale> Igloo: not here
04:44:13 <Cale> tuomov: that code isn't the actual code used in the implementations
04:44:23 <Cale> it's just there to specify what things do
04:44:26 <Igloo> Oh, no, I'm being stupid
04:44:32 <tromp_> they don't use foldr?
04:44:51 <tuomov> well it seems like that would be the implementation
04:44:57 <tuomov> with an accumulator the space should be constant
04:44:59 <SamB> tromp_: foldr would not really help much
04:45:01 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Prelude.hs?rev=1.23
04:45:13 <tromp_> it would save one line:)
04:45:29 <SamB> tromp_: true!
04:45:33 <SamB> and help with list fusion
04:45:33 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/List.hs?rev=1.26
04:45:44 <Cale> er, hmm
04:45:46 <SamB> though the value of fusing length is debatable
04:45:49 <tuomov> well, if we're using fixed-sized integers anyway
04:46:22 <tromp_> i guess foldr 0 (\_ l->l+1)    is not the prettiest either
04:46:41 <Cale> length                  :: [a] -> Int
04:46:42 <Cale> length l                =  len l 0#
04:46:42 <Cale>   where
04:46:42 <Cale>     len :: [a] -> Int# -> Int
04:46:42 <Cale>     len []     a# = I# a#
04:46:42 <Cale>     len (_:xs) a# = len xs (a# +# 1#)
04:47:04 <Cale> that's the definition that's actually being used
04:47:10 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/List.lhs?rev=1.13
04:47:22 <Cale> sorry about the other links :)
04:47:57 <SamB> foldr 0 (const (+1))
04:48:14 <tromp_> much better, samb:)
04:48:49 <tromp_> i wish ghc had the smarts to implement  foldr 0 (const (+1))  as efficient as the above Int#
04:49:22 <tromp_> you really don't wanna be forced to write source like that in order to get efficiency
04:49:45 <Cale> @type foldr 0 (const (+1))
04:49:46 <lambdabot> forall b a a1.
04:49:46 <lambdabot> (Num (a1 -> (b -> a -> a) -> b -> a -> a), Num a) =>
04:49:46 <lambdabot> [a1] -> b -> a -> a
04:50:01 <Cale> um, I don't think there's an instance of Num there :)
04:50:24 <tromp_> or let's say:   foldr 0 (const (+1)) :: [a] -> Int
04:50:44 <Cale> type error
04:50:53 <ejt> camio: getFilename = reverse . takeWhile (not . (== '/')) . reverse 
04:50:58 <Cale> ah
04:51:00 <tuomov> oh, but of course, it's still constructing that summation expression that never gets evaluated
04:51:04 <Cale> hehe, silly
04:51:17 <Cale> reverse the parameters to foldr :)
04:51:21 <Cale> @type foldr (const (+1)) 0
04:51:22 <lambdabot> forall a b. (Num b) => [a] -> b
04:51:40 <Cale> though I rather like your ordering :)
04:51:53 <Cale> tuomov: right
04:52:20 <Cale> tuomov: though it's questionable whether it should be
04:52:25 <tuomov> it should try to evaluate things more strictly occasionally
04:52:36 <Cale> length is one of those things which should be implemented with foldl'
04:53:46 <Cale> foldl' (const (+1)) 0 [1..]  -- runs in constant space
04:54:58 <tuomov> where's that?
04:57:05 <tuomov> hm.. hoogle couldn't find it
04:57:24 <tuomov> but found it anyway
04:57:50 <Cale> Data.List
04:57:58 <Cale> sorry
04:59:11 <tuomov> eh, but shouldn't that naive length implementation infact run in constant space, or am I just totally confused?
04:59:45 <Cale> no
04:59:46 <tuomov> it runs out of memory with it too, though
04:59:58 <Cale> because it's building up the big sum expression
05:00:21 <Cale> if nothing forces the evaluation of that sum, it doesn't get evaluated, and nothing ever does
05:00:22 <tuomov> but it should be able to start evaluating it
05:00:30 <Cale> yes, but it's not going to
05:00:41 <Cale> since it's lazy evaluation order
05:00:46 <Cale> outermost first
05:00:50 <tuomov> and it it doesn't start evaluating it, what forces it to generate more terms for the expression?
05:01:01 <Cale> it's evaluating length
05:01:16 <Cale> or foldl/foldr
05:02:03 <tuomov> oh, but 1 + (1 + ...) != 1 + 1 + ...
05:02:29 <tuomov> it's been too long since I've been programming much..
05:02:54 <tuomov> there could be rules for that, though
05:03:26 <tuomov> not sure how useful they would generally be
05:04:00 <dblhelix> but isn't it pretty hard to come up with an example where Prelude.length *isn't* forced to evaluate the addition?
05:04:02 <Cale> well, you can do various heuristic analyses, which GHC does, but it misses this one
05:04:22 <Cale> dblhelix: yes, which is why it should get implemented with foldl
05:04:25 <Cale> foldl'
05:05:07 <dblhelix> huh? so, can you give such an example?
05:05:22 <Cale> um, I'm agreeing with you
05:06:05 <Cale> It is quite hard to come up with an example, since length, if it terminates, will always be forced to evaluate to an integer, so the sum needs to happen
05:06:19 <dblhelix> but if you agree then you should be willing to accept that the current implementation isn't that bad, shouldn't you?
05:06:30 <tuomov> it's bad. it uses a lot of memory.
05:06:34 <tuomov> it shouldn't.
05:06:35 <Cale> The current implementation *is* bad
05:06:42 <Cale> it needs an extra seq
05:06:51 <Cale> I'll post to libraries
05:07:10 <dblhelix> okay, that I see
05:09:37 <Oejet> Lemmih: Hello.
05:09:58 <Lemmih> Hi.
05:10:36 <Lemmih> What's up?
05:15:36 <Oejet> Lemmih: I should be working and reading up for the exams, but I'd much rather lurk in #haskell too.
05:17:42 <Cale> hmm
05:17:46 <Cale> this is interesting
05:18:11 <Cale> for a finite, but really large list, length does run in constant space
05:18:23 <Cale> (if optimisations are on)
05:21:16 <Lemmih> Does it ever run in constant space?
05:21:46 <Lemmih> Isn't it defined as 'length [] = 0; length (x:xs) = 1 + length xs'?
05:22:13 <Lemmih> Urk. I misread 'does' as 'doesn't'.
05:24:44 <bringert> Cale: from fptools/libraries/base/GHC/List.lhs:
05:24:45 <bringert> length l                =  len l 0#
05:24:45 <bringert>   where
05:24:47 <bringert>     len :: [a] -> Int# -> Int
05:24:49 <bringert>     len []     a# = I# a#
05:24:53 <bringert>     len (_:xs) a# = len xs (a# +# 1#)
05:27:58 <dblhelix> and I# unboxes integers, I suppose?
05:28:11 <Cale> bringert: yes, I looked at that
05:28:19 <Cale> (I even pasted it above)
05:28:35 <Cale> I# is the Int constructor
05:29:21 <dblhelix> eh, I meant "it boxes integers"
05:29:26 <dblhelix> so, yes
05:29:36 <dblhelix> data Int = I# Int#
05:29:51 <Cale> :info Int will actually tell you that :)
05:29:51 <xerox> @type +#
05:29:58 <franka> Hm, I think I broke lambdabot.
05:30:09 <dblhelix> @type (+#)
05:31:10 <dons> @bot
05:31:20 <Cale> hmm...
05:31:21 <dons> bah
05:31:34 <Cale> I wonder if it's not written in terms of seq because seq is polymorphic
05:31:57 <franka> I got an "ERROR: thread killed".
05:32:10 <xerox> @bot
05:32:25 <lambdabot> :)
05:32:30 <xerox> Ooooh.
05:33:26 <franka> Shall I try to break it again?
05:34:33 <dons> people should try to fix things, rather than break things ;)
05:34:58 <bringert> Cale: oh, soory, didn't see that
05:35:11 <bringert>  /soory/sorry/
05:35:38 <franka> Well, what I am asking is, is it OK if I try again what I did before, which just happened to break it.
05:37:32 <franka> Ah well.  Too late.  I broke it again. :)
05:37:39 <franka> I just did "@prelude map".
05:37:53 <xerox> What is @prelude ?
05:37:56 <franka> @bot
05:38:02 <Cale> ah, yeah, that's it
05:38:08 <Cale> that's disappointing though
05:38:27 <franka> xerox, That's what I wanted to see.
05:39:04 <Cale> You can't make functions which act on unboxed values strict because seq is polymorphic, and you can't apply polymorphic functions to values of kind #
05:39:31 <Cale> which means that you have to choose which optimisation you want
05:39:33 <franka> Bye-bye, lambdabot.  It was nice knowing you.
05:40:01 <franka> dons, How about a reboot?
05:40:11 <franka> And a bug fix.
05:40:27 <twb`> So...
05:40:45 <twb`> How do I find out which module a function is in?
05:41:14 <franka> Anyway, I have a non-Haskell question.
05:41:43 <franka> Confluent + strongly normalizing implies decidable for a term rewrite relation.
05:41:44 <xerox> @index nub
05:41:48 <franka> But does the converse hold?
05:41:51 <xerox> twb`: that way, if lambdabot worked.
05:41:53 <twb`> xerox: programmatically.
05:42:35 <xerox> twb`: take @index off lambdabot, and make a command-line version of it... aaand...
05:42:56 <twb`> Ow.
05:43:20 <Spark> franka: what do you mean by decidable? always terminates in finite time?
05:43:37 <franka> Yes.
05:43:56 <Spark> i dont think you need confluence for that
05:43:57 <sieni> Spark: also probably needs to give the correct answer ^_^
05:44:58 <Spark> but dont you always have confluence? thats just the referential transparency
05:45:02 <jethr0> spark, doesn't missing confluence imply dependence on evaluation order?
05:45:13 <Spark> yeah
05:45:28 <Spark> but both paths could be finite
05:45:45 <jethr0> hmm
05:45:50 <Spark> but strongly normalising is the more interesting one
05:46:19 <Spark> since you'd need some notion of side effects or global heap in order to not have confluence (i think)
05:46:56 <Cale> hmm
05:47:23 <franka> Confluence makes the normal forms unique.
05:47:27 <Spark> strongly normalising means every evaluation order is finite doesnt it?
05:47:48 <Cale> perhaps it's enumFrom's fault somehow that length [1..] runs in non-constant space
05:48:12 <Spark> e.g. (\x.M) ((\x.xx)(\x.xx)) where M does not mention x
05:48:16 <Spark> is not strongly normalisable
05:48:25 <franka> Without it, you could reduce two terms to distinct NFs.  So you need it, unless you have a finiteness condition on the number of NFs.
05:48:55 <Spark> oh you mean working out every possible result?
05:49:06 <franka> What I am asking is if there are other properties which guarantee decidability.
05:49:16 <franka> Spark, Yes.
05:49:46 <Spark> there will be a finite number of "traces" if its strongly normalisable
05:50:31 <franka> No.  It might not be finitely branching.
05:51:03 <Spark> but if its strongly normalisable
05:51:16 <Spark> every step there will be a finite number of possibilities
05:51:20 <Spark> and the number of steps is finite
05:51:24 <franka> SN means there exists an NF in a finite number of steps.
05:51:50 <franka> But that does not mean that the relation has to be finitely branching.
05:52:05 <Spark> what do you mean by finitely branching?
05:52:10 <franka> There could be an infinite number of NFs among a finite number of levels.
05:52:13 <Spark> you mean there are uncountable outcomes from a node?
05:52:19 <Spark> direct outcomes
05:52:28 <franka> Not uncountable; just infinite.
05:52:39 <Spark> erm i meant countable :)
05:52:46 <Spark> that will never happen because the number of outcomes is limited by the size of the expression
05:52:54 <franka> Countable does not imply infinite.
05:53:12 <Spark> ok infinite then
05:53:29 <franka> noj, that is only true if the term decreases in size.
05:53:35 <franka> noj=No
05:53:52 <Spark> if it always has a fixed point, then its size will always be finite
05:54:10 <Spark> you will never have an infinitely large term anyway
05:54:23 <franka> If what has a fixpoint?
05:54:28 <Spark> the term
05:54:44 <franka> I dunno what you mean by "fixpoint of a term".
05:54:47 <Spark> forget that - the term is always finite
05:55:00 <Cale>     {-# INLINE enumFrom #-}
05:55:00 <Cale>     enumFrom (I# x) = eftInt x maxInt#
05:55:00 <Cale>         where I# maxInt# = maxInt
05:55:00 <Cale> 	-- Blarg: technically I guess enumFrom isn't strict!
05:55:02 <Cale> aha
05:55:06 <Spark> it might grow indefinitely, but since we've said its strongly normalising then that wont happen
05:55:08 <Cale> that's where the problem lies :)
05:55:17 <Spark> it might grow for a while and then stop, but it will remain finite for this period
05:55:25 <Cale> (for anyone still following the length [1..] thing)
05:55:34 <franka> It can grow indefinitely in the sense that there is no upper bound on the size of the NFs.
05:55:38 <franka> But this is all beside the point.
05:56:09 <Spark> each step can make the term grow by a finite amount, there are a finite number of steps
05:56:28 <franka> My question was if decidability of a relation on terms implies strongly normalizing and confluence.
05:56:30 <Spark> the term stays finite for all steps, the number of reduxes is finite at all stops
05:56:54 <franka> Spark, there is not just one term.
05:57:10 <Spark> there is a tree of terms
05:57:11 <franka> There may be an infinite number of NFs.
05:57:13 <Spark> possibly a DAG
05:57:21 <Spark> nope, finite NFs
05:57:35 <Spark> how can you have an infinite number of leaves on a finite tree? :)
05:57:49 <franka> Infinite branching.
05:58:00 <franka> Go look up Koenig's Lemma.
05:58:02 <Spark> each chain is finite and each node has a finite number of children
05:58:09 <xerox> Loops?
05:58:15 <Spark> strongly normalizing
05:58:35 <Spark> that implies the graph is acyclic i think
05:58:42 <Spark> unless ive forgotten what it means
05:59:48 <Spark> strongly normalizable means all finite chains, weakly normalizing means some finite chains, unnormalizable means no finite chains
05:59:52 <Spark> thats right isnt it?
06:00:20 <Spark> hmm ive got to go now
06:26:30 <twb> I say, profiling doesn't seem to be working for me.
06:26:44 <twb> The .prof file is created, but it's empty.
06:29:30 <Cale> hmm
06:29:36 <Cale> what did you compile with?
06:29:49 <twb> ghc -auto-all -prof -o tmp tmp.hs
06:30:16 <twb> Where tmp.hs is:
06:30:17 <twb> main = print (nfib 25)
06:30:17 <twb> nfib n = if n < 2 then 1 else nfib (n-1) + nfib (n-2)
06:30:44 <franka> How to Publish in Top Journals: http://www.roie.org/how.htm
06:31:49 <Cale> and how did you run the program?
06:31:57 <franka> Oops, wrong channel, sorry.
06:32:33 <twb> Cale: I tried ./tmp -p +RTS and -p RTS
06:32:41 <twb> I just noticed that +RTS -p works.
06:33:00 <Cale> ah
06:33:17 <Cale> +RTS turns on sending of further parameters to the runtime system
06:33:20 <twb> The documentation is a bit confusing.
06:33:21 <Cale> so order matters
06:33:39 <twb> When a GHC-compiled program is run with the -p RTS option, it generates a file called <prog>.prof.
06:33:47 <franka> Cale, what is it that you use Haskell for, anyways?
06:33:51 <twb> ...is what it says.
06:34:05 <Cale> franka: various small things, mostly. :)
06:34:15 <Cale> franka: I was hired to write Haskell at one point
06:34:27 <twb> Cale: haskell or in haskell?
06:34:27 <franka> By whom?
06:34:32 <Cale> in haskell
06:34:40 <Cale> by McMaster University
06:34:58 <Cale> Dr. Christopher Anand was my supervisor
06:34:59 <franka> For a research project?
06:35:19 <Cale> Yeah, I wrote a pipeline scheduler for PPC+Altivec
06:35:19 <twb> My boss doesn't care what language I write it.
06:35:22 <twb> s/it/in/
06:35:31 <twb> Cale: cool!
06:35:53 <twb> Cale: how do I change the output width of the profiler?
06:37:16 <Cale> twb: I'm not sure if you can
06:37:32 <Cale> you can get it to generate xml though
06:38:23 <Cale> apparently
06:39:25 <Cale> The scheduler was pretty successful. We ended up scheduling a piece of code which computed sine cosine pairs such that it ran at 2.7 clocks/float.
06:39:46 <Cale> It was 31 instructions.
06:39:59 <Cale> iirc
06:41:11 <Cale> I think it came to something like 19 cycles per loop.
06:42:29 <Cale> Maybe you could get it to 18 if you waited for a better schedule to come along. My scheduler produced a lazy list of schedules, greedy first.
06:42:36 <Cale> (using the list monad)
06:42:50 <Cale> It got reasonable performance too
06:43:57 <Cale> on the test program it took about a second to find the first schedule, and went at about 20 schedules/second after that.
06:44:36 <Cale> It was ~1200 lines which was ~50% documentation
06:44:59 <Cale> which includes a parsec parser for the intermediate language it consumed :)
06:45:59 <Cale> also had the nice feature of allowing you to specify multiple ways to compute the same result, and having it decide between them on the basis of which units are available at the right time.
06:46:58 <jlouis> I took a conjure update and I just got rid of some irritating exercise. Hopefully more hackery is now possible
06:47:12 <jlouis> So now, SamB's work should be put into the stuff
06:53:06 <gilles> hi again
06:53:10 <xerox> Howdy.
06:53:12 <Cale> hi
06:53:21 * Cale stays up indefinitely :)
06:53:26 <gilles> :)
06:53:59 <gilles> i'm each time connecting from a different place :)
07:02:39 <lisppaste2> bosie pasted "broken" at http://paste.lisp.org/display/14440
07:02:52 <bosie> anyone knows why i get this exception ?
07:03:37 <twb> > sum [1,2,3] where sum = product
07:03:38 <lambdabot> 6
07:03:43 <twb> Cool!
07:03:47 <twb> Wait.
07:03:52 <xerox> That's Right.
07:03:53 <twb> > sum [1,2,3,4] where sum = product
07:03:53 <lambdabot> 24
07:03:56 <twb> Good.
07:04:04 <int-e> bosie: your b has to be an a
07:04:12 <jlouis> bosie: what int-e said
07:04:22 <jlouis> You can't insert a b into a Tree a
07:04:29 <int-e> bosie: (in the signature of insert)
07:04:33 <bosie> if b is the same as a why not?
07:04:58 <jlouis> When you write b, you tell the type inferer that b may be different from a
07:05:02 <twb> > let sum = 2 . product in sum [1..4] where product = sum
07:05:03 <lambdabot>  add an instance declaration for (Num (a -> c))
07:05:22 <jlouis> and if it is different from a, then it wont work
07:05:32 <bosie> jlouis yes i would like to have a and b and if it differs from a then i do A if not then i do B
07:05:33 <twb> > let sum = (2*) . product in sum [1..4] where product = sum
07:05:34 <lambdabot> 20
07:06:00 <jlouis> bosie: Either a b
07:06:08 <jlouis> Might be what you want
07:06:11 <twb> Good, so I can rebind internal functions.
07:06:16 <bosie> Either?
07:06:25 <int-e> @type either
07:06:26 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
07:06:26 <twb> Does it work between modules?  I doubt it.
07:06:28 <jlouis> A data type
07:06:34 <bosie> oh thank you
07:06:37 <jlouis> data Either a b = Left a | Right b
07:07:10 <Igloo> twb: While you /can/ do that, it's unlikely to result in readable code
07:07:22 <twb> Igloo: the point is that I can.
07:09:17 * twb also delights in things like : 3 + ; and : + 2 ; in Forth :-)
07:20:50 <gilles> do any of you know a good tutorial on how to think without side effects?
07:21:08 <gilles> i'm reading YAHT
07:21:26 <xerox> Are you stuck on something?
07:21:31 <gilles> which is great, but doesn't help figuring how to do things in a purely functional language
07:22:10 <neologism> it helped me to think about functions as "fixed points" where data flows between them and the functions just modifies them
07:22:22 <gilles> xerox kind of :) i can't decide if it a conceptual problem or what
07:22:51 <xerox> gilles: it also helps to understand that '=' states that the things on the left and the right are _the_same_, independently from time.
07:23:13 <gilles> i think i got that 
07:23:53 <gilles> maybe an example can clarify things, i'm trying to code a web agent (http://paste.lisp.org/display/14437)
07:24:10 <gilles> so far it looks quite good to me
07:24:24 <gilles> but i need the first request to pass something to the second, and so on
07:37:03 <Cale> gilles: oh, right, you asked about that before :)
07:37:55 <Cale> gilles: well, you'll most likely have to separate them
07:39:01 <Cale> gilles: I don't really know much about what you're doing, but basically you'll be getting the return value from the first request, and using it to construct the second
07:40:16 <Cale> gilles: as to your earlier question about functional programming, the first step is to master the basic list functions, such as map, filter, and foldr -- these take the place of loop mechanics from an imperative language and as such are rather important.
07:41:16 <Cale> gilles: writing your main action is mostly an imperative exercise though
07:42:03 <Cale> (though usually you want the program as a whole to mostly lie outside the IO monad, it's sometimes hard to get around when there's lots of IO)
07:46:23 <Cale> gilles: does any of that help?
07:52:01 <bosie> gah
07:52:26 <bosie> data Tree a = Nil |
07:52:26 <bosie>      Node a (Tree a) (Tree a) deriving (Eq,Show)
07:52:26 <bosie> how do i create a Tree of Type "Tree (a,b)" with Tree a being null ?
07:53:14 <roconnor> ?
07:53:44 <bosie> well my problem is that i cant say (Node Int (Nil) (Nil))
07:53:54 <bosie> cos for some reason haskell doesnt recognize Int in that context
07:54:07 <roconnor> (Node 5 Nil Nil)
07:54:43 <Saulzar_> Nil :: Tree Int
07:55:23 <bosie> hmm roconnor ok
07:55:57 <roconnor> After data declaration Node becomes a function of type a -> Tree a -> Tree a -> Tree a
07:56:16 <roconnor> So you have to pass Node an object, not at type.
07:56:41 <bosie> i thought so but it tells me:
07:57:10 <bosie>   Cannot unify the type-signature variable `b' with the type `[Char]' 
07:57:10 <bosie>       Expected type: b 
07:57:10 <bosie>       Inferred type: [Char]
07:57:10 <bosie>   In the first argument of `Node', namely `(5, "F")'
07:57:33 <bosie> my code being:
07:57:33 <bosie> insert :: Tree (e,d) -> Int -> Tree (a,b)
07:57:33 <bosie> insert Nil x = (Node (5,"F") (Nil) (Nil))
07:58:18 <tic|school> Why do you have paranthesis around everything? :)
07:58:26 <Igloo> Node (5,"F") Nil Nil :: Num a => Tree (a, String)
07:58:28 <roconnor> The result of this function is of type Tree (Int,String)
07:58:38 <Igloo> So your type is too general
07:58:45 <Saulzar_> You can't have a tree of two types while you still have declared the type to have just one
07:59:00 <bosie> uhm
07:59:31 <roconnor> Thus, given your code, you must give inster the type Tree (e,d) -> Int -> Tree (Int, String)
07:59:40 <roconnor> s/inster/insert
07:59:55 <Saulzar_> Oh sorry, you're using a tuple - ignore me I'm a moron.
08:00:38 <bosie> Igloo why is my type too general ? i say 5, what other way can i declare Int ?
08:01:06 <Igloo> "Tree (a,b)" is what is too general
08:01:27 <bosie> roconnor i tried that but it tells that it cant instance e with type Int
08:01:44 <bosie> Igloo isnt that the point of polymorphismus ?
08:01:52 <bosie> damn gotta go
08:01:53 <bosie> cu
08:02:06 <Igloo> That says I can use the result of insert with type Tree (Bool, Char) whereas the value you are returning has type (Int, String) (ignoring the Num a thing for now)
08:06:25 <boegel> @hoogle String -> Char -> [String]
08:06:26 <lambdabot> Data.List.lines :: String -> [String]
08:06:26 <lambdabot> Data.List.words :: String -> [String]
08:06:26 <lambdabot> Prelude.lines :: String -> [String]
08:08:34 <boegel> @type readFile
08:08:35 <lambdabot> FilePath -> IO String
08:08:41 <boegel> @type lines
08:08:42 <lambdabot> String -> [String]
08:20:25 <gilles> Cale: thanks i way away for while... I think i've figured out a way
08:20:31 <gilles> cale: i'll let you know of my results :)
08:24:19 <boegel> suppose I have a list [1,2,3], and I want to print all the items in the list with something extra, for example I want as output:
08:24:21 <boegel> foo1
08:24:22 <boegel> foo2
08:24:24 <boegel> foo3
08:24:46 <boegel> any help ? I know I should use map, but how do I get it to print using putStr and show ?
08:25:24 <int-e> @type mapM_
08:25:29 <Cale> mapM (\x -> putStrLn $ "foo" ++ show x) [1,2,3]
08:25:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
08:25:33 <Cale> or mapM_
08:25:45 <araujo> Good morning!
08:25:51 <boegel> Cale: what's the difference ?
08:26:05 <Cale> boegel: mapM keeps the return values into a list
08:26:06 <int-e> mapM_ throws away the results
08:26:14 <int-e> @type mapM
08:26:14 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
08:26:39 <jethr0> why mapM anyway? why not "map (\x -> "foo"++show x) [1,2,3]"
08:26:42 <int-e> note the  m [b]  and  m ()  in the end (you may read 'm' as 'IO' if that helps you)
08:26:43 <boegel> @type mapM
08:26:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
08:26:59 <int-e> jethr0: because a list of IO actions is not an IO action
08:27:01 <boegel> jethr0: I want it to print
08:27:03 <Cale> jethr0: and then presumably, mapM_ putStrLn over that?
08:27:11 <int-e> jethr0: you'd need sequence or sequence_ to run that list
08:27:18 <jethr0> didn't see anything about printing ;-)
08:27:23 <Cale> int-e: it's just a list of strings
08:27:53 <jethr0> ah, there it is ;-)
08:27:56 <int-e> Cale, jethr0: oops, right.
08:28:19 <gilles> how do you define a function that return -> a b ?
08:28:33 <Cale> gilles: hm?
08:28:39 <gilles> hmm that's not the right question
08:28:45 <jethr0> gilles, you'd have to put them into a tuple (a,b)
08:28:48 <Cale> Like, a pair, or the type constructor a applied to the type b?
08:28:59 <jethr0> to return multiple values
08:29:07 <gilles> yes thanks jehtr0
08:35:41 <Saulzar_> Hmm - still looking at this Yampa stuff. I'm a little confused as to the role of state in the signal transformer functions. For something like integral to work clearly it must be updated at each iteration SF -> Time -> SF'. Is it possible to define your own transformer functions which store (any type of)  state?
08:37:14 <gilles> cale: i think i got it right now... the problem was i was trying to do to much inside a monad
08:37:45 <Saulzar_> It seems natural to me to have something along the lines of SF state state      ... but that doesn't seem to be how it works, all the state seems to be kept internally in these examples
08:55:39 <Cale> Saulzar_: I'm not sure what you mean about integral -- it's mapping one signal to another
08:55:58 <Saulzar_> It is, but to implement it, it must hold some state
08:56:36 <Cale> um, why?
08:56:56 <Saulzar_> I assume they simply don't re-run the whole system from 0 each iteration :)
08:57:23 <Cale> Why would it have to?
08:57:57 <dsacode> Hello! My function has type Float -> Float -> Maybe Float, but is it possible to return ANY value; for example (ax+b=0), can have any X value if a = 0 and b = 0..
08:57:59 <Saulzar_> To sum up all the intermediate values
08:58:42 <Saulzar_> In the examples, they use integral to keep track of an objects position   in this way   p <- (initial +) ^<< integral <- v
08:58:46 <Cale> dsacode: perhaps invent a new type to deal with that?
08:59:02 <Saulzar_> and p holds the objects current position, given all the intermediate values for v
08:59:11 <Saulzar_> and initial is the first state
08:59:20 <dsacode> Cale: Yes, may be.. like ExtMaybe x = Nothing | Any | Just x
08:59:29 <dsacode> Cale: do you mean so?
08:59:55 <Cale> dsacode: Something like that, though you won't be allowed to use Nothing or Just again
09:00:16 <gilles> ManyBe = Nothing | Just x | Any :)
09:00:18 <bringert> hehe, some crazy fisherman got a mine in his net, dragged it into gothenburg harbor and left it there
09:00:36 <Saulzar_> I think I see what's going on, they define their signal function SF as a function giving the transition from the previous 'frame'
09:00:49 <Cale> Saulzar_: integration is a pure function of signals
09:00:53 <Saulzar_> Sorry - signal transformation
09:01:38 <Saulzar_> Cale, Hmm, instantaneous integration is - but not the 'indefinite' integral
09:01:46 <Cale> Oh?
09:01:50 <Cale> Why not?
09:02:18 <Cale> Are you saying I can't write a pure function   integrate :: (Double -> Double) -> (Double -> Double)
09:02:42 <Cale> :)
09:02:44 <Saulzar_> Hmm, you can - but that's extremely expensive to calculate in real time
09:02:47 <Cale> why?
09:03:48 <roconnor> integrate f x = 0
09:03:51 <Saulzar_> I presume you have to calculate it out (over some infinitely big range) and sum up the area .. maybe we're on different wavelengths 
09:04:18 <Cale> Saulzar_: well, presumably you're only approximating the integral
09:05:10 <Cale> there's no reason why such a function is necessarily inefficient
09:05:12 <Saulzar_> But how approximate? 
09:05:24 <Saulzar_> In these examples they're using an integral to keep track of the exact position of objects - that's pretty accurate
09:05:30 <Cale> Say, using the trapezoid rule
09:06:58 <Saulzar_> But still, say you were doing this in the middle of a complicated piece of code, in order to obtain the values that would require running the whole simulation from 0 each time
09:07:18 <Cale> You're partially applying integral to the function
09:07:28 <Cale> and then applying the function you get back to various values
09:08:02 <Saulzar_> I don't follow 
09:08:11 <Cale> It's possible that the partial application sets up a memo table
09:09:08 <Saulzar_> That's state, isn't it? :)
09:09:12 <int-e> but pure
09:09:34 <Saulzar_> Yes
09:10:11 <Cale> but even if it doesn't there's nothing to say that it couldn't be done anyway
09:10:23 <Cale> you don't really know how the signals are stored
09:10:34 <Cale> Maybe they're just big arrays
09:11:14 <Saulzar_> What it seems to do is update the signal function each iteration
09:11:25 <Cale> What are iterations? :)
09:11:34 <xerox> @type iterate
09:11:35 <lambdabot> forall a. (a -> a) -> a -> [a]
09:11:52 <Cale> hehe, I say this because signals are functions from times to values
09:12:00 <Saulzar_> At each time step (clearly it's not _entirely_ continuous)
09:12:10 <Cale> Couldn't it be? :)
09:12:28 <Saulzar_> I think that would be a massive challenge :P
09:12:49 <Cale> Usually signals are nearly continuous
09:13:01 <Cale> in the sense that they're impractical to iterate along
09:13:16 <gilles> massive but avoidable according to Niquist
09:13:33 <Saulzar_> Hmm
09:13:53 <xerox> @type Control.Monad.Fix.fix (\f x -> x : f x)
09:13:54 <lambdabot> forall a. a -> [a]
09:13:55 <xerox> iterate?
09:14:47 <Saulzar_> Well, I guess you only ever use an approximation of any signal anyway
09:14:58 <Cale> @type Control.Monad.Fix.fix (\f g x -> x : f  g (g x))
09:14:59 <lambdabot> forall a. (a -> a) -> a -> [a]
09:15:07 <xerox> I see.
09:15:26 <gilles> that's what engineering is about isn't it ?
09:15:28 <xerox> Oh, yes!
09:15:35 <xerox> Nifty, cale.
09:15:57 <Cale> Saulzar_: you're sampling it somehow at the end, and you might retain intermediate information about what you've computed so far at that point
09:16:19 <Saulzar_> Cale, and that's what integral seems to be doing
09:17:08 <xerox> Cale: I don't completely get why the number of arguments can vary in fix's argument.
09:17:42 <Cale> xerox: the first argument is the function itself :)
09:17:43 <Saulzar_> I'm just intriuged because Yampa signal functions seem to allow you to store any state by combining events, I completely missed the point of it
09:18:04 <xerox> Cale: yes.. obviously I'm missing something simple.
09:18:43 <roconnor> Um, I don't think you can integrate a function without knowing its modulus of integration.
09:19:02 <Cale> > let y f = f (y f); fac n = y (\f n -> if n == 0 then 1 else n * f (n-1)) in fac 9
09:19:03 <lambdabot>  add an instance declaration for (Show (a -> a))
09:19:08 <xerox> @type \f g x -> x : f g (g x)
09:19:09 <lambdabot> forall a t. ((a -> t) -> t -> [a]) -> (a -> t) -> a -> [a]
09:19:18 <xerox> O_O
09:19:24 <Saulzar_> What do you mean roconnor? (I've not heard that term before...)
09:19:33 <Cale> > let y f = f (y f); fac = y (\f n -> if n == 0 then 1 else n * f (n-1)) in fac 9
09:19:34 <lambdabot> 362880
09:19:37 <Cale> oops :)
09:19:54 <Cale> xerox: does that example make sense?
09:20:18 <xerox> It's like continuations, when you stop calling the argument, it stops.
09:20:26 <xerox> But I'm still doubting.
09:20:30 <Cale> roconnor: you can make various assumptions about the function and try :)
09:20:34 <roconnor> Well, I'm sort of making up the term, but it would be a function that tells you how fine you need to chop up your function to integrate it.
09:20:38 <int-e> it's half an iterate?
09:20:56 <int-e> > take 10 $ fix (\f g x -> x : f g (g x)) (+1) 1
09:20:57 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
09:21:16 <xerox> @pl \f g x -> x : f g (g x)
09:21:17 <lambdabot> (ap (:) .) . ((.) =<<)
09:21:21 <xerox> Yay.
09:21:22 <Cale> what y f does is to pass y f to f as a parameter
09:21:22 <roconnor> integrate (sin . recip)
09:21:27 <int-e> ow
09:21:42 <int-e> @pl f g x = x : f g (g x)
09:21:43 <lambdabot> f = fix ((ap (:) .) . ((.) =<<))
09:22:56 <int-e> @type ((.) =<<)
09:22:57 <lambdabot> forall b c a.
09:22:57 <lambdabot> (Monad ((->) (a -> b))) =>
09:22:57 <lambdabot> ((a -> b) -> b -> c) -> (a -> b) -> a -> c
09:23:42 <Saulzar_> roconnor, Hmm, I guess that's true. It looks like everything is done on a per-timestep basis
09:24:10 <Saulzar_> So it's up to you to make sure you use a fine enough timestep that your integrals can be acurately calculated
09:24:57 <SamB> what does it mean that type checking is undecidable for Cayenne?
09:25:09 <Cale> Saulzar_: the implementation is considerably more complicated than the paper lets on :)
09:25:25 <Cale> SF actually is a different type altogether :)
09:25:35 <Cale> but you don't really need to know that
09:26:09 <roconnor> i'm planning on adding integration to my exact reall arithmectic implementation.
09:26:14 <Cale> If you forget about performance issues, you can simply regard integral and derivative as the obvious things :)
09:26:16 <Saulzar_> So it seems - but in concept it is Time -> Signal 
09:26:21 <Cale> right
09:26:30 <Cale> data SF a b = SF {sfTF :: a -> Transition a b}
09:26:34 <Cale> data SF' a b 
09:26:34 <Cale>     = SFConst {sfTF' :: DTime -> a -> Transition a b, sfCVal :: b}
09:26:34 <Cale>     | SFArr   {sfTF' :: DTime -> a -> Transition a b, sfAFun :: a -> b}
09:26:34 <Cale>     | SFTIVar {sfTF' :: DTime -> a -> Transition a b}
09:26:42 <Cale> type Transition a b = (SF' a b, b)
09:26:59 <Cale> type DTime = Double
09:27:06 <Saulzar_> I have been looking :)
09:27:49 <roconnor> I suppose waiting long enough is almost reasonable
09:29:43 <Cale> But the nice thing about arrow libraries especially, is that they allow the author to present a very abstract interface to something which might be completely turned inside out before anything gets computed.
09:30:06 <Saulzar_> I'm just starting to see that... 
09:30:26 <Cale> One implementation might just make all the operations produce abstract syntax for some language that has optimisations applied to it
09:30:48 <xerox> Saulzar_: what are you reading?
09:31:03 <Saulzar_> xerox, I have been trying to fathom Yampa
09:31:23 <xerox> Saulzar_: can you link us to the document?
09:32:08 <SamB> roconnor: the trouble with exact reals is how to compare them
09:32:16 <roconnor> It's easy: don't.
09:32:28 <Cale> combinator libraries in general can pull off tricks to optimise, but arrow libraries are especially able to do so, since the very notion of function application is abstracted away and hidden from the user, so you get to pull whatever tricks you like.
09:32:39 <Saulzar_> I've been looking at this: http://www.ida.liu.se/~henni/Publications/hw2003.pdf   as well as the document inside this http://www.haskell.org/yampa/Yampa-0.9.1.tgz
09:32:47 <xerox> Thanks very much!
09:33:00 <Saulzar_> Where the first is their space invaders implementation, second seems to be for a University course
09:35:33 <Saulzar_> It's been confusing the heck out of me - now I need to just go try out a few things and read it another 4 times :)
09:35:56 <Cale> Saulzar_: how comfortable are you with monads already?
09:36:01 <chrisbrown> hi all
09:36:10 <Cale> chrisbrown: hello
09:36:41 <chrisbrown> i was wodering if anyne could tell me why the operator @@ could appear in Haskell code? is this a common convention to mean something?
09:36:56 <chrisbrown> and the same for #
09:36:59 <Cale> In Haskell, you can define arbitrary infix functions
09:37:06 <chrisbrown> yes
09:37:07 <Cale> those aren't standard
09:37:10 <chrisbrown> ok
09:37:18 <Saulzar_> Cale, Moderate, I have figured out some of the basic ones, Maybe List State Reader ... and used them a tiny bit in my raytracer
09:37:28 <gour> dcoutts: ping
09:38:01 <chrisbrown> i am just trawvling the type checkec source code in Programatica and the guy who coded it likes to use @@ everywhere i cant see where it is defined and thought it would perhaps mean something to you guys
09:38:03 <int-e> > let a @@ b = b ++ a in "world!" @@ ", " @@ "Hello"
09:38:04 <lambdabot> "Hello, world!"
09:38:21 <Saulzar_> Cale, They seem extremely elegant to me. I got onto Haskell after trying some of the parser combinator stuff in O'Caml.
09:38:24 <int-e> it could be imported from some other module
09:38:29 <Taral> @hoogle (@@)
09:38:30 <lambdabot> No matches found
09:38:33 <Taral> @type (@@)
09:38:34 <lambdabot> Not in scope: `@@'
09:38:53 <Taral> Oh, nevermind.
09:38:59 <chrisbrown> it must be defined somewhere the thing is there are about 100 source files to look through
09:39:05 <Taral> Look for "(@@)"
09:39:13 <Taral> find | xargs fgrep
09:39:24 <chrisbrown> ok...
09:39:41 <Saulzar_> Cale, Certainly not proficient however...
09:39:45 <Taral> or, if it compiles, use -ddump-minimal-imports to see where it's imported from.
09:40:21 <int-e> or load it in ghci and type :info (@@)
09:40:41 <chrisbrown> ah
09:40:57 <chrisbrown> cool i have found where it is imported from - why didnt i think to do that! lol
09:41:51 <chrisbrown> is there a way in unix to look for a file?
09:41:57 <Saulzar_> grep
09:42:05 <Cale> Saulzar_: Arrows are a bit funkier than monads -- I've never written anything major using them, though all the libraries I've seen which use them have been impressive.
09:42:20 <Cale> chrisbrown: find also is quite good
09:42:22 <Saulzar_> chrisbrown, Sorry - locate or find
09:42:30 <chrisbrown> it says its in MUtils - is that a ghc library?
09:42:32 <Cale> locate is faster, but may be slightly out of date
09:42:34 <Saulzar_> Not sure how you would use grep to look for a file :)
09:43:06 <Cale> grep helps you find a file by its contents, given a list of files :)
09:43:10 <dcoutts> gour, pong
09:43:16 <chrisbrown> find -name "MUtils*" seems to work
09:43:16 <Cale> chrisbrown: nope
09:43:18 <int-e> grep -r ...
09:43:30 <Cale> find | grep
09:43:39 <chrisbrown> m1 @@ m2 = \ x -> m1 =<< m2 x
09:43:46 <Cale> aha
09:44:01 * chrisbrown scrathes his head
09:44:10 <Cale> @type \x -> m1 =<< m2 x
09:44:11 <lambdabot> Not in scope: `m1'
09:44:11 <lambdabot>  
09:44:11 <lambdabot> <interactive>:1:13: Not in scope: `m2'
09:44:13 <gour> dcoutts: there a lot of spam coming to the site recently, and idea what to do?
09:44:19 <Cale> @type \m1 m2 x -> m1 =<< m2 x
09:44:20 <lambdabot> forall a (m :: * -> *) b t.
09:44:20 <lambdabot> (Monad m) =>
09:44:20 <lambdabot> (a -> m b) -> (t -> m a) -> t -> m b
09:44:27 <Cale> @pl \m1 m2 x -> m1 =<< m2 x
09:44:27 <lambdabot> (.) . (=<<)
09:44:31 <Cale> hehe
09:45:04 <Taral> @pl \m1 m2 x -> (m2 x) >>= m1
09:45:05 <lambdabot> flip (flip . ((>>=) .))
09:45:05 <Saulzar_> In concept they seem simple enough. Quite similar to normal functions with a whole lot of ways to wire them up. But clearly it's not as simple as it seems :)
09:45:08 <Cale> chrisbrown: it's a funny kind of composition :)
09:45:10 <xerox> I wonder if one can make @pl run backwards.
09:45:25 <chrisbrown> what does it do? compose 2 monads together?
09:45:42 <Cale> compose two functions with monadic result type
09:45:51 <dcoutts> gour, really? I've not seen any
09:45:55 <chrisbrown> i see
09:45:56 <Cale> (a -> m b) -> (t -> m a) -> t -> m b
09:46:06 <Cale> have a careful look at that
09:46:07 <int-e> @type (=<<)
09:46:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
09:46:11 <gour> dcoutts: well, it all comes to my account for moderation :-)
09:46:12 <Taral> @pl \m1 m2 x -> (m1 x) >>= m2
09:46:12 <lambdabot> flip . ((>>=) .)
09:46:19 <chrisbrown> ah
09:46:19 <dcoutts> gour, oh I see. :-)
09:46:35 <dcoutts> gour, yeah, I've not seen any turn up in the RSS feed.
09:46:37 <chrisbrown> it calls the socend function on the parameter, then calls the first function on the result of that
09:47:00 <dcoutts> gour, so do all comments go to you for moderation?
09:47:05 <Cale> @type \t -> do x <- m2 t; m1 x
09:47:06 <lambdabot> Not in scope: `m2'
09:47:06 <lambdabot>  
09:47:06 <lambdabot> <interactive>:1:20: Not in scope: `m1'
09:47:11 <Cale> @type \m1 m2 t -> do x <- m2 t; m1 x
09:47:12 <lambdabot> forall t (m :: * -> *) a b.
09:47:12 <lambdabot> (Monad m) =>
09:47:12 <lambdabot> (a -> m b) -> (t -> m a) -> t -> m b
09:47:15 <gour> dcoutts: due to linkks within, it is stopped, but comes for mod.
09:47:21 <Cale> that's the same
09:47:28 <Saulzar_> What is @pl ? Find a one liner for x?
09:47:30 <dcoutts> gour, right
09:47:41 <int-e> Saulzar_: sort of
09:47:44 <Cale> Saulzar_: reduces things to points-free (pointless) form
09:47:47 <dcoutts> gour, well you can have them sent to me isntead if you like.
09:47:52 <Cale> that is, removes lambdas
09:47:52 <int-e> Saulzar_: it finds a lambda free version of the term
09:48:01 <Saulzar_> Ahh
09:48:09 <chrisbrown> @pl \m1 m2 t -> do x <- m2 t; m1 x
09:48:10 <lambdabot> (line 1, column 25):
09:48:10 <lambdabot> unexpected ";"
09:48:10 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
09:48:10 <gour> dcoutts: and therefore we can expect more of them, sending to you is not a solution ;)
09:48:26 <Cale> this is called points-free form because it became popular in algebraic topology, where they talk about spaces of points.
09:48:42 <dcoutts> gour, how many links do they normally have?
09:48:51 <Cale> and such a means of expressing a function neglects to mention the point which it acts on
09:48:59 <dcoutts> gour, can we just drop them if there are too many links?
09:49:21 <Cale> chrisbrown: seems that @pl doesn't know about do-notation
09:49:31 <gour> dcoutts: let me check
09:49:39 <dcoutts> gour, presumalby other WP sites will be having the same problem. We can see if there are any plugins available.
09:49:49 <xerox> Cale: implement it!
09:49:52 <syntaxfree> is there any predefined function  equivalent to "cutFrom c st = if (head st == c) then (rest st) else (cutFrom c (rest st))"?
09:49:58 <chrisbrown> f # x = fmap f x
09:50:05 <Taral> @pl \x y z -> if x then y else z
09:50:06 <chrisbrown> :type f # x = fmap f x
09:50:06 <lambdabot> if'
09:50:06 <int-e> @pl do x y = do y x
09:50:07 <lambdabot> do = fix flip
09:50:11 <Taral> @type if'
09:50:12 <lambdabot> Not in scope: `if''
09:50:22 <chrisbrown> @type f # x = fmap f x
09:50:23 <lambdabot> parse error on input `='
09:50:28 <Cale> xerox: I'd rather @pl was implemented in terms of the ghc api, but I don't know anything about either one at the moment :)
09:50:35 <chrisbrown> @type fmap
09:50:35 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
09:50:49 <xerox> Cale: it's a matter of minutes, isn't it? ;-)
09:50:52 <twb> What does the # do?
09:50:54 <Cale> > fmap (+1) [1,2,3,4,5]
09:50:55 <lambdabot> [2,3,4,5,6]
09:51:02 <xerox> twb: he defined it as fmap.
09:51:03 <Cale> > fmap (+1) (Just 2)
09:51:04 <lambdabot> Just 3
09:51:10 <Taral> @pl cutFrom c st = if (head st == c) then (rest st) else (cutFrom c (rest st))
09:51:11 <lambdabot> cutFrom = fix (ap (ap . (`ap` rest) . (if' .) . (. head) . (==)) . flip
09:51:11 <lambdabot> flip rest . ((.) .))
09:51:13 <chrisbrown> what does fmap do?
09:51:26 <Taral> maps functions into higher domains
09:51:27 <xerox> It lifts a function from a to b to Functors?
09:51:28 <int-e> map for arbitrary functors instead of only lists
09:51:29 <Cale> chrisbrown: applies a function to every element of a container
09:51:31 <syntaxfree> it applies a functor or something.
09:51:42 <gour> dcoutts: some time ago i found some plugin(s), one even works with SA
09:51:49 <chrisbrown> calc: not sure i follow
09:51:50 <int-e> for working on lists, fmap = map
09:51:54 <Taral> int-e: Ah.
09:51:55 <chrisbrown> yep...
09:51:57 <Cale> there you go, 4 different answers :)
09:51:59 <xerox> Hehe
09:52:01 <SamB> hmm, is Agda not able to handle GADTs?
09:52:04 <Cale> look at my examples :)
09:52:06 <Cale> > fmap (+1) [1,2,3,4,5]
09:52:07 <lambdabot> [2,3,4,5,6]
09:52:08 <xerox> They all contain a bit of truth to place together.
09:52:12 <Cale> > fmap (*2) [1,2,3,4,5]
09:52:13 <lambdabot> [2,4,6,8,10]
09:52:15 <SamB> Cale: do you know anything about Agda?
09:52:20 <Cale> > fmap (*2) (Just 6)
09:52:21 <lambdabot> Just 12
09:52:24 <Cale> > fmap (*2) Nothing
09:52:25 <lambdabot> Nothing
09:52:26 <chrisbrown> ah i see
09:52:27 <int-e> > mapM (-42) [23, 24]
09:52:28 <lambdabot>  add an instance declaration for (Show (m [b]))
09:52:39 <int-e> hmm
09:52:42 <Cale> chrisbrown: it only applies to instances of the class Functor
09:52:43 <chrisbrown> qualId f =  (f @@ parseQualId) # arg "<M.x>"
09:52:51 <syntaxfree> > mapM (-42) (do putStr(show ([23,24])))
09:52:51 <Taral> > mapM (- 42) [23, 24]
09:52:51 <lambdabot> Couldn't match `[a]' against `IO ()'
09:52:52 <lambdabot>  add an instance declaration for (Show (m [b]))
09:52:57 <chrisbrown> @type arg
09:52:58 <lambdabot> Not in scope: `arg'
09:52:59 <Cale> chrisbrown: what code is this? :)
09:53:09 <Taral> > map (- 42) [23, 24]
09:53:09 <int-e> Taral: ignore that, mapM is something different
09:53:09 <lambdabot>  add an instance declaration for (Num (a -> b))
09:53:13 <chrisbrown> Calc: its part of the type checker for Programatica
09:53:15 <Cale> SamB: I know nothing about it, what is it?
09:53:21 <Taral> @type (- 42)
09:53:22 <lambdabot> forall a. (Num a) => a
09:53:25 <Cale> chrisbrown: ah
09:53:26 <Taral> O.o
09:53:38 <Taral> @type ((-)42)
09:53:39 <lambdabot> forall a. (Num a) => a -> a
09:53:41 <Taral> there we go
09:53:42 <Cale> chrisbrown: also, my name is spelled Cale :)
09:53:43 <syntaxfree> oh god. I rewrote a lot of haskell again.
09:53:43 <int-e> > liftM (-42) [23, 42]
09:53:44 <lambdabot>  add an instance declaration for (Num (a -> r))
09:53:47 <Taral> no, that's not right
09:53:48 <SamB> Cale: it is based on Cayenne
09:53:49 <chrisbrown> Cale: sorry!
09:53:53 <Taral> @type (`(-)`42)
09:53:54 <lambdabot> parse error on input `('
09:53:55 <Cale> chrisbrown: no worries :)
09:53:56 <int-e> > liftM (-42+) [23, 42]
09:53:56 <Taral> LOL
09:53:57 <lambdabot> [-19,0]
09:54:00 <gour> dcoutts: i like these 2: http://www.ioerror.us/software/wp-spamassassin/ & http://unknowngenius.com/blog/wordpress/spam-karma/
09:54:02 <SamB> it is one of those dependantly-typed things
09:54:03 <Taral> @type (-42+)
09:54:04 <lambdabot> forall a. (Num a) => a -> a
09:54:06 <chrisbrown> Cale: must be my eyesight
09:54:13 <Taral> eeevil
09:54:14 <int-e> @type (-42)
09:54:15 <lambdabot> forall a. (Num a) => a
09:54:21 <gour> dcoutts: pls. check them a bit, and then next week i can do something regards..
09:54:40 <Taral> mmm, dependent types
09:54:41 <int-e> Taral: it's because - is interpreted as an unary minus in that constant ... I'd rather have a language without an unary minus.
09:54:50 <chrisbrown> has anyone seen arg before?
09:54:50 <int-e> it's one of the few warts that Haskell has.
09:54:51 <Cale> > map (subtract 42) [32,47]
09:54:53 <lambdabot> [-10,5]
09:54:55 <Taral> I'd at least want a strict requirement on them.
09:54:58 <Taral> I want (-42) != (- 42)
09:55:06 <Cale> Taral: !
09:55:17 <Cale> that would upset some people deeply :)
09:55:23 <Taral> bah
09:55:26 <Cale> but I can see how it would be nice
09:55:28 <int-e> the other wart is integer patterns.
09:55:36 <Taral> int-e: ?
09:55:43 <Cale> integer patterns aren't so bad, n+k patterns are
09:55:46 <twb> Cale: ~ as unary minus!
09:55:54 <int-e> > let f 0 = 1; f (n+1) = f n + 4 in f 3
09:55:55 <lambdabot> 13
09:56:00 <Taral> I've seen languages with _ as unary minus.
09:56:04 <int-e> I meant n+k patterns
09:56:07 <Taral> So _1 is negative one, but -1 is minus one.
09:56:15 <int-e> I don't mind using constants as patterns ... hmm.
09:56:18 <twb> I prefer to use the SUPERSCRIPT ONE character.
09:56:21 <Taral> n+k is a valid pattern?
09:56:21 <Cale> twb: hyphen-minus as unary minus, proper unicode minus as minus :)
09:56:29 <Taral> ewwwww!
09:56:32 <int-e> Taral: for integers k, yes.
09:56:36 <chrisbrown> thanks for your help everyone - this is making more sense now
09:56:43 <neologism> Taral: hows (-42) and (- 42) different?
09:56:47 <int-e> Taral: and I agree
09:56:49 <Taral> neologism: I want them different.
09:56:49 <Igloo> I like -3 as a single lexeme, (- 3) as (subtract 3) and ~ as the prefix subtract operator
09:56:55 <dcoutts> gour, ok, thanks
09:56:55 <neologism> how different?
09:56:59 <int-e> Taral: but there are people that don't.
09:57:05 <Saulzar_> One space as function application, two as function composition
09:57:05 <Taral> yes, yes.
09:57:05 <syntaxfree> > takeWhile (\x->x!='<') "Please cut this text when the <i>first tag</i> appears"
09:57:06 <lambdabot>  Not in scope: `!='
09:57:06 <neologism> a valua and a function?
09:57:08 <Taral> can't please everyone.
09:57:14 <syntaxfree> @type (!=)
09:57:15 <lambdabot> Not in scope: `!='
09:57:18 <Taral> @type (/=)
09:57:19 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:57:25 <syntaxfree> > takeWhile (\x->x/='<') "Please cut this text when the <i>first tag</i> appears"
09:57:27 <lambdabot> "Please cut this text when the "
09:57:27 <Cale> Saulzar_: hehehe
09:57:34 <Cale> Saulzar_: that's a *great* idea
09:57:40 <xerox> Cale: I got a new example for fmap, hehe.
09:57:51 <syntaxfree> > dropWhile  (\x->x/='<') "Please cut this text when the <i>first tag</i> appears"
09:57:53 <lambdabot> "<i>first tag</i> appears"
09:57:56 <Saulzar_> There is a joke paper around about C++ whitespace overloading, which goes on to describe newline overloading and then consequences of a 3D text buffer 
09:58:00 <xerox> > Data.Tree.unfoldTree (\b -> if b < 3 then (b,[b+1]) else (b,[])) 0
09:58:01 <int-e> Saulzar_: hmm, have you read the seminal paper on whitespace overloading by Stroustrup?
09:58:02 <lambdabot> Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {
09:58:02 <lambdabot> rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []}]}]}]}
09:58:08 <xerox> > (+1) `fmap` (Data.Tree.unfoldTree (\b -> if b < 3 then (b,[b+1]) else (b,[])) 0)
09:58:09 <lambdabot> Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {
09:58:09 <lambdabot> rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []}]}]}]}
09:58:09 <Saulzar_> int-e, Yep :)
09:58:11 <xerox> :-D
09:58:52 <syntaxfree> I'm trying to write something that uses the del.icio.us API. Do you think i ts better to write a quick and dirty XML parser, or I'm better off using HaXML orsomething?
09:59:07 <Cale> syntaxfree: HaXML or something :)
09:59:26 <Cale> Parsing XML properly seems like a nightmare better left to someone else
09:59:29 <syntaxfree> How much "theory" do I need to know? 
09:59:46 <syntaxfree> it seems simple to do stuff with takewhile/dropwhile. I know exactly what to expect from del.icio.us
09:59:57 <SamB> HXT?
10:00:14 <xerox> THX.
10:00:40 <SamB> which is to say, I would tentatively suggest using HXT
10:01:24 <dcoutts> gour, spamassassin 2.55 is available on haskell.org and which shuld work with one of those WP spam plugins you suggested
10:01:48 <syntaxfree> how complicated is it?
10:02:05 <syntaxfree> @google  HXT
10:02:06 <lambdabot> http://filext.com/detaillist.php?extdetail=HXT
10:02:12 <syntaxfree> @where HXT
10:02:13 <lambdabot> I know nothing about hxt.
10:02:37 <SamB> @google haskell xml toolkit
10:02:38 <lambdabot> http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
10:02:57 <Taral> @where HaXml
10:02:58 <lambdabot> http://haskell.org/HaXml
10:03:29 <SamB> hmm
10:03:40 <Taral> @google HXT haskell
10:03:41 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
10:03:42 <SamB> @google "haskell xml toolkit"
10:03:44 <lambdabot> http://lists.xml.org/archives/xml-dev/200111/msg00244.html
10:03:58 <SamB> hmm.
10:03:59 <Taral> @where+ HXT http://www.fh-wedel.de/~si/HXmlToolbox/
10:04:00 <lambdabot> hxt ~> http://www.fh-wedel.de/~si/HXmlToolbox/
10:04:06 <syntaxfree> do I need to learn fancy specs and custom data types? :~  I just want (Key, Value) pairs from <Key>Value</Key>  XML lines :~
10:05:26 <Cale> syntaxfree: well, you're free to write it however you like :)
10:05:36 <syntaxfree> I know :)
10:05:41 <dcoutts> gour, apparently the current setting of '0' in the comment links field means that everything gets sent to you for moderation.
10:05:47 <syntaxfree> I just don't want to get knee-deep in XML yet.
10:05:58 <SamB> syntaxfree: well, try out HXT
10:05:59 <syntaxfree> I just want to pick up data from del.icio.us for some clustering analysis.
10:06:02 <Cale> syntaxfree: you could go with Parsec as an intermediate
10:06:13 <syntaxfree> @where Parsec
10:06:13 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
10:06:16 <SamB> HXT does all the parsec for you ;-)
10:06:34 <SamB> syntaxfree: its also in your GHC libs, most likely
10:06:40 <syntaxfree> it's funny that google for parsec returns a Haskell result by default.
10:06:41 <xerox> Hire someone.
10:06:46 <SamB> but you will want the docs from daan's website?
10:07:16 <SamB> er.
10:07:21 <SamB> ignore question mark!
10:07:26 * SamB thinks he was distracted
10:07:31 <syntaxfree> instead of, say, something like metrology or physics.
10:08:05 <syntaxfree> Parsec or HXT?
10:08:11 <SamB> probably something to do with link text containing "parsec"
10:08:45 <syntaxfree> it's probably because I said @where,  not @google.
10:08:56 <SamB> I mean, many astronomical sites may use the term, but they don't go around linking to a particular page all the time when they mention it...
10:09:10 <SamB> @google parsec
10:09:11 <gour> dcoutts: true, but everything is porn spam
10:09:11 <lambdabot> http://www.parsec.org/
10:09:15 <SamB> I think thats a game
10:09:17 <SamB> actually
10:09:42 <SamB> which is also the kind of thing that tends to have an undisputed website
10:10:37 <syntaxfree> I was wondering the other day.
10:10:45 <syntaxfree> How haskell.org came to be an undisputed website?
10:10:56 <syntaxfree> I'd guess different organizations would fight for the domain.
10:11:14 <Cale> hm?
10:11:27 <Philippa_> there wouldn't be much room for it if it included all or even most of the authors of the Report
10:11:30 <syntaxfree> who owns haskell.org, and how come no one disputes it?
10:11:38 <Cale> The Haskell community is pretty small
10:11:41 <palomer> I dispute it.
10:11:45 <Philippa_> thing is, there's not much room for a serious challenge
10:11:59 <Philippa_> you can't claim it's held by those with no right to it, or that it's not promoting the haskell language
10:11:59 <Cale> This web site is a service to the Haskell community. The site is maintained by John Peterson and Olaf Chitil.
10:12:02 <palomer> haskell is my second middle name! the domain is mine!
10:12:20 <syntaxfree> all hail Peterson & Chitil.
10:12:41 <syntaxfree> @hawiki Parsec
10:12:41 <lambdabot> http://www.haskell.org/hawiki/Parsec
10:12:52 <palomer> why is everyone going bonkers over parsec?
10:13:05 <Cale> palomer: right now?
10:13:21 <palomer> yeah
10:13:31 <SamB> palomer: it is the errors
10:13:41 <Cale> syntaxfree was asking about means for parsing XML produced in relation to del.icio.us
10:14:06 <Cale> so the first thing that was suggested was one of the XML toolkits
10:14:21 <syntaxfree> Someone suggested I probably had Parsec already. Apparently I dont.
10:14:28 <Cale> syntaxfree: you do
10:14:44 <Cale> syntaxfree: assuming that you have GHC
10:14:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
10:14:55 <SamB> haskell.org is controlled by Haskell community leaders and open to hosting all sorts of things -- why would it be disputed?
10:15:38 <syntaxfree> Mingus:~ syntax$ ghc --version
10:15:40 <syntaxfree> The Glorious Glasgow Haskell Compilation System, version 6.4.1
10:16:02 <SamB> syntaxfree: how did you try to import it?
10:16:08 <syntaxfree> Prelude> :module + Parsec
10:16:08 <syntaxfree> Could not find module `Parsec':
10:16:14 <SamB> no wonder
10:16:30 <SamB> :m +Text.ParserCombinators.Parsec
10:16:41 <syntaxfree> oh.gooody.
10:16:43 <palomer> by going bonkers, I mean "why does everyone think parsec is the best thing since sliced bread"
10:17:02 <Cale> palomer: simply because, as far as parsing goes, it is
10:17:07 <SamB> palomer: because sliced bread gives horribly uninformative error messages?
10:17:16 <twb> it is what?
10:17:28 <Oejet> Because sliced bread is not type safe?
10:17:30 <Cale> twb: "the best thing since sliced bread"
10:17:48 <twb> Sliced bread does not make a good parser, IME.
10:17:48 <SamB> besides which, sliced bread is not able to parse the least thing?
10:17:55 <twb> Although it runs netbsd pretty well.
10:18:05 <SamB> it does, does it?
10:18:08 <palomer> I'm sure sliced bread can at least parse the least thing
10:18:14 <twb> I don't wish to know that!
10:18:25 <Cale> There are some really neat parsing libraries based on Arrows, but I'm not sure about how polished they are
10:18:29 * SamB thought it was the toaster that ran netbsd, not the bread
10:18:29 * Oejet can parse sliced bread.  Even non-sliced too.
10:18:47 <palomer> in soviet russia, sliced bread parses you!
10:18:48 <twb> @arrows
10:18:48 <lambdabot> Unknown command, try @listcommands.
10:18:56 <twb> @hawiki arrows
10:18:57 <lambdabot> http://www.haskell.org/hawiki/arrows
10:18:59 <Oejet> SamB: You can hotswap the bread where the kernel runs. 8-)
10:19:11 <Cale> haskell.org/arrows
10:19:13 <SamB> Oejet: I thought you needed to use RAM for that 
10:19:15 <Lemmih> @where arrows
10:19:16 <lambdabot> http://www.haskell.org/arrows/
10:19:58 <SamB> the only arrow based parsing library I saw was horrid
10:20:07 <twb> "More general than monads"?  /me cowers.
10:20:27 <Lemmih> Arrows are for functions as monads are for valies.
10:20:41 <Lemmih> Tsk. Ignore me and my typoes.
10:20:51 <xerox> Lemmih: please retry :-)
10:21:01 * Lemmih takes off to get some food.
10:21:08 <xerox> Have fun.
10:23:07 <Cale> mountains are for valleys
10:23:16 <syntaxfree> hmm. Parsec is already a lot more wizardly than what I expected.
10:23:22 <syntaxfree> but maybe it's good for me to dig into it.
10:23:28 <SamB> syntaxfree: it is fun!
10:23:39 <syntaxfree> yes, it looks exciting.
10:23:42 <SamB> and you get delightful error messages with ease!
10:24:05 <syntaxfree> I needed to convert <Key>Value</Key> to (Key, Value) to begin with, but I'm getting excited about this.
10:26:00 <Taral> How do you add an @quote?
10:26:26 <SamB> @remember Taral How do you add an @quote?
10:26:32 <SamB> @quote Taral 
10:26:33 <lambdabot>  How do you add an @quote?
10:26:39 <Taral> >:|
10:26:52 <Taral> @remember SamB because sliced bread gives horribly uninformative error messages?
10:27:03 <Taral> see, it needs context though :(
10:27:04 <SamB> you can @forget or @disremember or somesuch
10:27:09 <Taral> @forget SamB because sliced bread gives horribly uninformative error messages?
10:27:10 <lambdabot> Unknown command, try @listcommands.
10:27:19 * SamB likes his better anyway
10:27:21 <Taral> @disremember SamB because sliced bread gives horribly uninformative error messages?
10:27:21 <lambdabot> Unknown command, try @listcommands.
10:27:24 <Taral> @quote SamB
10:27:25 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
10:27:25 <lambdabot> printed
10:27:32 <Taral> @unremember SamB because sliced bread gives horribly uninformative error messages?
10:27:41 <astrolabe> @eval 1
10:27:42 <lambdabot> 1
10:27:46 <Taral> @unremember Taral How do you add an @quote?
10:27:48 <Taral> @quote Taral
10:27:48 <lambdabot>  How do you add an @quote?
10:27:53 <Taral> hm
10:28:04 <xerox> ...forget, maybe?
10:28:05 <palomer> an quote?
10:28:07 <SamB> maybe that adds it agean?
10:28:10 <arjanb> @help quote
10:28:18 <xerox> palomer: 'an at-quote' ;-)
10:28:26 <SamB> stupid spellchecker
10:28:35 <SamB> @listcommands quote
10:28:40 <SamB> > 1
10:28:45 <xerox> @help quote
10:28:53 <Taral> oh, wow
10:28:54 <xerox> @let's-flood-lambdabot
10:29:00 <Taral> lambdabot is single-threaded?
10:29:26 <astrolabe> I can't seem to msg lambdabot
10:29:27 <int-e> @botsnack
10:29:31 <SamB> huh
10:29:35 <SamB> maybe we killed it?
10:29:43 <int-e> it's busy handling my @listcommands right now
10:29:53 <Taral> it seems to block on @listcommands
10:29:58 <int-e> which takes a while at 2 seconds per line :/
10:30:00 <SamB> huh
10:30:03 <SamB> why?
10:30:13 <Taral> if it's going to wait like that, it should do other work in the mean-time.
10:30:15 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
10:30:16 <lambdabot> Quote somebody, or a random person, or save a memorable quote
10:30:22 <lambdabot> quote provides: fortune yow arr
10:30:25 <lambdabot> 1
10:30:26 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
10:30:29 <lambdabot> Quote somebody, or a random person, or save a memorable quote
10:30:32 <lambdabot> Unknown command, try @listcommands.
10:30:34 <lambdabot> :)
10:30:34 <int-e> so just stop messaging lambdabot and let its queue cool down :)
10:30:37 <xerox> Boom boom-cha.
10:30:43 <dcoutts> @seen JaffaCake
10:30:44 <lambdabot> I saw JaffaCake leaving #haskell 6 days, 1 hour, 51 minutes and 40
10:30:44 <lambdabot> seconds ago, and I have missed 3 days, 7 hours, 3 minutes and 33 seconds
10:30:44 <lambdabot> since then.
10:30:49 <SamB> @listmodules
10:30:50 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
10:30:50 <lambdabot> karma localtime more pl plugs poll quote search seen spell state system
10:30:50 <lambdabot> todo topic type version vixen where
10:31:07 <SamB> @listcommands fact
10:31:08 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-
10:31:08 <lambdabot> update
10:31:34 <int-e> SamB: if you privmsg lambdabot with an @listcommands it lists all commands for all modules - I guess it shouldn't do that.
10:31:53 <SamB> int-e: it should at least spawn a thread for it...
10:31:56 <SamB> if thats even possible
10:31:58 <bosie> insert :: Tree (g,d) -> Int -> Tree (a,b) 
10:31:58 <bosie> insert Nil x = (Node (5,"F") (Nil) (Nil))
10:31:58 <bosie> insert (Node (d,e) h f) x = (Node (d,e) h f)
10:32:15 <bosie> what does "cannot unify the type-signature" mean ?
10:32:16 <SamB> maybe it should DCC SEND a file with all the commands listed in it
10:32:21 <int-e> SamB: it blocks the bot for 70 seconds. (25 lines)
10:32:26 <int-e> 35
10:32:28 <SamB> but then lambdabot would need DCC support
10:32:48 <Taral> dcc is not hard
10:32:56 <Taral> but it doesn't work well w/ nat/firewalls
10:32:59 <xerox> Print an url of the wiki where commands are explained.
10:33:00 <SamB> true!
10:33:02 <SamB> oh.
10:33:06 <SamB> is there such an url?
10:33:13 <Taral> I wonder if anyone's written a haskell irc client.
10:33:16 <xerox> If someone writes it...
10:33:16 <SamB> which is up-to-date?
10:33:18 <SamB> yes!
10:33:21 <SamB> someone has.
10:33:24 <Taral> @where irc
10:33:25 <lambdabot> I know nothing about irc.
10:33:29 <Taral> @google irc haskell
10:33:30 <lambdabot> http://haskell.org/hawiki/HaskellIrcChannel
10:33:32 <SamB> they ripped off lambdabot's code for it, though
10:33:35 <Taral> bah
10:33:37 <int-e> dcc would require handling additional tcp connections ...
10:33:39 <SamB> and its not maintained anymore
10:33:49 <int-e> it would require handling connections *to* the bot
10:33:54 <SamB> int-e: thats the easy part
10:34:07 <SamB> the hard part is keeping track of outstanding offers
10:34:59 <Taral> there's no unremember :(
10:35:52 <xerox> Taral: ping dons.
10:37:15 <SamB> dons doesn't usually get up for a couple more hours, I think
10:38:02 <Cale> SamB: Did you see PArrows, or something else?
10:38:30 <SamB> Cale: PArrows
10:39:02 <Cale> I can't get Swierstra and Duponcheel's original paper, as the only place I could get it from doesn't seem to reach back far enough.
10:39:21 <Cale> Does anyone have a digital copy of it?
10:39:38 <Cale> SamB: what's wrong with PArrows?
10:39:54 <Cale> (I have to admit that I haven't used it, but it did look cool)
10:39:57 <SamB> Cale: it didn't seem to wrok quite right
10:40:19 <SamB> so, try it before claiming it is the coolest things since leavened bread ;-)
10:40:42 <Cale> well, what's a problem with it that I could test?
10:41:33 <SamB> don't rightly remember!
10:41:35 <int-e> SamB: what's next? crumbled bread?
10:42:03 <SamB> but I don't think you can easily miss it if you actually try to do anything real...
10:42:12 <SamB> int-e: matza
10:42:22 <SamB> going backwards, you see
10:42:35 <SamB> I'm presuming that leavened bread was invented second
10:44:59 <syntaxfree> I don't understand do/return notation :'(
10:45:08 <syntaxfree> I wonder if HXT is any friendlier.
10:45:19 <syntaxfree> @where hxt
10:45:19 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
10:46:33 <Cale> syntaxfree: have you used monads at all?
10:47:00 <syntaxfree> I've used IO and random  numbers, without much knowledge of the underlying monadic stuff.
10:47:17 <Cale> okay, well, Parser is a monad
10:47:30 <Cale> Parsers do some parsing and then return a value
10:47:57 <Cale> you have basic parsers like char which parses a single character
10:48:19 <syntaxfree> yes. 
10:48:21 <Cale> and you parse things in sequence using >> or by listing them in a do block
10:48:30 <syntaxfree> I get most of that.
10:48:35 <syntaxfree> except do blocks.
10:48:38 <Cale> oh
10:48:47 <Cale> do {x; y} = x >> y
10:49:10 <Cale> do {v <- x; y} = x >>= \v -> y
10:49:10 <syntaxfree> ah.
10:49:26 <Cale> just syntax sugar
10:49:35 <robajs> hello
10:49:38 <Cale> hello
10:49:42 <syntaxfree> anyway, this stuff is exciting, but sounds like overkill.
10:49:47 <syntaxfree> I should learnit some day, though.
10:49:56 <SamB> syntaxfree: but isn't it delightful?
10:50:01 <Cale> syntaxfree: somewhat overkill, but easier to use in the end than writing things y hand
10:50:03 <SamB> I overkill everything with it!
10:50:03 <syntaxfree> yes :)
10:50:16 <SamB> except the things which it isn't overkill for, of course
10:50:30 <syntaxfree> while I understand the "practical" aspects of monadic programming, it is far from second nature to me.
10:50:50 <Philippa_> you sorta get used to the more tedious syntactic aspects of it
10:51:06 <Philippa_> second nature is mostly about practice
10:51:13 <syntaxfree> I have to ask a stupid question, lest I get all of it wrong.
10:51:13 <Oejet> robajs: Welcome.
10:51:13 <SamB> syntaxfree: it isn't second nature for a while
10:51:23 <Philippa_> yeah, that's okay
10:51:28 <SamB> stupid questions are encouraged
10:51:33 <syntaxfree> What, precisely, is a parser?
10:51:47 <Philippa_> something that recognises the structure of a sentance in some language
10:51:56 <Philippa_> (for values of sentance that might include an entire program)
10:52:05 <SamB> I don't remember the last time I saw a stupid question, though
10:52:26 <SamB> syntaxfree: something to parse things with
10:52:27 <syntaxfree> well, that's what I have in mind about a parser too.
10:52:58 <SamB> its like a recognizer that returns a value
10:53:00 <Oejet> robajs: Are you interested in Haskell?
10:53:01 <int-e> syntaxfree: it also returns something that describes the thing that was parsed.
10:53:18 <Cale> usually parsers actually also return a value, which is often an abstract representation of the sentence that was parsed
10:53:37 <syntaxfree> why do you need to use monads for it?
10:53:39 <int-e> syntaxfree: (well, the relation is not mandatory of course, but it wouldn't make much sense to write a parser that always returns 42)
10:53:42 <SamB> syntaxfree: you don't
10:53:47 <SamB> thats purely for convenience
10:53:48 <Cale> syntaxfree: monads are merely convenient
10:53:48 <syntaxfree> can't it be simply a function transforming data structures?
10:53:56 <SamB> it is
10:54:03 <SamB> in a newtype shell
10:54:15 <SamB> so as to make it bulletproof
10:54:15 <Philippa_> syntaxfree: there's nothing you *need* to use monads for, ever
10:54:19 <Philippa_> there're many things where it's convenient
10:54:20 <robajs> Oejet: yes, but not limited to haskell only :-)
10:54:22 <Cale> syntaxfree: a few of those functions most commonly used have types which are consistent with being a monad
10:54:29 <Philippa_> (even with IO there're other ways to get the linearity constraint monads give)
10:54:46 <Cale> monads are something that you want
10:55:02 <SamB> syntaxfree: at the very least, it saves you from a longer-winded sequencing operator than >>
10:55:06 <syntaxfree> I've treated monads as black  magic boxes so far.
10:55:09 <Cale> since they help structure computations uniformly, and let you write general algorithms
10:55:25 <SamB> syntaxfree: which is a good idea, because thats just what they are most often
10:55:25 <Cale> most monads aren't black boxes
10:55:29 <Cale> hehe
10:55:34 <syntaxfree> or pseudoimperative boxes.
10:55:39 <Oejet> robajs: I see you on at least two other channels. ;-)  What makes curious about Haskell in particular?
10:55:48 * Cale contradicts SamB :)
10:55:49 <SamB> well, some of them are carelessly left unblack
10:56:20 <Cale> Well, any monad which is completely black is uninteresting
10:56:28 <syntaxfree> racism!
10:56:28 <SamB> well yes
10:56:34 <SamB> thats what the blinking lights are for
10:56:37 <int-e> IO ...
10:56:47 <Cale> If all that your type supports is the monad operations, you're not getting anywhere
10:56:54 <SamB> syntaxfree: we have a stronger definition of black than that used to include people
10:57:06 <syntaxfree> I was joking.
10:57:06 <Philippa_> syntaxfree: most monads are implemented in Haskell, and so they're only as black as the abstraction around their datatype
10:57:23 <SamB> namely, it absorbs or reflects all incident light
10:57:32 <Cale> absorbs
10:57:45 <Cale> :)
10:57:50 <syntaxfree> are you trying to rob afro-humans of their ethnic identity?
10:58:00 <Cale> heh
10:58:01 <robajs> Oejet: Im doing some personal "research" on functional programming and deciding which one schould be my native :-)
10:58:09 <SamB> no
10:58:16 <SamB> its just a different usage
10:58:23 <SamB> they can still refer to themselves as black
10:58:30 <SamB> anyway, they aren't boxes
10:58:41 <int-e> they're more like bubbles *g*
10:58:52 <Cale> robajs: Haskell is a great choice, a lot of the cool research goes into Haskell.
10:59:02 * araujo wonders if function names 18 letters long is abusive.
10:59:16 <int-e> bubbles are wobbly and less well defined than boxes ;)
10:59:16 <Cale> araujo: depends how often they're used
10:59:27 <syntaxfree> functions with names like aaa aab aac, etc. are more abusive.
10:59:29 <SamB> araujo: it depends on whether you need 18 letters to differentiate it from others
10:59:53 <Cale> not just differentiate it, but it should be clear what it's for
10:59:56 <araujo> Cale, It is only used once
11:00:02 <SamB> thats fine then
11:00:03 <Cale> 18 letters is fine then
11:00:16 <araujo> Yes, i want it to explictly state what it is used for
11:00:17 <araujo> Good.
11:00:18 <SamB> if nobody else has to use it, they won't care ;-)
11:00:32 <Cale> CanonicalRepresentativeDeterminatorOfExternalSet
11:00:38 <araujo> hah
11:00:38 <SamB> it might make a decent Haddock annotation more work
11:00:38 <superibor> What trick (or GHC extension) can help me to make the following work?: "instance (Ord s, Show s) => Symbol s"
11:00:40 <Cale> is a builtin function in GAP
11:00:52 <Cale> CentralizerInAssociativeGaussianMatrixAlgebra
11:00:59 <araujo> > length "CanonicalRepresentativeDeterminatorOfExternalSet"
11:01:01 <lambdabot> 48
11:01:02 <SamB> superibor: whats the trouble?
11:01:04 <araujo> hah
11:01:09 <SamB> what is "class Symboll"?
11:01:14 <SamB> er.
11:01:18 <SamB> modulo extra ls
11:01:40 <robajs> Cale: research in haskell is cool, but I need some real worl usefulnes (read get the job done even with dirty hands :-)
11:01:42 <superibor> SamB it's about parsers too. Anyway, class Symbol represents the symbols for the parser. It's just an empty class
11:01:44 <Cale> AugmentedCosetTableNormalClosureInWholeGroup
11:01:55 <SamB> superibor: oh
11:02:06 <int-e> superibor: does just adding a where at the end help?
11:02:12 <Cale> robajs: cool, it has a bit of that too
11:02:21 <araujo> Cale, i am just not used to use long names for funcs.
11:02:27 <SamB> int-e: you don't need a where unless you want to use
11:02:28 <Cale> robajs: I wrote a pipeline scheduler for PPC+Altivec in Haskell
11:02:29 <SamB> it
11:02:35 <superibor> this is not allowed in Haskell. it's necessary to put a type constructor as an instance, that's the problem
11:02:39 <jethr0> robajs, i had my doubts about real world haskell use as well, but after seing how well AND clean IO can be done in haskell i am converted
11:02:54 <Cale> robajs: which was about 1200 lines, and about half of that is documentation
11:03:04 <superibor> I was wondering if there was any trick around that limitation of the type system
11:03:06 <jethr0> FFI works like a charm in haskell without much syntactical or semantical overhead
11:03:10 <SamB> superibor: oh
11:03:22 <int-e> SamB: right. 'instance' is no exception - I was wondering if it could be one
11:03:41 <syntaxfree> robajs: what are other languages you're looking into?
11:03:42 <Cale> superibor: -fglasgow-exts?
11:03:49 <syntaxfree> robajs: MLs? All pure?
11:03:56 <jethr0> cale, there's only one doubt i have concerning haskell
11:03:57 * SamB wonders if "module Foo" is a valid Haskell module
11:04:04 <SamB> (with no "where" ever)
11:04:06 <Cale> possibly with -fallow-undecidable-instances
11:04:14 <robajs> syntaxfree: ocaml, clean, erlang, mercury, scheme
11:04:20 <jethr0> and that is with deeply nested pure functions where you decided late in the process that you'll need IO in a very deep hierarchy.
11:04:26 <SamB> Cale: I think its -overlapping-
11:04:30 <SamB> not -undecidable-
11:04:30 <int-e> SamB: no it's not
11:04:34 <jethr0> how do you cleanly deal with the ensuing typing troubles?
11:04:41 <syntaxfree> Scheme is fun and very easy to learn. Its not purely functional, though.
11:04:42 <SamB> possibly both
11:04:52 <superibor> Cale indeed, thkx
11:04:56 <Saulzar_> jethr0, I guess you can return IO actions ...
11:04:57 <syntaxfree> A Scheme+PostGreSQL combination is often used in web servers as an alternative to LAMP. 
11:05:24 <jethr0> yes, but you might have to rewrite LOTS of functions to handle IO...
11:05:30 <robajs> my daily work is network security and distributed networks of all kind. Some low level access to network is also required :-)
11:05:41 <Cale> robajs: Take a look at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html to see just the libraries that come with GHC these days :)
11:05:49 <jethr0> like when you choose to use a random generator in a deeply nested function, on which many others rely
11:05:50 <Saulzar_> jethr0, But they can be wrapped up and stored as any other data type
11:06:35 <SamB> Saulzar_: but you don't tend to pass things into the depth of your program unless you need to
11:06:41 <SamB> jethr0: relax ;-)
11:07:01 <syntaxfree> robajs: why are you interested in FP?
11:07:10 <jethr0> hehe, just wondering whether that's gonna bite me in the ass when doing speed optimizations!
11:07:13 <SamB> the type errors are there to help you through this process of ripping apart your program and putting it together again ;-)
11:07:17 <Saulzar_> You can always use a pseudo random number generator I guess, or generate an infinite list and use that later
11:07:50 <jethr0> sure, but for that you might to change the whole way your functions are called
11:08:11 <SamB> jethr0: yes.
11:08:13 <Saulzar_> jethr0, I'm not sure Haskell does wonderfully with speed optimizations in any case unless you are a guru :)
11:08:15 <int-e> jethr0: well you're also making a significant change to the behaviour of those functions
11:08:22 <SamB> which is what the type errors are for.
11:08:25 <SamB> you can't DO that in Python.
11:09:06 <jethr0> sure, and as i've said i am a great fan of haskell's. especially after seeing how well FFI and IO work.
11:09:36 <jethr0> the question is just how well speed optimisations using IO as an afterthought works in haskell.
11:09:56 <Philippa_> the number one thing is that the type system will really help you find all the places you need to modify
11:10:08 <robajs> syntaxfree: I have seen some examples of the way of doing things and definitely like it. (btw Im primary C coder and I have enough of it :-)
11:10:14 <Philippa_> depends how dirty you're willing to be, and how much time you spend in some kind of monad anyway
11:10:38 <jethr0> true, but adding an additional parameter and patching it through correctly to 10s if not 100s of functions might not be practical
11:10:41 <Philippa_> I do quite like "return an IO action and run it outside" as a strategy, it's great if you've got IO going on inside a parser for example
11:10:57 <Philippa_> (Flippi will soon be doing that)
11:11:28 <int-e> jethr0: if you expect that to happen you can wrap up your environment in a monad
11:11:31 <Cale> I wish Parsec was a monad transformer
11:11:47 <Philippa_> yeah, that would be useful
11:11:49 <int-e> jethr0: then you can extend that monad without modifications to the code
11:11:56 <Philippa_> the return-an-action strategy doesn't work too well for #include
11:11:58 <jethr0> int-e, i know, but programming has a lot to do with the unpredictable, doesn't it
11:12:04 <Cale> I've never actually looked at the source of it, but it doesn't seem like something which would be impossible.
11:12:06 <jethr0> and i don't want to _everything_ in monads
11:12:14 <Philippa_> why not?
11:12:31 <Philippa_> Cale: probably not, it's effectively state+minor control flow work
11:12:36 <jethr0> because i like pure functions ;-))
11:13:01 <Cale> Philippa_: yeah
11:13:10 <Philippa_> jethr0: the identity monad is your friend ;-)
11:14:00 <int-e> jethr0: if your function is pure, conceptually, why will you need additional arguments passed into it later?
11:14:12 <SamB> jethr0: just be mindful that random numbers require plumbing
11:14:27 <araujo> haha, rulez
11:14:28 <araujo> http://www.willamette.edu/~fruehr/logos/PNGs/RealHackers.png
11:14:39 <Cale> jethr0: monads apart from those involving IO are purely functional
11:15:12 <jethr0> int-e, because i might have to pass stuff to a function that has become non-pure and is called through this one...
11:15:47 <int-e> then your function isn't pure to begin with. you can't pass such stuff to a pure function and use it
11:15:47 <SamB> jethr0: you could just pass random seeds...
11:15:56 <Cale> If you have a state parameter that you're passing around, it's always better to use a state monad.
11:16:34 <astrolabe> Cale: why?
11:16:40 <jethr0> hmm, i'm not being specific. just voicing my worries that changes after the fact can be more disruptive in haskell than in other languages
11:16:52 <SamB> jethr0: maybe so!
11:16:52 <jethr0> typing not considered (for which haskell obviously rules)
11:16:56 <SamB> or maybe less.
11:17:01 <jethr0> hehe
11:17:23 <SamB> the typing helps you to make sure you change everyplace that needs changing, so may balance out the upheaval
11:17:30 <int-e> jethr0: in other languages you might end up with buggy code that doesn't work, but being unable to track down the cause
11:17:33 <jethr0> i understand that
11:18:18 <jethr0> but imagine that you find your bottleneck deep in the function call hierarchy and substitute it by an FFI call to a c function, but don't want to use unsafePerformIO
11:18:23 <SamB> and I really think that you have to rip apart programs written in other languages more often
11:18:31 <Cale> astrolabe: because it's the same thing, only you make sure that the parameter is handled sanely
11:18:33 <jethr0> then _everything_ atop that function has to move to IO, right?
11:18:34 <SamB> or at least, should
11:18:53 <int-e> jethr0: you can have safe calls to C code ...
11:18:53 <SamB> but those other languages let you be lax and put it off...
11:18:55 <Taral> jerthr0: FFI allows you to define SEF calls that therefore aren't imported into the IO monad.
11:18:56 <Cale> jethr0: if you find that, then you've made a mistake in your design
11:19:30 <jethr0> cale, it's impossible to foresee a bottleneck with certainty in your design!
11:19:37 <Cale> jethr0: If your C function isn't referentially transparent, then you really have no business calling it from pure code
11:19:38 <SamB> jethr0: foreign import can unsafePerformIO for you. or maybe it avoids the issue entirely, I'm not sure...
11:19:43 <jethr0> and if you do, it's most likely bad design ;-)
11:19:47 <Cale> and you shouldn't even want to
11:19:49 <int-e> jethr0: of course that means the interface that the C code provides is actually functionally pure. (FFI is a good way to shoot yourself into the foot - there's no way to help that)
11:19:49 <jethr0> if you try to*
11:20:11 <Cale> If it *is* referentially transparent, then that's exactly what unsafePerformIO is for
11:20:25 <SamB> jethr0: maybe what your design needs is not to have a bottleneck done in C, but rather to be refactored so that the bottleneck simply disappears
11:20:26 <jethr0> i understand, but have alot of respect for inadvertantly breaken ref. transparency
11:20:38 <jethr0> breaking*
11:20:48 <xerox> I have respect for elders
11:20:53 <int-e> jethr0: but then you should appreciate having to change all those functions :)
11:20:54 <jethr0> ya, bad grammar, i know
11:21:02 <SamB> anyway, there is nothing wrong with using a design with a predictable bottleneck
11:21:03 <Cale> oh, you mean a performance bottleneck
11:21:11 <Cale> I wasn't reading that correctly
11:21:14 <SamB> as long as you aren't afraid to change it
11:21:32 <Cale> Whatever you replace it with will almost certainly be referentially transparent.
11:21:49 <Cale> Since you're writing a replacement for code that was referentially transparent
11:21:49 <jethr0> ok, but one should be careful with this stuff.
11:21:54 <Cale> well sure
11:22:08 <jethr0> because if your c function is _not_, then you'll have a really hard to trace problem on your hands!
11:22:09 <Cale> C is a terrible language for ensuring program correctness
11:22:24 <xerox> fortune = unsafePerformIO (randomIO)
11:22:27 <Cale> If you want to be sure that your program is correct, you shouldn't use C
11:22:30 <robajs> I'm a little bit skeptical on haskell performance on Gbps traffic analysis. any experiences in this area?
11:22:52 <jethr0> so, in summary, you guys don't think that late optimisations in haskell are problematic?
11:23:06 <jethr0> cale, great ;-)
11:23:50 <SamB> jethr0: well, maybe sometimes they are
11:24:15 <SamB> but I'm pretty sure its figuring out HOW to optimize rather than restructuring your program that is more difficult
11:24:18 <Cale> robajs: well, what kind of hardware are you running it on :) I think I'd be hard-pressed to write a C program which could process Gbps in a nontrivial way
11:24:40 <Cale> what kind of analysis too
11:24:56 <xerox> Checking if the checksum is a prime, of course.
11:25:05 <Cale> hehe
11:25:22 <SamB> DoTheSimplestThingThatCouldPossiblyWork, they say...
11:25:25 <Cale> Forming a parse tree for a theorem and testing to see if that theorem is true.
11:25:38 <Cale> I don't think so :)
11:25:39 <robajs> hw cam be some 2GHz xeon with 2gigs of ram
11:25:48 <araujo> @where cabal
11:25:48 <lambdabot> http://www.haskell.org/cabal
11:26:07 <Cale> robajs: well, Haskell has an FFI, so you can mix C and Haskell code to some extent
11:26:32 <robajs> I would like to begin with some basic statistical analysis :-)
11:26:36 <SamB> @google DoTheSimplestThingThatCouldPossiblyWork
11:26:37 <lambdabot> http://xp.c2.com/DoTheSimplestThingThatCouldPossiblyWork.html
11:26:45 <Cale> robajs: Haskell is really better at hard tasks which you don't mind running a bit slowly as long as you can be certain that they're done correctly.
11:27:30 <Cale> robajs: It's rather good for writing compilers for special-purpose languages, for example.
11:27:39 <Cale> (perhaps relevant example)
11:27:46 <SamB> maybe you could write a program to generate your traffic-analyzer
11:27:51 <Cale> yes
11:28:11 <jethr0> samb, i'm familiar with DTHSTTCPW
11:28:35 <SamB> jethr0: but so many here aren't familiar with XP ;-)
11:28:37 <robajs> SamB: that would be easier that write it directly? :-)
11:28:52 <int-e> XP could possibly work?
11:29:00 <SamB> robajs: you don't code in a hex editor, I'll wager
11:29:02 <Cale> robajs: possibly, if changes need to ever get made, and the thing needs to be *really* fast
11:29:06 <jethr0> sadly! test first development "has changed my life"
11:29:13 <jethr0> well, not really, but it's really neat *g*
11:29:31 <SamB> it seems to work so well in Haskell too
11:30:03 <SamB> remember also YAGNI
11:30:05 <jethr0> yup, even better, because due to pure functions there's less of a hassle with mock objects
11:30:20 <SamB> you aren't going to need a random number generator ;-)
11:30:26 <jethr0> :P
11:30:35 <SamB> no hassle with mock objects
11:30:46 <Cale> robajs: my pipeline scheduler was part of a special purpose compiler for signal processing apps (resampling/fft/etc.) which would need to run in realtime at around rates that you're talking about.
11:30:49 <SamB> there is no need for mock objects when there aren't any objects ;-)
11:31:25 <jethr0> *lalala*, anyways, unit testing pure functions is _way_ cooler than horribly tangled C++ code!
11:31:25 <Cale> robajs: eventually, the compiler will know about the network architecture available and optimize the paralellism automatically too -- at least, that's the plan
11:31:43 <robajs> Cale: interesting.
11:31:49 <SamB> I thought XP was designed for Smalltalk
11:32:17 * jethr0 doesn't think that the central points of XP are bound to a specific language.
11:32:25 <jethr0> but it's was developed for OO for sure
11:32:27 <Cale> robajs: I had it schedule some code for computing sine/cosine pairs down to 2.7 clocks/float
11:32:44 <robajs> Cale: the second _real_ candidate is ocaml. I must learn both and will see :-)
11:33:07 <SamB> perhaps not the central points
11:33:08 <jethr0> robajs, _really_ learning both might take some time!
11:33:18 <Cale> with ocaml, you can often get better performance than C++ in ocaml itself
11:33:48 <SamB> but they tend to work best in languages that allow flexible code to be written
11:33:55 <robajs> jethr0: I'm not going to be an expert in both
11:34:05 <SamB> i.e., you don't need to set everything in stone
11:34:50 <jethr0> robajs, even so, learning haskell to do bare-metal things fast, will require you to become somewhat experty
11:34:55 <Cale> If you don't know any other functional programming languages really well, it takes about a year of writing Haskell to really get up to speed to the point where you can write optimised code, find performance bottlenecks etc. That might be an underestimate too.
11:34:59 <palomer> Cale: in mlton you most often get better performance than C++
11:35:22 <Cale> palomer: yeah. The strict functional languages are doing quite well these days
11:35:30 <robajs> Cale: as fas as I understand from some examples of ocaml code, the C++ performance can be done only with _near procedural_ way of programming and for that I dont need ocaml. Then I would keep on C.
11:35:32 <palomer> (performance wise)
11:35:42 <Cale> robajs: okay :)
11:35:55 <jethr0> palomer, but mlton is a whole program compiler... so the edit-compile-run cycle might be somewhat sluggish with many libs involed...
11:35:58 <palomer> but really, the strict functional languages are nothing but a cleaner type system, datatypes and a different syntax
11:36:14 <palomer> jethr0: yeah, they're working on an interpreter to solve exactly that problem
11:36:17 <Cale> palomer: I disagree
11:36:29 <palomer> Cale: hmm?
11:36:35 <Cale> There's a big qualitative difference between lazy and strict programming
11:36:51 <palomer> Cale: I'm saying "compared to C++ and friends)
11:36:54 <Cale> oh
11:37:04 <Cale> okay
11:37:05 <Cale> :)
11:37:21 <Cale> I thought you were comparing Haskell to things like O'Caml
11:37:35 <jethr0> lazy/strict makes all the difference... although i don't think laziness helps much when it comes to performance optimizations of a mainly iterative problem
11:37:57 <Cale> Laziness helps structure nondeterminism immensely.
11:38:23 <jethr0> palomer, i guess that whole program compiling could get _lots_ of performance out of any language!
11:38:33 <Cale> You basically have arbitrarily structured coroutines which you don't have to think about too hard.
11:38:51 <Cale> and data structures become control-flow structures
11:39:09 <jethr0> cale, i agree, but for deterministic, iterative problems it can be more of a burden. 
11:39:22 <jethr0> but then you can "disable" it in haskell with "$!", seq and strict data types
11:40:00 <Cale> jethr0: iterative isn't so bad, it's when you're taking huge amounts of input and reducing it to a small value that you need some strictness.
11:40:14 <Cale> see, for example, 'sum'
11:40:28 * jethr0 loves how laziness helps organizing otherwise chaotic code into a very structured form
11:40:49 <jethr0> it's "separation of policy and mechanism" to the extreme!
11:40:56 <Cale> yeah :)
11:41:12 <Cale> typeclasses also help there
11:41:21 <jethr0> in what way?
11:41:52 <SamB> isn't that the point of laziness?
11:42:05 <Cale> well, in a different way :)
11:42:21 <SamB> hmm?
11:42:23 <SamB> oh.
11:42:29 <SamB> about typeclasses?
11:42:32 <Cale> You can present an abstract interface to something, define all important functions on it, and hide the implementation 
11:42:47 <Cale> in a really clean way
11:43:19 <Cale> which seems to me to be quite a bit more flexible than the OO way of doing that
11:43:20 <SamB> laziness lets you say "calculate this based on this" without worrying about the order things are calculated in;
11:43:28 <jethr0> sure, but that's kinda a given coming from OO languages, like many here likely do
11:44:01 <jethr0> or even the fact, that much of it might not be calculated _at all_
11:44:17 <Cale> yeah :)
11:44:21 <SamB> and that
11:44:30 <Cale> I like not having to order computations
11:44:39 <SamB> but type classes let you say "do this" but not worry about how or to what
11:44:52 <jethr0> cale, why would typeclasses be more flexible than "interface" and "implements"?
11:45:31 <jethr0> except for the fact, that java has a much less generic view on types
11:45:32 <Cale> jethr0: constructor classes like monad, for instance
11:45:38 <SamB> parametric polymorphism is why
11:45:47 <Cale> Or multiparameter typeclasses
11:46:00 <jethr0> ok
11:46:01 <Cale> possibly throw in some functional dependencies :)
11:46:14 <SamB> but even parametric polymorphism takes you further...
11:46:30 <Cale> yeah
11:46:49 <jethr0> i didn't mean to explicitely compare java to haskell...
11:46:52 <Cale> you can enforce all the invariants on a 2-3 tree with just plain Haskell data types
11:47:01 <SamB> I did ;-)
11:47:17 <SamB> Java's arrays are bolted-on
11:47:40 <jethr0> cale, but don't you often need your own constructor functions to handle value invariants?
11:48:06 <jethr0> like defining a vector data type that ensures, it only contains unit vectors...
11:48:30 <Cale> jethr0: that's true
11:48:31 <SamB> jethr0: and you can do this in Java?
11:48:37 <Cale> but you can often enforce quite a lot
11:48:40 <jethr0> i still haven't figured out how to hide the "constructor" and use your own, but still allow "destructing"
11:48:48 <Cale> jethr0: modules
11:48:50 <jethr0> samb, no, just asking
11:48:54 <SamB> jethr0: views!
11:48:56 <Cale> jethr0: Rational is a great example
11:48:57 <jethr0> cale, but how to destruct?
11:48:59 <SamB> only we don't have them
11:49:00 <Cale> oh
11:49:07 <Cale> you have to provide functions for that
11:49:09 <SamB> because nobody implemented them...
11:49:25 <Cale> The whole point of hiding the implementation is to prevent destructing :)
11:49:25 <jethr0> yes, but your own functions can't be used in pattern matching.
11:49:41 <Cale> but I know what you mean :)
11:49:52 <SamB> destructuring
11:50:09 <jethr0> cale, not if you only want to ensure some value invariants
11:50:23 <Cale> It would be awfully nice to have something like Views for that.
11:50:30 <SamB> yes!
11:50:43 <Cale> or something like Miranda's laws
11:50:50 <SamB> we should draft an implementor
11:50:55 <jethr0> is there actually a language review process going on to enhance the haskell98 standard?
11:51:11 <SamB> jethr0: they are collecting feature ideas
11:51:25 <Cale> there's already a lot of stuff implemented in GHC and Hugs which isn't in the standard at all
11:51:26 <SamB> that is, possible extensions
11:51:27 <jethr0> ok, but i guess it might take a while before it comes out, huh?
11:51:46 <Cale> Haskell is basically going to be way ahead of the standard most of the time
11:51:50 <jethr0> i know, but i always shy away from using non-standard functionality if i don't absolutely have to
11:52:45 <SamB> which is why FFI and the heirarchical namespace are standard extensions, I suppose...
11:53:44 <jethr0> so, how do you debug / trace? that's what i'm having most difficulties with in haskell at the moment
11:53:47 <Cale> In Miranda, it was possible to create a sorted list type
11:54:00 <SamB> jethr0: for that, Debug.Trace should work servicably
11:54:08 <jethr0> hat, buddha, etc all seem so overengineered for a simple task
11:54:14 <SamB> when strategically-placed prints are not practical
11:54:24 <SamB> jethr0: also, they don't work with many real programs
11:54:32 <jethr0> prints in haskell are never practical, if i see it correctly
11:54:42 <SamB> they are in the IO monad
11:54:47 <Cale> jethr0: do you know about Debug.Trace?
11:54:49 <SamB> @type print
11:54:50 <lambdabot> forall a. (Show a) => a -> IO ()
11:55:08 <SamB> Cale: I just mentioned that ;-)
11:55:12 <Cale> which is basically an unsafePerformIO'd putStrLn
11:55:21 <Cale> er, from before SamB mentioned it
11:55:22 <SamB> Cale: only it actually gets run
11:55:23 <jethr0> cale, yes, but i've learnt in c++ that serious debugger usage is _way_ more productive than manually printing/tracing stuff
11:55:42 <SamB> jethr0: maybe thats true of C++
11:55:47 <jethr0> but, if you are using Trace, i'll have a closer look at it!
11:55:51 <SamB> maybe its even true of C
11:55:56 <astrolabe> C has variable variables
11:55:58 <SamB> definately its true of Smalltalk
11:56:12 <SamB> but Smalltalk has a fantastical debugger, so...
11:56:16 <Cale> jethr0: I mostly just use ghci to debug
11:56:24 <SamB> anyway, in Haskell its fine
11:56:28 <Cale> jethr0: Debug.Trace helps collect test data
11:56:31 <SamB> you don't have mutable state after all
11:56:46 <jethr0> cool, thx for the tip
11:57:02 <Cale> sometimes an algorithm only fails after running for a while
11:57:49 <SamB> its usually the way to go in Python, too (when cgitb is no help because the problem is far from where the exception is thrown)
11:57:53 <Cale> in which case you want to catch some input to some function involved which produces bad results, and trace is good at that
11:59:11 <jethr0> so you haven't used hat, buddha, etc so much, then?
11:59:15 <Cale> nope
11:59:58 <SamB> I tried hat once but the viewer kept crashing and I couldn't make any sense of what it showed me anyway
12:00:00 <Cale> I'd say 95% of my bugs are caught by just getting the thing to compile in the first place, then an extra 4% by trying things in ghci, and 1% of the bugs need additional tracing to find
12:00:29 <Cale> The most effective method of debugging is to make functions smaller
12:00:33 <SamB> Cale: but the 95% aren't technically bugs since they don't compile ;-)
12:00:44 <Cale> SamB: well, they would be in other languages :)
12:00:50 <SamB> yes
12:01:14 <SamB> so, in other words, 95% of bugs are impossible
12:01:20 <Cale> yeah
12:01:31 <SamB> or at least hard to do by mistake
12:01:41 <chrisbrown> @type mapM_
12:01:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:01:54 <chrisbrown> ah - thats why
12:01:57 <jethr0> which makes the average "bug" in haskell many times harder to find ;-))
12:02:03 <Cale> yes
12:02:04 <SamB> jethr0: hmm
12:02:21 <SamB> which is why a debugger would be no help, right?
12:02:22 <Cale> in fact, most of my notable bugs are actually design flaws
12:02:58 <Cale> for which a debugger *really* isn't going to help
12:03:51 <jethr0> small functions with manually easy to produce input and an interpreter are actually a lot more comfortable than any debugger...
12:04:32 <Cale> and you can actually reasonably debug that way because there's no global state for the most part
12:04:38 <SamB> maybe its a good thing that python has a terrible debugger?
12:04:54 <jethr0> most often in c++, the main problem is in reproducing the global state (which might not be realisticly possible at all!)
12:06:03 <jethr0> what haskell really should have is an error-edit-resume feature
12:06:17 <jethr0> which is possible due to its stacklessness (i guess / hope)
12:06:26 <Cale> the reason why you really needn't be very afraid of non-IO monads is that every one of them which you'll ever use has a "way out", which means that you can test things independently with no worries.
12:06:35 <Cale> like the list monad
12:06:37 <SamB> but it isn't stackless
12:06:42 <Cale> that's not scary at all :)
12:07:02 <Cale> (hehe, and yet you can do some really interesting things with it :)
12:07:24 <jethr0> ahh, lazyness might not well with that... (maybe)
12:07:37 <jethr0> work well*
12:07:46 <Cale> Haskell isn't stackless, but stack traces aren't all that useful for debugging
12:08:18 <Cale> since you have lots of anonymous closures and such
12:08:22 <jethr0> i know, but what does it use the stack for?
12:08:36 <jethr0> also, evaluation order is crazy!
12:08:45 <Cale> well, yeah
12:09:04 <jethr0> i thought it might do some continuation passing stuff in the background, like scheme
12:09:11 <Cale> it still pushes functions and parameters onto a stack like usual, but the way in which it does that is unusual :)
12:09:26 <SamB> this is why the cost center stack is more interesting than the execution stack
12:09:47 <SamB> jethr0: but there is no call/cc in Haskell
12:09:53 <SamB> nevermind that there is a callCC
12:09:59 <Cale> hehe
12:10:03 <SamB> @type Control.Monad.Cont.callCC
12:10:04 <lambdabot> forall (m :: * -> *) a b.
12:10:04 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
12:10:04 <lambdabot> ((a -> m b) -> m a) -> m a
12:10:44 <Cale> http://haskell.org/hawiki/ContinuationsDoneRight
12:10:45 <SamB> anyways, that uses a monad to do all the continuation-related bookkeeping, so it matters not
12:10:53 <Cale> callCC :: ((a -> (forall b. m b)) -> m a) -> m a
12:10:54 <jethr0> yes, but being lazy anyways, CPS would be a possible way to implement haskell, no?
12:11:17 <SamB> Cale: what use is that?
12:11:34 <SamB> how am I supposed to return anything interesting at an unknown type?
12:11:37 <SamB> albiet monadic
12:12:00 <Cale> well, you don't know that type
12:12:42 <SamB> oh, wait.
12:12:48 <SamB> I think I misread it.
12:13:39 <SamB> so, I pass it a function that takes a function of type "a -> (forall b. m b)"
12:13:51 <chrisbrown> module PfeParse(module PfeParse,arg,(<@),( #@ ),many) where
12:13:52 <SamB> hmm, I get it now.
12:14:00 <SamB> that does look like it is done right ;-)
12:14:08 <chrisbrown> sorry - does any one know why module PfeParse is boing exported here?
12:14:19 <jethr0> samb, they sure will be proud to finally have your approval :P
12:14:22 <SamB> we should totally put that in the library
12:14:25 <chrisbrown> does that mean everything in that module is being exported?
12:15:11 <Cale> SamB: also, http://haskell.org/hawiki/ListTDoneRight
12:15:17 <SamB> chrisbrown: only things from that module that are imported into the exprting module
12:15:28 <araujo> Talking about debuggers... i'll give a try to Buddha
12:15:31 <SamB> Cale: I saw that already
12:15:40 <chrisbrown> SamB: I dont follow
12:15:49 <SamB> I don't know what to use ListT for anyways
12:16:33 <jethr0> araujo, is that the one they now call plargleflarp?
12:16:35 <Cale> chrisbrown: that's an export list -- an explicit list of the values and types visible when another module imports your module
12:16:44 <chrisbrown> yes
12:16:53 <chrisbrown> but why is the first thing exports the module?
12:17:04 <chrisbrown> *thing it exports
12:17:07 <jethr0> why does it export itself
12:17:12 <Cale> itself...
12:17:19 <Cale> yeah, I didn't notice that :)
12:17:27 <Cale> um, that's a silly thing to do
12:17:38 <chrisbrown> ive never seen it done before!
12:17:48 <SamB> yes!
12:18:00 <SamB> it seems rather redundant to export other things as well
12:18:07 <SamB> also redundant to have an export list
12:18:07 <Cale> I'm surprised that compiles
12:18:15 <Cale> it's a cyclic dependency :)
12:18:20 <chrisbrown> i know
12:18:23 <jethr0> i haven't figured out how to import data constructors. "import Data.Either (Left)" (purely as an example) doesn't seem to work
12:18:42 <jethr0> cale, but the cycle resolves itself :P
12:18:46 <SamB> because an empty export list is approximately the same as "(module PfeParse)"
12:18:55 <SamB> er, an omitted export list
12:19:07 <SamB> anyway, its only a cyclic dependancy if it actually imports itself
12:19:20 <SamB> besides which, cyclic dependancies are allowed by the standard
12:19:30 <SamB> (though probably not such short ones)
12:19:49 <jethr0> samb, what's the lenght of the cycle?
12:19:59 <SamB> jethr0: either 0 or 1
12:20:04 <SamB> I'm not quite sure
12:20:05 <jethr0> :P
12:20:19 <SamB> I'll count arcs and say 1
12:20:21 <jethr0> i'm not sure whether a cycle of length 0 is a cycle
12:20:52 <SamB> anyway, counting arcs is the simplest way I can think of to do it ;-)
12:21:00 <jethr0> i haven't figured out how to import data constructors. "import Data.Either (Left)" (purely as an example) doesn't seem to work
12:21:22 <SamB> jethr0: you need to "import Data.Either(Either(Left))
12:21:29 <jethr0> ah, cool
12:21:32 <SamB> or "import Data.Either(Either(..))"
12:21:50 <SamB> or "import Prelude (Either(..))"
12:21:58 <jethr0> so data types are handled a bit like modules then...
12:22:14 <SamB> not a whole lot
12:22:30 <jethr0> )
12:22:38 <SamB> I mean, with modules the default is to import everything
12:23:07 <SamB> with types/classes the default is to import just that constructor/class name
12:27:15 <araujo> jethr0, re-named it the debugger?
12:30:38 <chrisbrown> @type mapM_
12:30:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:30:45 <jethr0> araujo, it seems some buddhists took exception to the name ;-)
12:30:54 <chrisbrown> why return m ()?
12:31:07 <chrisbrown> surely m b
12:31:14 <jethr0> chrisbrown, it's like an empty return in C
12:31:30 <chrisbrown> so its an action?
12:31:32 <musasabi> evening
12:31:38 <jethr0> for IO it's an empty action
12:31:48 <jethr0> @type sequence_
12:31:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
12:32:02 <chrisbrown> an you give me an example of using mapM_ ?
12:32:06 <chrisbrown> +c
12:32:08 <jethr0> sequence for IO executes all actions and returns an empty IO monad
12:32:08 <SamB> musasabi: afternoon, fool!
12:32:16 <Taral> mapM_ createEmptyFile filenames
12:32:27 <SamB> (for it is but 3:33!)
12:32:50 <jethr0> mapM_ putStrLn ([return "hello", return "world"] :: [IO String])
12:32:57 <araujo> What is the path Cabll looks for the Build-Depends packages?
12:33:01 <araujo> Cabal*
12:33:08 <jethr0> no, that was wrong
12:33:10 <jethr0> wait a sec
12:33:13 <Taral> heh
12:33:32 <xerox> You can also:
12:33:38 <Taral> araujo: ghc-pkg list
12:33:52 <xerox> sequence [putStrLn "hello", putStrLn "world"]
12:33:52 <chrisbrown> @eval mapM_ putStrLn ["hello", "world"]
12:33:53 <lambdabot> No IO allowed
12:34:01 <chrisbrown> why not? lol
12:34:03 <jethr0> @type putStrLn
12:34:04 <lambdabot> String -> IO ()
12:34:26 <araujo> Thanks Taral 
12:34:34 <araujo> Bah! , i was using the incorrect package name
12:34:38 <jethr0> chrisbrown, i'll test it "at home". might have been correct after all ;-)
12:34:55 <jethr0> nah
12:35:10 <chrisbrown> jethr0 so it applies a monad on each element of a list - and then returns nothing?
12:35:12 <jethr0> mapM_ putStrLn ["hello", "world"]       
12:35:20 <chrisbrown> k
12:35:35 <jethr0> for IO this makes sense, because you only want the side-effect.
12:35:47 <Taral> > runST (do { a <- newSTRef []; mapM_ (\x -> modifySTRef a (x:)) [1,2,3]; readSTRef a })
12:35:48 <lambdabot>  Not in scope: `readSTRef'
12:35:58 <xerox> You need parens.
12:36:03 <Taral> > runST (do { a <- Data.STRef.newSTRef []; mapM_ (\x -> Data.STRef.modifySTRef a (x:)) [1,2,3]; Data.STRef.readSTRef a })
12:36:05 <lambdabot>  Not in scope: `Data.STRef.readSTRef'
12:36:05 <xerox> mapM_ (putStrLn) ["hello", "world"]
12:36:05 <jethr0> for other monads i don't see the point!
12:36:12 <chrisbrown> ok
12:36:49 <chrisbrown> jethr0 thanks
12:36:52 <jethr0> np
12:37:07 <Taral> jethr0: There are other monads besides IO that have side-effecting operations.
12:37:21 <jethr0> hmm, which ones?
12:37:26 <Taral> ST
12:37:28 <Taral> State
12:37:31 <Taral> StateT *
12:37:37 <jethr0> ah, i see
12:37:58 <SamB> well, they don't count as side-effecting unless you look at the implementation ;-)
12:38:18 <SamB> and even then, only ST
12:38:26 <Taral> SamB: Side-effecting from the monad perspective.
12:38:50 <jethr0> so you could do "mapM_ id [set 7, set 9]" or something
12:38:59 <Taral> yeah, or mapM_ set [7, 9]
12:39:09 <SamB> but its right there in the spine of the monad!
12:39:09 <Taral> or, more likely, mapM_ mutateState [7, 9]
12:39:21 <Taral> SamB: Huh?
12:39:22 <jethr0> ya, i wanted to mix get and set, but it wouldn't have made any sense
12:39:55 <Taral> mapM_ (\x -> get >>= set . (x:)) [7, 9]
12:40:08 <jethr0> cool
12:40:31 <Taral> it's especially important if you have a function like:
12:40:53 <Taral> modifyAndReturnOldState f = do { x <- get; set $ f x; return x }
12:40:57 <Taral> and you don't care about the return value.
12:41:10 <araujo> lisppaste2, help?
12:41:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:41:38 <jethr0> very nic, thx taral
12:41:42 <jethr0> nice*
12:41:48 <lisppaste2> araujo pasted "Cabal error" at http://paste.lisp.org/display/14447
12:42:16 <araujo> Ive get the following error after: setup build
12:44:07 <Taral> araujo: something wrong with that .cabal file then
12:44:22 <Taral> probably not listing "base" as a required package
12:45:06 <araujo> Shopuld i use the other-modules: field?
12:46:46 <araujo> Taral, Ive got base on Build-Depends:
12:46:50 <chrisbrown> @type fmap
12:46:52 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:47:26 <SamB> araujo: other-modules is for modules that are part of your package but not to be exposed, I think...
12:47:27 <Taral> araujo: No, that should work. Try lisppasting your .cabal file?
12:47:40 <araujo> SamB, Yeah, true.
12:47:43 <araujo> Taral, Sure...
12:48:16 <SamB> Taral: are you on break or something?
12:48:26 <Taral> break?
12:48:27 <SamB> or has it been a week already?
12:48:27 <Taral> me?
12:48:36 <Taral> eh?
12:48:42 * SamB thought Taral said he was on about once a week
12:48:48 <Taral> oh, heh
12:48:52 <Taral> well, that was then, this is now.
12:49:09 <SamB> okay...
12:49:22 <lisppaste2> araujo pasted "Simple Cabal file" at http://paste.lisp.org/display/14448
12:49:32 * SamB doesn't know how to calculate now - then
12:49:33 <araujo> There it is , something simple really.
12:50:50 <jethr0> isn't there an inline way of doing "do x <- func; y <- func2; func3 x y" which doesn't use lambdas?
12:51:06 <jethr0> like "do func3 (<<< func) (<<< func2)" or so?
12:51:24 <xerox> Sure.
12:51:42 <xerox> But it's a secret.
12:51:54 <jethr0> haha
12:52:52 <jethr0> if i'm asking stupid questions, just tell me so!
12:53:39 <chrisbrown> @type mapM
12:53:40 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:54:14 <chrisbrown> qualId f =  (f @@ parseQualId) # arg "<M.x>"
12:54:30 <Philippa_> jethr0: it'll use >>= twice
12:54:36 <Philippa_> er, wait, not quite it won't
12:54:43 <jethr0> ya, but with lambda
12:54:52 <araujo> Taral, ?
12:54:54 <jethr0> "func >>= \x -> func2 >>= func3"
12:55:02 <chrisbrown> can any one holp here - parseQaulId takes one argument as well as f - how do i call qualId?
12:55:02 <jethr0> "func >>= \x -> func2 >>= func3 x"
12:55:03 <Taral> araujo: I don't see anything :(
12:55:10 <Taral> Try running the build with -vvvvv or something
12:55:10 <araujo> Taral, :-(
12:55:41 <jethr0> chrisbrown, ??
12:55:45 <jethr0> what does "@@" do?
12:55:49 <chrisbrown> jethr0: exactly
12:55:58 <chrisbrown> @@ is kind of monadic composition
12:55:58 <lambdabot> Maybe you meant: pl wn
12:56:05 <jethr0> if "f" is a function you call "qualId" with a function!
12:56:18 <chrisbrown> well
12:56:28 <chrisbrown> i can call f all by itself like this:
12:56:30 <jethr0> or not?
12:56:40 <chrisbrown> typeof tcOutput [(mod, "i")]
12:56:44 <chrisbrown> and it return m ()
12:57:30 <chrisbrown> so if i call qualId (typeof tcOutput [(mod,"i")]) it complains that qaulId doent take a m ()
12:58:30 <chrisbrown> im probably not making much sense
12:58:33 <jethr0> @type (@@)
12:58:34 <lambdabot> Not in scope: `@@'
12:58:50 <jethr0> yes, you are, but i know too little about "@@" and "#"
12:58:57 <chrisbrown> m1 @@ m2 = \ x -> m1 =<< m2 x
12:59:01 <jethr0> @hoogle (@@)
12:59:02 <lambdabot> No matches found
12:59:05 <chrisbrown> f # x = fmap f x
12:59:13 <chrisbrown> there are the definitions for @@ and #
12:59:28 <jethr0> *yuch*
12:59:34 <chrisbrown> yep!
13:00:29 <jethr0> qualId f =  fmap (\x -> f =<< parseQualId x) arg "<M.x>"
13:00:34 <araujo> Taral, i think the question here is, where should i specify those hidden modules?
13:00:53 <Taral> araujo: You shouldn't have to.
13:00:57 <jethr0> what's going on with the two additional args to fmap?
13:00:58 <Taral> What version of cabal are you using?
13:01:07 <chrisbrown> im not sure
13:01:13 <chrisbrown> thats what I cant figure out
13:01:13 <araujo> Taral, 1.1.3
13:01:24 <Taral> araujo: Hm, as far as I can tell, everything is right.
13:01:28 <chrisbrown> i wish he would put the parameters in explicitly
13:01:33 <Taral> jethr0: You mistranslated it.
13:01:42 <jethr0> sorry, trying my best
13:01:46 <Taral> it's qualId f = fmap (\x -> f =<< parseQualId x) $ arg "<M.x>"
13:01:54 <chrisbrown> ah yeah
13:01:54 <jethr0> ok
13:02:03 <chrisbrown> oh the definition of arg is...
13:02:12 <chrisbrown> arg = Token Just
13:02:23 <chrisbrown> data P res
13:02:23 <chrisbrown>   = Return res
13:02:23 <chrisbrown>   | forall arg . Ap (P (arg->res)) (P arg)
13:02:23 <chrisbrown>   | Named String (P res)
13:02:23 <chrisbrown>   | P res :-- String
13:02:25 <chrisbrown>   | Token (String->Maybe res) String
13:02:36 <Taral> araujo: Can I suggest looking at the verbose build output? If that doesn't help, then I'm out of ideas.
13:02:48 <chrisbrown> so arg "<M.x>" = Token Just "<M.x">
13:02:56 <Taral> chrisbrown: That doesn't work.
13:03:01 <araujo> Taral, yes, i did, but i couldn't fgure out anything :-(
13:03:02 <Taral> You want \x -> Token (Just x) x
13:03:08 <Taral> @pl \x -> Token (Just x) x
13:03:09 <lambdabot> Token =<< Just
13:03:12 <Taral> ha ha ha
13:03:30 <jethr0> aaahhh
13:03:30 <chrisbrown> im confused thats how its written in the code
13:03:49 <Taral> hm
13:03:51 <Taral> oh, wait
13:03:53 <Taral> my mistake
13:03:56 <Taral> no, Token Just is okay.
13:04:06 <Taral> arg :: String -> P String
13:04:21 <chrisbrown> P String?
13:04:28 <Taral> yes
13:04:33 <lisppaste2> araujo pasted "cabal -v output" at http://paste.lisp.org/display/14449
13:04:35 <Taral> the type is P a, this is P String.
13:04:37 <SamB> Taral: still, it seems an awfull lot like that constructor is defined that way just to avoid a "."...
13:04:38 <chrisbrown> ah
13:04:40 <chrisbrown> i see
13:04:46 <araujo> Taral, Take a look ... mmm.. 
13:04:50 <Taral> SamB: It does, doesn't it.
13:05:12 <SamB> Taral: unless sometimes more complicated things are used
13:05:15 <Taral> araujo: um, there's a problem with that...
13:05:32 <Taral> araujo: it's not passing -package base/unix/plugins
13:05:34 <araujo> Taral, Seems like it isn't taking the base and unix package right?
13:05:35 <SamB> or even then, I guess
13:05:45 <Taral> araujo: yes
13:06:11 <Taral> SamB: It's possible that they wanted the String around for display, in which case "Token (Maybe res) String" would have been appropriate.
13:06:19 <chrisbrown> so using this its qualId f = fmap (\x -> f =<< parseQualId x) $ P "<M.x>"
13:06:20 <Taral> but it is odd.
13:06:30 <Taral> chrisbrown: No.
13:06:36 <Taral> P String is a *type*, not an expression.
13:06:43 <SamB> Taral: hmm
13:06:44 <chrisbrown> of course
13:06:57 <Taral> [15:01] <Taral> it's qualId f = fmap (\x -> f =<< parseQualId x) $ arg "<M.x>"
13:07:05 <jethr0> chrisbrown, what type is parseQualId?
13:07:10 <chrisbrown> no idea
13:07:28 <chrisbrown> i cou/ld try putting it into ghci
13:07:30 <Taral> araujo: Does your ghc-pkg list show base and unix packages?
13:07:45 <jethr0> you could load the file and then do ":t parseQualId"
13:07:51 <jethr0> unless it is defined in a "where" or "let"
13:07:58 <araujo> Taral, I found the problem :-/
13:08:23 <Taral> Oh?
13:08:25 * araujo hits his head over the keyboard
13:08:36 <Taral> I was about to ask if you had more .cabal files laying around..
13:09:06 <chrisbrown> it cant find half the import files
13:09:09 <Taral> your head has a keyboard?
13:10:22 <jethr0> hmm, but we kinda know that parseQualId takes a "P String" and returns an "a m()", right?
13:10:39 <chrisbrown> i guess so
13:11:11 <jethr0> hmm, any idea what type "a" is bound to? String maybe?
13:11:29 <jethr0> chrisbrown, what library is this in?
13:11:38 <chrisbrown> http://www.cse.ogi.edu/~hallgren/Programatica/tools/pfe/PfeParse.hs
13:12:26 <jethr0> parseQualId takes a string
13:12:37 <araujo> Taral, forgot to run configure after the my last changes  :-/
13:12:55 <araujo> Taral, haha
13:12:57 <jethr0> but it's fmap'ed inside a monad
13:13:13 <chrisbrown> jethr0: its confusing isnt it?
13:13:53 <jethr0> not really, just getting around all the squiggly operators is!
13:15:16 <chrisbrown> so parseQualId takes a String
13:15:39 <jethr0> yup
13:16:11 <chrisbrown> hmmm
13:16:17 <jethr0> and returns Maybe Something, whereas the "@@" strips off the Maybe
13:16:23 <jethr0> Something should be String
13:16:29 <chrisbrown> yes
13:16:30 <jethr0> but is a tuple
13:16:56 <jethr0> no, strike my last comments
13:17:09 <chrisbrown> i think it makes a tuple using split
13:19:07 <jethr0> sorry, but without the function types i'm at a bit of a loss myself
13:19:42 <jethr0> isn't there a manual or documentation?
13:19:56 <chrisbrown> thing is if i give qualIds 2 arguments - it complains that Im giving it too many arguments
13:20:16 <chrisbrown> jethr0 no worries - nope no manual or documentation! just source code!
13:21:04 <jethr0> why do you give it two?
13:21:36 <jethr0> from what i can see it takes only one
13:21:42 <chrisbrown> it takes 1?
13:21:45 <chrisbrown> a function?
13:21:49 <jethr0> yup
13:22:03 <chrisbrown> but what type?
13:22:06 <chrisbrown> arghh!
13:22:07 <chrisbrown> :)
13:22:43 <jethr0> some tuple to something ;-(
13:22:50 <chrisbrown> hmmm
13:22:57 <jethr0> what's the function for, anyways
13:24:06 <chrisbrown> its to give me the type information for an identifier within a particular module
13:24:43 <palomer> GaH!
13:25:16 <Axioplase> Hi
13:26:16 <jethr0> chrisbrown, are you sure you are supposed to use qualId directly?
13:26:23 <Axioplase> if I do    foo l = bar l2 ++ qux l2 where l2 = evaluate complexcalculus l;   will it calculate l2 jsut once ? 
13:26:54 <flux__> yes
13:27:09 <chrisbrown> actually no im not! perhaps I need to take a good look at the code and work out whats going on
13:27:16 <Axioplase> flux__: ok thanks.
13:27:17 <jethr0> chrisbrown, because, to me, it looks as if the result of qualId is used in a monad parser like parsec
13:27:35 <chrisbrown> oh!
13:27:52 <chrisbrown> i wonder if it is - i read somewhere that he uses parser combinators
13:28:16 <jethr0> this would mean that you'd use qualId to build a parser... but i'm not sure at all about this!
13:28:23 <chrisbrown> ok
13:28:35 <chrisbrown> well, thanks very much for your help!! :)
13:28:41 <jethr0> np
13:28:42 <Axioplase> @type evaluate
13:28:43 <lambdabot> Not in scope: `evaluate'
13:28:48 * xerox hehes
13:28:59 <Axioplase> @type Control.Exception.evaluate
13:29:00 <lambdabot> forall a. a -> IO a
13:29:08 <xerox> Makes sense.
13:29:08 <Axioplase> argh... indeed...
13:40:38 <Axioplase> hum... how good is compiled haskell, compared to C, caml or else?
13:40:58 <xerox> Good enough.
13:41:04 <Axioplase> and is [x |x<-l, x<2] O(n) ?
13:41:12 <xerox> Way more good that I could do :-)
13:41:21 <palomer> double plus good?
13:41:38 <palomer> 10 banana bucks to whoever tells me where I took that expression
13:41:54 <xerox> Axioplase: in the worst case.
13:42:09 <Axioplase> because I'm doing a O(n log n) prog, that looks like a O(n^2) or so... (and I have no n2 or worse algo in that code...) 
13:42:31 <palomer> which, in reality, is an O(e^(n^2)) algorithm
13:42:38 <Axioplase> unless http://img526.imageshack.us/my.php?image=xgr0021tb.gif is O(n log n)
13:42:51 <Axioplase> palomer: that would explain things...
13:43:06 <xerox> ...a gif.
13:43:08 <psi> am i not supposed to be able to read any file with readFile? i get "Program error: <handle>: IO.getContents: protocol error (invalid character encoding)"
13:43:20 <xerox> How did you produce it?  Profiling?
13:43:34 <Axioplase> xerox: the display program I used outputs as gif (but is reaaaaaally good for plotting and so on)
13:43:51 <psi> xerox, are you asking me?
13:43:58 <xerox> psi: nope, Axioplase.
13:44:23 <jethr0> psi, got some code?
13:44:26 <psi> i get that error in hugs, but not in ghc
13:44:26 <jethr0> @type readFile
13:44:27 <lambdabot> FilePath -> IO String
13:44:38 <Axioplase> xerox: with getCPUTime around an "evaluate" of the main algo, and then, printing "number of plots, time to calculate" and puuting this to xgraphics which did the pic.
13:44:41 <xerox> psi: why mess with hugs?
13:44:55 <xerox> Axioplase: thanks for the wordy explanation.
13:45:18 <xinming> sequence = foldr mcons (return [])
13:45:19 <xinming>              where mcons p q = p >>= \x -> q >>= \y -> return (x:y)
13:45:22 <Axioplase> was it long for Profiling ?
13:45:25 <xinming> anyone here would tell me what will q get?
13:45:37 <xinming> a list?
13:45:43 <psi> xerox, ghci doesn't work on ppc
13:45:46 <psi> at least not for me
13:45:59 <xerox> sequence = foldl (mplus) mzero -- ?
13:46:00 <xinming> hmm, or one of monad operation from the list?
13:46:31 <psi> jethr0, should i paste it somewhere? like i said, it works with ghc
13:46:41 <jethr0> listpaste2: help?
13:46:45 <jethr0> lisppaste2: help?
13:46:47 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:46:59 <xerox> @type foldl (Control.Monad.mplus) Control.Monad.mzero
13:47:00 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => [m a] -> m
13:47:00 <lambdabot> a
13:47:22 <psi> oh, also: do arrays have O(1) for random access?
13:47:50 <xerox> I think the documentation talks about computational complexity at times, maybe check it out?
13:47:52 <int-e> Hah. I think I've now finally solved a puzzle by dons (from 2005-11-15) - how to cause "Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'" with a trivial typo in some code.
13:48:18 <xerox> int-e: the former seems fix, the latter looks like a function
13:49:25 <int-e> The typo being: ask >>= lift print (or some monad action) instead of ask >>= lift . print; in general, missing that . in the ReaderT monad.
13:49:33 <xinming> :-/ anyone would explain for me? :-/
13:49:39 <xerox> int-e: yeah!
13:51:20 <psi> lisppaste doesn't seem to react. i'll try again.
13:52:20 <psi> huh. nothing.
13:52:35 <int-e> xinming: q will be a monad action returning a list
13:52:42 <int-e> xinming: and y a list
13:52:51 <psi> anyway, i'm trying to read a nes rom-file into an array, but it fails when i run readFile.
13:53:01 <SamB> psi: what url are you pasting from?
13:53:38 <psi> lisppaste2: help?
13:53:39 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:54:27 <int-e> @quote lambdabot
13:54:28 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
13:54:34 <int-e> lucky me :)
13:54:40 <SamB> ooh, you trying to do an NES emu, or a rom hacking utility?
13:55:19 <SamB> psi: did you get it to paste?
13:55:19 <SamB> if it pasted, you can just tell us the URL...
13:55:33 <psi> i'm just messing around :-) earlier today i was upset at the quality of the nes emulators i could find.
13:56:20 <SamB> psi: it might be easier than doing a Z-Machine emulator, in some ways..
13:56:30 <psi> oh, i'm so stupid. i think the paste will work now.
13:56:42 <lisppaste2> psi pasted "rom" at http://paste.lisp.org/display/14450
13:57:13 <SamB> I mean, you don't have to do nicely-formatted text I/O for NES emulators
13:57:36 <jethr0> paste.lisp.org seems awfully sluggish today
13:58:13 <psi> i don't think i'm qualified to make an emulator of anything :) like i said - i'm just messing around right now.
13:58:15 <SamB> of course, no doubt 6502 is more annoying to implement than the z-machine instructions...
13:58:23 <jethr0> psi, you can actually read directly into a buffer...
13:58:54 <psi> what is that, in haskell?
13:58:55 <SamB> jethr0: don't scare him, jethr0 
13:58:55 <SamB> thats my job!
13:59:20 <jethr0> @type System.IO.hGetBuf
13:59:21 <lambdabot> forall a. GHC.IOBase.Handle -> GHC.Ptr.Ptr a -> Int -> IO Int
13:59:22 <jethr0> just telling
13:59:38 <Philippa_> SamB: probably not by as much as you'd think
14:00:04 <SamB> Philippa_: perhaps not.
14:00:06 <jethr0> psi, but it'll be easier like you do it, for now
14:00:11 <jethr0> psi, looks fine. what does hugs complain about?
14:00:12 <SamB> but it has REGISTERS!
14:00:35 <jethr0> maybe hugs can't handle binary files??
14:00:37 <psi> Program error: <handle>: IO.getContents: protocol error (invalid character encoding)
14:01:14 <SamB> and they aren't referenced in any kind of regular scheme
14:01:19 <SamB> okay, so you have a type error
14:01:25 <SamB> ?
14:01:25 <SamB> no?
14:01:46 <psi> i don't think so
14:01:50 <SamB> why are you using an array of Int?
14:01:57 * SamB would think Word8 was more appropriate
14:02:09 <SamB> psi: oh.
14:02:17 <psi> i not very familiar with all the types
14:02:29 <SamB> I guess hugs doesn't like binary files?
14:02:32 <psi> i want to do bitwise operations on the elements
14:02:58 <jethr0> you could the IO functions in System.IO...
14:03:01 <psi> SamB, that would be pretty lame
14:03:03 <jethr0> try the*
14:03:47 <jethr0> psi, what operating system are you running? does it need setting of File Mode to binary?
14:03:50 <jethr0> maybe?
14:03:58 <SamB> you know, hugs works a lot better when you use :l to load library modules than when you try to use :m...
14:04:11 <psi> jethr0, linux ppc
14:04:24 <SamB> for a while there I thought my install was broken because I was trying :m when I should have been using :l
14:04:26 <psi> SamB, i'm using emacs. what does it do?
14:04:32 <jethr0> hmm, linux doesn't care...
14:04:34 <chrisbrown> jethr0: i think ive worked out why it wasnt working
14:04:50 <jethr0> chrisbrown, yes?
14:04:52 <SamB> try System.IO.openBinaryFile
14:04:59 <chrisbrown> i finally got it to compile then realised it must have been using some kind of state monad
14:05:16 <chrisbrown> it was being used by some kind of parser combinator
14:05:16 <jethr0> samb, linux makes no difference between binary and text!
14:05:27 <jethr0> chrisbrown, just as i thought
14:05:28 <SamB> jethr0: perhaps hugs ALWAYS requires this when you want binary files?
14:05:36 <chrisbrown> it compiled but returned m ()
14:05:37 <SamB> I haven't ever tried using hugs with binary files before!
14:05:42 <chrisbrown> :)
14:05:50 <jethr0> hmm, but linux doesn't know the difference and hugs most likely calls some c function
14:05:55 <jethr0> but there's no harm in trying...
14:05:57 <psi> i'll try it out, anyway
14:06:47 <SamB> psi: hmm. I have a different error message!
14:06:51 <SamB> Program error: MarioBros.nes: Prelude.readFile: does not exist (file does not exist)
14:06:58 <psi> :P
14:07:30 <jethr0> psi, i got the same error message with hugs
14:07:43 <jethr0> ghci handles it nicely
14:07:53 <SamB> maybe I should ln -s ~/roms/nes/Zelda.nes MarioBros.nes?
14:07:58 <twb> Hey, does Debian have wxHaskell?
14:08:41 <SamB> yeah, my guess is that hugs supports unicode or something...
14:08:46 <Axioplase> is there something else that "you don't calculate what you don't need to calculte" which means that lazy evaluation is good? (because I'm wondering whether haskell was a good choice for what I'm calculating...)
14:08:53 <jethr0> twb, apt-cache search wxhaskell returned no results
14:08:57 <jethr0> maybe over at apt-get.org
14:09:05 <SamB> or complains towards that end
14:09:05 * twb looks
14:09:21 <SamB> hmm, now I get:
14:09:21 <SamB> ERROR - Garbage collection fails to reclaim sufficient space
14:09:22 <Axioplase> jethr0: apt-cache serach haskell |grep wx ?
14:09:37 <Axioplase> s/serach/search
14:09:55 <psi> it works with openBinaryFile
14:09:55 <jethr0> nah!
14:10:01 <psi> it's really slow, though!
14:10:25 <twb> OK, hands up who wants a wxHaskell Debian package?
14:10:28 <jethr0> but alien seems to work nicely, as always: http://haskell.org/hawiki/WxHaskellInstallationTips
14:10:37 <SamB> psi: try using GHCi
14:10:52 <psi> ghci doesn't work for  me
14:10:55 <SamB> that should work okay in ppc linux, afaik
14:10:55 <jethr0> samb, he's got problems with ghc[i] on ppc
14:11:17 <SamB> oh?
14:11:42 <psi> Loading package base-1.0 ... ghc-6.4.1: Unable to mmap( MAP_FIXED ) for Jump Islands
14:11:44 <psi> :-)
14:12:00 <SamB> huh!
14:12:06 <SamB> is dons up yet?
14:12:19 <SamB> dons: up yet?
14:12:23 <psi> he knows about it
14:12:26 <SamB> oh
14:12:36 <SamB> anyway.
14:13:31 * SamB doesn't have a clue what that error has to do with PPC, unless it only needs jump islands on PPC
14:14:10 * SamB supposes that, with a name like that, it could well be arch-specific
14:15:17 <psi> funny thing is, it works flawlessly on os x.
14:15:27 * SamB gets curious and looks for clues in the source
14:15:29 <int-e> SamB: the code is PPC specific.
14:17:40 <SamB> yes, I see that now
14:17:42 <int-e> it's also heavy on flags passed to mmap.
14:18:26 <SamB> maybe this code is just broken?
14:19:20 <SamB> because I notice it apparantly would give a compile-time error rather than compile that branch of the #ifdef USE_MMAP on anything but Linux...
14:19:25 <psi> using arrays like that i can access every byte in O(1) time, right?
14:19:40 <SamB> psi: yes
14:19:57 <SamB> however, with that kind you'll need O(n) to update
14:20:28 <psi> ok. i guess i don't need to do that, though.
14:21:30 <SamB> I can't help but think it would be better to just use the #else branch of that conditional
14:21:41 <SamB> I mean, with that, GHCi should be fine.
14:22:25 <SamB> so what if it takes a lot more RAM that way!
14:22:34 <SamB> isn't that how its done on OS X anyways?
14:22:52 <int-e> it certainly looks that way
14:23:19 <psi> are you saying it's an easy fix?
14:23:29 <SamB> psi: it sure looks like it
14:24:07 <int-e> I think the linux code is a performance hack that does not work for some reason or other; it potentially avoids a lot of copying of memory.
14:24:32 <SamB> maybe you need to make sure USE_MMAP is actually not defined, though
14:25:44 <SamB> looks like its just at the top of ghc/rts/Linker.c
14:29:18 <lisppaste2> twb pasted "Can someone explain why wxhaskell isn't building on my system?" at http://paste.lisp.org/display/14451
14:30:50 <jethr0> you seem to be having trouble with wxString/char*
14:31:08 <SamB> twb: is your clock set right?
14:31:21 <jethr0> and time difference over nfs/smb can cause probs too...
14:32:27 <SamB> int-e: and it also lets the pages be backed by the file...
14:32:39 <psi> SamB, think you could paste a patch? i'll try to recompile tomorrow 
14:32:50 <psi> if it's just a line or two, of course...
14:33:00 <SamB> psi: this shouldn't trigger recompilation of the entire compiler
14:33:12 <SamB> seeing as how it is in a C file and all...
14:33:45 <psi> well, technically i wouldn't *re*compile it. i'm using a debian binary now :)
14:33:51 <SamB> ah
14:34:21 <int-e> SamB: no, it's using MAP_ANONYMOUS, fd is ignored.
14:34:34 <SamB> int-e: hmm
14:34:45 <int-e> SamB: what I'm asking myself right now is - can m-n be zero?
14:34:57 <SamB> int-e: well, the mremap -- what does *that* do?
14:35:14 <SamB> int-e: if all symbols are defined, I suppose
14:35:48 <SamB> which seems rather unlikely
14:36:02 <int-e> SamB: oh. mremap resizes, potentially enlarges a map.
14:36:23 <SamB> int-e: anyways, USE_MMAP does a *lot* of things
14:36:30 <int-e> SamB: sure
14:39:33 * SamB wishes GHC was at least under svn
14:41:01 <int-e> SamB: does the error message come with an error number (or E... string?)
14:42:00 <SamB> int-e: no!
14:43:13 <twb> So, any idea what I can do about this wx thing?
14:44:32 <SamB> twb: do you have a good version of wxWidgets?
14:44:37 <twb> SamB: no idea.
14:44:40 <twb> I just apt-got it.
14:44:46 <SamB> oh
14:44:49 <SamB> what dist?
14:44:57 <twb> Debian/experimental/powerpc
14:45:03 <SamB> what version is that?
14:45:17 <twb> It's unstable + scary stuff
14:45:32 <twb> (a.k.a. sid)
14:45:57 <psi> just out of curiosity, would a nes emulator in haskell be fast?
14:46:01 <SamB> psi: do you want me to make sure this makes it through the preprocessor ok, at least on x86, or doesn't it matter?
14:46:04 <jethr0> the version ;-) apt-cache show ... | grep Version
14:46:08 <Axioplase> twb: isn't SID Unstable instead of expermimental ??
14:46:09 <SamB> psi: probably not but who knows
14:46:12 <int-e> SamB: hah. if m-n is 0 you get EINVAL ... and that's not too unlikely to happen.
14:46:20 <twb> Axioplase: correct.
14:46:24 <SamB> int-e: oh.
14:46:29 <SamB> so should we just fix that?
14:46:33 <twb> Axioplase: experimental is addenda to sid, not a full release in and of itself.
14:47:16 <int-e> SamB: if (m != n && ...) well, if you have the patience to try it, you could give that a shot
14:47:18 <Axioplase> I'm running an experimental with Debian GNU/KfreeBSD. pretty stable though.
14:47:19 <psi> SamB, if it's not any trouble, sure
14:47:41 <SamB> psi: well, it looks like we have a *real* fix
14:48:09 <int-e> SamB: as far as I understand the code, it looks fine otherwise.
14:50:09 <SamB> psi: which I can't actually test
14:50:32 <psi> SamB, does that mean that we can keep the performance hack?
14:50:40 <SamB> psi: yes
14:50:49 <psi> cool
14:51:31 <twb> Axioplase: "unstable" is not a measure of reliability.
14:51:45 <twb> Axioplase: "unstable" refers to what sort of changes will be allowed.
14:51:58 <Heffalump> and to the amount of testing its had
14:52:03 <twb> Axioplase: "stable" is called "stable" because only bug-fixes are allowed into it.
14:52:19 <Heffalump> and because it's had a lot of testing
14:52:28 <Axioplase> twb: I know. SID last crashed at me a few years ago.. and I run stable too on servers.
14:52:35 <SamB> twb: I thought that was called "updates" or something
14:52:47 <twb> SamB: hmm?
14:52:52 <SamB> never mind
14:52:56 <SamB> what do I know?
14:53:02 <SamB> I haven't used stable in years now
14:53:33 <twb> Argh, stupid rcirc.
14:53:37 <twb> So I have a whole bunch of wx versions.  Which should I pick?
14:53:37 <twb>  /usr/lib/wx/config/gtk2-unicode-release-2.6
14:53:37 <twb>  /usr/lib/wx/config/gtk2-unicode-debug-2.6
14:53:37 <twb>  /usr/bin/wxbase-2.4-config
14:53:37 <twb>  /usr/bin/wxgtk-2.4-config
14:53:57 <lisppaste2> SamB annotated #14450 with "Linker patch" at http://paste.lisp.org/display/14450#1
14:54:44 <SamB> twb: 2.6, I think...
14:54:58 <twb> Hmm.
14:55:01 <SamB> not sure if it will work with the unicode versions though
14:55:05 <twb> 2.6 doesn't work, but 2.4gtk does!
14:55:18 <SamB> oh, whatever then
14:55:28 <int-e> SamB: yes, that's what I had in mind.
14:55:38 <twb> SamB: I'm using the tarball, not the darcs/cvs head.
14:55:46 <SamB> twb: shouldn't matter
14:55:54 <SamB> oh, wait, that.
14:55:57 <SamB> maybe that matters
14:56:02 <SamB> who knows!
14:56:18 <psi> SamB, thanks :)
14:56:34 <SamB> now I am a real RTS hacker, right? ;-)
14:56:38 * SamB kids
14:57:08 <twb> SamB: At least you're prepared to revise your story :-)
14:57:32 <int-e> well, you've probably seen more RTS code than the average Haskell programmer now :)
14:57:39 <SamB> hmm
14:57:40 <SamB> yes
14:57:48 <basti_> ^^
14:58:02 <SamB> and some of the most intensely C code in the whole lot, too!
14:58:11 <twb> RTS = real-time system?
14:58:15 <int-e> Run
14:58:17 <int-e> Time
14:58:18 <SamB> run-time system
14:58:23 <SamB> ....
14:58:24 <twb> Oh.
14:58:45 * SamB wonders if int-e is pretending to be a non real-time system
14:59:04 * SamB supposes that isn't hard to do, because people generally are...
14:59:39 * int-e is a dead-line driven soft real time system ... and missing deadlines all the time.
14:59:57 <SamB> heh
15:00:16 * SamB sets a deadline of 1 minute from now for int-e to say "System" by
15:00:59 <int-e> no. I couldn't say it before you spelled it out completely. after you did, adding that became pointless.
15:01:30 <int-e> But we can have a lengthy discussion about it if you like.
15:01:34 * int-e grins foolishly
15:01:40 <SamB> heh
15:01:58 <SamB> twb: should we have a lengthy discussion or not?
15:07:35 * int-e ponders the Model/View/Controller concept, MVars and events ...
15:08:05 <SamB> int-e: keep the Model in an MVar ;-)
15:08:32 <SamB> or use channels
15:08:36 <SamB> or something like that
15:08:58 <int-e> well, the model will have to be kept in a shared location.
15:09:20 <int-e> ok, I could also pass it down the channels all the time.
15:09:43 <SamB> eh, MVar sounds better...
15:09:47 <SamB> I dunno.
15:09:59 <SamB> never tried to do MVC in Haskell
15:10:08 <SamB> never really got it anywhere, really...
15:10:52 <SamB> I think I get Morphic's model though
15:10:58 <Philippa_> I've not done MVC per se. I've done related things though
15:11:10 <SamB> which is something like Model/View+Controller
15:11:19 <SamB> only you don't always have to have a Model
15:11:28 <int-e> SamB: what does morphic do if you have multiple views of the same thing?
15:11:30 <Philippa_> yeah, most of the things I've done lean that way somewhat
15:11:43 <int-e> SamB: synchronise several models?
15:11:49 <SamB> I never really got the View/Controller model...
15:12:00 <int-e> SamB: err. wait. what's the /, what's the +?
15:12:00 <SamB> er, duality
15:12:21 <SamB> View+Controller is the Morph
15:12:32 <int-e> SamB: I guess I don't really get the difference either - except that they are separate interfaces to the model.
15:12:45 <Philippa_> I think I get the, or at least a, difference
15:12:53 <int-e> SamB: ok. that's closer to how I'm actually thinking about MVC.
15:13:00 <Philippa_> in my IRC client I sorta think of the network connections as models...
15:13:19 <SamB> Philippa_: okay, that makes sense I guess
15:13:45 <MarcWeber> Is anyone using hdirect with SUPPORT_TYPELIBS on windows?
15:13:50 <Philippa_> there's a controller thread in-between that dispatches somewhat abstracted commands from the view(s) to models. Admittedly the One True Controller aspect might be considered semi-broken but a top-level dispatch to per-model controllers would be easy enough
15:14:10 <int-e> SamB: actually the separation of view and controller has bugged me quite a bit - in the case of GUIs, the two are usually combined. But it's nice to have a separate controller - optionally - or a separate view.
15:14:17 <dons> SamB, 114:31 hmp3 0.2
15:14:21 <SamB> oh, so controller is an arbitrator?
15:14:40 <Philippa_> int-e: I often think of controller as 'but there're multiple ways to say "open file" and they all do the same thing underneath'
15:14:51 <Philippa_> SamB: I use it as one
15:15:11 <Philippa_> I won't go so far as to give a general definition because I'm aware I may well be bastardising someone else's model
15:15:19 <SamB> ah
15:15:22 <int-e> Philippa_: ah, that's what the controller does.
15:15:29 <SamB> int-e: maybe.
15:15:39 <SamB> it seems there is quite a bit of confusion regarding this
15:15:59 <int-e> there's no obvious 'right thing to do' here I guess.
15:16:24 <SamB> I think its more that "controller" is such an overloaded term its difficult to figure out what it means
15:18:53 <jethr0> i guess the controller produces input, the model determines how to apply the input to the state and the view outputs the result
15:19:25 <musasabi> State sounds like an unfunctional concept.
15:19:30 <int-e> jethr0: and a common GUI element (like a checkbox) is both controller and view.
15:19:40 <jethr0> yes, agreed, but that's no problem...
15:19:58 <Philippa_> int-e: only insofar as it's simple enough nobody can be arsed to separate the two
15:20:09 * Philippa_ tends to think of view as being slightly more than a presentation layer though
15:20:14 <Philippa_> it translates user input back as well
15:20:27 <Philippa_> musasabi: still tends to pop up in some sense in a GUI app however it's written though
15:20:53 * jethr0 thinks of "view" as an output only module, visualizing the model's state
15:21:11 <SamB> Philippa_: your model sounds pretty reasonable
15:21:17 <Philippa_> jethr0: what happens when someone starts dragging the view's widgets around?#
15:21:26 <Philippa_> to put it another way, what has to know about individual widgets?
15:21:59 <int-e> musasabi: it's worse, there are also threads involved in that model.
15:22:05 <jethr0> philippa_ that's only partially inside _my_ model
15:22:08 <SamB> it sounds like what would happen if you took the application logic out of a Morph (if it had any)
15:22:12 <int-e> musasabi: with synchronization
15:22:45 <Philippa_> jethr0: so widgets're shared between controller and view in effect?
15:22:47 <jethr0> but generally you could add the widget's position to the model, although that's kinda ugly
15:23:00 <Philippa_> that's not just ugly, it breaks the entire point of MVC in the first place
15:23:03 <SamB> int-e: you want to see a really big mess of threads?
15:23:19 <Philippa_> (brb, dragging laundry upstairs)
15:23:25 <jethr0> widgets are a union of controller and view. but that doesn't make the terms of controller and view any more unclear in my view
15:23:35 <int-e> Philippa_: so you separate a model, with low level access, a view that provides high level representations, a controller, that translates high level actions to low level actions and finally a widget and some plumbing to make it work?
15:23:37 <SamB> Philippa_: as I said, I never got the point of MVC and I suspect many others don't either ;-)
15:23:59 <jethr0> philippa, you could always encapsulate the _real_ model by a GUI model, which will add widget positions, ...
15:24:37 <int-e> SamB: hmm. worse than joelr1's code?
15:24:44 <jethr0> widgets are their only small MVC. it's just a coincident that they are also the "view" and "controller" for another MVC.
15:24:56 <Philippa_> b
15:25:12 <musasabi> ick
15:25:18 <SamB> int-e: no, probably not ;-)
15:25:25 <Philippa_> b
15:25:39 <jethr0> their own*
15:25:41 <Philippa_> jethr0: in my model, the view and only the view has widgets
15:25:46 <SamB> in fact, I think our mess works fine, insofar as it is believed to be implemented...
15:25:54 <jethr0> ;-)
15:26:12 <musasabi> I think a GUI should be declaritive. Or a transformation from one declarative GUI to a new one. (that is kind like functional images)
15:26:14 * SamB tries to decide which Squeak image to load
15:26:19 <Philippa_> the controller stuff tends to map to conceptual actions the view might invoke
15:26:34 <musasabi> Only the types are quite complex resulting in multipage type errors.
15:26:55 <Philippa_> int-e: in my model (yay overloading!) the view provides /user/ representations, be they high-level or otherwise
15:27:14 <Philippa_> the controller does indeed do largely translation work though, yes
15:27:26 <SamB> is the controller composable?
15:27:38 <Philippa_> with other controller-like things? Quite probably
15:27:45 <Philippa_> (I've mostly been implementing via concurrency and message passing)
15:27:49 <int-e> Philippa_: good. I think I understand your view (model? hehe) now.
15:27:58 <SamB> can you compose a variety of controllers and views into one big mess?
15:28:18 <SamB> (messes are so much easier to work with if you can define them compositionally, you know ;-)
15:28:20 <int-e> you can compose almost anything into one big mess
15:28:42 <Philippa_> I'm less sure about views. Choice of controller is dependant partly on the view type I guess - you might need different intermediate languages/interfaces
15:28:55 <Philippa_> if that happens then yes, views can compose message flow in the obvious way
15:29:19 * int-e stacks views on other views
15:29:46 * int-e turns a view into a controller for a mirror of the model.
15:29:47 <Philippa_> but composing compositions of view+controller gets tougher, I suspect
15:34:28 <ihope> Is "(((a -> b -> c) -> (a -> b) -> a -> c) -> (d -> e -> d) -> f) -> f" a good universal storage type?
15:34:46 <dons> heh
15:35:02 <dons> that's a type joke, right? ;)
15:35:07 <ihope> Sorty.
15:35:18 <ihope> It's the type of the combinator I've dubbed J.
15:35:26 <basti_> "J" yes?
15:35:41 <ihope> A.k.a. the Iota combinator.
15:35:46 <int-e> can J be used to implement both K and S?
15:35:58 <ihope> Yep.
15:36:01 <int-e> I see.
15:36:17 <basti_> >.<
15:37:06 <ihope> It applies its parameter to S and K, in that order... I think.
15:37:44 <int-e> @type \x -> x ap const
15:37:45 <lambdabot> Not in scope: `ap'
15:37:50 <int-e> @type \x -> x Control.Arrow.ap const
15:37:50 <lambdabot> Not in scope: `Control.Arrow.ap'
15:38:05 <int-e> > ap
15:38:05 <lambdabot>  add an instance declaration for (Show (m (a -> b) -> m a -> m b))
15:38:16 <ihope> !
15:38:18 <int-e> @type \x -> x Control.Monad.ap const
15:38:19 <lambdabot> forall (m :: * -> *) a b a1 b1 t.
15:38:19 <lambdabot> (Monad m) =>
15:38:19 <lambdabot> ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
15:38:47 <int-e> for the (->) x  monad.
15:39:04 <ihope> (->) x is a monad?
15:39:11 <int-e> yep
15:39:44 <int-e> it's defined in Control.Monad.Reader
15:39:50 <int-e> it actually *is* the Reader monad
15:40:31 * ihope crunches the fmap function for that one
15:40:36 <int-e> > let j = \x -> x ap const in j j
15:40:37 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a ->
15:40:37 <lambdabot> b
15:40:37 <lambdabot>   Expected type: ((t -> a1 -> b1) -> (t -> a1) -> t -> b1)
15:40:37 <lambdabot>        -> (a2 -> b2 -> a2)
15:41:12 <int-e> > let j :: (((a -> b -> c) -> (a -> b) -> a -> c) -> (d -> e -> d) -> f) -> f; j = \x -> x ap const in j j
15:41:12 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b ->
15:41:12 <lambdabot> c
15:41:12 <lambdabot>   Expected type: (((a -> b -> c) -> (a -> b) -> a -> c)
15:41:12 <lambdabot>         -> ((a -> b -> c) -> a -> b)
15:41:29 <int-e> nm
15:42:35 <ihope> @type fmap
15:42:36 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
15:42:41 <ihope> @type ap
15:42:42 <lambdabot> Not in scope: `ap'
15:43:01 <Philippa_> @type Control.Monad.ap
15:43:02 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:43:31 <dons> what's the history behind -package monads and -package mtl?
15:43:46 <dons> why two, and why is StateT defined in both (different impls)
15:43:51 <int-e> ok. (J J) = K; (J (J J)) = S. neat.
15:44:26 <int-e> (I've seen it before but I never really tried to follow the definition in detail)
15:45:32 <ihope> (J J) is I, I think.
15:45:37 <int-e> @type let ap = Control.Monad.ap in ((ap const) ap const, ((ap const) ap const) ap const)
15:45:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1 ->
15:45:38 <lambdabot> b
15:45:38 <lambdabot>   Expected type: a -> a2
15:46:35 <ihope> (J (J J)) is (S K), which is equivalent to (K I)...
15:46:52 <astrolabe> If I want 'data Shape = Circle radius | Rectangle side side' and a myRead :: String -> Shape which takes "rect 4.3 2.5" or "circ 6.4" as input, how can I do it without essentially writing the form of each data constructor twice in my code?
15:47:19 <dons> does anyone use -package monads yet?
15:47:26 <dons>  ah, I guess not, since its not in 6.4.1
15:47:40 <dons> TheHunter, any opinions on this new -package monads?
15:48:10 <int-e> ihope: ah I made a stupid mistake.
15:49:04 <jethr0> astrolabe, i don't quite get the question...
15:49:19 <jethr0> what do you mean by "typing the constructor twice"?
15:51:56 <astrolabe> The first way I think of doing it has that 'data' definition in my code, and also a 'myRead' function, that contains pretty much the same information (ie that there is a constructor that takes two float arguments etc).  If I wanted a 'myWrite', I'd need to include the same information again.
15:52:03 <jethr0> ah, i think i see what you're driving at, but in order to automate such a function you'd have to be in a meta-language over haskell...
15:52:40 <ihope> So, what *is* a good universal storage type?
15:52:47 <astrolabe> There's no way you can see of doing it within haskell?
15:53:35 <astrolabe> What if you wanted to read a grammar from a file and then parse another file according to that grammar?
15:53:56 <jethr0> i'm no expert, but i don't think so. "instance read" might be a possibility, but for most cases you'd have to write the projection of input to values anyways
15:54:10 <twb> How is := different from <-?
15:54:11 <Philippa_> astrolabe: you could do that easily with Parsec
15:54:23 <Philippa_> twb: <- is just a binding operation much like let
15:54:31 <ihope> > (:=)
15:54:32 <lambdabot>  Not in scope: data constructor `:='
15:54:40 <ihope> (Look, an emoticon!)
15:54:45 <astrolabe> Philippa: I've been looking at Parsec, could you give me another clue please.
15:54:59 <Philippa_> astrolabe: turn the grammar into an AST, build parser values from that grammar
15:55:03 <jethr0> philippa_, is there a generic read instance for data types of the form "data TT = Constructor Int Int"
15:55:17 <Philippa_> hell, you could turn a subset of Parsec into a language defined by an AST
15:55:29 <astrolabe> AST?
15:55:31 <Philippa_> jethr0: no, but you can derive Read and that works
15:55:34 <Philippa_> Abstract Syntax Tree
15:55:43 <twb> What is :=, then?
15:55:50 <astrolabe> thank you
15:55:53 <jethr0> philippa_, sure, but you'd have to do the parsing manually (once)...
15:56:08 <Philippa_> jethr0: you can parse the grammar using a parsec parser as normal
15:56:19 <Philippa_> twb: it's assignment to a mutable variable
15:56:32 <Philippa_> it's overwrite an actual value in memory that may exist outside the scope of the do statement
15:57:22 <twb> Philippa_: Oh, the same as in SML?
15:57:31 <Philippa_> twb: when people talk about it it is, yes
15:57:36 <Philippa_> Haskell itself has no :=
15:57:42 <Philippa_> some libraries may define one :-)
15:57:47 <twb> Ah.
15:57:57 <ihope> I'm working on a simple variable thinger.
15:58:07 <Philippa_> (the ones I've seen that do, it means pretty much what you'd expect albeit often with some properties deal going on)
15:58:15 <Philippa_> you learning wxHaskell?
15:58:19 <twb> Yes,
15:58:22 <twb> s/,/./
15:58:25 <Philippa_> if so, think of it as "set this list of properties on that thing"
15:58:41 <Philippa_> aside from the property list aspect, it's plain ol' mutable assignment
15:58:56 <Philippa_> oh, wait...
15:59:03 <twb> When you say plist, you mean [key(value),...]?
15:59:06 <Philippa_> it's set foo [prop := val], isn't it?
15:59:12 <Philippa_> haven't used wxHaskell in a while
15:59:20 <twb> Yeah.
15:59:20 <jethr0> philippa_, what did you mean by "parser values", earlier?
15:59:23 <twb> http://wxhaskell.sourceforge.net/quickstart.html
15:59:36 <int-e> > ap const error "42"
15:59:37 <lambdabot> "42"
15:59:40 <Philippa_> jethr0: values/computations in Parsec's monad
16:00:03 <Philippa_> similarly, I might describe a parsing function as a "parser value", or a function as a value...
16:00:10 <ihope> Say, is there any fmap-like that deals with 2-parameter functions?
16:00:13 <SamB> is (:=) an emoticon like a skull-looking robot head?
16:00:22 <jethr0> so, you'd be using parsec to build a specialised parser?
16:00:27 <Philippa_> jethr0: bingo
16:00:34 <Philippa_> welcome to higher-order languages :-)
16:00:59 <Philippa_> it's unlikely to be as well-optimised when you come to run it as something the compiler saw, but it'll run just fine
16:01:08 <int-e> @type Control.Monad.liftM2
16:01:09 <lambdabot> forall r (m :: * -> *) a2 a1.
16:01:09 <lambdabot> (Monad m) =>
16:01:09 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:01:22 <int-e> ihope: for monads, there's that
16:01:31 <SamB> helping you to build a higher order of programs than you'd ever thought possible ;-)
16:01:36 <jethr0> nice, i know that concept from lisp, where you'd generate a program from specification... but that i would be realisticly doable with parsec i wouldn't have thought
16:01:43 <ihope> So what is it?
16:02:01 <SamB> jethr0: only lisp has no decent parsing combinators
16:02:06 <jethr0> true
16:02:12 <SamB> I know, I've looked!
16:02:18 <jethr0> but then s-expressions help a lot
16:02:29 <Philippa_> jethr0: was there anything that suggested to you that it couldn't reasonably be done?
16:02:30 <SamB> not when you want to parse some real language!
16:02:41 <jethr0> although obviously no replacement for sth parsec-like
16:03:02 <SamB> I should try implementing the Abuse engine in Haskell sometime...
16:03:08 <SamB> or something to that effect
16:03:28 <jethr0> well, i am still not sure how to do it. you'd have to parse the grammar and convert it to monadic values. plug those together and apply to some other input
16:03:50 <SamB> jethr0: oh, you mean like my BFInterpreter?
16:03:51 <Philippa_> the plugging is just part of the converting, thankfully
16:03:55 <SamB> @wiki BFInterpreter
16:03:56 <lambdabot> http://www.haskell.org/hawiki/BFInterpreter
16:04:02 <Philippa_> applying is a case of passing the resulting parser to parse followed by the input
16:04:16 <jethr0> well, bfinterpreter is only the second part, isn't it
16:04:21 <SamB> oh.
16:04:33 <SamB> oh, a grammar
16:04:37 <jethr0> i am comfortable with monadic parsing... just doing it twice, is a new idea for me
16:04:42 <SamB> you want to do a parser generator with parsec?
16:05:05 <jethr0> i don't, but philippa_ suggested it was reasonable
16:05:12 <SamB> I would use hs-plugins instead
16:05:22 <SamB> saves writing a parser language
16:05:29 <jethr0> not only a parser generator, but even at runtime
16:05:48 <jethr0> no, perhaps not...
16:05:52 <SamB> hs-plugins lets you skip the generator part and just do the runtime part ;-)
16:05:58 <jethr0> philippa_, would you need to have the grammar at compile time?
16:06:03 <Philippa_> jethr0: nope
16:06:06 <Philippa_> why would you?
16:06:11 <Philippa_> if it's a function it's a function
16:06:24 <SamB> Philippa_: how would you parse any kind of useful data?
16:06:29 <jethr0> i thought haskell had little possibility of producing/evaluating code at runtime
16:06:35 <SamB> without eval?
16:06:45 <SamB> jethr0: well, hs-plugins cheats ;-)
16:06:46 <dons> heh. it's weird that people think this
16:06:50 <Philippa_> SamB: slightly slower than otherwise
16:06:59 <SamB> dynamic linking ;-)
16:07:03 <Philippa_> but essentially? parser (generateParser grammar) "" input
16:07:09 <SamB> same linker as GHCi uses
16:07:35 <jethr0> i still don't get it... 
16:07:36 <Philippa_> generateParser = parse grammarParser ""
16:07:44 <dons> if we have interpreters for the language, then we can always do runtime generated stuff.
16:07:49 <Philippa_> jethr0: parse is parsec's "run" function
16:07:50 <SamB> jethr0: how do you suppose it is that GHCi loads up Haskell modules?
16:07:57 <jethr0> yes, but do we have an interpreter for haskell?
16:08:02 <dons> ummm..
16:08:04 <SamB> yes.
16:08:04 <dons> > 1  + 2
16:08:06 <lambdabot> 3
16:08:06 <dons> yes!!
16:08:08 <jethr0> for interpreted languages i totally get you, but isn't haskell purely compiled?
16:08:08 <SamB> not that we need one.
16:08:14 <SamB> dons: that isn't interpreting, is it?
16:08:19 <SamB> I thought that compiled first!
16:08:29 <Philippa_> who gives a flying fuck so long as it's fast enough anyway? :-)
16:08:34 <dons> I'm using intrepreting in a loose sense here. I mean `interactive'
16:08:34 <jethr0> dons, how is eval implemented in lambdabot?
16:08:37 <SamB> yes, exactly
16:08:45 <SamB> the bytecode is just an optimization
16:08:47 <dons> jethr0, hs-plugins ;)
16:09:02 <jethr0> dons, but you need ghc for that, right?
16:09:15 <Philippa_> jethr0: how do you think hs-plugins is built?
16:09:20 <Philippa_> ghc is just another haskell program
16:09:39 <jethr0> yes, but ghc needs gcc, right?
16:09:44 <dons> no
16:09:49 <dons> well, depends on what you mean..
16:09:51 <jethr0> to produce executable code
16:09:55 <dons> nope
16:09:56 <dons> -fasm
16:10:00 <jethr0> ok
16:10:05 <SamB> does it not use the GCC driver anyways?
16:10:24 <astrolabe> ghc can generate assembler?
16:10:27 <jethr0> i thought hs-plugins was for precompiled modules
16:10:34 <SamB> astrolabe: yes
16:10:37 <SamB> its way faster
16:10:40 <SamB> jethr0: yes!
16:10:41 <dons> jethr0, that's one thing it does.
16:10:41 <int-e> @index liftA2
16:10:42 <lambdabot> bzzt
16:10:47 <astrolabe> wow
16:10:49 <SamB> so you compile them, and then load them
16:10:51 <jethr0> what else?
16:10:51 <dons> it also compiles them for you.
16:11:06 <dons> so you can do: read, eval, print..
16:11:15 <jethr0> ah, didn't know that. will that work standalone? i.e. with only the runtime and libs?
16:11:18 <dons> hs-plugins does the read and eval, you do the print ;)
16:11:21 <SamB> of course, GHCi swallowed the compiler whole...
16:11:34 <jethr0> interesting and _way cool_
16:11:35 <SamB> (in fact, is the compiler)
16:11:53 <SamB> which is a slighly different approach
16:12:04 <astrolabe> So does this mean that the -O2 flag only generates quite fast code, and can be beaten by -fasm?
16:12:05 <dons> not sure what 'standalone' means here... since you want to compile new code at runtime, you'll need a compiler..
16:12:06 <jethr0> just in time interpreter ;-)
16:12:16 <dons> astrolabe, use -O2 and -fasm
16:12:23 <SamB> astrolabe: oh, -fasm is faster to *compile* with
16:12:31 <dons> -fasm and -fvia-C are backends to the optimised Core code.
16:12:47 <SamB> *sometimes* it runs faster too
16:12:58 <dons> so -O2 cranks up Core->Core transforms, which get turned into Cmm, then -fasm or -fvia-C decide how to finally get Cmm to an asm
16:12:59 <SamB> but not generally for number-crunching
16:13:18 <jethr0> dons, let's say you wanted to read a file containing "let a = 4 in a + 2" and use haskell to evaluate it.
16:13:26 <jethr0> what would you need besides runtime and libraries?
16:13:39 <dons> you'd need a haskell compiler or interpreter
16:13:46 <astrolabe> Ah, but I'm probably not going to be able to reduce a week of run time by all that much?
16:13:47 <jethr0> how would you call it?
16:13:53 <dons> ah, you want code?
16:13:54 <SamB> ghc 6.6 should be good-to-go
16:14:03 <SamB> right?
16:14:19 <dons> getLine >>= eval >>= print
16:14:20 <dons> ;)
16:14:26 <SamB> I mean, you could just use the ghci library...
16:14:32 <dons> s/getLine/readFile/
16:14:45 <dons> import System.Plugins.Eval
16:14:50 <jethr0> dons, i thought there was no eval...
16:14:52 <int-e> @type interact
16:14:53 <jethr0> @type eval
16:14:54 <lambdabot> (String -> String) -> IO ()
16:14:54 <lambdabot> Not in scope: `eval'
16:15:00 <SamB> you'd need a main and a filename somewhere too
16:15:02 <Philippa_> jethr0: there is no eval in the standard
16:15:07 <dons> @type System.Eval.Haskell
16:15:08 <lambdabot> Not in scope: data constructor `System.Eval.Haskell'
16:15:10 <dons> @type System.Eval.Haskell.eval
16:15:11 <lambdabot> forall a.
16:15:11 <lambdabot> (AltData.Typeable.Typeable a) =>
16:15:11 <lambdabot> String -> [System.Eval.Utils.Import] -> IO (Maybe a)
16:15:11 <Philippa_> there is an eval in hs-plugins
16:15:15 <dons> ah ha!
16:15:23 <jethr0> ok
16:15:28 <SamB> @type System.Eval.Utils.Import
16:15:29 <lambdabot> Not in scope: data constructor `System.Eval.Utils.Import'
16:15:35 <SamB> @kind System.Eval.Utils.Import
16:15:36 <lambdabot> *
16:15:36 <dons> jethr0, we've only spent 10 mins now talking up eval, so I assume it exists .. :)
16:15:41 <SamB> @sort System.Eval.Utils.Import
16:15:42 <lambdabot> Maybe you meant: more part
16:15:48 <jethr0> ;-)
16:15:54 <dons> SamB gooes kind-crazy
16:16:02 <SamB> @quote SamB
16:16:03 <lambdabot>  C is a good language. If what you want is an assembly language where you
16:16:03 <lambdabot> can't be sure what anything does
16:16:29 <dons> jethr0, check out :
16:16:32 <SamB> @quote jethr0 
16:16:32 <lambdabot> jethr0 hasn't said anything memorable
16:16:34 <dons> @hwher hs-plugins
16:16:35 <lambdabot> Unknown command, try @listcommands.
16:16:36 <jethr0> haha
16:16:39 <dons> @where hs-plugins
16:16:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
16:16:40 <SamB> this is a sore travesty
16:16:44 <jethr0> @serene dons
16:16:45 <lambdabot> dons is in #haskell. Last spoke 5 seconds ago.
16:17:11 <jethr0> philippa_, so does eval come into play in your meta-parsec idea?
16:17:34 <jethr0> @quote samb
16:17:35 <lambdabot> samb hasn't said anything memorable
16:17:39 <int-e> @quote lambdabot
16:17:40 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
16:17:45 <jethr0> @quote SamB
16:17:45 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
16:17:45 <lambdabot> printed
16:17:46 <int-e> is that the only thing?
16:17:52 <SamB> jethr0: it probably doesn't. however, it does mean you can write your parsers in Haskell and load them dynamically...
16:18:15 <SamB> @quote lambdabot
16:18:15 <lambdabot>  lambdabot hasn't said anything memorable
16:18:17 <Philippa_> jethr0: no, it doesn't
16:18:24 <jethr0> samb, so you generate genuine haskell code and pass that to hs-plugins?
16:18:33 <Philippa_> SamB: right, that's a useful trick if you need to parse fast
16:18:34 <dons> right.
16:18:52 <Philippa_> dons: what're the odds on a func to compile from TH structures at this point, anyway?
16:18:55 <SamB> jethr0: no, I'm just thinking it would be more useful to use haskell code rather than grammar specifications in some restricted language
16:19:06 <dons> Philippa_, already written such a one a few times.
16:19:09 <Philippa_> cool
16:19:12 <dons> all it has to do is eval .show 
16:19:18 <Philippa_> heh, cool
16:19:26 <Philippa_> I keep forgetting obviousness like that...
16:19:28 <Philippa_> oh, wait
16:19:30 <jethr0> samb, i get that. so you'd be parsing haskell code instead of writing a parsec parser for some weirdo grammar file
16:19:32 <int-e> @type System.Eval.Haskell.unsafeEval
16:19:33 <Philippa_> how about whole modules?
16:19:33 <lambdabot> forall a. String -> [System.Eval.Utils.Import] -> IO (Maybe a)
16:20:04 <SamB> jethr0: yes. and more importantly, you'd be writing Haskell instead of wierd grammar files.
16:20:06 <jethr0> what are TH structures?
16:20:11 <dons> harder, you'd have to write your own thingy
16:20:15 <Philippa_> TH = Template Haskell
16:20:18 <jethr0> ah
16:20:24 <Philippa_> macro-like facilities for Haskell
16:20:34 <Philippa_> the structures I'm talking about are data structures that describe source code
16:20:35 <jethr0> ya, i've heard about it
16:20:41 <Philippa_> dons: that's a shame, I'd love to have that
16:20:52 <int-e> @type System.Eval.Haskell.unsafeEval "" [""]
16:20:53 <lambdabot> forall a. IO (Maybe a)
16:20:53 <Philippa_> I'd also like to be able to quasi-quote entire modules...
16:21:01 <dons> run :: (Typeable u, Ppr t) => Q t -> u
16:21:02 <Philippa_> because believe me, I have some sick and twisted uses for that :-)
16:21:10 <jethr0> ah, i saw those. they were used by some scheme guy to discredit template haskell
16:21:16 <dons> I have another, run2 :: Q Exp
16:21:31 <SamB> jethr0: thats silly
16:21:36 <jethr0> hehe
16:21:57 <Philippa_> if you want to say "it's not as trivial to use as Scheme macros" then fair enough...
16:21:59 <int-e> Well, lisp (and scheme) has hardly any syntax at all ... it's hardly a fair comparison.
16:22:01 <SamB> template haskell is a lovely toy
16:22:07 <Philippa_> but for a language without atoms? It's a neat trick
16:22:08 <dons> so it takes some Q monad expr that is Ppr'able, and gives you a Typeable haskell value back. `run' is fun
16:22:32 <dons> -- *Eval.Meta> run [| 1 + 2 ::Int |] + 3 :: Int
16:22:32 <dons> -- 6
16:22:35 <jethr0> i didn't compare or judge... just said where i'd seen TH structures before
16:22:51 <dons> runtime metaprogramming for the masses, Philippa_ ;)
16:23:02 <SamB> dons: you should write a paper!
16:23:05 <SamB> runtime TH! wow!
16:23:15 <int-e> jethr0: that wasn't aimed at you. if anything, it was aimed at the scheme guy ;)
16:23:18 <dons> papers are good :)
16:23:32 <SamB> dons: you could use that to serialize functions! omg!
16:23:44 <dons> how?
16:23:51 <SamB> well, okay, not quite.
16:24:07 <SamB> but you could serialize them after you ppr them and before you compile them ;-)
16:24:20 <dons> how can you get from a -> Exp ?
16:24:43 <SamB> hmm?
16:24:48 <jethr0> dons, so wouldn't it be possible to auto-generate Read instances for constructors?
16:24:51 <SamB> how do you compile them?>
16:25:01 <Philippa_> jethr0: yup
16:25:11 <SamB> doesn't that already work?
16:25:14 <Philippa_> quasi-quote the type, read the structure, etc etc
16:25:25 <jethr0> samb, i asked earlier... does it?
16:25:29 <dons> ah, right.
16:25:32 <SamB> deriving (Read)?
16:25:36 <SamB> not work for you?
16:25:42 <jethr0> does it work?
16:25:43 <SamB> or are they in a library?
16:25:47 <jethr0> haven't tried yet
16:26:06 <SamB> data Foo = Foo deriving (Read) should work
16:26:14 <jethr0> samb, i'll try
16:26:57 <jethr0> yup, worked like a charm
16:27:01 <jethr0> @serene astrolabe
16:27:01 <lambdabot> astrolabe is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
16:27:01 <lambdabot> 13 minutes and 15 seconds ago.
16:28:41 <dons> oh, I find this fun on haskell-cafe: "It seems that compiled programs run better then interactive ones."
16:28:44 <dons> :)
16:29:02 <jethr0> for suitable definitions of "better"
16:29:03 <Philippa_> well duh
16:29:33 <SamB> jethr0: you could probably use TH to do that too, but it would be a) a pain and b) overkill
16:29:40 <chrisbrown> night all
16:30:16 <dons> yeah, it's a great revelation, eh? and there I was interpreting all my code all these years. compilers sound k00l!
16:30:22 <jethr0> dons, where did that Eval.Meta thing come from? your code or library?
16:30:36 <dons> it's a little module i'm playing around with, yeah. my code.
16:30:46 <jethr0> cool
16:31:07 <dons> stick to System.Eval.Haskell though, if you need this kind of stuff (for now).
16:31:17 <dons> it's the stable eval branch, in a sense
16:31:29 <dons> (since it gets a pretty hard workout on lambdabot ;)
16:32:03 <SamB> lets exercise it some more ;-)
16:32:13 <SamB> > "Hello, "++show xxxx
16:32:14 <lambdabot>  Not in scope: `xxxx'
16:32:18 <SamB> > "Hello"
16:32:19 <lambdabot> "Hello"
16:32:23 <dons> lambdabot wins again
16:32:28 <SamB> yes
16:32:46 <SamB> > const
16:32:47 <lambdabot>  add an instance declaration for (Show (a -> b -> a))
16:32:51 <int-e> you have a 1/26^8 chance to get it right if you use 8 small caps letters ;)
16:32:58 <dons> hehe
16:33:17 <SamB> > aaaaaaaa
16:33:18 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:19 <SamB> > aaaaaaaa
16:33:20 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:20 <dons> int-e, is that a small enough risk, balancing off the obscurity of possible type errors with big random strings in them ?
16:33:21 <SamB> > aaaaaaaa
16:33:21 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:36 <SamB> > aaaaaaaa
16:33:37 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:38 <SamB> > aaaaaaaa
16:33:39 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:40 <SamB> > aaaaaaaa
16:33:41 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:42 <SamB> > aaaaaaaa
16:33:42 <dons> Samb...
16:33:43 <lambdabot>  Not in scope: `aaaaaaaa'
16:33:46 <int-e> dons: I don't see what you are protecting against ;)
16:33:53 <dons> you.
16:34:04 <dons> > 26^8
16:34:05 <SamB> dons: I'm demonstrating how long it takes to get it to do anything
16:34:05 <lambdabot> 208827064576
16:34:31 <int-e> > fix id
16:34:32 <lambdabot> Add a type signature
16:34:37 <SamB> > 26^4
16:34:38 <lambdabot> 456976
16:34:42 <int-e> > fix id :: Int
16:34:43 <lambdabot> Exception: <<loop>>
16:34:46 <jethr0> System.Eval.Haskell is not in my GHC distribution... should it be?
16:34:49 <SamB> 4 letters would likely be enough
16:34:57 <dons> jethr0, hs-plugins..
16:35:05 <SamB> dons: so how is xxxx any worse than fix id :: Int?
16:35:08 <jethr0> k
16:35:13 <dons> umm..?
16:35:19 <SamB> <lambdabot> Exception: <<loop>>
16:35:39 <dons> 'xxxx' is an error in the system, where the user seesthe internal workings of runplugs. fix id is just haskell, it should fail
16:35:43 <jethr0> what _are_ you guys trying?
16:35:50 <int-e> dons: if you want something more 'serious' to fix, fix @pl (\x -> x x) (\x -> x x) ;-)
16:35:59 <SamB> @pl (\x -> x x) (\x -> x x)
16:36:00 <dons> talk to TheHunter.
16:36:03 <lambdabot> ap id id (ap id id)
16:36:03 <lambdabot> optimization suspended, use @pl-resume to continue.
16:36:10 <SamB> @pl-resume
16:36:10 <dons> fixed imo ;)
16:36:18 <int-e> jethr0: a lambdabot feature that's now gone.
16:36:18 <lambdabot> ap id id (ap id id)
16:36:18 <lambdabot> optimization suspended, use @pl-resume to continue.
16:36:19 <jethr0> samb, that takes _minutes_...
16:36:25 <SamB> @pl-resume
16:36:28 <SamB> jethr0: which does?
16:36:36 <jethr0> i know the xxxx feature ;-)
16:36:45 <SamB> jethr0: its actually a bug!
16:36:45 <lambdabot> ap id id (ap id id)
16:36:45 <lambdabot> optimization suspended, use @pl-resume to continue.
16:36:47 <SamB> jethr0: its actually a bug!
16:36:47 <int-e> it was neatr
16:36:48 <jethr0> pl-resume on that expression
16:36:57 <SamB> er. wrong history line!
16:37:04 <SamB> @pl-resume
16:37:34 <dons>  86m 6852 R 99.7 17.1   0:20.05 lambdabot
16:37:35 <lambdabot> ap id id (ap id id)
16:37:35 <lambdabot> optimization suspended, use @pl-resume to continue.
16:37:43 <dons> seems to be coping reasonable well
16:37:45 <SamB> @pl-resume
16:37:46 <jethr0> you trying to let lambdabot reveal it's environment from inside the eval?
16:37:53 <int-e> > fix $ take 10 . (1:) . scanl (+) 1
16:37:53 <jethr0> like with xxxx?
16:38:02 <SamB> jethr0: who, me?
16:38:03 <lambdabot> ap id id (ap id id)
16:38:03 <lambdabot> optimization suspended, use @pl-resume to continue.
16:38:03 <SamB> no.
16:38:04 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
16:38:23 <jethr0> never mind...
16:38:28 <SamB> xxxx was a bug...
16:38:31 <int-e> no, it was just a nice syntax trick.
16:38:39 <int-e> well, feature. bug. whatever.
16:38:42 <jethr0> it was revealing more than it should've
16:38:49 <dons> it leaked a little info about how '>' was implemented, which was annoying
16:38:52 <jethr0> and using gensyms hasn't exactly fixed it!
16:38:56 <SamB> GHCi reveals "this"
16:39:04 <dons> kind of like how ghci sometimes lets you get at 'it'
16:39:11 <dons> this, ah. is that it
16:39:16 <jethr0> although guessing the current name is rather unlikely
16:39:28 <int-e> > lift id id
16:39:28 <dons> Prelude> 1
16:39:28 <dons> 1
16:39:28 <dons> Prelude> :t it
16:39:29 <dons> it :: Integer
16:39:29 <lambdabot>   The function `lift' is applied to two arguments,
16:39:29 <lambdabot>   but its type `m a -> t m a' has only one
16:39:29 <lambdabot>   In the definition of `viqzjelf': viqzjelf = lift id id
16:39:38 <int-e> there. viqzjelf :)
16:39:51 <dons> but it won't be that the next time ;)
16:39:56 <dons> so who cares?/ not me.
16:39:57 <int-e> I know.
16:39:58 <jethr0> > lift id id
16:39:59 <lambdabot>   The function `lift' is applied to two arguments,
16:39:59 <lambdabot>   but its type `m a -> t m a' has only one
16:39:59 <lambdabot>   In the definition of `gkrivqym': gkrivqym = lift id id
16:40:07 <jethr0> there. gkrivqym
16:40:07 <int-e> but it obscures the error message ;)
16:40:11 <jethr0> find the pattern
16:40:19 <dons> yeah. maybe size=4 would be better.
16:40:40 <int-e> hmm. what sort of random number generator is ghc using?
16:40:42 <jethr0> i don't see the added benefit of not having xxxx.
16:40:50 <dons> jethr0, check the logs.
16:40:53 <jethr0> it was no security issue in the first place, was it
16:41:00 <dons> if you know the name, then you can play annoying games
16:41:00 <jethr0> just a neat trick
16:41:06 <dons> s/neat/annoying ;)
16:41:11 <jethr0> g
16:41:14 <int-e> it doesn't matter :)
16:41:24 <jethr0> dons, i've seen it in action
16:41:32 * SamB plots to find ways to sneak annoying features into lambdabot
16:41:43 <dons> hehe
16:42:28 <jethr0> @babel es en hola senor. como esta? quiero un piso por la noche por favor
16:42:29 <lambdabot>  hello senor. like this? I want a floor at night please
16:42:52 <SamB> I guess spanish-speakers sleep on the floor.
16:43:09 <jethr0> hehe, it's in line with their siesta tradition
16:43:56 <SamB> I mean, we can understand why you fixed that TH issue...
16:44:07 <jethr0> @babel en es hello, mister. how are you? i would like a room for tonight, please
16:44:08 <lambdabot>  hola, seor cmo es usted? quisiera un cuarto para la esta noche, por
16:44:08 <lambdabot> favor
16:44:46 <dons> > lift id id
16:44:47 <lambdabot>   The function `lift' is applied to two arguments,
16:44:47 <lambdabot>   but its type `m a -> t m a' has only one
16:44:47 <lambdabot>   In the definition of `ckc': ckc = lift id id
16:44:47 * jethr0 is just trying out annoying features of \bot
16:44:48 <SamB> @babel es en hola, seor cmo es usted? quisiera un cuarto para la esta noche, por favor
16:44:49 <lambdabot>   hello, seor cmo are you? he wanted a quarter for tonight, please
16:44:57 <jethr0> @serene
16:44:57 <lambdabot> Lately, I have seen dons, int-e, jethr0 and samb.
16:45:32 <SamB> why do you always say "@serene"
16:45:54 <jethr0> samb, because i like the edit-distance thingey so much
16:46:11 <jethr0> my plan was to memorize sensible aliases for all commands, but i'm not there yet
16:46:18 <jethr0> @sense samb
16:46:19 <lambdabot> Unknown command, try @listcommands.
16:46:19 <dons> but it's like intentionally using the wrong word in a conversation..
16:46:29 <jethr0> exactly :P
16:46:49 <jethr0> @tuple (4,5)
16:46:50 <lambdabot> forall a b. (Num a, Num b) => (a, b)
16:46:54 <dons> and anyone listenting has to do some extra head computation to work out what just happened
16:47:07 * SamB plots to steal those commands for something else, which sometimes does that and sometimes does something else ;-)
16:47:08 <dons> which is annoying..
16:47:24 <dons> SamB, oh, we could introduce @random-annoying-action 
16:47:26 <jethr0> maybe we can add that to the list of annyoing "lambdabot" features :P
16:47:37 <SamB> dons: that isn't close to anything
16:48:20 <SamB> jethr0: on the other hand, if your efforts result in tighter limits on the spellchecker, more power to you.
16:48:23 <SamB> or less, whichever
16:48:32 <jethr0> @quoth SamB
16:48:32 <lambdabot>  because sliced bread gives horribly uninformative error messages?
16:49:34 <jethr0> @gzogzle haskell
16:49:35 <lambdabot> http://www.haskell.org/
16:49:50 <SamB> @ggl Haskell
16:49:51 <lambdabot> Maybe you meant: ghc pl
16:49:57 <SamB> @gogl Haskell
16:49:57 <lambdabot> http://www.haskell.org/
16:50:08 <jethr0> samb, remember max editing distance is 3...
16:50:15 <jethr0> @tape id
16:50:16 <lambdabot> forall a. a -> a
16:50:17 <SamB> oh, is it?
16:50:30 <SamB> I think edit distances are calculated strangely
16:50:34 <jethr0> why?
16:50:47 <SamB> @x
16:50:48 <lambdabot> Maybe you meant: pl wn
16:50:48 <jethr0> it also can't be too close to other valid commands
16:50:52 <SamB> @xx
16:50:53 <lambdabot> Maybe you meant: pl wn
16:50:56 <SamB> @xxx
16:50:56 <lambdabot> Unknown command, try @listcommands.
16:51:08 <jethr0> @plane \x y -> x
16:51:09 <lambdabot> Unknown command, try @listcommands.
16:51:13 <jethr0> @plan \x y -> x
16:51:13 <lambdabot> const
16:51:27 <dons> there's 2 functions at play, unique prefixes, and then edit distances
16:51:31 <jethr0> @evil "samb"
16:51:32 <lambdabot> "samb"
16:51:43 <dons> @vers
16:51:43 <lambdabot> lambdabot 3p219, GHC 6.5.20050806 (Linux i686)
16:51:43 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:51:47 <dons> isn't triggering the edit distance code
16:51:58 <jethr0> good to know
16:52:12 <dons> the  edit distance is the last resort, in a sense
16:52:27 <dons> and even then you only get to make 3 typos before it gives up
16:52:37 <SamB> dons: we think we figured out the problem with the linker on PPC Linux
16:52:41 <dons> unless you're jethr0, and intentionally make 3 typos every time ;)
16:52:47 <dons> SamB, ah, cool.
16:52:52 <dons> the USE_MMAP problem?
16:52:55 <jethr0> ;)
16:52:57 <SamB> http://paste.lisp.org/display/14450#1
16:53:06 <SamB> we haven't tested it exactly, though
16:53:08 <Philippa_> dons: JOOI, are you getting my occasional PMs?
16:53:13 <dons> oh. hmm
16:53:35 <SamB> it should fix a *possible* problem though
16:54:00 <dons> Philippa_, fixed. my fault
16:54:21 <SamB> I mean, if you have an object file with no undefined symbols, that would trigger that error message that psi got...
16:54:52 <SamB> oh, and we might have done it wrong! maybe I messed up the precedence
16:55:21 <Philippa_> dons: 'k, time to cuntpaste the lot at you again then
16:55:30 <dons> heh
16:55:36 <jethr0> i find that offensive
16:55:38 <jethr0> :P
16:56:55 <lisppaste2> SamB annotated #14450 with "parentheses" at http://paste.lisp.org/display/14450#2
16:59:13 * SamB still doesn't get what let-no-escaping is
17:02:27 * SamB wonders how musasabi is coming along...
17:02:49 <jethr0> @sneer musasabi
17:02:50 <lambdabot> musasabi is in #haskell-overflow, #flippi, #haskell-blah and #haskell.
17:02:50 <lambdabot> Last spoke 1 hour, 36 minutes and 15 seconds ago.
17:03:20 <SamB> (he's trying to redo the WireProtocol with FPS)
17:03:35 <jethr0> samb, you got that url to your brainf*ck interpreter once more, pls
17:03:44 <jethr0> fps?
17:04:14 <SamB> @where fps
17:04:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:04:21 <SamB> fast packed strings
17:04:28 * jethr0 just installed firefox NoScript extension and it makes him feel much more secure in the world "out" there...
17:05:30 <dons> fps is turning into a bit of a disease..
17:05:42 <SamB> is it?
17:06:23 <SamB> dons: do you prefer something like
17:06:24 <dons> i'm ambivalent about how much it should be used in haskell code. oh well.
17:06:53 <SamB> hGetChars h n = sequence (replicate n (hGetChar h))
17:06:55 <SamB> ?
17:07:01 <dons> :}
17:07:23 <SamB> I can't imagine that would perform at all well
17:07:53 <dons> oh, i think for performance we should go nuts with it, as I do ;)
17:08:11 <Philippa_> just that it's not always overly readable?
17:08:16 <Philippa_> are there any portability issues, btw?
17:08:28 <dons> don't think so Philippa_.
17:08:28 <SamB> it won't likely work on PalmOS
17:08:37 <dons> it is readable, but what's the semantics. they're unhaskellish
17:08:43 <dons> SamB?
17:08:44 <Philippa_> ah
17:08:52 <Philippa_> (see, I've not looked into it much)
17:08:53 <SamB> I know ;-)
17:09:03 <dons> well, I was happy to see it all ran nicely on a mips64
17:09:14 <SamB> PalmOS won't likely run Haskell code anyway...
17:09:17 <dons> which is about as far from x86 as I can get.
17:09:27 <dons> SamB.. oh have you seen the nhc on Palm project?
17:09:35 <dons> they run nhc on the palm!
17:09:37 <dons> hehe
17:09:46 <SamB> dons: that is only NEARLY haskell
17:09:54 <dons> H98 is haskell
17:10:15 <Philippa_> dons: how about non-POSIX OSes?
17:10:29 <dons> Build-Depends:       base
17:10:32 <jethr0> what do you think of type annotations in code. i just read that haddock can't make documentation for functions without type declaration ;-(
17:10:45 <SamB> anyway, the only palm in the house I half-sold to my littlest sister and then she and my other sister broke it...
17:10:57 <Cale> jethr0: They're generally good documentation anyway
17:11:04 <dons> you should use type annotatoins a lot, jethr0. they're machine-checkable documentation
17:11:09 <jethr0> half-sold means she got it, but you never saw the money, right?
17:11:12 <Philippa_> I don't use them as much as I should
17:11:31 <Philippa_> I'd *really* like to be able to declare module-scope tyvars and unify them with eg the type of a particular function
17:11:39 <Philippa_> that'd really help some of the things I'm doing atm be more readable
17:11:40 <jethr0> hmm, but if you change stuff you'll have to alter all the types. and theoretically they could be auto-generated in the code...
17:12:06 <Philippa_> if it'll run without an annotation you can always delete the old one if you don't mind losing the docs
17:12:09 <dons> use a script to insert them for you, if you find this tedious. in practice I don't think it is a problem
17:12:29 <dons> jethr0, do you use vim?
17:12:36 <jethr0> i guess, once your program has reached _some_ sort of stability, juggling everything around is bad anyways
17:12:43 <jethr0> yup
17:12:56 <Cale> jethr0: well, if you can't be bothered to update the type signatures, the documentation will probably be wrong anyway
17:12:58 <dons> here's a script to insert  type annotations for you, then: 
17:12:59 <Philippa_> dons: ooh, good point - is GHC-API good enough to get it to autogenerate annotations for you yet?
17:13:00 <dons> :map ty :.!typeOf %
17:13:09 <dons> where: typeOf ==
17:13:11 <dons> FILE=$*
17:13:11 <dons> DECL=`cat`
17:13:11 <dons> ID=`echo $DECL | sed 's/^\([^ ]*\).*/\1/'`
17:13:11 <dons> echo ":t $ID" | ghci -v0 -cpp -fglasgow-exts -w $FILE
17:13:12 <dons> echo $DECL
17:13:19 <jethr0> i actually use both and always want to use emacs more, but vim on the console feels "faster" to me ;-)
17:13:36 <SamB> jethr0: half sold means she gave me half the money
17:13:49 <dons> save the typeOf code to a shell script, stick :map .. in your .vimrc. then hit ty on a top-levle decl, and it'll insert the type on the line above
17:13:54 <Philippa_> heh, of course - when in doubt, hack it :-)
17:13:57 <jethr0> cool
17:14:20 <dons> Philippa_, right ;)
17:14:54 <dons> there's nothing that can't be done the ghc-api, that can't be done with sed and ghci alone ;)
17:15:09 <dons> oh, too many negatives in there..
17:15:31 <jethr0> do you actually have stuff like @pl, @hoogle, @index, @type somewhere near the editor (mapped)?
17:16:10 <SamB> jethr0: that would require Yi to support Lambdabot plugins ;-)
17:16:11 <dons> nope. some one should do it. it'd be a good project - a cmd line interfacee to lambdabot
17:16:55 <jethr0> i guess htags works for @index though, although i'm not using it
17:17:11 <jethr0> s/for/as a substitute/
17:17:16 <jethr0> for*
17:18:27 <dons> oh, I really use use htags on fptools. hmm. that's something to do today.
17:18:53 <jethr0> should*?
17:19:15 <dons> rather than storing all the jump points in my head :/
17:19:42 <jethr0> nice going dons :)
17:20:03 <jethr0> unsafeEval: "Note that if you get the proof wrong, your program will likely segfault."
17:20:03 <jethr0> hehe
17:20:29 <dons> that's reasonable
17:20:33 <dons> don't you think?
17:20:47 <SamB> oh, you asked about http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter before, right?
17:20:57 <jethr0> sure
17:21:41 <jethr0> yah, i wanted to look at the parsec part. i (extremely superficially) tried to do some parsec stuff before, but didn't know how to import "natural" or something...
17:21:46 <dons> jethr0,likely depending on how well you know how your type is represented in the runtime.
17:21:49 <jethr0> definitely worth another try!
17:22:04 <dons> i.e. Int/Char won't crash. () / Bool will
17:22:13 <jethr0> i think i'll leave this feature to compiler/runtime insiders
17:22:19 <dons> it's just like programming in C :)
17:22:28 * jethr0 laughs heartily
17:23:06 <jethr0> printf("%s there's no %s like %s\n", "place", "home")
17:23:11 <jethr0> :)
17:23:53 <Cale> Prelude Text.Printf> printf "%s there's no %s like %s\n" "place" "home"
17:23:53 <Cale> place there's no home like *** Exception: Printf.printf: argument list ended prematurely
17:24:16 <Cale> :)
17:24:19 <rep> hehe
17:28:51 * jethr0 is still unhappy with the mixing of associativity between (.), ($) and monadic/arrow operators
17:29:04 <jethr0> drives me crazy to switch reading direction all the time *grr*
17:32:40 <Cale> reading direction?
17:32:45 <dons> hmm. shouldn't hasktags generate info from haddock files...
17:33:19 <jethr0> cale, you know: reading (.) and ($) from right to left and all the standard monad/arrow ops from left to right...
17:33:40 <jethr0> *damn* xchat doesn't notice when i get disconnected by my ISP...
17:33:44 <Cale> I read (.) and ($) from left to right like everything else
17:34:01 <jethr0> hmm, maybe i'm just stupid
17:34:10 <jethr0> but i like to read my code with the data flow
17:34:13 <musasabi> he's 
17:34:20 <musasabi> (ignore that)
17:34:20 <Cale> Yeah, the data flows the other way
17:35:23 <Cale> but it's something that you get used to in math, I suppose :)
17:35:51 <Cale> Sometimes it does seem like aligning things with the data flow would perhaps be nicer
17:35:59 <jethr0> i still haven't understood how haskell determines which state monad instance to use when you have several state monads of equal type...
17:36:01 <Cale> x f  rather than  f x
17:36:33 <Cale> jethr0: usually based on the version of runState that you call
17:36:56 <jethr0> i have no big problems with math notation. that i can get used to, but "f . g . h >>= j . k >>= l . m" drives me crazy
17:37:03 <Cale> use =<<
17:37:15 <jethr0> i know, but i'm reading samb's code right now ;-)
17:37:20 <Cale> ah :)
17:37:43 <jethr0> i don't understand why there's no standard operator for (flip (.))
17:38:04 <jethr0> or why monads/arrows don't use the left-associative ops per default
17:38:25 <Cale> well, I think the thing to do is to understand the composite functions, then consider the binds
17:38:56 <jethr0> sure, but it's still odd to represent data flow so contortedly
17:39:18 <Cale> what code are you reading?
17:39:24 <jethr0> BFInterpreter
17:39:31 <Cale> hmm
17:39:34 <jethr0> just to get started with some parsec twiddling
17:39:36 <Cale> putc and getc?
17:39:42 <jethr0> yup
17:40:04 <Cale> well, getc reads just fine to me
17:40:11 <twb`> wxHaskell 0.9.4 for Debian http://twb.ath.cx/~twb/debian/pool/wxhaskell
17:40:31 <jethr0> so, all the code "insider/after" runState is inside one state monad? what happens if i call runstate inside there again for another. won't that get confusing?
17:40:44 <jethr0> getc is short enough, but i had to struggle with some of my own code as well
17:41:07 <jethr0> twb` cool, thx
17:41:19 <Cale> putc is perhaps in an awkward order
17:41:35 <jethr0> no, getc is fine. i meant putc
17:41:37 <twb`> jethr0: you can tell Igloo or whoever they can add that to their officially unofficial archive if they want.
17:41:57 <jethr0> ok, if i see them and remember :P
18:07:02 <SamB> musasabi: are you still up?
18:07:19 <dons> ah ha, with a bit of effort, I got all of fptools into a tags file :)
18:08:14 <dons> oh this is cool. anyone want an fptools tags file?
18:08:28 <jethr0> does anyone get this (shortened): "arrow-style parser combinators can at most parse [...] context-free grammars while monadic combinators can also handle context-sensitive grammars"
18:08:40 <jethr0> i thought any monad could be described by an arrow???
18:09:11 <SamB> jethr0: doesn't say you can use it for anything you can use a monad for...
18:09:12 <Cale> I think "arrow-style" refers to the particular style described by Swierstra and Duponcheel
18:09:22 <musasabi> SamB: haven't been able to sleep regularly in the past few weeks.
18:09:24 <jethr0> hmm, ok
18:09:44 <SamB> musasabi: ah
18:10:02 <SamB> musasabi: so hows that thing coming?
18:10:03 <jethr0> samb, well if you can implement monads with arrows, you can do anything with arrows, you can with monads
18:10:11 <jethr0> but i think i get the point...
18:10:36 <SamB> jethr0: I sure didn't much like them...
18:10:40 <SamB> (for parsing)
18:10:50 <Cale> SamB: PArrows seems to work for me
18:10:58 <musasabi> SamB: one result is that I am awake 20 hours a day, but most of the time too dazed to do anything that I feel is presentable.
18:10:59 <Cale> SamB: though the error messages aren't beautiful
18:11:18 <SamB> Cale: what have you parsed with them?
18:11:26 <jethr0> musasabi, that's exactly like i feel. haven't slept long/well for a few days myself
18:11:31 <SamB> musasabi: see, this is why you should record often.
18:11:37 <SamB> then you can revert.
18:11:39 <musasabi> Cale: feel free to fix that ;)
18:11:41 <jethr0> what a weird zombi-like feeling...
18:12:03 <Cale> SamB: just some small tests I did today
18:12:04 <jethr0> but on the other hand i've done some of my best "work" in a similar state
18:12:11 <Cale> Nothing too complex
18:12:14 <SamB> musasabi: "feel free", he says...
18:12:42 <Cale> musasabi: Of course, by "beautiful", I mean "as detailed as Parsec's"
18:12:55 <SamB> Cale: did you try both alternatives and repetition in the same thing?
18:13:10 <Cale> I think so, let me try it again :)
18:13:25 <SamB> both ways round?
18:13:35 <jethr0> samb, you mean repetion of alternatives or alternatives of repetition?
18:13:57 <SamB> jethr0: exactly
18:19:21 <Cale> SamB: it appears to work...
18:19:55 <Cale> (runParser $ many1 (many1 (char 'a') <+> many1 (char 'b'))) "aaabbab" = Right ["aaa","bb","a","b"]
18:20:40 <SamB> hmm
18:20:55 <SamB> maybe I tried to change it or something
18:20:55 * SamB doesn't remember
18:21:49 <musasabi> SamB: there may well be bugs lurking in the implementation, if you happen to find something that seems to be parsed wrongly I could try to fix it.
18:25:41 <Cale> musasabi: what kind of parsing does it implement?
18:26:30 <Cale> It doesn't appear to do full backtracking, though I might have a mistake in this input here
18:27:15 <musasabi> Cale: currently it uses a very straightforward algorithm. I noticed that compiling an optimized parser was too slow for most inputs :-(
18:28:01 <Cale> oh, nevermind, that was my mistake :)
18:28:51 <Cale> er, maybe not
18:29:05 <Cale> is <+> supposed to be symmetric choice?
18:29:19 <Cale> it doesn't seem to mind not consuming the full input
18:30:08 <musasabi> <+> is left biased.
18:30:47 <musasabi> I think your problem is that the left choice is not failing.
18:30:57 <Cale> well, yes
18:31:14 <Cale> It succeeds, but then the parse fails later
18:32:00 <Cale> many1 (char 'b') <+> (char 'b' >>> many (char 'a'))
18:32:19 <Cale> on the input "ba", just silently ignores the 'a'
18:33:15 <Cale> when it probably should fail
18:33:32 <Cale> (or at least give me the rest of the string back)
18:34:29 <Cale> ReadP seems very clever, I haven't looked at its source code, but I thought that arrow-style libraries were invented for just that sort of thing.
18:34:50 <musasabi> Cale: I'll look at that in the morning, thanks for pointing out the problem.
18:35:35 <Cale> Of course, the thing you'd really want is for it to find the second option there, but then you're doing more than LL1 parsing
18:36:11 <Cale> I wish I could get Swierstra and Duponcheel's paper
18:36:18 <Cale> you wouldn't happen to have a copy?
18:36:19 <musasabi> Try readP_to_S (many (char 'f')) "ffffff" ;)
18:37:29 <Cale> well, that seems to work
18:38:23 <musasabi> http://www.cs.uu.nl/people/doaitse/Papers/1996/DetErrCorrComPars.pdf ?
18:38:44 <Cale> ah, yes, that's it
18:39:41 <Cale> I looked through the online journal databases that I had, but the journal that it was published in didn't have back issues online quite that far back
18:45:41 <dons> mm. cabalised yi is tasty
18:47:24 <Cale> What is known about determining, from a grammar, what kind of backtracking would be necessary to parse it?
18:49:23 <Xianianol> What's the best way to make something like "do x <- characters" ? I want that x just accepts/fed by characters from a-z.
18:49:47 <Xianianol> If I just allow Chars in general, it accepts numbers and symbols!
18:50:17 <Cale> x <- letter ?
18:50:35 <Cale> x <- oneOf ['a'..'z']
18:50:47 <Xianianol> erm, is there something like "letter" defined ?
18:50:49 <Cale> either of those should work with parsec
18:51:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Char.html
18:51:20 <Xianianol> I start to find this book pointless :-/
18:51:46 <Xianianol> Thanks.
18:55:27 <araujo> Hello!
18:56:17 <araujo> Xianianol, Which book?
19:08:10 <Xianianol> "Programming in Haskell" - Graham Hutton
19:10:34 <Philippa_> didn't think he'd published it yet?
19:10:41 <Philippa_> (Graham's my dissertation supervisor, btw)
19:10:59 <Xianianol> Well, our University is using a partial old version of it I think.
19:11:03 <Philippa_> ah
19:11:16 <Xianianol> Maybe I should have rephrased that, my lecturer left out important thing.
19:11:34 <Philippa_> which parsing library are you using?
19:12:16 <Xianianol> Well, we are more "reinventing the wheel".
19:12:25 <Philippa_> ah
19:12:31 <Xianianol> Basically we doing what "Main" does already...
19:12:36 <Philippa_> in that case, you might have to do it the hard way - 'a' or 'b' or...
19:12:43 <Philippa_> what what Main does?
19:13:07 <Xianianol> Evaluating expression, accepting new definitions, jsut a few basic things that we need to re-implement.
19:13:23 <Xianianol> It is really half-half, very "lecturer mood flavoured"
19:13:23 <Philippa_> so you're writing an interpreter, then
19:13:24 <Cale> do you have a parser which parses a character, and a parser which finds the or of two others?
19:13:39 <Xianianol> Yes, exactly, an interpreter.
19:14:05 <Xianianol> Just wrote that, after finding out "letters"
19:14:09 <Xianianol> *letter
19:15:12 <Cale> okay, so letter = foldl1 (<|>) . map char
19:15:23 <Cale> er
19:15:42 <Cale> that's oneOf
19:15:59 <Cale> letter = oneOf (['a'..'z'] ++ ['A'..'Z'])
19:16:18 <Philippa_> assuming a valid oneOf is already in scope, of course
19:16:30 <Xianianol> lett = do xs <- many1 letter; return (read xs) /and/ letters = token lett do that ?
19:16:35 <Cale> well, I meant to write  oneOf = foldl1 (<|>) . map char
19:17:37 <Xianianol> Bah, my last two coursework was a lot more interesting :P
19:18:10 <Xianianol> Way too many instructions and guidelines for this one...
19:27:29 <twb> Xianianol: URL?
19:27:39 <twb> Or is it in (not haskell)?
19:28:19 <Xianianol> ? You mean my last 2 courseworks or what ?
19:29:11 <twb> Whatever it is that you're doing now.
19:29:25 <Xianianol> Oh, right now just writing an interpreter.
19:29:35 <twb> For what?
19:29:58 <Xianianol> One that can evaluate expressions like 2+2, 2+a*y etc...
19:30:22 <Xianianol> Load files and show a tree of the evaluation.
19:31:00 <Xianianol> Just don't like the fact that the template has been created, so the programming style is quite forced...
19:41:35 <Taral> anyone played with PEGs?
19:41:57 <Philippa_> not directly, but they look suspiciously like the first-order fragment of Parsec
19:43:48 <kawfee> How can I prove this: (a*b mod N) = ((a mod N)*(b mod N))mod N)
19:43:52 <musasabi> PEGs ?
19:43:55 <kawfee> Megzlna: is that you?
19:44:18 <kawfee> wli: you alive?
19:45:08 <Cale> kawfee: it's basically just unrolling the definition of congruence
19:45:38 <Cale> x being congruent to y mod N means that x = y + k * N for some k.
19:45:50 <Cale> sorry, to y, (mod N)
19:46:24 <kawfee> It's been a while since I have had any math. Could you be more detailed?
19:46:35 <kawfee> I'd appreciate it.
19:46:53 <kawfee> Although, I used to write haskell if that counts for anything. =]
19:47:12 <Cale> and  (a * b) mod N = ((a mod N) * (b mod N)) mod N is only true if (a * b) is congruent to (a mod N) * (b mod N)
19:47:36 <kawfee> ok
19:47:45 <kawfee> I need to prove this algebraically.
19:47:49 <Cale> right
19:48:52 <Cale> now, we know that a is congruent to (a mod N), and b is congruent to (b mod N) -- let's say that a = (a mod N) + k1 * N, and b = (b mod N) + k2 * N
19:49:20 <kawfee> oh wow
19:49:51 <Cale> then  a * b = ((a mod N) + k1 * N) * ((b mod N) + k2 * N)
19:49:59 <Cale> which by distributivity is equal to
19:50:14 <Taral> Philippa_: Yes, but I didn't think parsec had linear time guarantees.
19:50:39 <Taral> @where parsec
19:50:39 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
19:50:42 <Cale> (a mod N) (b mod N) + k1 N (b mod N) + k2 N (a mod N) + k1 k2 N^2
19:51:00 <Cale> which, factoring the N is equal to
19:51:19 <Cale> (a mod N) (b mod N) + N * [k1 (b mod N) + k2 (a mod N) + k1 k2 N]
19:51:53 <Cale> so a * b = (a mod N) (b mod N) + N * u for some value u
19:52:11 <kawfee> ok
19:52:12 <Cale> which means that a * b and (a mod N) (b mod N) are congruent modulo N.
19:52:18 <twb> @index words
19:52:18 <lambdabot> Data.List, Prelude
19:52:23 <kawfee> oh wow, you are using congruency
19:52:35 <kawfee> that doesn't sound like algebra =]
19:52:41 <Cale> It is
19:52:45 <kawfee> Seriously?
19:52:51 <kawfee> ok
19:53:12 <Cale> Yeah, this sort of thing is in Classical Algebra 1 in most math programs :)
19:53:26 <Taral> Cale's argument is a bit longer than is required.
19:53:26 <kawfee> Yes, this is what I was told. It is basic algebra.
19:53:37 <kawfee> Taral: simple and sweet is all I need. 
19:53:42 <Taral> If you have the result (a + b) mod N = ((a mod N) + (b mod N)) mod N, then...
19:53:43 <kawfee> Really, I want to undertsand what is going on
19:54:00 <Taral> all you have to show is that ((a + N) * b) mod N = (a * b) mod N
19:54:07 <Cale> Taral: hehe, I'm not assuming that, as the proof of that is basically the same as the proof of this
19:54:21 <Taral> definition of mod and the fact that * commutes does the rest.
19:54:35 <Taral> Cale: I know, I'm just stating my assumptions. :)
19:55:21 <twb> Why is this valid:
19:55:21 <twb> word = many1 alphaNum
19:55:21 <twb> fnord = do words <- sepBy1 word spaces
19:55:21 <twb>            return words
19:55:21 <twb> and this not?
19:55:21 <twb> word = many1 alphaNum
19:55:23 <twb> fnord = do return $ sepBy1 word spaces
19:55:45 <Taral> twb, the first is the same as fnord = sepBy1 word spaces, the latter has an extra return
19:55:58 <Cale> twb: the second doesn't have the same type
19:56:06 <Cale> @type return
19:56:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
19:56:22 <twb> I kinda grok.
19:56:25 <Cale> so if you pass it a parser, you'll get a Parser Parser
19:56:38 <Cale> which isn't what you want
19:56:55 <Taral> has anyone written a Haskell parser in parsec?
19:57:00 <kawfee> Cale: Taral thank you for the help. Both answers were a little above me but thank you.
19:57:01 <twb> many1 makes life *so* much easier.
19:57:29 <Cale> kawfee: Well, let me show you the way that I'd rather think about it :)
19:57:46 <Cale> I don't really like mod as an operation :)
19:58:08 <Cale> Do you know about equivalence relations?
19:58:23 <kawfee> vaguely, it's been a few years
19:58:59 <twb> The Parsec user documentation is also really great, the way it leads you through features in a natural progression.
19:59:33 <Cale> okay, an equivalence relation ~ on a set S is a relation such that a ~ a for all a in S (it's reflexive), a ~ b implies b ~ a (symmetric), and if a ~ b and b ~ c, then a ~ c (transitive)
20:00:01 <kawfee> those all sound familiar.
20:00:08 <Cale> When you have an equivalence relation on S, it partitions S into a bunch of disjoint sets called equivalence classes
20:00:13 <kawfee> sure
20:00:17 <kawfee> I get that
20:00:20 <Cale> okay
20:00:50 <Cale> so let's consider this relation on the integers:  n ~ m iff n = m + k * N for some k.
20:01:38 <Cale> This partitions the set Z of integers into, in fact, N distinct equivalence classes.
20:01:43 <kawfee> ~ is what?
20:01:54 <Cale> Let's take an example
20:01:57 <gzl> (another nice example of an equivalence relation is the one on the rationals: a/c ~ c/d iff ad - bc = 0; this lets you say that 1/2 = 2/4 = 3/6 and such)
20:02:03 <Cale> Let N = 2
20:02:20 <Cale> What is the set of x such that 0 ~ x ?
20:02:26 <kawfee> what is ~ ?
20:02:30 <Cale> It's a relation
20:02:49 <Cale> that is, really just a set of pairs of integers
20:02:59 <kawfee> sure
20:03:00 <Cale> we say that a ~ b if (a,b) is in that set
20:03:18 <kawfee> ok, I am unfamiliar with that notation
20:03:22 <Cale> okay
20:03:37 <Cale> would calling it == help?
20:03:46 <SlowByte> {0}?
20:03:51 <kawfee> oh, ~ is equal?
20:03:52 <Cale> SlowByte: nope :)
20:03:58 <Cale> ~ is congruent mod N :)
20:04:10 <kawfee> congruent mean equal?
20:04:30 <Taral> @type (@)
20:04:31 <lambdabot> parse error on input `@'
20:04:36 <Cale> Well, congruence is going to turn into our "equality" on a new set of things
20:04:38 <Taral> what is @?
20:04:41 <kawfee> ok
20:04:45 <SlowByte> 0 = x + 2N?
20:04:49 <Cale> Taral: it's part of pattern matching
20:04:58 <Cale> SlowByte: yes
20:05:04 <SlowByte> so hmm.. x = -2N
20:05:04 <Taral> oh, right
20:05:19 <Cale> SlowByte: x is even
20:05:38 <Cale> SlowByte: though you're using N in a different way
20:05:48 <Cale>  n ~ m iff n = m + k * N for some k.
20:06:07 <Cale> So this definition depends on our choice of N
20:06:16 <kawfee> is this valid for all N?
20:06:21 <kawfee> it should not be
20:06:29 <Cale> it's a valid definition for all N.
20:06:35 <kawfee> oh
20:06:36 <Cale> but you have to pick one
20:06:44 <SlowByte> yes, I assumed N would be the set of non-negative integers
20:06:47 <kawfee> right, maybe that is what I meant
20:06:54 <SlowByte> so that's why I proposed 0 :)
20:06:58 <Cale> We'll write n ~ m (mod N) to make it clear which one we mean
20:07:29 <SlowByte> so hmph
20:07:47 <Cale> now, you know about equivalence classes
20:08:05 <kawfee> right
20:08:07 <Cale> we'll write [a]_N to be the equivalence class containing a, modulo N
20:08:20 <Cale> or just [a], when it's clear that we've picked an N
20:08:36 <Cale> (since [a]_N is a bit awkward to type)
20:08:56 <Cale> So what's [0]_2 ?
20:09:22 <Cale> It's the set of x such that 0 ~ x (mod 2)
20:09:34 <Cale> which means that 0 = x + 2 * k for some k
20:09:47 <Cale> or x = -2 * k for some k
20:09:55 <Cale> or just x = 2 * k for some k
20:09:59 <kawfee> How do you know that?
20:10:01 <Cale> that is, x is even
20:10:08 <Cale> by all the definitions that I've set up
20:10:13 <Cale> which step, sorry?
20:10:24 <kawfee>  0 = x + 2 * k for some k
20:10:47 <Cale> The definition for ~ is:  n ~ m (mod N) iff n = m + k * N for some k
20:11:03 <dons> oh my: class Coerce a b c d e f | a b c d -> e f where
20:11:28 <Cale> So we apply that definition
20:11:32 <Cale> does that make sense?
20:11:36 <dons> and the prize for most ty vars goes to oleg.
20:11:48 <Pseudonym> That's not coercion.  That's brainwashing.
20:11:50 <Cale> 0 ~ x (mod 2) means the same thing as 0 = x + 2 * k for some k
20:11:50 <kawfee> not yet it does not
20:12:10 <kawfee> I'll take that as fact then. Please continue.
20:12:24 <Cale> "n ~ m (mod N)" means the same thing as "n = m + k * N for some k" by definition of ~
20:12:54 <kawfee> How do you know this
20:12:55 <kawfee> ?
20:13:02 <Cale> Because I just defined ~ in that was
20:13:02 <Korollary> That's how modulo is defined.
20:13:04 <Cale> way*
20:13:10 <Cale> The definition for ~ is:  n ~ m (mod N) iff n = m + k * N for some k
20:13:23 <Cale> iff is "if and only if"
20:13:55 <Cale> so when we write  n ~ m (mod N), that's notation for  "there is some k such that n = m + k * N"
20:14:07 <kawfee> yes, I have iff
20:14:20 <Cale> okay, so this should be fine :)
20:14:33 <kawfee> if that is how modulus is defined then I will take it as that
20:14:51 <Cale> note that by (mod N) here, I don't mean mod as an operator
20:15:06 <kawfee> what do you mean?
20:15:07 <Cale> I just mean that as a note to remind us which N we're using
20:15:13 <Cale> (mod N) is a comment
20:15:21 <SlowByte> more like n ~(mod N) m
20:15:24 <Cale> yeah
20:15:42 <Cale> n ~_N m, for fear of that looking like a bad smiley
20:15:51 <Korollary> Use xml tags !
20:15:54 * Korollary chuckles
20:16:01 <Cowmoo> you can think of it as something to remind you that we're working the world of mod N
20:16:09 <kawfee> Cowmoo: hi.
20:16:19 <Cowmoo> hello, followed you from #c++ :)
20:16:31 <kawfee> I see now.
20:16:39 <Cale> okay, so that's making sense? :)
20:16:45 <kawfee> Come to see Cale prove this. 
20:16:54 <Cale> You should see [0]_2 is the set of even numbers
20:17:02 <Cale> and [1]_2 is the set of odd numbers
20:17:07 <kawfee> Cale: not really. I understood you until you said mod was not mod
20:18:02 <dons> @seen Lemmih
20:18:02 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 9 hours, 41 minutes
20:18:02 <lambdabot> and 31 seconds ago.
20:18:08 <Cale> when I write  a ~ b (mod n), the "(mod n)" just serves to remind us which n was used in the definition of ~
20:18:25 <Cale> it's not some operation getting applied to b
20:18:28 <SlowByte> x in [0]_2 === 0 ~_2 x
20:19:14 <kawfee> which is just 0+2, 0+2+2, 0+2+2+2 ?
20:19:14 <Cale> perhaps it will make more sense if I write it in English :)
20:19:42 <Cale> n is congruent to m modulo N if and only if n = m + k * N for some k
20:19:59 <Cale> and 0 - 2, 0 - 2 - 2 and so on
20:20:09 <Cale> 0 + k * 2 for every integer k
20:20:14 <Cale> is [0]_2
20:20:51 <gzl> or: n is congruent to m modulo N if n and m differ by a multiple of N (n - m = k * N, rearranging Cale's equation)
20:20:59 <Korollary> lisppaste should support mathml
20:21:00 <Cale> yes
20:21:11 <gzl> dunno if that's more intuitive or not
20:21:22 <luqui> can I have multiple modules in a file?
20:21:43 <Cale> now, we'll define [a]_n + [b]_n as [a+b]_n, and [a]_n * [b]_n as [a*b]_n. What you originally wanted to show is that the latter definition for multiplication there is well-defined.
20:21:52 <Cale> (essentially, that's the same thing)
20:21:56 <Cale> luqui: no
20:22:03 <luqui> darn
20:22:54 <kawfee> so for  n = m + k * N  we hold N constant?
20:23:01 <Cale> kawfee: yes
20:23:03 <kawfee> If I am trying to make a set of numbers that is.
20:23:11 <kawfee> What does that set give me?
20:23:20 <Cale> if we're talking about congruence (mod N)
20:23:22 <kawfee> if N is 0 then I get m
20:23:45 <kawfee> if N is 1 I get m, m+1, m+2, m+3, and so on
20:24:00 <Cale> if N = 1, then everything is congruent to everything else
20:24:05 <gzl> and if N = 12, this is like clock arithmetic
20:24:22 <Taral> grr!
20:24:25 <Taral> haskell is not LL(1)
20:24:28 <Cale> if N = 2, even numbers are congruent to each other, and odd numbers are congruent to each other
20:24:29 <kawfee> and what does that mean? If N =1 1 being congruent. It means that everything is equal. I think I am missing the definition of congruence somewhere.
20:24:45 <Cale> Taral: no, it's context sensitive -- look at infixl/r
20:24:54 <Taral> even ignoring fixities
20:24:57 <Taral> it's still not LL(1)
20:25:06 <Cale> kawfee: well, modding out by 1 is usually quite pointless
20:25:08 <Taral> LR(1), maybe, but not LL(1)
20:25:20 <kawfee> ok
20:25:44 <gzl> kawfee: it's saying that two numbers are congruent if the difference between them is a multiple of 1, which is obviously true
20:25:51 <gzl> obviously true for any two numbers, I mean
20:25:55 <kawfee> ok
20:26:00 <kawfee> so 2 and 3 are congruent?
20:26:05 <gzl> mod 1, yes
20:26:06 <Cale> yeah, (mod 1)
20:26:09 <kawfee> but 2 and 4 are not
20:26:10 <gzl> mod 2, they are not
20:26:14 <kawfee> ok
20:26:21 <Korollary> 2 == 4 mod 1 as well
20:26:22 <Cale> 2 and 4  are congruent (mod 1)
20:26:27 <gzl> mod 1, 2 and 4 are congruent also, because they differ by 2 * 1
20:26:34 <kawfee> ahhh
20:26:36 <gzl> and 3 and 8 are congruent because they differ by 5 * 1
20:27:00 <Taral> @where alex
20:27:01 <lambdabot> http://www.haskell.org/alex/
20:27:03 <kawfee> so any two numbers are congruent for mod 1
20:27:07 <gzl> yes
20:27:18 <kawfee> but for mod 2 only even numbers are congruent
20:27:21 <gzl> no
20:27:30 <gzl> even numbers are congruent to each other AND odd numbers are congruent to each other
20:27:40 <kawfee> for any mod?
20:27:41 <Cale> So what we're going to do is define a new ring, or type of numbers, called Z_n, which is pronounced the integers mod n
20:27:44 <gzl> no no, for mod 2
20:27:48 <kawfee> ok
20:28:06 <kawfee> Cale: oh. I see what you are getting at.
20:28:07 <Cale> and which consists of the equivalence classes of ~ (mod n)
20:28:16 <kawfee> There are multiple rings.
20:28:19 <Cale> yeah
20:28:25 <gzl> n is congruent to m mod 2 iff n - m is even; this is the case when both n and m are even or when both n and m are odd
20:28:26 <kawfee> each of their own equv class.
20:28:43 <Cale> each with its own set of equivalence classes
20:28:46 <kawfee> ok
20:29:29 <Cale> we define the elements of Z_n to be the n equivalence classes of Z under the relation ~ (mod n)
20:29:56 <Cale> and [a] + [b] = [a + b],  [a] * [b] = [a * b]
20:30:07 <Cale> however, it's not clear that this is well-defined
20:30:25 <Cale> since many values of a give rise to the same equivalence class
20:31:00 <Cale> so we have to show that if a' ~ a (mod n) and b' ~ b (mod n), then [a] + [b] = [a'] + [b']
20:31:13 <Cale> and [a] * [b] = [a'] * [b']
20:31:26 <kawfee> some of that makes sense
20:31:27 <Cale> the latter of which is your original question, restated
20:31:37 <kawfee> I don't see that.
20:32:01 <Cale> well, it takes a bit of unwrapping, but it will serve the same purpose to us in the end
20:32:45 <kawfee> ok
20:33:02 <Cale> basically, it's saying that it doesn't matter if we multiply things first and then take the congruence class, or choose congruent things, and then multiply, then take the equivalence class
20:33:11 <kawfee> ok
20:33:29 <Cale> one way of getting something congruent to a is to reduce a mod N
20:33:41 <Cale> mod n rather, we've gone lowercase here :)
20:33:56 <Cale> that is, take the remainder after division
20:34:37 <Cale> so if this is true, then [a] * [b] = [a `mod` n] * [b `mod` n] is true
20:34:48 <Cale> where `mod` is the infix operator
20:36:02 <Cale> which means that [a * b] = [(a `mod` n) * (b `mod` n)], and hence that a * b ~ (a `mod` n) * (b `mod` n)
20:37:05 <Cale> and x ~ y (mod n) only if   x `mod` n = y `mod` n
20:37:33 <Cale> so we get back to your original problem of showing that
20:37:45 <kawfee> Cale: How much math have you had?
20:37:48 <Cale> (a * b) `mod` n = ((a `mod` n) * (b `mod` n)) `mod` n
20:37:51 <Cale> 4 years
20:37:53 <Cale> :)
20:38:00 <kawfee> You make it sounds so simple. 
20:38:04 <Cale> I have a bachelor's in pure math
20:38:09 <kawfee> Although I do not understand everything you are saying.
20:38:11 <kawfee> From where?
20:38:17 <Cale> Waterloo, Canada
20:38:18 <SlowByte> 0 years here ;)
20:38:22 <kawfee> That explains why you are using haskell. 
20:38:29 <Cale> :)
20:38:34 <kawfee> Waterloo is a good school.
20:38:49 <kawfee> SlowByte: Do you understand him?
20:38:56 <SlowByte> I'm thinking of doing a math degree, but I have no idea where
20:38:58 <SlowByte> yes
20:39:14 <Cale> okay, so let's show that if a ~ a' and b ~ b' then [a] + [b] = [a'] + [b']
20:39:41 <Cale> well, the first, and only thing we can do is to replace using the definition of + for equivalence classes
20:40:09 <gzl> (fwiw, I'm in the middle of a math degree as well.)
20:40:12 <Taral> parsec is not lazy :(
20:40:13 <Cale> [a] + [b] = [a'] + [b'] only if [a + b] = [a' + b']
20:40:38 <Cale> now, what does it mean for those to be the same equivalence class?
20:40:55 <Cale> Well, if means that a + b ~ a' + b'
20:41:00 <kawfee> means they are equal
20:41:04 <Cale> yeah
20:41:17 <kawfee> Some of what you write makes sense. 
20:41:24 <Cale> it means that a' + b' must be an element of [a + b]
20:41:30 <kawfee> I thought this would be a simple 5 to 10 line proof. heh
20:41:43 <SlowByte> it is :)
20:41:57 <kawfee> using some simple algebraic formulas.
20:42:01 <Cale> kawfee: well, I'm giving you the long answer which helps things in the long run :)
20:42:01 <kawfee> this isn't algebra
20:42:11 <Cale> kawfee: yes it is
20:42:14 <kawfee> This is far more than algebra in my books.
20:42:30 <kawfee> I didn't learn this kind of stuff in algebra. 
20:42:41 <Cale> which algebra courses did you take?
20:42:49 <kawfee> Maybe this us algebra for math majors. 
20:42:57 <gzl> that's exactly what it is
20:43:08 <SlowByte> relations and equivalence classes are pretty basic
20:43:25 <kawfee> I took one algebra course. the one right before pre-cal
20:43:44 <gzl> SlowByte: they are, but this isn't algebra in the "high school algebra" sense
20:43:48 <kawfee> I am not a math major.
20:44:02 <kawfee> I do have a CS degree.
20:44:10 <Cale> I'm of the opinion that you don't actually do any math in highschool :)
20:44:17 <kawfee> Cale: I didn't.
20:44:21 <gzl> oh, if you have a CS degree, then you should have seen all of this
20:44:26 <SlowByte> indeed
20:44:31 <kawfee> gzl: I have seen equivalence classes.
20:44:35 <SlowByte> CS should have discrete math at least
20:44:41 <kawfee> yeah, I had discrete
20:44:50 <kawfee> tis why I am able to understand some of what he says
20:45:01 <Cale> CS majors at waterloo do all of this, I know
20:45:08 <kawfee> I know one online.
20:45:20 <Cale> Since it's first year stuff, and CS and Pure Math are the same in first year.
20:45:50 <gzl> I know the CS majors here do this, though usually in the second year
20:45:58 <kawfee> gzl: where?
20:46:22 <gzl> university of pennsylvania
20:46:26 <kawfee> hrm
20:46:52 <kawfee> Cale: So that's it?
20:47:04 <Cale> kawfee: well, we haven't finished that proof
20:47:18 <kawfee> ok
20:47:23 <kawfee> I didn't think we were done.
20:47:56 <Korollary> gzl: Is Benjamin Pierce teaching there?
20:47:57 <Cale> back to the proof, we're assuming that a ~ a' and b ~ b', and trying to show that [a] + [b] = [a'] + [b']
20:48:13 <gzl> Korollary: yep, I took his course last semester
20:48:17 <Cale> which is only true if [a + b] = [a' + b'], by our new definition of +
20:48:28 <kawfee> ok
20:48:40 <Korollary> gzl: Ah. I have his TaPL, which I should read sometime...
20:48:47 <Cale> and that's only true if those two equivalence classes are the same, which would mean that a + b and a' + b' are in the same equivalence class
20:48:52 <gzl> Korollary: Stephanie Weirich also teaches here, she does a fair bit of stuff with Haskell as well (GADTs, haskell-prime, ...)
20:49:09 <Cale> which is to say that a + b ~ a' + b'
20:49:13 <kawfee> ok
20:49:30 <Cale> which means that a + b = a' + b' + k * n for some k
20:49:49 <Cale> now, we know that a ~ a', so a = a' + k1 * n for some k1
20:50:00 <Cale> and we know that b ~ b', so b = b' + k2 * n for some k2
20:50:06 <Cale> so
20:50:17 <Cale> a + b = a' + k1 * n + b' + k2 * n
20:50:35 <Cale> = a' + b' + n * (k1 + k2)
20:50:45 <Cale> so indeed, a + b = a' + b' + k * n for some k
20:50:56 <Cale> namely, k = k1 + k2
20:51:02 <Cale> so the thing is true
20:51:15 <Cale> now, for multiplication, things are quite similar
20:51:19 * Korollary thinks that it's possible to trick Cale into writing a full book by carefully placed questions.
20:51:29 <Cale> Korollary: quite possibly
20:51:33 <Cale> ;)
20:51:45 <gzl> Cale: after you're done with this, I have a question about Fermat.
20:51:50 <Korollary> Cale: You are the dream TA of any professor
20:51:51 <gzl> :)
20:51:52 <Cale> So now we're trying to show that [a] * [b] = [a'] * [b']
20:52:12 <Cale> this is only true if [a * b] = [a' * b']
20:52:15 <gzl> Korollary: more like the dream TA of any student
20:52:23 <Cale> which is only true if a * b ~ a' * b'
20:52:40 <Cale> which means that a * b = a' * b' + k * n for some k
20:53:02 <Cale> remember that a = a' + k1 * n, and b = b' + k2 * n
20:53:17 <Cale> so a * b = (a' + k1 * n) * (b' + k2 * n)
20:53:53 <Cale> = a' * b' + n (k1 b' + k2 a' + k1*k2*n)
20:54:20 <Cale> so it works, as a * b = a' * b' + k * n for some k, in particular, k = (k1 b' + k2 a' + k1*k2*n)
20:54:33 <Cale> and we're done, the operations are well-defined
20:55:19 <Cale> Hopefully that was moderately followable
20:55:30 <Cale> you should probably write it down and read it over again
20:56:34 <gzl> did he ask why they're well defined or did he ask something bigger?
20:56:47 <gzl> I mean, what was the original question
20:57:05 <Cale> gzl: he originally asked a question which was equivalent to the well-definedness of * on Z_n
20:57:09 <gzl> ok
20:59:20 <Cale> I think my favourite lecture in Classical Algebra 1 was on the Chinese Remainder theorem: If n and m are coprime, then Z_n x Z_m is isomorphic to Z_nm
21:00:13 <Cale> where Z_n x Z_m is the ring defined on pairs of elements from Z_n and Z_m with pointwise operations
21:21:23 <Taral> There's an ambiguity in the haskell98 lexing spec...
21:21:36 <Taral> is "--:" a comment or a varsym?
21:22:15 <Taral> It looks like it might be intended to be a varsym
21:22:55 <Cale> It's a varsym
21:23:35 <Cale> er, hmm
21:23:39 <Cale> maybe not :)
21:23:46 <Taral> it's ambiguous
21:24:15 <Taral> If I resolve the ambiguity with maximal-munch, it's a comment.
21:25:06 <Cale> An ordinary comment begins with a sequence of two or more consecutive dashes (e.g. --) and extends to the following newline. The sequence of dashes must not form part of a legal lexeme. For example, "-->" or "|--" do not begin a comment, because both of these are legal lexemes;
21:25:49 <Cale> ah, but : isn't considered a symbol
21:25:51 <Taral> --: is a legal lexeme
21:26:06 <Cale> so it's not
21:26:09 <Taral> sure it is
21:26:22 <Cale> --! is
21:26:27 <Cale> but --: isn't
21:26:28 <Taral> varsym -> (symbol {symbol | :})<reservedop|dashes>
21:27:44 <Cale> hmm
21:28:05 <Cale> okay :)
21:28:14 <Cale> yeah, ghc has a bug there
21:28:23 <Taral> well, ghc is following the text instead of the bnf
21:28:26 <Taral> the bnf says:
21:28:46 <Taral> comment -> dashes [any<symbol> {any}] newline
21:28:53 <Cale> I mean, ghc isn't following the text
21:28:54 <Taral> which matches "--:\n"
21:28:56 <dons> there's a maximal munch rule
21:28:59 <Taral> and --:\n is longer than --:
21:29:04 <dons> Taral, what are you working on, btw?
21:29:13 <Taral> dons: Yes, but the problem is the maximal munch rule conflicts with the section Cale quoted above.
21:29:19 <Taral> I'm writing a haskell lexer, of course.
21:29:26 <Cale> Taral: unicode?
21:29:28 <dons> yes, but *what for* ?
21:29:29 <Taral> How else does one discover crazy things like these?
21:29:33 <Taral> For a haskell compiler.
21:29:37 <Cale> please make it support unicode properly
21:29:37 <dons> ah ok.
21:29:40 <Taral> Yet Another Haskell Compiler.
21:29:51 <dons> I was thinking maybe you were writing a haskell lexer for syn highlighting in yi.
21:29:54 <Taral> Cale: It'll support unicode when I get my hands on the unicode class table
21:29:59 <dons> which I was also just working on. so checking, you know..
21:30:02 <Taral> dons: You could use it for that too.
21:30:07 <dons> of course.
21:30:10 <Taral> Anyway, I'm not sure what to do with this --: problem
21:30:14 <Taral> ghc reads it as a comment
21:30:19 <Taral> the spec is ambiguous
21:30:22 <Taral> I'm inclined to make it an error.
21:30:45 <Cale> the spec isn't ambiguous so much as it just conflicts with itself :)
21:30:56 <Taral> Is there a difference?
21:31:05 <dons> hugs reads it as a varsym
21:31:07 <Taral> We'll use "inconsistent" then.
21:31:09 <Taral> HAHAHAHA
21:31:11 <dons> Hugs.Base> let x --: y = 1 in 2 --: 3
21:31:11 <dons> 1
21:31:15 <Cale> ambiguous would be to say nothing about whether --: is a comment
21:31:17 <Taral> ghc and hugs have different reads?
21:31:20 <Cale> yeah
21:31:23 <Cale> they would
21:31:30 <Taral> yup
21:31:32 <dons> but I think this is a known isue.
21:31:38 <Taral> well, what's the answer then?
21:31:42 <Taral> is it a comment or a varsym?
21:32:34 <Cale> the GHC documentation doesn't list it
21:32:40 <dons> Haskell 98 says that two or
21:32:41 <dons> -- more dashes followed by a symbol should be parsed as a varsym,
21:32:46 <Cale> you should post to the Haskell mailing list about it
21:33:18 <Taral> dons: The problem is that varsym includes : as a "symbol", where comment does not.
21:33:26 <dons> but ':' isn't in symbol, is it?
21:33:38 <Taral> [23:26] <Taral> varsym -> (symbol {symbol | :})<reservedop|dashes>
21:33:45 <dons> $symchar   = [$symbol \:]
21:33:47 <dons> from ghc
21:33:54 <Taral> yup
21:33:59 <Taral> I keep saying this
21:34:03 <Taral> both varsym and comment rules match
21:34:09 * Lemmih yawns.
21:34:15 <Taral> the maximal munch rule says comment wins because it matches the newline as well
21:34:20 <Lemmih> Good morning, #haskell.
21:34:29 <Taral> the text on comments says that varsym wins because varsym always wins.
21:34:35 <Cale> Taral: do it the same as GHC :)
21:34:42 <Taral> Pfft.
21:34:44 <Taral> It's an error.
21:34:46 <Taral> Don't do that.
21:34:50 <Cale> you can always change it later if that turns out to be wrong :)
21:35:14 <Taral> hm, hard to make it an error.
21:35:20 <Taral> I'll leave the default, which is comment wins
21:35:21 <Cale> and post to the haskell mailing list
21:35:28 <Cale> yeah, that's what ghc does
21:35:37 <Taral> which haskell list?
21:35:47 <Cale> Haskell, probably :)
21:35:54 <Taral> @google haskell mailing list
21:35:55 <lambdabot> http://www.haskell.org/mailinglist.html
21:36:25 <Cale> you could put it on Haskell-cafe, but I think some important people only read Haskell.
21:37:24 <lisppaste2> Saulzar pasted "Overlapping instance error??" at http://paste.lisp.org/display/14465
21:37:56 <dons> where in the report does it say varsym always wins?
21:38:45 <dons> anwya, the text on comment seems to be pretty clear that --: isn't a comment.
21:38:56 <Taral> message sent
21:38:58 <Taral> dons: section 2.3:
21:39:18 <Taral> "The sequence of dashes must not form part of a legal lexeme."
21:39:40 <Taral> i.e. varsym always wins
21:40:06 <Cale> Saulzar: those instances already exist
21:41:00 <dons> Taral, I don't see that text in s2.3. do you have the revised report?
21:41:02 <Saulzar> Crikey, you're right
21:41:10 <Saulzar> Thanks - I was going crazy.
21:41:16 <Cale> Saulzar: you don't need your instance declaration, because it's covered by the instance declaration for Floating a => VectorSpace (a,a) a
21:42:13 <Cale> Saulzar: if you were to use newtypes, you'd need to declare (or derive) an instance
21:43:15 <dons> oh, sorry Taral, I had the wrong report :)
21:43:16 <Saulzar> Cale, I didn't realise that they had any defaults there - it didn't occur to me at all what the error meant.
21:43:41 <Taral> dons: What report were you looking at?
21:43:43 <Saulzar> Cale, Since it seemed fine and dandy with my overlapping instance until it came to the functional dependancy :)
21:43:55 <dons> yes, "The sequence of dashes must not form part of a legal lexeme" means varsym wins. so hugs is right.
21:44:23 <dons> and probably the rewrite of ghc's lexer introduced a bug
21:45:01 <Taral> well...
21:45:05 <Taral> it's not so clear, you see...
21:45:21 <Taral> oh, wait!
21:45:23 <Taral> it is clear!
21:45:23 <Taral> yay!
21:45:28 <Cale> It actually is pretty clear with that comment there
21:45:33 <dons> varsym beats maximal munch
21:45:36 <Taral> maximal munch only applies to "lexeme", not "whitespace"
21:45:38 <Taral> yay!
21:46:39 <Taral> aha
21:47:10 <dons> still, hugs and ghci shouldn't disagree on the --: token
21:47:22 <dons> > let x --: y = 1 in 2 --: 3
21:47:23 <lambdabot>  parse error (possibly incorrect indentation)
21:47:28 <Taral> :)
21:47:34 <Taral> it's a comment according to GHC
21:47:36 <Taral> so GHC sees let x
21:47:43 <dons> yep.
21:49:22 <Cale> I'm pretty sure I'd consider that a spec-bug if --: was specified as a comment
21:49:31 <dons> hugs, nhc and hbi all say it is a varsym
21:49:48 <Taral> the comment production should probably be fixed too
21:49:55 <dons> only ghc gets it wrong. and I bet its only since the lexer rewrite
21:49:58 <Cale> the only reason that : isn't a symbol is that it needs to be treated specially if it occurs as the first character
21:50:38 <dons> anyone have yhc installed?
21:50:43 <dons> what does yhc say?
21:51:33 <dons> and jhc, someone have jhc set up?
21:51:51 <Taral> heh
21:52:00 <Cale> GHC really needs a new lexer which handles unicode, and it would be really nice to have extensions to allow things like  for lambda :)
21:52:02 <Korollary> Taral: GHC openly deviates and sometimes disagrees with the report, so it may not be a good reference: http://haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#infelicities-lexical
21:52:13 <Korollary> +from
21:52:27 <Saulzar> How many text editors can handle the unicode chars?
21:52:48 <Cale> Saulzar: most of the common ones can
21:52:50 <dons> 42
21:53:05 <Saulzar> That many? :)
21:53:07 <Cale> vim and ghc both do
21:53:14 <Korollary> ghc is an editor now
21:53:15 <Cale> anything using gnome does
21:53:19 <Cale> or KDE
21:53:29 <dons> for some definition of 'handle' ;)
21:53:30 <Cale> yi does :)
21:53:45 <dons> for some definition of handle
21:53:46 <Taral> dons: jhc uses Language.Haskell.Lexer, which is correct
21:53:59 <dons> yeah, it's just ghc playing tricks
21:54:26 <Cale> well, by 'handle', I mean "is able to read and display unicode characters"
21:54:32 <Cale> and type them
21:54:45 <dons> gtk yi can, yep.
21:54:48 <dons> I think.
21:54:54 <Cale> yep
21:55:06 <Cale> I recall typing japanese characters into it
21:55:21 <Taral> I'm inclined to agree with haskell on the qualified reservedop issue. Otherwise my lexer gets yucky.
21:55:31 <Taral> s/haskell/ghc/
21:57:22 <Cale> I suppose there are more things which full Unicode support would entail
22:02:27 * dcoutts agrees with dons
22:05:01 <kawfee> Cale: sorry abour that
22:05:04 <kawfee> I got disconnected
22:05:24 <kawfee> Cale: I am still actually disconnected but I am rerouting through another host
22:05:59 <kawfee> Taral: You're in Austin?
22:06:09 <Cale> kawfee: what was the last line that you read?
22:06:45 <kawfee> 22:49 < Cale> which means that a + b = a' + b' + k * n for some k
22:06:49 <kawfee> But I can review what you wrote
22:07:03 <kawfee> I have IRC on a second host so I can get to the backlog.
22:07:30 <kawfee> for some reason the dorms are disconnected fro the internet but the labs aren't
22:07:44 <kawfee> had to ssh  into the labs to get to the internet
22:08:10 <kawfee> Cale: I do appreciate you going through to proof. thanks
22:08:24 <kawfee> through the proof
22:08:46 <Cale> kawfee: either you can read the #haskell logs on the web, or I could paste the stuff to you :)
22:08:58 <Cale> oh
22:09:00 <Taral> see, there are issues with unicode.
22:09:02 <Cale> okay
22:09:07 <Cale> cool
22:09:14 <Cale> Taral: hm?
22:09:17 <Taral> Like, is a modifier letter uppercase or lower?
22:09:19 <kawfee> I can scroll back in irssi
22:09:25 <Taral> (answer: neither)
22:09:26 <kawfee> where are haskell logs?
22:09:31 <kawfee> Taral: You're in Austin?
22:09:32 <Cale> right, neither
22:09:35 <Taral> yes
22:09:36 <kawfee> Taral: I did my undergrad there.
22:09:39 <Taral> in austin
22:09:41 <kawfee> Taral: are you in school?
22:09:41 <Taral> so did I
22:09:43 <Taral> I'm still here.
22:09:44 <Taral> no
22:09:46 <kawfee> Taral: What department?
22:09:47 <Taral> not in school
22:09:48 <Taral> CS
22:09:50 <kawfee> same here
22:09:59 <Taral> amazing :)
22:10:01 <kawfee> Taral: Did everything he said make sense to you?
22:10:09 <kawfee> Taral: right.
22:10:15 <kawfee> Taral: I graduated in 2003.
22:10:36 <kawfee> Taral: We didn't really discuss much of this in our undergrad. The most I got was from Dr. Boyers class. 
22:11:11 <kawfee> Taral: I don't suppose you had Dr. Richards for programming languages?
22:11:20 <kawfee> That's where I picked up haskell.
22:11:44 <Taral> OMG
22:11:54 <Taral> there is NO WAY I'm supporting full unicode
22:12:01 <Taral> not right now anyway
22:12:07 <Cale> Taral: what?
22:12:14 <Taral> http://www.unicode.org/Public/UNIDATA/UCD.html\
22:12:16 <Taral> http://www.unicode.org/Public/UNIDATA/UCD.html
22:12:21 <Taral> look at the categorization data
22:12:22 <Cale> Is there something ridiculous about it?
22:12:34 <Taral> Characters are divided into large numbers of categories.
22:12:42 <kawfee> Taral: I'm not that bad of a person to talk to.,
22:13:38 <Taral> this is the file to parse: http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt
22:13:58 <Cale> Taral: well, you don't necessarily need to know about all of them to lex haskell correctly
22:14:32 <Taral> No, but it's more than I want to handle tonight.
22:14:36 <Taral> It's late.
22:15:29 <Cale> :)
22:15:32 <Taral> 01C5          ; Lt #       LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
22:15:35 <Taral> unicode is crazy
22:16:24 <Cale> really, all you'd need is working uppercase, lowercase, and symbol predicates
22:16:32 <Cale> maybe whitespace as well
22:20:27 <Taral> what about combining marks?
22:21:13 <Taral> and numbers that aren't roman numerals?
22:22:01 <Taral> what about ltr/rtl marks?
22:22:06 <Taral> there are a lot of decisions to make.
22:23:29 <Cale> well, you can interpret them in a blunt manner, and improve things as people start caring about things like that
22:24:02 <Cale> I think most people would be quite happy just to have support for greek letters and extra operator symbols :)
22:29:08 <Taral> I suppose I could be restrictive and just say "I allow what I understand"
22:29:15 <Taral> so combinings and stuff are out until someone fixes it up
22:29:34 <Cale> yeah
22:30:21 <Saulzar> So now we get greek while reading haskell code, not only in academic proofs? :)
22:33:22 <Cale> hugs unforunately treats all extended unicode characters as symbol characters
22:33:40 <Cale> so you can't use ,,, etc. as type variables
22:34:23 <Cale> but you can use them as infix operators :)
22:35:30 <Cale> I think it would be fun to see  = return and  = join :)
22:35:45 <Cale> (only for a short while perhaps :)
22:36:29 <Cale> but the extra selection of characters would be quite handy
22:36:54 <Cale> you could almost get away with separate character sets for different types :)
22:37:53 <Cale> then all you need are space-cadet-style keyboard mappings to make it convenient :)
22:39:00 <Taral> okay, nini
22:39:25 <sieni> I know, let's make the syntax of Haskell locale dependent.
22:51:21 <Saulzar> If you had bold itallic and underline you could have 8 types worth
22:59:35 <Saulzar> Hmm, is the gtk2hs OpenGL stuff experimental? Trying to compile the little demo, and it's missing "Graphics.UI.Gtk.OpenGL"
23:16:44 <Cale> Saulzar: well, I think you'd at least have to have the latest darcs version of Gtk2Hs
23:21:54 <Saulzar> Ah hah "The gtkglext package is now included the development version of Gtk2Hs if you want to try it out."
23:21:55 <Saulzar> Cool.
23:37:46 <gour> dcoutts: ping
23:38:07 <dcoutts> gour, pong
23:38:29 <gour> dcoutts: hi, again i'm greeted with 5 spams in the queue
23:38:35 <dcoutts> hmm
23:38:44 <gour> spamkarma does not fit 'cause mysql is too old
23:38:48 <gour> it reqs >=4
23:38:56 <dcoutts> I thought that might be the case
23:39:05 <gour> i downloaded SA plugin and put in in the place
23:39:14 <gour> i reqs minor tweaking
23:39:28 <gour> pls. log to the site and go into ../plugins folder
23:39:41 * dcoutts does so
23:39:48 <gour> and check what should be the setting for mail server etc.
23:39:48 <Diablo-D3> I have the weirdest problem atm
23:40:01 <gour> then yo ucan just activate plugin from the panel
23:40:11 <gour> i'm going to take a breakfast
23:40:16 <Diablo-D3> trying to bootstrap ghc on fc2 with ghc 6.4.1...
23:40:17 <Diablo-D3> doesnt.
23:40:31 <Diablo-D3> ==fptools== make boot -wr;
23:40:31 <Diablo-D3>  in /var/local/home/users/d/di/diablo-d3/ghc-6.4.1/libraries/base
23:40:31 <Diablo-D3> ------------------------------------------------------------------------
23:40:31 <Diablo-D3> touch GHC/PrimopWrappers.hs
23:40:31 <Diablo-D3> make[2]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop.
23:40:37 <gour> dcoutts: will be back soon, so ping me if something is not clear, it is ok?
23:40:41 <Diablo-D3> anyone have any idea what I can do?
23:40:46 <dcoutts> gour, ok
23:40:59 <gour> dcoutts: s/it is ok/is it ok/ :-(
23:41:34 <Lemmih> Diablo-D3: You don't have a version of GHC installed?
23:41:55 <Diablo-D3> Lemmih: no
23:42:08 <Diablo-D3> its the sf compiler farm,btw
23:42:17 <Diablo-D3> I'm trying to build haskell so I can build darcs.
23:42:43 <Diablo-D3> unless someone already has darcs build for sf.net ....
23:42:44 <Lemmih> Diablo-D3: Get a binary version. Bootstrapping is difficult and unnecassary.
23:42:55 <Diablo-D3> Lemmih: can't.
23:43:03 <Lemmih> How so?
23:43:10 <Diablo-D3> rpms wont install in other locations.
23:43:26 <Lemmih> Download the generic linux binary.
23:43:32 <Diablo-D3> hrm
23:43:45 * Diablo-D3 tries that
23:45:36 <Diablo-D3> this may take a few minutes.
23:45:59 <Diablo-D3> not being able to wget directly on the shell or cf servers sucks.
23:57:01 <shapr> @seen SyntaxNinja
23:57:01 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 6 hours, 18 minutes
23:57:01 <lambdabot> and 2 seconds ago.
23:57:10 <shapr> good morning xerox!
23:57:54 <xerox> Buon giorno shapr!
23:58:38 <shapr> I have a random question... I'm using trac for my feature/issue tracking. I'm writing my unit tests with XmlRpc... I realize I could add support for bugs/features that close themselves by checking for a correct result via xmlrpc.
23:59:05 <shapr> I wonder, is this a generally useful feature?
23:59:09 <xerox> shapr: it's been a relatively long time from your last un-focussing period ;-)
23:59:15 <shapr> heh, yes.
23:59:31 <shapr> As the solstice approaches, my energy level is low.
23:59:35 <shapr> And I have deadlines.
23:59:59 * xerox is reminded of the laptop's battery and runs to get the charger.
