00:00:05 <ski> coinheritance for algebraic datatypes
00:00:11 <ski> inheritance for coalgebraic datatypes
00:00:18 <palomer> what the blazes is coinheritance?
00:00:34 <palomer> would it be possible to write a TH which satisfies your criterion ski?
00:01:07 <palomer> my supervisor claims to have invented coinduction
00:01:37 <shapr> He's wrong, I did!
00:01:41 * shapr cackles maniacally
00:01:46 <ski> palomer : well .. i guess it's purpose isn't for that .. but, i'm more attracted to something like MetaML
00:01:54 <ski> palomer : hm ?
00:02:05 <palomer> the meta meta language?
00:02:21 <shapr> I like the idea of a Template Haskell like Joy.
00:02:28 <ski> according to a paper with coinheritance, most logicians have used it
00:02:35 <shapr> I also like Epigram's first class types.
00:03:10 <palomer> dependently typed systems are a pain
00:03:32 <palomer> furthermore, the people who created them can't tell me exactly (model theoretically) why they work
00:03:49 <shapr> Have you looked at Types and Programming Languages?
00:03:56 <shapr> I has a pretty clear explanation.
00:04:02 <palomer> shapr: I can only look at that book in windows
00:04:12 * palomer kicks cisco vpn
00:04:15 <shapr> You could buy the book or check it out of the library.
00:04:27 <palomer> it's on reserve in the library
00:04:40 <palomer> though I could get access to a library which has it not on reserve
00:04:46 <shapr> You could go to the library and read the section on dependent types.
00:05:05 <palomer> I'm sure they won't give me a model theoretic argument
00:06:12 <palomer> I mean, if you find a term for : forall x. ((x==y)=T) where =(t,u) = forall X. (Xt -> Xu)
00:06:26 <palomer> then who says that == is reflexive?
00:06:36 <palomer> I mean, intuitively it should be reflexive
00:06:45 <palomer> but they can't prove it to me!
00:06:59 <palomer> (to be fair, I proved it to myself, but the fact that they don't bother about this strikes me as odd)
00:07:10 <palomer> err
00:07:17 <palomer> make that  forall x. ((x==x)=T)
00:07:35 <palomer> well, I proved something a little weaker:O
00:08:09 <palomer> but yeah, I should read that book
00:09:15 <palomer> good night!
00:09:25 <ski> (palomer : http://www.cs.ru.nl/~erikpoll/publications/durham97.html http://www.cs.ru.nl/~erikpoll/publications/kyoto97.html)
00:09:48 <ski> (palomer : those have some info on inheritance and coinheritance)
00:10:01 <ski> night
00:10:18 <palomer> thx
00:11:34 <ADEpt> @index assert
00:11:35 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
00:12:37 <ADEpt> @type Control.Exception.assert
00:12:38 <lambdabot> forall a. Bool -> a -> a
01:03:15 <user317> hello
01:04:15 <ValarQ> hi there
01:04:46 <user317> are you familiar with any genetic algorithms?
01:04:56 <ValarQ> no
01:05:56 <user317> doh
01:06:30 <shapr> hej ValarQ, hur mÃ¥r du?
01:06:56 <ValarQ> shapr: jorÃ¥, det Ã¤r hyffs
01:07:10 <Lemmih> user317: Genetic algorithms?
01:08:41 <user317> Lemmih: yea
01:10:48 <ADEpt> heh. "unveiled is Yoda master of secret. Programmer Foth old an is he" :)
01:12:05 <Lemmih> user317: I was not looking for a 'yea' answer.
01:15:38 <user317> Lemmih: sorry :), i am reading the GA faq on cs.cmu.edu.  i am basically wondering how to design a fitness function that works over two different properties
01:17:11 <ValarQ> i'm thinking about implementing a quadtree in haskell. i did something similar in python but it worked by having multiple references of objects in different levels of the tree
01:17:24 <ValarQ> how can that be implemented in haskell?
01:18:24 <user317>   but i need to sleep now
01:18:32 <user317> so good night everyone
01:18:41 <ADEpt> ValarQ: I dont think that anyone have readily availbale knowledge of what a "quadtree" is
01:19:11 <ValarQ> ADEpt: well, the problem would apply to ordinary trees as well
01:19:50 <ValarQ> ADEpt: i don't succeed to create multiple references to objects in any tree in haskell
01:20:17 <ADEpt> ValarQ: let "data Tree a = Leaf a | Tree (Tree a) (Tree a)". Could you define your problem on this datatype?
01:20:26 <ValarQ> i do realise that maybe i don't want to solve the problem that way in haskell
01:20:34 <ADEpt> "data Tree a = Leaf a | Branch (Tree a) (Tree a)"
01:21:37 <ADEpt> ValarQ: before everything else: have you read "tying the knot" on haskell wiki?
01:22:02 <ValarQ> ADEpt: yes, but only two times...
01:22:55 <ADEpt> ValarQ: "two times" == "read two times" ??
01:23:42 <ValarQ> ADEpt: yeah, i didn't quite understand it the first time
01:24:50 <ValarQ> maybe i should try something simpler with that trick and work my way up
01:25:05 <sieni> firefoxhan on tosi näppärä
01:25:09 <sieni> sorry
01:25:10 <ADEpt> ValarQ: but what is the problem ?:)))
01:25:11 <Saulzar> Hmm, I don't think you need any circular structures for a quadtree
01:26:06 <ValarQ> ADEpt: the real problem is that i wan't to store lines and arcs in a way that makes it fast to calculate intersections between them
01:26:11 <twb> What does wxhaskell need to work with unicode wxwindows?
01:26:14 <Saulzar> You don't use references to objects in haskell, just store the value (it will be boxed anyway) if you really wanted references you could store array indices or something
01:26:32 <Cale> You could use STRefs
01:26:42 <Cale> If you really wanted to
01:26:51 <ValarQ> well, maybe i don't want references
01:26:59 <Saulzar> But I don't think a quadtree demands such a thing... it should be fine as a pure data strcture
01:28:12 <Cale> ValarQ: note that if you define the values in the tree in such a way that some are obviously equal (i.e. they come from the same definition being copied), the compiler will share them in memory
01:28:29 <Saulzar> You could just store a list of shapes or whatever at the leaves (or any tree node)
01:28:45 <ValarQ> Cale: yeah, but i want to remove all of them at once
01:29:00 <ValarQ> Cale: in python i stored a list of treenodes with every object in the tree
01:29:08 <ValarQ> Cale: so that i just could rip it out
01:29:22 <Saulzar> Well, you can give each object an ID if you like
01:30:14 <ValarQ> Saulzar: but then i would have to walk through the entire tree to delete something
01:30:52 <Saulzar> Hmm, you can use the same intersection tests you use to insert to do the remove...
01:31:05 <Cale> Just about any imperative program is doable in Haskell with the ST monad, but you usually want to think of something more clever :)
01:31:11 <ValarQ> Saulzar: thats very true
01:31:40 <ValarQ> Cale: yeah, i guess i would hack it in C then :)
01:31:58 <Cale> in C?
01:32:09 <ValarQ> Cale: ANSI C
01:32:16 <Cale> why?
01:32:42 <Cale> I thought you already have a python implementation
01:32:49 <ValarQ> if it becomes to much work in haskell, then C might be both faster and simpler
01:33:18 <ValarQ> i do, so wont write a C version
01:33:22 <Cale> Well, the ST monad isn't any harder to use than pointers in C :)
01:33:38 <Cale> Or references in Java
01:33:40 <Saulzar> Probably not quite as quick :)
01:33:45 <Saulzar> Though, I don't know...
01:34:11 <Cale> well, Haskell programs have some overhead, but ST is pretty fast in general
01:34:24 <ValarQ> i think i will play around with them, see what i can do with them
01:35:22 <Cale> It would be nice to see a book on purely functional algorithms in computational geometry
01:36:05 <ValarQ> indeed
01:37:07 <Saulzar> What are you using this for?
01:37:54 <ValarQ> generating gcode files
01:38:04 <ValarQ> for cam systems
01:40:05 <ValarQ> http://arda.no-ip.org/crap_gcode_export_test.png
01:40:49 <Saulzar> What is that?
01:41:15 <ValarQ> here is a better example: http://arda.no-ip.org/somecrap.png
01:41:31 <ValarQ> it's just a testlayout
01:41:59 <Saulzar> Hmm
01:42:31 <ADEpt> @index fromMaybe
01:42:32 <lambdabot> Data.Maybe
01:42:38 <ValarQ> it's mainly for milling pcb-cards but it can be used for many other things
01:43:03 <Saulzar> I'm just doing something similar (well, collision detection), but I've not even bothered with subdivision structures, just bounding sphere :)
01:43:08 <Saulzar> Ahh
01:43:34 <ValarQ> ok :)
01:44:10 <Saulzar> Hmm - so you could have many many more objects?
01:44:40 <ValarQ> http://arda.no-ip.org/3xservo.png
01:45:18 <Saulzar> Hehe, I can see naive O(n^2) collision detection might not be so good there :)
01:45:28 <ValarQ> nope
01:46:47 <ValarQ> i really would like to implement it in haskell because that would make many functions so much simpler and faster
01:47:59 <Saulzar> Hmm, well I don't think a quadtree will be too much hastle, but I guess you have to take a slightly different approach
01:48:12 <ValarQ> maybe some integer reference would be quite fast
01:48:23 <ValarQ> and then just store the objects in a finite map
01:59:57 * Saulzar goes on "make it compile, again" mode...
02:00:21 <Cale> beats debugging :)
02:01:42 <Saulzar> 1 step, not 2 :)
02:10:47 <benny> morning
02:13:24 <Cale> morning
02:14:29 <benny> hm... i must be really dumb i'm getting a parse error (possibly incorrect indentation) on a function i define with let inside a do block
02:15:01 <Cale> Does your editor convert tabs to spaces?
02:15:09 <benny> no
02:15:15 <Cale> make it do that :)
02:15:25 <Cale> what editor are you using?
02:15:36 <benny> i'm using vim but i'm using only spaces so it's not that
02:15:41 <Cale> okay
02:15:58 <Cale> could you paste the code somewhere?
02:16:03 <Cale> lisppaste2: url
02:16:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:17:35 <lisppaste2> benny pasted "parse error" at http://paste.lisp.org/display/15181
02:17:54 <benny> i get parse error on the b + 1 line
02:18:31 <Cale> ah, one more space :)
02:19:00 <Cale> it's indented the same as a, so it looks like a's definition ends
02:19:40 <benny> ah! thanks! wow haskell layout can be tricky sometimes
02:20:13 <Cale> The essential idea is that parts which are inside other parts have to be indented more.
02:20:13 <benny> is there a page on the wiki with layout guidelines for newbies?
02:20:47 <Cale> the actual layout algorithm is pretty complex. It's described in the report, if you really want to read it :)
02:21:35 <benny> that's why we need a simple page for newbies :)
02:21:52 <Cale> http://www.haskell.org/onlinereport/lexemes.html#sect2.7 -- actually, this does a good job
02:22:32 <Cale> there's a more complicated explanation in section 9.3
02:26:39 <benny> hm... i guess one learns best just by reading lots of code =]
02:27:56 <benny> @seen Lemmih 
02:27:57 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 1 hour, 15 minutes
02:27:57 <lambdabot> and 51 seconds ago.
02:32:14 <Saulzar> Hmm, that's interesting - in the current Yampa ver it exports the data constructor for event...
02:32:26 <jlouis> Hi, I updated Conjure yet again. New laptop takes some time to get up and running, so I am a bit behind. Hopefully I can catch up over the next couple of days
02:32:56 <Saulzar> I was reading the robot soccor demo, and they keep on saying that they are doing evil things by constructing events directly
02:33:05 <benny> Saulzar: you mean i'm not supposed to do that?
02:33:08 <Saulzar> I guess they decided it's not so bad 
02:33:12 <jlouis> (And I am running Debian now, I welcome all other on the Dark side with light-saber wielding cows)
02:33:20 <benny> Saulzar: how are you supposed to make events then?
02:34:51 <Saulzar> I guess you can do it by using the event source signal functions... eg. edge, but that seems quite ugly when you just want to pass on events (eg. from SDL as you are)
02:35:25 <benny> yeah i'm just using Event constructor
02:35:51 <Saulzar> I see nothing wrong with it - I'm just curious given the comments in their robot soccor demo
02:36:50 <Saulzar> RSObjectPhysics.as:import AFRPInternals (Event(..))     -- Breach of abstraction!
02:39:05 <[CotL]Godofe_Kei> good morney
02:39:10 <Cale> they are importing from AFRPInternals
02:39:23 <Cale> which you'd suspect was for internal use :)
02:39:23 * benny is not importing from AFRPInternals
02:40:56 <Saulzar> Cale, Yeah, but in the current version they re-exprt Event in the main interface
02:42:43 <benny> man i really need more memory i think
02:48:21 * Cale listens to the "Up All Night" album by John Scofield.
02:48:28 <Cale> Rather appropriate for me :)
02:48:49 <Cale> @localtime Cale
02:48:51 <lambdabot> Local time for Cale is Fri Dec 30 05:48:28
02:50:13 <benny> @localtime benny 
02:50:15 <lambdabot> Local time for benny is Fri Dec 30 12:51:19
02:51:01 <Cale> http://www.dinkla.net/fp/cglib.html -- this looks interesting
02:53:30 <benny> cool, but what i want is a haskell version of NEAT
02:54:19 <Cale> what is that?
02:54:41 <Cale> (it's practically ungooglable on its own :)
02:57:47 <benny> http://nn.cs.utexas.edu/project-view.php?RECORD_KEY(Projects)=ProjID&ProjID(Projects)=14
02:57:57 <Saulzar> The programs were developed and teste with Hugs 1.4 and GHC 2.10.
03:00:04 <[CotL]Godofe_Kei> guys can u tell me how to build something like this: http://paste.lisp.org/display/15183
03:00:11 <Saulzar> benny, What does that lot mean? :)
03:00:55 <Saulzar> Is it machine learning? Neural networks or?
03:01:31 <benny> uses genetic algorithm to create a nueral net
03:01:41 <Saulzar> Ahh
03:02:06 <benny> problem with neural net is how do you know how many nodes and layers you need for your problem?
03:02:10 <Saulzar> The description on that page doesn't make it very clear!
03:02:23 <benny> NEAT uses a genetical algorithm to find the optimal structure
03:02:30 <Saulzar> Hmm, cool
03:02:38 <benny> bbiab
03:06:05 <[CotL]Godofe_Kei> guys can u tell me how to build something like this: http://paste.lisp.org/display/15183
03:08:22 <ValarQ> [CotL]Godofe_Kei: build?
03:08:30 <ADEpt> [CotL]Godofe_Kei: main = putStrLn "   Pos.  Num.  Nome                          Tempo
03:08:30 <ADEpt>    1     1     Tartaruga Teresa              00:25:15.000
03:08:30 <ADEpt>    2     2     Lebre Laura                   +0.013s
03:08:30 <ADEpt>    3     3     Mosca Maria                   +3 volta(s)"
03:08:39 <humasect> =)
03:08:55 <ValarQ> nicely done :)
03:09:08 <humasect> curious, would anyone have any examples off hand for "good haskell" and "bad haskell" code?
03:09:19 <ValarQ> humasect: on the wiki i believe
03:09:22 <humasect> i feel i got it
03:09:34 <humasect> okay
03:09:47 <ValarQ> humasect: http://haskell.org/hawiki/ThingsToAvoid
03:11:33 <humasect> ah, code pitfalls. i was thinking more of "evolution of a haskell programmer" but perhaps along the lines of: "haskell project _x_ was coded very well. haskell project _y_ was coded somewas undesirably [read: uncurried do]"
03:11:44 <humasect> *somewhat
03:12:24 <ValarQ> ok
03:15:02 <humasect> as benny said.. best to learn by reading lots of code, there are different styles of code. I think more so than other languages
03:15:24 <humasect> (styles of haskell code)
03:18:17 <Cale> ThingsToAvoid has a strange bias
03:18:25 <Cale> well, somewhat
03:18:38 <[CotL]Godofe_Kei> is there any way to "line up" those columns?
03:18:44 <[CotL]Godofe_Kei> to stay like that example
03:18:56 <Cale> actually, it's looking a little better
03:18:59 <[CotL]Godofe_Kei> do i have to type all the ' '?
03:19:14 * humasect checks
03:20:14 <Cale> [CotL]Godofe_Kei: you could write some functions which compute the number of spaces
03:20:37 <[CotL]Godofe_Kei> oh
03:20:39 <[CotL]Godofe_Kei> nvm then
03:20:42 <Cale> There's obviously not going to be anything like that in the libraries, as it's pretty special-purpose, but it's not a hard thing to do
03:20:48 <[CotL]Godofe_Kei> ill just send a big fat turd to my teacher
03:21:14 <humasect> ValarQ thanks
03:21:59 <ADEpt> [CotL]Godofe_Kei: you would need something along the lines of:
03:21:59 <ADEpt> data Row = R [String]
03:21:59 <ADEpt> data Table = T [Row]
03:21:59 <ADEpt> colLengths :: Row -> [Int]
03:21:59 <ADEpt> maxColLengths :: Table -> [Int]
03:21:59 <ADEpt> , which will enable you to compute desired number of spaces
03:23:03 <[CotL]Godofe_Kei> thx a lot
03:23:10 <[CotL]Godofe_Kei> but im not going to use that
03:23:22 <[CotL]Godofe_Kei> in fact, im not using anything at all
03:23:37 <[CotL]Godofe_Kei> just pray for the gods to explode my teachers head
03:23:46 <[CotL]Godofe_Kei> and then ill have a merry xmas
03:23:46 <Cale> why?
03:23:50 <[CotL]Godofe_Kei> why?!
03:23:52 <[CotL]Godofe_Kei> lol
03:23:54 <ADEpt> that's a christmas spirit!
03:24:15 <Cale> It's not that hard :)
03:24:19 <[CotL]Godofe_Kei> cause my teacher gave like 8 classes, in all he sits in his chair, gives us 10 exercices to do....
03:24:24 <[CotL]Godofe_Kei> when u ask for help
03:24:30 <[CotL]Godofe_Kei> he just says: Try harder
03:24:41 <[CotL]Godofe_Kei> and when the class is over, you've done about 3
03:24:51 <[CotL]Godofe_Kei> and the other 7 are considered done
03:24:55 <[CotL]Godofe_Kei> so the next class
03:24:59 <[CotL]Godofe_Kei> another 10 exercices
03:25:08 <[CotL]Godofe_Kei> the last exerciced i did were with map
03:25:15 <[CotL]Godofe_Kei> now he asks me to do something like this
03:25:27 <[CotL]Godofe_Kei> i havent even started to even look at something like this
03:26:07 <ADEpt> maybe it is just a matter of asking questions right. Like, not "how to do this?", but "I've done part of it, but i'm stuck with XYZ. Any clues?"
03:26:15 <[CotL]Godofe_Kei> lol
03:26:21 <[CotL]Godofe_Kei> i understant what your saying
03:26:24 <ADEpt> [CotL]Godofe_Kei: in fact, you do not need anything besides the map to do that
03:26:36 <[CotL]Godofe_Kei> .....
03:26:37 <Cale> you won't need much more than map, maximum, length, replicate
03:26:44 <[CotL]Godofe_Kei> how about practice?
03:26:52 <[CotL]Godofe_Kei> well
03:26:54 <ADEpt> ah. I'm wrong. You'll need foldl or maximum
03:26:57 <Cale> well, this is good practice isn't it?
03:27:00 <[CotL]Godofe_Kei> lol
03:27:12 <[CotL]Godofe_Kei> im just sick of it
03:27:15 <[CotL]Godofe_Kei> its not what u give
03:27:20 <[CotL]Godofe_Kei> its the quality
03:27:28 <[CotL]Godofe_Kei> they teahc me to work with map (mention it)
03:27:38 <[CotL]Godofe_Kei> give us 10 exercices we do the simpler ones
03:27:47 <[CotL]Godofe_Kei> and then ask us to do somethig like this
03:27:50 <[CotL]Godofe_Kei> its ridiculus
03:28:07 <[CotL]Godofe_Kei> it would be a good exercice if it was a homework
03:28:18 <Cale> well, what is it?
03:28:18 <[CotL]Godofe_Kei> but its not
03:28:21 <ADEpt> [CotL]Godofe_Kei: you seem to presume that this task is much harder than "map fun list" ?
03:28:53 <[CotL]Godofe_Kei> ADEpt wher r u from?
03:29:23 <[CotL]Godofe_Kei> this task can be realy simple
03:29:40 <[CotL]Godofe_Kei> but nobody ever taught me to do anything like this
03:30:15 <Cale> [CotL]Godofe_Kei: sure, but break the problem down a bit, and perhaps some familiar things will appear
03:30:21 <[CotL]Godofe_Kei> dude
03:30:33 <[CotL]Godofe_Kei> i uderstand it seems simple to you to say that
03:30:52 <[CotL]Godofe_Kei> but belive me, what they teach me....
03:30:55 <ADEpt> [CotL]Godofe_Kei: well, can you solve it without the computer? Like, describe solution in English? 
03:30:57 <[CotL]Godofe_Kei> i can barely use map
03:31:16 <[CotL]Godofe_Kei> of corse i can
03:31:18 <ADEpt> [CotL]Godofe_Kei: i'm from Kiev, Ukraine, but I can't see how this relates to the problem at hand :)
03:31:35 <[CotL]Godofe_Kei> no its cause you have ADEpt, and pt is my country
03:31:37 <[CotL]Godofe_Kei> :P
03:32:02 <ADEpt> [CotL]Godofe_Kei: well, I would dare to say that solution in English will map almost 1:1 to haskell
03:33:57 <[CotL]Godofe_Kei> ?!
03:34:14 <[CotL]Godofe_Kei> let me give u an example
03:34:31 <ADEpt> [CotL]Godofe_Kei: well, let's see. In the end you'll have to print the table, right?
03:34:33 <[CotL]Godofe_Kei> see this: map (\s -> let (n,r) = span isDigit s in (n,r)) (lines s)
03:34:45 <[CotL]Godofe_Kei> guess what....i HAD NO IDEA what this was
03:35:04 <Cale> so?
03:35:08 <[CotL]Godofe_Kei> so?
03:35:13 <Cale> look up span, isDigit, and lines
03:35:20 <[CotL]Godofe_Kei> i am supose to know this, i mean it came in my exam
03:35:31 <[CotL]Godofe_Kei> lines? span? isDigit?
03:35:36 <Cale> what have you been reading?
03:35:38 <[CotL]Godofe_Kei> never heard them before
03:35:45 <[CotL]Godofe_Kei> now i know what they do
03:35:48 <Cale> do you have a textbook?
03:35:50 <ADEpt> @docs lines
03:35:51 <lambdabot> lines not available
03:35:56 <ADEpt> @index lines
03:35:56 <[CotL]Godofe_Kei> but its because i get home and study about that
03:35:57 <lambdabot> Data.List, Prelude
03:36:01 <Cale> @type lines
03:36:02 <lambdabot> String -> [String]
03:36:04 <ADEpt> @index isDigit
03:36:04 <lambdabot> Data.Char
03:36:12 <[CotL]Godofe_Kei> but i dont think anyone can expect that from me when they didnt taught me right
03:36:32 <Cale> do you have a course text or course notes to study?
03:36:44 <[CotL]Godofe_Kei> ?!
03:36:46 <[CotL]Godofe_Kei> no
03:36:54 <[CotL]Godofe_Kei> i only have a book....in english
03:36:59 <[CotL]Godofe_Kei> im not EVEN ENGLISH!
03:37:09 * ADEpt wonders what's the point of [CotL]Godofe_Kei 's lamentation :)
03:37:24 * ADEpt is not English as well
03:37:27 <[CotL]Godofe_Kei> well the point is that im sick of all thi bs
03:37:38 <[CotL]Godofe_Kei> sry to bother u really
03:37:49 * ADEpt is so not english that .pt looks like Downing Street in comparison ;)
03:37:50 <[CotL]Godofe_Kei> but when u have tons of exams to do, and things to do
03:37:56 <pierre-> hello
03:37:59 <Cale> well, I'm not sure if there are any good portuguese references on Haskell, but you'd probably do well to look for one
03:38:07 <Cale> pierre-: hello
03:38:22 <[CotL]Godofe_Kei> i realy dont apreciate to be avaluated by something i havent even been taught
03:38:27 <[CotL]Godofe_Kei> sup dude?
03:38:51 <[CotL]Godofe_Kei> if teachers dont do their job, and on top of that give assignments like these to me?
03:38:54 <Cale> [CotL]Godofe_Kei: you might ask your prof what the expectations for the course are
03:39:00 <[CotL]Godofe_Kei> lol
03:39:01 <[CotL]Godofe_Kei> i would
03:39:09 <[CotL]Godofe_Kei> be he doesnt show up in classes for weeks
03:39:10 <[CotL]Godofe_Kei> see?
03:39:23 <[CotL]Godofe_Kei> they made some guy from my ouw course "teacher"
03:39:31 <[CotL]Godofe_Kei> so they could do "something else"
03:39:41 <Cale> Office hours?
03:39:52 <[CotL]Godofe_Kei> so, im actually learning from someone who never gave classes and hasnt even finished the course
03:40:02 <[CotL]Godofe_Kei> and u know what? hes better than them
03:40:15 <[CotL]Godofe_Kei> Cale: What do u mean?
03:40:24 <Saulzar> You have access to the reference material right? You can look up the ghc libraries on the net, or lookup functions in ghci...
03:40:44 <Cale> As in, does your professor have hours where he's supposed to be in his office so that students can come and ask questions?
03:40:54 <[CotL]Godofe_Kei> yes
03:41:00 <[CotL]Godofe_Kei> but u actualy think hes there?
03:41:03 <[CotL]Godofe_Kei> lol think again
03:41:14 <Cale> well, you should be able to complain in that case
03:41:21 <Cale> You might want to ask for a clearer list of the things you need to learn
03:41:30 <[CotL]Godofe_Kei> the point is: Going to classes or learn on myself == THE SAME!
03:41:53 <[CotL]Godofe_Kei> complain? lol let me give you another realy good example:
03:42:00 <Cale> well, if you're paying for lectures and not getting them, I think there's lots of room to complain to your uni
03:42:16 <[CotL]Godofe_Kei> in PhysicsII the last exam had 3 chapters 7 8 and 9
03:42:23 <[CotL]Godofe_Kei> i never even heard anything about them
03:42:32 <[CotL]Godofe_Kei> the last one we spoke of was 6
03:42:40 <[CotL]Godofe_Kei> see what i mean?
03:42:46 <[CotL]Godofe_Kei> we complain, but nobody realy cares
03:43:27 <Cale> my advice then would be to always finish reading all your textbooks :)
03:43:52 <Cale> (but I really think there ought to be a way to formally complain to the administration about things like that)
03:43:53 <[CotL]Godofe_Kei> lol
03:44:01 <[CotL]Godofe_Kei> but there is dude
03:44:05 <[CotL]Godofe_Kei> we done that so many times
03:44:12 <[CotL]Godofe_Kei> but...nobody cares
03:44:19 <[CotL]Godofe_Kei> they get payed the same
03:44:32 <[CotL]Godofe_Kei> actually, the longer we stay there the more they get payed
03:45:10 <[CotL]Godofe_Kei> aww cmon, u guys dont need to hear bout this
03:45:11 <[CotL]Godofe_Kei> sry
03:45:19 <[CotL]Godofe_Kei> :-P
03:45:25 <Cale> no problem
03:47:30 <maitscha> hallo, i am very new to haskell. what does the $-operator?
03:47:56 <ADEpt> maitscha: it's a way to get rid of lots of braces :)
03:47:56 <ADEpt> @type $
03:47:57 <Cale> f $ x = f x
03:47:58 <lambdabot> parse error on input `$'
03:48:04 <ADEpt> @tyep ($)
03:48:05 <lambdabot> forall b a. (a -> b) -> a -> b
03:48:08 <ADEpt> @type ($)
03:48:09 <lambdabot> forall b a. (a -> b) -> a -> b
03:48:28 <Saulzar> f $ x y z = f (x y z)
03:48:32 <Cale> but it binds really weakly, so it's like you're surrounding the two sides of it with parens
03:48:36 <maitscha> can't find any docu on that operator
03:48:43 <ADEpt> maitscha: f (g (s (t x))) == f $ g $ s $ t x
03:48:43 <Cale> It's in the prelude
03:48:49 <int-e> and it's right associative - a $ b $ c  si a (b c)
03:48:55 <Saulzar> It's quite hard to search for it in google though :)
03:49:11 <Lor> ($) = id
03:49:16 <Cale> infixr 0  $
03:49:25 <Cale> ($), ($!) :: (a -> b) -> a -> b
03:49:25 <jlouis> oy ADEpt 
03:49:25 <Cale> f $  x    =  f x
03:49:25 <Cale> f $! x    =  x `seq` f x
03:49:35 <jlouis> (Yes, I am behind, I know it ;)
03:49:37 <int-e> @info ($)
03:49:37 <lambdabot> Unknown command, try @listcommands.
03:49:38 <ADEpt> jlouis: oy!
03:49:48 <ADEpt> jlouis: christmas time, of course :)
03:49:48 <Cale> You can probably ignore $! for now
03:49:52 <int-e> does anyone know why @info is disabled?
03:49:52 <maitscha> ok
03:50:11 <Cale> but think of $ as just a good way to eliminate parentheses
03:50:15 <Lor> $! should really be left-associative...
03:50:17 <maitscha> so its a replacment for braces?
03:50:29 <Cale> yeah, basically
03:50:44 <Cale> It's just an ordinary function though
03:50:54 <pierre-> can someone help me to figure out perl-like "split" function?
03:50:54 <Cale> so you can pass it to other functions and such
03:51:06 <Saulzar> It's great when you have a huge amount of nesting, then you can use one $ per nesting level rather than a mass of backets
03:51:14 <ADEpt> pierre-: what have you got so far?
03:51:20 <Cale> > zipWith ($) [(+10), (+20), (*5)] [1,2,3]
03:51:21 <lambdabot> [11,22,15]
03:51:28 <ADEpt> jlouis: have you seen the latest diagram of mine yet?
03:51:49 <Cale> incidentally, it's the same as id
03:51:52 <Cale> > zipWith (id) [(+10), (+20), (*5)] [1,2,3]
03:51:53 <lambdabot> [11,22,15]
03:51:58 <pierre-> ADEpt: in haskell? or in "split"
03:52:05 <maitscha> so func1 (func2 (func3 a)) would be func1 $ func2 $ func3 a
03:52:06 <ADEpt> pierre-: in split
03:52:11 <pierre-> nothing :-)
03:52:12 <Cale> maitscha: yeah
03:52:16 <maitscha> ok. thx.
03:52:58 <ADEpt> pierre-: well ... what kind of help do you need then?
03:53:11 <Cale> pierre-: does it need to work with arbitrary regexes?
03:53:44 <Cale> @type Text.Regex.splitRegex
03:53:45 <lambdabot> Text.Regex.Posix.Regex -> String -> [String]
03:54:31 <pierre-> no, simply split "a" "xyazab" --> ["xy", "z", "b"]
03:55:15 <pierre-> i'm interested in functional implementation of this...
03:55:19 <ADEpt> pierre-: any you need to write your own, right?
03:55:38 <ADEpt> pierre-: are you aware of takeWhile and dropWhile?
03:55:55 <int-e> @type span
03:55:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:56:03 <Cale> > break (== 'a') "xyazab"
03:56:04 <lambdabot> ("xy","azab")
03:57:24 <ADEpt> pierre-: i would dare to say that you can compose split out of takeWhile+dropWhile+iterate or from takeWhile + iterate + break
03:58:25 <pierre-> @type iterate
03:58:26 <lambdabot> forall a. (a -> a) -> a -> [a]
03:58:41 <ADEpt> > take 10 $iterate (+1) 10
03:58:42 <int-e> ADEpt: break has the takeWhile built in [break = span . (not .)   and  span p l = (takeWhile p l, dropWhile p l)]
03:58:43 <lambdabot> [10,11,12,13,14,15,16,17,18,19]
03:59:41 <ADEpt> int-e: split with span and break will need lambdas, and split with takeWhile and dropWhile will not :)
04:00:26 <Cale> > words "This is a string."
04:00:27 <ADEpt> int-e: correction, "will need lambdas to be concise". I am well aware of @pl :)
04:00:28 <lambdabot> ["This","is","a","string."]
04:00:59 <Cale> For words and lines, there are special cases. I don't know why nobody thought to generalise :)
04:01:18 <int-e> > takeWhile (not . null) $ unfoldr (Just . break '==a') "aljknaablnclaba"
04:01:19 <lambdabot>  lexical error in string/character literal
04:01:29 <int-e> > takeWhile (not . null) $ unfoldr (Just . break (=='a')) "aljknaablnclaba"
04:01:30 <lambdabot> []
04:01:44 <ADEpt> :)
04:01:48 <Cale> hehe
04:02:26 <ADEpt> @type unfoldl
04:02:27 <lambdabot> Not in scope: `unfoldl'
04:02:44 <ADEpt> @type unfoldr
04:02:45 <lambdabot> Not in scope: `unfoldr'
04:02:54 <ADEpt> @ndex unfoldr
04:02:55 <lambdabot> Data.List
04:03:03 <ADEpt> @type Data.List.unfoldr
04:03:04 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:04:56 <int-e> > take 10 $ Data.List.unfoldr (\l -> if null l then Nothing else Just $ (id *** tail) $ break (=='a') l) "aljknaablnclaba"
04:04:58 <lambdabot> ["","ljkn","","blncl","b"]
04:05:12 <int-e> ignore the take 10 :)
04:06:08 <pierre-> @type (***)
04:06:09 <lambdabot> Not in scope: `***'
04:06:22 <int-e> @type (Control.Arrow.***)
04:06:23 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
04:06:23 <lambdabot> (Control.Arrow.Arrow a) =>
04:06:23 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
04:06:37 <pierre-> hmm and what's this? 
04:06:38 <int-e> [with a = (->)]
04:06:57 <Cale> (f *** g) (x,y) = (f x, g y)
04:07:20 <Cale> the fact that it's an Arrow operator can be ignored :)
04:07:37 <int-e> luckily ;)
04:07:56 <Cale> If you want to see a sane implementation of something like this, look in the prelude under words
04:08:09 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
04:08:13 <int-e> Cale: heh. from you, I resent that remark :)
04:08:19 <Cale> It's about 2/3 of the way down
04:08:29 <Cale> int-e: sane for a newbie? :)
04:08:46 <int-e> Cale: you didn't say this. I agree of course :)
04:09:14 <Cale> Though, I've always been annoyed with the awkwardness of unfoldr
04:09:47 <Cale> there's nothing much you can do about it though
04:12:26 <Lor> Yeah, many arrow combinators are useful for plain functions.
04:12:28 <int-e> well, it's artificial - the relationship between data [a] = [] | a:[a]  and  Maybe (a,-) = Nothing | Just (a,-) is not as clear as it could be.
04:16:27 <Cale> perhaps if list was built with explicit recursion
04:16:28 <int-e> data ListCons a b = Nil | Cons a b
04:16:28 <int-e> data List a = ListCons a (List a)
04:16:28 <int-e> unfoldr :: (b -> ListCons a b) -> b -> List a
04:16:32 <int-e> like this :)
04:16:49 <int-e> (the Cons in ListCons is for 'constructors')
04:16:52 <Cale> yes, like that
04:19:22 <Cale> type List a = Mu (ListCons a)
04:23:56 <xerox> moo.
04:24:09 <Cale> mew.
04:24:18 <xerox> What are you playing with? :-)
04:24:50 <Lor> µx.1+a×x
04:25:28 <int-e> oh. and of course, unfold :: (x :: *->*) => (a -> x a) -> a -> Mu x
04:25:39 <xerox> "of course"
04:25:44 <Cale> hehe
04:25:47 <Lemmih> Hi fabs.
04:25:55 <xerox> Someone here is playing with some pretty new shiny toy all alone :)
04:26:11 <int-e> it's just dreamware.
04:27:13 <Cale> Of course, then you end up writing lists like: In (Cons 1 (In (Cons 5 (In Nil))))
04:27:51 <fabs> hello Lemmih. Long time no see.
04:28:56 <int-e> and unfold needs a Functor instance for x ... is that enough? ... unfold f a = In $ fmap (unfold f) a ?
04:29:18 * xerox unfolds int-e
04:29:40 <Cale> int-e: yeah
04:29:57 <xerox> How does it stop?
04:30:45 <int-e> well, when it hits a constructor without recursion.
04:31:56 <xerox> ...a sample 'f' ?
04:32:25 <hulahub> how to convert Int to Integer ?
04:33:09 <xerox> fromIntegral
04:33:35 <Lemmih> fabs: I didn't know you were a Haskeller.
04:34:18 <Cale> unfold :: (Functor x) => (a -> x a) -> a -> Mu x
04:34:18 <Cale> unfold f a = In $ fmap (unfold f) (f a)
04:34:59 <int-e> ah.
04:35:47 <Cale> unfold (\n -> Cons n (n+1)) 0
04:35:47 <Cale> In (Cons 0 In (Cons 1 In (Cons 2 In (Cons 3 In (Cons 4 In (Cons 5...
04:35:54 <Cale> :)
04:36:48 <xerox> oooh.
04:38:20 <Cale> http://haskell.org/hawiki/HaskellIrcPastePage
04:40:31 <xerox> 'out' eh.
04:40:34 <fabs> Lemmih: I'm a haskell newbie really ;) I've programmed with some functional language which was developed here at our university and now I'm taking a look at haskell.
04:41:15 <int-e> unfold (\n -> if n==0 then Nil else Cons n (n-1)) 10 <-- shows how it stops :)
04:41:21 <xerox> Yeah :D
04:43:47 <xerox> I think we should have some function to write 'if's more concisely.
04:44:11 <xerox> ...like "if'", but maybe named differently.
04:44:20 <ndm> xerox, cond c t f = if c then t else f
04:44:27 <ndm> i have that defined in my standard library
04:44:31 <xerox> ...something like that, yeah.
04:44:57 <int-e> actually, if would be just fine - who needs special syntax for that?
04:46:18 <xerox> That's what I meant?
04:46:42 <int-e> yep.
04:46:55 <int-e> I suppose :)
04:47:28 <int-e> We could make a Haskell-- dialect ... Haskell without the few warts it has ;-)
04:48:17 <Cale> I actually disagree somehow with making if just a function. The 'then' and 'else' keywords help guide your eye in reading code.
04:48:48 <Cale> That was one of the annoying things about lisp/scheme
04:49:28 <Cale> of course, it would be nice to have a function equivalent to if' in the prelude
04:50:35 <xerox> Cale: I don't want 'if' to go away, but sometime an if' equivalent could be handy.
04:50:42 <Cale> xerox: yeah
04:51:23 <Cale> Or how about  cond a b c = if c then a else b
04:51:34 <xs_> a ? (b, c)
04:51:37 <Cale> a funny representation of pairs :)
04:52:59 <sieni> well, isn't "if-then-else" actually a function in Haskell because of the lazy evaluation unlike e.g. scheme, where it is a special form
04:53:00 <int-e> @type maybe
04:53:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:53:10 <int-e> that function should be called 'bool' then ;)
04:53:30 <Lor> Yeah, I've never liked the special syntax for if, since it's completely unnecessary.
04:53:37 <Cale> sieni: it's a function in the sense that it could be implemented by one, but it's still special syntax
04:53:57 * int-e actually isn't unhappy about the if syntax.
04:54:11 <Cale> I really hope the special syntax for if never goes away :)
04:54:16 * int-e is just unhappy about the (a+n)-patterns.
04:54:19 * Lor is actually rather fond of C's ?:-conditionals.
04:54:59 <Cale> Things which are unnecessary can still be desirable :)
04:55:06 <sieni> Lor: yeah, they rule
04:56:44 <Saulzar> I never quite know how to format if then else in haskell, in one line it makes for a really long line
04:56:45 <Lor> Well no, they don't quite _rule_, since trinary infix operators are syntactically a huge mess. But they're nice enough.
04:57:05 <Lor> Saulzar, use case.
04:57:09 <Saulzar> So I'd write it like a case..
04:57:28 <Cale> Saulzar: indent the then and else parts and put them on successive lines
04:57:35 <Cale> if ...
04:57:38 <Cale>     then ...
04:57:41 <Cale>     else ...
04:57:46 <Lor> How is that in any way better than
04:57:54 <Lor> case ... of
04:57:57 <Lor>   True -> ...
04:57:59 <Saulzar> Yeah, that's what I do - but then what's the point in using if over case, or using a function (and doing the same thing) ?
04:58:00 <Lor>   False -> ...
04:58:05 <Cale> Lor: it reads better
04:58:14 <Lor> No it doesn't.
04:58:46 <Lor> The only problem with case is that it's a bit too verbose. But if-then-else doesn't fix that.
05:00:05 <Lor> (And this is only an issue with very short expressions)
05:00:14 <Cale> case Finnish uses grammatical structure like this of True -> perhaps it's more natural for you; False -> if-then-else comes closer to your language
05:00:15 <Saulzar> I guess it depends on the person, doesn't worry me too much
05:00:45 <Cale> :)
05:00:58 <Lor> A formal language is not supposed to resemble a natural language.
05:01:07 <Cale> Well, it's nice where it does :)
05:01:12 <Lor> Otherwise cobol would rule the world.
05:01:17 <wolverian> I don't think Finnish has such a structure, anyway. or does it?
05:01:22 <Cale> It's nice to have a readable translation of your formal language
05:01:58 <Cale> So when you're speaking code aloud, it more easily makes sense to those around you :)
05:02:12 <Lor> Code spoken aloud never makes sense. :)
05:02:27 <Saulzar> If code is not meant to resemble natural language, why bother using words for variables?
05:02:54 <Saulzar> Oh wait - functional programmers tend to use the whole alphabet first :)
05:03:01 <Cale> why bother with keywords at all? Just make them all one letter, it'll be easier to parse :)
05:03:24 <Lor> I was talking about the syntax, not the vocabulary.
05:03:28 <Saulzar> Sorry you can't use "d", it's a key-letter :)
05:03:47 <Cale> hehe
05:03:53 <Lor> And personally, I'd rather not have alphabetical keywords.
05:04:11 <Lor> All built-in syntax should be purely symbolic, and letters should be reserved for variables.
05:04:14 <alar> easiness in remembering /= closeness to natural language
05:04:33 <Saulzar> No relation at all?
05:04:55 <shapr> I think ease of memory is related to regularity for me.
05:05:08 <benny> hm... did someone need me?
05:05:10 <Cale> I'm the sort of mathematician who writes his proofs in prose as much as possible though, and reserves symbolic bits for calculations.
05:05:13 <shapr> That is, if the patterns in one part of the system can be applied to figure out the rest of the system, I can remember it.
05:05:37 <Lor> Cale, I'm the sort that never understands prose until I write it down formally.
05:05:53 <shapr> Thus the reason that [1,2].sort() and other side-effect-only functions irritate me in Python.
05:05:53 <Cale> (well, I'll use symbols to refer to things, anyway)
05:05:59 <Lor> Rather, I never _trust_ prose.
05:06:29 <Cale> I usually find that prose brings things closer to the form in which I check them
05:06:33 <shapr> I trust working code that I can read and modify. And even then, I don't trust it unless I can understand it well enough to alter it for my own purposes.
05:06:42 <Saulzar> shapr, Yeah, consistency is wonderful.
05:06:57 <shapr> Haskell has LOTS of consistency.
05:07:04 <shapr> That's one of my favorite things about the language.
05:07:47 <Cale> I'd almost never write down a first-order sentence just to check a property, unless I was thinking of the property as a computation in formal logic.
05:09:06 <Lor> I write it down to _understand_ it.
05:09:20 <Lor> Informal language tends to have scope ambiguities and whatnot.
05:10:52 <Cale> They're usually not too much of a problem to disambiguate. I'm usually more concerned with my interpretation of the phrase than writing it into something formal and then having to interpret it again :)
05:11:29 <Cale> Probably the worst that it gets is when someone moves a quantifier to the end.
05:11:50 <Cale> There's a convention which says that quantifiers written in that way bind as tightly as possible.
05:12:27 <ibid> nowadays if i want my students to do things less than completely formally, i tend to ask them to use "the mathematician's way"
05:12:45 <int-e> Cale: Aww. I can't build show from fold (fold f = f . fmap (fold f) . out): fold show $ <some list> --> "Cons 2 \"Cons 1 \\\"Nil\\\"\""
05:13:19 <ibid> when i introduce this notion, i usually tell them that mathematicians are masters in leaving nonessentials out and just writing down what's essential to understanding the proof or whatever it is we're looking at
05:14:18 <Cale> Mathematicians always say what's essential for everyone around them to be able to fill in the gaps for themselves, because it gets really boring if you don't.
05:14:28 <shapr> Oh I have an idea for that.
05:14:34 <ibid> exactly
05:15:06 <Lor> I have no problem with gaps, I just wish the gaps were clearly marked.
05:15:07 <shapr> Make math papers literate files much like Haskell, executable in a proof assistant. And make a CPAN (Comprehensive Proof Archive Network) so you can download libraries.
05:15:15 <Cale> and usually it's faster for that someone fill in the gaps than for you to spell it out for them
05:17:25 <Cale> This actually gets pretty sophisticated, especially in places like topology, where I'll not hesitate to say "cut a hole in these two spaces, and connect them by gluing in a cylinder" -- usually writing out an explicit set of equivalence relations and such is pretty tedious in things like that, especially when you hardly care what it's doing on the set-theoretic level.
05:18:05 * Lor bought a klein bottle for his granddad as a christmas present.
05:18:15 <Cale> You usually prove that you can do things like that at the start of the course, and then just let them go, convinced that you could fill it in, so long as nothing too odd is happening.
05:18:56 <Lor> That's sufficient to _convince_ oneself, but not enough to _prove_ it, I'd say.
05:19:23 <Cale> well, being convinced is the same as being able to prove it.
05:19:23 <ibid> i once read a paper that argued that mathematics is a social, not formal, activity
05:19:29 <astrolabe> The ability to even give a formal description came quite late on for a lot of maths.
05:19:44 <Lor> cale, not in my world
05:19:55 <Cale> I could actually sit down and write out some equivalence relations and formulas in any case that you'd want.
05:20:11 <shapr> Why not just import them from a CPAN?
05:20:11 <{Arias}> hi
05:20:13 <{Arias}> @pl (\x -> zip (x) (tail x))
05:20:13 <lambdabot> ap zip tail
05:20:21 <{Arias}> what is ap?
05:20:28 <shapr> @index ap
05:20:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
05:20:29 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
05:20:29 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
05:20:29 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
05:20:37 <shapr> It's a monad lifter.
05:20:40 <Cale> @type Control.Monad.ap
05:20:41 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
05:20:47 <{Arias}> ahhh
05:20:58 <{Arias}> i was trying @type ap :P
05:20:59 <Cale> > return (,) `ap` [1,2,3,4,5] `ap` [6,7,8,9,10]
05:21:01 <lambdabot> [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7)
05:21:01 <lambdabot> ,(3,8),(3,9),(3,10),(4,6),(4,7),(4,8),(4,9),(4,10),(5,6),(5,7),(5,8),(5,9)
05:21:01 <lambdabot> ,(5,10)]
05:21:14 * xerox thinks
05:21:19 <Saulzar> lambdabot loves the monad instance for (->)
05:21:26 <xerox> What's the point in doing it?
05:21:53 <Cale> xerox: ap generalises liftM2, liftM3, etc.
05:22:10 <Lor> It's <*> in some parser combinator libraries.
05:22:36 <Lor> It's the primitive in that nifty class between monads and arrows.
05:22:42 <shapr> Saulzar: Maybe we should too?
05:22:47 <xerox> > return (,,) `ap` [1,2,3] `ap` [4,5,6] `ap` [7,8,9]
05:22:48 <lambdabot> [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(
05:22:48 <lambdabot> 2,4,7),(2,4,8),(2,4,9),(2,5,7),(2,5,8),(2,5,9),(2,6,7),(2,6,8),(2,6,9),(3,
05:22:48 <lambdabot> 4,7),(3,4,8),(3,4,9),(3,5,7),(3,5,8),(3,5,9),(3,6,7),(3,6,8),(3,6,9)]
05:22:53 * xerox stares blankly
05:22:54 <shapr> Lor: Conor's idioms?
05:22:54 <{Arias}> is better tu use (ap zip tail) or (\x -> zip x tail(x)) ?
05:23:06 <Cale> {Arias}: the latter, usually :)
05:23:10 <Lor> shapr, might be. I don't think he invented it, though.
05:23:13 <xerox> haha
05:23:22 <xerox> @type Control.Monad.ap zip tail
05:23:23 <lambdabot> forall a. (Monad ((->) [a])) => [a] -> [(a, a)]
05:23:24 <Cale> um
05:23:26 <Cale> however
05:23:34 <Cale> (\x -> zip x (tail x))
05:23:38 <Cale> you want taht
05:23:39 <Cale> that*
05:23:43 <xerox> ap x y = ?
05:23:59 <{Arias}> :P
05:24:10 <{Arias}> > (\x -> zip x tail(x)) [1,2,3]
05:24:11 <lambdabot>   The function `zip' is applied to three arguments,
05:24:11 <lambdabot>   but its type `[a] -> [b] -> [(a, b)]' has only two
05:24:11 <lambdabot>   In a lambda abstraction: \ x -> zip x tail (x)
05:24:21 <Lor> @type Monad.liftM ($)
05:24:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
05:24:31 <shapr> Hm, I had a great for porting House to an embedded system recently... what was it...
05:24:32 * xerox thinks
05:24:34 * shapr tries to remember.
05:24:38 <xerox> @type Control.monad.ap
05:24:39 <Cale> ap fs xs = do f <- fs; x <- xs; return (f x)
05:24:39 <lambdabot> Couldn't find qualified module.
05:24:39 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
05:24:39 <lambdabot> \\)?
05:24:40 <{Arias}> > (\x -> zip x (tailx)) [1,2,3]
05:24:41 <lambdabot>  Not in scope: `tailx'
05:24:45 <xerox> @type Control.Monad.ap
05:24:46 <{Arias}> arg
05:24:46 <{Arias}> > (\x -> zip x (tail x)) [1,2,3]
05:24:47 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
05:24:48 <lambdabot> [(1,2),(2,3)]
05:24:56 <Lor> @type Monad.liftM2 ($)
05:24:57 <lambdabot> forall b a2 (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
05:24:59 <xerox> Lor: so it's different?
05:25:00 <xerox> aaaah.
05:25:22 <Cale> exactly, it's lifted function application
05:25:35 <xerox> Mumble.
05:25:48 <xerox> Yes but how can one get a function inside a monad?
05:25:49 <Cale> ap fs xs = do f <- fs; x <- xs; return (f x) -- in case you missed it
05:26:12 <Cale> > [(+1), (*2)] [1,2,3]
05:26:13 <lambdabot>   The function `[(+ 1), (* 2)]' is applied to one arguments,
05:26:13 <lambdabot>   but its type `[a]' has none
05:26:13 <lambdabot>   In the definition of `duz': duz = [(+ 1), (* 2)] [1, 2, 3]
05:26:13 <int-e> is there a type class for (x :: * -> *) => x a -> x b -> x (a,b) ?
05:26:15 <Cale> > [(+1), (*2)] `ap` [1,2,3]
05:26:16 <lambdabot> [2,3,4,2,4,6]
05:26:37 <xerox> Man, this seems powerful.
05:26:41 <{Arias}> jajaj
05:26:55 <xerox> int-e: 'ZipFunctor' ? :D
05:27:25 <Lor> http://www.mail-archive.com/haskell@haskell.org/msg07011.html
05:27:42 <Lor> The type of ap is a better primitive.
05:28:36 <Lor> int-e's primitive plus fmap is equivalent to having lifted application
05:31:28 <Cale> http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
05:36:02 <blazold> lo
05:36:18 <Cale> inserting Applicative in between Functor and Monad in the prelude might be a good idea :)
05:36:39 <blazold> i wonder if you can help me once more :)?
05:36:44 <Cale> sure
05:36:48 <blazold> it is not about haskell for today
05:37:04 <blazold> it is prolog issue
05:37:04 <blazold> however
05:37:05 <blazold> it seems it can be close to your minds
05:37:09 <blazold> :)
05:37:19 <Cale> sure
05:37:43 <blazold> i was able to google something what is called "Symbolic Differentiation"
05:38:00 <blazold> however our task for today is reverse operation - antiderivation
05:38:14 <blazold> that's hard to find - or maybe i'm just using bad expressions to find it
05:39:03 <xerox> integration?
05:39:06 <blazold> i wonder if you know about some prolog server where one can find some examples on this that can be extended
05:39:10 <blazold> xerox: yup
05:39:11 <blazold> integration
05:39:49 <Cale> It's just finding an inverse to the operation of differentiation. That is, if D(f) = g, then I(g) = f + C, where C is sime constant.
05:39:51 <Cale> some*
05:40:06 <blazold> exactly 
05:40:20 <blazold> but some specials must be implemented
05:40:54 <xerox> 'sime' ?
05:41:03 <Cale> xerox: I corrected that
05:41:09 <xerox> Oh sorry.
05:42:03 <blazold> sime ? 
05:42:11 <Cale> <Cale> some*
05:42:29 <blazold> i mean xerox :)
05:42:31 <Cale> hehe
05:42:36 <int-e> Cale: http://haskell.org/hawiki/HaskellIrcPastePage <-- what do you think of this?
05:43:36 <Cale> int-e: hehe, nice :)
05:44:35 <blazold> so i've got this
05:44:35 <blazold> http://www.j-paine.org/prolog/mathnotes/files/symdiff.pl
05:44:51 <blazold> that's quite a good code to start with
05:44:51 <blazold> but there is no integration
05:46:03 <ski> instance (forall a. Show a => Show (f a)) => Show (Mu f)
05:46:11 <ski> 'd be nice if that worked
05:46:22 <shapr> Has anyone tried to run House on an AMD Geode?
05:46:26 * shapr has another crazy idea...
05:48:34 <shapr> Why doesn't bittorrent use something like Service Location Protocol?
05:50:42 <astrolabe> integration is a very difficult problem in general
05:51:01 <astrolabe> but it is easy to come up with rules
05:51:12 <astrolabe> they just won't be exhaustive
05:52:08 <astrolabe> for example, n/=0  =>  I(x^n) = x^(n+1) / (n+1)
05:54:16 <blazold> sure
05:54:22 <blazold> but real problems are
05:54:24 <astrolabe> I(a.f) = a.I(f),   I(f+g) = I(f)+I(g)
05:54:27 <blazold> in those nontrivial methods
05:54:36 <blazold> like per partes, substitution
05:54:48 <Cale> blazold: how much do you have to handle?
05:54:52 <astrolabe> there is a more general algorithm, hang on a mo.
05:55:00 <blazold> Cale: :)?
05:55:12 <blazold> Cale: as mcuh as possible ?
05:55:38 <blazold> i think all those elementary functions
05:55:44 <Cale> that differentiator doesn't quite work for me in swipl for some reason
05:55:45 <blazold> like sin/cos/ln
05:56:00 <Cale> but not necessarily composites of them?
05:56:17 <Cale> (we hope not anyway)
05:56:19 <astrolabe> http://en.wikipedia.org/wiki/Risch_algorithm
05:56:56 <Cale> The Risch decision procedure is not formally an algorithm because it requires an oracle that decides whether a constant expression is zero, a problem shown by Daniel Richardson to be undecidable. :)
05:57:07 <Cale> That's a nice comment :)
05:57:34 <blazold> ;))
05:58:19 <blazold> and also their combinations in polynoms etc.
05:58:50 <blazold> so something like  sin(x)*cos^2(x)/(x-sin(x))
05:58:56 <blazold> should be integrated
05:59:26 <astrolabe> I wish there were more papers available on the web.  I couldn't find a comprehensive description of Risch 
05:59:39 <astrolabe> algorithm, for example.
06:00:35 <astrolabe> Cale: are you familiar with that Laplace stuff?
06:00:39 <Cale> blazold: Mathematica can't do that one. Good luck.
06:00:43 <blazold> :))
06:00:54 <blazold> i'll try to write something based on that, and i'll talk to you later 
06:00:55 <blazold> cya for now
06:01:04 <Cale> blazold: just do polynomials first
06:01:10 <blazold> yup
06:01:10 <blazold> :)
06:01:21 <xerox> ...how does symdiff.pl work?
06:02:32 <xerox> Oh I see.
06:03:19 <Cale> xerox: Have you written prolog code before?
06:03:25 <xerox> A *little* bit.
06:03:30 <Cale> (or read it?)
06:03:37 <xerox> Yesterday for the very first time, heh.
06:03:44 <Cale> okay, so you know how everything is a relation
06:03:46 <blazold> btw: cale: just to make it working in SWI you need to replace "real" to "float"
06:03:56 <blazold> and then you get only few warnings on sinlgeton variables
06:03:57 <xerox> The execution model is still a bit awkward to understand for me.
06:03:57 <Cale> blazold: ah, yeah, I just commented that out
06:04:18 <Cale> xerox: It's a lot like the list monad.
06:04:52 <xerox> Hm.
06:05:09 <xerox> How do you input 'x^2' there?
06:05:16 <Cale> x^2.
06:05:27 <xerox> OK, great.
06:05:41 <xerox> Those end of the line dots are terrible... :)
06:06:27 <Cale> I suspect that you get used to it quickly.
06:07:16 <xerox> Cale: how would you write a "fuction" that doubles the elements of a list? :)
06:08:45 <xerox> > let twice xs = xs >>= ap (:) return in twice [1..5]
06:08:46 <lambdabot> [1,1,2,2,3,3,4,4,5,5]
06:08:52 <shapr> Hey, maybe the problem is that bittorrent trackers suck and should be using OpenSLP?
06:08:57 <xerox> In prolog, that is.
06:09:37 <shapr> Lunar^: Would JHC be easier to turn into the next hOp?
06:10:36 <Cale> xerox: a prolog list? Or doubles its nondeterministic input?
06:10:55 <ski> Cale : prolly first
06:11:27 <Cale> oh, doubles in that sense
06:12:14 <Lunar^> shapr: I asked John that question once
06:12:34 <JohnMeacham> shapr: it does have no runtime environment, which could help or hinder a hOp. on one hand you get to do everything in haskell, on the other you can't just port a C core.
06:12:46 <JohnMeacham> if hOp is what I think it is.
06:13:00 <Lunar^> JohnMeacham: right
06:15:04 <xerox> Cale: a prolog list I'd say
06:15:19 <xerox> Cale: though 'nondeterministic input' sounds.. cool?
06:15:52 * ski wonders if he should paste the 3 lines of doubled/2
06:16:49 <xerox> I've a 2 liners!
06:17:05 * ski likes to put body at own line
06:17:23 <xerox> Well, ok.  I still have some little problem with it's working but hey..
06:21:40 <tromp_> i don't see how ap (:) return is of type a -> m b
06:21:59 <ski> @type ap (:) return
06:22:00 <lambdabot> Not in scope: `ap'
06:22:09 <ski> @type Control.Monad.ap (:) return
06:22:10 <lambdabot> forall a. (Monad ((->) a)) => a -> [a]
06:22:47 <Cale> xerox: it's sort of the same thing as the functional implementation
06:22:53 <tromp_> so how is (:) of type m (a->b) ?
06:22:58 <Cale> double([], []).
06:23:03 <Cale> double([H|T], [H|[H|U]]) :- double(T,U).
06:23:28 <ski> [H|[H|U]] = [H,H|U]
06:23:46 <Cale> ski: ah, cool
06:24:43 <Cale> when you said "double" initially, I thought you meant numerically
06:25:20 <xerox> If I trace the expression
06:25:34 <xerox> I see it "consuming" the argument until reaching '[]'
06:25:46 <xerox> ...and then building up a list with the elements doubled 
06:26:04 * ski did a solution more similar to the list monad version
06:26:33 <xerox> Paste?
06:27:04 <ski> 8 lines (could be 2 or 3)
06:27:08 <ski> here ??
06:27:22 <xerox> Where do you prefer :D
06:28:00 <ski> doubled(Xs,XXs) :-
06:28:00 <ski>         findall(X
06:28:00 <ski>                ,(member(X,Xs),
06:28:00 <ski>                  ( true
06:28:00 <ski>                  ; true
06:28:01 <ski>                 ))
06:28:03 <ski>                ,XXs
06:28:05 <ski>                ).
06:28:31 <Cale> cute :)
06:28:40 <ski> this one "doubles" nondeterministically, then collects into a list
06:29:06 * xerox coughs
06:29:41 <ski> (though, of course, declaratively, one can't depend on this .. at least not in classical logic)
06:29:45 <Cale> Is findall primitive?
06:29:52 <ski> should be
06:30:03 <Cale> It would be interesting if it wasn't :)
06:30:09 <xerox> How does it work?
06:30:20 <ski> one can define it, with evil assert and stuff
06:30:36 * xerox skips the metaprolog discussions for now :)
06:30:58 <ski> xerox : try '?- member(X,[1,2,3]),(true ; true).'
06:31:05 <Cale> xerox: findall just collects all the solutions into a list
06:31:58 <xerox> X = 1
06:32:03 <xerox> Yes
06:32:08 <Cale> ;
06:32:12 <ski> xerox : you should press ';', not return
06:32:28 <xerox> uh.
06:32:46 <xerox> What does the (true; true) part mean?
06:33:03 <ski> what it says .. literally "true or true"
06:33:26 <xerox> Or!
06:33:41 <ski> yes
06:33:42 <xerox> Can one use 'or's in the arguments ?
06:33:55 <xerox> like foo(X;Y)
06:33:55 <ski> 'in the arguments' ??
06:34:04 <ski> that's syntax error, i think
06:34:40 <ski> there are two different commas in prolog .. one is in arguments .. the other is an infix operator, i.e., the 'and'
06:35:31 <xerox> I got that one
06:36:56 <xerox> Well, ok.
06:42:02 <shapr> JohnMeacham: I'd be fine with doing everything in Haskell.
06:42:59 <Saulzar> Hmm, at the low-low level there's some stuff which is required in assembler though, right?
06:43:14 <int-e> @pl fold (\s -> MuShow (\n -> showParen (n<1) $ shows s))
06:43:15 <lambdabot> fold (MuShow . flip (showParen . (< 1)) . shows)
06:46:07 <Saulzar> I'm sure there is at least some tiny code you'd have to write in assembler (maybe C is irrelavant)
06:48:27 <Saulzar> Also, you have to do various things like setting up heap allocation - if haskell expects to have one
06:49:28 <shapr> I'm okay with asm and Haskell.
07:00:07 <shapr> What's the easiest way to find the size of a file in Haskell?
07:01:13 <Lemmih> @type \f -> System.IO.openFile f System.IO.ReadMode >>= System.IO.hFileSize
07:01:15 <lambdabot> FilePath -> IO Integer
07:01:31 <shapr> No way I can ask posix or something like that?
07:02:30 <shapr> Well, that'll work for what I want to do.
07:03:10 <Lemmih> @type fmap System.Posix.Files.fileSize . System.Posix.Files.getFileStatus
07:03:12 <lambdabot> FilePath -> IO System.Posix.Types.FileOffset
07:03:19 <shapr> ah, nice
07:04:04 <shapr> thanks!
07:04:17 <Lemmih> What are you hacking, shapr?
07:04:28 <shapr> Just useful shell scripts actually.
07:04:45 <shapr> But rather than learning how to do it in zsh, I'd rather do it with Haskell.
07:07:10 <shapr> @index compareBy
07:07:10 <lambdabot> bzzt
07:07:16 <xerox> Heh?
07:09:52 <reductor> @pl foldr1 (\(x:xs) ys -> ys ++ map (+x) (xs++ys)) . tails
07:09:52 <lambdabot> foldr1 (ap ((ap (++) .) . (. (++)) . (.) . map . (+) . head) tail) .
07:09:52 <lambdabot> tails
07:10:35 <xerox> dot dot dot dot dot dot...
07:11:11 <mahogny> ok, reading up further on wxhaskell. hrm. when they say that it does not support threads, what exactly do they mean?
07:11:58 <mahogny> will it die a horrible death if I try to send data to a widget from another process?
07:13:52 <Lemmih> It's probably because wxWidgets isn't thread safe.
07:15:24 <mahogny> hm. ok. so if I manage to pass in the data through the back door (ie let a function called from wx read the data), I should be safe?
07:15:32 <mahogny> or is there a better way?
07:16:07 <Lemmih> You could avoid OS threads.
07:16:38 <mahogny> well. not really. I need them for a background process that must be run continuously
07:16:46 <mahogny> and does a lot of IO
07:17:26 <Lemmih> And you know for sure that Haskell threads won't cut it?
07:17:31 <Saulzar> The usual way is to use 1 thread to manage the gui toolkit and communicate with that
07:17:40 <mahogny> Lemmih, yes
07:17:46 <xerox> Haskell threads are *fast* .. aren't they?
07:17:49 <mahogny> Lemmih, blocking IO calls
07:18:35 <Philippa> they're RTS-implemented, if that's what you mean
07:18:55 <mahogny> yeah. normal haskell threads seems really nice
07:19:27 <Philippa> calling something that causes your OS thread to block sucks though
07:57:28 <blazold> re, really don't know what to do with substitution
08:00:54 <Philippa_> for those of us who weren't around earlier, want to explain what the problem is?
08:03:47 <tromp_> where is ((->) a) defined as a Monad?
08:04:30 <musasabi> Control.Monad.Reader I think
08:06:04 <tromp_> that defines Reader r as a Monad
08:06:18 <tromp_> > ap (:) return 0
08:06:19 <lambdabot> [0,0]
08:06:56 <tromp_> if i try that in ghci, i get  No instance for (Monad ((->) a))
08:07:45 <tromp_> so, how does lambdabot derive (Monad ((->) a)) ?
08:07:57 <Saulzar> Did you import the right module?
08:08:08 <Saulzar>  :module Control.Monad.Reader
08:08:29 <tromp_> ah, now it works
08:09:17 <esap> hmmm hit another ghc panic on my type checker.
08:09:59 <Pupeno> hello.
08:10:04 <roconnor> hmm, the haskell-cafe code to do modular arithmetic isn't very easy to use.
08:10:15 <roconnor> dependent types is not so easy to do in Haskell.
08:11:18 <Pupeno> musasabi: have you used any program to fabricate arbitrary DNS messages ? I need to do that to test my server and I can't find a way (I tried nemesis)
08:11:50 <tromp_> still, i don't see Monad ((->) r) anywhere in Control.Monad.Reader
08:12:05 <tromp_> i only see MonadReader r ((->) r)
08:16:19 <Philippa_> that'd imply Monad ((->) r), no?
08:16:34 <Philippa_> roconnor: no kidding :-(
08:17:09 <Philippa_> esap: look on the bright side. I started writing an article about monads and found my example code needed GADTs to compile
08:17:18 <Philippa_> *luckily* it's a simple usage with no typeclass work...
08:17:47 <Philippa_> ...so I should be able to get it past the readers OK (I tried it out on a friend who's not done any Haskell and last did an ML a few years back and had been drinking, so I /think/ it should work out ;-)
08:18:50 <esap> philippa: heh. That's very easy to do. Most of my designs actually require GADTs, because I have strong background in OOP, which means I always seem to write constraints in as strict way as possible.
08:19:23 <Philippa_> I don't have a "strong" OOP background, but I'm still inclined to do that when I've had the time to think it through anyway...
08:19:25 <araujo> Good morning.
08:20:03 <esap> philippa: OOP encourages exposing data dependencies to clients.
08:20:20 * Philippa_ nods
08:20:34 <Philippa_> well, OOP as taught at UoN mostly seems to encourage suicide, but I didn't say that ;-)
08:20:46 <esap> hehe
08:21:03 <Philippa_> it doesn't help that they're java-based and UML-based. And why the *fuck* bother with accessors in UML I don't know...
08:21:55 <esap> philippa: accessors are the OO way to enforcing invariants.
08:22:34 <Philippa_> yeah, I know. But given that fields come with accessors /anyway/, why can't we just annotate those and leave the explicitly named methods as implementation/translation details?
08:22:34 <musasabi> Pupeno: valid or invalid ones?
08:23:07 <esap> philippa: Because you don't want to expose the accessors that come with the fields, they expose too much.
08:23:07 * Philippa_ suspects she would've got on well with Self :-)
08:24:03 <esap> philippa: And the user-defined accessors are part of the interface.
08:24:08 <Philippa_> I guess that's true if you want interface and implementation type to be different in that regard
08:24:34 <roconnor> Pilippa_, I suppose I will just have to do things the normal way, with potential run-time errors.
08:24:44 <esap> philippa: it must be possible to change the data structure behind the interface at any time.
08:24:53 <roconnor> Although I probably can define interfaces that ought to prevent run-time errors.
08:25:05 <Philippa_> esap: sure. I like what Self gives you in that regard, you can effectively delegate the 'field' at any time anyway
08:25:34 <Philippa_> essentially, I don't think fields should be part of an interface /at all/ except insofar as accessors are exposed...
08:25:59 <Philippa_> ...at which point, the usual syntax for discussing that is somewhat clunky
08:26:17 <esap> phillippa: true. That's why you should define interfaces as totally abstract [only abstract methods]
08:26:37 * Philippa_ nods
08:27:15 <Philippa_> I wouldn't object at all to a standard piece of sugar that amounts to "accessors in these <> directions for this field-like thing" though. Or failing that, to the lot teaching our OOD course not making us fill in the bloody fields as well...
08:28:56 <esap> philippa: Java has such sugar via reflection, but it's a pretty awful kludge.
08:29:10 <Philippa_> it's not really Java I'm bitching about here, because if I start on /that/... ;-)
08:29:16 <Philippa_> it's overly Java-influenced teaching
08:29:19 * esap agrees fully.
08:29:53 <rep>           http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
08:29:58 <Philippa_> read it yesterday
08:30:05 <rep> oh ok :)
08:30:28 <Philippa_> UoN's a mostly-Java uni. We do get taught haskell in the first year, but nothing really comes of it
08:30:35 <Philippa_> we had to do our compilers module in Java in my year
08:31:15 <rep> UoN?
08:31:19 <Philippa_> Nottingham
08:31:26 <Philippa_> where I am
08:31:31 <rep> oic
08:31:40 <rep> we just got thought C++
08:31:43 <esap> When I had a compilers course, you could use any language you wanted [I did with C++]
08:31:52 <Philippa_> we only modified pre-existing code
08:31:54 <rep> but i hear they switched to java the year after i started
08:32:00 <Philippa_> believe me, I get very, very snarky about the visitor pattern now
08:32:07 <Philippa_> at least C++ has unions...
08:32:15 <musasabi> Java is just not suited for compilers.
08:32:23 <rep> unions are evil
08:32:32 <Philippa_> they're less evil than the visitor pattern
08:32:40 <esap> you can write compilers with Java as well. It's just matter of turning your thinking into OOP :-)
08:32:53 <Philippa_> IYTM "twisting" :-)
08:32:54 * esap 's compiler in the compiler course was in OOP style.
08:32:57 <Philippa_> er, ITYM even
08:33:06 * Philippa_ nods
08:33:18 <Philippa_> a lot of it can be. But I want disjoint unions for my AST thankyouverymuch
08:33:23 <musasabi> esap: only it is unnatural, cluttered and full of cut-and-paste code.
08:33:25 <mahogny> unions... I even prefer type casts before those
08:33:38 <esap> musasabi: My compiler wasn't.
08:33:41 <Philippa_> mahogny: when emulating a haskell datatype they're the best you'll get
08:33:46 <esap> musasabi: I had one object per language feature.
08:33:53 <esap> musasabi: s/object/class/
08:34:11 <mahogny> Philippa_, I usually go with the struct hack if I want to emulate inheritance/multiple constructors
08:34:20 <Philippa_> for what notion of 'language feature' and what kind of language?
08:34:26 <musasabi> esap: doesn't that make code cluttered or visitor-pattern madness?
08:34:32 <Philippa_> mahogny: that's exactly what I *don't* want to emulate
08:34:33 <esap> philippa: It was a pascal-like language.
08:34:50 <esap> musasabi: no, not necessarily.
08:34:53 <Philippa_> mmm, so language feature ~= syntactic construct?
08:35:07 <esap> musasabi: It's just a matter of how you design the interface to the class.
08:35:13 <Philippa_> and how much 'fancy' stuff did the compiler do?
08:35:29 <esap> philippa: well not quite, language feature included all phases in the compiler.
08:35:32 <Philippa_> (I guess I mean AST transformations or the moral equivalent)
08:35:51 <esap> philippa: except syntax actually, because it was so easy to use yacc....
08:35:54 <Philippa_> heh
08:36:04 <Philippa_> abstract-syntactic construct, then?
08:36:31 <esap> philippa: It was parse tree with OOP-like class hierarchy for different language constructs.
08:38:10 <musasabi> esap: how did you implement the various passes over the AST ?
08:38:33 <esap> musasabi: You can avoid the visitor stuff by not trying to differentiate the passes of the compiler too much. Just let the objects communicate with each other as is natural in OO
08:39:18 <Philippa_> esap: what I was getting at, yeah
08:39:58 <Philippa_> do you reckon it would've scaled to something akin to GHC?
08:40:03 <esap> musasabi: If you divide the problem in OOP way, you don't need the "compiler-passes" like division.
08:40:19 <Philippa_> how about the notion of optimisation passes though?
08:40:34 <pejo> Are you (indirectly) talking about the compiler book by Appel and Palsberg?
08:41:08 <esap> philippa: yes, it would have scaled. The difference is that with the OOP design, you can add new things to the language easily. But it's harder to change the structure of the compiler to include more passes.
08:41:08 <Philippa_> I'm not
08:41:15 * Philippa_ nods
08:41:19 <Philippa_> that figures
08:41:47 <esap> So OOP design works if the details of your language are not quite fixed.
08:41:47 <esap> ~
08:42:27 <esap> THe ordinary advice to anybody writing a compiler is that you should have the language fixed when you start :-) that doesn't need to be so at all, if you use OOP design for the compiler.
08:42:39 <Philippa_> I think the FP-style design's probably more effective if somewhere along the lines there's a significant desugaring pass?
08:43:28 <Philippa_> as in, if your new addition only needs to live for x 'passes', it's easier if those passes're functions rather than classes/interfaces?
08:44:03 <esap> in OOP design, that will cause that you have more than one full class hierarchy, with properties divided between the hierarchies. It's not too good to have parallel class hierarchies with conversion between them.
08:44:59 <esap> Or at minimum, the division between them must be _very_ clear from the start.
08:45:46 <esap> For my current compiler, I'm doing mixed functional and OOP design. with type checking and syntax being handled in OOP way, and separate language features handled OOP way.
08:46:08 <esap> sorry, type checking and syntax handled in functional way.
08:47:29 * esap uses Haskell and arrows for the OOP stuff.
08:50:18 <esap> Here's an example of an OO-like module: http://www.kotiposti.net/epulkkin/ControlOperation.txt
08:54:52 <ski> OO in what sense ?
08:55:19 <esap> in the sense of how the program is divided into modules.
08:55:53 <esap> OO is about dividing program into modules in a particular way.
08:56:16 <ibid> (that's one possible characterization of OO:)
08:56:28 <esap> true.
08:56:47 <Philippa_> I tend to use it in a 'there's some sense of message passing' kind of way these days
08:57:04 <Philippa_> how you construct the object-like things is up to you, it might well be done in a more functional manner
08:57:06 <esap> I wouldn't refer to message passing when defining OO, because it's widely misunderstood.
08:57:20 * Philippa_ nods
08:57:30 <Philippa_> especially if you've never encountered Smalltalk, Self or the likes
08:57:33 <esap> OO message passing is not the same as message passing in functional side.
08:57:50 <Philippa_> explain?
08:57:55 <Philippa_> (what constitutes functional message passing?)
08:58:32 <esap> I mean, in Actor model of computation, there is a concept of message passing. That's not the same as what's used in smalltalk, as far as I can tell.
08:58:51 * esap doesn't know smalltalk well though
08:59:05 <Philippa_> you could get close in smalltalk, the concurrency's an issue though
08:59:16 <Philippa_> in smalltalk it's possible to change what class an object belongs to on the fly...
08:59:26 <ibid> my friend and coworker who i regard as an oo guru refuses to define oo. the best i've been able to get him cough up is this, paraphrased:
08:59:51 <ibid> 1) object-oriented programming is *object*-oriented programming. note *object*, not *class*
08:59:58 <esap> In my opinion, OO doesn't extend to designs where you have concurrency. The largest part of run-time environment of OO design is the run-time stack.
09:00:04 <ibid> 2) an object has identity, state and behaviour
09:00:06 <ibid> (thazzit)
09:00:19 <Philippa_> esap: I find that... misguided
09:00:38 <Philippa_> ibid: that's pretty much where I stand on it, give or take the method of talking an object into doing stuff
09:00:40 <tromp_> > return (0:return 0) 0
09:00:42 <lambdabot> [0,0]
09:01:06 <Philippa_> esap: the reason I find it misguided is it makes it impossible to apply OOD techniques to a system in the middle of eg a pile of business processes - 'cos where's the call stack out in the real world?
09:01:26 <ibid> (i don't know what to make of him having turned into a LISP and CLOS nut recently)
09:01:32 <esap> philippa: It's in the design. Layers are very much OO concept.
09:01:52 <esap> philippa: And layers are basically just a representation of a type of the run-time call stack
09:01:53 <Philippa_> ibid: I've borrowed useful ideas from the lispish side of OO in the past
09:02:39 <Philippa_> esap: that makes about as much 'real' sense as claiming the World -> World function tells you useful things about what the real world does
09:02:44 <Philippa_> it's great for internal work, useless for external
09:03:01 <ibid> i just love it that the world can be represented in zero bits :)
09:03:08 <Philippa_> heh
09:03:16 <Philippa_> but only if your computer exists in it ;-)
09:03:20 <musasabi> Is Erlang OO ?
09:03:24 <ski> esap : so that module is OO-like in how you've separated it from other parts of the program ?
09:03:27 <tennin> I'm pretty much a philistine in my attitude to OOP, or at least the OO features in mainstream languages --- to me they're just a way to lump some data and functions together
09:03:28 <esap> musasabi: No
09:03:37 <tennin> is that wrong?
09:03:37 <Philippa_> musasabi: "not directly" is how I'd put it. You can do very OO-like things in it
09:03:38 <esap> ski: yes.
09:03:39 <musasabi> Because erlang is all about message passing.
09:03:49 <musasabi> between components which have state.
09:03:50 <Philippa_> tennin: That's a very C++ish view of it
09:04:08 <Philippa_> OTOH, that's mainstream languages for you
09:04:18 <esap> musasabi: erlang is all about the Actor model of computation, which is as far from OOP as you can get.
09:04:31 <Philippa_> IMO they gut half the good bits of OO in favour of applying some crap attempts at static typing
09:04:37 <Philippa_> esap: from /your/ view of OOP
09:04:39 <ski> (esap : so, to appreciate the OO-ness, one'd need to see the other parts (or at least a description of the structuring ..), yes ?)
09:04:40 <tuomov> an OO-language is a language that encourages writing things in OO-style. OO can be done even in assembler.
09:04:44 <Philippa_> I suspect Alan Kay views it differently, for example
09:05:28 <esap> Ok, my view of OO is very much static typing view to OO, in the sense that I think OOA and OOD find the classes (not objects) from the model of the external world.
09:05:36 <ibid> well, alan kay is the person whose main claim to fame is that he's the one who incorrectly claims to have invented OO ;)
09:05:42 <musasabi> esap: it is about what is defined as OO
09:05:52 <ibid> (that's the scandinavian POV. i'm sure the american POV is different)
09:06:32 <ibid> (hmm, can i add a few more indirections in that sentence?)
09:06:38 <Philippa_> ibid: I think it's mostly other people claim he did. There's some acknowledgement of Simula influences at the least
09:06:55 <esap> ski: well probably true. What I usually use to find which parts of programs were designed in which way is to look at file names. If the file names are singular substantives, then it's OO.
09:06:59 <_Codex> I thought OO is just variant of 2nd order logic. :)
09:07:09 <esap> codex: huh?
09:07:20 <ibid> Philippa_: yeah, i think his claim is to have invented the *word*
09:07:34 <ski> esap : heh
09:07:34 <ibid> Philippa_: but never let truth get in the way of a good story ;)
09:08:07 <ski> (esap : like Data.List.hs ?)
09:08:12 <Philippa_> _Codex: Implement Smalltalk in it and find out ;-)
09:08:49 <Philippa_> esap: if it has client code it's not OO? ;-)
09:09:05 <ibid> Philippa_: there's a wonderful quote from kay that says something like, 'when i came up with OO, C++ was *not* what i had in mind'
09:09:17 <Philippa_> heh
09:09:23 <esap> Philippa: well if it has client code, then probably the client code is not in OO
09:09:47 <ibid> of course, stroustrup would agree, as his influence came from simula, not smalltalk :)
09:10:02 <esap> philippa: I suppose you can write client code in OO way as well, but its purpose it then completely different than the purpose of client code normally.
09:10:23 <Philippa_> would you say the same of the client of an Int class? ;-)
09:10:43 <esap> philippa: Int is not a class
09:10:51 <palomer> Num is a class
09:11:02 <Philippa_> esap: in Haskell
09:11:23 <javed> hi guys
09:11:23 <palomer> why are generalised algebraic datatypes sometimes called guarded datatypes?
09:11:35 <Philippa_> if there's no language in which it is then there's sure one in which something closely synonymous is - Smalltalk, for one
09:11:36 <esap> philippa: ah, there is a difference between those examples.
09:11:41 <javed> HI shapr 
09:11:55 <esap> philippa: because "client" of an int can be designed in OO way or in functional way.
09:11:58 <SamB> Int and Integer don't really mean the same thing
09:12:00 <Philippa_> palomer: some of the constructors have guards on what type they'll be
09:12:16 <Philippa_> SamB: in Haskell. I did say "closely synonymous" for a reason
09:12:29 <SamB> well, even other places.
09:12:39 <esap> philippa: You must look at largest border of the module to see which way it's designed.
09:12:45 <esap> philippa: not the smallest.
09:12:51 <ski> hi javed
09:12:56 <javed> HI ski 
09:12:59 <javed> WHATZ UP
09:13:01 <SamB> How often do you see Int meaning an arbitrary integer?
09:13:12 <javed> I AM LOOKIN FOR FRIENDS FOR THIS CHANNEL
09:13:13 <esap> philippa: just saying "it's a client of Int", looks at just one part of the client module, not the whole of it.
09:13:14 <Philippa_> SamB: not very, it's more likely to be int than Int
09:13:30 <Philippa_> javed: DON'T SHOUT AT US THEN!
09:13:39 <SamB> javed: we are very friendly, its true
09:13:46 <Philippa_> esap: does Data.List count as an "OO style" module?
09:13:54 <Philippa_> Given that it defines a datatype and a pile of operations on it?
09:14:08 <SamB> we should get an award. but unfortunately I don't think there are awards for friendly IRC channels for programming langauges...
09:14:11 <samx> while we're talking OO.. Anyone tried out 'beta' / any thoughts on it? It seems pretty different from any other OO language I've tried
09:14:15 <palomer> Philippa_: for example?
09:14:19 <tennin> I'm OK with the purely expedient use of "OO" features in C++, but Java seems like an attempt to take that approach and give it some kind of true OO purity it can never have
09:14:29 <SamB> whats beta?
09:14:39 <javed> thayks SamB 
09:14:47 <samx> http://www.daimi.au.dk/~beta/
09:14:48 <ski> palomer : hm, maybe because one can rephrase e.g. 'data Foo a where Con :: Foo Bool; ...' into something like 'data Foo a = Con with a = Bool | ...' ?
09:14:48 <esap> philippa: no, not quite, because the representation of the list datatype is not hidden.
09:15:15 <esap> philippa: you can use the constructors, so it's not a abstract datatype.
09:15:25 <Philippa_> suppose it were possible to export abstract constructors for the purpose of pattern-matching and it did so, would that count?
09:15:33 <ibid> beta is in a sense a successor of simula
09:15:34 <SamB> esap: you can't even hide things in Self...
09:15:40 <Philippa_> Only there're plenty of objects out there that expose their internals due to being so simple there's no damn point
09:15:58 <palomer> ski: so we're only allowed equality constraints?
09:16:13 <samx> samb, kristen nygaard is mentioned as one of the authors, so yes, it has some relation to simula
09:16:20 <esap> philippa: in OO design, encapsulation of private representation of the data types is essential.
09:16:29 <esap> philippa: It prevents changing the representation
09:16:36 <esap> philippa: s/prevents/allows/
09:16:42 <MarcWeber> Looking at the get definition of the State Monad (Control.Monad.State.hs) I wonder what get = State $ \s -> (s,s) means. Especially I don't understand the "State $" here.
09:16:43 <Philippa_> esap: that's a principle of good design rather than a principal of being-an-object though
09:17:00 <esap> philippa: it's a principle of good OO design.
09:17:01 <SamB> esap: you are silly
09:17:20 <SamB> esap: observe the lack of hiding facilities in Self, Python, Slate... Lisp...
09:17:46 <Philippa_> Lisp being, y'know, the first ISO-standardised OO language
09:18:00 <ski> MarcWeber : means same as 'get = State (\s -> (s,s))'
09:18:12 <esap> Ok, the problem why none of those have hiding facilities, is because they have no type system.
09:18:20 <ski> MarcWeber : '$' is an infix operator, allowing to use less parens
09:18:22 <SamB> of course, Lisp's package system is probably a bad example :-(
09:18:25 <esap> The hiding facilities are related to static typing of OO
09:18:30 <MarcWeber> ski: Why is "State" needed?
09:18:55 <SamB> MarcWeber: because State is a newtype?
09:19:35 <SamB> which has the same representation as another datatype, but is not the same type?
09:19:47 <ski> (MarcWeber : if it was 'type State s a = s -> (a,s)' then the constructor wouldn't be needed .. but one can't make typesynonyms into class instances)
09:20:00 * Philippa_ laughs
09:20:07 <Philippa_> I ran into that yesterday building some example code for an article :-)
09:20:18 <MarcWeber> SamB: Thanks. I have forgotten that extra boxing of the runState function..
09:20:20 <SamB> esap: static typing?
09:20:20 <esap> The hiding and encapsulation are *compile-time* parts of OO. For Lisp, there is no compile-time where such checks could be done. So no support for encapsulation.
09:20:33 <SamB> there is a compile time!
09:20:41 <palomer> eh? can't you do that with macros?
09:20:45 <Philippa_> luckily it's the only thing that stops the intermediate module compiling (I transform an 'interpreted' state monad into the traditional implementation via an unboxed version like you're doing)
09:20:58 <esap> SamB: Well ok, but the CLOS doesn't use it for checking.
09:21:01 <Philippa_> SamB: there's a read time. There's no guarantee of a compile time
09:21:14 <ski> Philippa_ : restricted type-synonyms would be nice, here ..
09:21:18 <SamB> Philippa_: well. okay. so there is only a compile time when you actually compile...
09:21:20 <SamB> that is true!
09:21:49 <SamB> and I will be the first to say that there are so many potential times it is confusing...
09:22:14 <esap> I do think static typing is essential safeguard for writing OO programs. Otherwise, OO code could not place constraints on the client code.
09:22:39 <flux__> hmm.. so there are there no untyped oo-languages that support data hiding? I hadn't noticed that before..
09:22:47 <javed> hey guys
09:22:55 <javed> any tutorial about the perl lang ?
09:23:03 <javed> i need tutorials
09:23:11 <javed> for some programming skills
09:23:18 <Philippa_> flux__: there probably are somewhere, but usually it's given up in favour of reflection
09:23:20 <SamB> well. librep supports black-boxing
09:23:35 <SamB> I dunno if it has OO though
09:23:37 <ski> (Philippa_ : 'type State s a = s -> (a,s) in get,set,returnS,bindS; instance Monad (State s) where {return = returnS; (>>=) = bindS}; get :: State s s; get s = (s,s); ...')
09:24:20 <ski> javed : maybe you should also in #perl, if you're looking for perl tutorials ?
09:24:32 <ski> @learn
09:24:33 <lambdabot> http://www.haskell.org/learning.html
09:24:36 <javed> okay
09:24:39 <javed> hi lambdabot 
09:24:42 <ski> that's tutorials for haskell
09:24:44 <SamB> javed: you could try our sister channel #perl6
09:24:54 <javed> your sister ?
09:25:16 <SamB> their program Pugs is written in Haskell
09:25:58 <integral> there is also #perl where perl5 is on topic (which it isn't in #perl6 really)
09:26:28 <SamB> so?
09:27:22 <Philippa_> normally if someone just asks about perl I assume they mean perl5
09:28:39 <SamB> I meant about perl5 being offtopic in #perl6 ;-)
09:29:52 <javed> i dont know perl5, perl6
09:30:42 <SamB> perl5 is the one that kinda works
09:30:47 <SamB> perl6 not so much
09:30:53 <Philippa_> perl6 is the 'next version' that's still under development
09:30:59 <Philippa_> if all you want is to learn perl, you want to learn perl5
09:31:00 <SamB> also perl5 is the one everyone uses ;-)
09:33:48 <mahogny> perl... the language in which you can fuck up in the way you prefer most. how does perl compare to python? they seem to be rather much in the same cathegory
09:34:39 <Philippa_> nah, perl OO's a much bigger hack
09:34:39 <javed> yes they same 
09:35:16 <SamB> Philippa_: well. maybe you haven't seen Python's metaclasses up-close and dirty?
09:35:34 <Philippa_> close enough to understand
09:35:49 <Philippa_> but at least Python has a language-level notion of class
09:36:03 <mahogny> perl did indeed get OO later on. I only used perl before it got any classes
09:36:14 <Philippa_> er, no it didn't
09:36:21 <Philippa_> it got treating hashes as method lookup tables
09:36:27 <mahogny> well, yeah
09:36:46 <mahogny> python seems much tidier at least
09:36:52 <mahogny> except it got feature creep
09:37:22 <SamB> classes are overrated ;-)
09:37:28 <mahogny> indeed
09:37:58 * esap is writing a library for Haskell for being able to write classes in Haskell.
09:38:10 <xerox> Classes O_o ?
09:38:14 <xerox> Don't we have classes?
09:38:21 <Philippa_> we have typeclasses
09:38:25 <mahogny> worst is that ppl nowadays think OOP is about classes. the same ppl also wrote up a lab for the students in which the classes had circular dependencies and could not be split (and when I ask why not one file, they respond OOP)
09:38:25 <musasabi> OO is nice, but OO-classes are evil.
09:38:26 <esap> typeclass != OO class
09:38:30 <xerox> Ah, THOSE classes.
09:38:46 <Philippa_> mahogny: oh FFS
09:38:48 <xerox> I don't miss them.  But sounds like a cool project.
09:39:14 <sieni> esap: not satisfied with oohaskell?
09:39:35 <esap> sieni: no
09:39:46 <xerox> ...it gives you... objects, right?
09:40:01 <_roconnor> @where nshm
09:40:02 <lambdabot> I know nothing about nshm.
09:40:38 <mahogny> Philippa_, when you say FFS, I assume you do not refer to BSD somehow? :)
09:40:45 <Philippa_> mahogny: right :-)
09:40:51 <mahogny> (ie dunno acronym)
09:41:37 <neologism> ffs as in fast fourier somethign? :)
09:42:02 <mahogny> that's fft :)
09:42:06 <Philippa_> neologism: that's almost as obscene ;-)
09:42:06 <xerox> stransformate
09:42:50 <david> what's the most needed libraries for haskell right now?
09:43:14 <neologism> mahogny: s for something
09:43:32 <Philippa_> david: depends who you talk to
09:43:39 <mahogny> neologism, hmm. acronym finder gives me "41 meanings" of which none seem to fit lol
09:43:43 <Philippa_> good CGI or general web libs are still WIP
09:43:44 <david> philippa, so what do you think? 
09:43:49 <Philippa_> as are database interface libs
09:43:56 <Philippa_> GUI's starting to get there
09:44:08 <Pupeno> musasabi: both, but I am interested in valid ones now.
09:44:21 <Pupeno> (re: generating DNS packets)
09:44:41 <david> philippa, right
09:45:32 <mahogny> while we are in on GUIs, I can add that wx probably can play well with multiple threads though. when they say it isn't threadsafe, they only mean you can only run one instance
09:46:04 <Philippa_> erm, I wouldn't want to be making wx calls from other OS threads either
09:46:05 <mahogny> (now just to find the haskell function that wraps the right C function that I found :P)
09:46:40 <mahogny> well. it seems wx has no trouble with it in C so if I do it the same way (as they recomend) I think it should be ok
09:46:55 <mahogny> there are quite some restrictions on how to do it though
09:47:10 <musasabi> Pupeno: just add a generator for queries and do a loop of serialize/deserialize for them.
09:47:25 <Philippa_> having 'quite some restrictions' doesn't count as threadsafe IMO
09:47:33 <Philippa_> threadsafe is "you can't fuck it up even if you try"
09:47:42 <Pupeno> musasabi: a generator ?
09:48:07 <mahogny> well, true there. being a C library, "safe" has a very broad meaning :) 
09:48:14 <SamB> what sort of restrictions?
09:48:32 <mahogny> you can pass events to the GUI from other threads if you use the right functions
09:48:48 <mahogny> that way it will only execute in the right thread, but you can still feed it data from everywhere
09:49:05 <Philippa_> that'd be a relief insofar as it'd stop the idle loop hack
09:49:20 <SamB> events?
09:49:25 <Philippa_> OTOH, I'm using gtk2hs anyway these days
09:49:27 <musasabi> Pupeno: a function generating a sequence of pseudorandom dns packets.
09:49:44 <Philippa_> SamB: wx events. As can be handled by the main loop and dispatched to code within that thread
09:49:50 <mahogny> yeah. polling with no timer is completely inacceptable
09:50:00 <mahogny> even with a timer it can be discussed
09:50:20 <Philippa_> with a timer still stinks IMO
09:50:23 <Pupeno> musasabi: I see.
09:50:24 <mahogny> yup
09:50:36 <Philippa_> if your OS doesn't like doing much finer than a few tens of milliseconds it really stinks
09:50:49 <SamB> and I still wish it would work properly with GHCi...
09:51:45 <Philippa_> remind me what the problem is? It probably works better if you fork out the GUI thread rather than the local one
09:52:05 <Philippa_> (but then you have to have forked out something that'll let you build a system on top of it - almost as if you were doing the hs-plugins thing
09:52:06 <Philippa_> )
09:52:07 <SamB> the problem is that readline blocks
09:52:13 <mahogny> well, communication is in both directions so it doesn't really matter which thread does what
09:52:24 <Pupeno> musasabi: that would show that serialization and de-serialization is consistent, but it wouldn't show if it is consisntent with the protocol.
09:52:32 <mahogny> I have a networking library and other weird stuff going on in the other thread
09:53:06 <musasabi> Pupeno: ah. I just went through my own code and made certain it worked.
09:53:08 <Philippa_> mahogny: it does for ghci
09:53:20 <Philippa_> as ghci /won't run in a forked-off thread/
09:53:21 <mahogny> Philippa_, oh? well, I only use GHC right now
09:53:59 <Pupeno> musasabi: I wouldn't be sure untill I tried it, once (I'll do the testing you told me, but I need more, like generating a package with two questions)
09:54:52 <musasabi> Pupeno: I think many servers kept dropping things with multiple questions.
09:55:10 <Pupeno> musasabi: what do you mean ?
09:55:21 <musasabi> Pupeno: at least the question decoding code that my code has is much more strict than the spec.
09:55:34 <musasabi> Pupeno: most realworld servers don't conform the RFC.
09:55:40 <musasabi> +to
09:55:50 <Pupeno> really ? oh...
09:56:01 <mahogny> btw, is anyone up to date about subturing languages?
09:56:17 <_roconnor> mahogany, what do you mean?
09:56:30 <mahogny> _roconnor, languages for which termination is decidable
09:56:48 <_roconnor> I suppose I know something on the subject.
09:56:52 * Pupeno would like to not conform to the compression part. musasabi, I know you implemented it cleanly, but I still couldn't understand your code completely and I am doing things a bit different, since my goal is different.
09:56:53 <musasabi> no general recursion is a good start.
09:57:25 <mahogny> well, I might need one at some point so I just wonder, how flexible are the state-of-the-art ones?
09:57:34 <musasabi> Pupeno: BIND sends the answers compressed so you have to implement decompression.
09:57:53 <musasabi> on the send side compression is a free choice.
09:57:59 <Pupeno> musasabi: yes, I guess so.
09:58:02 <_roconnor> mahogny, they can do everything you'd ever want to do, except interpret themselves.
09:58:42 <_roconnor> proving termination can be a pain in the ass at times.
09:58:47 <mahogny> _roconnor, well, I know what the can't do. but what can they do? print hello world? :)
09:58:54 <_roconnor> But as long as you know the loop varient, you are pretty much set.
09:59:03 <_roconnor> oh
09:59:04 <Philippa_> Epigram can't print hello world yet AFAIK, which is sad
09:59:12 <Philippa_> but there are, er, reasons for that
09:59:22 <_roconnor> Well, I've only used languages that don't really do IO.
09:59:22 <Philippa_> what it *can* do is a hell of a lot, and prove many properties about said hell of a lot
09:59:46 <Philippa_> IO tends to screw up the more interesting properties
09:59:52 <musasabi> designing a simple terminating language with IO is simple,
09:59:53 <mahogny> epigram eh. ok. should look into that one. I don't think I need anything fancy but it would be nice to know the limits
10:00:03 <Philippa_> musasabi: only if none of the IO blocks
10:00:21 <_roconnor> Epigram isn't a sound logic.  I supsect that general recursion is definable.
10:00:39 <musasabi> Philippa_: one just has to define IO with suitable definitions.
10:00:41 <mahogny> "The epigram is the most condensed and concentrated form of poetry ..." <-- link on google. I can't agree less ;)
10:00:44 <_roconnor> although maybe it is a big pain in the ass to do general recrusion in epigram.
10:00:52 <Philippa_> that's a "we couldn't be arsed to pick our chosen solution yet" thing though, I believe that's something they intend to change at some point
10:01:07 <musasabi> general recursion makes termination proofs harder.
10:01:24 <Philippa_> they were looking at a general recursion monad though
10:01:30 <_roconnor> heh
10:01:56 <_roconnor> mahogny, I use Coq for my subturing language of choice.
10:02:12 <mahogny> hm. ok
10:06:47 <_roconnor> There is also Agda(sp?)
10:06:57 <_roconnor> although it may suffer from the same problems as epigram.
10:09:04 <mahogny> has anything.. hrm. remotely useful been written in these languages yet?
10:09:38 <_roconnor> probably.
10:10:00 <_roconnor> Code written in Coq can be exported to Haskell, Ocaml, and scheme.
10:10:30 <_roconnor> The biggest problem is that the Coq definition of integers is exported, rather than using the language integers.
10:10:54 <_roconnor> But exporting polymorphic functions over datatypes would be reasonable.
10:11:05 <palomer> why do people use coq?
10:12:01 <_roconnor> Because the Coq system is the only way to get whatever that eurpean level 4 secrurity thing is.
10:12:08 <_roconnor> the only current way.
10:12:28 <_roconnor> Anyhow, Coq has dependent types!
10:12:47 <palomer> does coq have recursion?
10:12:57 <_roconnor> Coq only has structural recursion.
10:13:10 <_roconnor> (and co-recursion)
10:13:12 <palomer> but, like, what kind of invariants can you define in coq?
10:13:29 <_roconnor> Basically any type of invariant.
10:13:43 <_roconnor> If you can state it in math, you can state it in Coq (more or less)
10:14:00 <palomer> so you can do more than just term equalities?
10:14:07 <_roconnor> yes
10:14:12 <palomer> have an example?
10:14:36 <_roconnor> I believe red-black trees are in the standard library.  I'll have a peek.
10:14:44 <lennart_> palomer: anything in *constructive( predicate calculus
10:15:03 <lennart_> (constructive) is what I meant to type
10:15:56 <lennart_> Well, kinda, since they use a particular variant.
10:16:17 <palomer> lennart_ = _roconnor?
10:16:33 <lennart_> Not as far as I know. :)
10:16:46 <palomer> you typed something before?
10:16:52 <_roconnor> oh, red-black trees are in the user-contribs
10:17:00 <_roconnor> http://coq.inria.fr/contribs-eng.html
10:17:14 <_roconnor> http://coq.inria.fr/contribs/FSets.html
10:17:21 <lennart_> They have done some very impressive stuff in Coq.
10:17:36 <icb> http://img43.imagevenue.com/img.php?loc=loc73&image=9f006_photo4.jpg
10:17:44 <_roconnor> I assume they enforce the red-black condition in their data structure.
10:17:47 <_roconnor> ... But I suppose I haven't looked.
10:18:34 <SamB> apparantly you can do red-black trees in GADTs also.
10:18:34 <SamB> sortof.
10:18:47 <lennart_> Or even with just H-M
10:19:05 <_roconnor> @what H-M
10:19:06 <lambdabot> I know nothing about h-m.
10:19:11 <palomer> but, erm, what predicates are allowed in the language of types?
10:19:17 <SamB> lennart_: how do you enforce the constraints that way?
10:19:41 <Philippa_> "messily", I'm guessing?
10:19:48 <Philippa_> a separate type for Red and Black?
10:19:50 <_roconnor> let me find the data stucture.
10:19:51 <palomer> can't red-black be reduced to term equalities?
10:19:51 <lisppaste2> Pupeno pasted "what do you prefeer ?" at http://paste.lisp.org/display/15192
10:19:54 <lennart_> Chris Okasaki has a paper with red-black trees in pretty standard Hinley-Milner.
10:20:07 <Philippa_> does it enforce the variants?
10:20:14 <SamB> well, of course you can write them
10:20:14 <Philippa_> er, invariants even?
10:20:15 <Pupeno> What of the two definition do you normally prefeer ? (the helper function are not used anywhere else).
10:20:19 <SamB> Philippa_: invariants?
10:20:23 <SamB> hehe
10:20:30 <lennart_> palomer: Coq has universal quantification on the type level.
10:20:33 <Philippa_> my brain isn't working too well :-)
10:21:01 <Pupeno> In scheme I would use the first without hesitating.
10:21:05 <palomer> lennart_: sure
10:21:10 <palomer> so does AF_2
10:21:30 <_roconnor> oh, p**, they doen't enforce the red-black contition in their data type.
10:21:39 <ski> Pupeno : isn't it more readable if you use 'where' instead of 'let', there ?
10:22:15 <Pupeno> ski: Maybe, maybe not. I haven't used where once since I am programming on Haskell, but this might be a good chance.
10:22:19 <lennart_> palomer: And then you can define your own predicates on the type level.  I'm not sure what you are after.
10:22:29 <_roconnor> Oh, can you do red-black trees in the H-M system?
10:22:59 <lennart_> Equality is not built in in Coq.
10:23:40 <palomer> erm, let's get back to the equality on integers example
10:24:27 <palomer> btw, I proved to myself that if you can find a term for forall a. (leftBin==)(a,a) ,then == is indeed reflexive
10:24:31 <_roconnor> http://coq.inria.fr/library/Coq.Sorting.Sorting.html
10:24:37 <_roconnor> A simile example for a sorted list.
10:24:52 <_roconnor> simple
10:24:56 <lisppaste2> ski annotated #15192 with "'where'" at http://paste.lisp.org/display/15192#1
10:25:01 <_roconnor> Inductive lelistA (a:A) : list A -> Prop :=
10:25:01 <_roconnor>   | nil_leA : lelistA a nil
10:25:02 <_roconnor>   | cons_leA : forall (b:A) (l:list A), leA a b -> lelistA a (b :: l).
10:25:18 <_roconnor> bah
10:25:19 <palomer> the sorted example can be done with forall a. (sorted(sort(a)) = T)
10:25:24 <_roconnor> that's not what I want either.
10:26:01 <lennart_> palomer: sorting is more than wht you just said
10:26:09 <palomer> oh, good point
10:26:23 <_roconnor> palomer, I expect most data structures will have such a formula to validate it
10:26:24 <lennart_> unless your predicates mean more than I think
10:26:29 <_Codex> How is equality usually handled in the languages? Can I do x^2+y^2<r^2 and get circle type out of it?
10:26:41 <palomer> forall a. (sorted (sort (a))=T and sameMultiplicity(sort(a),a) = T)
10:26:42 <_roconnor> However, the Coq type system will enforce such things.
10:28:42 <ski> (sameMultiplicity ?)
10:29:22 <palomer> ski: sameMultiplicity(a,b) returns true if a,b contain the same elements
10:29:41 <palomer> (and same multiplicities)
10:30:20 <lisppaste2> _roconnor pasted "Coq dependent type" at http://paste.lisp.org/display/15193
10:30:38 <palomer> _roconnor: lelistA is a list of elements which are less than or equal?
10:30:39 <_roconnor> Complete is my type for trees with all nodes at level n or n-1.
10:30:53 <ski> (palomer : ah ..)
10:31:20 * ski thinks he'd call it something with 'permutation'
10:31:29 <xerox> Is |~[n] <- getArgs| supposed to protect from empty/more than 1 arguments?
10:32:19 <palomer> but, yeah, I'd like to see an invariant in coq which is not definable in terms of term equalities
10:32:29 <xerox> ...or is it the other way around?
10:32:57 <_roconnor> palomer, that will be difficult to come up with perhaps.
10:33:07 <ski> xerox : that will fail when forcing 'n', if not exactly one arg
10:33:15 <_roconnor> Probably requires something beyond ground type objects.
10:33:23 <xerox> ski: but it doesn't seem to work that way
10:34:22 <rep> ski wrong
10:34:24 <rep> #
10:34:25 <rep> # Matching the pattern ~apat against a value v always succeeds. The free variables in apat are bound to the appropriate values if matching apat against v would otherwise succeed, and to _|_ if matching apat against v fails or diverges. (Binding does not imply evaluation.)
10:34:28 <ski> hm
10:34:54 <palomer> greatest fixed point: exists a. (f(a) = a ^ forall b. (f(b)=b -> a >= b))))
10:34:56 <_roconnor> Where are term equalities used?
10:35:11 <palomer> proving that a function has a greatest fixed point must be annoying as hell!
10:35:39 <ski> rep : wasn't that what i said ?
10:35:40 <palomer> _roconnor: = is term equality
10:35:43 <Lemmih> rep: Isn't that exactly what ski said?
10:35:57 <rep> well
10:36:04 <rep> it depends what he means by "fail"
10:36:09 <_roconnor> palomer, if I understand correctly selecting the greatest fixpoint tends to be easier the the least fixed point.
10:36:27 <ski> > let ~[x] = "" in x
10:36:28 <lambdabot>  Irrefutable pattern failed for pattern [x]
10:36:31 <ski> > let ~[x] = "ab" in x
10:36:32 <lambdabot>  Irrefutable pattern failed for pattern [x]
10:36:35 <ski> > let ~[x] = "a" in x
10:36:36 <lambdabot> 'a'
10:36:46 <ski> > let ~[x] = "" in ()
10:36:48 <lambdabot> ()
10:36:51 <_roconnor> palomer, I understand = is a term equality, but why are you intersted in examples that are not describable by term equalities?
10:37:01 <ski> hm
10:37:15 <ski> > (\~[x] -> ()) ""
10:37:16 <lambdabot>  parse error on input `->'
10:37:22 <ski> > (\(~[x]) -> ()) ""
10:37:24 <lambdabot> ()
10:37:30 <_roconnor> That would probably require a term where well-formedness is semi-decidable.
10:37:36 <palomer> _roconnor: just wondering if coq has other interesting predicates with their own deductive rules
10:38:28 <ski> so .. forcing the var will match the pattern, which possibly can fail
10:38:33 <Pupeno> How do I turn an "IO String" into a "IO Label" where "newtype Label = Label String" ?
10:38:37 <palomer> does anyone have the specification for sorting in coq?
10:38:47 <ski> Pupeno : liftM Label
10:38:55 <_roconnor> Although I haven't done it, I believe I can make a predicate that holds for all true sentences of the first order theory of the natural numbers.
10:38:56 <palomer> @type liftM
10:38:57 <lambdabot> Not in scope: `liftM'
10:39:03 <xerox> @type Control.Monad.liftM
10:39:04 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
10:39:06 <xerox> @type Control.Monad.liftM2
10:39:07 <lambdabot> forall r (m :: * -> *) a2 a1.
10:39:07 <lambdabot> (Monad m) =>
10:39:07 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:39:17 <ski> liftM = fmap, for Monads
10:39:33 <palomer> _roconnor: I'd very much like to see it
10:39:44 <_roconnor> lelistA, is the predicate.
10:39:48 <palomer> @type fmap
10:39:50 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
10:39:55 <_roconnor> I thought it was the data structure at first.
10:39:59 <_roconnor> but it is the predicate.
10:40:04 <palomer> isn't Monad a subclass of Functor?
10:40:30 <_roconnor> The predicate says that the empty list is sorted.
10:40:32 <Pupeno> thanks.
10:40:53 <_roconnor> and that if (b:l) is sorted, and a <= b, then (a:b:l) is sorted.
10:40:57 <ski> palomer : some of us thinks it should
10:41:17 <_roconnor> oh wait
10:41:23 <_roconnor> never mind, I'm totally wrong.
10:41:25 <xerox> @type fmap (+1) (return 1 :: IO Int)
10:41:27 <lambdabot> IO Int
10:41:34 <xerox> I wonder how's it implemented :-)
10:41:45 <ski> xerox : which ?
10:42:02 <palomer> | cons_leA : forall (b:A) (l:list A), leA a b -> lelistA a (b :: l) <--shouldn't this be  | cons_leA : forall (b:A) (l:list A), leA a b -> lelistA a (cons_leA (b,l)) ? 
10:42:19 <xerox> ski: IO instance
10:42:24 <ski> liftM/fmap f ma = do a <- ma; return (f a)
10:42:27 <_roconnor> http://coq.inria.fr/library/Coq.Sorting.Sorting.html#sort
10:42:39 <_roconnor> That is the sorted list predicate.
10:43:26 <_roconnor> the empty list is sorted, and if a is <= to all elements of l, then a:l is sorted.
10:43:58 <palomer> leListA (h1::h2::t) says that h1 <= h2, right? (and nothing more)
10:44:33 <_roconnor> sorry, (leListA a l) means that a <= x for all x in l.
10:44:42 <_roconnor> (although it isn't defined that way)
10:45:16 <palomer> i have to admit, I don't like lelistA
10:45:33 <palomer> (furthermore, I like my specifications to be as close as to how I would write them)
10:45:39 <_roconnor> It is defined as (leList a nil) holds, and if a <=b and (leList a l) holds, then (leList a (b:l)) holds.
10:45:53 <palomer> oh
10:46:01 <_roconnor> er no
10:46:03 <_roconnor> sigh
10:46:12 <_roconnor> It is defined as (leList a nil) holds, and if a <=b holds, then (leList a (b:l)) holds.
10:46:16 <_roconnor> hmm
10:46:19 <palomer> yeah, that makes sense
10:46:46 <_roconnor> that is a bizarre definition.
10:47:12 <palomer> oh, it is bizarre
10:47:12 <_roconnor> okay, so I don't really understand leListA.
10:47:15 <palomer> could be a bug
10:47:19 <_roconnor> so I don't really understand sort.
10:47:27 <palomer> probably is a bug
10:48:04 <palomer> still, I don't think inductive definitions are always the best way to describe things
10:48:49 <_roconnor> I more or less agree with you.
10:48:53 <esap> Hmm. If my algorithm pattern matches several existentially-bound objects that each have the same constraint and I attempt to use a function via the constraint, how does the compiler resolve, which actual instance to use?
10:49:04 <palomer> (in fact, for lelist, coinductive would be best) lelist (h1:h2:t) -> h1 < h2 and lelist (h2:t)
10:50:09 <ski> esap : how can they have the same constraint ?
10:50:11 <palomer> in fact, you could probably do  better with higher order pattern matching
10:50:54 <_roconnor> palmomer, you forgot about nil.
10:51:04 <palomer> nil: trivial
10:51:04 <palomer> :OP
10:51:10 <_roconnor> and the single element list.
10:51:14 <esap> ski: My code is pretty complicated, let me paste it to the paste page, hold on.
10:53:09 <palomer> does coq have infinite lists?
10:54:02 <esap> ski: http://www.kotiposti.net/epulkkin/TTypeCheck.txt see function tyCheckObject, and the recursive call to itself in it.
10:54:09 <palomer> coq specifications should be more readable:O!
10:54:12 <palomer> anyways, bbl
10:54:56 <esap> ski: this code causes ghc panic due to the recursive call line.
10:55:56 <esap> ski: The pattern matches for STFunctor and STModule both have the same constraint.
10:56:17 <esap> ski: And the STModule constructor requires it.
10:56:39 <ski> STModule, STObject and SObject is defined how ?
10:57:55 <esap> ski: http://www.kotiposti.net/epulkkin/TTree.txt has it. basically just existential wrapping over a complicated datatype.
10:58:09 <esap> ski: STObject :: (ModuleCtx cat,TypeCtx t) => TObject cat t -> STObject
10:58:18 <esap> ski: GADTs.
10:58:24 <ski> m
10:59:18 <esap> ski: Similarly for STModule: data STModule where { STModule :: (ModuleCtx cat) => TModule cat -> STModule }
11:01:03 <ski> tyCheckObject (STModule fdom')
11:01:10 <ski> is that the problematic call ?
11:01:13 <esap> yes.
11:02:47 <esap> I think the call to STModule attempts to find the constraint somewhere, and finds two different places, and can't decide which one to choose; or something like that.
11:03:02 <ski> hm
11:03:08 <ski> STObject arg' <- tyCheckObject (STModule fdom') -<< arg
11:03:30 <ski> the trouble is that "fdom'" and "arg" is not compatible
11:03:50 <esap> what do you mean not compatible?
11:04:17 <ski> you get "f" and "arg" from "sobj" .. a common source
11:05:04 <ski> then you transform "f" into "f'" (and extract "fdom'","fcod'")
11:05:29 <ski> and the way you do this transformation loses the compatibility
11:05:45 <ski> since you get back a new wrapped object which you unwrap
11:06:08 <ski> STFunctor f' <- tyCheckFunctor fdom fcod -<< f
11:06:38 <esap> hmm.. ok, perhaps I should use the cat argument to tyCheckObject to deduce the argument to STModule.
11:06:49 <ski> you must ensure 'tyCheckFunctor' keep the compatibility between the tyvars
11:07:00 <ski> so, it can't return a wrapped object
11:07:15 <ski> if you must wrap, then wrap the whole arrow, not the result of the arrow
11:08:10 <ski> hm, right, you don't use 'cat' there at all
11:08:43 <ski> 'deduce the argument to STModule' ?
11:09:32 <esap> ski: I can compute the value of the category where the recursive call should be made by inversely applying the functor to the result category.
11:10:00 <esap> ski: this is supposed to be a type checking routine for Objects in a category.
11:10:12 <esap> ski: and the functor application part of that.
11:10:47 <esap> ski: so if I have a functor application F A, the recursive call is how to check for validity of A. 
11:11:05 <esap> ski: it has to be made in different category than the F A itself.
11:11:25 <ski> anyway .. every time you unwrap an existential data constructor, you get basically a new fresh tyvar, not known to be same as any other type, and thus noncompatible with anything but itself
11:11:53 <esap> ski: I have a mechanism ("is_equal_type") where I can check for equality of the tyvars.
11:11:59 <esap> ski: at run-time.
11:12:15 <ski> ok .. that could work
11:12:53 <esap> ski: I do need to have the existential wrapping, because the origin of the data is from user input, and I can't have compile-time constraints on user input.
11:12:55 <ski> your 'tyCheckFunctor' call is anyway losing compatibleness
11:12:56 <glasser> is there no Maybe version of !! ?
11:13:22 <ski> @hoogle [a] -> Int -> Maybe a
11:13:24 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
11:13:35 <ski> mh..
11:13:43 <xerox> heh
11:14:17 <glasser> that's not really it
11:14:29 <ski> esap : i'm saying .. possibly you can change how you wrap .. further out in some way
11:16:17 <esap> ski: I was thinking that maybe the context e.g. the argument to tyCheckObject, could be directly the underlying type. But in that case, these functions have pretty strange type, since the result type would have none of the same type variables as the input. Which to me sounds strange.
11:16:29 <ski> @type \as i -> case drop i as of [] -> Nothing; a : _ -> Just a
11:16:30 <lambdabot> forall a. [a] -> Int -> Maybe a
11:18:14 <ski> esap : you need to share tyvars between input and output of 'tyCheckFunctor' (and maybe other of your arrows, too) (or maybe it could be done with judicious use of your 'is_equal_type' plus some kind of coercion)
11:19:50 <esap> ski: the is_equal_type + coercion is what I'm using right now.
11:20:34 <esap> ski: But I do need the existential wrapping there.
11:21:24 <musasabi> esap: how do you make existential wrapping without adding layers of it?
11:22:14 <esap> musasabi: what do you mean layers?
11:22:42 <musasabi> esap: basically when one has a functions like: "foo :: Foo a => a -> Something else -> ExistentialFoo" and then passes it an ExistentialFoo it gets wrapped twice.
11:23:38 <esap> musasabi: I don't have functions like that. I have functions like: foo : ExistentialFoo -> Something else -> ExistentialBar
11:24:34 <musasabi> mmh, that makes things simpler.
11:24:56 <esap> musasabi: So each function unwraps the existential wrapping, adds some data to it, and produces another existentially wrapped object.
11:25:10 <musasabi> usually I have wanted to support both the existential and the monotypic cases.
11:26:05 <ski> esap : is it the case that the existential tyvar in the input of 'tyCheckFunctor' should always be same as the ditto in the output ?
11:26:06 <esap> musasabi: this is a type checker of a compiler, where I'm using GADTs to check for consistency of the compiler itself.
11:26:43 <esap> ski: well they may have dependencies there, but it's not as simple as that.
11:27:05 <esap> ski: because this is a type checker, and it may need to compute with the types.
11:28:01 <esap> ski: tyCheckFunctor is not nearly ready, it can't be that simple.
11:28:14 <esap> ski: it only handles Identity functor case currently.
11:28:50 <musasabi> esap: sounds quite nifty.
11:29:42 <esap> this attempts to implement category theory, it should be nifty :-)
11:30:08 <ski> ok .. i would try making tyCheckFunctor polymorphic in the tyvar (i.e. handling unwrapped stuff, then) .. but maybe this doesn't work in your case
11:30:38 <ski> for what reason did you want wrapping there ?
11:30:58 <esap> It's possible I can get the two SModule arguments to be not existentially wrapped. But SFunctor is from syntax tree and has no type variables [and I can't add].
11:31:59 <esap> ski: the wrapping is because I have two trees, one with type information and another without. The type checker attempts to go from the untyped to typed.
11:32:21 <esap> ski: in the untyped case, I can't have any free type variables.
11:32:53 <ski> those trees have differing types, yes ?
11:33:39 <esap> ski: yes. The typed tree has lots of type variables that describe the environment of each node of the tree. I existentially quantify over those type variables.
11:34:31 <esap> ski: The type variables are used for checking the type checker via GADTs.
11:35:29 <esap> ski: so in effect, I must prove that my type checker actually can find the type of the environment of each node of the tree. This ensures minimum correctness for the type checker.
11:36:16 <esap> ski: the constraints are described in the http://www.kotiposti.net/epulkkin/TTree.txt file (that's the typed tree)
11:38:18 <esap> ski: And http://www.kotiposti.net/epulkkin/TSynTree.txt is the untyped tree.
11:38:39 <esap> both are unfinished (obviously :-)
11:38:59 <palomer> is the standard Term GADT example, eval is typed as forall a. eval (Term a) -> a, right?
11:39:04 <palomer> err
11:39:11 <esap> yes
11:39:16 <palomer> eval:: forall a. (Term a) -> a
11:39:42 <ski> esap : i still don't get why you wrap ..
11:39:52 <palomer> so if I have a data Color = Pink or Blue
11:40:03 <palomer> then eval :: (Term Color) -> Color
11:40:21 <esap> ski: The type checker functions can't have free type variables in their return type.
11:40:37 <esap> ski: that are not in their parameter types.
11:40:49 <palomer> which, of course, is nonsensical
11:41:22 <esap> ski: And I can't get all type variables in the domain.
11:41:33 <ski> esap : hmhm
11:41:53 <ski> esap : why ?
11:42:18 <esap> ski: because the syntax tree doesn't have free type variables, since it's untyped tree.
11:42:55 <esap> ski: and I don't want to try to enforce my type checking rules on the syntax.
11:42:56 <ski> esap : but i thought this module handled the typed one ..
11:43:28 <esap> ski: yes. the one with GADTs with type variables is the typed tree.
11:43:36 <esap> ski: but the TSynTree one is untyped.
11:44:52 <ski> ah, so SObject is untyped, while STObject is typed, then ?
11:45:08 * ski 's beginning to see the structure, hethinks
11:45:15 <esap> ski: yes, STObject is existential wrapping for the typed TObject
11:45:25 <ski> yes
11:45:34 <ski> but SObject is untypesd
11:45:37 <ski> s/s//
11:45:39 <esap> ski: yes.
11:46:47 <ski> hmm ..
11:47:44 <ski> what's type of 'functor_signature' ?
11:48:37 <esap> ski: TFunctor f dom cod -> (TModule dom, TModule cod)
11:50:15 <ski> you're sure the line
11:50:17 <ski> STObject arg' <- tyCheckObject (STModule fdom') -<< arg
11:50:20 <ski> is the prob ?
11:50:39 <ski> (e.g. have you tried replacing the lines after with undefined ..)
11:50:44 <esap> If I change it to STObject arg' <- undefined -<< undefined, it will compile :-)
11:51:30 <esap> interesting, though, with GHCi, my current code compiles as well. But with ghc, it panics.
11:51:38 <ski> hrm
11:51:40 <ski> bad
11:53:14 <esap> The exact message is "ghc-6.4.1: panic! (the 'impossible' happened, GHC version 6.4.1): cgPanic ; zddModuleCtx{v a4rW} ; static binds for: .... 
11:53:37 <esap> I think the message refers to ModuleCtx, which is one of my classes that are existentially quantified.
11:54:11 <esap> the one that STModule requires.
11:54:52 <ski> hm .. i don't rn see any prob in 'tyCheckObject' (after i cleared out that 'SObject' is untyped)
11:55:13 <ski> maybe this is just a plain compiler bug ?
11:55:41 <ski> you could try reproducing the error, with smaller example
11:55:42 <esap> I haven't yet tried your suggestion to compute the category using the context information ('cat' variable in tyCheckObject)
11:56:09 * ski is not sure he suggested that, but sure :)
11:56:17 <esap> hehe..
11:56:46 <esap> good idea anyway :-)
11:59:17 <ski> "cat" shoudl match "fcod'" in some way, is that right ?
11:59:44 <esap> yes. I haven't done that part of checking yet.
12:01:45 <ski> hm .. i keep wanting to share a tyvar between the 'STModule' argument and the 'STObject' output
12:02:24 <esap> yes, the link should be there.
12:04:07 <ski> hm, what's 'typeCxt' ?
12:05:10 <esap> TypeCtx is a class that contains common functions for all types.
12:05:40 <esap> Currently, it basically contains a mechanism to print the type.
12:05:53 <ski> esap : @type object_change_category
12:06:53 <esap> ski: object_change_category :: EqType cat cat' -> TObject cat t -> TObject cat' t
12:07:00 <ski> ok
12:07:26 <ski> tyCheckObject' :: ModuleCtx cat => TModule cat -> TChkA SObject (exists t. TypeCtx t *> TObject cat t)
12:07:40 <ski> maybe you want something more like this ?
12:08:05 <esap> yes, I think that's what it is.
12:08:45 <ski> btw, this could be a good reason to want first-class 'exists' .. i.e. to not have to conjure up so many auxillary wrappers
12:08:59 <ski> (also for readability)
12:09:25 <esap> yea. It doesn't bother me, since I know my own naming convention.
12:10:04 <esap> but for other people, it would make it much more easier to read.
12:10:54 * Philippa_ wonders if anyone's studied interactions between type inference and exists yet
12:11:04 <Philippa_> I *suspect* the sane answer is to just never, ever infer an existential type
12:11:59 <Lor> Why would you need to?
12:12:13 <esap> well I wouldn't go quite as far. Maybe infer only based on explicit declaration.
12:12:21 <Lor> Then it isn't inference. :)
12:12:45 <esap> I mean, if you have declaration at top-level, you can infer the types of everything within the function.
12:13:01 <Lor> A concrete type should be usable wherever an existential type is, so there shouldn't be any reason to implicitly pack anything.
12:13:14 <esap> or more like propagate the types into the function.
12:13:16 <ski> Philippa_ : i suspect one can infer them, when subexpressions already have them .. i.e. preserve them
12:13:34 <Lor> Argument types probably can be implicitly existentialized at top-level.
12:13:36 <Philippa_> not the same thing ;-)
12:13:43 <Lor> If the alternative would be to have _a -types.
12:14:07 <Philippa_> the only implicit packing I could see would happen when passing a type in anyway (typeclasses/dictionaries)
12:14:27 <Philippa_> ski: I'd expect retaining the information to work for the same reason it does with universals
12:14:47 <esap> Maybe implicit packing could occur, if the codomain would have universal type variable that is not present in domain.
12:15:00 <ski> (Philippa_ : it'd be an inferred type, that contained existentials .. though the existentials wasn't constructed by the inference of this expr here)
12:15:12 <Philippa_> yeah, I know
12:15:43 <ski> Lor : 'argument types' ? .. 'implicitly existentialized at top-level' ?
12:15:46 <Philippa_> but I don't think of that as 'inferring' an existential type, it's inferring that a known type is used
12:16:04 <SamB> propagating an existential type
12:16:09 <Philippa_> exactly
12:16:10 <ski> Philippa_ : indeed
12:16:18 <Lor> ski, I mean, what do you do with ungeneralized type variables at the end of inference?
12:16:41 <Philippa_> er, remind me which stage is 'generalisation'?
12:16:46 <ski> esap : hm .. ?
12:17:25 <Philippa_> my knowledge of inference algorithms is, er, hackish
12:18:13 <ski> Lor : well . i think some MLs instantiate them to dummy empty abstract types (i.e. basically skolems or top-level-existentials :) .. and some defer the instantiation ..
12:18:20 <Lor> # let r = ref [];;
12:18:20 <Lor> val r : '_a list ref = {contents = []}
12:18:30 <esap> ski: Think of show . read.
12:18:49 <esap> ski: Does the type in middle have universal or existential type?
12:18:54 <esap> ski: what type should it have?
12:19:03 <ski> Philippa_ : generalization is with let-polymorphism, when you all-quantify the unconstrained tyvars in the type
12:19:12 <Philippa_> ski: ah, thought so
12:19:50 <ski> Lor : yes, that's the 'defer' way, yes ?
12:20:16 <Lor> Yeah.
12:20:30 <Lor> They just leave the tyvars as they are.
12:20:35 <ski> esap : i think possibly the answer is no
12:20:43 <ski> right
12:21:07 <ski> esap : hmm ..
12:21:53 <esap> ski: if you'd have read :: String -> (exists a.a), then show . read could work, but it would have to be decided in read, what type the result has, at run-time.
12:22:05 <ski> esap : universal, i think .. since 'read' wants input to determine which type to read
12:22:33 <ski> esap : that'd be a different 'read' from the current one
12:22:35 <esap> ski: but currently, read :: forall a. String -> a, which means show . read must give a compile-time error.
12:22:56 <ski> esap : possibly it'd work in raw core
12:23:15 <Philippa_> core'd have to have existentials as well, right?
12:23:25 <ski> esap : i.e. you explicitely pass in which dict to use
12:23:30 <esap> yes.
12:24:19 <ski> anyway 'String -> (exists a. a)' is useless, anyway ..
12:24:42 <ski> you'd want at least something like 'readShowable :: String -> (exists a. Show a *> a)'
12:24:44 <esap> well, ok, I forgot the constraint on 'a'.
12:26:58 <esap> hmm.. even that is pretty useless :-)
12:27:20 <esap> you'd want some type of conversion function in that constraint.
12:28:58 <ski> Typable ?
12:29:12 <ski> maybe something like Clean's Dynamic ?
12:29:19 <esap> yea, something like that.
12:29:40 <ski> hm ..
12:30:12 <esap> otherwise it becomes way too hard to prove that the result value has the specified type [you can check for it at run-time, of course, but if there are many alternatives, it becomes hopeless effort]
12:30:25 <ski> that string would have to include an encoding of the type as well, btw .. so can't use same string as with 'read' and 'show'
12:31:10 <ski> consider 'data Unit = U; instance Show Unit where show = "()"'
12:32:22 <ski> well, using this 'read' variant .. one must in some way know what possible types to expect (if only by knowing they must be same as some other type)
12:33:12 <esap> yes, of course. What you'd normally do is, you check for each supported type separately, and reject the input if none of them matched.
12:33:22 <ski> dynApply :: Dynamic Dynamic -> Dynamic
12:33:24 <ski> dynApply (f :: a -> b) (x :: a) = dynamic f x
12:33:49 <ski> dynApply' :: Dynamic Dynamic -> b
12:33:50 <ski> dynApply' (f :: a -> b) (x :: a) = f x
12:34:06 <esap> Dynamic Dynamic?
12:34:20 <ski> Clean notation for curried (not really) functions
12:34:40 <esap> ah ok, I don't know Clean.
12:35:20 <ski> so, note that you can check two run-time-read types against each other .. and you can check a run-tim-read type against a polymorphic type arg ('b' in second example)
12:35:56 <esap> what happens if the types do not match? error?
12:36:03 <ski> match failure, yes
12:36:19 <esap> why isn't the error visible in the type?
12:36:32 <ski> first checks that inner type of second arg is same as domain of inner type of first arg (which must be a function type) .. the result of the application is then repackaged
12:36:40 <ski> s/first/first example/
12:37:27 <ski> second checks that inner type of second arg is same as domain of inner type of first arg (which must be a function type) .. and also checks that codomain of inner type of first arg is same as statically expected result type of whole application  (result is not rewrapped)
12:37:58 <ski> both those are partial functions .. to have total functions, one should wrap 'Maybe' around the result
12:38:17 <ski> (or handle the failure in some other case, in some way)
12:38:55 * esap likes total functions.
12:39:05 <ski> yes
12:39:27 <ski> wrote partial above just to get across how one could use the matching
12:39:37 <esap> ok
12:39:42 <ski> i.e. one doesn't have to match against known types
12:44:05 <Heffalump> hi
12:44:44 <droundy> Hello!
12:51:03 <droundy> Any idea where I can find the logs of this channel? tunes.org seems to be down...
12:51:38 <musasabi> google cache maybe?
12:52:59 <SamB> yes, tunes.org is quite down.
12:53:31 <SamB> apparantly bespin has been flakey lately and finally flaked out...
12:55:35 <Heffalump> so are no logs being kept?
12:56:04 <SamB> good question!
12:56:06 <SamB> clog: help
12:56:52 <SamB> we should add logging to lambdabot ;-)
12:57:16 <ski> (esap : http://www.cs.ru.nl/~clean/CleanExtra/report20/chapter8/index.html .. specifically 8.2 for matching)
12:58:23 <arjanb> there are also logs at: http://meme.b9.com/cview.html?channel=haskell&date=051230
13:01:04 <esap> ski: I can practically speaking do all the same kind of checks with existential types with Haskell pattern matching, the syntax is just not quite as convenient.
13:02:22 <esap> ski: And equality tests between two existentially typed values has to use separate mechanism based on the EqType stuff.
13:02:39 <esap> ski: But run-time checks nonetheless.
13:16:51 <ski> esap : yes
13:17:16 <palomer> hrm
13:17:27 <palomer> I still don't get why eval should be type Term a -> a
13:17:33 <palomer> s/type/typed
13:17:55 <palomer> I mean, shouldn't that mean that we could type eval as Term Colour -> Colour?
13:18:20 <basti_> we could
13:18:20 <basti_> yes
13:18:23 <esap> palomer: you do not want to restrict your eval funtion to work only on colors?
13:18:24 <basti_> if we gave a Term Colour
13:19:43 <palomer> but, erm, eval has already been defined
13:20:43 <esap> already defined?
13:20:51 <palomer> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
13:21:01 <esap> right.
13:21:32 <palomer> so a = Colour is a possible instantiation
13:21:37 <basti_> so?
13:21:44 <palomer> but it isn't!
13:21:48 <basti_> huh?
13:21:52 <palomer> eval::Term Colour -> Colour
13:21:58 <palomer> there are no colour terms!
13:21:59 <basti_> ???
13:22:12 <esap> The thing is, the example evaluator doesn't have any terms for constructing Color values.
13:22:16 <palomer> there's a restriction on a
13:22:19 <basti_> well, then, obviously, you can't instantiate a=Colour?
13:22:23 <basti_> no there isn't
13:22:26 <esap> But nobody prevents you from adding one.
13:22:27 <basti_> thats what we're saying
13:22:53 <basti_> ...in case you WANT one
13:22:55 <basti_> but why bother?
13:23:07 <palomer> if a::forall a. P then a::P[t/a] for any type t, does everyone agree?
13:23:20 <palomer> so eval::Term Colour -> Colour
13:23:24 <basti_> yea
13:23:32 <basti_> "you can instantiate eval with Colour = a"
13:23:37 <basti_> nobody will stop you
13:24:13 <palomer> oh, but it's impossible to create an element of Term Colour
13:24:15 <palomer> hrmphrm
13:24:23 <basti_> no why?
13:24:24 <carp> it becomes a function that takes elements of an empty type as input
13:24:34 <basti_> if you have a type Color, then you can create a Term Colour
13:24:36 <esap> having a specialized eval function with type Term Color -> Color doesn't mean it need to be useful
13:24:44 <palomer> basti_: you can? how?
13:25:02 <esap> undefined :: Term Color
13:25:09 <palomer> oh, that darn undefined
13:25:09 <basti_> for example
13:25:18 <basti_> but also, your datatype might allow it
13:25:31 <palomer> basti_: we're talking about a specific datatype
13:25:38 <palomer> basti_: http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
13:25:49 <basti_> palomer: so?
13:25:57 <palomer> Term certainly does not allow it
13:26:07 <basti_> do we know this?
13:26:11 <basti_> in the type system?
13:26:26 <palomer> we have the definition of Term
13:26:28 <basti_> would we want to introduce a general rule to forbid types that are not possible?
13:26:36 <basti_> we'd have to decide which types are possible
13:26:55 <palomer> so Term Colour has a single inhabitant?
13:27:05 <basti_> at least one.
13:27:12 <esap> you can build more inhabitants from existing ones.
13:27:23 <palomer> esap: for example?
13:27:39 <basti_> but even if it hadn't for now, would we be able to decide that it isnt possible?
13:27:53 <esap> Pair (undefined :: Term Color) (undefined :: Term Color) :: Term (Color,Color)
13:28:14 <esap> Pair   :: Term a -> Term b -> Term (a,b)
13:28:16 <palomer> basti_: in a hypothetical type system?
13:28:18 * carp thinks inductive families are less weird that gadts
13:28:28 <basti_> palomer: yea. certainly not haskell's.
13:28:34 <basti_> since haskell's doesnt make that decision
13:28:42 <palomer> esap: yeah, but I'm interested in inhabitants of Term Colour
13:29:00 <basti_> palomer: he gave one
13:29:02 <palomer> basti_: you could put the restriction that types have to be intuitionistically provable
13:29:10 <palomer> basti_: and I asked for others
13:29:11 <basti_> maybe.
13:29:24 <basti_> <esap> Pair (undefined :: Term Color) (undefined :: Term Color) :: Term (Color,Color)
13:29:25 <esap> ah, hmm. ok If (IsZero (Lit 1)) (undefined :: Term Color) (undefined :: Term Color)
13:29:28 <basti_> ^ there
13:30:00 <palomer> esap: isn't that just undefined?
13:30:07 <basti_> undefined :: a
13:30:17 <esap> palomer: Not before you evaluate it.
13:30:18 <palomer> basti_: that's an inhabitant of Term (Colour, Colour)
13:30:26 <basti_> yes it is
13:30:42 <basti_> > undefined :: [Int]
13:30:43 <lambdabot> Undefined
13:30:44 <palomer> basti_: I'm interested in inhabitants of Term Colour
13:30:51 <basti_> its even an inhabitant of [Int]
13:31:06 <palomer> esap: isn't there equality between values (which is not syntactic)?
13:31:07 <esap> palomer: it just constructs a data structure using the 'If', 'IsZero', etc. constructors.'
13:31:19 <palomer> If is a constructor?
13:31:25 <basti_> palomer: try in your code: "undefined :: Term Colour"
13:31:25 <esap> palomer: yes.
13:31:27 <basti_> does it break?
13:31:38 <palomer> basti_: does it break what?
13:31:45 <basti_> is it a type error?
13:31:45 <esap> palomer: defined by the data definition of "Term a" 
13:31:50 <basti_> or does it compile?
13:31:52 <glasser> @t undefined
13:31:53 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
13:31:53 <lambdabot> null topic-snoc topic-tail topic-tell type .
13:31:57 <basti_> @type undefined
13:31:58 <palomer> esap: I always thought if was simply a function
13:31:58 <lambdabot> forall a. a
13:31:59 <esap> palomer: constructor names generally start with upper case letter.
13:32:19 <esap> palomer: it's not (just) a function, because you can pattern match with constructors.
13:32:35 <palomer> esap: for example?
13:32:55 <palomer> basti_: it compiles
13:32:55 <esap> palomer: look at the definition of 'eval' from the page you cited.
13:33:03 <palomer> basti_: yes, I understand that undefined is in forall a.a
13:33:09 <basti_> palomer: so, is undefined an inhabitant of "Term Colour"?
13:33:43 <palomer> if x y z = case x of True -> y False -> z
13:33:49 <palomer> basti_: yes!
13:33:55 <basti_> whats the problem then?
13:33:56 <basti_> ^^
13:34:03 <palomer> basti_: we've moved on!
13:34:12 <palomer> we're looking for other inhabitants
13:34:25 <basti_> esap gave a different one
13:34:38 <palomer> and I'm trying to see why it's different
13:34:50 <palomer> it looks semantically equal to me
13:34:53 <basti_> well you can match away the outermost constructor without breaking
13:34:57 <palomer> esap: the if in eval pattern matches?
13:34:58 <basti_> "semantics" is a null-term
13:35:09 <palomer> a null-term?
13:35:18 <basti_> it doesn't convey meaning.
13:35:19 <esap> palomer: no, the part before '=' sign in parenthesis
13:35:29 <basti_> try the same sentence without "semantically"
13:35:59 <basti_> so, they are not the same, since you can match against the outermost constructor of that larger value
13:36:00 <palomer> esap: oh, If
13:36:03 <basti_> it won't break
13:36:04 <esap> palomer: eval (Lit i) = i.   The "Lit i"  uses the constructor Lit to pattern match and bind 'i'.
13:36:08 <palomer> sorry, my bad
13:36:47 <palomer> esap: yes yes, I see your point
13:37:11 <palomer> if we never use undefined in our code, is it still possible to have a value of type _|_ ?
13:37:25 <palomer> (is _|_ a value?)
13:37:32 <ndm> anyone know anything about Clean?
13:37:52 <esap> palomer: yes it is (there is a value 'error :: [Char] -> a'. And all kinds of infinite loops can also do that.
13:38:02 <ndm> I'm specifically interested in the abc-bytecode of Clean, but unfortunately can't find anything (googling is nearly useless for terms like clean and abc!)
13:38:36 <esap> palomer: let x = x in x  for example will evaluate to _|_.
13:39:04 <_Codex> esap: pattern match can do that too if no "otherwise" branch is used?
13:39:25 <palomer> esap: gotcha
13:39:35 <palomer> _Codex: we're talking about If, not if
13:40:20 <esap> codex: I haven't tried that, but I suppose it'll be some kind of run-time error, so I suppose it's also _|_.
13:40:59 <palomer> eh?
13:41:11 <esap> case Nothing of { Just x -> x } :: forall a. a
13:41:22 * ski wonders what ndm wonders about
13:41:44 <lennart_> In a denotational semantics of Haskell98 you would identify _|_, undefined, error foo, etc
13:41:48 <xerox> @type let bot = bot in const bot
13:41:49 <lambdabot> forall a b. b -> a
13:41:56 <ndm> ski, ndm wonders about converting from .hbc (haskell byte code) to .abc - and seeing how fast it is
13:41:58 <palomer> esap: what does { Just x -> x} mean?
13:42:12 <xerox> ^- bottom
13:42:13 <palomer> xerox: I like that type
13:42:21 <ski> let foo = If (IsZero (Lit 1)) (undefined :: Term Color) (undefined :: Term Color) in case foo of If _ _ _ -> True; _ -> False
13:42:26 <palomer> @type let bot = bot in bot
13:42:27 <lambdabot> forall t. t
13:42:31 <esap> palomer: as part of case, it's just matching with constructor 'Just' and then returns the embedded value that was bound to x.
13:42:35 <palomer> ^-bottom
13:42:45 <ski> (that shows that that term is not bottom)
13:43:02 <palomer> esap: oh, that's a non exhaustive search exception, no?
13:43:18 <esap> palomer: yes.
13:43:28 <palomer> which is...undefined, no?
13:43:41 <palomer> or is it another flavour of undefined?
13:43:41 <ski> > Data.Maybe.fromJust (Just 'a')
13:43:43 <lambdabot> 'a'
13:43:49 <ski> > Data.Maybe.fromJust Nothing :: ()
13:43:51 <lambdabot> Exception: Maybe.fromJust: Nothing
13:44:05 <palomer> so many elements does forall a.a have?
13:44:06 <ski> palomer : yes
13:45:44 <esap> palomer: as lennart said, in denotational semantics, differnt kinds of failure are often identified as same _|_ value. (Even if in practice, you might be able to catch some of those "error" situations with compiler support for exception handling)
13:45:45 <lennart_> forall a.a has one element in Haskell-98
13:46:03 <xerox> @type undefined
13:46:04 <lambdabot> forall a. a
13:46:08 <xerox> This one!
13:46:15 <palomer> @type error
13:46:16 <lambdabot> forall a. [Char] -> a
13:46:39 <palomer> does error return _|_ ?
13:47:04 <lennart_> That's a valid implementation of error.
13:47:18 <palomer> valid because it type checks?
13:47:23 <esap> lennart: I wonder if it would be a big restriction, if some/most types would not contain the _|_ element.
13:47:31 <Cale> yeah -- basically _|_ is the name for any value whose evaluation causes your program to halt
13:47:51 <lennart_> If you take Haskell-98 there is no way a program can distinguish between _|_ and undefined
13:48:02 <Cale> (whether by spinning, or dying with an error message)
13:48:28 <palomer> lennart_: so error will always return the same thing
13:48:29 <lennart_> externally you might get different behaviours, but internal to the program they are all the same
13:48:42 <Cale> I've also seen it used as the name for (parts of) values which just haven't been evaluated yet
13:49:10 <lennart_> Yes, in some sense error always returns the same thing.
13:49:28 <lennart_> No with catching exceptions things get a little muddier
13:49:36 <palomer> no or now?
13:49:41 <lennart_> Now
13:49:43 <palomer> yeah, that's what I'm wondering
13:50:01 <SamB> yes! they are much muddier.
13:50:08 <palomer> exception handling differentiates between different _|_
13:50:20 <palomer> so your program will act differently
13:50:21 <lennart_> But it's only in the IO monad, so you can always blame some external force for different behaviours.
13:50:23 * _Codex thinks of what is the opposite of _|_. Top or 1 and how it behaves...
13:50:46 <esap> codex: if you first define 'opposite', then maybe somebody can answer.
13:50:56 <samx> What does _|_ mean?
13:51:01 <lennart_> I really recommend SPJ et al's paper about exceptions
13:51:11 <SamB> lennart_: it means bottom ;-)
13:51:14 <SamB> er, SamB 
13:51:18 <SamB> er. samx
13:51:20 <SamB> ...
13:51:30 <Cale> samx: It's the bottom element of a lattice/poset
13:51:33 <Lor> _Codex, exists x. x ?
13:51:33 <samx> samb, I knew that far, but what does 'bottom' mean? :-)
13:51:51 <palomer> doesn't exists x.x contain all values?
13:52:03 <SamB> samx: it means your program had trouble, usually
13:52:03 <musasabi> it is a value representing error lifted into the type.
13:52:11 <samx> cale, would you be able to give an example?
13:52:16 <Cale> In Haskell/semantics, it's a value which represents nontermination or failure, and is usually an element of every type
13:52:16 <basti_> you people are nuts.
13:52:30 <Cale> @type undefined
13:52:31 <lambdabot> forall a. a
13:52:36 <_Codex> palomer: more likely just one value.
13:52:45 <lennart_> palomer: if Haskell had exists x.x I would say it contains all values
13:53:00 <palomer> lennart_: even values like \x -> x x ?
13:53:01 <SamB> I'd say it was a tautology
13:53:07 <esap> I would say it contains one value at a time (but any value)
13:53:32 <lennart_> \x -> x x is not a value in Haskell, it's not well formed
13:53:47 <Cale> SamB: you'd be right in Haskell, since there's no empty type
13:53:48 <palomer> lennart_: haskell98 or ghc?
13:54:01 <lennart_> either
13:54:22 <palomer> > \(x::forall a.a) -> x x
13:54:23 <lambdabot>   Illegal signature in pattern: forall a . a
13:54:23 <lambdabot>    Use -fglasgow-exts to permit it
13:54:30 <Cale> samx: Values in a type in Haskell are partially ordered by "how defined" they are
13:54:46 <palomer> Cale: how did you type \x -> x x before?
13:54:46 <Cale> samx: For example, take the type [Bool]
13:55:14 <Cale> palomer: like that
13:55:27 <palomer> Cale: but it worked for you!
13:55:47 <Cale> palomer: looks like someone turned off Glasgow-exts
13:55:53 <palomer> darn
13:56:59 <SamB> > let f x -> x x; f :: ((forall a . a) -> b)
13:56:59 <lambdabot>  parse error on input `->'
13:57:10 <SamB> > let f x -> x x; f :: (forall a . a) -> b
13:57:11 <lambdabot>  parse error on input `->'
13:57:37 <SamB> @type \(x::forall a.a) -> x x
13:57:38 <lambdabot> forall t. (forall a. a) -> t
13:57:49 <palomer> ok, so it is well formed in ghc
13:57:53 <xerox> @type Control.Monad.Fix.fix
13:57:54 <lambdabot> forall a. (a -> a) -> a
13:58:27 <Cale> samx: So _|_ (read bottom) is an element of this type, and then above that, you have [] and _|_ : _|_. Above _|_ : _|_, you have True : _|_, False : _|_, and _|_ : []
13:58:55 <palomer> Cale: what is this lattice called?
13:59:26 <Cale> Well, it's not actually a lattice, since there's no top. It's a distributive complete partial order
13:59:52 <Cale> er
13:59:56 <Cale> directed cpo
13:59:57 <palomer> lattices need tops?
14:00:01 <Cale> yes
14:00:48 <Cale> I'm not sure if this has a name
14:00:55 <_Codex> I always thought that anytime you distinguish between values and functions, you would have a top (but hidden inside values).
14:00:56 <Cale> probably :)
14:01:12 <Cale> _Codex: hmm
14:01:40 <Cale> _Codex: where does top arise?
14:01:50 <_Codex> I mean, Top -> A is same as A.
14:02:06 <Cale> Oh, as a type?
14:02:27 <Cale> I'm talking about the dcpo of values in a given type
14:02:43 <palomer> remind me what cpo stands for again
14:02:43 <_Codex> I dont know dcpo's :(
14:02:50 <Cale> complete partial order
14:03:06 <palomer> doesn't complete mean it has a top?
14:03:14 <samx> cale, ok.. so we would refer to bottom as the value of a function if it does not terminate, but how would this indicate a failure ?
14:03:32 <esap> samx: failure to terminate?
14:03:54 <Cale> palomer: the 'd' sort of changes that :)
14:04:08 <palomer> what does the d stand for?
14:04:23 <Cale> directed
14:04:40 <palomer> oh, no cycles
14:04:46 <palomer> asymetric
14:04:52 <palomer> asymmetric
14:06:20 <palomer> I don't see how this changes completeness
14:06:43 <palomer> anyways, I'm off to read more on GADTs
14:07:41 <Cale> Well...
14:07:49 <Cale> A poset is a dcpo if each of its directed subsets has a supremum.
14:08:13 <Cale> A cpo is a dcpo with a least element (which is actually what we have here)
14:08:16 <araujo> Hello all.
14:08:29 <esap> does the c in dcpo stand for 'complete' or 'cocomplete'?
14:08:34 <Cale> complete
14:08:38 <_Codex> cale: is that like "dependencies between types" and the dependency chain ends somewhere (thus least element?)
14:08:54 <Cale> _Codex: it's a relation between values
14:09:25 * Cale opens inkscape and begins scribbling :)
14:09:27 <_Codex> relations are like C -> (A,B)?
14:09:55 <Cale> A relation on a set S is a subset of S x S.
14:10:26 <Cale> Well, a binary relation :)
14:10:35 <_Codex> cale: sounds the same.
14:11:06 <Cale> If R is a binary relation on S, then R is a subset of S x S, and we write x R y if (x,y) is in R.
14:11:26 <Cale> For example, < is a relation on the integers.
14:11:44 <_Codex> [(x,y) | x <- S, y <- S, x*x+y*y < 10]  ; like this?
14:12:22 <Cale> sure, that's a relation which defines an open disc
14:12:33 <Cale> though I'd use curly braces for a set :)
14:12:59 <xerox> The functions differ because it has to he a set of ordered pairs?
14:13:05 <tewk> What does the ! in data Foo = Bar !Bax mean?
14:13:26 <esap> tewk: that the constructor argument is strict.
14:13:49 <tewk> duh I read that a couple of days ago.
14:14:18 <esap> tewk: that is, it specifies that Bar _|_ = _|_
14:19:59 * ski 's pondered an alternate pair type, in which (_|_,x) = (y,_|_) = (_|_,_|_) != _|_
14:20:56 <_Codex> ski: is that somehow different from current pairs?
14:21:39 <xerox> _Codex: yes, it can contain at most one element
14:23:37 <Cale> http://vx.hn.org/autoshare/%5BBool%5D.png
14:24:25 <_Codex> cale: what does T : _|_ : _|_ mean?
14:24:39 <Cale> These are the elements of [Bool]
14:24:48 <Cale> I wrote T for True
14:24:50 <_Codex> oh
14:24:52 * xerox opens a parens
14:25:07 <Cale> @type T : undefined : undefined
14:25:08 <lambdabot> Not in scope: data constructor `T'
14:25:13 <Cale> @type True : undefined : undefined
14:25:14 <lambdabot> [Bool]
14:25:22 * _Codex thought : means :: :)
14:25:27 <xerox> Well, happy new year, fellow Haskellers.  I'm going somewhere tomorrow so... goodbye, and have *much* fun :-)
14:25:34 * xerox closes the parens
14:25:51 <Cale> xerox: see you
14:26:04 <ski> _Codex : yes, with current pairs not ((_|_,x) = (y,_|_) = (_|_,_|_)), for all nonbottom x,y
14:26:53 <_Codex> ski: lazy eval could get x or y from them and actually not eval _|_ at all?
14:26:55 <Cale> oh, actually, I missed something there :)
14:27:28 <ski> _Codex : yes
14:27:38 <ski> > fst ('a',undefined)
14:27:39 <lambdabot> 'a'
14:29:23 <_Codex> ski: how is this new pair type going to work if you do fst ('a', bottom) with it?
14:30:05 <_Codex> ski: just like fst (undefined,undefined)?
14:30:05 <Cale> http://vx.hn.org/autoshare/%5BBool%5D.png -- updated :)
14:32:13 <Cale> anyway, the idea is to partially order elements of a type roughly by saying that x < y if y can be obtained from x by replacing some undefined parts of x with values which have a defined constructor.
14:32:56 <ski> _Codex : if you do that, it will hang (i.e. answer is bottom)
14:33:49 <ski> one could consider values with possible '_|_' inside them as current approximations
14:34:08 <ski> then every value starts out as '_|_' .. always monotonically increasing
14:34:44 <ski> and what one usually calls 'bottoms' are then 'final bottoms', i.e. values that wont be more determined
14:35:39 <_Codex> cale: I never understood why they dont use directed arrows in the dcpo diagrams? Are those relations somehow not directed at all?
14:36:01 <Cale> _Codex: they're directed by virtue of being up and down on the page
14:36:25 <_Codex> cale: so the layout is relevant in them?
14:36:33 <Cale> _Codex: these are Hasse diagrams for the partial order, and it's just uncommon to draw the arrows in Hasse diagrams. Yes
14:37:40 <Cale> an edge from x up to y means that x < y and there is no z such that x < z < y.
14:38:57 <Cale> http://en.wikipedia.org/wiki/Hasse_diagram
14:41:11 <Cale> I really like the middle drawing for P({a,b,c,d}).
14:41:20 <Cale> (near the bottom of the page)
14:41:48 <Cale> It becomes apparent that the Hasse diagram is the hypercube :)
14:45:09 <ski> yes, that is nice
14:45:45 <ski> (0 * 0 * 0 * 0  in BoolAlg)
14:46:26 <Cale> 0?
14:46:43 <Cale> I suppose there are no smaller boolean algebras
14:46:52 <_Codex> cale: is there composition in the diagrams. I mean, a < b, b < c => a < c. Even though a < c is not drawn (since b exists)?
14:47:00 <Cale> ah, okay, it is initial
14:47:14 <dons> Moin
14:47:31 <Cale> _Codex: yeah, transitivity is assumed
14:47:44 <Cale> (which is why those edges aren't drawn in the first place)
14:47:53 <Cale> morning dons 
14:48:10 <Heffalump> morning
14:48:34 <Cale> ski: 2^4
14:48:52 <Cale> Is how I'd probably name it :)
14:50:33 <ski> heh
14:50:53 <_Codex> cale: oh, that's how those are different from category diagrams. dcpo's never(?) draw triangles?
14:51:32 <Cale> _Codex: oh, they're a different thing from category theory diagrams altogether
14:51:39 <ski> used for different purpose
14:51:51 <Cale> _Codex: they're just for displaying a partial ordering nicely
14:52:02 <Cale> I suppose you can turn a poset into a category
14:52:12 <Cale> but it's sort of a funny thing to do :)
14:52:21 <gzl> I think people do that pretty often, actually
14:52:44 <gzl> add an arrow U -> V if U < V
14:52:54 <Cale> right
14:53:32 <gzl> my impression was that was a pretty standard construction
14:53:34 <ski> preorder
14:53:43 <Cale> I suppose that certain small examples of that are common.
14:54:01 <Cale> like finite ordinals
14:58:03 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
14:58:03 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
15:02:35 <gzl> I have a vague recollection of people looking at topological spaces like this.
15:08:10 <gzl> Cale: one thing is that Galois connections give rise to pairs of adjoint functors between the posets considered as categories in this way. I think that might buy you stuff.
15:08:33 <lennart_> ski: isn't your proposed pair type just 'data Pair a b = Pair !a !b' ?
15:10:14 <ski> very possibly
15:10:16 <lennart_> hmmm, maybe with an extra lifting
15:10:58 <lennart_> It's a weird type anyway.  It's not definable in lambda calculus. :)
15:11:20 <ski> (i wasn't considering strictness annotations at all when i thought about this .. which was when i was reading parts of the topology in haskell paper)
15:16:18 <Cale> http://vx.hn.org/autoshare/360.png  :)
15:25:00 <syntaxfree> @hoogle String->Int
15:25:01 <lambdabot> Text.Regex.Posix.regExtended :: Int
15:25:01 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
15:25:01 <lambdabot> Text.Regex.Posix.regNewline :: Int
15:25:12 <syntaxfree> @hoogle (Num a)=>String->a
15:25:13 <lambdabot> Data.HashTable.hashString :: String -> Int32
15:25:13 <lambdabot> Prelude.error :: String -> a
15:25:13 <lambdabot> Graphics.UI.ObjectIO.CommonDef.dummy :: String -> x
15:25:27 <syntaxfree> I want to make 15 out of "15".
15:25:32 <syntaxfree> how do I do that?
15:25:40 <Heffalump> > read "15" :: Int
15:25:41 <lambdabot> 15
15:25:46 <syntaxfree> @type read
15:25:47 <lambdabot> forall a. (Read a) => String -> a
15:25:57 <syntaxfree> oh, ok. thanks.
15:26:52 * syntaxfree bangs his drum all day
15:29:58 <gzl> ski: topology in haskell?
15:31:43 <ski> gzl : yes
15:31:52 <gzl> what's that about?
15:33:38 <ski> http://www.mail-archive.com/haskell@haskell.org/msg14893.html
15:35:25 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
15:35:25 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
15:35:43 <gzl> ski: thanks.
15:36:10 <ski> it's an interesting paper .. later parts are too heavy for me atm, though
15:36:25 <ski> still, brings interesting viewpoints
15:37:20 <gzl> woah, this is strange.
15:38:22 <_Codex> ski: looks good, a little too verbose.
15:38:54 * _Codex skipped lots of it :(
15:40:39 <gzl> I'm finding the writing style a little hard to follow.
15:41:33 <gzl> wait, what is 'semidecidable'?
15:42:19 <gzl> something in between decidable and r.e.?
15:44:25 <gzl> oh, weird, semidecidable = r.e., never seen that terminology before
15:45:06 <rep> http://forums.anandtech.com/messageview.aspx?catid=50&threadid=1746021&enterthread=y
15:53:59 <sproingie> how odd... the second two entries in http://haskell.org/hawiki/ChameneosEntry only work in ghci
15:54:04 <sproingie> i get linker errors with ghc
15:54:46 <sproingie> lots of : undefined reference to `ControlziConcurrentziSTMziTMVar_readTMVar_closure'
15:55:01 <sproingie> and other mangled control.concurrent symbols
15:56:13 <stepcut> you might need to add -package stm to the build-line
15:56:21 <stepcut> ghc --make -package stm ...
15:57:18 <sproingie> aha, that worked.  thanks
16:00:43 <sproingie> wow, ghc produces some big binaries on amd64
16:01:03 <stepcut> heh
16:01:07 <Cale> http://vx.hn.org/autoshare/210.png
16:01:14 <stepcut> strip may help some
16:01:27 <stepcut> but in general, ghc produces big binaries
16:01:33 <sproingie> well, it shaved 200K off the first, and 2 megs off the second
16:01:39 <sproingie> leaving the 64 bit version still at 4.4 megs
16:01:53 <sproingie> the 32 bit binaries are pretty reasonably sized
16:01:58 <stepcut> Cale: doesn't work for me
16:02:14 <stepcut> sproingie: I wonder if the 64-bit is statically linking more stuff
16:02:22 <sproingie> stepcut: nope
16:02:30 <sproingie> ldd shows the same libs
16:02:51 <Cale> stepcut: odd -- what error?
16:02:53 <mahogny> you use haskell for a reason. if the fixed size is huge you better make up for it writing a lot of code :)
16:02:57 * sproingie can live with the 32 bit version, so it's nbd 
16:03:33 <sproingie> ghci doesn't work on the debian's 64 bit ghc anyway.  grr.
16:03:34 <stepcut> Cale: timed out -- worked this second time (but took a wihle)
16:04:43 <monochrom> rep: interesting problems :)
16:05:06 <rep> i like this one: You are given two pointers to a linked list. One pointer is to the head of the list, and another pointer is to a target node that you need to delete. If you don't care about maintaining the list in any order, how can you delete the target node in constant time? 
16:05:32 * sproingie is thinking swapping pointers
16:05:45 <rep> which?
16:06:01 <sproingie> not sure.  i'm too distracted to really visualize it
16:06:56 <sproingie> if they're fixed size, you could just overwrite the deleted node with the head
16:07:14 <rep> yes
16:07:21 <sproingie> and change the head to the head's successor of course
16:08:08 <sproingie> could turn pointer traversals into a bigger copy though
16:08:30 <rep> what do you mean?
16:08:49 <sproingie> i suppose the list nodes are small, like a pointer to data and not the data itself
16:09:51 <sproingie> since i suppose you have to actually copy the node if you don't have a reference to the deleted node's predecessor
16:10:03 <monochrom> Ah, I see what sproingie is saying.
16:10:23 <sproingie> 'course if you have that reference, you don't need the head at all :)
16:11:56 <rep> what if the records are not constant size?
16:12:46 <monochrom> yeah, need target's predecessor, but that's expensive.
16:12:48 <musasabi> if the records are small constant size then just copying the head or head->next (if changing head not allowed) will work
16:13:19 <rep> monochrom that's not constant time anymore
16:13:33 <rep> (unless the list is doubly linked, which it could be. the problem didn't specify)
16:13:50 <gzl> if it's doubly linked it's simple
16:13:52 <musasabi> if it is doubly linked isn't the delete O(1) in any case?
16:14:00 <gzl> yes
16:14:10 <rep> i'm saying it's not constant time if the link is NOT doubly linked
16:14:17 <rep> (getting the previous node)
16:14:30 <rep> s/link/list/
16:15:03 <monochrom> Let's see if we can do it singly-linked, no copying.
16:20:03 <monochrom> Seems very difficult.
16:20:52 <monochrom> Seems like we can prove: if no copying allowed, we must redirect predecessor's "next" pointer, but that must take too long.
16:20:53 <musasabi> it is O(size_of_list_node_if_constant)
16:21:19 <monochrom> I am not sure Google is interested in impossibility proofs :)
16:23:13 <ski> Cale : oooh, nice and shiny :)
16:23:28 <stepcut> If you can calculate the worse case time, then you could modify the algorithm to always take that long :p
16:24:10 <ski> (one could keep a pointer to one place before the actual node ..)
16:32:08 <Cale> ski: 210 happens to be my room number from first year at Waterloo :)
16:33:39 <ski> oki
16:34:13 <Cale> It's the first number whose Hasse diagram of divisors is a hypercube :)
16:34:30 <Cale> (any number with 4 distinct prime factors will have that property)
16:35:38 <rep> ...
17:53:20 <lispy> is there a haskell tool to measure code coverage of a test suite?
17:54:04 <araujo> Hola.
17:55:28 <lispy> hi
17:55:46 * araujo next to add stderr redirection to hashell
17:56:22 <lispy> hmm....darcs could benefit from such a tool
17:57:39 <palomer> quickcheck is the bomb
17:58:04 <lispy> hmm...can that tell you which functions are getting tested?
17:58:17 <lispy> i should clarify, i don't want to do unit tests
17:58:44 <sproingie> is there any tutorial material available for control.concurrent?
17:58:46 <lispy> i want to test the whole program and see if i'm hitting the corner cases of functions
17:58:58 <sproingie> channels look reasonably simple, but i'm not totally sure
18:00:32 <monochrom> Simon PJ's Marktoberdort lectures "tackling the awkward squad" may be of use.
18:00:35 <lispy> what i want to do is run the darcs test suite and see how good it is
18:03:04 <lispy> hmm...i set a function equal to undefined, ran the test suite and everything passed, that's a bad sign
18:04:17 <sproingie> not great coverage
18:04:38 <sproingie> or maybe the test suite isn't producing I/O and it optimizes away to nothing :)
18:09:28 <SamB> lispy: profiling
18:11:31 <lispy> SamB: yeah, then i'd just need a way to visualize it
18:11:40 <stesch> If someone here has access or knows someone: The link to the paper is broken: http://www.cs.chalmers.se/ComputingScience/Research/Functional/Fudgets/haskell-vs-ada-abstract.html
18:12:08 <lispy> i wonder if hat would be helpful here
18:13:00 <stesch> Oh, there's the PDF: http://www.cs.pdx.edu/~apt/cs457/hudak-jones.pdf
18:14:16 <araujo> @index anyAlpha
18:14:17 <lambdabot> bzzt
20:29:29 <araujo> @index handle
20:29:30 <lambdabot> Control.Exception
21:35:20 <shapr> @yow !
21:35:21 <lambdabot> Let me do my TRIBUTE to FISHNET STOCKINGS ...
21:35:33 <shapr> Wassup?
21:40:28 <shapr> Good morning #haskell!
21:43:38 <araujo> yay!!!
21:58:36 * lispy growls at the layout rule
22:02:06 * shapr is comfortable layed out in bed
22:02:12 <shapr> comfortably*
22:02:19 <shapr> y0 Mistah Dagit, wazzup?
22:07:03 <lispy> shapr: uh, not much just looking at darcs source and getting annoyed with layout :)
22:07:16 <lispy> sometimes i just want to throw an if in there but then i have to move everything over
22:07:30 <lispy> @type fail
22:07:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:07:34 <shapr> haskell-mode could be friendlier.
22:08:00 <lispy> yeah, emacs needs a real parser
22:08:21 <lispy> @doc fail
22:08:22 <lambdabot> fail not available
22:08:29 <lispy> @doc Monad.fail
22:08:29 <lambdabot> Monad.fail not available
22:08:33 <lispy> hmm...
22:09:19 <lispy> what does fail do?
22:09:36 <lispy> "Fail with a message." is too vague for my purposes :)
22:09:50 <lispy> does it throw an exception?
22:11:16 <Saulzar> It depends on the monad - in IO or error yes, http://www.nomaware.com/monads/html/laws.html#fail
22:11:45 <lispy> thanks
22:13:20 <lispy> now it's time to get the error messages from scp
22:14:05 <araujo> mm.. let's see if this aliasing thingy work....
22:14:09 * araujo afraid
22:14:17 <shapr> Yi has a real parser.
22:14:35 <shapr> lispy: Does darcs support master connections with ssh?
22:14:52 <lispy> shapr: what is a master connection?
22:15:15 <lispy> darcs does a new scp attempt for each file
22:16:06 <lispy> hmm...scp doesn't list it's error codes, perhaps i need to read from stderr to get it's errors
22:16:18 <lispy> if that's the case i don't think i can really fix this bug
22:21:23 <shapr> lispy: http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/doc/darcs.html#toc10
22:21:36 <shapr> @google ssh darcs controlmaster
22:21:38 <lambdabot> http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/doc/
22:21:38 <lambdabot> darcs.html
22:21:44 <shapr> ok then
22:21:54 <shapr> @google controlmaster ssh same connection
22:21:55 <lambdabot> http://www.revsys.com/writings/quicktips/ssh-faster-connections.html
22:22:12 <shapr> Ah that sounds the like the sort of overview I was hoping for...
22:22:37 <shapr> Yes, that's it.
22:22:39 <lispy> reducing scp overhead would be nice
22:23:13 <shapr> ControlMaster does that transparently.
22:24:41 <lispy> shapr: it would be easy to add that option to the scp commandline, but i'm not sure how to hold a connection open
22:25:07 <lispy> it also seems like darcs could get the names of all the files it will copy and use one big scp command...maybe it does that now
22:27:15 <lispy> hmm...nope, it's as simple as possible, one attempt per file
22:27:57 <shapr> Simplicity is good. Efficiency has benefits too.
22:28:11 <shapr> The ControlMaster approach doesn't require any changes to darcs.
22:30:50 <lispy> oh, n/m, there are two versions of those copy functions
22:31:34 <lispy> shapr: no, but darcs could do automate it for people that would benefit and not otherwise use it
22:32:09 <lispy> but what got me started, was trying to improve the error reporting
22:32:20 <lispy> it looks like scp doesn't like to give good error messages tho
22:32:31 <lispy> i think it always dumps them to stderr or stdout
22:32:47 <lispy> i think it would take a bit of retooling to get darcs to capture that output
22:33:47 <lispy> i'm going to be 26 is an hour and a half
22:33:52 <lispy> go me
22:35:52 <shapr> happy birthday
22:36:30 <lispy> thanks
23:00:40 <shapr> Getting anything cool for your birthday?
23:01:20 <lispy> shapr: i suspect my gf is going to get me the latest mario rpg for game cube, but i told her not to get me anything
23:01:43 <lispy> shapr: other than that, probably nothing, usually my family gives me cards with $$ at christmas labeled, "birthday" ;)
23:05:23 <shapr> heh
23:06:10 <araujo> > "hi" ++ (unwords $ tail $ words "hello lambda world!")
23:06:12 <lambdabot> "hilambda world!"
23:06:26 <araujo> mm.. is there probably a saner way of doing that?
23:07:19 <shapr> > "hi" ++ (snd $ break (== ' ') "hello lambda world")
23:07:21 <lambdabot> "hi lambda world"
23:07:50 <araujo> yow!
23:52:23 <lispy> @pl \x -> foo x >>= bar
23:52:24 <lambdabot> (bar =<<) . foo
23:52:35 <lispy> hm...that's probably not more readable
23:53:11 <tewk> any fast way to get the docs for a library function from the cmdline, say hdoc print or hdoc id etc?
23:54:54 <lispy> @doc mapM
23:54:55 <lambdabot> mapM not available
23:54:59 <Lemmih> tewk: Nope.
23:55:00 <lispy> @index mapM
23:55:01 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
23:55:01 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
23:55:01 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
23:55:09 <lispy> @doc Control.Monad.mapM
23:55:10 <lambdabot> Control.Monad.mapM not available
23:55:26 <lispy> tewk: i thought there was a way to do it with lambdabot but i don't seem to know it anymore
23:55:27 <Cale> you can easily look things up in the online documentation though
23:55:36 <Lemmih> @docs Prelude
23:55:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
23:55:53 <Cale> there's a nice alphabetical index if you're looking for something specific, but don't know what module it's in
23:56:48 <Lemmih> tewk: Writing such a program would be a fun little task.
23:57:11 <perry-apsis> @doc Control.mapM
23:57:12 <lambdabot> Control.mapM not available
23:57:28 <Lemmih> @help docs
23:57:29 <lambdabot>  @docs <lib>, lookup the url for this library's documentation
23:57:46 <perry-apsis> @help doc
23:57:47 <lambdabot>  @help <command> - ask for help for <command>
23:58:13 <perry-apsis> @docs Control.Monad.mapM
23:58:14 <lambdabot> Control.Monad.mapM not available
23:58:29 <perry-apsis> whee
23:58:33 <Lemmih> It takes a module name, not a function.
23:58:42 <perry-apsis> @docs Control.Monad
23:58:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.
23:58:43 <lambdabot> html
23:59:38 <twb> What's wrong with this parser?
23:59:38 <twb> > formFeed = do char '\f'
23:59:38 <twb> >               setState (getState+1)
23:59:38 <twb> >               return ' '
23:59:40 <lambdabot>  parse error on input `='
23:59:40 <lambdabot>  Not in scope: `getState'
23:59:40 <lambdabot>  add an instance declaration for (Show (m Char))
