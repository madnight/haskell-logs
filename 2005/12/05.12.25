00:02:47 <gour> dons: one question about hs-plugins?
00:07:48 <xerox> Goodday people.
00:24:05 <araujo> dons, heyo!
00:24:10 <araujo> dons, merry xmas
00:26:37 <araujo> dons, got several queston about hs-plugins too, does it propagate the exception whenever they happen?
00:36:20 <Lemmih> araujo: hs-plugins does pretty much the same as GHCi.
01:21:31 <gour> Lemmih: ping
01:24:27 <Lemmih> gour: pong.
01:28:54 <gour> Lemmih: how are you?
01:29:31 <Lemmih> I'm good. You?
01:29:52 <gour> keep going..
01:30:07 <gour> are you familiar with hs-plugins licenising?
01:30:50 <gour> i.e. i'm interested if one writes e.g. gtk2hs application using hs-plugins, is it possible to have some of app's plugins close-sourced?
01:32:24 <Lemmih> That'll be difficult.
01:33:01 <gour> really?
01:33:38 <Lemmih> hs-plugins is LGPL'ed which means it must be possible to relink your program against a newer/different version.
01:34:13 <mwc> @seen JohnMeacham 
01:34:14 <lambdabot> JohnMeacham is in #haskell and #haskell-blah. Last spoke 11 hours, 54
01:34:14 <lambdabot> minutes and 29 seconds ago.
01:34:45 <Lemmih> LGPL is pretty much the same as GPL since haskell libraries in GHC are always statically linked.
01:34:50 <gour> Lemmih: hmm, but doesn't lgpl allow close-source, i.e. commercial app?
01:35:06 <mwc> gour, my understanding of that licencing issue is that for plugins, technically the user links them in
01:35:16 <mwc> so they can be closed source and used with GLP'd apps
01:35:38 <gour> personally i'm not concerned, but i know there could be some funcitonality which someone would like to cover
01:36:30 <gour> mwc: interesting...i'm definitely not an expert for reading licenses...
01:36:48 * gour would like that licensing issues are more simple...
01:36:50 <Saulzar> LGPL only really seems to serve it's intentions properly for ancient C code
01:36:54 <Lemmih> Oh right. The plugins can be closed as long as the main program is free.
01:37:27 <mwc> gour, just do like djb, distribute it without a license
01:37:31 <gour> Lemmih: that's what I would need (maybe), i.e. to have some of the plugins closed
01:37:48 <gour> mwc: and?
01:38:14 <mwc> gour, that's just it. Simplist possible licensing issue
01:38:17 <mwc> works for qmail
01:38:49 <gour> as i said, i do not plan to clsoe anything, but some other party would maybe like to have some of the plugins included with the application closed
01:39:01 <Saulzar> meaning that you give absolutely no rights to anyone to use your app?
01:39:31 <gour> Saulzar: me or djb license?
01:39:48 * gour hopes it's qmail-oriented
01:39:50 <Saulzar> Never heard of djb, but was replying to mwc ..
01:40:07 <gour> Saulzar: ok, i was thinking about qmail author :-)
01:40:21 <mwc> Saulzar, http://en.wikipedia.org/wiki/License-free_software
01:42:23 <gour> mwc: so i think if lgpl allows to have some of the included plugins as close-source, that's pretty everything i'm concerned about
01:42:50 <mwc> Yeah, I think that loading a plugin is a "user-time" linking
01:43:09 <mwc> and the L(GPL) just requires you to distribute source if you redistribute
01:43:16 <mwc> your modified version
01:45:32 <mwc> I am not a lawyer, but I think it's the same reason why you can have closed source NVidia drivers linked into the linux kernel: you can do it module wise since the user requests it to be loaded, but you couldn't put the NVidia object code into the kernel statically and then distribute it
01:45:42 <gour> and if i use non-modifed hs-plugins & gtk2hs plus my code, it can stay (at least part of) close-sourced?
01:46:03 <mwc> no, only the plugins can be closed
01:46:14 <mwc> anything you link into the application has to be L(GPL)
01:46:19 <mwc> or BSD, or whatever
01:46:40 <gour> yes, that is what i mean, just some of the plugins can be close-sourced
01:46:56 <mwc> yep, I think that's fine. There's plenty of precendence for that
01:47:23 <gour> mwc: the point is that hs-plugins allows to have almost the whole app via plugins
01:47:41 <gour> by having just a small part statically linked
01:47:47 <gour> core
05:01:31 <tennin> hello
05:02:03 <ski> hi tennin
05:02:19 <araujo> Good morning!
05:03:07 <araujo> Lemmih, and.. what exactly is that?
05:03:27 <araujo> Lemmih, i want to catch hs-plugins exceptos, which it looks like i can't do.
05:03:33 <araujo> I can do it with GHCI.
05:04:51 <tennin> good morning (in western hemisphere at least...)!
05:05:10 <tennin> all I want for Christmas is to get this program working!
06:26:57 <Cale> TaPL for Christmas :)
06:31:43 <ski> Cale : hehe
06:32:59 <lennart> hohoho
06:41:07 <{Arias}> hello
06:41:20 <ski> @hello
06:41:20 <lambdabot>  @help <command> - ask for help for <command>
06:41:32 <{Arias}> @hello ski
06:41:32 <lambdabot>  @help <command> - ask for help for <command>
06:41:40 <ski> :)
06:41:42 <{Arias}> jaja
06:50:24 <Pupeno> Good morning.
07:00:36 <Pupeno> quiet channel.
07:01:35 <ski> yes
07:01:48 <ski> @yow
07:01:49 <lambdabot> This TOPS OFF my partygoing experience!  Someone I DON'T LIKE is
07:01:49 <lambdabot> talking to me about a HEART-WARMING European film ...
07:02:09 <Pupeno> lambdabot can yow!
07:02:15 <Pupeno> @yow
07:02:16 <lambdabot> I've read SEVEN MILLION books!!
07:02:18 <ski> sure
07:02:22 <ski> @arr
07:02:22 <lambdabot> Yeh scurvy dog...
07:02:47 <ski> @arr
07:02:48 <lambdabot> Get out of me way, yeh landlubber
07:02:59 <Pupeno> It is awesome how bad algorithms look bad on haskell and good looks good (at least, the ones I did).
07:03:16 <ski> hmhm
07:24:18 <cm> ho ho ho
07:28:50 <alar> =))))
07:28:57 <alar> @yow
07:28:58 <lambdabot> Yow!  I threw up on my window!
07:29:05 <{Arias}> @arr
07:29:06 <lambdabot> Avast!
07:29:34 <alar> @yow
07:29:35 <lambdabot> Yow!  Are we wet yet?
07:29:40 <alar> @yow
07:29:41 <lambdabot> I think I'll KILL myself by leaping out of this 14th STORY WINDOW
07:29:41 <lambdabot> while
07:29:41 <lambdabot> reading ERICA JONG'S poetry!!
07:36:25 <{Arias}> @pl (\x y -> (notElem.(+1)) x y)
07:36:26 <lambdabot> notElem . (1 +)
07:36:41 <Pupeno> I think I am writting a parser... and I don't know how to write parsers.
07:37:26 <{Arias}> with parsec
07:37:42 <{Arias}> import Text.ParserCombinators.Parsec
07:38:44 <{Arias}> @pl (\x y -> filter (notElem.content y) x)
07:38:45 <lambdabot> flip (filter . (notElem .) . content)
07:38:51 <dsacode> Hello! Is it some more or less effective algorithm for generating primes written in Haskell? Searched through Google but found only bad solutions like Sieve of Eratosfene
07:38:53 <musasabi> backtracking is the only slightly complex issue with parsec (and even that is simple if you remember that <|> is left-biased)
07:39:43 <musasabi> dsacode: yes, there are more efficient ones, but they are usually not one-liners and few people need them in practice.
07:39:58 <dsacode> musasabi: where can I search for them?
07:41:57 <musasabi> dsacode: googling for haskell efficient prime number
07:49:45 <lennart> dsacode: there are one-liners that are pretty efficient
07:51:06 <alar> "íùö
07:51:10 <alar> @yow
07:51:11 <lambdabot> Don't worry, nobody really LISTENS to lectures in MOSCOW, either! ...
07:51:11 <lambdabot> FRENCH, HISTORY, ADVANCED CALCULUS, COMPUTER PROGRAMMING, BLACK
07:51:11 <lambdabot> STUDIES, SOCIOBIOLOGY! ...  Are there any QUESTIONS??
07:51:30 <alar> moscow?
07:51:57 <araujo> Theyt must be very borin lectures.
07:54:40 <lennart> primes = 2 : filter (isPrime primes) [3,5..] where isPrime (p:ps) n = p*p > n || n `mod` p /= 0 && isPrime ps n
07:55:45 <lennart> musasabi: use Parsek and stop worrying about backtracking :)
07:56:05 <musasabi> or ReadP
07:56:21 <lennart> yes, same technology
08:00:21 <lennart> dsacode: what kind of speed are you looking for?  the oneliner i showed computes 100000 primes in 12s on my laptop
08:04:22 <Cale> Parsek is a good deal slower than Parsec though, which itself is a good deal slower than PArrows
08:05:43 <Cale> PArrows seems to assume an ISO8859 character set, though I'm pretty sure that could be changed.
08:06:24 <Cale> (I'm fairly sure the others don't really fully support unicode either)
08:07:01 <{Arias}> lennart: primes = [ x | x <- [1..], all (\y -> x `mod` y /= 0) [2..floor (sqrt (fromIntegral x))] ]
08:07:15 <Cale> Then again, if you take care of the lexing you shouldn't have to worry about it :)
08:08:09 <lennart> Arias, I promise that my single * is much faster than fromIntegral, sqrt, and floor :)
08:08:40 <musasabi> Cale: unicode support seems hard to get right in an efficient manner.
08:08:42 <lennart> Also, my version only tests the number against primes which saves a lot
08:10:11 <lennart> Cale: Yes, you probably need to pick your parsing library depending on your needs.  I just know that for what I typically do the parsing time is just a small fraction.
08:10:17 <musasabi> Cale: the basic problem is that one cannot use a "naive" representation for sets.
08:10:59 <Cale> musasabi: yeah, that's true
08:11:01 <musasabi> after fixing that, the rest should be easy (but one still would need the sets of different unicode character classes)
08:11:20 <Cale> How does Data.Set do?
08:12:03 <musasabi> Cale: it won't do for the full unicode range, think about computing the set of characters "not number" 
08:12:50 <mjl69> my primes one-liner was very slow and skipped over 2 :-(
08:13:06 <Cale> Ah, you kind of need a more algebraic representation, I see.
08:13:45 <lennart> how many bits is a Unicode character these days?  20?
08:14:14 <Pupeno> lennart: depends on the encoding, doesn't it ?
08:14:53 <Pupeno> see you!
08:15:01 <Cale> Possibly something representing negations explicitly could be built on top of Data.Set with not too much work.
08:16:02 <musasabi> Cale: yes, but it makes implementing optimization more work as instead of simple set operations one has more complex ops. (or one just imports a better suited set implementation)
08:16:58 <Cale> (together with an abstract representation for intersection and union which determines in a somewhat smart way whether to perform the ops)
08:17:42 <musasabi> one simple thing is "does this choice introduce backtracking which is basically 'partition the choices to the equivalence classes with respect to the first character they accept' + handling empty input"
08:18:39 <musasabi> Cale: yes, but Data.Char does not have a way to get the various predicaters as sets of letters.
08:19:35 <Cale> Oh sure, you'd end up writing that, which I'm sure would be pretty tedious.
08:19:39 <musasabi> thus one would be forced to use something like letterSet = toSet (filter isLetter [minBound .. maxBound]), which is kind of ineffcient, or add unicode tables.
08:19:56 <Cale> I'm thinking of the unicode tables route.
08:20:19 <Cale> We really ought to have a Data.Char.Unicode or some such.
08:20:39 <musasabi> also unicode makes things hard by the combining character mess (and even simple equality is not very well defined)
08:20:55 <Cale> With various tables and classifiers
08:21:13 <Cale> Is there a messy equivalence relation on equality?
08:22:01 <musasabi> in most scripts there are predefined and composed forms of the same character
08:22:26 <musasabi> basically in latin one can write an accented character or a character + accent, the same in other scripts
08:23:24 <musasabi> + all the normalization things.
08:23:42 * musasabi is not an unicode expert, so I don't think I would get it right
08:23:56 <Cale> Yeah, it's probably pretty tough.
08:24:28 <Cale> It sort of sounds like you need a  firstCharEquivalent :: [Char] -> [Char]
08:24:30 <Cale> er
08:24:34 <Cale> firstCharEquivalent :: [Char] -> [Char] -> Bool
08:25:07 <Cale> Since actual characters are represented by multiple Chars
08:25:29 <Cale> I wonder if the Haskell compiler/runtime could improve on the situation
08:26:07 <Cale> i.e. make the Char type capable of expressing ligatures and character + accents
08:27:39 <Cale> Does unicode define some notion of 'chunks' which should be used for comparison of characters?
08:28:19 <Cale> I really should have a closer look at it at some point :)
08:30:19 <Cale> Most of what I've heard about Unicode makes it look like a very rich standard, but also one which is too complex for most programmers to have to deal with. I wonder how much could be done at the language/library level to make that better.
08:31:41 <musasabi> yes, it is quite complex
08:32:06 <musasabi> the hardest part I think is that one has to talk about strings instead of characters
08:33:22 <musasabi> and I think that "(s1 /= s1') && (s2 /= s2') && ((s1 ++ s2) == (s1' ++ s2'))" is possible
08:34:59 <Cale> It almost seems as if you'd want to turn characters or perhaps the strings themselves, into something more tree-like, perhaps with bounded depth.
08:36:41 <musasabi> it may be that the perl6 folks did much of the work already (not quite sure though)
08:36:56 <musasabi> audreyt: how does pugs (or perl6) handle unicode?
08:58:57 <palomer> merry christmas!
09:22:24 <conal> palomer, merry christmas.
09:27:03 <xerox> merry christmas indeed
09:58:17 <audreyt> musasabi: happily
09:59:18 <audreyt> musasabi: the idea is that you can treat the same thing as a bytestring, a codepoint array, or a grapheme array
10:04:51 <metaperl> shapr`: ping?
10:07:41 <musasabi> audreyt: so which one is used for equality?
10:09:07 <musasabi> and are different normalizations a problem?
10:10:51 <musasabi> also is Char == codepoint ?
10:13:09 <audreyt> Char == codepoint in haskell view, yes
10:13:47 <audreyt> if you have strong normalization constraints (like handling W3C data formats) and an application wide encoding
10:13:51 <audreyt> then either one can be used for equality
10:14:18 <audreyt> if the constraint/encoding is bogus, it's normalized to the higher level
10:14:30 <musasabi> mmh, ok
10:14:50 <audreyt> so if two strings are encoded in utf8/utf18 respectively, but you know they are NFKC
10:14:56 <audreyt> then perl6 would compare them in codepoint level.
10:15:01 <audreyt> s/utf18/utf16/
10:15:23 <audreyt> otoh, if you also know both are in utf16, then a bytewise comparison is used.
10:15:49 <musasabi> no grapheme combining performed?
10:15:49 <audreyt> in regular expressions, where /./ can mean different things, it depends on an modifier in the regex itself, and falls back to the lexical unicode level setting.
10:16:09 <audreyt> the point of KC normalization form is that it's precomposed for you
10:16:29 <audreyt> so comparing codepoints is guaranteed to yield the same result as graphemes
10:16:41 <audreyt> if the constraint is not known in strings (or specified in the lexical environment)
10:16:44 <musasabi> so everything is normalized on input?
10:16:55 <audreyt> then it will be normalized in memory
10:16:59 <audreyt> yes, that is the basic idea.
10:17:09 <audreyt> or "treated as if they are normalized"
10:17:18 <audreyt> i.e. normalization may be lazy
10:17:59 <musasabi> ok, thanks :-)
10:18:47 <musasabi> seems like much of that could be done in GHC with a suitable IO library with encoding conversions and normalization.
10:19:00 <audreyt> yup
10:19:46 <audreyt> GHC is already using UTF32 anyway
10:19:59 <audreyt> so just put NFC constraint on it and you should be all set
10:20:10 <audreyt> though it's very memory hungry
10:20:14 <audreyt> but we have FastString, so that's okay
10:20:46 <musasabi> yes, actional String representation seems orthogonal
10:21:32 <audreyt> parrot uses variable width representation -- 7bit ascii, 8bit latin1, 16bit ucs2, and full utf16+surrogates
10:21:43 <audreyt> so it's like a FastString that autoupgrades
10:22:04 <audreyt> it's a neat scheme for languages with huge amount of internal strings and passthru I/O
10:22:09 <audreyt> but I'm not sure GHC fits the profile.
10:23:09 <musasabi> well something has to be done for String sooner or later, as it is not possible to use it in the current form in performance critical places.
10:23:21 <audreyt> (Pugs uses dons's FastPackedString)
10:23:44 <audreyt> yeah I agree... [Char] really sucks.
10:24:00 <musasabi> currently everyone just uses their own FastStrings (with people merging towards the Dons versions, except for the licence problems)
10:24:22 <audreyt> *nod*
10:24:59 <audreyt> I wonder if libicu is an acceptable depdency for GHC.
10:25:25 <audreyt> it handles normalization, auto-upgrading and transcoding natively and efficiently
10:27:03 <musasabi> isn't that over 10mb ?
10:27:43 <audreyt> no
10:27:48 <audreyt> it's just 9194758 bytes ;)
10:27:49 <tuomov> I think [Char] rocks, but needs a more efficient implementation under the hood
10:27:53 <imix> @hoogle select
10:27:55 <lambdabot> Text.Html.select :: Html -> Html
10:27:55 <lambdabot> Graphics.Rendering.OpenGL.GL.Selection.Select :: RenderMode
10:27:55 <lambdabot> Text.Html.selected :: HtmlAttr
10:28:56 <tuomov> unicode sucks, though
10:28:57 <audreyt> tuomov: a linked list of code points is really not a very useful form of strings
10:29:11 <audreyt> [Word8] makes sense. so does [Grapheme]
10:29:16 <imix> is there no select (for synchronous I/O multiplexing) system call?
10:29:24 <musasabi> audreyt: has a point.
10:29:25 <jyp> tuomov, maybe then [a] needs a better implementation a :-)
10:29:33 <musasabi> imix: use threads, they are very cheap.
10:29:43 <tuomov> jyp: one of the simplified forms of unicode
10:29:56 <tuomov> there being multiple representations for a grapheme or whatever is stupid.
10:30:20 <imix> musasabi: ok, thanks
10:30:31 <jyp> Then you mean Char is stupid ?
10:31:07 <tuomov> As far it is understood to include arbitrary unicode, yes
10:31:24 <tuomov> unicode is way too difficult to deal with
10:32:01 <jyp> I'm pretty convinced that most of the overhead is due to the list aspect than to unicode though
10:32:30 <tuomov> I'd prefer an encoding that didn't include accented versions of characters etc., and mark combining characters so that it's easi to spot them without knowing much of the semantics
10:32:48 <jyp> tuomov, I agree with you on that point...
10:33:10 <jyp> chinese stuff in unicode is quite a mess
10:33:15 <tuomov> jyp: [WhateverTypeCharactersUse] rocks, though, and shouldn't be dumped. It just needs a more efficient implementation
10:33:30 <tuomov> under the hood
10:34:03 <musasabi> tuomov: the problem is that codepoint != logical character.
10:34:13 <tuomov> utf-8 is an example of an excellent encoding.. if unicode used a similar method to combine codepoints into logical chracters
10:34:24 <jyp> Ok, there are two orthogonal and parallel paths for improvements then :)
10:34:25 <tuomov> as utf-8 combines bytes to codepoints
10:34:48 <tuomov> you don't need to know what the characters mean when processing utf-8
10:35:13 <tuomov> s/characters/bytes/
10:35:26 <tuomov> C char corrupts thinking
10:35:27 <musasabi> tuomov: if one is sorting it, then one will have the same issues as otherwise.
10:35:44 <tuomov> well, there's no universal sorting even for latin1
10:36:25 <tuomov> if you want to sort by the locale
10:37:20 <musasabi> yes, one needs a locale for unicode too.
11:19:29 <imix> if I use multiple threads for socket communication, how do i cleverly connect them? (i don't see an elegant solution without select)
11:22:55 <musasabi> what are you trying to do?
11:25:11 <Micket> Hello! I'm trying to read a file, but it seems it will only read it until it reaches a NULL value, so it just reads the first 4 characters for me. Any tips?
11:25:18 <imix> a server which allows multiple clients to connect at the same time. the server can then send commands to one or more clients depending on it's state.
11:25:48 <musasabi> Micket: are you using readFile ?
11:26:24 <musasabi> imix: why is this hard with threads and either MVars, Chans or STM ?
11:26:47 <Micket> musasabi: Yes i am.
11:27:19 <jyp> fyi, I updated http://haskell.org/hawiki/FutureOfHaskellDiscussionDiscussion
11:27:59 <jyp> (cleanup of IRC transcript)
11:29:15 <imix> musasabi: because i'm rather new to haskell and don't have yet an overview of the usful tools. I will read about them now.
11:30:23 <musasabi> Micket: works for me:
11:30:27 <musasabi> print =<< (return . take 20) =<< readFile "/dev/zero"
11:31:07 <musasabi> imix: the concurrent haskell paper could be a good starting point, if you like fancy things maybe look into STM
11:35:07 <imix> musasabi: found it, I will have a look at STM (yes, i like fancy things), thanks
11:46:32 <musasabi> Is Data.Map differenceWith lazy? Especially how much does it cost if I just want to see whether it is null or not ?
11:47:54 <Micket> musasabi: I just got around to test what you wrote. It still only prints out the first 4 characters for me. (I'm using GHC, on windows xp)
11:51:07 <jyp> musasabi, Data.Map is strict iirc
11:52:17 <musasabi> jyp: ok, then I will just handimplement it.
11:52:49 <musasabi> Micket: strange, the same with binary files? (windows has such an evil distinction)
11:53:17 <Micket> Uhm, Actually this is a binary file. Forgot to mention that, my mistake!
11:53:50 <musasabi> does openBinaryFile help?
11:54:13 <Micket> I'll look it up, thanks!
11:54:41 <musasabi> do readBinaryFile fp = openBinaryFile fp ReadMode >>= hGetContents
11:54:56 <musasabi> in System.IO
11:58:41 <Micket> Uhm. Not in scope "readBinaryFile"
12:02:44 <Micket> ack! hugs specifik :(
12:03:17 <rep> what's your opinion on attribute grammars
12:08:44 <jyp> rep, I'm a huge fan, bug I never got the chance to use them :)
12:57:47 <[CotL]Godofe_Kei> evening
13:09:27 <[CotL]Godofe_Kei> Program error: pattern match failure: testaConcorrente2 [(Num_fromInt instNum_v30 3,Num_fromInt instNum_v30 4,1),
13:09:27 <[CotL]Godofe_Kei> (Num_fromInt instNum_v30 3,Num_fromInt instNum_v30 4,Num_fromInt instNum_v30 2)] [] 
13:09:32 <[CotL]Godofe_Kei> what does this error mean?
13:12:12 <basti_> you didn't expect all possible cases
13:12:52 <[CotL]Godofe_Kei> but if i put the last case like = [], the function only gives me the first case
13:13:15 <basti_> uh?
13:13:15 <[CotL]Godofe_Kei> and ends
13:13:22 <[CotL]Godofe_Kei> its suposed to work recursivelly
13:13:23 <basti_> do you want to recurse?
13:13:30 <basti_> well then you -should- recurse ^^
13:13:38 <[CotL]Godofe_Kei> ?
13:14:00 <basti_> well i don't see your problem exactly, but i think you miss both the one case, and the recursive call
13:14:37 <[CotL]Godofe_Kei> http://paste.lisp.org/display/14987
13:14:48 <[CotL]Godofe_Kei> and for explanation: http://paste.lisp.org/display/14990
13:15:27 <phys_rules> merry christmas to everyone ;)
13:15:32 <[CotL]Godofe_Kei> same to you
13:16:56 <basti_> hmmm
13:17:30 * [CotL]Godofe_Kei prays for an answer
13:18:00 <basti_> you seem to expect that both lists are empty, but not that only one is
13:18:16 <[CotL]Godofe_Kei> yes but ive tried to solve it but i cant
13:18:26 <basti_> yea thats why youre here
13:18:31 <basti_> i understood that much :D
13:18:35 <[CotL]Godofe_Kei> lol
13:20:00 <basti_> did you think about what would happen if one list is empty and the other isn't?
13:20:42 <[CotL]Godofe_Kei> well,all i have learned is to end those cases with []
13:21:05 <[CotL]Godofe_Kei> i tried to put xxxxxx [] _ = [], and _ [] = []
13:21:10 <basti_> but?
13:21:13 <basti_> didnt that help?
13:21:16 <[CotL]Godofe_Kei> nop
13:21:27 <basti_> why didnt you let it in?
13:21:41 <[CotL]Godofe_Kei> cause if i put testaConcorrente2 _ [] = [], then the result will be only 1
13:21:48 <[CotL]Godofe_Kei> 1 list element
13:21:52 <[CotL]Godofe_Kei> the recursion stops
13:22:08 <basti_> hmm and why? :P
13:22:16 <[CotL]Godofe_Kei> beats me...
13:22:31 <basti_> what does "_" say?
13:22:38 <[CotL]Godofe_Kei> anything
13:22:45 <basti_> yea.
13:22:50 <basti_> so you match anything and the empty list
13:22:59 <basti_> so if you got anything and the empty list, the recursion stops
13:22:59 <[CotL]Godofe_Kei> yes i understand why it breaks
13:23:04 <basti_> do you have the empty list there?
13:23:09 <[CotL]Godofe_Kei> no
13:23:14 <[CotL]Godofe_Kei> but eventually it will be empty
13:23:15 <basti_> are you sure? ^^
13:23:42 <basti_> I don't understand your function well enough to say what should be right and what should be not
13:23:53 <[CotL]Godofe_Kei> have you read the explanation?
13:24:01 <basti_> yes.it didn't help a lot
13:24:09 <[CotL]Godofe_Kei> its realy simples
13:24:13 <[CotL]Godofe_Kei> simple*
13:24:19 <[CotL]Godofe_Kei> its just hard to explain
13:24:23 <basti_> >_<
13:24:29 <[CotL]Godofe_Kei> all it needs to do is this:
13:24:50 <[CotL]Godofe_Kei> get for example this: [(1,2,3),(3,4,1),(3,4,2)] 
13:24:57 <[CotL]Godofe_Kei> and this: [(1,"kjasgd"),(2,"ajhsgd"),(3,"asdsdas")]
13:25:09 <basti_> do you know lookup? ^^
13:25:19 <[CotL]Godofe_Kei> and see if the the last number (3) is == to the first number (1)
13:25:35 <[CotL]Godofe_Kei> if it is then it returns the string atached to (1)
13:25:40 <[CotL]Godofe_Kei> in some format
13:25:45 <basti_> @type lookup
13:25:46 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
13:25:57 <[CotL]Godofe_Kei> i dont know what that does
13:26:08 <basti_> > lookup 4 [(3,"hi"),(4,"hello"),(5,"hy!")]
13:26:10 <lambdabot> Just "hello"
13:26:42 <[CotL]Godofe_Kei> hmm
13:26:44 <[CotL]Godofe_Kei> interesting
13:26:52 <[CotL]Godofe_Kei> is it in prelude?
13:26:56 <basti_> yes i think so
13:27:18 <[CotL]Godofe_Kei> nice
13:27:27 <[CotL]Godofe_Kei> ill try and rewrite the function with that
13:27:28 <[CotL]Godofe_Kei> thx
13:27:31 <basti_> ^^
13:27:36 <[CotL]Godofe_Kei> should be easy right?
13:27:40 <basti_> yea quite
13:27:44 <basti_> zip might help too
13:27:45 <basti_> and map
13:29:21 <[CotL]Godofe_Kei> ok thx a lot m8
13:29:28 <[CotL]Godofe_Kei> sry to bother, i do this a lot
13:29:29 <[CotL]Godofe_Kei> :P
13:29:38 <basti_> do what?
13:29:43 <[CotL]Godofe_Kei> bother ppl...
13:29:47 <[CotL]Godofe_Kei> but your my last resort
13:29:48 <basti_> ...? ;)
13:33:54 <Pupeno> Do you think that it is worth it to learn parsec to parse command line options ?
13:35:26 <xerox> there are some options
13:35:40 <xerox> the standard library has something, pesco wrote some lib too
13:36:00 <Pupeno> xerox: for parsing command line options ?
13:36:08 <xerox> Yep.
13:36:13 <rep> getopt?
13:36:42 <Pupeno> xerox: can you give me some name or url ?
13:36:50 <Pupeno> rep: getopt in Haskell ?
13:36:56 * xerox thinks harder
13:37:01 <xerox> @docs
13:37:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:37:04 <rep> Pupeno i wouldn't be surprised
13:37:55 <xerox> @type System.Console.GetOpt.getOpt
13:37:57 <lambdabot> forall a.
13:37:57 <lambdabot> System.Console.GetOpt.ArgOrder a
13:37:57 <lambdabot> -> [System.Console.GetOpt.OptDescr a]
13:37:57 <lambdabot> -> [String]
13:37:57 <lambdabot> -> ([a], [String], [String])
13:38:35 <stepcut> Pupeno: I depends on how fancy you want your command-line arguments to be
13:39:30 <stepcut> As a low priority project, I have been trying to write a command-line parsing library that can also *generate* bash completion code -- but I don't actually have any code written yet :p
13:41:00 <stepcut> the problem is -- the scope command-line argument parsing is pretty unlimited (especially if you include validation) 
13:42:41 <araujo> Hello.
13:42:46 * araujo boings around
13:42:55 <rep> stepcut why not zsh completion code?
13:43:56 <stepcut> rep: I would probably allow for many completion code generators, since I use eshell...
13:44:12 * rep has never head of eshell
13:44:17 <stepcut> M-x eshell
13:44:20 <rep> oh
13:44:33 <stepcut> its a bit wacky, I don't really recommend it
13:44:46 <rep> then why do you use it
13:45:21 <stepcut> I like some aspects of it, and I know most of the pitfalls now
13:46:52 <stepcut> the best way I can figure to handle the completion is to have bash/zsh/etc invoke the app itself and have the app provide the actual completion
13:48:28 <flux__> but the capability to do such stuff would have to be tagged in some ELF-readable header, or in a separate file
13:48:48 <flux__> because you just can go around running unknown software ;)
13:48:56 <flux__> but I admit, that would be the cleaneast option
13:50:02 <stepcut> flux__: I think it is probably something you would enable on a per application basis
13:53:08 <xerox> there also is M-x shell
13:53:13 <xerox> which is less wacky, in some sense
13:54:17 * araujo uses hashell and is proud of it
13:55:04 <flux__> hashell is quite invisible. to google, that is.
13:55:11 <flux__> @where hashell
13:55:12 <lambdabot> haskell.org/hashell
13:55:34 <flux__> araujo, is hashell your actual $SHELL?
13:56:02 <xerox> @google hashell
13:56:04 <lambdabot> http://www.all-creatures.org/discuss/abuse-hashell.html
13:56:05 <xerox> @google hashell dons
13:56:06 <lambdabot> http://tunes.org/~nef/logs/haskell/05.08.12
13:56:23 <xerox> @google hashell dons haskell shell
13:56:24 <lambdabot> http://tunes.org/~nef/logs/haskell/05.08.12
13:56:27 <xerox> -_-
13:56:51 <flux__> well, it's relevant, but..
13:57:08 <flux__> maybe google will learn that url some day.
13:57:54 <xerox> aah, it's not h4sh.
13:58:01 <flux__> wasn't there some haskell library targeted to writing shell-script-like code?
13:58:16 <flux__> does hashell have anything to do with that?
13:58:18 <araujo> flux__, Not _yet_ working toward that though
13:58:20 <xerox> @where h4sh
13:58:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
13:58:24 <xerox> ^- that one
13:58:26 <araujo> flux__, no, nothing
13:58:35 <stepcut> I am *also* worknig on a shell-script-like library for haskell 
13:58:45 <araujo> flux__, hashell is kind of different than that
13:59:13 <flux__> yeah, I figure, but it can be valuable to the user to have that h4sh installed, nevertheless?
13:59:20 <araujo> flux__, i don't worry about adding library for making dirs, or remove them for example, i just care about using Haskell as my shell-scripting language.
13:59:32 <stepcut> I am on the third revision of my code -- which may actually be releasable :p
13:59:42 <flux__> because IMO those examples in the examples page aren't terribly convincing ;-)
14:00:10 <araujo> ?
14:00:30 <flux__> (as in that using haskell as a shell language would bring more expressiveness with more ease of use)
14:00:47 <flux__> well, I didn't try to rewrite those in zsh/perl, but atleast they are long ;)
14:01:04 <araujo> flux__, i find it more natural than bash or any current shell :-]
14:01:36 <flux__> for example the monad shell (the microsoft one) examples seemed infact quite nice, but of course the advantage there comes from having a set of monad-aware tools around
14:02:16 <flux__> with hashell, you can write functions that play nicely with the type system, but how about scripts?
14:02:27 <flux__> (I assumed the part about writing functions)
14:02:46 <araujo> flux__, hashell is very recent. Ive got some ideas which i am still implementing.
14:02:56 <araujo> I need to get it more script-friendly.
14:03:27 <araujo> Though you already can write nice scripts for 'real' world tasks.
14:03:42 <flux__> hm, actually h4sh wasn't what I was thinking
14:03:44 <araujo> One line scripts so far.
14:03:53 <araujo> mm.. 
14:04:01 * araujo is talking about hashell
14:04:26 <flux__> yes, yes :-)
14:04:42 <flux__> but now I actually surfed the h4sh page and I don't think it is what I was talking about earlier
14:04:51 <araujo> Iyt is _still_ very primitive in comparison wiht other shells. But it does basic things very well now.
14:05:21 <flux__> hsshellscript is what I meant
14:05:27 <araujo> haha
14:05:39 * araujo throws a lambda at flux__ 
14:06:08 <flux__> am I missing something? you suggested h4sh, I just accepted it ;)
14:06:23 <araujo> mm.. not h4sh :-P
14:07:02 <flux__> oh, it was xerox
14:07:17 <flux__> who suggested it
14:08:00 <xerox> > length "oh, it was xerox" == length "who suggested it"
14:08:01 <lambdabot> True
14:08:28 <flux__> anyway, hsshellscript has stuff like analyzing path components, building pipes, interfacing with external programs, all that could be a nice fit to writing stuff for shells in haskell, and maybe hence with hashell
14:09:29 <flux__> it doesn't appear to be maintained, though (last release at may)
14:09:59 <flux__> otoh the page says it is maintained, so maybe I'm just judging too fast ;)
14:12:20 * araujo though uses it as an example
14:15:06 <araujo> flux__, hsshellscript is like a shell inside a library.
14:15:09 <araujo> I am not taking that way at all.
14:15:13 <araujo> I am just build a framework (i hope it keeps small enough) between a command line and the GHC RTS
14:15:17 <araujo> *building
15:00:20 <ski> @index catch
15:00:21 <lambdabot> Control.Exception, System.IO.Error, Prelude
15:00:35 <ski> @type Control.Exception.catch
15:00:36 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
15:01:10 <ski> @hoogle IO a -> (a -> IO b) -> (GHC.IOBase.Exception -> IO b) -> IO b
15:01:12 <lambdabot> No matches, try a more general search
15:01:14 <{Arias}> bye
15:01:28 <ski> @hoogle IO a -> (a -> IO b) -> (exn -> IO b) -> IO b
15:01:30 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO
15:01:30 <lambdabot> c
16:07:40 <greenrd> @eval sequence [[1,2,3],[4,5,6]]
16:07:43 <lambdabot> [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
16:08:30 <mauke> @typo sequence
16:08:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:10:49 <ski> that's a nice typo
16:26:40 <imix> quit
16:27:19 <imix> or not quit, guess i'm too tired to get commands right ;)
16:36:27 <palomer> how do I import the state monad?
16:37:07 <palomer> ugh, it's not supported by hugs
16:37:11 <ski> import Control.Monad.State ?
16:37:47 <ski> hm ?
16:38:49 <palomer> ERROR "/usr/lib/hugs/packages/mtl/Control/Monad/Reader.hs":46 - Haskell 98 does not support dependent parameters
16:39:38 <palomer> if I'm going to use the State monad, what should be the type of substitute? State Term -> State Term -> string -> State Term?
16:40:31 <ski> give flag '-98' to hugs
16:41:17 <palomer> running it from emacs
16:41:24 <ski> 'substitute' ?
16:41:48 <palomer> substitute t u v = t[u/v] 
16:42:12 <ski> why do you want this to be in state monad ?
16:42:24 <palomer> yeah, because substitute needs to create new variable names
16:42:28 <palomer> to avoid capture
16:42:31 <ski> ah, ok
16:42:53 <ski> prolly  'Term -> Term -> String -> State Foo Term'
16:43:23 <ski> (think of kleisli category)
16:43:25 <palomer> but substitute will call itself recursively
16:43:31 <ski> so ?
16:43:45 <palomer> we don't want recursive calls to reuse the same variable names
16:43:59 <ski> so ?
16:44:28 <palomer> how would substitute know which variables we've already used if we don't pass a State?
16:44:59 <ski> we pass a state
16:45:07 <ski> 'State' otoh is the state monad
16:45:19 <palomer> right, but Term -> Term -> String -> State Foo Term doesn't pass a State
16:45:26 <ski> sure it does
16:45:32 <palomer> it passes 2 terms and a string!
16:45:40 <Pupeno> Having this [TCP "13",UDP "13"], [UDP "13",TCP "13"], [TCP "13"], [UDP "13"] or _ I want to generate {streamPort = "13", dgramPort = "13"}, {streamPort = "13", dgramPort = "13"}, {transports = Stream, streamPort = "13"}, {transports = Datagram, dgramPort = "13"}, or an error, any common idiom that can help me ? (I have encountered this before).
16:45:43 <ski> State Foo Term  ~=  Foo -> (Foo,Term)
16:46:05 <palomer> Foo -> (Term, Foo)
16:46:08 <lennart> palomer: if you're not doing something very serious there's no need to use a state monad to generate new names.  you can do it much more easily.
16:46:15 <palomer> lennart: how?
16:46:16 <ski> here, 'Foo' is the state type
16:46:37 <palomer> runState :: (s -> (a, s))	
16:47:25 <lennart> when you detect that you're about to clash, just collect all names that are in use in the terms you are working with and pick one not in that set
16:47:51 <palomer> lennart: yeah, extremely slow
16:48:00 <lennart> have you tried?
16:48:27 <lennart> i've used it several times.  it's not been the bottleneck in what i did
16:49:03 <lennart> but it depends on what you're doing
16:50:18 <palomer> besides, state is a good learning experience
16:51:10 <lennart> that's true.  if you've never done it that way, you should.  but just for fun, you should try without state too.
16:51:33 <lennart> that saving grace of the method i mentioned is that names don't clash too often.
16:51:56 <palomer> lennart: good point
16:52:13 <palomer> we really shouldn't do lambda calculus with variables
16:52:24 <palomer> we should really transform them into numbers and work with that
16:52:48 <lennart> yeah, but deBruijn indicies are a pain too
16:52:57 <palomer> how so?
16:53:14 <palomer> this way we have a greatest number, which we can pass around
16:53:24 <palomer> and equality is much faster
16:53:27 <palomer> everything is faster, in fact
16:53:38 <palomer> anyways, I should really learn about state
16:53:53 <lennart> are you talking about using numbers as variables or using deBruijn indicies?
16:54:32 <palomer> lennart: yeah
16:54:34 <lennart> deBruijn indicies are great if you need to compare modulo alpha renaming
16:55:04 <palomer> or just use tha standard lambda calculus, but replacing strings with numbers
16:55:35 <lennart> but that's a different matter.  then you're still stuck with inventing new names
16:55:44 <palomer> lennart: but you can pass around a greatest number counter
16:55:53 <ski> HOAS ?
16:56:09 <palomer> and then you're sure not to have any clashes
16:56:14 <lennart> yeah HOAS should be experienced too :)
16:56:27 <palomer> anyways, who thinks my substitute function should have type Term -> Term -> String -> State Term?
16:56:35 <lennart> but passing around the greatest number is exactly like the state you're doing now
16:56:47 <lennart> palomer:  that's the one!
16:56:54 <palomer> lennart: true, but my method isn't guarenteed to work
16:57:03 <palomer> lennart: now, why the hell should substitute have that type?
16:57:13 <palomer> lennart: doesn't substitute need to know from which number we should state?
16:57:16 <palomer> shouldn't we pass a state to it?
16:57:17 <ski> in lambdaProlog one can patternmatch on lambda terms .. and there was some paper with an extension to ML with a similar feature ..
16:57:26 <lennart> Except I would not use String.  I would call it Symbol, or Name or something.  SO you can change it easily later
16:58:02 <lennart> reFLect has some interesting reflection pattern matching on lambda term.  but not really related to this
16:58:31 <ski> palomer : you *are* passing state to it
16:58:48 <palomer> ski: but none of the parameters are state
16:59:01 <lennart> it's in the monad
16:59:11 <ski> none of the *explicit* parameters is the state
16:59:34 <ski> Term -> Term -> String -> State Foo Term  ~=  Term -> Term -> String -> Foo -> (Term,String)
16:59:49 <palomer> Foo = String ?
16:59:53 <ski> since  State Foo Term  ~=  Foo -> (Term,Foo)
17:00:04 <ski> i dunno what your state type is here
17:00:12 <palomer> Foo -> (Term, String)
17:00:39 <ski> er
17:00:43 <ski> Term -> Term -> String -> State Foo Term  ~=  Term -> Term -> String -> Foo -> (Term,Foo)
17:00:49 <palomer> gotcha
17:00:54 <ski> (should have said that, mea culpa)
17:00:57 <palomer> lennart: so I should have newtype symbol = string
17:01:16 <palomer> lennart: and I should create a typeclass with members increment and getString?
17:01:27 <palomer> heck, all I need is equality
17:01:34 <palomer> increment and equality
17:01:35 * ski wonders why a typeclass
17:01:54 <palomer> because how would I change the Symbol type later on?
17:02:08 <ski> just plain ADT
17:02:09 <lennart> Oh, I'd probably start with either 'type Symbol = String' or 'newtype Symbol = Symbol String'
17:02:32 <lennart> a typeclass is probably overkill at this point
17:02:39 <palomer> but I will use if I use string
17:02:44 <palomer> so I can't change Symbol for anything else
17:03:03 <lennart> an ADT is probably the way to go
17:03:12 <palomer> ADT?
17:03:18 <palomer> abstract data type
17:03:18 <palomer> yes
17:03:20 <ski> abstract data type
17:03:22 <lennart> then you can add an Int to the Symbol type later, and use that for the equality test
17:03:30 <palomer> haskell has syntactic sugar for ADTs?
17:03:36 <lennart> no
17:04:22 * ski 'd like local modules, though
17:04:35 <palomer> how do I implement an ADT in haskell?
17:05:24 <ski> strictly, you need to put it in a separate module, and then only export type and ops on that type (not type impl)
17:05:55 <lennart> palomer: don't over-engineer it if it's the first time you're doing this
17:06:00 <lennart> keep it simple
17:06:18 * ski 'd prolly put it in same module, to begin with, though, and exercise dicipline to just use ADT ops
17:06:38 <lennart> type Symbol = String is fine.
17:06:55 <lennart> you can refactor later
17:07:30 <palomer> someone remind me the capture rules
17:07:40 <palomer> can't find them anywhere in wikipedia
17:08:03 <palomer> oh, I remember
17:08:24 <lennart> if the lambda you are just going under binds something that is free in what you substitute in, you're in trouble
17:09:21 <lennart> furthermore, if the lambda binds the same variable as you're substituting for, you should stop
17:11:05 <lennart> a worthwhile "trick" is to compute the free variables in the term you're substituting in once
17:13:54 <palomer> lennart: good point
17:14:00 <palomer> hrm, I still don't get how to use State
17:14:02 <palomer> it boggles my mind
17:15:06 <ski> when you see 'a -> State Foo b', you think impure function from 'a' to 'b' which can modify a state of type 'Foo
17:15:08 <ski> '
17:17:41 <palomer> how do I modify this state?
17:18:01 <ski> set :: foo -> State foo ()
17:18:11 <ski> get :: State foo foo
17:19:18 <ski> also
17:19:22 <palomer> x<-get; set (x+1) ?
17:19:28 <ski> modify :: (foo -> foo) -> State foo ()
17:19:32 <ski> yes
17:20:56 <dsacode> Hello! Can i separate list in list of lists by N elements? So if i have N = 2 and list [1,2,3,4,5], i want to get [[1,2],[3,4],[5]]
17:22:45 <ski> > let chunkify n = unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs)) in chunkify 2 [1,2,3,4,5]
17:22:47 <lambdabot> [[1,2],[3,4],[5]]
17:23:02 <dsacode> ski: Thank you
17:23:59 <lennart> The Prelude should have had a function foo, so you could have done 'foo (splitAt 2) [1,2,3,4,5]'
17:24:20 <lennart> It's a function I use fairly frequently.
17:24:31 <lennart> sadly missing
17:24:34 <palomer> @hoogle toString
17:24:36 <lambdabot> System.Time.timeDiffToString :: TimeDiff -> String
17:24:36 <lambdabot> System.Time.calendarTimeToString :: CalendarTime -> String
17:24:36 <lambdabot> Network.URI.uriToString :: (String -> String) -> URI -> ShowS
17:24:47 <palomer> how do you transform a number to a string?
17:24:50 <lennart> show
17:25:00 <ski> lennart : yes, i seem to have written many 'unfoldr's like this ..
17:27:48 <saccade> can the hugs interpreter run in emacs?
17:28:00 <dsacode> ski: `unfoldr' is undefined at my hugs :(
17:28:04 <dsacode> saccade: sure
17:28:10 <dsacode> saccade: 'inf-haskell.el'
17:28:24 <ski> @index unfoldr
17:28:25 <lambdabot> Data.List
17:28:32 <dsacode> saccade: or 'haskell-hugs.el'
17:29:09 <dsacode> ski: isn't it possible to done with only Prelude ? :(
17:29:20 <lennart> dsacode: did you find your primes? :)
17:29:29 <dsacode> lennart: some kind of :)
17:29:53 <dsacode> lennart: i've found more or less effective solution in 'docon'
17:29:56 <palomer> how does one use "as" in haskell?
17:30:10 <ski> dsacode : of course you can write your own 'unfoldr', and then if you like unfold it's definition into it's use
17:30:16 <saccade> is 
17:30:18 <saccade> hm
17:30:25 <ski> palomer : 'xs0@(x:xs)'
17:30:30 <lennart> dsacode: I don't know if you saw my onelines, but it's not bad
17:30:43 <lennart> one-liner, i mean
17:30:48 <ski> palomer : hm .. or did you mean the keyword 'as' in haskell ?
17:30:55 <palomer> like
17:31:05 <ski> palomer : 'import qualified FooBar as FB' in that case
17:31:07 <dsacode> ski: what's about this problem, if i need only to take N-th items in list? so, for N=2 and [1,2,3,4,5] it will be [2,4]
17:31:11 <palomer> foo (somename as blargh) = ...
17:31:30 <ski> palomer : 'foo somename@blargh = ...'
17:31:44 <palomer> and that binds blargh to the name somename, right?
17:31:52 <palomer> how tightly does @ bind?
17:32:02 <ski> not so, iirc
17:32:11 <palomer> that binds somename to blargh?
17:32:43 <ski> 'somename' should be a variable name, 'blargh' is a sub-pattern
17:32:57 <dsacode> lennart: which one?
17:33:27 <lennart> primes = (2::Int) : filter (isPrime primes) [3,5..] where isPrime (p:ps) n = p*p > n || n `mod` p /= 0 && isPrime ps n
17:33:42 <lennart> Or Integer, if you prefer
17:33:50 <dsacode> lennart: hehe, i've with some similar solution, actually
17:34:07 <saccade> okay, so I loaded that
17:34:08 <ski> lennart : that was interesting, yes
17:34:19 <saccade> I don't have an M-x run-haskell command or anything that I can find
17:34:23 <dsacode> primes = 2 : 3 : 5: filter isPrime
17:34:23 <dsacode>         [ a+b | a <- [30, 60 ..],
17:34:23 <dsacode>                 b <- [-23,-19,-17,-13,-11,-7,-1,1]]
17:34:52 <dsacode> lennart: but it's not so effective for big primes
17:35:01 <dsacode> lennart: but i can continue this function :)
17:35:16 <palomer> substitute (target@(Lambda s t)) u v | s == v = (return target) <--anyone see a parse error here?
17:35:26 <dsacode> ski: can you help me with that another problem?
17:35:36 <lennart> yes, you can improve the number generation as much as you like.  my simple one just took the first step by using odd numbers
17:36:03 <dsacode> lennart: yes, my just used not only 2, but 3 and 5, and we can continue this function to infinity
17:36:18 <dsacode> lennart: it will be nice to write function that will write this function for some N
17:36:19 <ski> palomer : see no parse error (but those parens around first arg is superfluous)
17:36:50 <lennart> dsacode: yes, you can generate it dynamically
17:37:22 <palomer> http://www.rafb.net/paste/results/pfSVhY91.html <--my substitute function
17:37:30 <palomer> giving me a parse error on the first line
17:37:32 <lennart> palomer: (and the parens around the rhs are superflous too)
17:37:33 <ski> (palomer : also, parens around the body there is also superfluous)
17:39:12 <ski> remove the 'in' (and indent the stuff after)
17:39:40 <ski> 'let'-commands in 'do'-notation have no 'in'
17:40:25 <lennart> palomer: does get increment the counter as well?
17:40:36 <palomer> lennart: oh no, I'll do that later
17:40:45 <palomer> once I get rid of the pesky parse errors
17:41:15 <lennart> palomer: the safest way is to make a function that returns the current value and increments in one go.  so you don't forget the increment
17:43:06 <palomer> http://www.rafb.net/paste/results/Xh7A1F60.html <-corrected version
17:43:08 <ski> palomer : your code got parsed as 'do {x <- get; let newName = getNewString x; in ...}' .. since the 'in' was in the same column as the other 'do'-commands, it got interpreted as starting another 'do'-command. which then triggered a syntax error
17:44:15 <ski> palomer : i think you may want the 'set' before the recursive call ..
17:44:44 <palomer> good point
17:44:47 <palomer> but it's the parse error!
17:44:53 <ski> ?
17:44:59 <palomer> still doesn't parse
17:46:13 * ski gets no parse error on that ..
17:46:52 <palomer> oh, it was from the line before
17:47:02 <palomer> set isn't in scope!
17:47:19 <ski> err
17:47:26 <ski> that should be 'put'
17:47:33 * ski is tired
17:51:36 * ski thinks he'll head for bed, in fact
17:59:35 <palomer> hrm
17:59:40 <palomer> does haskell evaluate inside lambdas?
17:59:58 <stepcut> ??
18:00:27 <palomer> nevermind
18:00:37 <stepcut> :p
18:04:57 <mwc> Ugh. Went to dinner for 22, 16 present
18:05:08 <mwc> 25 lbs of turkey, a 10 lbs ham
18:05:16 <mwc> so much gluttony
18:05:57 <palomer> sweet sweet gluttony
18:06:01 <palomer> I'm boycotting turkey
18:06:04 <palomer> had ray beef and raw fish
18:06:06 <palomer> yummy
18:07:46 <palomer> : undefined reference to `__stginit_ControlziMonadziState_'
18:07:54 <palomer> eh?
18:08:48 <palomer> I get that error when I try to compile
18:10:08 <stepcut> you might need to add a -package line
18:10:15 <stepcut> hold on
18:10:32 <stepcut> -package mtl
18:10:58 <palomer> what's mtl?
18:11:04 <stepcut> no idea
18:11:17 <stepcut> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
18:11:29 <palomer> oh
18:11:31 <stepcut> on the top of that page it says control.monad.state is in the package mtl
18:11:45 <palomer> what's the showsPrec member of Show?
18:11:47 <stepcut> mtl
18:11:47 <stepcut>     A monad transformer library, 
18:12:04 <stepcut> in stands for shows Precedence
18:12:16 <stepcut> i am not quite sure how you use it though
18:12:23 <palomer> do I have to implement it?
18:12:27 <stepcut> no
18:12:37 <palomer> how do I find out what members I have to implement to satisfy a typeclass?
18:13:36 <mwc> Check the docs?
18:13:47 <mwc> What typeclass are you interested in?
18:13:59 <palomer> Show in this case
18:14:06 <palomer> so :i can't tell me?
18:14:37 <stepcut> palomer: if the docs do not say, then you might have to look at the source, or just try a few and see if the compiler complains
18:14:46 <mwc> palomer, hoogle it: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AShow
18:14:55 <palomer> @hoogle Show
18:14:56 <lambdabot> Prelude.Show :: Show a
18:14:56 <lambdabot> Prelude.show :: Show a => a -> String
18:14:56 <lambdabot> Text.Show.Show :: Show a
18:15:27 <palomer> how do I search for the documentation for a  typeclass/function/module
18:15:29 <palomer> ?
18:15:59 <mwc> palomer, http://www.haskell.org/hoogle/
18:18:01 <palomer> nice
18:23:34 <palomer> we should have a command line hoogle!
18:24:10 <mwc> @hoogle foldl
18:24:11 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
18:24:11 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
18:24:11 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
18:24:17 <mwc> I thought we did
18:24:32 <mwc> Although if you mean a command line version. I think one is in the works
18:24:39 <mwc> er, I mean, a client-side version
18:25:17 <Saulzar> I just use the shortcuts in konqueror "hg: someHaskellTerm"
18:27:24 <palomer> yeah, client side version
18:30:32 <mwc> palomer, http://www.haskell.org/hoogle/download.htm you can download source now, run it on a home webserver
18:30:40 <mwc> but that's not quite good enough
18:30:53 <Saulzar> Could probably make up a tiny script to do it though
18:31:19 <palomer> oh yeah! my lambda calculator works
18:31:50 <palomer> we should also have an ncurses version!
18:31:58 <palomer> and a the corresponding gtk version
18:32:10 <Saulzar> It's not much use without being able to follow the link though
18:32:20 <Saulzar> So I'm not sure what a client side version would do?
18:33:20 <palomer> well, the ncurses version would let you scroll down with the keys
18:34:38 <palomer> the State monad is pretty cool
18:34:43 <palomer> though I still don't know how it works
18:34:56 <palomer> :O(
18:35:59 <palomer> where are all the datastructures located?
18:36:00 <palomer> Data?
18:36:27 <mwc> There's a pile of them in there, yep
18:36:38 <palomer> things like dictionary
18:36:40 <palomer> hashmap
18:36:42 <palomer> ...
18:36:50 <mwc> yeah
18:37:14 <palomer> where's hashmap?
18:37:16 <palomer> @hoogle hashmap
18:37:18 <lambdabot> No matches found
18:37:28 <mwc> Data.HashTable, Data.Map
18:37:34 <palomer> ahh, gotcha
18:37:49 <palomer> it's time to write an interpreter!
18:38:01 <palomer> (the logical step after the lambda calculator, don't you think?)
18:48:08 <palomer> ghc evaluates main into an IO () value, right?
18:48:35 <palomer> and then the RTS takes this value and runs it
18:49:41 <CosmicRay> yes
18:49:52 <palomer> how do we define value?
18:50:16 <palomer> like, what is a value
18:52:17 <CosmicRay> I'm not sure I understand your question
18:52:26 <CosmicRay> an IO foo is an action
18:52:30 <CosmicRay> an action is sorta special
18:52:56 <CosmicRay> it is not a value in the normal sense
18:53:51 <palomer> it is, nonetheless, a value
18:53:57 <palomer> now, how do we define a value?
18:54:04 <palomer> is it a constructor applied to a value or a constructor?
18:54:32 <CosmicRay> I'm afraid I'm not the right person to ask these questions of
18:55:06 <palomer> what does the where keyword do?
19:01:28 <Saulzar> It's like let, but you can define all your terms after the resulting expression instead of before it
19:02:06 <palomer> hrmphhrmph
19:02:16 <palomer> is quickcheck easy to use for a newbie?
19:04:02 <palomer> I can't make heads or tails out of it
19:04:50 * araujo saluda a Nomius 
19:14:11 <CosmicRay> hrmm.  I could have sworn fastpackedstring is in debian.
19:14:41 <Saulzar> palomer, patience :)
19:18:36 <palomer> is there a reason Arbitrary isn't derivable?
19:20:40 <Saulzar> It's a library typeclass, not built in - probably
19:20:40 * palomer would like to generate arbitrary Terms (term is either a variable, a lambda or an application)
19:21:20 <Saulzar> You can make instances for that yourself...
19:21:39 <palomer> yeah, trying to figure out how
19:22:04 <Saulzar> instance Arbitrary Term where ... 
19:24:19 <palomer> yeah, it's the implementation of arbitrary which boggles me
19:24:33 <palomer> for trees, I would do:
19:24:56 <palomer> http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html#16
19:25:09 <palomer> but notice that the generation doesn't mention Branch!
19:25:14 <palomer> this boggles me
19:27:13 <palomer> tree' n | n>0 = 
19:27:14 <palomer> 	oneof [liftM arbitrary,
19:27:14 <palomer> 	       liftM2 subtree subtree]
19:27:32 <palomer> where's Branch in this code?
19:28:38 <stepcut> oneof ?
19:29:31 <palomer> eh?
19:30:17 <stepcut> sorry
19:30:24 <palomer> oneof :: [Gen a] -> Gen a
19:30:37 <stepcut> i think 'liftM arbitrary' generates Leafs or Branches ? 
19:31:23 <stepcut> hrm
19:31:26 <stepcut> maybe not
19:31:58 <palomer> I think it's a typo
19:32:03 <lisppaste2> Pupeno pasted "better way to write this ?" at http://paste.lisp.org/display/15012
19:32:27 <Pupeno> Is there a better way to write that code ? It'll look good with Lips' where.
19:32:36 <Pupeno> s/it'll/it'd/
19:32:46 <palomer> oh my, generating lambda terms is very trick business
19:32:53 <stepcut> palomer: could be..
19:32:53 <lisppaste2> Saulzar pasted "Dynamic entities" at http://paste.lisp.org/display/15013
19:33:44 <palomer> _very_ tricky
19:33:58 <palomer> maybe I should understand lift before preceeding
19:33:59 <Saulzar> It doesn't have to be "fair"
19:34:09 <palomer> Saulzar: yeah, but I don't want to use arbitrary strings
19:34:24 <Saulzar> You don't have to...
19:34:28 <palomer> because then none of the variables will be bound!
19:34:39 <palomer> so I should pick my strings from a smallish finite list?
19:34:50 <Saulzar> Good idea I suppose
19:37:22 <palomer> @hoogle oneof
19:37:23 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st
19:37:23 <lambdabot> Char
19:37:23 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
19:37:23 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st
19:37:23 <lambdabot> Char
19:37:31 <palomer> @type Test.QuickCheck.oneof
19:37:33 <lambdabot> forall a. [Test.QuickCheck.Gen a] -> Test.QuickCheck.Gen a
19:37:41 <lisppaste2> humasect pasted "here is one step to factor it pupeno." at http://paste.lisp.org/display/15014
19:39:25 <Pupeno> hi humasect!
19:39:43 <lisppaste2> Saulzar annotated #15012 with "Individually?" at http://paste.lisp.org/display/15012#1
19:39:57 <palomer> grr
19:40:00 <Pupeno> humasect: that's the same as the other one (almost).
19:40:10 <palomer> how would I turn a [Char] into a Gen Term ?
19:40:23 <palomer> @hoogle Gen
19:40:24 <lambdabot> Test.QuickCheck.Gen :: Gen a
19:40:24 <lambdabot> Data.Generics.Aliases.GenericT :: a -> a
19:40:24 <lambdabot> Data.Generics.Aliases.GenericQ :: a -> r
19:40:39 <palomer> @index Test.QuickCheck.Gen
19:40:40 <lambdabot> bzzt
19:40:54 <Pupeno> Saulzar: would you say that is the best way to write it ?
19:41:15 <Saulzar> Pupeno, Both our suggestsions are the same in essence :P
19:41:57 <Pupeno> Saulzar: yours and humasect's ?
19:42:04 <Saulzar> Yes
19:42:18 <humasect> oh
19:43:17 <Pupeno> Saulzar: I don't see how, humasect is like mine, but moving the case to the pattern matching of functions (I wrote it like that the first time, I didn't like it), yours at least avoids having code duplication (but it has one extra function and function call).
19:43:53 <lisppaste2> Pupeno annotated #15012 with "I have other worst cases of the same." at http://paste.lisp.org/display/15012#2
19:44:04 <humasect> well pupeno it's two steps
19:44:41 <Saulzar> Hmm
19:45:14 <palomer> hrmphrm
19:45:47 <palomer> http://www.rafb.net/paste/results/U20BqC85.html <--this is what I have
19:45:50 <palomer> it's obviously false
19:45:59 <palomer> how do I turn a list into a generator?
19:46:30 <palomer> ahh, found it
19:49:47 <palomer> @hoogle liftM
19:49:48 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:49:48 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
19:49:48 <lambdabot> r
19:49:48 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
19:49:48 <lambdabot> > m a3 -> m r
19:50:10 <palomer> is it just me or does liftM look like map?
19:50:34 <Saulzar> LiftM = fmap  for monads
19:50:56 <palomer> @hoogle liftM2
19:50:57 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
19:50:57 <lambdabot> r
19:56:20 <palomer> quickcheck is fun
19:56:27 <palomer> I have _no_ idea what I'm doing
19:56:36 <palomer> I'm just making sure it type checks:
19:56:37 <palomer> :P
20:00:03 <araujo> Yeah!!
20:00:25 * araujo found the way around the chars overlapping problem in the parsing
20:04:24 * Saulzar 's head is spinning, designing these data types is hard.
20:08:39 <palomer> programming in haskell is fun
20:08:44 <palomer> cuz I don't know what the heck I'm doing
20:09:47 <Saulzar> Oh yes :)
20:12:13 <palomer> yes! I used quickcheck to show that my eval wasn't idempotent!
20:12:19 * palomer hugs quickcheck
20:15:33 * palomer wonders if it's possible to change the quickcheck seed
20:16:54 <palomer> so what's the difference between let and where?
20:19:13 <rep> hello friends
20:22:31 <araujo> palomer, none, as far as i know....
20:22:51 <araujo> mm... well, you can use let inside 'do'
20:23:15 <palomer> someone remind me what's the exponentiation term for church numerals
20:23:37 <palomer> \n -> \m -> n m ?
20:25:38 <palomer> oh, woops, was using the wrong church numerals
20:25:40 <palomer> silly me
20:30:57 <palomer> I want to represent a computation that can fail
20:31:08 <palomer> oh, right, Maybe monad
20:32:21 <palomer> is there a better monad than the Maybe monad?
20:32:27 <palomer> (for computations that can fail)
20:33:58 <palomer> man haskell rocks!
20:38:28 <Pupeno> indeed.
20:39:26 <palomer> can I put a type annotation inside a where?
20:39:27 <Pupeno> my insight of today is that elegant algorithms in haskell look elegant on the screen and bad ones look bad.
20:39:43 <Pupeno> palomer: I believe so.
20:40:16 <palomer> how do I block comment?
20:40:25 <Pupeno> {-
20:40:29 <Pupeno> -}
20:41:09 <Pupeno> palomer: http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html is useful.
20:41:30 <palomer> hah, I'm having too much fun with this evaluator
20:43:36 <Cale> palomer: let is part of expression syntax, where is part of declaration syntax, and scopes over function guards
20:44:04 <Cale> and yes, you can put type declarations inside a where
20:45:30 <Cale> Pupeno: that's mostly true (re: elegance), but there are some rather efficient pieces of Haskell code which look terrible too :)  (Mostly just when the FFI starts to get involved, things can get scary :)
20:46:02 <Pupeno> Cale: FFI can ruin everything (I played with FFI in various languages)
20:46:58 <Pupeno> I bet there are algerithms that look bad in Haskell while being elegant, but generally, the oposite happens (well, to me).
20:47:05 <Cale> Pupeno: right
20:47:09 <Cale> same here
20:47:20 <palomer> if type A instatiates class C, how do I get an implemented member?
20:47:47 <Cale> palomer: hmm... 'member' as in, one of the functions which the class C defines?
20:47:52 <palomer> yeah
20:47:54 <Cale> you just use its name
20:48:08 <Cale> the type of thing you apply it to disambiguates it
20:48:08 <palomer> but, I want to say that it's A's member
20:48:20 <Cale> ah, you could give it an explicit type annotation
20:49:02 <Cale> or create a function with a more restrictive type signature, which is just defined to be equal to that class function
20:49:49 <palomer> do arbitrary pairs implement any typeclasses?
20:50:38 <palomer> ah yes, they can
20:50:40 <Cale> arbitrary pairs... not usually. Conditionally they do, and technically, they should at least do Functor, but they don't
20:50:47 <palomer> such as Arbitrary
20:50:56 <palomer> well, pairs of some class types
20:51:03 <palomer> ugh, I wish I knew the proper vocabulary
20:51:03 <Cale> (Show a, Show b) => Show (a,b)
20:51:24 <Cale> are you working with QuickCheck?
20:51:34 <Cale> just wonder if you mean that Arbitrary
20:51:59 <Cale> (Arbitrary a, Arbitrary b) => Arbitrary (a, b)
20:54:05 <palomer> yeah
20:54:17 <palomer> is that an actual statement?
20:56:18 <palomer> if I wanted to run tests on a subset of the integers I would have to use newtype, right?
21:00:21 <Cale> I think so
21:01:00 <Cale> well, you could use (==>), but it would likely be inefficient for many subsets
21:01:19 <Cale> I haven't actually used QC for much though
21:02:06 <Cale> hmm, 'elements' looks like it might also do what you want
21:02:22 <Cale> or 'choose', if your subset is an interval
21:02:33 <palomer> elements allNumbers?
21:02:42 <palomer> elements [1..]
21:05:11 <Cale> hmm, I don't know if it's suitably lazy
21:05:41 <Saulzar> I guess it would index a random element ...
21:06:21 <Saulzar> Then you're up the creek for an infinite list - how can you define a random number of infinite range anyway?
21:06:44 <Cale> you can use ==>
21:08:37 <Cale> prop_Something n = (n > 0) ==> ...
21:09:16 <palomer> whoa, haskell has ==>
21:09:18 <palomer> very cool
21:09:24 <Cale> QuickCheck has that
21:09:42 <palomer> haskell doesn't?
21:09:47 <palomer> @hoogle (==>)
21:09:48 <lambdabot> No matches found
21:09:52 <Cale> well, by extension :)
21:09:54 <palomer> @hoogle ==>
21:09:55 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
21:09:59 <palomer> oh, righto
21:09:59 <Cale> but it's really part of QC
21:10:14 <Saulzar> Haskell has operators..
21:10:56 <palomer> how do I get the associativity of ==>/
21:10:56 <Saulzar> > let x *$^ y = x + y in 3 *$^ 5
21:10:58 <lambdabot> 8
21:11:00 <palomer> ?
21:11:11 <palomer> Saulzar: what the hell is that?
21:11:24 <Cale> if you just want the usual one on booleans, you can define it for yourself  x ==> y = not x || y
21:11:31 <palomer> Cale: yeah
21:11:40 <Cale> hmm
21:12:01 <Cale> Prelude Test.QuickCheck> :info (==>)
21:12:01 <Cale> ==> :: Testable a => Bool -> a -> Property
21:12:01 <Cale>         -- Imported from Test.QuickCheck
21:12:01 <Cale> infixr 0 ==>
21:12:15 <Cale> so it's right associative
21:13:05 <palomer> ahh, gotcha
21:20:21 <palomer> Cale: exponentiation for church numerals is \n ->\m -> n m , right?
21:20:29 <palomer> call this term exp
21:20:41 <palomer> exp (church 2) (church 1) is giving me (church 1)
21:22:01 <palomer> and exp (church 3) (church 2) is giving me (church 8)
21:22:02 <Cale> m^n = n m
21:22:10 <Cale> heh
21:22:14 <Cale> that looks funny
21:22:18 <palomer> which looks funny?
21:22:23 <Cale> what I just wrote
21:22:35 <palomer> or, you have to reverse the order
21:22:59 <Cale> simply because you expect juxtaposition to mean multiplication in something like that, but it means application of course
21:24:31 <palomer> my lambda calculator is calculating 9^7
21:24:40 <palomer> let's see if it'll be able to
21:24:47 <palomer> can we store functions in lambda bot?
21:24:55 <palomer> everyone on this channel should have his own namespace for functions
21:25:43 <Saulzar> It's called /usr/bin/ghci I believe :)
21:26:11 <palomer> on lambdabot!
21:26:15 <Cale> the evaluator doesn't store definitions, but the lambda calculus evaluator does
21:26:28 <Cale> @listcommands
21:26:29 <lambdabot> use listcommands [module|command]. Modules are:
21:26:29 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
21:26:29 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
21:26:29 <lambdabot> seen spell state system todo topic type version vixen where
21:27:03 <Cale> hmm, does lShell do it, I wonder
21:27:14 <Cale> @help lShell
21:27:15 <palomer> according to the church numerals, 0^0 is undefined
21:27:15 <lambdabot> lShell provides: lam
21:27:15 <palomer> booya
21:28:14 <Cale> no
21:28:29 <Cale> It looks like 0^0 = 1 to me
21:28:44 <Cale> (\f x. x) (\f x. x) = (\x. x)
21:28:56 <Cale> = (\f x. f x)
21:29:06 <palomer> ok, in beta/alpha land it's undefined
21:29:08 <palomer> and eta is for chumps
21:29:16 <Cale> heh
21:29:39 <Cale> I love 0^0 = 1 as a definition though.
21:30:05 <palomer> it's convenient most of the time
21:30:33 <palomer> how do I get the instances from an old type when using newtype?
21:30:34 <Cale> The really nice defining property of exponentiation on the naturals is that n^m is the number of functions from a set of size m to a set of size n.
21:30:55 <palomer> n^m can be defined categorically too
21:31:15 <palomer> oh wait, it's similar to the function definition
21:31:15 <Cale> There's one function from the empty set to itself -- namely the empty function (or id, if you like)
21:32:05 <Cale> palomer: using deriving
21:32:38 <palomer> newtype Positive = Positive Int deriving Show
21:32:49 <Cale> oh, hehe
21:32:55 <Cale> Show is one of the funny ones though
21:32:56 <palomer> oh, nevermind
21:33:00 <palomer> Cale: why?
21:33:06 <Cale> you'll get the usual derived Show
21:33:14 <Cale> which shows the constructor
21:33:17 <Saulzar> Maybe Num is useful too :)
21:33:48 <Cale> Show is derivable on data declarations too
21:34:17 <Saulzar> It's pretty cool how that works, otherwise you waste a lot of time writing little printout wrappers for debugging
21:34:35 <palomer> how do you get random values in haskell?
21:34:37 <palomer> through the FFI?
21:34:45 <Saulzar> System.Random
21:34:49 <Cale> import System.Random
21:35:02 <palomer> so System.random throws referential transparency out the window
21:35:05 <Cale> no
21:35:25 <palomer> oh, it's pseudo random?
21:35:28 <Cale> yeah
21:35:37 <Cale> but it's in IO anyway
21:36:06 <Saulzar> You can use it outside of IO
21:36:09 <Cale> I suspect that the generator that newStdGen gives you uses the system entropy...
21:36:22 <Cale> but I'd need to check
21:36:38 <Cale> newStdGen :: IO StdGen
21:36:47 <Cale> so it's allowed to do something like that :)
21:36:53 <palomer> main is an IO () value, right?
21:36:55 <Saulzar> mkStdGen takes a seed
21:37:00 <palomer> what exactly is a value?
21:37:01 <Cale> yeah
21:37:31 <Cale> I usually say "value" to mean "of a type whose top level type constructor is not (->)
21:37:32 <Cale> "
21:38:02 <Cale> but then, in another perspective, functions are perfectly good values too
21:38:03 <Cale> :)
21:38:32 <palomer> I mean, if the IO () value is your program, then I could argue that IO can be seen as a product of evaluation
21:39:15 <Cale> Well, the IO to-do list that needs to be carried out is a product of evaluation
21:39:20 <palomer> man, my ghc is 500 megs, how do I tell it to collect its garbage?
21:39:34 <Cale> whereas I'd say that the process of carrying it out is something separate
21:40:10 <palomer> Cale: but I could apply that distinction to any programming language
21:41:01 <Cale> you could, but it wouldn't be as obvious why you were doing it :)
21:41:06 <palomer> quickCheck doesn't like elements [1..]
21:41:12 <Cale> yeah
21:41:18 <palomer> bastard
21:41:33 <palomer> so half my test cases are wasted
21:41:34 <Cale> use ==>, or write an instance of Arbitrary
21:41:37 <Saulzar> Then evaluation would mean nothing
21:42:05 <palomer> Saulzar: right
21:42:17 <palomer> so, there must be a definition of value which makes your statement meaningful
21:42:26 <palomer> (which applies)
21:42:38 <Cale> palomer: Computing which action to perform is different from performing it
21:43:08 <Cale> Computations which produce IO values are like meta-programs.
21:43:29 <palomer> not if you're computing which action to perform while you're performing it
21:43:39 <palomer> but what exactly is an IO value?
21:43:39 <Cale> oh, that's just laziness :)
21:43:48 <Saulzar> IO Int is not the same as Int - you have no int, all you have is some instructions which when executed will result in an int
21:43:53 <Cale> What an IO value is is implementation dependent
21:44:18 <Cale> I think GHC uses something like a State monad where the state is a special token of type RealWorld
21:44:19 <palomer> right, so an IO value can be the actual program with nothing changed
21:44:38 <palomer> and then your distinction becomes meaningless
21:44:46 <palomer> because we will be doing something which is exactly the same as evaluating
21:44:48 <Cale> I'm not sure I understand your point there
21:45:08 <palomer> the IO value could be an encoding of your program
21:45:10 <palomer> without any reductions
21:45:24 <Cale> oh, sure
21:45:26 <palomer> ie, the value IS your program as written
21:45:34 <Cale> but there's no evaluation to be done in that case
21:45:39 <Cale> only execution
21:45:49 <palomer> and then when you pass it to the runtime system, it will do the same thing as any other interpreter!
21:45:53 <Cale> (in my terminology at least)
21:46:14 <palomer> and so, I argue, haskell is as pure as any other programming language
21:46:20 <Cale> The IO monad is like an imperative sublanguage of Haskell
21:46:33 <Cale> But no, you're wrong :)
21:46:44 <Cale> If I have a function a -> IO b
21:47:06 <Cale> then I know that for any particular value of type 'a' that I give it, it will always compute the same IO action
21:48:19 <Cale> also
21:48:54 <Cale> If I have a function IO a -> b, where b doesn't involve the IO type, then I know that function throws away its parameter.
21:49:18 <Cale> For instance
21:49:25 <Cale> IO String -> Integer
21:49:33 <Cale> must be a constant function
21:50:08 <palomer> IO actions being the same isn't a very strong statement
21:50:21 <Cale> sure, but it's something :)
21:50:32 <gzl> can you define a type by placing arbitrary conditions on an existing type? like strings starting with a or floats in [0,1]?
21:50:46 <Cale> gzl: not in Haskell
21:50:54 <palomer> that would make things undecidable
21:50:55 <Saulzar> Hm, it's the same as anything else being the same ... a -> Int will always compute the same Int
21:51:01 <palomer> fo sizzle
21:51:09 <gzl> Cale: is it possible to do it statically at all?
21:51:15 <palomer> Saulzar: yes, but ints being the same is a very strong statement
21:51:22 <CosmicRay> her xerox
21:51:36 <Cale> gzl: In some languages, there are attempts at it, but you're getting into the domain of ridiculously hard problems.
21:51:46 <gzl> yeah
21:51:47 <Saulzar> palomer, What's the difference? IO Int is a value and Int is a value
21:52:05 <gzl> it's not provably impossible, though?
21:52:13 <Cale> Basically, if I had a compiler for such a programming language, I could solve half the open problems in mathematics tomorrow.
21:53:15 <gzl> how?
21:53:35 <palomer> Saulzar: if you think of IO int as your program and program equivalence means that it will always do the same thing, then you will agree that your statement is not true
21:53:35 <gzl> I sort of see what you're saying, but not sure about the details.
21:53:39 <Saulzar> Hah, well if I had one I'd surely give it to you as I'm buggered if I know what good it would do me :)
21:53:52 <Cale> Well, say, take the Goldbach conjecture.
21:53:55 <palomer> Saulzar: in a sense, what you say about IO Int is true for any program from any programming language
21:53:57 <gzl> ok.
21:54:33 <palomer> @hoogle abs
21:54:34 <lambdabot> Prelude.abs :: Num a => a -> a
21:54:34 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
21:54:34 <lambdabot> Language.Haskell.Syntax.HsEAbs :: HsQName -> HsExportSpec
21:54:47 <Saulzar> palomer, it will always do the same thing given the same starting conditions - IO is represented as a transition
21:54:57 <Cale> I could write a function which simply tests, for a given even input integer greater than 2, if it's the sum of two primes
21:55:06 <Cale> just by brute force search
21:55:29 <gzl> but that's really slow
21:55:30 <Cale> and I have it return a boolean result of that searching
21:55:37 <Cale> that doesn't matter :)
21:55:50 <Cale> then I make its result type Bool restricted to True
21:55:52 <gzl> why? can't you write a program to check that anyway (by brute force search)?
21:55:56 <palomer> Saulzar: again, that can be aid for any programming language
21:56:00 <Cale> and I typecheck the program
21:56:08 <palomer> s/said/aid
21:56:32 <palomer> err, reverse those 2
21:56:35 <Cale> If it typechecks, and the typechecker is assumed to be sound, then Goldbach's conjecture is verified.
21:56:41 <gzl> hmm. I suppose that's true.
21:57:21 <palomer> restricted typechecking would solve all our problems
21:57:26 <Cale> Basically, typecheckers are theorem provers
21:57:34 <palomer> that's a lie and you know it!
21:57:36 <gzl> yeah.
21:57:40 <Cale> Currently, we have them proving fairly simple things
21:57:57 <gzl> what about a simpler kind of restriction?
21:58:13 <palomer> oh, we're constantly pushing the boundaries
21:58:16 <Cale> Well, there are practical restrictions which are feasible.
21:58:46 <Saulzar> I guess what is more reasonable is restricted values with "out of bounds" 
21:58:51 <Cale> Especially if you don't mind the thing taking a long time, and/or including lots of extra type annotations with your program.
21:59:39 <Cale> In the extreme case, the compiler requires a proof of the property before it will submit to compiling the code for you. :)
22:00:24 <palomer> we still haven't found a good language to express our assumptions in
22:00:45 <palomer> we're currently using a botched up form of third order logic in haskell
22:00:52 <palomer> very ugly
22:01:19 <Cale> I actually think what we have in Haskell right now is pretty practical given what we know about types at the moment.
22:01:27 <Cale> Well, it's not perfect
22:01:29 <palomer> it's the best we have
22:02:00 <Cale> I like the way that it bridges the categorical and logical standpoints.
22:02:03 <palomer> haskell is currently calculating 10^8 using a lambda calculator
22:02:05 <palomer> let's see if it works
22:02:10 <Cale> heh
22:02:18 <Saulzar> Did it finish 7 ^ 9?
22:02:26 <palomer> nope
22:02:31 <palomer> I think I killed it
22:02:56 <Saulzar> That's over 40 million... could easily use more memory than your computer has
22:03:05 <palomer> the problem with ghci is that it doesn't clean up after you kill a process
22:04:25 <Saulzar> I'm impressed with how practical Haskell is - I was informed otherwise.
22:05:40 <palomer> yes, I can do 6^7!
22:05:54 <Saulzar> Hm, I'm going to use Dynamic for my entity type... I think this is the only way I can make it extensible and avoid piling all my data structures into one dirty great file
22:06:18 <gzl> Cale: but you can't even write that function, can you? because it has to return False if the thing's not a sum of two primes, and it can only ever return True
22:07:09 <gzl> so it can't compile regardless
22:07:20 <palomer> actually, there is a function whic terminates and would prove or disprove goldbach's conjecture
22:07:23 <palomer> but it's too slow
22:08:58 <gzl> well, I don't really care about Goldbach's conjecture in particular
22:09:05 <palomer> > let foo x = True in foo 4
22:09:06 <lambdabot> True
22:09:27 <palomer> gzl: why can't it compile?
22:09:46 <gzl> because if the return type is always True the function can't have a 'return False' in it
22:09:57 <palomer> gzl: and...?
22:10:06 <gzl> False isn't of type True...
22:10:29 <palomer> False and True have the same type
22:10:41 <palomer> True is not a type
22:10:41 <Saulzar> gzl, I believe he was talking about the return type of a function doing the searching for the 2 primes
22:11:02 <palomer> and that function does always terminate
22:11:05 <gzl> ok, call the type AlwaysTrue. True is in AlwaysTrue, but False isn't.
22:11:19 <palomer> gzl: there is no AlwaysTrue type
22:11:23 <gzl> ...........
22:11:31 <gzl> if you could restrict types, you could make one
22:11:35 <palomer> but you can't!
22:11:37 <gzl> that's what Cale was just suggesting
22:11:41 <gzl> can't what?
22:11:45 <palomer> restrict types
22:11:47 <gzl> jesus
22:12:08 <gzl> I don't think you're following.
22:12:21 <Saulzar> gzl, So to make that function compile, it must return true... so it must be provable that for every input that it does return true :)
22:12:40 <palomer> oh, I think I see your point
22:12:46 <gzl> Saulzar: I understand. what I'm saying is that it doesn't compile for a different reason: the function has to have a 'return False' somewhere to be meaningful
22:13:21 <palomer> gzl: test x =  (x is not the sum of two primes) return false else test x+1
22:13:25 <Saulzar> gzl, Yes, it wouldn't be writable using haskell code....
22:13:36 <gzl> yeah, I'm not talking about Haskell code. I'm talking about the hypothetical example.
22:14:19 <palomer> say we have a NotFalse type
22:14:31 <palomer> and say foo::notFalse
22:14:45 <palomer> will foo (test 2)  typecheck?
22:15:13 <palomer> I think not!
22:15:13 <Saulzar> Or any language even remotely similar to we... which I think is the point
22:15:36 <Saulzar> Er, remotely similar as we know it
22:15:49 <gzl> palomer: ?
22:16:18 <palomer> test returns false if golbach is false and loops if goldbach is true
22:16:31 <palomer> foo takes any boolean which is not false
22:16:37 <palomer> (a form of restriction)
22:16:44 <araujo> geez.. im getting spoiled with this parsec combinators.
22:16:45 <gzl> right
22:16:46 <palomer> does foo (test 0) type check?
22:17:00 <Cale> gzl: well, depends on how you look at it :)
22:17:10 <gzl> Cale: why?
22:17:42 <Cale> Well, is AlwaysTrue a completely new type, or is it really a subtype of Bool?
22:18:04 <gzl> suppose it's a subtype
22:18:27 <gzl> I'm not sure I see why those two things are different here, though
22:19:13 <palomer> wait, first order logic is complete, which means either x or ~x is provable, doesn't this mean that proving first order theorems is decidable?
22:19:44 <palomer> oh wait, nevermind
22:19:48 <palomer> here's an example then:
22:20:17 <palomer> prove x =  if x is provable return true; if ~x is provable return false; loop
22:21:18 <palomer> someFunctionWhichTakesAlwaysTrue (prove goldbach)
22:21:24 <palomer> does this typecheck?
22:21:52 <palomer> it would if prove golbach either returns true or loops!
22:22:19 <gzl> why?
22:22:32 <gzl> as soon as you see the 'return false' in there the compile will fail
22:22:51 <palomer> gzl: but (prove golbach) might always be true
22:22:55 <gzl> so?
22:23:23 <palomer> gzl: oh, you want a conservative type checker
22:23:25 <Cale> If it's a subtype, then you're permitted to work with values of the whole type, and the compiler has to ensure that the result falls into the subtype.
22:23:28 <gzl> for example, in Java, stuff won't typecheck even if it's the result of an unreachable statement
22:23:32 <palomer> why didn't you say so in the first place
22:23:42 <palomer> yeah, subtyping is what you want
22:23:57 <gzl> Cale: ah, I see
22:24:24 <gzl> why permit that?
22:24:25 <palomer> in which case, you could have the set of all floats [0..1]
22:24:29 <palomer> just subclass Float
22:25:21 <Cale> gzl: well, consider writing the function f :: [0,1] -> [0,1],  f(x) = x/2. You want to be able to work with 2.
22:25:28 <gzl> oh, wait
22:25:29 <gzl> I see now
22:26:02 <Cale> Well, that's a poor example, since it's the same as f(x) = 0.5 * x here.
22:26:15 <Cale> but you see the point of it
22:26:23 <gzl> yeah
22:27:01 <palomer> oh wait, Float isn't a typeclass
22:27:08 <stepcut> :p
22:27:13 <Cale> palomer: there's Floating
22:27:24 <Cale> along with a bunch of other
22:27:25 <Cale> s
22:28:03 <Cale> http://www.haskell.org/onlinereport/basic.html#sect6.3
22:28:26 <Cale> many of which are poorly names
22:28:30 <Cale> arg
22:28:33 <Cale> named*
22:28:46 <Cale> I seem to be making that typo a lot lately.
22:29:07 <gzl> the keys are right next to each other. :)
22:29:12 <Saulzar> Is that the same as calling language feature 2nd class citizens? :)
22:29:19 <Saulzar> language features.
22:30:43 <Cale> palomer: however, to be an instance of Num, you probably at least want somewhat ring-like behaviour :)
22:31:15 <Cale> Though that's not explicitly mentioned, I think most code will assume that distributivity, for example, holds for instances of Num
22:31:32 <Cale> (or at least some approximation to it)
22:32:03 <Cale> Float doesn't quite satisfy distributivity, but it's trying as hard as it can :)
22:39:21 <palomer> >:o
22:39:27 <palomer> well it's not hard enough
22:39:56 <palomer> I have 5 instances of YAHT displayed
22:40:10 <Cale> hm?
22:40:19 <Cale> ah
22:40:58 * palomer still doesn't think that haskell is any purer than any other programming language
22:41:05 <palomer> except that IO foo -> bar bit
22:41:23 <palomer> so it's a teeny tiny bit purer
22:42:04 <Cale> well, okay, here's an example, say I have a function f :: Integer -> Integer, and it's been written by someone I don't know
22:42:23 <Cale> Is it safe to log in as root and play around with it in my interactive environment?
22:43:30 <stepcut> I do all the time
22:43:39 <stepcut> :p
22:43:40 <Cale> Of course, with GHC, I have to know that the System.IO.Unsafe module isn't loaded :)
22:44:02 <Cale> But otherwise, yes, I know that it's not going to do anything but evaluate some numbers.
22:44:07 <stepcut> Cale: don't forget the ffi 
22:44:30 <stepcut> foreign import ccall "somethingevil" evil :: Int -> Int
22:44:30 <palomer> yeah, the FFI!
22:44:30 <Cale> Sure, that's off too :)
22:44:39 <palomer> pfft
22:44:43 <palomer> so anything interesting is off
22:44:43 <Cale> That has to be explicitly enabled anyway
22:44:45 <palomer> seriously
22:44:52 <stepcut> Cale: yeah
22:44:57 <gzl> security-typing is kind of cool that way
22:45:10 <palomer> ruby has a safe mode which ensures that everything is safe
22:45:16 <Cale> Anyway, in Haskell 98 at least, I know that f is safe
22:45:32 <Cale> this is why lambdabot can freely evaluate Haskell expressions for us
22:45:42 <Cale> It just doesn't execute any IO.
22:45:53 <palomer> Cale: yeah, you can do the same in ruby
22:46:03 <palomer> by stopping certain modules from getting loaded
22:46:03 <Cale> The only sandboxing required is the type system
22:46:26 <palomer> if you restrict the modules, you can do this for any programming language
22:46:28 <Cale> Oh, there's other ways to achieve this, sure
22:46:49 <palomer> but they're similar ways!
22:46:56 <stepcut> palomer: like C ?
22:47:10 <palomer> C is off limits:o
22:47:48 <Cale> I think -fffi should be needed for System.IO.Unsafe
22:47:52 <stepcut> bash?
22:47:54 <Cale> (though it isn't)
22:48:27 <Cale> But anyway, it's not really part of the core Haskell 98 definition. It's part of the FFI spec.
22:48:53 <palomer> Cale: ok, I'll agree that haskell 98 is, erm, somewhat purer
22:49:01 <palomer> but who the hell codes in haskell 98?
22:49:04 <Cale> GHC has lots of broken extensions
22:51:10 <Cale> but if you exclude unsafePerformIO which breaks everything anyway, and its otherwise implicit use in the FFI, functions of type Integer -> Integer don't have side effects.
22:51:46 <Cale> I think those are reasonably modest assumptions. Usually uses of unsafe IO are quite blatant.
22:52:29 <Cale> There are other highly evil experimental extensions you can turn on in GHC too, like implicit/linear implicit parameters
22:52:44 <palomer> I hear noone uses those
22:53:08 <Cale> Well, lambdabot uses implicit parameters, but it probably shouldn't.
22:53:22 <palomer> what exactly is an implicit parameter?
22:53:34 <Cale> Basically it's like the reader monad, without the monad.
22:53:58 <Cale> Some parameter to a function is implicitly passed down from somewhere else.
22:54:17 <Cale> So you don't have to add it to the parameter lists
22:54:22 <palomer> nice!!
22:54:26 <Cale> horrible!!
22:54:30 <palomer> why?
22:55:32 <Cale> I'd say it breaks referential transparency.
22:57:00 <Cale> I value referential transparency more than a lot of people though.
22:58:54 <Cale> I suppose there's some way in which it's equivalent to the use of typeclasses, but there are some really strange things that happen.
22:59:36 <Cale> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3145719
23:02:45 <Cale> anyway, the problem they solve seems better solved to me using monads.
23:03:27 <Cale> It's quite possible that we need a better syntax for commutative (or essentially commutative) monads than do-notation though.
23:05:14 <Cale> People have suggested the use of funny evaluation brackets, which I think would be a crime in something like IO, but might be suitable for something like unique name generation, or something in which you really don't care what order things proceed in.
23:05:52 <Cale> Adding dynamic scoping to the language seems like overkill.
23:08:54 <stepcut> what I would find useful is a bit of syntatic sugar like, withModule SomeModule exp, so that you could use things in SomeModule, but only in that exp
23:09:53 <Cale> Linear implicit parameters are what's really awful, and people have used them to implement reify/reflect for arbitrary monads and shift/reset.
23:10:48 <Cale> Shift/reset are the sort of thing which I'd want to explicitly ensure that I exclude from any language I designed.
23:10:55 <stepcut> heh
23:12:42 <Cale> I suppose that in this case, they also used unsafeCoerce# and unsafePerformIO
23:14:34 <stepcut> I wrote a function to do an unsafe coerce on a phantom type the other day
23:14:45 <stepcut> let's see you stop that!
23:14:56 <Cale> hehe
23:15:46 * stepcut takes some photos and then heads to bed
23:15:54 <Cale> I can see the need for unsafePerformIO in FFI situations, but in actual Haskell code, we really ought to come up with better ways to do things :)
23:17:30 <Cale> One can use it to control memoisation, which I think is valid, but it's not terribly elegant.
23:18:23 <Cale> It would be nice to have some weaker system of execution attached to the evaluation of values. Perhaps ST rather than IO.
23:21:12 <Cale> something that you can make some kind of safety claims about anyway
23:24:52 <Saulzar> Hm, you mean something like a forced evaluate inside ST?
23:25:06 <flux__> cale, how about implementing the memo-function?-)
23:25:27 <flux__> or were you just referring to that
23:25:32 <Cale> I was referring to that
23:26:18 <Cale> ST is enough to manage references to your memo table anyway.
23:27:55 <Cale> You don't get things like weak pointers though, those are in IO.
23:29:36 <Cale> So maybe we want a special monad, with weak pointers, stable names and mutable cells, and nothing else.
23:32:14 <Cale> That is, just those things needed for memoisation. Perhaps throw in performGC just for good measure.
23:32:39 <Cale> You could still break referential transparency with it of course.
23:32:52 <Cale> (so it's still unsafe)
23:33:11 <Cale> but it's at least not going to talk over the network or write to disk or anything like that
23:37:03 <Cale> but as long as one is not going out of one's way to be malicious, side effects just don't happen accidentally in Haskell.
23:38:02 * shapr` boings cheerfully
23:38:03 <shapr`> Cale: You called?
23:38:07 <Cale> I did?
23:38:18 <shapr> Yeah, you said "You still about?"
23:38:30 <Cale> oh, hmm
23:38:37 <Cale> I wonder why I said that :)
23:38:46 <Cale> there was some good reason, I'm sure
23:38:53 <Cale> hehe
23:39:06 <shapr> stepcut: Hey, think you'll have the SPJ audio file edited by 2006?
23:39:34 <shapr> Cale: Oh Greg Buchholz said that he might have seen your Joy-like code in Okasaki's 'flattening postfix' paper.
23:39:40 <Cale> Perhaps one can prevent them in Ruby by explicitly excluding various modules, but afaict, the default configuration in Ruby permits lots of IO and otherwise side-effectful stuff all over the place
23:39:57 <Cale> shapr: cool, I'll have to look at it
23:40:25 <shapr> I wish there were some way to combine irc and a forum...
23:40:29 <stepcut> shapr: i have the spj one editted
23:40:34 <Cale> shapr: I thought about it, and I think I originally saw something like that in the context of an assignment that someone was doing and getting help with here.
23:40:39 <shapr> For example, some way to respond to someone months, years later. 
23:40:49 <shapr> stepcut: Oh, can I get a copy?
23:40:57 <stepcut> shapr: sure, should I email it ?
23:41:04 <shapr> Sure, works for me.
23:41:20 <shapr> metaperl: pong?
23:42:28 * shapr tries debsecan
23:42:28 <stepcut> shapr: ok, it may be arriving in your inbox
23:42:33 <shapr> spiffy, thanks
23:43:17 <shapr> hm, what's unstable right now? sid?
23:43:42 <shapr> Mmm, I've been away from a keyboard for days.
23:43:45 <stepcut> sid is always unstable..
23:43:54 <shapr> Strangely enough, I didn't mind a bit.
23:44:10 <shapr> Spending time with my woman and her family is nice.
23:44:36 <stepcut> I've been away from my woman for days -- and I *do* mind it
23:44:44 <shapr> Oh hey, I've come up with a good excuse to study Doerfler's Dead Reckoning... Number Theory is compiler optimizations, according to C-H.
23:44:50 <shapr> stepcut: that sucks :-(
23:45:01 <shapr> hiya humasect 
23:45:04 <stepcut> well, I just have to make more money next year :p
23:45:14 <humasect> hey shapr, happy holidays
23:45:39 <shapr> Happy holidays to you too. How's code?
23:45:45 <humasect> hs-plugins repo won't build with 6.5 and cabal 1.1.4, i will check the ML
23:46:11 <humasect> thanks. it is good =) i am getting further comfortable with completely functional thought
23:46:25 <stepcut> shapr: I am rewriting my unix pipe code for the third time :p
23:46:29 <humasect> reading don's hs-plugins and yi papers today after playing with ocaml some more.
23:47:05 <humasect> haskell is futuristic.
23:49:56 <shapr> Truly
23:50:05 <shapr> Any particular parts you think are especially futuristic?
23:50:35 <shapr> stepcut: So I shouldn't ask about unix pipes for TMR 2006?
23:51:29 <humasect> monads and lazyness are quite powerful. syntax and expression also flexible
23:51:55 <shapr> I also think that monads and laziness are futuristic features.
23:52:09 <humasect> i can see it will continue to evolve and "shape out" which is fantastic
23:52:47 <shapr> I'm happy that so many commercial programmers are learning monads recently.
23:52:59 <shapr> Did you see the LtU article that collected monad implementations in various languages?
23:53:03 <stepcut> shapr: I starting working on cleaning up v2 so I could right a TMR article, and then I realized I needed to write v3 ;)
23:53:20 <shapr> stepcut: ha
23:53:24 <humasect> i keep looking but i still have no problems putting all of my conceptual eggs of focus in the haskell basket.
23:53:44 <stepcut> s/right/write/
23:54:13 <humasect> i will read that article
23:57:54 <shapr> hi Zerthurd, learning Haskell?
23:59:32 <humasect> can monads be described by what they aren't?
23:59:33 <shapr> conal: Pajama sounds very cool.
