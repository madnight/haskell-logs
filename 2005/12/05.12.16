00:00:48 <aleator> I've actually checked some papers where algorithm just does not give result that the paper presents.
00:01:23 <aleator> Mostly because author has skipped "the inrelevant parts"..
00:03:47 <shapr> aleator: So, are you processing up a Lenna example?
00:04:20 <aleator> shapr: Yeah..
00:04:48 <aleator> shapr: Just having problems to think what would be a neat example..
00:07:09 * shapr doesn't know...
00:08:29 <shapr> hey skew, how's code?
00:08:59 <skew> coming along - thinking of some neat things
00:09:07 <skew> how's yi?
00:09:09 <shapr> skew: Random question, do you know if double stuffed or chocolate covered oreos are still sold in the USA?
00:10:14 <skew> I think they are, maybe the chocolate covered ones seasonally
00:10:16 <shapr> Yi is making some progress, did you see the cool type checking spell checking screenshots by Lemmih?
00:10:38 <xerox> Where, where!  (Hi.)
00:11:50 <shapr> http://www.scannedinavian.org/YiWiki/ScreenShots
00:12:27 <xerox> Ah, those!
00:12:36 <skew> oh, I think I did see those before
00:14:49 <tuomov> I'm completely out of touch with where Yi is going
00:15:01 <tuomov> but since it seems to be GUI, maybe, well, you know me
00:15:52 <xerox> tuomov: it is dynamic from the ground up, pick it up!
00:15:52 <skew> I have some ideas lying around about using hierarchial PPM models for autocomplete
00:15:57 <aleator> shapr: Not very interesting but http://www.cc.jyu.fi/~aleator/lenas/ contains few images and transcript of ghci session for them.
00:16:34 <tennin> ok, looks like I still don't understand the type system at all =(
00:16:35 <xerox> aleator: cool, what is it
00:16:54 <tuomov> xerox: I rather stay as far from gtk as possible
00:16:55 <xerox> tennin: tell us, I'm in a hurry but I'd love to help
00:17:06 <xerox> tuomov: GTK is just a possibility
00:17:14 <tuomov> has there been any new work on all the syntax hl etc. in curses?
00:17:15 <aleator> xerox: A proof that someone uses haskell for image processing? :/
00:17:37 <xerox> aleator: aww.
00:17:53 <tennin> can I have wildcards in what the constructors for my datatypes take?
00:18:08 <tennin> like data EnvMonad env a = EnvMonad (ContT a (State env) _)
00:18:26 <xerox> Why so?
00:18:47 <aleator> shapr: If I can figure out some more reasonable example, I'll show you. Those are bit boring since there is nothing new in there.
00:18:50 <xerox> Maybe data EnvMonad env a b = EnvMonad (ContT a (State env) b)
00:19:16 <xerox> Or even b = () if you don't use it, don't have time to check the details sorry
00:19:19 <xerox> Bye bye now!
00:20:40 <tennin> well actually it would be data EnvMonad env a  = CmdResult [ResourceTag] ([Resource] -> [a, EnvAction]) | EnvMonad (ContT a (State env) _)
00:20:48 <tennin> as you can see I really don't know what I'm doing =\
00:21:54 <skew> oh, that's the position of the continuation transformer used for the final result?
00:22:46 <tennin> something like that
00:23:21 <tennin> basically I want to have an environment where commands are executed
00:24:17 <tennin> and commands should be able to escape the current command loop, etc. hence the need for continuations
00:27:16 <tennin> erm that should be (a, [EnvAction])
00:27:46 <tennin> ugh, this is even more confused than I thought it was
00:30:33 <skew> it looks like you probably want something like forall r . ContT a (State env) r
00:32:12 <tennin> is that standard Haskell 98?
00:33:37 <shapr> aleator: Thanks!
00:34:33 <skew> no. To get standard code, lift the r up through the data type
00:34:52 <skew> and then, just let all your functions be polymorphic in it
00:35:39 <tennin> i.e. declare it as EnvMonad env a r?
00:35:41 <skew> I think just about every implementation supports foralls like that, though
00:37:56 <tennin> thanks
00:38:32 <skew> why are you worried about writing Haskell 98 code?
00:39:31 <cpatrick> blist
00:39:36 <cpatrick> gah, wrong window
00:39:49 <tennin> I'm not really
00:40:09 <tennin> just want to keep straight what's standard and what's not
00:41:23 <tennin> and what's documented in the Haskell Report and what has to be found elsewhere
00:47:37 <shapr> aleator: Do you want me to use "aleator" or your real name? Also, do you want to give a link to your research website?
00:47:44 <shapr> Could be good publicity for your project :-)
00:48:02 <tic> Hi, any of you know how to use Text.Html's concatHTML?
00:48:08 <tic> Can't get it working with (<<)
00:49:00 <shapr> @index concatHTML
00:49:00 <lambdabot> bzzt
00:49:06 <shapr> ?
00:49:06 <tic> concatHtml, sorry.
00:49:11 <shapr> @index concatHtml
00:49:12 <lambdabot> Text.Html
00:49:21 <shapr> @type Text.Html.concatHtml
00:49:22 <lambdabot> forall a. (Text.Html.HTML a) => [a] -> Text.Html.Html
00:49:24 <tic> There's really no docs on it, either.
00:49:57 <shapr> Looks like it takes a bunch of top level stuff and stick it together.
00:50:51 <aleator> shapr: Ville Tirronen would be better. Unfortunately we don't really have a website for this.
00:51:46 <tic> shapr, see, what I want to do is to grab a bunch of Html elements and throw them inside a <div> tag.
00:54:40 <tic> oh well.
00:55:03 <lisppaste2> twb pasted "what does this error mean?" at http://paste.lisp.org/display/14722
00:56:13 <twb`> Sorry about that.
00:56:22 <twb`> Anybody know what's wrong with that code?
00:57:56 <wilx> Can you use do without { }?
00:58:12 <twb`> wilx: it's never been a problem before...
00:58:41 <wilx> Ok, I'm just checking, I have never seen it without it.
00:59:11 <twb`> If you comment out the third line, it loads.
00:59:32 <twb`> Then "followedBy eof :: Show a => GenParser a b c -> GenParser a b c"
01:00:11 <skew> wilx: did you mean to ask if you can use ; without {}?
01:00:18 <wilx> skew, yes.
01:00:59 <wilx> twb`, ah, "overloading", isn't that forbidden?
01:01:01 <skew> wilx: the layout rule is defined by translation into the {;} synta
01:01:11 <twb`> wilx: I don't understand.
01:01:16 <skew> twb`: what interpreter are you using?
01:01:16 <wilx> Your followedBy has two parameters while the type you just pasted has one?
01:01:23 <twb`> hugs
01:01:31 <twb`> wilx: right.
01:02:02 <tennin> I think multiple semicolons are effectively ignored, though
01:02:07 <twb`> "f = g x where g x y = x" should be equivalent to "f y = g x y where g x y = x", right?
01:02:32 <tennin> >x*y where {x=8;; y=7;;}
01:02:46 <skew> I think that's a bad error message
01:03:07 <tennin> hmm, hugs accepts it though
01:03:07 <twb`> GHCi gives "Possible cause: the monomorphism restriction applied to the following:"
01:03:13 <skew> ghci would say something about the monomorphism restriction. followedBy is polymorphic in the token type and just about everything else
01:03:46 <skew> but eof requires that your token type have a Show instance
01:03:56 <skew> ghci picks better type names too
01:04:28 <skew> anyway, lastPara is a value at the top level, so it's now allowed to be polymorphic without an explicit signature
01:04:48 <skew> so it's not allowed, I mean
01:06:09 <skew> lastPara p = followedBy eof p works, though
01:11:26 <skew> I don't remember what the point of the monomorphism restriction is, though
01:12:53 <tennin> to test the faithful
01:13:18 <Heffalump> to avoid users thinking that a top-level declaration will only be evaluated once
01:13:33 <Heffalump> there's also some type-checking related reason that I forget
01:18:05 <araujo> mm.. some people in my univ. could get excited with this pascal's triangle haskell algorithm.....
01:19:02 * araujo has noticed people is amazed with haskell when they see htis kind of stuff
01:30:25 <twb> dons: I'm working on a parser for a wiki-type document format in parsec.  Is it possible to make yi use that as a hilighting mode as well, with only a little modification to the parser?  Or would a whole new parser have to be built?
01:49:35 <tromp_> which pascal algorithm, araujo?
01:50:18 <dons> twb, it will be possible in a few days, yes.
01:50:46 <araujo> tromp_, the Blaise Pascal's Triangle
01:51:56 <araujo> http://en.wikipedia.org/wiki/Pascal_triangle
01:52:55 <twb> dons: "in a few days from now it will be easy", or "it is possible in a few days of work"?
01:53:03 <joelr1> morning
01:53:12 <ADEpt> i'll try again: who know how to submit wishlist bug against darcs?
01:53:33 <joelr1> is +RTS -M800M the right combination of options to restrict GHC to 800Mb at runtime?
01:54:38 <dons> twb, in a few days it will be easy.
01:56:15 <tromp_> i know the triangle, but was wondering where the haskell code was:)
01:56:49 <tromp_> is it something like
01:56:50 <tromp_> pascal m n = a!(m,n) where
01:56:50 <tromp_>  a = array ((0,0),(m,n)) $ [((i,0),1) | i<-[0..m]]++[((0,i),1) | i<-[1..n]]++
01:56:50 <tromp_>      [((i,j),a!(i-1,j)+a!(i,j-1)) | i<-[1..m], j<-[1..n]]
01:56:51 <tromp_> ?
01:58:20 <joelr1> @type foldM
01:58:21 <lambdabot> Not in scope: `foldM'
01:59:42 <tromp_> @type Monad.Control.foldM
01:59:42 <lambdabot> Couldn't find qualified module.
01:59:42 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
01:59:42 <lambdabot> \\)?
02:00:08 <chucky> @type Control.Monad.foldM
02:00:09 <lambdabot> forall a (m :: * -> *) b.
02:00:09 <lambdabot> (Monad m) =>
02:00:09 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
02:00:17 <joelr1> ah
02:00:23 <tromp_> :-P
02:03:26 <tromp_> ah, the following is nice too:
02:03:28 <tromp_>  pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
02:08:39 <kowey> if i use runInteractiveProcess and waitForProcess, must i pass compile my code with -threaded?
02:09:23 <dons> if you don't want your whole app to block on waitForProcess, yes.
02:09:29 <dons> if you don't care about blocking, then no.
02:09:57 <kowey> hmm... i guess i do want it to block in fact... ok thanks (i'll go without -threaded)
02:09:58 <dons> -threaded will probably become the default soon anyway
02:10:16 <dons> well, if your single threaded, then nothing changes.
02:10:27 <dons> but other threads will block if one does a waitForProcess
02:10:47 <dons> other forkIO threads will not block with -threaded
02:10:48 <kowey> the default? hmm... i think i'm single threaded... i don't know if wxhaskell does any threads stuff
02:11:01 <kowey> i mean, is threading almost essential to make a gui work?
02:11:30 <dons> no, I don't think so. but forkIO is easy, so it's not too hard to play with.
02:11:51 <dons> but see how far you can go without extra threads
02:12:23 <dons> i even use multiple threads in my curses guis  :) they're great
02:12:53 <kowey> hmm... :-) i just want my program to work predictably right now
02:12:55 <ozone> dons: GHC's threads are lightweight (non-OS) threads by default, right?
02:13:10 <dons> yep.
02:13:58 <dons> @where+ hsql http://htoolkit.sourceforge.net
02:13:58 <lambdabot> Done.
02:14:41 <dons> kowey, hopefully you'll find out how much fun threads are in haskell -- they're simpler and more fun than any other language I can think of
02:14:56 <ozone> dons: erlang? :)
02:15:09 <dons> what do you think? i haven't used erlang very much
02:15:39 <kowey> #haskell enthusiasm... makes me smile
02:15:39 <dons> have you written many multithreaded erlang programs?
02:15:51 <dons> well, they reall are nice threads in haskell.
02:15:56 <dons> :)
02:16:07 <dons> @type Control.Concurrent.forkIO
02:16:08 <lambdabot> IO () -> IO GHC.Conc.ThreadId
02:16:15 <dons> how much fun is that?
02:16:34 <dons> you just pass arbitrary IO computations, and they become threads.
02:16:38 <ozone> dons: i haven't done any heavy threading stuff in haskell
02:17:03 <ozone> dons: erlang's empahsis is on message-passing though... no shared data structures.  (i.e. no mutexes)
02:17:12 <dons> ah, yes. quite different
02:17:14 <ozone> which i think is much, much better than having shared data, having used both
02:17:20 <ozone> though STM changes the whole story, and i haven't played with that yet
02:17:26 <dons> though haskell has STM now ..
02:17:39 <dons> yeah, a new story. but MVars are simple and effective too.
02:19:02 <ozone> yeah, i have a feeling that STM will be really nice.  though erlang's CSP-style concurrency still has a big advantage for truly distributed programs
02:19:07 <ozone> (that run on different machines)
02:19:29 <skew> that's what Chan is for
02:19:30 <ozone> i'm not sure how feasible it'd be to scale STM to different hosts, when the communication cost becomes very high
02:22:14 <shapr> Still, you could use STM locally, and something like musasabi's JoinHs remotely.
02:23:02 <ozone> i'm not familiar with JoinHs
02:23:04 <dons> JoinHs??
02:23:11 <shapr> @google joinhs einar
02:23:11 <dons> sounds like super-fun
02:23:12 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/JoinHs/
02:23:32 <shapr> http://www.haskell.org/tmrwiki/JoinHs
02:24:00 <shapr> "JoinHs is a new experimental dialect of Haskell supporting concurrent and distributed programming using Join-calculus as a basis."
02:24:16 <ozone> looks pretty nice
02:24:38 <dons> ah, a dialect eh?
02:24:52 <dons> oh, but just a preprocessor?
02:24:55 <dons> that sounds neat.
02:25:18 <dons> "The preprocessor compiles join-patterns into concurrent Haskell using MVars and pattern matching"
02:25:23 <dons> cool.
02:25:44 <dons> @where+ joinhs http://www.haskell.org/tmrwiki/JoinHs
02:25:45 <lambdabot> Done.
02:25:45 <Lor> Is it really necessary to use a preprocessor?
02:25:54 <dons> I imagine you could do it by hand..
02:26:08 <dons> but syntactic support might be nice too
02:26:32 <dons> calling it a `dialect' seems a bit of a red herring
02:27:08 <o_Rocky> Hello
02:27:10 <araujo> Good morning.
02:27:56 <o_Rocky> i'm trying to do some Rose Tree pretty printing...
02:28:19 <o_Rocky> i wonder if you could help
02:28:36 <dons> did you look at the  ppr in fptools?
02:28:48 <o_Rocky> ?
02:28:59 <dons> @type Data.Tree.drawTree
02:29:00 <lambdabot> Data.Tree.Tree String -> String
02:29:29 <dons> it's about  10 lines in Tree.hs :) I'd start with that.
02:29:50 <o_Rocky> i'm trying to print a rose tree to graphviz .dot format
02:30:17 <dons> ah, ok, where are you stuck?
02:30:32 <o_Rocky> i can already print stuff
02:30:38 <o_Rocky> like RTree Int
02:31:33 <o_Rocky> (Show a) => RTree a -> IO ()
02:31:55 <o_Rocky> but the type String is a sun of a beach :P
02:32:27 <SlowByte> is there some x such that (a y) x b x c is equivalent to (c (b (a y)))? :)
02:32:47 <shapr> SlowByte: Check out Conor's Idioms.
02:32:54 <o_Rocky> because in my system i print stuff like this: RTree Int --> "\"" ++ Int ++ "\""
02:33:18 <dons> o_Rocky, maybe use pretty printing combinators then? they're more fun
02:33:27 <dons> @doc Text.PrettyPrint
02:33:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
02:33:57 <dons> fun is really the key
02:34:14 <shapr> SlowByte: There's some sort of pattern where you can use multiple ops after the first one for stuff like that. So you have op0 val0 op1 val1 op1 val2 op1 val3
02:34:26 <shapr> dons: truly
02:34:49 <shapr> I've heard some call that zealot oriented programming.
02:34:59 <dons> hehe
02:35:00 <shapr> But the real power comes from motivation.
02:35:03 <dons> works for perl
02:35:18 <tromp_> then what's the e stand for in zope?
02:35:23 <o_Rocky> shapr: couldn't agree more
02:35:25 <tromp_> hi, shapr:)
02:35:34 <shapr> hoi tromp_, how's code?
02:35:42 <SlowByte> shapr: I'm so used to "thinking" that way (coming for Ruby) that I can't tolerate any other order ;)
02:35:48 <tromp_> cool
02:35:49 <SlowByte> from*
02:35:53 <tromp_> 17x17 is still running:)
02:36:26 <SlowByte> and it mimics the Unix pipe order of cat | foo | bar | baz
02:36:28 <shapr> SlowByte: My advice is to become comfortable and tolerant of many different ways. Have you tried Prolog, Joy, Mozart/Oz, Epigram, Aardappel?
02:36:52 <tromp_> i prefer rijst over aardappel:)
02:37:01 <shapr> @google rijst programming language
02:37:02 <lambdabot> http://www.nluug.nl/events/vj03/overview.html
02:37:09 <SlowByte> shapr: tried? well, I've only coded in Prolog from those but I've looked at all the others :)
02:37:29 <shapr> Yeah, but use and comfort is something else.
02:37:31 <araujo> SlowByte, You coming from Ruby? ... i think that's good.
02:38:01 <araujo> SlowByte, i myself come from Smalltalk , and ive found Haskell very exciting and easy in many respects.
02:38:02 <shapr> SlowByte: Anyway, I know I'm an extremist, so feel free to take my words with a grain of salt (or maybe a whole shaker's worth).
02:38:07 <shapr> tromp_: Where's Rijst?
02:38:08 <tromp_> rijst==rice aardappel==potato :)
02:38:14 <shapr> oh!
02:38:20 <tromp_> sorry, bad joke:(
02:38:38 <shapr> tromp_: No worries, my dutch just isn't up to that sort of humor :-)
02:38:48 <tromp_> not yet anyways:)
02:38:53 <shapr> Aardappel is a programming language based on concurrent tree space transformation.
02:38:55 <shapr> http://wouter.fov120.com/aardappel/index.html
02:39:37 <shapr> Wouter van Oortmerssen makes amazing programming languages.
02:39:42 <shapr> But I very much wish he would let me download them.
02:39:53 <shapr> Because I know I can't really understanding something until I've become comfortable using it.
02:40:08 <shapr> And I'd like to try his many strange languages just to see what I'm missing.
02:40:57 <dons> he  won't let you download them?
02:41:07 <dons> how does that work?
02:41:37 <shapr> He describes them, but they're not available - http://wouter.fov120.com/proglang/index.html
02:42:00 <dons> are they implemented?
02:42:03 <shapr> I emailed him and asked for executables or sources, but he said anything he was willing to release is already available on his pages.
02:42:04 <SlowByte> araujo: well, not exactly coming from, but writing Ruby felt nicer than anything else so I settled for it
02:42:05 <shapr> Yup
02:43:12 <dons> hmm. so he hasn't heard of darcs then ;)
02:43:18 <shapr> I dunno.
02:43:29 <araujo> SlowByte, then, you'll like Haskell i'd dare to say
02:43:37 <joelr1> how would you implement a replacement for TChan on top of MVars?
02:43:38 <shapr> I just want to play with these mental toys. I know I could dramatically improve my understanding of programming languages with these.
02:43:56 <dons> oh, Apfelstrudel sounds nice :)
02:44:06 <dons> I should name languages with silly names like this.
02:44:21 <o_Rocky> dons: that didn't solve my problem...
02:44:49 <araujo> SlowByte, I still use the "object <- message" mental model , but now with "function <- values" or "function <- function"
02:45:05 <dons> o_Rocky, I don't think you actually stated what your problem was :)
02:45:13 <dons> other than something about strings being bad
02:45:15 <araujo> SlowByte, I think smalltalkish languages are good for building a good way of thinking in terms of functional applications for example.
02:45:39 <o_Rocky> dons: the problem is that the function i have prints Strings like this: ""String""
02:45:54 <joelr1> never mind, i'm stupid 
02:46:11 <joelr1> i meant a bounded TChan
02:46:16 <o_Rocky> instead of "\"String\""
02:46:34 <dons> oh, you want to show your strings?
02:46:45 <o_Rocky> yeah
02:46:46 <dons> > show . show $ "foo"
02:46:47 <lambdabot> "\"\\\"foo\\\"\""
02:46:53 <o_Rocky> lol
02:46:55 <dons> how many \\ do you want ;)
02:47:04 <dons> > show . show . show . show $ "foo"
02:47:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
02:47:07 <dons> is that enough?
02:47:13 <dons> maybe some more...
02:47:14 <araujo> SlowByte, You can keep seeing functions as objects for example. And partial applications like messages.
02:47:24 <tromp_> better safe than sorry:)
02:47:24 <skew> joelr1: well, Chan is build on MVar already. You could do something similar to the bounded TChan construction from the list, pair a Chan with an MVar holding its length
02:47:35 <o_Rocky> dons: that would do if i wanted to show only strings...
02:47:51 <tromp_> > take 10 $ iterate show "foo"
02:47:52 <lambdabot> ["foo","\"foo\"","\"\\\"foo\\\"\"","\"\\\"\\\\\\\"foo\\\\\\\"\\\"\"","\"\\
02:47:52 <lambdabot> \"\\\\\\\"\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\
02:47:52 <lambdabot> \"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\
02:47:53 <lambdabot> \\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"
02:47:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
02:47:56 <joelr1> skew: the question is more like how to prevent more than X elements being put in
02:47:57 <lambdabot> [23 @more lines]
02:48:01 <joelr1> skew: there's no retry
02:48:07 <dons> oh tromp_, bad bad.
02:48:25 <tromp_> we are the knights that say: "Foo!"
02:48:27 <SlowByte> araujo: yeah, I don't really think OO anyway, verbs and nouns don't fall into distinct classes in my mind
02:48:29 <joelr1> skew: so how would i make writing threads block
02:48:50 <skew> hmm, probably the easiest is to use the QSem code
02:49:09 <joelr1> skew: code? you mean not QSem itself?
02:49:26 <skew> no, I mean QSem
02:49:53 <SlowByte> in both senses... also in the sense that you can use verbs as nouns (higher-order functions) :)
02:49:58 <joelr1> skew: i thought about doing that but wouldn't there be a race?
02:50:29 <joelr1> skew: imagine there are 0 resource available, you signal, and a bunch of threads were waiting... thinking
02:50:44 <skew> I worried about that for a bit, but no. Just take from the semaphore before you put in the chan, add after you remove
02:50:55 <ski_> SlowByte : 'infixl 0 >$; (>$) = flip ($)' ?
02:51:01 <joelr1> skew: true, thanks
02:51:12 <o_Rocky> "Just "\"Erro\""" [shape=circle, label="Just "\"Erro\""", color=green];
02:51:15 <dons> o_Rocky, I still am only guessing. can you give a specific example of what is broken for you?
02:51:32 <skew> only one thread will get the resource, unless the library is horribly broken - I've never used it
02:51:33 <joelr1> skew: i have to switch away from STM for now :( 
02:51:47 <joelr1> skew: profiling is cripped with STM at this point
02:51:55 <skew> oh, is that being fixed in 6.5?
02:52:04 <o_Rocky> it prints like this: "Just "Erro"" [shape=circle, label="Just "Erro"", color=green];
02:52:12 <joelr1> skew: beats me
02:52:26 <joelr1> skew: simon says that 6.6 is the next release
02:52:28 <joelr1> in a few months
02:52:35 <o_Rocky> i want to print like this: "Just \"Erro\"" [shape=circle, label="Just \"Erro\"", color=green];
02:53:02 <SlowByte> I like functional programming but lists are overused
02:53:08 <dons> hmm, can't you just show your type, producing a string, and then show the result, so you get quotes?
02:53:32 <dons> > show . show $ Just "Erro"
02:53:33 <lambdabot> "\"Just \\\"Erro\\\"\""
02:53:37 <dons> maybe too many.
02:54:14 <o_Rocky> > rtree2graphviz2file "UD" "teste" (Leaf (Just "Erro"))
02:54:15 <lambdabot>  Not in scope: data constructor `Leaf'
02:54:30 <dons> anyway, once it's a string, you can go nuts and filter the output any way you want.
02:54:36 <skew> SlowByte: lists mean a bit more in a lazy language
02:54:38 <o_Rocky> result: "Just "Erro""
02:54:40 <SlowByte> sets (and relations) are a much better fit for most data IMHO
02:55:15 <joelr1> skew: QSem has no decrement op
02:55:19 <skew> lists can often act more like a control structure than a data structure
02:55:35 <SlowByte> yeah
02:55:35 <joelr1> how the hell do you reset a QSem or decrement it?
02:55:46 <skew> joelr1: "waitQSem" and "signalQSem"
02:56:19 <joelr1> skew: ah! 
02:56:23 <skew> the names got a little too far from the idea of a counter...
02:56:31 <skew> are you looking at the library documentation?
02:56:34 <o_Rocky> desired result: "Just \"Erro\""
02:56:40 <joelr1> skew: so wait would take a unit and singnal add one
02:56:45 <joelr1> skew: yes, library docs
02:57:11 <skew> ok, so then you just need to read the little words - when there are words :(
02:57:16 <ski_> > error . show $ Just "Erro"
02:57:16 <lambdabot> Add a type signature
02:57:20 <ski_> > error . show $ Just "Erro" :: ()
02:57:21 <lambdabot> Exception: Just "Erro"
02:57:29 <ski_> > error . show . show $ Just "Erro" :: ()
02:57:30 <lambdabot> Exception: "Just \"Erro\""
02:57:33 <skew> joelr1: that's what I think it means
02:58:03 <dons> ski_  uses error for putStr , hacker alert :)
02:58:15 * ski_ smiles
02:58:31 <o_Rocky> lol
02:58:34 <twb`> Don't you just *hate* single-character errors?
02:59:14 <twb`> I spent at least half an hour on this one.
02:59:19 <skew> joelr1: too bad there's no tryWaitQSem, but other than that, it looks like it should do what you need
02:59:51 <skew> joelr1: have you made a list of your problems somewhere?
03:00:09 <lisppaste2> joelr1 pasted "Bounded Queue" at http://paste.lisp.org/display/14724
03:00:19 <o_Rocky> i think you don't get my problem...
03:00:23 <joelr1> skew: i send them all to simon m :)
03:00:36 <joelr1> folks, could you please review my bounded queue implementation?
03:00:39 <skew> joelr1: You've pointed out a great many things that could use work, having them collected somewhere would be nice
03:01:38 <joelr1> skew: hmm... like what things? could you give me an example?
03:02:35 <o_Rocky> the type of the function is (RTree a) so, it means that as long as (Show a) => (RTree a) i will have the same problem...
03:03:10 <o_Rocky> always if a :: ......... String .....
03:04:05 <joelr1> skew: i'm posting things in my blog as i figure them out 
03:04:27 <skew> joelr1: well, the profiling problems and crashes are big. It seems like threading+ffi needs better documentation, and maybe threading needs better performance
03:04:31 <joelr1> skew: i'm battling laziness at the moment
03:04:57 <skew> the queue looks right. You might want a tryReadQ function
03:04:59 <joelr1> skew: but yes, i'm with you. i keep a careful log of what i do and what happens now 
03:05:21 <joelr1> skew: I don't need a try for now
03:05:39 <joelr1> skew: http://wagerlabs.com is where i post things
03:06:21 <skew> I didn't even realize you could write one without try functions for QSem before I saw your code
03:06:45 <joelr1> skew: :-)
03:07:30 <skew> you're working on very different sorts of programs than we usually write, it's a good case study
03:08:04 <joelr1> skew: pioneers always get arrows in their back :D
03:08:15 <skew> I'm surprised it's taking hours to start up 2000 bots
03:08:57 <wilx> o_O
03:09:30 <joelr1> skew: they do a lot of things like initialize OpenSSL 
03:09:36 <joelr1> skew: but i'm surprised too
03:09:42 <skew> initialize OpenSSL?
03:09:55 <skew> like, call some library initialization function?
03:10:02 <skew> or just make a connection?
03:10:06 <joelr1> skew: i was even more surprized when my client's guy started running out of memory with 100 bots playing
03:10:09 <joelr1> on a 1Gb machine
03:10:18 <joelr1> skew: go through a custom ssl handshake
03:10:53 <joelr1> the running out of memory is caused at least in part by each bot retrieving a list of tables (40-50k chunk)
03:11:08 <joelr1> skew: need to run. check out my blog.
03:11:41 <wilx> What kind of bots?
03:11:58 <skew> some kind of poker server, I think
03:12:34 <wilx> Ah.
03:18:41 <twb> Anyone wanna look at my page of parsec code and suggest refactorings?
03:18:57 <twb> http://twb.ath.cx/~twb/darcs/miscellaneous/parsewiki/parser.hs
03:41:26 <asdasd> hey dons: thanks for the hint
03:41:49 <asdasd> i solved the problem
03:42:02 <asdasd> with a show . show
03:42:57 <o_Rocky> it seems kind of silly but it works
03:43:49 <dons> great :)
03:47:33 <kowey> does the top of http://haskell.org/hawiki/HaskellIrcPastePage look like the correct way to launch a subprocess?
03:48:20 <dons> basically, yes.
03:48:38 <kowey> hmm... still stumped then... thanks
03:49:54 <dons> you may have laziness issues with the output, so better to use somethinge like http://www.cse.unsw.edu.au/~dons/code/lambdabot/PosixCompat.hs
03:50:04 <soysauce> @type ixmap
03:50:05 <lambdabot> Not in scope: `ixmap'
03:50:10 <soysauce> @type Data.Array.ixmap
03:50:11 <lambdabot> forall e i j.
03:50:11 <lambdabot> (GHC.Arr.Ix j, GHC.Arr.Ix i) =>
03:50:11 <lambdabot> (i, i) -> (i -> j) -> GHC.Arr.Array j e -> GHC.Arr.Array i e
03:50:50 <dons> kowey, look at the implementation of popen in that module, it's the code you're looking for
03:51:33 <soysauce> @type Data.Array.listArray
03:51:34 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
03:51:47 <kowey> dons: thanks... trying to digest that
03:54:01 <dons> just like your code, except we evaluate the output explicitly, to make sure its all read before closing
03:54:17 <dons> you can ignore everything up to  "   (inp,out,err,pid) <- runInteractiveProcess ... "
03:55:38 <kowey> hmm... so a possible consequence of not doing this is that
03:55:48 <kowey> only some or none of the output is read back?
03:55:58 <soysauce> isn't there a way to use variables from the type signature inside a where clause?
03:57:17 <kowey> there's also this interesting business of catching an Exception from waitFromProcess
03:57:37 <ski_> soysauce : 'where' ?
03:57:41 <dons> yeah, so you can lose some output if it's really long, kowey
03:58:06 <Cale`> soysauce: if you name those type variables in the pattern
03:58:07 <dons> and the waitFromProcess wants to throw an exceptoin on some OSs if the process has already terminated when you call wait.
03:58:11 <dons> so we just ignore that.
03:58:36 <soysauce> ski - something like this:
03:58:46 <kowey> interesting... my problem is more non-termination of the subprocess... but i'll see if this has any effect
03:58:53 <soysauce> foo :: (IArray a e) => [e] -> a e
03:59:05 <soysauce> er
03:59:11 <ski_> soysauce : type ascriptions in LHS patten will scope over whole clause, including 'where' part, i believe
03:59:21 <soysauce> they don't seem to
03:59:26 <dons> kowey, well you could always send a signal to it, if necessary
03:59:29 <soysauce> maybe I'm wrong, though
04:00:00 <Cale> soysauce: they ought to, though if not, you could rewrite the thing in terms of let
04:00:19 <soysauce> let wouldn't fix the problem; isn't let basically the same thing as where?
04:00:19 <kowey> well dons... it is *supposed* to terminate by itself, isn't it? kinda weird, i could set theCmd to cat and it won't come back
04:00:38 <dons> i'm not sure. depends on what command you're running on the other end of the pipe
04:01:01 <kowey> i mean, if i call it from the shell, the subprocess, it comes back...
04:01:05 <soysauce> solvegr :: (IArray a e, Ix (i, i), Num e, Ord e) => a (i, i) e -> e -> [i] -> e
04:01:05 <soysauce> solvegr a mint xs = 0
04:01:05 <soysauce> 	where a  = listIUArray xs
04:01:13 <dons> hmmm. well lambdabot uses this code all the  time, but it's also compiled with -threaded. maybe that's making some difference?
04:01:33 <soysauce> listIUArray :: (IArray UArray e, Ix i) => [e] -> UArray i e
04:01:38 <ski_> foo (es :: [e]) :: a e = ...
04:01:39 <ski_>   where
04:01:40 <kowey> maybe... -threaded was what i was originally compiling with
04:01:40 <ski_>   ...
04:01:48 <soysauce> but I have no way to bind the i variable
04:02:02 <soysauce> so GHC is complaining, and I'm trying to pacify it.
04:02:09 <kowey> i've been meaning to ask the mailing list, but i keep getting bogged down in all these variables :-) (i.e. threaded or not, shell script or not, etc)
04:02:42 <soysauce> anyway, I tried adding an explicit type signature on a and it didn't work; let me see what the error message is
04:03:06 <ski_> soysauce : hm, that 'solvegr' above seems odd .. you don't seem to use 'a' defined in 'where' part
04:03:16 <soysauce> ski_ - because I haven't written that code yet
04:03:35 <ski_> why do you have an arg also named 'a' ?
04:03:52 <ski_> (that will be overshadowed, i think)
04:04:17 <soysauce> ...because I created a new variable a in the where clause to hold a sub-expression that I was trying to fix
04:04:21 <soysauce> and didn't notice the parameter
04:04:33 <ski_> soysauce : anyway, did you tried something of the line of 'foo (es :: [e]) :: a e = ...' ?
04:04:44 <ski_> ok
04:04:49 <ski_> s/tried/try/
04:04:57 <soysauce> es is fine, I need to bind i
04:05:01 <ski_> hm
04:05:22 <ski_> solvegr a mint (xs :: [i]) = ...
04:05:22 <ski_> ?
04:05:22 <soysauce> the problem is that listIUArray returns UArray i Word32 (I think e is Word32; not sure anymore)
04:05:43 <soysauce> oh, wait a second
04:06:40 <soysauce> well nevermind, forget it, it's too much of a pain to make these functions polymorphic
04:06:44 <soysauce> I think I'd rather finish the program
04:09:05 <triplah> hmm, i got my haskell question right on my exam at least :)
04:09:41 <triplah> create a function that generates more and more accurate approximations of the golden mean
04:09:49 <triplah> using list comprehension
04:09:53 <soysauce> Fibonacci sequence, eh
04:10:08 <triplah> fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2)
04:10:09 <triplah> golden = [(fib n)/(fib (n-1)) | n <- [2..]]
04:10:10 <triplah> yep
04:10:16 <triplah> and my answer runs
04:10:22 <triplah> yay, i know i got one answer right :D
04:10:55 <triplah> interesting, because im learning about the golden mean in multimedia at the moment
04:11:00 <triplah> i have an exam for that tomorrow
04:11:03 <triplah> so boring :\
04:11:04 <soysauce> > (sqrt(2.0) - 1)/2
04:11:05 <lambdabot> 0.20710678118654757
04:11:08 <soysauce> er, hm
04:11:20 <soysauce> oh, whoops
04:11:56 * soysauce attempts to remember the formula
04:12:00 <triplah> > fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2); golden = [(fib n)/(fib (n-1)) | n <- [2..]]
04:12:01 <lambdabot>  parse error on input `='
04:12:04 <triplah> boo
04:12:05 <triplah> :)
04:12:19 <triplah> > let fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2) in golden = [(fib n)/(fib (n-1)) | n <- [2..]]
04:12:20 <ski_> (triplah : you can write 'golden = [fib n / fib (n-1) | n <- [2..]]')
04:12:20 <lambdabot>  parse error on input `='
04:12:31 <Cale> triplah: the golden ratio is really neat
04:12:42 <triplah> ahh, yeah i didnt want to take an chances in the exam
04:12:42 <triplah> :P
04:12:46 <Cale> It satisfies a lot of really cool properties :)
04:12:52 <triplah> Cale: yeah!
04:12:55 <ski_> > > let fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2); golden = [fib n / fib (n-1) | n <- [2..]] in take 10 golden
04:12:56 <lambdabot>  parse error on input `>'
04:12:58 <ski_> > let fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2); golden = [fib n / fib (n-1) | n <- [2..]] in take 10 golden
04:12:59 <lambdabot> [2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619047619047619,
04:12:59 <lambdabot> 1.6176470588235294,1.6181818181818182,1.6179775280898876]
04:13:28 <soysauce> > (1 - sqrt(5.0))/2
04:13:30 <lambdabot> -0.6180339887498949
04:13:34 <soysauce> > (1 + sqrt(5.0))/2
04:13:35 <lambdabot> 1.618033988749895
04:13:36 <triplah> starts getting very slow very quickly, of course with dynamic programming it'd be a lot faster, i didnt want to try that in the exam though
04:13:37 <triplah> :)
04:13:43 <soysauce> my approximation is better. ;)
04:13:48 <triplah> nice :)
04:14:01 <Cale> Newton's method would work
04:14:19 <ski_> Cale : have you seen Baez' Golden Object ?
04:14:53 <sieni> of course it is very easy to compute large fibonacci numbers by taking matrix powers
04:15:06 <Cale> ski_: no
04:15:24 <ski_> Cale : http://math.ucr.edu/home/baez/week202.html (and 1 or 2 following weeks, iirc)
04:15:57 <Cale> oh
04:16:20 <soysauce> @hoogle ixmap
04:16:21 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j)
04:16:21 <lambdabot> -> a j e -> a i e
04:16:21 <lambdabot> Data.Array.ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e ->
04:16:21 <lambdabot> Array i e
04:16:49 <triplah> better get back to study :)
04:16:52 * triplah runs
04:16:54 <soysauce> still got exams?
04:16:57 * soysauce is done, done, done
04:17:03 <triplah> yep, one more
04:17:05 <soysauce> ...except for this Haskell project
04:17:08 <soysauce> ah, not bad. Good luck.
04:17:09 <Cale> I hate Baez' notation :)
04:17:21 <triplah> im afraid i did very poorly on my principles of prograaming subject
04:17:29 <triplah> spent too much time playing with haskell :P
04:17:42 <triplah> and not learning how to write out search trees for prolog clauses
04:17:49 <ski_> Cale : which ?
04:17:58 <Cale> But I actually have seen that combinatorial structure before
04:18:26 <Cale> "and set X = 1"
04:18:37 <Cale> you can't really do that
04:19:04 <ski_> one can assume X = 1
04:19:20 <Cale> well, you can't talk about T anymore in that case :)
04:19:36 <Cale> T(1) isn't anything valid here
04:19:36 <ski_> why ?
04:20:01 <ski_> agree
04:20:06 <ski_> that line is nonsense
04:20:42 <ski_> it should say  T = 1 + T^2  (under previous assumption of X = 1)
04:21:13 <ski_> ('G^2 = G + 1' further down would be the golden object, anyway)
04:22:20 <Cale> there doesn't seem to be any good reason for substituting anything
04:22:42 <Cale> you can't substitute real numbers into a formal power series unless you can show convergence
04:22:45 <ski_> he seemed to there want trees with trivial elements
04:22:48 <Cale> and convergence doesn't happen here
04:23:16 <Cale> So it's just kind of all wrong after he starts doing that
04:23:35 <Cale> It's better to simply work with the bijections directly.
04:23:47 <Cale> Then people will know what you're talking about :)
04:24:12 <Cale> I can sort of see what he's getting at
04:24:56 <ski_> yes .. he's not working rigorous, there
04:25:09 <Cale> 1 + 1 + 2 + 5 + 14 + 42 + ... = (1 - sqrt(-3))/2
04:25:14 <ski_> it needs to be formalized properly, to possibly work, for real
04:25:18 <Cale> I suppose it all depends on what you mean by +
04:25:22 <ski_> heh
04:26:18 <Cale> Physicists seem to have this fear of moving away from numbers and real functions
04:26:33 <ski_> possible
04:26:38 <Cale> Well, I'm not sure if it's a fear
04:26:50 <Cale> but they seem to always compare every other abstraction to that
04:27:12 <ski_> as if it would be more basic, in some way :)
04:27:27 <tromp_> fib = recurrence [1,1] [0,1]
04:27:31 <sieni> well, there are these things called observations and they usually give some numerical result, which is to be compared to theoretical predictions
04:28:28 <Cale> sieni: yes, however that doesn't justify some of the things that they write :)
04:28:56 <Cale> I mean, if they want to claim to be using mathematics and logic.
04:29:25 <Cale> If on the other hand, they want to claim to be using an ad-hoc string-rewriting system with no known properties, I'm all for it.
04:31:14 <ski_> Cale : what do you think of object (in some rig category, he says) G, st  G^2  ~=  G + 1 ?
04:32:12 <Cale> The important thing when writing mathematics is not that things be formal, but that they be formalisable in some fashion which is obvious to people that might read it. I have a hard time believing that physicists have a particular formalisation in mind when I see some of the things that get written :)
04:32:16 <Cale> ski_: hmm
04:33:00 <ski_> Cale : mm
04:33:46 <Cale> (And indeed, formalising the things that they write takes a really long time)
04:35:27 <ski_> (because they are complex or because they are not quite right ?)
04:35:57 <Cale> because the theorems which they claim to apply don't have their preconditions satisfied
04:36:12 <Cale> so they're manipulating things semi-blindly
04:36:33 <joelr1> anyone willing to lend a hand with laziness?
04:37:00 <ski_> (ok)
04:37:34 <Cale> So coming up with objects that actually have the properties that they want and which still look something like what the physicists wrote is quite hard.
04:37:44 <Cale> joelr1: sure
04:37:49 <Cale> let me get a coffee
04:38:04 <joelr1> Cale: "Battling laziness" on haskell-cafe
04:42:14 <Cale> hmm
04:42:21 <Cale> can I see the full .prof ?
04:42:31 <joelr1> http://wagerlabs.com/randomplay.tgz
04:43:51 <Cale> hehe, randomplay.tgz already exists, do you want to replace it? :)
04:44:29 <joelr1> Cale ;)
04:45:27 <Cale> hmm
04:46:14 <Cale> I don't see the leak from this. Well, if you're concerned with that 7/8% allocation that script #9 does, I suppose
04:46:16 <joelr1> Cale: did you see Simon's last suggestion?
04:46:23 <joelr1> +RTS -hy -hcscript#9
04:46:26 <joelr1> running that now
04:46:29 <Cale> but otherwise you don't have a cost centre for it
04:46:52 <Cale> launchScripts Main 293 2043  91.7   90.9    99.6   99.6  39980 48520047668
04:47:04 <joelr1> well, let me post what that looks like
04:47:16 <Cale> that's really big, but the rest of the numbers in the .prof don't add up to that :)
04:47:41 <Cale> so whatever's doing the eating isn't marked
04:47:42 <lisppaste2> joelr1 pasted "launcScripts" at http://paste.lisp.org/display/14728
04:47:53 <joelr1> it just launches the bots, no?
04:48:36 <Cale> well... let's see
04:49:20 <xinming> what does Identity Monad do? :-/
04:49:28 <Cale> xinming: not much
04:49:39 <Cale> xinming: are you familiar with the container analogy?
04:50:07 <Cale> joelr1: could you annotate the hell out of launchScripts? :)
04:50:10 <joelr1> Cale: affiliateIDs is a list of lists of bytes where each nested list is 7 bytes on average and there are 100 of these "rows"
04:50:24 <joelr1> Cale: i sure can, let me do that next
04:50:25 <xinming> Cale: Not much. :-P
04:50:37 <Cale> xinming: did you read MonadsAsContainers?
04:50:50 <xinming> Cale: hold on, I'll search for it
04:50:50 <Cale> It might help here :)
04:51:00 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
04:51:20 <Lor> Shouldn't that be ContainersAsMonads?
04:52:22 <Cale> Lor: well, no :)
04:52:36 <Cale> If we really wanted to study containers, we'd end up with more than monads :)
04:53:21 <Cale> The idea is really just to provide a nice concrete picture of what the monad operations are doing. 
04:54:00 <Cale> xinming: For the identity monad, say  data Identity a = Id a
04:54:11 <Cale> We have  fmap f (Id x) = Id (f x)
04:54:17 <Cale> return x = Id x
04:54:27 <Cale> and  join (Id (Id x)) = Id x
04:54:31 <ski_> it's the trivial collection, always containing exactly one element
04:54:33 <Cale> yes
04:55:42 <Cale> In terms of computations, I suppose you would say that there are no additional semantics apart from the value obtained by "running" the values.
04:55:44 <ski_> (btw, i'd s/data/newtype/)
04:55:56 <Cale> yes, that would be appropriate :)
04:56:05 <ski_> right, so it's always pure, no effect
04:56:43 <ski_> forall ma :: Identity a. exists a :: a. ma = return a
04:57:36 <Cale> that's a nice way to put it
04:58:51 <ski_> hm, in MonadsAsContainers, can one see State actions as a big state transition table ?
05:00:30 <Cale> yes
05:00:44 <Cale> I make an attempt at describing that below
05:01:01 <ski_> i thought that was a bit shady expl. ..
05:01:07 <ski_> hm
05:01:39 <Cale> A value of type State s a is a box indexed by values of type s, and in each cubby-hole, we find another value of type s, and a value of type a :)
05:02:00 <ski_> e.g. boxen containing not only elems, but also new indices
05:02:07 <Cale> yep
05:02:16 <ski_> that's not the case with other collections, i think
05:02:54 <Cale> There are other possible collections which have that. Of course, any State-like monad will have that sort of thing going on.
05:03:11 <ProfTeggy> Apples and blueberries.  Yummy.
05:03:15 <Cale> :)
05:03:19 <ski_> i'm just not sure i'd say that has elems of type 'a'
05:03:29 <Cale> ski_: no?
05:03:31 * ProfTeggy walks off for the cantina
05:03:36 <ski_> Reader/Environment i buy
05:03:39 <Cale> To me, it seems obvious that it does :)
05:04:02 <Cale> I'm picturing the whole function s -> (s,a)
05:04:12 <Cale> the graph of that function
05:04:46 <ski_> maybe i haven't grasped the analogy/metaphor/pov right, but in my mind, the "elems" are pairs of values of type 'a' together with a index
05:04:59 <ski_> mhm
05:05:07 <Cale> oh, the new indices are part of the container structure
05:05:17 <ski_> as a set of pairs (s |-> (s,a)) ?
05:05:42 <ski_> Cale : yes .. i just don't fit that into it being a collection :)
05:05:57 <Cale> ski_: it's like how in, say a tree
05:06:13 <Cale> you have all these extra nodes which are in the tree
05:06:24 <Cale> which don't have values of type a on them
05:06:28 <ski_> possibly i'm confused by comparing to Environment
05:06:55 <Cale> well, you shouldn't be confused too much by that view
05:07:30 <ski_> i guess i'm maybe sort of wondering how a 'lookup' would work
05:07:35 <Cale> it's just that next to the little plaque on which the index of each cubbyhole is engraved, we have another little plaque engraved with a second index.
05:07:50 <ski_> (that being a red herring, i know, but it's hard to not think so)
05:08:03 <Cale> A lookup applies the function
05:08:22 <ski_> and returns an elem
05:08:29 <ski_> here we get a new index, too
05:08:32 <ski_> though
05:08:43 <Cale> yes, we can throw that away if we like
05:08:54 <Cale> :)
05:09:06 <ski_> in some other cases, we get 'Maybe a' back (not all paths/indices valid)
05:09:15 <Cale> hm?
05:09:16 <ski_> throw away = bad :)
05:09:23 <Cale> no, it's fine
05:09:27 <ski_> @type lookup
05:09:28 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
05:09:36 <Cale> ah, in general
05:10:21 <Cale> but here there's some assurance that we'll either get a value of type 'a', or nontermination :)
05:10:35 <ski_> *and* a new index
05:10:53 <Cale> and a new index, but we can ignore it if we just want to do the lookup
05:11:02 <ski_> e.g. we can't throw away the world
05:11:02 <Cale> the second index is part of the container-structure
05:11:16 <Cale> and it's used in the container operations
05:11:25 <Cale> (the monad operations)
05:11:38 <Cale> but it's not relevant to the thing's functioning as a container as such
05:11:58 <Cale> it's just an additional index sitting there in the data structure
05:12:20 <Cale> after all, when you map over the structure, you don't get to map over those secondary indices
05:12:26 <Cale> so they're not elements
05:12:42 <Cale> (with fmap)
05:12:47 <ski_> m, point (FunctorsAsContainers)
05:12:52 <Cale> yes
05:13:07 <ski_> (does that hawiki page exist ?)
05:13:12 <Cale> hehe, no
05:13:21 <ski_> anyway
05:13:27 <ski_> <ski_> e.g. we can't throw away the world
05:13:32 <Cale> I thought I took care of that, sort of, in that article.
05:13:54 <Cale> This sort of thinking is from another conflicting analogy :)
05:14:00 <Cale> hehe
05:14:01 <ski_> and, that is an important use of state monads
05:14:06 <Cale> yes
05:14:37 <ski_> (you can substitute world with ST inner state, or linear array or some other linear object, if you wish)
05:14:43 <Cale> It might be worthwhile to look closely at 'join'
05:14:56 <Cale> Using the container analogy only
05:15:18 <Cale> and you can see that the extra tags serve a structural purpose
05:15:47 <ski_> hm, somehow remniscent of some tree monad, i think
05:15:47 <Cale> You mentioned that you don't like throwing things away :)
05:16:05 <Cale> In the case of Reader
05:16:32 <Cale> when we join, we apply the environment value twice
05:16:40 * ski_ wants to keep things doable in linear logic, if possible (possible with help of few select "exponentials" to get back copying and discarding in some cases)
05:16:50 <Cale> join xss = (\k -> xss k k)
05:16:53 <Cale> right?
05:17:20 <ski_> yes
05:17:38 <Cale> Even though xss k is another whole box with a world of elements in it, we're constrained to picking that same corresponding slot that we picked (k)
05:18:26 <Cale> joining proceeds by doing a lookup at k, then another lookup at k
05:19:02 <Cale> When we remove that indirection, we conceptually throw away a potentially infinite amount of information.
05:19:21 <ski_> no :)
05:19:31 <Cale> Well, yes
05:19:36 <ski_> this is 'lolli' (linear implication) in linear logic
05:19:56 <Cale> (xss k) itself has lots of elements in it
05:20:01 <ski_> if you think of that as a container, then it's an *additive* container
05:20:07 <Cale> and we throw them all away, and choose the one at k
05:20:13 <ski_> it's only designed to extract exactly one element from
05:20:33 <Cale> well, I'm not thinking about it like that
05:20:52 <ski_> you're thinking of it like an array (or finite function/map)
05:20:55 <ski_> right ?
05:21:07 <Cale> not necessarily finite function
05:21:16 <ski_> i know
05:21:18 <Cale> but yeah, a potentially infinite array
05:21:26 <ski_> yes
05:21:32 <ski_> and that is a different thing
05:21:34 <Cale> with one box for every value of e
05:21:39 <ski_> different connective
05:21:46 <Cale> than what?
05:21:52 <ski_> than linear implication
05:22:02 <ski_> which is what reader uses
05:22:05 <Cale> what does that have to do with anything?
05:22:07 <Cale> hm?
05:22:22 <Cale> It's got to work out to the same thing in the end though :)
05:22:38 <Cale> (even though I don't actually know anything at all about linear logic)
05:22:45 <ski_> they are different, just like additive and multiplicative conjunction is different
05:22:57 <Cale> sorry, I don't really know those terms
05:23:01 <Pupeno> Can one Cabal package contain more than one library ?
05:23:39 <ski_> an additive pair is potential, you get to choose which part you want ('fst' and 'snd') and then use that part
05:24:08 <Cale> but not the other?
05:24:10 <ski_> an multiplicative pair is actuality/both, you must use both parts ('let (x,y) = ... in ...')
05:24:13 <ski_> right
05:24:27 <Cale> okay, I don't really see the need for that distinction here :)
05:24:42 <ski_> in intuitionistic logic, these separate concepts merge into the usual conjunction
05:24:47 <Cale> since none of our resources are consumable
05:25:10 <ski_> if one's talking about linearity, then this distinction appears
05:25:16 <Cale> okay
05:25:17 <ski_> hm, elaborate ?
05:26:05 <Cale> well, things don't go away, we can apply them however many times we want. Haskell doesn't have an additive pair type.
05:26:10 <ski_> (in similar way, a linear function must be applies once, and then one get one result .. otoh one must extract every element from a linear array)
05:26:50 <Cale> Perhaps I'm not seeing the abstraction which you are here :)
05:27:05 <Cale> I'm thinking of these things purely in terms of Haskell values.
05:27:06 <ski_> Cale : (since Haskell has no linear type system) .. sadly, neither Clean or mercury does, either (even though they do)
05:27:18 <Cale> I'm not sure I'd want such a thing :)
05:27:21 <Cale> hehe
05:27:26 <ski_> arg
05:27:37 <ski_> s/do/do have a linear system/
05:27:50 <Cale> anyway, brb
05:28:14 <Cale> try to think of it as multiplicative conjuntion anyway
05:28:25 <kowey> dons: i think i've fixed my process issues
05:28:37 <kowey> it seems... and this is weird... that you *have* to read from its stderr
05:28:38 <ski_> linear logic has methods of regaining copying and discarding in controlled fashion, when needed, though
05:28:41 <Cale> and have a look at what join does in state in that case
05:28:42 <ProfTeggy> Bbl
05:29:54 <Cale> I have a love-hate relationship with constructive logic. It seems nice philosophically, but it disagrees with the way that I think in actual use.
05:31:58 <ski_> how about double negation elimination and excluded middle ?
05:32:19 <ski_> what is your opinion on them ?
05:46:31 <Cale> ski_: I'm usually happy with them
05:47:21 <ski_> did you know that they are allowed in linear logic ?
05:47:48 <Cale> I don't actually know anything about linear logic apart from what you've mentioned :)
05:47:49 <ski_> (iirc, Girard claims linear logic is more constructive than intuitionistic logic, btw)
05:48:18 <ski_> (so, it's constructive, *and* allows those proof methods :)
05:48:41 <Cale> but what fails?
05:49:12 <ski_> sorry ?
05:49:28 <Cale> well, if it's seen as constructive
05:49:49 <Cale> surely there are things which you can't do with it, relative to ordinary logic
05:50:42 <ski_> well, you can embed classical logic in it
05:51:22 <Cale> Oh, then how can it be seen as constructive?
05:51:26 <ski_> but, discarding and copying (i.e. weakening and contraction) is no longer allowed, universally
05:51:39 <Cale> hmm
05:51:57 <ski_> so, you can't reuse all assumptions, and can't choose to not use all of them, either
05:52:22 <ski_> if you want a reusable assumption, you wrap it in the "of course" unary connective
05:52:52 <ski_> '|- A -> (B -> A)' is not derivable
05:53:02 <ski_> '|- A -> (!B -> A)' is derivable
05:53:15 <ski_> '|- A -> (A /\ A)' is not derivable
05:53:21 <ski_> '|- !A -> (A /\ A)' is derivable
05:54:15 <Cale> hehe, I'm not sure I'd care for that sort of an effect usually.
05:54:33 <Cale> What's to stop me from simply always using ! ?
05:54:39 <ski_> nothing :)
05:54:56 <Cale> okay, so I can go ahead and prove things nonconstrucively :)
05:55:01 <Cale> t*
05:55:17 <ski_> except sometimes you can get more general results by not using '!' in some places
05:55:18 <Cale> but it won't look the same
05:56:35 <ski_> i think it may be that (at least part of) nonconst. in classical logic comes from conflating additive and multiplicative connectives
05:56:37 <Lor> You can encode classical logic in ordinary constructive logic, too.
05:56:43 * ski_ knows
05:57:45 <Cale> as in, in intuitionistic logic?
05:58:11 <ski_> e.g. '|- A `Either` Not A' is not derivable, but '|- A `Par` Not A' is derivable
05:58:22 <Cale> Of course, you can do the usual model-theory hack :)
05:58:38 <ski_> ('Either' being additive disjunction, and 'Par' being multiplicative disjunction)
05:58:49 <Cale> Though, if your external mathematics isn't the same, that's kind of interesting.
05:59:28 <ski_> '|- A `Par` Not A' is basically the same as '|- A -> A', while '|- A `Either` Not A' is another thing
06:00:40 <ski_> so, e.g., from proof of '|- A `Par` Not A' you can't tell which one was proved, since that's not how 'Par' (multiplicative disjunction) works
06:01:13 <ski_> s/one/part/
06:01:41 <Cale> I suppose the trouble I have with it is more that the notation is confusingly suggestive. As long as you remember that you're actually not talking about the same thing, it's all right :)
06:02:12 <ski_> in intuitionistic logic, a proof of a disjuction should be of one of the possible two form .. this is a reason why excluded middle doesn't work, there
06:02:36 <ski_> Cale : 'it' being ?
06:02:48 <boro> is here someone who have free time, patience and who can help with homework :S ?
06:02:49 <Cale> other logics :)
06:03:10 <Cale> boro: so long as by 'help with' you don't mean 'do' :)
06:04:05 <boro> well. i want to know how things goes, but i'm too begenner in haskell to do that game they want me to do :S
06:04:21 <ski_> what are you stuck on, rn ?
06:05:06 <musasabi> boro: trying to understand things will benefit you - if you just get someone to do your homework the next one will be even harder for you
06:05:36 <Cale> Anyway, everyone here is eager to answer questions you might have about how to get things done in Haskell
06:05:49 <boro> musasabi, i know, but there will be nexr homework in haskell i can return back to my life :P
06:05:53 <xerox> Hi
06:05:59 <Cale> Hi xerox 
06:06:02 <boro> next*
06:06:14 <ski_> guten tag, xerox
06:06:20 <Cale> boro: you ought to learn Haskell properly anyway -- it's a wonderful programming language, and fun to write programs in
06:06:24 <boro> asdas. there will be not next hoework*
06:06:50 <Cale> boro: It's a very practical language when you actually get down to using it.
06:07:30 <boro> yes, it's nice langue, but my orientation is php and C#
06:08:08 <Cale> Learning Haskell will change the way you program in those languages too :)
06:08:27 <Cale> Though I'm not sure there's anything one can do to make PHP code sane :)
06:08:38 <xerox> @babel de en guten tag
06:08:40 <lambdabot>  good day
06:08:51 <xerox> @babel it de altrettanto
06:08:52 <lambdabot> babelmodule failed: Prelude.head: empty list
06:09:00 <ski_> Cale : hm, e.g. one thing which i think linear logic could do, is to make use of continuations referentially transparent
06:09:02 <xerox> @babel en de you too
06:09:03 <lambdabot>  Sie auch
06:10:01 * ski_ is a bad german speaker
06:10:44 <ski_> boro : what things do you want to know how they goes in haskell, for the moment ?
06:11:22 <musasabi> Does anyone have NNTP code in Haskell?
06:11:31 <boro> ski_ right now i don't have guestions. i'm tring to understand that game protocol 
06:11:41 <ski_> mhm
06:12:21 <ski_> (stick around until you get questions then, i suggest :)
06:12:39 <Cale> musasabi: I remember there was some interest in one a while back, I'm not sure if anything was written
06:13:58 <ski_> (hm .. there appear to be another proj. named 'conjure', too ..)
06:24:07 <TFK> Hi guys. I want to get hopengl for ghc6 in Ubuntu, and it tells me that I need xlibmesa-gl-dev and xlibmesa-glu-dev, but it says they're not installable. Did anyone else have this problem?
06:26:31 <Cale> xerox: would you know anything about that?
06:26:46 <Cale> TFK: that package installs fine for me on debian at least
06:26:56 <Pupeno> TFK: I've found various problems with Haskell related packages on Ubuntu (and Debian), I am working on it (making an alternative repository with updated working pakcages).
06:27:25 <Pupeno> TFK: Some Haskell packages are just copied from Debian and are not properly Ubuntunized.
06:27:44 <Cale> hehe Ubuntunized
06:28:13 <TFK> I see. It's not ready now, is it?
06:28:25 <Pupeno> TFK: not yet.
06:28:44 <chucky> pupeno: What problems?
06:29:17 <chucky> I haven't seen any, and I run ubuntu. But I don't code much Haskell at home right now, so I haven't actually tested them much
06:29:29 <TFK> Oh well. Best of luck :-) I suppose I'll have to use ghc on Windows then.
06:29:34 <Pupeno> chucky: I've found a couple of packages that failed to install because the post-script failed.
06:29:41 <Pupeno> TFK: oh no!
06:30:08 <Cale> TFK: why is xlibmesa-gl-dev not installable?
06:30:14 <TFK> Beats me.
06:30:27 <chucky> pupeno: ack, that sucks
06:30:34 <Pupeno> TFK: are there working packages of Haskell-related programs and libs for Windows ?
06:30:34 <Cale> hmm, it's actually not installed on my machine
06:30:50 <Cale> TFK: you're attempting to install ghc6-hopengl?
06:31:51 <TFK> It suggests to check whether the appropriate repositories are installed. But I have multiverse on, and the separate haskell repository for ubuntu. Not sure what repo might contain those, google wasn't helpful.
06:32:27 <Pupeno> TFK: haskell repository ? which one ?
06:32:40 <TFK> Pupeno, yes, and HOpenGL should work fine in win32.
06:33:06 <TFK> The Debian one, judging by the link: http://haskell-unsafe.alioth.debian.org/archive/i386
06:33:16 <Pupeno> I have ghc6-hopengl working.
06:33:32 <Pupeno> TFK: Don't mix debian and ubuntu, they are different and that leads to problems.
06:33:49 <Pupeno> TFK: that is even unstable in Debian itself.
06:34:19 <TFK> What am I supposed to use, then? Last time I checked, Haskell wasn't in Ubuntu's main repos.
06:34:20 <Pupeno> TFK: if you want a package that is not available on Ubuntu, from Debian, re-build it, that's the safest path.
06:34:22 <Cale> that's not actually an official Debian package repository
06:34:53 <Cale> ghc6-hopengl is available in ubuntu itself, you should use that package
06:35:23 <Cale> http://packages.ubuntu.com/hoary/devel/ghc6-hopengl
06:35:48 <TFK> Hmm. I'll remove that Debian repo from Synaptic, let's see if something moves.
06:36:01 <Pupeno> or http://packages.ubuntu.com/breezy/devel/ghc6-hopengl ;)
06:36:27 <Pupeno> TFK: do an apt-get update after that, run synaptic and remove all obsoleted/local packages, or you would still be in trouble.
06:36:32 <Cale> whichever -- I don't really know what the ubuntu versions are
06:36:40 <Cale> (I just googled that)
06:36:47 * TFK nods
06:37:14 <Cale> oh, further, the dependence on xlibmesa is gone in the breezy version
06:37:33 <Cale> libgl1-mesa-dev is there instead
06:37:45 <Cale> and libglu1-mesa-dev
06:42:32 <TFK> OK, all good now. Thanks a bunch! :-)
06:42:49 <Cale> :)
06:46:31 <boro> How do i make Client-Server Sstem. Server asks: WHO and my code will answer: NAM Blaablaa 
06:48:35 <ADEpt> boro: client: (main = putStrLn "WHO"), server: (main = mapM_ reply (sequence (repeat readLine)) where reply "FOO" = putStrLn "NAM"; reply _ = return())
06:49:03 <Lor> s/FOO/WHO/
06:50:15 <Cale> boro: is this over the network?
06:50:26 <boro> nope
06:50:44 <boro> i upload my file to schoolserver or smt 
06:50:50 <boro> the server part has been already done
06:50:54 <boro> i have to make client
06:51:00 <boro> for battleships game
06:51:01 <Cale> (I mean, the communication between the programs)
06:51:25 <boro> i think not.
06:51:29 <Cale> okay
06:52:29 <boro> What was that code paste page for this channel ?
06:53:18 <psi> lisppaste2: url?
06:53:18 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:55:15 <lisppaste2> boro pasted "Battleships" at http://paste.lisp.org/display/14730
06:55:59 <boro> Cale. this is my source right moment. i upload this throw webpage and get answer like this:
06:56:00 <boro> Server> WHO
06:56:00 <boro> Client> NAM ELIIT
06:56:00 <boro> Server> NAM Nestra
06:56:00 <boro> fd:15: commitAndReleaseBuffer: resource vanished (Broken pipe)
06:56:45 <boro> how to hold that connection until Server givs EXT
06:56:58 <boro> right now, it should give me command lik: Server> PAR 1111222334 straight
06:57:17 <boro> but as i see, there will be now connection or smt
06:58:49 <roconnor> Time for me to learn how to use darcs!
06:59:13 <eivuokko> It's time well-invested :)
06:59:25 <Cale> boro: er, hmm... Is there perhaps supposed to be a main :: IO () ?
07:00:57 <boro> Cale, but module name is fpkodu2 ?
07:01:48 <Cale> boro: well, it depends on what they expect -- if you compile that code to a binary, it will probably complain about not having a main
07:02:02 <Cale> (unless there's some kind of harness that I don't know about)
07:02:15 <Cale> anyway, I'll be back in a while
07:02:43 <boro> umm. but after uploading file, webpage say's it compiled
07:04:46 <Speck> what does the constructor for type Query r = forall a. Type a -> a -> r expand to?
07:05:19 <Cale> boro: okay then, I have no idea :)
07:05:36 <shapr> shazam!
07:07:14 <roconnor> that explains why I was having trouble connecting.
07:09:32 * roconnor takes a deep breath and does darcs initalize
07:14:42 <boro> But how to i get server command. i mean how do i compare them. If servers says NAM, then my code will do something and if server says: EXT my code will disconnect or smt
07:14:55 <Cale> boro: perhaps with getLine?
07:15:04 <Cale> @type getLine
07:15:05 <lambdabot> IO String
07:19:34 <boro> whats wrong
07:19:35 <boro> fpkodu2 = do "WHO" <- getLine
07:19:35 <boro>           putStrLn "NAM ELIIT"
07:19:55 <boro> 4:13: The last statement in a 'do' construct must be an expression
07:20:08 <roconnor> Hey, darcs is awsome.
07:21:44 <boro> haha, more spaces needed :d
07:22:11 <xerox> boro: eheh, proper indentation :-)
07:28:25 <boro> can't i use it morw than one time ?
07:28:25 <boro> fpkodu2 = do "BGN" <- getLine
07:28:26 <boro>              putStrLn "NAM ELIIT"
07:28:26 <boro> fpkodu2 = do "BRD" <- getLine
07:28:26 <boro>              putStrLn "DOH Blaa"
07:29:15 <roconnor> darcs get http://r6.ca/FewDigits/
07:29:15 <Philippa_> you can't redefine a function, if that's what you mean
07:29:18 <Philippa_> you can call it twice
07:29:22 <roconnor> boy, this is easy.
07:29:55 <boro> Philippa_ how do i call it twice ? :>
07:30:10 <SamB> @seen jlouis
07:30:10 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 32 minutes and 2
07:30:10 <lambdabot> seconds ago.
07:31:06 <shapr> @seen
07:31:06 <lambdabot> Lately, I have seen boro, philippa_, roconnor, samb and shapr.
07:31:21 <shapr> roconnor: Yeah, darcs r0xx.
07:31:26 * Pupeno have just managed to build the first SCons-powered Haskell program :)
07:31:38 <SamB> Pupeno: ew, disgusting!
07:31:40 <roconnor> boro: do fpkodu2; fpkodu2
07:31:56 <Pupeno> SamB: you don't like SCons ?
07:32:14 <SamB> not a whole lot...
07:32:29 <Philippa_> boro: you just use it twice
07:32:31 <Pupeno> SamB: prefeer Make ?
07:32:55 <SamB> it seems not to have very good support for building build tools right before building your program...
07:33:07 <SamB> and it seems so very complicated
07:33:25 <SamB> Make at least isn't full of itself
07:33:41 <boro> Philippa_ something like this
07:33:42 <boro> fpkodu2 = do "BGN" <- getLine
07:33:42 <boro>              putStrLn "NAM ELIIT"
07:33:42 <boro>              "BRD" <- getLine
07:33:42 <boro>              putStrLn "DOH Blaa"
07:33:49 <Pupeno> SamB: you mean to use Cabal from SCons ?
07:33:58 <SamB> though apparantly it does somewhat much for its creator's taste...
07:34:21 <roconnor> You don't want quotes around "BGN", they are supposed to be new variable names.
07:34:26 <SamB> Pupeno: actually, I was trying to update the ZSNES SConsfile to work with a tool that Nach wrote
07:34:32 <roconnor> variable names need to begin with a lower case.
07:34:44 <SamB> he called it a language, but the input looked just about like ASM to me...
07:35:02 <Philippa_> asm's still a language
07:35:11 <Pupeno> SamB: it may be complex at times, but it also is simple at times. It is easier to add suppor for new tools to SCons than to make/autotools/etc.
07:35:16 <SamB> well, the output also looked like that ;-)
07:35:24 * Pupeno doesn't know what ZSNES is.
07:35:45 <SamB> Pupeno: well, new tools and tools that need to be built from sources in the same tree are somewhat different from eachother
07:36:13 <SamB> ZSNES is an SNES emulator
07:36:20 <SamB> but that isn't too relevant
07:36:28 <boro> reconnor, those are not variables, those are server output words
07:37:06 <roconnor> oh, you are doing a match.
07:37:10 <roconnor> okay
07:37:26 <Pupeno> SamB: I know, SCons is not really prepared to build a tool to build the project. Mainly because that isn't often done.
07:37:56 <shapr> Hi Arc1000, learning Haskell?
07:38:21 <shapr> Have any questions?
07:38:47 <shapr> roconnor: Oops, I found the webpage for FewDigits, you can ignore the patch I sent...
07:38:54 <Arc1000> Just passing thru. Mainly have an interest in functional languages. browsing more thru the logs. 
07:39:11 <shapr> We also have an interest in functional languages :-)
07:39:38 <shapr> Are you interested in stuff like the lambda cube, dependent types, arrows, comonads, etc?
07:40:23 * TFK is interested in the time it takes GHC to compile Monadius
07:40:24 <roconnor> heh, I'm getting patches already.
07:40:51 <roconnor> I still think a readme of some sort may be a good idea.
07:40:57 <shapr> roconnor: What gives you that idea?
07:40:59 * shapr blinks innocently
07:41:18 <roconnor> Well, shouldn't the webpage be part of the repository?
07:41:22 <shapr> yes!
07:41:28 <roconnor> So I should add it.
07:41:30 <shapr> yes!
07:41:32 * shapr cheers
07:41:42 <shapr> Like I said before, darcs r0xx.
07:41:56 <roconnor> I will need to think about how I am going to organize this.
07:42:27 <shapr> You could just throw in the data and reorganize later.
07:42:36 <shapr> Darcs lets you move files around in your repo and keep their history.
07:42:41 <TFK> Does anyone one know what sound system Monadius uses? I get "undefined reference to `close_audio_w'" and such.
07:43:00 <shapr> TFK: I thought it used a windows only sound binding?
07:43:05 <shapr> Doesn't it directly import win32 sound calls?
07:43:22 <TFK> It does, only I'm trying to compile it on Linux :-/
07:43:37 <shapr> iirc, it dumps the sounds files into a handle that points to the sound device via the FFI
07:43:51 <shapr> I just commented out the sound parts, though they are rather deeply entwined.
07:43:56 <boro> Looks like servers doesn't get "NAM ELIIT"
07:43:57 <boro> fpkodu2 = do "BGN" <- getLine
07:43:57 <boro>              putStrLn "OK"
07:43:57 <boro> 	     "WHO" <- getLine
07:43:57 <boro>              putStrLn "NAM ELIIT"
07:44:22 <shapr> You may find it easier to make the sound calls NOOPs, or maybe add OpenAL support?
07:44:34 <TFK> no idea how.
07:46:31 <shapr> Ya know...
07:46:51 <shapr> Amazon claims to have new copies of Hamming's "The Art of Doing Science and Engineering: Learning to Learn" but they never do ship...
07:47:14 <shapr> I ordered that book the first time in .. July, I think.
07:48:18 <roconnor> shapr, BTW, it has to do with real number ;)
07:49:39 <shapr> Right, but what?
07:49:53 <roconnor> It defines them.
07:52:13 <shapr> Real numbers are hard, let's go unicycling!
07:53:12 <boro> Whats wrong here:
07:53:13 <boro> fpkodu2
07:53:13 <boro>   :: IO ()
07:53:13 <boro> fpkodu2 = do command <- getLine
07:53:13 <boro>              if command == "BGN"
07:53:13 <boro> 	                then putStrLn "OK"
07:53:15 <boro> 			else ""
07:53:17 <boro> 	     if command == "WHO"
07:53:19 <boro>                         then putStrLn "NAM ELIIT"
07:53:21 <boro> 			else ""
07:56:07 <shapr> It's polite to paste anything over three lines long using one of the paste bots.
07:56:17 <boro> ok
07:57:05 <tromp_> it's impolite to split fpkodu2 :: IO ()   over 2 lines:)
07:57:30 <tromp_> or shld i say bad style:-?
08:02:10 <boro> @paste
08:02:10 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:02:36 <boro> erm
08:04:05 <boro> http://boro.pri.ee/_code/index.php?code=
08:13:34 <xs> boro: you'll probably want to do return () or similar, instead of ""?
08:14:53 <boro> erm. maybe there are problem to, but i get error:
08:14:54 <boro> Couldn't match `IO ()' against `[Char]'
08:14:54 <boro>       Expected type: IO ()
08:14:54 <boro>       Inferred type: [Char]
08:14:54 <boro>     In a 'do' expression: if command == "BGN\n" then putStrLn "OK" else ""
08:15:16 <xs> yes, that's because of the ""
08:15:36 <xs> e.g., if command == "BGN" then putStrLn "OK" else return ()
08:15:46 <boro> do i use: else return () ?
08:15:52 <boro> or just return ()
08:16:14 <xs> else return ()
08:17:33 <boro> okei, but why my code exit after givin NAM ELIIT, but should wait for another server command
08:18:15 <gour> dcoutts: ping
08:18:33 <xs> boro: why should it?
08:18:48 <SamB> Pupeno: well, there is a significant minority of projects that do...
08:19:02 <boro> because it should exit after EXT command
08:19:54 <xs> boro: i don't see that code..
08:22:23 <boro> xs, http://boro.ee/FPKodu2.hs
08:24:54 <xs> hm
08:25:03 <xs> why do you think that will loop?
08:26:10 <boro> xs, how do i make it loop ? 
08:31:10 <xs> boro: do you know about recursion?
08:31:36 <tromp_> loop = do blablabla...; loop
08:36:38 <boro> erm
08:38:20 <boro> got it :)
08:43:21 <boro> stupid, but how do i make more than one thing after then.... if .... then firstthing; seondthing else... ?
08:46:50 <TFK> you can only put one expression there. Of course, it could be a big do clause/lambda definition/whatever.
08:56:52 <xerox> damnit.
09:00:44 <Oejet> xerox: What's up?
09:01:15 <xerox> I didn't see the 'chat.' thing until now
09:01:44 <Oejet> Me too.
09:12:12 <roconnor> @hoggle bool -> m () -> m ()
09:12:13 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
09:12:13 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
09:12:13 <lambdabot> Control.Parallel.par :: a -> b -> b
09:12:52 <roconnor> @type when
09:12:53 <lambdabot> Not in scope: `when'
09:12:57 <roconnor> @type Monad.when
09:12:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:13:38 <Azmo> anyone who knows if it is possible to get an automatic layout of multiple widgets in wxHaskell? i.e that one does not have to specify that the widgets are to be shown either in row or in column, but something will be chosen to minimize the window size the layout would need.. or something.. ?
09:13:54 <SlowByte> boro: tsk tsk, IRC's kodut66d siis lahendad ;)
09:14:08 <roconnor> boro, I think  you can use (Monad.when b putStrLn "foo") instead of (if b then putStrLn "foo" else return ())
09:14:29 <roconnor> actually you will just import Monad, and use when without the prefix.
09:14:54 <boro> SlowByte, natuke abi jah vaja
09:23:21 <jethr0> moin moin
09:23:39 <boro_> SlowByte, kes oled ?
09:23:56 <SlowByte> boro_: eestlane, obviously :D
09:29:35 <boro_> roconnor, can't use Monad, because file name does not match module name `Main' :P
09:29:47 <roconnor> ?
09:30:22 <roconnor> that shouldn't happen.
09:36:22 <jethr0> @where hmp3
09:36:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
09:39:13 <Saulzar> Hmm, after trying out the code written here... http://www.haskell.org/hawiki/TimingOutComputations, "return $ last [1..]" seems un-interruptable
09:39:43 <jethr0> weird
09:40:15 <Lemmih> Hiya SyntaxNinja.
09:49:20 <Saulzar> Seems that despite the killthread it never returns, but if I re-order it so it has the delay first in the list and uses forkOS it seems to finish
09:50:01 <Cale> Saulzar: um, how are you forcing its execution?
09:50:34 <Cale> return $ last [1..] returns immediately
09:50:50 <Cale> so it'll win against practically anything
09:51:29 <Cale> (you don't expect it to bother computing last [1..] do you? ;)
09:51:42 <Saulzar> Ahh... of course 
09:51:53 <Cale> you'll need to use  Control.Exception.evaluate
09:52:02 <Saulzar> Then it simply takes all year after it returns ..
09:52:08 <Cale> right
09:52:17 <Cale> when you actually demand that value
09:52:34 <Saulzar> Hmm, that's quite sneaky
09:52:37 <SamB> @hoogle (a -> m a) -> a -> m [a]
09:52:38 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
09:52:38 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
09:52:38 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:54:54 <Saulzar> Ah hah, much better
09:55:19 <jethr0> hmm, i get "Setup.lhs: cannot satisfy dependency sourceview-any" although i've got the lib and -dev installed :(
09:55:22 <jethr0> in Yi
09:55:52 <Saulzar> Is your gtk2hs compiled with it?
09:56:17 <jethr0> hmm, maybe not... i'll try that :)
09:56:19 <Saulzar> sourceview-any is part of gtk2hs, maybe it didn't compile for some reason
09:56:24 <jethr0> didn't think that far
09:56:34 <jethr0> installed it only after compiling gtk2hs
09:59:47 <jethr0> who was it that used w3m as browser?
10:04:36 <jose_da_bicla> has anyone ever use the timeout functionality of quickcheck successfully?
10:05:23 <jose_da_bicla> i'm testing a function that never ends however i never get a timeout...
10:16:29 <Speck> hmm... compile-time io from TemplateHaskellTutorial is quite interesting
10:17:17 <jethr0> yeah, someone's reading my "work"
10:19:54 <Speck> scary stuff
10:19:59 <jethr0> hehe
10:25:35 <SyntaxNinja> hiya Lemmih
10:25:43 <SyntaxNinja> Lemmih: any luck w/ cabal-get-and-friends?
10:25:59 <SyntaxNinja> bbiab
10:49:00 <newsham> hi
10:49:08 <newsham> Cale around?
10:49:08 <basti_> hi newsham 
10:49:22 <Cale> hello
11:15:52 <Lemmih> SyntaxNinja: cabal-install/cabal-get-bootstrap seems quite nice.
11:18:24 <Lemmih> SyntaxNinja: You wanted to move something from cabal-get to cabal-install?
11:31:45 <jethr0> awfully quiet today/night
11:32:59 <musasabi> @seen bringert
11:32:59 <lambdabot> I saw bringert leaving #haskell.se and #haskell 2 days, 22 hours, 21
11:32:59 <lambdabot> minutes and 3 seconds ago, and I have missed 4 seconds since then.
11:36:01 <SyntaxNinja> Lemmih: yeah, some kind of package dependency code should be in cabal-install, IMO.
11:36:14 <SyntaxNinja> Lemmih: so you specify 10 packages on the cli, and cabal-install figures out which order to intsall them in.
11:36:43 <SyntaxNinja> Lemmih: so I could do something like "find . -name "*.cabal"|xargs cabal-install"
11:37:05 <SyntaxNinja> Lemmih: unlike cabal-get, cabal-install should install all of them, even if they're already installed
11:37:20 <TFK> Are there any plugins for Haskell for Leo?
11:37:20 <SyntaxNinja> probably w/ an option to not install ones that are already installed
11:40:54 <Lemmih> Tsk. cabal-get isn't very user-friendly. I just used 5min to figure out why it wouldn't install Djinn.
11:42:02 <mjl69> if you put a abstract a function into \x->L format, what do you call the abstraction precisely?
11:43:13 <SyntaxNinja> heh
11:43:20 <SyntaxNinja> Lemmih: yeah, that's a problem.
11:44:57 <mjl69> anyway, check this out: http://www.rafb.net/paste/results/T6CEh240.html. I was just wondering why you can't use an anonymous function in a list comprehension.
11:45:12 <jethr0> mjl69: lambda expression
11:46:00 <mjl69> jethr0: lamda expression.  ok, got it.  the text book I was reading this morning kept calling it a functional abstraction and avoided giving it any other name.
11:46:20 <Cale> !
11:46:36 <Cale> Too bad that freenode doesn't allow unicode nicks
11:47:16 <Cale> I think it would be neat to have bot
11:47:26 <mjl69> is there a name for that function that goes at the beginning of a list comprehension (and why is it called a comprehension? so many questions :-) )
11:47:57 <Cale> It's called a list comprehension by analogy with set comprehension in mathematics
11:48:07 <mjl69> cool
11:49:02 <Cale> Which I suppose might be named from the fact that you're producing the comprehensive collection of things satisfying a given predicate.
11:49:26 <Cale> But I don't really know the etymology there
11:49:48 <Cale> hmm... is there a name for that bit at the front :)
11:51:17 <mjl69> oh, I looked up comprehension and one synonym is translation.  that would make sense, a translation of a list.
11:51:42 <Cale> hehe,  "comprehend" would be a funny answer to that
11:52:13 <jethr0> a comprehensive iteration
11:52:40 * Cale OEDs
11:52:44 <mjl69> so why can't you use the lambda expression as the function in a list comprehension?
11:52:55 <Cale> hmm?
11:53:04 <mjl69> Is it just that you don't need to?
11:53:46 <mjl69> > (x*x|x,<-[1,2,3,4])
11:53:46 <lambdabot>  parse error on input `|'
11:53:50 <mjl69> whoops
11:53:52 <Cale>     I. Inclusion, comprising.
11:54:04 <Cale>     4. Logic. The sum of the attributes comprehended in a notion or concept; intension.
11:54:17 <Cale>     2. The faculty or quality of comprehending; inclusive force; comprehensiveness.
11:54:19 <mjl69> > (x*x|x<-[1,2,3,4])
11:54:20 <lambdabot>  parse error on input `|'
11:54:34 <mjl69> whoops, wrong bracket
11:54:34 <Cale> > [x * x | x <- [1..4]]
11:54:36 <lambdabot> [1,4,9,16]
11:54:46 <mjl69> yeah, not in my finger memory perfectly yet.
11:55:05 <mjl69> >[x * x | x <- [1..4]]
11:55:06 <Cale> > zipWith ($) [\y -> x*y | x <- [1..4]] [10,20,30,40]
11:55:07 <lambdabot> [10,40,90,160]
11:55:23 <mjl69> [\x->x * x | x <- [1..4]]
11:55:39 <mjl69> > [\x->x * x | x <- [1..4]]
11:55:39 <lambdabot>  add an instance declaration for (Show (a -> a))
11:55:53 <mjl69> that's what I was wondering about, what that means...
11:55:57 <Cale> > zipWith ($) [\x->x * x | x <- [1..4]] [10,20,30,40]
11:55:58 <lambdabot> [100,400,900,1600]
11:56:10 <mjl69> oh
11:56:19 <Cale> it's the same as let square x = x * x in [square,square,square,square]
11:56:50 <Cale> the other x gets shadowed by the lambda binding
11:56:53 <jethr0> > zipWith id (repeat (\x -> x*x)) [1..10]
11:56:54 <lambdabot> [1,4,9,16,25,36,49,64,81,100]
11:57:24 <mjl69> oh, I think I get it.
11:57:46 <Cale> zipWith id (repeat f) = map f
11:57:49 <mjl69> not the zipWith, id, or ($) part yet, but the general concept.
11:57:53 <Cale> oh
11:57:57 <Cale> @type zipWith
11:57:58 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:57:58 <jethr0> yesyesyes
11:58:05 * mjl69 is just a white-belt in haskell
11:58:22 <Cale> can you imagine what a function with such a type would be doing?
11:59:29 <mjl69> takes a curried function as an argument that takes an a and a b type and evaluates to a c type and then..
12:00:22 <mjl69> overall it is a curried function that takes that function I mentioned first and two lists of types [a] and [b] and evaluates to a [c]
12:00:35 <mjl69> oh, boy.
12:00:39 <Cale> well, all functions are curried :)
12:00:53 <Cale> so might as well not even bother mentioning that :)
12:01:27 <SamB> @type uncurry
12:01:28 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
12:01:47 <mjl69> I am still thinking at the level that a function can only have one parameter so if there is more than one, it is a composite of multiple functions.
12:01:51 <Cale> (except those which only take tuples)
12:02:01 <mjl69> so I can just drop mentioning that all the time.
12:03:08 <mjl69> so a function that takes a function of type (a -> b -> c) and two lists of types [a] and [b] and evaluates to a list of type [c]
12:03:15 <Cale> yep
12:03:16 <SamB> jlouis has some fixing to do...
12:04:12 <Cale> note that, as you mentioned, this is the same as a function which takes a function of type (a -> b -> c) and produces a function which takes two lists of types [a] and [b] and returns a list of type [c]
12:05:02 <Cale> but it's often harder to think about it that way when trying to sort out what it's doing
12:05:15 <Cale> (sometimes not, but quite often)
12:05:43 <Cale> So what could it be doing with those lists and that function?
12:05:54 <mjl69> a function which takes a function of type (a -> b -> c) and produces a function which takes a list of type [a] and produces a function that takes a list of type [b] and returns a list of type [c].  Would that be the same too?
12:06:01 <Cale> yes
12:07:00 <mjl69> using the function to act on the members of the two lists.  by the name, I would imagine zipping them together like a zipper.  
12:07:08 <Cale> yep
12:07:25 <mjl69> cool
12:07:42 <Cale> zipWith (\x y -> (x,y)) [1,2,3,4,5] [6,7,8,9,10]
12:07:45 <Cale> > zipWith (\x y -> (x,y)) [1,2,3,4,5] [6,7,8,9,10]
12:07:47 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:07:52 <Cale> > zipWith (,) [1,2,3,4,5] [6,7,8,9,10]
12:07:53 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:07:57 <Cale> > zip [1,2,3,4,5] [6,7,8,9,10]
12:07:58 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:08:29 <Cale> when one of the lists is shorter, it just stops there
12:08:47 <Cale> (rather than doing something like looping around to the start again)
12:09:08 <Cale> now, ($)
12:09:12 <Cale> @type ($)
12:09:13 <lambdabot> forall b a. (a -> b) -> a -> b
12:09:17 <Cale> hehe
12:09:27 <mjl69> hmmm
12:09:48 <Cale> one way to read it is as (a -> b) -> (a -> b)
12:10:01 <mjl69> takes a function that takes an a and returns a b and works it on an a to return a b
12:10:10 <Cale> yep
12:10:29 <Cale> alternately, it takes a function from a to b, and returns a function from a to b
12:10:33 <SamB> @type ($!)
12:10:34 <lambdabot> forall b a. (a -> b) -> a -> b
12:10:38 <Cale> (that's the curried view)
12:10:43 <mjl69> that makes sense
12:10:56 <Cale> now, it couldn't be doing much
12:11:02 <Cale> and indeed,  ($) = id
12:11:12 <Cale> or
12:11:16 <Cale> f $ x = f x
12:11:22 <SamB> @pl ($)
12:11:22 <lambdabot> id
12:11:31 <Cale> but why do we define it then?
12:11:42 <Cale> It's got a really low operator precedence
12:11:52 <Cale> so you can use it to eliminate brackets
12:12:15 <Cale> > map (2*) $ zipWith (+) [1,2,3,4,5] [6,7,8,9,10]
12:12:16 <lambdabot> [14,18,22,26,30]
12:12:21 <Cale> instead of
12:12:24 <Cale> > map (2*) (zipWith (+) [1,2,3,4,5] [6,7,8,9,10])
12:12:25 <lambdabot> [14,18,22,26,30]
12:12:26 <Saulzar> Hmm, much strangeness - I have some code using stdGen which causes a segfault about 20 stack frames into gtk
12:12:34 <Cale> which helps when you have lots of parens
12:12:48 <SamB> Saulzar: you sure the stdgen has something to do with it?
12:13:03 <mjl69> oh, I gotta run, wife is looking for me.  Thanks Cale!
12:13:05 <Cale> It's also a really good way to emphasize that you're talking about function application
12:13:08 <Saulzar> Well, it's pure haskell code
12:13:08 <Cale> no problem :)
12:13:21 <mjl69> I love this stuff.  It is so cool
12:13:26 <mjl69> I'll be back later.
12:13:28 <Cale> :)
12:13:31 <SamB> Saulzar: lets see it
12:13:45 <Saulzar> I don't have a great testcase, I'll try a few things 
12:13:49 <SamB> maybe there is a null pointer or something
12:14:33 <Saulzar> If I shift the code using the stdgen further down (after all the gtk stuff is initialised) then nothing happens
12:14:47 <Saulzar> Also, compiling without -O2 nothing happens
12:15:38 <SamB> ah
12:15:45 <SamB> GHC bug then, presumably
12:16:15 <SamB> tried -fasm?
12:16:43 <SamB> its probably a bug in code generation...
12:17:20 <Saulzar> Yeah, I'm using -fasm
12:18:07 <SamB> alternatively, try -fvia-C
12:18:25 <SamB> if you have bad luck, there will be different bugs in each :-(
12:20:52 <sdjp> is 
12:21:04 <sdjp> in the wrong window, sorry.
12:22:02 <Saulzar> Heh, seems there's something funny with the build system using f-via-C: 
12:22:02 <Saulzar> /tmp/ghc3579.hc:9:23: gtk/gtkgl.h: No such file or directory
12:31:06 <musasabi> That just complains that it cannot find a C header file
12:33:49 <Saulzar> Yeah, but what includes it? I have not setup any paths and -fasm seems to "just work"
12:34:27 <roconnor> so suppose I make a patch in darcs that I decide later I don't like, what should I do?
12:40:26 <musasabi> roconnor: depends on whether you have distributed it to other people
12:41:08 <Saulzar> SamB, I guess it's probably not stdgen, doesn't seem to happen when isolated
12:41:20 <musasabi> roconnor: if you are the only one with the patch then unrecord or amend-record
12:41:34 <musasabi> roconnor: if other people have got it then rollback.
12:41:43 <roconnor> I don't want to completely destroy the patch.
12:41:52 <roconnor> because I want revision control.
12:41:54 <musasabi> roconnor: http://darcs.net/manual/node7.html#SECTION00780000000000000000 contains documentation of the relevant commands.
12:42:01 <roconnor> I may want to look at the patch again in the future.
12:42:05 <musasabi> ah.
12:42:11 <musasabi> then you want to do the following:
12:42:38 <musasabi> make a new repo just without that one patch
12:42:45 <musasabi> then you can later pull it if you want
12:42:53 <roconnor> that's sort of what I figured.
12:43:04 <roconnor> Um, is that a big waste of space?
12:43:08 <roconnor> maybe space is free.
12:43:27 <musasabi> roconnor: you can have the repositories share the same links.
12:43:40 <roconnor> oh yea
12:43:49 <Oejet> Lemmih: Thanks for your answer on the ml. :-)
12:43:49 <roconnor> I vaguely recall reading something about that.
12:43:55 <musasabi> roconnor: an another alternative is to 1) darcs send -o myfile.patch, 2) darcs unrecord, 3) apply it later if you want
12:44:03 <roconnor> heh
12:44:15 <roconnor> thanks for the tips
12:44:29 <roconnor> I'm looking forward to using darcs.
12:45:49 <CosmicRay> this is odd.
12:45:52 <CosmicRay> I'm using hunit and seeing:
12:45:57 <CosmicRay> runtests: <stderr>: hPutStr: illegal operation (handle is finalized)
12:45:57 <CosmicRay> \
12:46:01 <CosmicRay> anyone else eeen that?
12:47:04 <Saulzar> Would that happen if you close the handle then try to use it?
12:47:16 <roconnor> Hmm, how to I name the patch I want to rollback?
12:47:21 <roconnor> how do I ..
12:47:41 <CosmicRay> Saulzar: I believe so
12:54:56 <roconnor> So a public repository is only supposed to grow?
12:55:14 <roconnor> er supposed to only grow.
13:00:00 <frederik_> Prelude Fu.Prepose> reflectNum $(reifyIntegral 348 (\x -> [| x |]))
13:00:00 <frederik_> 348
13:00:00 <frederik_> Prelude Fu.Prepose> :t $(reifyIntegral 348 (\x -> [| x |]))
13:00:00 <frederik_> $(reifyIntegral 348 (\x -> [| x |])) :: Twice (Twice (Succ (Twice (Succ (Twice (Succ (Twice (Twice (Succ (Twice (Twice (Succ Zero))))))))))))
13:00:07 <frederik_> cool eh?
13:00:17 <xerox> wow
13:00:32 <xerox> What is it? :-)
13:00:43 <frederik_> implicit configurations, with template haskell
13:01:22 <frederik_> the problem is that they make existential types using (\forall a . a -> w) -> w
13:01:39 <frederik_> there isn't really any other way right?
13:02:06 * xerox @get-{ski,Cale,<insert-yourname-here>
13:02:21 <Cale> hello
13:02:28 <xerox> Hi :-)
13:02:39 <frederik_> so it's hard to play around with in ghci. but if i make the type-level numerals instances of TH's Lift then
13:02:45 <frederik_> i can instantiate them
13:03:05 <frederik_> by passing (\x -> [| x |]) to reifyIntegral
13:04:40 <frederik_> neat?
13:14:04 * CosmicRay cheers.  I have hdbc-sqlite3 working with some unit tests, woohoo ;-)
13:16:16 <PupenoL> Does anybody know of the top of his/her head how do Debian packages solve the problem that installing a Haskell package needs to modify an already installed file ?
13:16:49 <CosmicRay> PupenoL: ghc-pkg is run in postinst
13:17:03 <PupenoL> CosmicRay: thanks.
13:17:05 <CosmicRay> there is no copy of the package list itself included in the haskell library packages.
13:18:35 <PupenoL> CosmicRay: so, even if make install does the ghc-pkg, as it happens in the rootjail, it modifies another file (not the installed one), and that other file is not included in the .deb, right ?
13:18:47 <CosmicRay> we have standardized on cabal
13:18:54 <CosmicRay> so we do, iirc, ./setup copy
13:18:57 <CosmicRay> instead of ./setup install
13:19:06 <CosmicRay> so that there is no attempt to run ghc-pkg at build time
13:19:11 <goron> Did anyone profile the difference between native code generation and C-generated code for GHC?
13:20:36 <PupenoL> CosmicRay: I see.
13:21:54 <PupenoL> CosmicRay: do you run setup from debian/rules or make with a Makefile that runs setup ? the second option is being used by WASH.
13:22:30 <CosmicRay> we normally run setup from debian/rules
13:22:38 <CosmicRay> if there is an existing Makefile that runs setp, that could be used too.
13:22:45 <CosmicRay> there's no point to creating a new file if it doesn't exist though
13:23:32 <PupenoL> CosmicRay: WASH has a patch for the makefile to run setup instead of the old way, but maybe WASH is the exception.
13:24:10 <SamB> goron: profile?
13:24:26 <goron> SamB: Well, or test. 
13:24:27 <SamB> but they would both have the same allocation patterns!
13:24:45 <goron> SamB: Doesn't profiling also include performance?
13:24:49 <SamB> oh, that.
13:25:01 <SamB> well, thats harder to understand :-(
13:25:51 <noj> hey guys, anything like this for haskell? http://wiki.alu.org:80/2004_Lisp_Timeline
13:26:18 <CosmicRay> Pupeno: if you're looking at my wash packages, don't.  it's that way because wash wasn't cabalized to begin with, and also didn't have its source tree in a cabal-friendly layout.
13:26:26 <CosmicRay> try magic-haskell instead ;-)
13:28:05 <PupenoL> CosmicRay: current WASH is in a Cabal-friendly structure and I have Cabalized it (I am not sure if it really works yet) and I have also made some .debs out of it (nothing stable/reliable yet).
13:29:25 <CosmicRay> PupenoL: are you the ubunto packager that has been emailing me about it?
13:29:29 <CosmicRay> err ubuntu
13:29:47 <CosmicRay> PupenoL: in any case, I'd appreciate having your finished source package for uploading to sid
13:30:41 <PupenoL> CosmicRay: yes, I am (I am not really a ubuntu packages, just a user). You'll have it when its done (although my original quest is more related to my SCons module for Haskell).
13:30:56 <CosmicRay> great, thanks
13:31:54 <PupenoL> you are welcome, thank you too!
13:41:33 <Freejack> Hello. Anyone here use GHCi much?
13:41:48 <basti_> for testing, certainly
13:42:02 <SyntaxNinja> y0
13:42:18 * PupenoL goes back to "All about monads".
13:42:26 <Freejack> basti: I'm working through a Haskell tutorial. GHCi seems to be getting in the way. Heh.
13:42:36 <SyntaxNinja> ghci is great
13:42:42 <PupenoL> Freejack: how ?
13:42:43 <SyntaxNinja> but sometimes might not do what you expect
13:42:43 <Freejack> You know. Typing in the examples.
13:42:48 <SyntaxNinja> one problem is that you can't define stuff on the top level
13:42:49 <basti_> what are you trying to do?
13:42:55 <SyntaxNinja> that's probably what you're running into.  it should be a FAQ
13:42:57 <basti_> some features don't work in interaction
13:42:57 <basti_> like "data"
13:43:03 <SyntaxNinja> (well, actually, you can, but perhaps not the way you expect)
13:43:06 <PupenoL> Freejack: type them in a text file and load it from ghci, it is what I do.
13:43:07 <Freejack> SyntaxNinja: I was guessing that was the case.
13:43:10 <SyntaxNinja> so type stuff into a file and use :load or :reload
13:43:19 <basti_> and toplevel assignments yes.
13:44:05 <Freejack> I'm just not versed well enough in Haskell or GHCi to figure out how to set up a good environment for walking through a tutorial.
13:44:39 <basti_> Freejack: what exactly is failing?
13:44:43 <PupenoL> writing programs to a file and loading it to a REPL to test it is awesome, it is among the top 5 things I dislike about C (yes, I know there are REPLs for C, I tried them and I made them fail).
13:45:07 <PupenoL> Freejack: what OS are you using ?
13:45:11 <Speck> does GHCi have an external editor command?
13:45:28 <basti_> Speck: what good would that be?
13:45:30 <Freejack> basti_: Well...doing simple things like  "data Bool = True | False"
13:45:45 <Speck> basti_: for writing a block of haskell to test, load it into GHCi, and play with it?
13:45:50 <basti_> Freejack: "data" doesn't work in interaction.
13:45:53 <Freejack> I know theres an Emacs mode for Haskell. I might try that.
13:46:21 <basti_> Speck: why dont you start an editor from outside of ghci6 and do exactly that?
13:46:26 <PupenoL> Freejack: I was very disappointed by it, it keep indenting things wrongly (and by wrongly I mean it won't compile).
13:46:43 <Freejack> PupenoL: I see.
13:47:13 <basti_> indentation conveys meaning for haskell
13:47:20 <basti_> you have to do some of the stuff by hand
13:47:27 <basti_> that is, pick the right level of indentation
13:47:30 <Freejack> basti_: Sort of like Python?
13:47:39 <basti_> (but yes, indentation in emacs-mode sucks a lot)
13:47:47 <basti_> yes, similar to python
13:47:48 <SyntaxNinja> Freejack: I used the emacs mode when I was learning.  I like it, though it's not as nice as modes for many other languages.
13:47:49 <Speck> basti_: just convenience
13:48:29 <PupenoL> Freejack: if you are used to Emacs, then it is as good as any other editor with syntax highlighting (on Haskell; I use Kate).
13:48:42 <basti_> Speck: that certainly wouldn't justify introducing at least one new configuration parameter and interaction command would it?
13:48:43 <Freejack> I'm primarily an Ada programmer, so I can't say I've had to deal with Indentation issues much. Heh.
13:48:50 <PupenoL> basti_: I agree, but then pressing tab various times should give me all the indentation that make some sense, like it does in Python.
13:48:50 <SyntaxNinja> Ada?!
13:48:56 <SyntaxNinja> that's my favorite programming language... name.
13:49:05 <basti_> PupenoL: yes, it's broken.
13:49:26 <basti_> PupenoL: It pisses me off, too. Are you going to fix it?
13:49:44 <Speck> basti_: I think it's worth it, but we might have to agree to disagree
13:49:46 <PupenoL> I don't know if anybody else got this, but inside a do, the then and else of an if end up at the same level of the if.
13:49:46 <Freejack> I was going to learn Curry, but found it to be a bit inflexible.
13:50:05 <basti_> Speck: .)
13:50:13 <SyntaxNinja> Freejack: haskell rules :)
13:50:15 <basti_> PupenoL: i think they may
13:50:21 <PupenoL> basti_: no, I don't know how to code that (elisp/emacs extensions) and I have enought learning Haskell at this time.
13:50:30 <SyntaxNinja> PupenoL: if you look hard, the indentation hardly works at all
13:50:32 <basti_> that is, outside a do...
13:51:16 <Freejack> SyntaxNinja: I don't doubt it. Thinking I might use it to build a front end to my packet compiler.
13:52:05 <basti_> i catch myself indenting by hand too.. but what to do? dig through emacs' entrails?
13:52:32 <Freejack> Has anyone written a Haskell IDE?
13:52:40 <PupenoL> Freejack: topic.
13:53:07 <SamB> it doesn't quite work yet, afiak
13:53:12 <Freejack> Woops.  Sorry.
13:53:40 <SamB> Freejack: no need to apologize, that topic is a monster
13:54:06 <basti_> does it do indentation already?
13:55:01 <SamB> shapr: did you get that repo started yet?
13:55:46 * Freejack is looking over that IDE page.
13:57:38 <Freejack> Theres a bunch of 'em.
13:58:53 <Freejack> I'm thinking Haskell would be perfect for writing code analysis tools and parsing -> tokenizing tools.
13:59:14 <SamB> Yes!
13:59:50 <astrolabe> Freejack: check out parsec
13:59:55 <astrolabe> @where parsec
13:59:55 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
14:02:21 <Freejack> I'm building a packet compiler + server that serves data out a raw network interface. I have all the low level stuff coded up and (more or less) working. I figured Haskell(and maybe parsec) could be used to translate and feed data to the compiler.
14:02:50 <Heffalump> that sounds quite a cool idea
14:03:58 <Freejack> Heffalump: I'm doing a double take. I think I've found Ada's functional cousin.
14:04:11 <astrolabe> Ha
14:04:27 <astrolabe> I thought Ada code was long-winded.
14:05:24 <Freejack> astrolabe: It really can be. But it also keeps me from going cross-eyed when refactoring or extending the code.
14:05:57 <Freejack> A Haskell based parsing and analysis system would boost my productivity a lot.
14:06:49 <astrolabe> I really love the strong flexible typing in haskell.  As someone (dons?) says, you can just chuck code together and use the compiler to sort it all out.
14:07:49 <Freejack> As far as the type system goes...If I understand it correctly...the types arent actually "frozen" until after it leaves the computation. Yes?
14:08:30 <astrolabe> Just the opposite I think.  Types are strong: fixed at compile time.
14:09:58 <astrolabe> But the type system is so flexible that strong types don't cause a headache.  You can define functions that work on lists of 'things' for example.
14:10:00 <Freejack> Okay..so the type is frozen prior to entering the computation, and creation of a new "variable" within a computation actually creates a new type?
14:10:40 <astrolabe> I wish someone that new more than me would join in this discussion :)
14:11:14 <Freejack> Well...I do have some experience with J and K, so this stuff isn't entirely new to me.
14:11:59 <astrolabe> During compilation, the types of all the variables are worked out.  A new variable may have a type that hasn't been used before, or not.
14:12:10 <Freejack> Gotcha.
14:12:28 <Lor> You don't create variables within a computation.
14:12:45 <Lor> Variables are syntactic, static objects. They all pre-exist before anything is run.
14:13:10 <Freejack> Lor: Variables all exist prior to the computation. Gotcha.
14:15:33 <Freejack> That keeps things simple.
14:15:33 <Freejack> Gah. Cable Modem is going out. I'll be back.
14:33:22 <SyntaxNinja> poor freejack
15:02:28 <CosmicRay> SyntaxNinja: silly him for using a cable modem ;-)
15:02:50 <Speck> >.<
15:03:57 <astrolabe> In parsec, what is a good way to skip up to (but not including) the next '\n'?
15:09:43 <astrolabe> ok, skipMany(noneOf ['\n']) should do it.
15:24:17 <jimapple> @seen lennart
15:24:17 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
15:25:38 <cinema>  /msg NickServ IDENTIFY
15:45:41 <jethr0> @seen shapr
15:45:41 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 7 hours, 49 minutes
15:45:41 <lambdabot> and 33 seconds ago.
15:53:50 <int-e> @type (1e6, 10^6)
15:53:51 <lambdabot> forall a a1. (Fractional a, Num a1) => (a, a1)
15:59:58 <jimapple> @listcommands djinn
15:59:58 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
15:59:58 <lambdabot> ver
16:00:04 <jimapple> @djinn-env
16:00:05 <lambdabot> data () = ()
16:00:05 <lambdabot> data Either a b = Left a | Right b
16:00:05 <lambdabot> data Maybe a = Nothing | Just a
16:00:05 <lambdabot> data Bool = False | True
16:00:05 <lambdabot> data Void
16:00:07 <lambdabot> type Not x = x -> Void
16:00:28 <jimapple> @djinn Not a -> Not b -> (Not a -> Not b)
16:00:28 <lambdabot> f _ x2 _ x4 = x2 x4
16:01:50 <jimapple> @more
16:02:15 <jimapple> @djinn-ve
16:02:16 <lambdabot> Djinn version 2005-12-15.
16:10:46 <soysauce> @djinn a -> Maybe a
16:10:47 <lambdabot> f = Just
16:10:51 <soysauce> hah
16:10:58 <soysauce> @djinn a -> b -> Maybe (a, b)
16:10:58 <lambdabot> f x1 x2 = Just (x1, x2)
16:11:40 <Cale> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
16:11:41 <lambdabot> f x1 x4 =
16:11:41 <lambdabot>   case x1 of
16:11:41 <lambdabot>   Nothing -> Nothing
16:11:41 <lambdabot>   Just v7 -> x4 v7
16:12:09 <Cale> @djinn Maybe (Maybe a) -> Maybe a
16:12:09 <lambdabot> f x1 =
16:12:09 <lambdabot>   case x1 of
16:12:09 <lambdabot>   Nothing -> Nothing
16:12:09 <lambdabot>   Just v6 -> v6
16:12:11 <soysauce> heh, neat
16:12:31 <soysauce> @djinn [Maybe a] -> [a]
16:12:31 <lambdabot> -- f cannot be realized.
16:12:35 <soysauce> ah, no lists
16:12:38 <Cale> @djinn (a -> b) -> (Maybe a -> Maybe b)
16:12:38 <lambdabot> f x1 x2 =
16:12:38 <lambdabot>   case x2 of
16:12:38 <lambdabot>   Nothing -> Nothing
16:12:38 <lambdabot>   Just v7 -> Just (x1 v7)
16:12:44 <jethr0> hey cale, i was starting to wonder where everyone was :)
16:12:49 <Cale> :)
16:13:01 <Cale> I've been here, just quiet
16:13:04 <musasabi> soysauce: recursive datatypes are hard.
16:13:13 <soysauce> I'm sure
16:13:40 * soysauce wonders what the cases are
16:13:52 <Cale> @djinn (a -> b -> c) -> (a,b) -> c
16:13:52 <lambdabot> f x1 (v3, v4) = x1 v3 v4
16:13:58 <musasabi> and of course with lists there is the additional fun, of proving: "[Maybe a] -> [a]" as "fun _ = []" ;)
16:14:22 <Cale> well, there are lots of trivial proofs that it's currently avoiding
16:14:29 <musasabi> point
16:14:43 <soysauce> well, obviously it should try to consume all inputs
16:14:48 <musasabi> but it is terminating at the moment
16:14:52 <Cale> :)
16:14:55 <soysauce> @djinn a -> a -> a
16:14:55 <lambdabot> f _ x2 = x2
16:15:08 <Cale> I wonder how far it could get with 3 seconds :)
16:15:10 <soysauce> I suppose there is no good answer for that one, although it is the type of (+)
16:15:20 <Cale> It's not the type of (+)
16:15:29 <Cale> @type (+)
16:15:30 <lambdabot> forall a. (Num a) => a -> a -> a
16:15:42 <soysauce> minus the class
16:15:46 <soysauce> otherwise it's the same
16:15:52 <Cale> yeah
16:16:00 <Cale> the class is a pretty important component there :)
16:16:28 <soysauce> hm, I suppose
16:16:38 <musasabi> hmm, I think adding class support could work.
16:17:01 <musasabi> is it is really about "if it is in the rules add these new rules for that type"
16:17:04 <soysauce> @djinn (a -> a -> a) -> a -> a -> a
16:17:05 <lambdabot> f x1 = x1
16:17:41 <jethr0> we should really feed its output to @pl...
16:17:45 <musasabi> @djinn (a -> b -> a) -> b -> a -> a
16:17:45 <lambdabot> f x1 x2 x3 = x1 x3 x2
16:18:12 <jethr0> @pl  f x1 x2 x3 = x1 x3 x2
16:18:12 <lambdabot> f = flip
16:18:13 <soysauce> @pl \x1 x2 x3 -> x1 x3 x2
16:18:13 <lambdabot> flip
16:18:19 <soysauce> heh!
16:18:33 <soysauce> it doesn't always give what you want, though
16:18:41 <soysauce> @djinn (a, b) -> (b, a)
16:18:41 <lambdabot> f (v2, v3) = (v3, v2)
16:18:45 <soysauce> @pl f (v2, v3) = (v3, v2)
16:18:46 <lambdabot> f = uncurry (flip (,))
16:18:55 <jethr0> hmm, so you filter for less than 3 dots and 4 pairs of parens, or sth
16:18:58 <Cale> @djinn (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k) -> j -> f -> i -> h -> d -> a -> b -> g -> c -> e -> k
16:18:58 <lambdabot> f x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x12 =
16:18:58 <lambdabot>   x1 x7 x8 x10 x6 x12 x3 x9 x5 x4 x2
16:18:59 <soysauce> the first is probably significantly more readable than the second
16:19:14 <jethr0> and i meant piping yourself like @djinn ... >>= @pl
16:19:38 <musasabi> @pl f x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x12 =  x1 x7 x8 x10 x6 x12 x3 x9 x5 x4 x2
16:19:53 <lambdabot> f = flip . ((flip . ((flip . ((flip . (flip .)) .) . (((flip .) .) .)) .))
16:19:53 <lambdabot> .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . (((
16:19:53 <lambdabot> (((((flip .) .) .) .) .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .
16:19:53 <lambdabot> ) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .)
16:19:53 <lambdabot> .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . (flip .) . ((flip .) .) .
16:19:55 <lambdabot> [4 @more lines]
16:19:57 <soysauce> haha, wow
16:19:57 <lambdabot> optimization suspended, use @pl-resume to continue.
16:20:02 <jethr0> nice
16:20:16 <musasabi> pretty points ^_^
16:24:54 <jethr0> emacs is better than vi :)
16:25:55 <Philippa_> performing genito-urinal surgery on yourself with a rusty fork is better than vi
16:26:32 <jethr0> just trying to get some conversation started *g*
16:26:55 <jethr0> but maybe i'd have switched them in here to get a more flamewar-like reaction...
16:26:58 <Philippa_> and I was just trying to shift it into #haskell-blah ;-)
16:27:23 <Philippa_> you'll note I didn't provide an ordering on the surgery and emacs, btw :-)
16:27:32 <jethr0> yes, actually i did
16:27:41 <musasabi> vim however feels like a little bit of self-whipping and can be quite fun.
16:27:55 <jethr0> i'm trying to compile yi right now, but somehow the build script seems broken
16:28:12 <musasabi> the emacs vi-emulation mode is reserved for the really perverse days
16:28:23 * jethr0 uses vi _and_ emacs, meaning he likes aspects of both of them
16:29:45 <jethr0> is there a darcs'able version of greencard outside of fptools
16:30:02 <musasabi> jethr0: have you tried to vi-emulation in emacs, I found it the nicest solution a few times. (then again it does not support the fancy vim commands)
16:30:30 <jethr0> musasabi: nah, that's to obscene even for me. in some parts of the world/net you could get stoned to death for that!
16:31:29 <jethr0> hey lisppaste2 :)
16:35:14 <jethr0> i thougth that stood for "NT girl"
16:40:08 <Philippa_> that's usually grrl
16:42:43 <jethr0> seriously, what's happening today. is it the superbowl or did the new harry potter come out?
16:43:50 <Philippa_> last friday that isn't very clearly part of 'christmas' (next friday being the 23rd)
16:43:59 <Philippa_> so a lot of people finished work or uni today for the holidays
16:44:50 <jethr0> ah, true, didn't think of all the people "chatting" on their work time :)
16:45:59 <jethr0> Philippa_: have you compiled yi before?
16:47:55 <cpatrick> musasabi: the bits of vi that I like are generally vim-isms, so emacs's vi emulation doesn't really do much for me :S
16:48:15 <cpatrick> but vim is a pain with multiple windows and doesn't have emacs's groovy auto-indent stuff
16:48:20 <jethr0> old-style VI is simply evil
16:48:50 <jethr0> cpatrick, if i only knew how to handle multiple open buffers and switching between them in VI :(
16:49:23 <musasabi> cpatrick: vim can be made nicer.
16:50:16 <cpatrick> jethr0: well there's :vsplit, :hide, :unhide - but it's all very cumbersome
16:50:27 <jethr0> but i don't _want_ splitting :)
16:51:02 <jethr0> buffer handling is handled quite nicely in emacs!
16:51:12 <musasabi> e.g. "map <M-Down> <Down>_" and the same for Up.
16:51:44 <cpatrick> jethr0: I agree. though normally I use multiple windows and splitting a lot in emacs
16:52:01 <cpatrick> musasabi: what does that do?
16:52:01 <musasabi> agh "map <M-Down> ^W<Down>^W_" that is
16:52:04 <jethr0> i'm not 1337 enough for extreme splitting *g*
16:52:24 <musasabi> cpatrick: makes alt-down go to the "next" window down and maximize that.
16:53:14 <jethr0> musasabi: how do you open such a window?
16:53:19 <musasabi> :n ?
16:53:21 <cpatrick> ah. I have no problem with the ^W commands, I'd just prefer to have something like C-x b also
16:53:48 <musasabi> well they take only one line of screen space (one can configure that), so it is not really a problem
16:53:55 <musasabi> with emacs I get lost with all my buffers.
16:55:09 <cpatrick> musasabi: generally I have most of the source files for the project I'm working on open as a buffer and flick between them regularly
16:55:19 <cpatrick> this gets ugly fsat in vim
16:55:28 <jethr0> sure, but things like "tags" make keeping dozens of files open unnecessary, often.
16:56:43 <jethr0> just found: "bufmap.vim - automatically maps buffers to function keys" :)
16:56:52 <cpatrick> true. I admit I'm not leet enough to figure out how to use tags :)
16:57:24 <jethr0> neither am i
16:57:55 <musasabi> cpatrick: basically hit ^] and get to the definition of what you wanted.
16:58:08 <musasabi> (that is the one under the cursor is used)
16:59:29 <jethr0> musasabi: that part is easy. getting my lazy self to mend my ways is the hard part!
16:59:46 <jethr0> s/lazy/stupid/
16:59:59 <fnord123> is stupid a type of evaluation?
17:00:38 <musasabi> my current problem is that I branch repos (with darcs) to too many directions and cannot merge them back together without much pain
17:00:41 <jethr0> yes, it does has type "stupid :: information -> garbage"
17:01:35 <fnord123> stupid :: information -> ridiculousInterpretations
17:02:11 <jethr0> yes, that's a longer type synonym for "garbage"
17:03:11 <cpatrick> musasabi: what do you use to generate the tags file for haskell? vim complains about hasktags's output
17:04:36 <musasabi> cpatrick: doesn't hasktags generate both tags and TAGS ?
17:05:42 <cpatrick> apparently it has -c for (presumably vi-style) ctags and -e for (emacs) etags output
17:05:48 <cpatrick> neither work in my vim
17:05:59 <cpatrick> it says "tags file not sorted"
17:07:55 <musasabi> cpatrick: googling with that error has some answers
17:08:41 <jethr0> as always :)
17:18:01 <ihope> What's wrong with this line:
17:18:03 <ihope> smurfGrab '"':xs = ("",smurfParse xs)
17:18:44 <Lemmih> smurfGrab ('"':xs) = ...
17:18:57 <ihope> :-)
17:18:58 <ihope> Thanks
17:19:23 <dons> Moin
17:20:24 <musasabi> morning dons 
17:21:11 <dons> hmm, maybe I should switch lambdabot over to network-alt
17:21:28 <dons> then all these packed string state plugins could use unboxed ircPrivMsgs..
17:22:18 <ihope> Whoa, what was I THINKING?
17:22:39 <ihope> Ah. I see.
17:24:36 <jethr0> dons, ion was a full success!
17:24:47 <ihope> No, I don
17:24:49 <ihope> 't.
17:25:04 <musasabi> mmh, might be fun
17:25:06 <jethr0> the only thing i don't know yet is how to copy sth in irssi and paste it in vim without a mouse
17:25:58 <dons> jethr0, cool.
17:26:01 <musasabi> I have been thinking whether I should take the bullet and start work on implementing things inside ghc rts to get the support there. But there are many things I dislike about Handles...
17:26:41 <dons> ah, copy and paste. hmm. I use the accupoint thingy, but maybe there is a secret way, not sure.
17:26:56 <jethr0> hmm
17:28:33 <cpatrick> jethr0: do you use screen? that has its own copy/paste buffer
17:28:56 <jethr0> not yet, but switching to mainly keyboard only maybe i should, thx
17:48:45 <dons> @pl \(p,_) -> (p,[])
17:48:45 <lambdabot> flip (,) [] . fst
17:49:20 <dons> that's a nice one.
17:50:37 <musasabi> rather a mapFst / mapSnd would be nice.
17:51:03 <musasabi> thus  \(p,_) -> (p,[]) => mapSnd $ const []
17:51:38 <ihope> Woot, the parser's down.
17:56:24 <ihope> Now I need to unbug it.
17:58:51 <CosmicRay> SyntaxNinja: ping
18:00:48 <CosmicRay> I've got an incredibly weird cabal problem.
18:00:52 <CosmicRay> two machines are running ghc 6.4.1
18:00:57 <CosmicRay> both debian sid, both i386.
18:01:06 <CosmicRay> I have installed a package in the user are on both.
18:01:23 <CosmicRay> on one, building a second package that depends on this one works fine (setup configure --user, then setup build)
18:01:26 <CosmicRay> on the other, it doesn't.
18:01:40 <jimapple> cosmic rays
18:01:48 <CosmicRay> And -- it's passing different args to ghc for ./setup build
18:01:54 <CosmicRay> despite having configured things identically
18:02:04 <CosmicRay> on the second, it is hardcoding an incorrect path to a user config file
18:27:04 <Igloo> CosmicRay: Both have the same cabal?
18:33:38 <SyntaxNinja> hi CosmicRay...
18:35:44 <SyntaxNinja> i'll reply to your email
18:38:11 <CosmicRay> SyntaxNinja: I discovered an additional tidbit
18:38:20 <CosmicRay> on one machine, I had run ./setup configure --prefix=~/lib
18:38:22 <SyntaxNinja> CosmicRay: the -package lines differ. are you sure they are the same .cabal file?
18:38:27 <CosmicRay> and on the other, --prefix=$HOME/lib
18:38:32 <SyntaxNinja> and cabal version?
18:38:34 <CosmicRay> on the first package (the one that installed OK)
18:38:36 <SyntaxNinja> I have to run, I think.
18:39:43 <CosmicRay> when I run $HOME/lib on both, it works
18:41:26 <SyntaxNinja> strange.
18:41:30 <SyntaxNinja> I gotta run. sorry. pax
19:17:48 <jethr0> > fix (1:)
19:17:50 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
19:17:50 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
19:17:50 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
19:17:50 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
19:17:50 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
19:17:51 <lambdabot> [23 @more lines]
19:18:37 <jethr0> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
19:18:39 <lambdabot> 120
19:18:56 <dons> @pl \fac n -> if n == 0 then 1 else n * fac (n-1)
19:18:57 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
19:19:02 <dons> oh, it'll be an if'
19:19:02 <jethr0> hehe
19:19:20 <jethr0> dons, is if' anywhere in haskell? can i use it?
19:19:28 <dons> nope
19:19:38 <jethr0> great! why does lambdabot return it then?
19:20:01 <Cale> for fun :)
19:20:03 <Cale> hehe
19:20:06 <jethr0> :)
19:20:18 <Cale> @pl \i t e -> if i then t else e
19:20:19 <lambdabot> if'
19:20:24 <dons> I also note fllip', id' and more in the lambdabot src.
19:20:39 <Cale> id'?
19:20:47 <dons> not sure about that one..
19:20:49 <jethr0> let if' i t e = if i then t else e in if' True "true" "false"
19:20:53 <jethr0> > let if' i t e = if i then t else e in if' True "true" "false"
19:20:54 <lambdabot> "true"
19:20:57 <dons> oh, id' == id
19:21:00 <Cale> hehe
19:21:02 <dons> id'    = Var Pref "id"
19:21:07 <Cale> ah
19:21:11 <dons> to avoid name clashes
19:22:09 <dons> hmm, it's interesting about  the use of _ versus ' in identifier names
19:22:28 <dons> we have foldl' (== strict) versus mapM_ (== returns ())
19:22:51 <dons> I usse ' for internal names, and _ for external names.
19:22:58 <dons> externally visible names
19:23:16 <jethr0> hmm
19:23:19 <dons> so I think I would have chosen if_-
19:23:20 <Cale> hmm
19:24:02 <Cale> trailing underscores look kind of bad
19:24:26 <jethr0> trailing _anything_ tends to look messy
19:24:35 <Cale> x' is fine
19:24:41 <jethr0> true
19:24:52 <Cale> but that's because it's not really a quotation mark :)
19:25:11 <jethr0> it's because we're so used to it from math notation!
19:25:15 <Cale> yeah
19:25:19 <Cale> It's a prime
19:25:29 <Cale> I think a trailing * wouldn't be too bad
19:25:37 <Cale> but it doesn't fit with the syntax
19:25:59 <dons> trailing ' aren't used in many library functions (only for local vars)
19:26:04 <Cale> I kind of think it might be worth it to require spaces around infix operators.
19:26:28 <Cale> that would allow the use of hyphens in names
19:26:31 <jethr0> this would also solve the unary minus problem
19:26:35 <Cale> yes
19:27:02 <dons> hmm, how smart is hoogle:
19:27:03 <Cale> It solves a lot of small uglinesses, at the risk of breaking code everywhere :)
19:27:39 <dons> @hoogle '
19:27:40 <lambdabot> No matches found
19:27:47 <jethr0> yes, but you could do it gradually... and it would generally enhance readability
19:28:03 <jethr0> and it's easy to convey
19:28:07 <Cale> spaces around operators generally look good anyway
19:28:37 <jethr0> although it might annoy some people in arithm. expressions
19:29:36 <Cale> yeah -- it would be pretty annoying if you didn't know about it
19:30:15 <jethr0> 4+5  -  error at 1:1
19:31:04 <Cale> no
19:31:15 <jethr0> no?
19:31:18 <Cale> hehe, undefined symbol :)
19:31:25 <jethr0> even better
19:31:39 <jethr0> but it wouldn't be allowed as symbol
19:32:07 <Cale> I suppose you can disallow symbols starting with digits
19:32:34 <jethr0> surely, and starting with hyphens isn't so great either
19:32:53 <jethr0> otherwise "-2" would be a symbol again
19:33:27 <Cale> well, we could have that be -2, but -2x be an allowable symbol :)
19:33:42 <Cale> not sure if that's completely desirable :)
19:34:03 <jethr0> that would be great stuff
19:34:16 <jethr0> there's nothing quite like intransparent exceptions
19:34:33 <Cale> the IOHCC would be quite fun
19:34:40 <jethr0> how about -2' or -2-
19:34:54 <jethr0> even better -2e10
19:35:11 <Cale> -2-5 = -8
19:35:47 <jethr0> -2e4 + 1 == 2
19:36:10 <Cale> > -2e4
19:36:11 <lambdabot> -20000.0
19:36:38 <jethr0> i didn't even know that worked in haskell :)
19:37:31 <Cale> however, you could have -2el0 = -2e9
19:38:09 <Cale> The goal being to make it as difficult as possible for maintenance programmers :)
19:38:39 <jethr0> you mean -2elO
19:38:52 <Cale> either way
19:39:00 <Cale> -2e1O is nice
19:39:09 <jethr0> it would be madness
19:39:37 <Cale> right, so probably don't want symbols starting with - or digits :)
19:39:43 <Cale> anyway, unary -
19:39:44 <jethr0> having them all being nearly the same might be a nice touch. have it look like a rounding problem
19:39:54 <Cale> hehe, yeah
19:40:08 * dons notes this in lambdabot:
19:40:20 <dons> choice :: (r -> Bool) -> (r -> a) -> (r -> a) -> (r -> a)
19:40:20 <dons> choice p f g x = if p x then f x else g x
19:40:29 <jethr0> in vim typing "20rt" will replace the next 20 chars with "t". that might come in handy some time...
19:41:03 <Cale> hm?
19:41:03 <dons> @djinn (r -> Bool) -> (r -> a) -> (r -> a) -> (r -> a)
19:41:04 <lambdabot> f x1 x2 x3 x4 =
19:41:04 <lambdabot>   case x1 x4 of
19:41:04 <lambdabot>   False -> x2 x4
19:41:04 <lambdabot>   True -> x3 x4
19:41:06 <jethr0> dons, having them all apply on x kinda restricts its usefullness, no?
19:41:14 <dons> seems weird
19:41:23 <Cale> it's not weird
19:41:40 <Cale> well, it's like a guard
19:41:42 <dons> oh, we have an alterniave:
19:41:43 <dons> -- choice :: ArrowChoice (~>) => r ~> Bool -> r ~> a -> r ~> a -> r ~> a
19:41:44 <dons> -- choice :: Monad m => m Bool -> m a -> m a -> m a
19:41:53 <dons> :)
19:41:57 <jethr0> "~>" *yuch*
19:42:08 <Cale> what's wrong with ~> ?
19:42:18 <dons> ah, it's rather elegant: map (choice (=='.') (const '/') id) x <.> "hs"
19:42:19 <jethr0> needs some getting used to, at least
19:42:34 <Cale> I'd at least use some more parens :)
19:42:35 <jethr0> that's mainly undecipherable
19:43:00 <Cale> -- choice :: ArrowChoice (~>) => (r ~> Bool) -> (r ~> a) -> (r ~> a) -> (r ~> a)
19:43:19 <dons> djinn needs some knowledge that order of args usually carries some meanning
19:43:55 <jethr0> is that expressible in types?
19:47:28 <jethr0> > 2e0
19:47:30 <lambdabot> 2.0
19:48:54 <jethr0> dons, i'm trying to compile yi, but having trouble... does it need greencard mandatorily?
19:50:00 <Cale> oh, right
19:50:25 <Cale> I had a problem with running curses yi the other day
19:51:16 <dons> jethr0, no.
19:51:18 <dons> Cale?
19:51:21 <jethr0> if yi doesn't necessarily need greencard, the build script is broken. and otherwise i've got a problem because my fptools/greencard won't compile *arg*
19:51:31 <dons> maybe it needs a newerr Cabal than you have...
19:51:40 <dons> it doesn't need greencard.
19:51:47 <dons> Cabal always looks for it anyyway.
19:52:09 <jethr0> cabal-1.1.4
19:52:21 <dons> how does it fail?
19:52:38 <Cale> A (seeming) freeze. Steps to reproduce: 1) Run yi. 2) Tap 'i' once or twice. The cursor disappears and nothing I type seems to affect anything.
19:52:47 <jethr0> sth like couldn't locate module "Yi"... rebuilding right now
19:53:21 <jethr0> linking...; could not find module 'Yi'
19:53:33 <jethr0> imported from boot/Static.hs
19:53:58 <jethr0> hopefully it's not again my stupidity taking its toll ;)
19:54:10 <dons> note that 1.1.4 encompasses a wide range of patches...
19:54:25 <jethr0> ya?
19:54:31 <Cale> (this is the darcs version)
19:54:41 <jethr0> should i use sth more stable then?
19:54:59 <dons> oh, you're using gtk yi?
19:55:17 <jethr0> hmm, seems so although nobody asked :)
19:56:17 <jethr0> pulled from "http://scannedinavian.com/repos/yi" and trying to build
19:56:23 <Cale> whoa, using 'a' to start my buffer doesn't freeze
19:56:59 <Cale> oh, hrm
19:57:03 <dons> hmm.  i've rewrote the entire gui last week, so there may be bugs..
19:57:09 <Cale> no, it's gone altogether now, after cleaning and rebuilding
19:57:12 <dons> in the curses yi.
19:57:14 <dons> ah, good..
19:57:15 <Cale> hmm
19:57:24 <pengo> is there a proper tutorial for haskell? one that doesn't just reword the language spec, but actually gives you complete 
19:57:27 <pengo> short programs
19:57:37 <dons> @learn
19:57:38 <lambdabot> http://www.haskell.org/learning.html
19:57:42 <Cale> pengo: what have you tried?
19:57:42 <jethr0> how/where do i get/compile the curses version?
19:57:51 <pengo> Cale, the ones listed above
19:57:51 <dons> @where yi
19:57:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
19:57:52 <Cale> I rather like "Yet Another Haskell Tutorial"
19:57:59 <Cale> did you try it?
19:58:29 <pengo> i believe so
19:58:32 <jethr0> weird, i wonder where i came up with the other repo :). maybe on the hIDE site
19:58:36 <pengo> it was the best guide to the spec, but it wasn't a tutorial
19:59:04 <Cale> that's not a tutorial?
19:59:11 <Cale> It sure claims to be :)
19:59:32 <Cale> How is it not a tutorial?
20:00:46 <pengo> Cale, well my defnition of a tutorial differs. rather than go through the features of the language, a tutorial should be practically based
20:01:30 <pengo> e.g. have small, complete programs
20:01:33 <Cale> hehe, I think you should find a different word, but hmm -- practical examples, there ought to be lots of those around
20:01:43 <Cale> You could download Yi and read it :)
20:01:47 <jethr0> pengo, now that you know about the language spec, can we maybe help with further questions?
20:02:02 <pengo> jethr0, yes. how do i write a logo interpreter? :)
20:02:07 <Cale> ah
20:02:26 <dons> can't be too hard.
20:02:31 <Cale> pengo: you might be interested in the L-System generator xerox and I wrote
20:02:33 <jethr0> you could look at "parsec" for parsing. and there is a good parsec tutorial around somewhere
20:02:49 <pengo> Cale, L-systems are fun. sounds good.
20:02:51 <Cale> That's got a logo interpreter in it, to some extent
20:02:55 <jethr0> cale, i read on the quotes that is was quite "short". where's it at?
20:03:22 <Cale> I think xerox has a more stable page for it
20:03:52 <Cale> but let me just make sure my copy works, and I'll put it somewhere
20:03:56 <pengo> cool
20:04:20 <pengo> i hope it's heavily commented :)
20:04:29 <Cale> oh, it's not
20:05:04 <Cale> (sorry about that)
20:06:06 <Cale> vx.hn.org/autoshare/Nymphaea.tar.bz2
20:06:29 <Cale> note also that certain UI elements don't yet do anything
20:06:55 <Cale> (but it does work :)
20:07:11 <Cale> Really, it's just the menus that don't do anything
20:07:27 <pengo> ok
20:07:41 <Cale> I'd remove them from the .glade, but they're a nice reminder that there's work to do :)
20:08:19 * dons happily notes that hmp3 comes up 3rd in google for "curses mp3"
20:08:30 <pengo> where's the name from (nymphaea)?
20:08:31 <dons> kick all those bad C apps 
20:08:31 <jethr0> you guys on #haskell are so cool. at least sth to aspire to :)
20:08:49 * jethr0 is just listening to hmp3
20:08:59 <dons> cool!
20:09:53 <jethr0> dons, i don't want to be a nuissance, but adding new files would be nice. or have i simply not found it?
20:09:53 <pengo> genus of lily?
20:09:55 <Cale> result 0 (axioms,productions) = axioms
20:09:57 <Cale> result n (axioms,productions) = result (n-1) (axioms >>= expand productions, productions)
20:10:00 <Cale> expand productions axiom = liftM join $ mapM apply axiom
20:10:02 <Cale>     where apply c = M.findWithDefault (return [c]) c productions
20:10:13 <Cale> that's the entirety of the code which expands the L-System
20:10:28 <dons> jethr0, quit and add new ones on the command line. that 's the only way atm.
20:10:32 <Cale> er, you need a few types too
20:10:32 <jethr0> :)
20:10:49 <Cale> actually, they're just synonyms
20:10:51 <pengo> Cale, cool
20:11:09 <SamB> hmm, something is wrong with irc.freenode.net...
20:11:18 <Cale> SamB: I noticed
20:11:28 <pengo> where do people mostly learn haskell from? at uni?
20:11:29 <mjl69> chat.freenode.net due to nuisancebots
20:11:52 <Cale> pengo: I learned it from online tutorials and by sitting around here and on the mailing lists.
20:11:53 <jethr0> samb, you mean because there's so little traffic?
20:12:11 <Cale> pengo: and then there was that time that I was paid to write Haskell code :)
20:12:12 <mjl69> mailing list? :-)
20:12:36 <SamB> jethr0: I mean because I can't connect that way
20:12:40 <Cale> http://www.haskell.org/mailinglist.html
20:12:50 <SamB> I ended up going via irc.eu.freenode.net, I think
20:13:01 <jethr0> samb, i thought it was due to my switch from xchat to irssi...
20:13:06 <jethr0> me too
20:13:18 <SamB> http://www.blug.linux.no/rfc1149/ is funny...
20:13:25 <Cale> haskell and haskell-cafe are pretty good. I've been finding them sort of duller than usual lately, but it's a good way to stay on top of things.
20:13:43 <pengo> Cale, paid to write haskell code? which planet do you live on?
20:13:59 <Cale> pengo: Magrathea
20:14:04 <jethr0> samb, and it transparently interfaces with haskell *g*
20:14:07 <pengo> of course
20:14:10 <Cale> hehe
20:14:24 <Cale> I wrote a pipeline scheduler for PPC+Altivec
20:14:30 <jethr0> cale's programs were used to generate fractal fjords
20:14:38 <Cale> jethr0: :)
20:14:46 <SamB> which transparently interfaces with Haskell?
20:15:02 <jethr0> the avian carrier IP
20:15:51 <Cale> 64 bytes from 10.0.3.1: icmp_seq=0 ttl=255 time=6165731.1 ms
20:16:06 <jethr0> nothing like a good roundtrip
20:16:26 <SamB> hehe
20:16:47 <Cale> 9 packets transmitted, 4 packets received, 55% packet loss
20:18:20 <SamB> yeah
20:18:27 <SamB> and I thought my PING was bad
20:18:53 <jethr0> would be interesting to route that long enough to hit the TTL, though
20:19:02 <jethr0> s/long/often/
20:21:56 <SamB> "bandwidth is limited to the leg length"
20:23:18 <mjl69> if I have a pile of 5 beans on the table in front of me on the left and another pile of 5 beans on the right and I want to add them together in my right hand... f(g(x)) where x is a pile of beans.  So g would be the action of picking up the first pile of beans and putting them in my right hand.  Then, f would be the action of using my left hand to place another pile of beans into my right hand.
20:24:42 <mjl69> I could do just f(x) or just g(x) or even g(f(x)) and it would still work the same.
20:26:28 <mjl69> Beans->Beans->Beans
20:31:14 <Cale> mjl69: assuming certain things about how you store information about the situation
20:32:36 <Cale> If you want, it could also be something like  g :: LeftPile -> RightHand -> (LeftPile, RightHand), f :: LeftHand -> RightHand -> (LeftHand, RightHand)
20:33:32 <Cale> Or, if you know about State monads they could both be of type  State (LeftHand, RightHand, LeftPile, RightPile) ()
20:34:17 <mjl69> I'm still working my way up through the early '90s
20:34:47 <Cale> :)
20:34:59 <jethr0> working chronogically, ey? how did you like your fortran phase?
20:36:01 <mjl69> I think it's the storing of information that is confusing me about the basics of composite functions.  I can't evaluate g(x) and then go evaluate f(g(x)) because g(x) is already gone and out of scope.
20:37:46 <mjl69> and when you take a function like (+) and say it is one function that is evaluated and  then in turn that result is evaluated by another function, what did the first one have to do?  Just take a value and return that same value so the second function can do the real work of adding?
20:38:03 <jethr0> "such that you can edit the editor itself, and reload it, w/o having to quit it" lol
20:38:09 <mjl69> On the surface, it makes perfect sense, but when I started experimenting, I wasn't so sure.
20:38:44 <jethr0> mjl69: have you had a closer look at lambda calculus?
20:40:05 <SamB> what makes perfect sense?
20:40:09 <SamB> or not?
20:40:11 <mjl69> I've started looking at it closer in my book "An Introduction to Functional Programming Systems Using Haskell" AJT Davie.  It has some good material.
20:40:11 <jethr0> :)
20:40:41 <jethr0> well, lambda calculus does this evaluation, and it makes sense and works, right?
20:41:16 <mjl69> yeah
20:41:32 <jethr0> then i don't understand where exactly your dilemma lies
20:42:10 <mjl69> well, a function that takes two arguments is really a composite of two functions, each taking a single argument.
20:42:42 <dons> mjl69, it takes the first argument, and returns a function which when applied to the second argument wil return the final result.
20:46:03 <jethr0> > \x y -> (+) y x
20:46:04 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
20:46:10 <jethr0> > (\x y -> (+) y x)   4 3
20:46:11 <lambdabot> 7
20:46:17 <jethr0> > (\x -> (\y -> (+) y) x)   4 3
20:46:18 <lambdabot> 7
20:46:59 <jethr0> no, that's not perfect, wait a sec
20:48:42 <mjl69> > (\x->x) 4
20:48:43 <lambdabot> 4
20:49:24 <jethr0> > (\x -> (\y -> (+) y x))   4 3
20:49:25 <lambdabot> 7
20:49:26 <Cale> mjl69: When you have something like double x = x + x, and oh, inc x = x + 1, you can evaluate double (inc x) in a number of ways
20:49:32 <jethr0> second one is more correct!
20:49:38 <Cale> one way is to do innermost first evaluation:
20:49:56 <Cale> double (inc 5) = double (5 + 1) = double 6 = 6 + 6 = 12
20:50:13 <Cale> another is to start with the outermost function:
20:50:34 <Cale> double (inc 5) = (inc 5) + (inc 5) = (5 + 1) + (5 + 1) = 6 + 6 = 12
20:51:21 <Cale> now, this second way looks like a big waste of space and time at first -- looks like you're going to have to compute (inc x) twice.
20:52:19 <Cale> But what we can do is to make note of when this kind of duplication of work is occurring (we can see it in the definition of double that the two x's are the same)
20:52:27 <Cale> and eliminate that extra work
20:52:46 <Cale> That in essence is what lazy evaluation is about
20:53:23 <Cale> outermost first, with sharing of work which is obviously the same because it came from expanding the same variable.
20:53:44 <jethr0> cale, i'm not sure about terminology, but wouldn't naive/multiple evaluation also count as lazy?
20:53:50 <Cale> strict evaluation, as occurs in most other languages is the first option, innermost first
20:54:08 <Cale> jethr0: well, it would be non-strict
20:54:15 <jethr0> hehe
20:54:32 <Cale> It would have non-strict semantics
20:54:53 <Cale> but everywhere I have seen, lazy includes that sharing as part of the definition
20:55:26 <jethr0> hmm, but sharing subexpressions does explicitely not change the semantics!?
20:55:33 <Cale> Right, it doesn't
20:55:45 <Cale> We're talking about evaluation mechanisms though
20:55:56 <jethr0> ya, didn't want to interfere...
20:56:03 <Cale> (rather than semantics)
20:56:07 <Cale> It's a good point
20:56:31 <Cale> There's strict and non-strict semantics, and lazy evaluation is a way to implement non-strict semantics.
20:56:43 <jethr0> ok
20:58:08 <Cale> mjl69: does that make sense? :)
20:58:46 <mjl69> if you have f(g(x)), g has to be evaluated within the scope of the definition of f.  That is why you must pass both arguments to what appears to be f but is really a composite of the two.  I think that is what was bothering me.
20:59:00 <mjl69> what you said makes sense
20:59:06 <Cale> hmm
20:59:29 <Cale> well, by writing f(g(x)), you're assuming that both f and g are in scope
20:59:42 <SamB> scope has nothing to do with evaluation mechanisms, really...
21:00:46 <SamB> well, that is, assuming you use lexical scope
21:00:52 <Cale> and just what do you mean by 'both arguments'?
21:00:57 <Cale> I may have missed something
21:01:15 <Pupeno> you only use static libraries with ghc ? no dynamic ones ? .so ?
21:01:24 <jethr0> samb, let's not get ahead of ourselves. dynamic scope has mainly been shunned from almost all modern languages...
21:01:38 <Cale> Pupeno: I think some platforms allow -split-objs or something like that
21:01:52 <Cale> Pupeno: but mostly not right now
21:01:57 <SamB> Cale: that doesn't have anything to do with .so
21:02:01 <Pupeno> ok. thanks.
21:02:06 <Cale> SamB: okay, I really don't know :)
21:02:08 <SamB> thats an optimization that drives ar crazy!
21:02:13 <dons> Ppupeno, on the mac you can use dynamic linking.
21:02:33 <dons> and split-objs is nice for shrinking binaries on other platforms.
21:02:34 <Cale> ah, okay, so I had it right, but the wrong flag :)
21:02:45 <Cale> ah
21:02:56 <Cale> that's how they probably got connected in my brain
21:04:25 <mjl69> addition is a composite function that takes two arguments.  having the type a->b->c, you should be able to write it as f(g(x)), right?
21:04:55 <jethr0> why do you have one arg and two functions?
21:05:47 <mjl69> hmmm...
21:06:13 <jethr0> don't you mean   ((f x) y)  ?
21:06:30 <jethr0> where (f x) is a function
21:06:48 <dons> with split-objs every top level decls is put into its own .o file, and then the linker can sort out all the dead code.
21:07:05 <dons> you end up with much smaller binaries.
21:09:29 <mjl69> jethr0: I think this is getting to the root of my confusion.  What is (f x)?  Does it have to be nameless here?
21:09:55 <jethr0_> sry, disconnected :C
21:10:21 <mjl69> so f x returns a function which takes y as an argument
21:10:40 <dons> it's the function 'f' applied to one argument 'x'
21:10:44 <jethr0_> yes, exactly
21:10:59 <mjl69> That's it! 
21:11:09 <dons> @type (+)
21:11:10 <lambdabot> forall a. (Num a) => a -> a -> a
21:11:16 <mjl69> I am thinking over and over in terms of f . g which is wrong.
21:11:21 <dons> @type (+) 1
21:11:22 <dons> @type (+) 1 2
21:11:22 <lambdabot> forall a. (Num a) => a -> a
21:11:22 <lambdabot> forall a. (Num a) => a
21:11:45 <mjl69> even in Perl and Ruby which I am more familiar with, when a function returns a function, it is nameless.
21:12:14 <jethr0_> mjl69: so it is in any language... who is there to name it?
21:12:24 <SamB> well.
21:12:32 <jethr0_> well?
21:12:33 <SamB> some languages might give them names...
21:12:59 <SamB> but that wouldn't be very pure, now would it?
21:13:07 <mjl69> so that's why Ruby calls the function that makes a block into an anonymous function 'lambda'
21:13:08 <Korollary> nothing returned from a perl function has a name
21:13:14 <cpatrick> the python folks wants to get rid of lambda :(
21:13:32 <dons> it doesn't have to be anonymous. you can name it
21:13:46 <dons> > let g = (+) 2 in g 3
21:13:47 <lambdabot> 5
21:13:48 <jethr0_> Korollary: how about the string literal "4". some might say it has a name :)
21:14:09 <jethr0_> dons, but after returning it, it is kinda anonymous again
21:14:24 <dons> it's just a normal value. nothing magic.
21:15:18 <SamB> eh.
21:15:18 <dons> functions are just values. you name them just like the 0-ary values like Strings and such like.
21:15:22 <mjl69> yes, just a dumb misunderstanding on my part.  thanks, now I can sleep tonight. 
21:15:23 <SamB> string literals have names...
21:15:32 <SamB> you can show them ;-)
21:15:42 <SamB> and they can be read back then.
21:15:48 <dons> you can show functions...
21:16:02 <SamB> .. but you can't read them in again
21:16:25 <Korollary> what does show or read have to do with something being a value or not?
21:16:32 <jethr0_> samb, well you could...
21:16:59 <SamB> jethr0: well, if you restrict yourself to specific classes of funtions I suppose...
21:17:15 <jethr0_> you'd just need a constructor for them :)
21:17:15 <dons> Korollary, I don't think it has anything to do with it.
21:17:25 <dons> SamB is just obfuscating things ;)
21:18:02 <jethr0_> is there a contest for irc channel obfuscation?
21:18:51 <jethr0_> dons, how stable are the emacs keybindings supposed to be? starting with "--as=emacs" doesn't seem to work all that well...
21:18:53 <mjl69> so you give f two arguments and say "f, I know you can only handle one argument, so just take the first one and make me a function that will handle the second one"
21:18:59 <SamB> Korollary: who said anything about values?
21:19:04 <SamB> I was talking about names
21:19:14 <jethr0_> mjl69: you give f one argument and it will return a function
21:19:24 <jethr0_> you give that function one argument and it will return a value
21:19:30 <SamB> IOICC just doesn't have the same ring to it as IOCCC
21:19:43 <dons> jethr0, unstable_. --as=mg is okk though.
21:20:31 <mjl69> jethr0_: right, f returns a function based on the first argument given.  like a closure in the popular scripting languages.
21:20:36 <SamB> mjl69: actually, you let f figure out how many arguments it was looking for and make no attempt to figure it out yourself...
21:20:47 <dons> mjl69, it is a closure.
21:20:56 <mjl69> but f can only take one no matter what
21:21:02 <SamB> hehe
21:21:12 <SamB> no, it can take more than that...
21:21:20 <SamB> but thats an implementation detail...
21:21:21 <jethr0_> samb, stop obfuscating :)
21:21:34 <SamB> jethr0_: but its SOOO much FUN!
21:22:13 <jethr0_> mjl69: don't listen to samb. he's in a weird mood today...
21:22:14 <dons> it's all closures in haskell.
21:22:36 <mjl69> dons: cool, now it's all coming together.
21:22:38 <SamB> in the lambda calculus interpretation, f will indeed take only one argument
21:22:39 <Pupeno> lisppaste2: url
21:22:39 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:23:29 <lisppaste2> Pupeno pasted "error" at http://paste.lisp.org/display/14750
21:23:44 <Pupeno> What does that compilation error means exactly ?
21:24:08 <mjl69> Well, I am being dragged away from the computer to get some sleep.  You guys are the greatest.  Thanks for clearing up my brain a little.
21:24:44 <SamB> Pupeno: it means GHC doesn't like you
21:24:50 <SamB> are you using 6.4?
21:25:00 <SamB> maybe you should upgrade to 6.4.1...
21:25:03 <Pupeno> 6.4.1.
21:25:07 <SamB> oh
21:25:19 <Pupeno> Glasgow Haskell Compiler, Version 6.4.1, for Haskell 98, compiled by GHC version 6.4.1
21:25:28 <SamB> try using make to rebuild that file?
21:25:42 <Pupeno> make ? haw ?
21:26:00 <SamB> hmm.
21:26:14 <SamB> or maybe remove/hide the WASH package.
21:26:16 <SamB> dunno.
21:26:28 <Pupeno> I mean, what do you mean by make ?
21:26:40 * SamB was probably not thinking straight
21:26:48 <Pupeno> ok.
21:27:22 * Pupeno gives up on playing with WASH to play with smaller code.
21:27:37 <SamB> basically, the problem is that GHC is confused by your request that it compile this WASH module which is also installed as part of the WASH package
21:27:57 <SamB> or rather, which has the same name as one installed as part of the WASH package
21:27:57 <Pupeno> oh! it is because WASH is installed ?
21:28:08 <SamB> in part, yes
21:28:27 <SamB> the other part is that it is not hidden
21:28:44 <SamB> ghc-pkg --help
21:29:27 <SamB> in particular, notice the "hide" and "expose" commands
22:23:50 <sethk> are there ghc packages for ubuntu?
22:26:47 <Cale> sethk: yep
22:26:56 <Cale> ghc6
22:27:06 <sethk> Cale, do I have to add a repository?  Let me try it.
22:27:18 <Cale> I don't actually run Ubuntu
22:27:22 <elk> it's in universe i think
22:27:45 <Cale> what is "universe" anyway?
22:27:49 <sethk> ok, thanks.  Just ghc?  The web page for debian says ghc6 ghc6-prof  etc., etc.
22:27:53 <sethk> Cale, a repository
22:28:08 <Cale> sethk: yeah, there's a bunch of other things you could probably get too
22:28:14 <elk> sethk, let me see
22:29:14 <sethk> elk, speaking of which, what's the universe repository URL and name?
22:29:50 <elk> Cale, ubunt classifies all avail. packages into categories - universe contains onse that are not supported by ubuntu
22:29:52 <sethk> Cale, reading from the docs, ubuntu has main, restricted, universe and multiverse
22:31:19 <sethk> restricted is stuff that isn't GPL
22:31:22 <sethk> main is main
22:31:39 <cpatrick> sethk: add "universe" after "main" in th esources you already have
22:31:50 <elk> sethk, you can just edit your /etc/apt/sources.lst - uncomment lines that have universe in em
22:31:53 <sethk> cpatrick, thanks
22:31:55 <sethk> elk, thanks
22:32:32 * elk thinks ubuntu rocks
22:33:17 <cpatrick> elk: too much of universe is just randomly broken (even compared to Debian sid)
22:33:24 <cpatrick> and often out of date
22:33:49 <cpatrick> e.g. in breezy, ion and speex are both complete unusable
22:33:55 <Korollary> hmm, static vs dynamic battles are intense between academics...
22:34:06 * cpatrick hates all operating systems
22:34:30 <Korollary> I usually hate the one I am currently running.
22:34:33 <sethk> cpatrick, I install from source on most of my boxes.  Ubuntu is a great help on systems with wireless
22:34:52 <sethk> cpatrick, so to me there isn't much sense in using ubuntu and then using universe or multiverse
22:35:01 <sethk> cpatrick, as you said, for that, debian is better
22:35:45 <cpatrick> sethk: yeah. I hate having to compile my own kernel on my (Debian) laptop to get working wireless
22:36:04 <cpatrick> sethk: compiling from source is pain. (I used gentoo for a few weeks before running away in horror ;)
22:36:46 <sethk> cpatrick, I dispensed with gentoo fairly quickly.  I don't see the attractiveness for some people of compiling for a week in order to get a system that runs slower than debian or fedora.
22:37:10 <sethk> cpatrick, important stuff I install from source, but compiling the universe just makes no sense.
22:37:18 <cpatrick> yep
22:38:06 <cpatrick> I'd rather not have to compile anything from source unless it's something I'm involved in the development of
22:38:10 <elk> sethk, so universe should be more like gentoo ebuilds ?
22:38:17 <Cale> I'd rather have someone who knows what they're doing compile my packages :)
22:38:30 <sethk> elk, no, I don't like gentoo style at all
22:39:02 <sethk> elk, what I meant is that ubuntu is very strong in some areas, and I use ubuntu on machines where those areas (where it is strong) are what I need
22:39:46 <Korollary> What is so nice about compiling everything from source?
22:39:55 <sethk> Korollary, nothing, IMHO
22:40:08 <sethk> Korollary, plus, as I said, with gentoo you end up with a system that is slower than the major distros
22:40:20 <Korollary> How do they manage that ?
22:40:21 <elk> sethk, right, i think i have only used universe to install ghc (so i can build 6.5) ond ocaml
22:40:22 <sethk> Korollary, the distros really do add value
22:40:38 <sethk> elk, I noticed, actually, that ocaml is there without universe
22:40:45 <sethk> elk, we should lobby to get ghc in there also
22:40:56 <elk> sethk, second that
22:41:06 <cpatrick> is Ubuntu main closed under build-depends?
22:41:24 <elk> actually my Gentoo seemed to be much faster then Suse
22:41:42 <elk> and about the same as my current Ubuntu
22:42:11 <Korollary> How do you tell how fast your linux distro is on the desktop?
22:42:47 <cpatrick> number of minutes needed to load openoffice :P
22:42:58 <elk> thats why I said seemed - just my subjective feeling
22:43:19 <Korollary> right, but sethk said that some gentoo heads were ending up with slower OS' as well.
22:43:22 <sethk> elk, cpatrick, I see what you mean about the universe repository.  cabal is broken (the package, that is)
22:43:42 <rep> every kiss begins with kay
22:43:46 <sethk> Korollary, I forget what I ran, it was quite a while ago
22:43:58 <sethk> rep, was that relevant?
22:43:59 <elk> sethk, just get it from darcs
22:44:06 <rep> sethk you tell me
22:44:12 <Korollary> diamonds are forever?
22:44:18 <sethk> elk, I know.  Actually all I really need is a running binary so I can compile from source
23:51:10 <newsham> hi
23:57:15 <Korollary> yello'
