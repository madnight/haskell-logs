00:00:26 <dons> hmm. try to work out what pattern didn't compile, and then see if it's weird for some reason.
00:00:39 <unusednick> dons: well, there's a lot of them
00:01:13 <dons> yeah, tricky. hmm...
00:01:13 <unusednick> is there a way to make the plugin or bot figure out which one it is?
00:01:36 <unusednick> looks to me like this is an opportunity for improving error reporting/debugging
00:01:41 <dons> oh, yes, we could wrap regcomp.
00:02:13 <dons> a wrapper over mkRegex in Plugins/Vixen/VixenState.hs would do the trick
00:03:24 <dons> mkRegex' s = catch (\e -> error "mkRegex failed with  " ++ show s ++ ": " ++ shoe e) (mkRegex s)
00:03:27 <dons> or so..
00:03:52 <dons> import mkRegex qualified in VixenState.hs, and then name the above mkRegx, and you won't have to modify more than 1 or 2 liens..
00:05:06 <dons> do you want to write it, unusednick?
00:07:00 <unusednick> hmm
00:07:05 <unusednick> i'll try it
00:07:16 <dons> well, i'm about to commit it anyway ;)
00:07:24 <unusednick> oh
00:07:28 <unusednick> nevermind, then
00:07:38 <unusednick> tell me when to pull
00:07:44 <dons> :)
00:07:44 <dons> it's a good idea though. if you see any other 
00:07:47 <dons> issues like that, let me know
00:07:51 <unusednick> sure
00:10:01 <kzm> @seen lambdabot
00:10:01 <lambdabot> Yes, I'm here. I'm in #unicycling, #ScannedInAvian, #haskell.es, #haskell.
00:10:01 <lambdabot> it, #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell
00:10:08 <kzm> @seen shapr
00:10:09 <lambdabot> shapr is in #haskell-blah, #ScannedInAvian and #haskell. Last spoke 4
00:10:09 <lambdabot> hours, 21 minutes and 49 seconds ago.
00:10:29 <kzm> 4h?  Not too promising..
00:11:09 <kzm> Anybody read the dazzle paper?  (Or write it, for that matter)
00:16:49 <dons> good idea unusednick, found one borken pattern straight away: 19:10  donsbot:: Module "vixen" produced error: mkRegex failed on input ".*(^| )(u |you |).
00:16:52 <dons> 19:10  donsbot:: *stop.*" with Text.Regex.Posix.regcomp: error in pattern
00:16:55 <dons> :)
00:17:26 <dons> @karma+ unusednick   -- you need a more intuitive nick ;)
00:17:27 <lambdabot> unusednick's karma raised to 1.
00:18:17 <unusednick> i tried severall
00:18:19 <unusednick> and gave up
00:18:25 <unusednick> this network's too big
00:18:40 <dons> it is big, yes :/
00:40:30 <dons> @index withCString
00:40:31 <lambdabot> Foreign.C.String, Foreign.C
00:47:52 <ProfTeggy> Moin
00:52:00 <Gs30ng> i've seen a lot of guys whose greeting is moin
00:52:04 <Gs30ng> interesting
00:52:15 <Gs30ng> seems kinda meme
00:52:45 <dons> Moin Moin!
00:55:02 <Heffalump> I blame the Germans.
00:55:39 <ProfTeggy> Yes, it's a contraction of 'moi morn!'
00:55:52 <ProfTeggy> Meaning '(have a) nice day'
00:56:02 <ProfTeggy> 'moin moin' simply means '... very nice day'
00:56:24 <Gs30ng> is it pronounced /moin/ (in IPA)?
00:57:04 <ValarQ> Gs30ng: godmorgon
00:57:22 <ProfTeggy> Gs30ng, yup
00:57:23 <Gs30ng> pardon?
00:57:35 <dons> unusednick, ok, I've committed some patches to the regex code. maybe you'd like to try it out.
00:57:38 <dons> @version
00:57:38 <lambdabot> lambdabot 3p201, GHC 6.5.20050806 (Linux i686)
00:57:38 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
00:57:46 <dons> ooh. 201!
00:58:29 <unusednick> ghc -Wall -Werror -I. -cpp -fglasgow-exts -funbox-strict-fields -O   -c Regex.hs -o Regex.o -ohi Regex.hi
00:58:32 <unusednick> Regex.hsc:105:66: Not in scope: type constructor or class `Int64'
00:58:40 <unusednick> do i need to clean first or something?
00:58:41 <dons> new patch has since gone in ...
00:58:45 <dons> yes, clean
00:59:26 <dons> I'd do a complete rebuild: autoreconf ; ./configure ; make
01:00:48 * unusednick is building
01:01:19 <dons> should build much faster, btw. i switched to -fasm, and tweaked VixenState.hs so ghc doesn't stall for 2 mins compiling it
01:01:31 <dons> now it stalls for 3 or 4 seconds :)
01:01:50 * dons notes we've had on average 3 patches to lambdabot a day since it went into darcs 13 months ago
01:05:16 <unusednick> dons: still getting compile error
01:05:17 <unusednick> ghc -Wall -Werror -I. -cpp -fglasgow-exts -funbox-strict-fields -O -fasm   -c Regex.hs -o Regex.o -ohi Regex.hi
01:05:20 <unusednick> Regex.hsc:105:66: Not in scope: type constructor or class `Int64'
01:05:31 <dons> ok. that's weird. i'll take a look.
01:06:05 <unusednick> that's after autoreconf, configure, make clean, make
01:12:04 <dons> try that, ununusednick, darcs pull.
01:12:34 * unusednick makes
01:12:43 <unusednick> got past Regex
01:12:52 <unusednick> now on VixenState...
01:13:21 <unusednick> compiled successfully, starting bot
01:13:31 <dons> cool.
01:13:38 <dons> (that was fast!)
01:13:43 <dons> -fasm really kicks butt.
01:13:53 <unusednick> @vixen seems to be working
01:13:53 <lambdabot> ever feel like you're going around in circles?
01:14:22 <dons> excellent.
01:23:37 <kzm> dons?  I've hacked a bit on the bot, how do I test it?  (I *think* it is compiling now :-)
01:24:19 <kzm> Hmm...I see I'm not alone here (maybe I should read the past conversation?)
01:24:32 <dons> one way is tojust to make up a random channel and test it there. also plugins can usually be tested bit by bit in ghci
01:24:37 <dons> hehe.
01:25:01 <dons> for hysterical reasons I've been testing in #boegelBotTesting
01:25:04 <kzm> I just made static=yes, didn't bother to d/l the plugins stuff.
01:25:11 <kzm> Lazy I know.
01:25:18 <dons> but #haskell-overflow would be ok.
01:25:30 <dons> ah, *shrug* it's ok if you don't use plugins.
01:25:55 <dons> but you won't get a working @eval, if that matters.
01:25:59 <kzm> Plugins are cool but I simply don't have the resources to absorb all that is cool with Haskell.
01:26:21 <dons> hehe ok :)
01:26:22 <kzm> No, no matter.
01:26:41 <kzm> Modules.o(.text+0xb9b): undefined reference to `PluginsziDynamic_theModule_closure
01:26:54 <kzm> Perhaps static=yes promises more than it can hold?
01:27:03 <dons> oh, you didn't completely make distclean 
01:27:09 <dons> it should be in the readme.
01:27:26 <dons> you can't switch between static and dynamic, without forcing the Modules.hs file to be regenerated.
01:27:45 <dons> but the build system can't tell if some env var has been twiddled (at the moment)
01:27:54 <kzm> Ah, okay.
01:28:20 <dons> probably i could write some .stamp file, but until then, you'll have to make distclean and start over.
01:28:52 <kzm> distclean, autconf, configure, make?
01:29:08 <dons> that'd do, yep.
01:29:30 <dons> make -j2 is pretty fast with the latest patch for -fasm, btw. even on single processors.
01:29:47 <kzm> I got HT as well, probably should use -j2 (or 3)
01:29:58 <dons> yeah, crank it up!
01:30:01 <kzm> Is -fasm quicker?  Isn't it default now?
01:30:10 <dons> very very much quicker.
01:30:17 <dons> it's still not the default for -O, iirc
01:30:17 <kzm> The default is -fvia-c?
01:30:29 <dons> if you turn on -O, yep.
01:30:40 <kzm> very very sounds good.  How late is latest?  (I.e. I got stock 6.4 something)
01:31:01 <kzm> 6.4.1
01:31:08 <dons> I mean, with the latest lambdabot patch to force -fasm
01:31:28 <dons> comitted about 10 mins ago ;)
01:32:06 <kzm> I see.  So ghc's -fasm has been fast for some time (always).  I didn't darcs pull today, but I can do that.
01:32:19 <kzm> But probably not worth terminating my compilation for, eh?
01:32:40 <dons> yeah, some nice patches just went in, on prompting from unusednick. maybe switching to -fasm and repulling would still be faster!
01:32:46 <kzm> If it was very very very very much faster, it might have been worth it, but not for only very very.
01:33:16 <dons> > replicate 4 "very"
01:33:17 <lambdabot> ["very","very","very","very"]
01:34:04 <kzm> make: *** No rule to make target `runplugs', needed by `all'.  Stop.
01:34:15 <kzm> Maybe not so needed?
01:34:30 <dons> not needed. it's harmless. but also a patch for that should already be in the repo
01:34:57 <dons> oh, actually. my fault. i only half did the patch.
01:35:03 <dons> nonetheless, still harmless
01:35:25 <kzm> I got lambdabot binary.  Anyway, how do I run it?  (Oh wait, should I have edited Config.hs?)
01:35:55 <dons> yeah, otherwise it'll try to log in a 'lambdabot' in this channel, and freenode won't let it
01:36:22 <kzm> I should, shouldn't I.
01:36:30 <kzm> Okay, now I get to try -j etc :-)
01:37:11 <kzm> (Possibly the public repo should provide (generate?) a config that makes sense for testing?)
01:37:12 <dons> just pushing a patch now for the runplugs err. maybe pull and check it.
01:37:25 <dons> hmm. maybe yeah. hmm.
01:37:40 <dons> or at least have an example with reasonable defaults
01:38:40 <kzm> Or comment out the config, so that the user is forced to at least uncomment it to get it to compile.
01:38:46 <kzm> (want a patch? :-)
01:39:07 <kzm> The commenting would probably be unobstrusive to any patches (i.e. commute cleanly)
01:39:55 <kzm> tick tick...make -j 3 static=yes
01:40:16 <dons> hmm. yeah, possibly forcing them to edit the Config.hs with, say, a DEPRECATED pragma or something would be ok.
01:40:27 <dons> i kinda feel a bit icky about breaking the build though
01:40:36 <dons> better would be to take channel and such like flags on the command line..
01:40:57 <dons> there's a bit of work to do that though, all the static refs to Config would have to go
01:41:34 <kzm> Hmm...isn't it possible to keep it with an unsafePerformIO config read?
01:42:03 <kzm> BTW, I was thinking (never a healthy excercise) about unsafeInterleaveIO...
01:42:22 <dons> ah yes?
01:42:28 <kzm> it is only unsafe with e.g. handles that may be closed elsewhere before the result is fully evaluated, right?
01:42:31 <dons> im a bit of a fan of unsafeInterleaveIO, actually.
01:43:06 <kzm> So IMO it seems hGetContents really should be unsafeHGetContents, while readFile is okay (safe)?
01:43:24 <dons> readFile is just a wrapper over hGetContents.
01:43:39 <dons> but you can certainly write programs that break due to laziness
01:43:40 <unusednick> dons: i think having all the config be static on Config.hs is not the most friendly choice, anyway
01:43:43 <kzm> Right. But you don't get the handle, so you can't close it before contents is read.
01:43:44 <dons> and you end up having to force the handle
01:44:04 <dons> you do a: forkIO (Control.Exception.evaluate (length output) >> return ())
01:44:09 <dons> to force it, before an hClose
01:44:21 <dons> unusednick, right. but it's simple. ;)
01:44:33 <dons> a todo is to instead move Config.hs into ~/.lambdabot/ and dyn load it
01:44:37 <kzm> Sorry you lost me a bit here.  Are you talking about readFile?
01:44:38 <dons> would be fairly easy to do
01:45:03 <dons> yeah, with all the lazy IO, there are cases where you have to force the input for the code to work.
01:45:19 <dons> and the length thingy is a good way to do that.
01:45:33 <dons> btw, readFile name   =  openFile name ReadMode >>= hGetContents
01:45:35 <kzm> Argh!  With all this idle chatter, I recompiled \bot with new patches, but *forgot to edit Config.hs*!
01:45:41 * kzm slaps forehead.
01:46:06 <dons> hmm. I wonder how quickly I can turn Config.hs into a Plugin/Config.hs..
01:46:16 <kzm> dons: no hClose?  Ever?
01:46:42 <dons> well, hClosing stdin is often a bad idea
01:46:50 <kzm> I thought the file would be closed when the contents was exhausted (finalizer or what have you)
01:47:04 <kzm> does it matter, if you have exhausted the input?
01:47:49 <dons> once the entire thing is read, it is closed.
01:47:49 <kzm> (and surely, readFile can't read stdin, since it needs a file name?  readFile "/dev/tty..."?
01:47:55 <dons> also if there's an error
01:48:28 <dons> there's a longish discussion of the semantics in $fptools/libraries/base/GHC/IO.hs
01:48:41 <dons> sorry, yeah, I was thinking of the underlying hGetContents
01:49:05 <kzm> By the way: textWidth = 75.  This causes ugly wrapping in my client.
01:49:38 <dons> hmm. the wrapping handling is still sub-optimal, yes. someone needs to dive in and improve it
01:49:38 <kzm> I realize it may make sense for some other type of client, but I think all clients must (will have to) deal with long lines anyway.
01:50:02 <dons> yeah, maybe we should just not wrap. I can't recall the argument against that though.
01:50:04 <kzm> For me, textWidth = \inf is probably the correct choice :-)
01:50:10 <dons> we had some long discussoins about this.
01:50:29 <kzm> Okay.  There
01:50:33 <dons> TheHunter might remember the details, he revamped the code recently
01:50:36 <kzm> ...is probably a good reason.
01:50:58 <ADEpt> SamB: here?
01:51:18 <kzm> The patch (static=yes) seems to work nicely.
01:51:31 <dons> good.
01:51:48 <kzm> And the rest of todays patches at least compile :-)
01:52:06 <dons> good good. they're already running in this lambdabot, and seems ok.
01:52:17 <dons> @vixen what do you think of lambdabot hackers?
01:52:18 <lambdabot> a bot? what is that?
01:52:34 <dons> @vixen what bout haskell hackers then?
01:52:34 <lambdabot> church is my favourite computer scientist.
01:55:52 <kzm> Eureka!  It is ALIVE!  Mouhahaha!
01:56:19 <kzm> But my extension didn't *quite* work - back to the drawing board.
02:10:39 <kzm> dons: thanks for the help.  Do you want patches?
02:11:09 <kzm> dons: I'll put my repo at http://www.ii.uib.no/~ketil/lambdabot, and you can pick whatever?
02:18:45 <dons> ok, cheers!
02:36:02 <phys_rules> hello to everyone ;)
02:36:49 <phys_rules> I have the *registered* build of ghc for Solaris x86 up and going :) finally small sizes and fast speed =) a hello world is 270kb =)
02:36:54 <phys_rules> ghci works just fine :)
02:41:00 <Lemmih> neat.
02:41:28 <eivuokko> Good job :)
02:47:34 <dons> excellent phys_rules, what was the problem with a registerised build in the first place?
02:47:49 <dons> and, what, split objs? did you get split objs working?
02:48:03 <phys_rules> dons: yep, with objs as well
02:48:09 <dons> cool!
02:48:19 <dons> did you have to do anything to get split objs working?
02:48:24 <phys_rules> dons: nope!
02:48:25 <phys_rules> :)
02:48:25 <dcoutts> phys_rules, was that using gnu ld or solaris ld?
02:48:31 <phys_rules> solaris ld
02:48:37 <dons> hmm!
02:48:38 <dcoutts> well done
02:48:46 <phys_rules> the hard part was getting an unregistered build to go
02:48:53 <phys_rules> as I didn't have a linux box
02:48:58 <phys_rules> so I had to build it on windows
02:49:06 <dons> oh boy. that's the hard way
02:49:08 <phys_rules> and I was trying to do that with mingw which isn't really POSIX-ish
02:49:17 <dons> i don't think that 's been done before, in fact.
02:49:25 <phys_rules> so I went with cygwin
02:49:29 <phys_rules> patched it here and there
02:49:30 <phys_rules> and voila
02:49:45 <dcoutts> and now it's working regesterised?
02:49:49 <phys_rules> dcoutts: yes
02:49:52 <dcoutts> cool
02:50:19 <phys_rules> muuuch faster than the unregistered build :)
02:50:23 <dcoutts> yeah
02:50:29 * dcoutts has to go now
02:50:32 <dcoutts> well done phys_rules 
02:50:32 <phys_rules> the unregistered one is a memory hog as well
02:50:37 <phys_rules> thanks
02:50:52 <phys_rules> I'll make a binary distribution
02:51:02 <phys_rules> and will try to upload it somewhere
02:51:39 <phys_rules> dons: yeah, I guess it's easier to just do it on linux than windows =)
02:51:40 <Lemmih> You can get JaffaCake to host it at haskell.org
02:52:13 <phys_rules> Lemmih: yeah
03:11:55 <Lemmih> dons: Does hmp3 work with libncurses5?
03:12:22 <dons> yep
03:12:24 <phys_rules> @where hmp3
03:12:25 <lambdabot> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/hmp3
03:12:44 <phys_rules> need to build darcs first =)
03:12:51 <dons> i've been using /usr/lib/libncursesw.so.5.4
03:12:57 <dons> on linux.
03:13:26 <dons> ncurses is pretty stable, and i've not heard of versioning issues in any of the ncurses apps i've hacked on
03:14:11 * Oejet is reading "Lock Free Data Structures using STMs in Haskell".  
03:14:39 <Lemmih> dons: Now I'm having problems with the Regex.hsc file.
03:15:02 <dons> ah, ok. i just hacked on that today, maybe i broke something
03:15:07 <dons> what does it say?
03:16:21 <Lemmih> Regex.hsc:65:0:
03:16:21 <Lemmih>      error: 'regex_t' undeclared (first use in this function)
03:16:29 <dons> hmm.
03:17:05 <Lemmih> I should install some regex library?
03:17:43 <dons> i've never had to, but it does assume # include <regex.h>
03:18:36 <dons> anything strange in cbits/config.h ?
03:18:48 <dons> and what does configure say?:
03:18:49 <dons> checking regex.h usability... yes
03:18:49 <dons> checking regex.h presence... yes
03:18:49 <dons> checking for regex.h... yes
03:18:58 <Lemmih> There is no cbits/config.h (:
03:19:21 <dons> did you follow the build instructions? ;)
03:19:26 <Lemmih> Bah. Stupid me.
03:19:31 <dons>     $ chmod +x configure Setup.lhs
03:19:32 <dons>     $ ./Setup.lhs configure --prefix=/home/dons
03:19:32 <dons>     $ ./Setup.lhs build
03:19:32 <dons>     $ ./Setup.lhs install
03:19:34 <dons> ;)
03:19:38 <dons> I bit it's the +x ..
03:20:02 <Lemmih> Why does configure has to be executable? Cabal ran it as 'sh configure' last time I checked.
03:20:25 <dons> oh, i've had some cabals that don't. i was just being cautious.
03:21:00 <dons> did you miss a step? 
03:21:47 <Lemmih> Yeah, I didn't change the permissions of 'configure'.
03:22:32 <joelr1> hello folks
03:22:44 <joelr1> has anyone seen this before?
03:22:45 <joelr1> 07:45:03: ThreadId 72: user error (Failed to connect to server: resource vanished)
03:22:54 <joelr1> this is the exception i get when calling connectTo
03:24:01 <lisppaste2> joelr1 pasted "resource vanished" at http://paste.lisp.org/display/14183
03:24:25 <joelr1> actually, this bit of code which is supposed to make it thread-safe
03:25:43 <Lemmih> Hm. Cabal runs 'sh configure' on windows and './configure' otherwise.
03:27:12 <eivuokko> There is no #! in Windows, so that is neccesary.
03:27:37 <joelr1> JaffaCake: ping
03:27:45 <JaffaCake> joelr1: hi there
03:27:52 <Lemmih> eivuokko: Why not run 'sh configure' everywhere?
03:27:59 <joelr1> JaffaCake: quick question re: my paste, is that what you had in mind?
03:28:13 <eivuokko> Lemmih, probably because there exists configure's written in perl etc.
03:28:16 <phys_rules> JaffaCake: I have the registered build of ghc running :)
03:28:26 <eivuokko> Lemmih, Dunno :)
03:28:33 <joelr1> JaffaCake: and good morning
03:28:35 <phys_rules> JaffaCake: with splitobjs, nativegen, ghci and all :)
03:28:53 <JaffaCake> phys_rules: nice!
03:29:40 <phys_rules> though ghci is weird as It doesn't understand backspace etc.. left right, something with my ncurses ? :)
03:30:04 <JaffaCake> joelr1: I don't know why you get that
03:30:19 <joelr1> JaffaCake: but is the blocking on the MVar done properly?
03:30:28 <JaffaCake> looks fine
03:30:30 <Lemmih> phys_rules: Do you have readline installed?
03:30:35 <phys_rules> Lemmih: yes
03:30:55 <joelr1> JaffaCake: ok, thanks. i'm looking into the resource vanished issue. i wish GHC gave me access to system error codes 
03:31:37 <JaffaCake> joelr1: just 'show e', you should get more information
03:31:56 <joelr1> JaffaCake: that's what i'm doing but all i get is resource vanished from connect
03:32:01 <joelr1> musasabi: ping
03:32:16 <JaffaCake> joelr1: your paste has 'ioeGetErrorString', use 'show' instead
03:32:28 <joelr1> JaffaCake: oh!
03:32:50 <JaffaCake> not all IOError->String functions are created equal :)
03:33:01 <joelr1> JaffaCake: ok, let me see
03:33:32 <joelr1> JaffaCake: i tried network-alt but get an error from the resolver code about ai something not supported
03:34:01 <JaffaCake> joelr1: you'll have to ask musasabi about that
03:34:18 <eivuokko> @remember JaffaCake not all IOError->String functions are created equal :)
03:35:17 <joelr1> JaffaCake: thanks, it helped!
03:35:31 <JaffaCake> so what do you get now?
03:35:41 <dons> Lemmih, hmp3 working?
03:35:58 <joelr1> 11:33:59: ThreadId 20: {handle: <socket: 4>}: hGetBuf: invalid argument (illegal buffer size (-4))
03:36:05 <joelr1> 11:34:00: ThreadId 31: user error (Failed to connect to server: connect: resource vanished (Connection reset by peer))
03:36:12 <joelr1> i love the detail!!!
03:36:25 <Lemmih> dons: Yep.
03:36:40 <dons> whaddya think? any comments?
03:37:30 <JaffaCake> joelr1: does that give you enough to go on?
03:37:38 <joelr1> JaffaCake: 100%, thanks
03:39:33 <Lemmih> dons: Pretty nice. The delay when seeking is a bit annoying but that's probably an issue with the underlying player.
03:39:43 <dons> nah, it's actually hmp3's fault.
03:40:10 <dons> i drop 24/25 frames from mpg321, since they're just a waste of time, but then updates on seeking are delayed ever so slightly
03:40:23 <Oejet> There was/is a long thread on the haskell.cafe list about records, but I didn't see "Extensible records with scoped labels" by Daan Leijen mentioned.  Why is that do you think?
03:40:27 <dons> this would be fixable though, it's on the todo list.
03:41:23 <dons> i should fix it. thanks for mentioning it.
03:42:13 <Lemmih> Oejet: David Menendez mentions the paper.
03:42:56 <Oejet> Oh, must've been in the last couple of days, where I've been buried in school work.
03:43:06 * SamB is awake
03:43:20 <SamB> ADEpt: hello
03:44:30 <Lemmih> Oejet: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/9184
03:45:47 <Oejet> Lemmih: Tak.
03:46:16 <SamB> 8:11
03:46:43 <kzm> dons, starting the bot takes long, waiting for ident, I think.
03:46:51 <kzm> Any way to avoid the timeout?
03:47:12 <SamB> kzm: identd!
03:47:20 <SamB> even a fake one
03:47:45 <dons> it seems to really vary from box to box. the machine lambdabot runs on, it's almost instantaneous when connecting:
03:47:47 <dons> @quit
03:47:55 <dons> quite fast.
03:48:02 <kzm> Hmm.. I guess they're not running identd here then.
03:48:14 <kzm> Can I fake it without priv port access?
03:48:23 <dons> ah, maybe that's it. it's probably identd running on alonzo.
03:49:39 <Dave114> hi.  newbie question: is there another way to express f( g( x ) )? ... something along the lines of: f of g (x)?
03:49:55 <phys_rules> (f . g) x
03:50:24 <SamB> f $ g x
03:51:40 <Dave114> ah.  thanks phys_rules and SamB.
03:53:22 <SamB> . and $ are both functions
03:54:07 * SamB confuses newbies again
03:54:40 <musasabi> joelr1: pong
03:54:54 <sieni> (\x->f(g(x)))x
03:54:56 <joelr1> musasabi: i could not use network-alt on mac osx, error about ai_ something not supported
03:55:00 <Cale> (f . g) = \x -> f (g x)
03:55:10 <Cale> f $ x = f x
03:55:17 <musasabi> joelr1: error or warning in the configure?
03:55:27 <Cale> (but $ has really low precedence)
03:55:57 <Cale> sieni: heh
03:56:01 <musasabi> at least the older versions worked on Mac OS X (I don't currently have an OS X test machine, so it could be some autoconf breakage)
03:56:07 <Dave114> SamB: I've had a little exposure to functional programming in the past with lisp.  Unfortunately I've forgotten almost all of it by now
03:56:11 <Cale> I suppose that's part of the transformation
03:56:24 <musasabi> if you can paste the last lines of configure output to me, I'll fix it.
03:56:29 <joelr1> musasabi: i had to edit a couple of minor things but this is a runtime error
03:56:39 <joelr1> musasabi: there was a missing NULL def
03:56:41 <joelr1> for one
03:56:57 <musasabi> joelr1: sounds like you enabled things not supported on your OS.
03:57:01 <joelr1> ./test && ./server
03:57:01 <joelr1> >>> getAddrInfo www.google.com
03:57:01 <joelr1> test: user error (ai_family not supported)
03:57:09 <joelr1> musasabi: me? nah!
03:57:23 <joelr1> musasabi: this is from running make in the test directiory
03:58:28 <joelr1> musasabi: also, i had to edit your Setup.lhs 
03:58:46 <joelr1> to add a couple of missing _ to the patterns at line 15 and 16
04:00:10 <joelr1> musasabi: does this tell you enough? do you need configure? 
04:00:25 <musasabi> joelr1: that is Cabal version mismatch - it is impossible to have a Setup.hs which works, with the cvs cabal and the released one.
04:00:37 <musasabi> The API was changed in an backward incompatible way for hooks.
04:00:47 <joelr1> Running on "darwin" - using Unix mode
04:00:47 <joelr1> Creating Network/Alt/Socket.hsc from implementation "blocking"
04:01:22 <musasabi> joelr1: can you paste the whole configure bit to web somewhere and give me a link (that would tell all the things)
04:01:39 <joelr1> musasabi: what is the configure bit?
04:02:05 <joelr1> the output from ./setup configure?
04:02:08 <musasabi> yes.
04:02:43 <musasabi> Is there a reason that referring to RealWorld# inside .hsc files fails with link error: "GHC/HandleBase_hsc_make.o: In function `main':HandleBase_hsc_make.c:(.text+0x101): undefined reference to `hsc_RealWorld'" (or is it related to the fact that I am playing with GHC internals)
04:02:51 <lisppaste2> joelr1 annotated #14183 with "configure for musasabi" at http://paste.lisp.org/display/14183#1
04:03:58 <musasabi> do a "./setup clean" "./setup configure" (should give you more output because autoconf is only run on demand)
04:05:58 <lisppaste2> joelr1 annotated #14183 with "more configure output" at http://paste.lisp.org/display/14183#2
04:06:04 <joelr1> musasabi: how about now?
04:06:48 * SamB wonders if a DSSSL engine would be profitable to implement in Haskell
04:08:02 <joelr1> SamB: what's a DSSSL engine?
04:09:32 <SamB> joelr1: well, DSSSL is what came before XSLT
04:09:55 <SamB> it is a stylesheet language based on Scheme which is iirc purely functional
04:10:21 <joelr1> SamB: ok
04:10:46 <SamB> oh, and it was for SGML
04:11:47 <musasabi> joelr1: I now know that the correct code is being picked up.
04:12:22 <joelr1> musasabi: ok
04:14:03 <musasabi> joelr1: 10min or so - I think I have a hunch what it may be.
04:14:36 <joelr1> :-)
04:21:08 <Cale> cale@zaphod[~]$ emacs
04:21:09 <Cale> Undefined color: "black"
04:21:14 <Cale> heh
04:21:56 <Cale> aha, rgb.txt has gone missing
04:22:41 <SamB> Cale: heh
04:22:45 <kzm> dons?  I need normalizeTimeDiff -- should I export it from AltTime, or import it directly?
04:22:53 <kzm> @seen dons
04:22:53 <lambdabot> dons is in #haskell. Last spoke 34 minutes and 29 seconds ago.
04:22:56 <Cale> (that's really all that emacs does at the moment)
04:22:59 <Dave114> silly newbie question # 2: does Haskell have any unordered numeric types? (my function works ok for all integers, but I'd like it polymorphic.  However, if I set Num a as a constraint, it gives me an error saying that it's unable to justify the constraint Ord.  I haven't yet figured out how to specify multiple constraints for a functions parameters.)
04:24:11 <SamB> Dave114: yes!
04:24:23 <Cale> Dave114: Num is a subclass of Eq, but not Ord
04:24:26 <SamB> @index Complex
04:24:26 <lambdabot> Data.Complex
04:24:40 <Dave114> ah ... wonderful!
04:25:00 <SamB> > sqrt -1 :: Data.Complex.Complex Double
04:25:01 <lambdabot>  Not in scope: type constructor or class `Data.Complex.Complex'
04:25:12 <Cale> also, parens :)
04:26:22 <SamB> > sqrt -1 :: Complex Double
04:26:23 <lambdabot>  Not in scope: type constructor or class `Complex'
04:26:43 <SamB> Cale: point!
04:37:13 <Cale> Complex should be added to runplugs
04:45:52 <kzm> @index TimeDiff
04:45:52 <lambdabot> System.Time, System.Time
04:46:00 <kzm> TimeDiff 0 0 0 1 0 0 0
04:46:06 <kzm> > TimeDiff 0 0 0 1 0 0 0
04:46:06 <lambdabot>  Not in scope: data constructor `TimeDiff'
04:46:12 <kzm> > System.Time.TimeDiff 0 0 0 1 0 0 0
04:46:13 <lambdabot>  Not in scope: data constructor `System.Time.TimeDiff'
04:46:18 * kzm shrugs.
04:46:49 <Cale> @type System.Time.TOD 0 0
04:46:51 <lambdabot> System.Time.ClockTime
04:47:01 <Cale> ah, that's different
04:47:34 <Cale> right, TimeDiff is the complicated one
04:51:55 <jethr0> hi, anyone home?
04:52:44 <boegel> jethr0: sure
04:53:11 <jethr0> hey, do you think it's possible to create a c-linkable library with haskell and ffi?
04:53:53 <jethr0> would "-dynamic" in ghc do the trick?
04:54:52 <boegel> sorry, I habe no experience with ffi, but I'm sure some people in here have (Lemmih, Cale ?)
04:55:02 <Cale> oh, what's the question?
04:55:06 <jethr0> hey, do you think it's possible to create a c-linkable library with haskell and ffi?
04:55:07 <jethr0> would "-dynamic" in ghc do the trick?
04:55:24 <Cale> yeah, you can do that, you just foreign export things
04:55:52 <jethr0> so, you export your functions with ffi and simply compile it with "-dynamic" and then you can link it against c code as a library?
04:56:08 <Cale> I can't recall exactly which ghc flags you'll need
04:56:18 <Cale> certainly something to avoid needing a main
04:56:19 <jethr0> ok, but great to know that it's possible
04:56:45 <jethr0> hmm, and how about garbage collection issues when haskell is "not in charge"?
04:57:04 <Cale> your library will just be statically linked with the runtime as usual
04:57:40 <musasabi> mmh, fixed the thing.
04:58:06 <jethr0> ok, i am not quite clear about this yet. but i guess i'll just play around with it for a while ;-)
05:02:08 <twb> Howdy.
05:02:52 <twb> Is there a walkthrough that teaches me to make a binary that, say, computes and prints the factorial of each command line argument?
05:03:19 <musasabi> twb: getArgs + mapM_ may be your answer.
05:03:40 <twb> musasabi: I should point out that I'm a novice as haskell.
05:04:11 <Cale> main = let fac n = product [1..n] in do xs <- getArgs; mapM_ print (map fac xs)
05:04:36 <musasabi> Cale: + read perhaps
05:04:40 <twb> Okie, so "main" is a special function.
05:04:42 <Cale> oh
05:04:45 <Cale> yes, of course :)
05:04:51 <Cale> main = let fac n = product [1..n] in do xs <- fmap read getArgs; mapM_ print (map fac xs)
05:04:56 <Cale> er
05:05:03 <Cale> main = let fac n = product [1..n] in do xs <- fmap (map read) getArgs; mapM_ print (map fac xs)
05:05:21 <Cale> or just
05:05:32 <Cale> main = let fac n = product [1..n] in do xs <- getArgs; mapM_ print (map (fac . read) xs)
05:05:33 <musasabi> main = mapM_ (\str -> print (product [1..(read str)])) =<< getArgs
05:05:39 <twb> getArgs isn't bound at the REPL.
05:05:51 <musasabi> twb: it is in the System module
05:05:53 <Cale> twb: :m + System
05:05:57 <musasabi> @type System.getArgs
05:05:58 <lambdabot> IO [String]
05:06:05 <Cale> or import System in your source file
05:06:34 <Cale> @type mapM_
05:06:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
05:06:38 <Cale> @type mapM
05:06:39 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
05:06:50 <int-e> @type enumFromTo
05:06:51 <lambdabot> forall a. (Enum a) => a -> a -> [a]
05:07:07 <Cale> of course, you could completely desugar it :)
05:07:31 <int-e> main = getArgs >>= mapM_ (print . product . enumFromTo 1 . read)
05:07:39 <Cale> hehe
05:08:11 <twb> "foo . bar" is a composition?
05:08:16 <int-e> yep
05:08:17 <twb> Like "foo o bar" in SML?
05:08:20 <twb> Righto.
05:08:56 <int-e> @pl \n -> [1..n]
05:08:57 <lambdabot> enumFromTo 1
05:09:07 <twb> What does pl do?
05:09:17 <Cale> Produces point-free versions of code
05:09:23 <Cale> (pointless)
05:09:32 * twb does not understand.
05:09:48 <int-e> \n -> [1..n]  and  enumFromTo 1   are equivalent
05:09:48 <jethr0> @pl \x y -> x + y
05:09:49 <lambdabot> (+)
05:09:56 <Cale> @pl \f g x -> f (g x)
05:09:57 <lambdabot> (.)
05:09:57 <int-e> but the latter uses no lambda abstraction
05:10:01 <sieni> @pl map (\x -> 1 + x)
05:10:01 <lambdabot> map (1 +)
05:10:02 <jethr0> hehe, quite nifty ;-)
05:10:24 <int-e> it's really rather pointless :)
05:10:24 <Cale> sometimes it manages to simplify code, sometimes it just makes things worse
05:10:24 <twb> So it is like a code simplification feature?
05:10:32 <twb> Okie dokey.
05:10:39 <twb> @pl u f = f f
05:10:40 <lambdabot> u = join id
05:10:40 <Cale> @pl \a b c d e -> a (b c) (d e)
05:10:41 <lambdabot> (((.) .) .) . (.)
05:11:04 <jethr0> yeah, great simplification there!
05:11:12 <Cale> it's untyped transformation of code
05:11:17 <sieni> twb: it transforms the code so that it doesn't refer to the elements the functions are applied to
05:11:20 <dblhelix> not that one again
05:11:29 <dblhelix> *sigh*
05:11:47 <twb> giggle
05:11:51 <Cale> @pl \a b c d e -> a (a b c) (d e)
05:11:51 <lambdabot> (((.) .) .) . ((.) =<< (.))
05:11:52 <twb> dblhelix: I can't help myself.
05:12:01 <int-e> eek.
05:12:04 <Cale> heh, and it likes to use the Reader monad
05:12:08 <Cale> @pl \a b c d e -> a (a b c) (a d e)
05:12:17 <int-e> @type ((.) =<< (.))
05:12:18 <lambdabot> ap (flip . (flip .) . (((.) .) .) . (((.) .) .) . ap ((.) . (.)) id)
05:12:18 <lambdabot> id
05:12:18 <lambdabot> optimization suspended, use @pl-resume to continue.
05:12:18 <lambdabot> forall b a.
05:12:18 <lambdabot> (Monad ((->) (b -> a -> b))) =>
05:12:20 <lambdabot> (b -> a -> b) -> b -> a -> a -> b
05:12:27 <sieni> @pl (\x->x=(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))
05:12:28 <lambdabot> (line 1, column 7):
05:12:28 <lambdabot> unexpected "="
05:12:28 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
05:12:50 <sieni> argh
05:12:56 <joelr1> musasabi: ping
05:13:04 <sieni> @pl (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))
05:13:13 <int-e> @pl fib = 1:scanl (+) 1 fib
05:13:13 <lambdabot> ap ((==) . length) (length . id nub . flip (ap (zipWith . flip (flip . (
05:13:13 <lambdabot> mod .) . (+)) . length) (map ((`mod` 39) . ord))) [1..])
05:13:13 <lambdabot> optimization suspended, use @pl-resume to continue.
05:13:13 <lambdabot> fib = fix ((1 :) . scanl (+) 1)
05:13:51 <Cale> automatic obfuscation of code
05:14:19 <Cale> on simple things, it can often lend some insight though
05:14:19 * twb whimpers
05:16:31 <Cale> It should perhaps use the ghc api. Currently it's using its own Haskell parser which isn't quite complete.
05:16:58 <Cale> and you could probably do things like make sure that the transformations are at least type-safe :)
05:17:17 <int-e> @pl \x -> x x
05:17:17 <lambdabot> join id
05:19:10 <triplah> is there some kinda of show function for ghci?
05:19:19 <triplah> ie, i need to show all possible combinations of two strings
05:19:40 <twb> Haskell doesn't do docstring, right?
05:19:54 <triplah> twb = the lisper?
05:19:59 <triplah> LAMP twb ?
05:20:10 <twb> Yeah
05:20:15 <triplah> heh cool
05:20:29 <triplah> you gave me the long long tute session about lisp / scheme
05:20:37 <twb> No worries.
05:20:39 <triplah> i got 9/10 for that assignment btw :)
05:20:41 <triplah> cheers
05:21:19 <jethr0> @all-dict LAMP
05:21:21 <lambdabot> *** "Lamp" gcide "The Collaborative International Dictionary of English v.
05:21:21 <lambdabot> 0.48"
05:21:21 <lambdabot> Lamp \Lamp\ (l[a^]mp), n. [OE. (with excrescent p), fr. F. lame,
05:21:21 <lambdabot>  L. lamina. See {Lamina}.]
05:21:21 <lambdabot>  A thin plate or lamina. [Obs.] --Chaucer.
05:21:23 <lambdabot> [133 @more lines]
05:21:27 <Cale> twb: docstring?
05:21:31 <jethr0> *grr*
05:21:37 <twb> jethr0: LAMP = linux + apache + mysql + php/perl/python.
05:21:41 <twb> jethr0: http://livelamp.org
05:21:54 <jethr0> ok, i knew that... but what does "LAMP twb?" mean then?
05:22:05 <twb> jethr0: I build http://livelamp.org
05:22:08 <Cale> twb: have you seen haddock? Is that somewhat similar?
05:22:10 <jethr0> ah, ok
05:22:17 <twb> Cale: documentation attached to a function that is accessible from the REPL.
05:22:24 <Cale> oh, no
05:22:28 <Cale> there's nothing of that sort
05:22:35 <triplah> there is :t
05:22:39 <twb> Cale: e.g. "documentation id" would print "this returns the identity of its argument" or similar.
05:22:43 <Cale> yeah, there's :t and :info
05:22:50 <triplah> Prelude> :t id
05:22:50 <triplah> id :: a -> a
05:22:51 * twb tries :info
05:22:53 <lisppaste2> tic pasted "Valid string syntax?" at http://paste.lisp.org/display/14190
05:23:00 <tic> good bot!
05:23:11 <triplah> @type id
05:23:12 <lambdabot> forall a. a -> a
05:23:13 <twb> How is :info different from :type?
05:23:16 <Cale> but this information is generated entirely from the code
05:23:23 <Cale> oh, for functions it's probably not
05:23:25 <triplah> info seems to say where the function is from
05:23:32 <twb> Ah.
05:23:36 <triplah> @info minimumBy
05:23:37 <lambdabot> Unknown command, try @listcommands.
05:23:54 <triplah> Prelude> :info Data.List.minimumBy
05:23:54 <triplah> minimumBy :: (a -> a -> Ordering) -> [a] -> a
05:23:54 <triplah>         -- Imported from Data.List
05:24:00 <triplah> boo, i ave to import it any
05:24:08 <Cale> Prelude> :info Maybe
05:24:09 <triplah> seems like you need to know where it comes from anyway
05:24:09 <Cale> data Maybe a = Nothing | Just a         -- Imported from Data.Maybe
05:24:14 <Cale> ... long list of instances
05:24:37 <triplah> @type Just a
05:24:38 <lambdabot> Not in scope: `a'
05:24:45 <triplah> @type Just
05:24:46 <lambdabot> forall a. a -> Maybe a
05:24:46 <Cale> @type Just 5
05:24:48 <lambdabot> forall a. (Num a) => Maybe a
05:25:01 <tic> Anyone knows about my string syntax question?
05:25:14 <Cale> tic: looking...
05:25:46 <jethr0> tic: what was your question?
05:25:55 <tic> jethr0, the lispbot pasted it.
05:25:55 <Cale> tic: that seems fine
05:25:59 <tic> Cale, nice! thanks.
05:26:08 <tic> Trying to work out an embedded language for writing documents. :)
05:26:12 <Cale> with something = 5, I get ws = ["Foo","barMeow","yada","yada","gnorkf5and","this","continuesto","the","end","of","this","string"]
05:26:56 <shapr> kzm: hiya
05:26:57 <tic> heh, completely forgot to simply paste it into a file and run it. d'oh. Thanks :)
05:27:03 <kzm> hi shapr
05:27:06 <tic> Cale, great!
05:27:14 <kzm> I was just leaving, really.
05:27:23 <shapr> Ok, have fun!
05:27:59 <kzm> I've been playing with the \bot, but not in this channel.
05:28:05 <shapr> emacs seems to crash when a buffer has more than eighty thousand lines. What's up with that?
05:28:07 <kzm> Try #flippi: @seen 
05:28:25 <kzm> strange, emacs used to be a good choice for binary files.
05:28:34 <bojohan> shapr: "seems to" crash, eh?
05:28:38 <twb> OK, so how do I compile to binary code?
05:28:52 <shapr> bojohan: How about segfaults when buffers get too big?
05:29:05 <bojohan> xemacs?
05:29:10 <shapr> Nope, gnumacs.
05:29:17 <shapr> xemacs worked fine with huge buffers.
05:29:19 * Cale attempts to load FreeNode-#haskell.log in emacs
05:29:21 <bojohan> which version?
05:29:32 <Cale> took a while, but loaded fine
05:29:35 <shapr> Whatever's in debian/unstable.
05:29:43 <bojohan> M-x version
05:29:56 <shapr> GNU Emacs 21.4.1 (i486-pc-linux-gnu, X toolkit, Xaw3d scroll bars) of 2005-10-03 on trouble, modified by Debian
05:30:03 <Cale> nearly 1000000 lines there
05:30:05 <triplah> twb: ghc compiles to machine code
05:30:13 <bojohan> and how huge?
05:30:20 <triplah> twb: or C if you'd prefer
05:30:21 <jethr0> twb: ghc --make example
05:30:29 <jethr0> with your file "example.hs"
05:30:35 <twb> jethr0: righto.
05:30:50 <shapr> I've had segfaults with one hundred thousand lines, one hundred twenty five thousand lines, around that size.
05:31:16 <Cale> twb: the flags look somewhat like gcc's flags, (apart from --make) you can also do:  ghc -o example example.hs
05:31:18 <shapr> The examples are #haskell log files and ange-ftp verbose message buffers.
05:31:20 <bojohan> i'm not really interested in the number of *lines*
05:31:27 <Cale> but this won't have the nice dependency tracking
05:31:46 <shapr> Oh, I don't know the full size.
05:32:12 <Cale> -rw-r--r--    1 cale     cale     71997751 2005-12-01 08:31 /home/cale/.xchat2/xchatlogs/FreeNode-#haskell.log
05:32:17 <Cale> that loads fine for me
05:32:37 <bojohan> max buffer size in emacs 21 is 128 MB
05:32:44 <bojohan> 256 in emacs 22
05:32:55 <bojohan> 1GB in xemacs, i think
05:33:04 <Cale> GNU Emacs 21.4.1
05:33:22 <bojohan> emacs still shouldn't crash though
05:33:29 <Cale> this is the Debian package, I'm not sure if they've done anything with it
05:33:40 <shapr> Cale: Is that true for erc-log-mode too? That's one place where I have problems, when I'm appending to a large history.
05:33:50 <Cale> I don't use erc
05:33:54 <shapr> oh
05:34:32 <Cale> hehe, as you might be able to tell from the ls output there, I use xchat :)
05:35:03 <triplah> uh oh, big storm coming..... big haskell assignment due
05:35:11 <triplah> which takes priority!
05:35:15 <Cale> what's the assignment?
05:35:20 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
05:35:27 <triplah> my first haskell assignment
05:35:33 <triplah> have done two classes on haskell
05:35:50 <triplah> I'm up to task 6
05:35:51 <Cale> ah, we had someone in here asking about that alignment problem
05:35:54 <bojohan> i think emacs may crash if the undo list grows out of control. emacs 22 takes measures to prevent this.
05:35:57 <Cale> was that you?
05:36:03 <triplah> probably was
05:36:15 <triplah> i've been so busy with other assignments i've been stuck at this for a day or two
05:36:29 <jethr0> yep, looks like some work.
05:36:58 * shapr wants Yi
05:37:10 <triplah> the align example output in the criteria seems to take two strings of length 2 and return strings from length 2 to 4
05:37:13 <triplah> which is confusing me
05:37:14 <triplah> :)
05:38:41 <Cale> triplah: I found that reading the initial part of the assignment caused that to make sense :)
05:39:08 <triplah> uh oh
05:39:11 * triplah blushes
05:39:15 <triplah> time to reread
05:39:20 <bojohan> it would be nice to have a working ghci in Ubuntu/amd64, btw
05:39:45 <Cale> in general, alignments of strings of length n and m respectively will be from length max {n,m} to length n + m
05:40:16 <Cale> bojohan: doesn't the ordinary one work there?
05:40:51 <kzm> shapr, Cale , I must go.  I'm leaving kbot running in #flippi, #haskell-blah, #haskell-overflow. Feel free to tell it to @-quit if it becomes an annoyance (it has the usual admins, incl. you)
05:40:52 <triplah> ahh
05:40:54 <triplah> hmm i see
05:40:56 <Cale> Or is amd64 binary-incompatible?
05:41:08 <shapr> kzm: Does it have cool new code?
05:41:28 <kzm> shapr: no.  Just a mildly improved @seen command.
05:41:54 <triplah> @seen Haskell Curry
05:41:54 <lambdabot> I haven't seen Haskell.
05:41:58 <triplah> lies!
05:42:02 <CosmicRay> hah
05:42:15 <CosmicRay> @wiki MegaMonad
05:42:15 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
05:42:23 <CosmicRay> this might be the time to mention that URL again
05:42:35 <CosmicRay> maybe I should get megamonad fired up for the holidays, for old times' sake...
05:42:38 <CosmicRay> :-)
05:43:09 <bojohan> well, the cpu can execute 32 bit code, but i'm using the 64 bit version of ubuntu.
05:43:29 <CosmicRay> bojohan: my understanding is that ghc 6.4.1 now has this
05:43:38 <CosmicRay> bojohan: does it work in the packages from debian?
05:43:44 <twb> Bah.  Schönfinkel was first.
05:43:58 <twb> Your language should be called Moses!
05:44:04 <bojohan> yes, but 6.4.1 isn't packaged afaict
05:44:19 <CosmicRay> bojohan: it is packaged
05:44:45 <CosmicRay> since October 15
05:45:13 <triplah> Moses was the first to do currying? :P
05:45:19 <bojohan> well, i see a "ghc6" package and a "ghc-cvs" package
05:45:25 <CosmicRay> triplah: hehe
05:45:29 <CosmicRay> bojohan: you want ghc6
05:45:30 <twb> I think ghc-cvs is well old.
05:45:35 <bojohan> "ghc6" is ghc-6.4 (not 6.4.1)
05:45:36 <CosmicRay> ghc-cvs is outdated
05:45:42 <CosmicRay> bojohan: where exactly are you looking?
05:45:56 <CosmicRay> bojohan: if you loko at packages.debian.org or packages.qa.debian.org, or ftp.debian.org, you'll see ghc 6.4.1.
05:46:04 <bojohan> ubuntu
05:46:05 <CosmicRay> [2005-10-15] Accepted 6.4.1-1 in unstable (low) (Ian Lynagh (wibble))
05:46:14 <CosmicRay> <CosmicRay> bojohan: does it work in the packages from debian?
05:46:22 <CosmicRay> I was not ;-)
05:46:48 <bojohan> likely
05:47:17 <CosmicRay> it's even been built for amd64.
05:47:22 <CosmicRay> http://amd64.debian.net/debian/pool/main/g/ghc6/
05:47:28 <CosmicRay> try the .deb and see.
05:47:45 <triplah> it builds fine on amd64
05:47:46 <CosmicRay> heh, there was just a "first post" on cafe.
05:47:55 <bojohan> i've compiled 6.4.1 myself so it's not really a problem (for me). it would still be nice if it was in ubuntu.
05:47:58 <triplah> cabal did fine too
05:48:21 <CosmicRay> bojohan: well then, you need to ask the ubuntu folks why the heck they haven't pulled it from debian.
05:50:09 <triplah> enable deb repo's ?
05:52:36 <twb> Wow, the binaries ghc generates are big.
05:52:57 <Speck> yup
05:53:02 <bojohan> ok, i was hoping that Igloo was ubuntu people...
05:53:08 <triplah> compared to C or compared to lisp? :P
05:53:13 <twb> Does it throw out functions it doesn't use?
05:53:17 <twb> triplah: compared to Scheme.
05:53:17 <Speck> twb: you should see the binaries jhc makes
05:53:29 <Speck> twb: no, it doesn't do a lot of dead code elimination that it could
05:53:32 <triplah> twb: which scheme compiler are you using?
05:53:36 <twb> triplah: csc
05:53:39 <triplah> ahh
05:53:40 <twb> triplah: Chicken
05:53:42 <sylvan> try nhc
05:53:43 <triplah> yep
05:53:51 <twb> nhc isn't in my Debian archive.
05:54:03 <triplah> http://www.cs.york.ac.uk/fp/nhc98/
05:54:08 <triplah> its in portage
05:54:47 <twb> Hmm, packages.debian.org lists it...
05:55:06 * Cale does triplah's assignment for fun
05:55:24 <twb> WTF?  Why isn't it listed in aptitude?
05:55:28 <triplah> Cale: not fair! :(
05:55:35 <twb> Ah, it's only in stable, not unstable.
05:58:03 <twb> What's the current release version of nhc98?
05:58:08 <araujo> Morning!
05:58:11 <shapr> jiihaa!
05:58:58 <Cale> triplah: have you guys studied data types at all?
05:59:10 <Cale> (user defined ones)
05:59:14 <twb> 00:44 <triplah> Moses was the first to do currying? :P
05:59:16 <triplah> Cale: yep
05:59:20 <twb> triplah: that's what Wikipedia says.
05:59:26 <triplah> twb: ahh ok :D
05:59:36 <triplah> Cale: in the context of ADT's and modules
05:59:38 <Cale> data Cost = Cost { match :: Integer, mismatch :: Integer, space :: Integer }
05:59:38 <jethr0> twb: might be a version thing stable/unstable/testing
05:59:39 <Cale>  -- this would make the type signatures nicer :)
06:00:03 <CosmicRay> shapr!
06:00:06 <twb> jethr0: 00:55 <twb> Ah, it's only in stable, not unstable.
06:00:12 <jethr0> yup
06:00:12 <CosmicRay> twb: nhc98 is in debian.
06:00:19 <CosmicRay> nhc98 is not very portable.
06:00:20 <shapr> CosmicRay!
06:00:20 <twb> Which is a bit weird.
06:00:29 <CosmicRay> shapr: tried pulling the new repos yet? ;-)
06:00:35 <shapr> CosmicRay: Yes, already made some patches too.
06:00:39 <CosmicRay> cool ;-)
06:00:41 <shapr> Haven't sent them though.
06:00:53 <CosmicRay> well, you'll still have to send diffs the old way for now
06:00:54 <shapr> I made a README.first for the ghc repo, the readme is wrong.
06:01:00 <CosmicRay> ahh.
06:01:15 <triplah> Cale: yeah it would, but i think for the purposes of the assignment we are more learning haskell's power for dynamic programming with lazy evaluation
06:01:16 <CosmicRay> you may want to post that to a list or something
06:01:18 <shapr> It should talk about autoconf/autoreconf but it only mentions ./configure && make 
06:01:26 <CosmicRay> I don't know how jaffacake wants to handle those right now
06:01:33 <Cale> triplah: yeah
06:01:34 <CosmicRay> I can see people wanting to darcs send things right away
06:01:38 <shapr> like me!
06:01:42 <CosmicRay> :-)
06:01:52 <triplah> http://www.cs.york.ac.uk/fp/nhc98/
06:01:54 <triplah> oops
06:01:56 <triplah> :\
06:01:59 <Cale> triplah: that's essentially what arrays are for in Haskell :)
06:02:06 <triplah> damn extra mouse buttons i never use :)
06:02:09 <Cale> hehe
06:02:19 <triplah> Cale: for using monads with I/O ?
06:02:21 <shapr> I could just mail my darcs patches to ghc-users.
06:02:25 <triplah> or something to that effect
06:02:27 <Cale> triplah: for dynamic programming
06:02:28 <ADEpt> SamB: hi
06:02:42 <triplah> Cale: ahh ok. thought you meant lazy evaulation in general
06:02:47 <triplah> yes, its awesome
06:02:52 <triplah> and purely functional
06:02:59 <Cale> You use arrays to cache the results of functions and keep them live so that they can be shared with other computations.
06:03:01 <triplah> \o/
06:03:17 <twb> Cale: lispers call that memoization :-)
06:03:24 <Cale> twb: yes
06:03:28 <Cale> we do too :)
06:03:56 <shapr> Hey, I really want five TMR articles! Anyone have something they can publish?
06:04:07 <triplah> haskell has call with current continuation?
06:04:14 <araujo> mm.. wait a minute.... isn't twb the same guy who was saying '\' is a stupid name for lambda?
06:04:17 <shapr> SamB is working on one, I've got one, kzm might write one, who else?
06:04:20 <twb> araujo: yes.
06:04:22 * araujo giggles
06:04:25 <Cale> triplah: in the Cont monad, I think
06:04:36 <triplah> imho \ is better than "lambda"
06:04:44 <shapr> I like \ for lambda.
06:04:53 <twb> I'd rather have lambda.
06:04:54 <triplah> almost as good as the unicode symbol for lambda
06:04:54 <Cale> I like λ for lambda
06:04:55 <triplah> :P
06:04:57 <araujo> \ is the sweetier thing for lambda ever invented.
06:05:01 <twb> Cale: yes, ideally.
06:05:08 <shapr> twb: personal choice and all that
06:05:14 <triplah> drScheme actually accespts the unicode lambda symbol as vaild syntax
06:05:21 <triplah> accepts*
06:05:22 <araujo>  /join #λ
06:05:25 <shapr> heh
06:05:25 <triplah> vaild*
06:05:28 <twb> You mathematician types are afraid of a few extra characters.  You're as bad as Perl people!
06:05:28 <triplah> dear lord :)
06:05:37 <Cale> If it was actually λ for lambda, I'd change the keybinding for greek mode.
06:05:39 <shapr> twb: dude, I am *not* a mathematician type.
06:05:49 <araujo> twb, me neither
06:06:05 <twb> Next you'll tell me you're not programmers either :P
06:06:06 <shapr> twb: I am a self-employed, self-taught contract programmer. No Computer Science classes, no math classes, don't even accuse me of having visited an ivory tower.
06:06:09 * Cale sings the Greek alphabet song: αβγδε!
06:06:19 <araujo> haha
06:06:38 <dblhelix> twb: we like to think of ourselves as artists ;)
06:06:44 <Cale> "eta theta" has a nice ring to it
06:06:46 <shapr> Haskell lets me write powerful software quickly, it's good for my business.
06:06:52 <twb> dblhelix: Don't get me started on bloody PG!
06:07:00 <dblhelix> Cale: what about "phi chi psi"?
06:07:00 <Cale> @index callCC
06:07:01 <lambdabot> Control.Monad.Cont
06:07:11 <Cale> dblhelix: yeah
06:07:35 <twb> Cale: are they first-class? ;-)
06:07:41 * triplah tries to find the haskell poetry examples from last night
06:07:43 <Cale> twb: we wouldn't want them to be
06:08:06 <shapr> twb: If you like verbosity, there's always #cobol
06:08:11 <araujo> haha
06:08:11 <triplah> huh? isnt a callCC first class by definitiaion?
06:08:14 <Cale> first class continuations break referential transparency horribly
06:08:19 <Cale> no
06:08:19 <triplah> a function needing one argument?
06:08:33 <triplah> which is another function needing one argument
06:08:35 <triplah> oh
06:08:38 <triplah> hmm :)
06:08:39 <Cale> @type Control.Monad.Cont.callCC
06:08:40 <lambdabot> forall (m :: * -> *) a b.
06:08:40 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
06:08:40 <lambdabot> ((a -> m b) -> m a) -> m a
06:08:41 <triplah> wait, thats in scheme
06:09:16 <Cale> ContT is insane :)
06:09:42 <Cale> lets you add support for continuations to other monads
06:10:34 <Cale> Someone should really merge ContT and ListT DoneRight from the wiki into fptools
06:10:35 <twb> Is there a unicode mode for hugs or ghc so I can type e.g. → instead of -> and λ instead of \?
06:10:45 <triplah_> we love cable bumpers :)
06:10:47 <Cale> twb: I don't think so
06:10:52 <twb> That would be nice.
06:11:03 <Cale> twb: and currently ghc doesn't even support unicode chars in source files
06:11:08 <twb> Otherwise I have to do it at the display level, which messes up indentation for everyone else.
06:11:16 <Cale> even though it's supposed to by the standard :)
06:12:00 <twb> Cale: surely you can just compile ghc in a compliant compiler, then? ;-)
06:12:40 <Cale> twb: I think the problem has to do with the parser generator which ghc uses
06:12:46 <Cale> er
06:12:50 <Cale> lexer generator
06:14:11 <dcoutts_> hia xerox
06:14:38 <Cale> I think that's Alex. So perhaps just fixing alex to generate lexers which can handle unicode would be enough.
06:14:58 <dcoutts_> Cale, yeah, though I think it'd be a bit tricky
06:15:18 <dcoutts_> I looked at it a little before
06:15:38 <triplah__> grr
06:15:43 <triplah__> my brother keeps bumping my cable
06:16:01 <triplah__> damn him and his brand new G5 powermac that just arrives :(
06:16:04 * twb giggles at the double entendre
06:16:06 <triplah__> arrived*
06:16:29 <Cale> ooh, nice. I loved my G5 when I was at McMaster.
06:16:51 <twb> Bah.  G5s suck compared to G4, don't they?
06:16:59 <Cale> with its nice 23" Cinema HD display, and gigabit ethernet goodness
06:17:20 <twb> Gig ethernet is pretty standard for workstations these days.
06:17:28 <Cale> twb: well, code will always run faster on the G5, but the architecture is somewhat dumber
06:17:46 <twb> dumber = cleaner, or dumber = uglier?
06:18:01 <xerox> Hello!
06:18:07 <twb> xerox: huzzah!
06:18:33 <triplah__> dual core ppc64, i wouldnt be complaining
06:18:40 <twb> I would.
06:18:43 <Cale> dumber in that it assumes that code generators are terrible
06:18:50 <twb> 64bit PPC sucks for Linux.
06:19:00 <triplah__> yeah this is true.
06:19:11 <triplah__> but he wont install linux on it
06:19:18 <xerox> R1ch people there :-)
06:19:18 <triplah__> well wont get rid of osx anyway
06:19:26 <Cale> There's much less opportunity for being smart with pipelining on the G5.
06:19:27 <twb> If you're gonna use OS X, why not just use BSD in the first place?
06:19:32 <bojohan> the lisp machines had real greek lambdas
06:19:41 <triplah__> he still has his linux p4 
06:19:49 <Cale> bojohan: my keyboard does too
06:19:56 <triplah__> he is a web developer and designer
06:19:59 <bojohan> and you could write your emacs key bindings in greek too
06:20:01 <bojohan> http://www.dd.chalmers.se/~bojohan/img/keys.png
06:20:01 <triplah__> photoshop doesnt run on bsd
06:20:02 <triplah__> :P
06:20:05 <twb> triplah__: the poor, stupid fool.
06:20:13 <triplah__> twb: do what makes you money
06:20:14 <Cale> bojohan: you still can, afaict
06:20:18 <triplah__> and if you are good at all the better
06:20:19 <triplah__> :)
06:20:30 <triplah__> at it*
06:20:30 <xerox> bojohan: archeological findings of the time? :-)
06:21:04 <twb> triplah__: by that argument I should be using Java.
06:21:08 <Cale> I've actually been preferring the Gimp to Photoshop lately. Still missing a few things, but there are features which the Gimp has over PS too.
06:21:24 <twb> gimp and photoshop are bitmap editors!  Yuk!
06:21:29 <Cale> If you're a print designer, the Gimp is kinda useless.
06:21:29 <triplah__> twb: no, i said DO what makes you money.
06:21:35 <twb> Long live inkscape!
06:21:37 <Cale> Inkscape is nice
06:21:38 <twb> Long live Cairo!
06:21:45 * xerox boings happily
06:21:58 <twb> triplah__: do my hands?
06:22:02 <Cale> xerox wrote the cairo binding for Haskell
06:22:10 <triplah__> twb: i dont wanna go there
06:22:11 <triplah__> :)
06:22:12 <xerox> That was fun :-)
06:22:31 <Cale> xerox: want to help with HaskEFL? :)
06:22:41 <twb> xerox: is it a full binding, or just stupid static PNG bindings?
06:22:43 <triplah__> the truth is that using linux then using OSX doesnt make you any less enlightened
06:22:54 <twb> Cale: E17 foundation libs?
06:22:59 <Cale> twb: yeah
06:23:04 <twb> Ew.
06:23:05 <xerox> twb: it is as full as I could 'fullify' it.. it has the GTK layer too.
06:23:07 * twb uses Ratpoison.
06:23:11 <triplah__> hmm
06:23:14 <triplah__>  i use e17
06:23:17 <triplah__> but suck at haskell
06:23:18 <triplah__> :)
06:23:18 <Cale> twb: The EFL are pretty nice
06:23:27 <twb> Cale: overhead!
06:23:37 <xerox> ...
06:23:38 <Cale> overhead?
06:23:38 <triplah__> efl runs fast on low spec machines
06:23:38 <twb> Screen + Emacs, or X11 + Ratpoison + Emacs.
06:23:43 <triplah__> maybe not like rat poison
06:23:44 <Cale> They're pretty efficient at what they do
06:23:46 <triplah__> but still nicely
06:24:05 <twb> I used to try to compile e17, just for the challenge!
06:24:11 <Cale> hehe
06:24:13 <twb> It was riddled with gccisms.
06:24:16 <xerox> Q:      What's a light-year?
06:24:16 <xerox> A:      One-third less calories than a regular year.
06:24:18 <triplah__> twb: now i know why you diss OSX, you clearly wouldnt know good design if it spat in your face :P
06:24:26 <twb> triplah__: bah.
06:24:29 <Cale> it's not that hard to compile anymore
06:24:36 <twb> triplah__: I bet you think obscured windows and desktop icons are good design.
06:24:37 <Cale> though still not easy
06:25:02 <Cale> I can't get by without obscured windows.
06:25:07 <triplah__> twb: nope, i use e17 and terms. definatly no desktop bullshit
06:25:09 <twb> Cale: granted, that *was* some time ago.  Like, six months before the first tarball.
06:25:11 <jlouis> Oh, I got more patches by ADEpt and SamB for Conjure
06:25:14 <triplah__> doesnt mean what i DO use needs to look bad
06:25:14 <triplah__> :P
06:25:19 <jlouis> havn't got so much time to hack it yet ;)
06:25:28 <twb> triplah__: *obscurable* windows?
06:25:35 <Cale> I'm running Gnome + Enlightenment 16
06:26:08 <triplah__> twb: shading? yes.
06:26:11 <jlouis> triplah__: where is enlightenment.org these days?
06:26:12 <takuan> is there some description to be found how typechecking proceeds in the current haskell compilers?
06:26:26 <twb> triplah__: I was talking about occlusion.
06:26:27 <Cale> enlightenment.sourceforge.net
06:26:36 <triplah__> jlouis: enlightenment.net.au i think. the dude who owned the domain went awol when they needed to renew the reg
06:26:45 <twb> Cale: surely http://enlightenment.org?
06:26:47 <Cale> because the domain expired and mandrake is away
06:26:47 <takuan> for example: why do some programs type checking succeeds ghc and not in hugs for example?
06:27:09 <Cale> www.enlightenment.org.au works
06:27:21 <takuan> sorry for interupting the enlightened discussion ;)
06:27:34 <triplah__> Topic for #edevelop: e.org is down, use enlightenment.sf.net instead.
06:27:51 <Cale> takuan: well, the source code for all the compilers is available, if you really want to get into it
06:28:04 <Cale> takuan: GHC implements a lot of extensions to the type system
06:28:14 <takuan> humz
06:28:14 <Cale> takuan: they're documented in the GHC user guide
06:28:20 <takuan> are they?
06:28:20 <twb> Haskell is all about the type system.
06:28:23 <Cale> yes
06:28:23 <takuan> i know
06:28:28 <xerox> @docs
06:28:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:28:35 <takuan> that's particularly interresting for my thesis
06:28:35 <takuan> \
06:28:37 <Cale> that's the library documentation
06:28:41 <xerox> Without "/libraries/index.html" it's the user guide I think.
06:30:15 <ADEpt> jlouis: hi
06:30:31 <ADEpt> jlouis: so, you got them? I have lots more pending :)
06:30:32 <dcoutts_> Cale, xerox, EFL?
06:30:42 <ADEpt> jlouis: tell me when I can 'darcs send'
06:31:14 <xerox> dcoutts, they are the Enlightenment Foundation Libraries, 5 years worth of coding to do some appealing things, it seems :-)
06:31:15 <Cale> dcoutts_: Enlightenment (dr17) Foundation Libraries
06:31:18 <takuan> we don't want uninitiated haskell programmers trying to code C++ style haskell
06:31:34 <Cale> http://www.enlightenment.org.au/Libraries/Documentation/
06:31:37 <takuan> they'll stop using haskell after a few hours
06:31:38 <twb> takuan: or vice versa
06:31:41 <xerox> takuan: I don't think it's possible to write C++ Haskell code at all.
06:31:45 <eivuokko> Huh
06:31:54 <Cale> actually, http://www.enlightenment.org.au/Libraries/Overview/
06:32:21 <xerox> Haskell is challenging to learn, but worth it :-)
06:32:33 <basti_> challenging? tss.
06:32:37 <triplah__> i'm having challeneges :P
06:32:41 <takuan> xerox: yup
06:32:46 <xerox> basti_: in some sense, at least.
06:32:46 <araujo> Anybody doing bindings in Haskell for dr17? :-)
06:32:47 <takuan> but that's what you try coming from c++
06:32:53 <xerox> basti_: that is, on the surface :-)
06:32:55 <basti_> xerox: its like a cancer.
06:33:03 <basti_> xerox: it's everywhere now ^^
06:33:05 <takuan> particularly when you try to overload + for example
06:33:13 <Cale> araujo: I'm starting on it
06:33:19 <twb> Has EFL even stabilised enough for bindings? ;-)
06:33:22 <Cale> twb: yeah
06:33:24 <araujo> Cale, really?, that's cool.
06:33:24 <triplah__> can you overload + using infix?
06:33:34 <araujo> Cale, do you already use E17?
06:33:36 <takuan> nah
06:33:40 <Cale> araujo: nope
06:33:47 <Cale> araujo: though it looks usable
06:33:47 <takuan> + is defined in Num
06:33:56 <triplah__> takuan: hmm ok
06:33:58 <lisppaste2> twb pasted "nhc = thttpt" at http://paste.lisp.org/display/14192
06:34:01 <araujo> Cale, oh ok, i wanted to aske you about its stability.
06:34:02 <takuan> so you should instantiate your datatype to be part of Num
06:34:04 <Cale> I could compile it and try it. I have all the libraried built.
06:34:12 <Cale> libraries*
06:34:17 <xerox> triplah__: + is infix
06:34:39 <triplah__> xerox: yep, i was just wondering if it was possible to overload it
06:34:46 <twb> Cale: what exactly is in EFL these days?
06:34:56 <takuan> triplah__: yes
06:35:02 <xerox> sure, hide it from the Prelude, and define your own version.  It's not a reccomandable thing to do, anyway.
06:35:07 <twb> Cale: a scripting language, a 2D graphics library, a NETWM API, and what?
06:35:15 <triplah__> evas ,ecore, ewl, esmart, edb, emotion
06:35:32 <triplah__> thats most of the libs
06:35:34 <twb> triplah__: yeah, but what functionality do they provide?
06:35:35 <takuan> also possible
06:35:43 <Cale> twb: imlib2, edb/eet (databases), evas (Canvas library), ecore (X11 abstraction),...
06:36:00 <Cale> etox (text layout)
06:36:16 <triplah__> emotion is  a whole bunch of xine stuff
06:36:18 <twb> text layout like TeX?
06:36:19 <Cale> edje (gui component signalling abstraction)
06:36:38 <Cale> twb: flowing text around obstructions and such
06:36:47 <twb> Ah, like in SVG.
06:36:57 <triplah__> pretty much
06:37:20 <Cale> embryo, an embeddable scripting language, used in edje components
06:37:40 <Cale> ewl, a widget library built on top of edje
06:37:45 <triplah__> ok bed time
06:37:46 * triplah__ runs
06:37:50 <triplah__> gnite
06:37:54 <twb> Bye.
06:38:00 <twb> I hope you catch the bed.
06:38:04 <Cale> emotion, a video library
06:38:06 <triplah__> hehe
06:38:09 <triplah__> too tired
06:38:26 <Cale> basically a nice binding to xine
06:38:54 <jethr0> n9
06:38:55 <jethr0> n8
06:38:59 <Cale> there's epsilon, which is a Freedesktop.org compliant thumbnailing library
06:39:01 <jethr0> @localtime triplah__
06:39:46 <xerox> Cale: do you have firefox 1.5?
06:39:54 <Cale> xerox: yeah
06:39:58 <xerox> http://www.croczilla.com/svg/samples/svgtetris/svgtetris.svg !
06:40:19 <Cale> I think I was playing that the other day, let me see.
06:40:25 <xerox> Uh.
06:41:04 <Cale> oh, not this version
06:41:58 <twb> Doesn't work in w3m-el or galeon :-(
06:42:13 <xerox> Indeed.
06:43:10 <jethr0> and then i thought w3m-el was a viable gui browser *pfft*
06:43:23 <twb> jethr0: thttpt
06:44:12 <jethr0> ??
06:44:21 <twb> thttpt = :P
06:44:54 * jethr0 nods slowly and assuringly
06:45:06 <twb> assuringly or reassuringly?
06:45:30 <jethr0> the latter...
06:45:32 <jlouis> ADEpt: just darcs send them. They are awfully cool. 
06:46:21 <jethr0> twb: so what does thttpt stand for?
06:46:21 <sylvan> xerox, uh.. isn't svg some sort of graphics format? What kind of black magic is at work here?
06:46:33 <twb> jethr0: it's onomatopoeic
06:46:49 <twb> sylvan: it's programmable with ECMAscript.
06:47:10 <twb> sylvan: you can also use CSS to change parts of it.
06:47:46 <twb> I used to have SVG graphs on my web page that would be black-on-white, but if you change the display style to white-on-black they would change along with the surrounding text.  It was awesome.
06:48:07 <Cale> xerox: eventually the controls are too stiff to play correctly
06:48:21 <jethr0> twb: you make funny noises while laughing ;-)
06:48:25 <xerox> Yeah.
06:48:27 <sylvan> cool, didn't know that
06:48:39 * Cale used to play tetrinet a lot
06:49:21 <jlouis> ADEpt: homework is taking all my ``spare'' time at the moment, unfortunately
06:50:09 <takuan> mmm
06:50:20 <takuan> what I wanted to know is how type inference works in haskell
06:50:36 <xerox> You know that shirt...
06:50:36 <twb> takuan: the same as in SML!
06:50:43 <xerox> HM..
06:51:16 <takuan> twb: and how does it work in SML? 
06:51:23 <twb> takuan: the same as in Haskell!
06:51:37 <jlouis> takuan: look up Hindley-Milner type inference
06:51:43 <takuan> is that it?
06:51:46 * twb digs out his pretty-symbols mode.
06:51:48 <jlouis> more or less
06:52:25 <jlouis> Haskell allows some extra stuff, which is not decideable by HM, but you can always take what the programmer type annotated and type-check that
06:52:39 <jlouis> ... which is, more or less, what Haskell does when you have extensions
06:54:46 <dblhelix> @seen kosmikus
06:54:47 <lambdabot> kosmikus is in #gentoo-haskell and #haskell. I don't know when kosmikus
06:54:47 <lambdabot> last spoke.
06:56:32 <ADEpt> jlouis: thing is, if I just darcs send, you will get all the old ones for, I think, the third time
06:59:47 <ADEpt> jlouis: but if this ok with you ....
07:06:04 <ADEpt> jlouis: is this ok with you? :)
07:07:23 <ADEpt> jlouis: ah! you applied them all. cool.
07:07:30 * ADEpt darcs-sends
07:16:08 <Dave114> one more newbie question: how can I add a tab to a string? (strings don't seem to auto-interpret "\t" as a tab here)
07:16:41 <ADEpt> jlouis: btw, there is bug in nextPiece, which we havent caught yet.
07:17:02 <ADEpt> Dave114: should be "\t"
07:17:09 * ADEpt is off to see the dentist
07:17:11 <ProfTeggy> Dave114: '\t' is the TAB character in Haskell
07:17:53 <ProfTeggy> Dave114: putStr "foo \t bar"
07:18:07 <ProfTeggy> @eval putStr "foo \t bar"
07:18:08 <lambdabot> No IO allowed
07:18:12 <ProfTeggy> Uh ;-)
07:19:33 <xerox> > show "\t" -- maybe?
07:19:34 <lambdabot> "\"\\t\""
07:19:41 <xerox> Nahw :)
07:19:48 <ProfTeggy> xerox, ;-)
07:20:15 <ProfTeggy> I/O has to be experience at your local ghci prompt it seems ;-)
07:20:18 <ProfTeggy> +d
07:20:40 <ProfTeggy> How appropriate for a purely functional language.
07:20:44 <xerox> Wasn't someone working for a safe IO Monad for lambdabot?
07:20:48 <Dave114> ProfTeggy, with putStr the tab is interpreted appropriately, but I'm trying to get my function to return a string in which the tab is interpreted, and in that context it doesn't seem to be working
07:21:11 <ProfTeggy> Dave114: a TAB is like any other character
07:21:36 <ProfTeggy> If you want it to do special things, your functions has to implement this "magic"
07:22:27 <ProfTeggy> Here is a function that returns a tab:
07:22:31 <Dave114> from my terminal: "abc" ++ [ '\t' ] ++ "def" produces "abc\tdef" rather than a tab in between the abc and def
07:22:34 <ProfTeggy> tab = "\t"
07:22:48 <ProfTeggy> Dave114, you need to putStr that string
07:22:57 <ProfTeggy> putStr does the magic I referred to above
07:23:13 <ProfTeggy> putStr ("abc" ++ ... ++ "def")
07:23:28 <Dave114> but doesn't putStr actually handle IO rather than just return the string from the function?
07:23:40 <ProfTeggy> Dave114, exacly
07:23:42 <ProfTeggy> +t
07:23:45 <araujo> putStr returns an action.
07:24:08 <ProfTeggy> Dave114: the "\t" is like a directive to putStr to output a TAB
07:25:01 <ProfTeggy> If your functions embed '\t' in a string, putStr will do what you expect
07:25:05 <twb> Do three or more periods in a row have special significance in haskell?
07:25:23 <ProfTeggy> twb, no but .. has
07:25:30 <twb> Good-o.
07:27:05 <Cale> .. is used in sequences, ... is a syntax error
07:28:40 <Dave114> ProfTeggy, isn't a tab an ASCII character (assuming that we're not working with unicode), whereas "\" and "t" would be two different ASCII chars.  It still seems to me that haskell is missing something here
07:29:01 <xerox> > let :... = id in :... 2
07:29:02 <lambdabot>  parse error on input `:...'
07:29:09 <xerox> > let :...: = id in :...: 2
07:29:10 <lambdabot>  parse error on input `:...:'
07:29:13 <xerox> Grin.
07:29:37 <ProfTeggy> Dave114: '\t' is translated into the character with ASCII code 8, yes
07:29:46 <twb> Is it possible for .. to exist outside of square brackets?
07:29:53 <xerox> > chr 8
07:29:54 <lambdabot> '\b'
07:29:57 <ProfTeggy> So "\t" and "\\" ++ "t" are different things
07:29:59 <twb> Nevermind, that would take too long to parse.
07:30:12 <ProfTeggy> But I guess you don't refer to this difference
07:30:15 <xerox> > asc '\t'
07:30:16 <lambdabot>  Not in scope: `asc'
07:30:20 <xerox> > ord '\t'
07:30:21 <lambdabot> 9
07:30:26 <xerox> chr 9
07:30:26 <ProfTeggy> Oh, 9
07:33:36 <twb> What's the regexp for identifiers?
07:33:44 <twb> [a-z][a-zA-Z0-9']* 
07:34:05 <ulfdoz> Underscore and other voodoo, you miss.
07:34:35 <twb> More importantly, are apostrophes ever used to represent ‵, or only ′?
07:34:56 <twb> (backwards prime / prime)
07:36:49 <tic> blarf (x:xs) = let x' = x*2 in x':blarf xs
07:36:53 <tic> for example
07:36:56 <xerox> It's like 'prime' I think.
07:37:02 <twb> Good-o.
07:38:47 <twb> http://twb.ath.cx/~twb/src/my-elisp/pretty.el
07:39:26 <xerox> This sounds way cool.
07:39:37 <twb> A working but more ugly version is
07:39:39 <twb> http://twb.ath.cx/~twb/src/my-elisp/pretty-symbols.el
07:39:49 <twb> It looks fucking awesome when in use.
07:40:09 <xerox> Does it need any kind of configuration?
07:40:16 <twb> Um,  no.
07:40:25 <twb> But you can't turn it off without killing the buffer ^_^;
07:40:30 <xerox> I'll try it.  That's the coolest thing of this week.
07:40:39 <twb> M-x pretty-symbols-mode should Just Work once it's loaded.
07:40:59 <twb> What does !! do in haskell?
07:41:06 <xerox> It takes the nth element
07:41:06 <twb> @t !!
07:41:07 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
07:41:07 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
07:41:14 <xerox> > [1..10] !! 0
07:41:15 <lambdabot> 1
07:41:21 <twb> xerox: Oh, so it's like nth in lisp :-)
07:41:22 <xerox> > [] !! 0
07:41:23 <lambdabot> Add a type signature
07:41:27 <xerox> > [] !! 0 :: Int
07:41:28 <lambdabot> Prelude.(!!): index too large
07:41:31 <twb> I can see how these names are more logical :-)
07:41:44 <xerox> Cough.
07:41:59 * xerox loads an .hs
07:43:03 <araujo> twb, are you already convinced that Haskell is 'The Language'?
07:43:05 <twb> araujo: nope
07:43:05 * araujo giggles
07:43:31 <xerox> Hmm, doesn't work here, hmpf.
07:44:44 <araujo> twb, resistence is futile
07:45:11 <twb> Is spelling also futile?
07:45:35 <xerox> It is, on purpose.
07:49:51 <twb> Is there a symbol for infinity?
07:50:25 <int-e> > 1/0
07:50:26 <lambdabot> Infinity
07:50:38 <int-e> apparently not :/
07:50:40 <int-e> > Infinity
07:50:41 <lambdabot>  Not in scope: data constructor `Infinity'
07:50:43 <twb> It doesn't evaluate to itself.
07:51:04 <int-e> maybe 1/0 is good enough?
07:51:13 <twb> int-e: not really.
07:51:19 <twb> int-e: See URL above.
07:51:26 <xerox> Sure
07:51:31 <xerox> Heh.
07:52:11 <twb> Man.
07:52:16 * cjb appears, hello.
07:52:16 <int-e> ∞ ?
07:52:31 <twb> Using macros and paredit on lisp code is sooo nice.
07:52:33 <xerox> Howdy, cjb!
07:52:48 <twb> Completely restructure a data object in ten keystrokes!
07:53:11 <cjb> Hi.  :)
07:53:28 <xerox> There were Haskell structure editors attempts too, I think.
07:53:39 <twb> xerox: good fucking luck.
07:53:41 <xerox> I can't recall the name of that BIG project which incorporated one.
07:53:58 <twb> Probably they end up like eclipse.
07:54:13 <cjb> xerox: You know how some people spend $bignum on expensive Go boards and think it'll improve their game?  I wonder if http://chris.printf.net/monitor_go3.jpg will do the same thing.  :)
07:54:16 <twb> Although I suppose you could apply the same logic to Emacs, if you assume that sexpr notation is "one language".
07:55:02 <xerox> cjb: haha, it is gGo!
07:55:10 <cjb> Yup.  :)
07:55:26 <xerox> I like that board, but I still prefer KGS.
07:55:35 <twb> Ooh, a kinesis!
07:55:51 <cjb> twb: No, that's a Touchstream.
07:55:52 <xerox> Oooh, a lil' apple.
07:56:01 <twb> Looks a bit like a kinesis.
07:56:06 <int-e> oh, someone watched today's Tengen title match
07:56:06 <cjb> But Kinesis boards are also lovely.  :)
07:56:16 <cjb> int-e: Oza.  :)
07:56:17 <xerox> int-e: OH!  Where?
07:56:22 <int-e> cjb: oops
07:56:32 <cjb> xerox: Just a small 30".
07:56:35 <xerox> IGS?
07:56:39 <twb> I wanna kinesis.
07:56:41 <int-e> cjb: Tengen title holder was the challenger. Oza title match. :)
07:56:42 <xerox> Ah, it finished?
07:56:46 <xerox> twb: me too.
07:56:48 <cjb> Yeah, it was on IGS a few hours ago.
07:56:54 <twb> One of the ones that replace the apple laptop keyboard.
07:56:57 <xerox> Dang.
07:57:03 <twb> One that's fully programmable!
07:57:19 <xerox> Yeah.
07:57:21 <twb> Then i'd unload the usb mouse driver, so the stupid other mouse thing wouldn't get in the way.
07:57:25 <xerox> Same here, apart from the apple.
07:57:28 <cjb> twb: Difference is that this one is just two trackpads; very different to a Kinesis.
07:57:39 <twb> xerox: the Second Phase is to buy an apple laptop :-)
07:57:53 <twb> cjb: hmm?
07:58:03 <xerox> twb: so phase 1,5 is to wait for money to flow in.
07:58:10 <twb> cjb: I thought that's what kinesis were.  maybe I'm confused.
07:58:24 <twb> xerox: that's phase 0
07:58:50 <xerox> We get other inter-phases because of Intel processors, too.
07:59:17 <twb> Fuck intel.
07:59:21 <twb> HATE HATE HAT
07:59:22 <twb> E
08:00:15 <shapr> um, yeah.
08:00:22 <cjb> twb: Nah, the Kinesis is just a contoured keyboards with keys.
08:00:29 <twb> cjb: oh.  ew.
08:00:30 <shapr> I have two kinesis countoured keyboards.
08:00:32 <tromp> inter is good for driving amd innovation...
08:00:35 <tromp> intel
08:00:44 <cjb> (But a particularly nice contoured keyboard.)
08:01:00 <shapr> I haven't found anything better than a kinesis. Only the unproduced Flinder...
08:01:52 <cjb> shapr: tried a Touchstream, out of interest?
08:01:52 <shapr> cjb: Do you know anything that seems better than a kinesis to you?
08:01:53 <twb> Does haskell have "fast" and "deep" equality tests?
08:02:12 <twb> Like [1,2,3] fast-eql [1,2,3] ===> False
08:02:17 <twb> Like [1,2,3] deep-eql [1,2,3] ===> True
08:02:34 <cjb> I'be used a Kinesis and am now using a Touchstream, but I wasn't at all unhappy with the Kinesis.
08:02:54 <twb> Man, you guys must be loaded.
08:03:07 <shapr> cjb: no, I haven't tried a touchstream. I really want something that uses the bowlshaped per-hand setup.
08:03:27 <shapr> twb: No, just dedicated to using the best tools possible: kinesis, haskell, etc
08:03:46 <twb> I can't afford a fancy keyboard.
08:03:53 <twb> They're like 600 bucks apiece.
08:04:06 <cjb> shapr: Cool.  Yeah, that sounds sensible; many of the galies, for example, went Touchstream->Kinesis.
08:04:29 <twb> cjb: apparently touchstream's manufacturer (Fingerworks) have gone out of business.
08:04:32 <cjb> But I like having the mouse integrated too much.
08:04:49 <cjb> twb: Yes, it's true.  It's not too hard to get one on eBay.
08:05:03 <twb> Bleh.
08:05:55 <twb> A second-hand keyboard is like a second-hand condom.
08:06:04 <takuan> usually
08:06:04 <cjb> !
08:06:46 <twb> All the hackers I know prefer the IBM M-keyboards.
08:07:00 <twb> Huge behemothic clickety-clack nasty.
08:07:39 <cjb> I had one of those on loan.  It was good for learning dvorak, 'cause you can pop out the key caps, but I had to give it back.
08:07:55 <twb> You look at the keys?
08:08:16 <cjb> I did while I was learning the keymap, yes.
08:08:29 <twb> I just have a printout next to me.
08:08:54 <twb> http://twb.ath.cx/~twb/doc/muse/speak-korean/keyboard.png
08:09:01 <xerox> I tried at time.  But I gave up.
08:09:21 <cjb> coo, Korean.
08:09:34 <twb> I'm learning!
08:09:45 <tic> why change the keymaps?
08:09:46 <twb> But I don't know anyone to talk to in Korean :-(
08:09:49 <tic> err, eys
08:09:51 <cjb> Lovely and logical.  :)
08:10:21 <cjb> I was really impressed when I heard about the consonant-vowel-consonant composition,
08:10:23 <cjb> .
08:10:44 <twb> http://twb.ath.cx/notes/speak-korean.pdf
08:10:46 <cjb> (I don't know any Korean, but I put support for it into Dasher.)
08:11:15 <cjb> http://www.inference.phy.cam.ac.uk/dasher/presentations/Korean/
08:11:15 <twb> dasher looked cool, but since I don't have a mouse I never really tried it.
08:11:56 <xerox> It was a while since the last time I heard of someone punishing himself.
08:12:15 <twb> xerox: hmm?
08:12:21 <xerox> :-)
08:12:48 <twb> emacs + screen, man!  No rat needed!
08:12:56 * xerox picks up the christmas presents list
08:13:33 <twb> Bah, dirty religio-corporate evil.
08:13:43 <cjb> twb: web-browsing?
08:14:08 <twb> cjb: w3m-el
08:14:23 <shapr> twb: I have one of the 1988 IBM clicky keyboards as a backup, but the kinesis is better.
08:14:29 <twb> cjb: you know that it's more common to input doubled consonants one at a time.
08:14:34 <shapr> I use my IBM clicky for right-hand dvorak.
08:14:47 <shapr> I have a heavily modified two hand dvorak keymap for my kinesis.
08:14:55 <twb> cjb: rather than having to select ㅆ, you type ㅅ ㅅ.
08:15:12 <shapr> http://www.scannedinavian.com/2005-11-03.html
08:15:32 <twb> Or 의 you type ㅇㅡㅣ, even though it's technically a single diphthong.
08:16:10 <shapr> Anyway, this sort of discussion should go onto #haskell-blah
08:16:32 * shapr gives kinesis info on #haskell-blah
08:16:42 <cjb> shapr: Interesting.  An advantage of the Touchstream is that you modify for one hand by dropping all your fingers on the other hand on one of the rows of keys.  
08:16:52 <phys_rules> hey all ;)
08:17:01 <cjb> (So, top row = ctrl, home row = shift, bottom row = meta.)
08:17:22 <cjb> Which works great for me, since I use emacs and ion and screen and need ctrl/alt all the time.
08:17:26 <twb> cjb: how do you type C-M-T?
08:17:26 <shapr> cjb: Want to hear about my hidden markov model keymap on #haskell-blah ?
08:17:42 <cjb> twb: By hand.  :)
08:18:27 <cjb> The modifier symbols are still *there*, the software just recognises that moving a finger/your hand to the edge of the keyboard is almost as dumb as taking your hand off the keyboard and moving it over to a mouse.
08:18:42 <twb> cjb: okie.
08:18:58 <twb> cjb: does this work everywhere, or do you need Evil Nasty proprietary drivers?
08:19:15 <cjb> Everywhere.  It's an open API, even for adding new gestures.
08:19:27 <cjb> And the keyboard shows up as a USB input device.
08:19:32 <twb> What is MEMBER called in Haskell?
08:19:42 <xerox> @type member
08:19:43 <lambdabot> Not in scope: `member'
08:19:46 <xerox> @type element
08:19:47 <lambdabot> Not in scope: `element'
08:19:50 <xerox> @type List.element
08:19:52 <lambdabot> Not in scope: `List.element'
08:19:53 <xerox> @type List.member
08:19:54 <lambdabot> Not in scope: `List.member'
08:20:12 <xerox> member x = any (== x)
08:20:34 <cjb> So, I guess the advantages are:  no keys to press down; built-in mouse; no modifier keys; gestures for anything you can think of.
08:21:23 <xerox> member = any . (==)
08:21:37 <xerox> @type Data.List.elem
08:21:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:21:41 <xerox> @type Data.List.notElem
08:21:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:21:46 <xerox> AH.
08:22:05 <twb> Thank you.
08:22:30 <xerox> You're welcome!
08:22:37 <xerox> (It is also in the Prelude)
08:22:46 <twb> Hmm?
08:22:49 <twb> @t elem
08:22:50 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
08:22:50 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
08:22:58 <twb> @type elem
08:22:59 <xerox> @type elem
08:22:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:22:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:23:04 <twb> Ooh.
08:23:28 <twb> I don't like the studlyCaps.
08:23:35 * twb wheels out glasses-mode.
08:24:28 <twb> Not much better.
08:27:16 <tic> wonder if there's a glasses-mode for vim.
08:28:22 <takuan> glasses-mode?
08:28:40 <Pita> Is there a good IDE for haskell on osx?
08:28:42 <jlouis> ExpandThis to Expand_This
08:28:50 <twb> jlouis: or expand-this.
08:29:47 * twb imagines
08:29:52 <twb> |expand this!|
08:32:10 <int-e> twb: does that work in Lisp?
08:32:21 <twb> int-e: yep
08:32:32 <twb> You can have any identifier you want if you put || around it.
08:32:46 <twb> I think maybe \| is used for internal stuff.
08:36:35 <bojohan> or use backslash: 'expand\ this
08:36:39 <cjb> By the way, I'm very interested in how people program; if anyone wanted to take a screencast of a little programming/compiling with Haskell, that would rule.
08:37:14 <twb> cjb: you guys don't have Haskell pron!?
08:37:17 <twb> That's terrible!
08:37:48 <twb> Marco made several Lisp porn movies.
08:37:56 <cjb> Yes, saw those.
08:38:32 <bojohan> > (symbol-name '||)
08:38:32 <lambdabot>  lexical error in string/character literal
08:38:33 <bojohan> ""
08:38:40 <bojohan> sorry, lambdabot 
08:38:48 * twb blinks
08:38:58 <twb> WTF is \bot running?
08:39:20 <twb> Oh, that was bojohan ^_^;
08:41:49 <shapr> cjb: Have you seen the TMR articles?
08:42:14 <cjb> shapr: TMR?
08:43:16 <shapr> The Monad.Reader
08:43:16 <shapr> http://www.haskell.org/tmrwiki/
08:43:42 <Igloo> Any autoconf gurus around?
08:44:03 * dcoutts knows a little about autoconf
08:44:32 <cjb> shapr: Any chance your blog's RSS could actually contain the blog items?
08:44:49 <shapr> Working on it...
08:45:10 <shapr> I think I figured out how to do it last night, but it'll be an evil hack.
08:45:16 <Igloo> I have http://musketeer.comlab.ox.ac.uk/~igloo/configure.ac but configure (after autoconf) says http://musketeer.comlab.ox.ac.uk/~igloo/out.txt - any ideas?
08:45:20 <shapr> Maybe I should switch to BloB or hack Flippi to output RSS.
08:45:54 <tic> the monad reader looks quite nice.
08:46:03 <shapr> It's nice to use blog software in Haskell, then any faults are clearly a lack of effort on my part :-)
08:46:52 <takuan> > :t '
08:46:53 <lambdabot>  parse error on input `:'
08:46:58 <takuan> humz
08:47:00 <takuan> @type '
08:47:01 <lambdabot> lexical error in string/character literal
08:47:15 <Igloo> Hmm, PKG_CHECK_MODULES doesn't get expanded at all
08:47:19 <cjb> shapr: Well, you can just throw the HTML between <item> tags, if you want a quick hack.  :)
08:47:39 <shapr> Yeah, that's the quick hack I'm trying to do...
08:47:54 <shapr> But PLog was structured in a way that makes that difficult.
08:49:20 <dcoutts> Igloo, is it getting defined in aclocal.m4?
08:49:47 <dcoutts> or maybe I mean acinclude.m4
08:50:01 <Igloo> Ah, I see, I need to run aclocal even if I don't have a an aclocal.m4, or whatever the file is?
08:53:30 <shapr> tic: Want to write an article? I haven't been able to get five article in the last two months :-(
08:54:16 <shapr> TMR has a (hoped for) viral culture along the lines of ... if you like it, write an article yourself!
08:54:19 <tic> shapr, thanks, but no. I'm a complete Haskell newbie and the only spare time until december 2006 is the two weeks from dec 18th to jan 1st this yaer. :)
08:54:29 <tic> yeah..
08:55:49 <tic> unless you want something along the lines of "a newbie's adventures in lambda land"
08:55:52 <shapr> tic: That would be perfect.
08:55:52 <shapr> In fact, that's what I want most.
08:56:09 <tic> shapr, haha.  well, like I said. I have little time, so I definitely won't make a commitment. but if I do find some time and a good topic, I might do so.
08:56:58 <shapr> Proceedings from academic meetings are great for experienced lambda knights, but newbies want to see how other newbies approached the lambda, where to find rough spots, and how to smooth the process.
08:57:26 <Igloo> dcoutts: Should autom4te.cache go in a tarball?
08:57:50 <shapr> http://www.haskell.org/tmrwiki/IssueThree has two articles very specifically for that subject, Graham Klyne wrote about his experience learning Haskell, and Alistair Bayley wrote an article on the differences between OOP and FP.
08:57:53 <tic> shapr, I suppose.
08:58:10 <tic> Yeah, I'm going to read through them later.  Eyeing through issue #1 atm.
08:58:15 <tic> like I said, time is precious..
08:58:37 <shapr> tic: Tell me if this would have helped you after reading the first tutorial - http://www.haskell.org/tmrwiki/LearningHaskellNotes
08:59:01 <tic> I -just- handed in an assignment in the Program Verification course (pre-, post-conditions, code coverage), and now I'm going to start working on an embedded language (in Haskell) for creating documents.
08:59:21 <shapr> Sounds like fun.
08:59:43 <tic> yeah, think so.. it's for the Advanced Functional Programming course. 
08:59:48 <tic> Lennart Augustsson. He's cool.
09:00:02 <tic> Would like to flatten to LaTeX and reST, but I think I'll stick for HTML.
09:00:02 <shapr> Yeah, he rocks out.
09:00:10 <tic> what do you mean with reading the first tutorial?
09:00:16 <tic> the LearningHaskellnotes page?
09:00:27 <tic> or the first tutorial in IssueThree?
09:00:35 <dcoutts> Igloo, no it should not.
09:00:55 <Igloo> Gngh
09:01:05 <shapr> I mean that once a newbie has a handle on the most basic parts of Haskell, a collection of pitfalls and how to get around them is probably a good thing to read.
09:01:09 <dcoutts> Igloo, at least the standard behaviour of automakes "make dist" is to leave it out.
09:01:14 <Igloo> Thanks
09:01:18 <tic> shapr, aha. I'll keep that in mind.
09:01:32 <tic> anyhow, afk (or rather, away from irc) for a while.. thanks for the links!
09:01:36 <shapr> sure
09:02:58 <Igloo> Hurrah, victory
09:20:59 <shapr> xerox: I think the post-declarative idea has been around for years.
09:21:05 <shapr> Have you heard of proof oriented programming?
09:21:14 <xerox> Nope, but it makes sense :-)
09:21:23 <shapr> Yeah, it does.
09:23:44 <shapr> Hiya dsacode, learning Haskell?
09:23:55 <Spark> also known as "thinking about your code as you write it"? :)
09:24:05 <xerox> I want the 'get the value off the type' thing, NOW
09:24:05 <SamB> is that where the program is a byproduct of proving it correct?
09:24:11 <shapr> SamB: yup, you got it.
09:24:13 <xerox> I mean, isn't it "Woo-ooh!" ?
09:24:17 <araujo> I am in middle of a dilemma here ...
09:24:25 <dsacode> Hello! Can someone explain me difference in two words between Parallel Haskell, Concurrent Haskell and Mobile Haskell?
09:24:26 <shapr> I am on the horns of a dilemma...
09:24:26 <xerox> I can't stand talking about it in three different channels, though.
09:24:27 <Spark> as opposed to "write, attempt to compile, write, attempt to compile, write, succeed compile, test = bug, write, attempt to compile, ..."
09:24:49 <araujo> What is a good way to interpret special characters in a interactive programm?
09:24:57 <shapr> xerox: truly, gale is a better approach to chatting.
09:25:32 <xerox> Let's focus on the type thing, ski is lecturing in #haskell-overflow it seems :-D
09:27:45 <SamB> dsacode: probably mobile haskell involves mobile code
09:28:13 <dsacode> SamB: mobile? it means it could be run in different environments?
09:28:26 <SamB> dsacode: meaning it migrates between nodes
09:28:31 <jethr0> is there a substring function in prelude or standard libs?
09:28:45 <SamB> either that or it runs on cellphones
09:30:00 <jethr0> i have looked, but not found anything of help...
09:30:29 <SamB> @hoogle String -> String -> Bool
09:30:30 <lambdabot> Network.URI.isURI :: String -> Bool
09:30:30 <lambdabot> Network.URI.isURIReference :: String -> Bool
09:30:30 <lambdabot> Network.URI.isRelativeReference :: String -> Bool
09:30:39 <bringert> jethr0: I don't think there is
09:30:39 <SamB> @hoogle String -> String -> Int
09:30:40 <lambdabot> No matches, try a more general search
09:30:47 <SamB> @hoogle String -> String -> Maybe Int
09:30:48 <lambdabot> No matches, try a more general search
09:31:49 <SamB> @hoogle substring
09:31:49 <jethr0> hmm, too bad, i'll have to roll my own then ;-(
09:31:53 <lambdabot> No matches found
09:32:13 <bringert> substringOf xs ys = any (isPrefixOf xs) (tails ys)
09:32:30 <bringert> is what I'd use for a quick substring
09:33:06 <bringert> would be nice to have an implementation of the Knuth-Pratt-Whatever algorithm though
09:33:41 <jethr0> bringert: thx a lot
09:34:18 <bringert> jethr0: wait, did you mean a function to check if one string is a substring of another, or to extract a substring of a string?
09:35:27 <jethr0> to find the index of a substring or Nothing.
09:35:45 <bringert> ah
09:36:04 <jethr0> index of the _first_ occurrence
09:37:01 <bringert> mine only checked whether the first was a substring of the other, doesn't return an index
09:37:04 <jethr0> i can still use your solution, but keep track of the current idx...
09:37:09 <bringert> jethr0: this isn't a homework problem, right?
09:37:30 <jethr0> no
09:37:48 <jethr0> as i said. something like:
09:38:00 <tromp> noone has ever answered yes to "is that homework?"
09:38:23 <SamB> tromp: oh?
09:38:27 <jethr0> hehe. i am not exactly waiting for a solution... it's not that hard a problem ;-)
09:38:43 * SamB wishes for a program to find such "Yes" answers
09:39:04 <SamB> jethr0: what kind of program are you writing?
09:39:33 <jethr0> samb: trying to write a (slow) implementation of libc in haskell. just for fun ;-)
09:39:38 <jethr0> nearly finished with string.h
09:41:10 <jethr0> i must say: FFI _really_ works like a charm in haskell. who'd have thought *g*
09:41:20 <bringert> findSubstr xs = findIndex (isPrefixOf xs) . tails
09:41:22 * xerox
09:41:32 <jethr0> cool, thx
09:41:33 <bringert> can anyone think of a shorter one?
09:41:39 <SamB> jethr0: ooh cool!
09:41:48 <SamB> you borrowing my idea then?
09:41:48 <xerox> @pl \xs -> findIndex (isPrefixOf xs) . tails
09:41:49 * bringert doesn't feel like working an more today
09:41:52 <lambdabot> flip ((.) . findIndex . isPrefixOf) tails
09:41:52 <lambdabot> optimization suspended, use @pl-resume to continue.
09:41:58 <xerox> @pl-resume
09:41:58 <samx_> jethr0, you happen to have any simple examples of using ffi?
09:42:07 <araujo> http://dev.gentoo.org/~araujo/stuff/screenshots/hkshell.gif
09:42:08 <lambdabot> flip ((.) . findIndex . isPrefixOf) tails
09:42:08 <lambdabot> optimization suspended, use @pl-resume to continue.
09:42:12 <jethr0> samb: not really. but i thought it would be a nice try.
09:42:14 <bringert> xerox: yeah I tried that
09:42:19 <SamB> jethr0: though just FYI, you'd probably want to use Ptrs directly rather than converting to Strings and back
09:42:28 <araujo> For those interested on my haskell shell screenshots :-)
09:42:32 <jethr0> i looked at what symbols were needed by gcc and gnu as and am trying now to implement them.
09:42:46 <jethr0> but, i'll run into trouble sooner or later.
09:42:47 <SamB> maybe not ;-)
09:43:24 * araujo off to eat
09:43:37 <jethr0> samb: hmm, where i can ;-). as i said, right now i am going for simplicity first and foremost; rather than speed.
09:43:45 <SamB> yes, point ;-)
09:43:57 * SamB is still way to premature in optimization sometimes
09:44:12 <SamB> er. as if being premature in optimization was ever a good idea
09:44:24 <jethr0> and writing c style black magic in haskell has its dangers...
09:45:20 <SyntaxNinja> good morning
09:45:22 * jethr0 thinks he finally has overcome the prem.opt. disease *hope*
09:45:27 <jethr0> morning
09:45:59 <jethr0> samb: but the problem in porting will less be the libc, but more the linking, etc.
09:46:20 <jethr0> but, in a few weeks when i'll have done a few more calls, i'll see at what point it becomes impossible for me *g*
09:46:20 <SamB> though personally I would try writing it both ways and see which looked nicer
09:46:34 <jethr0> hehe, care to look at the code so far?
09:46:48 <SamB> jethr0: sure!
09:47:03 <SamB> jlouis hasn't applied patches to conjure lately...
09:47:23 <lisppaste2> jethr0 pasted "string.h[s]" at http://paste.lisp.org/display/14195
09:47:37 <Igloo> Yo SyntaxNinja, does modern cabal pass cc-options to hsc2hs with --cflag=/-C?
09:49:13 <jethr0> samx_: sorry, http://haskell.org/hawiki/FfiTutorial
09:49:16 <SyntaxNinja> Igloo: lemmy look
09:49:34 <jlouis> SamB: wrong! :)
09:49:47 <Igloo> (and likewise ld-options --lflag/-L)
09:50:06 * joelr1 does a reduced version of a victory dance
09:50:30 <jethr0> samb: it's not safe yet... but i did far better in little time than i could have hoped for...
09:50:42 <jlouis> (And it was 24 hours since I last applied)
09:50:44 <SyntaxNinja> Igloo: yeah, looks like it.
09:50:54 <Igloo> Cool, ta
09:51:12 * Igloo curses the lack of ghc 6.6
09:51:14 <SyntaxNinja> hm. wait, maybe not
09:51:15 <joelr1> folks, how can i generate a list of N random numbers between (x,y)
09:51:26 <jlouis> joelr1: System.Random ;)
09:51:27 <xerox> @index randomRs
09:51:28 <lambdabot> System.Random
09:51:29 <joelr1> ah, stupid question, damn
09:51:32 <xerox> @type randomRs
09:51:33 <lambdabot> Not in scope: `randomRs'
09:51:37 <xerox> @type System.Random.randomRs
09:51:38 <lambdabot> forall a g.
09:51:38 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
09:51:38 <lambdabot> (a, a) -> g -> [a]
09:51:40 <joelr1> nono, i know about randomRIO
09:51:45 <xerox> @type System.Random.randomRIOs
09:51:46 <lambdabot> Not in scope: `System.Random.randomRIOs'
09:51:49 <xerox> @type System.Random.randomIORs
09:51:50 <lambdabot> Not in scope: `System.Random.randomIORs'
09:51:52 <joelr1> the question was more about the list of randomRIOs
09:51:54 <xerox> Ganh.
09:51:54 <joelr1> exactly
09:51:59 <joelr1> there's no randomRIOs
09:52:03 <SyntaxNinja> Igloo: no, it seems to only pas options that start with D, I, or U :)
09:52:09 <SyntaxNinja> cppOptions :: BuildInfo -> LocalBuildInfo -> [String]
09:52:09 <SyntaxNinja> cppOptions bi lbi
09:52:09 <SyntaxNinja>     = hcDefines (compiler lbi) ++
09:52:09 <SyntaxNinja>             ["-I" ++ dir | dir <- includeDirs bi] ++
09:52:09 <SyntaxNinja>             [opt | opt@('-':c:_) <- ccOptions bi, c `elem` "DIU"]
09:52:12 <joelr1> but i can simulate the same by going through a list of [1... x]
09:54:04 <SamB> jethr0: so, anyways, where is it?
09:54:47 <jethr0> jethr0 pasted "string.h[s]" at http://paste.lisp.org/display/14195
09:54:58 <jethr0> i thought you were looking at it all this time ;-)
09:55:17 <jethr0> samb: sorry, gotta go. i'll be back in a couple of hours.
10:00:52 <SamB> jlouis: where are patches?
10:01:14 <SamB> jlouis: didn't adept send you a whole bunch of them?
10:02:20 <Igloo> SyntaxNinja: I think that'll do in this case, although in general I don't see why they shouldn't all be passed through
10:02:22 <jlouis> SamB: oh, doh
10:02:49 <jlouis> I forgot
10:02:58 <jlouis> I have a couple of conflicts I need to solve first 
10:03:18 <jlouis> It'll be later this evening
10:03:18 <SyntaxNinja> Igloo: I don't really have an opinion. you're welcome to bring it up on the list or file a feature request :)
10:03:43 * Igloo is making a list of issues as I go, I'll probably just send that at some point
10:05:03 <Igloo> Although I might have stopped now I can't get by with ghc6's cabal
10:05:05 <SamB> jlouis: don't care! want anyway!
10:05:30 <SyntaxNinja> cabal-1.0 is rather limited
10:06:41 * SamB wonders how you would quickcheck string.h
10:14:01 <SamB> whats with this?
10:14:08 <SamB> /tmp/ghc25110.hc: In function '__stginit_LibC_':
10:14:08 <SamB> /tmp/ghc25110.hc:2932: warning: implicit declaration of function 'getStablePtr'
10:26:46 <syntaxfree> I found a (partial)) solution to the age-old riddle of whether it's pronounced hasKELL or HASkell.
10:27:26 <phys_rules> HASKELL ? LOL :)
10:28:39 <astrolabe> syntaxfree: Surely that is not solveable?
10:29:07 <syntaxfree> maybe not analytically
10:30:09 <astrolabe> Does your solution use elliptic functions?
10:30:20 <phys_rules> astrolabe: hypergeometric
10:32:35 <takuan> humz
10:32:38 <shapr> Can somone direct me to a good LaTeX tutorial? I've been sent one too many html emails...
10:32:38 <takuan> where's the logic in that
10:32:56 <takuan> if I add all correct type signatures to all functions it compiles slower than if I don't do that
10:33:02 <takuan> shapr: lshort.pdf
10:33:04 <takuan> google for that
10:33:23 <takuan> if that doesn't help
10:33:25 <takuan> mail me
10:33:27 <phys_rules> shapr: take chapter 8 of LaTeX companion it's available for free
10:33:28 <takuan> or pm me
10:33:45 <phys_rules> has all the required math stuff ;) or at least it's highgly helpful if you do physics or math ;)
10:33:52 <Cale> http://www.maths.tcd.ie/~dwilkins/LaTeXPrimer/
10:34:22 <xerox> @google lshort.pdf
10:34:23 <lambdabot> http://www.ctan.org/tex-archive/info/lshort/english/lshort.pdf
10:34:25 <shapr> I'll try that LaTeXPrimer first, thanks.
10:36:53 <phys_rules> lshort is kind of too simple :(
10:36:57 <SamB> shapr: I don't suppose you could set us up one of those patch-by-mail repos for conjure?
10:37:00 <phys_rules> definitely not enough for serious stuff
10:39:01 <shapr> SamB: How about patch by post?
10:39:14 <SamB> shapr: post?
10:39:24 <SamB> you mean HTTP POST or NNTP post?
10:39:42 <shapr> HTTP post.
10:40:01 <xerox> ...or even PUT!
10:40:56 <SamB> but then I would need an SSL key!
10:41:03 <SamB> or something
10:42:27 <jlouis> SamB: ok, this is going in tomorrow
10:42:38 <jlouis> I need to work a bit more on it ;)
10:42:53 <SamB> we could call it conjure-unstable
10:44:54 <eivuokko> 'Conjure-mutant´ sounds better ;)
10:44:59 <SamB> hehe
10:45:09 <SamB> shapr: so anyway, sure, why not!
10:45:28 <SamB> I guess thats a lot easier to set up, huh?
10:50:00 <astrolabe> What is the best way to plot 3 dimensional stuff using haskell?
10:50:19 <xerox> gnuplot?
10:50:27 <xerox> Oh, I don't know if it does that.
10:50:33 <xerox> Mathematica does, though :-)
10:50:38 <astrolabe> Where 'best' is almost exactly equal to 'easiest'
10:50:46 <phys_rules> xerox: gnuplot is good
10:51:00 <phys_rules> and does 3d and all
10:51:11 <xerox> Good enough.
10:51:12 <phys_rules> though it's not easiest
10:51:14 <SamB> but does it have a nice Haskell interface?
10:51:19 <phys_rules> no
10:51:21 <xerox> You feed it a file?
10:51:30 <xerox> A-la 'thing-to-draw-graphs'
10:51:43 <xerox> '-which-dcoutts-knows-of'
10:52:01 <SamB> are you talking about graphviz again?
10:52:04 <xerox> Yep.
10:52:06 <astrolabe> I was thinking maybe the haskell openGL library.
10:52:20 <xerox> That would be fun.
10:52:21 <SamB> does gl have decent plotting?
10:52:24 <xerox> Catch boegel :-)
10:52:46 <astrolabe> know idea :(  I thought that was probably all it did.
10:53:07 <xerox> In some sense it's true I think.
10:53:22 <xerox> I don't think you would have many problems building up a simple framework :-)
10:54:04 <astrolabe> Oh yeah, boegel would know.
10:54:16 <takuan> but once you learn using gnuplot, it works like a cream
10:54:20 <takuan> and pm3d is cool
10:55:10 <astrolabe> but if gnu plot isn't haskell, it will be a pain to use I guess.
10:55:13 <xerox> Yaaaaaawn.
10:55:54 <SamB> does anyone know where I can obtain pirate standards?
10:56:15 <astrolabe> Ah, when I said 'plot' I was being to specific.  I want to draw stuff in 3d.
10:56:16 <SamB> particularly ISO standards
10:56:40 <astrolabe> regulations for eye patches?
10:56:56 <SamB> okay, ISO warez
10:57:01 <SamB> of the non-cd-image variety
10:57:09 <araujo> lazy evaluation is dependent of the implementation or of a language?
10:57:19 <SamB> araujo: implementation
10:57:30 <araujo> SamB, thought so, thanks
10:57:37 <SamB> though generally only some languages can handle it
10:57:39 <astrolabe> SamB: Sorry I couldn't help, so I thought I'd be facetious instead.
10:57:58 <araujo> SamB, So, for example, it'd be possible ot have something like a C lazy interpreter?
10:58:00 <SamB> in particular the DSSSL standard appears to have gone missing
10:58:15 <Cale> well, there's lazy evaluation, and nonstrict semantics, and those are separate concepts
10:58:16 <SamB> araujo: well, who knows?
10:58:22 <araujo> SamB, Right.
10:58:31 <astrolabe> I thought lazy evaluation was not dependent on the language.
10:58:34 <araujo> Cale, lazy evaluation i mean
10:58:43 <astrolabe> Er I mean the implentation.
10:58:52 * astrolabe tries again
10:59:00 <SamB> astrolabe: well, things like Haskell almost dictate lazy evaluation
10:59:08 <astrolabe> I thought lazy evaluation was defined as part of the language.
10:59:29 <SamB> ever heard of "eager Haskell"?
10:59:36 <astrolabe> SamB: That's what I meant, but stronger.  I said the opposite :(
11:00:07 <astrolabe> But is eager Haskell a type of haskell strictly speaking :)
11:00:13 <SamB> no
11:00:15 <Cale> Haskell is defined to have nonstrict semantics
11:00:16 <SamB> it is not strict
11:00:32 <Cale> lazy evaluation is one way to implement nonstrict semantics
11:00:49 * SamB shamelessly rearranges astrolabes sentances for his own entertainment
11:01:09 <araujo> Cale, That's my confusion , as far as i know, the order of evaluation in a language is dependent of the implementation.
11:01:49 <araujo> What makes think that 'lazy evaluation' isn't a feature of the Haskell language but of their imlementations.
11:01:54 <Cale> It's basically outermost-first evaluation, except that there is sharing involved, to prevent needless evaluation when you have something like double x = x + x and you write double (13 + 27)
11:02:07 <Cale> you want to make sure that (13 + 27) is only evaluated once
11:02:12 <araujo> i know that
11:02:55 <Cale> however, I'd say that nonstrict semantics -- the idea that f _|_ is not necessarily _|_ is part of the language
11:03:15 <astrolabe> Languages only seem to define what the outputs are, not how they're got.
11:03:27 <araujo> Cale, really?
11:03:33 <Cale> yeah
11:03:41 <Cale> Practically speaking, it is anyway
11:03:59 <Cale> most Haskell programs aren't going to run if you put them into a strict evaluator
11:04:15 <araujo> But a lazy evaluator wouldn't give that very same result no matter the language?
11:04:35 <Cale> a lazy evaluator might return a result where the language doesn't define one
11:04:58 <araujo> Oh well, that's because they are designed for lazy evaluation.
11:05:25 <araujo> Cale, ?
11:05:54 <araujo> The order of evaluation shouldn't change the returned value.
11:06:04 <araujo> Unless you don't find its normal form.
11:06:11 <araujo> It should always return the same result.
11:06:12 <Cale> For example, if I have a strict language (which for my purposes will have the same syntax as Haskell) it's going to say that ones = 1 : ones is an infinite loop, and the same as _|_
11:06:39 <Cale> and so  head ones = _|_
11:07:09 <araujo> Of course. 
11:07:15 <araujo> It isn't lazy evaluated.
11:07:19 <Cale> but with lazy evaluation, you're going to evaluate head ones and get 1
11:07:31 <araujo> Yes.
11:07:37 <araujo> No matter the language right?
11:07:49 <Cale> hm?
11:08:14 <araujo> I don't see how that is language depedent.
11:08:28 <araujo> That's implementation dependent.
11:08:45 <Cale> The language defines the semantics -- what should a given expression evaluate to, and potentially what side effects may occur.
11:09:19 <Cale> hm?
11:09:27 <Cale> no, it's very language dependent
11:09:28 <araujo> mm.. but that's not responsability of the order of evaluation.
11:10:12 <Cale> Languages don't tend to define an order of evaluation so much as they define what the result of evaluating an expression is.
11:10:55 <jeffno> It's common for (true or exception) to never evaluate exception though.
11:10:59 <Cale> If your language says that  head ones = 1, then you'd better not use a strict evaluator to evaluate in it, because you'll fail to implement the language spec.
11:11:32 <eivuokko> Well, imperative lanaguages tend to define which order or orders expressions can be evaluated.
11:11:48 <_Codex> I wonder if it would work to use strict evaluator + explicit declaration that head ones = 1 :-).
11:11:48 <Cale> yeah, there are bits and pieces of lazy semantics in what you'd normally call strict languages
11:12:25 <jeffno> Can you write a Haskell program that will evaluate 1/0 in one compiler and not another?
11:12:26 <araujo> Cale, Precisely my point. Defining the result of evaluating an expression got nothing to do with the order of evaluation.
11:12:35 <Cale> _Codex: you'll either explicitly be declaring infinitely many things, or there will be infinitely many failing test cases :)
11:12:44 <Cale> araujo: well, sure
11:13:07 <Heffalump> jeffno: no
11:13:11 <_Codex> cale: I mean, maybe there would be a simple piece of code that would implement lazy eval :-)
11:13:14 <SamB> Cale: hmm, where can I get me one of those infinite test suits?
11:13:18 <takuan> what on earth does forall a . mean?
11:13:30 <Heffalump> well, not without unsafePerformIO.
11:13:32 <Cale> but only certain orders of evaluation can implement certain semantics
11:13:33 <pkern> How could I express `parse (a ++ "+" ++ b) = foo' in proper Haskell?
11:13:47 <Cale> takuan: for all a
11:14:12 <takuan> and how does it differ from not using forall in the type-specification?
11:14:18 <Cale> takuan: in types, it means  for all types a
11:14:24 <takuan> humz
11:14:44 <takuan> isn't that already implied?
11:14:49 <eivuokko> takuan, in most situations it just means that a is a variable.
11:14:50 <Cale> all type variables in signatures in Haskell are implicitly forall'd right at the front if you don't include an explicit forall
11:15:21 <Cale> It means that a isn't a free variable.
11:15:48 <Cale> which you usually want for types :)
11:15:52 <takuan> so why does Haskell suddenly shows it in a typesignature?
11:15:54 <takuan> ghc that is
11:16:03 <Cale> -fglasgow-exts is on?
11:16:05 <eivuokko> takuan, you have enabled extensions
11:16:05 <pkern> Or is there another way I could pattern-match on an element in a list, slicing the argument?
11:16:43 <Cale> pkern: no, use takeWhile and dropWhile perhaps
11:17:16 <Cale> well, that has a name, it's called break
11:17:21 <pkern> Cale: Sounds reasonable, but unperformant? ;)
11:17:35 <Cale> > break (== '+') "Hello + World"
11:17:37 <lambdabot> ("Hello ","+ World")
11:17:38 <eivuokko> I think forall syntax is a bit dumb.  I think it more like a gap in unification.  If you see forall, unification over it is only "match".
11:17:51 <pkern> Cale: Thanks.
11:18:20 <SamB> eivuokko: maybe it makes more sense with the curry/howard isomorphism?
11:18:42 <eivuokko> SamB, I know it's cool few words.  I don't know what it means...
11:18:42 * SamB thinks existential types ought to use "exists"
11:18:47 <Cale> It always made sense to me
11:18:53 <Cale> yeah, me too
11:18:59 <Cale> they should allow both
11:19:02 <takuan> it's strange
11:19:14 <eivuokko> Yeah, I am not educated enough to understand all of that.
11:19:15 <takuan> ghc shows them in the type signature without enabling extensions
11:19:21 <_Codex> I always think forall as "a way to enumerate all elements of a type" :)
11:19:31 <eivuokko> takuan, you might have enabled package that requires extensions
11:19:41 <Cale> _Codex: er, not quite what it means here
11:20:01 <takuan> Ratio eivuokko?
11:20:07 <Cale> f :: forall a. a -> a, means that for all types a, f has type a -> a
11:20:20 <eivuokko> takuan, uhm.  I dunno.
11:20:26 <takuan> Loading package haskell98-1.0 ... linking ... done.
11:20:34 <eivuokko> takuan, Oh, prelude..not then.  Wierd..
11:20:36 <takuan> i see that when I try to use one of the functions
11:20:44 <Cale> or, can have the type, perhaps more accurately.
11:22:33 <eivuokko> Cale, do you have good explanation how one understands higher rank polymorphism from that definition?
11:24:14 <Cale> well, with higher rank polymorphism, you can insist that the parameters to functions must be polymorphic
11:24:25 <takuan> what does package haskell98 do?
11:24:25 <eivuokko> Yes.
11:24:47 <_Codex> cale: yes, that implies that there exists a global list of types somewhere and then you copy the template a->a for all the types in the list. :)
11:25:06 <SamB> takuan: that has old modules like
11:25:11 <SamB> Maybe
11:25:14 <SamB> List
11:25:14 <takuan> uhu
11:25:21 <_Codex> cale: but that's a little stretching.
11:25:22 <eivuokko> And that's why I think forall is a bit dumb syntax, it doesn't say polymorphism anywhere clearly, and as I understand, it is sort of gap/blind spot in unification (from type point of view).
11:25:23 <SamB> Complex
11:25:40 <SamB> eivuokko: read up on the curry/howard isomorphism ;-)
11:25:49 <eivuokko> SamB, I don't understand it...
11:26:12 <takuan> now
11:26:15 <Cale> For instance, if your function type looks like (forall a. a -> a) -> (Char, Int) -> (Char, Int), then you have to pass it a parameter which for all types a, unifies with a -> a
11:26:36 <takuan> i have two files in haskell
11:26:46 <takuan> one practically without type specifications
11:26:55 <takuan> and another where I've added the type specifications
11:27:07 <takuan> without using extensions
11:27:20 <eivuokko> Cale, I know how it works.  I don't see how forall helps to understand/express that.  Nothing from the basic symbolic logic I know implies such meaning for forall.
11:27:41 <takuan> if I ask the type of one of the functions from the file without typesp. it says:
11:27:42 <takuan> uSerPow :: (Fractional a, Fractional (Series a)) => Series a -> a -> Series a
11:27:51 <takuan> which needs extensions to work
11:28:16 <Cale> eivuokko: perhaps read "->" as "implies"
11:28:37 <eivuokko> Cale, I'm afraid you lost me.
11:28:49 <astrolabe> =>     ?
11:29:07 <Cale> well, types are sort of like theorem statements.
11:29:13 <eivuokko> Yes..
11:29:16 <Cale> and programs are sort of like proofs
11:29:34 <_Codex> execution = proof simplification
11:29:39 <musasabi> What threading mechanism does GHC use on FreeBSD ?
11:30:15 <takuan> anybody an idea why ghc does that?
11:30:23 <_Codex> C-H is pretty nice.
11:30:40 <musasabi> My code appears to run 5-10 times faster on the linux host, and I would like to fix it. (I suspect it has to do with threading and sockets)
11:30:57 <phys_rules> musasabi: hey :) I did the registered build of ghc for solaris x86 ;) 
11:31:11 <musasabi> nice :-)
11:31:22 <musasabi> please submit it so it will be available from haskell.org
11:33:52 <Cale> f :: (forall a. Enum a => a -> a) -> (Char, Int) -> (Char, Int) : "If we have a value g, which for all types a, if a is in the class Enum, then v is a witness to the type a -> a, then we have f g is a witness to the type (Char, Int) -> (Char, Int)."
11:35:00 <Cale> Is that comprehensible?
11:35:07 <eivuokko> Cale, are you explainig to me?
11:35:33 <Cale> trying to :)
11:35:45 <_Codex> cale: looks ok to me.
11:35:49 <SamB> musasabi: you want it to run just as slow on linux as on freebsd?
11:35:50 <eivuokko> Cale, I know what the semantics are, I can very well use rank-2 polymorphism.
11:36:00 <Cale> an example of such an f would be  f g (x,y) = (g x, g y)
11:36:32 <Cale> eivuokko: I was trying to write that type in a more "logic-oriented" way
11:37:17 <eivuokko> Cale, Yeah.  Thanks for your effort :)  I just have hard time saying what I want because I don't happen to come with univ degree or similar education...
11:37:20 <sieni> musasabi: maybe freebsd is just slow ;-)
11:37:44 * jeffno has a CS degree but usually can't follow.
11:37:52 <SamB> eivuokko: have you read GEB?
11:38:12 <musasabi> sieni: I doubt it - more likely I just don't know how to tune it.
11:38:12 <eivuokko> Cale, What I jsut wanted to say, that I'd prefer something like     { Enum a => a->a }  ->  (Char, Int) -> (Char, Int)  Where {} means same sort of "gap" in unification as forall a. means
11:38:20 <eivuokko> SamB, What is it? :-P
11:38:30 <eivuokko> SamB, I read ghc docs, is that good?
11:38:47 <Cale> eivuokko: well, that would be about the same
11:38:55 <eivuokko> Cale, yes!
11:38:55 <pejo> eiv, Gdel, Escher, Bach.
11:39:06 <Cale> eivuokko: it's just that you occasionally want to control which variables are captured
11:39:12 <Cale> and which aren't
11:39:14 <eivuokko> Cale, But the syntax of "forall a." is in my opinion a dumb.
11:39:21 <eivuokko> Cale, Yes! :)
11:39:23 <Cale> why?
11:39:29 <jeffno> GEB has some bad reviews that scare me away from it.
11:39:42 <Cale> jeffno: no! it's a wonderful book
11:39:44 <eivuokko> Cale, it is the "capturing" of variables that is significant, not forall.
11:39:54 <integral> GEB is absolutely brilliant :)
11:39:56 <Cale> One of the best books I've ever read :)
11:39:56 <_Codex> geb is great book.
11:40:00 * astrolabe really liked GEB
11:40:02 <eivuokko> pejo, thanks, I'll check it out.
11:40:12 <eivuokko> So I should read it?  I hope it's easy to get.
11:40:12 <Cale> eivuokko: forall is what's doing the capturing
11:40:17 <eivuokko> Cale, I know :)
11:40:20 <Cale> it's the quantifier
11:40:22 * _Codex likes geb, but sets for mathematics is a little better. :)
11:40:28 <Cale> as opposed to exists
11:40:28 <jeffno> It sounded half-baked, kind of mixing up Alice in Wonderland with math.
11:40:28 <eivuokko> Cale, I am not commenting on semantics, but *syntax*
11:40:56 <_Codex> jeffno: that's exactly what geb is.
11:40:59 <Cale> jeffno: it's about neither one of those :)
11:41:10 <jeffno> Ah, a contradiction!
11:41:15 <Cale> jeffno: it's ultimately about consciousness, and it involves a lot of other things along the way
11:41:15 <jeffno> Who's right? :)
11:41:26 <_Codex> jeffno: both
11:41:45 <_SamB_> jeffno: how is mixing up alice in wonderland with math half-baked?
11:41:54 <jeffno> I really like stuff put straightforwardly.
11:42:03 <Cale> There's some small amount of math in it
11:42:04 <jeffno> Like if he has some deep math things to say, then say them plainly.
11:42:14 <eivuokko> Cale, in my opinion the syntax choice to use "forall" isn't all that intuitive.  It much easier to understand (for me atleast!) that when you reach forall a., you reached type, and you only check "match" for known types and kinds over it when unification is done.
11:42:29 <Cale> You get a drawn out proof of Gödel's Incompleteness Theorem
11:42:48 <jeffno> Mmm, but I wouldn't want it wrapped in some fictional writing.
11:42:54 <eivuokko> Cale, and imo nothing in forall implies those semantics.  And I am fairly sure that's true for others who don't know deeply what forall means.
11:43:20 <Cale> jeffno: the fiction is separated, and actually the effect is quite pleasant :)
11:43:34 * _Codex have a feeling that I dont know forall very well :(
11:44:37 <xerox> I wouldn't call it "some fictional writing".
11:45:04 <Cale> It's really more that you have these dialogues which come before each chapter
11:45:27 <Cale> with silly characters like Achilles, the Tortoise, and a Crab, and some others
11:45:40 <jeffno> See, that scares me.
11:45:46 <Cale> and they talk about things, and it relates to the chapter to come in an interesting way
11:45:46 <jeffno> I'd probably find it really annoying.
11:45:58 <Cale> It's actually pretty cleverly written
11:46:07 <Cale> there's a lot of nice things hidden in it
11:46:20 <jeffno> That's the part I don't like.
11:46:26 <_Codex> B |-y forall_f A  --------------- B f |-x A     <-- this is rule of forall in logic terms :)
11:46:37 <xerox> Yeah!
11:46:41 <musasabi> It seems that the problem lies in buffering data + SMP locking.
11:46:42 <Cale> also, sometimes very blatantly clever, for example, one of the dialogues reads basically the same backwards as forwards
11:46:50 <xerox> Finding hidden things is _so_ rewarding.
11:46:53 <SamB> jeffno: you don't have to find all the easter eggs or anything
11:47:05 <xerox> Also, noticing being fooled is too :-)
11:47:06 <eivuokko> Codex, :)
11:47:15 <xerox> I still didn't finish it :-)
11:47:22 <jeffno> Cale, no offense, but that's exactly the kind of thing that I'd want to avoid.
11:47:32 <Cale> jeffno: why?
11:47:37 <SamB> jeffno: you have strange fears
11:47:40 <jeffno> Because I consider it a waste of time.
11:47:47 * SamB calls jeffno a chicken
11:47:53 * jeffno runs and hides.
11:47:59 <SamB> hehehe
11:48:11 <eivuokko> Well, each to their own...
11:48:11 <SamB> I laugh evilly
11:48:18 <Cale> jeffno: How about listening to music?
11:48:24 <Cale> Is that a waste of time?
11:48:25 <xerox> jeffno: I really think it is not.
11:48:27 <jeffno> Cale, that's different.
11:48:33 <SamB> jeffno: you probably don't read fiction either
11:48:37 <jeffno> I don't listen to music to learn things.
11:48:38 <Cale> Or going to the art museum and looking at paintings
11:48:49 <Cale> I do :)
11:49:02 <jeffno> I like fiction.
11:49:10 <SamB> jeffno: you should listen to animaniacs
11:49:15 <jeffno> But I don't like mixing up fiction with academics.
11:49:16 <Cale> There's no reason that you can't learn things and enjoy something artistically at the same time.
11:49:18 <mwc> Cale: are you one of those people that see deep connections between math and music?
11:49:27 <mwc> I have a lot of friends like that
11:49:45 <mwc> Personally, I don't see any connection.
11:49:50 <Cale> mwc: well, not *that* deep, but there are quite a few connections
11:49:51 <mwc> but then I'm totally tonedeaf\
11:49:54 <jeffno> I tend to think when you get caught up in making something clever you lose sight of good teaching.
11:49:57 <eivuokko> Cale, there can be.  For example being brought up in a way that it's hard to enjoy while learning...
11:50:17 <jeffno> As an example, another blasphemy: I hate Conway's writings.
11:50:27 <Cale> Which Conway?
11:50:34 <jeffno> John of the Game of Life.
11:50:37 <Cale> ah, okay
11:50:52 <jeffno> He likes to put in lots of puns intermingled with math.
11:50:53 <Cale> yeah, he can be a little strange
11:51:15 <jeffno> I have a hard enough time as it is with the math, so he's probably best for professionals that already know what he's talking about.
11:51:36 <Cale> Well, a definition is a definition. You can call things whatever you like.
11:51:49 <Cale> He tends to come up with lots of new mathematical objects
11:51:50 <SamB> squiggol
11:51:57 <Cale> and gives them fanciful names
11:52:00 <SamB> thats the name I couldn't remember before...
11:52:07 <jeffno> It's not the name, it's the little jokes he likes to make.
11:52:21 <mwc> Oh please, that's what makes it great!
11:52:31 <jeffno> Usually the joke is a twist on some mathematical concept, and it makes it hard for me.
11:52:32 <mwc> Nietzsche would be as dull as Ayn Rand if it weren't for his puns\
11:53:06 <_Codex> real neat jokes are those that are so well hidden that you only realize them once you've studied the writings for 20 years.
11:53:14 <jeffno> mwc: This is my personal taste.  When learning I want a well written book that engages me because of what I'm learning.
11:53:17 <Cale> jeffno: well, mathematicians tend to write for mathematicians
11:53:23 <mwc> jeffno: have you read Knuth's Surreal Number stuff
11:53:31 <jeffno> mwc: Nope.
11:53:50 <Cale> jeffno: have you seen, for example, Spivak's Calculus?
11:53:57 <jeffno> Again, no.
11:54:06 <astrolabe> I find conway very clear.
11:54:13 <mwc> He basically derives a number system from the perspective of people sitting on a beach in Tahiti wanting to do some math
11:54:28 <mwc> Cale: I haven't read Spivak's calc, but I've heard it's legendary
11:55:06 <mwc> would it be worth "relearning" calc from?
11:55:21 <Cale> mwc: potentially
11:55:43 <Cale> mwc: if nothing else, it might teach you to how to teach Calculus :)
11:56:00 <mwc> Heh, sounds like it'd be good then
11:56:06 <Cale> I still enjoy picking it up and reading it
11:56:27 <Cale> (having just recently graduated from my pure mathematics degree)
11:56:32 <mwc> I've been meaning to go through Kolmogorov's Real Analysis this christmas season
11:56:43 <astrolabe> I don't like books that thick.  I know that is shallow, but they make me think there must be a lot to know.
11:56:51 <Cale> ah, that looked good, though I didn't get a chance to read it properly
11:56:57 <mwc> Since the applied math degree I have seems to have skirted around any real hardcore real analysis
11:57:04 <Cale> astrolabe: like which?
11:57:13 <astrolabe> Spivak
11:57:18 <sieni> what's the preferred way of taking backups of a darcs repository? do I just darcs pull over ssh?
11:57:25 * _Codex stopped reading heavy math half year ago. Too much math is not good.
11:57:31 <Cale> astrolabe: it's thick because it's well-explained, and there is a lot to know :)
11:57:56 <eivuokko> sieni, darcs pull/push or just packing it in a file.
11:57:58 <astrolabe> Cale: I guess I know a lot of what he covers, and it doesn't seem like much.
11:58:06 <Cale> It's basically a great introduction to modern mathematics. Not really in content, but in presentation.
11:58:31 <Cale> In content, it's an intro to analysis.
11:58:38 <astrolabe> I'm the same with coding though.  I try to make it look as though there isn't much code.
11:58:47 <Cale> and calculus on functions of a single real variable
11:59:11 <astrolabe> hmmm I could never get excited about that stuff.
11:59:25 * astrolabe prefers algebra
11:59:32 <Cale> Have you read Spivak or just looked at it?
11:59:51 <astrolabe> I've only looked at it, an that a long time ago.
12:00:00 <mwc> I personally wish they didn't put the pure and applied math people through the standard "Calculus" course
12:00:17 <astrolabe> I've read his 'calculus on manifolds' and enjoyed it.  Now there is a nice thin book!
12:00:19 <mwc> I see no reason why second year real analysis couldn't be rebranded as "Calculus For Mathematicians"
12:00:28 <mwc> and the old calc course as "Calculus for the Physical Sciences"
12:02:04 <mwc> Then they could put a real analysis course first semester of second year, and that would set up nicely for Diff Eq. 1 and Advanced Linear Algebra
12:02:07 <sieni> eivuokko: stupid question: does darcs push need darcs on the other end?
12:02:09 <astrolabe> I think it is worth bashing applied mathematicians heads with the fact that you can't just swap the order of integrals.  They can then spend their lives doing just that :)
12:02:33 <eivuokko> sieni, If it's over ssh, yes, locally not.
12:02:34 <Cale> mwc: at waterloo, if you take the advanced section mathematics, the first year calculus uses Spivak
12:02:43 <astrolabe> mwc: What's in the old calc course?
12:02:49 <mwc> astrolabe: standard first year calc
12:02:57 <Cale> and spends about 1/2 the time studying sequences and limits
12:03:13 <mwc> intro to functions, limits, differential calc first term;
12:03:15 <sieni> eivuokko: well, it would be difficult to run darcs locally, if I didn't have darcs locally ;-)
12:03:21 <mwc> second term is series, sequences, and integrals
12:03:37 <eivuokko> sieni, lol, heh, that was rather silly statement I made, huh? :)
12:03:45 <mwc> Cale: wish I'd gone to Waterloo for Pure math now
12:04:00 <mwc> but at the time, I was more interested in Applied Math, and UWO had a better dept/
12:04:06 <mwc> ORCCA is here, for instance
12:04:18 <astrolabe> Ah, then what's in the real analysis, if not that stuff?
12:04:31 <mwc> astrolabe: stuff like axiomatic development of the reals
12:04:38 <astrolabe> Ah I see.
12:04:40 <mwc> and more series stuff
12:04:58 <mwc> but then it follows that with "Calculus Done Right"
12:05:17 <Cale> I rather like the way that Spivak introduces the reals.
12:05:34 <astrolabe> Cale: How's that?
12:05:37 <mwc> I actually didn't really get into pure math until I took this group theory elective
12:06:21 <astrolabe> I used to really like group theory
12:06:34 <Cale> axiomatically, with a nice careful progression. He introduces the properties of a ring, then a field, then an ordered field, then adds the least upper bound property.
12:07:02 <Cale> But he doesn't actually mention rings in general, I don't think (though there is a brief mention of fields)
12:07:09 <mwc> Number Field/
12:07:37 <mwc> er, does he just discuss number fields, or abstract fields in general?
12:07:37 <Cale> mwc?
12:07:43 <Cale> oh
12:07:49 <Cale> he really only discusses R
12:08:06 <Cale> but the axiomatic properties of R that he introduces are carefully grouped
12:08:17 <mwc> SOunds good
12:08:23 <Cale> and you spend a bit of time studying rings without knowing that you are :)
12:08:30 <astrolabe> carefully 'grouped' ?
12:08:31 <mwc> I glanced through Kesler's Calculus book
12:08:50 <mwc> he basically axiomatically develpos the hyperreals and then founds the calculus on that
12:09:24 <Cale> astrolabe: the order in which he introduces the properties is the same as if you defined "ring" then "field", then "ordered field", and then there's the least upper bound property to add completeness.
12:09:57 <Cale> and after each of those, there's a volley of exercises
12:10:24 <Cale> and quite a bit of well-crafted discussion
12:11:45 <astrolabe> It is weird.  I find all that stuff really dull.  I don't know why, and I'm not diparaging your interests.
12:11:57 <Cale> Basically the first part of Spivak is what I'd have them teach in highschool, if I was in control of that.
12:12:16 <astrolabe> Cale: Now that's a good idea!
12:12:19 <Cale> He goes on to other things of course
12:12:29 <jeffno> Normally I'm not a big math fan, I think the Continuum Hypothesis is fascinating.
12:12:44 <Cale> This all happens in the first 60 pages or so.
12:13:00 <Cale> maybe fewer than that
12:13:06 <mwc> well, I have to go finish off a last assignment of the year
12:13:19 <mwc> thanks for the discussion Cale, astrolabe, jeffno 
12:13:23 <Cale> jeffno: Which way do you think it should be?
12:13:46 <astrolabe> I suppose I thought it was cool the first time I read about the definition of the reals in terms of dedekind cuts.
12:13:46 <Cale> CH or not-CH?
12:14:02 <jeffno> Let me think for a bit, I forgot what I was guessing it to be last time I looked at it.
12:14:04 * jeffno thinks
12:14:25 <Cale> I think it's somewhat accepted that CH isn't going to be selected either way in the near future. 
12:14:41 <Cale> astrolabe: that's an appendix :)
12:14:59 <astrolabe> I don't have a clue as to how you could have an intuition about the continuum hypotheses.
12:15:02 <jeffno> Actually, I have no intuition about it.
12:15:31 * jeffno said that without seeing astrolabes comment
12:15:44 <astrolabe> :D  Great minds
12:16:00 <jeffno> Just seems like such a simple question though.
12:16:32 <astrolabe> Whereas the axiom of choice seems sort of obviously true to me.  I must be a platonist.
12:17:11 <jeffno> I like that quote, I forgot how it goes, something about it being obviously true, and another thing obviously false, and a third one...?
12:18:09 <jeffno> Ah, here it is: "The Axiom of Choice is obviously true; the Well Ordering Principle is obviously false; and who can tell about Zorn's Lemma?"
12:18:33 <jeffno> Now *that* math joke I find funny :)
12:18:43 <takuan> humz
12:18:52 <astrolabe> :)
12:19:05 <Cale> I kind of lean toward there being no intermediate cardinalities
12:19:37 <sieni> many set theorists seem to think that c=\aleph_2
12:19:43 <Cale> It's kind of useful for ordinary mathematics, usually you can get around it, but it does simplify arguments in a number of places
12:20:11 <Cale> sieni: yeah
12:20:50 <astrolabe> really? that's weird.
12:22:37 <astrolabe> I'm too rusty to get this right, but maybe you can make some kind of argument from the ordinals
12:22:39 <Cale> The Axiom of Choice is nice, but I sort of like the fact that it's a second-class citizen as far as axioms go. I accept it, but it's nice to know what can be done without it.
12:22:56 <Cale> I'm a formalist really.
12:23:12 <Cale> astrolabe: well, CH is formally undecidable
12:23:17 <takuan> damn
12:23:25 <astrolabe> Cale: sure, I didn't mean a proof
12:23:38 <Cale> ah, that kind of argument :)
12:23:40 <takuan> can somebody suggest me a simple example when Haskell can't decide the type to use by itself?
12:23:48 <takuan> I had one today, but I forgot it
12:24:00 <Cale> takuan: anything involving existential types, I think
12:24:07 <Cale> and many things involving GADTs
12:24:21 <astrolabe> But I think the cardinality of the ordinals jumps from aleph_0 to c.
12:24:22 <takuan> GADTs
12:24:24 <Cale> with extensions turned off, it should always be able to decide
12:24:24 <takuan> ?
12:24:34 <Cale> Generalised Algebraic Datatypes
12:24:50 <takuan> humz
12:26:59 <astrolabe> takuan: is this what you mean
12:27:05 <astrolabe> > read "3"
12:27:06 <lambdabot> Add a type signature
12:33:01 <xerox> What is c in c=\aleph_2 ?
12:33:10 <xerox> Complex numbers?
12:33:33 <astrolabe> The number of real numbers
12:33:41 <xerox> Why is it c?
12:33:48 <astrolabe> for continuum
12:33:51 <xerox> I see.
12:34:18 <sieni> xerox: the cardinality of the continuum (usually in different font, though)
12:34:48 <astrolabe> \aleph_2 is the 3rd infinite cardinal.
12:35:43 <takuan> astrolabe: something like that
12:36:52 <SamB> how would I use HXT with SGML?
12:38:35 <sieni> is there some autopush feature in darcs (i.e. I want to automatically push changes to backup repositories on "darcs record") 
12:39:16 <eivuokko> You could write posthook, I guess.
12:39:40 <SamB> for sure you could
12:39:57 <eivuokko> But it's not really how one uses darcs usually
12:40:09 <astrolabe> scannedinavian.org down?
12:40:44 <SamB> sieni: you could also just rsync periodically...
12:40:46 <sieni> I don't want to worry about backups, so I want to autopropagate changes to several places
12:42:04 <SamB> get users?
12:43:32 <eivuokko> sieni, well, in that case you better lookup --posthook and add it to your prefs.
12:45:22 <newsham> hi
12:45:33 <eivuokko> Hello
12:45:52 <newsham> I'm getting some weirdness that I dont understand.
12:46:18 <newsham> sum' = fold (+) 0   <- complains of no fractional Int,  but if I use 0.0 its ok
12:46:32 <newsham> average x = sum' x / length x   <- complains that sum' returns a Double and not an Int
12:47:01 <newsham> this is in hugs, btw.
12:47:05 <musasabi> newsham: your problem is (/)
12:47:17 <newsham> what division function should I be using?
12:47:21 <musasabi> mod
12:47:32 <newsham> isnt mod the residue?
12:47:43 <musasabi> *div*
12:48:01 <Cale> > 11 `div` 3
12:48:02 <lambdabot> 3
12:48:12 <musasabi> > let sum' = fold (+) 0; average x = sum' x `div` length x; in average [1..40]
12:48:13 <lambdabot>  Not in scope: `fold'
12:48:17 <newsham> sum' x `div` length x       type : double does not match type : Int
12:48:19 <musasabi> > let sum' = foldl (+) 0; average x = sum' x `div` length x; in average [1..40]
12:48:20 <lambdabot> 20
12:48:56 <newsham> > let sum' = foldl (+) 0; average = sum' x `div` length x; in average [0.5, 0.2, 0.3, 0.9]
12:48:57 <Cale> > let sum' = foldl (+) 0; average x = sum' x / (fromIntegral $ length x); in average [1..40]
12:48:58 <lambdabot>  Not in scope: `x'
12:48:59 <lambdabot> 20.5
12:49:26 <sieni> eivuokko: thanks
12:49:34 <newsham> fromIntegral?
12:49:54 <newsham> > let sum' = foldl (+) 0; average x = sum' x `div` length x; in average [0.5, 0.2, 0.3, 0.9]
12:49:55 <lambdabot>  add an instance declaration for (Fractional Int)
12:49:55 <lambdabot>   In the list element: 0.9
12:50:31 <newsham> tada.  no workie.
12:51:42 <newsham> > sum' [0.5, 0.2, 0.3, 0.9]
12:51:43 <lambdabot>  Not in scope: `sum''
12:51:58 <newsham> > let sum' = foldl (+) 0; in sum' [0.5, 0.2, 0.3, 0.9]
12:51:59 <lambdabot> 1.9
12:52:02 <malcolm> the problem is that length returns an Int.
12:52:10 <newsham> > 1.9 / 4
12:52:11 <lambdabot> 0.475
12:52:24 <malcolm> > 1.9 / (4::Int)
12:52:25 <lambdabot>  add an instance declaration for (Fractional Int)
12:53:08 <newsham> so how can I perform a division between a numeric and an integer?
12:53:10 <malcolm> let sum' = foldl (+) 0; average x = sum' x `div` fromIntegral (length x); in average [0.5, 0.2, 0.3, 0.9]
12:53:33 <malcolm> > let sum' = foldl (+) 0; average x = sum' x `div` fromIntegral (length x); in average [0.5, 0.2, 0.3, 0.9]
12:53:34 <lambdabot> Add a type signature
12:53:59 <malcolm> > let sum' = foldl (+) 0; average x = sum' x `div` fromIntegral (length x); in average [0.5, 0.2, 0.3, 0.9] :: Double
12:54:00 <lambdabot>  add an instance declaration for (Integral Double)
12:54:00 <lambdabot>   In the definition of `average':
12:54:00 <lambdabot>    average x = (sum' x) `div` (fromIntegral (length x))
12:54:12 <newsham> danke.  fromIntegral fixed my woes
12:54:28 <malcolm> > let sum' = foldl (+) 0; average x = sum' x / fromIntegral (length x); in average [0.5, 0.2, 0.3, 0.9]
12:54:29 <lambdabot> 0.475
12:54:37 <malcolm> got there in the end...
12:55:25 <SamB> how do I parse identifiers that aren't allowed to end with :?
12:55:46 <SamB> just pretend thats the only rule ;-)
12:56:02 <xerox> > let average xs = (sum *** List.genericLength) >>> uncurry (/) in average [1..10]
12:56:03 <lambdabot>  add an instance declaration for (Show (([i], [b]) -> i))
12:56:13 <xerox> > let average xs = (sum &&& List.genericLength) >>> uncurry (/) in average [1..10]
12:56:13 <newsham> is there a better way to do this?  :   boundedSeries x = [v | (v,s) <- takeWhile (\(v,acc) -> (acc <= 1.0)) (zip x (sums x))]
12:56:14 <lambdabot>  add an instance declaration for (Show ([i] -> i))
12:56:17 <xerox> Heh.
12:56:37 <xerox> > let average = (sum &&& List.genericLength) >>> uncurry (/) in average [1..10]
12:56:38 <lambdabot> 5.5
12:56:42 <xerox> Thanks!
12:57:06 <newsham> what is (***) ?
12:57:21 <SamB> @type (Control.Arrow.***)
12:57:22 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
12:57:22 <lambdabot> (Control.Arrow.Arrow a) =>
12:57:22 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
12:57:34 <newsham> xerox: that definition doesnt seem very intuitive.
12:57:42 <xerox> It depends.
12:57:48 <SamB> @type (Control.Arrow.&&&)
12:57:49 <lambdabot> forall (a :: * -> * -> *) c' c b.
12:57:49 <lambdabot> (Control.Arrow.Arrow a) =>
12:57:49 <lambdabot> a b c -> a b c' -> a b (c, c')
12:58:01 <SamB> @type (Control.Arrow.>>>)
12:58:02 <lambdabot> forall (a :: * -> * -> *) d b c.
12:58:02 <lambdabot> (Control.Arrow.Arrow a) =>
12:58:02 <lambdabot> a b c -> a c d -> a b d
12:58:22 <SamB> @type ($)
12:58:22 <lambdabot> forall b a. (a -> b) -> a -> b
12:58:38 <SamB> @type (.,)
12:58:39 <lambdabot> parse error on input `,'
12:58:41 <SamB> @type (.)
12:58:41 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
13:00:09 <SamB> anyway, how would I implement something like /.*[^:]/ in parsec?
13:04:17 <ADEpt> SamB: i recall there is something like notFollowedBy
13:04:25 <ADEpt> @hoolge notFollowedBy
13:04:25 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok =>
13:04:25 <lambdabot> GenParser tok st tok -> GenParser tok st ()
13:05:21 <newsham> anyone want to take a crack at doing this The Haskell Way?  http://www.lava.net/~newsham/x/machine/e.py
13:05:24 <ADEpt> SamB: and there was thread about that week or two ago in cafe
13:05:35 <newsham> i've given it a whilr but my code isnt so nice :\
13:06:48 <newsham> (my incomplete code is at: http://www.lava.net/~newsham/x/e.lhs)
13:08:15 <araujo> What is a good way to get "file1" from = "|[file1])"?
13:08:50 <SamB> okay, I figured it out,
13:08:59 <SamB> it isn't very pretty though
13:11:58 <ADEpt> SamB: btw, I did horrible things to conjure :)
13:12:10 <ADEpt> SamB: twisted threads this way and that
13:12:35 <ADEpt> SamB: if you are interested, you know from where to pull :)
13:16:27 <SamB> ADEpt: hmm, I have to go somewhere in 15 minutes anyway, so I think I'll stick with implementing DSSSL for now
13:16:46 <ADEpt> @localtime SamB
13:16:48 <lambdabot> Local time for SamB is Thu Dec  1 16:17:24
13:17:12 * ADEpt . o O (hmm.. too early for a dog ;)
13:17:35 <ADEpt> SamB: DSSSL as in dynamic something stylesheets language, for docbook?
13:23:19 <astrolabe> newsham: Could you use something like ' length $ takeWhile (< 1.) (sums uniform) '?
13:23:24 <phys_rules> @where darcs
13:23:25 <lambdabot> http://darcs.net/
13:24:41 <newsham> astro: yah.  definitely.  originally i was trying to return the original items from x
13:24:54 <newsham> but now I'm just returning the list, so yah, I should od that
13:24:59 <newsham> err.,. just returning the lnegth
13:25:46 <newsham> updated.. thanks.
13:26:15 <newsham> a lot of the awkwardness in this is dealing with the random number stream.  :\
13:27:54 <astrolabe> isn't there a library for doing all that?
13:28:04 <newsham> *shrug*
13:33:16 <astrolabe> 'There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad.  It is initialised automatically in some system-dependent fashon, for example, by using the time of day, or Linux's kernel random number generator.'
13:34:13 <astrolabe> getStdGen :: IO StdGen
13:34:28 <astrolabe> gets the global random number generator
13:37:58 <newsham> astro: you'll note that e.lhs uses stdGen
13:39:00 <newsham> the awkwardness i refer to is the code having to repeatedly call "drop" to avoid reusing random numbers
13:39:10 <newsham> (either that or write the code in a monadic style)
13:39:45 <newsham> any suggestions welcome
13:40:43 <astrolabe> I've never done this, but looking at the report, I guess you want to use getStdRandom rather than mkStdGen
13:41:03 <newsham> nah, i want to seed the generator so i get unique values each run
13:41:36 <xerox> time || ~pid? :-)
13:41:58 <astrolabe> newsham: won't getStdGen do that?
13:44:28 <newsham> nope. try it out.
13:45:08 <newsham> main = do  gen <- getStdGen ; putStr $ show $ take 5 gen
13:45:44 <newsham> err.  randoms gen
13:46:26 <cinema> malcolm, ping
13:46:29 <newsham> E> do gen <- getStdGen; putStr $ show $ take 5 (randoms gen :: [Float])
13:46:30 <newsham> [0.4829781,0.5275123,0.3161012,0.4684335,0.002503544]
13:46:30 <newsham> E> do gen <- getStdGen; putStr $ show $ take 5 (randoms gen :: [Float])
13:46:30 <newsham> [0.4829781,0.5275123,0.3161012,0.4684335,0.002503544]
13:46:50 <malcolm> cinema: pong
13:47:07 <cinema> malcolm, Hi, I have some problems with Blobs
13:47:23 <malcolm> cinema: fire away
13:47:31 <cinema> malcolm, when re-readind files saved by Blobs
13:47:54 <cinema> I have errors in XML decoding
13:48:10 <malcolm> cinema: oh right, yes there are some problems with the parser combinators.
13:48:26 <malcolm> cinema: I've been working on fixing them in HaXml this week.
13:48:29 <cinema> example : when reading wirings.blobs
13:49:04 <cinema> malcolm, btw, building HaXml was not very easy
13:49:15 <malcolm> cinema: tell me more
13:49:30 <cinema> malcolm, may be because I have a ghc coming from HEAD
13:50:03 <malcolm> cinema: were the HaXml problems anything to do with multi-line strings?
13:50:12 <cinema> malcolm, so by default it does not generate a.out anymore
13:50:32 <cinema> malcolm, yes, 2 files need being modified for multi-line
13:50:57 <malcolm> cinema: the multi-line thing will go away in the fixed release of HaXml
13:51:13 <cinema> malcolm, good news
13:51:22 <malcolm> cinema: the a.out thing should be easy to overcome too
13:51:40 <astrolabe> newsham: I think you need to use getStdRandom too, but my monads are rusty :D
13:52:21 <cinema> malcolm, yes in the end I succeeded in building HaXml
13:53:12 <cinema> malcolm, I will try again now, to see if there are other things
13:53:17 <malcolm> cinema: the ghc version number you are using?
13:53:37 <malcolm> cinema: are you using the CVS version of HaXml, or the release?
13:54:04 <malcolm> cinema: I haven't yet rolled up a package of HaXml-1.15 - that is tomorrow's job
13:54:10 <cinema> malcolm, darcs version of HaXml, and CVS version (3 weeks ago) HEAD of ghc
13:54:46 <malcolm> cinema: I'm not very good at keeping the darcs version in synch with the CVS.  I'll try to do that tomorrow as well.
13:55:22 <cinema> malcolm, OK, so I'll rebuild everything this week-end, & keep you informed in case of trouble
13:56:18 <malcolm> cinema: sure, send bug reports to the Blobs list.
13:56:46 <cinema> malcolm, I'll do that
14:00:41 <astrolabe> newsham: It works!
14:00:55 <astrolabe> I've got
14:01:47 <astrolabe> main = do dice <- getStdRandom (randomR (1,6::Int)); print dice
14:01:53 <astrolabe> I compile it once
14:02:05 <astrolabe> everytime I run it, it gives a different answer
14:02:22 <astrolabe> (that's an exageration, but you see what I mean)
14:02:53 <astrolabe> Oh he's left :(   grrrr
14:07:06 <phys_rules> darn, darcs doesn't compile
14:22:33 <ADEpt> @index unsafePerformIO
14:22:33 <lambdabot> System.IO.Unsafe, Foreign
14:22:44 <xerox> @type Foreign.unsafePerformIO
14:22:45 <lambdabot> forall a. IO a -> a
14:23:24 <xerox> @type GHC.Exts.unsafeCoerce# :: IO a -> b
14:23:25 <lambdabot> IO a -> b :: forall a b. IO a -> b
14:23:28 <xerox> <grin>
14:24:07 <ADEpt> @index liftIO
14:24:08 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
14:24:08 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
14:24:08 <lambdabot> Control.Monad.List
14:25:44 <ADEpt> @hoogle liftIO
14:25:45 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:25:45 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
14:26:16 <araujo> @index splitWith
14:26:16 <lambdabot> bzzt
14:26:30 <araujo> mm...
14:26:34 <araujo> @hoogle splitWith
14:26:35 <lambdabot> Data.PackedString.splitWithPS :: (Char -> Bool) -> PackedString -> [
14:26:35 <lambdabot> PackedString]
14:36:43 <araujo> @hoogle splitAt
14:36:44 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
14:36:44 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:36:44 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString,
14:36:44 <lambdabot> PackedString)
14:38:39 <xerox> Goodnight.
14:40:06 <ADEpt> araujo: the thing that you are looking for is in PreludeExts on wiki :)
14:52:59 <ADEpt> am I right that atomically from STM does not go well with unsafePerformIO ?
14:53:50 <Cale> heh
14:54:25 <Cale> there's no reason it shouldn't work
14:54:34 <integral> I think Pugs does that in several places :)
14:54:42 <integral> the unsafe doesn't make the atomic not atomic
14:56:56 <ADEpt> I got:
14:56:56 <ADEpt> conjure: internal error: ASSERTION FAILED: file STM.c, line 745
14:57:11 <integral> that looks like a bug... :)
14:58:32 <ADEpt> I try to:
14:58:32 <ADEpt> logChannel = unsafePerformIO $ do ch <- atomically Chan.newTChan 
14:58:32 <ADEpt>                                   return ch
14:58:32 <ADEpt> and then when I send to that TChan, I get the error I posted
14:58:49 <Khisanth> does ghc try to keep everything it's building in memory?
14:58:52 <phys_rules> @where hmp3
14:58:52 <lambdabot> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/hmp3
15:00:23 <ADEpt> anyone have STM.c handly to tell me what assertion is violated?
15:01:28 <integral> @libsrc STM.c
15:01:29 <lambdabot> STM.c not available
15:02:20 <arjanb> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/rts/STM.c?rev=1.10
15:11:18 <phys_rules> where can I upload the ghc-6.4.1 for x86 solaris ?
15:13:50 <ADEpt> @index newEmptyMVar
15:13:51 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
15:16:38 <autrijus> @seen SyntaxNinja
15:16:39 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. Last spoke 3 hours, 26
15:16:39 <lambdabot> minutes and 20 seconds ago.
15:23:16 <ptolomy> Semi-OT: What is the highest-level non-GC language around? 
15:24:51 <ndm> ptolomy: probably Ada
15:25:21 <wilx> Ada has GC.
15:25:21 <ndm> although to be fair, Haskell isn't a garbage collected language - thats just the standard implementation
15:25:26 <wilx> At least it can have one.
15:25:32 <wilx> It is not required though.
15:25:41 <ndm> wilx, it can, but the standard one doesn't - it uses stacks of types for inference
15:25:56 <ndm> jhc is a haskell compiler without GC
15:26:01 <wilx> Standard one?
15:26:12 <ptolomy> ndm: What does it do to deal with memory then?
15:26:21 <wilx> The GC is imho spoken about in Ada's standard.
15:26:36 <malcolm> MLKit is a strict functional language with region interence instead of GC
15:27:13 * ptolomy looks up region inference.
15:28:20 * ihope is stuck on points-free-ness
15:28:53 <ptolomy> ihope: How so?
15:29:22 <ihope> Defining "ignore = flip seq ()" rather than "ignore x = seq x ()". Stuff like that.
15:33:00 <ihope> fac = foldr (*) 1 . enumFromTo 1 :-)
15:36:40 <phys_rules> I was using gmp's factorial
15:36:43 <Cale> fac = y (\f n -> if n == 0 then 1 else n * f (n - 1)) where y f = f (y f)
15:36:47 <phys_rules> and it crashed on (10^6)!
15:37:09 <psi> @pl fac n = product [1..n]
15:37:10 <lambdabot> fac = product . enumFromTo 1
15:37:16 <Pseudonym> I think I have the fastest factorial in Haskell so far.
15:37:37 <phys_rules> they're all slow anyway :)
15:37:49 <Cale> phys_rules: how long did it take to crash?
15:38:01 <phys_rules> Cale: 10-15 seconds
15:38:11 <ihope> Psuedonym: how fast is it?
15:38:23 <Pseudonym> ihope: What number would you like factorialised?
15:38:24 <Cale> let's see how mathematica does
15:38:32 <Cale> if my cpu doesn't just overheat
15:38:33 <phys_rules> Pseudonym: 10^6
15:38:35 <ihope> 32 would do nicely
15:38:39 <phys_rules> mathematica does it very fast
15:38:45 <Cale> done
15:38:49 <Cale> :)
15:38:56 <phys_rules> yep, told you
15:40:17 * ihope go /away
15:40:21 <phys_rules> well, the obvious optimization would be to not multiply by the numbers that are a multiple of 10, but just by the leading number
15:40:22 <phys_rules> and just adding the zeros at the end
15:40:28 <phys_rules> but I bet mathematica does much more magic =)
15:40:46 <phys_rules> Anyway can try their gmp's factorial ?
15:41:31 <Pseudonym> OK, hang on.  Computing it now.
15:41:33 <Cale> apparently it uses some kind of divide and conquer algorithm to keep the binary strings of digits to multiply roughly balanced in length
15:41:49 <Pseudonym> Mine uses a much trickier algorith, than that.
15:43:05 <phys_rules> Cale: yes, but so does gmp
15:43:09 <phys_rules> Cale: and yet gmp is slower
15:43:10 <Pseudonym> My algorithm uses the Legendre expansion.
15:43:17 <phys_rules> and even crashes on big numbers :)
15:43:21 <phys_rules> at least my 4.1.4
15:43:23 <Pseudonym> And then uses binary multiplication to combine the results.
15:43:32 <Pseudonym> s p 0 = 0
15:43:38 <Pseudonym> s p n = let (q,r) = n `divMod` p in s p q + r
15:43:52 <Pseudonym> Using that function, s p n is the sum of the base-p digits of n.
15:44:16 <phys_rules> so how fast is it ? ;)
15:44:27 <Pseudonym> Prelude Math.Combinatorial> factorial 1000000 `seq` ()
15:44:29 <Pseudonym> ()
15:44:29 <Pseudonym> (49.47 secs, 1128541028 bytes)
15:44:33 <Pseudonym> Is that fast?
15:44:59 <phys_rules> well mathematica does it 7 seconds on a slow puter :|
15:45:36 <phys_rules> try running it as executable maybe ?
15:45:48 <phys_rules> and write the result into a file, so that things are a bit faster
15:47:51 <Pseudonym> Well, I didn't write the result at all.
15:47:59 <Pseudonym> Actually, I think I need to use a faster prime sieve.
15:48:06 <Pseudonym> I'm using a straight Eratosthenes sieve.
15:48:10 <Pseudonym> I should use a Bernstein sieve.
15:50:55 <Pseudonym> Anyway, my method is to produce a prime power expansion of factorial n.
15:51:19 <Pseudonym> If you think about it, the only prime numbers which appear in the expansion of n! are those which are less than or equal to n.
15:51:35 <Pseudonym> The cool bit is that the prime power expansion can be represented using only machine words.
15:52:48 <Pseudonym> For example, the power of 2 in factorial 1000000 is 2^999993.
15:52:58 <Pseudonym> Nice and small.
15:57:23 <phys_rules> on my machine (very old athlon 850)
15:57:31 <phys_rules> just compiled a small fact
15:57:33 <phys_rules> using gmp
15:57:43 <phys_rules> it calcules it, but on large numbers it dumps core on print
15:57:46 <phys_rules> so I removed the print
15:57:53 <Pseudonym> How long did it take?
15:57:56 <phys_rules> 14 seconds
15:58:02 * Pseudonym nods
15:58:08 <Pseudonym> I think it uses a better sieve.
15:58:33 <phys_rules> where can I find the fastest implementation of factorial in haskell ?
15:58:39 <phys_rules> so I can try to run it here as well
15:59:27 <Pseudonym> http://andrew.bromage.org/darcs/
15:59:37 <Pseudonym> Note that I haven't gone to a lot of trouble of tuning it.
15:59:52 <Pseudonym> Actually, the multiplication is much smarter in this.
16:00:00 <ADEpt> @where QuickCheck
16:00:01 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:00:03 <Pseudonym> I could modify mine to do this.
16:00:30 <dons> Moin
16:01:25 <rep> http://www.davidsteele.com/usb_digital_bible.html 
16:03:03 <phys_rules> Pseudonym: how should I run it so it won't output anything ?
16:03:17 <Pseudonym> factorial 1000000 `seq` ()
16:03:20 <Pseudonym> That's what I did.
16:04:24 <phys_rules> Pseudonym: ok, compiling ;)
16:13:06 <phys_rules> Pseudonym: (42.32 secs, 1303020844 bytes)
16:13:17 <Pseudonym> Right.
16:13:19 <phys_rules> so your machine is even older than mine ? =)
16:13:33 <Pseudonym> Probably.  I think it's a 1GHz Pentium IV.
16:13:38 <Pseudonym> About 3 years old.
16:14:01 <Pseudonym> No, 2GHz.
16:14:03 <phys_rules> 850 athlon here, 5 years old
16:14:05 <Pseudonym> bogomips       : 3997.69
16:14:23 <phys_rules> how do you find the bogomips ? :)
16:14:31 <Pseudonym>  /proc/cpuinfo
16:14:45 <Pseudonym> Did you know that proc/cpuinfo isn't an IRC command?
16:14:50 <Pseudonym> You learn something every day.
16:15:39 <phys_rules> except that i'm on solaris =)
16:15:45 <phys_rules> and there's no /proc/cpuinfo ;)
16:15:54 <phys_rules> must be another command..
16:16:16 <dons> Lemmih, just fixed that seeking issue in hmp3, if you'd like to try it.
16:16:48 * Lemmih_ pulls.
16:17:43 <phys_rules> Pseudonym: still it's weird
16:17:52 <phys_rules> Pseudonym: my puter is way older than your
16:17:54 <phys_rules> yours
16:17:57 <dons> it took all of about 30 seconds to fix, once i'd had some sleep :)
16:19:48 <musasabi> getting Solaris installed @ home seems harder than it seemed (I have solaris @ uni) but this looks like no-go.
16:20:27 <phys_rules> musasabi: I even had to manually patch some boot scripts =)
16:20:34 <phys_rules> as it didn't load at all =)
16:20:36 <dons> why would you want to install solaris at home? seriously..
16:20:42 <phys_rules> solaris rocks!
16:20:49 <musasabi> dons: testing.
16:20:49 <dons> hehe
16:20:54 <Lemmih> dons: Neat. But it messed up the time counter pretty bad. (:
16:21:00 <dons> oh, didn't see that.
16:21:12 <phys_rules> musasabi: btw, where can I upload the ghc build for solaris ?
16:21:13 <dons> how?
16:21:23 <dons> Lemmih, I don't see any issues here. what happens?
16:21:26 <phys_rules> musasabi: it's not super duper fancy, one has to manually tweak package.conf but it works
16:21:31 * Lemmih watches it jump randomly from 1:20 to 1:50.
16:21:38 <dons> randomly?
16:21:46 <musasabi> phys_rules: upload it anywhere you want (if you don't have a location I can help) and post to ghc-users so the build will be added.
16:22:34 <musasabi> just add the warnings to the message - because getting to where you are is quite hard for most people.
16:22:40 <phys_rules> musasabi: I don't have a location unfortunately :(
16:23:08 <phys_rules> and ghci must be recompiled probably with the full readline support as now it's not very comfortable =)
16:23:19 <phys_rules> as it doesnt understand backspace and all =)
16:23:32 <dons> Lemmih, more info please. does it incrememnt by unexpectedly large amounts? or is there a delay incrementing the counter? I don't understand what you mean by messed up"
16:25:22 <Lemmih> dons: It counts normally, then suddenly jumps back a couple of seconds and then jumps back to normal again.
16:26:12 <dons> when does it do the sudden jump, in relation to when you try to seek?
16:26:19 <dons> before or after, or during
16:27:40 <Lemmih> It behaves like that even when I haven't performed any seeks.
16:27:59 * Cale wonders why the Firefox 1.5 release notes look so terrible in Firefox 1.5
16:28:06 <dons> oh. hmm.
16:28:59 <dons> I only made a fairly minor change, but this didn't happen yesterday?
16:29:12 <dons> and it happens without ever doing a seek?
16:30:08 <Lemmih> I'll try it without forceNextPacket.
16:30:24 <dons> thanks.
16:30:52 <dons> and try it on a couple or more different .mp3 files
16:31:03 <dons> since it's possible you have one that has funny frames, i guess.
16:32:08 <dons> oh, it could be on a slow machine the number of dropped packets is too high, maybe.
16:32:25 <dons> which would cause the clock to appear a bit jittery
16:36:17 <Lemmih> Hm. Looks like it's the mp3 file.
16:37:00 <dons> i just put in a patch to drop only 9/10 packets. maybe try that just in case.
16:37:29 <dons> it does stop the tiny jitters in clock updates when frames don't arrive on time each second
16:48:28 <phys_rules> good night guys
16:50:32 <Pseudonym> Hmmm.
16:50:33 <Pseudonym> Night.
16:51:13 <Pseudonym> Damn.
16:51:29 <Pseudonym> Unfortunately, there's no easy way to work out if a GHC Integer has overflowed into a GMP integer or not.
16:51:46 <dons> really?
16:51:53 <Pseudonym> Easy and efficient.
16:51:58 <Pseudonym> You can test n > 2^32 or something.
16:51:59 <SamB> Pseudonym: scrutiny usually does the trick...
16:52:00 <musasabi> Pseudonym: yes there is.
16:52:05 <Pseudonym> How?
16:52:07 <Pseudonym> I tried:
16:52:11 <SamB> ata Integer
16:52:11 <SamB>   = S# GHC.Prim.Int# | J# GHC.Prim.Int# GHC.Prim.ByteArray#
16:52:16 <dons> you can't just check the tags?
16:52:16 <musasabi> import GHC.Int
16:52:17 <SamB> er, I'm missing the d
16:52:25 <Pseudonym> Oh, you need to import GHC.Int.
16:52:27 <Pseudonym> Ah.
16:52:37 <dons> it's either S# or J# for big nums
16:52:47 <dons> GHC.Num
16:53:09 <musasabi> yes, Num
16:53:38 <dons> now, why is the 'J' tag used for big nums?
16:53:41 <Pseudonym> I was trying to do that without importing that.
16:53:44 <dons> S == small, J == ?
16:53:45 <Pseudonym> dons: I# is used for Int.
16:53:52 <dons> ah , right.
16:53:57 <musasabi> isBig (S# _) = False; isBig _ = True
16:54:23 <dons> you could also check if it was over maxBound Int, couldn't you?
16:54:33 * SamB wonders how to handle DSSSL keywords...
16:54:39 <dons> or is there some reason why that doesn't work?
16:54:59 <Pseudonym> It works, but you need to do a comparison.
16:55:05 <Pseudonym> And big integer comparison is too expensive.
16:55:24 <dons> ok. then tags it is!
16:55:26 <musasabi> dons: that does not work.
16:55:42 <Pseudonym> Let me see if this sped things up.
16:56:04 <Pseudonym>         gather n [] = [n]
16:56:04 <Pseudonym>         gather n (x:xs)
16:56:04 <Pseudonym>             = case nx of
16:56:04 <Pseudonym>                 S# _   -> gather nx xs
16:56:04 <Pseudonym>                 J# _ _ -> nx : gather 1 xs
16:56:05 <Pseudonym>             where
16:56:05 <musasabi> let x = 10000000000000000000000; y = x `div` x
16:56:07 <Pseudonym>                 nx = n * x
16:56:23 <musasabi> Both x and y are bignums.
16:56:41 <musasabi> although y == 1.
16:58:50 <SamB> J = Jigantic
16:59:27 <dons> hehe
16:59:41 <jethr0> J = Jumbo
17:00:23 <Pseudonym> Hmmm.  That didn't speed anything up at all.
17:02:57 <Pseudonym> Guess it's time to start profiling.
17:03:22 <SamB> heh, isn't it a bit overdue?
17:08:39 <Pseudonym> You'd think so.  But actually, when writing general-purpose libraries, profiling is one of the last things I do.
17:08:47 <Pseudonym> Getting the right algorithm is more important, IMO.
17:09:33 <SamB> true
17:25:07 <jethr0> samb: i am not so sure anymore whether "porting" libc to haskell is sensible.
17:25:20 <jethr0> but i'll just keep on doing it until my motivation runs out ;-))
17:25:20 <Pseudonym>         gather n []              = n `seq` [n]
17:25:20 <Pseudonym>         gather n@(S# _) (x:xs)   = gather (n*x) xs
17:25:20 <Pseudonym>         gather n@(J# _ _) (x:xs) = n : gather x xs
17:25:25 <Pseudonym> I'm kinda proud of that function.
17:27:05 <Pseudonym> Woah.
17:27:16 <Pseudonym> That's actually quicker than doing a Legendre expansion.
17:27:21 <Pseudonym> Weird.
17:27:37 <Pseudonym> Like, twice the speed.
17:38:06 <SamB> SF looks like XP now?
17:39:48 <Pseudonym> Prelude Math.Combinatorial> factorial 1000000 `seq` ()
17:39:52 <Pseudonym> ()
17:39:52 <Pseudonym> (23.77 secs, 353978636 bytes)
17:40:02 <Pseudonym> That's within a factor of two.
17:40:25 <Saulzar> Hmm, I'm having some issues pattern matching a list .. for some bizzare reason it is matching a non empty list on [] if I use type of Ord a, but not with Int directly ...
17:40:45 <dons> you could have a look at the C code generated, Pseudondym
17:40:50 <Pseudonym> I should, yes.
17:41:00 <Pseudonym> I suspect it's that I do more structure hacking than the GMP one does.
17:41:00 <dons> sometimes a little bit of explicit unboxing helps get the write C ops generated
17:41:01 <SamB> also try -fasm
17:41:03 <Pseudonym> Since I use lazy lists.
17:41:32 <Pseudonym> I'll try -fasm first.
17:41:39 <dons> this turns into 3 C ops: 
17:41:40 <dons> getRandom _ = do
17:41:41 <dons>     (I32# i) <- c_arc4random
17:41:41 <dons>     return (I# (word2Int# ((int2Word# i `and#` int2Word# 0xffff#)
17:41:41 <dons>                     `remWord#` int2Word# 52#)))
17:41:44 <dons> :)
17:42:22 <Pseudonym> -fasm doesn't seem to help
17:42:36 <SamB> well, its not really expected to help
17:42:40 <Pseudonym> Sure.
17:42:46 <SamB> but apparantly it sometimes does ;-)
17:43:03 <dons> hmm, but I think -fvia-C is encouraged for lots of math
17:43:16 <SamB> ah, yes, probably
17:43:33 * SamB certainly imagines that -fvia-C would help most with math
17:44:06 <dons> and you need thing slike -fexcess-precision when use -fasm and lots of floats
17:44:16 <Pseudonym> Well I don't use floats.
17:44:23 <Pseudonym> This is all big integers.
17:45:08 <dons> ah, righto.
17:45:42 <Pseudonym> You don't need floats to compute factorials.
17:46:54 <jethr0> any idea how to set points with FFI?
17:46:58 <jethr0> pointers*
17:47:20 <jethr0> is there maybe a pokePtr or something like that?
17:50:33 <SamB> jethr0: you mean with like Ptr Ptr?
17:50:41 <SamB> er, Ptr (Ptr a)
17:51:10 <eivuokko> Foreign.Storable has Storable class that might be what you want.
17:51:43 <jethr0> hmm. i've got a Ptr CString / Ptr (Ptr CChar) and i'd like to set it to the value of another pointer.
17:51:44 <SamB> jethr0 is implementing libc in Haskell ;-)
17:51:56 <eivuokko> o.O
17:52:02 <jethr0> i'm struggling. but it's a good exercise in FFI anyways.
17:52:07 <eivuokko> :)
17:52:13 <eivuokko> And hope it's fun ;)
17:52:29 <jethr0> until now - it has been...
17:53:15 * eivuokko is reading ghc rts
17:53:39 <jethr0> but i am finally seeing how VERY dangerous the c library is! try implementing "strtol" and you'll know what i mean ;-)
17:53:44 <eivuokko> ;p
17:54:10 <jethr0> no, bad example. but there's some good shoot-yourself-in-the-foot opportunities out there.
17:54:19 <dons> hehe. lots of weird functions with weird semantics, yeah.
17:54:35 <eivuokko> It's *so* old api.
17:54:51 <jethr0> yeah, and if something goes wrong it is by definition the user's fault.
17:54:58 <jethr0> the library is responsible for NOTHING!
17:55:10 <musasabi> grah. I need to find a darwin / mac os x machine to test what is breaking getaddrinfo (or my autoconf magic) there :-(
17:57:30 <eivuokko> Was ghc Windows support dropped at some point?  I wonder why rts as dll support was left to bitrot.
17:58:02 <jethr0> eivuokko: what are you planning to do with the RTS?
17:58:11 <musasabi> eivuokko: well the shared libs side is not much better on linux ;)
17:58:25 <eivuokko> Nothing for now, I just want to be able to understand how it works.
17:58:43 <jethr0> can someone tell me how try/catch works? i can't find any usage examples ;-(
17:59:00 <eivuokko> musasabi, Hmh.
17:59:30 <eivuokko> musasabi, There aren't much anything special in compiling rts as shared lib/libs, is there?
17:59:38 <eivuokko> I mean technically.
18:00:41 <musasabi> it is mostly toolchain mess I think.
18:01:11 <eivuokko> Ah, that makes sense (sadly).
18:01:15 <musasabi> what goes into which section and how you can get from memory locations to symbols and the reverse.
18:01:31 <musasabi> nasty details which are not very nice.
18:01:34 <eivuokko> Hmh
18:01:57 <eivuokko> But that isn't *rts* problem, but problem if haskell libs are shared?
18:03:51 <eivuokko> Hmmm.  Is there something special in those symbols, say something harder than C++ rtti/exception information?
18:04:10 <jethr0> can someone help me with catching an error from read?
18:04:30 <eivuokko> Uhm
18:04:35 <Pupeno> Hello.
18:04:39 <eivuokko> Hiya
18:04:42 <Lemmih> Control.Exception.catch (error "hello") (\_ -> putStrLn "Error caught")
18:04:43 <Lemmih> Error caught
18:04:57 <jethr0> i tried: catch (do d = read "asdf23"; return d) (\e -> return 0)
18:04:58 <Lemmih> jethr0: Perhaps you want to use 'reads' instead.
18:05:02 <dons> or even: 
18:05:03 <dons> readM :: (Monad m, Read a) => String -> m a
18:05:03 <dons> readM s = case [x | (x,t) <- {-# SCC "Serial.readM.reads" #-} reads s    -- bad!
18:05:06 <dons>                , ("","")  <- lex t] of
18:05:08 <dons>         [x] -> return x
18:05:11 <dons>         []  -> fail "Serial.readM: no parse"
18:05:13 <dons>         _   -> fail "Serial.readM: ambiguous parse"
18:05:16 <dons> :)
18:05:18 <dons>  ignore the SCC ;)
18:05:58 <jethr0> thx, reads seems like a better choice...
18:06:19 <Lemmih> jethr0: The 'catch' from Prelude will only catch IOError's.
18:06:47 <jethr0> lemmih: so i should be using Exception.catch?
18:07:29 <Pupeno> How does Haskell + Distributed Haskell compare to Erlang ?
18:07:46 <Lemmih> jethr0: If you just want parse something with 'read' then 'reads' or 'readM' would suffice.
18:07:51 <SamB> its apparantly even prettier
18:07:59 <SamB> but its probably not adequate for telecoms
18:08:21 <musasabi> eivuokko: well it is quite a lot harder.
18:08:50 <musasabi> eivuokko: GHC does it's own loading which means that it and the toolchain have to agree on things.
18:09:41 <SamB> couldn't it use libdl to load shared libs?
18:09:49 <eivuokko> musasabi, Hmmm.  I guess I better first learn how stuff is represented in memory, then.  Thanks, it's fairly fun to read.
18:09:59 <SamB> or are there symbol table issues with that?
18:10:02 <eivuokko> Suprisingly clean, the rts.
18:11:15 <musasabi> SamB: it mixis -ldl with it's own stuff.
18:11:20 <musasabi> *mixes
18:11:30 <musasabi> rts/Linker.c is the place.
18:11:41 <SamB> ah
18:12:25 <eivuokko> Ah, it was one of the files I skipped because it looked big.
18:28:12 <SamB> wow, this DSSSL standard leaves all the right things undefined
18:28:48 <eivuokko> ?
18:30:14 <SamB> eivuokko: so that conventional ways of implementing lisp and implementing in Haskell are equally acceptable
18:30:48 <eivuokko> Sorry, that made no sense.  But it might because it's late and I'm reading C.
18:30:56 <SamB> like, equality on functions can return #t if they return the same values for the same inputs
18:31:02 <SamB> but it doesn't have to
18:31:13 <eivuokko> Hmm
18:31:20 <SamB> more to the point
18:31:35 <SamB> the rules don't call for any sort of pointer-equality
18:33:48 <eivuokko> Maybe this would make more sense if I knew what's conventional way to implement functional languages?
18:39:40 <SamB> eivuokko: well, the language is based on Scheme
18:39:40 <SamB> but it is purely functional
18:40:10 <SamB> sort of
18:43:22 <SamB> hmm
18:43:26 <eivuokko> Okies :)
18:43:36 <SamB> one syntax rule is
18:43:47 <SamB> list = '('datum*) 
18:43:56 <SamB> er, bad enter key
18:44:34 <SamB> list = '('datum*')' | '('datum+ . datum')'
18:44:49 <SamB> so, I'm wondering how to implement that...
18:44:56 <SamB> hmm...
18:44:56 <SamB> oh.
18:45:19 <eivuokko> .?
18:46:00 <SamB> eivuokko: nevermind
19:07:45 <SamB> hmm, besides parsing "(.bar)" as bar, I think I did pretty well ;-)
19:07:51 * SamB isn't sure if that s dissallowed or not
19:08:16 * SamB suspects it could be trouble if a list started with .1
19:13:23 <SamB> hmm, how to turn a parsec parser into a Read implementation?
19:15:13 <musasabi> readsPrec _ str = case runParser p str of Left err -> []; Right val -> [(val,"")]
19:15:32 <musasabi> ReadP makes that more pretty
19:15:38 <musasabi> @index ReadP
19:15:39 <lambdabot> Distribution.Compat.ReadP, Text.ParserCombinators.ReadP
19:19:02 <SamB> @hoogle runParser
19:19:03 <lambdabot> Text.ParserCombinators.Parsec.Prim.runParser :: GenParser tok st a -> st -
19:19:03 <lambdabot> > SourceName -> [tok] -> Either ParseError a
19:19:18 <SamB> musasabi: well, my main purpose is not to implement Read
19:30:49 <SamB> ADEpt: whats up with this:
19:30:58 <SamB>       * prop_completable_by_next_piece
19:30:58 <SamB> *** Exception: prop_completable_by_next_piece: no pieces left. Bummer!
19:30:58 <SamB> Table: IT {piece_count = {0:=1,1:=1,2:=1,3:=1,4:=0,5:=1,6:=1,7:=1,8:=1,9:=0,10:=1,11:=1}, histogram = {0:=2,1:=10}, interests = {0:={4,9},1:={}}, have = {0,1,2,3,5,6,7,8,10,11}, started = {}, seed_started = {}, size = 12, shuffled = [3,11,10,2,6,0,5,8,7,1,9,4]}
19:38:58 <SamB> @hoogle Test.QuickCheck.Gen a -> IO a
19:38:59 <lambdabot> System.Exit.exitFailure :: IO a
19:39:38 <SamB> @hoogle Test.QuickCheck.Gen a
19:39:39 <lambdabot> Prelude.undefined :: a
19:39:39 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
19:39:39 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:54:00 <Lokadin> is there anything like pvm for haskell
19:54:01 <Lokadin> ?
19:54:14 <Lokadin> parallel virtual machine?
19:54:25 <SamB> @google Distributed Haskell
19:54:26 <lambdabot> http://www.cse.unsw.edu.au/~chak/goffin/
19:54:32 <Lokadin> ap-utils - Access Point SNMP Utils for Linux
19:54:35 <Lokadin> oops
19:55:31 <dons> or do you want a smp ghc rts?
19:56:11 <Lokadin> er yes
19:56:17 <Lokadin> smp?
19:56:30 <Lokadin> symmetric multi proccessing?
19:56:55 <Lokadin> well i need it to be able to be work over the span of a few computers
19:57:05 <Lokadin> so there wont really be a main server
19:57:15 <Lokadin> it's er very different from a normal rts
19:57:29 <Lokadin> more of a mix between an rts and an rpg
19:57:33 <Lokadin> and civilization
19:58:12 <Lokadin> i got this guy planning it with me right now, and he speciallizes in maps and stuff like that
19:58:45 <Lokadin> navigation for real systems
19:58:48 <Lokadin> like gps and stuff
19:59:06 <musasabi> Lokadin: distributed haskell uses pvm iirc
19:59:13 <musasabi> s/distributed/parallel/
19:59:36 <musasabi> http://www.macs.hw.ac.uk/~dsg/gph/
19:59:41 <Lokadin> kk thanks
20:00:08 <musasabi> Then there is GDH and Eden at least...
20:00:28 <Lokadin> hmmm
20:00:33 <Lokadin> well let me explain what it is that i need
20:01:17 <musasabi> please do
20:01:47 <Lokadin> k what's going to happen is that it's going to basically be a map of the entire world, now all individual computers will have only their own civilizations calculated and those that they are interacting with directly
20:01:52 <Lokadin> on a detailed level anyways
20:01:59 <musasabi> PVM is not what I would use for an rpg (as that is more for parallel stuff and with rpgs you usually want loosely distributed stuff)
20:02:51 <Lokadin> now on the whole map what it's going to have is a bunch of generalizatios, so for instance woods and such will be stored in the form of percentage and calculations of what the predicted rate of growth of other civilizations are to reduce cheating
20:02:56 <Lokadin> so what should i use?
20:03:30 <Lokadin> and the various computers would come to consensus on what the world is like every few minutes or so, by averaging their calculations
20:03:56 <musasabi> I would probably just serialize the stuff over sockets.
20:04:19 <Lokadin> kk, so you don't think it would be necessary to have pvm and the like?
20:04:38 <Lokadin> kk
20:04:50 <Lokadin> thanks :D
20:04:58 <musasabi> I think pvm could make it more complex, but I haven't got very much experience with gph/gdh/eden/...
20:05:30 <JohnMeacham> not sure why I didn't implement jhci sooner. it is so useful for debugging the compiler even if it can't compile stuff on the fly.
20:05:30 <Lokadin> what do you mean by making it more complex? you mean in terms of coding, or in terms of the possible complexity of the world
20:08:51 <Lokadin> how is socket support in haskell?
20:09:38 <Lokadin> like is it good?
20:09:50 * SamB fixes test
20:11:08 <Lemmih> Lokadin: http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
20:11:40 <SamB> its not worse than ordinary Handle support
20:12:30 <Lokadin> kk
20:13:23 <SamB> ADEpt: hello?
20:13:31 <SamB> I fixed the test!
20:17:47 <SamB> jlouis: I fixed the test!
20:22:35 <Khisanth> hrm is ghc slow(compared to gcc) or is pugs just really really big?
20:23:14 <Roboguy> By slow, do you mean compile speeds or runtime speeds?
20:23:20 <Saulzar> I think haskell is slower to compile than C, maybe similar to C++ for the same lines?
20:23:34 <SamB> pugs has some really convoluted modules
20:23:41 <SamB> with lots of #includes
20:23:47 <Saulzar> Compiling C just zooms compared to anything else
20:23:50 <SamB> to avoid circular dependancies
20:23:52 <Korollary> Khisanth: ghc compiles slower just because of the language. I also think that its lexing may not be as fast as gcc's.
20:23:57 <Roboguy> *Anything* else?
20:24:04 <monochrom> I do not find it fair to just look at the number of "lines of code".
20:24:05 <Roboguy> I doubt that
20:24:16 <SamB> and GHC isn't O(n)
20:24:34 <SamB> because it does all that whole-module simplification stuff and whatnot
20:24:40 <Saulzar> Well, most higher level languages (C is fairly low level)
20:25:02 <SamB> I'm pretty sure the lexing has nothing to do with it
20:25:14 <SamB> -fasm might improve speed if it worked
20:25:21 <SamB> by cutting out the GCC time
20:26:02 <monochrom> I offer my rant on this. http://groups.google.com/group/comp.lang.functional/msg/9e9c9a552a7d28f6?hl=en&
20:27:39 <Saulzar> Lines of code is not a particually accurate measure, but it is usually reasonable within the same language
20:27:58 <jethr0> samb: porting gcc to House might take a while...
20:28:07 <jethr0> as they don't have a filesystem yet ;-))
20:28:13 <Korollary> For C/C++, the lines of code in a translational unit becomes insane because of the header files.
20:28:30 <SamB> anyway, some of those modules in PUGS are rather deceptive due to #including code that properly ought to be in other modules
20:28:55 <SamB> but can't without using mutually recursive modules
20:29:05 <Korollary> monochrom: full marks on pulling 5 year old rants of yours ;)
20:29:10 <musasabi> jethr0: so write a nfs filesystem driver for them ;)
20:29:12 <monochrom> haha
20:29:18 <Saulzar> Does GHC (or other haskell compilers) optimise between modules? Eg. inlining a tiny function?
20:29:26 <musasabi> Saulzar: yes.
20:29:31 <SamB> Korollary: but the compiler doesn't have to optimize the header files
20:29:49 <monochrom> I am full of wisdom.
20:30:11 <Saulzar> SamB, It does if the headers have code... which is very typical for C++ using templates
20:30:29 <SamB> Saulzar: well, only if you use the code
20:30:40 <jethr0> hehe, they have some ftp file access...
20:30:45 <Korollary> SamB: C/C++ compilers don't spend much time optimizing or not. The bottleneck is the i/o. In fact, people typically #include C files in other C files to speed things up.
20:30:46 <Saulzar> True, but usually you include it to use it :)
20:31:16 <SamB> Korollary: they do.
20:31:21 <Saulzar> Korollary, Are you sure that is the case for C++? C++ is _much_ slower than C
20:31:24 <SamB> GCC has been getting slower and slower
20:31:33 <SamB> for C even
20:31:37 <Roboguy> Saulzar: Slower compile times, you mean?
20:31:40 <Saulzar> Yes
20:31:53 <Korollary> Saulzar: I mean the time spent after the sources have been slurped in already.
20:31:58 <Roboguy> And, besides, a *language* can't be "slower" than another language without context
20:32:12 <SamB> Roboguy: we have context, though
20:32:34 <monochrom> Tomorrow we will compare gcc and masm.
20:32:40 <SamB> hmm
20:32:41 <Saulzar> Hehe..
20:32:49 <SamB> I wonder who will win?
20:32:52 <Korollary> nasm will
20:33:01 <SamB> MASM will lose in the license category
20:33:24 <SamB> but it might assemble faster than GCC compiles
20:33:33 <SamB> if those are anything like comparable
20:41:26 <dons> @quit code yourself up!
20:41:35 <dons> @version
20:41:53 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
20:41:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
20:42:13 <Roboguy> Hmm, what features does lambdabot have?
20:42:45 <dons> many many many. grab the src and check the code.
20:42:56 <Roboguy> No docs?
20:43:13 <Roboguy> I'm still a bit new to Haskell.
20:43:21 <dons> @hawiki LambdaBot
20:43:21 <lambdabot> http://www.haskell.org/hawiki/LambdaBot
20:43:43 <dons> @seen kzm
20:43:43 <lambdabot> kzm is in #haskell-overflow, #flippi, #haskell-blah and #haskell. I don't
20:43:43 <lambdabot> know when kzm last spoke.
20:43:44 <Korollary> wow
20:43:52 <dons> kzm, your patches are in.
20:44:11 <monochrom> what is #haskell-overflow? :)
20:44:24 <dons> where haskell threads sometimes overflow to
20:44:28 <dons> Korollary, ?
20:44:30 <Korollary> monochrom: it's the express lane for heated on-topic conversations.
20:44:50 <Korollary> dons: nm. my wireless dropped me like a hot potato.
20:45:02 <monochrom> ah, and #haskell-blah must be the dual: heated off-topic conversations :)
20:45:06 <dons> also a bit of a pasto bin., where the pastes need analysis by multiple peoples.
20:45:24 <dons> write. it should have been called co-haskell orsuch ;)
20:45:27 <Korollary> monochrom: yes, we crucify non-believers in #blah.
20:45:31 <Roboguy> Hmm, I think I read somewhere that lambdabot can abstract code, is that true?
20:45:41 <dons> @pl \x y -> f x + f y
20:45:58 <monochrom> does that crash lambdabot?
20:46:01 <lambdabot> flip ((.) . (+) . f) f
20:46:01 <lambdabot> optimization suspended, use @pl-resume to continue.
20:46:01 <dons> eventually.hmm.
20:46:02 <Korollary> drumroll?
20:46:05 <dons> ah, thankyou.
20:46:29 <dons> @pl \x y -> x y y
20:46:29 <lambdabot> join
20:46:33 <dons> and so on.
20:46:39 <Roboguy> Hmm
20:46:47 <dons> > map (+1) [1..10] -- and it runs your code!!
20:46:49 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
20:47:08 <Roboguy> Isn't that a bit of a security risk? Or does it run in a sandbox?
20:47:10 <dons> @type map (+1) [1..10]  -- and type checks it
20:47:11 <lambdabot> forall a. (Num a, Enum a) => [a]
20:47:23 <Korollary> @vixen KDE or Gnome ?
20:47:24 <lambdabot> yes
20:47:26 <Korollary> good
20:47:30 <dons> strong static typing, with no side effects..
20:47:55 <musasabi> dons: looks like HaskellUserLocations could use a separate map of central Europe.
20:47:57 <monochrom> > putStrLn "LIES!"
20:47:57 <lambdabot> No IO allowed
20:48:05 <dons> not many other languges could do it, without much heavier infrastructure.
20:48:11 <monochrom> No IO allowed. So there is little risk.
20:48:16 <Roboguy> Ah, okay.
20:48:45 <dons> musasabi, yes. indeed. would you like to work out xglobe args for the zoomed in image?
20:49:00 <dons> and i'll add it to the script
20:49:09 <Korollary> @seen Pseudonym
20:49:09 <lambdabot> Pseudonym is in #haskell-blah and #haskell. I don't know when Pseudonym
20:49:09 <lambdabot> last spoke.
20:49:28 <Korollary> ah. lambdabot just had quit.
20:49:38 <musasabi> dons: it is 5am in Finland, so I won't be able to do anything productive.
20:50:21 <Korollary> it's only 9pm here and I still can't do anything productive.
20:50:29 <dons> ok ;)
20:50:31 <Pseudonym> So you want to find me so you can... what?
20:50:36 <Pseudonym> Do something less productive?
20:50:43 <dons> hmm. that's a bit weird that it didn't keep track of Pseudonym.
20:50:51 <Korollary> Pseudonym: Heh. I was going to ask about your new job again.
20:50:53 <dons> @seen Pseudonym
20:50:54 <lambdabot> Pseudonym is in #haskell-blah and #haskell. Last spoke 17 seconds ago.
20:51:19 <Pseudonym> Not much to report, really.
20:51:34 <Pseudonym> I still don't have the actual board.
20:51:51 <Pseudonym> And there's only so much you can do with an AVR simulator, when it doesn't simulate the custom hardware attached to it.
20:54:41 <Korollary> Do you miss your old job ?
20:58:19 <Roboguy> This is probably a stupid question, but is forall implicit? If not, what does it do? I was under the impression that all type variables implicitly are for all types.
20:58:42 <Korollary> forall is implicit in Haskell 98.
20:58:50 <Roboguy> Ah, okay.
20:59:02 <Roboguy> Haskell 98 is pretty common now, isn't it?
20:59:28 <Korollary> It's actually a bit antiquated. A lot of the extensions are pretty popular.
20:59:40 <Roboguy> Hmm
21:00:19 <Roboguy> Are there any plans for a new standard, which incorporates some of the more popular/widely liked extensions?
21:00:35 <Korollary> Yes, some people are actively working on Haskell '06 or something.
21:00:48 <Roboguy> Hmm
21:02:48 <Roboguy> Hmm, it seems like that Haskell's type classes, combined with modules, could be thought of as a form of object orientation
21:03:38 <Korollary> Not quite, imho. OO implies stateful objects. It's an abstraction method, nonetheless, but I think they are different.
21:05:04 <Roboguy> Couldn't you think of "f object" as another way of writing (using a common method call syntax) "object.f"?  Some objects in OO are nonmutable...
21:08:09 <Korollary> Roboguy: I really can't think of any immutable OO objects.
21:08:23 <Roboguy> Python's str class
21:08:28 <Roboguy> And Java's String class
21:08:41 <Korollary> Ah
21:09:08 <Korollary> I woudln't consider Python's str as a prime example of OO, though.
21:09:51 <Korollary> To answer your own question, if the string is immutable, then yes, func str is the same as str.func.
21:10:00 <Roboguy> When I think of OO, I don't think of something which implies that all objects are mutable.
21:10:09 <Roboguy> Or any, for that matter.
21:11:38 <Pupeno> as getLine isn't really a function, putStrLn isn't either, right ?
21:11:47 <Roboguy> They are functions.
21:12:09 <Roboguy> They take a monad as an argument, and return a monad as a result
21:12:10 <dons> Roboguy, almost noone programs in pure H98 anymore.
21:12:24 <Pupeno> Roboguy: oh.
21:12:26 <dons> it's almost a decade old, after all.
21:12:37 <dons> and there's been a *lot* of research in that time
21:12:45 <Roboguy> As I said, I'm a bit new to Haskell.  I'm used to trying to have very standards compliant code.
21:13:10 <dons> well, stickying to H98 is a good idea for the first 6 months
21:13:39 <Korollary> Roboguy: The definition of OO is highly controversial anyway. But my typical example would be a reference to an object whose exact type is not known, but it is known to be derived from some base class, and it's behavior is abstracted out. In Haskell, the true types of all objects are known at compile time.
21:13:40 <Roboguy> I've probably been using Haskell for only 3 or 4 months so far
21:13:50 <musasabi> If the Haskell 2006 (or whatever one wants to call it) effort could lead to a new standard.
21:14:34 <Roboguy> You mean polymorphism (in the OO sense)?
21:15:11 <Korollary> Roboguy: Yes. Subclassing polymorphism. I don't really require the others (encapsulation, etc.)
21:15:22 <musasabi> Roboguy: at least the FFI and hierarchical modules are considered stable extensions.
21:15:39 <miness> calllee
21:15:41 <miness> ccccccalllee
21:16:05 * SamB notes that python doesn't really support encasulation
21:16:28 <dons> pattern guards forever!
21:16:42 <SamB> yeah, the heirarchical libs you should start using as soon as you start using libs...
21:16:45 <Roboguy> It does support encapsulation.  Maybe not the best data hiding support, but it does support encapsulation
21:16:57 <Korollary> It doesn't enforce it afaik
21:17:22 <Roboguy> Korollary: I usually encapsulate as much as possible, to help abstract things.  As for the polymorphism thing, you could simulate it
21:17:44 <Korollary> Roboguy: In Python or in Haskell ?
21:17:50 <Roboguy> Haskell
21:18:03 <Roboguy> newtype PolymorphicTypeHelper = Type1 | Type2 | Type3 ...
21:18:28 <musasabi> -> sleep
21:18:35 <Korollary> But then it's just one type.
21:18:45 <Roboguy> I think you're missing my point
21:18:47 <Korollary> akin to writing switch statements
21:19:19 <Roboguy> newtype PolymorphicType = PolymorphicType PolymorphicTypeHelper <data-type>
21:19:54 <Roboguy> Then you use the first bit of data to determine how to handle it
21:20:24 <Korollary> Roboguy: As I said, you now have the switch statements.
21:20:36 <Roboguy> Not sure what you mean
21:21:18 <Korollary> Roboguy: You're looking at the first bit of data, right ? That's the switch statements people didn't want to write in C anymore. The point of C++ was to move that decision making progress elsewhere.
21:22:07 <Roboguy> It wouldn't really look like switches... "f (Type1 stuff) = ..." "f (Type2 stuff) = ..."
21:22:26 <SamB> Roboguy: I like how wxHaskell does it better
21:22:32 <SamB> you should take a look ;-)
21:23:48 <SamB> of course, good luck overriding in that scheme...
21:23:57 <Roboguy> Hmm
21:24:04 <Korollary> Roboguy: What I am saying is that your function looks like: "def func(): /* lotsa condition checking */ /* alternative behavior /*. People want to unburden the body of "f" from checking these things and enclose the alternation in behavior in subclasses.
21:24:57 <Roboguy> The way I am doing it looks pretty similar to subclasses to me
21:25:02 <SamB> Korollary: might be something to do with Python not having cases
21:25:53 <Korollary> Roboguy: Anyway. One curious thing to point out is that in OCaml, which does have OO support, people don't really use its OO features.
21:26:34 <Saulzar> I think that just shows that it is possible to have "too much" in a language...
21:27:04 <Korollary> Somebody needs to tell that to Larry Wall, then.
21:27:27 <Saulzar> I think most people do, when they curse at perl and perl programmers :)
21:27:52 <Korollary> To me it looks like everybody is in love with Perl and I am all alone in my silent hatred...
21:28:38 <Saulzar> Ok - well you can be safe to assume there is at least one other!
21:29:16 <monochrom> I don't love Perl.  But I am also too old to hate any programming language.
21:29:40 <Korollary> Once upon a time I crosschecked people in #perl, #python and #scheme. There's really not many people who frequent two of those channels.
21:29:43 <dons> Korollary, maybe some people just use Haskell, and don't worry about perl too much.
21:29:51 <Roboguy> There are very few languages which I actually hate, and I'm pretty young...
21:30:16 <dons> i don't know how you can realy hate a tool, really. unless you're forced to use it, of course..
21:30:23 <Korollary> monochrom: I bet you can pull a 10 year old rand of yours where you express hate for Prolog ! ;)
21:30:35 <Korollary>  s/rand/rant
21:31:03 <monochrom> Guys love Perl, the latest cell phones and PDAs, and media centres that can cook for you...
21:31:48 <monochrom> I'm sure I ranted about Prolog's cut 20 years ago, but alas I did not have access to newsgroups back then.
21:32:03 <Korollary> dons: aren't you forced to teach perl at uni ?
21:34:03 <miness> on another note...........whats a really good  spyware/trojan remover
21:34:21 <miness> im using ad-aware right now, but computer seems to be runnign strange still
21:34:28 <dons> Korollary, not any more!! :D
21:34:35 * Korollary rejoices
21:37:58 <Lemmih> miness: How is that related to Haskell?
21:43:49 <redlion> the Yi paper says you can change the type of the global state because it serializes/deserializes the state -- but I can't actually find the code in Yi...
21:43:54 <redlion> :-/
21:44:33 <dons> it's just a proposal redlion. but the code is pretty basic. just use Binary.hs (as is done in lambdabot)
21:45:43 <stepcut> dons: thanks
21:45:56 <dons> whether you'd actually want to do this, i'm not sure. i mean, it works, but it should hopefully be only rarely required.
21:46:30 <dons> yi does a different trick. the last field of the global state is a dynamically extensible component.
21:46:38 <dons> a Map of Dynamic
21:46:58 <Pupeno> love for perl is unfashioned now, love Ruby! (or die waiting for Perl 6) ;)
21:47:38 <stepcut> dons: I am trying to figure out how to serialize some data to disk, and then read it back in later -- i expect the format of the data to change on occasion
21:48:35 <stepcut> i have not decided if I want to do explicit data version upgrading, or sloppy version upgrading
21:48:43 <dons> ah, right. so you need a Binary.hs or so, and a chain of functions to get from an old form of the data to a new form
21:49:00 <stepcut> any idea how Berkeley DB handles this (if it handles it at all)
21:49:28 <dons> don't know. but that sounds like a good place to look
21:49:56 <stepcut> yes -- since I am thinking of making a haskell clone of BDB ;)
21:52:11 <Korollary> Interesting
21:52:22 <stepcut> Mobile Haskell looks interesting -- it sounds like they have a mechanism for serializing/deserializing unevaluated thunks -- but I could be dreaming
21:53:45 <stepcut> I realized that also none of the data I want to store in a database is relational -- so using relational databases is not the right way to go about doing things :p
21:55:57 * SamB thought BDB just made you dump all your data out and stick it back in again...
21:56:30 <stepcut> SamB: I think you could be right -- I did not see anything when I looked before -- but I did not look real hard
21:56:44 * SamB starts House downloading and goes to bed
21:58:45 * Korollary attempts to compile GHC 6.4.1 instead of using an rpm
22:03:09 * Korollary wonders why ghc's configure checks for Python...
22:03:29 <dons> the testsuite uses a pythion script
22:03:43 <Korollary> ah
22:04:19 <Khisanth> that is just .... very strange :)
22:04:32 <Khisanth> building & testing ghc requires perl, python and a C compiler?
22:04:36 <stepcut> :p
22:04:53 <Korollary> and ghc itself
22:05:20 <Khisanth> right
22:06:04 <Korollary> it would be really cool if all of it was in haskell
22:06:36 <Khisanth> you would probably need to do some stuff with shell scripts too
22:06:46 <dons> you can just use haskell if you want.
22:07:05 <dons> so no mangler and no -fvia-C, and no testsuite. i.e. just -fasm and unregisterised .
22:07:30 <Khisanth> and what is the catch?
22:07:43 <dons> well, unregisterised is slower.
22:08:02 <dons> so keeping the mangler (which is written in perl) is a good idea.
22:08:26 <dons> but not having pythong is probably not a problem. and not have a C compiler, hmm, well, you won't be able to compile the rts then..
22:08:47 <dons> so you need C anyway. perl and python are optional.
22:08:49 <Khisanth> HMM
22:09:12 <dons> it's not surprising you need  a rts written in C... 
22:09:12 <Khisanth> wonder what one has to do to convince Guido to change the language's name to Pythong
22:09:18 <gzl> haha
22:09:18 <Korollary> lol
22:09:31 <Korollary> too sexy
22:09:48 <Khisanth> and sexy is good!
22:09:53 <Korollary> bah. "make" returned with error...
22:10:13 <dons> did you make boot?
22:10:28 <dons> oh, shouldn't be needed.
22:10:33 <dons> where did it die?
22:10:34 <Korollary> it just said configure and make
22:10:59 <Korollary> Deviation.o(.text+0x33e): In function `Deviation':
22:11:11 <Korollary> : undefined reference to `sqrt'
22:11:36 <Korollary> building h2ps
22:11:43 <Korollary> err hp2ps
22:11:48 <dons> yeah, right. you on a funny OS?
22:12:10 <dons> where's #include <math.h> ?
22:12:10 <Korollary> linux
22:12:20 <dons> nah, should build out of the box then.
22:12:38 <Korollary> it should have found math.h or else it would not have compiled. The linker's missing -lm I think
22:12:54 <dons> hmm
22:13:05 <dons> what compiler are you using to bootstrap with?
22:13:33 <Korollary> with 6.4
22:14:25 <Korollary> yeah, I added -lm to the link line and it is ok.
22:14:50 <dons> oh, I see: LIBS         = $(LIBM)
22:14:52 <dons> in the makefile
22:15:04 <dons> for hp2ps. so maybe it didn't find it?
22:15:23 <Korollary> ugh
22:15:34 <dons> should have: config.mk:LIBM=-lm
22:15:37 <dons> in mk/config.mk
22:16:14 <Korollary> dons: it's empty in mine. Weird.
22:16:26 <dons> did configure find it?
22:16:29 <Korollary> Why didn't it complain ?
22:16:39 <dons> maybe it did, but wasn't fatal
22:17:05 <dons> what's  the value of LIBM in config.log?
22:17:30 <Korollary> it's ''.
22:17:40 <Korollary> It didn't print any messages about libm either
22:18:17 <Korollary> It's building some stage1/*.hi's now.
22:18:43 <Korollary> Should I manually insert -lm in config.mk ?
22:19:05 <dons> yeah, I reckon so.
22:20:39 <Korollary> hmm, ghc may be in a better shape to built for cygwin now.
22:21:01 <Korollary> The last time I tried I miserably failed.
22:21:25 <dons> I think mingw is the faster, more stable windows target
22:21:52 <Korollary> Why is it faster ?
22:22:07 <dons> not sure. I guess windows magic is involved
22:22:48 <Korollary> ReadlineIncludePath= empty as well.
22:22:58 <Korollary> mine is /usr/include/readline
22:23:05 <Korollary> or should be
22:23:18 <dons> did you run configure? or did it maybe fail somewhere?
22:23:23 <Korollary> or should it be just "readline" ?
22:23:29 <Korollary> yes, I did and it was fine.
22:23:31 <dons> did you run autoreconf first?
22:23:36 <Korollary> no
22:23:47 <dons> (or are you using a tar ball)
22:24:19 <Korollary> tarball
22:24:55 <Korollary> well, config.log shows it checking
22:25:35 <Korollary> I guess it somehow knows that path already
22:31:35 <musasabi> Korollary: mingw may be faster because that means one less abstraction layer.
22:31:49 * ADEpt does pull from SamB and goes to works
22:32:01 * musasabi woke up for a new day
22:33:14 <Korollary> musasabi: haskell code can pound on the OS layer fast enough to show a difference eh ?
22:33:50 <musasabi> Korollary: yes, I think so.
22:34:18 <musasabi> Korollary: e.g. sockets may show it.
22:35:33 <dons> not sure what Korollary thinks haskell code spends it's time doing? sleeping? ;)
22:36:24 <Korollary> Well, I was thinking that since it's between 5x and 20x slower, it wouldn't be that obvious.
22:37:31 <dons> 20x? oh man. 2x maybe... 2x faster perhaps? :) it all depends 
22:40:02 <Korollary> You're right. It's more like 2x-20x and a lot of tasks within 2x-5x.
22:40:14 <xerox> Hellow :)
22:47:20 <Korollary> hmm, the reverse-complement entry in the shootout has issues...
22:48:27 <musasabi> Korollary: usually the *same* code in Haskell in 2-10x slower than in C, but many times it is possible to create faster code with fewer locs in Haskell. Thus apples to oranges.
22:50:24 <Korollary> musasabi: This was about cygwin vs mingw. So it doesn't matter really.
22:50:39 <musasabi> Korollary: the reverse-complement there looks like it could use a lot of work.
22:51:15 <musasabi> Korollary: for cygwin vs mingw there is the sockets issue. I think it will make mingw come out on top.
22:51:17 <Korollary> musasabi: I think it has a space leak as well.
22:53:01 <musasabi> Korollary: submit a better version :-)
22:53:24 <Korollary> musasabi: I should. I was working on the pfannkuch entry a while ago actually.
22:54:07 <musasabi> If you need I can commit things into shootout.
22:54:43 <Korollary> If I have something, I'll probably paste it here first and see what people think.
22:55:57 <musasabi> One nice excercise could be to use parallel arrays for alternative implementations of a few tests.
22:56:38 <musasabi> (I had to give up on that earlier because ghc 6.2.2 had some fatal PArr bugs, but the shootout has update GHC to 6.4 now)
22:57:11 <Korollary> Where are these parallel arrays in the libs ?
22:57:18 <musasabi> GHC.PArr
22:57:38 <Korollary> Ugh. no documentation?
22:57:41 <xerox> @arr
22:57:42 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
22:57:43 <musasabi> They can use a list comprehension like syntax with [: :]
22:58:50 <xerox> Nicely-nice.
23:18:24 <musasabi> Has anyone got a nice LRU/pseudo-LRU cache implementation in Haskell?
23:18:52 <xerox> > let average = uncurry (flip div) . foldr (((+1) ***) . (+)) (0,0) in average [1..10]
23:18:53 <lambdabot> 5
23:18:56 <xerox> ^_^
23:20:25 <ValarQ> :-O
23:20:53 <astrolabe> but the average of [1..10] is 5.5
23:21:03 <xerox> > let average = uncurry (flip (/)) . foldr (((+1) ***) . (+)) (0,0) in average [1..10]
23:21:04 <lambdabot> 5.5
23:21:08 <xerox> As you whish.
23:21:20 <astrolabe> ah :)
23:21:30 <xerox> ;-)
23:22:26 <xerox> > let average = foldr (((+1) ***) . (+)) (0,0) >>> uncurry (flip (/)) in average [1..10]
23:22:27 <lambdabot> 5.5
23:22:31 <xerox> More arrowish.
23:26:00 <xerox> @yow
23:26:01 <lambdabot> Where does it go when you flush?
23:26:22 <ValarQ> stdout maybe...
23:27:08 * xerox melts... too geeky!
23:28:28 <ValarQ> :(
23:28:49 <ValarQ> i liked the solid xerox
23:29:48 <ValarQ> int-e: hello mr E
23:29:56 <xerox> Gotta run to school, hmpf.. have arrow fun for me.
23:32:14 <triplah> lisppaste2: url
23:32:16 <int-e> ValarQ: Hi Q.
23:32:19 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:33:39 <lisppaste2> triplah pasted "alignment" at http://paste.lisp.org/display/14223
23:33:53 <triplah> if anyone feels like looking at that? :)
23:34:02 <triplah> i need to make a call
23:34:10 <triplah> align str1 str2
23:34:29 <triplah> and return all possible combinations of the letters in str1 and str2
23:34:52 <triplah> > align "xx" "yy"
23:34:53 <lambdabot>  Not in scope: `align'
23:34:59 <triplah> [("xx","yy"),("xx-","y-y"),("x-x","yy-"),("xx-","-yy"),("xx--","--yy"),("x-x","-yy"),("x-x-","-y-y"),("x--x","-yy-"),("-xx","yy-"),("-xx","y-y"),("-xx-","y--y"),("-x-x","y-y-"),("--xx","yy--")]
23:35:04 <triplah> something like that
23:36:47 <sieni> where did you get the -'s from?
23:37:07 <triplah> part of the spec for the question
23:37:11 <triplah> they represent space's
23:37:37 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
23:37:42 <triplah> its task 6 on that page
23:37:51 <triplah> if anyone could be bothered
23:37:53 * triplah begs
23:37:55 <triplah> :)
23:41:08 <flux__> well, it's not a one-liner, and infact I think it might be worthwhile to calculate the scores while doing that list
23:41:24 <flux__> and the page itself presents many hints, so start reading ;)
23:42:11 <flux__> infact that's an interesting problem, if you make it efficient enough it could serve as a 'diff'
23:42:34 <triplah> flux__: yep
23:42:45 <triplah> the results of task 9 are VERY impressive
23:43:03 <triplah> my lecturer gave me a look at a run of it this afternoon
23:43:07 <triplah> i didnt see the code though :(
23:43:16 <flux__> ;(
23:43:27 <triplah> flux__: i've done two classes of haskell :)
23:43:38 <triplah> so its a steep learning curve
23:43:42 <flux__> nice course you have there, given that that assignment is only 0.1 of the course
23:43:59 <flux__> which makes it sound that it's not really that difficult ;)
23:44:08 <triplah> haha
23:44:13 <triplah> "sounds"
23:44:22 <triplah> apparently no one in the last class that did it finished this assignment
23:44:53 <triplah> the other two assignments are in prolog and scheme
23:45:28 <triplah> the rest of the subject is semantics, syntax, algebraic datatypes
23:45:37 <triplah> few other things
23:45:47 <triplah> i have lots of study to do for the exam coming up :|
23:46:16 <triplah> *Main> align "xx" "yy"
23:46:17 <triplah> [[("xxx","-yy")],[("xx","-yy")],[("-x","yyy")],[("xx","-y")],[("-x","yy")],[("xx","yy")],[("xx","yyy")],[("-xx","yyy")],[("xxx","-y")],[("xx","-y")],[("-x","yy")],[("xx","yy")],[("-xx","yy")],[("xxx","yy")],[("xxx","yyy")],[("xx","-y")],[("-x","yy")],[("xx","yy")]]
23:46:22 <triplah> thats what my align does
23:46:25 <triplah> close
23:46:27 <triplah> :)
23:46:39 <triplah> well for me it is anyway
23:48:08 <flux__> I think a really, really slow implementation isn't all that difficult
23:50:12 <triplah> so my lecturer keeps saying :)
23:50:43 <triplah> to me the dynamic programming way makes more sense in my head
23:50:55 <triplah> i guess i understand how i'd actually do it well enough
23:51:10 <flux__> well yes, dynamic programming is something one would want to use to make this efficient :-o
23:51:54 <flux__> hmm, I wonder if one can write such programs elegantly in haskell (or rather, more elegantly than in languages such as c++)
23:52:12 <flux__> but, off to work
23:52:16 <flux__> happy coding ;)
23:52:18 <triplah> i can pastebin my dynamic programming version of task 5 on that page
23:52:21 <triplah> ahhh
23:52:22 <triplah> hf :)
23:54:24 <boegel> @where csh
23:54:25 <lambdabot> I know nothing about csh.
23:54:34 <boegel> @google chs Haskell
23:54:35 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-2.html
23:54:49 <boegel> @google csh Haskell
23:54:50 <lambdabot> http://www.cse.ogi.edu/CFST/unix/filesystem.html
23:54:56 <boegel> grmbl
23:55:56 <boegel> what's the name of the Haskell tool which provides Haskell functions for shell scripting ?
23:56:11 <gzl> h4sh
23:56:42 <boegel> oh, my fault then
23:56:46 <boegel> @where h4sh
23:56:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
23:56:47 <Lemmih> @where h4sh
23:56:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
23:56:54 <boegel> Lemmih: ^_^
23:56:57 <Lemmih> Hi boegel (:
23:58:06 <boegel> Lemmih: maybe you'll know this... I need a function which does this: splitIn4 [1,2,3,4,56,7,8] = [[1,2,3,4],[5,6,7,8]]
23:58:27 <boegel> I've checked out the functions in List, but nothing seems to match, and I can't think of a oneliner which does this
23:58:29 <dons> boegel, you got some sh problems ? ;)
23:58:52 <boegel> dons: no, I just want some Haskell functions for writing scripts :)
23:59:30 <kzm> Good morning!
23:59:44 <kzm> @seen
23:59:44 <lambdabot> Lately, I have seen boegel, dons and kzm.
23:59:57 * kzm pats lambdabot on the head.
23:59:59 <boegel> kzm: cool
