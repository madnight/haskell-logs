00:24:26 <mysteriousentity> If I have:
00:24:41 <mysteriousentity> trace "..." f x
00:25:16 <mysteriousentity> f x = trace "!" {function contents}
00:25:37 <mysteriousentity> I run the program
00:25:41 <mysteriousentity> and get
00:25:48 <mysteriousentity> ...
00:26:04 <mysteriousentity> ***exception blah
00:27:43 <mysteriousentity> what does that mean? is that possible? (assuming x is a correct argument)
00:29:12 <jethr0_> hmm, i've never used trace that way
00:29:19 <mysteriousentity> I think it should be impossible, but it's happening in my program. I think.
00:29:33 <jethr0_> i always did "import Trace; trace topLevelFunction"
00:29:56 <mysteriousentity> what's topLevelFunction?
00:30:06 <lisppaste2> jethr0 annotated #14360 with "with I/O and commented" at http://paste.lisp.org/display/14360#6
00:31:13 <Cale> mysteriousentity: can I see your program?
00:31:31 <mysteriousentity> if you wish :)
00:31:55 <mysteriousentity> I don't have it on a server. Do you what me to paste code in here?
00:32:07 <Cale> If it's really short
00:32:10 <Cale> otherwise,
00:32:12 <Cale> lisppaste2: url
00:32:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:32:25 <mysteriousentity> ok
00:33:38 <lisppaste2> mysteriousentity pasted "trace_1" at http://paste.lisp.org/display/14367
00:34:39 <jethr0_> everyone seems to be doing raytracers these days ;-))
00:34:56 <jethr0_> welcome to the club, mysteriosentity, man with the long name
00:35:09 <Cale> what's the exception?
00:35:52 <mysteriousentity> specularComponent:
00:35:52 <mysteriousentity> lights [Light (Pt (-0.5,0.0,-0.5)) (Col (0.75,0.75,0.75))]
00:35:52 <mysteriousentity> ...
00:35:52 <mysteriousentity> renderer: Prelude.head: empty list
00:36:26 <Cale> okay
00:36:34 <mysteriousentity> I don't understand why "specularComponentFromLight:" etc does not show up
00:37:05 <Cale> because the program died before it was evaluated
00:37:53 <jethr0_> could you grep for "head" in your code, pls
00:38:01 <mysteriousentity> but after "..." there is nothing else to do but go into that function
00:38:13 <mysteriousentity> I'm pretty sure I have traced all it's arguments
00:38:18 <mysteriousentity> and they show up fine
00:38:27 <Cale> evaluation doesn't proceed linearly
00:38:34 <Cale> it proceeds by demand
00:39:04 <mysteriousentity> but if there is demand to evaluating componentFromLight
00:39:39 <Cale> where is that demand coming from?
00:39:55 <mysteriousentity> can it do other stuff before finishing evaluation?
00:40:08 <Cale> It could simply never evaluate it
00:40:14 <mysteriousentity> jethr0_: hold on, I just what not understand this first.
00:40:17 <Cale> if the result isn't actually needed
00:40:31 <mysteriousentity> but then it wouldn't be calling it at all
00:40:39 <mysteriousentity> and I wouldn't get "..."
00:40:45 <mysteriousentity> is my understanding wrong?
00:40:55 <Cale> ah, okay
00:41:34 <Cale> okay, so the error is happening because pattern matching the args to specularComponentFromLight is forcing some evaluation
00:41:42 <Cale> and part of that evaluation fails
00:41:52 <ProfTeggy> Moin
00:42:50 <Cale> well, where in your program do you call head?
00:43:09 <mysteriousentity> just a sec
00:43:57 <mysteriousentity> A function called getNormal. I'll just see what relationship is has to this.
00:44:15 <Cale> how is r, the ray being computed?
00:44:20 <jethr0_> moin
00:44:36 <jethr0_> profteggy, how come you're saying moin too?
00:44:53 <jethr0_> i feel almost at home (which is the most northern part of germany) ;-)
00:45:09 <mysteriousentity> I am very sure all the arguments to the function get evaluate fine.
00:45:36 <mysteriousentity> As in they show up in the trace if I trace them.
00:45:47 <mysteriousentity> *evaluated
00:46:40 <jethr0_> gotta run, later!
00:46:48 <Cale> could you put a trace on r in the call to specularComponent?
00:47:08 <Cale> i.e. show it in with the lights there
00:47:19 <mysteriousentity> ok
00:48:28 <mysteriousentity> evaluates
00:48:31 <mysteriousentity> specularComponent:
00:48:31 <mysteriousentity> lights [Light (Pt (-0.5,0.0,-0.5)) (Col (0.75,0.75,0.75))]
00:48:31 <mysteriousentity>  ray Ray (Pt (0.0,0.0,-1.0)) (Vec (-0.4677132228186838,0.35060193072010887,0.811
00:48:31 <mysteriousentity> 3708322190859))
00:48:31 <mysteriousentity> ...
00:48:32 <mysteriousentity> renderer: Prelude.head: empty list
00:49:34 <mysteriousentity> this line:
00:49:37 <mysteriousentity>       inten           = getLightIntensity scene isectPoint normal (l, lVec)
00:49:50 <mysteriousentity> eventually calls the function getNormal
00:50:01 <mysteriousentity> which contains the only "head" in this module
00:53:01 <Cale> hmm
00:54:02 <Cale> so probably you're passing head an empty list, but what's the parameter there?
00:55:44 <lisppaste2> mysteriousentity pasted "getNormal" at http://paste.lisp.org/display/14368
00:55:58 <Cale> oh
00:56:11 <Cale> put a $ after the trace
00:56:23 <Cale> for specularComponentFromLight
00:56:43 <Cale> after the message
00:57:05 <Cale> trace "specularComponentFromLight" $
00:57:19 <mysteriousentity> compiling
00:57:26 <Cale> It's being attached to the first parameter to scaleCol
00:57:36 <mysteriousentity> same result
00:57:59 <mysteriousentity> scaleCol?
00:58:18 <Cale> trace "specularComponentFromLight" (kSpecular * (normal `dot` h)) `scaleCol` inten * objCol
00:58:30 <mysteriousentity> oh
00:58:38 <Cale> = (trace "specularComponentFromLight" (kSpecular * (normal `dot` h))) `scaleCol` inten * objCol
00:58:54 <mysteriousentity> just a sec
00:59:46 <mysteriousentity> ...
00:59:46 <mysteriousentity> specularComponentFromLight:
00:59:46 <mysteriousentity> norm
00:59:46 <mysteriousentity> renderer: Prelude.head: empty list
00:59:49 <mysteriousentity> success
00:59:52 <mysteriousentity> !!!
01:00:17 <Cale> trace has a funny type, so it's hard to generate type errors with it
01:00:46 <Cale> you can often get it applied to the wrong thing if you're not careful
01:01:18 <mysteriousentity> Dollar sign is the way to go.
01:01:25 <mysteriousentity> Thank you very much.
01:01:42 <mysteriousentity> I don't know what I would do without this channel.
01:01:42 <Cale> no problem
01:01:48 <Cale> :)
01:10:45 <mysteriousentity> jethr0_: "welcome to the club, mysteriosentity, man with the long name". Yes, thanks btw. But how do you know I'm a man? ;)
01:11:55 <mysteriousentity> By my name maybe, I suppose. :)
01:12:05 <Heffalump> Alex could be a female name.
01:12:12 <Heffalump> I suspect by probabilities :-)
01:12:47 <mysteriousentity> Well, well, you're lucky I didn't turn out to be a passionate feminist!
01:14:58 <mysteriousentity> This nick was supposed to be a temp. I meant to change it to something less lame. But I don't know if it's worth it already :)
01:18:27 <Cale> afeigin and alexf seem free
01:18:48 <Cale> Alex seems taken though
01:21:03 <mysteriousentity> I don't like identifiying by my last name. Bad childhood experiences... don't ask. Although I might settle for alexf
01:37:12 <Sven_Moller_Fah> topof the mornin to you all
01:38:52 <Sven_Moller_Fah> jethr0, the thing you gave me yesterday didnt worked...dont know why
01:39:37 <Sven_Moller_Fah> i undstood it, and tried to do my own version, but something is wrong
01:41:36 <Sven_Moller_Fah> can anyone tell me why this doesnt work?   http://paste.lisp.org/display/14370
01:41:58 * Cale looks
01:43:39 <Cale> you didn't give drop enough parameters
01:44:02 <Sven_Moller_Fah> ??
01:44:10 <Sven_Moller_Fah> doesnt it only have 1?
01:44:22 <lightstep> @type drop
01:44:23 <lambdabot> forall a. Int -> [a] -> [a]
01:45:16 <Sven_Moller_Fah> hmm
01:45:17 <Sven_Moller_Fah> your right
01:45:51 <Oejet> Are you guarantied to have exactly one number in the beginning of the string?
01:46:29 <Oejet> *guaranteed
01:46:29 <Sven_Moller_Fah> yes
01:46:37 <Sven_Moller_Fah> divide s = numero s : divide (drop (length numero s)s)
01:46:42 <Sven_Moller_Fah> this doesnt work either
01:47:33 <lightstep> @type length
01:47:35 <lambdabot> forall a. [a] -> Int
01:47:51 <lightstep> 'length' only cares abou numero, not about s
01:48:46 <Sven_Moller_Fah> if anyone knows a better way tp turn this  -> "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"   into this:  ["1","Tartaruga Teresa","2","Lebre Laura","3","Mosca Maria"]
01:49:00 <Sven_Moller_Fah> im doing lines, then do that
01:49:22 <Sven_Moller_Fah> words also split the names into 2 diferent words so it doesnt work
01:49:29 <Cale> > (map words . lines) "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"
01:49:31 <lambdabot> [["1","Tartaruga","Teresa"],["2","Lebre","Laura"],["3","Mosca","Maria"]]
01:50:03 <Sven_Moller_Fah> yes, but i need "Tartaruga","Teresa" to be "Tartaruga teresa"
01:50:09 <Sven_Moller_Fah> thats the problem
01:50:16 <lightstep> map (break (== ' ') . lines) "1 ab cd\n2 gsr gsrg\n3 rhgrh hr"
01:50:27 <Lemmih> > unwords ["One", "Two"]
01:50:28 <lambdabot> "One Two"
01:50:29 <lightstep> >map (break (== ' ') . lines) "1 ab cd\n2 gsr gsrg\n3 rhgrh hr"
01:50:38 <lightstep> > map (break (== ' ') . lines) "1 ab cd\n2 gsr gsrg\n3 rhgrh hr"
01:50:40 <lambdabot> Couldn't match `Char' against `String'
01:50:56 <lightstep> oof
01:51:11 <Sven_Moller_Fah> lightstep is that suposed to work?
01:51:27 <Lemmih> > let (n,r) = span isDigit "1 one two" in (n,dropWhile isSpace r)
01:51:28 <lambdabot> ("1","one two")
01:51:40 <Cale> > do (x:xs) <- (map words . lines) "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"; return [x, concat xs]
01:51:41 <lambdabot> [["1","TartarugaTeresa"],["2","LebreLaura"],["3","MoscaMaria"]]
01:51:56 <Cale> oops :)
01:52:00 <Cale> > do (x:xs) <- (map words . lines) "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"; return [x, concat (intersperse " " xs)]
01:52:01 <lambdabot> [["1","Tartaruga Teresa"],["2","Lebre Laura"],["3","Mosca Maria"]]
01:52:23 <Lemmih> concat (intersperse " ") ... === unwords.
01:52:41 <Oejet> Lemmih: You are too quick for me. :-)
01:52:46 <Cale> that's inefficient, but it basically does the trick :)
01:52:50 <Cale> ah, right
01:52:58 <Cale> > do (x:xs) <- (map words . lines) "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"; return [x, unwords xs]
01:53:00 <lambdabot> [["1","Tartaruga Teresa"],["2","Lebre Laura"],["3","Mosca Maria"]]
01:53:13 <Sven_Moller_Fah> hmm
01:53:18 <Sven_Moller_Fah> i realy understand that
01:53:26 <Sven_Moller_Fah> but i couldnt do it again if i wantes
01:53:30 <Sven_Moller_Fah> wanted*
01:53:38 <Cale> of course, you can rewrite that as a list comprehension
01:53:39 <Sven_Moller_Fah> im not used to all that do (x:xs) <- 
01:53:50 <Sven_Moller_Fah> and returns and stuff
01:53:59 <Sven_Moller_Fah> just started to work with haskell
01:54:01 <Cale> that's from monads
01:54:04 <lightstep> @pf \dict -> concat [[read x, unwords xs] | (x:xs) <- map words.lines] dict
01:54:05 <lambdabot> (line 1, column 17):
01:54:05 <lambdabot> unexpected "["
01:54:05 <lambdabot> expecting variable, "(", operator or end of input
01:54:05 <lambdabot> ambiguous use of a right associative operator
01:54:07 <Lemmih> > map (\s -> let (n,r) = span isDigit s in (n,dropWhile isSpace r)) (lines "1 one line\n2 two lines")
01:54:08 <lambdabot> [("1","one line"),("2","two lines")]
01:54:20 <Cale> > [[x, unwords xs] | (x:xs) <- (map words . lines) "1 Tartaruga Teresa\n2 Lebre Laura\n3 Mosca Maria\n"]
01:54:22 <lambdabot> [["1","Tartaruga Teresa"],["2","Lebre Laura"],["3","Mosca Maria"]]
01:55:04 <Lemmih> Sven_Moller_Fah: 'span' is what you want.
01:55:09 <Cale> makes more sense?
01:55:14 <Sven_Moller_Fah> im looking at it
01:55:15 <Sven_Moller_Fah> hmm
01:55:46 <Sven_Moller_Fah> im just used to things in this format
01:55:46 <Sven_Moller_Fah> divide :: String -> [String]
01:55:46 <Sven_Moller_Fah> divide "" = []
01:55:46 <Sven_Moller_Fah> divide s = numero s : divide (drop (length numero s))
01:56:04 <Sven_Moller_Fah> all those returns,and do and stuff mess with my head lol
01:56:11 <Lemmih> You're giving 'length' two arguments.
01:56:20 <Sven_Moller_Fah> yes i know
01:56:33 <Cale> divide s = ns : divide (drop (length ns) s) where ns = numero s
01:56:33 <Lemmih> > map (\s -> let (n,r) = span isDigit s in (n,dropWhile isSpace r)) (lines "1 one line\n2 two lines") -- Can't you use this?
01:56:34 <lambdabot> [("1","one line"),("2","two lines")]
01:56:44 <Sven_Moller_Fah> ok, step by step
01:56:53 <Sven_Moller_Fah>  map (\s -> let (n,r) what does this means?
01:56:57 <Sven_Moller_Fah> i know map
01:57:23 <Lemmih> "\s -> ..." is a lambda function, aka an unnamed function.
01:57:33 <lightstep> \s -> len (n, r) = span isDigit s in (n, dropWhile is Space r)
01:57:47 <lightstep> breaks s into the parts r and n
01:57:57 <Sven_Moller_Fah> ahhh
01:58:12 <lightstep> then drops the spaces from r, so you can continue processing at the next word
01:58:47 <Sven_Moller_Fah> what is len?
01:58:54 <Sven_Moller_Fah> let?
01:59:03 <Lemmih> "let x = y in ..." binds 'x' to 'y' in the '...' scope.
01:59:13 <Lemmih> > let x = 10 in x+x
01:59:14 <lambdabot> 20
01:59:24 <lightstep> (and in the 'y' scope)
01:59:24 <Sven_Moller_Fah> nice
02:00:58 <Sven_Moller_Fah> ("\s -> is the only thing i dont get
02:01:12 <Lemmih> > (\s -> s+1) 10
02:01:13 <lambdabot> 11
02:01:19 <Lemmih> > let f s = s +1 in f 10
02:01:21 <lambdabot> 11
02:01:31 <Sven_Moller_Fah> oh!
02:02:37 <Sven_Moller_Fah> ill try to "adapt" it to my format
02:02:46 <Oejet> > let f = \s -> s+1 in f 10
02:02:47 <lambdabot> 11
02:03:01 <Oejet> > let f = (+1) in f 10
02:03:02 <lambdabot> 11
02:03:05 <Sven_Moller_Fah> i understand it, but not enough to work with it
02:03:11 <Oejet> Ok, I'll stop now. :-(
02:03:15 <Sven_Moller_Fah> hehehe
02:04:35 <Sven_Moller_Fah> HAHAHA
02:04:51 <Sven_Moller_Fah> Cale, only now i saw what u wrote there
02:04:52 <Sven_Moller_Fah> divide s = ns : divide (drop (length ns) s) where ns = numero s
02:04:57 <Sven_Moller_Fah> yeah that did the trick
02:05:43 <Sven_Moller_Fah> but i did that and it didnt work
02:05:47 <Sven_Moller_Fah> isnt this the same?
02:05:47 <Sven_Moller_Fah> divide s = numero s : divide (drop (length numero s) s) 
02:06:26 <Sven_Moller_Fah> ah juts realised why....
02:06:38 <Lemmih> 'length numero s' == '(length numero) s', not 'length (numero s)'
02:06:41 <Sven_Moller_Fah> if i put () in numero s next to length it works
02:06:45 <Sven_Moller_Fah> exactly
02:07:05 <Sven_Moller_Fah> thankyou SO much!!
02:11:35 <tromp> you mighht want to look at the ReadS class
02:12:18 <tromp> reads "15 bla bla"
02:12:29 <tromp> > reads "15 bla bla"
02:12:30 <lambdabot> Add a type signature
02:12:55 <tromp> > reads "15 bla bla" :: [(Int,String)]
02:12:56 <lambdabot> [(15," bla bla")]
02:14:22 <Sven_Moller_Fah> wow
02:14:25 <Sven_Moller_Fah> it does that?!
02:14:46 <Sven_Moller_Fah> and can i use it over and over?
02:14:57 <Sven_Moller_Fah> with map for example?
02:16:12 <tromp> sure, it's a general parsing engine
02:16:26 <Sven_Moller_Fah> hmm ill try that
02:17:07 <tromp> > reads "[1,2,3] bla" :: [([Int],String)]
02:17:09 <lambdabot> [([1,2,3]," bla")]
02:18:06 <Sven_Moller_Fah> wow
02:18:11 <Sven_Moller_Fah> this is realy usefull
02:18:46 <tromp> > reads "\"Yo dude\" bla" :: [(String,String)]
02:18:48 <lambdabot> [("Yo dude"," bla")]
02:23:13 <Sven_Moller_Fah> dividour (x:xs) = map (read x :: (Int,String)) xs
02:23:24 <Sven_Moller_Fah> isnt this the format
02:23:25 <Sven_Moller_Fah> ?
02:26:21 <Lemmih> That's a type error.
02:27:04 <Sven_Moller_Fah> hmm
02:27:46 * joelr1 waves
02:28:15 <Sven_Moller_Fah> how do i apply something like read to a whole list?
02:28:54 <lightstep> reads, perhaps?
02:29:06 <Sven_Moller_Fah> reads yes
02:29:13 <Sven_Moller_Fah> omg
02:29:17 <Sven_Moller_Fah> i wrote read....
02:29:43 <Sven_Moller_Fah> well doesnt work either
02:30:37 <tromp> what do u want to apply it to?
02:31:03 <Sven_Moller_Fah> a ating
02:31:06 <Sven_Moller_Fah> string*
02:31:36 <tromp> give me an example of input and expected output
02:31:41 <Sven_Moller_Fah> hmm...
02:32:27 <Sven_Moller_Fah> ["1 something something","2 someotherthing someotherthing"]
02:33:02 <Sven_Moller_Fah> output -> [(1,"something something"),(2,"someotherthing someotherthing")]
02:33:57 <tromp> map (head . reads) list :: [(Int,String)]
02:34:30 <tromp> the strings will still have a leading space
02:34:30 <Sven_Moller_Fah> what does (head . reads) mean?
02:34:41 <tromp> function composition
02:34:50 <tromp> apply head after applying reads
02:35:34 <Sven_Moller_Fah> hmmok thx
02:35:52 <Oejet> (f . g)(x) = f(g(x))
02:36:31 <Sven_Moller_Fah> why not just write it like that?
02:37:09 <Lemmih> (head . reads) is prettier than (\x -> head (reads x)).
02:37:51 <Sven_Moller_Fah> lol
02:38:32 <Oejet> You could define a new function: "hr(x) = head(reads(x))" and say "map hr list".
02:38:52 <Lemmih> (x) looks weird (:
02:39:15 <Sven_Moller_Fah> ah
02:39:18 <Sven_Moller_Fah> thats more simple to me
02:39:24 <Sven_Moller_Fah> baby steps
02:39:26 <Sven_Moller_Fah> :D
02:39:59 <Oejet> That just forced me to name it something stupid like "hr" (no offence to any Henning Rauers or others).
02:40:29 <tromp> hr is human resource, like what catbert does:)
02:40:44 <tromp> evil director of HR
02:40:59 <Sven_Moller_Fah> loool
02:41:29 <Oejet> First he reads you, and then he takes your head?
02:41:58 <tromp> see him in acation today at dilbert.com
02:42:08 <tromp> action
02:42:19 <tromp> does look like head taking:)
02:42:23 * Oejet sometimes feels like a human resource.
03:10:03 <C-Keen> re
03:16:13 <Sven_Moller_Fah>  Unresolved overloading  <-- what does this means?
03:19:52 <dcoutts> Sven_Moller_Fah, suppose I wrote (read . show)
03:20:03 <Sven_Moller_Fah> hmm...
03:20:08 <Sven_Moller_Fah> compilador ((x,y):xs) = (reads x , y) : compilador xs
03:20:17 <Sven_Moller_Fah> this seems to work
03:20:20 <Sven_Moller_Fah> but it doesnt
03:20:27 <dcoutts> or perhaps (read . show) is a better example
03:20:48 <dcoutts> the point is that there is nothing saying which type we're using read or show at
03:20:57 <Sven_Moller_Fah> hmm....
03:21:01 <Sven_Moller_Fah> so how can i fix it?
03:21:17 <dcoutts> usually you jsut add a type signature
03:22:26 <Sven_Moller_Fah> hrm...
03:22:30 <Sven_Moller_Fah> damn this!
03:23:37 <Sven_Moller_Fah> im trying to turn [("1","asdd"),("2","sdff)] into [(1,"asdd),(2,"sdff")]
03:23:41 <Sven_Moller_Fah> and that should work!!!!
03:24:59 <Sven_Moller_Fah> whats wrong with: compilador ((x,y):xs) = (reads x , y) : compilador xs
03:25:06 <Sven_Moller_Fah> its so simple!!
03:26:38 <mrchebas> try the following: compilador ((x,y):xs) = (read x::Int , y) : compilador xs
03:27:47 <Sven_Moller_Fah> you ppl are genious....
03:28:11 <dblhelix> Sven_Moller_Fah: and I only just entered the room... thanks! ;)
03:29:16 <mrchebas> Sven_Moller_Fah: you can get rid of the |::Int| bit if you provide a type signature for compilador
03:29:52 <Sven_Moller_Fah> but i did
03:29:57 <Sven_Moller_Fah> and it gave error
03:30:11 <Sven_Moller_Fah> compilador :: [(String,String)] -> [(Int,String)]
03:30:45 <mrchebas> what error?
03:31:09 <dblhelix> any readline experts here?
03:32:40 <Sven_Moller_Fah> Expression     : (reads x,y) : compilador xs
03:32:40 <Sven_Moller_Fah> *** Term           : (reads x,y)
03:32:40 <Sven_Moller_Fah> *** Type           : ([(a,[Char])],[Char])
03:32:40 <Sven_Moller_Fah> *** Does not match : (Int,String)                    
03:33:13 <Lemmih> @type reads
03:33:14 <lambdabot> forall a. (Read a) => ReadS a
03:33:19 <Lemmih> @type read
03:33:20 <lambdabot> forall a. (Read a) => String -> a
03:33:28 <mrchebas> Sven_Moller_Fah: use |read| instead of |reads|
03:33:37 <Sven_Moller_Fah> ah...
03:33:41 <Lemmih> type ReadS a = [(a,String)]
03:33:44 <Sven_Moller_Fah> lemme try
03:34:19 <dblhelix> type ReadS a = String -> [(a, String)]
03:34:30 <Sven_Moller_Fah> ahh it works now
03:34:30 <Sven_Moller_Fah> thx
03:34:31 <Lemmih> ah, right.
03:34:32 <dblhelix> ah
03:49:04 <tromp> read parses an item from a string and returns the remainder as well
03:49:10 <tromp> uhm, reads does that
03:49:28 <tromp> read makes sure the remainder is empty and return just the parsed item
03:50:12 <tromp> reads returns a list in case of multiple (or 0) possible parses
03:52:40 <joelr1> howdy folks
03:53:37 <joelr1> i asked this question before but don't remember the answer... 
03:53:43 <joelr1> orElse :: STM a -> STM a -> STM a
03:54:02 <joelr1> how would i daisy-chain orElse on a variable number of TVars?
03:54:12 <joelr1> or transactions rather
03:55:46 <Saulzar> foldl1 orElse [stmList] ?
03:55:59 <joelr1> @index fold1
03:56:00 <lambdabot> bzzt
03:56:06 <joelr1> @index fold1
03:56:07 <lambdabot> bzzt
03:56:09 <joelr1> hmm
03:56:12 <Saulzar> @index foldl1
03:56:13 <dcoutts> @index foldl1
03:56:13 <lambdabot> Data.List, Prelude
03:56:13 <lambdabot> Data.List, Prelude
03:56:27 <joelr1> @type foldl1
03:56:27 <Saulzar> snap
03:56:28 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:56:44 <joelr1> probably not this one, a monadic version is in order
03:56:57 <joelr1> @index mapM
03:56:58 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
03:56:58 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
03:56:58 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
03:57:01 <musasabi> foldM or fold + mplus ?
03:57:10 <dcoutts> @type foldM
03:57:12 <lambdabot> Not in scope: `foldM'
03:57:19 <dcoutts> @type Monad.foldM
03:57:20 <lambdabot> forall a (m :: * -> *) b.
03:57:20 <lambdabot> (Monad m) =>
03:57:20 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
03:57:29 <Lemmih> @type foldl1 Control.Concurrent.STM.orElse
03:57:30 <lambdabot> forall a. [GHC.Conc.STM a] -> GHC.Conc.STM a
03:57:55 <joelr1> foldl1 it is then
03:57:56 <musasabi> @type foldl1 mplus
03:57:58 <lambdabot> Not in scope: `mplus'
03:58:04 <musasabi> @type foldl1 Control.Monad.mplus
03:58:06 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => [m a] -> m
03:58:06 <lambdabot> a
03:58:53 <joelr1> thank you!
03:59:22 <lightstep> @type Monad.msum
03:59:23 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [m a] -> m
03:59:23 <lambdabot> a
04:00:00 <joelr1> another question... i would like to implement a variant of TChan where i could selectively remove messages or pull them out in order of arrival. any suggestions for a data structure?
04:00:20 <joelr1> i'm thinking a map keyed on ClockTime but need to see how i can remove max key
04:00:31 <joelr1> and whether this would be afficient at all
04:01:54 <astrolabe> joelr1: Do you mean a first in first out thing?
04:02:04 <joelr1> no, first in, last out
04:02:11 <joelr1> or selective remove based on a predicate
04:02:38 <joelr1> and i need to keep time of arrival on hand for each mesage
04:02:40 <joelr1> message
04:03:54 <Saulzar> Can't you just use a stack (a list) for that?
04:05:27 <Saulzar> first in last out seems an odd way to put things, is that the same as last in first out? 
04:06:06 <astrolabe> joelr1: Did you mean to say "or pull them out in REVERSE order of arrival"?
04:11:16 <Saulzar> Oh, I didn't notice remove on a predicate... I have had similar problems recently, but I was using C++ :)
04:11:38 <joelr1> yes, reverse order
04:11:42 <joelr1> of arrival
04:12:00 <joelr1> Saulzar: first in, last out is called a queue :D
04:12:23 <ProfTeggy> No, joelr1
04:12:29 <ProfTeggy> That's first in, first out
04:12:37 <joelr1> i'm confused
04:12:40 <joelr1> this morning
04:12:51 <Saulzar> You're making me confused :)
04:13:01 <joelr1> first in, first out. exactly what i need. a queue. 
04:13:16 <ProfTeggy> So, no reverse order
04:13:16 * joelr1 apologizes
04:13:21 <joelr1> no reverse order
04:14:03 <joelr1> attach a timestamp to a message, stick messages into a structure, selectively ignore messages and probably squish them as well, i.e. don't stick it in if the message is in already
04:14:41 <ProfTeggy> That sounds like a priority heap
04:15:12 <ProfTeggy> http://www.dcs.shef.ac.uk/~mps/courses/com2020/notes/priority-queue.pdf
04:15:23 <joelr1> any appropriate existing haskell data structure?
04:15:33 <ProfTeggy> The above uses Haskell
04:16:01 <joelr1> i wonder if there's associated code 
04:16:05 <joelr1> ProfTeggy: do you know?
04:16:41 <ProfTeggy> I bet Ralh Hinze has something in store...
04:16:44 <ProfTeggy> Ralf
04:16:55 <ProfTeggy> This? http://www.informatik.uni-bonn.de/~ralf/publications/UU-CS-2001-09.pdf
04:19:56 <Saulzar> Being able to detect if a message is already in the queue is annoying... 
04:20:06 <joelr1> Saulzar: i can skip it for now
04:20:10 <joelr1> it's not a priority
04:22:23 <musasabi> Data.Map / Data.IntMap works quite well.
04:22:33 <musasabi> unless your structure is huge.
04:22:52 <Saulzar> What I've done in the past is to create two structures linked together  - but that would need to be mutually recursive for haskell ...  a tree indexed by priority, then unique id   would probably work on second thoughts
04:23:11 <joelr1> cool, thanks
04:23:13 <musasabi> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#20 etc
04:23:28 <joelr1> musasabi: that is what i was thinking about, thanks
04:23:45 <joelr1> i'm gonna abstract TChan into a mailbox and set a fixed # of messages for now
04:23:55 <joelr1> so that i know when the message build-up starts
04:23:57 <musasabi> joelr1: the only thing to be wary of is that you probably want the keys to be unique. I solved that by replacing keys with (Key,AnIncrementingValueFromACounter)
04:24:12 <joelr1> musasabi: ClockTime 
04:24:58 <musasabi> do you guarantee unique results (even with the user resetting the clock behind your back) ?
04:26:12 <joelr1> musasabi: i don't give a damn ;) that will be there own fault
04:26:26 <musasabi> point :-)
04:28:08 <SamB> musasabi: hows that patch coming along?
04:28:08 <SamB> musasabi: user? what user is that?
04:29:03 <musasabi> SamB: the one running the machine and plotting to make your crash so he can file bug reports.
04:29:03 <Saulzar> One from the mysterious land of IO? :)
04:29:17 <musasabi> s/your/your code/
04:29:30 <JohnMeacham> infer! infer! infer! w00t! take a shot every time a polymorphic type is infered.
04:30:09 <SamB> musasabi: but this is more of a server thing
04:30:16 <musasabi> SamB: slowly working on it.
04:30:42 <SamB> musasabi: from where will I be able to pull your patch when it is finished?
04:31:13 <musasabi> SamB: I'll paste you an url for that then.
04:31:32 <SamB> musasabi: okay then.
04:33:07 <SamB> keep up the good work. try to remember to keep the code somewhat readable whilst you are optimizing it. remember that we are probably going to end up using sendfile for pieces, so don't worry too much about them (not that they are particularly difficult to get right or anything)
04:34:13 <musasabi> it is quite hard to make sendfile work very well to make it worth for pieces.
04:34:50 <musasabi> basically the problem is that for 16kb pieces the overhead of a safe call may not be worth it.
04:35:03 <musasabi> not to mention most *nix have a different API for it.
04:35:16 <Oejet> What's a piece?
04:35:28 <musasabi> Oejet: a slice of a file.
04:36:53 <SamB> musasabi: there is that
04:36:54 <SamB> maybe sendfile isn't such a great idea
04:37:18 <musasabi> SamB: how should receiving a piece be handled from an architectural viewpoint? I want to avoid copying it from the receive-buffer but that means that the parser would need to call a strict operation on it.
04:37:33 <SamB> musasabi: FPS has slices
04:37:49 <musasabi> SamB: O(n)
04:37:58 <SamB> O(1) slices
04:38:14 <musasabi> SamB: that works only if you don't want to reuse the buffer memory.
04:38:40 <SamB> musasabi: you shouldn't really be doing that anyways
04:38:57 <SamB> probably not, anyway
04:39:08 <musasabi> it has fixed memory usage which is nice.
04:39:35 <musasabi> mmh, but adapting to a buffer/message model seems easy enough.
04:40:13 <SamB> this isn't going to change the interface much beyond a few strings changing to FastStrings, is it?
04:41:32 <SamB> hmm, I better go about now, I have a class to get to...
04:42:11 <SamB> oh, you do realize we are going to be using this from multiple threads, right?
04:42:49 <musasabi> yes, that is not a problem.
04:43:29 <SamB> okay ;-)
04:45:23 <Saulzar> How many of you are working on this project?
04:47:09 <SamB> mostly me, adept, and jlouis
04:47:33 <ADEpt> SamB: hi
04:47:47 <ADEpt> SamB: nice fix, i completely missed out that second 'not
04:49:40 <Saulzar> Cool - how far through are you?
04:50:07 <ADEpt> musasabi: were you talking about conjure?
04:51:26 <ADEpt> Saulzar: how can you measure 'how far' ? :)
04:52:36 <Saulzar> Well, what state is it in, does it produce "Hello world"? :)
04:53:50 <ProfTeggy> If you can you read e-mail with it, the project is close to its end.
04:54:27 <ADEpt> Saulzar: when run, it launches most of the major threads (5 so far), sets up communication channels, and working through them, requests peers from tracker, select one of the peers and request first 1K of each available piece of file :) (does not store them, though)
04:56:16 <Saulzar> Ah hah, neat
05:03:39 <ProfTeggy> bbl, lecturing
05:16:03 <JohnMeacham> sigh. jhc needs a new typechecker. I have given up hope on modifying the current one...
05:18:55 <dcoutts> JohnMeacham, what's wrong?
05:19:23 * dcoutts has been researching constraint based type inference algorithms
05:29:16 <musasabi> JohnMeacham: one nice small thing (implementation detail) could be to not check for cycles, but just let the typechecker loop on them and check every Nth operation whether a cycle has formed.
05:30:01 <musasabi> (makes things faster when there are no type errors and slower when reporting an error - but most definitions are usually ok)
05:33:07 <JohnMeacham> Yeah, I have improved the speed some so it is not too bad in that respect. but extending it with boxy types and existentials and all that goodness is tricky. that and the type errors are horrendous.
05:34:04 <pejo> dcoutts, hows it going?
05:34:33 <dcoutts> pejo, ok at the moment thanks
06:22:03 <dcoutts> @seen miked
06:22:04 <lambdabot> I haven't seen miked.
06:22:46 <dcoutts> ndm, do you know if Mike Dodds frequents #haskell?
06:22:58 <ndm> dcoutts, occasionally
06:23:03 <dcoutts> I notice he's working on Gyhe
06:23:04 <ndm> dcoutts: i can get him to go on now if you want
06:23:13 <ndm> dcoutts, he is, as we speak
06:23:29 <dcoutts> ndm, well you can tell him I'm avalialbe if he wants any advice on Gtk2Hs
06:23:53 <ndm> dcoutts, he's just coming...
06:24:06 <dcoutts> ndm, I'm not demanding his presense :-)
06:24:26 <ndm> he wanted to ask some questions about dragging and dropping files into a window
06:24:32 <dcoutts> just letting hime know that he can ask stuff
06:24:37 <ndm> or at least i want him to implement that, and hence questions arise :)
06:24:40 <dcoutts> ndm, ah, drag & drop
06:24:44 <dcoutts> mikd, hia
06:24:49 <mikd> hey dcoutts
06:25:02 <dcoutts> mikd, Gyhe is looking cool
06:25:06 <mikd> cheers
06:25:12 <mikd> it's going pretty well
06:25:16 <dcoutts> great
06:25:36 <mikd> gtk2hs is really cool :)
06:25:40 <dcoutts> ta :-)
06:26:04 <dcoutts> I notice you're working on osx. You'll be glad to know that a native Gtk+ port is in progress.
06:26:14 <mikd> oh excellent
06:26:19 <dcoutts> so it ought to look better in future
06:26:24 <mikd> yeah, I'd heard that there was a native gtk port
06:26:28 <xerox> Hi!
06:26:30 <mikd> how far along is it?
06:26:38 <dcoutts> more like how Gtk+ looks pretty much native on Windows
06:26:45 <takuan> are there functions in haskell to query for time?
06:26:53 <dcoutts> mikd, let me find the announcement
06:27:00 <ndm> @hoogle time
06:27:01 <lambdabot> Graphics.HGL.Units.Time :: Integer
06:27:01 <lambdabot> System.Locale.TimeLocale :: TimeLocale
06:27:01 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [
06:27:01 <lambdabot> (String, String)] -> String, String -> String -> String -> String ->
06:27:01 <lambdabot> String -> TimeLocale)
06:27:04 <takuan> ah
06:27:55 <Pupeno> Good morning.
06:28:08 <dcoutts> mikd, http://sourceforge.net/mailarchive/forum.php?thread_id=9057116&forum_id=8415
06:28:56 <mikd> dcoutts, well if you need any beta-testers, I'd like to give it a go
06:29:17 <mikd> X window system widgets are horrible :(
06:29:24 <dcoutts> mikd, it's still in the gtk cvs
06:29:35 <dcoutts> mikd, so it's probably a bit of an effort to build
06:29:54 <dcoutts> mikd, yeah it's using the Linux theme by default rather than an OSX theme.
06:30:10 <mikd> dcoutts, well I might give it a go
06:30:19 <dcoutts> and a rather boring theme at that :-)
06:30:23 <mikd> heh
06:30:47 <dcoutts> mikd, I'd be interested to know how it goes if you try it
06:31:07 <dcoutts> however I suspect it's not for the faint of heart :-)
06:31:31 <mikd> I'll post on the list if I succeed magnificently / fail horribly
06:31:37 <dcoutts> mikd, so you were wondering about drag & drop. Sadly that's a neglected area of the Gtk2Hs coverage.
06:31:46 <dcoutts> we could certainly improve it
06:32:05 <mikd> yeah, I thought that from the haddock api
06:32:11 <dcoutts> we haven't had anyone wanting to use it yet so it's not been high on the priority list
06:32:18 <ndm> the ability to detect when a file has been dropped would be very handy
06:32:26 <dcoutts> that, and it confuses us somewhat
06:32:43 <mikd> yes, the gtk documentation for dnd isn't very clear either
06:32:50 <dcoutts> yeah :-(
06:32:56 <mikd> I *think* it's supported on windows
06:32:58 <mikd> sort of
06:33:01 <dcoutts> there are low and mid level apis for it
06:33:05 <dcoutts> which is confusing
06:33:16 <dcoutts> I'd expect it is supported onw win32
06:33:25 <dcoutts> the win32 port is pretty complete
06:33:35 <mikd> I asked on the list about clicking TextTag widgets
06:33:40 <dcoutts> yes
06:33:42 <mikd> is that possible?
06:33:50 <dcoutts> I think we just need to bind the signal on the tag
06:33:55 <dcoutts> I'll look into it
06:34:05 <mikd> great :)
06:35:10 <dcoutts> so your dnd use case is jsut for loading files that are dropped on your main window?
06:36:15 <mikd> yeah
06:36:23 <dcoutts> doesn't sound too hard
06:36:28 <dcoutts> (famous last words)
06:36:39 <mikd> I'm actually not that bothered about it
06:37:01 <mikd> but ndm thinks it's important
06:37:06 <mikd> it'd be nice to have
06:37:06 <dcoutts> mikd, well we can have you switching to wxHaskell just because of lack of dnd support! :-)
06:37:14 <dcoutts> can/can't !!
06:37:20 * ndm thinks its very important
06:37:28 <dcoutts> ok ndm :-)
06:37:29 <mikd> heh, I'd forgotten I'd put that on the wiki
06:37:37 * dcoutts grins
06:37:48 <dcoutts> you got my attention :-)
06:37:50 <mikd> I'm not going to go to wxHaskell now
06:38:06 <mikd> that was when I had about 1/4 the code I've written now
06:38:14 <dcoutts> right
06:38:32 <dcoutts> mikd, did you see how to embed the icon in your source code?
06:38:42 <mikd> yeah, I'm just doing that now actually
06:38:53 <dcoutts> it's supposed to be possible with our current api (in two different ways I think)
06:39:05 <dcoutts> I've never tried it myself however.
06:39:15 <mikd> i'm doing it with an xpm
06:39:26 <mikd> I couldn't make the ffi method work
06:39:49 <mikd> hey, it works!
06:39:56 <dcoutts> pixbufNewFromXPMData or pixbufNewFromInline
06:40:06 <dcoutts> the inline one is tricky I believe
06:40:06 <mikd> the xpm method, that is
06:40:10 <dcoutts> ok, cool
06:40:37 <mikd> the screenshots I have up are quite old
06:40:51 <mikd> it looks much nicer now - I should put a new one up
06:40:54 <dcoutts> :-)
06:41:38 <mikd> anyway, gtg
06:41:54 <mikd> dcoutts: great to talk to you.
06:41:59 <dcoutts> you too
06:42:05 * dcoutts has to go to a meeting now
06:42:20 <dcoutts> mikd, feel free to ask stuff whenever
06:42:28 <mikd> thanks, I will
07:11:31 <araujo> Good morning!
07:26:47 <Pupeno> Hello araujo.
07:28:18 <Pupeno> How do you commonly write unit tests ? In another file ? on the same file ? in one file for a whole project, in one file per file ?
07:31:20 <Sven_Moller_Fah> how do i go from ["2","2","3","6","1","7"] to [2,2,3,6,1,7] ?
07:31:25 <Sven_Moller_Fah> using read for example?
07:31:42 <Pupeno> map read ["2","2","3","6","1","7"] ?
07:31:45 <Lemmih> > map read ["2","2","3","6","1","7"]
07:31:46 <lambdabot> Add a type signature
07:31:50 <Lemmih> > map read ["2","2","3","6","1","7"] :: [Int]
07:31:52 <lambdabot> [2,2,3,6,1,7]
07:31:52 <Sven_Moller_Fah> realy?
07:32:00 <Sven_Moller_Fah> lol thx
07:32:22 <Pupeno> Sven_Moller_Fah: awesome, isn't it ?
07:32:51 <Spark> the novelty of the map function never wears off for functional programmers
07:33:39 <Sven_Moller_Fah> lol
07:35:52 <Pupeno> I have a function [Char] -> PortID that I am tring to unit test, the problem is that PortID is not a member of Eq nor Show (the second is very disturbing). How should I do the testing ?
07:36:48 <Lemmih> You could make PortID an instance of Eq and Show.
07:36:50 <Saulzar> Pupeno, You can use the default - eg. data PortID = PortID Int deriving (Eq, Show)  
07:37:47 <Pupeno> PortID is a type of the Network module (http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html), I don't controle it
07:38:21 <Pupeno> Could I make PortID a member of Show and Eq just for my tests (on my module) ?
07:38:27 <Lemmih> You can't derive the instances but you can write them by hand.
07:38:32 <Saulzar> Ah - well you can still do as Lemmih says, and write the instance methods for Eq and Show
07:40:12 <Pupeno> Is doing that good style ?
07:43:01 * joelr1 is eating crow
07:43:06 <takuan> is there a simple way to do a time based iteration in haskell?
07:46:07 <joelr1> so 5 times less and then 5 times less again makes an order of magnitude, right?
07:47:21 <Igloo> Somewhere between 1 and 2 orders of magnitude
07:47:54 <joelr1> hmm
07:48:02 <joelr1> dcoutts: ping
07:49:24 <joelr1> Cale: ping
07:51:49 <boegel> joelr1: 5x*5x = 25x, 1 order of magnitude = 10x
07:52:05 <joelr1> cool
07:52:33 <joelr1> boegel: so it's 10x :-) or more, hell i don't even know now
07:52:47 <joelr1> huge freaking unbelieavable reduction in memory usage
07:53:29 <boegel> w00 !
07:53:45 <joelr1> i will blog about the whole thing very soon
07:55:39 <joelr1> i now use 1/2 less memory for 600 connections than i was using for 60 before
07:56:12 <boegel> I believe that's 2 order of magnitude, although I'm not sure
07:56:18 <joelr1> :D
07:57:37 <Igloo> That's x20, not x100...
07:58:14 <Igloo> (assuming 0 constant, which will certainly be wrong)
07:58:32 <Igloo> (but possible noise given the approximate nature)
08:00:46 <musasabi> What are the major differences of using Cairo vs Pancito for draving vector graphics?
08:01:08 <takuan> is there a simple way to do a time based iteration in haskell?
08:04:52 <SamB> musasabi: is pancito related to pango?
08:06:12 <SamB> ah, I see, a haskell library?
08:06:23 <musasabi> yes, related to Pan.
08:06:32 <musasabi> although crossplatform
08:06:40 <SamB> a, right, based on Pan
08:07:21 <SamB> well yes
08:07:26 <SamB> probably related to not having been done for an internship at MS Research
08:07:58 <Lemmih> takuan: You need to explain your question/problem better.
08:08:48 <SamB> well, iirc Pan didn't actually quite do vector graphics
08:11:15 <takuan> ok
08:11:46 <SamB> takuan: time-based?
08:11:57 <musasabi> this does with Doubles so I think it is the same as Cairo
08:13:00 <SamB> well, I don't think Cairo uses functions as its data structure...
08:16:50 <SamB> pancito looks, unsurprisingly, to be rather slow due to this technique...
08:20:34 <Cale> SamB: I thought it was also rather fast for using functions as its data structure.
08:21:42 <SamB> Cale: you mean fast for a library that uses functions as its principle data structure, or because of using functions as its principle data structure?
08:22:05 <takuan> second SamB 
08:22:05 <SamB> note that I'm not trying to imply that most things using functions as their principle data structure are slow...
08:22:11 <takuan> i'll be back in an hour or something
08:22:12 <SamB> takuan: hmm?
08:22:15 <SamB> oh
08:22:27 <Cale> Because of. I haven't actually tried it.
08:22:38 * Igloo mutters at segfaults deep in gstreamer/gobject code
08:22:41 <musasabi> Seems like pancito is more pretty, but lacks functionality as compared to cairo
08:22:59 <Cale> But I heard that it could do some things rather quickly that would be hard to optimise raster code for.
08:23:06 <musasabi> and I really don't care about performance for drawing static images.
08:24:33 <SamB> well, what functionality do you desire?
08:25:21 <musasabi> path objects and splines.
08:26:20 <musasabi> or bezier curver
08:26:58 <SamB> well, okay. I guess the basic difference is: pancito is a functional graphics library, cairo is a vector graphics library...
08:36:54 <tromp> any vi gurus here?
08:37:29 <Cale> I'd be hesitant to call myself a guru, but I use vim
08:37:56 <tromp> i want to repeat a series of 4 commands hundreds of times
08:38:25 <tromp> namely, join,join,join,down
08:40:40 <gilles> hi all!
08:41:00 <Cale> qa
08:41:08 <Cale> then type your commands
08:41:17 <Cale> which will put them in register a
08:41:28 <Cale> then 100@a
08:42:11 <Cale> er
08:42:13 <tromp> how does it know where my command end?
08:42:16 <Cale> sorry, q to stop recording
08:42:23 <gilles> i'm just beginning with haskell... i've got two questions if anyone cares answering: if i'd like to test a library (like for example the one for doing http connection) 1) am I forced to compile or install it? or is it possible to include it in my test file? 2) is it possible to test it from the intepreter?
08:42:38 <Cale> hi gilles 
08:43:12 <Cale> Well, it ought to be possible to test any code from ghci, say
08:43:14 <xerox> oi.
08:43:29 <Cale> Whether you have to install a given library depends on how it was packaged
08:43:44 <tromp> i did 433@a, but it came out wrong, and now it wont undo:(
08:43:56 <Cale> tromp: hmm
08:43:58 <gilles> what i tried is that : Prelude> import Network.HTTP and i got a parse error on 'import'
08:44:04 <Cale> tromp: it won't undo?
08:44:46 <ProfTeggy> tromp, use your backup file
08:44:47 <tromp> i shld first test with 2 repeats
08:44:53 <tromp> i re-loaded file
08:45:31 <Cale> tromp: is this vi or vim?
08:45:36 <Cale> you should use vim :)
08:45:39 <tromp> wow! it worked!
08:45:44 <Cale> great :)
08:45:47 <tromp> vim
08:45:56 <xerox> What are you trying? :-)
08:46:07 <tromp> looks impressive to see something done 433 times
08:46:07 <Cale> gilles: :m + Network.HTTP
08:46:21 <tromp> oh, had long list of numbers, one per line
08:46:28 <gilles> Cale: thanks :-)
08:46:28 <tromp> needed to group them by 4 on a line
08:46:29 <Cale> gilles: the syntax for loading modules in ghci is a little different
08:47:19 <gilles> i'm reading the tutorial, but it's really a *lot* of new things at once... esp. since i never really did any functional prog.
08:47:49 <Cale> gilles: yeah, most people have that experience :)
08:49:06 <gilles> last question: if I :load a program into the interpreter, i can launch it with "main" but it seems it doesn't like when i give him parameters... is there a special syntax for that?
08:49:17 <Cale> is this ghci?
08:49:22 <gilles> yes
08:49:39 <Cale> :set args <arg1> <arg2> ...
08:49:44 <gilles> thanks a lot!
08:49:58 <gilles> i'll be able to experiment a little now :-)
08:50:10 <Cale> :)
08:50:53 <Cale> Another trick is to write something like   main = do xs <- getArgs; realMain xs
08:51:34 <Cale> (or just   main = getArgs >>= realMain)
08:52:02 <Cale> the point of which is to be able to just pass a list of strings to your realMain function in the interactive environment
08:52:15 <gilles> yes i get the idea
08:53:03 <gilles> i'm not at all familiar with that monad syntax... but it doesn't seem very complicated 
08:53:15 <Cale> it's not too bad
08:53:27 <Cale> @type (>>=)
08:53:28 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
08:54:05 <Cale> well, for the purposes of IO, it's  IO a -> (a -> IO b) -> IO b
08:54:45 <Cale> so you give >>= an IO action returning a value of type a, and a function from a's to IO actions returning values of type b, and it chains them together
08:55:07 <Cale> into a single action which returns a value of type b
08:57:04 <Cale> do-notation is just shorthand for a bunch of (>>=)'s
08:58:26 <SamB> and >>s
08:58:57 <Cale> well, yeah :)
08:59:17 <Cale> but  x >> y = x >>= const y
09:00:15 <dcoutts> @seen CosmicRay
09:00:16 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 18 hours, 53 minutes
09:00:16 <lambdabot> and 1 second ago.
09:08:43 <lispy> morning
09:09:00 <Cale> morning
09:10:44 <lispy> what is #haskell-blah?
09:11:12 <Cale> discussion about anything but Haskell
09:11:27 <lispy> hmm...i see
09:11:31 <Cale> basically the off-topic version of this channel
09:12:05 * lispy nods
09:12:08 <xerox> basically.
09:12:16 * xerox unformalizes Cale
09:12:26 <Cale> heh
09:12:46 <xerox> Hi All,
09:12:46 <xerox> The t-shirts have arrived and are fabulous, now...we will send them
09:12:46 <xerox> out to you, our intrepid fantastic Summer of Coders.
09:12:49 <xerox> Oh yeah!
09:13:16 <lispy> heh, cool
09:13:23 <lispy> xerox: do you have a picture of them?
09:13:32 <xerox> Them, being what?
09:13:40 <lispy> t-shirts
09:13:50 <xerox> As soon as it arrives :-)
09:14:06 <lispy> er
09:14:13 <lispy> didn't youjust say they have arrived?
09:14:23 <Cale> lispy: presumably at Google
09:14:33 <lispy> Oh
09:14:39 * lispy is slow today
09:14:45 <xerox> Right-o.  That was cdibona@
09:16:14 <lispy> i'm going to have to find a way to participate next year, if they do it again
09:17:10 <xerox> Seems so.
09:19:25 * dcoutts congratulates xerox 
09:19:33 <xerox> Thanks much :-)
09:23:26 <Saulzar_> Well, I figured out a strange solution to my monad which partially evaluates and stops, by making the return type of Either a Command() ... pity that I'd decided it wasn't the best way to do it anymore :)
09:25:35 <Cale> Saulzar: Continuations?
09:26:44 <Saulzar_> It's not doing continuations, I had thought that would be another way - but then you can never "get out" of it...
09:26:59 <joelr1> Cale: implementing single-slot (TMVar vs TChan) mailboxes for my logger thread as well as for the poker clients reduced by memory consumption about 20 times
09:27:46 <dcoutts> joelr1, impressive
09:28:51 <joelr1> dcoutts: thanks to bulat's suggestion. don't know how i could have missed it before
09:29:06 <joelr1> dcoutts: and thanks to you guys of course. doing with arrays was still awesome
09:30:46 <sebell> joelr1: How do you find Haskell compared to Erlang for non-distributed computing? I'm assuming that you might get a speed-up by not using isolated threads, but message-passing does feel natural at times
09:30:58 <sebell> rather, non-distributed concurrent programming
09:31:18 <joelr1> haskell sucks so far :( but for non-obvious reasons
09:31:38 <joelr1> with erlang i can just examine the process mailbox, i.e. get the message count
09:31:46 <joelr1> and get a list of processes
09:31:57 <joelr1> i find myself implementing these things in haskell
09:32:53 <dcoutts> joelr1, yeah, the TVars/MVars TChan/Chan are lower level abstractions
09:32:53 <joelr1> it took me at least a couple of weeks to realize that my space leak was due to TChan accumulating messages, for example. and i still don't know why that happened
09:33:02 <joelr1> the patient died during autopsy
09:33:27 <dcoutts> since Haskell is not domain-specific for network switch message passing apps
09:33:39 <SamB> joelr1: I thought you weren't supposed to do autopsies until *after* the patient died?
09:34:13 <joelr1> a super-cool thing you can do in erlang is install message tracing. i can trace messages that match a certain pattern. i think i could do the same in haskell by supplying a predicate to pattern-match them
09:34:20 <Saulzar_> Cause of death - premature autopsy
09:34:25 <jethr0_> samb, that's for sissies. the real challenge is to do your work with the patient kicking and screaming...
09:34:35 <jethr0_> *macabre* ;-)
09:34:44 <joelr1> SamB: i know. what's what i meant. i decided not to figure out why the message queues were building up and move to TMVars 
09:34:56 <joelr1> presto, no message queues
09:34:59 <joelr1> no build-up
09:35:06 <joelr1> other problems now :D
09:35:32 <joelr1> is there a problem with this code?
09:35:33 <joelr1> {-# NOINLINE tracer #-}
09:35:33 <joelr1> tracer :: Tracer
09:35:33 <joelr1> tracer = unsafePerformIO $ startTracer
09:36:15 <dcoutts> joelr1, well it's not a nice trick, but it should work
09:36:21 <lisppaste2> joelr1 annotated #14302 with "tracer" at http://paste.lisp.org/display/14302#11
09:37:04 <joelr1> dcoutts: what about the contents of startTracer together with unsafePerformIO?
09:37:17 <joelr1> i would like tracer to be a singleton
09:37:43 <dcoutts> joelr1, you should be careful since atomically cannot be nested
09:37:57 <joelr1> hmm
09:38:05 <joelr1> that could be an issue
09:38:14 <dcoutts> dcoutts, tracer must never be used inside an atomically context
09:38:28 <joelr1> dcoutts: i think ghc crashes then but i have not seen any crashes
09:38:31 <dcoutts> since otherwise you'll be nesting atomically, which will fail dramatically
09:39:02 <dcoutts> joelr1, so it's a doubly not-nice thing to do
09:39:32 <dcoutts> can't the tracer just be created at the beginning and passed as a parameter to whomever needs it?
09:40:01 <joelr1> no, it can't :(
09:40:11 <joelr1> i have calls like trace_ all over the place
09:40:19 <Cale> joelr1: so perhaps I was right?
09:40:25 <joelr1> Cale: 100%
09:40:44 <Cale> memory issues are solved then?
09:41:09 <joelr1> Cale: i think so. other fish to fry now
09:41:18 <joelr1> it's like that tale about the bird
09:41:29 <joelr1> pulled the beak out, the tail got stuck 
09:41:35 <joelr1> and vise versa
09:41:52 <Cale> hehe
09:42:10 <joelr1> my tracer does not work right 
09:42:20 <joelr1> it only prints messages from a single place
09:42:21 <joelr1> hmm
09:42:26 <joelr1> dcoutts: what do you think of that?
09:42:58 <joelr1> it's like the first guy who gets hold of it prints to it. the first module?
09:43:03 <dcoutts> joelr1, I don't understand
09:43:06 <joelr1> and others do not
09:43:28 <Cale> Usually for logging you create a channel, and you pass the function which adds a message to that channel to your various threads
09:43:35 <joelr1> dcoutts: well, let me look into it some more
09:43:48 <joelr1> my issue is that i need to have just 1 channel
09:43:56 <joelr1> i created it like this
09:43:57 <Cale> yeah, that ought to work
09:44:08 <dcoutts> joelr1, which you get by passing the thing as an argument
09:44:16 <joelr1> Cale: you saw the paste, right?
09:44:19 <Cale> um
09:44:21 <dcoutts> you're trying to create a top level global variable
09:44:22 <Cale> which one?
09:44:31 <dcoutts> which is evil
09:44:36 <joelr1> http://paste.lisp.org/display/14302#11
09:44:38 <dcoutts> and always a hack
09:44:48 <joelr1> yes, i'm trying to create a top-level variable
09:44:52 <Cale> don't use unsafePerformIO for this :)
09:45:03 <dcoutts> joelr1, what does trace do?
09:45:49 <joelr1> logging
09:45:55 <joelr1> it prints to screen and to file
09:46:06 <Cale> all you really need to do is to create a logging channel in your main thread, create a trace function from it, and pass that function to your new threads which need to log
09:46:29 <Cale> and of course, spawn a thread to read that channel as quick as possible
09:46:49 <Cale> maybe a bounded channel would be appropriate
09:46:51 <joelr1> Cale: that would work but i find it handy to trace from all sorts of other places
09:47:02 <joelr1> Cale: i have a TMVar channel now, works for me
09:48:03 <joelr1> i can just say trace_ "foo bar" from somewhere deep and it shows up. sort of. it used t work when the var was a MVar, maybe i should switch to that
09:48:04 <Cale> yeah, that ought to work okay, as long as there's no problem with blocking when lots of messages get printed at the same time :)
09:48:13 <Cale> (which there probably isn't really)
09:48:21 <joelr1> Cale: it's a traade-off, let them block
09:48:24 <Cale> yeah
09:48:25 <joelr1> i have no requirement to run fast
09:48:55 <gilles> hmm... small prob again... what does this: Building NewBinary-0.1...
09:48:55 <gilles> Setup.lhs: internal error: stg_ap_v_ret means ?
09:49:21 <Cale> joelr1: this is more than just temporary debugging messages, I take it
09:49:37 <joelr1> Cale: no, these _are_ temporary messages
09:49:42 <Cale> gilles: um... internal compiler error
09:49:50 <gilles> doesn't sound good :)
09:49:54 <Cale> I'll have a look for it
09:50:08 <joelr1> Cale: at tracer?
09:50:10 <joelr1> hang on
09:50:11 <gilles> i was trying to compile NewBinary on MacOS X.4.3 using ghc 6.4
09:50:35 <lisppaste2> joelr1 annotated #14302 with "full code to Tracer" at http://paste.lisp.org/display/14302#12
09:50:40 <Cale> where did you get the copy of ghc?
09:50:45 <joelr1> it's standalone too
09:50:54 <joelr1> gilles: i did it w/o problems once
09:51:21 <joelr1> if setup is barfing then it could be Cabal maybe
09:51:21 <gilles> joelr1: did you give it any special parameters?
09:51:27 <joelr1> no, don't think so
09:51:32 <gilles> Cale: the url given in the darcs readme
09:51:47 <gilles> i can find it again if you need it
09:51:58 <gilles> http://haskell.org/ghc/dist/6.4/MacOSX/GHC-6.4.pkg.zip
09:51:59 <gilles> this one
09:52:44 <Cale> perhaps try http://www.haskell.org/ghc/dist/6.4.1/MacOSX/GHC-6.4.1.pkg.zip
09:52:52 <gilles> thanks
09:52:54 <joelr1> mine is from darwinports
09:52:56 <gilles> will it do the update?
09:53:11 <gilles> or should i uninstall something first?
09:53:14 <Cale> I'm not sure what it will do
09:53:27 <gilles> i'll try then :) thanks
09:53:35 <Cale> it was linked from the download page on the ghc site
09:54:31 <gilles> fine, i assume it'll detect that I already have something installed :)
09:54:49 <gilles> i'll get something to eat while it's downloading... thanks a lot for the help Cale!
09:54:52 <gilles> see you soon
09:54:56 <Cale> It's a MacOS X installer package, so I'd hope that it's reasonably smart :)
09:55:00 <Cale> see you
09:55:07 <Cale> joelr1: hmm
09:55:40 <joelr1> Cale: i suspect laziness here
09:55:51 <joelr1> trace :: Int -> String -> ScriptState () 
09:55:51 <joelr1> trace n a = 
09:55:51 <joelr1>     do w <- get
09:55:51 <joelr1>        when (debug_level w >= n) $
09:55:51 <joelr1>             liftIO $ trace_ a
09:55:56 <joelr1> although this used to work before
09:56:25 <joelr1> if i comment out the when and insert a print then the print prints but nothing goes into trace_ still
09:56:53 <Cale> odd
09:57:37 <SyntaxNinja> 'morning
09:57:44 <Cale> well, it ought to, are you sure it's not getting called anyway?
09:57:59 <Cale> what happens with a print in trace_ ?
09:58:47 <joelr1> it works 
09:58:55 <joelr1> maybe it gets called
09:58:58 <joelr1> wierd
09:59:01 <joelr1> investigating
09:59:08 <joelr1> it's not getting called from a single place
10:00:35 <Cale> is 'inbox' even in scope there?
10:00:39 <Cale> in trace_
10:00:57 <Cale> oh
10:01:02 <Cale> yes, from the case
10:01:23 <joelr1> Cale: what's happening is this
10:01:38 <joelr1> trace_ is being called fine from within the library where it was compiled, etc. 
10:01:55 <joelr1> but attempting to use it from the code that links to that library has no effect for some reason
10:02:10 <Cale> okay
10:02:24 <Cale> I think it might be strangeness with unsafePerformIO
10:02:36 <joelr1> this was working fine when tracer was unsafePerformIO $ newMVar ...
10:02:40 <joelr1> so i will look at that
10:02:46 <Cale> hmm
10:02:56 <joelr1> i will first switch away from STM
10:03:00 <dcoutts> unsafePerformIO should always make you wonder
10:03:02 <joelr1> to see if it makes a dfiferrence
10:03:05 <dcoutts> it really is unsafe :-)
10:04:42 <dcoutts> it allows you to break many rules of the language
10:05:02 <joelr1> unsafe IO + STM = nothing working :D
10:05:02 <dcoutts> and that is really not a good thing becuase everything else relies on those assumptions
10:05:47 <dcoutts> many optimisation rules break in the presence of unsafe IO
10:06:00 <dcoutts> you can cheat the type system with unsafe IO
10:07:58 <Cale> Even implicit parameters would be a better answer, I think
10:08:06 <Cale> (though they're somewhat evil too :)
10:08:48 <xerox> What are they actually useful for?  State?
10:08:58 <dcoutts> configuration
10:09:56 <joelr1> what are implicit parameters?
10:10:10 <joelr1> a simple example would be perfect
10:10:14 <Cale> You could pass the tracing function (partially applied against the TMVar to write to) through to where you need it with them
10:10:37 <joelr1> ah
10:10:39 <joelr1> partial eval
10:10:46 <xerox> Uhm.  That shows that "State" doesn't really mean something precise by itself :-)
10:10:58 <Cale> joelr1: well, do you know the "right way" to do it?
10:11:14 <takuan> SamB: the situation is like this
10:11:14 <joelr1> Cale: do what? parameters? no
10:11:24 <takuan> I have a function which i want to iterate over some data
10:11:25 <Cale> to get the logging you want done
10:11:33 <takuan> but I want the iteration to stop after some time
10:11:39 <takuan> a definite amount of time
10:11:47 <joelr1> Cale: i think so but let me just play with it some more
10:11:57 <takuan> is there some system to do that in Haskell?
10:12:04 <joelr1> switching to MVars from TMVars did not help so it must be a blocking issue somewhere or something
10:12:08 <joelr1> i'm investigating
10:12:23 <takuan> i don't have enough clues as to how monads work and should be programmed
10:12:27 <Cale> The "right way" is to create a TMVar in your main thread, and create a reader function and a writer function referring to that TMVar, and pass *those* into the appropriate threads
10:12:39 * araujo back from lunch
10:12:42 <Cale> takuan: yes, let me get you a link
10:13:03 <Cale> http://www.haskell.org/hawiki/TimingOutComputations
10:13:05 <joelr1> Cale: except that i need to create the file, etc.
10:13:12 <jethr0_> is there a standard apply function: (\x y -> x y) or so?
10:13:18 <Cale> joelr1: you do that in your main thread
10:13:24 <joelr1> so there's more initialization thatn just creating the MVar
10:13:28 <Cale> jethr0_: ($)
10:13:30 <joelr1> Cale: let me poke around
10:13:32 <jethr0_> hehe
10:13:35 <Cale> jethr0_: or id
10:13:46 <joelr1> i like the way i do it now since i only export trace_ from the module. and stopTracer
10:13:46 <Cale> joelr1: well, yeah
10:13:50 <joelr1> and the rest is hidden
10:14:09 <gour> dcoutts: ping
10:14:12 <joelr1> and  i can call trace_ from anywhere i want. i surmise that the first call performs the initialization and then it's just the value
10:14:27 <joelr1> except that the logging half works :) but i'll figure it out
10:14:34 <dcoutts> gour, pong
10:14:35 * joelr1 thanks everyone
10:14:51 <takuan> Cale: wow
10:14:52 <gour> dcoutts: have you seen that ghc is udner trac?
10:14:58 <takuan> does it need to be with threads and stuff?
10:15:02 <dcoutts> gour, yes
10:15:12 <takuan> for that's entirely what i don't want to do
10:15:12 <Cale> takuan: yeah
10:15:16 <takuan> the code is rather simple
10:15:30 <takuan> it would be a serious distraction to have to spawn threads
10:15:32 <gour> dcoutts: it looks like gtk2hs is a bit behind :-)
10:15:35 <SamB> takuan: threads aren't that bad
10:15:41 <Cale> takuan: um, what is it that you're doing?
10:15:45 <takuan> well
10:15:52 <takuan> it's a simple diffusion equation solver
10:16:02 <SamB> why does it have to be wall time?
10:16:18 <takuan> well, that's what my assistent asks :D
10:16:32 <Cale> It's really quite simple, you copy that code there
10:16:43 <Cale> and you don't have to think about the threads
10:16:45 <Cale> :)
10:16:47 <takuan> mkay
10:16:52 <dcoutts> gour, heh heh
10:16:53 <Cale> timeout :: Int -> IO a -> IO (Maybe a)
10:17:00 <takuan> but how do I explain that to the jury which doesn't understand shit of haskell?
10:17:13 <gour> dcoutts: should we also get annoyed enough before we switch?
10:17:14 <Cale> well, how else are you going to time things out?
10:17:26 <takuan> good question
10:17:36 <Cale> you need one process to keep track of the other
10:17:41 <takuan> the idea was to check the time after each iteration
10:17:46 <takuan> but I don't seem to get that to work
10:17:50 <SamB> @type until
10:17:51 <Cale> oh, I suppose you could do that
10:17:52 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:17:56 <takuan> that's the simple way in C++
10:18:00 <SamB> @type untilM
10:18:01 <Cale> I think it's actually probably harder
10:18:02 <lambdabot> Not in scope: `untilM'
10:18:10 <jethr0_> > map (left (+1) >>^ either id id) $ zipWith ($) (fix ([(Left), (Right)]++)) [1..10]
10:18:11 <lambdabot> [2,2,4,4,6,6,8,8,10,10]
10:18:18 <SamB> @type Control.Monad.untilM
10:18:19 <lambdabot> Not in scope: `Control.Monad.untilM'
10:18:20 * jethr0_ is starting to like arrows ;-)
10:18:22 <SamB> hmm
10:18:23 <dcoutts> gour, we don't have quite so many bugs as ghc
10:18:53 <dcoutts> gour, we'll see how it goes. Axel was thinking of doing better bug/issue trackign than we do now.
10:19:08 <dcoutts> gour, what does trac do appart from bug tracking?
10:19:42 <Cale> takuan: here, you just have one thread sleep a while and the other try to finish before the sleeping thread wakes up and returns first
10:19:55 <takuan> ok Cale 
10:19:56 <takuan> that's all fine
10:20:08 <takuan> but I repeat, this is code which is going to be compared next to C++
10:20:11 <Cale> okay
10:20:15 <takuan> it's for my thesis
10:20:38 <takuan> if I have to spawn threads in Haskell opposed to none in C++ that's not going to be pretty
10:20:38 <Cale> all right, so it's fairly easy to do the other way, I suppose
10:20:46 <takuan> well, i thought that to
10:20:53 <Cale> though I don't see how threads are a problem at all :)
10:20:54 <takuan> until i ran into monad problems
10:21:02 <Cale> they're not OS threads
10:21:02 * takuan neither
10:21:16 <takuan> but in this case it shouldn't be necessary
10:22:17 <takuan> could you lend me a hand on this?
10:22:22 <Cale> sure
10:22:37 <Cale> it should return the value of the last iteration after it times out?
10:22:49 <SamB> @pl does something like that
10:22:50 <lambdabot> does something like that
10:22:53 <Cale> you're definitely going to be using IO
10:22:53 <takuan> well, after a certain amount of time passes
10:23:00 * SamB thought it was going to do that
10:23:06 <gour> dcoutts: ticket system (not only bugs, e.g. support etc.), wiki, source browser with darcs backe-end and inter-links, e.g. wiki entries to tickets etc.
10:23:06 <takuan> there always is a result
10:23:17 <takuan> it doesn't matter that way to much time passes for example
10:23:18 <SamB> @pl f x = f x
10:23:19 <lambdabot> f = fix id
10:23:23 <Cale> You can't get away from IO here because getting the system time is IO :)
10:23:28 <takuan> I know
10:23:42 <Cale> is the function to iterate a pure function?
10:23:48 <dcoutts> gour, how would it integrate with our current website?
10:24:20 <takuan> yes it is Cale 
10:24:23 <Cale> how much time precision do you want?
10:24:25 <gour> dcoutts: this is good (& natural question)
10:24:32 <takuan> doesn't matter really
10:24:43 <takuan> seconds will be too coarse
10:24:50 <Cale> I suppose I can give you picoseconds :)
10:24:51 <takuan> i used milliseconds in C++
10:24:54 <takuan> :D
10:25:03 <gour> dcoutts: it uses css, but i didn't delve much into it, it is customize-able for sure
10:25:06 <takuan> let's add *10**9 there
10:25:15 <Cale> okay
10:25:35 <gour> dcoutts: i was more interested for the features
10:25:49 <takuan> basically the function should do an iteration and check afterwards if the chosen amount of time passed
10:25:56 <takuan> if it didn't it does another iteration
10:26:22 <dcoutts> gour, I'm not talikg about the apperance exactly, just how it'd relate to our existing site, since trac includes a wiki
10:26:27 <takuan> the problem is that I get stuck in the "do -stuff"
10:26:42 <Oejet> takuan: I'd like to see a performance comparison of threads vs. time checks each iteration.
10:26:42 <takuan> and the code looks real ugly
10:26:57 <dcoutts> gour, there would appear to be a certain amount of duplication between the trac wiki and the WP posts & categories
10:26:57 <takuan> Oejet: it doesn't matter
10:27:03 <takuan> performance is not the issue here
10:27:07 <takuan> elegance of code is the issue
10:27:11 <takuan> that's what my thesis is all about
10:27:43 <SamB> takuan: I think threads might be prettier
10:27:54 <Oejet> There is a timeout function in http://research.microsoft.com/%7Esimonpj/papers/stm/lock-free.htm
10:28:11 <Cale> that's definitely going to use threads :)
10:28:15 <SamB> you could use an MVar to extract the final value
10:28:26 <Cale> yeah, I showed him the threaded version :)
10:28:31 <gour> dcoutts: why? one can uses wiki formatting for writing tickets
10:28:33 <SamB> oh?
10:28:34 <Cale> http://www.haskell.org/hawiki/TimingOutComputations
10:28:51 <Cale> it's quite elegant actually :)
10:29:10 <takuan> yup
10:29:13 <Cale> you get a nice combinator for competing various IO actions against each other
10:29:16 <takuan> but it's a Maybe answer
10:29:20 <SamB> Cale: doesn't DTRT
10:29:22 <takuan> in my case, there is no maybe
10:29:30 <takuan> there always is an action
10:29:33 <Cale> Well, that's easy enough :)
10:29:37 <takuan> a result I mean
10:30:07 <takuan> the thing is
10:30:23 <Cale> oh, I see :)
10:30:27 <takuan> you get i.e. 400 msec, try to complete as many iterations as possible in that amount of time
10:30:43 <SamB> you're allowed to go slightly over, I hope?
10:30:59 <takuan> if you get 1 msec, you just wait until the iteration is complet
10:31:03 <takuan> even if it takes 1 hour
10:31:07 <takuan> yup SamB 
10:31:09 <Cale> okay
10:31:23 <SamB> thats not too hard
10:31:29 <takuan> I thought that too
10:31:33 <takuan> but I can't get it to work
10:31:43 <SamB> well, I mean, with threads and an MVar
10:32:04 <gour> dcoutts: and some of the present docs could (maybe) go into wiki?
10:32:24 <SamB> every iteration, you put the value in the MVar and then take it out right away at the start of the next...
10:32:49 <takuan> humz
10:32:59 <SamB> in the other thread, you sleep until the timeout and then take the value out
10:33:11 <SamB> and then kill the thread that was doing all the iterating
10:33:23 <dcoutts> gour, hmm, I dunno. I quite like the existing WP setup you made for us :-)
10:33:33 <takuan> humz
10:33:34 <Cale> getting the clock time and subtracting is annoying, because it has two fields
10:33:54 <Cale> it's split into seconds and picoseconds
10:34:09 <SamB> sleeping is nice and efficient and simple to understand ;-)
10:34:18 <Cale> also, you waste lots of time on subtracting :)
10:34:19 <gour> dcoutts: i like it too, but it would be nice to have ticket & bugs system, requests, online browsing of the source etc.
10:34:23 <takuan> ok
10:34:36 <takuan> but I can hear my assistents scream when they are going to see the code:
10:34:40 <takuan> "too complex!!!"
10:34:55 <Cale> I think MVars are pretty simple
10:34:57 <SamB> well, wait until you have it written out
10:35:03 <gour> dcoutts: the whole project gets more serious note, and, believe me, in the recent time i am seeing more and more projects which are only based on Trac
10:35:04 <takuan> then I have to explain why it can't be like in c++
10:35:06 <SamB> it should take 5 lines max
10:35:07 <Cale> It'll be like 4 lines of code
10:35:19 <Oejet> 3 lines.
10:35:20 <gour> dcoutts: however, i do not propose getting rid of WP :-)
10:35:24 <SamB> with a blank line or two
10:35:39 <Oejet> :-P
10:35:45 <takuan> compete is 7 lines
10:35:46 <gour> dcoutts: don't forget, with 1.0 we'll move to gallery 2.x
10:35:55 <Cale> takuan: yeah, but it does more :)
10:35:55 <SamB> more with type signatures
10:36:26 <Cale> takuan: that competes an arbitrary list of computations against each other
10:36:26 <takuan> humz
10:37:00 <takuan> ok, let's try it and see if I can simplify afterwards
10:38:36 <dcoutts> gour, ok
10:40:01 <Cale> I suppose it's a little more awkward due to the fact that you need to sequence that pure computation with respect to IO
10:40:14 <Cale> you can do that with Control.Exception.evaluate
10:40:19 <gour> dcoutts: trac also has 'Roadmap' (e.g. miling stones feature)
10:40:35 <Cale> or just require the input function to iterate to be of an IO type
10:40:35 <dcoutts> gour, well maybe we'd just not use the wiki feature of trac, and just use the issue tracking + source browsing etc
10:40:38 <Oejet> What is the type of that pure function?
10:41:26 <Cale> Oejet: a -> a
10:41:28 <gour> dcoutts: yes, it is possible, although more features is not a headache
10:41:44 <takuan> Cale: I don't get it
10:42:00 <Oejet> @index iterate
10:42:01 <lambdabot> Data.List, Prelude
10:42:08 <Oejet> @type iterate
10:42:09 <lambdabot> forall a. (a -> a) -> a -> [a]
10:42:41 <gour> dcoutts: i'll back soon, family called me for a dinner
10:42:59 <Cale> Oejet: the problem is, given a specified number of milliseconds, iterate for at least that long, and return the last value you get
10:43:42 <Oejet> Cale: Yes, I got that much. :-)  Now my brain is spinning.
10:44:01 <gour> dcoutts: have you seen zim http://zoidberg.student.utwente.nl/zim/index.shtml
10:45:07 <Oejet> Hm.
10:46:52 <SamB> maybe its a bit longer than I thought
10:47:00 <Cale> yeah, but still not long :)
10:47:04 <SamB> its got to do all those little things
10:47:23 <dcoutts> gour, it looks a bit like "Tomboy". http://www.beatniksoftware.com/tomboy/
10:48:18 <Cale> create a new mvar, create the loop thread, delay, take from the mvar, kill the loop thread, return the value. Then you have the loop thread which takes the mvar, evaluates the application of the function, then loops
10:48:32 <Cale> you can probably squeeze a bit though :)
10:48:55 <takuan> can you put that into some example code Cale?
10:49:04 <takuan> I would be really happy
10:49:12 <takuan> been looking over it for 3 hours unsuccessfully now
10:49:15 <takuan> i'm getting tired
10:49:53 <Oejet> doit v (x:xs) = atomically (writeTVar v x) >> doit v xs
10:50:14 <Oejet> doit v (iterate f x0)
10:50:53 <Cale> takuan: sure
10:51:59 <Oejet> doit is taking a list of the values after each iteration and furiously writes them into the global variable v.
10:52:23 <SamB> Cale: so how do we make sure the value is suffiently evaluated?
10:52:27 <Oejet> One at a time that is and in order.
10:52:35 <Cale> SamB: Control.Exception.evaluate?
10:52:50 <Cale> http://www.haskell.org/hawiki/TimingOutComputations -- added some code
10:53:15 <SamB> Cale: I was under the impression that that only went to WHNF?
10:53:23 <Cale> well, yes
10:53:39 <Cale> if you want more than that, you'll need to use strict data constructors
10:53:51 <SamB> hmm
10:53:54 <SamB> okay then, whatever
10:53:55 <Cale> or explicit seq
10:54:15 <Cale> well, you could also insist on an instance of NFData or DeepSeq
10:54:37 <Cale> Let's try the other way
10:54:44 <Cale> with getClockTime
10:54:48 <Cale> just for fun
10:56:16 <takuan> ok that works
10:56:20 <takuan> thanks Cale!
10:59:06 <Cale> well, this might be simpler actually, despite the odd time calculations :)
10:59:18 <Cale> as long as you factor that bit out :)
11:00:14 <takuan> is that microseconds?
11:00:37 <Cale> ah, yes
11:02:45 <SamB> mine is very inaccurate...
11:03:14 <SamB> *Main> iterateWithTimeout 0 (+1) 0 >>= print
11:03:15 <SamB> 18573
11:03:15 <SamB> *Main> iterateWithTimeout 0 (+1) 0 >>= print
11:03:15 <SamB> 22088
11:03:49 <CosmicRay> @seen jafffacake
11:03:50 <lambdabot> I haven't seen jafffacake.
11:03:57 <palomer> http://www.rafb.net/paste/results/vMeQtn11.html <--what are the advantages of the top declaration over the bottom declaration?
11:04:03 <CosmicRay> @seen JaffaCake
11:04:04 <lambdabot> I saw JaffaCake leaving #haskell 4 days, 2 hours, 25 minutes and 1 second
11:04:04 <lambdabot> ago.
11:04:10 <CosmicRay> lambdabot: ah ha!  caught you in a lie! 
11:04:38 <Cale> STM seems a bit like overkill for this, especially as we're not actually using any features of STM
11:04:44 <jethr0_> lambdabot took a sick leave in the meantime
11:04:45 <SamB> you used three fs the first time
11:05:09 <SamB> Cale: well, does STM support MVars?
11:05:25 <SamB> oh, wait,
11:05:28 <Cale> SamB: I think they should work fine alongside each other
11:05:32 <SamB> thats a stupid question
11:05:51 * SamB keeps forgetting that you only use STM for the atomical bits
11:05:57 <Cale> right
11:06:25 <Oejet> Cale: I was considering using `orElse` somehow. :-P
11:06:27 <palomer> I mean, seriously, I don't see how GADTs are useful in the Term example
11:06:49 <SamB> palomer: oh?
11:07:12 <Cale> um, that STM version wasn't tested was it?
11:07:33 <SamB> palomer: well, write me an eval for the bottom declaration
11:08:26 <Cale> palomer: really?
11:08:31 <SamB> ... which gives results in normal Haskell datatypes
11:08:36 <palomer> SamB: check out my paste
11:08:41 <Cale> it's so pretty with the GADTs by comparison
11:08:41 <Oejet> Cale: Working on it. ;-)
11:08:47 <SamB> palomer: I did
11:09:10 <SamB> yeah, the non-gadt version specifies nothing
11:09:20 <Cale> um, the bottom isn't equivalent at all
11:09:30 <SamB> you'd need to add a bunch of comments
11:09:49 <Cale> also, I'm assuming that you'll be deferring those type errors to runtime?
11:10:04 <palomer> oh my, I get stuck at pairing
11:10:20 <palomer> wait, how does that function work with GADTs?
11:10:26 <palomer> it may either return an int or a pair
11:10:29 <SamB> they wouldn't be type errors
11:10:37 <Cale> eval :: Term a -> a
11:10:54 <Cale> you retain the type of evaluating the Term in the type parameter
11:11:04 <palomer> oh my, this must make type inference a pain
11:11:08 <SamB> palomer: is the light beginning to dawn?
11:11:14 <palomer> (who knows, it may not even be decidable!)
11:11:21 <SamB> its wobbly, apparantly!
11:11:31 <Cale> palomer: it requires some annotations
11:11:39 <palomer> ugh, raise you're hand if you think I should write my thesis on type inference with GADTs
11:11:46 <Cale> but otherwise proceeds just fine
11:11:52 <Cale> um
11:11:55 <SamB> I don't have hands on IRC!
11:12:03 <Cale> that paper's been written already
11:12:19 <palomer> type inference without annotations
11:12:22 <SamB> that too
11:12:25 <palomer> where?
11:12:27 <Cale> Unless you're thinking of improving it further
11:12:30 <SamB> oh, no not that
11:12:49 <Cale> It only requires *some* annotations. I think it may be undecidable otherwise.
11:13:00 <palomer> Cale: have a reference?
11:13:12 <Cale> for which?
11:13:15 <Cale> GADTs?
11:13:19 <palomer> undecidability
11:13:26 <palomer> of type inference for GADTs
11:13:33 <Cale> hmm
11:13:40 <SamB> palomer: couldn't you read the paper?
11:13:47 <SamB> @google "wobbly types"
11:13:48 <palomer> the wobbly type paper?
11:13:49 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/gadt/old-wobbly.htm
11:13:53 <SamB> hmm.
11:14:00 <Cale> that's the old paper
11:14:05 <SamB> Cale: clearly
11:14:09 <palomer> SamB: the wobbly type paper simply states that type inference is easy given proper annotations
11:14:24 <Cale> http://research.microsoft.com/Users/simonpj/papers/gadt/ is the new one
11:14:32 <SamB> palomer: does it not have a bibliography?
11:14:56 <SamB> ooh, a new version
11:15:04 <SamB> maybe I will be able to understand this one
11:15:05 <jethr0> @type guard
11:15:07 <lambdabot> Not in scope: `guard'
11:15:11 <jethr0> @type Control.Monad.guare
11:15:13 <jethr0> @type Control.Monad.guard
11:15:13 <lambdabot> Not in scope: `Control.Monad.guare'
11:15:14 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
11:15:30 <jethr0> @pl \x -> Control.Monad.guard (x==Nothing)
11:15:31 <lambdabot> ((Control . Monad) .) . guard . (Nothing ==)
11:15:47 <Cale> haha
11:15:54 <Cale> poor @pl
11:16:04 <SamB> "type inference is known to be difficult"
11:16:09 <Oejet> Cale: The STM version works now, but...
11:16:13 <Oejet> *Main> timeOutIterate 10000000 (+1) 0 >>= print
11:16:13 <Oejet> *** Exception: stack overflow
11:16:13 <SamB> @pl \x -> guard (x==Nothing)
11:16:14 <lambdabot> guard . (Nothing ==)
11:16:35 <Cale> Oejet: right, because iterate has that problem
11:16:37 <palomer> SamB: yeah, he doesn't mention undecidability
11:16:41 <palomer> (which is something he would mention)
11:17:05 <SamB> palomer: thats true
11:17:13 <Cale> Oejet: you end up with a huge unevaluated expression which is forced at the time when you want to print it
11:17:51 <Oejet> Cale: Hm, yeah I get it.  This lazy IO stuff is tricky.
11:19:25 <Cale> Oejet: that's why I used Control.Exception.evaluate, since it ensures the order of evaluation of an expression happens in step with the rest of the IO
11:19:48 <SamB> Oejet: well, most of the time when you iterate you force-as-you-go
11:19:55 <Oejet> Cale: That's clear.
11:20:14 <takuan> somethings wrong with the microseconds
11:20:29 <takuan> it looks like they are 10**-4 seconds instead of 10**-6 seconds
11:20:52 <SamB> maybe they aren't microseconds?
11:21:25 <takuan> that's what it looks like
11:21:40 <takuan> but on zvon they say microseconds
11:22:03 <Cale> seem like microseconds on my machine
11:22:11 <Cale> with both of my versions at least
11:22:23 <takuan> strange
11:22:30 <Cale> what OS?
11:22:37 <Cale> also...
11:22:59 <jethr0> @pl even $ (+) 4 5
11:23:00 <lambdabot> even 9
11:23:17 <jethr0> @pl \x y -> even $ (+) x y
11:23:18 <lambdabot> (even .) . (+)
11:23:32 <takuan> Cale: debian
11:23:34 * jethr0 still hates the dots
11:23:40 <Cale> could you tell me what System.CPUTime.cpuTimePrecision is?
11:24:50 <takuan> 10000000000
11:25:22 <Oejet> takuan: Nice. :-)
11:25:37 <Cale> so your system timer has a 10000 microsecond resolution
11:26:18 <SamB> Cale: I don't believe it!
11:26:22 <SamB> I think it is lying
11:26:27 <takuan> maybe
11:26:52 <jethr0> did someone else ever have trouble with parentheses? is there a semantic difference between (f $ g a b) and (f.g) ?
11:27:02 <jethr0> concerning the parens?
11:27:03 <Cale> well, that's actually for the getCPUTime command, which is different, but I suspect related
11:27:31 <Cale> jethr0: parens always mean grouping
11:27:53 <Cale> a and b don't occur in the second expression
11:28:14 <Igloo> parens in sections and functionification of operators have additional meaning
11:28:19 <jethr0> yes, because "f . g a b" isn't legal, right?
11:28:25 <jethr0> > even . (+) 4 5
11:28:26 <lambdabot>  add an instance declaration for (Show (a -> Bool))
11:28:32 <Cale> it's legal
11:28:35 <jethr0> (even $ (+) 4 5)
11:28:39 <Cale> but it might not do what you're thinking
11:28:39 <jethr0> > (even $ (+) 4 5)
11:28:41 <lambdabot> False
11:28:46 <jethr0> > (even . (+) 4 5)
11:28:47 <lambdabot>  add an instance declaration for (Show (a -> Bool))
11:29:04 <Oejet> Both versions of timeoutIterate (with and without threads) has about the same overhead, sometimes one faster, sometimes the other.  Tested with "]ghc --make -O2 timeout.hs" and 10 seconds running time each.
11:29:07 <jethr0> no, i am aware of what it's doing, but in some cases parens build a section and in some they just group
11:29:12 <jethr0> or is that my stupidity?
11:29:37 <Cale> jethr0: okay, yeah
11:29:58 <Cale> they only build a section when an infix operator is at the left or right end of them though
11:30:10 <jethr0> i take that as affirmation of my sanity *g*
11:30:46 <Cale> and that 'or' is exclusive
11:31:03 <Cale> an infix operator at both ends is a syntax error
11:31:13 <jethr0> hehe, "((+) 4 (+))"... but cale said it was supposed to work ;-)
11:31:33 <Cale> ah, and that operator can't itself be in parens
11:31:40 <Cale> that's just a type error
11:31:47 <jethr0> arg, my bad, don't listen to the fool behind the curtain...
11:31:51 <Cale> > ((+) 4 (+))
11:32:09 <jethr0> hmm...
11:32:14 <jethr0> > (+ 4 +)
11:32:21 <Cale> heh, not even going to dignify it with a response
11:32:30 <jethr0> > 4 + 5
11:32:39 <jethr0> he's kinda speechless at the moment
11:32:44 <jethr0> > False
11:33:03 <Cale> lambdabot: @reconnect
11:33:08 <Cale> hmm
11:33:17 <jethr0> you might have killed him with your ascii-art (or rather mine ;)
11:34:21 <jethr0> any ideas how to simplify "\(a,_) (b,_) -> a == b" ?
11:34:30 <jethr0> @pl \(a,_) (b,_) -> a == b
11:34:53 <jethr0> *damn*
11:35:10 <Cale> @pl \(a,_) (b,_) -> a == b
11:35:11 <mbot> (`ap` snd) . (. fst) . (const .) . (==) . fst
11:35:15 <jethr0> great
11:35:29 <Cale> % Integrate[Sqrt[Cos[x]], x]
11:35:30 <jethr0> nothing like a goood simplification...
11:35:31 <mbot> Cale: 2*EllipticE[x/2, 2]
11:35:44 <jethr0> > (+ 4 +)
11:35:45 <mbot>  parse error on input `)'
11:36:00 <Cale> any idea why my gnome-panel is taking 106 MB of memory?
11:36:21 <Spark> mmap?
11:36:27 <flux__> so nobody has yet taken on the idea of writing @pointful, @unpl, or something?-)
11:36:33 <jethr0> not really. maybe you pasted your harddrive's content :P
11:36:59 <Cale> and gnome-vfs-daemon is at 175.9 MB
11:37:08 <kzm_> @seen
11:37:09 <mbot> I haven't seen .
11:37:10 <Cale> nautilus at 83.4
11:37:12 <kzm_> :-)
11:37:21 <kzm_> @botkick
11:37:21 <mbot> Unknown command, try @listcommands.
11:37:28 <jethr0> flux__, would be nice... "@unpl $ @pl" would transform code into normal form
11:37:38 <Cale> I'm running a somewhat older version of lambdabot
11:37:50 <kzm_> mbot is yours, cale?
11:37:53 <flux__> jethr0, well, it would propably convert the code 'to the other extreme'
11:38:04 <Cale> kzm: yeah
11:38:05 <kzm_> and where is \bot?  This is bot anarchy!
11:38:08 * kzm_ grins
11:38:10 <jethr0> hmm, then we need @optimal-pointiness
11:38:17 <Cale> lambdabot stopped responding
11:38:22 <kzm_> again.
11:38:33 <jethr0> cale, did you write the integration yourself?
11:38:44 <Cale> jethr0: no, that's an interface to mathematica
11:38:48 <kzm_> @seen shapr
11:38:49 <mbot> I haven't seen shapr.
11:38:56 <flux__> people, these lambdabot issues aren't good advertisement for writing dependable software in haskell!
11:38:59 <flux__> ;)
11:39:44 <jethr0> nobody needs to hear about it... ever!
11:39:50 * Cale restarts gnome-panel and usage goes down to 26.1 MB. Can we say "memory leak"?
11:40:23 <jethr0> well, before getting a new version, firefox would take up _all_ swapspace and then eventually be killed by the vm.
11:40:37 <Cale> yeah, firefox is quite bad too
11:40:45 <Cale> and xmms
11:40:46 <jethr0> no idea, where you could lose nearly 1.5gb in mere minutes...
11:40:54 <Cale> whoa
11:41:00 <Cale> I've had nothing that bad
11:41:15 <jethr0> well, after the update it's all back to normal.
11:41:30 <Cale> 1.5 has seemed buggy to me
11:41:30 <jethr0> but still, imagine forgetting to deallocate 1.5gb *brr*
11:41:35 <Philippa> so, still leaking over time?
11:41:50 <Cale> 1.5 has strange UI issues on my machine
11:41:52 <Philippa> ("back to normal")
11:42:07 <flux__> my firefox just crashes for some reasons every now and then, which takes care of the memory leak problem nicely.
11:42:47 <Cale> like the menu selection being flickery and unresponsive, and dialog windows starting at stupid sizes which cut off a bunch of the controls
11:42:58 <jethr0> no, keeping steady at 289mb virtual/167mb resident... and that running for 4 days or so
11:43:24 <jethr0> it's still rather much, but as long as it won't unexpectedly be slaughtered by the VM, i can live with it
11:43:52 <jethr0> flux__, maybe it's the VM failsafe in your case as well
11:44:19 <flux__> nope, nothing in dmesg
11:44:21 <jethr0> well, i am quite fond of firefox. opening hundreds of tabs doesn't bring it down like it used to...
11:44:41 <flux__> and it also gives some assertion or related error message to console
11:44:56 <flux__> oh, well not this last time I see
11:45:08 <flux__> maybe infact all those things are older messages ;)
11:45:13 <jethr0> kde killed my habit of trying to read console messages ;-(
11:45:33 <jethr0> of gui applications
11:45:47 <flux__> "Gdk-WARNING **: gdk_property_get(): length value has wrapped in calculation (did you pass G_MAXLONG?)" - how do I have a feeling that these kinds of warnings wouldn't exist if that stuff were written in ml or haskell :/
11:45:59 <flux__> (using magic values)
11:46:52 <jethr0> well, it's also a question of so called "elitism". put all wannabe-programmers to work on haskell and they'll make a mess of it...
11:47:16 <jethr0> they'll just have a harder time doing it; AND it might just be bad code, and less unsafe apps!
11:48:10 <gour> dcoutts: when i mentioned zim, i was thinking that it has (almost ?) the same syntax as txt2tags & trac wiki
11:48:16 <flux__> it is just my feeling that those mentioned staticly typed languages really make it easier to handle corner cases; for instance sum types make expressing things more easy and less fragile
11:48:44 <mrchebas> argh! I am losing hair trying to get a cabal install to work with a package!
11:48:51 <mrchebas> any cabal guru around?
11:49:19 <jethr0> i think it's a good idea to have "safe" numeric types (overflow, ...) as default and use the machine types only for late optimising.
11:49:28 <jethr0> but then a C guru might argue otherwise
11:50:29 <Cale> jethr0: yeah, Integer rather than Int
11:51:00 <Cale> I wish we had arbitrary precision floating point in the standard
11:51:15 <jethr0> looking at his own code *cough*. well, i stil got my newbie stupidity credits, ain't i ;-)
11:51:47 <jethr0> how would you constrain that for irrationals? laziness?
11:51:50 <astrolabe> Cale: More work for the compiler writers.  Maybe a library?
11:51:51 <Cale> Haskell does prevent you from making the most egregious mistakes
11:52:08 <Cale> jethr0: yeah, laziness
11:52:42 <jethr0> yup, and i appreciate it a lot. but many high-level mistakes are made due to bad code quality and this can't be changed by a language alone.
11:52:56 <Cale> astrolabe: well, we're already using a library which provides them
11:53:16 <Cale> GHC links with GMP, which has all that sort of thing in it.
11:53:45 <jethr0> cale, but does that always work? aren't there some weird "non-sequential" functions on floats? don't know, i'd just be amazed if it were so easy *g*
11:53:52 <astrolabe> Ah.  I see.
11:54:47 <jethr0> also, you could have a "transparent" union type of BoundedFloat and Unbounded (for speed)
11:55:05 <Cale> jethr0: well, if you decide on a number of digits to print, it will always work
11:55:11 <Cale> or to compare
11:55:37 <Cale> in general, of course it's impossible
11:55:57 <jethr0> well, constraining comparison length kinda defeats part of the purpose i guess
11:56:48 <Cale> In fact, if you can give me a working comparison function on real numbers represented using suspended computations, I can solve a lot of unsolved mathematical problems
11:57:04 <Cale> For instance, Goldbach's conjecture :)
11:58:16 <lisppaste2> jethr0 pasted "othello v3" at http://paste.lisp.org/display/14384
11:58:18 <Cale> It's about the same as comparing infinite lists
11:58:47 <jethr0> cale, you had an idea of implementing the "Board" as monad for passing the dimension...
11:59:12 <jethr0> could you elaborate on/repeat that please, 'coz i didn't fully get it...
11:59:16 <Cale> not for passing the dimension
11:59:19 <Cale> for passing the board
12:00:11 <jethr0> ah, ok
12:00:26 <Cale> also, for making sure that functions can't use the board improperly
12:00:43 <Cale> for example, right now, a function is allowed to make invalid moves on the board
12:01:28 <jethr0> yup, that's right... so, how would that work with a state monad. the board would be intransparent to all functions but "makeMove" and "showBoard"?
12:01:39 <Cale> yeah
12:01:46 <Cale> well, maybe even to showBoard
12:02:11 <Cale> you could just provide an operation to observe the board positions
12:02:27 <Cale> but makeMove would be allowed in
12:02:32 <Cale> you make a new module
12:02:33 <jethr0> true. ok, so all functions would take "ST Board"?
12:02:38 <maitscha> hallo. i have some problem, I have a type "newtype WGraph a = WG [(a,[(a,Int)])] deriving Eq" and "type SWGraph a = [(a,[(a,Int)])]". I have to convert the abstract type WGraph to type SWGraph. any ideas?
12:03:31 <Cale> makeMove :: Point -> BoardState Bool
12:03:48 <jethr0> you posted an url to an example yesterday?
12:03:52 <Cale> yeah
12:04:32 <Cale> http://www.haskell.org/hawiki/MonadRandom
12:04:41 <jethr0> cool, thx
12:04:49 <Cale> there, the hidden state is the random number generator
12:05:11 <Cale> in your case, it will be the board array, and which player's turn is next
12:06:05 <jethr0> yep, i'll try sth with that. also thx for your help yesterday. i finally got around to using "join". and by now the nested monad code has become pretty readable, i hope.
12:07:20 <Cale> you mix >>= and do a little bit more than I would, but it looks fine
12:07:42 <jethr0> yes, i changed that... i'm in a bit of a conciseness phase right now
12:08:18 <jethr0> BTW, is there a pattern for "let x = do ...; if x == Nothing then False else True"
12:08:39 <Cale> isJust x ?
12:08:45 <Cale> > isJust Nothing
12:08:47 <mbot> False
12:08:51 <Cale> > isJust (Just 5)
12:08:53 <mbot> True
12:09:11 <jethr0> sure, but i mean for taking the "result" of a monad and transforming it...
12:09:17 <Cale> oh
12:09:19 <Cale> fmap
12:09:39 <Cale> > fmap (+1) (Just 5)
12:09:40 <jethr0> "let x = do ...; case x of Just x -> x+5; _ -> 2"
12:09:41 <mbot> Just 6
12:09:49 <Cale> > fmap (+1) Nothing
12:09:50 <mbot> Nothing
12:09:59 <jethr0> cool, that already helps a lot
12:11:31 <Cale> the maybe function is also often handy
12:11:44 <Cale> it's like foldr for Maybe
12:11:44 <Cale> hehe
12:11:45 <Cale> @type maybe
12:11:46 <mbot> forall b a. b -> (a -> b) -> Maybe a -> b
12:11:55 <jethr0> didn't know that, but my guess is that it's an equivalent of "either"
12:12:07 <jethr0> or not...
12:12:11 <Cale> either is related, yeah
12:12:13 <Cale> @type either
12:12:14 <mbot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
12:12:21 <jethr0> hmm, i see
12:12:23 <Cale> that's like fold for Either
12:13:05 <jethr0> > map ((left (+1)) >>> (right (subtract 1)) >>^ either id id) $ zipWith id (fix ([(Left), (Right)]++)) [1..10]
12:13:07 <mbot> [2,1,4,3,6,5,8,7,10,9]
12:13:09 <jethr0> hehe
12:13:57 <Cale> > [1..5] >>= \x -> [2*x, 2*x-1]
12:13:58 <mbot> [2,1,4,3,6,5,8,7,10,9]
12:14:18 <jethr0> ya, i know. but i am playing around with arrows, so that justifies it ;-)
12:14:23 <Cale> hehe
12:17:30 <Cale> hmm, there should be a special name for  foldr (mplus . return) mzero
12:17:55 <xerox> jethr0: woop?
12:18:06 <jethr0> wazzup?
12:18:19 <xerox> What's that >>^ !
12:18:33 <Cale> xerox: there was a guy asking whether you got the jstor article
12:18:42 <Cale> in #math the other day
12:18:53 <xerox> Cale: ah, can you tell me the nick?
12:18:55 <jethr0> (>>^ f) = (>>> arr . f) or so
12:18:58 <Cale> um, let me see :)
12:19:34 <jethr0> applies a pure function afterwards
12:19:52 <xerox> jethr0: so >>^ = >>> in fact
12:19:54 <Axioplase> Hi
12:20:13 <jethr0> ">>^ either id id" = ">>> (arr either) id id"
12:20:16 <jethr0> or some such
12:20:26 <Axioplase> How can I convert a number to a string? (or print a number in a file, or on stdout)
12:20:29 <xerox> > ((*3) >>> (+1)) 2
12:20:31 <mbot> 7
12:20:33 <xerox> > ((*3) >>^ (+1)) 2
12:20:35 <mbot> 7
12:20:44 <Cale> Dec 05 23:15:10 <exsisonek>	anyone seen xerox here in the past week or so?
12:20:52 <xerox> Cale: thanks much.
12:21:00 <Cale> Dec 05 23:30:56 <exsisonek>	Cale: I sent him a jstor article a week ago and never heard back, and haven't been here either...just trying to make sure he got it
12:21:08 <jethr0> xerox, no idea why that works... maybe Num is already in arrow or so
12:21:19 <Cale> jethr0: (->) is an arrow
12:21:27 <xerox> Yep.
12:21:37 <jethr0> what is (->)
12:21:43 <xerox> @kind (->)
12:21:44 <Cale> the type constructor of functions
12:21:45 <mbot> ?? -> ? -> *
12:21:55 <xerox> mbot?
12:22:07 <Cale> yeah bot isn't responding
12:22:13 <jethr0> ?? so what do you need "arr" for. i thought you needed it to lift functions to arrows
12:22:14 * xerox hehs
12:22:23 <xerox> jethr0: right-o.
12:22:30 <SamB> @type (Control.Arrow.>>^)
12:22:32 <mbot> forall d b (a :: * -> * -> *) c.
12:22:32 <mbot>         (Control.Arrow.Arrow a) =>
12:22:32 <mbot>         a b c -> (c -> d) -> a b d
12:22:36 <Cale> jethr0: ...if you're not in the trivial arrow
12:22:46 <jethr0> ah, it's a question of arrows
12:22:48 <Oejet> Axioplase: Try looking up "show".
12:22:50 <SamB> @type (Control.Arrow.>>>)
12:22:51 <mbot> forall (a :: * -> * -> *) d b c.
12:22:51 <mbot>         (Control.Arrow.Arrow a) =>
12:22:51 <mbot>         a b c -> a c d -> a b d
12:23:12 <Cale> oh, sorry Axioplase, I'd have answered, but I somehow missed that
12:23:39 <Cale> oh, because I was looking through my irc logs, so blame xerox :)
12:23:39 <Cale> hehe
12:23:47 <xerox> :(
12:24:05 <Cale> it's all good now though
12:24:23 <Cale> > show 568
12:24:24 <mbot> "568"
12:24:32 <Cale> > show [1,2,3,4,5]
12:24:33 <mbot> "[1,2,3,4,5]"
12:24:42 <Cale> > show 224.823
12:24:44 <mbot> "224.823"
12:24:45 <xerox> > show xxxx
12:24:47 <mbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\
12:24:47 <mbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:24:47 <mbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:24:47 <mbot> \\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:24:47 <mbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:24:49 <mbot> [21 @more lines]
12:24:50 <xerox> hahaha.
12:24:52 <Cale> hehehe
12:25:00 <jethr0> hehe
12:25:02 <xerox> 'show xxxx' is xxxx-rated.
12:25:19 <jethr0> hohoho
12:25:20 <Axioplase> Oejet: yep. I just found out
12:26:03 <jethr0> xerox, i fooled around a bit with Control.Arrow.loop. but i'm too stupid to work out how it is supposed to work
12:26:12 <xerox> @type Control.Arrow.loop
12:26:13 <mbot> forall (a :: * -> * -> *) c b d.
12:26:13 <mbot>         (Control.Arrow.ArrowLoop a) =>
12:26:13 <mbot>         a (b, d) (c, d) -> a b c
12:26:50 <jethr0> you know, it's for passing output into input...
12:27:21 <jethr0> "loop (\(x, y) -> (2*x, y `div` 2))" or some such
12:27:49 <xerox> > loop (\(x,y) -> (2*x, y `div` 2)) 1
12:27:50 <mbot> 2
12:28:02 <jethr0> yep, it's not quite doing what i'd like it to
12:28:09 <xerox> There's something to read about I think :-)
12:28:15 <jethr0> ;-)
12:28:24 <jethr0> well, the problem is: there _nothing_ to read about...
12:28:38 <xerox> musasabi has something I bet
12:28:40 <jethr0> except it saying that the looped-in/output will only be evaluated once or so
12:28:53 <xerox> ...if it's in the right place to access the famous bookmarks-list.
12:28:55 <jethr0> yeah, i found something of his in the irc logs...
12:28:55 <Cale> http://haskell.org/arrows/
12:29:20 <xerox> Cale: more specifically, please?
12:29:25 <xerox> Hug00 ?
12:29:44 <Cale> yeah, I think one of the papers there at least
12:29:47 <Cale> I'm just checking
12:29:49 <jethr0> i'm reading all the arrow papers at the moment, but that takes time...
12:29:51 <xerox> Danke.
12:30:01 <jethr0> haben sie vielen dank, mein herr
12:30:04 <xerox> I never read them, hm.
12:30:15 <jethr0> @babel de en haben sie vielen dank, mein herr
12:30:16 <mbot>  have they thank you, my gentleman
12:30:20 <xerox> Err, my comprehension doesn't go further than 'bitte' :-)
12:30:40 <jethr0> that is the _worst_ translation ever!
12:30:50 <CosmicRay> why are we talking about german translations in haskell? ;-)
12:30:57 <jethr0>  @jethr0-babel de en haben sie vielen dank, mein herr
12:31:19 <jethr0> accept my gratitude, good sir
12:31:28 <jethr0> hehe
12:31:35 <Oejet> Nice.
12:31:44 <xerox> :-!
12:32:32 <fanopnaic> http://www.phpfi.com/90659    can somebody tell me why? :)
12:32:43 <jethr0> 42
12:32:49 <fanopnaic> but of course! :)
12:33:12 <kosmikus> jethr0: are you german?
12:33:19 <jethr0> where would you have ']' in the alphabet?
12:33:24 <jethr0> > ord ']'
12:33:25 <mbot> 93
12:33:31 <jethr0> > ord 'a'
12:33:32 <mbot> 97
12:34:10 <jethr0> > dropWhile (']'<) "aaaab]aaaa"
12:34:11 <mbot> "]aaaa"
12:34:21 <jethr0> > dropWhile (']'/=) "aaaab]aaaa"
12:34:23 <mbot> "]aaaa"
12:34:27 <xerox> > dwim
12:34:28 <mbot>  Not in scope: `dwim'
12:34:30 <jethr0> kosmikus: yep
12:34:41 <jethr0>  > jethr0-dwim
12:34:49 <jethr0> jawohl, mein herr
12:34:49 <fanopnaic> aha!
12:34:58 <fanopnaic> ok, now it makes sense, thanks.
12:35:08 <jethr0> xerox, why is "dwim" not in prelude?
12:35:20 <maitscha> does somebody know how to convert a newtype to a data type?
12:35:20 <jethr0> importing "Things.I.Want.dwim" is kind of a pain
12:35:35 <jethr0> convert?
12:35:53 <SamB> huh, apparantly it really isn't easy to google for 
12:36:09 <xerox> @babel squarese english 
12:36:10 <mbot> module "babel" screwed up: Error: Language squarese not supported
12:36:39 <twb> Aah!
12:36:45 <jethr0> well, this mbot is a really old version!
12:36:48 <twb> Non-UTF-8 funny characters!
12:36:52 <jethr0> maitscha: convert?
12:37:03 <xerox> What character is it?
12:37:12 <twb> \210\200
12:37:22 <Axioplase> @babel japanese english 
12:37:24 <mbot> module "babel" screwed up: Prelude.head: empty list
12:37:25 <jethr0> my guess would be '#88' '#80'
12:37:28 <xerox> maitscha: you can pattern match it and wrap it again.  I think.
12:37:31 <maitscha> I doesn't now what is the difference between newtype and type deklarations and why both are possible.
12:37:35 <twb> Waah!
12:37:55 <xerox> It's more two-letter-words as languages for @babel
12:37:56 <twb> Emacs is convinced those characters aren't in Unicode.
12:37:59 <jethr0> a newtype allows you to give an existing type another name (naively put)
12:38:12 <maitscha> I don't...
12:38:25 <xerox> twb: indeed
12:38:33 <maitscha> jethr0: exactly what a type does
12:38:47 <jethr0> ??
12:39:11 <jethr0> maitscha: a type constrains what values you can pass to a function
12:39:11 <maitscha> a type also gives a type another name
12:39:29 <jethr0> "type Hallo = Int"
12:39:48 <maitscha> yes, but there also exists abstract data types
12:39:55 <jethr0> "newtype Hallo = Hallo Int"
12:40:30 <jethr0> the difference is that you can pass an "Int" wherever a "type Hallo" is expected, but the same is not true for "newtype"
12:40:47 * jethr0 hopes, he's not telling complete nonsense
12:41:03 <maitscha> and what can I pass the newtype Hallo type?
12:41:46 <jethr0> you can pass "Hallo 5" and afterwards everyone can treat this value as an Int
12:41:56 <jethr0> it's really hard to explain with only one line to work in ;-)
12:43:22 <SamB> jethr0: no, you aren't telling nonsense
12:43:36 <SamB> the way you say it may be a bit strange, though
12:43:36 <jethr0> thank god for that
12:43:47 <jethr0> sry, i will stand corrected
12:44:00 <SamB> no, that would be too much work!
12:44:08 <jethr0> hehe, that's the spirit
12:44:27 <jethr0> maitscha, do you have any code you're working on where this applies?
12:44:37 <maitscha> yes.
12:44:43 <jethr0> could you paste it somewhere?
12:45:00 <maitscha> I have only 3 declarations, I will paste it here.
12:45:26 <SamB> note that type constructors defined with "type" are often called type synonyms
12:47:04 <maitscha> type Graph = [(Int,[Int])]        newtype Graph a = TG [(a,[a])]        type Graph a = [(a,[a])] (type synonym)
12:48:36 <jethr0> i'll start my own example:
12:48:42 <jethr0> type HalloT = Int
12:48:52 <jethr0> newtype HalloNT = HalloNT Int
12:49:03 <jethr0> fT :: HalloT -> Bool
12:49:06 <samx_> jethr0, created the ultimate haskell othello yet? :)
12:49:20 <jethr0> fT = even
12:49:28 <jethr0> fNT :: HalloNT -> Bool
12:49:32 <jethr0> fNT = even
12:49:44 * jethr0 hopes this will work, just a sec
12:50:49 <jethr0> samx_, it's not ultimate and my isValid function is way more complicated than yours, but it's ready so far (and very terse)
12:50:53 <jethr0> samx_, http://paste.lisp.org/display/14384
12:52:54 <jethr0> samb, it doesn't like my "fNT = even"... what's wrong with it? "HalloNT not instance of Integral"
12:56:47 <Cale> jethr0: type error
12:56:52 <Cale> @type even
12:56:54 <mbot> forall a. (Integral a) => a -> Bool
12:57:21 <Cale> You pass it a value of type HalloNT
12:57:22 <jethr0> but i thought you could treat HalloNT exactly as Int
12:57:33 <Cale> internally
12:57:38 <jethr0> would "fNT (HalloNT i) = even i" work?
12:57:42 <Cale> yes
12:57:59 <jethr0> sry, my bad
12:58:02 <Cale> or you can do (in GHC at least)  newtype HalloNT = HalloNT Int deriving Integral
12:58:16 <jethr0> no, integral is not derivable, it said
12:58:23 <Cale> -tglasgow-exts
12:58:26 <jethr0> ok
12:58:27 <Cale> -fglasgow-exts
12:58:57 <jethr0> maitscha, sorry for botching up my example... what would you like to do with your code?
12:58:58 <Cale> With glasgow-exts on, any class which the old type has is derivable by the newtype
12:59:00 <maitscha> But what is the difference between "newtype HalloNT = HalloNT Int" and "type HalloT = Int"
12:59:14 <Cale> the latter just gives Int another name
12:59:22 <Cale> the former creates a new type
12:59:31 <jethr0> with "type" "HalloT" and "Int" are interchangable
12:59:40 <Cale> with values of the form  (HalloNT x)
12:59:52 <jethr0> so, fNT has to be
13:00:00 <jethr0> fNT (HalloNT i) = even i
13:00:33 <jethr0> you have to unpack the value, and thus can't interchange "HalloNT 4" with "4"
13:00:39 <jethr0> anymore
13:02:12 <maitscha> hmmm... and when I use abstract types...
13:02:30 <jethr0> samx_, BTW, either i absolutely don't get your "isValid" function or it is plain wrong
13:02:36 <maitscha> like "type HalloNT a = a", will this work?
13:02:58 <samx_> jethr0, i'm reasonably confident, that it's correct
13:03:03 <jethr0> cale, ?
13:03:23 <jethr0> samx_, could you paste your url once more?
13:03:38 <samx_> http://www.pcuf.fi/~sam/Othello.hs
13:04:15 <jethr0> maitscha, i don't think this works, but explaining abstract types goes beyond my haskell skill set
13:05:14 <jethr0> samx_, could you explain the function to me? i just don't get it.
13:05:33 <samx_> jethr0, isValidMove or isValidDir?
13:05:50 <jethr0> isValidDir
13:06:16 <jethr0> well, i think i have it now, except for the "/= Square Nothing" part
13:06:49 <syntaxfree> gah. I graduated.
13:06:55 <Axioplase> hum...might someone help me with some basic IOs ? (getting rand numbers in a list, do some stuff, then print the result out) http://rafb.net/paste/results/pytfxx41.html
13:06:56 <jethr0> congrats
13:06:59 <syntaxfree> hell, I wish I hadn't.
13:07:06 <syntaxfree> I wish I had a couple  more years in there.
13:07:27 <syntaxfree> I'm going to a much lesser school for my master's. It's really an odd feeling.
13:07:43 <boegel|home> syntaxfree: why much lesser ?
13:07:45 <syntaxfree> I have a great sense of loss right now.
13:07:55 <syntaxfree> because that's all I managed to get in.
13:08:23 <syntaxfree> s/get in/get into.
13:08:34 <boegel|home> syntaxfree: where are you from ?
13:08:41 <xerox> Goodnight people.
13:08:41 <syntaxfree> Brazil.
13:08:49 <boegel|home> night xerox !
13:08:52 <boegel|home> hmm, sucks
13:08:53 <samx_> jethr0, the "/= Square Nothing" prevents the case where the matching piece is in the adjacent position to the move.. e.g. "XX" (or ".X" move accurately, as the move has not been done yet)
13:08:54 <wilx> @wiki
13:08:55 <mbot> http://www.haskell.org/hawiki/
13:08:57 <boegel|home> not Brazil :)
13:09:10 <Cale> Axioplase: there's some stuff on the wiki you should read -- let me get some links
13:09:15 <jethr0> ah, ok, maybe i can put that into my code too...
13:09:21 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
13:09:51 <syntaxfree> I could work for a while, and try and get into a better school next year.
13:11:02 <syntaxfree> I really wasn't  mature enough for the grad school admission exam. three or four thousand economists from the whole country attempt to cram themselves into 20 or 40 spots at the top schools.
13:11:14 <syntaxfree> I didn't put effort into it. 
13:11:47 <Axioplase> Cale: thanks.
13:20:19 <SamB> @where omega
13:20:19 <mbot> I know nothing about omega.
13:21:15 <Cale> http://www.cs.pdx.edu/~sheard/Omega/index.html
13:21:17 <kosmikus> @google omega sheard download
13:21:18 <mbot> http://www.cs.pdx.edu/~sheard/Omega/
13:23:01 <SamB> hmm. can we ask staff to disconnect lambdabot?
13:23:30 <SamB> oh, its not even here this time
13:24:02 <boegel|home> SamB: why would you want to disconnect lambdabot ?
13:24:02 <Cale> It died at some point, and was probably disconnected the next ping
13:24:05 * SamB doesn't have xemacs installed so can't run epigram
13:24:33 <boegel|home> @seen dons
13:24:34 <mbot> I saw dons leaving #haskell 1 hour, 34 minutes and 16 seconds ago.
13:24:37 <SamB> boegel: well, last time it was dead it turned out that apparantly what it needed was to be reconnected
13:24:40 <boegel|home> hmm
13:24:51 <boegel|home> I miss her =(
13:24:52 <boegel|home> ;)
13:24:53 <SamB> remember, lambdabot has its own machine now
13:24:57 <SamB> er, her own machine
13:25:03 <Cale> we have mbot for the time being
13:25:15 <Cale> though I should upgrade it to the latest release
13:25:30 <SamB> thats batter than _samb_lambdabot, I'm sure, but it still knows nothing
13:25:31 <boegel|home> SamB: really ? cool :)
13:25:31 <Cale> hmm, are unicode characters allowed in nicknames?
13:25:44 <Cale> apparently not
13:25:46 <Cale> oh well
13:27:38 <Cale> I wish that darcs would mark edit conflicts more descriptively
13:28:19 <Axioplase> Cale: hum... If I understand well, I can do as if IO a was just a until the last function, that will do all the calculus in a Monad. Is that it? Or should anything dealing with IO a be in a do ?
13:29:04 <Cale> a value of type (IO a) is an action which might do some IO before returning a value of type 'a'
13:29:19 <SamB> yes!
13:29:24 <Cale> in a do-block, you can run one of these actions
13:29:25 <SamB> well, maybe.
13:29:31 <Cale> v <- myAction
13:29:43 <Cale> this will run myAction and bind its result to the name 'v'
13:29:54 <Cale> if myAction :: IO a, then v :: a
13:33:23 <Axioplase> Cale: then, "outside", I can just use v like anything? or should it be used as anything, but still inside the do ?
13:33:47 <Cale> you can't get it out of the do
13:33:51 <Axioplase> (I think I'm getting it!)
13:34:03 <Cale> but you can apply pure functions to it
13:34:12 <Cale> inside the do
13:34:17 <Axioplase> Ok, I got it. Now I need to understand how to rewrite parts of my code to do so.
13:38:19 <Buggaboo> hi ski
13:39:11 <schlick> Could anyone give me some pointers to open source software-oriented automatic theorem provers?  So far I've heard of ACL2, MetaPRL, Coq, and Isabelle.
13:41:21 <SyntaxNinja> schlick: there's a conference on such things: http://web.comlab.ox.ac.uk/oucl/conferences/TPHOLs2005/
13:41:27 <SyntaxNinja> in portland, OR next year, I hear.
13:42:39 <Axioplase> schlick: Coq is nice (well, my teachers wrote it, so I do some propaganda...)
13:43:29 <SyntaxNinja> I have a friend whose favorite is Isabelle, and another whose favorite is Coq
13:43:39 <wodka> What is Isabelle?
13:43:42 <wodka> I'm playing with Coq now.
13:45:48 <schlick> Axioplase: Trying to look at my options now.  I'd heard about Coq, and it seems to be the most popular.
13:46:12 <schlick> I won't be able to go to conferences, this is a "hobby" a very strange one.
13:46:38 <SyntaxNinja> schlick: but you might look at the conference papers to get an idea of what's out there and what's active.
13:46:40 <schlick> Isabelle is another theorem prover.  Order of descendance is Otter -> Hol -> Isabelle.
13:46:56 <Taral> I can't find a text-only proof editor for coq other than proof general, and that wants *bleah* emacs.
13:47:02 <Taral> schlick: Ah.
13:48:06 <schlick> Originally I only knew of ACL2 and MetaPRL which have programming support "built in" then someone pointed out Coq, and I found Isabelle on my own.  I'm wondering about others.
13:48:38 <jethr0> @pl \x y -> x:' ':y
13:48:39 <mbot> (. (' ' :)) . (:)
13:49:33 <schlick> mbot: some interesting smilies you got there.
13:49:53 <Taral> heh
13:50:10 <Taral> @pl \a b -> b a
13:50:11 <mbot> flip id
13:50:13 <Taral> hm
13:50:26 <Taral> I'm still trying to derive that algorithm without looking at it.
13:50:36 <Taral> @pl \ x y -> y:' ':x
13:50:37 <mbot> flip (:) . (' ' :)
13:50:46 <Taral> :(
13:51:43 <jethr0> taral, that's much better though
13:52:58 <Taral> heh
13:53:13 <Cale> the lambda term looks like the winner to me
13:53:21 <jethr0> me too
13:53:57 <jethr0> @pl \y x -> x:' ':y
13:53:59 <mbot> flip (:) . (' ' :)
13:55:34 <schlick> So I'm guessing nobody's heard of ones I haven't mentioned (at least no others that have their source available and are used for programming)?
13:55:49 <twb> Hello.
13:56:15 <twb> Somebody told me the other day that the "error" function can be caught.
13:56:24 <twb> But http://www.haskell.org/tutorial/io.html indicates otherwise.
13:56:29 <Axioplase> Can I do a recursive function using 'do' like anyother func (with the "return" in the stop condition) ?
13:56:34 <SamB> twb: its not standard
13:56:39 <twb> SamB: ah.
13:56:44 <SamB> or at least, not Haskell 98
13:57:15 <Axioplase> schlick: what did wikipedia tell you about proof programs ?
13:57:17 <twb> SamB: I'm only doing it in the test functions...
13:57:35 <SamB> twb: I never said it was a bad idea
13:57:40 <twb> SamB: is it possible in ghc and hugs?
13:57:54 <SamB> @doc Control.Exception
13:57:55 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:58:08 <SamB> I certainly hope so!
13:58:49 <twb> SamB: ah, so it is part of the draft standard that will supersede `98 in the future?
13:59:51 <schlick> Axioplase: Wikipedia showed me two big lists of them, depending on how you look it up.  Several of them have no descriptions.  A few have descriptions but it's so math jargon heavy I can't tell if it's relevent to programming or not (generally speaking their websites do not help clarify the matter).  By bouncing around between there and google I managed to come up with the list I mentioned.
14:00:22 <schlick> Further Wikipedia doesn't differentiate between provers that automatically construct proofs and ones that merely confirm proofs.  The former is what you'd need for verifying a program.
14:01:56 <SamB> schlick: to prove anything interesting, I'm pretty sure you have to do fair bit of construction yourself whatever you use
14:02:44 <Axioplase> schlick: if programs could prove others with a single finger snap, that would be heaven. But they do still need a human to tell him how to "tip" the proof so that it eventually resolves.
14:05:09 <schlick> Axioplase: Sort of.
14:05:31 <syntaxfree> whatever maths that aren't relevant to programming right now might come to be relevant.
14:05:51 <syntaxfree> maybe, by learning the mathematics not currently in use in programming, you can add to the existing body of knowledge.
14:06:16 <schlick> Axioplase: I'm new to all this, but basically, assuming the prover has sufficient equivalence statements, and you indicate what it can assume, it should be able to perform the verification completely automatically.
14:06:20 * syntaxfree starts to whistle Iron Maiden's "Alexander the Great" as he continues the "be bold" speech
14:06:27 <schlick> If it doesn't have enough information, yes, you'll have to give it more.
14:07:46 <schlick> However there's a practical difference between something you have to feed all the steps of the proof in, and it just makes sure you have no logical conflicts, and something that looks at its database of rules and determines what set, if any, can prove or disprove your statement.
14:08:18 <SamB> schlick: you haven't read GEB have you?
14:08:27 <schlick> There's also a practical difference between something who's specification language is designed specifically for digital electronics, and one that's designed specifically for software, and one that's designed specifically for typical math. :P
14:08:50 <SamB> true!
14:09:26 <schlick> SamB: I know, after some thinking, it refers to Godel Escher Bach.  I suspect what you're getting at is the halting problem.  Yes I'm aware of the halting problem.  I can show you a nice one line example that causes it to occur, that isn't very contrived (though it took some hunting to find).
14:09:30 <SamB> although C++'s templates are suspicously similar to Haskell on crack
14:09:47 <SamB> schlick: not the halting problem
14:10:07 <SamB> the incompletenes theorem
14:10:57 <schlick> However it doesn't mean much.  Saying the existance of the halting problem means one shouldn't verify anything is like saying "a semi could cross over into my lane and kill me therefore I may as well drive drunk at 120MPH in a car with no breaks, backwards, down country roads.  After all, I could die if I drive safe, anyway, so what's the point? :P
14:11:10 <schlick> The halting problem follows from the incompleteness theorem.
14:11:10 <jethr0> samb, aaahhh, how can you commit the blasphmy of comparing STL to haskell?
14:11:14 <schlick> It's just a practical side effect.
14:11:26 * jethr0 is flabberghasted (and happy to have used that words at last)
14:11:29 <SamB> jethr0: not the library, the template language
14:11:36 <jethr0> well, still
14:11:49 <lisppaste2> twb pasted "catching errors" at http://paste.lisp.org/display/14388
14:11:51 <SamB> schlick: no, the point is that the prover can't just prove anything
14:12:07 <schlick> SamB: Not exactly.
14:12:33 <Axioplase> Cale: I'm sorry to bother you again. Why is there a type error with http://rafb.net/paste/results/O06K4Z21.html ?
14:12:39 <schlick> SamB: The point is at any given point, the database of lemmas will be incomplete for some theorems, resulting in some (exceedingly rare) situations being unprovable.
14:12:56 <Axioplase> Cale: forget it
14:13:01 <schlick> SamB: However, lemmas can be added to solve more problems.  Just that the nature of mathematics means they never can be complete.
14:13:26 <Cale> Axioplase: let m = MyPoint rand1 rand2
14:13:35 <Taral> @hoogle getStdRandom
14:13:36 <mbot> An error occured.
14:13:40 <Taral> !
14:13:42 <SamB> jethr0: note the "on crack"
14:13:46 <Taral> @type getStdRandom
14:13:46 <schlick> It would be better if the halting problem and godel's results had never been publicized I fear.  They're used to excuse the total lack of any static checking, even though such issues almost never come up.
14:13:48 <mbot> Not in scope: `getStdRandom'
14:13:52 <Axioplase> Cale: yep. hence my "forget it" :)
14:13:52 <Taral> @type Random.getStdRandom
14:13:54 <mbot> forall a.
14:13:54 <mbot>         (System.Random.StdGen -> (a, System.Random.StdGen)) -> IO a
14:14:14 <jethr0> samb, well "on speed" is not all bad, so i thought you might mean it in a drug-condoning kinda way
14:14:50 <SamB> schlick: lemmas also have to be proven
14:15:32 <schlick> Some way or another, yes.  Ones from geometry were originally proven by drawing it and seeing what happened.
14:15:51 <SamB> schlick: I never said you can't verify things, just that explaining to the computer how to do it can be tricky
14:15:57 <schlick> Basically math seems to break down to a mix of observation and a lot of mental masturbation. :P
14:17:41 <schlick> SamB: Yes, explaining to the computer how to do it is hard.  Model checking avoids it by brute force, but has the usual issues with brute force.  I'm interested in the different approaches.  I have lots of model checkers to look at.  Not so many theorem provers.
14:18:30 <schlick> Most theorem provers seem to be oriented to traditional mathematics or hardware verification in situations where model checking is infesable.
14:18:58 <somakoma> hi all. whats the best online tutorial to learn haskell for someone like me, who never had to do with functional languages before?
14:19:15 <SamB> what is model checking?
14:19:29 <SamB> somakoma: good question. I'm afraid it is undecidable.
14:19:54 <SamB> somakoma: what have you had to do with before?
14:19:59 <schlick> SamB: Determining all the states that the program can get into, then comparing that list against your specification of what must always be true, or what must never be true, sometimes in context of the state at a particular point in execution.
14:20:00 <somakoma> thought so. asking for the best is difficult. some good tutorials then?
14:20:17 <schlick> SamB: The problem being that the number of states it can get into can be very, very large, for anything remotely realistic.
14:20:17 <twb`> somakoma: Also SICP, even though that's about Scheme.
14:20:25 <somakoma> little c, java, pascal... thats it
14:20:49 <twb`> somakoma: SICP is a good introduction to functional programming in general, although it covers non-functional areas later on.
14:20:52 <Axioplase> Cale: err... Now I can generate one point, how can I generate a list of points? I'm getting a bit lost because of the 'do' for my recursion...
14:20:58 <twb`> somakoma: http://mitpress.mit.edu/sicp/
14:21:00 <o_Rocky> anyone can explain me how to do imports?
14:21:09 <SamB> somakoma: well, you could try the one for C programmers
14:21:18 <Cale> Axioplase: replicateM 
14:21:19 <SamB> @google Haskell for C programmers
14:21:20 <somakoma> tnx, i'll have a look at that
14:21:20 <mbot> http://www.haskell.org/~pairwise/intro/intro.html
14:21:28 <SamB> thats the one
14:21:30 <twb`> o_Rocky: in the file, "import Foo.Bar.Baz"
14:21:39 <SamB> o_Rocky: what sort of imports?
14:21:44 <SamB> what is your problem?
14:21:46 <o_Rocky> twb`: i don't understand
14:22:02 <twb`> o_Rocky: er, what exactly are you trying to do?
14:22:06 <Axioplase> Cale: I have a [IO Mypoint], will it become an [MyPoint] (well, inside the do. I unerstand myself)
14:22:12 <SamB> o_Rocky: what do you want to import?
14:22:17 <o_Rocky> like p.e. i would like to import some file in another directory
14:22:33 <SamB> why?
14:22:46 <SamB> is there any particular reason why it isn't in the same directory?
14:23:04 <o_Rocky> p.e i have a module "a.l" in directory b
14:23:20 <jethr0> axioplase, sequence
14:23:27 <jethr0> @type sequence
14:23:28 <mbot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:23:36 <o_Rocky> SamB: yes, they were not made by me
14:23:50 <SamB> o_Rocky: what are they part of?
14:23:50 <jethr0> meaning "[IO Mypoint] -> IO [Mypoint]"
14:23:57 <Axioplase> jethr0: oh great!
14:24:12 <o_Rocky> they are part of another project
14:24:23 <Cale> no, replicateM
14:24:29 <SamB> o_Rocky: well, are there instructions for installing the library modules?
14:24:30 <jethr0> and inside the IO monad, you can write: "do points <- sequence lalala; ..."
14:24:32 <Axioplase> I know understand lot more things than when I fisrst read about monads.
14:24:40 <o_Rocky> no
14:24:41 <Cale> well, sequence will move between those two types
14:24:48 <Cale> @type replicateM
14:24:49 <mbot> Not in scope: `replicateM'
14:24:56 <Cale> @type Control.Monad.replicateM
14:24:57 <mbot> forall a (m :: * -> *).
14:24:57 <mbot>           (Monad m) =>
14:24:57 <mbot>           Int -> m a -> m [a]
14:24:57 <jethr0> same goes for me... hands-on will always stay the best approach; even for theoretical stuff
14:25:05 <Axioplase> Cale: according to the type, sequence is what I'm looking for.
14:25:11 <SyntaxNinja> yay sequence
14:25:13 <SamB> o_Rocky: well, what project is it?
14:25:13 <Axioplase> Ha. this too seems nice...
14:25:22 <o_Rocky> does that matter?
14:25:31 <jethr0> cale, what do you mean "move between types"
14:25:32 <jethr0> ?
14:25:43 <SamB> o_Rocky: well, maybe I've heard of it and know how to build it ;-)
14:25:54 <o_Rocky> or maybe don't!
14:26:05 <SamB> maybe!
14:26:09 <Cale> jethr0: a -> b, "Move from type a to type b" :)
14:26:12 <SamB> is it a new library?
14:26:19 <o_Rocky> now you gave me an hint...
14:26:32 <jethr0> hehe, but that's how i understodd axioplase's question.
14:26:35 <jethr0> o*
14:27:06 <o_Rocky> you said you migth know how to build it, then it's possible to define directories in the ghci, am i rigth?
14:27:23 <o_Rocky> on the command line
14:27:44 <SamB> o_Rocky: well, it is... but it can be slow.
14:27:48 <SamB> and it is definately annoying
14:28:18 <SamB> you can use -ifoo/bar to tell it to use modules also from ./foo/bar/
14:28:23 <o_Rocky> that's not important
14:29:29 <SamB> I don't mean slow in a bad-performance sense so much as a twiddle-your-thumbs-while-you-wait-for-it-to-load sense
14:29:30 <jethr0> > fmap sum $ replicateM 4 (Just 2)
14:29:33 <mbot> Just 8
14:29:49 <jethr0> (+) i meant
14:30:54 <Axioplase> Cale: what is the Int of replicateM? should I replicateM (length l) l; to get IO[foo] from [IO foo] ?
14:31:20 <SamB> Axioplase: want sequence
14:31:25 <o_Rocky> SamB: thanks for the hint
14:31:25 <SamB> er, you want sequence
14:31:34 <o_Rocky> SamB: it solved the problem
14:31:44 <jethr0> axioplase, if you already have a list [IO Mypoint], sequence is the way to go
14:31:49 <Axioplase> ok.
14:34:46 <Cale> Axioplase: I was thinking you needed a list of n random points
14:34:56 <Cale> you have an IO MyPoint
14:35:21 <Cale> you can replicateM that to get your IO [MyPoint]
14:35:35 <lisppaste2> twb annotated #14388 with "I realize that IO x /= x, but what can I do about it?" at http://paste.lisp.org/display/14388#1
14:36:28 <Axioplase> Cale: I do need a list of n (different) random points
14:36:38 <jethr0> cale, that's damn cool. i have a lot to learn when it comes to "executing" monads ;-)
14:36:43 <SamB> twb`: the main thing you can do about it is bind it
14:37:11 <jethr0> cale, but it works only with randomRIO, doesn't it?
14:37:32 <Cale> Axioplase: then  replicateM n randPoint
14:38:15 <Axioplase> Greaat!
14:38:21 <Cale> btw, why are the field names for your point type prefixed with underscores?
14:38:30 <dcoutts> @hoogle assert
14:38:31 <mbot> An error occured.
14:38:40 <Cale> @hoogle a -> b
14:38:41 <mbot> An error occured.
14:38:44 <Cale> no hoogle
14:38:51 <dcoutts> @index assert
14:38:52 <mbot> Control.Exception, Test.HUnit.Base, Test.HUnit
14:39:20 <Axioplase> Cale: because I once had some fucntions with the same name without the underscore.
14:39:20 <lisppaste2> Taral annotated #14388 with "evaluate" at http://paste.lisp.org/display/14388#2
14:39:29 <dcoutts> @type Control.Exception.assert
14:39:30 <mbot> forall a. Bool -> a -> a
14:40:26 <SamB> who is Taral 
14:40:26 <SamB> ?
14:40:40 <Taral> me
14:41:01 <Axioplase> hum. Where do I get a getTimeOfDay function ?
14:41:14 <dcoutts> @docs System.Time
14:41:15 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
14:41:37 <dcoutts> @type System.Time.getClockTime
14:41:39 <mbot> IO System.Time.ClockTime
14:41:45 <dcoutts> Axioplase, does that help?
14:41:57 <Axioplase> dcoutts: let me check
14:42:24 * SamB needs to get better noticing new (to him) people
14:42:34 <Taral> :)
14:42:37 <Taral> hi!
14:42:45 <SamB> (or something to that effect)
14:42:53 <Taral> *grin*
14:42:54 <Taral> s'ok
14:43:01 <Taral> I'm in here occasionally (like once a week at most)
14:43:04 <Taral> re twb
14:43:07 <SamB> hi!
14:43:10 <Taral> :)
14:43:43 <twb> Sorry, something funny happening to my connection.
14:44:02 <Taral> hm! paste.lisp.org is interesting. :)
14:44:22 <Taral> Sorry if my paste is less useful. How does it generate the --... sections with the compilation output? Or do you have to do that by hand?
14:44:35 <twb> Taral: I've done that by hand.
14:44:47 <twb> lisppaste is not designed for haskell.
14:44:54 <Taral> ok
14:45:03 <SamB> anyone have a clue why it takes so long to compile RankN.hs in Omega 1.11?
14:45:21 <Taral> Anyway, if you want to catch an exception thrown in a pure expression, you have to wrap it with evaluate. :/
14:46:02 <Axioplase> dcoutts: no, it doesn't. I need to bench some stuff, not get the date in fact :) I'd rather get time in miliseconds...
14:46:03 <cinema> dcoutts, ping
14:47:21 <Cale> getClockTime will get the current time in the form  TOD s p  where s and p are Integers giving the number of seconds and additional picoseconds since the Epoch
14:47:49 <Taral> I think Axioplase wants the equivalent of C clock()
14:47:50 <Axioplase> diffClockTime seems something nice
14:48:21 <Cale> except that TimeDiffs are much less convenient than ClockTimes for some things
14:48:28 <Taral> Axioplase: System.Posix.Process.getProcessTimes
14:48:46 <Taral> closer to what you want?
14:50:35 <Axioplase> Taral: if I understand how to do substraction and then print it...
14:51:20 <Taral> um
14:51:22 <Taral> hm
14:51:22 <Cale> Axioplase: do you want nicely formatted times, or raw integers?
14:51:26 <Taral> you need the C constant CLOCKS_PER_SEC
14:51:49 <Cale> are you trying to measure the CPU time used by your program?
14:51:49 <Axioplase> Cale: raw integers. I'm benchmarking.
14:52:06 <Axioplase> getCPUTime seems to be pretty good.
14:52:17 <Cale> I was about to suggest it
14:52:45 <Taral> AHA
14:52:46 <Taral> Axioplase: http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
14:52:50 <Taral> that is what you want
14:52:55 <Cale> yep
14:52:58 <dcoutts> cinema, pong
14:53:03 <Axioplase> Hum. Is there a nice site where I can get modules lists and there functions?
14:53:17 <Taral> ooh, I was just a little late ;)
14:53:44 <cinema> dcoutts, Hi, I have a problem with c2hs parser, when compiling my graphviz code
14:54:07 <dcoutts> cinema, oh yes?
14:54:12 <cinema> dcoutts, I tried to reduce the size of the header, but it is still quite big
14:54:16 <Cale> Axioplase: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:54:36 <cinema> dcoutts, it chokes on a "typedef", I don't understand why
14:54:47 <dcoutts> cinema, even a big test case is ok if it's reporducable
14:55:03 <dcoutts> cinema, what'd be really useful is the pre-processed C source
14:55:12 <cinema> dcoutts, It is reproducible, no problem.
14:55:14 <dcoutts> that way it is platform independant
14:55:23 <twb> Taral: OK, so I can use evaluate to turn a into IO a, but I don't understand how that helps.
14:55:26 <cinema> dcoutts, and I have the preprocessed source
14:55:46 <twb> Taral: AFAICT, quickCheck wants a and I have IO a, so I would have thought I wanted to turn IO a into a.
14:55:50 <dcoutts> cinema, ok, send the test case to the c2hs mailing list
14:56:05 <dcoutts> cinema, do you have the line where it fails?
14:56:10 <cinema> I have modified the parser slightly to add a direct treatment.
14:56:19 <cinema> Yes It is always the same
14:56:33 <SamB> twb: it helps you to catch the exception by throwing it in the IO monad
14:56:35 <dcoutts> cinema, what change did you need to make to the c2hs parser?
14:56:51 <twb> SamB: I still don't get it.
14:57:01 <SamB> maybe that isn't what you need, though
14:57:14 <SamB> twb: perhaps you need unsafePerformIO
14:57:15 <cinema> dcoutts, Just add a main function to execute the parser. I can send you the whole thing if you want, or just the offending file
14:57:27 <SamB> which, as the name implies, is unsafe...
14:57:31 <SamB> let me check something
14:57:56 <twb> All I really want to do is ensure that "f bad_value" throws a particular error.
14:58:10 <cinema> dcoutts, I executed the parser compiled with happy's -d option
14:58:16 <dcoutts> cinema, oh I see
14:58:31 <cinema> dcoutts, but there are an awfull lot of states
14:59:10 <dcoutts> cinema, I think just the preprocessed file is enough. If possible provide a link to it rather than attachine it in the email to the c2hs list.
14:59:12 <cinema> dcoutts, and a very reduced cas works allright
14:59:35 <dcoutts> cinema, what does the offending line look like btw?
14:59:49 <dcoutts> or the offending decl
15:00:06 <cinema> I'll copy&paste in a minute
15:01:04 <Taral> twb: unsafePerformIO is what you want then.
15:01:10 <Taral> let me see...
15:01:13 <cinema> dcoutts,  Ppolyline_t path;
15:01:42 <cinema> dcoutts, but it is not the line in itself, because it works in my small example. It's the contex!
15:02:08 <dcoutts> right
15:02:28 <cinema> dcoutts, Can I e-mail you my 2 files, the small & the large ?
15:02:54 <Taral> twb: unsafePerformIO $ catch (evaluate (f val `seq` False) (\e -> True))
15:02:55 <dcoutts> cinema, I'd prefer it to be sent to the c2hs list so it's in the open
15:03:21 <cinema> dcoutts, if the ml accepts it, I'm OK
15:03:41 <dcoutts> cinema, how big are the attachements?
15:04:18 <cinema> dcoutts, the big file is 79k, but I can 1) truncate the end 2) compress it
15:04:28 <SamB> finally! it now goes into the cc1 phase!
15:04:52 <dcoutts> cinema, oh, that's not so bad. The full Gtk+ headers are 1Mb+
15:05:12 <cinema> dcoutts, well, I'm a midget then
15:05:33 <SamB> cinema: why? how many k are you?
15:06:13 <cinema> SamB, compared to dcoutts'Gtk headers, I feel very small
15:06:31 <SamB> cinema: I bet you are several TB at least
15:06:32 <dcoutts> cinema, and you can see why we had perf problems with the Gtk+ headers :-)
15:06:46 <dcoutts> at least until I rewrote the parser
15:06:46 <SamB> dcoutts: do you use precompiled headers now?
15:06:49 <SamB> oh.
15:07:08 <SamB> for c2hs..
15:07:15 <dcoutts> SamB, actually we still use precompiled headers in Gtk2Hs but it's not a big win anymore and just makes things more complex
15:07:18 <cinema> dcoutts, I began to use c2hs several years ago, and it was very slow even on my small files
15:07:38 <dcoutts> cinema, is it better now?
15:08:13 <cinema> dcoutts, It chokes ultra-quickly
15:08:18 <SamB> dcoutts: what kind of precompiled headers?
15:08:27 <cinema> dcoutts, Just kidding. It is very fast
15:08:31 <SamB> GCC precompiled headers or the other kind?
15:08:32 <dcoutts> cinema, heh heh
15:08:52 <SamB> er, some other kind
15:09:12 <dcoutts> SamB, we serialise the c2hs internal representation of the header (plus various symbol info maps)
15:09:22 <SamB> ah
15:09:33 <dcoutts> nothing to do with gcc
15:09:45 * SamB has to wonder how much time GCC wastes on reading them
15:10:10 <dcoutts> SamB, you don't think gcc saves time by using precompiled headers?
15:10:20 <SamB> it might
15:10:28 <SamB> depending on the amount of headers...
15:10:52 <dcoutts> glibc + X11 + Gtk makes for some rather large headers.
15:10:58 <dcoutts> I expect C++ is even worse
15:11:07 <SamB> yes! probably.
15:11:10 <dcoutts> since people put so much stuff in the headers
15:11:21 <wilx> PCH help a lot during compilation of wxWidgets.
15:11:33 <SamB> I know ReactOS uses precompiled headers, but I suppose windows people are more apt to do that...
15:11:35 <dcoutts> wilx, I can certainly believe that
15:12:11 <dcoutts> I always found VS's precompiled headers system rather annoying
15:12:33 <SamB> I'm sure they are
15:12:41 <cinema> dcoutts, sent the files to the ml
15:12:51 <dcoutts> you had to fit their scheme rather than it just working with however you want to organise the headers
15:12:53 <SamB> but ReactOS, afaik, doesn't build with VS yet anyway
15:13:04 <SamB> dcoutts: yes, just one PCH per project
15:13:09 <dcoutts> and it encourages centeralising lots of header definitions
15:13:14 <SamB> yes yes!
15:13:16 <dcoutts> rather than making minimal imports
15:13:16 <SamB> I know.
15:13:19 <SamB> horrid horrid.
15:13:42 <wilx> Hmm, not true imho.
15:13:49 <dcoutts> it's only sensible for headers of dependent libs that do not change much, eg glibc, X11, etc
15:13:57 <wilx> MSVC supports the same mode as GCC does now.
15:14:07 <SamB> wilx: well the header files it generates certainly imply that
15:14:16 <dcoutts> but for the headers within a libray / app I don't think it's helpful (unless it's totally transparent)
15:14:31 <SamB> well, in 6 anyways
15:14:36 <dcoutts> cinema, ok
15:14:48 <syntaxfree_gradu> anyone knows some site where I can get my typing WPM speed measured?
15:15:20 <SamB> syntaxgraduate: there is a game called typespeed or somesuch
15:16:08 <cinema> dcoutts, Are you going to translate your parser to Frown ? We had a course on attribute grammars at AFP !
15:18:28 <dcoutts> cinema, the performance of the parser is quite important so I think it's best to stick to Happy rather than something more elegant. :-(
15:19:27 <cinema> dcoutts, you're probably right. I hope to understand & practice AG sometimes though
15:19:52 <twb> Taral: did you hear what I just said, or had I already been disconnected?
15:21:38 <dcoutts> cinema, yeah, I'd like to get more practical experience of using AGs
15:24:48 <cinema> dcoutts, the toolchain created by Doaitse & Atzke is beginning to be impressive: Ruler, Shuffle, UUST, UUAG, TOP
15:24:49 <kosmikus> ah, is frown more elegant, but less efficient than happy?
15:25:47 <cinema> we are beginning to have something really interesting in the compiler construction domain
15:26:24 <cinema> kosmikus, Ralf Hinze says performance are comparable
15:26:39 <kosmikus> cinema: atze has had no part in creating uuag, doaitse and atze have not really participated in creating top
15:26:57 <kosmikus> cinema: yes, that's what I thought.
15:27:56 <cinema> kosmikus, yes but the tools are linked somehow, or will be (may be in ehc)
15:28:35 <kosmikus> ehc makes use of all but top, afaik
15:29:09 <kosmikus> but you can use most of them standalone
15:29:25 <kosmikus> ruler and shuffle might be closely tied together, I don't really know
15:29:50 <cinema> kosmikus, if you want to create some kind of DSL, you could use the all 
15:30:39 <cinema> kosmikus, anyhow there is no real real release of top today 
15:30:46 <kosmikus> for a dsl, that seems almost overkill
15:31:19 <kosmikus> cinema: true, I think top is released only as part of helium at the moment
15:32:18 <cinema> I know, except ordinary DSL have to be wrapped in a type-safe thing because the types are usually too weak
15:32:44 <cinema> (I read a paper by Alan Schmitt on that)
15:34:47 <Axioplase> Can I transform a "a" to "IO a" ?
15:35:04 <wilx> return
15:35:06 <liyang> return :: a -> IO a
15:35:15 <Axioplase> that simple :)
15:36:10 <wilx> Is liyang a bot or was it just coincidence? :)
15:36:30 <syntaxfree_gradu> question.
15:36:33 <syntaxfree_gradu> is IO a functor?
15:36:35 <liyang> I'm a bot.
15:37:13 <syntaxfree_gradu> I mean, for an arbitrary type x there's a corresponding type IO x
15:37:24 <integral> IO is a monad,  monads are functors...
15:37:32 <syntaxfree_gradu> monads are functors!
15:37:42 <syntaxfree_gradu> monads are functors! i'm beginning to get it.
15:38:46 <syntaxfree_gradu> @type liftM
15:38:48 <mbot> Not in scope: `liftM'
15:38:55 <syntaxfree_gradu> @type Control.Monad.liftM
15:38:57 <mbot> forall r (m :: * -> *) a1.
15:38:57 <mbot>         (Monad m) =>
15:38:57 <mbot>         (a1 -> r) -> m a1 -> m r
15:39:10 <syntaxfree_gradu> @type Control.Monad.mapM
15:39:11 <mbot> forall b (m :: * -> *) a.
15:39:11 <mbot>         (Monad m) =>
15:39:11 <mbot>         (a -> m b) -> [a] -> m [b]
15:39:18 <syntaxfree_gradu> teee heee
15:40:29 <Taral> um, if I recall correctly, the language accepting nested comments isn't regular, right?
15:41:01 <kosmikus> @type fmap
15:41:03 <mbot> forall (f :: * -> *) b a.
15:41:03 <mbot>    (Functor f) =>
15:41:03 <mbot>    (a -> b) -> f a -> f b
15:41:28 <SamB> Taral: you recall correctly
15:41:29 <kosmikus> Taral: yes
15:41:33 <Taral> damn.
15:41:33 <Taral> :(
15:41:40 <SamB> it is NICE, though
15:41:44 <Taral> heh
15:42:03 <SamB> and regeexes are a pain anyways
15:42:03 <Taral> Coq uses nested comments, which means I can't use a regex to skip to the next statement.
15:42:10 <Taral> Well, I'm trying to write coq.vim
15:42:14 <SamB> oh
15:42:16 <SamB> I see
15:42:25 <Taral> I'll just have to count the damn comments.
15:42:34 <SamB> well, you couldn't do it in Haskell either
15:43:22 <rep> how are you gentlemen
15:44:33 <Axioplase> how do I print to a file ?
15:44:44 <Taral> how do you print to a file in C?
15:45:03 <Cale> hPutStr/hPutStrLn
15:45:03 <araujo> Axioplase, writeFile ?
15:45:52 <syntaxfree_gradu> @type map
15:45:54 <mbot> forall b a. (a -> b) -> [a] -> [b]
15:45:55 <SamB> you need a special printer that can print on files
15:46:07 <SamB> they are so thick and stiff, you know
15:46:53 <earthy> samb: all you really need is one with a straight paper path
15:47:04 <earthy> that will allow slightly oversized stock
15:47:08 <earthy> anyway, bedtime
15:47:11 <syntaxfree_gradu> @let wap _ [] = []; wap f (x:xs) = f x : (wap xs) in wap (*2) [1..10]
15:47:12 <mbot> Unknown command, try @listcommands.
15:47:23 <syntaxfree_gradu> > let wap _ [] = []; wap f (x:xs) = f x : (wap xs) in wap (*2) [1..10]
15:47:24 <Cale> @type openFile
15:47:25 <mbot> Couldn't match `[a]' against `t -> t1'
15:47:26 <mbot> Not in scope: `openFile'
15:47:46 <earthy> or, if you really want to print on files, a pen and neat handwriting. :P
15:47:47 <Cale> @type System.IO.openFile
15:47:49 <mbot> FilePath
15:47:49 <mbot>         -> GHC.IOBase.IOMode
15:47:49 <mbot>         -> IO GHC.IOBase.Handle
15:47:59 <earthy> what Cale said
15:48:05 <syntaxfree_gradu> let wap _ [] = []; wap f (x:xs) = (f x) : (wap xs) in wap (*2) [1..10]
15:48:11 <Cale> @type hPutStrLn
15:48:12 <dons> hmm. looks like all of cse.unsw.edu.au got disconnect last night :/
15:48:13 <mbot> Not in scope: `hPutStrLn'
15:48:17 <Cale> @type System.IO.hPutStrLn
15:48:18 <musasabi> A
15:48:18 <mbot> GHC.IOBase.Handle -> String -> IO ()
15:48:27 <syntaxfree_gradu> > let wap _ [] = []; wap f (x:xs) = (f x) : (wap xs) in wap (*2) [1..10]
15:48:28 <mbot> Couldn't match `[a]' against `t -> t1'
15:48:33 <syntaxfree_gradu> :'(
15:48:44 <lambdabot>   Expecting a function type, but found `[a]'
15:48:46 <lambdabot>   Expected type: [a]
15:48:48 <lambdabot>   Inferred type: [a1] -> [a2]
15:48:58 <syntaxfree_gradu> ahh
15:49:08 <syntaxfree_gradu> > let wap _ [] = []; wap f (x:xs) = (f x) : (wap (f xs)) in wap (*2) [1..10]
15:49:08 <lambdabot>   Expecting a function type, but found `[a]'
15:49:08 <lambdabot>   Expected type: [a]
15:49:08 <lambdabot>   Inferred type: [a1] -> [a2]
15:49:10 <mbot> Couldn't match `[a]' against `t -> t1'
15:49:22 <twb> lambdabot: wb
15:49:22 <syntaxfree_gradu> > let wap _ [] = []; wap f (x:xs) = (f x) : (wap f xs) in wap (*2) [1..10]
15:49:24 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
15:49:25 <mbot> [2,4,6,8,10,12,14,16,18,20]
15:49:26 <syntaxfree_gradu> phew.
15:49:27 <dons> mbot, @quit?
15:49:52 <Cale> hehe, @part would have been better :)
15:50:03 <dons> oops!! :/
15:50:09 <Cale> no problem
15:51:57 <syntaxfree_gradu> how is "wap _ []" different from "wap f []"?
15:52:06 <syntaxfree_gradu> "wap f [] = []"  :~
15:52:17 <Cale> it's not
15:52:22 <twb> syntaxfree_gradu: _ means "ignore this variable"
15:52:25 <dons> you can't refer to the var on the lhs if you call it _
15:52:32 <dons> rhs
15:52:35 <Axioplase> Can I have a 'do' without return ?
15:52:38 <syntaxfree_gradu> I know.
15:52:47 <dons> :) 
15:52:52 <syntaxfree_gradu> that's the Haskell version of "old hackers never die".
15:52:53 <SamB> Axioplase: yes!
15:52:56 <Cale> Axioplase: yes, if the last line returns something, that's what's returned
15:53:26 <SamB> Axioplase: return is but a function
15:53:36 <Cale> do x <- k; return x is the same as do k, which is the same as k
15:53:45 <Cale> @type return
15:53:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
15:54:20 * SamB tries building hmp3 again
15:54:30 <Cale> > return 3 :: [Integer]
15:54:31 <lambdabot> [3]
15:54:37 <Cale> > return 3 :: Maybe Integer
15:54:38 <lambdabot> Just 3
15:54:58 <dons> up to 68 hrs here :) so I think it is stable.
15:55:13 <dons> @seen phys_rules
15:55:13 <lambdabot> I saw phys_rules leaving #haskell-blah and #haskell 2 days, 23 hours, 16
15:55:13 <lambdabot> minutes and 37 seconds ago, and I have missed 2 days, 15 hours, 39
15:55:13 <lambdabot> minutes and 57 seconds since then.
15:56:15 <syntaxfree_gradu> Gah. When I try to measure my typing speed I become so self-conscious I trip and fall.
15:57:19 <SamB> syntaxfree_gradu: play a game!
15:57:29 <syntaxfree_gradu> I am playing such a game.
15:57:38 <syntaxfree_gradu> I am very fast typing impromptu, but bad at copying what the game says.
15:57:44 <Axioplase> Why don't I get any printed output with http://rafb.net/paste/results/53eJny50.html ?
15:57:45 <SamB> preferably one without shoelaces
15:58:05 <Cale> Typing non-meaningful pieces of text is harder
15:58:19 <syntaxfree_gradu> maybe it's because english is my second language.
15:58:29 <SamB> a game that uses unix commands shouldn't be too bad!
15:58:50 <syntaxfree_gradu> @pl rate l = ((length . (filter isUpper)) l) / ((length. (filter isLower)) l)
15:58:51 <lambdabot> rate = ap ((/) . length . filter isUpper) (length . filter isLower)
15:59:07 <syntaxfree_gradu> I still don't understand "ap"
15:59:47 <Cale> > return (+) `ap` [1,2,3] `ap` [4,5,6]
15:59:48 <lambdabot> [5,6,7,6,7,8,7,8,9]
15:59:52 <SamB> hmm, I need to implement Binary.get for Mode...
15:59:55 <Cale> > return (,) `ap` [1,2,3] `ap` [4,5,6]
15:59:56 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:59:56 <syntaxfree_gradu> @type ap
15:59:57 <lambdabot> Not in scope: `ap'
16:00:06 <Cale> @type Control.Monad.ap
16:00:06 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:00:08 <syntaxfree_gradu> @type Control.Monad.ap
16:00:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:00:18 <dons> SamB, yeah, would be a good idea. 
16:00:22 <syntaxfree_gradu> ah, ah.
16:00:23 <dons> an easy!1
16:00:30 * dons hacks it up
16:00:32 <syntaxfree_gradu> like, "ap" applies a functor.
16:00:38 <SamB> dons: no, no, don't!
16:00:40 <SamB> I moved it
16:00:45 <dons> oh, ok ..
16:00:48 <dons> :)
16:00:51 <dons> you want hints?
16:01:05 <syntaxfree_gradu> > ap [] 1
16:01:05 <lambdabot>  add an instance declaration for (Num [a])
16:01:12 <syntaxfree_gradu> > ap [] 'c'
16:01:13 <lambdabot> Couldn't match `[a]' against `Char'
16:01:15 <SamB> I was going to just use fromEnum/toEnum and the Int one 
16:01:29 <syntaxfree_gradu>  > ap [] 1 :: Num [a]
16:01:37 <syntaxfree_gradu> > ap [] 1 :: Num [a]
16:01:37 <lambdabot>   Class `Num' used as a type
16:01:37 <lambdabot>   In the type `Num [a]'
16:01:37 <lambdabot>   In an expression type signature: Num [a]
16:01:39 <dons> ok. that'd do. and tweak writeSt,readSt
16:01:52 <dons> maybe you could pack it into a byte, but it doesn't really matter, I guess
16:02:06 <SamB> yes, I believe I've got all the other parts of this done already
16:02:12 <dons> great!
16:02:24 <dons> test it out and darcs send when you're done
16:02:28 <syntaxfree_gradu> > (ap ((/) . length . filter isUpper) (length . filter isLower)) "This text is low-Uppercase"
16:02:28 <lambdabot>  add an instance declaration for (Fractional Int)
16:03:25 <syntaxfree_gradu> > (ap ((/) . length . filter isUpper) (length . filter isLower)) "This text is low-Uppercase" :: (Fractional Int a)
16:03:26 <lambdabot>   Class `Fractional' used as a type
16:03:26 <lambdabot>   In the type `Fractional Int a'
16:03:26 <lambdabot>   In an expression type signature: Fractional Int a
16:03:44 <syntaxfree_gradu> > (ap ((/) . length . filter isUpper) (length . filter isLower)) "This text is low-Uppercase" :: (Fractional Int a) => [Char]->a
16:03:45 <lambdabot>   Kind error: `Fractional' is applied to too many type arguments
16:03:45 <lambdabot>   In the type `(Fractional Int a) => [Char] -> a'
16:03:45 <lambdabot>   In an expression type signature: (Fractional Int a) => [Char] ->
16:03:45 <lambdabot> a
16:05:26 <syntaxfree_gradu> > (ap ((/) . length . filter isUpper) (length . filter isLower)) "This text is low-Uppercase" :: [Char]->Double
16:05:27 <lambdabot>   Expecting a function type, but found `Int'
16:05:27 <lambdabot>   Expected type: [Char] -> Double
16:05:27 <lambdabot>   Inferred type: Int
16:05:45 <syntaxfree_gradu> > (ap ((/) . fromIntegral . length . filter isUpper) (fromIntegral . length . filter isLower)) "This text is low-Uppercase" ::
16:05:45 <lambdabot>  parse error on input `}'
16:07:55 <syntaxfree_gradu> @hoogle isLower
16:07:56 <lambdabot> Data.Char.isLower :: Char -> Bool
16:07:56 <lambdabot> GHC.Unicode.isLower :: Char -> Bool
16:08:03 <Axioplase> how do I concat Strings ?
16:08:13 <SamB> ++
16:08:26 <SamB> > "Hello, " ++ "World!"
16:08:27 <lambdabot> "Hello, World!"
16:09:25 <Axioplase> hum... a=3 -->  (show a) ++ 4 --> 34 ?
16:09:52 <SamB> > show 3 ++ 4
16:09:53 <lambdabot>  add an instance declaration for (Num [Char])
16:09:58 <SamB> > show 3 ++ "4"
16:10:00 <lambdabot> "34"
16:10:26 <Axioplase> hum.. a is a parameter of my function..
16:10:53 <SamB> that works fine
16:11:08 <Axioplase> and, how fo I add this instance?
16:11:19 <Axioplase> :w
16:11:21 <Axioplase> argh.
16:12:01 <SamB> it works!
16:12:09 <SamB> only it might break your db
16:12:14 <SamB> so watch out!
16:12:44 <dons> s/might/will ;)
16:13:06 <SamB> okay
16:13:16 <SamB> sent
16:13:27 <dons> great.
16:16:01 <Axioplase> What is supposed to be after a where in  "instace foo bar where ..." ?
16:16:23 <dons> looks good SamB
16:16:26 <SamB> type errors are a great way to find where you need to make the next change ;-)
16:16:39 <dons> yep :)
16:17:17 * SamB resumes his omega build
16:17:17 <dons> as long as you use unique types for all the different thingies :)
16:17:48 <SamB> dons: well, usually, you'll be adding or removing things or changing their types...
16:18:25 <dons> so it worked quite well with this  Mode type, I imagine. all the places to edit would have been flagged?
16:18:40 <SamB> yes!
16:18:57 <SamB> especially since most of it was adding to tuples...
16:19:10 <dons> yeah. so probably should have a record type for that 
16:19:28 <dons> less type sigs to edit
16:19:34 <SamB> ah, yes
16:19:48 <Taral> I want vim-hs bindings
16:20:10 <dons> vim-hs?
16:21:07 <dons> hehe hmp3: /import/pill00/1/dons/.hmp3db: hGetChar: end of file
16:21:08 <dons>  ;)
16:21:40 <astrolabe> Axioplase: next come the things that need to be defined for the class.
16:21:55 <Taral> haskell bindings for vim :)
16:21:59 <Taral> write plugins in haskell.
16:22:14 <dons> ah! yes :)
16:22:21 <dons> death to vim script!
16:22:21 <Taral> everything needs haskell plugins
16:22:36 <Taral> actually...
16:22:37 <dons> I 100% agree, Taral :)
16:22:43 <Taral> maybe hsvim is needed -- vim in haskell
16:22:49 <SamB> Taral: this wouldn't be a problem if you used Yim
16:22:52 <Taral> yim?
16:22:55 <dons> but you know of Yi, right?
16:22:57 <dons> @where yi
16:22:58 <Taral> no...
16:22:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
16:23:04 <SamB> Yim is a bad pun
16:23:07 <Taral> eeeeeeeeeeeeeeee
16:23:08 <dons> this is vim in haskell ;)
16:23:22 <Taral> vim in haskell!
16:23:26 <Taral> O.o
16:23:32 <Taral> ha, forget this.
16:23:34 <SamB> yes, its really called Yi...
16:23:34 <Taral> I'll use yi
16:23:46 <SamB> its not that great yet, afiak...
16:23:56 <dons> Taral, be aware that it's not fully done yet. though the vim mode is quite good
16:24:03 <dons> needs syntax hightlighting
16:24:04 <SamB> well, mainly because it lacks a properly working IDE
16:24:18 <dons> oh, and SamB wants hIDE I guess?
16:24:24 <dons> the ncurses yi is pretty nice though
16:24:27 <SamB> that works, yes!
16:24:32 <astrolabe> Axiophase: For example 'instance Eq Char where c==c' = fromEnum c == fromEnum c'   '
16:24:32 <dons> imo :)
16:25:06 <dons> Taral, note the extensive references to haskell plugins ;)
16:25:16 <SamB> Axioplase: but don't try to use that example, of course -- Char already has an instance for Eq
16:26:06 <Taral> dons: Yes.
16:26:26 <Taral> Syntax highlighting isn't important to me.
16:27:10 <Axioplase> SamB: I have [(string,string,string,string)] and I want  to print "s1s2s3s3\n" where sx is a string from the tuple..
16:27:15 <o_Rocky> hi
16:27:15 <ozone> dons: you're such a pimp :)
16:27:27 <dons> :p
16:27:36 <dons> well he wanted vim with haskell plugins, come on!
16:27:43 <o_Rocky> can someone help me with "data" definitions?
16:27:44 <SamB> o_Rocky: hello again
16:27:47 <o_Rocky> data RTree a = Leaf a
16:27:47 <o_Rocky>              | Branch (a,[RTree a])
16:27:54 <o_Rocky> Rose Tree
16:27:54 <SamB> dons: is Taral a he?
16:27:56 <Taral> ozone: Proof is in the pudding. It could be unusable.
16:28:00 <Taral> yes
16:28:03 <Axioplase> damn. have to sleep! it's damn late..
16:28:04 <ozone> true
16:28:06 <Axioplase> see you
16:28:22 <o_Rocky> SamB: i want to turn this defenition into something more generalised
16:28:45 <SamB> o_Rocky: that looks generalized enough to me...
16:28:49 <SamB> be more specific
16:28:56 <dons> ozone, pimping is an important economic activity
16:29:02 <Taral> dons: Don't ship tarballs with autom4te.cache
16:29:09 <o_Rocky> p.e : Functor f => Branch (a, f (RTree a))
16:29:13 <dons> oh, good idea Taral
16:29:23 <dons> must have slipped through the clean up script
16:29:48 <o_Rocky> SamB: do you understand?
16:30:14 <SamB> o_Rocky: yes
16:30:18 <SamB> okay
16:30:35 <Speck> wow thank goodness for joelr, giving me so much to read at the cafe
16:30:41 <dons> Taral, you might want the darcs version, which has about 100 more patches than v0.1
16:31:01 <SamB> try "data Functor f => RTree a f = Leaf a | Branch (a, f (RTree a))"?
16:31:32 <SamB> Taral: edible proofs, you say?
16:31:41 * SamB wants some proof pudding.
16:31:55 * SamB thinks it would be more palatable than the average proof
16:32:21 <o_Rocky> SamB: the functor cant go undefined?
16:32:37 <dons> pudding sounds like a nice name for a theorem prover
16:32:47 <SamB> o_Rocky: well, I imagine it would be unwieldy that way
16:32:52 <o_Rocky> so for the particular case of lists what functor do i put in it?
16:32:59 <SamB> []
16:33:10 <SamB> @info []
16:33:11 <lambdabot> Unknown command, try @listcommands.
16:33:18 <SamB> dons: why no @info?
16:33:31 <dons> too verbose
16:33:37 <SamB> hmm
16:33:59 <dons> it used to be in, but was removed on the request of several people
16:34:00 <SamB> isn't @more enough protection?
16:34:11 <dons> still too verbose
16:34:14 <SamB> oh.
16:34:30 <SamB> @kind []
16:34:31 <lambdabot> * -> *
16:34:51 <dons> in #haskell, lambdabot should really aim to spit out 1 line responses, as a rule
16:35:27 <SamB> > [1..]
16:35:28 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
16:35:28 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
16:35:28 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
16:35:28 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
16:35:28 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
16:35:30 <lambdabot> [24 @more lines]
16:35:36 <dons> btw SamB, I swtiched hmp3 to use only a posix curses subset of ncurses. so complain loudly if the ui does anything weird.
16:35:38 * SamB teases dons
16:35:46 <SamB> dons: it seems okay
16:35:54 <dons> "should really aim" /= "does"
16:35:55 <dons> ;)
16:36:12 <SamB> dons: I know!
16:36:42 <dons> I actually managed to build hmp3 on a mips64/irix box, which is about as exotic a haskell env you can get. so fingers crossed on portability :)
16:36:53 <dons> it'd probably build on cygwin too now.
16:36:57 <SamB> but does it build for PS2?
16:37:05 <dons> netbsd/ps2, yep
16:37:06 <dons> :)
16:37:28 <dons> though this assumes we can port ghc to that thing. (it's a mips, no?)
16:37:29 <SamB> they got netbsd running on the playstation 2?
16:37:33 <dons> sure.
16:37:34 <dons> years ago
16:37:45 <SamB> how did they do that?
16:37:48 <dons> or what about running it on linux on the ipod..!
16:38:15 <dons> sony provides a boot disk hack,iirc
16:38:22 <SamB> yes, the ps2 is apparantly mips. at least, thats what the fool who wanted to port ZSNES to ps2 said.
16:38:26 <dons> here: http://www.netbsd.org/Ports/playstation2/
16:38:34 <SamB> well, yes, for linux...
16:39:27 <SamB> xbox isn't exotic enough to bother with, I'm sure ;-)
16:39:44 <Taral> yay I can finally leave work.
16:40:20 <dons> right, so ps2 is mips little endian.
16:40:22 * jethr0 thinks that zsnes is one of the smarter things to port to the PS2...
16:40:22 <Taral> SamB: I don't remember talking about edible proofs.
16:40:24 <Taral> Editable, maybe.
16:40:40 <jethr0> hmm, edible proofs
16:40:42 <SamB> Taral: you said "the proof is in the pudding"
16:40:51 <SamB> so, I want to eat the pudding!
16:41:09 <Taral> I see.
16:41:12 <Taral> Okay, byebye everyone
16:41:17 <Taral> I'm going home.
16:41:26 <dons> ozone, if they can run linux on the ipod, why can't they put macosx on it?
16:41:30 * dons teases
16:42:37 <SamB> dons, you very well know the iPod doesn't have a 3d accelerator!
16:42:52 * jethr0 wonders whether dons has ever worked on a mac os x machine with too little ram
16:43:11 <dons> thankfully no ;)
16:43:35 <jethr0> and by too little i mean 256mb...
16:43:37 <ozone> dons: i think an aqua interface on the ipod might not work too well :)
16:43:45 <ozone> jethr0: s/256/512/
16:43:53 <SamB> jethr0: well, maybe, but zsnes is still mostly written in ASM
16:44:04 <dons> ozone, but an ncurses one would be just fine :)
16:44:07 <jethr0> i wanted to write that, but feared the backlash from some zealot
16:44:12 <ozone> (speaking as someone who has a powermac g5 with 2GB on his desk...)
16:44:20 <dons> http://ipodlinux.sourceforge.net/index.shtml
16:44:29 <dons> ozone, btw, where does stealth live?
16:44:31 <jethr0> samb, that i didn't know. what i meant was application-wise...
16:44:52 <jethr0> who in his right mind would write an emulator (or however it works) in assembly???
16:44:57 <ozone> dons: CSIRO :}
16:45:02 <dons> (I've been using stealth of late for testing)
16:45:02 <SamB> jethr0: well, okay. so the guy maybe wasn't an idiot. just didn't know.
16:45:09 <dons> oh, should I be using something else?
16:45:12 <SamB> jethr0: it was a while back
16:45:20 <jethr0> but still
16:45:24 <SamB> it would never have been fast enough in C back then
16:45:46 <triplah> was probably a thesis assignment
16:45:47 <triplah> :P
16:46:04 <SamB> ZSNES? thesis?
16:46:04 <dons> seems to me that an emulator is the kind of thing actually doable in asm
16:46:09 <SamB> you must be kidding!
16:46:16 <triplah> ehe :)
16:46:28 <SamB> dons: well, it is really ugly code...
16:46:49 <SamB> they are trying to convert bits to C gradually
16:47:03 <SamB> I hope they get it done in a decade
16:47:09 <jethr0> hmm, the speed relevant parts, yes. but writing an application to accept foreign machine code in assembly seems like chaotic code to me
16:47:15 <jethr0> unless you are _very_ disciplined
16:47:42 <SamB> jethr0: whoever it was wasn't
16:47:48 <jethr0> hehe
16:47:53 <SamB> or at least, the code is a horrible mess
16:47:58 <dons> yeah, maybe C with a bunch of .S files, a la libgmp.
16:48:12 <jethr0> so, you could tell by a quick glance at i386 assembly ;-)
16:48:49 <jethr0> i mean, 10 years back assembly was more of an issue (especially w/o decent graphics adapters)
16:49:42 <jethr0> but for most applications i'd guess 60-80% can be C w/o much of a performance penalty.
16:49:51 <jethr0> but then i have no idea what i'm talking about
16:50:37 <dons> SamB, oh the ipod linux guys actually discuss running mpg321/123 on the ipod :)
16:52:08 <dons> and it uses the framebuffer, so curses would work... 
16:52:14 * dons dreams of haskell on the ipod
16:53:00 <araujo> Hello!
16:53:04 * araujo back from dinner
16:53:06 <Igloo> What are ipods these days?
16:53:09 <araujo> Hi hi dons 
16:53:27 <jethr0> igloo which one?
16:53:29 <dons> looks  like m68ks
16:53:41 <dons> according to the dmesgs
16:53:50 <Igloo> If you can get Linux on it then ghc and hugs both ought to work then  :-)
16:54:07 <dons> oh, with 32M, easily enough to fit in hmp3.
16:54:18 <dons> nhc should run fine.
16:54:29 * araujo using hmp3 on top of hashell
16:54:47 <araujo> Only thing, 'q' is for quit right?
16:54:52 <Igloo> I'm not sure nhc98 ever worked on m68k
16:54:53 <dons> pretty screenshots: http://ipodlinux.sourceforge.net/screens.shtml
16:55:02 <dons> Igloo, really? I'm surprised.
16:55:17 <dons> surely it grew up on m68k suns?
16:55:38 <dons> araujo, yep. 'q' or ^C 
16:55:42 <Igloo> By "ever" I mean in the last few years for me on Linux  :-)
16:55:45 <dons> try 'h' for the full list of bindings
16:55:49 <dons> oh :)
16:56:22 <jethr0> you remember that guy that transmitted data out of (was it an ipod) via the audio jack?
16:56:37 <dons> yeah, the audio jack is some kind of serial port
16:56:40 <jethr0> what did he transmit? was it the flash content?
16:57:00 <araujo> dons, It works, but my console gets messed up :-/
16:57:09 <dons> Igloo, looks like nhc is known to run on pmax,amiga,atari,cobalt,sun3,m68K
16:57:13 <dons> araujo!
16:57:17 <dons> shouldn't happen. what OS
16:57:18 <jethr0> yes, he transmitted via a series of impulses, recorded the audio and recovered the flash content, or something
16:57:24 <araujo> dons, Gentoo 
16:57:28 <dons> hmm.
16:57:33 <dons> just hitting 'q'?
16:57:37 <araujo> dons, yes
16:57:48 <araujo> dons, mm... i am using it from Eterm ....
16:57:49 <dons> which hmp3 version? what patch number?
16:57:52 <dons> ah.. hmm.
16:58:11 <dons> some of these terms (esp. the gtk one, gnome term? are not fun)
16:58:17 <dons> i'll see if i can reproduce it
16:58:19 <araujo> @google hmp3
16:58:20 <lambdabot> http://aep.ucsd.edu/hpp.html
16:58:43 <araujo> dons, ok, let me test something....
16:59:09 <araujo> dons, check, i get this:
16:59:11 <araujo> FastIO.packedHGetLine: unsupported operation (Illegal seek)
16:59:29 <araujo> I might not have your latest release though....
16:59:39 <dons> is it 0.2?
17:00:44 * dons notes that it is 35.3 outside
17:00:57 <araujo> mmm... the --version doesn't work too :-P
17:01:05 <araujo> I think this is even your first release
17:01:27 <araujo> dons, Where can i fetch it? 
17:01:30 <dons> -V ?
17:01:37 <araujo> --version 
17:01:43 <dons> $ hmp3 -V
17:01:44 <dons> hmp3 0.2p13 - curses-based MP3 player
17:02:18 <dons> @where hmp3
17:02:18 <lambdabot> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/hmp3
17:02:42 <jethr0> dons, if that was fahrenheit, we're in the same climate zone ;-)
17:03:32 <dons> hehe. not fahrenheit, no.
17:04:42 <triplah> im wearing jeans :|
17:04:47 <triplah> uni is so cold
17:04:49 <triplah> in the labs
17:04:54 <triplah> i have to ssweat it out for the walk
17:05:06 <triplah> then freeze my tits off when im over there
17:05:14 * jethr0 notes that max temperature today was 5 degrees celcius
17:05:24 <triplah> lucky bastard :(
17:07:10 <araujo> dons, fps != fps-any ?
17:07:29 <dons> no, that's fine. though you should try to use the snapshot version of fps
17:07:31 <dons> @where fps
17:07:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:07:39 <dons> there's a snapshot to download
17:07:58 <triplah> @share fps
17:07:59 <lambdabot> Maybe you meant: state where
17:08:03 <triplah> bah :)
17:08:20 <dons> (it doesn' tsound like your problem though. sounds more like some invalid assumption I make about shutting down, that eterm doesnt' agree with)
17:08:58 <jethr0> @serene
17:08:58 <lambdabot> Lately, I have seen araujo, dons, igloo, jethr0 and triplah.
17:09:34 <SamB> dons: snapshotted after the RULE?
17:09:38 <dons> yep
17:09:41 * Igloo pokes lambdabot with correct capitalisation
17:09:58 <dons> we don't have a patch to un-canonicalise the canonical nicks
17:10:04 <dons> I think..
17:11:16 <Igloo> YM to canonicalise the noncanonical nicks
17:11:40 * jethr0 wonders who decides what canonicalization looks like ;-)
17:11:57 <jethr0> sounds like a song by the red hot chilli peppers
17:12:04 <Igloo> jethr0: In the case of my nick, I do  :-
17:12:41 <jethr0> but "IgLoO" would be _so_ much better
17:12:55 <jethr0> 19L00
17:13:27 * jethr0 shouldn't make fun of this, having "leet"-char in his own nick
17:14:25 <jethr0> @localtime dons
17:14:26 <lambdabot> Local time for dons is Wed Dec  7 12:09:06 2005
17:14:27 <Igloo> Hmm, sadly the OED doesn't want to rule on what "canonicali[sz]ation" looks like
17:14:46 <jethr0> dons, given your timezone and your temperature, i can pretty much pinpoint your location ;-)
17:15:00 <dons> guam?
17:15:02 <araujo> Ok, just compiled the latest darc version dons :
17:15:04 <jethr0> hehe
17:15:04 <araujo> hmp3 0.2p17 - curses-based MP3 player
17:15:17 <SamB> jethr0: try the map
17:15:21 <jethr0> i could just look it up in the map...
17:15:23 <SamB> @map
17:15:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:15:23 <araujo> dons, Though i was confused at first because it says that it is hmp3-0.1 while it is compiling.
17:15:26 <dons> araujo, so with Eterm 0.8.10 it runs fine for me.
17:15:36 <twb> I'm guessing it's in NSW, given he has an account on the UNSW WWW server :-)
17:15:51 <dons> oh.. maybe that's a give-away ;)
17:16:06 * twb is in .melb.vic.au
17:16:09 <dons> araujo, it says hmp3-0.1 while compiling? ah! the .cabal file.
17:16:31 <araujo> dons, yes
17:16:43 <SamB> dons: heh!
17:17:44 <jethr0> twb, if that is an actual domain, australia has done _far_ better than the rest of the world
17:18:09 <dons> hmm?
17:18:29 <araujo> dons, Much better, now it works very good. 
17:18:29 <twb> jethr0: heh
17:18:33 <dons> araujo, now, it works?
17:18:35 <dons> great.
17:18:37 <araujo> dons, i think i was using your first code :-]
17:18:37 <jethr0> well, with the americans using ".gov" all for themselves, and stuff
17:18:41 <twb> jethr0: It's an idiom I stole from the Monastery.
17:19:03 <dons> araujo, good good.
17:19:59 <dons> does Eterm really use less memory than xterm?
17:20:01 <dons> hmm
17:20:16 <twb> xterm is a hog.
17:20:22 <twb> Compare eterm with xvt or rxvt.
17:20:46 <jethr0> xterm is bad, but then it's the most compatible for stuff like mouse support in console vi
17:20:53 <twb> Bleh.
17:21:00 * twb doesn't even *have* a mouse.
17:21:06 <SamB> I know someone with an email address at ssa.gov
17:21:16 <twb> ssa?
17:21:32 <twb> SS Amerika?
17:22:16 <SamB> social security administration
17:22:19 <jethr0> social security america?
17:22:21 <twb> Ah.
17:22:24 <jethr0> ah
17:22:26 <dons> single static assignment . gov, of course
17:22:46 <palomer> anyone have any other GADTs examples?
17:22:51 <dons> static single assignment, maybe..
17:23:11 <jethr0> @dict-all gadt
17:23:11 <lambdabot> Unknown command, try @listcommands.
17:23:37 <SamB> palomer: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/testsuite/tests/ghc-regress/gadt/
17:24:04 <palomer> haskell uses cvs and not darcs?
17:24:20 <twb> No!
17:24:22 <autrijus> the "Intro to Haskell" talk was very well received in osdc.com.au :)
17:24:28 <SamB> palomer: haskell is a language
17:24:33 <Cale> palomer: we're in the middle of a transition to darcs
17:24:38 <SamB> I have no idea what VCS they use for the reports
17:24:44 <Cale> for fptools at least
17:24:45 <palomer> err, ghc
17:24:47 <autrijus> a dozen or so people lined up after the talk to say they've become converts :)
17:24:53 <palomer> Cale: you work on ghc?
17:24:55 <Cale> no
17:25:01 <twb> autrijus: you have the lecture notes somewhere?
17:25:05 <palomer> so why the "we're"?
17:25:06 <dons> autrijus, great.
17:25:07 <autrijus> twb: http://pugscode.org/
17:25:10 <Cale> I mean the grand We, as Haskell users :)
17:25:13 <autrijus> twb: look at the left hand side
17:25:23 <dons> @karma+ autrijus
17:25:24 <lambdabot> autrijus's karma raised to 6.
17:25:45 <Cale> autrijus: how did that lecture go?
17:25:48 <palomer> oh, then you should have said "We're"
17:26:07 <araujo> dons, now something weird happens ....
17:26:20 <twb> autrijus: XUL?  What can I view that in?
17:26:23 <Cale> palomer: capital?
17:26:31 <Cale> twb: Firefox
17:26:32 <araujo> dons, It exits fine, but when i try to immediately run it again, it doesn't work :-/
17:26:32 <palomer> if you're going to use the grand We
17:26:39 <jethr0> autrijus likes the firefox slideshows ;-)
17:26:41 <twb> Bleh.
17:27:13 <Cale> twb: Konqueror user?
17:27:40 <Cale> possibly Safari :)
17:28:12 <autrijus> Cale: very very very well :)
17:28:26 <Cale> autrijus: :)
17:28:31 <palomer> forall a. Eq a => a -> a really means forall a \in Eq. a-> a, right?
17:28:45 <jethr0> ???
17:28:50 <Cale> palomer: sure, if you think of Eq as a set
17:28:51 <jethr0> ;-)
17:29:10 <Cale> If you think of it as a proposition with a free variable, then it reads as written
17:29:30 <palomer> Cale: I'd like to read it in a higher order logic syntax (disregarding programming languages)
17:30:13 <dons> araujo, any error msgs?
17:30:49 <araujo> dons, the terminal just goes black :-/
17:31:03 <dons> hmm. can you hmp3 2> t
17:31:08 <SamB> palomer: it reads as written
17:31:18 <dons> then see if there's any output in 't'?
17:31:19 <araujo> dons, sure
17:31:25 <dons> show me in a priv msg.
17:31:50 <SamB> I mean, you can't do that \in trick with multi-parameter type classes...
17:32:27 <palomer> => is not in the language of higher order logic!
17:32:36 <Cale> palomer: "implies"
17:32:41 <palomer> so what is ->?
17:32:51 <Cale> a type constructor
17:33:09 <Cale> I suppose it depends on your interpretation
17:33:15 <Cale> It could also be implies
17:33:21 <palomer> A -> B <--this, to me, is a function that takes A and returns B
17:33:33 <palomer> logically, I read it as "A implies B"
17:33:45 <Cale> okay
17:33:53 <Cale> You can also read => as implies
17:34:06 * SamB wonders if palomer would like it better in Core?
17:34:09 <Cale> Remember that => is implemented by dictionary passing anyway
17:34:42 <Cale> So it's really like just another precondition
17:35:48 <palomer> but Eq a => b <----this does not read as a function which takes an element of Eq a and returns an element of b
17:35:57 <Cale> It takes a proof of Eq a
17:36:20 <Cale> that is, a dictionary for Eq which applies to a
17:36:43 <palomer> and returns a proof of b?
17:36:51 <Cale> yeah, I suppose
17:37:05 <palomer> so a -> b takes a proof of a and returns a proof of b?
17:37:10 <Cale> yes
17:37:14 <Cale> proofs are values
17:37:27 <dons> araujo, any msgs?
17:37:29 <dons> how you going?
17:37:32 <araujo> dons, no error message, but look
17:37:37 <palomer> but, you see, you don't explicitly pass the proof in Eq a => b
17:38:15 <dons> which version of Eterm are you using?
17:38:23 <Cale> palomer: right
17:38:31 <Cale> palomer: but that's just a language feature
17:38:34 <araujo> dons, Whenever the console goes black, i check with ps , and the hmp3 and mpg321 process are sleeping
17:38:38 <Cale> you still need a proof of a
17:38:49 <Cale> er of Eq a
17:38:52 <Cale> it's got to be in the program 
17:38:55 <Cale> somewhere
17:38:58 <palomer> still, having two operators for implies gives me the heebie jeebies
17:39:04 <Cale> meh
17:39:06 <dons> araujo, and you're exiting with 'q' ?
17:39:13 <Cale> Haskell isn't second order logic
17:39:22 <SamB> palomer: so maybe you would like core better?
17:39:27 <palomer> it would be third order, if anything
17:39:30 <palomer> what's core?
17:39:32 <dons> what color is your terminal? maybe it's just the colors are all black?
17:39:34 <Cale> it's a rough analogy at best
17:39:42 <Cale> with any kind of logic
17:39:56 <SamB> palomer: GHC's favorite IR
17:40:32 <palomer> ah, so there are two kinds of "proofs" in haskell
17:40:44 <araujo> Eterm 0.9.3
17:40:44 <araujo> dons, hmp3 sleeps and mpg123 goes zombie :-P
17:40:50 <araujo> dons, it's like if some parent process unexpectedly died.
17:41:08 <dons> does pkill -KILL hmp3 ; pkill -KILL mpg321 fix things?
17:41:23 <araujo> dons, yes, i can send it the signal kill -9
17:41:45 <araujo> dons, let m,e post you a screenshot
17:42:17 <dons> so, when you quit with 'q' neither process seem to terminate properly? can you give me instructions on how to reproduce this exactly?
17:42:37 <dons> including any changes youu made to the .cabal file(?) and which ghc vresion.
17:43:55 <araujo> dons, yes, run hmp3 , then quit (q) , run again and it happens the problem., ghc-6.4.1
17:46:47 <araujo> dons, http://dev.gentoo.org/~araujo/hmp3error.gif
17:46:55 <dons> hmm, ok, I can't reproduce that. does it start playing music? oh. I wonder if its because you're using mpg123?
17:47:00 <araujo> dons, There you will find a normal console showing ps output
17:47:04 <araujo> And the black console
17:47:07 <dons> can you try mpg321? it generally seems to be more stable..
17:47:14 <araujo> dons, Ok.
17:48:09 <dons> so you'll have  to install mpg321, recompile (making sure that it detect mpg321) and try again. hopefully it's just mpg123 misbehaving.
17:48:23 <araujo> dons, Ok, take a while but here we go
17:48:48 <araujo> dons, It choose mpg321 over mpg123 if available?
17:48:54 <dons> oh, I see you have many instances of hmp3 running. hmm.
17:48:57 <dons> it should do, yes
17:49:13 <dons> AC_CHECK_PROG(MPG321,mpg321,mpg321)
17:49:17 <dons> if test -z "$MPG321" ; then
17:49:17 <dons>     AC_CHECK_PROG(MPG321,mpg123,mpg123)
17:49:21 <araujo> dons, yes, those are the already deads
17:49:41 <araujo> Ok.
18:02:31 * jethr0 is frustrated at his own inability to understand the hugs00 at the first reading
18:02:55 <jethr0> hugs00 paper*
18:03:13 <Cale> That's a tough paper
18:03:52 <jethr0> there's always something else. first you have to get lambda, then HOF, then continuations, then bounded continuations, then monads, then arrows
18:04:05 <jethr0> i really like to learn, but will it ever get easier ;-))
18:04:43 <SamB> jethr0: yes. when you figure out you don't need to learn more *before* writing your program
18:04:51 <jethr0> blowing your mind and changing your perception seems to stay hard all the way...
18:05:50 <SamB> you don't have to be continually blowing your mind...
18:06:10 <jethr0> it's the bane of my existance ^_^
18:08:36 <SamB> ooh, mega finished building
18:10:33 <SamB> what is that cayenne dirivative called?
18:11:33 * jethr0 thinks there should be a "must read" selection of haskell related papers. "haskell.readscheme.org" is just too huge...
18:12:52 <lispy> jethr0: cool!
18:13:02 * lispy posts it to his delicious list
18:13:04 <jethr0> no, not cool, too huge
18:13:16 <jethr0> ;-)
18:14:53 <lispy> hm...last modified october 26th, 2004
18:15:19 <jethr0> oh well, by the time you've read all the basic papers, they'll have updated it
18:15:46 <lispy> most recent addition is january 24, 2003
18:15:47 * jethr0 is annoyed by all the things he _doesn't_ know
18:16:27 <jethr0> well, there's tons of arrows papers and arrows have barely made it into mainstream haskell
18:16:57 <lispy> this guy's name rocks, Bjrn Lisper
18:17:13 <lispy> looks like, "born lisper"
18:17:13 <gzl> more depressing, there are tons of papers on haskell and haskell has barely made it into the programming mainstream :P
18:17:15 <jethr0> especially if you are a haskeller
18:17:27 <jethr0> true
18:18:12 <lispy> gzl: i don't think haskell adoption is really possible.  I think haskell language feature adoption is what we need to hope for
18:18:23 <lispy> for example, more and more languages support lambdas
18:18:31 <jethr0> hmm
18:18:33 <lispy> and monands
18:19:06 <jethr0> in this respect i ain't no optimist
18:19:36 <jethr0> chances are that in 50 years time, 90% of programming will still look like "for (int i = 0; i < 10; i++)"
18:19:51 <dons> oh, no chance
18:19:52 <lispy> i know several grad students who think functional programming is inherently obtuse and reject it on that basis alone.
18:20:00 <dons> what did programming look like 50 years ago..
18:20:30 <jethr0> well, 50 years is exaggerated, but look at how much mainstream/mean programming has changed since the glory days of "C"
18:20:35 <lispy> lisp, fortran, hex and asm?
18:20:39 <gzl> lispy: I know a lot of people like that
18:20:41 <jethr0> we have php, perl, asp, C++, VB, ...
18:20:49 <SamB> jethr0: it will be at least "for i in range(10):"
18:21:12 <lispy> well, MS intentially designs languages which are similar to C in syntax as to not frighten people away
18:21:27 <jethr0> for the last 20 years there have been no major steps towards acceptable (to me) high-level languages
18:21:43 <jethr0> smalltalk would have been great and was not adopted
18:21:47 <gzl> it's hard to tell whether FP doesn't match the way a lot of people think (e.g. abstractly or mathematically) or whether it's simply that they've gotten used to some other language
18:21:48 <palomer> haskell isn't a step in the right direction?
18:21:56 <lispy> i think java was well intended, and a step in the right direction even if i hate java
18:21:58 <jethr0> in the 70s and 80s lisp would have been great and did not succeed
18:22:17 <lispy> palomer: i don't think he means in general, but instead in the mainstream
18:22:24 <jethr0> nono, there have been great advances in academia. but not in the "real world"
18:22:33 <SamB> jethr0: its because they forgot the syntax
18:22:57 <palomer> jethr0: have you ever tried using haskell "in the real world"?
18:22:57 <lispy> but, are languages like haskell easy to pickup and understand?  there are so many weird ways of doing things in haskell that maybe programs are too hard to read?
18:23:02 <jethr0> i _love_ lisp and its syntax...
18:23:15 <palomer> have you ever tried using lisp in the real world?
18:23:22 <SamB> jethr0: but thats just it! they forgot to implement syntax?
18:23:22 <jethr0> palomer, i'm not arguing possibility. i am arguing numbers!
18:23:33 <lispy> palomer: yes
18:23:38 <lispy> palomer: well, sort of yes
18:23:52 <lispy> palomer: it's a nice language, carrying around the compiler is a pain
18:24:12 <jethr0> an incredible amount of legacy code is still cobol... where do you think legacy C++/VB/ASP code will go in 20 years?
18:24:21 <palomer> lispy: yes for which?
18:24:30 <lispy> jethr0: does LtU have a must read haskell section, maybe that would be better than haskell.readscheme.org
18:25:07 <jethr0> samb, lisp macro are gorgeous. they might not be safe, or inherently readable, but you can solve almost everything in 50 lines of macro-laden lisp code!
18:25:09 <lispy> palomer: i mean, using lisp in the real world.  It's a nice language, very easy to debug and on and on. But carrying around the lisp compiler whenever you deploy is a pain
18:25:48 <jethr0> hmm, its a runtime containing the compiler, no? how's that different from carrying java jre/jdk with you?
18:25:48 <lispy> well, i'm off to dinner
18:26:03 <lispy> jethr0: in java you can use just the jre
18:26:18 <lispy> jethr0: with lisp you need the whole thing, at least in my experience you did
18:26:24 <jethr0> if you don't inline compile lisp, the runtime suffices as well (i think)
18:27:15 * fworp knew this conversation seemed familiar
18:27:21 <jethr0> hehe
18:31:01 <jethr0> have any of you worked with exciting "purely functional data structures" like zippers, ...?
18:31:17 <SamB> I played with the demo code
18:31:43 <jethr0> so, was it worth the hype? it sounded like the cure of all problems ;-)
18:32:07 <SamB> it was cool, I guess
18:32:57 <jethr0> did you look at the inner workings. i must admit i didn't get how you can have multiple "iterators" keeping a synchronised data structure in a functional language
18:34:34 <SamB> its transactional...
18:36:04 <jethr0> well, maybe i'll have a look at the presentation or the paper abstract ;-)
18:36:15 <jethr0> gonna read the arrows paper once more...
18:37:48 <twb> Is x $ y equivalent to x (y)?
18:38:05 <fworp> yeah
18:38:57 <twb> Why bother?
18:39:18 <twb> vi doesn't have M-x check-parens and M-( ? ;-)
18:40:24 <fworp> well, its 1 $, rather than a ( and a ). why not bother :P
18:40:52 <twb> Well, it's not obvious to mathematicians :-)
18:41:14 <dons> it's good for lazy control structures:
18:41:15 <dons> mpgLoop = forever $ do
18:41:15 <dons>     mmpg <- findExecutable (MPG321 :: String)
18:41:16 <SamB> please remember: do not name your papers "paper.tex"!
18:41:18 <dons> ...
18:41:34 <fworp> well lots of haskell isnt obvious to the rest of us, so i think its an acceptable compromise :D
18:41:37 <Taral> dons here?
18:41:39 <SamB> it makes it harder to find them when you have a bunch open
18:41:44 <SamB> Taral: yup
18:41:50 <dons> Taral, si.
18:42:20 <Taral> dons: Does yi really require alex and haddock?
18:42:32 <Taral> and happy?
18:42:36 <twb> It's probably just `cos it's new to me, but I have a habit of bitching about inconsequentials :-)
18:42:43 <Taral> I don't see any alex/happy sources other than some unused test sources
18:43:42 <dons> Taral, not haddock. remove the syntax/ stuff if you don't want the dependency
18:44:03 <jethr0> samb, i hate it when in xpdf they all are named thesis.dvi, or such
18:44:03 <dons> you can do this by editing Makefile, and removing the Yi/Syntax arg to ALL_DIRS=
18:44:13 <Taral> ah
18:44:26 <Taral> but there's no makefile in Yi/Syntax
18:44:33 <Taral> so how is that doing anything?
18:44:49 <dons> hehe
18:44:52 <dons> magical gnu make
18:45:02 <fworp> i think its just sometimes more readable/writable. I could live without, but i dont want to
18:45:11 <dons> have you read 'recursive make considered bad' ;)
18:45:20 <Taral> Mmm, possibly.
18:45:22 <dons> s/bad/harmful, of course.
18:45:25 <jethr0> 'considered harmful' you mean
18:45:29 <twb> dons: could be $(MAKE) -C syntax -f ../Makefile
18:45:40 <Taral> I know recursive make sucks because it prevents proper dependency resolution
18:45:53 <Taral> I once wrote a make substitute for exactly that reason
18:46:06 <jethr0> "* make" sucks, no questions asked
18:46:14 <dons> anyway, there's no need for recursive make when using the hierarchical module system
18:46:47 <Taral> I see.
18:46:50 <Taral> I prefer ghc --make
18:46:51 <dons> so, just trust me (unless you read mk/paths.mk) ..
18:46:56 <Taral> I read mk/paths.mk
18:47:15 <dons> GNU make  string hackery, the worlds worst functional language
18:47:25 <Taral> I modified configure.ac to not get upset at missing alex/happy, and Makefile to only compile Yi/Syntax if alex/happy are present
18:48:07 <Taral> !!
18:48:18 <twb> The important question is: When will Yi be able to read mail?
18:48:21 <Taral> It appears to assume that darcs repo data is available.
18:48:31 <dons> yeah :)
18:48:34 <jethr0> hmm, but the world worst _string hackery_ is definitely in the c preprocessor with "##" and "#"
18:48:37 <dons> but you can ignore that. it's pretty harmless.
18:48:43 <Taral> I'm fixing it.
18:48:59 <dons> patches welcome. but you should use the darcs version (if you aren't already..?)
18:49:09 <dons> otherwise patches are too hard to integrate 
18:49:48 <Taral> I'll pull it in a sec.
18:50:19 <twb> jethr0: damn right.  It doesn't even have GENSYM!
18:50:29 <Taral> grr!
18:50:37 <Taral> make distclean runs hsc2hs?!
18:51:11 <dons> make distclean way=fast
18:51:17 <Taral> nope
18:51:19 <Taral> still tries
18:51:24 <Taral> hsc2hs -Imk -Icbits  -DGLASGOW_HASKELL=  Yi/Curses/CWString.hsc
18:51:34 <dons> sorry, make distclean FAST=1
18:51:38 <dons> as the readme says ;)
18:51:40 <Taral> ?
18:51:51 <Taral> distclean should not run hsc2hs
18:51:52 <jethr0> twb, please tell me that was a joke
18:52:13 <twb> jethr0: I got into Lisp when I couldn't write CPP macros that needed GENSYM.
18:52:16 <dons> no, I didn't come up with an obvious fix, hence the FAST=1 version which doesn't check deps
18:53:04 <jethr0> but there are som many other problems before gensyms (like arg evaluation problems), i wonder how you ever got to the point of missing _gensyms_ of all things
18:54:13 <twb> Trying to write domain-specific iterators.
18:54:54 <Taral> dons: distclean did not remove Yi/Curses/CWString_hsc_make.c
18:55:23 <jethr0> hmm, i tried to write iterators for an inheriting data type, failed, asked in the c++.moderated newsgroup and got told that i shouldn't have been mixing STL and inheritance in the first place *pah*
18:55:24 <dons> hmm. works for me.
18:55:34 <Taral> dunno
18:56:10 <Taral> why not use ghc --make?
18:56:36 <dons> too slow. these days I'd use cabal though.
18:56:47 <dons> anyway, the build system works just fine, when you don't complain about it ;)
18:56:47 <Taral> Oh, and CWString_hsc_make.c was only present because I interrupted hsc2hs
18:56:50 <Taral> LOL
18:58:49 <twb> What's this "HSP" thing?
19:00:24 <Taral> dons: ifneq ($(MAKECMDGOALS),distclean)
19:00:30 <twb> It looks like an XML parsing library, but the example has what looks like straight XML in the haskell source.
19:01:17 <jethr0> Haskell Server Pages (HSP) is an extension of vanilla Haskell, targetted at the task of writing dynamic server-side web pages. Features include:    * Embedded XML syntax
19:01:34 <musasabi> which is quite nifty
19:01:34 <araujo> dons, Same problem with mpg321 :-(
19:01:34 <gzl> huh
19:01:35 <jethr0> @google hsp haskell
19:01:35 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
19:01:40 <twb> Ah.
19:01:42 <gzl> crazy
19:01:45 <Taral> wtf? configure is in the repository?!
19:01:57 <twb> jethr0: is it integrated with the rest of haskell, or does it require a special compiler?
19:02:09 <jethr0> i just copy/pasted from that url *g*
19:02:23 <musasabi> twb: if uses a preprocessor, just like drift.
19:02:39 <twb> Ew.
19:02:44 <musasabi> hmm?
19:02:44 <jethr0> it seems to have its own runtime
19:02:46 <twb> preprocessors bad.  embedded / dsls good.
19:03:00 <dons> araujo, hmm. weird. I can't get this to happen on linux or openbsd. is there anything strange about your setup?
19:03:02 <musasabi> well one cannot do some things without a preprocessor.
19:03:14 <twb> Otherwise you end up with four preprocessors.
19:03:16 <musasabi> syntax extensions is one such thing in Haskell
19:03:39 <twb> Yeah, it's kind of annoying.
19:03:50 <twb> You've got an impressive amount of other stuff right, though.
19:04:35 <musasabi> another is automatic class instance derivation (what drift does). One can do it with TH, but then one needs hacks not to link against the template haskell library at runtime.
19:04:50 <jethr0> yup, although syntactic sugar is starting to get a bit too sweet ;-)
19:05:29 <twb> musasabi: is that the "deriving Show" stuff?
19:05:35 <jethr0> could you explain what "automatic class instance derivation" is?
19:05:47 <musasabi> twb: yes, except for classes that the compiler does not know about.
19:05:48 <jethr0> is that like "implements" in java?
19:06:02 <jethr0> ah, ok
19:06:10 <musasabi> jethr0: no, it is deriving a suitable implementation for a typeclass given a datatype.
19:06:56 <twb> The alternative, I suppose, is to require the compilers to support it natively via something like SRFIs.
19:06:59 <jethr0> so, you write a typeclass and derive from it. but where do you put the "standard" code?
19:07:19 <araujo> jethr0, In the class :-P
19:07:58 <jethr0> hmm, so why doesn't allow std haskell deriving from arbitrary typeclasses? anything speaking against that?
19:08:09 <jethr0> std haskell allow*
19:08:36 <SamB> jethr0: it doesn't know *how*
19:08:41 <SamB> thats why
19:08:50 <gzl> wow, this is neat.
19:09:16 <twb> Out of curiosity, what editors are people using?
19:09:30 <twb> (for developing in Haskell, that is.)
19:09:32 <jethr0> vim and emacs
19:10:22 <jethr0> samb, why? can't it just copy paste the functions?
19:10:42 <SamB> jethr0: for that, just say instance Foo Bar
19:11:05 <jethr0> exactly, and what does drift allow you to do?
19:11:41 <jethr0> no, but in instance you have to declare the function yourself, no?
19:11:46 <SamB> write horrible ugly code to print out the instances
19:12:00 <SamB> jethr0: if the class has defaults for everything, no ;-)
19:12:07 <jethr0> ok
19:12:09 <jethr0> thx
19:12:13 <SamB> especially if there aren't any methods in that class ;-)
19:14:16 <musasabi> emacs usually
19:14:53 <twb> Using Dave Love's haskell.el?
19:15:11 <musasabi> On windows there is nifty visual studio integration if you use that platform.
19:16:12 <musasabi> http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
19:21:04 <fworp> i think i recently saw some kind of 'realtime colaborative programming' internet client/server... thing, on some haskell related website, but i have no idea where or what it was called, does anyone here have any idea what im talking about?
19:21:15 <twb> reddit?
19:21:22 * fworp checks
19:21:22 <twb> Or is that a blogging thing?
19:21:37 <twb> I remember it, too, but not the name.
19:21:52 <musasabi> shapr may know that (at least I think he has used some interactive editing things)
19:22:46 <fworp> alright
19:23:24 <twb> What is the "declaration scanning" feature?
19:30:52 <twb> Gah.  There's all this stuff in haskell-mode which is only bound to the mouse buttons or in the menu-bar.
19:41:21 <Cale> can't you bind it yourself?
19:44:35 <twb> Cale: yeah, but I didn't know it was there until just now.
19:45:19 <Cale> Usually I find out about things only if they're in the menu. How do you know that keybindings have been added?
19:45:29 <twb> C-h b
19:45:35 <twb> And C-h m
19:46:55 <twb> ...and going through the source, of course :-)
19:47:06 <Cale> I suppose that works :)
19:47:33 <twb> I want to display the type under the point when I hit space, instead of after .5 seconds.
19:47:41 <Cale> Seems less convenient than the menu.
19:47:51 <twb> Well, F10 sucks ass.
19:47:57 <twb> And I'm on the console.
19:48:10 <Cale> oh
19:48:34 <Cale> okay, on the console I can see that :)
19:52:32 <twb> Aha, haskell-doc-show-type.
20:41:37 <twb`> What function do I use to get 7/3 ==> 2?
20:41:49 <jethr0> > 7 / (fromIntegral 3)
20:41:50 <lambdabot> 2.3333333333333335
20:41:58 <jethr0> > 7 `div` 3
20:41:59 <lambdabot> 2
20:42:10 <twb`> Ah, of course!
20:42:15 <jethr0> what else
20:42:18 <Korollary> @type (/)
20:42:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:42:28 <Korollary> @type floor
20:42:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:43:02 <Korollary> @type div
20:43:02 <lambdabot> forall a. (Integral a) => a -> a -> a
20:43:26 <Korollary> People at haskell-cafe are incredibly kind.
20:43:27 <jethr0> > (floor . (/)) 7 3
20:43:28 <lambdabot>   add an instance declaration for (RealFrac (a -> a), Integral (t -> a1))
20:44:21 <twb`> Hmm.
20:44:32 <twb`> Quickcheck fails with dividing by zero.
20:44:50 <twb`> How can I tell quickcheck not to test zero divisors?
20:45:22 <jethr0> > ((floor .) . (/)) 7 3
20:45:23 <lambdabot> 2
20:46:29 <jethr0> how do you generate test data?
20:46:39 <twb`> prop_eval_quotient d n m s = eval d (n:m:s) ["/"] == (d,div n m:s)
20:46:39 <twb`>     where types = (d::Dict Word [Word], s::Stack Int, n::Int, m::Int)
20:48:25 <jethr0> hmm, it's been a long time since i last used quickcheck...
20:49:43 <lispy> > 100 `div` 0
20:49:44 <lambdabot> divide by zero
20:49:51 <lispy> lambdabot: duh!
20:50:01 <jethr0> ??
20:50:37 <jethr0> you could do your own generator, that doesn't produce 0
20:50:39 <Cale> whoa, sequence.complete.org doesn't resolve from here
20:50:59 <twb`> jethr0: but then I need to make a type that isn't Int, and it would need to work with other functions.
20:51:05 <Korollary> Cale: hmm, it does for me.
20:51:11 <Cale> interesting
20:51:14 <jethr0> hmm, i don't particular fancy that solution either
20:51:35 <jethr0> otherwise you could catch (m==0) in your prop function and return success or something...
20:51:45 <Korollary> Cale: 69.10.152.58
20:51:51 <jethr0> me too
20:51:54 <twb`> That's what I'm doing, but it's a kluge, not correct.
20:52:14 <twb`> Ideally it would still do the eval, but catch the error.
20:52:29 <twb`> But the whole x vs. IO x thing is just too confusing for me atm.
20:52:35 <jethr0> or, you could catch the exception...
20:52:47 <jethr0> don't you want to test the "implementation" of "div by zero"?
20:52:56 <twb`> I do indeed.
20:53:04 <twb`> But I couldn't work out how to do it.
20:53:09 <jethr0> so, what should it return, ideally?
20:53:17 <Cale> Korollary: okay, set my nameserver to 18.18.18.18 and that seems to find it.
20:53:33 <twb`> Well, quickCheck expects it's argument to be a -> Bool.
20:54:09 <jethr0> can't you  say: "prop_ d n m s = | m == 0 = eval ... = result"
20:54:20 <jethr0>                                | otherwise = eval ... = result2"
20:54:24 <twb`> Er, no.
20:54:33 <twb`> When m == 0, it throws an error.
20:54:52 <jethr0> yes, but quickcheck can handle exceptions
20:54:58 <twb`> Oh!
20:54:59 <twb`> How?
20:55:22 <jethr0> i'm pretty sure you can catch "expected" exceptions... but i'm not the quickcheck master in the channel...
20:55:38 <twb`> Nothing about it in http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html
20:55:44 * joelr1 waves
20:55:55 <dons> morning joelr1
20:56:12 <dons> another day, another toatally extreme rts bug eh ;)
20:56:24 <joelr1> i need a state machine monad ... should i implement it on top of State or roll my own?
20:56:26 <jethr0> you could do "catch (eval ... `seq` False) (\x -> True)" or so
20:56:28 <dons> I think you must have some kind of evil soul, that likes to break code
20:56:35 <joelr1> dons: go ahead, laugh!
20:56:41 <twb`> catchJust, you mean.
20:56:46 <dons> oh, I know. here, have some karma:
20:56:50 <dons> @karam+ joelr1
20:56:50 <jethr0> so that if eval succeeds it returns false and otherwise True
20:56:50 <lambdabot> Maybe you meant: karma karma+
20:56:55 <joelr1> dons: nah, i just like to do things the easy way, you know
20:56:57 <jethr0> as i said, i am no quickcheck guru
20:57:00 * joelr1 bows
20:57:00 <dons> @karma+ joelr1
20:57:01 <lambdabot> joelr1's karma raised to 2.
20:57:03 <twb`> I think that's what I was doing before.
20:57:07 <twb`> Lemme try it.
20:57:07 <joelr1> thank you dons 
20:57:23 <joelr1> dons: what do you think re: the state machine?
20:57:25 <jethr0> so? if your eval is "supposed" to throw an exception, testing for it seems ok, right?
20:57:35 <dons> reminds me of knuth's comment about testing, how he'd work himself into some kind of evil state of mind, and try to break TeX
20:57:53 <dons> joelr1, I rolled a state machine on top of let me see...
20:58:35 <dons> ah, import Control.Monad.State
20:58:36 <twb`> jethr0: yes, but I get type unification errors.
20:58:38 <joelr1> dons: i need to write do { 
20:58:41 <joelr1> } like this
20:58:42 <joelr1> snippet Start event = 
20:58:42 <joelr1>     do startScript
20:58:42 <joelr1>        traceat 100
20:58:42 <joelr1>        goToLobby affid
20:58:44 <joelr1>        pickTable Holdem []
20:58:47 <joelr1>        starttimer "takeSeatEx" 60
20:58:50 <jethr0> looking how?
20:58:56 <joelr1> where each action can change the state 
20:59:11 <elux> hi
20:59:12 <joelr1> dons: i mean, it can change it or not change it, depending on what it does
20:59:22 <Korollary> hi elux
20:59:28 <dons> ok, sounds like a state monad problem
20:59:30 <elux> i was just looking at a haskell program and i noticed they had the following imports: import qualified Data.Map as Map hiding (Map) import Data.Map (Map)
20:59:43 <elux> where can i get information on what a qualified import is and what Data.Map is
20:59:53 <dons> elux, that's not my code is it? 
20:59:58 <elux> dont think so
20:59:58 <Korollary> elux: The haskell report explains those.
21:00:06 <joelr1> dons: right... i guess within that action i would need to do get & put to change my state, right?
21:00:06 <dons> anyway, yeah, check the h98 report
21:00:11 <dons> @where h98
21:00:12 <lambdabot> I know nothing about h98.
21:00:21 <dons> @where report
21:00:21 <Korollary> @doc report
21:00:21 <lambdabot> I know nothing about report.
21:00:21 <lambdabot> report not available
21:00:39 <joelr1> dons: or not... actually, so long as i return the new state i should be good, right?
21:00:40 <dons> @where haskell98
21:00:40 <lambdabot> http://haskell.org/onlinereport/
21:00:40 <Korollary> http://haskell.org/definition/
21:01:00 <joelr1> allright, i know how to do it :)
21:01:02 <dons> returning the state is often how you want to do things
21:01:08 <joelr1> as always, the mere fact of asking
21:01:16 <joelr1> paves the way to a solution ;)
21:01:22 <elux> sure would be nice if the online report was searchable
21:01:22 <dons> write some state manipulation combinators, withState, readState and so on
21:01:24 <Korollary> joelr1: have you looked at the nomaware monad tutorial's state section?
21:01:37 <dons> so then you can write: withState $ \st -> do .... return st' 
21:02:19 <Korollary> elux: yes, but syntax is difficult to index. Tutorials also explain them.
21:02:29 <twb`> jethr0: http://twb.ath.cx/~twb/darcs/miscellaneous/cse1303-a2/solution.lhs
21:02:50 <elux> korollary: which tutorial?
21:02:54 <joelr1> dons: i reduced memory consumption about 20 times by 1) moving to unboxed arrays (minor effect), 2) moving to a 1-slot (MVar) mailbox for my logger so that only one thread can log to it at a time and 3) doing #2 for the network client mailbox
21:02:56 <elux> i cant find anything to explain it
21:02:59 <joelr1> Korollary: yes, thanks
21:03:10 <Korollary> elux: almost all of them, starting with the Gentle Introduction at haskell.org
21:03:12 <dons> joelr1, cool!
21:03:24 <dons> did you profile, or guess this optimisation?
21:03:31 <joelr1> dons: but now i need to do the state machine thing
21:03:36 <joelr1> i profiled for all it was worth
21:03:39 <dons> the 1 slot mail box sounds good. that's how I would have done it.
21:03:48 <joelr1> Cale suggested that it could be message build-up in the TChan
21:04:07 <dons> I'd strictify the mailbox as well, to really ensure no thunks are floating around
21:04:21 <joelr1> and bulat on haskell-cafe suggested MVar instead of a TChan. that's when i had the epiphany 
21:04:40 <joelr1> it hit me like a train, i went and maid the changes and presto, i was done
21:04:51 <dons> ah ha. wonderful
21:04:54 <joelr1> but now i need to do the state machine as a monad
21:04:58 <twb`> jethr0: any idea what's wrong?
21:04:59 <joelr1> snippet Start event = 
21:05:00 <joelr1>     do startScript
21:05:00 <joelr1>        traceat 100
21:05:00 <joelr1>        goToLobby affid
21:05:00 <joelr1>        pickTable Holdem []
21:05:02 <joelr1>        starttimer "takeSeatEx" 60
21:05:17 <twb`> jethr0: rather, what to do about it.
21:05:27 <joelr1> dons: how can i make the state machine changes transparent?
21:05:44 <joelr1> dons: you can only change the state with get/put, right?
21:06:00 <joelr1> dons: i would like to keep this nice syntax
21:06:10 <jethr0_> twb`, i'm not sure you want catchJust
21:06:14 <jethr0_> @type Control.Exception.catchJust
21:06:15 <lambdabot> forall a b.
21:06:15 <lambdabot> (GHC.IOBase.Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
21:06:20 <jethr0_> @type Control.Exception.catch
21:06:21 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
21:06:38 <joelr1> dons: there's a catch, see
21:06:47 <dons> joelr1, i'd start with a functoin withState :: (State -> IO State) -> IO ()
21:06:56 <jethr0_> sorry, was disconnected for the last 2 minutes *arg, german telekom*
21:07:09 <dons> withState f = do s <- get ; s' <- f s ; put s'
21:07:12 <joelr1> dons: the program is supposed to loop around in each state until i return stop at which point it should advance to the next line above
21:07:14 <jethr0_> twb`: not sure this is correct, but compiles: "Control.Exception.catch (div 2 0 `seq` return False) (\x -> return True)"
21:07:21 <dons> then write: witheState $ \st -> do my code ;
21:07:48 <joelr1> dons: fair enough. i will need to think about this more
21:07:58 <elux> okay .. all I want to know is what does Map.empty and Map.lookup do?
21:08:10 <dons> @docs Data.Map
21:08:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
21:08:15 <dons> check there ^^ elux
21:08:20 <jethr0_> twb` seems to work perfectly fine
21:08:24 <elux> thanks
21:08:38 <joelr1> dons: thanks!
21:08:48 <jethr0_> @serene
21:08:49 <lambdabot> Lately, I have seen dons, elux, jethr0, jethr0_, korollary and twb`.
21:08:52 <twb`> jethr0_: not in gchi...
21:09:24 <jethr0_> for me it does... " do Control.Exception.catch (div 2 1 `seq` return False) (\x -> return True) >>= putStrLn . show"
21:09:29 <jethr0_> False
21:09:38 <elux> is lambdabot written in haskell?
21:09:39 <jethr0_> > do Control.Exception.catch (div 2 1 `seq` return False) (\x -> return True) >>= putStrLn . show
21:09:40 <lambdabot>  Not in scope: `Control.Exception.catch'
21:09:45 <dons> elux, yep
21:09:49 <elux> cool
21:09:54 <jethr0_> > do Exception.catch (div 2 1 `seq` return False) (\x -> return True) >>= putStrLn . show
21:09:55 <lambdabot>  Not in scope: `Exception.catch'
21:09:59 <jethr0_> *damn*
21:10:05 <twb`> jethr0_: sorry, yours does.
21:10:09 <elux> haskell is a pretty incredible language i must say .. cant believe how easy it is to write a simple lexer/parser/interrupter
21:10:28 <dons> it's almost like it was designed for building languages ;)
21:10:32 <jethr0_> twb` for some reason the "IO Bool" result isn't displayed... maybe a bug or something
21:10:35 <elux> absolutely
21:10:38 <twb`> I'm using catchJust because I only want to catch *my* exception -- I'm not equipped to handle anything else so it should be passed up the stack otherwise.
21:10:40 <elux> i cant think of a better language to build other languages
21:11:03 <jethr0_> dons, is it a feature that "return 5 :: IO Int" isn't echoed?
21:11:05 <jethr0_> > return 5 :: IO Int
21:11:06 <lambdabot> No IO allowed
21:11:08 <twb`> elux: I can.
21:11:11 <jethr0_> in ghci
21:11:15 <elux> twb: .. lol whats that?
21:11:20 <twb`> elux: Common Lisp.
21:11:35 <dons> it's just throw away, jethr0, think of ghci as a do-block
21:11:37 <jethr0_> not _again_, the flamewar
21:11:38 <twb`> The one thing it's good at is writing domain-specific languages.
21:11:45 <dons> so it's like writing: do ... return 5 ... 
21:11:49 <elux> but you can also do that in haskell pretty easily
21:11:53 <jethr0_> hmm, but shouldn't it echo _something_?
21:11:54 <dons> if you want to see it: return 5 >>= print
21:12:03 <elux> is ghci written in haskell?
21:12:07 <dons> yes.
21:12:09 <twb`> elux: of course.
21:12:13 <dons> it's all haskell roundhere
21:12:16 <jethr0_> yes, i understand, but why not print "IO Int" or something
21:12:26 <twb`> If a compiler can't compile itself, it ain't worth much :-)
21:12:42 <jethr0_> twb` as if common lisp could!
21:13:01 <twb`> jethr0_: SBCL can compile *most* of itself...
21:13:11 <Pupeno> Hello.
21:13:12 <twb`> I think GCL can compile itself.
21:13:12 <jethr0_> i'm pretty dubious whether there's a bootstrapped native lisp compiler out there
21:13:28 <lispy> twb`: which makes wonder why it can't do any C translation to get that tohre 10%
21:13:31 <jethr0_> lisp compiler to native machine code
21:13:39 <TheHunter> jethr0, current ghc-cvs echoes the 5. Which is somewhat inconsistent, actually.
21:13:48 <twb`> jethr0_: oh, I think movitz does that.
21:13:48 <jethr0_> hmm, ok
21:14:03 <lispy> sbcl can generate machine code
21:14:16 <lispy> but it still needs the lisp run time to do anything with it
21:14:23 <lispy> can movitz do more than that?
21:14:24 <jethr0_> yes, but movitz is an operating system / runtime
21:14:26 <Pupeno> I am doing this: import Network (PortNumber, Service, UnixSocket), but I get: Daytime.hs:5:28: Module `Network' does not export `Service'. What should I import ? (other than all of Network)
21:14:35 <lispy> jethr0_: ah
21:14:45 <jethr0_> like lisp machine
21:15:50 <twb`> jethr0_: anyhow, I'm not here to talk about Lisp.
21:16:11 <dons> @index Service
21:16:12 <lambdabot> Network
21:16:13 <twb`> jethr0_: yes, your example works, but quickCheck still expects Bool, not IO Bool.
21:16:33 <jethr0_> pupeno, service is a constructor, not a function. i'm struggling myself how to import those!
21:16:46 <Pupeno> jethr0_: oh!
21:16:58 <dons> Pupeno, isn't Service a constructor..
21:17:03 <dons> oh, yeah :S
21:17:06 <jethr0_> as is portnumber
21:17:08 <dons> data PortID =
21:17:08 <dons>       Service String 
21:17:12 <Pupeno> dons: it is.
21:17:34 <Pupeno> jethr0_: but PortNumber is also a type (which is very confusing).
21:17:36 <dons> so you import it: PortId(Service)
21:17:50 <Pupeno> dons: thanks!
21:17:56 <jethr0_> twb` that's kinda a BIG problem
21:18:18 <jethr0_> dons, any idea how to catch an exception without being left with an IO value?
21:18:27 <Taral> twb: I thought I answered the for you?
21:18:27 <twb`> Yeah, I've been asking about it all day, and never getting a straight answer.
21:18:30 <Taral> s/the/that/
21:18:33 <twb`> Nope.
21:18:46 <Taral> unsafePerformIO $ catch (f val `seq` False) (\e -> True)
21:18:55 <Taral> refine that to what you want
21:19:02 <dons> that's the only way.
21:19:10 <dons> since exceptions have to be caught in the io monad
21:19:19 <jethr0_> taral, would you say that's an idiomatic / good solution? (honest question)
21:19:34 <twb`> Where is unsafePerformIO?
21:19:40 <Taral> System.IO.Unsafe
21:19:45 <jethr0_> @type unsafePerformIO
21:19:45 <Cale> wasn't there some specialised version of quickcheck for IO
21:19:46 <lambdabot> Not in scope: `unsafePerformIO'
21:19:47 <Cale> ?
21:19:52 <jethr0_> @type System.IO.Unsafe.unsafePerformIO
21:19:53 <lambdabot> forall a. IO a -> a
21:20:32 <Cale> http://www.cs.chalmers.se/~rjmh/QuickCheck/QuickCheckM.hs
21:20:36 <Cale> what about that?
21:20:46 <Cale> I haven't really looked too closely at it
21:23:43 <jethr0> twb`, if you didn't care about how "eval" handled division by zero, you could always do "if m == 0 then True else ..."
21:23:52 <jethr0> but then, you knew that
21:24:32 <Cale> m /= 0 ==> ...
21:24:54 <jethr0> huh?
21:25:18 <jethr0> monad bool?
21:25:21 <Cale> @type Test.QuickCheck.==>
21:25:22 <lambdabot> parse error on input `Test.QuickCheck.==>'
21:25:25 <Cale> @type Test.QuickCheck.(==>)
21:25:26 <lambdabot> Couldn't find qualified module.
21:25:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
21:25:26 <lambdabot> \\)?
21:25:29 <Cale> @type (Test.QuickCheck.==>)
21:25:30 <lambdabot> forall a.
21:25:30 <lambdabot> (Test.QuickCheck.Testable a) =>
21:25:30 <lambdabot> Bool -> a -> Test.QuickCheck.Property
21:25:47 <jethr0> ah, cool
21:27:08 <TheHunter> i would consider test |(\args -> usafePerformIO $ f args)| a safe usage of unsafePerformIO, it's really just QuickCheck's fault for not supporting IO properly.
21:27:30 <jethr0> true
21:27:49 <jethr0> are the pipe symbols part of the code? ;-)
21:28:02 <Cale> does QuickCheckM help here?
21:28:11 <TheHunter> both questions: no
21:28:24 <Cale> What is QuickCheckM actually for then?
21:28:32 <Cale> other monads?
21:28:40 <Pupeno> Is HUnit the only unit testing framework available ?
21:28:43 <TheHunter> QuickCheckM wants a monad morphism m -> Id
21:28:47 <Pupeno> for Haskell of course.
21:28:50 <Cale> ah
21:29:37 <jethr0> pupeno, quickcheck is different from standard unit testing, but also pretty nice...
21:30:19 <TheHunter> @index @=
21:30:19 <lambdabot> bzzt
21:30:47 <TheHunter> @index @?
21:30:48 <lambdabot> Test.HUnit.Base, Test.HUnit
21:31:11 <Cale> It seems odd that despite the tests occurring in the IO monad that it doesn't have support for testing of IO
21:31:33 <jethr0> kind of ironic even
21:32:11 <jethr0> but "inside" the io monad ">>=" should take care of the problem, won't it?
21:32:46 <jethr0> or do you mean the non-io return type?
21:33:30 <dons> I think  getEnv code should be in unsafePerformIO too
21:33:48 <TheHunter> we are basically all waiting for this: http://www.haskell.org/communities/05-2005/html/report.html#quickcheck
21:33:49 <Cale> I mean that there's no instances of Testable for IO
21:33:52 <dons> and getArgs should be. 
21:33:56 <jethr0> true, but that's the old "getArgs" discussion, isn't it?
21:34:00 <dons> yeah
21:34:10 <dons> had to write such code yesterday, and its annoying
21:34:12 <jethr0> but "getEnv" can actually change!
21:34:13 <Cale> dons: I somehow think that getArgs should remain in IO
21:34:29 <TheHunter> @index withArgs
21:34:29 <lambdabot> System.Environment
21:34:30 <Cale> @index getEnv
21:34:31 <lambdabot> System.Environment, System.Posix.Env, System.Posix
21:34:33 <dons> it's hard to think of a more pure function.. 
21:34:38 <dons> and if Text.Regex is pure..
21:34:49 <Cale> @type System.Environment.getEnv
21:34:50 <lambdabot> String -> IO String
21:34:58 <Cale> dons: it's not pure
21:35:02 <dons> maybe not getEnv, since putEnv can mess with it
21:35:04 <Cale> it varies by execution
21:35:12 <jethr0> dons, EUID can easily change during executin!
21:35:26 <dons> yeah yeah. but you shouldn't write such programs ;(
21:35:31 <TheHunter> thing is, we have a lot of functions like that already.
21:35:44 <Cale> Things which aren't the same on every execution of the program should be in IO.
21:36:09 <TheHunter> isAlpha?
21:36:14 <dons> ok, I give in. that's a reasonable assumption. but then main :: [String ] -> IO () perhaps
21:36:18 <jethr0> hmm, true
21:36:57 <Cale> TheHunter: doesn't unicode have some convention regarding that?
21:37:15 <Cale> dons: perhaps :)
21:37:20 <TheHunter> doesn't it depend on the locale?
21:37:25 <jethr0> what _does_ happen if you use isAlpha and change the locale?? will haskell's computation become undefined??
21:37:31 <Cale> TheHunter: I wouldn't think so
21:37:53 <Cale> well, maybe
21:37:58 <TheHunter> let's check
21:38:16 <TheHunter> @index isAlpha
21:38:16 <lambdabot> Data.Char
21:38:32 <jethr0> ansi c: NOTE The  details  of  what characters belong into which class depend on the current locale
21:38:57 <Cale> Well, what if we always assume that characters are Unicode?
21:39:01 <jethr0> well, maybe not ansi, but linux at least
21:39:07 <Cale> I suppose there's still the ordering problem.
21:39:14 <Cale> But that's already broken
21:39:40 <Cale> The ordering on strings certainly *is* locale-dependent
21:39:57 <jethr0> so, what happens if referential transparency breaks?
21:40:07 <Cale> well, not that much
21:40:28 <jethr0> well, it has a good chance of being undefined, i guess?
21:41:09 <Cale> code and optimisations which rely on that referential transparency breaks
21:41:32 <Cale> With things that don't vary per-execution, one could claim that no harm could come of it
21:41:41 <Cale> but there's still a stylistic issue there
21:42:18 <Cale> do you really want values in the core of the language which seem pure and yet vary on each execution
21:42:37 <Cale> somehow the environment and arguments to the program seem more variable than the locale
21:43:19 * TheHunter doesn't see any difference in variability between environment and locale.
21:43:38 <Cale> well, there's a lot more stuff in the environment than the locale setting
21:44:19 <Cale> and a user is more likely to change *something* in their environment variables, than to change the locale in particular.
21:44:28 <jethr0> in the ghc code it's defined inside unicode!
21:44:43 <Cale> Chars are supposed to be unicode chars
21:44:46 <jethr0> isAlpha that is
21:45:31 <jethr0> and calls a C FFI function
21:45:40 <Cale> somehow I thought that unicode defined those statically
21:45:45 <Cale> yeah, that's likely
21:46:18 <Cale> isAlpha probably returns true for every alphabetic character in every language
21:46:21 <jethr0> thehunter, changing the locale during runtime doesn't seem likely
21:46:44 <jethr0> and will cause problems under all conditions. even if you're sorting an array in "C" and someone alters the locale while your at it...
21:47:08 <TheHunter> yeah, you're right.
21:47:54 <jethr0> cale, yes, but isUpper is called in the same fashion and man isUpper says it varies with locale
21:48:30 <Cale> jethr0: It does? hmm, that's interesting
21:48:56 <jethr0> wait, let me see. Unicode.hs calls iswupper, which is likely a unicode thingey. just a sec
21:49:26 <jethr0> but still depends on current locale!
21:49:44 <Cale> does it?
21:49:47 <Cale> how exactly?
21:49:49 <jethr0> NOTE: This function is not very appropriate for dealing with Unicode characters,
21:49:52 <jethr0> ;-)
21:49:53 <Cale> does it give an example?
21:49:55 <Cale> oh
21:49:59 <Cale> that's bad
21:50:04 <jethr0> The behaviour of iswupper depends on the LC_CTYPE category of the current locale.
21:50:56 <jethr0> A-umlaut will not be an uppercase letter in locale "C"
21:51:32 <Cale> pfft
21:52:05 <jethr0> but it will in a german speaking locale (iso8859-1, latin?)
21:52:06 <Cale> The Report says that Char is unicode
21:52:30 <jethr0> yes, but base/GHC/Unicode.hs call iswupper, iswalpha, ...
21:52:40 <Cale> well, right now :)
21:52:45 <jethr0> ;)
21:53:03 <TheHunter> LC_ALL=C ghci won't even let me type ''.
21:53:45 <Cale> ghc/ghci don't have lexical support for non-ansi characters
21:53:53 <Cale> because of Alex
21:54:01 <jethr0> i think the chars ARE unicode, but that char handling still depends on locale, even with unicode!
21:54:02 <Cale> (the lexer generator)
21:54:15 <Cale> jethr0: that's possible
21:54:24 <jethr0> because weirdo characters like A-umlaut mean different things to different people *g*
21:54:31 <Cale> yeah
21:54:51 <Taral> nah, they just haven't loaded in the unicode tables yet
21:55:00 <Taral> unicode defines things like upper/lower-case
21:55:01 <jethr0> so, changing locale during runtime will not work in haskell as long as char functions are pure ;-(
21:55:25 <TheHunter> Cale, if I start ghci with my usual locale, '' works jsut fine, though.
21:55:45 <Cale> oh, perhaps 0-255 work
21:56:12 <Cale> hmm
21:56:28 <jethr0> thehunter, the problem is changing the locale for the haskell process during runtime.
21:56:34 <jethr0> a rather unlikely, but possible event
21:56:45 <Cale> ah
21:56:48 <Cale> \196
21:57:12 <Lemmih> Hi.
21:57:47 <TheHunter> (LC_ALL=C) Prelude> Data.Char.isUpper '\196'
21:57:47 <TheHunter> True
21:57:54 <Cale> I wish I knew why gucharmap segfaults
21:58:11 <jethr0> what is 196?
21:58:37 <Pupeno> QuickCheck seems interesting. Is it possible to do the testing for integers between a range (without defining my generator) ?
21:58:41 <TheHunter> Prelude> '\196' == ''
21:58:41 <TheHunter> True
21:59:33 <jethr0> thehunter, it said LC_TYPE
21:59:48 <jethr0> LC_CTYPE
22:00:00 <Cale> especially odd, as with unicode in hugs,  generates the same character code
22:00:15 <Cale> though it doesn't work in ghci
22:00:25 <jethr0> LC_CTYPE - Character classification and case conversion.
22:00:27 <jethr0> makes sense
22:00:50 <TheHunter> # LC_ALL=C locale | grep TYPE
22:00:50 <TheHunter> LC_CTYPE="C"
22:01:02 <TheHunter> LC_ALL=C locale | grep TYPE
22:01:02 <TheHunter> LC_CTYPE="C"
22:01:02 <jethr0> ok
22:01:10 <TheHunter> oh, sorry.
22:01:20 * TheHunter turns in.
22:01:35 <Cale> Char> map ($ '') [isUpper, isLower, isAlpha]
22:01:35 <Cale> [False,False,True]
22:02:01 <jethr0> what character is that?
22:02:19 <Cale> katana
22:02:50 <jethr0> which locale?
22:03:01 <Cale> uTF-8
22:03:04 <Cale> UTF-8
22:03:13 <jethr0> i mean LC_CTYPE
22:03:24 <Cale> LC_ALL=en_US.UTF-8
22:05:22 <elux> *** Exception: parser.hs:(65,17)-(71,44): Non-exhaustive patterns in case
22:05:24 <elux> what does this mean?
22:05:27 <elux> im assuming i missed some cases in my function.
22:05:34 <elux> but the (65,17)-(71,44) ??
22:05:39 <jethr0> yup
22:05:59 <dons> line numbers
22:06:00 <jethr0> between (line 67, col 17) and (line 71, col 44). i think
22:06:06 <elux> thanks
22:06:09 <elux> i hope
22:06:12 <jethr0> hehe
22:07:31 <Cale> of course, in ghci, it just gives me a lexical error :)
22:07:46 <elux> i am using ghci
22:08:16 <Cale> elux: different problem :)
22:08:28 <Cale> Prelude Char> map ($ '\20992') [isLower, isUpper, isAlpha]
22:08:28 <Cale> [False,False,True]
22:08:31 <Cale> that works though
22:09:24 <Cale> I wonder how involved an operation fixing GHC's lexer would be
22:13:45 <elux> has anyone ever implemented any genetic algorithms in haskell?
22:14:15 <elux> i was just wondering what the efficiency of the implementations were in comparison to c or another imperative language (not sure if someone has done that tho)
22:14:31 <elux> not sure if lazy evaluation would assist in reducing the over head on a more complex problem
22:14:38 <Cale> One could do that quite elegantly
22:14:59 <Cale> I've never done it myself, but I can think of a rather good way to do it.
22:15:32 <dons> @seen phys_rules
22:15:33 <lambdabot> I saw phys_rules leaving #haskell-blah and #haskell 3 days, 5 hours, 36
22:15:33 <lambdabot> minutes and 56 seconds ago, and I have missed 2 days, 15 hours, 39
22:15:33 <lambdabot> minutes and 57 seconds since then.
22:16:37 <Cale> well, one style of genetic programming anyway
22:17:28 <jethr0> i've tried to look up the code inside libc. but it's just impossible with all those defines...
22:17:53 <jethr0> i finally got to: #define __CTYPE_isupper(D)    (((unsigned int)(D - __CTYPE_alpha_upper_lower)) <= 1), but have no idea what that means ;-((
22:18:10 <Cale> One could create a monad similar to my MonadRandom, but where the state was a particular list of initially supplied random generators. Then, at each point of nondeterminism, it would apply one of these generators and drop it from the list (or move it to the end of the list, for finite genotypes)
22:21:28 <Cale> one could use that to provide an operation which selected a value randomly from a list according to the genotype
22:22:04 <Cale> (well, deterministically, if you know the genotype)
22:22:35 <Cale> I think I'll write that, just for fun :)
22:23:52 <jethr0> isUpper seems to have the same results in "C" and "de_DE"...
22:24:08 <Korollary> I once wrote a genotype to solve quadratic equations heh.
22:24:27 <jethr0> quadratic??
22:25:01 <Korollary> mmm, it was more like x^4 + ... , on second thought
22:27:28 <Cale> quartic
22:27:29 <jethr0> makes more sense ;-)
22:27:51 <Cale> did you beat Newton's method? :)
22:28:21 <jethr0> those are needed for tori/torusses... damn, i would _so_ have like to have fast tori in my raytracer ^_^
22:28:54 <Cale> Isn't Newton's method reasonably fast for that?
22:29:05 <Korollary> Cale: Newton-Raphson?
22:29:20 <Korollary> I think mine was a much slower approach heh
22:29:21 <Cale> yes
22:29:45 <Korollary> It's all about picking the right fitness function.
22:29:45 <jethr0> isn't newton raphson the fixpoint version, where you reapply the function recursively?
22:29:59 <jethr0> well, iteratively
22:30:00 * earthy nods
22:30:03 <Cale> yeah
22:30:17 <Cale> http://mathworld.wolfram.com/NewtonsMethod.html
22:30:19 <jethr0> that's supposed to be fast for quartics? *yipee*
22:30:30 <twb> *yippee
22:30:39 <Korollary> We're so easily amused
22:30:42 <jethr0> hehe
22:30:56 <Korollary> Look! Twin primes! Make a wish!
22:32:15 <Cale> You should also use it for cubics
22:32:27 <Cale> what were you using for solving the quartics before?
22:33:15 <Cale> If you used the quartic formula directly, I'd be quite impressed if you didn't just have total garbage after all the numerical loss of precision.
22:33:43 <Cale> Though there's a particular way to evaluate it where it shouldn't be quite so bad
22:34:53 <jethr0> let sieve (x:xs) = x : sieve [y | y <- xs, y `rem` x /= 0] in take 20 $ filter (\(x,y) -> y == x + 2) $ zip (sieve [2..]) (drop 1 $ sieve [2..])
22:34:56 <jethr0> > let sieve (x:xs) = x : sieve [y | y <- xs, y `rem` x /= 0] in take 20 $ filter (\(x,y) -> y == x + 2) $ zip (sieve [2..]) (drop 1 $ sieve [2..])
22:34:57 <lambdabot> [(3,5),(5,7),(11,13),(17,19),(29,31),(41,43),(59,61),(71,73),(101,103),(
22:34:57 <lambdabot> 107,109),(137,139),(149,151),(179,181),(191,193),(197,199),(227,229),(239,
22:34:57 <lambdabot> 241),(269,271),(281,283),(311,313)]
22:35:00 <jethr0> yipee
22:36:43 <jethr0> > let sieve (x:xs) = x : sieve [y | y <- xs, y `rem` x /= 0] in drop 200 $ filter (\(x,y) -> y == x + 2) $ zip (sieve [2..]) (drop 1 $ sieve [2..])
22:36:46 <lambdabot> [(9677,9679),(9719,9721),(9767,9769),(9857,9859),(9929,9931),(10007,10009)
22:36:46 <lambdabot> ,(10037,10039),(10067,10069),(10091,10093),(10139,10141),(10271,10273),(
22:36:46 <lambdabot> 10301,10303),(10331,10333),(10427,10429),(10457,10459),(10499,10501),(
22:36:46 <lambdabot> 10529,10531),(10709,10711),(10859,10861),(10889,10891),(10937,10939),(
22:36:46 <lambdabot> 11057,11059),(11069,11071),(11117,11119),(11159,11161),(11171,11173),(
22:36:48 <lambdabot> [25 @more lines]
22:37:16 <JohnMeacham> '
22:37:22 <jethr0>  
22:37:59 <jethr0> gotta go to bed.
22:38:03 <jethr0> good nite everyone
22:38:04 <Cale> 'night
22:41:25 <twb> What's the syntax for case clauses?
22:42:02 <Cale> case blah of
22:42:09 <Cale>    pattern -> expr
22:42:11 <dons> > case Just 1 of Nothing -> True ; Just _ -> False
22:42:12 <lambdabot> False
22:42:37 <Cale> you can also include guards
22:43:49 <dons> > case () of {_ | 1 > 2 -> False | otherwise -> True }
22:43:50 <lambdabot> True
22:44:06 <Cale> don't need the braces even
22:44:18 <dons> oh, just out of habit :}
22:44:18 <Cale> > case () of _ | 1 > 2 -> False | otherwise -> True
22:44:20 <lambdabot> True
22:45:30 <twb> Thanks.
22:45:47 <Taral> @localtime Taral
22:45:48 <lambdabot> Local time for Taral is Wed Dec 07 00:45:26 2005
22:46:02 <twb> Can I do guards with a lambda directly?
22:46:17 <twb> like SML's "\0 -> 0 | 
22:46:35 <twb> Er, '\0 -> 0|x -> 2 * x'
22:46:39 <Taral> don't think so
22:46:43 <Taral> use \x -> case x of ...
22:46:54 <Cale> \0 ?
22:46:56 <twb> Mm.
22:47:05 <twb> Cale: a function that takes 0 as an argument.
22:47:26 <Cale> > (\0 -> 5) 0
22:47:26 <Taral> twb: Definitely not. Lambda bindings are irrefutable.
22:47:27 <lambdabot> 5
22:47:33 <Cale> > (\0 -> 5) 7
22:47:34 <lambdabot>  Non-exhaustive patterns in lambda
22:47:41 <Korollary> twb: 0 is not a type, though. Can the function take 1 as well?
22:47:57 <Taral> > (\x -> case x of { 0 -> 0; x -> 2 * x }) 0
22:47:58 <lambdabot> 0
22:47:59 <Taral> > (\x -> case x of { 0 -> 0; x -> 2 * x }) 7
22:48:00 <lambdabot> 14
22:48:00 <dons> @kind 0
22:48:01 <lambdabot> Only unit numeric type pattern is valid
22:48:05 <dons> @kind 1
22:48:06 <lambdabot> *
22:48:08 <dons> oh well.
22:48:09 <Cale> heh
22:48:13 <Taral> @kind 0 :: Integer
22:48:14 <lambdabot> parse error on input `::'
22:48:18 <Taral> @kind (0 :: Integer)
22:48:19 <lambdabot> parse error on input `Integer'
22:48:20 <Taral> heh
22:48:27 <Cale> @type GHC.Base.Unit
22:48:28 <twb> Korollary: no, that would return "unmatched pattern" error.
22:48:28 <lambdabot> GHC.Base.Unit
22:48:38 <dons> @type undefined :: 1
22:48:39 <lambdabot> 1 :: GHC.Base.Unit
22:48:39 <Korollary> twb: ah, I see
22:48:51 <Taral> @type undefined :: 2
22:48:52 <lambdabot> Only unit numeric type pattern is valid
22:48:53 <Korollary> lambdas with guards
22:48:54 <Taral> weird
22:48:58 <dons> next obfucastion contest, I want x :: 1 to be used ..
22:49:06 <Taral> @type ()
22:49:07 <lambdabot> ()
22:49:13 <dons> Taral, type theory guys like using '1' as a type
22:49:14 <Taral> wtf is this Unit thing for?
22:49:23 <Taral> oh
22:49:24 <Cale> it's the unit type
22:49:24 <dons> so somehow it made it into the ghc parser 
22:49:29 <Cale> it's isomorphic to ()
22:49:32 <Taral> crazy
22:49:53 <dons> just notation.
22:49:53 <Taral> @type undefined :: ()
22:49:54 <lambdabot> () :: ()
22:50:02 <Cale> actually kind of silly that it's there, but no other numeric types are
22:50:03 <twb> () is used a lot more in SML.
22:50:14 <Cale> twb: really?
22:50:22 <dons> no one actually writes :: 1 for real, I think.
22:50:26 <Taral> anyway, twb, Haskell does not allow value bindings in a lambda context.
22:50:27 <twb> Instead of "f = f" you have to say "f () = f ()"
22:50:27 <Korollary> well, in a sense it's used a lot in ocaml, too.
22:50:28 <dons> I only stumbled across it one day
22:50:41 <Taral> () is used to delay evaluation in ML
22:51:00 <Cale> ah, right
22:51:00 <Taral> we might write f = ... and not worry, they'd write f () = ... and force eval when they want it.
22:51:11 <Taral> heh, "we"
22:51:17 <Taral> omg, I have to sleep.
22:51:18 <dons> ah ha! you're converted now ;)
22:51:23 <Taral> I have a meeting in just over 8 hours.
22:51:29 <Korollary> it's a Freudian slip
22:51:39 <twb> If I say "length lst > 2", will it traverse the whole list?
22:51:49 <dons> night Taral, thanks for the code hackery
22:52:04 <Taral> np dons
22:52:07 <Taral> tell me how it goes
22:52:11 <dons> hope it lands in my inbox soon..
22:52:11 <Cale> twb: yes
22:52:18 <Taral> hehehe
22:52:25 <Taral> downside of using reified numbers :)
22:52:49 * twb is afraid to ask
22:53:04 <Taral> dons: You did get the others, right?
22:53:11 <Cale> twb: if Naturals were represented by an algebraic datatype, you could have that work
22:53:22 <Cale> > length [1..] > 2
22:53:26 <Taral> O.o
22:53:28 <lambdabot> Terminated
22:53:35 <dons> Taral, I got the first one
22:53:38 <dons> not the second
22:53:40 <Taral> dons: It bounced it!
22:53:48 <Cale> data Nat = Zero | Succ Nat
22:53:57 <twb> Ah.
22:54:02 <dons> and not the 3rd yet either
22:54:19 <Taral> there you go
22:54:20 <Cale> length' [] = Zero; length' (x:xs) = Succ (length' xs)
22:54:23 <Taral> I used mutt to resend it
22:54:29 <twb> In quickcheck, is there a way to combine multiple ==> phrases?
22:54:35 <Taral> I guess darcs doesn't put a proper envelope addr on the message
22:54:43 <dons> cool, got it.
22:54:55 <Taral> :)
22:55:00 <dons> @karma+ Taral
22:55:00 <lambdabot> Taral's karma raised to 1.
22:55:09 <Taral> yay!
22:55:23 <Taral> @karma taral
22:55:23 <lambdabot> taral has a karma of 0
22:55:28 <Cale> it's kind of neat that data Nat = Zero | Succ Nat has one more element in it than the usual naturals.
22:55:29 <twb> Bad.
22:55:35 <Cale> well, actually lots more
22:55:39 <Taral> Cale: It does?
22:55:41 <dons> really, you should get about 3 karams for rewriting the yi build system ;)
22:55:43 <Cale> but one more completely defined element
22:55:55 <Cale> x = Succ x
22:56:04 <dons> Taral, ok, the lambdabot code is at....
22:56:07 <dons> @version
22:56:07 <Taral> HA
22:56:08 <lambdabot> lambdabot 3p219, GHC 6.5.20050806 (Linux i686)
22:56:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:56:10 <dons> ^^ ;)
22:56:14 <Taral> GOING TO BED NOW
22:56:16 <Taral> :P
22:56:18 <dons> doh
22:56:19 <twb> Night.
22:56:35 <dons> hehe
22:57:22 <dons> cool, he asked about an editor in haskell, in 4 hrs later rewrote the build system to yi :)
22:57:39 <Cale> :)
22:57:46 <dons> good good. our little community grows
22:58:10 <Cale> Does yi have a todo list?
23:00:03 <dons> yep
23:00:24 <dons> $ wc -l TODO 
23:00:25 <dons>      119 TODO
23:00:31 <dons> and what a list!
23:00:44 <Cale> I'll take a look at it in a little bit :)
23:01:37 <dons> so I've got some ideas now from hmp3 and Lemmih to push forward the ncurses syntax hl. and some time free over xmas. so maybe then
23:03:05 <Cale> How has hIDE been progressing? I should do a pull on those repositories and see
23:05:03 <dons> i think we've had a lazy month over nov.
23:09:59 <lispy> where would i start if i wanted to create haskell bindings for an api that is in C (for which I don't have the source code)
23:10:32 <Cale> Read the Haskell FFI report
23:10:40 <Cale> and then maybe look at a tool like c2hs
23:10:53 <Cale> or decide if you'd rather just write it directly
23:11:04 <lispy> what do you mean write it directly?
23:11:16 <lispy> when you say ffi report you mean in the haskell98 report?
23:11:38 <Cale> FFI is in an addendum to the H98 report
23:11:45 <lispy> okay, i found that link
23:11:51 * lispy starts reading
23:12:12 <lispy> and when you say directly, do you mean rewrite the C code in haskell+
23:12:56 <Cale> I mean write the foreign imports and marshalling directly or get a tool to help with it
23:13:09 <lispy> ah
23:13:29 <lispy> i'm trying to figure out how hard it would be to create a direct win32 api
23:13:37 <lispy> (or osx for that matter)
23:14:14 <lispy> i'm curious because the new job i'm starting is open to language preference.  I want to see how hard I would be able to take that openness
23:14:24 * Lemmih gently pokes hIDE.
23:15:09 <lispy> Lemmih: was that directed at me?
23:15:47 <Korollary> probably not
23:15:48 <Lemmih> Nope.
23:15:58 <lispy> okay, because it's semi related :)
23:16:13 <lispy> there is a discussion on the wiki of which gui library they chose and so on
23:16:14 <Korollary> lispy: where did you find that job where people don't care about maintaining your code after you leave?
23:16:30 <lispy> Korollary: yeah, i'm wondering about that too
23:17:00 <lispy> Korollary: but they do currently use python, some-form-of sql, Java, .Net, C++
23:17:02 <Saulzar> He can directly contribute to the number of haskell jobs available after he leaves :)
23:17:09 <lispy> oh and VB/VBA
23:17:09 <Korollary> Man, I could extort money from employers if they only had my haskell app, heh.
23:17:25 <Cale> hehe
23:17:31 <Korollary> "Let me see if I want to fix that bug. Yeeess. It will be $$$$$."
23:17:51 <lispy> "Oh, that bug!  Yeah, that one is really expensive...'
23:18:01 <Saulzar> Hmm, Yampa/AFRP looks slightly complicated, I wonder if it would be a stupid idea to go for a vast simplification...
23:18:54 <lispy> the UI mockup for hIDE isn't really to my licking
23:19:00 <lispy> er liking
23:19:37 <Korollary> lispy: do you really love the project at work?
23:19:44 <lispy> not sure what good that tree menu is on the side of the screen
23:19:54 <lispy> Korollary: i haven't started yet
23:20:02 <lispy> ask me again in a month :)
23:20:08 <Korollary> lispy: but, is it looking interesting?
23:20:23 <lispy> oh, um...i think so.  In general the work they do sounds interesting
23:20:54 <lispy> why do you ask?
23:20:58 <Cale> the really cool screenshot is where it highlights your type errors as you type them
23:21:26 <lispy> heh, that would be interesting.  Or it tries to use the type system to educate the autocomplete
23:21:53 <lispy> "User probably means this because those other ones would give type errors"
23:21:53 <Cale> yes
23:22:35 <Korollary> lispy: truth be told, something like Windows Forms or Swing would look more profitable on your resume. You may wanna save haskell for a personal project.
23:23:17 <lispy> Korollary: very true
23:23:43 <palomer> who the hell would put haskell on their resume?
23:23:50 <palomer> it's like telling your date that you love star trek
23:23:52 <lispy> i've always dreaded being in an interview and having the interviewer say, "You don't know perl!?!?"
23:23:56 <palomer> or telling your mom that you're gay
23:24:02 <Korollary> palomer: I did. Actually, it's not negative at all.
23:24:22 <palomer> Korollary: you told you're mom that you're gay?
23:24:48 <Korollary> palomer: most people don't know, which makes no difference. The ones who know may or may not care. As long as what they're looking for is on your resume, it's harmless.
23:25:19 <palomer> I would never hire a haskell programmer!
23:25:29 <Korollary> I would love to hire haskell programmers.
23:25:29 <lispy> never?
23:25:35 <palomer> unless he knew VB
23:25:39 <palomer> VB6 that is
23:25:46 <Korollary> They make very good C++/Java, etc. programmers.
23:26:13 <Cale> Most Haskell programmers can pick up languages in a week
23:26:38 <Saulzar> Most haskell programmers probably know enough random languages that the others are quite similar...
23:26:48 <Cale> (at least, of the sort that the industry use)
23:26:55 <Cale> Saulzar: exactly
23:27:15 <lispy> but, picking up a languaging and being effective with a language are quite different
23:27:32 <lispy> C++ is easy to "pickup" but it's hard to be good at
23:28:17 <dons> a good haskell programmer would be an asset, regardless of what language they actually have to code in. think about the clean code, the good abstractions, the safety!
23:28:20 <Korollary> lispy: it depends on what you call a good C++ programmer. If it requires knowing design patterns and boost inside out, of course not.
23:28:38 <Cale> well, if you know C or something like it, and a proper OO language, I think you'll be okay for the most part.
23:28:48 <palomer> well, at least you know he wouldn't steal your wife
23:29:21 * lispy is still struggling to know any design patterns
23:29:22 <Saulzar> Hmmm, there are lot of programmers which know C/Java, they make awful C++ programmers 
23:29:36 <lispy> i got the book last christmas, but have yet to find time to give it a real real
23:29:39 <lispy> er real read
23:29:41 <Cale> Saulzar: and Haskell?
23:29:46 <Korollary> Most C++ programmers are C programmers with syntactic sugar.
23:29:48 <Saulzar> Probably :)
23:30:03 <dons> just having people who know about referential transparency would help a lot
23:30:07 <Saulzar> Yes, to use C++ effectively you don't write it like C...
23:30:12 <lispy> Korollary: yeah, i've heard people that only use C++ because it lets them use operator overloading ;)
23:30:14 <Korollary> dons: but RT doesn't apply to anything else.
23:30:25 <dons> of course it does.
23:30:29 <Cale> Well, if you know a real OO language, you're not going to write C code in C++
23:30:53 <palomer> I still don't get new/delete!
23:30:58 <Korollary> palomer: ??
23:31:13 <palomer> or, rather, every time I try to use them all hell breaks loose
23:31:13 <Cale> If you know Haskell, you'll find mutable state painful, and that pretty much gets rid of any C-like usage
23:31:18 <lispy> palomer: i hate trying to remeber when i need delete[] vs. delete
23:31:30 <Korollary> lispy: use smart pointers and be done with it ;)
23:31:33 <palomer> lispy: that's easy: delete[] is for arrays
23:31:59 <lispy> palomer: i know the rule, but the fact that i have to make sure i'm using the right one is annoying
23:32:09 <lispy> Korollary: smart pointers don't work in all cases
23:32:27 <lispy> Korollary: i take that back, auto_ptr doesn't work in all cases
23:32:40 <Korollary> dons: How does RT help writing in perl?
23:32:48 <Saulzar> Cale, But there's the whole other side of templates and the standard library which a lot of C/Java programmers miss. I think knowing the standard library is one of the things which makes you really proficient...
23:33:40 <Cale> Saulzar: that can be read about in a couple of days though, can't it? Perhaps I'm forgetting, but back when I wrote C++ code, the STL wasn't *that* large.
23:33:43 <dons> Korollary, you'd write decent subs that didn't mess with global state and do weird things
23:33:45 <Saulzar> For example, I know some of haskell, but not really many details or much of the standard library - so I'm horribly ineficient compared to most around here
23:34:02 <dons> I have to mark perl assignments, it makes a big difference :)
23:34:13 <Saulzar> Cale, It's not - but most don't bother
23:34:18 <Cale> Saulzar: is the STL even as large as the Hierarchy?
23:34:28 <Korollary> dons: global state is discouraged in every PL. But the rest of the body of the sub has state.
23:34:33 <Cale> I'm sure it doesn't include things like X11 and OpenGL
23:34:35 <Korollary> Cale: STL is pretty big
23:35:03 <lispy> most languages feel small after mucking about in CL for a while.
23:35:18 <lispy> i think the flatness of the namespace gives CL an impression of being unlearnably large
23:35:22 <Saulzar> I like languages which feel small
23:35:22 <Cale> How much has it grown since 1997 or so?
23:36:14 <Korollary> Cale: I don't exactly know. But you don't really need to know every detail. I don't even know the entire streams hierarchy. heh.
23:36:48 <Korollary> Saulzar: like Scheme!
23:37:01 <lispy> C is pretty small too
23:37:20 <lispy> well, if you don't count the numerous libraries and the POSIX/Unix stuff
23:38:02 <Korollary> Because of the libraries issue, I don't really consider myself someone who knows Java.
23:38:13 <lispy> yeah, same here
23:38:34 <lispy> i know the syntax, i can deal with a lot of java weirdness, but i don't really know the api.  On the other hand, the api has decent documentation
23:39:53 <palomer> I would hire anyone with "visual object oriented logo writer" on their resume
23:39:59 <Korollary> Yes, but Python's libs are pretty well documented, too. I'd say I know Python, but it's because Java's use is so much about the libs, I couldn't say the same.
23:40:13 * lispy updates resume and sends to palomer
23:40:22 <Cale> I wrote a compiler in Java in one of my courses, but I don't know the libraries terribly well.
23:40:23 <palomer> the problem with java is that there is basically one and only one set of libraries
23:40:33 <palomer> installing and distributing third party libraries is a pain
23:40:53 <palomer> this is a really huge problem
23:41:23 <Cale> You can write quite a lot by keeping a browser with documentation open at all times.
23:41:27 <Saulzar> The basic libraries are extremely comprehensive though, which is one of it's major strong points
23:41:40 <palomer> true
23:41:51 <palomer> I've yet to find something I needed which wasn't in the standard library
23:41:51 <Korollary> I looked at Ruby today. I have no idea why somebody who knows Perl and/or Python would be interested in it.
23:42:08 <palomer> Though I have wanted to use sdl for java (a major no go)
23:42:14 <Cale> Ruby? There are some nice things about it.
23:42:26 <Cale> I consider it about as pleasant as python
23:42:46 <Korollary> Cale: But which areas does it surpass them?
23:42:54 <palomer> Korollary: call/cc? lambdas which are more than 1 line? everything is an object(including classes)?
23:42:58 <lispy> i think the major draw to ruby at the moment is rails
23:43:16 <palomer> a more consistent standard library
23:43:36 <palomer> shall I go on?
23:43:41 <Cale> It's more object oriented than either one of them. Code blocks aren't quite monadic programming, but they come close to that level of expressiveness for IO.
23:43:48 <Korollary> palomer: heh, call/cc and multiline lambdas would be a case for using scheme instead.
23:44:02 <palomer> scheme is missing things which python and ruby have
23:44:13 <Korollary> Yes, it is
23:44:39 <palomer> sane syntax, built-in OO type system, comprehensive library, etc...
23:45:22 <palomer> seriously, whoever thought that people could read scheme was nuts
23:45:24 <Korollary> But I doubt that the audience who is switching from Perl/Python to Ruby is doing it for call/cc.
23:45:32 <lispy> oh man, reading the ffi report makes me feel like there is a lot (too much?) to learn before i can use ffi corectly
23:45:39 <palomer> Korollary: rails was a major winning point
23:45:39 <Cale> scheme/lisp are readable once you've written a bunch of code in them
23:46:01 <Korollary> palomer: scheme is readable with proper editor support, imho.
23:46:04 <palomer> Cale: that's what I thought, and then I wrote a bunch of code and still couldn't find it readable
23:46:08 <Cale> lispy: you don't need to know it all -- the most interesting part is the syntax of foreign import
23:46:09 <lispy> yeah, lisp is not a problem once you write for a while
23:46:18 <palomer> haskell/ml is _so_ much more readable
23:46:30 <Cale> palomer: I agree with that still
23:46:35 <Korollary> yes, that's why I don't write any more scheme heh.
23:46:47 <lispy> Cale: is there a tool that can read the .h files and just give me a haskell "library" to use?
23:46:53 <Cale> (that Haskell at least is more readable)
23:46:56 <palomer> I mean, I could read scheme, but it would take me much more time than it should have
23:47:11 <Cale> lispy: yes, but it's not going to give you a nice Haskell library
23:47:20 <lispy> Cale: hmm...
23:47:33 <Cale> lispy: also, I think there are already bindings to win32 if that's what you're looking for
23:47:36 <palomer> haskell seriously needs structures/functors
23:47:50 <lispy> Cale: i looked for win32 bindings, but my google skills may need work
23:47:51 <Korollary> palomer: like ocaml?
23:47:57 <palomer> heck, I'd be happy with structures/signatures
23:48:02 <Cale> my main gripe about CL was the lack of static typing
23:48:05 <palomer> Korollary: or sml
23:48:24 <lispy> Cale: sblc has static typing, but it doesn't really enforce it unless you beg
23:48:24 <Korollary> palomer: I didn't quite understand what functors accomplished, really.
23:48:38 <Cale> lispy: yeah, I never figured out how to get it to work
23:48:49 <Cale> I used structures a whole bunch
23:48:55 <Cale> which helped quite a lot
23:49:00 <lispy> Cale: it gave me a bunch of type errors that didn't matter once and wouldn't compile some valid code :)
23:49:02 <Cale> but it didn't catch a lot of things
23:49:04 <palomer> Korollary: oh, they accomplish something similar to type classes (in most cases)
23:49:22 <Korollary> palomer: That's what I thought. What do they do that can't be done using classes?
23:49:30 <Saulzar> They seem a lot more like C++ templates
23:49:56 <palomer> Korollary: they're much more powerful. for example, type classes can only be singly parameterized, right?
23:50:13 <palomer> type classes are a lot like C++ templates
23:50:30 <Lemmih> eh?
23:50:56 <lispy> Cale: so which of these FFI tools are any good, green card?
23:51:09 <Korollary> palomer: Then you can use contexts with multiple classes in the function.
23:51:34 <Cale> lispy: I haven't tried many of them. c2hs seems reasonably good
23:51:45 <palomer> Korollary: I'm not too familiar with haskell, so I don't know what that means
23:51:50 <Cale> there are some fairly automatic tools
23:51:50 <lispy> i think green card is for exposing haskell to C
23:51:52 <palomer> Lemmih: eh what?
23:52:26 <Lemmih> Type classes aren't a lot like C++ templates.
23:52:38 <palomer> Lemmih: they solve the same kinds of problems (in most cases)
23:52:40 <Cale> http://www.haskell.org/hawiki/HsffigTutorial
23:52:42 <Lemmih> lispy: GreenCard is a bit outdated.
23:52:48 <Korollary> palomer: if function f takes a b c, and we want to parameterize all of them, we can have (Eq a, SomeOtherClass b, ...) => f :: a -> b -> c -> ...
23:53:02 <palomer> Lemmih: you have some function which depends on what a type can do, and is valid for all type that have these capabilities
23:53:12 <Lemmih> lispy: hsc2hs a more lightweight compared to c2hs.
23:53:30 <palomer> Korollary: can you have (Eq a, SomeOtherClass a, ...) => f:: a -> b -> ... ?
23:53:53 <lispy> Lemmih: what do ye mean lightweight?  doesn't do as much?
23:54:17 <Korollary> palomer: not without the right hierarchy. I see what you mean.
23:54:59 <Lemmih> lispy: Yeah. It's more suitable for small bindings than c2hs, IMHO.
23:55:22 <lispy> if there is a win32 api i can't find it
23:55:33 <lispy> (i mean a win32 api binding for haskell)
23:55:39 <palomer> Korollary: also, what if you want to write a type class which takes 2 parameters ? (Eq a b)
23:55:46 <lispy> Lemmih: thanks
23:55:56 <Cale> palomer: in Haskell?
23:55:59 <palomer> Cale: yeah
23:56:05 <palomer> this can't be done, right?
23:56:11 <Cale> palomer: the things you're describing are all possible in Haskell
23:56:16 <Korollary> 'a' would have to be a type constructor.
23:56:29 <palomer> both a and b would have to be type constructors, no?
23:56:44 <palomer> oh wait, I see
23:56:47 <palomer> I mean (Eq a) b
23:56:48 <Cale> you can have constructor classes
23:56:52 <Cale> look at Monad
23:56:55 <astrolabe> I've seen multi-parameter type classes in the array stuff.
23:57:05 <palomer> not Eq (a b)
23:57:14 <Korollary> astrolabe: I think those are beyond h98
23:57:16 <Cale> Eq a b means (Eq a) b
23:57:25 <astrolabe> Korollary: yes
23:57:30 <palomer> I remember ski telling me this can't be done
23:57:37 <Cale> and yeah, it's past H98
23:57:40 <Cale> but it's in GHC
23:57:51 <Cale> but Eq is single parameter
23:57:55 <palomer> yeah
23:57:56 <Cale> you can have
23:57:56 <Lemmih> And in Hugs, right?
23:58:05 <Cale> class VectorSpace f v | v -> f where
23:58:08 <Cale> yeah
23:58:23 <Cale> which means that if you know the type v, then f is determined uniquely
23:58:27 <Korollary> well, maybe haskell-prime should have structures, then.
23:58:34 <Cale> and the compiler will guarantee that
23:58:39 <Cale> and have operations like
23:58:47 <Cale> (.*) :: f -> v -> v
23:58:49 <palomer> Cale: oh no, I mean (SomeClass a b) <--a and b are not related
23:58:57 <Korollary> although I don't like the names structure and functor (confusing).
23:58:57 <Cale> sure, you can do that too
23:59:05 <Cale> look at, say, IArray
23:59:08 <palomer> Korollary: structure is a namespace
23:59:15 <palomer> Korollary: functors map namespaces to namespaces
23:59:22 <Cale> class HasBounds a => IArray a e
23:59:40 <palomer> Korollary: so an instance of a class is a mapping from names to functions, right? hence a namespace
23:59:40 <Cale> a being an array type and e an element type
23:59:46 <Korollary> palomer: well, I mean the terminology is confusing since functor is something else in haskell, and people think of C structures when you say structure.
