00:03:22 <palomer> this is computer graphics
00:03:30 <palomer> that was a seriously stupid class though
00:04:01 <palomer> I'm off to bed
00:04:37 <palomer> someone help MarcWeber, he's having trouble comiling with ghc
00:04:40 <palomer> night yall
00:41:21 <SlowByte> MarcWeber: if you need a program to pick distinguishable colour values, do it in the HSV/HSL colour space
00:42:05 <SlowByte> oh, sorry, that was supposed to be palomer:
00:42:06 <SlowByte> :)
00:43:34 <MarcWeber> SlowByte: We already did that by using a hsv gradient and letting gimp calculate a optimized 12 value indexed palette ;-).. But think of red green desease and so on.. it's not so easy *lol*
00:55:52 <SlowByte> MarcWeber: yeah, I didn't read the log to that far ;)
01:01:27 <MarcWeber> Shit. My processor is idle but ghc hasn't finished compiling that file.. 
01:02:43 <flux__> paging?
01:03:00 <MarcWeber> No hard disk activity.
01:05:12 <MarcWeber> flux__: Where can I watch paging (on win?)
01:13:54 <flux__> well, there would be hard disk activity in that case, but I thinkg Windows has some system performance monitor software
01:18:43 <MarcWeber> flux__: When using ghc -v [..] it hangs at include ".." "<..>"\n End of search list
01:19:12 <MarcWeber> Any ideas how to track down the error?
01:22:42 <soysauce> @hoogle nub
01:22:43 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
01:22:43 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:23:02 <gour> dcoutts: ping
01:26:58 <soysauce> > let xs = [0,0,0,1,2,3,3,4,4,4,4,5] in foldl (\ys x -> if x /= (head ys) then x:ys else ys) (head xs:[]) (tail xs)
01:27:00 <lambdabot> [5,4,3,2,1,0]
01:27:27 <soysauce> > let xs = [0,0,0,1,2,3,3,4,4,4,4,5] in foldr (\x ys -> if x /= (head ys) then x:ys else ys) (head xs:[]) (tail xs)
01:27:28 <lambdabot> [0,1,2,3,4,5,0]
01:28:18 <soysauce> > let xs = [0,0,0,1,2,3,3,4,4,4,4,5] in foldr (\x ys -> if (null ys) || (x /= (head ys)) then x:ys else ys) [] (tail xs)
01:28:19 <lambdabot> [0,1,2,3,4,5]
01:29:24 <soysauce> @pl (\ys x -> if x /= (head ys) then x:ys else ys)
01:29:25 <lambdabot> flip =<< ap (ap . (if' .) . (/=) . head) (flip (:))
01:35:07 <flux__> marcweber, sorry, no
01:40:52 <araujo> Î»
01:56:38 <dcoutts> gour, sorry, no time.
02:20:59 <joelr1> morning!
02:21:20 <joelr1> is there a way to see a history of patches with darcs? 
02:21:30 <joelr1> commited against a particular file
02:23:24 <jethr0_> joelr1: maybe darcs diff for a file given two versions?
02:24:24 <joelr1> no, it's darcs changes -v
02:24:37 <jethr0_> ah, ok
02:24:48 <jethr0_> i misread your question, too :)
02:52:44 <xerox> Ciao.
03:01:31 <jethr0_> bye
03:05:06 <jethr0_> @seen shapr
03:05:06 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 22 hours, 56 minutes and
03:05:06 <lambdabot> 45 seconds ago.
03:05:41 <xinming> for Writer Monad, what does listen do?
03:05:53 <xinming> listen (Writer (a,w))     = Writer ((a,w),w) 
03:05:56 <flux__> how useful is that second information anyway, or even the minute information, when there's 22 hours already?-)
03:06:08 <xinming> It's easy to understand, why the this is used for
03:06:18 <jethr0_> hehe
03:07:15 <xinming> I know tell is used for update the value in monadic value. :-)
03:24:46 <araujo> Good morning Haskell!
03:24:58 <jethr0_> good morning, mister araujo.
03:25:14 <araujo> Hello Dr. jethr0_ :-)
03:25:29 <jethr0_> that's all right, you can call me simple jethr0
03:26:12 <araujo> hah :-)
03:26:15 <joelr1> any quickcheckers?
03:27:03 * araujo eating some ice-cream
03:27:19 * jethr0 eating some popcorn
03:27:35 <araujo> :-)
03:27:58 <tennin> programming in Haskell I always have this nagging suspicion there's some nicer way of doing things
03:28:04 <tennin> does that ever go away, with enough experience?
03:28:14 <joelr1> no
03:28:26 <araujo> tennin, Why it should!?
03:28:52 <jethr0> i guess there's always the compromise of overcomplication and more abstraction :)
03:29:14 <tennin> at least in some other languages I know there probably isn't any way to make it less ugly, so I don't have to try =P
03:30:44 <jethr0> any ion users around?
03:33:44 <araujo> tennin, Haskell is like writting poetry.
03:34:00 <araujo> Romantic and fun.
03:35:52 <jethr0> you never know when done? :)
03:36:14 <wilx> Poetry is not all romantic and fun :)
03:36:43 <araujo> jethr0, isn't taht fun? :-)
03:37:40 <jethr0> sure, but you never get closure... always go back to old programs saying: "ooh, maybe i can do this a little nicer/shorter/better/more descriptive"...
03:37:46 <araujo> wilx, that kind of poetry i meant....
03:38:05 <xinming> writing haskell is a bit like writing a formula, and you can always deduce the finally function yourself. :-) But it's also a pain to do so
03:38:44 <araujo> yes, that's why i think a hacker is very similar to a painter or writter
03:40:13 <tennin> there's definitely a lot of room for expression... which definitely invokes the aesthetic perfectionist in me
03:40:48 <tennin> yeah, and most of my essays, stories, music compositions go unfinished for the same reason
03:41:24 <tennin> but I guess knowing when to stop probably does come with experience
03:41:36 <astrolabe> I don't know if it's because I'm a beginner, but I spend a LOT of time working out how I should do things in haskell.
03:41:37 <jethr0> depends on how you define unfinished. they might be considered finished, but there's always sth to improve
03:42:32 <araujo> abstract expressionism painters goes through a process very similar to that of a hacker for example.
03:42:42 <araujo> I enjoy a lot that kind of painting.
03:46:18 <araujo> They got no clue what the painting will be like :-]
03:47:34 <araujo> And the painting might mutate dozens of times while they keep painting....
03:47:37 <araujo> It's fun.
03:48:43 <xah> xerox: how's your haskell hacking?
03:49:10 <xerox> xah: quite cool!  I wrote the Scavenger Monad yesterday, heh.
03:49:32 <xah> :) what's that?
03:51:56 <xerox> Hmm, how is *your* Haskell going? :-)
03:53:57 <tic> What's the name of the notation haskell uses (without parens)? 
03:54:06 <xerox> Prefix?
03:54:25 <tic> no, it's a special name for the notation that doesn't use parens. :)
03:54:50 <xerox> That's postfix
03:55:05 <tennin> I think he might mean f 9 vs. f(9)
03:55:07 <tic> Yeah, but there's another name for that specific leaving-out-parens-syntax
03:55:09 <tic> exactly.
03:55:37 <jethr0> applicative?
03:55:57 <xerox> It's like "1 2 + 4 *" => 12
03:56:02 <xerox> Or something :-)
03:56:14 <tic> xerox, no, not that.
03:56:18 <tic> I meant what tennin said.
03:56:20 <xerox> Hmpf.
03:56:30 <xerox> That's currying
03:56:34 <tic> No.
03:56:39 <xerox> :(
03:56:40 <tic> compare:
03:56:43 <xerox> Why not.
03:56:44 <tic> f a b c
03:56:48 <tic> f(a, b, c)
03:56:52 <xerox> Yes.
03:57:01 <xerox> The first one works because of currying.
03:57:06 <tic> and I'm not referring to the (((f a) b) c)
03:57:10 <tic> yes, I know that. :)
03:57:25 <jethr0> (f a b c)   in lisp :)
03:57:32 <tic> okay, so say a function from a -> b. Then you need to write f(x) in C/Python/whatever, but (f x) in Haskell.
03:57:47 <tennin> in principle, currying and parens are orthogonal, since you could have ((f(a))(b))(c)
03:57:49 <astrolabe> as in the lambda calculus
03:58:11 <tic> sure.
03:58:29 <xerox> tic: check this out:
03:58:33 <xerox> @type curry
03:58:33 <xs> jethr0: wouldn't it be (((f a) b) c) in lisp?
03:58:33 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
03:58:36 <xerox> @type uncurry
03:58:37 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
03:58:49 <tic> xerox, I already know what you're getting at, and thank you for that. :)
03:58:53 <jethr0> xs, depending whether it was curried or not.
03:58:59 <jethr0> and most functions aren't by default
03:59:03 <tic> xerox, but it's not about what it's doing, it's just some name somebody came up with.
03:59:05 <xerox> > let sum = uncurry (+) in sum (1, 2)
03:59:06 <lambdabot> 3
03:59:29 <xerox> > let sum = (+); sumU = uncurry (+) in (sum 1 2, sumU (1, 2))
03:59:30 <lambdabot> (3,3)
03:59:33 <xerox> Is it not?
04:00:38 <astrolabe> The report just says "Function application is written e_1 e_2."
04:01:07 <tic> Yeah. Oh well, nvermind.
04:01:22 <xinming> for Writer Monad, what does listen do?
04:01:39 <xerox> Heh, it listens to what its 'told'
04:01:46 <xinming> wc, bbl&
04:06:04 <tennin> hmm, "the basic syntactic form for function application is juxtaposition..."
04:07:43 <tennin> "in Standard ML, juxtaposition denotes function application..." ... maybe that's the word you want?
04:12:34 <tic> aha!thanks :)
04:14:01 <tennin> no, thank you for giving me a chance to be helpful for a change =)
04:20:41 <tic> would you say concludingly?
04:20:59 <astrolabe> That's not a word!
04:21:13 <astrolabe> 'in conclusion'  ?
04:21:21 <tic> Yeah, thought so. :) Thanks!
04:21:54 <xerox> ...or you could start using it waiting the people to follow you, heh.
04:21:59 <xinming> xerox: Is it like get in State Monad?
04:22:02 <jethr0> apart from not being a word, it wouldn't even be a sensible adverb
04:22:26 <xerox> xinming: somehow... let me see.
04:24:11 <tennin> why not?
04:24:41 <tennin> "concluding" is used as a synonym for "final", right?
04:24:44 <jethr0> hmm, well maybe
04:25:21 <jethr0> sometimes i write faster than i think :(
04:25:40 <xinming> listen (Writer (a,w))     = Writer ((a,w),w) 
04:26:37 <jethr0> but usually adverbs are built from adjectives, not verbs
04:26:50 <xinming> since tell's implemention is tell v = Writer (_,v)
04:29:51 <tennin> doesn't it just allow the "log" to be read by the next function in the do block?
04:31:07 <jethr0> and "conclusively" is an actual adverb
04:31:31 <tennin> the next function being of type (a,w) -> Writer w b
04:33:22 <Cale> hello
04:33:26 <jethr0> hi cale
04:33:54 <Cale> I just wrote a program to verify that someone's reasoning about a small concurrent program was flawed. 
04:34:14 <tennin> dictionary.com actually does have "concludingly", as a synonym for "conclusively".  I've never seen it though
04:34:23 <jethr0> cool, me neither
04:34:36 <Cale> http://vx.hn.org/autoshare/inter.hs :)
04:34:50 <Cale> http://rafb.net/paste/results/KwxULF72.html was the original "proof"
04:35:27 <jethr0> also, i'm not sure whether "conclusively" means the exact same thing as "in conclusion"
04:36:02 <tennin> I don't think it means the same thing at all
04:36:04 <Cale> no
04:36:09 <Cale> it's not the same
04:36:18 <jethr0> because "conclusively" means finally and "in conclusion" means "in closing"
04:37:14 <jethr0> finally in the sense of irrevocably
04:37:23 <Cale> "Conclusively" has a sense of "with certainty"
04:37:38 <Cale> and it applies to arguments
04:37:38 <jethr0> yes
04:37:43 <xinming> tennin: Sorry, I don't understand exactly. :-(
04:38:17 <Cale> anyway, inter.hs is a nice little interpreter for a trivial assembly language :)
04:38:46 <Cale> (which isn't even Turing complete, but whatever :)
04:38:47 <MarcWeber> Do you know what might be the reason if either cc1 continues compiling or ghc stops using cpu but doesn't finish dependend on some compile flags such like -fvia-C?
04:39:12 <xinming> tennin: for example. return a >>= listen >>= (\x -> x) what will x get ?
04:39:29 <musasabi> MarcWeber: try adding -v to the GHC command line if it tells the answer
04:40:17 <jethr0> cale, and what does/can it prove?
04:41:52 <Cale> It proves that if each loop runs twice, that the max/min value of x is +-3
04:42:18 <Cale> whereas if the reasoning there was correct, it would be 2
04:42:26 <jethr0> haha
04:43:21 <tennin> xinming: I don't think that will work... it would have to be listen (return a) >>= return
04:45:53 <xinming> tennin: So, what the monadic value will be for your expression?
04:46:11 <xinming> Writer (a,v) ?
04:46:16 <Cale> xinming: it depends on which Writer monad
04:46:51 <Cale> :t return a >>= Control.Monad.Writer.listen >>= (\x -> x) 
04:46:55 <Cale> @type return a >>= Control.Monad.Writer.listen >>= (\x -> x) 
04:46:56 <lambdabot> Not in scope: `a'
04:47:02 <Cale> @type \a -> return a >>= Control.Monad.Writer.listen >>= (\x -> x) 
04:47:03 <lambdabot> forall w a.
04:47:03 <lambdabot> (Control.Monad.Writer.MonadWriter w ((,) a)) =>
04:47:03 <lambdabot> (a, a) -> (a, w)
04:47:52 <jethr0> nice cale, although exhaustion might not scale to hundreds of asm lines :)
04:48:10 <xinming> :-S
04:48:17 <xinming> will think more
04:48:19 <tennin> just a minute
04:48:20 <MarcWeber> What does the option /split-objs do?
04:49:16 <jethr0> it splits into smaller object files to help the linker(?)'s dead-code heuristics (or sth)
04:50:01 <jethr0> just repeating what i heard in here yesterday/day before :)
04:50:51 <MarcWeber> jethr0: What does dead-code mean?
04:51:21 <jethr0> code that isn't needed by any execution path, but was present in the sources.
04:52:09 <jethr0>  /split-objs simply results in smaller binaries
04:52:41 <MarcWeber> Thanks.. So that's not my problem.
04:52:48 <jethr0> he
04:52:58 <jethr0> but disabling won't hurt
04:56:49 <tennin> xinming: for example, runWriter((listen (return a)) >>= return) :: ((Integer, [Integer]), [Integer]) will get you ((a, []), [])
05:00:39 <tennin> er rather, runWriter((listen (return x)) >>= return) :: ((a, [a]), [a]) will get you ((x, []), [])
05:03:55 <Cale> jethr0: I know, it actually takes quite a long time to run if I increase the number of loop iterations to 3. Longer than I want to bother running it, anyway
05:04:34 <jethr0> well, if needed, one could add some heuristic to decide whether a local combination will make a difference
05:04:42 <MarcWeber> jethr0: It's really wired: ghc just stops working without having finished compilation. The last line printed on my screen is a cc1.exe line.. So I think cc1 is the evil..
05:04:44 <jethr0> but then you'd have to prove the heuristic :)
05:05:48 <jethr0> have you tried using only some stages. so only producing c-code? also, you might try -fasm to circumvent gcc
05:05:51 <Cale> jethr0: I think there's a closed form anyway if you think hard enough :)
05:06:12 <jethr0> certainly, but for a quick test this is cool
05:06:52 <jethr0> with operational semantics it might well be provable
05:12:37 <tennin> xinming: and in general, runWriter((listen (return x)) >>= return) :: ((a, <monoid>), <monoid>) will yield ((x, <empty monoid>), <empty monoid>).  because the monadic side effects/log output of every function in the do block are accumulated in the monoid, and "listen" takes whatever's been written so far and sends it to whatever function the value of "listen" is bound to, but in this particular example nothing's written to the monoi
05:17:51 <xinming> tennin: So, if there are many listen within a >>= monadic calculation, the final result will be (((((a,v),v1),v2),v3),v4), right?
05:22:14 <xerox> xinming: no.
05:22:48 <tennin> if there are many (listen . return) or such, without anything intervening to dispose of the nested tuples, yeah
05:23:19 <xerox> I don't think so
05:23:31 <xinming> hmm, I don't mean a >>=, I mean many. :-) listen(return a) >>= \x -> listen(return x) >>= \y -> listen(return y)>>=return
05:24:39 <xinming> what does mappend do by the way
05:25:19 <xinming> (Writer (a,w)) >>= f = let (a',w') = runWriter $ f a in Writer (a',w `mappend` w')
05:25:34 <xerox> I'm not sure I'm understanding listen.
05:25:35 <xinming> for this function, the right part, is `in Writer (a',w `mappend` w')` valid?
05:25:51 <xerox> mappend is defined in the Monoid insance
05:25:56 <xerox> For example:
05:26:03 <xerox> instance Monoid (a -> a) where
05:26:07 <xerox>   mempty = id
05:26:09 <xinming> hmm, how about the a',w ?
05:26:10 <xerox>   mappend = (.)
05:26:54 <xerox> runWriter (do { tell [1]; a <- listen (return "1"); tell [2]; b <- listen (return "2"); return (a,b) })
05:27:03 <xerox> ==> ((("1",[]),("2",[])),[1,2])
05:27:07 <xerox> hmm.
05:27:55 <xerox> No way..
05:31:26 <xinming> +_+
05:31:52 * xerox thinks harder
05:33:36 <xerox> AH!
05:33:42 <xerox> runWriter (do { tell [1]; (a,w) <- listen (tell [2,3]); tell [4]; return w })
05:34:12 <xerox> Maybe its useful to listen to a specificl part of the computation.
05:34:26 <Cale> jethr0: btw, that closed form is [-(2n-1), 2n-1], where n is the number of iterations in each of the two processes.
05:36:44 <xerox> xinming: does it make any sense?
05:36:54 * xinming is thinking harder.
05:39:41 <xerox> xinming: it works for me
05:40:10 <xinming> It works for me also, I just trying to understand what It means. :-)
05:40:35 <xerox> It's like, run a subcomputation and listen to its log (and return value).
05:40:49 <xerox> Without listen how would have you done that?  Mumble.
05:42:41 <xerox> This doesn't work in the same way, [2,3] will not compare in the "main" log.
05:42:43 <xerox> runWriter (do {tell [1]; (a,w) <- return $ runWriter (tell [2,3]); tell [4]; return w })
05:42:52 <xerox> ([2,3],[1,4])
05:43:38 <tennin> oh
05:43:39 <tennin> you're right
05:43:55 <tennin> looks like I was wrong
05:43:55 <xerox> In the other case, in fact:
05:43:57 <xerox> runWriter (do { tell [1]; (a,w) <- listen (tell [2,3]); tell [4]; return w })
05:43:57 <xerox> ([2,3],[1,2,3,4])
05:48:27 <tennin> <tennin> "listen" takes whatever's been written so far and sends it to whatever function the value of "listen" is bound to <-- wrong, wrong, wrong =\
05:49:03 <xerox> Indeed.
05:49:07 <xerox> It's the other way around.
05:50:22 <xinming> xerox: runWriter (do { tell [1]; (a,w) <- listen (tell [2,3]); tell [4]; return w })
05:50:25 <xinming> what will a get?
05:50:30 <xerox> ()
05:50:49 <xerox> runWriter (do { tell [1]; (a,w) <- listen (tell [2,3]; return "hi!"); tell [4]; return w })
05:50:53 <xerox> a = "hi!"
05:53:22 <xerox> Uh
05:53:24 <xerox> Maybe I got it.
05:53:53 <xerox> Nah.
05:54:37 <xerox> Okay, I think that's it.
06:00:54 <tennin> think you left out a "do" there
06:02:46 <xerox> Right.
06:02:55 <xerox> or s/;/ >>/
06:05:35 <Gs30ng_> hi
06:05:51 <Gs30ng_> isn't there any Qt library written for haskell?
06:06:05 <xerox> I don't really know!
06:06:19 <xerox> Gtk2Hs is too cool to think about something else <blink>
06:06:28 <Gs30ng_> I don't like gtk
06:06:29 <xerox> Except for tuomov, but hey... ;-)
06:06:51 <Gs30ng_> it's kinda slow and sometimes bugful in win32 environment
06:07:00 <Gs30ng_> well, compared to Qt, i mean.
06:07:11 <xerox> We got Cairo vector graphics in Gtk2Hs too!
06:07:30 <xerox> OpenGL integration (and widget), and much more... woot :)
06:07:50 <Gs30ng_> and wxHaskell library doesn't work on my machine... i don't see what's the problem
06:08:05 <sajjad_rpg> hi
06:08:15 <sajjad_rpg> i want to learn hack
06:08:24 <sajjad_rpg> is there any one to help me?
06:08:44 <xerox> My first Gtk application compiled *seamlessy* on windows, and it was *completely* developed on linux.
06:08:55 <xerox> sajjad_rpg: do you mean 'Haskell' ?
06:08:57 <Cale> sajjad_rpg: You can grab a Haskell tutorial
06:09:11 <Cale> http://www.haskell.org/learning.html
06:09:12 <sajjad_rpg> no
06:09:15 <sajjad_rpg> Hacking
06:09:18 <Cale> YAHT is a good one
06:09:26 <xerox> sajjad_rpg: it's the same thing.
06:09:51 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
06:10:02 <Gs30ng_> there.. i see the topic. :)
06:10:48 <Cale> Haskell is the language of choice for discriminating hackers, after all :)
06:10:56 <xerox> Point
06:11:17 <Gs30ng_> my wxHaskell installer says
06:11:19 <Gs30ng_> 'ghc-pkg' is not recognized as an internal or external command,
06:11:19 <Gs30ng_> operable program or batch file.
06:11:19 <Gs30ng_> error:
06:11:19 <Gs30ng_>   Unable to register the package using "ghc-pkg".
06:11:19 <Gs30ng_>   Maybe you have an incompatible version of ghc installed?
06:11:48 <Gs30ng_> and i'm quite sure i've installed proper version of ghc
06:12:35 <Cale> aw, he left
06:13:06 <Gs30ng_> ghc is version 6.4.1 and wxHaskell is for Windows, ghc 6.4
06:14:12 <jethr0> it's quite funny to see these wannabes drop in here and get utterly confused by what they're told ;)
06:14:47 <xerox> That description resembles my first times <grin>
06:15:25 <kowey> Gs30ng_: is this with cygwin?
06:15:52 <jethr0> i really wonder what they expect... like hacking an application was sth you could do without prior a host of CS related topics (programming, compiling, assembly, debugging, ...)
06:16:00 <Gs30ng_> kowey: i'm sorry but what do you mean with 'this'?
06:16:36 <jethr0> Gs30ng_: are 'you' running under cygwin
06:16:53 <Gs30ng_> well then obviously no
06:17:00 <jethr0> :)
06:17:08 <kowey> and you're installing the binary version of wxHaskell?
06:17:42 <kowey> well, i guess that would be yes, since you're talking about an installer
06:18:56 <Gs30ng_> i've just simply downloaded a file whose description is "Binary package: Windows, ghc 6.4, updated" and extracted it
06:19:12 <kowey> ok... i'm not on windows myself, but i'm taking a look right now
06:20:08 <Gs30ng_> and expected an msi or exe file, just like in case of ghc, but encountered a batch file. they says i should execute the batch file named wxHaskell-register.bat and i simply did
06:20:44 <Gs30ng_> there was no notice about need of cygwin or some another Unix-related tool
06:20:51 <kowey> my basic guess is that ghc isn't in your path
06:20:57 <kowey> erm... how do you run ghc under windows?
06:20:58 <MarcWeber> How to specify include-dirs in a cabal specification file? Is include-dirs: "d:\haskell\fptools\fptools\lib\" correct ? Or do I have to escape the \?
06:21:01 <kowey> DOS prompt?
06:21:27 <Gs30ng_> on the start menu
06:21:55 <Gs30ng_> i haven't run the very ghc but ghci
06:22:15 <MarcWeber> Gs30ng_: Have you tried adding the bin directory of ghc to the path environment variable?
06:22:23 <MarcWeber> I'm using cygwin shell
06:23:11 <Gs30ng_> i'll try that one
06:25:13 <MarcWeber> Gs30ng_: As far as I know you don't need cygwin..
06:28:27 <xerox> Yaaaaawn.
06:28:52 <jethr0> xerox, where you from?
06:28:58 <Gs30ng_> i just copied all files of wxHaskell to /ghc/bin directory and now it works
06:29:11 <xerox> jethr0: Italy! And you?
06:29:14 <jethr0> germany
06:29:16 <Gs30ng_> it's kinda outrageous
06:29:45 <jethr0> i was just wondering whether in the states they celebrated "advents" the last 4 sundays before christmas...
06:29:52 <jethr0> you do in italy, don't you?
06:30:21 <xerox> Yes.
06:30:30 <jethr0> how are they called in italian?
06:30:34 <jethr0> advento :)
06:30:38 <xerox> Avvento
06:30:41 <jethr0> ah
06:31:14 <kowey> Gs30ng_: hmm... i dunno, i would have added C:/ghc/ghc-6.4/bin (or something similar) to your environment path variable - did that not work on its own?
06:31:44 <jethr0> i'm trying to "darcs get" pugs, but somehow it's not working :(
06:32:30 <Gs30ng_> kowey: i added it, and the error message was somewhat different, but anyway it didn't work
06:33:17 <Heffalump> is ghc 6.4.1 supposed to include Data.Graph in base?
06:33:31 <kowey> Gs30ng_: guess the important thing is that it works... now you can run sample applications and all?
06:33:59 <Gs30ng_> kowey: i'm trying that one now
06:40:29 <Gs30ng_> damn it
06:40:53 <Gs30ng_> it tries to load imports/graphics/(blah blah)
06:41:04 <Gs30ng_> it should be imports\graphics\
06:45:31 <kowey> i thought windows accepted both types of slashes nowadays?
06:46:54 <Gs30ng_> maybe, but not on my ghc :(
06:47:36 <kowey> hmm... ok, well you said you copied stuff directly into the ghc directory: did you then run the installer's batch files?
06:52:34 <Gs30ng_> yes
06:54:29 <kowey> (bear with me here, i'm not on windows)... would you mind working our way back up to the 'official' install?
06:54:33 <kowey> with me?
06:54:50 <kowey> what kind of error messages did you get after setting the environment variable?
06:58:52 <xinming> what does monoid mean by the way?
06:59:44 <xinming> does monoid = monadic value?
07:02:58 <xerox> xinming: the set of natural numbers is a Monoid on the (+) operation with zero as 0, it is also a monoid on the (*) operation with zero as 1.
07:03:37 <xerox> The endofunctors (functions of the type (a -> a)) are monoids on the (.) operation with zero as id.
07:04:24 <integral> (also lists/strings with ++)
07:04:38 <Lor> A monoid is a structure with a carrier set, a designated member of the set, and an associative binary operator for which the designated member is an identity.
07:04:40 <xerox> The Monoid instance for the Writer Monad argument tells it how to combine the values told.
07:04:56 <xerox> (where told = passed to the 'tell' function, heh)
07:05:24 <xerox> associative binary operator, thanks Lor.
07:05:49 <integral> ah, associative
07:06:02 <xerox> Makes sense.
07:08:17 <xinming> anyone here could explain Writer Monad for me? :-/
07:08:33 <xinming> @log
07:08:33 <lambdabot> Maybe you meant: msg yow
07:09:10 <xerox> xinming: what kind of explanation are you thinking of?
07:09:45 <xinming> (Writer (a,w)) >>= f = let (a',w') = runWriter $ f a in Writer (a',w `mappend` w')
07:10:00 <xerox> Right
07:10:09 <xinming> for this, since f will return a monadic action, and mappend is = (.)
07:10:28 <xerox> Hm?
07:10:35 <xinming> So, Writer (a',w `mappend` w') will become, Writer ( a', w . w' )
07:10:55 <xerox> You chosen the 'most difficult' Monoid to start with?
07:11:02 <xinming> But you've said, that w' is monoid.
07:11:20 <xinming> how can that be composed? It's a bit like, 3 . 3
07:11:30 <xinming> hmm, no, "3" . "3"
07:11:34 <xinming> but It's a value
07:11:34 <xerox> You see: > runWriter (do { tell [1]; tell [2]; return 'a' })
07:11:41 <xerox> ==> ('a',[1,2])
07:11:47 <tennin> mappend is only (.) in one particular case
07:11:54 <Pupeno> Good morning.
07:11:55 <xerox> Because mappend = (++) for Monoid [a]
07:12:02 <xinming> xerox: I've read the Reader and State.
07:12:43 <xerox> xinming: good, Writer = State - Reader  :-)
07:12:48 <tennin> because (a -> a) can be treated as a monoid type
07:13:57 <xinming> xerox: But, It's really hard to understad without the explaination from someone. :-/  Maybe Monad is the easiest, And still takes me hours to understad. :'(
07:14:00 <xerox> Want to see an example use of Writer (a -> a) b ?
07:14:25 <xerox> xinming: if you have some precise question I could happily try to answer.
07:14:28 <tennin> (because composition is associative, and the identity function exists)
07:16:14 <xinming> the listen function. :-/
07:16:21 <xerox> xinming: OK.
07:16:26 <xinming> it returns Writer ((a,w),w)
07:16:57 <xinming> don't know why it *should* return ((a,w),w)
07:17:15 <xerox> It's simple inf act.
07:18:39 <xerox> listen (Writer (a,w))     = Writer ((a,w),w)
07:19:07 <xerox> There is something hideously going underneath, heh.
07:19:24 <xerox> This is subtle: Writer ((a,w),w)
07:19:40 <xerox> It just means that it returns a Writer (x,y) where:
07:19:50 <xerox> x = (a,w), the result of the inner Writer computation
07:19:59 <xerox> y = w <- point
07:20:07 <xinming> yes, I understad this
07:20:37 <xerox> Thanks to the internal MonadWriter definition, w is combined (`mappend`ed) to the "log".
07:20:53 <xerox> This just let you do:
07:21:37 <xerox> runWriter (do { tell [1]; (a,w) <- listen (tell [2]; return 0); tell[3]; return (a,w) })
07:21:53 <xerox> ==> ((0,[2]),[1,2,3])
07:22:05 <xerox> I.e. you don't "lose" the inner-computation log.
07:22:17 <xerox> (the [2], in the "main" log)
07:23:22 <xerox> Elsehow, you have surely lost it.  `listen' makes the inner Writer computation aware of~ the outer one.
07:23:37 <xinming> :-S
07:25:03 <xerox> runWriter (do { tell [1]; (a,w) <- liftM (runWriter) (return $ tell [2] >> return 0); tell [3]; return (a,w) })
07:25:06 <xerox> ((0,[2]),[1,3])
07:25:23 <xerox> Was it clear?
07:26:28 <xinming> Sorry. >_<
07:26:47 <xerox> You should not be sorry :-(
07:27:07 <xinming> I am still in confusion. :-(
07:27:12 <xerox> About what?
07:27:58 <xinming> how does it go underneath.
07:28:05 <xerox> heh
07:28:12 <xerox> That's part of the definition, let's see.
07:28:56 <xinming> hmm, I know what your example does, for `runWriter (do { tell [1]; (a,w) <- listen (tell [2]; return 0); tell[3]; return (a,w) })`
07:29:07 <xerox> Yes
07:29:18 <xerox> The definition of listen I mean, it's quite cool, in fact.
07:29:24 <xinming> this do something, with a pair,
07:29:54 <xinming> for the tell [1], It add the [1] into the second part,
07:30:27 <xerox> (if you want the semantics of the pair, 'a' is the return value, 'w' is the log)
07:30:50 <xinming> and the second tell append the [2] after [1]
07:31:32 <xerox> Point is that the |tell [2] >> return 0| part, is a subcomputation 'listened'
07:31:41 <xinming> but, here, I stock, why should we have use a listen to get the a ?
07:31:49 <Pupeno> Is it possible in haskell to have the same function that can be called with different amount of characters ?
07:31:53 <xerox> No no, you *can* get the 'a' without the listen!
07:32:02 <xerox> You couldn't get the 'w'!
07:32:25 <xerox> Pupeno: let it take a string?  type String = [Char]
07:32:38 <Pupeno> xerox: and ?
07:32:55 <xerox> Pupeno: now you have to handle a list of things (Chars).
07:33:20 <Pupeno> what a complex way to say 'no'.
07:33:21 <xinming> tell [2] >> return 3 which will return (3, [2]) in this example
07:33:36 <xerox> Pupeno: maybe I didn't understand your question, my answer is 'yes'.
07:33:46 <xerox> xinming: right!
07:33:57 <xinming> xerox: you can answer Pupeno first, I will think it for now. :-)
07:34:08 <xerox> xinming: no problem, feel free to continue.
07:34:48 <xerox> Pupeno: that is, I read 'different amount' as 'a list of'.
07:34:52 * Pupeno re-reads the question. Sorry, I should be still asleep
07:34:58 <xerox> No problem :-)
07:35:04 <Pupeno> I meant different amount of arguments.
07:35:13 <xerox> Pupeno: nope.
07:35:23 <xerox> Well...
07:35:40 <xinming> Pupeno: think of Zip Zip3 :-)
07:35:40 <xerox> If they're all of the same type, yes.
07:35:54 <xerox> In some sense, if they're eterogeneous too (i.e. HList)
07:36:11 <xerox> But it's kinda cheating, that is, passing a list of them.  In fact it's just "one".
07:36:40 <xerox> xinming: try to run a Writer inside another one with runWriter, and check what happens to the main long.
07:36:44 <xerox> s/long/log/
07:39:52 <xerox> Mumble.
07:42:15 <xinming> runWriter (do { tell [1]; listen( tell [2]); listen( tell [4]); listen( tell [5]) })
07:42:18 <xinming> :-S
07:42:25 <xinming> (((),[5]),[1,2,4,5])
07:42:27 <xinming> *_*
07:42:46 <xerox> Yes.
07:43:02 <xerox> ((),[5]) is just the result of the last expression, namely |listen (tell [5])|.
07:43:37 <xerox> The log is [1,2,4,5], which actually makes sense, being it the main log of the main computation and all the 'listened' logs.
07:46:19 <Pupeno> What is the CInt on Network.Socket.MkSocket ?
07:46:33 <xinming> tell [1] >> listen (tell [2]) >> listen (tell [4]) >> listen (tell [5])
07:50:30 <Pupeno> Is it desired to improve the documentation of, let's say, Network.Socket ?
07:50:49 <xerox> xinming: yes, what?
07:53:56 <xinming> `tell [1] >>= \ (a,w) -> listen( tell [2] )' ==> `Writer ((),[1]) >>= \ ((),w) -> listen( Writer ((),[2]) )
07:54:04 <xinming> xerox: how was listen expanded?
07:55:05 <xerox> I'm not sure: Writer $ runWriter (tell [2]) ?
07:55:17 <xerox> Ah no
07:55:55 <xerox> Hmm, yes, something like that.
07:56:15 <tennin> hmm, looks to me like you can in fact have a function that takes a different amount of arguments
07:56:21 <xerox> tennin?
07:56:41 <tennin> class FnThing a where {fn :: Integer -> a}
07:56:50 <Gs30ng> i have a question... the number of the arguments of a function is called `arity'. then is there any term for the number of the return values of a function?
07:56:58 <tennin> instance FnThing Integer where {fn x = 2*x}
07:57:27 <tennin> instance FnThing (Integer -> Integer) where {fn x = \y -> x*y}
07:57:44 <xerox> Gs30ng: in Haskell all the functions just return one value.
07:57:46 <tennin> (fn 8::Integer)::Integer ==> 16
07:57:52 <xinming> xerox: But in listen function, there isn't any runWriter function. :-/
07:57:57 <tennin> (fn 8::Integer 7::Integer)::Integer ==> 56
07:58:01 <tennin> =P
07:58:05 <Gs30ng> xerox: i didn't mean only in haskell.
07:58:35 <xerox> Gs30ng: Okay.  I always heard it just as 'multiple values', I don't know.  Scheme does that, for example.
08:01:44 <Gs30ng> hmm
08:02:16 <Gs30ng> so, it seems there's no specific word for it, since it is no frequently-used notion
08:02:21 <Gs30ng> anyway thanks
08:02:26 <xerox> You're welcome!
08:02:56 <xerox> IIRC, in perl6 you can do cool things with arities.  For example there is an '.arity' method hehe.
08:07:35 <xinming> xerox: could you please answer my question? :'(
08:08:09 <tennin> actually... I don't quite understand why it makes me give it those type annotations
08:09:49 <TuringTest> tennin : http://okmij.org/ftp/Haskell/vararg-fn.lhs
08:10:38 <TuringTest> It's an explanation of how to write functions like that.
08:13:46 <tennin> ah, thanks
08:16:17 <TuringTest> That's what IRC is for.
08:28:11 <xinming> xerox: thanks, Just now, the result is deduced. :-)
08:37:43 <musasabi> Is there a good way to make monadic code that depends on a lot of option flags pretty?
08:38:50 <Lor> Hide the options under the monad?
08:38:50 <musasabi> the code looks like: "if optA then foo else bar" where foo and bar will also be if-else blocks and so on with small monadic actions (in IO) behind all the flag nonsense
08:39:17 <jethr0> anyone here know where/whether there is a darcs repo for PUGS?
08:39:59 <xinming> jethr0: http://www.pugscode.org/
08:40:06 <xinming> jethr0: there is a link,
08:40:42 <Lor> musa, I don't quite follow
08:40:57 <jethr0> ya, i've seen it... i might've already tried that one, just a sec..
08:41:54 <jethr0> xinming: yes, tried it before. seems to be dead...
08:42:26 <jethr0> i mean in my browser it works, but darcs seems to be doing nothing for a long time
08:42:43 <TuringTest> musasabi : can you write a case (optA,optB,optC) of"
08:43:07 <TuringTest> block that hold all the leafs of all the if-then-else blocks?
08:50:32 <xinming> TuringTest: hmm, if all are if-then-else, will Maybe Monad used here please?
08:52:03 <TuringTest> xinming: don't ask me, ask musasabi.  But he has not acknowledged my reply yet...
08:53:43 * palomer passes the turing test
08:58:51 <jethr0> pugs darcs directory seems definitely broken (or my darcs is)
08:59:03 <musasabi> TuringTest: mmh, that might work (then again it will lead to code duplication)
09:00:05 <TuringTest> Haskell is all about shorthand, just use a let repeatedThingie = ... before the case and you can cut down on duplication
09:02:49 <TuringTest> That's what took me a few weeks to understand about haskell : functions and values are not objective things like in other languages, like C or Scheme.  Anything bound by let or where (or <-) is more like shorthand.  The mutable TVars/MVars/STVars/IOVars are objective things.
09:03:16 <ski_> hehe
09:03:43 <ski_> stuff seem more plastic in some way
09:04:34 <ski_> (that's possibly related to more ease of refactoring, etc)
09:08:38 <tennin> is it silly to use "Either a a" for (Bool, a) ?
09:09:04 <Lor> Depends on the situation.
09:09:42 <Lor> (Also, due to non-strictness, (Bool, a) has more elements.)
09:11:02 <jethr0> lor, i don't understand that last remark
09:11:46 <Lor> _|_ ~ _|_, Left x ~ (False, x), Right x ~ (True, x), but there's nothing to correspond to (_|_, x)
09:12:03 <jethr0> is bottom in Bool?
09:12:07 <Lor> Sure.
09:12:31 <Lor> All types are pointed domains except for unboxed types.
09:12:34 <jethr0> how about (undefined, x)?
09:12:51 <Lor> What about it?
09:13:03 <Lor> As I said, there's no element of type Either a a that would correspond to it.
09:13:28 <jethr0> ah, i get your point
09:14:18 <jethr0> is there a way of making darcs more verbose?
10:01:39 <xinming> runWriter (do { tell []; (a,w) <- listen( return 1); return a})
10:01:59 <xinming> result of this expression will be `(1,[])`
10:02:20 <xinming> why not `((1,[]),[])`
10:02:50 <xinming> since, listen returns `((1,[]),[])'
10:03:58 <xinming> and (1,[]) will become a in above example.
10:04:32 <xinming> and while it returns, it will become (a,w) ==> ((a,w),w)
10:05:08 <HaskNoob> hello
10:05:10 <HaskNoob> I'm back
10:05:21 <HaskNoob> This time... i have a bug
10:07:51 <HaskNoob> ghci says that it had problems IO () against t -> t1, and that the probable cause is that putStr is being applied to too many arguments
10:08:04 <HaskNoob> matching
10:08:07 <ski_> > runWriter (listen (return 1))
10:08:08 <lambdabot>  Not in scope: `listen'
10:08:18 <ski_> > runWriter (Control.Monad.Writer.listen (return 1))
10:08:19 <lambdabot>  Not in scope: `Control.Monad.Writer.listen'
10:08:20 <chucky> hasknoob: How does the call to putStr look?
10:08:24 <TheHunter> hmm, if I use Language.Haskell.Syntax, do I have to fix fixities myself?
10:08:52 <chucky> valid example:
10:08:55 <HaskNoob> well i used to have things concatenated inside of parenthesis, but i broke it all up, so now the call to putStr is just a single argument string..
10:09:07 <HaskNoob> putStr "The sum is "
10:09:12 <chucky> ok... that should work
10:09:17 <HaskNoob> yeah but its not
10:09:24 <HaskNoob> where can i paste my code?
10:09:25 <ski_> HaskNoob : how does context to that look ?
10:09:33 <HaskNoob> well
10:09:35 <ski_> lisppaste2 : url
10:09:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:10:16 <xinming> ski_: Would you please answer me? :-)
10:10:21 <HaskNoob> ok thanks.. working on that paste
10:10:37 <ski_> xinming : yes .. sorry got distracted :)
10:11:41 <lisppaste2> HaskNoob pasted "help with an exercise" at http://paste.lisp.org/display/14788
10:11:56 <MarcWeber> Hi @ll! I've got a problem and I need some ideas... I'm stuck. I still want to compile hdirect. My current problem: when running runhaskell Setup.hs build cc1.exe called by ghc stops working.. At least it doesn't finish in 10 min.. This is anything related: www.rafb.net/paste/results/xeofpd62.html 
10:12:16 <HaskNoob> ok, here it is http://paste.lisp.org/display/14788
10:12:32 <TuringTest> HaskNoob: You need to put a "do" after the "then"
10:12:32 <xinming> HaskNoob: the bot will automatically paste the url. :-)
10:12:51 <TuringTest> The "else" is a single command so omitting the "do" is okay.
10:13:00 <HaskNoob> ooh
10:13:03 <TuringTest> This was tricky for me to learn the first few times
10:13:53 <HaskNoob> if i wasnt doing I/O, would i still need a do?
10:14:07 <HaskNoob> i mean.. is that just because its multiple lines?
10:14:21 <MarcWeber> HaskNoob: do means nice syntax for using monads.. ;-)
10:14:23 <chucky> hasknoob: you can also reduce the number of lines by doing something like: putStrLn $ "The sum is " ++ (show (folkdl (+) 0 ns)) ++ "."
10:14:25 <TuringTest> the "do" wraps up all the command under the "then" into a single "IO ()" expression, which is required by the if/then/else syntax
10:14:39 <HaskNoob> whats $ ?
10:14:48 <xerox> f $ x = f x
10:14:48 <ski_> xinming : the result of 'listen (return 1)' is '((1,[]),[])', right ..
10:14:51 <HaskNoob> oh
10:14:52 <HaskNoob> ok
10:15:08 <HaskNoob> i had it originally with one line, but i started breaking it up trying to get it debuggede
10:15:10 <xinming> ski_: yes,
10:15:29 <TuringTest> The precedence of $ is set so that it helps reduce the number of required parentheses.
10:15:40 <ski_> xinming : .. but, the monadic result of 'listen (return 1)' is just '(1,[])' .. the '[]' is the effect of this action (empty/trivial, in this case) ..
10:15:41 <xinming> ski: and pattern match will become (a,[]) which a = (1,[])
10:15:55 <HaskNoob> so basicly, if I understand, if I have a putStr or a putStrLn inside a then block, it better have a do... right?
10:16:00 <ski_> xinming : .. so '(a,w)' will be matched against '(1,[])'
10:16:03 <TuringTest> In C-code or Java-code you need braces when going from 1 to many commands.
10:16:07 <xinming> ??
10:16:16 <xinming> ... not understand. :-/
10:16:25 <ski_> xinming : so 'a' will be '1' and 'w' will be '[]'
10:16:38 <xinming> listen (W (a,w) = W ((a,w),w)
10:17:04 <ski_> yes (module typos)
10:17:19 <xinming> I just use W for short.
10:17:30 <ski_> listen (return 1) >>= \(a,w) -> ...
10:17:34 <xinming> type W = Writer :-P
10:17:36 <ski_> listen (1,[]) >>= \(a,w) -> ...
10:17:44 <ski_> ((1,[]),[]) >>= \(a,w) -> ...
10:18:41 <xinming> ah...
10:18:43 <xinming> thanks. :-)
10:18:56 <xinming> haskell is really an amazing language...
10:19:27 <HaskNoob> Is there something like map, except purely for the side effect?
10:19:33 <ski_> let (x,w0) = ((1,[]),[]); (b,w1) = (\(a,w) -> ...) x; in (b,mappend w0 w1)
10:19:54 <ski_> let x = (1,[]); w0 = []; (b,w1) = (\(a,w) -> ...) x; in (b,mappend w0 w1)
10:20:00 <lisppaste2> TuringTest annotated #14788 with "Works now" at http://paste.lisp.org/display/14788#1
10:20:07 <ski_> let (b,w1) = (\(a,w) -> ...) (1,[]); in (b,mappend [] w1)
10:20:25 <ski_> let (b,w1) = (let (a,w) = (1,[]) in ...); in (b,mappend [] w1)
10:20:28 <TuringTest> HaskNoob: I added a "sequence" command to do what you want, I think
10:20:35 <ski_> let (b,w1) = (let a = 1; w = [] in ...); in (b,mappend [] w1)
10:20:41 <ski_> xinming : etc
10:20:45 <TuringTest> HaskNoob: mapM would also work (as would mapM_ )
10:21:21 <xinming> ski: then, you can get the value... :-)
10:21:42 <TuringTest> HaskNoob: specifically "mapM_ putFact (n:ns)"
10:21:50 <xinming> ski_: by the way, why not make Reader Writer and State Monad in one big Monad?
10:21:59 <HaskNoob> ok
10:22:19 <ski_> @index RWS
10:22:20 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
10:22:34 <xinming> ...
10:22:43 <ski_> xinming : there ..
10:23:18 <HaskNoob> Thanks TuringTest 
10:24:40 <ski_> (HaskNoob : if you want several monadic actions after each other, then use 'do' (or '(>>)' or '(>>=)'), otherwise it's not needed)
10:25:01 <HaskNoob> hmm
10:25:26 <HaskNoob> i havent learned about >> or >>= yet
10:26:11 <xinming> HaskNoob: go ahead, It's interesting.
10:29:28 <ski_> @type do putStrLn "foo"; putStrLn "bar"
10:29:29 <lambdabot> IO ()
10:29:35 <ski_> @type putStrLn "foo" >> putStrLn "bar"
10:29:36 <lambdabot> IO ()
10:29:50 <xinming> ski_: So, for (a,w) <- listen, the return a will result a pattern match, right?
10:29:51 <ski_> @type do s <- getLine; putStrLn (reverse s)
10:29:52 <lambdabot> IO ()
10:30:01 <ski_> @type getLine >>= \s -> putStrLn (reverse s)
10:30:02 <lambdabot> IO ()
10:30:25 <ski_> xinming : 'return a will result a pattern match' means ?
10:32:56 <xinming> hmm, I mean for listen, It's a bit like, `do a <- listen( return 1); ' here, a will become (value, log), and (a,w) will pattern match the monadic value a, right?
10:33:02 <HaskNoob> i'll be back later, thanks for the help everyone
10:34:08 <ski_> yes .. except 'a' is not a monadic value, in either of those two cases
10:34:39 <ski_> in first case, 'a' is the result of the monadic action .. you can call it monadic result ..
10:34:40 <xinming> hmm, yes, It's a value
10:35:24 <xinming> then, what's the monadic value. :-/
10:36:17 <xinming> I know everything here is monadic action,
10:37:18 <ski_> this is a terminology question
10:37:47 <xinming> hmm, I think I should learn more to ask this. :-)
10:37:50 <xinming> thanks,
10:37:57 <ski_> 'listen (return 1)' Writer-action 
10:38:20 <ski_> this monadically returns a result '(1,[])'
10:39:30 <xinming> then, this result is the monadic value?
10:40:08 <ski_> @type [Control.Monad.Writer.listen (return 1),Control.Monad.Writer.tell "abc"]
10:40:09 <lambdabot>   Couldn't match `(a, w)' against `()'
10:40:09 <lambdabot>   Expected type: m (a, w)
10:40:19 <ski_> er, right
10:40:52 <ski_> anyway
10:41:06 <ski_> i haven't seen 'monadic value' used so often ..
10:41:38 <ski_> when i hear it, i think of the value of the monadic action (i.e. *not* the 'monadic' value of that action)
10:42:07 <ski_> > return 1 `mplus` return 2 :: Just Int
10:42:08 <lambdabot>  Not in scope: type constructor or class `Just'
10:42:13 <ski_> > return 1 `mplus` return 2 :: Maybe Int
10:42:15 <lambdabot> Just 1
10:42:30 <ski_> this is a Maybe-action
10:42:56 <ski_> i'd say that 'return 1 `mplus` return 2' is an action that evaluates to the monadic value 'Just 1'
10:43:09 <ski_> and, the monadic result of this action (in the Maybe monad, of course) is '1'
10:43:23 <ski_> xinming : do you understand the distinction i'm trying to make 
10:43:25 <ski_> ?
10:43:35 <xinming> > return "1" `mplus` return "2" :: []
10:43:36 <lambdabot>   `[]' is not applied to enough type arguments
10:43:36 <lambdabot>   Expected kind `?', but `[]' has kind `* -> *'
10:43:36 <lambdabot>   In an expression type signature: []
10:43:43 <xinming> > return "1" `mplus` return "2" :: [Char]
10:43:44 <lambdabot> Couldn't match `Char' against `[Char]'
10:43:52 <ski_> > return "1" `mplus` return "2" :: [String]
10:43:53 <lambdabot> ["1","2"]
10:44:27 <ski_> on one hand, we can compute/evaluate monadic actions down to values (sometimes this evaluatoin might hang)
10:45:01 <ski_> on the other hand, we can use '(>>=)' to get the monadic result of these actions (this usually implies evaluating the actions at least to some extent)
10:45:08 <xinming> ski_: hmm, I think I can, monadic value is a bit like `Type value' which is now we used,
10:45:37 <ski_> as i use it, 'monadic value' is just the (normal) value of an expression which happens to be a monadic action
10:45:41 <xinming> and the monadic action, does include all of those `Other value'
10:46:14 <ski_> while, 'monadic result' (or 'monadically returned value') is the thing that '(>>=)' will pass to it's right argument
10:46:46 <TheHunter> @index nelem
10:46:47 <lambdabot> bzzt
10:46:53 <ski_> > (return 2 `mplus` return 3) >>= \n -> return (n,n*n) :: Maybe (Int,Int)
10:46:54 <lambdabot> Just (2,4)
10:47:08 <ski_> > do n <- (return 2 `mplus` return 3); return (n,n*n) :: Maybe (Int,Int)
10:47:09 <lambdabot> Just (2,4)
10:47:15 <ski_> > (return 2 `mplus` return 3) >>= \n -> return (n,n*n) :: [(Int,Int)]
10:47:16 <lambdabot> [(2,4),(3,9)]
10:47:21 <ski_> > do n <- (return 2 `mplus` return 3); return (n,n*n) :: [(Int,Int)]
10:47:22 <lambdabot> [(2,4),(3,9)]
10:47:29 <ski_> 'n' there is the monadic result
10:47:30 <Cale> I would say that a monadic action is any value of type m a for some Monad m.
10:47:38 <ski_> right
10:48:05 <astrolabe> @type length
10:48:05 <lambdabot> forall a. [a] -> Int
10:48:30 <ski_> except, not all expressions terminate, and one might want to call an expression 'monadic action' without knowing whether it will terminate or not
10:49:00 <ski_> it's not a very important distiction, if at all, anyways
10:49:51 <xinming> ski_: I think I understand now.
10:50:39 <ski_> the important distictoin here is 'monadic action' versus 'monadic result/return value'
10:50:56 <ski_> if first has type 'm a', then second has type 'a'
10:52:32 <xinming> hmm, In my understanding, It would be, first has m a, But it need to be passed to next function, the second will be the final result.
10:52:50 <ski_> yes
10:53:39 <ski_> @type \(action :: m a) -> action >>= \(result :: a) -> return ()
10:53:40 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m ()
10:53:47 <xinming> by the way, some one said, that haskell is as fast as C++, But... for a "hello, world" program, It's really big after compiled into binary
10:54:20 <mnz> how can I generate a random integer in haskell, between 2 values
10:54:23 <ski_> includes full run-time
10:54:42 <ski_> @index randomRIO
10:54:42 <lambdabot> System.Random
10:54:55 <ski_> @type System.Random.randomRIO
10:54:56 <lambdabot> forall a. (System.Random.Random a) => (a, a) -> IO a
10:55:13 <mnz> cheer!
10:55:19 <xinming> ski_: hmm, is there a way to compile it without compile all libs into a binary?
10:55:21 <ski_> do ...; n <- randomRIO (0,9); ..n..
10:55:24 <xinming> for ghc
10:55:34 <ski_> xinming : hm, possibly
11:15:54 <TheHunter> does anyone have experiences with Language.Haskell.Syntax
11:17:21 <TheHunter> pointless> 1 + 2 * 3
11:17:21 <TheHunter> Your expression:
11:17:21 <TheHunter> (1 + 2) * 3
11:18:37 <TheHunter> @pretty 1 + 2 * 3
11:18:37 <lambdabot> "Parse error" at column 10
11:18:42 <TheHunter> @pretty x = 1 + 2 * 3
11:18:43 <lambdabot>  x = 1 + 2 * 3
11:20:29 <TheHunter> does Lemmih's ghc-parse treat fixities correctly?
11:22:16 <Igloo> They're done after parsing by ghc, so possibly not
11:22:40 <Igloo> You need to have import info to do them right, of course
11:24:23 <pesco> Greetings, Haskell-manglers.
11:25:44 <TheHunter> ok, thanks, so @pl's parser will stay what it is now.
11:26:18 * araujo throws lambdas in all directions
11:27:07 * pesco ducks behind a type signature.
11:27:37 <TheHunter> it's a shame tho, that there's no function |fixFixities :: FixityInfo -> HsModule -> HsModule| or similar.
11:33:38 <pesco> I've been toying around with making a LaTeX-like _structural_ markup language... My idea is to make it so that "macros become functions" and a document is mapped directly to a corresponding haskell expression. Declaring types for the available functions corresponds to XML Schema and friends, and supplying an implementation for the functions is analogous to, say, either DOM or XSLT (depending on the resulting type).
11:34:06 <Cale> pesco: have you seen lout?
11:34:21 <Cale> I'm not sure if that's related
11:34:30 <pesco> Cale: No, haven't heard of it.
11:34:52 <Cale> http://snark.niif.spb.su/~uwe/lout/lout.html
11:35:06 <pesco> Ah, thanks.
11:35:17 <Cale> I wish it used TeX as a backend. :)
11:37:24 <Cale> Currently the mathematics output looks odd to me. It's in the details, so it's hard to say exactly, but the spacing seems off.
11:44:14 <goron> I am compiling ghc, but it seems make it's in an infinite loop (constant 99% CPU usage). Any way to get some information on whatever it's doing?
11:44:50 <pesco> Cale: It appears that lout puts its emphasis on the actual typesetting. I was hoping to be more abstract, i.e. structural, like XML.
11:45:15 <pesco> Cale: Although, I might just be mistaken about lout.
11:45:46 <xinming> where is the Monoid class located?
11:45:56 <pesco> Anyway, I was going to ask if anyone was interested in my project?
11:46:24 <Philippa_> er. It vaguely reminds me of the stuff I'm battling with extensible wiki parsing
11:46:38 <xinming> found it. :-)
11:46:42 <Philippa_> I'm trying to avoid using hs-plugins though, which is part of what makes it a hard task
11:46:43 <pesco> Philippa_: Oh, please elaborate.
11:46:53 <Cale> pesco: I'm not sure (re lout) -- I had the idea that it was indended to handle things up to the document-structure level. Certainly something like LaTeX is programmable in lout
11:46:55 <pesco> Hm.
11:47:23 <Cale> But perhaps the implementation is currently at the TeX level of concern
11:47:28 <pesco> Cale: I might be mistaken, have just skimmed the first 10 or so pages of the design doc.
11:47:50 <Cale> hey Philippa -- where should we create a page? I don't think I have access rights on TMR wiki
11:48:08 <pesco> Cale: But I hate '@' as the command character, anyway. :-P
11:48:20 <pesco> (I'm such a nitpick.
11:48:20 <pesco> )
11:48:46 <Cale> xinming: Data.Monoid
11:49:14 <Philippa_> Cale: I can sort that out for you
11:54:40 <Lor> Agh, there are phd studentships at edinburgh. Tempting, tempting...
11:54:44 <xinming> Cale: thanks
11:55:01 <Lor> There's a huge list of projects there, and the very last one is links...
11:56:41 <sieni> Lor: Is your study leave getting longer? :-)
11:57:11 <Lor> I was just wondering myself... :)
11:57:31 <Lor> The thing is, I've always thought that if there's one place where I _want_ to go do a PhD, it's Edinburgh.
11:57:37 <Lor> Ever since Wadler returned there.
11:57:55 <Lor> And now out of the blue there's an advert for studentships.
11:58:52 <sieni> Lor: In that case I think you should (try to) go there, since otherwise you'll probably regret not going there later
12:01:49 <goron> :( the ghc build *is* in a loop....  
12:07:22 <Cale> goron: how does that happen?
12:08:16 <goron> Cale: I don't know, I did autoreconf and ./configure <with a pile of options> and make. 
12:08:33 <goron> Cale: I think it's a bug in Make.
12:08:57 <goron> Cale: since gg% CPU usage is almost impossible in real compilations with make.
12:09:02 <goron> er 99
12:09:19 <Cale> odd
12:09:20 <goron> Cale: make just calls stuff normally. 
12:09:58 <goron> I already tried make clean. But that didn't help.
12:10:13 <goron> I think I will get myself a new make.
12:10:44 <jethr0> Philippa_: apart from sorting it out for cale... i've had trouble creating a page on tmr, too. is it generally disallowed to create pages?
12:11:04 <goron> Cale: does GHC also compile with BSD make?
12:11:08 <Philippa_> you need an account and admin rights or similar, yeah
12:11:17 <Philippa_> it's not supposed to let random people create pages
12:11:26 <jethr0> hmm
12:12:16 <goron> I already have the latest version of make :(
12:13:14 <Saulzar> are you talking 99% ghc usage or 99% make usage?
12:13:22 <goron> Saulzar: gg% make usage.
12:15:41 <pediddle> goron: lol, are you writing this on a tablet pc or something?
12:16:21 <goron> pediddle: You mean with the "gg"? I think my fingers were close ;)
12:26:24 <xinming> >  runReader(do { y <- liftM (\x ->3) ; return}) 8
12:26:25 <lambdabot> Couldn't match `Reader r' against `(->) (m a1)'
12:26:31 <xinming> where did I wrong?
12:27:30 <xinming> s/did/was/
12:27:32 <ski_> runReader(do {y <- liftM (\x -> 3) (...); return (...)}) 8
12:27:42 <ski_> you need to give those two parts
12:28:15 <ski_> @type liftM
12:28:15 <lambdabot> Not in scope: `liftM'
12:28:22 <ski_> @type Control.Monad.liftM
12:28:23 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:29:15 <ski_> > runReader (do {y <- liftM (\x -> 3) ask; return (y,y * y)}) 8
12:29:16 <lambdabot> (3,9)
12:31:19 <xinming> ski_: Is there a way to let lambdabot read give the function implemention?
12:31:26 <xinming> lambdabot: listcommands
12:31:36 <xinming> lambdabot: @listcommands
12:31:36 <lambdabot> use listcommands [module|command]. Modules are:
12:31:36 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
12:31:36 <lambdabot> help hoogle karma localtime more pl plugs poll pretty quote search seen
12:31:36 <lambdabot> spell state system todo topic type version vixen where
12:31:54 <xerox> xinming: which function?
12:34:15 <xinming> liftM
12:34:38 <ski_> @index liftM
12:34:38 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
12:34:38 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
12:34:38 <lambdabot> Control.Monad.Error, Control.Monad.List
12:34:46 <ski_> @libsrc Control.Monad
12:34:47 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
12:35:04 <xerox> Right.
12:35:51 <ski_> we had some command that could paste impls of functions (at least ones in Prelude)
12:36:09 <ski_> but it seems to be no more
12:37:43 <xerox> get-definition ?
12:37:58 <ski_> no
12:37:59 <xerox> Evil idea.
12:38:05 <xerox> @. pl code
12:38:07 <ski_> that's lambacalc
12:38:15 <ski_> heh
12:38:32 <xerox> @compose pl code
12:38:46 <xerox> Hmm, dons unloaded it?
12:38:57 <xerox> @compose id arr
12:39:10 <xerox> @compose id eval 1
12:39:23 <xerox> @compose eval 1
12:39:26 <xerox> Okay.
12:39:30 <xerox> @help compose
12:39:37 <xerox> @yow
12:39:46 <xerox> Boom?
12:40:13 <ski_> hmm
12:40:20 <xerox> I'm sorry!
12:40:27 <ski_> @hello
12:40:32 <xerox> @botsnack
12:40:41 <greenrd> I am reading about WASH, and I see the ## monadic operator, which is kind of like >>
12:40:54 <greenrd> Is the ## operator something that exists elsewhere, or only in WASH?
12:41:07 * ski_ hasn't seen it
12:41:12 <ski_> so, prolly only in WASH
12:48:46 <xinming> runReader(do { return 1; local (\x -> x + 5) (do { v <- ask; if v > 10 then return 3 else return 4 })) 8
12:48:51 <xinming> where I did wrong? :-/
12:49:14 <xinming> oops, I know.
12:49:15 <xinming> sorry
12:52:18 <ski_> (missing '}', yes)
12:54:25 <goron> Cale: Do you have any hint of how I can get ghc to compile?
13:20:51 <jimapple> @seen lennart
13:21:20 <jimapple> @type id
13:21:45 <jimapple> What's with lambdabot?
13:21:56 <ski_> 'lennart has been idle 2hrs 45mins 56secs, signed on Sun Dec 18 19:35:15'
13:22:59 <moonlite> is this correct haskell: "import Base.Module (func,(<<),func1)" ?
13:23:16 <xerox> Possibly?
13:23:40 <jimapple> did you ask GHC or Hugs?
13:24:06 <moonlite> well. it says that << isn't in scope
13:24:17 <moonlite> so i figured it was some other syntax.
13:25:13 <Saulzar> Perhaps you can't import << if it doesn't exist
13:25:50 <moonlite> doh
13:26:06 <moonlite> im sorry. i had forgotten to remove "qualified"
13:26:15 <moonlite> that's pretty stupid
13:27:55 <jethr0> that's extreme... Yi has 12000 pure lines of haskell code and PUGS has 17000
13:28:09 <jethr0> i'd have guess Yi way lower on that!
13:29:41 <jethr0> frag (the game) has 16000
13:29:52 <Saulzar> Hmm, heavyweight
13:30:12 <Pupeno> What is/is not an expresion exactly ? (dealing with "The last statement in a 'do' construct must be an expression")
13:30:14 <Saulzar> What do you mean "pure" (Non IO?)
13:30:26 <Heffalump> Pupeno: foo <- bar isn't an expression
13:30:28 <jethr0> yup, and frag's quite deeply nested, whereas the pugs code is really nice and short
13:30:37 <jethr0> Saulzar: no comments no whitespace, sorry for the bad term
13:30:42 <Heffalump> neither is let foo = bar
13:30:47 <Pupeno> Heffalump: I got that part, is return () an expresion ?
13:30:48 <Saulzar> Ahh, that is big then...
13:30:50 <Heffalump> yes
13:30:59 <Heffalump> you probably have your indentation wrong if it doesn't like that either
13:31:09 <jethr0> pugs is _extremely_ well documented. maybe even too much
13:31:14 <Heffalump> an expression is anything you can give a free-standing type to
13:31:18 <Philippa_> something like pugs has to be
13:31:29 <Saulzar> Frag seems to have a lot of crazy code :)
13:31:33 <Pupeno> I'll paste the code.
13:31:43 <Pupeno> lisppaste2: url
13:31:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:31:48 <Philippa_> I'm extremely bad at getting round to commenting it when I do something deep/interesting/confusing in my code
13:32:03 <pesco> Philippa_: What was that wiki problem you are struggling with?
13:32:08 <jethr0> yes, but in the files i looked at, the ratio was like 3:1 code to comments. and this is for short (<20 lines) function with good names, etc
13:32:10 <Philippa_> Flippi's plugin model confused the hell out of shapr until he realised I was effectively doing AOP at one point
13:32:12 <jethr0> but i'm not complaining :)
13:32:23 <Philippa_> jethr0: short functions can still be incredibly complex
13:32:25 <lisppaste2> Pupeno pasted "How do I do this but right ?" at http://paste.lisp.org/display/14796
13:32:30 <jethr0> true
13:32:50 <Philippa_> pesco: it's more a dealing with lots of bits of code that don't know anything about each other problem
13:32:55 <pesco> @wtf aop
13:33:05 <Heffalump> oh, you shouldn't use let ... in with do like that
13:33:11 <Philippa_> Aspect Oriented Programming, Another Overblown Parasite ;-)
13:33:20 <pesco> :)
13:33:21 <jethr0> but i'm amazed at the code quality of pugs (at first glance). only two files in main directory longer than 400 lines.
13:33:36 <lisppaste2> Heffalump annotated #14796 with "corrected code" at http://paste.lisp.org/display/14796#1
13:33:47 <xinming> http://changelog.complete.org/node/265
13:33:55 <xerox> jethr0: agreed
13:34:08 <Heffalump> Pupeno: except in Haskell the hook points would have to be explicit
13:34:20 <xinming> someone get the same feeling as me. Says that haskell is easy to understand follow the book, and forgotten at the end.
13:34:32 <Pupeno> Heffalump: oh! I forgot there's no "in" on a do. Thanks.
13:34:57 <Saulzar> xinming, Same with anything, only way you really understand is by practice
13:35:06 <Heffalump> the error message was quite poor
13:35:51 <Philippa_> yeah, otherwise things're only easy when you're really doing the same as you've ever done
13:36:20 <Heffalump> s/Pupeno/Philippa_/ above when talking about hook points # doh
13:36:56 <jethr0> hehe, AOP would be another Template Haskell feature :)
13:37:34 <Philippa_> Heffalump: yeah, they are indeed
13:37:40 <Pupeno> xinming: I agree with you but I also agree with Saulzar.
13:37:42 <Philippa_> but frankly I consider that an improvement
13:37:44 <Heffalump> jethr0: yeah :-)
13:37:55 <Heffalump> Philippa_: it stops it really being AOP, I think.
13:38:00 <Heffalump> Though it's an ill-defined term.
13:38:06 <Philippa_> I think it does for most of the common definitions
13:38:16 <jethr0> it would actually be really easy! take your code walker, give it a function with all hooks and let TH insert hooks for functions while walking the AST...
13:38:18 <Philippa_> but cf duck typing and type classes. It's certainly closer to AOP than anything else
13:38:49 <Philippa_> I think the current typical definition of AOP has a lot to do with the advocates not wanting to deal with the statically-well-founded cases
13:38:56 <Philippa_> (that, and wanting to sell Java extensions)
13:39:58 <sdjp> I thought that threading the computation through a monad got you the majority of the benefits of AOP anyway:?
13:39:59 <greenrd> What do you mean by "statically-well-founded cases"?
13:40:38 <jethr0> sdjp: well, if you write a monad for any application of AOPs and combine them...
13:40:39 <Philippa_> sdjp: not always. You don't always want a monadic interface, and sometimes you want to do AOP on something that's plain IO or something
13:41:00 <greenrd> sdjp: You have to rewrite your code to use a monad, sometimes. in some cases where you can just use liftM or whatever
13:41:02 <jethr0> but switching a feature on by function name, or similar, might be hard, no?
13:41:19 <Philippa_> greenrd: a Haskellised form of AOP does things like leave the weaving process extremely well-founded, and generally doesn't screw up static guarantees as much as Java-based AOP typically does
13:41:29 <Philippa_> sloppy phrasing on my part though
13:41:49 <jethr0> hey cale
13:42:02 <Cale> hi
13:42:04 <Philippa_> jethr0: slap a runMyTranformer $ around the rest of the function. But yes
13:42:35 <jethr0> Philippa_: i think i'm gonna implement sth of the kind in TH right now :)
13:43:05 <jethr0> we'll see how far i'm gonna come :)
13:43:41 <jimapple> @type f (g,h) (x,y) = (g x, h y)
13:43:51 <jimapple> @pl f (g,h) (x,y) = (g x, h y)
13:43:58 <Heffalump> @type \ (g,h) (x,y) -> (g x, h y)
13:44:10 <ski_> lambdabot's sleeping
13:44:23 <Philippa_> jethr0: IMO the alternatives're more interesting
13:45:00 <Philippa_> monads+transformers+type classes give you one way to find join points, another fun one involves faking a more complete module system via records and building a transformer stack on that
13:45:02 <jethr0> Philippa_: for one i'm probably not gonna implement a whole AOP, and for another it'll be _very_ little code if i'm correct. just fooling around :)
13:45:31 <Philippa_> fair enough
13:49:18 <jethr0> Philippa_: _plus_ i haven't understood a way of what you said *g*
13:56:07 <Philippa_> jethr0: Define some set of functions that you want to be join points...
13:56:17 <Philippa_> jethr0: build a record whose fields are those functions
13:56:58 <Philippa_> build a record type with a function field for every field in the previous record that takes one of those functions as a parameter and returns another
13:57:36 <jethr0> yes, but that doesn't sound very runtime-ey to me...
13:58:00 <Philippa_> I don't recall runtime being a big part of AOP in the stuff I've read about it
13:58:18 <Philippa_> but in case that bothers you, follow the next few steps and you'll find the obvious bit to screw with at runtime
13:58:21 <jethr0> no, neither have i, but monads+transformers+type sound like runtime features
13:58:29 <jethr0> ok
13:58:50 <jethr0> type classes, but please continue
13:58:52 <Philippa_> though yes, you can do it a different way with monads + transformers + type classes
13:59:14 <Philippa_> (where the typeclass takes the role of the first record type, the monad the role of the first record and the transformers the role of the transformer records)
13:59:29 <jethr0> aahh
13:59:54 <Philippa_> now, build a stack of transformer records. You can just keep a list of them and fold a concatenation function along them, if you like
14:00:04 <Philippa_> this is the bit you can frig with at runtime if you want to build the mechanism to...
14:00:13 <Philippa_> apply the resulting stack to the original record to apply your advice
14:00:19 <Philippa_> (each transformer record is a piece of advice)
14:00:33 <Philippa_> the resulting record can then be used as the code to actually run
14:01:15 <Philippa_> you can build that resulting record in an input-independant manner if you want, in which case it can be statically known. Or you can shove it in a monad's state somewhere if you want as part of some kind of object model...
14:01:30 <jethr0> and you find that nicer than walking the tree and inserting by name (at least for "enter" and "leave")? call would be harder, though
14:01:31 <Philippa_> Flippi does the former with the IO API for its page database
14:01:55 <Philippa_> I find it much nicer being able to trace through WTF happened when something goes wrong :-)
14:01:58 <jethr0> hmm, cool. i'll have a look at the flippy code then
14:02:13 <Philippa_> only the version in the repo does that atm. It's badly commented I'm afraid
14:02:20 <jethr0> let's see how far i come before i give up ^_^
14:02:31 <Philippa_> but it lets you do things like add an edit history as a plugin, which is cool
14:02:38 <jethr0> np, i can handle _good_, uncommented code :)
14:02:49 <Philippa_> it's, er, idea-heavy
14:03:11 <jethr0> i don't even know what that means... does it mean dense or erratic?
14:03:23 <Philippa_> it means the ratio of interesting concepts involved:code is high
14:03:24 <ski_> @where flippi
14:03:29 <Philippa_> for values of 'interesting' that may break brains
14:03:36 <Philippa_> www.flippac.org/projects/flippi at the mo
14:03:52 <Philippa_> shapr's supposed to be setting up a repo and taking the role of maintainer at some point, but he's been busy
14:03:54 <jethr0> ah, i'll just do a little TH messing and look at it later, but thx
14:04:08 <jethr0> yes, and he's not been showing himself in here for a while
14:04:15 <Heffalump> how usable is it?
14:04:24 <Philippa_> the wiki, or the plugin model?
14:04:41 <ski_> Philippa_ : repo ?
14:04:47 <Heffalump> both
14:04:54 <ski_> hm
14:05:03 <Philippa_> the wiki's a bit too feature-light at the moment
14:05:37 <Philippa_> there's a plugin that does version history but I've not written a way of viewing it and reverting changes yet for example
14:05:47 <Philippa_> the plugin model is usable if you understand it
14:06:03 <Philippa_> though it's nowhere near ready to be finalised for a 1.0 version yet
14:06:20 <Philippa_> the parsing stuff's got a lot of places it could go, for example
14:06:20 <Pupeno> does anybody know where can I read a simple example of how Network.Socket is used ?
14:06:34 <Philippa_> it's used much as per the equivalent C functions
14:06:44 <Philippa_> look up "BSD sockets"
14:07:32 <Philippa_> shapr's written a plugin or two in developing FLM
14:08:45 <Pupeno> Philippa_: I have an example in C using BSD sockets and I have trouble translating it to Haskell, particulary how MkSocket is used (what are the first and last parameters ?, why doesn't I get a Socket)
14:09:12 <Philippa_> Pupeno: ah. I have to admit, I tend to just use Network
14:09:39 <Pupeno> Philippa_: yes, it's easy and handy, I've used it, but I need UDP as well as TCP.
14:10:38 <Pupeno> maybe MkSocket is not for general use.
14:27:24 <Pupeno> Network.Socket.socket AF_INET Stream 13 says "*** Exception: socket: unsupported operation (Socket type not supported)". What does it mean ? Stream (TCP) not suported ?
14:28:24 <basti_> hmm
14:29:16 <basti_> what socket type are you trying to open?
14:29:29 <Pupeno> (of course Datagram gives me the same error).
14:29:48 <Pupeno> basti_: type ? IP, TCP and UPD, port 13.
14:30:33 * basti_ tries a similar stunt
14:32:48 <basti_> are you on windowsß
14:32:48 <basti_> ?
14:32:51 <xinming> @index fmap
14:33:01 <Pupeno> basti_: no, Linux.
14:33:23 <xinming> @type fmap
14:33:35 <xinming> how to get the definition of fmap?
14:33:49 <basti_> how do i get the protocol number Pupeno?
14:33:57 <basti_> or, "a" protocol number
14:34:09 <basti_> xinming: well you thought right, lambdabot seems stoned though
14:34:25 <Pupeno> cat /etc/protocols I imagine.
14:34:30 <Pupeno> 0 is IP
14:34:36 <basti_> there ought to be some mechanism
14:34:39 <Pupeno> 17 is UDP
14:35:31 <Pupeno> basti_: there's a function in C to convert from strings to protocol numbers, but it's not available on Network.Socket (that's the first thing that made though that MkSocket is not for general consuption)
14:36:04 <Pupeno> man getprotoent
14:36:07 <basti_> yup
14:36:16 <lennart> getprotobyname
14:37:03 <Philippa_> constants for IP, UDP and TCP would be nice
14:37:36 <basti_> Program error: user error (socket: Address family not supported by protocol)
14:37:44 <musasabi> Philippa_: you can just use 0, and it should work.
14:37:49 <basti_> ^^
14:38:11 <musasabi> (0 is the default protocol)
14:38:21 <basti_> well with AF_INET it doesnt break anymore
14:39:33 <basti_> it doesn't connect anywhere either
14:41:00 <basti_> something is wrong with my IP
14:43:24 <basti_> the program ends up connecting to the wrong ip
14:43:27 <basti_> ah
14:46:35 <basti_> I can connect to my http server
14:46:46 <basti_> a <- socket AF_INET Stream 0
14:46:53 <basti_> Pupeno: thats what i'm doing
14:47:34 <Pupeno> oh! the last parameter is protocol number, not port number, silly me, thanks basti_.
14:47:57 <basti_> Main> main
14:47:57 <basti_> <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
14:48:02 <basti_> :D
14:48:11 * basti_ gently pat's Pupeno's head
14:49:02 <basti_> you didn't do that a lot?
14:50:02 <basti_> sockets and all i mean
14:50:16 <Pupeno> basti_: no.
14:50:35 <Pupeno> I did some sockets programming in C about 6 or 7 years ago.
14:50:36 <basti_> It's confusing first, i know, but it has a technical reason
14:50:41 <basti_> ow
14:51:57 <Pupeno> Would improvements to Network.Socket, particulary its documentation, be welcome ?
14:52:34 <basti_> hmm i think nobody would complain if you did that. You should try to talk to the ghc devels
14:52:50 <basti_> send an email or something
14:53:06 <basti_> there's version control, that'll make it pretty easy
14:59:58 <ski_> xinming : there is no *the* implementation of fmap
15:02:30 <basti_> d'oh.
15:02:39 * basti_ could have said that too, had he spent a thought
15:02:40 <Lor> Well, fmap f m = m >>= return . f
15:02:50 <Lor> That's "the" version if anything. :)
15:03:07 <Philippa_> can't be, though. Insufficiently generic still
15:03:22 <Lor> Yes, but it's the most generic you can get. :)
15:03:38 <Lor> It's liftM, of course.
15:09:18 <greenrd> Lor: You have it backwards. liftM = fmap always. ;) Or it would be, if Monad was a subclass of Functor, as it morally ought to be.
15:14:37 <jimapple> greenrd: are there any Monad instances that are not instances of Functor?
15:14:59 <Pupeno> basti_: do you still have your network example/tests ?
15:16:47 <Lor> jimapple, no, because you can (and should) always define fmap = liftM
15:17:15 <greenrd> jimapple, my point exactly :)
15:17:56 <basti_> Pupeno: sure
15:18:01 <basti_> lisppaste2: @url
15:18:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:18:03 <xinming> hmm, do you mean that fmap is deprecated ?
15:18:18 <greenrd> no, fmap is more generic than liftM
15:18:40 <greenrd> the name of liftM helps me remember what it does tho, so I still use it
15:18:41 <xinming> so, liftM will die?
15:18:54 <lisppaste2> basti_ pasted "networking example" at http://paste.lisp.org/display/14800
15:19:17 <basti_> Pupeno: there you go
15:19:31 <ski_> hopefully, in Haskell', liftM, if defined, will be defined as 'liftM = fmap' (and Functor be a superclass of Monad)
15:19:34 <Pupeno> Thankyou.
15:20:29 * xinming wonders, why there are two names of a function only do one thing without any difference.
15:21:09 <ski_> fmap is more general than liftM
15:21:29 <astrolabe> why isn't functor a superclass of monad?
15:21:31 <ski_> but, when both applies, they are (should be) the same
15:22:03 * ski_ also wonders why
15:22:12 <Lor> Can the instance of superclass depend on the instance of the subclass?
15:22:14 <xinming> then, I would use fmap normally
15:22:27 <Lor> Because otherwise one would have to define fmap/liftM _manually_ without being able to use return and >>=.
15:22:32 <ski_> Lor : depend in which sense ?
15:22:43 <Lor> instance FMap M where fmap = liftM
15:22:46 <Lor> instance Monad M where ...
15:23:03 <ski_> yes, that's possible
15:23:41 <ski_> it would be interesting if one could provide defaults in a class definition, not for that class, but for superclasses
15:23:50 <Philippa_> yeah
15:24:28 <jimapple> Does anyone have handy instances of Functor that are not monads?
15:25:38 <ski_> someone mentioned queues .. (haven't thought through whether they can't be monads)
15:25:47 <_Codex> jim: maybe?
15:25:54 <Lor> It's a monad.
15:26:09 <_Codex> oh
15:26:11 <Lor> (A very handy monad, at that.)
15:26:33 <xs> for Data.x, instance Functor x where fmap = Data.x.map?
15:27:02 <jimapple> like Data.Map
15:27:09 <jimapple> I see
15:27:23 <basti_> night all
15:27:37 <basti_> Pupeno: good luck with networking... cu tomorrow
15:27:45 <Pupeno> thank you.
15:32:19 <xinming> type ParseMonad = Either ParseError
15:32:36 <xinming> so, there, ParseMonad will take one argument, right?
15:33:04 <xinming> because `Either' needs too argument. :-/
15:33:45 <Heffalump> xinming: yes
15:33:47 <xinming> and ParseError here can be pattern matched using (Left a),
15:34:50 <xinming> Heffalump: hmm, and so, if there is a function which will return ParseMonad, the return will default equal `Right'
15:34:53 <xinming> right?
15:37:35 <xinming> no one answer? :-/
15:38:34 <Saulzar> Right
15:40:22 <xinming> thank you all everyone, sleep time, will catch the Cont tommorow. 
15:40:32 * xinming waves&
15:44:56 <fnord123> hey all. im sure theres a lot of people in here who have a lot of pdfs and ps files. do you know any programs to organize them in osx?
16:03:25 <TuringTest> One of few useful feature of OS X 10.4 aka Tiger: it indexes inside pdf (and ps?) documents.  So I just use that spotlight search feature.
16:04:42 <Beelsebo1> fnord123: have to agree with TuringTest there... but I am writing a little program to organise them
16:04:44 <unsaved> not .ps out of the box, unfortunately, so now I convert all to .pdf for spotlight reasons.
16:04:49 <Beelsebo1> and keep an iTunes like database of them
16:04:56 <Beelsebo1> (along with bibtex entries etc)
16:05:17 <fnord123> ok
16:06:06 <fnord123> im not sure thats so useful for my work habits. i download loads of papers to the desktop and read most of them and every month of so, shovel them into my Articles And Papers directory
16:06:19 <fnord123> they all keep their titles like pts.pdf, heinze-lecture.pdf, etc
16:06:44 <fnord123> so when i look back over them to continue reading that interesting paper i have no idea which one it was and im always lost for keywords :P
16:10:07 <greenrd> fnord123, maybe citeulike.org would help, I dunno
16:11:00 <fnord123> greenrd: xoxo
16:11:10 <greenrd> actually the thing I like most about citeulike is how you can fortuitously discover cool papers by spying on what other people's reading lists, rather than any benefit for organisation
16:15:16 <fnord123> ok well now this is going to point me to MORE papers
16:15:25 <fnord123> so i have MORE need for organizing them :)
16:21:18 <fnord123> beelsebob_: which os are you writing for?
16:21:33 <beelsebob_> fnord123: 10.3 and later
16:21:53 <beelsebob_> well, actually, I'm considering making it 10.4 and later
16:21:58 <beelsebob_> because CoreData makes the task WAY easier
16:22:06 <fnord123> os x then. :D
16:22:09 <beelsebob_> yes
16:22:19 <fnord123> cool. add me as a contact pls and let me know how you get on
16:22:34 <fnord123> or leave :(
16:26:00 <fnord123> is there a note taking bot in here? id like to tell beelsebob_ that I'd like him to keep me informed on that project
16:32:30 <Pupeno> anybody using networking-alt ?
16:35:57 <dons> ask musasabi
16:38:55 <musasabi> I get some mails from time to time asking for help on specific issues.
16:39:34 <musasabi> I should really build some way to measure downloads / darcs gets so I would have some idea of the relative popularity of things
16:40:12 <dons> hackage!
16:40:17 <TheHunter> arg!
16:40:20 <TheHunter> @pl let x = y; y = z; z = w in x
16:40:20 <lambdabot> w
16:41:08 <musasabi> dons: I don't know how to automatize my workflow with hackage
16:41:33 <Pupeno> musasabi: Are you Einar Karttunen ?
16:41:40 <dons> hackage should provide satistics, one day, of what things are popular.
16:42:10 <Lor> Pupeno, are you familiar with /whois?
16:42:44 <Pupeno> Lor: yes, but most of the time there's nothing to see there, thanks.
16:43:01 <Lor> I was told some time ago that only Finns bother with realnames.
16:43:50 <musasabi> In finnish irc channels realname is part of common courtecy usually.
16:44:16 <Lor> imnsho, the only reason not to have a realname is if you really want to be anonymous.
16:44:53 <Lor> And if you connect directly from your own machine, you aren't...
16:45:14 <TheHunter> moin dons, do you know about any fixity-fixing code for Language.Haskell.Syntax?
16:45:27 <musasabi> Lor: doesn't that involve using a proxy chain and coming in from an innocent looking (DSL) address from a random country ;)
16:46:20 <Lor> Weell...
16:46:24 <dons> hmm, don't know of any, TheHunter.
16:46:46 <Lor> granted, dsl address are often rather opaque.
16:46:51 <Lor> +es
16:46:52 <dons> TheHunter, maybe you'd have to post process it?
16:47:06 <TheHunter> yes, definitely:
16:47:18 <TheHunter> pointless> 1 + 2 * 3
16:47:18 <TheHunter> Your expression:
16:47:18 <TheHunter> (1 + 2) * 3
16:47:31 <dons> cool.
16:47:50 <dons> have youu had a look at HaRe?
16:48:08 <dons> they have some interesting refactoring ideas.
16:48:09 <TheHunter> no
16:48:15 <Heffalump> post process what?
16:48:26 <dons> http://www.cs.kent.ac.uk/projects/refactor-fp/catalogue/RefacIdeasAug03.html
16:48:39 <TheHunter> the "parse tree" parseModule returns.
16:48:57 <Heffalump> how do you tell the difference between explicit parens and implicit ones?
16:50:05 <TheHunter> the parse tree contains all the explicit parens.
16:51:03 <Heffalump> ah, something else inserts the implicit ones later?
16:52:30 <dons> wouldn't that be a job for the ppr?
16:52:32 <TheHunter> yes, that's how ghc works at least. Unfortunately, Language.Haskell doesn't seem to support this second step.
16:53:05 <TheHunter> It's annoying.
16:53:26 <TheHunter> this is quite a list they have there...
16:55:25 <dons> do any of the there's more: http://www.cs.kent.ac.uk/projects/refactor-fp/catalogue/
16:55:36 <dons> s/.*there//
16:56:05 <jethr0> => 's more:
16:56:05 <dons> however, HaRe was difficult to build
16:56:42 <jethr0> how do you control HaRe? is there a GUI refactorer?
16:56:49 <dons> the custom haskell lexer they used took more than 20 mins to compile (without -O!)
16:56:55 <dons> it uses vim or emacs, iirc.
16:57:01 <jethr0> :)
16:57:04 <dons> @where hare
16:57:05 <lambdabot> I know nothing about hare.
16:57:24 <dons> @where+ hare http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
16:57:24 <lambdabot> Done.
16:57:35 <jethr0> haskell makes parsing so easy, that everyone writes his own parser for the haskell syntax :)(
16:58:04 <dons> writing parsers in haskell is certainly pretty easy.
16:58:10 <dons> parsec forever!
16:58:31 <dons> long live combinators!
16:58:40 <jethr0> yes, but there must be 4 or 5 standard parsers for the haskell syntax out there... what a waste
16:58:53 <_metaperl> haskell makes parsing so easy that autrijus wrote the Perl 6 parser using Haskell
16:59:02 <dons> quite amazing, really.
16:59:07 <dons> considering how hard the perl parser works.
16:59:08 <jethr0> and the code of pugs is even pretty to look at
16:59:11 <lisppaste2> HaskNoob pasted "YAHT, ex 4.6 & 4.7" at http://paste.lisp.org/display/14802
16:59:17 <HaskNoob> hey
16:59:46 <HaskNoob> I'd appreciate it if someone could look at my attempts here to do the exercises in the Yet Another Haskell Tutorial pdf..
16:59:47 <_metaperl> hey, does anyone know that trick with list comprehensions to express fibonacci numbers? Autrijus showed it in his slides awhile back
17:00:16 <jethr0> > fibs = 1:1:(zipWith (+) fibs (tail fibs))
17:00:16 <_metaperl> HaskNoob: buy Simon Thompsons book or use JHR's "Road to Logic , Mathsand Programming via Haskell"
17:00:17 <lambdabot>  parse error on input `='
17:00:20 <HaskNoob> on 4.7 it said use the Either type, and i didnt, not literally
17:00:24 <jethr0> > let fibs = 1:1:(zipWith (+) fibs (tail fibs)) in take 10 $ fibs
17:00:26 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
17:00:32 <_metaperl> the free haskell books are not very good
17:00:49 <HaskNoob> they're good enough for me, for now
17:00:53 <HaskNoob> thankyou
17:01:07 <_metaperl> jethr0: he did something like [ | x <- [1, 1] , y <- [2, ] ]
17:01:11 <_metaperl> I cant remember it
17:01:25 <jethr0> let fibs = [1,1] ++ [x + y | x <- fibs, y <- tail fibs] in take 10 $ fibs
17:01:29 <jethr0> > let fibs = [1,1] ++ [x + y | x <- fibs, y <- tail fibs] in take 10 $ fibs
17:01:30 <lambdabot> [1,1,2,3,4,5,6,7,8,9]
17:01:34 <jethr0> damn
17:01:34 <dons> pretty easy to ranslate a zip into a list comprehension..
17:01:52 <jethr0> no, that was stupidly wrong :(
17:01:56 <HaskNoob> Mainly its the second question, i'm not sure i'm answering it correctly
17:02:08 <HaskNoob> i posted the questions along with my answers
17:03:24 <jethr0> >  let fibs = 1:1:[x + y | (x,y) <- zip fibs (tail fibs)] in take 10 $ fibs
17:03:25 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
17:07:34 <dons> > take 10 . fix $ \f -> 1 : 1 : [ uncurry (+) x | x <- zip f (tail f) ]
17:07:35 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
17:07:54 <jethr0> dons, i wanted to do that, but it didn't fit the requirements :)
17:07:59 <Twigathy> > 1 + 1
17:08:00 <lambdabot> 2
17:08:07 <Twigathy> shiny :)
17:10:33 <Pupeno> When running a stream server (simple.hs of network-alt) I get the error "*** Exception: user error (no socket to listen on)". Any ideas what might be causing it ?
17:10:43 <dons> @pl \f -> 1 : 1 : [ uncurry (+) x | x <- zip f (tail f) ]
17:10:44 <lambdabot> (1 :) . (1 :) . return . ((uncurry (+) x | x) <-) . ap zip tail
17:11:09 <dons> hehe
17:11:11 <int-e> > take 10 $ fix ((1:) . scanl (+) 1)
17:11:12 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
17:11:31 <lispy> @type fix
17:11:32 <lambdabot> Not in scope: `fix'
17:11:39 <int-e> @type Control.Monad.Fix.fix
17:11:41 <lambdabot> forall a. (a -> a) -> a
17:12:23 <HaskNoob> Hey, TuringTest, you were really helpful and insightful when i asked a question here earlier. If you're still here and willing to take a look, I'd be grateful for whatever insights/tips/corrections if any, you might have on this latest post of mine http://paste.lisp.org/display/14802.. particularly the second portion.
17:13:13 <jethr0> int-e, that's pure evil.
17:14:13 <dons> @where+ darcsweb http://users.auriga.wearlab.de/~alb/darcsweb/
17:14:15 <lambdabot> Done.
17:15:15 <jethr0> int-e: how the hell did you come up with that fix solution? i can't even figure out why it works :)
17:16:06 <lispy> what is fix?
17:16:14 <lispy> i can't figure out what fix does
17:16:16 <dons> fix is fun
17:16:33 <Lemmih> fix f = f (fix f)
17:16:39 <dons> fix f = let x = f x in x
17:16:50 <dons> -- | @'fix' f@ is the least fixed point of the function @f@,
17:16:52 <dons> -- i.e. the least defined @x@ such that @f x = x@.
17:17:22 <jethr0> > take 10 $ fix (1:)
17:17:23 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
17:17:26 <HaskNoob> is @ a convention for irc, or is that haskell?
17:17:38 <lispy> > take 10 ((1:). scanl (+) 1)
17:17:39 <lambdabot>   Expecting a function type, but found `[a]'
17:17:39 <lambdabot>   Expected type: [a]
17:17:39 <lambdabot>   Inferred type: [b] -> [b]
17:17:43 <Heffalump> scanl (+) 1 [1,1,2,3]
17:17:52 <Lemmih> HaskNoob: It's Haddock syntax.
17:17:57 <Heffalump> > scanl (+) 1 [1,1,2,3]
17:17:58 <lambdabot> [1,2,3,5,8]
17:18:04 <HaskNoob> thanks Lemmih 
17:18:29 <int-e> jethr0: fix x is just a shorthand version to say let f = x f in f
17:19:10 <Heffalump> apparently fib n = 1 + sum [fib k | k <- [0..n-1]]
17:19:27 <Heffalump> which isn't immediately obvious to me, but once you know that, int-e's solution makes sense
17:19:37 <int-e> actually, 0..n-2 :)
17:19:41 <Heffalump> nearly :-)
17:19:52 <Heffalump> I can see how to prove it by induction, anyway.
17:20:01 <Heffalump> But not the intuition.
17:20:41 <HaskNoob> Is there a generic way to reduce Constructor x to simply x?
17:21:02 <dons> use 'case'
17:21:05 <ibid> case foo of Constructor x -> x
17:21:11 <jethr0> int-e: i know that, and i think i have figured it out now. but i still wonder how you figured it out :)
17:21:29 <ibid> but no, there is no way where you would not need to name the coonstructor
17:21:38 <HaskNoob> ok
17:21:39 <jethr0> it's like. if i have a function for fibonnaci, then i just have to scanl over it. but the first part seems the harder :)
17:22:32 <HaskNoob> I guess.. i'm kind of thinking of something like user defined type classes..
17:22:49 <HaskNoob> not sure if thats the right term
17:23:08 <int-e> jethr0: I think that's close to how I figured it out - I mean, look at how scanl is implemented.
17:23:22 <jethr0> true
17:24:06 <int-e> it's not that far from the usual zipWith version if you do that.
17:24:23 <int-e> the scanl just has the tail operation built into itself :)
17:25:03 <Heffalump> int-e: you really are using an algebraic property of fib
17:25:22 <Heffalump> there's no obvious generic way of making the version based on tail into this one
17:26:28 <int-e> Well, scanl f x l = let l' = x:zipWith f l' l
17:26:29 <int-e> :)
17:26:39 <int-e> Heffalump: I never said it was obvious
17:26:51 <Di-Fosfor> Good evening all. What technique would you suggest for passing around a bundle of functions?
17:27:04 <Heffalump> your scanl identity is missing an "in" clause
17:27:08 <Heffalump> Di-Fosfor: a record
17:27:16 <int-e> right. in l'
17:27:21 <Heffalump> data Foo = Foo { fun1 :: ... , fun2: .., ... }
17:27:46 <Di-Fosfor> Yeah, that's what I thought too
17:28:05 <Di-Fosfor> First tried using a class for it, but then figured out that wouldn't work :P
17:28:15 <Heffalump> it would actually
17:28:27 <Heffalump> you just have to pass around a dummy value
17:29:49 <Di-Fosfor> Hmm.. yeah.. still having a hard time understanding classes...
17:29:49 <Heffalump> int-e: ok, but you still have to do some reasoning with a tail and the 1: to get your clever version
17:30:03 <dons> a bit annoying when all you want is the dictionary. oh well.
17:30:10 <Heffalump> Di-Fosfor: I think the record solution is clearer, though.
17:30:28 <Di-Fosfor> Oki, thanks a bunch :)
17:32:03 * Heffalump embeds
17:35:22 <int-e> Heffalump: well, I remember that it first occured to me that scanl could be used to implement fibonacci numbers and then after a bit of trial and error and more thinking I found that solution. One intermediate try was:
17:35:25 <int-e> > take 10 $ Control.Monad.Fix.fix ((1:) . scanl1 (+))
17:35:26 <lambdabot> [1,1,2,4,8,16,32,64,128,256]
17:35:35 <int-e> which wasn't quite right ;)
20:06:30 <moonlite> are there any good language-references for haskell on the internet? Specifically i want the complete syntax for "import"
20:07:23 <Korollary> The Haskell Report?
20:07:59 <moonlite> thats way to verbose
20:08:06 <moonlite> too
20:08:26 <Korollary> Well, complete it is, though.
20:08:49 <moonlite> yeah ./
20:09:47 <Korollary> I suppose you're trying to do something within the ()'s ?
20:11:26 <Lemmih> moonlite: Section 5.3 of the report is quite concise.
20:58:00 <jethr0> @seen tuomov
20:58:01 <lambdabot> tuomov is in #haskell. I don't know when tuomov last spoke.
21:25:31 <jimapple> @pl f (g,h) (x,y) (g x, h y)
21:25:31 <lambdabot> f (g, h) (x, y) (g x, h y)
21:25:49 <jimapple> @pl f (g,h) (x,y) = (g x, h y)
21:25:49 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((
21:25:49 <lambdabot> .) . (,)) .))
21:26:10 <jimapple> wow that's awful
21:26:46 <jimapple> @ pl f x y = (y x, x y)
21:26:47 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
21:26:47 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
21:26:47 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
21:26:47 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
21:26:47 <lambdabot> fact-snoc fact-update foldoc fortune gazetteer get-shapr ghc google help
21:26:49 <lambdabot> [8 @more lines]
21:27:01 <jimapple> @pl f x y = (y x, x y)
21:27:02 <lambdabot> f = ap =<< ((,) .) . flip id
21:27:14 <jimapple> @type ap =<< ((,) .) . flip
21:27:15 <lambdabot> Not in scope: `ap'
21:27:26 <jimapple> @type Monad.ap =<< ((,) .) . flip
21:27:27 <lambdabot> forall a c.
21:27:27 <lambdabot> (Monad ((->) (a -> a -> c)), Monad ((->) a)) =>
21:27:27 <lambdabot> (a -> a -> c) -> a -> (a -> c, a -> c)
21:27:28 <Korollary> well, I find pointfree style analogous to compression. For some inputs, it will expand instead.
21:27:40 <jimapple> I like that analogy
21:30:14 <jimapple> Is Monad ((->) a) a valid instance?
21:31:24 <Pupeno> Why do I get "Warning: Pattern match(es) are overlapped In a case alternative: sockDgram -> ..." on "case prot of sockStream -> [...]^M sockDgram -> [...]" ?
21:32:11 <jimapple> do you need a ';'?
21:32:32 <Lemmih> Pupeno: 'sockStream' and 'sockDgram' are both variables.
21:32:41 <jimapple> @djinn b -> (a -> b)
21:32:42 <lambdabot> f a _ = a
21:32:50 <Lemmih> > case 10 of a -> (); b -> ()
21:32:50 <lambdabot>   Warning: Pattern match(es) are overlapped
21:32:50 <lambdabot>      In a case alternative: b -> ...
21:33:49 <jimapple> @djinn (x -> a) -> (a -> (x -> b)) -> (x -> b)
21:33:50 <lambdabot> f a b c = b (a c) c
21:34:16 <jimapple> so, there you go, I guess (-> (a)) is a monad
21:34:22 <jimapple> thanks, djinn!
21:34:38 <Pupeno> Lemmih: but the contents are different.
21:35:26 <jimapple> @type Monad.ap =<< ((,) .) . flip
21:35:27 <lambdabot> forall a c.
21:35:27 <lambdabot> (Monad ((->) (a -> a -> c)), Monad ((->) a)) =>
21:35:27 <lambdabot> (a -> a -> c) -> a -> (a -> c, a -> c)
21:35:31 <jimapple> @type Monad.ap
21:35:32 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:36:07 <jimapple> @type ($) =<< ((,) .) . flip
21:36:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = a1 -> a ->
21:36:08 <lambdabot> c
21:36:08 <lambdabot>   Expected type: (a1 -> a -> c) -> (a1 -> a -> c) -> b
21:37:09 <jimapple> @type (Monad.ap =<< ((,) .) . flip) const
21:37:10 <lambdabot> forall a.
21:37:10 <lambdabot> (Monad ((->) (a -> a -> a)), Monad ((->) a)) =>
21:37:10 <lambdabot> a -> (a -> a, a -> a)
21:37:33 <jimapple> @type (Monad.ap =<< ((,) .) . flip) const True
21:37:34 <lambdabot>   No instance for (Monad ((->) Bool))
21:37:34 <lambdabot>   arising from use of `Control.Monad.ap' at <interactive>:1:1-8
21:37:57 <jimapple> @type Monad.return
21:37:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
21:38:29 <jimapple> @type f x -> (\_ -> x)
21:38:30 <lambdabot> Parse error in pattern
21:38:43 <jimapple> @type f x = (\_ -> x)
21:38:44 <lambdabot> parse error on input `='
21:38:56 <jimapple> tyep const
21:38:59 <jimapple> @type const
21:39:00 <lambdabot> forall a b. a -> b -> a
21:39:12 <jimapple> sorry, ya'll, I'll take this offline
21:41:20 <jimapple> @pl \x y -> \z -> y (x z) z
21:41:22 <lambdabot> flip flip id . (ap .) . flip (.)
21:46:37 <jimapple> ok, I give up: why isn't ((->) a) a monad for all a?
21:49:29 <Korollary> That sounds like a language reference corner case question.
21:51:02 <Korollary> @kind ((->) a)
21:51:03 <lambdabot> Not in scope: type variable `a'
21:51:09 <Korollary> oops
21:51:34 <Korollary> well, ((->) a) is not a type constructor as is.
21:51:47 <Korollary> @kind ((->) Int)
21:51:48 <lambdabot> ? -> *
21:59:23 <Pupeno> how do I send eof to a Handle ?
21:59:54 <Korollary> I suppose closing it is equivalent
22:00:15 <jimapple> @kind ((->) Int Bool)
22:00:16 <lambdabot> *
22:00:30 <Pupeno> but I'd like to send an eof and go on reading (close only the writing part).
22:00:38 <jimapple> @kind (Data.Set)
22:00:39 <lambdabot> Couldn't find qualified module.
22:00:39 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
22:00:39 <lambdabot> \\)?
22:00:58 <jimapple> @kind Either
22:00:59 <lambdabot> * -> * -> *
22:01:02 <Korollary> @kind Data.Set.Set
22:01:02 <lambdabot> * -> *
22:01:10 <jimapple> @kind Either Int
22:01:11 <lambdabot> * -> *
22:01:35 <jimapple> so, why not ((->) Bool)?
22:02:24 <jimapple> is it just a syntax thing, like
22:02:24 <jimapple> @kind []
22:02:25 <lambdabot> * -> *
22:02:32 <jimapple> that works?!
22:02:42 <jimapple> @type ()
22:02:43 <lambdabot> ()
22:02:51 <jimapple> @kind ()
22:02:52 <lambdabot> *
22:03:00 <jimapple> @kind ((,))
22:03:01 <lambdabot> * -> * -> *
22:03:06 <jimapple> @kind (->)
22:03:07 <lambdabot> ?? -> ? -> *
22:03:16 <jimapple> wtf
22:09:14 <jimapple> @pl \x y -> (x y, y x)
22:09:15 <lambdabot> liftM2 ap ((,) .) (flip id)
22:11:59 <jimapple> @pl f x y = (y x, x y)
22:11:59 <lambdabot> f = ap =<< ((,) .) . flip id
22:12:17 <jimapple> @type liftM2 ap ((,) .) (flip id)
22:12:18 <lambdabot> Not in scope: `liftM2'
22:12:18 <lambdabot>  
22:12:18 <lambdabot> <interactive>:1:7: Not in scope: `ap'
22:12:27 <jimapple> Monad.liftM2 Monad.ap ((,) .) (flip id)
22:12:36 <jimapple> @type Monad.liftM2 Monad.ap ((,) .) (flip id)
22:12:37 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1) ->
22:12:37 <lambdabot> b
22:12:37 <lambdabot>   Expected type: (t -> t1) -> ((t -> t1) -> b) -> c
22:12:58 <jimapple> @pl \x -> \y -> (x y, y x)
22:12:59 <lambdabot> liftM2 ap ((,) .) (flip id)
22:13:17 <jimapple> @pl \f -> \x -> \y -> (x y, y x)
22:13:17 <lambdabot> const (liftM2 ap ((,) .) (flip id))
22:13:34 <jimapple> @type Monad.ap =<< ((,) .) . flip id
22:13:35 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a -> c)
22:13:35 <lambdabot>   Expected type: m a -> m (a -> b)
22:13:59 <jimapple> @type Monad.ap =<< ((,) .) . flip
22:14:00 <lambdabot> forall a c.
22:14:00 <lambdabot> (Monad ((->) (a -> a -> c)), Monad ((->) a)) =>
22:14:00 <lambdabot> (a -> a -> c) -> a -> (a -> c, a -> c)
22:14:15 <jimapple> WTF!
22:16:50 <jimapple> @pl f x = x
22:16:50 <lambdabot> f = id
22:16:57 <jimapple> @pl \x -> x
22:16:57 <lambdabot> id
22:22:23 <WebFound> yeah wtf?
22:24:10 <Pupeno> Is there an easy way to send and recieve datagrams with network-alt ?
23:49:47 <soysauce> does a UArray of Word16 take half the memory as a UArray of Word32?
23:51:04 <dons> I would say "yes"
23:51:12 <soysauce> except for?
23:53:11 <dons> except for nothing :)
23:53:17 <soysauce> oh
23:53:34 <soysauce> I ask because I have a large array -- 200x200, or 40.000 elements
23:54:10 <dons> it uses word 16 writes and reads underneath, so it must be 16 .
23:54:20 <soysauce> I don't know what sorts of overhead come with Haskell objects, although my understanding is that a UArray of Word16 is approximately equal to a short[] on platforms where short is 16-bits
23:54:23 <nnod> hi all, just a quick question for a haskell newbie, i'm trying to execute a shell command using 'system "pwd"' but when i 'import System (system)' i get a compile error saying the module System does not exist...can someone point me to the correct location of the system function?
23:54:46 <Lemmih> @index system
23:54:47 <lambdabot> System.Cmd
23:55:01 <soysauce> I suppose, actually, it is most equivalent to short[] in Java
23:55:07 <dons> it's the same, soysauce.
23:55:11 <soysauce> or such is my assumptionj
23:55:16 <soysauce> ok
23:55:43 <dons> since they're unboxed.
23:55:44 <Lemmih> nnod: But you might wanna use getCurrentDirectory instead of 'system "pwd"'.
23:55:49 <soysauce> yeah, that's what I had thought
23:55:58 <nnod> Lemmih: thanks, it was just for example
23:56:07 <soysauce> underneath the hood, UArray is going to use the primitive type, isn't it?
23:56:08 <nnod> lambdabot: thanks, that worked
23:56:19 <soysauce> hence 'unboxed'
23:56:30 <nnod> lemmih: what does @index do?
23:57:08 <soysauce> nnod - cross-reference of Haskell libraries... or something along those lines
23:57:17 <Lemmih> nnod: It tells you where an identifier is defined.
23:57:25 <soysauce> @hoogle a -> b -> a
23:57:26 <lambdabot> Control.Parallel.par :: a -> b -> b
23:57:26 <lambdabot> Control.Parallel.seq :: a -> b -> b
23:57:26 <lambdabot> GHC.Conc.par :: a -> b -> b
23:57:39 <Lemmih> dons: The help for @index isn't very good (:
23:57:57 * soysauce skips off to finishing this stupid homework
23:58:03 <nnod> thanks guys
