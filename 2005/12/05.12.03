00:28:06 <neologism> pls remind me... how do I quote comments in prolog?
00:29:13 <Cale> %
00:29:40 <neologism> oh thnx ;)
00:33:56 <hulahub> hey, i want to output each element of a binary tree in a Tupel (insert, height, etc. was easy) BUT - somehow i need to output the value - recursive call the output again on the left and the same on the right node - but im stuck - does anyone know any _good_ resources on this ?
00:36:39 <Cale> hulahub: what's the type of that tuple?
00:36:50 <Cale> perhaps you want a list?
00:49:05 <hulahub> Cale: ye right, a List of Int's [Int]
01:13:15 <neologism> some willing/able to help me with prolog?
01:22:06 <boegel|home> boing-de-boing-boing !
01:23:31 <kzm_> boing?
01:23:38 <kzm_> @seen boegel|home
01:23:39 <lambdabot> boegel|home is in #haskell-overflow, #haskell-blah and #haskell. Last
01:23:39 <lambdabot> spoke 1 minute and 32 seconds ago.
01:23:50 <kzm_> @seen
01:23:51 <lambdabot> Lately, I have seen boegel|home, kbot2 and kzm_.
01:26:28 <boegel|home> kzm: still testing ? :)
01:44:26 <bikobiko> hi all
01:47:29 <Cale> hi!
01:47:34 <Cale> what's up?
01:49:44 <boegel|home> hi bikobiko
02:06:15 <tic> Hi guys, I have problem with bind:
02:06:15 <tic> http://rafb.net/paste/results/xS1aLp72.html
02:13:49 <Cale> tic: looking...
02:13:58 <tic> Cale, I found a solution :)
02:14:15 <tic> Section (Document ()) (Document a), and I'm set.
02:14:33 <Cale> oh
02:14:43 <Cale> you're going to throw away the section?
02:14:49 <Cale> why not recurse into it?
02:15:08 <tic> Have a look at the bottom of this page: http://www.dtek.chalmers.se/~tic/afp.html#sample-documents
02:15:12 <tic> or well, just click that link actually :)
02:15:33 <tic> I'm just throwing away the type.
02:16:27 <Cale> um, hmm
02:16:52 <tic> (at least I think do)
02:17:16 <Cale> I'd think that would mean throwing away the section
02:17:45 <tic> hm... really?
02:17:46 <Cale> oh
02:17:57 <Cale> Section (Document ())  (Document a) ?
02:18:00 <tic> Yeah.
02:18:07 <Cale> as in, sections can't return anything
02:18:10 <tic> correct.
02:18:22 <Cale> hmm
02:27:21 <tic> awesome, works :P
02:27:25 <tic> wonder if it works with nested sections..
02:27:28 <tic> but alas no time.
02:29:11 <Cale> well, I'm kind of wondering about the ref thing
02:29:35 <Cale> it would seem to me that you'd need a pretty clever return type
02:29:50 <Cale> or is it just String?
02:30:18 <Cale> ah, label generates it
02:38:23 <hulahub> hmmm ... its hard :D how to remove the last element of a List? the first is just rem (x : xs) = xs but the last... :/
02:39:03 <Lemmih> > init [1,2,3]
02:39:04 <lambdabot> [1,2]
02:39:25 <Lemmih> Beware of its complexity, though.
02:40:25 <hulahub> hmm
02:40:49 <hulahub> thats a pre defined function? :D is there a list fo predefinded functions somewhere?
02:42:24 <wilx> The docs.
02:42:52 <hulahub> ah the std libs..
02:43:13 <Lemmih> @docs Data.List
02:43:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
02:44:20 <neologism> > let foo x = take (length x - 1) x in foo [1,2,3,4]
02:44:21 <lambdabot> [1,2,3]
02:44:49 <Lemmih> Urk.
02:45:41 <hulahub> k
03:05:55 <kzm_> init == reverse . drop 1 . reverse ?
03:06:18 <kzm_> > let init' = reverse . drop 1 .reverse in init' [1,2,3]
03:06:19 <lambdabot> [1,2]
03:06:20 <Heffalump> that'll behave worse on infinite lists
03:06:30 <kzm_> Good point.
03:07:25 <kzm_> > let { init' (x:xs) = x : init' xs ; init' [x] = [] } in init' [1,2,3]
03:07:26 <lambdabot>   Warning: Pattern match(es) are overlapped
03:07:26 <lambdabot>      In the definition of `init'': init' [x] = ...
03:07:35 <Lemmih> > fix (\i l -> case l of [x] -> []; (x:xs) -> x:i xs) [1,2,3]
03:07:36 <lambdabot> [1,2]
03:07:47 <Lemmih> > head $ fix (\i l -> case l of [x] -> []; (x:xs) -> x:i xs) [1..]
03:07:48 <lambdabot> 1
03:07:49 <kzm_> > let { init' (x:xs@(_:_)) = x : init' xs ; init' [x] = [] } in init' [1,2,3]
03:07:50 <lambdabot> [1,2]
03:08:38 <kzm_> does it have bad behavior (time-complexity)?
03:13:22 <flux__> well, it's O(n) if that's what you're thinking? but then again so is traversing the list, so it could be considered being free.
03:14:13 <flux__> it adds a minor per-element cost to accessing the elements of the list, compared to manipulating the original list
03:16:01 <Cale> and the new list isn't shared with the old one at all, so it may cost O(n) space.
03:16:29 <Cale> (well, the elements themselves are shared of course)
03:22:46 <twb> @pl \w h -> concat (map (\y -> map (\x -> (x, y)) [0..w]) [0..h])
03:22:46 <lambdabot> (join .) . (. enumFromTo 0) . map . flip (map . flip (,)) . enumFromTo
03:22:46 <lambdabot> 0
03:25:36 <twb> @pl \f xs ys -> map (\y -> map (\x -> (f x y)) xs) ys
03:25:36 <lambdabot> (map .) . flip . (map .) . flip
03:50:43 <xerox> Wroooom.
04:49:42 <astrolabe> Is there a matrix library in haskell?  with eigenvalue decomposition of symmetric matrices?
04:50:04 <astrolabe> *for haskell
04:50:16 <basti_> octave? ffi? 
04:50:18 * basti_ ducks and runs
04:50:37 <astrolabe> basti:  hmmm  :)
04:50:45 <xerox> $ emacs Matrix.hs   ^_^
04:50:47 <Gs30ng> can anybody tell me the pronunciation of "Haskell" in IPA?
04:51:11 <basti_> sampa?
04:51:16 <Gs30ng> yeap
04:51:20 <basti_> let me try
04:52:03 <Saulzar> astrolabe, I've seen mention of "hmatrix" which looks quite interesting, as a wrapper on gnu scientific library
04:52:05 <Gs30ng> i want to write a simple Haskell tutorial in my mother language(Korean), but not sure about the pronunciation of it
04:52:25 <astrolabe> Saulzar: thanks, I'll check it out.
04:53:26 <basti_> Gs30ng: haskEl i'd say
04:54:18 <Gs30ng> thanks
04:54:20 <Gs30ng> well
04:54:26 <astrolabe> I'd always assumed the emphasis would be on the first syllable
04:54:31 <Gs30ng> in Korea there are 2 ways of reading 'Haskell'
04:54:40 <basti_> Gs30ng: with a slight lowering of tone in the E, but I'm not sure if thats only a personal habit
04:55:00 <basti_> astrolabe: indeed, emphasis is on the first syllable, but, did someone claim opposite? ^^
04:55:37 <basti_> the problem is, how is emphasis rendered in english? more "pressure" and slightly higher tone i'd say.
04:55:56 <Gs30ng> in X-SAMPA, one is /haskEl/ and the other one is /h{skEl/
04:56:23 <Gs30ng> X-SAMPA { is IPA Ã¦
04:56:43 <Gs30ng> i'm not sure that character can be shown in another machine but anyway i'm confused
04:57:07 <basti_> Gs30ng: nobody in europe pronoucnes it that way i'd think
04:57:18 <basti_> with { that is
04:57:38 <ulfdoz> ANGEL OF DEAAAAAAATH!
04:57:45 <ulfdoz> args, sorry
04:57:52 <Gs30ng> well right now i'll regard it /haskEl/ according to basti_. thanks
04:57:56 <ulfdoz> The client's fault.
04:58:04 <basti_> lol
04:58:19 <Gs30ng> { is "near-open front unrounded vowel" in English trap
04:58:51 <basti_> aw sorry i confused
04:59:01 <basti_> i thought you wrote }
04:59:05 <basti_> { is possible, yes.
04:59:15 <Gs30ng> Haskell also can be pronounced this way, and actually many Korean follows this way, about 50%
04:59:27 <Gs30ng> another 50% reads it /haskEl/ :(
04:59:31 <hulahub> is there a way to get an offline version of the haskell wiki? :D
05:00:32 <astrolabe> What english word uses the little 'a'  sound?
05:00:36 <basti_> Gs30ng: the problem is, english spelling is completely unrelated to pronounciation
05:00:42 <Gs30ng> right.
05:00:43 <basti_> astrolabe: "husk"?
05:01:34 <hulahub> Usshole
05:01:42 <basti_> >.<
05:02:03 <basti_> hulahub: wget?
05:02:10 <astrolabe> Well, I'm english, I've never heard an expert pronounce haskell, but I'd be really suprised if it sounded like husk.  I bet it sounds like trap.
05:02:27 <basti_> mm ok
05:02:43 <hulahub> or h'schkel
05:02:44 <astrolabe> like 'basti'  :)
05:03:03 <basti_> hashkell?
05:03:04 <Gs30ng> it could be o sound of hot, i think
05:03:19 <hulahub> basti_: hmmm ... ? i think the links will still be wrong :D 
05:03:26 <astrolabe> Gs30ng: I doubt it.
05:03:55 <hulahub> hascool ?
05:04:01 <basti_> hulahub: uhm. ever heard of relative linking?
05:04:09 <Gs30ng> like harskell, with reduced r
05:04:31 <hulahub> basti_: sure - but im unsure if the wiki uses relative linking :D
05:04:36 <hulahub> lemme check
05:05:19 <hulahub> the url's are "hard" files or just rewrite rules?e.g. hawiki/LibrariesAndTools ?
05:05:46 <Gs30ng> the wiki is based on moinmoin, right?
05:06:12 <Gs30ng> then there should be a way to make local version of it, with sql dump(i'm not sure about this term though)
05:06:51 <astrolabe> look for 'pronounce' in this file http://tunes.org/~nef/logs/haskell/05.11.18
05:07:58 <Si\> Does anyone know if there's been any talk about a built in constraint in Haskell which would be able to establish whether a monad is pure or impure?
05:10:30 <JohnMeacham> is there a doc anywhere describing how user defined kinds will work in ghc? I want to implement them in jhc and want to make sure it is compatable.
05:11:47 <astrolabe> Gs30ng: Having browsed around a bit, I'm pretty sure that the vowels in 'Haskell' sound like those in 'trap' and 'hell', but people probably get lazy about the 'ell' and make it sound like the end of 'pull'.
05:12:23 <Gs30ng> oh
05:13:28 <Gs30ng> then you suggest me to consider it Haskell with a in trap and e in hell?
05:16:07 <dcoutts> JohnMeacham, I was talking to a guy in my department who did his dphill on region analysis. We were wondering what region analysis technique you are using in jhc?
05:17:22 <astrolabe> Gs30ng: yes.  Or you could ask shapr to send you the audiofile from SPJ.
05:26:43 <hulahub> is there a way of executing more than one function inside on function? e.g. walking a bTree: walk left AFTER walk right ?
05:27:24 <ski> what should the left walk return ?
05:27:31 <ski> what should the right walk return ?
05:27:58 <xerox> ...a Zipper :-)
05:28:00 <ski> what should the whole call return, in terms of answers to those previous questions ?
05:28:11 <ski> xerox : hi
05:28:14 <xerox> Howdy!
05:28:39 <hulahub> ski - i've two patterns on a function - one is a Leaf (so nothing folows - break condition) and the other is a node
05:28:54 <hulahub> if a leaf i print out its value
05:29:13 <ski> print how ? using IO ? or just returning a string ?
05:29:14 <hulahub> if a node i call the same function on the left of the node
05:29:40 <hulahub> but i need to call left and right :D that how i did it imperative - perhaps im thinking in the wron direction :D
05:29:46 <hulahub> ski: io just for learning
05:29:55 <JohnMeacham> dcoutts: not sure yet. I am experimenting with several but will likely allow a choice of GC systems.
05:29:56 <hulahub> ski: want to have a list later
05:29:58 <ski> but you want io, here ?
05:30:06 <JohnMeacham> or region algorthims for that matter.
05:30:11 <ski> with lists, you can e.g. use append '(++)'
05:30:28 <ski> with IO, you can use "do-notation"
05:30:32 <ski> do blaha
05:30:35 <ski>    blahhh
05:30:36 <hulahub> ski: ye know that - but thats not the porblem?
05:30:39 <ski> do   ...
05:30:58 <ski> do print the left part
05:31:07 <ski>    print the right part
05:31:10 <ski> like that
05:31:42 <hulahub> ski: ye buts that my problem - i've only two pattern - a leaf (break cond.) and a node - in the node i have to walk left and after that right
05:31:53 <xerox> ski: I think he wants them to return the tree.
05:31:54 <hulahub> ski: but how to execute 2 functions insinde a function ?
05:32:00 <xerox> @wiki TheZipper
05:32:01 <lambdabot> http://www.haskell.org/hawiki/TheZipper
05:32:03 <xerox> Check that out!
05:32:20 * ski isn't sure hulahub really wants zipper
05:32:29 <xerox> Who doesn't want one.
05:32:33 <ski> hehe
05:32:58 <Si\> If we had a language extension which would allow for constraining that a particular monad must be pure it would allow the type-system to guarantee that (without unsafePerformIO) a particular bit of monadic code is side-effect free
05:33:26 <ski> hulahub : maybe by using do-notation, as i showed above ?
05:33:48 <ski> Si\ : 'pure' ?
05:33:55 <hulahub> the imperative way: walk(left); print value; walk(right) - and in haskell im at: walk(left) :D i do not know how to call the walk(right) after that
05:34:11 <ski> Si\ : all monads are pure, from one pov, and no monad (except Id) is pure, from another pov
05:34:12 <hulahub> print is done by the break condition
05:34:13 <xerox> In fact he seem to want to put order the computation, you do it with simple function composition that way.
05:34:17 <Si\> IO isn't
05:34:26 <ski> sure is
05:34:28 <Si\> because IO isn't a monad arguably
05:34:43 <ski> are you thinking of that ugly 'seq' matter ?
05:34:45 <basti_> hulahub: this chapter of the haskell book requires a little time to understand
05:34:51 <Si\> no, it affects the work state of the world, thus it is impure
05:34:56 <ski> no
05:34:59 <basti_> hulahub: are you familiar with the way IO stuff is chained?
05:35:09 <Si\> you cannot guarantee what a piece of IO code is going to do, right?
05:35:23 <ski> hulahub :
05:35:24 <ski> do print the left part
05:35:24 <ski>     print the right part
05:35:29 <ski> um
05:35:31 <ski> do print the left part
05:35:31 <ski>    print the right part
05:35:34 <hulahub> basti_: in no way - just unsing print for IO :D
05:35:36 <ski> (must be aligned)
05:35:37 <xerox> ski: nope!
05:35:42 <xerox> ski: just (.)
05:36:07 <basti_> hulahub: hmm. Did you ever encounter ">>=" or ">>"?
05:36:14 <ski> xerox : <hulahub> ski: io just for learning
05:36:20 <Si\> any pure function has a guaranteed set of outputs, for a particular set of inputs
05:36:25 <xerox> KISS!
05:36:28 <ski> xerox : that seems to imply he wants, IO, not ShowS
05:36:44 <hulahub> ski: just the output .... i want a list - just to see what happens i print :D
05:36:46 <ski> xerox : <hulahub> ski: want to have a list later
05:37:01 <basti_> @type putStrLn
05:37:02 <lambdabot> String -> IO ()
05:37:04 <hulahub> basti_: i found >> - read it is like a ; 
05:37:11 <basti_> yes it is
05:37:13 <basti_> kinda.
05:37:16 <hulahub> basti_: bust walk left >> walk right does not work :D
05:37:25 <basti_> do you understand the type of putStrLn?
05:37:31 <ski> hulahub : exactly what are you writing ?
05:37:32 <basti_> (this has to do with your walk problem)
05:37:49 <ski> lisppaste2 : url
05:37:50 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:38:24 <twb> Woo, "Process haskell segmentation fault"
05:38:45 <ski> Si\ : if you think of 'IO a = Realworld -> (a,Realworld)', then surely, if you give same world to an io-action you get same result and same new world ?
05:39:04 <twb> Woo, it's reproducible!
05:39:12 <xerox> twb: what is it?
05:39:14 <twb> Anyone interested in a reproducible segfault in ghci?
05:39:22 <Si\> erm, but IO isn't that, it pretends to be, but you can in no way model the real world with a digital computer
05:39:24 <hulahub> ski: i generated a huffman tree and now want to create a List of Tupels containing the symbol + its new code
05:39:36 <xerox> twb: does it involve a sporious use of classes? :-D
05:39:39 <ski> Si\ : implementation is one thing, semantics abother
05:39:43 <twb> xerox: http://twb.ath.cx/~twb/src/darcs/miscellaneous/cse1303-a1/haskell.hs
05:39:46 <ski> a/abother/another/
05:39:56 <twb> xerox: load that, then evaluate "points puzzle".
05:39:59 <ski> hulahub : surely they should agree, though, which they do in this case
05:40:16 <ski> s/hulahub/Si\/
05:40:32 <xerox> There is not such directory/file, it seems, twb.
05:41:01 <twb> xerox: http://twb.ath.cx/~twb/darcs/miscellaneous/cse1303-a1/haskell.hs ?
05:41:11 <Si\> but the fact still remains that whilst you can guarantee what x -> State s v is going to produce, you can't for x -> IO v
05:41:14 <ski> Si\ : the 'pretends' here is unimportant for reasoning about results
05:41:55 <ski> Si\ : that is *only* because you can't pass the same world into the io-action, twice
05:42:36 <ski> Si\ : in Clean, the 's' in the State could be a linear array, which gets updated-in-place, so it'd share the same thing
05:43:09 <Si\> ok, think of it another way, let's not worry about what IO is doing, but consider that IO actions can be latent and can fail
05:43:14 <ski> Si\ : in Clean, you can't pass the same linear array twice to a function .. exactly similar to the world
05:43:30 <ski> fail ?
05:43:40 <ski> in what sense ?
05:44:01 <Si\> yes, because if I try to invoke a service over the net and someone pulls the cable out half way through, it fails
05:44:09 <ski> hulahub : hm .. could you paste tour code at lisppaste, above ?
05:44:10 <xerox> twb: it does work here.  And with "work", I mean it outputs a list of points.
05:44:11 <Saulzar> I guess it is possible to have a haskell system where you _do_ model the real world - I guess you would not be taking input from a keyboard however :)
05:44:25 <ski> why not ?
05:44:39 <jlouis> Cale, SamB: I am not around 5 at night ;)
05:45:09 <twb> ii  ghc6           6.4.1-1        GHC - the Glasgow Haskell Compilation system
05:45:49 <dcoutts> JohnMeacham, I was under the impression that region analysis currently had only been applied to strict languages.
05:45:56 <jlouis> Updated conjure with patches from about yesterday. I have a couple of things I need to do to pass an exam, so I am not that productive at the moment, sorry
05:46:13 <dcoutts> JohnMeacham, my colleague is quite keen to look into the lazy/non-strict case.
05:46:13 <binary42> twb: platform? Works for me too (Mac OS X 10.4.3). GHC 6.4.1
05:46:40 <twb> binary42: Debian/sid/PPC
05:47:00 <twb> It might be a problem with the Emacs comint package.
05:47:10 <twb> http://twb.ath.cx/tmp/tmp.png
05:47:33 <hulahub> ski: sure - wait a sec
05:49:22 <Si\> If we have no IO in a program it will always produce the same result from the same input, it is only when you introduce IO that you introduce non-determinism.
05:50:25 <xerox> (Which differs from 'modelling' non-determinism.)
05:50:26 <lisppaste2> hulahub pasted "Learning (via Huffman eg)" at http://paste.lisp.org/display/14248
05:51:33 <hulahub> ski: http://paste.lisp.org/display/14248 - i can get the right code for walking right only or walking left only --- but i need all codes :) 
05:51:38 <twb> Hmm, it segfaults on the command-line, too.
05:52:30 <twb> It must be in the print routines, because ":t points puzzle" works fine.
05:52:49 <Si\> So I think that rather than trying to model the RealWorld for the entire program, which is difficult if not impossible, we should restrict having to model this to the code where we actually need it, via the type-system.
05:52:59 <hulahub> ski: cn = create node, ct = create tree, cc = create codes *g
05:53:52 <ski> Si\ : IO is just dependence on external input .. if you pass in different things, no wonder the result can be different
05:54:13 <jlouis> Even more conjure patches
05:54:15 <jlouis> @where conjure
05:54:16 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
05:54:31 <ski> hulahub : is it 'cc' that you had trouble with ?
05:54:44 <hulahub> ski: yes
05:55:06 <twb> jlouis: what is conjure?  A bt client?
05:55:10 <hulahub> ski: you see in the second pattern of cc i need to walk left tree first than right tree - but i dont know how to execute both functions :D
05:55:50 <ski> hulahub : it's slightly more problematic here, since you return a pair from each rec. call, and want to combine corresponding parts of the two pairs (i think)
05:55:56 <ski> but, it's not hard
05:56:01 <ski> you use 'where
05:56:08 <ski> ' and call recursively in thst
05:56:13 <ski> s/thst/that/
05:56:19 <ski> hulahub : do you know 'where' ?
05:56:57 <ski> cc (Node l v r) i = ...
05:56:58 <ski>   where
05:56:59 <ski>   ...
05:57:19 <twb> In Haskell, can a function body refer to another function that is defined later on?
05:57:31 <JohnMeacham> dcoutts: Yes, as far as I know that is true. but by the time the grin transformations have been done, it is a strict first-order language.
05:57:39 <hulahub> ski: no i don't know yet
05:57:45 <twb> i.e. does the compiler catch the free variable at define-time.
05:58:16 <hulahub> ah 
05:58:18 <hulahub> stop
05:58:21 <hulahub> i know i think
05:58:29 <ski> Si\ : yes, i agree that it's stupid to give the whole world as input to all parts of the program .. if they don't depend on whole world, then no need to pass it in .. instead just passing in info that were earlier extracted from world (and possibly transformed)
05:58:36 <flux__> twb, yes it can
05:58:43 <ski> hulahub : it lets you declare local variables
05:58:59 <hulahub> ski: yes - i remember
05:59:09 <hulahub> ski: but how can it help me ?
05:59:15 <ski> cc (Node l v r) i = 
05:59:16 <ski>   where
05:59:22 <ski>   ... = cc (...) (...)
05:59:24 <ski>   ... = cc (...) (...)
05:59:26 <ski> like that
05:59:58 <ski> you can put the recursive calls in the 'where' parts .. putting results of those into variables
06:00:12 <ski> hulahub : do you understand ?
06:03:15 <twb> I've distilled the problem.
06:03:19 <twb> http://twb.ath.cx/tmp/tmp.sh
06:03:34 <hulahub> ski: no :(
06:03:54 <Si\> The problem at the moment is that we don't distinguish IO from the other, pure monads, so if I right a program which works in any Monad, I have to allow for the fact that my code could be side-effecting. I can't force it not be.
06:04:08 <Si\> I think the type-system should allow me to distinguish
06:04:44 <basti_> ?
06:05:13 <jlouis> twb: yes, it is a bt client
06:05:15 <ski> Si\ : there really is no such (conceptual (as opposed to implementational)) difference between IO and other monads .. only difference there is that there's no way to get out of IO monad
06:05:36 <basti_> ski: thats what i thought
06:06:15 <ski> hulahub : i mean, put your (two) recursive calls in the 'where' part, like i started to, above
06:06:38 <ski> hulahub : then you get back results, namely two chars and two intlists, and the after the '=
06:06:48 <ski> ' you put the main thing you want to return
06:07:19 <ski> hulahub : would it help if i took some other example, to show the technique ?
06:07:22 <Si\> conceptually, yes, there is not difference. But if our implementation doesn't reflect the theory, surely either the implementation is flawed or the theory is too coarse
06:07:41 <ski> yes
06:07:45 <hulahub> ski: a simple example would help :)
06:07:59 <ski> hulahub : do you know this function ?
06:08:04 <ski> > splitAt 3 [1..6]
06:08:05 <lambdabot> ([1,2,3],[4,5,6])
06:08:38 <ski> we could write that function, it'll use a similar style to what you want
06:09:01 <tic> is there a splitBy or something?
06:09:12 <tic> splitBy '.' "file.ext"
06:09:16 <Si\> Now we could say the implementation is flawed: GHC/Hugs should represent IO literally as Realword -> (a, RealWorld), but then the question is how?
06:09:17 <ski> > span (< 5) [0..9]
06:09:18 <lambdabot> ([0,1,2,3,4],[5,6,7,8,9])
06:09:23 <ski> tic : that ?
06:09:37 <Si\> Can we model the Universe?
06:10:06 <Si\> When our side-effects are simply based on keyboard/local effects sure we can model
06:10:15 <tic> ski, nope.
06:10:19 <ski> Si\ : to avoid IO being an abstract datatype, and export the implementation like that, we need a linear/uniqueness typesystem (like in Clean and Mercury)
06:10:23 <tic> ski, I want to split "foo.ext" in "foo" and "ext"
06:10:28 <tic> (possibly "foo" and ".ext"
06:10:36 <Si\> but I deal in the Web, and in the Web a storm in China is an important side-effect
06:12:11 <ski> > let foo c [] = []; foo c s = let (s0,s1) = span (/= c) s in s0 : foo c (dropWhile (== c) s1 in foo '.' "foo.ext"
06:12:11 <lambdabot>  parse error on input `in'
06:12:15 <jethr0> > splitAt '.' "foot.ext"
06:12:16 <lambdabot> Couldn't match `Int' against `Char'
06:12:24 <ski> > let foo c [] = []; foo c s = let {(s0,s1) = span (/= c) s} in s0 : foo c (dropWhile (== c) s1 in foo '.' "foo.ext"
06:12:24 <lambdabot>  parse error on input `in'
06:12:26 <jethr0> no, wrong
06:12:56 <ski> > let foo c [] = []; foo c s = (let (s0,s1) = span (/= c) s in s0 : foo c (dropWhile (== c) s1) in foo '.' "foo.ext"
06:12:57 <lambdabot>  parse error on input `in'
06:13:04 <tic> ski, how come something like that isn't in the standard library? :)
06:13:08 <Si\> ski: But do we need such a dramatic overhaul? Surely if we can simply distinguish what is side-effecting code from what is pure code?
06:13:21 <tic> cf. python's "".split(c='\n')
06:13:41 <ski> Si\ : it's a matter of pov
06:13:58 <ski> Si\ : it all compiles down to machine code
06:14:21 <hulahub> :D
06:15:14 <ski> Si\ : in one pov, *no* thing in haskell is side-effcting (ignoring evils like unsafePerformIO, here)
06:16:08 <ski> Si\ : that is more or less the point .. of course we could have two different languages, one pure and one impure, but i prefer keeping all in pure (at least when it works so good as it does, in haskell)
06:16:28 <ski> hulahub : ok, define 'splitAt' 'twas :)
06:17:03 <Si\> ski: But aren't we just deceiving ourselves, saying that Haskell is pure when we have IO in the middle?
06:17:14 <ski> it takes a number n and a list, and chops off n elements from the list, returning that as the first list in the pair, the second returned list being the rest of the list
06:17:23 <jethr0> ski: shouldn't this work fairly easy with unfoldr?
06:17:32 <tic> Si\, I don't think we do, just because of the fact that all side-effects are done in the IO monad and you can never escape.
06:17:42 <ski> Si\ : no .. what matters here is that we can reason in same way about IO-code as about other code, and we can
06:17:45 <tic> Si\, how do you plan on writing real programs without side effects? impossible.
06:18:00 <gilles> hi all
06:18:37 <ski> tic : well, implementation will of course have effects somewhere ..
06:18:43 <Si\> No, what I'm saying is that my application for Haskell is such that side-effects are not tangible. You can't get hold of them and you can't reason over them
06:19:37 <ski> you can reason about them as much as you can reason about any other ADT, i.e. only by the laws that are known to hold
06:19:47 <Si\> And if you have a magic IO type, you have a sub-language, which I think is good, but we should be able to determine when we are in that sublanguage and when we are not
06:20:11 <ski> Si\ : of course, additionally, you don't lose normal reasoning as substitution rule, etc
06:20:40 <tic> Si\, I don't understand what you mean. Why can't we determine that?
06:20:52 <tic> Si\, you can always verify your pure functions
06:21:09 <ski> 'let foo = putStringLn in "Hello" in do {foo; foo}'  really means same as  'do {putStringLn "Hello"; putStringLn "Hello"}'
06:21:13 <Si\> How can the type-system determine whether something is pure or not?
06:21:19 <ski> all is pure
06:21:26 <ski> so, the asnwer is no
06:22:02 <ski> mapM is a pure function
06:22:05 <tic> What was the original question/statement in this thread?
06:22:40 <Si\> I don't think we agree over what pureness is. I see pureness as being able to work in a closed environment.
06:22:59 <ski> pureness is a matter of pov
06:23:22 <ski> (more specifically, it's a syntactical/grammatical matter)
06:23:29 <tic> My view of pure is that of a function, i.e., for any two values x, y, f(x) != f(y) unless x=y
06:23:58 <tic> Forall x, y:a. f x = f y <=> x=y, right?
06:24:23 <Si\> agreed
06:24:24 <ski> 'sequence' will always return the same IO-action, when you pass '[getChar,getChar]' to it
06:24:24 <tic> or, hm. no. sorry. wrong. :)
06:24:45 <ski> so, 'sequence' is a pure function
06:25:03 <ski> sequence [getChar,getChar] :: IO [Char]
06:25:07 <tic> shouldn't require functions to be injective...
06:25:24 <ski> hulahub : sorry about waiting ..
06:25:28 <tic> How do you define pure, anyway? :)
06:25:35 <jethr0> tic: you want x == y => f(x) == f(y), i think
06:25:39 <Si\> Erm, if I type p & q, and then x & y, it returns different values...
06:25:53 <tic> jethr0, nope. What if the function's not injective?
06:26:01 <ski> jethr0 : yes, that is substitution law
06:26:21 <ski> tic : doesn't matter
06:26:39 <ski> Si\ : '&' ?
06:26:53 <Si\> Oh I see what you mean, yes you're right, you get the same IO Action.
06:26:53 <tic> ski, what if your function maps two different values onto the same target value?
06:27:09 <jethr0> tic: no prob, all kinds of functions do it!
06:27:17 <jethr0> > even 2
06:27:18 <lambdabot> True
06:27:18 <twb> Is there a case-insensitive char/string comparator?
06:27:19 <jethr0> > even 4
06:27:20 <lambdabot> True
06:27:22 <twb> string=
06:27:30 <tic> jethr0, so how's that pure, if you define it as x == y => f(x) = f(y) ?
06:27:32 <Si\> I'm going to have to think about this some more, I must be able to guarantee execution of certain monadic actions in my program...
06:27:44 <tic> jethr0, maybe I should think about it a bit more..:)
06:27:51 <jethr0> huh?????
06:28:00 <hulahub> ski: i have to scroll up... :D
06:28:09 <ski> twb : don't think so ..
06:28:15 <jethr0> tic: sorry, i read "may _you_ should ..."
06:28:22 <tic> jethr0 :)
06:28:50 <tic> for any two the same values, it cannot yield different results.. Yeah, that sounds about right.
06:29:22 <jethr0> that's (part of?) referential transparency. that one can substitue equals for equals.
06:29:36 <ski> yeah
06:29:38 <jethr0> tic: but this also holds in time.
06:29:42 <tic> Right, referential transparency was what I was thinking of.
06:29:44 <SamB> jethr0: I thought that was pretty much the whole story?
06:29:44 <tic> jethr0, *nod*
06:29:56 <SamB> equals for equals
06:30:09 <SamB> wherever you like
06:30:12 <jethr0> samb: just trying to be cautious and not forget something out of stupidity ;-)
06:30:17 <jethr0> whenever you like
06:30:53 <SamB> what is this "time" thing you keep mentioning?
06:31:00 <jethr0> hehe
06:31:15 <tic> 4th dimension.. is that some kind of 4GL-tool?
06:31:26 <jethr0> ?
06:32:09 <tic> nm.
06:32:33 <jethr0> samb: this "time" thing allows order of execution. might come in handy when altering the world *g*
06:33:36 * jethr0 sings: (refrain) "make the world a better place, for you and for me and for the entire human race"
06:33:44 <jethr0> lalala
06:34:19 <ski> jethr0 : bah, just another data-dependency
06:36:23 <SamB> jethr0: oh, are you talking about that RealWorld thing again?
06:37:31 * gilles think changing the world is really over-rated
06:37:32 <jethr0> samb: yeah, i know. but i _insist_ that such a thing exists... even if we can never see it directly from in here!
06:40:05 <SamB> jethr0: could be!
06:40:06 <ski> Clean people can see it
06:40:15 <jlouis> hi SamB. Everything has been comitted and looks quite nice
06:40:24 <ski> (though, not only the Clean people, also Mercurians)
06:40:46 <SamB> isn't murcury rather hot?
06:40:52 <jethr0> ski: so how do clean and mercury solve the ref. transparency issue?
06:41:14 <jethr0> samb: mainly it melts and room temperature ;-)
06:41:18 <ski> jethr0 : the type system doesn't allow you to use a variable of "linear type" twice
06:41:29 <jethr0> huh?
06:41:34 <SamB> jlouis: I'm not seeing anything to pull. Does this mean that I have everything already?
06:41:46 <SamB> jethr0: not the metal, the planet!
06:42:01 <ski> jethr0 : silly person, the planet is not made out of that metal (except esoterically speking)
06:42:55 <jethr0> samb: mean temperature: 452 K vs 150K on earth
06:43:20 <ski> jethr0 : 'main world0 = let (c,world1) = getChar world0 in let (c,world2) = getChar world0 in world2' is not allowed
06:43:43 <jlouis> SamB: yes
06:43:48 <jethr0> "Mercury's composition is approximately 70% metallic", i rest my point ^_^
06:43:59 <jlouis> SamB: your patches should just be much smaller
06:44:18 <ski> jethr0 : so, you must use things of "linear types" in a single-threaded way, so data-dependency ensures the execution order of world modifications
06:44:49 <jethr0> uhu. maybe i'll have a look at it at some time...
06:44:50 <SamB> jlouis: okay, so the main repo is now up-to-date. lovely!
06:45:22 <SamB> ski: do they have sugur or honey for this?
06:46:18 <Pupeno> What free tutorial/book do you recommend to start learning Haskell ? (I am reading Yet Another Haskell Tutorial).
06:46:28 <twb> Is there a builtin function that does this?
06:46:28 <twb> removeIf _ [] = []
06:46:28 <twb> removeIf p (h:t) = if p h then removeIfNot p t else h : (removeIfNot p t)
06:46:46 <twb> Er, s/removeIfNot/removeIf/
06:46:47 <SamB> twb: filter . not?
06:46:51 <ski> jethr0 : one nice possibility is that you could consider splitting the world into parallel, noninteracting subsystems, like gfx, filesystem, etc .. and then pass those pieces off to different parts of program (later joining), and those separate execution parts are not sequenced with respect to each other (as opposed to monads in haskell)  (btw, i'm not talking about concurrency, here)
06:46:58 <ski> SamB : yes
06:47:00 <twb> SamB: looking...
06:47:12 <twb> Ah, thanks.
06:47:38 <jethr0> ski: but how would you join them again. is that legally possible in clean/mercury?
06:47:49 <Philippa> by using the results
06:47:51 <ski> Pupeno : that tut is often said to be quite good .. if you're looking for a book to but, then maybe "Haskell: The Craft of Functional Programming" (there's a list of books at the haskell site)
06:47:58 <twb> It's like grocery shopping in a foreign country.  All the stuff is there, but with different names :-)
06:48:12 <lisppaste2> basti_ pasted "Huffmann Tree" at http://paste.lisp.org/display/14251
06:48:28 <ski> split :: RealWorld -> (FileSystem,Graphics)  -- assuming just two parts
06:48:44 <ski> join :: FileSystem -> Graphics -> RealWorld
06:48:44 <jethr0> twb: well, except that when shopping for groceries you can actually see and touch them.
06:49:27 <Pupeno> thanks.
06:49:46 <SamB> jethr0: wasn't he talking about filter.not?
06:49:50 <Saulzar> ski, Why wouldn't that kind of thing be equally possible in haskell?
06:50:07 <SamB> Saulzar: oh, did you get my tarball?
06:50:08 <jethr0> hmm, as i said, i'll have to look into it. so, is that approach "better" than monads?
06:50:17 <Saulzar> SamB, Nope?
06:50:25 <ski> Saulzar : because haskell has no linear/uniqueness typesystem
06:50:29 <Saulzar> SamB, Uploaded you mean?
06:50:58 <ski> jethr0 : monads can be used for many things, including IO
06:51:01 <SamB> http://vx.hn.org/autoshare/slugtracer-0.0.2.tar.gz
06:51:30 <SamB> and see http://vx.hn.org/autoshare/slugtracer-Cale.jpeg
06:51:33 <jethr0> ski: i know. but would you consider clean's approach to "IO" more clean than haskell's?
06:51:36 <Saulzar> Ah, what've you done to it?
06:51:43 <ski> jethr0 : linearity can be used for IO and state   (and is also good to have incorporated in your thinking, imo)
06:51:52 <Saulzar> SamB, Ah hah, beatuful :)
06:51:57 <ski> jethr0 : depends
06:52:41 <jethr0> but don't io and state monads enforce linearity too? or is that a different kind of linearity?
06:52:46 <ski> jethr0 : in a way it's more "functional", since we can access the internals of the IO monad (it doesn't have to be abstract, for safety)
06:53:01 <ski> jethr0 : they enforce it by means of ADT, only
06:53:36 <jethr0> yes, but instead of saying "you can use this value, but never forget where it's coming from" you then say "use it, but only once"?
06:54:35 <jethr0> ski: sounds pretty clean to me ;-)
06:55:15 <jethr0> samb: i timed out on your url...
06:55:24 <SamB> jethr0: great
06:55:36 <SamB> okay, I guess I'll put it up here
06:55:48 <ski> jethr0 : yes
06:56:08 <ski> (though i didn't get the 'never forget where it's coming from' part)
06:56:08 <Philippa> to finish the statement: "you'll get a new version back when you use it"
06:56:14 <Philippa> the IO monad
06:56:20 <ski> yep
06:56:27 <jethr0> ski: that was my description of the IO monad...
06:56:28 <Philippa> though in practice you can forget pretty easily once you have the value
06:56:39 <Philippa> you can pass it into all the pure code you want
06:57:09 <jethr0> everyone who wishes to use a valued originating from inside IO has to go into IO to use the value.
06:57:19 <ski> the linearity restriction allows the optimisation of updating in place (whether it's an array or the world that is updated in place)
06:57:22 <SamB> http://naesten.dyndns.org:8080/slugtracer-0.0.2.tar.gz
06:57:31 <jethr0> thx
06:57:49 <Philippa> jethr0: er, that's not entirely accurate
06:57:58 <jethr0> *damn*. why not?
06:58:05 <Philippa> you only need to use IO code to pass the value into a pure function
06:58:13 <astrolabe> @where parsec
06:58:13 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
06:58:14 <ski> jethr0 : yes, and that is exactly because you need some world to pass to your io-action, which you must get from somewhere
06:58:23 <jethr0> yes, but the function is executed "within" io; somehow at least!
06:58:25 <Philippa> you can have pure code inside IO monad code (return is your friend). You just can't do the other way round
06:58:34 <Philippa> yes. That's a substantial difference though
06:59:09 <jethr0> sorry, i formulated it rather sloppyly ;-)
06:59:10 <Philippa> and conceptually, it makes perfect sense - you don't get to do anything that affects the real world without it reducing to IO eventually
06:59:19 * ski interpreted 'valued originating from inside IO' as 'returned value from an IO-action, when it's run (with "current" world)'
06:59:32 <Philippa> ski: same here
06:59:55 <Philippa> it's pretty common to build a little driver framework and a lot of pure code...
06:59:58 <Saulzar> SamB, It takes a while :)
07:00:29 <SamB> Saulzar: yes
07:00:41 <SamB> I set the recursion depth to maxBound :: Int
07:02:26 <Saulzar> Ah yes, sorry about the fantastic hardcoded values with no documentation :)
07:02:35 <Saulzar> I fixed up refraction last night, this one took about half an hour to make: http://saulzar.orcon.net.nz/refract.png
07:02:43 <Philippa> jethr0: with linear typing you'll get the same problem anyway - a function can only do real world things if it takes the real world as a parm and returns a new version (or the same for a smaller chunk thereof - I guess it can be argued that's an improvement in typing)
07:03:13 <SamB> Saulzar: most of the changes I made are in darcs patches
07:03:40 <jethr0> saulzar: _very_ nice. but a bit straining for the eyes ;-)
07:04:20 <jethr0> philippa: so they enforce the same thing; only with slightly different mechanisms??
07:04:37 <ski> as said, monads can be used for other stuff, too
07:05:10 <Saulzar> SamB, Hmm, will have to look up darcs sometime - you use it locally for your projects?
07:05:40 <SamB> locally, globally, every-ly except windows-ly
07:05:45 <Saulzar> My current version control consists of cp foo foo67
07:05:51 <SamB> oh, and negative-ly
07:05:59 <Saulzar> Heh heh.
07:06:00 <SamB> don't use it negative-ly either
07:06:28 <Philippa> jethr0: yes, they're both based on the same denotational model of IO
07:06:45 <Philippa> ski: as can linear types, yeah
07:06:53 <ski> right
07:07:02 <SamB> lambdabot uses it
07:07:02 <Philippa> they're different methods being applied to the same problem here
07:07:12 <ski> (but not exactly same things)
07:07:21 * ski agrees
07:07:30 <Philippa> (linear types make proving that eg a bank transaction preserves cash a lot easier, for example)
07:07:50 <Philippa> myself, I can't help thinking linear types are probably most useful for implementing monads, but that's me ;-)
07:08:46 <jethr0> philippa: let's say you wanted to print a string to stdout and then read a result from stdin. how would that work in linear types (roughly?)
07:10:38 <Philippa> I've not coded in clean - my understanding is you'd do something like this:
07:11:35 <Philippa> (\oldWorld -> let newWorld = print "foo" oldWorld in getLine newWorld)
07:11:51 <Philippa> (where getLine will return a (world, result) tuple, as will the function)
07:12:26 <Philippa> in practice, I'd probably want to build a monad to do all the piping for me anyway - but that's just me
07:12:45 <Philippa> I would at least have a proof that the monad doesn't do anything dodgy - it wouldn't compile if it did
07:13:12 <SamB> shouldn't print return a (world,()) tuple?
07:13:17 <sieni> hmm... where do I get the energy to set up my darcs environment
07:13:18 <sieni> hmm
07:13:22 <ski> SamB : why ?
07:13:24 <SamB> just to save on plumbing?
07:13:29 <ski> SamB : it's isomorphic
07:13:44 <sieni> maybe I'll just watch monty python's meaning of life ^_^
07:13:52 <jethr0> so, it's like: \x oldWorld -> do print "foo" oldWorld >>= getLine
07:14:06 <jethr0> only without IO annotation...
07:14:07 <SamB> ski: but my way is more modular
07:14:33 <jethr0> sieni: darcs initialize in the source directory
07:14:41 <Philippa> SamB: it could do, but why bother? I'd assumed it didn't
07:14:42 <jethr0> siene: then darcs add *
07:14:51 <jethr0> siene: followed by darcs record
07:15:12 <Philippa> anyway, I'm not particularly bothered either way precisely because I would've built a monad out of it all anyway
07:15:30 <SamB> Philippa: well, yeah, there is that.
07:15:30 <sieni> jethr0: indeed, but I want to set up backup repositories and posthooks to autopush stuff there
07:15:57 <jethr0> huh, you lost me. gotta ask a _real_ haskeller for that ;-))
07:16:59 <ski> http://www.cs.ru.nl/~clean/Download/Download_Libraries/Std_Env/StdFunc/stdfunc.html
07:16:59 <sieni> and I want to use darcs push for backups
07:17:10 <ski> seqList there is basically 'sequence'
07:17:26 <sieni> rsync is a very sure way to fubar all backups as well
07:17:30 <ski> SamB : yes, for plumbing .. but often one codes at "bare" level
07:18:07 <ski> ('St s' there is a monad)
07:20:18 <sieni> (i.e. if you fubar your repository, then the rsync might fubar the backups as well even if --delete is not specified)
07:22:02 <jethr0> sieni: but with rsync-backup you also have the deltas!
07:22:35 <araujo> Good morning Haskell'ers!
07:22:42 <ski> Start oldWorld
07:22:47 <ski> um
07:22:53 <ski> Start world
07:23:04 <ski>   # world = putStrLn "foo"
07:23:19 <ski>   # (line,world) = getLine world
07:23:39 <ski>   = dosomething line world
07:23:45 <jethr0> @localtime araujo
07:23:47 <lambdabot> Local time for araujo is Sat Dec  3 11:23:18
07:23:59 <sieni> jethr0: well but darcs push works as well for a repository
07:24:17 <ski> um
07:24:20 <ski>   # world = putStrLn "foo" world
07:24:22 <ski> of course
07:25:01 <ski> that is like  Start world0 = let world1 = putStrLn "foo" world0 in (line,world2) = getLine world1 in dosomething line world2
07:26:38 <sieni> jethr0: I might also do so that I have the rsync-backup of the repository at one site and darcs pushed version in another
07:28:43 <dmg_> Hi there!
07:29:37 <ski> hi dmg_
07:30:37 <dmg_> Has anybody been successful with the latest fudgets-050222.src.tar.gz snapshot?
07:31:28 <dmg_> Just got it to compile with ghc 6.2.2, and even the simplest example fails with message: Fail: Prelude.(!!): index too large
07:31:43 <dmg_> Any ideas where to look for that index overflow?
07:31:59 <jlouis> grep the source
07:32:18 <ski> dmg_ : hm, where's that file located ?
07:32:19 <jlouis> its a bad way of finding the thing, but better than nothing
07:32:44 * ski downloaded fudgets-050120.src.tar.gz recently, but haven't tried yet
07:32:53 <dmg_> Well, I did ;) I'm wondering has anyone else had this problem?
07:33:18 <dmg_> ski, which file?
07:34:12 <ski> dmg_ : fudgets-050222.src.tar.gz
07:36:58 * araujo deeply hates the emacs 'case .. of' indentation
07:37:08 <dmg_> ski: it is at http://www.cse.ogi.edu/~hallgren/untested/Source_code/
07:37:46 <ski> danke (got the other file from chalmers ftp)
07:37:46 <chucky> araujo: are you using the latest version of haskell-mode? It has a more sensible case of indentation
07:38:23 <dmg_> while 050120 is at http://www.cs.chalmers.se/pub/haskell/chalmers/untested/ (I was unaware of that place)
07:38:29 <SamB> Saulzar: btw, why do you use 4-vectors throughout?
07:38:32 <araujo> chucky, Good, no i am not, i'll emerge it now
07:39:20 <SamB> you can get some really wierd results by setting the 4th component of a position to something besides 1...
07:40:11 <Saulzar> SamB, For transformations mainly - so you can transform vectors and points the same way... I'm just used to it because OpenGL does it this way
07:40:38 <SamB> Saulzar: ah
07:40:41 <ski> (dmg_ : yes .. for some reason i couldn't connect with ftp, so i used that)
07:41:32 <SamB> I'm used to povray, which uses flipped 3x4 partial matrices and 3-vectors, and fills in a 1 whenever it transforms them
07:42:42 <dmg_> ski: OK, I'll need to try the previous one. Maybe 050222 is "too much" untested
07:42:43 <Saulzar> Hmm
07:42:55 <basti_> 4d representation of 3d data is called "homogenous" i think. You can also display translation as matrix then, conceptually much simpler than first multiplying and then adding some more
07:43:09 <dmg_> Thanks, I've got to go somewhere (physically). Will post the results here.
07:43:26 <Saulzar> In my other projects I have done that, it feels a little awkward 
07:43:46 <SamB> which is to say, you give povray something like [[1,0,0],[0,1,0],[0,0,1],[1,2,3]]
07:43:50 <SamB> and it converts that to
07:43:50 <SamB> > transpose [[1,0,0],[0,1,0],[0,0,1],[1,2,3]] ++ [[0, 0, 0, 1]]
07:43:51 <SamB> yes, it is abit awkward :-(
07:43:51 <lambdabot> [[1,0,0,1],[0,1,0,2],[0,0,1,3],[0,0,0,1]]
07:44:43 <SamB> (or maybe it just pretends that the matrix is that, don't remember
07:45:35 <SamB> anyway, apparantly the function that takes the most time in that tracer is dot
07:45:47 <Saulzar> Hmm
07:46:49 <SamB> after all this criticism, I *will* say that your tracer seems rather easier to understand than HRay ;-)
07:47:28 <SamB> for one thing, I couldn't figure out how to set the camera angle in HRay at all
07:47:54 <Saulzar> Hehe, I'll have to take a look at HRay.
07:48:08 <SamB> @wiki HRay
07:48:08 <lambdabot> http://www.haskell.org/hawiki/HRay
07:48:39 <SamB> observe the CategoryApplication link at the bottom of the page, which is my doing ;-)
07:49:06 <SamB> dons said he had some things to put there...
07:49:11 <SamB> but he hasn't done it yet!
07:49:11 <Saulzar> Haha. Well I've had a look before, though the site seems down today...
07:49:17 <Saulzar> (The HRay site that is)
07:49:34 <SamB> was fine yesterday
07:50:10 <SamB> anyway, you can darcs get http://scannedinavian.org/~boegel/HRay/darcs/hray
07:50:37 <SamB> assuming you aren't blocked from scannedinavian somehow
07:50:59 <Saulzar> I can't access it today it seems
07:51:21 <SamB> huh
07:51:26 <SamB> what country are you in?
07:51:30 <SamB> china?
07:51:35 <Saulzar> NZ
07:51:56 <jethr0> scannedinavian.org is down from here (germany) as well
07:52:08 <jethr0> i'd say it's down irrespective from where you try...
07:52:12 <SamB> huh, that isn't to my knowledge an oppressive country...
07:52:37 <SamB> oh?
07:52:56 <kala> could somebody point me to working Tree example ? 
07:53:09 <ski> (SamB : oh .. i thought CategoryApplication meant CategoryTheoryApplication :)
07:53:15 <SamB> kala: which Tree?
07:53:28 <SamB> people have a habbit of defing their own Trees a lot
07:53:38 <SamB> ski: heh!
07:53:48 <jethr0> kala: http://www.haskell.org/tutorial/modules.html
07:53:50 <kala> SamB: well, any Tree. I could easily find definitions like data Tree a = Leaf a | Node (Tree a) (Tree a), but I'm trouble acutally using this with hugs
07:54:13 <SamB> ski: you are probably one of the people who think CategoryTheory is a category
07:54:18 <SamB> kala: oh, stick it in a file
07:54:26 <SamB> that generally helps
07:54:40 <jlouis> Cat is the category of categories
07:54:50 <ski> SamB : no, it's not a category, it's about categories
07:54:56 <jethr0> anyone have an idea about function overloading when exporting with FFI
07:55:01 <jlouis> with Functors as arrows
07:55:02 <SamB> ski: hehe
07:55:13 <kala> hold on a minute, I'll make appropriate pastebin entry
07:55:33 * ski likes 2Cat
07:55:43 <SamB> jethr0: you can't foreign export something at overloaded type
07:55:54 <SamB> C doesn't support overloaded types
07:56:05 <SamB> well, maybe you could for some other language...
07:56:08 <ulfdoz> int is everything
07:56:28 <jethr0> samb: not on type. on signature!
07:56:50 <SamB> jethr0: signature?
07:56:55 <SamB> explain better!
07:58:16 <jethr0> hmm, i thought c could overload function signatures, like having "int test()" and "int test(int a)" both defined.
07:58:29 <jethr0> but apparently that doesn't work *?!*
07:58:38 <Saulzar> C++ can, C can't
07:58:38 <jlouis> jethr0: its a C++ thing
07:58:40 <SamB> jethr0: what are you implementing?
07:58:43 <jlouis> ISO C can't
07:58:44 <SamB> libc still?
07:58:49 <jethr0> still.
07:59:22 <jethr0> haven't made much progress lately due to not getting my head around file handles, etc in haskell. but now i'm off again ;-)
07:59:25 <kala> http://pastebin.com/447292 - How do I make up more complicated trees than just a leaf? 
07:59:41 <ski> jethr0 : that is not overloading, but old-style function header vs. new-style function prototype
07:59:48 <jethr0> jlouis: so i see. havn't programmed in c for too long a time, it seems.
08:00:27 <SamB> jethr0: you'll need to redo everything that uses System.* to get it to work under House anyways
08:00:40 <SamB> well, assuming it is actually external-system stuff
08:01:04 <jethr0> samb: i _do_ know that, but i don't want to work under house, so i'll implement it this way and _MAYBE_ implement the necessary system calls in house later.
08:01:24 <SamB> jethr0: okay ;-)
08:01:25 <jethr0> at some point one would need system commands in haskell too, so i am hoping for someone else to do that ;-)
08:01:41 <kala> oh, I got it now. "sumTree (Node (Leaf 3) (Node (Leaf 4) (Leaf 4)))" works. :) 
08:01:50 <SamB> jethr0: did you see that GHC provides for reading directly to your own buffers?
08:02:03 <jethr0> no, where? how?
08:02:13 <SamB> @hoogle Buffer
08:02:13 <lambdabot> System.IO.BufferMode :: BufferMode
08:02:13 <lambdabot> Graphics.UI.GLUT.State.BufferDepth :: Int
08:02:13 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects.BufferObject :: BufferObject
08:02:23 <SamB> @hoogle hGetBuffer
08:02:24 <lambdabot> System.IO.hGetBuffering :: Handle -> IO BufferMode
08:02:26 <ski> @index system
08:02:26 <lambdabot> System.Cmd
08:02:32 <SamB> er
08:02:33 <ski> @type System.Cmd.system
08:02:34 <lambdabot> String -> IO GHC.IOBase.ExitCode
08:02:37 <jethr0> hmm, problem is with handles...
08:02:38 * SamB forgets
08:02:54 <SamB> @hoogle Handle -> Ptr a -> IO ()
08:02:55 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
08:02:55 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
08:02:55 <lambdabot> System.IO.hClose :: Handle -> IO ()
08:03:06 <SamB> arg
08:03:09 <jethr0> i need to return "FILE*" to c for file operations and have _NO_ idea how to make a FILE* from a Handle...
08:03:43 <SamB> @hoogle hGetBuf
08:03:43 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
08:03:43 <lambdabot> System.IO.hGetBuffering :: Handle -> IO BufferMode
08:03:43 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:05:05 <SamB> jethr0: oh, you can use any kind of pointer for FILE*
08:05:22 <SamB> you are after all the implementor
08:06:09 <jlouis> jethr0: Keep yourself away from C unless you absolutely need to or are programming operating systems
08:06:44 <jethr0> samb: i know. but i haven't yet found out how i can export a struct definition with FFI (or even whether it's possible).
08:07:00 <jethr0> samb: it's likely that what i am doing is totally bogus, but i got the time, right ;-)
08:07:41 <jethr0> jlouis: i actually like c for quite a few applications. it kind of complements haskell for the bare metal stuff...
08:09:37 <SamB> jethr0: unneccessary
08:09:47 <SamB> use a C header
08:10:13 <SamB> jlouis: we are hoping to port GHC to House or a related OS
08:11:02 <jlouis> interesting
08:11:04 <Oejet> jethr0: You could use handleToCFile from http://www.student.dtu.dk/~s022018/Temporary/ffitutorial.ps
08:11:30 <jlouis> jethr0: well, C has its uses ;)
08:11:58 <jethr0> samb: yeah, i thought about that. i am pondering the matter for a little longer and then decide ;-)
08:13:03 <jethr0> oejet: i've come across that one, but i don't think it help me... hmm, or maybe i wasn't thinking it through *hmm*
08:13:35 <jethr0> but it uses handleToFd from posix, which again has the sideeffect of closing the handle...
08:13:45 <jethr0> it all get's rather tricky at some point *g*
08:14:58 <Oejet> jethr0: Indeed it does.
08:15:24 <jethr0> but maybe it's still viable. as i said, i'll have to think about it a little more...
08:20:14 <SamB> jethr0: typedef struct _FILE FILE; or something
08:22:50 <jethr0> samb: sure. but i considered simply returning the "Handle" to C or something. but couldn't figure out how to return intransparent data to C...
08:23:16 <jethr0> like: typedef FILE void*
08:23:19 <SamB> @index StablePtr
08:23:20 <lambdabot> Foreign.StablePtr, Foreign
08:23:43 <jethr0> ahh, that's what it's good for. but wasn't this a pointer intransparent for haskell?? i think i need the opposite *g*
08:23:51 <SamB> jethr0: no, you don't need to do that.
08:24:01 <SamB> just use an incomplete struct type
08:24:42 <jethr0> hmm, so let's consider this. i want to return the haskell "Handle" to C as "FILE*".
08:24:53 <jethr0> in some way or another...
08:25:13 <jethr0> and when C calls me again i want to reverse the process and get a "Handle" from a "FILE*"
08:25:33 <SamB> jethr0: so, use a StablePtr Haskell-side and an incomplete struct type C-side
08:25:41 <jethr0> ok, cool
08:26:15 <jethr0> i also thought about hashing something and simply returning an int. but i couldn't figure out how to do a global hash table in haskell...
08:26:18 <SamB> hopefully StablePtrs are incomplete struct pointer compatible...
08:26:24 <jethr0> i'm still quite the newbie ;-)
08:26:45 <SamB> jethr0: you are *quite* the newbie ;-)
08:26:56 <SamB> not too many newbies try to implement libc in Haskell ;-)
08:27:20 <jethr0> well, most likely i won't pull it through, anyways ;-)
08:27:39 <jethr0> so don't advertise it all too loudly...
08:27:59 <SamB> it certainly seems unlikely to be usable, except I suppose maybe it would work on Windows as a DLL...
08:28:32 <SamB> though it seems unlikely, unless the RTS is in a seperate DLL
08:28:34 <jethr0> speedwise it will _SUCK_. but on the other hand it is kind of a c-interpreter in haskell, which might have its uses.
08:28:53 <jethr0> well, not interpreter, but one could do traces and stuff.
08:29:07 <SamB> I'm just talking about the fact that it would be tricky to work it so that it would actually link okay
08:29:27 <SamB> because the GHC RTS is going to want the real libc functions of the same names
08:29:37 <jethr0> samb: i'm compiling against c-code already. linking dynamically should work okay.
08:30:05 <SamB> jethr0: but does it link?
08:30:05 <jethr0> no, but in house rts is compiled more or less static against the libs.
08:30:17 <SamB> house RTS will be fine
08:30:26 <SamB> there is no libc on house, after all...
08:30:35 <jethr0> well, you just have to tell the compiler in what order to use the libraries and to use mine topmost!
08:30:41 <SamB> hmm
08:30:49 <jethr0> samb: they have _some_ minimal parts of libc in there
08:30:54 <SamB> but wouldn't the RTS then by linking to yours?
08:30:59 <SamB> s/by/be/?
08:31:03 <jethr0> i am not concerned about linking. but speed will be _horrible_!
08:31:11 <SamB> yes
08:31:16 <SamB> but thats not the point ;-)
08:31:25 <jethr0> samb: i see your point...
08:31:48 <SamB> speed being horrible is comparatively easy to fix
08:32:08 <jethr0> well, maybe there is some linker magic to link different object files to different libs.
08:32:24 <jethr0> hadn't thought about that, but then again it is _really_ for house ^_^
08:35:29 <jethr0> samb: i don't think that what i am doing right now makes any/much sense. that's no reason not to do it though *g*
08:35:43 <kala> can I define trees like this: "data Tree a = Leaf a | Node [(Tree a)]" ? 
08:36:42 <basti_> kala: certainly
08:36:44 <arjanb> yes and you can leave the parentheses out
08:37:36 <kala> but then what about this "sumTree (Node [one_tree:trees]) = sumTree one_tree + sumTree trees"
08:38:31 <kala> hugs thinks that "[one_tree : trees]" doesn't match "[Tree a]"
08:38:40 <ricebowl> try sumTree (Node (one_tree:trees)) = sumTree one_tree + sumTree (Node trees)
08:38:55 <ricebowl> and Hugs would be right ;)
08:39:23 <ricebowl> @ty \[x:xs] -> x
08:39:24 <lambdabot> forall a. [[a]] -> a
08:39:28 <ski> sumTree (Node trees) = sum $ map sumTree trees
08:39:37 <ricebowl> so you have Node [[Tree a]], not Node [Tree a]
08:39:38 <SamB> jethr0: neither do my attempts at Self, apparantly.
08:40:00 <SamB> but MMIX makes even less sense
08:40:01 <jethr0> what are you working on? implementing self in haskell?
08:40:16 <SamB> I haven't worked on it lately
08:40:18 <jethr0> thou speaketh in riddles
08:40:33 <SamB> yes, implementing Self in Haskell was what I meant
08:40:49 <kala> ricebowl: huh, thanks, got it compiling. 
08:40:54 <ricebowl> sumTree (Node trees) = foldl' (\x y -> x + (sumTree y)) 0 trees
08:41:00 <ricebowl> though strictness might not be what you want
08:41:07 <SamB> I haven't figured out how to represent objects correctly yet though
08:41:16 <ricebowl> *nods* np
08:41:20 <SamB> I'm about ready to implement them in C and foreign import them
08:41:43 <SamB> not quite, though
08:42:11 * ricebowl wonders if sum is strict in its arguments
08:43:11 <SamB> ricebowl: that depends
08:43:17 <SamB> try it with Nats
08:43:22 <ricebowl> Nats? What's that?
08:43:34 <SamB> data Nat = Zero | Succ Nat
08:43:43 <astrolabe> sum isn't strict is it?
08:43:44 <SamB> and then the obvious implementation of Num
08:43:45 <ricebowl> oh, yes, I guess it can work on things that aren't integers in the traditional sense
08:44:27 <ricebowl> since I could write data Foo = (Int, Int), implement Num for Foo, and then use sum on it
08:44:36 * ricebowl still forgets these things
08:44:43 <SamB> anyway, the point is, these can be added lazily
08:44:51 <ricebowl> yeah, I see
08:45:19 <SamB> however, for most existing implementations, + is an all-or-nothing proposition
08:45:21 <ricebowl> the point is that sum can take parameters whose type can be a lazy data structure, even if Ints can't be evaluated lazily in that case
08:45:26 <SamB> so sum would end up acting strict
08:45:29 <ricebowl> *nods*
08:49:01 <kala> ok, why I needed "Node trees" in "sumTree (Node (one_tree:trees)) = sumTree one_tree + sumTree (Node trees)"
08:49:20 <ski> kala : to convert the tail list of trees to a tree
08:49:29 <ricebowl> kala - the argument of sumTree has to be a Tree
08:49:32 <ski> kala : sumTree wants one tree, not a list of trees
08:49:48 <kala> and Node trees does exactly that? 
08:49:50 <ski> Node :: [Tree a] -> Tree a
08:49:59 <ricebowl> kala - Node is a constructor for Tree
08:50:04 <ski> Leaf :: a -> Tree a
08:50:06 <kala> oh, yes. Now I see it. Node is a constructor 
08:50:18 <ski> so, it's just rewrapped, here
08:50:24 <ski> you could also do
08:50:34 <ski> sumTree (Node trees) = sumTrees trees
08:50:39 <ski> sumTrees [] = 0
08:50:53 <ricebowl> you could also use fold ;)
08:50:53 <ski> sumTrees (tree:trees) = sumTree tree + sumTrees trees
08:50:57 <ski> right
08:50:58 <ricebowl> or map+sum
08:51:02 <kala> ski: ok
08:51:34 <ricebowl> fold & map make writing Haskell programs *so* much easier :p
08:51:48 <ski> ricebowl : i like that sum+map, since it's not direct recursion, but recursion through 'map' (not even a literal recursive call inside a lambda)
08:52:15 <ricebowl> "through"? Do you mean like it gets hoisted inside?
08:52:27 <ricebowl> i.e. good producer/consumer
08:53:08 <ski> sumTree (Node trees) = sum (map sumTree trees)
08:53:18 <ricebowl> yes
08:53:20 <ski> no 'sumTree (...)' call, there
08:53:23 <ricebowl> I see, you're just commenting on style
08:53:27 <ski> right
08:54:30 * SamB wonders why darcs takes so long to do -l on what came out of a 26-MiB tar.bz2
08:54:31 <ricebowl> @pl let sumTree = id in \x y -> x + (sumTree y)
08:54:31 <lambdabot> (+)
08:54:35 <SamB> er, record -l
08:54:40 <ricebowl> bah. I figured that would happen.
08:54:55 <SamB> you'd think it would be relatively straightforward when starting with an empty repo...
08:56:00 <ricebowl> @pl let data Tree a = Leaf a | Node [Tree a]; sumTree (Leaf _) = 1; sumTree (Node xs) = foldl hlpr xs; hlpr x y = x + (sumTree y) in hlpr
08:56:00 <lambdabot> (line 1, column 57):
08:56:00 <lambdabot> unexpected "_"
08:56:00 <lambdabot> expecting operator or ")"
08:56:12 <ski> @pl \x y -> x + (sumTree y)
08:56:12 <lambdabot> (. sumTree) . (+)
08:56:20 <kala> haskell is a good language. because there is very good irc channel for support :P
08:56:28 <SamB> hehe
08:56:30 <neologism> ;)
08:56:35 <SamB> I think you may have that backwards
08:56:42 <SamB> but perhaps not
08:56:42 <ricebowl> Haskell is a good language because it makes coding simpler instead of more difficult ;)
08:57:03 <ricebowl> ski - at least @pl is good for writing obfuscated Haskell
08:58:31 <ski> @pl \x y -> sumTree x + y
08:58:32 <lambdabot> (+) . sumTree
08:58:37 <ski> nicer
08:59:05 <ricebowl> won't work
08:59:20 <ski> if you flip
08:59:24 <ricebowl> but you could do (+) . sumtree . flip
08:59:25 <ricebowl> right
08:59:38 <ski> @type (+) . sumtree . flip
08:59:38 <lambdabot> Not in scope: `sumtree'
08:59:59 <ski> @type \(sumtree :: [Int] -> Int) -> (+) . sumtree . flip
09:00:00 <lambdabot>   Expecting a function type, but found `b'
09:00:00 <lambdabot>   Expected type: (a -> b -> c) -> [Int]
09:00:16 <ski> @type \(sumtree :: [Int] -> Int) -> flip ((+) . sumtree)
09:00:17 <lambdabot> ([Int] -> Int) -> Int -> [Int] -> Int
09:00:22 <ricebowl> @type let data Tree = Blah; sumTree x = 0 in (+) . sumTree . flip
09:00:23 <lambdabot> parse error on input `data'
09:00:32 <ricebowl> blah.
09:00:34 <ski> so, 'flip ((+) . sumtree)'
09:00:41 <ricebowl> ah, that works
09:01:37 * ski wonders whether any of the haskell debuggers support walking inside a function, giving values to free vars, and calling local functions
09:03:13 <ski> (or even, calling the function and stepping inside and then call local functions, could possibly work)
09:06:16 <SamB> ski: that would be sweet
09:09:20 * jethr0 would love having such a debugging functionality
09:09:35 <jethr0> but then again there is no "time" inside haskell ;-(
09:12:05 <ski> jethr0 : so ?
09:13:43 <jethr0> well, it means you can't just witness the interpreter doing it's job, because the evaluation could be totally chaotic.
09:14:10 <jethr0> lazy evaluation and voyeuristic debugging are hard to combine!
09:14:41 <ski> i wasn't really suggesting stepping
09:14:52 <ski> just some way to access and test locally defined stuff
09:14:57 <jethr0> what did you mean by "walking"
09:15:09 <ski> (it's irritating to hoist out stuff just to test them)
09:15:27 <jethr0> that would be _REALLY_ nice. i've been very annoyed by this, too!
09:15:30 <ski> jethr0 : (: well, that was in case of a stepper
09:15:47 <ski> but, it should be doable without a stepper
09:16:04 <musasabi> something like Buddha, but with good support to monads and various extensions would be nice.
09:16:23 <jethr0> mainly, what would be needed is some kind of naming scheme for local funcs...
09:16:47 <sieni> musasabi: searching for a new deity?
09:17:07 <jethr0> like "mainfunc..subfunc" for "mainfunc = let subfunc = 4 in 5"
09:17:23 <musasabi> who needs deities when there are the old ones to worship
09:17:36 <ski> hm, actually, we'd need some way of referring to clauses
09:17:50 <jethr0> i thought buddha renamed themselves to "asdlksdjf"?
09:18:08 <jethr0> ski: that's true
09:18:10 <ski> IÄ IÄ, Shub-Niggurath !
09:18:44 <jethr0> we'd need to navigate through "let" and "where".
09:19:04 <jethr0> and nested local definitions
09:19:09 <ski> well, just getting at things in top where would be an improvement
09:19:19 <musasabi> jethr0: just lifting them to toplevel solves things.
09:19:40 <ski> possibly one could omit giving value to a var, if it's not intransitive closure of the local thing one tests
09:19:49 <jethr0> musasabi: yes, but maybe they were fine where they stood before. and lifting just for debugging _sucks_
09:20:10 <musasabi> jethr0: that is why the debugger should do it transparently.
09:20:33 <jethr0> ahh, ok. but then you might run into name clashes, no?
09:20:35 <ndm> musasabi: have you taken a look at hat?
09:21:00 <ndm> it has lots of modes, some like budda, some like hood and some entirely different
09:21:10 <ndm> and it lets standard haskell through perfectly, without modification :)
09:21:11 <musasabi> jethr0: generating unique names is quite easy + renaming (and displaying the original source to user)
09:21:43 <jethr0> hmm
09:21:48 <musasabi> ndm: I have tried hat a few times, but didn't get anything solved by it.
09:22:00 <musasabi> buddha worked very well for pure Haskell98 code.
09:22:25 <musasabi> => sauna
09:22:52 <ndm> musasabi, what were you trying to do?
09:22:59 <ndm> there is a nice overview of the hat tools now
09:24:31 <ndm> and in a few weeks, yhc should have integerated hat trace generation
09:25:27 <malcolm> ndm: where is the nice overview?
09:25:40 <astrolabe> malcolm: you beat me to it.
09:25:41 <ndm> malcolm: bob's page, although i can't find a link...
09:26:09 <malcolm> ndm: oh the one with all the cute pictures of different hats
09:26:13 <ndm> http://www.cs.kent.ac.uk/people/rpg/tatd2/icons/
09:26:30 <astrolabe> thank you
09:26:38 <ski> hehe
09:26:46 <ndm> a plan was to have a brief description of every tool on that page, then link to a detailed description of the tool (man page), and a tutorial on each one
09:27:20 <araujo> Is there a way to share two variables between two different pattern-matchs of the same function?
09:28:22 * ski assumes araujo means s/pattern-matchs/clauses/
09:28:47 <ski> and the answer is no .. ('local' would have been nice here, in smoe circumstances)
09:28:59 <ski> araujo : do they depend on arguments ?
09:29:09 <Philippa> you can dispatch all the parms to a function defined in a where clause
09:29:15 <ski> if so, always same arguments ?
09:29:16 <ski> yes
09:29:19 <araujo> ski, yes
09:30:22 <araujo> I talk abut pattern-matchs , because the tail of the pattern-matching of the clauses will be used for calculating the two variables.
09:30:30 <ski> map f = loop
09:30:32 <ski>   where
09:30:38 <ski>   loop [    ] = []
09:30:45 <ski>   loop (a:as) = f a : loop as
09:31:01 <ski> if you follow that style, you can define things depending on f
09:31:57 <araujo> mm...
09:33:23 <araujo> i want something like: f ('|':xs) = fa x ; f('$':xs) = fb x; where x = fc xs
09:34:03 <ski> f (c:xs) = case c of
09:34:10 <ski>   '|' -> fa x
09:34:16 <ski>   '$' -> fb x
09:34:19 <ski>   where
09:34:22 <ski>   x = fc xs
09:34:29 <ski> like that ?
09:34:31 <araujo> I see , thanks ski :-]
09:35:05 <araujo> mm... hell... 
09:35:13 <ski> hi TheHunter_
09:35:51 <araujo> ski, well, the patter matching might be irregular, i mean, it might be ('|':xs)  , ('|':'@':xs) ....
09:36:28 <araujo> I just wanna see if i avoid duplicating code , or probably writing a separate function for this.
09:36:35 <araujo> can*
09:36:55 <ski>   where
09:37:00 <ski>   foo xs = ...xs...
09:37:11 <ski> and then use 'foo xs' in each branch ?
09:37:16 <TheHunter_> morning ski
09:37:45 * ski tries some ideas with TheHunter_'s monadic reflection
09:37:48 <jethr0> where can i find "sleep" in haskell?
09:37:55 <ski> @index sleep
09:37:56 <lambdabot> System.Posix.Unistd, System.Posix
09:38:07 <araujo> jethr0, we don't "sleep" in haskell :-P
09:38:08 <jethr0> thx, gotta learn to use the l'bot
09:42:41 <Philippa> araujo: we're too lazy to sleep?
09:42:48 <SamB> araujo: really? what kind of lazy language doesn't sleep?
09:43:17 <ski> @sleep
09:43:18 <lambdabot> Lately, I have seen philippa, samb and ski.
09:43:24 <ski> err
09:43:32 <araujo> Philippa, haha, that's it :-)
09:43:46 <SamB> lambdabot needs a longer "lately"
09:43:58 * ski wonders how short time lambdabot considers 'lately' to be
09:44:21 <SamB> looks like less then five minutes...
09:44:46 <SamB> maybe 1 minute?
09:45:30 <jethr0> ehh
09:45:48 <ski> @seen kbot
09:45:48 <lambdabot> I saw kbot leaving #flippi, #haskell-blah and #haskell-overflow 2 days, 3
09:45:48 <lambdabot> hours, 44 minutes and 42 seconds ago, and I have missed 7 minutes and 14
09:45:48 <lambdabot> seconds since then.
09:46:12 <jethr0> any ideas how to convert an Integral to CInt explicitely (i.e. not with fromIntegral)
09:46:22 <SamB> jethr0: that is explicit
09:46:33 <SamB> to be more explicit, use type signatures
09:46:42 <jethr0> not if the receiver expects "a" and not "CInt"
09:46:55 <SamB> i.e.:
09:47:05 <SamB> (fromIntegral x :: CInt)
09:47:23 <ski> (type ascription also works, yes)
09:47:48 <SamB> ski: that looks like a type signature to me
09:48:01 <jethr0> ah
09:48:02 <ski> signatures are declarations
09:48:24 <ski> > (1 :: Int) + 2
09:48:25 <lambdabot> 3
09:48:26 <SamB> "type ascription" is a bit too high-falutin a term for me
09:48:35 <SamB> mainly because I don't know what it means
09:48:58 <ski> you ascribe a type to an expression, thus constraining it to have that type, and get back an expression
09:49:08 <SamB> well, okay.
09:49:17 <SamB> but why can't we call that a type signature too?
09:49:53 <ski> you could, but strictly speaking, it's an ascription
09:50:16 <SamB> well, haskell is lazy! and I don't particularly care!
09:50:39 * ski thinks SamB means the other way around
09:50:56 <SamB> and I'm using too many exclamation points!
10:06:09 * basti_ 's brain has the consistency of spinach after now 2 days of seminar talk last stage ^^
10:16:07 <SamB> jlouis: could you explain couldGet to me?
10:29:36 <twb> How do I exit a haskell program with a success/fail value?
10:29:55 <ski> @index exitWith
10:29:55 <lambdabot> System.Exit
10:29:57 <SamB> @type System.Exit.exitWith
10:29:58 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
10:30:03 <SamB> @type System.Exit.ExitSuccess
10:30:04 <lambdabot> GHC.IOBase.ExitCode
10:30:08 <SamB> @type System.Exit.ExitFailure
10:30:09 <lambdabot> Int -> GHC.IOBase.ExitCode
10:30:20 <twb> Thank you.
10:30:58 <twb> Using quickcheck, if a test fails, will the program exit with a failure value?
10:33:25 <twb> Or more generally, how can I write tests that darcs can run prior to committing?
10:34:40 <SamB> well, it depends how you run the tests
10:34:43 <ski> @get-shapr
10:34:44 <lambdabot> shapr!!
10:36:01 <ski> (he should prolly know, i think .. he's experimented with getting quickcheck to save failing tests to check later, e.g.)
10:37:35 <twb> There's a pythonite at work, and he's mostly convinced me on the whole "test-driven" thing.
10:38:35 <SamB> quickcheck is definately a good idea
10:38:42 <twb> Mmm.
10:38:48 <SamB> I just fixed some code that was failing its test in conjure ;-)
10:38:52 <twb> But I want darcs to be able to talk to it.
10:39:19 <SamB> well, even just having it run the tests is helpful...
10:39:38 <SamB> but yes, I can see why you'd want darcs to know if they failed
10:39:41 <twb> But if I can't commit until I fix a bug, it will encourage me to fix the bug :-)
10:40:10 <SamB> well, there is --no-test
10:40:18 <twb> sssh.
10:41:42 <SamB> which is lovely when you just changed docs or when you are changing a number of little things (in their own patches) on a slow computer
10:42:06 <twb> I notice the docs talk about "a flag +names".
10:42:15 <twb> Is it the case that Haskell has &optional arguments?
10:42:27 <jlouis> SamB: I have not read source on couldGet yet
10:42:36 <jlouis> it is ADEpts
10:42:50 <SamB> jlouis: it isn't a function, its an arg
10:43:07 <SamB> I think I got the test passing now
10:43:18 <jlouis> ok
10:43:26 * SamB could of sworne it had passed the last time he said that too, though
10:43:30 <kala> I'm having troubles with some complicated (at least to me) tree operations. Given the code, why do I get the following error message? http://pastebin.com/447441
10:44:08 <SamB> also, I jacked up the size of the InterestTables used in tests
10:44:37 <SamB> by using mkTable (n*5+1) instead of mkTable (n+1)
10:44:45 <twb> Oh, silly me.  That is for a standalone script.
10:45:35 <SamB> "optional" args are done with Maybe
10:45:44 <SamB> varargs with []
10:46:51 <kala> uh, solved the problem again myself, after pasting the code to IRC ;)
10:47:03 <SamB> kala: cool
10:47:44 <SamB> kala: in future, you could mention juicy details of your problems to entice people to help you ;-)
10:51:02 <jethr0> is there a quick way to un-IO-ify _two_ values like: (a,b) <- (unIO a, unIO b)?
10:51:18 <jethr0> sorry, gotta go
10:51:31 <SamB> (a,b) <- liftM2 (,) a b?
10:52:04 <Korollary> heh.
10:52:15 <SamB> also a <- a; b <- b
10:52:36 <Korollary> yes, the pair on the left is not really useful.
10:57:17 * SamB makes sure to send
11:00:08 <SamB> jlouis: got it?
11:06:39 <jlouis> SamB: got what?
11:06:43 <jlouis> a patch?
11:06:50 <SamB> jlouis: 3
11:07:00 <jlouis> cool, 3 patches
11:07:54 <jlouis> (!)
11:09:34 <SamB> If it weren't for needing to name them, I'd probably have done one patch with less stuff in it...
11:09:58 <SamB> or do I mean if it weren't for record being so easy?
11:12:59 <jlouis> cool!
11:13:15 <jlouis> (I do not care about having a hard time with darcs apply)
11:13:31 <twb> No joy on the darcs/quickcheck front :-/
11:13:57 <phys_rules> hoi guys!
11:14:07 <musasabi> evening
11:14:30 <phys_rules> musasabi: I compiled ghci with readlines now, so ghci is finally usable =)
11:14:39 <twb> phys_rules: M-x run-haskell :P
11:14:47 <twb> M-p / M-n
11:14:58 <musasabi> mm -tasty :-)
11:15:04 <phys_rules> no, no, I'm trying to forget emacs LOL :)
11:15:51 <twb> phys_rules: why?
11:15:59 <phys_rules> I get the impression that ghc is working faster on solaris than on windows...
11:16:40 <phys_rules> twb: Been too much into emacs, then found the joy of IDEs with intelligent features, don't want to go back to emacs anymore =)
11:16:57 <twb> Bah.
11:17:10 <twb> So you were using Emacs for editing files?
11:17:14 <phys_rules> yep
11:17:17 <twb> That seems pretty silly.
11:17:27 <phys_rules> when I was coding C/C++
11:17:33 <twb> Oh gods.
11:17:41 <twb> C++ support in Emacs is dog shit.
11:17:50 <twb> Even with ECB and semantic.
11:17:51 <SamB> hehe
11:18:04 <phys_rules> well, it was about 7 years ago =)
11:18:16 <SamB> it goes better with the C++ that way ;-)
11:19:12 <twb> Emacs actually sucks pretty hard.  But everything else I've seen sucks more.
11:19:21 <SamB> jlouis: apply? sych?
11:20:04 <SamB> twb: you've got to be kidding. emacs has more ways to suck than anything else on the planet!
11:20:34 <phys_rules> twb: I loved PsPad for editing simple files, and for tex but that's for windows, for java IDEA is unbeatable, for C/C++ Microsoft's Visual Studio is not too bad especially with some good plugins
11:20:40 <phys_rules> and for haskell...well
11:21:02 <twb> I refuse to believe that people actually write C++ or Java.
11:21:15 <twb> Just as I refuse to believe that people still use Windows.
11:21:15 <phys_rules> I wrote a lot of java =)
11:21:19 <phys_rules> and a lot of c
11:21:22 <phys_rules> and even more java
11:21:23 <phys_rules> =)
11:21:41 <twb> Any evidence to the contrary is simply a statistical anomaly.
11:22:03 <Oejet> twb: Or a conspiracy.
11:22:07 <SamB> twb: well, people still write C++
11:22:12 <phys_rules> yes, conspiracy ;)
11:22:33 <SamB> but I have trouble believing people ever wrote Java
11:22:33 <phys_rules> twb: haskell rocks though ;)
11:22:54 <twb> Yeah, haskell is a better compromise than python.
11:22:55 <phys_rules> SamB: it's a very clean oop language and it's easy to maintain very large projects
11:23:05 <twb> Java is not OO.
11:23:07 <SamB> its not easy
11:23:13 <SamB> its too long-winded
11:23:13 <phys_rules> not easy ?
11:23:14 <twb> CLOS is OO.
11:23:17 <phys_rules> very easy
11:23:22 <SamB> C++ is even less OO than Java
11:23:33 <twb> C++ and java are just pale clones of OO.
11:23:47 <phys_rules> SamB: yes, java programs might be long but as I said it's very easy to code large applications with large amount of developers
11:23:52 <SamB> I thought Java was genuine, but just overly restricted, OO?
11:24:07 <phys_rules> depends on your definition of OO ;)
11:24:08 <SamB> phys_rules: oh, that
11:24:08 <twb> SamB: well, that's the optimistic version.
11:24:13 <SamB> who cares?
11:24:21 * SamB never has that many developers
11:24:39 <Oejet> phys_rules: Could you repeat that please?  It's very easy to code large applications with large amounts of developers?
11:24:44 <franka> Hey, what is this Platonic ideal of OO, anyway?
11:24:51 <franka> Everybody talks about it with such reverence.
11:24:54 <phys_rules> SamB: imagine 20-30 developers coding on haskell, one preferring point free, the other do notation, the other monads etc.. and it's going to be very hard to understand the code
11:24:59 <SamB> Smalltalk is where its at.
11:25:02 <franka> And yet they've never seen it.
11:25:26 <twb> phys_rules: so instead we force *evereyone * to use a style that *no one* likes!
11:25:30 <SamB> Self is where it ought to be, but isn't, because the implementation won't run on anything but a SPARC or PPC, iirc
11:25:45 <phys_rules> Oejet: why ? =)
11:25:45 <SamB> (it crawls on x86, when it executes at all)
11:25:53 <twb> franka: it's called CLOS
11:25:57 <phys_rules> SamB: Java is not for client apps
11:26:03 <SamB> phys_rules: ah
11:26:05 <franka> Ah... CLOS.  So, why are you on #haskell?
11:26:07 <SamB> that would explain a lot
11:26:08 <phys_rules> SamB: for web side and for specific tools for developers
11:26:16 <twb> franka: because I hate OO.
11:26:20 <SamB> franka: because Haskell doesn't even pretend to be OO?
11:26:29 <SamB> twb: maybe you just hate CLOS?
11:26:35 <phys_rules> like IDEA, Eclipse, various frameworks for the web ...
11:26:36 <franka> And yet you talk of OO with such reverence.
11:26:37 <twb> No, I hate OO.
11:26:51 <twb> But I hate CLOS less than any other OO system, except maybe smalltalk's
11:26:57 <franka> "pale clones of OO"
11:27:09 <phys_rules> SamB: And I would NEVER use a java mp3 player or a java video player or even a java IM :)
11:27:09 <SamB> you keep identifying OO with CLOS, and yet claim that you don't just hate CLOS
11:27:14 <Oejet> phys_rules: I'ts never easy to code large applications with many developers.  That's why you have managers. ;-)
11:27:15 <twb> Kay is on record as saying that C++ is not OO.
11:27:21 <phys_rules> SamB: because it would it too much of my memory
11:27:30 <phys_rules> Oejet: easier than let's say in C or C++
11:27:35 <SamB> phys_rules: who would write #1 or #2?
11:27:40 <phys_rules> it=eat sheesh =)
11:28:02 <SamB> easier than C or C++ isn't saying a whole lot
11:28:24 <SamB> thats like saying its easier than building the pyramid with toothpicks for levers
11:28:36 <SamB> s/the/a/
11:28:57 <phys_rules> SamB: Easier to understand code (well modularized), easier to write (clean syntax), easier to maintain and develop (good tools available)
11:29:05 <twb> SamB: how big are the toothpicks?
11:29:16 <SamB> twb: typical toothpick sized
11:29:19 <twb> Java syntax is not clean.
11:29:26 <phys_rules> twb: it's clean to me ;)
11:29:36 <twb> Forth and Lisp syntaces are clean.
11:29:40 <SamB> maybe its like saying its easier to use chopsticks than toothpicks...
11:29:50 <SamB> Forth? clean?
11:29:52 <Oejet> phys_rules: Did you ever read someone elses Java-code?
11:29:54 <SamB> words can parse!
11:29:55 <twb> Yes.
11:29:58 <SamB> how is that clean?
11:30:00 <phys_rules> Oejet: of course
11:30:06 <twb> SamB: Huh?
11:30:10 <phys_rules> Oejet: I worked in companies with 30+ devs
11:30:14 <phys_rules> working on the same project
11:30:26 <SamB> twb: I said: words can parse! how is that clean?
11:30:30 <twb> SamB: you can define the Forth evaluation rule in three lines of Haskell.
11:30:51 <SamB> twb: hmm, but the syntax is more than the core of a parser
11:30:56 <int-e> words in forth can change the semantics of the parser - by implementing their own parser.
11:31:10 <twb> SamB: what is the forth syntax, then?
11:31:15 <int-e> (that's around the point where I stopped looking at forth)
11:31:23 <SamB> twb: it is an ill-defined syntax
11:31:30 <twb> SamB: what part?
11:31:58 <SamB> okay, it is a dynamically modifiable syntax
11:32:02 <twb> A word matches [^ \n\t]+.
11:32:18 <twb> If the word is in the dictionary, evaluate it's defintiion.
11:32:30 <twb> Otherwise, try to turn it into an integer and put it on the stack.
11:32:42 <Oejet> phys_rules: I really would like to hear about you experiences.  Perhaps in #haskell-blah?
11:32:50 <SamB> does that mean I can put 1 in the dictionary?
11:32:55 <twb> That's just about the entirety of the forth syntax.
11:33:10 <twb> SamB: yes.
11:33:27 <twb> SamB: Note that "clean" does not imply "safe".
11:33:36 <SamB> thats absolutely disgusting
11:34:09 <twb> But it fits into 4kb.
11:34:26 <int-e> a lot of things fit into 4kb if you try.
11:34:27 <flux__> hm, I've never done any forth, except for setting up a sparcstation, but a language where you can redefine numbers, now that's cool!
11:34:29 <twb> That is, the entire environment.
11:34:29 <SamB> true!
11:34:30 <flux__> ;)
11:35:08 <SamB> int-e: a haskell interpreter?
11:35:10 <twb> flux__: you don't redefine a number, you define a symbol.  Some symbol happens to overlap with the symbols that can become integers.
11:35:27 <twb> Er, s/symbol/word
11:35:41 <twb> But that's a bit pedantic.
11:36:02 <flux__> twb, well, but numbers sort of have a predefined meaning because they have the special function of being converted into integers by the internal conversion function?
11:36:28 <flux__> so infact you could think there's no conversion happening, but there are integers -inf..inf predefined in the dictionary
11:36:32 <twb> flux__: Effectively yes, but the spec is worded differently.
11:37:05 <phys_rules> back
11:37:44 <int-e> SamB: hmm. The syntax isn't so bad ... the problem would be fitting the IO monad in. At least that's what I think.
11:38:41 <SamB> @where harrorth
11:38:42 <lambdabot> I know nothing about harrorth.
11:39:00 <int-e> SamB: I won't try though, I don't have an application for it. It'd not be very efficient.
11:39:01 <SamB> @where+ harrorth http://perlcabal.org/~nothingmuch/harrorth/
11:39:02 <lambdabot> harrorth ~> http://perlcabal.org/~nothingmuch/harrorth/
11:39:38 * SamB googled for Forth in Haskell and got http://perlcabal.org/~nothingmuch/harrorth/doc/02.kwid
11:40:03 <twb> If you want to see something scary, http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html
11:43:11 <SamB> that doesn't let combinators parse more input, though
11:45:15 <int-e> "Many programs first construct another program which is then executed."
11:45:22 <SamB> so?
11:45:47 <int-e> it's a bit scary (yes, it doesn't change the syntax_
11:45:52 <SamB> you get that in Haskell too
11:46:50 <int-e> Hmm. We could think of IO 'values' as programs and say that every Haskell program does that.
11:48:08 <SamB> yes
11:48:16 <SamB> I was thinking of IO values as programs
11:48:27 <SamB> I was also thinking of my BF interpreter
11:50:10 <SamB> hmm, this one doesn't work right
11:56:04 <twb> Any quicktest users about?
11:56:31 <twb> I'm wondering how to group tests.
11:56:34 <ndm> twb: QuickCheck?
11:56:41 <twb> ndm: Er, yeah.
11:56:47 <ndm> group?
11:57:02 <twb> So I can say "QuickCheck allTests"
11:57:08 <twb> Or similar.
11:57:35 <ndm> I just write out
11:58:10 <ndm> mapM_ (test prop1, test prop2, test prop3)
11:58:21 <twb> I initially thought "map quickCheck [test1,test2,...]", but the tests have different formal parameters.
11:58:23 <ndm> mapM_ [test prop1, test prop2, test prop3] (ahem :))
11:58:39 <ndm> twb, yeah, i couldn't think of anyway to get round that
11:58:56 <twb> hunit gets around it by wrapping them in an object, I think.
11:59:11 <twb> Er, no.
11:59:22 <ndm> then you'd need higher order types or something, forall maybe?
11:59:27 <twb> It gets around it because it lists them after doing the tests, as you have done above.
11:59:28 <ndm> and no longer be haskell98
12:00:08 <ndm> could you define an operation, +++++ or something, that did that automatically with the typeclass?
12:00:20 <twb> I don't know.
12:00:29 <ndm> i think its possible
12:00:38 <Cale> jlouis: I think it was possibly a nick completion problem, followed by my own confusion :)
12:04:45 <lisppaste2> twb pasted "What am I doing wrong here?" at http://paste.lisp.org/display/14259
12:07:30 <twb> ERROR "solution.lhs":39 - Unresolved top-level overloading
12:07:30 <twb> *** Binding             : quickChecks
12:07:30 <twb> *** Outstanding context : Testable (IO ())
12:09:05 <Cale> hmm
12:10:40 <Cale> @type Test.QuickCheck.quickCheck
12:10:41 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
12:11:07 <Cale> @type Test.QuickCheck.test
12:11:08 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
12:11:18 <Cale> you don't want to apply both, I don't think
12:11:46 <twb> ndm said to!
12:13:00 <palomer> someone remind me, what odes the type IO () represent?
12:13:11 <palomer> oh, right, it's a unit IO
12:13:11 <twb> nfi
12:13:13 <Cale> an IO action
12:13:23 <palomer> the IO type is parametrized
12:13:27 <SamB> something that does something that doesn't have an interesting result
12:13:29 <Cale> with no interesting result to speak of :)
12:13:31 <palomer> and () is the parameter, right?
12:13:33 <Cale> yeah
12:13:39 <ndm> twb: ndm is usually wrong :)
12:13:45 <SamB> hehe
12:13:46 <palomer> that's what I wanted to know:o
12:13:46 <Cale> @type ()
12:13:48 <lambdabot> ()
12:13:59 <SamB> @type return ()
12:14:00 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
12:14:01 <palomer> you'll confuse newbies if you introduce expressions like "IO action"
12:14:05 <twb> ndm: can you check how you are doing it in real source code?
12:14:24 <twb> palomer: I'm not a newbie!  I've been here all day!
12:14:31 <ndm> sequence_ [quickCheck a, quickCheck b]
12:14:31 <SamB> heh
12:14:40 <palomer> I'm the newbie
12:14:52 <twb> ndm: works!
12:14:58 <Cale> heh
12:15:02 <Cale> why not just use do?
12:15:11 <SamB> I thought you were a newbie for at least a month unless you suddenly remembered you already knew Haskell...
12:15:15 <Cale> do quickCheck a; quickCheck b
12:15:58 <palomer> I've been a newbie for at least 2 months
12:16:05 <Cale> Everyone starts at 50 kyu. After they've written their first compiling program, they're 30 kyu.
12:16:09 <twb> Cale: well actually I want to compose tests into a bigger test.
12:16:15 <palomer> and when I have exams coming up, it sucks the life out of me
12:16:24 <palomer> so I simply muck around instead of doing anything interesting
12:16:26 <palomer> (I don't even study)
12:16:43 <SamB> were you a newbie before that?
12:16:54 <palomer> oh yes
12:17:01 <twb> Cale: kyu?
12:17:03 <SamB> the 2 months
12:17:15 <palomer> ok, I've been a newbie for more than 2 months
12:17:17 <moonlite> does anyone know of any small System.Posix.Signals examples?
12:17:24 <palomer> I've never written a single line of haskell code
12:17:35 <twb> palomer: I'll help!
12:17:36 <moonlite> the docs at www.haskell.org wasn't very informative
12:17:41 <twb> palomer: say "id x = x"!
12:17:47 <Cale> twb: I'm mimicking the rating system used in Go and martial arts
12:17:59 <SamB> what is a yu?
12:18:00 <palomer> twb: doesn't work in ghci
12:18:00 <phys_rules> main = putStrLn "Yo"
12:18:08 <twb> Cale: oh.  I'm not a martial Go artist.
12:18:14 <phys_rules> palomer: write that and you're upgraded =)
12:18:19 <SamB> and why do you lose 20,000 of them when your program compiles?
12:18:39 <twb> SamB: I think it's like golf.
12:18:43 <SamB> twb: that sounds like a Ranma episode
12:18:46 <twb> SamB: 0 kyu is "top of the mountain"
12:19:00 <palomer> I don't belong in academia, it's so stiffling!
12:19:09 <twb> *academentia
12:19:12 <Cale> well, usually it goes from 1 kyu to 1 dan
12:19:18 <Cale> without a zero
12:19:28 <SamB> what is dan?
12:19:31 <Cale> then 2 dan, 3 dan, etc
12:19:33 <palomer> and damnit, I don't want to be a programmer
12:19:35 <Cale> positive skill :)
12:19:39 <palomer> what options are there left:O!
12:19:45 <SamB> palomer: are you going into the arts, then?
12:20:04 <twb> palomer is gonna be a lawyer and take everyone's money.
12:20:37 <phys_rules> palomer: physics!!
12:20:43 <phys_rules> the best option =)
12:20:43 <palomer> I'm no artist
12:20:54 <palomer> I really do shine in academia, but  I'm getting disgusted
12:21:05 <SamB> noveling?
12:21:42 <palomer> I need a little life experience before writing a novel
12:22:13 <SamB> write speculative fiction!
12:22:52 <SamB> or, you could fork academia!
12:23:27 <palomer> ho hum
12:23:37 <palomer> they should have monasteries where people go and live chaste
12:23:38 <lispy> so i thinks to myself, "self, you should make sure you know how to use haskell on win32."  So I goes out and a downloads latest ghc release for windows.  I installs it.  Now what do I do?  I opened a command line but ghc is not found....
12:23:41 <palomer> and are able to create whatever they want
12:23:58 <SamB> lispy: windows is always like that
12:24:14 <twb> palomer: they do have them.
12:24:18 <SamB> you need to get it in path somehow
12:24:21 <phys_rules> lispy:  just set the path
12:24:26 <lispy> ah
12:24:27 <palomer> hrm, what do you guys think of "technical writer"?
12:24:34 <lispy> so i have to reboot? ;)
12:24:34 <twb> palomer: we call them computer labs.
12:24:35 <SamB> twb: where
12:24:40 <SamB> oh
12:24:46 <palomer> twb: computer labs don't take care of my basic needs
12:24:48 <SamB> what about the "live" part
12:24:53 <SamB> and the "eat" part
12:24:54 <twb> palomer: which basic needs?
12:25:00 <phys_rules> right click on my computer -> properties -> advanced -> environm. settings
12:25:02 <phys_rules> and change path there
12:25:05 <phys_rules> you don't have to reboot
12:25:06 <palomer> eating and sleeping
12:25:06 <eivuokko> Open control panel, open system, take advanced, take environment variables.
12:25:12 <SamB> and the "hard drive of my own" part
12:25:26 <twb> palomer: you can eat and sleep in computer labs.
12:25:27 <eivuokko> phys, that only works if user has My Computer on desktop :)
12:25:38 <palomer> twb: but the food won't be supplied
12:25:41 <phys_rules> eivuokko: nope, works from Start as well ;)
12:25:52 <syntaxfree> ah, yes, the wonders of free housing @ graduate school.
12:25:55 <twb> palomer: you don't have vending machines?
12:25:58 <syntaxfree> free housing = under your computer desk.
12:26:05 <SamB> twb: they all charge money
12:26:05 <ICanWaterMyPlant> Caralho, quanta gente.
12:26:05 <palomer> twb: where will the money come from?
12:26:11 <eivuokko> phys, Start-menu doesn't need to contain My computer either, but yeah :)
12:26:14 <twb> palomer: the money comes from vending machines.
12:26:16 <lispy> thanks for the path info
12:26:26 <SamB> twb: you can't just open them
12:26:28 <twb> With the help of Mr. Crowbar.
12:26:29 <phys_rules> eivuokko: well, one can remove system.cpl from control panel as well =)
12:26:32 <lispy> i added it to the system path, restarted "cmd.exe" and it finds ghc
12:26:52 <twb> eivuokko: you are running Debian?
12:26:56 <syntaxfree> ghc installed trivially in the windows box i tried.
12:26:56 <SamB> wouldn't it be easier to hotwire your ID card to have infinite money?
12:27:00 <eivuokko> phys_rules, Heh.
12:27:06 <lispy> so what are the choices for cross platform gui with haskell?  wxHaskell?
12:27:09 <syntaxfree> i made the mistake of installing ghc from fink when i first did it on the mac box.
12:27:11 <ICanWaterMyPlant> syntaxfree Diego?
12:27:12 <eivuokko> twb, Is that a trick question?
12:27:14 <twb> SamB: crowbars are cheaper than magcard writers.
12:27:19 <phys_rules> lispy: gtk2hs, wxhaskell
12:27:23 <SamB> twb: hmm
12:27:23 <twb> eivuokko: it would explain the lack of desktop.
12:27:24 <SamB> true
12:27:29 <syntaxfree> the downloaded installer is vastly superior.
12:27:29 <palomer> twb: I don't think you understand vending machines
12:27:36 <SamB> and the crowbars don't leave your ID in logs, either
12:27:38 <superibor> hi, can anyone point me to Bird's problem of searching the max node in a tree in one pass ?
12:27:38 <syntaxfree> s/downloaded/downloadable.
12:27:38 <lispy> phys_rules: i don't think gtk2hs does osx natively, does it?
12:27:52 <SamB> but, how do you avoid breaking the machine?
12:27:54 <syntaxfree> ICanWaterMyPlant: :*
12:28:04 <twb> lispy: GTK has no native Cocoa interface yet...
12:28:08 <SamB> and how do you avoid getting caught if you sleep in the lab?
12:28:09 <phys_rules> lispy: I think there is gtk for osx, no ?
12:28:17 <phys_rules> ah, no, ok :)
12:28:23 <twb> SamB: what do you mean "caught"?
12:28:26 <superibor> I got Bird's book here but can't find it, is it in the book anyway?
12:28:28 <eivuokko> twb, I suppose it was joke of somekind.  I didn't get it, sorry.  (FWIW, I use Debian as well)
12:28:46 <twb> eivuokko: what are you using, NT5?
12:28:50 <twb> Er, NT4.1
12:29:02 <twb> No no, it is 5.
12:29:04 <lispy> how can i find out which libraries came with the windows installation?
12:29:13 <twb> avalon is NT 5.2
12:29:15 <lispy> and how would i add more libraries?
12:29:15 <ICanWaterMyPlant> syntaxfree For some unknown reason, I dont see the "s" for plantS. :'(
12:29:19 <SamB> twb: sooner or later, someone will notice that the machine you raided is broken
12:29:26 <syntaxfree> samb: they can't punish you for sleeping in the lab.
12:29:32 <twb> SamB: and then they fix it!
12:29:37 <twb> SamB: isn't it a brilliant plan?
12:29:37 <syntaxfree> ICanWaterMyPlant: nickname length restrictions, babe.
12:30:00 <SamB> twb: no!
12:30:09 <SamB> they will wonder who did it!
12:30:12 <twb> ICanWaterMyPlant: don't listen to him; it's because NickServ hates you.
12:30:22 <SamB> they might even decide to take away all the vending machines at the lab
12:30:25 <twb> SamB: not minimum-wage vending machine restockers :-)
12:30:31 <eivuokko> twb, Windows xp pro...I don't call them fancy versioning.
12:30:50 <twb> eivuokko: Right click on the barren part of the desktop, and choose properties.
12:30:58 <twb> eivuokko: on the (third?) tab, choose advanced.
12:31:08 <twb> eivuokko: then you can turn the "My Computer" icon back on temporarily.
12:31:15 <eivuokko> twb, ..
12:31:19 <SamB> twb: the brokenness will be reported to headquarters, who will tell the university
12:31:29 <eivuokko> twb, I didnt have problem.  And trust me, I know my way around Windows :)
12:31:47 <twb> eivuokko: that's not something you should broadcast.
12:31:50 <ICanWaterMyPlant> Im tired of "Hi I can water my pant". Now its easier to read my nick in the wrong way, syntaxfree. :'(
12:31:50 <eivuokko> twb, Thanks for helping, however.
12:31:54 <syntaxfree> you don't need my computer.
12:31:59 <twb> eivuokko: that's like saying "I know where all the cheap brothels are in town."
12:32:07 <syntaxfree> just windows+e will open explorer and my computer.
12:32:21 <twb> syntaxfree: It's spelt "hyper".
12:32:33 <syntaxfree> I call it windows. And note that I use a Mac.
12:32:43 <twb> syntaxfree: it's called hyper on the mac, too.
12:33:00 <syntaxfree> it's actually "command". But my cheapo keyboard has the windows logo.
12:33:07 * SamB calls it "start"
12:33:12 <twb> syntaxfree: no, command is what the GUI calls it.
12:33:21 <twb> The keycode is hyper.
12:33:33 <syntaxfree> I doubt the word "hyper" is hardcoded somewhere.
12:33:38 <SamB> twb: how odd
12:33:47 <SamB> most places, keycodes are numbers
12:33:58 <twb> SamB: bah.
12:33:59 <syntaxfree> SamB: :rimshot:
12:34:20 <twb> I suppose you say "space" instead of ^@, too?
12:34:28 <Cale> Isn't the windows key Super?
12:34:39 <SamB> twb: no
12:34:50 <SamB> twb: isn't that \0 or something?
12:34:52 <syntaxfree> I suppose "space" is actually called "kirk".
12:35:07 <Cale> My windows keys generate Super_L and Super_R
12:35:08 <SamB> syntaxfree: huh?
12:35:23 <sieni> not "pirk"?
12:35:30 <Cale> well, that's the keysym they're mapped to anyway
12:35:35 <ICanWaterMyPlant> Who is addicted to haskell here? Im trying to save my boyfriend.
12:35:37 <syntaxfree> In the Pirkinning is a good movie.
12:35:45 <syntaxfree> I had to delete i t today though.
12:35:45 <Cale> ICanWaterMyPlant: everyone here
12:35:54 <Cale> Just about :)
12:36:07 <SamB> ICanWaterMyPlant: I am, but I'm not your boyfriend
12:36:16 * syntaxfree is her boyfriend. Hmph.
12:36:29 * syntaxfree growls.
12:36:34 <ICanWaterMyPlant> :'(
12:36:40 <Cale> aww
12:37:02 <SamB> ICanWaterMyPlant: what are you trying to save him from?
12:37:16 <syntaxfree> she's trying to save me from the evil grip of functional  programming.
12:37:23 <ICanWaterMyPlant> From Haskell. Hes addicted.
12:37:28 <syntaxfree> She wants me to go back to an imperative paradigm.
12:37:34 <ICanWaterMyPlant> He cant stop thinking of haskell.
12:37:39 <SamB> ICanWaterMyPlant: so?
12:37:46 <syntaxfree> She'd rather have me coding in  Delphi,  haha.
12:37:47 <SamB> I fail to see the problem!
12:38:19 <ICanWaterMyPlant> o__O
12:38:45 <lispy> oh hm...ghc doesn't have any libraries for directly using win32 api does it?
12:38:52 <twb> ICanWaterMyPlant: maybe you should dress up as haskell.
12:39:01 <twb> kinky language fetishism!
12:39:16 <jlouis> a lambda chick!
12:39:17 <SamB> @type (.).(.)
12:39:18 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:39:27 <twb> \x. x!
12:39:41 <twb> I'm thinking about getting that tatooed.
12:40:12 <Cale> http://www-history.mcs.st-andrews.ac.uk/history/BigPictures/Curry.jpeg -- here's a photo of Haskell B. Curry to get you started.
12:40:18 <Cale> heh
12:40:23 <jlouis> ok, I am out. I'll continue my addiction elsewhere
12:40:36 <Cale> heh
12:40:38 <SamB> Cale: who wants to see that?
12:40:46 <twb> Haskell isn't addictive!  It's *habit* *forming*!
12:40:58 <SamB> he's probably horribly ugly
12:41:10 <SamB> *mind* *altering*
12:41:19 <Cale> SamB: well, presumably, if someone was to dress up as Haskell, one will need to have a good idea as to what Haskell looked like
12:41:24 <twb> Cripes, I've never actually seen Curry's photo before.
12:41:34 <twb> Cale: I meant the language.
12:41:47 <ICanWaterMyPlant> Adeus.
12:41:48 <Cale> twb: I know, I"m just being annoying :)
12:41:54 <twb> OK.
12:42:05 <Cale> I'm*
12:42:06 <Cale> heh
12:42:07 <syntaxfree> You scared her off!
12:42:09 <twb> It's hard to tell stupidity from cunning punes on IRC.
12:42:10 <SamB> syntaxfree: why is she leaving?
12:42:16 <twb> syntaxfree: *scarred
12:42:23 <lispy> so to do any gui stuff in haskell i have to first install a library like gtk or wxwidgets?
12:42:46 <twb> lispy: apt-get install!!
12:43:01 <lispy> twb: hehe, the point was to find out how easily it would work in windows :)
12:43:14 <SamB> syntaxfree: she's too easily scared
12:43:28 <twb> SamB: bollocks.  She's dating a hacker, ffs.
12:43:29 <hulahub> hey<
12:43:32 <lispy> i'm getting this new job...and they are open to letting me use what ever language i want for development...so i thought i'd find out how painful/painless haskell would be
12:43:38 <SamB> maybe it was that Haskell Curry picture?
12:43:46 * lispy nods
12:43:58 <twb> lispy: what is the problem domain?
12:44:00 <Cale> heh
12:44:09 <Cale> hulahub: hello
12:44:38 <twb> lispy: you can of course write haskell for the logic and use an FFI to access GUI code in another language.
12:44:41 <SamB> lispy: so it has to work in windows?
12:45:07 <lispy> twb: traffic simulation/visualizationis their main product, but they have other stuff and other projects so I'm not sure.  Probably a bit of data transformation
12:45:17 <lispy> SamB: i think so
12:45:35 <twb> lispy: also, have you considered a web interface?
12:45:58 <lispy> mostly i wanted to find out how encompasing haskell would be.  if it's not good at gui stuff that's good to know now :)
12:46:05 <twb> That's platform independent and hands all the laborious rendering work off on the client.
12:46:15 <lispy> twb: i haven't no.  But, I also haven't started yet :)
12:46:16 <SamB> lispy: its not so bad
12:46:38 <SamB> Its about normal for GUI stuff, I think
12:46:42 <SamB> maybe a bit better
12:46:42 <twb> Not that I *like* web interfaces.  In fact they shit me no end.  But users don't get to do design :-)
12:46:55 <lispy> heh
12:47:10 <SamB> twb: no?
12:47:16 <twb> SamB: hmm?
12:47:19 <SamB> twb: please don't tell dons that!
12:47:32 <Cale> huh?
12:47:39 <SamB> he might stop listening to my ideas about hmp3!
12:47:44 <twb> SamB: I'm talking about in corporate products, not Free software.
12:47:58 <Cale> oh, you have web-related ideas for hmp3?
12:48:08 * twb likes emms.
12:48:08 <hulahub> since im still having trouble..... is there a way to do this in haskell: myFunc x y = someFunc1 x AND EXECUTE someFunc2 y ??? so executing 2 functions in one function definition?
12:48:11 <SamB> no
12:48:21 <Cale> oh "users don't get to do design".
12:48:36 <lispy> hulahub: what do you mean by "execute"?
12:48:47 <Cale> myFunc x y = (someFunc1 x, someFunc2 y) ?
12:48:51 <Cale> like...
12:48:56 <twb> I've been trying to talk the in-house timesheet program's maintainer into adding an e-mail based interface.
12:49:05 <twb> Like Debian has for its BTS.
12:49:08 <lispy> twb: email based?
12:49:15 <lispy> hmm..
12:49:16 <twb> lispy: yeah.
12:49:19 <lispy> why not IM based ;)
12:49:20 <flux__> well, there's seq
12:49:29 <twb> lispy: cos then I could plug in *anything* that can call sendmail.
12:49:35 <flux__> but the question does suggest that something important is yet to be learned
12:49:49 <twb> As it is, there's only a web interface.  It works in lynx, but it's still a PITA because it can't be scripted.
12:49:53 <Cale> > let double x = x + x; square x = x * x; myFunc x y = (double x, square y) in myFunc 4 5
12:49:54 <lambdabot> (8,25)
12:49:57 <lispy> Me> "I worked 80 hours today";; TimeBot> "Timesheet updated."
12:50:03 <hulahub> lispy: some way i think its imperative: myFunc(x,y) { someFunc1(x); someFunc2(x) } .... you know i call someFunc 1 and 2 inside myFunc ...
12:50:17 <Cale> hulahub: what are the types?
12:50:22 <twb> Hey, I only started IRCing on sufferance.  IM can bite my ass.
12:50:29 <Cale> of myFunc and someFunc?
12:50:43 <twb> It's 8am on Sunday.  Should I mow the lawn, or go to bed?
12:50:58 <Cale> lispy: hahaha
12:51:11 <SamB> lispy: you mean TimeBot> "But there are only 24 hours in a day!" 
12:51:30 <lispy> ;)
12:51:35 <twb> TimeBot> Fuck off, it's my cigarette break.
12:51:57 <hulahub> Cale: e.g. IO() .... but i don't think thats important - just need to know if i cann call both functions without the need of combining them
12:52:12 <lispy> man, i have to go to campus to get a picture of something for a group project...geez
12:52:15 <SamB> lispy> But you don't smoke!
12:52:16 <Cale> hulahub: it is important :)
12:52:25 <Cale> a value of type IO () isn't a function :)
12:52:32 <twb> TimeBot> bullshit.  lp1 on fire
12:52:33 <SamB> hulahub: >>
12:52:51 <hulahub> SamB: i tried >> but hmmm ...
12:53:00 <Cale> myFunc x y = do someFunc1 x; someFunc2 y
12:53:24 <Cale> or, myFunc x y = someFunc1 x >> someFunc2 y
12:53:38 <hulahub> Cale: http://paste.lisp.org/display/14248 ... need to walk the whole tree look at cc - want to call cc on left and cc on right 
12:54:42 <int-e> hulahub: uhm, shouldn't you be taking the list 'i' apart there?
12:54:45 <Cale> then, can't you just do that?
12:54:52 <int-e> hulahub: instead of appending new values, I mean.
12:54:53 <Cale> what are you doing with the results?
12:54:56 * lispy is confused by the code
12:55:01 <hulahub> huffman
12:55:14 <int-e> hulahub: you want to decode a list in cc, don't you?
12:55:43 <int-e> hulahub: i.e. decode the first character from a Huffman encoded bit stream
12:55:46 <hulahub> i generate a huffman tree ... thats allready done ... by ct - now i want to have a list of all symbols (leafs) with theirs ways as a tupel
12:55:47 <lispy> what should that function be returning?
12:55:52 <hulahub> encode
12:56:10 <int-e> hulahub: hmm. your cc signature makes no sense to me.
12:56:16 <lispy> yeah, same here
12:56:20 <int-e> hulahub: i.e. the type
12:56:28 <lispy> why a list of integers?
12:56:33 <lispy> why not a float?
12:56:45 <hulahub> but i don't really want to encode now - i want to create a Tupel (Char, [Int]) for each ymbol on the tree --- something like a code table - e.g. ('a', [0,1,1,0])
12:56:56 <int-e> ah. the list is the 'current' prefix
12:57:03 <int-e> but the return type is wrong
12:57:05 <hulahub> ye could be a list of bools or yould use a int ... list is not the best way but thats not the bad thing i think
12:57:34 <int-e> you want to be able to return more than just a single (char, [code]) pair
12:58:30 <int-e> and once you do that the solution to your problem should be obvious
12:58:39 <hulahub> mainly i want to walk the whole tree and return each leaf as a tupel with the way i've gone (the [int])
12:59:13 <lispy> you may want a new type instead of using 0 and 1
12:59:22 <lispy> data Code = Left | Right
12:59:28 <int-e> @type Bool
12:59:29 <lambdabot> Not in scope: data constructor `Bool'
12:59:34 <int-e> err
12:59:35 <lispy> then you could return (Char, [Code])
12:59:37 <int-e> @type True
12:59:37 <Cale> @type True
12:59:38 <lambdabot> Bool
12:59:38 <lambdabot> Bool
12:59:40 <Cale> heh
13:00:01 <hulahub> lispy: ye there are many ways to do it better but thats not so important i think - i mainly miss a way ti walk the whole tree
13:00:21 <int-e> hulahub: you need to return more than one value (leaf of the tree then)
13:00:31 <Cale> we should get lambdabot to say "jinx!" when two people give the same request within 1 or 2 seconds :)
13:00:32 <int-e> hulahub: and with your current type that's not possible
13:00:35 <hulahub> imperative i do it: walkTree(l, v, r) { walkTree(l); print v; walkTree(r) }
13:01:09 <hulahub> shematic... :D
13:01:21 <Cale> inorder (Branch l v r) = inorder l ++ [v] ++ inorder r
13:02:19 <Cale> and why bother printing before you've constructed the list of things to print? :)
13:02:50 <hulahub> was just an e.g. ---
13:03:02 <Cale> I know
13:03:07 <int-e> Cale: so ... lists are the generic represntation for a fold pattern.
13:03:15 <Cale> I'm just commenting on a change of style :)
13:03:37 <Cale> int-e: depends on what you mean by fold :)
13:03:59 <int-e> Cale: (a description of how to do a linear fold, as an ADT - this comment is inspired by our short discussion of optimal alignments yesterday)
13:04:16 <Cale> They're a natural way to order things :)
13:04:53 <Cale> If I want to order the elements of my data structure, why, I'll put them in a list :)
13:05:03 <int-e> Cale: instead of returning a list, you could also build in a foldr into every list producer.
13:05:29 <Cale> yes, that would be equivalent
13:05:35 <int-e> Cale: and if you actually want a list, feed it with (:) and [] as arguments :)
13:05:41 <Cale> foldr with the list preapplied is isomorphic to the list
13:06:12 <int-e> hulahub: anyway. you should to return a list - that's the easiest way to go there.
13:06:47 <hulahub> i want to return a list
13:06:50 <hulahub> but the problem is
13:06:53 <hulahub> if you look at the code
13:06:57 <hulahub> i walk the right tree
13:07:00 <hulahub> but only the right one
13:07:01 <int-e> then you should specify a list type
13:07:03 <Cale> In general, you can abstract a recursive data type from its data constructors, representing it as a fold.
13:07:05 <hulahub> i bneed to walk the left one too :D
13:07:13 <int-e> hulahub: you should really get the type correct first
13:07:33 <syntaxfree> I'm interested in that too.
13:07:35 <Cale> hulahub: if you need to walk them both, walk them both, I don't see what's stopping you
13:07:55 <int-e> Cale: he's not using lists ;)
13:08:02 <Cale> well, there's that :)
13:08:11 <hulahub> hmm im searching for something like an ; in imperative languages thats stoping me :D a sequence of function calls :D
13:08:15 <hulahub> perhaps im thinking to imperative
13:08:21 <Cale> I haven't looked very closely at what his code is even doing
13:08:35 <Cale> hulahub: of what use would ; be?
13:08:44 <Cale> if you throw away the result, it's gone
13:08:45 <syntaxfree> Haskell is lazily evaluated.
13:08:55 <syntaxfree> You don't get to define execution order.
13:08:58 <Cale> you just want to specify the result
13:09:14 <hulahub> the return is done by the break condition i think .... 
13:09:49 <int-e> hulahub: you usually don't want to do that; if you want to produce something sequentially you're usually best off with producing a list; that's flexible and can be used with many other functions in Haskell
13:10:20 <hulahub> hmm ok i will try
13:10:30 <hulahub> i have to learn to think different :D
13:10:34 <Cale> yes
13:11:30 <int-e> yes, lazy evaluation is what makes this approach viable - without it you'd waste tremendous amounts of memory that way and in some cases not even finish calculations (think infinite lists)
13:11:44 <Cale> walkTree(l, v, r) { walkTree(l); print v; walkTree(r) } // here you call walkTree recursively, but you throw away the results. You don't care because you're really interested in is the side effect of printing the elements.
13:12:50 <Cale> walkTree (Branch l v r) = walkTree l ++ [v] ++ walkTree r -- here, you call walkTree recursively and hang on to the results in the form of a list, there are no side effects
13:13:49 <Cale> if printing needs to be done, you defer it to as late as possible
13:14:07 <Cale> mapM_ print (walkTree mytree)
13:14:25 <Cale> this will print out each of the elements of the list in turn
13:14:33 <Cale> *while* that list is being computer
13:14:37 <Cale> computed*
13:14:47 <Cale> this is because Haskell is lazy
13:15:06 <Cale> it's not going to compute things it doesn't have to
13:15:09 <int-e> hmm. ct doesn't look correct to me actually (besides it's grossly inefficient - it'd be better to work on the same list, reversed).
13:15:50 <Cale> hulahub: does that make some kind of sense?
13:16:14 <hulahub> Cale: ye have to experiment a bit
13:16:53 <Cale> hulahub: side effects are considered harmful because you can't take them back, or decide to not do them after they've happened
13:17:29 <Cale> they impose sequencing on everything, which means that you can't be lazy, you really do have to compute everything, even the parts you're not really interested in
13:19:20 <Cale> Hoever, programs without some side effects aren't interesting of course. So what we do is to keep the side effects (reading input from the user, printing results) contained in one place.
13:19:33 <hulahub> kk
13:19:43 <Cale> We do the interesting stuff elsewhere, and put the IO in the IO monad.
13:20:28 <Cale> by interesting stuff, I mean all the part in between the input and the output.
13:23:13 <Cale> you could actually go and use Haskell by writing your whole program in the IO monad, and it wouldn't be too different from programming in something like Pascal or C -- everything would be sequenced. It wouldn't even be all that unpleasant, but you wouldn't get the most out of Haskell this way.
13:35:15 <syntaxfree> how much  do I really need to understand monads to get useful stuff  done with pseudorandom numbers?
13:35:29 <Korollary> not much at all
13:35:39 <SamB> syntaxfree: not any more than to do IO
13:35:40 <syntaxfree> I don't want to put everything in the main =  function. I want some recursion starting with a random number.
13:35:47 <lispy> syntaxfree: the bett your understand monads the easier programming in haskell will be
13:35:52 <Korollary> in fact, you can get by not knowing anything about the monad laws, etc.
13:36:10 <syntaxfree> I get by with IO.
13:36:20 <syntaxfree> Then again, I use "getLine" and "putStr", nothing more.
13:36:24 <lispy> learning monads is an investment in haskell, IMHO
13:36:29 <Korollary> why do you think you need more than that for pseudorandom numbers?
13:36:33 <int-e> you could probably get away with passing around an infinite list of random numbers, but a random number monad is much more convenient to use.
13:37:15 <int-e> (in particular you won't have to explicitely return the new list in your functions - it'll be implicit in the monad)
13:37:26 <SamB> int-e: you can equally well use IO
13:38:01 <syntaxfree> jesus. I need to get to part 2 of htut.
13:38:03 <int-e> SamB: hmm. I want a non-strict monad that does not force the order of evaluations between taking random numbers.
13:38:08 <syntaxfree> I'm starting to need more t han what I know.
13:38:44 <SamB> syntaxfree: try Parec for a change of pace
13:38:47 <int-e> SamB: hmm. and I want to be able to spark such a computation from within a pure function
13:38:50 <SamB> er, Parsec
13:38:53 <int-e> SamB: so I wouldn't use IO there.
13:38:55 <syntaxfree> Parsec?
13:39:01 <SamB> it fun
13:39:10 <syntaxfree> int-e: me too!
13:39:37 <syntaxfree> it'd be nice if random numbers could be passed around symbolically somehow.
13:39:37 * SamB is not very good ast typing with just his left hand
13:40:15 <syntaxfree> most of statistics is based upon handling random numbers symbolically.
13:40:27 <SamB> syntaxfree: a stochastic monad?
13:40:35 <syntaxfree> yes!
13:40:39 <syntaxfree> yes!
13:40:48 <syntaxfree> yes! 
13:41:01 <int-e> syntaxfree: well, you can pass around seeds *shrugs*
13:41:07 <SamB> hmm, I've heard of such things but I don't recall actually seeing them...
13:41:16 <SamB> int-e: do you know of them?
13:41:26 <SamB> @google stochastic monad
13:41:28 <lambdabot> http://www.eecs.harvard.edu/~nr/pubs/pmonad-abstract.html
13:42:17 * syntaxfree envisions heafty uses in the simulation and parameter-fitting of stochastic differential equations.
13:42:31 <syntaxfree> s/heafty/hefty
13:43:19 <syntaxfree> that article describes exactly what I'd like.
13:43:26 <SamB> @google stochastic monad haskell
13:43:27 <lambdabot> http://dx.doi.org/10.1145/503272.503288
13:44:09 <SamB> hmm. maybe I have the wrong word.
13:44:14 <syntaxfree> should I learn lambda calculus formally somehow?
13:44:14 <SamB> @google probability monad haskell
13:44:16 <lambdabot> http://dx.doi.org/10.1145/503272.503288
13:44:33 <SamB> don't worry about that
13:44:34 <syntaxfree> I want to get to the core of the mathematical issues regarding Haskell.
13:44:59 <hulahub> Cale: i can't get it :/
13:45:02 <SamB> well, there isn't much to learn anyways
13:45:38 <syntaxfree> I see.
13:45:50 <syntaxfree> I find it very exciting to read academic papers about functional programming.
13:46:12 <hulahub> Cale: first i just try to createal ist of all nodes and leafs ... but ... 
13:46:33 <syntaxfree> I need some guidance to know what to read so I'm  actually building knowledge instead of picking up scattered odds & ends.
13:46:38 <hulahub> Cale: just temp :: HTree -> [HTree]
13:48:16 <syntaxfree> do you think a "Haskell machine" in hardware like Lisp machines is somehow factible?
13:54:40 <Cale> syntaxfree: hmm
13:55:07 <chucky> syntaxfree: not very related, but Koen Claessen, Mary Sheeran and others have a DSL in Haskell called Lava that is used as a hardware description language. See:
13:55:07 <chucky> http://www.cs.chalmers.se/~koen/Lava/
13:55:54 <Cale> hehe, that's the opposite arrow
13:56:20 <Cale> I wonder how hardware-implementable the STG-machine is
13:56:46 <Cale> hulahub: okay, so that's going to give you a list of the subtrees?
13:57:25 <hulahub> Cale: i want it to give me - but it does not want me to... :D
13:57:39 <Cale> okay, so let's do it by cases
13:57:54 <Cale> and rename it to traverse
13:57:55 <Cale> hehe
13:58:01 <Cale> traverse Empty = ...
13:58:06 <Cale> what should it return there?
13:59:19 <hulahub> the huffman tree can'T have a empty one
13:59:28 <hulahub> the break condition is Leaf
13:59:37 <Cale> I'm going based on your data declaration
13:59:41 <Cale> data HTree = Empty | Node HTree Float HTree | Leaf Char Float
13:59:42 <Cale>      deriving (Show)
13:59:53 <Cale> you should remove Empty if you don't want it
14:00:03 <hulahub> the empty is used before .... after i generated the tree it does not consist any Empty's anymore
14:00:04 <Cale> okay
14:00:11 <Cale> so, we'll change that to:
14:00:13 <hulahub> so
14:00:17 <Cale> data HTree = Node HTree Float HTree | Leaf Char Float
14:00:17 <Cale>      deriving (Show)
14:00:21 <Cale> right?
14:00:27 <hulahub> traverse (Leaf c p) =
14:00:30 <hulahub> if you want so
14:01:12 <Cale> good to keep ourselves focused, and reduce the possibilities of pattern match errors if we're not actually going to use it
14:01:15 <Cale> okay
14:01:39 <Cale> so we want traverse :: HTree -> [HTree]
14:02:16 <Cale> traverse (Leaf c p) = ... -- well, what lists could we sensibly put here?
14:02:17 <hulahub> traverse (Leaf c p) = [Leaf c p]
14:02:25 <Cale> sure, that seems reasonable :)
14:02:41 <Cale> and one other case
14:02:56 <Cale> traverse (Node t1 p t2) = ...
14:03:18 <hulahub> traverse (Node l v r) = [traverse l] ++ [traverse r]
14:03:24 <int-e> close
14:03:45 <Cale> close
14:03:51 <roconnor> close?
14:03:58 <Cale> traverse l :: [HTree]
14:03:59 <int-e> it has the wrong type :)
14:04:00 <Cale> so
14:04:08 <int-e> traverse l is a list already
14:04:09 <Cale> [traverse l] :: [[HTree]]
14:04:10 <roconnor> oh right
14:04:36 <hulahub> ok cc l + cc r
14:04:38 <hulahub> ++
14:04:58 <Cale> If you'd like to rename traverse to cc :)
14:05:14 <hulahub> cc comes frome create codes *g
14:05:28 <Cale> well, we're not actually creating codes in traverse
14:05:41 <Cale> we're just producing a list of the leaves
14:05:55 <hulahub> hmts right now ... the problem was the [cc l] ++ [cc r] :/
14:06:11 <roconnor> boy I almost missed that error.
14:06:15 <hulahub> ye i jut want a list of the leaves ... the nodes are unimportant
14:06:15 <int-e> which means you'll not be able to use it in cc, but cc will be very similar.
14:06:40 <hulahub> cc (ct nodes) gives me a list of all nodes now --- YEEEAAHHHH :D a first step ... :P
14:06:48 <int-e> (because you forget the path to the leaves, which is all cc is about)
14:06:51 <hulahub> all leafs
14:07:46 <roconnor> heh, once it complies, it works.
14:07:47 <hulahub> thank you very much! ... will try to modify it now to fit my needs :)
14:08:23 <Cale> :)
14:08:56 <int-e> hulahub: the ct function you posted is buggy btw.
14:09:07 <hulahub> int-e: why? 
14:09:26 <hulahub> int-e: worked untill now ... what will cause an error ?
14:10:02 <int-e> hulahub: it'll generate a wrong tree for [('a',0.25), ('b',0.25), ('c',0.25), ('d',0.25)]
14:11:02 <int-e> I'll leave the 'why' to you.
14:11:22 <resiak> dons: In http://haskell.org/hawiki/LambdaBot_2fInstallation "Build hs-plugins:", Setup.hs should be Setup.lhs
14:12:01 <roconnor> It's too bad the optimal tree flattening code isn't the obvious code.
14:12:02 <int-e> hulahub: err, I mean Leaf x y instead of (x,y) there.
14:12:03 <hulahub> int-e: ?? perhaps the list is definded wrong? :D [Leaf 'a' 0.25, Leaf 'b' 0.25, Leaf 'c' 0.25, Leaf 'd' 0.25]
14:12:24 <int-e> hulahub: look at the generated tree (or the codes once you have them)
14:13:15 <Cale> resiak: change it :)
14:13:16 <hulahub> int-e: .. hmm the tree looks good *taking a closer look*
14:13:19 <xerox> Howdy
14:13:30 <resiak> Cale: I can't. The page is immutable.
14:13:31 <Cale> xerox: hello
14:13:36 <Cale> resiak: log in
14:13:53 <hulahub> int-e: Node (Leaf 'a' 0.25) 1.0 (Node (Leaf 'b' 0.25) 0.75 (Node (Leaf 'c' 0.25) 0.5 (Leaf 'd' 0.25)))
14:13:56 <hulahub> looks good ?!
14:13:59 <Cale> pages are immutable until you log in
14:14:26 <resiak> Cale: Aaah
14:14:42 <int-e> hulahub: it's not a Huffman tree
14:15:02 <hulahub> int-e: ?!?! why ?
14:18:27 <syntaxfree> I wish the choose operator mentioned @ pmonad.pdf actually existed.
14:19:05 <hulahub> int-e: looks good to me - drawed it
14:20:07 <int-e> hulahub: it does not describe an optimal binary prefix code for the given distribution.
14:20:26 <hulahub> int-e: ye could be a bit better balanced 
14:20:48 <int-e> hulahub: could be? Huffman trees are perfectly balanced in that way.
14:21:49 <hulahub> int-e: i think its because i do not sort after inserting into list
14:21:56 <int-e> right
14:22:11 <hulahub> int-e: ye but still working as example --- have to find out how to sort first :D
14:23:11 <Cale> > sort [5,3,4,2,1]
14:23:12 <lambdabot> [1,2,3,4,5]
14:23:25 <hulahub> Cale: and sort the other way? :D
14:23:30 <int-e> > sortBy (flip compare) [1,2,3,4,5]
14:23:31 <lambdabot> [5,4,3,2,1]
14:23:40 <hulahub> ok...
14:23:48 <jeffno> > flip flip
14:23:48 <lambdabot>   add an instance declaration for (Show (b -> (a -> b -> c) -> a -> c))
14:23:57 <int-e> . o O ( although it would do the algorithm some good to reverse that list )
14:24:04 <hulahub> > flip [1,2,3]
14:24:05 <lambdabot> Couldn't match `a -> b -> c' against `[a1]'
14:24:08 <hulahub> :P
14:24:11 <resiak> Bah, lambdabot won't compile for me. :(
14:24:15 <syntaxfree> > flip fold [1,2,3] (+)
14:24:16 <lambdabot>  Not in scope: `fold'
14:24:23 <syntaxfree> > flip foldl [1,2,3] (+)
14:24:24 <lambdabot>  add an instance declaration for (Show ([[a]] -> [a]))
14:24:42 <int-e> (working on heads and tails of lists is vastly more efficient than working on last elements and initial segments)
14:25:08 <int-e> > flip foldl 0 (+) [1,2,3]
14:25:09 <lambdabot> 6
14:25:20 <syntaxfree> @type foldl
14:25:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:25:22 <hulahub> int-e: you mean using first element as lowest in the whole htree list?
14:25:23 <int-e> > flip foldl1 [1,2,3] (+)
14:25:24 <lambdabot> 6
14:25:32 <int-e> hulahub: yep
14:25:34 <syntaxfree> what dos foldl1 do again?
14:25:48 <int-e> syntaxfree: foldl1 f (a:b) = foldl f a b
14:25:49 <hulahub> int-e: think oyu are right - will do so i think :)
14:26:04 <hulahub> int-e: thanks
14:26:55 <syntaxfree> smart!
14:27:02 <syntaxfree> jesus, smart definition. 
14:27:02 <int-e> > foldl1 (+) []
14:27:04 <lambdabot> Prelude.foldl1: empty list
14:27:18 <syntaxfree> I never thought of that when writing folds in Scheme!
14:27:47 <hulahub> cc2 :: HTree -> String -> [(Char, String)] - im getting closer to what i want.... but i still stuck...
14:27:51 <syntaxfree> > foldl1 (*) [13,5,9]
14:27:52 <lambdabot> 585
14:28:04 <hulahub> cc2 (Leaf c p) x = [(c, x)]
14:28:13 <hulahub> think that is right...
14:28:28 <int-e> looks good
14:28:55 <hulahub> cc2 (Node l v r) x = cc2 l (x ++ "0") ++ cc2 r (x ++ "1")
14:28:59 <hulahub> is the other one ...
14:29:08 <syntaxfree> OH
14:29:13 <syntaxfree> god, I'm such an idiot.
14:29:19 <int-e> hulahub: looks good
14:29:22 <hulahub> oh ye :D it works :P i missed the second argument
14:29:22 <bosie> is there a function converting a [[]] into [] ?
14:29:33 <hulahub> cc2 (ct nodes) ""
14:29:35 <hulahub> works fine :)
14:29:43 <hulahub> [('b',"0"),('c',"10"),('d',"110"),('a',"1110"),('e',"1111")]
14:29:48 * hulahub is happy
14:29:51 <hulahub> *jumps arround*
14:30:11 <int-e> bosie: concat ?
14:30:17 <int-e> @type concat
14:30:18 <lambdabot> forall a. [[a]] -> [a]
14:30:22 <syntaxfree> head?
14:30:25 <syntaxfree> > head [[]]
14:30:26 <lambdabot> Add a type signature
14:30:26 <bosie> thank you
14:30:38 <syntaxfree> > head [[]] :: Int
14:30:39 <lambdabot> Couldn't match `Int' against `[a]'
14:30:41 <hulahub> i love that - learning is fun :P
14:30:42 <Cale> > filter (not . null) [[]]
14:30:43 <lambdabot> Add a type signature
14:30:51 <Cale> > filter (not . null) [[]] :: [[Int]]
14:30:52 <lambdabot> []
14:30:56 <int-e> Cale: heh!
14:31:17 <bosie> concat was it thanks int-e
14:31:31 <bosie> actually Data.List doesnt contain any function for that does it?
14:31:34 <int-e> bosie: so you wanted to 'flatten' a list :)
14:31:53 <int-e> @index concat
14:31:54 <lambdabot> Data.List, Prelude
14:32:21 <bosie> int-e prelude?
14:32:35 <int-e> bosie: it's in the prelude but imported from Data.List ;)
14:32:36 <bosie> on zvon.org there is no prelude
14:32:45 <syntaxfree> > concat [[1,2,3],[4,5,6]]
14:32:46 <lambdabot> [1,2,3,4,5,6]
14:32:51 <int-e> Prelude is automatically available ...
14:32:53 <bosie> ah
14:32:54 <syntaxfree> haha. I actually wrote a function for that, with recursion.
14:32:57 <syntaxfree> I'm  such an idiot.
14:33:14 <bosie> int-e that prelude you mean
14:33:14 <bosie> ;)
14:33:18 <int-e> syntaxfree: you've certainly learned a bit doing that
14:33:24 <hulahub> hmm is 'sort' no default function?
14:33:30 <hulahub> hugs does not know it... hmm
14:33:32 <Cale> hulahub: import List
14:33:34 <syntaxfree> I had one entire semester of doing the dumbest things with recursions.
14:33:35 <bosie> hulahub sort is in Data.List
14:33:36 <int-e> hulahub: import Data.List
14:33:43 <int-e> @index sort
14:33:44 <bosie> syntaxfree what course?
14:33:44 <lambdabot> Data.List
14:33:46 <syntaxfree> in scheme.
14:33:54 <bosie> syntaxfree what univ?
14:33:57 <syntaxfree> we weren't allowed to use ANY recursion patterns like map or filter.
14:34:01 <syntaxfree> PUC-Rio.
14:34:11 <bosie> puc ?
14:34:14 <syntaxfree> it's in the Brazil. The guys who came up with Lua.
14:34:24 <syntaxfree> s/in the Brazil/in Brazil.
14:34:57 <bosie> catholic university?
14:36:05 <int-e> @type sortBy
14:36:06 <lambdabot> Not in scope: `sortBy'
14:36:13 <int-e> @type Data.List.sortBy
14:36:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:36:17 <int-e> @type Data.List.insertBy
14:36:18 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
14:36:39 <int-e> @type compare
14:36:40 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:37:23 <int-e> @pl x a b = c (f a) (f b)
14:37:23 <lambdabot> x = (. f) . c . f
14:37:33 <hulahub> int-e: and performing operations on the head of a list is the better option in all cases?
14:38:12 <int-e> hulahub: in most of the cases. (:), head, tail are all O(1) operations
14:38:14 <Speck> shapr: I got my hands on the yampa-gadt sources
14:38:50 <int-e> ++ , last, init are O(n) operations (where n is the length of the list - in case of ++ the length of the first argument)
14:39:20 <int-e> @type reverse
14:39:21 <lambdabot> forall a. [a] -> [a]
14:39:45 <int-e> reverse is O(n), too - so building a reversed list and then reversing it will be more efficient than appending single items at the end.
14:39:59 <int-e> (O(n) total instead of O(n^2))
14:40:06 <hulahub> ok
14:40:21 <hulahub> so replaced last with head and init with tail :D
14:40:21 * int-e thinks
14:40:59 <hulahub> so now i need to create a way to sort the list....
14:41:04 <int-e> that last remark needs to be taken with a grain of salt.
14:41:24 <hulahub> int-e: ?
14:41:30 <int-e> (it's true for a single list but sharing of intermediate results can spoil the analysis)
14:42:12 <int-e> anyway. for ct it's a clear win
14:42:36 <hulahub> ok - with sortby i can apply a function written by my self - right ?
14:42:47 <Heffalump> yes
14:43:35 <Cale> @type sortBy
14:43:35 <int-e> yes. (it's a capital 'B' btw)
14:43:36 <lambdabot> Not in scope: `sortBy'
14:43:40 <Cale> @type Data.List.sortBy
14:43:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:43:56 <Cale> data Ordering = LT | GT | EQ
14:44:01 <hulahub> and ordering ... i just return RT, LT or EQ ?
14:44:05 <hulahub> :D
14:44:08 <hulahub> ok :D
14:44:14 <int-e> hulahub: or use compare to do the job
14:44:16 <int-e> > compare -1 2
14:44:17 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> Ordering))
14:44:27 <int-e> > compare *-1) 2
14:44:28 <lambdabot>  parse error on input `)'
14:44:30 <int-e> > compare (-1) 2
14:44:31 <lambdabot> LT
14:44:33 * araujo thinking lately to write a blog-maker
14:44:33 <int-e> I hate this.
14:44:43 <hulahub> int-e: but compare does not work on a list of Leafs... i think ...
14:44:50 <araujo> I just can't find anything decent.
14:45:03 <int-e> hulahub: well, you'll need to extract the probabilities first
14:45:07 <hulahub> ye
14:45:11 <hulahub> thats what i thought of :)
14:45:13 <hulahub> okee
14:45:14 <Cale> @type compare
14:45:15 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:45:44 <int-e> hulahub: but there's no reason to do if v1 < v2 then LT else if v1 == v2 then EQ else GT
14:46:08 <hulahub> o :: a -> a -> Ordering
14:46:09 <hulahub> o (Leaf ca pa) (Leaf cb pb) = compare pa pb
14:46:40 <hulahub> replace a with HTree :P
14:46:49 <int-e> yes
14:47:50 <int-e> although I don't understand why you don't have a function that extracts the probability from a HTree.
14:50:09 <hulahub> because i have to create the tree firsT? :D
14:52:12 <lisppaste2> hulahub pasted "generate HTree and HCodes" at http://paste.lisp.org/display/14262
14:52:23 <hulahub> int-e: you like this more? :D
14:53:48 <hulahub> [('c',"00"),('b',"01"),('e',"100"),('a',"101"),('d',"11")]
14:53:54 <hulahub> YEEAAAAHHHWWW :D
14:53:57 <hulahub> *happy*
14:54:07 <int-e> hulahub: now 'ct nodes' will still be wrong (although it'll accidently generate a Huffman tree)
14:54:34 <hulahub> int-e: ??!!!???!??
14:54:45 <int-e> hulahub: you turned the list around, remember?
14:54:54 <hulahub> yes ...
14:55:16 <hulahub> and ?
14:55:32 <int-e> hulahub: you should turn nodes around, too.
14:55:58 <hulahub> ah compare pb pa instead... ?
14:56:48 <hulahub> no... sortBy o nodes gives me the correct list
14:56:53 <hulahub> what else do you mean
14:57:15 <int-e> hulahub: yes it does, but ...
14:58:06 <int-e> hulahub: you never sort the list initially passed to ct
14:58:29 <hulahub> int-e: i do - its sorted as it is passed to ct
14:58:49 <hulahub> ah
14:58:53 <hulahub> i know what oyu mean
14:59:29 <hulahub> it forst tails ...
14:59:39 <hulahub> and tails the initially list
14:59:41 <hulahub> you are right
15:01:43 <hulahub> int-e: now a very stupid question: how to add the command sortBy o nodes to the code file without using it inside a function? just a line with SortBy o nodes won't work i think ... this just works in interactive mode...
15:02:02 <Cale> um what would it mean?
15:02:08 <hulahub> hmm
15:02:11 <hulahub> im stupid :D
15:02:16 <hulahub> i never asked this question
15:02:20 <Cale> hehe
15:02:21 <hulahub> delete it please :)
15:03:27 <Cale> like, if you want to set up a main action to execute when you compile the program, you can do something like  main = print (sortBy o nodes) 
15:03:39 <Cale> if that's sort of the thing you're getting at
15:03:53 <hulahub> [('b',"00"),('e',"010"),('a',"011"),('d',"10"),('c',"11")]
15:04:01 <hulahub> this should be the correct code table
15:04:03 <hulahub> i think
15:04:37 <int-e> one of many
15:05:00 <hulahub> now i can finally be happy and jump arround?
15:05:24 <int-e> hmm. I guess :)
15:05:28 <int-e> btw. with a function
15:05:32 <int-e> hProb :: HTree -> Float
15:05:34 <int-e> you could write
15:05:40 <int-e> cn a b = Node a (hProb a + hProb b) b
15:05:42 <int-e> :)
15:06:21 <int-e> and you need only 2 cases to define hProb, instead of 4 for cn and o.
15:06:34 * int-e thought that was an obvious thing to do.
15:06:42 <hulahub> but this would make me loosing the information what symbol im handling ...
15:07:13 <hulahub> this would break cc ...
15:07:20 <int-e> it doesn't
15:08:29 <hulahub> wait... 
15:09:24 <hulahub> tf :: HTree -> Float
15:09:24 <hulahub> tf (Leaf c p) = p
15:09:24 <hulahub> tf (Node l p r) = p
15:09:28 <hulahub> thats what you mean ?
15:09:34 <int-e> yep
15:13:39 <lisppaste2> hulahub pasted "final hTree?" at http://paste.lisp.org/display/14263
15:13:47 <jethr0> hey, i asked this question before and had to go... *sorry*
15:13:51 <hulahub> int-e: ---- thats the way you like it? :D
15:14:09 <jethr0> is there a way to get two io values out at once? "do (x,y) <- (IO a, IO b)"
15:14:40 <jethr0> OR a standard way to combine two IO values into one: "fn :: IO a -> IO b -> IO (a, b)"
15:15:09 <jethr0> standard/lib function
15:15:16 <SamB> @type Monad.liftM (,)
15:15:17 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
15:15:26 <int-e> hulahub: good enough, I'd say
15:15:27 <SamB> @type Monad.liftM2 (,)
15:15:28 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:15:36 <hulahub> int-e: O_o
15:16:29 <lisppaste2> int-e annotated #14263 with "I'd do it like this - some technical differences, some minor algorithmic changes" at http://paste.lisp.org/display/14263#1
15:16:53 <int-e> hulahub: for the curious :)
15:17:03 <jethr0> so, would the following work: "do (a,b) <- Monad.liftM2 (,) $ (IO x) (IO y)" ?
15:17:11 <Lemmih> Hi.
15:17:38 <int-e> jethr0: maybe without the $
15:17:50 <int-e> @type Control.Monad.liftM2
15:17:51 <lambdabot> forall r (m :: * -> *) a2 a1.
15:17:51 <lambdabot> (Monad m) =>
15:17:51 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:18:03 <jethr0> ah
15:18:05 <int-e> yep, it should work without the $
15:18:13 <hulahub> ok will eat something on this success :D
15:18:34 <hulahub> Cale & int-e: thank you very _very_ VERY much ! :)
15:18:44 <jethr0> ah, yes, for me lift was always about functions, but that is just the comfort of partial evaluation ;-)
15:18:52 <jethr0> and transparent currying/uncurrying
15:20:13 <int-e> @type curry
15:20:14 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
15:20:17 <int-e> @type uncurry
15:20:18 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
15:20:45 <int-e> curried functions are the default in Haskell - that's the whole trick.
15:21:07 <jethr0> yes, that's what i (clumsily) wanted to say ;)
15:21:30 <int-e> > [(+) 1 2, uncurry (+) (1,2)]
15:21:32 <lambdabot> [3,3]
15:21:58 <int-e> @index uncurry3
15:21:58 <lambdabot> bzzt
15:22:09 <jethr0> but in other languages, uncurried functions are the norm, thus making "curry" very important to have the effect of partial function application
15:23:04 <jethr0> "uncurry" i meant...
15:23:25 <jethr0> ah, i'm not myself today. don't mind my ramblings...
15:23:29 <Cale> @type uncurry
15:23:30 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
15:23:33 <Cale> @type curry
15:23:34 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
15:23:51 <Cale> uncurry is to (,) what foldr is to []
15:24:21 <int-e> Cale: have you ever seen anything that automates the conversion of a function a -> [b] (that calls itself recursively and builds lists with (++)) to a function of type a -> [b] -> [b] (that uses (.) instead of (++))?
15:24:26 <jethr0> ahh, you are seriously blowing my mind
15:25:10 <bosie> how the heck do i replace a char by two other chars?
15:25:13 <Heffalump> int-e: my PhD project does that
15:25:13 <jethr0> int-e: isn't that conversion to continuation-passing-style?
15:25:25 <Heffalump> but it doesn't handle full Haskell
15:26:01 <int-e> I'm just curious - it's a transformation that I happen to do (manually) quite often :)
15:26:02 <jethr0> heffalump: so what are the buzzwords involved? does it have to do with CPS?
15:26:11 <int-e> Heffalump: are there any papers about it?
15:26:13 <Cale> int-e: do you know about build?
15:26:28 <int-e> Cale: doesn't ring a bell
15:26:59 <jethr0> int-e: i don't really get your question. is one of the "[b]" an accumulator or are you building up a concatenated operation to be perfomed at the end?
15:27:36 <int-e> jethr0: the last two functions in http://paste.lisp.org/display/14263#1 are an example of such a transformation
15:27:53 <int-e> jethr0: i.e. cc0 and cc / cc'
15:28:33 * Cale looks for a relevant paper
15:28:40 <Heffalump> jethr0: it's connected, but the technique I used was fusion
15:29:10 <Heffalump> int-e: http://web.comlab.ox.ac.uk/oucl/work/ganesh.sittampalam/ - the stuff about fusion, matching and MAG
15:29:38 <Cale> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
15:29:40 <jethr0> cool, fusion. at some point i want to read up on it...
15:29:48 <Cale> build g = g (:) []
15:30:01 <Heffalump> that's short-cut fusion
15:30:05 <jethr0> cale: how would you use that?
15:30:15 <Cale> there's a nice property that  foldr k z (build g) = g k z
15:30:54 <int-e> Cale: ah. that's what we were talking about earlier.
15:31:20 <bosie> how do i replace a char by two other chars? ;)
15:31:23 <Cale> jethr0: (forall b. (a -> b -> b) -> b -> b) -- this type is isomorphic to the type of lists via build / foldr
15:32:32 <int-e> > "abcd" >>= \x -> if x == 'b' then "xy" else return x
15:32:33 <lambdabot> "axycd"
15:33:49 <int-e> > [c | x <- "abcd", c <- if x == 'b' then "xy" else [x]]
15:33:50 <lambdabot> "axycd"
15:33:54 <int-e> same thing :)
15:33:57 <bosie> uhm
15:33:59 <bosie> >>= ?
15:34:07 <int-e> it's using the list monad
15:34:26 <bosie> hm
15:34:32 <bosie> its not on zvon.org
15:34:43 <Heffalump> can't possible exist then :-
15:34:44 <Heffalump> )
15:35:17 <jethr0> > map (\x -> if x == 'b' then "xy" else [x]) "abcd"
15:35:18 <lambdabot> ["a","xy","c","d"]
15:35:23 <jethr0> damn
15:35:28 <bosie> oh well how should i know what exists and what doesnt if i dont have a complete list, Heffalump
15:35:30 <jethr0> > concat $ map (\x -> if x == 'b' then "xy" else [x]) "abcd"
15:35:32 <lambdabot> "axycd"
15:35:33 <int-e> > concatMap (\x -> if x == 'b' then "xy" else [x]) "abcd"
15:35:34 <lambdabot> "axycd"
15:35:56 <int-e> (>>=) = flip concatMap
15:36:03 <jethr0> why doesn't the list comp. version not have the same problem??
15:36:06 <jethr0> does*
15:37:03 <jethr0> > [c | x <- [1,2,3,4], c <- if x == 2 then [2,2] else [x]]
15:37:05 <lambdabot> [1,2,2,3,4]
15:37:23 <jethr0> > [c | x <- [1,2,3,4], c <- if x == 2 then 0 else x]
15:37:24 <lambdabot>  add an instance declaration for (Num [a])
15:37:24 <lambdabot>   In a list comprehension: c <- if x == 2 then 0 else x
15:37:24 <lambdabot>   In the definition of `lghoyewh':
15:37:36 <int-e> bosie: if you look for monads, you'll find list among them
15:37:54 <bosie> int-e http://www.zvon.org/other/haskell/Outputlist/index.html yes thats list but >>= is not on it?
15:38:07 <jethr0> ahh, i get it! "c <-"
15:38:51 <int-e> bosie: it's in Prelude ... and you have to know that [] is a Monad
15:39:19 <int-e> > [c | x <- [1,2,3,4], let c = if x == 2 then 0 else x]
15:39:21 <lambdabot> [1,0,3,4]
15:40:24 <roconnor> > [c | x <- [1,2,3,4], c <- [if x == 2 then 0 else x]]
15:40:25 <lambdabot> [1,0,3,4]
15:41:12 <int-e> bosie: the list is only what the List module exports - there are functions that work with lists that are in other modules.
15:42:09 <bosie> thank you
15:42:18 <bosie> didnt know that :(
15:53:34 <jeffno> What's the prefix do in this command? "runhaskell Setup.hs configure --prefix=/home/dons"
15:54:28 <musasabi> jeffno: specify under which directory the software is going to be installed.
15:54:44 <jeffno> Ok, thanks.
15:57:06 <jethr0> @seen samb
15:57:07 <lambdabot> samb is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 41
15:57:07 <lambdabot> minutes and 39 seconds ago.
15:58:50 <SamB> hello
15:58:56 <jethr0> hi
15:59:26 <jethr0> any ideas how to get a null-terminated array of char pointers to haskell?
15:59:44 <jethr0> *g*
15:59:55 <musasabi> jethr0: CString
16:00:05 <SamB> musasabi: no, pointers!
16:00:15 <SamB> not really
16:00:17 <musasabi> @type Foreign.C.Types.CString
16:00:18 <lambdabot> Not in scope: data constructor `Foreign.C.Types.CString'
16:00:31 <Lemmih> Ptr CString?
16:00:34 <jethr0> musasabi: i know how to do it for char*. i got char**
16:00:37 <jethr0> yup
16:00:40 <user317> is anyone familiar with the opengl tutorial?  i cant get it to build, i get a  Variable not in scope: `GLUT.init' error
16:00:46 <musasabi> CString == Ptr CChar
16:00:50 <jethr0> i could peek the ptr and increment it in a recursive function until it's null
16:00:55 <musasabi> ah
16:01:05 <SamB> oh, "to haskell"
16:01:07 <SamB> right
16:01:14 <musasabi> Ptr CString like Lemmih said.
16:01:34 <musasabi> why not just peekArray0 ?
16:02:02 <jethr0> musasabi: doesn't that go in char steps?
16:02:12 <jethr0> and pointers have 4-bytes, i think.
16:02:18 <musasabi> jethr0: it can just return the list of pointers
16:02:33 <jethr0> that would be sufficient.
16:02:43 <musasabi> peekArray0 :: (Eq a, Storable a) => a -> Ptr a -> IO [a]
16:02:57 <jethr0> any ideas whether operations like peekArray can be lazy?
16:03:11 <triplah> hmm a lazy array of pointers
16:03:12 <triplah> hot
16:03:13 <musasabi> I think it is strict.
16:03:31 <jethr0> would "peekArray 100 ptr >>= (\x -> take 10 x)" work?
16:03:35 <triplah> user317: opengl tute? link me up :)
16:03:46 <Lemmih> jethr0: return (take 10 x)
16:03:49 <jethr0> work in the sense of reading only 10 chars in memory?
16:03:54 <jethr0> yup, sorry
16:04:14 <Lemmih> jethr0: No, peekArray is strict.
16:04:15 <user317> triplah: http://www.cin.ufpe.br/~haskell/hopengl/first.html
16:04:16 <musasabi> jethr0: if you have an array of string pointers that makse litle sense.
16:04:17 <jeffno> How can I tell what version of Cabal is installed?
16:04:28 <musasabi> ghc-pkg describe Cabal
16:04:33 <Lemmih> `ghc-pkg field Cabal version`
16:04:50 <user317> triplah: let me know if you can get the first example to build :)
16:05:05 <jeffno> Thans guys.
16:05:18 <jethr0> musasabi: so, how about the problem of char-stepping vs (sizeof char*) stepping in peekArray0?
16:05:30 <Lemmih> user317: That tuturial is way old.
16:06:10 <jethr0> user31337
16:06:18 <Lemmih> user317: There are some up-to-date ports of the NeHe tutorials around.
16:07:02 <musasabi> jethr0: it uses corerect stepping for the type of pointer used.
16:07:10 <triplah> user317: yeah it doesnt build
16:07:15 <triplah> i dare say the api has changed
16:07:26 <user317> Lemmih: thanks, ill see if i can find it
16:07:54 <jethr0> musasabi: oh cool. i'll read up on my foreign.storable, thx a lot!
16:08:10 <musasabi> np, hope it helps you
16:09:08 <user317> triplah: ah, this http://haskell.org/hawiki/HaskellOpenGl has some working examples
16:13:03 <jethr0> is it possible/sensible to mix "do" and ">>="?
16:13:14 <triplah> user317: cool :D
16:13:15 <Lemmih> Yep.
16:13:17 <jeffno> Is hs-plugins currently broken?  I can't build it.
16:14:08 <Lemmih> jethr0: do x <- a =<< b; ... can be very elegant at times.
16:14:21 <jeffno> @seen dons
16:14:22 <lambdabot> dons is in #haskell. Last spoke 17 hours, 32 minutes and 38 seconds ago.
16:14:30 <jethr0> so, can you say "do x <- lala; y <- (lala >>= lolo); return y"?
16:15:07 <jethr0> what does "=<<" do? is that reverse order concatenation?
16:16:34 <eivuokko> It's >>= with arguments reversed.
16:17:00 <jethr0> @index =<<
16:17:00 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
16:17:00 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
16:17:00 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
16:17:39 <Lemmih> @type (Monad.=<<)
16:17:40 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
16:18:08 <jethr0> i still don't get "x <- a =<< b". how strong do "<-" and "=<<" bind relative to each other?
16:18:36 <Lemmih> (<-) is not a function.
16:19:45 <jethr0> so what's the difference between "x <- a =<< b" and "x <- b >>= a"?
16:20:04 <Lemmih> There is none.
16:20:18 <eivuokko> Just notation, sometimes other one is more readable.
16:20:27 <jethr0> ok, that got me really confused *hehe*
16:23:52 <dons> jeffno, how is it broken?
16:28:20 <triplah> > "is lambdabot feeling better?"
16:28:21 <lambdabot> "is lambdabot feeling better?"
16:28:26 <triplah> appears so :)
16:29:10 <dons> dons law of software breakage: 50% of the time it is you that is broken, not the software
16:29:24 <int-e> > xxxx
16:29:25 <lambdabot>  Not in scope: `xxxx'
16:29:25 <triplah> i like those odds!
16:29:54 <triplah> i fear i wont be able to answer the last question in my assignment
16:30:05 <triplah> so i'm going to monadise as much of the rest of it as possible
16:30:13 <triplah> and try win extra marks from my lecturer
16:31:54 <jethr0> i know i've asked a similar question before, but how do i convert: "[IO a] -> IO [a]" ?
16:32:05 <triplah> can anyone tell me how to turn tab size down in vi's hs highlighting?
16:32:24 <jethr0> set tabstop=n
16:32:28 <triplah> ta
16:33:04 <triplah> ahh much better
16:33:09 <triplah> thanks :D
16:33:22 <jethr0> but highlighting should be independent from tab depth *?!?!*
16:33:42 <triplah> ahh, i just assumed it set the tab depth per syntax
16:33:45 <jethr0> triplah: how do you ask lambdabot for a function with given signature?
16:33:48 <triplah> take python for example
16:33:59 <Lemmih> jethr0: sequence
16:34:05 <triplah> @hoogle ?
16:34:05 <lambdabot> Test.HUnit.Base.(
16:34:05 <lambdabot> Test.HUnit.Base.(
16:34:05 <lambdabot> Test.HUnit.Base.(~?) :: AssertionPredicable t => t -> String -> Test
16:34:07 <jethr0> thx
16:34:21 <jethr0> @type sequence
16:34:22 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:34:24 <JohnMeacham> hohum.
16:34:35 <jethr0> @hoogle [IO a] -> IO [a]
16:34:36 <lambdabot> No matches, try a more general search
16:34:37 <triplah> @hoogle [IO a] -> IO [a]
16:34:39 <lambdabot> No matches, try a more general search
16:34:55 <triplah> :(
16:34:57 <jethr0> @hoogle forall a. [IO a] -> IO [a]
16:34:58 <lambdabot> No matches, try a more general search
16:35:15 <triplah> @hoogle fst a
16:35:16 <dons> @hoogle [m a] -> m [a]
16:35:17 <lambdabot> Prelude.undefined :: a
16:35:17 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
16:35:17 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
16:35:17 <lambdabot> Data.List.head :: [a] -> a
16:35:17 <lambdabot> Data.List.last :: [a] -> a
16:35:18 <lambdabot> Prelude.head :: [a] -> a
16:35:19 <jethr0> @hoogle forall a (m::*->*). (Monad m) [m a] -> m [a]
16:35:20 <lambdabot> hoogle: Unexpected character when parsing: *->*). (Monad m) [m a] -> m [a]
16:35:22 <lambdabot>  
16:35:57 <jethr0> shouldn't lambdabot give "sequence" as well?
16:36:02 <araujo> dons, hello!
16:36:18 <dons> it doesn't know about kind annotations, jethr0.
16:36:28 <dons> hey araujo!
16:36:29 <triplah> anyone feel like helping me with a particularly nasty type problem?
16:36:33 <triplah> :(
16:36:34 <araujo> dons, how you doing?
16:36:50 <dons> @hoogle (Monad m) => [m a] -> m [a]
16:36:51 <lambdabot> No matches, try a more general search
16:36:51 <jethr0> dons: so it will never find generic monad operations?
16:36:56 <araujo> dons, have you created any snapshot of hmp3 that we could add to the tree now? :-)
16:36:58 <triplah> lambdabot: url
16:37:04 <dons> @hoogle [m a] -> m [a]
16:37:05 <lambdabot> Data.List.head :: [a] -> a
16:37:05 <lambdabot> Data.List.last :: [a] -> a
16:37:05 <lambdabot> Prelude.head :: [a] -> a
16:37:08 <dons> @hoogle+
16:37:09 <lambdabot> Prelude.last :: [a] -> a
16:37:09 <araujo> Or tarball....
16:37:10 <triplah> lisppaste2: usl
16:37:14 <triplah> lisppaste2: url
16:37:15 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:37:16 <int-e> @type sequence
16:37:17 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:37:32 <int-e> hmm
16:37:36 <dons> maybe Control.Monad isn't in its db. hmm.
16:37:39 <dons> araujo, which tree?
16:37:49 <int-e> @hoogle liftM2
16:37:49 <araujo> dons, gentoo tree :-]
16:37:50 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
16:37:50 <lambdabot> r
16:37:53 <dons> and yes, I'm about to tag, tarball and release hmp3 0.2
16:38:02 <int-e> does it use the same db for this lookup?
16:38:06 <dons> SamB, whaddya reckon, ready for 0.2?
16:38:10 <araujo> dons, cool, ping me when you do it!
16:38:27 <dons> you going to stick it in gentoo?
16:38:35 <araujo> dons, yeah
16:38:37 <dons> excellent
16:38:39 <jethr0> > let conc = sequence in cond ["ab", "cd"]
16:38:40 <dons> :)
16:38:40 <lambdabot>  Not in scope: `cond'
16:38:42 <araujo> :-]
16:38:46 <jethr0> > let conc = sequence in conc ["ab", "cd"]
16:38:47 <lambdabot> ["ac","ad","bc","bd"]
16:39:02 <jethr0> huh?
16:39:23 <lisppaste2> triplah pasted "types hate me" at http://paste.lisp.org/display/14264
16:39:27 <int-e> > "ab" >>= "cd"
16:39:28 <lambdabot> Couldn't match `Char -> [b]' against `[Char]'
16:39:53 <int-e> ah. right
16:40:06 <int-e> > "ab" >>= \x -> "cd" >>= \y -> [x,y]
16:40:07 <lambdabot> "acadbcbd"
16:40:17 <int-e> > "ab" >>= \x -> "cd" >>= \y -> return [x,y]
16:40:18 <lambdabot> ["ac","ad","bc","bd"]
16:41:09 <jethr0> [x:y:"" | x <- "ab", y <- "cd"]
16:41:11 <jethr0> > [x:y:"" | x <- "ab", y <- "cd"]
16:41:12 <lambdabot> ["ac","ad","bc","bd"]
16:41:54 <jethr0> list monad still creeps me out a little...
16:42:29 <int-e> jethr0: it works exactly like list comprehension ;)
16:42:40 <int-e> @type guard
16:42:41 <lambdabot> Not in scope: `guard'
16:42:48 <triplah> ergh, whats redo in vi?
16:42:51 <triplah> undid too many times
16:42:52 <triplah> :)
16:42:53 <int-e> @index guard
16:42:53 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
16:42:53 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
16:42:53 <lambdabot> Control.Monad.Error, Control.Monad.List
16:43:15 <jethr0> > sequence ["12", "23", "45"]
16:43:16 <hulahub> i do not understand the any function - what does any :: (a -> Bool) -> [a] -> Bool mean ? if (a -> Bool) is in [a] return true? but why a -> bool ?
16:43:16 <lambdabot> ["124","125","134","135","224","225","234","235"]
16:43:25 <int-e> @type Control.Monad.List.guard
16:43:26 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
16:43:47 <jethr0> hulahub: it's the predicate
16:44:00 <hulahub> ye but whas a predicate? :D
16:44:01 <int-e> > "abc" >>= \x -> Control.Monad.guard (x/='b') >> return x
16:44:03 <lambdabot> "ac"
16:44:34 <jethr0> hulahub: the function that determines whether an element should be considered "in" or "out"
16:44:38 <jethr0> "true" or "false"
16:44:54 <jethr0> > any even [1,2,3]
16:44:55 <lambdabot> True
16:44:55 <int-e> True or False :)
16:45:04 <jethr0> all even [1,2,3]
16:45:07 <jethr0> > all even [1,2,3]
16:45:08 <lambdabot> False
16:45:10 <jeffno> dons: runhaskell Setup.hs configure --prefix=/home/jeffno/haskell --> can't find file `Setup.hs'
16:45:11 <hulahub> hmm
16:45:14 <int-e> > all (>0) [1,2,3]
16:45:16 <lambdabot> True
16:45:23 <dons> @seen SamB
16:45:23 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 44
16:45:23 <lambdabot> minutes and 16 seconds ago.
16:45:29 <int-e> > all (\x -> x>0) [1,2,3]
16:45:30 <jethr0> hulahub: do you know the function "filter"?
16:45:30 <lambdabot> True
16:45:31 <triplah> where do guards need to be tabbed exactly?
16:45:36 <triplah>         alsEntry i j
16:45:36 <triplah>           | i ==j     = attachMutant m mm sp x y (als (i-1) (j-1))
16:45:37 <hulahub> e.g. i've a list of [1,2,3] - i want to know if a 2 is in the list - how to do that ?
16:45:44 <triplah> this is throwing a parse error
16:45:53 <Lemmih> > 2 `elem` [1,2,3]
16:45:54 <jethr0> > any (==2) [1,2,3]
16:45:54 <lambdabot> True
16:45:55 <lambdabot> True
16:46:02 <hulahub> ah ok
16:46:02 <int-e> @type elem
16:46:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:46:31 <dons> jeffno, the file is caalled 'Setup.lhs'
16:46:49 <jeffno> dons: Ok, I tried that too.
16:47:20 <jeffno> Setup.lhs:10:20:
16:47:20 <jeffno>     Couldn't match `IO' against `(->) t'
16:47:20 <jeffno>       Expected type: IO t1
16:47:20 <jeffno>       Inferred type: t -> t2
16:47:20 <jeffno>       Expected type: IO t1
16:47:20 <jeffno>       Inferred type: Distribution.Simple.LocalBuildInfo.LocalBuildInfo
16:47:22 <jeffno>                      -> IO GHC.IOBase.ExitCode
16:47:24 <jeffno>     Probable cause: `(postConf defaultUserHooks)' is applied to too few arguments in the call
16:47:26 <jeffno>         ((postConf defaultUserHooks) args' flags lbi)
16:47:42 <Lemmih> Looks like you need a newer Cabal.
16:47:51 <dons> oh, you have a newer cabal. uncomment the 'xx' argument in Setup.lhs
16:47:54 <jeffno> I just installed the latest!
16:48:02 <dons> it appears in 2 places.
16:48:04 <Lemmih> Oh, it's too new (:
16:48:22 <jeffno> By the way, the README in lambdabot says Setup.hs.
16:48:26 <dons> fixed.
16:49:00 <SamB> dons: hello?
16:50:13 <SamB> dons: okay, I've got 20:27
16:50:28 <SamB> at 0.1p133
16:50:33 <dons> SamB, I was wondering whether you reckon there are any issues that need to be sorted out before I release 0.2
16:50:47 <SamB> dons: I haven't seen anything
16:51:08 <SamB> the only issue I have is that I am bored of this playlist :-(
16:51:19 <dons> oh. well you need more music!
16:51:31 <SamB> yes!
16:51:38 <dons> I think you're 'sposed to use conjure for that ;)
16:51:56 <SamB> dons: it doesn't work yet!
16:52:03 <dons> doh!
16:52:07 <SamB> well, I suppose I could use BitTornado.
16:52:43 <SamB> but it would take a ridiculous amount of time to download even the smallest OCR torrent
16:53:10 <jeffno> dons: Ok, after uncommenting I also had to chmod +x configure
16:53:21 <SamB> and I don't really know of any others...
16:53:38 <SamB> (OCR meaning overclocked remixes)
16:53:58 <dons> jeffno:         $ chmod +x Setup.lhs configure
16:53:59 <dons>         $ ./Setup.lhs configure --prefix=/usr/local
16:54:04 <dons>         $ ./Setup.lhs build
16:54:04 <dons>         $ ./Setup.lhs install
16:54:10 <dons> in the readme ;)
16:55:03 <SamB> hmm, darcs has been running for HOURS AND HOURS
16:55:14 <SamB> it is being MEAN AND NASTY
16:55:28 <jeffno> I was using the README for lambdabot.
16:55:47 <dons> oh. ok. why would configure in lambdabot need chmod +x ?
16:55:58 <dons> that seems very strange. autoconf should do that automagically.
16:55:59 <dons> hmm
16:56:07 <jeffno> No, the readme in lambdabot tells you how to build hs-plugins.
16:56:14 <dons> ah, I see what you mean.
16:56:35 <jeffno> Maybe it should just tell you to read the respective READMEs.
16:56:38 <dons> fixed.
16:57:15 <dons> eveyone's building lambdabot these days, it seems.
16:57:34 <jeffno> Gotta have the latest toys.
16:57:35 * SamB hasn't touched lambdabot in months
16:57:59 <SamB> well, maybe I built it once when lambdabot was down...
16:58:17 * jethr0 hasn't even seen the code for lambdabot, yet.
16:58:25 <dons> SamB, and now lambdabot resents you. she needs more affection
16:58:31 <dons> @version
16:58:31 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
16:58:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:58:36 <SamB> dons: I like lambdabot fine!
16:58:43 <SamB> @hug
16:58:44 <lambdabot> Not enough privileges
16:58:47 <SamB> hmm
16:58:51 <dons> hehe!
16:59:01 <SamB> what is lambdabot misinterpreting my request as?
16:59:04 <SamB> @botsnack
16:59:04 <lambdabot> :)
16:59:07 <SamB> @bot
16:59:07 <lambdabot> :)
16:59:12 <SamB> @help bot
16:59:12 <lambdabot>  @help <command> - ask for help for <command>
16:59:19 <SamB> @help botsnack
16:59:20 <lambdabot> bot-feeder
16:59:28 <SamB> @listcommands botsnack
16:59:29 <lambdabot> dummy provides: dummy get-shapr eurohaskell wiki paste docs libsrc learn
16:59:29 <lambdabot> map botsnack
16:59:36 <SamB> @dummy
16:59:36 <lambdabot> dummy
16:59:46 <SamB> @eurohaskell
16:59:46 <lambdabot> less talks, more code!
16:59:46 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
16:59:46 <lambdabot> EuroHaskell - Haskell Hackfest - Summer 2005 
16:59:46 <lambdabot> - Gothenburg, Sweden
16:59:50 <jethr0> @botsnack get-shapr
16:59:50 <lambdabot> :)
17:00:01 <SamB> @get-shapr
17:00:01 <jethr0> @get-shapr
17:00:01 <lambdabot> shapr!!
17:00:02 <lambdabot> shapr!!
17:00:05 <jethr0> hehe
17:00:08 <palomer> :o
17:00:13 <palomer> yeah, where's shapr
17:00:16 <SamB> which was which?
17:00:32 <SamB> @docs
17:00:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:00:39 <SamB> @docs foo
17:00:39 <lambdabot> foo not available
17:00:40 <jethr0> @help paste
17:00:40 <lambdabot> paste page url
17:00:44 <SamB> @libsrc
17:00:45 <lambdabot>  not available
17:00:52 <SamB> @libsrc Monad
17:00:53 <lambdabot> Monad not available
17:00:55 <jethr0> @paste http://slashdot.org
17:00:56 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:00:58 <SamB> @libsrc Control.Monad
17:00:59 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
17:01:09 <SamB> @learn
17:01:10 <lambdabot> http://www.haskell.org/learning.html
17:01:13 <SamB> @map
17:01:14 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:01:45 <lispy> it's hard to remember to update the map when i move :)
17:01:53 * jethr0 wonder how anyone would come up with the name "botsnack" for this...
17:01:56 <palomer> damnit, where's monochrom when you need'em
17:02:16 <jethr0> lispy: are you still doing that manually. i tied my gps in month ago!
17:03:00 <palomer> anyone know if termination of a program P can be expressed in first order logic
17:03:32 <palomer> ie P terminates iff phi(P) is provable
17:03:47 <palomer> phi: string -> first order formula
17:03:49 <SamB> palomer: sounds pretty unlikely
17:04:01 <palomer> SamB: are you sure?
17:04:20 <SamB> heard of the halting problem?
17:04:23 <jeffno> dons: When I make lambdabot, I get:
17:04:26 <jeffno> Binary.hs:1:0:
17:04:26 <jeffno>     Warning: `IO' is imported more than once:
17:04:26 <jeffno>                imported from GHC.IOBase at Binary.hs:28:25-30
17:04:26 <jeffno>                imported from Prelude at Implicit import declaration
17:04:26 <jeffno> make: *** [Binary.o] Error 1
17:04:27 <jeffno> $
17:04:35 * jeffno halts.
17:04:43 <palomer> isn't the halting problem turing equivalent to  first order proving?
17:05:01 <jethr0> "turing equivalent"??
17:05:15 <palomer> jethr0: an algorithm of one gives an algorithm of the other
17:05:38 <jethr0> but the halting problem isn't an algorithm. that's pretty much the problem with it!
17:05:40 <palomer> I know that proving first order formulae is at least as hard as the halting problem
17:05:49 <SamB> oh
17:05:53 <SamB> in that case, maybe!
17:06:04 <palomer> yeah, this is _exactly_ what monochrom studies
17:06:18 <hulahub> > any (!='x') [a,b,x]
17:06:19 <lambdabot>  Not in scope: `x'
17:06:20 <jeffno> How can it be "at least as hard" if it is impossible to solve the halting problem?
17:06:24 <SamB> jethr0: heard of scooby snacks? maybe they are related?
17:06:27 <hulahub> hmm
17:06:42 <SamB> jeffno: by being no less impossible?
17:06:50 <lispy> jeffno: the halting problem isn't unsolvable
17:06:51 <hulahub> does any (!=c) .. not work if c is a char ?
17:06:52 <jethr0> palomer: if FOF is harder to prove than halting problem (which can't be proven), doesn't that leave you with a problem?
17:06:54 <jeffno> Ok, but could it be "more" impossible?
17:06:57 <lispy> jeffno: it's that a computer can't do it :)
17:07:09 <jeffno> lispy: Umm, it can't in all cases.
17:07:27 <palomer> this is my statement: if we can get an algorithm for proving FOF, then we can solve the halting problem
17:07:30 <lispy> my text book doesn't make that claim
17:07:36 <palomer> does anyone have a problem with this statement?
17:07:36 <jeffno> lispy: Get a new textbook!
17:07:40 <jeffno> Or reread it.
17:08:10 <JohnMeacham> how do I get my password on the hawiki reset? my login is JohnMeacham
17:08:50 <lispy> jeffno: it's impossible for a turing machine to solve.  I would agree with that, but unless someone can prove it is unsolvable in any way I don't buy it
17:09:36 <jethr0> lispy: yes, but how are you supposed to find an algorithm for a turing machine for the FOF, which is supposedly "turing equivalent"?
17:09:38 <jeffno> Ok, so you don't believe in the Universal Computer.
17:09:59 <JohnMeacham> yes, I believe if you could solve the halting problem you can solve first order proving.
17:10:15 <palomer> jethr0: two problems are turing equivalent if, given an algorithm to solve one, you can solve the other
17:10:52 <palomer> JohnMeacham: do you have a reference?
17:11:14 <lispy> jeffno: the universal computer being the turing machine that simulates turing machines?
17:11:16 <int-e> JohnMeacham: right, because first order theorems are recursively enumerable.
17:11:18 <jethr0> palomer: i get that part. but given that "halting problem" is unsolvable for all cases on a turing machine, and turing equivalence of FOF and HP, HP can't be solved on a turing machine...
17:11:36 <palomer> FOF can't either
17:11:40 <JohnMeacham> because it has a single existential quantifier, 'there exists a proof'. so write a program that runs through every proof checking them and quitting if it is a valid one. if said program halts or not gives you your answer
17:11:51 <jeffno> lispy: Actually I meant that you can't get any more power machines than Turning machines.
17:12:00 <palomer> JohnMeacham: there exists a proof is expressible in first order logic?
17:12:02 <jeffno> The Universal Computer just being a Turning machine.
17:12:14 <hulahub> HALT! 
17:12:15 <lispy> jeffno: ah, yeah, i don't believe that turing machines are as powerful as possible
17:12:16 <hulahub> *g
17:12:17 <int-e> palomer: with natural numbers, addition and multiplication it is.
17:12:33 <palomer> int-e: I assume no axioms
17:12:33 <jeffno> lispy: Got an idea for a better one?
17:12:45 <JohnMeacham> yup. recursively enumerable means it is possible to generate every proof with a recursive program which is why that algorithm works.
17:12:51 <hulahub> jeffno: a ms pc? *g
17:13:03 <jeffno> Maybe if you break consistency in a useful way.
17:13:04 <jethr0> what can solve problems that turing machines can't?
17:13:10 <lispy> jeffno: nope.  I would say that it's a reasonable hypothesis.  But I wouldn't state it as fact either :)
17:13:20 <int-e> palomer: without axioms you can't prove anything ;)
17:13:23 <musasabi> JohnMeacham: doesn't that work only for finite proofs?
17:13:35 <palomer> JohnMeacham: I have to admit, I'm not catching you. What are you claiming? (and how are you proving it?)
17:13:37 <jethr0> int-e: hear, hear!
17:13:38 <musasabi> (or do we define a proof as finite)
17:13:41 <hulahub> the turing machine works as long as your tape is not broken
17:13:42 <hulahub> :D
17:13:43 <palomer> int-e: sure you can, you can prove theorems
17:13:46 <palomer> int-e: for example:
17:13:48 <int-e> palomer: (ok, you can do everything on a syntactic level, sure ...)
17:13:54 <jeffno> lispy: I don't think your hypothesis is reasonable without addressing Turning's argument.
17:14:04 <ihope> > sub id id where sub x y z = x z (y z)
17:14:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:14:05 <lambdabot>   Expected type: (t -> t1) -> t
17:14:05 <lambdabot>   Inferred type: (t -> t1) -> t -> t1
17:14:05 <jethr0> hulahub: and with an infinitely long tape, that would be quite the tape jam!
17:14:29 <lispy> jeffno: which is?
17:14:42 <JohnMeacham> musasabi: it will eventually enumerate every proof. since your solution to the halting problem will tell you if it will ever halt, even in the infinite future it will find the solution if one exists no matter what its size.
17:14:46 <lispy> jethr0: hehe
17:14:52 <jeffno> lispy: I dunno, I've never read it :)
17:15:06 <jeffno> I assume if it was flawed I'd have heard about it by now.
17:15:09 <palomer> forall x.forall y. (s(+(x,y)) =+(sx,y) ^ +(x,y) = +(y,x)) -> s(+(0,1)) = +(1,1)
17:15:15 <palomer> this is a theorem
17:15:33 <jethr0> with the halting problem solved, you can execute every conceivable output and thereby solve all problems that are solvable by the turing machine!
17:15:36 <lispy> jeffno: turing didn't prove that there was no machine with more power than a turing machine
17:15:39 <palomer> first order theorem proving is recursively enumerable, yes
17:15:44 <palomer> but so is the halting problem
17:15:49 <jethr0> conceivable program*
17:15:56 <JohnMeacham> musasabi: unless you mean a proof with an infinite number of terms.. which I am not sure if it gives you any more expressibility in first order logic, but don't know off the top of my head.
17:15:57 <SamB> JohnMeacham: but if the proof was infinite, it wouldn't stop anyways
17:16:23 <jethr0> i'm not sure one can call an "infinite proof" a proof.
17:16:27 <ihope> An algorithm for generating an infinite proof is a finite proof.
17:16:29 <jethr0> ;-)
17:16:31 <ihope> ...I think.
17:16:36 <musasabi> JohnMeacham: yes, that was what I was thinking of - infinite number of terms, but I am too tired to think how that would affect things.
17:16:43 <jethr0> ihope: only if you can proove its correctness *g*
17:16:53 <hulahub> jethr0: is there a way to use any with a list of chars? to check if a 'x' is inside ['a', 'b', 'x'] e.g. ?
17:17:23 <triplah> @type isIn
17:17:23 <jethr0> diagonalisation argument for real -> int is infinite (as are all inductive proofs).
17:17:24 <lambdabot> Not in scope: `isIn'
17:17:27 <triplah> doh
17:17:28 <triplah> :)
17:17:42 <ihope> element [] _ = False ; element (x:xs) y = y == x || element xs y
17:17:46 <ihope> Something like that...
17:17:56 <jethr0> hulahub: this wouldn't be homework, would it?
17:17:57 <Lemmih> Can't you use 'elem'?
17:18:08 <JohnMeacham> in any case proof usually implies a finite set of derivations. but if you think about it, an infinite proof would either actually contain an infinite amount of information, in which case it is not really a proof because it can never be stated, or you can find a finite generator for it, and hence find a finite proof.
17:18:26 <palomer> > elem 'a' "abc"
17:18:27 <ihope> ...That's what I said :-)
17:18:27 <lambdabot> True
17:18:36 <jeffno> lispy: Ok, not proven, but the thesis is well accepted.
17:18:41 <JohnMeacham> but my arguments are rather handwavy.
17:18:41 <ihope> > elem (+) [(+),(-)]
17:18:42 <lambdabot>  add an instance declaration for (Eq (a -> a -> a))
17:18:42 <lambdabot>   In the definition of `wrrxjbgv': wrrxjbgv = elem (+) [(+), (-)]
17:18:42 <lambdabot>   In the definition of `v':
17:18:52 <ihope> >:-)
17:18:52 <triplah> hah!
17:18:54 <hulahub> jethr0: ? homework? this is "The adventure of the difference between imperative and functional programming"
17:19:06 <int-e> palomer: anyway if you have addition and multiplication you can express finite sequences of integers in the form a(n) = x (mod y*n + z) for some x, y and z. this is enough to encode a proof and verify it step by step in a first order formula.
17:19:12 <JohnMeacham> ihope: so you did. I missed that :)
17:19:18 <jethr0> aha.
17:19:20 <palomer> JohnMeacham: you can have proofs in second order logic which can only be expressed as infinite proofs in first order logic (with infinite formulae, of course)
17:19:24 <hulahub> palomer: ah ok ..
17:19:53 <palomer> int-e: you can put the axioms as part of your statement
17:19:55 <ihope> Second order logic? Eep.
17:20:02 <hulahub> jethr0: no homework - just for fun
17:20:03 <palomer> oh wait, you don't have the inductive hypothesis
17:20:04 * araujo saluda a Nomius 
17:20:10 <JohnMeacham> palomer: then a proof in first order logic does not exist and that is your answer. the question of whether a proposition is true is a different one than asking whether a proof exists in a given system.
17:20:35 <triplah> i've got homework. but i'll wager no one here can fix it in under 15 mins :)
17:20:36 <jethr0> hulahub: any (=='x') ['a', 'b', 'x']
17:20:42 <int-e> palomer: I can have any instance of the inductive hypothesis that I want to use
17:20:45 <palomer> JohnMeacham: err, a proof does exist, but your formula is infinite
17:20:46 <triplah> if they do i'll send them money :P
17:20:53 <jethr0> triplah: i won't try if cale couldn't help you...
17:20:56 <palomer> first order logic is sound and complete
17:21:02 <hulahub> jethr0: i tried that - id didn'T want to work --- but elem seems to work :D thanks
17:21:04 <JohnMeacham> and goedel showed us that there ain't no such algorithm for determining truth so we can stop worrying about such philosophical ideals :)
17:21:09 <triplah> jethr0: :(
17:21:18 <palomer> either A is provable, or not(A) is provable
17:21:28 <ihope> Really?
17:21:31 <jethr0> > any (=='x') ['a', 'b', 'x']
17:21:32 <lambdabot> True
17:21:34 <ihope> True or false: x = 3
17:21:37 <jethr0> > any (=='x') ['a', 'b', 'c']
17:21:38 <lambdabot> False
17:21:46 <jethr0> hulahub: works perfectly fine!
17:22:00 <ihope> Not provable either way...
17:22:20 <jethr0> ihope: (True v False)
17:22:31 <JohnMeacham> palomer: not true. not within a system. that is goedels thesis. you can prove more by going outside the system like you said, but then you will get new stuff for which neither A or not(A) is provable.
17:22:37 <Lemmih> let elem' f [] = False; elem' f (x:xs) = case I# (reallyUnsafePtrEquality# f x) of 1 -> True; 0 -> elem' f xs in (elem' (+) [(-),(+)], elem' div [(-),(+)])
17:22:41 <hulahub> Faltrue
17:22:43 <Lemmih> (True,False)
17:22:56 <palomer> JohnMeacham: in any higher order logic, A or not(A) is provable
17:23:54 <JohnMeacham> palomer: I am pretty sure that is not true.
17:23:57 <ihope> Lemmih
17:24:04 <ihope> : was that Haskell?
17:24:08 <Lemmih> ihope: Yep.
17:24:10 <ihope> :-)
17:24:12 <int-e> palomer: how many formulas are that?
17:24:18 <Lemmih> Evil Haskell, that is.
17:24:24 <ihope> :-D
17:24:26 <int-e> `A or not(A)' is certainly provable, yes.
17:24:34 <palomer> JohnMeacham: if A is provable in FOL, then A is provable in SOL, TOL, FourthOL
17:24:51 <ihope> Couldn't you call it FoOL?
17:24:53 <JohnMeacham> Ah, I missed the A must be expressible in FOL.
17:25:01 <JohnMeacham> then that is true.
17:25:31 <palomer> A v not(A) is a FOF
17:25:49 <palomer> ihope: who are you calling a fool?
17:26:36 <ihope> Call it FiOL then :-)
17:26:58 <JohnMeacham> not if A contains arbitrary quantifications. but in any case, we are out of my range of stuff I remember from school so have started intuiting things a while ago, so I better stop lest I spread misinformation.
17:27:00 <ihope> Then fifth would be SiOL, sixth SevOL, etc.
17:27:41 <palomer> monochrom, where are youuuuuuuuuuuuuuuuuuuuu
17:27:49 <JohnMeacham> the wikipedia page has some good info http://en.wikipedia.org/wiki/First_order_logic
17:30:34 <triplah> argh, im commenting my code. and suddenly it wont parse anymore
17:30:39 <triplah> all comment blocks are closed
17:30:40 <triplah> :(
17:30:48 <ihope> Hmm...
17:31:13 <jethr0> triplah: good thing you backup regularly, isn't it.
17:31:26 <triplah> :\
17:31:53 <jethr0> triplah: but seriously; can't you undo in your editor?
17:32:02 <triplah> yeah
17:32:07 <triplah> i'll paste the code elsewhere
17:32:13 <triplah> er
17:32:15 <triplah> comments
17:34:20 <palomer> usually when it doesn't parse it tells you exactly where it doesn't parse
17:34:26 <triplah> phew :)
17:34:36 <triplah> palomer: yeah, its saying an "=" that doesnt exist
17:35:33 <triplah> ah
17:35:33 <palomer> so make it exist!
17:35:39 <triplah> its something to do with where's and indentation
17:36:04 <fworp> paste it and let us have a look at it
17:36:32 <triplah> ahh i got it
17:36:46 <triplah> its something to do with tab's and spaces
17:38:03 <jethr0> triplah: _those_ are the worst!! i switched to expanded tabs (i.e. all spaces) and never looked back!
17:38:18 <jethr0> triplah: vim can visualize tabs.
17:39:38 <triplah> how do i do that?
17:41:14 <jethr0> :set list
17:41:19 <triplah> ta
17:41:42 <triplah> ahh
17:41:42 <jethr0> it's not the prettiest option, but the one i could find fastest. TAB=^I
17:41:44 <triplah> brilliant
17:41:59 <triplah> argh
17:42:04 <triplah> combined use of space and tab
17:42:08 <triplah> my eyes!
17:43:29 <jethr0> :set unlist
17:43:46 <jethr0> :syn match Tab '[press tab]' | highlight Tab ctermbg=2
17:44:30 <jethr0> keep the ticks, lose the brackets and press tab ;-)
17:44:44 <jethr0> looks like '^I'
17:45:07 <JohnMeacham> there is talk of just having the compiler reject any program with literal tabs in them.
17:45:39 <jethr0> hmm, although i am a strong proponent of tab-free code, this sounds unnecessarily harsh.
17:45:52 <SamB> JohnMeacham: I like that idea
17:45:55 <jethr0> in python there was talk, but it's just too drastic a measure
17:45:56 <JohnMeacham> yeah, it is just talk.
17:46:00 <JohnMeacham> but, possible.
17:46:10 <triplah> jethr0: nah i dont mind this
17:46:18 <SamB> should be default, I think
17:46:23 <triplah> im complaining about the rampant mixing of delimeters in my code
17:46:37 <triplah> its whitespace spagetti
17:46:39 <jethr0> triplah: complaining to _who_?
17:46:41 <JohnMeacham> is there a hawiki page on how to enable tab expansion in every popular editor? there should be, so we can point people to it.
17:46:51 <triplah> jethr0: anyone who cares to take pity :)
17:47:12 <JohnMeacham> In any case, I think a harsh warning from the compiler is in order.
17:47:19 <jethr0> triplah: choose a tabwidth and ":%s/^I/    /g" with "^I" == Tab and "   " the number of spaces you like
17:47:31 <jethr0> triplah: not really; it's easily fixed!
17:47:39 <triplah> i'm replacing my spaces with tabs, perhaps i should be doing the reverse?
17:48:01 <jethr0> johnmeacham: i think a warning for mixing leading tabs and spaces is ok!
17:48:04 <hulahub> whats the reason that
17:48:07 <hulahub> > 1 / 10
17:48:09 <lambdabot> 0.1
17:48:10 <hulahub> works
17:48:17 <hulahub> but
17:48:21 <jethr0> triplah: yes, i think so, spaces are just "more reliable", somehow
17:48:33 <hulahub> > 1 / (length [1,2,3])
17:48:34 <lambdabot>  add an instance declaration for (Fractional Int)
17:48:34 <lambdabot>   In the definition of `nentyuny': nentyuny = 1 / (length [1, 2, 3])
17:48:34 <lambdabot>   In the definition of `v':
17:48:37 <hulahub> not
17:48:47 <triplah> ok, so i could sed the tabs in my code and replace them with 4 spaces or something
17:48:52 <jethr0> triplah: ":set expandtab" will vim do all the work
17:48:57 <triplah> ok cool
17:48:58 <ihope> > 1 / (fromInt (length [1,2,3]))
17:48:59 <lambdabot>  Not in scope: `fromInt'
17:49:00 <jethr0> will let!
17:49:05 <ihope> Mmh
17:49:11 <SamB> > 1 / (fromIntegral (length [1,2,3]))
17:49:12 <lambdabot> 0.3333333333333333
17:49:30 <jethr0> > 1 / (length [1,2,3])
17:49:31 <lambdabot>  add an instance declaration for (Fractional Int)
17:49:31 <lambdabot>   In the definition of `zzzyusik': zzzyusik = 1 / (length [1, 2, 3])
17:49:31 <lambdabot>   In the definition of `v':
17:49:42 <triplah> hmm its putting in 8 spaces
17:49:57 <jethr0> triplah: undo and set your tabstop=4
17:50:16 <jethr0> oh, ":set shiftwidth"... not sure what that is for??
17:51:15 <triplah> it isnt finding ^I :\
17:52:14 <jethr0> it's not exactly '^I'. what are you trying?
17:52:26 <triplah> :%s/^I/    /g
17:52:34 <triplah> i need the special char for tab then
17:52:41 <jethr0> :%s/<press tab>/  /g
17:52:42 <triplah> just press tab i guess
17:52:43 <triplah> :)
17:52:47 <triplah> ahh heh
17:52:48 <triplah> ta
17:53:03 <jethr0> or :%s/<^V Tab>/   /g
17:53:16 <triplah> thanks worked a charm
17:53:30 <SamB> dons: what ever happened to those things you wanted to add to CategoryApplication?
17:53:57 <jethr0> triplah: enabling expandtab and saving should have removed them anyways.
17:54:17 <triplah> yep
17:54:28 <triplah> just had about 200 lines of call all using tabs
17:54:28 <triplah> :)
17:54:32 <triplah> code*
17:54:51 <hulahub> p :: Int -> Int -> Float
17:54:51 <hulahub> p x y = x / y
17:54:58 <hulahub> why does this not work...
17:55:15 <hulahub> error is that result is Int and no float
17:55:20 <hulahub> is there a way to force a float ?
17:55:24 <int-e> > let p x y = fromInteger x / fromInteger y in p 1 3
17:55:25 <lambdabot> 0.3333333333333333
17:55:37 <hulahub> fromInteger forces a float ?
17:55:46 <int-e> @type fromInteger
17:55:47 <lambdabot> forall a. (Num a) => Integer -> a
17:56:12 <int-e> hmm
17:56:15 <JohnMeacham> you can also use the 'expand' program. but having the editor do it is the best choice.
17:56:41 <int-e> let a::Int; a=5; x::Float; x = fromInteger a in x
17:56:46 <int-e> >let a::Int; a=5; x::Float; x = fromInteger a in x
17:56:52 <int-e> > let a::Int; a=5; x::Float; x = fromInteger a in x
17:56:53 <lambdabot> Couldn't match `Integer' against `Int'
17:57:08 <int-e> > let a::Int; a=5; x::Float; x = fromInteger $ toInteger a in x
17:57:11 <lambdabot> 5.0
17:57:11 <hulahub> int-e: - but im using int's ... so i get the error int != integer -- but there is no fromInt function available....
17:57:23 <ihope> fromIntegral?
17:57:33 <int-e> > let a::Int; a=5; x::Float; x = fromIntegral a in x
17:57:34 <jethr0> int-e: what a beautiful line of code. what that we can get _everyone_ to use haskell, finally ;-)
17:57:34 <lambdabot> 5.0
17:57:50 <jethr0> with that*
17:57:56 <int-e> thanks ihope 
17:58:14 <ihope> 'Welcome
17:58:42 <ihope> Now, is there any equivalent of that for floats?
17:59:05 <jethr0> @type fromFractional
17:59:06 <lambdabot> Not in scope: `fromFractional'
17:59:23 <jethr0> @type fromRational
17:59:24 <lambdabot> forall a. (Fractional a) => Rational -> a
17:59:36 <jethr0> hmm, not quite
18:00:47 <triplah> :set unlist aint working :)
18:02:26 <jethr0> :set nolist
18:02:27 <jethr0> sry
18:03:40 <triplah> ty :D
18:03:46 <jethr0> np
18:04:05 <hulahub> what does 'inf' instead of a float number mean? *g
18:04:18 <int-e> > 1/0
18:04:20 <lambdabot> Infinity
18:04:42 <hulahub> that can't be ... 
18:04:43 <hulahub> hmm
18:04:53 <jethr0> int-e: nice touch of verbosity. are you letting lambdabot answer for you these days?
18:05:24 <hulahub> ahh :D
18:07:09 <int-e> > map chr [89,101,115]
18:07:10 <lambdabot> "Yes"
18:07:29 <jethr0> *bfg*
18:07:58 <triplah> @type chr
18:07:59 <lambdabot> Not in scope: `chr'
18:08:16 <ihope> > map ord "Hello, world!"
18:08:17 <lambdabot> [72,101,108,108,111,44,32,119,111,114,108,100,33]
18:08:29 <jethr0> > map chr [119,101,108,108,32,100,111,110,101,32,115,105,114,46]
18:08:30 <lambdabot> "well done sir."
18:08:34 <triplah> hahaha
18:08:45 <triplah> ascii values?
18:08:45 <int-e> triplah: it's in Data.Char
18:08:52 <triplah> int-e: ok thanks
18:10:08 <jethr0> how again did we split a string at a certain character? i can't remember
18:10:30 <jethr0> func "abc=def=ghi"    =>    ["abc","def","ghi"]
18:11:17 <triplah> > partition "b" "abc"
18:11:18 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
18:11:22 <triplah> bah :)
18:11:30 <jethr0> > partition 'b' "abc"
18:11:31 <lambdabot> Couldn't match `a -> Bool' against `Char'
18:11:40 <jethr0> > partition (=='b') "abc"
18:11:41 <lambdabot> ("b","ac")
18:11:45 <triplah> @type partition
18:11:46 <lambdabot> Not in scope: `partition'
18:11:53 <triplah> @type Data.List.partition
18:11:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:11:57 <hulahub> cool
18:11:59 <triplah> ahh
18:11:59 <jethr0> > partition (=='=') "ab=cd=ef"
18:12:00 <lambdabot> ("==","abcdef")
18:12:07 <hulahub> speed is really good
18:12:13 <triplah> no shit
18:12:16 <jethr0> no, partition is _definitely_ not it!
18:12:17 <triplah> >:D
18:12:24 <ihope> > break (=='b') "abc"
18:12:26 <lambdabot> ("a","bc")
18:12:42 <jethr0> > break (=='=') "ab=cd=ef"
18:12:44 <lambdabot> ("ab","=cd=ef")
18:13:26 <jethr0> thx, ihope
18:13:31 <triplah> >break (=='d') ["abc","def","ghi"]
18:13:34 <lisppaste2> hulahub pasted "Really Bad HTree" at http://paste.lisp.org/display/14271
18:13:46 <hulahub> int-e: this one is for you :D
18:13:55 <hulahub> int-e: will destroy your eyes *g
18:14:27 <hulahub> gc, cp and cf are soooo baaad implemented :D but it works for testing :D
18:14:48 <hulahub> cc (ct (sortBy o (cf (cp text text "") text))) "" - gives you a cool list *g
18:14:53 <Lemmih> > fix (\f c l -> if null l then [] else let (s,e) = break c l in s:f c (dropWhile c e)) (=='=') "hello=world=yo"
18:14:54 <lambdabot> ["hello","world","yo"]
18:15:39 <jethr0> lemmih: i am still a little perplexed by "fix". how is it different from iterate?
18:15:59 <Lemmih> @type iterate
18:16:00 <lambdabot> forall a. (a -> a) -> a -> [a]
18:16:01 <Lemmih> @type fix
18:16:03 <lambdabot> Not in scope: `fix'
18:16:26 <int-e> > length $ filter ('c'==) "abcdefqwertyiccccd"
18:16:27 <lambdabot> 5
18:16:31 <Lemmih> @type Control.Monad.Fix.fix
18:16:32 <lambdabot> forall a. (a -> a) -> a
18:17:11 <jethr0> lemmih: how would you describe what fix does?
18:17:39 <Lemmih> fix x = x (fix x)
18:18:00 <ihope> Aha!
18:18:08 <int-e> > group $ sort "abcvsadoncap0oh;lszc"
18:18:09 <lambdabot> ["0",";","aaa","b","ccc","d","h","l","n","oo","p","ss","v","z"]
18:18:15 <Lemmih> > fix (\mysum l -> case l of [] -> 0; (x:xs) -> x + mysum xs) [1,2,3]
18:18:16 <lambdabot> 6
18:19:05 <jethr0> lemmih: i find those hard to read. but that effect will likely pass with conditioning ;-)
18:19:35 <hulahub> int-e: took a look at it ?
18:19:36 <int-e> > map (head &&& length) $ group $ sort "abcvsadoncap0oh;lszc"
18:19:37 <lambdabot> [('0',1),(';',1),('a',3),('b',1),('c',3),('d',1),('h',1),('l',1),('n',1),(
18:19:37 <lambdabot> 'o',2),('p',1),('s',2),('v',1),('z',1)]
18:19:43 <jethr0> > (\mysum l -> case l of [] -> 0; (x:xs) -> x + mysum xs) [1,2,3]
18:19:44 <lambdabot> Couldn't match `[a] -> a' against `[a1]'
18:20:39 <jethr0> lemmih: is fix for defining recursive lambda functions? or does it something else?
18:20:42 <int-e> hulahub: hmm, could be worse :)
18:20:52 <Lemmih> jethr0: Yep, exactly.
18:21:49 <hulahub> int-e: this map.... hmmm
18:22:09 <hulahub> its a far better way for what i use? :D
18:22:36 <jethr0> int-e: any idea for a good overview of arrow operators?
18:22:42 <int-e> hulahub: I think using group and sort like that is a good idea
18:22:56 <hulahub> what does the $ mean ?
18:23:18 <int-e> hulahub: a $ b = a b .... but $ is right associative and has a very low precedence
18:23:47 <int-e> hulahub: so a $ ... is like a (...)
18:24:12 <hulahub> so it means first sort, than group ?
18:24:23 <int-e> hulahub: right
18:24:34 <int-e> > group "aabbaabb"
18:24:35 <lambdabot> ["aa","bb","aa","bb"]
18:24:39 <int-e> > group $ sort "aabbaabb"
18:24:41 <lambdabot> ["aaaa","bbbb"]
18:25:15 <triplah> > sort . group "aabbaabb"
18:25:16 <lambdabot>   Expecting a function type, but found `[[a]]'
18:25:16 <lambdabot>   Expected type: a1 -> [a]
18:25:16 <lambdabot>   Inferred type: [[a2]]
18:25:23 <triplah> :\
18:25:31 <jethr0> > sort . group $ "aabbaabb"
18:25:32 <lambdabot> ["aa","aa","bb","bb"]
18:25:56 <jethr0> > (sort . group) "aabbaabb"
18:25:57 <lambdabot> ["aa","aa","bb","bb"]
18:26:27 <int-e> jethr0: hmm. I've read a paper about arrows and if I'm unsure I look at the source code.
18:26:29 <triplah> my understanding of . was (f(g x)) = f . (g x)
18:26:53 <int-e> triplah: nope. f (g x) = (f . g) x
18:26:59 <jethr0> int-e: as always... well, at least haskell code is a treat to read, mostly ;-)
18:27:19 <int-e> jethr0: I'd implement cf with map, too
18:27:21 <hulahub> > group (sort "aaababaabaababbaba")
18:27:22 <lambdabot> ["aaaaaaaaaaa","bbbbbbb"]
18:27:31 <hulahub> why not this way? why the $ ?
18:27:42 <jethr0> int-e: "cf"?
18:27:45 <int-e> hulahub: that's a matter of taste
18:27:53 <int-e> jethr0: sorry, I meant hulahub 
18:28:07 <triplah> hmm, i thought f . g x is f applied to the result of g x
18:28:26 <int-e> triplah: no, that's $ :)
18:28:40 <triplah> ahh
18:28:45 <triplah> so f . g x is?
18:28:51 <jethr0> triplah: (.) does function concatenation
18:29:13 <triplah> jethr0: i understand its composition. i just dont grasp its difference to a sequence of applications
18:29:21 <int-e> > (succ . (+) (-1)) 2
18:29:22 <lambdabot> 2
18:29:48 <jethr0> ((*2) . (+2)) 4
18:29:55 <jethr0> > ((*2) . (+2)) 4
18:29:57 <lambdabot> 12
18:30:06 <triplah> > * . (- (3 4)
18:30:06 <lambdabot>  parse error on input `*'
18:30:12 <int-e> triplah: f . g x is f . (g x)
18:30:16 <triplah> > (*) . (- (3 4)
18:30:17 <lambdabot>  parse error on input `}'
18:30:22 <jethr0> > myfunc 4 where myfunc = (*2) . (+2)
18:30:23 <lambdabot> 12
18:30:31 <int-e> triplah: (f . g x) y is (f . (g x)) y = f (g x y)
18:30:37 <jethr0> triplah: (.) returns a function (as far as i know)
18:30:40 <jethr0> @type (.)
18:30:41 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
18:30:44 <hulahub> int-e: what does the &&& do? if i copy the map you did to hugs i get error that &&& is unknown
18:30:57 <jethr0> okay, it doesn't
18:30:58 <int-e> hulahub: &&& is defined in Control.Arrow
18:31:42 <int-e> hulahub: for this purpose, it takes two functions a -> b and a -> c and builds a function a -> (b, c)
18:32:11 <hulahub> this map is just wow :D
18:32:12 <triplah> so if i wanted to (snd (head list)) using composition ?
18:32:25 <ihope> (snd . head) list, I think
18:32:30 <jethr0> > (snd . head) [1,2,3]
18:32:31 <lambdabot>  add an instance declaration for (Num (a, b))
18:32:31 <lambdabot>   In the list element: 3
18:32:36 <jethr0> > snd . head $ [1,2,3]
18:32:37 <lambdabot>  add an instance declaration for (Num (a, b))
18:32:37 <lambdabot>   In the list element: 3
18:32:51 <triplah> (snd . head) [(1,2)]
18:32:55 <triplah> > (snd . head) [(1,2)]
18:32:56 <lambdabot> 2
18:32:58 <jethr0> triplah: you need "$" or parens because (.) has a very low priority
18:32:59 <triplah> hey cool
18:33:06 <triplah> ahh i see
18:33:45 <ihope> I never really got how operator precedence worked.
18:33:47 <jethr0> ah, f*ck it. today i'm only talking non-sense. i'll shut up for a while... sry
18:34:21 <hulahub> is a result of a function call cached? so that map (head &&& length) $ group $ sort s won't be calculated everytime it is called?
18:35:00 <triplah> lol
18:35:24 <triplah> ihope: depends how its define in the language definition i suppose
18:35:49 <triplah> in BNF precedence is defined by distant from the core <expr>
18:35:54 <triplah> distance*
18:36:12 <triplah> and associativity is where the recursive <expr> lies
18:36:23 <int-e> hulahub: there's no caching like this
18:36:53 <hulahub> so isn't map a very expensive call ?
18:37:08 <triplah> haskell is typically an expensive language
18:37:18 <Lemmih> eh?
18:37:30 <triplah> compared to C for example 
18:37:36 <int-e> hulahub: I'd think map gets inlined if you compile the code.
18:37:41 <triplah> garbage collection etc
18:37:42 <hulahub> triplah: you are in the wrong channel for this... psst
18:37:48 <triplah> hulahub: hehe :)
18:38:25 <Lemmih> hulahub: Thunks will only be evaluated once.
18:39:35 <int-e> hulahub: heh, there are even some fancy optimization rules for map
18:39:54 <hulahub> map is a btree --- or ?
18:41:10 <int-e> hulahub: anyway, what Lemmih said - if it's clear that you're re-using the same value (i.e. it can be found out syntactically with common subexpression elimination) then you can expect that it's only evaluated once. you can make that kind of sharing explicit with let. (let value = complex_caluculation in term using vale)
18:41:34 <int-e> no
18:41:36 <int-e> @type map
18:41:37 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:41:52 <int-e> it just applies a function to each element of the list
18:41:57 <hulahub> hmmm i read something like that
18:42:03 <int-e> not in haskell :)
18:42:06 <palomer> anyone here into opengl?
18:42:10 <int-e> hmm.
18:42:26 <Lemmih> palomer: Somewhat.
18:42:39 <int-e> there's Data.Map ... that's different.
18:43:08 <palomer> Lemmih: how do I draw a pyramidal section of a sphere?
18:43:17 <palomer> like, a pyramid with a curved base
18:44:25 <int-e> hulahub: the most expensive part of that line is the sort
18:44:31 <Lemmih> palomer: I have no idea (:
18:44:37 <hulahub> okee
18:44:48 <int-e> > map (+1) [1,2,3]
18:44:49 <lambdabot> [2,3,4]
18:44:59 <int-e> > map odd [1,2,3]
18:45:00 <lambdabot> [True,False,True]
18:45:12 <jethr0> is there a standard operator for forward concatenation outside monads?
18:45:38 <ihope> ?
18:48:35 <jethr0> ihope: well ($) and (.) concatenate kinda backwards.
18:48:52 <ihope> You mean they're right-associative?
18:48:54 <jethr0> is there a standard (flip ($)) or (flip (.))
18:48:58 <hulahub> int-e: does map work with list's of tupels as well ?
18:49:05 <ihope> Oh right.
18:49:22 <int-e> hulahub: yep, it works with all lists.
18:49:35 <int-e> > map (\(a,b) -> a+b) [(1,2), (3,-4)]
18:49:37 <lambdabot> [3,-1]
18:49:59 <hulahub> ah lambdas
18:51:23 <jethr0> @type unzip
18:51:24 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
18:51:41 <jethr0> @type zip
18:51:43 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
18:56:06 <hulahub> wow
18:56:10 <hulahub> map is just BOOM
18:56:30 <ihope> How about fmap?
18:56:39 <ihope> > fmap (+1) (Just 3)
18:56:40 <lambdabot> Just 4
18:56:55 <ihope> > fmap (+1) [3]
18:56:56 <lambdabot> [4]
18:57:00 <ihope> :-)
18:57:05 <hulahub> @type fmap
18:57:06 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:57:53 <ihope> > fmap (+1) (return 3 :: IO Integer)
18:57:54 <lambdabot> No IO allowed
18:57:59 <ihope> Heh
18:58:38 <jethr0> _bad_ ihope. trying to exploit lambdabot with an evil "3"
18:58:43 <jethr0> *tststs*
18:59:41 <hulahub> int-e: bw :: String -> [(Char, Float)]
18:59:41 <hulahub> bw s = map (\(c,n) -> (c,((fromIntegral n)/(fromIntegral (length s))))) $ map (head &&& length) $ group $ sort s
18:59:50 <hulahub> all functions in one line :D
18:59:52 <hulahub> cool :D
18:59:54 <hulahub> just cool
19:00:24 <jethr0> hulahub: hmm, but instant readability is not enhanced. at least not for newbies like me ;-(
19:00:30 <int-e> hulahub: next, use map (uncurry Leaf) on the result ;-)
19:00:45 <jethr0> i'd consider at least using "where" and "let" instead of lambdas
19:01:24 <hulahub> jethr0: don't know how to use let and where yet  - untill now it worked without
19:01:47 <int-e> hulahub: e.g. map (uncurry Leaf) (bw text)
19:01:59 <jethr0> bw s = map pairDiv $ map (head &&& length) $ group $ sort s
19:02:16 <jethr0> where pairDiv = (\(c,n) -> (c,((fromIntegral n)/(fromIntegral (length s)))))
19:02:28 <Lemmih> You don't need two map's.
19:02:32 <jethr0> where pairDiv (c,n) = c,((fromIntegral n)/(fromIntegral (length s)))
19:02:37 <palomer> seriously, application should be right associative
19:02:39 <jethr0> where pairDiv (c,n) = (c,((fromIntegral n)/(fromIntegral (length s))))
19:02:48 <int-e> jethr0: I'd prefer   where pairDiv (c,n) = ...   then
19:03:00 * int-e is too slow
19:03:04 <SamB> > unsafePerformIO
19:03:05 <lambdabot>  Not in scope: `unsafePerformIO'
19:03:16 * jethr0 is too dumb today to get anything right on the first try ;-(
19:03:16 <SamB> > forkIO
19:03:17 <lambdabot>  Not in scope: `forkIO'
19:03:53 <hulahub> Lemmih: why not ?
19:04:00 <jethr0> samb: how is IO forbidden in lambdabot. is the IO monad reimplemented?
19:04:10 <SamB> jethr0: no!
19:04:25 <int-e> hulahub: (map f . map g) = map (f . g)
19:04:30 <SamB> it just filters out things with IO types, I think
19:05:01 <ihope> > error "Hello, world!" :: IO ()
19:05:02 <lambdabot> No IO allowed
19:05:02 <jethr0> wouldn't it be possible to implement IO monad as doing nothing?
19:05:06 <int-e> @type id . id Control.Arrow.&&& id
19:05:07 <lambdabot> forall b. b -> (b, b)
19:05:15 <jethr0> a >>= b = error "IO forbidden"
19:05:19 <SamB> jethr0: not really
19:05:31 <SamB> then GHCi wouldn't work and neither would main...
19:05:44 <hulahub> int-e: aaahh . connects statements
19:06:13 <jethr0> samb: that's _exactly_ the same problem as with libc. i don't seem to react all that well to "conditioning" ;-)
19:06:40 <SamB> jethr0: only your libc implementation is supposed to do something
19:06:45 <jethr0> hehe
19:06:49 <int-e> hulahub: functions.    f . g = \x -> f (g x)
19:07:02 <jethr0> stlib and string are finished (for usage with gcc). unistd is mostly done
19:07:10 <jethr0> but the HUGE stdio is still missing
19:07:34 <SamB> got printf done yet?
19:07:36 <jethr0> PLUS i am using system.posix, system.io, etc which are all not implemented yet in house
19:07:38 <jethr0> yup
19:07:45 <jethr0> no, that's in stdio
19:08:02 <jethr0> printf is not implementable in haskell, i think
19:08:09 <jethr0> due to variable number of args!
19:08:23 <SamB> dons: can you implement printf in Haskell?
19:08:34 <jethr0> you can't even express its signature
19:08:48 <Lemmih> @type Text.Printf.printf
19:08:49 <lambdabot> forall r. (Text.Printf.PrintfType r) => String -> r
19:09:00 <SamB> Lemmih: you can't foreign export that ;-)
19:09:31 <jethr0> lemmih: isn't that missing one argument?
19:09:42 <ihope> Variable number of arguments... like a list? >:-)
19:09:45 <Lemmih> jethr0: Nope.
19:09:58 <jethr0> so, how is it called?
19:10:45 <Lemmih> Prelude Text.Printf> printf "Hello %s" "world\n"
19:10:45 <Lemmih> Hello world
19:10:56 <SamB> Prelude Text.Printf> printf "%s%s" "%s" "%s"
19:11:01 <SamB> %s%sPrelude Text.Printf> 
19:11:09 <SamB> Prelude Text.Printf> printf "%s%s" "%s" "%s" "%s"
19:11:09 <SamB> %s%s*** Exception: Printf.printf: formatting string ended prematurely
19:11:09 <hulahub> uncurry is magic? :D
19:11:16 <SamB> nope
19:11:17 <jethr0> hehe
19:11:22 <SamB> not magic
19:11:22 <hulahub> @type uncurry
19:11:23 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
19:11:31 <int-e> hulahub: uncurry f = \(x,y) -> f x y
19:11:43 <jethr0> samb: how can it handle variable number of args?
19:11:55 <jethr0> is that a haskell-external work-around?
19:12:04 <SamB> jethr0: how does quickcheck supply a variable number of args?
19:12:08 <Lemmih> @libsrc Text.Printf
19:12:08 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Text/Printf.hs
19:12:28 <SamB> Prelude Text.Printf> :i PrintfType
19:12:28 <SamB> class PrintfType t where
19:12:28 <SamB>   spr :: String -> [Text.Printf.UPrintf] -> t
19:12:28 <SamB>         -- Imported from Text.Printf
19:12:28 <SamB> instance IsChar c => PrintfType [c]     -- Imported from Text.Printf
19:12:29 <SamB> instance PrintfType (IO a)      -- Imported from Text.Printf
19:12:32 <jethr0> i'm baffled. i thought this wasn't possible (hence zip2, zip3, ...)
19:13:15 <SamB> zip2, zip3, ... can't be done as one
19:13:30 <SamB> though perhaps we would be better off with a zip like you propose!
19:13:37 <SamB> let me see if I can figure out how to do it...
19:13:43 <hulahub> connection functions with a . ... is left or right side executed first?
19:14:26 <Lemmih> hulahub: f . g = \x -> f (g x)
19:14:43 <hulahub> ok... right side :D
19:15:04 <hulahub> thats SOOO CRAZY
19:15:06 <hulahub> bw :: String -> [HTree]
19:15:06 <hulahub> bw s = map ((uncurry Leaf) . (\(c,n) -> (c,((fromIntegral n)/(fromIntegral $ length s)))) . (head &&& length)) $ group $ sort s
19:15:12 <hulahub> reduced 30 lines to 1 :D
19:15:50 <int-e> hulahub: note that instead of using uncurry Leaf you could just construct the Leaf directly, instead of a pair
19:15:59 <Lemmih> You can make the line even shorter.
19:16:04 <int-e> \(c,n) -> Leaf c (...)
19:16:12 <jethr0> hulahub: try taking out the lambda and putting it into an indented "where pairDiv (c,n) = "
19:16:28 <int-e> and then ... yep
19:17:17 <int-e> map (\l -> Leaf (head l) (fromIntegral (length l) / fromIntegral (length s))) $ group $ sort s
19:17:18 <Lemmih> map (head &&& (\n -> fromIntegral (length n) / fromIntegral (length s)))
19:17:18 <jethr0> encouraging rampant usage of "where" and "let" is one of the finest features of haskell; for me at least!
19:17:43 <jethr0> that might even be short enough to still be a one-lines *g*
19:17:54 <jethr0> liner*
19:19:45 <hulahub> int-e: aahhh that takes the magic from uncurry :P
19:20:01 <hulahub> uncurry reminds me on ketchup
19:22:30 <jethr0> lemmih: is there a reverse for &&&?   (||| (+)) (1,2,3) => 6   or something like that?
19:22:57 <jethr0> not exactly reverse, i know
19:23:24 <Cale> sorry, triples?
19:23:26 <int-e> @type (Control.Arrow.|||)
19:23:27 <lambdabot> forall (a :: * -> * -> *) d c b.
19:23:27 <lambdabot> (Control.Arrow.ArrowChoice a) =>
19:23:27 <lambdabot> a b d -> a c d -> a (Either b c) d
19:23:49 <jethr0> hmm, i had hoped &&& would work on any tuples ;-(
19:23:59 <hulahub> im really impressed
19:24:03 <Cale> tuples are all considered quite different
19:24:27 <jethr0> cale: i know. but sometimes the staticness of tuples bothers me.
19:24:41 <jethr0> getting stuff into a tuple seems infinitely easiert than getting it out again
19:24:51 <jethr0> generically speaking
19:24:57 <Cale> well, you generally get it out with pattern matchin
19:24:58 <Cale> g*
19:25:50 * SamB is still trying to do a zip typeclass
19:26:07 <jethr0> samb: why the hell did i think variable arguments wasn't possible in haskell?
19:26:18 <jethr0> i still haven't understood how they did it in printf...
19:26:22 <Cale> It seems impossible at first :)
19:26:40 <jethr0> the typing of such a thing is unclear to me.
19:26:42 <hulahub> int-e: you are a good teacher :D never had so much fun learning something :P
19:26:50 <SamB> Cale: how do I do this without resorting to units in the last pair?
19:27:03 <int-e> hulahub: heh thanks
19:27:04 <Cale> Look closely at how Printf is done and it'll make sense. The idea is that you generalise the return type so that it's either a result, or a function taking another parameter
19:27:18 <Cale> SamB: hm?
19:27:27 <Cale> I just showed up
19:27:46 <jethr0> ah, like "Branch (Tree a) (Tree a)", huh?
19:27:53 <SamB> Cale: I'm trying to write a ZipType typeclass in that same spirit
19:28:13 <SamB> function taking another parameter....
19:28:26 <SamB> okay, [()] it is...
19:28:47 <jethr0> note to self: mixing (>>=) and ($) / (.) can get you _extremely_ confused as to associativity...
19:29:02 <int-e> it's actually turning the C printf around - the C printf is format driven, while that Haskell printf is type driven.
19:29:04 <int-e> I like it.
19:29:26 <Cale> like class PrintfType t, which has as instances  PrintfType (IO a), PrintfType String, and (PrintfArg a, PrintfType r) => PrintfType (a -> r)
19:29:34 <jethr0> considering that printf is most likely one of Cs least type safe operations, that quite the irony *g*
19:29:36 <hulahub> perhaps i can conquer the whole world by maping and uncurring it? *g
19:29:48 <jethr0> if there exists anything like "least type safe" in C
19:30:17 <Cale> this printf still kind of has the problems that the C one did
19:30:34 <Cale> though at least you can't pass complete nonsense
19:30:53 <Cale> it doesn't statically check the format string though, it can't
19:31:05 <SamB> Cale: but no segfaults!
19:31:06 <jethr0> printf("double: %f, str: %s, int: %d\n", myDouble, myInt);   will most likely get you to segfault land straight away
19:31:15 <int-e> it's safe - it knows exactly what it's printing. :)
19:31:16 <jethr0> and no compiler to tell you about it
19:31:39 <hulahub> is it better to define a function for a map or should i use a map directly ?
19:32:03 <int-e> hulahub: it depends on the context
19:32:06 <jethr0> everything is fine applying directly... until it gets too long or too convoluted!
19:32:25 <int-e> hulahub: if your function is also useful when not used with map, make it a separate function
19:32:26 <hulahub> if i just use it as a helper function - which is used inside an other function
19:32:37 <SamB> hmm, it complains about:
19:32:40 <SamB> Zip.hs:16:24: Malformed context in instance header
19:32:44 <SamB> instance ZipType [b] => ZipType [a] -> [(a,b)] where
19:32:45 <SamB>     zipN xs = zip xs . zipN
19:32:55 <Cale> Prelude Text.Printf> printf "double: %f, str: %s, int: %d\n" (0.23 :: Double) (5 :: Int) :: String
19:32:55 <Cale> "double: 0.23, str: *** Exception: Printf.printf: bad argument
19:33:13 <Cale> it's nice enough to throw an exception at least :)
19:34:41 <jethr0> he found out astonishingly late that the type didn't match. so it's _extremely_ runtime driven as well
19:34:44 <Cale> and "take 12" of that is just fine of course :)
19:35:00 <Cale> it's lazy
19:35:32 <jethr0> > map chr [116,104,97,116,39,115,32,97,32,110,105,99,101,32,119,111,114,107,45,97,114,111,117,110,100]
19:35:33 <lambdabot> "that's a nice work-around"
19:35:50 <SamB> Cale: any ideas?
19:36:10 <Cale> SamB: can you paste the code so I can have a look?
19:36:26 <Cale>  ZipType ([a] -> [(a,b)]) ?
19:36:36 <SamB> sure
19:36:45 <Cale> (try those parens)
19:37:02 <SamB> oh, right
19:37:11 <SamB> why didn't it SAY it was a syntax error?
19:37:29 <dons> jeffno, those lambdabot errors are actually a bug in ghc 6.4. edit config.mk and remove "-Werror"
19:37:37 <SamB> great, now I get a type error ;-)
19:37:55 <SamB> however, I must start over, since I had a bunch of -fallow flags
19:38:14 <SamB> okay, now it says I need undecidable instances
19:38:48 * int-e thinks its funny how far Haskell's type system can be stretched.
19:39:24 <Cale> With all the extensions it's almost possible to do dependently typed sorts of things
19:40:07 <jethr0> can anyone tell me why ($) doesn't work with partial application as (.) does?
19:40:29 <Cale> what?
19:40:32 <jethr0> > let func = (*2) $ (+1) in func 2
19:40:32 <int-e> I once coded an   instance Num a => Num [a] where   to implement polynomials.
19:40:33 <lambdabot>  add an instance declaration for (Num (a -> a))
19:40:40 <jethr0> > let func = (*2) $ (+1) in func 2::Integer
19:40:41 <lambdabot>  add an instance declaration for (Num (Integer -> Integer))
19:40:50 <jethr0> > let func = ((*2) $ (+1)) in func 2::Integer
19:40:51 <Cale> um, ($) and (.) aren't at all the same thing
19:40:51 <lambdabot>  add an instance declaration for (Num (Integer -> Integer))
19:40:55 <int-e> @type ($)
19:40:56 <lambdabot> forall b a. (a -> b) -> a -> b
19:40:57 <int-e> @type (.)
19:40:58 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
19:41:15 <Cale> (*2) $ (+1) means the function (*2) applied to the function (+1) which is a type error
19:41:36 <Cale> > (*2) $ 5
19:41:37 <lambdabot> 10
19:41:38 <jethr0> sure!!! as always today, i wasn't thinking it through
19:41:55 <hulahub> o a b = compare (tf a) (tf b)
19:42:05 <jethr0> it's understandable though, because their applications can look similar
19:42:14 <hulahub> \(a,b) -> compare (tf a) (tf b)
19:42:16 <Cale> comparing p a b = compare (p a) (p b)
19:42:19 <jethr0> > even $ (*2) $ (-1) $ 5
19:42:19 <lambdabot>  add an instance declaration for (Num (a -> b))
19:42:44 <Cale> (subtract 1)
19:42:46 <jethr0> *ARG*
19:42:59 <jethr0> > even $ (*2) $ (-1) 5
19:43:00 <lambdabot>  add an instance declaration for (Num (t -> a))
19:43:04 <Cale> > even $ (*2) $ (subtract 1) $ 5
19:43:05 <int-e> @pl comparing p a b = compare (p a) (p b)
19:43:05 <lambdabot> True
19:43:05 <lambdabot> comparing = flip =<< (((.) . compare) .)
19:43:12 <jethr0> vs
19:43:23 <hulahub> i can't use \a,b -> ... and \(a,b) is wrong type - so what to do ?
19:43:25 <jethr0> > even . (*2) . (subtract 1) $ 5
19:43:27 <lambdabot> True
19:43:33 <int-e> hulahub: \a b
19:43:43 <hulahub> without comma ?
19:43:47 <SamB> Cale: it still doesn't seem to work
19:43:47 <int-e> hulahub: right
19:43:52 * jethr0 considers it a bug that (-1) is not a function *g*
19:43:53 <hulahub> hmm thats funny
19:43:53 <int-e> hulahub: or, \a -> \b ->
19:44:23 <jethr0> hulahub: it's just another notation for:  "anonymousFunction a b ="
19:44:26 <lisppaste2> SamB pasted "Brokent Zipper" at http://paste.lisp.org/display/14274
19:44:36 <hulahub> ok
19:44:55 <SamB> jethr0: the trouble with -1 is enough to make you want a special char for negative numbers like the TI-83+ has
19:45:15 <Cale> keyboards need more keys
19:45:17 <Cale> hehe
19:45:26 <Cale> especially symbol characters
19:45:45 <Cale> A separate hyphen and minus character would be handy there
19:45:55 <jethr0> samb: your zipper does some BAD*SS typedriving programming ;-)
19:46:10 <SamB> jethr0: but it does not work!
19:46:11 <jethr0> cale: but not if they looked anything like each other
19:46:13 <hulahub> and again 2 lines less *g
19:46:27 <Cale> jethr0: hyphens are shorter than minus signs
19:46:30 <SamB> the trouble is that GHC accepts the program but then denies to have more than one instance for ZipType
19:46:52 <jethr0> depends. in type setting hyphens (or however they are called there) are _much_ longer!
19:47:10 <SamB> jethr0: those are dashes
19:47:47 <jethr0> well, i'm not a native speaker; thus slight misnomers might be forgiven
19:48:13 <SamB> jethr0: I assume you also aren't a typesetter?
19:48:21 <jethr0> this also goes for braces, brackets, parentheses, ...
19:48:23 * SamB thinks most of those are computer programs these days
19:48:43 <jethr0> no, but i've more than my share of experience with LaTex
19:49:05 <jethr0> i've had*
19:49:28 <Cale> SamB: needs functional dependencies almost for sure
19:49:33 <Cale> let me try something
19:49:48 <jethr0> actually... http://www.answers.com/topic/hyphen
19:51:18 <jethr0> oh, i forgot chevrons (the angular, pointy ones)
19:51:32 <hulahub> i go to bed
19:51:41 <hulahub> bye!
19:52:40 <int-e> bye hulahub 
19:52:48 <int-e> bye #haskell 
19:52:50 <jethr0> bye
19:52:55 <SamB> bye int-e
19:53:54 <Cale> as you can see lower down on that page, the Unicode explicit hyphen is a bit shorter than the hyphen-minus, and the proper minus sign is a bit longer
19:55:13 <SamB> Cale: you were trying?
19:55:43 <jethr0> cale: ;-)
19:55:47 <Cale> yeah, going to have to think about this. I think it should be something like  class ZipType t r | r -> t where zipN :: t -> r
19:56:04 <Cale> hmm, r -> t ?
19:56:08 <Cale> maybe not
19:56:16 <Cale> certainly not
19:56:26 <Cale> maybe multiparameter but not fundeps :)
19:56:41 <Cale> t -> r seems incorrect as well
19:56:49 <Cale> (as a fundep)
19:58:00 <Cale> er, hmm... we actually want control over the final result, not the intermediate one
19:58:12 <triplah> if i wanted to make a pair of parralel tables, could i do something like dblTable i j = (table1 !! i !! j,table2 !! i !! j)
19:58:38 <Cale> triplah: sure
19:58:47 <triplah> so then i can have meta information about one table in the corresponding indexs in the other table
19:59:03 <triplah> ah
19:59:10 <Cale> class ZipType t r where
19:59:10 <Cale>     zipN :: t
19:59:13 <Cale> :)
19:59:15 <triplah> i think this is a cheaty way of doing my problem from yesterday
20:00:05 <SamB> what does r do?
20:00:18 <Cale> holds onto the final result type
20:00:30 <jethr0> triplah: parallel tables?
20:00:45 <jethr0> triplah: indices are tuples
20:00:50 <SamB> final result type?
20:00:52 <jethr0> @type (!!)
20:00:53 <lambdabot> forall a. [a] -> Int -> a
20:01:00 <Cale> t is some function type
20:01:06 <jethr0> hmm, might even work
20:01:19 <Cale> but we need to know what the result of fully applying that function is
20:01:36 <Cale> in order to be able to add another parameter
20:01:47 <jethr0> > let table = [[1,2,3],[4,5,6]] in table !! 1 !! 2
20:01:48 <lambdabot> 6
20:01:58 <jethr0> > let table = [[1,2,3],[4,5,6]] in table !! 0 !! 1
20:01:59 <lambdabot> 2
20:02:11 <jethr0> triplah: nice one...
20:02:51 <jethr0> triplah: which problem from yesterday are you referring to?
20:05:07 <SamB> Cale: and how am I supposed to use it?
20:05:30 <Cale> hmm
20:05:38 <Cale> yeah, this is a little questionable :)
20:05:54 <Cale> hmm
20:05:54 <SamB> I think your other idea was better...
20:06:31 <Pupeno> Why does the haskell mode indent 'then' and 'else' at the same level of 'if', it doesn't work.
20:06:59 <Pupeno> On emacs.
20:07:07 <Cale> I'm not sure, it shouldn't do that
20:07:14 <Cale> try hitting tab again
20:07:15 <SamB> it does a lot of things it shouldn't...
20:07:43 * Pupeno agrees with SamB
20:08:05 <Pupeno> Cale: hitting tab again sais "Sole indentation".
20:08:25 <Cale> Pupeno: use simple haskell indent mode, it's better
20:08:40 <Pupeno> let's see.
20:08:45 <Cale> the smart mode is too smart for its own good
20:08:50 <SamB> Cale: back to type gymnastics! 
20:08:51 <jethr0> he
20:08:52 <jethr0> he
20:09:29 <bojohan> haskell syntax is too complicated for its own good
20:10:45 <Pupeno> the simple mode doesn't do indentation.
20:10:52 <Pupeno> right ?
20:10:56 <jethr0> is there a standard function for:   sndApp (x,y) func = (x, func y)   ?
20:11:27 <Cale> bojohan: it's not even all that complicated
20:11:41 <lisppaste2> triplah annotated #14264 with "where getting in the way?" at http://paste.lisp.org/display/14264#1
20:11:44 <Cale> bojohan: but hIDE should solve these problems nicely
20:12:08 <triplah> i think the second where is not letting the function parse properly
20:12:28 <bojohan> it is
20:12:32 <bojohan> i'm approaching from the lisp direction
20:12:44 <triplah> is there a way around this problem?
20:13:49 <bojohan> alEntry doesn't line up with simEntry
20:13:57 <SamB> Cale: help!
20:13:59 <triplah> argh
20:14:00 <triplah> thanks
20:14:01 <triplah> :)(
20:14:37 <triplah> argh
20:14:40 <triplah> more type errors :(
20:15:22 <Cale> *Zip> zipN ([1,2,3,4],([5,6,7,8], ()))
20:15:22 <Cale> [(1,(5,())),(2,(6,())),(3,(7,())),(4,(8,()))]
20:15:52 <Cale> *Zip> zipN ([1,2,3,4],([5,6,7,8], ([9,10,11,12], ())))
20:15:52 <Cale> [(1,(5,(9,()))),(2,(6,(10,()))),(3,(7,(11,()))),(4,(8,(12,())))]
20:15:55 <triplah> alsim i j = ((simTab !! i !! j),(alTab !! i !! j))
20:15:55 <SamB> Cale: what does your base case look like?
20:15:56 <Cale> getting closer
20:16:04 <Cale> instance ZipType () () where
20:16:04 <Cale>     zipN () = repeat () 
20:16:07 <Cale> class ZipType t r | t -> r where
20:16:07 <Cale>     zipN :: t -> [r]
20:17:32 <Cale> the recursive case, if you hadn't guessed, is:
20:17:33 <Cale> instance (ZipType t r) => ZipType ([a], t) (a,r) where
20:17:33 <Cale>     zipN (xs, u) = zip xs (zipN u)
20:18:29 <Cale> *Zip> zipN ([1,2,3,4],([5,6,7,8], [9,10,11,12]))
20:18:30 <Cale> [(1,(5,9)),(2,(6,10)),(3,(7,11)),(4,(8,12))]
20:18:33 <Cale> this is better
20:18:37 <Cale> instance ZipType [a] a where
20:18:37 <Cale>     zipN xs = xs
20:20:25 <Cale> next trick is generating a curried version
20:21:30 <jethr0> > let table = [[1,2,3],[4,5,6]] in table !! 0 !! 1
20:21:31 <lambdabot> 2
20:21:49 <triplah> argh
20:21:55 <triplah> i'm not gonna get this done :)
20:22:06 <jethr0> triplah: is it still your assignment?
20:22:14 <jethr0> maybe i can help after all?
20:22:20 <lisppaste2> triplah annotated #14264 with "go tables!" at http://paste.lisp.org/display/14264#2
20:22:36 <jethr0> you got the assignment url once again?
20:22:38 <jethr0> once more?
20:22:44 <triplah> im making two tables
20:22:50 <jethr0> hmm
20:22:59 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
20:23:03 <triplah> task 9
20:23:06 * jethr0 slips into his psychiatrist role
20:23:11 <triplah> i've decided to cheat a bit
20:23:17 <triplah> and make parralel tables
20:23:36 <jethr0> you mean emulated higher dimensional arrays instead of "array (i,j)"?
20:23:39 <triplah> so one table holds cost information at the same indexs as the appropriate alignment information
20:23:48 <triplah> well no,
20:23:50 <triplah> this is like
20:23:54 <jethr0> ahh, parallel tables, i get it!
20:23:59 <triplah> cool :)
20:24:01 <SamB> instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where
20:24:02 <SamB>     spr fmt args = \ a -> spr fmt (toUPrintf a : args)
20:24:17 * SamB wonders if this is useful
20:24:27 * SamB suspects the lambda may be key
20:24:43 <SamB> well, maybe not
20:25:34 <jethr0> triplah: so why doesn't "map (costFunc &&& alignFunc) work?
20:25:43 <jethr0> " work*
20:26:02 <triplah> what does &&& do?
20:26:33 <triplah> and how can i apply map to two lists?
20:26:35 <jethr0> it combines two function result on a value into a tuple
20:26:45 <jethr0> tell me what you have to start with.
20:26:45 <triplah> oh really?
20:27:03 <triplah> well
20:27:05 <triplah> hmm
20:27:09 <jethr0> > map (even &&& (*2)) [1,2,3]
20:27:10 <triplah> lemme pastebin my code so far
20:27:10 <lambdabot> [(False,2),(True,4),(False,6)]
20:27:20 <triplah> ahh
20:27:38 <jethr0> triplah: my guess is that it's too much code to digest quickly
20:27:42 <triplah> but i dont have anything to map them over
20:27:52 <triplah> i'm generating the tables lazily
20:27:54 <jethr0> and most likely your problem can  be reduced to something i can grasp at 5:30 in the morning...
20:28:00 <triplah> hehe yeah
20:28:14 <SamB> triplah: lazily coming up!
20:28:16 <jethr0> so, what types are the two tables you have and what's in them?
20:28:21 <SamB> > map (even &&& (*2)) [1..]
20:28:22 <lambdabot> [(False,2),(True,4),(False,6),(True,8),(False,10),(True,12),(False,14),(
20:28:22 <lambdabot> True,16),(False,18),(True,20),(False,22),(True,24),(False,26),(True,28),(
20:28:22 <lambdabot> False,30),(True,32),(False,34),(True,36),(False,38),(True,40),(False,42),(
20:28:22 <lambdabot> True,44),(False,46),(True,48),(False,50),(True,52),(False,54),(True,56),(
20:28:22 <lambdabot> False,58),(True,60),(False,62),(True,64),(False,66),(True,68),(False,70),(
20:28:24 <lambdabot> [25 @more lines]
20:28:38 <SamB> ugh! that is repugnant!
20:28:46 <jethr0> samb: what is?
20:28:57 <jethr0> order in, garbage out?
20:29:06 <triplah> one table is [([Char],[Char])]  <-- alignments , and the other is Int
20:29:27 <jethr0> ok, so why not use zip
20:29:29 <triplah> Int being the associated cost
20:29:54 <triplah> i need to generate alignments AND give them an associated cost at the same time
20:30:16 <triplah> so generate the tables in sequence
20:30:16 <jethr0> yes i see.
20:30:34 <jethr0> although lazyness kinda does that for you already, doesn't it?
20:30:56 <triplah> well yes
20:31:00 <jethr0> what kind of input is given to the function producting the alignments?
20:31:07 <jethr0> producing?
20:31:09 <jethr0> *
20:31:30 <triplah> optimalAlignment cost1 cost2 cost3 string1 string2
20:31:55 <triplah> the costs being the costs associated with a mismatch in letters, a match in latters, and a space
20:32:01 <triplah> letters*
20:33:04 <jethr0> ok, so at the moment you are calculating the costs AFTER having calculated your alignments?
20:33:30 <triplah> yeah, i gen alignments... then run a filter over them to get the ones with the smallest scores
20:33:33 <jethr0> try pasting your code. maybe it's little enough to grasp quickly
20:33:52 <triplah> i'll paste the relevant bits
20:34:29 <Pupeno> Can I have an if without using the layout ? (like case) is so, what is its syntax ?
20:34:51 <jethr0> pupeno: what layout?
20:35:11 <Pupeno> jethr0: layount... err. indentation to define blocks.
20:35:17 <jethr0> case x of
20:35:24 <jethr0>   4 -> Nothing
20:35:28 <jethr0>   5 -> Just 5
20:36:00 <jethr0> that help?
20:36:03 <lisppaste2> triplah annotated #14264 with "relevant code so far" at http://paste.lisp.org/display/14264#3
20:36:24 <araujo> Pupeno, I think you can't (hi!)
20:36:25 <Pupeno> jethr0: mh ? that's using indetation, I want to not use it, like case x of { 4 -> Nothing; 5 -> Just 5 } but on the if.
20:36:38 <araujo> > if null [] then True else False
20:36:39 <lambdabot> True
20:36:41 <jethr0> triplah: state your problem once more... you want to splice cost calculation into alignment calculation?
20:36:55 <jethr0> "on the if"?
20:36:58 <araujo> Pupeno, you always got the option of writting in the very same line.
20:37:10 * Cale needs type-level foldr
20:37:17 <triplah> jethr0: i want make a function that makes a table of (cost,alignment) pairs
20:37:18 <triplah> OR
20:37:22 <triplah> make a table of costs
20:37:27 <triplah> with a matching table of alignments
20:37:32 <Pupeno> araujo: (hi), I see :(
20:37:37 <triplah> at the moment the pair of tables is my best bet i think
20:38:03 <jethr0> triplah: i don't see why you can't use zip, or a simple map for that matter
20:38:07 <araujo> Pupeno, learning haskell? ..... we just have #haskell.es
20:38:11 <jethr0> if it is only a matter of combining two lists...
20:38:16 <Pupeno> araujo: yes.
20:38:34 <olliej> can anyone think of an example of a function that would need a type argument that was both higher kinded and higher order
20:38:40 <olliej> ?
20:39:10 <jethr0> olliej: ask cale and samb. they are in that kind of sphere, right now
20:39:20 <jethr0> sphere?
20:39:32 <triplah> jethr0: did you see the annotation? i want to combine the function similarity' with optAlignment' i dont see how its possible with a map :\
20:39:35 <olliej> jethr0: cheers
20:40:18 <jethr0> triplah: so you have two parallel lists and just want to combine them?
20:40:34 <triplah> two parralel lists of lists
20:40:47 <jethr0> > zip [1,2,3,4] [('a','b'), ('c','d')]
20:40:48 <lambdabot> [(1,('a','b')),(2,('c','d'))]
20:41:03 <triplah> hmm
20:41:07 <triplah> so i coul
20:41:10 <triplah> could*
20:41:16 <jethr0> could you abstract the problem to something that can be done in here?
20:41:20 <Cale> olliej: sorry, higher-order?
20:41:43 <olliej> Cale: possibly higher rank
20:42:11 <olliej> Cale: just trying to remember sytnax
20:42:21 <Cale> hmm
20:42:42 <olliej> ah
20:43:01 <jethr0> triplah: "so i could" ...
20:43:14 <SamB> shapr: you have to admit that Flash is an improvement over <BLINK>. it isn't always annoying!
20:43:17 <triplah> zip (optAlignment' 0 1 2 "xx" "yy") (similarity' 0 1 2 "xx" "yy")
20:43:18 <olliej> say a function foo :: (forall a b. a->b->Int)->... 
20:43:32 <triplah> it doesnt work
20:43:35 <triplah> but something to that effect
20:43:49 <olliej> Cale: where there was a type arg with a kind *->*
20:44:00 <jethr0> no, i mean abstract it to something involving simple lists with bogus data.
20:44:15 <olliej> Cale: I'm trying to workout if there was ever a case where you might encounter it
20:44:29 <jethr0> like costs = [1,2,3,4], align = [("ac", "de"), ("ef", "df")]
20:44:42 <Cale> foo :: (forall f. (a -> b) -> f a -> f b) -> (a -> b) -> [a] -> [b] ?
20:44:42 <SamB> @kind Monad
20:44:43 <lambdabot> Class `Monad' used as a type
20:44:48 <jethr0> well, with equal number of elements, obviously
20:44:50 * SamB doesn't care!
20:44:54 <Cale> there's a case
20:44:55 <triplah> jethr0: ok, lemme see here
20:44:55 <triplah> :)
20:44:56 * SamB just wanted to know its kind
20:45:14 <olliej> Cale: oh.. maybe a dictionary contructor for monad would do it
20:45:26 * jethr0 would kindly ask mr samb to treat the l-bot a little nicer!
20:45:32 <Cale> olliej: or even Functor
20:46:05 <olliej> Cale: nuts, now to work out how to get them both going at the same time... *sigh*
20:46:16 <olliej> Cale: cheers :)
20:47:14 <olliej> @kind MkMonad
20:47:15 <lambdabot> Not in scope: type constructor or class `MkMonad'
20:47:27 <triplah> jethr0: *Main> optAlignment' 0 1 2 "xzx" "yzys"
20:47:27 <triplah> [("xz-x","yzys"),("xzx-","yzys")]
20:47:32 <jethr0> ok
20:47:32 <Pupeno> Do you get emacs+haskell-mode to indent like this as well: http://pupeno.com/miscellaneous/temporary/emacshaskell.png/view ?
20:47:45 <triplah> but thats filtering out the ones that arent optimal
20:47:50 <Cale> olliej: working on a Haskell compiler?
20:47:58 <olliej> Cale: yeah
20:48:04 <jethr0> triplah: it doesn't have to be an example with _real_ data.
20:48:04 <olliej> Cale: targetting .NET
20:48:08 <olliej> Cale: oh the fun
20:48:08 <Cale> ah
20:48:20 <jethr0> just something to tell me what you want to do...
20:48:27 <olliej> Cale: supports most things.. though it is still exceedinly alpha
20:48:44 <olliej> Cale: uses Core output from ghc
20:48:55 <triplah> jethr0: ok, here is the abstraction, similarity finds all possible scores given two strings to align, and returns the smallest one
20:49:00 <Cale> olliej: I was going to ask if it's a backend for GHC
20:49:04 <jethr0> yes
20:49:08 <triplah> so its trivial to change what it does to a list of scores
20:49:43 <olliej> Cale: basically trying to come up with ways to deal with features that functional languages use on an OO virtual machine
20:49:43 <triplah> optAlignment does the same thing, except it returns the optimal alignment, or list of optimal alignments
20:50:05 <jethr0> ok
20:50:08 <olliej> Cale: supports most of haskell now
20:50:39 <Cale> olliej: do types like that get down to the level of Core?
20:50:39 <Cale> I don
20:50:47 <Cale> I don't know much about Core
20:51:14 <Cale> I'd have figured things like that would get eaten away by the frontend and turned into dictionaries and such.
20:51:15 <araujo> Pupeno, yes.
20:51:33 <olliej> Cale: they do get turned into standard data types, etc 
20:51:52 <olliej> Cale: but there names are code so I can idenitfy them, and turn them back into classes :)
20:52:15 <olliej> Cale: depending of course on what they are
20:52:18 <Pupeno> Is this a known bug or should I report it ?
20:52:29 <Cale> olliej: hmm
20:53:04 <olliej> Cale: dealing with things like foo a :: a->(forall b . b->a) ->a is fun
20:53:54 <olliej> Cale: basically you have different kinds of type variables, lifted, unlifted, and higher order
20:54:14 <olliej> Cale: lifted and unlifted are easy to deal unto
20:54:33 <olliej> Cale: it's the higher order ones that cause pain
20:54:43 <jethr0> triplah: i am really sorry, but i still get it. i thought that your problem could be expressed with a simple, concrete example. but maybe too complicated for that.
20:54:57 <triplah> jethr0: no worries, thanks for the time anyway
20:55:05 <jethr0> it'd take me quiet a while to read the whole assignment and understand all your decisions...
20:55:13 <triplah> yeah :)
20:55:19 <triplah> thats what sucks about programming
20:55:23 <Cale> olliej: is there even anything you can do to be clever about them?
20:55:26 <triplah> well reading other peoples code anyway
20:55:30 <jethr0> triplah: i'm not giving up, yet. just coaxing you into trying to describe the problem independently from the assignment to me
20:55:52 <jethr0> so that i'd know only the parts of the problem that pertained to the concrete problem.
20:55:56 <triplah> jethr0: im making realisations as i try to forumate an accurate enough description to you
20:56:04 <triplah> so you are helping already :P
20:56:09 <triplah> formulate*
20:56:11 <jethr0> cool ;-)
20:56:14 <triplah> *for
20:56:18 <triplah> sign :)
20:56:21 <triplah> argh
20:56:22 <triplah> sigh
20:56:24 <triplah> haha
20:56:28 <olliej> Cale: it looks like higher order types have to be turned into C++ styled templates -- eg. macro expansion
20:56:29 <jethr0> helping by by being a nuissance *buyacasha*
20:56:33 <dons> SamB, araujo, hmp3 0.2 is released!
20:56:35 <dons> http://www.cse.unsw.edu.au/~dons/hmp3.html
20:56:37 <triplah> hehe :)
20:56:58 <triplah> olliej: isnt that how you define higher order types anyway?
20:57:06 <triplah> enumeration types?
20:57:09 <Cale> olliej: Well, you could, but is there a benefit to it? Or do you absolutely have to do that for some reason?
20:57:13 <jethr0> triplah: from your last expressions, i gather that you used the 36h very "efficiently" for haskell up until now, huh?
20:57:20 <araujo> dons, Cool!!!! 
20:57:21 <olliej> Cale: there is no way around it
20:57:31 <Cale> hmm
20:57:35 <olliej> Cale: say you have [Int]
20:57:39 <triplah> jethr0: :(
20:57:40 <Cale> due to separate compilation?
20:57:44 <olliej> Cale: that would be a vvalid type in .NET
20:57:46 <jethr0> i.e.: are a little exhausted;
20:57:51 <Cale> okay
20:57:56 <triplah> ehe yeah :)
20:57:56 <olliej> Cale: but [*] doesn't work
20:58:10 <Cale> okay, so you don't have parametric polymorphism
20:58:20 <Cale> but shouldn't that get resolved at compile time anyway?
20:58:33 <jethr0> don't let me stress you. i've got time and other things to do. so take your time!
20:58:36 <olliej> Cale: no the problem is you can have a List of Int for instance
20:58:46 <olliej> but you can't have just a plain List
20:58:48 <jethr0> [other things to do] meanwhile*
20:59:12 <Cale> olliej: ah, okay, you're saying that dealing with higher-kinded variables is an issue
20:59:13 <olliej> as in .NET a generic type is not actually a type until type arguments are applied
20:59:19 <olliej> Cale: yeah
20:59:26 <Cale> well, isn't that sort of the same way here?
20:59:39 <olliej> Cale: I'm honestly not sure what ghc does
20:59:51 <Cale> like, you don't know which 'fmap' to dispatch until you know the type
20:59:54 <olliej> Cale: i assume it does something simlar
21:00:20 <olliej> Cale: however memory in .NET is typed
21:00:34 <olliej> Cale: so you can't just store thing temporarily as void* or whatever
21:00:47 <olliej> Cale: it makes life interesting at times
21:01:11 <olliej> @type Functor
21:01:12 <Cale> hmm, it seems to me that you shouldn't even try to keep the types as high-level as that
21:01:13 <lambdabot> Not in scope: data constructor `Functor'
21:01:18 <Cale> @type fmap
21:01:19 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
21:01:47 <Cale> there's a manner in which code which uses fmap is transformed to take a dictionary as a parameter
21:02:18 <Cale> a dictionary for Functor, which is essentially just a pointer to an implementation of fmap
21:02:38 <olliej> Cale: what module is fmap defined in?
21:02:54 <Cale> the Prelude
21:03:11 * palomer is amazed that the haskell type system is decidable
21:03:17 <Cale> it really ought to be renamed to map
21:03:30 <Cale> palomer: with -fallow-undecidable-instances it's not :)
21:03:33 <olliej> Cale: it
21:03:36 <olliej> ick rather
21:03:44 <Cale> olliej: hm?
21:04:10 <olliej> higher kinded types aren't part of haskell 98
21:04:29 <Cale> yes they are
21:04:46 <Cale> higher rank polymorphism isn't though
21:04:49 <palomer> Cale:what does (f :: * -> *) tell us?
21:05:01 <Cale> nor are multiparameter typeclasses, or functional dependencies
21:05:14 <Cale> f is a function from types to types, essentially
21:05:35 <Cale> You can read * as "Type"
21:06:12 <Cale> for example [], at the type level, is a function which takes a type, and gives the type of lists of elements of that type
21:06:23 <Cale> > [1,2,3] :: [] Integer
21:06:24 <lambdabot> [1,2,3]
21:11:46 <SamB> eh
21:11:51 <SamB> hmm.
21:11:53 <SamB> yes!
21:12:18 <palomer> java is such a huge f**** pain sometimes
21:12:37 <palomer> >:t [1,2,3]
21:12:46 <Cale> @type [1,2,3]
21:12:47 <lambdabot> forall a. (Num a) => [a]
21:12:53 <SamB> @kind []
21:12:54 <lambdabot> * -> *
21:13:02 <SamB> @kind (->)
21:13:03 <lambdabot> ?? -> ? -> *
21:13:03 <Cale> [] is written surroundfix by convention
21:13:12 * SamB likes to confuse the newbies
21:13:22 <SamB> Cale: I thought that was called outfix?
21:13:30 <Cale> hehe
21:13:32 <Cale> that works too
21:13:43 * palomer hates java, deeply
21:13:46 <SamB> by way of contrast with infix
21:13:52 <SamB> palomer: hmm. is that even allowed?
21:14:00 <SamB> I think Java only supports shallow hating!
21:14:02 <Cale> I've heard surround-fix applied to notations like absolute value
21:14:27 <triplah>     No instance for (Num [a])
21:14:28 <triplah>       arising from use of `sims' at <interactive>:1:0-3
21:14:28 <triplah>     Probable fix: add an instance declaration for (Num [a])
21:14:29 <triplah> :(
21:14:40 <SamB> triplah: well?
21:14:42 <Cale> maybe you need an additional map?
21:14:51 <Cale> you're using a list like a number
21:14:59 <triplah> hmm ok
21:15:04 <triplah> ahh
21:15:04 <Cale> > [1,2,3] + 5
21:15:05 <lambdabot>  add an instance declaration for (Num [a])
21:15:18 <olliej> Cale: the important thing about *->* type variables is that it effectively mean you have an uninstantiated polymorphic type as a  type parameter
21:15:23 <SamB> > [1,2,3] + "hello"
21:15:24 <lambdabot>  add an instance declaration for (Num [Char])
21:15:24 <lambdabot>   In the definition of `sibtxylj': sibtxylj = [1, 2, 3] + "hello"
21:15:24 <lambdabot>   In the definition of `v':
21:15:32 <olliej> Cale: which .NET does not cope with
21:15:50 <palomer> getting java to work with opengl is like pulling teeth
21:15:51 <Cale> olliej: well, neither does Intel, but people manage :)
21:16:07 <Cale> Or PowerPC
21:16:12 <SamB> hmm?
21:16:16 <Cale> they're just completely untyped
21:16:21 <olliej> Cale: yes, but they don't have to worry about types *all* the time
21:16:27 <olliej> Cale: :p
21:16:45 <SamB> .NET isn't a brand of CPU!
21:17:08 <jethr0_> samb: well, it _is_ a machine - if virtual
21:17:15 <olliej> Cale: anyhoo the main cause of this was that i couldn't think of a practical example where you would use both things at once :)
21:17:17 <SamB> true!
21:17:19 <jethr0_> well, the runtime at least
21:17:33 <Cale> olliej: I'd try and make them orthogonal
21:17:35 <SamB> in that vain, I'd like to see a Haskell implementation for Glulx
21:17:49 <olliej> SamB: glulx?
21:17:50 <triplah> its complaining about the same error, but about an arg that im passing in, which is only ever treated as an Int, im passing the litteral 0
21:17:54 * SamB thinks that would be a stupid idea, though
21:17:59 <SamB> olliej: another VM
21:18:00 <triplah> literal*
21:18:00 <olliej> Cale: how do you mean?
21:18:09 <olliej> SamB: well i had figured that much ;)
21:18:10 <jethr0_> triplah: sorry, i seem to have disconnected for the past few minutes
21:18:18 <SamB> @google glulx
21:18:19 <lambdabot> http://www.eblong.com/zarf/glulx/
21:18:30 <triplah> jethr0_: tis ok, i've been trying to write a function that makes a table of costs
21:18:31 <SamB> exactly what I wanted ;-)
21:18:47 <olliej> SamB: hehe
21:18:55 <Cale> as in, try and design things such that the mechanism for handling higher kinds, and the mechanism for handling higher rank types don't interfere with each other's operation
21:19:22 <Cale> but I wouldn't think that after the frontend got its claws into things that you'd have to deal with this sort of thing at all
21:19:31 <olliej> Cale: yeah, and i don't think what i'm currently doing should... but there's potential for much badness
21:19:52 <olliej> Cale: horrifically bad performance among them :)
21:20:22 <palomer> what in the blazes is glulx(yes I went to the webpage)
21:20:24 <jethr0_> let costString match miss space s1 s2 = sum . (zipWith (costChar match miss space)); costChar _ _ _ _ _ = 1} in costString 0 0 0 "hallo" "upsla"
21:20:28 <jethr0_> > let costString match miss space s1 s2 = sum . (zipWith (costChar match miss space)); costChar _ _ _ _ _ = 1} in costString 0 0 0 "hallo" "upsla"
21:20:29 <lambdabot>  parse error on input `}'
21:20:33 <Cale> well, if performance is a problem with those things, I think it's the frontend's job more than a backend thing
21:20:54 <jethr0_> > let {costString match miss space s1 s2 = sum . (zipWith (costChar match miss space)); costChar _ _ _ _ _ = 1} in costString 0 0 0 "hallo" "upsla"
21:20:55 <lambdabot>   Expecting a function type, but found `b'
21:20:55 <lambdabot>   Expected type: [a1] -> [a]
21:20:55 <lambdabot>   Inferred type: [a1] -> [b] -> [c]
21:20:57 <lisppaste2> triplah annotated #14264 with ":(" at http://paste.lisp.org/display/14264#4
21:20:58 <Korollary> jethr0_: what's that "}" doing there?
21:21:04 <jethr0_> haha
21:21:42 <Cale> olliej: Despite not knowing much about core, I get the feeling that there won't be enough information left about that stuff for you to care about it at that level
21:22:01 <jethr0_> > let {costString match miss space s1 s2 = sum . (zipWith (costChar match miss space); costChar _ _ _ _ _ = 1} in costString 0 0 0 "hallo" "upsla"
21:22:02 <lambdabot>  parse error on input `;'
21:22:23 <olliej> Cale: errr, at the Core level that sutff *is* there, and hence has to be in some way munged to work on .NET
21:22:28 <Korollary> jethr0_: paren left open
21:22:55 <jethr0_> working on here is not as comfy as "at home". I'LL BE BACK
21:22:59 <Cale> olliej: hmm
21:23:01 <triplah> anyone know where my error is coming from?
21:23:06 <triplah> i cant track it down :(
21:23:19 <olliej> Cale: currently the compiler produces fully lazy evaluation, type classes, instances, lambas, partial evaluation
21:23:39 <jethr0_> > let {costString match miss space = sum . (zipWith (costChar match miss space)); costChar _ _ _ _ _ = 1} in costString 0 0 0 "hallo" "upsla"
21:23:40 <lambdabot>   Expecting a function type, but found `b'
21:23:40 <lambdabot>   Expected type: [a1] -> [a]
21:23:40 <lambdabot>   Inferred type: [a1] -> [b] -> [c]
21:23:47 <olliej> Cale: but dealing with higher kinded and higher order argumetns is "exciting"
21:23:55 <jethr0_> @type zipWith
21:23:56 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
21:24:09 <Korollary> triplah: I have a tip for you
21:24:15 <triplah> Korollary: yep?
21:24:31 <triplah> i need to shower more and prgram less
21:24:37 <Cale> olliej: hmm...
21:24:51 <Korollary> triplah: Until you get comfortable with the type inferencing, split your functions and add type annotations.
21:25:24 <olliej> Cale: though higher order arguments is more or less dealt with (in the sense that algorithm should now work, and it's just down to getting some degree of type consisency)
21:25:42 <triplah> Korollary: this assignment is due tomorrow, and the questions follow the assignment spec layout, this particular quesiton is for bonus marks.... i can got splitting em up now :P
21:26:06 <Korollary> triplah: once you got it figured out, you can merge them back if you want.
21:27:59 <triplah> a good tip, 
21:28:09 <triplah> it actually helped me understand the problem at hand too
21:28:46 <triplah> hooray!
21:28:55 <triplah> ok, now to make this mother of a function
21:28:57 <triplah> :)
21:29:14 <jethr0_> hehe
21:32:50 <jethr0_> > let costString match miss space s1 s2 = sum $ zipWith (costChar match miss space) s1 s2; costChar _ _ _ = (+) in costString 0 0 0 [1,3] [1,4]
21:32:51 <lambdabot> 9
21:33:17 <jethr0_> for some reason haskell won't let me point-free s1 and s2...
21:33:45 <Cale> jethr0_: it's the $
21:34:02 <jethr0_> > let costString match miss space = sum . (zipWith (costChar match miss space)); costChar _ _ _ = (+) in costString 0 0 0 [1,3] [1,4]
21:34:02 <lambdabot>   Expecting a function type, but found `b'
21:34:02 <lambdabot>   Expected type: [a1] -> [a]
21:34:02 <lambdabot>   Inferred type: [a1] -> [b] -> [c]
21:34:04 <Cale> replace it with composition and you can
21:34:10 <jethr0_> not
21:34:10 <Cale> oh
21:34:12 <Cale> heh
21:34:17 <Cale> it's worse than that
21:34:30 <jethr0_> than what?
21:35:00 <Cale> @pl \match miss space s1 s2 -> sum $ zipWith (costChar match miss space) s1 s2
21:35:00 <lambdabot> (((((sum .) .) . zipWith) .) .) . costChar
21:35:12 <jethr0_> _great_
21:35:15 <Cale> heh
21:35:23 <SamB> palomer: it is a 32-bit replacement for the Z-Machine of dubious usefulness
21:35:33 <jethr0_> that's one hell of a short version, but maybe a tad on the write-only side!
21:35:45 <Cale> hehe :)
21:36:03 <Cale> we need @unpl :)
21:36:12 <jethr0_> unpl would be great.
21:36:21 <SamB> Cale: oh, yeah!
21:36:22 <Cale> theoretically easier too
21:36:26 * SamB to bed
21:36:36 <jethr0_> you simply feed it the newest versions of haskell-golf and obfuscated-haskell
21:36:49 <jethr0_> and it spits the literary transcriptions right in your face
21:37:30 <jethr0_> triplah: not that it will help you any, but i got a shorter version of costString
21:37:37 <jethr0_> > let costString match miss space s1 s2 = sum $ zipWith (costChar match miss space) s1 s2; costChar _ _ _ = (+) in costString 0 0 0 [1,3] [1,4]
21:37:38 <lambdabot> 9
21:37:58 * SamB thinks he understands how that repeating . thing works now, at least...
21:38:23 * jethr0_ thinks that samb _must_ be delusional from sleep deprivation...
21:38:31 <jethr0_> nobody can understand the dot thingey
21:38:36 <dons> I'd really like to have a new @pl that uses the HaRe api
21:38:36 <Cale> hehe
21:38:45 <jethr0_> at least not in "(((((sum .) .) . zipWith) .) .) . costChar"
21:38:45 <dons> an alternative @pl, I mean.
21:39:10 <dons> they have some cool transforms:  http://www.cs.kent.ac.uk/projects/refactor-fp/catalogue/RefacIdeasAug03.html
21:39:18 <dons> and http://www.cs.kent.ac.uk/projects/refactor-fp/catalogue/
21:39:40 <lisppaste2> jethr0 annotated #14264 with "shorter costString" at http://paste.lisp.org/display/14264#5
21:39:45 <dons> some of these would work nicely in one-shot single line of code style mode.
21:41:05 <Korollary> fellas, there's something wrong with this benchmark: http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=all
21:41:39 <Korollary> I'm using 6.4.1 as well, and it doesn't take 30 seconds, nor does it allocate 400MB.
21:42:50 * dons realises, 2.3 years later, that there was a typo on the opening slide of my HW'04 talk :S
21:43:02 <dons> 1.3 years? maybe that's it.
21:43:17 <Korollary> typo about a typo heh
21:43:39 <Cale> @pl \(x,(y,z)) -> x + y + z
21:43:39 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((+) .) . (+))
21:43:44 <Cale> beautiful
21:44:02 <jethr0_> no
21:44:21 <Cale> @pl \(x,(y,(z,w))) -> x + y + z + w
21:44:22 <jethr0_> @type (ap)
21:44:23 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . (
21:44:23 <lambdabot> ((.) . ((+) .) . (+)) .) . (+))
21:44:23 <lambdabot> Not in scope: `ap'
21:44:27 <jethr0_> @type `ap`
21:44:28 <lambdabot> parse error on input ``'
21:44:39 <Cale> @type Control.Monad.ap
21:44:39 <jethr0_> hehehe
21:44:40 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:45:38 <jethr0_> wtf is going on with "flip flip"
21:45:52 <dons> @type flip
21:45:53 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
21:45:55 <dons> @type flip flip
21:45:57 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
21:46:04 <dons> double your fun
21:46:09 <jethr0_> hehe
21:46:21 <jethr0_> it's the magical type combinations
21:46:25 <jethr0_> @type flip flip flip
21:46:26 <lambdabot> forall a c a1 b c1.
21:46:26 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
21:46:38 <jethr0_> huh?
21:46:43 <dons> ah, now you have a 3rd arg, so it gets a bit hard..
21:47:02 <jethr0_> @type flip flip flip flip flip
21:47:03 <dons> @type flip (flip flip)
21:47:03 <lambdabot> forall a b c a1 c1.
21:47:03 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
21:47:04 <lambdabot> forall a a1 c. (a1 -> a -> c) -> a -> a1 -> c
21:47:16 <jethr0_> @type flip flip flip flip flip
21:47:17 <lambdabot> forall a b c a1 c1.
21:47:17 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
21:47:35 <jethr0_> somehow it doesnt change after 3 appliations
21:47:43 <jethr0_> it's a typical fixpoint
21:47:57 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 = f3 (f3 x) in f4
21:47:58 <lambdabot> Not in scope: `x'
21:48:05 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
21:48:12 <jethr0_> what the heck is that?
21:48:15 <Cale> hehe
21:48:18 <dons> oh, is Cale playing games again...
21:48:24 <lambdabot> forall a.
21:48:24 <lambdabot> -> ((((((((((((((((a, a), (a, a)), ((a, a), (a, a))),
21:48:24 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a)))),
21:48:24 <lambdabot>      ((((a, a), (a, a)), ((a, a), (a, a))),
21:48:24 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a))))),
21:48:26 <lambdabot> [8188 @more lines]
21:48:29 <dons> ha ha!
21:48:34 <palomer> time to learn haskell
21:48:35 <dons> lambdabot wins the day
21:48:39 <palomer> what' sthe best way to go about this?
21:48:51 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x); f5 x = f4 (f4 x) in f5
21:48:52 <jethr0_> the quick way is here in the channel
21:49:05 <Cale> take that!
21:49:25 <jethr0_> but with a risk of getting swamped by topics that are a bit "advanced"
21:49:35 <dons> now I think she might be in trouble...
21:49:41 <jethr0_> palomer: but with a risk of getting swamped by topics that are a bit "advanced"
21:49:49 <Cale> me type-system DDoS's lambdabot
21:49:55 <jethr0_> @seen
21:50:03 <jethr0_> yes, you did
21:50:06 <dons> just wait.. she'll give up soon.. I hope.
21:50:15 <jethr0_> lambdabot is a she?
21:50:15 <Cale> or run out of memory
21:50:20 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in funny $ funny $ f x
21:50:27 <dons> well, ghc'll run out, then lambdabot will give up
21:50:56 <dons> 667m 462m  33m R  1.6 91.8   0:24.04 ghc-6.5.2005080
21:51:03 <dons> that's a big type..
21:51:04 <lambda-bot> it's me... stop torturing me
21:51:06 <Cale> that's the trouble, even with a decidable type system
21:51:22 <lambdabot> Lately, I have seen cale, dons, lambda-bot and palomer.
21:51:23 <lambda-bot> ahhh, noooo, 
21:51:24 <lambdabot> Not in scope: `x'
21:51:36 <Cale> nice
21:51:40 <dons> faithful bot! you have returned.
21:51:44 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in \x -> funny $ funny x
21:51:46 <lambdabot> forall b. (b -> b) -> b -> b
21:52:08 <dons> yeah, who cares about undecidability anyway?
21:52:25 <dons> just as long as it never decides the wrong thing.
21:52:30 <palomer> shouldn't that type be bigger?
21:52:33 <Cale> it's hard to avoid having types which are practically undecidable
21:52:37 <jethr0> > wherelet lambdabot = map chr [116,104,97,110,107,32,121,111,117] 
21:52:38 <lambdabot>  parse error on input `='
21:53:14 <jethr0> > cookie >>= lambdabot where cookie = [0]; lambdabot = \x -> map chr [116,104,97,110,107,32,121,111,117] 
21:53:16 <lambdabot> "thank you"
21:53:28 <palomer> why isn't my type bigger??
21:53:51 <Cale> funny :: (b -> b) -> b -> b
21:54:14 <Cale> and f isn't used
21:54:27 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in \x -> funny $ funny $ f x
21:54:28 <lambdabot>   Couldn't match `b -> b' against `(a, a)'
21:54:28 <lambdabot>   Expected type: b -> b
21:54:38 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in \x -> funny $ funny f x
21:54:39 <lambdabot>   Couldn't match `b -> b' against `(b -> b, b -> b)'
21:54:39 <lambdabot>   Expected type: (b -> b) -> b -> b
21:54:55 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in \x -> funny $ (funny f x) x
21:54:56 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b)
21:54:56 <lambdabot>   Expected type: b -> b
21:55:02 <palomer> darn you!
21:55:21 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x  y in \x -> funny $ (funny f x) x
21:55:22 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b)
21:55:22 <lambdabot>   Expected type: b -> b
21:55:26 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x $  y in \x -> funny $ (funny f x) x
21:55:27 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b)
21:55:27 <lambdabot>   Expected type: b -> b
21:55:41 * palomer gives up
21:56:40 <palomer> shouldn't that work?
21:58:26 <palomer> @type let f x = (x,x); funny x y = x $ x $ x $ x $  y in \x -> funny f x
21:58:27 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b, b)
21:58:27 <lambdabot>   Expected type: b -> b
21:59:28 <jethr0> @seen triplah
21:59:29 <lambdabot> triplah is in #haskell. Last spoke 30 minutes and 31 seconds ago.
22:00:10 <triplah> hey
22:01:02 <palomer> hrm
22:01:08 <palomer> yi isn't as responsive as, say, emacs
22:01:18 <jethr0> hey
22:01:39 <jethr0> palomer: how is yi? are you using it for real?
22:01:57 <palomer> I just downloaded it
22:02:00 <dons> palomer, really?/
22:02:10 <dons> not as reponsive. that's surprising. or are you talking about hIDE?
22:02:15 <palomer> nonono
22:02:24 <dons> the ncurses yi should be way ahead of emacs.
22:02:25 <palomer> I'm talking about the delay between the time I press a key and the time something is displayed
22:02:38 <dons> are you talking about ncurses yi, or yi+gtk?
22:02:47 <palomer> ./yi-static --as=emacs2
22:02:52 <jethr0> triplah: any further problems, i can't help with?
22:02:56 <dons> hmm. strange.
22:03:08 <dons> there should be no delay, as there's no computation to do
22:03:21 <palomer> it's a tad slower than emacs in X, and much slower than console emacs
22:03:27 <dons> palomer, but is this the gtk yi?
22:03:30 <triplah> jethr0: hmm i've written down the gist of waht i wanted to acheive. now i'm tidying up my code etc (aka i've given up for now)
22:03:33 <dons> or ncurses, in a terminal?
22:03:34 <palomer> dons: nope
22:03:37 <palomer> in a terminal
22:03:38 <triplah> thanks for the help before tho :)
22:03:40 <jethr0> hmm
22:03:59 <jethr0> triplah: i looked through you code and understand most of it now.
22:04:09 <triplah> ahh :)
22:04:10 <jethr0> but i still haven't understood the assignment / problem.
22:04:11 <dons> palomer, try --as=mg for me.
22:04:17 <dons> maybe it's a problem with emacs2 mode
22:04:18 <jethr0> understood what "it" is
22:04:23 <palomer> dons: no difference
22:04:35 <dons> I see no delay here. how fast is your cpu?
22:04:39 <palomer> dons: I'm really, really sensitive to this
22:04:46 <palomer> dons: the delay isn't a problem
22:04:49 <jethr0> palomer: latency on what scale? microsecs, millisecs, 10th?
22:04:57 <palomer> dons: it's probably, like, 30% slower to display
22:05:11 <palomer> jethr0: single digit millisecs, probably
22:05:16 <triplah> jethr0: the assignment problem is to generate alignments of strings and give the ones back that make give the best scores according to what scores you pass in
22:05:32 <jethr0> no, seriously, when you say it's nearly as good as emacs(x)...
22:05:32 <dons> that's very surprising. something sounds wrong.
22:05:47 <palomer> dons: it's not something that any computer user would detect
22:06:05 <dons> yeah sure, but all that happens is a ccall to ncurses to read the char, then a call to ncurses to display it.
22:06:06 <palomer> for example, 99.999% of people don't notice the time delay difference between emacs in console and emacs in X
22:06:06 <jethr0> triplah why won't "zip" do the trick?
22:06:20 <dons> maybe emacs uses an optimised display algo
22:06:22 <jethr0> does it have to be dynamic programming? i.e. interleaving of code?
22:06:30 <triplah> jethr0: i've never used zip before, and i have no idea how i'd apply it to my current functions :(
22:06:43 <jethr0> is this similar to what you want to do:
22:07:10 <jethr0> > zip [1,2] [("a","b"), ("c", "de")]
22:07:11 <lambdabot> [(1,("a","b")),(2,("c","de"))]
22:07:43 <palomer> dons: and when you type 2 characters at a really small interval, the delay increases slightly
22:08:02 <triplah> jethr0: yes it is. i just need to get my function to pass to it working properly
22:08:11 <palomer> it's a tad faster than kate though
22:08:20 <triplah> ie, i need the outputs of optalignment and similarity to match up
22:08:27 <jethr0> no, basically you need to get your function to produce the arrays and pass those
22:08:34 <palomer> actually, I take it back, kate is faster
22:08:39 <jethr0> if the arrays have the same lengths it's no prob
22:09:01 <jethr0> zip (calculateCosts) (calculateAligns)
22:09:02 <triplah> jethr0: yeah its the lenghts that are giving me some problems at the moment
22:09:13 <triplah> i need to write the one that gives the arrays of costs properly
22:09:17 <jethr0> hmm, weird
22:09:18 <dons> yi uses a fairly simple display call, it could be optimised. I learnt a few tricks since I wrote that code
22:09:40 <palomer> hrm, I could see the delay being a problem
22:10:02 <lisppaste2> triplah annotated #14264 with "list of similarities" at http://paste.lisp.org/display/14264#6
22:10:22 <palomer> does yi come with a built in ghc intepreter?
22:10:27 <palomer> err, haskell interpreter?
22:10:28 <dons> no.
22:10:32 <triplah> its giving me back too many similarities at the moment
22:10:34 <triplah> :)
22:10:58 <palomer> dons: is there anything you need done? I'm learning haskell and I always learn by doing projects
22:11:26 <dons> any patches to yi are welcome, as I don't have much time to work on it at the moment.
22:11:47 <dons> the ui drawer could be improved, along the lines of (the much faster, imo) hmp3 ui drawer
22:11:57 <dons> there's a todo list as well.
22:12:02 <triplah> *Main> align' "x" "y"
22:12:02 <triplah> [("x","y"),("x-","-y"),("-x","y-")]
22:12:05 <triplah> *Main> sims 0 1 2 "x" "y"
22:12:05 <triplah> [2,2,2,2,1]
22:12:09 <dons> also, contributions to hIDE are welcome.
22:12:12 <triplah> i need those lists to be the same length :)
22:12:32 <dons> improving the emacs modes would be another thing to do
22:12:51 <dons> i should get around to doing syn hl for yi now that I know how to do it nicely
22:13:10 <jethr0> i don't know what align' does
22:13:10 <dons> maybe that's a xmas hack
22:13:37 <triplah> jethr0: produce all possible alignments of the chars up to the ling of str1 + str2
22:13:51 <triplah> ignoring ones where there are two spaces
22:14:03 <Cale> how is hide progressing?
22:14:16 <skew> dons: what figure out for doing it nicely?
22:14:41 <skew> what did you figure out for doing syntax highlighting nicely?
22:14:41 <triplah> so what i've don previously, is run my cost function over the optimal alignments, which is inefficient, i want to make record of costs in the table as i create it
22:15:04 <skew> triplah: are you writing some kind of formatting program?
22:15:06 <jethr0> triplah: one question: don't you want to take the mimimum of all those "otherwise" elements in "sims" anyway?
22:15:23 <dons> skew, oh, I worked out how to structure ncurses screens as pretty-printed documents, making the colorizing essentially trivial
22:15:33 <dons> hmp3 is written in this way
22:15:49 <jethr0> skew : it's string similarity. what's the name of the famous algo...
22:15:50 <dons> it's a lot lot less error prone, and potentially more efficient
22:16:12 <skew> which way does that go? write down pretty printing code and get ncurses screens?
22:16:14 <triplah> skew: sort of. its calculating similairties of strings
22:16:14 <jethr0> was it knuth-morris-pratt?
22:16:17 <dons> basically, the ncurses screen is just another form of pretty printing, and it follows the ideas developed for normal haskell pretty printing
22:16:27 <dons> skew, yup.
22:16:27 <triplah> then generating ones with optimal similarities based on a scoring mechanism
22:16:53 <dons> to make it really nice needs some work -- stefanw and I have an evil plan to do this at some point
22:17:47 <skew> I think an editor should provide a way to uniquely refer to any expression in the program, and highlighting has a role in it
22:18:23 <skew> To have a natural place to put the cursor when you want to query type information, among other functions
22:18:51 <jethr0> editing distance
22:19:43 <skew> With S-expression syntax you can use the parens, I think nested colored boxes might do it for more general syntax
22:19:44 <jethr0> levenstein edit distance
22:20:46 <dons> oh, there's a levenshtein algo in lambdabot
22:20:56 <dons> @verisno
22:20:56 <lambdabot> Unknown command, try @listcommands.
22:21:01 <dons> @verison
22:21:02 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:21:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:21:33 <jethr0> @veirson
22:21:34 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:21:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:21:45 <jethr0> @veirosn
22:21:45 <lambdabot> Unknown command, try @listcommands.
22:21:50 <dons> it gives up if the edit distance is greater than 3
22:21:51 <triplah> heh
22:21:58 <dons> (though the underlying algo doesn't)
22:22:02 <jethr0> @versino
22:22:02 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:22:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:22:03 <dons> that's just a heuristic on top, though
22:22:26 <jethr0> with IO disabled it's not even dangerous...
22:22:29 <triplah> @ervsion
22:22:29 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:22:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:22:38 <triplah> @ervison
22:22:39 <lambdabot> Unknown command, try @listcommands.
22:22:42 <triplah> bah
22:22:42 <triplah> :")
22:22:45 <jethr0> @vzerszion
22:22:45 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:22:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:22:48 <skew> @revison
22:22:48 <lambdabot> Unknown command, try @listcommands.
22:22:54 <dons> jethro0, it's annoying when the wrong commands are run, and people don't even know what thing got run.
22:23:07 <triplah> lol
22:23:10 <dons> so we tame it down a bit ;)
22:23:10 <jethr0> @vzerszizon
22:23:11 <lambdabot> Unknown command, try @listcommands.
22:23:23 <triplah> @moogle cow
22:23:24 <lambdabot> Maybe you meant: google hoogle
22:23:31 <triplah> aww
22:23:32 <triplah> :(
22:23:34 <jethr0> @zverzsion
22:23:34 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:23:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:23:38 <araujo> @moo
22:23:38 <lambdabot> Maybe you meant: map more msg todo yow
22:23:41 <dons> in practice, I think 99% of errors are single edits
22:23:52 <araujo> @get-moo
22:23:53 <lambdabot> Unknown command, try @listcommands.
22:23:58 <dons> I don't think I've seen a for-real 3-edit error in the logs
22:24:00 <jethr0> @help
22:24:01 <lambdabot>  @help <command> - ask for help for <command>
22:24:07 <jethr0> @help help
22:24:08 <lambdabot>  @help <command> - ask for help for <command>
22:24:09 <dons> only when we've been hammering the edit code ;)
22:24:25 <triplah> @hooglies
22:24:25 <lambdabot> Maybe you meant: hoogle hoogle+
22:24:26 <dons> what do you think help help would say ;)
22:24:27 <jethr0> @zgozogle 
22:24:27 <lambdabot> Empty search.
22:24:33 <jethr0> @zgozogle haskell
22:24:35 <lambdabot> http://www.haskell.org/
22:24:57 <jethr0> dons: how about "@help <command> - ask for help for <command>"
22:25:05 <triplah> boogla boogie
22:25:08 <triplah> @boogla boogie
22:25:09 <lambdabot> Maybe you meant: google hoogle
22:25:10 <dons> sometimes people think the edited cmd is the real cmd. you'll see:
22:25:12 <dons> @pugs 1 + 2
22:25:14 <lambdabot> 3
22:25:17 <dons> and 
22:25:21 <dons> @y0w
22:25:22 <lambdabot> ... If I had heart failure right now, I couldn't be a more fortunate
22:25:22 <lambdabot> man!!
22:25:31 <triplah> haha
22:25:33 <jethr0> @godgka goodie
22:25:34 <lambdabot> Unknown command, try @listcommands.
22:25:44 <jethr0> @godgla goodie
22:25:44 <lambdabot> http://www.goodie.org/
22:25:56 <triplah> @tape "electric"
22:25:57 <lambdabot> [Char]
22:26:05 <jethr0> @help tape
22:26:06 <lambdabot>  @help <command> - ask for help for <command>
22:26:11 <jethr0> hehe
22:26:19 <dons> doesn't work like that. maybe it should
22:26:24 <dons> patch it! 
22:26:25 <triplah> @hell @tape
22:26:25 <lambdabot>  @help <command> - ask for help for <command>
22:26:26 <dons> @version
22:26:27 <lambdabot> lambdabot 3p212, GHC 6.5.20050806 (Linux i686)
22:26:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:26:32 <triplah> @hell tape
22:26:32 <lambdabot>  @help <command> - ask for help for <command>
22:26:56 <jethr0> @plone x $ y
22:26:57 <lambdabot> Unknown command, try @listcommands.
22:27:02 <jethr0> @play x $ y
22:27:03 <lambdabot> x y
22:27:23 <triplah> @fooval
22:27:24 <lambdabot> Unknown command, try @listcommands.
22:27:29 <triplah> @foeval
22:27:29 <lambdabot> <stdin>: hGetLine: end of file
22:27:39 <triplah> @foeval "fooval"
22:27:40 <lambdabot> "fooval"
22:27:43 <jethr0> @commandlist
22:27:44 <lambdabot> Unknown command, try @listcommands.
22:27:44 <dons> oh, that's nice.
22:27:46 <dons> @eval
22:27:46 <lambdabot> <stdin>: hGetLine: end of file
22:27:47 <jethr0> @listcommands
22:27:47 <lambdabot> use listcommands [module|command], please. Modules are:
22:27:47 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
22:27:47 <lambdabot> karma localtime more pl plugs poll quote search seen spell state system
22:27:47 <lambdabot> todo topic type version vixen where
22:27:50 <dons> heh.
22:27:54 <dons> another bug. patch it!
22:28:05 <triplah> hehe
22:28:09 <dons> that would be easy to fix... if someone wants to hack lambdabot :)
22:28:15 <dons> just edit Plugins/Plugs.hs
22:28:30 <jethr0> @hwkere haskell
22:28:30 <lambdabot> http://haskell.org/
22:28:47 <jethr0> @play flip flip flip
22:28:48 <lambdabot> flip flip flip
22:28:52 <jethr0> @help play
22:28:52 <lambdabot>  @help <command> - ask for help for <command>
22:28:58 <triplah> @sphere something
22:28:58 <lambdabot> I know nothing about something.
22:29:05 <triplah> @sphere ball
22:29:05 <lambdabot> I know nothing about ball.
22:29:11 <triplah> @sphere haskell
22:29:12 <lambdabot> http://haskell.org/
22:29:27 <jethr0> @khmer haskell
22:29:28 <lambdabot> Unknown command, try @listcommands.
22:29:30 <jethr0> @khmere haskell
22:29:31 <lambdabot> http://haskell.org/
22:29:36 <triplah> hehe
22:29:55 <jethr0> @there haskell
22:29:55 <lambdabot> http://haskell.org/
22:29:56 <dons> jethr0 and triplah go nuts.. on an unrelated note, lambdabot also works in private msg ;)
22:30:01 <triplah> @tripe "haskell"
22:30:02 <lambdabot> [Char]
22:30:04 <jethr0> sorry
22:30:04 <triplah> haha yeah
22:30:08 * triplah shuts up now
22:30:17 <triplah> its helping me procrastinate
22:30:19 <triplah> :)
22:31:04 <jethr0> @tapir flip flip flip
22:31:04 <lambdabot> Unknown command, try @listcommands.
22:31:46 <skew> wierd, why is Data.Graph.Inductive.Graph.& left-associative?
22:32:05 * dons didn't know there was an & operator in fgl
22:32:08 <dons> what does it do?
22:32:20 <dons> @type (Data.Graph.Inductive.Graph.&)
22:32:21 <lambdabot> forall (gr :: * -> * -> *) b a.
22:32:21 <lambdabot> (Data.Graph.Inductive.Graph.DynGraph gr) =>
22:32:21 <lambdabot> Data.Graph.Inductive.Graph.Context a b -> gr a b -> gr a b
22:32:41 <triplah> grab?
22:32:44 <triplah> :>
22:32:51 <dons> a graph of a's and b's
22:33:06 <triplah> ehe yeah :)
22:33:20 <skew> It adds in a new node with context
22:47:03 <skew> The graphviz output is very nice
22:51:01 <jethr0> @seen
22:51:02 <lambdabot> Lately, I have seen jethr0.
22:51:10 <dons> oh. that's interesting
22:51:17 <dons> kzm's new  patches are fun :)
22:51:28 <dons> @seen
22:51:28 <lambdabot> Lately, I have seen dons and jethr0.
22:51:34 <dons> mmm. nice.
22:51:45 <triplah> hah!
22:51:57 <dons> lately == 2 mins, according to Seen.hs
22:52:09 <jethr0> hah
22:52:14 <triplah> @seen
22:52:15 <lambdabot> Lately, I have seen dons, jethr0 and triplah.
22:52:24 <dons> @seen #haskell-overflow
22:52:25 <lambdabot> In #haskell-overflow I can see astrolabe, eivuokko, kbot2, korollary,
22:52:25 <lambdabot> musasabi, philippa_, samb, shapr, ski, ski_ and thehunter.
22:52:37 <dons> that could be a bit verbose, but cool
22:52:45 <dons> kbot2 eh?
22:52:47 <Cale> @seen #haskell
22:52:47 <lambdabot> In #haskell I can see araujo, astrolabe, binary42, cale, dcoutts, dons,
22:52:47 <lambdabot> eivuokko, flux__, fworp, gs30ng, heffalump, jethr0, jlouis, johnmeacham,
22:52:47 <lambdabot> kala, korollary, lemmih, lisppaste2, lispy, moonlite, musasabi, neologism,
22:52:47 <lambdabot> olliejbbl, palomer, philippa_, psykotic, resiak, ricebowl, samb, shapr,
22:52:47 <lambdabot> sieni, skew, ski, ski_, speck, syntaxfree, thehunter, tic, triplah,
22:52:49 <lambdabot> ulfdoz and user317.
22:52:54 <triplah> especially if someone does @seen #haskell
22:52:57 <triplah> ahh
22:52:58 <triplah> :)
22:53:02 <dons> well. interesting..
22:53:20 <jethr0> dons: for what time period is that?
22:53:28 <dons> trying to work that out..
22:53:28 <jethr0> since LB has been connected?
22:54:12 <dons> hmm. maybe. but it also has persistent state, which makes it less a bit confusing.
22:54:16 <jethr0> haven't seen lately: "flux__, dcouts, neologism, psykotic, speck, ulfoz"
22:54:41 <jethr0> "which makes it less a bit confusing" ???
22:54:58 <jethr0> working on your paradoxes?
22:54:59 <dons> potentially the list of people to @seen could go bcak months
22:55:12 <dons> s/less// :)
22:55:22 <jethr0> which would make it less helpful.
22:55:30 <dons> sometimes  I change my ideas half way though a sentence, but my fingers don't catch up
22:55:43 <jethr0> maybe, it should be ordered in reverse by last appearance
22:56:12 <triplah> you need a signal monad for your finger dons 
22:56:17 <triplah> fingers*
22:56:18 <skew> Well, persistant state makes it possible to implement something more predicatable than just since lambdabot was last on
22:56:31 * beelsebob_ wonders why he's still up at 7am
22:56:33 <dons> right, so I'm wondering why that list was so small..
22:57:05 <jethr0> beelsebob, you're in good company ;-)
22:57:14 <beelsebob_> :)
22:57:20 <beelsebob_> what did you spend the night doing?
22:57:43 <triplah> avoid code induced tourettes by singing songs while i program
22:57:44 <jethr0> nothing, really
22:57:48 <triplah> avoiding*
22:57:50 <beelsebob_> boring!
22:57:53 <jeffno> What happened to the haste IDE?
22:57:55 <jethr0> mainly procrastinating in here
22:58:05 * beelsebob_ spent the evening trying to fix his love life
22:58:14 <jethr0> _WAY_ better
22:58:22 <jethr0> but the "trying" part worries me
22:58:24 <triplah> hmm i just thought the rubbery grip on my pacer was a snake lolly, i almost ate it
22:58:30 * triplah should pay more attention
22:58:51 <beelsebob_> jethr0: succeeding I think :)
22:59:21 <dons> @quit testing...
22:59:22 * jethr0 shudders at "rubbery grip on my pacer was a snake lolly" in close context with "trying to fix his love life"
22:59:30 <jethr0> beelsebob, well then.
22:59:37 * beelsebob_ goes to bed
22:59:41 <jethr0> nite
22:59:45 <beelsebob_> night
23:00:12 <jethr0> triplah: what is a pacer? pacifier? *g*
23:00:19 <triplah> hehe
23:00:37 <triplah> nah, its a pencil, but made of plastic... and you press the top to make more lead come out
23:00:46 <triplah> a pen with leads?
23:00:52 <jethr0> well, technically it ain't lead!
23:01:00 <triplah> true true :)
23:01:18 <skew> in US they are called mechanical pencils
23:01:31 <jethr0> or is it called "lead" in english?
23:01:33 <triplah> what do people actually call them?
23:01:42 <dons> um, or "graphite" ;)
23:01:47 <triplah> yeah
23:01:47 <triplah> :)
23:01:56 <triplah> old words stick i guess
23:01:57 <jethr0> "mechanical pencils"! that's hillarious
23:02:07 <triplah> what a mouthful
23:02:17 <triplah> only fitting for people with such large mouths
23:02:17 <dons> I like programming my mechanical abacus
23:02:18 * triplah ducks
23:02:35 * jethr0 likes typing with his mechanical fingers
23:02:43 <triplah> dons: you have a computer with windows too? :)
23:02:52 <dons> heh
23:03:16 <dons> no no, mines more like a mechanical brain once haskell's running :)
23:03:24 <triplah> hehe
23:03:33 <triplah> habacus
23:03:49 <triplah> a calculator written in haskell?
23:03:53 <triplah> hmm
23:03:59 <triplah> that could be very cool
23:04:08 <triplah> oh wait, you can use ghci like that anyway
23:04:11 <dons> there's a few, well, I can think of one.
23:04:17 <jethr0> okay, fingers can't actually be mechanical
23:04:25 <dons> gtkcalc? or some such it's called.
23:04:39 <triplah> gtkcalc? written in haskell?
23:04:48 <triplah> jethr0: ever seen ghost in the machine? :)
23:04:52 <triplah> er
23:04:55 <jethr0> sure, _great_ movie
23:05:08 <triplah> wait ..
23:05:15 <triplah> ghost in the shell?
23:05:24 <triplah> ghost shell?
23:05:41 <jethr0> quite visionary ideas, seeing souls as transferable entities and bodies as mere mechanical vessels
23:05:43 <triplah> people have implants
23:06:09 <jethr0> yeah, i got you the first time *G*
23:06:17 <triplah> ahh :)
23:06:18 <jethr0> ghost in the shell
23:06:30 <triplah> yeah thats it
23:06:35 <triplah> with the finger implants
23:06:39 <triplah> mechanical fingers
23:06:50 <jethr0> true, hundreds of them typing away
23:07:32 * araujo is the puppet-master
23:10:20 * jethr0 is the amped-up Major Kusanagi
23:10:49 <triplah> ehe
23:11:26 <jethr0> "Der originale, japanische Titel bedeutet aufgeschlüsselt: ? = Angriff, ? = Schale, Hülse; Hülle, ??? = Mobile Einsatztruppe."
23:11:27 <jethr0> ;-)
23:11:40 <jethr0> sh*t
23:12:07 <triplah> heh :)
23:12:50 <jethr0> "the original, japanese title means "translated": ... = attack, ... = shell, hull, ... mobile deployment unit
23:14:57 <dons> @babel de en Der originale, japanische Titel bedeutet aufgeschlüsselt
23:14:58 <lambdabot>  The original, Japanese title means classified
23:15:02 <dons> hehe
23:15:12 <jethr0> _no_
23:15:38 <triplah> @babel ich glaube babel ist nicht richtig
23:15:38 <lambdabot> Module "babel" produced error: Error: Language ich not supported
23:15:41 <jethr0> auschlüsseln can hardly ever mean "classify"
23:15:48 <dons> @help babel
23:15:49 <lambdabot> usage: babel lang lang phrase
23:15:59 <jethr0> @babel Ich glaube Babel ist nicht richtig.
23:16:00 <lambdabot> Module "babel" produced error: Error: Language Ich not supported
23:16:00 <triplah> @babel de Ich glaube babel ist nicht richtig
23:16:01 <lambdabot> Module "babel" produced error: Error: Language Ich not supported
23:16:09 <jethr0> @babel de en Ich glaube Babel ist nicht richtig.
23:16:10 <lambdabot>  I do not believe Babel am correct.
23:16:19 <triplah> ahh :)
23:16:35 <triplah> @babel de en danke shoen jethr0 
23:16:36 <lambdabot>  shoen jethr0 thanks
23:16:41 <triplah> bah
23:17:36 <jethr0> @babel en de The correctness of Babel's translation can rightfully be disputed by literary experts and amateurs alike
23:17:37 <lambdabot>  Die Korrektheit von Übersetzung Babels kann von den literarischen
23:17:37 <lambdabot> Experten und von den Bewunderern rechtmäßig gleich diskutiert werden
23:17:56 <triplah> @babel de en ich hasse babel, er hat sheiss im kopf
23:17:57 <lambdabot>  I hate babel, he have sheiss in the head
23:18:01 <jethr0> @babel de en Die Korrektheit von Übersetzung Babels kann von den literarischen Experten und von den Bewunderern rechtmäßig gleich diskutiert werde
23:18:03 <triplah> haha
23:18:03 <lambdabot>  The correctness of translation Babels can by the literary experts and by
23:18:03 <lambdabot> the Bewunderern is rightfully directly discussed
23:18:10 <triplah> ROFL
23:18:19 <jethr0> well, the german translation was actually quite good
23:18:33 <jethr0> *damn*
23:18:39 <yozora> @help babel
23:18:39 <lambdabot> usage: babel lang lang phrase
23:18:40 <triplah> :)
23:19:01 <jethr0> although he translated "amateur" with "admirer" ?!?!
23:19:10 <triplah> lol
23:19:47 <jethr0> i never understood how babel can translate into a word and not back again (Bewunderern)...
23:19:55 <jethr0> that seems like seriously buggy programming to me.
23:20:14 <dons> maybe it's the same reason you can't always compile down and back again..
23:20:36 <triplah> the dictionaries for the languages must be unique for each direction
23:20:42 <jethr0> dons: it would be cool, if the lambdabod responses could be piped into the haskell "interpreter" and vice versa ;-)
23:21:24 <jethr0> dons: yes, but in this case (at least for 1-to-1 cases) it's a bijective function to start with
23:21:54 <dons> maybe. unless @babel also does more than just keyword translation.
23:21:55 <jethr0> you just have to reverse the original dictionary and multiply out ambiguities
23:22:08 <jethr0> @type assoc
23:22:09 <lambdabot> Not in scope: `assoc'
23:22:51 <jethr0> what was the function called for finding associtation tuples?
23:23:03 <dons> @type List.lookup
23:23:03 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
23:23:07 <dons> ?
23:23:12 <jethr0> yup
23:24:01 <jethr0> > snd $ Maybe.fromJust  $ lookup "amateur" [("admirer", "amateur")]
23:24:02 <lambdabot> Couldn't match `(a, b)' against `[Char]'
23:24:22 <jethr0> > snd $ Maybe.fromJust  $ lookup "amateur" [("amateur", ["admirer", "amateur"])]
23:24:23 <lambdabot> Couldn't match `(a, b)' against `[[Char]]'
23:24:30 <jethr0> ah, f*ck it.
23:24:43 <jethr0> > Maybe.fromJust  $ lookup "amateur" [("amateur", ["admirer", "amateur"])]
23:24:44 <lambdabot> ["admirer","amateur"]
23:28:43 <Lemmih> > ["admirer","amateur"] !! 1
23:28:44 <lambdabot> "amateur"
23:29:25 <yozora> @babel en jp cat
23:29:25 <lambdabot> Module "babel" produced error: Error: Language jp not supported
23:29:47 <Lemmih> autrijus: en jp cat
23:29:56 <jethr0> i wanted to reverse the association thingey, but when i realized how much work it'd be my motivation waned
23:30:01 <jethr0> @babel en de waned
23:30:03 <lambdabot>  abgenommen
23:30:20 <jethr0> gato?
23:30:37 <jethr0> @babel jp en gato
23:30:37 <lambdabot> Module "babel" produced error: Error: Language jp not supported
23:32:39 <yozora> @babel en cn cat
23:32:40 <lambdabot> Module "babel" produced error: Error: Language cn not supported
23:34:07 <yozora> @babel en fr cat
23:34:08 <lambdabot>  chat
23:34:56 <yozora> @babel fr en je ne comprend pas
23:34:57 <lambdabot>  I does not include/understand
23:35:19 <dons> @babel en ja cat
23:35:23 <lambdabot>  can't parse this language
23:35:26 <dons> ah well.
23:35:48 <dons> it means that the answer returned by babelfish didn't fit the regexes we currently have
23:36:19 <dons> @babel ja en gato
23:36:21 <lambdabot>  Gato
23:37:31 <yozora> @babel ja en gato wa nan nano yo
23:37:32 <lambdabot>  Gato wa nan nano yo
23:38:09 <dons> it's using this: http://babelfish.altavista.com/babelfish/tr
23:41:12 <jethr0> @babel es en que diablo pasa con ese chisme(?)
23:41:13 <lambdabot>  that devil passes with that chisme()
23:42:05 <fworp> @babel hakunamatata
23:42:06 <lambdabot>  bzzt.
23:42:10 <yozora> there's always something interesting in #haskell
23:42:20 <Cale> @babel ja en ãã¨ã¯ãªããªã®ã
23:42:21 <lambdabot>  can't parse this language
23:42:38 <Cale> @babel ja en ãã¨ãã¯ããªãããªã®ãã
23:42:39 <lambdabot>  can't parse this language
23:42:39 <jethr0> yozora: what does "gato wa nan nano yo" mean?
23:42:48 <yozora> "what's gato?"
23:43:01 <jethr0> nani des ka?
23:43:08 <ski_> (dons : hm, dons, did you fix the 'xxxx' thing ?)
23:43:15 <jethr0> watashi wa jethr0 des
23:43:34 <yozora> hajimemashite jethr0-san
23:43:36 <jethr0> anata wa nihonjin des ka?
23:43:46 <dons> ski_, sure did.
23:43:52 <jethr0> hajimemashite yozora-san
23:44:02 <yozora> chigaimasu chuugokujin desu
23:44:16 <yozora> keredo australia ni sundeimasu
23:44:40 <jethr0> i already used up my japanese skills two lines ago ;-))
23:45:12 <yozora> :)
23:45:13 <jethr0> but reading/hearing it again makes me wanna learn it once more for real *g*
23:45:28 <yozora> i'm just a learner too anyway
23:45:51 <jethr0> anata wa nihongo no gakuse des ka?
23:45:55 <Cale> å¤ç©º
23:46:18 <jethr0> cale: you were the one with the longest unreadable line, so far...
23:46:24 <Cale> hehe :)
23:46:31 <jethr0> > xxxx
23:46:32 <lambdabot>  Not in scope: `xxxx'
23:47:05 <Cale> jethr0: I haven't said anything original though :)
23:47:14 <ski_> (palomer : i think you need rank-2 polymorphims to abstract in that way ..)
23:47:26 <yozora> kaishain dakedo nihongo wo naraimasu
23:47:44 <jethr0> cale, well, i couldn't read it, so i'll take you word for your unoriginality ;-)
23:48:52 <jethr0> yozora, sorry, but "i only understand train station" as goes a saying in german...
23:49:23 <jethr0> @babel de en Ich verstehe nur Bahnhof.
23:49:25 <lambdabot>  I understand only station.
23:49:44 <Cale> yozora: Is that your company is making you learn Japanese?
23:50:15 <yozora> nah, i'm just doing it for fun
23:50:19 <jethr0> no, i started studying just for fun for a short time (a few weeks, a few hours per week) and then just stopped
23:50:22 <yozora> to play japanese video games
23:50:36 <yozora> which is a very mature adult reason
23:50:41 <jethr0> because i had trouble with those pesky characters
23:50:51 <yozora> but my company is making me use c# :P
23:50:57 <jethr0> couldn't even bring myself to learn the easy/few ones
23:51:07 <Cale> I learned a bit from being exposed to Go
23:51:27 <Cale> which got me into watching Hikaru no Go
23:51:39 <jethr0> "being exposed to go" makes it sound like an pandemic disease ;-)
23:51:54 <Cale> oh, it is :)
23:51:59 <jethr0> hehe
23:52:21 <Cale> wonderfully infectious game :)
23:52:21 <dons> some kind of virus of the brain
23:52:31 <jethr0> i tried Go too, but after playing _very_ few games on a 19x19 board, i decided it would take me decades to reach an acceptable level and stopped.
23:52:50 <Cale> jethr0: start on 9x9
23:52:58 <Cale> we'll have some games
23:53:19 <Cale> the proverb goes something like "lose your first 50 games as quickly as possible"
23:53:23 <jethr0> cale, i did. 9x9 was getting to small an 13x13 nobody plays. but 19x19 is just _so_ big
23:53:41 <Cale> yeah, it is pretty large
23:53:53 <Cale> but you get some intuition after a while
23:54:01 <jethr0> yes, but after 15 games i had already gathered that fast progress in the sense of reliable heuristics is not an easy feat in Go
23:54:02 <Cale> and things start coming together
23:54:04 <Buggaboo> 19x19 takes about 2 hours or sometihng
23:54:09 <jethr0> hmm
23:54:10 <Buggaboo> doable
23:54:17 <Cale> 2 hours?
23:54:29 <Cale> well, if you're playing really seriously
23:54:40 <Cale> normal games take me about 45 minutes
23:54:43 <Buggaboo> oh no, I play mostly with idiots...
23:55:12 <Cale> I tend to get lazy and play just on intuition
23:55:18 <jethr0> but in the same time of reaching a 5 kyu, i could already have mastered the whole of haskell there and back again
23:55:21 <Cale> which is probably why I'm not 1d :)
23:55:44 <Cale> anyone want a game?
23:55:52 <Cale> KGS please :)
23:56:11 <jethr0> cale, great. i'm something like a 18 kyu (if that). how many advance stones (japanese word here) would you give me? 12?
23:56:25 <Buggaboo> I'm programming a go game in python... but got stuck on the ai part.
23:56:32 <Cale> hehe, I'm not quite sure, but we could try 9
23:56:38 <jethr0> *rofl*
23:56:38 <Cale> 9 is the usual max
23:57:12 <jethr0> buggaboo: i started writing a python game in python too, but never intended for a real AI
23:57:38 <jethr0> an idea would have been to somehow gather hundreds if not thousands of games with reliable annotations from good players
23:58:06 <jethr0> and magically build up a neuronal network (or similar) representation of those annotated moves
23:58:20 <jethr0> but as we all know, this is sheer naivity speaking ;-)
23:58:27 <Buggaboo> I'm trying the neural network approach too.
23:58:28 * Cale listens as his brain is modified by the music of John Scofield.
23:58:41 <yozora> what about that alpha-beta cutoff algorithm?
23:58:57 <yozora> is it too computationally expensive?
23:58:58 <Buggaboo> alpha-beta pruning is not very good here...
23:59:08 <jethr0> number of possibilities is too big for anything tree-based
23:59:08 <Buggaboo> search space is disgustingly large.
23:59:12 <Cale> There are 361 intersections on the board
23:59:31 <jethr0> you gotta look at local and global patterns and decide solely on basis of these.
23:59:36 <Cale> that goes down by roughly 1/move
23:59:56 <jethr0> determine freedoms of groups, pro/con of their survival and the chances
23:59:56 <yozora> sounds like an interesting game then
