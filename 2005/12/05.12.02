00:00:02 <dons> > show [1,2,3,4,56,7,8]
00:00:03 <lambdabot> "[1,2,3,4,56,7,8]"
00:00:06 <boegel> kzm: on the back
00:00:32 <boegel> dons: I meant [1,2,3,4,5,6,7,8], and split it in lists of size n (=4)
00:01:00 <kzm> > splitAt 4 [1..8]
00:01:01 <lambdabot> ([1,2,3,4],[5,6,7,8])
00:01:06 <dons> right.
00:01:13 <boegel> kzm: but also with longer lists :)
00:01:16 <dons> fold that
00:01:22 <boegel> > splitAt 4 [1..12]
00:01:23 <lambdabot> ([1,2,3,4],[5,6,7,8,9,10,11,12])
00:01:38 <boegel> brb
00:02:29 <kzm> let {(x,y) = spliAt 4 [1..12] ; (y',z) = splitAt 4 y} in [x,y,z]
00:02:33 <kzm> > let {(x,y) = spliAt 4 [1..12] ; (y',z) = splitAt 4 y} in [x,y,z]
00:02:34 <lambdabot>  Not in scope: `spliAt'
00:02:39 <kzm> > let {(x,y) = splitAt 4 [1..12] ; (y',z) = splitAt 4 y} in [x,y,z]
00:02:40 <lambdabot> [[1,2,3,4],[5,6,7,8,9,10,11,12],[9,10,11,12]]
00:02:46 <kzm> > let {(x,y) = splitAt 4 [1..12] ; (y',z) = splitAt 4 y} in [x,y',z]
00:02:47 <lambdabot> [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
00:03:00 <kzm> Generalization is left as an excercise for the reader :-)
00:03:19 <triplah> what do {} mean in haskell?
00:03:35 <Heffalump> they can be used to explicitly delimit blocks
00:03:48 <kzm> also for record selection
00:03:51 <triplah> ahh ok
00:04:00 <kzm> x {field1="foo"}
00:04:01 <Heffalump> and record definition
00:04:38 <Heffalump> data Foo = Bar { field1 :: String, field2 :: String } | ...
00:04:45 <kzm> Normally, I'd write:
00:04:50 <kzm> let x = foo y
00:04:53 <Heffalump> (what kzm said is technically record updating, not selection, btw)
00:04:57 <kzm>     x2 = blah blah
00:05:19 <kzm> but in ghci, you must (?) write let {x = foo y; x2 = blah blah} in ...
00:05:34 <kzm> Yeah, yeah. Whatever :-)
00:05:49 <kzm> (you are right of course)
00:07:26 <Speck> where can I read about the GADT stuff that the simons et al are adding to ghc?
00:08:04 <Heffalump> GHC docs aren't too bad
00:08:15 <kzm> speck: there was a paper at ICFP, I think.
00:08:19 <Heffalump> there's also a paper at ICFP 05 by Henrik Nilsson that helps understand them
00:08:30 <Speck> I saw his dynamic optimizations paper
00:08:39 <Speck> is that the one?
00:08:42 <Heffalump> think so
00:08:55 <Heffalump> he was explaining how GADTs help him optimize Yampa programs
00:09:10 <Heffalump> because he can express things that need to be optimized with them that he just couldn't without
00:09:12 <kzm> Pardon me, but I must ask: are you really in Liechtenstein?
00:09:14 <Speck> yeah that's it -- great paper. I wonder if that technique will be applied to ghc at all.
00:09:28 <Heffalump> me? no. Just a vanity domain.
00:09:47 <Speck> Heffalump: actually, I was a little disappointed by his benchmarks in the paper, though I thought he should have gone futher with it
00:09:53 <kzm> :-)
00:09:57 <Heffalump> a bunch of us thought it'd be cool to register earth.li some years back so we could call ourselves "earthlings"
00:10:26 <kzm> I guess cyb.org was taken? 
00:10:51 <kzm> Wow - it's not!
00:11:24 <triplah> i have to register a few domains at uni soon
00:11:27 <kzm> Domain squatting, here I come!
00:11:30 <triplah> store.it.bond.edu.au
00:11:33 <triplah> see.it.bond.edu.au
00:11:38 <triplah> stop.it.bond.edu.au
00:12:02 <triplah> filestore, webserver + open sharepoint, and firewall respectivly
00:12:21 <triplah> wait, share.it is the webserver
00:12:22 <Heffalump> Speck: I don't really remember how good the results were, but I thought it was quite cool
00:12:24 <kzm> It must be quite tempting to use nastier words than those...especially for windows servers?
00:12:26 <triplah> see.it is the freeNX server
00:12:32 <triplah> kzm: very much so
00:12:50 <triplah> but we use opensource products exclusivly in the IT students association
00:12:59 <Speck> Heffalump: not much improvement at all (actually one case was worse) -- but maybe Frag would show some interesting results
00:13:24 <kzm> There was (is?) a company here called Yes.  So the domain is yes.no, and I think the users were called "maybe", "perhaps" etc.
00:13:34 <triplah> haha nice
00:13:47 <mysteriousentity> Hello. Is there a library function equivalent to (\x -> case x of True -> 1; False -> 0)?
00:14:01 <triplah> we have very large amount of norweigian students at bond
00:14:08 <triplah> and the other uni here in this city
00:14:14 <triplah> lots
00:14:18 <ibid> i used to have an email address at sci.fi
00:14:25 <triplah> haha
00:14:52 <kzm> mysteriousentity, fromEnum?
00:15:02 <kzm> > map fromEnum [True,False]
00:15:03 <lambdabot> [1,0]
00:15:04 <mysteriousentity> oh, of course :)
00:15:12 <mysteriousentity> thank you
00:15:14 <ibid> it was the premier ISP in finland in the latter half of the 90's
00:15:46 <ibid> no longer exists except as a legacy domain in the huge ISP that scifi merged into
00:15:59 * triplah turns kettle on
00:16:08 <triplah> i've got a long way to go with this hs assignment
00:17:35 <boegel> kzm: I need help generalizing it :(
00:19:03 <kzm> Do an explicit recursion?  s4 xs = let (h,t) = splitAt 4 xs in h : s4 t
00:19:32 <kzm> add terminatino if length t <= 4
00:20:18 <kzm> Then when you've spent an hour getting all the details right, rewrite it to use a fold :-)
00:20:42 <boegel> > let {s4 xs = let (h,t) = splitAt4 xs in (h : s4 t) ; s4 [] = []} in s4 [1..16]
00:20:42 <lambdabot>  Not in scope: `splitAt4'
00:20:50 <boegel> > let {s4 xs = let (h,t) = splitAt xs in (h : s4 t) ; s4 [] = []} in s4 [1..16]
00:20:51 <lambdabot>   Expecting a function type, but found `(a, b)'
00:20:51 <lambdabot>   Expected type: (a, b)
00:20:51 <lambdabot>   Inferred type: [a1] -> ([a1], [a1])
00:21:30 <boegel> > let {s4 xs = let (h,t) = splitAt 4 xs in (h : s4 t) ; s4 [] = []} in s4 [1..16]
00:21:31 <lambdabot>   Warning: Pattern match(es) are overlapped
00:21:31 <lambdabot>      In the definition of `s4': s4 [] = ...
00:21:46 <boegel> > let {s4 [] = []; s4 xs = let (h,t) = splitAt 4 xs in (h : s4 t)} in s4 [1..16]
00:21:47 <lambdabot> [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
00:21:52 <boegel> w00 !
00:22:09 <boegel> now, using foldl...
00:23:02 <int-e> takeWhile (not . null) $ unfoldr (Just . splitAt 4) [1..15]
00:23:21 <dons> unfoldr!
00:23:25 <int-e> > takeWhile (not . null) $ unfoldr (Just . splitAt 4) [1..15]
00:23:26 <lambdabot> [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15]]
00:23:47 <boegel> @type unfoldr
00:23:48 <lambdabot> Not in scope: `unfoldr'
00:23:59 <boegel> @index unfoldr
00:24:00 <lambdabot> Data.List
00:24:01 <int-e> @type Data.List.unfoldr
00:24:02 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
00:24:54 <dons> it can do no wrong
00:24:57 <boegel> ok, but these functions aren't all in h4sh, right ? (Maybe monad, null, ...)
00:25:11 <dons> sure, unfoldr is.
00:25:17 <dons> paprika$ unfoldr --help
00:25:17 <dons> Usage: "unfoldr" [OPTION...] [file..]
00:25:17 <dons>   -V  --version  version string
00:25:17 <dons>   -h  --help     help
00:25:18 <boegel> oh, coolness
00:25:20 <dons> :)
00:26:59 <dons> i have a suspicion that all programs can be reduced to unfoldr
00:27:18 <boegel> heh :)
00:27:41 <lisppaste2> triplah annotated #14223 with "non-dyn align" at http://paste.lisp.org/display/14223#1
00:27:56 * triplah begs again
00:27:59 <triplah> so close :)
00:28:08 <dons> what's the unfoldr paper called?
00:31:23 <int-e> Imagiro?
00:40:31 <palomer> what the heck is unfoldr?
00:42:05 <dons> -- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'
00:42:05 <dons> -- reduces a list to a summary value, 'unfoldr' builds a list from
00:42:11 <dons> -- a seed value. 
00:42:24 <palomer> dual in which sense?
00:42:47 <dons> it reverses a fold
00:42:59 <dons> -- > unfoldr f' (foldr f z xs) == xs
00:43:11 <palomer> ah, so it's a sort of left inverse
00:43:21 <palomer> what's f'?
00:43:51 <int-e> unfoldr f x = case f x of Nothing -> []; Just (l, x') -> l:unfoldr f x'
00:43:58 <dons> some function, where:
00:44:00 <dons> -- > f' (f x y) = Just (x,y)
00:44:00 <dons> -- > f' z       = Nothing
00:44:26 <palomer> sounds groovy
00:44:36 <palomer> got a wicked example of unfoldr in action?
00:44:54 <dons> iterate f == unfoldr (\x -> Just (x, f x))
00:45:27 <int-e> I used in 20 minutes ago.
00:46:15 <int-e> it.
00:46:18 <palomer> I'm guessing there's an unfoldl too, right?
00:46:42 <dons> nope.
00:46:51 <palomer> why not?
00:47:53 <int-e> it wouldn't be a good list producer - you'd generate the result tail first (I think)
00:48:35 <palomer> ugh
00:48:36 <palomer> bedtime
00:48:38 <palomer> night!
00:51:18 <kzm> and I got to start working :-)
01:05:50 <triplah> argh
01:05:57 <triplah> im so close to getting this function nailed
01:06:00 <triplah> :)
01:10:57 <mysteriousentity> Is there an easy way of displaying a function's name in an error?
01:12:29 <Lemmih> myFunc = error "Error in myFunc" (:
01:13:03 <dons> use assert, perhaps
01:13:45 <Lemmih> That wont give you the function name, though.
01:14:29 <mysteriousentity> which module holds assert?
01:14:33 <dons> no, but it'll give you a line number
01:14:35 <dons> $ ./a.out 
01:14:35 <dons> a.out: T.hs:10:4-9: Assertion failed
01:14:54 <dons> GHC.Base
01:14:59 <dons> @index assert
01:15:00 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
01:15:10 <dons> f = assert (1 == 2) $ undefined  
01:15:27 <Lemmih> mysteriousentity: What kind of errors are you referring to?
01:15:32 <dons> @type Control.Exception.assert
01:15:33 <lambdabot> forall a. Bool -> a -> a
01:16:38 <mysteriousentity> Lemmih: Logic errors. Very much like what assert does in C.
01:16:49 <mysteriousentity> I didn't know it existed in Haskell
01:17:18 <dons> well, you could probably guess it's type, then ask hoogle:
01:17:21 <dons> @hoogle assert
01:17:21 <lambdabot> Control.Exception.assert :: Bool -> a -> a
01:17:21 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
01:17:21 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
01:17:31 <dons> @hoogle Bool -> a -> a
01:17:32 <lambdabot> Control.Exception.assert :: Bool -> a -> a
01:17:32 <lambdabot> Prelude.id :: a -> a
01:17:32 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:17:37 <dons> yeah :)
01:18:23 <mysteriousentity> Thanks :)
01:53:12 <musasabi> mmh, why does HaskellDB discard type information when compiling queries?
01:54:41 <musasabi> or makes it harder to use in any case.
02:01:30 <sethk> musasabi, it's simplistic in order to work with too many databases, IMHO
02:01:52 <sethk> musasabi, I'm working on a haskell database thing, but it's still several weeks from being interesting
02:02:34 <sethk> musasabi, for small and simple databases it works reasonably well, though
02:05:55 <musasabi> sethk: hmm, what kind of thing?
02:06:21 <sethk> musasabi, I'm translating my database server into haskell.
02:06:56 <sethk> musasabi, and of course the user interface as well, but that will follow the changes on the server side.
02:06:57 <musasabi> sethk: Are you using STM for things? (I was playing with using STM for database concurrency control)
02:07:26 <sethk> musasabi, no.  The concurrency control I use is unique and it doesn't fit well into STM.
02:07:36 <sethk> musasabi, although I am still debating on exactly how to translate it.
02:07:47 <sethk> musasabi, I might wrap STM, but I haven't found a clean way to do it yet.
02:08:30 <sethk> musasabi, ask me again in about a week.  :)
02:08:59 <musasabi> will do, (and please tell if you get any success - I would be interested in looking at the code)
02:09:05 <sethk> musasabi, because I'm taking advantage of laziness, I'm doing column level locking, which is hardly trivial.
02:09:21 <sethk> musasabi, oh, I will do it, since I have a working C++ engine that will map reasonably well.
02:09:28 <sethk> musasabi, the only question is how long it will take me.
02:09:43 <sethk> musasabi, which, of course, is not an unimportant question.  :)
02:11:10 <sethk> which reminds me of something I wanted to ask.  What tools are available to count lines of code?
02:12:21 <musasabi> grep and wc -l ;)
02:12:31 <sethk> musasabi, that I know about.  :)
02:12:41 <sethk> musasabi, I think there is either a tool or something that you can get from ghc
02:13:39 <musasabi> I think loc does not make very much sense most of time.
02:13:55 <sethk> musasabi, true, but it is better than wc -l
02:13:56 <musasabi> Because it is only comparable for code written in the same style
02:14:10 <sethk> musasabi, but I agree it is a poor metric.  It's just that people ask.
02:14:49 <musasabi> sethk: If you want to compare C++ and Haskell I would just wc -l both (and maybe do another run with comments and blank lines removed)
02:15:26 <sethk> musasabi, removing comments and blank lines is easy and probably good enough, you are right.
02:15:42 <phys_rules> ghc has a perl script
02:15:46 <phys_rules> count_lines
02:15:50 <sethk> musasabi, my coding style leads to a large number of lines in both languages.
02:15:54 <phys_rules> in the sources under ghc/compiler
02:16:05 <phys_rules> it even unlits the *.lhs files hehe
02:16:08 <sethk> phys_rules, in the sources, but not installed by make install?
02:16:22 <phys_rules> nope, not in the install
02:16:44 <musasabi> http://cvs.haskell.org/darcs/ghc/ghc/compiler/count_lines
02:17:02 <sethk> phys_rules, musasabi, thanks.
02:21:37 <ProfTeggy> Moin
02:34:09 <dsacode> Hello! What is monad? :) Is there some good understandable definition?
02:34:32 <twb> Yes.
02:34:38 <twb> FSVO "understandable"
02:34:39 <dsacode> Is it some functor F, so for some category M, F: M -> M
02:34:52 <dsacode> is it right definition?
02:34:59 <twb> I don't know.
02:35:35 <dsacode> twb: May be you can give me link to some reference?
02:35:42 <sethk> dsacode, it isn't that simple, by a long shot.  There are several stabs at defining it in the wiki
02:36:02 <triplah> monads are a lot more complicated than that
02:36:03 <triplah> :P
02:36:07 <dsacode> :(
02:36:24 <triplah> http://en.wikipedia.org/wiki/Monad_(functional_programming)
02:36:48 <sethk> dsacode, I was thinking about the haskell wiki, but that one is good too.
02:38:30 <ski> good morning,#haskell
02:38:42 <twb> How do I define a datatype "Point" of integer * integer?
02:39:05 <ski> data Point = P Integer Integer
02:39:16 <twb> And the constructor is P?
02:39:22 <ski> (Integer is bignum, Int is fixnum)
02:39:23 <ski> yes
02:39:45 <twb> Looks funny without the *'s.
02:39:53 <ski> it curried
02:40:02 <ski> P :: Integer -> Integer -> Point
02:40:02 <twb> Ah.
02:40:12 <ski> if you do
02:40:13 <twb> That's an interesting way of thinking about it.
02:40:20 <triplah> lo ski 
02:40:20 <ski> data Point = P (Integer,Integer)
02:40:23 <ski> you get
02:40:28 <ski> P :: (Integer,Integer) -> Point
02:40:29 * twb nods.
02:40:36 <twb> Which is how SML does it.
02:41:00 * ski actually thinks the syntax for tuple-types in haskell is a bit illchosen
02:41:02 * ski nods
02:41:32 <ski> (also, constant constructors are just a curried constructor with zero args)
02:41:38 <triplah> yep i dont like it
02:41:45 <triplah> but its a small gripe
02:41:47 <triplah> :P
02:41:53 <twb> data Point = P Integer Integer
02:41:53 <twb> at_point grid (Point x y) = (grid !! x) !! y
02:42:02 <twb> Have I got the parameter list right?
02:42:16 <ski> at_point :: [[a]] -> Point -> a
02:42:21 <ski> yes
02:42:26 <ski> @type (!!)
02:42:27 <lambdabot> forall a. [a] -> Int -> a
02:42:29 <twb> Hooray!
02:42:29 <ProfTeggy> It's probably due to Haskell's syntax principle of using few noise characters (cf. the offside rule)
02:42:30 <triplah> its not P x y ?
02:42:34 <ski> um
02:42:44 <twb> Oh.
02:42:46 <ski> triplah : yes, youäre right
02:42:57 <ski> at_point grid (P x y) = (grid !! x) !! y
02:43:00 <twb> Eek, funny apostrophe.
02:43:09 <twb> "you\344re"
02:43:10 <ski> oh
02:43:11 <triplah> yeah
02:43:13 <ski> s/ä/'/
02:43:19 <triplah> youäre
02:43:25 <triplah> almost you are
02:43:26 <triplah> :)
02:43:34 <twb> Bet you're using latin-1 or something.
02:43:40 * twb hugs utf-8
02:43:50 <ski> 'Point' is the type constructor, lives in type-land, 'P' is the data constructor, lives in value-land
02:44:02 * ski doesn't know what he's using
02:44:09 <twb> ski: do they have a separate namespace?
02:44:13 <ski> yes
02:44:14 <triplah> env | grep LC
02:44:22 <ski> you can, if you want to, do
02:44:25 <triplah> woop
02:44:27 <triplah> that gives nothing
02:44:28 <twb> So why not have "data Point = Point Integer Integer"?
02:44:28 <triplah> :)
02:44:34 <ski> data Point = Point Integer Integer
02:44:41 <ski> some people like that
02:44:44 <twb> Since it's not a disjoint type.
02:44:56 <triplah> the only requirement is that it starts with a capital
02:45:04 <ski> it can be confusing sometimes, though mostly to newbies
02:45:34 <ski> also, the module system is such that one can't discarn between those two when deciding what to export
02:45:38 <ski> which is a bit bad
02:45:47 <twb> Oh, that is bad.
02:46:10 <ski> usually, if i can't come up with a better name for the constructor, i do
02:46:15 <ski> data Foo = MkFoo ...
02:46:23 <triplah> yeah i like that
02:46:29 <triplah> makes it clear its a cons
02:46:34 <ski> right
02:46:39 <twb> Bah.
02:46:43 <twb> make-foo.
02:46:46 <ski> if it also has just one arg, one can do
02:46:53 <triplah> needs to be Make-foo
02:47:00 <ski> data Foo = MkFoo {unFoo :: X}
02:47:01 <twb> make-foo = (:)
02:47:02 <triplah> capital
02:47:06 <twb> Hee hee.
02:47:06 <ski> MkFoo :: X -> Foo
02:47:12 <ski> unFoo :: Foo -> X
02:47:42 <ski> (often, then, one uses 'newtype' instead of 'data')
02:48:20 <triplah> data SchemeList = EmptyList | Cons a (Cons a)
02:48:26 <ski> no
02:48:32 <twb> Indeed.
02:48:39 <ski> data SchemeList = EmptyList | Cons a (SchemeList a)
02:48:40 <triplah> Cons a (List a)
02:48:43 <twb> Scheme lists are heterogeneous.
02:48:44 <triplah> yeah
02:48:57 <ski> think of the syntax like a BNF, only each arm tagged with a constructor
02:48:59 <tic|school> so then SchemeList b?
02:49:10 <ski> 'b' ?
02:49:51 <twb> Say I have a type like "data Word = W Int (Int -> Int) Int"...
02:50:01 <ski> m-m
02:50:02 <twb> Is there a convention for labelling the slots with meaningful names?
02:50:33 <ski> no special convention .. you could invent some based on what the fields are supposed to denote
02:50:43 <twb> Icky.
02:51:06 <triplah> nothing will ever be a syntactically clean as scheme :P
02:51:07 <ski> (iirc ocaml e.g. has a convention for named arguments .. i don't know of any similar convention in haskell)
02:51:46 <twb> What's the equivalent nomenclature to "foo->bar" in Scheme?
02:51:49 <twb> foo2bar?
02:52:07 <ski> well, one convention i can think of .. a list of stuff (or sometimes even another collection), is often denoted by adding plural 's' to the name for the individual elements
02:52:12 <triplah> i've forgotten what -> does in scheme :\
02:52:17 <twb> triplah: nothing.
02:52:19 <ski> nothing
02:52:22 <twb> triplah: it's part of the name.
02:52:29 <ski> @hoogle ST s a -> IO a
02:52:30 <twb> e.g. string->list
02:52:30 <triplah> ahh
02:52:30 <lambdabot> Control.Monad.ST.Lazy.stToIO :: ST RealWorld a -> IO a
02:52:30 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
02:52:30 <lambdabot> System.Exit.exitFailure :: IO a
02:52:40 <ski> stToIO
02:52:48 <ski> i think some ppl have used '2', too
02:53:03 <twb> Okie.
02:53:05 <triplah> enumFromTo
02:53:08 <triplah> etc
02:53:14 <ski> that's not same thing
02:53:32 <ski> that's 'from' and 'to' as lower and upper bound
02:53:44 <triplah> yep
02:53:47 <ski> hm, also
02:53:54 <ski> @type fromIntegral
02:53:55 <lambdabot> forall b a. (Num b, Integral a) => a -> b
02:54:01 <triplah> oh, sorry thought u were talking about conventions in general
02:54:04 * triplah should read better
02:54:05 <ski> @type toRational
02:54:06 <lambdabot> forall a. (Real a) => a -> Rational
02:54:13 <twb> Is SML's "local" still called "local" in Haskell?
02:54:31 <Lor> There is no such thing in Haskell.
02:54:36 <twb> Gasp.
02:54:37 <ski> sadly
02:54:39 <twb> That's terrible!
02:54:42 <beelsebob_> anyone know of a *permissive* html parser for haskell?
02:54:53 <Lor> It's handy, but not very essential, imho.
02:54:54 * ski often misses 'local'
02:55:11 <Lemmih> What's 'local'?
02:55:30 <twb> Why isn't there an HRFI for it?
02:55:33 <tic|school> isn't it let?
02:55:36 <ski> declare local declarations, over *declarations*
02:55:37 <tic|school> or where?
02:55:43 <twb> tic|school: no, the semantics are different.
02:55:48 <tic|school> twb, k
02:55:52 <ski> 'let' declare local declarations, over *expression*
02:56:03 <ski> where is similar to let
02:56:13 <ski> local
02:56:17 <twb> local x = 3 in plus3 = (+ 3) end
02:56:18 <ski>   my local definitions ...
02:56:23 <lisppaste2> triplah annotated #14223 with "align" at http://paste.lisp.org/display/14223#2
02:56:28 <twb> Would make plus3 visible at the top level.
02:56:38 <ski> in my visible definitions, which may use the local ones ...
02:57:10 <triplah> let and where are sugar for lambda, or was local like that in SML too?
02:57:23 <twb> triplah: local is different.
02:57:32 <triplah> ahh ok
02:57:38 <twb> triplah: FWIW scheme has no local, either.
02:57:39 <triplah> actual declarations then i guess
02:57:43 <ski> local is lightweight hiding of some declarations
02:57:54 <twb> triplah: local + define gives you something similar to let + defun in Common Lisp.
02:58:04 <ski> one can simulate it with returning a tuple, but it's a bit tedious
02:58:10 <twb> i.e. with the let outside the defun.
02:58:27 <triplah> hmm ok
02:59:09 <twb> Although on reflection the most obvious use cases are all non-functional.
02:59:10 <ski> i guess the stuff i most miss from the MLs, in haskell, is the module system, with signatures and functors, etc, and 'local'
02:59:59 <ski> twb : sometimes one wants to define a couple of mutually recursive functions, which all should access some local helper definitions
03:00:22 <twb> Yeah.
03:00:43 <twb> To which the hard-core people will probably say that the local helper functions should be put in a separate module .
03:01:08 <ski> depends on how much they can stand on their own, i think
03:01:44 <triplah> scheme is typeless until runtime isnt it? there arent any declarations as such
03:02:00 <ski> scheme is 'dynamically typed'
03:02:08 <triplah> yep
03:03:08 <ski> which means there are no static / compile-time type checks .. but there are run-time "tag" checks, which makes it 'strongly typed' (unlike e.g. C)
03:03:21 <triplah> i get the distinct feeling i'm not get anywhere close to finishing this assignment by monday :(
03:03:44 <ski> what is the assignment about ?
03:03:52 <Saulzar> Any assignment can be done in 2 days :)
03:03:58 <twb> The airspeed velocity of unladen swallows.
03:03:58 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
03:04:02 <triplah> Saulzar: i beleived that once
03:04:20 <triplah> ski:  its doing string matching,
03:04:27 <triplah> sounds simple yes :)
03:04:31 <twb> triplah: he never said you could do it *well* in 2 days.
03:04:40 <triplah> using dynamic programming. ie using lazy evaluation
03:04:47 <triplah> twb: heh :D
03:04:59 <ski> twb : heh .. african or european swallows ?
03:05:09 <triplah> http://paste.lisp.org/display/14223#2
03:05:15 <triplah> i'm up to task 6
03:27:12 <ADEpt> triplah: need hints? :)
03:27:28 <triplah> ADEpt: i've been ripping my hair out over this for days
03:27:34 <triplah> aynthing wll make me happy
03:27:35 <triplah> :)
03:30:52 <triplah> :(
03:31:08 <ADEpt> triplah: first, what is align "" "" ?
03:31:14 <ADEpt> then, align "x" ""?
03:31:21 <ADEpt> then, align "" "y"?
03:31:36 <triplah> those parts of my code i guessed
03:31:39 <triplah> which is bad
03:31:41 <triplah> :)
03:31:42 <ADEpt> cool
03:31:46 <ADEpt> then ...
03:31:52 * ADEpt needs a moment
03:32:56 <ADEpt> triplah: then, what's the result of aling "x" "" and align "x" "y" ?
03:33:42 <triplah> align "x" "" would be ("x",[]) i think
03:35:06 <ADEpt> triplah: and align "x" "y" ?
03:35:18 <triplah> align "x" "y" would be [("x-","y-"),("-x","-y"),("-x","y-"),("x-","-y")]
03:35:28 <kosmikus> stefanw: how did your thesis presentation go?
03:35:59 <triplah> ADEpt: no order is required
03:36:13 <triplah> no ordering of the pairs anyway
03:37:46 <ADEpt> then why attach "x" "" is not [("x","-")] or something?
03:37:58 <triplah> eeep
03:38:00 <triplah> i missed those
03:38:33 <triplah> align "x" "y" would be [("x","y"),("x-","y-"),("-x","-y"),("-x","y-"),("x-","-y")]
03:38:51 <triplah>  [("x","-")] is not valid because it needs at least one y
03:38:55 <triplah> i think
03:39:03 <stefanw> kosmikus
03:39:14 <stefanw> kosmikus: good, thanks
03:42:45 <tromp> ("x-","y-") makes no sense
03:42:58 <triplah> why not?
03:43:01 <tromp> there's no point in having a "-" aligned with a "-"
03:43:12 <tromp> they should both disappear
03:43:28 <triplah> ahh you are right
03:43:41 <tromp> you only insert gaps to pair with non-gaps
03:43:53 <ADEpt> triplah: then, could you produce all possible insertions of space into given string?
03:44:05 <triplah> argh, i fear my attempt at understanding a solution is becomeing worse and worse :P
03:44:46 <tromp> align "x" "y" would be [("x","y"),("x-","-y"),("-x","y-")]
03:44:50 <triplah> hmmm
03:44:56 <triplah> yes
03:45:36 <triplah> *Main> align "x" "y"
03:45:37 <triplah> [("x","-y"),("-x","y"),("x","y"),("x","y-"),("x-","y")]
03:45:39 * ski remembers he used Nothing for the gaps
03:45:41 <triplah> i get that at the moment
03:47:06 * ski tries to recall his array-based solution
03:47:19 <tromp> i'd prefer another representation though
03:47:27 <triplah> i've got an attempt at a list based one but its wrose
03:47:31 <triplah> worse
03:47:40 <triplah> i'll get the inefficient one done first, then do the dynamic one
03:48:25 <tromp> instead of ("x-","-y"), i'd use [('x','-'),('-','y')]
03:49:02 <tromp> that would make the definition of an alignment score somewhat easier
03:49:13 <ski> but doesn't he needs variable length ?
03:49:18 <ski> s/needs/need/
03:49:25 <triplah> yes
03:49:26 <ski> hm
03:49:27 <ski> ah
03:49:28 <tromp> that is variable length
03:49:33 <ski> you transposed
03:49:38 <tromp> yes
03:50:36 <tromp> of course you could zip your repr to get this one...
03:50:42 <kosmikus> stefanw: great, so do you have your degree now, or do you still have to do an exam?
03:50:57 <triplah> instead of doing lots of appending, i should probably use guards? then have multiple recursion within each guard?
03:50:57 <tromp> so it prolly doesn't matter much:9
03:51:25 <ski> (tromp : yes, when other things stay the same, using representation that doesn't enable bad values is better)
03:51:47 <stefanw> kosmikus: yes, I'm a Dipl. Inf. now!
03:51:56 <ski> triplah : is #2 the current version ?
03:52:06 <kosmikus> stefanw: congratulations!
03:52:15 <ADEpt> triplah: i look at you pasted code, and say, why do you concat alternatives in such a hard way?
03:52:16 <tromp> mine still allows you to insert the bad ('-','-'). it just stands out more:)
03:52:25 <triplah> ski: yes, but i think i'm going to try something completely different
03:52:39 <kosmikus> stefanw: what are you going to do next?
03:52:42 <triplah> ADEpt: yeah i think i need to change that
03:52:58 <ADEpt> triplah: do you agree that solution have to be recursive?
03:53:18 <ski> what is attachHeads ?
03:53:21 <triplah> ADEpt: so much that that the whole point of this question is to use dynamic programming
03:53:24 <triplah> :P
03:53:27 <stefanw> kosmikus: I got a position here in FR
03:53:28 <triplah> thats in #1 ski 
03:53:37 <triplah> er
03:53:38 <triplah> #0
03:53:50 <ski> m, right
03:54:14 <ski> attachHeads is a map
03:54:41 <triplah> yes
03:54:53 <ADEpt> triplah: maybe you should map over results of align? ...
03:55:00 <triplah> i dont think i'm using it properly
03:55:03 <triplah> which is part of the problem
03:55:12 <ski> hm 'align (x:xs) [] = []' ?
03:55:12 <ADEpt> triplah: exactly
03:55:18 * ADEpt got align working
03:55:31 <triplah> ski: the base cases are me just putting something there to get it to run
03:55:32 <ADEpt> ski: right, it is
03:55:39 <lisppaste2> Muad_Dib pasted "COmpiling errors?" at http://paste.lisp.org/display/14225
03:55:52 <Muad_Dibber> guys, errors like these: ghc27495.hc:(.text+0x1878): undefined reference to `ControlziMonadziState_zdfMonadStates_closure
03:56:00 <Muad_Dibber> are those ghc errors, or program errors?
03:56:05 <Lemmih> Muad_Dibber: Add --make or -package mtl
03:56:05 <ski> ADEpt : it is what ?
03:56:13 <ADEpt> ski: it is []
03:56:23 <Muad_Dibber> Lemmih: sorry?
03:56:33 <ski> ADEpt : but should it be [] ?
03:56:45 <Lemmih> Muad_Dibber: You're using functions from the mtl library which you must link with.
03:56:47 <ADEpt> ski: sorry?
03:56:58 <tromp> only align [] [] shld be []
03:57:04 <ski> yeah
03:57:10 <Muad_Dibber> Lemmih : you mean to the ghc
03:57:16 <ski> Muad_Dibber : yes
03:57:17 <Muad_Dibber> (i'm using a make file from someone else
03:57:20 <ADEpt> ski: ah. me bad. yes, you are right
03:57:50 <Lemmih> Muad_Dibber: Indeed. Aren't those errors from GHC?
03:57:51 <ski> in fact, you don't need to recurse to end of one list when other is empty .. just map over the other list
03:57:56 <triplah> align (x:xs) (y:ys) = attachHeads xs ys (do stuff with align here)
03:57:59 <phys_rules> @where fps
03:57:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:58:01 <triplah> something like that?
03:58:03 <Muad_Dibber> yes Lemmih 
03:58:09 <ADEpt> triplah: yes
03:58:28 <Muad_Dibber> its kinda a dumb question
03:58:41 <Muad_Dibber> more or less driven by the fact i was looking at HC_OPTS in the makefile :P
03:58:45 <ski> triplah : no
03:58:50 <ADEpt> triplah: suppose that you have align "xx" "yy" working. How can you use that to produce align "xxx" "yyy", using only attachHeads as a tool?
03:59:14 <ADEpt> triplah: rather, align (x:xs) (y:ys) = attachHeads x y (...)
03:59:27 <ADEpt> triplah: not attachHeads xs ys ...
03:59:38 <ski> triplah : you are enumerating all solutions, instead of just returning the best, currently ?
03:59:47 <triplah> ski: thats right
03:59:49 <triplah> all of them
03:59:58 <tromp> align (x:xs) (y:ys) = <matchxy> ++ <xgap> ++ <gapy>
04:00:00 <ski> then use list monad, easier to read
04:00:11 <tromp> just fill in the <...>
04:00:45 <ski> tromp : yes
04:00:50 <ADEpt> tromp: he already did _almost_ that ... http://paste.lisp.org/display/14223#2
04:01:31 <ski> hm
04:01:34 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)
04:01:37 <triplah> so something like that?
04:01:43 <ADEpt> triplah: yes.
04:01:44 <ski> that is one case
04:01:46 <triplah> then use my base cases to construct the pair structure?
04:01:55 <ADEpt> triplah: except that there is two more cases
04:02:02 <ski> you need to generate for the two other cases, too
04:02:05 <triplah> align (x:xs) [] = []
04:02:07 <triplah> align [] (y:ys) = []
04:02:10 <triplah> changing the [] of course
04:02:11 <ski> no
04:02:13 <ski> right
04:02:13 <ADEpt> triplah: no
04:02:24 <ski> change that now, i suggest
04:02:35 <triplah> do i still need this too? align [] [] = []
04:02:38 <ski> a map should suffice
04:02:38 <ADEpt> triplah: you need to more cases of attachHeads application _inside_ align (x:xs) (y:ys)
04:03:03 <ski> triplah : that will be handled by the two other, if you s/(x:xs)/xs/ and s/(y:ys)/ys/
04:03:05 <ADEpt> triplah: ... _two_  more ... (stupid typos)
04:03:26 <triplah> align (x:xs) [] = attachHeads x []
04:03:28 <triplah> align [] (y:ys) = attachHeads [] y
04:03:28 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)
04:03:40 <triplah> i still need an extra arg for attachHeads
04:03:41 <ski> base cases are still wrong
04:03:44 <ADEpt> triplah: and where you will put attachHeads x '-' ?
04:03:49 <triplah> eep :)
04:04:01 <triplah> the base cases are really what has stuff me around with  this question
04:04:11 <triplah> how the hell can you do recursion without understanding the base cases
04:04:35 <ADEpt> triplah: base cases should be about basic (short) strings
04:04:52 <ski> triplah : either you do base cases with a map, as i suggested, or you do it with explicit recursion down to the 'align [] []' case
04:05:08 <Muad_Dibber> whoops, now i get wx haskell linking errors me thinks
04:05:19 <ADEpt> ski: i think explicit recursion is simplier to get
04:05:28 <ski> hm, yes
04:05:34 * ADEpt is off
04:05:40 <ski> in this case, since he's generating all solutions
04:05:41 <triplah> i guess i dont completely understand what my base cases are doing yet
04:05:53 <lisppaste2> Muad_Dib annotated #14225 with "Some more errors" at http://paste.lisp.org/display/14225#1
04:05:56 <ski> first think what they should do
04:05:58 <ski> then code that
04:06:07 <Muad_Dibber> anybody knows about that? :P
04:06:13 <ski> what should 'align "xyz" ""' return, e.g. ?
04:06:14 <triplah> i've been trying to figure that out for ages :D
04:06:20 <tromp> triplah seems to be very confused:(
04:06:28 <triplah> yeah :(
04:06:46 <ski> well, it's no point it matching '-' with '-' agree ?
04:06:54 <triplah> right
04:07:16 <tromp> just try to spell out align (x:xs) (y:ys) = <matchxy> ++ <xgap> ++ <gapy>
04:07:28 <ski> so, you have to add '-'s to the second string, matching the chars in the first, and not inserting any in the first '-' (and stopping when it stops)
04:07:51 <ski> align "xyz" "" = [("xyz","---")]
04:07:56 <triplah> align "xyz" "" would be [("xyz","---")]
04:07:57 <ski> is the wanted result
04:08:00 <triplah> bah :P
04:08:04 <ski> :)
04:08:27 * ski still thinks this would be easier to write and understand, using list-monad
04:08:40 <phys_rules> Muad_Dibber: build for different versions maybe ?
04:08:44 <phys_rules> built
04:09:03 <triplah> ski: lemme understnad this way first :D
04:09:07 <triplah> understand*
04:09:08 <ski> ok
04:09:30 <ski> (btw, coding in list monad resembles a lot coding with backtracking in prolog :)
04:09:39 <triplah> ahh nice
04:09:48 <triplah> ok quick, lets do this i wanna see the monad
04:09:51 <triplah> :D
04:10:00 <ski> (in prolog you'd have three recursive clauses, one for each case, right ?)
04:10:17 <Muad_Dibber> phys_rules : what do you mean? wxhaskell built for another version of gtk?
04:11:11 <triplah> yeah
04:11:15 <ski> align :: [Char] -> [Char] -> [([Char],[Char])]
04:11:22 <triplah> lemme test this
04:12:08 <Muad_Dibber> but that would be weird, since i just build wxhaskell
04:12:16 <triplah> align [] [] = []
04:12:18 <triplah> align (x:xs) [] = attachHeads (x:xs) "-" (align xs [])
04:12:18 <triplah> align [] (y:ys) = attachHeads "-" y (align [] ys)
04:12:18 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)
04:12:29 <ski> that has type errors, i think
04:12:33 <triplah> it does
04:12:43 <ski> in second clause
04:13:00 <phys_rules> Muad_Dibber: more like diff. version of ghc
04:13:12 <ski> (triplah : see the mistake ?)
04:13:13 <phys_rules> Muad_Dibber: but if you say you just built it, that's weird..
04:13:22 <kosmikus> stefanw: at the university, with peter? is it matthias' position?
04:13:31 <triplah> yep
04:13:36 <triplah> trying to pass a list
04:13:55 <ski> second and third clauses should be symmetric, i think
04:14:02 <ski> (or at least almost)
04:14:03 <triplah> yes
04:14:08 <triplah> *Main> align "x" "y"
04:14:09 <triplah> []
04:14:11 <triplah> uh oh
04:14:12 <triplah> :)
04:14:32 <tromp> your case align (x:xs) (y:ys) = attachHeads x y (align xs ys) is wrong
04:14:52 <tromp> that is only the <matchxy> part
04:14:59 <ski> yes
04:15:08 <ski> but does that explain why he got 0 solutions ?
04:15:33 <triplah> i still see no construciton of pairs
04:15:37 <triplah> so i must need to do that
04:15:41 <tromp> no
04:15:42 <ski> attachHeads
04:15:49 <triplah> oh of course
04:15:51 <tromp> the reason he got 0 solutions, is that
04:15:56 <tromp> align [] [] = [[]]
04:15:57 <ski> ah
04:15:58 <ski> yes
04:16:04 <ski> just saw that, too
04:16:08 <ski> hm
04:16:13 <ski> type error
04:16:27 <ski> slightly wrong
04:16:29 <tromp> align [] [] = [("","")]
04:16:32 <ski> yes
04:16:36 <ski> better
04:16:43 <tromp> the empty alignment:)
04:16:56 <tromp> i was thinking about my own representation:(
04:17:07 <ski> it shouldn't fail at base case, it should succeed with the empty alignment :)
04:17:32 <triplah> hmmm
04:17:41 * vincenz waves at ski
04:17:42 <ski> triplah : understand ?
04:17:51 <triplah> so i need to fix my align (x:xs) (y:ys)
04:17:58 * ski smiles at vincenz
04:18:00 <triplah> the base case, yes i understand that
04:18:13 <triplah> i keep wanting to give an extra arg and do prolog style stuff
04:18:15 <triplah> :)
04:18:22 <Muad_Dibber> phys_rules : exactly
04:18:25 <ski> you return the result
04:18:32 <ski> otherwise this is very prolog-like
04:18:44 <triplah> align x y l ... build l up
04:18:45 <ski> (even more, if using monad syntax)
04:18:48 <triplah> then return it at the base case
04:18:50 <vincenz> crap no highlighting
04:18:58 <Muad_Dibber> maybe kosmikus knows if there are problems using wxhaskell 0.9.4 with ghc-bin 6.4 on amd64?
04:19:37 <tromp> here's a nice exercise:
04:19:51 <tromp> define a function countalign n
04:20:07 <tromp> for the number of alignmnents of 2 length-n strings
04:20:11 * ski remembers what the assymmetry between the two strings was, at least in his laboration
04:20:29 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)++(align xs ['-'])++(align ['-'] ys)
04:20:34 <ski> tromp : 'alignment' in the above sense ?
04:20:54 <tromp> yes, the length of the align list
04:21:01 <ski> triplah : almost
04:21:18 <triplah> *Main> align "xx" "yy"
04:21:20 <triplah> [("xx","yy"),("x-","y-"),("x-","y-"),("x","-"),("-","-"),("-","-"),("-","y"),("-","-"),("-","-")]
04:21:21 <triplah> woops :)
04:21:24 <triplah> ehe
04:21:30 <ski> tromp : yes that is an interseting idiom .. i thought of it in the context of another problem some weeks ago
04:21:58 <ski> (tromp : would be nice if a logic programminf language could compute this (efficiently) automatically, for predicates)
04:22:27 <triplah> counting the number of permutaions would be hard in prolog?
04:22:33 <triplah> permutations*
04:22:43 <vincenz> ski: assymetry?
04:22:44 <ski> triplah : in the two other cases, you are throwing away x,y,ys, respectively x,y,xs
04:22:49 <twb> No "end" needed in Haskell "let"s, right?
04:23:09 <ski> triplah : well, no, but it'd be nicer if one didn't have to change the code, just call it in a different way
04:23:16 <triplah> ahh yeah
04:24:03 <vincenz> Anyone an irssi expert?
04:24:28 <triplah> hmmm
04:24:35 <ski> vincenz : yes .. in my laboration, we should match a pattern against some substring of a given string .. so we could cut off arbitrary prefix and suffix of that string .. so the substring we should match against should never have to be modified by inserting gaps at beginning, nor end
04:24:45 <ski> twb : right
04:24:49 <triplah> vincenz: nope, but i wouldnt mind doing some scripting for it
04:25:36 <ski> triplah : look at your two last cases, .. e.g. the recursive calls are worng
04:26:16 * ski recalls even more of how he solved this :)
04:26:22 <triplah> lol
04:26:31 <triplah> do i need to use attachheads?
04:26:35 <triplah> no thats not right
04:27:24 <triplah> argh :)
04:28:22 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)++(align xs ('-':ys))++(align ('-':xs) ys)
04:28:25 <triplah> that seems ok
04:28:27 * triplah checks more
04:28:39 <triplah> no
04:28:41 <kosmikus> Muad_Dibber: should there be? ;)
04:28:43 <triplah> its not right at all
04:28:45 <lisppaste2> twb pasted "example of when local would be helpful" at http://paste.lisp.org/display/14226
04:29:06 <Muad_Dibber> http://paste.lisp.org/display/14225#1 <- i hope not, then its just me
04:29:21 <Muad_Dibber> i'm doing a re-emerge of wxhaskell using -u now, see what it updates and if that helps
04:29:39 <ski> triplah : you should not add '-' to args of recursive call
04:29:39 <triplah> check useflags?
04:29:55 <ski> you should add them with attachHeads
04:30:07 <triplah> ski: ahh, i do that alread in  the other clauses
04:30:09 <triplah> duh
04:30:32 <triplah> argh
04:30:33 <ski> this last haskell clause is like three combined prolog clauses
04:30:41 <triplah> nope thats not right either
04:30:51 <ski> (separated with '++' which here corresponds to ';', i.e. 'or')
04:31:21 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)++(align xs [])++(align [] ys)
04:31:24 <triplah> thats not right either
04:31:26 <triplah> hrmph
04:31:36 <ski> look
04:31:59 <ski> either you match x against y (gives a match or a mismatch), and continue with xs and ys
04:32:01 <kosmikus> Muad_Dibber: no idea right now
04:32:11 <ski> or you match ? with ? and continue with ? and ?
04:32:12 <ski> or you match ? with ? and continue with ? and ?
04:32:17 <ski> fill in the '?'
04:33:36 <triplah> so i DO use attachHeads again
04:33:40 <ski> yes
04:34:06 <ski> you need that to add stuff in front of each solution returned
04:34:13 <reddi> hi, i want to have the following line correct: Main> [x|x<- (map snd [(1,[2,5]),(2,[1,3,3,4]),(3,[2]),(4,[2,5]),(5,[1,4,5])] )  ]
04:34:13 <reddi> [[2,5],[1,3,3,4],[2],[2,5],[1,4,5]]   
04:34:27 <Muad_Dibber> kosmikus : if it still wont work after re-emerging i'll bother you lot in here again
04:34:34 <ski> (or you could use a list-comphrehension (or map) directly in this clause .. or you could use list-monad :)
04:34:36 <reddi> the problem is, that i want as an output  [[2,5],[1,3,4],[2],[2,5],[1,4,5]]  and i dont know where to put the nub
04:34:53 <reddi> cause i dont want to eliminate [2,5] (it occours twice)
04:35:04 <ski> x|x<- (map snd [(1,[2,5]),(2,[1,3,3,4]),(3,[2]),(4,[2,5]),(5,[1,4,5])])]
04:35:05 <triplah> align (x:xs) (y:ys) = attachHeads x y (align xs ys)++attachHeads x '-' align xs (y:ys) ++attachHeads '-' y align (x:xs ys) 
04:35:06 <ski> is the same as
04:35:12 <ski> map snd [(1,[2,5]),(2,[1,3,3,4]),(3,[2]),(4,[2,5]),(5,[1,4,5])]
04:35:38 <ski> (um, s/x|/[x|/)
04:35:40 <reddi> ski: this expression results cause i wanted to use nub
04:35:51 <reddi> somewhere in the list comp.
04:36:00 <ski> reddi : you don't need list comrpehension, just use nub there directly
04:36:02 <reddi> but the only result i got is an elimination of [2,5]
04:36:12 <ski> hm
04:36:14 <ski> aha
04:36:16 <ski> sorry, i misread
04:36:26 <ski> yes, you want a list compr.
04:36:32 <reddi> i only want to eliminate the double 3
04:36:37 <ski> use it to the left of '|'
04:36:37 <reddi> in [1,3,3,4]
04:36:52 <reddi> FINE
04:36:53 <ski> i.e. in the expr to return for each way of choosing
04:36:56 <reddi> LOL
04:36:59 <reddi> that is cool
04:37:04 <reddi> that works ;-)
04:37:26 * ski thought you wanted to remove duplicate lists .. but you wanted to remove duplicate elements, for each list
04:37:33 <tromp> [(a, nub b)|(a,b)<-list]
04:37:35 <triplah> works ski :)
04:37:38 <triplah> weee!
04:37:44 <ski> triplah : yes, that looks fine, except syntax error
04:37:55 <reddi> i did not know that i can give results on the left side ;-)
04:37:58 <twb> What does snd do?   Is it like #2 in SML?
04:38:12 <tromp> parenthesize, triplah
04:38:16 <triplah> ski: yeah i fixed the syntax stuff
04:38:18 <tic|school> twb, snd (a, b) = a
04:38:21 <ski> reddi : you can type arbitrary expression there, e.g. using variables defined on the right of '|'
04:38:29 <tic|school> err
04:38:31 <tic|school> make that = b
04:38:32 <tic|school>  :)
04:38:36 <twb> Is there an equivalent to SML's #?
04:38:37 <ski> triplah : do you want to see the list-monad version ?
04:38:37 <triplah> hehe tic|school 
04:38:45 <triplah> ski: hell yes :)
04:38:46 <twb> i.e. select the nth slot in a tuple.
04:38:50 <tic|school> twb, there's only fst and snd defined.
04:38:56 <twb> Bummer.
04:39:16 <tic|school> twb, you'll have to make a lambda function: (\(_, _, _, x) -> x) nple
04:39:22 <ski> twb : except tuples are not records (there are no real records in haskell, they're half-real)
04:39:32 <twb> ski: okie.
04:39:47 <ski> (this is also a bit unfortunary)
04:39:59 <triplah> haha
04:40:04 <twb> Is there an extension mechanism like SRFI?
04:40:14 <tromp> doesn't some library define liftfst and liftsnd to lift functions into pairs?
04:40:15 <ski> no
04:40:25 <twb> ski: why not?
04:40:43 <ski> twb : there are extensions which are common to impl.s though
04:41:24 <ski> twb : dunno .. (guess nobody have thought of it, or needed it that much, or deemed it necessary, or something ..)
04:41:47 <ski> tromp : 'lift functions into pairs' ?
04:42:05 <ski> @type (Control.Arrow.&&&)
04:42:06 <lambdabot> forall (a :: * -> * -> *) c' c b.
04:42:06 <lambdabot> (Control.Arrow.Arrow a) =>
04:42:06 <lambdabot> a b c -> a b c' -> a b (c, c')
04:42:08 <ski> @type (Control.Arrow.***)
04:42:10 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
04:42:10 <lambdabot> (Control.Arrow.Arrow a) =>
04:42:10 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
04:42:13 <ski> tromp : those ?
04:42:19 <twb> Maybe it's because you've only been around for 20 years :-)
04:42:30 <ski> yeah, could be that
04:43:27 <kosmikus> Muad_Dibber: I'm away for the rest of the day ...
04:43:31 <ski> > ((+10) Control.Arrow.&&& (*3)) 20
04:43:31 <ski> lambdabot: @hello
04:43:31 <tromp> like those, ski
04:43:31 * JaffaCake does the bug squashing dance
04:43:32 <lambdabot> (30,60)
04:43:32 <lambdabot>  @help <command> - ask for help for <command>
04:43:43 <tromp> but trivial to define: liftsnd f (a,b) = (a, f b)
04:43:49 <ski> > ((+10) Control.Arrow.*** (*3)) (20,30)
04:43:50 <lambdabot> (30,90)
04:44:05 <tromp> ah, cool
04:44:13 <ski> > Control.Arrow.left (*3) (20,30)
04:44:14 <lambdabot> Couldn't match `Either b d' against `(a, b1)'
04:44:19 <ski> > Control.Arrow.first (*3) (20,30)
04:44:20 <lambdabot> (60,30)
04:44:25 <ski> > Control.Arrow.second (*3) (20,30)
04:44:27 <lambdabot> (20,90)
04:44:35 <ski> tromp : there you go
04:44:49 <ski> triplah : ok
04:45:07 <ski> align [] [] = [("","")]   -- align([],[],("","")).
04:45:13 <tromp> nice to have instance Arrow (,)
04:45:20 <ski> no
04:45:24 <ski> it's not
04:45:29 <ski> instance Arrow (->)
04:45:30 <ski> 'tis
04:45:42 <ski> triplah : agree ?
04:46:31 <tromp> ah, ok, ski
04:46:59 <ski> align (x:xs) [] = attachHeads x '-' (align xs [])   -- align([X|Xs],[],([X|Xs2],[0'-|Ys2])) :- align(Xs,[],(Xs2,Ys2)).
04:47:13 <twb> Is there a wiki page or similar on unit testing?
04:47:32 <ski> align [] (y:ys) = attachHeads '-' y (align [] ys)   -- align([],[Y|Ys],([0'-|Xs2],[Y|Ys2])) :- align(Xs,[],(Xs2,Ys2)).
04:48:31 <musasabi> twb: you might look up QuickCheck and hunit.
04:48:40 <ski> @where hunit
04:48:40 <lambdabot> http://hunit.sourceforge.net/
04:48:58 <twb> I want something very lightweight.
04:49:30 <triplah> ski: thats with monads?
04:49:39 <ski> http://www.haskell.org/hawiki/UnitTesting
04:49:45 <ski> triplah : not yet
04:49:49 <ski> just comparing with prolog
04:50:03 <twb> Like (defmacro assert (expression) `(format "~[passed~:failed~]: ~s~%" ,expression ',expression))
04:50:05 <triplah> ski: oh yeah, thats how i kept wanting to solve this
04:50:12 <triplah> its just that the assignment spec requires 2 args
04:51:03 <triplah>   | i>0 and j==0 =attachHeads x '-' (alsEntry i 0)
04:51:08 <triplah> something wrong with this guard?
04:51:11 <ski> align (x:xs) (y:ys) = attachHeads x y (align xs ys)
04:51:15 <triplah> cant i check two conditions in a guard?
04:51:25 <ski>                     ++ attachHeads x '-' (align xs (y:ys))
04:51:30 <ski>                      ++ attachHeads '-' y (align (x:xs) ys)
04:51:36 <ski> s/and/&&/
04:51:41 <triplah> oh
04:51:43 <triplah> thanks
04:52:27 <ski> align([X|Xs],[Y|Ys],([X|Xs2],[Y|Ys2])) :- align(Xs,Ys,(Xs2,Ys2)).
04:52:40 <ski> align([X|Xs],[Y|Ys],([X|Xs2],[0'.|Ys2])) :- align(Xs,[Y|Ys],(Xs2,Ys2)).
04:52:52 <ski> align([X|Xs],[Y|Ys],([0'-|Xs2],[Y|Ys2])) :- align([X|Xs],Ys,(Xs2,Ys2)).
04:52:59 <ski> s/0'./0'-/
04:53:17 <ski> this is how your last haskell clause you look in prolog .. three clauses
04:53:32 <ski> s/you/would/
04:53:35 <triplah> yep
04:53:41 <ski> now
04:53:44 <triplah> would it return all possible variants though?
04:53:50 <ski> in prolog, yes
04:53:54 <ski> same as in haskell
04:53:57 <triplah> ahh yep
04:54:03 <ski> by backtracking, in prolog
04:54:10 <ski> compare now with monad solution
04:54:16 <triplah> ok
04:54:22 <ski> align [] [] = do return ("","")
04:54:47 <ski> align (x:xs) [] = do (xs2,ys2) <- align xs []
04:55:08 <ski>                      return (x:xs2,'-':ys2)
04:55:20 <ski> align [] (y:ys) = do (xs2,ys2) <- align [] ys
04:55:27 <ski>                      return ('-':xs2,y:ys2)
04:55:35 <twb> OK, hugs doesn't like ":m +Test.QuickCheck".  What should I be saying?
04:56:01 <ski> twb : Debug.Test.QuickCheck, iirc
04:56:13 <twb> ski: no joy.
04:56:13 <ski> align (x:xs) (y:ys) = do (xs2,ys2) <- align xs ys
04:56:23 <musasabi> twb: with hugs use ":l Test.QuickCheck"
04:56:37 <ski>                          return (x:xs2,y:ys2)
04:56:38 <twb> musasabi: thanks.
04:56:44 <twb> Why :load instead of :module?
04:57:08 <ski>               `mplus` do (xs2,ys2) <- align xs (y:ys)
04:57:10 <triplah> ski: thats pretty damn sexy
04:57:15 <ski>                          return (x:xs2,'-':ys2)
04:57:24 <ski>               `mplus` do (xs2,ys2) <- align (x:xs) ys
04:57:34 <ski>                          return ('-':xs2,y:ys2)
04:57:37 <ski> that's it
04:58:03 <ski> 'mplus' is in Control.Monad
04:58:16 <tromp> that's monadic form of ++
04:58:24 <triplah> ahh
04:58:27 <ski> triplah : you see the better similarity with the prolog version, now ?
04:58:37 <ski> tromp : yes, .. for the list-monad, i.e.
04:58:41 <triplah> lemme just paste this all into vi
04:58:54 <triplah> so i can read it properly
04:59:00 <ski> think of '`mplus`' as ';' in prolog, i.e. 'or
04:59:03 <ski> '
04:59:06 <twb> triplah: you don't use the vi irc client?
04:59:15 <tromp> right, ski, mplus is more general
04:59:24 <ski> align([X|Xs],[Y|Ys],(Xs3,Ys3) :-
04:59:44 <ski>         ( align(Xs,Ys,(Xs2,Ys2)),
04:59:59 <tic|school> twb, is there one?
05:00:03 <ski>           Xs3 = [X|Xs2],Ys3 = [Y|Ys2]
05:00:04 <twb> tic|school: yep
05:00:10 <tic|school> twb, nifty. any good?
05:00:11 <twb> tic|school: maybe just for vim, though.
05:00:15 <tic|school> twb, that's okay, I use vim. :9
05:00:16 <twb> tic|school: I don't know, I use Emacs :-)
05:00:19 <tic|school> eek
05:00:39 <ski>         ; align(Xs,[Y|Ys],(Xs2,Ys2)),
05:00:46 <ski>           Xs3 = [X|Xs2],Ys3 = [0'-|Ys2]
05:00:47 <twb> I also use emacs for mail, news, web browsing, desktop publishing and playing music =D
05:00:48 <triplah> twb: nope, irssi
05:00:56 <ski>         ; align([X|Xs],Ys,(Xs2,Ys2)),
05:01:09 <ski>           Xs3 = [0'-|Xs2],Ys3 = [Y|Ys2]
05:01:11 <ski>         ).
05:01:39 <twb> ski: sorry for interrupting.  Maybe you should lisppaste or something.
05:01:44 <triplah> what does this syntax mean?
05:01:46 <triplah> (xs2,ys2) <- align xs [
05:01:47 <ski> triplah : that is an alternate way of writing the last three prolog clauses as one clause .. which corresponds even better to the haskell clause
05:01:56 <int-e> wee. optAlignment'' 0 2 1 "ilovefunctionalprogramming" "myhovercraftisfullofeels"   runs out of memory fairly quickly - I guess keeping all those intermediate partial words around isn't very clever.
05:02:07 <triplah> ski: some of that prolog is well foreign to me :P
05:02:37 <ski> triplah : here, think of it as "get some arbitrary solution '(xs2,ys2)' from the 'align xs []' call"
05:02:45 <triplah> int-e: did you do it using lists?
05:02:52 <int-e> triplah: yes
05:02:58 <triplah> hmm
05:03:06 <triplah> ski: hah, now that IS like prolog
05:03:13 <ski> :)
05:03:28 <int-e> triplah: there are just too many solutions
05:03:42 <triplah> do monads chew more processor doing wierdo unifications?
05:03:51 <ski> only that you don't return through arguments, but through return value .. and you can't (easily) run things both backwards and forwards
05:03:57 <triplah> int-e: i'll point that out to my lecturer :P
05:03:59 <ski> no unification there
05:04:06 <triplah> ahh ok
05:04:35 <ski> triplah : really, the list-monad solution i wrote does the exact same thing as your solution, only written in another way
05:04:39 <yozora> > (,) 1 2
05:04:40 <lambdabot> (1,2)
05:04:41 <ticVim> hrm, this is weidr.. :)
05:04:42 <triplah> int-e: do propse a better solution?
05:04:47 <yozora> > (,,) 1 2 3
05:04:48 <lambdabot> (1,2,3)
05:04:48 <ticVim> weird, too.
05:04:59 <triplah> vi itc tic?
05:05:02 <triplah> irc*
05:05:09 <ski> triplah : you could also use list-comprehensions
05:05:09 <ticVim> Ah nice, now I get the text too
05:05:22 <ticVim> triplah, yeah, vimirc.
05:05:39 <ticVim> server-list to the left
05:05:49 <triplah> ski: to write a solution?
05:06:01 <ticVim> It seems to miss some of my messages.
05:06:09 <int-e> triplah: mind you, it's possible that I'm doing something foolish that causes solutions to be generated that aren't actually used.
05:06:29 <triplah> which mond do i import to try that list stuff?
05:06:37 <triplah> int-e: ahh :)
05:06:41 <ski> triplah : '[ <foo> | <var> <- <expr> , ... , <test> , ... , ... ]' means same thing as list-monad action 'do {<var> <- <expr>; ... ; guard <test>; ... ; ... ; return <foo>}'
05:06:43 <triplah> monad*
05:07:08 <ski> just import Control.Monad, for 'mplus' .. the basic list monad should already be in scope
05:07:23 <triplah> ahh
05:07:30 <ski> also, just so you know, prolog's 'fail' corresponds to 'mzero' in list-monad
05:07:39 <triplah> ski: how would i write this using monads?
05:07:42 <ski> @type Control.Monad.guard
05:07:43 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
05:07:49 <triplah> eep
05:07:54 <ski> that is also useful
05:07:55 <triplah> lost the one i wanted to try
05:08:01 <ski> lost ?
05:08:18 <triplah> er i had a simple solution for pythag triples here
05:08:24 <triplah> all pythag triples up to n
05:08:33 <ski> in list-compr. ?
05:09:57 <triplah> > let trip n = [(a,b,c) | a <- [1..n], b <- [1..n], c <- [1..n], a*a+b*b==c*c] in trip 25
05:09:58 <lambdabot> [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15)
05:09:58 <lambdabot> ,(12,5,13),(12,9,15),(12,16,20),(15,8,17),(15,20,25),(16,12,20),(20,15,25)
05:09:58 <lambdabot> ,(24,7,25)]
05:10:05 <ski> actually, before do-notation for monads was invented, wadler (i think) suggested extending list-comprehension-syntax to work for all monads :)
05:10:24 <triplah> ski: possible to write that using monads?
05:10:30 <ski> sure
05:10:31 <twb> http://twb.ath.cx/tmp/tmp.hs
05:11:27 <tic|school> twb, thanks for the tip :9
05:11:28 <ski> > let trip n = do {a <- [1..n]; b <- [1..n]; c <- [1..n]; Control.Monad.guard (a*a + b*b == c*c); return (a,b,c)} in trip 25
05:11:29 <lambdabot> [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15)
05:11:29 <lambdabot> ,(12,5,13),(12,9,15),(12,16,20),(15,8,17),(15,20,25),(16,12,20),(20,15,25)
05:11:29 <lambdabot> ,(24,7,25)]
05:11:33 <ski> or, better
05:11:51 <ski> > let trip n = do {c <- [1..n]; b <- [1..c-1]; a <- [1..b-1]; Control.Monad.guard (a*a + b*b == c*c); return (a,b,c)} in trip 25
05:11:52 <lambdabot> [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,
05:11:52 <lambdabot> 24,25)]
05:12:51 <ski> (so you don't get solutions that are same except 'a' and 'b' are swapped, also you never try with 'a' or 'b' greater than 'c')
05:12:57 <ski> triplah : ok ?
05:13:17 <triplah> yeah
05:13:21 <triplah> i'm impressed
05:13:27 <triplah> so this poses the question... why?
05:13:36 <triplah> useless for a trivial example like that i suppose
05:13:45 <ski> guard will fail if it's passed the boolean False, otherwise, if it's passed True, it succeeds
05:13:55 <ski> why what ?
05:14:12 <triplah> why use a monad
05:14:21 <triplah> it seems more complicated than the original
05:14:31 <ski> you don't have to use the somewhat unintuitive attachHeads
05:14:50 <triplah> ahh
05:14:55 <triplah> i meant in general sorry
05:14:58 <ski> you can think more in terms of a single solution at a time, instead of the full list of all solutions at the time
05:15:07 <triplah> hmm i see
05:15:21 <vincenz> let double x = x*x in double 4
05:15:28 * vincenz pokes lambdabot 
05:15:33 <vincenz> > let double x = x*x in double 4
05:15:34 <lambdabot> 16
05:15:36 <vincenz> ah
05:15:50 <vincenz> ski: how does that work?
05:15:54 <vincenz> the monoad thing
05:16:02 <wilx> Magic. :)
05:16:04 <vincenz> I fail to see wher ethe control flow entres in that whole {...} block
05:16:25 <ski> instead of thinking, "i want to map, so i add x to first list in each solution, and '-' to second list in each solution" you think "i add x to the first list and '-' to the second list, (in "the" solution)"
05:16:43 <ski> vincenz : really, not much different from list-comprehensions, in this case
05:16:46 <vincenz> do {a <- [1..n]; b <- [1..n]; c <- [1..n]; Control.Monad.guard (a*a + b*b == c*c); return (a,b,c)}
05:17:07 <vincenz> a <- [1..n] means put that list in a?
05:17:10 <ski> vincenz : let trip n = do {...} in trip 25
05:17:10 <triplah> so for normal use of guards it wouldnt be possible to use monads?
05:17:12 <triplah> like
05:17:19 <dsacode> Hello! What's "thunk"?
05:17:28 <twb> dsacode: the past tense of "think".
05:17:31 <ski> vincenz : no, it means "select some member of this list, and put that in 'a'"
05:17:42 <triplah> a thunk is usually the name given to a local variable that has been called by name
05:17:45 <int-e> triplah: I confirmed my theory; I have a version that stores the alignments in a DAG that describes how to generate them and it's using much less memory now :)
05:17:47 <vincenz> ski: select which?
05:17:49 <triplah> does haskell have thunks?
05:17:56 <ski> vincenz : "any" :)
05:17:58 <triplah> int-e: ehe nice
05:17:58 <tic|school> triplah, implicitly as it's lazy.
05:18:07 <dsacode> twb: sure :) but i saw this in some haskell paper..
05:18:12 <triplah> tic|school: ahh, duh :)
05:18:15 <vincenz> ski: so what if I used that construct elsewhere?
05:18:25 <twb> dsacode: that's why it's called a thunk.
05:18:34 <vincenz> let double x = a <-[1..x]; a*a in double 3
05:18:40 <vincenz> > let double x = a <-[1..x]; a*a in double 3
05:18:41 <lambdabot>  parse error on input `<-'
05:18:44 <ski> vincenz : you have to use that inside do-notation (or list-comprehesion)
05:18:45 <tic|school> twb, interesting, didn't know.
05:18:55 <vincenz> > let double x = do {a <-[1..x]; return a*a} in double 3
05:18:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
05:18:56 <lambdabot>   Expected type: m a
05:18:56 <lambdabot>   Inferred type: a
05:19:08 <ski> > let double x = do {a <-[1..x]; return (a*a)} in double 3
05:19:09 <lambdabot> [1,4,9]
05:19:23 <joelr1> JaffaCake: ping
05:19:27 <joelr1> howdy folsk
05:19:29 <joelr1> folks
05:19:30 <vincenz> > let double x = do {a <-[1..x]; return (a*a)} in double 3
05:19:30 <triplah> so thats also a monad
05:19:31 <lambdabot> [1,4,9]
05:19:34 <triplah> its almost like learning the language again
05:19:36 <triplah> :)
05:19:38 <vincenz> so do {x <-.... is a loop?
05:19:45 <twb> tic|school: SICP is a fountain of knowledge.
05:19:46 <kzm> > let double x = [a*a | a <- [1..x] in double 3
05:19:47 <lambdabot>  parse error on input `in'
05:19:47 <ski> vincenz : no
05:19:56 <ski> vincenz : well
05:20:00 <kzm> > let double x = [a*a | a <- [1..x]] in double 3
05:20:01 <lambdabot> [1,4,9]
05:20:14 <ski> vincenz : think of it as backtracking, if you know any prolog
05:20:16 <triplah> quit with the double!
05:20:21 <triplah> its making my eyes bleed
05:20:23 <vincenz> t> let double x = do {a <-[1..x]; let b = a*a in return (a*a)} in double 3
05:20:24 <twb> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html
05:20:25 <vincenz> ski: I meant how it works
05:20:28 <triplah> at least call it sqr or something
05:20:30 <triplah> :)
05:20:36 <ski> vincenz : see what kzm did, that does same thing, really
05:20:37 <twb> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#footnote_Temp_580
05:20:40 <dsacode> twb: i'm not so familiar with english language.. so I asked for its technical definiton
05:20:45 <vincenz> > let double x = do {a <-[1..x]; let b = a*a in c <-[1..b]; return (c*c)} in double 3
05:20:45 <lambdabot>  Parse error in pattern
05:20:57 <twb> dsacode: see the above chapter.
05:21:05 <triplah> dsacode: i think i said it
05:21:09 <vincenz> ski: never coded haskell :P
05:21:20 <vincenz> just tryiing to figure out what the do {... means SEMANTICALLY
05:21:21 <vincenz> l
05:21:24 <ski> > let double x = concat (map (\a -> [a*a]) [1..x]) in double 3
05:21:25 <lambdabot> [1,4,9]
05:21:33 <ski> vincenz : that is also same thing
05:21:39 <triplah> a thunk is usually the name given to a local variable that has been called by name. its passed toa function and every time it is use it is evaluated in the environment it was declared in
05:21:41 <dsacode> sorry then
05:21:48 <vincenz> ski: I fail to see the reason for concat
05:21:53 <kzm> vincenz, that's easy: it can be transformed to >> and >>= operators.
05:22:05 <ski> > let double x = map (\a -> a*a) [1..x] in double 3
05:22:06 <lambdabot> [1,4,9]
05:22:14 * vincenz grins
05:22:25 <ski> vincenz : not needed here, yes .. but if you did a nondeterministic select afterwards, you need it
05:22:26 <vincenz> ski: and yes that piece of code is obvious (remember? I code ocaml?)
05:22:37 <ski> > let double x = do {a <-[1..x]; let b = a*a; return b} in double 3
05:22:38 <lambdabot>  parse error on input `}'
05:22:46 <triplah> dsacode: in haskell though, params to functions are evaluated until they are used, which is similar but not the same
05:22:51 <ski> > let double x = do {a <-[1..x]; let {b = a*a}; return b} in double 3
05:22:52 <triplah> arent*
05:22:53 <lambdabot> [1,4,9]
05:23:12 <ski> > let double x = do {a <-[1..x]; let {b = a*a}; c <-[1..b]; return (c*c)} in double 3
05:23:13 <lambdabot> [1,1,4,9,16,1,4,9,16,25,36,49,64,81]
05:23:21 <dsacode> triplah: so "thunk" is unevaluated expression in heap?
05:23:22 <ski> vincenz : there you go
05:23:26 <ski> dsacode : yes
05:23:32 <triplah> dsacode: sort of
05:23:37 <vincenz> isn't it let .... IN?
05:23:42 <ski> no in do-notation
05:23:48 <ski> s/no/not/
05:23:48 <dsacode> ok, thanks
05:23:51 <triplah> dsacode: its a pointer to the value in its original environment
05:23:58 <vincenz> blegh haskell
05:23:59 <triplah> but unevaluated it close enough
05:24:06 <ski> vincenz : it's like a toplevel let in ocaml
05:24:17 <triplah> typically a thunk is evaluated every time it is used. which is pretty ineffecient
05:24:21 <triplah> luckily haskell doesnt do that
05:24:28 <dsacode> because it's lazy? :)
05:24:31 <ski> yes
05:24:33 <triplah> yes
05:24:34 <triplah> :)
05:24:35 <ski> because it caches
05:24:36 <dsacode> great :)
05:25:27 <int-e> triplah: (for that example, there are 1160997400 possible alignments - a bit too many to generate them all :)
05:25:58 <triplah> int-e: woah :P
05:26:35 <boegel> @seen astrolabe 
05:26:35 <lambdabot> astrolabe is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
05:26:35 <lambdabot> 6 hours, 5 minutes and 15 seconds ago.
05:26:38 <boegel> hmmz :s
05:27:18 <triplah> ski: i'm going to get as much of this assignment done as possible
05:27:24 <triplah> then im going to return to look at monads
05:27:37 <triplah> and maybe turn some of my assignment into monadic form
05:27:42 <triplah> try impress my lecturer
05:27:42 <triplah> :P
05:27:58 <ski> vincenz : a do-expression consists of "commands"   'do {<expr>}' = '<expr>'  'do {<expr>; ...}' = '<expr> >> do {...}'  'do {<pat> <- <expr>; ...}' = '<expr> >>= \<pat> -> do {...}' (almost)  'do {let {<decls>}; ...}' = 'let <decls> in do {...}'
05:28:44 <ski> triplah : ok, sure :)
05:29:14 <triplah> i have to do the dyname version of align now
05:29:17 <triplah> dynamic
05:29:20 <triplah> i sort of have it
05:29:27 <triplah> something wrong with my recursion though
05:30:11 <lisppaste2> triplah annotated #14223 with "dynamic align" at http://paste.lisp.org/display/14223#3
05:30:55 <ski> twb : because haskell is lazy, you need to make 'accum' strict in it's first argument, to get iterative process (O(1) stack space) in haskell
05:32:14 <ski> twb : optimising compilers can sometimes discover that the first argument will always be forced at end, so could just as well force it already (this is called strictness analysis), but this doesn't always succeed in strictifying all places one'd like to
05:32:32 <ski> twb : so one uses 'seq' and '($!)', to explicitely force stuff
05:32:45 <ski> @type seq
05:32:46 <lambdabot> forall b a. a -> b -> b
05:33:00 <ski> > seq (error "barf !") 42
05:33:01 <lambdabot> barf !
05:33:09 * ADEpt is back
05:33:15 <ADEpt> triplah: want more hints?
05:33:18 <ski> > let seq' a b = b in seq' (error "barf !") 42
05:33:19 <lambdabot> 42
05:33:26 <ski> @type ($!)
05:33:27 <lambdabot> forall b a. (a -> b) -> a -> b
05:33:34 <triplah> ADEpt: 23:33 < lisppaste2> triplah annotated #14223 with "dynamic align" at http://paste.lisp.org/display/14223#3
05:33:37 <triplah> :P
05:33:39 <ski> f $! x = seq x (f x)
05:33:48 <triplah> trying to figure out where my stack overflow is coming from
05:34:16 <ADEpt> triplah: excuse me, but it seems like huge overkill, to go THAT way
05:34:36 <triplah> ADEpt: just filling out the assignment spec :P
05:34:58 <triplah> its meant to be a faster solution too
05:36:10 <ADEpt> triplah: have you though about writing a recursive definition for align with base case 'align "xx" "yy" = [("x-x-","-y-y"),("x--x","-yy-"), ...', and trying it on 'align "xxx" "yyy"'?
05:36:25 <twb> ski: okie
05:37:16 <triplah> ADEpt: hrm ?
05:39:03 <ADEpt> triplah: have you tried to go this way:
05:39:03 <ADEpt> align "xx" "yy" = [("x-x-","-y-y"),("x--x","-yy-"), ... (copy-paste from task description)
05:39:03 <ADEpt> align (x:xs) (y:ys) = some expression featuring attachHeads, 'align xs ys', probably 'align xs (y:ys)' and maybe something else
05:39:03 <ADEpt> , then try align "xxx" "yyy" and see wether it will work as expected.
05:39:11 <ski> twb : otoh, there are new idioms in lazy programming that allows O(1) space usage .. like looping through a lazy list, making sure not to keep any reference to some earlier cons cell (keeping such would keep the list from the point on in memory, instead of GCing it .. this is called a 'space leak' in haskell)
05:39:44 <ski> > let seq' a b = b in (seq' $! (error "barf !")) 42
05:39:45 <lambdabot> barf !
05:40:37 <ADEpt> triplah: then you can replace your base case to 'align [] [] = []' and hope that it will work as well.
05:41:04 <triplah> hmm
05:41:35 <ski> ADEpt : he wants to do dynamic version now ..
05:41:55 <triplah> yep
05:41:59 <triplah> at the moment i want to get this done
05:42:05 <triplah> i can optimise after
05:42:28 <triplah> is there some kinda of tracer / debugger in ghci?
05:42:36 <triplah> i dunno where this stack overflow is coming from :P
05:42:52 <ski> #3 ?
05:43:06 <triplah> yep
05:43:12 * ski looks
05:44:04 <ski> shouldn't alsEntry call als ?
05:44:25 <ski> otherwise, what's the point of making the lists ?
05:44:36 <triplah> dear lord
05:44:41 <triplah> what an oversight
05:44:42 <triplah> haha
05:45:01 <ski> also, should you really do [0..] ?
05:45:10 <ski> no upper bound ?
05:45:14 * ski thinks about that
05:45:23 <triplah> its lazily evaluated
05:45:37 <ski> yes ..
05:45:43 <ski> ok, it could work :)
05:46:01 <triplah> hmm
05:46:04 <ski> is there a reason you don't use an array instead of a list, though ?
05:46:07 <triplah> im still getting a non termination
05:46:19 <triplah> i've only been taught lists at uni
05:46:19 * ski hasn't looked at recursion details, yet
05:46:35 <ski> array indexing is faster than list indexing
05:46:56 <triplah> i didnt even know arrays existed in haskell
05:46:58 <ski> simple to change to arrays
05:47:09 <triplah> do they scale?
05:47:27 <triplah> or do i need to do complex copy operations whenever i run out of space?
05:48:31 <ski> i was thinking of creating one big array, sufficient for storing up to the lengths, in each direction
05:48:44 <ski> you only need to define one array, i think
05:48:56 <triplah> er?
05:49:05 <triplah> then i need to change the table stuff
05:49:08 <ski> (and it'd be defined recursively, like this list is (or will be, if you let alsEntry call als)
05:49:16 <ski> slightly, yes
05:49:26 <ski> @type Data.Array.array
05:49:27 <lambdabot> forall e i.
05:49:27 <lambdabot> (GHC.Arr.Ix i) =>
05:49:27 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
05:49:32 <ski> @type (Data.Array.!)
05:49:33 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
05:51:02 <ski> should i show how to alter alsTable ?
05:52:01 <triplah> hmm
05:52:07 <twb> Does Haskell have SML's "as"?
05:52:09 <triplah> i'll just get this working first i think
05:52:34 <twb> e.g. "f l as (x:xs) = ..."
05:52:35 <ADEpt> triplah: ah! me bad. I missed that you already have recursive solution :((((
05:52:40 <ADEpt> triplah: sorry :(
05:52:48 <triplah> ADEpt: lol no worries :D
05:53:18 <ski> > let f xs@(x:_) = (xs,x) in map f [[1,2,3],[4,5,6],[7,8,9]]
05:53:19 <lambdabot> [([1,2,3],1),([4,5,6],4),([7,8,9],7)]
05:53:26 <ski> twb : see
05:53:46 <int-e> Hah. Type classes are cool. I can generate and count solutions using the same function, and the counting is actually efficient :)
05:54:06 <triplah> haha
05:54:12 <twb> ski: not really...
05:54:13 <ski> int-e : can i see ? :)
05:54:20 <ski> twb : ?
05:54:49 <twb> ski: I don't understand that function.
05:54:49 <int-e> triplah: nah, sorry. It's your assignment, I don't want to give you the solution.
05:55:03 <triplah> int-e: show ski in a PM
05:55:04 <triplah> :P
05:55:10 <twb> Hmm.
05:55:12 <triplah> im not fussed.
05:55:17 <int-e> ski: oh.
05:56:00 <twb> ski: OK, now I get it.
05:56:31 <ski> twb : let fun f (xs as x :: _) = x in map f [[1,2,3],[4,5,6],[7,8,9]] end
05:59:09 <ADEpt> int-e: can I see it as well? :)
06:01:06 <triplah> hmm
06:01:13 <triplah> i think i see the problem with my dynamic one
06:02:14 <triplah> actually, no I don't :)
06:02:19 * triplah quints
06:02:22 <triplah> squints*
06:02:56 <ski> hm
06:03:50 <ski> in the '==0' cases you don't decrement
06:04:39 <ski> @seen kzm
06:04:39 <lambdabot> kzm has changed nick to lambdabot5.
06:04:39 <lambdabot> lambdabot5 is in #haskell-overflow, #flippi, #haskell-blah and #haskell.
06:04:39 <lambdabot> Last spoke 36 minutes and 46 seconds ago.
06:04:58 <triplah> dammit ski 
06:05:00 <kzm> Hi.
06:05:02 <triplah> must be getting too late
06:05:07 <triplah> missing stupid bugs now
06:05:08 <kzm> ski: you called?
06:05:48 <kzm> Sorry if I polluted the channel - I tried to experiment a bit in a different channel, but forgot tho log out of #haskell.
06:06:06 * kzm blushes.
06:06:44 * ski just wondered what necissated that
06:07:03 * kzm just wasn't thinking.
06:07:05 <kzm> Sorry.
06:07:15 * ski wonders how that word is really spelled
06:07:37 * kzm thinks the lambdabot probably has a spellchecker - somewhere.
06:07:41 <kzm> @spell
06:07:41 <lambdabot> No word to spell.
06:07:46 <kzm> @spell necessitate
06:07:57 <kzm> @dispell?
06:07:58 <lambdabot> Unknown command, try @listcommands.
06:08:01 <ski> @help spell
06:08:01 <lambdabot>  @spell <word>, show spelling of word
06:08:15 <kzm> @spell narcissitate
06:08:21 <kzm> @spell spell
06:08:28 <kzm> @spell haspell
06:08:32 <kzm> ?
06:08:42 * kzm no grok this.
06:08:44 <ski> @spell sepll
06:09:01 <ski> maybe not currently working .. or can't connect or something
06:09:04 <kzm> @spell stupid-braindead-bot-software
06:09:28 <ski> dons : would you happen to know ?
06:09:29 <kzm> Probably not.
06:10:36 <kzm> calls out to aspell, it seems.
06:11:02 <ski> re
06:11:30 <twb> "Necessitate"
06:11:38 <kzm> dons: is aspell working on the bot computer?
06:11:40 <kzm> @seen dons
06:11:41 <lambdabot> dons is in #haskell. Last spoke 4 hours, 54 minutes and 3 seconds ago.
06:12:00 <ski> twb : ty
06:12:10 <ski> hehe
06:12:41 <triplah> hmm
06:13:03 <ski> does it work better ?
06:13:12 <triplah> sure does
06:13:17 <triplah> im workong on the next part now
06:13:20 <triplah> thanks for that!
06:13:53 <triplah> now i need to make a costString function over that list of pairs
06:14:05 <triplah> then filter everything but the smallest one
06:14:08 <triplah> s
06:14:21 <triplah> smallest costs
06:14:27 <triplah> thats my understanding anyway
06:14:35 <triplah> might be a bit harder in practice
06:14:39 <kzm> Try @spell to kbot (in #haskell-overflow,blah, or #flippi)
06:15:33 <triplah> fst (fst [(a,b),(c,d)]) would be "a" yeah?
06:15:49 <kzm> \msg dons Stock bot works on my computer, so I think it's aspell that is the culprit.
06:16:00 <tromp> try head
06:16:07 <triplah> and snd (fst [(a,b),(c,d)]) would be b ?
06:16:08 * kzm growls.
06:16:16 <triplah> ahh yeah
06:16:35 <triplah> fst (head [blah])
06:16:45 <triplah> snd (head [blah])
06:17:15 <int-e> @type uncurry
06:17:16 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
06:17:28 <int-e> > uncurry (+) (2,3)
06:17:29 <lambdabot> 5
06:18:27 <twb> @pl curry snd
06:18:27 <lambdabot> const id
06:18:39 <twb> Hmm.  I would've thought it'd print "k".
06:18:51 <twb> @pl \x y -> y
06:18:52 <lambdabot> const id
06:18:53 <triplah> > uncurry (length) ("test","hello")
06:18:53 <lambdabot>   Expecting a function type, but found `Int'
06:18:53 <lambdabot>   Expected type: [a] -> b -> c
06:18:53 <lambdabot>   Inferred type: [a] -> Int
06:19:11 <triplah> > uncurry id ("test","hello")
06:19:12 <lambdabot> Couldn't match `b -> c' against `[Char]'
06:19:15 <triplah> boo
06:19:18 <ski> kzm : /query
06:19:24 <int-e> triplah: uncurry takes a function that has two arguments and creates a function that takes a pair instead
06:19:43 <triplah> int-e: aaa i see
06:19:51 <twb> What's wrong with the following?
06:19:51 <twb> mkMoveFn hFn vFn = \(Pt x y) -> Pt (hFn x) (vFn y)
06:19:51 <twb> s = mkMoveFn id (+ 1)
06:19:51 <twb> n = mkMoveFn id (- 1)
06:20:07 <ski> @pl curry fst
06:20:07 <lambdabot> const
06:20:13 <ski> const is K
06:20:47 <int-e> ap is S, id is I
06:22:00 <ski> n = mkMoveFn id (`subtract`1)
06:22:10 <kzm> ski: thanks.  Less embarrassment. :-)
06:22:15 <int-e> grr. stupid unary minus.
06:22:17 <twb> ski: why doesn't (- 1) work?
06:22:19 <ski> '- 1' is the number .. this is somewhat ugly
06:22:22 <psi> or (-) 1
06:22:28 <araujo> Hello Haskell'ers!!!!!
06:22:33 <int-e> (-) 1 is different
06:22:34 <twb> That's nearly as stupid as ~1.
06:22:37 <int-e> you need flip (-) 1
06:22:49 <psi> ah, yeah
06:22:50 <ski> psi : 'flip (-) 1', you mean 
06:22:54 <twb> What about (+ -1)?
06:23:01 <int-e> or (-1+)
06:23:03 <ski> syntax error
06:23:09 <ski> hm
06:23:15 <ski> @type (-1 +)
06:23:16 <lambdabot> forall a. (Num a) => a -> a
06:23:20 <twb> Heh
06:23:21 <ski> that works
06:23:24 <twb> Just like scheme.
06:23:25 * twb ducks.
06:23:30 <ski> ?
06:23:43 <twb> -1+ is a `standard' scheme function.
06:23:46 <ski> what's just like scheme ?
06:23:47 <ski> ah
06:23:53 <ski> is that really in r5rs ?
06:23:56 <int-e> (1+) works, too.
06:23:57 <twb> Nope
06:24:03 <twb> ski: but Sussman always uses it.
06:24:06 <int-e> (instead of (+1)
06:24:07 <int-e> )
06:24:18 <ski> twb : yes, seem to recall it from sicp
06:24:45 <araujo> twb, Then that is not standard. 
06:24:58 <twb> araujo: hence the `quotes'.
06:25:07 <ski> araujo : i think : "hence the ` and '"
06:25:10 <ski> :)
06:25:20 * araujo `ducks`
06:25:36 <twb> Grr.
06:25:39 <twb> It still doesn't work.
06:25:44 <twb> ERROR "haskell.hs":36 - Syntax error in expression (unexpected `)')
06:26:22 <araujo> twb, The usual error for Lispers, too many ')' 
06:26:26 <araujo> ;-)
06:26:53 <twb> araujo: feel free to correct me.
06:27:21 <araujo> twb, I don't correct lispers.
06:28:15 <psi> what have you typed?
06:28:20 <twb> psi: n = mkMoveFn id (-1+)
06:28:31 <triplah> here is a stupid question
06:28:38 <triplah> can i write a lamba that takes no args?
06:28:43 <twb> triplah: \()
06:28:49 <triplah> hmm
06:28:55 <triplah> actually i dont think thats what i need to do
06:28:57 <twb> All functions take exactly one argument.
06:29:11 <twb> Same as in Scheme.
06:29:44 <psi> twb, ((-1) +) seems to work
06:29:50 <triplah> map (\x -> costString m mm sp (fst x) (snd x)) (align str1 str2) where x = head (align str1 str2)
06:29:52 <int-e> triplah: that's just a value.
06:30:00 <triplah> int-e: yep
06:30:29 <twb> psi: Sigh.  I hate fighting the parser.
06:30:34 <triplah> im doing align twice
06:30:34 <twb> Anyway, it works now.
06:30:36 <triplah> which is BAD
06:30:51 <twb> Aah!  Long lines aren't pretty-printed!
06:31:07 * twb stares at a 200-column return value.
06:32:17 <int-e> triplah: hmm, why the x = head (align str1 str2) ?
06:33:14 <triplah> int-e: i want to do costString to each part of the pairs
06:33:20 <triplah> align returns the list of pairs
06:33:30 <int-e> triplah: yes, but that's what the map is good for
06:33:48 <triplah> hmm so, i dont need any args to the lambda?
06:34:21 <int-e> triplah: you define an x that's never used
06:34:38 <triplah> int-e: thats because i'm not quite sure how to use the lambda in the map
06:34:41 <int-e> triplah: (\x -> ...) binds a new x variable
06:34:45 <twb> Use _
06:34:55 <int-e> triplah: your use is fine
06:35:09 <int-e> triplah: I think. it's the outer x that's useless.
06:35:17 <psi> twb: there is also succ and pred, btw
06:35:21 <triplah> in the where?
06:35:33 <twb> @pl (+ -1)
06:35:33 <lambdabot> (line 1, column 2):
06:35:33 <lambdabot> unexpected "+"
06:35:33 <lambdabot> expecting lambda abstraction or expression
06:36:08 <twb> psi: thanks.
06:38:48 <boegel> does anyone have an email-address of astrolabe ?
06:39:08 <twb> My astrolabe isn't even networked.
06:39:46 <int-e> triplah: anyway, optAlign can actually be implemented as a one to two line function using what you already have.
06:40:13 <triplah> int-e: i was hoping that too
06:40:23 <triplah> int-e: this is the joke i have so far
06:40:28 <triplah> filter costString foldl1 min (map (\x -> costString m mm sp (fst x) (snd x)) (align str1 str2))
06:41:08 <triplah> the problem is, i think i might need to evaulate align str1 str2 twice this way
06:41:15 <triplah> unless i can somehow evaluate it one and use it twice
06:41:18 <triplah> once*
06:41:49 <int-e> triplah: that's what let a=<...> in <term with a> is for
06:43:02 <triplah> ahh yeah!
06:43:23 <int-e> triplah: but you're doing too much work that you've done before ;)
06:43:52 <triplah> :(
06:44:19 <triplah> let z=(align str1 str2) in filter (\z -> costString foldl1 min (map (\x -> costString m mm sp (fst x) (snd x)) z) z
06:44:22 <triplah> something like that
06:44:34 <triplah> er
06:44:38 <triplah> ignore that second z
06:44:43 <bourbaki> moin
06:45:48 <int-e> > minimum [1,2,3,4,5,5]
06:45:49 <lambdabot> 1
06:46:02 <int-e> (which, btw, is mentioned in Task 3)
06:46:36 <triplah> hmm
06:46:46 <triplah> but, int-e that returns one value, i need a list of the smallest values
06:47:04 <int-e> triplah: hmm, maybe look at Task 3 again ;)
06:47:05 <ski> smallest values ?
06:47:05 <triplah> hence the filter
06:47:20 <triplah> the pairs with the smallest costs
06:47:40 <triplah> int-e: yeah i i'm kinda copying my minimaBy
06:47:44 <ski> minimaBy ?
06:47:52 <triplah> yep
06:47:55 <ski> m
06:47:58 <int-e> ski: http://www.it.bond.edu.au/inft313/053/assessment/a3.html , Task 3
06:48:19 <int-e> triplah: maybe instead of copying it, you could just use it?
06:48:46 <triplah> the thing that has made me start rewriting it is that i need to give it a list of pairs
06:49:00 <triplah> then get each part of the pair, and feed that to costString
06:49:11 <int-e> but you can do that.
06:49:12 <twb> int-e: isn't that just edit distance?
06:49:21 <int-e> if you can do it with map ...
06:49:35 <int-e> twb: 'just'. :) yes.
06:49:47 <triplah> i'm using map
06:49:49 <triplah> ahh i see
06:49:51 <triplah> hmm
06:49:53 <triplah> interesting
06:49:53 <ski> or, just another '<-' line, using list-monad
06:49:57 <twb> Here's my lecturer's implementation: http://www.csse.monash.edu.au/~lloyd/tildeFP/Haskell/1998/Edit01/
06:50:03 <int-e> twb: it's a walkthrough from a naive to an efficient solution.
06:50:31 <int-e> twb: and it's an assignment due on monday so we don't want to give ready solutions, just hints.
06:50:38 <twb> Oopsie.
06:51:00 <triplah> its ok
06:51:03 <triplah> im bookmarking it
06:51:03 <twb> It's the first hit in google, so I'm not giving away much.
06:51:06 <triplah> i'll read it another time
06:51:23 <triplah> i want to learn haskell anyway
06:51:28 <triplah> the hard way is good for now
06:51:34 <triplah> i clear my timetable this weekend for this
06:51:40 <triplah> cleared*
06:54:22 <twb> That's weird.
06:54:38 <twb> With a suffix rule, make thinks the code is compiled when it isn't.
06:54:45 <twb> But with a pattern rule it works correctly.
06:56:50 <twb> Is there a GNU getopt thingamyjig for Haskell?
06:57:07 <triplah> optAlign m mm sp str1 str2 = let z = (align str1 str2) in minimaBy (costString m mm sp (fst (head z)) (snd (head z)) z
06:57:15 <triplah> thats a hazarded guess
06:57:16 <triplah> :)
06:58:33 <triplah> i get the distint feeling minimaBy needs alambda
06:58:44 <twb> anaphoric lambda?
06:59:08 <twb> Or did you forget a space?
07:00:15 <int-e> triplah: yes
07:00:22 <int-e> triplah: that, or an uncurry ;-)
07:00:31 <triplah> ehe
07:00:33 <triplah> ahh yeah!
07:00:45 <triplah> @type uncurry
07:00:46 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
07:01:06 <triplah> i'll use the lambda for now
07:01:15 <triplah> once i figure it out
07:04:55 <ski> (twb : suffix rule ?)
07:05:08 <twb> ski: Huh?
07:05:19 <twb> ski: Oh.
07:05:53 <twb> ski: A suffix rule looks like e.g. ".c.o: \n\tcc -c -o $@ $<"
07:06:03 <ski> ah, that
07:06:12 <lome> hi!
07:06:18 <twb> lome: hi!
07:06:19 <ski> lo!
07:06:24 <twb> lome: Duck and cover!
07:06:50 <lome> i am looking for function something like that
07:06:50 <lome> while f x = either id (while f) (f x)
07:07:03 <lome> but without stack recursion
07:07:23 <lome> while :: (a -> Either b a) -> a -> b
07:07:58 <lome> while f x returns Right we loop... and then return Left value
07:08:15 <lome> could you help me with it?
07:08:17 <ski> while f x = loop (f x) where loop (Left y) = y; loop (Right x) = loop (f x)
07:08:18 <ski> ?
07:09:02 <triplah_> hmm
07:09:10 <triplah_> optAlign m mm sp str1 str2 = let z = (align str1 str2) in map (\x -> minimaBy (costString m mm sp (fst x) (snd x))) z
07:09:13 <triplah_> something aint right
07:09:23 <twb> ski: "where" is syntactic sugar for "let"?
07:09:32 <triplah_> yes
07:09:35 <ski> twb : not quote
07:09:45 <lome> ski: yes, thx... i thought that there is such function or i can do it using folding
07:10:15 <ski> twb : 'let' declares local things over an expression, 'where' declares local thing over a clause/branch
07:10:30 <ski> f x
07:10:37 <ski>   | y < 0 = ...
07:10:41 <ski>   | y > 0 = ...
07:10:45 <ski>   | otherwise = ...
07:10:50 <ski>   where y = ..x..
07:10:53 <triplah_> max3 a b c = let maxab = if a > b then a else b in if maxab > c then maxab else c
07:11:13 <triplah_> max3 a b c =if maxab > c then maxab else c where maxab = if a > b then a else b
07:12:00 <triplah_> argh thats ugly
07:12:01 <ski> lome : hm .. maybe .. though it'd possibly work with a possible 'iterateM'
07:12:08 <twb> max x y = if x > y then x else y
07:12:09 <twb> max3 x y z = max x (max y z)
07:12:24 <ski> yes
07:12:31 <lome> ski: does your example tail-recirsive?
07:12:36 <ski> @type max
07:12:37 <lambdabot> forall a. (Ord a) => a -> a -> a
07:12:40 <int-e> @index iterateM
07:12:41 <lambdabot> bzzt
07:12:48 <int-e> ski: sequence?
07:12:56 <lome> @ty iterateM
07:12:56 <ski> lome : yes, it is
07:12:57 <lambdabot> Not in scope: `iterateM'
07:13:17 <ski> int-e : hm, maybe .. how you you do it with that ?
07:13:28 <ski> s/you you/would you/
07:13:31 <lome> ski: i also think so, but hugs doesnot
07:13:34 <triplah_> > let optAlign m mm sp str1 str2 = let z = (align str1 str2) in map (\x -> minimaBy (costString m mm sp (fst x) (snd x))) z in optAlign 1 2 3 "test" "test"
07:13:35 <lambdabot>  Not in scope: `costString'
07:13:40 <triplah_> ahh damn
07:13:48 <ski> lome : think what ?
07:14:06 <lome> ski: that your function is tail-recursive
07:14:35 <lome> ok, i'll think...
07:14:39 <ski> it *is* tail-recursive .. that is not same that it executes in O(1) space
07:14:54 <ski> if arguments grow bigger and bigger, it's not O(1)
07:15:02 <SamB> @seen lambdabot5
07:15:02 <lambdabot> lambdabot5 has changed nick to kzm.
07:15:02 <lambdabot> kzm is in #haskell-overflow, #flippi, #haskell-blah and #haskell. Last
07:15:02 <lambdabot> spoke 26 minutes and 29 seconds ago.
07:15:04 <ski> and, thunks can grow bigger and bigger if not forced
07:15:05 <int-e> ski: I was wondering about iterateM actually, but it must be something different
07:15:46 * ski haven't seen an 'iterateM', only thought it could be nice (in Either monad, in this case)
07:15:53 <SamB> ski: how so?
07:16:03 <SamB> don't they only get mutated when they are forced?
07:16:13 <int-e> @type fixM
07:16:14 <lambdabot> Not in scope: `fixM'
07:16:34 <SamB> @index MonadFix
07:16:34 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
07:16:34 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
07:16:34 <lambdabot> Error
07:16:38 <ski> SamB : i was speaking about when recursing over them
07:16:48 <ski> @index mfix
07:16:49 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
07:16:49 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
07:16:49 <lambdabot> Error
07:16:58 <SamB> ski: isn't that more numerous rather than bigger and bigger?
07:16:59 <lisppaste2> triplah annotated #14223 with "optAlign" at http://paste.lisp.org/display/14223#4
07:17:06 <twb> Woo.  FPA "Control.Monad.RMS"
07:17:15 <int-e> @type Control.Monad.Fix.mfix
07:17:16 <lambdabot> forall (m :: * -> *) a.
07:17:16 <lambdabot> (Control.Monad.Fix.MonadFix m) =>
07:17:16 <lambdabot> (a -> m a) -> m a
07:17:32 <ski> hm, actually, not 'iterateM'
07:17:52 <ski> twb : hehe .. Reader-Writer-State
07:18:00 <SamB> FPA?
07:18:23 <twb> first parsed as
07:18:36 <SamB> ah
07:18:59 <lome> what is iterateM, i cannot find it
07:19:08 <ski> there is no such
07:19:18 <ski> i just thought it could be nice to have
07:19:28 <lome> oh! i see
07:19:31 <ski> but it shouldn't be iterateM, in this case, anyway, i realized
07:19:44 * SamB thinks it would depend on an UnsafeInterleaveMonad
07:19:51 <ski> yes
07:20:01 <ski> and i wasn't thinking of that
07:20:11 <SamB> no wait, Monad goes at beginning of those typeclass names
07:20:20 <lome> (a -> m a) -> a -> m [a]?
07:20:27 <ski> loopM :: Monad m => (a -> m a) -> (a -> m b)
07:20:28 <ski> loopM f a = do {a' <- f a; loopM f a'}
07:20:38 <ski> lome : for a possible 'iterateM', yes
07:21:06 <ski> i thought of 'loopM'
07:21:12 <lome> cool, i always forget about lazy lists
07:22:16 <ski> > take 6 $ iterate (2^) 0
07:22:17 <lambdabot> [0,1,2,4,16,65536]
07:22:38 <ski> (don't try to take more)
07:22:47 <lome> :-)
07:23:27 <ski> SamB : hm, maybe it could be safified and put into a class ?
07:23:50 <SamB> > iterate (2^) 0
07:23:52 <lambdabot> [0,1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926
07:23:52 <lambdabot> 501697371089405955631145308950613088093334810103823434290726318182294938211
07:23:52 <lambdabot> 881266886950636476154702916504187191635158796634721944293092798208430910485
07:23:52 <lambdabot> 599057015931895963952486337236720300291696959215610876494888925409080591145
07:23:52 <lambdabot> 703767520850020667156370236612635974714480711177481588091413574272096719015
07:23:54 <lambdabot> [23 @more lines]
07:24:11 <ski> oh, it seemed to be able to construct the next
07:24:24 <ski> @more
07:24:25 <lambdabot> 183628256061809145885269982614142503012339110827360384376787644904320596037
07:24:25 <lambdabot> 912449090570756031403507616256247603186379312648470374378295497561377098160
07:24:25 <lambdabot> 461441330869211810248595915238019533103029216280016056867010565164675056803
07:24:25 <lambdabot> 874152946384224484529253736144253361437372908830379460127472495841486491593
07:24:25 <lambdabot> 064725201515569392262818069165079638106413227530726714399815850881129262890
07:24:27 <lambdabot> [18 @more lines]
07:24:27 <ski> @more
07:24:29 <lambdabot> 113423778270556742108007006528396332215507783121428855167555407334510721311
07:24:31 <lambdabot> 242739956298271976915005488390522380435704584819795639315785351001899200002
07:24:33 <lambdabot> 414196370681355984046403947219401606951769015611972698233789001764151719005
07:24:35 <lambdabot> 113346630689814021938348143542638730653955296969138802415816185956110064036
07:24:37 <lambdabot> 211979610185953480278716720012260464249238511139340046435162386756707874525
07:24:39 <lambdabot> [13 @more lines]
07:24:50 * joelr1 waves
07:24:51 * ski stops asking for @more
07:25:21 <SamB> that was bits of 2^65536
07:25:22 * ski actually doesn't remember right now what was unsafe in unsafeInterleaveIO
07:25:39 <joelr1> does anyone have a subscription to ACM?
07:25:40 <SamB> ski: well, the fact that it makes things go out of order
07:25:52 <joelr1> i'm looking for this paper http://portal.acm.org/ft_gateway.cfm?id=507655&type=pdf
07:25:57 <triplah__> :\
07:26:26 <ski> in a unsafeInterLeaveST, it's surely unsafe, but in IO, can't we attribute it to some oracle or something living in the IO monad ?
07:27:03 <SamB> ski: well, I suppose so...
07:27:04 <ski> (concurrency also allows things to go out of order)
07:27:48 <SamB> it makes readFile a bit unsafe, actually
07:28:20 <ski> but not in an impure way, right ?
07:28:20 <SamB> I mean, if you readFile a file and then overwrite it before consuming the contents, bad things will happen!
07:28:25 <ski> hm
07:28:27 <ski> right
07:28:41 <SamB> so maybe not impure in any kind of mathematical way
07:28:45 <SamB> but still a bit messy
07:29:13 <ski> guess it depends if we want unsafeInterleaveIO to be unsafeInterleaveST with s being RealWorld .. or if we allow the former to actually look at RealWorld
07:29:21 <ski> right
07:29:46 <joelr1> folks, if i have do { a; b; c; d 
07:29:53 <joelr1> is there a way to reverse the order?
07:30:03 <ski> order of what ?
07:30:07 <joelr1> and get do { d; c; b; a }
07:30:20 <ski> write that instead ?
07:30:30 <SamB> although if you actually do anything to RealWorld in the continuation, maybe it *is* impure mathematically...
07:30:37 <ski> sequence . reverse $ [a,b,c,d]
07:30:45 <ski> hm, not quite
07:31:06 <joelr1> ski: you are moving in the right direction ;)
07:31:07 <ski> liftM last . sequence . reverse $ [a,b,c,d]
07:31:25 <joelr1> ski: why last?
07:31:26 <ski> (could be done better, though)
07:31:39 <SamB> couldn't you just sequence_ ?
07:31:40 <ski> to get result of the 'a' action
07:31:44 <joelr1> ski: oto force eval?
07:32:04 <joelr1> SamB: what does sequence_ do?
07:32:09 <ski> 'do { d; c; b; a }' monadically returns what 'a' monadically return
07:32:12 <SamB> @type sequence_
07:32:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:32:16 <ski> @type sequence
07:32:17 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:32:33 <ski> 'sequence_' just ignores result of all actions
07:32:48 <ski> @type mapM_
07:32:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
07:32:51 <ski> @type mapM
07:32:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:32:57 <ski> similar to those
07:33:04 <SamB> the _ versions just return ()
07:33:08 <joelr1> ski: but you still need last? or do you not?
07:33:14 <SamB> and are potentially more efficient
07:33:46 <SamB> (assuming they are implemented by more than the normal version >> return ()
07:34:07 <ski> joelr1 : well, if not otherwise stated, you want monadic result of 'a', so can't use sequence_ since that throws away all results, so use sequence_ and then extract last result
07:34:26 <ski> SamB : 'more' ?
07:34:28 <joelr1> ski: no, i do not need the result of a
07:34:38 * ski always thought it was to avoid to build the list
07:34:56 <ski> joelr1 : oh, then 'sequence_ . reverse $ [a,b,c,d]' is fine
07:35:01 <joelr1> ski: can i use just sequence_ . reverse $ [a, b, c]
07:35:08 * ski smiles
07:35:10 <joelr1> ski: ok, thanks a lot 
07:35:30 <SamB> ski: well, more code that does less work
07:35:44 <ski> what are you thinking of ?
07:36:32 <SamB> ski: you shouldn't assume people state explicitly everything they do not need
07:37:12 <SamB> and should suggest things that don't do exactly what they said they wanted if you think they might work, with a qualifier
07:37:38 <ski> (SamB : oh, you commented on joelr1's prob ?  i thought you commented on sequence_ vs. sequence)
07:38:42 <ski> (SamB : anyway, you're right re joelr1)
07:38:48 <ski> @karma- ski
07:38:48 <lambdabot> You can't change your own karma, silly.
07:38:53 <ski> bah
07:39:12 <int-e> @karma ski
07:39:12 <lambdabot> ski has a karma of 2
07:39:31 <joelr1> :D
07:39:42 * joelr1 is not explicit in what he does not want
07:40:37 <triplah__>  map (\x -> costString 0 1 2 (fst x) (snd x)) (align "xx" "yy")
07:40:37 <triplah__> [2,5,5,5,8,5,8,8,5,5,8,8,8]
07:40:41 <triplah__> i can get it that far
07:40:54 <triplah__> map (\x -> minimaBy (costString 0 1 2 (fst x) (snd x))) (align "xx" "yy")
07:40:59 <triplah__> this just doesnt work
07:41:00 <triplah__> :(
07:41:17 <joelr1> is there a thd or thrd for triples?
07:41:20 <joelr1> like fst and snd
07:41:24 <triplah__> nope
07:41:32 <ski> triplah__ : try replacing map with minimaBy
07:41:49 * ski thought there were fst3 snd3 thd3 somewhere
07:42:05 <triplah__> ahh
07:42:08 <triplah__> not in prelude
07:42:12 <ski> @index fst3
07:42:13 <lambdabot> bzzt
07:42:26 <ski> maybe hugs specific, or only in 'the craft'
07:42:57 <int-e> triplah__: I usually find it helpful to think about types when I'm not sure how to fit things together.
07:43:02 <ski> (anyway, it's tedious to define such)
07:43:24 * int-e would, btw, love to have Functor instances for (a,a), (a,a,a) and (a,a,a,a)
07:43:40 <int-e> (but the type System can't quite cope with that)
07:43:44 <int-e> S->s
07:43:49 <ski> non-linear use of tyvars in instance head
07:44:30 <int-e> so I'd be stuck with newtype Pair a = (a,a) - for which I can define such an instance - and a lot of glue code where I just want to use map.
07:44:34 <triplah__> hmm not sure what you mean there
07:44:36 <triplah__> ski
07:44:41 <triplah__> map (\x -> minimaBy (costString 0 1 2 (fst x) (snd x))) (align "xx" "yy")
07:44:48 <ski> (hm, actually, that could be done with lambdas in type .. not sure of simpler way)
07:45:03 <ski> map (\x -> costString 0 1 2 (fst x) (snd x)) (align "xx" "yy")
07:45:05 <triplah__> you mean do minimaBy (\x ->
07:45:09 <triplah__> oh
07:45:13 <ski> this calculates cost for all stuff in the list
07:45:17 <int-e> ski: anyway, using map on pairs would be quite handy from time to time :)
07:45:30 <triplah__> ski: yep
07:45:52 <ski> map :: (a -> b) -> ([a] -> [b])
07:45:53 <ski> minimaBy :: Ord b => (a -> b) -> ([a] -> [a])
07:45:59 <int-e> ski: fmap then
07:46:11 <lome> iterateM :: (Monad m) => (a -> m a) -> a -> m [a]
07:46:12 <lome> iterateM f x = do
07:46:12 <lome>     next <- f x
07:46:12 <lome>     rest <- iterateM f next
07:46:12 <lome>     return (next : rest)
07:46:12 <lome> what's wrong?
07:46:20 <ski> so, by replacing, you get a list of some inputs, instead of list of costs
07:46:27 <triplah__> the thing is, this is going to return the list a smallest scores to me, not the smallest scoring alignments
07:46:45 <triplah__> ah
07:46:46 <int-e> lome: it won't terminate for sequencing monads
07:46:49 <ski> int-e : fmap over which part of pairs ? first ? second ? both ?
07:47:09 <ski> lome : it's strict, that's the problem
07:47:13 <ski> well
07:47:25 <lome> how i have to rewrite it?
07:47:34 <ski> it can't be done generally
07:47:39 <int-e> ski: both, in the cases where I want to use it. I realize it's not really the only way to define a functor instance for pairs.
07:47:43 <lome> and where it is strict?
07:48:19 <int-e> ski: I'm daydreaming. :)
07:48:37 <lome> oh! rest MUST be calculated before return?
07:48:40 <ski> * SamB thinks it would depend on an UnsafeInterleaveMonad
07:49:47 <ski> iterateM f x = f x >>= \next -> iterateM f next >>= \rest -> return (next:rest)
07:50:09 <int-e> hmm. what would this do for the list monad?
07:50:36 <lome> ski: yes, i already understand it :(
07:51:12 <ski> > let iterateM f x = f x >>= \next -> iterateM f next >>= \rest -> return (next:rest) in take 5 . map (take 5) $ iterateM (\x -> [2*x,2*x+1]) 1
07:51:15 <lambdabot> Stack overflow
07:51:22 <xerox> Yow.
07:51:45 <ski> > let iterateM f x = f x >>= \next -> iterateM f next >>= \rest -> return (next:rest) in iterateM (\x -> Nothing) 1
07:51:46 <lambdabot> Nothing
07:51:52 <ski> yes, as i thought
07:52:39 <ski> problem is, it will only get to the return part if there's some 'rest' constructed
07:52:54 <int-e> right
07:53:06 <lome> and how i can make it lazy?
07:53:15 <int-e> don't use monads :P
07:53:20 <lome> :-))
07:53:29 <Cale> well, it works just fine in the identity monad :)
07:53:30 <ski> and it won't construct the cons cell until the rec. call return, and it won't (unless it fails, like i showed)
07:53:36 <ski> > let iterateM f x = f x >>= \next -> iterateM f next >>= \rest -> return (next:rest) in take 5 . map (take 5) $ iterateM (\x -> []) 1
07:53:37 <lambdabot> []
07:53:43 <int-e> in the IO monad, they do crazy stuff with unsafeInterleaveIO
07:53:57 <triplah__> hmm
07:54:00 <ski> it can be fun
07:54:47 <ski> > do Right ()
07:54:48 <lambdabot> Add a type signature
07:54:54 <ski> > do Right () :: Either () ()
07:54:55 <lambdabot> Right ()
07:55:06 <triplah__> > error ":("
07:55:07 <lambdabot> Add a type signature
07:55:11 <triplah__> bah
07:55:15 <triplah__> > let error ":("
07:55:15 <lambdabot>  parse error (possibly incorrect indentation)
07:55:18 <triplah__> haha
07:55:24 <triplah__> ok im getting tired now
07:55:38 <int-e> > error ":(" :: Int
07:55:40 <lambdabot> :(
07:55:47 <triplah__> :>
07:56:05 <ski> > let loopM f x = f x >>= \x' -> loopM f x' in loopM (\x -> if x > 100 then do Left x else do return (2^x)) 0
07:56:06 <lambdabot>  add an instance declaration for (Monad (Either a))
07:56:06 <lambdabot>   In the definition of `xxxx':
07:56:06 <lambdabot>    xxxx = let loopM f x = (f x) >>= (\ x' -> ...)
07:56:08 <xerox> @botsnack
07:56:08 <lambdabot> :)
07:56:11 <ski> bah
07:56:15 <triplah__> wb xerox :)
07:56:20 <xerox> Howdy
07:56:24 <ski> (Either a) is a monad
07:56:30 <triplah__> damn thats sad, i was sitting here when you left
07:56:49 <ski> > xxxx
07:56:49 <lambdabot> Add a type signature
07:56:54 <ski> > xxxx :: ()
07:56:55 <lambdabot> Loop
07:56:58 <ski> haha !
07:57:02 <int-e> huh?
07:57:05 <ski> dons !
07:57:26 <ski> it should use some gensym-thing
07:57:35 <int-e> ah!
07:57:50 <ski> > 0 : map (1+) xxxx
07:57:51 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
07:57:51 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
07:57:51 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
07:57:51 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
07:57:52 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
07:57:54 <lambdabot> [24 @more lines]
07:57:58 <ski> hehe
07:58:07 <int-e> > 1 : scanl (+) 1 xxxx
07:58:08 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
07:58:08 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
07:58:08 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
07:58:08 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
07:58:08 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
07:58:10 <lambdabot> [24 @more lines]
07:58:14 <int-e> neat.
07:58:32 <ski> it can't be meant as "last answer", since it's *current* answer
07:59:44 <hulahub> perhaps i have a stupid question but is there a way to define and declare new functions directly in Hugs or GHCi without the need of writing the code to a file and loading it ?
07:59:47 <int-e> > take 10 $ 1 : scanl (+) 1 xxxx
07:59:48 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
08:00:27 <xerox> WOW
08:00:28 <xerox> !!!
08:00:39 <ski> hulahub : not in hugs
08:00:43 <int-e> in hugs, no. in ghci I think it's possible with let ?
08:00:48 <triplah__> yeah
08:00:49 <triplah__> let
08:00:49 <ski> yes
08:00:55 <int-e> Prelude> let a=3
08:00:55 <int-e> Prelude> a
08:00:55 <int-e> 3
08:01:07 <ski> but's it's not mutually recursive with later definitions, so beware
08:01:21 <ski> (it's basically like a 'let' inside 'do')
08:01:34 <roconnor> You can  treat the top level ghci prompt as a do block for IO.
08:01:51 <hulahub> thank you
08:02:15 <hulahub> let was what i was searching for :D
08:02:21 <ski> Prelude> let {foo = ...; bar = ...}
08:02:31 <roconnor> Prelude> print 5
08:02:31 <roconnor> 5
08:02:35 <ski> is possible, though (i.e. you can get mutual recursion, there)
08:03:28 <int-e> > take 10 $ fix((1:).scanl(+)1)
08:03:29 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
08:09:28 <triplah__> ok 
08:09:37 <triplah__> once i get optAlign working im going to bed
08:12:26 <triplah__> bah
08:12:27 <triplah__> stuff it
08:12:30 <triplah__> i'll try tomorrow
08:12:33 <triplah__> gnite all
08:12:38 <jethr0> n8
08:12:47 <triplah__> thanks for the help int-e and ski 
08:13:49 <int-e> sleep well triplah__ 
08:15:32 <Saulzar> Hmm, my fancy new refraction code gives me "<< loop >>", gah :)
08:17:26 <jethr0> saulzar: got any images to see?
08:17:47 <ski> night triplah__
08:19:01 <Saulzar> I'll make one... after turning refraction off ;)
08:19:18 <jethr0> hehe. so slow, huh?
08:19:37 <Saulzar> No - there appears to be a bug, it spits "<< loop >>" at me
08:19:53 <jethr0> no idea what that means...
08:20:02 <roconnor> Saulzar, you the one who wrote the haskell ray tracer?
08:20:05 <Saulzar> I think it must be infinite recursion... 
08:20:46 <Saulzar> I have been writing _a_ haskell raytracer,  but I'm not sure it's of any note :)
08:21:11 <roconnor> The one discussed in some issue of the monad reader?
08:21:53 <Saulzar> Nope, that's someone else
08:22:21 <roconnor> ah okay
08:22:27 <Saulzar> Jethr0 is writing one too - so they are popular!
08:22:42 <Saulzar> Whoops - my scene was a little messed up, lets try that again...
08:23:42 <jethr0> yup, quite a nice application for haskell.
08:23:59 <jethr0> HUGE effects with moderate effort!
08:24:08 <Saulzar> Though some waiting :)
08:28:00 <Saulzar> You get great abstraction just about everywhere almost for free
08:30:02 <jethr0> well not exactly free... i'd bet that a similar (if less elegant) solution in C would be many times faster...
08:30:41 <Saulzar> Ok, I wonder if I still have that web account around..
08:31:02 <Saulzar> True
08:31:10 <Saulzar> But none the less...
08:31:51 <Saulzar> My C++ raytracer of a year or so ago was almost realtime on some of the scenes where it took 10 seconds for this one
08:32:00 <jethr0> but it's MUCH more fun in haskell (no segfaults or weird memory corruptions).
08:32:06 <Saulzar> Yes~!
08:32:18 <ski> maybe you could write code that writes code ?
08:32:50 <ski> (like some fft, i think .. was in haskell or ocaml, and produced C code)
08:34:10 <Saulzar> Hmm, if desperate :)
08:34:39 <Saulzar> I think that was mainly to tune the parameters exactly to depend on the inputs though
08:34:57 <Cale> fftw
08:34:58 <Saulzar> Something like a raytracer must be more complicated.. surely?
08:35:04 <Cale> is probably what you're thinking of
08:35:46 <Cale> It's written in ocaml, and automatically tunes the fft code for the platform it's running on, and the size of the fft you want.
08:36:24 <Cale> "Fastest Fourier Transform in the West" :)
08:40:08 <Saulzar> Ok finally - saulzar.orcon.net.nz/output.jpg
08:40:38 <Cale> nice :)
08:40:40 <jethr0> nice composite object
08:41:07 <Cale> Did you see the raytrace I did with just 3 spheres?
08:41:14 <Cale> er 4 spheres :)
08:41:18 <SamB> Saulzar: can I see your tracer?
08:41:23 <Saulzar> Nope..?
08:41:26 <Saulzar> SamB, The code?
08:41:39 <SamB> yes
08:41:50 <Saulzar> Sure
08:42:06 <Cale> http://vx.hn.org/autoshare/colours-3.png -- and a couple pages of Haskell :)
08:42:14 <Saulzar> I'll upload to the same place 
08:42:38 <Saulzar> Fractals :)
08:43:27 <Cale> Someone started out on a raytracer here, and I helped out with it a bit.
08:43:29 <Saulzar> That's really cool
08:44:14 <Cale> You place 4 spheres such that they're tangent, and centred on the vertices of a tetrahedron.
08:44:14 <Cale> (regular tetrahedron)
08:44:34 <Saulzar> Other fun thing to do with raytracing is heightmaps - you can make cool looking terrains
08:44:41 <Saulzar> Which is not too tricky
08:44:45 <Cale> and some lights just off the centres of the faces of the imaginary tetrahedron
08:45:29 <Saulzar> Where is the camera?
08:46:18 <Cale> in the leftover face which I didn't put a light in, pointed directly at the opposite sphere
08:47:05 <Saulzar> It somehow looks like it's sandwitched..
08:47:22 <Cale> most of the view there is filled with that one sphere, you can only see other real spheres off to the sides
08:47:59 <Cale> you're looking straight into the reflection of the gap that it's sitting in
08:48:23 <SamB> Cale: that looks a lot like a seirpinski gasket
08:48:43 <Cale> yeah, it does
08:49:01 <Cale> I've done this in real life with christmas decorations. It works reasonably well, but it'd be better if the spheres had a 1m radius :)
08:49:10 <Saulzar> Haha
08:49:38 <SamB> Saulzar: so, where were you uploading to again?
08:49:55 <Saulzar> SamB, Just done... saulzar.orcon.net.nz/slugtracer.tar.gz
08:50:47 <ski> Cale : beautiful pic .. reminds of sierpinski, somehow
08:50:52 <Saulzar> I bet you had refraction iterations turned way up for that one? :)
08:50:59 <Cale> http://vx.hn.org/autoshare/DSCF0103.JPG
08:51:33 <Cale> they're not quite shiny enough.
08:51:43 <Cale> but you can see a bit of it
08:51:43 <Cale> Saulzar: infinite
08:52:07 <Cale> Saulzar: rays were followed until they left the scene
08:52:28 <SamB> Cale: infinite!!!
08:52:40 <SamB> Cale: that must have taken a long time
08:52:55 <jethr0> potentially infinite (plus rounding error)
08:53:06 * SamB has it loaded about 40%
08:53:12 <Saulzar> Better hope your spheres are not too perfect :)
08:53:52 <Cale> SamB: about a minute or two if I recall
08:54:28 <Saulzar> Not too bad...
08:54:28 <Cale> Sorry about my net connection
08:54:28 <Cale> this should speed things up :)
08:54:30 <SamB> really?
08:54:36 * Cale closes aMule
08:54:40 <astrolabe> Cale, what if a ray doesn't leave the scene?
08:54:44 <Saulzar> What is the thumb picture?
08:55:12 <Saulzar> Oh, it is wide
08:55:13 <SamB> Cale: I'm fully saturated here myself
08:55:15 <Cale> astrolabe: then the computation diverges
08:55:19 <Saulzar> Neato
08:55:20 * SamB has 56k
08:55:27 <jethr0> astrolabe: _to infinity and beyond_ ;-)
08:55:35 <Cale> Saulzar: it's a picture I took with me holding some spheres in a similar configuration
08:56:12 <SamB> Cale: you want to see slow, you should see what happens when I use eMule ;-)
08:56:13 <Saulzar> I was looking at one corner thinking "what the heck is this thing?!" then a giant thumb appeared
08:56:39 <Saulzar> That is amazing you could line it up so well..
08:57:10 <astrolabe> Wow that's slow
08:57:24 <Saulzar> I think we are murdering Cale's connection :)
08:57:30 <Cale> hehe :)
08:57:36 <astrolabe> as the whole of #haskell connects to cale's machine
08:57:55 <Cale> pretty much -- this is a slow connection. I want my 3mbit connection back
08:57:57 <roconnor> How are you generating the PNGs?
08:58:06 <roconnor> the gamma doesn't look correct.
08:58:39 <Cale> roconnor: by taking a screenshot.
08:58:47 <Cale> Back in Waterloo, I was getting 3mbit/s for $24/mo.
08:58:53 <astrolabe> I'm giving up.  I'l look later.
08:58:59 <SamB> Cale: not as slow as mine!
08:58:59 <SamB> roconnor: gamma shmamma!
08:59:10 <Cale> hehe
08:59:16 <roconnor> Take your RGB values are and raise them to the 0.45
08:59:35 <roconnor> You make have to fiddle with your lighting in your scenes afterwards
09:00:25 <roconnor> Oh I see, these Cale's pics
09:00:37 * SamB remembers that whenever he runs Basillisk II, it changes his gamma whenever it gets focused
09:00:56 <astrolabe> Anyone here use HOpenGL?
09:01:06 <roconnor> Well, the comment probably applies to Saulzar as well ;)
09:01:13 <Saulzar> roconnor, Hehe..
09:01:30 <roconnor> In a ray-tracer you are dealing with a linear light scale.
09:01:40 <roconnor> but R'G'B' is actually non-linear
09:01:45 <roconnor> so you need to covert.
09:02:26 <SamB> roconnor: I know, I know.
09:02:37 <astrolabe> why is RGB non-linear?
09:02:45 <SamB> well except for the part about hardcoding 0.45
09:02:55 <roconnor> RGB controls the voltage applied to a CRT
09:02:56 <SamB> astrolabe: no, R'G'B' 
09:03:01 <Saulzar> Hmm, well my lighting is a complete hack anwyay :)
09:03:03 <roconnor> ;)
09:03:12 <SamB> astrolabe: because of non-linear phosphor response
09:03:27 <roconnor> The voltage applied to the electron gun is not linearly correlated with the intensity seen on the monitor.
09:03:46 <roconnor> The phosphor response is actually pretty linear
09:03:54 <jethr0> roconner: shouldn't that be a problem of the gpu and the display drivers?
09:03:55 <roconnor> Let me find the FAW
09:03:56 <roconnor> Let me find the FAQ
09:03:58 <astrolabe> roconnor: thanks, and I guess LCD's mimic CRTss
09:04:03 <SamB> yeah, its not useful to implement proper gamma until you have something that works reasonably...
09:04:04 <roconnor> bingo
09:04:21 <SamB> roconnor: oh?
09:05:06 <roconnor> http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html#gamma_correction
09:05:16 <roconnor> Incidentally, the nonlinearity of a CRT is a function of the electrostatics of the cathode and the grid of an electron gun; it has nothing to do with the phosphor. 
09:06:08 <roconnor> Saulzar, it may be less of a hack than you think.
09:07:13 <Saulzar> roconnor, Well, it is phong shading .. but that is hardly a physical simulation
09:07:35 <roconnor> If you are 31337 then you can use the E'709 transfer function instead of just (**0.45)
09:07:50 <jethr0> in the long term i'd like to implement photon maps and photon caustics. but that will take me longer than i anticipated ;-))
09:07:52 <roconnor> phong shading isn't so bad
09:08:00 <SamB> roconnor: oh?
09:08:18 <tic|school> If I want to build up a nested structure (like a document) in some data Document a = Section (Document a) (Document a) | Paragraph String (Document a) and then just do Paragraph s d >>= k = Paragraph s (d >>= k) in my Monad instance.. would my data type be a good representation, or how is that usually done?
09:08:18 <roconnor> Anyways, that's shading, and this is a problem with lighting.
09:08:26 <Gs30ng> is list not able to have a list as it's element? i tried [[1], 2, 3] but it occurs an error...
09:08:47 <Gs30ng> while string(not a char) can be an element of a list.
09:08:56 <tic|school> Gs30ng, what's the type of the list?
09:09:00 <SamB> Saulzar: what is less physical about phong than about those fancy techniques with five or six letter acronyms?
09:09:04 <jethr0> gs30ng: list elements have to have a common type.
09:09:06 <roconnor> there are a few engery conservations problems with phong shading, but it's better than gouraud shading.
09:09:12 <SamB> so what if it glosses over a few things... or mattes...
09:09:12 <tic|school> Gs30ng, [1, 2, 3]::[Integer].  What's [[1], 2, 3]?
09:09:20 <Saulzar> SamB, Hehe..
09:09:25 <int-e> Gs30ng: you can't mix multiple data types in a list
09:09:34 <int-e> > [[1], [2,3], [4,5,6]]
09:09:35 <Gs30ng> aha...
09:09:35 <lambdabot> [[1],[2,3],[4,5,6]]
09:09:38 <int-e> that's perfectly ok
09:09:56 <int-e> > reverse  [[1], [2,3], [4,5,6]]
09:09:57 <lambdabot> [[4,5,6],[2,3],[1]]
09:10:02 <int-e> > map reverse  [[1], [2,3], [4,5,6]]
09:10:03 <lambdabot> [[1],[3,2],[6,5,4]]
09:10:14 <Gs30ng> it's a little bit inconvenient, i think
09:10:28 <Gs30ng> can tuple have multiple data types?
09:10:32 <int-e> yes
09:10:33 <tic|school> Gs30ng,  yes.
09:10:38 <roconnor> >[Left [1], Right 2, Right 3]
09:10:44 * SamB wonders if his own build of GHC will compile a working raytracer?
09:10:50 <roconnor> > [Left [1], Right 2, Right 3]
09:10:50 <jethr0> in the beginning it might be. but in most cases mixed list elements are not such a hot idea...
09:10:52 <lambdabot> [Left [1],Right 2,Right 3]
09:10:55 <Cale> tic|school: seems okay to me
09:11:10 <Cale> tic|school: (the Document type)
09:11:18 <roconnor> We use union types to get around non-homongenous list problems.
09:11:32 <tic|school> Cale, thanks for looking. Is that what people generally do? I'm not very experienced with Monads, so this is how I've learned structures are built up
09:11:37 <int-e> Gs30ng: if you want to mix types, you have to make a new data type. A type that can take values of two types is Either a b = Left a | Right b  - that's what roconnor was using
09:11:47 <roconnor> @type [Left [1], Right 2, Right 3]
09:11:48 <lambdabot> forall a b. (Num a, Num b) => [Either [a] b]
09:12:21 <SamB> Gs30ng: its more inconvenient to have to have to deal with lists or non-lists everywhere in your Python code...
09:12:24 <SamB> Gs30ng: have you seen the cgi module?
09:12:25 <ski> Gs30ng : how would e.g. map work over such a heterogenous list ? .. what type would maap have ?
09:12:29 <Cale> tic|school: Well, often the usual monads/transformers will do just fine to build up whatever structure you need, but there are advantages to just creating your own too.
09:12:34 <int-e> Gs30ng: and you can make such data types so it's not really inconvenient at all.
09:12:51 <ski> tic|school : hm, interesting use for monads
09:12:57 <Cale> GHC also has dynamic typing if you really really want it
09:13:17 <Cale> @index toDyn
09:13:17 <lambdabot> Data.Dynamic
09:13:24 <tic|school> ski, oh?
09:13:26 <Cale> @docs Data.Dynamic
09:13:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
09:13:27 <Gs30ng> well, don't get me wrong. with inconvenient, i meant that i am not familiar with those kind of way
09:13:28 <SamB> tic|school: you can even build your own with newtype and monad transformers
09:13:47 <Gs30ng> and anyway thanks everybody for answering me
09:13:49 <tic|school> Cale, I guess.  I haven't really investigated any existing monad transformers. Maybe I should. On the other hand, defining bind is trivial in this case, so.
09:13:59 <tic|school> SamB, yup. Just not sure of which to use. :P
09:14:02 <SamB> sometimes you might want a transformer of your own, too
09:14:18 <tic|school> Yup, when dealing with IO
09:14:20 <roconnor> Gs30ng, if you practice the way of static types, you will have few bugs (so we hope)
09:14:46 <tic|school> but I'm trying to design an embedded langage for writing programmable documents, without the security risks of VBA and friends. :)
09:15:00 <Gs30ng> now it seems to make sense
09:15:00 <tic|school> (or well, dealing with other things, too. IO was the first thing to come to mind.)
09:15:11 <Gs30ng> like map stuff
09:15:16 <ski> Gs30ng : would can also have stuff like a list of widgets, each supporting e.g. draw in different ways (with the help of type classes and "existentially quantified datatypes")
09:15:22 <SamB> Gs30ng: at least you will never need a flatten function ;-)
09:15:36 <SamB> tic|school: ah
09:15:45 <Cale> Gs30ng: yeah, in order for things like map to work, you need to know that the type of all the elements in the list matches the type of the function you pass
09:16:06 <tic|school> SamB, anyway, I trust your authority on this being okay. Thanks :)
09:16:12 <ski> SamB : flattenTree :: Tree a -> [a]
09:16:19 * tic|school reads a bit in the Nomaware Trans pages.
09:16:33 <SamB> ski: for lists!
09:16:37 <SamB> and you know it!
09:16:58 <Cale> Some of the examples on nomaware struck me as needlessly complex.
09:16:59 <ski> (SamB : e.g. data Tree a = Node [(a,Tree a)])
09:17:10 <Cale> But otherwise, it's a pretty great tutorial :)
09:17:12 <ski> SamB : :P
09:17:17 <tic|school> although, a writer monad might be useful...
09:17:30 <tic|school> but I still need to define my own language, so whatever :)
09:17:43 <SamB> tic|school: Cale is the one who looked at it
09:17:43 <Gs30ng> list can contain only 1 type of elements, but that type could be everything, like integer, char, string, ... right?
09:17:51 <ski> yes
09:17:54 <tic|school> SamB, sorry. Tired and confused.
09:17:54 <reddi> ERROR "e:\uni\funktionale programmierung\6\Aufgabe6.hs":1 - Syntax error in input (unexpected keyword "type")  
09:18:01 <reddi> type Graph = [(Int,[Int])]
09:18:03 <Cale> Gs30ng: even a list type :)
09:18:08 <Cale> Gs30ng: or functions
09:18:10 <Gs30ng> yeap :)
09:18:14 <tic|school> Cale, thanks for looking. ;)
09:18:16 <reddi> what is the reason that i cannot even use type?
09:18:26 <SamB> tic|school: just trying to make it clear that I did not look at it too
09:18:28 <Cale> tic|school: the idea of monad transformers is to give some basic tools for building up languages
09:18:35 <SamB> don't want to recieve thanks under false pretenses
09:18:37 <ski> reddi : what is above that ?
09:18:41 <tic|school> SamB, aight.
09:18:47 <reddi> nothing
09:18:56 <Gs30ng> then is there anything to do with "the type of the list"?
09:19:12 <tic|school> Cale, so I'm not quite sure I'd need any of these tools. My document is only, well, a document. I'm not doing any IO or so in it. And the user isn't supposed to mess with it, either.
09:19:28 <ski> Gs30ng : ?
09:19:41 <Cale> tic|school: you usually want to hide the fact you're using monad transformers using a module barrier
09:19:49 <tic|school> Cale, if you have a minute, you could have a look at the "Sample Documents" section of http://www.dtek.chalmers.se/~tic/afp.html for my idea on what a document would look like.
09:19:54 <Gs30ng> i mean, function like 'sum' can handle only a list of integers, but i can pass any kind of list to it, although it causes an error when it tries to add the elements
09:20:08 <int-e> Gs30ng: you can reverse lists
09:20:13 <Cale> You have a simple monad, so it's not obvious that any of the standard transformers apply
09:20:13 <int-e> @type sum
09:20:14 <lambdabot> forall a. (Num a) => [a] -> a
09:20:16 <tic|school> Gs30ng, sum :: Num a => [a] -> a?
09:20:23 <tic|school> Cale, *nod*
09:20:26 <int-e> and sum works for other kinds of numbers, too.
09:20:28 <ski> > sum [True,False]
09:20:29 <lambdabot>  add an instance declaration for (Num Bool)
09:20:29 <lambdabot>   In the definition of `xxxx': xxxx = sum [True, False]
09:20:29 <lambdabot>   In the definition of `v':
09:20:39 <ski> type error
09:20:43 <int-e> > or [True, False]
09:20:44 <ski> not run-time error
09:20:44 <lambdabot> True
09:20:59 <int-e> > sum [1.0, 1.4, 2.4]
09:20:59 <Gs30ng> oh, i see...
09:21:00 <lambdabot> 4.8
09:21:22 <Cale> tic|school: the use of 'par' scared me at first, until I realised it wasn't *that* par
09:21:26 <Cale> heh
09:21:43 <Gs30ng> so Num a => [a] means Num a â [a] in a mathematical way, right?
09:21:43 <tic|school> Gs30ng, Num defines "+". So any operator that has + "on" it can be used with sum. that's what the Num a=> ... says.
09:22:02 <tic|school> Cale, now you've lost me. What's par? Some horrible construction I should be aware of?
09:22:11 <ski> Cale : speaking of linear logic ? :)
09:22:14 <SamB> hmm, interesting beep pattern when run with +RTS -B
09:22:45 <reddi> http://pastebin.com/446286
09:22:52 <Cale> @index par
09:22:52 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
09:22:54 <ski> 'par' in linear logic is 'multiplicative disjunction' >;)
09:22:56 <reddi> ERROR "e:\uni\funktionale programmierung\6\Aufgabe6.hs":12 - Syntax error in input (unexpected `;', possibly due to bad layout)
09:23:02 <Cale> Control.Parallel
09:23:11 <reddi> what is wrong on line 12?!?!?!
09:23:18 <Cale> It's like seq, but for parallelising things.
09:23:29 <ski> reddi : could you paste your code somewhere ?
09:23:32 <ski> lisppaste2 : url
09:23:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:23:34 <reddi> i simply copied my example from aufgabe5 (which was lhs) to aufgabe6
09:23:44 <ski> i suspect bad indentation
09:23:51 <reddi> ski, i already did it
09:23:51 <reddi> http://pastebin.com/446286
09:23:57 <ski> oh, sorry
09:24:04 <reddi> np
09:24:09 <SamB> what happens if you use par?
09:24:19 <reddi> the code works
09:24:23 <tic|school> Cale, eep. no, not that one. maybe I should rename it to something else, huh?:)
09:24:25 <reddi> i only copied it from lhs to hs
09:24:46 <tic|school> Cale, anyway, does my ramblings on monads seem apt for the basic look of a document right now?
09:24:47 <reddi> i removed the > etc. ;-)
09:25:14 <SamB> reddi: did you make sure to remove a consistant amount of whitespace from each line?
09:25:28 <reddi> yes i did
09:25:34 <reddi> between lineds
09:25:36 <reddi> lines
09:25:52 <Cale> tic|school: well, up to you :) Making your datatype a monad seems appropriate. Of course, you should do some quick tests to make sure that the monad laws seem to hold :)
09:26:01 <Cale> (or actually verify that they do)
09:26:14 <tic|school> Cale, I just want the do notation. ;)  Why do I want them to hold, generally?
09:26:17 <Cale> I'm thinking that they will.
09:26:27 <reddi> SamB how do u mean that? i didnt change any line
09:26:34 <reddi> i only removed > cause of lhs
09:26:43 <tic|school> Cale, I'll add that to my todo, anyway.  Thanks a bunch for the help, most appreciated!
09:26:55 <SamB> reddi: well, generally when you do that you also remove some spaces
09:26:57 <Cale> Well, people assume that the monad laws hold of things defined to be in the Monad class.
09:27:09 <SamB> sometimes you forget some, and sometimes there were tabs
09:27:25 <SamB> Cale: or at least they assume they can pretend such ;-)
09:27:27 <reddi> but then i dont get an error on the first line?
09:27:52 <Cale> So if, for example,  x >>= return wasn't the same as x, people would have trouble thinking about things, and bugs would result.
09:27:52 <flux__> triplah__, how's your assignment?-)
09:28:13 <tic|school> Cale, I guess.. but the monad is really opaque to the user.. But I'll make sure that works. :)
09:28:19 <tic|school> Now, I gotta run. Later, and thanks again!
09:28:22 <Cale> later
09:28:36 <reddi> it seems that i am to stupid to change lhs to hs
09:28:40 <reddi> ;-(
09:29:14 <basti_> greetings. How is that ST thing done? I mean, where and how is the type "s" generated?
09:29:56 <Cale> basti_: the s is a bit of a type system trick
09:30:48 <Cale> basti_: the idea is that eventually the internal state type for ST (which maintains all your STRefs) is going to get plugged in there
09:30:59 <basti_> thats what i figured
09:31:04 <Cale> but you have to write your code in a way which is polymorphic in s
09:31:13 <Cale> due to the higher rank polymorphism
09:31:23 <basti_> yep.
09:31:34 <Cale> which effectively means that the internal state record can't escape
09:31:39 <ski> flux__ : he went to bed
09:31:48 <reddi> LOL
09:31:52 <Cale> you can't, say, return it.
09:31:54 <reddi> now i created a new file
09:31:59 <basti_> hmm
09:32:00 <reddi> copied the stuff into, -> works
09:32:10 <basti_> so its first a measure to constrain me?
09:32:11 <flux__> hmph, no ctcp time for me as I'm unregistered
09:32:17 <Cale> basti_: yeah
09:32:29 <Cale> basti_: well, it hides an implementation detail from you
09:32:39 <ski> (you could hide the 's' inside an existential and return that, but it's of no use)
09:32:40 <basti_> well keeping me from shooting myself in the foot
09:32:41 <basti_> ^^
09:32:47 <Cale> yeah
09:32:53 <basti_> so is there a definitive haskell type for that s? (like, "[Int]")
09:33:00 <Cale> something like that
09:33:00 <ski> no
09:33:02 <basti_> is it ever generated, or is that just implicit
09:33:21 <Cale> well, eventually something is going to get plugged in there, internal to runST.
09:33:35 <SyntaxNinja> 'morning
09:33:42 <ski> you could think of the ST monad magically seeing into the future what calls to newST you will make, and then it constructs a big record that instiantiates the 's' type
09:33:42 <flux__> hmm.. ST is written in haskell, right?
09:33:46 <ski> no
09:33:49 <ski> primitive
09:33:57 <basti_> ski: yea thats what i figured
09:33:58 <ski> State is written in haskell
09:33:58 <Cale> it could be written in Haskell
09:34:08 <Cale> (ST could be)
09:34:11 <basti_> Cale: like, with tuples? ^^
09:34:17 <flux__> without the need of IO monad?
09:34:21 <Cale> yes
09:34:43 <flux__> (that's actually what I thought too)
09:34:56 <ski> hm, you need some kind of dynamics, right ?
09:35:01 <basti_> did anyone ever do that? ^^
09:36:05 <Cale> ski: perhaps some typesafe casts if you want to do it even the least bit conveniently
09:36:48 <reddi> are there any algorithm in the net to test wheter an graph is azyclic etc.?
09:36:58 <ski> Cale : leibniz ??
09:37:05 <Cale> ski: hm?
09:37:20 <ski> data Leibniz a b = L (forall f. f a -> f b)
09:37:27 <Gs30ng> this is weird... in Hugs [] is [] and [[]] is [[]], but () is () and also (()) is ()
09:37:29 <ski> s/data/newtype/
09:37:45 <Gs30ng> > [] == [[]]
09:37:46 <lambdabot> Add a type signature
09:37:58 <Gs30ng> err whatever
09:38:05 <ski> '()' on it's own is the empty tuple, with ',' in between it's another tuple, otherwise it's grouping
09:38:32 <ski> Cale : or did you mean unsafeCoerce# ?
09:38:54 <ski> (which is cheating)
09:39:03 <Gs30ng> ski, you mean, because () can be used both to represent a tuple or to group?
09:39:08 <ski> right
09:39:32 <ski> '[]' is always for lists, though
09:39:43 <Gs30ng> then how can i make a tuple that contains an empty tuple as its element?
09:39:53 <ski> > ((),())
09:39:54 <lambdabot> ((),())
09:39:59 <ski> there are no unituples
09:40:16 <flux__> that's funny
09:40:21 <flux__> > let i = (); tuplize z = z in tuplize (tuplize i)
09:40:22 <lambdabot> ()
09:40:46 <Cale> 1-tuples are sort of pointless anyway
09:40:51 <Cale> ski: hmm
09:40:52 <flux__> (actually s/tuplize/identity/g ;))
09:41:14 <malcolm> > let i = (); tuplize z = (z,z) in tuplize (tuplize i)
09:41:15 <lambdabot> (((),()),((),()))
09:41:37 <gilles> hi all
09:41:40 <flux__> but then again, of course my code does what it does, because even then the () is used only for grouping
09:41:42 <ski> Bool -> a  ~=  (a,a)
09:41:51 <ski> Void -> a  ~=  ()
09:41:57 <ski> () -> a  ~=  a
09:42:19 <xerox> heh
09:42:28 <flux__> and I think it does follow that there can be no unituples
09:42:29 <xerox> > let dup = (id &&& id) in dup 2
09:42:30 <lambdabot> (2,2)
09:42:47 <Gs30ng> > ()
09:42:48 <lambdabot> ()
09:42:49 <flux__> or, unituple == the value itself
09:42:51 <Gs30ng> > (())
09:42:52 <lambdabot> ()
09:42:54 <Cale> There really ought to be a void type in the prelude. I think it would be nice if Haskell had a completely uninhabited type (not even inhabited by _|_)
09:42:54 <Gs30ng> > ((1))
09:42:55 <lambdabot> 1
09:42:55 <ski> oh, Control.Arrow is imported nonqualified ?
09:43:07 <xerox> ski: YEAH, happy happy, joy joy!!
09:43:13 <malcolm> Cale: there used to be one in haskell 1.2
09:43:15 <ski> Cale : that'd be the Void#, the unboxed variant
09:43:39 <xerox> I want Arrow in @type too.
09:43:51 <malcolm> You can create your own uninhabited type with 'data Void' and no rhs
09:43:52 <PupenoL> Hello.
09:44:08 <ski> data# Void#
09:44:09 <ski> ?
09:44:13 <ski> hi PupenoL
09:44:23 <Cale> malcolm: I've been finding that there was a lot of stuff that I'd like to have in *previous* versions of Haskell. Why were so many nice features removed for '98?
09:44:25 <flux__> how could such a type be used?
09:44:41 <flux__> how would you write function a -> Void ?
09:44:47 <Gs30ng> is there any prelude function that does this?
09:44:49 <Gs30ng> 		spltl 1 (x:xs) = xs
09:44:49 <Gs30ng> 		spltl n (x:xs) = spltl (n-1) xs
09:45:02 <Cale> malcolm: That still seems to have _|_ in it.
09:45:08 <malcolm> Cale: either because there were already ways of doing the same thing, or because a general mechanism led to bizarre errors for newbies, e.g. monad comprehansions
09:45:19 <ski> Cale : think some were standardisation and simplification .. wasn't clear what was good .. or something along those lines
09:45:31 <malcolm> Cale, yes dataVoid still has bottom
09:45:32 <Cale> malcolm: yeah, I still don't agree with the decision on monad comprehensions :)
09:45:44 <ski> flux__ : the answer is NO (unless a = Void)
09:46:03 <malcolm> Cale: monad comprehensions are identical to do notation (bar syntax)
09:46:23 <Cale> malcolm: yeah, but they emphasize a different aspect of what you're doing
09:46:33 <ski> > drop 10 [0..20]
09:46:34 <lambdabot> [10,11,12,13,14,15,16,17,18,19,20]
09:46:39 <ski> Gs30ng : how about that ?
09:46:50 <Cale> They emphasize the view of monads as containers as opposed to computations.
09:46:56 <ski> > take 10 [0..20]
09:46:57 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
09:47:01 <ski> > splitAt 10 [0..20]
09:47:02 <lambdabot> ([0,1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
09:47:14 <malcolm> Cale: but monads are not necessarily containers any more than they are computations
09:47:28 <Cale> malcolm: sure, they're both analogies :)
09:47:30 <Gs30ng> i've been aware of take, but drop is a newface for me
09:47:32 <Gs30ng> thanks
09:47:37 <Cale> but I think they're both useful
09:47:53 <malcolm> Cale: Maybe we should rename 'do' to 'sequence' or something, to avoid the computational interpretation
09:48:05 <xerox> > let spit n = (take n &&& drop n) in spit 3 [1..6]
09:48:06 <lambdabot> ([1,2,3],[4,5,6])
09:48:08 <xerox> :-)
09:48:09 <ski> if we ever got nice bag and set monads, then monad comprehensions would be nice with those
09:48:33 <ski> xerox : :)
09:48:33 <Speck> hmm... monads
09:48:37 <Cale> malcolm: well, there have been some people who have wanted to get rid of list comprehensions altogether, seeing as one can always use 'do'
09:48:43 <Speck> tasty monads :-D
09:48:52 <xerox> ski: :-D
09:49:21 <malcolm> Cale: I agree that writing a list comprehension as a do thingy is a bit strange
09:49:22 <Cale> But that seems distasteful somehow, because list comprehensions really do look better for some things.
09:49:44 <Cale> Perhaps some notation which was in between the two?
09:49:56 <Cale> add syntax for guards to do-notation?
09:50:12 <malcolm> perhaps we need a class Monad a => ContainerLike a and restrict comprehensions to the ContainerLike things
09:50:23 <Cale> MonadPlus
09:50:35 <reddi> i want to make my own function like == in and (map (==1) [1,2,3,4]) 
09:50:43 <reddi> what is the signature of ==?
09:50:43 <Cale> You need MonadPlus for comprehensions
09:50:48 <xerox> @type (==)
09:50:49 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:51:03 <malcolm> Cale: right
09:51:28 <malcolm> > map (>=3) [1,2,3,4]
09:51:30 <lambdabot> [False,False,True,True]
09:51:41 <Cale> Even if it seems unnecessary, I still think that removing MonadZero was a bad idea. I'd rather keep MonadZero, and get rid of fail.
09:51:58 <xerox> > let reddi n = all . map (==n) in reddi 2 [2,2,2]
09:51:59 <lambdabot> Couldn't match `a -> Bool' against `[b]'
09:52:07 <xerox> > let reddi n = all . (map (==n)) in reddi 2 [2,2,2]
09:52:08 <lambdabot> Couldn't match `a -> Bool' against `[b]'
09:52:10 <malcolm> > [ n | n <- [1,2,3,4], n >= 3 ]
09:52:11 <lambdabot> [3,4]
09:52:43 <Cale> MonadZero is exactly the class of monads which support failure
09:52:57 <SamB> Cale: really?
09:53:01 <xerox> Woot.
09:53:07 <Cale> SamB: well, of course :)
09:53:10 <SamB> what about those that haven't got around to implementing it?
09:53:14 <Cale> SamB: heh
09:53:18 <malcolm> Cale: I think the only reason MonadZero was not adopted was because the IO monad is not an instance
09:53:18 <xerox> They're not MonadZero
09:53:21 <Cale> Well, in principle :)
09:53:27 <gilles> any one would advise a tutorial on haskell for a non-functunal programmer? i'm a bit lot in the list of haskell.org :)
09:53:42 <xerox> @where YAHT
09:53:42 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
09:53:44 <Cale> gilles: Yet Another Haskell Tutorial
09:53:45 <xerox> ^- check this out
09:53:51 <Cale> @google Yet Another Haskell Tutorial pdf
09:53:52 <gilles> thanks
09:53:52 <Speck> what about haskell for c programmers?
09:53:52 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
09:53:56 <SamB> what are the laws for MonadZero?
09:54:34 <Cale> mzero >>= k = mzero
09:54:46 <SamB> @seen Saulzar
09:54:47 <lambdabot> I saw Saulzar leaving #haskell 42 minutes and 51 seconds ago.
09:54:57 <Cale> m >>= \_ -> mzero = mzero, provided that m isn't bottom
09:55:11 <Cale> (possibly)
09:55:20 <Cale> not sure if we really want that one
09:55:37 <Cale> certainly the first one though
09:55:55 <roconnor> Cale, In haskell even the empty type must have _|_ in it; although maybe you knew that.
09:56:14 <Cale> roconnor: yeah
09:56:21 <roconnor> ;)
09:56:48 <roconnor> Haskell make for a poor logic system.
09:57:20 <ski> > let spit = curry (uncurry (&&&) . (($ take) &&& ($ drop)) $ uncurry) in spit 3 [1..6]
09:57:22 <lambdabot> ([1,2,3],[4,5,6])
09:57:29 <ski> xerox : chew on that ! :)
09:57:30 <Cale> roconnor: I'm thinking it would be nice to have an initial object.
09:57:48 <Cale> er, hmm...
09:57:54 <roconnor> yes
09:58:00 <Cale> yeah
09:58:15 <xerox> ski: what!
09:58:21 <xerox> :-D
09:58:35 <PupenoL> What is the logic behind functions taking (x:xs) as parameter instead of [x:xs] (ala Erlang) ? I ask this because the Erlang way seems nicer, but there might be something else to it.
09:58:36 <roconnor> Does Data Foo = Foo Foo simulate it?
09:58:42 <xerox> ski: I always have the feel that's like cheating, but hey, it's nice :-)
09:58:47 <roconnor> err, it has one element.
09:59:03 <Cale> PupenoL: [x:xs] is a list whose first and only element is a list (x:xs)
09:59:15 <ski> xerox : you avoided explicitely compying the list, but didn't succeed with 'n', so i "fixed" that
09:59:16 <Cale> the parens are just for grouping
09:59:32 <ski> s/compying/copying/
09:59:59 <Cale> > let f [x:xs] = x in f [[1,2,3]]
10:00:00 <lambdabot> 1
10:00:11 <ski> @pl spit n = (take n &&& drop n)
10:00:19 <lambdabot> spit = liftM2 (&&&) take drop
10:00:19 <lambdabot> optimization suspended, use @pl-resume to continue.
10:00:22 <ski> @pl spit = curry (uncurry (&&&) . (($ take) &&& ($ drop)) $ uncurry)
10:00:28 <Cale> PupenoL: make sense?
10:00:29 <lambdabot> spit = id (fix (const (curry (uncurry (&&&) . (($ take) &&& ($ drop)) $
10:00:29 <lambdabot> uncurry))))
10:00:29 <lambdabot> optimization suspended, use @pl-resume to continue.
10:00:41 <ski> lambdabot: bah, you're better :)
10:00:42 <xerox> ski: I find that the more point free form
10:00:47 <xerox> is not always the cutest.
10:00:49 <PupenoL> Cale: more or less.
10:00:50 <xerox> later anyway
10:01:27 <PupenoL> is (x:xs) on a function definition a function aplication like anywhere else ?
10:02:06 <Cale> PupenoL: that's a pattern if it occurs on the left hand side of an =
10:02:19 <Gs30ng> not everywhere
10:02:26 <Cale> It gives a particular way to decompose a list
10:02:45 <Cale> : is a special kind of function called a data constructor
10:02:56 <Cale> Only data constructors are allowed in patterns
10:03:09 <Cale> (and variables, of course)
10:03:11 <ski> patterns are like expressions, but it's restricted what you can write, (and you can write some other things too) .. and, oh, they execute "backwards" too :)  (given a value, the produce an environment of variable bindings, or they fail)
10:03:19 <xoso> jo
10:04:00 <ski> the only functions you can apply in patterns are the 'data constructor' functions
10:04:06 <frookyo> do you know a good site for haskell beginner?
10:04:14 <Cale> @google Yet Another Haskell Tutorial pdf
10:04:15 <Gs30ng> haskell.org works
10:04:15 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
10:04:23 <Cale> there's a nice tutorial
10:04:34 <Cale> also, check out the wiki!
10:04:46 <frookyo> ok i'll try thanks a lot
10:04:56 <Cale> http://haskell.org/hawiki/HaskellNewbie
10:05:01 <Gs30ng> there's a nice Haskell tutorial in Korean but you must not be interested on it :)
10:05:04 <Cale> this has lots of questions and answers
10:05:18 <Cale> if you add questions, I, or someone at least, will answer them
10:05:25 <cptchao1> hi, does anyone know if there is a way to get type variables strict. e.g. make "Map !Double" ?
10:05:37 <ski> > let reddi n = all (==n) in reddi 2 [2,2,2]
10:05:38 <lambdabot> True
10:05:50 <Cale> cptchao1: only by modifying the definition of Map
10:05:54 <ski> > let reddi n = and . map (==n) in reddi 2 [2,2,2]
10:05:55 <lambdabot> True
10:06:38 <Cale> Sometimes I wonder if it wouldn't be a good idea to allow for that sort of thing though.
10:06:51 <ski> @google haskell for c programmers
10:06:52 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
10:07:10 <cptchao1> Cale: thanks, however modifying Map.Map, seem odd  to me, als well as reimplementing it.
10:07:26 <Cale> cptchao1: you need a strict Map?
10:07:38 <Cale> cptchao1: you could build one with seq
10:07:45 <Cale> if nothing else
10:08:01 <basti_> is if completely transparent in any monad? it should be shouldn't it?
10:08:33 <Cale> basti_: 'if'? if-then-else expressions are just expressions, just like anywhere
10:08:39 * basti_ nods
10:08:41 <basti_> yup
10:08:53 <ski> PupenoL : ':' is just an infix constructor in haskell, the parens in '(x:xs)' is just grouping parens
10:08:56 * SamB gets an image much faster reducing the res to 160x120
10:09:09 <reddi> can someone explain me what to write es ???? to get the following result?
10:09:10 <reddi> Main> filter (?????) ([(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])])
10:09:10 <reddi> Main> 1,2,4  
10:09:13 <PupenoL> ski: but in the function declaration it is not that, am I wrong ?
10:09:24 <basti_> reddi: this sounds like homework ^^
10:09:49 <reddi> basti_: lol, no i dont need this as an example, i need it as a between result ;-)
10:10:02 <basti_> :D
10:10:06 <Cale> > filter (snd . head) [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:10:07 <lambdabot> Couldn't match `[(a, Bool)]' against `(a1, b)'
10:10:18 <reddi> it seems that i nead something like pattern matching?
10:10:18 <Cale> no
10:10:20 <Cale> filter?
10:10:25 <Cale> > (snd . head) [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:10:25 <basti_> did you look at the type of filter?
10:10:26 <lambdabot> [1,2,4]
10:10:32 <basti_> @type filter
10:10:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:10:34 <reddi> http://www.zvon.org/other/haskell/Outputprelude/filter_f.html
10:10:41 <reddi> here are some "small" examples
10:10:42 <Cale> what exactly are you filtering for then?
10:10:57 <Cale> you can't get that result by filtering
10:10:59 <cptchao1> Cale: actually, i used map to implement a sparse matrix.  But that is a bit slow,
10:11:04 <reddi> hm i want to give a node nr (e.g. 1...5)
10:11:14 <reddi> and give as an result the list which is after the node
10:11:33 <Cale> cptchao1: well, you can write a constructor for your sparse matrices which just forces the input list before building the Map
10:11:46 <ski> PupenoL : in function declaration it's grouping, also
10:11:48 <SamB> hmm, I just did a heap profile of Saulzar's raytracer
10:11:54 <SamB> where should I put it...
10:12:04 <Cale> lisppaste2: url
10:12:04 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:12:22 <SamB> Cale: its a postscript file
10:12:23 <reddi> is there a better function then filter?
10:12:29 <Cale> SamB: oh...
10:12:39 <reddi> i would like to understand, WHAT to write between the word filter and the list
10:12:40 <Cale> reddi: snd . (!! n)
10:12:48 <Cale> there's no filter here
10:12:56 <SamB> there is a textfile, but its not actually readable
10:13:30 <ski> PupenoL : i think you could define "x : xs <!> y:ys = (x,y) : (xs <!> ys); _ <!> _ = []" provided you had suitable precedence
10:13:36 <Cale> or maybe you want lookup?
10:13:39 <Cale> @type lookup
10:13:40 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
10:13:53 <Cale> > lookup 3 [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:13:55 <cptchao1> Cale: hm thanks. I got an idea.
10:13:55 <lambdabot> Just [2]
10:14:34 <Cale> cptchao1: look at the stuff in Control.Parallel.Strategies, in particular, "using" and "rnf" would be handy :)
10:14:58 <Cale> > lookup 1 [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:14:59 <lambdabot> Just [1,2,4]
10:15:04 <Cale> > lookup 47 [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:15:05 <SamB> http://naesten.dyndns.org:8080/slugray_heap_profile.ps.gz
10:15:05 <lambdabot> Nothing
10:15:40 <reddi> cale: what is against the filter solution?
10:15:42 <ski> PupenoL : so, really, the parens in 'f (x:xs) = ...' is just grouping .. 'f x : xs = ...' would mean '(f x) : xs = ...'
10:15:51 <reddi> 10[19:13] Cale: 01reddi: snd . (!! n) does not work
10:15:52 <SamB> so, who can read these things?
10:16:21 <Cale> reddi: hm? I thought you wanted to get the second component of the nth item of the list?
10:16:43 <Cale> or do you want the second component of the item of the list whose first component matches n?
10:16:46 <reddi> cale: i want it, but i get an type error
10:16:48 <Gs30ng> ski, doesn't it mean a function that takes 3 arguments?
10:16:56 <Cale> reddi: you don't need filter
10:16:58 <Gs30ng> i mean in case of 'f x : xs =' thing
10:16:59 <SamB> anyhow, this heap profile looks a bit suspicious
10:17:03 <Cale> filter doesn't do anything like what you want
10:17:09 <ski> Gs30ng : nope
10:17:17 <ski> 'f x (:) xs = ...*
10:17:21 <ski> s/*/'/
10:17:25 <ski> that would be three args
10:17:26 <reddi> filter filters out a list.....
10:17:27 <ski> hm
10:17:30 <ski> actually not
10:17:35 <ski> 'f x (+) xs = ...*
10:17:38 <ski> would be three args
10:17:44 <reddi> and gives me a partial list
10:17:48 <cptchao1> Cale: thanks, that look promising
10:17:49 <ski> > let f (+) = () in f ()
10:17:51 <lambdabot> ()
10:17:54 <ski> > let f (:) = () in f ()
10:17:55 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 0
10:17:55 <lambdabot>   When checking the pattern: :
10:17:55 <lambdabot>   In the definition of `f': f : = ()
10:18:01 <Cale> reddi: yeah
10:18:22 <Cale> > filter ((== 3) . fst) [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:18:23 <lambdabot> [(3,[2])]
10:18:26 <ski> (can't have operator variables (as opposed to constructors) beginning with ':')
10:18:27 <Cale> > filter ((== 2) . fst) [(1,[1,2,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[])]
10:18:28 <xerox> Back.
10:18:29 <lambdabot> [(2,[1,3])]
10:18:33 <reddi> that is what i want
10:18:37 <Cale> you could use it I suppose
10:18:45 <Cale> there's no need though
10:18:47 <reddi> what das the . mean?
10:18:54 <Cale> function composition
10:19:02 <xerox> @type List.lookup
10:19:03 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
10:19:06 <Cale> that's the same as \x -> fst x == 2
10:19:12 <ski> @type liftM2 (Control.Arrow.&&&) take drop
10:19:13 <lambdabot> Not in scope: `liftM2'
10:19:18 <SamB> see also http://naesten.dyndns.org:8080/slugray_heap_profile.prof
10:19:22 <reddi> i see, ok that works
10:19:22 <ski> @type Control.Monad.liftM2 (Control.Arrow.&&&) take drop
10:19:23 <lambdabot>   No instance for (Monad ((->) Int))
10:19:23 <lambdabot>   arising from use of `Control.Monad.liftM2' at <interactive>:1:0-
10:19:23 <lambdabot> 19
10:19:36 <xerox> ski: what are you doing!
10:19:38 <ski> ah, it's environement monad again
10:19:46 <ski> xerox : just wanted to check
10:19:50 <xerox> Woo.
10:19:57 <reddi> so if i have any list  where the entries are not pure numbers i can make fct. comp.
10:19:58 <xerox> ski: let's define that monad :-D
10:20:01 <Cale> reddi: are you sure you don't just want 'lookup'?
10:20:07 <reddi> is there a way to make the same with pattern matching?
10:20:12 <reddi> cause of the "just"
10:20:14 <SamB> Cale: take a look
10:20:23 <ski> (anyway, what lambdabot came up with was shorter my version .. and possibly clearer, too)
10:20:31 <ski> xerox : it's basically Reader
10:20:36 <xerox> ski: I know!
10:20:50 <xerox> ski: I mean, do it cleanly and let's use it :-)
10:21:14 <xerox> ski: also, what did lambdabot come up with?
10:21:16 <Cale> Whoa Main.CAF is huge
10:21:28 <dsacode> Hello! Are there some papers related to organizing run-time memory in haskell?
10:21:51 <reddi> my idea of getting the result would be pattern matching, is that possible to?
10:21:52 <Cale> SamB: is the scene and image hardcoded?
10:21:54 <ski> instance Monad ((->) e) where return = runReader . return; ma >>= amb = runReader (asks ma >>= \a -> asks (amb a))  -- if i don't mistake myself
10:21:58 <Cale> are*
10:22:04 <reddi> or do i have as an only solution the way u described?
10:22:04 <SamB> Cale: yes
10:22:09 <Cale> SamB: aha
10:22:22 <ski> @pl spit n = (take n &&& drop n)
10:22:33 <SamB> but I changed the res from (800, 600) to (160, 120)
10:22:36 <xerox> Ah, I see.
10:22:36 <lambdabot> spit = liftM2 (&&&) take drop
10:22:36 <lambdabot> optimization suspended, use @pl-resume to continue.
10:22:39 <ski> spit = curry (uncurry (&&&) . (($ take) &&& ($ drop)) $ uncurry)  -- my version
10:22:45 <xerox> @type Control.Monad.ap
10:22:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:22:50 <xerox> @type Control.Monad.liftM2
10:22:51 <lambdabot> forall r (m :: * -> *) a2 a1.
10:22:51 <lambdabot> (Monad m) =>
10:22:51 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:23:14 <Cale> dot                            Vector                16.4   12.4
10:23:30 <Cale> can I see the data declaration for Vector?
10:23:45 * ski thinks his version was more creative, but lambdabot's is also nice
10:23:52 <SamB> @pl spit n xs = (take n xs, drop n xs)
10:23:52 <lambdabot> spit = ap (ap . ((,) .) . take) drop
10:24:22 <xerox> ski: that's what I meant with 'cheating' :-D
10:24:59 <ski> > let spit = curry (uncurry take &&& uncurry drop) in spit 3 [1..6]
10:25:00 <lambdabot> ([1,2,3],[4,5,6])
10:25:05 <SamB> Cale: data Vector = Vector !Double !Double !Double !Double
10:25:05 <Cale> um, isn't that splitAt?
10:25:07 <ski> @pl spit = curry (uncurry take &&& uncurry drop)
10:25:08 <lambdabot> spit = curry (uncurry take &&& uncurry drop)
10:25:12 <xerox> @type splitAt
10:25:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:25:14 <ski> that's even better
10:25:21 <Cale> SamB: It's a 4 dimensional raytracer?
10:25:29 * ski wonders why he didn't think of that before
10:25:32 <SamB> Cale: not sure
10:26:16 <xerox> @type spit = curry (uncurry take Control.Arrow.&&& uncurry drop)
10:26:17 <lambdabot> parse error on input `='
10:26:22 <xerox> @type curry (uncurry take Control.Arrow.&&& uncurry drop)
10:26:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:26:51 <SamB> Vector x y z w `dot` Vector x' y' z' w' = (x * x') + (y * y') + (z * z') + (w * w')
10:26:58 <ski> that's the obvious nice solution
10:27:14 <SamB> Vector x y z w `cross` Vector x' y' z' w' = Vector (y * z' - z * y') (z * x' - x * z') (x * y' - y * x') (0)
10:27:23 <SamB> I guess the dot product isn't too helpful
10:27:32 <SamB> but it looks kinda 3d to me
10:27:32 <Cale> I'm not worrying about cross
10:27:47 <SamB> I'm not talking about performance
10:27:57 <Cale> The cross product should take 3 vectors
10:28:03 <SamB> you just wanted to know if it was 4d ;-)
10:28:05 <Cale> yeah
10:28:14 <Cale> that's a 3d cross product embedded in 4d space
10:28:28 <SamB> I seemed to remember one or the other product being dependant on dimensionality...
10:28:44 <SamB> yes
10:29:02 <SamB> so one wonders: why bother with that 4th component? 
10:29:08 <Cale> I'd like to know what the 4th component is for too
10:29:51 <SamB> well, you generally use 4x4 transformation matrices
10:29:51 <Cale> Given that 16.4% of the time is spent in the dot product, removing the 4th component could speed things up.
10:31:25 <Cale> boxIntersections Box   294      547830   6.0    5.6    11.6   16.0
10:31:27 <Cale> hmm
10:31:35 <Cale> maybe take a look there?
10:32:42 <SamB> it drops the 4th components on the floor...
10:33:36 <roconnor> Cale, Cross takes two elements and returns a 6 dimentional vector.
10:33:47 <roconnor> 4 choose 2
10:33:54 <roconnor> > choose 4 2
10:33:55 <lambdabot>  Not in scope: `choose'
10:33:58 <roconnor> bah
10:34:19 <SamB> roconnor: huh?
10:34:35 <SamB> we only work in n-space
10:34:36 <roconnor> cross is presumably the outer product.
10:35:51 <Cale> Cross(v_1,...v_(n-1)) = (v_1 /\ v_2 /\ ... /\ v_(n-1))^t
10:36:11 <roconnor> hmm
10:36:17 <roconnor> I figured Cross = /\
10:36:37 <roconnor> It's hard to figure out how to generalize the 3-d cross product.
10:37:02 <Cale> well, any generalisation isn't going to be the only one :)
10:37:17 <roconnor> sure, but usually there is a right one.
10:37:48 <SamB> ah, normalizePoint seems to use it...
10:37:49 <Cale> That one there is the one that most places use. Calculus on manifolds defines that one in a side note.
10:38:07 <Cale> SamB: perhaps it's all working in projective space?
10:38:39 <Cale> I've never considered doing a raytracer in P^3 R, but that would be interesting :)
10:39:43 <Cale> where's the code?
10:39:59 <roconnor> dot and cross don't seem to make much sense to me on homogenous coordinates.
10:40:27 <lisppaste2> SamB pasted "Saulzar's Vector.hs" at http://paste.lisp.org/display/14231
10:41:02 <SamB> saulzar.orcon.net.nz/slugtracer.tar.gz
10:41:11 <Cale> roconnor: well, they have meanings, but not the usual ones -- it does bring up the problem of what the hell angles are though :)
10:42:00 <roconnor> Vector x y z w * Vector x' y' z' w' = error "Can't multiply vectors"
10:42:39 <roconnor> angles aren't such a problem I guess.
10:42:55 <SamB> roconnor: it is convenient to be able to say v1 * v2 when what you want is elementwise multiplication...
10:42:57 <roconnor> it will be inherited from the notion of angles on a sphere.
10:43:11 <roconnor> When do you want to do element wise multiplication?
10:43:42 <Cale> roconnor: hmm... I suppose.
10:43:47 <int-e> if you want to implement color blending
10:44:02 <roconnor> But, I mean, projective space isn't a vector space.
10:44:04 <Cale> I suppose it's fine as soon as you fix a coordinate frame.
10:44:12 <SamB> roconnor: oh
10:44:29 <Cale> roconnor: it's a vector space with scalar multiples identified
10:44:38 <Cale> (and 0 removed)
10:44:50 <roconnor> 0 is an import part of a vector space ;)
10:44:55 <Cale> well, yeah
10:45:07 <Cale> but that's a common way to build projective spaces
10:45:14 <roconnor> It's Lee algebra is a vector space.
10:45:19 <roconnor> certainly.
10:45:30 <SamB> well, this one seems to have zero...
10:45:34 <Cale> (R^n \ {0}) / ~ where v ~ w if v = a*w
10:45:35 <roconnor> points in projective space are represented by an inner product space.
10:45:42 <Cale> for a in R
10:45:53 <roconnor> but since it isn't itself a vector space, you don't want to write vetor space operations for it.
10:46:08 <Cale> well, you do want the common vector space operations
10:46:17 <Cale> there are really nice things you can do
10:46:27 <SamB> have we figured out if these are projective or not yet?
10:46:32 <roconnor> What does it mean to multiply a point in projective space by 5?
10:46:45 <Cale> roconnor: scalar multiplication does nothing
10:47:21 <Cale> you get a coordinate system for your points and your hyperplanes that way
10:47:35 <Cale> it's a rather elegant way to treat projective geometry
10:47:36 <roconnor> I see what you are getting at, the vetor space operations on the represents of a projective space may be useful.
10:47:46 <Cale> in P^2 R, say
10:48:06 <Cale> you can represent vectors with column vectors (modulo that equivalence)
10:48:17 <Cale> and lines as linear functionals, row vectors
10:48:37 <roconnor> abs (Vector x y z w) = x^2 + y^2 + z^2 +w^2
10:49:00 <roconnor> fromInteger i = "can't convert from integers to vectors"
10:49:03 <Cale> and a point (a,b,c) is on the line [x,y,z] if <[x,y,z], (a,b,c)> = 0
10:49:21 <roconnor> opps abs should return the square root of that.
10:49:41 <Cale> roconnor: type error, unfortunately
10:49:49 <Cale> @type abs
10:49:49 <lambdabot> forall a. (Num a) => a -> a
10:49:54 <roconnor> oh crap
10:49:56 * CosmicRay finally looks in
10:50:03 <CosmicRay> I just opened my irc a mere 5 hours ago
10:50:08 <int-e> which is great - lines through two points and a the intersection of two lines can be calculated using a cross product
10:50:10 <roconnor>  abs (Vector x y z w) = error "cannot take abs of a vector"
10:50:15 <Cale> int-e: yes!
10:50:25 <int-e> if the cross product is 0, the lines were parallel or the points identical.
10:50:28 <roconnor> Really, you might as well not even make it an instance of Num :P
10:50:29 <Cale> right
10:50:35 <int-e> err no. identical
10:50:36 <Cale> er
10:50:39 <Cale> identical
10:50:40 <int-e> even for the lines :)
10:50:41 <Cale> yes
10:50:56 * int-e forgot the points at infinity
10:51:07 <Cale> yeah, it takes care of those quite nicely
10:51:17 <Cale> and it makes proofs really really easy
10:52:08 <Cale> you generally just fix a coordinate frame based on your diagram, (that is, a set of 4 points, assigned to the coordinates (1,0,0), (0,1,0), (0,0,1) and (1,1,1)) and then calculate
10:52:11 <basti_> did anyone ever instantiate MonadPlus for STM?
10:52:25 <Cale> basti_: I'm not sure, but it ought to e
10:52:26 <Cale> be*
10:52:42 <basti_> then let him ough
10:52:44 <basti_> or whatever ^^
10:52:45 <basti_> :P
10:53:13 <Cale> in fact, it ought to *only* be an instance of MonadPlus. There's no real need to have retry or orElse exposed to the public.
10:53:20 <Cale> other than that they're nice names
10:53:29 <xerox> STM?
10:53:31 <xerox> Oh yes.
10:53:51 <basti_> yes thats true cale
10:53:57 <roconnor> heh, the traspose of a point is the line that is as far aways as possible.
10:54:05 <Cale> roconnor: yeah
10:54:10 <roconnor> except that metric is all wrong.
10:54:12 <Cale> yeah
10:54:36 <Cale> This is usually used in geometry where there's no metric being considered.
10:54:44 <basti_> my seminar is going to rock.
10:55:02 <Cale> basti_: what's your seminar about?
10:55:16 <basti_> I'm going to teach them some haskell in disguise of talking about the STM paper.
10:55:32 <Cale> sneaky
10:55:47 <basti_> And I'll mention MonadPlus
10:55:48 <basti_> ^^
10:56:28 <SamB> Cale: It is non-obvious how to modify Matrix.hs to work with 3d vectors
10:56:49 <roconnor> STM?
10:56:51 <Cale> SamB: mostly I think it would involve adding an additional 0 component
10:56:56 <roconnor> state transition monad?
10:57:02 <Cale> Software Transactional Memory
10:57:16 <Cale> it's a great paper
10:57:18 <roconnor> *l* I still have no idea what that is.
10:57:41 <Cale> http://research.microsoft.com/Users/simonpj/papers/stm/index.htm
10:57:52 <xerox> @google Software Transaction Memory
10:57:53 <lambdabot> http://www.cambridge.intel-research.net/~rennals/faststm.html
10:57:56 <xerox> @google Software Transactional Memory
10:57:58 <lambdabot> http://www.cambridge.intel-research.net/~rennals/faststm.html
10:58:02 <xerox> Uh, sorry.
10:58:18 <ski> basti_ : when,where,who ?
10:58:31 <Cale> @where stm
10:58:31 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
10:58:44 <basti_> ski: tuesday, marburg, me.
10:58:46 <Cale> well, that at least has it right :)
10:58:59 <xerox> Who has multiple answers :-)
10:59:03 <ski> basti_ : you're holding a seminar just for yourself ?
10:59:06 <roconnor> http://www.science.uva.nl/ga/
10:59:06 * basti_ kicks xerox
10:59:07 <xerox> ;-)
10:59:10 <roconnor> geometric algebra
10:59:15 <xerox> That's what I meant! :-(
10:59:20 <basti_> ski: I'm having a talk in front of my co-students.
10:59:28 <basti_> like, 8 of them.
10:59:34 <ski> ah
10:59:42 <ski> they study ?
10:59:45 <basti_> and a professor
10:59:47 <basti_> yes
10:59:48 <ski> hehe
10:59:49 <Cale> http://research.microsoft.com/Users/simonpj/papers/stm/lock-free.htm -- Word Document!?!
10:59:51 <basti_> students study, usually.
10:59:56 <basti_> at least now and then
11:00:00 <ski> basti_ : sorry, they study what ?
11:00:05 <basti_> ah
11:00:08 <basti_> Computer Sciences
11:00:13 <basti_> one or two are Mathematics
11:00:21 <reddi> what does ERROR - Cannot infer instance  mean?
11:00:45 <basti_> I think i'll see 2 or 4 eyes light up when i say "monoid with an unit", and eyelits close over all other eyes
11:01:02 <reddi> http://pastebin.com/446381
11:01:04 <roconnor> all monads have units?
11:02:02 <roconnor> or do you mean zero?
11:03:16 <ski> *monoid*
11:03:20 <int-e> monoids have units.
11:03:32 <roconnor> *l*
11:03:32 <ski> (though monads are a kind of monoids, at least if taken sufficiently general)
11:03:34 <roconnor> sorry
11:03:53 <ski> monads have 'return' which is what corresponds to the unit, here
11:04:11 <reddi> has anyone an idea what that error http://pastebin.com/446381 means?
11:04:20 <ski> (or, maybe basti_ meant MonadPlus ?)
11:04:20 <roconnor> Is a monoid with a unit a semi-group?
11:04:25 <basti_> ah, STM is in MonadPlus
11:04:34 <xerox> Indeed!
11:04:38 <int-e> roconnor: you're probably trying to add lists
11:04:46 * ski thought monoid always have unit
11:04:51 <basti_> "unit" is a bad word for it, in haskell it's called "zero"
11:04:59 <int-e> ski: they do. monoids without units are semigroups
11:05:02 <basti_> we should stick with "zero"
11:05:05 <basti_> (additive)
11:05:14 <xerox> @index mzero
11:05:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
11:05:14 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
11:05:14 <lambdabot> Control.Monad.Error, Control.Monad.List
11:05:20 <xerox> @type mzero
11:05:21 <lambdabot> Not in scope: `mzero'
11:05:25 <xerox> @type Control.Monad.mzero
11:05:26 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => m a
11:05:35 <ski> basti_ : oh, so you were thinking of MonoidPlus, then (and not monads as monoids, with unit and join as the monoid ops)
11:06:02 <basti_> ski: actually no why?
11:06:13 <ski> reddi : you are mixing numners and lists
11:06:17 <basti_> ski: I'll just make the connection orElse = mplus
11:06:26 <int-e> > [1]+[2]
11:06:27 <lambdabot>  add an instance declaration for (Num [a])
11:06:27 <lambdabot>   In the definition of `xxxx': xxxx = [1] + [2]
11:06:27 <lambdabot>   In the definition of `v': v = let xxxx = [1] + [2] in take 2048 (show
11:06:27 <lambdabot> xxxx)
11:06:29 <ski> > [(1,[1,2,5,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[1])],2,[5]
11:06:30 <lambdabot>  parse error on input `,'
11:06:35 <ski> > [(1,[1,2,5,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[1])],2,[5]]
11:06:36 <lambdabot>  parse error on input `,'
11:06:40 <ski> um
11:07:02 <int-e> > [1] + [2]
11:07:03 <lambdabot>  add an instance declaration for (Num [a])
11:07:03 <lambdabot>   In the definition of `xxxx': xxxx = [1] + [2]
11:07:03 <lambdabot>   In the definition of `v': v = let xxxx = [1] + [2] in take 2048 (show
11:07:03 <lambdabot> xxxx)
11:07:10 <ski> > ([(1,[1,2,5,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[1])],2,[5])
11:07:11 <lambdabot> ([(1,[1,2,5,4]),(2,[1,3]),(3,[2]),(4,[1,4]),(5,[1])],2,[5])
11:07:14 <int-e> oops. sorry.
11:07:15 <xerox> > [1] `mplus` [2]
11:07:16 <lambdabot> [1,2]
11:07:22 <xerox> > [1] ++ [2]
11:07:23 <lambdabot> [1,2]
11:07:45 <ski> reddi : ah, so the list is ok .. so you are passing it errorenously to the function
11:07:48 <reddi> i am so stupid
11:07:59 <reddi> i entered a number instead of a list in the testing 
11:08:02 <reddi> at the testing ;-(
11:09:19 <ski> basti_ : monads are monoids in endofunctor categories with monoidal structure being identity and composition of functors, iirc
11:09:44 <basti_> ski: yes thats correct.
11:09:45 <ski> (basti_ : i.e. a kind of monoidal category)
11:10:14 <ski> but you seemed to be thinking of monoids 'm a', i.e. MonadPlus
11:10:15 <basti_> do you want to intimidate me or what?
11:10:23 <basti_> ^^
11:10:23 <ski> no
11:10:38 <basti_> well a thing can be both Monad and MonadPlus
11:10:39 * ski just wasn't sure which basti_ meant
11:10:44 <ski> sure
11:11:22 <basti_> and then "monadplus" (a different kind of operation than "bind", though it confusingly has a similar structure) makes it a stronger concept
11:11:37 <ski> similar ?
11:11:52 <basti_> well with similar laws. mmmmmaybeeeeee.
11:11:56 * basti_ thinks about that
11:12:00 <ski> how's bind similar to that ?
11:12:27 <basti_> well let's see: bind has properties like (a >>= b) >>= c
11:12:36 <basti_> or a >>= return  === a
11:13:10 <basti_> uhm that first should have become an associative law
11:13:17 <basti_> === a >>= (b >>= c)
11:13:25 <ski> maybe you are thinking of (>@>) where (f >@> g) m = f m >> g  ?
11:13:37 <basti_> a "monoid with 1" is like a*(b*c) = (a*b)*c, a*1 = 1
11:13:38 <ski> f >@> return = f
11:13:44 <ski> return >@> f = f
11:13:53 <basti_> thats kleisli?
11:13:56 <basti_> triple?
11:13:57 <ski> (f >@> g) >@> h = f >@> (g >@> h)
11:13:59 <basti_> thing
11:14:14 <ski> that's composition in the kleisli category of the monad, yes
11:14:26 <ski> (well, converse composition)
11:14:32 <basti_> yea but thats a monad inside out isnt it?
11:14:33 <basti_> ^^
11:14:40 <ski> inside out ?
11:14:52 <basti_> like, same concept, different way of expressing it
11:14:56 <ski> yes
11:15:05 <basti_> different parts make up the same whole
11:15:09 <ski> only, if you express it with bind, it doesn't have form of monoid laws
11:15:21 <basti_> yea i noticed that
11:15:27 <basti_> you can just handwave a little
11:15:28 <basti_> ^^
11:15:45 * ski involutarily smiles
11:16:00 <basti_> :P
11:16:47 <basti_> so this is going to be my final brain-teaser
11:16:54 <basti_> "look its even a bit more" .)
11:16:55 <ski> what is ?
11:17:01 <basti_> that STM is MonadPlus
11:17:04 <ski> monoid stuff ?
11:17:06 <ski> ok
11:17:30 <basti_> "and you know this stuff. you all do. C || &&, perl, shell scripts ..."
11:17:44 <Cale> It's not so much handwaving as it is generalising. You generalise the notion of monoid to a so-called monoid-object in a category. Then a monad is a monoid object in the functor category over a given category.
11:17:53 <basti_> Cale: yea i know.
11:18:17 <basti_> i just didnt want to give them a CT lesson ^^
11:18:37 <Cale> ah :)
11:19:01 <Cale> the way that All About Monads writes the monad laws is okay
11:19:02 <ski> yeah, sneak it into them, instead !
11:19:22 <Cale> I think I might prefer to write them with liftM, join and return instead.
11:19:40 <Cale> and I might just write liftM == map :)
11:19:48 <ski> depends on example monad, which formulation is easiest to get
11:20:27 <Cale> well, I mean notation-wise
11:20:37 <Cale> I might write 'map' to mean the same as 'liftM'
11:21:07 <Cale> As we all know that map :: (Functor f) => (a -> b) -> (f a -> f b), and Functor is a superclass of Monad :)
11:21:35 <xerox> Functor is a *super*class of Monad?
11:21:41 <xerox> Woot, I thought it was the other way around.
11:21:50 <Cale> yes
11:22:01 <Cale> every monad is a functor, but not the other way
11:22:25 <xerox> Ooh-kay.
11:22:44 <Cale> (so Functor contains "more" type constructors)
11:22:51 <Cale> hence "super"
11:23:41 <Cale> however, the current Prelude doesn't respect this
11:24:17 <Cale> Anyone up for a fork of fptools? :)
11:24:25 <Cale> hehe
11:25:10 <xerox> Yeah :-D  /me wants Monad ((->) a) :D
11:25:32 * ski wants Monad (e ->)
11:25:44 <ski> and Monad (Either e)
11:25:45 <Cale> That's already secretly in Control.Monad.Reader
11:25:51 <Cale> yeah
11:25:56 <ski> (no evil Error stuff !)
11:26:16 <xerox> I know that Cale :(
11:26:55 <Cale> xerox: I agree that it would be nice to have that instance in the Prelude, though I haven't seen many use cases that weren't abusive :)
11:27:26 <ski> well, maybe not in Prelude
11:27:50 <Cale> How do you suppose we could get these changes made? I wonder whether it's worthwhile to branch things so as to have an advanced-user and beginner-user Haskell variants
11:28:12 <Cale> I'd like to see things like monad comprehensions come back
11:28:21 <ski> why should the other way be better for beginners ?
11:28:28 <Cale> and 'map' being the be-all and end-all of map functions
11:28:56 <Cale> well, a lot of these changes were made so that beginners wouldn't get 'confusing' error messages about functors
11:29:02 <ski> (DrScheme has 'language levels')
11:29:13 <Cale> and monads and other category theoretic nonsense
11:29:16 <Cale> yeah
11:29:19 <xerox> Language Level sucks in DrScheme :-\
11:29:22 <Cale> I was thinking about that
11:29:23 <ski> Monad (rho ->) could be in another module
11:29:33 <ski> xerox : :)
11:29:40 * ski likes stepper, though
11:29:50 <Cale> Infix type constructors seem to lack some obvious features
11:29:58 <Cale> also, printing them out seems broken
11:29:59 <ski> like ?
11:30:10 <Cale> like sections
11:30:15 <ski> ah
11:30:19 <ski> 'type'
11:30:24 <ski> yes
11:31:34 <astrolabe> I guess to get acceptance in a new haskell standard, you would need to make the error messages more comprehensible for beginners.
11:31:47 <newsham> hi
11:32:00 <astrolabe> hi newsham
11:32:11 <Cale> data a ~> b = Arr a b
11:32:11 <joelr1> folks, how do i derive Eq for this ?
11:32:11 <joelr1> data State 
11:32:12 <joelr1>     = Start
11:32:12 <joelr1>     | Stop
11:32:12 <joelr1>     | forall a. (Show a, Eq a) => State a
11:32:22 <Cale> *Main> :t Arr 5 (Arr 6 7)
11:32:22 <Cale> Arr 5 (Arr 6 7) :: forall a a1 b.
11:32:22 <Cale>                    (Num a, Num a1, Num b) =>
11:32:22 <Cale>                    ~> a (~> a1 b)
11:32:23 <newsham> looking for better or even interestingly different ways to do: http://www.lava.net/~newsham/x/machine/e.lhs.txt
11:32:23 <joelr1> i cannot just say derives (Eq)
11:32:30 <Cale> look how it's rendered prefix
11:32:41 <Cale> in a not-even valid way
11:33:18 <Cale> joelr1: you can't automatically derive Eq for existential types
11:33:30 <Cale> you have to write it yourself
11:33:39 <joelr1> Cale: that much i figured but how do i write it myself for State a?
11:33:45 <joelr1>     State a == State b = a == b
11:34:00 <joelr1> this does not work because a and b can be of different types, i think
11:34:09 <joelr1> instance Eq State where
11:34:09 <joelr1>     Start == Start = True
11:34:09 <joelr1>     Stop == Stop = True
11:34:09 <joelr1>     State a == State b = a == b
11:34:25 <joelr1> this was my first attempt
11:34:31 <ski> joelr1 : what should happen if you compare 'State x' and 'State y' for equality ?  they have unknown (and prolly different) types
11:34:32 <xerox> (Eq a, Eq b) => ?
11:34:57 <joelr1> xerox: so i should just add a type signature?
11:34:58 <xerox> Not that it helps.
11:35:10 <xerox> I don't think so, but hey.  Hmm, dinner :-)
11:35:15 <newsham> write our comparison rules.    (State Start) == (State Start) = true
11:35:17 <Cale> aha
11:35:24 <newsham> (State _) == (State _) == false
11:35:32 <Cale> you can't compare (State x) to (State y)
11:35:37 <joelr1> newsham: does not work 
11:35:41 <joelr1> Cale: so i'm stuck?
11:35:46 <Cale> you don't know that 'x' and 'y' are even the same type
11:35:57 <joelr1> Cale: but they are both EQ, no?
11:36:02 <joelr1>     | forall a. (Show a, Eq a) => State a
11:36:12 <ski> newsham : you don't need to write '.0'
11:36:13 <joelr1> data State 
11:36:13 <joelr1>     = Start
11:36:13 <joelr1>     | Stop
11:36:13 <joelr1>     | forall a. (Show a, Eq a) => State a
11:36:21 <joelr1> how come i cannot compare them?
11:36:30 <Cale> yeah, Int and String are both in Eq, but 67 == "Hello" is still a type error
11:36:31 <newsham> it doesnt?  works for me.  see "PartialHand" and "compare" in http://www.lava.net/~newsham/x/machine/poker.lhs.txt
11:36:50 <joelr1> Cale: hmm
11:37:06 <ski> joelr1 : you can't compare an int and a string for equality .. same thing here
11:37:09 <newsham> instace Eq State where ...
11:37:34 <joelr1> newsham: i want to compare x and y
11:37:54 <joelr1> but since i cannot i guess i'll just drop the existentials here
11:38:04 <joelr1> and go with | State String
11:38:11 <ski> newsham : yes, but did you use existentials in your code ? :)
11:38:21 <newsham> ski: ahh, I see what his problem is.
11:38:33 <newsham> he would have to define comparisons amoung all types in Eq
11:38:34 <Cale> That's about equivalent anyway with only those classes
11:38:39 <ski> joelr1 : you could quantify "further out" if that helps
11:38:43 <Cale> yes
11:38:54 <newsham> StateStr vs StateInt ? :)
11:39:05 <joelr1> nah, i got it. thank you folks!
11:39:07 <Cale> data State a = Start | Stop | State a
11:39:16 <Cale> instance (Eq a) => Eq (State a) where
11:39:21 <joelr1> Cale: oh!
11:39:35 <joelr1> Cale: i totally forgot about that
11:39:44 <Cale> hehe
11:39:54 <newsham> any suggestions for my question?
11:40:01 <Cale> that's the obvious way, existentials are the nonstandard and scary way to go
11:40:13 <joelr1> newsham: what are you doing with poker?
11:40:32 <newsham> joel: that was my "learn haskell" project.
11:40:37 <Cale> why is Poker so popular all of a sudden?
11:40:38 <newsham> it does hand ranking
11:40:42 * joelr1 is the resident poker software guy
11:40:54 <joelr1> Cale: big business
11:41:00 <Cale> It seems like nobody cared about poker, oh, 3 years ago.
11:41:11 * joelr1 nods 
11:41:22 <newsham> cale: rounders, espn, pokerstars, mass media.
11:41:23 <Cale> all of a sudden, there are ads on TV about how to improve your poker game and stuff
11:41:45 <astrolabe> newsham: why can't you use 'sum' instead of defining your own sum'?
11:41:53 <ski> see Adrian Hey's haskell example at http://groups.google.com/group/comp.lang.functional/browse_thread/thread/fe02dfa8937fee91/ac9ec53dd11e97a2?lnk=st&q=adrian+hey+functor+set&rnum=1#ac9ec53dd11e97a2
11:42:02 <newsham> astro: i need to perform sums of floating point numbers
11:42:17 <int-e> newsham: sum does that
11:42:21 <astrolabe> > sum [2.4,4.65]
11:42:22 <lambdabot> 7.050000000000001
11:42:31 <Cale> Seems as bizarre to me as everyone suddenly pushing Scrabble
11:42:43 <joelr1> Cale: big money
11:42:45 <ski> newsham : you know you can 'import Prelude hiding (sum)' right ?
11:42:46 <int-e> Cale: what about Sudoku?
11:42:50 <Cale> There are some stupidly amazing Scrabble players out there
11:43:13 <newsham> ski: didnt know that, thanks.
11:43:23 <Cale> Poker has been around for a long time. It's not like it's a new game or something
11:43:26 <newsham> i would still rather use a different name if i'm reusing a widelyused name
11:43:49 <newsham> cale: rounders then pokerstars then espn then mass media.
11:44:01 <newsham> why do fads happen?  marbles, rubics cube, hula hoop, etc..
11:44:01 <astrolabe> My old bridge partner has been ranked first at scrabble in the uk.  He used to learn lists of word, like all the 7 letter words containing g,k, a and l.
11:44:03 <newsham> they just happen
11:44:30 <ski> newsham : if you also still would like to use it you could additionally do 'import qualified Prelude (sum)'  and then use 'Prelude.sum' (think one should be able to insert 'as P' somewhere and use 'P.sum', too)
11:45:02 <Cale> The Rubik's cube and Hula hoop at least were fads because they were new inventions.
11:45:11 <Cale> I don't know about marbles
11:45:13 <newsham> thanks, using sum now.
11:45:15 <astrolabe> but why not just use sum
11:45:19 <astrolabe> ah :)
11:45:41 <newsham> i had some typing problems earlier with sum and other code I had
11:45:50 <newsham> which led me to believe I couldnt use sum.
11:45:56 <Cale> Sudoku is a minor fad because it's a new kind of puzzle.
11:46:01 <Cale> Poker isn't new
11:46:18 <flux__> so what was before sudoku?
11:46:21 <astrolabe> newsham: maybe include some type declarations?
11:46:29 <newsham> ski: my problem with calling it sum would be that other people might expect it to be the sum they know.
11:46:31 <Cale> flux__: crosswords?
11:46:52 <flux__> I'm not sure if that's the same area
11:47:09 <Cale> Seems to take similar places in newspapers at least
11:47:14 <flux__> crosswords are heavily related to knowing a wide, maybe on-topic, vocabulary
11:47:14 <astrolabe> There are those 'logic puzzle' books.
11:47:19 <Cale> yeah
11:47:26 <flux__> while sudokus are plain logic
11:47:27 <Cale> they're a different kind of puzzle for sure
11:47:44 <Cale> if they were the same, they wouldn't be different :)
11:47:46 <flux__> infact I have one sudoku still unfinished from the morning newspaper ;)
11:47:59 <newsham> i've thought of the type signatures.  is it worthi t?  on the one hand its cool that it figures out the typing for you, on the other hand explicitely listing them is partially documentary
11:48:01 <ski> newsham : ok  (you might explain that the import line hides the usual, or they might see that themselves .. or you could do like you do now, it's ok :)
11:48:24 <flux__> yeah, but I would say that cryptos (do you know those? I'm just translating what they call them in here) are more similar to crossword puzzles than sudokus is to any of those
11:48:25 <int-e> newsham: it's worth it, IMO. and in some cases it's even necessary
11:48:47 <astrolabe> newsham:  In real code, I put lots in.  They serve as comments and help the compiler find bugs.
11:48:52 <newsham> I appreciate the small nit-picks, but what about on a larger scale -- is there some drastically different approach thta would be different?
11:49:05 <newsham> would be cool rather :)
11:49:24 <flux__> atleast sudoku stroke me as a new kind of puzzle when I saw it ;)
11:49:34 <ski> newsham : i usually give type sigs for toplevel things (except sometimes omitting them for trivial stuff), not so often for local stuff
11:50:15 <ski> newsham : iirc John Hughes don't put in type signatures at all (if he can avoid it)
11:51:37 <SamB> ski: he must be very good at getting his types right then
11:51:52 <SamB> or rather foolish
11:52:01 <Cale> I'd like to see more of nurikabe
11:52:03 <ski> i don't recall
11:52:10 <Cale> that's a really nice puzzle
11:52:16 <newsham> ok, has type sigs now.  
11:52:23 <newsham> to me it doesnt look clearer, just longer :)
11:52:36 <ski> SamB : maybe i'm making it bigger than it is
11:53:02 <newsham> oh, here's a question.  can I make my "sums" and "average" more generic?  right now they operate on Doubles and Ints respectively
11:53:12 <newsham> should be able to write them both for any Num right?
11:53:31 <ski> @type let sum = foldl (+) 0 in sum
11:53:32 <lambdabot> forall b. (Num b) => [b] -> b
11:53:40 <ski> @type let sum = scanl (+) 0 in sum
11:53:41 <lambdabot> forall b. (Num b) => [b] -> [b]
11:54:25 <ski> @type \x -> foldl (+) 0 (map fromIntegral x) / fromIntegral (length x)
11:54:26 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
11:54:44 <ski> newsham : it's already quite general, if you remove sigs and ask typechecker
11:54:58 <astrolabe> @type sum
11:54:59 <lambdabot> forall a. (Num a) => [a] -> a
11:55:14 <newsham> sums = scanl (+) 0    with no signature -> Type error in application Expression sums x, term x, type [Double] does not match [Integer]
11:55:15 <newsham> in hugs
11:55:25 <ski> newsham : '(/)' don't work for any "Num"s, though, just for "Fractional"s
11:55:40 <astrolabe> @type putStrLn
11:55:41 <lambdabot> String -> IO ()
11:55:54 <ski> newsham : did you write that in file ?
11:55:58 <astrolabe> newsham: You could use ^ ^ that
11:56:23 <newsham> ski: if I use "0" instead of "0.0" I get an error. in hugs
11:56:40 <ski> when you load the file ?
11:56:45 <newsham> yah
11:57:04 * basti_ just grokked how monoids work in CT.
11:57:08 * basti_ is happy.
11:57:09 <ski> ah
11:57:17 <ski> monomorphism restriction, i think
11:57:52 <ski> newsham : try 'sums xs = scanl (+) 0 xs'
11:57:55 <newsham> astro: danke.
11:58:08 <ski> (and possibly similar for "sum'")
11:58:19 <newsham> that works with xs.  why?
11:58:25 <ski> monomorphism restriction
11:58:55 <ski> it assumes you don't want it overloaded when you have no args, if you don't specify a type-signature
11:59:31 <newsham> ok, so next.  how can I perform a more general average?
11:59:53 <ski> (iirc, this was supposedly to avoid weird behavior, with "values" not being cached while it seems they would be)
12:00:04 <ski> @type \x -> foldl (+) 0 (map fromIntegral x) / fromIntegral (length x)
12:00:05 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
12:00:21 <newsham> I should be able to average non integrals too
12:00:41 <earthy> @type \x -> foldl (+) 0 x / length x
12:00:42 <lambdabot>   No instance for (Fractional Int)
12:00:42 <lambdabot>   arising from use of `/' at <interactive>:1:20
12:00:56 <earthy> owh, right, defaulting. ;)
12:01:04 <ski> @type \xs -> foldl (+) 0 xs / fromIntegral (length xs)
12:01:05 <lambdabot> forall b. (Fractional b) => [b] -> b
12:01:08 <ski> better ?
12:01:15 <newsham> thast what i want.
12:01:18 <earthy> but, that should work for any datatype that actually has + and /
12:01:20 <SamB> ski: so the polymorphic type signature is expected to remind people that something doesn't get cached?
12:01:36 <ski> yes, iirc
12:02:09 <ski> because ther's a class context, which in the usual impl converts to a dictionary, underhead
12:02:13 <newsham> wait.. no.. thats not what I want.
12:02:21 <newsham> you should be able to average non-fractional values too
12:02:33 <ski> but you can't divide general numbers
12:02:35 <newsham> the result will be fractional but the arguments need not be
12:02:37 <ski> just fractionals
12:02:47 <newsham> can I somehow promote the sum to a fractional type?
12:02:59 <ski> why ?
12:03:05 <newsham> I dont care who haskell is, he cant tell me that you cant average integers :)
12:03:18 <ski> map fromIntegral
12:03:25 <ski> @type map fromIntegral
12:03:26 <lambdabot> forall a b. (Num b, Integral a) => [a] -> [b]
12:03:38 <ski> @type (\xs -> foldl (+) 0 xs / fromIntegral (length xs)) . map fromIntegral
12:03:39 <lambdabot> forall a b. (Fractional b, Integral a) => [a] -> b
12:03:56 <ski> you use that if you want to avarage numbers of integral types
12:04:04 <SamB> its not fractional/non-fractional values that are distinguished
12:04:11 <SamB> but fractional/non-fractional types
12:04:13 <newsham> I dont always want to average integrals
12:04:17 <newsham> sometimes i want to average floats
12:04:32 <newsham> sometiems i want to average complexes
12:04:33 <astrolabe> so how do cast from int to float?
12:04:40 <ski> then you just use avarage
12:04:48 <earthy> @type average
12:04:49 <lambdabot> Not in scope: `average'
12:04:51 <earthy> ;)
12:04:53 <ksandstr> astrolabe: fromIntegral
12:04:53 <SamB> @type List.average
12:04:54 <lambdabot> Not in scope: `List.average'
12:04:55 <ski> > fromIntegral (12 :: Int) :: Float
12:04:56 <astrolabe> @type average
12:04:56 <lambdabot> 12.0
12:04:57 <lambdabot> Not in scope: `average'
12:05:01 <SamB> @type List.mean
12:05:02 <lambdabot> Not in scope: `List.mean'
12:05:13 <earthy> but, the 
12:05:13 <Muad_Dibber> argh
12:05:14 <SamB> @type Data.List.average
12:05:14 <Muad_Dibber> fuck it
12:05:15 <lambdabot> Not in scope: `Data.List.average'
12:05:17 <ski> astrolabe : and the name is 'coerce' or 'convert', not 'cast'
12:05:19 <SamB> @type Data.List.mean
12:05:20 <lambdabot> Not in scope: `Data.List.mean'
12:05:35 <ski> @index mean
12:05:36 <lambdabot> bzzt
12:05:36 <Muad_Dibber>  internal error: adjustor creation not supported on this platform\n    Please report this as a bug to glasgow-haskell-bugs@haskell.org,
12:05:37 <newsham> you're saying that if i want to average flats then I do    "average flist"  but if I want to average ints I do  "average (map fromIntegral ilist)" ?
12:05:38 <SamB> ski: don't say coerce
12:05:38 <earthy> \xs -> foldl (+) 0 xs / length xs    works on any number that allows /
12:05:39 <ski> @index avarage
12:05:40 <lambdabot> bzzt
12:05:41 <newsham> doesnt that seem like a cop out?
12:05:45 <SamB> it sounds to much like casting pointers
12:05:56 <earthy> which is not integers
12:06:02 <ski> SamB : ok (doesn't bear that connotation to me, at least)
12:06:10 <roconnor> :type  \l -> (sum (map fromIntegral l))/(genericLength l)
12:06:18 <roconnor> @type  \l -> (sum (map fromIntegral l))/(List.genericLength l)
12:06:19 <lambdabot> forall a i. (Integral a, Fractional i) => [a] -> i
12:06:28 <SamB> well, thats about what unsafeCoerce# does...
12:06:35 <SamB> except they needn't be pointers, iirc
12:06:41 <earthy> @type \l -> (sum l)/(List.genericLength l)
12:06:42 <lambdabot> forall i. (Fractional i) => [i] -> i
12:06:46 <SamB> @kind unsafeCoerce#
12:06:47 <lambdabot> Not in scope: type variable `unsafeCoerce#'
12:06:49 <earthy> hm. right. ;)
12:06:50 <SamB> @type unsafeCoerce#
12:06:51 <lambdabot> Not in scope: `unsafeCoerce#'
12:06:57 <SamB> @type GHC.Prim.unsafeCoerce#
12:06:58 <lambdabot> forall b a. a -> b
12:07:06 <SamB> @kind (->)
12:07:07 <lambdabot> ?? -> ? -> *
12:07:28 <SamB> @kind a
12:07:29 <lambdabot> Not in scope: type variable `a'
12:07:35 <SamB> @kind forall a. a
12:07:36 <lambdabot> *
12:07:37 <astrolabe> let av xs = sum xs / (fromIntegral $ length xs) in av [(2.4),(5.7)]
12:07:41 <ski> @kind ((->) Int)
12:07:41 <lambdabot> ? -> *
12:07:47 <astrolabe> > let av xs = sum xs / (fromIntegral $ length xs) in av [(2.4),(5.7)]
12:07:48 <lambdabot> 4.05
12:08:26 <SamB> @kind ((->) a)
12:08:27 <lambdabot> Not in scope: type variable `a'
12:08:34 <SamB> @kind forall a. ((->) a)
12:08:35 <lambdabot>   `(->) a' is not applied to enough type arguments
12:08:35 <lambdabot>   Expected kind `*', but `(->) a' has kind `? -> *'
12:08:36 <ski> newsham : it's just that integers doesn't support division, so you can't avarage them without first converting them to some number type which does support division
12:08:55 <SamB> @kind forall a. (->) a
12:08:56 <lambdabot>   `(->) a' is not applied to enough type arguments
12:08:56 <lambdabot>   Expected kind `*', but `(->) a' has kind `? -> *'
12:08:58 <ski> @kind /\a. ((->) a)
12:08:59 <lambdabot> parse error on input `/\'
12:09:17 <newsham> ski: there's no way to make a polymorphic function that does the appropriate conversion when necessary?
12:09:38 <newsham> ie. applies map fromIntegral when the argument is integer
12:09:46 <SamB> newsham: not really. I mean, you'd need classcase for that...
12:09:58 <ski> newsham : i don't think we even want that
12:10:05 <SamB> I suppose you could do it with overlapping typeclasses
12:10:19 <SamB> er, instances
12:10:23 <astrolabe> newsham: see my function 15 lines up
12:10:28 <ski> hm
12:10:44 <ski> (newsham : well, hm, if Int was a subtype of Double, then maybe)
12:10:47 <newsham> astro: ?
12:10:59 <astrolabe> > let av xs = sum xs / (fromIntegral $ length xs) in av [2.4,5.7]
12:11:00 <lambdabot> 4.05
12:11:06 <astrolabe> > let av xs = sum xs / (fromIntegral $ length xs) in av [2,5]
12:11:07 <lambdabot> 3.5
12:11:19 <ski> > let av xs = sum xs / (fromIntegral $ length xs) in av ([2,5] :: [Int])
12:11:20 <lambdabot>  add an instance declaration for (Fractional Int)
12:11:20 <lambdabot>   In the definition of `xxxx':
12:11:20 <lambdabot>    xxxx = let av xs = (sum xs) / (fromIntegral $ (length xs))
12:11:35 <newsham> > let av xs = sum xs / (fromIntegral $ length xs) in av [2 :: Int, 5 :: Int]
12:11:35 <lambdabot>  add an instance declaration for (Fractional Int)
12:11:35 <lambdabot>   In the definition of `xxxx':
12:11:35 <lambdabot>    xxxx = let av xs = (sum xs) / (fromIntegral $ (length xs))
12:11:37 <ski> '2' is overloaded to any number typew
12:11:41 <ski> s/w//
12:12:03 <astrolabe> Hey.  You've broken my code   :(
12:12:09 <newsham> thats what I do :)
12:12:12 <xerox> > let average = foldr (((+1) ***) . (+)) (0,0) >>> uncurry (/) in average [1..10]
12:12:13 <lambdabot> 0.18181818181818182
12:12:16 <xerox> Err.
12:12:31 <xerox> > let average = foldr (((+1) ***) . (+)) (0,0) >>> uncurry (flip (/)) in average [1..10]
12:12:32 <lambdabot> 5.5
12:12:35 <ski> newsham : what you're asking is a bit like asking the computer to automatically convert a tree to a list, when you try to use list operations on a tree
12:12:39 <xerox> :-D
12:13:09 <ski> xerox : can you write that in arrow sugar ?
12:13:10 <roconnor> what's up with the (+1) bit?
12:13:14 <roconnor> oh right, length.
12:13:18 <newsham> ski: I disagree. :)
12:13:39 <ski> integers don't support division
12:13:39 <newsham> xerox: I dont understand *** >>>
12:13:43 <roconnor> xerox, that is way more clear.  No lambdas cluttering things up.
12:13:56 <ski> so, to get division, you must convert to something which does support division
12:13:57 <newsham> ski: right, but I know how to convert from integrals to items that support division
12:14:05 <ski> yes
12:14:10 <xerox> roconnor: <blink>
12:14:11 <SamB> ski: if perl had trees, it would probably do that...
12:14:16 <xerox> newsham: (>>>) = flip (.)
12:14:23 <SamB> (convert them to lists when you tried to use list ops on them)
12:14:26 <ski> so, do that when you want to convert integers to such numbers and then avarage them
12:15:23 <newsham> I'm defining intAverage I guess.  *sigh*
12:15:30 <xerox> newsham: (f &&& g) x = (f x, g x)  and  (f *** g) (x,y) = (f x, g y)  and  f >>> g = g . f
12:16:08 <ski> (xerox : well ?)
12:16:11 <newsham> &&& makes a function returning a tuple?
12:16:18 <ski> pair, yes
12:16:22 <newsham> danke.
12:16:30 <xerox> > let dup = (id &&& id) in dup 2
12:16:31 <lambdabot> (2,2)
12:16:38 <ski> (&&&) :: (x -> a) -> (x -> b) -> (x -> (a,b))
12:16:47 <ski> (***) :: (x -> a) -> (y -> b) -> ((x,y) -> (a,b))
12:16:49 <astrolabe> newsham: On the topic of doing your e calculation radically differently, you could define a monad to represent stochastic types, then for sumable types, you could define a 'mean' function.
12:17:01 <ski> (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
12:17:30 <newsham> I get >>> (functional composition, but in pipe-order)
12:17:41 <ski> yes
12:17:50 * ski often defines '(>.>) = flip (.)', though
12:18:09 <newsham> why not ">|" ?  
12:18:10 <ski> ( (>>>) is more general that function composition)
12:18:32 <xerox> ski: in what sense?  I know it, but I don't _really_ know it :-)
12:18:50 <ski> newsham : well, that looks like maybe converse application '(>$) = flip ($)'
12:18:59 <int-e> @type (Control.Arrow.>>>)
12:19:00 <lambdabot> forall (a :: * -> * -> *) d b c.
12:19:00 <lambdabot> (Control.Arrow.Arrow a) =>
12:19:00 <lambdabot> a b c -> a c d -> a b d
12:19:27 <ski> (xerox : just wondered if you could transform the above 'average' version into using arrow syntax)
12:19:29 <Gs30ng> i have a question about the evaluation priority of functional expression
12:19:38 <int-e> >>> works for arbitrary Arrow instances; (->) is just one of them.
12:19:43 <xerox> ski: hehe.
12:19:57 <ski> (xerox : wondered how it'd look like, mostly)
12:20:08 <ski> (xerox : and too tired to do it myself ;)
12:20:21 <newsham> intAverage = average . (map fromIntegral)
12:20:23 <xerox> I did it this morning, re-get it now.
12:20:39 <Gs30ng> in Wikipedia article of Polish Notation, if the arity of all function is known(and fixed), we don't need any parentheses to show the priority of evaluation
12:20:42 <ski> newsham : parens unnecessary
12:20:49 <newsham> thanks.
12:21:24 <astrolabe> Gs30ng: parentheses in haskell don't show the order of evaluation.
12:21:29 <ski> Gs30ng : parens are not used to show priority of *evaluation*, but priority of how to read it
12:21:37 <int-e> Gs30ng: well, due to the possibility of partial applications, arity is not known in functional programming languages
12:21:40 <Gs30ng> like, * + 3 4 + 5 6 should be (* (+ 3 4) (+ 5 6))
12:22:02 <Gs30ng> astrolabe, well i don't mean in Haskell but in general
12:22:14 <xerox> int-e: in "Haskell"
12:22:30 <xerox> int-e: in curried functional languages? :-)
12:22:32 <newsham> astro: I think "monad for stochastics" might be a bit out of my league
12:22:36 <astrolabe> ok.  better to say they tell you how to make a tree structure from the line of symbols
12:22:36 <ski> xerox : and SML,OCaml
12:22:45 <xerox> I mean, in Scheme you have it.
12:22:53 <ski> astrolabe : yes
12:23:10 <ski> xerox : also Erlang
12:23:12 <int-e> xerox: hmm. I was thinking of Haskell and various ML dialects.
12:23:18 <ski> (xerox : and Mercury)
12:23:18 <astrolabe> newsham: I would find it hard, but it could be fun, and it would look really cool.
12:23:20 <Gs30ng> what i want to know is that, if i want to use the map function of haskell, do i still don't need any paranthesises?
12:23:22 <xerox> In lisp, more generally, I think.
12:23:26 <xerox> But hey, ok :-)
12:23:44 <newsham> gs30ng: depends :)
12:23:50 <ski> Gs30ng : parens are used for grouping, not for saying what should be evaluated when
12:23:52 <int-e> Gs30ng: that depends. map f [1,2,3] is ok; map +2 [1,2,3] isn't.
12:24:13 <ski> Gs30ng : e.g. 'f x y z' really means '((f x) y) z'
12:24:16 <xerox> ...for some values of '+'
12:24:20 * xerox is too pointy :-P
12:24:32 <Gs30ng> * + 1 2 + 3 4 should represent 14
12:24:35 <int-e> Gs30ng: the latter would have to be written as map (2+)  or map (+2)
12:24:39 <Gs30ng> without any parens
12:24:42 <int-e> xerox: I want to see that Num instance
12:24:47 <ski> Gs30ng ; in polish, yes
12:24:52 * xerox hides under a rock
12:25:24 <Gs30ng> suppose i design a new language, and i want a map function with Polish Notation without any paren... is it possible?
12:25:32 <ski> @ @ * @ @ + 1 2 @ @ + 3 4 
12:25:33 <lambdabot> Maybe you meant: all-dicts arr babel botsnack choice-add code devils dice
12:25:33 <lambdabot> dict dict-help docs dummy dynamic-load dynamic-reload dynamic-unload
12:25:33 <lambdabot> easton echo elements elite eurohaskell eval fact fact-cons fact-delete
12:25:33 <lambdabot> fact-set fact-snoc fact-update foldoc fortune gazetteer get-shapr ghc
12:25:33 <lambdabot> google help hitchcock hoogle hoogle+ index jargon join karma karma+ karma-
12:25:35 <lambdabot> [7 @more lines]
12:25:37 <ski> oops
12:25:39 <astrolabe> > (*) (+) 1 2 (+) 3 4
12:25:40 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
12:26:00 <astrolabe> oh that's not gonna work :(
12:26:10 <ski> (that was meant to be application structure in haskell, converted to polish notation, with explicit application symbol '@')
12:26:52 <Muad_Dibber> any ghc amd64 guru in here?
12:27:15 <astrolabe> ski: are you sure you didn't mean 'arr babel botsnack choice-add code devils dice' ?
12:27:49 <ski> (btw http://www.cs.chalmers.se/Cs/Research/Functional/Meeting/2000/index.html#John-Oct-26)
12:28:02 * ski leaves
12:28:10 <xerox> Bye.
12:28:15 <xerox> Hi!.
12:28:51 <monochrom> hi...
12:30:51 <SamB> @index Storable
12:30:51 <lambdabot> Foreign.Storable, Foreign
12:31:29 * SamB thinks there ought to be some kind of facility for binary arrays of non-primitive datatypes
12:32:38 <monochrom> What is a binary array?
12:33:11 <SamB> as opposed to an array of closures
12:38:22 <kzm_> @dice
12:38:23 <lambdabot> "dice" (line 1, column 1):
12:38:23 <lambdabot> unexpected end of input
12:38:23 <lambdabot> expecting digit
12:38:32 <kzm_> @dice 4
12:38:33 <lambdabot> 4 => 4
12:38:36 <kzm_> @dice 4
12:38:37 <lambdabot> 4 => 4
12:38:43 <kzm_> @help dice
12:38:44 <lambdabot>  @dice <expr>. Throw dice. <expr> of the form 3d6+2.
12:38:51 <kzm_> @dice 4d2
12:38:52 <lambdabot> 4d2 => 6
12:38:55 <kzm_> @dice 4d2
12:38:55 <lambdabot> 4d2 => 5
12:39:10 <astrolabe> @dice 1d4
12:39:10 <lambdabot> 1d4 => 3
12:48:02 <SamB> is 1e-8 Haskell 98?
12:48:03 <twb> In Haskell, memoization is entirely automatic, right?
12:48:56 <monochrom> No.
12:48:57 <xerox> You get persistence with functional data structures, that is.
12:49:03 <integral> the report doesn't specify any memoising
12:49:37 <SamB> twb: what sort of memoization?
12:49:44 <twb> SamB: memoization of functions.
12:49:48 <SamB> ADEpt: hello
12:50:01 <twb> SamB: like PG defines for CL in On Lisp.
12:50:02 <SamB> did you hear that I fixed the test?
12:50:24 <SamB> actually, I think GHC has a very bad memowy
12:50:48 <astrolabe> SamB: yes
12:50:56 <ADEpt> SamB: hi!
12:51:11 <SamB> astrolabe: nhc doesn't seem to like it much...
12:51:22 <newsham> we all forget from time to time
12:52:11 <astrolabe> float -> decimal . decimal [exponent]  |  decimal exponent
12:52:35 <astrolabe> exponent -> (e|E) [+|-] decimal
12:52:47 <newsham> grammar is a rocky road
12:55:22 <SamB> must have forgotten to implement the latter form or something
12:55:37 <ADEpt> SamB: have you seen my pictures, perchance?
12:55:49 <astrolabe> weird
12:57:50 <astrolabe> @eval 1e-8
12:57:51 <lambdabot> 1.0e-8
12:57:58 <SamB> ADEpt: I saw the SVG though apparantly not in its full glory
12:58:37 <SamB> > 1e-8
12:58:38 <lambdabot> 1.0e-8
12:58:49 <ADEpt> SamB: no, the .ps ones
12:59:29 <araujo> Hi Haskell'ers!!!!
12:59:48 <ADEpt> hi
13:00:19 <SamB> ADEpt: overview.ps seems to be cut off at the edge
13:01:23 <SamB> ADEpt: actually so does threads-orchestration.ps
13:01:38 <ADEpt> SamB: which edge? gv shows it fine for me, though it is in landscape
13:02:18 <SamB> ADEpt: the top edge. which is to say, the right edge.
13:03:08 <ADEpt> SamB: what's the rightmost you see?
13:04:02 <twb> "Write a C program which asks for a file name, reads an array of characters contained in the file, and prints out the array to the screen."
13:04:02 <twb> How would I write this in Haskell?
13:04:31 <basti_> why is stm cooperative?
13:05:02 <SamB> ADEpt: I see most of a box that says "Peer" and I see the "Tr" of a box that presumably starts with "Tracker"
13:05:04 <ADEpt> twb: for "abc" in the file, what should it print?
13:05:15 <malcolm> SamB: looks like nhc98 missed the change from 1.0e-8 to 1e-8 being permitted
13:05:22 <twb> ADEpt: ["abc"]
13:05:24 <ADEpt> SamB: yes it is, and there is nothing more there
13:05:42 <ADEpt> twb: and what seems to be the problem?
13:05:56 <twb> ADEpt: I don't grok how to do I/O in Haskell.
13:06:15 <ADEpt> SamB: sequence diagram is more interesting (i hope)
13:06:47 <ADEpt> twb: you need readFile or getContents, and putStrLn
13:07:21 <SamB> twb: are you sure?
13:07:26 <SamB> brackets and quotes?
13:07:39 <twb> SamB: well, it's a 2D array of characters.
13:07:49 <araujo> twb, you do IO with the all-mighty Monads
13:08:10 <twb> araujo: they sound like a bad guy from Dr. Who.
13:08:12 <roconnor> > List.transpose ["abc"]
13:08:13 <lambdabot> ["a","b","c"]
13:09:21 <basti_> > List.transpose ["ab","cd"]
13:09:23 <lambdabot> ["ac","bd"]
13:09:39 <SamB> twb: oh, maybe you want to do main = do [filename] <- getArgs; print =<< liftM lines (readFile filename)
13:09:47 <basti_> > List.transpose ["abc","def","ghi"]
13:09:48 <lambdabot> ["adg","beh","cfi"]
13:10:47 <ADEpt> twb: or 'main = do [fname] <- getArgs; content <- readFile fname; print (lines c)', which does the same
13:11:10 <twb> SamB: ok, so that pulls a string "filename" from the first argument...
13:11:20 <twb> Then readFile reads the whole file (lazily)
13:11:26 <twb> What does lines do?
13:11:35 <ADEpt> @type lines
13:11:36 <lambdabot> String -> [String]
13:11:43 <twb> Yes, but what does it *do*?
13:11:44 <SamB> > lines "foo\nbar"
13:11:45 <lambdabot> ["foo","bar"]
13:11:48 <twb> Ah.
13:11:50 <ADEpt> > lines "aaa\nbbb\nccc"
13:11:51 <lambdabot> ["aaa","bbb","ccc"]
13:11:52 <SamB> > lines "foo\nbar\n"
13:11:53 * twb feels stupid.
13:11:53 <lambdabot> ["foo","bar"]
13:12:09 <SamB> twb: well, it was a reasonable question...
13:12:15 * twb tries to work out liftM on his own.
13:12:30 <cinema> malcolm, sorry to bother you with that, but it seems that the file 'src/Text/ParserCombinators/PolyState.hs' is missing from the darcs repository of HaXml
13:12:38 <twb> Hmm, not bound.
13:12:55 <malcolm> cinema: ok, thanks for the heads up.  will add it now
13:13:02 <SamB> twb: ah. its in Control.Monad
13:13:08 <SamB> also Monad
13:13:27 <twb> SamB: thanks.
13:13:58 <ADEpt> @index liftM
13:13:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
13:13:59 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
13:13:59 <lambdabot> Control.Monad.Error, Control.Monad.List
13:14:16 <twb> Why is it in so many modules?
13:14:27 <roconnor> @type print
13:14:28 <lambdabot> forall a. (Show a) => a -> IO ()
13:14:29 <twb> Does @index collapse dependencies?
13:14:41 <SamB> ADEpt: did you see I fixed the test?
13:14:41 <roconnor> @type putStr
13:14:42 <lambdabot> String -> IO ()
13:14:43 <ADEpt> twb: it is some pecularity of @index
13:14:53 <roconnor> wouldn't putStr be better than print?
13:15:05 <roconnor> and forget about lines.
13:15:10 <SamB> twb: its just re-exported by a bunch of Control.Monad submodules
13:15:23 <twb> That seems a little odd.
13:15:30 <SamB> roconnor: that wouldn't print it like that
13:15:36 <twb> What is the rationale behind re-exporting stuff?
13:15:39 <malcolm> cinema: darcs repo for HaXml now updated :-)
13:15:50 <SamB> twb: convenience
13:15:55 <SamB> usually
13:15:57 <roconnor> oh right
13:15:58 <cinema> malcolm, thanks a lot. Will try again and repot
13:16:18 <ADEpt> SamB: yes, neat! but I think that I misunderstood semantics of 'havePred' for next piece. I should be a list of pieces 'visible' for PeerThread which requests 'nextPiece', not abstract 'we have those function'. Otherwise PeerThread will not have enough data to supply such function. Do you agree?
13:16:27 <roconnor> @type readFile
13:16:28 <lambdabot> FilePath -> IO String
13:16:32 <SamB> twb: occassionally the module something is defined in isn't meant for general use anyway
13:17:16 <twb> Incidentally, do you have a portable pathname library?
13:17:31 <SamB> ADEpt: I didn't understand it in the first place
13:17:44 <SamB> twb: no
13:17:48 <twb> Aw.
13:17:53 <SamB> twb: just use /es
13:18:12 <twb> Common Lisp's pathspec datatype is scarily impressive.
13:18:41 <malcolm> twb: is your build of nhc98 still stuck?  Or did you get it fixed yet?
13:18:48 <twb> malcolm: I gave up.
13:18:58 <SamB> personally I just find it annoying
13:18:59 <twb> malcolm: I'm on a Debian Sid PPC, btw. :-)
13:19:12 <malcolm> twb: I think it is a simple config problem with finding the ghc libraries
13:19:15 <ADEpt> SamB: it seems that IST tracks whats is available, but does not track - from where. PeerThread keeps private track of pieces of his peer. Then PeerThread uses nextPiece to ask 'which of those pieces I have ability to get I should download next?'. Does this make any sense?
13:19:18 <xerox> twb: on which hardware?
13:19:24 <twb> xerox: Mac Mini.
13:19:39 <PupenoL> Hello.
13:19:44 <xerox> Howdy!
13:19:50 <SamB> ADEpt: oh.
13:20:03 <PupenoL> Can I run ghci inside Emacs (like I can with Erlang and Common Lisp) ?
13:20:07 <twb> Fuck me.
13:20:15 <xerox> PupenoL: sure!
13:20:16 <ADEpt> PupenoL: yes. haskell-mode does that
13:20:21 <SamB> ADEpt: I think I could fix InterestTable then
13:20:22 <xerox> @where haskell-mode
13:20:22 <lambdabot> I know nothing about haskell-mode.
13:20:25 <xerox> D'oh.
13:20:28 <twb> Using ghci, haskell-mode can print the parameter list.
13:20:41 <PupenoL> ADEpt: I have installed it, but I don't see any option for it.
13:20:53 <ADEpt> SamB: I maybe already done that
13:20:55 <PupenoL> maybe I am missing some set up.
13:20:58 <PupenoL> @where haskell-mode
13:20:59 <lambdabot> I know nothing about haskell-mode.
13:21:07 <xerox> @where+ haskell-mode http://www.iro.umontreal.ca/~monnier/elisp/haskell-mode-2.0.tar.gz
13:21:08 <lambdabot> haskell-mode ~> http://www.iro.umontreal.ca/~monnier/elisp/haskell-mode-2.
13:21:08 <lambdabot> 0.tar.gz
13:21:22 <xerox> @where+ haskell-mode http://www.iro.umontreal.ca/~monnier/elisp/
13:21:23 <lambdabot> haskell-mode ~> http://www.iro.umontreal.ca/~monnier/elisp/
13:21:39 <twb> Curiously, it prints a different parameter list to :t in the inferior buffer.
13:21:42 <xerox> Somehow better, I think.  That's where you can find haskell-mode 2.00
13:21:43 <malcolm> twb: the config file at /home/twb/nhc98-1.16/lib/ppc-Linux/hmakerc doesn't know where ghc's standard libraries are installed
13:21:47 <ADEpt> SamB: Thing is, I am now stuck on the next step - how PeerThread could know which segment of particular piece to request, especially if the whole piece is shorter than 23767?
13:22:00 <xerox> What do you mean, twb?
13:22:36 <twb> xerox: "liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r" vs. "liftM :: (Monad m) => (a -> b) -> (m a -> m b)".
13:23:11 <twb> (I'm using haskell-mode v. 2.1)
13:23:30 <xerox> Where is the 2.1 version?
13:23:36 <twb> In Debian.
13:23:37 <ADEpt> PupenoL: try 'C-c C-l' while editing
13:23:39 <twb> *shrug*
13:23:55 <xerox> Version: 2.0-1  hhmmm?
13:24:02 <twb> xerox: 2.1-1
13:24:09 <xerox> :-\
13:24:10 <twb> ii  haskell-mode   2.1-1          A major mode for editing Haskell in Emacs
13:24:46 <xerox> I wonder where I can find it, not in .deb format.
13:24:49 <twb> xerox: try "deb http://ftp.debian.org/debian/ experimental main contrib non-free"
13:24:54 <twb> Oh.
13:25:04 <cinema> malcolm, HaXml compiled flawlessly. I'll compile wxHaskell & Blobs now
13:25:05 <twb> apt-get source :-)
13:25:27 <malcolm> cinema: I look forward to bug reports....
13:26:01 <ADEpt> SamB: i am not sure where a method like 'pieceSize :: PieceNum -> Int' should reside? Torrent? IST? ...
13:26:02 <twb> xerox: http://ftp.debian.org/debian/pool/main/h/haskell-mode/haskell-mode_2.1.orig.tar.gz
13:26:09 <xerox> Thanks very much.
13:26:22 <malcolm> cinema: There's one I know about already.  Attempting to load a new palette file crashes the application on ppc with an illegal instruction error.
13:26:52 <cinema> malcolm, well, I'm on x86 so I won't report it!
13:26:53 <twb> Ew, the maintainer left ~ and semantic.cache crap all through the diff.
13:27:25 <malcolm> cinema: actually, I'd be interested to know if if happens elsewhere.  I don't think it is a Blobs fault.  Maybe wx.
13:27:54 <cinema> malcolm, OK, I'm going to test it
13:29:05 <SamB> ADEpt: no idea
13:29:12 <SamB> ADEpt: just let me fix this ;-)
13:32:02 <ADEpt> SamB: and then we compare the patches? ;)
13:33:12 <ADEpt> SamB: i think that i did that already, but go ahead by all means, I am not particulariry sure that my impl is good enough.
13:34:21 <twb> Is "do" like Scheme's "begin"?
13:34:37 <xerox> In some very, very, very loose sense.
13:35:04 <araujo> hah
13:35:12 <PupenoL> ADEpt: I got an error, too fast to be seen.
13:35:30 <xerox> The 'do' is just a syntactic sugar over a composition of (>>=) and (>>).
13:35:35 <araujo> very(e10) loose sense
13:35:41 <Philippa> twb: you can think of it as the equivalent of a macro call, I guess
13:35:48 <twb> Is there a pprint function?
13:35:58 <Philippa> that takes what kind of parameter?
13:36:05 <xerox> print = putStrLn . show -- ?
13:36:06 <twb> Having a 1200 column list printout is kind of irritating.
13:36:07 <SyntaxNinja> xerox: haskell-mode web page, there's a lihnk from there.
13:36:17 <xerox> Gotcha.
13:36:31 <araujo> Geez... i never thought it was difficult for a lisper to grasp at Haskell
13:36:34 <PupenoL> ADEpt: something regarding "Symbol's function definition is void: inferior-haskell-load-file".
13:36:40 <araujo> *so difficult*
13:36:43 <Philippa> twb: there's an entire pretty-printing library IIRC - I think you'd have to rig up a show-like function with it yourself though
13:36:57 <newsham> araujo: there's a lot of concepts in lisp that dont apply as much to lisp
13:37:00 <newsham> err in haskell
13:37:09 <newsham> not to mention you can do non-functional programming in common lisp
13:37:14 <ADEpt> PupenoL: C-h l will show you error messages
13:37:44 <xerox> @hoogle Pretty
13:37:44 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
13:37:44 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
13:37:53 <PupenoL> ADEpt: it doesn't show it here.
13:38:00 <araujo> newsham, Ive seen that many people do very good coming from other languages, like Python.
13:38:34 <twb> Python is nearly as bad as C++.  Of course they do better in Haskell.
13:38:41 <newsham> i'm a python guy.  i wouldnt say that it made it easier to learn haskell
13:38:51 <newsham> except that python people tend to be naturally smarter ;-)
13:39:00 <twb> newsham: than what, moss?
13:39:04 <twb> :P
13:39:11 <ADEpt> PupenoL: it should be in inf-haskell-*.el Maybe yours is missing?
13:39:40 <PupenoL> ADEpt: maybe ubuntu's/debian's package for haskell-mode is bad.
13:39:46 <newsham> i am half joking.  but i think the fact that python is still learned mostly on ones free time has a filter effect.
13:39:58 <newsham> you dont have the unwashed masses who learned python in school
13:40:07 <monochrom> A Python guy will have little hurdle with Haskell list comprehension.
13:40:27 <newsham> yah, but i didnt have much of a hurdle with python's list comprehension when I first saw them
13:40:31 <twb> monochrom: well, nor will anyone who has seen (first?) order logic.
13:40:41 <ADEpt> PupenoL: i have debian sid and haskell-mode 2.1 running right now
13:40:56 <monochrom> Yes both of you are right.
13:41:03 <PupenoL> ADEpt: kubuntu's package is fol haskell-mode 2.0, I'll try to find a newer one.
13:41:05 <ADEpt> PupenoL: `inferior-haskell-load-file' is an interactive Lisp function
13:41:05 <ADEpt>   -- loaded from "inf-haskell"
13:41:05 <ADEpt> (inferior-haskell-load-file &optional RELOAD)
13:41:34 <ADEpt> PupenoL: try reinstall of package. Seems that autoloads are not working
13:41:45 <tic> Hm..
13:43:48 <twb> PupenoL: or just write new autoloads :-)
13:44:47 <PupenoL> I'm rebuilding haskell-mode 2.1.
13:45:51 <phys_rules> hehe, that's why we really need that hIDE =)
13:46:16 * PupenoL doesn't like single language ides
13:46:21 <twb> phys_rules: can it run in a console?
13:46:24 <PupenoL> more or lees.
13:46:26 <PupenoL> less
13:46:50 <phys_rules> twb: hide, well the current version is based on Gtk Yi, so no
13:46:57 <phys_rules> but in principle Yi supports ncurses
13:47:09 <twb> Okie.
13:47:13 <phys_rules> is having it in console that important ?
13:47:20 <twb> All my work is done remotely.
13:47:25 <phys_rules> ah
13:48:16 <phys_rules> PupenoL: you are right, but those are the most advanced too..
13:48:41 <twb> BTW, Yi really shouldn't advertise "Emacs mode".  nano is more compatible with Emacs than yi --as=emacs.
13:48:42 <phys_rules> for example in case of haskell ide you can interface with ghc-api to get the inferred types, syntax errors, etc.. everything on the fly
13:49:16 <phys_rules> twb: hehe, yeah, the keymaps aren't too well implemented yet :)
13:49:16 <newsham> people still use emacs?
13:49:17 <newsham> ;-)
13:49:27 <phys_rules> newsham: I imagine some do :)
13:49:35 <PupenoL> phys_rules: technically, you may be able to that as well from a generic IDE, but I agree that most generic IDEs won't be able to do that and extending it to that may be impossible.
13:49:46 <twb> newsham: if you know a better web browser than Emacs, I'd like to hear about it!
13:50:04 <phys_rules> PupenoL: yeah, but you would need to have an extremely good OpenAPI which beats the purpose since the plugins will be overly complex
13:50:11 <phys_rules> and then it's just eaiser to build a new IDE
13:50:18 <PupenoL> phys_rules: I agree.
13:50:30 <ADEpt> SamB: jlouis seems to be busy at the moment, so if you care for a pull, I have more patches ready
13:50:55 <newsham> sure it can browse the web, but can it check mail!?
13:51:39 <twb> Not very well.
13:51:53 <phys_rules> PupenoL: just imagine how sweet it would be to interface hoogle from IDE, you press Ctrl-Something and you have a textfiled, you type something and on the fly you get the matches you choose a function, the module for that gets auto imported, etc..
13:52:17 <twb> Well, gnus can theoretically be a good MUA, in the same way that a Harrier jump jet could be a good SUV.
13:52:36 <PupenoL> phys_rules: most of that is unintelligible to me (I started with Haskell yesterday), but, I still understand you.
13:52:43 <phys_rules> twb: the best full featured browser is opera IMHO :) 
13:52:47 <twb> Gnus is like using a chainsaw to cut your spam.
13:52:53 <twb> (real spam, I mean)
13:53:20 <twb> phys_rules: yeah, it was pretty impressive last time I tried.
13:53:24 <PupenoL> I got it to run (I am not sure how). It'd be nice to have a Haskell menu like the Erlang menu.
13:53:26 <xerox> Thunderbird is good enough :-)
13:53:27 <SamB> ADEpt: isn't darcs fun?
13:53:31 <newsham> spam is a lot bigger than it used to be
13:53:42 <phys_rules> twb: the 9th version is awesome
13:53:47 <twb> newsham: like my penis size!
13:53:50 <twb> giggle
13:54:12 <newsham> that was my cue to get work done.
13:54:17 <twb> exactly
13:54:17 <phys_rules> more spam, more viagra LOL
13:54:19 <monochrom> The universe is expanding.
13:54:20 <xerox> ...and then newsham put his glasses back on and noticed the, small, reality
13:54:47 <SamB> ADEpt: so you reverted my change and fixed nextPiece?
13:55:20 <SamB> shapr: what about that PUT repo?
13:55:38 <ADEpt> SamB: it sure is fun! 
13:56:10 <ADEpt> SamB: I dont remember reverting any changes lately. I'd rather blame my sloppy use of darcs. 
13:56:24 <ADEpt> SamB: which change you are referring to?
13:56:51 <SamB> well, let me just pull and see...
13:57:07 <newsham> dont get me wrong, its not that talking about your penis is less interesting than staring at disassemblies of kernel32.dll for hours on end
13:57:19 <newsham> its just that well...  I lied.. it is...
13:57:34 * SamB would rather look at source code
13:57:57 <newsham> samb: that would be nice.  /dcc.  thanks.
13:58:18 <SamB> newsham: you can just check out ReactOS...
13:58:40 <newsham> reactos has kernel32.dll src?
13:59:36 <phys_rules> I checked ReactOS
13:59:38 <phys_rules> it's fun
13:59:44 <phys_rules> but still far away from being something usable
13:59:54 <phys_rules> plus I've moved to Solaris 2.11 now..
14:00:25 <newsham> i'm not sure what they hope to accomplish by copying an existing design.
14:00:47 <SamB> newsham: they wish to have a maintainable version
14:01:03 <SamB> I mean, that people other than microsoft can maintain
14:01:06 <newsham> sure but it will always lag a few years behind whatever MS adds on to their system in each release
14:01:18 <newsham> it will be great for running xp apps in 2009
14:01:21 <phys_rules> newsham: I think the point is to provide a simple gaming system
14:01:35 <phys_rules> since lots of unix users don't have games..
14:01:53 <phys_rules> and they don't even need windows
14:01:53 <newsham> according to an xbox wiki, all xbox games run in-kernel.
14:01:58 <SamB> yes. but more importantly, if some feature or library is important to you or your bussiness, you can keep it as long as necessary...
14:02:22 <phys_rules> plus it's never bad to have another free os ;)
14:02:25 <SamB> yes, it will be great for running XP apps in 2009
14:02:29 <phys_rules> but I wonder if ReactOS will actually last
14:02:31 <SamB> which is an important application
14:02:34 <xerox> ...so game crashes will be BSOD by default :-D
14:02:55 <newsham> wine can run xp apps now.
14:03:11 <monochrom> blue wine :)
14:03:27 <phys_rules> I think ReactOS is somehow based on wine =)
14:03:54 <twb> SamB: especially after the poignant reminder when NT 4 end-of-lifed recently.
14:03:54 <xerox> Goodnight chaps.
14:04:14 <twb> xerox: bye
14:04:22 <SamB> anyhow, at this point they are shooting for NT 4 compat ;-)
14:04:47 <newsham> humans sure are an amusing breed
14:04:52 <twb> SamB: they're too late, then.  Everyone's dropped NT4 already.
14:05:01 <cinema> malcolm, I have problems when compiling Blobs. It looks like a version mismatch between (darcs Blobs) and (darcs HaXml)
14:05:10 <SamB> reactos has been around for a good while now...
14:05:19 <malcolm> cinema: symptoms?
14:05:27 <cinema> malcolm, the message is src/NetworkControl.hs:391:23:
14:05:27 <cinema>     The function `runParser' is applied to three arguments,
14:05:27 <cinema>     but its type `Parser t a -> [t] -> (Either String a, [t])' has only two
14:05:30 <SamB> twb: doesn't mean they only have things NT4 has
14:05:46 <malcolm> cinema: I'll go look
14:05:59 <cinema> malcolm, thanks.
14:06:13 <SamB> apparantly it finally has network support, at least sometimes
14:06:39 <cinema> malcolm, the offending instruction is 'case runParser parse () newInfo of'
14:07:19 <malcolm> cinema: yes I guessed that.
14:07:24 <SamB> cinema: thats Parsec, actually
14:07:32 <SamB> or not
14:07:34 * ADEpt is off to bed
14:07:36 <malcolm> cinema: I think this might explain my 'illegal instruction' crashes :-)
14:07:45 <ADEpt> SamB: i'll pull and check out you changes tomorrow
14:07:48 <monochrom> that looks like Parsec
14:08:05 <cinema> malcolm, good news then !
14:08:35 <twb> What's wrong with using map here?
14:08:35 <twb> main = do [filename] <- getArgs; map print =<< liftM lines (readFile filename)
14:08:37 <monochrom> I propose to remove ()
14:08:42 <cinema> I think there is a Parsec-like system in HaXml
14:08:49 <SamB> oh
14:08:51 <malcolm> cinema: I think my Makefile dependencies must be broken, cos that should have failed to compile here and it didn't even attempt to compile it.
14:08:57 <SamB> yeah, now I think I remember
14:09:19 <SamB> I think it was HXT that decided "rather than reinvent Parsec, why don't we just use that?"
14:10:33 <SamB> that () would have been the state argument to Parec's runParser
14:10:38 <monochrom> This is odd.  The things I said may be wrong.
14:10:43 <SamB> twb: you'd need mapM
14:10:51 <cinema> yes, and it should be a list
14:10:54 <SamB> or mapM_
14:11:20 <SamB> cinema: Parsec's runParser takes a polymorphic state arg
14:11:33 <monochrom> "runParser parse () newInfo" would be correct if Parsec were used.  If it's someone else's runParser I don't know.
14:11:47 <twb> SamB: thanks
14:12:03 <malcolm> cinema: OK, recompiling now
14:12:27 <cinema> the type of this parser (HaXml's) is 'runParser   -- :: Parser t a -> [t] -> (Either String a, [t])'
14:12:50 <phys_rules> btw, guys is darcs with libcurl faster than using wget ?
14:12:50 <SamB> jlouis: do you know where ADEpt's repo is?
14:12:56 <monochrom> In fact, IIRC, "runParser parse () newInfo" is correct for the current version of Parsec.  There was an old version with a different type signature.
14:13:00 <phys_rules> as I seem to get very slow speeds with darcs + wget
14:13:01 <malcolm> monochrom: the 'runParser parse () info' variant is correct with HaXml's PolyState combinators, but for the case where the state is unused, there is another set of (nearly identical) combinators called Poly.
14:14:13 <monochrom> Removing () seems the simplest.
14:14:21 <twb> phys_rules: libcurl *feels* about as fast as tla.
14:14:44 <SamB> jlouis: I'll just add the repos to AUTHORS
14:15:00 <malcolm> cinema: hurray! you fixed my 'illegal instruction' crash in Blobs.  darcs repo now updated.
14:15:39 <cinema> malcolm, well, it was accidental! Downloading now
14:16:00 <phys_rules> twb: ok, thanks :)
14:16:13 <malcolm> cinema: turned out there was another use of runParser with a state argument of () that needed removing too.
14:16:14 <twb> phys_rules: not a very useful datapoint, to be sure :-)
14:18:03 * malcolm notes that changing the type signatures in a package will not necessarily force recompilation of code that uses the package
14:19:29 <cinema> * there are some mysteries in ghc sometimes. I've seen that
14:19:55 <phys_rules> guys, what text editors do you usually use on unix ? :) except the emacs & vi(m)
14:20:16 <monochrom> Eclipse.
14:20:17 <cinema> malcolm, Super, Blobs' compilation was successfull
14:20:35 <phys_rules> monochrom: is the haskell plugin working well ?
14:20:57 <monochrom> The author makes it work better on Windows than on Linux.
14:21:41 <monochrom> He provides a Windows DLL for on-the-fly parsing, but not a Linux counterpart.
14:21:52 <phys_rules> darn
14:22:01 <monochrom> Also, (on all platforms), I don't like his builder.
14:23:11 <phys_rules> what I miss the most from windows is total commander :)
14:23:27 <phys_rules> mc is sort of like 90s
14:23:27 <SamB> phys_rules: try midnight commander
14:23:40 <SamB> plain, not the one with the G
14:23:41 <phys_rules> gnome-commander tries to imitate tc but is not too good at it
14:23:42 <neologism> what is total commander good for?
14:23:48 <cinema> malcolm, full success. I have been able to load wirings.blobs, and the 2 small examples I had done earlier. Bravo !
14:24:03 <SamB> wait, what is total commander?
14:24:09 <phys_rules> and then there's k... something
14:24:15 <SamB> if it isn't 90s?
14:24:15 <phys_rules> and it uses KDE, no thanks
14:24:20 <palomer> and then I got high
14:24:25 <phys_rules> SamB: it's mega advanced =)
14:24:31 <phys_rules> it has tabs=) zillions of plugins
14:24:37 <phys_rules> very good search
14:24:55 <phys_rules> fast copy with buffering
14:24:59 <SamB> on what keys?
14:25:18 <phys_rules> what is on what keys ? :)
14:25:24 <SamB> the search
14:25:30 <phys_rules> Alt-F7
14:25:32 <neologism> imho plain command line is the best
14:25:37 <SamB> not that kind of key
14:25:37 <neologism> you work very fast
14:25:39 <palomer> woot, finished my classes
14:25:42 <palomer> for EVER
14:25:47 <phys_rules> neologism: not always :)
14:25:52 <neologism> I'd say alway
14:25:53 <neologism> s
14:25:55 <monochrom> congrats palomer
14:26:18 <monochrom> A secretary is the best interface.
14:26:36 <phys_rules> it is easier for me to press Alt-F7 type a name (without having to put *aa* around it) and press a tab type 1 instead of doing a find / -name '*aa*' -m -time 1 -print and so on =)
14:26:44 <palomer> if I don't have a masters degree by next fall, I'm quitting the masters program
14:26:54 <palomer> and that's final!
14:26:56 <SamB> monochrom: a commandline-using secretary or a GUI-using secretary?
14:27:14 <palomer> monochrom: does refinement calculus let you specify things in term of fixed points?
14:27:16 <monochrom> You just tell the secretary to delete the files.  Plus she knows which files.
14:27:17 <neologism> phys_rules: a matter of habit Id say
14:27:24 <monochrom> Yes, palomer.
14:27:26 <SamB> you say "delete the files"?
14:27:45 <phys_rules> neologism: I've been used to both, but lately I find the intuitive ways better ;)
14:27:59 <palomer> monochrom: do you really think we'll be writing our programs in terms of the refinement calculus in the future?
14:28:01 <monochrom> The secretary is free to choose how he/she does it.
14:28:04 <phys_rules> the unix comamands land is a bit old nowadays
14:28:12 <neologism> phys_rules: no doubt there
14:28:20 <neologism> but for file browsing etc. its still the best Id say
14:29:09 <monochrom> I already think in terms of the refinement calculus or similar calculi.
14:29:32 <palomer> monochrom: do you think it  could be the basis of a programming language?
14:30:07 <twb> I've never even heard of the refinement calculus.
14:30:10 <monochrom> It is already the basis of programming languages.  ESC/Java already uses the weakest precondition semantics.
14:30:12 <twb> paper url?
14:30:37 <twb> monochrom: is it something like AOP?
14:30:42 <monochrom> No.
14:31:11 <phys_rules> thing like [=  . >> %^$ already start to look ackward in languages =)
14:31:26 <twb> phys_rules: oh, you are a lisper? ;-D
14:31:27 <phys_rules> maybe everyone will switch to unicode or something hehe
14:31:33 <phys_rules> two: no-no! ;)
14:31:36 <phys_rules> not a purist LOL :)
14:31:39 <monochrom> In the future I just tell my secretary to write programs to my specs.
14:31:53 <palomer> monochrom: is there a paper describing various functions in terms of the refinement calculus (factorial, max, min, fibonnacci, etc...)?
14:32:01 <twb> monochrom: so you're going into *management*?  You poor bastard.
14:32:10 <twb> palomer: yeah!
14:32:14 <twb> paper! paper! paper!
14:32:27 <phys_rules> twb: the point is of course it would be better just to have the original math symbols, but they're not ASCII ... :\
14:32:27 <monochrom> I'm going into the arts.  I let my secretary do my programming.
14:32:39 <twb> phys_rules: fuck ascii.  utf-8, man!
14:32:51 <phys_rules> true, but what about keyboard now
14:32:51 <phys_rules> hehe
14:32:56 <phys_rules> maybe haskell keyboard
14:32:57 <twb> phys_rules: http://twb.ath.cx/~twb/src/my-elisp/pretty-symbols.el
14:32:58 <monochrom> When my secretary can code for me, I will finally have time to learn conducting.
14:33:11 <twb> @google space cadet keyboard
14:33:12 <lambdabot> http://world.std.com/~jdostale/kbd/SpaceCadet.html
14:33:22 <twb> @botsnack
14:33:22 <lambdabot> :)
14:33:57 <monochrom> There is a body of papers, not a single paper.  You can go through Ralph Back's paper list.
14:34:07 <twb> I have this image of a USB to PS/2 to AT to individual pins adaptor tangle :-)
14:34:32 <palomer> I'm looking at http://www.ecs.soton.ac.uk/~mjb/refcalc-tut/home.html
14:34:42 <phys_rules> space cadet rocks =)
14:34:44 <palomer> and,erm, the specification language doesn't seem any more intuitive than, say, haskell
14:34:59 <SamB> phys_rules: before Haskell keyboard, we need GHC to be able to parse utf-8
14:35:13 <monochrom> programming is never intuitive
14:35:30 <phys_rules> SamB: true =) are there plans for 6.6 ? =)
14:35:36 <twb> monochrom: Only nipples are intuitive.
14:35:41 <twb> And apparently floating.
14:35:48 <SamB> and personally I need James Clark to add support for coexistance with mule-ucs to nxml/rng-validate-mode
14:36:04 <SamB> phys_rules: it is indefinately postponed, last I knew
14:36:16 <monochrom> Or rather, see http://www.vex.net/~trebla/weblog/intuitive.html
14:36:19 <SamB> until they figure out how to do it right
14:36:40 <phys_rules> SamB: sounds fare enough, there are better things to do now..
14:36:57 <phys_rules> fair enough
14:36:58 <phys_rules> gee =)
14:37:01 <phys_rules> must be the late hour =)
14:37:45 <SamB> floating doesn't have to be intuitive, there is nothing at all to it
14:37:59 <SamB> you just sit there and... float
14:38:19 <SamB> even an unborn baby can do it
14:38:22 <phys_rules> is there a btorrent client written in haskell ? 
14:38:23 <twb> SamB: I was alluding to.
14:38:26 <twb> ...yeah
14:38:29 <SamB> thought so
14:38:30 <palomer> monochrom: what I mean to say is that the the specifications in the refinement calculus look like computer programs
14:39:04 <twb> SamB: I assume you also got the nipple reference?
14:39:08 <SamB> yes
14:39:12 <monochrom> specifications generalize programs. some specifications will look like programs. some will be almost programs. and finally some are programs.
14:39:19 <SamB> nipples are for nursing ;-)
14:39:37 <monochrom> Some complex numbers look like real numbers, too.
14:39:42 <SamB> babies know what to do with them right out of the womb
14:41:03 <yozora> phys: i think it's conjure
14:41:12 <yozora> http://j.mongers.org/pub/haskell/darcs/conjure/
14:41:44 <cinema> malcoml, Finally, 2 small problems with HaXml build system. 1) after compiling, 'make clean; make' loops 2) './configure --buildwith=ghc --buildopts="-O2"' is not sufficient to build an optimised version, I had to modify src/Makefile to put the '-O2' flag in ghc command line
14:42:18 <malcolm> cinema: OK, will note those and fix
14:42:52 <phys_rules> yozora: thanks!
14:43:53 <phys_rules> I wonder if ghc will be fast one day .. =)
14:45:35 <earthy> you mean, you don't find ghc to be fast?
14:46:09 <malcolm> the compiler itself is slow, even if it produces reasonably fast output
14:46:31 <monochrom> how slow is slow?
14:46:38 <phys_rules> earthy: I meant the compiling ;)
14:46:47 <phys_rules> the code produced is good ;)
14:47:31 <twb> monochrom: when it takes over a fortnight to compile the compiler on a 6000 bogomips machine with 1Gb or ram.
14:47:42 <gzl> a FORTNIGHT?
14:47:51 <twb> I don't know, the machine caught fire on the ninth day.
14:47:54 <gzl> haha
14:48:16 <phys_rules> what's 6*10^3 bogomips in Mhz ? =)
14:48:16 <monochrom> Bear in mind that HM type inference is like doubly exponential or something.  A compiler for it cannot be fast.
14:48:28 <twb> Well, FSVO "caught fire" = "CPU overheating,  aaaaaaah!" 
14:48:46 <twb> phys_rules: a 3GHz P4
14:49:22 <monochrom> Now throw in rank-N polymorphism where N=1,2,3, fundeps, and existential types.
14:49:31 <phys_rules> well, I'm on a 850Mhz athlon =))
14:50:05 <twb> I'm actually "on" a 1400 bogomips mac.
14:50:13 <twb> The 6000 bogomips machine is the server.
14:50:34 <monochrom> And so I don't understand the logic behind comparing a haskell compiler with g++.  Like, do you ever say, gee, this SAT solver is so slow, it's even slower than booting up Windows!
14:51:48 <twb> Because C++ users expect compilation to be part of the test-change cycle.
14:52:26 <monochrom> Oh and Windows lusers expect rebooting to be part of the crash-reboot cycle too.  So?
14:52:37 <twb> That's why they think compile time is important.
14:52:43 <phys_rules> twb: of course it should be slower than compiling plain C because of all the type inferrence and all but still one always dreams of faster speeds =)
14:52:54 <monochrom> They be damned.
14:53:05 <twb> phys_rules: the fortnight figure is for Stalin.
14:53:15 <phys_rules> actually my windows boots up in 15 seconds =)
14:53:21 <twb> http://en.wikipedia.org/wiki/Stalin_(Scheme_compiler)
14:53:51 <twb> http://en.wikipedia.org/wiki/Stalin_scheme_compiler
14:54:16 <monochrom> I do think ghc can be made still faster in the future, but bear in mind it solves a problem in an entirely different complexity class.
14:55:17 <monochrom> At the end of the day, you are choosing between providing your own type signatures (a la C++) or have them inferred (a la HM, SML, Haskell).  You must choose your poison.
14:55:24 <phys_rules> twb: hehe interesting choice of name there =)
14:56:20 <phys_rules> monochrom: yeah, but even in haskell it's good at times to specify the type, otherwise you can get in a mess with type errors =)
14:56:51 <eivuokko> I find ghc much faster than any c++ compiler I have used for practical programs.
14:57:12 <monochrom> Yes, the exported things usually have sane types and can be easily written manually.
14:57:46 <monochrom> The local definitions you use in the implementation is completely another story.
14:58:44 <twb> monochrom: there is a third alternative.
14:59:12 <twb> Dynamic typing, with static type declarations for bottleneck code.
14:59:49 <monochrom> Why has no one complained that perl or python is slower than ghc-generated code, speaking of which?
15:00:10 <phys_rules> monochrom: we didn't complain about the generated code speed ;)
15:00:13 <phys_rules> the speed is good =)
15:00:16 <twb> Because the shouldn't be used in production code? ;-)
15:00:21 <twb> s/the/they/
15:00:38 <monochrom> I mean I hope you see what are fair comparisons and what aren't.
15:01:27 <twb> I never said that it was a valid rationale to compare GNU C++ and GHC compile times.  I just said what the rationale was.
15:01:28 <monochrom> Now, if only we had a polynomial-time algorithm for the halting problem...
15:02:16 <mwc> monochrom, I have one
15:02:21 <mwc> of infinite degree
15:02:34 <monochrom> I want a cubic.
15:02:38 * mwc pimps the arbitrariness of "polynomail time"
15:02:56 <mwc> and I want a Harrier jumpjet for getting to work
15:02:56 <monochrom> I actually know how to play that game, mwc.
15:03:37 <mwc> Hahah, "I can see you've played knifey-spoony before."
15:05:06 <twb> Is there a function like Lisp's READ?
15:05:37 <monochrom> I forgot what READ does.
15:05:50 <twb> e.g. if the file contained '(1,2,"harry") 4', it would return a tuple (1,2,"harry")
15:06:12 <twb> I think Java people call it serializability or something.
15:06:32 <monochrom> It's probably called "readIO" in Haskell.
15:06:43 <monochrom> @type readIO
15:06:44 <lambdabot> forall a. (Read a) => String -> IO a
15:07:01 <twb> @index readIO
15:07:02 <lambdabot> System.IO, Prelude
15:07:26 <monochrom> It wants to read from a string.  (Think of it as sscanf)
15:07:37 <twb> readIO . read, then
15:08:07 <monochrom> Here is a non-IO version.  It's called read.  It also wants to parse a string.  If the parse fails, it aborts.
15:08:31 <monochrom> > read "(1,2,\"harry\") 4"
15:08:31 <phys_rules> twb: yeah, but in java you'd have to implement your own serialization the default one won't be in plain text ;)
15:08:32 <lambdabot> Add a type signature
15:08:45 <monochrom> > read "(1,2,\"harry\") 4" :: (Int,Int,String)
15:08:46 <lambdabot> Prelude.read: no parse
15:08:55 <monochrom> > read "(1,2,\"harry\")" :: (Int,Int,String)
15:08:56 <lambdabot> (1,2,"harry")
15:09:03 <monochrom> That should be good enough.
15:09:07 <twb> Cool.
15:09:26 <twb> So it was called read after all! :D
15:09:38 <malcolm> @hoogle read
15:09:38 <lambdabot> Prelude.Read :: Read a
15:09:38 <lambdabot> Prelude.read :: Read a => String -> a
15:09:38 <lambdabot> Text.Read.Read :: Read a
15:09:42 <twb> I was lead astray by ignorance and bad memory.
15:09:47 <monochrom> readIO throws an IO exception.  Then you can catch it.
15:10:53 <monochrom> @type reads
15:10:54 <lambdabot> forall a. (Read a) => ReadS a
15:11:17 <SamB> @hoogle ReadS
15:11:18 <lambdabot> Prelude.ReadS :: String -> [(a, String)]
15:11:18 <lambdabot> Prelude.reads :: Read a => ReadS a
15:11:18 <lambdabot> Text.ParserCombinators.ReadP.ReadS :: String -> [(a, String)]
15:11:20 <twb> What does the s do?
15:11:35 <SamB> twb: well, ReadS is a type
15:11:35 <monochrom> If you really want to work with "(1,2,\"harry\") 4" and have it do the "right thing", you can use reads, and you will write a lot more code.
15:11:39 <twb> Ah.
15:12:00 <monochrom> type ReadS a = String -> [(a,String)]
15:12:24 <SamB> part of the "list of successes" school of parsing
15:12:31 <monochrom> > reads "(1,2,\"harry\") 4" :: [((Int,Int,String), String)]
15:12:32 <lambdabot> [((1,2,"harry")," 4")]
15:12:34 <SamB> @hoogle ReadM
15:12:35 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
15:12:35 <lambdabot> System.IO.ReadMode :: IOMode
15:12:35 <lambdabot> Data.Graph.Inductive.Internal.Thread.threadMaybe' :: (r -> a) -> Split t
15:12:35 <lambdabot> i r -> Split t j (Maybe i) -> Split t j (Maybe a)
15:12:44 <SamB> @hoogle ReadP
15:12:45 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: ReadP a
15:12:45 <lambdabot> Prelude.readParen :: Bool -> ReadS a -> ReadS a
15:12:45 <lambdabot> Text.ParserCombinators.ReadP.readP_to_S :: ReadP a -> ReadS a
15:13:23 <monochrom> ReadP is easier to use (monad do-notation applies), but not part of the standard.
15:13:43 <SamB> you can use Parsec, too...
15:13:52 <SamB> but its more work than it ought to be
15:14:04 * SamB thinks Parsec should include a utility function for that
15:14:31 <twb> SamB: don't say that!
15:14:56 <twb> I have high hopes for Parsec as the basis of a nice wikiscript parser.
15:15:05 <malcolm> HaXml now has a monadic parser replacement for the Read class
15:15:19 <malcolm> like Parsec only simpler
15:15:24 <SamB> twb: I mean, it ought to be like
15:15:55 <SamB> instance Read Foo where reads = parsecReadS parsecParser
15:16:14 <SamB> but instead you have to case over the result of runParser yourself...
15:16:52 <SamB> twb: I was not referring to the effort involved in actually *writing* the parser ;-)
15:17:24 <dons> moin
15:17:25 <twb> Man, I wish ? was valid in identifiers.
15:17:38 <SamB> twb: it is, sometimes
15:17:39 <dons> > let (?) = 4 in (?)
15:17:40 <lambdabot> 4
15:17:40 <twb> predicatep is so lame.
15:17:47 <SamB> only you wouldn't like that kind
15:18:21 <SamB> > let (foo?) = 4 in (foo?)
15:18:21 <lambdabot>  Parse error in pattern
15:18:24 <dons> > let x ? y = 4 in 2?7
15:18:25 <lambdabot> 4
15:18:32 <SamB> > let foo? = 4 in foo?
15:18:34 <lambdabot>  parse error on input `='
15:18:37 <dons> nah, not like that.
15:18:45 <SamB> > let ?foo = 4 in ?foo
15:18:46 <lambdabot>  parse error on input `?'
15:18:50 <malcolm> > let foo (?) = 4 in foo (?)
15:18:50 <dons> either all var syms or all alpha nums
15:18:51 <lambdabot>  Not in scope: `?'
15:19:06 <SamB> dons: I was trying to get it to do the dynamic-scope thing
15:19:23 <dons> oh. yes, I see. don't think that is turned on anyway
15:19:24 <malcolm> > let foo (?) = 4 in foo (+)
15:19:25 <lambdabot> 4
15:20:03 <dons> and this: http://www.cse.unsw.edu.au/~dons/pretty.html
15:21:58 <twb> Woo, another aussie!
15:22:20 <dons> hi twb.
15:22:26 <twb> dons: hullo
15:22:30 <dons> @map
15:23:09 <dons> @bot
15:23:10 <lambdabot> :)
15:23:15 <SamB> what is with all the U+007Fs?
15:23:33 <SamB> > length ""
15:23:34 <lambdabot>  lexical error in string/character literal
15:23:35 <dons> oh, oops. wifi bad fi
15:23:44 <dons> @map
15:23:45 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:23:46 <SamB> wifi bad fi?
15:23:50 <sethk> dons, looks like you are playing dominos
15:24:12 <SamB> where did you get all the 00/7F dominos?
15:24:14 <sethk> dons, or mahjong
15:24:35 <SamB> if he's playing mahjong, he's surely doing horribly
15:24:43 <SamB> because those tiles should be *gone*
15:27:16 <dons> since moving to wireless, sometimes I notice funny strings like that dumped  into my instance of irssi running remotely. very rarely though
15:27:36 <SamB> wow
15:27:40 <SamB> thats not good at all!
15:27:43 <dons> I was going to say, twb: check the map, we have a bunch of .au hackers.
15:27:44 <phys_rules> @where fps
15:27:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:27:52 <SamB> I thought there were, like, checksums or something
15:27:58 <dons> it's a bit weird, isn't it SamB.
15:28:41 <dons> this is wireless boardbad though, over a secret/proprietary network protocol.
15:28:49 <dons> broadband.
15:29:05 <dons> so who knows how many bugs they have in their network code
15:30:12 <twb> Dirty broadcom bastards.
15:32:19 <phys_rules> @where MissingH
15:32:19 <lambdabot> http://quux.org/devel/missingh
15:34:16 <twb> This is the news.  I'm sorry I'll read that again: "here are the news".
15:36:09 <CosmicRay> dons: but, TCP has checksums
15:36:14 <CosmicRay> how could that possibly happen?
15:36:47 <eivuokko> Maybe they don't tunnel whole tcp, but only data.
15:37:00 <CosmicRay> eh?
15:37:10 <CosmicRay> that can't work
15:37:41 <CosmicRay> phys_rules: there's also a darcs repo at http://darcs.complete.org/missingh
15:37:42 <dcoutts> is there any sequence ADT in the standard libs with effecient split and join operations (and therefore effecient random insert and delete)
15:38:03 <CosmicRay> I guess it's possible that they are converting it to some format and then reconverting it at the other end, but that would not make a whole lot of sense
15:38:29 <eivuokko> It is possible.  And sense isn't likely to enter if they manage to inject stuff into stream :)
15:38:41 <eivuokko> Most likely it is something else, tho
15:38:46 <dons> yeah, maybe.
15:39:52 <malcolm> dcoutts: tried Adrian Hey's AVL trees?
15:40:08 <malcolm> dcoutts: scratch that, it isn't a sequence!
15:41:52 <luqui> ignore this
15:42:19 <luqui> ignore this
15:42:59 <Cale> dcoutts: Does Map from some suitable index type count? :)
15:44:00 <dcoutts> Cale, no, because it does not allow one to insert elements inbetween existing elements
15:44:17 <dons> ski, I closed down your clever lambdabot trick
15:44:34 <dons> you get random identifiers each time, now.
15:44:50 <SamB> dons: what trick was that
15:44:54 <dons> also, I'm not sure why, but it appears to have been using a differrent compiler last night. weird. fixed that too.
15:44:59 <SamB> 44:10
15:45:05 <wilx> Use float, make the new index as average of left and right indexes :)
15:45:14 <dons> SamB:
15:45:15 <Cale> dcoutts: well, you choose an index between the existing elements indices
15:45:15 <dons> 07:56:49 <ski> > xxxx
15:45:16 <dons> 07:56:49 <lambdabot> Add a type signature
15:45:17 <dons> 07:56:54 <ski> > xxxx :: ()
15:45:18 <dons> 07:56:55 <lambdabot> Loop
15:45:38 <Cale> dcoutts: if you use, say Rational, as your index type, this is always possible :)
15:45:45 <dons> he worked out my internal top-secret identifier used to tag code that is typed in ;)
15:45:48 <dcoutts> Cale, well one can't do that with fixed size index types
15:46:09 <dons> SamB, leading to tricks like:
15:46:10 <dons> 07:58:07 <int-e> > 1 : scanl (+) 1 xxxx
15:46:10 <dcoutts> I guess I want something from here: http://www.haskell.org/ghc/docs/edison/
15:46:10 <dons> 07:58:08 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
15:46:14 <Cale> yeah, it's a little cheap :)
15:46:35 <phys_rules> darn, one package needs cabal 1.0.4 the other needs 1.0, gee =)
15:46:46 <jethr0> dons: and there i was, really impressed with this xxxx operation ;-))
15:47:01 <dons> hehe
15:47:18 <dons> phys_rules, really?? won't a later cabal always work?
15:47:22 <SamB> phys_rules: recompile the latter
15:47:33 <jethr0> what about the other solution with "fix"? is that a real function for finding fix points??
15:47:47 <triplah__> what happens when im mapping a function to something, but the function requires a function as an argument, whic also needs to work on the same peice of data?
15:47:53 <triplah__> optAlign m mm sp str1 str2 = let z = (align str1 str2) in map (\x -> minimaBy (costString m mm sp (fst x) (snd  x)) z) z
15:48:00 <phys_rules> dons: not on MissingH =)
15:48:05 <triplah__> minimaBy needs to for on my list z
15:48:16 <triplah__> but costString needs to work on it first
15:48:30 <phys_rules> The field "hs-source-dir" is deprecated, please use hs-source-dirs.
15:48:30 <phys_rules> Cabal: MissingH.cabal:80: Parse of field 'extensions' failed
15:48:51 <dons> oh. fun fun.
15:48:54 <dons> @seen kzm
15:48:55 <lambdabot> kzm is in #haskell-overflow, #flippi, #haskell-blah and #haskell. Last
15:48:55 <lambdabot> spoke 9 hours and 21 seconds ago.
15:51:44 <phys_rules> time to sleep
15:51:46 <phys_rules> good night people ;)
15:51:50 <jethr0> nite
15:52:08 <twb> What is flatten called in Haskell?
15:52:14 <arjanb> concat
15:52:15 <dons> conccat?
15:52:39 <dons> > concat ["a", "b"]
15:52:40 <lambdabot> "ocshhdqai"
15:52:48 <dons> umm..
15:52:58 <jethr0> must be a feature!
15:53:00 <wilx> Hehe.
15:53:01 <twb> No, I mean [[1,2],[3,4]] ===> [1,2,3,4]
15:53:18 <wilx> > concat ["c","d"]
15:53:19 <twb> Ah.
15:53:19 <lambdabot> "dgfelmvce"
15:53:22 <arjanb> > concat [[1,2],[3,4]]
15:53:23 <lambdabot>  add an instance declaration for (Num Char)
15:53:23 <lambdabot>   In the list element: 4
15:53:23 <lambdabot>   In the list element: [3, 4]
15:53:24 <dons> did I break lambdabot in my last patch.. hmm.
15:53:25 <wilx> Wth?!
15:53:25 <jethr0> huh?
15:53:28 <twb> It works on the REPL, anyway.
15:53:31 <eivuokko> Heh.
15:53:34 <dons> I think i broke something *bad*
15:53:37 <wilx> @eval concat ["c","d"]
15:53:38 <lambdabot> "bxpmdbvbc"
15:53:50 <wilx> Indeed.
15:53:54 <dons> > 1 + 2
15:53:55 <lambdabot>  add an instance declaration for (Num [Char])
15:53:57 <SamB> I didn't have any trouble building MissingH!
15:54:14 <SamB> and my cabal is not 1.0
15:54:15 <jethr0> > show "mumble, if you are severly bOrken"
15:54:16 <lambdabot> "eimbgxivr"
15:54:24 <SamB> dons: you been playing with Ptrs again?
15:54:36 <dons> sigh.
15:54:40 * SamB teases dons
15:55:03 <dons> ah,no no . one indirection via 'show' too many
15:55:18 <jethr0> maybe there should be a unit test framework for the lambdabot modules ;-)
15:55:36 <dons> it should be a literal imbgxivr in the generated src, not a "imbgxivr"
15:55:39 <SamB> dons: 44:20
15:55:43 <dons> which leads to silly results..
15:55:49 <dons> SamB, cool.
15:56:04 <jethr0> what kind of a silly literal is "imbgxivr"?
15:56:18 <dons> see earlier discussion about 'xxx' hacks
15:56:27 <dons> it's a unique sym
15:56:28 <jethr0> ah, gensyms.
15:56:32 <twb> What is remove-if-not called?
15:56:32 <dons> yah.
15:56:50 <dons> twb, do you have access to the list lib docs?
15:56:55 <dons> @docs Data.List
15:56:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:57:10 <jethr0> (newbie speaking): although gensyms don't make a great security mechanism!
15:57:38 <dons> well, it's different each run, so that's ok. and the only thing you can do anyway is write a loop
15:57:45 <dons> let xxx = my code.
15:57:56 <dons> all you can do is call xxx again.
15:58:04 <dons> shrug, no big deal, I think.
15:58:04 <triplah__> optAlign m mm sp str1 str2 = let z = (align str1 str2) in minimaBy ( map (\x -> costString m mm sp (fst x) (snd  x)) z) z
15:58:11 <triplah__> thats saying map ios applied to too many arguments
15:58:16 <triplah__> is*
15:59:37 <SamB> > x where x = x
15:59:38 <lambdabot> "gdpirqocr"
16:00:08 <SamB> > x where x = x
16:00:09 <lambdabot> "rfqbddlzr"
16:00:24 <triplah__> is lambdabot broken?
16:00:27 <jethr0> > "hello"
16:00:28 <lambdabot> "ynfouqoer"
16:00:33 <triplah__> well haha
16:01:00 <jethr0> > "are you broken, oh almight lambdabot?"
16:01:01 <lambdabot> "viscilyme"
16:01:11 <triplah__> > ?
16:01:11 <lambdabot>  parse error on input `?'
16:01:15 <triplah__> bah :)
16:01:15 <jethr0> > "almighty*"
16:01:17 <lambdabot> "fjxybmagq"
16:01:18 <dons> hah!
16:01:39 <dons> at least the parser still works ;)
16:01:44 <triplah__> haha
16:02:03 <triplah__> http://paste.lisp.org/display/14223#4
16:02:04 <jethr0> maybe we just need naked priestesses to interpret the oracles responses.
16:02:16 <twb> jethr0: you rang?
16:02:16 <triplah__> anyone care to tell me what i'm doing wrong with map?
16:02:39 <jethr0> twb: ??
16:02:46 <triplah__> haha
16:03:15 <twb> jethr0: I'm a wholesale supplier of naked priestesses.
16:03:18 <SamB> twb: you are a priestess?
16:03:33 <dons> > map (+1) [1..10]
16:03:34 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
16:03:57 <jethr0> twb: oh well. i was inquiring whether you would have any oracle decyphering one in stock?
16:04:18 <jethr0> ones*
16:04:19 <triplah__> > foldl1 (+) [1..10]
16:04:20 <lambdabot> 55
16:04:22 <twb> jethr0: which type of oracle?
16:04:51 <jethr0> twb: the kind that responds in a garbled fashion to questions and prayers.
16:04:55 <twb> The skeins of time or database?
16:05:11 <jethr0> i guess it would be a modern version of the delphi series.
16:05:26 <twb> giggle
16:05:28 <triplah__> haha
16:05:31 <jethr0> skeins??
16:05:34 <twb> We don't take kindly to Pascal here.
16:05:49 <twb> @google define:skein
16:05:49 <lambdabot> No result found.
16:05:52 <jethr0> isn't that the guy with the triangles?
16:05:57 <jethr0> or was that sierpinsky?
16:06:00 <SamB> > isSpace '\n'
16:06:02 <lambdabot> True
16:06:09 <triplah__> haha
16:06:15 <SamB> jethr0: the oracle is gone anyways
16:06:18 <twb> jethr0: Delphi was once called Pascal.
16:06:37 <triplah__> > length "\n"
16:06:38 <lambdabot> 1
16:06:49 <twb> I've always felt that naming a language after a dead mathematician is a bit like graverobbing.
16:06:50 <jethr0> tough luck. now we will never make the effort to try solving the problem with naked priestesses *grumble*
16:06:58 <SamB> actually, Pascal ain't that bad, as long as it isn't standard
16:07:00 <triplah__> twb: troll!
16:07:01 <triplah__> :D
16:07:30 <jethr0> twb: i'm not sure about _your_ age. but my whole adolescense was dominated by pascal!
16:07:33 <triplah__> almost as bad as naming an expressive language after a speech inpediment
16:07:34 <twb> Well, do you reckon Ada or Blaise would approve of their names being appropriated?
16:07:34 <triplah__> :P
16:07:47 <jethr0> you mean lovelace?
16:07:47 <triplah__> impediment*
16:07:55 <twb> Her first name is Ada.
16:08:01 <twb> *was, rather.
16:08:36 <SyntaxNinja> Ada is a nice name
16:08:49 <SamB> how do you make happy give reasonable error messages?
16:09:38 <twb> Languages should have proper names, like "an altered state of mind"
16:09:39 <malcolm> There was a fashion for naming languages after female firstnames
16:09:40 <lispy> SamB: by using parsec :)
16:09:43 <SamB> but apparantly Ada protects things from concurrent access with an armed guard..
16:09:48 <malcolm> Ada, Miranda
16:09:50 <twb> "I always program in an altered state of mind!"
16:09:51 <SamB> lispy: hmm.
16:10:05 <malcolm> Drusilla...
16:10:37 <Philippa> twb: I had a language called Tyop which bore the brunt of some type system experiments
16:10:47 <twb> *Typo?
16:10:53 <jethr0> perl
16:11:00 <twb> Or is that [sic]?
16:11:36 <jethr0> having a language called either "Typo" _or_ "Tyop" is simply hilarious.
16:12:08 <jethr0> although i would imagine the novelty to wear off pretty quickly and experiencing some pains having to explain the name for the thousands time
16:12:12 <twb> We should make one just called "Enterprise".
16:12:21 <twb> To piss off all the buzzword companies.
16:12:24 <Philippa> twb: the spelling is indeed correct. OTOH, you can guess how it's derived
16:12:32 <Gs30ng> Can't i use 'where' when i'm using a guard?
16:12:50 <dons> Gs30ng, sure.
16:13:12 * Lor intends to name a language "Overkill".
16:13:14 <Lor> Once I have a language, that is.
16:13:19 <malcolm> 'where' scopes over all the guards in a single clause
16:13:36 <triplah__> argh
16:13:44 <triplah__> i really am stuffed here
16:13:51 <triplah__> map (\x -> costString 0 1 2 (fst x) (snd  x)) (align "xx" "yy")
16:13:52 <astrolabe> dons: is it possible for @eval to see the outputs of other @ commands, @where for instance?
16:14:09 <triplah__> i want to man another function over that
16:14:11 <triplah__> map*
16:14:17 <dons> > let f x | x == y = 3 | otherwise = 7 where y = 2 in f 0
16:14:18 <lambdabot> 7
16:14:31 <Cale> triplah__: (\(x,y) -> costString 0 1 2 x y)
16:14:37 * jethr0 likes the naming of scheme implementations: stalin chicken bigloo gambit rabbit
16:14:37 <dons> astrolabe, yes, this would be possible. why?
16:14:56 <Cale> triplah__: map f . map g = map (f . g)
16:15:14 <triplah__> ooo
16:15:20 <triplah__> havent try composition yet
16:15:24 <triplah__> tried*
16:15:28 <astrolabe> dons: I just think it would be cool.  Does 'would be' mean it is not possible at the moment?
16:15:36 <Cale> triplah__: well, not so much composition that I'm pointing at
16:15:36 <twb> jethr0: is there a pattern to those?
16:15:54 <Cale> but that you can combine mapped functions
16:15:56 <jethr0> guile, hobbit, hotdog, shoe, ...
16:16:02 <dons> it is not possible without writing code. but not much code ;)
16:16:11 <triplah__> Cale: hmmm check this link out of you'd be so kind
16:16:12 <dons> but I'd like to see an example of why this would be cool..
16:16:16 <triplah__> http://paste.lisp.org/display/14223#4
16:16:17 <jethr0> twb: i am not sure. although many of them seem to be referring to small mammels or animals
16:16:23 <astrolabe> dons: ok I'll think about it.
16:16:33 <Cale> triplah__: looking at it
16:16:39 <Cale> what should I be looking for?
16:16:49 <twb> Cale: walri!
16:17:02 <jethr0> mammals*
16:17:04 <Cale> twb: heh
16:17:05 <triplah__> Cale: i need to map costString over the list, then filter them using minimaBy. 
16:17:06 <twb> (multiple walruses)
16:17:15 <jethr0> hehe
16:17:31 <Cale> triplah__: then, why is minimaBy being applied to the costs?
16:17:35 <astrolabe> dons: say I want to see on the fly, which people have mentioned my name in the last hour.
16:17:40 <triplah__> Cale: but i dont want the result of costString returned, i want the value the cost represented in the original list
16:17:42 <jethr0> "multiple walrusses" is an oxymoron or a tautology or something like that!
16:18:05 <twb> This looks like a job for... ITERATE!
16:18:09 <Cale> triplah__: what's the type of minimaBy?
16:18:27 <dons> ah, astrolabe, you want a scripting interface to lambdabot!
16:18:28 <twb> Except Haskell doesn't have iterate :-(
16:18:28 <astrolabe> If there was an @ command to veiw what people have said, you could write it in a line of haskell.
16:18:36 <triplah__> Cale: minimaBy :: (Ord a) => (a1 -> a) -> [a1] -> [a1]
16:18:43 <jethr0> ITERATE to the rescue. to guard the weak against the wicked. to infinity and beyond ;-)
16:18:46 <astrolabe> dons: yeah, probably, that sounds right.
16:18:53 <Cale> triplah__: okay, and what's the type of the thing you're currently passing it?
16:19:22 <twb> (iterate (for element in list) (finding element (minimizing (cost element))))
16:19:37 <triplah__> Cale: list of int as far as i can see
16:19:46 <Cale> triplah__: which isn't a function
16:19:51 <jethr0> twb: i think to remember that iterate can be easily implemented with fold and unfold????
16:19:56 <triplah__> hmm
16:20:12 <triplah__>  map (\x -> costString 0 1 2 (fst x) (snd  x)) (align "xx" "yy")
16:20:14 <triplah__> this works
16:20:16 <twb> jethr0: if you can show how to do each ITERATE clause in Haskell, I will hug you.
16:20:18 <triplah__> it gives me back a list of int
16:20:25 <Cale> triplah__: right, a list of the costs
16:20:29 <jethr0> or maybe the fac that i haven't slept for 40 hours could finally take its toll *g*
16:20:31 <Cale> but that's not what you want, is it?
16:20:32 <twb> jethr0: let me dig up the manual.
16:20:46 <triplah__> Cale: so i want to get the string patterns represented by the smallest costs
16:20:57 <Cale> why not use minimaBy instead of map?
16:21:08 <jethr0> twb: where did they introduce iterate again. was that in SICP??
16:21:20 <twb> jethr0: it's a CL macro.
16:21:36 <triplah__> Cale: lordy lord. im an idiot
16:21:39 <triplah__> thanks for that
16:21:43 <Cale> no problem :)
16:21:53 <dons> astrolabe, we could expose the (private, read-only) state over modules to a script module that lets you run haskell code over the values
16:22:20 <dons> each module would, perhaps, proovide a nice [a] form for getting at their state, and some docs about the state type
16:22:22 <twb> http://twb.ath.cx/tmp/iter-man.pdf
16:22:46 <dons> astrolabe, very interesting idea!
16:22:50 <astrolabe> dons: yeah.!
16:22:51 <jethr0> twb: ah yeah, i remember. i've seen it before for building class instances on the fly!
16:23:08 <astrolabe> dons: thanks. 
16:23:35 <jethr0> twb: i think i was just talking out of my *** back there... but then again, there's my excuse of not having slept much recently ;-)
16:23:35 <dons> i'll think some more about how this would work. (i've previously pondered similar ideas with yi)
16:23:38 <twb> iterate is where it's at for iterating over data structures.
16:24:01 <twb> jethr0: maybe we could issue it as an open challenge to the Haskell community.
16:24:05 <astrolabe> dons: sorry, I won't be able to help.  I don't know enough.
16:25:09 <wilx> Hm, I don't think there is any such all-powerful function in Haskell.
16:25:10 <twb> "Write the most concise, elegant function or set of functions to duplicate ITERATE's functionality."
16:25:38 <jethr0> why not. but what are the challenges? do you really think it would be difficult to implement? what would the possible problems be?
16:25:42 <wilx> You will have to rewrite each of its uses into something Haskellish.
16:26:06 <triplah__> isnt iterate not purely functional?
16:26:09 <twb> wilx: in the introduction it gives a couple that are quite hard to do in a purely functional way.
16:26:23 <twb> wilx: specifically the stuff with FINDING.
16:26:29 <jethr0> twb: looks pretty much like list comprehensions to me in the simple examples.
16:26:33 <triplah__> i suppose you could use monads to simulate interate
16:26:35 <twb> Yeah.
16:26:48 * twb doesn't like list comprehensions.
16:26:50 <triplah__> bah jethr0 beat me to it
16:26:51 <triplah__> :)
16:27:00 <triplah__> list comprehensions are awesome!
16:27:09 <twb> So...
16:27:12 <jethr0> @seen bah
16:27:12 <lambdabot> I haven't seen bah.
16:27:19 <twb> how would you do the finding example with a comprehension?
16:27:43 <Cale> of course, comprehensions are roughly like do-blocks over a MonadPlus
16:27:57 <Cale> (currently, they're restricted to lists)
16:28:52 <triplah__> > let index i = [1..] !! i in index 5
16:28:54 <lambdabot> 6
16:28:58 <twb> (iterate (for el in list) (finding el minimizing (length el)))
16:29:11 <jethr0> maximumBy length list-of-lists
16:29:13 <Lor> Why Plus?
16:29:15 <triplah__> lazy evaluation and liust comprehension is damn sexy imho
16:29:28 <triplah__> list*
16:29:32 <twb> jethr0: wouldn't that return the maximum, rather than the element?
16:29:34 <Cale> Lor: for guards
16:29:39 <triplah__> > let index i = [1..] !! i in index 2000
16:29:40 <lambdabot> 2001
16:29:42 <Lor> Well, Monad already has fail.
16:29:48 <Cale> Lor: it shouldn't
16:29:55 <jethr0> twb: maybe
16:29:56 <Lor> Yeah.
16:30:01 <twb> > maximumBy length ["foo","bar","quux"]
16:30:01 <lambdabot>   Expecting a function type, but found `Int'
16:30:01 <lambdabot>   Expected type: [a] -> [a] -> Ordering
16:30:01 <lambdabot>   Inferred type: [a] -> Int
16:30:17 <triplah__> twb: needs to be a comparison function
16:30:20 <Lor> Didn't there used to be a MonadZero between Monad and MonadPlus?
16:30:24 <Cale> We already have  error :: String -> a
16:30:27 <Cale> Lor: yeah
16:30:33 <Cale> I don't see why they removed it
16:30:35 <jethr0> > List.maximumBy length ["foo", "bar", "quux"]
16:30:35 <lambdabot>   Expecting a function type, but found `Int'
16:30:35 <lambdabot>   Expected type: [a] -> [a] -> Ordering
16:30:35 <lambdabot>   Inferred type: [a] -> Int
16:30:36 <wilx> > maximum (map length ["foo","bar","quux"])
16:30:37 <lambdabot> 4
16:30:45 <twb> > maximumBy (\x y -> length x < length y) ["foo","bar","quux"]
16:30:46 <lambdabot> Couldn't match `Ordering' against `Bool'
16:30:47 <Cale> there were a lot of bad decisions made when moving to Haskell 98
16:30:58 <Cale> (at least, in my opinion)
16:31:00 <wilx> > maximum $ map length ["foo","bar","quux"]
16:31:01 <lambdabot> 4
16:31:03 <twb> wilx: the point is that it should return "quux", not 4.
16:31:05 <triplah__> maximumBy (length a 'cmp' length b) ["foo","bar","quux"]
16:31:07 <wilx> Ah.
16:31:22 <Cale> also, things like combinations and permutations being removed from the List library seems silly and pointless.
16:31:26 <triplah__> > maximumBy (length a 'cmp' length b) ["foo","bar","quux"]
16:31:26 <lambdabot>  lexical error in string/character literal
16:31:32 <triplah__> epp
16:31:38 <jethr0> wrong ticks
16:31:42 <twb> triplah__: ``?
16:31:49 <triplah__> > maximumBy (length a `cmp` length b) ["foo","bar","quux"]
16:31:50 <lambdabot>  Not in scope: `b'
16:31:54 <triplah__> argh
16:31:56 <triplah__> you get the idea
16:32:00 <triplah__> <--- noob
16:32:01 <jethr0> > maximumBy (\x y -> compare (length x) (length y)) ["foo","bar","quux"]
16:32:02 <lambdabot> "quux"
16:32:05 <twb> > maximumBy (\a b -> length a `cmp` length b) ["foo","bar","quux"]
16:32:05 <lambdabot>  Not in scope: `cmp'
16:32:07 <dons> @pl \a b -> length a `cmp` length b
16:32:21 <lambdabot> flip ((.) . cmp . length) length
16:32:21 <lambdabot> optimization suspended, use @pl-resume to continue.
16:32:24 <jethr0> @pl \x y -> compare (length x) (length y)
16:32:32 <lambdabot> flip ((.) . compare . length) length
16:32:32 <lambdabot> optimization suspended, use @pl-resume to continue.
16:32:33 <dons> hmm. @pl seems a bit flakey all of a sudden.
16:32:51 <jethr0> hmm, there certainly is a version with many concatenation dots in it!
16:33:17 <twb> But you will concede that that lambda is ugly.
16:33:27 <twb> Compared to (finding elt maximizing (length elt))
16:33:31 <jethr0> yes
16:33:33 <Cale> > let comparing p x y = compare (p x) (p y) in sortBy (comparing snd) [("example", 3), ("sortBy", 1), ("comparing", 2)]
16:33:35 <lambdabot> [("sortBy",1),("comparing",2),("example",3)]
16:34:07 <jethr0> map snd $ maximum $ map (\x -> (lenght x, x)) ["foo","bar","quux"]
16:34:07 <SamB> > maximumBy
16:34:08 <lambdabot>   add an instance declaration for (Show ((a -> a -> Ordering) -> [a] -> a)
16:34:08 <lambdabot> )
16:34:16 <jethr0> > map snd $ maximum $ map (\x -> (lenght x, x)) ["foo","bar","quux"]
16:34:17 <lambdabot>  Not in scope: `lenght'
16:34:20 <Cale> comparing was supposed to end up in Data.Ord at some point :)
16:34:22 <jethr0> > map snd $ maximum $ map (\x -> (length x, x)) ["foo","bar","quux"]
16:34:23 <lambdabot> Couldn't match `[(a, b)]' against `(Int, [Char])'
16:34:39 <twb> That's the other way to do it, yes.
16:34:39 <jethr0> > snd . maximum $ map (\x -> (length x, x)) ["foo","bar","quux"]
16:34:40 <lambdabot> "quux"
16:34:58 <triplah__> let minimaBy f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in ["something","test","quxx"]
16:35:07 <triplah__> > let minimaBy f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in ["something","test","quxx"]
16:35:08 <twb> But that way rapidly becomes unreadable if you have multiple finding clauses.
16:35:08 <lambdabot> ["something","test","quxx"]
16:35:25 <triplah__> > let minimaBy f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minimaBy min ["something","test","quxx"]
16:35:26 <lambdabot>  add an instance declaration for (Ord ([Char] -> [Char]))
16:35:26 <lambdabot>   In the definition of `gdtpccwp':
16:35:26 <lambdabot>    gdtpccwp = let minimaBy f xs = filter (\ x -> ...) xs
16:35:31 <triplah__> haha
16:35:38 <twb> Here's another good one:
16:35:42 <jethr0> sure. this iterate thing reminds me a bit of the "amb" operator and prolog clauses.
16:35:45 <Cale> twb: should be possible to implement all those with a state monad
16:36:00 <wilx> twb, well, I think that you should not try to rewrite your List code into Haskell literally.
16:36:04 <Cale> Maybe state transformed lists
16:36:28 <Cale> It'd make a nice library
16:36:51 <twb> (iterate (for i in (list 1 2 3 4 5)) (collect i into (if (even? i) evens odds)) (finally return (cons evens odds))) ===> ((2 4) . (1 3 5))
16:37:12 <jethr0> twb: in the end "iterate" is a domain specific language, isn't it?
16:37:18 <twb> jethr0: yeah.
16:37:26 <twb> An *embedded* DSL.
16:37:38 <newsham> [foo i | i <- [1,2,3,4,5]]
16:37:59 <Cale> > partition even [1,2,3,4,5]
16:38:00 <lambdabot> ([2,4],[1,3,5])
16:38:01 <SamB> twb: maybe we could do something in TH
16:38:02 <Cale> :)
16:38:06 <twb> Cale: nice.
16:38:15 <Cale> I doubt it would even need TH
16:38:26 <Cale> You could do it with an appropriate monad for sure
16:38:28 <SamB> or a combinator library...
16:38:31 <Cale> yeah
16:38:43 <twb> Anyway, I mainly wanted to get you guys thinking about it.
16:38:56 <Cale> I'm hesitant to say exactly what that monad is, since there's variables
16:39:06 <Cale> Maybe something built on ST
16:39:12 <twb> ST?
16:39:18 <Cale> or perhaps that's just binding
16:39:30 <jethr0> it's interesting, but as i said mainly a DSL and as such maybe too much syntactic sugar for haskellers taste...
16:39:46 <SamB> I mean, I don't remember CL having a decent Parser library...
16:39:47 <yozora> @type iterate
16:39:48 <lambdabot> forall a. (a -> a) -> a -> [a]
16:39:52 <Cale> ST is a monad where you're allowed to construct STRefs
16:40:07 <Cale> @type Control.Monad.ST.runST
16:40:08 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
16:40:18 <Cale> @type Control.Data.STRef.newSTRef
16:40:19 <lambdabot> Couldn't find qualified module.
16:40:19 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
16:40:19 <lambdabot> \\)?
16:40:40 <SamB> jethr0: we'd like it IFF we could convert to semantic sugar
16:40:40 <Cale> @type Data.STRef.newSTRef
16:40:41 <lambdabot> forall a s. a -> GHC.ST.ST s (GHC.STRef.STRef s a)
16:40:44 <Cale> oops :)
16:40:51 <twb> SamB: A lot of the lisp community never really saw the point of parsers.
16:40:55 <Cale> excuse the horribly qualified types
16:41:03 <twb> SamB: since READ works for any sexprs, and anything can be put into a sexprs.
16:41:07 <Cale> STRefs are mutable memory cells
16:41:23 <Cale> it's like a state monad with an undetermined state type
16:41:28 <jethr0> lispers simply write _everything_ as s-expressions and therefore never have to parse themselves ;-))
16:41:39 <jethr0> samb: i didn't get that with the sugar!?
16:41:49 <wilx> Don't they ever go out of their Lisp house?
16:41:58 <twb> wilx: nope
16:42:06 <wilx> Poor lost souls.
16:42:19 <jethr0> wilx: well then they write a reader macro or something like that.
16:42:32 <SamB> I know the Slate people prototyped in CL... no idea how they parsed!
16:42:33 <twb> wilx: CL doesn't even have a way to execute a UNIX command portably.
16:42:52 <Philippa> well duh, that's not portable outside UNIX
16:43:02 <Cale> SamB: wouldn't a similar combinator library to Parsec be possible in CL?
16:43:12 <Cale> Does any such library exist?
16:43:18 <twb> Philippa: I mean portably *within* UNIX implementations.
16:43:26 <jethr0> there _are_ parser libraries for CL and scheme. but they are used much less often then in haskell!
16:43:34 <twb> Cale: apparently MIT-Scheme has something like Parsec.
16:43:41 <Philippa> ah. That's a bit more sucky, though I guess we only get it for those implementations supporting the hierarchical libs
16:43:49 <Philippa> (unless I've forgotten something)
16:43:52 <jethr0> twb: CL and scheme have FFI!
16:44:08 <Cale> @type System.system
16:44:08 <lambdabot> String -> IO GHC.IOBase.ExitCode
16:44:17 <Cale> That's not really GHC specific
16:44:32 <Cale> (it's in the Report)
16:44:44 <Philippa> fair enough. 'snot UNUX-specific though, right? I mean, it'd compile on my windows machine?
16:44:51 <Cale> Philippa: yes
16:45:00 <SamB> Cale: I couldn't find one when I looked!
16:45:01 <Philippa> and then lead to much confusion as the windows command line behaves differently
16:45:01 <triplah__> argh
16:45:05 <triplah__> i hate parse errors
16:45:08 <Philippa> revenge of the run time error!
16:45:14 <SamB> it doesn't help that lisp doesn't have monads...
16:45:25 <jethr0> system is actually posix or ansi (forgot which)!
16:45:26 <Cale> SamB: but you could add them, couldn't you?
16:45:29 <triplah__> list kinda doesnt need them does it?
16:45:32 <triplah__> lisp*
16:45:39 <triplah__> lisp has side effects
16:45:51 <Cale> triplah__: Monads aren't just something you need, they're something you generally want :)
16:45:59 <triplah__> ahh
16:46:09 <SamB> Cale: I don't know lisp well enough to do it!
16:46:12 <Cale> They're a good core to most combinator libraries
16:46:13 <twb> triplah__: just because you don't *need* them is no excuse to not have them.
16:46:18 <SamB> and the lack of types makes it even scarier!
16:46:18 <jethr0> CL is really not a pure functional language. it's more a hybrid language and hence very powerful and potentially harmful (in the wrong hands).
16:46:21 <triplah__> i was under the impression they were a cool way of doing imperative things in a functional way
16:46:26 <Philippa> I don't need anything more than variables, application and abstraction
16:46:32 <Cale> triplah__: well, they're more than that
16:46:36 * araujo would say CL is an imperative language
16:46:43 <triplah__> arjanb: it is
16:46:46 <twb> CL is basically every good and most bad ideas rolled into a *huuuuge* language.
16:46:46 <triplah__> so is scheme
16:46:47 <Philippa> even McCarthys's first lisp had more primitives than that though
16:46:49 <araujo> OR if you like, a dis-functional language ;-)
16:47:03 * jethr0 would say lisp can be most anything the user models it to be.
16:47:11 <Philippa> except a statically typed language?
16:47:11 <jethr0> that is its strength and its weakness.
16:47:13 <twb> araujo: the core is mostly purely functional.
16:47:36 <Philippa> yeah, you can't forcibly separate out non-core stuff though right?
16:47:44 <jethr0> they have built OO on top of lisp, prolog, expert systems, type systems. you name it!
16:47:45 <triplah__> scheme sorta did that
16:47:45 <triplah__> :P
16:47:48 <twb> Philippa: no one is forcing you to use assignment.
16:48:10 <jethr0> and extending the language is the _one_ thing lisp is  best at.
16:48:10 <Philippa> no, but thanks to stupid assault laws I can't force my cow-orkers not to either
16:48:18 <araujo> twb, sorry?, the fact that you don't use assigment doesn't make a PL purely functional.
16:48:36 <twb> araujo: I never said that.
16:48:37 <Cale> I had problems finding many simple things in CL. It seems to be deficient when it comes to actual list processing :) (though I didn't have or know about iterate)
16:48:45 <twb> araujo: I said that the core is *mostly* purely functional
16:48:48 <lisppaste2> triplah annotated #14223 with "parse error" at http://paste.lisp.org/display/14223#5
16:48:53 <araujo> CL is by far more imperative than even functional.
16:48:59 <Philippa> araujo: I was indirectly arguing in favour of monads and twb was responding to that
16:49:15 <jethr0> CL is a monster of a language. try scheme for some more pleasant journeys into s-expression land!
16:49:23 <twb> araujo: on what do you base that assumption?
16:49:27 <Cale> triplah__: you didn't close a paren
16:49:35 <twb> *assertion
16:49:49 <triplah__> Cale: im buggered if i can find it
16:49:55 <twb> Cale: get paredit!
16:49:56 <Cale> triplah__: the first one
16:50:12 <sh10151> scheme needs a standard module system
16:50:20 <twb> sh10151: it's getting one!
16:50:21 <Cale> twb: hm?
16:50:30 <sh10151> good, because it needs one
16:50:32 <triplah__> Cale: i closed that after the second "where"
16:50:33 <twb> Cale: paredit is a structured editing package for Emacs.
16:50:41 <jethr0> hmm, but mzscheme is pretty nice as a portable starting point. although inferior to a real standard, certainly!
16:50:46 <Cale> twb: how does that help with list processing?
16:50:53 <sh10151> does mzscheme run in the jvm?
16:50:57 <Cale> twb: I wasn't complaining about parens in lisp
16:51:00 <twb> Cale: I was talking about missing closing parens.
16:51:01 <araujo> twb, Because of its features. Assigment, no referential transparency, sequence of computation etc etc 
16:51:15 <Cale> I was complaining about the missing close paren in triplah's code :)
16:51:29 <triplah__> i like drschemes parens highlighting, and the swi-prolog ones arent bad
16:51:36 <Cale> triplah__: it has to close before the first 'where'
16:51:48 <Cale> 'where' isn't part of expression syntax
16:51:50 <triplah__> ahh really?
16:51:52 <twb> araujo: referential transparency is orthogonal to FP.
16:51:55 <triplah__> woops
16:51:57 <araujo> I think that Lisp (Scheme for example) can be considered more an OOPL first than a functional language.
16:51:58 <Cale> it's part of the function declaration
16:52:03 <jethr0> araujo: you have to keep in mind it's age. and functional is not equivalent with "pure functional"!
16:52:05 <Philippa> twb: that depends a fuckload on your definition of FP
16:52:07 <Cale> > x where x = 5
16:52:07 <twb> araujo: you don't *need* it for FP, any more than you need encapsulation for OOP
16:52:08 <lambdabot> 5
16:52:12 <SamB> try DSSSL on for size -- thats purely functional all right ;-)
16:52:13 <Cale> ah, hehe
16:52:17 <Cale> that's deceptive :)
16:52:18 <sh10151> it is the Algorithmic Language cheme
16:52:20 <triplah__> still getting the same error
16:52:21 <sh10151> Scheme, even
16:52:22 <triplah__> :(
16:52:41 <araujo> jethr0, twb yes, and it is more OO (imperative) than functional.
16:52:42 <Cale> triplah__: repaste
16:52:54 <twb> OO is not the same as imperative, either.
16:53:01 <lisppaste2> triplah annotated #14223 with "nother parse" at http://paste.lisp.org/display/14223#6
16:53:07 <araujo> twb, I never said that. :-]
16:53:09 * Philippa is actually quite a fan of functional OO-like systems
16:53:16 <Cale> triplah__: same paren isn't closed
16:53:28 * jethr0 has the slight feeling that this is escalating into a flamewar and dresses accordingly...
16:53:40 <Philippa> jethr0: the asbestos'll do you more harm than the flames
16:53:41 <wilx> :)
16:53:43 <twb> I hate objects.  I find closures far more natural.
16:54:03 <twb> But haskell has no local :-(
16:54:08 <triplah__> Cale: ummm. i'm gonna get my stack abacus out now
16:54:09 <triplah__> :)
16:54:09 <twb> ...or assignment.
16:54:15 <twb> So whatever.
16:54:17 <sh10151> I don't know, it seems to me that referentially transparent procedures that use internal mutable state fit into the spirit of FP
16:54:21 <Cale> triplah__: there isn't much of a stack to observe
16:54:21 * jethr0 was illuminated by reading SICP and the possibilites of lisp/scheme.
16:54:34 <Cale> triplah__: it's the expression *before* the first where
16:54:48 <jethr0> independent of what later work on purely functional languages has brought forth!
16:54:50 <Cale> (als (length xs) (length ys) -- find the unclosed paren
16:54:56 <sh10151> twb: I have the most fun in Haskell when programming points-free
16:55:00 <triplah__> Cale: but i want the let to = both of the where's
16:55:09 <araujo> sh10151, points free are fun :-]
16:55:10 <sh10151> I feel for anyone that has to read my code though
16:55:10 <Cale> what?
16:55:15 <twb> Cale: M-x check-parens :-)
16:55:20 <triplah__> bah
16:55:21 <Philippa> twb: There tend to be a lot of closures involved when I'm building object-like code in Haskell anyway
16:55:23 <triplah__> it built fine
16:55:24 <triplah__> :(
16:55:34 <Cale> triplah__: what?
16:55:34 <Philippa> but objects and closely-related concepts are often a good way to think about a system
16:55:56 <Philippa> (note that I'm not picking a particular value of 'object' here...)
16:56:18 <jethr0> message passing can be a blessing or a curse; depending on the domain!!!
16:56:26 <triplah__> Cale: i took the parens out completely and it compiled fine, but now it wont run :)
16:56:27 <twb> Anyway, it's midday and I need to go to bed.
16:56:31 * araujo usually thinks in terms of structures (functions compositions mainly)
16:56:33 <Cale> Philippa: I think you'll be happy with the type-system extensions Autrijus was working on
16:56:53 <Philippa> Cale: have these been talking about in here before?
16:56:53 <twb> Night all!
16:56:58 <Cale> Philippa: yeah
16:56:58 <triplah__> nn twb 
16:57:02 <SamB> twb: you can use closures that way!
16:57:04 <Philippa> I was away the last couple of days and miss stuff more generally
16:57:09 <SamB> you just need to use Refs of some kind
16:57:10 * jethr0 can only repeat: SICP is da sh*t!
16:57:17 <Cale> Philippa: it was a couple weeks ago, I think
16:57:32 <Philippa> jethr0: three exclamation marks is generally a sign of a slipping grip on sanity, however ;-)
16:57:33 <Cale> let me find a reference, I think something was put on the wiki about it
16:58:12 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
16:58:12 <jethr0> philippa: n/p. after 40h w/o sleep "slipping grip of sanity" is the least of my problems...
16:58:14 <Cale> there we go :)
16:58:31 <jethr0> and also, i wanted to make my impression of a language zealot.
16:59:10 <Cale> jethr0: pretty soon, you'll be at my record... can you make it another 19 hours?
16:59:22 * sh10151 thinks in terms of dataflows
16:59:33 <Cale> also, you should try to get as much mathematics homework done in this remaining time as possible
16:59:42 <jethr0> my record was at 56 hours and afterwards i had a fever and felt _really_ awful. never again *g*
16:59:52 <SamB> Cale: do you color the spheres or the lights?
17:00:00 <Cale> SamB: lights
17:00:21 <jethr0> i played 4h of pool today and have never played so well in my life! sleep depravation seems to be doing it for my motoric skill ^_^
17:00:24 <SamB> Cale: thats what I thought
17:00:32 <jethr0> skills*
17:00:40 <dons> TheHunter, interesting, looks like @pl needs -fvia-C, or we get the timeout error
17:00:54 <lisppaste2> triplah annotated #14223 with "wtf?" at http://paste.lisp.org/display/14223#7
17:00:55 <triplah__> Cale: this is a doosy.
17:01:28 <jethr0> http://thedailywtf.com/
17:01:28 <triplah__> i think thats why i wanted the parens, because now its doing wierd stuff
17:01:36 <triplah__> jethr0: love that site :)
17:01:49 <jethr0> gotta love it!
17:02:09 <jethr0> makes all your own blatant stupidities look like mere stylistic glitches ;-)
17:02:39 <triplah__> lol
17:03:34 <jethr0> triplah__: what's up with the underscores in your name, anyway. had some fierce competition for the name ?-)
17:03:48 <triplah__> jethr0: yeah with myself
17:03:48 <triplah__> :)
17:04:13 <triplah> or more to the point, my brother bumping the network cable
17:04:15 <jethr0> good old schizophrenic cyberpunks
17:06:06 <jethr0> everytime the channel goes quiet all so suddenly i have the bad feeling of having caused this phenomenon *blush*
17:06:15 <yozora> @help quote
17:06:15 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
17:06:15 <lambdabot> Quote somebody, or a random person, or save a memorable quote
17:06:18 <lisppaste2> triplah annotated #14223 with ":(" at http://paste.lisp.org/display/14223#8
17:06:21 <jethr0> @quote
17:06:22 <lambdabot> Module "babel" produced error: getRandItem: empty list
17:06:47 <dons> bah, I hate that error.
17:06:54 <dons> @quit
17:06:57 <dons> tacke that!
17:07:14 <jethr0> yeah, RNGs running out of numbers is also my most frequent problem!
17:07:32 <jethr0> PRNGs*
17:07:43 <SamB> I only get that feeling when I'm the last one to have spoken
17:08:06 <jethr0> yes, and lately it's always me *should i be worried now?*
17:08:12 <SamB> jethr0: RNGs also run of numbers
17:08:36 <jethr0> yes, RNGs can. PRNGs can't because they will simply cycle!
17:08:52 <SamB> jethr0: in this case, though, I think it was asked to pick an item at random out of an empty list
17:09:09 <dons> it's some stupid bug. investigating..
17:09:34 <jethr0> ah, ok.
17:09:55 <triplah> *Main> optAlign 0 2 1 "phil" "ppl"
17:09:56 <triplah> [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),("phil","p-pl"),("phil","pp-l")]
17:09:59 <triplah> *Main> optAlignment 0 2 1 "phil" "ppl"
17:10:00 <triplah> why me? :(
17:10:03 <triplah> [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp-","l--pp"),("lihp","l-pp"),("lihp","lp-p")]
17:10:06 <triplah> same function 
17:10:08 <triplah> different output
17:10:10 <triplah> :P
17:10:16 <Cale> > sort [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),("phil","p-pl"),("phil","pp-l")]
17:10:16 <triplah> "sort of the same function*
17:10:17 <lambdabot> [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),(
17:10:17 <lambdabot> "phil","p-pl"),("phil","pp-l")]
17:10:24 <Cale> > sort [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp-","l--pp"),("lihp","l-pp"),("lihp","lp-p")]
17:10:25 <lambdabot> [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp","l-pp"),("
17:10:25 <lambdabot> lihp","lp-p"),("lihp-","l--pp")]
17:10:30 <Cale> okay
17:10:47 <jethr0> aaahhh
17:10:58 <Cale> no, they're still different
17:11:02 <SamB> anybody know how to use HRay?
17:11:29 <jethr0> nope
17:11:38 <triplah> Cale, i hate you :P
17:11:40 <jethr0> can't be _that_ hard ;-)
17:11:52 <Cale> triplah: why?
17:11:54 * triplah quints at code some more
17:12:01 <jethr0> squints*
17:12:04 <triplah> you can see the problem, and i cant apparently
17:12:05 <triplah> :)
17:12:26 <Cale> Oh, I haven't looked closely enough to see the problem
17:12:33 <triplah> ah :)
17:12:37 <Cale> oh
17:12:39 <Cale> I see
17:12:40 <Cale> hehe
17:12:47 <triplah> lies!
17:12:50 <Cale> look at the second list
17:12:59 <Cale> are *any* of those valid alignments?
17:13:05 <Cale> :)
17:13:11 <triplah> nope
17:13:15 <triplah> thats what i mean!
17:13:21 <triplah> its completely whack
17:13:32 <Cale> > sort $ map (\(x,y) -> (reverse x, reverse y)) [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp-","l--pp"),("lihp","l-pp"),("lihp","lp-p")]
17:13:33 <lambdabot> [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),(
17:13:33 <lambdabot> "phil","p-pl"),("phil","pp-l")]
17:13:51 <Cale> > (sort $ map (\(x,y) -> (reverse x, reverse y)) [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp-","l--pp"),("lihp","l-pp"),("lihp","lp-p")]) == sort [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),("phil","p-pl"),("phil","pp-l")]
17:13:52 <lambdabot> True
17:14:17 <triplah> why!
17:14:18 <triplah> haha
17:14:19 <Cale> you're attaching the heads in reverse
17:14:24 <triplah> ahh
17:14:30 <triplah> attachTails might work better
17:14:34 <Cale> yeah
17:15:02 <jethr0> > "lambdabot is a cool invention" /= "any other"
17:15:18 <triplah> oh yeah
17:15:20 <triplah> it works
17:15:20 <triplah> :)
17:15:21 <jethr0> wasn't me!
17:15:22 <triplah> thanks Cale 
17:16:02 <Cale> triplah: it's more effective to memoise things with an array which has O(1) lookup time
17:16:39 <Cale> alsTable = listArray ((0,0),(length xs, length ys)) [[ alsEntry i j | j <- [0..]] | i <- [0..]]
17:16:42 <dons> i'm working on it..
17:16:47 <Cale> als i j = alsTable ! (i,j)
17:17:06 <Cale> xs !! n takes O(n) time
17:18:02 <Cale> I suppose you don't expect the strings to compare to be very long anyway, but in principle, an array would do better. :)
17:18:06 <triplah> Cale: yeah ski pointed that out last night
17:18:12 <triplah> we havent learnt about arrays in class yet
17:18:14 <triplah> only lists
17:18:27 <mwc> so? here's your chance to be a keener
17:18:39 <Cale> actually, it's safer to use: alsTable = array ((0,0),(length xs, length ys)) [[ ((i,j), alsEntry i j) | j <- [0..]] | i <- [0..]]
17:19:05 <Cale> I wouldn't trust listArray to get the indices in the right order on multidimensional arrays
17:19:20 <Cale> (though it should)
17:19:32 <mwc> yeah, cale, are you sure about those [0..]?
17:19:39 <triplah> haha
17:19:47 <Cale> mwc: it's lazy
17:19:49 <triplah> [0..(length xs)]
17:19:55 <triplah> but arrays arent lazy
17:19:55 <mwc> as I understand it, array is strict on the indexes, and so sending in that infinite list would be... bad
17:20:01 <Cale> triplah: yes they are
17:20:05 <triplah> really?
17:20:06 <triplah> wtf:\
17:20:13 <triplah> in the way a vector is in C?
17:20:17 <Cale> triplah: unboxed arrays aren't
17:20:32 <triplah> hmm
17:20:36 <Cale> mwc: you pass the indices to listArray, that part is fine
17:20:38 <triplah> a
17:20:51 <mwc> Cale, last I saw of the Report, arrays are strict on indexes and lazy on content
17:20:57 <mwc> oh, I didn't see where you passed into List Array
17:21:09 <SamB> hmm, HRay doesn't seem like a very good raytracer
17:21:21 <mwc> I was seeing the array iterating over an infinite list of (0,i) before it got to (1,0)
17:21:22 <SamB> it doesn't appear to have any facility to reorient the camera!
17:22:15 <mwc> @hoogle listArray
17:22:22 <Cale> Prelude Data.Array.IArray> listArray ((0,0),(2,2)) [i+j | j <- [0..], i <- [0..]] :: Array (Int, Int) Int
17:22:22 <Cale> array ((0,0),(2,2)) [((0,0),0),((0,1),1),((0,2),2),((1,0),3),((1,1),4),((1,2),5),((2,0),6),((2,1),7),((2,2),8)]
17:22:28 <triplah> *Main> optAlign 0 2 1 "phil" "ppl"
17:22:29 <triplah> [("-phil","pp--l"),("p-hil","pp--l"),("ph-il","p-p-l"),("phi-l","p--pl"),("phil","p-pl"),("phil","pp-l")]
17:22:31 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i
17:22:32 <triplah> *Main> optAlignment 0 2 1 "phil" "ppl"
17:22:32 <triplah> sorry
17:22:33 <lambdabot> e
17:22:34 <triplah> [("l-ihp","lp--p"),("li-hp","l-p-p"),("lih-p","l--pp"),("lihp-","l--pp"),("lihp","l-pp"),("lihp","lp-p")]
17:22:35 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
17:22:37 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
17:22:37 <triplah> argh
17:22:39 <lambdabot> m (a i e)
17:22:40 <triplah> bumped mouse
17:22:46 <jethr0> > "lambdabot is a cool invention" /= "any other"
17:22:48 <lambdabot> True
17:23:50 <jethr0> samb: havent' tried. i just glanced quickly at the code for inspiration...
17:24:00 <triplah> Cale: how do i index the arrays in the alsEntry part?
17:24:18 <SamB> who all has done a raytracer lately?
17:24:20 <triplah>  alsEntry 0 0 = [("","")]
17:24:25 <triplah> im getting an error on that line
17:24:26 <SamB> Saulzar has one
17:24:29 <Cale> triplah: the same way you have been
17:24:44 <Cale> and rewrite  als i j = alsTable ! (i,j)
17:25:09 <triplah> i've done that
17:25:15 <Cale> then it ought to be okay
17:25:24 <Cale> oh
17:25:31 <triplah> array is out of scope
17:25:32 * Cale notices a bug in code that he provided
17:25:36 <triplah> do i need to import something?
17:25:37 <Cale> oh, that's easy
17:25:45 <Cale> import Data.Array.IArray
17:25:57 <Cale> or just import Array if you're using something other than GHC
17:25:59 <jethr0> samb: i'm in the process of writing one, too
17:26:38 <Cale> alsTable = array ((0,0),(length xs, length ys)) [ ((i,j), alsEntry i j) | j <- [0..], i <- [0..]
17:26:45 <Cale> alsTable = array ((0,0),(length xs, length ys)) [ ((i,j), alsEntry i j) | j <- [0..], i <- [0..]]
17:26:47 <Cale> there :)
17:27:28 <Cale> you might want to give a name to length xs and length ys, so you don't end up computing each twice
17:28:43 <triplah> what does the (i,j) in front of alsEntry signify?
17:29:06 <Cale> triplah: the index of the entry in the array
17:29:49 <mwc> Cale, about that list, if we iterate over [(i,j) | j <- [0..], i <- [0..]], then that first parameter goes through an infinite sequence before it gets to (1,0)
17:30:16 <triplah> assignment3.hs:145:95: Illegal parallel list comprehension: use -fglasgow-exts
17:30:40 <mwc> so how would the array ever get to (1,0) if the only way to go through a list is by sequential access?
17:30:42 <Cale> mwc: ah
17:30:44 <Cale> hehe
17:31:19 <Cale> safer to use an array call anyway :)
17:31:34 <Cale> alsTable = array ((0,0),(length xs, length ys)) [ ((i,j), alsEntry i j) | j <- [0..(length xs)], i <- [0..(length ys)]]
17:31:50 <jethr0> there was a solution to that with monads and diagonalisation...
17:32:21 <Cale> yeah, the error would have been missed with listArray, and caught at runtime at least with array
17:32:32 <Cale> oh, you don't even need monads
17:32:51 <Cale> though they might be a nice way to handle it
17:33:31 <triplah> wouldnt it be (length xs) - 1  ?
17:33:39 <triplah> *Main> optAlignment 0 2 1 "philfsfe" "pplfdf"
17:33:40 <triplah> *** Exception: Error in array index
17:33:54 <Cale> ah, yes, in both places
17:33:57 <Cale> I think
17:34:10 * Cale looks at the implementation he did of this yesterday
17:34:22 <jethr0> http://www.dcs.gla.ac.uk/mail-www/haskell/msg01650.html
17:34:47 <Cale> hmm, I included the lengths, not subtracting 1
17:35:12 <triplah> im getting array index exceptions
17:35:47 <triplah> i'll stick with lists for now
17:35:55 <triplah> i can optimise later
17:36:00 <triplah> i'll get the assignment working first
17:36:07 <Cale> hum
17:36:14 <triplah> i want to change some of my answers to monadic solutions later too
17:36:34 <dons> hmm. maybe we should have a HaRe plugin..
17:37:27 <dons> anybody here at kent?
17:37:29 <wilx> Hmm, what was the html/CGI pages toolkit that is not WASH?
17:37:49 <wilx> @hasp
17:37:50 <lambdabot> Maybe you meant: help map
17:38:01 <wilx> @whatis Hasp
17:38:01 <lambdabot> I know nothing about hasp.
17:38:03 <dons> hsp?
17:38:21 <wilx> Ah, right.
17:38:22 <wilx> Thanks.
17:38:23 <Lemmih> @where+ hasp http://scannedinavian.org/~lemmih/hasp
17:38:24 <lambdabot> hasp ~> http://scannedinavian.org/~lemmih/hasp
17:38:31 <wilx> That too.
17:38:33 <wilx> Hmm.
17:40:08 <jethr0> am i the only one for whom that url don't work?
17:40:45 <Lemmih> Try .com instead.
17:41:44 <jethr0> works, but no html eye candy...
17:41:54 <lispy> what is hasp?
17:42:00 <lispy> haskell active server pages?
17:42:05 <jethr0> @where+ hasp http://scannedinavian.com/~lemmih/hasp
17:42:06 <lambdabot> hasp ~> http://scannedinavian.com/~lemmih/hasp
17:42:57 <jethr0> hmm scannedinavian.org is down...
17:43:27 <araujo> What is a good name for a function that split an string into tokens , evaluate some of them and then concat'em all back.
17:43:29 <araujo> ?
17:43:40 <jethr0> strtok :-)
17:43:49 <araujo> *ough*
17:44:02 <araujo> Not _that_ C-like please :-]
17:44:02 <dons> hmm. 225M  123M sleep    biowai   0:39 13.77% ghc-6.4.1
17:45:01 <jethr0> scanner-parser-compiler-concatenater
17:45:28 <lispy> spcc?
17:45:36 <triplah> oh wtf, im up to task 9
17:45:38 <triplah> im nearly done
17:45:39 <triplah> :)
17:45:48 <lispy> task 9?
17:45:52 <triplah> after this i'll just optimise
17:45:57 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
17:46:00 <araujo> jethr0, too long.. but i see your point....
17:46:01 <jethr0> that's what i call a few days well spent *g*
17:46:37 <araujo> splitEvalToken
17:46:40 <jethr0> actually i was just fooling around and had no point; always pleased to help!
17:46:43 <lispy> triplah: huh, cool
17:47:01 <lispy> splitEVILtoken
17:47:05 * araujo is bad at naming things 
17:47:12 <araujo> lispy, haha, that's cool
17:47:32 <lispy> ;)
17:47:40 <jethr0> but maybe you _could_ split that into several funcs...
17:47:46 * lispy waits for dports it upgrade all...
17:48:12 <lispy> i'd say it ought to be split up
17:48:38 <jethr0> and if only for the sake of name finding...
17:49:29 <araujo> jethr0, yeah, it is actually composed of two functions
17:49:42 <araujo> I only looking for a name for the entry function
17:50:29 <jethr0> hmm, name it after what you will use it for. string-evaluator or so
17:51:24 <jethr0> w/o stating how it works "internally"
17:55:49 <lispy> i recommend, orderPizza
17:56:44 <SamB> lispy: come on! it takes more than two functions to order pizza these days, you know!
17:57:33 <lispy> oh right
17:57:37 <SamB> okay, how do I return all the subsets of a list?
17:57:55 <lispy> orderPizza . makeGirlFriendPayForIt
17:58:43 <jethr0> your girlfriend pays upfront?
17:58:50 <SamB> lispy: do you mean orderPizza >>= makeGirlFriendPayForIt
17:59:20 <jethr0> or even: orderPizza >> makeGirlFriendPayForIt
18:00:28 <jethr0> > List.tails "abcdef"
18:00:29 <lambdabot> ["abcdef","bcdef","cdef","def","ef","f",""]
18:00:42 <jethr0> but that's not quite it, huh
18:00:53 <lispy> SamB: oh right
18:01:00 <SamB> jethr0: not quite
18:01:01 <lispy> well, that's what type checkers are for
18:01:27 * araujo loves $
18:01:59 <jethr0> combinations [] = [[]]
18:02:08 <jethr0> combinations (x:xs)  = combinations xs ++ [ x:xs' | xs' <- combinations xs ]
18:02:12 <jethr0> maybe??
18:02:38 <lispy> what are we computing?
18:02:47 <lispy> the combinations of a list?
18:03:20 <jethr0> powerset of a list (i think that's the right term). all possible sublists.
18:03:34 <lispy> hmm...i suck at that problem
18:03:59 <jethr0> > let {combinations [] = [[]]; combinations (x:xs)  = combinations xs ++ [ x:xs' | xs' <- combinations xs ]} in combinations "abcde"
18:04:00 <lambdabot> ["","e","d","de","c","ce","cd","cde","b","be","bd","bde","bc","bce","bcd",
18:04:00 <lambdabot> "bcde","a","ae","ad","ade","ac","ace","acd","acde","ab","abe","abd","abde"
18:04:00 <lambdabot> ,"abc","abce","abcd","abcde"]
18:04:25 <SamB> let subsets [] = [[]]; subsets (x:xs) = map (x:) (subsets xs) in [(1,1,1), (-1,-1,1), (-1,1,-1), (1,-1,-1)]]
18:04:51 <lispy> > let { combinations [] = [[]]; combinations (x:xs) = combinations xs ++ [x:xs' | xs' <- combinations xs]} in length (combinations "abcde")
18:04:53 <lambdabot> 32
18:04:56 <SineTwo> i have to create a function that does the same as "!!" - i.e. "fetch 2 "haskell"" returns 's' (0 being the first char)... but i have no idea how to do this recursively... can anyone give me any hints to what i should use? i'm thinking to chop off one and one letter untill i get to my basecase, and then chop off the tail or something..?
18:05:05 <lispy> well, that's the right number of elements
18:05:27 <jethr0> sinetwo: sure it's not homework?
18:05:36 <jethr0> ;-)
18:05:38 <SineTwo> jethr0: it is homework
18:05:39 <SineTwo> :)
18:05:48 <SineTwo> i'm not hiding it... i just can't see what exactly to use...
18:05:58 <lispy> @type (!!)
18:05:59 <lambdabot> forall a. [a] -> Int -> a
18:06:21 <lispy> SineTwo: what is the base case?
18:06:26 <SamB> > let subsets [] = [[]]; subsets (x:xs) = map (x:) (subsets xs) in subsets [(1,1,1), (-1,-1,1), (-1,1,-1), (1,-1,-1)]]
18:06:27 <lambdabot>  parse error on input `]'
18:06:27 <lispy> SineTwo: can you do that part?
18:06:50 <lispy> eg, what is fetch 0 (x:xs) = ??
18:06:54 * SamB just does it by hand...
18:07:07 <jethr0> or to reformulate: under which conditions should the recursion stop?
18:07:22 <SineTwo> when the basecase "hits" the character in the given array position?
18:07:48 <jethr0> so, fetch 0 (x:xs) = ??
18:07:48 <SineTwo> also, our teach went through (x:xs) but i never quite understood it... not really explained in his notes either :\
18:07:49 <lispy> SineTwo: do you know how to handle the case "fetch 0 (x:xs)" ?
18:07:56 <lispy> ah
18:08:02 <lispy> do you know what : does?
18:08:14 <lispy> @type (:)
18:08:15 <lambdabot> forall a. a -> [a] -> [a]
18:08:20 <jethr0> [1,2,3] = (1:[2,3])
18:08:33 <jethr0> > [1,2,3] == (1:[2,3])
18:08:35 <lambdabot> True
18:08:38 <SineTwo> lispy: should i type that?
18:08:54 <lispy> SineTwo: can you explain to me what : is for?
18:09:11 <lispy> SineTwo: (i'm trying to figure out how much you know, so i know where to begin in helping)
18:09:27 <SineTwo> ah ok... i'm not quite sure what : does no... :\
18:09:39 <lispy> SineTwo: do you know how to read type signatures?
18:09:49 <SineTwo> i've just learned really simple functions like: add :: int -> int -> int
18:09:57 <lispy> if i said (:) :: a -> [a] -> [a], would it mean anything to you?
18:10:11 <araujo> "Sometimes the best way of solving a problem, it is not to solve it" --- myself
18:10:29 <jethr0> or to simplify: (:) :: Int -> [Int] -> [Int]
18:10:37 * Cale computes  length $ optAlignment defCost "ilovefunctionalprogramming" "myhovercraftisfullofeels"
18:10:52 <Cale> where defCost = Cost 0 2 1 :)
18:11:15 <SineTwo> that a given function takes a list of Int's and returns a list of Int's?
18:11:25 <SineTwo> dont quite know how to formulate Int -> [Int]
18:11:31 <Cale> heh, that didn't go too well
18:11:49 * jethr0 had that happen to him and doesn't want to see eels again for quite some time...
18:11:59 <Cale> > 1 : [2,3,4,5]
18:12:01 <lambdabot> [1,2,3,4,5]
18:12:07 <Cale> > 1 : 2 : [3,4,5]
18:12:08 <lambdabot> [1,2,3,4,5]
18:12:11 <lispy> SineTwo: Int -> [Int] means it takes an int and gives a list of ints, Int -> [Int] -> [Int] means it takes an int and a list of ints and gives a list of ints
18:12:18 <Cale> > 1 : 2 : 3 : 4 : 5 : []
18:12:19 <lambdabot> [1,2,3,4,5]
18:12:21 <SineTwo> ah ok
18:12:28 <triplah> > [1,2,3]++4
18:12:29 <lambdabot>  add an instance declaration for (Num [a])
18:12:33 <triplah> bah
18:12:35 <Cale> > [1,2,3] ++ [4]
18:12:36 <lambdabot> [1,2,3,4]
18:12:37 <triplah> > [1,2,3]++[4]
18:12:39 <lambdabot> [1,2,3,4]
18:12:55 <Cale> all lists are built up from [], and applications of (:)
18:12:59 <lispy> SineTwo: so (:) takes an "a" and a "list of a" and returns a "list of a"
18:13:09 <Cale> @type (:)
18:13:10 <lambdabot> forall a. a -> [a] -> [a]
18:13:11 <SineTwo> ok, i understand now :)
18:13:26 <dons> oh, hmm, darcs revert dooesn't work in a cvs repo
18:13:27 <Cale> also, (:) has the distinction of being a data constructor
18:13:33 <Cale> so you can pattern match with it
18:13:38 <lispy> SineTwo: so, i typed "fetch 0 (x:xs)" what should i get back?
18:13:45 <lispy> dons: haha
18:14:05 <SineTwo> you should get the first element of the list of ints
18:14:18 <lispy> SineTwo: do you mean x?
18:14:40 <jethr0> samb: what happened to your subset prob?
18:14:46 <SineTwo> i'd assume so, i'm just a bit confused over the (x:xs) bit
18:15:11 <Cale> SineTwo: consider this definition
18:15:15 <Cale> length [] = 0
18:15:17 <jethr0> > let (x:xs) = [1,2,3] in x
18:15:18 <lambdabot> 1
18:15:21 <Cale> length (x:xs) = 1 + length xs
18:15:36 <jethr0> > let (x:xs) = [1,2,3] in (x,xs)
18:15:38 <lambdabot> (1,[2,3])
18:15:41 <lispy> SineTwo: so, in that case you can actually write some code.  "fetch 0 (x:xs) = x"
18:16:17 <jethr0> fetch 0 [] = error "index too large"
18:16:49 <lispy> SineTwo: now, given that we know how to fetch the first element, how would you implement fetch 1 (x:xs) ?
18:16:59 <Lemmih> jethr0: s/0/n/
18:17:02 <lispy> SineTwo: the hint is that you need to use "fetch 0"
18:17:15 <jethr0> fetch _ [] = error "index too large"
18:17:19 <jethr0> sry 'bout that
18:18:17 <SineTwo> hmm, the problem is (sorry if this is repetitive), i just dont understand the form of fetch 0 (x:xs)
18:18:57 <jethr0> (:) can construct or deconstruct. therefore (x:xs) splits the list into its first element and the remainder.
18:19:04 <Cale> SineTwo: what it is that's confusing about it?
18:19:04 <lispy> SineTwo: "(x:xs)" means that it is a list and you are giving the first lement a name "x" and the rest of the list is "xs" often read as the plural of x
18:19:16 <jethr0> > x where (x:xs) = [1,2,3]
18:19:17 <lambdabot> 1
18:19:25 <SineTwo> oh ok
18:19:30 <SineTwo> so xs = [2,3] ?
18:19:33 <int-e> Cale:  optAlignmentCount 0 2 1 "ilovefunctionalprogramming" "myhovercraftisfullofeels" -> 1160997400 [time: 0.01s]
18:19:34 <Cale> fetch 0 (x:xs) is the function fetch applied to the value 0, which is then applied to the list (x:xs)
18:19:38 <lispy> SineTwo: yes
18:19:43 <jethr0> > xs where (x:xs) = [1,2,3]
18:19:45 <lambdabot> [2,3]
18:19:45 <SineTwo> x = head, xs = tail?
18:19:55 <Cale> int-e: yeah, keeping the strings around is bad :)
18:19:57 <jethr0> yup
18:20:03 <SineTwo> ah ok
18:20:19 <lispy> SineTwo: yes, and the names can be arbitrary, and you can apply the pattern multiple times.  For example, (x:y:zs)
18:20:30 <int-e> Cale: I can also generate the strings without running out of memory ... but 1160997400 is a bit too large to actually finish that task
18:20:40 <Cale> int-e: yeah
18:20:48 <lispy> SineTwo: so does the definition "fetch 0 (x:xs) = x" make sense?
18:20:53 <SineTwo> yes
18:20:56 <SineTwo> it does now :)
18:20:59 <Cale> Well, if you're memoising them, you'll run out of memory rather quickly
18:21:04 <SineTwo> thanks...
18:21:08 <lispy> SineTwo: okay, now use that definition to implement "fetch 1"
18:21:11 <int-e> Cale: I know. I did that first :)
18:21:17 <lispy> SineTwo: no problem
18:21:47 <SineTwo> fetch 1 (x:xs) = chop off x, xs - tail? :P
18:21:52 <lispy> SineTwo: you should have something like "fetch 1 (x:xs) = ... fetch 0 ..."
18:22:31 <int-e> Cale: now I generate a description of the alignments as a DAG - and process that description afterwards.
18:22:34 <sploo22> SineTwo: since fetch 1 means the second element of the whole list, what is that in terms of xs?
18:22:58 <int-e> Cale: (the DAG is an ADT, but there are cycles due to memoizing)
18:23:00 <SineTwo> sploo22: the first element?
18:23:04 <SineTwo> of xs
18:23:12 <lispy> SineTwo: right, and how do you fetch that?
18:23:24 <jethr0> sinetwo: and do you know a function that returns the first element of a list?
18:23:35 <SineTwo> head?
18:23:44 <lispy> think of a function you wrote
18:24:40 <lispy> head isn't the wrong answer, but it's not going to lead you to the right solution in this case
18:24:50 <SineTwo> hmm ok...
18:25:09 <SineTwo> fetch :: Int -> [] -> Char
18:25:19 <SineTwo> would that be the correct way of doing the top bit?
18:25:26 <lispy> sorry :(
18:25:28 <SineTwo> or should it be [ Char ]
18:26:11 <sploo22> SineTwo: yes, Int -> [Char] -> [Char] is a valid type for your program
18:26:20 <lispy> well, it could be Int -> [Char] -> Char, but it has a more general type than even that
18:27:01 <jethr0> sploo22: not really, seeing how the function should return a list element...
18:27:10 <sploo22> SineTwo: oops, sorry, I meant Int -> [Char] -> Char
18:27:17 <SineTwo> hhe ok, thought so...
18:27:23 <lispy> SineTwo: what would you expect "fetch 1 (x:xs) = fetch 0 xs" to do?
18:27:49 <SineTwo> to return the first element of list xs
18:28:00 <lispy> SineTwo: why?
18:28:15 <SineTwo> because it does fetch 0 xs..?
18:28:37 <lispy> SineTwo: okay, do you see how to handle the general case?
18:28:48 <SineTwo> yeah i can see it's recursive in that way...
18:28:53 <int-e> Cale: with Cost 0 3 2  I get just 1008 solutions.
18:29:18 <jethr0> sinetwo: can you implement "fetch 2 (x:xs)" ?
18:29:21 <lispy> SineTwo: so you could imagine getting rid of the definiton "fetch 1 (x:xs)" and replacing it with "fetch n ..."?
18:29:25 <Cale> int-e: same
18:29:31 <SineTwo> yeah, definately
18:29:33 <Cale> (on both accounts)
18:29:39 <jethr0> so?
18:29:48 <SineTwo> fetch 2 (x:xs) = fetch 1 xs
18:29:59 <jethr0> so we have:
18:30:02 <lispy> cool
18:30:06 <jethr0> fetch 1 (x:xs) = fetch 0 xs
18:30:10 <jethr0> fetch 2 (x:xs) = fetch 1 xs
18:30:18 <jethr0> fetch 3 (x:xs) = fetch 2 xs
18:30:20 <jethr0> ...
18:30:26 <SineTwo> ok, so fetch n (x:xs) = fetch (n - 1) xs
18:30:35 <lispy> yup
18:30:42 <lispy> and of course you still have the base case
18:30:58 <SineTwo> yeah, i nkow it should stop once i get to the element i want
18:31:03 <SineTwo> and return that character
18:31:06 <SamB> Cale: where exactly do the lights go?
18:31:33 <jethr0> let {fetch 0 (x:xs) = x; fetch _ [] = error "idx too long"; fetch n (x:xs) = fetch (n-1) xs} in fetch 5 [0..]
18:31:34 <Cale> SamB: in the centres of the faces of the tetrahedron, iirc
18:31:35 <jethr0> > let {fetch 0 (x:xs) = x; fetch _ [] = error "idx too long"; fetch n (x:xs) = fetch (n-1) xs} in fetch 5 [0..]
18:31:36 <lambdabot> 5
18:31:37 <lispy> SineTwo: well, i hope that helps, that process we went through is pretty standard for building a recursive function
18:31:41 <Cale> *Main> optAlignmentCount (Cost 2 0 1) "ilovefunctionalprogramming" "myhovercraftisfullofeels"
18:31:41 <Cale> 189
18:32:06 <jethr0> samb: are you recreating the infinite sphere raytracing image??
18:32:19 <SamB> jethr0: attempting it
18:32:45 <lispy> SineTwo: sometimes it's easier to start from the general case and work back to the base case, but often the base case is easier to see.  If the base case is easier youjust figure out how to express one step up from the base case in terms of the base case
18:33:22 <int-e> Cale: also the same
18:33:33 <lispy> well, i should go home
18:33:36 <jethr0> sinetwo: the idea is to find a way to split off a part of the problem and let someone else deal with the "smaller" problem.
18:33:57 <SineTwo> ah ok...
18:34:09 <jethr0> sinetwo: until finally the problem reaches someone for whom the problem is small enough to solve directly.
18:34:24 <jethr0> "smaller" remaining problem.
18:35:03 <int-e> Cale: have you introduced a type class for combining results of the optAlignment function in various different ways?
18:35:43 <Cale> int-e: no, I haven't bothered to factor the code yet
18:38:35 <SineTwo> thanks a lot for your help guys
18:39:51 <SamB> Cale: how big are the spheres?
18:40:01 <Cale> SamB: it doesn't matter
18:40:02 <Cale> :)
18:40:07 <SamB> you sure?
18:40:09 <Cale> they're all the same size
18:41:03 <Cale> well, you'll be positioned the same with respect to them in any event. If they're larger, you'll be farther away from them anyway
18:41:04 <jethr0> samb: you have a point camera which has an infinitely small aparture ;-)
18:41:26 <Cale> Since you're positioned also in the centre of one of the faces
18:41:33 <SamB> well, I've got a tetrahedron inscribed in the raytracer's unit cube (with corners <+-1,+-1,+-1>)
18:41:47 <Cale> hm?
18:41:53 <Cale> it's a regular tetrahedron
18:41:57 <SamB> yes
18:42:00 <Cale> okay
18:44:01 <Cale> call the 4 vertices of the tetrahedron v1,v2,v3,v4. Then you should be positioned at p = (v1 + v2 + v3) / 3, pointed in the direction of v4 - p
18:44:52 <Cale> similarly, the point lights are positioned at (v2 + v3 + v4) / 3, (v1 + v3 + v4) / 3, and (v1 + v2 + v4) / 3
18:45:24 <jethr0> can someone help me in respect to System.Posix.Types.Fd filedescriptor?
18:45:51 <Cale> jethr0: what do you need help with?
18:46:06 <jethr0> it's defined "newtype Fd = Fd CInt" but i can't seem to extract the CInt from it, because the constructor seems not to be exported by the module...
18:46:33 <Cale> it's an instance of Num though
18:46:38 <lisppaste2> SamB pasted "Attempt at Cale's Fractal" at http://paste.lisp.org/display/14240
18:46:46 <Cale> so just toInteger
18:46:52 <Cale> er
18:46:56 <Cale> no
18:46:59 <Cale> fromIntegral
18:47:03 <jethr0> no, the problem is that the constructor "Fd" is not available.
18:47:10 <Cale> jethr0: you don't need it
18:47:19 <Cale> fromIntegral will convert it to any numeric type
18:47:25 <Cale> as it's an instance of integral
18:47:44 <jethr0> ahh, you mean Fd is also an Integral??
18:47:45 <Cale> SamB: post a screenshot? :)
18:47:52 <SamB> Cale: how?
18:47:56 <Cale> jethr0: yes, you see that right below in the docs?
18:48:10 <jethr0> ok, must have overlooked that, thx
18:48:15 <Cale> SamB: um... well, you could send it to me, and I'll put it up
18:48:20 <jethr0> newtype is quite new to me, still.
18:48:22 <SamB> Cale: you can't download Saulzar's tracer and build by scene with it?
18:48:27 <Cale> oh
18:48:30 <Cale> where is that?
18:48:37 <jethr0> or samb could post it himself on your upload page *g*
18:48:42 <SamB> I don't remember exactly...
18:48:45 <Cale> jethr0: well, yes :)
18:48:58 <jethr0> i got saulzar sources here...
18:49:04 <Cale> jethr0: this however would not make it accessible to others (I hope)
18:49:24 <jethr0>  saulzar.orcon.net.nz/slugtracer.tar.gz
18:49:24 <Cale> http://vx.hn.org/uploads.html
18:49:45 <jethr0> i could try with my raytracer as well...
18:52:05 <Cale> hmm
18:52:25 <Cale> that looks like a bug or two
18:52:44 <jethr0> cale: is it four touching reflective spheres with the camera in their center looking tangentially of one sphere?
18:53:41 <Cale> jethr0: four tangential spheres of equal radius, with the camera in the centre of one of the faces of the imaginary tetrahedron with vertices at their centres
18:53:58 <Cale> and lights at each of the centres of the other 3 faces
18:54:24 <SamB> Cale: is pgm okay?
18:54:39 <SamB> actually, I suspect it isn't really pgm
18:54:54 <Cale> I got mangled junk when I ran it
18:54:58 <jethr0> so its like a tetrahedron of spheres
18:55:05 <jethr0> pnm it should be!
18:55:21 <jethr0> pgm is "_g_ray"
18:55:30 <Cale> output.pnm: Netpbm PPM image text
18:56:24 * Cale wonders if there is a bug in his image viewer
18:56:41 <Cale> SamB: does the result look anything like it should?
18:56:57 <jethr0> gqview has sometimes weird problems with my raytraces images, too
18:57:12 <Cale> SamB: your spheres are centred at the wrong locations
18:57:36 <Cale> [(1,1,1), (-1,-1,1), (-1,1,-1), (1,-1,-1)] -- this doesn't give a regular tetrahedron
18:58:23 <SamB> Cale: you sure?
18:58:44 <Cale> quite
18:59:01 <Cale> let a be some constant
18:59:02 <jethr0> i'm too lazy to check, but your side lengths differ, methinks
18:59:27 <Cale> (V3 (sqrt 3 * a / 3) 0 0), (V3 (sqrt 3 * a / (-6)) (a/2) 0), (V3 (sqrt 3 * a / (-6)) (-a/2) 0), (V3 0 0 (- sqrt 6 * a / 3))
18:59:43 <Cale> then those are the corners of a tetrahedron
18:59:53 <Cale> (for simplicity, you may take a = 1)
19:00:29 <Cale> hmm, perhaps I did have the camera right in the centre
19:00:57 <Cale> the rest of my description matches what I have here though
19:02:13 <Cale> ah, in the gimp it looks better
19:02:21 * SamB used gqview
19:02:28 <Cale> but still not fractaly
19:02:33 <SamB> no!
19:02:36 <SamB> not a bit
19:02:46 <Cale> doesn't look like the shader is reflective enough
19:02:53 <SamB> hmm
19:03:22 * SamB tries 0.99 instead of 0.9
19:04:54 <jethr0> samb: could you give me your sphere positions?
19:05:10 <SamB> jethr0: they were right in the pasted source file
19:05:15 * jethr0 's too stupid to figure it out right now ;-(
19:05:18 <Cale> jethr0: you want his positions?
19:05:31 <Cale> my positions are actually a regular tetrahedron
19:05:36 <Cale> I gave them above
19:05:43 <SamB> I'm pretty sure mine are too...
19:05:45 <Cale> [(1,1,1), (-1,-1,1), (-1,1,-1), (1,-1,-1)] were his
19:05:56 <jethr0> samb: ok, cale: yup
19:06:11 <SamB> I've played with Zome enough that I ought to know this ;-)
19:06:21 <jethr0> i'm not sure whether i'm happy with those... are the sphere really touching with those?
19:06:33 <SamB> not with the size I gave them...
19:06:36 <SamB> which is 1
19:07:08 <Cale> > let norm (x1,y1,z1) (x2,y2,z2) = sqrt (x1*x2 + y1*y2 + z1*z2) in norm (1,1,1) (-1,-1,1)
19:07:09 <lambdabot> NaN
19:07:13 <Cale> er
19:07:23 <Cale> heh
19:07:33 <Cale> > let norm (x1,y1,z1) (x2,y2,z2) = sqrt ((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2) in norm (1,1,1) (-1,-1,1)
19:07:34 <lambdabot> 2.8284271247461903
19:07:53 <Cale> > let norm (x1,y1,z1) (x2,y2,z2) = sqrt ((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2) in norm (-1,-1,1) (-1,1,-1)
19:07:54 <lambdabot> 2.8284271247461903
19:09:01 <Cale> hmm, which pair :)
19:09:26 <triplah__> this is hideous
19:09:32 <triplah__> and it wont parse
19:09:32 <triplah__> :)
19:09:56 <lisppaste2> triplah annotated #14223 with "*cries*" at http://paste.lisp.org/display/14223#9
19:11:56 <triplah__> hmm
19:11:59 <triplah__> fixed the base case
19:12:28 <jethr0> cale: are the lights supposed to be inside the spheres?
19:12:40 <SamB> jethr0: how would that work?
19:12:51 <SamB> well, I suppose maybe this tracer doesn't implement shadows...
19:13:03 <Cale> jethr0: they're positioned at the centres of the faces
19:13:28 <SamB> okay, now I get something that looks like a test pattern ;-)
19:13:31 <jethr0> well, the tetrahedron faces obviously intersect the spheres and thus the tetrah. face centers lie within the sphere, no??
19:13:52 <Cale> jethr0: no
19:14:06 <jethr0> tetrahedron vertices = sphere centers?
19:14:09 <Cale> yes
19:14:23 <jethr0> => parts of the tetrahedron faces intersect spheres!
19:14:49 <jethr0> in fact the whole face intersects with spheres, because of fine-tuned radii of the spheres!
19:14:53 <SamB> the tetrahedron is not shown
19:14:54 <jethr0> or am i halucinating?
19:15:05 <SamB> hallucinating
19:15:17 <Cale> you're not hallucinating enough
19:15:20 <Cale> heh
19:15:20 <jethr0> i know! but if the light are at the face centers and the face intersects the sphere, then the light lies inside the sphere
19:15:24 <SamB> Cale: did you get the second upload yet?
19:15:37 <Cale> SamB: oh, you have to let me know :)
19:15:54 <SamB> you've already seen what the first one looked like
19:16:05 <SamB> its output.pgm
19:16:19 <Cale> yep
19:16:33 <SamB> it looks rather odd
19:16:46 <lisppaste2> SamB annotated #14240 with "looks like a test pattern" at http://paste.lisp.org/display/14240#1
19:17:51 <Cale> yeah
19:17:56 <Cale> burnt out
19:17:59 <SamB> maybe I should try an eyepoint that isn't on the surface of a sphere, ya think?
19:18:08 <Cale> yeah
19:18:35 <SamB> or maybe I should have put a 1 for the fourth component
19:19:57 <SamB> doesn't help much
19:20:37 <SamB> this one's called Cale3.pgm
19:20:50 <SamB> those fourth components are certainly mystical...
19:21:56 <SamB> oh, I think I didn't figure out how to do the radius right, is it
19:25:07 <Cale> hmm, yeah, that *does* appear to be a tetrahedron :)
19:25:44 <SamB> apparantly you can get all sorts of crazy effects by using non-1 4th components...
19:27:08 <triplah__> i've got big problems :)
19:27:17 <SamB> wow, now its even freakear
19:27:28 <lisppaste2> triplah annotated #14223 with ":(" at http://paste.lisp.org/display/14223#10
19:27:38 <triplah__> too many type errors
19:27:43 <triplah__> i cant read the ones enar the top
19:27:56 <SamB> now I will try with a point in the middle of the face and touching spheres
19:29:17 <SamB> I think I'm too close...
19:30:35 <jethr0> i got totally different params, but i can also see a fractal pattern...
19:31:00 <jethr0> i set my reflection depth higher and now it's _rather_ slower.
19:31:33 <jethr0> for a small version: http://84.163.75.218/haskell/firstfrac.png
19:31:35 * SamB sets reflect to .95
19:32:04 <jethr0> astonishingly the spheres' centers are in the top left and bottom right corners...
19:32:25 <jethr0> no idea how this pattern is created
19:32:47 <jethr0> i also only have only one light
19:33:32 * jethr0 suspects that his adaptive anti-aliasing is hard at work.
19:35:59 <jethr0> okay, bigger image, same address.
19:36:41 <Cale> makes sense
19:37:00 <Cale> add a couple more lights
19:37:29 <Cale> also, are you making sure to use quadratic light falloff?
19:37:39 <jethr0> no, i got linear falloff.
19:37:49 <Cale> yeah, it looks a bit harsh
19:38:59 <Cale> though that might be a good effect here :)
19:39:06 * SamB downloads what he started with to see how he messed it up to only do flat colors
19:39:32 <jethr0> the harshness comes from adding reflection and diffuse to more than 1... i haven't implement falloff for reflected light yet.
19:39:38 <jethr0> hehe
19:40:04 <SamB> oh, I messed up the light vectors by taking out a 1
19:40:14 <SamB> er, not vectors
19:41:23 * Cale renders SamB's tetrahedron in Mathematica and spins it around. Yeah, it is really regular after all. :)
19:41:33 <Cale> Now that I think about it, it makes lots of sense :)
19:42:19 <SamB> I'm certainly not going to be coming up with some three complicated formulas when I can just embed in the cube...
19:42:25 <lisppaste2> triplah annotated #14223 with "type errors" at http://paste.lisp.org/display/14223#11
19:42:43 <Cale> Graphics3D[ Polygon /@ KSubsets[{{1, 1, 1}, {-1, -1, 1}, {-1, 1, -1}, {1, -1, -1}}, 3]] // Show
19:43:52 <Cale> triplah__: have you tried using let?
19:43:55 <SamB> oh, looks like Mathematica would make a lovely frontend for a raytracer
19:44:05 <triplah__> Cale: instead of where?
19:44:16 <Cale> triplah__: where would be fine too
19:44:35 <Cale> but in any event, you can pattern match to extract the pieces you want
19:44:44 <triplah__> Cale: i've used where probably too much there. where in particular are you suggesting useing it?
19:44:57 <SamB> triplah__: also in that sentence
19:45:10 <triplah__> SamB: indeed :D
19:45:21 <Cale> triplah__: you pattern match against the result of the cache lookup
19:45:32 <Cale> to extract the cost and the list separately
19:45:37 <TheHunter> you should just use another indentation style.
19:45:50 <Cale> yeah, that's pretty terrible :)
19:45:56 <triplah__> hey im new
19:45:58 <Cale> hehe
19:45:58 <triplah__> gimme a break :D
19:46:00 <Cale> :)
19:46:19 <Cale> you don't need to nest wheres like that quite so much
19:46:28 * TheHunter uses two spaces.
19:46:29 <Cale> and your tabs are huge
19:46:39 <triplah__> blame vi's syntax highlighting
19:46:40 <Cale> I use 4 spaces, 2 would be fine as well
19:46:48 <Cale> hm?
19:46:56 <Cale> I use vim
19:47:27 <lisppaste2> SamB annotated #14240 with "Looks nicer anyway" at http://paste.lisp.org/display/14240#2
19:47:38 <Cale> also, make sure that you set expandtab
19:47:55 <triplah__> how do i do that?
19:47:58 <SamB> Cale: it still doesn't look fractaly
19:48:24 <SamB> jlouis: I unjustly accuse you of something
19:48:35 <Cale> jlouis?
19:48:39 <triplah__>  alsEntry i j
19:48:39 <triplah__>                                                         | i>0 && j==0  = ((costString m mm sp xs ys (fst . head xcst)(snd . head xcst)),xcst)
19:48:45 <triplah__> argh
19:48:56 <SamB> jlouis: oh, I'm just wondering if he is around at all
19:49:13 <SamB> I figure unjustly accusing him of something is the best way to get his attention ;-)
19:49:28 <SamB> er, Cale 
19:49:34 <SamB> me
19:49:38 <SamB> s/me/meh/
19:49:42 <triplah__> haha
19:50:01 * jethr0 is tired of trying raytracing configurations...
19:50:25 <jethr0> maybe i'll play around with this tomorrow a little more. g' nite
19:50:27 <SamB> Cale: give #2 a whirl?
19:50:34 <TheHunter> what would be the recommended way of parsing haskell code? ghc-src?
19:50:53 <SamB> TheHunter: postponing it indefinately?
19:52:09 <TheHunter> -package ghc probably isn't quite there yet, so the question becomes if it will have a similar interface as ghc-src.
19:52:09 <jethr0> cu
19:52:15 <Cale> SamB: hmm
19:52:23 <Cale> SamB: are you sure it's recursive?
19:52:28 <SamB> Cale: no!
19:52:48 <Cale> that looks a lot like iteration depth 1
19:52:59 <SamB> @localtime Saulzar_ 
19:53:00 <lambdabot> Local time for Saulzar_ is Sat Dec  3 16:52:38
19:53:09 <flux__> @localtime flux__
19:53:12 <lambdabot> Local time for flux__ is Sat Dec  3 05:52:47 2005
19:53:14 <SamB> Saulzar! I summon thee!
19:53:16 <flux__> ooh
19:53:24 <Cale> hehehe
19:53:25 <flux__> I wondered how it worked, but just uses ctcp time
19:53:36 <SamB> hmm. I guess this is not yu-gi-oh!
19:53:47 <SamB> or I haven't got the Saulzar card in my hand
19:54:02 <SamB> possibly both
19:54:53 <SamB> oh, the depth is hardwired to 1
19:55:28 <Cale> hardwire it to infinity :)
19:55:30 <Cale> heh
19:55:38 <SamB> cant, its an Int
19:55:49 <Cale> ah, then use -1
19:55:58 <flux__> hardwire it to depth + 1 then?
19:56:03 <Cale> hehe
19:56:14 <SamB> won't work
19:56:20 <flux__> ;(
19:56:28 <SamB> I'll use maxBound
19:56:37 <Cale> It'd work if Int was implemented lazily
19:56:54 <SamB> no, because you have to compare it
19:57:03 <SamB> so it would just jam the whole thing
19:57:04 <flux__> there would be some interesting consequences if ints were defined inductively
19:57:20 <flux__> you could lazily compare n < 42, if n is already evaluated to be >= 42
19:59:00 <SamB> hmm, I think I need to turn down the glare somehow
20:01:50 <SamB> dons: 48:27
20:02:13 <dons> cool. up to p133, btw
20:02:23 <dons> but nothing significant, really.
20:02:24 <SamB> ah. that was for "0.2"
20:02:52 <dons> just tidying up so I can freeze it.
20:03:17 <dons> 0.2, then i decided to go back to 0.1 until i'd finished ;)
20:06:49 <SamB> hmm, lowering that one number makes the glare worse...
20:08:18 <SamB> Cale: can you host a tarball?
20:08:26 <Cale> yep
20:08:47 <SamB> and give it to Saulzar if he comes by?
20:09:08 <Cale> It would be on my desktop machine, which isn't 100% reliable, but it's reasonable
20:09:19 <Cale> (and I leave it on all the time)
20:09:47 <SamB> yeah, well my desktop is on 56k dialup
20:09:54 <Cale> ah
20:10:08 <SamB> and also I might not be around when saulzar comes by ;-)
20:10:26 <Cale> okay
20:10:29 <Cale> sure
20:10:48 <Cale> the tarball of Saulzar's code didn't quite compile at first either
20:10:54 <Cale> there was a small typo
20:11:32 <SamB> oh, yes, thats true ;-)
20:12:11 * SamB sets that wierd number to 100 to see what happens
20:13:16 <SamB> any clue how Phong works?
20:14:34 <Cale> look at the description in Light.hs
20:19:02 * SamB tries lowering reflectance
20:20:18 * SamB dims lights
20:22:11 <SamB> lovely!
20:22:27 * SamB changes res to something more reasonable
20:23:19 <SamB> dons: that blue looks a tad dark
20:23:25 <SamB> on black, I mean
20:30:02 * SamB adds everything needed to darcs
20:33:57 <SamB> okay, I've sent you slugtracer-0.0.2.tar.gz
20:34:43 <SamB> It contains a working (and even pretty) version of your fractal ;-)
20:39:07 <Cale> nice :)
20:39:46 <SamB> you ought to give the URL for the nice people, as well as posting your finished render ;-)
20:40:20 <SamB> and consider JPEG
20:41:18 <Cale> :)
20:45:07 <SamB> hmm, you smile, but you don't seem to have done either one. why is this?
20:47:35 * SamB impishly wonders what would happen if he changed that one number back that makes everything all-or-nothing
20:47:41 <dons> SamB, on black? oh, that's what the black config settings are for. you should use that instead. or maybe I can detect it automagically
20:47:58 <SamB> dons: detectorate!
20:48:01 <SamB> if possible
20:48:06 <dons> blackBgStyle :: UIStyle
20:48:43 <dons> yeah, vim does it, so I reckon I could..
20:49:27 * SamB threatons to paste the image in ASCII art on lisppaste2 if Cale doesn't post soon };->
20:49:33 <Cale> heh
20:49:36 <Cale> sorry
20:49:42 <Cale> was involved in a game of go
20:50:10 <Cale> yes, that's it :)
20:52:12 * Cale gets the url
20:52:38 <Cale> http://vx.hn.org/autoshare/slugtracer-0.0.2.tar.gz
20:52:42 <SamB> my render hasn't quite finished, but it was pretty clear even in the 160x120 version that it was right
20:53:09 <Cale> http://vx.hn.org/autoshare/slugtracer-Cale.jpeg
20:53:22 <SamB> I mean, I've had the fractal for a while now, was just trying to reduce the glare
20:53:51 <Cale> there's about the right amount of glare now, depending on what sort of effect you're going for
20:54:03 <SamB> just about since I set depth to maxBound, I've had it.
20:54:14 <SamB> though once I moved the camera and it disappeared
20:54:39 <SamB> and the only reason I wanted to cut the glare was that it was way too much
20:55:02 <Cale> http://vx.hn.org/autoshare/colours-2.png -- this was my initial version, before the upper bound on light intensity was removed.
20:55:05 <SamB> this might be a little bit more than I like, but it is mostly fantastic
20:56:45 <SamB> the only parts I don't like are around the primary highlights for each lightsource on the center sphere
20:58:29 <SamB> and then maybe just the green one...
20:58:42 <SamB> what did you have an upper bound for in the first place?
20:58:43 <Cale> I also think it would benefit from supersampling
20:58:56 <SamB> oh, sure
20:59:07 <Cale> oh, the original raytracer just passed around colours
20:59:15 <Cale> which were triples of Char
20:59:19 <Cale> er
20:59:21 <SamB> but you can tell that to saulzar ;-)
20:59:22 <Cale> Word8
20:59:38 <Cale> Oh, we could do that ourselves :)
20:59:54 <Cale> You just render a larger version and scale it down :)
21:00:05 <Cale> (with something like the Gimp)
21:01:12 <SamB> true
21:01:22 <SamB> or zoom out in gqview ;-)
21:01:30 <Cale> hehe
21:12:18 * SamB thinks Smerdy has finally gone stark raving mad
21:12:34 <lispy> Smerdy is an interesting sounding name
21:12:43 <lispy> sort of Dr. Seus-ish
21:12:46 <Korollary> it's missing a "akov" I think
21:13:11 <SamB> yes
21:14:36 <SamB> hmm, and Zhivago is imagining C implementations involving synchronized swim teams or ballroom dancers
21:15:02 <Korollary> where are you reading whatever that is ?
21:15:29 <SamB> ##c
21:15:57 <SamB> Smerdy seems to think bitfields are usefull for implementing network protocols
21:16:56 <Korollary> I think they've been useful for the last 20 years for similar crammed stuff.
21:17:09 <SamB> well, I think he meant C bitfields
21:17:18 <Korollary> yes
21:17:26 <SamB> but are they even portable?
21:17:35 <Korollary> oh
21:17:35 <SamB> I mean, is the packing portable?
21:17:40 <Korollary> It's an implementation
21:18:07 <SamB> nobody else seems to have made any reply to this suggestion. I'm assuming that is a good thing.
21:18:17 <Korollary> You could say in the protocol that the first entry in the header is 4 bytes long and has such and such bits assigned such and such values.
21:18:27 <SamB> yes
21:18:38 <Korollary> then you could implement it using bitfields and longs, ints, etc. on different platforms.
21:18:47 <Korollary> the code won't be portable of course.
21:19:00 <Korollary> because these are implementation level details.
21:19:09 <SamB> yes, all this I know
21:19:23 <Korollary> he is saying that the code would be portable ?
21:19:27 <SamB> no
21:19:41 <SamB> he meant the kind with colons in them, I think
21:19:54 <SamB> he didn't really elaborate much, though
21:20:31 <SamB> is he maybe an idiot savant or whatever you call them?
21:20:41 <Korollary> I wouldn't know.
21:21:15 <Korollary> why somebody hangs out in ##c is beyond me anyways.
21:21:32 <SamB> hmm, no idea why I hang there anymore really
21:21:35 <lispy> heh, ##c isn't bad
21:21:44 <SamB> maybe I just like to say Haskell this, Haskell that
21:21:48 <lispy> i like being able to help students learning C
21:22:14 <Korollary> well, not that anything's wrong with c. It's just that it doesn't make great conversation material, you know.
21:22:28 <lispy> that's true
21:22:38 <SamB> the only one I got any complaints about was when I said Haskell had a wonderful community, I think
21:22:39 <lispy> take this conversation for example ;)
21:22:47 <SamB> Smerdy had issues with that statement
21:23:02 <SamB> said something about "inappropriate persons"
21:23:22 <Korollary> He must have meant dons or Cale. I just can't stand these helpful people.
21:23:38 <SamB> actually, he meant shapr
21:23:41 <lispy> people outside the haskell community often comment that haskellers are very "obtuse" and "academic"
21:24:04 <SamB> and Smerdy has a more-academic-than-thou attitude
21:24:05 <Korollary> shapr is highly inappropriate with his unicycles and longitude and latitude.
21:24:24 <lispy> mostly the longitude
21:24:40 <SamB> doesn't understand our "steps of the parthenon" policy
21:24:56 <Korollary> haskellers are indeed more academic than everybody else imho.
21:25:47 <lispy> i'm starting a new job in a couple weeks and they are open to me using haskell on new projects that i'm part of
21:25:54 <lispy> i think that's pretty cool
21:25:58 <SamB> yes, but they don't go around trying to pull rank with it ;-)
21:26:17 <Korollary> lispy: what kinda job?
21:26:44 <SamB> have you seen the pretty picture I made with Saulzar's raytracer?
21:28:09 <SamB> I copied it off of Cale's raytracer fractal
21:28:17 <SamB> which also works with christmas ornaments
21:28:33 <SamB> http://vx.hn.org/autoshare/slugtracer-Cale.jpeg
21:29:25 <SamB> the source is at http://vx.hn.org/autoshare/slugtracer-0.0.2.tar.gz
21:31:02 <Korollary> neat
21:38:26 <triplah__> argh
21:38:28 <triplah__> :(
21:41:53 * SamB wonders if James Clark got his email
21:42:45 <triplah__> ok i really need help here
21:42:54 * triplah__ jumps around
21:43:06 <SamB> yes?
21:43:09 <SamB> where are you?
21:43:35 <lisppaste2> triplah annotated #14223 with "hmmmm" at http://paste.lisp.org/display/14223#12
21:44:03 <SamB> triplah__: okay, you look at pretty picture to relax while I look at code ;-)
21:45:02 <triplah__> hehe
21:45:07 <triplah__> yeah thats impressive by the way
21:45:09 <triplah__> :)
21:45:52 <triplah__> SamB: something is wrong with the way i'm doing the als recursive call
21:46:40 <triplah__> its implying [([Char],[Char])] whereas i actually want each index of the table to be (a, [([Char], [Char])])
21:47:17 <SamB> triplah__: huh
21:47:27 <SamB> whats the a?
21:47:47 <triplah__> an Int
21:47:49 <triplah__> sorry
21:48:04 <triplah__> a cost associated with the pair at that index
21:49:00 <SamB> well, it looks like attachMutant isn't returning one of those
21:49:17 <SamB> or something...
21:50:15 <SamB> oh, actually, attachMutant doesn't like what its getting
21:50:26 <SamB> its getting (a, [([Char], [Char])])
21:50:43 <SamB> but trying to use it as [([Char], [Char])]
21:51:24 <SamB> you follow?
21:51:54 <triplah__> SamB: yes
21:52:10 <triplah__> i need to fix lis
21:52:15 <triplah__> the comprehension?
21:52:34 <SamB> I would just change lis in the pattern to (_, lis)
21:52:43 <triplah__> yep
21:53:07 <SamB> now you'll probably get some errors about attachMutant
21:53:13 <triplah__> yeah
21:53:19 <triplah__>     Couldn't match `[a]' against `(a1, [([Char], [Char])])'
21:53:21 <triplah__>       Expected type: [a]
21:53:21 <triplah__>       Inferred type: (a1, [([Char], [Char])])
21:53:21 <triplah__>     In the application `attachMutant m mm sp x y (als (i - 1) (j - 1))'
21:55:45 <triplah__> now i need to fix the als calls
21:55:46 <SamB> I find type errors are easier to understand when you give type signatures to key top-level definitions
21:56:16 <triplah__> i dont fully understand how to write type defs
21:56:22 <triplah__> i understnad ones i see
21:56:26 <triplah__> :P
21:56:52 <triplah__> especially in horrible functions like this one
21:57:18 <SamB> yeah, I can't get a good enough grasp of what you have to be sure of anythings type myself...
21:58:16 <triplah__> :(
21:58:47 <SamB> what does costString return?
21:58:59 <triplah__> an integer
21:59:07 <triplah__> thats the Int i want to stick together with the pair
21:59:10 <SamB> ah, right
21:59:20 <SamB> I finally notice the comma
21:59:41 * SamB likes to put spaces after those, especially in huge expressions
21:59:54 <triplah__> yeah
21:59:56 <triplah__> good idea
22:01:27 * SamB doesn't get it
22:01:48 <triplah__> i'm building a table of cost,alignment pairs
22:01:50 <SamB> Korollary, lispy: do your brains still check types
22:01:52 <SamB> ?
22:01:59 <triplah__> previously it was just a table of alignments
22:02:06 <SamB> ah
22:02:22 <triplah__> its the adding the cost that is giving me grief
22:03:37 <Korollary> ?
22:03:41 <SamB> ah
22:03:42 <SamB> I got it
22:03:55 <SamB> the ++s in
22:03:56 <SamB>                                                         | otherwise    = attachMutant m mm sp x y (als (i-1) (j-1))++
22:03:57 <SamB>                                                                          attachMutant m mm sp x '-' (als (i-1) j)++
22:03:57 <SamB>                                                                          attachMutant m mm sp '-' y (als i (j-1))
22:04:13 <SamB> that is WAAAY too wide, wow...
22:04:25 <triplah__> yeah vi does massive tabs:(
22:04:55 <triplah__> the ++'s are building up the list
22:04:58 <triplah__> ahhh i seee
22:05:01 <SamB> you can't add tuples with ++
22:05:01 <triplah__> its the list of alignments
22:05:13 <triplah__> yep
22:05:15 <triplah__> ouchies
22:05:28 <triplah__> time to write a function to add them
22:05:39 <SamB> I suggest you write a nice little function to do that and use it infix...
22:05:53 <triplah__> yep
22:06:02 <SamB> hopefully nice and little, that is
22:06:10 <triplah__> yeah :\
22:06:20 * SamB isn't used to the idea of adding in this sort of situation
22:06:45 * SamB thought what you did was take the best one
22:06:51 <triplah__> take two (Int,([Char],[Char])) 's and put them into a list together
22:06:56 <SamB> whatever, carry on
22:07:09 <triplah__> ah
22:07:16 <triplah__> i do need the best one
22:07:20 <SamB> I am in no condition to criticize your dynamic programming algorithms
22:07:28 <triplah__> i'm generating all of them at the moment
22:07:37 <triplah__> then doing the minimum function at the end
22:07:41 <triplah__> i need to filter as i'm going
22:07:55 <triplah__> perhaps :)
22:08:12 * SamB thought you attached the cost to the individual alignments
22:08:25 <SamB> anyway, get this to typecheck before you do any of that...
22:08:33 <SamB> and then go into ghci and :b it
22:08:33 <triplah__> a cost is only associated with a pair of laignmnts
22:08:38 <SamB> and steal all the typesigs
22:08:39 <triplah__> yep
22:08:41 <triplah__> :b ?
22:08:49 <SamB> that should be usefull
22:09:10 * SamB takes dog out, goes to bed
22:09:40 <triplah__> gnite :)
22:10:38 <SamB> oh, and if you are going to be at this for a while, seriously consider setting up a darcs repo ;-)
22:10:48 <SamB> good night
22:16:13 <ricebowl> is there a Union-Find implementation in the GHC libraries?
22:16:29 <ricebowl> or does Data.Set approximate that?
22:16:46 <Korollary> What is union-find?
22:17:05 <triplah__> comp :: (Int,[([Char],[Char])]) -> Int
22:17:05 <triplah__> comp (a,_) = a
22:17:12 <ricebowl> has to do with disjoint sets...
22:17:15 <triplah__> would this take a pair, and give me the int that is fst?
22:17:31 <ricebowl> triplah__ - yes
22:17:36 <triplah__> sweet :)
22:17:48 <triplah__> just means my bug is harder to find
22:17:48 <triplah__> :P
22:18:07 <ricebowl> triplah__ - it is also morally equivalent to the fst function in Prelude... :p
22:18:21 <triplah__> ricebowl: ahh, duh
22:18:25 <triplah__> maybe i should use that
22:18:25 <triplah__> :D
22:19:21 <ricebowl> Korollary - the idea is simple. I have an undirected graph. I want to know which groups of nodes are connected.
22:20:05 <ricebowl> so initially I start with all nodes in their own sets. Whenever I encounter an edge, I union the two sets that the two nodes are in since both graphs are now connected.
22:20:20 <ricebowl> the final list of sets contains sets in which every node is connected
22:26:06 <ricebowl> hm, oh well, I think Data.Set is the thing that I want
22:26:13 * ricebowl heads off to bed and prepares to get hacking in the morning
22:26:34 <Cale> ricebowl: probably :)
22:41:43 <dons> SamB, color patch landed for you :)
22:52:53 <Cale> ricebowl: you should also note that there's code in the hierarchy for doing just that
23:07:47 <Cale> http://docs.python.org/ref/coercion-rules.html -- wow, I'll take static typing over that any day.
23:07:55 <Cale> :)
23:09:34 <Korollary> That's nothing compared to some other dynamically typed languages.
23:09:44 <Korollary> but I'll take ST as well.
23:18:32 <dsacode> Hello! Where I can find papers related to GHC6 run-time system (organizing memory and so)?
23:21:13 <Korollary> dsacode: I only know of this: http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
23:21:52 <Korollary> I suppose you have checked out these already: http://haskell.org/ghc/documentation.html
23:22:21 <dsacode> yes, i also found 'ghc/docs/rts' in distribution.. just check if something else is available
23:25:37 <dsacode> I can't understand what's `heap' in meaning of Haskell.. Is there some illustration of RTS memory organizing available?
23:26:32 <Korollary> I'm no ghc hacker but I believe heap means heap as usual.
23:28:15 <dsacode> And it holds unevaluated objects?
23:29:24 <triplah__> dsacode: you could safely bet that non basic data types would go on the heap
23:29:25 <triplah__> thats a guess
23:29:25 <triplah__> but i'd say its pretty accurate given how other languages work
23:29:25 <triplah__> for sure
23:29:25 <triplah__> why wouldnt it?
23:29:58 <Korollary> It also holds evaluated objects per my understanding until they are garbage collected.
