00:50:05 <twb`> @pl take 2 repeat 'x
00:50:07 <lambdabot> (line 1, column 15):
00:50:07 <lambdabot> unexpected "'"
00:50:07 <lambdabot> expecting variable, "(", operator or end of input
01:03:42 <Saulzar> Hmm, rendering an empty set of points with HOpenGL gives wierd corruptions all around the gtk window...
01:06:15 <boegel> Saulzar: give us a screenshot !
01:11:32 <Pupeno> Good morning!
01:12:14 <Saulzar> http://saulzar.orcon.net.nz/corrupt.jpg
01:13:42 <Saulzar> If I take away the line rendering some points, it goes away...
01:21:23 <Pupeno> list comprenhensions are cool one you start to understand them.
01:27:38 <Saulzar> Yep :)
01:39:07 <ProfTeggy> Pupeno, this is a statement of general truth.  Simply replace 'list comprehensions' by your favorite topic. ;-)
01:40:25 <boegel> Saulzar: strange, but I don't think it's HOpenGL's fault, that has nothing to do with the stuff outside the window
01:46:37 <flux__> have you guys read about model-based testing?
01:46:40 <earthy> profteggy: dirty socks are cool once you start to understand them? bugs are cool once you start to understand them? wha?
01:46:51 <flux__> it seems somewhat interesting for testing non-trivial systems
01:48:05 <lennart> Can you truly start to understand dirty socks?
01:48:52 <Saulzar> earthy, Actually some bugs certainly are... well, it is definately cool to understand some bugs :)
01:49:32 <Saulzar> Not sure about dirty socks, but they've never been my favourite topic.
01:50:23 <earthy> saulzar: *some* bugs, agreed. :)
01:54:53 <ProfTeggy> Hehe
02:17:14 <{Arias}> Hello
02:17:40 <ricebowl> hola {Arias}, debes entrar a #haskell.es :p
02:17:55 <{Arias}> tanto se me nota?
02:17:56 <{Arias}> xD
02:20:47 <Saulzar> boegel, I guess it could be any number of things.. there are quite a few layers involved!
02:24:11 <{Arias}> a question...
02:24:33 <{Arias}> i'm working with rdf and i want to make a RDFGraph
02:24:46 <{Arias}> i'm using library Data.Graph.Inductive.Graph
02:25:09 <{Arias}> and it haves a Graph class
02:25:26 <{Arias}> i want to extend this class, how can i do it?
02:28:27 <{Arias}> 8-)
02:32:14 <lennart> how about 'class (Graph g) => RDFGraph g where ...'?
02:34:13 <{Arias}> yes, it works
02:34:32 <{Arias}> but i have another class called RDFNode
02:34:38 <{Arias}> and i want something like this:
02:34:53 <{Arias}> class Graph RDFNode => RDFGraph where ...
02:35:04 <{Arias}> but this doesn't works :(
02:35:39 <{Arias}> Kind error: Expecting kind `* -> * -> *', but `RDFNode' has kind `*'
02:35:54 <{Arias}> i don't know how to make it work
02:35:59 <lennart> what is it supposed to mean, what you wrote?
02:36:26 <{Arias}> i want that rdfgraph will be a graph of rdfnodes
02:37:01 <kzm> @seen shapr
02:37:02 <lambdabot> shapr is in #ScannedInAvian and #haskell. I don't know when shapr last
02:37:02 <lambdabot> spoke.
02:37:42 <{Arias}> do you understand me lennart?
02:38:24 <{Arias}> I want for rdfgraph to be a graph of rdfnotes :P
02:38:40 <lennart> i don't think you want a subclss
02:39:12 <{Arias}> what i want?
02:39:13 <{Arias}> :P
02:39:14 <tic> Anyone here an ace with Hoare logic? 
02:40:06 <lennart> hmmm. haskell.org seems to be down so i can't look at the documentation for the Graph module :(
02:40:38 <{Arias}> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graph.html
02:40:48 <ricebowl> a mirror: http://support.informatik.uni-freiburg.de/manuals/ghc/libraries/
02:41:07 <ricebowl> http://support.informatik.uni-freiburg.de/manuals/ghc/libraries/fgl/Data.Graph.Inductive.Graph.html
02:41:39 <[CotL]Godofe_Kei> good morning everyone!
02:42:08 <lennart> I don't seem to be able to connect to freiburg either.  weird
02:42:11 <[CotL]Godofe_Kei> can anyonple please tell me why isnt this working? it looks realy simple..maybe im a moron
02:42:13 <[CotL]Godofe_Kei> sub1 :: (Int,[(Int,Int)]) -> (Int,[(Int,Int)])
02:42:13 <[CotL]Godofe_Kei> sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : sub1 xs) (reverse ((x,y):(a,b):xs))
02:42:47 <ricebowl> what is that supposed to do?
02:43:04 <ricebowl> you're going to get a type error from the cons, of course
02:43:40 <ricebowl> I'd write sub1 (n, xs) = (n, sub1' xs) where sub1' :: [(Int, Int)] -> [(Int, Int)]
02:43:45 <MarcWeber> Hi. Is there something similar to exuberant-ctags availible for haskell? Using vim it's quite useful browsing in your source files..
02:43:48 <ricebowl> and in that case perhaps you can write sub1' as a map or fold
02:44:00 <[CotL]Godofe_Kei> hmm
02:44:06 <[CotL]Godofe_Kei> the thing is
02:44:13 <tic> (you guys seem to be into logic of various kinds :)
02:44:14 <lennart> Arias: but without checking, I think you either want an instance of Graph, or even more likely, you want to use an existing instance
02:44:33 <[CotL]Godofe_Kei> i need to turn this: (1,[(1,303433),(1,606817),(1,909271),(1,1212488),(1,1515000)])
02:45:01 <{Arias}> sorry, how can i make an instance? xD
02:45:11 <[CotL]Godofe_Kei> into the same thing, just subtractf 1212488 to 1515000, 909271 to 1212488 and so on
02:45:15 <ricebowl> so basically you want to generate [(1, n*x) | x <- [1..]]?
02:45:33 <[CotL]Godofe_Kei> no i have that first thing i showed u
02:45:50 <[CotL]Godofe_Kei> just subtractf 1212488 to 1515000, 909271 to 1212488 and so on
02:45:52 <lennart> Arias> if you need one, you use an instance declaration
02:45:56 <ricebowl> yes, but that's rather strange :p
02:46:03 <ricebowl> so you want to subtract adjacent elements?
02:46:14 <[CotL]Godofe_Kei> hmm
02:46:17 <[CotL]Godofe_Kei> i reversed it
02:46:21 <ricebowl> here, can you give a short example of what it should do?
02:46:22 <[CotL]Godofe_Kei> so it seems more simple
02:46:29 <ricebowl> just the second in each pair
02:46:33 <[CotL]Godofe_Kei> ok for example
02:47:33 <[CotL]Godofe_Kei> (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])  --->   (1,[(1,10-0),(1,30-10),(1,70-30),(1,130-70),(1,400-130)])
02:47:48 <MarcWeber> {Arias}: Instance of what?
02:48:13 <kzm> Anybody know what I need to be able to edit TMR wiki pages?
02:48:19 <ricebowl> ok
02:49:45 <{Arias}> instance of a Graph... xD
02:50:26 <ricebowl> do you not care about the first element in the tuple?
02:50:31 <ricebowl> in the tuples in the list, I mean
02:50:36 <[CotL]Godofe_Kei> well
02:50:39 <[CotL]Godofe_Kei> not for now
02:50:43 <[CotL]Godofe_Kei> i mean yes
02:50:45 <ricebowl> hm, ok then
02:50:55 <[CotL]Godofe_Kei> just not got to there yet
02:51:17 <[CotL]Godofe_Kei> its suposed to go like this:   (1,[(1,10-0),(2,30-10),(3,70-30),(4,130-70),(5,400-130)])
02:51:27 <[CotL]Godofe_Kei> add 1 for each tuple
02:52:23 <ricebowl> > let foo (n, xs) = (n, zip (map fst xs) (snd (List.mapAccumL (\x y -> (y, y-x)) 0 (map snd xs)) in foo (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])
02:52:24 <lambdabot>  parse error on input `in'
02:52:37 <ricebowl> > let foo (n, xs) = (n, zip (map fst xs) (snd (List.mapAccumL (\x y -> (y, y-x)) 0 (map snd xs))) in foo (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])
02:52:38 <lambdabot>  parse error on input `in'
02:52:44 <ricebowl> huh...ok, wait a sec
02:52:48 <tromp_> so you want to take a list a to zipWith (-1) a (0:a)   ?
02:52:58 <ricebowl> oh
02:53:02 <tromp_> i mean zipWith (-)
02:53:18 <ricebowl> so you don't care about the first element in the tuples in the list? They're just supposed to be monotonically increasing by 1?
02:53:25 <[CotL]Godofe_Kei> no
02:53:26 <ricebowl> that would make it a *lot* easier
02:53:35 <[CotL]Godofe_Kei> hmm
02:53:42 <ricebowl> you could replace map fst xs with [1..] in that case :p
02:53:46 <[CotL]Godofe_Kei> i was trying to do the sub part
02:53:49 <ricebowl> yes
02:53:51 <[CotL]Godofe_Kei> then add 1 for each tuple
02:53:53 <[CotL]Godofe_Kei> separatley
02:53:58 <araujo> Good morning.
02:54:03 <ricebowl> it's easier if you unzip it so you get a :: [Int]
02:54:10 <ricebowl> buenos días araujo
02:54:11 <tromp_> morning, araujo
02:54:30 <araujo> Hello ricebowl tromp_ 
02:54:33 <araujo> What's up?
02:55:09 <ricebowl> > let foo (n, xs) = (n, zip (map fst xs) (snd (List.mapAccumL (\x y -> (y, y-x)) 0 (map snd xs)))) in foo (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])
02:55:10 <lambdabot> (1,[(1,10),(1,20),(1,40),(1,60),(1,270)])
02:55:15 <ricebowl> how's that?
02:55:34 <ricebowl> like I said, if monotonically increasing is what you want, just replace (map fst xs) with [1..]
02:55:37 <[CotL]Godofe_Kei> hmm
02:55:52 <ricebowl> @pl (\x y -> (y, y-x))
02:55:53 <lambdabot> ap (,) . subtract
02:56:28 <[CotL]Godofe_Kei> thats too complicated for me m8
02:56:36 <[CotL]Godofe_Kei> i realy cant understand that
02:57:16 <ricebowl> neither can I
02:57:25 <ricebowl> well, it's really not that difficult :p
02:57:32 <ricebowl> @type List.mapAccumL
02:57:34 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:57:51 <ricebowl> basically that's like a fold, but you get a separate "state" parameter
02:58:18 <[CotL]Godofe_Kei> hmm
02:58:26 <ricebowl> xs matches the second part of the original tuple and has type [(Int, Int)]
02:58:41 <ricebowl> map snd xs takes the second of each tuple, so you get [Int]
02:58:52 <ricebowl> > map snd [(1,2),(3,4),(5,6)]
02:58:54 <lambdabot> [2,4,6]
02:59:04 <ricebowl> those are the numbers that you want to subtract
02:59:15 <ricebowl> initially you subtract 0, so that's the initial value passed to mapAccumL
02:59:27 <ricebowl> then after each iteration it just passes in the previous number
02:59:32 <twb> @pl take 2 (repeat ' ')
02:59:33 <lambdabot> take 2 (repeat ' ')
02:59:47 <[CotL]Godofe_Kei> hmm yes i understand
02:59:52 <tromp_> > (\a->zipWith (-) a (0:a)) [10,30,70,130]
02:59:53 <twb> what's the function I'm thinking of?
02:59:54 <lambdabot> [10,20,40,60]
02:59:59 <ricebowl> there are other ways to do it, too
03:00:04 <ricebowl> twb - replicate
03:00:10 <ricebowl> > replicate 2 ' '
03:00:11 <lambdabot> "  "
03:00:16 <ricebowl> > take 2 (repeat ' ')
03:00:18 <lambdabot> "  "
03:01:00 <[CotL]Godofe_Kei> hmm
03:01:00 <MarcWeber> tromp_: What is "zip With"?
03:01:01 <ricebowl> Godofe_Kei - so, once you get that list, you can zip it with the original first halves of each tuple. That's the zip (map fst xs) part.
03:01:15 <[CotL]Godofe_Kei> ahh
03:01:30 <MarcWeber> Which editors are you using for code navigation?
03:01:34 <ricebowl> Godofe_Kei - then you package *that* list which is :: [(Int, Int)] back into the original tuple, so (n, zip ...)
03:01:48 <ricebowl> a little confusing written all together, but relatively simple :)
03:02:22 <[CotL]Godofe_Kei> hmm
03:02:26 <[CotL]Godofe_Kei> i got it thx
03:02:49 <[CotL]Godofe_Kei> i just dont get that mapAcuml
03:03:15 <ricebowl> hehe
03:03:26 <ricebowl> it's similar to fold...I've found it to be very, very useful ;)
03:03:39 <takuan> can somebody think of a better datatype for polynomials than "data  Poly a = Poly [(a,Int)]"?
03:03:39 <ricebowl> @type foldl
03:03:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:03:42 <ricebowl> @type List.mapAccumL
03:03:44 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:03:45 <MarcWeber> ricebowl: Can you read my text?
03:03:57 <ricebowl> MarcWeber - what do you mean?
03:04:18 <ricebowl> takuan - why would you use [(a, Int)]?
03:04:24 <takuan> well
03:04:27 <ricebowl> shouldn't you just be representing the coefficients?
03:04:31 <takuan> a is the type of the coefficient
03:04:34 <ricebowl> hence [Int] or [a] if you want it generic
03:04:35 <takuan> Int the power
03:04:41 <MarcWeber> I got no response. I'm trying to find out wether it's worth adding haskell to exuberant-ctags to be able to browse more efficient through haskell code using vim..
03:04:48 <takuan> lists are annoying since we want to have negative powers
03:04:52 <ricebowl> ah
03:05:13 <takuan> and it allows for prettyer printing
03:05:17 <MarcWeber> And want to know wether there is something similar around already
03:05:18 <ricebowl> MarcWeber - saw that comment, but I don't know anything about exuberant-ctags :p
03:05:27 <takuan> but the Poly in front makes things annoying
03:05:42 <ricebowl> takuan - you can do type Poly = [(a, Int)] if you like...
03:05:52 <takuan> ah
03:05:52 <ricebowl> then Poly becomes an alias and has no ctor
03:06:01 <lennart> takuan Poly a = Poly [([(a,Integer)], Coeff)]
03:06:08 <ricebowl> any arbitrary [(a, Int)] could be treated as a polynomial
03:06:12 <lennart> for some type of coefficients
03:06:41 <ricebowl> takuan - what you have already is basically the same, though
03:06:41 <lennart> I wrote a polynomial module day before yesterday :)
03:06:52 <joelr1> good morning!
03:06:55 <takuan> why so complex lennart?
03:07:01 <ricebowl> I'd expect that you decompose it into the list whenever you want to modify it, do all your operations on the list, and then recompose it
03:07:27 <takuan> the annoying thing is that I have to decompose it
03:07:34 <lennart> Well, I wanted polynomials over several variables
03:07:40 <takuan> since we have bunch of classes defining operations on a poly type
03:07:53 <takuan> but not on a [(a,Int)] type
03:08:04 <ricebowl> takuan - if that's really annoying, you could always define a function to extract the list component :p
03:08:13 <ricebowl> (which is almost equivalent to simply using a record type)
03:08:16 <takuan> so everytime you want to use those operations (which is very frequent) you have to compose them
03:08:30 <ricebowl> well (Poly xs) isn't that bad... :p
03:08:51 <ricebowl> why don't you make internal versions that operate on lists and then export only the versions that operate on the datatype itself?
03:09:03 <takuan> that's on option too
03:09:14 <takuan> but it wouldn't be as "beautiful"
03:09:17 <ricebowl> it's a little annoying to have to duplicate so much code, but...
03:09:20 <ricebowl> yes, I know
03:09:31 <ricebowl> duplicate in the sense of creating wrappers
03:09:31 <takuan> and that code already exists btw
03:09:36 <takuan> that's how it works now
03:09:38 <MarcWeber> ricebowl: It's a little C program parsing different languages which creates some kind of tags of definitions (methods, classes,.. ) some editors are using this to create a navigation tree. So it's really simple and fast to jump to the function you want.
03:09:40 <lisppaste2> twb pasted "Anyone care to offer style hints?" at http://paste.lisp.org/display/14895
03:10:06 <ricebowl> MarcWeber - ah
03:11:13 <[CotL]Godofe_Kei> ricebowl: can u just tell me whats wrong with this?
03:11:15 <[CotL]Godofe_Kei> -sub1 :: (Int,[(Int,Int)]) -> (Int,[(Int,Int)])
03:11:15 <[CotL]Godofe_Kei> --sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : sub1 xs) (reverse ((x,y):(a,b):xs))
03:11:41 <[CotL]Godofe_Kei> cant it work like this? can it be fixed? im much more confortable in doing things like this...i suck see?
03:12:01 <ricebowl> sub1 returns a (Int,[(Int,Int)]) -> (Int,[(Int,Int)])
03:12:11 <ricebowl> and you're trying to const a (Int, Int) onto that -- it won't work
03:12:17 <ricebowl> you can use a where clause to fix it, though
03:12:21 <MarcWeber> ricebowl: It looks like this http://www.geocities.com/yegappan/taglist/screenshots.html
03:12:39 <[CotL]Godofe_Kei> where clause how?
03:12:56 <ricebowl> hold on
03:13:25 <ricebowl> I don't know what the reverse part is supposed to do, either
03:13:31 <ricebowl> sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : xs')
03:13:31 <ricebowl> 	where (_, xs') = sub1 (n, (a,b):xs)
03:14:03 <ricebowl> (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])> let let (_, xs') = sub1 (n, (a,b):xs) in sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : xs') in sub1 
03:14:07 <ricebowl> er
03:14:12 <ricebowl> > let let (_, xs') = sub1 (n, (a,b):xs) in sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : xs') in sub1 (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])
03:14:13 <lambdabot>  Parse error in pattern
03:14:28 <takuan> ricebowl: you can't do type Poly = [(a, Int)]
03:14:36 <takuan> since a is not bound
03:14:40 <ricebowl> > let sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : (snd (sub1 (n, (a,b):xs)))) in sub1 (1,[(1,10),(1,30),(1,70),(1,130),(1,400)])
03:14:42 <lambdabot>  Non-exhaustive patterns in function sub1
03:14:46 <[CotL]Godofe_Kei> so it doenst work with the where??
03:14:48 <ricebowl> takuan - a does not have to be bound
03:15:08 <takuan> well it doesn't compile here anyway ricebowl 
03:15:14 <ricebowl> Godofe_Kei - it does, just not in the interpreter...but if you use the where clause it will compile
03:15:27 <ricebowl> takuan - actually, there is no way to bind a in a type definition... :p
03:15:35 <[CotL]Godofe_Kei> so its useless?
03:15:36 <takuan> i figured that out ;)
03:15:39 <[CotL]Godofe_Kei> if it doesnt work
03:15:43 <takuan> Not in scope: type variable `a'
03:15:46 <ricebowl> Godofe_Kei - it works fine, just not when I enter it here in chat
03:15:50 <takuan> that's what ghc tells me
03:15:53 <[CotL]Godofe_Kei> oh
03:15:56 <ricebowl> takuan - paste the type definition
03:15:59 <[CotL]Godofe_Kei> let me try in hugs
03:16:02 <ricebowl> Godofe_Kei - anyway, you're missing the final case
03:16:05 <takuan> type Polys = [(a,Int)]
03:16:13 <takuan> (sinc Poly is alread defined)
03:16:23 <ricebowl> Godofe_Kei - look at the code I pasted into chat. It would work except that you lack the final case.
03:16:24 <takuan> verbatim as you told me
03:16:49 <[CotL]Godofe_Kei> gram error: {sub1 (1,[(Num_fromInt instNum_v28 1,1212488)])} 
03:17:01 <ricebowl> takuan - oh, I see, I was thinking you were still using data... well, IIRC the syntax is type Polys a = [(a, Int)]
03:17:12 <[CotL]Godofe_Kei> so can it be fixed?
03:17:27 <ricebowl> [CotL]Godofe_Kei - yes, but you're going to have to put it into a file
03:17:33 <ricebowl> you have to add a tail case
03:17:39 <ricebowl> the case of (n, (x,y):[])
03:17:47 <[CotL]Godofe_Kei> = what?
03:17:48 <takuan> ricebowl: you can do it with a datadefinition too?
03:17:49 <ricebowl> and I can't have lambdabot evaluate it in chat
03:18:03 <ricebowl> takuan - of course, but type makes an alias, and aliases have no ctors
03:18:19 <[CotL]Godofe_Kei> sub1 (n, (x,y):[]) = ??
03:18:23 <ricebowl> rather, the ctor is the same as that of the original type
03:18:41 <ricebowl> [CotL]Godofe_Kei - you have to handle that case to the function. What happens if I pass your function (1, [])?
03:18:52 <ricebowl> you don't handle that case
03:19:00 <ricebowl> nor do you handle (1, [(1, 0)])
03:19:23 <[CotL]Godofe_Kei> hmm
03:19:33 <[CotL]Godofe_Kei> let me think
03:19:33 <takuan> ricebowl: what's a ctor? and how would you do the equivalent datadefinition
03:19:45 <takuan> i want to have a constraint on the type of a
03:19:52 <takuan> the type definition doesn't allow me to do that
03:20:28 <ricebowl> takuan - constructor :p
03:20:48 <[CotL]Godofe_Kei> but it can work?
03:21:00 <[CotL]Godofe_Kei> or am i just wasting your time?
03:21:06 <[CotL]Godofe_Kei> should i find another way?
03:21:12 <ricebowl> takuan - basically if you write data Poly1 a = Poly2 [(a, Int)] then Poly2 is your ctor. (These can have the same name, but I wanted to make the distinction clear.)
03:21:22 <ricebowl> [CotL]Godofe_Kei - yes, it can be made to work
03:21:37 <joelr1> Cale: ping
03:21:38 <[CotL]Godofe_Kei> argh!
03:21:41 <[CotL]Godofe_Kei> how?
03:21:42 <takuan> ok ricebowl 
03:21:48 <[CotL]Godofe_Kei> i cant!
03:21:48 * takuan got the point
03:22:31 <ricebowl> [CotL]Godofe_Kei - it's *much* easier if you decompose the problem
03:22:49 <ricebowl> look, you want to replace the second part in the tuple (Int, [(Int, Int)])
03:22:50 <[CotL]Godofe_Kei> im trying
03:22:56 <ricebowl> so write this:
03:23:04 <ricebowl> sub1 (n, xs) = (n, sub1' xs)
03:23:13 <ricebowl> now sub1 :: [(Int, Int)] -> [(Int, Int)]
03:23:14 <ricebowl> err
03:23:17 <ricebowl> sub1' :: [(Int, Int)] -> [(Int, Int)]
03:23:34 <ricebowl> you also want to leave the first half of each tuple unmolested, so do this:
03:24:26 <ricebowl> sub1' xs = let (ys,zs) = unzip xs in zip ys (sub1'' zs)
03:24:31 <ricebowl> sub1'' :: [Int] -> [Int]
03:24:49 <[CotL]Godofe_Kei> lol dude
03:24:53 <ricebowl> unzip and zip convert between [(a, a)] and ([a], [a])
03:25:10 <[CotL]Godofe_Kei> im so sorry but...thats realy out of my league
03:25:16 <[CotL]Godofe_Kei> im a noob at this
03:25:19 <ricebowl> I don't understand why you're saying that
03:25:22 <ricebowl> ok, so that makes 2 of us
03:25:27 <[CotL]Godofe_Kei> lolol
03:25:53 <[CotL]Godofe_Kei> i started to learn haskel 3 hours per weak about 2 months ago
03:25:54 <ricebowl> look... I'm telling you that the problem will be a lot easier to solve if you make it simpler
03:26:16 <[CotL]Godofe_Kei> i know it would be easier, just nobody tought me about those functions
03:26:18 <ricebowl> I started 3 months ago, so there's not a *ton* of difference
03:26:28 <[CotL]Godofe_Kei> maybe u had a better teacher
03:26:32 <[CotL]Godofe_Kei> mine sucks
03:26:46 <[CotL]Godofe_Kei> i leaned map, fold, and basicly that
03:27:01 <[CotL]Godofe_Kei> and when i say learned i mean they mentioned it
03:27:11 <ricebowl> *nods*
03:27:24 <[CotL]Godofe_Kei> i know...
03:27:27 <[CotL]Godofe_Kei> im a moron
03:27:36 <[CotL]Godofe_Kei> sub1 (n, (x,y):[]) = ??? cant this just be fixed?
03:27:44 <[CotL]Godofe_Kei> i could understand it if this worked
03:27:59 <ricebowl> it can, but it's going to be really complicated
03:28:08 <[CotL]Godofe_Kei> why?
03:28:12 <[CotL]Godofe_Kei> seems simple
03:28:17 <[CotL]Godofe_Kei> sub1 :: (Int,[(Int,Int)]) -> (Int,[(Int,Int)])
03:28:17 <[CotL]Godofe_Kei> sub1 (n, (x,y):[]) = 
03:28:17 <[CotL]Godofe_Kei> sub1 (n,((x,y):(a,b):xs)) = (n,(x,y-b) : xs')
03:28:17 <[CotL]Godofe_Kei> 	where (_, xs') = sub1 (n, (a,b):xs)
03:28:42 <ricebowl> because you're working with the full tuple, and you only want to change (Int, [(Int, Int)]) the part that I highlighted in the type. (Yay now I'm going to get kicked. :P)
03:29:02 <ricebowl> hmm, I thought colors and such were banned here... anyway!
03:29:20 <ricebowl> all those (n, ...) tuples are a lot of noise
03:29:31 <[CotL]Godofe_Kei> let me give you an example, i never learned to use let
03:29:40 <[CotL]Godofe_Kei> i understand it but i dont know how to use it
03:29:43 <ricebowl> I wasn't taught let in class either :P
03:29:47 <ricebowl> it's the same as where, AFAIK
03:29:56 <ricebowl> expr = let ... in ...
03:30:02 <ricebowl> expr = ... where ...
03:30:24 <[CotL]Godofe_Kei> hmm
03:30:27 <[CotL]Godofe_Kei> i understand
03:30:28 <[CotL]Godofe_Kei> ok
03:30:31 <[CotL]Godofe_Kei> im with you
03:30:35 <[CotL]Godofe_Kei> TEACH ME MASTER!
03:31:05 <ricebowl> ok, so! I'll back up a little bit...make an outer function sub1 which does this: sub1 (n, xs) = (n, sub1' xs)
03:31:09 <ricebowl> where sub1' is a helper function
03:31:22 <ricebowl> sub1' :: [(Int, Int)] -> [(Int, Int)]
03:31:26 <ricebowl> now you don't need to worry about n
03:31:39 <ricebowl> borrowing what you wrote before:
03:32:28 <ricebowl> sub1' ((a,x):(b,y):[]) = (a,x-y):(sub1' (b,y):[])
03:32:39 <ricebowl> you need another case, though:
03:32:43 <ricebowl> sub1' xs = xs
03:32:57 <ricebowl> that will match [] or (a,x):[] and just return them
03:33:14 <ricebowl> oh, I see what you were doing...
03:33:22 <ricebowl> ok, change sub1 to this (since you need the reverse):
03:33:40 <ricebowl> sub1 (n, xs) = (n, reverse (sub1' (reverse xs)))
03:34:25 <[CotL]Godofe_Kei> hmm
03:34:46 <[CotL]Godofe_Kei> and sub1'' :: [Int] -> [Int]?
03:34:50 <[CotL]Godofe_Kei> whats the rest?
03:35:19 <[CotL]Godofe_Kei> is thi correct?:
03:35:19 <[CotL]Godofe_Kei> sub1 :: [(Int, Int)] -> [(Int, Int)]
03:35:19 <[CotL]Godofe_Kei> sub1 (n, xs) = (n, reverse (sub1' (reverse xs)))
03:35:19 <[CotL]Godofe_Kei> sub1' :: [(Int, Int)] -> [(Int, Int)]
03:35:19 <[CotL]Godofe_Kei> sub1' xs = let (ys,zs) = unzip xs in zip ys (sub1'' zs)
03:35:37 <ricebowl> if you want a sub1'' then yes, that will work
03:35:40 <ricebowl> @type unzip
03:35:41 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
03:35:41 <ricebowl> @type zip
03:35:43 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
03:35:57 <ricebowl> that would be my preference, but the other way you were doing works too
03:36:07 <ricebowl> s/doing/doing it/
03:36:12 <[CotL]Godofe_Kei> what other way?
03:36:17 <[CotL]Godofe_Kei> --sub1 (n, (x,y):[]) = 
03:36:19 <[CotL]Godofe_Kei> this way?
03:36:48 <ricebowl> right, to just match the tuples directly
03:37:01 <ricebowl> I think it's easier to decompose [(Int, Int)] into [Int], though
03:37:10 <ricebowl> compare:
03:37:14 <[CotL]Godofe_Kei> yes your right
03:37:25 <[CotL]Godofe_Kei> but i dont have sub1'' defined
03:37:37 <ricebowl> sub1' ((a,x):(b,y):xs) = (a,x-y):(sub1' (b,y):xs)
03:37:38 <ricebowl> vs.
03:37:53 <ricebowl> sub1' (x:y:xs) = x-y:(sub1' y:xs)
03:38:07 <[CotL]Godofe_Kei> hmm
03:38:17 <[CotL]Godofe_Kei> the second one is better no?
03:38:20 <[CotL]Godofe_Kei> simpler
03:38:22 <ricebowl> yeah
03:38:35 <ricebowl> that's what I was trying to explain earlier :P
03:38:40 <[CotL]Godofe_Kei> lol
03:38:44 <[CotL]Godofe_Kei> but it doesnt work m8
03:38:45 <[CotL]Godofe_Kei> :P
03:38:56 <[CotL]Godofe_Kei> sub1 :: [(Int, Int)] -> [(Int, Int)]
03:38:56 <[CotL]Godofe_Kei> sub1 (n, xs) = (n, reverse (sub1' (reverse xs)))
03:38:56 <[CotL]Godofe_Kei> sub1' :: [(Int, Int)] -> [(Int, Int)]
03:38:56 <[CotL]Godofe_Kei> sub1' (x:y:xs) = x-y:(sub1' y:xs)
03:39:02 <[CotL]Godofe_Kei> this is what i have
03:39:06 <[CotL]Godofe_Kei> isnt it correct?
03:39:11 <ricebowl> right, sorry, I was comparing the two approaches
03:39:12 <ricebowl> no
03:39:21 <ricebowl> the problem is that the type doesn't match
03:39:24 <[CotL]Godofe_Kei> ah
03:39:39 <ricebowl> sub1' :: [(Int, Int)] -> [(Int, Int)]
03:39:41 <ricebowl> @type unzip
03:39:43 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
03:40:05 <ricebowl> @type zip
03:40:06 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
03:40:13 <ricebowl> sub1' xs = let (ys, zs) = unzip xs in zip ys (sub1'' zs)
03:40:34 <ricebowl> so ys gets all the a's and zs gets all the b's
03:40:35 <[CotL]Godofe_Kei> but that way i need to define sub''
03:40:38 <ricebowl> yes, right
03:40:48 <ricebowl> so the work isn't 100% complete, but now the problem is very simple
03:40:52 <ricebowl> sub1'' :: [Int] -> [Int]
03:41:08 <ricebowl> sub1'' (x:y:xs) = x-y:(sub1'' y:xs)
03:41:18 <ricebowl> sub1'' xs = xs -- base case
03:41:49 <[CotL]Godofe_Kei> doesnt work
03:42:15 <[CotL]Godofe_Kei> *** Expression     : sub1'' y
03:42:15 <[CotL]Godofe_Kei> *** Term           : y
03:42:15 <[CotL]Godofe_Kei> *** Type           : Int
03:42:15 <[CotL]Godofe_Kei> *** Does not match : [Int]
03:42:28 <[CotL]Godofe_Kei> it needs to be a List
03:42:43 <ricebowl> oops
03:42:46 <ricebowl> sub1'' (x:y:xs) = x-y:(sub1'' (y:xs))
03:43:02 <[CotL]Godofe_Kei> lol
03:43:06 <[CotL]Godofe_Kei> stil doesnt work
03:43:15 <ricebowl> yeah, it's because : is infix, so it parsed as (sub1'' y):xs
03:43:17 <[CotL]Godofe_Kei> let me think
03:43:25 <ricebowl> a syntax error or semantic error?
03:43:34 <[CotL]Godofe_Kei> *** Term           : (n,xs)
03:43:34 <[CotL]Godofe_Kei> *** Type           : (a,b)
03:43:34 <[CotL]Godofe_Kei> *** Does not match : [(Int,Int)] 
03:45:04 <ricebowl> oh
03:45:10 <ricebowl> your type signature on sub1 is wrong :p
03:45:20 <ricebowl> sub1 :: (Int, [(Int, Int)]) -> (Int, [(Int, Int)])
03:45:21 <[CotL]Godofe_Kei> yeah
03:45:25 <[CotL]Godofe_Kei> your right lol
03:46:27 <[CotL]Godofe_Kei> dude
03:46:32 <ricebowl> does it work?
03:46:36 <[CotL]Godofe_Kei> it compiles...but it doesn nothing
03:46:44 <[CotL]Godofe_Kei> sub1 (1,[(1,303433),(1,606817),(1,909271),(1,1212488)])
03:46:44 <[CotL]Godofe_Kei> (1,[(1,303433),(1,606817),(1,909271),(1,1212488)]) 
03:46:54 <ricebowl> well, hold on then
03:47:24 <ricebowl> I'm going to have to rewrite a bit to get this into GHCi
03:47:26 <ricebowl> ugh
03:47:36 <[CotL]Godofe_Kei> use hugs98
03:47:41 <[CotL]Godofe_Kei> it suports copy and paste
03:47:42 <[CotL]Godofe_Kei> :D
03:47:58 <ricebowl> they're the same with regard to that; that's not the problem
03:49:08 <[CotL]Godofe_Kei> i think the problem is in sub3 xs = xs 
03:50:01 <ricebowl> depends on where you put it
03:50:05 <ricebowl> that has to be the last case
03:52:06 <[CotL]Godofe_Kei> hmm
03:52:43 <ricebowl> BTW, the advantage to this is that it's much easier to test the important part
03:52:50 <ricebowl> Prelude> reverse (sub1'' (reverse [303433,606817,909271,1212488]))
03:52:50 <ricebowl> [303433,303384,302454,303217]
03:53:13 <[CotL]Godofe_Kei> it works?
03:53:49 <ricebowl> yeah
03:53:54 <ricebowl> for me, yeah
03:53:58 <[CotL]Godofe_Kei> then why doesnt sub1 works?
03:53:59 <ricebowl> see if you get the same result
03:54:38 <[CotL]Godofe_Kei> nop i dont
03:54:53 <[CotL]Godofe_Kei> Program error: {sub3 [Num_fromInt instNum_v28 303433]} 
03:55:02 <[CotL]Godofe_Kei> oh nvm
03:55:04 <[CotL]Godofe_Kei> it works
03:55:07 <[CotL]Godofe_Kei> ops
03:55:09 <[CotL]Godofe_Kei> no it doesnt
03:55:29 <[CotL]Godofe_Kei> whats the hell?
03:55:34 <ricebowl> Prelude> let xs = zip [1..] [303433,606817,909271,1212488]
03:55:36 <ricebowl> Prelude> sub1 (1, xs)
03:55:36 <ricebowl> (1,[(1,303433),(2,303384),(3,302454),(4,303217)])
03:55:49 <ricebowl> I copied and pasted the code from chat into GHCi
03:55:58 <[CotL]Godofe_Kei> hmm
03:55:59 <[CotL]Godofe_Kei> sub1 :: (Int, [(Int, Int)]) -> (Int, [(Int, Int)])
03:55:59 <[CotL]Godofe_Kei> sub1 (n, xs) = (n, reverse (sub2 (reverse xs)))
03:55:59 <[CotL]Godofe_Kei> sub2 :: [(Int, Int)] -> [(Int, Int)]
03:55:59 <[CotL]Godofe_Kei> sub2 xs = let (ys, zs) = unzip xs in zip ys (sub3 zs)
03:55:59 <[CotL]Godofe_Kei> sub3 :: [Int] -> [Int]
03:56:01 <[CotL]Godofe_Kei> sub3 xs = xs 
03:56:02 <ricebowl> the only difference is that I modified sub1'' because I can't do cases interactively
03:56:03 <[CotL]Godofe_Kei> sub3 (x:y:xs) = x-y:(sub3 (y:xs))
03:56:05 <[CotL]Godofe_Kei> i have this
03:56:07 <[CotL]Godofe_Kei> should work!
03:56:10 <ricebowl> no it shouldn't
03:56:15 <ricebowl> sub3 xs = xs has to come *last*
03:56:15 <[CotL]Godofe_Kei> ?!
03:56:30 <ricebowl> otherwise it will never match the other case
03:56:38 <[CotL]Godofe_Kei> ah
03:56:43 <[CotL]Godofe_Kei> so i was right
03:56:43 <[CotL]Godofe_Kei> lol
03:56:50 <[CotL]Godofe_Kei> i knew it had to be because of that
03:57:09 <[CotL]Godofe_Kei> lol
03:57:11 <[CotL]Godofe_Kei> it works now
03:57:15 <ricebowl> cool
03:57:55 <[CotL]Godofe_Kei> thx a llot m8
03:57:59 <[CotL]Godofe_Kei> so sorry to bothe
03:58:01 <[CotL]Godofe_Kei> bother*
03:58:32 <joelr1> musasabi: ping
03:59:01 <joelr1> folks, how do you use configure with cabal? to find platform endianness for example
03:59:16 <ricebowl> no problem
04:00:33 <musasabi> pong
04:00:40 <[CotL]Godofe_Kei> where do i put the zip [1..]?
04:00:43 <joelr1> musasabi: have you used configure with cabal?
04:00:48 <[CotL]Godofe_Kei> in the code to work like that?
04:01:00 <musasabi> yes, e.g. in network-alt
04:01:15 <Lemmih> joelr1: http://haskell.org/ghc/docs/latest/html/Cabal/authors.html#system-dependent
04:01:18 <joelr1> musasabi: i would like to 1) determine platform endianness and 2) use a particular brand of reverse (noop or actual reverse) in the c code
04:01:45 <joelr1> Lemmih: thanks
04:02:41 <musasabi> joelr1: I have the following:
04:02:42 <musasabi> AC_CHECK_FUNCS([htons htonl ntohs ntohl in6addr_any])
04:02:43 <musasabi> AC_C_BIGENDIAN([AC_DEFINE([HAVE_BIGENDIAN], [1], [Compiling for a big endian platform])], 
04:02:46 <musasabi>                [AC_DEFINE([HAVE_LITTLEENDIAN],[1], [Compiling for a little endian platform])])
04:03:51 <joelr1> musasabi: the HAVE_ .. .where do they come from?
04:04:00 <joelr1> musasabi: who calculates them?
04:06:23 <musasabi> joelr1: they are just defines, AC_C_BIGENDIAN does the work and autoconf provides that out of box.
04:06:47 <joelr1> joelr1: cool. i did not know about autoconf providing AC_C_BIGENDIAN
04:06:59 <joelr1> musasabi: i'll just copy your approach then
04:07:48 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt/build/autohell/configure.ac
04:08:05 <joelr1> musasabi: i pulled it from darcs. just updated it in fact
04:08:06 <joelr1> thanks
04:08:20 <[CotL]Godofe_Kei> ricebowl: U here?
04:10:11 <ricebowl> yeah
04:10:14 <ricebowl> was just reading
04:10:26 <[CotL]Godofe_Kei> i cant adapt the zip [1..] to the rest
04:10:31 * ricebowl was reading about Deng Xiaoping, the architect of modern China :p
04:10:37 <[CotL]Godofe_Kei> all it does is replace the fst with 1 2 3 4 etcright?
04:10:39 <ricebowl> what specifically are you trying to do?
04:10:43 <ricebowl> yeah
04:10:53 <[CotL]Godofe_Kei> im trying to put it in the code
04:10:55 <ricebowl> that would be in sub2
04:10:58 <ricebowl> instead of this: sub2 xs = let (ys, zs) = unzip xs in zip ys (sub3 zs)
04:11:15 <ricebowl> write this: sub2 xs = zip [1..] (sub3 (map snd xs))
04:11:31 <ricebowl> > map snd [(0,1),(2,3),(4,5),(6,7)]
04:11:33 <lambdabot> [1,3,5,7]
04:12:29 <[CotL]Godofe_Kei> hm
04:12:37 <[CotL]Godofe_Kei> the numbers appear in reverse
04:12:45 <[CotL]Godofe_Kei> (1,[(4,303433),(3,303384),(2,302454),(1,303217)]) 
04:13:29 <[CotL]Godofe_Kei> doesnt the unzip need to be ther too?
04:15:13 <ricebowl> well unzip xs = (map fst xs, map snd xs)
04:15:21 <ricebowl> you could do it with unzip too
04:16:13 <[CotL]Godofe_Kei> but i dont understand why they appear reversed
04:17:27 <ricebowl> oh
04:17:29 <ricebowl> whoops
04:17:38 <ricebowl> that's because of the way you wrote sub1
04:17:56 <ricebowl> ugh, then it's a bit trickier
04:18:12 <ricebowl> sub2 xs = zip (reverse [1..length xs]) (sub3 (map snd xs))
04:18:17 <ricebowl> I think that should work
04:18:33 <skew> or, [length xs, length xs-1..1]
04:18:41 <ricebowl> oh
04:18:46 <ricebowl> yeah if you do that, it works too
04:27:59 <joelr1> musasabi: ping
04:31:43 <musasabi> pong
04:31:56 <joelr1> musasabi: do you dig top-level splices? :-)
04:32:46 <lisppaste2> joelr1 pasted "Splices" at http://paste.lisp.org/display/14897
04:33:16 <joelr1> musasabi: i'm calling TH to the rescue. isBigEndian works like a charm but now i'm trying to define my reverse routines the same way 
04:33:32 <joelr1> but i get the dreaded error
04:33:33 <joelr1> Swap.hs:23:27:
04:33:33 <joelr1>     GHC stage restriction: `v'
04:33:33 <joelr1>       is used in a top-level splice, and must be imported, not defined locally
04:33:33 <joelr1>     In the first argument of `shiftR', namely `v'
04:33:36 <joelr1>     In the first argument of `(+)', namely `(v `shiftR` 8)'
04:33:59 <musasabi> joelr1: you must define the TH in one module and use it in the other one.
04:34:32 <joelr1> musasabi: this is slightly different, take a look at the pate
04:34:33 <joelr1> paste
04:34:55 <kzm> @seen shapr
04:34:56 <lambdabot> shapr is in #ScannedInAvian and #haskell. I don't know when shapr last
04:34:56 <lambdabot> spoke.
04:35:01 <musasabi> joelr1: module1 should export ifBigEndian and module2 to use it like foobar = $(ifBigEndian beFunc leFunc)
04:35:04 <joelr1> musasabi: i'm trying to define a swap16 routine that does things differently depending on certain things
04:35:36 <skew> joelr1: you are not allowed to use a function defined in a file inside of a TH splice in the same file
04:35:36 <joelr1> musasabi: would you kindly take a look at paste? i'm not using isBigEndian in swap16
04:35:48 <musasabi> joelr1: yes, I looked at the paste.
04:35:49 <joelr1> skew: look at paste
04:36:00 <joelr1> musasabi: it's complaining about v in swap16
04:36:12 <joelr1> _not_ about isBigEndian
04:36:20 <musasabi> joelr1: the error will go away if you do like we say.
04:36:41 <joelr1> musasabi: not likely. i NEED to use v in swap16
04:36:54 <joelr1> musasabi: unless you can tell me a way of not doing it
04:37:47 <skew> I don't understand lift. I'd suggest moving the splice out even more
04:37:50 <joelr1> what i'm trying to do is use TH to define a swap16 routine that evals to either the reverse bit or to just the value passed to it
04:38:21 <joelr1> the isBigEndian is there just to show how it is done. it works and i have used it.
04:38:23 <skew> I'm not sure lift is even written to handle that case.
04:38:50 <skew> I think it's more for constants rather than parameters, but I'm pretty out of date
04:38:53 <joelr1> skew: wanna try it? all i want is a compile-time eval of the if
04:39:08 <skew> yeah, I'm writing some code
04:40:21 <joelr1> @type const
04:40:22 <lambdabot> forall a b. a -> b -> a
04:40:35 <joelr1> @type id
04:40:36 <lambdabot> forall a. a -> a
04:41:58 <joelr1> i think it can be done without importing v by having TH define a partial function
04:42:41 <joelr1> i.e. (v `shiftR` 8) + ((v .&. 0xFF) `shiftL` 8) as a partial function
04:43:02 <joelr1> (v `shiftR` 8 ) + ((v .&. 0xFF) `shiftL` 8 )
04:43:31 <skew> that's what I was saying about pushing the splice out
04:43:55 <skew> but I'll just post the code rather than trying to explain better
04:44:04 <joelr1> skew: how would you rewrite the above as a partial function given that + requires two arguments... hmm
04:44:07 <joelr1> skew: ok, thanks
04:44:46 <lisppaste2> skew annotated #14897 with "declaration splict" at http://paste.lisp.org/display/14897#1
04:45:00 <skew> oops, that should be "declaration splice"
04:45:26 <skew> Hmm, maybe you don't know that you can splice in whole declarations, like different versions of swap16
04:45:48 <joelr1> skew: i did not know
04:46:16 <joelr1> skew: by different versions you mean one that returns v and the other that returns reverse?
04:46:48 <skew> in my code, what is being spliced in is a function declaration. Depending on the test, it's either the identity or the one that does the swapping
04:47:36 <joelr1> right
04:48:04 <joelr1> an interesting side-effect is that i can specialize it now
04:48:05 <joelr1> hmm
04:48:33 <joelr1> skew: i had it specialized for Word16 and Int16
04:49:18 <skew> yeah, it didn't compile with those specializations included
04:49:28 <joelr1> skew: but i suppose that needs to be done in the module that actually uses swap16
04:49:33 <joelr1> skew: what do you think?
04:49:53 <skew> I think the pragma can go in the defining module
04:49:56 <joelr1> skew: my goal is to compile with -O -ddump-simpl and look at the output to make sure it's as close to C as possible
04:50:16 <skew> the user's guide explains RULES and SPECIALIZE
04:50:19 <joelr1> skew: defining meaning the one where you have TH? let me see if it works if i put it after the declaration
04:50:28 <joelr1> skew: i looked at the user's guide
04:50:45 <skew> It compiles fine if you put them in the [d| |] quotation
04:50:56 <joelr1> aha!
04:51:33 <skew> I won't trust that it works unless I find the corresponding type in the TH module
04:53:54 <joelr1> skew: thanks a whole lot!
04:54:39 <skew> I suspect putting the pragma in the splice doesn't work. Putting it in another module should work fine, though.
04:55:19 <joelr1> skew: let me see what ghc translates a call to swap16 to
04:56:23 <ski> (Philippa : toplevel type variables ?)
04:56:48 <skew> it doesn't work - with one version and the pragmas hardcoded, nm shows specialized versions floating around, taking my paste and putting pragmas in the quasiquote doesn't give those versions
04:58:48 <joelr1> skew: hmm
04:58:54 <skew> strange - it compiles but doesn't specialize if the pragma is after the splice
04:58:57 <joelr1> skew: did you look at core output?
04:59:05 <skew> no, just nm on the .o file
04:59:15 <joelr1> skew: it actually _does_ work
04:59:17 <joelr1> check this out
04:59:42 <joelr1> give me a sec
05:01:11 <lisppaste2> joelr1 annotated #14897 with "swap II" at http://paste.lisp.org/display/14897#2
05:01:20 <joelr1> skew: check that out
05:02:33 <skew> oh, I think that's just ordinary inlining
05:02:43 <joelr1> skew: if you are on a wintel then it should be even better
05:02:58 <joelr1> skew: hmm... 
05:03:02 <skew> plus, specializations of + and shifts
05:03:04 <soysauce> there's no way to write a Haskell program in Unicode, is there?
05:03:16 <soysauce> i.e. I want variable names whose representation uses Unicode characters
05:03:32 <joelr1> skew: ok, let me try removing the specialization pragmas
05:03:55 <joelr1> skew: and the inlining
05:04:18 <joelr1> skew: true, looks the same
05:04:27 <skew> that probably makes no difference, it's small enough GHC will probably inline it anyway
05:04:39 <skew> or, at least package it up in the .hi file for possible inlining
05:05:44 <skew> here we go - with a specialize pragma active, I get a symbol Swap_zdsswap161_closure in the .o file
05:06:16 <skew> without it, just the Swap_swap16_closure symbol
05:06:26 <skew> Oh, and SPECIALIZE in another module won't work
05:06:41 <joelr1> skew: so then my version does work? :-) /yes, to not working in another module, just tried that :)/
05:07:05 <skew> part of SPECIALIZE just sets up some RULES, but another part is compling the specialized version of the code
05:07:26 <joelr1> skew: so what's the resolution on this?
05:07:34 <skew> you could also do this with a preprocessor
05:07:54 <joelr1> skew: does is work with pragmas in the TH or not?
05:08:01 <joelr1> skew: do what with a pre-processor? 
05:08:14 <skew> conditionally define the swapping or non-swapping version
05:08:27 <joelr1> skew: it seems that to do with with CPP i would need to pull in the autoconf shebang
05:08:37 <skew> btw, you should call the function something like hton16, which is accurate whether or not the endianess matches
05:08:42 <skew> what are you building with now?
05:08:42 <joelr1> skew: or just remind the customer to set a flag every time they check out the source :)
05:08:46 <joelr1> skew: cabal
05:08:59 <skew> I think that will run the preprocessor if you ask it
05:09:02 <joelr1> skew: but i'm on powerpc and the customer is on freebsd/intel
05:09:14 <joelr1> skew: so the flag will need to be different for me and for them
05:09:34 <skew> you have a customer already?
05:09:53 <joelr1> skew: of course. the project has been paid in full, actually. and i'm still delivering it :(
05:10:14 <skew> oh, I thought this was more like prototyping
05:10:43 <joelr1> skew: no way. i'm trying to speed up my serialization code and reverse (swap) is currently taking like 20% of the time
05:10:47 <musasabi> why not just use the #ifdef way?
05:11:07 <musasabi> + configure
05:11:20 <joelr1> musasabi: because every time i check in the code into darcs and the customer checks out they would need to edit the flag :) and because i think th is simpler than configure. 
05:11:46 <joelr1> if i were to use configure i might just as well define the swapping in C
05:11:48 <musasabi> TH simpler than configure?
05:12:06 * musasabi thinks that is not very true
05:12:23 <joelr1> well, in this particular case
05:12:28 <musasabi> TH is complex and underdocumented with 6.4 lacking in error descriptions
05:12:44 <joelr1> i have a working version of swap16 with skew's help 
05:12:48 <musasabi> and with #ifdefs you know what you are getting
05:12:49 <joelr1> take a look at paste
05:12:58 <skew> ok, it looks like the SPECIALIZE doesn't work at all inside the splice
05:13:01 <joelr1> musasabi: and it seems to do what i need it to do
05:13:09 <musasabi> except for pragmas etc
05:13:14 <joelr1> oops. now skew is bringing the bad news :(
05:13:28 <joelr1> skew: but does it matter in this case?
05:13:37 <musasabi> lunch ->
05:13:44 <joelr1> i.e. do i get a further performance boost if i use #ifdef
05:14:03 <joelr1> skew: shall we do a test? with #ifdef and pragmas?
05:14:15 <skew> it probably doesn't hurt performance
05:14:22 <joelr1> skew: let me try
05:14:30 <skew> or, it will only hurt it where the call isn't inlined
05:15:13 <skew> did you ever fix your serialization problem?
05:15:26 <joelr1> skew: i'm doing it with your help ;)
05:15:42 <skew> your tgz seems to be down, and I never understood why you needed to serialize the same 50k of data once per client
05:15:53 <joelr1> down?
05:15:54 <joelr1> let me try
05:16:17 <joelr1> http://wagerlabs.com/timeleak.tgz
05:16:20 <joelr1> does not look down to me
05:16:29 <skew> yeah, that one.
05:16:34 <joelr1> try now
05:16:53 <skew> hmm, maybe I was copying in a period from the end of sentance
05:17:29 <joelr1> skew: wow, learned a lesson!
05:18:24 <lisppaste2> joelr1 annotated #14897 with "#define rules" at http://paste.lisp.org/display/14897#3
05:18:30 <joelr1> skew: check this out!
05:19:16 <skew> What's that from?
05:19:22 <joelr1> no, i'm doing something wrong... i think
05:19:45 <lisppaste2> joelr1 annotated #14897 with "this is from" at http://paste.lisp.org/display/14897#4
05:19:57 <joelr1> shouldn't it have inlined swap?
05:20:26 * joelr1 scratches his head
05:21:15 <skew> do you really need to mask off bytes if you are shifting anyway?
05:21:18 <joelr1> this is wierd
05:21:32 <joelr1> skew: just removed a whole bunch of imports, right? left just the needed ones
05:21:36 <skew> what is output #3 from?
05:21:51 <twb> Is there a way to have qualified names without using directories?
05:22:04 <lisppaste2> joelr1 annotated #14897 with "different results" at http://paste.lisp.org/display/14897#5
05:22:26 <joelr1> skew: i had various imports before and reduced them to this
05:22:43 <lisppaste2> joelr1 annotated #14897 with "and now from this" at http://paste.lisp.org/display/14897#6
05:23:07 <skew> twb: not with GHC - jhc lets you use filenames with dots in them, but it's still pretty experimental
05:23:28 <joelr1> skew: #3 had the same set of imports as in the beginning
05:23:29 <twb> Hmm, okay.
05:24:16 <joelr1> skew: so the end result looks almost the same as TH, no?
05:25:14 <skew> no, end result looks better (if that core is from Swap), because SPECIALIZE actually worked
05:25:24 <twb> Hmm.
05:26:01 <joelr1> skew: it looks better to me with TH
05:26:23 <joelr1> skew: because now i have a fun call in foo whereas it was inlined before
05:26:42 <skew> oh, did you post that?
05:26:47 <twb> I have two files, a library Text.Restructured (in ./Text/Restructured.lhs), and a unit test library Main (./Text/Restructured/Tests.hs).  Calling "ghc Text.Restructured.Tests -e tests" doesn't work.  What should I be doing?
05:26:58 <joelr1> skew: take a look at the last paste
05:27:01 <joelr1> annotation
05:27:20 <adept> twb: define "does not work"?
05:27:34 <twb> adept: Could not find module `Text.Restructured.Tests':
05:27:59 <joelr1> skew: TH seems to give better output _without_ the pragmas 
05:28:09 <skew> joelr1: I thought that was the core from compiling Swap.hs
05:28:15 <adept> twb: ghc -I. Text.Restructured.Tests -e tests ?
05:28:17 <twb> Argh, the shell was in the wrong PWD.  Lemme try again.
05:28:20 <skew> the core you were looking at before was the core from building main
05:28:39 <joelr1> skew: it produces a single file
05:28:56 <joelr1> where i can see both swap16 and foo
05:29:11 <joelr1> ghc --make Foo.hs -O -ddump-simpl > foo
05:29:17 <twb> adept: ghc-6.4.1: user specified .o/.so/.DLL could not be loaded.
05:29:29 <twb> adept: ...with "-l."
05:30:21 <skew> annotation 3 has a foo in it
05:30:42 <joelr1> yes, it produces a single core file
05:30:47 <skew> but I don't see one in 5/6
05:30:52 <joelr1> let me make two versions so that you can see the difference
05:31:01 <joelr1> skew: that's cause i did not post it
05:31:08 <joelr1> skew: hang on, lets make it formal
05:31:09 <soysauce> @type (:&)
05:31:11 <lambdabot> Not in scope: data constructor `:&'
05:31:16 <soysauce> @type (&)
05:31:18 <lambdabot> Not in scope: `&'
05:31:24 <soysauce> @type and
05:31:26 <lambdabot> [Bool] -> Bool
05:31:34 <soysauce> @type (Data.Word.&)
05:31:35 <lambdabot> Not in scope: `Data.Word.&'
05:31:43 <ski> @index (&)
05:31:44 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive
05:31:44 <skew> @type (.&.)
05:31:46 <lambdabot> Not in scope: `.&.'
05:31:51 <ski> @index (.&.)
05:31:51 <lambdabot> Data.Bits, Foreign
05:31:53 <soysauce> ah
05:33:09 <soysauce> excellent
05:34:30 <lisppaste2> joelr1 annotated #14897 with "#define version" at http://paste.lisp.org/display/14897#7
05:34:35 <joelr1> skew: here's one for you
05:35:11 <soysauce> @type Data.Bits.complement
05:35:13 <lambdabot> forall a. (Data.Bits.Bits a) => a -> a
05:37:41 <skew> are you compiling with -O?
05:37:51 <lisppaste2> joelr1 annotated #14897 with "TH version 1" at http://paste.lisp.org/display/14897#8
05:38:08 <joelr1> skew: same thing always  ghc --make Foo.hs -O -ddump-simpl > foo
05:39:37 <skew> that should be equivalent to using the #ifdef without SPECIALIZE
05:40:16 <adept> twb: that's capital "i", not "l"
05:40:35 <joelr1> skew: inserting specialize into TH made no difference
05:40:56 <skew> yeah, and it should be the same as using the #ifdef without SPECIALIZE
05:40:57 <joelr1> skew: so the results seems to be that it _should_ be the same but it's not
05:41:02 <joelr1> skew: right?
05:41:15 <joelr1> skew: the TH version somehow unrolls things
05:41:31 <joelr1> skew: at foo1, thus avoiding the function call
05:41:58 <skew> it looks to me like your IFDEF code has SPECIALIZE and INLINE pragmas written in it
05:42:16 <joelr1> skew: yes, why?
05:42:41 <skew> I think if you removed those from the #ifdef code, then it would behave the same as the TH code
05:42:55 <joelr1> skew: hmm... let me see...
05:43:16 <skew> My guess is that the SPECIALIZE rule is firing before the function has a chance to be inlined, and maybe the specialized versions SPECIALIZE builds don't come with inlining information
05:45:38 <lisppaste2> joelr1 annotated #14897 with "#define w/o pragmas" at http://paste.lisp.org/display/14897#9
05:45:46 <joelr1> skew: this is WIERD
05:46:03 <joelr1> skew: it inlined foo1 without the pragmas 
05:46:09 <skew> sure
05:46:11 <joelr1> skew: but did _not_ inline foo1 with them
05:46:14 <skew> what's so wierd about that?
05:46:26 <skew> GHC inlines any small things whether you say INLINE or not
05:46:30 <joelr1> skew: i would have expected results to be the same
05:46:47 <joelr1> skew: but it did not inline foo1 when i had the pragmas on swap16 (no TH)
05:48:22 <joelr1> skew: do you see why i think it's wierd now?
05:48:39 <twb> adept: Oh, right.
05:48:44 <skew> I think my theory explains what's going on. I'm checking the names to be sure
05:48:53 <joelr1> skew: what's your theory?
05:48:55 <twb> adept: small font, sorry :-)
05:49:47 <skew> the rewrite that turns swap16 on an Int16 into a call to $sswap16 is applied before swap16 is inlined
05:50:32 <adept> twb: works now?
05:50:46 <skew> the wrapper function $sswap16 is inlined, as you can see from the __inline_me on that line of annotation 7, but the worder $w$sswap16 isn't marked for inlining
05:51:07 <skew> so main is left with a call to $w$sswap16
05:51:10 <twb> adept: "./Text/Restructured.lhs: file name does not match module name `Restructured'"
05:51:19 <joelr1> skew: so what is the solution?
05:51:35 <joelr1> skew: seems like a bug of sorts to me
05:52:18 <joelr1> skew: and a counter-intuitive one at that. turns pragmas on and do not get optimization. turn pragmas off and get it.
05:52:30 <joelr1> skew: do you think it's a "bug"
05:52:36 <skew> not really
05:52:44 <Philippa_> twb: it thinks it's Text.Restructured
05:52:45 <skew> well, kind of
05:52:49 <twb> Yeah.
05:52:54 <twb> That's kinda confusing.
05:52:54 <skew> it's more like this is tricky, than incorrect
05:52:58 <joelr1> skew: thank you for agreeing with me :)
05:53:21 <joelr1> skew: i'm gonna post it to haskell-cafe to see what everyone else thinks
05:53:33 <skew> becauste it is replacing function calls of the right type with a call to a more efficient version as advertised
05:53:56 <skew> but in this case it turns out to be even more efficient to inline the generic version and optimize from there
05:54:03 <joelr1> skew: but you get more mileage by not telling it to inline stuff here because it inlines stuff there
05:54:28 <skew> I think if the worker functions were marked for inlining it would come out just the same
05:54:31 <twb> It's a PITA having to have the files in particular places, tho.
05:54:48 <joelr1> skew: what peeves me is that it does not follow advetized logic here
05:54:51 <twb> Especially since the dir Restructured/ will interfere with completion when opening Restructured.lhs.
05:55:20 <joelr1> skew: i'm trying to figure out how i can rely on the compiler to do the right thing
05:55:28 <skew> hmm, I was hoping you could improve things by putting a staging annotation on the SPECIALIZE, but I guess not
05:55:42 <joelr1> skew: did you try that (staging annotation)
05:55:55 <skew> yeah, it's a syntax error
05:56:04 <soysauce> argh, wtf
05:56:08 <soysauce> GHCi crashed yet again
05:56:19 <soysauce> > [Data.Bits.bit x | x <- [0..], x < 64] :: [Data.Word.Word64]
05:56:25 <lambdabot> Terminated
05:56:34 <joelr1> skew: you were right about masking, no need to do it for swap16
05:56:48 <skew> do you understand my theory about this behaviour?
05:57:16 <twb> Is there a way to make ghc return a failure status (to Make) when a QuickCheck test fails?
05:57:35 <joelr1> skew: i think i do... sort of.. lets do this... let me post to cafe and you will reply with your theory, ok? so that we can see what everyone else is thinking
05:57:38 <joelr1> skew: what do you think?
05:57:50 <skew> ok
05:58:27 <joelr1> skew: what's your name?
05:58:33 <skew> Brandon
05:58:36 <ski> (soysauce : you know that list can't terminate, right ?)
05:58:52 <joelr1> skew: ok, so I'll say Brandon and I ... hang on a sec
05:58:58 <soysauce> ski - that's what the constraint was for...although I know that I should have written [0..63]
05:59:25 <soysauce> ah hm, I see, so it just sat there evaluating
05:59:42 <ski> using 'x <- [0..], x < 64' will make it generate bigger and bigger numbers, failing back each time
05:59:46 <soysauce> still, why does GHCi crash instead of doing what lambdabot does?
05:59:55 <ski> (shouldn't crash anyway, though)
05:59:59 <soysauce> yes
06:00:06 <soysauce> I've seen both Hugs and GHCi crash *often*
06:00:15 * ski 's ghci didn't crash ..
06:00:22 <soysauce> Hugs crashed when I forgot a base case in an implementation of sort
06:00:26 <soysauce> which platform?
06:01:09 <ski> Debian/Linux on x86
06:01:55 <ski> (hugs can crash because it smashes the C stack .. this is a known bug, i think)
06:02:43 <soysauce> shouldn't it transform that into tail recursion, i.e. a loop?
06:03:17 <ski> not sure about this case
06:04:27 <soysauce> hm, on Ubuntu/x86 it doesn't crash, just runs for forever
06:04:41 <soysauce> I wonder what the difference is
06:04:42 <ski> (same here)
06:04:52 <ski> (hm, which ghc version ?)
06:05:02 * ski has 6.2.2. here
06:05:06 <soysauce> 6.4 on Ubuntu, I believe
06:05:13 <soysauce> 6.4.1 on Windows
06:05:53 <ski> (maybe you could search known bugs and/or bugs mailing list, failing that report a bug ?)
06:07:23 <soysauce> perhaps later
06:08:09 <soysauce> am a bit busy at the moment trying to translate this C code into Haskell
06:08:33 <twb> soysauce: I remember another bug manifests in Debian's ghc but not Ubuntu's.
06:08:45 * ibid feels like advertising my latest haskell program
06:08:52 <ibid> see here -> http://antti-juhani.kaijanaho.info/tmp/screenshot.png :)
06:09:06 <twb> soysauce: http://hackage.haskell.org/trac/ghc/ticket/631
06:09:18 <joelr1> skew: posted!
06:09:20 <twb> ibid: pictures are hard.  I'm on a thin client :-(
06:09:34 <ibid> twb: hehe :)
06:10:00 <ibid> twb: well, you'd probably not get much out of the program itself either, as it's gtk2hs-based :)
06:10:05 <twb> Isn't "unbounded tic-tac-toe" basically go?
06:10:05 <adept> twb: you should have 'module Text.Restr....Test' in your file
06:10:19 <twb> adept: I worked it out, thanks.
06:10:31 <ibid> sources are at http://antti-juhani.kaijanaho.info/darcs/unbounded/
06:10:35 <ibid> twb: i don't think so
06:10:51 <twb> ibid: Are those arrows UTF-8 characters?
06:10:54 <skew> twb: not trivially - from the screenshot it looks like the object is still to capture a row
06:11:21 <ibid> twb: yes
06:11:39 <ibid> twb: and the one in the lower-right corner is wrong, i know. font bug.
06:11:42 <twb> ibid: An impressive feature would be if it hilighted all the possible enemy wins you need to block :-)
06:11:48 <ibid> heh
06:12:13 <ibid> well, that should not be that hard, but i don't find it a very useful feature :9
06:12:16 <ibid> (it's a cheat)
06:12:17 <twb> ibid: I thought current-gen haskell interpreters had trouble with UTF-8?
06:12:30 <ibid> twb: i'm not doing UTF-8 :)
06:12:43 <twb> Ah, you did that in the FFs?
06:12:52 * ibid frantically records all changes not yet recorded
06:13:03 <ibid> twb: no, i used \x-escapes
06:13:08 <twb> Ew.
06:13:15 <twb> Better than nothing, I suppose.
06:14:57 <twb> ibid: in fact, the two right arrows look wrong, too.
06:15:11 <twb> 'â' 0008598 002196 NORTH WEST ARROW, So, 0, ON, N, UPPER LEFT ARROW,
06:15:12 <twb> 'â' 0008599 002197 NORTH EAST ARROW, So, 0, ON, N, UPPER RIGHT ARROW,
06:15:12 <twb> 'â' 0008600 002198 SOUTH EAST ARROW, So, 0, ON, N, LOWER RIGHT ARROW,
06:15:12 <twb> 'â' 0008601 002199 SOUTH WEST ARROW, So, 0, ON, N, LOWER LEFT ARROW,
06:15:21 <ski> ibid : is that 'five in a row' ?
06:15:38 <ibid> ski: on unbounded board
06:15:50 <ibid> twb: they should be correct
06:16:13 <twb> Really?  The height and glyph looks different to the NW glyph.
06:16:43 <twb> ibid: btw, it looks like you cropped the image by hand.  If you use import(1), you can take a snapshot of just one window.
06:18:14 <ibid> public darcs now has the version used to generate the screenshot
06:18:19 <ibid> twb: i used import
06:18:37 <ibid> twb: but i don't know how to include the decorations when not importing the root window
06:19:01 <adept> @seen SamB
06:19:01 <adept> @seen jlouis
06:19:02 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. I don't know
06:19:02 <lambdabot> when SamB last spoke.
06:19:02 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
06:19:02 <lambdabot> spoke.
06:19:24 <twb> ibid: click on the decoration.
06:19:40 <ibid> twb: i tried
06:19:40 <twb> The decorations are provided by drawin a window (wit decorations), then drawing the real window slightly smaller inside.
06:19:46 <twb> Oh well.
06:19:49 <ibid> twb: did not work
06:20:02 <ibid> anyway
06:20:52 <ibid> the AI opponent is not the best possible  but it does do its job well enough to challenge me
06:23:46 <araujo> Ok, gonna try something here...
06:24:03 <tromp_> the AI of what game?
06:24:40 <ibid> tromp_: my game, see above
06:29:54 <kzm> Anybody with experience with the TMR wiki?
06:30:07 <kzm> I'm not allowed to edit anything.
06:30:41 <ski> you need to be made an editor
06:31:21 <Philippa_> and so you need to be logged in
06:33:18 <kzm> Hmm...okay.  In other words, it will have to wait until after xmas.
06:33:33 <kzm> Well - merry Christmas everybody!
06:33:38 <Philippa_> I can give you editor rights now if you want
06:36:24 <xerox> hi!
06:40:22 <chucky> I need some help with Cabal, anyone up for it? :)
06:41:06 <Pupeno> Is it possible to make a type a superset of another (that is, have all the same constructors and a couple more) ?
06:41:12 <CosmicRay> chucky: we can give it a try
06:41:15 <Pupeno> chucky: just ask I'd say.
06:41:22 <CosmicRay> chucky: it seems like I've seen you in a different channel before...
06:41:34 <chucky> cosmicray: a different channel? :)
06:41:37 <chucky> #haskell.se?
06:41:42 <CosmicRay> nope
06:41:47 <CosmicRay> maybe there is another chucky lurking about
06:41:54 <chucky> perhaps
06:42:24 <ndm|bristol> Pupeno: data Superset = NewMember1 | NewMember2 | OldMember Subset
06:42:32 <ski> Pupeno : no subtyping in haskell (see OHaskell for a way that it might be done in)
06:42:38 <ndm|bristol> but not directly
06:42:41 * chucky is thinking on how to describe my problem
06:42:45 <Pupeno> ok.
06:43:09 <Pupeno> chucky: we have a pastebot for long things.
06:43:13 <Pupeno> lisppaste2: url
06:43:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:43:16 <chucky> I know
06:44:00 <chucky> I have a file, Lexer.x, that contains a function lexerMain :: IO (). I want to build an executable called rblex that uses lexerMain as it's main function. Can I do this in Cabal?
06:44:16 <chucky> Lexer.x is an Alex file btw
06:44:19 <CosmicRay> yes, but why the .x instead...
06:44:19 <CosmicRay> ah.
06:44:27 <CosmicRay> I'm not certain cabal supports alex, but I think it does.
06:44:32 <chucky> It does
06:44:42 <chucky> my problem is specifying the "Main-Is:"
06:44:48 <joelr1> folks, is there a way to do this?
06:44:49 <joelr1> instance Enum GameType where
06:44:49 <joelr1>     fromEnum :: GameType -> Word16
06:44:49 <joelr1>     fromEnum GT_1 = 0
06:44:49 <CosmicRay> all you need is an executable section, and a main-is line
06:45:23 <chucky> cosmicray: I've gotten that much, but I have trouble specifying a main-is line
06:45:37 <CosmicRay> what sort of trouble?
06:46:37 <chucky> if i specify it as Lexer.x it won't work since I need to specify that I want to use the "lexerMain" function rather than "main"
06:46:48 <chucky> and I don't know how to tell it to use lexerMain instead
06:46:48 <CosmicRay> ah.
06:46:55 <CosmicRay> the main function has to be named main
06:47:03 <CosmicRay> that is a Haskell thing, not a Cabal thing.
06:47:10 <CosmicRay> but you could always write a main.hs that says:
06:47:12 <CosmicRay> import lexerMain
06:47:16 <CosmicRay> main = lexerMain
06:47:21 <chucky> hmm yes I could
06:48:07 <chucky> but GHC supports writing for example: -main-is Lexer.lexerMain so my thinking was that I should be able to coerce Cabal into doing the same thing
06:48:58 <CosmicRay> chucky: afaik -- and I may be wrong on this -- that is a nonstandard extension
06:49:04 <CosmicRay> chucky: however, consider the ghc-options line.
06:49:24 <chucky> hmm yes
06:49:29 <lisppaste2> twb pasted "Int /= Integer -- what should I do?" at http://paste.lisp.org/display/14901
06:49:58 <musasabi> twb: fromIntegral
06:50:53 <chucky> hmm I'll think I'll go with the separate Main.hs file instead. Seems like a more correct way to do it anyway
06:51:08 <CosmicRay> chucky: I'd agree
06:51:30 <chucky> if Cabal doesn't support it I'll most likely run into the same linking problems I have right now with my makefile
06:51:59 <chucky> well that sentence probably made no sense to anyone else but me. :)
06:56:10 <araujo> Hello!
06:56:37 <chucky> hello araujo
06:56:48 <araujo> hey, what's up chucky ?
06:57:10 <chucky> not much, just doing a bit of Cabalizing
06:57:18 <araujo> Cool.
06:57:26 <chucky> (if Cabalizing is a proper verb) :)
06:57:41 <soysauce> @pl \(x,y) -> (y,x)
06:57:42 <lambdabot> uncurry (flip (,))
06:57:49 <soysauce> @pl map (uncurry (flip (,)))
06:57:50 <lambdabot> map (uncurry (flip (,)))
06:57:53 <soysauce> ...
06:58:32 <chucky> hmm what package do I need to get Control.Monad.State?
06:58:46 <xerox> (snd *** fst) -- too :)
06:59:23 <soysauce> that won't work
06:59:31 <soysauce> @type (snd Control.Arrow.*** fst)
06:59:33 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (b, a1)
07:00:27 <ski> @type (snd Control.Arrow.&&& fst)
07:00:28 <lambdabot> forall a b. (a, b) -> (b, a)
07:01:05 <ski> or even, just define 'swap (x,y) = (y,x)' :)
07:01:37 <xerox> uh sorry, &&& not ***.
07:03:55 <ADEpt> @seen SamB
07:03:56 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. I don't know
07:03:56 <lambdabot> when SamB last spoke.
07:04:00 <ADEpt> @seen jlouis
07:04:01 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
07:04:01 <lambdabot> spoke.
07:04:42 <soysauce> @pl \(_, i) -> (i .&. initmsk) /= 0
07:04:43 <lambdabot> (0 /=) . (.&. initmsk) . snd
07:07:10 <SamB> ADEpt: hello
07:07:33 <SamB> I see jlouis has done nothing
07:08:04 <ADEpt> SamB: me too :)
07:08:14 <ADEpt> SamB: conjure: <socket: 7>: hGetChar: end of file
07:08:24 <ADEpt> SamB: trying to figure out, why :)
07:09:16 <SamB> oh
07:09:27 <SamB> one of two things:
07:10:10 <SamB> either it was that handshake from the tracker, or you connected to a seeder who promptly disconnected on finding you had the entire file
07:10:27 <ADEpt> SamB: thats the second one, yes
07:11:08 <SamB> follow the "pieces"
07:12:13 <SamB> really, we need to flesh out MasterThread
07:12:46 <SamB> and I think the PeerThreads need a message something like
07:13:02 <SamB> TGot
07:13:04 <SamB> er.
07:13:29 <SamB> TGotPiece PieceNum
07:14:19 <SamB> and we need to have FSThread somehow inform the coordinator of the pieces we have already
07:14:33 <SamB> and the pieces we get need to be sent to the FSThread
07:16:11 <SamB> how do you suppose we should have FSThread communicate with the coordinator?
07:18:23 <ADEpt> SamB: i've seen it this way: PT communicates with Coordinator (NPP or IST) in terms of blocks (small) only. PT communicates with FS by submitting received blocks and requesting requested blocks. Coordinator keeps track of blocks and pieces, and detects when a new piece is available. FS informs coordinator of completed blocks and pieces (that passed checksum check).
07:19:35 <SamB> well, mostly I was thinking in terms of, how would we get that connection between FS and Coordinator going in the first place.
07:19:54 <SamB> also, the PTs all need to know whenever we get a completed block too
07:20:02 <SamB> er, piece
07:20:44 <SamB> also, I can't help but think it would be nice to store blocks in the WorkTable ;-)
07:20:47 <ADEpt> SamB: Coordinator could submit a message to the master, which will propagate it to all PTs via PT control channel
07:21:08 <SamB> ADEpt: yeah, that sounds workable.
07:21:09 <ADEpt> SamB: "store blocks" as in "store their bytes"?
07:21:33 <SamB> yes
07:21:56 <ADEpt> SamB: hm. why? why not let FS handle blocks?
07:22:09 <ADEpt> SamB: ah.
07:22:23 <SamB> well, the worktable already keeps track of which blocks are done...
07:22:25 <ADEpt> SamB: because FS does not have piece <-> block map, right?
07:22:53 <SamB> why not just replace
07:22:57 <SamB> data BlockStatus = Done | InProgress | Unstarted deriving (Eq,Show)
07:23:00 <SamB> with
07:23:06 <SamB> data BlockStatus = Done Block | InProgress | Unstarted deriving (Eq,Show)
07:23:22 <ADEpt> SamB: seems workable. Are you onto it? :)
07:23:33 <SamB> I'm not sure how much work it would be...
07:24:29 <SamB> jlouis seems to also have an idea about how to do this
07:25:00 <SamB> see the commenst after StorePiece in FS.FSThread
07:25:26 <ehuber> Hello
07:26:09 <SamB> the haddock comment is mine, the question I'm presuming to be jlouis's, and then I marked my answer
07:26:54 <ADEpt> SamB: yep. I see it. It seems kinda ugly to store Pieces, but request blocks.
07:27:02 <SamB> maybe!
07:27:20 <ADEpt> SamB: i have a wild idea once, that it is possible to serve in terms of blocks as well
07:27:40 <ADEpt> SamB: like, when we got first block of a piece, we start advertizing that piece as complete
07:27:53 <SamB> bad idea
07:27:57 <ADEpt> SamB: if we receive requests for a blocks from that piece that we already have ...
07:28:06 <ADEpt> SamB: but yes, it could be bad idea
07:28:08 <SamB> at least, I think so
07:28:47 <ADEpt> SamB: another thing not accounted for is that peers could (in theory) request blocks of the different size that we dealing with. Or is it accounted for?
07:28:48 <SamB> well, for one thing, we want to contain bad blocks...
07:29:46 <SamB> anyway, that kind of thing could get us a reputation for dishonesty
07:30:55 <sjanssen> SamB, ADEpt: just guessing from your conversation, are you hacking on a Bittorrent client?
07:31:04 <SamB> sjanssen: exactly ;-)
07:31:14 <sjanssen> is there a darcs repo?
07:31:19 <SamB> @where conjure
07:31:20 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
07:36:14 <SamB> hmm, this WorkTable isn't the way I thought it was...
07:36:25 <twb> Why is foo = 8 :: Integer when 8 :: Integral a => a
07:36:41 <twb> Er, Num a => a
07:37:02 <SamB> twb: monomorphism restriction?
07:37:09 <twb> Yuk.
07:37:10 <SamB> combined with numeric defaulting?
07:37:22 <twb> It's causing me grief.
07:37:24 <SamB> -fno-monomorphism-restriction
07:37:27 <twb> At least, I think it's that.
07:37:30 <SamB> or, give a signiture
07:37:57 <twb> SamB: ah, cool.
07:38:07 <twb> That fixes it up nicely.
07:38:28 <SamB> ADEpt: with the way you have this WorkTable, storing blocks in it would be bad...
07:38:44 <twb> Having to explicitly type toplevel names makes me feel dirty.
07:39:25 <soysauce> @pl \f (x, y) -> (f x, f y)
07:39:26 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
07:39:37 <soysauce> hm, there is a Control.Arrow function that does that, isn't there?
07:39:41 <SamB> twb: well, haddock also wants type signatures
07:40:01 <ADEpt> SamB: I updated the overview picture. Will you accept "darcs send"?
07:40:22 <SamB> I don't think I've gotten it to work yet...
07:40:37 <twb> SamB: that's of little comfort.
07:40:42 <ADEpt> SamB: you do not have working email?
07:40:56 <twb> It just emphasises the lack of reflection :-)
07:40:56 <SamB> twb: also! it makes it much easier to pin down type errors
07:40:58 <SamB> ADEpt: yes
07:41:02 <ski> @type \f -> f Control.Arrow.*** f
07:41:03 <lambdabot> forall (a :: * -> * -> *) b c.
07:41:03 <lambdabot> (Control.Arrow.Arrow a) =>
07:41:03 <lambdabot> a b c -> a (b, b) (c, c)
07:41:08 <SamB> but it seems to mangle darcs patches a bit...
07:41:23 <twb> How so?
07:41:33 <ADEpt> SamB: I think it is better to have separate block storage in the NPP, and use WorkTable only as a map of what block are available
07:41:34 <soysauce> @type (Control.Arrow.***)
07:41:36 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
07:41:36 <lambdabot> (Control.Arrow.Arrow a) =>
07:41:36 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
07:42:05 <SamB> twb: well, sometimes the error message is attached to a location far from where the types begin to divirge from your expectations
07:42:34 <twb> SamB: true.
07:42:58 <twb> (I was actually asking about the patches post)
07:43:07 <SamB> oh
07:43:08 <twb> (I realize now that it wasn't for me.)
07:43:14 <SamB> hehe
07:43:48 <ADEpt> SamB: where whould i send to?
07:44:03 <SamB> ADEpt: the address in AUTHORS
07:44:25 <ADEpt> SamB: off it goes
07:44:45 * ADEpt is away for 30-45 minutes
07:45:01 <ADEpt> SamB: any comments to picture are appreciated
07:47:01 <chucky> hmm is there any way in Cabal to specify options to Alex and Happy?
07:48:34 <SamB> hmm.
07:49:58 <soysauce> how do function types map onto arrows?
07:50:21 <SamB> instance Arrow (->)
07:50:26 <ski> (->) a b
07:50:30 <soysauce> I know that, but I mean how does it work
07:50:35 <soysauce> I don't understand
07:50:49 <ski> @type ((\f -> f Control.Arrow.*** f) :: (a -> b) -> ((a,a) -> (b,b)))
07:50:51 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
07:50:59 <SamB> oh, do you mean
07:51:10 <SamB> @type Control.Arrow.pure
07:51:10 <araujo> chucky, i think there is soemthing....
07:51:11 <lambdabot> forall (a :: * -> * -> *) c b.
07:51:11 <lambdabot> (Control.Arrow.Arrow a) =>
07:51:11 <lambdabot> (b -> c) -> a b c
07:51:16 <araujo> chucky, check the docs.
07:51:46 <SamB> ADEpt: I'm not seeing the patch
07:51:52 <soysauce> well I'm in GHCi just messing around with things and trying to figure out how it works. Now, I had assumed that when I saw a b c for the arrow type, that was a synonym for (a -> b -> c) in the case of a function
07:51:53 <chucky> araujo: I am looking at them now, but I can't find anything
07:51:59 <soysauce> but id is a -> a, and it matches just fine
07:52:08 <soysauce> so obviously I'm missing something pretty central
07:52:55 <SamB> (->) replaces a when you work in the (->) Arrow
07:53:03 <ski> soysauce : no .. if you have an arrow type 'ar a b', then if 'ar' is '(->)', then 'ar a b' is '(->) a b', i.e. 'a -> b'
07:53:05 <soysauce> hm, ok
07:53:41 <soysauce> so matching a b c against (+) you get Num d => a = (->), b = d, c = (d -> d)?
07:54:07 <ski> yes
07:54:13 <soysauce> ok, I see
07:54:29 <soysauce> so all non-null argument functions can fit that pattern
07:55:12 <ski> (strictly speaking, every function has exactly one argument)
07:55:17 <SamB> heh
07:55:29 <SamB> thats abstractly speaking
07:55:33 <soysauce> yes, I know that
07:55:57 <soysauce> functions of 0 arguments or functions of 1 argument (which can return a function of 1 argument or 0 arguments)
07:55:58 <SamB> strictly speaking, most functions take tuples
07:56:18 * SamB makes lame ML joke
07:56:44 <soysauce> still, it's much easier to speak of them as N-argument functions
07:56:54 <ski> yes
07:57:13 <SamB> when n is small, sure
07:57:18 <ski> (think the term "0-arg function" isn't so common, though)
07:57:52 <SamB> we only call those functions when are implemented that way, roughly ;-)
07:58:54 <SamB> I mean, most of the non-function-typed things that would bring to mind the idea of "function" are actually just newtype-wrapped functions...
07:59:18 <SamB> I mean, take getContents for example.
07:59:31 <SamB> @type GHC.IOBase.IO
07:59:32 <lambdabot> forall a.
07:59:32 <lambdabot> (GHC.Prim.State# GHC.Prim.RealWorld
07:59:32 <lambdabot> -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
07:59:32 <lambdabot> -> IO a
07:59:55 <ski> sometimes one call thunks functions (to emphasise (e.g. to newbies) that the language is lazy)
08:00:32 <soysauce> well, there isn't any semantic difference between these (in C):
08:00:39 <soysauce> int zero() { return 0; }
08:00:42 <soysauce> int zero = 0;
08:01:05 <ski> (the second can be assigned to)
08:01:07 <SamB> inside, its really just a function that takes the world and returns a new world and a String...
08:01:19 <soysauce> syntactically they are quite different, but semantically identical, so the distinction between data and functions is meaningless unless you give the programmer absolute control (as in C) over the final code
08:01:35 <soysauce> ski - ok, true, but if C were pure then there would be no difference
08:01:58 <SamB> well.
08:02:00 <SamB> Actually.
08:02:06 <soysauce> in the context of Haskell I don't think the distinction is made
08:02:12 <soysauce> ...because it's pointless
08:02:14 <ski> int bottom() { while(0); }
08:02:19 <SamB> @type (\() -> 0)
08:02:20 <lambdabot> forall t. (Num t) => () -> t
08:02:21 <SamB> @type 0
08:02:23 <lambdabot> forall t. (Num t) => t
08:02:31 <ski> er
08:02:36 <ski> int bottom(void) { while(1); }
08:02:41 <soysauce> SamB - \() -> 0 is a function of 1 argument
08:02:50 <soysauce> might not be a terribly useful one, but it still takes an argument
08:03:00 <twb> My screen is 180x76 chars.
08:03:12 <twb> Oops, wrong buffer ;-)
08:03:38 <SamB> stupid silly translation?
08:03:48 <soysauce> ??
08:04:01 <SamB> you don't like the translation with parentheses?
08:04:06 <SamB> like
08:04:23 <soysauce> well that works, but it's not "a function of 0 parameters"
08:04:30 <SamB> > let zero() = 0 in zero()
08:04:32 <lambdabot> 0
08:04:37 <SamB> > let zero = 0 in zero
08:04:38 <lambdabot> 0
08:04:44 <soysauce> oh, a translation from the C code?
08:04:48 <SamB> hehe
08:05:02 <soysauce> ah, I see...well that's syntactically the same but semantically different
08:05:14 <SamB> ADEpt: okay, now I see the patch
08:05:16 <soysauce> (disregarding the obvious point that one language is pure and the other is not)
08:05:43 <soysauce> zero = 0 would be how I would translate int zero() { return 0; }
08:05:50 <SamB> well...
08:06:11 <SamB> you can do the idiomatic translation or the silly similar-looking translation...
08:06:20 <xerox> oh
08:06:23 <soysauce> I know
08:06:32 <xerox> > let zero = return 0 :: IO Int in zero
08:06:33 <lambdabot> No IO allowed
08:06:38 <xerox> That's the translation ;-)
08:06:42 <SamB> (which might very well be the translation of choice in ML, a lot of the time)
08:06:43 <soysauce> hah
08:07:02 <soysauce> curious...well, it's been a long time since I've written any ML
08:07:13 <soysauce> and I never wrote very much
08:07:14 <SamB> I haven't written any ML
08:07:38 <sieni> ML <3
08:07:40 <SamB> in fact, I don't have a clue what they do for nullary C functions
08:07:58 <SamB> probably depends on what they do
08:08:32 <soysauce> I probably ought to take the time to familiarize myself with OCAML
08:08:36 <soysauce> since I've heard that it's quite fast
08:08:56 <sieni> mlton is supposed to be even faster
08:09:09 <soysauce> oh, interesting
08:09:29 <soysauce> well, one thing at a time; I'm still dealing with Haskell for now, I think
08:09:38 <sieni> although it doesn't support interactive toplevel or separate compilation
08:09:48 <soysauce> what?
08:09:55 <soysauce> "separate compilation" meaning?
08:10:37 <sieni> soysauce: well, if you have a c-file, you can compile it to a .o-file and then later link bunch of .o files together
08:11:00 <SamB> ADEpt: ooh, cool, apparantly they fixed gmail to not mangle darcs patches. or something like that.
08:11:12 <soysauce> yes
08:11:21 <soysauce> I was hoping that you meant something else
08:11:53 <soysauce> I remember a pretty solid argument from one of the "founding fathers of programming" with regard to separate compilation -- Hoare or Dijkstra, probably, but I forget who exactly
08:12:26 <soysauce> the argument basically stating that separate compilation was a fundamental necessity as a tool to assist the programmer
08:12:57 <soysauce> (the actual argument was lambasting certain compiler designers for requiring small files and separate compilation because of performance)
08:13:42 <sieni> soysauce: well, I don't think that's a big problem with mlton, but lack of separate or incremental compilation sort of excludes the possibility of changing the code of a running process
08:14:10 <soysauce> changing the code of a running process seems to me to be more trouble than it's usually worth
08:14:25 <sieni> but of course you can use smlnj to develop the code and compile the final binaries with mlton
08:14:30 <soysauce> *nods*
08:14:56 <soysauce> one thing I never quite grasped about ML--are all these variants different "dialects" of ML, or just different compilers for a common language?
08:15:11 <neologism> dialects
08:15:17 <soysauce> I used SML when I was tinkering with it for class
08:15:25 <soysauce> ok, that was my understanding
08:15:36 <musasabi> soysauce: how would you view the various Haskell implementations?
08:15:37 <sieni> well the most common dialects are sml and ocaml
08:15:49 <Trevion> soysauce, in the case of Ocaml and SML it's almost like they're divergent evolutions of a common starting ground.
08:16:00 <bringert> is there a way with ghc to dump a stack trace when you get a stack overflow?
08:16:09 <sieni> ocaml has only one implementation with a sucky license
08:16:11 <ski> SML and OCaml are separate langs
08:16:26 <sieni> like common lisp or scheme or something
08:16:29 <soysauce> musasabi - I only know the standard implementation, so...
08:16:44 <Trevion> soysauce, which standard implementation?
08:16:53 <soysauce> er, standard language, rather
08:16:56 <xerox> sieni: Scheme has many
08:16:59 <soysauce> and I'm using GHC
08:17:21 <sieni> xerox: sorry I was referring to the "separate langs"-comment by ski
08:17:34 <ski> (sieni : yes)
08:17:58 <ski> (they both belong to the ML family)
08:18:47 <sieni> then there are some funny extensions to sml, like alice
08:18:56 <ski> m
08:19:03 <sieni> alice actually looks pretty cool
08:19:14 <soysauce> what's Alice?
08:19:45 <sieni> http://www.ps.uni-sb.de/alice/
08:19:46 <musasabi> GHC is actually quite far from "standard" haskell
08:20:01 <ski> Alice take ideas from Oz, and extend SML with them
08:20:05 <Trevion> Not like Ocaml is from "standard" ML
08:20:06 <soysauce> musasabi - with -fglasgow-exts, yes, but without it's the same, isn't it?
08:20:46 <musasabi> soysauce: yes, but most complex programs use -fglasgow-exts + multiparamater classes + fundeps + ffi + ...
08:21:37 <Trevion> musasabi, I believe FFI is an accepted extension to Haskell 98.
08:21:43 <sproingie> hugs is probably what i'd call "standard"
08:21:57 <Trevion> hugs also supports mptc, etc., I believe.
08:21:57 <sproingie> while ghc is more the reference ... plus a bunch
08:22:11 <sproingie> maybe nhc then
08:22:24 <Trevion> How about the Haskell 98 standard is standard?  (-;
08:22:38 <tairox> hey room
08:22:44 <tairox> good business here
08:22:46 <sproingie> is helium still getting developed?  a hand-holding compiler always sounded like a good idea
08:23:09 <tairox> i need a good hacker here
08:23:10 <sproingie> but last i looked it seemed kind of crippled
08:23:23 <tairox> pls can u talk to me
08:23:28 <ndm|bristol> FFI and heirarchical modules were both standardised additions to haskell98
08:23:47 <soysauce> what is FFI?
08:23:52 <ndm|bristol> nhc98 and yhc are both pretty much just FFI+heirarchical
08:24:00 <ndm|bristol> soysauce: interfacing to C, foreign function interface
08:24:06 <tairox> i need an hacker here
08:24:09 <soysauce> ah
08:24:34 <tairox> pls can i get one
08:25:04 <tairox> i need an account transfer
08:25:15 <soysauce> from a bank account in Nigeria?
08:25:30 <tairox> no
08:25:40 <tairox> from a bank account in usa
08:25:48 <sproingie> go away
08:26:07 <soysauce> well, generally my policy is to never do anything that will get me thrown into jail...
08:26:24 <neologism> soysauce: some of those things are very nice :)
08:26:36 <neologism> (like dancing drunk and naked in the streets etc. :) )
08:26:40 <soysauce> haha
08:27:03 <soysauce> I'll take your word for it ;)
08:27:17 <sproingie> we'll H4X0R the bank ... in HASKELL!
08:27:21 <sieni> neologism: why would that get you thrown in jail?
08:27:27 <tairox> can u do a boa or welsfargo account transfer
08:27:29 <neologism> sieni: dont know.. havent tried
08:27:35 <ski> @elite we'll H4X0R the bank ... in HASKELL!
08:27:36 <lambdabot> We'l| |-|4x0R TH3 BaNK ... IN HA5K3LL!
08:27:36 <tairox> or make me get bank loggons
08:27:43 <soysauce> rofl
08:27:45 <tairox> we will be on percenatge
08:28:01 <musasabi> MPTCs are quite unstandardized and there is no spec for fundeps
08:28:07 <sieni> neologism: In finland the police would probably hand you a sock, so you can continue dancing with red hot chili peppers -style
08:28:13 <soysauce> tairox - want to learn Haskell?
08:28:18 <musasabi> and GHC and Hugs get them in different ways
08:28:20 <neologism> sieni: hehe
08:28:26 <sproingie> the fucking mugus are invading irc now
08:28:48 <tairox> sry baout that
08:28:55 <neologism> what is a mugu?
08:29:06 <soysauce> en bög
08:29:17 <sproingie> neologism: nigerian word for "sucker".  turns out con artists make good suckers too.
08:29:21 <sproingie> neologism: 419eater.com
08:29:32 <Trevion> @elite Haskell the Gibson
08:29:33 <lambdabot> HA5xe1| t|-|e GIb50N
08:30:19 <soysauce> it's supposed to be "teh"
08:30:28 <soysauce> don't you speak hax0r? :|
08:30:56 <lennart> tairox: the good hacker on here only listens when you put a > first on the line
08:31:07 <soysauce> haha
08:31:22 <neologism> > id "like this?"
08:31:24 <lambdabot> "like this?"
08:31:27 <sieni> isn't there any channel operators here?
08:31:39 <sieni> or similar with opping powers?
08:31:48 <soysauce> sieni - he seems to have ceased :p
08:31:55 * sproingie has bop-it powers
08:32:19 <musasabi> sieni: at least shapr has ops if they are required.
08:32:32 <sjanssen> > reverse "?siht ekil esrevnoc ew spahrep"
08:32:33 <lambdabot> "perhaps we converse like this?"
08:32:50 <soysauce> hej
08:33:49 <sjanssen> > map succ "sghr\USbntkc\USfds\US`mmnxhmf"
08:33:51 <lambdabot> "this could get annoying"
08:33:52 <musasabi> joelr1: Re: "Optimization help needed", you can certainly try if they make a difference when done in C. interleaving C and Haskell is quite painless.
08:34:41 <CosmicRay> I have a question about ForeignPtrs.  Is there a way I can tell the system, "OK, do NOT run the finalizer after all?"
08:34:57 <CosmicRay> My situation is that there is a close operation on the item that the foreignptr points to.
08:35:05 <joelr1> musasabi: i wish i knew in advance whether that would make a difference :(
08:35:10 <CosmicRay> this operation can possibly fail, so it is desirable for code to call it directly
08:35:20 <sproingie> why have a finalizer if it's not meant to always be called 
08:35:23 <CosmicRay> however then the finalizer from the foreignptr will do weird things as it tries to call it a second time
08:35:42 <CosmicRay> otoh, in many cases, explicitly closing is a waste and I'd like it to be closed when GC runs, discarding any error like usual
08:35:52 <twb> How do I say "\x -> x is not a member of [1,2,3]"?
08:35:56 <musasabi> joelr1: well writing that in C, should be <30min.
08:36:14 <sproingie> files should probably not wait for gc to close
08:36:15 <CosmicRay> sproingie: the function the finalizer points to is meant to always be called.
08:36:36 <sproingie> CosmicRay: you probably need to make the finalizer check for double-close
08:36:36 <CosmicRay> sproingie: but it's a useful property of handles, you know.
08:36:40 <joelr1> musasabi: but then i would want configure to define BIG_ENDIAN for me, etc. 
08:36:42 * joelr1 whines
08:36:49 <CosmicRay> sproingie: write a C wrapper, IOW?
08:37:18 <roconnor> twb, you can't.  \x->x is a function, and [1,2,3] is a list of numbers, so the statement (\x->x) is a member of [1,2,3] doesn't even make sense.
08:37:42 <tairox> fuck u all
08:37:45 <tairox> u cant scam
08:37:48 <tairox> poor u
08:37:52 <soysauce> rofl
08:38:04 <twb> sigh
08:38:19 <twb> roconnor: I never said it was Haskell, did I?
08:38:28 <tairox> lets talk about scamming
08:38:29 <CosmicRay> tairox: why would you expect anybody to help you rip off innocent people?
08:38:36 <tairox> lets get logons
08:38:39 <twb> If it was already haskell, it'd be easy to translate into haskell.
08:38:43 <soysauce> just ignore him, he's an obvious troll :p
08:38:52 <tairox> lol fuck u
08:38:52 <sproingie> not to feed the trolls thanks
08:38:57 <tairox> yoruba man
08:38:59 <CosmicRay> soysauce: I'm trying to decide if he's a troll or an idiot.
08:39:00 <tairox> mugu
08:39:08 <tairox> maga
08:39:10 <sproingie> hey look he can learn new words
08:39:12 <CosmicRay> soysauce: though I admit the line is fine.
08:39:12 <tairox> lol
08:39:17 <sproingie> sort of.  babbles them really
08:39:18 <ndm|bristol> CosmicRay: its possible to be both :)
08:39:27 <tairox> i'm from nigeria
08:39:33 <sproingie> no kidding.  bye now.
08:39:35 <soysauce> he'll give up eventually if he's ignored
08:39:38 <tairox> i understand u pretty well
08:39:39 <sproingie> no one has ops
08:39:45 <tairox> lol
08:39:47 <tairox> ode nie
08:39:59 <CosmicRay> funny that someone from nigeria is logged on from illinois.
08:40:04 <twb> @hoohle a -> [a] -> Bool
08:40:05 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
08:40:05 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
08:40:05 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
08:40:14 <soysauce> haha
08:40:23 <roconnor> twb, soooooooorry.
08:40:37 <CosmicRay> err, make that israel.
08:40:42 <CosmicRay> two meanings for IL
08:40:53 <soysauce> indeed ;)
08:41:02 <CosmicRay> anyway, /me goes to code an annoying finalizer wrapper
08:41:13 <sproingie> nifty ... what's @hoohle stand for?
08:41:21 <soysauce> sproingie - @hoogle
08:41:28 <soysauce> but I guess it auto-corrected the typo
08:41:39 <sproingie> smart bot
08:41:55 * Oejet wonders if 175 people messaged him privately would make him go away quickly.
08:41:56 <soysauce> smarter than you realize
08:42:03 <soysauce> Oejet - he logged
08:42:11 <soysauce> @djinn a -> b -> (a, b)
08:42:12 <lambdabot> f a b = (a, b)
08:42:23 <soysauce> @djinn a -> b -> Maybe (a, b)
08:42:24 <lambdabot> f a b = Just (a, b)
08:42:34 <soysauce> @djinn Maybe a -> a
08:42:35 <lambdabot> -- f cannot be realized.
08:42:51 <droundy> @djinn a -> Maybe b
08:42:51 <lambdabot> f _ = Nothing
08:42:52 <Oejet> soysauce: Which means?
08:42:56 <sproingie> i dont quite get what djinn is doing
08:43:00 <soysauce> Oejet - [11:40:18] * Quits: tairox (n=taidude@81.199.62.131.rmts.satcom-systems.net)
08:43:08 <ski> @type \x -> x `notElem` [1,2,3]
08:43:09 <lambdabot> forall a. (Num a) => a -> Bool
08:43:10 <soysauce> sproingie - automatically constructing a function from its type
08:43:16 <ski> @type (`notElem` [1,2,3])
08:43:17 <lambdabot> forall a. (Num a) => a -> Bool
08:43:23 <sproingie> soysauce: satcom systems ... he probably was from a nigerian net cafe
08:43:46 <ski> twb : that ?
08:43:47 <Oejet> soysauce: Yes, I know he logged off, but just wondering what to do next time. :)
08:43:56 <soysauce> Oejet - ah, ok
08:43:57 <sproingie> soysauce: that could be a useful addition to an ide
08:44:13 <soysauce> sproingie - @pl is more useful in general
08:44:22 <soysauce> @pl \(x, y) -> (y, x)
08:44:23 <sproingie> soysauce: what's @pl?
08:44:24 <lambdabot> uncurry (flip (,))
08:44:29 <soysauce> @help pl
08:44:30 <lambdabot>  @pointless <expr> - play with pointfree code
08:44:34 <ski> @pl \x y -> x
08:44:35 <lambdabot> const
08:44:36 <ski> @pl \x y -> y
08:44:37 <lambdabot> const id
08:45:07 <soysauce> @pl f x y = (x, y)
08:45:08 <lambdabot> f = (,)
08:45:16 <sproingie> i still have trouble figuring out how to write programs with lots of side effects in haskell
08:45:22 <musasabi> @djinn a -> b -> (a,b)
08:45:23 <lambdabot> f a b = (a, b)
08:45:27 <musasabi> @. pl djinn a -> b -> (a,b)
08:45:28 <lambdabot> f = (,)
08:45:48 <sproingie> especially when there's more than one logical environment to think of, like a db and other application state
08:46:06 <sproingie> stuffing everything into the IO monad smacks of abuse of globals
08:46:53 <sproingie> guess i should look at more real world code
08:47:10 <soysauce> sproingie - BTW, tairox traces to a .il domain (as was stated earlier) -- Israel cybercafe, maybe :P
08:47:33 <xerox> @djinn Either a b -> Either (a,a) (b,b)
08:47:34 <lambdabot> f a =
08:47:34 <lambdabot>   case a of
08:47:34 <lambdabot>   Left b -> Left (b, b)
08:47:34 <lambdabot>   Right c -> Right (c, c)
08:47:59 <soysauce> @djinn Either a b -> Either (Maybe a) b
08:48:01 <lambdabot> f a =
08:48:01 <lambdabot>   case a of
08:48:01 <lambdabot>   Left b -> Left (Just b)
08:48:01 <lambdabot>   Right c -> Right c
08:48:04 <soysauce> :D
08:48:25 <xerox> @djinn Maybe a -> Maybe b -> Either a b
08:48:25 <lambdabot> -- f cannot be realized.
08:48:27 <xerox> heh
08:48:38 <soysauce> too bad it doesn't accept lists
08:48:42 <ski> @djinn Maybe a -> Maybe b -> Maybe (Either a b)
08:48:43 <lambdabot> f a b =
08:48:43 <lambdabot>   case a of
08:48:43 <lambdabot>   Nothing -> Nothing
08:48:43 <lambdabot>   Just c -> case b of
08:48:43 <lambdabot>      Nothing -> Just (Left c)
08:48:45 <lambdabot>      Just d -> Just (Right d)
08:49:05 <xerox> ahah
08:49:07 <xerox> right.
08:49:12 <soysauce> that's pretty neat
08:49:24 <musasabi> @djinn Either a b -> Maybe a
08:49:25 <lambdabot> f a =
08:49:25 <lambdabot>   case a of
08:49:25 <lambdabot>   Left b -> Just b
08:49:25 <lambdabot>   Right _ -> Nothing
08:49:44 <xerox> @djinn Either (Maybe a) a -> Either a (a,a)
08:49:45 <lambdabot> -- f cannot be realized.
08:49:47 <ski> (though, it'd be nice if it gave Nothing just when both args where absent)
08:49:48 <xerox> heh
08:50:01 <xerox> ski: sure
08:50:03 <droundy> It couldn't be too hard to combine djinn with a type checker to finish one's functions, could it?
08:50:07 <soysauce> I was thinking that, heh
08:51:50 <sjanssen> where can I find an unsigned Int type?
08:51:55 <soysauce> Data.Word
08:52:11 <soysauce> Word is the unsigned parallel of Int
09:02:05 <soysauce> @help
09:02:06 <lambdabot>  @help <command> - ask for help for <command>
09:02:18 <soysauce> @listcommands
09:02:19 <lambdabot> use listcommands [module|command]. Modules are:
09:02:19 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
09:02:19 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
09:02:19 <lambdabot> seen spell state system todo topic type version vixen where
09:02:46 <soysauce> @vixen
09:02:47 <lambdabot> do you have toys?
09:02:58 <soysauce> @help vixen
09:02:59 <lambdabot> sergeant curry's lonely hearts club
09:03:08 <Philippa> @vixen wanna see my collection of pervertibles?
09:03:09 <lambdabot> why don't you guess?
09:03:17 <Philippa> @vixen sure thing *thwack*
09:03:19 <lambdabot> that's what i figured
09:03:21 <Philippa> etc etc
09:03:30 <Philippa> @vixen you're the local hot bi babe, right?
09:03:31 <lambdabot> thanks! i do my best
09:03:41 <Philippa> it could be better :-)
09:03:45 <soysauce> @fact
09:03:46 <lambdabot> I can not handle empty facts.
09:04:38 <neologism> lambdabot is not budhist ;)
09:04:49 <soysauce> haha
09:06:04 <soysauce> nor a Daoist
09:06:14 <takuan> can one use an if then else in a lambda abstraction?
09:06:29 <palomer> whoa, there are only three instances of Monad in the Prelude
09:06:32 <Philippa> if-then-else is just an expression like any other
09:06:35 <Philippa> (so yes)
09:06:39 <takuan> mm
09:06:44 <takuan> I must be doing something wrong
09:06:47 <Philippa> palomer: *only*? It's the Prelude!
09:07:02 <Philippa> I mean, it's two more than many would expect...
09:07:02 <palomer> but, like, every datatype should implement Monad
09:07:27 <Philippa> yeah, the CustomerAddress Monad is awesome!
09:07:48 <lennart> but the prelude doesn't have more than about 3 type constructors
09:07:49 <sjanssen> which monads are in the Prelude? IO, List, Maybe?
09:08:30 <Philippa> sounds about right
09:08:41 <lennart> hmmm, I wonder if Ratio is a monad
09:08:41 <Philippa> I'm pretty sure List is
09:08:47 <soysauce> wouldn't Either also be in Prelude?
09:09:01 <Philippa> ooh, you could probably turn Ratio into an error-accumulating one of some sort?
09:09:09 <Philippa> or if not Ratio itself then certainly something like it
09:09:27 <tromp_> i guess you could make () a Monad;)
09:09:35 <lennart> no
09:09:54 <sjanssen> () has the wrong kind
09:09:56 <ski> @kind ()
09:09:57 <lambdabot> *
09:10:04 <tromp_> oh wait it's the wrong kind:(
09:10:10 * ski smiles
09:10:31 <palomer> Num should implement Monad!
09:10:40 <ski> Stream is a monad ..
09:10:44 <lennart> it's a type class
09:10:46 <palomer> oh wait, it's the wrong kind
09:10:52 <soysauce> what kind need something have? * -> *?
09:10:59 <ski> yes
09:11:14 <ski> @kind Maybe
09:11:15 <lambdabot> * -> *
09:11:16 <ski> @kind IO
09:11:17 <lambdabot> * -> *
09:11:21 <ski> @kind Either String
09:11:22 <lambdabot> * -> *
09:11:30 <Philippa> ski: you wanted me to show you some random silly musings of mine?
09:11:31 <ski> @kind (->) Int
09:11:32 <lambdabot> ? -> *
09:11:43 <ski> Philippa : er, right ..
09:11:53 <soysauce> wait, what is ?
09:12:03 <ski> Philippa : also wondered about something you said about toplevel tyvars ..
09:12:07 <Philippa> well, not entirely random. Mixed strict/lazy language with copious monad abuse, stuff like that
09:12:23 <ski> '?' is a superkind of '*' (only needed for unboxed stuff)
09:12:36 <soysauce> ah
09:12:40 <soysauce> @kind (+)
09:12:41 <lambdabot> Not in scope: type variable `+'
09:12:44 <Philippa> yeah. The purpose of the toplevel tyvars was to be combined with a sort of pseudo-union type thing so you could deliberately unify them with fragments of types elsewhere...
09:12:50 <soysauce> hm...
09:13:03 <Philippa> so you could let it infer a type for you, bind it to a tyvar and use that elsewhere
09:13:10 <Philippa> "type of this thing whose type I want you to infer"
09:13:45 <ski> Philippa : don't type synonyms give "toplevel tyvars" ?
09:13:51 <Philippa> no
09:13:53 <ski> or did you mean in another way
09:13:56 <Philippa> you can't unify with a type synonym
09:14:00 <Philippa> only with what it expands to
09:14:07 <ski> do you mean free or bound toplevel tyvars ?
09:14:22 <Philippa> I mean tyvars bound at top level
09:14:30 <Philippa> to be unified with at will
09:14:43 <Philippa> so the declaration doesn't necessarily bind something to the tyvar, just the tyvar to its name
09:15:33 <Philippa> tyvar foo; f :: foo; f = ...; data FTransformer = FTrans (foo -> foo)
09:16:27 <palomer> http://www.rafb.net/paste/results/eFoofj24.html <--syntax question
09:16:29 <xs> must f be monomorphic?
09:16:29 <ski> like logic variables, then ?
09:17:26 <Philippa> xs: at the moment, yes
09:17:32 <Philippa> xs: given boxy types, no. SEP :-)
09:17:38 <xs> heh :)
09:17:43 * ski sometimes want tyvars that are arguments to the module
09:17:44 <Philippa> ski: like a type variable as already present in the type system :-)
09:18:02 <Philippa> they do behave rather like logic variables for some strange reason ;-)
09:18:14 <Philippa> that would be cool, yeah
09:18:29 <ski> 'strang' ?
09:18:29 <Philippa> records-as-modules, news at 11 ;-)
09:18:32 <ski> 'strange' ?
09:18:45 <Philippa> there's this isomorphism thing, y'see ;-)
09:18:55 <ski> hm ?
09:19:36 <palomer> so, erm, anyone has any ideas about my do syntax question?
09:19:56 <Philippa> ski: tyvars're isomorphic to logic variables, assuming I've understood things correctly
09:20:05 <Philippa> or to put it another way, they essentially *are* logic variables
09:20:15 <ski> yes
09:20:35 <xs> palomer: isn't it due to indentation of <|>?
09:21:34 <palomer> xs: I tried both identations proposed by emacs
09:21:36 <palomer> neither works
09:22:08 <xs> try, (do y <- identifier\nreturn (x:y)) <|> return [x]
09:22:42 <ski> Philippa : so your 'tyvar' declaration is more or less an existential quantifier, i guess
09:22:55 <lennart> since type classes are like (pure) Prolog, tyvars had better be like logical variables :)
09:23:13 <palomer> xs: nope
09:23:29 <Philippa> ski: something like that, I guess
09:23:44 <Philippa> the top-level scope was sorta the more important bit at the time of conception
09:25:12 <palomer> from my understanding, an expression of the form do {...} returns an m a, right?
09:26:02 <Philippa> yes
09:26:05 <xs> palomer: hm, it does for me. http://www.rafb.net/paste/results/zDUykN49.html
09:26:09 <Philippa> in the most general sense, anyway
09:26:26 <Philippa> and I *think* there's one exception
09:26:39 <Philippa> do {<expression>} is pretty much <expression>
09:27:15 <xs> but expr must be :: Monad m => m a?
09:27:54 <lennart> do x is desugared as x, but the type checker enforces that x is monadic
09:28:15 <ski> @type \x -> do {x}
09:28:17 <lambdabot> forall (t :: * -> *) t1. t t1 -> t t1
09:28:28 <ski> xs : so yes
09:28:29 <Philippa> 'k, I guess that's a good thing given the potential for obfuscation otherwise
09:29:20 <Igloo> Interesting, 6.4.1 has a Monad constraint but 6.5 doesn't
09:29:37 <Igloo> Anyone know if that was deliberate?
09:29:53 <Philippa> I can see how it might've been
09:30:32 <palomer> > @type <-
09:30:33 <lambdabot>  parse error on input `@'
09:30:37 <palomer> @type <-
09:30:39 <lambdabot> parse error on input `<-'
09:31:29 <palomer> xs: is there a reason that the do's are nested in my example?
09:32:48 <xs> palomer: each one produces Parser Char. you want alternatives using <|>, so you need m a each side of it.
09:33:26 <xs> it's the same as (identifier >>= return . (x:)) <|> return [x]
09:33:32 <xs> (the inner do)
09:35:14 <twb> Has anyone written Python-style indent/dedent parsers with Parsec?
09:36:00 <Philippa> I haven't directly, but it seems to me a two-layer approach is the most obvious?
09:36:26 <Philippa> tokenise it and do the indent/dedent stuff on that level, then feed the result into another round of parsers
09:36:26 <twb> Philippa: it needs state, AFAICT, which I am a little unsteady on.
09:36:37 <Philippa> it doesn't need state if you tokenise first
09:36:56 <Philippa> though yes, you could do it that way I guess
09:37:03 <Philippa> works the same as the state in a state monad
09:44:18 <palomer> what's the best resource to learn about typeclasses?
09:48:07 <araujo> dons, ping@
09:48:28 <palomer> showsPrec :: Int -> a -> ShowS
09:48:32 <palomer> how can I find the type of ShowS?
09:48:56 <palomer> nevermind
09:49:40 <araujo> type ShowS = String -> String
09:49:40 <Cale> type ShowS = String -> String
09:49:56 <palomer> yeah, was using :t instead of :info
09:51:27 <Cale> There's some stuff on typeclasses in YAHT
09:51:28 <palomer> is it possible to have haskell implement Show for you?
09:51:48 <Cale> yeah, add  "deriving (Show)" to the end of your data declaration
09:51:50 <ski> data Maybe a = Nothing | Just a deriving Show
09:51:56 <palomer> ahh
09:57:30 <palomer> @pretty \x -> do{y <- x; return x}
09:57:31 <lambdabot> "Parse error" at column 1
09:57:38 <palomer> @pretty \x -> do{y <- x; return y}
09:57:39 <lambdabot> "Parse error" at column 1
09:59:31 <xs> is it possible to serialise a function?
09:59:31 <xs> (at run time)
09:59:47 <ricebowl> palomer - um, that's the same as id...
09:59:51 <Cale> xs: no, but that would be nice
10:00:14 <Cale> xs: of course, highly platform dependent though
10:01:14 <xs> yes :(
10:02:13 <palomer> ricebowl: yeah, trying to get used to the syntax
10:02:27 <palomer> it's a restricted form of id
10:02:49 <palomer> hrmph
10:02:53 * palomer doesn't like parsec
10:03:00 <Cale> \x -> do{y <- x; return y} = \x -> x >>= \y -> return y = \x -> x
10:03:03 <Cale> palomer: why not?
10:03:04 * ricebowl finds >> and >>= much easier for some reason
10:03:16 <palomer> Cale: because I'm used to thinking in EBNF
10:03:32 <Speck> you can always use happy
10:03:32 <Cale> palomer: well, it's not that far off
10:03:48 <palomer> Cale: I'm writing a lambda calculus parser
10:03:58 <palomer> and I have to put trys everywhere
10:04:11 <Igloo> I tend to find happy less painful overall
10:04:49 <palomer> and simple things like identifier = [a-zA-Z]+[a-zA-Z0-9]* aren't so simple in parsec
10:05:00 <ski> (having to use 'try' is a bit evil ..)
10:05:15 <Igloo> I wouldn't hav though a LC parser would need backtracking
10:05:33 <Speck> I'm interested in intermediate languages for pure functional languages, and I've read the Grin paper and looked at JohnMeacham's source for E, but I hunger for more information on PTS... anyone have good links?
10:05:46 <Speck> *compilers for pure functional languages
10:06:13 <xs> palomer: identifier = do {xs <- many1 letter; ys <- many alphaNum; return (xs ++ ys)}?
10:07:21 * Igloo would prefer x <- letter; xs <- many alphaNum; return (x:xs)
10:07:36 <xs> ooh yes. oops.
10:07:52 <Igloo> Oh, yours has the advantage of being a direct translation, though
10:08:19 <Igloo> Does parsec really use letter and alphaNum for those?
10:08:32 <Philippa> I think so
10:08:44 <Cale> @type Text.ParserCombinators.Parsec.letter
10:08:46 <lambdabot> forall st. Text.ParserCombinators.Parsec.Char.CharParser st Char
10:08:51 <Cale> @type Text.ParserCombinators.Parsec.alphaNum
10:08:53 <lambdabot> forall st. Text.ParserCombinators.Parsec.Char.CharParser st Char
10:08:58 <Igloo> @type Text.ParserCombinators.Parsec.alpha
10:09:00 <lambdabot> Not in scope: `Text.ParserCombinators.Parsec.alpha'
10:09:07 <Igloo> Hmm
10:09:49 <xs> used less thinking.
10:09:51 <palomer> xs: yeah, that's twice the typing (and not so straight forward)
10:10:01 <palomer> seriously, I don't want to have to use recursion to define my regexps
10:10:37 <Cale> It's not really any harder though, and that's not directly recursive.
10:11:05 <palomer> Cale: if I'm going to build my tree while I'm parsing I have to make it recursive
10:11:26 <palomer> or create dummy productions
10:11:41 <Cale> oh, well, your parser as a whole will be
10:11:48 <palomer> still, writing twice the amount of code to achieve the same thing is a bother
10:12:09 <Philippa> EBNF does less than Parsec does
10:12:18 <Philippa> EBNF doesn't do the equivelent of the return bit
10:12:25 <xs> palomer: you can always tokenize and use mkRegex.
10:12:29 <Cale> Is the concrete syntax for LC usually regular?
10:12:32 <Philippa> also, EBNF doesn't do abstraction
10:12:39 <Philippa> depends if you want parens or not
10:13:03 <Speck> Parsec parsers can be composed, which is interesting.
10:13:09 <Cale> Yeah, I was kind of thinking that wouldn't be possible.
10:13:56 <palomer> Philippa: can you give me an example of something useful parseable in parsec but not with, say, YACC?
10:15:35 <palomer> @hoogle isAlpha
10:15:36 <lambdabot> Data.Char.isAlpha :: Char -> Bool
10:15:36 <lambdabot> GHC.Unicode.isAlpha :: Char -> Bool
10:15:36 <lambdabot> Data.Char.isAlphaNum :: Char -> Bool
10:15:41 <soysauce> Parsec is recursive descent, isn't it?
10:16:16 <SamB> Parsec's advantages are more in the areas of ease-of-use and quality-of-error-messages
10:17:02 <Philippa> palomer: not easily, IIRC you can abuse YACC to cover the turing complete range anyway
10:17:06 <Cale> soysauce: Parsec is LL(1) if you never use try. LL(k) or LL(infinity) if you do.
10:17:15 <Philippa> OTOH, Parsec covers the entire turing complete range in a reasonably obvious manner
10:17:24 <soysauce> ah, interesting
10:18:01 <lennart> it's strictly more powerful than e.g. YACC, since you can make context sensitive parsers
10:18:02 <palomer> Philippa: but you don't need that range!
10:19:42 <lennart> palomer: a part of the range can be very useful
10:19:55 <Cale> palomer: You can also make your parser configuration dependent. For example, I wrote a parser for a somewhat abstracted assembly language which was generalised over the processor architecture -- it turned a description of the opcodes available into a parser.
10:20:28 <palomer> Cale: so you used it as a parser generator generator
10:20:32 <Cale> yeah
10:20:35 <Philippa> lennart: no kidding. I've done some things with Parsec that go well into most people's idea of sick-and-twisted
10:20:37 <xs> palomer: really?
10:20:51 <palomer> xs: really what?
10:21:05 <chucky> philippa: Please give an example. :)
10:21:09 <palomer> I could see parsec being useful for a parser generator generator
10:21:11 <Cale> You could also write a parsec parser which reads EBNF and returns a parsec parser for that EBNF :)
10:21:14 <lennart> palomer: something you can do easily with parsec, but not yacc is to say parse something that starts with a number and the number indictes how many items follow
10:21:34 <Philippa> chucky: consider the things you can do by shoving the state full of a map from some kind of ID to a parser...
10:21:46 <Philippa> lennart: *good* call
10:22:07 <Philippa> I really want to be able to use Parsec more easily for binary data, it'd be great
10:22:07 <SamB> lennart: you mean like Banana?
10:22:13 <chucky> philippa: that does sound sick and twisted in a very interesting way. :) 
10:22:21 * tic ponders some gingerbread dough....
10:22:31 <JohnMeacham> Speck: did you read the paper on 'henk'?
10:22:35 <palomer> lennart: usually the list following the number has a production dedicated to it, and the size of the list can be checked after parsing
10:22:36 <SamB> Philippa: its not hard really...
10:22:46 <Philippa> SamB: it's just enough work that I've never done it
10:22:48 <SamB> as long as the data is serialized
10:23:02 <Philippa> well, kinda the point is to be able to spec the layout as a parsec parser
10:23:13 <JohnMeacham> Speck: http://research.microsoft.com/~simonpj/Papers/henk.ps.gz
10:23:14 <Philippa> (or better yet, as something from which you can build both parser and printer)
10:23:26 <Speck> JohnMeacham: no, I should, but I think I need to read up more on PTS from a categorical/type theoretical/or mathematical perspective, then read implementation papers so I don't cloud my understanding
10:23:42 <SamB> Philippa: I mean, as long as there is no jumping around by offsets or addresses or anything like that
10:23:56 <Speck> JohnMeacham: also, do you have anything describing E? how and where it differs from Grin?
10:24:06 <musasabi> What was the correct #ifdef for windows with GHC ?
10:24:11 <JohnMeacham> Speck: The henk paper is the best description of E actually.
10:24:22 <SamB> musasabi was doing something for structured binary I/O
10:24:30 <Philippa> SamB: that does help, yeah :-)
10:24:56 <Speck> oops, I think I was mistaking henk with grin
10:25:09 * musasabi jumps around offset addresses in DNS parsing code
10:25:23 <Speck> I guess what I should read about first is the lambda cube and the CoC
10:25:43 <lennart> palomer: but the items following the number might be numbers themselves (stupid idea, but i's just an example)
10:25:44 <droundy> Philippa: I'm very interested in a unified parsing/pretty printing framework.  It doesn't seem like it ought to be all that hard, and would be insanely useful...
10:26:16 <Philippa> droundy: reversible pattern-matching. 'nuff said.
10:26:57 <lennart> JohnMeacham: I have a small PTS implementation where you can specify the PTS you want (it has to be injective)
10:27:01 <SamB> droundy: yes, it would be insanely useful
10:27:21 <lennart> JohnMeacham: then it type checks and normalizes the expressions
10:27:23 <musasabi> #ifdef mingw32_HOST_OS ?
10:27:30 <SamB> but I'd hardly call binary output "pretty printing"
10:27:49 <ski> Philippa : 'reversible' ?
10:27:55 <JohnMeacham> lennart: cool. is it online somewhere? I sort of played fast and lose with the theory in E in order to get things working.
10:28:33 <SamB> you mean like "bicase ... of Foo x <-> Bar x; Baz y <-> Boo y"?
10:28:42 <Philippa> that kind of thing, yeah
10:29:09 <lennart> JohnMeacham: darcs.augustsson.net/Proj/PTS
10:29:33 <droundy> I don't follow teh reversible pattern-matching...
10:30:09 <JohnMeacham> lennart: that doesn't seem to work.
10:30:36 <lennart> oops
10:31:23 <palomer> lennart: I'd only be parsing things which are easily human readable, and that language seems to fit inside the language of CFGs
10:31:23 <lennart> http://darcs.augustsson.net/Proj/PTS should work
10:31:54 <Speck> lennart: I'm not getting anything over here
10:32:11 <lennart> palomer: mostly, I agree.  but sometimes it's useful with a little more
10:32:15 <sieni> http://www.bloomberg.com/apps/news?pid=10000085&sid=avOoTq8aXkU8&refer=europe
10:32:40 <JohnMeacham> lennart: I am getting a 'page not found' error.
10:32:45 <palomer> lennart: it can usually be fudged with a CFG parser+code whenever it does occur
10:33:18 <lennart> JohnMeacham: but I just tried it
10:33:24 <lennart> try www instead of darcs
10:34:01 <lennart> palomer: usually, yes
10:34:25 <JohnMeacham> no.. it is still not working... can someone else here try it?
10:34:28 <lennart> my PTS type checker needs improvement, though
10:34:36 <JohnMeacham> so does mine :)
10:35:50 <chucky> johnmeacham, lennart: I get a "page not found" error as well
10:35:50 <lennart> Arg!  darcs.augustsson.net/Darcs/PTS
10:35:56 <palomer> lennart: and in the odd cases when it doesn't, then you can turn to something drastic like parsec
10:36:26 <lennart> palomer: there's nothing drastic about parsec.  it's very natural :)
10:36:52 <JohnMeacham> lennart: okay, that worked :)
10:37:14 <lennart> JohnMeacham: The PTS type checker needs some more checks to ensure termination.  and some speedups when checking lets.  but otherwise it's good
10:37:51 <lennart> i have some examples of data types and type class translations, etc
10:38:21 <Cale> palomer: another nice little use of meta parsing was where I wrote a little app for determining certain variants on (musical) chord structures. I wanted the possibility to add more chord structures easily, so I wrote the parser to parse a file containing their names and numerical descriptions and create a parser which would read things like "C# minor augmented"
10:38:46 <SamB> palomer: Parsec is fun
10:38:50 <lennart> The Henk paper doesn't have a good type checking algorithm.  There's better ones now.
10:39:00 <SamB> the error messages are a joy to behold
10:39:22 <Cale> which my program then used to turn human descriptions of the chords into something it could process. Then the same description of the structures was used to pretty print the output.
10:39:24 <JohnMeacham> lennart: do you have a good reference? I could use a better algorithm.
10:39:48 <JohnMeacham> lennart: this looks really cool. I will dig into it some more.
10:41:35 <palomer> http://www.rafb.net/paste/results/am9x4g16.html <--how the hell does this parse
10:42:06 <palomer> and it parses as Var "a"
10:43:03 <SamB> palomer: do you use the eof parser anywhere?
10:43:05 <Cale> palomer: identifier = many1 letter
10:43:30 <Taral> @djinn (a, b) -> (a -> b -> c) -> c
10:43:31 <lambdabot> f (a, b) c = c a b
10:43:38 <Taral> O.o
10:43:41 <Cale> er
10:43:42 <Taral> that's new
10:43:55 <Cale> palomer: identifier = fmap Var (many1 letter) -- :)
10:44:11 <Taral> @djinn (Either a b) -> (a -> c) -> (b -> c) -> c
10:44:12 <lambdabot> f a b c =
10:44:12 <lambdabot>   case a of
10:44:12 <lambdabot>   Left d -> b d
10:44:12 <lambdabot>   Right e -> c e
10:44:28 <Taral> okay, maybe not
10:45:02 <Cale> palomer: or just: do { xs <- many1 letter; return (Var xs) }
10:45:14 <Cale> palomer: there's no need to do the recursion yourself
10:45:32 <palomer> Cale: yeah, just realized it
10:45:35 <SamB> palomer: anyway, if you want to make sure the whole file is parsed, you need to use the eof parser at the end
10:45:48 <palomer> SamB: I just want to parse "a b"
10:46:00 <palomer> and it's parsing as Var "a"
10:46:29 <Cale> palomer: right, since it doesn't know what to do with the space, so it figures that's the end
10:47:53 <Cale> if you add an eof parser at the end of the expression, it will then generate an error, since it's currently only set up to parse one identifier
10:47:56 <palomer> oh, usually parsers throw an error when they don't know what to do
10:48:16 <palomer> Cale: but then it wouldn't be able to parse strings in which I don't include an eof token
10:48:19 <Cale> yeah, it does too, it's just that it allows for not eating the entire input
10:48:37 <palomer> or is eof = [] ?
10:48:47 <Cale> palomer: the eof parser just represents the end of the input
10:49:26 <Cale> eof  = notFollowedBy anyToken <?> "end of input"
10:49:47 <Cale> (notFollowedBy p) only succeeds when parser p fails.
10:49:57 <palomer> gotcha
10:53:18 * ski thinks 'eof' parser is a bit evil
10:53:45 <palomer> try is a bit evil
10:54:23 <Philippa> eof is useful
10:54:44 <Philippa> try is... one of those design decisions you either love or hate
10:54:59 <palomer> is there a way around try?
10:55:21 <Philippa> don't parse that kind of grammar, essentially
10:55:29 <franka> Do or do not: there is no try.
10:55:30 <Cale> Well, designing your parsers such that any choice can be determined from looking at the first character.
10:56:06 <Cale> which you can usually do by factoring out common prefixes
10:56:06 <palomer> that's nuts!
10:56:18 <Cale> note that this only applies locally
10:57:33 <Cale> so rather than   string "(a)" <|> string "(b)", you'd do something like  do char '('; (char 'a' <|> char 'b'); char ')'
10:58:03 <Cale> where that end factoring isn't quite necessary, but I did it for sanity's sake :)
10:58:08 <Cale> Better yet:
10:58:11 <palomer> hrm, program = try expression <|> application
10:58:17 <Cale> yeah
10:58:59 <palomer> it doesn't do it:o
10:59:15 <palomer> it tries expression then fails
10:59:27 <xs> program = (try expression) <|> application
10:59:35 <Cale> ah
10:59:45 <xs> (iirc)
10:59:46 <Igloo> Those parens are redundant
10:59:48 <palomer> still no go
10:59:50 <Cale> well, no that should be the same
11:00:02 <xs> ahh hmm.
11:00:05 <Cale> are you parsing spaces anywhere?
11:00:05 <Igloo> So program foo fails, but application foo succeeds?
11:00:22 <palomer> Cale: yes
11:00:29 <palomer> Cale: program = application parses it correctly
11:00:54 <Igloo> Incidentally, I'd probably have applications, which looks for a list of atomic expressions
11:01:14 <Igloo> Either that or a nastier grammar which does expression (Maybe Expression) and puts them together
11:02:30 <{Arias}> what's the meaning of this error?
11:02:31 <{Arias}> Illegal instance declaration for `RDFModel RDFGraph'
11:02:31 <{Arias}> (The instance type must be of form (T a b c)
11:02:31 <{Arias}> where T is not a synonym, and a,b,c are distinct type variables)
11:02:50 <Cale> hmm, perhaps -fglasgow-exts is needed
11:03:09 <{Arias}> i have this:
11:03:19 <{Arias}> class RDFModel t where
11:03:19 <{Arias}> addStatement :: Statement -> t -> t
11:03:35 <palomer> Igloo: application succeeds
11:03:37 <{Arias}> instance RDFModel RDFGraph where
11:03:37 <{Arias}> addStatement = undefined
11:03:38 <Cale> what is RDFGraph?
11:03:39 <palomer> Igloo: but program fails
11:03:52 <{Arias}> this: type RDFGraph = G.Gr RDFNode URI
11:04:08 <{Arias}> Gr from Data.Graph.Inductive.Graph
11:04:09 <{Arias}> xD
11:04:22 <Cale> {Arias}: there's the problem
11:04:28 <Igloo> In H98 you can't give instances of type synonyms
11:04:39 <{Arias}> why ?
11:04:39 <Igloo> You can newtype it instead, or possible enable extensions
11:05:20 <Igloo> palomer: What's the failure output?
11:05:34 <{Arias}> newtype RDFGraph = G.Gr RDFNode URI ???
11:05:35 <SamB> {Arias}: who knows!
11:06:07 <SamB> (re: why?)\
11:08:46 <Cale> Because instances only applied to one type constructor at a time.
11:08:50 <lennart> JohnMeacham: You should look at Gilles Barthe's algorithm if you want something better for PTS.
11:09:16 <Cale> you can use type synonyms, they just have to expand to something legal to make an instance out of.
11:45:15 <lightstep> when do you want main of type not IO() ?
11:45:29 <basti_> yes when?
11:49:12 <musasabi> OI ?
11:49:33 <Philippa> OI u!
11:49:41 <Philippa> 'lo SyntaxNinja
11:49:45 <Cale> Comonads seem unsuited to IO.
11:50:08 <musasabi> Cale: they just require linearity I think
11:50:11 <basti_> but they're suited to stream processing
11:50:24 <Cale> musasabi: which comonads don't give
11:50:55 <basti_> think about it: you may be able to calculate a pure value from a stream (and thus lose the streamity)
11:50:58 <SyntaxNinja> hiya Philippa
11:51:14 <musasabi> Cale: well haskell just lacks it.
11:51:16 <basti_> and I'm sure theres a formulation of lists as comonads.
11:51:33 <musasabi> basti_: how would you represent the empty list?
11:51:47 <Cale> musasabi: well, the point being that monads can give you linearity and comonads can't.
11:51:54 <musasabi> true
11:51:54 <basti_> I don't see the problem musasabi?
11:52:00 <musasabi> basti_: try it.
11:52:06 <basti_> okay
11:52:16 <basti_> hmm
11:52:37 <musasabi> basti_: try starting with coeval :: w a -> a
11:52:38 <Cale> You can roughly abstract lists to MonadPlus
11:53:06 <Cale> supposing enough things are true of MonadPlus :)
11:53:12 <basti_> ah i see what you mean.
11:53:24 <musasabi> non-empty lists are comonads.
11:53:28 <musasabi> (streams)
11:53:32 * basti_ nods
11:54:23 <Cale> Well, both of those :)
11:54:32 * CosmicRay releases a new HDBC.
11:54:33 <CosmicRay> whee.
11:54:34 <CosmicRay> ;-)
11:54:45 <lightstep> um, i meant main :: IO String or such
11:54:57 <Cale> lightstep: ah, that's just for convenience
11:55:13 <Cale> so you don't have to put  return () at the end
11:56:05 <basti_> ah i see
11:57:25 <Cale> Lists embed into any MonadPlus which satisfies enough laws, but not into any monad.
11:57:46 <sieni> again: http://www.ssh.com/company/careers/engineer-windows-scheme.html
11:58:22 <Cale> sieni: is that an ad? :)
11:58:33 <sieni> Cale: sort of
11:58:47 <basti_> sieni: that sounds good.
11:59:03 <basti_> i bet that's interesting
12:09:46 <ski> Cale : monads don't give linearity
12:10:20 <Philippa> they do /support/ it though
12:10:29 <Cale> You can implement it in terms of them
12:10:34 <ski> you can hide linearity of state monad inside an abstract monad
12:10:43 <Philippa> but yes, if you need proof-of-linearity, being a monad isn't good enough
12:10:47 <Cale> right
12:11:16 <Cale> "can give you"
12:12:08 <ski> so, they don't give you linearity, they makes it possible to get away with not having a linear type system, in that particular case
12:12:34 <ski> (and, only if the monad is an ADT)
12:13:09 <Philippa> a specific monad can give you linearity of specific stuff, is one way of putting it. That stuff can't be the return value
12:13:28 <ski> m
12:14:14 <Cale> Well, ST basically gives you what linearity does, no?
12:14:32 <Philippa> eh?
12:14:34 <ski> well, in the form of manipulating the linear data through references, yes
12:14:39 <Cale> (or perhaps a monad based on ST)
12:14:50 <Philippa> depends what you want to do with linearity
12:15:10 <Philippa> if you want to couple it with GADTs to prove a file handle's used correctly then it won't help you :-)
12:15:24 <ski> sometimes using stuff through references is appropriate . .sometimes it's more useful to work directly on the data itself
12:15:59 <ski> (Cale : Mercury supports both variants, btw)
12:18:23 <ski> (the ST / references approach is more monolithic)
12:18:50 <Cale> Monolithic in what way?
12:19:16 <ski> you need to pass all of the state down to every part of program which needs to access it
12:19:25 <Philippa> you can't access the heap directly...
12:19:28 <ski> hence single-threading the use of the linear state
12:19:37 <Philippa> ...can't take it apart, stuff like that
12:19:42 <ski> and hence stuff like unsafeInterleaveST to get around this
12:19:50 <musasabi> Can linearity be implemented without the complication present in Clean?
12:19:59 <Philippa> (give or take sickness like the code Oleg supplied for my last Impure Thoughts article, which is kinda cheating
12:20:00 <Philippa> )
12:20:01 <ski> which complication ?
12:21:38 <ski> musasabi : hm ?
12:23:26 <musasabi> ski: higher order types + overloading + uniqueness make for complicated types.
12:24:32 <Philippa> I suspect half the answer is a better editor that can be told when to skip half the extras on a given type and when not to...
12:24:41 <Philippa> type folding, if you like
12:24:49 <ski> heh .. the better IDE argument
12:24:57 <Cale> ski: wouldn't you have to pass those variables anyway? The fact that you're now passing references doesn't change all that much
12:25:18 <Philippa> well yeah, but there's no arguing that a good IDE isn't useful for sufficiently large programs - why shouldn't the same be true of types?
12:25:24 <ski> Cale : passing references is fundamentally differnent from apssing around linear values
12:26:47 <Cale> hmm
12:27:03 <ski> when you pass references (or, e.g. already have them stored in a datastructure), then you also need the state to lookup them in
12:27:14 <ski> with ST, this means the *full* state
12:27:45 <ski> of course, a function can't affect parts of the state that it doesn't have references into
12:28:19 <Cale> Is this simply an efficiency problem?
12:28:53 <ski> with linear values, one can take one linear structure, pass down one part to one call, another part to another call, and then assembling together those parts again afterwards .. note the two subcalls are not sequenced wrt to each other
12:29:24 <ski> with ST, i have to sequence those two subcalls (or use an unsafe hack as unsafeInterleaveST)
12:29:46 <Cale> ah, okay
12:29:46 <dsacode> Hello! Assume i have some list 'primeDivisors', can i define 'divisors' as divisors n = 1 : primeDivisors ++ [x*y | (x,y) <- {x and y are from divisors and x*y < n}, can i write expression in curly brackets using haskell?
12:30:34 <basti_> dsacode: certainly. The question is, would you be happy with the order this implies? ;)
12:30:37 <ski> working directly on linear values has a more declarative feel, than working in an imperative manner, with assignment and rereference through references into a satte
12:30:49 <ski> s/re/de/
12:31:19 <dsacode> basti_: hehe, can you suggest good and effective way to get all divisors of some number if we have its prime divisors?
12:31:27 <Cale> I already see linear variables as being somewhat imperative anyway.
12:31:29 <basti_> > take 10 [(x,y) | x<-[2,4..] , y<-[3,6..] , x*y<n ]
12:31:30 <lambdabot>  Not in scope: `n'
12:31:34 <basti_> uhm
12:31:36 <ski> Cale : they are not
12:31:38 <basti_> > take 10 [(x,y) | x<-[2,4..] , y<-[3,6..] , x*y<20 ]
12:31:43 <lambdabot> Terminated
12:31:49 <dsacode> :(
12:31:50 * basti_ .o° ( ? )
12:31:52 <Dirty> can i haxor a computer using my pda?
12:32:02 <ski> (basti_ : diagonalization ?)
12:32:10 <Philippa> I doubt the comp'll care about your public displays of affection
12:32:15 <Philippa> so you can leave your boyfriend at home
12:32:18 <basti_> what did i do wrong with that?
12:32:41 <Dirty> person digital assistance
12:32:45 <Dirty> stupid school nerd
12:33:11 <basti_> @shapr
12:33:12 <lambdabot> Unknown command, try @listcommands.
12:33:43 <basti_> ah i see
12:33:56 <Cale> basti_: x = 2 for every value in that list
12:34:14 <basti_> Cale: yes i know, but i would have expected at least a few values
12:34:25 <ski> Cale : using linear values is just like ordinary declarative programming, just with additional restriction .. and this happens to allow (more like guarrantee) more efficient implementation
12:34:37 <basti_> (that x=2 in the naive implementation is what i wanted to demonstrate)
12:35:01 <ski> > take 3 [(x,y) | x<-[2,4..] , y<-[3,6..] , x*y<20 ]
12:35:03 <lambdabot> [(2,3),(2,6),(2,9)]
12:35:08 <ski> > take 4 [(x,y) | x<-[2,4..] , y<-[3,6..] , x*y<20 ]
12:35:13 <lambdabot> Terminated
12:35:22 <Cale> ski: well, you're restricted in how you use those values, which forces you to think about sequencing anyway
12:35:29 <basti_> ah so it doesnt output anything if it can't complete a line?
12:35:50 <basti_> at least a line
12:35:51 <ski> Cale : yes, some dataflow sequencing .. but no assignment or side-efefcts
12:36:24 <mauke> > take 4 [(x,y) | x<-[2,4..] , y<-[3,6.. 20 `div` x] , x*y<20 ]
12:36:26 <lambdabot> [(2,3),(2,6),(2,9),(4,3)]
12:36:32 <ski> > take 4 [(x,y,"012345678901234567890123456789") | x<-[2,4..] , y<-[3,6..] , x*y<20 ]
12:36:37 <lambdabot> Terminated
12:36:55 <mjl69_> @type take
12:36:57 <lambdabot> forall a. Int -> [a] -> [a]
12:37:03 <basti_> > take 5 [1..]
12:37:05 <lambdabot> [1,2,3,4,5]
12:37:08 <mjl69_> oh
12:38:17 <ski> Cale : but i think this sequencing is not any different from when you use a Map linearly in a prog, anyway .. only this time it's checked
12:39:16 <basti_> dsacode: so, basically, yes there is a way, but the order might be strange until you fix it
12:40:11 <Cale> The checking that it implies seems useful for certain things, but I'd usually not want to have to worry about dataflow sequencing so much. It would be nice if it was all embedded in some other structure which was then run to produce a value.
12:40:37 <Cale> Perhaps a nicer notation for handling commutative monads would be helpful.
12:41:33 <ski> Cale : could you rephrase the 'structure' part ?
12:41:52 <dsacode> divisors n = 1 : (primeDivisors n) : [x*y | x <- divisors, y <- divisors, x*y < n] Why doesn't this work?
12:42:11 <Trevion> dsacode, is primeDivisiors n a list?
12:42:17 <Trevion> divisors*
12:42:23 <dsacode> Trevion: yes
12:42:41 <Trevion> You can't use : to concatenate lists -- it has type a -> [a] -> [a]
12:42:54 <Cale> ski: Some sort of functor f with a map  f a -> a
12:42:55 <Trevion> You want 1 : primeDivisors n ++ [x * y | ..] I believe
12:43:38 <dsacode> Trevion: i made so, but it still doesn't work. The error is "Type error in generator"
12:44:10 <ski> 'divisors' is a function, you can't use it alone in the generators
12:44:12 <Trevion> dsacode, divisors is a function.  You should apply it to something.
12:44:26 <ski> (Cale : don't understand ..)
12:45:05 <dsacode> argh, sure
12:45:56 <Cale> ski: Well, perhaps I'm misunderstanding some point about linear types, but basically, I'm saying that there should be some explicit sublanguage which has them, with a projection back to ordinary types.
12:46:55 <Heffalump> why does it have to be a sublanguage, rather than just adding Linear x to the type system?
12:47:11 <Philippa> all it needs is a takeLinearCopy function, surely?
12:47:31 <Philippa> although Linear shouldn't really be a data constructor IMO
12:47:45 <Philippa> 'smore akin to a strictness annotation in my book
12:48:24 <lightstep> i also don't get it. if you want to separate the state to parts, you can use State and not ST
12:48:36 <Philippa> not necessarily
12:48:46 <Cale> Linear variables have restrictions on use which are not shared by any ordinary data type.
12:48:46 <Philippa> State requires you to statically know all the parts
12:49:08 <Philippa> it's linear values rather than linear variables
12:49:26 <Heffalump> yeah, it shouldn't look like a normal data constructor
12:49:31 <Cale> Or linear values rather
12:49:34 <musasabi> also you have to currently decide whether your array is mutable or not - no simply using an array with or without a uniqueness annotation.
12:49:38 <lightstep> but if you separate the state into parts, you have to know them statically
12:49:39 <Heffalump> but the point is that it's just a new kind of type
12:49:52 <Philippa> lightstep: no you don't
12:49:58 <Cale> Except that it's not just a new type :)
12:50:11 <lightstep> Philippa, i don't get it
12:50:17 <Heffalump> it's a new kind of type, obviously it needs type system support
12:50:21 <Philippa> for example, in a region discipline you can build a tower of unbounded size of regions...
12:50:22 <Cale> ah
12:50:31 <Heffalump> like a GADT
12:50:37 <Heffalump> or an existential type
12:50:51 <lightstep> readFile :: Path -> World -> (String, WorldWithoutThatFile) ?
12:52:16 <Philippa> lightstep: runSingleThreadedCode :: (WorldWithoutConcurrencyPrimitives -> WorldWithoutConcurrencyPrimitives) -> (World -> World)
12:53:47 <lightstep> that's like atomically
12:53:58 <Cale> However, those things don't force me to think about how I'm going to use some value 'x' of those types. If I have an X and something which takes an X, I can always make that application. With linear values, I have to be more careful with how I use the values that I have. That's different enough from ordinary programming that I'd like it to be obvious when it's happening.
12:54:03 <lightstep> oh, i understand
12:54:15 <Philippa> more obvious than when you're using a monad?
12:54:16 <Heffalump> yes, true
12:54:26 <Cale> Philippa: no, as obvious
12:54:41 <lightstep> you can combine many transformations into the final (world->world) function
12:54:45 <Cale> As in, obvious enough that types can be inferred from the code.
12:55:22 <Cale> Code which uses linear types should look different.
12:55:23 <Philippa> hrmm, fair enough, I guess there's no equivalent of >>= or do
12:55:54 <Philippa> you could start with "linear patterns" and things like that
12:56:14 <Philippa> and possibly insist on not shadowing variables of linear type with ones of non-linear type
12:57:02 <ski> Philippa : no need for such a specific rule
12:57:02 <lightstep> or use sigils
12:57:15 <Philippa> ski: no *need*, sure :-)
12:57:29 <ski> ok, it'd even be of hinder
12:57:39 * Philippa nods
12:57:43 <Philippa> I did say "possibly"
12:58:27 <ski> there are prefectly good uses in which one can shadow lin. vars
12:58:58 <dsacode> is it some effective way to append one element to the end of list?
12:59:07 <Philippa> yes, although I think the best ones involve shadowing with another linear one (say, the "future" value)
12:59:08 <Cale> dsacode: xs ++ [x] ?
12:59:16 <dsacode> Cale: is it most effective?
12:59:19 <Philippa> dsacode: not really, you still gotta walk the whole list
12:59:22 <Cale> dsacode: effective?
12:59:26 <dsacode> Argh :(
12:59:28 <ski> Philippa : yes
12:59:29 <Cale> > [1,2,3,4,5] ++ [6]
12:59:31 <lambdabot> [1,2,3,4,5,6]
12:59:35 <Cale> it works :)
12:59:39 <Philippa> you could have a slightly faster one-element append func, but it'd still be slow
12:59:44 <Cale> it's inefficient if you do it a lot
12:59:53 <Philippa> ski: I did say shadowing with a non-linear var would be the thing to ban :-)
13:00:04 <dsacode> I always think of "++" as very hard recursive function, and trying to avoid it
13:00:07 <ski> dsacode : depending on what you do, there are possibly other more efficient ways to do it
13:00:22 <dsacode> ski: i need to append one element to the end of list
13:00:25 <ski> Philippa : yes .. but i don't see a reason even for that
13:00:37 <Cale> dsacode: (++) isn't bad unless you use it to repeatedly add lots of small lists to the end of a list.
13:00:39 <Philippa> dsacode: if you can keep the list in reverse order that might speed things up a lot
13:00:44 <Philippa> prepending is much, much faster
13:00:56 <Cale> dsacode: Laziness makes it a lot more efficient than you'd normally expect.
13:00:58 <Philippa> Cale: at which point it can be stupefyingly slow. Early versions of Flippi suffer from it!
13:01:00 <ski> dsacode : are you sure you can't cons to front, and reverse one time at the end ? or how about using an accumulator ?
13:01:21 <Philippa> to the extent that loading pages full of drug spam didn't actually work because it timed out before it finished building the page to show you...
13:03:04 <ski> to a first appoximation, linear values and vars is just a restriction of the normal declarative programming .. (and it's usually not very difficult to see if a var is used once or not)
13:03:32 <Philippa> yeah, it's knowing if it's only allowed to be used once that's trickier
13:04:10 <ski> one knows whether called functions wants linear args, or not, etc ..
13:04:23 <Dirty> can i hack with a Pda _ Personal Digital Assistant?
13:04:48 <Philippa> Dirty: In what sense do you mean "hack"?
13:05:09 <ski> Dirty : you could possibly hack haskell on that, provided there's an implementation (not sure if anybody's done this)
13:05:23 <Cale> Dirty: I'm not sure if there are running Haskell implementations on PDA's yet.
13:05:37 <Cale> I seem to recall there was some talk about it a little while back
13:07:14 <Cale> iirc, someone ported nhc98 to PalmOS
13:07:44 <Cale> I'm not sure, but the yhc people might be interested in that too.
13:20:13 <palomer> back
13:20:25 <palomer> so did anyone, erm, find a solution to try foo <|> bar ?
13:20:45 <Heffalump> what's the problem?
13:21:11 <palomer> program = try expression <|> application
13:21:22 <palomer> fails to pars "a b"
13:21:29 <palomer> yet program = application succeeds
13:22:14 <dsacode> sorry for mathematical question, but may be it's exist some more elegant algorithm in Haskell to find all divisors of N then: divisors n = 1 : [x | x <- [2,3 .. (abs n)], n `mod` x == 0]
13:22:16 <Philippa> it eats a complete expression (a) and returns?
13:22:21 <lightstep> does expression include application?
13:22:28 <Philippa> (or rather, wonders why it's not at eof?)
13:23:09 <lightstep> dsacode, the number field sieve? i think that's the most advanced one as of now
13:23:21 <palomer> actually, it's programWithouteof = try expression <|> application
13:23:34 <dsacode> lightstep: is it some nice implementation on the Wiki or somewhere?
13:23:40 <palomer> and program = do x<- programWithouteof; eof;return x
13:24:09 <Cale> hmm
13:24:32 <Cale> how about  programWithoutEOF = try application <|> expression
13:25:06 * ski wonders whether left-recursion is problem, here
13:25:26 <palomer> Cale: that works
13:25:41 <Cale> palomer: the problem is that 'expression' succeeded
13:25:57 <Cale> so it never bothered to try application, and then later failed
13:26:05 <palomer> oh my
13:26:15 <palomer> but, you see, this is exactly what I would write in EBNF
13:26:24 <lightstep> dsacode, i don't really know what it is, but i understand the quadratic sieve somewhat. these are not simple algorithms at all.
13:26:25 <ski> the problem is that '(<|>)' cutts
13:26:31 <ski> s/cutts/cuts/
13:26:32 <Philippa> <|> is left-biased
13:26:38 <ski> (in prolog sense)
13:26:38 <Cale> Parsec doesn't have commutative <|>
13:26:55 <Cale> Other combinator libraries do
13:27:01 <Philippa> you need to check for application first
13:27:34 <ihope> I calculated ack(4,2) using Haskell.
13:27:37 <palomer> hrm
13:27:40 * palomer skips back to happy
13:28:07 <ihope> It took about a second to calculate, and another second to display.
13:28:19 <Cale> palomer: it's just an efficiency thing
13:29:01 <Philippa> and for values of "just" that produce really fast code
13:29:17 <Philippa> the first-order fragment of parsec parsers can be parsed in linear time
13:30:44 <musasabi> monads make the optimization hard
13:31:05 <ski> (hm .. how about the arrow-basec parser ?)
13:31:27 <Heffalump> is there a proper implementation of that anywhere?
13:31:43 * ski is not sure
13:33:04 * Philippa still suspects jhc-style optimisations can make first-order parsec parsers rather fast
13:33:14 <dsacode> If i have some number and i have infinite list of prime numbers, how i can check if this number belongs to that list?
13:33:25 <ihope> I calculated ack(4,2) using lambdabot :-)
13:33:28 <Philippa> at least, if applied aggressively enough - if you get to the point of inlining a load of stuff and then performing case merging
13:33:54 <Cale> dsacode: well, hopefully the list is sorted
13:34:10 <Philippa> 'cos otherwise you can't write a function that's guaranteed to terminate
13:34:11 <palomer> does lambdabot have comments for functions?
13:34:16 <palomer> like @help getContents
13:34:17 <dsacode> Cale: yes
13:34:27 <palomer> @info getContents
13:34:28 <lambdabot> Unknown command, try @listcommands.
13:34:28 <Cale> dsacode: so that you can just check if it belongs to takeWhile (<= x) xs
13:34:47 <palomer> > :info getContents
13:34:48 <lambdabot>  parse error on input `:'
13:35:43 <dons_> moin
13:36:06 <dsacode> Cale: sorry i don't know how to use takeWhile, can you give me example for `primes' list and some `x' number?
13:36:14 <Cale> actually, head (dropWhile (<x) xs) == x ought to work well
13:36:23 <lightstep> @index getContents
13:36:24 <lambdabot> System.IO, Prelude
13:36:33 <palomer> yeah, but what does it do?
13:36:39 <palomer> lambdabot should be able to tell me!
13:36:43 <Cale> takeWhile p xs  is the initial fragment of xs of elements such that p returns true
13:36:58 <Cale> > takeWhile (<10) [1..30]
13:37:00 <lambdabot> [1,2,3,4,5,6,7,8,9]
13:37:05 <ski> hi dons_
13:37:06 <Cale> > dropWhile (<10) [1..30]
13:37:08 <lambdabot> [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
13:37:12 <lightstep> @where sicp
13:37:13 <lambdabot> I know nothing about sicp.
13:37:36 <Cale> > head (dropWhile (<10) [1,3..31]) == 10
13:37:38 <lambdabot> False
13:37:43 <Cale> > head (dropWhile (<11) [1,3..31]) == 11
13:37:45 <lambdabot> True
13:38:04 <lightstep> @doc getConentes
13:38:05 <lambdabot> getConentes not available
13:38:11 <Cale> > head (dropWhile (<11) [1,3..]) == 11
13:38:13 <lambdabot> True
13:38:21 <Cale> > head (dropWhile (<10) [1,3..]) == 10
13:38:22 <lambdabot> False
13:38:32 <Cale> (works in the infinite case, as you can see :)
13:39:04 <ihope> Infinity is a smallish number.
13:39:07 <dsacode> great, thanks
13:39:14 <Cale> x `ordElem` xs = head (dropWhile (< x) xs) == x
13:39:30 <Cale> you might want to take care of the empty case better than I have :)
13:39:50 <palomer> why does happy force us to write our own lexer?
13:40:14 <Cale> palomer: because it's not a lexer generator like alex
13:40:42 <palomer> oh, so you need to use lexer AND happy together
13:41:07 * palomer never understood why they always have to seperate a lexer generator and a parser generator
13:41:19 <palomer> seriously, who uses one without the other?
13:42:10 <Philippa> different class of algorithm
13:42:18 <Philippa> so it's easier to treat them as separate programs
13:42:32 <Saulzar> Seems a pretty useful kind of function to have around... for monads too "returnWhen" or somesuch
13:42:58 <Cale> Saulzar: returnWhen?
13:43:08 <Lor> Sometimes one may want to write either the lexer or the parser by hand.
13:43:46 <Saulzar> Cale, The function you were discussing above, that's just my bad naming :)
13:44:50 <Cale> Saulzar: but monads don't have any notion of head or tail
13:45:04 <Heffalump> lexing means you need less lookahead when parsing
13:45:36 <Philippa> yup. Often a very good thing, especially given the option of lazy lexing
13:45:43 <palomer> bah, everyone should do like sablecc and combine the 
13:45:43 <palomer> 2
13:46:10 <palomer> while letting the user optionally use his own
13:46:29 <Saulzar> Cale, I mean something like the equivalent of mapM_ with a -> Bool but only returning the last element 
13:46:47 <lightstep> @type mapM
13:46:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:47:13 <lightstep> @type \f l -> mapM f l >>= liftM last
13:47:15 <lambdabot> Not in scope: `liftM'
13:47:19 <Cale> Saulzar: ah, okay
13:47:28 <Philippa> palomer: parsec can do that
13:47:44 <Heffalump> Philippa: most lexers are stream based, I think
13:47:46 <palomer> ok, back to parsec:P
13:48:22 <Philippa> getting used to the left-bias and using try takes a short while, but you're fine once you've done it
13:48:26 <Cale> palomer: if you're put off by the asymmetric choice operator, try that parsek library which was mentioned the other night
13:48:33 <Philippa> it was close enough to EBNF for me to write Real Parsers (tm) pretty fast
13:48:58 <palomer> parsek should so be the standard
13:49:08 <Saulzar> Hmm, in fact the one I was thinking of has no list at all, just interpreting the output of a monad... whoops.
13:49:12 <Saulzar> returnWhen :: Monad m => (a -> Bool) -> (m a) -> m a
13:49:27 <Saulzar> Hmm, second brackets unnesescary..
13:49:38 <lightstep> @google parsek
13:49:40 <lambdabot> http://www.cp2.parsek.com/
13:49:41 <Philippa> palomer: there is no standard, HTH :-)
13:49:41 <Cale> Saulzar: how does that work?
13:49:51 <Cale> http://www.cs.chalmers.se/ComputingScience/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../koen/Parsek.hs
13:50:16 <Saulzar> Keeps repeating the action until the returned value satisfies the condition, when it does - returns it
13:50:43 <Cale> Saulzar: ah, okay
13:51:05 <palomer> well, erm, parsek should be included in ghc
13:51:15 <Cale> yes, I agree with that
13:52:11 <Philippa> how fast's parsek, and what class of languages does it work with?
13:52:28 <Philippa> Parsec's fast enough I'm generally happy to do twisted things with it like the way Flippi handles parsing plugins...
13:53:16 <Cale> Philippa: it's somewhat like ReadP, but almost Parsec compatible
13:53:26 <ski> (Saulzar : maybe you could have 'until' in the name ?)
13:54:38 <Philippa> I never really played with ReadP enough
13:54:52 <Philippa> mostly because Parsec was Good Enough and resilient enough to me doing twisted things with it
13:55:03 <palomer> > print "\\"
13:55:04 <lambdabot> No IO allowed
13:55:09 <Cale> apparently it's almost as fast as Parsec
13:55:09 <palomer> > "\\"
13:55:11 <lambdabot> "\\"
13:55:14 <palomer> > "\"
13:55:15 <lambdabot>  lexical error in string/character literal
13:55:19 <palomer> how do I get "\" ?
13:55:32 <Cale> you did
13:55:44 <lightstep> > length "\\"
13:55:46 <lambdabot> 1
13:56:01 <palomer> > isLetter "\\"
13:56:03 <lambdabot> Couldn't match `Char' against `[Char]'
13:56:07 <palomer> > isLetter '\\'
13:56:09 <lambdabot> False
13:56:11 <ski> > error "\\"
13:56:12 <lambdabot> Add a type signature
13:56:17 <ski> > error "\\" :: ()
13:56:19 <lambdabot> Exception: \
13:56:26 <lightstep> Parsek only parses strings, unlike Parsec
13:57:35 <palomer> what else can parsec parse?
13:57:40 <Cale> er, I'm not sure about that...
13:57:50 <Cale> It seems to be generalised over symbol type
13:58:02 <Cale> parsec can parse arbitrary lists of tokens
13:58:08 <palomer> ahh
13:58:12 <palomer> but, like, who would:P
13:58:20 <Cale> lots of people
13:58:23 <basti_> yes lots
13:58:35 <basti_> many parsers first "lex" the data
13:58:57 <basti_> thus the parsed symbols would be "tokens"
13:59:46 <Cale> What Parsek is missing is builtin user state, but that's stupid to include anyway, since a state transformer will give you that.
14:00:05 <basti_> parsers with state unrule anyway.
14:00:37 <JohnMeacham> Philippa: actually, some of the optimizations that seem to work well for parsec parsers can be ported to ghc easily, as they are core->core transformations.
14:01:00 <basti_> :-o
14:01:02 <Cale> Parsek seems to have functions for returning the shortest/longest result, or a list of all possible parses, which is cool
14:02:07 <Cale> as well as being able to return you the leftover portion of the string
14:02:17 <Philippa> JohnMeacham: yeah, I'd suspected that might be true. I can't help wondering how easy it is for each compiler to apply them just aggressively enough for a given parser though
14:03:02 <palomer> when writing a lambda term evaluator, one is constantly creating new variable names
14:03:10 <Philippa> have you had sufficiently cool results on parsers appear in practice, btw?
14:03:11 <JohnMeacham> well, the generalized CPR one that I am thinking of that helps error monads greatly is always a win so that should be used as much as possible.
14:03:14 <palomer> how would one go about doing this in haskell in an elegant manner?
14:03:40 <basti_> monadically
14:03:45 <JohnMeacham> nothing I have measured. my IO monad is an error monad though, so I have paid particular attention to optimizations involving them.
14:03:45 <Philippa> Reader monad
14:04:02 <palomer> how so?
14:05:38 <Philippa> the Reader monad solves your problem exactly. Go read :-)
14:05:38 <JohnMeacham> as a tangent, this might be interesting if writing a lambda calculator http://okmij.org/ftp/Haskell/Lambda_calc.lhs
14:05:56 <JohnMeacham> but yeah, reader monad is the way to go.
14:07:33 <Cale> Parsek seems quite fast
14:08:56 <Cale> at least, fast enough for practical use
14:12:03 <palomer> Cale: I was thinking about what you said the other day, side effects never being the product of evaluation
14:12:12 <palomer> but isn't the execute function simple an evaluator?
14:12:22 <palomer> s/simple/simply
14:12:41 <Cale> not a Haskell evaluator
14:12:53 <Cale> as in it doesn't have a pure resuly
14:12:58 <Cale> result*
14:13:20 <palomer> the reader monad looks like fun!
14:13:49 <palomer> Cale: but it'll have this big lambda term of type IO()
14:13:53 <palomer> and it'll reduce it
14:13:54 <palomer> no?
14:14:46 <xs> into what?
14:15:05 <palomer> what do you mean into what?
14:15:12 <xs> what will it be reduced to?
14:16:26 <palomer> well, it would be in a different calculus
14:16:37 <xs> an impure one?
14:17:07 <Cale> just caught your question there before my machine overheated :)
14:17:42 <Cale> something of type (IO a) necessarily isn't a lambda term, or else it would be of type a -> b for some types a and b
14:18:25 <Cale> now, internally, perhaps IO a is implemented with lambda terms. In some sense, a value of type IO a is a function RealWorld -> (a, RealWorld)
14:19:07 <Cale> but that's an odd way to think of them :)
14:22:58 <Cale> but there's no one true way of representing IO actions, and it'll be dependent on the runtime system which one is chosen
14:23:00 * {Arias} bye
14:23:10 <Cale> bye {Arias} 
14:25:10 <ricebowl> rofl
14:25:27 <ricebowl> interesting /quit message...
14:28:46 <palomer> :o
14:28:54 <fnord123> ?
14:29:21 <palomer> anyone have any monad reader examples?
14:29:22 <ricebowl> the link to "cada_pais_con_su_mujer.pps"
14:29:43 <ricebowl> means "each country has its own woman" or something like that
14:35:39 <soysauce> @type Control.Arrow.returnA
14:35:41 <lambdabot> forall b (a :: * -> * -> *). (Control.Arrow.Arrow a) => a b b
14:35:49 <soysauce> > Control.Arrow.returnA
14:35:50 <lambdabot>  add an instance declaration for (Show (a b b))
14:35:56 <soysauce> > Control.Arrow.returnA 0
14:35:58 <lambdabot> 0
14:36:02 <soysauce> weird...
14:36:29 <soysauce> > Control.Arrow.returnA id
14:36:30 <lambdabot>  add an instance declaration for (Show (a -> a))
14:37:04 <xerox> @type Control.Arrow.returnA
14:37:05 <lambdabot> forall b (a :: * -> * -> *). (Control.Arrow.Arrow a) => a b b
14:37:12 <xerox> uh.
14:37:42 <ricebowl> so basically it's the same as id when in the (->) arrow
14:37:48 <xerox> Rigt.
14:38:12 <poetix> xerox: where id was, there shall ego be
14:38:55 <poetix> Are you making sense of Arrows?
14:39:06 <ricebowl> me?
14:39:14 <SyntaxNinja> is haxml's non-cabal build system weird?
14:39:17 <xerox> poetix: parse error
14:39:21 <SyntaxNinja> (or is it just me)
14:39:26 <xerox> poetix: yeah, anyway.
14:40:20 <fnord123> any haskellites on macs?
14:40:34 <SyntaxNinja> fnord123: lots of 'em!
14:40:45 <SyntaxNinja> galois seems to have more macs these days than linux (on the desktop)
14:41:03 <SyntaxNinja> <--- not me
14:41:04 <xerox> anyway, too tired --  'night!
14:41:06 <fnord123> im going through the xcode.app package contents and i see how to do the syntax highlighting for new languages
14:41:29 <fnord123> im wondering how to get other things working, like function resolution for 'goto definition' and such working
14:41:54 <fnord123> maybe it uses TAGS or -g debugging info in the .o files
14:44:31 <soysauce> > let foo xs = [x:y:[] | x <- xs, y <- xs] in foo [1,2,3]
14:44:33 <lambdabot> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
14:44:42 <soysauce> aha
14:45:25 <soysauce> > let foo n xs = if n == 0 then [] else [x:ys | x <- xs, y <- foo (n-1) xs] in foo 3 [1,2]
14:45:27 <lambdabot>  Not in scope: `ys'
14:45:33 <soysauce> > let foo n xs = if n == 0 then [] else [x:ys | x <- xs, ys <- foo (n-1) xs] in foo 3 [1,2]
14:45:35 <lambdabot> []
14:47:37 <soysauce> > let foo n xs = if n == 0 then [[]] else [x:ys | x <- xs, y <- foo (n-1) xs] in foo 3 [1,2]
14:47:38 <lambdabot>  Not in scope: `ys'
14:47:45 <soysauce> > let foo n xs = if n == 0 then [[]] else [x:ys | x <- xs, ys <- foo (n-1) xs] in foo 3 [1,2]
14:47:47 <lambdabot> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
14:48:17 <xerox> cool
14:50:49 <soysauce> @pl \x -> [x]
14:50:50 <lambdabot> return
14:50:54 <soysauce> !
15:05:50 <zagrius> Too bad Haskell's lazyness doesn't do the following:
15:05:53 <zagrius> if length [1..2] > length [1..] then 1 else 2
15:06:32 <SyntaxNinja> zagrius: you could write a function to perform that check, as long as not both the lists were infinite ;)
15:07:04 <zagrius> SyntaxNinja: I know. 
15:07:29 <SyntaxNinja> it's not really a matter of Haskell's laziness.
15:07:30 <zagrius> I think I was being too lazy ;)
15:08:54 <rep> too lazy?
15:08:58 <rep> is there such a thing?
15:09:33 <zagrius> Well, if you take the "if a function doesn't need a value, it doesn't compute it", then this one should just work. 
15:10:04 <zagrius> The formal semantics say that this should not work(which is a different story). 
15:32:37 <icb> the syntax for arrowp seems to be slightly different that that of the latest ghc
15:35:11 <musasabi> well they have separate parsers...
15:36:47 <icb> i am trying to build arrowp so i can convert some .as files to .hs
15:37:17 <icb> trying to figure out if i should use the Data.Set.map or GHC.Base.map
15:38:07 <musasabi> List.map probably
15:38:26 <icb> freeVars = unionManySets . map freeVars
15:39:30 <icb> line 20 in the arrow source
15:39:34 <icb> Utils.h
15:39:46 <icb> Utils.lhs
15:40:46 <musasabi> what is the type of freeVars?
15:41:13 <icb> > class FreeVars a where
15:41:14 <icb> >	freeVars :: a -> Set HsName
15:41:14 <lambdabot>  parse error on input `class'
15:41:30 <icb> i guess set
15:51:27 <guest_> must go today!  2 alienware laptops price $500 for one, 750 for two. message me on aim at mikcomputing, msn at heymikeeh@hotmail.com or yahoo at mperkelay if interested and wanting to buy only!!
15:53:31 <Cale> I say we all spam him back :)
15:54:30 <xinming> good idea...
15:55:08 <xinming> * guest_ :No such nick/channel
15:55:17 <xinming> It goes more than we can think.
15:55:20 <Cale> he gave contact info
15:55:35 <Cale> He's not on IRC since he got K-lined
15:55:45 <Lor> That was fast.
15:55:50 <xinming> yea...
15:56:13 <xinming> but filling his mail-box isn't a good idea :-/
16:01:46 <fnord123> Cale, what OS are you on
16:09:48 <jimapple> Did anyone understand David Roundy's q. on cafe?
16:10:44 <jimapple> I think foo :: (Foo f) => f a -> Foo is ill formed, even if there's a data Foo = Foo
16:10:54 <jimapple> @djinn a -> a
16:10:55 <lambdabot> f a = a
16:18:53 <Cale> fnord123: debian
16:21:31 <lennart> jimapple: I see you're back to simpler proofs.  lol
16:24:16 <jimapple> you gotta crawl . . .
16:25:55 <jimapple> BTW, which one of those expressions was supposed to take a short amount of time? Scott a seems to be the hiccup, except for Put a b c -> Goedel b c and Goedel (Elim a) (Peirce a b)
16:26:02 <jimapple> @djinn-env
16:26:02 <lambdabot> data () = ()
16:26:02 <lambdabot> data Either a b = Left a | Right b
16:26:02 <lambdabot> data Maybe a = Nothing | Just a
16:26:02 <lambdabot> data Bool = False | True
16:26:02 <lambdabot> data Void
16:26:04 <lambdabot> type Not x = x -> Void
16:26:27 <jimapple> @djinn-add type Goedel a b = (a->b, b->a)
16:26:29 <lennart> jimapple: oh, you need to run djinn with -s to make them fast
16:26:40 <jimapple> [rereads docs]
16:26:50 <lennart> then it doesn't sort the answers
16:27:19 <lennart> when you want proofs and not programs you usually don't care about the proof term
16:27:25 <jimapple> ah!
16:28:09 <jimapple> will :set -multi do it, or does it still sort and return the best?
16:28:50 <lennart> -multi just turns on multiple answers
16:28:58 <lennart> turns off, i mean
16:29:17 <lennart> you probably want -s -m
16:29:29 <jimapple> @djinn-clr
16:29:29 <jimapple> @djinn-add Goedel a b = Either (a->b) (b->a)
16:29:31 <lambdabot> Cannot parse command
16:29:44 <jimapple> @djinn-add type Goedel a b = Either (a->b) (b->a)
16:30:43 <lennart> are you making a hierarchy of strengthenings to IPC?
16:31:30 <jimapple> yeah. it would probably be faster to go to the library and see what's already done on the subject, eh?
16:31:47 <lennart> or google.  but less fun
16:32:18 <jimapple> but this way I can get my hands dirty. I realized last night that I've been missing a lot of implications because I forgot tyhat djinn doesn't do foralls
16:32:25 <jimapple> google wasn't much help
16:32:41 <jimapple> @google "intermediate logic" introduction
16:32:43 <lambdabot> http://www.niu.edu/phil/~buller/phil405/PHIL405.shtml
16:33:02 <lennart> yeah, i might add forall some day
16:33:10 <jimapple> I thought it was undecidable?
16:33:26 <lennart> yes, but it could still be an interesting option
16:34:10 <jimapple> indeed. So, my computer is gong crazy on Goedel (Elim a) (Peirce a b), even with :set - multi and :set -sort
16:34:35 <lennart> yes, there was one on the list that didn't terminate for me.
16:35:04 <lennart> and i have plenty of other formulae that take a looooong time
16:35:16 <jimapple> but Elim a -> Peirce a b and Peirce a b -> Elim a finish quickly
16:35:30 <jimapple> What takes so long about an Either?
16:35:36 <jimapple> I don't mean to whine
16:35:44 <jimapple> I'm really curious
16:36:00 <lennart> either introduces a choice in the search
16:36:40 <jimapple> but, if it tried one branch and then the other, it would be done very quickly
16:36:40 <lennart> but it could be a bug
16:37:18 <lennart> i think there might be a non-termination problem even with -s
16:37:36 <lennart> i "improved" the deduction rules somewhat
16:39:50 <jimapple> so I "should" darcs pull?
16:40:28 <lennart> nono, the improvement was quite a while ago.  so if it's broken, it's been broken a while
16:40:38 <lennart> and i've not fixed anything
16:41:13 <Cale> I wonder how well one could do with heuristics for recursive functions/types
16:41:39 <lennart> probably ok for the standard ones
17:10:40 <mahogny> ok, suggestions wanted. I am using wxwindows+haskell(duh) and now I want to put in non-blocking sockets. what is the best way to go?
17:12:08 <mahogny> I was thinking of mixing in some C for non-blocking sockets. haskell seems awful for sockets. or does anyone have a better idea?
17:13:04 <rep> mahogny ghc already uses non-blocking sockets
17:13:08 <Lemmih> Network.* wont do?
17:13:30 <mahogny> hm. from the API it looked like all were blocking :o I'll have another look
17:14:12 <musasabi> mahogny: they are nonblocking under the hood.
17:14:32 <mahogny> well. I need nonblocking over the hood :)
17:16:06 <mahogny> so... given that, what is the best way?
17:16:28 <mahogny> I could of course use concurrent haskell but I have a severe dislike for threads
17:18:45 <mahogny> oh wait. .socket might do. thanks anyway
17:20:37 <xs> is it possible to declare your own instance of MArray? because it seems like there is magic going on.
17:21:06 <xs> e.g. No explicit method nor default method for `Data.Array.Base.unsafeWrite'
17:21:22 <xs> but then.. if you declare it `unsafeWrite' is not a (visible) method of class `MArray'
17:29:12 <sylvan> xs, you should use unsafeWrite etc
17:29:52 <xs> sylvan: hm. but then i cannot specify how i wish mutation to occur?
17:30:40 <sylvan> You need some sort of underlying mutable construct.. so in your instance declaration you define unsafeRead and unsafeWrite
17:31:56 <xs> that yields: `unsafeWrite' is not a (visible) method of class `MArray
17:32:05 <sylvan> hmm...
17:33:08 <sylvan> Where did you import the MArray type class from? Data.Array.Base?
17:33:24 <xs> Data.Array.MArray
17:33:31 <sylvan> Use the one in Base instead...
17:33:51 <sylvan> Not sure why it would make a difference, though =)
17:34:11 <xs> heh! it does!
17:34:14 <xs> thanks!
17:34:40 <sylvan> no problem!
17:44:26 <jethr0> moin moin
17:46:31 <jethr0> @seen shapr
17:46:32 <lambdabot> shapr is in #ScannedInAvian and #haskell. I don't know when shapr last
17:46:32 <lambdabot> spoke.
17:49:13 <jethr0> @seen
17:49:14 <lambdabot> Lately, I have seen jethr0, sylvan and xs.
17:50:09 <Saulzar> hi jethr0
17:55:25 <jethr0> hey saulzar
17:55:46 <jethr0> sth happened to my tutorial page on tmrwiki. did shapr have problem recently?
17:57:23 <Saulzar> Hm, you can get a list of changes
17:57:41 <Pupeno> I have been studing programming for years (I touched a computer for the first time when I was 5 years old, I am 23 years old). Sorting algorithms were always scaping me, like I have a glimpse of how they worked and soon it was all black again, till now. Sorting algorithms and algorithms in general in Haskell are just understandable, impresive.
17:57:52 <jethr0> yes, and the stuff i did is not in them... but i guess i'll ask shapr when he's around :)
17:59:21 <Saulzar> Ahh.
18:07:38 <icb> @seen ross
18:07:39 <lambdabot> I haven't seen ross.
18:07:45 <icb> @seen henrik
18:07:46 <lambdabot> I haven't seen henrik.
18:14:29 <xinming> lisppaste2: url
18:14:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:33:06 <icb> anyone has a working "arrowp" executable here? i need help to convert a few files
19:19:17 <erm> n
19:20:16 <erm> whois
19:26:15 <Cale> erm: new here?
19:26:59 <Cale> Any questions about Haskell?
19:27:32 <Lemmih> @seen jlouis 
19:27:33 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
19:27:33 <lambdabot> spoke.
19:27:39 <Lemmih> @seen SamB 
19:27:39 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 8
19:27:39 <lambdabot> hours, 21 minutes and 31 seconds ago.
19:30:25 <tismith> its a bit quiet isn't it
19:33:31 <Lemmih> Well, it's December the 23rd.
19:33:49 <Stinger> thats no excuse
19:34:41 <tismith> hrm.. to stick around here at work til 5, or bugger off early and go to the pub... decisions, decisions
19:35:44 <monochrom> order a delivery of alcohol to the work place.
19:45:34 <chucky> going to the pub now... Wow, I just returned from the bar. :)
19:46:28 <chucky> to be specific, it's 5 am in Sweden right now.
19:47:00 <musasabi> early it is.
19:47:36 <chucky> or late, depending on how you see it.
20:59:05 <sethk> hey, all, why, when I forget to put qualified (after import) the thing works anyway?
21:03:47 <Lemmih> Because 'import M' allows you to access the symbols qualified and unqualified.
21:04:43 <sethk> Lemmih, so I can say   import Data.Map as DMap, without qualified, and it's legal?  Not a ghc extension?
21:05:40 <Lemmih> It's pure Haskell 98.
21:08:14 <sethk> ah, thanks, didn't know.
21:13:46 <jimapple> Lemmih: I want to play with HASP, but OCR'dBirdLanguage is down!
21:17:36 <Lemmih> huh?
21:19:01 <Korollary> heh, Taral seems to have discovered LtU.
21:19:53 <jimapple> Lemmih: Ah, nevermind. But your link is misspelled in HCAR
21:20:26 <jimapple> http://scannedinavan.org/~lemmih/hasp/
21:20:40 <Lemmih> D'oh.
21:21:12 <jimapple> d'oh, indeed
21:33:34 <twb`> Any people familiar with elisp?
21:34:20 <twb`> It has an idiom "mapconcat list-of-strings '\n'" to turn ["foo","bar","baz"] into "foo\nbar\nbaz".
21:34:46 <twb`> I'm thinking the best way is to concat $ intersperse l-o-s '\n'.
21:36:00 <twb`> Oops, that doesn't work.
21:36:14 <twb`> > concat $ intersperse '\n' ["foo","bar","baz"]
21:36:16 <lambdabot> Couldn't match `[a]' against `Char'
21:36:29 <cpatrick> > unlines ["foo","bar","baz"]
21:36:30 <lambdabot> "foo\nbar\nbaz\n"
21:36:34 <twb`> Aha!
21:36:36 <twb`> Thanks.
21:36:45 <cpatrick> > unwords ["hello","world"]
21:36:46 <lambdabot> "hello world"
21:36:50 <cpatrick> is also handy :)
21:38:29 <Cale> > concat $ intersperse "\n" ["foo","bar","baz"]
21:38:31 <lambdabot> "foo\nbar\nbaz"
21:38:43 <Cale> > concat $ intersperse "," ["foo","bar","baz"]
21:38:45 <lambdabot> "foo,bar,baz"
21:39:12 <twb`> Cale: oooh.
21:39:18 * twb` feels stupid.
21:39:59 <twb`> What is butlast called?
21:40:12 <Cale> butlast?
21:40:16 <twb`> @hoogle [a] -> [a]
21:40:17 <lambdabot> Data.List.tail :: [a] -> [a]
21:40:17 <lambdabot> Data.List.init :: [a] -> [a]
21:40:17 <lambdabot> Data.List.reverse :: [a] -> [a]
21:40:17 <Cale> maybe 'init'?
21:40:40 <twb`> butlast [1,2,3] ==> [1,2]
21:40:47 <Cale> > init [1,2,3]
21:40:49 <lambdabot> [1,2]
21:41:02 <Cale> > init []
21:41:03 <lambdabot> Add a type signature
21:41:05 <twb`> Ah, cool.  And last?
21:41:16 <Cale> > init [] :: [Int]
21:41:18 <lambdabot> Exception: Prelude.init: empty list
21:41:19 <cpatrick> > last [1..54]
21:41:21 <lambdabot> 54
21:41:25 <Cale> > last [] :: [Int]
21:41:26 <lambdabot> Exception: Prelude.last: empty list
21:41:30 <twb`> Okie dokey.
21:41:55 <Stinger> whatcher writing twb?
21:42:21 <twb`> Stinger: I'm implementing docutils in Haskell.
21:42:28 <twb`> http://docutils.sf.net
21:42:49 <twb`> http://twb.ath.cx/~twb/darcs/miscellaneous/parsewiki/
21:42:59 <Stinger> reinventing the wheel eh? :)
21:43:11 <twb`> Well, I have a pathological hatred of Python.
21:43:18 <Stinger> aw :(
21:43:24 <twb`> And their community.
21:43:29 <cpatrick> :o
21:44:30 <twb`> They remind me of the GNOME community.
21:44:49 <ozone> twb`: i presume you've seen POD?
21:44:55 <ozone> (perl's documentation format)
21:44:58 <twb`> ozone: the Perl stuff?
21:45:02 <twb`> Yeah, briefly.
21:45:20 <twb`> Currently I'm using muse, which is both wonderful and a pile of hacks.
21:45:23 <ozone> very simple, very easy, very good for its target market
21:46:10 <twb`> Well, what I want it for is an alternative to LaTeX that can output good-looking HTML and PDF.
21:53:41 <gzl> have you looked at lout?
21:53:45 <twb`> Yeah.
21:53:47 <gzl> ok.
21:53:56 <twb`> And ast or awt or whatever it was.
21:56:57 <twb`> @pl all (\xs -> all p xs) xss
21:56:58 <lambdabot> all (all p) xss
21:57:32 <twb`> I wish I was as smart as you, lambdabot.
21:59:44 <twb`> Am I the only one that *loves* where?
22:01:57 * twb` grins evilly.
22:02:05 <twb`> (defmacro where (expr &rest bindings) `(let ,bindings expr))
22:02:42 <gzl> where?
22:03:39 <twb`> It's like let, but the details go at the end instead of at the start.
22:03:52 <twb`> Which makes it more readble, IMO.
22:05:25 <gzl> oh, that. yeah, I really like where.
22:05:30 <gzl> like it a lot better than let.
22:05:45 <gzl> I agree about readability.
22:05:59 <twb`> That above code implements it in Lisp ;-)
22:06:38 <Saulzar> Especially for math-ish stuff... you have a million x = blah y = blah .... 
22:07:16 <Saulzar> Where in haskell, a million = a big routine = 4 lines :) 
22:07:54 <twb`> Heh, in Forth you *have* to have short functions, because the editor is block-oriented :-)
22:09:58 * aleator_ wants an excuse to program in forth..
22:10:19 <cpatrick> aleator_: get an HP calculator?
22:10:39 <twb`> HP uses RPL, not Forth.
22:10:40 <cpatrick> RPL is pretty neat
22:10:46 <cpatrick> twb`: pedant
22:10:59 <cpatrick> I don't actually know forth, but I figure it must be pretty similar
22:11:03 <twb`> If you want to use Forth, get a Sun / Apple box. :-)
22:11:09 <cpatrick> they're both perverse and backwards
22:11:20 * cpatrick shudders at the memory of using openfirmware
22:13:22 <aleator_> I actually did a forth clone once.. In haskell.
22:13:30 <twb`> aleator_: hasn't everyone?
22:13:41 <twb`> Mine was about 50 lines long :-)
22:13:57 <aleator_> Mine was a stack of ~5 monads :)
22:14:03 <Cale> there's some nice forth-like languages which embed into Haskell
22:14:09 <Saulzar> I haven't :)
22:14:30 <twb`> Wow, for once I used compose correctly on my first try.
22:15:32 <Cale> vx.hn.org/autoshare/forthish.hs
22:16:10 * cpatrick stabs firefox
22:16:28 <cpatrick> why won't it let me open it in a browser rather than spawning gedit? brrr
22:16:42 <twb`> w3m-el
22:16:53 <cpatrick> hrmph
22:16:54 <twb`> Or use view-source:http://bleh
22:17:16 <Cale> it really ought to provide an option in the save file dialog
22:17:17 <cpatrick> w3m is probably quite sensible for this kinda thing though
22:17:22 <cpatrick> Cale: yes
22:17:34 <aleator_> Cale: thats kinda neat.
22:17:47 <cpatrick> Cale: I don't understand it but it looks cute
22:18:22 <cpatrick> k is a continuation?
22:18:32 <Cale> *Main> start push 1 push 2 add end
22:18:32 <Cale> 3
22:18:46 <Cale> yeah
22:22:24 <elux> hey
22:22:26 <elux> does anyone know a good compiler design article/tutorial on code generation?
22:22:29 <elux> from c to assembly perferrably
22:22:40 <Cale> app (f, (x,s)) k = k (f x, s)
22:22:44 <Cale> start push 1 push 2 push (+) app app end
22:24:11 <sieni> elux: what about "modern compiler implementation in c" by appel et al.?
22:24:17 <elux> ok then
22:24:19 <elux> thank you
22:25:21 <sieni> there are also ML and Java versions of the book
22:25:34 <sieni> (the ML is, not surprisingly, the original one)
22:28:32 <Cale> I don't know what would posess someone to implement a compiler in C.
22:29:35 <sieni> Implementing a C compiler in C makes sense :-)
22:29:49 <elux> lol
22:30:13 <Cale> yeah, maybe that much, for ease of bootstrapping
22:30:22 <sieni> Cale: you know, one should eat your own dogfood :-)
22:30:48 <Cale> still, a C compiler would probably be much easier to write in Haskell
22:31:24 <sieni> well, they say that gcc is written in common lisp with c syntax or something
22:31:41 <Cale> heh
22:32:35 <Cale> Actually, one could write a C compiler in Haskell, then just use GHC to compile that Haskell down to C.
22:33:47 <elux> does anyone know of a haskell svg module?
22:33:54 <sieni> Cale: something like that... some scheme-to-c compilers ship a compiled version (c source) with their packages to bootstrap the compiler
22:34:18 <Cale> http://www.ofb.net/~abe/svg-cairo.shtml
22:34:26 <Cale> that's the first thing I found :)
22:34:33 <elux> damn
22:34:37 <elux> thats nice :)
22:35:01 <elux> hrmm how good is libsvg tho? which version of svg does it implement
22:35:17 <Cale> I don't know really
22:36:02 <elux> http://librsvg.sourceforge.net/
22:36:09 <elux> this is probably much better
22:36:13 <Cale> I also don't know how good those cairo bindings there are. I know that xerox' bindings in Gtk2Hs are quite good
22:37:20 <elux> i guess i'll probably just use c++ to do this one
22:37:22 <Cale> librsvg looks small, a binding should be easy
22:37:59 <Cale> If you feel like learning about the FFI
22:38:33 <Cale> It looks like it works with GTK2 types, so you might want to talk to Duncan (dcoutts) about it.
22:38:36 <elux> dont think so
22:38:44 <elux> er
22:38:50 <elux> probably just gonna use c++, it'll save me the hassle
23:01:47 <ProfTeggy> Morning all.
23:01:54 <Cale> morning ProfTeggy 
23:05:39 <ProfTeggy> I think it is one of the luckier coincidences that with Haskell, technical superiority of the language goes together with unseen friendliness of its user community.
23:06:09 <ProfTeggy> Gives me a warm and fuzzy Christmas feeling. ;-)
23:08:37 <Cale> @pl q3 a b c d = a d b (q2 (\ _ _ -> c) b d)
23:08:38 <lambdabot> q3 = (`ap` flip (q2 . const . const)) . (((.) . ap) .) . flip
23:09:32 <Cale> @pl q3 a b c d = a d b c
23:09:34 <lambdabot> q3 = (flip .) . flip
23:09:53 <Cale> @pl q4 a b c d e = a e b c d
23:09:54 <lambdabot> q4 = (((flip .) . flip) .) . flip
23:10:12 <Cale> @pl q2 a b c = a c b
23:10:13 <lambdabot> q2 = flip
23:10:32 <Cale> nice pattern there :)
23:11:51 <ccshan> @djinn ((((p->q)->p)->p)->false)->false
23:11:52 <lambdabot> -- f cannot be realized.
23:12:35 <ccshan> @djinn ((p->(q->false)->false)->(p->false)->false)->(p->false)->false
23:12:36 <lambdabot> f a b = a (\ c _ -> b c) b
23:13:42 <Cale> @djinn ((p->(q->Void)->Void)->(p->Void)->Void)->(p->Void)->Void
23:13:43 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
23:14:58 * ccshan waves
23:15:12 <ccshan> Why install software when you can talk to it over irc?
23:15:18 <Cale> :)
23:20:58 <ForgeAus> hey all :)
23:43:05 <Itkovian> meuning
23:47:45 <araujo> Hello.
