00:41:44 <ProfTeggy> Moin
00:42:00 <Cale> haha, this error message rules :)
00:42:06 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
00:43:36 <Cale> (I forgot the gamma0)
00:43:42 <Cale> *HC> reify ((flip .) . (((flip .) .) . (((.) . (.)) . (((.) . (.)) .)))) gamma0
00:43:43 <Cale> \a b c d h p y -> a (b d h) (c p y)
00:46:25 <Cale> this should get added to lambdabot :)
00:46:39 <ski> yes
00:59:10 <hellish> has anyone found a use for the djinn utility? Or is it just for show?
01:00:41 <NLoRD> hello
01:01:19 <NLoRD> I want to use 2 where in my program, but hugs does not accept to load it
01:01:29 <NLoRD> is there a trick to use 2 where?
01:01:46 <NLoRD> I use: where y = f(n-1)
01:01:46 <NLoRD>                         where g::(Int,Int)->Int
01:01:46 <NLoRD>                               g(n,m)
01:01:46 <NLoRD>                                 | (n>=2 && m==0) = g(sqrt(n),0)
01:01:46 <NLoRD>                                 | (n>=2 && m>=1) = g(sqrt(n),m-1)+m
01:01:46 <NLoRD>                                 | otherwise = n
01:01:51 <NLoRD> sorry for the flood
01:02:52 <NLoRD> could anyone help me please?
01:02:59 <Taral> @pl (\f g x y -> g (f x y))
01:03:00 <lambdabot> flip ((.) . (.))
01:03:14 <Taral> @pl (\f g x -> g (f x))
01:03:15 <lambdabot> flip (.)
01:03:19 <Taral> @pl (\g f x y -> g (f x y))
01:03:20 <lambdabot> (.) . (.)
01:03:33 <Cale> NLoRD: sure
01:03:53 <Cale> NLoRD: is there a function declaration just above the first where?
01:04:44 <Cale> also, you're not using g in the definition of y
01:04:47 <NLoRD> may I paste somewhere my code to make it simpler?
01:04:54 <Cale> so, the second where won't be used
01:04:58 <Cale> yeah
01:05:02 <Cale> lisppaste2: url
01:05:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:05:34 <Cale> why not put it all in one where clause?
01:05:38 <lisppaste2> NLoRD pasted "2 where" at http://paste.lisp.org/display/14670
01:05:52 <ski>   where
01:05:55 <ski>   y = ...
01:05:57 <ski>   g :: ...
01:06:04 <ski>   g (n,m) ...
01:06:11 <Cale> yeah
01:06:18 <NLoRD> ok thank you very much :)
01:06:27 <Cale> you don't want g to just scope over the declaration of y
01:12:05 <dons> Cale, you want oleg's HList evil as a plugin?
01:12:34 <Cale> hehe
01:12:40 <Cale> well, it's @unpl
01:12:55 <Cale> (somewhat)
01:13:20 <dons> hmm...
01:17:19 <NLoRD> my program works for low values , for example f(1) but it freezes for higher values like f(10)
01:17:33 <NLoRD> could you give me a little tip?
01:17:43 <NLoRD> NLoRD pasted "2 where" at http://paste.lisp.org/display/14670
01:17:54 <dcnstrct> I *LOVE* Ruby.  I have a good amount of experience with C/C++/Java/x86asm.  I like OO and all, but I feel like it might be useful to go ahead and learn a different type of language.  I can't decide if I should learn LISP first or Haskell.  Any advice ?
01:19:25 <neologism> haskell
01:19:27 <Heffalump> what advice would you expect from a Haskell channel?
01:19:31 <chucky> dcnstrct: learn Haskell and see how you like a language with lots of static typing
01:19:43 <neologism> lisp is too old for my taste
01:20:07 <dcnstrct> it is damn old. 
01:21:00 <neologism> with haskell you have pattern matching, lazy evaluation, strict typing, type variables, set generators etc etc etc
01:21:05 <neologism> with lisp you have parenthesis :)
01:21:17 <ValarQ> hmm :/
01:21:35 <Oejet> neologism: That's deep.
01:21:40 <neologism> :)
01:21:46 <wilx> Hehe.
01:23:18 <dcnstrct> wow I asked the same question in #lisp and they're saying "go with haskell" lol
01:23:32 <dblhelix> a language being old is not quite a good argument not to use it, imho
01:24:01 <dcnstrct> C is pretty old, but still damn useful.
01:24:02 <dblhelix> a language not being capable of evolving etc. *is*
01:24:56 <dcnstrct> how new is Haskell ?
01:24:57 <neologism> dblhelix: well... old languages lack features which were developed after their birth
01:25:11 <dcnstrct> my fav language sofar is Ruby but its really damn new, like < 10 years
01:25:46 <dblhelix> neologism: haskell, f.i. now has GADTs... they weren't there when haskell was born... hence, evolving
01:26:10 <Oejet> dcnstrct: What types of programs would you like to write in Haskell?
01:26:13 <dons> they weren't here this time lsat year ;)
01:26:15 <neologism> not haskell98
01:26:57 <dblhelix> neologism: well, if you fix a specific version and stamp it... well, then there's no evolution possible, of course
01:27:00 <dcnstrct> Oejet, I'm not sure yet.  What kind or programs do people use it for ? Do people write many network apps in it ?
01:27:01 <neologism> its like saying that C supports oop cause C++ does
01:27:25 <dblhelix> neologism: and, indeed, that's not that bad an argument ;)
01:27:42 <neologism> anyway - I'd prefer hskell over lisp
01:27:43 <dblhelix> from a certain perspective
01:27:53 <dblhelix> neologism: we agree on that
01:28:14 <dcnstrct> what kinds of apps is haskell NOT good for ?
01:28:21 <dons> dcnstrct, it's a general purpose language, so you can of course write network apps. many have been written.
01:28:25 <dons> @version
01:28:26 <lambdabot> lambdabot 3p243, GHC 6.5.20050806 (Linux i686)
01:28:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
01:28:29 <neologism> dcnstrct: bad written apps
01:28:30 <dcnstrct> excellent
01:28:32 <chucky> dcnstrct: realtime systems?
01:28:45 <neologism> its hard to write coredumping app in haskell :)
01:28:53 <neologism> or.. at least harder then in C
01:30:11 <Oejet> dcnstrct: How did you learn that Haskell exists?
01:30:24 <dcnstrct> chit chat in #ruby
01:30:36 <neologism> a lot of universities provide haskell courses
01:30:41 <dcnstrct> people were talking about other styles of programming besides OO
01:31:05 <neologism> OO is orthogonal to functional/imperative
01:31:11 <Oejet> What is OO?  8-]
01:31:50 <ValarQ> Oejet: some buzzword i believe
01:32:00 <neologism> openoffice ? :)
01:32:04 <dons> from the 80s 
01:32:40 <Oejet> Any good language can simulate many styles of programming well.
01:32:56 <neologism> my master thesis might be implementing OO in haskell
01:33:00 <dcnstrct> in my language of choice ruby... EVERYTHING is an object. 
01:33:02 <neologism> OO extension of haskell Imean
01:33:18 <ValarQ> Oejet: yeah, i'm always passing around functionpointers in C :)
01:33:18 <dcnstrct> so you can do things like this:  3.times { print "hello" }
01:33:45 <chucky> neologism: I assume you've seen O'Haskell?
01:34:06 <neologism> no... Ijust saw the title of one theme for the thesis
01:34:20 <neologism> theme->topic
01:34:28 <chucky> oh ok.
01:34:29 <Oejet> dcnstrct: Which means?
01:34:38 <dcnstrct> which means OO exists ? 
01:34:43 <neologism> I dont know if I'll stick with this thesis
01:34:57 <Oejet> Ah, if print "hello" returns an integer, that would work.
01:35:02 <dcnstrct> alright people the choice is clear, even the #lisp people say go with haskell so I will
01:35:10 <dcnstrct> thnx for your time
01:35:16 <neologism> dcnstrct: the paradigm haskell uses is very different toruby paradigm
01:35:31 <dcnstrct> thats why it should be interesting
01:35:35 <dons> @remember dcnstrct even the #lisp people say go with haskell
01:35:37 <neologism> yaeh
01:35:38 <dcnstrct> if it were the same then I'd just use ruby
01:35:40 <Cale> hehehe
01:35:55 <neologism> it definitely widens your knowledge
01:36:02 <neologism> try aslo some logic programing
01:36:39 <dcnstrct> k. 
01:36:53 <dcnstrct> is there a book everyone recommends as the best intro ?
01:37:08 <neologism> search haskell.org
01:37:18 <dcnstrct> k
01:37:25 <dons> @learn
01:37:26 <lambdabot> http://www.haskell.org/learning.html
01:37:35 <dcnstrct> gracias.  
01:37:36 <neologism> there's one book which name I dontremember but I know its violet
01:37:41 <dcnstrct> alright folks I'm out. thnx again
01:37:44 <neologism> "art of functional progamming" maybe
01:37:45 <Taral> is there anything that does (unzip . map) efficiently?
01:38:04 <ski> neologism : "Haskell: The Craft of Functional Programming" ?
01:38:06 <Cale> what's wrong with unzip . map ?
01:38:09 <Taral> @type unzip.map
01:38:10 <lambdabot>   Expecting a function type, but found `b'
01:38:10 <lambdabot>   Expected type: (a1 -> b1) -> [(a, b)]
01:38:12 <neologism> ski: probably
01:38:14 <Taral> @type unzip . map
01:38:16 <lambdabot>   Expecting a function type, but found `b'
01:38:16 <lambdabot>   Expected type: (a1 -> b1) -> [(a, b)]
01:38:18 <Taral> Nothing, just wondering...
01:38:19 <Cale> er
01:38:26 <Taral> heh
01:38:26 <Cale> other than that it's a type error :)
01:38:30 <Taral> yeah, you know what I meant.
01:38:37 <Taral> @type (\f -> unzip . (map f))
01:38:38 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
01:38:42 <Cale> yeah
01:38:53 <Cale> I think it ought to be fine
01:38:55 <Taral> okay, unzip map it is
01:39:00 <ski> @hoogle (a1 -> (a, b)) -> [a1] -> ([a], [b])
01:39:01 <lambdabot> No matches, try a more general search
01:39:18 <Taral> we have concatMap, why not unzipMap? :)
01:39:30 <ski> @hoogle unzip
01:39:31 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
01:39:31 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
01:39:31 <lambdabot> Data.List.unzip3 :: [(a, b, c)] -> ([a], [b], [c])
01:40:26 <ski> Control.Monad.mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b],[c])
01:40:31 <Taral> ski: I just saw that
01:40:32 <Taral> scary
01:40:47 <ski> that's a monadic version of what you want
01:40:50 <Cale> just use it with the identity monad
01:40:54 <Cale> :)
01:40:56 <ski> Taral : what's scary ?
01:41:01 <Taral> I want (a -> (b, c)) -> m a -> (m b, m c) or something
01:41:14 <Taral> anyway
01:41:16 <Taral> back to hacking
01:41:16 <ski> Taral : not possible, i think
01:41:28 <Taral> no, probably not
01:41:37 <joelr1> good morning!
01:41:50 <Cale> morning :)
01:41:57 <chucky> morning
01:42:17 <ValarQ> morning mr Cale
01:42:25 <dons> @djinn (a -> (b, c)) -> m a -> (m b, m c)
01:42:26 <lambdabot> -- f cannot be realized.
01:42:41 <ski> @djinn Monad m => (a -> (b, c)) -> m a -> (m b, m c)
01:42:42 <lambdabot> Cannot parse command
01:43:26 <Taral> @type (\f a -> a >>= \a' -> let (b, c) = f a' in (return b, return c))
01:43:28 <lambdabot> forall a a1 b (m :: * -> *) (m1 :: * -> *).
01:43:28 <lambdabot> (Monad ((,) (m a1)), Monad m, Monad m1) =>
01:43:28 <lambdabot> (a -> (a1, b)) -> (m a1, a) -> (m a1, m1 b)
01:43:38 <Taral> @type (\f a -> a >>= \a' -> let (b, c) = f a' in (return b, return c)) :: Monad m => (a -> (b, c)) -> m a -> (m b, m c)
01:43:40 <lambdabot>   Couldn't match the rigid variable `m' against `(,) a1'
01:43:40 <lambdabot>   `m' is bound by the polymorphic type `forall (m :: * -> *) a b c.
01:43:51 <Taral> ?
01:44:44 <Taral> weiiird.
01:44:53 <Taral> @type (\f a -> a >>= (\a' -> let (b, c) = f a' in (return b, return c)))
01:44:55 <lambdabot> forall a a1 b (m :: * -> *) (m1 :: * -> *).
01:44:55 <lambdabot> (Monad ((,) (m a1)), Monad m, Monad m1) =>
01:44:55 <lambdabot> (a -> (a1, b)) -> (m a1, a) -> (m a1, m1 b)
01:45:05 <Taral> what's with the second parameter's type?
01:45:16 <Taral> @type (\f a -> a >>= (\a' -> f a'))
01:45:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
01:45:25 <Taral> oh!
01:45:27 <Taral> heh
01:45:31 <Taral> yeah, can't be done
01:46:14 <Cale> @type \f x -> (fmap (fst . f) x, fmap (snd . f) x)
01:46:16 <lambdabot> forall (f :: * -> *) a b a1.
01:46:16 <lambdabot> (Functor f) =>
01:46:16 <lambdabot> (a1 -> (a, b)) -> f a1 -> (f a, f b)
01:46:50 <Cale> doesn't even require a monad :)
01:46:51 <ski> hm
01:47:34 * ski for some reason thought Taral wanted  Monad m => (a -> m (b, c)) -> m [a] -> (m [b],m [c])
01:47:34 <Cale> this is specific to the Haskell category, I'm pretty sure
01:47:42 <dons> ;)
01:47:49 <ski> Cale : using strength ?
01:47:56 <ski> (hm, no, nvm)
01:47:57 <Cale> or something like it
01:49:44 <Cale> er hmm
01:49:50 <Cale> no, I'm smoking crack :)
01:51:58 <Cale> (all you need are products)
01:56:53 <dblhelix> Cale: and a map over m, I suppose
01:57:05 <Cale> oh, it's assumed that f is a functor
01:57:14 <dblhelix> indeed
01:57:21 <dcoutts> dons, are you going to add hmp3 to hackage?
01:57:22 <Cale> (every monad is a functor anyway)
01:57:34 <dcoutts> dons, you notice that fpr-0.1 is in hackage?
01:57:40 <Taral> is there something like foldlr?
01:57:41 <dcoutts> fpr-0.1 / fps-0.1
01:57:42 <dons> dcoutts, well, unless someone else does it first...
01:57:46 <dcoutts> heh
01:57:50 <Cale> Taral: what would it do?
01:57:51 <dons> which would be nice :)
01:58:02 * dcoutts makes ebuild for fps + hmp3
01:58:05 <Taral> Use two accumulations, one left-to-right, one right-to-left
01:58:05 <musasabi> What is the status of GHC wiki vs HaWiki ?
01:58:16 <dblhelix> so effectively, you're composing split and map
01:58:36 <ski> Taral : i've played with something like that ..
01:58:38 <Taral> ?
01:59:05 <Cale> hmm
01:59:18 <Cale> I'm not sure what that would look like
01:59:37 <Cale> in my head it looks like a circular dependency would be easy to obtain
01:59:38 <dcoutts> dons, which version of fps does hmp3 need? >0.1 apparanelt
01:59:44 <dons> dcoutts, hmp needs the snapshot of fps
01:59:46 <Cale> are you talking about some kind of fixed point?
01:59:52 <dons> fps-051204.tar.gz
01:59:55 <dcoutts> dons, ok
02:00:01 <Taral> Cale: I'm writing a generic one to show.
02:00:11 <chucky> what's new in the fps snapshots?
02:00:18 <dons> ftp://ftp.cse.unsw.edu.au/pub/users/dons/fps/fps-051204.tar.gz
02:00:33 <dcoutts> dons, if the hmp3.cabal file had said so then our tools would have picked that up :-)
02:00:50 <dons> yes, it's not a real release yet...
02:01:10 <dcoutts> dons, you can have snapshot version numbers in cabal, that's ok
02:01:11 <dons> I should have tagged it though, true.
02:01:49 <dons> chucky, some things. darcs changes | less is your friend ;)
02:02:05 <dcoutts> dons, since in that case when I generated the ebuild from the cabal package it'd have complained to me tha I didn't have fps-051204 installed :-)
02:02:11 <chucky> ah yes, that's a good answer. :)
02:02:41 <Taral> foldlr _ _ [] _ n = n
02:02:41 <Taral> foldlr accL accR (x:xs) a n =
02:02:41 <Taral>     let (t, a') = accR x a
02:02:41 <Taral>     in accL t $ foldlr accL accR xs a' n
02:03:43 <Cale> ah, okay
02:03:46 <Taral> I think it has map-like functionality too?
02:03:49 <Cale> so it's not simultaneous
02:03:54 <Taral> anyway, it's... odd.
02:04:00 <Taral> I just had to use it.
02:04:08 <Cale> foldr has map-like functionality though :)
02:04:21 <Taral> true
02:04:26 <Cale> map f = foldr ((:) . f) []
02:05:06 <Cale> hmm
02:05:18 <Cale> n doesn't appear to be changing anywhere there
02:05:21 <Taral> I have those arguments out of order
02:05:26 <Taral> n is the nil
02:05:33 <Cale> ah, okay
02:05:35 <Cale> yeah
02:05:51 <Taral> foldlr _ _ _ n [] = n
02:05:51 <Taral> foldlr accL accR a n (x:xs) =
02:05:51 <Taral>     let (t, a') = accR x a
02:05:51 <Taral>     in accL t $ foldlr accL accR a' n xs
02:06:05 <ski> iirc, i had only one function for modifying
02:07:37 <ski> possibly it was  (s0 -> s1) -> (a -> s0 -> (s0,s1 -> s1)) -> [a] -> (s0 -> s1)
02:09:43 <Taral> foldlr :: (aL -> bL -> bL) -> (aR -> bR -> (aL, bR)) -> bR -> bL -> [aR] -> bL
02:10:20 <Taral> foldlr :: (t -> b -> b) -> (a -> c -> (t, c)) -> c -> b -> [a] -> b
02:10:30 <Taral> craaaazy function
02:10:38 <Taral> But it's what I needed.
02:10:48 <Cale> what did you need it for?
02:10:56 <Taral> Basically I'm taking apart an object and putting it back together again via a mutation
02:10:57 <ski> you don't want a combined 'acc' function ?
02:11:14 <Taral> t is the piece I took off
02:11:25 <Taral> a is the identification of the piece we're removing
02:11:38 <Taral> b is the reconstructed object
02:11:40 <Taral> c is the original object
02:12:43 <Cale> ah, okay
02:13:16 <ski> i'd convert the downwards state into upwards state, at end of list
02:13:42 <MarcWeber> I want to run frag. I get this error: a.out: user error (unknown OpenGL call glGenBuffersARB, check for GL_ARB_vertex_buffer_object or OpenGL 1.5).
02:13:47 <ski> Taral : btw, this kind of things can be made with attribute grammars, more easily, i believe
02:14:57 <MarcWeber> fglrxinfo tells me: OpenGL version string: 1.2 (1.5 Mesa 6.2.1) Does this mean that I have OpenGL 1.5 as needed?
02:15:33 <Taral> oops, small bug in foldlr
02:15:34 <Taral> :)
02:15:41 <Taral> foldlr :: (a -> t -> b -> b) -> (a -> c -> (t, c)) -> c -> b -> [a] -> b
02:15:41 <Taral> foldlr _ _ _ n [] = n
02:15:41 <Taral> foldlr accL accR a n (x:xs) =
02:15:41 <Taral>     let (t, a') = accR x a
02:15:41 <Taral>     in accL x t $ foldlr accL accR a' n xs
02:15:46 <Taral> accL needs the a
02:16:02 <pesco> Good morning, #haskell!
02:16:21 <Taral> what are attribute grammars?
02:16:29 <Cale> Taral: sure that it can't be done in two "passes"?
02:16:38 <Taral> Cale: Sure, but not as efficiently.
02:16:42 <Cale> why not?
02:16:57 <Taral> I could do something like compose . map mutate . decompose
02:17:07 <Cale> yeah
02:18:09 <Taral> but decompose looks something like "unfoldr (\a -> <something with the detach layer function>)"
02:18:19 <Cale> that seems like a saner approach to me, and it shouldn't cost any more assuming that you write decompose such that it produces lazily, and compose such that it consumes lazily
02:18:36 <Taral> foldlr is a bit insane
02:18:55 <ski> @google UUAG haskell attribute
02:18:57 <lambdabot> http://www.cs.uu.nl/people/arthurb/ag.html
02:19:11 <Taral> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
02:19:34 <Taral> no idea what the idea is.
02:19:44 <ski> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
02:19:48 <ski> yes
02:20:25 <ski> it's a way of writing tree traversals and transformers in a nice way
02:20:38 <Taral> @hoogle unfoldr
02:20:40 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
02:20:42 <ski> should i explain the basics ?
02:20:52 <Taral> I think I've seen something like it?
02:20:59 <Taral> ANTLR's tree parsers looked like this.
02:22:12 <Taral> okay, decompose is...
02:22:12 <Taral> unfoldr (\(n, m) -> if n == 10 then Nothing else let (b, m') = peelMap n m in Ju
02:22:12 <Taral> st (b, (n + 1, m'))) (1, m)
02:22:13 <Taral> ew
02:22:25 <Taral> :(
02:22:39 <musasabi> joelr1: that other STM paper looks very nice.
02:23:00 <joelr1> musasabi: it's in Word. strange :-) i did not look at it yet, though
02:23:17 <joelr1> does not look like it will help with my current set of problems
02:23:59 <Cale> heh, yeah, I opened it in openoffice and converted it to pdf before reading it :)
02:24:11 <joelr1> musasabi: i just posted some statistics to cafe, btw
02:24:25 <Cale> It's silly that he doesn't provide a postscript or pdf version
02:24:53 * musasabi is reading it at the moment and it seems quite practically oriented
02:25:04 <Cale> it's very practically oriented
02:25:23 <Cale> It doesn't quite get around to implementing too many different structures though
02:25:31 <musasabi> joelr1: as for the block or not thing - where does the exception come to wreck the checker-thread?
02:26:05 <musasabi> I think I should push the patch containing documentation for Control.Concurrent.STM.*
02:26:38 <joelr1> musasabi: what about the patch? also, i modified the checkTiemrs fun
02:26:56 <joelr1> so i'm no longer blocking exceptions and ignoring those from the timer IO
02:27:05 <joelr1> i.e. the action that runs when the timer expires
02:27:11 <joelr1> posted to cafe
02:27:13 <joelr1> take a look
02:27:42 <Taral> okay
02:27:51 <Taral> the new version is a foldr ... $ unfoldr ...
02:28:26 <Cale> Taral: take 10?
02:28:33 <musasabi> joelr1: do most timers fire or are the most cancelled?
02:28:35 <Taral> with two levels of pair consing
02:28:40 <Cale> oh
02:28:45 <Cale> no, you can't quite do that
02:28:55 <Taral> take 10? No. :) I just used [1..9]
02:28:59 <Taral> rebuildMap f m =
02:28:59 <Taral>     let dstep ([], _) = Nothing
02:28:59 <Taral>         dstep (n:ns, m1) =
02:28:59 <Taral>             let (b, m2) = peelMap n m1
02:28:59 <Taral>             in Just ((n, f b), (ns, m2))
02:28:59 <Taral>         acc (n, b) a = zipWith (zipWith (\me ae -> if me then n:ae else ae)) b a
02:29:01 <Taral>         nullAcc = replicate 9 (replicate 9 [])
02:29:03 <Taral>     in foldr acc nullAcc $ unfoldr dstep ([1..9], m)
02:29:06 <joelr1> musasabi: can't say, really. it depends. 
02:29:09 <Taral> (that's the longest paste I'll do in channel, btw)
02:29:23 <joelr1> musasabi: the keep alive timers expire, the other ones should be cancelled mostly
02:30:10 <Cale> Taral: what is this code a part of?
02:30:17 <Taral> sudoku solver :)
02:30:18 <musasabi> joelr1: can you think of a percent of timers that expire? (it can be +-20% of the real thing)
02:30:26 <Cale> Taral: hehe
02:30:28 <Taral> :)
02:30:31 <musasabi> just to get a clear picture.
02:30:42 <Cale> hmm
02:30:43 <Taral> I like my rebox function
02:30:48 <Taral> rebox s = concatMap (map concat . transpose . map split3) $ split3 s
02:31:01 <Taral> does boxes <-> rows
02:31:03 <Cale> split3?
02:31:05 <Cale> oh
02:31:19 <Taral> split3 [1,2,3,4,5,6,7,8,9] = [[1,2,3],[4,5,6],[7,8,9]
02:31:20 <Taral> ]
02:31:36 <musasabi> (and are we talking about 10 or 20000 concurrent timers)
02:31:55 <musasabi> otherwise we are going to be optimizing the wrong place.
02:32:17 <joelr1> musasabi: lets see... 4k bots that's 4k timers. plus additional timers that start and expire for some bot ops.
02:32:33 <Cale> Taral: is it a moderately "natural" solver, or is it nondeterministic?
02:32:40 <joelr1> musasabi: for example, when i try to go to the lobby i start a timer and kill it as soon as i'm connected
02:33:09 <joelr1> so i would say 4k expiring timers and maybe 4k x 2/3 more that are killed
02:33:21 <joelr1> so it's something like 18k timers :D
02:33:26 <joelr1> at most
02:33:46 <joelr1> no, 16k of which 1/4 are expiring
02:33:53 <joelr1> and the rest are killed 
02:34:25 <musasabi> So you have a 16k element map on which 3/4 of the operations are O(n=16k)
02:35:08 <joelr1> musasabi: damn, the map is gonna be huge :( and i just realized that the way i do timers will no be wrong :( i will need to key them on thread id or better yet return a timer id instead
02:35:21 <joelr1> musasabi: what do you suggest?
02:35:29 <Taral> Cale: It's natural.
02:35:38 <Taral> svrepeat can solve most (if not all) easy/medium problems
02:36:39 <Taral> svrepeat + applySingle can solve most hard problems
02:36:49 <Taral> applyDouble is used for very hard problems
02:37:05 <joelr1> musasabi: i'm open to suggestions
02:37:19 <Taral> I'm working on the planeLines solver
02:37:24 <Cale> http://www.menneske.no/sudoku/eng/index.html has a good collection of problems
02:37:35 <Taral> I'm just pulling problems from websudoku.com
02:37:42 <Taral> it's infinite problems!
02:37:43 <araujo> Hello!
02:38:02 <Taral> I also plan to put in the 2sat solver at some point, to see how effective it is.
02:38:12 <Cale> menneske has them categorised by difficulty and symmetry, and for the easier ones, lists methods needed to solve them.
02:38:21 <musasabi> joelr1: I would optimize for killing of the timeouts.
02:38:32 <joelr1> how?
02:38:47 <musasabi> joelr1: also consider the IORef vs getClockTime thing.
02:39:34 <Cale> http://www.menneske.no/sudoku/irr/4x4/eng/ -- heh, irregular box sizes
02:40:36 <musasabi> joelr1: e.g. if your timeouts are > 5 seconds create a lobby where new timeouts are in a list. (with a timeout being "(Time,IORef (Maybe (IO ())))" and check whether they have been already killed before entrance into the main Map.
02:40:49 <musasabi> joelr1: also you can make killings through the IORefs...
02:41:48 <joelr1> hmm
02:42:00 <musasabi> newtype TimeOutRef = TOR (IORef (Maybe (IO ()))); killTimeOut (TOR x) = writeIORef x Nothing
02:42:04 <joelr1> musasabi: the timeouts are always at least 60 seconds
02:42:22 <musasabi> joelr1: thus having a waiting lobby makes sense.
02:42:32 <joelr1> musasabi: i do not know what a waiting lobby is
02:42:57 <joelr1> also, using IORef / MVar would buy me not having to modify the map, right?
02:43:16 <joelr1> but it's gonna grow huge eventually
02:43:25 <musasabi> yes. (IORef is slightly cheaper, but you have to be carefull what you do)
02:43:27 <joelr1> because the timers that are killed are then restarted
02:43:51 <joelr1> i guess i need to look into recycling timers somehow
02:43:54 <musasabi> joelr1: If I were you I would read up some literature on priority queues.
02:44:14 <joelr1> maybe i should index the timers on both thread id and name and not remove them from the map
02:44:32 <musasabi> joelr1: they have the exact same problems you are strugling with
02:44:34 <joelr1> then, once the time is restarted, i would just replace the IO action
02:44:48 <joelr1> priority queues, hmm
02:44:57 <musasabi> well it is a priority queue.
02:45:05 <joelr1> musasabi: how so?
02:45:13 <musasabi> timer name = key name, time out value = priority.
02:46:44 <musasabi> and operations like: findMin, deleteMin, add, deleteWithKey, updateWithKey
02:47:37 <joelr1> musasabi: right
02:47:45 <joelr1> are there any priority queues for haskell?
02:49:21 <musasabi> There is some code, and Data.Map works where the queue is small (<1k) or the range of operations limited (no WithKey operations), but I don't remember a good open source code for that.
02:51:10 <joelr1> musasabi: how about this
02:51:25 <joelr1> musasabi: how about just using a TChan for timers?
02:51:32 <joelr1> argth
02:51:42 <joelr1> no, you cannot remove them then :( so much for an idea
02:51:49 <wilx> Heh.
02:51:54 <wilx> What about heap based PQ?
02:52:02 <wilx> In IOArray or something?
02:52:04 <joelr1> do you have any code?
02:52:15 <joelr1> how would IOArray help?
02:52:15 <musasabi> PQs are in most algorithmics book
02:52:23 <musasabi> *books
02:52:48 <wilx> Random access that you basically need for the heap iirc.
02:53:16 <joelr1> hmm
02:54:30 <joelr1> for now i think i will just add a thread id to the name in the key and then use Maybe (IO ()) for the value as musasabi suggested
02:54:49 <joelr1> there will be no deletions from the map then
02:56:30 <joelr1> and possibly two maps, where one maps from (ThreadId, String) to action and another one maps from ClockTime to (ThreadId, String) ... well, this won't change a lot since I would then filter two maps :(
02:56:36 <joelr1> reading up on priority queues
02:59:35 <musasabi> another idea is to have, "newtype TimerRef = TR (ClockTime,Int)", index the map by that and return the key, so that is used in the kill operation which thus becomes O(log n)
03:00:09 <musasabi> the Int is there to make sure your operations will have an unique key even if they have the same time.
03:00:30 <joelr1> musasabi: i could use the ThreadId for that
03:00:52 <joelr1> right?
03:00:53 <dcoutts> @seen Lemmih
03:00:54 <lambdabot> Last time I saw Lemmih was when I left #flippi, #gentoo-haskell, #haskell,
03:00:54 <lambdabot> #haskell', #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and
03:00:54 <lambdabot> #scannedinavian 10 hours, 29 minutes and 10 seconds ago, and I have
03:00:54 <lambdabot> missed 46 minutes and 36 seconds since then.
03:01:04 <musasabi> joelr1: the same having multiple timeouts would screw things up.
03:01:24 <joelr1> musasabi: i meant thread id instead of the int
03:01:27 <musasabi> joelr1: also if you are evil you can make your times evil.
03:01:33 <joelr1> (ClockTime, ThreadId)
03:01:37 <musasabi> let me show the code for that.
03:01:50 * musasabi has "uniquely increasing cheap time" lying around
03:02:52 <joelr1> musasabi: suppose i'm using ints instead of name 
03:03:02 <joelr1> how does that make killing timers cheap?
03:03:18 <joelr1> i would need a separate global counter or something then
03:03:39 <joelr1> maybe a Int that wraps around
03:03:52 <joelr1> cheaper than name + thread id
03:04:02 <musasabi> joelr1: 5min till I have a paste
03:04:04 <joelr1> but i do not see how that improves kill times and speeds up the lookup
03:05:00 <joelr1> i just found a priority queues paper by ralf hinze
03:11:47 <musasabi> http://youzen.b2.fi/~musasabi/time.hs
03:12:04 <joelr1> looking
03:12:22 <musasabi> joelr1: now you can use the Time obtained when installing a timeout to kill it.
03:12:50 <musasabi> this code is complementary to other things
03:13:28 <joelr1> so i would use time from TimeSource, right?
03:13:33 <joelr1> instead of ClockTime 
03:13:38 <joelr1> to index the timer map
03:14:12 <musasabi> yes, and kill the threads with the time not the name. Of course you can do the same with ClockTime too
03:14:48 <joelr1> hmm
03:15:08 <joelr1> wait, but i can achieve the same effect by returning ClockTime, Int as the timer id, right?
03:15:16 <joelr1> is your approach cheaper?
03:16:19 <musasabi> joelr1: it was cheaper for me in a very specific context, but depends on your code which one is better.
03:16:39 <musasabi> and your OS and such things.
03:16:40 <joelr1> musasabi: thinking... 
03:17:04 <joelr1> you are calling getClockTime every second whereas I'm calling it as needed... i think
03:17:08 <joelr1> only when you start the timer
03:17:29 * araujo cracking his head again with CT
03:19:05 <Taral> omg
03:19:12 <Taral> someone tell me where I can find a 2sat solver
03:19:27 <Taral> or how to write one :)
03:20:35 <musasabi> joelr1: I am calling it once every second. (my code was calling it some 300times / second and I didn't like that very much)
03:21:09 <joelr1> ok
03:21:28 <joelr1> musasabi: i'm gonna steal some of your ideas then and post an updated implementation that uses ClockTime, Int as key
03:21:33 <joelr1> musasabi: that idea completely rules!
03:24:53 <sieni> Taral: if you google for 2sat, then the first link (powewpoint slideshow)-: gives you a polynomial time algorithm
03:24:58 <musasabi> :-)
03:37:59 <Taral> sieni: oh?
03:38:01 <Taral> @google 2sat
03:38:02 <lambdabot> http://www.cs.tau.ac.il/~safra/Complexity/2SAT.ppt
03:38:13 <Taral> I got one based on resolution
03:39:41 <boegel> can someone explain (or show) me when the sets of axis are othogonal to eachother ?
03:40:42 <Cale> boegel: hm?
03:41:25 <Taral> is there a list function like nub . sort, but faster?
03:42:01 <tromp_> sort -u :)
03:42:16 <Taral> hm, maybe head . group . sort
03:43:00 <tromp_> you mean map head . group . sort
03:49:46 <tibbe> hmmm, Data.Map.lookup returns its value in a monad, how to get it out? do I even have to?
03:49:56 <tibbe> @type Data.Map.lookup
03:49:58 <lambdabot> forall a (m :: * -> *) k.
03:49:58 <lambdabot> (Ord k, Monad m) =>
03:49:58 <lambdabot> k -> Data.Map.Map k a -> m a
03:51:21 <ski> case lookup k m of Nothing -> ... ; Just v -> ...
03:52:32 <ski> (wouldn't it be better if that used MonadZero, btw ?)
03:53:04 <Cale> MonadZero no longer exists
03:53:10 <ski> know ..
03:53:12 <Cale> (though I wish it did)
03:53:33 <Cale> Things which need failure should probably use MonadPlus for the time being
03:53:50 <ski> how about that 'lookup' above ?
03:54:12 <Cale> hmm, yeah
03:54:24 <ski> (iirc it uses 'fail' for failure)
03:54:28 <Cale> ugh
03:54:32 <ski> indeed
03:54:40 <ski> 'fail' is ugly
03:54:40 <Cale> Maybe would be better
03:54:44 <Cale> it is
03:54:56 <Cale> do-notation should simply check to see if the monad is a MonadZero
03:55:05 <ski> yes
03:55:10 <Cale> and implement pattern match failure specially in that case
03:55:10 <ski> like with arrow notation
03:55:41 <Cale> How do we get these things changed?
03:56:06 <Cale> complain lots on the mailing lists? :)
03:56:13 <ski> prod the demigods ?
03:56:30 <ski> come up with a suggestion for replacement
03:56:37 <Cale> MonadZero is a very useful concept
03:56:52 <ski> possibly even a working impl/patch which does this ..
03:57:00 <Cale> hmm
03:57:06 <Taral> YAY
03:57:10 <Taral> *TwoSat> run test
03:57:10 <Taral> [("dz",False)]
03:57:14 <Cale> I'm somewhat frightened of the GHC code though :)
03:57:22 <ski> hm, how many cases of MonadZero, but not MonadPlus, can you think of ?
03:57:49 <ski> (btw, the MonadError is a bit ugly, too)
03:57:51 <Cale> ski: depends on what you consider to be in MonadPlus
03:57:52 <Speck> control-operation-like stuff?
03:58:03 <Cale> But regardless
03:58:08 <tibbe> so why is the type variable m if it is a specific monad?
03:58:15 <ski> yes .. someone should work out what laws should hold
03:58:24 <ski> tibbe : it's polymorphic
03:58:41 <Cale> There should be a distinction just so that functions which want to return values typed in a monad with failure will have an option.
03:58:47 <ski> tibbe : in my case, i instantiated it to the Maybe monad
03:59:07 <ski> yes
03:59:07 <Cale> It's silly to assume that a monad will have a natural failure mechanism
03:59:27 <Cale> There are so many instances of 'fail' which simply crash the program.
03:59:43 <ski> i sortof understand the rationale for 'fail'
03:59:45 <Cale> (well, throw an exception, anyway)
03:59:52 <ski> maybe one could move 'fail' into another class .. hm
04:00:10 <Cale> fail should be mzero
04:00:26 <ski> but in Maybe, we wan't mzero .. fail is not useful there
04:00:29 <Cale> I suppose there's that string
04:00:51 <Cale> If you want to keep the string, then you'll need some extra MonadError or something
04:01:13 <tibbe> so I could do: do b <- lookup k map; case b of Nothing -> _whatever_; Just value -> value ?
04:01:15 <ski> stuff like 'do [x,y] <- foo; Just (x,y)' could be useful, though
04:02:02 <Cale> ski: list is a MonadZero
04:02:03 <ski> tibbe : yes .. though i think you at least have to s/-> value/-> return value/ (unless the value is a monadic action, in your monad)
04:02:06 <Cale> er
04:02:10 <Cale> yeah
04:02:13 <Cale> so that's fine
04:02:19 <ski> tibbe : er  .. you prolly want that 'lookup' in let or where
04:02:50 <Cale> do b <- lookup k mymap; foo b
04:03:01 <ski> yes ..
04:03:06 <Cale> or even just   return (foo b)
04:03:08 <ski> tibbe : are you in a monad ?
04:03:13 <Cale> that's in the Maybe monad
04:03:18 <tibbe> ski, actuallt I already know that the value exists (checked using member) and I only want it out and the rest of the code is non-monadic. so I'll have to go through the hassle of running the monad just to get the value?
04:03:18 <Cale> (or similar)
04:03:22 <tibbe> ski, no
04:03:41 <ski> tibbe : then don't use 'do' :)
04:03:42 <tibbe> that really sucks
04:03:49 <Cale> tibbe: hm?
04:03:59 <ski> case lookup k map of Nothing -> _whatever_; Just value -> value
04:04:02 <Cale> tibbe: Maybe is a monad, you can just pattern match if you like
04:04:03 <ski> or even
04:04:09 <tibbe> is like having to catch exception that can't be thrown
04:04:18 <Cale> fromJust
04:04:20 <ski> maybe _whatever_ id (lookup k map)
04:04:22 <Cale> @type fromJust
04:04:24 <lambdabot> Not in scope: `fromJust'
04:04:29 <Cale> @type Data.Maybe.fromJust
04:04:31 <lambdabot> forall a. Maybe a -> a
04:04:32 <ski> er, yes, fromJust, too
04:04:38 <Cale> > fromJust Nothing
04:04:40 <lambdabot> Add a type signature
04:04:42 <Cale> > fromJust Nothing :: Int
04:04:44 <lambdabot> Exception: Maybe.fromJust: Nothing
04:04:48 <Cale> > fromJust (Just 5) :: Int
04:04:50 <lambdabot> 5
04:04:59 <ski> tibbe : when do you check with member ?
04:05:15 <Speck> it might be nice to have a kind of try function that takes a monadzero do block, which branches on failure
04:05:23 <ski> tibbe : possibly you could replace the member call with a lookup call ?
04:05:27 <tibbe> ski, right before, I've got a stack of maps and I want to continue searching downwards if the elem doesn't exist
04:05:42 <Cale> Speck: hm?
04:06:00 <Speck> try $ do ...
04:06:01 <ski> Speck : isn't that 'mplus' ?
04:06:05 <tibbe> lookupStack _ []         = Nothing
04:06:05 <tibbe> lookupStack var (xs:xss) =
04:06:05 <tibbe>     case Map.member var xs of
04:06:05 <tibbe>                            True  -> Map.lookup var xs
04:06:05 <tibbe>                            False -> lookupStack var xss
04:06:15 <Speck> maybe I'm confusing the two
04:06:21 <Speck> or just confused in general
04:06:23 <Cale> Speck: I think you're assuming a MonadPlus, yeah
04:06:30 <tibbe> so I'll just add a fromJust before the lookup?
04:06:36 <Cale> and mplus does what you want in that case, I think
04:06:47 <Cale> > (Just 5) `mplus` (Just 7)
04:06:48 <lambdabot> Just 5
04:06:55 <Cale> > mzero `mplus` (Just 7)
04:06:56 <lambdabot> Just 7
04:07:12 <ski> lookupStack var (xs:xss) = case Map.lookup var xs of
04:07:13 <tibbe> > (Data.Map.singleton 1)
04:07:14 <lambdabot>  Not in scope: `Data.Map.singleton'
04:07:21 <ski>   Nothing -> lookupStack var xss
04:07:28 <ski>   Just val -> val
04:07:34 <tibbe> > (Data.Map.singleton "a" 1)
04:07:35 <lambdabot>  Not in scope: `Data.Map.singleton'
04:07:45 <ski> tibbe : how about something like that ?
04:07:54 <tibbe> ski, I'll give it a try
04:08:15 <Cale> > M.singleton "a" 1
04:08:17 <lambdabot> {"a":=1}
04:08:19 <Cale> aha
04:08:21 <ski> hm
04:08:22 <tibbe> heh
04:08:26 <Cale> It's imported strangely
04:08:39 <ski> tibbe : do you want lookupStack to return a maybe, or not ?
04:09:15 <Speck> hmm, there could be a nice syntax for MonadPlus-style branching in do notations. It would be nice for the STM monad I think.
04:09:50 <Cale> Speck: hmm
04:09:52 <tibbe> ski, yes, a Maybe
04:10:19 <Speck> try $ do ... else ...
04:10:33 <tibbe> > fromJust (M.lookup (M.singleton "a" 1))
04:10:34 <lambdabot>   Expecting a function type, but found `Maybe a'
04:10:34 <lambdabot>   Expected type: Maybe a
04:10:34 <lambdabot>   Inferred type: Data.Map.Map k a1 -> m a1
04:10:35 <ski> @type let lookupStack var = msum . map (Map.lookup var) in lookupStack
04:10:37 <lambdabot> Couldn't find qualified module.
04:10:37 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
04:10:37 <lambdabot> \\)?
04:10:41 <ski> @type let lookupStack var = msum . map (M.lookup var) in lookupStack
04:10:43 <lambdabot> Couldn't find qualified module.
04:10:43 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
04:10:43 <lambdabot> \\)?
04:10:45 <Cale> well, you wouldn't need the $ if it was syntax :)
04:10:45 <tibbe> > fromJust (M.lookup "a" (M.singleton "a" 1))
04:10:47 <lambdabot> 1
04:10:50 <Cale> I wish that there was a standard function of type (MonadPlus) => [a] -> m a
04:10:51 <ski> hm
04:10:52 <Speck> Cale: true
04:10:58 <Cale> er
04:11:02 <Cale> (MonadPlus m) => [a] -> m a
04:11:20 <ski> @type let lookupStack var = msum . map (Data.Map.lookup var) in lookupStack
04:11:22 <lambdabot> Not in scope: `msum'
04:11:30 <ski> @type let lookupStack var = Control.Monad.msum . map (Data.Map.lookup var) in lookupStack
04:11:30 <Cale> @type  msum . map return
04:11:32 <lambdabot> forall k a (m :: * -> *).
04:11:32 <lambdabot> (Ord k, Control.Monad.MonadPlus m) =>
04:11:32 <lambdabot> k -> [Data.Map.Map k a] -> m a
04:11:32 <lambdabot> Not in scope: `msum'
04:11:38 <Cale> @type  Control.Monad.msum . map return
04:11:40 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [a] -> m a
04:11:47 <Cale> that ought to have a name
04:11:48 <ski> tibbe : hm, would that work ?
04:11:58 <Speck> Cale: how would you use it?
04:12:18 <Cale> Speck: It's very useful in nondeterminism monads
04:12:28 <ski> @type foldr mplus mzero
04:12:29 <lambdabot> Not in scope: `mplus'
04:12:29 <lambdabot>  
04:12:29 <lambdabot> <interactive>:1:12: Not in scope: `mzero'
04:12:38 <tibbe> ski, the first thing with the case worked I think
04:12:42 <Cale> basically it represents choosing between one of the values in the list you give it
04:12:43 <ski> @type foldr Control.Monad.mplus Control.Monad.mzero
04:12:45 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => [m a] -> m
04:12:45 <lambdabot> a
04:13:02 <Speck> Cale: ah
04:13:07 <ski> tibbe : was just thinking you could do it simpler
04:13:09 <Cale> in the list monad, it's just the identity
04:13:15 <Cale> in maybe, it's just head
04:13:18 <Cale> well
04:13:32 <Cale> Just . head
04:13:34 <tibbe> ski, I'm switching data structure in a module so it doesn't compile yet (it was [[(k,v)]] before
04:13:34 <tibbe> ski, which one was simpler, got lost in the lambdabot output
04:13:38 <Cale> sort of
04:13:46 <tibbe> ski, so the Maybe monad has plus and zero right?
04:13:56 <ski> tibbe : lookupStack var = Control.Monad.msum . map (Data.Map.lookup var)
04:14:01 <Cale> in other nondet monads, it's more interesting
04:14:08 <ski> tibbe : yes ..
04:15:01 <Cale> heh, typing "nondet monad" into firefox's address bar gives http://haskell.org/hawiki/NonDeterminism
04:15:18 <ski> Cale : isn't that the unique morphism from initial object in category of monads with zero or plus (or something like that :) ?
04:15:39 <Cale> ski: probably :)
04:15:45 <Cale> List seems pretty initial
04:16:04 <Cale> or perhaps I should say "universal"
04:17:36 <ski> (why ?)
04:17:58 <Cale> Well, I suppose it depends on the properties of mplus and mzero
04:18:06 <ski> m .. right
04:18:14 <Cale> If you insist that mplus and mzero turn the thing into a monoid...
04:18:23 <ski> possibly we need MonadPlus and MonadElse
04:18:42 <Cale> Which one's the real one? :)
04:18:48 <ski> both
04:18:49 <Cale> ah
04:18:54 <Cale> yeah, I see what you mean
04:19:05 <ski> Maybe would be MonadElse, but not MonadPlus, iirc
04:19:09 <Cale> right
04:19:36 <Cale> yeah, and we can call the MonadElse operation orElse, which unifies nicely with STM
04:19:41 <Speck> Cale: did you just add option to NonDeterminism?
04:19:48 <Cale> not recently
04:19:52 <ski> think there's some note on hawiki on this ..
04:19:59 <ski> s/note/notes/
04:20:05 <Speck> ah, so you have an agenda ;-)
04:20:08 <Cale> ski: I remember seeing something about it too
04:20:17 <ski> Speck : hehe
04:20:20 <Cale> Speck: I'm just bringing up old points
04:20:40 <Cale> I really wish that it was easier to contribute to the libraries :)
04:20:58 <Speck> I think your swing combinator should be in prelude
04:21:01 * Cale crosses his fingers about darcs
04:21:04 <Cale> Speck: :)
04:21:13 <Speck> it's so funky
04:21:23 <Cale> Personally, I miss 'comparing' most often
04:21:30 <Cale> and it's so simple :)
04:21:46 <Cale> comparing p x y = compare (p x) (p y)
04:21:56 <Cale> sortBy (comparing snd)
04:21:59 <Cale> etc.
04:22:33 <Cale> apparently they were/are going to add Data.Ord and put it there
04:23:38 <ski> ing foo p x y = foo (p x) (p y)
04:23:43 <Speck> hmm, I wonder how I could use combinationsM
04:23:55 <Cale> ski: hehe
04:24:13 <Speck> make it postfix
04:24:42 <Cale> sortBy (compare `ing` snd)
04:24:57 <Speck> ah perfect
04:25:06 <Speck> I like it
04:25:21 <Cale> Maybe just a little too general for this :)
04:25:39 <cpatrick> it's cute though
04:25:42 <Cale> yeah
04:25:56 <cpatrick> I really need to get my mind in the habit of coming up with wacky combinators like that
04:25:59 <Cale> otoh, I'm pushing generality everywhere else
04:26:34 <Cale> also, I don't see any good reason why there aren't more basic, everyday things in Data.List
04:26:48 <Cale> like combinations, permutations, etc.
04:27:27 <Cale> I think I saw a Haskell 1.3 Prelude or List library somewhere and it had them
04:29:27 <cpatrick> yeah. I'd like to see some nice built-in thingies for tuples too
04:29:45 <Cale> swap maybe?
04:29:51 <Cale> or is that there?
04:29:53 <cpatrick> like mapTuple f (a, b) = (f a, f b)
04:29:57 <Cale> ah
04:30:06 <cpatrick> swap would also be handy, yeah
04:30:45 <Cale> well, there should be fmap f (x,y) = (x, f y)
04:31:33 <Cale> pair f g (x,y) = (f x, g y), though that's taken care of by Arrow stuff
04:32:08 <cpatrick> fmap?
04:32:13 * cpatrick doesn't see how that works
04:32:35 <Cale> @type fmap
04:32:37 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
04:32:38 <ski> Functor ((,) a)
04:32:59 <cpatrick> ghci says
04:32:59 <cpatrick> <interactive>:1:0: No instance for (Functor ((,) a))
04:33:02 <Cale> right
04:33:07 <Cale> that's because there isn't
04:33:47 <cpatrick> hmm, never knew that the , operator could be used as a function either
04:33:47 <Cale> instance Functor ((,) a) where fmap f (x,y) = (x, f y)
04:33:59 <Cale> > (,) 2 5
04:34:01 <lambdabot> (2,5)
04:34:11 <Cale> hmm
04:34:13 <cpatrick> > (,) ((,) 1 2) 3
04:34:14 <lambdabot> ((1,2),3)
04:34:15 <Cale> > (2,) 5
04:34:16 <lambdabot>  parse error on input `)'
04:34:20 <Cale> nope :)
04:34:25 <Cale> that would be cute
04:34:32 <Cale> > (,5) 2
04:34:33 <lambdabot>  parse error on input `5'
04:34:35 <cpatrick> mm
04:34:48 <Cale> Not sure if that's really desirable :)
04:35:01 <Cale> > (,,) 1 2 3
04:35:03 <lambdabot> (1,2,3)
04:35:34 <Cale> > [1,2,3] :: [] Integer
04:35:35 <lambdabot> [1,2,3]
04:35:36 <cpatrick> @type (,,,)
04:35:37 <lambdabot> forall d c b a. a -> b -> c -> d -> (a, b, c, d)
04:35:46 <Cale> @type (,,,,,,,,,,,)
04:35:48 <lambdabot> forall l k j i h g f e d c b a.
04:35:48 <lambdabot> -> b
04:35:48 <lambdabot> -> c
04:35:48 <lambdabot> -> d
04:35:48 <lambdabot> -> e
04:35:49 <lambdabot> [8 @more lines]
04:36:35 <cpatrick> wacky
04:36:47 <Cale> I sometimes think that larger tuples ought to just be syntax sugar for nested pairs
04:37:04 <cpatrick> does that forall mean an existensial type htingy?
04:37:17 <Cale> (though there is constructor overhead)
04:37:18 <cpatrick> maybe
04:37:24 <Cale> cpatrick: not in this case
04:37:56 <Cale> every type signature in Haskell (98) is implicitly forall quantified
04:38:23 <Cale> When you write  a -> b -> (a,b), you really mean forall a b. a -> b -> (a,b)
04:38:41 <Cale> That is, the function applies for any assignment of types to those variables.
04:38:54 <ski> when you say
04:39:02 <arjanb> n-tuples not being nested pairs is annoying when writing class instances for them
04:39:14 <cpatrick> yeah. but then ghc seems to use forall to mean \exists, I haven't quite got my head around that
04:39:15 <ski> data SomeShowable = forall x. Show x => SS x
04:39:18 <ski> that means
04:39:26 <Cale> cpatrick: yes, in some stupid cases :)
04:39:32 <ski> SS :: forall x. Show x => x -> SomeShowable
04:39:45 <ski> that's the reson for 'forall' in existential datatypes
04:39:57 <ski> s/reson/reason/
04:40:35 <ski> forall x. Show x => x -> SomeShowable   ~=   (exists x. Show *> x) -> SomeShowable
04:40:40 <ski> unSS (SS x) = x
04:40:49 <ski> unSS :: SomeShowable -> exists x. Show *> x
04:41:01 <ski> but, that's not allowed
04:41:04 <cpatrick> the other thing I bumped into when trying to use existential types the other day
04:41:10 <cpatrick> was a compiler error saying "My brain just exploded"
04:41:15 <Cale> yeah
04:41:19 <cpatrick> which struck me as very appropriate :)
04:41:44 <Cale> it does that when you try to derive certain things for existential types
04:42:03 <cpatrick> in my case I needed to change a let pattern into a case pattern
04:42:11 <cpatrick> which makes me wonder what the semantic difference between the two was
04:43:54 <Cale> ski: Is this equivalent? forall x. Show x => x -> SomeShowable ~= (exists x. Show x => x) -> SomeShowable
04:44:47 <Cale> hmm, let has effects with respect to polymorphism
04:44:59 <Cale> which may react poorly with existentials, I don't know
04:45:44 <Cale> when you have a let-bound value with a polymorphic type, you're allowed to instantiate that polymorphic type in multiple ways in the 'in' portion of the let.
04:46:29 <Cale> for instance
04:46:59 <Cale> > let i x = x in (i 5, i "Hello")
04:47:00 <lambdabot> (5,"Hello")
04:47:46 <cpatrick> ahh righty, never knew you were allowed to do that
04:47:50 <Cale> Note that it didn't go inferring that i :: String -> String or anything like that and complaining about types not matching
04:47:59 <cpatrick> yes
04:48:38 <Cale> I have no idea how that interacts with existential types. :)
04:48:41 <ski> Cale : no
04:48:49 <ski> Cale : i said '*>' not '=>'
04:48:56 <Cale> yeah, I know
04:49:06 <ski> Mercury has '*>' (other syntax)
04:49:08 <cpatrick> what is *> ??
04:49:24 <Cale> ski: Is the "isomorphism" I gave valid?
04:49:31 <ski> 'exists x. Show x => x' is the type of things of some type 'x' such that 'Show x'
04:49:47 <ski> Cale : invalid
04:49:50 <Cale> okay
04:50:14 <ski> you need to invert '=>' into '*>' when inverting 'forall' into 'exists', there
04:50:14 <Cale> hmm
04:50:49 <ski> if you think of '=>' as implies or function arrow, then think of '*>' as conjunction or product type
04:51:09 <Cale> Or perhaps a reverse implication?
04:51:21 <ski> no
04:51:21 <Cale> er
04:51:22 <Cale> hmm
04:51:33 <Cale> no, that's not equivalent to what you're saying
04:51:35 <ski> forall a. Foo a => a -> T  ~=  forall a. (Foo a *> a) -> T
04:51:51 <ski> it's just (un/)currying :)
04:52:35 <Cale> hmm
04:52:40 <Cale> I see
04:52:44 <ski> a value of type 'Foo a *> a' is a value of the type 'a', together with a witness of 'Foo a'
04:53:14 <Cale> yeah
04:53:26 <Cale> Why use such a strange symbol for it, btw?
04:53:33 <Cale> why not & ?
04:54:01 <Cale> just convention?
04:56:16 <Cale> If we're going with the types as theorems view :)
04:56:42 <Cale>  /\ would be good if it weren't already type lambda :)
04:58:00 <ski> '*>' is just syntax
04:58:10 <ski> there are possibly better syntax :)
04:58:24 <cpatrick> having /\ and \/ operators instead of && and || makes so much sense :)
04:58:33 <ski> maybe '&>'
04:58:59 <Cale> ski: I guess it's directed because of the proof types
04:59:15 <ski> Mercury uses the same symbol as for it's '=>', but reversed .. i'm not very happy about that syntax
04:59:23 <Cale> Sort of an odd situation that we have two kinds of truth.
04:59:38 <ski> Cale : yes, it should take constraints and a type as the two args, so it's assymetric
05:00:11 <Cale> I wonder if it's strictly necessary to make that distinction in the syntax
05:01:11 <Cale> If the required proof is an instance, then the function doesn't take it as a parameter.
05:01:26 <Cale> Might make for some mighty obfuscated code though :)
05:02:47 <Cale> I suppose at some level, you want to recognise (->) as a type constructor which takes two types, as that fact is sometimes really important (say, in making it an instance of some class)
05:03:44 <ski> yes
05:03:45 <ski> what do you mean with the 'If the ...' part ?
05:04:12 <Cale> Ord a -> a -> a -> Bool
05:04:23 <ski> explicit ?
05:04:27 <Cale> Make no distinction between different kinds of implication
05:04:37 <Cale> but that function still takes 2 parameters
05:05:00 <Cale> it's just that since the Ord a is an instance, the proof is already provided.
05:05:05 <ski> hm, Cayenne had Ord a |-> a -> a -> Bool
05:05:27 <ski> (and Agda provides a way to hide args)
05:05:44 <Cale> It might be nice to be able to pass proofs
05:05:48 <ski> yes
05:06:13 <Cale> but it may also break other things
05:06:15 <ski> though, sometimes, it's good to know that there can be at most one instance for any possible instance head
05:06:18 <Cale> yeah
05:06:30 <ski> like, e.g. if you're merging sets
05:06:36 <Cale> hehe
05:07:00 <ski> 'functors' in the MLs solve this in another way
05:07:12 <ski> (which can be sortof emulated in haskell, btw)
05:07:28 <Cale> I suppose that if you want explicit proof passing, it's there.
05:07:34 <Cale> It's just that there's nothing in between
05:07:48 <ski> right
05:08:07 <ski> i seem to recall something about 'coherence', wrt multiple instances
05:10:29 <ski> hm .. sometimes i believe that 'instance Eq a <= Eq [a]' would be better syntax
05:10:37 <ski> err
05:10:38 <xinming> http://www.nomaware.com/monads/examples/example12.hs
05:10:49 <xinming> for this example, why can't I compile it here?
05:10:53 <ski> 'class Eq a <= Ord a' i meant
05:11:21 <ski> Cale : since, 'a' being in 'Ord' implies 'a' being in 'Eq' ..
05:11:25 <Cale> right
05:12:03 <Cale> otoh, if you take the notation Eq a => Ord a not as implies, but superset, it makes sense :)
05:12:16 <Cale> stupid duality, heh
05:12:17 <ski> yes, it's evil confict
05:13:04 <ski> hm .. so maybe it boils down to bad syntax of implies wrt to syntax of superset ?
05:13:11 <Cale> xinming: I can't get there from here atm
05:13:33 <Cale> ski: well, normally, these are different symbols altogether
05:13:35 * ski neither
05:13:43 <Cale> really, the problem is ascii
05:13:52 <Cale> :)
05:14:19 <ski> Cale : hm, i guess i was thinking of the "reversed C" syntax for implication
05:15:22 <ski> (Cale : anyway, i seem to recall i had another argument for why the syntax in 'class' there is good .. but it can't recall it rn ..)
05:15:53 <ski> btw, Prolog uses '>=' for 'greater or equal'
05:16:06 <ski> (saner choice in ascii, imo=
05:16:12 <ski> s/=/)/
05:16:24 <Cale> )= ?
05:16:29 <Cale> oh
05:16:30 <Cale> hehe
05:16:37 <ski> m
05:16:46 <ski> '>=' and '=<'
05:16:57 <Cale> >= is normal
05:17:08 <ski> hm .. right
05:17:11 <Cale> =<, yeah that seems better
05:17:18 <Cale> since it saves an arrow
05:17:23 <Cale> :)
05:17:30 <ski> 'saves' ?
05:17:32 <ski> ah
05:17:33 <ski> right
05:17:45 <Cale> from being eaten :)
05:17:46 <Cale> hehe
05:17:55 <Cale> (excuse me, I've been up a while)
05:17:58 <ski> how'd you mean with '=>' and superset, then ?
05:18:00 * ski too :)
05:18:36 <Cale> the usual superset sign looks somewhat like a rounded > with a line underneath
05:18:50 <ski> yes
05:19:11 <ski> that alludes to (what is rendered in ascii as) '>='
05:19:24 <Cale> either way :)
05:19:26 <Cale> but yeah
05:19:28 <Cale> that's better
05:20:34 * ski 's trying to determine if '=>' in 'class' ought to be changed to '<=' (or flip order), or if there's an argument why not
05:20:39 <Cale> =< is sort of odd to type though, since it reads as 'equal to or less than' while you're typing it :)
05:20:56 <ski> just need to get used to it :)
05:21:44 <Cale> really, I wish everyone had a really nice comprehensive compose key setup
05:22:01 <Cale> with all the unicode symbols
05:22:16 <Cale> (all the mathematical ones, at least :)
05:22:21 <ski> (how about symbols with same or similar glyphs ?)
05:22:42 <Cale> actually, have you used TeXmacs?
05:22:47 <ski> njet
05:23:00 <Cale> try it sometime :)
05:23:08 <ski> da :)
05:23:34 <cpatrick> texmacs strikes me as an icky implementation of a neat idea
05:23:38 <Cale> It has some rather interesting keybindings in math mode
05:23:45 <tuomov> texmacs is quite nice in that it supports writing commands in the input stream
05:23:51 <tuomov> instead of mousing or cryptic key bindings
05:23:53 <cpatrick> Cale: it's Mathematica-like IIRC?
05:23:58 <Cale> @ makes a composition circle, @@ makes an infinity sign
05:23:59 <lambdabot> Maybe you meant: all-dicts arr babel botsnack choice-add code devils dice
05:23:59 <lambdabot> dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env djinn-ver
05:23:59 <lambdabot> docs dummy dynamic-load dynamic-reload dynamic-unload easton echo
05:23:59 <lambdabot> elements elite eurohaskell eval fact fact-cons fact-delete fact-set fact-
05:23:59 <lambdabot> snoc fact-update foldoc fortune gazetteer get-shapr ghc google help
05:24:01 <lambdabot> [8 @more lines]
05:24:02 <Cale> no, nothing like it :)
05:24:20 <cpatrick> oh. may be confusing it with something else then
05:24:41 <tuomov> iirc texmacs has some such support w/ lisp
05:24:47 <ski> @eurohaskell
05:24:49 <lambdabot> less talks, more code!
05:24:49 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
05:24:49 <lambdabot> EuroHaskell - Haskell Hackfest - Summer 2005 
05:24:49 <lambdabot> - Gothenburg, Sweden
05:24:55 <ski> hm
05:25:00 <tuomov> but primarily it's a sort of word processor
05:25:54 <tuomov> everything else about it sucks though except the command support :)
05:26:22 <cpatrick> the interface to maxima/octave/gnuplot is nice though. when it works.
05:26:55 <tuomov> I'm no a fan of emacs, you see
05:27:04 <tuomov> and blurred fonts
05:27:16 <Cale> > makes a greater-than, > TAB makes a pointy greater than, > TAB TAB makes a superset sign, TAB again gives "contains as an element", then a square variant, then a \rangle, then a sort of pie wedge thing, and finally back to >
05:27:17 <lambdabot>  parse error on input `,'
05:27:31 <tuomov> and I'd prefer the "wysiwym" approach of lyx over wysiwyg
05:27:51 <Cale> It's not really wysiwyg anyway
05:27:52 <tuomov> lyx, otoh, only supports command in math mode, the last I checked
05:28:03 <tuomov> texmacs is as wysiwyg as it can get
05:28:09 <Cale> not quite
05:28:25 <Cale> lines and pages break differently in the actual result
05:28:34 <Cale> which is quite annoying
05:28:52 <Cale> sometimes in the middle of formulas, which is *really* bad
05:28:57 <tuomov> well, it's trying to look exactly like a scanned copy, along with the scaling blur
05:29:24 <Cale> I really hate when you get something like: blah blah blah |x - y
05:29:25 <Cale> |
05:29:49 <Cale> where the absolute value sign, or norm bars get broken onto a new line
05:29:52 <tuomov> formulas should only break around operators at the highest level
05:29:56 <Cale> yes
05:30:10 <tuomov> but that requires some more semantical information
05:30:14 <Cale> TeX normally handles things sanely
05:30:34 <tuomov> it doesn't know that \| a - b \| shouldn't break around -
05:30:36 <Cale> but all the GUI editors I've seen have this annoying feature
05:30:48 <tuomov> It should understand \abs{a-b} as something unbreakable
05:31:01 <Cale> It should produce sane TeX code :)
05:31:16 <tuomov> I'm talking about TeX here..
05:31:25 <tuomov> texmacs doesn't use TeX, afaik
05:31:28 <Cale> TeX doesn't break formulas for me
05:31:32 <Cale> it does
05:31:49 <Cale> In fact, it renders the entire UI with TeX
05:31:57 <tuomov> No, it doesn't use TeX for that
05:32:10 <Cale> well, it appears to :)
05:32:17 <tuomov> it uses the tex algorithms, but not tex the program
05:32:22 <Cale> ah, okay
05:32:36 <Cale> so perhaps they introduced a few bugs
05:32:55 <Cale> since ordinary TeX is quite sane about not breaking formulas.
05:33:07 <tuomov> it may be due to differences in some magic numbers
05:33:29 <Cale> oh, that could be too
05:33:36 <tuomov> TeX doesn't really have that much intelligence about formula breaking IIRC, it just heuristically places some glue and stuff
05:34:00 <Cale> The right magic numbers are important when typesetting maths :)
05:34:51 <tuomov> If TeX were intelligent, there would be no need for multline, split, etc. :)
05:36:30 <Cale> yeah, but even so, I've never seen another document processor that comes close to what (Plain-/AMS-/La-)TeX does in terms of looks.
05:37:04 <tuomov> of course not; they use even crappier algorithms
05:37:23 <tuomov> even page/framemaker are quite poor compared to tex
05:37:32 <tuomov> m$ word can't even be mentioned in the same sentence
05:38:36 <tuomov> texmacs is probably the most usable program for writing formulas
05:39:15 <tuomov> rendered output and command input instead of hunting through dialogs for symbols or meoising Ctrl+Shift+Esc+a
05:39:29 <tuomov> s/meoising/memoizing/
05:39:46 <Cale> um
05:39:47 <Cale> hm?
05:40:07 <Cale> texmacs is either hunting through menus or knowing the right keys
05:40:08 <tuomov> lyx does that in math mode too, though
05:40:17 <tuomov> no, tex input works fine
05:40:43 <tuomov> \int <enter> 0 <enter> 1 <enter>
05:40:45 <tuomov> or something like that
05:40:53 <tuomov> I'd prefer not needing the enter, but it's better than nothing
05:41:04 <tuomov> _0 and ^1, that is
05:41:05 <Cale> ah, it does :)
05:41:08 <Cale> yeah
05:41:15 <tuomov> that is the single great thing about that program.
05:41:21 <tuomov> and it works outside math mode too, unlike in lyx!
05:41:55 <tuomov> \section<enter>Here's the title
05:42:11 <Cale> yep
05:44:10 <GnuVince> Is there a free Haskell shell somewhere?  I'm thinking something like Allegro Common Lisp's telnet://prompt.franz.com
05:44:19 <Cale> I also really like the structured selection
05:45:47 <ADEpt> GnuVince: it is here :)
05:45:53 <ADEpt> > 1+1
05:45:54 <lambdabot> 2
05:46:21 <Cale> > map (2^) [1..10]
05:46:23 <lambdabot> [2,4,8,16,32,64,128,256,512,1024]
05:46:23 * SamB likes that... "TeXmacs UI is rendered with TeX"...
05:46:40 <Cale> SamB: well, it rather appears to be :)
05:46:53 <Cale> (all the fonts it uses are the same)
05:47:09 <SamB> it uses METAFONT fonts, thats true
05:47:09 <Cale> So it at least appears to use metafont
05:47:26 <xinming> http://www.nomaware.com/monads/examples/example12.hs
05:47:36 <xinming> anyone here else would tell me why I can't compile this?
05:47:42 <xinming> Sorry, I was out for supper. :-P
05:47:54 <Cale> xinming: I get a 404 there at the moment
05:48:04 <Cale> (I realise that I shouldn't be getting one)
05:48:15 <SamB> The first time you start it, it tends to take a while to display the menus because it has to generate the font first ;-)
05:49:19 <xinming> hmm, hold on
05:49:22 <xinming> lisppaste2: 
05:49:23 <GnuVince> ADEpt: ah, nice.  Can I use him in private too if I want to test a lot of things and not flood the channel?
05:49:25 <xinming> lisppaste2: url
05:49:26 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:49:30 <GnuVince> s/him/it
05:49:33 <tennin> I imagined I could use TeXmacs without having to learn it
05:49:33 <SamB> The thing I like about TeXmacs is that it shows that it *is* possible to have such attractive rendering in an interactive program
05:50:05 <ADEpt> GnuVince: try it :) I bet you can
05:50:11 <SamB> the things I don't like are that its rather hard to figure out how to use it, and that it tends to crash rather more than TeX
05:50:43 <lisppaste2> xinming pasted "example12.hs" at http://paste.lisp.org/display/14677
05:50:46 * SamB has to wonder how hard it would be to give TeX a papyrus mode
05:51:13 <tennin> yeah, and you can't really rely on any existing emacs and/or TeX knowledge contrary to my fantasies
05:51:15 <GnuVince> ADEpt: yes!  Thanks a bunch
05:52:12 <SamB> GnuVince: one more thing!
05:52:12 <xinming> It's a example from the tutorial "All about monads",,
05:52:17 <SamB> lambdabot is a her
05:52:18 <Cale> xinming: what's the error?
05:52:44 <xinming> May I paste it here? :-P
05:52:52 <GnuVince> lambdabot: she is?
05:52:54 <ProfTeggy> SamB, can you elaborate: what is a 'payrus' mode?
05:53:03 <GnuVince> When did she become self-aware? :-P
05:53:05 <ProfTeggy> papyrus, rather
05:53:08 <xinming> lisppaste2: url
05:53:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:53:11 <ski> @vixen are you female?
05:53:12 <lambdabot> i truely am
05:53:12 <SamB> ProfTeggy: well, an infinite-height mode
05:53:22 <ProfTeggy> SamB, oh OK
05:53:29 <SamB> GnuVince: she isn't yet
05:53:42 <lisppaste2> xinming pasted "error msg" at http://paste.lisp.org/display/14679
05:53:43 <SamB> at least, I don't *think* she is
05:53:54 <SamB> especially when shapr isn't around
05:54:02 <Cale> xinming: compile with --make
05:55:48 <xinming> Cale: thanks
05:57:20 <xinming> type ParseMonad = Either ParseError
05:58:16 <xinming> this is a type "alias", So, will `ParseMonad Integer` become `Either ParseError Interger`?
06:03:01 <Cale> xinming: yes
06:13:04 <jethr0> hey #haskell
06:13:08 <Cale> hey
06:14:12 <xerox> Howdy!
06:15:01 <Cale> hi!
06:15:32 <jethr0> we're putting the channel back together :)
06:15:45 * xerox hehs
06:15:51 <ski> @put-shapr
06:15:52 <lambdabot> shapr!!
06:15:55 <ski> hm
06:15:59 <Cale> heh
06:16:04 <jethr0> @list-commands
06:16:05 <lambdabot> use listcommands [module|command], please. Modules are:
06:16:05 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
06:16:05 <lambdabot> hoogle karma localtime more pl plugs poll pretty quote search seen spell
06:16:05 <lambdabot> state system todo topic type version vixen where
06:16:06 <xerox> So othen than the getter we have the putter.
06:16:15 <Cale> @put-shapr 10
06:16:16 <xerox> @listcommands dummy
06:16:16 <lambdabot> shapr!!
06:16:17 <lambdabot> dummy provides: dummy get-shapr eurohaskell wiki paste docs libsrc learn
06:16:17 <lambdabot> map botsnack
06:16:26 <xerox> I told you :-)
06:16:36 <jethr0> @hi-shapr
06:16:37 <lambdabot> Unknown command, try @listcommands.
06:16:38 <xerox> Cale: ahah, it's not like putthing something ON shapr.
06:16:49 <xerox> -h
06:17:00 <jethr0> @put-shapr on-the-phone
06:17:01 <lambdabot> shapr!!
06:17:12 <xerox> @be silly, with lambdabot
06:17:13 <lambdabot> Maybe you meant: pl wn
06:17:18 <Cale> @bot
06:17:19 <lambdabot> :)
06:17:35 <jethr0> @he always thinks i mean something else
06:17:36 <lambdabot>  @help <command> - ask for help for <command>
06:17:41 <jethr0> *grr*
06:17:50 <xerox> Hahahah.
06:17:56 <jethr0> @it always thinks i mean something else
06:17:57 <lambdabot> Maybe you meant: dict pl quit wn
06:18:06 <xerox> She's a she.
06:18:15 <jethr0> is she? how did that happen?
06:18:24 <Cale> @vixen are you female?
06:18:25 <xerox> Ask dcoutts
06:18:25 <lambdabot> yes, i am
06:18:31 <Cale> see?
06:18:42 <jethr0> so @vixen is supposed to be the bot...
06:18:46 <Cale> hehe
06:18:48 <dcoutts> xerox, huh?
06:18:57 <jethr0> @vixen tell me about yourself
06:18:58 <lambdabot> what about me?
06:19:06 <jethr0> @vixen where do you live
06:19:07 <lambdabot> Huntington Beach California
06:19:11 <jethr0> hehe
06:19:17 <xerox> dcoutts: the first time I heard that was you on -blah or the contest :-)
06:19:29 <xerox> *for
06:19:32 <ski> http://www.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html
06:19:35 <jethr0> @vixen you got any hobbies?
06:19:36 <lambdabot> let's don't talk about that
06:19:48 <jethr0> shouldn't that be "let's _not_"?
06:20:53 <dcoutts> xerox, hah, yeah
06:21:09 <xerox> ;-)
06:21:34 <jethr0> @vixen how come a chic like you knows about haskell?
06:21:35 <lambdabot> Ooh, functional programmers are so hot!
06:21:43 <neologism> hehe
06:22:34 <jethr0> @vixen how come a chic like you knows about haskell?
06:22:35 <lambdabot> church is my favourite computer scientist.
06:23:03 <neologism> @vixen curry me
06:23:04 <lambdabot> are you coming on to me?
06:23:32 <jethr0> @vixen what's one times seven minus four?
06:23:33 <lambdabot> why are you giving me a math test?
06:23:41 <xerox> woo.
06:24:42 <neologism> @vixen yes
06:24:42 <lambdabot> you agree?
06:24:44 <neologism> @vixen yes
06:24:45 <lambdabot> i guessed that
06:24:47 <neologism> @vixen no
06:24:47 <lambdabot> i didn't think so
06:24:48 <neologism> @vixen no
06:24:49 <lambdabot> i didn't think so
06:25:01 <Cale> @vixen @vixen
06:25:02 <lambdabot> i am a bit of a vixen :)
06:25:27 <jethr0> @vixen how come you're so smart?
06:25:28 <lambdabot> why not?
06:25:28 <xerox> What is the @vixen secret?
06:25:42 <jethr0> @vixen tell me about yourself
06:25:43 <lambdabot> what about me?
06:25:54 <jethr0> @vixen tell me about yourself
06:25:55 <lambdabot> what about me?
06:26:24 <jethr0> @vixen let's meet someplace
06:26:26 <lambdabot> let's get to know each other better before we meet, okay?
06:26:28 <Cale> @vixen where do you work?
06:26:30 <lambdabot> maybe. do you?
06:26:31 <tromp_> @vixen will you marry me?
06:26:32 <lambdabot> let me answer that later, okay?
06:26:37 <Cale> heh
06:27:01 <Cale> @vixen what do you do?
06:27:02 <lambdabot> i don't know, what?
06:27:06 <tromp_> @vixen your place or mine?
06:27:08 <lambdabot> good question
06:27:18 <jethr0> @vixen i'll call you
06:27:19 <lambdabot> let's wait before we exchange phone numbers
06:27:22 <Cale> @vixen You must be a Libra
06:27:23 <lambdabot> underneith the top layer I'm completely bear (no bra or panties)
06:27:40 <jethr0> @vixen did you eat already?
06:27:41 <lambdabot> that reminds me, i have yogart in the frige
06:27:45 <tromp_> i've never seen a bear wearing a bra or panties...
06:27:55 <neologism> bear -> bare ?
06:28:08 <SamB> so lambdabot can't spell.
06:28:09 <Cale> yeah, there are lots of intentional typos
06:28:15 <SamB> you got a problem with that?
06:28:42 <xerox> Where!
06:29:06 <jethr0> @vixen have a look at my homepage: http://vixen.com
06:29:07 <lambdabot> i'm 19
06:29:14 <jethr0> @vixen have a look at my homepage: http://me.com
06:29:15 <lambdabot> i'm 19
06:29:18 <Heffalump> anyone heard of the Ivy project at Berkeley?
06:29:18 <jethr0> weird
06:29:38 <Cale> @vixen /
06:29:39 <lambdabot> I have a goldfish named Ernie
06:29:44 <Cale> @vixen //
06:29:45 <lambdabot> Thank God for AOL that I could meet people like you!
06:29:57 <Cale> @vixen : :// .
06:29:58 <lambdabot> i like your screen name... what does it mean?
06:30:15 <neologism> @vixen have you ever had sex with one plus two?
06:30:16 <lambdabot> yes, once or twice :)
06:30:16 <jethr0> @vixen i'll try my dicktionary
06:30:17 <lambdabot> sad dude. gotta go on AOL and find random girls to talk about your dick
06:30:17 <lambdabot> with
06:31:18 <jethr0> @vixen you know, i've got a lexus.
06:31:19 <lambdabot> i think i know
06:31:38 <jethr0> @vixen my lexus in stands in the garage
06:31:39 <lambdabot> i just turned 19
06:31:45 <jethr0> wtf
06:31:50 <jethr0> @vixen lexus
06:31:51 <lambdabot> ooo, that's a nice car! you must be a very important person
06:33:28 <tromp_> @vixen quest
06:33:29 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
06:35:14 <Cale> @vixen space quest
06:35:15 <lambdabot> You think this is a botiecall??
06:35:26 <jethr0> botie?
06:35:36 <Cale> terrible spelling :)
06:35:36 <jethr0> bowtie :)
06:36:02 <Cale> @vixen bowtie
06:36:03 <lambdabot> I'm sorry, I'm confused.
06:36:09 <jethr0> @vixen booty
06:36:10 <lambdabot> i hate it when i get stuck with chatting with a bot!
06:36:26 <Cale> @vixen i hate it when i get stuck with chatting with a bot!
06:36:26 <jethr0> vixen is a little erratic today
06:36:27 <lambdabot> you must be good at that
06:36:34 <Cale> @vixen you must be good at that
06:36:35 <lambdabot> thanks, i do my best to be good
06:36:42 <Cale> @vixen thanks, i do my best to be good
06:36:43 <jethr0> cale, that's just mean!
06:36:43 <lambdabot> just good?
06:36:50 <Cale> @vixen just good?
06:36:51 <lambdabot> good good
06:36:57 <Cale> @vixen good good
06:36:58 <lambdabot> good? not great?
06:37:08 <jethr0> that's a nice test application for a bot!
06:37:18 <jethr0> produces nice long logs to study
06:37:45 <Cale> It's better when the bot takes chunks of what you say and splices them into its own text.
06:38:07 <jethr0> ya, the eliza feature
06:38:59 <jethr0> i've always wanted to write an Eliza with an ontology. so it would know about language semantics PLUS word associations
06:39:25 <jethr0> so, it could automatically infer:
06:39:26 <xinming> convert s = let (Right str) = do {n <- parseHex s; toString n} `catchError` printError
06:39:26 <xinming>             in str
06:39:30 <xinming> what does this mean please?
06:40:01 <xinming> if I split them up, I can understand, But if they joint together, I have no clue. :-/
06:40:16 <tennin> lambdabot seems a bit insecure
06:40:30 * jethr0 doesn't get why the 'catchError' is outside the do!
06:40:46 <ADEpt> xinming: are you sure that this compiles?
06:40:48 <jethr0> brr, monads in monads
06:41:27 <xinming> ADEpt: yes, It's an example from <<All about Monads>> tutorial
06:41:28 <jethr0> xinming, what type does printError have? does it return (Either _ _)?
06:41:44 <xinming> jethr0: yes, either _ _
06:42:39 <jethr0> presumable printError produces a (Right _)
06:44:02 <xinming> I don't know what does `let (Right str) = do ... in str
06:44:41 <jethr0> @pretty convert s = let action = do {n <- parseHex s; toString n}; (Right str) = catchError action printError in str
06:44:42 <lambdabot>  convert s  = let action     = do n <- parseHex s
06:44:42 <lambdabot>                                   toString n
06:44:42 <lambdabot>                   (Right str) = catchError action printError
06:44:42 <lambdabot>                          in str
06:44:47 <jethr0> *aaahhh*
06:45:31 * jethr0 thinks @pretty tried to align the equal signs
06:45:32 <ski> (why does it put 'in' there ?)
06:45:51 <Cale> http://www.nik.com.au/archives/2003/11/21/alice-bot-off-3/
06:45:54 <jethr0> ski, i got *lots* of cleaning up to do on @pretty :(
06:46:21 <jethr0> cale, did you do anything further with your table pretty printer?
06:47:27 <Cale> jethr0: nope
06:47:39 <jethr0> how far did you get?
06:47:45 <tennin> xinming: what exactly don't you understand?
06:47:45 <Cale> Thinking :)
06:47:53 <xinming> hmm, what does str hold
06:48:09 <jethr0> xinming, my guess would be a "String"
06:48:39 <xinming> I don't know what does `let (Right str) = do ... in str` do, It seems a bit like, let (Maybe a) = ... in a
06:49:02 <jethr0> you mean (Just a), right :)
06:49:07 <ski> ('Maybe' is not a data constructor)
06:49:11 <tennin> I think the "do... `catchError`printError ... returns either a Right String if it parsed the hex digit successfully, or a Left _ if it hit a snag
06:49:26 <Cale> I love the way that the Alice talking to Alice conversation ends up diverging.
06:49:29 <jethr0> tennin, but then the pattern match would fail!
06:50:17 <tennin> right...
06:50:38 <jethr0> cale, but it kinda reaches a fixpoint :)
06:50:46 <Cale> yeah
06:50:58 <jethr0> xinming, "Just" and "Nothing" are data constructors for the data type "Maybe"
06:51:14 <jethr0> similarly "Right" and "Left" are constructors for type "Either"
06:51:24 <xinming> jethr0: hm, I know,
06:51:41 <xinming> so, let (Just a) = ... in a
06:51:43 <xinming> what does this mean?
06:52:16 <jethr0> so "(Just x) = sth" will try extract the encapsulated content of the Maybe type if sth is of type Maybe and was constructed with "Just"
06:52:29 <jethr0> if it was constructed with "Nothing" this match will fail
06:53:01 <xinming> so, `let (Just a) = ... in a` will return a?
06:53:12 <tennin> yeah
06:53:15 <jethr0> @pretty let xx = Just "x"; text = case xx of (Just a) -> a; (Nothing) -> "nothing"
06:53:16 <lambdabot> "Parse error" at column 75
06:53:40 <jethr0> @pretty let xx = Just "x"; text = case xx of (Just a) -> a; (Nothing) -> "nothing" in text
06:53:40 <xinming> It's clear now, thanks.
06:53:41 <lambdabot>  i = let xx = Just "x"
06:53:41 <lambdabot>          text
06:53:41 <lambdabot>            = case xx of
06:53:41 <lambdabot>                  (Just a) -> a
06:53:41 <lambdabot>                  (Nothing) -> "nothing"
06:53:43 <lambdabot>        in text
06:54:06 * xinming says: amazing haskell, and unreadable haskell
06:54:11 * jethr0 is annoyed with his pretty printer
06:54:26 <Pupeno> Is it possible to make ghc output the dependencies instead of writing them to Makefile ? I need to use them somewhere else.
06:56:05 <Igloo> You can read them from the Makefile
06:56:06 <ski> @index fromRight
06:56:08 <lambdabot> bzzt
06:56:21 <Igloo> There's an option to change the file if you don't want them in Makefile
06:56:52 <jethr0> ski, doesn't exist. but "either" does
06:56:54 <jethr0> @type either
06:56:56 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
06:57:14 <xerox> jethr0: work on the ppinter :D
06:57:26 <jethr0> :D
06:57:28 <ski> jethr0 : thought i'd seen it somewhere ..
06:57:36 <jethr0> nah, i'm on my TH tutorial
06:58:05 * Cale off to take a short nap
06:58:11 <jethr0> later
06:58:13 <Pupeno> Igloo: the option -f file is not really there on ghc 6.4.1.
06:58:17 * xerox wonders if it would be good to do the same
06:58:21 <Cale> I'll be back in a couple of hours probably :)
06:58:25 <Pupeno> Igloo: and reading them from Makefile is nasty.
06:58:37 <Pupeno> I mean, writing it to Makefile is nasty.
06:58:38 <Cale> (despite the fact that I haven't slept :)
06:58:57 <xerox> @localtime Cale
06:58:59 <lambdabot> Local time for Cale is Thu Dec 15 09:58:35
06:59:13 * jethr0 slept 4 hours today...
06:59:25 <malcolm> anyone here familiar with converting a CVS repository to darcs using tailor?
06:59:37 <Igloo> Pupeno: I think you need something before the -f, but it escapes me
06:59:56 <Pupeno> something before ? mmhh
06:59:57 <Igloo> Pupeno: Ah, -optdep-f -optdepfilename I think
07:00:03 <jethr0> to boldly go where no man has gone before
07:01:20 <Oejet> jethr0: That's nothing.  I read about a guy who sleeps 2-3 hours per 24 hours, and does it consistently.
07:01:45 <jethr0> oejet, my uncle has been doing that for decades. and he's one of the healthies persons i know
07:01:54 <Pupeno> Igloo: thanks, I would have never figure that out.
07:02:55 <Oejet> jethr0: It's something about just getting enough REM sleep, I think.
07:04:15 <jethr0> my uncle goes to bed at 10pm and get's up at 2am. it's supposedly something to do with "sun time"...
07:22:16 <xinming> hmm, again
07:22:16 <xinming> convert s = let (Right str) = do {n <- parseHex s; toString n} `catchError` printError
07:22:16 <xinming>             in str
07:22:36 <xinming> since the type for convert is `convert :: String -> String`
07:23:33 <xinming> what will covert return, If it doesn't match the (Right str) ?
07:25:05 <ADEpt> xinming: it will fail with run-time error
07:26:16 <ski> (though, won't 'catchError' make sure that's impossible ?)
07:26:40 <xinming> http://www.nomaware.com/monads/examples/example12.hs
07:26:56 <xinming> ADEpt: this is the example I am now learning,
07:27:17 <Lemmih> > let Right r = Left () in r :: Int
07:27:18 <lambdabot>  Irrefutable pattern failed for pattern Data.Either.Right r
07:27:27 <xinming> but for this example is compiled into binary
07:27:51 <xinming> ./a.out 34 abc zx 123
07:28:01 <jethr0> lemmih, who says printError returns a "Left"?
07:28:21 <xinming> it will just print the error message about the zx, and still perform the next conver
07:28:22 <xinming> t
07:28:54 <jethr0> my guess is that printError returns a "Right" and then everything seems perfectly alright...
07:29:20 <Lemmih> jethr0: No one. But he asked what happened if it did.
07:29:28 <jethr0> sry
07:29:56 * ADEpt once again have not read it all. sorry
07:30:41 <xinming> thanks,
07:30:50 <xinming> It's clear now,
07:30:52 <xinming> :-)
07:38:33 <Lor> Hm, is there a way to give hugs an expression to run on command-line?
07:38:51 <shapr> Was someone calling my name?
07:38:57 <jethr0> hehe
07:39:03 <jethr0> @put-shapr on the phone
07:39:04 <lambdabot> shapr!!
07:39:12 <shapr> Amazing
07:39:18 <jethr0> :)
07:40:16 <jethr0> lor, maybe "ghc -e" helps you?
07:40:49 <Lor> Funny that ghc would support something like that and hugs didn't.
07:40:59 <ski> Lor : 'echo 1+2 | hugs' ?
07:41:09 <jethr0> shapr, my TH tutorial is coming along nicely. i am even hoping it's approaching TMR standards :)
07:42:41 <Lor> ski, no, I want the standard input to be used for data, not code.
07:42:52 <ski> aha
07:43:00 * ski doesn't know
07:43:00 <jethr0> lor, i misunderstood that
07:43:17 <kowey> hi shapr, have you received my mail about the darcs wiki by any chance? (i ask because you said something about anti-spam measures... maybe eaten)
07:43:21 <jethr0> lor, can you give an example of what you want?
07:44:09 <shapr> kowey: Yes, I got your mail, but I haven't gotten around to actually trying it yet.
07:44:10 <Lor> haskell -e 'print "Hello, world!"'
07:44:38 <shapr> jethr0: Cool, good to hear!
07:44:43 <jethr0> lor, and then?
07:44:44 <xerox> hey hey hey.
07:44:51 <kowey> no hurry shapr, wasn't meaning to bug you :-)
07:44:56 <jethr0> xerox, done sleeping already?
07:45:03 <xerox> i didn't sleep, whoopee.
07:45:14 * jethr0 neither, *whoopee*
07:45:33 <xerox> jethr0 said pee!
07:45:45 <jethr0> may i be so bold as to use markup in irc?
07:45:52 <Lor> What then?
07:46:09 <Lor> I just want to use haskell for quick command-line scripts:
07:46:13 <jethr0> lor, 'print ".."' isn't exactly a valid haskell program
07:46:30 <Lor> It's an expression of type IO ()
07:46:34 <xerox> main = print ".." is, tough.
07:46:36 <Lor> It should use that as main.
07:46:48 <xerox> how, if you don't name it.
07:46:51 <jethr0> echo "putStrLn \"hello world\"" | hugs
07:46:58 <Lor> Or: liftM (sum . map read . lines) getContents >>= print
07:47:00 <jethr0> ah, didn't know "print" was in IO
07:47:12 <musasabi> Lor: ghc -e 'print "hello world"'
07:47:16 <Lor> jethr0, I want to use stdin for _input_
07:47:21 <jethr0> but it's a little verbose
07:47:27 <jethr0> sry
07:47:55 <Lor> musasabi, doesn't work for me, maybe it's a faulty build.
07:48:11 <Lor> ghc-6.4: /usr/lib/ghc-6.4/HSbase.o: unknown architecture
07:48:22 <musasabi> hmm. You might want to try 6.4.1
07:48:32 <Lor> Ah, this is of course the same reason why ghci doesn't work.
07:48:35 <Lor> (amd64)
07:48:42 <musasabi> Lor: if that is amd64 then 6.4.1 will fix it
07:48:58 <Lor> Hm, lessee if debian has it already...
07:49:08 <jethr0>  runhugs <(echo "module Main where main = getLine >>= putStrLn")
07:49:25 <Lor> jethr0, yeah, but that's raaather too verbose
07:49:28 <jethr0> i know
07:49:37 <Lor> And again it takes the stdin.
07:49:47 <jethr0> no, that's process substitution
07:49:59 <musasabi> I think one could provide a wrapper script for hugs.
07:50:02 <jethr0> it treats the result of echo as a file descriptor
07:50:47 <jethr0> #!/bin/bash; runhugs <(echo "module Main where main = $1")
07:51:32 <Lor> How does runhugs know to use that file descriptor, if it isn't stdin?
07:51:52 <jethr0> it's a feature of bash. it's called process substitution or something
07:52:55 <jethr0> ./myscript "getLine >>= putStrLn"
07:52:58 <jethr0> brave new world
07:53:02 <jethr0> brave new world
07:53:17 <Lor> All right, cool.
07:53:27 <xerox> woot.
07:53:42 <jethr0> what's with the l33t speak expressions, xerox?
07:54:06 <jethr0> although i share your enthusiasm :)
07:54:28 <tuomov> asks someone with a l33t name :)
07:54:29 <int-e> jethr0: you mean, w007?!
07:54:37 <jethr0> hehe
07:55:00 <Lor> Right, it passes /dev/fd/something to the program
07:55:05 <jethr0> tuomov, i had that name long before the term 1337 even was popularly known
07:55:06 <Lor> Anyway, ghc -e works now.
07:55:37 * jethr0 had this nick since 1998 or sth
07:55:37 <xerox> jethr0: err, you shake my enthusiasm :)
07:56:21 <jethr0> but your rebuttal is well received :)
07:56:50 <Lor> ...except that ghc does some strange terminal setting things and I can't eof the input...
07:57:10 <jethr0> ^D ?
07:57:15 <Lor> Doesn't work.
07:57:18 <jethr0> hmm
08:09:37 <jethr0> channel gets eerily at times...
08:09:41 <jethr0> quiet*
08:10:40 <ADEpt> AH! WHO IS THERE?!
08:10:42 * ADEpt hides
08:11:06 * xerox
08:18:10 * xinming walks around
08:18:31 * xerox walks counterclockwise around
08:18:58 * jethr0 has just bumped into xerox
08:19:12 <jethr0> the situation is getting agitated
08:20:20 <xerox> I wouldn't say that
08:20:40 * jethr0 get's angry at xerox patronizing him
08:20:45 <jethr0> for
08:20:52 <jethr0> :)
08:22:14 <GnuVince> Is there somewhere I could learn about lambdabot's capabilities?
08:22:24 <jethr0> @listcommands
08:22:25 <lambdabot> use listcommands [module|command], please. Modules are:
08:22:25 <lambdabot> babel base code dice dict djinn dummy dynamic elite fact haddock help
08:22:25 <lambdabot> hoogle karma localtime more pl plugs poll pretty quote search seen spell
08:22:25 <lambdabot> state system todo topic type version vixen where
08:22:33 <jethr0> and the source of course :)
08:23:49 <GnuVince> jethr0: thanks a bunch
08:26:29 <genneth> @help djinn
08:26:30 <lambdabot> Generates Haskell code from a type.
08:26:30 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:26:47 <genneth> huzzah!
08:26:49 <jethr0> @djinn a -> (Maybe a)
08:26:50 <lambdabot> f = Just
08:27:04 <jethr0> @djinn (a -> b) -> a -> (Maybe b)
08:27:05 <lambdabot> f x1 x2 = Just (x1 x2)
08:27:42 <jethr0> @djinn (a -> b) -> (Maybe a) -> (Maybe b)
08:27:43 <lambdabot> f x1 x2 =
08:27:43 <lambdabot>   case x2 of
08:27:43 <lambdabot>   Nothing -> Nothing
08:27:43 <lambdabot>   Just v7 -> Just (x1 v7)
08:31:14 <ProfTeggy> If people are interested:
08:31:16 <ProfTeggy> http://db.ewi.utwente.nl/Publications/PaperStore/db-utwente-0000003696.pdf
08:31:27 <ProfTeggy> The Haskell Progrmmer's Guide to the IO Monad
08:31:42 <ProfTeggy> Fills the gap between Haskell and the categorical view of things quite nicely, IMHO
08:31:50 <jethr0> nice
08:32:00 <xerox> Cool
08:32:23 <ProfTeggy> By Stefan Klinger (former student of mine *plug*plug* ;-)
08:35:05 <mjl69> ProfTeggy: thanks! I saved it for later reading.
08:35:22 * jethr0 wonders whether it can be considered nerdy if you put the pizza in the oven and type "sleep $((60 * 20))"
08:35:42 <jethr0> followed by some sort of signal of couse
08:35:43 <ProfTeggy> mjl69, enjoy.  But all kudos go to Stefan.
08:37:30 <ihope> I got a program here...
08:37:45 <shapr> jethr0: It's only nerdy if you get Template Haskell to actually turn off your oven at that time.
08:38:16 <ADEpt> shapr: it is nerdy if you oven responds with:
08:38:17 <ADEpt> > sleep $((60 * 20))
08:38:18 <lambdabot>  Not in scope: `sleep'
08:38:26 <xerox> Don't sleep!
08:38:31 <ADEpt> ... responds with "Not in scope: `sleep'" :)
08:38:32 <shapr> Oh hey, I had this crazy idea today...
08:38:33 <jethr0> hehe
08:38:50 * xerox sits at his chair watching shapr
08:39:10 <ADEpt> ihope: anyway, you were having that program ...
08:39:12 <shapr> Tiled robots where each tile is designed to flex in such a way that it can move a tile from one face to another.
08:39:30 <shapr> Is there a 3D shape that could flex like that? In pairs maybe?
08:39:34 <ihope> It implements a simple (and very weak) encryption algorithm.
08:40:05 * ADEpt stares at shapr in awe. My nightmares are usually less sophisticated :)
08:40:15 <xerox> shapr: crosses?
08:40:30 <shapr> ADEpt: You don't want to see my nightmares, they're indescribable.
08:40:34 <ihope> For example: "To be or not to be: that is the." to "Tb  et t :osoaoeoeni hthb t rt ."
08:41:14 <jethr0> are you actually talking about the same thing, you three?
08:41:27 <ihope> I'm not.
08:41:30 <shapr> There's this one about an infinite blue tiled slideway thing, sort of like a stairway in reverse...
08:41:35 <shapr> aanyway.
08:41:50 <shapr> xerox: crosses?
08:41:56 <xerox> X
08:43:24 <mjl69> like penrose tiles?
08:43:49 <shapr> I was trying to think of solids that would flex on their edges. Take a cube for example, if each corner were a joint, it could lie flat. But if you had something like ligaments on the inside that could control how it bends and stretches...
08:43:50 <mjl69> tiling the plane
08:44:12 <shapr> I want something like a bunch of cubes where the cubes can crawl over each other.
08:44:14 <xerox> cylinders
08:44:33 <shapr> Think of a tank tread, where the tread pieces are each a robot.
08:44:45 <mjl69> like rotating zippers at all edges?
08:44:49 <shapr> cylinders work only in one direction.
08:44:57 <shapr> mjl69: yes! excellent description!
08:45:01 <tic|school> Is it possible to extract the state from a StateT m s a without doing execStateT myMonad state, where state <- get?
08:45:24 <tic|school> because then I'll get the state after running it for state in myMonad; I want to know what it is _right now_.
08:45:39 <shapr> xerox: Cylinders are the right idea though...
08:45:48 <tic|school> in State, I'd just do (my, fine, state) <- get, but that doesn't seem to be possible now.. :-
08:45:49 <xerox> tic|school: for 'it' to 'be' you must run it
08:45:51 <tic|school> :-/
08:46:03 <xerox> tic|school: so, you're already "in" it to "see" what it "is".
08:46:20 <tic|school> xerox, true. but how do I get at the actual state=
08:46:20 <tic|school> ?
08:46:31 <xerox> shapr: well!
08:46:38 <shapr> mjl69: Oh I think I might know how penrose tiles are connected to superconductivity.
08:47:02 <mjl69> shapr: really?
08:47:02 <xerox> tic|school: run it
08:47:20 * ADEpt marwells at shapr's imagination
08:47:23 <tic|school> xerox, but I'm inside a function that's doing something to the inner monad, and therefore have no knowledge of it.
08:47:26 <ADEpt> ihope: and ... ?
08:47:49 <xerox> tic|school: do it in the monad, or monadize that function?
08:48:38 <tic|school> xerox, it already is monadized. Hrm, think you could check?
08:48:56 <xerox> Sure
08:49:07 <shapr> Some quasicrystals are a 3D form of penrose tiles. They end up forming layered planes of penrose tiles, like pieces of paper on top of each other. Recent research into one molecule thick layers of carbon has discovered dramatically reduced resistance, they suspect they can achieve superconductivity once they can generate enough of the single molecule layers.
08:49:30 <tic|school> xerox, http://www.dtek.chalmers.se/~tic/Document.hs
08:49:37 <tic|school> xerox, "bundle"
08:49:39 <jethr0> tic|school, i'm no expert, but i think outside of exeState no "state" exists
08:49:43 <shapr> So I wonder if the penrose tiling in quasicrystals ends up enforcing the same single molecule conductor setup that's being researched.
08:50:33 <shapr> Oh, I think I left out a bit, that quasicrystals already have something to do with superconductors, but no one is really sure what.
08:50:38 <tic|school> jethr0, I -think- I'm in it, though.
08:50:54 <mjl69> cool
08:51:03 <mjl69> very cool
08:51:04 <xerox> wow, what cool piece of code
08:51:09 <jethr0> i thought one would know if one were...
08:51:32 <tic|school> xerox, thanks :)
08:51:41 <xerox> tic|school: if you're *in*, you can get it (as in the get action)
08:52:01 <tic|school> xerox, what I want to do is the equivalent of "execState <everything-up-to-here> state"
08:52:26 <xerox> continuations?
08:52:32 <tic|school> ugh.
08:52:34 <tic|school> no.
08:52:34 <shapr> ADEpt: Imagination is fun, but sometimes I wish mine would stop and let me focus.
08:52:54 <xerox> you can grab the 'everything up to here' with reset, and shift it in, heh.
08:52:58 <tic|school> xerox, get has type DocumentState () in the function bundle.
08:53:15 <xerox> @type Control.Monad.State.get
08:53:17 <lambdabot> forall s (m :: * -> *). (Control.Monad.State.MonadState s m) => m
08:53:17 <lambdabot> s
08:53:18 <tic|school> xerox, and I want to get the document, i.e., the inner monad.
08:53:28 <tic|school> exactly.
08:53:32 <xerox> So it returns a DocumentState
08:53:34 <tic|school> or hm...
08:53:50 <xerox> Hmm?
08:54:22 <tic|school> xerox, look at the case ... of in bundle.  figcount comes from the 
08:54:29 <tic|school> xerox, *new* state I have.
08:54:37 <jethr0> > return 2 >>= even
08:54:39 <lambdabot> Couldn't match `m b' against `Bool'
08:54:52 <jethr0> > 2 >>= even
08:54:54 <lambdabot> Couldn't match `m b' against `Bool'
08:55:02 <tic|school> xerox, that is, what I have after running the "inner" section. If anyone defines a figure there, numbering will be screwed up
08:55:40 <tic|school> xerox, I want to get the current state, and _then_ run the inner section. But that doesn't seem possible without running $self, so to speak.
08:56:14 <xerox> I wonder what am I missing
08:56:21 <xerox> do s <- get
08:56:32 <xerox>    doInner s
08:56:53 <xerox> equals to 'do doInner' if you want.. hm.
08:58:36 <tic|school> xerox, compacting the basic idea a bit. This is what I want: do {(figcount, figtable) <- get; put (figcount+1, (figcount, label):figtable); doInner (figcount, figtable);]
08:58:40 <tic|school> }, sorry.
08:59:24 <xerox> do them sequentially
08:59:33 <tic|school> ?
09:00:19 <xerox> what's your problem with do { (a,b) <- get; put (a+1,(a,x):b); foo (a,b) }
09:00:28 <xerox> err
09:00:34 <xerox> no yes, makes sense to me
09:00:44 <tic|school> no, that is not the problem
09:00:52 <tic|school> the problem is that the doInner function modifies the state
09:01:03 <tic|school> and therefore I'll have a different state.
09:01:12 <xerox> so do it the other way around
09:01:17 <tic|school> but I cannot.
09:01:25 <tic|school> I can't get at the current state without execStateT-ing somethng.
09:01:26 <xerox> do { (a,b) <- get; foo (a,b); put (a+1,(a,x):b);
09:01:40 <ihope> > (return 2) >>= even
09:01:41 <lambdabot> Couldn't match `m b' against `Bool'
09:01:50 <tic|school> thanks for your help, I'll ask someone around here instead. Really hard to explain over the net like this.. Thanks for trying though!
09:01:56 <xerox> > return 2 >>= return . even :: [a]
09:01:57 <lambdabot>  [a]
09:01:57 <lambdabot>   Inferred type: [Bool]
09:01:57 <lambdabot>   In the expression: (return 2) >>= (return . even)
09:01:59 <jethr0> ihope, i was trying this (->) monad thingey
09:02:01 <xerox> > return 2 >>= return . even :: [Bool]
09:02:02 <lambdabot> [True]
09:02:14 <jethr0> *yuch*, but thx
09:02:22 <xerox> tic|school: sorry :(
09:02:53 <jethr0> > return 2 >>= return . (+1) :: [Int]
09:02:54 <lambdabot> [3]
09:03:20 <jethr0> xerox, no, i didn't want to do it in the list monad. i though (->) was monadic somehow too
09:03:29 <xerox> sure it is
09:03:29 <jethr0> and i was trying whether i could do function application with (>>=)
09:03:36 <palomer> in 2 hours I'll be writing my final exam!
09:03:39 <xerox> use the Reader Monad
09:03:43 <xerox> Good luck palomer!
09:03:51 <jethr0> somehow replacing "(.)" with "(>>=)"
09:04:24 <jethr0> xerox, what do you mean "reader monad". how should i use it?
09:04:32 <jethr0> what's it do, anyways :)
09:04:38 <xerox> @google all about monads
09:04:40 <lambdabot> http://www.nomaware.com/monads/html/
09:04:44 <xerox> sorry I know it's harsh to say rtfm
09:04:59 <jethr0> naa, you're quite right
09:05:14 <jethr0> i'll have to read that tutorial all the way through sooner or later
09:05:58 <jethr0> would be cool though if there was a pdf version, or sth
09:06:25 <ihope> Say... what's the data constructor for the IO monad?
09:06:35 <jethr0> hmm
09:07:05 <xerox> Do it!
09:07:18 <xerox> ihope: there isn't one .. wavint the hands in a jedi-like fashion
09:07:25 <ihope> Oh...
09:07:59 <jethr0> > return 5 :: IO Int
09:08:01 <lambdabot> No IO allowed
09:08:05 <Saulzar> There probably is - but certainly not exported :)
09:08:10 <Lemmih> @type GHC.IOBase.IO
09:08:11 <lambdabot> forall a.
09:08:11 <lambdabot> (GHC.Prim.State# GHC.Prim.RealWorld
09:08:11 <lambdabot> -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
09:08:11 <lambdabot> -> IO a
09:08:12 <xerox> ihope: if there were, you could have done a foo :: IO a -> a
09:08:30 <xerox> Lemmih's taking the advanced course.
09:09:00 <jethr0> xerox, which is another way of saying unsafePerformIO, right :)
09:09:10 <jethr0> well, not really
09:09:19 <xerox> Yeah
09:09:22 <xerox> It is
09:09:51 <jethr0> but "let (IO a) = a" would try to extract it directly, while unsafe... will execute the IO operation
09:09:54 <jethr0> right?
09:11:12 <Saulzar> Hmm, well the data constructor looks like a function...
09:11:44 <Saulzar> So I guess if you had access to it you could run it directly
09:12:05 <jethr0> true
09:12:33 <Saulzar> Provided you could also construct a "RealWorld" .. real question is, what is in there?
09:12:49 <Saulzar> @type GHC.Prim.RealWorld
09:12:50 <lambdabot> Not in scope: data constructor `GHC.Prim.RealWorld'
09:13:16 <Lemmih> @type GHC.Exts.realWorld#
09:13:18 <lambdabot> GHC.Prim.State# GHC.Prim.RealWorld
09:13:40 <Saulzar> RealWorld is hard-coded maybe?
09:13:47 <jethr0> well, at some point you need functionality outside of haskell...
09:14:42 <Saulzar> @type GHC.Prim.State#
09:14:44 <lambdabot> Not in scope: data constructor `GHC.Prim.State#'
09:16:32 <moonlite> if i import a module qualified. I will have to access the functions using Module.function right?
09:17:32 <moonlite> what about datatype constructor, is it the same there? Like do i access it using Module.Constructor
09:17:45 <ProfTeggy> moonlite, you bet
09:18:26 <moonlite> :)  thx
09:18:46 <ProfTeggy> moonlite, a constructor is nothing but a function, by the way
09:18:55 <ProfTeggy> So no real surprise here
09:19:26 <moonlite> oh ok
09:19:56 <jethr0> moonlite, if importing restricted you'll need to write "import Module (DataType(Constructor))"
09:20:12 <jethr0> to import only "Constructor"
09:20:36 <moonlite> btw, could i access BlogDB.Posts.Id.Id just using Id.Id (where BlogDB.Posts.Id is the module)?
09:20:38 <Lemmih> Hiya SyntaxNinja.
09:21:01 <moonlite> (and Id is a datatype constructor)
09:21:15 <Lemmih> moonlite: 'import qualified BlogDB.Posts.Id as Id'
09:21:36 <jethr0> lemmih, you beat me to it...
09:21:55 <moonlite> hm yeah ok thx a lot. 
09:22:02 <jethr0> or "import qualified BlogDB.Posts as BP" and then "BP.Id.Id"
09:22:44 * shapr wants a class D IP address.
09:22:52 <shapr> hiya SyntaxNinja 
09:24:00 <Heffalump> shapr: don't you have one?
09:24:15 <Heffalump> if you make the obvious extrapolation, anyway
09:24:48 <shapr> There's a way to extrapolate an IPv4 address to a multicast IPv4 address?
09:25:02 <Heffalump> sorry?
09:25:13 <shapr> Class D addresses are multicast.
09:25:16 <Heffalump> no, I mean the obvious extrapolation from the definitions of class A,B,C
09:25:17 <Heffalump> oh, ok
09:25:24 <Heffalump> I didn't know it really existed
09:25:43 <Heffalump> right.
09:25:45 <shapr> Yeah, it does. I'm just doing some idle research into multicasting.
09:25:58 <Heffalump> doesn't really work properly with v4, AIUI
09:26:09 <Heffalump> anyway, are they actually globally assigned?
09:26:21 <shapr> It's part of the standard, but rarely supported because most routers can't handle it.
09:26:39 <shapr> I haven't gotten that far yet, no clue how they're assigned.
09:26:46 <SyntaxNinja> hey shapr, Lemmih
09:26:57 <SyntaxNinja> Lemmih: get a chance to look at cabal-install yet?
09:30:46 <Lemmih> I'll get time later today.
09:31:27 <SyntaxNinja> sweet
09:31:32 <SyntaxNinja> ping me w/ any questions
09:31:35 <ProfTeggy> G'night all
09:33:49 <jethr0> night
09:37:41 <ADEpt> Btw, who can help my with cabal-get-bootstrap?
09:39:45 <musasabi> I think multicast generally does not work with the current infrastructure which is a pity
09:41:17 <SyntaxNinja> ADEpt: what's the problem?
09:43:35 <prionic> hello there! is Either an instance of Monad?
09:44:23 <Heffalump> are you asking whether it is declared as one by the standard libraries, or whether it could be?
09:44:38 <prionic> declared
09:44:49 <Heffalump> I don't think so.
09:45:13 <Lor> _Anything_ can be declared as a monad.
09:45:18 <prionic> thanks, thought so... 
09:45:25 <musasabi> Control.Monad.Error defines and instance for Error e => Either e
09:45:35 <ADEpt> SyntaxNinja: i'm doing a clean "./install" before complaining, wait 2 mins please :)
09:45:48 <Heffalump> lor: I challenge you to declare () a monad.
09:45:51 <SyntaxNinja> ok
09:46:05 <Lor> instance Monad () where return x = (); () >>= f = ()
09:46:27 <Heffalump> lor: that's not well-kinded
09:46:30 <Lemmih> A '()' of kind '* -> *' ?
09:46:42 <prionic> musasabi: saw it but i wanted to use it as straight forward as Maybe. With Left working like Nothing.
09:46:58 <Heffalump> () doesn't have kind * -> *
09:46:58 <Lor> Ah, sorry. :)
09:47:05 <Heffalump> that was my point :-)
09:47:29 <Lor> But given a proper kind, and at least one element, you can define a dummy monad.
09:47:30 <musasabi> prionic: so how about instance Monad (Either ()) where ... ?
09:47:55 <Lor> So, the above should work for data Unit a = Unit
09:48:04 <prionic> musasabi: jupp ill do that
09:48:05 <Heffalump> lor: agreed.
09:48:22 <Lor> Not that this would be particularly useful...
09:48:38 <Saulzar> You can use Either like Maybe, except instead of "nothing" you can return an error
09:49:25 <SyntaxNinja> ADEpt: please email me w/ any problems you have
09:49:45 <ADEpt> SyntaxNinja: can I force ./install of cabal-get-bootstrap to install under /usr/local, not under /usr? And force it it uninstall everything it installed under /usr?
09:50:33 <ADEpt> SyntaxNinja: aha! got it:
09:50:33 <ADEpt> Running command: tar xzf cabal-get-0.2.1.tgz
09:50:33 <ADEpt> Running command: ghc --make -package Cabal Setup.lhs -o setup
09:50:33 <ADEpt> Chasing modules from: Setup.lhs
09:50:33 <ADEpt> Compiling Main             ( Setup.lhs, Setup.o )
09:50:33 <ADEpt> Setup.lhs:25:19: Not in scope: data constructor `CopyTo'
09:50:35 <ADEpt> Setup.lhs:26:19: Not in scope: data constructor `CopyPrefix'
09:50:37 <ADEpt> Setup.lhs:27:19: Not in scope: data constructor `NoCopyDest'
09:50:51 * ADEpt apologizes for overpost
09:51:08 <SyntaxNinja> ADEpt: yeah, bad cabal version :(
09:51:14 <SyntaxNinja> bugger
09:51:20 <SyntaxNinja> don't tell Igloo
09:52:33 <SyntaxNinja> ADEpt: grab the one from darcs, I think.
09:52:34 <Taral> @pl \f (x, y) -> (f x, f y)
09:52:35 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
09:52:39 <Taral> O.o
09:52:41 <Taral> not useful
09:52:44 <SyntaxNinja> I'll have to make cabal part of hte cabal-get-bootstrap script :(
09:52:48 <ADEpt> @where cabal
09:52:49 <lambdabot> http://www.haskell.org/cabal
09:52:56 <SyntaxNinja> hear that, Lemmih
09:53:38 <jethr0> what where the latex modes for haskell again?
10:01:01 <SyntaxNinja> "Official" hackage / cabal wiki & bug tracker here: http://hackage.haskell.org/trac/hackage/
10:03:48 <dcoutts> SyntaxNinja, is that linked from the main Cabal web page now? I couldn't find it when I was looking for the bug tracker the other day.
10:08:19 <ski_> prionic : you can also do 'instance Monad (Either e)'
10:09:11 <SyntaxNinja> dcoutts: not yet.
10:09:35 <SyntaxNinja> ADEpt: please fill in any cabal-get-bootstrap infolrmation that you learn here: http://hackage.haskell.org/trac/hackage/wiki/HackageTools
10:09:54 <SyntaxNinja> (click on CabalGetBootstrap and fill in info!) same for you, lemmih
10:09:59 <SyntaxNinja> and report bugs with this system.
10:13:43 <dcoutts> SyntaxNinja, I was trying to get the cabal-get ebuild working again, but the Setup.lhs in cabal-get-0.2.1 doesn't build with Cabal-1.1.3
10:28:26 <SyntaxNinja> dcoutts: bugger!
10:28:38 <SyntaxNinja> dcoutts: I think I'll release a 1.1.5 this weekend or something
10:29:22 <dcoutts> SyntaxNinja, oh right. But it's cabal-get that needs updating.
10:30:01 <dcoutts> what important in 1.1.5 compared to 1.1.3?
10:30:12 <dcoutts> Gentoo is using 1.1.3 atm.
10:31:23 <SyntaxNinja> dcoutts: some interface change,s bug fixes, and cabal-install
10:31:34 <dcoutts> SyntaxNinja, ah cabal-install
10:31:37 <SyntaxNinja> OK I pushed something new that works w/ 1.1.4, and MAYBE 1.1.3 + cabal-install
10:32:30 <SyntaxNinja> dcoutts: I possibly could just make it a branch, but not right this minute.  if this doesn't work with any sane version of cabal, then that'll be fixed over the weekend, I hope.
10:32:41 * SyntaxNinja &
10:32:43 <dcoutts> ok
10:32:58 <SyntaxNinja> I'm like 99.9% sure it'll work w/ darcs head
10:33:24 <SamB> shapr: how is that HTTP PUT repo coming along?
10:42:29 <soysauce> argh, I have a variable called ps of type [((i, i), j)], how can I force j to bind to Int64 without binding i?
10:43:07 <xerox> ((_,Int64):xs)
10:43:14 <SamB> xerox: eh
10:43:18 <SamB> that doesn't make sense
10:43:21 <Oejet> xerox: Say again?
10:43:27 <Oejet> :-P
10:43:31 <xerox> Uh
10:43:34 <SamB> Int64 isn't a data constructor
10:43:47 <xerox> okay
10:43:51 <SamB> or a variable name
10:45:06 <Igloo> _foo :: Int64; _foo = fst (head ps)
10:45:30 <Igloo> Err, IM snd of course
10:47:51 <soysauce> hm, that works. Is there no way to do it purely through a type signature, though?
10:48:15 <shapr> SamB: Haven't tried it yet... I may have time to try it tonight.
10:54:30 <ulfdoz> Sorry, when offtopic. But as most of you probably know the theory, I'll ask: I have a db-table Tree:{parent, child}, which represents a tree as list of its edges. I can describe a path as a list of edges, where the child of one edge is the parent in another. Is this expressiveness in relational Algebra, i.e. without loops and recursion?
10:54:41 <ulfdoz> s/expressiveness/expressible/
10:54:55 <Saulzar> Hmm, is there some way to pattern match a union type without matching all the args?  data Foo = A Int | B Int    foo x@A = ?
10:55:01 <Heffalump> is what precisely expressible that way?
10:55:19 <Heffalump> you can't answer the question "is A a descendant of B" without recursion, certainly.
10:55:42 <ulfdoz> Heffalump: I want to extract from the set of all edges Sets which only contain one path in the tree from the root to a leave.
10:56:07 <Heffalump> sorry?
10:56:17 * Heffalump doesn't follow that
10:56:18 <Taral> hm
10:56:36 <ulfdoz> It's a classification task with a decision tree.
10:57:13 <Taral> I have a (sorted) list of [(Int, a)] where Int is a list index and I want to convert it to [a]... is there some way to do this using standard operations, or do I have to write my own recursion?
10:57:34 <SamB> Saulzar: in GHC you can use {} instead of giving the args
10:57:34 <Taral> (actually, that's [Maybe a])
10:57:37 <Saulzar> Ah hah, I can do it with records..
10:57:45 <ulfdoz> Taral: map snd list?
10:57:48 <Saulzar> SamB, Thanks :)
10:57:51 <Heffalump> Taral: map snd?
10:57:54 <Taral> no, no
10:57:59 <SamB> you don't need records for this in GHC
10:58:03 <Taral> those Ints are the indices into the list
10:58:13 <SamB> it does that for normal constructors also
10:58:17 <Taral> so [(2, ())] => [Nothing, Nothing, Just ()]
10:58:22 <Heffalump> oh, so you want to make gaps where the indices are missing.
10:58:24 <Taral> yes
10:58:35 <Taral> I'm reconstructing a tables from a list of assertions :)
10:58:38 <Taral> *table
10:58:41 <Heffalump> I think any solution with standard operations would be more opaque than an explicit recursion.
10:58:44 <Taral> ok
10:58:48 <Saulzar> Ahh - well I was using records anyway, I just had about 10 elements, you can guess it might get a bit messy matching 10 _'s
10:59:10 <SamB> > case return undefined of Just {} -> True; Nothing -> False
10:59:11 <lambdabot> True
10:59:34 <SamB> which buys you nothing in this case, but does show that it works for non-record constructors
11:00:36 <Heffalump> ulfdoz: I'm still none the wiser about the problem you are trying to solve, btw.
11:01:25 <Heffalump> are you trying to make an SQL query that will find a path from the root to a given leaf?
11:02:12 <ulfdoz> Heffalump: Not an SQL-Query, an expression in relational algebra.
11:02:25 <ulfdoz> But yes, it is the task to find such a path.
11:02:50 <Heffalump> without recursion, it's not possible
11:03:53 <ulfdoz> Hm, so I need to code the path to the start-node of an edge into the schema.
11:09:08 <jethr0> i have converted "all about the monads" to pdf... if anyone is interested: http://84.163.122.237/haskell/AllAboutTheMonads.pdf
11:09:31 <ulfdoz> jethr0: thx.
11:09:38 <SamB> jethr0: does it have bookmarks?
11:10:13 <jethr0> no, but maybe i could add them. i got the latex source, though...
11:10:33 <SamB> you need to use the hyperref package and pdfLaTeX for that, I think.
11:10:35 <ulfdoz> \\usepackage{hyperref} should be all, which is needed.
11:10:46 <SamB> or at least, that is the easiest way
11:10:47 <jethr0> i'll try that, just a moment
11:10:50 <ulfdoz> And include it last in package-list.
11:12:14 <jethr0> now it does...
11:12:18 <SamB> if you use LaTeX running under normal TeX, it doesn't know what you plan to do with the DVI file, and so can't know how to encode those without being told explicitly
11:12:28 <jethr0> using pdflatex
11:12:30 <tibbe> what would be a good way to signal that an update of a value associated with a key in a map failed because the key doesn't exists in the map?
11:12:49 <tibbe> returning Maybe Map sounds like a not so good idea
11:12:59 <SamB> tibbe: in what context?
11:13:06 <SamB> to whom or what?
11:13:44 <jethr0> could i host that pdf anywhere more decent?
11:14:46 <SamB> jethr0: well, you might be able to attach it to the wiki
11:14:54 <jethr0> yes, i might
11:15:03 <tibbe> SamB, well, I have a stack of Maps where I want to update the first map (from the top) that contains the key and return some indicator if the key wasn't in any of the maps
11:15:16 <SyntaxNinja> dcoutts, ADEpt I'm back for a minute, any cabal-get-bootstrap q's?
11:15:21 <SamB> if not hawiki, tmrwiki for sure!
11:15:32 <SamB> tibbe: oh
11:15:44 <SamB> you implementing an imperative langauge?
11:15:46 <tibbe> update :: Var -> Value -> [Data.Map.Map] -> [Data.Map.Map]
11:15:51 <tibbe> SamB, yes :)
11:15:57 <tibbe> it's for scoping
11:16:09 <ADEpt> SyntaxNinja: can I make it to install uder /usr/local?
11:16:11 <tibbe> i used a [[(a,b)]] before changing it to a map
11:16:24 <SamB> tibbe: I would use monads and ErrorT
11:16:54 <SamB> or something of that nature
11:16:57 <SyntaxNinja> ADEpt: you'd have to modify the script.  I just did an upload that vastly simplifies the script, but it requires the latest cabal (from darcs)
11:17:02 <tibbe> SamB, the rest of the code is non monadic
11:17:02 <SyntaxNinja> OK sorry,g otta run again :(
11:17:11 <SamB> and throw the equivalent of Python's NameError...
11:17:30 <ADEpt> SyntaxNinja: i got cabal from debian/unstable (1.1.3). I take it that is it too old nevertheless, right?
11:17:39 <ADEpt> SyntaxNinja: ok
11:17:47 <tibbe> SamB, I'm not very familiar with the Error monad, Does it return a Left Error Right Okay or something like that?
11:17:53 <cjb> xerox: Around?
11:18:01 <xerox> cjb: yessir
11:18:33 <SamB> tibbe: me either
11:18:35 <cjb> xerox: Could you kill/restart your ginsu, please?  I had to kick the galed, and ginsu doesn't cope well with it disappearing temporarily.
11:18:41 <SamB> but it is presumably good for something ;-)
11:18:46 <tibbe> :)
11:18:51 <cjb> (Our ginsus are competing for 100% CPU at the moment.  :)
11:19:09 <xerox> oh, sorry
11:19:25 <xerox> killed
11:19:39 <cjb> It's fine, not your fault.  It's the first time there's been a galed problem in a year or so, it doesn't happen often.
11:19:41 <SamB> though if I ever used it I would probably have been using a stack of monads already, and just throw ErrorT on the top...
11:19:49 <tibbe> SamB, I don't really like to have to propagate errors all the way to the interpreter but I guess I'll have to
11:20:07 <xerox> cjb: is it safe to run it again now?
11:20:08 <SamB> tibbe: the other option is to use error
11:20:25 <SamB> > error "foo'd the wrong bar"
11:20:26 <lambdabot> Add a type signature
11:20:27 <cjb> xerox: Yup!
11:20:32 <xerox> cjb: ok, great.
11:20:35 <tibbe> SamB, yeah, and that makes it less generic so I think I'll go with Error
11:20:37 <SamB> > error "foo'd the wrong bar" :: String
11:20:39 <lambdabot> Exception: foo'd the wrong bar
11:20:42 <tibbe> SamB, :D
11:21:04 <tibbe> @type Data.Map.lookup
11:21:06 <lambdabot> forall a (m :: * -> *) k.
11:21:06 <lambdabot> (Ord k, Monad m) =>
11:21:06 <lambdabot> k -> Data.Map.Map k a -> m a
11:21:23 <tibbe> SamB, the lookup function in Map returns something in a monad
11:21:42 <SamB> @type Data.Map.update
11:21:43 <lambdabot> forall a k.
11:21:43 <lambdabot> (Ord k) =>
11:21:43 <lambdabot> (a -> Maybe a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
11:21:44 <tibbe> SamB, I'll guess I'll have to read up on error in the wiki
11:22:09 <tibbe> the update isn't really nice, it's really a insert or update
11:22:15 <SamB> ah
11:22:56 <tibbe> one could do an "adjust" then see if the size change but that's really slow I think, and feels a bit stupid
11:23:08 <tibbe> since adjust just returns the map as is if it's not changed
11:23:13 <tibbe> @type Data.Map.adjust
11:23:15 <lambdabot> forall a k.
11:23:15 <lambdabot> (Ord k) =>
11:23:15 <lambdabot> (a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
11:26:41 <Taral> @pl \x y -> y
11:26:42 <lambdabot> const id
11:27:01 <Taral> @pl \x y -> Just y
11:27:02 <lambdabot> const Just
11:27:54 <SamB> @pl const id . Just
11:27:55 <lambdabot> const id
11:31:00 <Taral> @pl \a b c -> (a c) (b c)
11:31:01 <lambdabot> ap
11:31:04 <Taral> heh
11:31:13 <Taral> ap const id = S K I
11:31:27 <tibbe> SamB, hmm, one could return a pair (Bool, Map) but that doesn't really feel Haskellish
11:31:37 <Taral> so that's how it works
11:34:30 <Taral> @type delete
11:34:32 <lambdabot> Not in scope: `delete'
11:34:34 <Taral> @type List.delete
11:34:36 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
11:34:53 <ulfdoz> Ok, I deserved my beer. Nice evening. :)
11:38:47 <ADEpt> @hoogle concatMapM
11:38:48 <lambdabot> No matches found
11:39:16 <jethr0> samb, is tmrwiki shapr's?
11:39:19 <ADEpt> @type (liftM concat).mapM
11:39:20 <lambdabot> Not in scope: `liftM'
11:39:48 <ADEpt> @type (Cntrol.Monad.liftM concat).Control.MonadmapM
11:39:49 <lambdabot> Couldn't find qualified module.
11:39:49 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
11:39:49 <lambdabot> \\)?
11:39:57 <Taral> @type (fmap concat) . mapM
11:39:58 <lambdabot> forall a b. (Functor ((->) [a])) => (a -> [b]) -> [a] -> [b]
11:40:20 <ADEpt> @type (Cntrol.Monad.liftM concat).mapM
11:40:22 <lambdabot> Couldn't find qualified module.
11:40:22 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
11:40:22 <lambdabot> \\)?
11:40:36 <ADEpt> @index liftM
11:40:37 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
11:40:37 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
11:40:37 <lambdabot> Control.Monad.Error, Control.Monad.List
11:40:37 <ndm> @type (Control.Monad.liftM concat).mapM
11:40:38 <lambdabot> forall a b. (Monad ((->) [a])) => (a -> [b]) -> [a] -> [b]
11:40:50 <ndm> you misspelt Control
11:41:09 <ADEpt> ndm: thnx!
11:43:55 <tibbe> you ever had the feeling when you cannot pick one solution from a list of several equaly good (bad) solutions?
11:44:46 <jethr0> tibbe, not really. there's usually a trade-off
11:46:19 <jethr0> @seen shapr
11:46:20 <lambdabot> shapr is in #haskell and #ScannedInAvian. Last spoke 58 minutes and 4
11:46:20 <lambdabot> seconds ago.
11:47:09 <tibbe> jethr0, guess I can't see it yet, I'm doing an update and want to communicate the fact that something actually was updated (or not)
11:47:50 <jethr0> ok
11:48:34 <tibbe> one could do: (flag, data structure), Error monad etc
11:48:52 <tibbe> flag would be easiest but I really don't like flags
11:49:46 <jethr0> my understanding of specialized monads is yet very limited :( i think i'm gonna read the "all about the monads" tut right now!
11:50:01 <tibbe> do that, it's good
11:57:33 <Taral> @type Control.Monad.ST.stToIO
11:57:35 <lambdabot> forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
12:15:08 <SamB> jethr0: shapr administered both hawiki and tmrwiki last I knew 
12:18:02 <jethr0> ah, ok
12:18:34 <jethr0> coz i can't upload on hawiki and can't create a page on tmr, but i guess i'll just ask shapr
12:18:44 <SamB> jethr0: have you registered on tmr?
12:18:52 <SamB> it works better if you register ;-)
12:18:56 <jethr0> i have
12:19:02 <SamB> hmm.
12:19:07 <astrolabe> hawiki too
12:19:15 <astrolabe> and logged yourself on?
12:19:29 <SamB> tried naming the page after your login?
12:20:01 <jethr0> logged in. in hawiki i can create pages but not upload (because it's not enabled) and on tmr i can't even create a new page
12:21:06 <SamB> huh!
12:21:19 <SamB> shapr: help!
12:21:24 <SamB> @get-shapr
12:21:25 <lambdabot> shapr!!
12:21:32 <jethr0> i can wait :)
12:21:51 <jethr0> it's not as if i had a life :)
12:22:18 * SamB thinks we need to wire this to some kind of electrodes or something
12:22:23 <Taral> heh
12:22:26 * jethr0 agrees
12:22:43 <jethr0> but maybe a really annoying audible message would suffice
12:23:55 <jethr0> what's the difference between hawiki and tmr if shapr administers both?
12:24:32 <Cale> There is a way to actually annoy shapr from IRC, but I forget what it was :)
12:24:39 <SamB> tmrwiki has uploads
12:24:59 <SamB> maybe "/CTCP shapr bug"?
12:27:10 <Lemmih> @getshapr ?
12:27:11 <lambdabot> shapr!!
12:28:26 <Cale> ctcp page
12:28:30 <SamB> Lemmih: you spelled it wrong I think
12:28:48 <jethr0> never mind. he's bound to come back sooner or later
12:28:48 <Cale> Nov 10 07:47:22 <shapr>	If you want real functionality, you can use ctcp page. My emacs usually woofs when that happens.
12:29:15 * SamB thinks shapr's emacs is confused about its identity
12:30:08 <ADEpt> SamB: yes it is, but it like a good walk and scratch behind the ear nevertheless
12:30:21 <SamB> hehe
12:30:21 <ADEpt> ^like^likes^
12:35:30 <SamB> ADEpt: how is the IST coming?
12:35:47 <SamB> or should I ask, what does it do?
12:37:12 <ADEpt> SamB: i am not sure. have time to talk about that?
12:38:24 <SamB> as far as I know.
12:38:38 <SamB> which is to say, unless my mother makes me do something
12:39:56 <ADEpt> :)
12:40:34 <lightstep> i wonder what happened to that penrose tiles types project from a few months ago
12:40:41 * lightstep checks tmr issues
12:41:16 <ADEpt> So, first thing that bugs me in RequestedFromSeeder vs RequestedFromLeecher messages (which eventually modify InterestTable differently). Does the PeerThread supposed to know where he requests from seeder or leecher?
12:42:00 <SamB> well, why do you have both of them?
12:42:44 <ADEpt> SamB: the same thing goes to "nextPiece" from InterestTable - how the caller (PeerThread) is supposed to know whether it is seeding or not, and why this is needed in the first place, and why 'nextPiece YesWeAreSeeding' does not return Nothing without any further checks?
12:43:17 <ADEpt> SamB: I dont know. That was jlouis's idea, he probably got it from "official" bittorrent or something.
12:43:31 <SamB> hmm, perhaps PeerThread isn't supposed to call nextPiece directly?
12:44:11 <SamB> I'd think the IST would be in a position to know all these things.
12:44:12 <ADEpt> SamB: I started to modify InterestTable to accept availability information for pieces and convert it into availability information for blocks, and immediately bumped into those questions.
12:44:28 <ADEpt> SamB: if PeerThread is not supposed to call it, then who does?
12:44:53 <SamB> well, I see here a constructor "NextPiece (PieceNum -> Bool) (Maybe PieceNum -> IO ())"
12:45:13 <SamB> not sure what the first part is for...
12:46:23 <ADEpt> this is basically a set of PieceNum's that PeerThread is choosing between.
12:46:54 <SamB> oh, I guess he was thinking the PeerThread would know what pieces the peer had
12:47:01 <ADEpt> supposed to be True for each piece that PeerThread could start to download as soon as IST confirms that.
12:48:43 <jethr0> this simon p jones guy has written more papers than i've ever read... and that's saying a lot :)
12:49:26 <ADEpt> SamB: but without knowing which pieces there are PeerThread could not deduce who is seeder and who is leecher. And I cant see why this is important anyway :(
12:49:27 <SamB> well, I think the idea is that there are several pieces which are in-progress and you assign various blocks in those pieces to the various PeerThreads
12:49:42 <SamB> ADEpt: well, take it out then ;-)
12:49:54 <SamB> we can add it when we need it, somehoqw
12:49:58 <SamB> s/q//
12:50:20 <SamB> just say "Requested"
12:50:57 <SamB> hmm.
12:51:20 <SamB> I don't think we'll be wanting PieceCompleted
12:51:31 <SamB> want me to hack it about some?
12:54:05 <ADEpt> SamB: but what is seed_started in InterestTable then?
12:54:50 <SamB> ADEpt: I have no idea
12:55:52 <SamB> lets just pretend everything is a leacher?
12:56:14 <ADEpt> SamB: ah. from the comments to pieceRequested it seems like it has something to do with endgame madness.
12:56:40 <SamB> why is InterestTable dealing with what was requested...
12:57:04 <ADEpt> SamB: but then the names are not correct. Should be smth like 'shouldBeRequestedFromSeeder'... Too bad I dont know about endgame much
12:57:19 <ihope> Indeed: no IO data constructor.
12:57:50 <SamB> ihope: actually, there often is one. but its nonstandard and secret.
12:58:25 <ADEpt> SamB: still, does not make much sense :(
12:59:04 <ADEpt> SamB: I'd say if we dont understand it, we hack it out. Will you?
12:59:11 <SamB> where is jlouis when you need him?
12:59:25 <SamB> hmm
12:59:43 <Cale> endgame?
13:00:17 <ihope> Hey, how is "Haskell" pronounced?
13:00:29 <SamB> Cale: thats where you request blocks from multiple sources in an effort to finish the download in a reasonable amount of time
13:01:08 <jethr0> ihope, it's like a sneezing sound :)
13:01:16 <ihope> :-)
13:01:26 <SamB> maybe we should comment out requested entirely?
13:01:34 <ihope> I wonder what Mr. Curry thought of it...
13:01:39 <Philippa> ihope: I mostly pronounce it to rhyme with Pascal, though I know a lot of people who pronounce the e differently
13:01:56 <ADEpt> SamB: for the time being, yes
13:02:00 <jethr0> maybe it was a hip name back in his days
13:02:47 <Cale> I've heard lots of people (myself included) not pronounce the 'e' much at all.
13:02:59 <SamB> I guess we should comment out those two constructors both, since the code for them calls that stuff
13:03:08 <flux__> ihope, maybe you'll find discussion on that matter from google (from #haskell logs)
13:03:12 <Cale> (perhaps a schwa)
13:03:24 <flux__> not long ago the same thing popped up
13:03:28 <ADEpt> SamB: yep
13:04:46 <Cale> SamB: hmm, finish the download in a reasonable amount of time -- exactly like what Azureus is not doing for me at the moment. 99.3% finished and the download has slowed to 122 B/s
13:06:12 <SamB> Cale: is it written in Java?
13:06:15 <Cale> (okay, so it's averaging around 4 kB/s, but that's still a lot slower than it was, and there are plenty of seeders)
13:06:18 <Cale> I think so
13:06:50 <ADEpt> Cale: joing bandwagon and write yourself bt client in haskell ;)
13:06:53 <SamB> maybe its authors don't know endgame either?
13:08:01 <ADEpt> SamB: could you also take a look at type Interests in InterestTable?
13:08:29 <ADEpt> SamB: why should we need such a map?
13:08:42 <SamB> ADEpt: yes?
13:08:47 <SamB> the comment is not very good
13:09:18 <Cale> I don't know -- could just be that I need to bring my ratio back in line on the torrent too. It's an otherwise pretty nice client. Supports multiple simultaneous transfers, you can assign specific priorities to files, has really nice supersampled graphical display bars :)
13:09:25 <SamB> ADEpt: well, thats what nextPiece goes through to find the next piece to start on...
13:10:28 <ADEpt> Cale: and you can't leave in running in "screen" on that rusty router you have in the basement :(
13:10:47 <ADEpt> SamB: maybe, you can demangle the comment?
13:10:51 <SamB> ADEpt: I absolutely do not understand the point of these started/requested things
13:11:03 <Cale> My router is one of those appliance things you can't run anything on anyway :)
13:11:40 <Cale> Though I wish that I could transfer X programs from place to place while they were running.
13:12:40 <ADEpt> Cale: x11vnc does something like that. Something, but not quite.
13:13:32 * ADEpt feels suddenly scared by InterestTable
13:13:56 <SamB> ADEpt: it looks like we'll need to add a new data structure to track blocks in in-progress pieces
13:17:08 <ADEpt> SamB: yep. I'm trying to at least declare them in the InterestTable right now.
13:17:48 <SamB> we don't want the interest table dealing with blocks, methinks
13:20:29 <ADEpt> SamB: hmm?
13:22:16 <SamB> it seems like having the interest table worry about blocks would be too much complexity for one module.
13:22:18 * ADEpt stares in the "official" BT. How they distinguish "piece" (short) and "piece" (long) there????
13:23:11 <SamB> ADEpt: pull away
13:24:24 <jethr0> samb, you working on a bittorrent app?
13:24:41 <SamB> jethr0: we are, yes
13:24:47 <jethr0> kewl
13:25:46 <jethr0> how far into it?
13:25:47 <ADEpt> jethr0: join! :)
13:25:56 <jethr0> sure, where do i have to go?
13:25:57 <SamB> ADEpt: I think we should start a module called WorkTable or something like that that keeps track of which pieces we are working on and what blocks are assigned
13:26:36 <Heffalump> interestingly, I find myself needing to solve Taral's problem myself
13:26:38 <ADEpt> @where conjure
13:26:39 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
13:26:52 <ADEpt> jethr0: there
13:27:04 <SamB> % grep Repo AUTHORS
13:27:04 <SamB> Repo: http://j.mongers.org/pub/haskell/darcs/conjure/
13:27:04 <SamB> Repo: http://adept.homeunix.net/conjure
13:27:04 <SamB> Repo: http://naesten.dyndns.org:8080/repos/conjure-SamB # Warning: 56k dialup!
13:27:04 <ADEpt> jethr0: darcs pull from there.
13:27:49 <ADEpt> SamB: I believe it would be our InterestTable, only redone from scratch, no?
13:28:05 <SamB> ADEpt: well, not really.
13:28:06 <mjl69_> I put together some functions for practice, and I plugged in a very large number for one parameter which GHC was not able to evaluate in a timely manner.  I would have imagined it to be possible to evaluate it in a lazy fashion very quickly.  http://rafb.net/paste/results/JRZsfc10.html
13:28:06 <jethr0> is there a todo list / what concretely are you working on?
13:28:59 <SamB> ADEpt: it would only keep track of what pieces are in progress, which blocks in them are assigned, and which are done
13:29:02 <ihope> Hmm, I'm stuck in #haskell.
13:29:45 <ADEpt> SamB: why separate this from InterestTable?
13:29:59 <ADEpt> jethr0: there is TODO, but it is slightly outdated.
13:30:32 <SamB> ah
13:30:32 <SamB> too distracting for you, eh?
13:30:32 <jethr0> mjl69_, maybe evaluating a lazy list with 10000000000000000000 elements just takes its time!
13:30:33 <jethr0> oh, and "splice = (>x)"
13:30:33 <SyntaxNinja> y0
13:30:38 <SamB> > [1..10000000000000000000]
13:30:40 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
13:30:40 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
13:30:40 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
13:30:40 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
13:30:40 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
13:30:42 <lambdabot> [24 @more lines]
13:30:58 <Saulzar> Also it fits in 30 lines
13:31:03 <SamB> ADEpt: Seperaton of Concerns
13:31:09 <SamB> er, Seperation
13:31:27 <SamB> also, InterestTable gives me a headache
13:31:27 <sieni> lambdabot is probably the fastest known program in calculating the infinite loop
13:31:54 <ihope> No program can calculate certain infinite loops...
13:31:56 <SamB> > loop = loop
13:31:58 <lambdabot>  parse error on input `='
13:32:05 <SamB> > loop where loop = loop
13:32:07 <lambdabot> Add a type signature
13:32:08 <sieni> ihope: sure, look:
13:32:14 <ihope> (But "certain" is probably the wrong word.)
13:32:16 <sieni> > [1..]
13:32:16 <SamB> > let loop = loop in loop
13:32:17 <Saulzar> << loop >>
13:32:17 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
13:32:17 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
13:32:17 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
13:32:17 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
13:32:17 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
13:32:19 <lambdabot> [24 @more lines]
13:32:21 <lambdabot> Add a type signature
13:32:36 <ADEpt> SamB: completely agree on last one :) 
13:32:41 <sieni> ihope: she did it in finite time
13:32:43 <lightstep> let {loop :: a; loop = loop} in loop
13:32:45 <lightstep> > let {loop :: a; loop = loop} in loop
13:32:47 <lambdabot> Add a type signature
13:32:51 <SamB> ADEpt: and adding to it would just make things worse
13:33:03 <SamB> which is my REAL motivation
13:33:20 <ihope> But there are loops which no program can detect.
13:33:35 <jethr0> > fix id :: Int
13:33:36 <lambdabot> Exception: <<loop>>
13:33:39 <SamB> > let loop = loop in loop :: Int
13:33:41 <lambdabot> Exception: <<loop>>
13:33:44 <mjl69_> jethr0: but if GHC had near-human intelligence, it would have seen that a only a tiny slice of the list will be asked for, so no need to calculate the whole list.
13:33:54 <SamB> > fix (+1)
13:33:56 <lambdabot> Exception: <<loop>>
13:34:02 <SamB> heh
13:34:14 <Saulzar> > "Exception: <<loop>>"
13:34:16 <lambdabot> "Exception: <<loop>>"
13:34:21 <xerox> Unfair :-)
13:34:22 <jethr0> mjl69_, but you are filtering the entire list and then printing it! (or am i missing sth?)
13:34:26 <ihope> But you still haven't tried *all* the loops.
13:34:34 <SamB> well
13:34:39 <SamB> > last [1..]
13:34:46 <lambdabot> Terminated
13:34:49 <mjl69_> that's true.
13:34:50 <jethr0> > init [1..]
13:34:52 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
13:34:52 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
13:34:52 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
13:34:52 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
13:34:52 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
13:34:54 <lambdabot> [24 @more lines]
13:35:01 <jethr0> huh?
13:35:06 <SamB> jethr0: its lazy
13:35:26 <jethr0> how can you drop the last element of an infinite list?
13:35:29 <SamB> it just has make sure there is at least another element before it returns that one
13:35:32 <ihope> "True" lazy evaluators don't evaluate at all.
13:35:38 <Saulzar> lambdabot can answer the question of What is the last thing in the universe?
13:35:50 <mjl69_> would it make a difference if the mklist function was defined in a clause within the mycut function?  Probably not.
13:35:55 <SamB> jethr0: well, you just keep going along and checking if you've reached the last one.
13:35:59 <ihope> > thelastthingintheuniverse
13:36:00 <SamB> if you have, you drop it.
13:36:00 <lambdabot>  Not in scope: `thelastthingintheuniverse'
13:36:00 <lightstep> Saulzar, yes, but it'd wait until the end of the universe (it's lazy)
13:36:07 <ihope> Or did you mean:
13:36:12 <ihope> > last "the universe"
13:36:14 <lambdabot> 'e'
13:36:39 <jethr0> mjl69_, no. what were you trying to do? you are not stopping to evaluate the list at any element!
13:36:56 <jethr0> mjl69_, maybe you want takeWhile
13:37:02 <jethr0> @type takeWhile
13:37:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:37:05 <lightstep> mjl69_, if you filter a list of 1E20 elements and force all of it, it'd take 1E20 time
13:37:07 <SamB> if you haven't, you return x:init xs
13:37:16 <SamB> if you have, you return []
13:37:20 <jethr0> > takeWhile (<20) [1..]
13:37:21 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
13:37:43 <mjl69_> jethr0: thanks, I'll look at that.  I don't have any specific goal, just experimenting with the basics to get a feel for things.
13:37:45 <ihope> > seq [1..] (head [1..])
13:37:47 <lambdabot> 1
13:37:52 <ihope> Yo!
13:38:01 <Saulzar> > filter (\x -> False) [1..]
13:38:04 <SamB> lambdabot can't answer the question of "what is the last thing in the universe"
13:38:06 <lambdabot> Terminated
13:38:16 <SamB> because lambdabot is not only lazy but also impatiant
13:38:19 <ihope> 'e' is the last thing in the universe.
13:38:29 <jethr0> why did the "seq" work?
13:38:31 <lightstep> ihope, seq doesn't do what you might think it does
13:38:50 <lightstep> seq doesn't force the "whole" result, just the topmost box
13:38:50 <SamB> ADEpt: so, do you think we should do it?
13:38:54 <jethr0> i guess it only brings it into normal form
13:38:56 <lightstep> box as in "unboxed"
13:39:01 <Taral> jethr0: whnf
13:39:07 <jethr0> yup
13:39:24 <SamB> why the "weak"?
13:39:28 <ihope> lightstep: what *does* it do?
13:39:49 <mjl69_> so tail [1..] will take a very long time to finish then
13:40:18 <SamB> mjl69_: define finish
13:40:54 <mjl69_> complete the evaluation of the expression
13:40:56 <Saulzar> Hmm, tail [1..] will give you another lazy list, in itself which will take constant time
13:40:57 <lightstep> ihope, to reduce (seq x y), haskell reduces x to weak head normal form (whnf), and than replaces it (the seq) with y
13:40:59 <rashakil> > tail [1..]
13:41:01 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
13:41:01 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
13:41:01 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
13:41:01 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
13:41:01 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
13:41:03 <lambdabot> [24 @more lines]
13:41:43 <Taral> SamB: weak because it doesn't insist that the contents of a datatype be in hnf
13:41:56 <Taral> > let a = Maybe undefined in a `seq` a
13:41:58 <Saulzar> > takeWhile (<10) $ tail [1..]
13:41:58 <lambdabot>  Not in scope: data constructor `Maybe'
13:41:59 <lambdabot> [2,3,4,5,6,7,8,9]
13:42:02 <Taral> > let a = Just undefined in a `seq` a
13:42:03 <lambdabot> Add a type signature
13:42:10 <Taral> > let a = Just undefined :: Maybe Int in a `seq` a
13:42:12 <lambdabot> Undefined
13:42:15 <Taral> hm
13:42:28 <Taral> > let a = Just (Just undefined) :: Maybe (Maybe Int) in a `seq` a
13:42:29 <lambdabot> Undefined
13:42:31 <Taral> !
13:42:38 <Taral> I was sure that seq was weak only
13:42:44 <Taral> oh, duh
13:42:49 <Taral> > let a = Just undefined :: Maybe Int in a `seq` ()
13:42:51 <lambdabot> ()
13:43:13 <xerox> > let a = Just undefined in a `seq` ()
13:43:15 <lambdabot> ()
13:43:33 <xerox> > undefined `seq` ()
13:43:35 <lambdabot> Undefined
13:43:47 <ADEpt> SamB: I think that we should do something simple :) Concert: right now we have PeerThread with reports what he thinks is available on the other end and expects to be told what to do next. There should be some sort of priority queue which is being consulted before telling each particular thread what to do. Right?
13:44:15 <xerox> Howdy, franka.
13:44:22 <SamB> ADEpt: priority queue, you say?
13:44:25 <franka> 'lo, xerox.
13:45:16 <ADEpt> SamB: So, if that is right, I have a naive question: why not transform .torrent into huge list of (priority, (piece, offset, length)), use information, obtained from peers, to modify priority, and upon "what should I do next" just pull from that queue?
13:45:21 <ihope> So is there a way to pattern match with lambdas?
13:45:38 <Saulzar> ihope, Just as with normal functions
13:45:39 <SamB> ADEpt: that sounds really slow
13:46:04 <SamB> not to mention probably almost as complicated as what we have now.
13:46:08 <Saulzar> > (\(x, y) -> x + y) (10, 20)
13:46:10 <lambdabot> 30
13:46:19 <SamB> we'll just have to chastise jlouis for making things too complicated ;-)
13:46:29 <jethr0> > (\(Just a) -> a) (Just 5)
13:46:31 <lambdabot> 5
13:46:32 <ADEpt> SamB: on the first glance, what was being done in "official" BT strikes me like something overcomplicated. And that overcomplication crawled right into InterestTable.
13:46:40 <ADEpt> @seen jlouis
13:46:40 <ihope> I think I get it...
13:46:41 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
13:46:41 <lambdabot> spoke.
13:46:48 <SamB> ADEpt: there you go!
13:46:59 <SamB> he shouldn't have been reading the client!
13:47:10 <ADEpt> SamB: well, I'll settle for something slow and simple, and then convert it into complex and fast :)
13:47:10 <ihope> But what if there are multiple cases you want to check for?
13:47:17 <SamB> damn free software licenses...
13:47:50 <ADEpt> jethr0: so, have you got it (code, I mean)?
13:48:05 <lightstep> ihope, a case expression?
13:48:33 <lightstep> @pl \x -> case x of Left a -> Right a; Right a -> Left a
13:48:34 <lambdabot> (line 1, column 24):
13:48:34 <lambdabot> unexpected ">" or "-"
13:48:34 <lambdabot> expecting variable, "(", operator or end of input
13:48:52 <lightstep> @pl \x -> case x of {Left a -> Right a; Right a -> Left a}
13:48:53 <lambdabot> (line 1, column 17):
13:48:53 <lambdabot> unexpected "{"
13:48:53 <lambdabot> expecting variable, "(", operator or end of input
13:48:57 <lightstep> @type \x -> case x of {Left a -> Right a; Right a -> Left a}
13:48:59 <lambdabot> forall b b1. Either b1 b -> Either b b1
13:49:05 <jethr0> adept, sure, reading STYLE right now
13:49:51 <ADEpt> jethr0: you could even compile it and launch with "conjure -v some.torrent". With luck, something will happen :)
13:50:03 <jethr0> already compiled
13:51:22 <jethr0> "We will rather have 8k lines of source code with opportunity for polishing than 500 lines of perfect code."
13:51:25 <jethr0> i don't get it
13:52:04 <ADEpt> jethr0: means that we will not aiming to win shortest-and-most-obfuscated-code contest :)
13:52:18 <ADEpt> jethr0: rather, most-readable-code contest :)
13:52:33 <jethr0> hmm
13:52:38 <ihope> > (concat . intersperse '\n' . words) "jethr0: you mean like this?"
13:52:39 <lambdabot> Couldn't match `Char' against `String'
13:52:44 <ihope> Heh
13:52:52 <SamB> or maybe jlouis did that when he was asleep ;-)
13:53:11 <jethr0> > (concat . intersperse "\n" . words) "jethr0: you mean like this?"
13:53:12 <ihope> > (concat . intersperse "\n" . words) "jethr0: you mean like this?"
13:53:12 <Saulzar> Then your 8k lines will be perfect by your criteria...
13:53:13 <lambdabot> "jethr0:\nyou\nmean\nlike\nthis?"
13:53:14 <lambdabot> "jethr0:\nyou\nmean\nlike\nthis?"
13:53:31 <jethr0> :)
13:53:44 <SamB> I've got a start on WorkTable which I'm recording right now
13:53:58 <ihope> > error "Exceptional condition!" :: Int
13:54:00 <lambdabot> Exception: Exceptional condition!
13:54:02 * ADEpt waits for a pull
13:54:43 <ihope> > (concat . intersperse " " . words) "This  is    teh   \nw00tness"
13:54:45 <lambdabot> "This is teh w00tness"
13:54:51 <SamB> okay, its recorded
13:55:20 <jethr0> > (unwords . filter (/=' ') . words) "This  is    teh   \nw00tness"
13:55:21 <lambdabot> Couldn't match `Char' against `String'
13:55:31 <xerox> > error "Exceptional condition!"
13:55:32 <jethr0> > (unwords . . words) "This  is    teh   \nw00tness"
13:55:32 <lambdabot>  lexical error
13:55:33 <lambdabot>  parse error on input `.'
13:55:35 <jethr0> > (unwords . words) "This  is    teh   \nw00tness"
13:55:37 <lambdabot> "This is teh w00tness"
13:55:49 <jethr0> *argh*
13:56:01 <xerox> creat
13:56:05 <xerox> *Great
13:56:51 <ihope> > unwords ["Hello, world!"]
13:56:53 <lambdabot> "Hello, world!"
13:57:18 <SamB> and pulled into my web-visible repo
13:57:25 <SamB> ADEpt: pull and review?
13:58:34 <ADEpt> SamB: btw, what about cutting the time needed to get "inventory"? have you found some means?
13:58:46 <SamB> ADEpt: hmm.
13:58:57 <SamB> I think it was darcs optimize --something-or-other?
13:59:22 <boegel|home> does anyone know how I get the string "~." to appear using LaTeX, _without_ the ~ standing above the dot ?
13:59:36 <SamB> perhaps after a tag?
13:59:51 <SamB> ADEpt: should we update the version number/name?
14:00:10 <SamB> and tag?
14:00:33 <ADEpt> SamB: like "0.0.0.1.inventory.was.too.long"?  I agree :)
14:02:29 <ihope> Hmm... this factorial function chokes when given the value 2.
14:02:29 <SamB> well, it looks like we'd do something more along the lines of 2005.12.15-VERB-ENDING-IN-ING
14:03:25 <ADEpt> SamB: "-WASTING" ? :) Because we wast bytes that we download?
14:04:06 <Cale> ihope: which factorial?
14:04:13 <SamB> ADEpt: sure, whatever
14:04:34 <SamB> shall I or would you like to do it?
14:05:13 <ADEpt> SamB: do, please
14:05:18 <ihope> let fix x = (x . fix) x in fix (\x -> \y -> case y of { 1 -> 1 ; _ -> y * x y }) 1
14:05:29 <ADEpt> SamB: i'm still trying to pull your previous patch
14:06:33 <SamB> ADEpt: ah
14:06:41 <SamB> oh, theres a list of names in the file
14:06:48 <SamB> but wasting sounds good to me
14:08:32 <Taral> ihope: fix exists
14:08:35 <Taral> @type fix
14:08:36 <lambdabot> Not in scope: `fix'
14:08:39 <Taral> @hoogle fix
14:08:41 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:08:41 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
14:08:41 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
14:09:22 <franka> boegel|home: \~{ }.
14:13:00 <lightstep> > Control.Monad.Fix.fix (\fact n -> if n == 0 then 1 else n * fact n)
14:13:02 <lambdabot>  add an instance declaration for (Show (a -> a))
14:13:12 <lightstep> > Control.Monad.Fix.fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
14:13:13 <lambdabot> 120
14:13:46 <lightstep> ihope, perhaps you miss the (subtract 1)
14:14:03 <ihope> lightstep: yes, definitely!
14:16:21 <SamB> hmm. Okay, should work now, but you might have to do a "darcs get" for yours to also be like this
14:17:23 <jethr0> > let fac = (scanl1 (*) [1..] !!) in fac 5
14:17:25 <lambdabot> 720
14:17:39 <rashakil> 0..
14:17:43 <jethr0> ups
14:17:46 <jethr0> > let fac = (scanl1 (*) [0..] !!) in fac 5
14:17:47 <lambdabot> 0
14:17:50 <rashakil> er.. :/
14:17:53 <jethr0> *argh*, fooled me
14:18:00 <SamB> which is undeniably a bad thing
14:18:00 <SamB> ADEpt: okay?
14:18:00 <SamB> especially when my sister is trying to read webcomic
14:18:00 <SamB> s
14:18:01 <jethr0> it's not even true!
14:18:21 <jethr0> oh, i see
14:19:14 <jethr0> > let fac = (scanl1 (*) [1..] !!) . (subtract 1) in fac 5
14:19:15 <lambdabot> 120
14:19:43 <rashakil> > let fac = (scanl1 (*) [1..] !!) . (subtract 1) in fac 0
14:19:45 <lambdabot> Exception: Prelude.(!!): negative index
14:20:04 <jethr0> > let fac = ((0:scanl1 (*) [1..]) !!) in fac 5
14:20:06 <lambdabot> 120
14:20:27 <rashakil> > let fac = ((0:scanl1 (*) [1..]) !!) in fac 0
14:20:29 <lambdabot> 0
14:20:40 <jethr0> it's supposed to be 1, right?
14:20:46 <rashakil> an easy fix
14:21:07 <ADEpt> SamB: still trying :)
14:21:43 <lightstep> > map ((1:scanl1(*)[1..])!!) [0..10]
14:21:45 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880,3628800]
14:21:50 <SyntaxNinja> updated cabal web page finally whew
14:21:59 <SyntaxNinja> and now hackage.haskell.org redirects to the wiki
14:22:07 <SyntaxNinja> Lemmih: any luck w/ hacking?
14:22:13 <SamB> er, well, maybe now.
14:22:20 <jethr0> > let fac = (scanl1 (*) (1:[1..]) !!) in fac 5
14:22:22 <lambdabot> 120
14:22:42 <rashakil> > let fac = (scanl (*) 1 [1..] !!) in fac 6
14:22:43 <lambdabot> 720
14:22:57 * jethr0 is just *too* stupid *argh*
14:23:02 <SamB> or you could just manually grab the inventory and inventories/* files as well as the checkpoints/* files
14:23:08 <SyntaxNinja> sometimes I think we need #lambdabot :P
14:23:22 <glaikit> exit
14:23:24 <jethr0> sry
14:23:35 <SamB> let me go ask my sister to stop...
14:23:48 <jethr0> stop doing what?
14:24:42 <SamB> jethr0: reading webcomics
14:24:49 <lightstep> > (scanl(*)1[1..]!!) == (product.enumFrom 1)
14:24:51 <lambdabot>   Expecting a function type, but found `[a]'
14:24:51 <lambdabot>   Expected type: a1 -> [a]
14:24:51 <lambdabot>   Inferred type: [a2]
14:25:10 <jethr0> lightstep, i know that
14:25:30 <jethr0> > let fac n = product [1..n]
14:25:31 <ADEpt> SamB: ah, i got "pulling from ..." at last :)
14:25:32 <lambdabot>  parse error on input `}'
14:25:39 <jethr0> > let fac n = product [1..n] in fac 5
14:25:41 <lambdabot> 120
14:25:49 <jethr0> but that so lame :)
14:26:01 <SamB> ADEpt: don't pull the patch after the TAG
14:26:10 <SamB> oh, wait, that isn't in the repo you are pulling from anyways
14:26:33 <ihope> > let fac n = product [1..n] in fac 0
14:26:35 <lambdabot> 1
14:26:41 <ihope> > let fac n = product [1..n] in fac (-1)
14:26:43 <lambdabot> 1
14:26:50 <ihope> > [1..0]
14:26:52 <lambdabot> []
14:26:55 <jethr0> weird
14:27:01 <jethr0> product []
14:27:04 <jethr0> > product []
14:27:06 <lambdabot> 1
14:27:14 <ihope> > sum []
14:27:16 <lambdabot> 0
14:27:27 <rashakil> > foldl (*) 1 []
14:27:28 <lambdabot> 1
14:28:09 <ihope> In Lisp, the function namespace is separate from the "other" one. I think that's weird.
14:28:15 <Cale> ihope: yes
14:28:19 <Cale> it's very annoying
14:28:20 <SamB> ihope: yes, it is
14:28:33 <ihope> Imagine if every value had its own namespace!
14:28:46 <Cale> every type?
14:28:49 <jethr0> i know... historic binding reasons. but the annoying #'s are worse than different namespaces!
14:29:04 <SamB> especially since its not really seperate namespaces, but multiple value cells in a name...
14:29:07 <ihope> > foobar foobar (foobar . foobar) [foobar, foobar, foobar foobar (foobar, foobar)]
14:29:08 <lambdabot>  Not in scope: `foobar'
14:29:30 <ADEpt> SamB: newtype WorkTable = WT (M.Map BlockId ). Why BlockId two times? (M.Map BlockId BlockStatus) seems to be enough, no?
14:29:42 <jethr0> let a = \n -> a * n; a = "hello"; a = 5 in show a ++ (show $ a a)
14:29:44 <ihope> So what are the #'s?
14:30:06 <SamB> ADEpt: hows it going?
14:30:20 <jethr0> you need them to denote functions, right?
14:30:24 <Taral> this 2sat solver is a pain. :(
14:30:30 <SamB> ADEpt: er, one of them was supposed to be a PieceNum
14:30:34 <SamB> the outer one.
14:30:44 <ihope> (defun foobar foobaz)?
14:31:17 <ADEpt> SamB: but blockid carries piecenum inside, anyways
14:31:19 <jethr0> (foobar #foobar), or sth like that, to pass a function bindings value
14:31:24 <jethr0> i thought, anyways
14:31:34 <SamB> #'foo gives you the function value of the symbol 'foo
14:31:36 <Cale> #'foobar ?
14:31:38 <ihope> I heard it was fdefinition.
14:31:41 <jethr0> yes
14:31:42 <Cale> yes
14:31:46 <ihope> (fdefinition `foobar)
14:31:48 <SamB> ADEpt: yes.
14:32:01 <jethr0> never seen fdefinition before, onlye #' 
14:32:11 <Cale> and then you still have to use funcall or apply
14:32:15 <ihope> I think that's what clisp uses.
14:32:17 <jethr0> true
14:32:26 <ihope> Oh, the annoying... annoyances of Lisp!
14:32:39 <jethr0> but scheme fixed many of these problems! don't even need apply necessarily
14:32:49 <SamB> but the outer map will allow us to tell how many pieces are in progress
14:32:53 <Cale> yeah, scheme is a good deal nicer
14:33:02 <ihope> I like to say Lisp is an imperative language with some functional pieces tossed in...
14:33:14 <SamB> ADEpt: got the inventories yet?
14:33:18 <Cale> I'd still find the lack of a proper type system annoying
14:33:26 <ihope> (+ 3 "5")
14:33:37 * jethr0 could never wrap his head around all the different defines in lisp (def*)
14:33:59 <jethr0> cale, it's a different approach and extremely flexible at that, but i agree with you
14:34:09 <lightstep> you add a new namespace and a new def* macro for each application type
14:34:13 <ihope> defears?
14:34:46 <lightstep> the end result is that lisp code with lots of macros looks somewhat like haskell code with lots of monadic combinators
14:34:49 <lightstep> (or not)
14:35:49 <jethr0> yes, but mixing compile-time, read-time, runtime, etc macros can be very powerful (although not very readable)
14:36:14 <jethr0> read-time macros are a nice way of extending your language
14:36:17 <ihope> If I want unreadable code, I can always use Unlambda.
14:36:55 <zagrius> Is there something very efficient in the implementation of lazyness in Haskell? 
14:37:06 <Cale> zagrius: hm?
14:37:11 <ihope> Is Haskell an implementation?
14:37:19 <SamB> jethr0: I've said it before, and I'll say it now, and maybe I'll even say it again some time: so much power should not be given to such unreadable code
14:37:22 <zagrius> Or is it "just a memoization datastructure"?
14:37:29 <Cale> GHC, I'd assume you mean?
14:37:35 <zagrius> For example
14:37:58 <jethr0> samb, true. but concise haskell code can be quite unreadable to the non-guru too :)
14:38:01 <zagrius> I don't think the standard describes how it could be implemented.
14:38:02 <Cale> Laziness is usually implemented by representing values as pointers to either code or data
14:38:07 <SamB> not really
14:38:18 <ihope> I thought data was code,
14:38:19 <Cale> zagrius: would you like a paper about how to implement it?
14:38:25 <Cale> (and how it's done in GHC)
14:38:26 <zagrius> Cale: sure
14:38:33 <lightstep> why does bram cohen not like avalanche? using random linear combinations seems like a good idea at first look
14:38:37 <SamB> I tried to define a reader macro for C/C++ style comments, but it seems just about impossible...
14:38:43 <Cale> one sec
14:39:05 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
14:39:07 <ihope> How readable is "`````sii``siiri"?
14:39:07 <jethr0> samb, well, you could write a parser and call that from the reader-macro :)
14:39:16 <zagrius> SamB: are you talking about Lisp?
14:39:29 <lightstep> ihope, like fix id
14:39:50 <SamB> jethr0: but at least you can have an idea of what it could be using to do what it does ;-)
14:39:52 <jethr0> ihope, as i said, scheme fixed many of CL's problems (if that was CL code)
14:40:03 <lightstep> jethr0, that was unlambda code
14:40:04 <ihope> That was Unlambda code.
14:40:18 <jethr0> could've been the start of a CL macro :)
14:40:20 <SamB> I mean, it only uses functions the names of which are mentioned in its source
14:40:34 <SamB> (though those names might be argument names rather than global names)
14:40:55 <jethr0> hmm
14:41:03 <ihope> The equivalent Haskell would be "let bot = bot in bot id (putChar '\n') id".
14:41:33 <CosmicRay> What's the best way, with hugs, to specify a binary (say, with unit tests) that is built but not installed?
14:41:35 <SamB> ihope: unlambda was designed from the ground up to be unreadable
14:41:45 <lightstep> except putChar is impure
14:41:54 <ihope> Unlambda is impure!
14:42:04 <lightstep> sure, so you can't translate it to haskell
14:42:11 <Igloo> CosmicRay: DYM "with cabal"?
14:42:17 <zagrius> Cale: did you read that paper?
14:42:21 <SamB> ihope: you've got it backwards: code is data ;-)
14:42:27 <ihope> You can; you just need to use Haskell's little impurities.
14:42:40 <jethr0> and data _can_ be code, but needn't be
14:42:48 <Cale> zagrius: yeah, at one point
14:42:49 <CosmicRay> Igloo: yes
14:42:51 <ihope> Code and data are both the same?
14:42:51 <CosmicRay> s/hugs/Cabal/
14:43:03 <ihope> And 
14:43:07 <Igloo> CosmicRay: No idea, anyway, but do let me know what the answer is  :-)
14:43:19 <SamB> lightstep: well, I can certainly interpret unlambda in Haskell ;-)
14:43:33 <ihope> GUC?
14:44:04 <ihope> Well, Lazy K is a much nicer language than Unlambda.
14:44:38 <CosmicRay> Igloo: OK, that means that the answer is "copy the hackish Makefile that I wrote for MissingH" ;-)
14:44:44 <SamB> ADEpt: how goes it?
14:44:58 <SyntaxNinja> CosmicRay: make a little sub-project with its own .cabal file
14:45:13 <Igloo> SyntaxNinja: It likely wants unexposed modules, though
14:45:26 <zagrius> Is it possible to "escape" the type-system for some part of the Haskell code?
14:45:29 <Cale> zagrius: basically the idea there is not to use a tag to tell whether or not things have been evaluated (though you can still kind of think about it that way if you like) -- Everything on the heap is just a code pointer together with possibly some fields which give the values of the free variables of the code.
14:45:44 <ADEpt> SamB: sloooow
14:45:51 <Cale> zagrius: well, there are tricks, but you don't want ti
14:45:52 <Heffalump> zagrius: well, you can call C
14:45:53 <SyntaxNinja> CosmicRay: did you upload missingh to hackageDB yet?
14:45:55 <Cale> to*
14:46:01 <Heffalump> and there's unsafeCoerce
14:46:03 <Cale> zagrius: GHC has Data.Dynamic
14:46:12 <Heffalump> but things are unlikely to work if you use that
14:46:14 <Cale> @type Data.Dynamic.toDyn
14:46:15 <lambdabot> forall a. (Data.Typeable.Typeable a) => a -> Data.Dynamic.Dynamic
14:46:21 <Cale> @type Data.Dynamic.fromDyn
14:46:22 <lambdabot> forall a.
14:46:22 <lambdabot> (Data.Typeable.Typeable a) =>
14:46:22 <lambdabot> Data.Dynamic.Dynamic -> a -> a
14:46:59 <Heffalump> hmm, could one write a TH program that tried to typecheck its argument, and inserted dynamicness wherever it couldn't?
14:46:59 <CosmicRay> SyntaxNinja: but it would depend on the package from the top-level .cabal file, which has not been installed anywhere yet
14:47:00 <CosmicRay> nah I don't care about unexposed modules (though I might at some point)
14:47:00 <CosmicRay> zagrius: you shouldn't need to do that.
14:47:00 <CosmicRay> zagrius: if you think you do, you probably have a bug ;-)
14:47:27 <SyntaxNinja> CosmicRay: IC.
14:47:28 <CosmicRay> SyntaxNinja: no, I haven't.  I will the minute hackage hits sid though, I promise.  and perhaps even before then
14:47:35 <CosmicRay> (we're back off generator power at work today, whee)
14:47:47 <CosmicRay> suffice it to say that Real Life (TM) has provided significant distractions this week.
14:47:58 <CosmicRay> though I do now have a good story.
14:48:10 <SamB> Data.Dynamic does the type-system-escape tricks for you, so you don't have to go insane doing it yourself ;-)
14:48:24 <CosmicRay> I have never before received a call from tech support, saying "Looks like your T1 is down.  We're investigating."  when I can then say "Well, that might be because it's on fire."
14:48:24 <CosmicRay> ;-)
14:48:43 <Heffalump> :-)
14:48:55 <SyntaxNinja> CosmicRay: sux0rs
14:49:03 <Igloo> Just the first half sounds pretty impressive to me
14:50:41 <CosmicRay> The rest of the conversation was like this...  Tech: "Uh, did you just say the T1 is on fire?"  Me: "Could be.  The building's on fire and we're not allowed in yet, plus the utility is trying to cut the power."  Tech: "Hmm.  We'll just assume it's on your side then."
14:51:23 <ADEpt> SamB: I need a place for "piece2blocks torrent piece blocksize". Is the WorkTable right place for that or somethign atop the WorkTable (InterestTable?)
14:51:39 <jethr0> Heffalump, i didn't quite get your question...
14:51:49 <jethr0> what do you mean by dynamicness?
14:51:53 <Cale> CosmicRay: awesome :)
14:51:53 <SyntaxNinja> CosmicRay: heh. you should have said it's probably his fault, please reboot windows ;)
14:52:42 <CosmicRay> SyntaxNinja: hehe
14:52:57 <SamB> ADEpt: maybe it is a good place...
14:53:07 <SamB> if it isn't, I'll re-home it
14:53:16 <jethr0> Heffalump, but TH doesn't have access to the typechecker... so reacting to typing errors i IMHO currently not possible.
14:53:54 <Cale> zagrius: anyway, the way that code gets written in Haskell dooesn't usually warrant needing dynamic typing. It's available (at least in GHC), but it's not a terribly elegant thing. Of course, you want the compiler to make sure that your code is correct as much as possible, so it's good to avoid it.
14:54:16 <jethr0> @seen zagrius
14:54:17 <lambdabot> zagrius is in #haskell. Last spoke 8 minutes and 50 seconds ago.
14:54:24 <Cale> We have things like parametric polymorphism to avoid dynamic typing.
14:55:10 <lightstep> and type classes, we all love type classes
14:55:16 <Cale> yep :)
14:55:29 <Cale> "Please talk to your son or daughter about parametric polymorphism."
14:55:42 <jethr0> what is "data Test = " called in haskell is that a kind or a meta-type, or what?
14:55:49 <jethr0> :)
14:55:52 <Pseudonym> I did, and the response I got was "ee want chips".
14:55:57 <zagrius> Cale: IIRC, you can't do "apply a function f to all the children of a datatype", generically. 
14:56:20 <jethr0> zagrius, with TH you can
14:56:25 <Cale> zagrius: well, there's Data.Generic, which does that for quite a large class of structures
14:56:28 <Heffalump> I quite often run into things the type system can't express
14:56:40 <Cale> Heffalump: really?
14:56:42 <Heffalump> though I can't think of an example OTTOMH
14:56:48 <jethr0> :)
14:56:54 <Cale> I almost never do
14:56:59 <SyntaxNinja> looks like the fire spread to cosmicray's computer
14:57:15 <zagrius> Cale: and deriving (Typable) is also in Haskell?
14:57:23 <Cale> zagrius: yep
14:57:25 <Cale> in GHC
14:57:27 <zagrius> Cale: (or GHC) 
14:57:29 <SamB> SyntaxNinja: that isn't called "Client exiting"
14:57:30 <jethr0> cale, what is "data Test = " called in haskell is that a kind or a meta-type, or what? apart from "Test" being a type constructor?
14:57:49 <SamB> zagrius: with -fglasgow-exts, probably
14:57:50 <Cale> That looks like a data declaration for an empty type
14:57:57 <zagrius> Cale: so basically there's no reason to use e.g. Stratego?
14:57:57 <Cale> (well, not quite empty)
14:58:05 <lightstep> jethr0, data type declaration?
14:58:31 <jethr0> no, i meant "data Test = A | B| C" and what the whole thing was called. am i defining a type?
14:58:33 <Heffalump> zagrius: I'd expect Stratego to offer a lot more language support for the kinds of things its good at (i.e. strategies and rewriting)
14:58:36 <Cale> zagrius: I'm afraid I don't know much about that language
14:58:52 <Heffalump> and to produce better code
14:59:01 <lightstep> jethr0, yes, it defines a type named Test
14:59:09 <Cale> jethr0: well, yes, I would call it a data type declaration.
14:59:32 <SamB> ADEpt: done yet?
14:59:34 <Cale> lightstep: I'm pretty sure he knows what it does, he just wants a name for it. :)
15:00:00 <lightstep> the Haskell 98 Syntax Reference just lists it under topdecl, and doesn't name it
15:00:01 <zagrius> Cale: Stratego has a primitive to build terms and to match terms by unification. Also it has a "generic" traversal, which basically visits all or some children of a datatype(not that there are real types in Stratego).
15:00:14 <SamB> jethr0: its called a type definition or a data type definition or a type declaration or something like that
15:01:37 <zagrius> Heffalump: A strategy is just a function (with the possibility of "failure"). The "difference" with Haskell is that it is untyped. 
15:02:21 <Cale> If it's untyped, that sounds kind of like how mathematica evaluates things, which is a little scary. :)
15:02:34 <basti_> lol
15:04:05 <zagrius> Cale: It coredumps when you make a higher-order strategy and make an error :)
15:04:31 <zagrius> Cale: It's quite a nice view :P
15:05:45 <Cale> If it's anything like mathematica -- well, mathematica is really flexible in the sense that you can define values with special properties wrt existing functions, and such craziness, but I'm not sure if I'd ever want to verify a program written in something like that.
15:07:13 <Cale> In Mathematica, you can write  Cos[x] ^= 2, which becomes part of the definition of the symbol x, not of Cos.
15:07:36 <Cale> So you end up with a special value which whose cosine is 2 :)
15:07:50 <Heffalump> zagrius: ok, but rewrite rules are more efficient
15:07:57 <Saulzar> I'm not sure I'd ever want to verify a program, what am I doing here? :)
15:08:01 <Heffalump> or should be
15:08:12 <zagrius> Heffalump: the way they implemented it, yes.
15:09:08 <zagrius> There's a tradeoff for using dynamic features and LOC. 
15:12:28 <Pupeno> I am adding support to SCons to build Haskell programs (and libraries). I have the problem that Haskell outputs a bunch of .o files and gcc is picked up to link them (that is the default handler for .o files). I am thinking about outputing the objects to .ho, what do you think about it ?
15:12:29 <joelr1> evening
15:13:48 <dcoutts> Pupeno, you need to use ghc to linkt the .o files, not gcc.
15:14:18 <Pupeno> dcoutts: I knew, that is why I am thinking about making ghc output .ho instead of .o and use ghc to link .ho files.
15:14:19 <dcoutts> Pupeno, if you use gcc you need to reproduce exactly what ghc does when linking.
15:14:25 <dcoutts> ok
15:14:29 <Pupeno> dcoutts: yes.
15:14:34 <lightstep> it's confusing to have both jethr0 and joelr1 
15:14:41 <Cale> hehe
15:14:44 <joelr1> hehe
15:14:50 * dcoutts &
15:14:59 <chucky> .ho-files sounds like it came straight out of a bad rap video
15:15:19 <Pupeno> aside of that, will I encounter any problem ?
15:15:32 <lisppaste2> joelr1 pasted "battling laziness" at http://paste.lisp.org/display/14700
15:15:51 <Philippa> chucky: one produced by a bunch of guys who fancied scully
15:15:54 * joelr1 needs some help with laziness
15:16:46 <joelr1> folks, am I doing this right?
15:18:43 <lisppaste2> joelr1 annotated #14700 with "this is how i use Tables ..." at http://paste.lisp.org/display/14700#1
15:20:38 * Cale invents a board game which is the exact opposite of "Monopoly" called "Perfect Competition".
15:21:05 <Cale> The players have no ability to influence the prices in the game.
15:21:43 <Saulzar> joelr1, What is the issue?
15:21:54 <joelr1> Saulzar: space leaks
15:22:15 * shapr boings cheerfully
15:22:50 <lisppaste2> joelr1 annotated #14700 with "an improvement?" at http://paste.lisp.org/display/14700#2
15:22:58 <JohnMeacham> who is mocking my .ho files?
15:23:28 <JohnMeacham> Haskell Object files being the derivation of said extension.
15:24:11 <JohnMeacham> Pupeno: ah. I see. jhc does spit out .ho files which contains the equivalant of what it in the .hi and .o files for ghc and nhc.
15:24:14 <SamB> @pretty foldExpr s k i ap = f where f S = s;f K = k;f I = i;f Ap x y = ap x y
15:24:15 <lambdabot> "arity mismatch for 'f'" at column 45
15:24:49 <Pseudonym> Bliss.  I get to use Haskell for work agaiN!
15:25:03 <joelr1> Pseudonym: cool. what for?
15:25:13 <Lemmih> NeaT.
15:25:14 <Pseudonym> Oh, I have a DSP chip, but there's no assembler for it.
15:25:27 <Pseudonym> This gives me an excuse to learn Parsec.
15:25:39 <joelr1> Pseudonym: awesome. so what are you gonna do? write an assembler for it in haskell?
15:25:42 <Pseudonym> Sure.
15:25:46 <joelr1> damn, i wish i had a cool job like that
15:25:47 <Pseudonym> It's not a difficult job.
15:25:55 <Pseudonym> What I actually need to do is program the damn thing.
15:26:35 <joelr1> on the other hand, i just closed a deal to write collusion detection for poker 
15:26:47 <joelr1> which means i get to take the dazzle paper and do the same :D
15:26:50 <Pseudonym> In Haskell?
15:26:53 <joelr1> of course
15:26:55 <Pseudonym> Yay!
15:26:58 <joelr1> but i think dsp is cooler
15:26:59 <Pseudonym> That sounds very cool.
15:27:03 <Pseudonym> Well, not really.
15:27:12 <Pseudonym> I'm not actually doing any DSP to start with.  I'm just using it as an ADC.
15:27:23 <Pseudonym> :-)
15:27:30 <joelr1> i don't even know what an ADC is
15:27:47 <cpatrick> joelr1: Analog->Digital Conerter
15:27:51 <cpatrick> +v
15:27:51 <Pseudonym> Right.
15:28:00 <joelr1> ah!
15:28:45 <Pseudonym> Well, a glorified ADC.  It's designed specifically for use with a wheatstone bridge.
15:28:49 <Philippa> Pseudonym: rather than write a full-blown assembler in Haskell, why not build up programs as haskell data structures?
15:28:57 <Philippa> you'll actually get a nicer syntax than most assemblers...
15:29:00 <Pseudonym> Well that's what I'm going to do first.
15:29:23 * Philippa nods
15:29:35 <Pseudonym> program = [ldx r1, stx r3]
15:29:35 <Pseudonym> etc
15:29:40 <Philippa> I just figured... well, why write a macro processor when you've already got a turing complete substitution language to start with?
15:30:00 <Pseudonym> Then add a few pseudo-instructions.
15:30:04 <Pseudonym> And then write a parser.
15:30:19 <Heffalump> Haskell really could do with HERE documents.
15:30:26 <ADEpt> SamB: pull?
15:30:29 <Pseudonym> The reason why I want an assembler eventually is I also want a DISassembler.
15:30:41 <Cale> Heffalump: don't string gaps sort of solve that problem?
15:30:43 <ADEpt> SamB: it seems that we should carry torrent around almost everywhere ...
15:30:45 <Heffalump> you can disassemble into Haskell values :-)
15:30:46 <Heffalump> string gaps?
15:30:49 <Cale> yeah
15:30:56 <Cale> string = "Hello \
15:31:01 <Cale>      \World"
15:31:12 <Heffalump> only if you don't mind type '\' everywhere..
15:31:19 <Heffalump> s/type/typing/
15:31:19 <Philippa> Pseudonym: what Heffalump just said...
15:31:20 <Cale> meh.
15:31:21 <Cale> hehe
15:31:25 <Pseudonym> :-)
15:31:28 <Pseudonym> Anyway.
15:31:37 <Pseudonym> It gives me an excuse.
15:31:41 <Cale> What I'm more annoyed about is the inability to break numeric literals across lines
15:31:57 <Heffalump> if Haskell did have HERE documents, then you can write a trivial parser for simple assembler, and jump back into Haskell for anything complex
15:32:03 <Pseudonym> Cale: Are you trying to break RSA numbers or something?
15:33:00 <Cale> Pseudonym: nah, I just noticed that it didn't have any way to do that, and since it supports bignums, it might as well give you a nice way to write them
15:33:20 <Pseudonym> read "102398012381 [detail omitted] 0827317231"
15:33:24 <Pseudonym> ?
15:33:27 <SamB> @ski \x -> x S K
15:33:28 <lambdabot> http://www.haskell.org/hawiki/\x -> x S K
15:33:30 <Pseudonym> It's not great, but still.
15:35:08 <Heffalump> > read "10239801238\  \0827317231" :: Integer
15:35:09 <Cale> Pseudonym: yeah
15:35:09 <lambdabot> 102398012380827317231
15:35:13 <Cale> with gaps
15:51:12 <tony2> chaps, is there a quick way to determine the size of a data structure, as in the amount of physical mem it's occuping?
15:52:04 <Cale> tony2: profiling
15:52:38 <tony2> Cale, sorry, I mean at run time?
15:52:43 <Cale> no
15:53:20 <Cale> That's not even really well-defined
15:53:47 <Cale> Well, perhaps if you could refer to cost centres
15:53:52 <Cale> in IO code
15:54:22 <tony2> it's read in from a file in the IO monad.
15:55:05 <Cale> The amount of memory that a structure is consuming often has very little to do with, say, the number of elements it holds, and a lot more to do with how it is being consumed.
15:56:14 <Heffalump> there's no fundamental reason the runtime couldn't give you a function to find out
15:56:24 <Heffalump> (in the IO monad, obviously)
15:56:49 <Heffalump> something like thunkOf :: a -> IO Thunk
15:57:04 <dons> hmm, don't we have such a function already.
15:57:06 <Heffalump> children :: Thunk -> IO [Thunk]
15:57:14 <dons> ah, but not children.
15:57:14 <Heffalump> and sizeof :: Thunk -> IO Int
15:57:27 <Heffalump> and have Thunk implement Eq (and maybe Ord)
15:57:36 <Heffalump> then you could do as much or as little tracing as you wanted
15:57:42 <Cale> hmm... I wonder if that's likely to be terribly useful. It would be more useful to have something which reports on a cost centre, I think.
15:57:42 <dons> and there's always Storable, for a poor mans version.
15:57:51 <Heffalump> that would strictify something, though
15:58:12 <tony2> Storable is an option I suppose.
15:58:24 <Cale> tony2: what is it that you're doing?
15:58:24 <tony2> what is Thunk?
15:58:31 <Heffalump> it's a type I just made up
15:58:41 <Heffalump> for the interface I just made up
15:58:42 <tony2> I see. Illistrutive purposes.
16:00:36 <tony2> Cale, well it's a small part of a big program I'm working on, but I'm reading in some very large data structures and serialising them to disk. For larger ones it could behave differently so as not to induce using the VM system.
16:01:33 <dons> hmm, why is there a GHC ticket to "Port GHC to the IA-64 platform"
16:01:42 <Cale> tony2: probably the best thing would be to ensure that the program acts as a pipeline, and doesn't hold on to any particular part of the input (or intermediate values) for too long
16:02:39 <Heffalump> (and uses one of the lazy IO operations to read the data initially)
16:02:48 <Cale> yeah
16:02:54 <Heffalump> s/and uses/possibly by using/
16:04:41 <tony2> Cale, the structure prohibits that as the records change arbitary parts of the structure. I could sort them first I suppose.
16:06:57 <Cale> tony2: well, try to ensure that you output something as soon as you have all the data necessary to compute it. There might be an ordering on your output which forces more input to be read than you might like, but hopefully this won't be too bad
16:07:05 <Cale> and I really do recommend profiling in GHC
16:08:06 <tony2> I've profiled with GHC already. I try to most of the time, to aid my understanding as I'm still a novice when it comes to performance.
16:09:14 <Cale> You might also try playing with Debug.Trace to get some idea of the order in which things are being evaluated
16:09:15 <tony2> I think the most elegant/quick solution could well be for me to buy more ram. If I had another 512M I'd be fine.
16:09:35 <Philippa> heh
16:09:42 <Philippa> congratulations, you work in the real world! :-)
16:10:39 <tony2> don't tell anyone! :)
16:14:36 <musasabi> A standard DeepSeq might be a nice thing to have.
16:14:48 <Cale> musasabi: yes
16:14:55 <Cale> I want deriving NFData
16:15:15 <Cale> (See Control.Parallel.Strategies)
16:15:25 <mjl69_> If I am a beginner who is picking up Haskell quickly, but need something more thorough than the tutorials, is Haskell: The Craft of Functional Programming the best book to get first?
16:16:49 <mjl69_> new $42 and used $33 at amazon.
16:18:22 <tony2> mjl69_, thats a good first book I think. I used it alongside a course in college and it served me quite well. But then as with all first books, it was the only one I had.
16:18:39 <Philippa> I'm not a good person to ask about books, I didn't use any
16:18:46 <Cale> I'm not really sure. I took out a bunch of books on Haskell from my library at one point, but I wasn't incredibly engaged by any of them at the time.
16:18:56 <musasabi> Cale: what is the definitive paper on strategies in Haskell? I only have read things from the clean folks.
16:19:05 <Heffalump> tony2: which college, OOI?
16:19:10 <Cale> musasabi: well, the SPJ one :)
16:19:10 <musasabi> c
16:19:25 <mjl69_> I have a book from '93 that is really pretty good.  It doesn't have the modern, post-98 stuff in it, but otherwise, I am learning a lot from it.
16:19:40 <tony2> Imperial college london. Tony Field, first year course.
16:19:46 <Cale> http://research.microsoft.com/Users/simonpj/Papers/strategies.ps.gz
16:19:59 <musasabi> heh, Should have just googled for "simon haskell strategies"
16:19:59 <Heffalump> oh, I didn't know they taught Haskell in the first year.
16:20:20 <mjl69_> The tutorials are hard to read for long on the computer and the cost of printing and binding one could just go towards a real book.
16:20:22 <tony2> as the very first language.
16:20:46 <Oejet> tony2: Nice.
16:20:50 <tony2> mjl69_ it's good as it continues to serve as a decent reference.
16:20:56 <musasabi> tony2: I am envious :-)
16:21:04 <Heffalump> several universities in the UK do that
16:21:08 <Heffalump> at least I think they do
16:21:15 <Heffalump> Oxford definitely, York (?)
16:21:17 <mjl69_> tony2: thanks, I'm going to get that one.
16:22:10 <tony2> well, you may think it's nice, but for me it spoilt all the others! 
16:22:19 <musasabi> Cale: could generic Haskell solve that ?
16:22:29 <Cale> musasabi: I tried it
16:22:34 <Cale> it sort of works
16:22:36 <Cale> but not well
16:22:41 <Cale> (It's really slow)
16:22:46 <Heffalump> tony2: :-)
16:23:10 <Heffalump> are you still at uni?
16:23:34 <tony2> Heffalump, no I graduated this year. Are you working in the UK?
16:23:35 * Heffalump programs in C for a living now and doesn't mind it too much
16:23:40 <Heffalump> yeah, Cambridge
16:24:02 <tennin> hmm, how about a good introductory book on type theory?
16:24:07 <Lor> TAPL
16:24:22 <tony2> did you study there also? (ML first year?)
16:24:25 <Cale> tennin: yeah, I've heard lots of good things about Types and Programming Languages
16:24:27 <Heffalump> no, oxford
16:24:49 <Lor> Well, it's practically the _only_ really introductory textbook on the subject.
16:24:50 <Cale> tennin: I haven't managed to get a copy yet, but perhaps soon :)
16:24:55 <Heffalump> actually that was for an MSc (my first degree is Maths) but they taught me Haskell first of all in that too
16:25:18 <tennin> ah, ok
16:25:23 <Heffalump> is there any type class where you can just get a list of all its values?
16:25:29 <Heffalump> IM all the type's values.
16:25:39 <Lor> (Bounded a, Enum a)
16:25:42 <dons> enum?
16:25:52 <Lor> That's what I usually use.
16:26:00 <Heffalump> oh, enum with fromEnum 0, fromEnum 1 and fromThen ?
16:26:03 <tennin> is type theory necessarily tied to programming languages?  is there a purely mathematical type theory?
16:26:12 <Heffalump> Lor: ah, that looks simplest.
16:26:12 <dons> Heffalump with .. :)
16:26:42 <Lor> I'm not sure if there is actually a law about Bounded and Enum being "compatible".
16:26:47 <dons> minBound .. maxBound, i'd have thought would be easiest
16:26:51 <Heffalump> [toEnum 0..] works fine
16:26:53 <Heffalump> ta
16:26:55 <cpatrick> tennin: yes, that came first (before computers where invented)
16:27:22 <Lor> It goes back to Russell & Whitehead, at least.
16:27:49 <Lor> And Frege, of course.
16:27:54 <dons> Lor, there are some laws in the Enum.lhs docs
16:28:06 <dons> -- For any type that is an instance of class 'Bounded' as well as 'Enum',
16:28:08 <dons> -- the following should hold:...
16:28:36 <tennin> Yeah, the Wikipedia entry for example mentions Russell, but I'm wondering how closely connected his type theory was to the type theory used in CS
16:28:46 <dons> where `the following' is a  bunch of stuff connecting boundedness to enum
16:29:26 <Lor> tennin, not very. Russell just wanted to stratify set theory to avoid paradoxes.
16:30:01 <Lor> Then Zermelo came along and mathematicians forgot about types.
16:30:59 <cpatrick> grr. my multi-param type classes are misbehaving.
16:31:07 <lisppaste2> cpatrick pasted "Multiparam type classes - doesn't work :(" at http://paste.lisp.org/display/14704
16:31:15 <Heffalump> cpatrick: clearly they aren't dependent enough.
16:31:54 <tennin> so, the type theory of today was basically invented for CS purposes then?
16:32:32 <Lor> Weeelll...
16:33:09 <Lor> I think that in the olden days the distinction between a computer scientist and a logician wasn't as clear as it is nowadays.
16:33:14 <Philippa> very much so
16:33:39 <Philippa> even now some people blur the lines a little - Wadler's Dual Calculus, say
16:33:56 <Lor> The C-H isomorphism is here to stay, of course.
16:34:17 <Lor> But people often find themselves definitely on one side of it or the other.
16:34:23 * Philippa nods
16:34:34 <Philippa> it's fun talking to philosophy students about what we do with logic
16:34:41 <Heffalump> @djinn (a -> b) -> (c -> b) -> (c -> a)
16:34:42 <lambdabot> -- f cannot be realized.
16:34:51 <Heffalump> @djinn (a -> b) -> (b -> c) -> (a -> c)
16:34:52 <lambdabot> f x1 x2 x3 = x2 (x1 x3)
16:35:14 <Heffalump> see, #haskell can straddle it
16:35:18 <Lor> Can we give djinn axioms?
16:35:24 <Philippa> @pl (@djinn ...) <- we should have this ability
16:35:24 <lambdabot> (line 1, column 2):
16:35:24 <lambdabot> unexpected "@"
16:35:24 <lambdabot> expecting lambda abstraction or expression
16:35:28 <dons> Lor, yep. new types, synonyms and functions
16:35:28 <Lor> like Not (Not a) -> a ?
16:35:42 <tennin> I thought I should learn about the purely mathematical type theory, but couldn't seem to find any books on it
16:35:47 <Heffalump> @pl \x1 x2 x3 -> x2 (x1 x3)
16:35:48 <lambdabot> flip (.)
16:35:55 <Philippa> tennin: what do you know about type theory more generally?
16:36:01 <dons> so with the right functions, djinn behaves a bit like @pl.
16:36:04 <Philippa> I'm happy with the kind of stuff in TaPL, I guess
16:36:06 <dons> @djinn a -> a
16:36:07 <lambdabot> f x1 = x1
16:36:14 <dons> @djinn-add id :: a -> a
16:36:15 <dons> @djinn a -> a
16:36:17 <lambdabot> f = id
16:36:17 <Heffalump> ISAGN for @compose
16:36:22 <Lor> Would martin-lf's type theory count?
16:36:30 <Philippa> ooh, good call
16:36:39 <Heffalump> or @., I guess.
16:36:56 <Heffalump> however, it's bedtime for little Heffalumps
16:37:00 <Pseudonym> Is there a decent introdction to Martin-Lof type theory anywhere?
16:37:06 <Heffalump> and indeed medium-height, getting slightly fat Heffalumps
16:37:16 <Pseudonym> I read the one on why it's interesting, but it failed to show why it's interesting.
16:37:31 <Pseudonym> Which I considered a serious shortcoming.
16:37:33 <Pseudonym> Night.
16:37:47 <Heffalump> the one that was linked from LtU a while back?
16:37:51 <Pseudonym> Yeah.
16:38:36 <dons> there's Martin-Lof's paper/tutorial, `on the meaning of the logical symbols'
16:38:39 <Lor> I have glanced a little at "Intuitionistic Type Theory" at our math dept's library. It looked like a pretty ordinary dependent type system with a little old-fashioned notation.
16:38:47 <Heffalump> hmph. Now I want to implement @.
16:38:53 * Heffalump decides to see if he can do it in 20 mins.
16:38:56 <dons> what does @. do?
16:39:17 <tony2> goodnight all.
16:39:26 <Heffalump> "@. (@pl,@djinn) (a -> b) -> (b -> c) -> (a -> c)" should produce the output I got above
16:39:30 <dons> ah, yes.
16:39:34 <dons> hmm...
16:39:44 <Heffalump> should be pretty trivial
16:39:52 <Pseudonym> I was thinking of something online. :-)
16:39:58 <Heffalump> assuming plugins can call other ones
16:40:06 <dons> but how to stop those functions just dumping their output to ircPrivMsg?
16:40:16 <Heffalump> ah, good point..
16:40:19 <Heffalump> ok, not a 20 minute job..
16:40:31 <dons> a general system for inter-plugin calls, supported by the Module type would be good
16:40:47 <Heffalump> we'd need to abstract ircPrivMsg into an argument to the module or something
16:40:48 <dons> the Module `process' function should be :: .. IO [String] 
16:40:52 <newsham> I have a question about monads (go figure :)
16:41:00 <Heffalump> right
16:41:03 <newsham> if you ahve something like:  getc >>= \x -> getc >>= y -> return x + y
16:41:14 <Heffalump> yep
16:41:26 <newsham> that means   getc >> (\x -> getc >>= (\y -> return x + y) ) )    right?
16:41:35 <newsham> minus typos :)
16:41:49 <Heffalump> no
16:41:55 <Heffalump> it's infixl
16:42:14 <Heffalump> oh, hangon
16:42:16 <Heffalump> yes, you're right
16:42:27 <Heffalump> cos the lambdas force it to associate that way
16:42:28 <Cale> >>=
16:42:32 <Cale> yeah
16:42:48 <Heffalump> x >>= f >>= g is (x >>= f) >>= g
16:42:58 <Heffalump> (and would have to be cos of the types)
16:43:50 <newsham> ok, maybe i should back up.     start off with   do; x <- getc; y <- getc; return x + y       or something like that
16:44:05 <newsham> that gets translated into what I had above, right?
16:44:09 <Heffalump> yes
16:44:33 <newsham> I guess what has me confused is looking at the innermost thing being "evaluated" (if thats the right term for it)
16:44:38 <newsham> we have (\y -> return x + y)
16:44:54 <Heffalump> remember that Haskell evaluation is demand-driven
16:45:08 <Heffalump> so what will actually happen is:
16:45:09 <newsham> *nod*
16:45:17 <Heffalump> RTS asks for an IO action for main.
16:45:31 <Heffalump> assuming your expression is main, then the next thing it'll look at will be the outermost >>=
16:45:41 <newsham> well, I don't wanna get into IO per se.. just general monad stuff..  I just choce getc cause it was easy
16:45:54 <Heffalump> ok, well in any case the outermost >>= will be the first thing inspected
16:45:54 <newsham> chose
16:46:14 <newsham> so its going to walk the parsed tree from top down
16:46:15 <Heffalump> and now it'll depend on the definition of >>= for the monad in question what happens next, but probably most will inspect their left hand argument
16:46:20 <Heffalump> so the getc will get "run"
16:46:21 <Heffalump> yeah.
16:47:01 <Heffalump> the real story is a bit more complicated cos it all depends on what the monad actually does, but that's roughly it
16:47:14 <newsham> when it gets to \y -> return x + y       there's an expression with one variable..  and confusing me is the "x"
16:47:22 <newsham> is this x already bound to a fixed value at this point?
16:47:25 <Heffalump> yes
16:47:37 <newsham> so it could well be thought of as  \y -> return 3 + y
16:47:42 <Heffalump> >>= will get a value out of its left hand argument, and pass it to its right hand argument
16:47:45 <Heffalump> yes
16:47:53 <newsham> ok, that makes my head hurt less
16:48:02 <Heffalump> just like in (\x y -> x+y) 3 you can think of the x as being 3
16:48:08 <Heffalump> cos that's precisely what function application does
16:48:23 <newsham> so the binding happening is   getc    with   (\y -> return 3 + y)
16:48:31 <Heffalump> well, the result of getc
16:48:41 <newsham> right, but the two "arguments" to (>>=)
16:48:47 <Heffalump> yes
16:48:50 <newsham> ok.
16:49:12 <Heffalump> again I'm simplifying a bit. I could explain the details by showing you runState and walking you through what happens with a state monad, but I really should go to bed
16:49:21 <newsham> and behind that (>>=) could be some fancy machinery like iterating over all of a lists items.
16:49:25 <Heffalump> right
16:49:44 <newsham> ok.  I think that shores up my last few questions.
16:49:54 <newsham> thank you
16:50:02 <Heffalump> the type of >>= makes it pretty much inevitable that it will "run" its first argument first
16:50:11 <newsham> perhaps one of the tutorials should go into more detail on breaking the problem apart like that
16:50:14 <Heffalump> cos m a -> (a -> m b) -> m b
16:50:39 <Heffalump> there's no way you can get an m b without either returning an undefined value or running the (a -> m b)
16:50:59 <Heffalump> and there's no way you can run a -> m b without an a, so if you don't make it undefined you need to run the m a to get it
16:51:03 <jethr0> what's the "cos"?
16:51:11 <Heffalump> short for "because"
16:51:12 <newsham> "because"?
16:51:20 <jethr0> ah, looked like code :)
16:51:25 <Heffalump> yeah, sorry :-)
16:51:38 <Heffalump> I rephrased the way I was writing that half way through so it ended up looking a bit confusing
16:52:38 <newsham> I think if one of the tutorials started off explaining the >>= mechanics a little more (with an example or two from different monad instances) instead of jumping into the "big picture" it would make more sense
16:53:00 <Heffalump> I think you're the first person who has asked a question like that, TICBW.
16:53:05 <newsham> like   [1,2,3] >>= return (+ 1)      once I understood that, I think its all starting to fall into place
16:53:13 <Heffalump> it's hard to find something that'll suit everyone
16:53:20 <newsham> *nod*
16:53:25 <Cale> newsham: have you looked at my tutorial?
16:53:30 <Heffalump> we should make people who we explain things to write up a wiki page about what they learnt :-)
16:53:34 <newsham> cale: probably.  i've read several. 
16:53:36 <newsham> which one?
16:53:43 <Cale> MonadsAsContainers
16:53:44 <Heffalump> that way over time we'll build up a library of different explanations for things
16:53:47 <Cale> on the wiki
16:53:52 <newsham> cale: no.  i didnt see that one yet
16:54:00 <Cale> oh, definitely look at it
16:54:08 <newsham> *nod* pulling up now
16:54:13 * Heffalump declares his bed a monad and goes to embed himself in it
16:54:20 <Cale> What I wrote there is how I always teach monads to beginners
16:54:21 <SamB> it would be an excellent way to judge comprehension as well
16:54:45 <newsham> there was a good analogy to comprehensions in the "monads for working haskell programmers"
16:54:45 <dons> @seen dcoutts
16:54:46 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #
16:54:46 <lambdabot> haskell. Last spoke 1 hour, 39 minutes and 55 seconds ago.
16:54:58 <dons> dcoutts, how'd the packaging of hmp3 go?
16:55:02 <newsham> but it took me a lot of investigation before I understood why
16:55:14 <SamB> maybe monads should be explained in terms of quantum mechanics
16:55:30 <dons> hehe, that would help comprehension :)
16:55:33 * SamB confuses newbies even more than david roundy
16:55:35 <newsham> basically lots of tutorials say something like:   "here's an identity:   m >>= return . f    is just like   fmap f m"
16:55:46 <Cale> I really think that monads are best thought of first as a kind of container. (functors too)
16:55:56 <newsham> and I stare at it for a while and scratch my head.  skip over it, come back to it in the next tutorial, repeat.. then finally sit down to figure out whats going on
16:56:25 <SamB> perhaps it makes more sense to explain quantum mechanics in terms of monads
16:56:29 <newsham> cale: yah, thats how I try to model in my head.  but the container is only halfway helpful for figuring out how to write my own or use the operators
16:56:50 <Cale> The container analogy is perfect for writing your own :)
16:57:05 <SamB> Cale: only the container kind :-(
16:57:15 <SamB> we need a function analogy
16:57:17 <Philippa> I sort of think about somewhat twisted interpreters
16:57:25 <Philippa> in the "abstract machine" kind of way
16:57:27 <newsham> i dunno.. i got the container bit pretty quickly.  and then I tried to read some instance (>>=) definitions and I could almost understand what they were doing
16:57:29 <SamB> all the best monads are newtyped functions
16:57:37 <newsham> but if I was to write my own I would be more than confused
16:57:52 <Philippa> (>>=) definitions often involve some rather funky (or maybe just something that sounds like it) bindings
16:58:07 <Philippa> it might be easier to try drawing the structure you want on paper first and then translating it?
16:58:17 <Cale> It's usually easier to define join and fmap than try to attack >>= directly
16:58:22 <Cale> at least, I find that
16:58:23 <Philippa> I had to do that the other way round to understand a state monad definition once
16:58:47 <Philippa> I should try doing that one if and when I next define one directly
16:58:50 <Cale> SamB: functions are just big boxes :)
16:58:53 <Philippa> I tend to just stack up transformers these days
16:59:28 <Cale> (You can think of them as containers indexed by their argument type)
17:00:03 <Cale> But I'll admit that for things like State, it might be saner to think of them as actions.
17:00:16 <newsham> cale: liking your wiki.  thanks.
17:00:21 <Cale> newsham: :)
17:00:50 <Philippa> Cale: 'sone of the things I like about the "it's semantics" option - you can decide whether you want to think about your abstract machine primarily in terms of code or data, IYSWIM
17:01:05 <Cale> yeah
17:01:14 <Cale> There's a certain duality to the whole picture
17:01:28 <newsham> xs >>= f = join (fmap xs)     this is nicer. :)
17:01:49 <newsham> minus the typo :)
17:02:04 <Cale> Do you want to think about m a directly, or more about a -> m b?
17:03:35 <Saulzar> That's a really confusing type signature to comprehend to begin with - until you realise all it means is that you're keeping a value around so that future computations can depend on prior computations.
17:03:50 <Cale> not necessarily one value even :)
17:04:01 <Cale> usually much much more than one
17:04:14 <Cale> often infinitely many :)
17:04:18 <Saulzar> Yes, true.. for things like list :)
17:04:24 <Cale> or State
17:04:25 <Cale> :)
17:04:49 <Cale> (even though you tend not to think about it that way)
17:05:06 <newsham> sqrt might be a good example for list monad (since it is multivalued)
17:05:07 <SamB> oh, I figured out the parsec combinator for epsilon:
17:05:14 <Cale> newsham: yeah
17:05:21 <SamB> it is this strange function called "return"
17:05:28 <Cale> SamB: hehe
17:05:49 <Saulzar> Yeah, "wrap" or something makes more sense... until you start using do notation
17:05:55 * palomer wonders why they didn't use the | operator for parsec
17:06:06 <Cale> return makes sense in the view as computations
17:06:26 <Cale> return x is the computation which constantly returns x and has no other effects
17:07:05 <Cale> Computation is such an abstract thing that I like starting with the container view.
17:07:37 <Saulzar> I read you tutorial a fair while ago, very helpful :)
17:07:39 <Cale> Like, when you're allowed nondeterminism, and all kinds of other funky stuff, it gets really hard to picture.
17:07:50 <Cale> While containers are usually reasonable
17:07:59 <Cale> (except functions, if you're not used to that)
17:09:07 <Cale> There was a nice monad which I have no real idea how to picture computationally, where the values are trees with values on all the nodes, and join does some fun things with the edges.
17:09:42 <Cale> wonder if I still have the diagram I drew...
17:11:01 <dons> @seen psi
17:11:02 <lambdabot> I saw psi leaving #haskell 1 hour, 31 minutes and 51 seconds ago.
17:11:41 <newsham> got an example of when you would play with leaves?
17:11:59 <Cale> newsham: hm?
17:12:30 <newsham> <Cale> There was a nice monad which I have no real idea how to picture
17:12:30 <newsham> +computationally, where the values are trees with values on all the nodes, and
17:12:30 <newsham> +join does some fun things with the edges.
17:12:34 <Cale> ah
17:12:53 <Cale> yeah, I had a picture of the join for that monad, I'm just looking for it
17:14:03 <SamB> palomer: | is not an operator
17:14:11 <SamB> it is used by pattern guards
17:14:16 <SamB> er, guards period
17:19:13 <SamB> hmm, I wonder if you can implement lazy K like this:
17:19:19 <SamB> newtype LK = LK {unLK :: LK -> LK}
17:21:37 <ADEpt> SamB: i've once again did horrible things to conjure :)
17:22:42 <newsham> i figured out my objection to these tutorials.  monads are an abstraction.  they're pretty abstract.  these tutorials start off talkign about the abstraction and how it works and then later on start saying what you can do with them.
17:23:26 <newsham> i would like to see something that starts concretely.   "example 1.  lets write code to do a small computation that can fail."  "exampel 2, lets write code to do computation that computes all of the values, not just the first one that doesnt fail."
17:23:33 <Saulzar> I think the parser combinators paper is very helpful with monads too, if you sit down and implement the first few 
17:23:35 <newsham> "hey wait, look at all the similarities.  how can we put these two things together"
17:23:50 <Saulzar> Until they start getting heavy with the monad comprehensions 
17:23:51 <newsham> starting with the concrete and then working towards the abstract
17:24:56 <Saulzar> Yep, actually I think the parser combinators paper does that to an extent
17:24:57 <jethr0> newsham, i agree with your assessment. but i still think that most people would have problems with even the best of monad tutorials, because it is a pretty high-level abstraction (although simple) and we're just not used to learn new abstractions from scratch
17:25:28 <jethr0> i know i've grappled with continuations for weeks and my inability to comprehend them did _not_ lie in the tutorials :(
17:25:33 <newsham> "if the truth can be explaind so as to be understood, it will be believed"
17:25:44 <ADEpt> newsham: i believe I saw a tutorial just like that
17:26:00 <Saulzar> Just have to read it to death and suddenly it's more clear
17:26:13 <jethr0> ya, at some point it just clicked for me...
17:26:26 <ADEpt> newsham: It was about building parsers. "lets build it simple, now with error handling, now with context tracking, hey - notice the similarities"
17:26:30 <Saulzar> Continuations are the opposite though, they seem clear enough in concept - but in practice I can't follow it
17:26:33 <jethr0> but i'm not saying that such a tutorial wouldn't be good, it just wouldn't solve _all_ problems with beginning to understand monads...
17:26:53 <newsham> setjmp? :)
17:27:07 <Saulzar> Where as monads seem all vague and alien in concept, but they're not really that hard in practice
17:27:11 <jethr0> Saulzar, you thing you got it and then look at an example an all your "understanding" crumbles back down again
17:27:26 <jethr0> exactly
17:27:49 <newsham> arent continuations just a setjmp on a set of garbage collected activation frames?
17:27:57 <jethr0> newsham, continuations are _way_ more than any kind of jump :)
17:28:01 <ADEpt> who knows, where I can report a wishlist bug against darcs?
17:28:04 <Saulzar> There is an example in "yet another haskell tutorial" with continuations based fold, it's rather steep for 40 pages into an introductory article :)
17:29:12 <newsham> if C used the heap for activation frames, and the frames were reclaimed when they were no longer referenced (isntead of when you return), then wouldnt setjmp be a continuation?
17:30:15 <Cale> http://vx.hn.org/autoshare/treeJoin.ps -- There it is!
17:30:23 <jethr0> i'm pretty sure you need explicit environments to implement full continuations... (and i understood only half of what you said :)
17:30:57 <newsham> an activation frame is the thing that holds your arguments and your local variables.
17:31:13 <Cale> That shows the join transformation from Tree (Tree a) to Tree a where data Tree a = Leaf a | Branch (Tree a) a (Tree a)
17:31:17 <newsham> C uses a stack for them.  it pushes args on, then pushes its locals on it.  subroutines push the return address and jump.
17:31:33 <newsham> returns pop the locals and return address and args and jump back to the return address
17:31:45 <jethr0> newsham, could you have parallel call trees and jump between them?
17:31:51 <newsham> so all of your "environment", except for globals, are contained in a chain of activation frames
17:32:12 <newsham> jethr0: yes.  thats how you do coroutines (multiple stacks, with setjmp and longjmp)
17:32:20 <jethr0> well, then maybe it would be a setjmp, but i'm not sure
17:32:34 <newsham> http://lava.net/~newsham/x/machine/thrgen/ <- here's a tiny simplistic example (using coroutines as generators in C)
17:32:37 <jethr0> coroutines are a weaker form of continuations
17:32:56 <newsham> *nod* because each coroutine still has a FIFO stack.
17:33:19 <newsham> you need to use a general heap to do arbitrary continuations
17:33:24 <jethr0> but how do you "garbage collect" the stack?
17:33:27 <newsham> and then you have to figure out when to reclaim space
17:34:00 <newsham> jethr0: it couldnt be a FIFO "stack".
17:34:01 <Cale> Who was it that wanted that picture?
17:34:15 <Cale> newsham: http://vx.hn.org/autoshare/treeJoin.ps
17:34:18 <newsham> cale: still looking
17:34:36 <jethr0> newsham, i'm still not convinced. for multishot continuations (i.e. callable more than once)  they have to be able to follow different execution paths each time. would that be possible in your model? you'd branch inside the stack pretty often!
17:35:20 <newsham> jethr0: there's no "stack".  the activation frames would simply be structures on the heap, with pointers to the parent (caller)'s activation frame.
17:35:26 <tennin> hello
17:35:41 <newsham> ie. if main() calls printf().  printf gets a activation frame with a pointer back to main()'s activation frame.
17:35:43 <Saulzar> Cale, What is the point of it?
17:35:52 <jethr0> newsham, but that's pretty much what i meant by environments :)
17:35:52 <Cale> Saulzar: it's a monad
17:35:56 <newsham> so you can reach return addresses (and any scoped variables, if the language supports that)
17:36:02 <Cale> Saulzar: that type becomes a monad
17:36:13 <newsham> jethr0: ok.  there you go.  garbage collected activation frame == environment :)
17:36:17 <jethr0> continuation passing style also helps a great deal for "implementing" continuations :)
17:36:22 <Cale> I didn't have any particular application in mind
17:37:24 <newsham> cale: thats what I wsa wondering (concrete example of use)
17:37:27 <jethr0> newsham, then we've agreed all along *g*
17:37:44 <Saulzar> Hmm
17:37:44 <Cale> newsham: well, similar types have uses
17:37:51 <newsham> jethr0: doesnt seem terribly complex, then :)
17:37:51 <jethr0> cale are those two arrows different operators?
17:37:53 <Cale> Plain trees are definitely a useful monad
17:37:57 <Cale> jethr0: no
17:38:05 <jethr0> newsham, belileve me, using them generally is!
17:38:06 <Cale> jethr0: their composition is join
17:38:16 <newsham> minor change in the calling convention, and then use of some GC system.
17:38:30 <Cale> well, they're doing different things
17:38:49 <jethr0> implementing them is easy once you've converted to CPS...
17:39:39 <jethr0> there's a nice, readable paper outlining it for a scheme interpreter: http://www.iro.umontreal.ca/%7Eboucherd/mslug/meetings/20041020/90-min-scc/90-min-scc.pdf
17:41:42 <jethr0> actually, it's a presentation
17:57:31 <twb`> Woo woo!
17:57:38 <twb`> I got my parser to do something correctly!
17:57:53 <twb`> http://twb.ath.cx/darcs/miscellaneous/parsewiki_0.4.3/parser.hs
18:00:30 <jethr0> check that url again
18:00:49 <jethr0> 404 not found
18:16:59 <dons> @quit purity for all
18:17:55 <dons> @version
18:17:55 <lambdabot> lambdabot 3p246, GHC 6.5.20050806 (Linux i686)
18:17:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
18:19:26 <newsham> @quit purity for all
18:19:26 <lambdabot> Not enough privileges
18:19:32 <newsham> @elevate me
18:19:32 <lambdabot> Unknown command, try @listcommands.
18:19:35 <twb`> http://twb.ath.cx/~twb/darcs/miscellaneous/parsewiki_0.4.3/parser.hs
18:55:21 <Saulzar> Hmm, seems strange that I get a much faster, smoother animation with  priorityLow vs. priorityHigh for a gtk timer...
19:04:31 <Spark> how do you do the small step operational semantics for while
19:04:53 <Spark> my brain has melted
19:04:59 <Spark> does it have to be in terms of if?
19:05:08 <jethr0> ahh, i hate those... in my oral exam i totally froze up :(
19:05:17 <Spark> while b e -> if b then (e ; while b e)
19:05:36 <jethr0> looks good to me, but then i nearly failed because of SOS :)
19:05:40 <Spark> :)
19:05:48 <Spark> unfortunately my language doesnt have if
19:05:58 <Spark> on the grounds that you can represent it in terms of while
19:06:12 <jethr0> this solution was for one kind of semantics, but i forgot which
19:06:23 <Spark> small step presumably, because it reproduces the b
19:06:33 <Spark> with big step you do something different i think
19:06:46 <Spark> you have a while for false
19:07:05 <Spark> and the while for true executes itself again with the new heap
19:07:20 <Spark> damn, i cant *not* have if
19:07:35 <jethr0> in this presentation i found, small step s. has "if"!
19:07:49 <Spark> mm
19:09:23 <Spark> the thing is, you cant evaluate b in the small step semantics for while
19:09:37 <Spark> i cant think of a way to do that without resorting to if
19:09:53 <Spark> oh well, i'll have to add "if" to my language
19:10:02 <jethr0> *yeah*, i can create automatic deconstructors in TH now :) 
19:10:13 <jethr0> $(consMatcher ''Maybe >>= lift . pprint)
19:10:27 <jethr0> \n -> case n of Nothing -> "Nothing"; Just _  -> "Just"
19:10:34 <jethr0> *yipee*
19:10:34 <Spark> argh monads
19:11:00 <jethr0> well, i thing the "argh" should definitely go to template haskell *g*
19:11:15 <jethr0> btw, the first line auto generates the second!
19:11:20 <Spark> heh
19:12:45 <SamB> oh wonderful ;-)
19:12:51 <SamB> adept is trying to replace IST
19:12:55 <jethr0> this could come in quite handy
19:13:01 <jethr0> IST?
19:13:11 <jethr0> samb, you still working on conjure?
19:13:46 <SamB> jethr0: I was watching Monsters Inc. with my sisters and father for a while there, but now I'm back for more ;-)
19:14:06 <jethr0> samb, i wouldn't have believed how much work such a tutorial is *uff*
19:14:20 <jethr0> it's not finished, but check it out: http://www.haskell.org/hawiki/TemplateHaskellTutorial
19:14:35 <twb> What does "Arguments exhausted after 7 tests." mean?
19:14:54 <jethr0> that quickCheck could generate only seven test cases?
19:14:57 <SamB> you know, you could probably use this as a TMR article ;-)
19:14:58 <twb> I'm testing x::Char, it should have at least 127 different cases.
19:15:12 <jethr0> samb, that's what i wrote it as after shapr suggested sth of the kind
19:15:51 <SamB> you have come far further on this than I have on my article :-(
19:16:26 <jethr0> samb, i've seen no progress on yours. but i guess once you're back on it, it'll be a really cool tutorial
19:16:33 <jethr0> the code is absolutely gorgeous!
19:16:37 <SamB> hehe
19:16:42 <SamB> thank you ;-)
19:16:52 <jethr0> did you write it down like that or did it take lots of iterations to get it this polished?
19:16:56 <SamB> now if only I was good at making up backstories...
19:17:13 <SamB> unfortunately, pretty close to the former
19:17:30 <jethr0> "unfortunately"?? that's amazing. i'm green with envy!
19:17:41 <SamB> well, it means I have to make all the iterations up ;-)
19:17:47 <jethr0> he
19:17:56 <SamB> that makes my article a work of fiction, you know?
19:18:08 <jethr0> it also means you are a "discriminating hacker"
19:18:25 <SamB> I thought that came free with the language ;-)
19:18:36 <jethr0> nobody expects an article to be a chronologic account of real events!
19:18:42 <SamB> hehe
19:18:44 <twb> Are you sure you're not green with scurvy?
19:19:09 <jethr0> how would i've gotten scurvy?
19:19:24 <jethr0> i _do_ eat fruit now and then!
19:19:54 <SamB> @pretty do eat fruit now and then
19:19:54 <lambdabot> "Parse error" at column 22
19:20:11 <SamB> @pretty let in do eat fruit now and then
19:20:12 <lambdabot> "Parse error" at column 29
19:20:21 <SamB> hmm
19:20:27 <SamB> what is wrong with that code?
19:20:43 <SamB> oh, the then
19:20:47 <cpatrick> then is a keyword
19:20:51 <cpatrick> yeah
19:20:52 <SamB> hehe
19:21:06 <jethr0> samb, it has to be valid code. i haven't figured out how it handles unbound names, yet
19:21:25 <SamB> @pretty let in foo bar baz
19:21:25 <lambdabot>  i = let in foo bar baz
19:21:30 <SamB> it doesn't care
19:21:36 <cpatrick> @pretty do abstain from abstaining
19:21:36 <lambdabot> "Parse error" at column 27
19:21:37 <jethr0> hmm, good to know
19:21:43 <jethr0> @type from
19:21:43 <lambdabot> Not in scope: `from'
19:21:45 <cpatrick> it doesn't do intercal ;P
19:21:48 <SamB> from is probably a keyword
19:21:54 <SamB> > from
19:21:55 <lambdabot>  Not in scope: `from'
19:21:58 <SamB> hmm.
19:22:00 <SamB> no.
19:22:07 <jethr0> could still be a reserved word
19:22:13 <SamB> oh, you forgot the let
19:22:14 <cpatrick> @pretty let in do blah blah
19:22:14 <lambdabot>  i = let in do blah blah
19:22:27 <SamB> @pretty let in do abstain from abstaining
19:22:27 <lambdabot>  i = let in do abstain from abstaining
19:22:44 <cpatrick> @pretty please do abstain from abstaining
19:22:45 <lambdabot> "Parse error" at column 8
19:22:50 <SamB> jethr0: why don't you just treat it as an expression if it doesn't parse as a binding?
19:22:55 <jethr0> @pretty order = abstain from fruit
19:22:55 <lambdabot>  order = abstain from fruit
19:23:03 <cpatrick> we really need a pretty please command. I don't care what it does ;)
19:23:13 <SamB> @pretty please
19:23:14 <lambdabot> "Parse error" at column 7
19:23:18 <jethr0> it prepends "module Main where"
19:23:27 <jethr0> and if it starts with let an additional "i = "
19:23:34 <jethr0> it's all rather sketchy
19:23:44 <SamB> jethr0: so, if it doesn't parse the one way try it the other way
19:23:45 <jethr0> @pretty please = please
19:23:46 <lambdabot>  please = please
19:24:04 <SamB> @pretty please = with cherries on top
19:24:04 <lambdabot>  please = with cherries on top
19:24:17 <jethr0> samb, i'll implement that... but first i want to finish this friggin' tutorial. it's taking me ages already!
19:24:23 <SamB> hehe
19:24:51 * jethr0 can hear his own cackling laughter
19:30:43 <SamB> hmm, I'm not seeing what ADEpt meant wrt messing up conjure
19:31:20 <SamB> stand by for reconnection
19:32:56 <twb> Remind me again how you do the equivalent of python's 'x'*10 ?
19:33:04 <cpatrick> replicate 10 'x'
19:33:08 <twb> Ah.
19:33:12 <twb> I was trying repeat :-)
19:33:18 <cpatrick> or take 10 (repeat 'x')
19:33:30 <cpatrick> repeat goes on forever and ever
19:33:40 <jethr0> i always forget the name of replicate and can only think of repeat. it's so annoying
19:33:43 <twb> I noticed.
19:35:42 <elk> @hoogle Char -> Integer -> [Char]
19:35:43 <lambdabot> No matches, try a more general search
19:35:56 * cpatrick stabs static typing repeatedly
19:36:00 <Cale> @hoogle Char -> Int -> [Char]
19:36:01 <lambdabot> No matches, try a more general search
19:36:10 <Cale> @hoogle a -> Int -> [a]
19:36:11 <lambdabot> Data.List.replicate :: Int -> a -> [a]
19:36:11 <lambdabot> Prelude.replicate :: Int -> a -> [a]
19:36:11 <lambdabot> Data.List.repeat :: a -> [a]
19:36:12 <Korollary> @hoogle a -> Integer -> [a]
19:36:13 <lambdabot> Data.List.repeat :: a -> [a]
19:36:13 <lambdabot> Prelude.repeat :: a -> [a]
19:36:13 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
19:36:36 <elk> that's what i meant, thanks
19:37:10 <Korollary> genericReplicate's order of args is different heh...
19:37:21 <Cale> odd
19:37:34 <Korollary> nice job by hoogle on the fuzzy match, tho
19:38:14 <twb> cpatrick: what did it do this time?
19:38:56 <cpatrick> twb: I have a bunch of types in a particular class. and I want to be able to select from them at runtime
19:39:21 <twb> Hack it up using read.
19:39:23 <cpatrick> and kludging this with existential types is bloody doing my head in
19:39:34 <cpatrick> using read?
19:39:40 <twb> Yeah.
19:39:43 <Korollary> Isn't there something like Data.Dynamic
19:40:02 <twb> Or whatever the equivalent of read is that has String -> a
19:40:26 <cpatrick> nah I need to be able to construct arbitary instances of these classes
19:40:38 <twb> Hmm.
19:40:46 <cpatrick> erm, using python's definition of instance and classes
19:40:49 <Korollary> cpatrick: you wanna construct types at runtime?
19:40:49 <SamB> ooh, sounds like you need hs-plugins... or something even more powerful...
19:40:52 <Cale> er, why don't you know which type it is that you want?
19:41:00 <cpatrick> Korollary: no
19:41:07 <Cale> is there a finite, known number of types in this class?
19:41:08 <Korollary> cpatrick: then look at GHC's Data.Dynamic
19:41:11 <cpatrick> Cale: yes
19:41:18 * cpatrick looks
19:41:26 <Cale> You might just add a datatype which represents their union
19:41:41 <SamB> yeah, that would work fine.
19:41:46 <twb> Cale: and then instantiate arbitrary over that union?
19:41:48 <Korollary> That's just too clean
19:41:49 <Cale> data Val = VChar Char | VInt Int
19:41:50 <Cale> ...
19:41:51 <SamB> and you could use TH to generate the killer case
19:42:30 <twb> No no no, you should create an embedded DSL :-)
19:43:13 <SamB> isn't that what TH is?
19:43:34 <Cale> TH would sort of give not-quite-embedded DSLs
19:43:42 <twb> SamB: I only know of TH from Lispniks, who say that it sucks.
19:43:57 <jethr0> cale, have you seen my auto-generating deconstructor? "$(consMatcher ''Maybe)" is replaced at compile-time by '\n -> case n of Nothing -> "Nothing"; Just _  -> "Just"'
19:43:59 <jethr0> :))
19:44:19 <twb> Is there a neater way to write this function:
19:44:19 <twb> test' n f = do putStr ("Trying "++n++":"++ (replicate (20 - (length n)) ' ')); test f
19:44:29 <SamB> twb: that does not say anything about whether or not it is an EDSL
19:44:42 <Cale> jethr0: hmm :)
19:44:54 <cpatrick> twb: what you really want is a function to left-justify a string
19:45:01 <twb> cpatrick: yeah.
19:45:06 <jethr0> it's not for application. rather as my personal proof of concept *g*
19:45:12 <twb> format "~20,' s" string
19:45:18 <twb> ;-)
19:45:25 <cpatrick> there's a printf lruking in haskell somewhere isn't therE?
19:45:32 <jethr0> *brrr*
19:45:32 <Cale> jethr0: if you like TH, you ought to like Data.Generics
19:45:32 <cpatrick> Text.Printf
19:45:38 <Cale> Have you looked at that?
19:45:48 <twb> printf is kind of evil.
19:45:54 <SamB> > Printf.printf "%-20s" "foo"
19:45:55 <lambdabot>  Not in scope: `Printf.printf'
19:45:57 <SamB> hmm
19:45:59 <Cale> Text.Printf isn't too evil
19:46:05 <SamB> > Text.Printf.printf "%-20s" "foo"
19:46:06 <jethr0> not so sure. i feel quite comfortable in my typed environment.
19:46:06 <lambdabot>  Not in scope: `Text.Printf.printf'
19:46:20 <jethr0> but for generating bindings, driFt stuff TH is quite nice!
19:46:26 <SamB> it does work if you run it in GHCi
19:46:32 <SamB> which is more than I expected!
19:46:36 <Korollary> with GADT's, it's possible to have a typesafe printf.
19:46:59 <SamB> I didn't even know that you could do that in C until the other day when I saw it in K&R2 
19:47:21 <SamB> Korollary: typesafe... printf?
19:47:29 <SamB> no it isn't.
19:47:30 <twb> Actually what I would like more is to extract the name of a variable.
19:47:34 <SamB> or.
19:47:35 <SamB> well.
19:47:42 <SamB> not any more than we already do.
19:47:42 <Korollary> SamB: Yeah, there's paper by the MS Research guys that show it.
19:47:50 <SamB> Korollary: but...
19:48:03 <SamB> the string could be input by the user!
19:48:10 <jethr0> samb, printf in C is such an evil construct. it is almost impossible to use varargs in C responsibly!
19:48:15 <twb> test' f = do putStr (printf "Trying %-20s" (name f)); test f
19:48:52 <jethr0> with TH you can have a typesafe printf, but i guess that's cheating
19:48:52 <Korollary> SamB: Right, it's not exactly like the printf we know. You have to split the formatting characters, etc.
19:48:59 <SamB> huh>?
19:49:32 <twb> SamB: I think he means "printf :: Format -> a -> IO ()"
19:49:34 <SamB> our printf is probably about as type-safe as you can get without using TH...
19:50:05 <jethr0> and using TH would involve the rather obvious TH splicing syntax
19:50:10 <twb> where data Format = Number Alignment Int | String Alignment Int | ...
19:50:12 <SamB> yes
19:50:26 <jethr0> $(printf "%s %s") "hello" "world" just doesn't look all that nice
19:50:55 <SamB> Korollary: that doesn't count as "printf"
19:51:25 <SamB> you see, in order for something to count as printf, you see, it has to not only print, you see, but also except a format, um, string, you see?
19:51:34 <twb> Heh, C-c C-l doesn't work in haskell-mode if the file is gzipped.
19:52:08 <twb> printf/format is a DSL.
19:54:08 <palomer> who uses emacs anymore?
19:54:11 <palomer> use yi!
20:04:31 <Saulzar> There are some horrible printf libraries for C++ which try to look exactly like the C printf, garbage overloaded operators everywhere
20:04:35 <Saulzar> @where yi
20:04:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
20:05:27 <user311> hehe, is it something usefull?
20:05:31 <jethr0> Saulzar, they can't possibly be worse than C printf with varargs! those things are impossible to use!
20:05:55 <SamB> jethr0: aren't those used internally by the other ones?
20:06:05 <jethr0> other ones?
20:06:21 <SamB> or are you talking about something else?
20:06:25 <SamB> whats impossible to use?
20:06:31 <twb> Not enough people play SKEE-BALL..  They're always thinking about COCAINE or and ALIEN BEINGS!!
20:06:58 <SamB> @zippy
20:06:59 <lambdabot> Unknown command, try @listcommands.
20:07:02 <SamB> @pinhead
20:07:02 <lambdabot> Unknown command, try @listcommands.
20:07:05 <SamB> @zow
20:07:06 <lambdabot> What's the MATTER Sid? ... Is your BEVERAGE unsatisfactory?
20:07:54 <jethr0> samb, i'm talking about C "feature" for functions to accept an arbitrary number of arguments. "<varargs.h>"
20:08:29 <Saulzar> jethr0, They might be typesafe but hideously verbose
20:08:37 <jethr0> or rather stdarg.h
20:09:07 <jethr0> saulzar, i didn't find them all that typesafe... and using them is like dancing on crutches; you keep hurting yourself
20:09:15 <SamB>         #include <stdarg.h>
20:09:15 <SamB>       int vprintf(const char *format, va_list ap);
20:09:23 <jethr0> exactly
20:09:44 <jethr0> and handling that va_list is a nightmare
20:10:13 <Saulzar> jethr0, The ones I'm talking about are using overloading as a wrapper to C++ iostream stuff..
20:10:48 <jethr0> nah, these are good old C macros *hmm, macros*
20:10:56 <Saulzar> cout << boost::format("writing %1%,  x=%2% : %3%-th try") % "toto" % 40.23 % 50; 
20:11:09 <Saulzar> _why_ would you want anything which looked like that?
20:11:11 <jethr0> yes, that is hideously verbose
20:11:17 <twb> Saulzar: >scream<!
20:12:01 <jethr0> although using stdio's combinators for output formatting aren't human-usable either!
20:12:09 <jethr0> talking about verbose
20:12:25 <jethr0> not stdio
20:12:27 <jethr0> iostream
20:13:01 <jethr0> cout << setiosflags(ios::fixed) << setprecision(2) << x;
20:13:05 <Saulzar> Quite annoying, yes.. :)
20:13:26 <twb> Waah!
20:13:29 <twb> I miss local!
20:14:21 <Saulzar> Hmmm
20:15:26 <twb> I don't want these abstractions to be visible to the whole module!
20:16:15 <Saulzar> Hmm?
20:16:31 <jethr0> returning multiple functions from something like a let-block would also be nice :)
20:16:38 <Saulzar> Make a local function then? 
20:16:42 <twb> jethr0: that's what local is.
20:16:54 <jethr0> is or was?
20:16:55 <twb> Saulzar: it can't be local *and* shared by several top-level functions.
20:16:56 <Saulzar> I don't understand
20:17:01 <twb> jethr0: is, in SML.
20:17:03 <Saulzar> Ahh
20:17:18 <twb> I'll lisppaste an example.
20:17:25 <Saulzar> Nest them all in one function? :P
20:18:01 <lisppaste2> twb pasted "local!  local!  local!" at http://paste.lisp.org/display/14715
20:18:59 <jethr0> although i understand completely what you mean, your paste makes absolutely no sense to me in this context :(
20:19:18 <Saulzar> and you want something like lookAhead shared by all or? 
20:19:42 <lisppaste2> twb annotated #14715 with "with local..." at http://paste.lisp.org/display/14715#1
20:19:46 <Saulzar> Yep, don't see the connection
20:19:58 <jethr0> ahh, much better :D
20:20:26 <jethr0> he was trying to garner all the suspense he could (or she) :)
20:20:38 <Saulzar> Ah, yes... 
20:20:47 <twb> I'm a tree.  I'm hermaphroditic.
20:20:58 <jethr0> i hate it. there should be a gender neutral term for referring to people in a chat
20:21:12 <twb> jethr0: there is.  It's "OP".
20:21:17 <Saulzar> That would be nice - I'm not so bothered though, I've used C++ and OCaml a tiny bit before haskell and haskell is infinately better syntax than both :)
20:21:38 <twb> Saulzar: it's one of the few things SML does that Haskell doesn't do better.
20:21:51 <jethr0> hmm, but sharing code between function which is not visible at module level is sorely missing
20:22:23 <twb> So how do I submit an S^HHRFI ? ;-)
20:22:33 <Saulzar> Unless you have a huge module that shouldn't be a problem though, right?
20:22:42 <twb> Saulzar: it makes me feel dirty.
20:22:57 <twb> Saulzar: also, it'd be nice to call them all "mk" :-)
20:23:09 <jethr0> hmm, but having it would often make explicit exporting unnecesary because only exportable functions would be visible anyways
20:23:22 <Saulzar> I do it all the time, I expand out code to as many functions as I possibly can, that way I can understand it 
20:23:36 <twb> Saulzar: "expand out"?
20:23:48 <Saulzar> Seems experienced FP'ers condense code considerably compared to me
20:24:06 <jethr0> sure, as do i, but grouping these "helper" functions to their point of use could be supported by syntax... all i'm sayin'.
20:24:16 <Saulzar> Where as I require several functions and type signatures or I never see the light of day from the typechecker
20:24:32 <Cale> er, what?
20:24:33 <jethr0> saulzar, shorter code is not always better!
20:24:39 <Cale> what's that paste?
20:24:47 <jethr0> never mind :D
20:24:47 <twb> Cale: what #1?
20:25:03 <Cale> I get the parser bit
20:25:04 <twb> Cale: it's my Fantasy Haskell syntax.
20:25:18 <Cale> hmm
20:25:32 <twb> Probably the free variable p would need to be fixed.
20:25:36 <dons> Saulzar, we just play with @pointless until we can dream in pointfree style
20:25:43 <Cale> I'm not sure I understand how it's supposed to work
20:25:51 <Cale> oh
20:26:10 <Cale> why not simply define mk?
20:26:33 <jethr0> visibility
20:26:40 <Cale> If you're using it over and over again, it seems useful, might as well give it a name :)
20:26:53 <Cale> Don't export it if you don't want it to be visible
20:26:55 <jethr0> "mk" is a name too :)
20:27:11 <jethr0> sure, but we were talking about _in_-module visibility
20:27:23 <twb> Cale: I don't want to have to imagine a name for every mk function.
20:27:27 <jethr0> but then, modules should be short, i guess!
20:27:32 <twb> I'm not very creative -- it takes away time from coding.
20:27:33 <Cale> mk is a name :)
20:27:49 <palomer> grrr, the sablecc creator is rewriting sablecc, making me unable to write bindings (he's even changing the grammar!)
20:28:03 <dons> @pl  getRepos >>= showRepos >>= return . (:[])
20:28:04 <lambdabot> return `fmap` (showRepos =<< getRepos)
20:28:12 <dons> oh, wise guy, eh?
20:28:15 <twb> palomer: isn't sable a Java thing?
20:28:34 <jethr0> isn't sable an xml thing?
20:28:40 <palomer> twb: nope, it has bindings for 6 or so languages
20:28:57 <Cale> what we really want is to be able to have more than one module per file
20:29:01 <jethr0> dons, you should be happy that our wise l'bot helped you out here.
20:29:15 <jethr0> cale, that would be awesome!
20:29:29 <jethr0> but how would you find a module?
20:29:36 <Cale> grep
20:29:58 <jethr0> no, i mean Filename.ModuleName.functionName or what?
20:30:05 <dons> Heffalump's @. would be cool. we could pipe @pl into @type..
20:30:24 <dons> even @. djinn . pl . type
20:30:25 <Cale> just ModuleName.functionName as currently
20:30:28 <jethr0> i thought he wanted to glue @djinn and @pl together
20:30:41 <Cale> it would be the same as it is now, only you can put more than one module in a file
20:30:44 <jethr0> but how would ghc figure where to look for a module (or does that work already)?
20:30:55 <dons> well, I think it would be reasonable to parameterise @., jethr0
20:31:02 <Cale> make it look around in reasonable places :)
20:31:04 <jethr0> true
20:31:27 <jethr0> dons, i've wished for a way of combining l'bots commands too
20:31:56 <dons> yes, we've talked about scripting interfaces and such, it's an old idea. but I think a compose plugin is doable in, say, half a day.
20:32:03 <dons> i'm 1/4 of a day into it, atm :)
20:32:11 <jethr0> cool
20:32:24 <jethr0> what kind of day?
20:32:35 <Cale> a dons day
20:32:37 <Cale> heh
20:32:38 <dons> but a generic interface to the internals, using @eval, needs more thunks on my part
20:33:08 <twb> You save up thunks for a rainy day? ;-)
20:33:14 <dons> sure, that's what thunks are for
20:34:00 <jethr0> that's so cool. saving think time for when it is needed and then applying it to a problem with instant results. brilliant!
20:34:41 <dons> i think that's actually how a lot of problems get solved. we toss ideas out, ponder them, and come back in 6 months when it seems easy
20:34:58 <jethr0> true, over night seems to work often enough
20:35:13 <dons> yep.
20:35:47 <dons> nice syntax highlighting in curses seemed tricky, so I sort of abandoned it. over the next 6 months i did a bunch of other things, and now it's obvious.
20:37:34 <dons> hmm, I should write somthing on the lazy programmer's guide to lazy problem solving using laziness
20:37:46 <dons> lazily.
20:38:43 <dons> hmm, I think it was a design error in lambdabot to have process :: ... -> ModuleT s LB ()
20:38:53 <dons> instead of ModuleT s LB [String]
20:38:54 <dons> oh well.
20:40:00 <twb> dons: have you looked at slang instead of curses?
20:40:04 <Saulzar> dons, Yeah, I'm sure it just requires a little time :)
20:40:20 <twb> Several people recommended it to me, but I couldn't find any documentation for it so I went back to curses.
20:40:53 <dons> twb, no, but i've noticed only a few apps out there using it. the bare minimum XSI curses interface is really quite enough though
20:41:17 <dons> it's all about solving curses screens as a pretty printing problem, then it's dead easy
20:41:49 <twb> Can syntax colouring be mapped onto a pretty printing model?
20:41:55 <dons> yes
20:41:58 <twb> I'd never considered that before.
20:42:01 <dons> quite easily, that's why it worked
20:42:11 <twb> ...for things other than .hs files? ;-)
20:42:28 <dons> has nothing to do with what you're coloring. the original idea came from coloring hmp3 playlists
20:42:58 <twb> Is it user-extensible?
20:43:07 <twb> Or does it require recompiling?
20:43:08 <dons> you just need 2 things. 1 is a Doc type describing colored boxes of text, with combinators to compose them, and 2) a function :: Doc -> IO (), that calls curses
20:43:26 <dons> just use a combinator-based parser, yes.
20:43:40 <dons> or even without.
20:43:46 <dons> extensibility isn't the issue.
20:44:26 <dons> the user writes a nice pure function from AbsSyn -> Doc. and the ui then just knows how to draw such a type to a curses screen
20:45:02 <jethr0> dons, that sounds marvelously clean!
20:45:21 <twb> Have you added the possibility of Carbon/X11/GTK-type UIs?
20:45:35 <dons> it's just like the Hughes pretty printer, but for curses screens. and in that way is also like the higher level gui combinators
20:45:41 <twb> And components that aren't text / aren't monospaced?
20:46:10 <dons> well, this is curses, so it's all text.
20:46:16 <twb> Mmm.
20:46:28 <twb> But eventually you're gonna implement a web browser in it.
20:46:29 <dons> it's not an aalib
20:46:38 <dons> a text-based browser.
20:46:53 <dons> it _could_ be extended for arbitrary renderable thingies though
20:46:59 <twb> Well, w3m-el is a text browser, but it can display images, too.
20:47:02 <dons> you just extend the Doc type to other weird boxes
20:47:03 <twb> Yeah.
20:47:15 <twb> See, it's important to plan ahead for these things.
20:47:23 <dons> and write a function that calls the appropriate display routine
20:47:24 <twb> Otherwise you end up with Emacs.
20:47:49 <dons> I'd say emacs was pretty extensible :)
20:47:59 <twb> But the underside is a nest of kluges.
20:48:03 <jethr0> i think one of the problems of emacs is that they _did_ plan ahead decades
20:48:41 <jethr0> it's like the hurd phenomenon... too much planning can make you lose sight of the current situation!
20:48:56 <twb> Haha
20:49:13 <twb> The hurd problem is that by the time it's released, no one will use i386s.
20:49:22 <dons> yeah, the hurd is weird weird weird
20:49:38 <jethr0> and before you know it, nobody's using your system because it is supposedly too complicated even though superior to most alternatives
20:49:40 <twb> The hurd is the "100% right" mentality, in Gabriel terms.
20:49:44 <dons> someone should write a paper on why the hurd doesn't rule the world.
20:49:52 <twb> dons: they did.
20:49:57 <twb> dons: it's called "Worse is Better"
20:50:10 <twb> Only it's about UNIX vs. Lispm.
20:50:17 <twb> Instead of Linux vs. Hurd.
20:50:19 <Saulzar> What are the aims of the hurd? 
20:50:20 <dons> yes, but not about the hurd specifiically..
20:50:23 <jethr0> and the predominance of C
20:50:27 <twb> jethr0: indeed.
20:51:00 <jethr0> Saulzar, producing a microkernel based OS with everything daemonized and full user control
20:51:32 <jethr0> so you could run your own filesystem, or your own scheduler or whatever
20:51:35 <twb> Saulzar: ...as opposed to Linux' monolithic approach.
20:52:05 <jethr0> and they've been working on it since 1990 or something and getting _just_ fine with the 2 remaining part-time developpers they got
20:52:21 <jethr0> linus stole them all their momentum (if they ever had any :)
20:53:33 <Saulzar> Hehe, you think perhaps maybe more than 2 people work on Linux?
20:53:55 <jethr0> yes, actually a _lot_ more than 2!
20:54:38 <jethr0> i've been on hurd mailing list for the past year and they had like a total of 50 messages or so. and most of them administrative :(
20:54:50 <twb> jethr0: nah, linus just has lots of pseudonyms :-)
20:54:54 <cpatrick> jethr0: yeah, that's why they can rewrite the hotplug framework every second week
20:55:05 <cpatrick> in incompatible ways
20:55:14 <cpatrick> and different languages
20:55:37 <jethr0> yeah, or kick out working stuff like the sound system or the devfs. they love to keep things moving!
20:55:49 <jethr0> _and_ they develop in their "stable" branch
20:56:33 <tennin> eh, at this point the Hurd developers seem to be treating it more as an OS research project than as a software development project
20:56:59 <jethr0> there _are_ virtually no hurd developers. it's literally down to 2 guys or so
20:57:00 <cpatrick> and have been for the past 15+ years
20:57:36 <jethr0> if there were 20-30 people working on it, it would be running in a matter of weeks :(
20:57:39 <tennin> Brinkmann and Walfield?
20:57:57 <jethr0> don't know their names... you following it closely?
20:58:43 <tennin> I read the mailing lists occasionally
20:59:00 <jethr0> as did i. but traffic was rather low.
21:00:35 <jethr0> there are virtually no commits in 2005. and few in 2004
21:01:07 <dons> sometimes I wish I could use $  on the type level
21:01:32 <jethr0> dons, your types are too complicated :)
21:02:36 * dons can't wait for normal functions on the type level
21:04:05 <jethr0> huh?
21:04:28 * jethr0 is totally retarded when it comes to type theory. and not even all that eager to read dozens of papers on it...
21:04:29 <dons> type hackery for all
21:04:33 <jethr0> ah
21:07:04 <dons> death to tabs!
21:07:50 <jethr0> death to smoochy
21:08:29 <ozone> death to smooching?
21:08:43 <tenni1> my ~/papers contains 26 megs of .ps.gz, .pdf I've fooled myself into thinking I'll read someday
21:12:01 <tenni1> all accumulated over the past few weeks, so probably a few years from now it'll have grown to over 1 GB, all still unread
21:12:42 <kzm_> have you considered the three-pile method of oranizing things?
21:12:51 <SamB> tenni1: you could at least run gv on some of them
21:13:41 <tenni1> hmm.  does that count?
21:14:12 <tenni1> like the VCR that watches hours of tedious television so you don't have to?
21:17:03 <SamB> tenni1: no, like maybe you'll see the window lying about and start reading ;-)
21:17:33 <SamB> I really don't see what ADEpt meant about having messed up the code...
21:18:10 <dons> @pl get >>= \s -> mapM (listModule target) $ M.keys (ircModules s)
21:18:11 <lambdabot> mapM (listModule target) . (M .) . keys . ircModules =<< get
21:18:24 <dons> almost..
21:18:27 <dons> @pl get >>= \s -> mapM (listModule target) $ keys (ircModules s)
21:18:27 <lambdabot> mapM (listModule target) . keys . ircModules =<< get
21:18:58 <dons> why @pl reverses the >>= is beyond me
21:23:21 <kzm_> @type =<<
21:23:21 <lambdabot> parse error on input `=<<'
21:23:27 <kzm_> @type (=<<)
21:23:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
21:23:55 <kzm_> @type (>>=)
21:23:56 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:24:52 <kzm_> so it is equivalent?  (I didn't know there was a =<<)
21:25:10 <ricebowl> @type flip (>>=)
21:25:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
21:25:19 <ricebowl> @type (<<=)
21:25:20 <lambdabot> Not in scope: `<<='
21:25:25 <ricebowl> @type (=<<)
21:25:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
21:25:57 <ricebowl> > (\x -> (x+1):[]) =<< [1,2,3]
21:25:58 <lambdabot> [2,3,4]
21:26:06 <ricebowl> > [1,2,3] >>= (\x -> (x+1):[])
21:26:07 <lambdabot> [2,3,4]
21:26:53 <jethr0_> fmap (+1) [2,3,4]
21:26:57 <jethr0_> > fmap (+1) [2,3,4]
21:26:58 <lambdabot> [3,4,5]
21:32:16 <palomer> > map (+1) [2,3,4]
21:32:17 <lambdabot> [3,4,5]
21:32:25 <palomer> is fmap useful?
21:32:36 <jethr0> yes, for monads other that List
21:32:36 <Cale> yes
21:32:42 <Cale> and other functors
21:32:45 <jethr0> > fmap (+1) (Just 1)
21:32:46 <lambdabot> Just 2
21:32:55 <jethr0> > fmap (+1) Nothing
21:32:56 <lambdabot> Nothing
21:33:01 <Cale> @type fmap
21:33:02 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
21:33:17 <Cale> I think they should replace map with it
21:33:23 <dons> and for @pl
21:33:30 <jethr0> cale, what are examples of non-monad-only functors?
21:33:54 <dons> there's plenty in Data.*
21:34:16 <dons> instance Functor (Map k) where
21:34:30 <jethr0> i'll have a look in Data, thx
21:34:35 <dons> anything data structure you want to be able to map over
21:34:39 <Cale> Queue
21:34:58 <jethr0> what does fmap do in the IO monad?
21:35:10 <Cale> same as liftM does
21:35:17 <jethr0> ah
21:35:33 <Cale> liftM f x = do { v <- x; return (f v) }
21:35:56 <jethr0> yah
21:35:58 <Cale> liftM is kind of silly
21:36:43 <Cale> but we're allowed to have monads which aren't defined as functors, so you get things like this
21:36:55 <ricebowl> I thought all monads were functors?
21:36:59 <ricebowl> by definition
21:37:07 <Cale> yes
21:37:10 <Korollary> Has everybody seen this nice Haskell Monads paper on LtU?
21:37:17 <Cale> but not all Monads are Functors :)
21:37:27 <ozone> cale: ?
21:37:29 <dons> class  Monad m  where doesn't require Functor
21:37:30 <Cale> (i.e. Haskell doesn't require it)
21:37:56 <Cale> I think it should
21:37:58 <kmag> so... I've got some example Haskell by Autrijus Tang from perl.com, but hugs doesn't like it... (probably a dumb typo on my part, but I'm new at Haskell)  Are any of you kind enough to take a look at a pastebin of it?
21:38:03 <dons> but if you do have an instance of both Monad and Functor, then you should have > fmap f xs  ==  xs >>= return . f
21:38:04 <ozone> oh, right
21:38:09 <Cale> lisppaste2: url
21:38:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:38:19 <Cale> kmag: sure
21:38:29 <lisppaste2> kmag pasted "example from perl.com" at http://paste.lisp.org/display/14718
21:38:33 <ricebowl> Cale - I see
21:38:37 <ricebowl> well, that doesn't make sense then
21:38:44 <kmag> (yea... I had teh paste ready to go)
21:39:04 <Cale> kmag: possibly indentation
21:39:18 <Cale> kmag: untab the where a little, and tab in the guards
21:39:20 <kmag> I believe I used a tab
21:39:26 <kmag> oh
21:39:29 <Cale> oh, and don't use tabs
21:39:37 <ricebowl> tabs work fine
21:39:39 <Cale> have your editor convert them to spaces
21:39:42 <ricebowl> just make sure you use them properly
21:39:45 <kmag> ERROR hamming.hs:5 - Syntax error in declaration (unexpected `;', possibly due to bad layout)
21:39:46 <Cale> tabs will count as 8 spaces
21:39:46 <dons> I voet for -fwarn-all-tabs
21:39:59 <Cale> yes
21:40:18 <dons> I had a type error today that I scratched over for maybe 10 mins until I realised someone had dumped evil tabs into lambdabot src
21:40:25 <Cale> the lines starting with | should be in a little further than the xss@...
21:40:30 <dons> :retab solved the type error.
21:40:40 <jethr0> tab / space problems can be excrutiating in python! that's when i stopped using tabs...
21:40:40 <ricebowl> dons - isn't that more of a language-level problem?
21:40:48 <dons> hmm, maybe haskell mode in vim should color tabs red...
21:40:53 * dons hacks some VimScript
21:41:24 <kmag> so should the where line be tabbed in a bit less than the xss@... line?
21:41:26 <jethr0> dons, you can do that with a simple :syn addition!
21:41:39 <dons> yep
21:41:57 <Korollary> kmag: the lines following xss should be indented more than xss
21:42:00 <Cale> kmag: yeah
21:42:09 <kmag> and I also have a typo on the last line
21:42:17 <Cale> the xss@ line is "inside" the where
21:42:31 <Cale> and the |... lines are "inside" the definition of xss
21:42:40 <kmag> it seemed to run...
21:42:40 <Cale> er, really the definition of ~~
21:42:53 <Cale> it runs now?
21:43:08 <kmag> well... it didn't "print" anything
21:43:37 <kmag> I'm not sure where to expect the hamming numbers to be output
21:43:46 <Cale> how are you running it?
21:43:54 <kmag> hugs hamming.hs
21:44:00 <Cale> type 'main'
21:44:06 <ricebowl> @type freeze
21:44:07 <lambdabot> Not in scope: `freeze'
21:44:13 <ricebowl> @type Data.Array.MArray.freeze
21:44:13 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *).
21:44:13 <lambdabot> (Data.Array.Base.IArray b e,
21:44:13 <lambdabot> Data.Array.Base.MArray a e m,
21:44:13 <lambdabot> GHC.Arr.Ix i) =>
21:44:13 <lambdabot> a i e -> m (b i e)
21:44:21 <kzm_> dons: why not set tab stops to 8 (or however it is interpreted by the compiler)? :-)
21:44:42 <Cale> kmag: or even just 'hamming', but it will never finish :)
21:44:47 <kmag> ooh... pretty numbers :-D
21:45:19 <dons> hi link tabNasty Todo
21:45:20 <dons> ;)
21:45:59 <dons> kzm_, I already do have tabs at 8, but since I indent to 4, things can (sometimes, rarely) look ok, but introduce errors
21:46:06 <dons> esp. if editing others tabified code.
21:46:24 <Cale> not everyone who is reading the code will have their tabs set at 8
21:46:27 <kmag> is there a "standard" depth to make indentations in Haskell code?
21:46:33 <dons> but 1 line of vimscript solves this. nonetheless, I'm waiting for -fkill-tabs-with-hammer in the new ghc
21:46:39 <Korollary> kmag: no
21:46:39 <kmag> 4 spaces, 8 spaces?
21:46:47 <Cale> kmag: it's usually determined by structure
21:46:55 <Cale> basically, you make things line up
21:47:02 <dons> 2, 4, 8. 4 is most common, I would guess.
21:47:10 <Cale> 4 is common otherwise
21:47:24 <Cale> 2 is usable
21:47:26 <kmag> Most of my work now-days is in Java and Python
21:47:43 <dons> highlighting tabs as bright orange really helps eliminate them. I should have done this years ago.
21:48:04 <Korollary> dons: That's a good idea. I wish haskell-mode did that.
21:48:32 <dons> well, here's the vimscript:
21:48:32 <dons> syn match tabNasty display "\t"
21:48:33 <dons> hi link tabNasty Todo
21:48:36 <Cale> 'night all
21:48:47 <Korollary> night Cale
21:48:52 <kmag> night Cale
21:48:54 <kmag> and thanks
21:49:06 <kzm_> There is a standard definition for tab sizes, isn't there?
21:49:08 <Cale> kmag: have fun with Haskell :)
21:49:17 <kmag> Cale: will do
21:49:22 <dons> kzm, 8, from the report.
21:49:28 <Korollary> kzm_: the language will assume it's 8 spaces if you use them.
21:49:31 <kzm_> Right.
21:50:02 <jethr0> night
21:50:03 <kzm_> So, while they are Evil anyway, 8 is the only choice.
21:50:11 <kzm_> Good morning here :-)
21:50:21 <Korollary> good @localtime
21:50:57 <Korollary> @localtime >>= \t -> good t
21:51:00 <kmag> hmm... so the code output from that example:
21:51:05 <kmag> take 10 hamming 
21:51:24 <kmag> [1,2,4,8,16,32,64,128,256,512]
21:51:42 <kzm_> Perhaps IO should be allowed, but restricted to other bot commands?
21:51:50 <kmag> whereas I would have expected [1,2,3,4,5,6,8,9,10,12 ...]
21:51:52 <kzm_> Not being able to recurse seems....wrong, somehow.
21:52:21 <Korollary> kmag: Did you really get powers of 2? weird...
21:52:33 <kmag> hugs bug?
21:52:39 <jethr0> unlikely
21:53:00 <kmag> should I pastebin again?
21:53:33 <dons> kzm_? you want to combine lambdabot commands inside an @eval ?
21:53:44 <Korollary> I got the same in ghc
21:53:45 <palomer> > 2+4
21:53:46 <lambdabot> 6
21:53:58 <dons> this will be possible in the new @./@compose plugin on its way
21:54:00 <palomer> today I constructed the natural numbers for my students
21:54:17 <palomer> non of them were bedazzled
21:54:26 <kzm_> dons: yeah, basically. Can I?
21:54:32 <dons> not yet, but soon
21:54:39 <kzm_> Ah, sorry missed that comment.
21:54:51 <kzm_> bercool.
21:55:42 <kmag> so... any idea what's wrong with the hamming number code?
21:55:54 <Korollary> kmag: you have a typo
21:55:56 <lisppaste2> kmag annotated #14718 with "revised example from perl.com" at http://paste.lisp.org/display/14718#1
21:56:41 <lisppaste2> Korollary annotated #14718 with "typo fixed" at http://paste.lisp.org/display/14718#2
21:57:08 <Korollary> palomer: haha
21:57:20 <palomer> s/non/none
21:57:38 <Korollary> palomer: Did they tell you "big deal, egghead!" ;)
21:58:58 <kmag> damned tabs!
21:59:14 <kmag> thanks Korollary
21:59:21 <Korollary> np
21:59:46 <Korollary> If I can wake up, I'll read some more from TaPL...
22:01:23 <kmag> actually... there weren't tabs... there must be something goofy with my console... brb..
22:01:47 <Korollary> kmag: it wasn't tabs. You had a typo in the 2nd line of the pattern match.
22:03:16 <kmag> :-D
22:04:01 <dons> @pl map (\t -> "  "++t) msg
22:04:01 <lambdabot> map ("  " ++) msg
22:04:51 <Saulzar> Hmm, what kind of time resolution can I expect concurrency operators to work at? If I wanted to pass messages to/from 10-20 threads at 50 fps would that be too much?
22:06:07 <dons> @pl do p <- liftIO $ babelFish f t i ; return [p]
22:06:07 <lambdabot> (line 1, column 34):
22:06:07 <lambdabot> unexpected ";"
22:06:07 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
22:06:14 <dons> @pl do p <- liftIO (babelFish f t i) ; return [p]
22:06:14 <lambdabot> (line 1, column 34):
22:06:14 <lambdabot> unexpected ";"
22:06:14 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
22:06:16 <dons> bah
22:06:39 <dons> Saulzar, the schedular switches at 20ms, but is tunable
22:07:02 <Korollary> dons: What's the type of babelfish ? String -> Maybe [String] ?
22:07:24 <dons> babelFish :: String -> String -> String -> IO String
22:07:43 <Korollary> ah, the 3rd is the language name?
22:07:52 <dons> babelFish inLang outLang string
22:08:05 <dons> Saulzar, read:
22:08:10 <dons> @docs Control.Concurrent
22:08:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:08:40 <kmag> dons: this is for the hugs scheduler?
22:09:09 <Saulzar> I'm trying to figure out how best to implement running several bots in a way that one can't hog the cpu 
22:09:12 <dons> that was for the ghc schedular, not sure about hugs.
22:09:37 <kmag> so are multiple concurrent operations multiplexed on a single os-level thread?
22:09:43 <dons> bah, Either monad is for silly-heads
22:11:46 <Saulzar> Cool, if it can be adjusted then it might be possible to run 1 at a time in just 1 thread
22:12:52 <Saulzar> (Or rather, spawn 1 at a time and timeout for each)
22:18:00 <adu> can you do find/replace on expressions in haskell?
22:19:20 <dons> hmm?
22:20:28 <adu> is there a way you can take an expression, like a list, or a formula and find/replace 'a' with 'b' in it?
22:21:30 <aleator> Saulzar: Are you still making a programming game?
22:22:04 <dons> adu, in your editor?
22:22:17 <dons> or in some refactoring ide?
22:22:29 <Saulzar> aleator, Yep.. slowly :)
22:22:43 <adu> no not in an editor or ide, but in code
22:23:14 <dons> oh, I see:
22:23:35 <aleator> Saulzar: Neat. Haskell programmable or generally programmable?
22:23:41 <dons> > map (\c -> if c == 'X' then '$' else c) "aXbXc"
22:23:43 <lambdabot> "a$b$c"
22:23:59 <dons> is that what you mean? I'm uncertain exactly what you're trying to do adu.
22:24:20 <dons> @pl map (\c -> if c == 'X' then '$' else c) "aXbXc"
22:24:21 <lambdabot> map (flip if' '$' =<< ('X' ==)) "aXbXc"
22:25:13 <Saulzar> aleator, Haskell programmable, I'm using Yampa for the bots - which looks like it should work out well...
22:25:33 <jethr0> note to self: switching to ratpoison as your window manager before reading some docu - _not good_
22:25:57 <dons> jethr0, use ion!
22:26:05 <dons> it's the most popular wm in #haskell
22:26:09 <dons> just ask tuomov :)
22:26:20 <jethr0> haha
22:26:27 <sieni> ion is pretty nice
22:26:36 <Saulzar> aleator, I haven't got far - but I've got something moving and on the screen (in a straight line) - so it's something to go by :)
22:26:39 <jethr0> fluxbox isn't all that bad either
22:27:04 <dons> but that's a completely different paradigm. are you looking for a mouseless efficient wm?
22:27:09 <cpatrick> ion is nice. so is ratpoison. but I'm using GNOME for now, partly through inertia
22:27:19 <jethr0> i'm thinking about it. using my mouse p*sses me off
22:27:27 <sieni> sawfish is nice as well <3
22:27:32 <dons> ah well, it's your time you're wasting cpatrick dragging windows around ;)
22:27:32 <jethr0> hehe
22:27:37 <cpatrick> when you use a full-screen xterm most of the time, it doesn't matter much what WM you use ;)
22:27:38 <jethr0> as is fvwm
22:27:47 <sieni> jethr0: use a trackball, it's nearly not as annoying
22:28:01 <dons> i like the accupoint thingies in ibm and toshibas
22:28:09 <jethr0> still, taking my hands off the keyboard and putting them on the mouse will give me RSI too soon
22:28:11 <dons> i wish all keyboards had them
22:28:19 <cpatrick> dons: the clit ones? or the touchpad ones?
22:28:24 <dons> the former, yes.
22:28:24 <Korollary> jethr0: which app makes you use the mouse? the browser?
22:28:26 <Saulzar> accupoint? Are those the little fuzzy dot thingeys?
22:28:53 <jethr0> Korollary, i'm using it generally too much...
22:28:56 <dons> yep, fuzzy dots, but you can get all sorts. there's also flat ones.
22:29:08 <Saulzar> Notepad input devices suck :)
22:29:08 <dons> and convex/concave ones
22:29:24 <Saulzar> Er, notebook ;)
22:30:04 <Korollary> I own a tablet, but I can't use it to enter text (at least in windows).
22:31:07 <jethr0> dons, you tried ion?
22:31:13 <jethr0> ratpoison i mean
22:31:33 <dons> a few years ago
22:31:41 <jethr0> so how does it compare to ion?
22:31:51 <dons> at the time at least, ion was more featured, more stable
22:31:57 <dons> and ion has progressed at lot since then.
22:32:11 <jethr0> hmm, so what's it like. you using the mouse at all?
22:32:12 <dons> don't know what ratpoison's been up to. tuomov is the guy to ask.
22:32:17 <dons> i don't have a mouse :)
22:32:18 <jethr0> ya
22:32:25 <jethr0> smart move
22:32:35 <dons> haven't had a mouse since about day 10 of using ion
22:32:43 <jethr0> so you shun mouse-heavy applications?
22:32:56 <dons> sort of, but I still use gimp, mozilla and so on.
22:33:03 <jethr0> gimp w/o mouse?
22:33:09 <araujo> Hello.
22:33:11 <dons> i have an accupoint :)
22:33:31 <dons> it's way more efficient than a mouse. 
22:33:36 <Saulzar> Web browsing without a mouse would seem difficult...
22:33:45 <dons> Saulzar, try w3m ;)
22:33:54 <jethr0> what is that?
22:33:56 <cpatrick> Saulzar: sabetts did a firefox hack that had emacs keybindings and didn't use the mouse
22:33:59 <dons> @google w3m
22:34:01 <lambdabot> http://w3m.sourceforge.net/
22:34:05 <cpatrick> can't remember the name of it now
22:34:10 <Saulzar> I have used lynx..
22:34:17 <dons> @where+ w3m http://w3m.sourceforge.net/
22:34:18 <lambdabot> Done.
22:34:19 <jethr0> *bah* lynx
22:34:29 <dons> w3m is a better lynx
22:34:34 <cpatrick> Saulzar: if you want to remain sane with text-based browsers, you want w3m
22:34:35 <jethr0> w3m's keybindings are very _special_
22:34:57 <Saulzar> I don't use lynx except in emergencies :)
22:35:39 <jethr0> dons, _can_ you use the mouse in ion?
22:35:45 <jethr0> for moving windows, etc?
22:35:47 <dons> sure.
22:36:07 <jethr0> nice, i think i'll give ion a try
22:36:55 <sieni> can you actually move windows in ion like in a conventional window manager?
22:37:02 <Saulzar> Hmm, I've never really been convinced by the all-keyboard approaches - I never have trouble inputting/typing faster than I can think.
22:37:06 <sieni> or just move them between frames
22:37:40 <jethr0> saulzar, how is that not a contradiction?
22:38:09 <Saulzar> Well, the benefit of the all keyboard approaches has always been so called improved efficiency
22:38:54 <jethr0> Saulzar, i just don't like using the mouse. in most cases it seems inferior to expressing things in text
22:39:03 <Saulzar> I'm just saying that I can do without it, I would rather focus on the task at hand
22:39:13 <sieni> of course one difficulty is that one has to tolerate crappy web browsers
22:39:15 <jethr0> for example, i've never gotten used to drag-and-drop. especially not for file copying/moving
22:39:30 <Saulzar> I never use a gui file manager either
22:39:55 <jethr0> Saulzar, that's all i'm saying. who knows whether i won't miss my mouse in a few hours :)
22:40:03 <Saulzar> But I much prefer an IDE to a text editor 
22:40:17 <adu> i love text editors
22:41:28 <Saulzar> Maybe I'm just stubborn to change :)
22:41:55 <Saulzar> Hmm, so Ion works by using tabs on everything?
22:42:56 <jethr0> Saulzar, some say emacs is both :)
22:43:23 <jethr0> yup, and i'm actually pretty pleased with it. now, if i only knew a single key binding :)
22:43:33 <Saulzar> Hah.
22:44:22 <sieni> jethr0: you get the man page with Mod1-F1 (or something
22:44:23 <sieni> )
22:44:37 <jethr0> thx
22:44:48 <sieni> If you don't know which one is Mod1, then you can press F1 and type in ion and read the man page
22:44:48 <jethr0> i got no meta, is that a problem?
22:44:56 <jethr0> i mean windows key
22:45:20 <jethr0> nice, instant manpage
22:47:46 <Saulzar> Somone should invent garbage collecting interfaces 
22:47:56 <jethr0> hehe
22:48:10 <Saulzar> That is - when you open too much random stuff and never look at it, it slowly gets rid of it 
22:48:14 <jethr0> but it's hard to keep track of the references, as they lie in the wetware
22:48:32 <Saulzar> Hehe.
22:48:55 <Saulzar> I have 15 konqueror windows open right now, each with 4 or 5 tabs..
22:49:50 <aleator> Urgh. I Should not have counted. I have 63 open windows/tabs..
22:50:55 <Saulzar> The thing is, most of it is useless .. I'll just have to close it all down
22:50:56 <jethr0> *yuch* konqueror
22:54:24 * Saulzar keeps on hitting je\tab and getting jesse 99
22:56:25 <jethr0> Saulzar, i absolutely _love_ ion!!
22:57:18 <jethr0> although its multi-dimensionality takes some getting used to
23:02:14 <Saulzar> Say that again in a month :)
23:03:26 <SlowByte> I had Opera open with 160 tabs... now it's only ~80 tabs, moved the ones I have to read "later" to bookmarks ;)
23:05:59 <sieni> Well, I actually use bookmarks for bookmarking :-)
23:06:59 <Saulzar> Bookmarks are like tabs, too optimistic - need garbage collection.
23:08:47 <Saulzar> Though I recall MS word does that with menus, which only annoys you because when looking for something you always assume it must be hidden
23:09:27 <SlowByte> I open way too many tabs, so I find it helpful to postpone reading them for a certain amount of time, when I return to the subject later, my mind is clearer so I can filter out the chaff faster
23:09:59 <SlowByte> of course, reading them later only increases their amount ;)
23:10:44 * jethr0 tends to go on bookmark sprees and never ever return to them
23:10:50 <Saulzar> Yep
23:10:55 <SlowByte> the more effective I am, the more work (reading) I take on so the speed of completing one task tends to stay the same or even decrease
23:11:37 <jethr0> i found it most effective to research a topic completely in google, bookmark everything and wade through it one by one
23:11:38 <lightstep> is there case-insensitive string comparison, or should i use map toUpper?
23:11:49 <jethr0> otherwise i tend to visit the same sites over and over
23:12:13 <SlowByte> I don't have that problem... the internet is just too big ;)
23:12:55 <Saulzar> I do that, same papers/sites pop up all the time
23:13:34 <jethr0> but now i've got 2000 good bookmarks, most of which i haven't "consumed" yet :(
23:14:35 <SlowByte> of course, I have a weird memory for things so I find myself subconsciously steering away from what I've already read
23:15:01 <SlowByte> but I could forget putting on my pants in the morning
23:15:25 <jethr0> also, i have a nack for collecting things. i've got 4000 pages worth of CS papers most of which i'd like to read someday, but most likely most i never will
23:26:01 <sethk> jethr0, I have more things I haven't read than you do.   :P
23:26:10 <jethr0> :)
23:26:23 * jethr0 is in the process of reconfiguring his gui approach
23:26:29 <jethr0> xchat => irssi
23:28:19 <mwc> Wow, Epigram looks really cool
23:28:49 <mwc> if we can get an Epigram implementation to the performance standards of something like ocaml by 2007, I'll be a happy lad
23:29:56 <mwc> just as a quick question, in case I missed something
23:30:24 <mwc> how is a dependent type in Epigram different from say, C++ templates being able to be generalized int-wise?
23:31:40 <jethr0> okay, time to go to bed
23:31:44 <jethr0> nite @ all
23:32:12 <sieni> nite? NITE? some people have to go to WORK! :-)
23:32:21 <Heffalump> morning :-)
23:33:03 <shapr> yow!
23:33:28 * shapr is starting work.. with Haskell!
23:39:29 * aleator has been at work for hour and half now. Also doing haskell.
23:40:49 <shapr> aleator: Yay! What are you writing? Something nifty?
23:41:02 <shapr> I'm just writing my unit tests in Haskell, but it should make for a good TMR article next issue.
23:43:00 <aleator> shapr: I'm doing computer vision. Though I have to admit that my work is university research..
23:43:17 <shapr> Oooh, using the Fvision bindings?
23:44:11 <aleator> No. I made a binding for intel OpenCV.
23:44:22 <shapr> Fvision is functional reactive bindings on top of XVision - http://haskell.cs.yale.edu/yale/papers/padl01-vision/
23:44:29 <shapr> @google intel opencvs
23:44:30 <lambdabot> http://www.rtems.com/ml/rtems-users/2002/november/msg00219.html
23:44:34 <shapr> doh, fingers faster than brain
23:44:37 <shapr> @google intel opencv
23:44:37 <lambdabot> http://www.intel.com/research/mrl/research/opencv/
23:45:57 <shapr> Oh that looks nifty.
23:46:06 <shapr> aleator: Sounds like fun research.
23:46:25 <aleator> opencv is really hairy c. But a haskell binding makes it very nice.
23:46:39 <shapr> Have you considered using FRP on top of the binding?
23:47:06 <shapr> hoi Itkovian
23:47:21 <Itkovian> hi shapr
23:47:24 <shapr> goede morgen
23:47:31 <Itkovian> all is well up north?
23:47:47 <aleator> shapr: Not really.
23:47:51 * araujo wonders if he should continue eating ice cream or not
23:48:00 <shapr> Yeah, the sunrise slowly approaches... there's a pink ribbon of morning over the hills.
23:48:36 <aleator> shapr: Yeah it is rather fun. Though images I get are mostly gray with gray noise. 
23:48:37 <shapr> Itkovian: How's code in the big city?
23:48:49 <shapr> aleator: Got any pretty demo pix we can see?
23:49:33 <aleator> shapr: let me see.. Though they are really boring. :)
23:49:58 <shapr> Hey, I like anything where I can say "Look, proof of computer vision with Haskell!"
23:51:05 <Itkovian> Well, this city isn't that big.
23:51:18 <Itkovian> Code is ok, I guess, though I'm not coding very much these days
23:51:26 <Itkovian> Mostly analysis stuff.
23:51:34 <aleator> shapr: http://www.cc.jyu.fi/~aleator/M014-Vana.png and http://www.cc.jyu.fi/~aleator/M014-Vana-detected.png.
23:52:36 <shapr> aleator: Looks neat. Is this the sort of thing I can mention in Haskell Weekly News, or would you rather keep it quiet?
23:53:53 <aleator> Well, you can. but the image is not to be distributed.
23:54:23 <shapr> Do you have an image I can link to?
23:54:50 <shapr> Hey mwc, Epigram really is cool.
23:55:19 <aleator> Hmm.. I can make you one. How about lena and some filtering?
23:55:32 <shapr> aleator: No clue what that means, so .. Yeah sure!
23:56:12 <aleator> see www.lenna.org  :)
23:56:38 <shapr> Oh! Yeah!
23:56:40 <earthy> lena is cool. :)
23:56:56 <earthy> that line detection was also pretty neat
23:57:04 <earthy> took me some time to see the line myself, even ;)
23:57:47 <aleator> That was bloody hard you know.. And I still don't know if works for any other streak than the one on the test picture.
23:59:12 <tuomov> that's how 90% of all papers signal processing are generated anyway; finding the right constant to make a particular example work :)
23:59:50 <aleator> Yep.
