00:09:03 <JohnMeacham> hmm.. still no boxy types experts around?
00:09:18 <JohnMeacham> does SPJ ever use #haskell?
00:21:23 <Heffalump> he did once
00:21:31 <Heffalump> but I don't think he's been back
00:22:03 <JohnMeacham> hmm.. 
00:37:56 <gour> dcoutts: ping
01:14:12 <araujo> Hello.
01:16:55 <Lemmih> Hiya araujo.
01:18:51 <araujo> Hello Lemmih 
01:18:54 <araujo> What's up?
01:21:51 <araujo> mmmm....
01:22:34 * araujo doesn't get it
01:23:14 <araujo> I sometimes test a programm which doesn't work ... and when i test it later on, it works.
01:23:18 <Lemmih> Enjoying my new 8mbps broadband connection while trying to decide whether to hack Haskell or create some chistmas presents.
01:23:50 <araujo> Nice.
01:24:25 <araujo> I'd go with hacking haskell .. 
01:25:07 <araujo> Though i am not usually too social :-]
01:45:53 <shapr> whee
01:52:19 <maitscha> hello, i would like to know how it is possible to write a test-script for a haskell-module. i wrote a script with the testinput, and made hugs module_to_test.hs < tests.txt. is there a better way?
01:52:29 <Cale> ski is participating in the nickname slalom event
01:52:53 <Cale> maitscha: you could include the tests in the code
01:53:01 <maitscha> ... i would like to make some unit-testing...
01:53:06 <Cale> There are tools like HUnit and QuickCheck
01:53:09 <maitscha> Cale, how?
01:53:26 <Cale> HUnit is a unit testing facility
01:53:31 <maitscha> i don't think it is the proper way to include tests into the code...
01:53:49 <Cale> and QC is a tool to randomly generate tests of properties
01:53:50 <maitscha> QuickCheck?
01:53:54 <Cale> yeah
01:54:50 <Cale> Well, you ought to include them somewhere in the code. It seems silly to have to carry out testing with external tools, when you have a beautiful functional language to do it in :)
01:55:24 <Cale> http://www.cs.chalmers.se/~rjmh/QuickCheck/
01:55:50 <Cale> http://hunit.sourceforge.net/
01:55:57 <Cale> both are included in GHC
01:56:07 <Cale> (maybe hugs too)
01:56:39 <Cale> Under Test.QuickCheck(.*) and Test.HUnit(.*)
02:01:07 <maitscha> ok. thx.
02:09:47 <maitscha> is there a function which only prints a text to output?
02:11:13 <Oejet> @type putStr
02:11:14 <lambdabot> String -> IO ()
02:11:26 <Oejet> @type print
02:11:26 <lambdabot> forall a. (Show a) => a -> IO ()
02:17:10 <dcoutts> gour, pong
03:20:13 <audreyt> @pl \a b c -> a b c
03:20:14 <lambdabot> id
03:22:42 <audreyt> @pl \f a b c -> f c a b
03:22:42 <lambdabot> (flip .) . flip
03:23:54 <ski_> @pl \x y z -> x z (y z)
03:23:54 <lambdabot> ap
03:26:09 <ski_> @pl \f k -> f (\k' -> k' . k) (\o -> o)
03:26:10 <lambdabot> flip flip id . (. flip (.))
03:31:38 <audreyt> @pl \a b c -> b c a
03:31:38 <lambdabot> flip flip
03:31:47 <audreyt> @pl \a b c -> f b c a
03:31:48 <lambdabot> flip (flip . f)
03:33:36 <ski_> @pl \f a b c -> f b c a
03:33:36 <lambdabot> flip . (flip .)
03:33:52 <Azmo> have anyone tried out ghc 6.4.1 ? it does not seem to work for me. strange errors when importing modules.
03:35:01 <ski_> @pl \please pretty -> coin pretty please
03:35:01 <lambdabot> flip coin
03:39:16 <Lemmih> Azmo: What kind of errors?
03:39:44 <Azmo> ht.o(.text+0x46):fake: undefined reference to `W_wbeep_closure'
03:39:45 <Azmo> ht.o(.text+0xa4):fake: undefined reference to `W_wbeep_closure'
03:39:45 <Azmo> ht.o(.text+0xe3):fake: undefined reference to `__stginit_W_'
03:39:45 <Azmo> ht.o(.rodata+0x0):fake: undefined reference to `W_wbeep_closure'
03:39:45 <Azmo> ht.o(.rodata+0x8):fake: undefined reference to `W_wbeep_closure'
03:39:45 <Azmo> collect2: ld returned 1 exit status
03:40:12 <Azmo> ..for module W exporting wbeep. which is imported and used in another module that i am compiling.
03:41:06 <Lemmih> Use 'ghc --make'.
03:42:10 <Azmo> Lemmih: *arg* :[. not that mistake again.
05:12:02 <dsacode> Hello! I try to understand this definition: fib = 0 : 1 : [ this + next | (this, next) <- zip fib (tail fib) ] ; What does mean notation in square brackets? How does it work?
05:12:58 <basti_> its pretty simple. it's called a "list comprehension"
05:13:18 <basti_> > [a | a<-[2,3,4,5]]
05:13:19 <lambdabot> [2,3,4,5]
05:13:37 <basti_> > [a+b | a<-[2,3], b<-[3,4]]
05:13:38 <lambdabot> [5,6,6,7]
05:13:47 <basti_> > [a+b | a<-[(2,3),(3,4)]]
05:13:48 <lambdabot>  Not in scope: `b'
05:13:52 <basti_> oops
05:13:55 <basti_> > [a+b | (a,b)<-[(2,3),(3,4)]]
05:13:56 <lambdabot> [5,7]
05:14:26 <basti_> its a little stupid to use it in this situation, since zipWith (+) would do exactly the same
05:16:17 <benny> @seen dcoutts 
05:16:18 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #
05:16:18 <lambdabot> haskell. Last spoke 2 hours, 59 minutes and 7 seconds ago.
05:16:26 <dcoutts> benny, hia
05:16:28 <benny> hey man!
05:16:55 <benny> dcoutts: sorry to wake you, but does gtk2hs have MessageDialog support? i can't find it
05:16:56 <joelr1> howdy folks
05:17:18 <dcoutts> benny, ah, in my tree is does (sort-of) I've not added it yet.
05:17:32 <benny> dcoutts: i see... it's pretty useful
05:17:34 <joelr1> assuming that I have data Foo = Foo [Something] | Bar Int Int  | Baz ...
05:17:41 <dcoutts> benny, the reason it wasn't in yet is that a message dialog is pretty simple to construct
05:18:05 <benny> simple, but annoying :)
05:18:11 <joelr1> is there a way to derive show so that custom printing is only used for the Foo constructor and the rest is printed normally?
05:18:32 <benny> dcoutts: btw, did you see this?
05:18:33 <benny> http://img215.imageshack.us/img215/6171/stringprocgui0021gh.png
05:18:53 <joelr1> something like 
05:18:53 <joelr1> instance Show Foo where 
05:18:53 <joelr1> show (Foo x) = custom printing
05:18:53 <joelr1> show x = show x
05:19:00 <joelr1> i don't think this will work, though
05:19:56 <dcoutts> benny, looks nice, is that what you're coding?
05:20:12 <benny> dcoutts: yeah, check this one out too: http://img223.imageshack.us/img223/5392/stringprocgui0046yk.png
05:20:33 <dcoutts> benny, so what is it doing exactly?
05:21:13 <benny> dcoutts: it's like a mini-ide for writing your own string processor function :)
05:21:28 <dcoutts> benny, cool
05:21:41 <joelr1> any ideas?
05:22:17 <dcoutts> benny, ah, I remember the othere reason. MessageDialog is hard to bind because it uses variable length argument lists and printf style format strings.
05:22:45 <benny> i see
05:27:49 <Lemmih> joelr1: differentShow (Foo x) = customPrint; differentShow x = show x?
05:28:06 <joelr1> Lemmih: well, i want Show to be used, see
05:28:26 <joelr1> Lemmih: i.e. my show to be used automatically when Foo is printed
05:34:31 <benny> dcoutts: what about support for gtk actions, is it working?
05:35:14 <dcoutts> benny, I beleive so, though I've never used them. Axel did that bit.
05:36:03 <shapr> test driven development r0xx
05:36:07 <benny> cool
05:36:11 <dcoutts> benny, there's an example here: http://www.cs.kent.ac.uk/projects/pivotal/programs/bones/Main.hs
05:36:19 <benny> do you recommend using them?
05:36:36 <dcoutts> not sure really, I've no experience with them
05:36:53 <benny> i used them a while back in c#
05:37:13 <benny> but i don't remember if i liked them :)
05:37:18 <dcoutts> heh
05:37:44 <dcoutts> that example above is a complete skeliton for a main window, from here: http://www.cs.kent.ac.uk/projects/pivotal/downloads.html
05:40:10 <benny> hm... i get errors trying to compile pivotal
05:41:20 <joelr1> dcoutts: would you have any ideas?
05:42:56 <dcoutts> joelr1, about what?
05:43:04 <joelr1> the Show bit
05:43:44 <dcoutts> benny, me too. There were some changes in the Gtk2Hs api since the version they mainly used. I also had problems with some of the packages they were using.
05:44:03 <benny> ok
05:44:18 <dcoutts> benny, if you just get errors about 'x' 'y' etc then those are easy to fix
05:44:28 <benny> yeah
05:45:29 <Lemmih> joelr1: There is no easy solution. Either bite the bullet or redesign your program.
05:46:01 <dcoutts> joelr1, "is there a way to derive show so that custom printing is only used for the Foo constructor and the rest is printed normally?" answer is no.
05:46:02 <joelr1> Lemmih: gotcha
05:46:12 <joelr1> dcoutts: ok :-)
05:46:15 <shapr> psygurd: Hey, you can get help TMR publish more often by writing articles :-)
05:47:13 <psygurd> yeah, and someday i might
05:52:33 * shapr lags horribly
06:19:10 <joelr1> is there a way to resolve this in my favor?
06:19:10 <joelr1> ./Snippets.hs:53:5:
06:19:10 <joelr1>     Overlapping instances for Show [TableInfo]
06:19:10 <joelr1>       arising from the 'deriving' clause of a data type declaration at ./Snippets.hs:53:5
06:20:34 <Lemmih> -fallow-overlapping-instances?
06:21:08 <jyp> Or you can get by defining only Show for TableInfo ?
06:23:08 <dcoutts> jyp, oh, you might be interested to know we're working on the treeview api again over in gtk2hs-devel. We'd be interested to know if what we're thinking about would suit your use cases.
06:24:19 <dcoutts> jyp, I am remembering right? some time ago you were asking about how the gtk2hs treeview api could be improved?
06:24:25 <jyp> dcoutts, that cool, thanks for the info :)
06:25:25 <jyp> However the project that used that is kinda in the fridge for now...
06:25:27 <joelr1> ah! allow overlapping instances?
06:26:01 <joelr1> jyp: the issue is that about 500 of TableInfos are printed and they really clutter up my log
06:26:03 <dcoutts> jyp, np, we're not asking you to use it :-). We've just wondering what'd be a better api
06:26:30 <joelr1> so i want to reduce that down 
06:26:43 <joelr1> Lemmih: thank you!
06:27:52 <jyp> joelr1, then I guess you want overlapping instances... Though I'm not particularly fond of them in such a case :)
06:28:21 <joelr1> jyp: it's a hack but a harmless one in this case. i think.
06:29:35 <jyp> dcoutts, I would like to have a look at the new api anyhow. Converting my code to the new stuff shall not take such a long time, I assume...
06:29:50 <jyp> Is the new thing in cvs ?
06:30:08 <dcoutts> jyp, actually yes, but only the low level parts of it
06:30:20 <dcoutts> jyp, let me find the email...
06:33:22 <dcoutts> jyp, bah, SF.net seems to be down
06:33:52 <dcoutts> jyp, the idea is to make it easy to create custom stores
06:33:53 <dcoutts> makeListStore :: [Column a] -> [a] -> CustomStore
06:34:04 <dcoutts> data Column a = ColumnString (a -> String)
06:34:04 <dcoutts>               | ColumnInt    (a -> Int)
06:34:04 <dcoutts>               | ColumnBool   (a -> Bool)
06:34:06 <dcoutts> ... etc
06:35:56 <jyp> dcoutts, this is really cool
06:36:58 <dcoutts> jyp, that api works now for lists & trees (though that high-level part is not in cvs yet)
06:37:20 <dcoutts> but there's no functions for modifying the store after they've been created
06:37:24 <dcoutts> yet
06:37:56 <jyp> This looks promising... I'll give you comments as soon as I do the conversion mentioned above
06:38:37 <jyp> I don't think I need dynamic stores ... probably
06:38:39 <dcoutts> jyp, when SF.net is back up check the gtk2hs-devel archive. I sent an email explaing it all.
06:38:58 <jyp> alright.
06:40:33 <dcoutts> under the thread "new API for TreeModel" 08/12/05
06:40:52 <jyp> ok, added to TODO list :)
06:41:10 <dcoutts> with working code attached. hmm the SF.net archive doesn't show the attachments. :-(
06:43:14 <dcoutts> jyp, oh I was wrong it does have the attachements: http://sourceforge.net/mailarchive/message.php?msg_id=14123011
06:43:56 * jyp reads
06:44:53 <syntaxfree> any ideas for higher-order numerical differentiation?
06:45:50 <syntaxfree> the naïve algorithm has an explosive error, and my own stab at it using the Taylor series is unfeasibly slow.
06:46:31 <dcoutts> jyp, ah it looks like it cuts off the bottom of the TreeStore.hs attachment
06:46:49 <syntaxfree> oh, and while at haskell... any built-in functions equivalent to ntimes 1 f = f; ntimes n f = f . (ntimes (n-1) f)? 
06:47:05 <Cale> syntaxfree: Do you mean something degree-parametrisable?
06:47:14 <dcoutts> syntaxfree, something like: take n . iterate f
06:47:16 <Cale> syntaxfree: iterate f x !! n
06:47:35 <dcoutts> oh yeah, "!! n" not "take n"
06:47:42 <Cale> or just  (!! n) . iterate f
06:47:48 <Cale> yeah
06:48:18 <syntaxfree> that doesn't return a function.
06:48:54 <syntaxfree> cale: yes.
06:48:59 <Cale> ntimes n f = (!! n) . iterate f
06:49:05 <xerox> (foldl (.) id .) . repeat
06:49:12 <syntaxfree> I like xerox's.
06:49:20 <xerox> I like syntaxfree 
06:49:26 <syntaxfree> it's a pointless version of mine.
06:49:41 <syntaxfree> well,  one that abstracts the recursion away.
06:49:53 <xerox> ^_^
06:50:15 <xerox> I used it for tree traversal with zippers
06:50:29 <syntaxfree> anyway, any thoughts for higher-order numerical differentiation?
06:51:29 <jyp> d n f / dx n
06:51:46 <jyp> ?
06:51:52 <xerox> I got it wrong it seems
06:51:55 <Cale> syntaxfree: well, I don't know too much about that in general, but Simpson's 1/3 and 3/8 rules are easy to implement
06:52:01 <Cale> oh
06:52:07 <Cale> differentiation
06:52:23 <syntaxfree> so, given a suitable ntimes function as mine or xerox's.
06:52:25 <Cale> heh, for some reason I was thinking of integration
06:52:57 <sieni> syntaxfree: depends on the function, but you could use some of the standard spline approximations and then get the answer from that
06:53:11 <syntaxfree> for threepoint f h = \x-> (1/2*h) * (f (x+h) - f(x))
06:53:24 <syntaxfree> ntimes n threepoint f h has explosive error.
06:53:32 <syntaxfree> I hacked up a method with Taylor series.
06:53:53 <SamB> dons: the patch psi meant was http://paste.lisp.org/display/14450#1
06:53:57 <syntaxfree> but it's really really slow.
06:54:02 <SamB> I don't see how it could have possibly fixed hmp3
06:54:10 <Cale> Well, you could write a function differentiate :: (Double -> Double) -> (Double -> Double), but there's some fear of numerical problems as you iterate something like that
06:54:19 <Cale> and yeah, it'll be slow
06:54:24 * shapr hops
06:54:45 <syntaxfree> Iterating the naïve version is numerically awful.
06:54:52 <syntaxfree> I have a version that's more precise, but it's slow.
06:55:03 <syntaxfree> @hawiki DiegoNavarro
06:55:04 <lambdabot> http://www.haskell.org/hawiki/DiegoNavarro
06:55:36 <sieni> syntaxfree: get a copy of numerical recipes
06:56:01 <syntaxfree> I have a bunch of manuals in numerical maths. But they all cover methods from EDO's on.
06:56:31 <sieni> wtf is edo?
06:56:37 <syntaxfree> oops. ODE's.
06:56:44 <sieni> ahh ok :-)
06:56:52 <int-e> 'extended data out' iirc.
06:56:54 <int-e> ;)
06:57:33 <psi> SamB, i wonder what's weird about ubuntu's and debian's ghc, then
06:57:39 <sieni> numerical recipes for (c/c++/fortran/??) is a good place to find information about the basic stuff
06:58:28 <syntaxfree> the Linux community really needs to drop the whole package management hippie cult and come up with installer kits.
06:58:45 <syntaxfree> Installing GHC on Windows: click the .EXE, watch the fill bar get filled, bingo.
06:59:00 <syntaxfree> Installing GHC on OS X: click the .DMG, watch the fill bar get filled, bingo.
06:59:14 <sieni> syntaxfree: install on debian: apt-get update && apt-get install ghc
06:59:17 <syntaxfree> every single program I tried to manage with fink borked.
06:59:27 <shapr> fink is Linux?
06:59:40 <sieni> syntaxfree: well fink is much more broken than e.g. debian
06:59:42 <syntaxfree> sieni: well, when the packages aren't borked. Or when you don't just get conflicts.
06:59:50 <sieni> probably not enough developers
06:59:56 <syntaxfree> maybe fink packages are of worse quality.
06:59:57 <shapr> You could install debian on your Apple hardware.
06:59:59 <Igloo> ghc6, not ghc
07:00:34 <sieni> syntaxfree: I have certainly had more problems with fink than debian
07:00:35 <Cale> syntaxfree: on debian, type "apt-get install ghc6" and have thing downloaded and installed for you.
07:00:35 <syntaxfree> Fink as in the system is essentially apt-get with a thin layer of adaptations.
07:00:47 <Cale> You don't even have to browse the web for it
07:00:54 <syntaxfree> Cale: supposedly, on OS X, "fink install ghc6" will do it. I first installed GHC that way.
07:01:05 <benny> emerge :P
07:01:13 <xerox> There also is darwinports, right?
07:01:24 <syntaxfree> but after a while, it all gets b0rked. Some program I installed put there its own version of tar.
07:01:32 <syntaxfree> Its own version of tar was broken.
07:01:32 <xerox> Something like 'port install ghc' or whatever..
07:01:59 <kowey> it would be nice if darwinports had some "official" binary ports
07:02:01 <syntaxfree> the thing is, leaving binary management to the distros does not, pragmatically, work.
07:02:05 <kowey> especially ghc....
07:02:11 <syntaxfree> it's pretty interesting, technically. 
07:02:17 <syntaxfree> the whole emerge -uD world game.
07:02:27 <shapr> Why doesn't binary management work when managed by distros?
07:02:33 <Cale> dcoutts: on gentoo, do you have a binary package for the latest release of GHC?
07:02:34 <sieni> syntaxfree: I think debian works pretty well
07:02:37 <shapr> It works fine for me. 
07:02:48 <syntaxfree> I've used Linux from like 1997 to 2004.
07:02:56 <shapr> Me too
07:03:06 <sieni> syntaxfree: the problem with explicit installer packages is that you end up duplicating libraries and stuff
07:03:06 <shapr> I was much happier when I switched to Debian.
07:03:12 <dcoutts> Cale, not yet. It's still possible to bootstrap with an older binary package however
07:03:12 <syntaxfree> I found it really annoying that most open source apps were easier to install on Windows because they just used InstallShield or whatever free clone there is.
07:03:34 <shapr> I disagree with your conclusion, apt-get is easier than installshield.
07:03:45 <syntaxfree> then I started needing microsoft word for work, and in the same month they came up with the mac mini.
07:03:52 <xerox> Just because 'easier' it's subjective :-)
07:04:07 <syntaxfree> when it works, apt-get is easier than installshield, probably.
07:04:11 <syntaxfree> sp. with something like synaptic.
07:04:12 <sieni> syntaxfree: unless you want to do something like a generic package management system on Linux :-)
07:04:15 <Cale> I'd rather leave binary management to the distributions.
07:04:20 <syntaxfree> I'm talking about a sociological problem.
07:04:28 <shapr> What's the sociological problem?
07:04:32 <syntaxfree> Package repositories are pragmatically borked.
07:04:37 <shapr> How so?
07:04:48 <Saulzar> Hmm, the other thing perhaps is that most windows apps have no library dependancies - they either statically link everything or you're expected to have it already
07:04:48 <syntaxfree> as in, "apt-get install xxx" will fail 3 out of 10 times.
07:04:55 <shapr> But it always works for me.
07:05:03 <shapr> It fails zero out of ten times for me.
07:05:13 <sieni> syntaxfree: apt-get in fink or apt-get in debian?
07:05:20 <xerox> For some values of 'working' :-)
07:05:21 <syntaxfree> apt-get in debian derivatives.
07:05:31 <Cale> dcoutts: let me know -- my friend uses gentoo, and I'd like her to be able to install it without quite that much compiling. She can ssh into my machine and use it that way, but at some point she may want to use gtk2hs :)
07:05:31 <shapr> I've heard that apt-get works in Ubuntu also.
07:05:36 <syntaxfree> My distro of choice was Quantian, a live-cd-with-installer that came packed with scientific tools.
07:05:39 <xerox> It indeed does.
07:05:42 <syntaxfree> a Knoppix variant.
07:05:48 <syntaxfree> I did use official Debian for a while, though.
07:05:52 <xerox> I have to fight it for skype, though.
07:05:55 <syntaxfree> Saulzar: maybe. But smart explicit installers get around it.
07:05:56 <psi> i use ubuntu. it's mostly really great :)
07:05:58 <shapr> How does apt-get install fail for you?
07:06:24 <Saulzar> syntaxfree, Yes - 35 meg download :)
07:06:27 <syntaxfree> A smart explicit installer can check versions of libraries et al.
07:06:29 <benny> @seen dons
07:06:29 <lambdabot> dons is in #haskell. Last spoke 13 hours, 5 minutes and 41 seconds ago.
07:06:36 <xerox> skype uses qt with a specific version number which ubuntu breezy has not :-\
07:06:44 <shapr> xerox: I have the same problem.
07:06:45 <dcoutts> Cale, the binary versions are mainly for bootstrapping anyway, so it doesn't really matter so much which version is used. Using all the other libs with a binary package of ghc is only vaugly supported.
07:06:51 <syntaxfree> well, if I did care about download sizes that much, I'd be using Sorcerer or something.
07:07:02 <shapr> How is a smart installer different from apt-get?
07:07:22 <syntaxfree> shapr: the packaging is left up to the program authors, not to the distribution.
07:07:26 <dcoutts> Cale, supported in the sense that it happens to work but we don't particularly guarantee it.
07:07:31 <xerox> shapr: Even if I could find how to tell the apt system "ho harm, just do it", it makes impossible to do things after have forced its installation - damnit.
07:07:45 <shapr> syntaxfree: Redhat unofficial rpms work that way, and it's a nightmare.
07:07:53 <Cale> dcoutts: Isn't it kind of annoying, or are gentoo users used to that amount of compiling things anyway?
07:07:59 <xerox> apt tells you 'run apt-get -f install' which will remove skype, and everything works again.
07:08:01 <syntaxfree> Try to understand, I'm not pointing a technical fault in package management systems in general, but a pragmatic problem of the state of package repositories.
07:08:17 <syntaxfree> Unofficial RPMs are not smart installers, they just bundle some dependencies.
07:08:24 <xerox> syntaxfree: isn't _that_ the type of checks that apt do?
07:08:30 <dcoutts> Cale, there are very few -bin packages in Gentoo. Gentoo is a source based distro afterall.
07:08:34 <sieni> cale: http://funroll-loops.org/
07:08:50 <shapr> I don't think that getting the program authors to deal with dependencies themselves has any advantages.
07:09:00 <syntaxfree> I use Gretl, a handy tool for quick-n-dirty econometric modelling.
07:09:16 <syntaxfree> the Windows installer always has the latest version and it's a breeze.
07:09:20 <sieni> Well The Debian Way is occasionally annoying
07:09:37 <sieni> e.g. grep has been compiled wrong for an eternity
07:09:46 <Cale> sieni: it has?
07:09:46 <sieni> (the explicitly disable the -P option)
07:09:48 <syntaxfree> in Linux, I have either to compile from source, or wait until the repository admins eventually notice the tiny majority of econometrists using their particular distribution.
07:09:58 <shapr> xerox: Can you pull apart the deb and fix it?
07:10:21 <xerox> shapr: that's an idea...
07:10:26 <syntaxfree> (on the Mac I have to get X to work in first place, but Apple provides a .dmg installer on the OS X cd so I don't have to dick around with package management systems)
07:10:27 <sieni> Cale: fortunately there's pcregrep, so I can alias pcregrep to grep
07:10:35 <shapr> syntaxfree: If one person who compiles from source maintains a package, no one else has to do that.
07:11:11 <syntaxfree> shapr: ah, yes. The "given enough eyes, all bugs are shallow" approach.
07:11:14 <Cale> sieni: -P is perl-compatibility?
07:11:21 <Cale> I've never used that option
07:11:22 <shapr> I've seen minimal packages be improved by the community into really smooth packages, after which they often get accepted into the official distro.
07:11:36 <syntaxfree> Yes, given an ideal community of developers, a package management system can be functional.
07:11:58 <syntaxfree> Econometrists aren't usually developers.
07:11:59 <shapr> It also works with a less than ideal community, like we have now.
07:12:31 <syntaxfree> Maybe they'll be able to ./configure && make && make install.
07:13:04 <sieni> Cale: yes
07:13:14 <shapr> Unicyclist aren't usually developers either, so I and some other people do geeky stuff in the community.
07:13:17 <syntaxfree> pragmatically,  I can't get the latest Gretl installed on Linux without a lot of dicking around.
07:13:21 <Cale> syntaxfree: the idea is that the distribution takes care of compiling things and producing nice packages
07:13:54 <shapr> hiya nerdlor, long time no see.
07:13:54 <sieni> Cale: I don't want to learn multiple regular expression syntaxes and perl regexen are The Only True Way anyway (although I don't like perl that much otherwise)
07:13:56 <syntaxfree> Cale: yes. I'm not pointing out any technical flaws in the concept of a package, but that leaving packaging to the distribution is a bad model.
07:13:57 <Cale> syntaxfree: apt-get install gretl ?
07:14:01 <Cale> it's got a debian package
07:14:07 <syntaxfree> yeah, but it's an old version.
07:14:18 <syntaxfree> It doesn't include the time-series models that have been built into the latest version.
07:14:26 <syntaxfree> the version that comes with Debian is a toy.
07:14:35 <shapr> You can probably fix that.
07:14:44 <syntaxfree> except I won't. 
07:14:46 <shapr> Here's an opportunity for you to refine the existing package, see?
07:14:48 <shapr> Ah, ok then.
07:14:51 <syntaxfree> Nor has any econometrist so far.
07:15:06 <Cale> 1.4.1 is old?
07:15:07 <syntaxfree> and Gretl is the most popular open-source program in its category.
07:15:12 <xerox> shapr: I'm trying!
07:15:16 <shapr> xerox: w00!
07:15:21 <xerox> shapr: it worked!
07:15:23 <shapr> @karma+ xerox 
07:15:24 <lambdabot> xerox's karma raised to 10.
07:15:28 <shapr> awesome!
07:15:34 <xerox> Danke :-D
07:15:35 <Cale> syntaxfree: where do you get the version that's newer than 1.4.1?
07:15:37 <xerox> Let me put it online.
07:15:45 <syntaxfree> I've dropped Linux about a year ago.
07:16:22 <shapr> How's your Haskell going?
07:16:29 <Cale> syntaxfree: ?
07:17:00 <syntaxfree> cale: I'm not sure of version numbers. Maybe apt-get has catched up since then.
07:17:07 <syntaxfree> check the official site. 
07:17:19 <Cale> It looks like the version matches the latest
07:17:31 <Cale> in fact, there have been 3 debian revisions
07:17:31 <syntaxfree> maybe because of my insistent bitching back then ;-)
07:17:48 <Cale> Which debian did you run?
07:17:57 <syntaxfree> For the longest while, I couldn't do what my Windows colleagues did. Pretty annoying.
07:18:09 <Cale> stable only updates very rarely
07:18:14 <Cale> you should run unstable
07:18:21 <Cale> or at least testing
07:18:26 <syntaxfree> I had unstable and testing enabled on /etc/apt.conf or whatever.
07:18:29 <shapr> I can't do what windows does either... My Linux never crashes :-(
07:18:52 <syntaxfree> jesus, just to think I had to dick around with /etc/apt.conf.
07:19:10 <syntaxfree> mr. Mingus, my silent, nonheating mac mini doesn't crash either.
07:19:15 <shapr> I couldn't even get Linux to crash when disconnecting and reconnecting IDE drives while it was running.
07:19:30 <shapr> The things I have to go through to get Linux to crash.
07:19:31 * shapr sighs
07:19:35 <syntaxfree> It's just not worth the pain. I like to do geeky things, but I prefer to learn programming instead of messing around with config files.
07:19:37 * xerox yummys some 86% cocoa chocolate
07:19:42 <xerox> shapr: want some?
07:19:45 <syntaxfree> anyway, I'm gonna get some lunch.
07:19:55 <Cale> you don't have to mess with that in order to set it on unstable, iirc.
07:19:59 <benny> is there a 3-way bool?
07:20:01 <shapr> yes!
07:20:05 <shapr> syntaxfree: Good idea! Wanna do some Haskell?
07:20:10 <shapr> benny: Maybe Bool
07:20:18 <benny> shapr: anything else?
07:20:20 * xerox hands a piece of it, while uploading skype-haxxored
07:20:34 <shapr> benny: What do you want?
07:20:40 <Cale> benny: data MyType = A | B | C
07:20:41 <Saulzar> data Foo | Bar | Wibble
07:20:42 <benny> ok i guess i'll use that
07:20:57 <benny> "Wibble"? :D
07:21:04 <int-e> Maybe (Maybe ())
07:21:04 <xerox> data QBool = True | False | Entanglement
07:21:26 <benny> can you do that like inside another data line?
07:22:16 <Cale> benny: what's wrong with Maybe Bool?
07:22:24 <Cale> exactly what are you representing?
07:22:32 <benny> nothing i guess. i'll use it
07:22:37 <Cale> Perhaps a proper custom data type is appropriate?
07:22:45 <xerox> To whoever cares: <http://haskell.galois.com/~paolo/skype_1.2.0.18-1_i386.deb>
07:22:45 * musasabi thinks hawiki should have a paper section
07:23:15 <shapr> musasabi: Make a category?
07:24:22 <musasabi> shapr: have to do something like that :-)
07:27:30 <shapr> psygurd: I'm the editor of The Monad.Reader, so I know you could get an article in...
07:32:00 <psygurd> shapr: yes, i just need some subject that i know something about and some time on hand
07:32:34 <shapr> Have you written any Haskell code? If so, you could write a description of the lib/app/etc and the process of writing it.
07:33:18 <shapr> People learning Haskell mots often want to learn the differences in the thought process between writing imperative and functional code.
07:33:51 <psygurd> not too much yet, but i have read lots of stuff and intend to get started sometime soon
07:34:32 <shapr> Ok cool. If you have any questions, feel free to ask.
07:34:38 <psygurd> i will
07:39:13 <Saulzar> When searching for haskell related topics, it's amazing how many times logs from this channel turn up.
07:39:55 <shapr> What were you looking for? What did you find?
07:44:27 <Saulzar> I was trying to compile gtk2hs, and a number of errors were to be found in logs from this channel. Also when searching for things related to yampa I kept finding your conversations :)
07:44:44 <shapr> #haskell or me specifically?
07:44:58 <Saulzar> You specifically (in #haskell)
07:45:33 <shapr> Any questions about Yampa?
07:47:00 <basti_> :D
07:47:38 <Saulzar> It's very interesting .. I'm very slowly getting my head around it, have you used it for any project? (It's just that one log you were enthusiastic about games in Yampa)
07:48:28 <Buggaboo> tried wxhaskell?
07:48:34 <shapr> Arrows, Yampa, and functional reactive programming have the potential to be the next big paradigm the size of OOP. I don't know if it'll happen though.
07:49:04 <benny> it's gotten happen eventually :)
07:49:33 <basti_> i never could get yampa running
07:49:42 <basti_> that is, anything meaningful written in it
07:49:44 <shapr> No, I haven't used it for a project yet. I'd like to, but I get paid to do web dev, and it doesn't really match Yampa.
07:49:53 <Saulzar> I am working on (the very beginnings of) a little AI game similar to robocode, but with robots in haskell/yampa
07:50:08 <shapr> Have you based it on the robot soccer demo?
07:50:35 <Saulzar> No... I haven't looked at that closely
07:51:15 <basti_> Saulzar: thats a very good idea.
07:51:56 <Saulzar> About wednesday I thought that scrapping yampa would be best, but I have come around.
08:00:34 <shapr> Arrows are great, except that you can't use them with boring Haskell functions and keep their nifty properties.
08:01:25 <shapr> Yampa takes advantage of the good points of arrows, so it's really great for reactive/dataflow processes, but doesn't work well with Haskell functions.
08:01:52 <Heffalump> Arrows are nowhere near as generally useful as OOP
08:02:03 <Cale> shapr: do you find that this is moreso than with monads?
08:02:12 <shapr> A robocode game should work nicely.
08:02:14 <basti_> OOP is useful for anything? ^^
08:02:25 <shapr> Heffalump: Why do you think that?
08:02:56 <Lemmih> Comparing arrows and OOP is kinda weird.
08:03:13 <Cale> I agree, that is a bizarre comparison
08:03:21 <shapr> Cale: this what?
08:03:55 <Saulzar> Maybe OOP Event based Guis vs FRP Guis
08:04:32 <Heffalump> Because arrows are hard to understand, and of limited applicability - useful for structuring a few kinds of things that people want to do in a programming paradigm that is already only of niche interest.
08:04:33 <Cale> oops
08:04:35 <Cale> sorry, what was that?
08:04:40 <xerox> > compare "OOP" (>>>)
08:04:40 <lambdabot>   Expecting a function type, but found `a'
08:04:40 <lambdabot>   Expected type: [Char]
08:04:40 <lambdabot>   Inferred type: a b c -> a c d -> a b d
08:04:48 <Heffalump> :-)
08:04:57 <shapr> Heffalump: How do you support that opinion?
08:05:06 <Saulzar> OOP gui frameworks are hard for Java beginners
08:05:11 * shapr is lagging
08:05:20 <basti_> Heffalump: arrows are an abstraction that apparently include many "paradigms"
08:05:45 <Cale> I dunno, Arrows seem like an ideal way to structure a combinator library which allows the library developer to hide some pretty impressive things from the user.
08:05:49 <Heffalump> OOP gui frameworks are hard to understand because the frameworks are complicated, not because OOP itself is. Although some aspects of OOP (e.g. virtual base classes) certainly are.
08:05:57 <shapr> Heffalump: Do you think that arrows are limited to functional programming?
08:05:59 <Cale> like, various runtime optimisations
08:06:19 <Heffalump> shapr: yes. They don't make any sense without having purity underlying them.
08:06:31 <shapr> Do you think that's true of monads also?
08:06:58 <Cale> I kind of think that functional programming at least has to be convenient to support something like arr
08:07:02 <Heffalump> Yes. And don't bother trotting out your list of monad implementations in imperative languages unless you can actually show substantial *use* of those implementations.
08:07:32 <Cale> (or is it 'pure')
08:07:52 <Cale> @type Control.Arrow.arr
08:07:53 <lambdabot> forall (a :: * -> * -> *) c b.
08:07:53 <lambdabot> (Control.Arrow.Arrow a) =>
08:07:53 <lambdabot> (b -> c) -> a b c
08:08:01 <Cale> yeah, that one :)
08:08:04 <Heffalump> cale: agreed re the structuring and runtime optimisations, but it's still too complicated
08:08:23 <Heffalump> and people won't care enough about the benefits
08:08:31 <basti_> Heffalump: ; in C is just like >>=.
08:08:49 <Heffalump> no it's not, you can't replace ; with another implementation
08:08:49 <shapr> Heffalump: It is my opinion that arrows are no harder to understand than OOP, and that both arrows and monads are useful in imperative languages.
08:08:50 <Cale> Heffalump: It doesn't look much worse than monads to me
08:08:52 <Saulzar> People say the same thing about functional programming and Haskell in general (hard to understand and not useful in general), though
08:09:21 <Heffalump> saulzar: right, and arrows are yet another step removed from that.
08:09:35 <shapr> Yes, I think the usefulness and difficulty points are hard to quantify, and so hard to discuss.
08:10:05 <shapr> For example, you requested a significant use. Do the various monadic parser combinator libraries in Java count there?
08:10:08 <basti_> Heffalump: the point is that "monad" is an abstraction of the thing that makes C C.
08:10:43 <shapr> Obviously, different people will have different ideas of useful, difficult, significant, etc.
08:10:44 <Saulzar> I wonder if people leanred Haskell instead of C when they were 15 they would think the other way around
08:10:55 <Saulzar> er, learned
08:11:03 <shapr> Saulzar: Oh, I heard about someone who learned Haskell first learning C...
08:11:07 <Cale> I mean, you probably wouldn't want to use an arrow when a monad would suffice, but on the other hand, there's some very good evidence that arrows are quite effective in a number of areas.
08:11:07 <Heffalump> shapr: like where?
08:11:29 <shapr> They were totally lost until someone said "Every C function has an implicit IO signature."
08:11:40 <Saulzar> Haha.
08:11:53 <Heffalump> cale: but none of the benefits are important enough for people to care that much
08:12:03 <Cale> Heffalump: I don't know about that
08:12:06 <Heffalump> Saulzar: well, they don't
08:12:21 <shapr> But see, then you have to define the benefits, and 'important enough' too.
08:12:26 <basti_> Cale: my main point for arrows is that they include comonads, which makes streams acessible
08:12:43 <Saulzar> I'm not convinced it's so hard, people spend a _long_ time studying OO before they're even slightly effective
08:13:04 <basti_> (dataflow programming is completely disregarded in mainstream CS  without reason)
08:13:14 <Heffalump> shapr: or I could point to reality and the fact that noone outside the FP community gives a shit about arrows.
08:13:18 <Cale> Well, more than that, they let you define application, so you get to optimise and do impossible-seeming things.
08:13:40 <Cale> Heffalump: the fact that nobody cares about them right now doesn't mean anything :)
08:13:42 <shapr> Heffalump: That's just your perception.
08:14:02 <Cale> Good abstractions are good abstractions.
08:14:07 <Saulzar> Heffalump, Nobody outside the FP community cares about FP either I suspect...
08:14:13 <Heffalump> Saulzar: right :-)
08:14:28 <Heffalump> except that's not actually true
08:14:36 <Cale> Also, who cares if anyone out there cares about them, if we can write good software using them? :)
08:14:37 <Heffalump> Haskell is gaining traction out there, mainly cos of pugs and darcs.
08:14:57 <Heffalump> cale: I don't particularly. I was just challenging shapr's assertion that Arrows have the potential to become as big as OOP.
08:15:10 <Heffalump> Which, quite frankly, is typical shapr bullshit </Smerdyakov>
08:15:12 <Cale> Oh, I think that's probably possible too.
08:15:32 <Cale> Why not?
08:15:35 <shapr> Well, thank you for expressing your opinion. Would you like to try supporting it now? :-)
08:15:51 <Cale> OOP is way more complicated than arrows.
08:15:54 <basti_> i think haskell is gaining attention because people see how well-designed it is
08:16:08 <Cale> Give me a 1-page description of the axioms of OOP.
08:16:08 <basti_> I agree completely, Cale.
08:16:16 <Heffalump> The bit about you talking bullshit a lot, or the bit about arrows?
08:16:27 <Heffalump> see, in the real world, noone needs to know about the axioms.
08:16:30 <shapr> Feel free to support either or both of those.
08:16:52 <Cale> Heffalump: well, it would be a good estimate of how hard it is to understand
08:17:00 <Heffalump> in fact, can you give a 1-page description of the axioms of arrows? Note that if they are axioms they must be non-redundant...
08:17:09 <Cale> If you can't even *describe* it in a page
08:17:22 <Cale> no, axioms can be redundant
08:17:33 <Heffalump> really?
08:17:40 <Cale> really.
08:17:47 <Heffalump> Sadly, most people's intuition doesn't line up with theoretical foundations.
08:17:52 <Heffalump> ok, never mind then :-)
08:18:12 <Cale> Try showing whether or not ZF has a redundant axiom. :)
08:18:12 <shapr> Heffalump: Seriously, give me some numbers or unit tests that support your claims.
08:18:14 <Heffalump> surely an axiom that you can prove isn't an axiom, by definition?
08:18:24 <Heffalump> hmm, ok :-)
08:18:33 <Cale> Heffalump: axioms are exactly those statements which you are accepting as true
08:18:56 <Cale> usually you'll delete something from your list of axioms if it's a theorem from the others, but that's not necessary
08:19:09 <Heffalump> fair enough
08:19:10 <Saulzar> Certainly none of these things will gain any traction unless _somone_ is especially keen about it, and shows it :)
08:20:13 <Heffalump> I think people like Autrijus are doing a good job there.
08:20:21 <shapr> Definitely.
08:20:22 <Cale> As a matter of fact, I haven't really even seen a really good definition of what OOP is at all, apart from a nebulous bunch of language features which may or may not be present :)
08:20:52 <basti_> OOP is "we say the words 'class', 'instantiate' and 'overload' a lot"
08:20:59 <Cale> basti_: hehe
08:21:00 <Heffalump> no, it does mean more than that.
08:21:24 <basti_> and maybe, "we agree on a certain first parameter for every function"
08:21:30 <Cale> hehe
08:21:35 <Heffalump> which is actually a pretty clever idea
08:21:51 <benny> until you want things like multiple dispatch :(
08:22:01 <Heffalump> and while it's nowhere near as powerful as some of the abstractions FP offers, it still gets people quite a long way
08:22:41 <Heffalump> it's also easy to adopt piecemeal if you're coming from C
08:22:41 <basti_> the question is, is that inherent because its a valuabe and powerful construct, or is it because it makes people write cleaner programs?
08:22:42 <shapr> Anyway, in abscence of evidence to the contrary, let me repeat that arrows have the potential to be as popular as paradigm as OOP.
08:23:16 <Cale> Remember that OOP itself took a really long time to catch on
08:23:22 <Heffalump> And in the absence of evidence to the contrary, let me repeat that they are nowhere near as useful as OOP has shown itself to be, and that shapr is spouting rubbish again :-)
08:23:40 <Heffalump> true
08:23:44 <basti_> i can only say that my intuition about processing data was closer to arrows than it was to oop from the very beginning.
08:23:57 <Heffalump> if FP ever does catch on big time, I'll revise my opinion.
08:24:01 <shapr> heh
08:24:16 <shapr> So, why are you here on #haskell then?
08:24:26 <Cale> Heffalump: why do you think they fail to be useful? I think that the construction of EDSLs using Hughes Arrows, Monads and Comonads is a very worthwhile approach to library design.
08:24:37 <Heffalump> useful = 'useful to the majority of the world'
08:24:47 <Cale> Heffalump: sure
08:25:14 <Heffalump> I think it's a worthwhile approach to certain hard problems.
08:25:23 <Cale> Well, the majority of the computer programming world anyway.
08:25:30 <Cale> A library like parsec is quite useful.
08:25:30 <Heffalump> But most of the world is about easy, but big, problems.
08:25:45 <shapr> How do you know most of the world?
08:25:50 <shapr> I think you're overgeneralizing a bit...
08:26:21 <Heffalump> Random sampling.
08:26:32 <Heffalump> (OK, not very random, admittedly :-)
08:26:38 <shapr> How many standard deviations? 
08:26:59 <Heffalump> But I do spend most of my working life interacting with some parts of it.
08:27:04 <Cale> But I actually halfheartedly hold the opinion that Haskell should avoid becoming too popular.
08:27:19 <Heffalump> cale: a library like parsec is quite useful, but most people will find yacc good enough.
08:27:47 <Heffalump> so there's not enough "pull" for everyone to switch to a language in which implementing parsec is feasible
08:27:49 <shapr> So, yacc is your demonstrative example that fp/monads/arrows aren't useful to most of the world?
08:28:05 <Cale> Heffalump: parsec is just one library
08:28:26 <Heffalump> shapr: no, of course not. It's my rebuttal of "parsec is quite useful"
08:28:59 <Cale> Heffalump: but it's not really parsec itself that I'm pointing at
08:29:02 <Saulzar> Others such as myself having never used yacc would rather jump off a cliff, but parsec seems pretty easy
08:29:09 <Cale> but what parsec is -- its design
08:29:17 <Heffalump> cale: sure.
08:29:39 <Heffalump> My general point is that there are usually "good enough" solutions around.
08:29:43 <shapr> Ok, so your argument is that fp/monads/arrows are too hard to learn and the benefits aren't important enough.
08:29:50 <Cale> the ability to design libraries like parsec is something which is very hard without the basic abstractions that it's built on.
08:29:50 <Oejet> shapr, Heffalump: Care to take your very interesting discussion to #haskell-overflow, please?
08:30:04 <Heffalump> arrows in particular. The same applies to fp, but at a much weaker level.
08:30:07 <Heffalump> Oejet: why?
08:30:09 <tic|school> shapr, what is the point of arrows anyway? I've read through the first parts of Hughes' paper.
08:30:22 <basti_> yes that would be good.
08:30:28 <basti_> its a meta-discussion
08:30:33 * Oejet thinks the discussion overflowed.
08:30:41 <basti_> and not of interest to the average average haskell programmer
08:30:52 <Cale> hm?
08:30:53 <Cale> it's not?
08:30:53 <Heffalump> what did it overflow?
08:31:03 <Cale> there's no other discussion going on here
08:31:07 <Heffalump> indeed.
08:31:15 <shapr> Heffalump: Yeah, if you'd like to come up with some real numbers, I'm interested. Otherwise, I think it's just your unsupported opinion.
08:31:15 <basti_> well thats true
08:31:26 <basti_> but i think, advocacy is generally overflow
08:31:34 <basti_> (in any direction)
08:31:39 <shapr> tic|school: Have you seen the unfinished ArrowsIntroduction on TmrWiki?
08:31:43 <Heffalump> shapr: feel free.
08:31:58 <basti_> theres no point in discussing "c or not, and if, why" on #c either
08:32:17 <Saulzar> tic|school, As far as I can tell the major benefit is that arrows abstract the input as well as the output. 
08:32:19 <Cale> basti_: I think it's interesting enough :)
08:32:38 <Cale> basti_: It's not really about "Haskell or not", but "Arrows or not"
08:32:44 <basti_> i dont think its boring, it just might scare any noobs.
08:32:48 <basti_> ^^
08:32:58 <basti_> let's say its a margin case.
08:33:07 <Heffalump> I think an awful lot of the highly technical conversations on here could potentially scare noobs.
08:33:09 <shapr> tic|school: In short, arrows give you a limited ability to get around the halting problem.
08:33:15 <Heffalump> AAARGH!
08:33:26 <Heffalump> that's the worst summary I've ever heard of arrows in my life.
08:33:51 <shapr> Are you being offensive on purpose?
08:33:58 <Cale> shapr: how so?
08:34:07 <Heffalump> Are you being idiotic on purpose?
08:34:11 --- mode: ChanServ set +o shapr
08:34:12 <Cale> (I wouldn't say that they do that at all)
08:34:16 --- kick: Heffalump was kicked by shapr (Kicked by shapr)
08:34:27 <Heffalump> oi!
08:34:38 <shapr> Believe it or not, I am sincerely trying to be nice to you.
08:35:11 <Heffalump> I don't care if you're nice to me or not, I just care about you spouting obfuscated nonsense.
08:35:41 <shapr> The correct approach on this channel is to have a conversation where we refine our understanding.
08:35:51 <Heffalump> I've done that many times with you.
08:35:57 <shapr> It's perfectly acceptable to spout nonsense in pursuit of better understanding.
08:36:00 <Heffalump> Though I'd have to dig in logs to find all the examples, and I can't be bothered.
08:36:12 <shapr> Lots of newbies show up trying to get their value out of IO again.
08:36:13 <Heffalump> Spouting nonsense at people who want information, however..
08:36:14 <Cale> okay, well, shapr, could you explain what you meant by that comment? It's obviously a rough analogy, and I might see what you're getting at, but I'm not sure
08:36:22 <shapr> That's nonsense that's on the right track to learning.
08:36:39 <shapr> Name calling is not acceptable on this channel.
08:36:44 <Heffalump> sez you.
08:36:49 <shapr> Yes, sez me.
08:37:02 <Cale> I agree, name calling serves no purpose
08:37:11 <shapr> I have invited you and Smerdyakov to start another #haskell elsewhere and run it however you see fit.
08:37:25 <Heffalump> I don't intend to make a habit of it, but in this specific instance you are being an idiot, which is part of a common pattern.
08:37:31 <shapr> But while I'm the maintainer of this channel, I will do my best to promote community and discussion.
08:37:45 <Heffalump> How do I stop you being the maintainer?
08:37:54 <shapr> Start your own channel, and make it more popular.
08:38:03 <Heffalump> I can't start #haskell on OPN a second time.
08:38:07 <shapr> I started #haskell. What are you waiting for?
08:38:17 <Heffalump> And that is the standard place people will look for such a channel.
08:38:17 <Igloo> Actually, on Freenode, #haskell's ownership should be decided by the community
08:38:24 <shapr> That's fine with me too.
08:38:38 <Heffalump> Yes, and I joined it and started helping out because I thought it was the right place to be.
08:38:53 <shapr> How does calling someone an idiot help?
08:39:20 <Heffalump> It probably doesn't, but then neither do your ridiculous explanations.
08:39:31 * shapr sighs
08:40:04 <shapr> Heffalump: You don't know that, do you?
08:40:10 <Cale> Heffalump: why, rather than calling him an idiot (he isn't), not ask him what he actually means?
08:40:25 <Heffalump> cale: I have done that, many times in the past. I'm just a bit fed up of wasting time on it.
08:40:32 <shapr> Then stop wasting your time on it.
08:40:39 <shapr> Write a better ArrowsIntroduction, I won't mind.
08:40:52 <shapr> Put your frustration into teaching people, rather than insulting me.
08:40:59 <Cale> If you don't have something constructive to say, don't bother to say it.
08:41:19 <Heffalump> well, shapr apparently doesn't have anything constructive to say about arrows either.
08:41:26 * shapr sighs
08:41:43 <Heffalump> if the best one-line summary he can up with for a newbie is the above.
08:41:54 <benny> how do i debug an "openFile: resource busy (file is locked)" error?
08:41:55 <shapr> So, write a better explanation or don't, but leave me alone.
08:42:00 <Heffalump> benny: strace?
08:42:11 <Cale> benny: lsof?
08:42:31 <Heffalump> (that's my usual trick for handling errors probably caused by the OS I don't understand)
08:42:41 <shapr> Heffalump: If you do this again, I will temporarily ban you.
08:43:15 <Heffalump> I would like you to get general agreement from the channel before you do that.
08:43:31 <shapr> Heffalump: If you do this again, I will ban you for a month.
08:43:51 <Heffalump> I would complain to Freenode admin if you didn't, but I don't trust them not to cause even more trouble for #haskell, so I won't.
08:44:19 <shapr> #haskell is here for teaching and learning. You are not helping that in any way.
08:44:28 <Saulzar> I certainly appreciate the explanations, one thing I have noticed around here was the amazing enthusiasim for people to help others. 
08:44:46 <Heffalump> I think I do help with teaching and learning quite a lot.
08:45:09 <shapr> If you're going to complain to the freenode admins, I think you should do it now.
08:45:17 <benny> Cale: thanks
08:45:24 <Heffalump> I already said I'm not going to.
08:45:30 * shapr shrugs
08:45:42 <Heffalump> It would (potentially) be like launching a nuke to get my lunch money back.
08:45:47 <mjl69> at the risk of looking stupid, I find the concept of monads to be a little confusing.
08:45:56 <Cale> benny: lsof -i is a good trick too, if you want to know what programs are accessing the network :)
08:45:59 <Heffalump> mjl69: I think many people do :-)
08:46:16 <Cale> Well, any abstraction is a little confusing at first.
08:46:16 <mjl69> but then again, OOP was difficult at first too, so I am confident that I will some day get it.
08:46:39 <benny> Cale: nice :) anyway, i've discovered that hs-plugins apparently isn't closing my plugin source file after it compiles it... where is dons when you need him :=
08:46:41 <Heffalump> Personally, I understood OOP a lot faster than I understood monads.
08:46:56 <Cale> Heffalump: I think it was the reverse for me
08:46:58 <Heffalump> (Even though I found Haskell probably easier to learn than C)
08:46:59 <Saulzar> I used OOP for years before I really understood it
08:47:32 <jlouis> hi hi. In for a small time
08:47:36 <Cale> I must have spent 3 or 4 years at least on understanding OOP.
08:47:39 <shapr> hiya jlouis, how's code?
08:48:02 <Cale> Whereas with monads, that's probable more like 3 or 4 months.
08:48:05 <Cale> y*
08:48:06 <mjl69> is it a function, a type, or something else that has something to do with one or both?  I need to read and sleep on it for a while.  It looks like it can be used without being understood for simple IO needs maybe.
08:48:11 <Heffalump> I guess it all depends on what "really understanding" means. OOP is quite a woolly concept.
08:48:22 <Heffalump> mjl69: it's a framwework, really.
08:48:24 <Cale> mjl69: right
08:48:34 <jlouis> shapr: cool, though I am not having that much time for Conjure
08:48:38 <shapr> Me neither.
08:48:40 <Cale> mjl69: You might have a look at my MonadsAsContainers analogy on the wiki
08:48:48 <benny> Cale: url?
08:48:49 <Heffalump> I guess the easiest explanation is that the Monad type class does encapsulate everything you need to know
08:48:59 <Heffalump> (apart from monad syntax)
08:49:01 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
08:49:07 <mjl69> Cale: cool, thanks.
08:49:22 <int-e> wee. Context reduction stack overflow; size = 21
08:49:31 <Cale> I like to think of a monad as a particular kind of container.
08:49:51 <twb> An *object* is not a complicated structure.  What is complex is the various, sometimes conflicting, features commonly found in object systems.
08:49:58 <Cale> Which supports at least a particular small collection of operations
08:50:01 <mjl69> is a list considered a container in Haskell also? or do you mean a different kind of container?
08:50:12 <Cale> yes
08:50:17 <Cale> a list is the prime example
08:50:26 <Cale> the list monad is probably the best one to start with
08:50:28 <xerox> I never got around OOP, I thought I understood it, but I never faced 'interfaces' and the like.
08:50:35 <Cale> and IO probably the hardest to understand
08:50:45 <twb> In Haskell lists are homogeneous ordered sets.
08:50:49 <sethk> xerox, OOP is trivial
08:50:51 <xerox> Where, with Monads, and a bit of Arrows, I was enlightnend very, very rapidly.
08:50:58 <Cale> twb: which may contain multiple elements
08:51:06 <xerox> sethk: it _seems_ so!
08:51:08 * benny summons dons
08:51:10 <mjl69> great, I get containers.  That gives me a starting point.
08:51:13 <Cale> er, repeated elements
08:51:24 <twb> Cale: isn't that property implied by "set"?
08:51:24 <jlouis> I do not find OOP trivial, but this is due to the fact that even experinced people do not agree on what OOP really is
08:51:28 <sethk> xerox, with interfaces, certainly, it is so.  There is nothing beneath the surface there
08:51:41 <twb> Cale: Hmm, what do you mean by "repeated"?
08:51:46 <Cale> twb: nope, sets usually don't remember how many times an element is included
08:51:58 <twb> Cale: Ah, OK.
08:52:24 <twb> It depends on whether you treat the 1's in [1,1] as different (which Haskell does not).
08:52:26 <jlouis> twb: sometimes people use the term ``bag'' for a set where the same element can occur more than once I think
08:52:34 <Cale> twb: I'd say it does :)
08:52:41 <Cale> well, sort of
08:52:53 <Cale> yeah, "ordered bag" is good :)
08:52:56 <twb> Oops, I had it backwards.
08:53:13 <Cale> like [1,1] isn't the same list as [1]
08:53:15 <twb> Haskell *does* treat them as the same object.
08:53:23 <Cale> whereas {1,1} is the same set as {1}
08:53:39 <xerox> Indeed.
08:53:44 <twb> hd [1,1] == hd $ tl [1,1] ===> True
08:53:52 <Cale> [1,2] and [2,1] are different lists, but <1,2> and <2,1> are the same bag.
08:54:01 <Cale> twb: well, yes
08:54:27 <Cale> they're the same value, but the structure records the fact that it's occurring more than once
08:54:28 <Cale> anyway
08:54:35 <Cale> all these are examples of containers
08:54:53 <Heffalump> shapr: I'm unhappy with you making unilateral decisions about what is acceptable on here and what isn't. I would like to suggest an alternative, that you pick a set of the obvious regulars and get at least a majority to agree before you do something like banning me (or anyone else).
08:55:11 <mjl69> This is not a trivial quick read.  I skimmed it, but I'll have to save it for later thorough read and re-read.
08:55:17 <Cale> mjl69: yeah
08:55:40 <Heffalump> I prefer to think of monads as a way of structuring computation.
08:55:45 <Cale> mjl69: monads are kind of a hard concept to get at first because they're a fairly general abstraction
08:55:54 <Heffalump> But I'm sure everyone has their own way of looking at them :-)
08:56:11 <Cale> they're also a way to structure computation, but I find that this is hard to grasp at first
08:56:29 <Heffalump> well, I think state and exceptions are the easiest examples of this
08:56:36 <Cale> sure
08:56:37 <Heffalump> and both of them fit well with that view of the world
08:56:48 <twb> Is a monad like a procedure?  i.e. an expression with side effects?
08:56:50 <mjl69> on first impression, when I hear container with associated functionality, I think either of a class or object.  Or I might think of a container of functions.  I am probably wrong on both accounts.
08:56:51 <Heffalump> and you can see how Maybe is a primitive exceptions monad
08:56:54 <jlouis> I think the Maybe monad is the simplest to grasp
08:57:03 <Heffalump> and then how Either goes one stage further
08:57:11 <Heffalump> and how IO can be viewed as State RealWorld
08:57:16 <Cale> twb: a monad is a function from types to types, together with a bunch of operations
08:57:35 <twb> Cale: why are they necessary, then?
08:57:37 <Cale> State and Exceptions are certainly not the easiest monads to understand
08:57:43 <twb> Because types aren't first class?
08:57:50 <Cale> monads are never necessary
08:58:11 <jlouis> twb: they separate imperative computations from pure computations, but they are never necessary as Cale says
08:58:11 <Cale> they're just a nice way to structure things
08:58:17 <twb> s/necessary/useful/, then.
08:58:22 <Cale> a nice way to unify a bunch of pictures of the world
08:59:08 <mjl69> on first read in the tutorial, it appears to be a complex abstract way to make a functional language perform useful real world tasks and still be consistently a functional languages with only pure functions.
08:59:19 <twb> haha
08:59:44 <Heffalump> mjl69: that's probably one fair summary :-)
08:59:45 <Cale> mjl69: well, that's an application
08:59:59 <Cale> Monads really aren't specific to programming at all
09:00:19 <Cale> they're a concept from mathematics, and they were first put to use in a branch called algebraic topology
09:00:32 <mjl69> but math is harder than programming, so when the two meet...
09:00:35 <Cale> :)
09:00:49 <Heffalump> aargh, who let the category theorist in? :-)
09:00:57 <Cale> actually, it's unsurprising that things from category theory are of use to programmers
09:01:14 <Cale> programmers value abstraction because they dislike writing the same code over and over again
09:01:23 <Cale> and category theory has lots of tools for abstraction
09:01:25 <twb> Cale: I've heard it said that category theory is just wank for static typists :-)
09:01:30 <basti_> somebody recently asked me "that haskell stuff, it's quite mathematical, isn't it?"
09:01:35 <mjl69> I took both Abstract Alebra and Topology last year of college and on the last day, we were given a brief overview of what algebraic topology is.
09:01:42 <basti_> i was like "well if you call CT mathematics"
09:01:50 <Cale> basti_: hehehe
09:01:54 <mjl69> s/Alebra/Algebra
09:02:24 <mjl69> that was a long time ago, so I don't remember too much...
09:03:17 <Cale> mjl69: well, essentially, the idea is to relate topological spaces to other, more algebraic structures
09:03:29 <Cale> like groups, rings, etc.
09:03:51 <Cale> in such a way that information about those spaces is preserved
09:04:01 <Ashsong> Excuse me - I have a question about using the unique identifiers from Data.Unique.  Would this be an appropriate time and place to ask it?  
09:04:05 <mjl69> right, if you can't prove something in one space, try moving it to the other, proving it there, and bringing it back.
09:04:07 <Cale> Ashsong: sure
09:04:16 <Cale> mjl69: yes
09:04:39 <mjl69> Cale thanks!
09:04:42 <mjl69> anyways, I have to leave Starbucks.  Thanks all for help, and thanks Cale for the link to the wiki.  I'll come back when I get it a little better.
09:05:19 <Cale> Ashsong: what was your question?
09:05:27 <Ashsong> (typing)
09:05:57 <jlouis> Cale: the funny thing is you throw away a _lot_ of information to build you algebraic view, but in fact the information thrown away is not that much
09:06:43 <Cale> jlouis: yeah :)
09:06:50 <Ashsong> I'm trying to model a board game called "Titan".  In Titan, players have stacks of units.  At any given time, however, we've only seen some of the units in a given stack.  There are four (important) operations on stacks: Adding a unit, Removing a unit, Revealing a unit, and Splitting a stack into two new stacks.
09:08:01 <basti_> jlouis: now how does that help us in programming ^^
09:08:44 <Ashsong> The point of the program is to model the constraints of the form "stack one contains at least one and at most one of a Titan or an Angel" (denoted {T, A}[1,1]) and to resolve these constraints as reveals, splits, adds, and drops take place.
09:09:19 <jlouis> basti_: I have not found any link besides that some topological spaces can model some denotational semantics sets
09:09:28 <Ashsong> To model the fact that there might be two Ogres in a single stack, for example, I clearly need to give the Creatures a unique identifier of some kind.
09:09:30 <basti_> Ashsong: did you think about logic programming?
09:09:41 <basti_> jlouis: :P
09:09:50 <Ashsong> basti_: Briefly, but I'm more interested in learning Haskell :)
09:09:53 <Cale> Ashsong: I wouldn't use Data.Unique for that
09:10:09 <basti_> Ashsong: lol.
09:10:10 <Ashsong> Anyway, the point is that newUnique has type IO Unique, for obvious reasons.
09:10:16 <jlouis> basti_: I am far from sure they are path-connected and thus applicable to an algebraic view on the topology
09:10:19 <Cale> Ashsong: right
09:10:51 <basti_> jlouis: heheh
09:11:22 <Ashsong> The question is basically, "do I write all of my functions which possibly involve Creatures in the IO monad" or can I write them as pure functions without worrying about where the Creatures are coming from?
09:11:24 <Cale> jlouis: or Hausdorff :)
09:11:31 <basti_> Ashsong: i don't see how unique would help you there. I think you have rather a problem of expressing constraints.
09:11:59 <jlouis> Cale: Or Hausdorff ;)
09:11:59 <basti_> Ashsong: but, it is certainly possible to do everything pure in IO.
09:12:14 <Cale> Ashsong: why not use lists? It's perfectly okay to have equal elements in a list occurring more than once
09:13:01 <Ashsong> Well, what's happening is that as moves happen (i.e. as splits, adds, removes, and reveals occur), a tree is being built up.
09:13:15 <jethr0>  @seen samb
09:13:19 <jethr0> @seen samb
09:13:19 <lambdabot> samb is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 2
09:13:19 <lambdabot> hours, 19 minutes and 16 seconds ago.
09:13:22 <Ashsong> The tree starts with the players initial two stacks of creatures.
09:13:39 <basti_> Ashsong: you're referring to a tree of potential moves?
09:13:43 <basti_> of which one will be picked?
09:13:50 <Ashsong> basti_: No, only the moves that actually occur.
09:14:02 <basti_> a tree-like game?
09:14:03 <Ashsong> The program is intended as a bookkeeping aid for use while playing the game.
09:14:20 <basti_> in all games i know, moves are chosen sequentially
09:15:15 <Cale> I've seen games where they're given in parallel and then conflicts resolved
09:15:17 <basti_> like, i make a move, you make one, then i make one
09:15:21 <Ashsong> I'll explain the types that I'm using (they're brief; there's only 3 or 4 of them) and I think what I'm saying will be clearer.
09:15:38 <Cale> Ashsong: is this anything like that?
09:15:58 <Ashsong> Creatures have types given by "CreatureType = Ogre | Centaur | ..."
09:16:04 * basti_ nods
09:16:20 <Cale> (i.e. an "everyone makes their move in secret and then there's a conflict resolution stage" type game)
09:16:37 <Heffalump> Diplomacy, yay :-)
09:16:44 <xerox> Nash Equilibrium
09:16:55 <Ashsong> Cale: Actually, we're only modeling how our knowledge of the contents of each players stacks changes as the abstract events "add, reveal, drop, and split" take place in the actual game.
09:17:04 <Ashsong> So anyway.
09:17:13 <Cale> Ashsong: ah
09:17:23 <basti_> so we're talking more about a bookkeeping thing than an AI player
09:17:26 <Ashsong> Stacks are modeled with a type called a "Bracket", which looks like:
09:17:26 <Ashsong> data Bracket =    Unit { unitId :: Unique, creature :: CreatureType } 
09:17:26 <Ashsong>   | Brkt {
09:17:26 <Ashsong>       minSize :: Integer,
09:17:26 <Ashsong>       maxSize :: Integer,
09:17:26 <Ashsong>       contents :: [Bracket]
09:17:28 <Ashsong>     }
09:17:32 <Ashsong> basti_: Correct.
09:17:48 <basti_> whats that?
09:17:49 <basti_> o.0
09:17:51 <xerox> ...and something like a command-line interface, or GTK one, or ncurses, to see the stats
09:17:58 <Ashsong> Yes.
09:18:23 <Ashsong> So Brackets can be either a single, known unit or a constraint.
09:18:33 <basti_> why dont you generalize over that?
09:18:38 <Ashsong> Mmm?
09:18:51 <basti_> for example, a thing could be "an ogre or an orc"
09:18:58 <basti_> or just "an ogre"
09:19:02 <basti_> or "anything"
09:19:17 <basti_> (thats always a partial set of the possible types)
09:19:20 <Ashsong> basti_: We thought about it, but it turns out that a probabilistic representation doesn't really buy you anything.
09:19:38 <basti_> i wasnt referring to probabilistic
09:19:51 <basti_> it seems to me that you're seperating "i'm sure its X" from "I'm not sure if its X or Y"
09:19:58 <Ashsong> Oh, I must have misunderstood you then.
09:20:17 <Cale> whereas those cases are really one
09:20:33 <basti_> yes
09:20:34 <Cale> since the first can be included in the second
09:20:36 <Ashsong> We're actually writing "I'm not sure if its X or Y" as "We know that it contains at least one and at most one thing from [X, Y]"
09:21:03 <basti_> so "we're sure" is a degenerate? ("I'm sure its at least one and at most one of [x]")?
09:21:04 <Cale> right
09:21:10 <Ashsong> Ah, yes, they can.  I just figured the pattern matching would be easier if we distinctly idenfied the "atoms" of the language, so to speak.
09:21:35 <Cale> oh, this is actually a tree though
09:21:40 <Ashsong> Getting there.  :)
09:21:46 <Cale> why a tree?
09:21:47 <Ashsong> Two more types - the tree type and the node type.
09:22:01 <Cale> Bracket is a tree
09:22:10 <Ashsong> Right, but it doesn't store any history.
09:22:18 <Cale> mm
09:22:21 <Ashsong> The tree that I'm talking about records the adds, drops, reveals, and shows.
09:22:30 <Ashsong> Hence:
09:22:32 <Cale> what does allowing Bracket to be a tree gain?
09:22:42 <Ashsong> data Node = TimeStep Bracket
09:22:42 <Ashsong>   | Split Integer Integer
09:22:42 <Ashsong>   | Add Bracket
09:22:42 <Ashsong>   | Reveal Bracket
09:22:42 <Ashsong>   | Die Bracket
09:22:50 <Ashsong> data Tree a = Leaf a |
09:22:50 <Ashsong>             Branch a (Tree a) |
09:22:50 <Ashsong>             Fork a (Tree a) (Tree a)
09:23:12 <Ashsong> Cale: It's really the representation that we're thinking in.  It has to do with the split algorithm.
09:23:13 <basti_> oof.
09:23:23 <benny> Ashsong!
09:23:37 <Ashsong> Mmm?
09:24:20 <benny> wait a minute... you're not the real ashsong
09:24:40 <int-e> so hmm ... you're building alternate versions of the history, and therefore a tree?
09:25:00 <Ashsong> benny: (I might be, if you're thinking of the one involved with OGRE)
09:25:20 <benny> yeah!
09:25:32 <Ashsong> int-e: Not even alternate versions; it just seemed like a convenient way to represent what was going on in the game.
09:25:46 <benny> Ashsong: what are you doing here?
09:26:03 <Ashsong> benny: Having a discussion  :)
09:26:24 <Ashsong> Let's see.  
09:27:08 <Ashsong> Cale: Players start off with two identical Brackets containing:  { {A, T}[1, 1], {O, O, C, C, L, L}[3, 3] }[4, 4]
09:28:34 <xerox> Readable! ;-)
09:30:47 <Ashsong> So anyway, the intial tree for each player looks like 
09:30:47 <Ashsong> Fork (Split 4 4) 
09:30:47 <Ashsong>     Leaf (TimeStep initialBracket)
09:30:47 <Ashsong>     Leaf (TimeStep initialBracket)
09:31:52 <int-e> Are the game's rules available anywhere?
09:32:00 <basti_> yea that might help
09:32:01 <Ashsong> int-e: Not sure; haven't looked.
09:32:12 <Ashsong> Anyway, we're at my actual question about types.
09:32:26 <basti_> then just ask it
09:32:27 <basti_> lol
09:33:00 <Ashsong> Which is: the game's pieces are unmarked so if we see an Ogre revealed in the Player's first stack, we need to pick out one of the two possible Ogres that could be there to "reveal".
09:33:22 <Cale> does it matter which one?
09:33:22 <Ashsong> The algorithm for doing that is to pick the most-recently added Ogre and to break ties arbitrarily.
09:34:00 <Cale> does it make a difference which one is revealed?
09:34:37 <Ashsong> It needs to be the most-constrained one, i.e. the most-recently added one, i.e. the one which is mentioned the fewest total times in the leaf nodes.
09:35:05 <Ashsong> That's what's required for the constraint propagation rule to be correct.
09:35:16 <Ashsong> So each creature needs to be identified uniquely.
09:35:24 <Ashsong> That's where the Unique comes from.
09:36:03 <Ashsong> I'd *really* like a way of generating unique ids that had type () -> Unique but that clearly can't happen (without resort to unsafePerformIO, which doesn't seem like the first thing I ought to try)
09:36:22 <Ashsong> Then the rest of the program (up until I start printing things, anyway) is completely pure.
09:37:06 <Ashsong> I.e. each creature is a singleton - it gets created exactly once and is only copied from there-on out.
09:37:52 <Ashsong> The question is basically, does the IO monad that is used to make the ids have to be propagated all the way up to the top-level functions?
09:38:09 <Ashsong> You see?
09:38:13 <Cale> You could also just use integers as unique ids
09:38:39 <Cale> and the idea if you were using uniques would be to make a bunch of them, and pass them into the pure functions
09:38:56 <Cale> IO is always the outermost part of your program
09:39:16 <Ashsong> Ah, so pre-generate the list of all ids and then just pull of the list as necessary?  (There are only a few hundred units in the game, ever, so that's quite doable)
09:39:40 <Ashsong> Cale: That was my understanding of the monad's purpuse; it seemed quite wrong to have it poisoning every intermediate function.
09:40:14 <Cale> Ashsong: but why not use integers? :)
09:40:31 <Ashsong> So, for example, if you look at the three setup functions I've written so far:
09:40:32 <Ashsong> makeCritter :: CreatureType -> IO Bracket
09:40:32 <Ashsong> makeCritter c = do id <- newUnique
09:40:32 <Ashsong>                    return Unit { unitId = id, creature = c}
09:40:38 <Ashsong> makeBracket :: Integer -> Integer -> [Bracket] -> IO Bracket 
09:40:38 <Ashsong> makeBracket minSize maxSize contents = return Brkt { minSize = minSize, 
09:40:38 <Ashsong>                                               maxSize = maxSize,
09:40:38 <Ashsong>                                               contents = contents }
09:40:45 <Cale> Or if you're afraid of using the integers incorrectly, a state monad, constrained so as to only provide unique ids
09:40:45 <Ashsong> initPlayer :: String -> IO Player 
09:40:45 <Ashsong> initPlayer playerName = do 
09:40:45 <Ashsong>   bigCritters <- mapM (makeCritter) [Angel, Titan] 
09:40:45 <Ashsong>   angelTitanBrkt <- makeBracket 1 1 bigCritters 
09:40:46 <Ashsong>   critters <- mapM (makeCritter) [Centaur, Centaur, Ogre, Ogre, Gargoyle, Gargoyle] 
09:40:48 <Ashsong>   crittersBrkt <- makeBracket 3 3 critters 
09:40:50 <Ashsong>   combinedBrkt <- makeBracket 4 4 [angelTitanBrkt, crittersBrkt] 
09:40:52 <Ashsong>   timeStepNode <- return $ Leaf (TimeStep combinedBrkt) 
09:40:54 <Ashsong>   splitNode <- return $ Fork (Split 4 4) timeStepNode timeStepNode 
09:40:56 <Ashsong>   return $ Player { name = playerName, root = splitNode, leaves = [timeStepNode, timeStepNode] } 
09:40:58 <Ashsong> Cale: Simple answer: I didn't think of it :)
09:42:13 <Ashsong> It just seemed completely wrong to be doing all of that initialization imperatively.
09:43:47 <Cale> hmm, yeah
09:44:04 <Cale> It's not necessary to be doing it like that
09:44:25 <Cale> (well, it sort of is, if you want to stick to Uniques, but there's no compelling reason to do so)
09:44:57 <Ashsong> Could you say a bit more about the structure of the other solutions you're thinking of?
09:45:03 <Cale> You could also do it "imperatively" in a weaker monad, which projects back to pure values.
09:45:27 * benny prods shapr 
09:45:56 <Cale> We can construct a monad for the sole purpose of generating unique integers
09:46:35 <Cale> A state monad will suffice, but to do it right, we should really restrict it
09:46:51 <Cale> Are you familiar with monads apart from IO?
09:47:01 <Philippa> there's a monad like that in the current (in-the-repo) Flippi codebase if you need something to rip
09:47:06 <Ashsong> Cale: I've read about them but never tried to program with them.
09:47:35 <Ashsong> Phillipa: Thanks for the suggestion.
09:47:38 <Cale> newtype Unique a = Unique (State Integer a) deriving (Functor, Monad)
09:47:46 <shapr> benny: hm?
09:48:40 <benny> shapr: i've fixed up the code a lot :)
09:48:41 <Cale> evalUnique (Unique s) = evalState s 0
09:49:02 * shapr looks
09:49:03 <Cale> inc :: Unique Integer
09:49:17 <Cale> well, that's a terrible name :)
09:49:17 <benny> shapr: haven't put it on the wiki yet (!)
09:49:22 <shapr> ah, ok
09:49:27 <Cale> getUnique :: Unique Integer
09:49:34 <benny> shapr: i'm using glade now
09:49:43 <shapr> How do you like it?
09:49:46 <Cale> getUnique = do v <- get; put (v+1); return v
09:49:55 <Cale> er
09:50:02 <Cale> getUnique = Unique (do v <- get; put (v+1); return v)
09:50:04 <Ashsong> Cale: so far so good; how does this thread through the rest of program?
09:50:09 <Cale> okay
09:50:55 <Ashsong> I.e. if I used a state monad like this, would I just be replacing the IO declarations with Unique declarations?
09:51:02 <Cale> so you can now do a bunch of constructing of objects in this monad, and then when you're done all of that, apply evalUnique
09:51:13 <Cale> and you'll get back pure values
09:51:20 <Ashsong> Mmm.  That sounds promising.
09:51:29 <Cale> it just saves the trouble of lots of parameter passing
09:51:45 <Cale> you could do it quite plainly by simply passing an Integer around
09:51:50 <Ashsong> Right.
09:52:36 <benny> shapr: i think i've discovered a bug in hs-plugins that causes it to crash sometimes, but other then that i am happy
09:52:43 <Ashsong> What would the type signature of makeCritter look like now?
09:52:49 <benny> shapr: ... except for my newbie haskell code style :(
09:52:59 <Ashsong> CreatureType -> Bracket ?
09:53:01 <Cale> makeCritter :: CreatureType -> Unique Bracket
09:53:16 <Cale> You're still in a monad, it's just not IO
09:53:17 <Ashsong> Okay.  So when do I actually call evalUnique.
09:53:35 <Cale> once you're done creating the initial setup
09:53:46 <Cale> and have all the creatures that you'll need
09:54:02 <Ashsong> Hmm.
09:54:21 <Ashsong> So I'm really looking at something like a makeAllCritters function that returns a list or a map of creatures.
09:54:36 <Cale> you could do it that way if you wanted too
09:54:57 <Ashsong> Then I'm going to be constructing the tree with stuff pulled out of that?
09:55:01 <Cale> but this just saves the trouble of worrying that a creature gets reused somewhere that it shouldn't
09:55:08 <Ashsong> Right.
09:55:23 <Ashsong> Hmm.  
09:55:35 <Ashsong> It seems as though this doesn't actually change anything about how I write the program.
09:55:46 <Cale> oh?
09:56:01 <Cale> do you need to create new creatures during the analysis?
09:56:05 <Ashsong> It might be a "tighter" fit for the actual goal, but my initFunction is still going to wind up returning M Player
09:56:29 <Cale> when is the last time that you need a new unique thing?
09:56:31 <Ashsong> Cale: Well, not exactly.  I.e. All of the creatures that will ever be created are known at the start of the game - there are only so many pieces, mind :)
09:56:36 <Cale> aha
09:56:52 <Cale> so then you apply evalUnique to that initial setup
09:57:15 <Cale> and it gives you a pure set of Players, or whatever
09:57:32 <Ashsong> However, it's not clear to me that recording the information about all of the creatures ever being made (there are only a few hundred) and then recording the "next Creature" of each type is actually better than just making the creatures on the fly, in the monad.
09:57:56 <Ashsong> Though maybe I'm wrong about that.
09:58:11 <Cale> well, you'll still have to thread your store of creatures through
09:58:16 <Cale> as you take them out
09:58:23 <Ashsong> Which I might as well do with State, no?
09:58:24 <Ashsong> :)
09:58:26 <Cale> yes
09:58:33 <Cale> so it works out to the same thing
09:58:41 <Ashsong> So the bottom line is that this program actually is fairly imperative in nature.
09:58:46 <Ashsong> Okay.
09:58:49 <Cale> somewhat, yeah
09:58:51 <Ashsong> I can live with that, I guess.
09:58:58 <Cale> though really, if you look at State, it's purely functional
09:59:07 <Ashsong> I just thought I'd check with someone who knew what they were doing before continuing.
09:59:10 <Cale> it's only the do-notation that's making it look imperative :)
09:59:30 <Cale> that's all turned into nice little combining functions
09:59:56 <Ashsong> Cale: Maybe you believe in Platonic forms, my friend, but I'm still constrained by syntax.  
10:00:02 <Cale> :)
10:00:10 <Ashsong> Anyway, thanks for your help.
10:00:31 <Cale> well, the important thing is that you can still be sure that nothing bizarre is going on apart from the very specific effect that you've provided
10:00:39 <Ashsong> benny: Good luck with your project!
10:00:39 <Cale> with IO, you don't have any guarantees
10:00:42 <Ashsong> Indeed.
10:00:51 <Ashsong> Bye now!
10:02:47 <shapr> benny: Bug finding is a good result.
10:12:41 <shapr> @type Test.HUnit.Test
10:12:42 <Cale> shapr: so what exactly do you mean about the "partially avoid the halting problem" thing? I'm not so sure I get the analogy.
10:12:42 <lambdabot> Not in scope: data constructor `Test.HUnit.Test'
10:12:58 <Cale> You can certainly make things a whole lot more efficient
10:13:05 <shapr> Cale: I mean that it gives you the ability to compare code.
10:13:13 <Cale> yes
10:13:23 <Cale> I'd agree with that, certainly :)
10:13:49 <Cale> Since you could just have your arrow operations build syntax trees
10:13:52 <shapr> And because of that, you can skip a lot of execution.
10:14:25 <shapr> You could do the same thing with datatypes, but datatypes aren't directly 'executable.'
10:14:52 <shapr> Monads are directly exuctable, but are subject to being uncomparable.
10:14:55 <shapr> executable*
10:15:23 <Cale> Well, functions of type a -> m b are uncomparable
10:15:58 <Cale> but then when you go to having an arrow type  a ~> b, that's abstract, and you can compare them.
10:16:02 <shapr> Anyway, tic|school asked about the point of arrows, he didn't ask for an explanation of arrows.
10:16:12 <Cale> yeah
10:17:00 <shapr> Yeah, arrows are like both a datatype representing a computation and an executable abstraction like monads.
10:17:54 <Cale> (at least, it's possible to represent your arrows by an often-comparable type)
10:18:11 <shapr> So you get access to all the cool tricks you'd get with a runtime interpreter or macro processor, without the need for a separate interpreter.
10:18:16 <Cale> a full instance of Eq is likely out of the question though
10:18:18 <Heffalump> doesn't 'arr' make it impossible to compare two instances of even a chosen arrow?
10:18:23 <Cale> yes
10:18:30 <Heffalump> just checking :-)
10:18:45 <Cale> Heffalump: but you can still compare some of the arrows you have available
10:18:54 <shapr> Yes, that's how Yampa gets its benefits.
10:20:06 <Cale> Heffalump: whereas, when your transitions are of type (a -> m b), you never get to do this comparison.
10:20:12 <Heffalump> Cale: sure
10:20:16 <shapr> Once you lift Haskell functions into arrows, you have the black box problem. But for many applications that's not necessary.
10:20:22 <Cale> You can do various sorts of fusion
10:20:45 <shapr> This is why darcs could gain efficiency benefits from patches as arrows.
10:21:11 <Heffalump> No, that idea is still bonkers.
10:21:30 <Cale> Heffalump: why?
10:21:32 <shapr> Seems pretty obvious to me.
10:22:08 <Heffalump> well, what are the benefits?
10:22:25 <shapr> Tell me why it's bonkers?
10:22:29 <Cale> moving from an arbitrary function representation of patches, to an abstract representation which allows them to be combined and optimised before application seems like a good thing
10:22:31 <Heffalump> patches aren't current structured as a monad
10:23:08 <shapr> So?
10:23:50 <Cale> arrows seem like a natural fit for that kind of combinator
10:24:52 <Philippa> something with a pure-like operation certainly does
10:25:08 <Philippa> although then you run into functions-are-still-black-boxes problems
10:26:57 * Heffalump can't find the logs of what I said the first time shapr brought this idea up
10:27:13 <benny> shapr: ok i've updated the wiki
10:27:50 <shapr> cool
10:28:16 <benny> shapr: you gotta get dons and friends to go over it and make comments+changes before i start writing the article ;)
10:28:23 <shapr> awright
10:30:31 <Heffalump> cale: the point is that one wouldn't be moving from an arbitrary function represenation of patches.
10:30:40 <Cale> The point is that you aren't going to represent most of your patches by (arr f), but something more structured in that arrow.
10:30:42 <Heffalump> because that's not a useful view of them in the first place
10:31:08 <Heffalump> they already are structured things
10:31:17 <Heffalump> arrows aren't a good fit, for one thing because of arr itself.
10:31:30 <Heffalump> darcs doesn't *want* arbitrary functions as patches, they just wouldn't work
10:32:56 <Heffalump> and that's the whole point of arrows, they let you have structure *and* arbitrary functions in the same setting
10:33:35 <Heffalump> and all the applications I've seen of arrows are very cool. But trying to fit everything into that box is pointless
10:33:41 <shapr> heh
10:36:04 <Heffalump> if you want a cool new FP idea to apply to darcs, look no further than GADTs ;-)
10:37:09 <shapr> Patch arrows would speed up patch operations by shortcutting comparisons. You could sort patches by which file they touch, the patch flavor, etc.
10:37:22 <Heffalump> you could do that anyway
10:37:31 <Heffalump> putting them in an arrow wouldn't make it any easier
10:37:56 <shapr> And monads are just explicitly passed values, right?
10:38:05 <Philippa> I have to admit, I could be sold on a category without arr just as if not more easily
10:38:33 <Heffalump> does arrow notation work without arr?
10:38:39 <Heffalump> arrows are pretty much unusable without that
10:38:51 <shapr> I think you should reread the papers.
10:39:01 <Philippa> not really, it assumes it can lift bits out of Haskell to do lifting work when needed
10:39:02 <Heffalump> and if I recall the translation scheme for arrow notation correctly, it relies quite heavily on it
10:39:09 <Heffalump> right
10:39:32 <Heffalump> shapr: why?
10:41:23 <dbremner> shapr - hello
10:41:26 <shapr> Because arrows without arr are roughly categories.
10:41:28 <shapr> hiya dbremner 
10:41:41 <Heffalump> no, that's not true
10:41:49 <jyp> arr, matey...
10:41:58 * jyp is ashamed
10:41:59 <shapr> Ok, whatever.
10:42:13 <Heffalump> jyp: and so you should be :-)
10:42:21 <jyp> ;p
10:42:27 <Philippa> they're specific categories with extra structure
10:42:33 <Philippa> IIRC
10:42:40 <Heffalump> yes, quite a lot of extra structure IIRC
10:42:53 <Heffalump> bicartesian closed mumblemumble, or is that monads?
10:42:54 <Philippa> and tbh, that structure is mostly... well, I'll *try* not to retch ;-)
10:43:16 <Philippa> give me a definition of 'bicartesian' - is it stronger or weaker than 'cartesian'?
10:43:21 <Heffalump> no idea.
10:43:32 <Heffalump> when it comes to those bits of category theory I only remember the buzzwords
10:43:41 <Heffalump> and not even them very well
10:43:44 <Philippa> I always just settle for "there's a product-like thing" in my own thinking, but then I've not had to do heavy CT work around there
10:43:57 <Philippa> the "product-like thing" certainly takes a lot of defining
10:44:37 <Cale> They're Freyd categories, iirc.
10:44:43 <Heffalump> that sounds familiar
10:45:39 <Philippa> Cale: I thought Freyd category was the whole thing complete with arr?
10:45:56 <Cale> oh, sorry, I thought we were discussing Hughes' Arrows?
10:46:18 <Philippa> more what you have left when you discard arr on the basis that you don't want the black boxing
10:46:28 <Cale> hmm
10:46:53 <Philippa> (I've found uses for the structure, but they're mostly what could be described as metawankery atm)
10:47:02 <Cale> Well, they'd still be Freyd categories, but in a less-interesting way.
10:47:11 <Heffalump> anyway, I think we're all agreed that they aren't general categories. Actually, re-reading what shapr said, he may not have meant that they are, but then he didn't need to discard "arr" to make that statement.
10:47:14 <Philippa> "oh look, they can lift themselves into themselves"?
10:47:21 <Cale> Philippa: yes
10:47:34 <Cale> so they're something stronger, most likely
10:47:40 <Philippa> Heffalump: he didn't mean they are from my reading, only that they form categories of some sort
10:47:54 <Heffalump> fair enough. But they would anyway.
10:48:00 <Philippa> I do get the impression you read strength into shapr's statements that isn't there sometimes
10:48:15 <Philippa> "everything is a category, oh look, I just found a new programming paradigm!"? :-)
10:48:40 <Heffalump> :-)
10:49:34 <Philippa> (for my money, there's probably interesting/useful metawankery to be done with that - and I know I'm not the first person to think it)
10:49:50 <Cale> But arrows are roughly categories in any event.
10:50:13 <Cale> They're something more specific than general categories
10:50:27 <Heffalump> right, which was why I thought he meant that arrows without arr are categories whereas arrows aren't
10:50:32 <Philippa> "wow, I have a general category. I can, er, stick things together"
10:50:52 <jethr0> philippa is awfully cynical todat/tonight :)
10:51:11 <Heffalump> Philippa: isn't most of category theory metawankery? ;-) Except when it turns out to have discovered something useful like monads or arrows years before functional programmers did, of course.
10:51:15 <Cale> It's like a monoid, but the operation is only partially defined :)
10:51:27 <Philippa> jethr0: had a long weekend. Oh, and this is territory I've kinda explored in my own time
10:51:41 <gzl> Heffalump: no
10:51:48 <Cale> Heffalump: there's some pretty neat stuff there
10:51:51 <Philippa> Heffalump: yeah. I do think there's fun to be had with analysing properties of categories and ways of combining those properties
10:51:52 <Heffalump> yes, I know.
10:51:53 <jethr0> chinese remainder theorem seems like (sort of) like an application of category theory...
10:52:12 <Cale> jethr0: well, it's certainly a lot clearer in that framework!
10:52:17 <Heffalump> but there's lots of neat stuff deep in lambda calculus, and that feels like metawankery too sometimes.
10:52:25 * Philippa nods
10:52:41 <Philippa> there's nothing /wrong/ with wankery
10:52:43 <gzl> pure category theory is kind of wankery, but the language and basic concepts are very widely used in algebraic geometry/topology/..., etc
10:52:43 <Cale> what's wrong with metawankery anyway?
10:52:47 <jethr0> couldn't you also do some nice stuff with "polynome multiplication" and FastFourierT, or something?
10:52:56 <gzl> Cale: it can be a little unsatisfying sometimes
10:53:05 <jethr0> transforming domains, solving problems and transforming back is sometimes nice
10:53:06 <Cale> one could consider all of mathematics as wankery
10:53:15 <Heffalump> yeah, much more satisfying to interface with a computer
10:53:16 <gzl> and I think some would say it's a little unsatisfying :)
10:53:17 <jethr0> and if category theory can help specify those transformations, all the better
10:53:27 <Philippa> Heffalump: remind me not to use your keyboard
10:53:30 <Cale> After all, you're just pushing formal symbols around according to arbitrary rules
10:53:36 <Cale> :)
10:53:39 <Heffalump> Philippa: it does tend to get a bit sticky
10:53:41 <dbremner> Cale - reminds me of the quip "All models are wrong, some are useful."
10:53:52 <Philippa> Cale: you familiar with the phrase "ha ha only serious"? :-)
10:53:59 <Cale> Philippa: quite :)
10:54:03 <gzl> I think algebraic topology provides some really good historical and conceptual motivations for the basic ideas in category theory
10:54:16 <Cale> gzl: yeah
10:54:17 <Philippa> and I could elaborate further, but probably in -blah ;-)
10:54:19 <gzl> it answers the initial "wtf??" question pretty well
10:54:29 <Cale> The concept of natural transformations is definitely worth it
10:54:33 <gzl> yeah
10:54:36 <Heffalump> agreed
10:54:45 <gzl> and it makes functors pretty concrete
10:54:47 <Philippa> I still need better mathematical foundations. I mean really, I kinda dropped the ball on that after A level
10:54:52 <Heffalump> I got confused by category theory at the point of adjunctions.
10:55:01 <gzl> the problem is that you need to know algebra *and* topology to read about that stuff
10:55:21 <JKnecht> wankery if it only results in further math, 'the real thing' if in practical apps?
10:55:27 <Philippa> yeah. That's frustrating, I suspect it'd make concrete a lot of the way I only intuit
10:55:55 <gzl> JKnecht: I think at that point a lot of things are not wankery
10:55:55 <Philippa> JKnecht: depends how the practical app joins in. I mean, it's possible to wank using your partner's body as a toy...
10:56:00 <gzl> depending on what you think is practical
10:56:01 <Cale> JKnecht: the point is kind of that it doesn't matter -- it's structure with which to build models of things.
10:56:14 <gzl> if monads aren't wankery, what is? :)
10:56:19 <takuan> can I put some code on the haskell wiki?
10:56:19 <Heffalump> arrows, duh.
10:56:25 <takuan> or may I paste it here?
10:56:30 <Heffalump> takuan: there's a pastebin
10:56:31 <gzl> use the paste page
10:56:35 <Philippa> takuan: post it on the wiki's pastebin page, it's what it's there for
10:56:37 <Heffalump> I'm sure someone can remind us where it is
10:56:41 <Philippa> @paste
10:56:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:56:45 <Heffalump> the lisppaste one is better, isn't it?
10:56:48 <takuan> You are not allowed to edit this page.
10:56:49 <Heffalump> Cos it announces it to the channel
10:57:04 <astrolabe> takuan: you need to register
10:57:08 <takuan> humz
10:57:10 <Cale> You prefabricate a bunch of structures, and they become recognisable, and you can try to apply them to things in the real world with varying success at prediction.
10:57:47 <Cale> Heffalump: but it doesn't source highlight
10:57:57 <Heffalump> true
10:58:02 <Heffalump> well, do whatever you feel like :-)
10:58:05 <gzl> there is some book I looked at on categories for CS/PL people
10:58:11 <gzl> but it's so confusing, because all of the examples are in (Sets)
10:58:27 <gzl> I think that can make the material significantly weirder
10:58:32 <takuan> astrolabe: where can I register?
10:58:37 <gzl> even though the barrier to entry is much lower
10:59:07 <Cale> It would certainly seem quite pointless, when you have only one category.
10:59:40 <gzl> well, he does mention many other categories in one page
10:59:41 <astrolabe> I don't think you need that much maths to motivate category theory.  Say just sets & functions and real vector spaces and linear maps should give you enough examples to get a long way.
10:59:55 <gzl> but then doesn't illustrate the later concepts using them
11:00:00 <gzl> e.g. initial/terminal objects
11:00:05 <gzl> or whatever
11:00:15 <Cale> yeah
11:00:33 <astrolabe> takuan: http://haskell.org/hawiki/UserPreferences
11:01:02 <Cale> A first course in algebraic topology really helps to appreciate some things.
11:01:05 <gzl> oh, here's a question. can you consider the category of covering maps of a base space B with equivalence of coverings as morphisms as a comma category over B?
11:02:16 <astrolabe> cale: I would argue that is too much work for it's benefits in learning category theory.
11:02:34 <Cale> astrolabe: perhaps, but it has intrinsic benefit too :)
11:02:39 <shapr> Yeah, CT is nifty.
11:03:02 <Cale> gzl: hmm...
11:04:10 <Heffalump> what are the main achievements of category theory, from the point of view of a non-category theorist?
11:04:25 <Philippa> selling books ;-)
11:04:56 <soysauce> is there a good example of how to use mutable arrays? (Data.Array.ST.STArray)
11:05:24 <gzl> Heffalump: it provides an abstract language that makes it considerably easier to do work in various subfields of mathematics; it helps you look at "what does this thing actually do?" rather than "how is it constructed?" or other nitty-gritties
11:05:27 <Cale> Heffalump: the Yoneda lemma is pretty significant -- at least philosophically
11:05:31 <astrolabe> There is powerful abstract gobbledegook 'derived categories' useful in algebraic geometry I believe.
11:05:44 <gzl> algebraic geometry uses a LOT of stuff from category theory
11:05:48 <gzl> for exactly this reason
11:05:48 <Cale> but really the benefit is in how it's changed the language of mathematics
11:06:00 <Philippa> gzl: that'd be my pick too. That's sure what it's good for in CS
11:06:23 <astrolabe> I think that is more important than it's unifying aspect.
11:06:24 <takuan> ok
11:06:31 <gzl> well, in addition, there are certain theorems you can prove in the general setting
11:06:41 <gzl> that are way easier to prove than the specific instances within a specific category
11:06:52 <takuan> is there an easy fix around the problem with the code i just pasted in http://haskell.org/hawiki/HaskellIrcPastePage other than the solution which we devised a few days ago using threads?
11:07:00 <Cale> soysauce: hmm
11:07:03 <Heffalump> stuff like general fusion theorems of catamorphisms/anamorphisms would be my example
11:07:03 <gzl> you get a lot of stuff "for free" because you immediately see that X Theorem applies to all abelian categories, for example
11:07:13 <takuan> the code tries to iterate a function for a given amount of time
11:07:29 <Cale> soysauce: there might be something in YAHT
11:07:35 <takuan> obviously this doesn't compile because we try to create an infinite type
11:07:36 <Heffalump> takuan: AFAIK there is no way to time limit things without threads or forking.
11:08:00 <Cale> soysauce: you can sort of infer how to use them from studying the types
11:08:00 <Heffalump> oh, apart from having the thing interrupt itself periodically to check, as you're doing there
11:08:02 <gzl> for example, you could show that some functor F commutes with products by showing that F can be represented as some Hom functor; then you have immediately that Hom commutes with products, and you're done
11:08:03 <astrolabe> I think mathematicians would have proved the results separately in the different contexts, and realised their commonalities without category theory.
11:08:07 <gzl> (this happens with the fundamental group functor)
11:08:29 <Heffalump> takuan: what's the type error, precisely?
11:08:48 <Cale> oh, that's the unwritten part of YAHT :/
11:09:15 <takuan>  Occurs check: cannot construct the infinite type: a = IO a
11:09:39 <Cale> takuan: did you paste somewhere?
11:09:57 <Heffalump> oh, that return around iter is superfluous
11:10:09 <Heffalump> return (iter start msec f x) should be iter start msec f x
11:10:12 <Heffalump> return :: a -> IO a
11:10:19 <Heffalump> but iter already returns IO something
11:10:34 <Heffalump> the return around (val now) is also superfluous
11:10:34 <takuan> Cale: irc pastepage
11:10:40 <gzl> Heffalump: and the third thing I'd cite is that it provides a rigorous language for discussing a theory that takes you from one domain (e.g. topology) to another (e.g. groups); if you want to talk about how relationships between spaces translate into relationships between other structures, functors are where you wind up
11:10:43 <Cale> takuan: yeah, Heffalump is right
11:10:46 <Heffalump> (by superfluous here, I mean wrong :-)
11:10:59 <takuan> now
11:11:04 <takuan> what can we do about that?
11:11:11 <Cale> delete the word "return"
11:11:29 <Cale> (the first instance of it there)
11:11:37 <astrolabe> gzl: but that stuff wouldn't have been difficult before categories.
11:11:49 <Heffalump> both instances, in fact.
11:11:51 <Cale> also, the last instance of it is probably also wrong
11:12:00 <Cale> the one in the middle is okay
11:12:05 <Cale> er
11:12:05 <Cale> no
11:12:17 <gzl> astrolabe: at some point, it does become difficult
11:12:20 <Cale> the last instance is fine, but the middle isn't
11:12:23 <Heffalump> oh, the one at the end is ok.
11:12:25 <Heffalump> yeah.
11:12:30 <Heffalump> So get rid of the first two, keep the third.
11:12:37 <gzl> astrolabe: there's a reason all this came out of the needs of algebraic topology, after all :)
11:13:50 <benny> anyone know what causes in ghc "Linking ..." stage the error: collect2: ld terminated with signal 9 [Killed]
11:14:22 <Frookyo> hi all
11:17:46 <astrolabe> Were they originally invented to formalise the definition of 'natural transformation'?
11:17:46 <Frookyo> how can a use the foldr function for this      maxList :: [Int] -> Int    
11:17:46 <astrolabe> That is valuable.
11:17:46 <astrolabe> Frookyo: homework?
11:17:46 <Frookyo> yes+
11:17:46 <takuan> Heffalump: so basically it is possible without threads and forking ;)
11:17:46 <Frookyo> ive made it for sum and product
11:17:58 <Frookyo> but for the maxlist it doesn't work
11:18:08 <astrolabe> can you do it without using foldr?
11:18:36 <Frookyo> hmm i didn'T try it but i should be able to
11:19:36 <astrolabe> here we go again.
11:20:13 <newsham> hi
11:20:13 <Frookyo> lol whats going on with the server?
11:20:51 <astrolabe> net split
11:21:04 <astrolabe> they'll come back in a moment.
11:21:16 <newsham> i'm slowly working my way through some monad documents.  I have a question about the State monad.  it provides 'get' and 'put' functions
11:21:20 --- mode: irc.freenode.net set +o shapr
11:21:27 <newsham> hmm
11:21:39 <newsham> i'm slowly working my way through some monad documents.  I have a question about the State monad.  it provides 'get' and 'put' functions
11:21:40 <astrolabe> what should your function return if you pass it the empty list?
11:21:42 <Frookyo> astrolabe do you know how i can use foldr   for this   maxList :: [Int] -> Int ??
11:21:47 <SlowByte> benny: resource limits, possibly? out of memory?
11:21:48 <soysauce> @type newArray
11:21:50 <benny> SlowByte: perhaps
11:22:01 <newsham> what would be a good way to apply a function to extract a subcomponent of the state after a "get"?
11:22:11 <SlowByte> the OOM killer should leave a message on syslog IIRC
11:22:13 <newsham> (also what about updating a subcomponent of the state after a put)
11:22:29 <newsham> ie. if the state is a tuple, and I would like to apply  "fst" to the tuple after a get
11:22:33 <Heffalump> and I don't think it reports signal 9
11:22:42 <Saulzar> newsham, You can use pattern matching as usual
11:22:55 <Heffalump> Frookyo: please stop repeating the question, and think about the questions people are asking you.
11:22:56 <Saulzar> newsham, (x, y) <- get
11:23:14 <newsham> saulzar: more to the point, I want to compose "get" and "fst" into a single function
11:23:33 <ustenzel> newsham: gets fst
11:23:33 <ustenzel> newsham: liftM fst get
11:23:46 --- mode: irc.freenode.net set +o shapr
11:23:56 <newsham> ie:   getX = get >>= \s -> return (fst x)
11:24:16 <newsham> isnt there an easier way to do this compsition?  (ie. I could write a generic   getFunc, but is there already one?)
11:24:30 <newsham> ahh, liftM is what I want
11:24:40 <astrolabe> Frookyo: what do you want the value to be for the empty list?
11:24:59 <Cale> or  fmap fst get
11:25:11 <Frookyo> a empty list
11:25:18 <newsham> cale: danke.
11:25:31 <newsham> > sfunc f = get >>= \s -> return (f s)
11:25:34 <newsham> is that fmap?
11:25:46 <newsham> err.. wait.. no because i have get in there :)
11:26:11 <Heffalump> Frookyo: that doesn't make sense
11:26:13 <lambdabot> Not in scope: `newArray'
11:26:16 <newsham> fmap f x =   x >>= \y -> return (f y)    ?
11:26:19 <Heffalump> you said it should have type maxList :: [Int] -> Int
11:26:23 <Heffalump> and an empty list isn't of type Int
11:26:42 <Cale> fmap and liftM are essentially the same thing, but liftM only works for monads
11:26:50 <astrolabe> Frookyo, doesn't that have the wrong type?
11:27:04 <Frookyo> oh of course... it should give an error when you give him a empty list
11:27:10 <Heffalump> > sin 2
11:27:33 <Frookyo> astrolabe: no our teacher said we should use this type
11:27:49 <Cale> look at foldr1
11:27:58 <newsham> ok, cool, so I can use   "stateAccessor = liftM accessor get" 
11:28:00 <astrolabe> @type foldr
11:28:05 <Cale> @type foldr1
11:28:09 <newsham> now what about composing things with "put" to update pieces of state?
11:28:11 <Cale> oh, it's dead
11:28:19 <ricebowl> no, it's just lagging
11:28:22 <Cale> @type foldr1
11:28:23 <mbot> forall a. (a -> a -> a) -> [a] -> a
11:28:25 <ricebowl> it will respond in about 5 minutes
11:28:36 <astrolabe> @type foldr
11:28:36 <ricebowl> @type newArray_
11:28:37 <mbot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:28:38 <mbot> Not in scope: `newArray_'
11:28:49 <ricebowl> @type Data.Array.ST.newArray
11:28:51 <mbot> forall e
11:28:51 <mbot>            (a :: * -> * -> *)
11:28:51 <mbot>            (m :: * -> *)
11:28:51 <mbot>            i.
11:28:51 <mbot>          (Data.Array.Base.MArray a e m, GHC.Arr.Ix i) =>
11:28:53 <mbot>          (i, i) -> e -> m (a i e)
11:29:02 <Cale> http://vx.hn.org/autoshare/folds.png
11:29:13 <Cale> this has diagrams of various folds
11:29:38 <astrolabe> Frookyo: do you want to go to #haskell-overflow ?
11:29:52 <Frookyo> ok
11:29:53 <Heffalump> > sin 2
11:29:55 <mbot> 0.9092974268256817
11:29:57 <Cale> in the case of a maxList function, you'll want one of the latter two
11:30:09 * Heffalump questions the need for #haskell-overflow
11:30:27 <Philippa> it does sometimes get traffic while there's talking in here
11:30:38 <Cale> % N[Sin[2],50]
11:30:39 <mbot> Cale: 0.9092974268256816953960198659117448427022549714478902683789730137945`50.
11:30:41 <Heffalump> wouldn't it be better for it all to be here, though?
11:30:59 <Heffalump> volume on here isn't *that* high
11:31:13 <Philippa> there're times one conversation kills another dead
11:31:16 <Heffalump> oh well, I guess if people find it useful.
11:31:25 <Philippa> especially The Tour
11:31:29 <lambdabot>  parse error on input `='
11:31:33 <Heffalump> I just find it a bit annoying when either (a) someone asks me to take a conversation there or (b) One that I was following moves there
11:31:37 <lambdabot> 0.9092974268256817
11:31:39 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:31:41 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:31:45 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:31:47 <Cale> Heffalump: sometimes it's nice when you have a lecture or something where you don't want interruptions
11:31:47 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:31:49 <lambdabot> Not in scope: `newArray_'
11:31:51 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i.
11:31:53 <lambdabot> (Data.Array.Base.MArray a e m, GHC.Arr.Ix i) =>
11:31:55 <lambdabot> (i, i) -> e -> m (a i e)
11:31:57 <Cale> haha
11:31:58 <Heffalump> Cale: fair enough
11:32:01 <lambdabot> 0.9092974268256817
11:32:02 <Cale> lag :)
11:32:04 <newsham> updFst x' (x,y) = (x', y)    ;   putX x' = liftM (updFst x') put ?
11:32:11 <int-e> @hoogle a -> [a]
11:32:12 <lambdabot> Data.List.repeat :: a -> [a]
11:32:12 <lambdabot> Prelude.repeat :: a -> [a]
11:32:12 <lambdabot> Data.List.replicate :: Int -> a -> [a]
11:32:13 <mbot> http://www.biblegateway.com/
11:32:15 <Cale> mbot: @part #haskell
11:32:15 <ricebowl> like I said, lambdabot was lagging by *exactly* 5 minutes
11:32:30 <Heffalump> can we kick it temporarily?
11:32:37 <int-e> why doesn't (:[]) have a name?
11:32:41 <ricebowl> it's done, I think
11:32:46 <Heffalump> cos that's shorter :-)
11:32:49 <int-e> > return 1 :: [Int]
11:32:50 <lambdabot> [1]
11:32:55 <Heffalump> wrap is the usual name people give it
11:32:56 <int-e> I guess it does have a name.
11:32:59 <Heffalump> but it's not in the prelude
11:33:02 <Heffalump> (IIRC)
11:33:08 <Cale> odd, it mbot spell checked hoogle to google and apparently biblegateway.com has something to do with "a -> [a]"
11:33:26 <Heffalump> "Go forth and multiply"
11:33:32 <Philippa> it's only really useful as a HOF parm anyway
11:33:55 <Philippa> otherwise it's quicker and often clearer to write [foo]
11:34:10 <newsham> is there an elegant way to compose an update function with the "put" function in the State monad?
11:34:25 <takuan> Heffalump: so it is possible without threads and forking and stuff ;)
11:34:34 <int-e> Philippa: I was using it as a HOF parameter; I was creating a list of singletons from a list with map.
11:34:40 <Heffalump> takuan: yes, ok :-)
11:34:41 <ustenzel> newsham: modify
11:34:52 <int-e> Philippa: And I thought that (:[]) looks remarkably ugly.
11:34:56 <Heffalump> I was thinking of pre-emptive interruption, not cooperative.
11:35:15 <Heffalump> but cooperative interruption is only useful when you are sure that a single iteration won't run away
11:35:21 <Heffalump> so it's strictly weaker, obviously
11:35:38 <newsham> where is modify defined?
11:35:39 <Heffalump> int-e: one for PreludeExts or whatever it's called
11:35:53 <newsham> i dont see it in Monad or the prelude
11:35:54 <Heffalump> which State monad are you using?
11:36:02 <newsham> Monad.Control.State
11:36:04 <ustenzel> newsham: Control.Monad.State
11:36:10 <ricebowl> (:[]) is the same as return
11:36:13 <newsham> err.. yah, that.
11:36:14 <ricebowl> @pl (:[])
11:36:14 <lambdabot> return
11:36:23 <int-e> it's not the same
11:36:26 <int-e> return is more general
11:36:29 <Heffalump> @type Control.Monad.State.modify
11:36:30 <lambdabot> forall (m :: * -> *) s.
11:36:30 <lambdabot> (Control.Monad.State.MonadState s m) =>
11:36:30 <lambdabot> (s -> s) -> m ()
11:36:34 <Heffalump> seems to be there :-)
11:36:39 <ricebowl> sure, but return can do the same thing
11:36:53 <Heffalump> you'll get confusing error messages, though
11:37:01 <Heffalump> sometimes more specific types are good
11:37:06 <newsham> but not in http://haskell.org/onlinereport/monad.html
11:37:09 <int-e> ricebowl: Thanks, but I noticed that shortly after I asked my question :)
11:37:18 <Heffalump> newsham: that doesn't define state monads either, though
11:37:22 <ricebowl> *nods*
11:37:26 <newsham> yah, where do I find that definition?
11:37:48 <Heffalump> the online GHC docs for Control.Monad.State would be the easiest place
11:38:02 <newsham> danke
11:38:08 <ricebowl> any idea how to create a mutable array in the ST monad, permute it, and then get an immutable array for general use? I see runSTArray, but I can't figure out how to use it.
11:38:13 <Heffalump> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
11:38:19 <SineTwo> could anyone help me out with a very simple function?
11:38:26 <SineTwo> dont quite understand how it recurses...
11:38:36 <SineTwo> i've written it, and it magically worked, hehe
11:38:43 <ricebowl> SineTwo - pastebin the function
11:38:48 <SineTwo> will do
11:38:59 <musasabi> ricebowl: the freeze functionality
11:39:00 <Heffalump> ricebowl: what goes wrong?
11:39:06 <Heffalump> musasabi: runSTArray seems to encapsulate that
11:39:09 <Cale> hehe, we don't get many requests to help with working code :)
11:39:12 <musasabi> Heffalump: point.
11:39:12 <ricebowl> Heffalump - nothing goes wrong, I don't understand how to use it
11:39:15 <Heffalump> @type Data.Array.ST.runSTArray
11:39:16 <lambdabot> forall e i.
11:39:16 <lambdabot> (GHC.Arr.Ix i) =>
11:39:16 <lambdabot> (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e))
11:39:16 <lambdabot> -> GHC.Arr.Array i e
11:39:23 <ricebowl> Heffalump - I am trying to write the code...and failing
11:39:24 <Heffalump> ricebowl: make a ST computation that produces a STArray
11:39:34 <ricebowl> Heffalump - well, I've never worked with ST before
11:39:34 <Cale> should I tell lambdabot to part?
11:39:38 <Cale> oh
11:39:39 <Heffalump> so its final action would be return foo where foo :: STArray s i e
11:39:43 <Cale> no that wasn't so lagged
11:39:44 <SineTwo> ricebowl: http://pastebin.com/459849
11:39:50 <Cale> nm :)
11:39:55 <Heffalump> (for example)
11:40:02 <Heffalump> ricebowl: but you're familiar with monads?
11:40:13 <ricebowl> SineTwo - this grabs the nth char?
11:40:15 <ricebowl> Heffalump - yes
11:40:29 <SineTwo> ricebowl: yup
11:40:30 <newsham> ahh.. they have a "gets" function for doing the extraction too
11:40:49 <ricebowl> SineTwo - well, while n != 0, it drops the first character in the string and recurses with n = n-1
11:41:06 <SineTwo> ricebowl: how does it keep dropping the first character tho?
11:41:06 <ricebowl> SineTwo - and on the nth iteration it returns the first character in the string...this is the same as head (drop n xs)
11:41:14 <ricebowl> SineTwo - because it keeps hitting the second case
11:41:27 <ricebowl> n /= 0, therefore it executes the "otherwise" part
11:41:45 <ricebowl> because of the pattern match (x:xs) against the string parameter, xs has all characters except the first
11:41:54 <ricebowl> > let foo (x:xs) = xs in foo "abcd"
11:41:55 <lambdabot> "bcd"
11:42:11 <Heffalump> ricebowl: ok, do you see how you'd write something of type ST s (STArray s i e) using the STArray operations, then?
11:42:28 <ricebowl> Heffalump - no, not at all, that's the hold-up :)
11:42:48 <ricebowl> Heffalump - if I saw a short example I think I could figure it out. IO was trivial after I saw a little bit of code.
11:42:50 <Heffalump> oh, the docs are a bit annoyingly abstract.
11:42:53 <SineTwo> ricebowl: yeah i see that.. but i just dont understand how the otherwise part works...
11:43:16 <SineTwo> fetch n-1 (xs) - what does that mean?
11:43:17 <ricebowl> SineTwo - the guards (the | syntax) are a big if statement
11:43:35 <Heffalump> @type do { foo <- newArray (1,5) 'a' ; return foo } :: ST s (STArray s Int Char)
11:43:36 <lambdabot> Not in scope: `newArray'
11:43:36 <lambdabot>  
11:43:36 <lambdabot> <interactive>:1:49: Not in scope: type constructor or class `ST'
11:43:40 <ricebowl> it calls fetch with the first parameter as (n-1) and the second as xs...though you need parenthesis around n-1
11:43:45 <Heffalump> @type do { foo <- Data.Array.ST.newArray (1,5) 'a' ; return foo } :: ST s (STArray s Int Char)
11:43:46 <lambdabot> Not in scope: type constructor or class `ST'
11:43:46 <lambdabot>  
11:43:46 <lambdabot> <interactive>:1:69: Not in scope: type constructor or class `STArray'
11:43:59 <Heffalump> well, something like that, aanyway..
11:44:22 <ricebowl> SineTwo - this might be a more helpful way to think about it: fetch n (x:xs) = if n == 0 then x else fetch (n-1) xs
11:44:29 <Heffalump> @type do { foo <- Data.Array.ST.newArray (1,5) 'a' ; return foo } :: Control.Monad.ST.ST s (Data.Array.ST.STArray s Int Char)
11:44:30 <lambdabot> Control.Monad.ST.ST s (Data.Array.ST.STArray s Int Char) :: forall s. GHC.
11:44:30 <lambdabot> ST.ST s (GHC.Arr.STArray s Int Char)
11:44:35 <Heffalump> there you go :-)
11:44:40 <ricebowl> Heffalump - many thanks
11:44:42 <SineTwo> ricebowl: yeah, i understand that it recurses, and when n = 0 it returns the character... but how does haskell sort of move up the array of chars?
11:44:50 <Heffalump> basically, look in the MArray class for the operations
11:45:24 <ricebowl> Heffalump - my operations go into the do, yes?
11:45:27 <Heffalump> yes
11:45:41 <ricebowl> SineTwo - it's a list of characters. Here, look at this example again:
11:45:45 <ricebowl> > let foo (x:xs) = xs in foo "abcd"
11:45:46 <lambdabot> "bcd"
11:46:02 <newsham> is the state monad used often?  (isn't imperative programming frowned on by haskell types?)
11:46:03 <ricebowl> SineTwo - the string is "abcd", and the function returns "bcd". Why do you think that is?
11:46:03 <Heffalump> the end result should be a STArray, and then runSTArray will freeze it into a immutable array for you
11:46:04 <int-e> > let foo (x:xs) = xs in foo ['a', 'b', 'c', 'd']
11:46:05 <lambdabot> "bcd"
11:46:19 <ricebowl> Heffalump - ah, I see
11:46:24 <int-e> > let foo (x:xs) = xs in foo 'a' : 'b' : 'c', : 'd' : []
11:46:25 <lambdabot>  parse error on input `,'
11:46:28 <SineTwo> ricebowl: because it takes the tail?
11:46:30 <int-e> > let foo (x:xs) = xs in foo 'a' : 'b' : 'c' : 'd' : []
11:46:31 <lambdabot> Couldn't match `[a]' against `Char'
11:46:32 <Heffalump> newsham: the nice thing about state monads is that they allow you to partition off the bits that really need "imperative" programming from the rest of your code
11:46:38 <ustenzel> newsham: all the time.  which is good, since it is purely functional ;-)
11:46:44 <ricebowl> Heffalump - confusing, then; I thought runSTArray actually executed the computation, but I suppose it simply forces evaluation to get a result
11:46:46 <newsham> "really need"?
11:46:47 <int-e> > let foo (x:xs) = xs in foo $ 'a' : 'b' : 'c' : 'd' : []
11:46:48 <lambdabot> "bcd"
11:47:07 <Heffalump> ricebowl: well, if you're being pedantic, the only thing that executes a computation is the RTS when it calls main.
11:47:12 <Heffalump> everything else just defines values.
11:47:16 <ricebowl> SineTwo - it binds the variable xs to the tail and x to the head of the list, so if you return xs then you get the tail back
11:47:40 <ricebowl> Heffalump - yes, true, but these "values" execute computations when they are called ;)
11:48:02 <Heffalump> but in operational terms, asking for the result of runSTArray will cause the wrapped computation to be run
11:48:31 <ricebowl> er, whoops, return was a poor choice of words...but anyway, if the value of the function is xs, then the function gets the tail from the list
11:48:42 <ricebowl> Heffalump - *nods* ok
11:49:23 <ricebowl> Heffalump - are the burly braces simply a syntax that allows you to put all of that code on a single line?
11:49:30 <Heffalump> btw, random OT cool thing of the month: http://the.earth.li/~alex/halley/advent/ (from a friend on his way to spend a couple of years in Antarctica)
11:49:34 <ricebowl> analogous to their use in popular imperative languages
11:49:35 <Heffalump> ricebowl: yes
11:49:37 <ricebowl> ok
11:49:46 <SineTwo> ricebowl: right.. i see... so otherwise it fetches the tail..? but when it does "fetch 4 xs" for example it loops four times and checks if n = 0?
11:49:57 <Heffalump> in a real program I'd nearly always use layout and multiple lines
11:50:51 <ricebowl> Heffalump - yeah
11:51:09 <ricebowl> SineTwo - no, look at a single iteration of the recursion
11:51:31 <ustenzel> newsham: MonadState is never strictly needed, it's just convenient.  ST is sometimes needed to avoid unnecessary runtime cost.  I rarely use the later.
11:51:54 <ricebowl> SineTwo - normally when you want to understand recursion, you look at the base case (n == 0) and at the step that it performs when it recurses
11:52:12 <ricebowl> > let foo (x:xs) = x in foo "abcd"        -- the base case
11:52:13 <lambdabot> 'a'
11:52:22 <Heffalump> in principle I think a very good implementation would always optimise MonadState to be equivalent to ST.
11:52:29 <Cale> ricebowl: also, the use of semicolons and braces are separate -- you can choose to use semicolons even without the braces
11:52:33 <Heffalump> but in practice it's probably quite a lot of hassle
11:52:44 <ricebowl> Cale - what do the semi-colons do?
11:53:01 <Heffalump> the semi-colons do what going to a new non-indented line does in "normal" syntax
11:53:02 <Cale> ricebowl: separate lines, like in layout
11:53:06 <SineTwo> ricebowl: ah ok...
11:53:07 <Heffalump> I'm not actually sure what the braces do, then.
11:53:08 <ricebowl> ah
11:53:08 <Cale> yeah
11:53:19 <Cale> the braces mark off a block
11:53:26 <Heffalump> I just automatically use them to wrap around anything with ;s
11:53:29 <Cale> which gets rid of some ambiguities
11:53:35 <ricebowl> SineTwo - when n == 1, then it does what I showed you earlier. It removes the first character and recurses. Since on the second iteration, n == 0, it will take the second element.
11:53:38 <int-e> Heffalump: you could read the haskell report - it describes how indentation is turned into braces and semicolons.
11:53:50 <Heffalump> can you give an example of using braces without semicolons? Where the braces actually matter, that is.
11:53:58 <Heffalump> int-e: yeah, I could. But I'm lazy :-)
11:54:02 <Cale> > do x <- [1,2,3]; y <- [10,20,30]; return (x+y)
11:54:03 <lambdabot> [11,21,31,12,22,32,13,23,33]
11:54:12 <Heffalump> and maximum munch rules give me headaches.
11:54:22 <SineTwo> ricebowl: ah ok
11:54:43 <ricebowl> SineTwo:
11:54:45 <Cale> I think that once you use braces, you have to use semicolons, but I'm not sure about that
11:55:05 <ricebowl> > let fetch n xs = head (drop n xs) in fetch 3 "abcde"
11:55:07 <lambdabot> 'd'
11:55:12 <ricebowl> ;)
11:55:42 <Cale> > "abcde" !! 3
11:55:43 <lambdabot> 'd'
11:55:46 <int-e> > let fetch = flip (!!) in fetch 3 "abcde"
11:55:47 <lambdabot> 'd'
11:56:20 <ricebowl> that works too :p
11:56:59 <ricebowl> Heffalump - oh, that was stupid of me... I didn't think to use return to get the array into the ST monad, and that's what I needed to do
11:57:06 <SineTwo> just having some minor trouble understanding how it automatically moves up the array of chars
11:57:19 <ricebowl> SineTwo - that's the recursive step
11:57:29 <Cale> nice thing about Haskell being lazy is that those are pretty much equivalent :)
11:57:38 <ustenzel> SineTwo: do you understand what the pattern match (x:xs) does?
11:57:53 <SineTwo> ustenzel: : yeah, that x = head, xs = tail ?
11:58:14 <SineTwo> i..e x:xs of "haskell": x = 'h' xs = 'askell'
11:58:16 <ustenzel> sort of... so that is not your misunderstanding.  Hm.
11:58:38 <ricebowl> SineTwo - the recursion is going to execute that step n times
11:58:48 <SineTwo> yup, its going to recurce until it hits 0
11:58:49 <ricebowl> First time: x = 'h', xs = 'askell'
11:58:57 <ricebowl> Second time: x = 'a', xs = 'skell'
11:58:57 <ricebowl> etc.
11:59:10 <SineTwo> yeah, but how does the recursive step chop off the letter?
11:59:21 <ricebowl> SineTwo - because it calls fetch with xs, not x:xs
11:59:43 <ricebowl> xs is 'askell', so the second iteration matches x:xs against 'askell' and gets x='a' and xs='skell'
11:59:51 <ustenzel> SineTwo: nothing is ever modified.  the original list is still there while recursing.
11:59:57 <SineTwo> oooh
11:59:59 <SineTwo> ok
12:00:02 <SineTwo> i see :(
12:00:04 <SineTwo> :) i mean
12:00:04 <ricebowl> SineTwo - see it now?
12:00:07 <ricebowl> cool
12:00:08 <SineTwo> yeah
12:00:53 <SineTwo> thanks a lot
12:01:18 <Cale> well, the original list might be getting thrown away as you recurse, depending on whether it's ever used again
12:01:37 <Cale> but you shouldn't have to think about that too hard when thinking about how it works
12:01:52 <SineTwo> now i need to make a position function that takes finds a position of the character...
12:01:54 <Cale> You're just defining one thing in terms of the structure of another
12:01:56 <ricebowl> Cale - I expect that any reasonable implementation would not copy the entire list
12:02:00 <ricebowl> so at most one element is being thrown away
12:02:06 <ricebowl> but that's superfluous information ;)
12:02:09 <newsham> lets say I define:   data XY = XY { xval :: Int, yval :: Int }     and then  updXval x' (XY x y) = XY x' y
12:02:15 * int-e thinks lookup and zip ...
12:02:19 <Cale> what's the function in question?
12:02:23 <newsham> is there an easy way to automatically instantiate all the updXval type functions?
12:02:36 <SineTwo> well its like this
12:02:41 <Cale> newsham: you already have :)
12:02:52 <Cale> newsham: myrec { xval = newval }
12:03:01 <Cale> record update syntax
12:03:01 <SineTwo> Position function: Takes a character, and counts the position at which it is located at, and if it's not there, then it counts the whole length.
12:03:13 <newsham> cale: thanks, thats what I wanted to know
12:03:25 <SineTwo> i.e. position 'e' "haskell" gives me back 5
12:03:51 <SineTwo> i know its: position :: Char -> [Char] -> int
12:03:53 <SineTwo> *Int
12:04:04 <Cale> SineTwo: okay
12:04:07 <SineTwo> then i should have
12:04:15 <SineTwo> position 'y' (x:xs)
12:05:09 <Cale> specifically the letter y?
12:05:18 <SineTwo> hmm, no, any letter i guess
12:05:30 <SineTwo> so position _ (x:xs)?
12:05:46 <newsham> so putX x s = modify (s { xval=x } )     ?
12:05:54 <Cale> that's if you don't care what the letter is at all
12:06:06 <Cale> newsham: yep
12:06:22 <Cale> newsham: you can also include multiple updates, separating them with commas
12:06:31 <Cale> er
12:06:37 <Cale> no
12:06:43 <Cale> putX x s = s { xval=x }
12:06:53 <SineTwo> Cale: as in, i want to see if the char is the same as the one in the array
12:07:02 <Cale> list
12:07:07 <Cale> yes
12:07:08 <newsham> cale: trying to make a putX for the state monad 
12:07:12 <Cale> so you should give it a name
12:07:24 <Cale> oh
12:07:33 <Cale> newsham: okay then :)
12:07:54 <Cale> perhaps: putX x = modify (\s -> s { xval=x } )
12:08:11 <Cale> SineTwo: how about:  position y (x:xs)
12:08:16 <Cale> ?
12:08:30 <Cale> 'y' is a character literal
12:08:43 <ricebowl> no, you're going to need a separate function to do this
12:08:56 <ricebowl> position y xs = position' y xs 0
12:09:04 <ricebowl> position' :: Char -> String -> Int -> Int
12:09:18 <SineTwo> ah ok
12:09:21 <Cale> hmm, why?
12:09:36 <ricebowl> because you need to know how many characters you've dropped when you find the letter
12:09:37 <int-e> ricebowl: it's not technically needed
12:09:40 <Cale> you shouldn't really
12:09:45 <int-e> ricebowl: you're optimizing prematurely
12:09:48 <ricebowl> no I'm not
12:09:53 <int-e> yes you are.
12:09:57 <ricebowl> if you don't do it that way then it will not work on an infinite list
12:10:03 <Cale> yes you are :)
12:10:05 <ricebowl> how else would you do it?
12:10:31 <int-e> using normal recursion instead of tail recursion
12:10:34 <ricebowl> it's not an optimization. Furthermore, nobody else has suggested another solution to the problem.
12:10:38 <Cale> ricebowl: think about it some more :)
12:11:02 <Cale> ricebowl: we don't want to give it away :)
12:11:16 <ricebowl> Cale - the only other thing that I thought of is to use (length xs) - (length xs'), but this won't work on an infinite list
12:11:37 <benny> hello guys, i am going to attempt to port a physics library to haskell... i have a few questions
12:12:12 <benny> the physics library works by updating a "World"
12:12:37 <benny> so i need a haskell function, stepWorld :: World -> Double -> World
12:12:47 <newsham> ok, so now I know hwo to write a state acessor and a state updater for the monad..  is there any way to write something that instantiates a whole bunch of these things for me all at once? :)
12:12:56 <benny> that takes the world and delta-time and returns the new state of the world
12:12:58 <newsham> (other than having haskell code that spits out more haskell code)
12:13:11 <benny> problem is, i don't know how the World type should be
12:13:30 <newsham> ie all of my accessors and updaters are going to look like:  getX = gets xval   and   putX x = modify (\s -> s { xval=x } )
12:13:30 <SineTwo> ive got the following
12:13:35 <SineTwo> position :: Char -> [Char] -> Int
12:13:35 <SineTwo> position y (x:xs)
12:13:35 <SineTwo> position y [] = 1
12:13:40 <benny> it's basicly a set of rigid-bodies, but should i just use a list then?
12:13:55 <SineTwo> and then
12:14:00 <SineTwo> | y == x = 1
12:14:10 <SineTwo> correct..?
12:14:29 <Cale> that guard is on the other case, right?
12:14:39 <ricebowl> SineTwo - so far, so good. What do you want to happen when y /= x?
12:15:12 <newsham> (would be nice if there was an easier way to write  \s -> s { xv = x }     like there is an easier way to write (+ 2) )
12:15:19 <SineTwo> 	 | otherwise = 1 + position y xs
12:15:20 <newsham> err.. easy way to write (+ 2)
12:16:10 <ricebowl> SineTwo - there you go
12:16:20 <SineTwo> ricebowl:  but it doesnt work! :\
12:16:51 <ricebowl> SineTwo - well, you might have an off-by-1 if you were expecting 0-based indexing (which is what you used with your other function)
12:17:05 <Cale> SineTwo: it looked like you had two lines swapped when you pasted above
12:17:05 <ricebowl> > let position y (x:xs) = if x == y then 1 else 1 + position y xs in position 'e' "abcdefg"
12:17:07 <lambdabot> 5
12:17:36 <ricebowl> SineTwo - looks like it works to me ;)
12:17:38 <SineTwo> ricebowl: http://pastebin.com/459897
12:17:43 <SineTwo> i've entered that in hugs
12:17:56 <Cale> aha
12:18:03 <ricebowl> isn't line #3 an indentation problem?
12:18:11 <SineTwo> ERROR "temp.hs":24 - Syntax error in input (unexpected `|')
12:18:14 <ricebowl> and the guards are on the wrong case
12:18:16 <Cale> yeah, the syntax is all permuted :)
12:18:43 <int-e> well, one line is badly indented and in the wrong place
12:18:45 <Cale> http://pastebin.com/459904 -- look now
12:18:54 <SineTwo> lol
12:19:19 <ricebowl> truthfully I would omit the case where the string is empty
12:19:21 <Cale> Haskell isn't quite *that* order independent :)
12:19:28 <ricebowl> > let position y (x:xs) = if x == y then 1 else 1 + position y xs in position 'h' "abcdefg"
12:19:29 <lambdabot>  Non-exhaustive patterns in function position
12:19:35 <ricebowl> then you at least get that
12:19:45 <ricebowl> and you know that something went wrong
12:19:47 <Cale> ricebowl: it's supposed to give the length of the string if the character isn't found
12:19:52 <newsham> so no way to instantiate a number of settors/getters in some sort of macro way?
12:19:53 <ricebowl> ah, ok, I missed that
12:20:14 <SineTwo> bah
12:20:15 <Cale> newsham: without TH?
12:20:17 <SineTwo> i keep getting
12:20:18 <SineTwo> ERROR "temp.hs":26 - Syntax error in declaration (unexpected `;', possibly due to bad layout)
12:20:22 <newsham> whats TH?
12:20:28 <Cale> Template Haskell
12:20:59 <newsham> I could always write a tiny preprocessor that spit out a bunch of the things, but that seems hacky (must invoke compiler multiple times)
12:21:00 <Cale> basically, Haskell code which writes other Haskell code (in the form of syntax trees) at compile time
12:21:14 <newsham> hmm.. TH might be useful for that
12:21:23 <newsham> i'll put that on my list of things to look at
12:21:34 <Cale> I've never run into a case where there were so many that I actually cared.
12:21:48 <Cale> TH is presently hard to learn.
12:21:49 <SineTwo> why is it supposed to be in this order?
12:21:51 <SineTwo> position y [] = 1
12:21:51 <SineTwo> position y (x:xs)
12:22:03 <Cale> SineTwo: the guards apply to the nonempty case
12:22:15 <Cale> x isn't in scope in the empty list definition
12:22:20 <newsham> cale: *nod* just trying to learn more haskell stuff really (I dont need the generator right now, just wondering)
12:22:20 <ricebowl> SineTwo - you can put it in any order you like, but the guards *must* be on the non-empty list case
12:22:20 <SineTwo> ioh
12:22:23 <SineTwo> oh ok i see
12:22:25 <int-e> SineTwo: you can also put   position y [] = 1   as the last line instead.
12:22:26 <SineTwo> thanks :D
12:22:54 <newsham> I can think of cases where you might have a large state (ie. a control block for a TCP stack)
12:23:19 <SineTwo> appreciate it...
12:23:21 <SineTwo> works now
12:23:26 <SineTwo> it's been driving me nuts for ages
12:23:27 <Cale> SineTwo: great :)
12:23:55 <Cale> newsham: yeah, I suppose there are some things with lots of fiddly small pieces of data like that.
12:24:43 <newsham> not that I intend to write a haskell tcp stack :)
12:25:07 <newsham> http://lava.net/~newsham/x/machine/gcdstatemonad.lhs.txt   here's what I have so far (partially adopted from "monad's for the working haskell programmer")
12:25:09 <newsham> thoughts?
12:26:39 <Cale> looks about right :)
12:28:19 <newsham> anything you'd do different or recommend?
12:28:58 <newsham> btw, I get an error in hugs when I import the State module (works fine in ghci though).  Any ideas why?
12:29:03 <newsham> ERROR "/usr/local/lib/hugs/packages/mtl/Control/Monad/Reader.hs":46 - Haskell 98 does not support dependent parameters
12:29:27 <Cale> newsham: -98 ?
12:29:54 <newsham> with -98:  ERROR "/usr/local/lib/hugs/libraries/Hugs/Base.hs":56 - Type error in application
12:30:08 <Cale> um, that's broken :)
12:30:19 <newsham> wait, that might be my fault.. I think I edited Base.hs for kicks when I first was learning (:e went there :)
12:30:21 <Cale> mine certainly doesn't do that
12:30:27 <Cale> ah
12:30:31 <Cale> hehe
12:30:52 <MacVince> Is there a function to convert a numerical char to an integer?  I read about digitToInt, but it does not seem to be available in GHC
12:31:06 <newsham> yah, works with -98
12:31:26 <newsham> so why do they have libs that dont work in the standard invocation?
12:31:26 <int-e> @index digitToInt
12:31:26 <lambdabot> Data.Char
12:31:41 <int-e> MacVince: so import Data.Char :)
12:31:41 <MacVince> Char.digitToInt?
12:31:48 <MacVince> will try
12:31:49 <MacVince> Thanks
12:32:29 <Cale> newsham: because those libs require features that don't exist in Haskell 98
12:32:54 <Cale> (in particular, functional dependencies)
12:33:14 <Cale> as well as multiparameter typeclasses in the first place
12:33:48 <newsham> so do I generally want to use -98 instead of +98?
12:33:58 <Cale> well, probably
12:34:13 <Cale> in ghc  -fglasgow-exts is pretty popular
12:34:19 <Cale> -98 is similar
12:34:31 <Heffalump> hugs doesn't make any difference between use of extensions in libraries you use and use of extensions in your own program
12:34:59 <Heffalump> ghc does if the library is compiled, IIRC (which obviously isn't possible for hugs)
12:38:21 <MacVince> What's the remainder operator in Haskell?
12:38:29 <newsham> mod ?
12:39:01 <newsham> > 235 `mod` 7
12:39:02 <lambdabot> 4
12:39:09 <rg> what place would you recommend for starting to learn about combinators?
12:39:24 <rg> i keep seeing the term but i don't know what exactly does it mean
12:39:31 <Heffalump> it's a bit fluffy
12:39:35 <Heffalump> (like OOP ;-)
12:39:50 <Heffalump> I think the best way is to learn by example.
12:39:51 <rg> (for example in "how to write a financial contract")
12:40:00 <Heffalump> right, so that's the second example I was going to give.
12:40:07 <rg> :)
12:40:07 <Heffalump> The first example is parser combinators, like Parsec etc.
12:40:36 <rg> ok. examples are good. but i'd like to see a _definition_ of the term
12:40:47 <Heffalump> A combinator library is one which exposes building blocks to the user.
12:40:52 <Heffalump> As I said, it's a bit fluffy.
12:41:05 <Heffalump> Sorry, building blocks and structures for combining those blocks.
12:41:17 <Heffalump> (this is my definition, not necessarily a generally accepted one)
12:41:21 <rg> when do you say something is a combinator, and when do you say it is merely a function?
12:41:35 <Heffalump> when you feel like it :-)
12:41:50 <rg> the problem is i don't feel anything yet :)
12:41:55 <Heffalump> combinators are often fucntions with quite high orders
12:42:18 <Heffalump> e.g. with parser combinators, a base parser is a function itself, and a combinator like seq takes two parsers and gives you another one,
12:43:09 <Heffalump> I think it makes more sense to talk about combinator libraries, than about combinators per se.
12:43:42 <Heffalump> And I think the thing that distinguishes a combinator library from other kinds is that a combinator library gives you ways of combining other things from the library.
12:44:18 <rg> so if i want to get a geeling of what a combinator library is then i should use one. is that your advice?
12:44:26 <rg> geeling -> feeling
12:44:41 <Heffalump> but that's still not very good, because a numeric library gives you numbers and ways of combining numbers, but I wouldn't really call that a combinator library.
12:44:44 <rg> (i have a borrowed MS keyboard :p)
12:44:51 <Heffalump> Well, or just look at different examples of what other people call combinator libraries.
12:45:25 <rg> fair enough. i'll do that
12:45:28 <rg> thanks
12:47:38 <newsham> would it be possible to have a state monad that encapsulates a PRNG, that returns an infinite number of random values, so that you can use takeWhile on it, and each invocation of takeWhile grabs new numbers?
12:48:02 <Heffalump> rg: pretty printing, parsing and financial combinators are the three examples that spring to mind for me
12:48:06 <newsham> for example, what I do in http://www.lava.net/~newsham/x/machine/e.lhs.txt in waitTimes   but using a state monad to hide the state
12:48:11 <Heffalump> newsham: yes
12:48:50 <newsham> I'm having a problem figuring it out.
12:49:06 <Cale> It's more along the lines that you're combining things which you could consider programs in their own right
12:49:07 <Heffalump> well, you'll need to make your own takeWhile like thing
12:49:10 <rg> Heffalump: yep, i remember seeing a paper about preety print (by wadler?). i'll read that too
12:49:16 <Heffalump> rg: yeah, that's it
12:49:30 <newsham> heffalump: thats what I was afraid of..  so its not going to make my e.lhs simpler and shorter then.
12:49:44 <Heffalump> newsham: probably not.
12:49:59 <newsham> (i would basically write a takewhile that calls get repeatedly until the predicate is true)
12:50:40 <Cale> A pure combinator is actually just a function which produces nothing other than some application of its arguments to one another
12:51:03 <newsham> ok, i think thats enough for state monads for today.
12:52:29 <Cale> (in the sense of function application)
12:53:07 <Cale> id and flip being two simple examples
12:53:13 <Heffalump> @type Control.Monad.takeWhileM
12:53:14 <lambdabot> Not in scope: `Control.Monad.takeWhileM'
12:53:17 <Heffalump> bah :-)
12:53:41 <Heffalump> newsham: but you could in principle write such a thing.
12:54:03 <Heffalump> it'd have type (a -> m Bool) -> [m a] -> m [a] probably.
12:54:16 <Heffalump> and would apply to any monad
12:54:32 <Heffalump> and then you'd do something like takeWhile (...) (repeat get)
12:54:37 <Heffalump> IM takeWhileM
12:55:17 <SineTwo> does anyone know why this returns 1 when i type in: position 'h' "haskell"? http://pastebin.com/459960
12:56:26 <Heffalump> are you sure it does?
12:56:27 <SineTwo> it should start counting from 0 in that sense.. i..e position 'e' "haskell" should return 4
12:56:35 <SineTwo> Heffalump: that's what i thought :\
12:56:46 <Heffalump> your definition is horribly wrong, but 'h' should have worked.
12:56:55 <rg> - -> +
12:57:07 <Heffalump> (position y [] should be an error, cos it wasn't found, and you want 1+position y xs, not 1-position y xs)
12:57:26 <SineTwo> oh sorry
12:57:31 <newsham> X> position 'h' "haskell"
12:57:31 <newsham> 0
12:57:31 <newsham> X> position 'a' "haskell"
12:57:31 <newsham> 1
12:57:31 <SineTwo> that was the wrong pasted one
12:57:46 <SineTwo> i.e. it should be 1+position y xs
12:57:55 <Cale> Heffalump: not by his earlier description
12:58:05 <Heffalump> ah, I wasn't following that
12:58:09 <SineTwo> just something i tried to fiddle with :P
12:58:17 <SineTwo> newsham: yes exactly
12:58:18 <Cale> It should give the length of the string if the character isn't found
12:58:29 <SineTwo> it gives me the length of the string if the char is not found
12:58:47 <SineTwo> but if i do: position 'h' "haskell" it returns 1, not 0
12:58:52 <Heffalump> ah, ok.
12:58:54 <newsham> sine: seems to be working here (with +)
12:59:05 <Cale> SineTwo: that's because you told it to :)
12:59:25 <SineTwo> it works now
12:59:26 <SineTwo> nevemrind
12:59:28 <SineTwo> friggin hugs
12:59:40 <Cale> SineTwo: just change the - to a + in the pasted version
12:59:59 <SineTwo> Cale: no no, that was the wrong pasted version, but emacs kept screwing up the saved version with hugs in the shell within emacs
13:00:02 <SineTwo> :\ sorry :(
13:00:04 <SineTwo> :)
13:00:24 <Cale> (your original version used 1-based indexes)
13:00:24 <newsham> maybe use vi and :e?  ;-)
13:01:17 <Cale> you could use emacs with :e just as well
13:01:30 <newsham> sure, but you'd have to quite emacs and start it up again
13:01:40 <newsham> which seems to not be a thing emacs users are willing to do
13:02:02 <Cale> though I like to keep an editor window open alongside my interactive environment, and simply reload the file when I add something
13:02:27 <Cale> (whether or not I'm using emacs or vim)
13:02:34 <newsham> *nod* there's no undo across :wq and :e 
13:06:15 <benny> what is Ghc.Real.Real?
13:10:52 <newsham> these monad things arent easy.  I've been programming for 2/3rds of my life and its taking a lot of persistence and patience to get a grasp on them
13:11:47 <jethr0> newsham, the easiest is to look at some examples, and kick ideas back here in the channel
13:12:05 <jethr0> stuff like this will probably spark your interest:
13:12:08 <newsham> thats what I'm doing.  playing with examples.
13:12:15 <jethr0> > sequence [[1,2],[2,3],[4,5]]
13:12:16 <lambdabot> [[1,2,4],[1,2,5],[1,3,4],[1,3,5],[2,2,4],[2,2,5],[2,3,4],[2,3,5]]
13:12:19 <jethr0> :)
13:13:00 <newsham> thats nice and all but list comprehension does that without me grasping esoteric algebras :)
13:13:00 <jethr0> > [1,2] >>= \x -> [3,4] >>= \y -> return [x,y]
13:13:02 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
13:13:22 <jethr0> newsham, sure, but it let me want to understand how the list monad works
13:13:49 <_Codex> yes, monads are difficult, even after long time doing haskell. (easy to use, but difficult to understand deeply)
13:14:00 <newsham> > liftM2 (+) [1,2,3] [4,5,6]
13:14:01 <lambdabot> [5,6,7,6,7,8,7,8,9]
13:14:07 <newsham> played with it a little already
13:14:57 <newsham> btw. "a gentle introduction"'s chapter on monads was one of the worst monad intros i've read so far. :\
13:15:05 <newsham> maybe i'll get it after I finish reading the rest of the intros
13:15:23 <newsham> (otherwise I generally liked the gentle introduction)
13:15:38 <jethr0> > [1..10] >>= \x -> guard (even x) >> return x
13:15:39 <lambdabot> [2,4,6,8,10]
13:15:51 <reddi> hi, why isnt it possible to write: testfkt :: (a -> b -> c) -> Int -> Int -> Int
13:15:52 <reddi> testfkt op a b = op a b   
13:15:55 <_Codex> good monad intro is the "parser combinators" -thing. Only that will make you understand how useful monads can be.
13:16:09 <jethr0> newsham, for me, none of the tutorials did it! they all did a poor job of getting me up to speed
13:16:24 <jethr0> might be me, but then again others have "complained" too :P
13:16:25 <_Codex> toy examples are not showing what monads are for.
13:16:57 <newsham> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm  is so far one of my favorites, but i have had to play with the code alot (when I read it straight through I got lost several times)
13:17:14 <jethr0> _codex, the problem is less the examples, but rather telling the reader _why he should care_ and what benefits he'll get from monads
13:17:18 <jyp> reddi, because a, b and c are quantified at the outermost scope
13:17:34 <reddi> jyp and how can i do better?
13:17:42 <jyp> -- The Art of Answering without Helping :)
13:17:50 <_Codex> jethro: exactly.
13:18:35 <jethr0> after understanding monads, the tutorials are all great sources of information and i come to understand their humor
13:19:15 <jethr0> but reading them initially, i felt really stupid! and all that just because i didn't realize that monads where about abstractions of control :(
13:19:31 <newsham> well i always feel stupid, but i dont have a problem with that.
13:19:38 <newsham> socrates seemed to think feeling stupid was a good thing
13:19:49 <jethr0> newsham, nobody said i've stopped :P
13:20:03 <jyp> reddi: depends on waht you want to do
13:20:23 <reddi> i want to apply the function (a->b->c) to the other elements
13:21:17 <jethr0> > let testfkt op a b = op a b in testfkt (+) 3 4
13:21:18 <lambdabot> 7
13:21:41 <jyp> You can't because "testfkt :: (a -> b -> c) -> Int -> Int -> Int" says that the 1st argument can be any function
13:21:49 <ustenzel> reddi: why do you think it should be possible?  "c" is not "Int".
13:21:50 <_Codex> http://www.cs.nott.ac.uk/~gmh//bib.html#monparsing  <-- parser combinators paper is useful thing to read.
13:23:55 <jethr0> > let {testfkt :: (a -> b -> c) -> a -> b -> c; testfkt op a b = op a b} in testfkt (+) 3 4
13:23:56 <lambdabot> 7
13:24:42 <jethr0>  > let {testfkt :: (a -> b -> c) -> a -> b -> c; testfkt op a b = op a b} in (testfkt (+) 3 4, testfkt (++) "hello" "world")
13:24:50 <jethr0> > let {testfkt :: (a -> b -> c) -> a -> b -> c; testfkt op a b = op a b} in (testfkt (+) 3 4, testfkt (++) "hello" "world")
13:24:51 <lambdabot> (7,"helloworld")
13:25:18 <reddi> hm.... the problem is that i have a self defined type
13:25:32 <reddi> moment
13:26:22 * jethr0 doesn't have any idea why the above work, but *what the heck*... wouldn't have thought that the type system would be this forgiving :)
13:26:32 <reddi> http://pastebin.com/460017
13:27:03 <jethr0> reddi, the actual data type used plays no role in this!
13:27:51 <reddi> i want (better said: HAVE) to write a programm which has the signature zipTF
13:27:51 <reddi> :: (a -> b -> c) -> Tree a -> Tree b -> Tree c.
13:28:10 <reddi> what do i have to write additionaly that it works?
13:28:25 <jyp> aha... that's quite different :)
13:28:57 <jyp> you need to recurse on the both trees in parallel
13:29:30 <reddi> where is the difference between my "testfct" and that?
13:29:30 <jethr0> reddi, are "Tree a" and "Tree b" congruent? i.e. have the same form, number of nodes, ...?
13:29:52 <reddi> jethr0: no....
13:30:03 <reddi> if one node is zero then the result shall be zero#
13:30:03 <jyp> reddi: well type variables appear in the result as well
13:30:05 <jethr0> well, how do you suppose to apply the function to the tree nodes then??
13:30:17 <jethr0> ok
13:30:36 <jethr0> reddi, i would flatten the trees and work on the resulting lists...
13:31:00 <jethr0> maybe with "zipWith func (flatten TreeA) (flatten TreeB)"
13:31:20 <jethr0> nah, wait, that doesn't solve your "Empty" problem directly...
13:31:22 <reddi> aaaaaaaaaaaaa
13:31:23 <reddi> i see
13:31:28 <jyp> reddi: just find the source code of zipWith somewhere and generalize for trees
13:31:32 <reddi> the a, b and c appears in the result
13:31:35 <reddi> that is the difference
13:31:43 <jyp> yah :)
13:31:51 <jethr0> jyp, but how do you propose to iterate over both trees simulataneously?
13:32:11 <reddi> so idont have to use something like polymorphy (i dont know how exactly to write)
13:32:20 <jethr0> reddi, your problem seems rather obscure? what do you need this for, if i may ask?
13:32:21 <reddi> i can simply write a normal haskell programm (as i did it the weeks before)
13:32:36 <newsham> jethr0: how do you iterate over two lists simultaneously?
13:32:45 <reddi> jethr0: i need it fore a lecture ;-)
13:32:53 <newsham> you take the head, and move to the tail of both, while both have tails
13:32:55 <reddi> and the week before xmas is VERY stressy
13:32:55 <jethr0> newsham, zip
13:33:02 <reddi> and it is the last week ;-(
13:33:06 <reddi> so i asked here ;-)
13:33:26 <jethr0> newsham, but lists have automatically the same shape. binary trees of different form, might be more complex to iterate
13:33:39 <jethr0> although stopping at empty branches might reduce it to your algorithm!
13:33:40 <newsham> jethr0: no they dont, some lists terminate before others.  thats a difference in shape.
13:33:43 <newsham> you can do the same thing with branches.
13:33:49 <newsham> you branch left if both have left branches
13:33:50 <jethr0> true
13:33:54 <newsham> you branch right if both have right branches
13:34:12 <newsham> resulting in a trimmed list or trimmed tree
13:34:49 <jethr0> yesyes, i didn't think straight a few moments ago, my bad :P
13:34:53 <newsham> (now try graphs where the representations of identical shapes can be different ;-)
13:34:56 <reddi> but it still says:  Inferred type
13:34:56 <reddi>  is not general enough 
13:35:26 <SineTwo> hmm, have to take a string of chars, and encode them into numbers, returning a=0,b=1 etc... so: encode "haskell" returns [7,0,18,10,4,11,11]
13:35:43 <newsham> > fromEnum 'a'
13:35:44 <lambdabot> 97
13:35:53 <jethr0> > Char.ord 'a'
13:35:54 <lambdabot> 97
13:36:04 <newsham> > map fromEnum "haskell"
13:36:05 <lambdabot> [104,97,115,107,101,108,108]
13:36:31 <SineTwo> hm i see
13:36:37 <jethr0> > "haskell" >>= return . Char.ord
13:36:38 <SineTwo> i could just do that -97 then?
13:36:38 <lambdabot> [104,97,115,107,101,108,108]
13:36:46 <reddi> http://pastebin.com/460035
13:36:51 <reddi> i still get the same error
13:37:11 <ustenzel> reddi: stop and think for a moment.  you're calling a function with two Ints as arguments and expect an Int as result.  What's the function's type?  Certainly not (a -> b -> c).
13:37:14 <jethr0> > map ((- (fromEnum 'a') . fromEnum) "haskell"
13:37:15 <lambdabot>  parse error on input `}'
13:37:29 <jethr0> > map ((subtract (fromEnum 'a')) . fromEnum) "haskell"
13:37:30 <lambdabot> [7,0,18,10,4,11,11]
13:37:42 <newsham> reddi: dont you want something like:   zipTF op (Left x) (Left y) = Left (op x y)   ?
13:37:49 <jyp> reddi: hint: here's the first equation: zipTF f Nil _ = Nil 
13:38:06 <jyp> the rest should be straightforward :)
13:38:10 <reddi> jyp: i dont need the zip function anymore ;-)
13:38:16 <SineTwo> jethr0: oh problem is, i have to use the following function:
13:38:28 <reddi> i already have it, i only have troubles with the (a->b->c)
13:38:48 <reddi> i think the rest shall be no problem (i hope so)
13:39:01 <jethr0> > map (fromEnum . (subtract 'a')) "haskell"
13:39:02 <lambdabot>  add an instance declaration for (Num Char)
13:39:02 <SineTwo> jethr0: http://pastebin.com/460038
13:39:07 <jyp> reddi: what I wrote applies to "the (a->b->c)"
13:39:59 <jethr0> sinetwo, using that function makes no sense in haskell...
13:41:01 <SineTwo> well, it does the following: position 'e' "haskell" returns 4
13:41:03 <newsham> redi: your paste code is taking in a Tree b and returning a Tree c?
13:41:25 <SineTwo> hence position 'a' "abc" gives 0, position 'b' "abc" gives 1 etc
13:41:29 <jethr0> fun ls = [fromEnum (position i ls) | i <- [0..length ls-1]]
13:41:30 <SineTwo> so i think there's something in there
13:41:34 <jethr0> but that's b*tt ugly
13:41:57 <jethr0> ah, sorry, i got a better idea
13:42:32 <jethr0> map (\x -> position x ['a'..'z']) "haskell"
13:42:39 <xerox> yo.
13:42:47 <jethr0> hi xerox
13:43:24 <xerox> @index position
13:43:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors, Graphics.Rendering.OpenGL.GL,
13:43:25 <lambdabot> Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:43:47 <jethr0> xerox, it's his own function
13:43:51 <jethr0> sth like findIndex
13:43:52 <xerox> If you flip the arguments of position you have the more stylish > map (position ['a'..'z']) "haskell"
13:43:53 <newsham> map (flip position ['a'..'z']) ?
13:44:03 <jethr0> map (`position` ['a'..'z']) "haskell"
13:44:09 <xerox> Right-o.
13:44:10 <jethr0> even more so :)
13:44:25 <newsham> ahh, neat trick with the back ticks.  i shall have to remember that
13:44:42 <jethr0> well, question is whether it _really_ makes it more readable...
13:44:58 <xerox> ..it does :-)
13:45:03 <newsham> if you know (`foo` bar)  why not
13:45:06 <newsham> looks pretty clear
13:45:11 <newsham> I got it without having seen it before
13:46:17 <SineTwo> map (\x -> position x ['a'..'z']) "haskell" gives me [1,0,0,0,0,1,1]
13:46:50 <jethr0> try "position 'a' ['a'..'z']"
13:47:00 <jethr0> try "position 's' ['a'..'z']"
13:47:07 <jethr0> *damn*
13:47:56 <SineTwo> maybe
13:47:57 <ustenzel> SineTwo: I bet my left knee that you're running the version of 'position' with the - where the + should be.
13:48:08 <SineTwo> ['a','b'..'z']
13:48:12 <newsham> what ust said.
13:48:15 <SineTwo> ustenzel: if i am, you can shoot me
13:48:21 <SineTwo> and be prepared to!
13:48:24 <newsham> your old version returned zeros and ones often :)
13:48:26 <xerox> @index indexOf
13:48:27 <lambdabot> bzzt
13:48:29 <newsham> with + it worked properly
13:48:30 <SineTwo> OH FFS!!!!
13:48:36 * SineTwo just shoots himself
13:48:38 <jethr0> sinetwo, works like a charm for me with your pasted code!
13:48:41 <xerox> @index findIndex
13:48:41 <lambdabot> Data.List, Data.Map
13:48:43 <SineTwo> and deletes temp.hs
13:48:50 <xerox> @type Data.List.findIndex
13:48:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
13:49:02 <newsham> can someone throw an operator exception?
13:49:28 * jyp throws an operator exception!
13:50:22 <xerox> > let position x = (fromJust .) . findIndex . (==) in position 'x' ['a'..'z']
13:50:23 <lambdabot>  add an instance declaration for (Show ([[Char]] -> Int))
13:50:30 <xerox> Got it wrong :-)
13:50:37 <jyp> An operator exception falls to the ground and takes 2d6+1 damage.
13:50:44 <xerox> @pl \x xs = fromJust (findIndex (==x) xs)
13:50:45 <lambdabot> (line 1, column 7):
13:50:45 <lambdabot> unexpected "="
13:50:45 <lambdabot> expecting pattern or "->"
13:50:51 <xerox> @pl \x xs -> fromJust (findIndex (==x) xs)
13:50:51 <lambdabot> (fromJust .) . findIndex . (==)
13:50:55 <xerox> Sorry for the flood.
13:51:00 <newsham> this tutorial defines a state monad with  s->Maybe(s,a)   is there an existing Control.Monad.* definition that does this?
13:51:00 <xerox> HM, so it was right.
13:51:09 <jethr0> xerox, not using x!
13:51:13 <xerox> DANG.
13:51:20 <xerox> > let position = (fromJust .) . findIndex . (==) in position 'x' ['a'..'z']
13:51:21 <lambdabot> 23
13:52:41 <SineTwo> (\x -> position x ['a'..'z']) "haskell" <- so what does that od really?
13:53:03 <ustenzel> newsham: StateT s Maybe
13:53:21 <newsham> ust: thanks, just stumbled on that.
13:53:37 <jethr0> sinetwo, which part are you wondering about?
13:53:47 <xerox> > let position = (fromJust .) . findIndex . (==) in map (`position` ['a'..'z']) "haskell"
13:53:48 <lambdabot> [7,0,18,10,4,11,11]
13:54:01 <SineTwo> jethr0: the whole thing, hehe, \x -> position
13:54:03 <jethr0> yesyesyes, xerox...
13:54:13 <pengo> argh
13:54:16 <xerox> jethr0: answering SineTwo
13:54:24 <newsham> the example also has a MonadPlus definition (mplus is used for backgtracking)
13:54:32 <jethr0> ah, "fun = \x -> x + 2" is the same as "fun x = x + 2"
13:54:35 <newsham> do I have to add that to StateT myself?  or does it come with that?
13:54:53 <jethr0> "\" is a poor representation of the greek "lambda" and is used for anonymous functions
13:55:06 <int-e> newsham: Maybe is a monad and StateT takes a monad. newtype StateT s m a  = S (s -> m (a,s)) <-- the m here.
13:55:22 <newsham> *nod* I got that part.
13:55:30 <jethr0> alternatively you could write "let fun x = position x ['a'..'z'] in map fun "haskell""
13:55:31 <ustenzel> newsham: it comes with Maybe, StateT uses that
13:55:32 <twb> Grr,
13:55:34 <jethr0> xerox, ??
13:55:49 <SineTwo> ah ok i see jethr0 
13:55:52 <twb> I'm having trouble unifying IO types again, in order to do unit testing.
13:55:59 <newsham> so StateT s Maybe a    already has the proper "mplus" for backtracking?
13:56:10 <SineTwo> jethr0: if i were to write a function encode
13:56:15 <jethr0> yes
13:56:16 <SineTwo> it would look like:
13:56:32 <SineTwo> encode :: [Char] -> [Int]
13:56:38 <newsham> (I'm trying to play with http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm "Exceptions, exception handling, and backtracking" but using the existing libs instead of writing the monads out)
13:57:26 <jethr0> sinetwo, ??
13:57:54 <jethr0> ah, same problem... yes, that seems like an appropriate type
13:58:05 <SineTwo> encode (x); map (\x -> position x ['a'..'z'])
13:58:29 <jethr0> what's that?
13:58:32 <int-e> newsham: you'll need to provide your own MonadPlus instance for Maybe; StateT will use it and provide its own MonadPlus instance based on that
13:58:56 <int-e> newsham: at least I can't find a ready-to-use MonadPlus instance for Maybe
13:59:40 <jethr0> sinetwo, how do you write a function that takes an integer and returns it incremented by one?
14:00:18 <newsham> so there's no existing state monad designed for backtrackign in the libs 
14:00:29 <wilx> IIRC Data.Maybe has MonadPlus instance.
14:00:56 <SineTwo> jethr0: emr... increment :: Int -> Int ?
14:00:58 <int-e> > let encode x = Data.Char.ord x - Data.Char.ord 'a' in encode 'm'
14:00:59 <lambdabot> 12
14:01:03 <sieni> (1+)?
14:01:07 <jethr0> wilx, that's what the docu says
14:01:10 <int-e> wilx: but where?
14:01:13 <jethr0> sieni, not you!
14:01:29 <jethr0> sinetwo, that's the type declaration... but how would the function declaration look like?
14:01:35 <wilx> Yeah, that is what the doc says.
14:01:41 <wilx> Is it not true?
14:02:06 <SineTwo> jethr0: hmm... increment x; x = x+1?
14:02:09 <xerox> Are there other ords?
14:02:10 <int-e> ah. found it. it's in Control.Monad ...
14:02:10 <xerox> @type ord
14:02:11 <lambdabot> Not in scope: `ord'
14:02:14 <xerox> Dang.
14:02:17 <xerox> > ord 'a'
14:02:18 <lambdabot> 97
14:02:19 <int-e> (where else)
14:02:26 <jethr0> sinetwo, that's not haskell...
14:02:30 <int-e> @type Data.Char.ord
14:02:30 <sieni> jethr0: sorry 
14:02:31 <lambdabot> Char -> Int
14:02:38 <jethr0> siene, no prob
14:02:43 <ustenzel> newsham: Maybe and [] do backtracking
14:03:00 <SineTwo> increment n = n + 1?
14:03:04 <jethr0> yup
14:03:08 <int-e> newsham: ok, the MonadPlus instance for Maybe in Control.Monad does what you want - it uses the first alternative if it succeeds, otherwise the second one
14:03:17 <jethr0> so, how does "encode" look like?
14:03:35 <SineTwo> encode [Char] -> [Int]
14:03:37 <SineTwo> ::
14:03:51 <jethr0> yes...
14:04:27 <SineTwo> encode [whatverhere/which i dunno how to wildcard] = map (\x -> position x ['a'..'z']) [whatverhere/which i dunno how to wildcard] 
14:04:36 <newsham> this example (http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm, 8 queens at "Exceptions, exception handilng, and backtracking")  does both state and maybe
14:04:48 <SineTwo> i think?
14:05:07 <jethr0> sinetwo, you don't have to wildcard. you just have to say "here comes an argument which i will call "foo""
14:05:19 <SineTwo> oh ok
14:05:26 <jethr0> so?
14:05:53 <SineTwo> encode "foo" = map (\x -> position x ['a'..'z']) "foo"
14:06:06 <SineTwo> no that would just encode "foo"
14:06:07 <SineTwo> hmm
14:06:17 <jethr0> yes, but without the quotes
14:06:24 <SineTwo> oh
14:06:30 <SineTwo> so it uses patternmatching for that aswell?
14:06:35 <int-e> yes
14:06:51 <SineTwo> oki, cheers
14:06:53 <jethr0> well, not really. in C you also have named arguments...
14:07:09 <jethr0> int* encode(char *foo);
14:07:18 <int-e> you could also write  encode = map (\x -> position x ['a'..'z'])
14:07:32 <jethr0> int-e, that might be getting a bit ahead of ourselves...
14:07:55 <SineTwo> hehe, supernoob in the house :P
14:07:58 <jethr0> :P
14:07:58 <int-e> jethr0: but in C, the foo isn't a pattern
14:08:27 <jethr0> int-e, the function is "encode foo = ... foo"
14:08:27 <xerox> SineTwo: it's just that you can write any f x y z .. = g x y z .. as f = g
14:08:34 <jethr0> there's no pattern matching involved in there
14:08:40 <jethr0> at least no explicit PM
14:08:57 <int-e> jethr0: 'foo' is a pattern - it matches anything and binds it to foo
14:09:18 <jethr0> yes, but that takes the "pattern" out of PM, doesn't it :)
14:09:33 <jethr0> but ok, i stand corrected
14:09:38 <reddi> i have solved the first example but i have troubles with the second ;-(
14:09:56 <int-e> jethr0: well, it's a base case for building patterns recursively.
14:10:01 <jethr0> sinetwo, didn't want to be rude, it's just that you should have done more work yourself on those functions (IMHO)
14:10:02 <reddi> i want something like: http://pastebin.com/460095
14:10:23 <reddi> but i am not familar with the (\x->y)
14:10:31 <reddi> Prelude> (\(x,y)->(y,x)) (4,65)
14:10:31 <reddi> (65,4)  
14:11:27 <SineTwo> jethr0: i totally agree, but i didnt quite understand how \x etc worked
14:11:44 <SineTwo> but i knew i had to assign 'a'..'z' using position
14:11:47 <jethr0> no problem, glad to help
14:11:51 <xerox> > let swap = uncurry (snd &&& fst) in swap (0,1)
14:11:51 <lambdabot>   Expecting a function type, but found `t_a1qQ'
14:11:51 <lambdabot>   Expected type: (a, b) -> b1 -> c
14:11:51 <lambdabot>   Inferred type: (a, b) -> (b, a)
14:11:55 <xerox> Ops, sorry
14:12:00 <xerox> > let swap = uncurry (snd *** fst) in swap (0,1)
14:12:00 <lambdabot>   Expecting a function type, but found `t_a1qU'
14:12:00 <lambdabot>   Expected type: ((a, b), (a1, b1)) -> b2 -> c
14:12:00 <lambdabot>   Inferred type: ((a, b), (a1, b1)) -> (b, a1)
14:12:01 <SineTwo> i just didnt know how, which is most my trouble in programming, hehe
14:12:05 <xerox> OK, I'll shut up.
14:12:12 <SineTwo> but i really do appreciate it
14:12:35 <jethr0> but you could write a helper function like i showed earlier, which would make the "lambda", i.e. "\x ->" unnecessary
14:12:55 <jethr0> xerox, that's like worst use of arrows _ever_ :P
14:13:01 <xerox> hmpf.
14:13:02 <int-e> xerox: why uncurry?
14:13:10 <jethr0> @type (***)
14:13:11 <lambdabot> Not in scope: `***'
14:13:17 <jethr0> @type (Control.Arrow.***)
14:13:18 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
14:13:18 <lambdabot> (Control.Arrow.Arrow a) =>
14:13:18 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
14:13:31 <int-e> > (snd &&& fst) (0,1)
14:13:32 <lambdabot> (1,0)
14:13:39 <jethr0> hehe
14:13:41 <reddi> why is there an error
14:13:42 <xerox> Yeah.
14:13:56 <reddi> whats the reason that i cannot use the function itself on the right side of the =
14:14:42 <int-e> reddi: your left side should be unzipTF f (Node (x,y) l r) = ...
14:14:51 <int-e> reddi: and then you can use f on the right side.
14:15:20 <int-e> reddi: you can't pattern match functions; but you don't have to do that either.
14:16:31 <reddi> ok fine and how do i say WHAT to turn?
14:17:14 <reddi> http://pastebin.com/460103
14:17:48 <int-e> reddi: well, you want to apply f to (x,y) I think and use both result ... right?
14:18:41 <reddi> that is what i want to have 4 example: http://pastebin.com/460105
14:19:11 <reddi> i want to use unzip but i want to tell which is the first one ;-)
14:20:10 <int-e> well. applying f to the pair of trees is obviously wrong
14:20:37 <reddi> i have to apply it to the content
14:21:05 <int-e> yes. you actually already do that for l an r ... you can handle (x,y) very similarily
14:21:17 <jethr0> xerox in da house
14:21:21 <jethr0> done any more work with arrows?
14:21:35 <xerox> jethr0: nope!  I'd love to, though.
14:21:53 <jethr0> hmm, i'm just reading "the yampa arcade" and it all looks pretty neat to me!
14:22:18 <jethr0> *way to go* modular, interactive, GUI components!
14:22:43 <xerox> I had no time, hmpf.
14:23:00 <jethr0> yah, time's a b*tch
14:23:02 <jethr0> :)
14:23:42 <xerox> School is!
14:23:54 <reddi> arg, i am to stupid
14:24:04 <jethr0> ya, but school usually leaves time to do stuff, right?
14:24:11 <newsham> blah, I'm having problems with this:  http://lava.net/~newsham/x/threequeens.lhs.txt
14:24:21 <newsham> anyone in a helping mood?
14:24:36 <jethr0> newsham, how can i be of service?
14:24:53 <newsham> I'm getting lots of compiler errors and I'm a bit lost
14:25:04 <jethr0> ah no, not the StateT stuff. sorry, way beyond me :(
14:25:17 <xerox> jethr0: morning and other silent periods of time (like night) are way more fruitful for me
14:25:29 <int-e> reddi: http://pastebin.com/460111
14:25:46 <jethr0> xerox, so you _do_ have time ;)
14:25:46 <xerox> jethr0: doing things like 'morning school, lunch, homeworks, play' makes me a dull boy.  I mean, it's boring.
14:25:50 <reddi> can u give me a hint ? http://pastebin.com/460112 i know that it CANNOT work but i dont know how to get itwork
14:26:17 <jethr0> "play" makes you a dull boy?
14:26:26 <newsham> head hurts :)
14:26:31 <jethr0> man those must be pretty dumb games you kids play these days...
14:26:46 <reddi> i want to apply the f to x and y
14:27:25 <jethr0> newsham, that code is evil (until i understand it, maybe)
14:27:28 <xerox> jethr0: I mean that I can't code in the afternoon because it's "the right time to do it"; i.e. the others decided it for me.
14:27:30 <int-e> reddi: or like this: http://pastebin.com/460116
14:27:35 <reddi> what about f fst (x,y)
14:28:05 <jethr0> xerox, neither can i! i've done some pretty good programming at _really_ weird night/morning hours
14:28:09 <int-e> f takes a pair and returns a pair - fst (f (x,y)) would work
14:29:10 <newsham> jethro: the idea is that there's this State object that can fail (Maybe), and an mplus that runs each alteranative until one doesnt fail.
14:29:14 <newsham> to implement backtracking
14:29:48 <jethr0> newsham, i got that much... but isn't this a beautiful application of "bounded continuations" ala "ContT"?
14:29:55 <ustenzel> newsham: what's the compiler's complaint?
14:30:31 <newsham> ustenzel: what isnt a complaint?  :)  lots of em.  i think partly because my put methods arent returning Maybe's
14:30:34 <xerox> jethr0: and it's the same for other activities to me too.  Say, reading.  I read the most interesting pages in "unusual" hours.  I wonder how much of it it's just psychology.
14:30:42 <newsham> I think another thing is I have to define mplus still
14:30:58 <ustenzel> newsham: I'm just looking at it, not compiling it...
14:31:36 <jethr0> xerox, i tend to be a little lethargic. but if i have to do sth important, like exams, i can't stop myself exploring new languages/paradigms...
14:32:01 <newsham> ERROR "threequeens.lhs":30 - Type error in explicitly typed binding
14:32:01 <newsham> *** Term           : putCols
14:32:01 <newsham> *** Type           : Int -> a ()
14:32:01 <newsham> *** Does not match : StateT QState Maybe ()
14:32:08 <xerox> jethr0: exam-related things, or (like me), doing your best in different things when you have other deadlines?
14:32:21 <newsham> thats because I'm missing a Just, right?
14:32:28 <newsham> (how can I throw a Just in there?)
14:32:37 <jethr0> yup
14:32:50 <jethr0> that's me, alright
14:33:09 <newsham> problem is I'm using "modify" which wants an S->S function
14:33:14 <int-e> newsham: you're missing that your functions take arguments
14:33:18 <ustenzel> newsham: let's see... you need evalStateT instead of evalState, and it results in a Maybe
14:33:42 <int-e> newsham: so putCols is of type [Int] -> StatT etc.
14:34:21 <newsham> no, putCols takes a single value and adds it to the int list
14:34:36 <int-e> newsham: ok, Int then
14:34:40 <newsham> oops, my signature is whacked :)
14:34:47 <ustenzel> newsham: the type declarations for putCols, putSEDiags, putSWDiags are wrong
14:35:10 <newsham> fixed
14:35:18 <int-e> newsham: after that there's only one obvious mistake left :)
14:36:06 <ustenzel> Huh?  At my end it runs now.
14:36:12 <pengo> argh i hate haskell
14:36:26 <astrolabe> I love haskell
14:36:29 <int-e> pengo: do it somewhere else please :)
14:36:34 <lisppaste2> twb pasted "IO unification" at http://paste.lisp.org/display/14535
14:36:42 <newsham> whoa, it runs!
14:36:43 * jethr0 couldn't agree more with astrolabe
14:36:44 <lollan> pengo : you are crazy
14:36:47 <twb> What am I doing wrong?
14:36:56 <pengo> now that i've learnt some haskell, it makes coding in java so annoying
14:37:07 <astrolabe> Ah
14:37:09 <twb> pengo: ooooh, yeah.
14:37:16 <twb> pengo: that happens a lot.
14:37:16 <jethr0> pengo, i can believe that. i guess the explicit typing is worst, right?
14:37:34 <twb> jethr0: the lack of pattern matching is also annoying.
14:37:35 <pengo> jethr0, it's the explicit casting that gets me
14:37:53 <newsham> http://lava.net/~newsham/x/machine/eightqueens.lhs.txt <- fixed
14:38:11 <jethr0> pengo, but i'm not fan of (fromIntegral, ...) either
14:38:18 <reddi> thx @ all who helped me
14:38:19 <pengo> and the "if i was doing this in haskell i could do it in a type safe manner"
14:38:33 <jethr0> you are doing type unsafe java???
14:38:36 <reddi> a defect vaio, the week before xmas and i have NO time anymore ;-(
14:38:58 <int-e> newsham: that's a neat program, btw.
14:39:09 <pengo> jethr0, more or less
14:39:14 <ricebowl> pengo - what about the "if I were doing this in Haskell (or any other language) it would take half the time and half the lines of code to get the job done"
14:39:40 <pengo> ricebowl, that doesn't bother me so much :)
14:39:46 <twb> ricebowl: well yes, but it's not very explanatory.
14:39:48 <ustenzel> jethr0: pray tell, how do you write a non-trivial type-*safe* program in Java?!
14:39:54 <jethr0> or "if i were using haskell i could have abstracted this recurring pattern instead of retyping it dozens of times"
14:40:06 <twb> jethr0: nod nod nod
14:40:08 <pengo> ustenzel, you can use generics
14:40:11 <jethr0> ustenzel, define "type-safe"
14:40:49 <twb> Haskell isn't as good at abstraction as CL, but because it's lazy you can do a lot more with the abstraction you *do* have.
14:40:49 <ricebowl> ustenzel - I think they're referring to the fact that (prior to 1.5) there is no way to specialize a generic container, e.g. a linked list container, to a particular type, so you do a lot of casting
14:40:55 <ricebowl> and pray that the container is homogenous
14:41:05 <newsham> so once the syntax is right, this seems pretty easy to use.
14:41:15 <twb> 1.5 is not yet supported by anyone but Sun, right?
14:41:18 <newsham> but getting the syntax right, and figuring out the errors, is awkward for me :)
14:41:18 <ricebowl> in Haskell (and various imperative languages such as C++) you can choose how abstract the type is
14:41:53 <ricebowl> that's different from type safety. Java is 100% type safe because it is impossible to cast something into the wrong type. You will get an exception.
14:42:16 <ricebowl> unlike C and C++ where they will happily do it. (Although C++ extensions allow behavior similar to Java's.)
14:42:17 <ustenzel> jethr0: skipping the boring details, types simply happen at compile time.
14:42:20 <ricebowl> err s/extensions//
14:42:42 <ricebowl> but it's a runtime check instead of a compile-time check, so you can't make guarantees about behavior
14:42:54 <jethr0> ustenzel, i still don't get your point... i see java as a type fascistic language, but maybe i don't remember it right...
14:42:56 <pengo> ricebowl, yeah, but i'd like that checking to happen at compile time.. which in theory would be possible with my code, but in practice, isn't
14:43:22 <ricebowl> pengo - well, 1.5 can do that, but it's still Java and I passionately hate the verbosity and lack of abstraction
14:43:41 <ricebowl> they added enumerations which apparently are just syntactic sugar
14:43:47 <triplah_> haha
14:43:50 <triplah_> for what?
14:43:57 <ricebowl> classes
14:43:59 <triplah_> ahh
14:44:01 <jethr0> ustenzel, maybe it's a runtime vs. compile-time issue... haven't thought about it in a while.
14:44:01 <triplah_> yuck
14:44:18 <ricebowl> yeah, which means that they ignored the real power of enumerations just like C and C++ did.
14:44:23 <ustenzel> jethr0: yeah, Java forces you to declare types, but they are not powerful enough.  You end up declaring everything as Object and get no static guarantees in return.
14:44:24 <triplah_> yeah :\
14:44:36 <pengo> what's the real power of enumerations?
14:44:37 <ricebowl> but I'm not surprised.
14:44:45 <triplah_> the power of enumeration types really is in the higher order stuff isnt it?
14:44:45 <ricebowl> after 15 years of screwing up, can you expect them to get it right all of a sudden?
14:45:06 <jethr0> ustenzel, yes, but you can't call any functions on object and dynamic casts will fail at runtime. but i guess that's your critique :)
14:45:36 <pengo> triplah_, higher order?
14:45:38 <ricebowl> well an enumeration is conceptually a *completely* different concept from integers, though obviously integers are enumerable. In Haskell you can index arrays with enumerations. You can do that in C/C++, too, if you don't assign values to them.
14:45:40 <jethr0> btw, what's the point of True/False being an enumeration?
14:45:44 <ricebowl> but the guarantee that it will work isn't there
14:46:07 <pengo> ricebowl, ah ok
14:46:15 <jethr0> > [True..False] >>= return . not
14:46:15 <ricebowl> the whole point is to let the compiler pick reasonable values and do a lot of the work for you
14:46:16 <lambdabot>  parse error on input `True..'
14:46:21 <newsham> is the "tryEach" function a standard one?
14:46:22 <triplah_> pengo: first class functions.... stuff like that
14:46:31 <ustenzel> jethr0: exactly.  I don't care much if it says "...exited with SIGSEGV" or "invalid cast exception"; if I bother with types, it shouldn't fail at all.
14:46:35 <pengo> triplah_, ah k
14:46:35 <ricebowl> and then you can do nice things like associate data with a particular element
14:46:43 <triplah_> my lecturer wrote map in C, it wasnt pretty :)
14:46:52 <triplah_> and was very type specific
14:47:01 <jethr0> triplah_, well that has to do with c lacking any kind of array/list
14:47:11 <ricebowl> triplah_ - in C++ it's not as bad
14:47:12 <pengo> i think i'm slowly rewriting haskell in java
14:47:22 <pengo> just without the syntax
14:47:46 <newsham> (cant tryEach be defined as a fold of mplus?)
14:47:47 <triplah_> jethr0: yes, but C was only made to provide and abstraction to assembler, not create expressive mathematical power
14:47:50 <triplah_> :P
14:47:54 <triplah_> and aray is a list of memory locations
14:47:58 <triplah_> array*
14:48:03 <ricebowl> triplah_ - C++ has generics which makes it non-type-specific. However, lack of built-in memory management means that you have to play tricks.
14:48:04 <ustenzel> newsham: (msum .) . fmap
14:48:09 <dons> @where+ djinn darcs get http://darcs.augustsson.net/Darcs/Djinn
14:48:09 <lambdabot> djinn ~> darcs get http://darcs.augustsson.net/Darcs/Djinn
14:48:17 <triplah_> ricebowl: so you mean things like unions? :O
14:48:27 <ricebowl> triplah_ - not at all
14:48:30 <newsham> what is msum?
14:48:34 <dons> "djinn: a small program that takes a (Haskell) type
14:48:34 <triplah_> ahh ok
14:48:35 <dons> and gives you back a function of that type if one exists."
14:48:44 <jethr0> lack of memory management means you'll leak mem all over the place!
14:48:49 <ricebowl> triplah_ - C has unions, C++ has templates which allow you to write a function that can operate on multiple types
14:48:50 <triplah_> ehe
14:48:50 <ustenzel> newsham: msum = foldr mplus mzero
14:48:54 <Heffalump> C++ generics are *AWFUL*
14:49:00 <Heffalump> (templates and unions)
14:49:02 <ricebowl> jethr0 - if you're not careful ;) any good C/C++ programmer minds his memory
14:49:08 <triplah_> ricebowl: ahh ok cool, yeah i think i've seen some code like that, it wasnt pretty
14:49:18 <Heffalump> templates are only type checked at instantiation time.
14:49:19 <newsham> ustenzel: so inst msum the same as tryEach?
14:49:24 * xerox stares at dons
14:49:24 <ricebowl> Heffalump - they aren't pretty, but they aren't awful
14:49:40 <Heffalump> they are awful. No type safety.
14:49:41 <ustenzel> newsham: no, you need to combine msum and map
14:49:46 <jethr0> ricebowl, *yeah right*. i've done my share of C/C++ development. and i'd be happy to see the application that doesn't have mem problem at some point...
14:49:54 <ricebowl> triplah_ - I've written a lot of code like that. The syntax is particularly annoying because of parser issues, so nested templates require spaces between the angle brackets
14:50:02 <jethr0> ever looked at the output of valgrind of the gnu standard libraries?? *brrr*
14:50:05 <ricebowl> e.g. std::vector<std::basic_string<char> >
14:50:10 <xerox> dons: is it *real* ?  does it support recursion?
14:50:13 <triplah_> eep
14:50:15 <ricebowl> and it can get really complicated
14:50:26 <newsham> oh, right, tryEach invokes the function and then sums the result
14:50:41 <jethr0> i thought recursion in templates was limited to depth 7!?
14:50:43 <dons> xerox, well, you give it a type,, it gives you a function of that type:
14:50:44 <dons>   Djinn> bindC ? C a -> (a -> C b) -> C b
14:50:44 <dons>   bindC :: C a -> (a -> C b) -> C b
14:50:44 <dons>   bindC x1 x2 x3 = x1 (\ c15 -> x2 c15 (\ c17 -> x3 c17))
14:50:50 <Heffalump> dons: is bottom allowed? :-)
14:50:53 <ricebowl> jethr0 - depends on the size and complexity. Also, it is possible to set simple coding standards that prevent memory leaks. It just makes it much more difficult to write correct code.
14:51:02 <dons>   Djinn> cast ? a->b
14:51:03 <dons>   -- cast cannot be realized
14:51:16 <Heffalump> dons: was C specified above?
14:51:26 <ricebowl> jethr0 - nesting 7 levels is pretty significant.
14:51:32 <Heffalump> oh, must have been a function type
14:51:32 <ustenzel> jethr0: instantiation depth is limited to something and the standard mandates at least 17 (for whatever reason)
14:51:34 <dons> Heffalump, yep.
14:51:39 <dons>   Djinn> type C a = (a -> r) -> r
14:51:39 <dons>   Djinn> returnC ? a -> C a
14:51:40 <jethr0> ricebowl, it get's complicated when objects are created and destroyed at different points in the code. short of smart pointers it can get pretty ugly!
14:51:41 <Heffalump> otherwise it couldn't have applied x1
14:51:42 <ricebowl> at that point the type becomes so long that it's impossible to read
14:51:53 <Heffalump> so where do I get this?
14:51:54 <dons> so it derived the continuation monad
14:51:54 <newsham> tryEach l f = msum (fmap f l)    ?
14:51:58 <ricebowl> jethr0 - yes, but there are always smart pointers ;)
14:51:59 <dons> @where djinn
14:52:00 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
14:52:02 <dons> Lennart's tool
14:52:07 <Heffalump> what does it do with state monads?
14:52:08 <jethr0> ah, i thought it was instantiation depth 7
14:52:12 <pengo> what's the haskell obsession with one letter variables and types anyway?
14:52:15 <xerox> Let's make it.
14:52:26 <Heffalump> cos there are type correct but wrong ways to write >>= for that
14:52:33 <newsham> pengo: when you only have one or two, why not use one letter (or two letter plural)
14:52:40 <ricebowl> my only complaint about templates is that they're extremely limited, e.g. you can't write a function with a template parameter that must be a sub-class of a particular class
14:52:47 <dons> "Djinn uses a decision procedure for intuitionistic
14:52:48 <dons> propositional calculus"
14:52:59 <Heffalump> ricebowl: right. Type checking is only instantiation time.
14:53:09 <ricebowl> MS implemented that in C# and of course patented it.
14:53:20 <Heffalump> hadn't Java already done it?
14:53:23 <ricebowl> Heffalump - that's a separate issue
14:53:30 <pengo> newsham, i'm sure mathematians used to say that too :/ i hate maths syntax
14:53:31 <ricebowl> no, Java's generics are even more retarded
14:53:33 * jethr0 considers C++ templates patched on and their syntax inherently unwriteable
14:53:35 <Heffalump> ok, a closely related one
14:53:43 <Heffalump> jethr0: yeah
14:53:57 <xerox> dons: it would be so cool to type types and get the definitions out in say, hIDE, for simple functions.  Ã'simple' meaning straightforward or something.
14:53:57 <newsham> pengo: longVariableNames does not necessarily make code more readable.
14:53:59 <ustenzel> ricebowl: oh, C++ *has* constrained genericity, though, as any useful feature of that language, only accidentally.
14:54:05 <ricebowl> my understanding is that Java's generics are akin to Haskell's generalization of function parameters. It proves that the type of a particular object is always the same, so it can vary.
14:54:05 <jethr0> i can't imagine writing something really complex in C++ templates *urgh*
14:54:23 <Heffalump> the template metaprogramming people seem to manage
14:54:35 * ricebowl writes template metaprograms
14:54:36 <rg> pengo, mathematics has been around a lot longer than programming and its "syntax" had time to mature
14:54:36 <dons> xerox, yeah, I'd like to write a little binding to it. hmm. a lambdabot plugin!
14:54:41 <xerox> dons: maybe passing Djinn through pl.
14:54:43 <jethr0> and also, templates don't abstract well over inheritance and maybe polymorphy in general
14:55:11 <ricebowl> jethr0 - there is overlap, but I don't see how you say "don't abstract well"
14:55:12 <jethr0> phism*
14:55:18 <rg> pengo, most programmers these days still write crap
14:55:27 <xerox> dons: do it!!!!!!!11111oneoneoneoneone[x | x <- [1] _ <- [1..]]
14:55:30 <ricebowl> they're mostly parallel idioms, but orthogonal with respect to storage
14:55:31 <pengo> rg, well this is true
14:55:33 <triplah_> i prefer haskell syntax to the lambda calculus
14:55:34 <triplah_> :p
14:55:39 <jethr0> inheriting a virtual template method is IMHO not possible
14:55:40 <pengo> mm.. lambda calculus
14:55:49 <triplah_> and i like schemes lambdas too, pity schme isnt curried though
14:56:12 <newsham> most programmers are not well read.
14:56:17 <ricebowl> jethr0 - is a virtual templated method possible?
14:56:22 <rg> pengo, my opinion on variable names: their length should increase monotonically with their scope
14:56:24 <ricebowl> hm, I guess it would be
14:56:26 <newsham> I don't imagine there are many good writers who dont read.
14:56:26 <jethr0> no, that's what i'm saying
14:56:41 <ricebowl> well, conceptually it is, but I think that's a limitation of C++'s backward-compatibility with C
14:56:43 <rg> pengo, if they are used only on two lines, long names usually make the code harder to read
14:56:55 <jethr0> inheritance in combination with templates gets ugly very fast
14:57:13 <ricebowl> yes, but usually it makes no sense to mix them anyway
14:57:30 <jethr0> hmm, i had occasions where i'd have liked to have them
14:57:40 <rg> pengo, in procedural languages you rarely have such narrow scopes, but in functional languages scopes are naturally smaller
14:57:43 <ustenzel> usually, inheritance makes no sense at all...
14:57:52 <rg> pengo, hence the variable names...
14:57:58 <pengo> rg, hm yeah that's a point
14:58:01 <jethr0> also, there are some _weird_ work-arounds with classes, templating parametrizing themselves *urgh*
14:58:32 <pengo> rg, tho once they use 3 or more variables and types, i find names pretty useful
14:58:32 <newsham> besides the smaller scope... there's lots of well written C code with short variable names that is quite readable.
14:58:34 <ustenzel> hey, that's not much worse than the innards of HList!
14:58:42 <ricebowl> ustenzel - usually large inheritance trees make no sense; there are some uses. Java does particularly well with its storage heirarchy. Still, I doubt anyone bothers to use the expressivity of it.
14:58:43 <rg> jethr0, i bet you'd love "policy based design" in c++ :D
14:58:46 <newsham> read through any Unix 7th edition utility for example.
14:59:10 <jethr0> ricebowl, i tried once to implement iterators over inherited classes... the templating just broke down!
14:59:27 <ricebowl> jethr0 - why would the iterators be templated?
14:59:28 <jethr0> and the newsgroup simply said "don't mix templates/STL and polymorphism"
14:59:29 <ustenzel> ricebowl: yeah, but have a look at STL -- it does even better without inheritance
14:59:32 <ricebowl> haha
14:59:35 <ricebowl> well that group is lame
14:59:49 <ricebowl> I read through their FAQ, they have the same egocentric style that Microsoft groups have
14:59:55 <xerox> dons: would you mind #haskell-overflow some example uses of Djinn?
14:59:56 <ricebowl> "Program like this because it's better."
14:59:56 <jethr0> ricebowl, i forgot, but there was a reason for it...
15:00:17 <rg> ricebowl, and haskellers are not egocentric? :p
15:00:21 <ricebowl> ustenzel - not better, but yes, it does well enough
15:00:35 <ricebowl> rg - at least they have better answers to questions than "You shouldn't do that."
15:00:53 <newsham> Whoa!  ok.. this is fricken cool.   by taking the eightqueens code and changing "Maybe" to "[]" all of the sudden the same code will generate *all* solutions
15:01:13 <jethr0> ricebowl, no it was templated, but STL has "templating" in it and so i ignorantly consider them as one :)
15:01:14 <musasabi> Is it really impossible to get the current location in a file from a Handle?
15:01:19 <ustenzel> ricebowl: hey, I *love* the STL!  already knowing it helped a lot with understanding haskell ;-)
15:01:19 <jethr0> http://groups.google.de/group/comp.lang.c++.moderated/browse_thread/thread/b2b6647b60d281df/35c945f88507c802?lnk=st&q=softpro%40gmx.net&rnum=10#35c945f88507c802
15:01:24 <ricebowl> coming from a C background, I know when to use macros and when not to use macros. The C++ people always shun macros as being universally evil. I understand why they do, but the fact that you can do bad things does not generalize.
15:01:31 <Pseudonym> newsham: Welcome to the wonderful world of monads.
15:01:38 * musasabi wants lseek
15:01:49 <Pseudonym> Actually, I found that already knowing Haskell helped with the STL.
15:01:52 <ricebowl> they also say that you should always use std::vector instead of arrays, std::string instead of char*, etc.
15:02:08 <ricebowl> which is really retarded. Engineering is always about picking the correct tool for the job.
15:02:13 <jethr0> ricebowl, purely syntactic macros have their use, but have no place in abstracting stuff
15:02:21 <ricebowl> yes, of course
15:02:24 <Pseudonym> The reason why C++ shun macros is that many uses of macros have safer alternatives in C++.
15:02:35 <jethr0> _plus_ the string concatenation thingeys are pure evil (although loads of fun :)
15:02:41 <musasabi> hmm hTell :-)
15:02:41 <dons> Lennart's code is quite interesting
15:02:43 <Pseudonym> For example, static const int is better than a value macro, because you can put it in a namespace.
15:02:48 <rg> ricebowl, and you should also use the best language for the job
15:02:57 <rg> and the answer is not haskell
15:03:01 <rg> ... always :)
15:03:10 <Pseudonym> Merely because something has a use doesn't mean that you should use it habitually.
15:03:23 <ricebowl> Pseudonym - that's very, *very* painful
15:03:32 <xerox> Pseudonym!  How long.
15:03:41 <ricebowl> Pseudonym - also, you cannot use __FILE__ and __LINE__ macros which are *extremely* useful in assertions
15:03:45 <Pseudonym> That's true.
15:03:55 <Pseudonym> I'm not saying that macros are the embodiment of evil.
15:04:10 <rg> ricebowl, why not simply use "assert"?
15:04:12 <ricebowl> Pseudonym - I seem to recall that C++ allows you to use a const int as an array bound, but when I began learning my compiler did not allow that
15:04:13 <Pseudonym> I think that the _true_ C++ illuminati would agree that they are important to have.
15:04:37 <rg> ricebowl, your compiler was retarded
15:04:38 <ricebowl> rg - because the purpose of C (and the stated purpose of C++) is to be able to work in minimal environments and write systems code
15:04:39 <jethr0> nobody has anything against null-ary macros... (well, with exceptions). the problems arise with arguments and their horrendous "evaluation"
15:04:40 <ricebowl> I write systems code.
15:04:46 <ricebowl> assert does not work in my environment.
15:04:46 <newsham> pseudo: besides [] and Maybe, what else might be useful in this context?
15:04:49 <Pseudonym> However, you can have the best of both worlds: A macro which is a very thin layer on top of a decent C++ abstraction.
15:05:08 <Pseudonym> newsham: This might.
15:05:11 <Philippa> ricebowl: can you name me situations that don't involve legacy interfaces where char * is genuinely better than std::string?
15:05:17 <ricebowl> jethr0 - yes, many C++ people who I talk to have problems with null-ary macros
15:05:23 <ustenzel> jethr0: reading your post, I'm wondering why there's begin() and end() in your Base class.  They are actually ill-typed, but let's not rehash that here.
15:05:26 <Pseudonym> Hang on.
15:05:40 <rg> ricebowl, i haven't heard of a compiler that doesn't know about "assert"... until now
15:05:48 <ricebowl> Philippa - yes, when you don't need to modify the string
15:05:56 <Pseudonym> ricebowl: One of the things that the less-illumined C++ users don't realise is that "static const float" doesn't work.
15:06:03 <Pseudonym> So you need macros there.
15:06:07 <ricebowl> rg - my compiler knows what assert is
15:06:14 <Philippa> ricebowl: the improvement being the minor decrease in memory utilisation, I take it?
15:06:17 <ricebowl> rg - it is simply the case that assert is not supported in my runtime environment
15:06:21 <jethr0> ustenzel, let's not, but the newsgroup was pretty firm about denying the feasibility of my question.
15:06:27 <Lor> Pseudonym, why not?
15:06:40 <Pseudonym> newsham: Here we are.
15:06:44 <Pseudonym> @wiki NonDeterminism
15:06:44 <lambdabot> http://www.haskell.org/hawiki/NonDeterminism
15:06:55 <ricebowl> Philippa - there is no improvement, AFAIK, but it can be appropriate. Legacy interfaces are impossible to escape, you know.
15:06:56 <Pseudonym> NondetT should do nicely.
15:07:01 <rg> ricebowl, i see
15:07:08 <Pseudonym> The cool part about NondetT is that you can stack it on top of IO.
15:07:12 <newsham> pseudo: random hill climbing?
15:07:15 <ustenzel> jethr0: they have a good reason
15:07:39 <Pseudonym> Lor: For some reason, it just doesn't.
15:07:44 <ricebowl> rg - many people forget that not everyone is writing nice GUI/commandline programs which have a relatively lax environment.
15:08:02 <Lor> Pseudonym, all right, but is this just an implementation issue or do you claim that the language precludes their inlining?
15:08:03 <ricebowl> rg - although that seems to be the vast majority of software
15:08:15 <Pseudonym> Lor: Just a moment.
15:08:29 <ricebowl> but drivers, OS kernels, and other such things do not have all the luxury that languages like C++ and Java attempt to afford the programmer
15:08:53 <rg> ricebowl, so you consider the lack of "assert" being justified by the fact that it's an embedded system?
15:09:01 <ricebowl> no
15:09:11 <rg> ricebowl, they should have debug versions of the runtime no matter
15:09:19 <ricebowl> I am simply stating that we *have* to create our own assert, and this is the simplest way to do it
15:09:26 <Pseudonym> Lor: http://www.research.att.com/~bs/bs_faq2.html#in-class
15:09:28 <jethr0> ricebowl, few people here will have problems with "pure c"... it's C++ that's the real culprit!
15:09:30 <ricebowl> rg - I am working in an environment that cannot be debugged
15:09:37 <newsham> ricebowl: many kernels provide the "luxury" (if it can be called that) of c++ support.
15:09:55 <newsham> not a lot with garbage collection.. but give MS a few years.. I'm sure they'll fix that
15:09:55 <jethr0> pure C has even some beauty in its assembly-like simplicity
15:10:09 <ricebowl> newsham - C++ is not officially sanctioned either in the Linux kernel or the Windows kernel, and there is a reason for that (besides language prejudice).
15:10:15 <Philippa> jethr0: you can count me in for problems with pure C. It's a great language for 30 years ago
15:10:38 <ricebowl> newsham - yes, there was talk of allowing .NET drivers in the Windows kernel, and FWIW C++ code does run in the Windows kernel. But those who code C++ have to know what they can and cannot do.
15:10:41 <newsham> are you sure?  I thought there were context in the NT kernel that supported c++
15:10:44 <ricebowl> because there is no full C++ runtime
15:10:53 <rg> ricebowl, "debugged" as in "step thru the code"? i never do that
15:10:58 <Pseudonym> The fact that Linus doesn't know what good C++ looks like is reason enough.  He's the one who has to understand all of the code.
15:11:04 <Philippa> and I'm not just being a snob due to not having to perform the tasks C is good for, either
15:11:05 <ricebowl> no, MS explicitly states that they do not support C++ code in the kernel. Of course, win32k.sys is written in C++.
15:11:25 <ricebowl> rg - debugged in any sense of the word
15:11:27 <jethr0> philippa, agreed. but compared to C++ it's like the a programming language revelation!
15:11:31 <Pseudonym> The fact that there's already 2.5 million lines of C is also reason enough.
15:11:44 <Lor> Pseudonym, all right, but that's just inside classes.
15:11:52 <Heffalump> C is at least smaller than C++.
15:11:52 <ricebowl> rg - because my code *is* the debugger, and the debugger for a number of reasons cannot debug itself
15:11:55 <rg> ricebowl, well that i can't believe. surely there must be some kind of observable behaviour.
15:11:56 <Heffalump> It's still a pretty awful language.
15:11:58 <Pseudonym> You actually don't need very much C++ runtime to support C++.
15:12:02 <Philippa> jethr0: not here. I moved to C++ from C having found C couldn't support the abstractions that were becoming natural for my code
15:12:05 <Pseudonym> There are some pretty small kernels written in C++.
15:12:09 <ricebowl> rg - yes, there is: either it works or it fails ;)
15:12:09 <Lor> Anyway, arguably the "right" way to do float constants in C++ is to define an inline function that returns the value.
15:12:10 <Philippa> Pseudonym: you do to cover all of it
15:12:15 <Pseudonym> Admittedly, they tend not to be for 8- or 16-bit platforms.
15:12:18 <rg> ricebowl, that is enough
15:12:21 <Lor> It's imho better than using macros.
15:12:23 <ricebowl> rg - we're limited to "debugging by printf", except that there is no printf
15:12:25 <Philippa> heh
15:12:34 <jethr0> philippa, agreed, C can't handle abstractions _at all_!
15:12:56 <Pseudonym> Personally, I wouldn't use C unless there were some severe platform constraints.
15:13:00 <newsham> http://research.microsoft.com/os/singularity/
15:13:01 <Pseudonym> e.g. what I'm doing now. :-)
15:13:16 <ricebowl> we use C++, but it's really C code compiled as C++ code
15:13:17 <Pseudonym> But that's just me.
15:13:21 <newsham> (I wonder if singularity will ever see commercial use)
15:13:22 * Pseudonym nods
15:13:25 <ricebowl> and it's still really frustrating
15:13:29 <Pseudonym> Even using C++ as a better C is an improvement on C.
15:13:29 <Philippa> jethr0: not true. Any language that lets you name things has at least one abstraction mechanism: "stop caring what's behind the name"
15:13:41 <newsham> pseudo: debatable
15:13:45 <Philippa> and if you can't name thing you can name the positions they go in instead
15:13:46 <Pseudonym> Right.  That's called "data polymorphism".
15:13:47 <jethr0> i meant user-added abstractions :)
15:13:50 <ricebowl> Pseudonym - not by much in my experience. Most of the type errors that C++ catches are benign.
15:13:52 <Pseudonym> One name, multiple values.
15:14:07 <newsham> sometimes the goodness of a language is in what it doesnt let you do (see also: perl)
15:14:09 <ricebowl> I suppose that we do use templates in some places, and for that C++ is a win
15:14:17 <rg> jethr0, you can put those in comments
15:14:32 <rg> jethr0, it does have comments.
15:14:35 <Philippa> if I have to manage memory manually, destructors are a big win for me
15:14:45 <jethr0> newsham, let's not start about the "goodness of perl"
15:14:45 <Pseudonym> I've commonly used C++ classes basically as a decent module system for C.
15:14:48 <ricebowl> Pseudonym - usually when I convert pure C to C++ I get a ton of errors about casting the return value of malloc(), and that's it
15:14:49 <Pseudonym> And that's a big win.
15:15:01 <ricebowl> Philippa - that is true
15:15:03 <newsham> jethro: the implication was the lack of goodness in perl.
15:15:15 <Philippa> ricebowl: usually your C code's been through the run a few times and you're looking for the stragglers, no?
15:15:24 <Philippa> that doesn't tell you C++ wouldn't have helped you catch the errors faster
15:15:24 <ricebowl> Philippa - something like that ;)
15:15:29 <ricebowl> well, true
15:15:43 <Pseudonym> C++ classes are a fairly good alternative if you don't have a REAL module system.
15:15:48 <ricebowl> my experience has been that usually those aren't difficult errors to find
15:15:57 <Pseudonym> (I miss decent module systems, BTW.)
15:16:02 <jethr0> rg, yup, "// this pointer-arithmetic ridden code is a balanced avl tree. even though you might not recognize it as such"
15:16:02 <Pseudonym> (Especially in Haskell!)
15:16:08 <Philippa> Pseudonym: half the GoF patterns book is OO and C++ hacks for missing language features, of course
15:16:21 <Pseudonym> Philippa: So are half the Functional Pearl papers.
15:16:30 <ricebowl> I just wish C++ afforded better abstraction
15:16:37 <rg> jethr0, nope, as in... look-up SGB by knuth
15:16:38 <Pseudonym> Why do we have whole papers on how to get global mutable state in Haskell?
15:16:50 * Philippa nods
15:16:54 <Pseudonym> It just so happens that the missing features are different in each language.
15:17:02 <Philippa> but we get significant wins over just having global mutable state in our case
15:17:13 <Pseudonym> I agree, however.
15:17:16 <jethr0> yes, which leads us back to "best tool for the job"!
15:17:17 <Philippa> I don't really see it with the Visitor pattern, for example
15:17:31 <Pseudonym> There are still many papers on type system extensions to implement some feature or other from some other langauge.
15:17:34 <jethr0> philippa, i _love_ the visitor pattern
15:17:41 <Heffalump> so why doesn't Haskell allow declaration of global locations?
15:17:43 <rg> jethr0, the point is: sure, it is better if you express abstractions in a fully formal language (e.g. haskell) but the important thing is to have them in your head and communicate them well
15:17:49 <Pseudonym> In most cases, I'd prefer real algebraic data types to visitors.
15:17:49 <jethr0> it's a good workaround for missing generators/internal/external iteration!
15:17:54 <ricebowl> Haskell is nice because you can verify that all cases are handled and all computations have well-defined results
15:17:58 <ricebowl> you can't do that in C++
15:18:03 <Philippa> jethr0: I fucking hate it with a vengeance. Give me algebraic datatypes and the obvious signiature on a recursive function anyday
15:18:03 <Pseudonym> But actually, Haskell has a rough equivalent to visitors, and that's views.
15:18:05 <ricebowl> and especially not Java
15:18:11 <Pseudonym> @wiki ConcreteView
15:18:12 <lambdabot> http://www.haskell.org/hawiki/ConcreteView
15:18:13 <Heffalump> at one level, I can see why. Referential transparency and all that. You don't want foo = some_location as a top-level declaration to be the way to do it.
15:18:25 <Philippa> except views are fairly clearly raw sugar anyway
15:18:32 <jethr0> philippa, ya well, that's a question of the environment you have to work in.
15:18:35 <Pseudonym> So are visitors, surely?
15:18:43 <Philippa> Heffalump: I see it this way - the program's in the IO monad /anyway/
15:19:20 <jethr0> but given an imperative manually typed system, i wouldn't miss my visitors! they allow me separation of policy and mechanism in an otherwise stupid language
15:19:34 <Philippa> Pseudonym: there's a lot more of it. In the case of views, the sugar's almost all in skipping a single function call
15:19:34 <Pseudonym> Algebraic data types and concrete views basically give you language support for codata.
15:19:58 <Pseudonym> There are almost no other languages (apart from ML variants) which truly handle codata cleanly.
15:20:01 <Philippa> with the visitor pattern, you have to use the dual of the appropriate variety of type
15:20:11 <Pseudonym> Loki/Boost variant support is very, very close.
15:20:15 <gzl> what is codata?
15:20:31 <Pseudonym> gzl: Codata is the dual of data. :-)
15:20:56 <Pseudonym> gzl: What other languages do you know apart from Haskell?
15:21:51 <gzl> I dunno, C, Java, PHP, what have you
15:21:55 <Pseudonym> OK.
15:21:58 <gzl> I imagine it's the dual of data
15:22:03 <gzl> but I don't know what that means
15:22:03 <Pseudonym> Imagine how you'd implement an infinite stream in Java.
15:22:08 <Pseudonym> StreamObject o;
15:22:13 <Pseudonym> if (o.endOfStream())
15:22:14 <Pseudonym> {
15:22:19 <Pseudonym>    // Do something
15:22:19 <Pseudonym> }
15:22:20 <Pseudonym> else
15:22:20 <Pseudonym> {
15:22:27 <Pseudonym>     Object c = o.getData();
15:22:28 <Pseudonym> }
15:22:29 <Pseudonym> Right?
15:22:30 <soysauce> Pseudonym - just wrap it in an iterator
15:22:32 <gzl> ok.
15:22:34 <rg> wow: category theory in Java :)
15:22:39 <Pseudonym> That is codata.
15:22:45 <gzl> why is that codata?
15:22:55 <Pseudonym> It's an abstraction that you want to get data OUT OF, rather than to put it in.
15:22:57 <soysauce> for(Iterator it = o.iterator(); it.hasNext(); it = it.next()) { ... }
15:23:07 <Pseudonym> Logically, this is a possibly infinite list.
15:23:10 <jethr0> pseudonym, so would you say that objects in OO are (data + codata)?
15:23:14 <gzl> oh
15:23:15 <Pseudonym> Physically, you can't do that in Java.
15:23:29 <Philippa> jethr0: they're data+cthulhu
15:23:29 <gzl> that's much clearer than the StreamObject example.
15:23:30 <Pseudonym> jethr0: Not quite.
15:23:40 <Pseudonym> There are other examples which can't be modelled with iterators.
15:23:42 <Philippa> you get this big tentacled horror back out ;-)
15:23:44 <Pseudonym> Example:
15:23:49 <Pseudonym> In Haskell, you could do this:
15:24:07 <Pseudonym> data Result = Zero | One Double | Two DoubleDouble
15:24:15 <Pseudonym> solveQuadratic :: Double -> Double -> Double -> Result
15:24:21 * jethr0 has spent _too_ much time procrastinating on userfriendly
15:24:30 <Pseudonym> Because a quadratic equation can have zero, one or two solutions.
15:24:40 <Pseudonym> That "get data out" situation is codata.
15:24:50 <Pseudonym> You can imagine how you might write this in Java:
15:25:01 <Pseudonym> Quadratic q = new Quadratic(a, b, c);
15:25:09 <Pseudonym> switch (q.resultType())
15:25:09 <Pseudonym> {
15:25:12 <Pseudonym> case ZERO:
15:25:16 <Pseudonym> etc etc
15:25:21 <ricebowl> Pseudonym - you can do it in C/C++ with a union, though it's not type-checked like Haskell is
15:25:28 <ricebowl> Java is a bad example because Java is a bad language
15:25:35 <gzl> and C/C++ aren't?
15:25:35 <Pseudonym> C++ unions must be POD.
15:25:37 <jethr0> you can always do "union types" in java via implementing interfaces *brr*
15:25:45 <ricebowl> POD--I forget what this acryonym stands for
15:25:50 <Pseudonym> Plain Old Data
15:25:52 <ricebowl> ah
15:25:56 <Pseudonym> A union member cannot have a destructor.
15:26:03 <Philippa> ricebowl: if OO languages got good disjoint unions with pattern-matching, they'd be a lot more comfortable to code in
15:26:10 <Pseudonym> Right.
15:26:14 <ricebowl> Philippa - agreed
15:26:18 <Pseudonym> And Boost/Loki variants come very, very close to that.
15:26:27 <Philippa> Pseudonym: wrap the union inna class etc etc
15:26:29 <Philippa> I built it once
15:26:33 <Pseudonym> Yeah.
15:26:38 <ricebowl> Philippa - painful.
15:26:39 <Pseudonym> Anyway.
15:26:40 <Philippa> I had to do something very, very dirty just to get all the memory to allocate...
15:26:49 <Pseudonym> It's actually not too bad in Boost and Loki.
15:26:55 <Pseudonym> Template metaprogramming.
15:26:56 <Philippa> they wrap the dirty bits
15:26:58 <ricebowl> lack of foresight (or perhaps raw incompetance) on the part of the ANSI committee makes C++ far more painful than it need be
15:27:09 <Philippa> really, I had to do a reinterpret_cast
15:27:11 <Pseudonym> boost::variant<boost::null, double, std::pair<double,double> >
15:27:13 <Heffalump> Boost/Loki do tagged unions?
15:27:17 <Pseudonym> Yup.
15:27:21 * Heffalump goes to look at them
15:27:26 <Pseudonym> And it even handles the alignment constraints.
15:27:27 <Heffalump> how efficiently?
15:27:30 <Pseudonym> Very.
15:27:43 <Pseudonym> The only problem is that at the moment you need to use a visitor to unpack them.
15:27:47 <Heffalump> ah.
15:27:48 <Pseudonym> Which kind of defeats the purpose.
15:27:55 <jethr0> hahaha
15:27:56 <Heffalump> unpacking is the issue.
15:27:59 <Heffalump> I need to replace
15:27:59 <Pseudonym> Right.
15:28:08 <Pseudonym> Hence: Haskell has the best support for codata in existence.
15:28:10 <Heffalump> switch (tag) { case tag1: ... case tag2: case tag3: ... }
15:28:18 <Pseudonym> Particularly because of lazy evaluation.
15:28:19 <Heffalump> with something as concise
15:28:28 <xerox> `codata', eh...
15:28:31 <jethr0> pseudonym, that's the funniest thing i've ever heard :) and the saddest
15:28:37 <soysauce> Pseudonym - lazy evaluation is convenient but easy to emulate with iterators
15:28:45 <Pseudonym> soysauce: No it's not.
15:28:51 <Pseudonym> It is for streams.
15:28:54 <Pseudonym> Not for other things.
15:28:56 <Pseudonym> e.g. codata :-)
15:28:58 <jethr0> you need generators (a la python)
15:29:05 <Philippa> soysauce: build your parsec clone to do everything lazily...
15:29:12 <Philippa> you'll soon get sick of it
15:29:13 <soysauce> eh I suppose
15:29:16 <jethr0> and they are not as flexible as lazy evaluation.
15:29:24 <newsham> co-routines.
15:29:33 <Pseudonym> Lazy evaluation gives you codata objects which share computation between the fields.
15:29:34 <jethr0> continuations
15:29:43 <Pseudonym> You'd need to use explicit caching to do that in C++.
15:29:57 <newsham> http://lava.net/~newsham/x/machine/thrgen.tgz
15:30:12 <xerox> Pseudonym: does 'codata' have a sensible definition?
15:30:41 <Pseudonym> xerox: Interesting definitional question.  Is anything "sensible" in category theory?
15:31:07 <Philippa> xerox: the dual of strict [algebraic] data[types], AFAICT
15:31:10 <xerox> Pseudonym: you answered with a question.
15:31:21 <Pseudonym> Yes I did.
15:31:35 <xerox> Hmpf.  Thanks Philippa.
15:31:42 <Pseudonym> Here's how I understand it:
15:31:47 <Pseudonym> If you think of an algebraic signature.
15:31:50 * soysauce wonders why Haskell tuples can't be treated as lists
15:32:00 <Philippa> there's a paper something like 'codata and comonads', which contains the closest thing to a definition I've seen
15:32:03 <newsham> http://lava.net/~newsham/x/machine/thrgen/ <- extracted 
15:32:11 <Philippa> it *might* also be 'coalgebraic datatypes', but I could be v.v.wrong
15:32:11 <Pseudonym> Then the free algebra is the initial object in the category of models of that signature.
15:32:20 <newsham> generation in C using coroutines
15:32:26 <Pseudonym> You can think of the free algebra as "data".
15:32:30 <Philippa> (and it doesn't help that ordinary algebraic datatypes admit deconstruction via pattern-matching due to being /initial/ algebras)
15:32:41 <xerox> Pseudonym: I'm lost on that.  Could you suggest any reading useful to comprehend what you're talking about?
15:32:47 <xah> xerox: do you know lisp?
15:32:52 <xerox> xah: yup.
15:32:53 <Pseudonym> xerox: Yes.  Barr and Wells. :-)
15:32:57 <pengo> Codata and Comonads in Haskell: http://www.cse.ogi.edu/PacSoft/publications/phaseiiiq10papers/codata.pdf
15:33:03 <xah> xerox: CL?
15:33:13 <xerox> xah: less than Scheme, but some.
15:33:19 <Pseudonym> I'll warn you, though, that the Codata and Comonads paper has what we think is an error in it.
15:33:21 <pengo> Philippa, i was reading that while hoping someone would give a simpler definition in channel
15:33:32 <soysauce> @pl \c -> c == ' ' || c == '\t' || c == '\r'
15:33:32 <Pseudonym> An error, I might add, which prompted shapr to write FLM.
15:33:32 <lambdabot> liftM2 (||) (' ' ==) (liftM2 (||) ('\t' ==) ('\r' ==))
15:33:40 <soysauce> @type dropWhile
15:33:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:33:49 <Philippa> Pseudonym: what's the error?
15:33:50 <xerox> Pseudonym: this makes it even more interesting!  Point me.
15:34:17 <Pseudonym> @wiki CoMonad
15:34:17 <lambdabot> http://www.haskell.org/hawiki/CoMonad
15:37:09 <joelr1> good evening everyone
15:37:18 <xerox> Oi.
15:37:29 <Pseudonym> Sorry, no.  OI is unsafe.
15:37:39 <joelr1> hmm
15:37:44 <xerox> I felt so ;)
15:38:08 <joelr1> how do you read ^C from the keyboard?
15:38:21 <xerox> Installing a signal handler
15:38:27 <jethr0> soysauce: (`elem` " \t\r")
15:38:56 <soysauce> jethr0 - ah, interesting
15:39:01 <dons> @djinn a -> b -> a
15:39:02 <lambdabot> x :: a -> b -> a
15:39:02 <lambdabot> x x1 _ = x1
15:39:03 <jethr0> hope it works
15:39:05 <soysauce> I decided to just stick with the lambda though
15:39:05 <joelr1> haha
15:39:10 <joelr1> xerox: you are funny
15:39:11 <dons> @djinn (a -> b -> c) -> ((a,b) -> c)
15:39:11 <lambdabot> x :: (a -> b -> c) -> (a, b) -> c
15:39:11 <lambdabot> x x1 (v3, v4) = x1 v3 v4
15:39:12 <xerox> dons: you rock.
15:39:24 <dons> here's either:
15:39:24 <jethr0> > map (`elem` " \t\r") "hello world\r"
15:39:25 <xerox> joelr1: thanks! :-)
15:39:25 <lambdabot> [False,False,False,False,False,True,False,False,False,False,False,True]
15:39:27 <dons> @djinn (a -> b) -> (c -> b) -> Either a c -> b
15:39:27 <lambdabot> x :: (a -> b) -> (c -> b) -> Either a c -> b
15:39:27 <lambdabot> x x1 x2 x3 = case x3 of
15:39:27 <lambdabot>      Left l4 -> x1 l4
15:39:27 <lambdabot>      Right r5 -> x2 r5
15:39:32 <dons> code for free!
15:39:35 <xerox> dons: I'm melting in my pants
15:39:43 <jethr0> what does djinn do?
15:39:50 <xerox> @djinn (a -> a) -> a
15:39:50 <lambdabot> -- x cannot be realized.
15:40:03 <jethr0> cool
15:40:06 <xerox> @djinn a -> [a] -> [a]
15:40:07 <lambdabot> x :: a -> [a] -> [a]
15:40:07 <lambdabot> x _ x2 = x2
15:40:08 <dons> @help djinn
15:40:09 <lambdabot>  @djinn <type>
15:40:09 <lambdabot> Generates Haskell code from a type.
15:40:11 <xerox> Err.
15:40:13 <Cale> jethr0: writes polymorphic code automatically :)
15:40:22 <jethr0> meaning?
15:40:27 <Cale> That's awesome :)
15:40:34 <soysauce> @djinn (a -> b) -> [a] -> [b]
15:40:34 <lambdabot> -- x cannot be realized.
15:40:41 <Cale> jethr0: there's a lot of types out there with only one function in them
15:40:43 <xerox> @djinn (a -> b) -> (b -> a) -> a -> a
15:40:44 <lambdabot> x :: (a -> b) -> (b -> a) -> a -> a
15:40:44 <lambdabot> x _ _ x3 = x3
15:40:45 <Pseudonym> dons: Now write "theorems for free" as a lambdabot module.
15:40:50 <dons> ah, good idea.
15:40:55 <xerox> @djinn (a -> b) -> (b -> c) -> a -> c
15:40:56 <lambdabot> x :: (a -> b) -> (b -> c) -> a -> c
15:40:56 <lambdabot> x x1 x2 x3 = x2 (x1 x3)
15:40:57 <Pseudonym> <lambdabot> x = undefined
15:41:13 <Pseudonym> @djinn (a -> b) -> [a] -> [b]
15:41:13 <lambdabot> -- x cannot be realized.
15:41:16 <dons> @djinn a
15:41:16 <lambdabot> -- x cannot be realized.
15:41:17 <Pseudonym> Ha!
15:41:18 <Cale> @djinn (b -> c) -> (a -> b) -> a -> c
15:41:19 <lambdabot> x :: (b -> c) -> (a -> b) -> a -> c
15:41:19 <lambdabot> x x1 x2 x3 = x1 (x2 x3)
15:41:25 <Cale> @pl @djinn (b -> c) -> (a -> b) -> a -> c
15:41:26 <lambdabot> (line 1, column 1):
15:41:26 <lambdabot> unexpected "@"
15:41:26 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
15:41:26 <lambdabot> expression
15:41:28 <Cale> hehe
15:41:33 <dons> @djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
15:41:33 <lambdabot> x :: ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
15:41:33 <lambdabot> x x1 = x1 (\ c1973 -> Right (\ _ -> x1 (\ _ -> Right (\ c3585 -> x1 (\ _ -
15:41:33 <lambdabot> > Left (\ c3587 -> c1973 (c3587,
15:41:33 <lambdabot>                                   c3585)))))))
15:41:33 <Igloo> @djinn Char -> Int
15:41:34 <lambdabot> -- x cannot be realized.
15:41:34 <xerox> hahaha
15:41:37 <psi> @djinn (a -> a) -> a -> a 
15:41:37 <lambdabot> x :: (a -> a) -> a -> a
15:41:37 <lambdabot> x _ x2 = x2
15:41:53 <Cale> er, that one is less than ideal
15:41:58 <Pseudonym> @djinn (a -> a -> b) -> b -> b
15:41:58 <lambdabot> x :: (a -> a -> b) -> b -> b
15:41:58 <lambdabot> x _ x2 = x2
15:42:03 <xerox> @djinn (a -> b -> c) -> b -> a -> c
15:42:03 <lambdabot> x :: (a -> b -> c) -> b -> a -> c
15:42:03 <lambdabot> x x1 x2 x3 = x1 x3 x2
15:42:04 <psi> yeah
15:42:11 <Pseudonym> It gives the "simplest" one.
15:42:14 <xerox> I told you we want it to me @pl-ed.
15:42:22 <xerox> s/me/be/
15:42:24 <rg> @djinn (a->b->a)->a->[b]->a
15:42:25 <lambdabot> x :: (a -> b -> a) -> a -> [b] -> a
15:42:25 <lambdabot> x _ x2 _ = x2
15:42:28 <Cale> optionally
15:42:28 <dons> now, you can add your own types to the environment, but that isn't supported yet..
15:42:37 <dons> so no monads yet
15:42:40 <dons> I think...
15:42:47 <Cale> You should make it try to use as many of the parameters as possible
15:42:58 <jethr0> i still don't get it? is that just for fun or can you extract purpose from its answers?
15:43:08 <dons> you can extract real programs...
15:43:10 <Cale> jethr0: it's giving proofs of theorems
15:43:11 <benny> dons: hey
15:43:13 <rg> @djinn ((a->b)->a->b)->a->b
15:43:14 <lambdabot> -- x cannot be realized.
15:43:19 <dons> @type a -> b -> (a,a)
15:43:20 <lambdabot> parse error on input `->'
15:43:24 <jethr0> nice
15:43:26 <xerox> @djinn (a,b) -> a
15:43:26 <dons> @djinn a -> b -> (a,a)
15:43:27 <lambdabot> x :: (a, b) -> a
15:43:27 <lambdabot> x (v2, _) = v2
15:43:27 <lambdabot> x :: a -> b -> (a, a)
15:43:27 <lambdabot> x x1 _ = (x1, x1)
15:43:29 <xerox> @djinn (a,b) -> b
15:43:30 <lambdabot> x :: (a, b) -> b
15:43:31 <lambdabot> x (_, v3) = v3
15:43:32 <dons> that's real code.
15:43:37 <soysauce> @pl \(s, m) -> (s, m 
15:43:38 <lambdabot> (line 1, column 14):
15:43:38 <lambdabot> unexpected ","
15:43:38 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
15:43:39 <soysauce> er
15:43:43 <xerox> @djinn (a,b) -> (b,a)
15:43:43 <lambdabot> x :: (a, b) -> (b, a)
15:43:43 <lambdabot> x (v2, v3) = (v3, v2)
15:43:45 <soysauce> @pl \f (s, m) -> (s, m >>= f)
15:43:46 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (=<<)
15:43:58 <jethr0> yeah!
15:44:02 <Cale> Does it know about monads?
15:44:15 <gzl> hm. that's pretty cool.
15:44:20 <jethr0> (second (>>= f)) maybe
15:44:27 <xerox> OK, I'll leave you all the fun.  Goodnight folks!
15:44:31 <Cale> @djinn (Monad m) => m (m a) -> m a
15:44:32 <lambdabot> Cannot parse command
15:44:33 <jethr0> nite
15:44:33 <dons> you can add types, so that it can derie say, `bind', but I haven't written the plugin code to extend the env yet
15:44:45 <soysauce> @hoogle second
15:44:45 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
15:44:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays.SecondaryColorArray :: ClientArra
15:44:45 <lambdabot> yType
15:44:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec.SecondaryColor :: SecondaryColor
15:44:45 <lambdabot> a
15:44:59 <Philippa> @djinn a -> (a,a)
15:44:59 <lambdabot> x :: a -> (a, a)
15:44:59 <lambdabot> x x1 = (x1, x1)
15:45:03 <Philippa> @djinn a -> (b,b)
15:45:04 <lambdabot> -- x cannot be realized.
15:45:06 <soysauce> all monads are arrows, right?
15:45:21 <Cale> soysauce: yes
15:45:23 <jethr0> all monads can be implemented by arrows, i think
15:45:26 <Philippa> @djinn a -> b
15:45:27 <lambdabot> -- x cannot be realized.
15:45:38 <soysauce> well, in my case m is bound to Maybe, I want to know if this will work
15:45:45 <Pseudonym> @djinn (a -> b) -> a -> b
15:45:45 <Philippa> dons: obvious implementation for a -> b is const someB
15:45:45 <lambdabot> x :: (a -> b) -> a -> b
15:45:45 <lambdabot> x x1 x2 = x1 x2
15:45:47 <Cale> in the sense that for any monad, the functions  a -> m b  form an arrow
15:45:51 <soysauce> @type \f -> (second (>>= f))
15:45:52 <lambdabot> Not in scope: `second'
15:45:55 <rg> @help
15:45:55 <lambdabot>  @help <command> - ask for help for <command>
15:45:58 <soysauce> @type \f -> (Control.Arrow.second (>>= f))
15:45:59 <lambdabot> forall (m :: * -> *) a b d.
15:45:59 <lambdabot> (Monad m) =>
15:45:59 <lambdabot> (a -> m b) -> (d, m a) -> (d, m b)
15:46:12 <Philippa> @djinn a -> ()
15:46:12 <lambdabot> x :: a -> ()
15:46:12 <lambdabot> x _ = ()
15:46:37 <Philippa> @djinn a -> a
15:46:38 <lambdabot> x :: a -> a
15:46:38 <lambdabot> x x1 = x1
15:47:09 <Philippa> @djinn Int -> Integer
15:47:10 <lambdabot> -- x cannot be realized.
15:47:39 <soysauce> @eval (\f -> (Control.Arrow.second (>>= f))) (\x -> Just (x + 1)) ("abc", Just 1)
15:47:40 <lambdabot> ("abc",Just 2)
15:47:42 <Cale> @djinn a -> [a]
15:47:42 <lambdabot> -- x cannot be realized.
15:47:43 <soysauce> @eval (\f -> (Control.Arrow.second (>>= f))) (\x -> Just (x + 1)) ("abc", Nothing)
15:47:44 <lambdabot> ("abc",Nothing)
15:47:49 <soysauce> nifty
15:48:03 <soysauce> @type second
15:48:04 <lambdabot> Not in scope: `second'
15:48:09 <soysauce> @type Control.Arrow.second
15:48:10 <lambdabot> forall (a :: * -> * -> *) c d b.
15:48:10 <lambdabot> (Control.Arrow.Arrow a) =>
15:48:10 <lambdabot> a b c -> a (d, b) (d, c)
15:48:14 <Cale> that's only using the (->) arrow actually
15:48:43 <lollan> somebody knows a tezt editor for haskell ?
15:48:43 <jethr0> soycause "Nothing >>= _" is Nothing
15:48:49 <soysauce> jethr0 - I know
15:49:00 <jethr0> ah, sry
15:49:10 <soysauce> jethr0 - in my case I have (String, Maybe a), and I want to implement the same sort of behavior
15:49:21 <jethr0> @pl \f -> (Control.Arrow.second (>>= f))
15:49:22 <lambdabot> ((Control . Arrow) .) . second . (=<<)
15:49:25 <Xianianol> Is there anyway to evaluate a expression and shows all the evaluation steps ?
15:49:32 <soysauce> some function which for the moment I will call (>>=) so that I can bind and compute, and if a computation fails then evaluation stops
15:49:33 <Cale> lollan: vim and emacs work fine. If you want something written in Haskell, look at yi, which is really cool.
15:49:47 <lollan> thanks Calele
15:49:48 <lollan> thanks Cale
15:49:51 <jethr0> > (second . (=<<)) (Just . (+1) ("abc", Nothing)
15:49:52 <lambdabot>  parse error on input `}'
15:49:58 <Philippa> @djinn a -> Int
15:49:58 <lambdabot> -- x cannot be realized.
15:50:05 <Heffalump> Philippa: the only possible implementation for a -> b is const undefined
15:50:07 <Heffalump> (type-safe)
15:50:09 <jethr0> > (second . (=<<)) (Just . (+1)) ("abc", Nothing)
15:50:10 <lambdabot> ("abc",Nothing)
15:50:11 <Heffalump> @djinn Integer -> Int
15:50:12 <lambdabot> -- x cannot be realized.
15:50:21 <Heffalump> @djinn Int -> (Int,Int)
15:50:21 <lambdabot> x :: Int -> (Int, Int)
15:50:21 <lambdabot> x x1 = (x1, x1)
15:50:39 <soysauce> jethr0 - I'm trying to do a quick-n-dirty parser with in continuation-passing style
15:50:41 <Heffalump> @djinn (a - b) -> [a] -> [b]
15:50:41 <lambdabot> Cannot parse command
15:50:43 <Pseudonym> @djinn (a, b) -> (b, a)
15:50:44 <lambdabot> x :: (a, b) -> (b, a)
15:50:44 <lambdabot> x (v2, v3) = (v3, v2)
15:50:45 <Heffalump> @djinn (a -> b) -> [a] -> [b]
15:50:46 <lambdabot> -- x cannot be realized.
15:50:51 <Heffalump> hmph.
15:50:52 <jethr0> aha
15:50:57 <soysauce> I want to build it from simpler functions, similar to how ReadS works
15:51:00 <Heffalump> @djinn (a -> b) -> (b -> c) -> (a -> c)
15:51:01 <lambdabot> x :: (a -> b) -> (b -> c) -> a -> c
15:51:01 <lambdabot> x x1 x2 x3 = x2 (x1 x3)
15:51:07 <dons> doesn't seem to know much about lists
15:51:10 <jethr0> is it for fun or for real?
15:51:12 <soysauce> so each function takes a continuation and then String -> (String, Maybe a)
15:51:16 <soysauce> the latter
15:51:20 <soysauce> for an assignment for class
15:51:22 <Heffalump> @djinn a -> [a]
15:51:22 <lambdabot> -- x cannot be realized.
15:51:25 <dons> @djinn a -> Maybe a
15:51:25 <lambdabot> -- x cannot be realized.
15:51:29 <Heffalump> @djinn a
15:51:30 <lambdabot> -- x cannot be realized.
15:51:42 <dons> @djinn (a -> b) -> (c -> b) -> Either a c -> b
15:51:43 <lambdabot> x :: (a -> b) -> (c -> b) -> Either a c -> b
15:51:43 <lambdabot> x x1 x2 x3 = case x3 of
15:51:43 <lambdabot>      Left l4 -> x1 l4
15:51:43 <lambdabot>      Right r5 -> x2 r5
15:51:47 <Heffalump> ok, so it really is just a propositional solver
15:51:50 <Heffalump> oh, it knows Either.
15:51:52 <jethr0> hmm, could get pretty ugly if you start before you know what you want :)
15:51:54 <Heffalump> @djinn a -> Maybe a
15:51:55 <lambdabot> -- x cannot be realized.
15:51:58 <soysauce> I need to parse really simple things, basically I have lines with 2 or 3 integers on them and need to repeatedly parse them
15:52:00 <Heffalump> but not Maybe. Weird
15:52:12 <Heffalump> @djinn (a -> b) -> b -> Maybe a -> b
15:52:12 <lambdabot> x :: (a -> b) -> b -> Maybe a -> b
15:52:12 <lambdabot> x _ x2 _ = x2
15:52:19 <soysauce> so I built a function that throws away whitespace, another function that eats until the end of the line, and a function that parses an integer
15:52:26 <jethr0> so, basically you just do (>>=) in CPS?
15:52:26 <dons> ah.
15:52:35 <soysauce> no, I want the equivalent of that
15:52:37 <Cale> @djinn (a -> b) -> (c -> d) -> (Either b d -> e) -> Either a c -> e
15:52:37 <lambdabot> x :: (a -> b) -> (c -> d) -> (Either b d -> e) -> Either a c -> e
15:52:37 <lambdabot> x x1 x2 x3 x6 = case x6 of
15:52:37 <lambdabot>       Left l7 -> x3 (Left (x1 l7))
15:52:37 <lambdabot>       Right r8 -> x3 (Right (x2 r8))
15:52:41 <Igloo> @djinn (a -> b) -> (a -> b)
15:52:41 <lambdabot> x :: (a -> b) -> a -> b
15:52:41 <lambdabot> x x1 x2 = x1 x2
15:52:42 <jethr0> yes, that's what i meant!
15:52:50 <soysauce> I can already combine these to parse out a line, and if there's a parse error then I get (String, Nothing)
15:52:54 <soysauce> that way I know where parsing stopped
15:53:08 <ihope> Hmm, now ol' djinn looks pretty useful...
15:53:19 <Cale> @djinn (a -> b) -> (c -> Either d e) -> (Either b d -> e) -> Either a c -> e
15:53:19 <lambdabot> x :: (a -> b) -> (c -> Either d e) -> (Either b d -> e) -> Either a c ->
15:53:19 <lambdabot> e
15:53:19 <lambdabot> x x1 x2 x3 x6 = case x6 of
15:53:19 <lambdabot>       Left l7 -> x3 (Left (x1 l7))
15:53:19 <lambdabot>       Right r8 -> case x2 r8 of
15:53:21 <lambdabot>            Left l9 -> x3 (Right l9)
15:53:23 <lambdabot>            Right r10 -> r10
15:53:26 <Cale> :)
15:53:28 <ihope> @djinn (a -> b -> c -> d) -> (a -> b -> c) -> (a -> b) -> a -> d
15:53:29 <lambdabot> x :: (a -> b -> c -> d) -> (a -> b -> c) -> (a -> b) -> a -> d
15:53:29 <lambdabot> x x1 x2 x3 x4 = x1 x4 (x3 x4) (x2 x4 (x3 x4))
15:53:29 <jethr0> soysauce, you could pass through in an error continuation
15:53:36 <soysauce> error continuation?
15:53:53 <ihope> Substituted substituted substituted identity.
15:54:15 <Heffalump> @djinn Either a b -> Either b a
15:54:15 <lambdabot> x :: Either a b -> Either b a
15:54:15 <lambdabot> x x1 = case x1 of
15:54:15 <lambdabot>    Left l2 -> Right l2
15:54:15 <lambdabot>    Right r3 -> Left r3
15:54:16 <jethr0> like "parseFunc cont error = if ... then cont result else error "message""
15:54:24 <soysauce> BTW, I am writing it in a convoluted manner for 1) fun 2) challenge 3) prestige ;)
15:54:25 <Heffalump> @djinn Either a b -> Either b b
15:54:26 <lambdabot> -- x cannot be realized.
15:54:32 <soysauce> ah, interesting idea
15:54:34 <Heffalump> @djinn Either a a -> Either b a
15:54:35 <lambdabot> x :: Either a a -> Either b a
15:54:35 <lambdabot> x x1 = case x1 of
15:54:35 <lambdabot>    Left l2 -> Right l2
15:54:35 <lambdabot>    Right r3 -> Right r3
15:54:53 <Heffalump> @djinn , the new #haskell spambot :-)
15:54:57 <ihope> :-)
15:55:06 <jethr0> and, you could define (|>>|) or something to do your continuation passing for you
15:55:09 <Cale> sorry, it's just too much fun :)
15:55:09 <benny> man, programming in haskell can sometimes be really annoying. things that take 2 short lines in c take a huge block of code in haskell :(
15:55:17 <ihope> I have a question: map is to zipWith as fmap is to what?
15:55:23 <soysauce> I'm trying to extract maximum performance since we've been benchmarking our programs in a competition, it's somewhat entertaining
15:55:32 <dons> benny, like what?
15:55:34 <Heffalump> benny: like what?
15:55:39 <Cale> benny: really? I think on average it's pretty good :)
15:55:39 <dons> should almost always be less code, if you know what you're doing :)
15:55:43 <soysauce> benny - my experience has been the opposite
15:55:44 <jethr0> "input |>>| sym1 |>>| sym2 |>>| sym3" or sth like it :)
15:55:45 <Heffalump> bah, too slow with my outraged houl of denial
15:55:54 <Heffalump> s/houl/howl/
15:56:15 <benny> here's an example, i have a data X = Double Double Double Double Double Double Double Double Double
15:56:27 <dons> yikes.
15:56:28 <jethr0> missing a constructor
15:56:29 <benny> and i have a zero = X 0 0 0 0 0 0 0 0 0
15:56:30 <soysauce> you need a ctor
15:56:36 <soysauce> what are you trying to do exactly?
15:56:37 <Heffalump> jethr0: Double is a constructor
15:56:39 <benny> yeah, forgot the "X" in there
15:56:41 <soysauce> that looks more like a tuple
15:56:47 <Heffalump> ah, ok
15:56:50 <ihope> Yeah...
15:56:52 <benny> i meant data X = X Double Do....
15:56:53 <Heffalump> I see where this is going.
15:57:01 <benny> anyway, so i want to make a value X 0 0 0 0 0 1 0 0 0 0
15:57:07 <Heffalump> you have to process each element individually, whereas in another language you'd make a loop?
15:57:12 <dons> wrong kind of data type ;)
15:57:14 <benny> no, in other languages i could do:
15:57:16 <ihope> Lists!
15:57:27 <benny> a = zero(); a.elem4 = 1;
15:57:27 <jethr0> maybe it has to be fixed length!
15:57:28 <Cale> yeah, why are you not using a list?
15:57:32 <Cale> or an array
15:57:35 <dons> > (replicate 10 0)
15:57:35 <benny> fixed length
15:57:36 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
15:57:38 <soysauce> benny - with a record you can do that.
15:57:41 <Cale> Use an array!
15:57:47 <Heffalump> data X = X { elem0 :: Double, elem1 :: Double, ... }
15:57:49 <ihope> Lists don't have fixed length...
15:57:58 <jethr0> nah, record is just as bad!
15:58:01 <Heffalump> a = zero { elem4 = 1 }
15:58:02 <soysauce> data X = X {d1::Double, d2::Double, ...}
15:58:03 <benny> array is too messy, i actually have more things then just Double
15:58:17 <soysauce> set4th x v = x { d4=v }
15:58:19 <soysauce> I think.
15:58:20 <Heffalump> it's record update syntax
15:58:27 <jethr0> yup
15:58:27 <dons> how would you do this in C, benny?
15:58:30 <Cale> Well, you ought to think about your data differently -- what are you trying to do?
15:58:31 <ihope> You want to toss variable numbers of the same thing into one data structure?
15:58:48 <Cale> Why do you have to carry around so much data in one big blob?
15:58:50 <soysauce> benny - is this an array of bits?
15:58:52 <ihope> Yeah!
15:58:56 <Heffalump> look, we've provided a solution for his actual problem, stop criticising his data type :-)
15:59:00 <benny> ok guys, here is what i am *reall* doing:
15:59:02 <ihope> :-)
15:59:12 <benny> data Vector3 = Vector3 Double Double Double
15:59:19 <Heffalump> you see, he wouldn't have had to tell us this if we'd just limited ourselves to the question asked.
15:59:23 <benny> data Matrix3 = Matrix3 Vector3 Vector3 Vector3
15:59:26 <Cale> benny: okay
15:59:32 <Heffalump> benny: record syntax really will solve this problem
15:59:33 <benny> data Mass = Mass Double Vector3 Matrix3
15:59:39 <ihope> data Make3 a = Make3 a a a
15:59:41 <benny> now i need to make a Mass value
15:59:53 <ihope> ...Never mind
16:00:07 <Heffalump> though changing nested stuff isn't entirely pleasant
16:00:19 <soysauce> v0 = Vector3 0.0, 0.0, 0.0
16:00:21 <ihope> Abstraction! Use functions to access the data!
16:00:27 <soysauce> m0 = Matrix3 v0 v0 v0
16:00:29 <Heffalump> data Vector3 = Vector3 { d0 :: Double, d1 :: Double, d2 :: Double }
16:00:35 <soysauce> mass0 = Mass 0.0 v0 m0
16:00:44 <Heffalump> data Matrix3 = Matrix3 { v0 :: Vector3, v1 :: Vector3, v2 :: Vector3 }
16:00:46 <jethr0> not everyone at once; what a ruckus!
16:00:52 <soysauce> but do what Heffalump suggested, records are much nicer to work with.
16:00:58 <ihope> Heh
16:01:07 <Cale> You should have an abstract vector-space class, of which matrix and vector are instances
16:01:09 <benny> hm... i don't quite understand how record syntax would help
16:01:16 <snat> @djinn a -> a
16:01:17 <lambdabot> x :: a -> a
16:01:17 <lambdabot> x x1 = x1
16:01:17 <Heffalump> data Mass = Mass { d :: Double, v :: Vector3, m :: Matrix 3 }
16:01:46 <soysauce> benny: setMass x m = x { mass = m } -- set the mass of object x
16:01:48 <Heffalump> zeroVec = Vector3 0.0 0.0 0.0
16:01:49 <jethr0> cale, that's just overengineered :)
16:02:02 <Heffalump> zeroMat = Matrix3 zeroVec zeroVec zeroVec
16:02:08 <Cale> jethr0: I don't think so -- it would make a lot of things nicer
16:02:13 <Heffalump> zeroMass = Mass 0.0 zeroVec zeroMat
16:02:29 <Heffalump> ok, so now you want to set the middle element of the middle vector of the matrix to 1
16:02:44 <benny> yes please continue Heffalump 
16:02:45 <jethr0> it would be nice, but vector-space sounds so algebraic :P
16:02:47 <soysauce> benny: setXVel obj vx = obj { velocity = (velocity obj) { x = vx } }
16:03:00 <Cale> jethr0: hehe :)
16:03:03 <soysauce> and so forth
16:03:28 <jethr0> soysauce, you don't have to repeat unchanged values!
16:03:29 <Heffalump> newMass = zeroMass { m = (m zeroMass) { v1 = (v1 $ m zeroMass) { d1 = 1.0 } } }
16:03:38 <soysauce> jethr0 - ?
16:03:40 <jethr0> same goes for heffalump
16:03:46 <Heffalump> so not quite as concise as in C etc, but not far off.
16:03:50 <Heffalump> jethr0: huh?
16:04:09 <Heffalump> I had to list all the things on the path from the thing to change to the root of the structure
16:04:09 <jethr0> sorry, my bad
16:04:11 <benny> yeah... in c i could just do this: newMass = zeroMass(); newMass.m.v1.x = 1;
16:04:16 <jethr0> nested records
16:04:18 <snat> @help djinn
16:04:19 <lambdabot>  @djinn <type>
16:04:19 <lambdabot> Generates Haskell code from a type.
16:04:20 <Cale> jethr0: another nice thing would be to have a function which takes a function f :: Vector -> Vector, and assumes that it's linear, and gives the corresponding matrix, and vice versa.
16:04:37 <Heffalump> well, you can't have everything, but it's not that much worse
16:04:41 <soysauce> benny - you set all fields when you create the object, if it's so painful then you can write functions that modify them "in-place" (this actually creates a new object)
16:04:47 <jethr0> yeah, i always liked the concept of linear function inversion
16:04:49 <soysauce> but usually there is a better, more functional way to do it
16:04:52 <jethr0> but it's oh-so-limited
16:05:10 <lennart> @djinn a->a->a
16:05:10 <lambdabot> x :: a -> a -> a
16:05:10 <lambdabot> x _ x2 = x2
16:05:18 <Heffalump> it's a shame that there is no way to write a function that abstracts over record selectors
16:05:35 <soysauce> benny - e.g. you probably want to modify the matrix as a unit, not update individual fields in the matrix
16:05:58 <soysauce> mat3mal :: Matrix3 -> Matrix3 -> Matrix3
16:06:21 <soysauce> er, mat3mul
16:06:32 <soysauce> rotobj obj m = obj { orientation = mat3mul (orientation obj) m }
16:06:34 <ihope> Most things are only referentially transparent to some point. If Haskell were completely referentially transparent, the only function you could define would be "id".
16:06:48 <benny> soysauce: i want a matrix that is a zeroMatrix but where the main diagnol has specified values... how can i create this value easily?
16:06:59 <jethr0> ihope, examples?
16:07:10 <Cale> jethr0: well, this lets you write matrices more conveniently:  matrix (\(x,y,z) -> (2*y,x,x+z)) rather than Matrix3 (Vector3 0 2 0) (Vector3 1 0 0) (Vector3 1 0 1)
16:07:15 <ihope> Do-notation with the IO monad...
16:07:18 <benny> without doing Matrix3 (Vector3 x 0 0) (Vector3 0 y 0) (Vector3 0 0 z))
16:07:33 <jethr0> cale, but it gets messy for more complicated matrices!
16:07:34 <soysauce> benny - Matrix3 (Vector3 a 0 0) (Vector3 0 b 0) (Vector3 0 0 c)
16:07:41 <int-e> @djinn (a->b->c) -> (a->b) -> a -> c
16:07:41 <lambdabot> x :: (a -> b -> c) -> (a -> b) -> a -> c
16:07:41 <lambdabot> x x1 x2 x3 = x1 x3 (x2 x3)
16:07:43 <ihope> One could make setVar and getVar functions for that one.
16:07:49 <jethr0> no, you are right, you mean a simple projection!
16:08:03 <soysauce> benny - it's not that different from writing {{a, 0, 0}, {0, b, 0}, {0, 0, c}}
16:08:04 <int-e> @djinn (a->a) -> a
16:08:04 <lambdabot> -- x cannot be realized.
16:08:25 <benny> soysauce: you are comparing to c?
16:08:29 <soysauce> yes
16:08:32 <int-e> @djinn (a->a) -> a -> a
16:08:33 <lambdabot> x :: (a -> a) -> a -> a
16:08:33 <lambdabot> x _ x2 = x2
16:08:47 <int-e> @djinn (a->b) -> a -> b
16:08:47 <lambdabot> x :: (a -> b) -> a -> b
16:08:47 <lambdabot> x x1 x2 = x1 x2
16:08:55 <jethr0> aahhh, stop *djinning*
16:09:01 <benny> soysauce: well, in c i could do, m = zeroMatrix(); m[0][0]=x; m[1][1]=y; m[2][2]=z;
16:09:26 <soysauce> benny:
16:09:34 <int-e> jethr0: sorry. it's a new toy. it'll be boring soon enough :)
16:09:47 <soysauce> updm0 m v = m { v0 = v }
16:09:55 <dons> @seen autrijus
16:09:56 <lambdabot> autrijus has changed nick to audreyt.
16:09:56 <lambdabot> audreyt is in #haskell. I don't know when audreyt last spoke.
16:09:57 <soysauce> updv0 v x = v { x0 = x }
16:10:14 <soysauce> setm00 m x = m { v0 = updv0 v0 x }
16:10:45 <soysauce> you can define a matrix as a tuple of scalar values instead of 3 vectors, and it'll be easier to update
16:10:56 <soysauce> but that has other drawbacks
16:12:01 <soysauce> you could also do something a bit nastier like so:
16:13:10 <soysauce> updm m i j x = let v = case i of 0 -> v0 m; 1 -> v1 m; 2 -> v2 m in case j of 0 -> v { x0 = x }; 1 -> v { x1 = x; }; 2 -> v { x2 = x; }
16:13:27 <soysauce> now you can do updm zeroMatrix 0 0 x and you modify m[0][0]
16:13:54 <soysauce> I'm not 100% sure about that syntax; I would write it on multiple lines
16:14:43 <soysauce> if you wanted to get really fancy then you could create update functions yourself
16:14:58 <soysauce> updm0 :: (Vector3 -> Vector3) -> Matrix -> Matrix
16:15:09 <soysauce> updm0 f m = m { v0 = f (v0 m) }
16:15:44 <soysauce> you just need a little bit more glue, and then it's really, really simple
16:16:42 <benny> hm... i'm just going with explicity constructors for everything. it's actually not that bad
16:16:57 <soysauce> you have to have ctors in either case
16:17:19 <Cale> benny: yeah
16:17:36 <Cale> writing getters and setters for everything is awkward
16:17:46 <soysauce> yes, definitely
16:18:04 <Cale> Really, you either want a higher-level view of the data altogether, or just use the constructors :)
16:18:05 <jethr0> > let zw f = zipWith (zipWith f); mm f = map (map f); mat = [[1,0,0],[0,1,0],[0,0,1]] in transpose $ mm (+1) $ zw (+) mat mat
16:18:06 <lambdabot> [[3,1,1],[1,3,1],[1,1,3]]
16:18:08 <jethr0> :)
16:18:36 <soysauce> jethr0 - doesn't express n-dimensional matrices very well since it could be jagged or have other oddities
16:18:39 <ihope> > error "Hello, world!" undefined
16:18:39 <lambdabot> Add a type signature
16:18:44 <jethr0> just joking
16:18:45 <ihope> ;-)
16:18:59 <Cale> soysauce: still, that's often a convenient representation
16:19:02 <benny> maybe this is an appropriate time to mention something that bothers me about haskell: it may be a language based on really sweet theory, and it may be very powerful, but in terms of actual pragmatic syntax and user-friendliness, a lot of other languages beat haskell. i'm talking about even c# and friends
16:19:04 <soysauce> yeah, it is
16:19:27 <soysauce> benny - not at all
16:19:36 <Cale> I have a neat little bit of gaussian elimination code (probably got it somewhere) which works on that representation
16:19:39 <jethr0> benny, it depends on your view on programming and the paradigm you're using
16:19:44 <Cale> There's a nice recursive algorithm :)
16:20:19 <jethr0> if you're thinking imperatively you're right, but once you've gotten used to the functional ways, haskell's syntax becomes nicer and nicer!
16:21:01 <benny> i'm talking about simple syntactic things... like in c#, when you use enumed values, you must prefix them with the enum name:
16:21:06 <Cale> benny: I'd say Haskell is quite a lot more user friendly than something like C
16:21:07 <benny> Color.Red, Color.Blue
16:21:09 <jethr0> cale, i like the fact that "transpose" is already predefined :)
16:21:16 <benny> Cale: yeah, c is bad
16:21:20 <Cale> jethr0: yeah, that's nice
16:21:33 <Cale> benny: you can get that in Haskell too
16:21:40 <soysauce> modules
16:21:52 <benny> Cale: you mean modules?
16:21:56 <Cale> yes
16:22:02 <Cale> and qualified import
16:22:17 <benny> ok... but how about default arguments to functions?
16:22:20 <jethr0> what i don't get is why multiple modules per files aren't allowed...
16:22:25 <Cale> default?
16:22:27 <soysauce> benny - define another function
16:22:37 <Philippa> default => partial application
16:22:43 <jethr0> benny, C can't do it and java has serious short-comings in that respect!
16:22:50 <benny> how about named function arguments? f(a=b, c=d)
16:23:02 <jethr0> neither C, C++ nor java have that
16:23:04 <benny> jethr0: ok, but there is also python, ruby
16:23:10 <Philippa> take a record for a parameter if you really really want it
16:23:13 <Cale> named function arguments seem to be solved by record types
16:23:14 <jethr0> ruby doesn't
16:23:25 <Cale> create a record type
16:23:27 <Philippa> more realistically, comment by the side of each arg
16:23:32 <Philippa> 'cos they're going on separate lines anyway
16:23:57 <jethr0> well, it's a nifty feature. but until now i haven't really missed it in haskell!
16:24:12 <Philippa> I'd want it if my funcs started to take more parms
16:24:16 <benny> guess i just need to use haskell more and get used to it :)
16:24:23 <jethr0> :)
16:24:26 <Cale> The real solution to that one is for Haskell to have a bit nicer of a record system
16:24:29 <Philippa> in practice I tend to find I've missed an opportunity for a monad when that's happening though
16:24:43 <Philippa> Cale: I'm not convinced on that one
16:24:52 <Philippa> doing that loses you partial application
16:25:21 <Cale> Philippa: hmm... what if it didn't? :)
16:25:44 <Philippa> that's one hell of a record system you've got there that lets you treat partially applied functions as records ;-)
16:25:55 <Philippa> (or similarly, records as functions)
16:25:55 <jethr0> hehe
16:26:17 <jethr0> (fun {a = "a", b = "b"}) {c = "c"}
16:26:23 <Cale> um, hmm -- I meant functions from one record type could be partially applied
16:26:41 <Cale> to take values from a deleted record type
16:26:49 <Cale> like jethr0 demonstrated
16:26:53 <jethr0> that would kick the sh*t out of "flip"!
16:27:13 <shapr> Whoa, djinn r0xx
16:27:35 <jethr0> that wasn't meant as a proof of concept!
16:28:04 <lollan> sorry 
16:28:20 <audreyt> dons: yo
16:28:25 <lennart> Thanks, shapr :)
16:28:27 <lollan> i am learning haskell and i don't understand waht is a gaurd
16:28:34 <Cale> jethr0: it was well-timed nonetheless :)
16:28:34 <lollan> is it this : |
16:28:36 <lollan> ?
16:28:42 <shapr> hej lennart, hu mÃ¥r du?
16:28:44 <Cale> lollan: yes
16:28:45 <shapr> hur*
16:28:48 <lollan> thanks
16:28:51 <lennart> bra, tack
16:29:04 <shapr> Har du skrivit djinn?
16:29:10 <Cale> lollan: in general, it's a condition which must hold for some code to be activated
16:29:12 <lennart> ja
16:29:22 <shapr> hÃ¤ftigt
16:29:34 <lennart> den aer lite kul
16:29:35 * jethr0 doesn't particularly like guards...
16:29:53 <Cale> I think they have their place
16:29:53 <lollan> Cale : if i use a guard my function must return something true that's it ?
16:29:55 <shapr> jo, mycket kul... Ã¤r det i darcs repon Ã¤n? Jag vill veta hur det fungerar.
16:29:56 <Philippa> I like some uses, don't like others
16:30:06 * shapr grabs the latest repo
16:30:15 <Cale> lollan: it returns something based on which condition holds first
16:30:21 <jethr0> cale, sure, but especially a single guard looks ugly!
16:30:24 <Cale> here's an example
16:30:31 <lennart> det staar hur du kan haemta den i mitt email till haskell-listan
16:30:35 <Cale> (they look terrible on one line)
16:30:35 <shapr> Ah yes, it's in the repo.
16:30:39 <shapr> jasÃ¥...
16:30:54 <musasabi> swedish in the middle of a dark night...
16:31:05 <lennart> yeah, it sure is dark here
16:31:13 <Cale> > let f x | x < 5 = 'a' | x == 5 = 'b' | otherwise = 'c' in map f [0..10]
16:31:14 <lambdabot> "aaaaabccccc"
16:31:20 <jethr0> *argh*
16:31:29 <jethr0> that's exactly what i meant :P
16:31:30 <Cale> normally, you'd write it on multiple lines
16:31:32 <lollan> thanks Cale
16:31:34 <Cale> and line up the |'s
16:31:40 <shapr> musasabi: minÃ¤ en puhu suomea!
16:31:42 <lollan> i am going study this now
16:31:58 <shapr> lennart: Is this your first time on #haskell? I won't even ask you if you want the introduction to programming in Haskell :-)
16:32:19 <Cale> lennart: ask for the intro anyway!
16:32:23 <Cale> hehe
16:32:26 <lennart> I've been on here couple of times over the years, but not much.
16:32:30 <jethr0> > let f x | x < 5 = True | True = False in f 4
16:32:31 <lambdabot> True
16:32:43 <jethr0> *yuch*
16:32:44 <shapr> Ok, just curious.
16:32:48 <lennart> is there an automated intro? :)
16:33:02 <Philippa> yeah. Shapr's a bot, didn't you know?
16:33:04 * shapr grins
16:33:06 * jethr0 is anxious to see the automated intro!
16:33:06 <lollan> Cale , jethr0 what is the return value of your function ?
16:33:10 <lennart> aha!
16:33:16 <lollan> how can you know ?
16:33:25 <shapr> I do often give the tour of #haskell and Haskell.
16:33:25 <Pseudonym> shapr: @djinn IO ()
16:33:27 <Philippa> "automated" as in he's automatically your mate (but not in that sense)
16:33:28 <shapr> :-P
16:33:34 <Cale> lollan: let me reformat things a little :)
16:33:39 <jethr0> @type f x | x < 5 = True | otherwise = False
16:33:40 <lambdabot> parse error on input `|'
16:33:43 <lollan> ok
16:33:51 * shapr bounces cheerfully.
16:34:16 <Cale> f x | (x < 5)   = 'a' 
16:34:16 <Cale>     | (x == 5)  = 'b' 
16:34:16 <Cale>     | otherwise = 'c'
16:34:18 <musasabi> shapr: that is quite passable :-)
16:34:19 <jethr0> lollan, is your question related to the guards?
16:34:24 <shapr> Djinn is cool. I have no idea how it works, but it's nifty.
16:34:36 <lennart> it's a theorem prover
16:34:47 <lollan> jethr0 no it is for the return value now
16:34:49 <Philippa> @djinn Either a b -> Either b b
16:34:49 <lambdabot> -- x cannot be realized.
16:34:58 <Philippa> there's at least one obvious function of that type...
16:34:58 <shapr> Do you have links to the papers, or should I just google for Roy Dyckhoff?
16:35:01 <lollan> ah ok Cale i understoof
16:35:08 <Cale> which gets translated to  f x = if x < 5 then 'a' else if x == 5 then 'b' else 'c'
16:35:14 <Cale> (or some equivalent)
16:35:15 <jethr0> lollan, it takes an Int and return a Char
16:35:22 <lollan> ok
16:35:23 <jethr0> takes a Num
16:35:25 <lennart> there's no total function of that type
16:35:25 <Philippa> OK, there's one /useful/ function of that type and a few that use _|_
16:35:26 <lollan> we are not oblige to use ( ) 
16:35:56 <lollan> ok thanks Cale and jethr0
16:35:57 <Cale> lollan: yeah
16:35:59 <lennart> djinn will never generate function with any kind of bottom
16:36:00 <jethr0> np
16:36:07 <Philippa> wait, no, of course - most of them use _|_ :-)
16:36:18 <Philippa> sorry, I'm really tired tonight and thus not thinking straight - especially when I forget an important case
16:36:39 <lollan> lol
16:36:47 <lennart> @djinn Either a b -> Either b a
16:36:47 <lambdabot> x :: Either a b -> Either b a
16:36:47 <lambdabot> x x1 = case x1 of
16:36:47 <lambdabot>    Left l2 -> Right l2
16:36:47 <lambdabot>    Right r3 -> Left r3
16:36:53 <Philippa> (it's thus a good job djinn doesn't merely offer me three wishes)
16:37:10 <lennart> i thought of having it quit after 3 tries
16:37:30 <Cale> It would be nice if it knew about some other axioms, like the monad functions ;)
16:37:56 <jethr0> @djinn Maybe a -> a
16:37:56 <lambdabot> -- x cannot be realized.
16:38:06 <Xianianol> Is it easy to implement on a working interpreter (that evaluates math expressions) so that it shows the evaluation steps ?
16:38:06 <lennart> any other axioms would probably involve universal quantification, and it would no longer be decidable
16:38:11 <Philippa> jethr0: same problem as my Either example
16:38:20 <jethr0> @djinn Maybe (a, b) -> Maybe (b,a)
16:38:21 <lambdabot> -- x cannot be realized.
16:38:25 <jethr0> *grr*
16:38:34 <Philippa> jethr0: it's not allowed to return _|_
16:38:41 <ihope> *Everything* of type Either a b -> Either b b uses _|_, I think.
16:38:41 <lennart> djinn doesn't know about Maybe :)
16:38:45 <Philippa> @djinn Maybe a -> a -> a
16:38:46 <lambdabot> x :: Maybe a -> a -> a
16:38:46 <lambdabot> x _ x2 = x2
16:38:49 <jethr0> philippa, i guess "a -> b" is generally a problem!
16:39:04 <ihope> @type let bot = bot in const bot
16:39:05 <lambdabot> forall a b. b -> a
16:39:14 <Philippa> jethr0: you see why my func on Maybe works and yours didn't?
16:39:14 <Cale> @djinn Either () (a,b) -> Either () (b,a)
16:39:15 <lambdabot> x :: Either () (a, b) -> Either () (b, a)
16:39:15 <lambdabot> x x1 = case x1 of
16:39:15 <lambdabot>    Left l2 -> Left ()
16:39:15 <lambdabot>    Right r3 -> case r3 of
16:39:15 <lambdabot>         (v5, v6) -> Left ()
16:39:32 <Cale> um, that proof sucks :)
16:39:37 <jethr0> philippa, well yours simply ignores the maybe...
16:39:37 <Cale> hehe
16:39:39 <bd__> @djinn Monad m => a -> m a
16:39:40 <lambdabot> Cannot parse command
16:39:46 <Philippa> jethr0: that's just 'cos it's the trivial one
16:39:54 <shapr> Wow, Dyckhoff has publications about both Dummet and GÃ¶del. That sounds like the kind of thing I want to read.
16:39:58 <Philippa> lennart: any chance of convincing it not to generate const variants unless it has to?
16:40:12 <Cale> lennart: it should mark the preconditions as it goes and try to use as many as it can
16:40:43 <Philippa> jethr0: yes, but that's because it's valid regardless of what constructor's used. In your case, it doesn't have anything valid it can do in case of a Maybe
16:40:48 <Philippa> er, a Nothing even
16:40:50 <ihope> Why isn't _|_ an actual Haskell value?
16:41:03 <jethr0> i don't understand, how "Maybe (a,b) -> Maybe (b,a)" is so different from "(a,b) -> (b,a)"
16:41:04 <Philippa> it's a djinn, nothing said it had to generate /useful/ functions
16:41:05 <Cale> ihope: well, there's no specific syntax for it
16:41:07 <lennart> it's tricky to know what the "good" functions are.  you are welcome to modify djinn :)
16:41:08 <benny> Cale: you know how to calculate the inertia tensor of a sphere?
16:41:13 <Philippa> jethr0: same reason Maybe a -> a fails
16:41:20 <Cale> benny: I don't know much physics at all
16:41:25 <Pseudonym> benny: You use integral calculus.
16:41:29 <Pseudonym> :-)
16:41:35 <jethr0> Nothing -> a is non-trivial
16:41:38 <benny> Cale: yeah, it's more mathematics then physics :)
16:41:53 <Philippa> jethr0: oh, it's trivial. There's exactly one answer: _|_. Djinn's not allowed to use it
16:41:56 <bd_> @djinn Maybe (a, b) -> Maybe (b, a)
16:41:57 <lambdabot> -- x cannot be realized.
16:42:00 <Cale> lennart: well, functions that consume their arguments somehow are "better" than those which don't.
16:42:00 <Philippa> 'lo Beelsebob
16:42:01 <bd_> mhm
16:42:13 <lennart> Cale, true
16:42:15 <Pseudonym> benny: http://integrals.wolfram.com/ is your friend.
16:42:32 <lennart> It's an interesting idea.  I'll think about it.
16:42:33 <jethr0> but "case x of Just (a,b) -> Just (b,a); Nothing -> Nothing" isn't so hard, is it
16:42:55 <Philippa> jethr0: point
16:42:56 <jethr0> it's pretty much the same as for the working either case
16:43:06 <ihope> @djinn (((((((() -> b) -> b) -> b) -> b) -> b) -> b) -> b)
16:43:06 <lennart> jethr0, djinn doesn't know about Maybe.  only tuple, Either, and functions
16:43:07 <lambdabot> -- x cannot be realized.
16:43:07 <shapr> lennart: Shall I send darcs patches to your chalmers address? I'd like to submit a README that includes urls to the relevant papers.
16:43:18 <jethr0> Either, but not Maybe *tststs*
16:43:28 <Cale> yeah, that proof is better because it makes use of the extra values which are available in that case
16:43:39 <lennart> shhapr, a good address is given in the :help message
16:43:43 <ihope> @djinn ()
16:43:43 <shapr> ok
16:43:43 <lambdabot> x :: ()
16:43:43 <lambdabot> x = ()
16:43:48 <Philippa> lennart: how easy is it to teach it new types and constructors, preferably from a data file?
16:43:59 <jethr0> preferably automatically :)
16:44:06 <audreyt> dons: trhsx's build system is broken
16:44:21 <lennart> Philippa, I think it's hard in general.  But it would be interesting
16:44:22 <MarcWeber> Hi. Do you have any idea what might be the cause of this error: http://www.rafb.net/paste/results/ovCqgI50.html? I'm trying to create a cabal version of hdirect because I can't compile ihc with SUPPORT_TYPELIBS=YES by now... I hope that the undefined reference errors will be gone then
16:44:22 <jethr0> slurp (map readFile allHaskellFiles) >>= djinn
16:44:41 <audreyt> dons: I've sent a patch to d00nibro@cs.chalmers but it may or may not reach there. if you have commit to the hsx repo, can you push this hunk in?
16:44:44 <audreyt> hunk ./src/trhsx/trhsx.cabal 6
16:44:46 <Pseudonym> benny: http://scienceworld.wolfram.com/physics/MomentofInertiaSphere.html
16:44:47 <audreyt> -Build-Depends:         haskell-src-exts
16:44:49 <audreyt> +Build-Depends:         haskell-src-exts -any, haskell98 -any, base -any
16:45:04 <Cale> MarcWeber: looks like maybe ffi is turned off?
16:45:05 <audreyt> dons: without this, I can't build hsplugins and consequently pugs can't inline haskell anymore
16:45:18 <benny> Pseudonym: thanks
16:45:46 <Philippa> audreyt: who rechristened you, JOOI?
16:45:54 <shapr> Yeah, I was curious about the nick change also.
16:46:00 <MarcWeber> Cale: Thanks, will look it up.
16:46:12 <Cale> MarcWeber: -fffi
16:46:21 <Cale> is the relevant switch for ghc
16:46:42 <shapr> lennart: Thanks for the cool code!
16:47:10 <Cale> yeah, @djinn is quite impressive already, even if it doesn't write our entire programs for us yet :)
16:47:55 <Cale> I remember reading a paper about doing this sort of thing
16:48:27 <shapr> Proof oriented programming?
16:48:40 <shapr> This is way cool stuff.
16:48:44 <Cale> Specifically about finding witnesses of Haskell types
16:48:51 <Cale> I can't recall where I saw it
16:49:12 <Pseudonym> It was an Oleg paper.
16:49:18 <shapr> I am unsurprised.
16:49:25 <Pseudonym> Yeah, thought you wouldn't be.
16:49:32 <Cale> heh
16:49:38 <lennart> heh
16:49:39 <Pseudonym> All the best type hacks are partly or wholly from Oleg.
16:49:47 <ihope> @djinn (a,b,c,d,e,f,e,g,a,h,i,i,b) -> (a,e,i,i,b,f,h,d,g,a,c,e,b)
16:49:47 <lambdabot> x :: (a, b, c, d, e, f, e, g, a, h, i, i, b) -> (a, e, i, i, b, f, h, d,
16:49:47 <lambdabot> g, a, c, e, b)
16:49:47 <lambdabot> x (_, _, v4, v5, _, v7, v8, v9, v10, v11, _, v13, v14) = (v10,
16:49:47 <lambdabot>                     v8,
16:49:47 <lambdabot>                     v13,
16:49:49 <shapr> Aren't GADTs about phantom type witnesses too?
16:49:49 <lambdabot> [10 @more lines]
16:50:06 <ihope> Ooi!
16:50:27 <Cale> hahaha
16:50:38 <ihope> @more
16:50:38 <lambdabot>                     v13,
16:50:38 <lambdabot>                     v14,
16:50:38 <lambdabot>                     v7,
16:50:38 <lambdabot>                     v11,
16:50:38 <lambdabot>                     v5,
16:50:39 <shapr> That's why these days we say, "That'll require at least an oleg of type hackery."
16:50:40 <lambdabot> [5 @more lines]
16:51:04 * ihope feels this is a bug
16:51:10 <lennart> hmmmm, obviously i need to improve the pretty printing
16:51:16 <Cale> it's just a pretty-printer thing
16:51:37 * jethr0 wonders whether template haskell can read from stdin at compile-time *brr*
16:51:50 <shapr> jethr0: Yup
16:51:53 <jethr0> cool
16:52:05 <jethr0> echo "hello world" | ghc --make th.hs
16:52:10 <jethr0> -fth
16:52:38 <shapr> jethr0: Before hs-plugins came along, I had the crazy idea of doing runtime reloading by running the whole program in ghc --make.
16:52:53 <Cale> Pseudonym: do you remember the title?
16:53:10 <jethr0> that is a horribly nasty idea!
16:53:14 <shapr> Thank you :-)
16:53:42 <jethr0> shapr, have your worked with TH?
16:53:49 <shapr> lennart: If I disorganize another IOHCC, would you have time to enter?
16:53:59 <ihope> Horribly nasty ideas are what esoteric programming languages are all about...
16:54:14 <shapr> jethr0: Yeah, I wrote the TemplateHaskellTutorial on the wiki, remember?
16:54:27 <lennart> shapr, perhaps.  but it's too easy in haskell ;)
16:54:28 <MarcWeber> Cale: Thanks. Now I get ghc.exe: flag `' is incompatible with source file `c:/DOKUME~1/Marc/LOKALE~1/Temp/ghc2112.p_hc' but this file is no longer there.. ;-( What does p_hc mean? .hc means c file generated by ghc..
16:54:28 <Philippa> ihope: don't get me started
16:54:28 <jethr0> sure, just didn't know whether you actually used them
16:54:43 <Philippa> I have some really horribly sick (and potentially rather useful) plans involving template haskell and hs-plugins
16:54:43 <Pseudonym> Cale: Nope.
16:54:48 <Cale> MarcWeber: hmm, odd
16:54:54 <audreyt> Philippa: JOOI?
16:54:57 <Cale> MarcWeber: I don't really know what's going on there
16:55:00 <jethr0> shapr, i'm working on the tutorial right now. but i don't get from where one can reify? other modules, same module, ...?
16:55:04 <Pseudonym> I measure my type hackery in milli-olegs.
16:55:27 <MarcWeber> Cale: Perhaps I should try using an older ghc version which works with the hdirect sources..
16:55:27 <shapr> jethr0: Other modules.
16:55:34 <shapr> Which sux, imho.
16:55:36 <jethr0> philippa, loved your THCompiler!
16:55:42 <Philippa> audreyt: "Just Out Of Interest"
16:55:49 <shapr> But I haven't tried to fix it myself so, I can't complain much.
16:56:06 <Philippa> jethr0: it's a fun hack, isn't it? I should use it for a real language sometime
16:56:07 <jethr0> i guess it has sth to do with breaking static scoping, etc
16:56:14 <lollan> i create a simple function to calculate the the absolute value of a number
16:56:28 <lollan> but where i do abs -3
16:56:36 <lollan> there is a mistake
16:56:40 <jethr0> hmm, getting typing to work in the AST is a real problem... it's getting more into compiler construction that a fun project
16:56:43 <Philippa> *argh*. I now have the urge to implement a compiler for a reflective language on top of TH+hs-plugins
16:56:43 <musasabi> Philippa: use it for Haskell ;)
16:56:45 <lollan> do you konw why ?
16:56:51 <Cale> lollan: abs (-3)
16:56:52 <ihope> What is the function?
16:56:58 <ihope> Ah
16:57:04 <musasabi> then we have Haskell compiler running inside Haskell compiler ;)
16:57:05 <jethr0> philippa, i was trying to parse a subset of haskell (still am), but the parsing/typing get's me kinda down
16:57:10 <lollan> lol thanks Cale i am really bad on it
16:57:10 <Cale> abs - 3 is the same as subtracting 3 from abs
16:57:44 <lollan> ok
16:57:46 <jethr0> philippa, hopefully i can parse directly into the TH AST. that would spare me a lot of trouble
16:57:47 <Cale> I kind of think we should require whitespace between infix operators and the things they apply to
16:57:55 <Philippa> jethr0: I've not written a typechecker for haskell as a whole. You can do a basic hindley-milner typechecker fairly easily if you're comfortable with unification and have a nice core language to desugar to though
16:58:01 <Cale> so that prefix - is unambiguous
16:58:03 <Philippa> it would also be cheating :-)
16:58:06 <audreyt> Philippa: oh, I changed it myself; it's part of this transgender process I'm going through.
16:58:08 <lollan> ok
16:58:09 <jethr0> btw, i have no idea how haskell determines how many arguments a function has. is it done type driven??
16:58:16 <Cale> lollan: (but it doesn't do that)
16:58:23 <Cale> jethr0: yes
16:58:31 <ihope> Every function has one argument.
16:58:34 <Cale> well, really, functions always have one argument
16:58:41 <lollan> lol
16:58:42 <jethr0> philippa, i don't mean type checking. i mean parsing stuff like n-ary functions, etc
16:58:50 <MarcWeber> Cale: Do you mean (-3).abs ?
16:58:51 <jethr0> lalala
16:58:54 <shapr> lennart: I've always thought Haskell was harder to obfuscate than C. But I believe you.
16:59:00 <Cale> MarcWeber: hm?
16:59:14 <Philippa> audreyt: in that case I suggest you change your userinfo :-)
16:59:18 <Cale> MarcWeber: lollan was asking why "abs -3" didn't work
16:59:21 <MarcWeber> Is should read lollan question first..
16:59:38 <audreyt> Philippa: how do I do it in runtime?
16:59:43 <lollan> :)
16:59:46 <audreyt> or would it require /bye and relogin?
16:59:51 <Philippa> audreyt: the latter
17:00:02 <audreyt> (I've /set user_info already)
17:00:05 <audreyt> aha. bbiab
17:00:10 <Philippa> jethr0: you just don't. It's much easier to treat as a series of single applications
17:00:20 <Cale> I think it would actually be nice if "abs -3" and "abs - 3" were different, but I think some people would scream
17:00:32 <ihope> Hmm...
17:00:35 <jethr0> yup, for now i put parens around all expressions... *LISP Style*
17:00:37 * ihope likes
17:00:54 <ihope> (...the distiction between -3 and - 3)
17:00:56 <shapr> jethr0: I think Sean Seefried found a way to turn modules into TH ASTs for PanTHeon, check it.
17:00:59 <Cale> require whitespace around infix functions
17:01:00 <audreyt> Philippa: better?
17:01:08 <Philippa> yep
17:01:15 <audreyt> thanks :)
17:01:22 <jethr0> shapr, no, he puts the whole module inside a quasi-quote
17:01:27 <Cale> which would also mean we'd be free to use hyphen in identifier names
17:01:52 <jethr0> lisp/scheme style function name with hyphen are actually quite cool
17:01:53 <Cale> (lisp-style)
17:01:57 <Cale> yeah
17:01:57 <shapr> jethr0: Oh... hey, you want to turn this into a TMR article?
17:02:09 <jethr0> what? the tutorial?
17:02:28 <shapr> Yeah
17:02:28 <ihope> Would it be possible to have an instance declaration like "instance Show a where"?
17:02:53 <jethr0> if a where a valid class name...
17:03:13 <Xianianol> A question, if someone ask you to implement "stepwise evaluation" it means an evaluation that counts how many steps it is needed to do the evaluation or show how the evaluation is done, step-by-step ?
17:03:14 <jethr0> "a" were
17:04:28 <shapr> lennart: Do you get paid to write Haskell?
17:04:41 <Pseudonym> @djinn ((a -> c -> c) -> c -> c) -> (a -> (b -> d -> d) -> d -> d) -> (b -> e -> e) -> e -> e
17:04:41 <lambdabot> x :: ((a -> c -> c) -> c -> c) -> (a -> (b -> d -> d) -> d -> d) -> (b ->
17:04:41 <lambdabot> e -> e) -> e -> e
17:04:41 <lambdabot> x _ _ _ x4 = x4
17:04:48 <jethr0> shapr (re TMR), what? the tutorial?
17:05:03 <shapr> Yes
17:05:28 <jethr0> hmm, let's see how far i take this. and if it becomes really cool and up to the TMR standards, gladly!
17:05:33 <shapr> spiffy!
17:05:44 <jethr0> cracking toast, gromit
17:06:07 <jethr0> shapr, are you british?
17:06:09 <shapr> Xianianol: I think it means an evaluator that only does one step at a time, so you can later make it recursive if you want.
17:06:23 <shapr> jethr0: Nah, I'm a good old boy from Alabama, living in Sweden/Finland the last six years.
17:06:46 <jethr0> i'd have sworn that someone who came up with "spiffy" had to be a brit :)
17:06:51 <jethr0> is that even known in the US?
17:07:11 <ihope> I think so.
17:07:12 <shapr> But I speak decent chunks of Swedish and French. I can understand a bit of Finnish too.
17:07:31 <jethr0> cool
17:07:32 <ihope> Well, I speak good English ;-P
17:07:32 <ricebowl> jethr0 - it is
17:07:42 <jethr0> i stand corrected
17:07:49 <shapr> ihope: Are you in Michigan?
17:07:57 <ihope> Yes
17:08:02 <jethr0> @babel en en spiffy
17:08:03 <lambdabot> Module "babel" produced error: Prelude.head: empty list
17:08:10 <ricebowl> it isn't widely used AFAIK, but I have heard it often enough
17:08:22 <jethr0> @babel en de spiffy
17:08:24 <lambdabot>  spiffy
17:08:29 <jethr0> :(
17:08:29 <Xianianol> One step each time ? Humm, is just that one of the earlier requested implementation was an evaluator that does evaluation recursively...I wouldn't expect it to ask something already that is done.
17:09:02 <jethr0> xianianol, "stepwise" doesn't sound like "step counting" to me
17:09:18 <jethr0> it rather sounds like "step - read key - repeat"
17:09:26 <shapr> Spiffy is an old word, last popular in the forties or fifties I think. I decided to use it for 'delightful' or 'unexpected quality'.
17:09:43 <jethr0> i know what it means, it's just so spiffy!
17:09:48 * shapr boings cheerfully
17:10:42 <Xianianol> Humm, so like...if I eval the an expression 5+5+5, it would show "5+5=10" and then "10+5=15"
17:11:13 <jethr0> depends on your step size really :)
17:11:19 <shapr> I'd say 5+5+5 would become 10+5
17:11:30 <Xianianol> So, I don'
17:11:36 <ihope> I'd like (+) ((+) 5 5) 5
17:11:43 <Xianianol> (argh), so I don't show the results ?
17:11:45 <shapr> Yeah, what ihope wrote.
17:11:55 <Xianianol> I like infix!
17:12:02 <jethr0> ('+ ('+ 5 5) 5) == ('+ 5 5 5)
17:12:08 <shapr> 5 `plus` (5 `plus` 5)
17:12:15 <ihope> Apostrophe...
17:12:20 <jethr0> 5 5 5 (+) (+)
17:12:30 <ihope> Oh yeah!
17:12:34 <Xianianol> «@shapr» : At that case, my parser already does that...
17:12:36 <jethr0> reverse polish notation
17:12:46 <ihope> We can do everything backwards: [3,2] head
17:13:04 <Xianianol> It would give 5 :+ 5 ( 5 :+ 5 )
17:13:07 <shapr> Is the lambda evaluator plugin still in lambdabot?
17:13:13 <jethr0> ihope, funnily i might even get that to work with template haskell :)
17:13:15 <shapr> @lambda joy "5 5 5 + +"
17:13:16 <lambdabot> Unknown command, try @listcommands.
17:13:30 <ihope> Lambda?
17:13:35 <shapr> @lambda joy "5 5 5 + +"
17:13:36 <lambdabot> [15]
17:13:43 <jethr0> wtf
17:13:55 <jethr0> is that "joy" the language?
17:14:10 <shapr> Yup, it's a minimal joy interpreter on top of a lambda calculus evaluator.
17:14:17 <shapr> @get-definition joy
17:14:18 <lambdabot> joy = either id (flip joyEval [] . fst) . joyParse
17:14:21 <jethr0> @lambda joy "5 2 2 * 1 + -"
17:14:22 <ihope> Can it evaluate Lazy K programs?
17:14:22 <lambdabot> [0]
17:14:27 <shapr> @get-definition joyParse
17:14:27 <lambdabot> joyParse = runMonad MonadParser joyExpr
17:14:42 <gzl> woah
17:14:51 <shapr> @get-definition joyExpr
17:14:51 <lambdabot> joyExpr = many $ choice [bind (squares joyExpr) (return . Left),bind
17:14:51 <lambdabot> identifier (return . Right),bind_ (sat (\c.c=='\'')) $ bind next $ \c.
17:14:51 <lambdabot> bind_ spaces $ return (Left c),bind parseNum $ \n.bind_ spaces $ return (
17:14:51 <lambdabot> Left n)]
17:15:07 <ihope> Ork?
17:15:09 <jethr0> yup, maybe we should @pl that
17:15:14 <lollan> It's me again :)
17:15:26 <lollan> this definition is it correct ?
17:15:27 <soysauce> it's yuo
17:15:30 <shapr> lambda was in there long before dons wrote hs-plugins. What impressed me was how easy it was to confuse the simple lambda cal evaluator with full Haskell.
17:15:30 <lollan> power :: Int -> Int -> Int
17:15:31 <lollan> power x0 = 1
17:15:31 <lollan> power xn | n > 0 = power x(n-1) *x 
17:15:50 <soysauce> hmm, wait a minute
17:15:51 <jethr0> lollan, you should reverse the two lines
17:15:54 <ihope> Haskell *is* lambda...
17:15:57 <shapr> It showed me just how thin is the layer between lambda cal and Haskell.
17:16:15 <ihope> Aye, it's quite thin.
17:16:29 <lollan> jethr0 ??
17:16:32 <jethr0> lollan, it takes the first declaration/pattern that fits, and x0 matches all
17:16:39 <lollan> ok
17:16:55 <jethr0> i'd rather write:
17:16:58 <jethr0> power 0 = 1
17:17:11 <jethr0> power n = power (n-1) * n
17:17:21 <ihope> Factorial?
17:17:28 <lollan> yes
17:17:34 <lollan> i try understand
17:17:37 <ihope> fac n = product [1..n]
17:17:51 <jethr0> lollan, i don't understand what all the "x" are doing there?
17:17:55 <lollan> so jethr0 why do i must reverse these to lines ?
17:17:58 <MarcWeber> Cale: Thanks & g.night
17:18:28 <jethr0> x0 is an identifier which will match any argument. 0 will only match 0
17:18:42 <resiak> I think power x n is meant to be x ** n
17:18:42 <lollan> jethr0 i want to do this : power xn = x * x * x * x (n times)
17:18:57 <lollan> yes resiak
17:18:59 <jethr0> ok, sorry
17:19:01 <ihope> Hmm, I think you can do that.
17:19:02 <lollan> that's it
17:19:09 <ihope> Using foldr and... stuff.
17:19:14 <soysauce> power x n = foldr (*) (repeat n x)
17:19:19 <ihope> Yeah!
17:19:24 <soysauce> of course, (**) is better
17:19:30 <soysauce> > foldr (*) (repeat 3 2)
17:19:31 <lollan> it's just something to understand
17:19:31 <lambdabot>   The function `repeat' is applied to two arguments,
17:19:31 <lambdabot>   but its type `a -> [a]' has only one
17:19:34 <jethr0> lollan, i was just missing whitespace between "x" and "n"
17:19:36 <soysauce> er, replicate
17:19:39 <soysauce> > foldr (*) (replicate 3 2)
17:19:40 <lambdabot>  add an instance declaration for (Show ([[a]] -> [a]))
17:19:41 <ihope> Does Haskell have a *** operator?
17:19:51 <jethr0> yes, but it's an arrow operator
17:19:53 <soysauce> > replicate 3 2
17:19:53 <lollan> ans i don't know what is reapeat and other stuff :)
17:19:54 <lambdabot> [2,2,2]
17:19:59 <soysauce> oh, d'oh
17:20:03 <soysauce> > foldr1 (*) (replicate 3 2)
17:20:03 <jethr0> > 4 ** 4
17:20:04 <lambdabot> 8
17:20:05 <lambdabot> 256.0
17:20:05 <lollan> ok thanks jethr0 and others :)
17:20:16 <jethr0> > 4 `exp` 4
17:20:17 <lambdabot>  add an instance declaration for (Floating (t -> a))
17:20:17 <lambdabot>   In the definition of `ovm': ovm = 4 `exp` 4
17:20:17 <lambdabot>   In the definition of `v': v = let ovm = 4 `exp` 4 in take 2048 (show
17:20:17 <lambdabot> ovm)
17:20:42 <ihope> foldr1 (**) (replicate 3 3)
17:20:49 <soysauce> > foldr1 (**) (replicate 3 3)
17:20:50 <lambdabot> 7.625597484987e12
17:20:54 <ihope> :-)
17:20:55 <soysauce> you need the >
17:21:06 <soysauce> hmm, strange, it shouldn't be that big
17:21:13 <ihope> Shouldn't it?
17:21:14 <soysauce> that's (3^3)^3 = 27^3
17:21:25 <soysauce> = 19683
17:21:30 <jethr0> sth like "sequence (replicate (3*)) would be nice :)
17:21:37 <ihope> > foldl1 (**) (replicate 3 3)
17:21:38 <lambdabot> 19683.0
17:21:43 <ihope> Moop.
17:21:47 <soysauce> well wtf?
17:21:58 <soysauce> oh, maybe it did 3^27
17:22:09 <soysauce> yes, that would seem to be it.
17:22:20 <ihope> That was what I meant it to do.
17:22:23 <jethr0> (3 ** (3 ** 3))
17:22:32 <soysauce> yeah
17:22:38 <ihope> > (3 ** (3 ** 3))
17:22:39 <lambdabot> 7.625597484987e12
17:22:40 <lollan> wata
17:22:45 <lollan> Haskell powaa
17:22:57 <ihope> Whataa?
17:22:59 <jethr0> damn, i did foldr *arg*
17:23:11 <jethr0> foldl = ((3 ** 3) ** 3)
17:23:12 <soysauce> > foldl (:) [] [1,2,3]
17:23:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:23:13 <lambdabot>   Expected type: a -> [a] -> a
17:23:13 <lambdabot>   Inferred type: a -> [a] -> [a]
17:23:18 <soysauce> > foldl (flip (:) [] [1,2,3]
17:23:19 <lambdabot>  parse error on input `}'
17:23:22 <soysauce> > foldl (flip (:)) [] [1,2,3]
17:23:23 <lambdabot> [3,2,1]
17:23:33 <soysauce> whee
17:23:53 <jethr0> > ((3 ** 3) ** 3)
17:23:53 <lollan> ihope it is wata
17:23:54 <lambdabot> 19683.0
17:23:58 <lollan> not whata
17:24:04 <lollan> :)
17:24:05 <ihope> :-)
17:24:09 <ihope> Oh wellaa.
17:24:13 <lollan> lol
17:24:22 <ihope> You mean lolaa...
17:25:40 <ihope> How about a Haskell function that does that to every word in a string?
17:25:52 <soysauce> @type (>>=)
17:25:53 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
17:26:26 <jethr0> unwords . map (++"a") . words $ "hello world"
17:26:28 <jethr0> > unwords . map (++"a") . words $ "hello world"
17:26:29 <lambdabot> "helloa worlda"
17:26:36 <ihope> Aha
17:26:43 <jethr0> > unwords . map (++"a") . words $ "there is no such thing as a free lunch"
17:26:44 <lambdabot> "therea isa noa sucha thinga asa aa freea luncha"
17:27:01 <ihope> Now strip out the letter 'h'...
17:27:01 <lollan> if i call a function with more than one paramater
17:27:18 <lollan> i do func(a,c,c)
17:27:21 <jethr0> > unwords . map (++"a") . words . filter (/='h') $ "there is no such thing as a free lunch"
17:27:23 <lambdabot> "terea isa noa suca tinga asa aa freea lunca"
17:27:23 <soysauce> filter ((/=) 'h')
17:27:24 <lollan> is it good ?
17:27:32 <soysauce> haha
17:27:35 <ihope> Arr!
17:27:40 <soysauce> lollan - no
17:27:57 <lollan> func(a b c)
17:27:58 <soysauce> lollan - here, the (+) is a function
17:28:00 <soysauce> @type (+)
17:28:01 <lambdabot> forall a. (Num a) => a -> a -> a
17:28:04 <soysauce> that is the type
17:28:07 <ihope> Currying is good...
17:28:08 <soysauce> @eval (+) 1 2
17:28:10 <lambdabot> 3
17:28:15 <soysauce> @eval (+) (1, 2)
17:28:15 <lambdabot>  add an instance declaration for (Show ((a, b) -> (a, b)))
17:28:28 <jethr0> > add == (+)
17:28:28 <lambdabot>  Not in scope: `add'
17:28:36 <soysauce> um, interesting... well, anyway, you can't pass parameters like that
17:28:39 <soysauce> (x, y, z) is a tuple
17:28:50 <int-e> @eval (curry (+)) (1, 2)
17:28:50 <lambdabot>   add an instance declaration for (Show (b -> ((a, b1), b) -> ((a, b1), b)
17:28:50 <lambdabot> ))
17:28:59 <soysauce> if you do that, then your function takes one parameter, and that parameter is a tuple...but most functions aren't written this way
17:29:13 <jethr0> > uncurry (+) (1,2)
17:29:14 <int-e> @eval (uncurry (+)) (1, 2)
17:29:14 <lambdabot> 3
17:29:14 <soysauce> int-e - uncurry, isn't it?
17:29:15 <lambdabot> 3
17:29:19 <soysauce> :p
17:29:23 <ihope> :-)
17:29:34 <soysauce> lollan - watch this
17:29:37 <int-e> soysauce: I'm never sure which one is which.
17:29:37 <soysauce> @type (+)
17:29:38 <lambdabot> forall a. (Num a) => a -> a -> a
17:29:40 <soysauce> @type (+) 1
17:29:41 <lambdabot> forall a. (Num a) => a -> a
17:29:51 <jethr0> that's what i'm talking about
17:29:54 <soysauce> @type (1+)
17:29:55 <lambdabot> forall a. (Num a) => a -> a
17:30:02 <ihope> What if Haskell had automatic fmapping?
17:30:03 <soysauce> 1+ is a special syntax
17:30:07 <soysauce> @eval (1+) 2
17:30:08 <lambdabot> 3
17:30:13 <ihope> > (+1)
17:30:14 <lambdabot>  add an instance declaration for (Show (a -> a))
17:30:38 <jethr0> @type (*2) . (+1) 
17:30:40 <lambdabot> forall a. (Num a) => a -> a
17:31:04 <lollan> what is Num ?
17:31:12 <soysauce> it's a class
17:31:24 <jethr0> @pl \a b c -> 2*a-4*a*c+6b
17:31:25 <lambdabot> (. 6) . flip . ((+) .) . ap ((.) . (-) . (2 *)) ((*) . (4 *))
17:31:25 <lollan> why i must use this class ?
17:31:26 <soysauce> it means that the function takes any type a, but that type must be a "Num"
17:31:39 <soysauce> lollan - you don't need to worry about it
17:31:40 <ihope> It acts on numbers...
17:31:45 <lollan> lol
17:32:10 <ihope> @type 345
17:32:10 <lambdabot> forall t. (Num t) => t
17:32:23 <soysauce> heh, that's pretty cool... functions of 0 arguments ;)
17:32:39 <ihope> A function with no arguments is... not a function.
17:32:43 <soysauce> template<typename T> T one() { return 1; } // not as cool
17:32:45 <soysauce> sure it is
17:32:45 <lollan> power :: Int -> Int -> Int
17:32:45 <lollan> power x 0 = 1
17:32:45 <lollan> power x n | n > 0 = power x(n-1) *x 
17:32:53 <jethr0> ihope, a function with null arguments is a null-ary function
17:32:59 <lollan> when i ant use it it do'ent work 
17:33:09 <ihope> Isn't a nullary function just the same as the value it returns?
17:33:09 <lollan> i do power(2 3 )
17:33:15 <soysauce> lollan - in the second case, n is always > 0
17:33:16 <jethr0> yes, so?
17:33:22 <soysauce> lollan - try this:
17:33:25 <soysauce> power :: Int -> Int -> Int
17:33:27 <soysauce> power x 0 = 1
17:33:34 <ihope> Mmh.
17:33:41 <jethr0> ihope, that's the whole basis of lambda calculus. this way _everything_ is a function!
17:33:42 <soysauce> power x n = power (x*x) (n-1)
17:33:48 <soysauce> that doesn't compute the correct power, though
17:33:54 <soysauce> err, wait, sorry :)
17:34:00 <lollan> ok
17:34:01 <soysauce> power x n = x*(power x (n-1))
17:34:14 <ihope> Indeed, everything's a function in lambda calculus...
17:34:14 <shapr> hej bojohan 
17:34:36 <bojohan> hej
17:34:41 <soysauce> shapr tycker om svenska hälsningar ;)
17:34:53 <soysauce> or is it svenskt?
17:34:55 <ihope> More foreign language?
17:35:24 <jethr0> let true (a,b) = a; false (a,b) = b; myif cond thn els = cond (thn, els) in myif true "yes" "no"
17:35:29 <jethr0> > let true (a,b) = a; false (a,b) = b; myif cond thn els = cond (thn, els) in myif true "yes" "no"
17:35:30 <lambdabot> "yes"
17:35:35 <jethr0> > let true (a,b) = a; false (a,b) = b; myif cond thn els = cond (thn, els) in myif false "yes" "no"
17:35:36 <lambdabot> "no"
17:35:40 <shapr> ihope: Same old Swedish.
17:35:59 <ihope> Blue Swede shoes...
17:36:05 * soysauce is much better with Spanish than with Swedish but opts to refrain
17:36:07 <shapr> soysauce: C'mon, I was born a poor white chile in South Alabama, it's amazing I can speak English, much less other languages :-)
17:36:15 <twb> Did I hear about a quickCheck that could handle monads (i.e. functions of type a -> IO)?
17:36:16 <soysauce> haha
17:36:27 <ihope> fmap quickCheck?
17:36:29 <soysauce> if it counts, I was born in Texas ;) but I've always been a "city slicker"
17:36:30 <ihope> :-)
17:36:33 <shapr> twb: QuickCheckM can handle any monad with a run function.
17:36:56 <ihope> Oh right. What's the difference between a functor and a monad?
17:36:56 <twb> All I know is that I can't work out how to use quickCheck with parseTest.
17:37:24 <shapr> Speaking of testing, does anyone know how I can make an HUnit test that *requires* failure?
17:37:37 <soysauce> shapr - I will have to practice, I suppose, since you are much better at it than I
17:37:43 <shapr> I'm testing authentication via XmlRpc, and I want to make sure that anon users cannot access certain items.
17:37:43 <jethr0> shapr, isn't that a paradox?
17:37:46 <twb> shapr: I can't do that in quickCheck, either... :-(
17:37:57 <Igloo> Just negate the result before returning it to hunit...
17:38:22 <shapr> XmlRpc throws an error, so just catch expected errors or rethrow?
17:38:30 <shapr> Hm, makes sense...
17:38:42 <shapr> soysauce: I live in Sweden, that helps.
17:38:44 <jethr0> catch (... `seq` fail) (\_ -> succeed)
17:38:51 <soysauce> I'm sure ;)
17:39:04 <soysauce> but I've gotten markably good at Spanish without ever having visited a foreign country aside from Canada
17:39:07 <shapr> I'm sure you can find a Swedish group in any large city though.
17:39:27 <soysauce> well, 20% of the students at my university are foreign, I'm sure there are some Swedes here
17:39:38 <soysauce> though unlikely any with any motivation to teach
17:39:48 <shapr> Nah, just hang out and speak Swedish.
17:40:03 <soysauce> attempt it at least :p
17:40:21 <soysauce> but usually what happens when one person is learning another's language and they have another language in common is that they settle on the common language
17:40:41 <soysauce> I didn't really learn much Spanish until I started talking to Spanish-speakers who spoke no English
17:40:49 <jethr0> shapr, would this help: catch (... `seq` fail) (\_ -> succeed)
17:40:54 <soysauce> when it's do-or-die then the rules of the game change
17:41:04 <ihope> Espa[insert corrent character here]ol!
17:41:12 <shapr> jethr0: I'll try it, thanks.
17:41:13 <jethr0> ñ
17:41:55 <Heffalump> shapr: when did QuickCheckM appear?
17:42:27 <shapr> 2002
17:42:41 <Heffalump> oh, I thought that was just for ST
17:42:45 <soysauce> ihope - español
17:42:48 <Heffalump> what they did in 2002, that is
17:42:51 <shapr> This is 2005, right?
17:42:52 <Xianianol> Gah...Can't see how it is possible to do this...If I convert it into String to show a step then there is no way I can evaluate it as an int for my next step...Can't see a recrusive method in this...
17:42:57 <soysauce> standard practice is to write espanol if you lack the character
17:43:04 <Heffalump> yes
17:43:15 <ihope> How about *all* the Spanish special characters? :-)
17:43:34 <Heffalump> oh, looks like I was wrong anyway
17:43:37 <shapr> Â¿por que?
17:43:37 <jethr0> @babel en es haskell in the house
17:43:41 <lambdabot>  haskell en la casa
17:43:47 <ihope> How about "espannol"?
17:43:57 <soysauce> that works, too, or espanyol
17:44:00 <shapr> espaÃ±ol?
17:44:05 <Heffalump> the example given was ST, but the abstract suggests it's more general
17:44:06 <Xianianol> Espanhol ?
17:44:24 <jethr0> espa~nol
17:44:24 <shapr> Heffalump: Yup, like I said, any monad with a run method. IO works too if you use unsafePerformIO.
17:44:28 <soysauce> ñ is the only special character except for accent marks, but most native speakers don't write them and wouldn't know where to put them anyway
17:44:36 <jethr0> ¿
17:44:39 <ihope> Really?
17:44:45 <Xianianol> Does spanish has "ç" ?
17:44:45 <soysauce> and nobody writes the upside-down question mark
17:44:47 <jethr0> ¡
17:44:49 <soysauce> Xianianol - no
17:45:02 <soysauce> it is on the Spanish keyboard, but it isn't a letter in their alphabet
17:45:04 <Xianianol> Oooh, Portuguese has that!
17:45:06 <shapr> I have used QuickCheck to test IO monad using code. unsafePerformIO works fine if you're careful with the sharing.
17:45:33 <ihope> What's the complement of ord?
17:45:40 <shapr> Thing is, you don't need QuickCheckM to test IO monad code if you use unsafePerformIO.
17:45:51 <benny> is there something like assert in haskell?
17:45:59 <musasabi> @index assert
17:45:59 <soysauce> there is error
17:45:59 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
17:46:01 <shapr> Not unless you're using the model or specification based testing.
17:46:18 <soysauce> > [1,2,3] !! 4
17:46:19 <lambdabot> Exception: Prelude.(!!): index too large
17:46:24 <shapr> Which I am :-)
17:46:32 <musasabi> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#15
17:46:34 <Philippa> benny: if cond then rest else error "some message"
17:46:41 <Philippa> feel free to abstract it out into a HOF
17:46:53 <Heffalump> not a HOG
17:46:54 <benny> Philippa: problem with that is the "rest" part
17:46:55 <Heffalump> IM HOF
17:47:00 <jethr0> shapr, btw, it has to be Control.Exception.catch.
17:47:08 <Heffalump> benny: why?
17:47:15 <Heffalump> assert (x==y) (do stome stuff with x and y)
17:47:15 <dons> @seen autrijus
17:47:15 <lambdabot> autrijus has changed nick to audreyt.
17:47:15 <lambdabot> audreyt is in #haskell-blah and #haskell. Last spoke 45 minutes and 59
17:47:15 <lambdabot> seconds ago.
17:47:17 <benny> if you need lots of "asserts" then you get killer nesting :(
17:47:20 <Philippa> benny: make it the last parm of a HOF instead and it sorta reads right
17:47:21 <ihope> > let { bot = bot ; assert True = True ; assert False = error "False assertion" } in assert False
17:47:22 <lambdabot> Exception: False assertion
17:47:22 <dons> audreyt?
17:47:51 <soysauce> benny - usually it isn't necessary to make explicit assertions; if you omit cases then the assertion is made for you automatically
17:48:18 <jethr0> > let f 1 = 2; f 2 = 1 in f 3
17:48:19 <lambdabot>  Non-exhaustive patterns in function f
17:48:20 <benny> hm... interesting point
17:48:35 <soysauce> yeah... it's not particularly helpful, unfortunately
17:48:55 <soysauce> it would be much nicer to say "Non-exhausitve patterns in function f: Failed to match `f 3'"
17:49:00 <soysauce> but not all types are Showable
17:49:13 <soysauce> anyway, it is sufficient
17:49:23 <jethr0> well, error localisation isn't haskell's forte, anyways
17:49:25 <jethr0> > head []
17:49:26 <lambdabot> Add a type signature
17:49:27 <ihope> instance a Show where show a = ""
17:49:31 <soysauce> and if you are careful, you can often use the type system to enforce your constraints at compile-time
17:49:32 <araujo> Hi hi!
17:49:33 <jethr0> > head [] :: Int
17:49:34 <lambdabot> Exception: Prelude.head: empty list
17:49:51 <dons> audreyt, hs-plugins doesn't need hsx.. ?
17:50:34 <ihope> With Dvorak, it's easy to type PFY. Just type RYT.
17:50:44 <shapr> aoeuhtns?
17:51:14 <jethr0> i gave up dvorak because i mainly typed code and most languages are optimized for US kb layout
17:51:15 <ihope> D and I...
17:52:08 <araujo> Hi dons 
17:52:30 <Korollary> jethr0: how fast could you write code anyway? Most of my coding is scrolling up and down, copy-paste'ing variable names, function names from docs, etc. 
17:53:15 <dons> hey araujo
17:53:23 <jethr0> still, on the german keyboard the braces, brackets, ... are so horribly placed that your hands die before you even begin
17:53:36 <ihope> :-)
17:53:44 <jethr0> and also there isn't really a standardized/good dvorak layout for german umlaute
17:54:14 <jethr0> so i'd have neither good umlaute nor good coding keys, so i dropped it.
17:54:14 <araujo> dons, --libdir is the option to specify a library directory other than exec_prefix/lib/  in hs-plugins?
17:54:15 <Korollary> jethr0: ah. They should make new keyboards with more keys with more symbols for coders.
17:54:36 <dons> araujo, hmm. whatever Cabal does..
17:54:47 <dons> ./Setup.lhs configure --help ?
17:54:47 <jethr0> it's really amazing how very specialized almost all languages are for the US layout. and how utterly unusable for some "foreign" ones!
17:55:10 <ihope> ASCII!
17:55:36 <Korollary> jethr0: keyboard locales are an afterthough anyways. Nowadays there are a lot of US keyboards that mess with the locations of |, INS, etc. They should just add another row.
17:55:47 <araujo> dons, Let me check.... 
17:56:07 <ihope> Why do we even still have the Never-Used Three?
17:56:32 <audreyt> dons: yeah but they are built together
17:56:37 <Korollary> ihope: People freak out if they don't see ScrollLock
17:56:39 <audreyt> I'm going to unsw now... ttul &
17:56:51 <dons> ok.
17:56:56 <ihope> The key or the light?
17:57:06 <dons> I'll see you soon then
17:57:16 <Korollary> ihope: good point. Those led's are ultimately useful, too.
17:57:33 <dons> audreyt, hs-plugins shouldn't need any of nibro's stuff. it's optional.
17:57:37 * jethr0 remapped his caps lock, because it's the most useless invention ever
17:57:47 <twb> shapr: so, do you have some working code using quickCheck and an IO function?
17:58:16 <Korollary> jethr0: it's somewhat useful, but it deserve that prime location.
17:58:20 <Korollary> err it does not
17:58:32 <dons> doesn't everyone remap caps lock to ctrl?
17:58:40 <twb> No, I remapped it to compose.
17:58:43 <Korollary> I don't
17:58:45 <jethr0> i never "shout" and even if i can easily type all upper-case reasonably fast!
17:58:51 <jethr0> twb, me too
17:59:23 <twb> I use hyper and meta as much as control, so it would be too confusing to use the upper control.
17:59:39 <jethr0> actually i mapped caps [a,o,u,s,n] to the respective umlaute, cedille, ...
17:59:51 <ihope> I'd like to remap caps lock to option.
18:00:05 <ihope> Tricky do do on a PC, I'd think.
18:00:39 <twb> ihope: option?  You mean meta?
18:00:40 <jethr0> ihope, you mean under windows
18:00:43 <benny> soysauce: but there are situations where unless you give an explicit assert then you won't get one made automatically
18:00:54 <benny> dons: i think there is a bug in hs-plugins btw
18:00:56 <ihope> The Macintosh option key...
18:01:03 <ricebowl> benny - yes, there are, but they are fairly rare
18:01:07 <jethr0> ah
18:01:08 <ricebowl> er, d'oh
18:01:10 * ricebowl == soysauce
18:01:10 <dons> benny, you said about files closing?
18:01:17 <benny> dons: yes
18:01:18 <twb> ihope: that is congruent to the Alt key on a PC keyboard.
18:01:23 <dons> benny, mail me a test case, could be quite easy to fix. just an hFlush ;)
18:01:30 <dons> dons (AT) cse.unsw.edu.au
18:01:36 <ihope> There's no useful option+e.
18:01:41 <dons> even better, darcs send the fix ... ;)
18:01:51 <benny> dons: ok, i'll make a test case, but the gist of it is if there is an error during the merge stage then the plugin file isn't closed properly
18:01:53 <ihope> Nor option+n, option+1, option+?...
18:02:04 <benny> hm... i'll try darcs sending it :)
18:02:05 <twb> ihope: huh?
18:02:09 <dons> ah, this is fairly untested on my part, so could well be, benny
18:02:14 <jethr0> cool, it's possible to introduce dynamic scope into haskell with TH
18:02:24 <dons> yes
18:02:27 <araujo> dons, In the hs-plugin 9.10 tarball doesn't exist Setup.hs
18:02:28 <ihope> The combining diacriticals and upside-down puncuation.
18:02:32 <dons> check the TH paper for evil stuff jethr0 ;)
18:02:37 <twb> ihope: perhaps you have mapped the option key to mode-switch.
18:02:43 <dons> araujo, Setup.lhs ?
18:02:44 <jethr0> dons, i'm on it!
18:02:59 <araujo> dons, neither that one
18:03:03 <jethr0> dons, would be nice to have a dynamic scope monad, or something :P
18:03:04 <dons> araujo, the 0.9.10 tarball doesn't use Cabal...
18:03:05 <twb> On PCs that is generally only mapped on Alt_R (sometimes printed as AltGr)
18:03:12 <dons> you need the darcs version for that
18:03:30 <ihope> twb: http://en.wikipedia.org/wiki/Option_key#Alternative_keyboard_input
18:03:30 <dons> jethr0, I don't think you can use the words "nice" and "dynamic scope" in the same sentence
18:03:33 <araujo> dons, yes, i thought so, but i am using the tarball version
18:03:51 <dons> I recommend the darcs version :)
18:04:08 <jethr0> dons, look at perl. dynamic scope doesn't seem to harm its reputation *cough*
18:04:16 <araujo> dons, It is for adding it to Gentoo
18:04:19 <araujo> :-/
18:04:22 <dons> oh.
18:04:23 <dons> hmm
18:04:37 <dons> well, there'll be a new release later this month, I think
18:05:10 <araujo> dons, it just looks like the options to pass to configure are kind of broke.
18:05:58 <Korollary> jethr0: by dynamic scope, do you mean stuff like wantarray in perl?
18:06:19 <soysauce> Korollary: sub foo { return $p; } $p = 1; print foo();
18:06:22 <soysauce> prints "1"
18:06:29 <dons> araujo, in the non-darcs version, you edit config.mk, iirc
18:06:31 <soysauce> better yet
18:06:39 <soysauce> sub foo { return $p; } $p = 1; print foo(); $p++; print foo();
18:06:40 <jethr0> soysauce, that might be considered global variable
18:06:43 <soysauce> this prints "12"
18:06:45 <ihope> > sub
18:06:45 <lambdabot>  Not in scope: `sub'
18:06:48 <dons> araujo, if you need it in gentoo right now, host a tarball of the darcs version perhaps?/
18:06:51 <soysauce> well, ok, true
18:06:54 <twb> Anybody using Parsec and test-driven development?
18:07:10 <soysauce> sub foo { $p++; } sub bar { print $p; } foo(); bar(); foo(); bar();
18:07:13 <soysauce> this also prints "12"
18:07:15 <Philippa> I remember talking to shapr about it
18:07:20 <jethr0> :))
18:07:36 * jethr0 adores perl's simple, yet elegant style
18:07:55 <Philippa> there's sort of a risk in specifying the grammar multiple times unfortunately
18:07:59 * Korollary explodes in sarcasm overload
18:08:00 <Philippa> how do you know which spec was wrong?
18:08:06 <soysauce> to drive home the point:
18:08:22 <araujo> dons, mmm... that might be an option
18:08:22 <soysauce> sub foo { my($p) = 1; bar(); print $p; } sub bar { $p++; } foo();
18:08:27 <soysauce> this prints "2"
18:08:37 <soysauce> and my() scopes variables
18:08:56 <jethr0> korollary, dynamic scope means that when looking up a variable/binding not the one in the closest nesting block is returned, but the one most recently used in the execution context
18:09:14 <ihope> My Internet connection seems to have failed in a very odd way.
18:09:20 <Korollary> jethr0: I get it now. My love for perl grows every day.
18:09:24 <jethr0> closest nesting static/syntactic block
18:09:27 <gzl> ihope: yeah. in that you're still online.
18:09:35 <ihope> Exactly.
18:09:42 <twb> jethr0: Perl has closures... surely that implies lexical scope?
18:09:45 <araujo> dons, yeah, config.mk.in is the file to tweak
18:10:03 <araujo> dons, i think i will go straight ahead with this version for now
18:10:03 <jethr0> twb, i thought perl also had dynamic scope. i could look it up...
18:10:05 <soysauce> twb - scope exists, but the default extent of a variable is the lifetime of the program
18:10:11 <araujo> dons, the new tarball version will use Cabal ?
18:10:16 <twb> Ah.
18:10:31 <twb> So basically variables are special by default (in CL lingo)
18:10:39 <soysauce> not familiar with that lingo
18:10:54 <dons> araujo, the next release will use Cabal yes.
18:10:56 <jethr0> "Perl started with dynamic scoping. It has slowly evolved to support lexical scoping via the my qualifier. Lexical scoping may become default in Perl 6."
18:11:04 <dons> i'll just make a snapshot of the darcs repo, when it's release
18:11:05 <twb> CL has both dynamic and lexical, with lexical as the default.  Dynamic variables in CL are called "special variables".
18:11:47 <soysauce> sub closure { ($x) = @_; return sub { $x + 1; } }
18:11:48 <soysauce> $f = closure(1); $x = 2; print &$f();
18:11:52 <soysauce> this prints the value 3
18:11:53 <jethr0> twb, "dynamic" has fallen out of favor on lisp. back in the 60s and up until lisp 1.5 it was standard, i think
18:12:14 <soysauce> dynamic scoping is rarely what you want, I think
18:12:50 <jethr0> i think it might have its uses, but it really tangles up your brain so badly, that you wouldn't want to use it for your own sake
18:13:06 <jethr0> global variables are _nothing_ when compared to dynamic scope
18:13:31 <jethr0> exceptions in C++ are dynamically scoped, i seem to remember
18:13:53 <jethr0> or rather exception handling
18:14:03 <soysauce> they have extent greater than the lifetime of the function that throws them and smaller (usually) than the lifetime of the program
18:14:07 <soysauce> but that's not the same thing as scoping
18:14:33 <Philippa> really it's the catch that's scoped, not the exception (which is rebound with each catch)
18:14:38 <jethr0> try/catch blocks are IMHO dynamically scoped
18:14:46 <soysauce> what Philippa said.
18:14:50 <jethr0> sorry, unprecise wording
18:15:01 <soysauce> scope is the part of the program in which the bound variable is accessible
18:15:05 <soysauce> extent is the lifetime of the data
18:15:09 <jethr0> i know
18:15:16 <Philippa> in fairness C++ does rather like to link the two
18:15:44 <soysauce> Philippa - in programs that don't use pointers or references, that is true
18:16:15 <soysauce> pointers/references are constantly created and destroyed without destroying the data
18:16:23 <jethr0> especially since the visual c++ denied nested scopes and rebinding variables
18:16:31 <Philippa> soysauce: you missed out a 'pointed to' there
18:16:37 <benny> how hard would it be to make a CSS parser using one of the haskell parser libraries?
18:16:37 <Philippa> but yeah, IKWYM
18:16:51 <soysauce> and they're essential to C/C++'s strategy for data with extent longer than that of a function call and shorter than the program's lifetime, I forget what this is called
18:16:53 <jethr0> benny, isn't CSS pretty huge?
18:17:07 <Philippa> benny: piece o'piss if you just want to parse, assuming the CSS grammar's as simple as I remember
18:17:12 <Philippa> (now, the semantics're another matter...)
18:17:13 <soysauce> jethr0 - no it doesn't
18:17:26 <benny> piece o'..... "piss" ? :o
18:17:34 <Philippa> benny: "easy"
18:17:35 <soysauce> jethr0 - the VC++ compiler fully allows you to rebind variables; that is a feature of C++
18:17:41 <Korollary> Piece of cake for the PC oriented.
18:17:44 <soysauce> it might warn, though. I'm not sure.
18:17:46 <jethr0> soysauce, in some older version it didn't allow "for (int i = ...) {} for (int i = ...) {}"
18:17:48 <shapr> twb: I've got quickCheck and IO code around here somewhere, but not time to look for at the moment. Can I offer you a stack of HUnit and IO tests?
18:17:48 <Philippa> or if you prefer, "as easy as pissing"
18:18:03 <jethr0> nor did it allow "for (int i = ...) { for (int i = ...) {}}"
18:18:13 <shapr> twb: I'm using HUnit for TDD right this moment. I'm testing Plone via XmlRpc.
18:18:32 <Philippa> Korollary: I'm not sure that's a PC issue per se
18:18:35 <jethr0> at least not with the "standard" configuration i worked with
18:18:39 <soysauce> jethr0 - that might have been true of VC 12.x (VS 6.x), but it was certainly not true of the 13.x compilers (VS .NET/.NET 2003)
18:18:50 <soysauce> but I think even VS 6.x allowed it; I'm not sure since that goes back a long way
18:18:51 <jethr0> as i said, slightly older version
18:19:01 <Korollary> Philippa: Maybe. I just have never heard the piss version in the US
18:19:18 <jethr0> i was stunned that it didn't compile my code with rebinding "i" for-variables...
18:19:35 <araujo> dons, cool
18:19:36 <soysauce> jethr0 - I worked at MS for a spell, and I worked on some very old code that did that. They had their own lint-like tool called prefast, and prefast would bitch and moan every time someone did that.
18:19:39 <Philippa> Korollary: That's the US for you. Throw away half the decent cusses, bastardise the other half because they don't fit the accent...
18:20:18 <jethr0> it's so stupid. it leads to code like "int i; for (i=) {} for (i=) {}" and the occasional non-scoped nesting of already used variables"
18:20:20 <jethr0> *stupid*
18:20:22 <soysauce> jethr0 - but the code compiled all the same. This was summer of 2003, but like I said, the code was pretty old.
18:20:43 <soysauce> jethr0 - yeah... as in C ;)
18:20:47 <Philippa> VS6 had the for loop problem
18:20:56 <Philippa> used to piss me off, that one
18:21:00 <Korollary> Philippa: I don't think the accent would stop anybody from saying anything here. I think it's just isolation.
18:21:04 <soysauce> having grown up on C, I became accustomed to simply declaring all my variables at the top of a block
18:21:38 <soysauce> plus I always found a use in knowing at which index the loop terminated
18:21:45 <jethr0> i had to rewrite code that used to nest loop-variables "for (i=) {for (i=) {}}" and i had to figure out what it did so my version wouldn't change the behaviour *brr*
18:21:59 <jethr0> and it was inadvertently in the original!
18:22:02 <soysauce> :p
18:22:27 <Philippa> Korollary: some words just don't work with an american accent. The donkey/backside confusion thing, for example
18:22:38 <Philippa> they're actually different words when you say them out loud
18:23:01 <soysauce> Philippa - I've never confused the two ;)
18:23:03 <Korollary> Philippa: Of course. Sometimes here they use the brit version for emphasis.
18:23:20 <jethr0> i just found out that "dick" is not only the short-form for "richard" but also a term for private detectives...
18:23:28 <jethr0> kinda makes sense - dick tracy...
18:24:22 <Korollary> it's something else as well heh
18:25:19 <jethr0> korollary, it's actually at least two more thinkg.
18:27:06 * Korollary feels like a South Park character, wonders if Kenny is around.
18:27:44 <jethr0> s/.\(g\)/\1s/
18:28:27 * jethr0 thinks regular expression pattern matching would be a _great_ extension for haskell
18:28:40 <dons> @where harp
18:28:41 <lambdabot> http://www.cs.chalmers.se/~d00nibro/harp
18:28:43 <dons> ;)
18:28:58 <Philippa> jethr0: pointless. Why regex when you have higher-order PEGs in the form of Parsec?
18:29:10 <dons> that's regexes on [a], for [Char] there's also Text.Regex jethr0
18:29:17 <ricebowl> Philippa - ease of use
18:29:19 <jethr0> *nice*, parsec pattern matching in declarations
18:29:20 <dons> well, sometimes they're useful. 
18:29:27 <dons> Philippa, when writing editors..
18:29:50 <Philippa> ricebowl: only significantly easier for people already familiar with them though
18:30:15 <Philippa> for most other people I suspect the parsec's got a better learning curve - especially when doing anything complex
18:30:23 <Philippa> dons: fair enough :-)
18:30:30 <jethr0> fun x = | ((many1 letter) `sepBy1` ";") = "hello" | otherwise = "world"
18:30:39 <ricebowl> Philippa - regex is popularized by grep
18:30:44 <dons> no, sed!
18:30:48 <dons> long live sed.
18:30:49 <ricebowl> sed too
18:30:57 <ricebowl> and I expect it's substantially more compact, though I have no experience with parsec
18:31:40 <Philippa> ricebowl: compact, yes. As for the rest, you'll have to excuse me if I point out the *nix-centricism...
18:32:07 <dons> it's the one true way, Philippa
18:32:18 <ricebowl> haha
18:32:25 <ricebowl> Philippa - I use grep on Windows
18:32:35 * jethr0 just realised that his example above is actually already feasible *brr*
18:32:42 <ski_> (Cale,lennart : functions which consume their arguments are relevant)
18:32:44 <ricebowl> although it's not as nice because the port doesn't work with pipe :(
18:32:57 <Philippa> ricebowl: you're in a distinct minority there :-) It's still a *nix thing culturally
18:33:00 * ricebowl is accustomed to doing ps aux | grep ...
18:33:25 <Philippa> dons: the one true way is to execute everybody who believes they have a one true way ;-)
18:33:25 <ricebowl> Philippa - yes, I suppose that is true, but a large number of UNIX people use Windows either by choice or by requirement
18:33:36 <Philippa> yeah, hence the ports
18:33:41 * jethr0 wouldn't know what to do without grep, sed and friends
18:34:14 <shapr> For some reason HUnit is catching my expected exception: (CE.catch (remote un1 "authping" :: IO String) (\_ -> return "failed")) ~>= "failed"
18:34:17 <shapr> Any ideas why?
18:34:49 <Philippa> ricebowl: the thing is, the vast majority of computer users outright don't know what the hell grep /is/
18:35:18 <Philippa> I'd merely need to RTFM to pick up the syntax. I'm a minority in here, but if it's a minority among coders more generally then it's a sizable one
18:35:30 <ricebowl> Philippa - the vast majority don't know how to program either; what's your point? ;)
18:35:45 <jethr0> shapr, what are you expecting?
18:36:09 <shapr> jethr0: user error (Error calling createuser: user error (401 Unauthorized ))
18:36:17 <shapr> Er wait...
18:36:18 <shapr> doh
18:36:19 <jethr0> do you want an exception to occur?
18:36:47 * shapr sighs
18:36:58 <shapr> Sorry, it's 3:30am and I've been up too long...
18:37:02 * jethr0 is happy that all of shapr's problems are automagically solved
18:37:04 <shapr> That's one of my other tests :-/
18:37:23 <shapr> The expected exception code works perfectly, thanks :-)
18:37:27 <jethr0> np
18:37:55 <shapr> hoi jelmer 
18:38:21 <Philippa> ricebowl: in case it wasn't clear, I'm windows-based. I run a few things that're directly from a *nix culture (most notably PC-Pine) and a couple of things less directly so (er, GHC)
18:38:30 <ricebowl> Philippa - so am I
18:38:31 <Philippa> I'm somewhat odd for a windows user /anyway/, of course
18:38:42 <Philippa> would you be if you didn't have to be?
18:38:47 <ricebowl> yes
18:38:53 <Philippa> fair enough
18:38:55 <ricebowl> I grew up on DOS/Windows, and I have never been a big *nix fan
18:39:11 <ricebowl> but my point is that, of all coders (the group of people of interest), the vast majority either know what regex is or are familiar with it
18:39:11 * jethr0 gets out his linux zealot hat and starts preaching to the heathens
18:39:20 <jethr0> :)
18:39:21 <Philippa> I'm not entirely convinced
18:39:23 <ricebowl> in the CS curriculum at my uni they teach us regex
18:39:28 <ricebowl> lol jethr0
18:39:35 <Philippa> there are a *lot* of windows-based folks out there
18:39:37 <ricebowl> I have a Linux box, I just don't use it very often
18:39:38 <pengo> i'm using linux today because it's behaving
18:39:47 <Korollary> linux zealots are so 1990's.
18:39:48 <Philippa> and *nix-style regex != regular expressions in the CS sense
18:39:53 <ricebowl> haha
18:39:56 <Philippa> the latter was what was covered on the curriculum here
18:39:56 <shapr> I'm a House zealot.
18:40:00 <ricebowl> Philippa - I know
18:40:05 <shapr> GHC is my OS.
18:40:07 <ricebowl> Philippa - but I meant that we were taught grep/sed
18:40:11 <jethr0> pengo, i should've known! with your sacriligeous name...
18:40:21 <Philippa> reading off *nix-style regexes doing anything non-trivial is rather tougher
18:40:27 <shapr> If you're not in the Hardware monad... well, I feel sorry for you.
18:40:27 <pengo> jethr0, eh?
18:40:33 <jethr0> never mind
18:40:34 <Philippa> we weren't except in a basic "it takes a regex and does this" kinda way
18:40:45 <Korollary> why do regexes matter so much anyway?
18:40:49 <jethr0> philippa, regexes are strictly write-only!
18:41:04 <Philippa> jethr0: that's *exactly* why I don't want them as a syntax extension to haskell
18:41:14 <Philippa> parsec is readable
18:41:21 <jethr0> korollary, do they? they just help me a lot when automating stuff
18:41:22 <Korollary> I would hate regexes built into any language (like per....)
18:41:30 <jethr0> philippa, i wasn't serious about them before, either!
18:41:44 <shapr> I learned regexes in an afternoon and have used them ever since. What's the big deal?
18:41:44 <Philippa> yeah, 'sok, you're not the one who started arguing with me :-)
18:41:54 <jethr0> korollary, well as a builtin i find them quite nice...
18:42:03 <Korollary> jethr0: Yes, they help, but some people attribute to much importance to them as if 90% of all coders use them daily.
18:42:06 <Philippa> shapr: I learned the basic CS concept in 5 minutes and never remember the syntax or the big pile of extensions
18:42:29 <ricebowl> Korollary - well if you're in a UNIX environment where you pass everything around as text, they are rather useful ;)
18:42:35 <jethr0> well, 90% of all perl coder do!
18:42:42 <jethr0> *joking*
18:42:50 <Philippa> 90% of perl coders think it's a good language, so I think we can discount them ;-)
18:43:05 <pengo> text is so 1970's
18:43:47 <jethr0> i'd really like to test out this M$ monad shell... i wonder if it is really so superios to "everything is a file/text" and if so, if i shouldn't steal their concepts for the *nix cause :)
18:44:11 <ricebowl> I suppose I'm in the other 10%
18:44:16 <pengo> unix shells need a makeover
18:44:18 <ricebowl> from the academic angle it's a horrible language
18:44:24 <ski_> the M$ monad, you can't escape ! mwuahahaha !!
18:44:27 <ricebowl> but it's pretty efficient in terms of rapid prototyping
18:44:30 <Korollary> ski_: heh
18:44:33 <jethr0> everything-is-text gets you pretty far, but at some point it just fails to solve problems
18:44:37 <ricebowl> pengo - yes, I agree completely
18:44:48 <shapr> eshell is nifty.
18:44:51 <ricebowl> jethr0 - it is universal, I think, just horribly inelegant and inefficient
18:45:15 <ski_> (hm .. unsafePerfomM$ ..)
18:45:26 <jethr0> a quick "wget "..." | sed 's/</\n</g' | grep 'href="ed2k://'" is faster written then thought about
18:45:27 <ricebowl> Philippa - you asked my opinion earlier, so I will give it to you: UNIX was a great OS. In the 1970s. ;)
18:45:59 <Cale> jethr0: you should use xml2
18:45:59 <ricebowl> Philippa - I'm a Windows kernel hacker, so naturally that's what I run. But it does help to have a Linux system which comes (relatively) secure by default and is free.
18:46:02 <Philippa> heh
18:46:12 <Cale> (and/or html2
18:46:12 <Cale> )
18:46:27 <jethr0> ya, i was thinking about using a haskell shell (if there is one) and doing some nifty stuff with monads/arrows
18:46:29 <ricebowl> having dealt with both models, NT's approach to asynchronous I/O is awesome.
18:46:44 <Cale> (I mean, in that shell pipeline)
18:46:50 <Cale> http://dan.egnor.name/xml2/
18:46:54 <jethr0> the IO situation can be pretty under linux :(
18:47:01 <jethr0> pretty dreary*
18:47:21 <jethr0> thx, cale
18:47:25 <pengo> what's nt's approach to async IO?
18:47:30 <ricebowl> UNIX does a great job at I/O so long as everything can be modelled as a stream of data. ;) but it's pure pain when you want to do asynchronous stuff, or at least as compared to Windows.
18:47:46 <ricebowl> pengo - every I/O request you make is tagged with a condition variable (Win32 event)
18:47:50 <jethr0> cale, apt-get install xml2 :)
18:47:59 <Cale> jethr0: yes :)
18:48:01 <pengo> ricebowl, what's the condition?
18:48:14 <ricebowl> pengo - you create it. It's a variable. When the kernel finishes the request, the variable gets set.
18:48:28 <pengo> ricebowl, gotcha
18:48:40 <ricebowl> it works very well for small amounts of I/O. I/O to other threads goes directly through memory
18:48:45 <pengo> ricebowl, so do you have to poll it or what?
18:48:51 <ricebowl> and both I/O to threads and to the kernel is unified
18:48:51 <Cale> jethr0: it also includes 2xml and 2html so you can convert things back into xml/html after shell processing
18:48:57 <ricebowl> nope, you can poll if you like but you can also wait
18:49:02 <Cale> However, this sort of thing is kind of silly.
18:49:23 <Cale> (though terribly convenient)
18:49:25 <ricebowl> for large numbers of concurrent I/Os you can create a queue and have the OS drop a notification in the queue when the I/O completes
18:49:28 <ricebowl> it's similar to BSD's kqueue
18:49:51 <ricebowl> except that the I/O model is built on it, rather than vice versa
18:50:02 <Cale> hmm
18:50:17 <ricebowl> kqueue is a little more generic since you can get process/thread notifications as well as notifications from the file system
18:50:26 <pengo> ricebowl, interesting
18:50:28 <ricebowl> I think NT's queues are limited to file and socket I/O
18:50:39 <ricebowl> but the other model, that of condition variables, generalizes
18:50:58 <ricebowl> so you can wait on changes in the file system, conditions, I/O completion, or notifications from other threads
18:51:50 <ricebowl> many other OS services are built around the same model, so I can ask Winsock to notify me via a condition variable of route changes or changes to the machine's network addresses
18:52:32 <ricebowl> I wrote a single-threaded UDP server which processed packets and bound to all network interfaces which didn't match a particular constraint. That would be impossible under POSIX without polling, if it's possible at all.
18:53:09 <ricebowl> it's not a perfect model, but it's very nice to program for, and it's overall very efficient
18:53:46 <ricebowl> and, in the case where you want blocking I/O, you use a NULL condition variable and the OS kernel will wait for the I/O to complete before returning ;)
18:54:54 <musasabi> Has anyone got an implementation of hRead ?
18:56:07 <musasabi> or is that even possible to create?
19:00:54 <soysauce> buenas, Nomius
19:01:19 <Nomius> Hola soysauce 
19:01:27 <Nomius> Siempre que entro acá me saluda araujo...
19:01:37 <Nomius> A vos no te conosco, pero te saludo :D
19:01:42 <soysauce> ;)
19:02:51 <soysauce> ví que sos de Argentina, pues te saludo en castellano
19:03:10 <Nomius> ¿De dónde eres?
19:03:19 <jethr0> @babel es en vi que sos de Argentina, pues te saludo en castellano
19:03:20 <soysauce> los EE.UU
19:03:21 <lambdabot>  I saw that sos of Argentina, because I salute to you in Castilian
19:03:24 <soysauce> haha
19:03:36 <soysauce> "I saw that you were from Argentina, so I'm greeting you in Spanish"
19:03:37 <jethr0> jejeje
19:03:49 <soysauce> babelfish doesn't understand the Argentine dialect
19:03:52 <soysauce> it's funny to watch it try
19:05:03 <Nomius> You are from argentina
19:05:11 <soysauce> no, I'm an American
19:05:12 <jethr0> que significan los double E y U? E Estados U Unidos?
19:05:18 <Nomius> No...
19:05:23 <soysauce> jethr0 - exacto
19:05:27 <soysauce> Estados Unidos
19:05:38 <jethr0> no, pero por que _double_ E y U?
19:05:49 <soysauce> jethr0 - colloquialism, I don't know. It's what I was taught.
19:05:54 <soysauce> some people write E.U I think
19:06:32 * twb idly contemplates #emacs-es
19:06:40 <soysauce> la maestra que me lo dijo era de Venezuela (o de verdad su esposo era de Venezuela)
19:06:51 <Nomius> I don't like when the people from USA say that they are americans...
19:06:56 <Nomius> I'm american too...
19:06:59 <twb> Nomius: yeah.
19:07:23 <twb> They don't believe anything outside .us really exists, except maybe .ca.
19:07:28 <soysauce> Nomius - well saying "I'm a United Stateser" sound dumb and takes a lot of breath
19:07:34 <soysauce> but I always say "soy estadounidense"
19:07:40 <jethr0> USanian
19:07:42 <soysauce> sounds dumb, rather
19:07:51 <twb> What's wrong with "idiot"? ;-)
19:08:03 <Nomius> HAHAHAHA
19:08:04 <soysauce> I said I was from the US, I didn't say I was from NYC or LA
19:08:36 <jethr0> twb, your direct approach to cross cultural communication cracks me up.
19:08:45 <Nomius> Haha
19:09:18 <soysauce> despite the ignorance of the most outspoken Americans, obviously some of us are somewhat educated ;)
19:09:39 <soysauce> I was surprised to discover that there are citizens of the US, born here, and they can't even name all 50 states
19:09:58 <Xianianol> The problem with Americans is that, all of the dumb people get the spotlight...
19:10:04 <jethr0> @babel es pt nadie comprende il portugues por que todas las palabras son escrito differentamente
19:10:06 <soysauce> that's true of every nation
19:10:07 <lambdabot> Module "babel" produced error: Prelude.head: empty list
19:10:17 <jethr0> *damn*
19:10:28 <Nomius> jethr0, onde você mora?
19:10:29 <Xianianol> Well, true, but since they do try to keep the World Spotlight on them...
19:10:34 <jethr0> exactly
19:10:40 <soysauce> se escriben, not son escrito :p
19:10:49 <Xianianol> Woha, sounds like Portuguese...
19:11:18 <jethr0> my spanish is _really_ bad. i can understand about everything, but my speaking/writing is really poor
19:11:24 <soysauce> du bist Deutscher, richtig?
19:11:37 <jethr0> *damn*, my accent gave me away
19:11:39 <soysauce> jethr0 - it's not that bad. It's really, *really* funny to listen to Americans try to speak it. ;)
19:11:40 <twb> soysauce: I can't name all 50 states.
19:11:44 <soysauce> jethr0 - naw, your host did :p
19:11:50 <jethr0> jeje
19:11:53 <soysauce> twb - do you live in the US?
19:11:57 <twb> soysauce: I do not.
19:12:02 <Xianianol> I can google 50 states!
19:12:02 <Nomius> So... Let's be all one...  Imagine there's no countries,
19:12:04 <Nomius>  it isnt hard to do <--- Said John Lennon
19:12:05 <soysauce> twb - that's a different matter then, no? :p
19:12:22 <Xianianol> 1 country ? 1 culture ? baaaaad!
19:12:27 <twb> Nomius: "nationalism sucks", Orwell (paraphrasing)
19:12:28 <jethr0> soysauce, you should hear brits talking french. that's enough fun to last you a lifetime of drudgery
19:12:34 <Korollary> well, for many US citizens, other states are like other countries. lack of interest is understandable.
19:12:34 <soysauce> haha
19:12:36 <soysauce> I'd imagine
19:12:57 <soysauce> I was getting my hair cut one day, the woman had a slight accent, so I asked where she was from
19:12:57 <Nomius> twb, I say the same :D
19:13:26 <Xianianol> And the answer was ?
19:13:28 <soysauce> "Cuba" "Oh eres cubana!" "Tú hablas español?" "Sí bastante..." "De dónde eres?" "Nací en Texas pero vivo aquí..." etc.
19:13:35 <jethr0> w/o wanting to appear anti-bushian, i was amazed that GWB had not passport prior to becoming president :(
19:13:43 <Xianianol> lol
19:13:53 <Nomius> "Nationalism is an infantile disease. It is the measles of mankind." said Albert Einstein...
19:14:04 <soysauce> other people tried to join in the conversation, but they were obviously not very proficient, it was so funny
19:14:28 <twb> Que significa "bastante"?
19:14:34 <soysauce> bastante = enough
19:14:35 <Nomius> more
19:14:35 <Xianianol> To be fair, I just can barely able to understand spoken Spanish...
19:14:42 <Nomius> No
19:14:45 <soysauce> like sufficient
19:14:46 <jethr0> infantile diseases have the property of being mostly mild and non-lethal. imagine what mankinds _real_ diseases will be like!
19:14:48 <Nomius> Enough is suficiente...
19:14:56 <Nomius> Bastante is like too much
19:15:09 <soysauce> Nomius - I'm looking at a Spanish-English dictionary
19:15:10 <Xianianol> Bastante is "quite a lot"
19:15:24 <jethr0> he oido bastante
19:15:24 <Nomius> Xianianol, that's it :D
19:15:28 <soysauce> bastante (pron.): enough (Hemos visto bastante -> we have seen enough)
19:15:48 <Xianianol> Wrong translation, I can tell you...
19:15:49 <jethr0> @babel es en bastante
19:15:51 <lambdabot>  enough
19:15:52 <Nomius> Oh, that way...
19:16:02 <Xianianol> suficiente is enough...
19:16:07 <jethr0> @babel es en suficiente
19:16:08 <lambdabot>  sufficient
19:16:08 <soysauce> I suppose I should say "sí, suficiente"
19:16:09 <Xianianol> bastante is quite a lot
19:16:23 <soysauce> ah well... it's not my native language, so
19:16:30 <Nomius> The correct one would be: Hemos visto suficiente..
19:16:30 <Xianianol> It is nor mine :P
19:16:35 <Xianianol> I am Portuguese
19:16:52 <soysauce> Nomius - well I'm just quoting the dictionary ;)
19:16:57 <soysauce> it could be regional variation too
19:17:02 <Xianianol> Burn that dictionary!
19:17:03 <jethr0> nomius, i guess it depends. if you wanna be polite you say suficiente. and if you wanna be rude you say bastante. right?
19:17:07 <Nomius> soysauce, probably :)
19:17:28 <Nomius> jethr0, you're right...
19:17:34 <soysauce> Argentines are well-known for their peculiar dialect ;)
19:17:37 <Xianianol> I don't think so...
19:17:39 <twb> bastante is a familiar form? :-)
19:17:43 <Xianianol> no...
19:17:44 <soysauce> vos sos argentino obvio ;)
19:17:47 <Xianianol> They have different meaning!
19:18:13 <soysauce> I don't think it has anything to do with politeness
19:18:15 <Nomius> soysauce, you are absolutely right :D
19:18:30 <Xianianol> Well, I can't explain it with spanish example but:
19:18:31 <jethr0> nomius, you can't agree with both of us!
19:18:57 <Nomius> jethr0, I don't wanna fight or discuss with anyone :D
19:19:01 <jethr0> :)
19:19:04 <Xianianol> Comi bastante -> I've eaten a lot!
19:19:08 * soysauce kann ein bisschen Deutsch sprechen!
19:19:24 <Nomius> Ich bin David aus argentina :D
19:19:24 <soysauce> kann or kannt?
19:19:29 * jethr0 freut sich, daß soysauce seine sprache spricht
19:19:30 <Korollary> kannt
19:19:35 <jethr0> kann
19:20:02 <Korollary> hmm. very rusty
19:20:16 <jethr0> very similar to "kennt" which means nearly the same thing :)
19:20:29 <jethr0> it's like saber and poder in spanish
19:20:40 <soysauce> those are very different :S
19:20:42 <jethr0> or being able and can and know
19:20:44 <soysauce> "to know" and "to be able"
19:20:46 <Xianianol> Yes, they are different :P
19:20:54 <Xianianol> (Exactly)
19:21:04 <soysauce> hm, I see what you're trying to say though
19:21:27 <Nomius> Esperanto... Anyone speak it?
19:21:37 * soysauce hat eine Deutschprüfung am 13 Diezember...
19:21:41 <soysauce> or however you spell that
19:21:50 <Xianianol> Can someone give me a hand in a function that I am writing ? I don't know why it is not showing the correct result/style.
19:21:58 <soysauce> Xianianol - go for it
19:22:07 <Xianianol> stepEval env (Nat n) = show (evalExpr env (Nat n))
19:22:07 <Xianianol> stepEval env (Var v) = show (evalExpr env (Var v))
19:22:08 <Xianianol> stepEval env (e1 :+ e2) = (stepEval env e1) ++ " + " ++ (stepEval env e2) ++ " = "
19:22:08 <Xianianol> ++ show (evalExpr env (e1 :+ e2)) ++ "\n"
19:22:08 <Xianianol> stepEval env (e1 :* e2) = (stepEval env e1) ++ " * " ++ (stepEval env e2) ++ " = "
19:22:08 <Xianianol> ++ show (evalExpr env (e1 :* e2)) ++ "\n"
19:22:12 <jethr0> puedo ir mi casa, se como ir a mi casa, reconosco ese lugar (or sth)
19:22:18 <jethr0> como llegar
19:22:32 <soysauce> jethr0 - ??
19:22:39 <jethr0> what seems to be the problem
19:22:43 <jethr0> soysauce, never mind
19:22:46 <Xianianol> (uups, forgot that I got a new line in the last two patterns)
19:22:50 <soysauce> espero que puedas llegar a tu casa
19:23:00 <Xianianol> Anyway, I am trying to do a stepwise evaluation...
19:23:02 <soysauce> sería mala onda no poder volver para dormir en la noche
19:23:16 <jethr0> @babel es en onda
19:23:19 <lambdabot>  wave
19:23:25 <jethr0> *hmm*
19:23:28 <jethr0> onda?
19:23:36 <soysauce> jethr0 - it's like saying "it would be a terrible thing to be unable to go home to sleep at night"
19:23:37 <jethr0> signal?
19:23:42 <soysauce> no
19:23:47 <Xianianol> So that if I put into the function "5+5+5" it would be 5 + 5 = 10 and then 10+5=15
19:23:55 <soysauce> it's Mexican slang, but I've seen others use it too...
19:24:13 <jethr0> never heard it... but that doesn't mean a thing
19:24:16 <Xianianol> However, what I am getting is: 5 + 5 + 5 = 10 and then = 15
19:24:16 <soysauce> Xianianol - way over my head
19:24:44 <jethr0> xianianol, i don't get why you have to explicitely model the stepping?
19:25:03 <soysauce> jethr0 - they always say "que onda" which means "what's up?"
19:25:12 <Xianianol> Well, to show each step to the user.
19:25:21 <soysauce> or "eres buena onda", though I don't know how to translate it :p
19:25:23 <jethr0> the evaluation is stepwise anyways, right? so why don't you just interleave the prior evaluation with some additional code
19:25:27 <soysauce> it's something like "I like you"
19:25:30 <jethr0> no idea whether i'm making sense right now
19:25:33 <soysauce> except not in the romantic sense
19:25:38 <jethr0> weird word
19:25:41 <Xianianol> I thought that is what I am doing...
19:25:41 <soysauce> yeah, it is
19:26:19 <jethr0> xianiano, never mind, i'll have a look at the code, just a sec
19:26:27 <jethr0> lispaste: help
19:26:33 <jethr0> lispaste2: help
19:26:44 <Nomius> "eres buena onda" is like "you are the men", or "you are great"
19:26:56 <soysauce> yeah
19:26:59 <soysauce> that's a good translation
19:27:00 <jethr0> xianiano, could you paste your code somewhere? http://paste.lisp.org/new/haskell
19:27:21 <Xianianol> Is just that, from the look of the results it looks like it is caused by my new lines or recursions, since I got everything there, but the results are just on the wrong place.
19:27:23 <Xianianol> Sure.
19:27:24 <Xianianol> A sec.
19:27:31 <soysauce> Nomius - they use that in Argentina too, right?
19:27:41 <Nomius> No...
19:27:47 <soysauce> un amigo de tu país lo usa...
19:27:52 <Nomius> It´s more a mexican expression...
19:27:56 <soysauce> pero tiene un dialecto *muy* extraño
19:28:03 <jethr0> captar la onda; estar en la  onda
19:28:13 <soysauce> por ej. me dice "vos qué dice a ella?"
19:28:14 <jethr0> from the dictionary, but sounds pretty square to me...
19:28:23 <Nomius> We say "tenés buena onda"...
19:28:27 <soysauce> y debe ser "qué decís a ella?"
19:28:33 <soysauce> ah
19:28:53 <Nomius> "¿Qué LE decís a ella?"
19:29:04 <soysauce> yes, sorry
19:29:17 <soysauce> I realize that after I said it...but I was trying to point out that he gets the conjugation wrong
19:29:20 <soysauce> I realized, rather
19:29:29 <araujo> QuÃ© le dices a ella? 
19:29:33 <araujo> :-P
19:29:35 <soysauce> hola araujo
19:29:40 <araujo> Hola soysauce :-]
19:29:47 <Nomius> araujo, cambiate a utf-8
19:29:49 * soysauce es salsa roja
19:29:51 * araujo points Nomius to #haskell.es
19:30:04 <soysauce> tienes una idea buena
19:30:13 <Nomius> Just because you tell me :D
19:30:26 * araujo hugs Nomius 
19:30:29 <soysauce> Nomius - está usando UTF-8
19:30:43 <Nomius> UOOOOPS
19:30:45 <soysauce> hehe
19:30:46 <Nomius> My mistake
19:30:47 <araujo> yeah!!!!
19:31:00 <soysauce> what's wrong with this? parse f g s = case p@(f s) of ...
19:31:01 <Nomius> Fixed :D
19:31:04 <soysauce> I thought that was legal Haskell
19:33:14 <jethr0> > let fun x = case p@(even x) of True -> 1 | False -> 0 in fun 2
19:33:15 <lambdabot>  parse error on input `|'
19:33:28 <jethr0> > let fun x = case p@(even x) of {True -> 1; False -> 0} in fun 2
19:33:29 <lambdabot>  Pattern syntax in expression context: p@(even x)
19:33:45 <jethr0> soysauce, why do you need to bind "p" inside the case?
19:34:02 <jethr0> > let fun x = let p = even x in case p of {True -> 1; False -> 0} in fun 2
19:34:03 <lambdabot> 1
19:34:41 <Cale> soysauce: is f a constructor?
19:34:42 <lisppaste2> Xianianol pasted "stepwise eval problem" at http://paste.lisp.org/display/14541
19:34:50 <jethr0> soysauce, i would (naively) have thought it possible, but the case thingey is not really a pattern matcher
19:34:57 <jethr0> i think
19:35:04 <Cale> case only pattern matches
19:35:17 <jethr0> but also between "case" and "of"?
19:35:33 <Cale> wait, what is it that you're trying to do?
19:35:45 <jethr0> not me
19:35:53 <Cale> oh
19:35:54 <soysauce> jethr0 - I have nested cases
19:36:00 <soysauce> oh, I see
19:36:03 <Cale> there, you're supposed to put an expression
19:36:05 <soysauce> bind in the case itself
19:36:13 <soysauce> err ignore that thing about nested cases
19:36:15 <Xianianol> Okay, pasted the problematic code on the pastebin.
19:36:18 <Cale> case expr of patt1 -> expr1; patt2 -> expr2 ...
19:36:43 <jethr0> xianiano, can you paste the url, pastebot seems absent
19:37:17 <Xianianol> http://paste.lisp.org/display/14541
19:37:18 <Cale> Xianianol: why are you trying to do everything at once?
19:37:40 <Cale> Why not write a  stepEval :: Expr -> Expr
19:37:50 <Cale> and then showExpr :: Expr -> String
19:38:11 <Xianianol> Humm, I thought that there will be many line of codes...
19:38:24 <Xianianol> And in a way, I thought the method I am using would work.
19:38:31 <Xianianol> (with of course, doesn't )
19:39:24 <Xianianol> But then, I don't understand what you mean with Expr -> Expr, I got a parser that gives out the structure (in a way, the steps) of the evaluation.
19:39:30 <Xianianol> However, that is not very user-eue friendly.
19:39:36 <Xianianol> *user-eye
19:39:38 <jethr0> just a sec
19:39:56 <Cale> Um, don't you just want the parser to emit an expression?
19:40:21 <Xianianol> Nope, I sort of want it do show each step of the evaluation of an expression.
19:40:35 <Cale> why the parser?
19:40:44 <Cale> the parser doesn't have anything to do with evaluation
19:41:03 <Cale> its job is to read the string and put it into a structural form that's easy to manipulate
19:41:19 <jethr0> xianianol, from my perspective it does exactly what you told it to.... try "5+5+5+5" and i guess you might see sth different
19:41:22 <Xianianol> Well, my parsers gives out the structure, and then I got another eval function that receives the structures and do whatever it should do...
19:41:30 <Cale> Sure, you could evaluate at the same time, but it would reduce flexibility
19:41:34 <jethr0> depending on how he parses it.
19:42:08 <Xianianol> No, I am not realyl doing everything at the same time, I got a parser that gives out the structure, and a function that evaluates!~
19:42:15 <Cale> okay
19:42:42 <Cale> The function that evaluates, just evaluates things by one step?
19:43:16 <Xianianol> Yes.
19:43:47 <Xianianol> Well, by one step as...
19:43:52 <Xianianol> Just shows the result
19:44:12 <Xianianol> But in theory, it is still a recursive evaluation.
19:44:24 <Xianianol> Basically:
19:44:24 <Cale> iterate eval expr -- this should then give a list of the steps of evaluation
19:44:24 <Xianianol> evalExpr env (e1 :+ e2) = evalExpr env e1 + evalExpr env e2
19:44:24 <Xianianol> evalExpr env (e1 :* e2) = evalExpr env e1 * evalExpr env e2
19:44:24 <Xianianol> evalExpr env (Nat n) = n
19:44:40 <Cale> okay, that's doing all the evaluation at once
19:44:47 <Cale> not what we want
19:44:48 <jethr0> xianianol, i guess your step-function could return a list of strings representing the steps...
19:45:10 <jethr0> because at the moment all steps are put together into one single string (with newlines in it)
19:45:26 <Xianianol> Humm...
19:45:39 <Cale> Assuming strict evaluation, you just want to take the innermost leftmost redex and replace it with what it reduces to.
19:45:52 <Cale> evalStep :: Expr -> Expr
19:45:53 <jethr0> depending on whether you want interactive stepping or just a "trace"-like representation of the steps
19:46:05 <Xianianol> I was planing trace like.
19:46:06 <Cale> where the output is just one step more evaluated than the input expression
19:46:08 <Xianianol> Just to show.
19:46:20 <Cale> does that make sense?
19:46:32 <Xianianol> Humm, sort of.
19:46:43 <Xianianol> So, I just don't use recursion at all ?
19:46:50 <Cale> you use recursion
19:46:56 <Cale> you just don't return an Integer
19:47:06 <Cale> you return another expression
19:47:22 <Cale> and the recursion leaves most of the structure alone
19:49:53 <soysauce> hum, this is kind´ve annoying
19:49:58 <soysauce> Nothing :: Maybe a :(
19:50:03 <jethr0> so?
19:50:09 <jethr0> why's that annoying?
19:50:23 <soysauce> well it doesn't hold any data, and I was trying to return it, except I was returning a Maybe b
19:50:29 <soysauce> so I have to reconstruct my data
19:50:45 <soysauce> minor inconvenience, I suppose, but I'm trying to make this fast so as to best my classmates ;)
19:50:48 <jethr0> i had that problem too. i just created a new Nothing...
19:50:56 <soysauce> I know
19:50:59 <Cale> soysauce: er, hm?
19:51:08 <Cale> I don't understand what you're saying :)
19:51:09 <jethr0> how are you converting the Just?
19:51:20 <soysauce> Cale - I am taking a class on functional programming this semester, this is for one of my Haskell assignments
19:51:30 <soysauce> but the professor benchmarks the programs
19:51:38 <soysauce> and there's glory in it for the fastest program ;)(
19:51:47 <soysauce> or rather, the author of the fastest program
19:51:53 <Cale> *Main> evalStep ((Const 5 :+ Const 5) :+ Const 5)
19:51:53 <Cale> Const 10 :+ Const 5
19:51:58 <soysauce> and optimization is fun for me
19:52:04 <Cale> Xianianol: there's an example :)
19:52:10 <Xianianol> So, I should do something like,
19:52:10 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ evalStep env e2)
19:52:10 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* evalStep env e2)
19:52:10 <Xianianol> evalStep env (Nat n) = Nat n
19:52:22 <Cale> Xianianol: no
19:52:29 <Cale> too much recursion there
19:52:29 <soysauce> so I'm trying to construct a super-optimized program. Basically I'm giving Knuth a reason to not die just yet.
19:52:34 <jethr0> > let fun m = case m of (Just x) -> Just (fromEnum x); otherwise m in fun (Just True)
19:52:34 <lambdabot>  parse error on input `in'
19:52:45 <soysauce> since Knuth was the one to whom is credited the saying, "Premature optimization is the root of all evil."
19:52:53 <soysauce> s/was/is/
19:52:55 <Cale> soysauce: but I don't understand your problem with the Maybe type
19:52:58 <jethr0> > let fun m = case m of {(Just x) -> Just (fromEnum x); otherwise m} in fun (Just True)
19:52:59 <lambdabot>  parse error on input `}'
19:53:01 <soysauce> Cale - it's not a problem
19:53:04 <jethr0> > let fun m = case m of {(Just x) -> Just (fromEnum x); otherwise = m} in fun (Just True)
19:53:05 <lambdabot>  parse error on input `='
19:53:06 <soysauce> I just didn't want to reconstruct my data
19:53:11 <jethr0> > let fun m = case m of {(Just x) -> Just (fromEnum x); otherwise -> m} in fun (Just True)
19:53:12 <lambdabot> Couldn't match `Int' against `Bool'
19:53:22 <jethr0> cale, _that_ problem
19:53:22 <soysauce> and now I have to because I have to change the type of Nothing from Maybe a to Maybe b
19:53:23 <Cale> reconstruct?
19:53:29 <soysauce> yes
19:53:36 <soysauce> data Parse = Parse (String, Maybe a)
19:53:43 <soysauce> so I have to construct a new Parse object
19:53:51 <Xianianol> Humm, too much recursion...let's see
19:53:55 <soysauce> parse :: (String -> Parse a) -> (String -> Parse b) -> String -> Parse (a, b)
19:54:02 <Cale> jethr0: um, that's obviously a type error
19:54:04 <soysauce> if the first one fails, then it returns a Parse (a, b)
19:54:09 <jethr0> i know
19:54:11 <soysauce> where the (a, b) is Nothing
19:54:17 <Cale> jethr0: easily fixed :)
19:54:21 <jethr0> :)
19:54:56 <jethr0> soysauce, stuff like Maybe is optimized away most likely anyways
19:55:03 <soysauce> ok
19:55:03 <Cale> Xianianol: remember, you only want to evaluate just one thing
19:55:15 <soysauce> well it ultimately doesn't matter much, I'm just being pedantic about optimization
19:55:21 <soysauce> and I just realized that this is an error case anyway. ;)
19:55:22 <Cale> Xianianol: you'll either be adding two constants, or multiplying two constants
19:55:31 <Xianianol> So maybe, I take out the recursions of the right side ?
19:55:32 <soysauce> it's more of an exercize in tedium for pleasure
19:55:34 <jethr0> soysauce, although i don't understand how you convert the Just, but not the Nothing...
19:55:41 <Cale> Xianianol: yes
19:55:42 <soysauce> jethr0 - I can paste the function
19:55:48 <jethr0> pls
19:55:48 <Cale> Xianianol: and you'll need more cases
19:55:51 <soysauce> although I warn that it's ugly.
19:55:55 <Xianianol> Making it like,
19:55:55 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ env e2)
19:55:55 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* env e2)
19:55:55 <Xianianol> evalStep env (Nat n) = Nat n
19:56:03 <jethr0> premature optimization always is!
19:56:05 <Xianianol> Feels weird
19:56:13 <Cale> is env a function?
19:56:15 <soysauce> http://www.rafb.net/paste/results/gQtRTH61.html
19:56:23 <soysauce> s/premature// ;)
19:56:24 <Cale> you're applying it to e2 there
19:56:25 <Xianianol> oh, you can ignore env, it is just a list.
19:56:41 <Xianianol> To keep a feel others things that won't be applied.
19:56:57 <Cale> Xianianol: then that's a type error
19:56:59 <Xianianol> TO keep a *few others thing.
19:57:04 <Cale> (just a small thing)
19:57:05 <soysauce> so I have a couple primitive functions, one removes whitespace, one parses an integer, another eats characters up to and including EOL
19:57:17 <soysauce> now I want to combine these in the functional style to built my parser
19:57:18 <Xianianol> erm, I mean, I should have taken the env on the right side too
19:57:24 <soysauce> that's what the parse function is for
19:57:26 <Cale> yeah :)
19:57:26 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
19:57:26 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
19:57:26 <Xianianol> evalStep env (Nat n) = Nat n
19:57:34 <soysauce> takes a pair of smaller parsers and creates a bigger one
19:57:45 <Cale> Xianianol: right, now you have an identity function though :)
19:57:52 <soysauce> if the first fails, then it returns (s, Nothing) to indicate the point at which the parse failed
19:57:56 <Xianianol> ack...true
19:58:01 <Cale> Xianianol: so you need to do a little more work, but just in some special cases
19:58:41 <jethr0> soysauce, if your type were "Maybe (String, a)" you could use the Maybe Monad
19:58:46 <soysauce> I know
19:58:55 <soysauce> but then when it failed I wouldn't know where
19:58:59 <jethr0> so, why don't you change it?
19:59:07 <jethr0> hmm
19:59:10 <soysauce> I wanted to use the Maybe monad, and I thought even about making Parse a monad
19:59:14 <Xianianol> Things like.... (e1 :+ Nat n) ?
19:59:16 <soysauce> essentially the same sort of Monad as Maybe
19:59:26 <jethr0> making a monad is _really_ simple
19:59:30 <Xianianol> humm, but then, e2 should cover that...
19:59:31 <soysauce> I know
19:59:33 <Cale> Xianianol: in particular  (Nat n :+ Nat m)
19:59:38 <soysauce> you only need to define return and >>=
19:59:43 <jethr0> yup
19:59:50 <soysauce> I don't know how I would define return, though
20:00:02 <Cale> Xianianol: and perhaps all the cases where you need to do variable substitution
20:00:03 <jethr0> return = Parse
20:00:12 <soysauce> @type return
20:00:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
20:00:14 <soysauce> a -> m a
20:00:26 <jethr0> a = (String, Maybe b)
20:00:27 <soysauce> Parse has type (String, a) -> Parse a
20:00:37 <jethr0> yu
20:00:38 <jethr0> p
20:00:52 <soysauce> the types don't match, though
20:01:01 <jethr0> they do
20:01:04 <Xianianol> Humm, variable substituition should just return a longer expression...
20:01:07 <Cale> jethr0: hmm
20:01:13 <Cale> no
20:01:19 <jethr0> *grr*
20:01:24 <Cale> return has to be fully polymorphic
20:01:38 <jethr0> "return = Just" in Maybe
20:01:42 <soysauce> Prelude> :i IO
20:01:42 <soysauce> newtype IO a
20:01:42 <soysauce>   = IO (GHC.Prim.State# GHC.Prim.RealWorld
20:01:42 <soysauce>         -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
20:01:47 <Cale> yes, but that's a really simple case :)
20:02:05 <jethr0> yes, and soysauce basically wants another Maybe monad, just a tad different
20:02:07 <soysauce> you never ever have to deal with GHC.Prim.State# when using IO, or at least in the simple stuff I have done
20:02:10 <Cale> you want the parser that doesn't eat any characters, succeeds, and returns the value
20:02:45 <Cale> data Parse = Parse (String, Maybe a) ?
20:02:51 <jethr0> yup
20:02:54 <Cale> How should I interpret that?
20:03:01 <Xianianol> But then, shouldn't it stop at (Nat n +: Nat m) ?
20:03:09 <Cale> perhaps   return x = Parse ("", Just x)
20:03:15 <Cale> Xianianol: yes
20:03:30 <soysauce> Cale - the parse with String unconsumed input and Maybe a output
20:03:32 <jethr0> and "instance Monad Parse where return = Parse; (Parse (a,Nothing)) >>=...)
20:03:32 <Cale> Xianianol: it should return the expression representing the sum
20:03:48 <Cale> jethr0: type error
20:04:00 <Cale> return = Parse isn't the right type
20:04:00 <Xianianol> So, Nat(n +m)
20:04:05 <Cale> Xianianol: yep
20:04:19 <soysauce> hmm, your solution with an empty string of unconsumed input might work, but I'm not familiar enough to know what implications that has
20:04:24 <jethr0> "(Parse (a, Nothing)) >>= return" =="(Parse (a, Nothing))"
20:04:32 <jethr0> ahh, you mean because of "a" and "b"
20:04:34 <jethr0> *grr*
20:04:46 <soysauce> bind has an obvious implementation though
20:05:01 <Cale> soysauce: what does the Parse type represent?
20:05:03 * soysauce tries it so he can play around in GHCi
20:05:13 <soysauce> Cale - it's almost the same type as ReadS, and it's the same idea
20:05:27 <jethr0> soysauce, you should unionize your parsetype
20:05:29 <Cale> Why isn't it a function type?
20:05:30 <soysauce> or rather... I guess not
20:05:42 <soysauce> Cale:
20:05:43 <soysauce> type ReadS a = String -> [(a, String)]
20:05:46 <jethr0> data ParseType = PInt Integer | PEmpty
20:05:51 <Cale> A parser for things is a function from strings, to lists of pairs of strings and things!
20:05:55 <soysauce> my parsing functions have type String -> (String, Maybe a)
20:05:57 <soysauce> it's *very* similar
20:05:58 * jethr0 is confused
20:06:27 <Cale> Okay, you probably really want  data Parse a = String -> (a, String)
20:06:36 <Cale> that is, a deterministic parser
20:06:37 <soysauce> what does that do?
20:06:43 <Cale> er
20:06:45 <Cale> type
20:06:46 <soysauce> I don't understand what -> does in that context
20:06:49 <Cale> or add a constructor :)
20:06:54 <Cale> function
20:07:03 <soysauce> example...?
20:07:07 <jethr0> aaahhh
20:07:14 <soysauce> I'm curious about the -> syntax in a data declaration
20:07:26 <jethr0> it's just a type
20:07:26 <Cale> a parser is a function from an input string to a value and remaining string
20:07:29 <Xianianol> The end function for Expr -> Expr would be then:
20:07:29 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
20:07:29 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
20:07:29 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat (n + m)
20:07:29 <Xianianol> evalStep env (Nat n :* Nat m) = Nat (n * m)
20:07:33 <soysauce> Parse is basically a closure used to make the types much simpler
20:07:36 <Cale> Okay, you probably really want  data Parse a = Parse (String -> (a, String))
20:07:38 <Cale> sorry
20:07:45 <soysauce> s/a/Maybe a/
20:07:51 <Cale> ah
20:07:59 <soysauce> because I want to detect parse failures
20:08:02 <Cale> data Parse a = Parse (String -> Maybe (a, String))
20:08:13 <soysauce> no
20:08:17 <Cale> no?
20:08:23 <soysauce> data Parse a = Parse (String -> (String, Maybe a))
20:08:28 <Cale> hmm...
20:08:40 <soysauce> the String represents unconsumed text
20:08:40 <Cale> It still gets to modify the string even if it fails?
20:08:46 <soysauce> no
20:08:54 <Cale> well, that's what that does :)
20:08:56 <soysauce> in the event of a parse failure, I want to be able to know where it was at
20:09:02 <Cale> ah, okay
20:09:15 <Cale> but you won't get any output
20:09:20 <soysauce> right
20:09:21 <Cale> (values)
20:09:30 <Cale> okay, that seems saner anyway
20:09:38 <soysauce> so I get (point at which it failed, Nothing) or (unconsumed input, Just _)
20:09:47 <Cale> okay
20:10:08 <soysauce> what's the difference between Parse (String -> (String, Maybe a)) and what I wrote, Parse (String, Maybe a)?
20:10:13 <Cale> return x = Parse (\s -> (s, x))
20:10:15 <Cale> er
20:10:16 <soysauce> I see that yours is a function, but I don't understand how that works
20:10:17 <Cale> return x = Parse (\s -> (s, Just x))
20:10:42 <Cale> see how it's now a parsing function and not just a value and a string?
20:10:46 <jethr0> functions are first-class citizens :)
20:10:48 <soysauce> yes, right
20:10:53 <Cale> You can't encode parsing as just a string
20:11:10 <soysauce> I can and am, just not monadically. Is this specific to making it a monad?
20:11:19 <Cale> well, not really
20:11:29 <Cale> your values of type Parse a weren't parsers
20:11:35 <soysauce> right
20:11:40 <Cale> they were the results of parsers
20:11:40 <soysauce> they were closures produced by a parser
20:11:48 <Cale> closures?
20:11:54 <Cale> They were just values, really.
20:11:57 <soysauce> sorry, perhaps poor terminology
20:11:59 <soysauce> yes
20:12:08 <soysauce> but they represent a parser state
20:12:30 <Cale> hmm... somewhat, yes.
20:12:36 <stepcut> if, data Parse a = Parse (String, Maybe a), I think you *can* make a Monad instance, but the function in 'm >>= f' will only be able to use the value inside 'Maybe a', and won't be able to use the String...
20:12:56 <Cale> Well, yes
20:13:02 <Cale> that's certainly a monad
20:13:09 <Cale> it's just not the one we're looking for
20:13:19 <stepcut> yes, it is not very useful :p
20:13:21 <Cale> or, I don't think so anyway
20:13:38 <soysauce> hm
20:14:00 * soysauce ponders
20:14:12 <soysauce> it strikes me that this is similar to a state transformer where String represents the parser state
20:14:26 <Cale> Xianianol: btw, you probably want to reorder those to put the more specific cases first
20:14:33 <Cale> Xianianol: or they'll never get used
20:14:44 <Cale> soysauce: yes
20:14:44 <stepcut> however, I do not see any other monad that can be defined for Parse, unless you change how parse is defined
20:14:56 <soysauce> stepcut - what would you suggest?
20:15:14 * stepcut ponders
20:15:22 <Cale> soysauce: why not make a parsing monad, like baby parsec?
20:15:59 <soysauce> String -> (String, Maybe a) is a very natural representation for the parser, but it's rather unwieldy otherwise
20:16:09 <soysauce> Cale - I wouldn't mind doing that, but I'm a little lost as to where to begin
20:16:24 <Cale> well, we'll try it then :)
20:16:48 <Cale> do you want your parser to be able to backtrack?
20:16:52 <soysauce> no
20:17:03 <Cale> okay, then the type you have there is about right
20:17:14 <Cale> data Parser a = Parser (\String -> (String, Maybe a))
20:17:14 <Cale>  -- this seems okay for now at least
20:17:29 <soysauce> yeah, it's pretty simple. It's very similar to ReadS, like I said; the main difference is that I produce only one element, and I can fail.
20:17:36 <soysauce> or fail gracefully, anyway
20:17:39 <Cale> now, we want to make this an instance of Monad
20:17:46 <soysauce> okay
20:17:55 <Cale> I gave away the answer to how to define return :)
20:18:05 <soysauce> yeah, that's fairly straightforward.
20:18:08 <soysauce> >>= is not...
20:18:28 <Cale> okay, well, let's think about what we want >>= to do
20:18:32 <Cale> and its type
20:18:35 <soysauce> (>>=) (s, Nothing) _ = (s, Nothing)
20:18:52 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
20:19:03 <soysauce> er, right, I was thinking of the old type
20:19:19 * soysauce thinks
20:19:24 <Cale> so we have  (Parser p) >>= f
20:19:44 <Cale> we may want to write runParser first :)
20:20:02 <Cale> which is easy if we switch to record syntax
20:20:02 * soysauce cheats
20:20:13 <soysauce> er, I was going to @djinn, but I guess I can't :)
20:20:28 <Cale> data Parser a = Parser { runParser :: String -> (String, Maybe a) }
20:21:24 <Cale> just for clarity's sake, so it's really really clear what it is that we're doing here, let's define  p >>= f
20:21:33 <soysauce> yes, I'm trying ;)
20:21:38 <Cale> rather than taking the parsing function out automatically
20:21:55 <soysauce> (>>=) (Parser f) g = g f
20:22:02 <soysauce> I guess there isn't any other way to do it
20:22:02 <Cale> we're trying to return a parser
20:22:15 <Cale> so the only way to do that
20:22:23 <Cale> is to start with the Parser constructor
20:22:33 <soysauce> well, g returns a parser
20:22:58 <soysauce> but that definition of >>= isn't particularly useful
20:23:05 <Cale> hmm
20:23:16 <Cale> but f isn't an appropriate argument to g
20:23:43 <soysauce> yeah, but it's difficult to do anything useful to a function without changing the type
20:23:52 <soysauce> and g has type a -> Parser b
20:24:08 <soysauce> the only permutation I can even think of is id, and that's simply not useful
20:24:10 <Cale> let me get you started here :)
20:24:11 <Cale>     p >>= f = Parser (\s -> 
20:24:11 <Cale>                 let (rest, v) = runParser p s
20:24:12 <soysauce> ok
20:24:30 <Cale> we run p
20:24:44 <Cale> and collect the return value, and the rest of the string
20:24:59 <soysauce> hmm...
20:25:37 <soysauce> well, rest gets the remainder of the string and v the `Maybe a' part
20:25:53 <soysauce> f takes a function as a parameter, though
20:26:07 <Cale> f takes a value
20:26:12 <soysauce> what's the type of f?
20:26:19 <soysauce> I thought it was String -> (String, Maybe a)
20:26:22 <Cale> a -> Parser b
20:26:33 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
20:26:40 <soysauce> yeah
20:26:46 <Cale> so p is a parser
20:26:49 <soysauce> but a is really String -> (String, Maybe a')
20:26:54 <Cale> no
20:26:56 <soysauce> ?
20:27:05 <soysauce> oh
20:27:06 <Cale> Parser a is really String -> (String, Maybe a)
20:27:08 <soysauce> oh!
20:27:14 <soysauce> ok, I see
20:27:45 <soysauce> so then I run f rest
20:27:56 <soysauce> or rather the function I put into the monad will do that when it is executed
20:28:07 <Cale> hmm
20:28:08 <soysauce> wait, I see how to do this
20:28:13 <Cale> you're jumping the gun a bit
20:28:27 <soysauce> @type Monad.liftM2
20:28:28 <lambdabot> forall r (m :: * -> *) a2 a1.
20:28:28 <lambdabot> (Monad m) =>
20:28:28 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:28:32 <Cale> have to deal first with the fact that you got a Maybe value
20:28:35 <soysauce> @type Monad.liftM
20:28:36 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
20:28:38 <Cale> just write it plainly :)
20:28:50 <Cale> (use case)
20:29:00 <soysauce> no need, Maybe will do that for me
20:29:04 <soysauce> wait a sec...
20:29:20 <Cale> well, I suppose, kind of
20:29:36 <Cale> I suppose the maybe function could be ued
20:29:39 <Cale> @type maybe
20:29:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:30:06 <soysauce> no, I meant that (>>=) :: Maybe a -> (a -> Maybe b) -> b will do it
20:30:20 <Cale> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
20:30:27 <Cale> but...
20:30:43 <Cale> that doesn't *quite* work out here, I don't think
20:30:53 <Cale> possibly you see a way to use it that I don't
20:31:04 <soysauce> p >>= f = Parser (\s -> let (rest, v) = runParser p s in (f v) rest)
20:31:05 <musasabi> Is there a way to tell GHC not to lock files?
20:31:21 <soysauce> it's different, I guess, since the new parser has to propigate old state
20:31:25 <Cale> soysauce: (f v) is a type error
20:31:35 <soysauce> how ?
20:31:39 <soysauce> it has type a -> Parser b
20:31:44 <Cale> v :: Maybe a
20:31:45 <soysauce> oh
20:31:50 <soysauce> yes, sorry
20:32:00 <Cale> also, you want another runParser in there
20:32:19 <Cale> but deal with that after branching for the cases of the Maybe
20:33:09 <soysauce> what is the type of runParser?
20:33:53 <Cale> runParser :: Parser a -> String -> (String, Maybe a)
20:33:53 <soysauce> runParser :: Parser a -> String -> Maybe a?
20:33:57 <soysauce> er, right
20:34:01 <soysauce> (String, Maybe a) at the end
20:34:23 <soysauce> runParser (Parser f) s = f s?
20:34:47 <Cale> yes
20:35:20 <Cale> man, firefox is greedy for keyboard input -- it seems to steal the focus on me at strange times
20:35:42 <Cale> particularly when it's open at gmail
20:35:52 <Xianianol> About the Expr->String, do I just convert directly like: stepEval env (e1 :+ e2) = show (evalStep env (e1 :+ e2)) ?
20:36:33 <Cale> Xianianol: if you already have a nice show function, you shouldn't need to do anything
20:36:57 <Xianianol> Okay, I don't have a nice show function for sure.
20:37:14 <soysauce> Cale - why do I want a second runParser?
20:37:17 <Cale> otherwise, you want cases like  showExpr (e1 :+ e2) = "(" ++ showExpr e1 ++ " + " ++ showExpr e2 ++ ")"
20:37:35 <Cale> soysauce: to run the parser that you get from applying f
20:37:43 <Xianianol> I see...
20:37:43 <soysauce> hmm
20:38:06 <Cale> soysauce: in this function, your goal is to return a   (String, Maybe b), right?
20:38:13 <soysauce> but with (>>=), am I not just constructing higher-order functions?
20:38:18 <Cale> hm?
20:38:22 <soysauce> no
20:38:28 <soysauce> I want a Parser b
20:38:34 <soysauce> which is Parser (String -> (String, Maybe b))
20:38:35 <Cale> Well, in order to get one
20:38:45 <Cale> you apply the Parser constructor to a function
20:38:50 <soysauce> yes...
20:38:57 <Cale> and that function has to return (String, Maybe b)
20:39:05 <soysauce> right
20:39:09 <Cale> and you're writing that function right now, as a lambda term
20:39:09 <soysauce> when applied to a string
20:39:15 <Cale> \s ->
20:39:21 <Cale> let ...
20:39:31 <soysauce> well, this is what I wrote:
20:39:32 <soysauce> p >>= f = Parser nxt
20:39:32 <soysauce> 	where nxt s = case x of
20:39:32 <soysauce> 	              	Nothing -> (rest, v)
20:39:32 <soysauce> 	              	Just x' -> f x
20:39:32 <soysauce> 	      	where (s', x) = runParser p s
20:40:00 <musasabi> Can it really be that the only solution is FFI?
20:40:02 <soysauce> er, whoops.
20:40:25 <Cale> soysauce: really, the code I gave you should be okay :)
20:40:41 <Cale> (I already have a working parser, so I know that it works out in the end :)
20:41:04 <musasabi> seems like even openFd locks the file in an exclusive manner.
20:41:12 <soysauce> oh, I see
20:41:33 <musasabi> which means that even if I do open + unlock there is a race condition
20:42:30 <musasabi> a shared Handle does not work, because I need to seek on the files
20:43:16 <soysauce> Cale - I had forgotten that I was in a lambda. I know that it's incorrect to think about when a function executes and more correct to think about how they execute relative to each other, but I always find it easier to think strictly
20:43:32 <soysauce> so I was thinking that the second parser would be evaluated when (>>=) was called
20:43:44 <soysauce> but now I see. Since we're in a lambda, we're generating a continuation
20:44:01 <soysauce> the remainder of the string is bound to the next parser in sequence
20:44:24 <soysauce> this unsurprisingly looks a lot like the ST monad
20:46:09 <soysauce> nice. Now it's an instance of Monad and everything./
20:46:41 <Cale> soysauce: now we actually need some basic parsers
20:46:46 <soysauce> yep, got those.
20:46:56 <Cale> char c = Parser (\s -> case s of []     -> ([], Nothing)
20:46:56 <Cale>                                  (x:xs) -> if x == c then (xs, Just x) 
20:46:56 <Cale>                                                      else (xs, Nothing)
20:46:56 <Cale>                 )
20:47:07 <soysauce> Cale - already did that ;)
20:47:16 <Cale> have you done <|> ?
20:47:23 <soysauce> no, is that alternation?
20:47:29 <Cale> yes
20:47:34 <soysauce> well, I don't need that...
20:47:46 <Cale> well, nice exercise anyway
20:47:59 <soysauce> yeah, but that's not foremost on my mind when I have a deadline ;)
20:48:07 <Cale> p <|> q = Parser $ \s -> 
20:48:08 <Cale>     let (rest, v) = runParser p s
20:48:08 <Cale>     in case v of
20:48:08 <Cale>         Nothing -> runParser q s
20:48:08 <Cale>         Just x -> (rest, v)
20:48:22 <soysauce> yeah
20:49:30 <jethr0> cale, you remember when philippa talked about having a parsec parser generate a parsec parser from a grammar file?
20:49:50 <Cale> hehe
20:49:50 <Cale> no
20:49:57 <Cale> but that's a neat idea :)
20:50:08 <jethr0> well, from what i understood she wanted to do it at runtime, and without eval
20:50:13 <Cale> sure
20:50:15 <Cale> you could
20:50:16 <jethr0> and i just don't get, how to do it
20:50:20 <jethr0> how?
20:50:27 <Cale> Parsec builds parsers at runtime
20:50:32 <Cale> they're first class values
20:50:47 <jethr0> ah, hadn't looked at it from that angle
20:50:51 <Cale> you can very well have a  Parser (Parser a)
20:50:58 <jethr0> true, just "functions" stuck together
20:51:12 <jethr0> like what you just did with soysauce
20:51:16 <Cale> yep
20:51:22 <jethr0> hmm, nice
20:51:47 <jethr0> so, you could build a GUI parser builder
20:51:51 <Cale> sure
20:51:56 <jethr0> where you just plug and play your components
20:51:59 <jethr0> *cool*
20:52:44 <jethr0> btw, haskell with mandatory parens and prefix operators/functions looks _extremely_ like scheme :)
20:52:53 <jethr0> s/looks/reminds me/
20:53:05 <Cale> yeah
20:53:08 <Cale> brackets = do { char '(';
20:53:08 <Cale>                 n <- brackets;
20:53:08 <Cale>                 char ')';
20:53:08 <Cale>                 m <- brackets;
20:53:08 <Cale>                 return (max (n+1) m) }
20:53:09 <Cale>             <|> return 0
20:53:11 <jethr0> "(if ((<) 4 3) then (let x = 5 in ((==) x 4)) else (\\x -> ((==) x 4)))"
20:53:19 <Cale> we can already write that parser with just what we have :)
20:53:33 <jethr0> i know, did that already
20:53:40 <Cale> :)
20:53:59 <jethr0> i wanted to parse a subset of haskell, put it into template haskell and run
20:54:09 <jethr0> for the obfuscated haskell contest
20:54:15 <Cale> hehe
20:54:23 <jethr0> but it doesn't seem i'm gonna do it :(
20:54:29 <Cale> It's difficult
20:54:39 <Cale> Parsing Haskell isn't trivial.
20:54:41 <jethr0> would have been cool though to compile the whole program in itself (kinda + imports)
20:55:12 <jethr0> that's why i chose mandatory parens, prefix ops and no syntax checking.
20:55:24 <soysauce> isn't that because Haskell isn't um, what's the word for it, a language that does not take into account columns
20:55:32 <soysauce> free-form or something
20:55:32 <Cale> did you see the program I wrote the other day which determines if it's been compiled with GHC or not?
20:55:34 <jethr0> just parsing and TH, supposing correct input
20:55:46 <jethr0> yup
20:55:55 <jethr0> yup mean the "--" trick
20:56:00 <jethr0> you
20:56:01 <Cale> yeah --:
20:56:20 <Cale> GHC treats it as a comment when it shouldn't
20:56:43 <jethr0> i heard your idea about that as an entry for ObfuscatedH, but it'd be difficult to exploit well
20:57:12 <jethr0> but how cool would a program be that compiles itself over and over with little changes until the final result is assembled
20:57:18 <Cale> :)
20:57:25 <soysauce> the problem with parsing Haskell is the fact that it's not free-form, is it not?
20:57:36 <Cale> soysauce: well, that's the first problem
20:57:38 <jethr0> it's type-driven i guess
20:57:43 <Cale> no
20:57:46 <Cale> the type system is later
20:57:52 <jethr0> so, to know how many arguments to expect you have to know the type of the function?
20:58:00 <Cale> no
20:58:01 <soysauce> the type system should never affect the parser
20:58:09 <jethr0> so, how does it do it?
20:58:11 <Cale> it's not a syntax error to apply too many arguments
20:58:17 <jethr0> hmm, well
20:58:22 <Cale> it's a type error
20:58:44 <soysauce> @type Control.Arrow.second
20:58:45 <lambdabot> forall (a :: * -> * -> *) c d b.
20:58:45 <lambdabot> (Control.Arrow.Arrow a) =>
20:58:45 <lambdabot> a b c -> a (d, b) (d, c)
20:58:49 <Cale> besides,  f x y z = ((f x) y) z
20:59:06 <Cale> that's how it parses it
20:59:14 <jethr0> parsing "let y = let x = if 4 < 3 then let y = 4 in y else 5 in x in in y" caused me quite the headache already :)
20:59:14 <soysauce> that makes sense
20:59:55 <Cale> heh
20:59:55 <soysauce> that means that if you have a function a -> (a -> b), then f x y is not a semantic error either, given the correct types
21:00:05 <soysauce> although I guess that's the same as a -> a -> b
21:00:12 <Cale> yes
21:00:13 <Cale> it is
21:00:19 <soysauce> I never noticed that.
21:00:22 <Cale> -> associates to the right
21:00:28 <soysauce> yeah
21:00:44 <jethr0> but i couldn't figure out how to parse "if f a b c then d else e" in parsec...
21:00:54 <jethr0> i.e. knowing when to stop before the "then"
21:01:24 <Cale> IfThenElse (App (App (App f a) b) c) d e
21:01:39 <jethr0> sure, i mean the monadic part :)
21:01:58 <Cale> well, then is a keyword
21:02:09 <Cale> so it can't occur as an identifier
21:02:16 <Cale> so you should be able to tell the two apart
21:02:44 <jethr0> yes, but how do i do "(many1 expr, butNot "then")"?
21:03:05 <Cale> "then" isn't a valid expr
21:03:07 <jethr0> ah, maybe i should exclude reserved words from identifiers/etc
21:03:19 <Cale> and it's not even many1 expr
21:03:29 <Cale> but just expr
21:03:48 <jethr0> cale, i've got a very simplistic parser right now, because i only want to parse a specific, simplified subset...
21:04:13 <jethr0> but if i want to compile the code in itself, i'll need to support "do, <-, >>=, ..." too :(
21:04:22 <soysauce> Cale - nice, this monadic parser works... thanks a bunch
21:04:30 <Cale> soysauce: no problem :)
21:04:46 <soysauce> runParser ((return ()) >>= parsedec >>= parsews >>= parsedec) "12  34abc" produces ("abc",Just (((),12),34))
21:04:56 <Cale> I've never actually written a monadic parser before :)
21:04:57 <soysauce> which is what the CPS version did, just not as elegantly
21:05:26 <soysauce> well, it's easier to read, at least
21:05:35 <Cale> :)
21:05:50 <soysauce> the CPS version went something like consumeData (parsedec (parsews (parsedec s)))
21:06:05 <soysauce> except it's written right->left, not left->right
21:06:17 <soysauce> and each parsing function had to incur the complexity of dealing with Maybe
21:06:42 <Cale> hmm, why is parsews taking a parameter?
21:06:56 <Xianianol> Humm, evalStep seems to producing same structures as my parser, in fact, it seems that it is not doing (Nat n :+ Nat m) at all
21:06:57 <soysauce> parsews :: a -> Parser a
21:07:04 <Cale> hmm
21:07:08 <Cale> soysauce: why :)
21:07:13 <soysauce> it doesn't produce any data, it just eats whitespace
21:07:16 <Cale> parsews :: Parser ()
21:07:20 <soysauce> nope
21:07:23 <soysauce> that's what I had originally
21:07:32 <soysauce> but if I make the types a -> Parser a, then I can use them in bind like that
21:07:50 <Cale> runParser ((return ()) >>= parsedec >> parsews >>= parsedec) "12  34abc"
21:07:58 <soysauce> I was thinking of making a function wrap :: Parser b -> (a -> Parser (a, b)) or something
21:08:00 <Cale> note the deleted =
21:08:12 <Cale> or you could use do-notation :)
21:08:23 <soysauce> right, but I can't use them like that because their types would be Parser a
21:08:32 <soysauce> by making them be a -> Parser b, I can use bind
21:08:40 <Cale> er
21:08:41 <Cale> oh
21:08:46 <soysauce> parsews :: a -> Parser a
21:08:48 <Cale> I see
21:08:48 <soysauce> parsedec :: a -> Parser (a, Int)
21:08:50 <soysauce> parseeol :: a -> Parser a
21:08:57 <Cale> you're just passing values through
21:09:00 <soysauce> yep
21:09:10 <soysauce> that's what I did when I used CPS, it was just more of a pain
21:09:19 <Cale> hmm :)
21:09:47 <jethr0_> sry disconnected :(
21:09:50 <jethr0_> "(if ((<) 4 3) then (let x = 5 in ((==) x 4)) else (\\x -> ((==) x 4)))"
21:09:54 <Cale> there might be an even more elegant way if you added state
21:10:12 <jethr0_> EApply (EFun "if'") [EApply (EFun "(<)") [ENum 4,ENum 3],EApply (ELambda [EIdent "x"] (EApply (EFun "(==)") [EIdent "x",ENum 4])) [ENum 5],ELambda [EIdent "x"] (EApply (EFun "(==)") [EIdent "x",ENum 4])]
21:10:15 <jethr0_> you mean me?
21:10:16 <soysauce> like I said, I was thinking of making a function that would do Parser b -> (a -> Parser (a, b)) or something like that
21:10:48 <Cale> data Parser s a = Parser { runParser :: (String,s) -> (String, s, Maybe a) }
21:10:53 <soysauce> but I like the way it is now because, even though I incur some complexity, parsews and parseeol don't need to produce useless tuples
21:11:15 <japple> @djinn a -> a -> a
21:11:15 <lambdabot> x :: a -> a -> a
21:11:15 <lambdabot> x _ x2 = x2
21:11:17 <soysauce> what would s be?
21:11:23 <Cale> state
21:11:31 <japple> @djinn a -> a -> a -> a
21:11:31 <lambdabot> x :: a -> a -> a -> a
21:11:31 <lambdabot> x _ _ x3 = x3
21:11:40 <soysauce> I thought that's what String represented
21:11:43 <Cale> this is easier to add with monad transformers though
21:11:58 <mwc> Cale, feel like giving me a hint with group theory? I'm trying to figure out how to show that if a group G contains a exactly 1 p-Sylow subgroup for each prime divisor of G, then they're pairwise intersections are all trivial
21:12:27 <soysauce> well, I'm pretty happy with the way it turned out
21:12:28 <Cale> mwc: okay
21:12:44 <Cale> soysauce: the way you're using it is just a little unconventional :)
21:12:51 <soysauce> yah, I suppose
21:13:09 <Cale> soysauce: the usual thing is to only bind values when you're interested in them
21:13:18 <soysauce> *nods*
21:13:42 <soysauce> that's problematic here, though, because if I don't bind parsews's output then I can't use anything from earlier computations
21:13:51 <Cale> sure you can
21:13:56 <japple> @djinn Bush a = Bcons a (Bush (Bush a)) | Bnil
21:13:57 <lambdabot> Cannot parse command
21:14:07 <soysauce> computations are accumulated in the result of a parser, though
21:14:13 <japple> @djinn Bush a = Bcons a (Bush (Bush a)) | Bnil; a -> a
21:14:14 <lambdabot> Cannot parse command
21:14:28 <japple> @djinn data Bush a = Bcons a (Bush (Bush a)) | Bnil
21:14:28 <lambdabot> Cannot parse command
21:14:33 <Cale> parsedec >>= \n -> parsews >> parsedec >>= \m -> return (n,m)
21:14:36 <Cale> or,
21:14:38 <soysauce> japple - doesn't work with arbitrary types
21:14:48 <soysauce> only with Either and a couple others
21:14:55 <Cale> do {n <- parsedec; parsews; m <- parsedec; return (n,m)}
21:15:01 <japple> but, the example from the announcement:
21:15:02 <Cale> clearer?
21:15:11 <soysauce> Cale - yes, true, but then I have to use lambdas
21:15:16 <japple> Â  Djinn> type C a = (a -> r) -> r 
21:15:16 <Cale> use do :)
21:15:19 <soysauce> or that
21:15:23 <Cale> parsedec :: Parser Integer
21:15:27 <Cale> parsews :: Parser ()
21:15:29 <soysauce> anyway, I'm very content with it now
21:15:41 <Cale> mwc: okay, I'll have a look :)
21:16:19 <Cale> mwc: so all those Sylow p-subgroups are normal
21:17:01 <japple> @djinn (b -> Maybe (a, b)) -> b -> [a]
21:17:01 <lambdabot> -- x cannot be realized.
21:17:05 <mwc> yeah, there's exactly one of each prime divisor. Basically, I'm trying to figure out how to show G is the direct product of the Sylow subgroups
21:17:31 <japple> @djinn (b -> Maybe (a, b)) -> b -> Maybe (a, b)
21:17:31 <lambdabot> x :: (b -> Maybe (a, b)) -> b -> Maybe (a, b)
21:17:31 <lambdabot> x x1 x2 = x1 x2
21:17:54 <japple> @djinn (b -> Maybe (a, b)) -> b -> [Maybe (a,b)]
21:17:54 <lambdabot> -- x cannot be realized.
21:19:16 <Cale> mwc: consider the order of any nontrivial element of one of the Sylow p-subgroups
21:19:17 <japple> @djinn (b -> c) -> b -> [c]
21:19:17 <lambdabot> -- x cannot be realized.
21:19:31 <japple> @djinn (b -> c) -> b -> Maybe c
21:19:31 <lambdabot> -- x cannot be realized.
21:19:34 <Cale> could it be in some Sylow q-subgroup for p /= q ?
21:19:39 <soysauce> japple - doesn't work with Maybe types
21:19:49 <japple> nope, sure doesn't
21:19:52 <mwc> Ah, aha!
21:19:52 <soysauce> @djinn a -> (a -> b) -> b
21:19:53 <lambdabot> x :: a -> (a -> b) -> b
21:19:53 <lambdabot> x x1 x2 = x2 x1
21:19:59 <mwc> Wow, I can't believe I missed that!
21:20:01 <mwc> thanks
21:20:16 <soysauce> it doesn't work with lists, either
21:20:23 <Cale> mwc: no problem
21:20:23 <soysauce> @djinn a -> (a -> Either b) -> b
21:20:24 <lambdabot> -- x cannot be realized.
21:20:28 <soysauce> @djinn a -> (a -> Either b) -> Either b
21:20:28 <lambdabot> x :: a -> (a -> Either b) -> Either b
21:20:28 <lambdabot> x x1 x2 = x2 x1
21:20:34 <Cale> Either b isn't a type
21:20:40 <japple> @djinn (b -> c) -> b -> Either c ()
21:20:41 <lambdabot> x :: (b -> c) -> b -> Either c ()
21:20:41 <lambdabot> x x1 x2 = Left (x1 x2)
21:20:48 <soysauce> oh, d'oh
21:20:49 <Xianianol> Cale, sorry for bothering you again, is just that...evalStep does not seem to be working the way it should.
21:21:02 <Cale> Xianianol: what does it do?
21:21:12 <soysauce> @djinn Bool -> a -> b -> Either a b
21:21:13 <lambdabot> x :: Bool -> a -> b -> Either a b
21:21:13 <lambdabot> x _ x2 _ = Left x2
21:21:20 <soysauce> heh, interesting
21:21:28 <Xianianol> With this definition: evalStep env (Nat n :* Nat m) = Nat(n * m) ; When I do (Nat 5 :+ Nat 6) it should return (Nat 11)
21:21:52 <Xianianol> However, it just seems to return what my parser returns, or close enough
21:22:15 <Cale> Xianianol: it's not a parser
21:22:29 <Xianianol> For example, if I input 5+5+5, it Nat 5 :+ (Nat 5 :+ Nat 5)
21:22:37 <Xianianol> *it returns Nat 5 :+ (Nat 5 :+ Nat 5)
21:22:46 <Cale> okay, have you got the definition for :+ in there?
21:22:51 <Xianianol> Yes
21:22:52 <Cale> you pasted the one for :*
21:22:59 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
21:22:59 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
21:22:59 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat(n + m)
21:22:59 <Xianianol> evalStep env (Nat n :* Nat m) = Nat(n * m)
21:22:59 <Xianianol> evalStep env (Nat n) = Nat n
21:23:01 <Xianianol> Uups, sorry.
21:23:02 <Cale> ah
21:23:12 <Cale> move the first two lines down
21:23:24 <Cale> the first line which succeeds in its pattern match gets to run
21:23:36 <Cale> you should flip all those lines over
21:23:47 <Cale> Most specific first
21:23:55 <japple> @djinn Bool -> Either Bool Bool
21:23:56 <lambdabot> x :: Bool -> Either Bool Bool
21:23:56 <lambdabot> x x1 = Left x1
21:24:09 <Xianianol> oh, is that a general rule that I should follow in Haskell or jsut in this case ?
21:24:12 <soysauce> Cale - question, if my parsers were to have type Parser a, then how would I combine them with >>=?
21:24:16 <soysauce> lots of lambdas?
21:24:17 <Cale> Xianianol: in general
21:24:26 <Xianianol> Thanks, good to know that.
21:24:31 <Cale> soysauce: lambdas, or just do-notation
21:24:36 <Cale> I tend to use do-notation
21:24:40 <soysauce> hm
21:24:48 <soysauce> heh, I never use do notation, it's harder for me to understand
21:24:58 <Cale> well, there's only 2 or 3 rules to it
21:25:02 <soysauce> I know
21:25:04 <Cale> well, actually
21:25:08 <Cale> here's a good chance
21:25:10 <soysauce> I know how it works, but it's much easier for me to use bind
21:25:14 <Cale> write it with bind
21:25:19 <Cale> then write it with do notation
21:25:28 <Cale> and see if you can spot what's going on :)
21:25:36 <japple> @djinn a -> (a,a)
21:25:36 <lambdabot> x :: a -> (a, a)
21:25:36 <lambdabot> x x1 = (x1, x1)
21:25:40 <Xianianol> Humm, my order is now:
21:25:41 <Xianianol> evalStep env (Nat n) = Nat n
21:25:41 <Xianianol> evalStep env (Nat n :* Nat m) = Nat(n * m)
21:25:41 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat(n + m)
21:25:41 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
21:25:41 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
21:25:44 <Xianianol> But it does the same.
21:25:50 <soysauce> @djinn (a, b) -> a
21:25:51 <lambdabot> x :: (a, b) -> a
21:25:51 <lambdabot> x (v2, _) = v2
21:25:58 <soysauce> yay, it implemented fst correctly
21:26:02 <Cale> Xianianol: it shouldn't
21:26:11 <Cale> Xianianol: make sure the file is saved and reloaded
21:26:19 <japple> @djinn (forall f . a -> f a) -> a -> f (f a)
21:26:20 <lambdabot> -- x cannot be realized.
21:26:43 <Xianianol> Humm...I sort of see the problem now.
21:26:45 <soysauce> Xianianol - shouldn't you have parentheses around (e1 :* e2) and (e1 :+ e2)?
21:26:54 <Cale> soysauce: no
21:26:59 <Xianianol> Nope.
21:27:06 <Cale> soysauce: in fact, that would mean an infinite loop
21:27:39 <Xianianol> If I put them it would look like this: evalStep env (e1 :* e2) = evalStep env (e1 :* e2)
21:27:54 <Cale> @djinn forall g. (forall f. a -> f a) -> a -> g (g a)
21:27:54 <lambdabot> -- x cannot be realized.
21:28:26 <soysauce> hm
21:28:35 <japple> @djinn Bool
21:28:35 <lambdabot> -- x cannot be realized.
21:28:43 <japple> @djinn a -> Bool
21:28:44 <lambdabot> -- x cannot be realized.
21:28:45 <Cale> pfft, can't even handle higher-rank, higher-kinded polymorphism
21:28:53 <Cale> ;)
21:28:58 <japple> yeah, what a rip :-)
21:29:06 <Xianianol> Humm, if it is two terms/expressions only, it would work fine. For example, 5+5 would return Nat 10, however, 5+5+5 would return Nat 5 :+ (Nat 5 :+ Nat 5)
21:29:07 <jethr0> ok, gotta go to bed. good nite
21:29:33 <japple> Probably no dependent recursive intersection types, Either.
21:30:24 <ricebowl> ah, un nuevo usario que debe estar en #haskell.es
21:30:33 <julian> @djinn a->a
21:30:34 <lambdabot> x :: a -> a
21:30:34 <lambdabot> x x1 = x1
21:30:38 <Cale> Xianianol: so, you want to also try to recurse on the right, after first checking if you can recurse on the left
21:30:54 <japple> @djinn a -> ()
21:30:54 <lambdabot> x :: a -> ()
21:30:54 <lambdabot> x _ = ()
21:31:01 <japple> @djinn ()
21:31:01 <Cale> Xianianol: hmm...
21:31:01 <julian> je, cool
21:31:01 <lambdabot> x :: ()
21:31:01 <lambdabot> x = ()
21:31:05 <Xianianol> So, I need more patterns...
21:31:18 <japple> @djinn Either a b -> Either a ()
21:31:19 <lambdabot> x :: Either a b -> Either a ()
21:31:19 <lambdabot> x x1 = case x1 of
21:31:19 <lambdabot>    Left l2 -> Left l2
21:31:19 <lambdabot>    Right r3 -> Right ()
21:31:44 <japple> @djinn [()]
21:31:45 <lambdabot> -- x cannot be realized.
21:32:12 <julian> @djinn ((a->a)->a)->a
21:32:13 <lambdabot> x :: ((a -> a) -> a) -> a
21:32:13 <lambdabot> x x1 = x1 (\ c6 -> c6)
21:32:19 <japple> @djinn () -> ()
21:32:20 <lambdabot> x :: () -> ()
21:32:20 <lambdabot> x _ = ()
21:32:59 <Cale> @djinn (t -> t) -> t
21:33:00 <lambdabot> -- x cannot be realized.
21:33:02 <Cale> aww
21:33:34 <Cale> @djinn ((a -> b) -> (a -> b)) -> (a -> b)
21:33:34 <lambdabot> -- x cannot be realized.
21:33:41 <Xianianol> Something like...:
21:33:41 <Xianianol> evalStep env (Nat n) = Nat n
21:33:42 <Xianianol> evalStep env (Nat n :* Nat m) = Nat(n * m)
21:33:42 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat(n + m)
21:33:42 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
21:33:42 <julian> (A=>A)=>A not is a theorem
21:33:42 <Xianianol> evalStep env (e1 :* e2) = (e1 :* evalStep env e2)
21:33:44 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
21:33:46 <julian> ;)
21:33:46 <Xianianol> evalStep env (e1 :+ e2) = (e1 :+ evalStep env e2)
21:33:48 <Xianianol> ?
21:33:53 <japple> @djinn ((a->b) -> a) -> a
21:33:53 <lambdabot> -- x cannot be realized.
21:34:12 <Cale> Xianianol: well, you actually want to check whether it does find an expression to reduce on the left
21:34:26 <Cale> and if not, then reduce on the right
21:34:33 <julian> @djinn a -> IO ()
21:34:33 <lambdabot> -- x cannot be realized.
21:34:52 <Cale> julian: x f = f (x f) :)
21:35:08 <Xianianol> humm
21:35:29 <Xianianol> Doesn't the left recursion and the right recursion does that ?
21:35:50 <Cale> Xianianol: no, the first pattern will succeed and the second never tried
21:36:25 <Cale> so you want the test to be something else
21:36:50 <japple> @djinn (forall a . a)
21:36:50 <lambdabot> -- x cannot be realized.
21:37:00 <japple> @djinn (forall a . a) -> ()
21:37:01 <lambdabot> x :: forall a . a -> ()
21:37:01 <lambdabot> x _ = ()
21:37:12 <Xianianol> Something like...(e1 :+ e2) +: Nat n ?
21:37:15 <japple> @djinn (forall a . a) -> (b -> c) -> c
21:37:16 <lambdabot> -- x cannot be realized.
21:37:31 <Xianianol> Humm, shouldn't be...
21:37:42 <Cale> Xianianol: like using a guard to check if any reduction could occur on the left
21:37:54 <julian> @djinn (forall a . a -> (b ->c) ->c )
21:37:55 <lambdabot> -- x cannot be realized.
21:38:13 <soysauce> @type Monad.liftM
21:38:13 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:38:17 <Cale> @djinn (forall a . a) -> (b ->c) ->c
21:38:17 <lambdabot> -- x cannot be realized.
21:38:22 <soysauce> @type Monad.liftM2
21:38:23 <lambdabot> forall r (m :: * -> *) a2 a1.
21:38:23 <lambdabot> (Monad m) =>
21:38:23 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:38:31 <soysauce> @type uncurry
21:38:32 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:38:48 <Xianianol> But then, I don't see what can be stopping reduction in 5+5+5...Since it should be able to be reduced to 10+5 and then 15
21:38:50 <soysauce> @pl (\x y -> (x, y))
21:38:50 <lambdabot> (,)
21:38:54 <soysauce> d'oh
21:38:58 <soysauce> @type Monad.liftM2 (,)
21:38:59 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
21:39:22 <japple> @djinn (a -> b -> c) -> (a, b) -> c
21:39:22 <lambdabot> x :: (a -> b -> c) -> (a, b) -> c
21:39:22 <lambdabot> x x1 (v3, v4) = x1 v3 v4
21:39:44 <japple> what is @pl?
21:40:03 <soysauce> pointless
21:40:14 <soysauce> eliminates lambdas
21:40:15 <shapr> japple: Is this your first time here?
21:40:22 <japple> Indeed
21:40:30 <shapr> I thought you might find your way here sooner or later.
21:40:47 <japple> [looks around room for camera]
21:40:57 <shapr> I assume you're Jim Apple?
21:41:03 <japple> I am
21:41:08 <shapr> Hi, I'm Shae Erisson.
21:41:08 <Cale> @pl \x y z -> z y x
21:41:09 <lambdabot> flip (flip . flip id)
21:41:49 <japple> Hi! I have trouble tracking names, so I'm going to google you now. I assume we've met on LtU & haskell-cafe?
21:41:52 <shapr> Anyway, I've seen some of your posts on LtU and the mailing lists, I think you'll like the discussions here.
21:41:53 <Cale> Xianianol: :+ isn't associative
21:42:06 <shapr> Yes, please google me.
21:42:09 <shapr> @google shae erisson
21:42:10 <lambdabot> http://www.faqts.com/knowledge_base/community/index.phtml/id/842
21:42:15 <shapr> yeesh
21:42:16 <Cale> heh
21:42:21 <shapr> @google shae matijs erisson
21:42:21 <Cale> @google cale gibbard
21:42:22 <lambdabot> http://lists.debian.org/debian-openoffice/2003/01/msg00147.html
21:42:23 <lambdabot> http://article.gmane.org/gmane.comp.lang.haskell.cafe/8316
21:42:38 <shapr> @google jim apple haskell
21:42:38 <lambdabot> http://blog.gmane.org/gmane.comp.lang.haskell.glasgow.user
21:42:50 <Korollary> yes, yes, we're all famous...
21:42:57 <Cale> that's interesting
21:43:05 <Cale> I wonder why it picked that message
21:43:10 <Cale> (for me)
21:43:24 <shapr> I also wonder why it picked that message for me.
21:43:28 <shapr> @google shapr haskell
21:43:29 <lambdabot> http://haskell.org/hawiki/QuotesPage
21:43:32 <Korollary> hah
21:43:32 <shapr> heh!
21:43:50 <shapr> At least that's accurate.
21:44:02 <Cale> <shapr> GHC has more flags than the UN
21:44:06 <Korollary> why are you op today, shapr?
21:44:28 <shapr> Oh, Heffalump was calling me names earlier.
21:44:41 <shapr> So I had to tactfully kick him off the channel to get his attention.
21:45:02 --- mode: shapr set -o shapr
21:45:25 <soysauce> @pl \x y -> y
21:45:25 <lambdabot> const id
21:45:32 <soysauce> @type const
21:45:33 <lambdabot> forall a b. a -> b -> a
21:46:04 <soysauce> @type Monad.liftM2 (const id)
21:46:04 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a2
21:46:09 <shapr> Anyway, it's time for me to go to sleep.
21:46:19 <soysauce> heh, that looks a lot like >>
21:46:26 <Xianianol> Okay, now I am blank :-/ Assuming that I would really want to use guarded condition, I need to understand why it is not associative...
21:46:27 <soysauce> or sequence_
21:46:29 <soysauce> @type sequence_
21:46:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:46:33 <soysauce> @type sequence
21:46:34 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
21:46:41 <soysauce> or, what was it...
21:46:50 <Xianianol> And what's actually stopping the reduction
21:47:24 <Xianianol> 5+5+5 should be seen as, at worse case, 5+(5+5)....humm
21:47:40 <Xianianol> The brackets would stop the reduction I assume :-/
21:48:14 <soysauce> @pl \p x -> Monad.liftM2 (const id) (return x) p
21:48:15 <lambdabot> ((Monad .) .) . flip (fmap . const id)
21:48:18 <japple> Where can I find @pl in an offline form?
21:48:33 <shapr> @version
21:48:33 <lambdabot> lambdabot 3p222, GHC 6.5.20050806 (Linux i686)
21:48:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
21:49:12 <japple> thanks
21:49:27 <Xianianol> Still can't see what should I be checking in the guarded conditions...
21:49:47 <japple> @pl \y -> map (\x -> fst $ head $ filter ((== x) . snd) $ zip [0 ..] y) y
21:49:47 <lambdabot> map =<< ((fst . head) .) . flip (filter . (. snd) . (==)) . zip [0..]
21:50:54 <soysauce> blah, a working @djinn would be so nice right about now
21:51:20 <japple> maybe we can do it manually - what's the type?
21:51:44 <Cale> Xianianol: whether you'll be able to reduce something on the left or not
21:51:58 <soysauce> japple - I already have it worked out
21:52:16 <soysauce> it wasn't that complex, but I'm still relatively new to Haskell, and working with monads is not entirely straightforward.
21:52:22 <soysauce> parseign :: Parser b -> a -> Parser a
21:52:22 <soysauce> parseign p x = p >> (return x)
21:52:55 <Xianianol> Should be something like this...
21:52:55 <Xianianol> evalStep env (e1 :* e2) | = (evalStep env e1 :* e2)
21:52:55 <Xianianol> | otherwise = (e1 :* evalStep env e2)
21:52:55 <Xianianol> evalStep env (e1 :+ e2) | = (evalStep env e1 :+ e2)
21:52:56 <Xianianol> | otherwise = (e1 :+ evalStep env e2)
21:53:05 <Xianianol> But of course, I basically miss the core.
21:53:11 <Cale> Xianianol: yeah
21:53:22 <Cale> with an appropriate test inserted
21:53:34 <Xianianol> Yes, let's see...
21:53:54 <Xianianol> If it is reduced, it should become a Nat...
21:54:31 <Cale> Xianianol: you just need to see if there's even one thing on that side which can be reduced
21:55:02 <Cale> Xianianol: actually, hmm, in your case, you might be able to get away with pattern matching
21:55:20 <Cale> since the only thing which doesn't reduce is a (Nat x)
21:55:45 <Xianianol> Humm, but is just that so far, I would assume anything that is e1 :+ e2 is fine
21:56:16 <Cale> but if e1 matches (Nat x), you don't want to recurse that way
21:56:59 <Cale> since Nat x doesn't reduce any further
21:58:27 <Xianianol> So, something like...
21:58:28 <Xianianol> evalStep env (e1 :* e2) | e1 /= (Nat e1) = (evalStep env e1 :* e2)
21:58:28 <Xianianol> | otherwise = (e1 :* evalStep env e2)
21:58:33 <Cale> (but it's the only expression which doesn't)
21:58:57 <Cale> nah, you can just switch back from using guards to pattern matching :)
21:59:13 <Cale> Since there's only one non-reducible pattern
21:59:25 <soysauce> @type \m xs -> Monad.liftM (:) xs m
21:59:26 <lambdabot> forall t a1. (Monad ((->) t)) => t -> (t -> a1) -> [a1] -> [a1]
21:59:31 <Cale> Normally, you'd write a function to tell you if the expression was reducible at all
21:59:57 <soysauce> ah, right
22:00:01 <Cale> (which could be as simple as trying to reduce it a step and comparing to see if that's the same, though that's inefficient)
22:00:43 <Xianianol> Humm, you mean I should pattern match things like...evalStep env (Nat n :* e1 :* e2) ?
22:01:14 <soysauce> Cale - I wrote some primitives which transform Parser b into a -> Parser b
22:01:22 <soysauce> and a -> Parser a in the case that I want to toss the input
22:01:25 <soysauce> so I don't need lambdas now.
22:01:31 <Taral> @djinn (a -> b -> b) -> b -> b
22:01:32 <lambdabot> x :: (a -> b -> b) -> b -> b
22:01:32 <lambdabot> x _ x2 = x2
22:01:36 <soysauce> I changed everything back to Parser a
22:01:38 <Cale> soysauce: that's a little inflexible in general though :)
22:01:40 <Taral> hm
22:01:42 <Xianianol> But the amount of patterns required seems too amny.
22:01:43 <soysauce> yess
22:01:46 <Xianianol> *many
22:01:46 <soysauce> but!
22:01:57 <soysauce> parsepair :: Parser a -> Parser (a, a)
22:01:57 <soysauce> parsepair p = Monad.liftM2 (,) p p
22:01:57 <soysauce> parsetrip :: Parser a -> Parser (a, a, a)
22:01:57 <soysauce> parsetrip p = Monad.liftM3 (,,) p p p
22:02:17 <soysauce> parserep :: Int -> Parser a -> Parser [a]
22:02:17 <soysauce> parserep n p = sequence (replicate n p)
22:02:30 <Taral> @type replicate
22:02:31 <lambdabot> forall a. Int -> a -> [a]
22:02:32 <Taral> @type replicateM
22:02:33 <lambdabot> Not in scope: `replicateM'
22:02:38 <Taral> @type liftM replicate
22:02:39 <lambdabot> Not in scope: `liftM'
22:02:41 <soysauce> @type Monad.replicateM
22:02:42 <lambdabot> Not in scope: `Monad.replicateM'
22:02:45 <Cale> soysauce: sure, you get all that for free :)
22:02:55 <soysauce> yeah, it's rather nice.
22:02:58 <Taral> @hoogle Monad m => Int -> m a -> m [a]
22:02:59 <lambdabot> No matches, try a more general search
22:03:01 <Taral> guh
22:03:10 <Cale> soysauce: a good example of why monads matter :)
22:03:11 <Taral> @pl \n -> liftM (replicate n)
22:03:12 <lambdabot> fmap . replicate
22:03:22 <Taral> @type fmap . replicate
22:03:23 <lambdabot> forall (f :: * -> *) a. (Functor f) => Int -> f a -> f [a]
22:03:39 <Taral> @type  \n -> liftM (replicate n)
22:03:40 <Cale> imagine doing the same in, oh, C++ even.
22:03:40 <lambdabot> Not in scope: `liftM'
22:03:44 <Taral> @type  \n -> Monad.liftM (replicate n)
22:03:45 <lambdabot> forall a1 (m :: * -> *). (Monad m) => Int -> m a1 -> m [a1]
22:03:51 <soysauce> Cale - I think it could be done with templates, it's just not very pretty
22:03:52 <Taral> hm!
22:03:56 <Taral> is every monad a functor?
22:04:00 <soysauce> lack of tuples is the real problem
22:04:02 <Cale> Taral: yes!
22:04:06 <Taral> good
22:04:17 <Taral> btw, I mostly finished that PDF parser :)
22:04:22 <Taral> it does what I want it to.
22:04:24 <Cale> Taral: it's unfortunately not currently enforced by Haskell
22:04:37 <Taral> The only thing that could be added is (a) new object number allocation and (b) new file creation
22:04:43 <Cale> but fmap = liftM is enough to define an instance
22:04:50 <soysauce> Taral - fmap on a monad would just be fmap f x = x >>= return f
22:04:58 <soysauce> return . f, rather
22:05:02 <Xianianol> Humm, to check if left is a Nat, something like this ?
22:05:02 <Xianianol> evalStep env (Nat n) = Nat n
22:05:02 <Xianianol> evalStep env (Nat n :* Nat m) = Nat(n * m)
22:05:02 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat(n + m)
22:05:02 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
22:05:02 <Xianianol> evalStep env (Nat n :* e2) = (Nat n :* evalStep env e2)
22:05:04 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
22:05:06 <Xianianol> evalStep env (Nat n :+ e2) = (Nat n :+ evalStep env e2)
22:05:07 <Taral> soysauce: Yeah, liftM, like Cale said.
22:05:08 <Xianianol> evalStep env (Var v) = substExpr env (Var v)
22:05:11 <soysauce> @pl \f x -> x >>= return . f
22:05:12 <lambdabot> fmap
22:05:22 <Taral> LOL
22:05:24 <Cale> Xianianol: more specific first
22:05:36 <Taral> lambdabot makes some serious assumptions about instance Functor(s).
22:05:44 <Taral> er, Functor instances.
22:05:44 <Cale> Taral: yep :)
22:06:19 <Cale> Taral: ideally, the prelude will eventually be reverted to be nonidiotic in this respect :)
22:06:34 <Xianianol> Humm, it works now...
22:06:51 <Xianianol> Thanks...now I just need to link this with the string...and...link it with my parser...
22:07:28 <Taral> I was going to suggest at one point defining instance Monad m => Monoid (m a)
22:08:32 <Taral> but I remember reading that there was some dispute about Monoid.
22:08:48 <Taral> Cale: In Haskell2020
22:08:58 <Cale> Taral: or Haskell 1.4
22:09:50 <Cale> There are several instances of language de-evolution from 1.4 to 98
22:10:11 <Taral> Is there a documentation of the rationale?
22:10:15 <nalexand> Can any Cabal gurus suggest why I get linking errors requiring a main function when I build a cabal library?
22:10:37 <nalexand> Specifically, I get the standard missing __stginit etc.
22:10:38 <Cale> yeah, it's mostly all to help the error messages be more newbie-friendly
22:11:13 <Cale> but I think that would be best enabled via a compiler switch
22:12:35 <Cale> nalexand: hmm... I'm not a Cabal guru, but I could try to determine -- which library is this?
22:13:04 <nalexand> It's the SDL library packaged by Lemmih.
22:13:20 <Cale> which version of Cabal do you have?
22:13:30 <nalexand> I'll check, but recent - 1.1.3 I think.
22:13:45 <nalexand> Can you tell me how to make Cabal go verbose and tell me the commands it's executing?
22:14:20 <nalexand> ghc-pkg tells me
22:14:48 <nalexand> that I have (net-1.0), (hssource-1.0), Cabal-1.1.3
22:14:49 <shapr> hm, it's 7am, should I just stay up and drink lots of coffee?
22:15:00 <nalexand> There's a (Cabal-1.0) as well.
22:15:13 <Saulzar> shapr, It's always good in "theory", and never good in practice :)
22:15:16 <nalexand> I assume entries in parens are deprecated/ignored.
22:15:34 <Cale> hmm
22:16:02 <Cale> Parens mean that the packages are hidden
22:16:12 <Cale> but I'm not sure exactly what that implies
22:16:29 <Cale> I think it may mean that they'd have to be explicitly mentioned on the GHC commandline to be active
22:16:38 <shapr> Yeah, I think I'll be a clean kiwi and sleep instead of dirtying up my bod with stimulants.
22:16:46 <shapr> Saulzar: Are you a clean kiwi?
22:17:01 <nalexand> Well, I installed GHC 6.4.1 from Wolfgang Thaller's binaries, then installed Cabal-1.1.3.
22:17:03 <Cale> You wouldn't happen to be the Nick Alexander I know from Waterloo?
22:17:07 <nalexand> Yes, I would.
22:17:12 <nalexand> I PMed you, but no replies.
22:17:12 <Cale> ah :)
22:17:15 <Cale> oh
22:17:17 <nalexand> How're things?
22:17:19 <Xianianol> It is just 6AM here :P
22:17:22 <Cale> perhaps you're not registered
22:17:28 <Cale> They're good
22:17:31 <shapr> Xianianol: Man, you need to toughen up. It's 7am here.
22:17:34 <nalexand> No, probably not.  Registered as in IRC reged?
22:17:39 <Cale> yeah
22:17:42 <nalexand> Or registered as in reged to talk to you.
22:17:47 <Xianianol> You are from the future!
22:17:50 <nalexand> How do I freenode reg?
22:18:01 <shapr> try /msg nickserv help register
22:18:12 <nalexand> thanks.
22:18:13 <Cale> shapr is faster than me :)
22:18:15 <Saulzar> shapr, I'm not entirely sure about clean, but...
22:18:21 <shapr> Saulzar: Wasn't there a big ad campaign about being a clean kiwi long ago?
22:18:41 <Cale> Freenode is annoying now about having to be identified to send PMs
22:18:54 * shapr gives up and goes to sleep
22:18:57 <Xianianol> Coffee/Tea is always good to keep awake, assuming that you don't have anything important to do at that day...
22:19:13 <Saulzar> They used to make a fuss about "clean and green", but I've heard less of that recently - since they realise we're becoming much like everywhere else
22:21:28 <soysauce> @type \(x, y), z -> (x, y, z)
22:21:29 <lambdabot> parse error on input `,'
22:21:34 <soysauce> @type \((x, y), z) -> (x, y, z)
22:21:35 <lambdabot> forall a b b1. ((a, b), b1) -> (a, b, b1)
22:21:42 <soysauce> er, d'oh
22:21:43 <soysauce> @pl \((x, y), z) -> (x, y, z)
22:21:43 <lambdabot> uncurry (uncurry (,,))
22:25:50 <Xianianol> Humm...So now I just iterate the evalStep ?
22:29:33 <Xianianol> Humm, nevermind, doesn't seem to be a good idea, since then it will produce a list...
22:29:58 <ncalexan> Any clues on how to make Cabal tell you what it's doing?
22:38:14 <Cale> @seen Lemmih
22:38:15 <lambdabot> Lemmih is in #haskell and #haskell-blah. Last spoke 7 hours, 39 minutes
22:38:15 <lambdabot> and 48 seconds ago.
22:38:20 <Cale> hmm
22:38:28 <Cale> @seen dons
22:38:28 <lambdabot> dons is in #haskell. Last spoke 3 hours, 59 minutes and 46 seconds ago.
22:38:41 <dons> yo
22:39:11 <Cale> ncalexan: perhaps dons will have some idea :)
22:39:22 <dons> ./Setup.lhs build -v4 ?
22:39:26 <ncalexan> That would be nice.
22:39:29 <Cale> ncalexan is trying to build SDL from the Cabal package
22:39:58 <dons> -vN flags will tell you in more and more detail what is happening
22:40:01 <Cale> and it's complaining at link about missing __stginit_ZCMain
22:40:03 <ncalexan> Not alot to say, really:
22:40:04 <ncalexan> runhaskell ./Setup.lhs build -v4Reading parameters from /Users/nalexand/Devel/haskell/SDLstable/src/Core/SDL.buildinfo
22:40:08 <ncalexan> Preprocessing library SDL-0.2.0...
22:40:16 <ncalexan> _ZCMain_main_closure
22:40:19 <ncalexan> ___stginit_ZCMain
22:40:19 <ncalexan> Of course, it shouldn't link against main.
22:40:22 <ncalexan> collect2: ld returned 1 exit status
22:40:24 <dons> umm. hmm.
22:40:24 <ncalexan> Setup.lhs: got error code while preprocessing: Graphics.UI.SDL.General
22:40:32 <ncalexan> I can chase that into hsc2hs, and further into a bad linker command.
22:40:41 <ncalexan> But I can't find where that Main symbol is coming from.
22:40:50 <dons> probably hsc2hs's generated file
22:40:56 <dons> isn't linking for some reason?
22:41:17 <dons> you could try running the hsc2hs cmd line by hand
22:41:28 <ncalexan> As background, I should say this is the SDL packaging, and the SDLmain library can foul things up, but this seems purely ghc.
22:41:31 <ncalexan> I have.
22:41:36 <ncalexan> Run hsc2hs by hand, that is.
22:41:40 <ncalexan> And then the ghc linker command.
22:41:47 <ncalexan> With or without -no-hs-main.
22:42:12 <Cale> ncalexan: where did you get that package -- it has a different directory layout than the one I downloaded from Hackage
22:42:14 <ncalexan> I'm trying to track the .o with ___stginit in it.
22:42:17 <dons> so it is hsc2hs that is failing?
22:42:20 <ncalexan> I didn't download from Hackage.
22:42:29 <ncalexan> I grabbed it by darcs from Lemmih's page.
22:42:33 <Cale> oh
22:42:40 <Cale> well, that ought to be newer anyway :)
22:42:40 <ncalexan> Is hackage even for use by regular folk like me these days?
22:43:12 <Cale> http://hackage.haskell.org/ModHackage/Hackage.hs?action=view -- it seems to be working anyway :)
22:43:45 <musasabi> searchpath looked nice for some things when I tried it out some days ago
22:44:20 <Cale> I'll get the darcs version and try again
22:44:21 <ncalexan> All right, I'll try installing hackage.  I shudder at the thought of more experimental software to solve experimental software problems :)
22:44:34 <Cale> ncalexan: you can just use the webpage
22:44:51 <Cale> It just links to cabal packages
22:45:06 <ncalexan> Okay, I'll try that instead.
22:46:43 <ncalexan> No, same linker error :(
22:46:49 <Cale> okay, well, the darcs version links for me too
22:47:05 <Cale> hmm
22:47:30 <Cale> which hsc is the problem?
22:47:47 <ncalexan> hsc2hs version 0.66
22:47:50 <Xianianol> To link both Expr -> Expr and Expr -> String...I do something like this ?
22:47:50 <Xianianol> niceShow env (e1 :+ e2) = showExpr(evalStep env (e1 :+ e2))
22:47:50 <Xianianol> niceShow env (e1 :* e2) = showExpr(evalStep env (e1 :* e2))
22:47:50 <Xianianol> niceShow env (Nat n) = showExpr(evalStep env (Nat n))
22:48:33 <Cale> er, I don't suppose anything points at a specific hsc file which causes the problem
22:48:48 <ncalexan> Sort of.
22:48:58 <ncalexan> Executing: ghc -c -I/sw/include/SDL Graphics/UI/SDL/General_hsc_make.c -o Graphics/UI/SDL/General_hsc_make.o
22:49:01 <ncalexan> Executing: ghc Graphics/UI/SDL/General_hsc_make.o -o Graphics/UI/SDL/General_hsc_make
22:49:13 <Taral> um
22:49:22 <Taral> hm
22:49:25 <ncalexan> Then linker errors.
22:49:56 <Taral> I have hsc2hs version 0.66
22:49:59 <Taral> What's in General.hsc?
22:50:24 <Taral> wait... linker errors on that last ghc invocation?
22:50:27 <Taral> Very weird.
22:50:33 <ncalexan> It defines some SDL enums, has a foreign declaration or two.
22:50:42 <ncalexan> Taral: the linker errors are looking for Main.
22:50:50 <ncalexan> I can't find any reference to Main, though
22:50:50 <Taral> What ghc version?
22:50:54 <ncalexan> 6.4.41
22:50:55 <ncalexan> 6.4.1
22:50:57 <Taral> hm
22:51:03 <Taral> Can I fetch this package from somewhere?
22:51:12 <ncalexan> It seems to be a Mac specific problem.
22:51:18 <Taral> Oh.
22:51:24 <ncalexan> But we're live at http://hackage.haskell.org/packages/SDL-0.2.0.tgz
22:51:51 <ncalexan> Any idea what other package uses Cabal, hsc2hs, that I could try?
22:52:00 <ncalexan> Then we could at least isolate hsc2hs a little.
22:52:33 <Taral> Something is wrong with your ghc
22:52:40 <Taral> I suspect it's a linker ordering problem.
22:52:57 <Taral> Try doing hsc2hs --ld=gcc
22:53:19 <Cale> http://vx.hn.org/autoshare/Cabal-SDL-log.txt
22:53:29 <Cale> there's a log of what happens when I do a build
22:53:47 <Taral> I don't see any errors in there...
22:54:00 <Cale> I'm not even seeing the command that he's having the error on
22:54:02 <ncalexan> Taral: you are sort of correct :)  That dropped the GHC specific main problem.  There's still a C-main _main problem, but that's SDL specific.
22:54:12 <ncalexan> I know what happens with that.
22:54:29 <ncalexan> So thanks for the idea.
22:54:31 <Taral> ok
22:54:38 <Taral> I don't see the error in your logfile there.
22:54:46 <Cale> Taral: it's my logfile
22:54:54 <Taral> and?
22:54:59 <Cale> It built correctly
22:55:01 <Taral> Oh!
22:55:08 <ncalexan> Mine gets nowhere near so far.
22:55:23 <Cale> So Nick can compare the commands that are being run.
22:55:25 <Taral> ncalexan: Can you paste the output?
22:55:29 <Taral> lisppaste2: help
22:55:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:55:51 <ncalexan> On Mac OS X, the entry to SDL is very delicate.  But I've made it work in a few languages, I know a few ways to make it happen.
22:56:05 <ncalexan> It's probably just not been done Mac OS X friendly-ly in this package.
22:56:18 <Taral> Okay, so you got past the hsc2hs problem?
22:56:34 <Taral> You shouldn't have been having that error, might want to report it to the ghc on macosx people.
22:56:40 <Cale> ncalexan: you said ghc is being run in the "Preprocessing library" stage?
22:56:52 <ncalexan> Yeah.  I think I'll drop a mail to Wolfgang Thaller about that.
22:56:58 <Cale> In my build ghc isn't run until the library is being built.
22:57:06 <Taral> Cale: ghc is being run behind the scenes by hsc2hs
22:57:15 <Cale> ah, okay
22:57:20 <Taral> as a platform-independent cc
22:57:21 <ncalexan> Taral: yeah, that's my situation
22:57:59 <Taral> the problem is, macosx's linker picks the wrong copy of "main" when presented with two of them (one from *_hsc_make.o, one from the RTS)
22:58:15 <Taral> so I told ncalexan to tell hsc2hs switch to using gcc as linker instead of ghc
22:58:20 <Cale> ah, okay
22:58:31 <ncalexan> I've had that problem before, and found ordering ways to solve it.
22:58:38 <Taral> ordering ways are a hack.
22:58:43 <ncalexan> True that :)
22:58:50 <Taral> hsc2hs needs to tell ghc not to include the damn RTS when doing a C-only compile.
22:58:55 <Taral> -no-hs-main or something?
22:59:16 <Cale> yeah
22:59:25 <ncalexan> Maybe.  I never found where to put that flag into the hsc2hs process.
22:59:34 <ncalexan> Through cabal, that is.
22:59:37 <dons> hmm, mapSerial :: (Ord k, Show k, Show v, Read k, Read v) => Serial (Map k v)
22:59:38 <ncalexan> hsc2hs-flags:
22:59:39 <ncalexan> ?
22:59:40 <soysauce> @hoogle newArray
22:59:41 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a
22:59:41 <lambdabot> i e)
22:59:41 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a
22:59:41 <lambdabot> i e)
22:59:41 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
22:59:48 <dons> how many constraints till I win the constraint game?
22:59:50 <soysauce> @hoogle newArray_
22:59:51 <lambdabot> Data.Array.MArray.newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
22:59:51 <lambdabot> Data.Array.MArray.newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
23:00:30 <Cale> dons: Nobody wins in the constraint game.
23:00:45 <dons> ah, maybe true. yes.
23:01:18 <Cale> just like the Dairy Challenge
23:01:31 <dons> i'm not sure what that is, but it sounds dangerous
23:01:51 <Taral> ncalexan: Nope, looking at Distribution.PreProcess, it only passes the cpp-options, no hsc2hs specific options.
23:02:03 <Taral> anyway, it's an hsc2hs/ghc bug, any such option would be a hack.
23:02:13 <Taral> (can you tell I don't like hacks?)
23:02:28 <soysauce> @hoogle runSTArray
23:02:29 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
23:02:29 <lambdabot> e
23:02:31 <dons> Taral is good at cleaning up hacked code
23:02:37 <Taral> hehehehe
23:02:42 <dons> like a vacuum cleaner for hacks
23:02:44 <dons> :)
23:02:48 <ncalexan> :)
23:03:02 <ncalexan> That's going to make it hard to build this package.
23:03:07 <dons> try to trick him into reviewing your code, if at all possible ...
23:03:18 <Taral> ncalexan: Well, there might be a way...
23:04:22 <Taral> Setup.hs --with-hsc2hs="hsc2hs --ld=gcc"
23:04:35 <Taral> and hope :)
23:04:49 <twb`> Where are the semantics of "newtype" described?
23:04:59 <Taral> newtype is the bastard child of "type" and "data"
23:05:02 <Cale> twb`: the report, in declarations
23:05:11 <twb`> URL?  Pleeeease?
23:05:12 <Taral> it's like data, but guarantees that you won't get an extra box.
23:05:20 <Cale> sure
23:05:28 <twb`> Maybe I should describe what I want, without trying to guess the answer.
23:05:38 <dons> @where haskell98
23:05:39 <lambdabot> http://haskell.org/onlinereport/
23:05:40 <dons> there ^^^
23:05:51 <soysauce> how is it that there is no instance of MArray for STUArray of Int?
23:05:57 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
23:05:57 <dons> newtype is very much under appreciated
23:06:08 <Cale> dons: I agree :)
23:06:11 <Taral> http://haskell.org/onlinereport/decls.html#datatype-renaming
23:06:15 <Cale> anyway, I should go to bed :)
23:06:23 <Taral> @report
23:06:23 <lambdabot> Unknown command, try @listcommands.
23:06:27 <Taral> Hm, I need to add that.
23:06:28 <dons> I seem to recall either the report, or Thompson, saying its rarely used.
23:06:32 <Cale> @where report
23:06:32 <lambdabot> I know nothing about report.
23:06:39 <ncalexan> Cale: g'night, nice to talk to you.
23:06:42 <Taral> dons: newtype is useful if you have a dumb compiler
23:06:46 <Taral> otherwise, data is good enough
23:06:52 <Cale> ncalexan: yeah, nice to talk to you again too
23:07:03 <ncalexan> Unfo, --with-hsc2hs is ignored.
23:07:06 <Cale> you should come online here more :)
23:07:27 <ncalexan> Well, I will providing the haskell on mac os x situation remains frustrating.
23:07:35 <Taral> ncalexan: Is your Setup.hs using the withHooks version of defaultMain?
23:07:36 <Cale> hehe
23:07:48 <ncalexan> Yes.
23:07:57 <Taral> ncalexan: You might have to use it on "Setup.hs config"
23:08:32 <Taral> dons: Wait... what's the difference between "newtype N = N Int" and "data N = N !Int"?
23:08:55 <ncalexan> Taral: No go.  Feeding a non-existent command doesn't fault.
23:09:03 <Taral> weeeird
23:09:21 <soysauce> @hoogle STUArray
23:09:22 <lambdabot> Data.Array.ST.STUArray :: STUArray s i a
23:09:22 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i
23:09:22 <lambdabot> e
23:09:22 <lambdabot> Data.Array.ST.castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
23:09:25 <dons> one is strict. you can write functions that behave different in the presence of undefined
23:09:40 <Cale> Taral: there are some examples in that link I posted
23:09:49 <Cale> showing the difference
23:09:53 <soysauce> hm, how do I modify data in the array? I presume I can bind the thing I get back from newArray and then permute, but...do I use (!)?
23:09:55 <dons> I seem to recall a newtype-bashing session on haskell-cafe@, where Lennart had some nice examples
23:10:12 <Taral> ncalexan: I was right, it's Setup.hs configure --with-hsc2hs="hsc2hs --ld=gcc"
23:10:13 <Cale> at the very least, newtype will always use the exact same data representation in the program
23:10:33 <Cale> (it's only affecting things at the type level)
23:10:49 <dons> anything that adds more types to your program has to be good, right?
23:10:51 <Taral> dons: Ew.
23:10:54 <Cale> data will create a data constructor which gets through to the runtime
23:11:18 <soysauce> Cale - mind helping me with mutable arrays?
23:11:28 <Taral> I wonder if newtype is really actually necessary in real programs...
23:11:39 <soysauce> I think I know how to do it, but I'm just not sure
23:12:05 <dons> I have one real program that uses it nicely. It has an dsl embedded in the type class system, and uses newtype for dispatch 
23:12:13 <soysauce> heh, nevermind!
23:12:24 <dons> newtype and instances go together nicely
23:12:24 <soysauce> I never thought to look at Data.Array.MArray, now I see.
23:12:35 <Taral> mutable arrays are *weird*
23:12:36 <ncalexan> Taral: well, it does something if you put the -- option before the command.
23:12:43 <Taral> I used them for IO caching in PDF.hs
23:12:49 <Taral> ncalexan: !!
23:12:56 <soysauce> Taral - well, I've never used them before.
23:13:01 <Taral> nor had I.
23:13:04 <Taral> took a bit to get right
23:13:22 <Taral> I really wish there was a once-and-only-once "cacheIO :: IO a -> a"
23:13:43 <Taral> unsafePerformIO just doesn't have that guarantee
23:13:44 <ncalexan> Taral: didn't SPJ write a paper explaining that did something similar?
23:13:51 <Taral> I dunno.
23:13:55 <Taral> SPJ has a lot of papers
23:14:00 <ncalexan> True.
23:14:01 <soysauce> haha
23:14:11 <soysauce> that's an understatement
23:14:26 <dons> it doesn't have that guarantee?
23:14:42 <dons> but I think in practice, since a thunk is allocated, it will work like that.
23:15:07 <dons> ah, I'm tripping
23:15:12 <dons> I'm thinking of unsafeInterleaveIO
23:15:24 <Taral> dons: In practice, yes, but there's no guarantee.
23:15:33 <Taral> It would be nice to have a runtime-guaranteed version called "cacheIO"
23:15:39 <Taral> there are really three cases:
23:15:45 <Taral> (a) Run once and only once
23:15:52 <Taral> (b) Run many times, but not concurrently
23:15:57 <Taral> (c) Run many times, concurrency is OK
23:16:14 <dons> unsafePerformIO (IO m) = case m realWorld# of (# _, r #)   -> r
23:16:16 <Taral> er, (b) and (c) should also say "but cache the result for efficiency"
23:16:32 <Taral> My PDF.hs has case (b) all over it.
23:16:45 <dons> but I wonder what would happen with a : unsafePerformIO (IO m) = let (#_, r#) = m realWord# in r   -- assuming you could write that
23:16:45 <Taral> Stuff that is not reentrant, but can be re-evaluated if necessary.
23:16:59 <dons> and then we compare with:
23:17:01 <dons> unsafeInterleaveIO (IO m)
23:17:01 <dons>   = IO ( \ s -> let
23:17:01 <dons>            r = case m s of (# _, res #) -> res
23:17:01 <dons>         in
23:17:03 <dons>         (# s, r #))
23:17:11 <dons> ah, but that's just what I wrote
23:17:16 <Taral> yes
23:17:26 <Taral> unsafeInterleaveIO = return . unsafePerform IO, but inlined
23:17:27 <dons> but you want a unsafePerformIO . unsafeInterleaveIO ?
23:17:32 <Taral> no
23:17:36 <Taral> I want a cacheIO
23:18:01 <Taral> For operations that are theoretically SEF but non-reentrant.
23:18:08 <Taral> (e.g. it messes with a file pointer)
23:18:23 <dons> how is unsafeInterleaveIO = return . unsafePerform IO  ?
23:18:29 <dons> it's explicitly lazy with that 'let'
23:19:06 <Taral> um
23:19:16 <Taral> I thought I remembered reading that somewhere.
23:19:26 <Taral> unsafePerformIO is lazy too, no?
23:19:51 <Taral> since the caller with construct a thunk (unsafePerformIO x)
23:20:05 <dons> hmm.
23:20:16 <Taral> so return . unsafePerformIO = unsafeInterleaveIO
23:20:34 <Taral> unless there's a seq hiding in IO's return that I don't know about.
23:21:06 <Taral> I mean, if return is \r -> IO (\s -> (# s, r #))
23:21:20 <dons> ah. returnIO x = IO (\ s -> (# s, x #))
23:21:28 <Taral> yup
23:21:35 <Taral> now inline return . unsafePerformIO...
23:22:00 <dons> I really like to see that 'let' in unsafeInterleaveIO though ;)
23:22:05 <dons> then I *know* what its going to do
23:22:13 <Taral> what else would you get?
23:22:46 <Taral> application is just as lazy as let
23:22:54 <dons> the 'let' is an emphasis that its going to be suspended. there's no other option there :)
23:23:17 <Taral> bah, I think that's just a syntactic preference on your part
23:23:33 <dons> STG semantics of let.
23:23:41 <dons> let == alloc thunk. good to know.
23:23:56 <Taral> I don't like to rely on STG semantics.
23:24:05 <Taral> I prefer to rely on the Haskell laziness guarantees.
23:24:10 <Taral> let and apply are both lazy.
23:24:15 <Taral> all the time, every time.
23:24:26 <dons> sure sure. but let is more lazy ;)
23:24:31 <Taral> "more lazy"
23:24:37 <dons> you can quote me on that.
23:24:47 <Taral> @remember dons but let is more lazy ;)
23:24:54 <Taral> done
23:25:03 <Taral> re twb
23:25:09 <twb> Thanks.
23:25:27 <Taral> anyway, right now I'm assuming that unsafePerformIO = cacheIO
23:25:42 <Taral> I use it in an MArray for cached reads of objects from disk
23:25:48 <Taral> I'm considering switching to antimemoization
23:25:58 <Taral> Then I don't have to make that assumption.
23:26:53 * dons tries to finish this djinn binding.
23:27:18 <twb> @pl foldr (\x y -> ',':x:y) "" "xyz"
23:27:19 <lambdabot> ",x,y,z"
23:27:26 <twb> @pl foldr (\x y -> ',':x:y) "" xs
23:27:26 <lambdabot> foldr ((((',') :) .) . (:)) [] xs
23:27:32 <twb> Yech.
23:27:38 <Taral> heh
23:27:53 <dons> looks like TheHunter played some games
23:28:11 <dons> twb, submit a patch. 
23:28:12 <dons> @version
23:28:13 <lambdabot> lambdabot 3p222, GHC 6.5.20050806 (Linux i686)
23:28:13 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
23:28:18 <twb> dons: huh?
23:28:20 <dons> oh, 222, unlucky.
23:28:26 <twb> dons: patch what?
23:28:33 <dons>  @pl ?
23:28:42 <twb> I don't understand.
23:28:52 <dons> or did your `Yech' mean something that I didn't think it meant
23:29:06 * twb is really confused.
23:29:15 <twb> I was saying \bot's output was yuk.
23:29:53 <Taral> @pl \x -> x x
23:29:54 <lambdabot> join id
23:30:11 <dons> ah, ok. I thought you were complaining that the 2nd wasn't as nice as the first, so I complained back that you haven't sent in a patch  yet.. :)
23:30:28 <twb> dons: Ah, I understand now.
23:30:40 <Taral> \f -> let g = f g in g
23:30:43 <Taral> @pl \f -> let g = f g in g
23:30:43 <lambdabot> fix
23:30:45 <Taral> yay
23:30:51 <twb> dons: is there a way to do @pl directly, without having to come into freenode?
23:30:57 <dons> directly?
23:31:00 <dons> i.e. cmd line?
23:31:06 <twb> REPL.
23:31:10 <dons> ghci..?/
23:31:13 <twb> Yeah
23:31:21 <Korollary> I suppose you can rip it out of lambdabot sources
23:31:39 <Taral> @pl fix (\foldr f z a -> case a of { [] -> z; (x:xs) -> f x (foldr f z xs) })
23:31:39 <lambdabot> (line 1, column 32):
23:31:39 <lambdabot> unexpected "{"
23:31:39 <lambdabot> expecting variable, "(", operator or ")"
23:31:41 <Taral> gah!
23:31:41 <dons> it's called: ghci -cpp -fglasgow-exts Plugins/Pl.hs ;)
23:31:45 <Taral> no cases in @pl
23:31:56 <dons> @pl case 1 of x -> x
23:31:56 <lambdabot> (line 1, column 13):
23:31:56 <lambdabot> unexpected ">" or "-"
23:31:56 <lambdabot> expecting variable, "(", operator or end of input
23:32:00 <dons> gah!
23:32:15 <dons> @pl let x = 1 in x
23:32:16 <lambdabot> 1
23:32:18 <dons> sigh
23:32:40 <Korollary> @pl let x = 1 in if x /= 1 then 2 else 3
23:32:40 <lambdabot> if' False 2 3
23:32:45 <Taral> @hoogle [a] -> (a -> [a] -> b) -> b
23:32:46 <lambdabot> No matches, try a more general search
23:33:06 <Taral> @hoogle [a] -> (a -> [a] -> b) -> b -> b
23:33:07 <lambdabot> No matches, try a more general search
23:33:09 <dons> @djinn [a] -> (a -> [a] -> b) -> b
23:33:09 <Taral> grr!
23:33:10 <lambdabot> -- x cannot be realized.
23:33:19 <Taral> @djinn [a] -> (a -> [a] -> b) -> b -> b
23:33:20 <lambdabot> x :: [a] -> (a -> [a] -> b) -> b -> b
23:33:20 <lambdabot> x _ _ x3 = x3
23:33:31 <dons> well, that's one possible function ;)
23:33:34 <Taral> x [] _ x3 = x3
23:33:40 <Taral> x (a:as) f _ = f a as
23:33:46 <Taral> that's what I want
23:33:54 <Korollary> @wtf djinn
23:33:55 <dons> I agree with Cale's earlier point that @djinn should try to use all the args
23:33:56 <lambdabot> *** "djinn" wn "WordNet (r) 2.0"
23:33:56 <lambdabot> djinn
23:33:56 <lambdabot>   See {djinni}
23:33:56 <lambdabot>  
23:33:56 <lambdabot> *** "djinn" wn "WordNet (r) 2.0"
23:33:56 <Taral> conversion of [a] into its functional equivalent
23:33:58 <lambdabot> [6 @more lines]
23:34:28 <dons> Korollary, you know, like the magic djinn of the lamp?
23:34:37 <Korollary> dons: I meant in the lambdabot sense
23:34:53 <Korollary> forgot that @wtf was actually a lambdabot command :)
23:35:05 <dons> @help djinn
23:35:06 <lambdabot>  @djinn <type>
23:35:06 <lambdabot> Generates Haskell code from a type.
23:35:10 <Korollary> ah
23:35:12 <Korollary> lies
23:35:19 <dons> @djinn a -> b -> a
23:35:19 <lambdabot> x :: a -> b -> a
23:35:19 <lambdabot> x x1 _ = x1
23:35:22 <dons> works for me.
23:35:38 <Xianianol> Gah - Out of ideas how to keep feeding the function the expression structure, can't even think of a recursive way...
23:35:40 <Korollary> @djinn String -> Integer
23:35:40 <lambdabot> -- x cannot be realized.
23:35:42 <dons> @djinn ((Either (a -> f) (b -> f) -> (a, b) -> f) -> f) -> f
23:35:42 <lambdabot> x :: ((Either (a -> f) (b -> f) -> (a, b) -> f) -> f) -> f
23:35:42 <lambdabot> x x1 = x1 (\ c14 -> case c14 of
23:35:42 <lambdabot>         Left c15 -> \ (c17, _) -> c15 c17
23:35:42 <lambdabot>         Right c19 -> \ (_, c22) -> c19 c22)
23:35:55 * soysauce sighs
23:35:56 <Korollary> wow
23:36:06 <soysauce> how do you use writeArray, it doesn't make sense :(
23:36:19 <dons> currently it has a pretty small environment, so I'm trying to get it to add newtypes and type synonyms, which should help make it a bit more like a super-hoogle
23:36:21 <twb> What's filter called when it takes a value instead of a predicate?
23:36:25 <Taral> @hoogle writeArray
23:36:26 <lambdabot> Data.Array.MArray.writeArray :: (MArray a e m, Ix i) => a i e -> i -> e ->
23:36:26 <lambdabot> m ()
23:36:27 <Korollary> soysauce: in a do-block?
23:36:31 <Taral> writeArray arr ix elem
23:36:38 <Taral> equivalent in other languages to arr[ix] = elem
23:36:45 <soysauce> hmm
23:36:51 * twb pines for M-x haskell-hyperspec-lookup
23:37:00 <dons> hyperspec?
23:37:06 <twb> dons: the CL version of the report.
23:37:10 <Taral> ...
23:37:14 <dons> is that like hasktags on fptools?
23:37:15 <Taral> just how strict is IO's return?
23:37:27 <twb> dons: in Emacs, M-x hyperspec-lookup in lisp mode goes to the specification of the symbol under point.
23:37:33 <Taral> if I do "return $ f x", is f x evaluated immediately?
23:37:38 <dons> like hasktags applied to fptools..
23:38:03 <dons> which I use, so that \^[ applied to a sym jumps to its defn
23:38:06 * twb looks for hasktags.
23:38:12 <Taral> dons?
23:38:26 <dons> Taral, it'll suspend, surely?
23:38:41 <dons> why would it be strict?
23:38:53 <dons> @where hasktags
23:38:54 <lambdabot> I know nothing about hasktags.
23:39:03 <Taral> dons: look at lazy_apply in http://www.pps.jussieu.fr/~jch/software/repos/darcs-git/AntiMemo.lhs
23:39:03 <dons> bah, when you find it twb, add the url
23:39:07 <Korollary> I dont think IO's return could be different than other monad returns in strictness
23:39:09 <Taral> @google hasktags
23:39:10 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
23:39:43 <Taral> @where+ hasktags http://www.cl.cam.ac.uk/users/rje33/software.html
23:39:43 <lambdabot> hasktags ~> http://www.cl.cam.ac.uk/users/rje33/software.html
23:39:45 <dons> that looks like it.
23:40:06 <soysauce> Korollary - well, when I use writeArray, I get a type of m (a i e) -> m ()
23:40:09 <soysauce> which throws away my array
23:40:12 <twb> dons: hmm, that's slightly different.
23:40:13 <soysauce> which is definitely not what I want
23:40:14 <Taral> dons: I suspect returnIO is hacked to be strict in its first argument.
23:40:24 <Taral> or something?
23:40:43 <twb> dons: M-x hyperspec-lookup would go to the relevant part of the Report.
23:40:52 <dons> twb, it generates a tag file for all defns in the standard libs. which you can then jump  to and from. 
23:40:56 <Korollary> soysauce: That doesn't throw your array away. You can keep referring to it in the do block.
23:41:07 <twb> dons: but they are the implementation, not the specification.
23:41:13 <twb> dons: if you see what I mean.
23:41:38 <dons> you want to jump to the language defn of a symbol?
23:41:48 <soysauce> Korollary - it throws away my changes
23:41:52 <dons> or the language defn of individual functions, like fst,snd,curry etc?
23:41:54 <soysauce> test a = a >>= (\a' -> writeArray a' 2 2) >> a
23:41:55 <twb> dons: in the web browser.
23:42:07 <soysauce> when I runSTArray, I get the original array
23:42:11 <twb> dons: yes.
23:42:20 <Korollary> soysauce: ah, I dont know about the STArray stuff
23:42:31 <soysauce> oi.
23:42:37 <dons> twb, which one?
23:42:38 <soysauce> well, what should I be using, then?
23:42:41 <twb> dons: both.
23:43:01 <twb> dons: I don't know enough about those terms' meaning in the haskell community to say which.
23:43:01 <dons> because the point would be that the language defn of the standard libs is the same as the implementation of the standard libs.
23:43:15 <twb> dons: really?  No optimizations?
23:43:20 <dons> both
23:43:22 <Taral> soysauce: Hm.
23:43:25 <Taral> @type runSTArray
23:43:26 <lambdabot> Not in scope: `runSTArray'
23:43:29 <Taral> @hoogle runSTArray\
23:43:30 <lambdabot> hoogle: Unexpected character when parsing: \
23:43:30 <lambdabot>  
23:43:30 <dons> look for the #if defined(USE_REPORT_PRELUDE) ;)
23:43:31 <Taral> @hoogle runSTArray
23:43:32 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
23:43:32 <lambdabot> e
23:43:33 <soysauce> @type Data.Array.ST.runSTArray
23:43:34 <lambdabot> forall e i.
23:43:34 <lambdabot> (GHC.Arr.Ix i) =>
23:43:34 <lambdabot> (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e))
23:43:36 <lambdabot> -> GHC.Arr.Array i e
23:43:41 <twb> e.g. I would expect length to be defined with an accumulator in the actual code.
23:44:04 <Taral> @type \a -> a >>= (\a' -> writeArray a' 2 2) >> a
23:44:05 <lambdabot> Not in scope: `writeArray'
23:44:11 <Taral> @type \a -> a >>= (\a' -> Data.Array.writeArray a' 2 2) >> a
23:44:13 <lambdabot> Not in scope: `Data.Array.writeArray'
23:44:16 <Taral> @hoogle writeArray
23:44:17 <lambdabot> Data.Array.MArray.writeArray :: (MArray a e m, Ix i) => a i e -> i -> e ->
23:44:17 <lambdabot> m ()
23:44:18 <soysauce> Data.Array.MArray.writeArray
23:44:22 <Taral> @type \a -> a >>= (\a' -> Data.Array.MArray.writeArray a' 2 2) >> a
23:44:23 <lambdabot> forall (m :: * -> *) (a :: * -> * -> *) i e.
23:44:23 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.MArray a e m, Num i, Num e) =>
23:44:23 <lambdabot> m (a i e) -> m (a i e)
23:44:39 <soysauce> yes, now watch:
23:45:06 <soysauce> > (\a -> runSTArray (a >>= (\a' -> Data.Array.MArray.writeArray a' 2 2) >> a)) (Data.Array.MArray.newArray (0 :: Int, 3) 0)
23:45:06 <lambdabot>  Not in scope: `Data.Array.MArray.newArray'
23:45:35 <twb> @pl filter (/= 'x') "xyxzsxsa"
23:45:35 <lambdabot> filter ('x' /=) "xyxzsxsa"
23:45:43 <Taral> uh
23:45:47 <twb> Isn't there a "remove all" function?
23:45:48 <soysauce> > (\a -> Data.Array.ST.runSTArray (a >>= (\a' -> Data.Array.MArray.writeArray a' 2 2) >> a)) (Data.Ix.newArray (0 :: Int, 3) 0)
23:45:48 <Taral> @type Data.Array.MArray.newArray
23:45:48 <lambdabot>  Not in scope: `Data.Ix.newArray'
23:45:49 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i.
23:45:49 <lambdabot> (Data.Array.Base.MArray a e m, GHC.Arr.Ix i) =>
23:45:49 <lambdabot> (i, i) -> e -> m (a i e)
23:45:56 <Taral> notice that newArray is in the monad
23:46:01 <soysauce> yes
23:46:10 <Taral> you can't use newArray outside of runSTArray
23:46:20 <Taral> try this
23:46:32 <Taral> runSTArray (newArray (0::Int, 3) 0 >>= test)
23:46:38 <dons> > filter ('x' /=) "xyxzsxsa"
23:46:39 <lambdabot> "yzssa"
23:46:42 <soysauce> I thought I would just (newArray ...) >>= f >>= g >>= h >>= ...
23:46:52 <Taral> soysauce: Yes, but INSIDE the runSTArray.
23:47:03 <Taral> What you passed to lambdabot above is using newArray outside runSTArray
23:47:11 <Taral> oh, wait
23:47:13 <Taral> I see, nevermind.
23:47:15 <soysauce> heh
23:47:20 <Taral> Yes, your problem is that you tried
23:47:26 <Taral> newArray ... >>= ... >> newArray ...
23:47:31 <soysauce> I know
23:47:31 <Taral> do you see?
23:47:40 <soysauce> but I was crossing my fingers and hoping for magic
23:47:42 <Taral> the return value was a new array, not the first one.
23:47:45 <soysauce> because otherwise I get ST s ()
23:47:48 <soysauce> which is pretty useless
23:47:55 <Taral> Try this then:
23:48:08 <Taral> newArray (0::Int, 3) 0 >>= \a -> test a >> return a
23:48:19 <Taral> a.k.a.
23:48:28 <Taral> do { a <- newArray ...; test a; return a }
23:48:40 <Taral> it's easier to understand if you do it in the monad
23:48:49 <soysauce> that changes the type
23:48:57 <Taral> of test?
23:48:58 <soysauce> oh, nevermind
23:48:59 <Taral> yes
23:49:22 <Taral> test now takes the STArray itself instead of an array constructor.
23:50:14 <Taral> soysauce: Don't try to be too functional when doing monadic programming.
23:50:15 <twb> Hooray.
23:50:17 <Taral> twb?
23:50:30 <twb> Taral: my code compiles.
23:50:35 <Xianianol> Can someone help me ? :-/
23:50:37 <Taral> yay
23:50:40 <twb> Xianianol: probably.
23:50:43 <Taral> Xianianol: maybe
23:51:17 <Taral> no medical questions, though
23:51:19 <Xianianol> Well, I've been trying for a while to show the steps of a expression evaluation
23:51:54 <Taral> you trying to debug an evaluation, or just map it?
23:51:55 <Xianianol> I got the function working, however, I am unable to find a way for it to keep producing the next step recursively
23:52:02 <Taral> Try buddha:
23:52:04 <Taral> @where buddha
23:52:05 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
23:52:12 <Xianianol> Nope, not debugging.
23:52:23 <Taral> okay...
23:52:26 <Xianianol> It is just that I am implementing a stepwise evaluation
23:52:33 <Taral> so you have a function step ... = ...?
23:52:45 <Xianianol> I got the function like this:
23:52:47 <Xianianol> evalStep env (Nat n) = Nat n
23:52:47 <Xianianol> evalStep env (Nat n :* Nat m) = Nat(n * m)
23:52:47 <Xianianol> evalStep env (Nat n :+ Nat m) = Nat(n + m)
23:52:47 <Xianianol> evalStep env (Nat n :* e2) = (Nat n :* evalStep env e2)
23:52:47 <Xianianol> evalStep env (e1 :* e2) = (evalStep env e1 :* e2)
23:52:47 <Xianianol> evalStep env (Nat n :+ e2) = (Nat n :+ evalStep env e2)
23:52:49 <Xianianol> evalStep env (e1 :+ e2) = (evalStep env e1 :+ e2)
23:52:56 <Xianianol> It works fine in a way.
23:53:06 <Taral> okay
23:53:36 <Xianianol> For example:
23:53:36 <Xianianol> Main> evalStep [] (Nat 5 :+ Nat 6 :+ Nat 9)
23:53:37 <Xianianol> Nat 11 :+ Nat 9
23:53:49 <Taral> eval env x = case evalStep env x of { Nat n -> n; x' -> eval env x }
23:53:56 <Taral> eval env x = case evalStep env x of { Nat n -> n; x' -> eval env x' }
23:54:10 <twb> > List.intersperse 'x' "xyz"
23:54:11 <lambdabot> "xxyxz"
23:54:11 <Taral> or you could just combine the two and do things like
23:54:15 <soysauce> Taral - hrm, I seem to have gotten it working, although I don't understand how
23:54:23 <Taral> eval env (Nat n :* e2) = eval env (Nat n :* eval env e2)
23:54:31 <Taral> soysauce: Sorry.
23:54:32 <twb> > List.intersperse ',' "abcd"
23:54:33 <lambdabot> "a,b,c,d"
23:54:37 <soysauce> well, that's ok
23:54:53 <soysauce> modify a i e = return a >>= (\a' -> writeArray a' i e) >> return a
23:55:08 <Taral> um
23:55:16 <soysauce> then I can newArray ... >>= modify ... >>= modify ...
23:55:16 <Taral> @pl modify a i e = return a >>= (\a' -> writeArray a' i e) >> return a
23:55:17 <lambdabot> modify = ap (flip . ((flip . ((>>) .)) .) . writeArray) return
23:55:20 <Taral> hm
23:55:28 <soysauce> not very beautiful
23:55:33 <Taral> modify a i e = writeArray a i e >> return a
23:55:40 <soysauce> er, good point
23:55:41 <Taral> no idea why you want this.
23:55:43 <soysauce> I just noticed that m'self
23:56:03 <Taral> it's a variant of writeArray that returns the array
23:56:36 <Taral> are you trying to get a functional-style modify?
23:56:43 <Taral> modify (modify a i e) i' e'
23:56:44 <Taral> ?
23:56:47 <soysauce> I guess. I just want to write my code.
23:56:52 <Taral> just write it then
23:56:53 <soysauce> have nfi what I'm doing
23:56:54 <Taral> imperative style
23:56:58 <Taral> do ...
23:57:07 <Taral> use readArray and writeArray to read and write the array
23:57:18 <soysauce> hm
23:57:31 <soysauce> do { writeArray a ...; return a }?
23:57:34 <Taral> t = a[i] => t <- readArray a i
23:57:39 <Taral> a[i] = t => writeArray a i t
23:57:45 <Taral> yes
23:57:53 <soysauce> thought so
23:57:59 <Taral> then inline that into the callers
23:58:03 <soysauce> I know
23:58:08 <Taral> the caller already has the array, it doesn't need it back
23:58:15 <Taral> that's why writeArray is ... -> m ()
23:58:20 <Xianianol> Well, using: eval env x = case evalStep env x of { Nat n -> n; x' -> eval env x' } would produce the final step/result instantly, for that I got a one-step evaluation function.
23:58:32 <Taral> Xianianol: Not what you wanted?
23:58:43 <Taral> Oh!
23:58:45 <Taral> um...
23:59:02 <Xianianol> Well, I do want it to reach the result, but I wanted it to show each step, that is why I broke the recursive function into smaller parts.
23:59:02 <soysauce> @type sequence
23:59:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:59:19 <Taral> eval env x@(Nat _) = [x]
23:59:26 <soysauce> well, I think I know what to do now
23:59:29 <soysauce> although this is painful
23:59:33 <Taral> eval env x = x : eval env (evalStep env x)
