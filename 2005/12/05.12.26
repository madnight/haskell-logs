00:00:38 <shapr> humasect: I don't know. Can you give some examples?
00:01:52 <Zerthurd> shapr: yes
00:01:54 <Zerthurd> hi all
00:02:10 <humasect> i was trying to see if i can measure how much i understood monads outside of action composition
00:02:10 <shapr> Zerthurd: Do you have any questions?
00:02:53 <shapr> Well, try it. Can you describe it?
00:05:00 <humasect> hmm... monads are declarative function compositions for ordering of actions, a pipeline for ordering expressions
00:05:07 <Zerthurd> i learning monads now
00:05:36 <humasect> ..including state
00:05:48 <humasect> (and related operations)
00:07:09 <shapr> I'd say ordering is the most common use of monads in Haskell, but it's not the only use.
00:08:33 <humasect> ah, ordering and organizing
00:09:00 <humasect> monads don't have to go "forwards"
00:09:06 <humasect> right?
00:09:21 <shapr> Right
00:09:46 <shapr> Look at the nondeterminism / list monad.
00:10:13 <humasect> ok
00:10:51 <humasect> monad -> diad -> triad ?
00:11:15 <Zerthurd> :)))
00:11:26 <Zerthurd> monad -> stereoad
00:11:30 <humasect> =)
00:11:55 <humasect> doblyad quadrad
00:14:09 <Cale> monad is already a portmanteau of monoid and triad
00:17:29 <humasect> ahh
00:17:44 <shapr> Cale: When you did "*Main> (foldr mplus mzero . map return) [1,2,3,4,5] :: FreeMonad TreeSig Integer" Were you using the code from LtU?
00:18:27 <Cale> not quite
00:18:43 <Cale> but that code was a subset of the code I was using :)
00:19:01 <shapr> Could I get a copy of the FreeMonad module?
00:19:05 <humasect> what is INSTANCE_TYPEABLE1?
00:19:23 <Cale> http://vx.hn.org/autoshare/FreeMonad.hs
00:19:30 <Cale> one sec :)
00:20:24 <Cale> okay
00:20:26 <Cale> there
00:20:56 <Cale> I just added a couple of instances of Functor to make things work, and an instance of MonadPlus
00:21:15 * shapr absorbs...
00:22:18 <Cale> I briefly considered instances which the functor could have which would guarantee automatic instances of MonadPlus, but I didn't come to any conclusion.
00:22:20 <Lemmih> humasect: A cpp macro used by GHC in the standard libraries, iirc.
00:25:09 <shapr> Is MonadPlus covered in the Nomaware monads tutorial?
00:25:54 <Cale> http://www.nomaware.com/monads/html/laws.html#zero
00:26:46 <Cale> It's pretty brief
00:27:32 <Cale> I actually think that MonadPlus should be split into 3 classes
00:29:13 <Cale> MonadZero should be reseparated, and then there should be MonadElse and MonadPlus, where MonadPlus would require the left distribution law, and MonadElse wouldn't
00:30:06 <Cale> that is, mplus a b >>= k = mplus (a >>= k) (b >>= k)
00:32:51 <Cale> "Serving size: 14 bears."
00:33:58 <Cale> I suppose it's appropriate, being on a package of gummy bears.
00:35:31 <Cale> http://www.haskell.org/hawiki/MonadPlus -- I agree with the suggestion made at the bottom of this page
00:36:14 <humasect> Lemmih: thanks
00:40:18 <Cale> hmm
00:40:46 <Cale> ah, my instance of MonadPlus for Tree is a bit off
00:41:06 <Lemmih> jlouis: Du er ikke meget paa IRC i jule tiden, eh?
00:41:07 <Cale> but there also isn't much that can be done about it
00:41:27 <Cale> I suppose you'd just have to consider them up to equivalence under flattening
00:42:05 <Cale> I suppose it could also apply some algorithm to canonicalise the shape of the tree
00:42:37 <humasect> lemmih, where did you put -I/usr/lib/ghc-6.5/include for compiling hs-plugins with 6.5? ghc-options: in plugins.cabal ?
00:43:19 <Lemmih> yeah.
00:43:28 <humasect> ok, hm
00:46:11 <adept> jlouis: hi
00:53:20 <Saulzar> Hmm, are there any chess programs written in Haskell?
00:54:24 <basti_> Saulzar: not thati know of
00:55:51 <humasect> i can't get past the INSTANCE_TYPEABLE issue with 6.5 with either hs-plugins (0.9.10 and darcs head)
00:56:25 <Saulzar> I'm just wondering because after seeing Cale's Sudoku 8-liner it could be something pretty elegant, then again - it's something which is researched pretty heavily for bit operations in C :)
00:56:43 <basti_> yes
00:56:44 <basti_> ^^
00:56:54 <adept> @seen SamB
00:56:55 <lambdabot> I saw SamB leaving #haskell, #haskell-blah and #haskell-overflow 1 day, 8
00:56:55 <lambdabot> hours, 4 minutes and 56 seconds ago.
00:57:33 <basti_> most chess programs rely on obscene amounts of moves being evaluated every second
00:57:41 <basti_> not exactly haskell's strength
00:57:56 <Cale> Saulzar: a state transformed list monad or nondet monad is really a neat way to go with this sort of thing.
00:58:17 <basti_> thats true yes
00:58:25 <basti_> list monad gives backtracking for free
00:59:29 <Cale> If you switch to a nondet monad, you can get better performance, but you might need foldNondet to get a list for deeper comparison of options.
01:00:13 <Cale> (which might negate any performance benefit)
01:02:47 <haskellnewbie> ok, I'm feeling really retarded right now, I need to add every successive element of two lists and am brainfarting on how to do it
01:03:32 <Cale> hmm
01:03:43 <Cale> trying to decipher what you mean
01:03:54 <humasect> hm, no ghci support with haskell-mode? i thought i've seen it.
01:03:57 <Cale> > zipWith (+) [1,2,3,4,5] [10,20,30,40,50]
01:03:58 <lambdabot> [11,22,33,44,55]
01:04:07 <Cale> like that?
01:04:31 <haskellnewbie> yes, exactly like that!!
01:04:59 <haskellnewbie> thanks, I've been staring at so many zip, zipWith, map, etc. definitions that I couldn't see the forest for the trees!
01:05:17 <Cale> > zip [1,2,3,4,5] [10,20,30,40,50]
01:05:19 <lambdabot> [(1,10),(2,20),(3,30),(4,40),(5,50)]
01:05:38 <Cale> > map (\(x,y) -> x + y) $ zip [1,2,3,4,5] [10,20,30,40,50]
01:05:40 <lambdabot> [11,22,33,44,55]
01:05:48 <Cale> > map (uncurry (+)) $ zip [1,2,3,4,5] [10,20,30,40,50]
01:05:50 <lambdabot> [11,22,33,44,55]
01:06:30 <Cale> zipWith f xs ys = map (uncurry f) (zip xs ys)
01:06:37 <Cale> also
01:06:49 <Cale> > zipWith (,) [1,2,3,4,5] [6,7,8,9,10]
01:06:51 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
01:06:59 <Cale> zip = zipWith (,)
01:07:01 <haskellnewbie> oy, the simple one the first time is EXACTLY what I think I need
01:07:06 <Cale> yeah
01:07:27 <Cale> the first one there is probably the best and most idiomatic
01:07:38 <Cale> I'm just showing how you can put these things together
01:08:18 <Cale> If you didn't know about zipWith, zip and map will work together to get you there
01:08:41 <haskellnewbie> zipWith is my friend right now I think!
01:08:54 <Cale> It's a pretty handy function
01:09:15 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
01:09:17 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
01:09:29 <haskellnewbie> I was trying to piece together how to do it with zip and map, zipWith is clearer to read in this (admittedly simple!) case
01:09:51 <Cale> check that one out :)
01:10:06 <Cale> it's worth understanding how that works
01:10:48 <haskellnewbie> yes, yes it is, it's just late and night and I'm THIS CLOSE to a release, and am brainfarting
01:10:50 <haskellnewbie> :-)
01:10:54 <gour> Cale: isn't that one (fib) pretty advanced stuff?
01:11:15 <Cale> gour: I dunno -- if you understand zipWith and recursion, it's okay :)
01:11:31 <haskellnewbie> I'm about to release sha256, purely in haskell
01:11:37 <Cale> ah, cool
01:11:46 <gour> Cale: yep, that's true
01:12:16 <Cale> It's a good example to get you in the mindset of laziness
01:12:53 <gour> Cale: true, i still didn't pass 14th chapter, but you're source of many nice haskell-jewels
01:13:21 <gour> i saw that example in 'haskell to c-programmers tutorial'
01:13:46 <Cale> yeah, that one is all over the place :)
01:13:59 <Cale> I think it's also in the "Gentle Introduction"
01:14:05 <gour> but i'm 'saving' it when i come to laziness (17 the chapter)
01:14:14 <gour> it could be, chasing the tail :-)
01:15:28 <gour> i'd wish to have more time on disposal to write solutions for those 14th-chapter exercises and move to 15th chapter (case study) and module-system
01:15:40 * gour thinks it's too long on 14th chapter :-/
01:15:55 <Cale> heh, 'chasing the dragon', a slang term for smoking heroin, which incidentally, tends to make you lazy :)
01:16:54 <gour> didn't know about that, but i'm anyway not into it (fortunately) :-))
01:17:03 <Cale> yeah, neither am I
01:17:50 <Cale> I think I heard it in a Steely Dan song, and looked it up.
01:18:00 <srle> yo, I have one question realted to Erlang? Can I ask it here? (It look like there is nobody active in Erlang chanel).
01:18:05 <gour> and i believe i would not  (anongst many other things) be interested in haskell either
01:20:11 <Cale> srle: well, you can ask it. Perhaps someone here knows Erlang. I haven't really looked too closely at it
01:21:01 <srle> Erlang: A = list_to_binary("srdjan"). Will this be evaluated at compile time or at runtime?
01:21:42 <srle> Function parameters are known in advance (this is obvious).
01:22:28 <Cale> Somehow I'm betting on runtime, unless metaprogramming in Erlang is common.
01:23:08 <srle> Cale: But C compiler will optimize it. I think with -02.
01:23:22 <Lethalman> hi
01:23:27 <Cale> hi
01:23:54 <Lethalman> who can give me some really simple tutorial about haskell?
01:24:02 <Cale> I can :)
01:24:05 <Lethalman> i'm italian and i can't find anything in italian
01:24:09 <Lethalman> Cale, thanks :)
01:24:17 <Cale> oh, in Italian?
01:24:27 <Lethalman> Cale, i don't care
01:24:30 <Cale> http://www.haskell.org/hawiki/FirstSteps -- this is in English
01:24:39 <Lethalman> but, since it's not italian, something reeeally easy to understand :)
01:24:44 <Cale> and will point you at a bunch of tutorials
01:24:56 <Lethalman> i've seen something about lisp, but haskell seems to be cooler :)
01:25:10 <Cale> You might also want to talk to xerox here
01:25:16 <Cale> He's Italian :)
01:25:24 <Cale> xerox: are you up?
01:25:25 <srle> Cale: Tanks. I am leaving. Bye.
01:25:39 <Lethalman> Cale, i know xerox :) i think it's still sleeping
01:26:26 <haskellnewbie> w00t! w00t!! YES!!! it only handles one block input right now, but YES!! the fucker works!!!
01:26:54 <Cale> hehe
01:27:18 <haskellnewbie> purely functionally, no linking nasty C libraries....aahhhhhhh, haskell doesn't have any (non-weak) hash functions, and that's about to change!!
01:58:58 <shapr> yow!
02:01:32 * boegel|home yows back and leaves
02:06:19 <shapr> @yow 
02:06:20 <lambdabot> An Italian is COMBING his hair in suburban DES MOINES!
02:07:33 <shapr> @. yow elite
02:07:34 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the faculty
02:07:34 <lambdabot> dining room.
02:13:33 <Lemmih> @. elete yow
02:13:34 <lambdabot> compose module failed: Parse error: "elete"
02:13:40 <Lemmih> @. elite yow
02:13:41 <lambdabot> ARE 7He $t3\/\/Ed pRuNe$ stI1L In +He hair dRy3R?
02:14:46 <basti_> OW
02:16:45 <Zerthurd> where I can to read about lambdabot commands?
02:17:13 <adept> Zerthurd: just "/msg lambdabot @help" him
02:21:30 <Zerthurd> thanks
02:22:20 <Zerthurd> is lambdabot sources open?
02:23:12 <Lemmih> @version
02:23:12 <lambdabot> lambdabot 3p266, GHC 6.5.20050806 (Linux i686)
02:23:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:23:26 <Zerthurd> thank you
02:25:02 <[CotL]Godofe_Kei> sup ppl?
02:25:30 <[CotL]Godofe_Kei>  > lookup 3 [(1,"kjasgd"),(2,"ajhsgd"),(3,"asdsdas")] 
02:25:49 <basti_> no space in front and it will work
02:26:00 <[CotL]Godofe_Kei> > lookup 3 [(1,"kjasgd"),(2,"ajhsgd"),(3,"asdsdas")] 
02:26:01 <lambdabot> Just "asdsdas"
02:26:04 <[CotL]Godofe_Kei> thx
02:26:08 <[CotL]Godofe_Kei> how do i remove the just?
02:26:12 <[CotL]Godofe_Kei> so i can use the STR?
02:26:18 <basti_> STR?
02:26:21 <[CotL]Godofe_Kei> String
02:26:22 <basti_> you know what Just is?
02:26:24 <basti_> ah
02:27:01 <basti_> @type lookup
02:27:10 <basti_> @type Just 3
02:27:16 <basti_> @type (Nothing)::(Maybe Int)
02:27:21 <basti_> lambdabot?
02:27:36 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
02:27:38 <lambdabot> forall a. (Num a) => Maybe a
02:27:40 <lambdabot> Maybe Int
02:27:47 <basti_> @botsnack
02:27:48 <lambdabot> :)
02:28:04 <basti_> hmm
02:28:09 <[CotL]Godofe_Kei> ?
02:28:09 <humasect> @karma basti_
02:28:10 <basti_> @type (Just 3)::(Maybe Int)
02:28:11 <lambdabot> basti_ has a karma of 0
02:28:11 <lambdabot> Maybe Int
02:28:18 <humasect> +
02:29:02 <basti_> [CotL]Godofe_Kei: "Maybe a" is a type.
02:29:13 <basti_> that is, a parametrised one
02:29:26 <basti_> its defined like: data Maybe a = Just a | Nothing
02:29:31 <basti_> which is pretty self-explanatory
02:29:46 <basti_> ("either you got an 'a', or you got nothing")
02:30:04 <[CotL]Godofe_Kei> hmm
02:30:12 <basti_> this is similar to lists
02:30:33 <basti_> where you got either an 'a' and an [a] (thats ':'), or you got []
02:30:53 <basti_> just that you don't get another instance of the type in the one case.
02:30:58 <[CotL]Godofe_Kei> so the Just doesnt do anything?
02:31:02 <[CotL]Godofe_Kei> i understand what it means 
02:31:06 <basti_> no it doesnt do anything
02:31:11 <basti_> well it does
02:31:12 <[CotL]Godofe_Kei> ok thx m8
02:31:18 <basti_> > map Just [3,4,5]
02:31:19 <lambdabot> [Just 3,Just 4,Just 5]
02:31:26 <basti_> it is a constructor
02:31:28 <basti_> @type Just
02:31:30 <lambdabot> forall a. a -> Maybe a
02:31:31 <[CotL]Godofe_Kei> yes
02:31:34 <[CotL]Godofe_Kei> i know what it does
02:31:37 <basti_> good
02:31:41 <basti_> then you know what to do with it?
02:31:58 <[CotL]Godofe_Kei> for example if i have XXXX :: Int -> (Int,String) -> String
02:32:01 <[CotL]Godofe_Kei> can i do:
02:32:20 <jyp> > catMaybes [Just 3, Nothing, Just 4,Just 5]
02:32:22 <lambdabot> [3,4,5]
02:32:32 <[CotL]Godofe_Kei> XXXX x (x,y) = lookup x (x,y)
02:32:33 <[CotL]Godofe_Kei> ?=
02:32:34 <[CotL]Godofe_Kei> ?
02:32:41 <basti_> uhm
02:32:43 <basti_> yes
02:32:47 <basti_> but that doesnt help
02:32:50 <[CotL]Godofe_Kei> will it return "y" or Just "Y"?
02:32:51 <basti_> you could wirte XXXX = lookup either
02:33:00 <basti_> it would return "Maybe y"
02:33:14 <[CotL]Godofe_Kei> but i dont need the maybe or the just
02:33:15 <basti_> that is "Nothing", or "Just <value>"
02:33:19 <basti_> yes you need
02:33:19 <[CotL]Godofe_Kei> i just need the string part
02:33:27 <basti_> what do you do when the thing you look up isn't in the list?
02:33:36 <[CotL]Godofe_Kei> but i know it will be
02:33:43 <basti_> but haskell doesn't know.
02:33:43 <[CotL]Godofe_Kei> well i dont
02:33:50 <jyp> :t fromJust
02:33:52 <basti_> what shall it do if it doesnt? burn and crash?
02:34:01 <jyp> @type fromJust
02:34:01 <[CotL]Godofe_Kei> ok
02:34:03 <lambdabot> Not in scope: `fromJust'
02:34:03 <basti_> you can have that behaviour
02:34:05 <basti_> ^^
02:34:09 <[CotL]Godofe_Kei> but if it finds that case
02:34:19 <[CotL]Godofe_Kei> i just need the string
02:34:31 <[CotL]Godofe_Kei> i dont want the result to be just "something"
02:34:38 <basti_> which string?
02:34:44 <basti_> lets say you look up something that isnt there
02:34:50 <basti_> which behaviour do you expect?
02:34:59 <Lemmih> @type Maybe.fromJust
02:35:00 <lambdabot> forall a. Maybe a -> a
02:35:07 <basti_> this one would break in case of Nothing
02:35:22 <[CotL]Godofe_Kei> > lookup 2 [(1,1),(1,1)]
02:35:23 <lambdabot> Nothing
02:35:44 <[CotL]Godofe_Kei> well
02:35:48 <[CotL]Godofe_Kei> im screwed then
02:35:58 <basti_> > fromJust (lookup 2 [(1,1),(1,1)])
02:36:00 <lambdabot> Exception: Maybe.fromJust: Nothing
02:36:02 <basti_> no you're not
02:36:10 <xerox> Mooooornin'
02:36:12 <basti_> @type maybe
02:36:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:36:20 <jyp> > fromMaybe 0 (lookup 2 [(1,1),(1,1)])
02:36:22 <lambdabot> 0
02:36:40 <jyp> might be what you want
02:36:42 <basti_> this one supplies a default value
02:36:52 <[CotL]Godofe_Kei> hmm
02:36:58 <[CotL]Godofe_Kei> actually no
02:37:19 <basti_> yes it does
02:37:20 <basti_> ^^
02:37:23 <[CotL]Godofe_Kei> lol
02:37:25 <[CotL]Godofe_Kei> dude
02:37:35 <basti_> :P
02:37:42 <[CotL]Godofe_Kei> ive been for the last 48 hours tryiong to solve this problem
02:37:47 <[CotL]Godofe_Kei> and i just CANT!
02:37:51 * basti_ gives godofe a hug
02:37:53 <[CotL]Godofe_Kei> im going insane
02:37:56 <[CotL]Godofe_Kei> lol
02:37:57 <jyp> you want something that doesn't exit :)
02:38:05 <jyp> exists
02:38:11 <xerox> [CotL]Godofe_Kei: what's your problem?
02:38:18 <Saulzar> You've got to deal with failure somehow, even if it means spitting error back at your user
02:38:21 <[CotL]Godofe_Kei> hmm
02:38:35 <[CotL]Godofe_Kei> http://paste.lisp.org/display/14987 and for explanation http://paste.lisp.org/display/14990
02:38:42 <[CotL]Godofe_Kei> i CANT MAKE IT WORK!!!
02:38:46 <Saulzar> If you absolutely know that it _must_ exist then you can just match against it
02:39:17 <basti_> you'll be screwed in case it doesn't though
02:39:21 <Saulzar> > let (Just foo) = lookup 1 [(1, "blah)] in foo
02:39:22 <lambdabot>  lexical error in string/character literal
02:39:27 <Saulzar> > let (Just foo) = lookup 1 [(1, "blah")] in foo
02:39:29 <lambdabot> "blah"
02:39:33 <Saulzar> > let (Just foo) = lookup 1 [(333, "blah")] in foo
02:39:35 <lambdabot>  Irrefutable pattern failed for pattern (Data.Maybe.Just foo)
02:39:43 <basti_> i like this one
02:40:07 <Saulzar> However you will get a runtime error otherwise, not good practice to leave it to chance :)
02:40:10 <[CotL]Godofe_Kei> can anyone understand the paste?
02:40:39 <xerox> Hmm.
02:41:07 <jyp> Use fromJust, it's what you need.
02:42:08 <xerox> [CotL]Godofe_Kei: more or less... :)
02:42:15 <[CotL]Godofe_Kei> god.....
02:42:15 <jyp> because supplying contestant number without specifying his name in the 2nd list is probably a user error
02:42:27 <jyp> and i guess you don't need to handle them
02:42:34 <[CotL]Godofe_Kei> exactly
02:43:17 <[CotL]Godofe_Kei> but in http://paste.lisp.org/display/14987
02:43:25 <[CotL]Godofe_Kei> this needds some kind of case to make it work
02:43:27 <basti_> godofe: there is a difference between breaking ("error", or failing patterns or something), and "displaying an error message to the user"
02:43:39 <xerox> [CotL]Godofe_Kei: what do you exactly want to get out of '[(4,20,3),(3,20,1),(3,40,2)]' ?
02:43:41 <Saulzar> You could just skip elements in the list if they don't exist
02:43:46 <[CotL]Godofe_Kei> hmm
02:43:50 <[CotL]Godofe_Kei> its like this
02:44:09 <[CotL]Godofe_Kei> i need a function that checks the last of each (4,20,3)
02:44:16 <xerox> Good so far
02:44:29 <[CotL]Godofe_Kei> compare it with the first of every (1,"kjasgd")
02:44:43 <[CotL]Godofe_Kei> the second argument would be [(1,"kjasgd"),(2,"ajhsgd"),(3,"asdsdas")]
02:44:55 <xerox> Right.
02:44:59 <xerox> ...aaaand?
02:45:02 <[CotL]Godofe_Kei> and if its == it returns the number, and the string in some format
02:45:27 <[CotL]Godofe_Kei> format would be [(Int,String,Int,Int)]
02:45:53 <xerox> Hmm, can you use synonyms for the Ints?
02:45:58 <[CotL]Godofe_Kei> hmm
02:45:59 <[CotL]Godofe_Kei> ok
02:46:10 <xerox> Just to make it clear
02:47:35 <Saulzar> Too much tuple gives much confusion? :)
02:47:39 <[CotL]Godofe_Kei> someFunction (a,b,c) (x,y,z) = if x==c then (x,"y",a,b)
02:47:50 <[CotL]Godofe_Kei> oops
02:47:52 <[CotL]Godofe_Kei> my bad
02:47:58 <basti_> Saulzar: confusius?
02:48:07 <[CotL]Godofe_Kei> someFunction (a,b,c) (x,y) = if x==c then (x,"y",a,b)
02:48:18 <[CotL]Godofe_Kei> for the whole 2 lists
02:48:43 <[CotL]Godofe_Kei> understand it?
02:48:53 <jyp> You need to break up the problem into subproblems... Try to write a function with type Int -> [(Int,String)] -> String that just finds the contestant name
02:49:20 <jyp> also you need to understand that you should not recurse on both lists at once
02:49:52 <basti_> yes thats another thing ^^
02:50:19 <jyp> so split into two functions, one for inner loop, one for outer loop.
02:50:32 * [CotL]Godofe_Kei is about to implode
02:50:39 <[CotL]Godofe_Kei> lol
02:50:43 <xerox> Deep breathes :)
02:50:47 <basti_> godofe: welcome to the steep part of the hill.
02:50:59 <jyp> You need to think about something else probably... :)
02:51:16 <basti_> girls?
02:51:20 <basti_> thats what -blah is for
02:52:06 <[CotL]Godofe_Kei> lol
02:53:10 <jyp> once you have completely forgotten your beggining of a solution, try to think it from afresh...
02:53:42 <jyp> also reading a bit of idiomatic haskell code should help
02:54:06 <[CotL]Godofe_Kei> lol
02:54:09 <[CotL]Godofe_Kei> thx a lot dudes....
02:54:23 <basti_> godofe: we're not being cruel
02:54:27 <basti_> this is just hermeneutics
02:54:46 <basti_> if we just tell you the solution, you might not learn as much
02:54:46 <[CotL]Godofe_Kei> hermeneutics?
02:54:54 <[CotL]Godofe_Kei> i know lol
02:55:00 <basti_> thats "helping the other one learn through dialogue"
02:55:15 <[CotL]Godofe_Kei> and i probably can figure it out somehow, by spliting that into smaller functions
02:55:19 <[CotL]Godofe_Kei> im justo...so tired....
02:55:27 <basti_> why do you code 48 hours in row?
02:56:18 <[CotL]Godofe_Kei> cause i have to...
02:56:32 <jyp> free yourself!
02:56:36 <[CotL]Godofe_Kei> lolol
02:56:42 <jyp> :p
02:56:46 <[CotL]Godofe_Kei> well i dont code 48 hours in a row
02:56:56 <[CotL]Godofe_Kei> i have other obligations as well
02:57:04 <basti_> drop them
02:57:06 * basti_ ducks
02:57:11 <basti_> I'll shower and dress... brb
02:57:34 * [CotL]Godofe_Kei waves
02:58:10 <jyp> I'll eat lunch and leave home for a trip... be back this evening :P
02:58:16 * jyp waves
03:04:15 <joelr1> good morning
03:04:31 <[CotL]Godofe_Kei> mornin!
03:05:00 <joelr1> if anyone is interested, i posted the erlang version of the pickler combinators at http://wagerlabs.com/erlang/pickle.erl
03:05:04 <joelr1> @google pickler combinators
03:05:06 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
03:05:13 <joelr1> this would be the original paper
03:09:40 <basti_> back
03:19:40 <xerox> joelr1: what are them?
03:19:56 <joelr1> xerox: what are them what?
03:20:03 <xerox> 'pickler combinators'
03:20:13 <joelr1> @google pickler combinators
03:20:16 <lambdabot> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
03:20:32 <joelr1> xerox: a cool way to pickle and unpickle from a single spec
03:20:46 <joelr1> without separately listing the pickling and unpickling methods
03:20:51 <xerox> @babel en it pickle
03:20:56 <lambdabot>  sottaceto
03:21:15 <xerox> O_o
03:21:58 <xerox> @babel it en sottaceto
03:21:59 <lambdabot>  sottaceto
03:22:02 <xerox> -_-
03:29:31 <[CotL]Godofe_Kei> ppl
03:29:32 <[CotL]Godofe_Kei> lista1 :: (Int,[(Int,Int)]) -> Int -> (Int,[(Int,Int)])
03:29:32 <[CotL]Godofe_Kei> lista1 (a,x) n = (a, (take n x))
03:29:32 <[CotL]Godofe_Kei> lista2 :: [(Int,[(Int,Int)])] -> Int -> [(Int,[(Int,Int)])]
03:29:32 <[CotL]Godofe_Kei> lista2 [] n = []
03:29:32 <[CotL]Godofe_Kei> lista2 l n = map lista1 l
03:29:37 <[CotL]Godofe_Kei> why ist this working
03:29:51 <[CotL]Godofe_Kei> lista1  works
03:29:53 <[CotL]Godofe_Kei> but 2 doesnt
03:30:36 <basti_> lista1 seems to take 2 arguments
03:30:49 <basti_> what is the error you get while compiling?
03:30:54 * shapr yodels
03:31:14 <[CotL]Godofe_Kei> Type           : [(Int,[(Int,Int)])] -> Int -> [Int -> (Int,[(Int,Int)])]
03:31:14 <[CotL]Godofe_Kei> *** Does not match : [(Int,[(Int,Int)])] -> Int -> [(Int,[(Int,Int)])] 
03:31:33 <basti_> what does this say?
03:31:49 <Lemmih> [CotL]Godofe_Kei: 'map (flip lista1 n) l'
03:32:43 <[CotL]Godofe_Kei> ??
03:33:02 <[CotL]Godofe_Kei> basti_: i dont know...i know the types arent coming out right
03:33:06 <[CotL]Godofe_Kei> but i cant understand why
03:33:42 <[CotL]Godofe_Kei> <Lemmih>: ??
03:33:46 <basti_> godofe: you're applying just one parameter to a function that takes 2
03:33:47 <Lemmih> 'lista1' wants 'n' but you're not giving it to it.
03:34:19 <[CotL]Godofe_Kei> but if i give n it gives error too
03:34:25 <[CotL]Godofe_Kei> lista2 l n = map lista1 l n
03:34:27 <[CotL]Godofe_Kei> ?
03:34:28 <basti_> yes because n is the second parameter
03:34:44 <[CotL]Godofe_Kei> oh
03:34:58 <Lemmih> You gotta give 'n' to 'lista1', not 'map'.
03:35:03 <basti_> you could write something like map (\x->lista1 x n) l
03:35:13 <basti_> but (flip lista1 n) is the same and easier to read
03:35:34 <[CotL]Godofe_Kei> yeah
03:35:40 <[CotL]Godofe_Kei> but i stil cant understand
03:36:52 * shapr hops
03:37:34 <[CotL]Godofe_Kei> ?
03:37:43 <greenrd> if in doubt add more parentheses; if still in doubt comment stuff out until you get something that typechecks, and then work backwards from there
03:38:17 <[CotL]Godofe_Kei> lol
03:38:22 <basti_> godofe: what part of "\x->lista1 x n" don't you understand? 
03:38:22 <basti_> ^^
03:38:36 <[CotL]Godofe_Kei> map (flip lista1 n) l
03:38:40 <[CotL]Godofe_Kei> explain this
03:38:44 <basti_> thats easy.
03:38:51 <basti_> > (-) 5 3
03:38:53 <lambdabot> 2
03:38:54 <basti_> > flip (-) 5 3
03:38:56 <lambdabot> -2
03:39:01 <basti_> understood this one?
03:39:02 <[CotL]Godofe_Kei> HA!
03:39:04 <[CotL]Godofe_Kei> yes
03:39:06 <basti_> good.
03:39:07 <basti_> ^^
03:39:16 <[CotL]Godofe_Kei> but...
03:39:27 <xerox> @libsrc Prelude
03:39:28 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
03:39:36 <basti_> the point is, you can only apply parameters in order.
03:39:42 <[CotL]Godofe_Kei> map (flip lista1 n) l = map (n lista1) l?
03:39:51 <basti_> no
03:39:59 <basti_> thats wrong
03:40:04 <[CotL]Godofe_Kei> ?
03:40:05 <basti_> @type flip
03:40:06 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
03:40:20 <basti_> flip trades the places of the first two parameters of it's first argument
03:40:30 <flux__> map (\x y -> lista1 y n) l
03:40:40 <basti_> it does not trade places of its forst two parameters
03:40:41 <basti_> i
03:40:46 <[CotL]Godofe_Kei> ph
03:40:49 <[CotL]Godofe_Kei> oh*
03:41:01 <flux__> uh
03:41:04 <flux__> I did it wrong :-)
03:41:17 * basti_ should try not to use "parameter" and "argument" in the same sentence
03:41:21 <flux__> forget the x
03:41:39 <basti_> godofe: understanding the type system is essential for learning haskell.
03:41:53 <[CotL]Godofe_Kei> yup
03:42:34 <basti_> you can read most of this from flip's type
03:43:37 <flux__> @djinn (a -> b -> c) -> b -> a -> c
03:43:38 <lambdabot> f a b c = a c b
03:43:55 <xerox> @compose pl djinn (a -> b -> c) -> b -> a -> c
03:43:56 <lambdabot> f = flip
03:44:01 * xerox laughs
03:45:04 <xerox> Hmm.
03:45:19 <xerox> Prelude.hs does not have the definition of the functions anymore?
03:45:27 <basti_> did you see me trying to pl mergesort? ^^
03:45:29 <xerox> What should I make a newbie read ?!
03:45:36 <xerox> brrr... yes :-)
03:45:39 <flux__> basti_, hm, did you succeed?-)
03:46:25 <basti_> flux__: well, of course it succeeded, since pl is correct.
03:46:39 <basti_> it just was not much of an improvement
03:46:40 <flux__> yeah, but it doesn't know all the haskell syntax
03:46:59 <basti_> no it doesnt
03:47:59 <[CotL]Godofe_Kei> xerox
03:48:07 <xerox> Hey
03:48:07 <[CotL]Godofe_Kei> i cant find the serach function anywhere
03:48:12 <[CotL]Godofe_Kei> search*
03:48:13 <xerox> Uh.
03:48:22 <basti_> @pl merge = \(ha:ta) (hb:tb) -> if (ha<hb) then ha:merge ta (hb:tb) else hb:merge (ha:ta) tb
03:48:32 <lambdabot> merge = fix (flip ap tail . (. head) . flip flip tail . ((flip . (ap .)) .
03:48:32 <lambdabot> ) . flip flip head . ((flip . ((.) .)) .) . ap (ap . ((ap . ((ap . (ap .))
03:48:32 <lambdabot> .)) .) . ap ((.) . ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (.) . (
03:48:32 <lambdabot> :)) . flip flip (:) . (((.) . (.)) .)) (((flip ((.) . (:)) .) .) . (. (:))
03:48:32 <lambdabot> . (.)))
03:48:34 <lambdabot> optimization suspended, use @pl-resume to continue.
03:48:46 <basti_> flux__: it won't get any better.
03:48:47 <Saulzar> !!
03:49:00 * shapr warbles
03:49:17 * basti_ smacks shapr with a large trout
03:49:26 * shapr slar basti_ med en forell!
03:49:33 <shapr> ich habe keine ahnung!
03:49:48 <basti_> you don't?
03:49:55 <shapr> Not today at least.
03:50:10 <shapr> But I do have a bunch of threads of ideas in my head that are trying desperately to form something.
03:50:43 <basti_> thats how tragedies start isnt it?
03:53:25 <Saulzar> lambdabot is a serious menace with () . and flip
03:53:49 <basti_> ap is a dangerous thing too
03:54:51 <shapr> This is fun to read - http://opal.cabochon.com/~stevey/blog-rants/
03:55:15 <roconnor> is there a template haskell modular arithmetic libary?
03:55:21 <Saulzar> Hmmm, what is the monad in that expression?
03:55:25 <Saulzar> (->) ?
03:55:42 <basti_> Saulzar: in "ap" things by pl? yes
03:56:36 <Saulzar> You could make a hillarious code obfuscator with @pl 
03:57:05 <Saulzar> If you could pick out the specific expressions which it could deal with :)
04:00:54 <adept> @seen jlouis
04:00:55 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
04:00:55 <lambdabot> spoke.
04:01:07 <xerox> @type Control.Monad.ap
04:01:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
04:03:22 <boro_> a
04:03:43 <basti_> "a".
04:18:30 <xerox> @pl \x (l,m) -> (l+1,m+x)
04:18:31 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,) . (1 +)) . (+)
04:20:43 <xerox> > (fst &&& uncurry (flip (/))) . foldr (\x -> (+1) *** (+x)) (0,0) $ [1..10]
04:20:44 <lambdabot> (10.0,5.5)
04:20:46 <xerox> ihi.
04:25:31 <Saulzar> @pl (fst &&& uncurry (flip (/))) . foldr (\x -> (+1) *** (+x)) (0,0) $ [1..10]
04:25:32 <lambdabot> (fst &&& uncurry (flip (/))) (foldr (((1 +) ***) . (+)) (0, 0) [1..10])
04:26:12 <roconnor> (,) and (.) look too similar.
04:26:54 <Saulzar> @type uncurry (flip (/))
04:26:56 <lambdabot> forall a. (Fractional a) => (a, a) -> a
04:29:00 <musasabi> > (.)(.) (+)0(+0) 0
04:29:01 <lambdabot> 0
04:29:16 <shapr> How can I get an exact date from 4 years 34 weeks 6 days (14h 3m 32s) ago  ?
04:29:24 * shapr is trying to figure out when #haskell started
04:29:45 <basti_> shapr: databases often have carefully crafted time arithmetic
04:29:51 <basti_> ("use mysql")
04:29:55 <roconnor> how many leap seconds have their been?
04:30:12 <shapr> Actually, I bet freenode keeps the dates in unix time format.
04:33:35 * Saulzar suspects xerox of aiming to slightly obfuscate
04:39:20 <flux__> shapr, also: date -d 'today -4 year -36 week -6 day -14 hour -3 min -32 second'
04:46:23 <r3tex> hey =) i installed hugs98 through the ebuild but it doesn't find the prelude =(
04:47:47 <Zerthurd> env-update && source /etc/profile ?
04:48:44 <Zerthurd> do you see an error message?
04:49:22 <Zerthurd> try :load Prelude
04:53:09 <r3tex> well, hugs doesn't even load
04:53:21 <r3tex> i tried searching for Prelude.hs but i don't seem to have one
04:54:56 <Zerthurd> what you see when you do :load Prelude?
04:55:43 <Zerthurd> /usr/lib/hugs/libraries/Prelude.hs
05:13:06 <araujo> Good morning.
05:17:46 <ricebowl> buenas araujo
05:23:51 * joelr1 waves
05:25:20 <xerox> Oi.
05:27:23 <basti_> "oi"?
05:27:39 <joelr1> oi is jewish. i think.
05:27:50 <joelr1> oi == oops? omg?
05:29:31 <basti_> i know "oy wey!"
05:30:11 <joelr1> oy way, right. i surmise xerox's oi = oy wey
05:44:12 <r3tex> Zerthurd:  i don't have a /usr/lib/hugs/libraries
05:44:16 <r3tex> just /oldlib
05:44:19 <r3tex> and no Prelude there
05:44:53 <r3tex> hugs doesn't even start without it
05:46:27 <Igloo> You aren't out of disk space are you?
05:47:23 <Igloo> strace hugs and see where it's trying to load it from, and what's there
06:04:43 <Pupeno> Good morning.
06:07:31 <Lemmih> Hiya.
06:08:27 <davidw> hi.
06:08:28 <shapr> I still think libraries are an excuse for underperforming languages.
06:08:38 <shapr> hej davidw 
06:08:41 <shapr> Are you learning Haskell?
06:08:50 <davidw> no, i'm davve :)
06:08:52 <shapr> oh, ok
06:08:59 <ramkrsna> hey shapr 
06:09:14 <shapr> namaste ramkrsna 
06:09:24 <ramkrsna> woAh
06:09:32 <ramkrsna> namaste shapr 
06:09:47 <shapr> (and if you ask, why the greeting to a guru? I have an excellent answer :-)
06:10:15 * shapr can't do the pressed hands and bow over irc, sadly.
06:10:20 <ramkrsna> ok why?
06:10:33 <ramkrsna> HeHe
06:10:56 <shapr> Because, everyone knows something I wish I knew. Everyone can be my teacher.
06:11:50 * ramkrsna wishes shapr all the best attaining pure functional karma
06:11:55 <shapr> :-)
06:14:16 * shapr tries to figure out how to fit concurrency ideas from Erlang, Nesl, and Sisal into a single proposal for Haskell'
06:17:14 * greenrd thinks about termination checking with types
06:20:11 <greenrd> the great thing about never-ending lists is that they're perfectly safe as long as you don't assume they have a last element
06:33:42 <xerox> Hmm
06:33:53 <xerox> Who does recall the variable-arity functions paper from Oleg?
06:33:57 <shapr> me!
06:34:11 * xerox high-fives shapr
06:34:14 <xerox> Where is it!
06:34:35 <saccade> so, I have a haskell-hugs process running in emacs
06:34:40 <saccade> and I have a haskell mode
06:35:02 <xerox> I like GHCi more, personally ;)
06:35:03 <saccade> how can I send expressions to the haskell process from another window?
06:35:20 <xerox> saccade: C-c C-l loads the file in the interpreter
06:35:31 <shapr> Ok, the Erlang,E,Nesl,Sisal thing would need thunks where each have their own permissions, and where they're never guaranteed to return. Thus you get permissions, failure, and remote execution. Sort of.
06:35:32 <xerox> For single expression, I think you have to write them in the interpreter window.
06:35:35 <saccade> hm
06:35:43 <xerox> shapr: do you happen to know where is it?
06:35:47 <ndm|bristol> xerox, is this it? http://okmij.org/ftp/Haskell/types.html#polyvar-fn
06:36:10 * xerox hugs ndm|bristol
06:37:08 <saccade> "Symbol's function definition is void: inferior-haskell-load-file"
06:37:18 <xerox> saccade: do it again
06:37:18 <r3tex> Igloo:  when i try to load it looks at Hugs.Prelude not found on current path: ".:{Home}/lib/hugs/packages/*:/usr/local/lib/hugs/packages/*:{Hugs}/libraries:{Hugs}/packages/*:{Hugs}/oldlib
06:37:23 <shapr> M-x turn-on-haskell-hugs
06:37:27 <shapr> Maybe?
06:37:43 <saccade> xerox: same result
06:37:43 <r3tex> Igloo:  is it looking for a Prelude.hs ?
06:38:34 <r3tex> Igloo:  i'm missing the /usr/lib/hugs/libraries/
06:39:42 <r3tex> Igloo:  hmm, the hugs ebuild doesn't seem to come with a prelude.hs file, am I missing some other package? I have ghc installed
06:42:50 <saccade> xerox: I was looking for something like C-x C-e in scheme mode, that would send an expression to the repl
06:42:58 <xerox> I know :!
06:43:09 <saccade> no such luck then?
06:43:19 <xerox> I think so :\
06:43:25 <saccade> hm
06:44:01 <saccade> well any luck on fixing that error?
06:44:03 <saccade> erm
06:44:07 <saccade> s/luck/advice/
06:44:53 <xerox> It does it to me too, but if I do it again, it simply works.
06:46:04 <saccade> hm
06:48:52 <r3tex> noone have any hugs advice?
06:50:02 <saccade> well, that's an improvement right there
07:09:47 <adept> @type sequence
07:09:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:15:25 <adept> @type sequence_
07:15:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:32:38 <r3tex> Zerthurd:  i don't have a /usr/lib/hugs/libraries/ folder
07:37:28 <takuan> mmm
07:37:34 <takuan> datafields are nifty from time to time
07:37:39 * Lemmih wonders if people are sending private messages to r3tex or if he's just talking to people at random.
07:38:12 <palomer> merry boxing day
07:47:31 <r3tex> Lemmih:  no, it was people that i talked to before and then we went to eat lunch
07:47:32 <r3tex> =P
07:48:25 * Cale replaces a DiffUArray with a DiffArray on account of the occasion
07:48:50 * TuringTest groans at Cale
07:49:28 <Cale> :)
07:49:37 <TuringTest> Huh, I had not noticed DiffUArray before.  Thanks for mentioning it
07:53:18 <musasabi> hmm, how is DiffUArray vs UArray?
07:53:52 <TuringTest> Diff(U)Array is like a regular array when built....
07:54:34 <TuringTest> ..When you update it (using (//) for example), then it updates the old array in place, treating it as mutable.
07:55:00 <TuringTest> But code with references to the original array do not see the updates...
07:55:24 <TuringTest> ...since those old references now point to a reverse changelog view of the new array.
07:55:53 <TuringTest> If you never use the old array references, then the array operations are mutable O(1) and fast.
07:55:55 <musasabi> hmm, basically MVar + IO(U)Array + differences
07:56:06 <musasabi> why IO insteead of ST ?
07:56:29 <musasabi> (except for the MVar)
07:56:36 <Cale> Because it presents an immutable interface anyway
07:56:38 <TuringTest> Right...but all under the hood.   No IO monad!
07:56:48 <Cale> so it doesn't really matter so much
07:57:24 <TuringTest> Not ST monad.  It looks like the inefficient standard Array, but has fast updates if you keep using just the new version of the array.
07:58:02 <TuringTest> Inside it must be using unsafe* ops, but all hidden so you cannot abuse them or make it inconsistent.
07:58:17 <Cale> It could have been written using stToIO
07:58:22 <musasabi> Seems like async exceptions can break a DiffArray
07:58:37 <Cale> really?
07:59:06 * neologism trying ocaml
07:59:06 <TuringTest> If it dies in the middle of several unsafe* ops...I guess that's possible.  So I expect they make it atomic.
07:59:09 <musasabi> it has code like: "takeMVar mv; ...; putMVar mv newValue"
07:59:26 <Cale> Perhaps it should be rewritten using STM
08:00:01 <musasabi> or the modify/withMVar interfaces at least where necessary
08:00:16 <TuringTest> For smp threaded ghc 6.6 goodness it had better be thread safe.
08:00:30 <musasabi> it is thread safe.
08:00:45 <musasabi> Cale: and isn't STM kind of problematic for that?
08:01:05 <Cale> musasabi: why?
08:01:10 <TuringTest> STM won't work since you can't unsafe* perform STM inside STM.
08:01:20 <Cale> why would you need it?
08:01:53 <TuringTest> Well, you can imaging STM code that happened to use a DiffArray.  If that used unsafe* STM code then you're toast.
08:02:00 <Cale> It sounds like all that is needed is to wrap up a few operations atomically, which is essentially what STM lets you do.
08:02:07 <musasabi> Cale: takeTMVar; ...; unsafeIOToStm (unsafeWrite array ...); ... putTMVar;, the IO effect persists even if the transaction is cancelled.
08:02:43 <TuringTest> And I have seen email where people who try musasabi's style of code end up crashing the runtime.
08:02:51 <Cale> hm, I should actually look at the implementation I suppose
08:03:03 <Cale> Yes, embedding IO in STM actions is stupid
08:03:29 <musasabi> TuringTest: that kind of code works (I use it), but one just has to be very carefull with IO being retried over and over.
08:04:06 <musasabi> Cale: well one needs IO (or ST) to get the array update working.
08:04:27 <TuringTest> musasabi: TVars could work.
08:05:07 <TuringTest> But hiding all that under a pure functional interface looks semantically fishy.
08:05:12 <carp> hmm can't get the darcs version of hs-plugins to build with the darcs version of cabal
08:05:22 <musasabi> TuringTest: how would one get the performance with TVars ?
08:06:01 <TuringTest> musasabi: Beats me.  I don't peek at internals.
08:10:18 <neologism> haskell seems better to me than ocaml
08:11:09 <basti_> better in what respebt?
08:11:16 <basti_> c*
08:11:17 <musasabi> a matter of taste, of course many of us here think the same.
08:11:18 <neologism> but if only haskell had something like ocamlbrowser
08:11:32 <neologism> is there anything like ocamlbroswer?
08:13:29 <CosmicRay> merry day-after-christmas, everyone ;-)
08:14:27 <ndm|bristol> neologism: what does ocaml browser do?
08:14:40 <neologism> shows all modules and their function
08:14:42 <musasabi> neologism: what does ocamlbrowser have over emacs+tags
08:15:11 <neologism> how can I use tags with haskell?
08:15:52 <Cale> hasktags
08:16:06 <carp> anyone using hs-plugins?
08:16:18 <CosmicRay> any conjure hackers around?
08:16:28 <musasabi> hasktags or :etags in ghci 6.5
08:17:04 <neologism> I only have 6.4
08:17:20 <musasabi> well you can install hasktags
08:19:20 <gour> what's better (to use) hasktags or etags?
08:19:50 <palomer> how would I write an interpreter with parsec/parsek? I mean, I'll getLine, but how do I know that the line I'm getting ends the expression?
08:19:55 <gour> (for gvim)
08:19:58 <palomer> (or binding)
08:20:52 <neologism> btw: I wanted haskell builtin modules/function
08:20:53 <neologism> s
08:20:59 <neologism> will hasktags help me with this?
08:21:35 <Cale> palomer: Perhaps try to parse and see if you get a finished expression? I'd probably just restrict expressions to one line.
08:22:17 <CosmicRay> palomer: one usually feeds an entire file to parsec
08:22:23 <CosmicRay> palomer: is that not an option in your case?
08:22:40 <neologism> anyway - there's no text description of the function
08:22:42 <palomer> Cale: and if it fails you catch the exceptio?
08:22:46 <neologism> and ocamlbrowser provides that
08:23:13 <Cale> palomer: well, the parse will fail with and you can examine the error
08:23:16 <Cale> er
08:23:20 <Cale> -with
08:24:17 <palomer> but, erm, how will I be able to distinguish bad syntax from unfinished syntax?
08:24:28 <palomer> CosmicRay: I'm writing an interpreter
08:24:41 <Cale> palomer: I suppose that's tricky in any case
08:24:49 <musasabi> neologism: you would like something that is interactive and like haddock?
08:24:54 <CosmicRay> palomer: perhaps you mean you're writing an *interactive* interpreter?
08:24:57 <Lemmih> CosmicRay: Yeah.
08:25:00 <palomer> CosmicRay: yeah
08:25:32 <palomer> so I'll have to do like sml and force my users to end their expressions with ;?
08:26:02 <Cale> palomer: there's always the ghci route of simply not allowing multiple line expressions
08:26:15 <palomer> oh, that's an idea
08:26:47 <palomer> ok, I'll do it that way:O
08:27:06 <palomer> oh oh, a lambda calculus question
08:27:15 <Cale> you could also reserve a special character which users could end the line with if they weren't finished their input
08:27:48 <palomer> if I do \x'. t[x'/x], is this alpha equivalent to \x. t?
08:28:31 <palomer> oh yes, it is
08:28:32 <palomer> nevermind
08:28:32 <palomer> :o
08:28:39 <palomer> (it's actually the definition)
08:29:16 <palomer> what's the easiest way to install parsek?
08:30:23 <Cale> It appears to just be a standalone library. So you could ostensibly just copy and paste the text from that web page into a file and save it as Parsek.hs
08:30:25 <neologism> musasabi: I am afraid  I dont know haddock
08:30:46 <Cale> http://www.cs.chalmers.se/ComputingScience/Research/Functional/MultiLib/koen/Parsek.hs
08:30:47 <Cale> ah
08:30:53 <Cale> non-coloured version
08:31:11 <r3tex> hey, anyone know why the gentoo ebuild doesn't work by itself?
08:31:21 <Cale> r3tex: hm? of what?
08:31:27 <palomer> how do I set my classpath?
08:31:44 <r3tex> Cale:  hugs says that my Hugs.Prelude is missing in my path
08:31:55 <palomer> (and why isn't . in the classpath :O!)
08:32:01 <Cale> palomer: classpath?
08:32:04 <palomer> yeah
08:32:14 <palomer> to tell ghc where to look for .hs files
08:32:16 <Cale> i.e. where it looks for modules?
08:32:27 <palomer> I put parsek in the same directory as my source
08:32:33 <palomer> and now I want to import it
08:32:35 <Cale> There's a whole package system, but that ought to work
08:32:41 <Cale> just  import Parsek
08:32:55 <Cale> and it'll look for it in Parsek.hs in the current directory
08:32:56 <palomer>  Failed to load interface for `Parsek':
08:32:56 <palomer>         Could not find module `Parsek':
08:34:21 <Cale> hmm, I don't get that prolem
08:34:24 <musasabi> neologism: haddock is the tool that is used to generate the online documentation for library modules.
08:34:24 <Cale> problem*
08:34:30 <neologism> oh
08:34:58 <Cale> palomer: one thing you might want to do though is to put {-# OPTIONS_GHC -fglasgow-exts #-} at the top of the Parsek.hs file.
08:35:04 <neologism> how do I convert Float to Int ?
08:35:34 <neologism> I want 2**n as Int
08:35:56 <palomer> Cale: still no go
08:36:22 <r3tex> Cale:  are you running gentoo?
08:37:52 <Cale> r3tex: no, but friends of mine do
08:37:57 <r3tex> aha
08:38:21 <Cale> neologism: 2^n ?
08:38:23 <r3tex> hmm, can't find the Prelude file
08:38:29 <Cale> @type (^)
08:38:31 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:38:33 <Cale> @type (^^)
08:38:35 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
08:38:38 <Cale> @type (**)
08:38:39 <lambdabot> forall a. (Floating a) => a -> a -> a
08:38:41 <musasabi> neologism: either use "round (2**5)" or "2^5".
08:39:14 <neologism> thnx :)
08:39:15 <palomer> Cale: it says it looks for Parsek.hi
08:39:27 <gour> r3tex: i'm on gentoo
08:39:44 <Cale> palomer: this is ghci?
08:39:48 <palomer> ghc
08:39:57 <r3tex> gour:  what did you install besides hugs98?
08:40:24 <gour> r3tex: i removed hugs98, only ghc atm
08:40:34 <Cale> palomer: hmm, all I needed to do was import Parsek at the top of my file
08:40:48 <r3tex> gour:  aha, ok i'm just doing it for a course ;P hugs is more friendlytastic
08:41:03 <Cale> palomer: oh - compile with --make
08:41:26 <palomer> ah hah!
08:41:49 <gour> r3tex: what's your problem?
08:41:55 <Cale> palomer: otherwise you have to tell it that you want to compile Parsek.hs too
08:42:22 <r3tex> gour:  i try to start hugs but it says that it doesn't find prelude
08:42:28 <r3tex> FATAL ERROR: Unable to load prelude implementation
08:43:19 <palomer> omg, Parsek doesn't have the eof token
08:43:22 <gour> r3tex: hmm, which version?
08:43:40 <Cale> r3tex: perhaps check that /usr/lib/hugs/libraries/Prelude.hs and /usr/lib/hugs/libraries/Hugs/Prelude.hs are there?
08:43:42 <r3tex> [ebuild   R   ] dev-lang/hugs98-2005.3-r1  USE="opengl" 0 kB 
08:44:04 <r3tex> Cale:  exactly, the ebuild did not make me a /usr/lib/hugs/libraries folder
08:44:14 <r3tex> or /usr/lib/libraries
08:44:17 <r3tex> doh
08:44:56 <r3tex> mabie i should try another version?
08:44:58 <r3tex> 2003?
08:45:13 * gour is emerging hugs...
08:45:24 <saccade> how do I leave a module?
08:47:07 <r3tex> oh wow, i can't compile the old hugs
08:48:37 <neologism> ERROR "Skola.hs":8 - Inferred type is not general enough
08:48:37 <neologism> *** Expression    : gS
08:48:37 <neologism> *** Expected type : Num a => a -> a -> a -> [a]
08:48:37 <neologism> *** Inferred type : Num Integer => Integer -> Integer -> Integer -> [Integer]
08:48:40 <neologism> what does this mean?
08:49:05 <Cale> neologism: did you give gS a type signature?
08:49:13 <neologism> I have gs :: Num a => a -> a-> a -> [a]
08:49:16 <neologism> gS I mean
08:49:32 <Cale> It means that gS is supposed to work for all Num types but it only works for Integers
08:49:41 <neologism> ah...
08:50:15 <r3tex> gour:  any luck ?  : >
08:50:26 <Cale> You could remove the type signature and it'll infer a more specific type of Integer -> Integer -> Integer -> [Integer]
08:50:30 <palomer> where can I find an example of a Parsek program?
08:50:35 <neologism> Cale: yeah.. I got it
08:50:45 <neologism> the error message confused me
08:52:05 <Cale> palomer: well, I don't know where to find an example, but usage is basically the same as parsec except that you use  parse :: Parser s a -> ParseMethod s a r -> [s] -> ParseResult s r
08:52:36 <Cale> the Parser is obviously just your parser, for ParseMethod, there are a bunch of options it provides
08:53:15 <neologism> I want to use intersect from module List
08:53:19 <Cale> shortestResult, longestResult, longestResults, allResults, completeResults, shortestResultWithLeftover, longestResultWithLeftover, longestResultsWithLeftover, and allResultsWithLeftover
08:53:21 <neologism> how do I import it?
08:53:28 <Cale> import Data.List
08:53:35 <Cale> or just  import List
08:53:42 <Cale> though that usage is deprecated
08:53:42 <neologism> how did you find that its Data. ?
08:53:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
08:54:00 <gour> r3tex: /hugs98-2005.3-r1 starts fine here
08:54:22 <palomer> you can use case on functions?
08:54:31 <palomer> I can't believe ghc lets me do that:o
08:54:47 <palomer> (or does it?)
08:54:47 <Cale> palomer: you can only pattern match against constructors
08:55:04 <neologism> ok.. thnx
08:55:29 <Cale> neologism: it's just that the List library moved to Data.List in the hierarchy
08:56:14 <Cale> palomer: as you can see there, there's also parseFromFile, which might be handy if you're doing that
08:56:54 <Cale> obviously, it only works with Char parsers, but you probably only want to parse characters anyway :)
08:56:57 <neologism> is there better wat then "take n (repeat x)" ?
08:57:05 <Cale> replicate n x
08:57:08 <neologism> thnx
08:57:11 <palomer> Cale: oh no, I'm parsing a string
08:57:28 <Cale> palomer: yeah, then you want 'parse'
08:57:43 <palomer> Cale: I don't get parse:P
08:57:50 <palomer> can't find any examples on google:(
08:57:53 <Cale> oh
08:57:58 <palomer> why can't they just use parsec's parse!
08:58:09 <Cale> parsek's is actually nicer
08:58:16 <Cale> just look at its type :)
08:58:22 <Cale> you pass it a parser
08:58:32 <Cale> then a ParseMethod, of which you'll find a bunch below
08:58:36 <Cale> and then a string
08:58:44 <Cale> and it gives you a result
08:58:56 <palomer> ah hah!
08:59:00 <palomer> it's the parse method which annoyed
08:59:28 <palomer> gah, which one do I want?
08:59:28 <Cale> The fact that it has different parse methods is actually pretty nice :)
09:02:33 <Cale> probably longestResult or completeResults
09:03:07 <CosmicRay> what's parsek, or was that just a typo?
09:03:08 <neologism> I have foo :: Int -> [Int] -> Int
09:03:11 <CosmicRay> @where parsek
09:03:12 <lambdabot> I know nothing about parsek.
09:03:12 <neologism> how do I use thi foo in map?
09:03:32 <CosmicRay> that doesn't look like a function you'd pass to map
09:03:38 <Cale> http://www.cs.chalmers.se/ComputingScience/Research/Functional/MultiLib/koen/Parsek.hs
09:03:39 <CosmicRay> a function for map would be more like Int -> Int
09:03:41 <gour> r3tex: have you found out something?
09:03:45 <CosmicRay> since map applies it to each element
09:03:50 <neologism> I am mapping [[Int]]
09:03:59 <Cale> CosmicRay: it's the library there
09:04:02 <neologism> I need to flip the argumetns
09:04:05 <neologism> but I dont know how
09:04:36 <neologism> foo :: a -> b -> c
09:04:37 <Cale> It's ReadP-like in that it supports symmetric choice, but it's pretty close to Parsec compatible.
09:04:42 <CosmicRay> still, if you're passing a functio to map, you should take only one parameter
09:04:45 <neologism> map foo [b] a
09:04:55 <Cale> It would be a nice inclusion in the Hierarchy under Text.ParserCombinators
09:05:36 <CosmicRay> indeed.
09:05:41 <CosmicRay> I could at least slurp it into MissingH
09:05:58 <Cale> Perhaps we should ask on the libraries list
09:06:13 <r3tex> gour:  nope no luck =(
09:06:56 <r3tex> gour:  do you have a /usr/lib/hugs/libraries?
09:06:58 <Cale> hmm, it says that it's GPL'd -- is GPL'd code permitted in the libraries?
09:07:36 <CosmicRay> Cale: probably not
09:08:22 <gour> r3tex: yes
09:08:25 <Cale> I wonder if we could get Koen to release it under a more general license for inclusion in the libraries :)
09:09:11 <palomer> if I'm going to write an interactive interpreter, I need to do something like main = do {x<-getLine; print (pareString x) ; main}
09:09:27 <r3tex> gour:  ok, i'm missing it, =/ wonder why my ebuild did not create it
09:09:31 <palomer> but, the interpreter changes the environment 
09:09:33 <palomer> so I need a state!
09:10:16 <gour> r3tex: what arch you're on?
09:10:28 <palomer> how do I combine a State and an IO ()?
09:10:35 <xerox> StateT IO m a
09:10:37 <xerox> err
09:10:48 <xerox> StateT IO s a
09:13:15 <xerox> So you can lift IO actions in.  Intersperse them, whatever.
09:13:57 <xerox> @index lift
09:13:58 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
09:13:58 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
09:13:58 <lambdabot> Control.Monad.List, Language.Haskell.TH.Syntax, Text.ParserCombinators.
09:13:58 <lambdabot> ReadPrec, Text.Read
09:14:02 <xerox> @type Control.Monad.Trans.lift
09:14:04 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
09:14:04 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
09:14:04 <lambdabot> m a -> t m a
09:14:22 <xerox> @type (Control.Monad.Trans.lift :: IO a -> StateT IO a)
09:14:24 <lambdabot> Not in scope: type constructor or class `StateT'
09:14:30 <xerox> @type (Control.Monad.Trans.lift :: IO a -> Control.Monad.State.StateT IO a)
09:14:31 <lambdabot>   `IO' is not applied to enough type arguments
09:14:31 <lambdabot>   Expected kind `*', but `IO' has kind `* -> *'
09:14:44 <xerox> heh..
09:15:12 <palomer> and how exactly do you do these things?
09:15:21 <xerox> It's quite simple in fact
09:15:25 <xerox> Let me see..
09:15:25 <wolverian> I always feel that's haskell laughing at me. :)
09:19:20 <Cale> palomer: note that IO also supports IORefs
09:19:32 <Cale> if you really need them
09:19:51 <CosmicRay> personally I prefer MVars to IORefs
09:19:59 <Lethalman> hi
09:20:03 <CosmicRay> about as easy to use, and have useful properties for threaded programs
09:20:31 <xerox> runStateT (lift $ print =<< get) 1
09:21:02 <xerox> @type Control.Monad.State.get
09:21:03 <lambdabot> forall s (m :: * -> *). (Control.Monad.State.MonadState s m) => m
09:21:03 <lambdabot> s
09:21:39 <xerox> OK.
09:21:46 <xerox> foo :: StateT Int IO ()
09:21:46 <xerox> foo = do s <- get
09:21:47 <xerox>          lift $ print s
09:21:55 <xerox> runStateT (foo) 1834
09:22:11 <xerox> Understandable?
09:23:15 <Cale> State transforming IO isn't so necessary, since IO is already very stateful. I suppose you get some computation-global state for free that way.
09:23:26 <Cale> but you could also use an IORef just as easily :)
09:23:59 <Cale> but first of all, what is it that this state is for?
09:24:11 <xerox> I don't like IORefs :)
09:24:25 <Cale> I don't like IO :)
09:24:27 <Cale> hehe
09:24:53 <palomer> xerox: yeah
09:25:03 <palomer> xerox: so I use lift everytime I want to do IO
09:25:25 <xerox> palomer: right.
09:25:36 <Cale> What will you be using the state for?
09:26:03 <Cale> a table of bindings?
09:26:29 <palomer> Cale: yeah
09:26:43 <palomer> nothing else
09:26:56 <CosmicRay> @where isJust
09:26:57 <xerox> Cale: have you ever thinked about the nice properties of 'Writer (a -> a) a' ? (or even '.. b')
09:26:57 <lambdabot> I know nothing about isjust.
09:27:00 <Cale> of course, you always have to weigh things, but I sort of think it would be easier to keep track of the table yourself in this case than working in lifted IO
09:27:00 <CosmicRay> @index isJust
09:27:01 <lambdabot> Data.Maybe
09:27:31 <Cale> xerox: that is a neat monoid to be using :)
09:28:11 <xerox> Cale: indeed.  Do you remember the subtree exchange thing...  I think that way you can 'tell' yor way trough the Tree!  And then get something out :)
09:28:23 <Cale> let (newTable, result) = eval oldTable expr
09:28:44 <Cale> print (show result)
09:28:45 <palomer> Cale: how would I pass that to main again?
09:28:51 <Cale> repl newTable
09:28:51 <palomer> oh wait, I wouldn't
09:28:54 <palomer> fair enough
09:29:05 <r3tex> gour:  i386, i'm using ~x86
09:29:10 <palomer> good point Cale
09:29:33 <Cale> xerox: neat :)
09:29:44 <xerox> Cale: (re: State) then add complexity, and he wants a Monad :-P
09:29:45 <Cale> hmmm
09:30:01 <palomer> when I have an infinite loop, is it possible to find in which functions it's looping?
09:30:40 <Cale> xerox: well, possibly, but in this case it doesn't really look like you're going to want anything too complicated
09:30:57 <Cale> palomer: via profiling, I suppose
09:30:58 <gour> r3tex: ok, i'm on ~amd64
09:31:03 <r3tex> hmm, ok
09:31:05 <xerox> Well, ok.  I want to see the GADT behind eval too :-)
09:34:57 <neologism> can someone help me with overflows?
09:35:18 <Cale> neologism: stack overflows?
09:35:19 <basti_> like how? need a few?
09:35:20 <basti_> ^^
09:35:53 <xerox> use a non-strict fold :)
09:35:53 <palomer> http://www.rafb.net/paste/results/qoknvc89.html <--anyone have any thoughts?
09:35:53 <neologism> no.. interger overflows
09:36:14 <Cale> Use Integer instead of Int :)
09:36:19 <neologism> I am trying
09:36:23 <neologism> but it somehow doesnt work
09:36:54 <neologism> gS :: Int -> Int -> Int -> [Int]
09:36:54 <neologism> gS p 1 n = [p `mod` n]
09:36:54 <neologism> gS p m n = [p^m `mod` n] ++ gS p (m-1) n
09:36:56 <neologism> this is the code
09:37:41 <neologism> Skola> gS 3 20 29
09:37:41 <neologism> [9,18,6,2,20,26,28,19,16,15,5,21,7,12,4,11,23,27,9,3]
09:37:52 <neologism> the first number (9) should be 25
09:38:08 <neologism>  3 ^ 20 `mod` 29
09:38:10 <xerox> (p^m `mod` n) : (gs p (m-1) n)
09:38:21 <neologism> this doesnt matter
09:38:26 <neologism> I care about the overflow
09:38:26 <Cale> palomer: neither of those loop
09:38:31 <palomer> Cale: with parsek
09:38:32 <neologism> I made a funvtion
09:38:36 <neologism> power a x = foldr (*) 1 $ replicate x a
09:38:43 <palomer> ./a.out
09:38:43 <palomer> ao
09:38:43 <palomer> Stack space overflow: current size 8388608 bytes.
09:38:46 <neologism> but when I change tyhe code from p^m to power p m
09:38:50 <neologism> it still doesnt work
09:38:53 <neologism> what do I do wrong?
09:39:03 <flux__> > 3 ^ 20 `mod` 39
09:39:04 <lambdabot> 9
09:39:09 <neologism> 29
09:39:10 <neologism> not 39
09:39:13 <flux__> > (3::Integer) ^ 20 `mod` 39
09:39:14 <lambdabot> 9
09:39:24 <palomer> neologism: tried gS :: Integer -> Integer ->Integer -> [Integer] ?
09:39:32 <neologism> ^ is defined only for Int
09:39:45 <palomer> @type (^)
09:39:46 <Cale> no
09:39:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:39:50 <flux__> hmm, bc says (3 ^ 20) % 39 = 9
09:39:52 <Cale> > 3^20
09:39:52 <neologism> > 3^20 `mod` 29
09:39:54 <lambdabot> 3486784401
09:39:54 <lambdabot> 25
09:39:57 <Cale> > 3^100
09:39:59 <lambdabot> 515377520732011331036461129765621272702107522001
09:40:07 <neologism> hm.. it doesnt work in my code
09:40:13 <Cale> use Integer, not Int
09:40:15 <flux__> oh, right
09:40:18 <sieni> > 3.1^101
09:40:20 <lambdabot> 4.241613349779627e49
09:40:27 <palomer> Cale: are you using parsec or parsek?
09:40:36 <Cale> Parsek
09:40:41 <flux__> > (3::Int)^20 `mod` 29
09:40:42 <lambdabot> 9
09:40:43 <xerox> 'parsek' ?!
09:40:52 <basti_> > ackermann 10 10
09:40:53 <palomer> Cale: so why does it loop for me and not you?
09:40:54 <lambdabot>  Not in scope: `ackermann'
09:40:56 <basti_> :(
09:40:59 <flux__> > (3^20 :: Int) `mod` 29
09:41:00 <lambdabot> 9
09:41:11 <palomer> Cale: which parsermethod are you using?
09:41:14 <neologism> when I change Int to Integer
09:41:17 <Cale> palomer: I just copied your code and filled in the blanks -- can I maybe try your whole source?
09:41:34 <palomer> Cale: http://www.rafb.net/paste/results/KSYCiS78.html
09:42:45 <neologism> gS p m n = [(p::Integer)^m `mod` n] ++ gS p (m-1) n
09:42:49 <neologism> why is this illegal code?
09:43:11 <neologism> or how can I rewrite that?
09:43:35 <neologism> (and I dont want to change function prototype)
09:43:53 <Cale> no base case?
09:43:57 <Cale> It's fine
09:44:10 <Cale> @type let gS p m n = [(p::Integer)^m `mod` n] ++ gS p (m-1) n in gS
09:44:12 <neologism> I have base case..
09:44:12 <lambdabot> forall b. (Integral b) => Integer -> b -> Integer -> [Integer]
09:44:13 <palomer> Cale: base case?
09:44:21 <palomer> Cale: variable is the base case
09:44:23 <Cale> palomer: in neologism's case
09:44:38 <palomer> oh
09:44:43 <neologism> gS :: Int -> Int -> Int -> [Int]
09:44:43 <neologism> gS p 1 n = [p `mod` n]
09:44:43 <neologism> gS p m n = [(p::Integer)^m `mod` n] ++ gS p (m-1) n
09:44:47 <neologism> this is how the code looks
09:44:57 <Cale> neologism: remove the type signature
09:45:05 <neologism> then it overflows
09:45:23 <musasabi> neologism: just use Integer?
09:46:12 <musasabi> neologism: your type signature says "p is an Int" and you have an explicit type signature saying "p is an Integer"
09:46:24 <musasabi> neologism: of course those won't get along.
09:46:27 <Cale> > let gS p 1 n = [p `mod` n]; gS p m n = [(p::Integer)^m `mod` n] ++ gS p (m-1) n; in gS 10 12 14
09:46:29 <lambdabot> [8,12,4,6,2,10,8,12,4,6,2,10]
09:46:33 <neologism> I have strange problems when I %s/Int/Integer
09:46:33 <Cale> It works fine
09:46:39 <Cale> your type signature is wrong
09:47:05 <Cale> just remove it and see what ghci/hugs infers
09:47:12 <neologism> *** Expression     : take n (gS p n n)
09:47:12 <neologism> *** Term           : n
09:47:12 <neologism> *** Type           : Integer
09:47:12 <neologism> *** Does not match : Int
09:47:17 <neologism> wehen I s/Int/Integer
09:47:30 <Cale> that's because take wants an Int
09:47:42 <neologism> when I put there Int for the n
09:47:47 <Cale> but why did you add the explicit type annotation anyway?
09:47:47 <neologism> it says it wants Integer
09:48:02 <Cale> @type let gS p 1 n = [p `mod` n]; gS p m n = [p^m `mod` n] ++ gS p (m-1) n; in gS
09:48:04 <lambdabot> forall a a1. (Integral a, Integral a1) => a -> a1 -> a -> [a]
09:48:10 <neologism> hysteria.sk/~neologism/Skola.hs
09:48:12 <neologism> this is the program
09:48:25 <Cale> (Integral a, Integral a1) => a -> a1 -> a -> [a]
09:48:27 <musasabi> @seen JohnMeacham
09:48:28 <lambdabot> I saw JohnMeacham leaving #haskell-blah and #haskell 1 day, 3 hours, 43
09:48:28 <lambdabot> minutes and 18 seconds ago.
09:48:32 <Cale> this is a better type signature for it
09:49:10 <Cale> neologism: btw, you don't have to import Hugs.Prelude
09:49:20 <Cale> I don't think, anyway
09:49:27 <Cale> It should automatically be imported
09:49:47 <neologism> its not
09:49:50 <Cale> try  take (fromIntegral n) (gS p n n)
09:50:27 <Cale> or just remove the type signatures and let hugs figure them out
09:50:41 <neologism> *** Expression     : length (intersect (enumFromTo 1 (n - 1)) a) == n - 1
09:50:41 <neologism> *** Term           : length (intersect (enumFromTo 1 (n - 1)) a)
09:50:41 <neologism> *** Type           : Int
09:50:41 <neologism> *** Does not match : Integer
09:50:59 <neologism> got it..
09:51:01 <Cale> fromIntegral
09:51:23 <Cale> or use genericLength
09:51:31 <Cale> @type Data.List.genericLength
09:51:32 <lambdabot> forall i b. (Num i) => [b] -> i
09:51:34 <neologism> ok
09:51:36 <neologism> now it works
09:51:38 <neologism> but the code is ugly ;(
09:51:57 <tennin> why is >>= left-associative?
09:52:06 <Cale> tennin: convenience
09:52:16 <tennin> when it seems the semantics of "do" are effectively "right-associative"
09:53:22 <palomer> http://www.rafb.net/paste/results/KSYCiS78.html <---anyone have any idea why this program loops on any input?
09:53:25 <palomer> (or fails)
09:54:19 <tennin> or is that not the right way to think about it...?
09:56:38 <Cale> > [1,2,3] >>= (\x -> [x,x+10]) >>= (\x -> if odd x then return x else [])
09:56:39 <lambdabot> [1,11,3,13]
09:57:10 <Cale> seems natural enough behaviour to me :)
09:57:12 <Tweakee> hmm...
09:57:18 <Tweakee> naturally
09:57:25 <Cale> palomer: I'm looking at it :)
09:58:07 <tennin> yeah, guess it makes sense in practice
09:58:15 <Tweakee> hmmm sequence, selection, repetition
09:58:22 <Tweakee> (structure theorem)
10:00:58 <roconnor> I don't suppose there is an extended euclidean algorithm implementation in Haskell in some standard place.
10:01:13 <Cale> palomer: it looks a lot like it's getting stuck in an infinite loop because as part of parsing an expression, one of the first things it might have to look for is an application, and the first thing in an application is an expression, which in turn...
10:02:09 <palomer> Cale: but this is a standard grammar for lambda calculus
10:03:01 <palomer> it really should be able to handle this case
10:04:27 <Cale> It diverges because it tries to eat as little as possible, and it's possible to eat nothing by going into an infinite loop. Even if it was trying for the longest result, it isn't going to be smart enough to know that exploring that option is not going to do any better
10:05:19 <palomer> how do we get around this?
10:07:15 <Cale> hmm
10:07:48 <Cale> we need to make it always eat something before recursing
10:11:12 <palomer> ugh, back to parsec I guess>:O
10:11:15 <Cale> expression = do x <- variable <|> lambda 
10:11:15 <Cale>                 option x (application x)
10:11:25 <Cale> application x = do space
10:11:25 <Cale>                    z <- expression
10:11:25 <Cale>                    return (App x z)
10:11:46 <palomer> you need a space before application?
10:12:01 <Cale> well, that was there before, so I left it
10:12:20 <Cale> I factored out the initial variable or lambda in an application
10:12:37 <palomer> it could also be an application
10:13:44 <palomer> I don't understand that grammar, an application is a space followed by an expression and an expression is a variable or a lambda?
10:13:55 <Cale> hm, this isn't quite right, because it makes application have a strange sort of associativity
10:14:27 <Cale> I added a parameter to application
10:15:19 <Cale> basically, factoring out the first thing it would have eaten
10:15:30 <lennart> palomer: not that I know exactly what your problem is, but it sounds like left factoring your grammar would help you
10:15:39 <Cale> yeah
10:17:28 <lennart> and the only way I can remember left factoring is to do the power series expansion :)
10:18:13 <roconnor> Can you say newType ... deriving (Eq, Show)?
10:18:26 <Cale> roconnor: newtype, yes
10:18:32 <roconnor> oh
10:18:36 <palomer> ho hum
10:18:42 * palomer reads up on left factoring
10:19:21 <palomer> this grammar would work in happy as is, right?
10:19:32 <Cale> palomer: I'm not sure
10:19:33 <lennart> palomer: just think of how you'd solve 'x = xa + b' with real numbers
10:19:42 <Cale> it depends on how smart Happy is
10:20:10 <lennart> left recursion is good in Happy.  It's what you want.  Right recursion is "bad"
10:21:14 <lennart> The lack of proper treatment of left recursion with parsing combinators is their only big drawback in my opinion.
10:21:37 <lennart> But it's never that hard to works around (but why should I work when I have a computer?)
10:22:34 <Cale> I think it ought to be possible to treat correctly with arrow based parsers at least, if it's really not possible with monadic parsers.
10:23:41 <Cale> well, Parsec has the whole buildExpressionParser thing
10:24:25 <blazold> lo
10:24:32 <Cale> hi
10:24:38 <blazold> can you help me with my haskell school task please ?
10:25:09 <Cale> blazold: well, we can answer questions, but not homework questions
10:25:18 * esap has been happy with happy so far for my language.
10:25:19 <blazold> :) sure
10:25:41 <blazold> my task is to write a function that gets Tree in this form:
10:25:55 <blazold> data Tree a = List a | Branch (Tree a) (Tree a)
10:26:01 <blazold> that's the tree
10:26:15 <blazold> now my function will be given something like Tree [a]
10:26:38 <blazold> let's say
10:26:41 <blazold> (Branch (List [1,2]) (Branch (List [5,6]) (Branch [3])))
10:26:44 <blazold> this is such a tree
10:26:52 <blazold> with lists as lists :)
10:27:02 <blazold> with lists as leaves
10:27:16 <Cale> yep
10:27:22 <blazold> now that function should return the list of "Tree a"
10:27:32 <blazold> where each member of this list is one combination
10:27:36 <Cale> er
10:27:42 <Cale> s/List/Leaf/ :)
10:27:43 <blazold> of possible trees made from input tree
10:27:45 <Cale> in general :)
10:28:00 <blazold> e.g.
10:28:02 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
10:28:09 <blazold> ah, yes
10:28:10 <blazold> sorry
10:28:26 <blazold> so let's make an example
10:28:41 <Cale> (Branch (Leaf [1,2]) (Branch (Leaf [5,6]) (Leaf [3])))
10:28:41 <blazold> if i call
10:28:47 <blazold> yes
10:28:51 <Cale> :: Tree [Integer]
10:29:01 <blazold> if i call "doit (Branch (Leaf [1,2]) (Leaf [3]))"
10:29:03 <blazold> i should receive
10:29:19 <blazold> [(Branch (Leaf 1) (Leaf 3)),(Branch (Leaf 2) (Leaf 3))]
10:29:38 <blazold> and i have no idea what to do :)
10:29:39 <Cale> ah, neat :)
10:29:49 <blazold> i have no idea for these thingz: 
10:30:04 <blazold> 1) how to make my haskell interpret (HUGS) to show me the structure
10:30:15 <blazold> like (Branch (Leaf 1) (Leaf 3))
10:30:25 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Eq, Show, Read)
10:30:27 <blazold> it always says that there is no show for "Tree a"
10:30:52 <Cale> might as well derive some classes like Show
10:31:12 <araujo> @index lexeme
10:31:13 <lambdabot> Text.ParserCombinators.Parsec.Token
10:31:13 <blazold> deriving means like inheritance ?
10:31:23 <Cale> no, just automatic generation
10:31:36 <blazold> so what is "deriving (Eq, Show, Read)"
10:31:44 <Cale> Only some classes are derivable
10:32:02 <Cale> That means that it will generate the "obvious" instances for Eq, Show, and Read
10:32:12 <Cale> which are just based on the structure of the type
10:32:14 <blazold> ah, ok
10:32:51 <blazold> i see
10:32:54 <blazold> now the second problem is 
10:32:58 <blazold> that 
10:33:06 <blazold> 2) i know how to work with e.g. lists
10:33:12 <blazold> like how to implement "tail" function
10:33:38 <blazold> but have no idea how to implement Prolog-like non-determinism
10:34:14 <blazold> simply said i don't know how to think about that task
10:34:40 <blazold> let's say i know it should be like 
10:34:41 <blazold> doit :: Strom [a] -> [Strom a]
10:34:53 <blazold> ah, sorry Strom == Tree
10:35:12 <Cale> well, that type looks right
10:35:18 <Cale> Do you know about monads?
10:35:22 <blazold> nope
10:35:25 <roconnor> hmm, How do I add two points on an elliptic curve.
10:35:53 <Cale> roconnor: you take the line passing through them, and there will be a 3rd point on the curve also on that line
10:36:07 <Cale> roconnor: if the points are identical, use the tangent line
10:36:38 <roconnor> ;)
10:36:41 <Cale> I think you might have to do one other thing...
10:37:01 <roconnor> what's a tangent line in a finite field?
10:37:15 <Cale> (excuse me, I only took one course in algebraic geometry, and this just popped up as a brief special topic)
10:37:28 <Cale> you can still differentiate formally
10:37:46 <blazold> the problem is that the task was given after 90 minute intro to haskell which ended with defining the Tree structure and that's all :)
10:37:51 <jyp>  blazold: have you written the Leaf case already?
10:37:56 <Cale> blazold: hehe :)
10:38:11 <Cale> blazold: well, it should be doable just with recursion
10:38:18 <blazold> i hope so
10:38:30 <blazold> but really can't see how to make it in haskell
10:38:34 <blazold> can do it in prolog
10:38:35 <roconnor> http://www.cryptoman.com/elliptic.htm
10:38:43 <blazold> but no chance in haskell for me yet
10:38:44 <roconnor> Point 7 is the answer
10:39:11 <jyp> blazold: use list comprehensions, probably.
10:39:25 <blazold> i've tried to think out if the simple recursion can be used
10:39:27 <Cale> list comprehensions are sort of like nondeterminism :)
10:39:29 <blazold> like for leafs
10:39:30 <blazold> doit (Leaf [a]) = [(Leaf a)]
10:39:44 <Cale> well, that's too specific
10:39:52 <blazold> now i need something for longer lists
10:39:56 <Cale> right
10:40:07 <blazold> i need something like
10:40:07 <Cale> do the general case right off the bat here :)
10:40:18 <Cale> commute (Leaf xs) = ...
10:40:27 <blazold> commute ?
10:40:42 <Cale> yeah, since we're commuting the [] and Tree type constructors :)
10:40:53 <araujo> lisppaste2, help?
10:40:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:41:00 <Cale> you can call it doit if you want :)
10:41:11 <blazold> commute (Leaf (head:tail)) = ???
10:41:35 <Cale> don't bother breaking down the list
10:41:44 <jyp> blazold, you have all sorts of predefined functions that do the recursion on lists for you :)
10:41:57 <blazold> i want to take head and get the result AS WELL AS continue with the tail doing the same
10:42:06 <lisppaste2> araujo pasted "parsec problem" at http://paste.lisp.org/display/15026
10:42:21 <Cale> ah, roconnor: you have to take the reflection in the x axis after too.
10:42:22 <araujo> Anybody good with parsec who could help me there?
10:42:38 <Cale> blazold: don't split up the list at all
10:42:40 <Cale> :)
10:42:41 <araujo> It is giving compilation errors , buti don't understand why
10:42:42 <Cale> use map
10:42:55 <Cale> or a list comprehension
10:43:07 <blazold> well i understand the map function but can't see what it is good for me for this task
10:43:19 <palomer> ok, time to read up on type systems
10:43:23 <palomer> anyone has any papers to recommend?
10:43:37 <Cale> blazold: well, you have a list of values which you want to make into leaves, right?
10:43:40 <CosmicRay> any conjure hackers here?
10:43:41 <blazold> the problem is that i have no example on that nondeterminism
10:43:49 <Di-Fosfor> @hoogle minInt
10:43:50 <lambdabot> No matches found
10:43:54 <blazold> i've got list of values
10:43:58 <blazold> but only one 
10:44:03 <blazold> should be the leaf
10:44:04 <Cale> commute (Leaf xs) = ...
10:44:07 <Cale> xs is a list
10:44:18 <Di-Fosfor> Hrm.. anybody know how to get the minimum and maximum Int values?
10:44:23 <Cale> you want to return a list of trees
10:44:28 <Cale> what list of trees is it?
10:44:30 <araujo> @index max
10:44:31 <lambdabot> Prelude
10:44:34 <araujo> @index min
10:44:35 <lambdabot> Prelude
10:44:38 <Cale> Di-Fosfor: minimum and maximum
10:44:39 <roconnor> Cale, ah yes. ... Good thing I'm blindly following these formulas
10:44:40 <blazold> Cale: ?
10:44:44 <araujo> @type min
10:44:45 <lambdabot> forall a. (Ord a) => a -> a -> a
10:44:46 <Cale> > minimum [1,2,3,4,5]
10:44:48 <lambdabot> 1
10:44:52 <Cale> > maximum [1,2,3,4,5]
10:44:54 <lambdabot> 5
10:44:56 <Di-Fosfor> Sorry, not like that
10:45:05 <neologism> you mean the max value of Int ?
10:45:10 <Di-Fosfor> I meant the lowest possible value for an Int param
10:45:14 <Di-Fosfor> yeah
10:45:56 <lennart> maxBound::Int
10:45:58 <Cale> > maxBound :: Int
10:46:00 <lambdabot> 2147483647
10:46:01 <roconnor> Does Cabel work?
10:46:03 <Cale> > minBound :: Int
10:46:03 <blazold> Cale: we want list of trees that's right
10:46:05 <lambdabot> -2147483648
10:46:09 <Cale> blazold: right
10:46:13 <Di-Fosfor> Thanks guys :)
10:46:22 <Cale> blazold: and we have a list of values which we want to turn into trees
10:46:27 <xerox> > minBound + maxBound :: Int
10:46:29 <lambdabot> -1
10:46:35 <blazold> Cale: could be
10:46:36 <Cale> blazold: how do we turn an 'a' into a 'Tree a'?
10:46:49 <blazold> we make (Leaf a)
10:46:53 <blazold> that's Tree a
10:46:56 <Cale> right
10:47:10 <blazold> in prolog i have "member" function
10:47:11 <Cale> so by applying Leaf to those values, we'll get trees
10:47:26 <Cale> how do we apply Leaf to each of the elements of our list?
10:47:34 <blazold> map leaf ;)
10:47:38 <Cale> right
10:47:47 <jyp> ..nah... map Leaf :p
10:47:52 <Cale> well, yes
10:47:55 <blazold> sure
10:47:55 <xerox> nah, map (Leaf)
10:48:02 <blazold> :)
10:48:03 <Cale> xerox: why the parens?
10:48:05 <jyp> lol
10:48:25 <xerox> map Leaf [1,2,3]  ==>  error
10:48:36 <Cale> um, no
10:48:43 <Cale> why would that be an error?
10:48:47 <xerox> Can't match 'Num a => Tree a' with '(a -> b)'
10:49:02 <xerox> > map Just [1,2,3]
10:49:03 <lambdabot> [Just 1,Just 2,Just 3]
10:49:05 <xerox> O_O
10:49:13 * xerox hits the head on the desk
10:49:16 <esap> map (const Leaf) [1,2,3] perhaps?
10:49:23 <Cale> esap: no
10:49:40 <xerox> Cale: I ever thought I was lke that... MUMBLE.
10:50:01 <jyp> me /hugs xerox 
10:50:08 <jyp> rofl
10:50:28 <blazold> well for me
10:50:29 <roconnor> Hmmm, the number b doesn't occur in the addition formula.
10:50:29 <blazold> Main> map Leaf [1,2,3]
10:50:29 <blazold> [Leaf 1,Leaf 2,Leaf 3]
10:50:29 <xerox> Well, thanks :)
10:50:34 <roconnor> that seems bad.
10:50:39 <xerox> Wee, that's weird, though.
10:51:06 <Cale> bad?
10:51:08 <Cale> oh
10:51:11 <Cale> b?
10:51:24 <Cale> xerox: Leaf is also a function
10:51:30 <xerox> Cale: I know...
10:51:31 <roconnor> from y^2 = x^3 + a*x + b.
10:51:50 <blazold> ok, we've got commute for a leaves - list of e.g. numbers, that's nice, now i can try to buildup the tree with branches too
10:51:52 <xerox> Cale: we need '$' because a b c is (a b) c and not a (b c) right?
10:51:55 <neologism> blazold: mimochdem, cech zdravi cecha :)))
10:52:15 <blazold> neologism: ja jsem si te uz vsim :) cets jsem mnohe z tveho blackhoulu
10:52:17 * xerox screatches his head..
10:52:29 <blazold> neologism: jen se tady snazim vyonanovat ten ukol
10:52:29 <Cale> xerox: map Just [1,2,3] = (map Just) [1,2,3]
10:52:41 <blazold> neologism: takze sem te jeste neoslovil ;)
10:52:50 <xerox> Cale: so my argument is your argument, hehe
10:53:02 <blazold> neologism: procz se czech pripojuje z .sk ;)?
10:53:08 <xerox> Anyway, I thought it was wrong, mah.
10:53:11 <neologism> privmsg
10:53:22 <Cale> blazold: okay, so now what should we do with the branches/
10:53:22 <Cale> ?
10:53:38 <blazold> Cale: lemme think about it little bit ;)
10:53:51 <neologism> ha! privmsgs are blocked on freenode
10:54:03 <Cale> neologism: only for unregistered users
10:54:03 <xerox> neologism: so you can't cheat!
10:54:06 <xerox> heh.
10:54:23 <jyp> blazold, I guess you better rewrite the Leaf case as a list comprehension first...
10:54:25 <neologism> havent noticed I am unregistered
10:54:46 <blazold> jyp: would be nice if i knew what "list comprehension" is 
10:55:02 <roconnor> Another reference says it is the same.
10:55:05 <Cale> commute (Leaf xs) = [Leaf x | x <- xs]
10:55:21 <jyp> thanks Cale :)
10:55:40 <Cale> that's equivalent to the version you wrote above
10:55:48 <blazold> ah, ok
10:55:51 <blazold> i see
10:56:02 <jyp> that should help for the Branch case 
10:56:06 <blazold> that's that 'evil haskell's for loop'
10:56:22 <Cale> It's not evil at all
10:56:36 <Cale> just syntax sugar for map and filter
10:56:38 <blazold> it's all evil ;) never seen something like that
10:56:45 <blazold> in other languages
10:56:49 <neologism> set generator
10:56:52 <neologism> its comon in math
10:56:53 <Cale> python
10:57:12 <humasect> st almost
10:57:23 <blazold> i'm more asm guy (neologism like asm-guys ;)
10:57:49 <neologism> I've never seen asm which containts set generators :)
10:58:21 <blazold> neo-> yo vidim
10:58:32 <neologism> a muzes mi odepsat?
10:58:46 <blazold> neologism: odepisuju, otazka je jestli neco vidis ty ;)
10:58:51 <neologism> nevidim
10:58:54 <neologism> nejsi zaregistrovany
10:58:56 <tennin> why did you have to rewrite it as list comprehension?
10:58:59 <blazold> mno to nejsem no
10:59:04 <neologism> nevermind
10:59:14 <xerox> commute (Leaf xs) = xs >>= return . Leaf
10:59:21 <Cale> tennin: it makes the Branch case easier to deal with :)
10:59:49 <blazold> neologism: uz ?
10:59:50 <Cale> commute (Leaf xs) = do x <- xs; return (Leaf x)
11:00:07 <Cale> blazold: there's your nondeterminism :)
11:00:12 <blazold> what's ";" and return ?
11:00:25 <Cale> blazold: ; is just a line separator
11:00:43 <jyp> @type return
11:00:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
11:01:11 <neologism> he doesnt know anything about monads... so I dont thgink this is of any use for him
11:01:19 <palomer> anyone here tried cayenne?
11:01:32 <xerox> neologism: that's the good part of the internet, heh.
11:02:11 <neologism> yeah but.. you know ;)
11:02:45 <Cale> blazold: return has to do with monads, the list monad models nondeterminism
11:02:55 <Cale> > return 5 :: [Integer]
11:02:56 <lambdabot> [5]
11:03:02 <Cale> > return 5 :: Maybe Integer
11:03:04 <lambdabot> Just 5
11:03:15 <jyp> blazold, you can also see the "do notation" as another way to write list comprehensions.
11:03:36 <blazold> gimme a sec
11:03:46 <Cale> yeah, in fact list comprehensions used to be monad comprehensions :)
11:06:49 <Cale> *Main> sequence [Branch (Leaf 1) (Leaf 3),Branch (Leaf 2) (Leaf 3)]
11:06:49 <Cale> Branch (Branch (Leaf [1,2]) (Leaf [1,3])) (Branch (Leaf [3,2]) (Leaf [3,3]))
11:06:50 <mjl69_> oh, because a list is a monad?  a common special case?
11:06:52 <Cale> hehe
11:06:56 <Cale> mjl69_: yeah
11:08:15 <palomer> cayenne looks freaky
11:09:55 <jyp> palomer: you probably want to look at modern versions of dependent types languages...
11:10:09 <jyp> like Omega or Epigram
11:10:22 <Cale> instance Monad Tree where
11:10:22 <Cale>     return = Leaf
11:10:22 <Cale>     Leaf x >>= f = f x
11:10:22 <Cale>     Branch t t' >>= f = Branch (t >>= f) (t' >>= f)
11:10:40 <palomer> jyp: which one is more popular?
11:11:16 <jyp> I'm not sure we can call any popular :)
11:11:17 <esap> what's Omega? URL?
11:11:26 <jyp> but Omega is probably easier
11:11:32 <jyp> @where omega
11:11:34 <lambdabot> I know nothing about omega.
11:11:43 <jyp> @google tim sheard omega
11:11:45 <lambdabot> http://www.cs.pdx.edu/~sheard/
11:12:22 <jyp> @where+ omega http://www.cs.pdx.edu/~sheard/
11:12:23 <lambdabot> Done.
11:12:56 <esap> Thanks.
11:13:22 <jyp> you're welcome
11:13:26 <mjl69_> @type (>>=)
11:13:28 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
11:13:59 <jyp> @where epigram
11:14:00 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
11:14:15 <palomer> epigram seems better documented
11:14:31 <jyp> then I guess epigram is more popular... at least to lambdabot :)
11:18:21 <blazold> Cale: that's interesting
11:18:57 <blazold> Cale: however i've no idea what's instance, monad, return and >>=  :)
11:19:01 <blazold> but i'll try
11:19:27 <blazold> ah! have no idea how to try ;)
11:19:31 <Cale> instance is just syntax for declaring instances of typeclasses
11:19:44 <mjl69_> so above, Leaf is a monad (a type constructor of Tree?) holding value x.  Second arg is the function f which can take a value of the same type as x and return a monad of type Tree?
11:19:52 <Cale> the code I pasted makes your Tree type an instance of Monad
11:20:04 <Cale> Tree is a monad
11:20:30 <Cale> Leaf is a data constructor of Tree
11:21:31 <Cale> in (x >>= f), x is a value of type Tree a, and f is a function from values of type a to values of type Tree b
11:21:33 <blazold> &-) still confused
11:21:49 <Cale> and >>= does the only obvious thing one could do with those
11:22:27 <jyp> haha :)
11:22:40 <Cale> *Main Control.Monad> Leaf 5 >>= \x -> Branch (Leaf x) (Leaf (x+1))
11:22:40 <Cale> Branch (Leaf 5) (Leaf 6)
11:22:54 <franka> Cale, still kickstarting your career of online Haskell tutelage I see.
11:23:07 <Cale> *Main Control.Monad> Branch (Leaf 1) (Leaf 2) >>= \x -> Branch (Leaf x) (Leaf (x+1))
11:23:07 <Cale> Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 2) (Leaf 3))
11:23:24 <franka> Your check is in the mail.
11:23:30 <Cale> heh
11:23:44 <blazold> i would rather come back to "commute (Leaf xs) = map Leaf xs" this stile of programming 
11:23:50 <blazold> ;)
11:24:09 <blazold> and i'm going to define 
11:24:10 <blazold> commute (Branch l r) = 
11:24:11 <blazold> this 
11:24:17 <Cale> blazold: well, this isn't immediately applicable to your problem anyway :)
11:24:20 <Cale> so yeah
11:24:31 <blazold> Cale: you mean your way or my way ?
11:24:53 <Cale> what I was talking about there was more an answer to the problem which is opposite yours
11:25:01 <jyp> The wiseman says "There is only one true way"
11:25:13 <jyp> nevermind me.
11:25:21 <franka> No, the wiseman says the opposite.
11:25:26 <franka> Er, wise man.
11:25:27 <jyp> :)
11:25:32 <r3tex> anyone here go to chalmers?
11:25:35 <Cale> jyp: with polymorphism, that's often the case :)
11:25:47 <blazold> i'd say "commute (Branch l r) = (Branch (commute l) (commute r))"
11:26:01 <Cale> blazold: except that's a type error
11:26:11 <jyp> bzzt!
11:26:22 <blazold> yeah
11:26:26 <Cale> you certainly have the right idea though
11:26:36 <blazold> but why ?
11:26:44 <Cale> because commute l is a list
11:26:54 <Cale> but Branch takes trees
11:27:07 <Cale> *Main Control.Monad> :t Branch
11:27:08 <Cale> Branch :: Tree a -> Tree a -> Tree a
11:27:14 <blazold> i see
11:27:15 <blazold> but
11:27:21 <jyp> now is the time to remember my advice about comprehensions :)
11:27:28 <blazold> i need either branch or leaf, right ?
11:27:31 <franka> "But isn't a list just a flat tree?"
11:27:32 <Cale> right
11:27:36 <Cale> well
11:27:38 <Cale> actually
11:27:49 <Cale> You don't just want one Tree to be returned either
11:27:55 <Cale> you want a list of trees
11:27:57 <blazold> yes
11:28:02 <blazold> that's exactly the point
11:28:05 <blazold> i'm not able to solve
11:28:06 <Cale> so you have to create a list
11:28:34 <Cale> One good way to do that, as jyp has been prodding at, is to use a list comprehension
11:29:00 <blazold> but for me it is still "too far" from to know what to do 
11:29:27 <Cale> Well, can you describe what you want it to do in English?
11:29:58 <blazold> hmm, i have to somehow go through the tree
11:30:09 <blazold> find some leaf list
11:30:15 <blazold> get one member of it
11:30:17 <blazold> return it 
11:30:21 <Cale> hehe, too imperative :)
11:30:21 <blazold> go back in the recursion
11:30:27 <jyp> think recursively, dammit! :)
11:30:32 <Cale> hehe
11:30:47 <Cale> you were closer with  commute (Branch l r) = (Branch (commute l) (commute r))
11:31:16 <jyp> btw, does djinn return the correct code for this ?
11:31:19 <franka> blazold thinks in CPS.
11:31:21 <jyp> anyone tried ?
11:31:26 <blazold> cps ?
11:31:30 <Cale> you want to form branches with the results of commute
11:31:32 <blazold> but the problem is that (commute l) if it worked return the list of all trees
11:31:37 <franka> Nevermind, I am being an ass.
11:31:45 <blazold> so what i want
11:31:53 <blazold> is to take every member of this result
11:31:56 <blazold> of this commute l
11:31:59 <lennart> jyp: this being commute?
11:31:59 <Cale> yes
11:32:00 <blazold> take one member - one tree
11:32:10 <blazold> and to do something with it - like connecting to a branch
11:32:13 <blazold> with right side
11:32:14 <Cale> yes
11:32:17 <franka> Hello, Lennart.
11:32:18 <jyp> yeah... blazold's exercise
11:32:21 <blazold> put together and whoala ;)
11:32:41 <blazold> so i've got a list
11:32:44 <Cale> > [x + y, x <- [1..5], y <- [10,20..50]]
11:32:45 <blazold> that's where <- 
11:32:45 <lambdabot>  parse error on input `<-'
11:32:47 <blazold> yeah
11:32:49 <Cale> > [x + y | x <- [1..5], y <- [10,20..50]]
11:32:50 <lambdabot> [11,21,31,41,51,12,22,32,42,52,13,23,33,43,53,14,24,34,44,54,15,25,35,45,
11:32:50 <lambdabot> 55]
11:32:58 <blazold> that's exactly what i wanted to say
11:33:18 <jyp> ... tadaa!
11:33:25 <blazold> so the syntax of [ ? | ? <- ?]
11:33:27 <blazold> is
11:33:48 <Cale> you're allowed to put multiple generators on the right side of |
11:33:48 <blazold> nope it is like 
11:33:51 <blazold> [ ? <- ?]
11:33:56 <blazold> nope
11:33:58 <blazold> jesus
11:34:14 <Cale> [ expr | var1 <- list1, var2 <- list2, ...]
11:34:15 <blazold> [ do_something_with X | X <- list, conditions]
11:34:16 <blazold> right ?
11:34:32 <Cale> well, it's actually a list of generators or conditions
11:34:39 <Cale> you can mix them freely
11:34:43 <blazold> so
11:34:46 <blazold> i've got commute l
11:34:49 <blazold> but in fact i want
11:34:57 <blazold> little_tree <- commute l
11:35:16 <blazold> but what would expr be here ?
11:35:29 <blazold> Branch little_tree
11:35:30 <Cale> > [ (x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
11:35:32 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
11:35:33 <blazold> and another_little_tree
11:35:37 <blazold> hope so :)
11:35:41 <franka> What is the purpose of this exercise, if I may interrupt?
11:36:11 <blazold> franka: to make me crazy ;) or to teach me a haskell or just to finish my homework
11:36:23 <Cale> franka: to commute the list and tree functors :)
11:36:28 <franka> I mean: what is the function you want to define>
11:36:35 <franka> OK.
11:36:45 <blazold> [Branch lBranch rBranch | lBranch <- commute l, rBranch <- commute r]
11:36:45 <Cale> commute :: Tree [a] -> [Tree a]
11:37:05 <Cale> blazold: right
11:37:09 <lennart> jyp: djinn would be clueless about commute.  djinn doesn't like recursion of any kind.
11:37:22 <franka> With nodes only at the leaves?
11:37:29 <Cale> franka: yeah
11:37:30 <jyp> lennart, oh, ok
11:37:34 <jyp> I didn
11:37:41 <blazold> woo
11:37:46 <blazold> seems to work
11:37:51 <jyp> 't check the details of djinn
11:37:51 <blazold> like completely work :)
11:38:14 <Cale> blazold: we could also write that  do x <- commute l; y <- commute r; return (Branch x y)
11:38:23 <Cale> just for a taste of monad syntax :)
11:38:33 <jyp> The world celebrates :)
11:38:48 <Cale> perhaps that fits better with your intuition about nondeterministic computation
11:38:48 <blazold> that's evil
11:39:03 <jyp> it's holy
11:39:07 <franka> Is there a unique solution to this?
11:39:08 <Cale> x nondeterministically gets a result of commute l
11:39:11 <Cale> y nondeterministically gets a result of commute r
11:39:20 <Cale> and then you put the results together :)
11:39:35 <Cale> franka: only one that's really natural
11:39:37 <franka> Oh, if they are functors.
11:39:46 <franka> For it to be natural.
11:39:55 <franka> Literally.
11:40:00 <blazold> well so it seems
11:40:07 <blazold> that
11:40:08 <blazold> data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Eq, Show, Read)
11:40:08 <blazold> commute :: Tree [a] -> [Tree a]
11:40:08 <blazold> commute (Leaf xs) = map Leaf xs
11:40:08 <blazold> commute (Branch l r) = [Branch lBranch rBranch | lBranch <- commute l, rBranch <- commute r]
11:40:12 <blazold> this makes the stuff
11:40:18 <Cale> yeah, it works
11:40:30 <blazold>  so
11:40:32 <blazold> cale:
11:40:34 <blazold>  ^^
11:40:36 <blazold>  \/
11:40:42 <Cale> heh
11:40:46 <blazold> one big thank for you ;)
11:40:54 <Cale> no problem
11:41:19 <blazold> very nice
11:42:00 <franka> That looks like you are giving him the bird. :)
11:42:11 <jyp> \o/ \o/ \o/ \o/ \o/ <-- cheering crowd
11:42:12 <lennart> well designed home work to show the power of Haskell ;)
11:42:22 <blazold> :o)
11:42:32 <blazold> too strong coffee for me
11:42:54 <blazold> well when one sees haskell syntax for an hour and half 
11:43:00 <blazold> it is quite non-trivial
11:43:05 <blazold> to create something like
11:43:08 <blazold> those 4 lines
11:43:31 <blazold> but except "deriving" syntax
11:43:40 <jyp> now try to rewrite it without list comprehension :p
11:43:44 <blazold> everything was in those 90 minutes
11:44:04 <blazold> so maybe it is just too different style of programming 
11:44:05 <jyp> ... nor monads 
11:44:08 <blazold> for me
11:44:38 <franka> It becomes natural with practice.
11:45:18 <lennart> yes, you get used to it after a few years ;)
11:45:35 <franka> lennart, I've never seen you here before.
11:45:46 <Cale> try translating that list comprehension into applications of concat and map :)
11:46:00 <franka> Are you keeping an eye on your students? :)
11:46:34 <Cale> lennart: well, it usually takes a few years to get used to imperative programming too :)
11:46:39 <blazold> and i'm now so exhausted
11:46:41 <blazold> to leave you
11:46:43 <lennart> nah, my students are done by now
11:46:43 <blazold> tx to all
11:46:47 <jyp> franka: like, in a very incognito way... :p
11:46:55 <blazold> have a nice night (i'm gmt +1)
11:47:04 <blazold> and cya 
11:47:10 <Cale> blazold: quite welcome -- come back any time if you have more questions
11:47:16 * jyp waves
11:47:21 <blazold> tx
11:48:12 <palomer> I'm reading the "why dependent types matter" paper
11:48:18 <palomer> it's giberish to me
11:48:55 <lennart> it's not the best paper to have such a pretentious title
11:49:30 <franka> I don't think it sounds pretentious.
11:50:07 <palomer> omg, xemacs is needed for epigram
11:50:21 <lennart> well, it's a similar title to John Hughes' paper "Why functional programming matters"
11:50:24 <jyp> it sounds like it's written for the "random computer scientist" while isn't
11:50:32 <franka> Ah, that's true.
11:50:35 <jyp> imho
11:50:41 <franka> (re: lennart)
11:50:41 <lennart> And that paper is rather well written
11:50:55 <franka> I haven't read the paper, only the slides.
11:51:13 <palomer> pfft, epigram is written in haskell and needs xemacs to run, what the hell?
11:51:18 <lennart> palomer: you should read my paper instead ;)
11:51:26 <palomer> lennart: on what?
11:51:31 <lennart> CAyenne
11:51:45 <palomer> lennart: I seriously don't get dependent types yet
11:51:53 <palomer> lennart: what they're good for, what they express, etc...
11:51:57 <lennart> That's why you should read my paper
11:51:59 <franka> That is the point.
11:52:10 <palomer> lennart: where's your paper?
11:53:28 <lennart> you can type lennart into google and follow a few links
11:54:03 <palomer> oh, that paper
11:54:07 <palomer> yeah, I started reading it
11:54:42 <palomer> there is one part I didn't understand
11:54:50 <lennart> only one? :)
11:54:57 <palomer> well, one big one
11:55:22 <lennart> which is?
11:55:23 <palomer> type Eq a = sig (==) :: a -> a -> Bool equiv ::  Equiv (liftBin (==))
11:55:48 <palomer> now from my understanding to construct an element of Eq a you need to supply two things
11:55:56 <lennart> yes
11:55:59 <palomer> an element of type a -> a -> Bool
11:56:05 <palomer> and an element of type Equiv (liftBin (==))
11:56:12 <lennart> that's right
11:56:52 <palomer> and if your element of type Equiv (liftBin (==))  is not bottom, then we know that == is an equivalence relation
11:57:00 <palomer> is this correct?
11:57:25 <lennart> that's right
11:57:57 <palomer> now...how does this work?
11:59:23 <lennart> hmmmm, how does it work?  Well, with depedent types the Curry-Howard isomorphism is extended from propositional calculus (as we've got with Haskell types) to predicate calculus.  So you can express arbitrary properties.
11:59:35 <lennart> I'm not sure this really helps you.
11:59:47 <franka> Should equality be a congruence also?
12:00:00 <franka> +n't
12:00:05 <palomer> actually, Equiv R := forall x, forall y, forall z, (R(x,y) -> R(y,x)) and R(x,x) and (R(x,z) and R(z,y) -> R(x,y)), right?
12:00:17 <lennart> Oh, sure, it should be a congruene.  This is just an example.
12:00:45 <palomer> and liftBin op := op(x,y) <-> x==y, right?
12:00:57 <palomer> err
12:01:04 <palomer> actually, what's liftBin?
12:01:15 <lennart> liftBin lifts a boolean function to the propositional level
12:01:24 <palomer> yeah, but what's the formula representing liftBin
12:01:56 <palomer> liftBin should have a propositional representation
12:02:24 <lennart> it maps False to the empty set and True to a non-emptry set
12:03:02 <palomer> oh, liftBin isn't a dependent type
12:03:07 <palomer> it's an actual function
12:03:48 <lennart> Well, it maps values to types so I'd call it a depedent type
12:03:56 <palomer> ok, so it's a dependent type
12:04:21 <palomer> and, erm, dependent types have first order representations, right?
12:04:33 <lennart> what does that mean?
12:04:45 <palomer> I wrote out Equiv before
12:04:50 <palomer> Equiv = some first order formula
12:05:07 <palomer> rather, Equiv R = some firts order formula
12:06:59 <franka> Hello, JohnMeacham.
12:07:29 <palomer> liftBin op := forall x, forall y, isTrue(op x y) ?
12:07:36 <lennart> there's a simple definition.  if you want to call it first order or no, I don't know
12:07:57 <palomer> where isTrue is the predicate containing the boolean true and nothing else
12:08:18 <palomer> is this correct?
12:08:23 <lennart> yes
12:08:35 <CosmicRay> hi John
12:08:43 <lennart> isTrue True = Truth; isTrue False = Absurd
12:08:56 <palomer> sure
12:09:05 <lennart> where Truth is some non-empty set and Absurd is an empty set
12:09:08 <palomer> ok, so now I can understand the type of equiv
12:09:23 <palomer> wait, predicates are simply n-ary sets
12:09:33 <palomer> isTrue = {True}, no?
12:10:07 <lennart> it doesn't really matter what non-empty set you pick
12:10:45 <lennart> it matters to how your proof terms will look, but not the provability
12:11:11 <palomer> hrmph, anyways I don't see why a term of type Equiv(liftBin(==)) will prove the equivalency of ==
12:11:56 <lennart> it will because to find an element in Equiv(liftBin(==)) you have to supply a proof
12:12:08 <palomer> sure
12:12:33 <lennart> perhaps you should download Cayenne and look at some of the examples
12:12:46 <palomer> but there's still stuff that bothers me
12:12:51 <palomer> since CH says nothing of semantics
12:12:58 <palomer> sure, it shows that the statement is true
12:14:04 <lennart> it show that the statement is true in a constructive way.  what more can you ask for? :)
12:14:09 <franka> Why do you say CH says nothing of semantics?
12:16:18 <palomer> CH states that there is an easy homomorphisms alpha and beta such that if a term t has type T then alpha(T) is provable with proof beta(T)
12:16:29 <palomer> err, beta(t)
12:16:42 <palomer> term t in simply typed lambda
12:16:44 <palomer> calculus
12:17:47 <lennart> and in Cayenne you don't bother with the homomorphisms, you use the type and term syntax all the time
12:17:51 <palomer> where proof is defined in, say, natural deduction
12:18:15 <lennart> each term is easily translatable to ND if you want to
12:19:33 <palomer> however, we have function (==) living in function land and we have Reflexive R := forall x. R(x,x) living in predicate calculus land, and a priory I don't see why proving Reflexive (liftBin (==)) shows that (==) is reflexive
12:19:41 <palomer> though I really want to believe it
12:20:01 <palomer> since it seems really intuitive
12:20:22 <palomer> to be convinced, I'd need someone to give me a model theoretic argument
12:20:49 <palomer> (not too many of those around though:()
12:21:25 <lennart> Oh, I see what you're saying :)
12:21:29 <cm> what is liftBin?
12:22:06 <palomer> ie, I have a term for Reflexive (liftBin (==)), now someone show me that anywhere in my computer program I can replace x==y with y==x and have an equivalent computer program
12:22:13 <palomer> cm: it maps a boolean function to a predicate
12:22:24 <palomer> for some definition of equivalent
12:22:44 <palomer> err, rather, I can replace x==x with True
12:22:50 <lennart> Yes, that would take some additional proofs
12:23:08 <palomer> lennart: is this done anywhere? (this is really what's bothering me about this whole deal)
12:23:15 <JohnMeacham> hello.
12:23:29 <jyp> hi John
12:23:36 <palomer> hullo
12:24:39 <franka> The model theory of dependent types is notoriously complicated.
12:24:55 <cm> palomer: is it an isomorphism? ;)
12:25:48 <palomer> no way, computable boolean functions are countable
12:26:06 <palomer> franka: I can handle it!
12:26:26 <cm> ah, this is computable function land.
12:26:29 <franka> Then look in Bart Jacobs' book, or Paul Taylor's.
12:26:37 <lennart> palomer: your particular example shouldn't be difficult
12:27:57 <lennart> you want to show that x==x and True are congruent
12:28:17 <palomer> congruent modulo the program equivalence relation
12:28:42 <lennart> yes, that's always there
12:30:32 <lennart> It's quite possible that the example I used in my paper isn't the one best suited for doing these kind of proofs.  It was really juest meant as a motivation why you'd want dependent types to express additional properties.
12:32:15 <palomer> and we'd need to show that congruence factors through application and abstraction
12:32:28 <palomer> (as well as everything else you can do to a term)
12:32:59 <lennart> but that's the definition of congruence
12:33:42 <palomer> oh, I thought we were talking about congruence in the general sense of the word
12:34:20 <lennart> no, I was talking about the notion of congruence that you can define in Cayenne
12:34:39 <palomer> lennart: are you sure it's a definition? I always took congruent modulo an equivalence relation P as "x and y are congruent iff P(x,y)"
12:35:12 <palomer> where P is program equivalence in this case (but now we have to define program equivalence)
12:35:50 <lennart> Cong |a R = (F :: a -> #) |-> (x,y :: a) -> x `R` y -> F x -> F y
12:36:01 <lennart> it's one way
12:36:11 <lennart> Leibniz' equality
12:36:40 <palomer> yeah, I've seen that as forall X. forall a. forall b.(Xa -> Xb)
12:37:11 <lennart> There's a more refined equality available in Cayenne based on Martin-Loev's equality type.  It's not definable within Cayenne, though.
12:38:00 <palomer> but, erm, then we'd need to show that if two terms are congruent then they belong to the same computable predicates (which is what your statement is saying, but I still need to be convinced that your statement proves this)
12:38:04 <palomer> do you understand what I'm getting at?
12:38:44 <lennart> no
12:40:31 <palomer> say I've shown a and b to be congruent , does this mean that for any function f::Term -> Bool in cayenne (or meta-cayenne), f(a) = f(b) ?
12:40:49 <lennart> brb
12:44:06 <lennart> palomer: what is your = in that statement?
12:44:29 <palomer> boolean equivalence
12:44:50 <lennart> then the answer is yes
12:44:51 <palomer> for simplicity sakes though we should simply agree no a definiition of program equivalence
12:44:58 <palomer> lennart: but I would need a proof!
12:45:15 <palomer> s/no/to
12:45:51 <lennart> if I wasn't trying to pick music for our Pacific eclipse video as we speak I would do the proof for you.  It should be two lines. :)
12:46:13 <lennart> The proof would be inside Cayenne, of course
12:46:33 <lennart> So you have to trust that the logic it has is right.
12:47:39 <lennart> you can simplify things down to the level of, say, Martin-Lof type theory and make the same proofs.
12:48:16 <lennart> If you feel that you somehow need to justify why that is correct you're on you're on your own. :)
12:48:34 <lennart> At some level you have to give up and just believe.
12:48:40 <palomer> yeah 
12:48:41 <palomer> model theory
12:48:49 <palomer> we can actually stop before then
12:49:13 <lennart> why stop at model theory? :)
12:49:15 <palomer> ok, two terms are equal if: they are the same 0-ary constructor, they are the same constructor applied to equal terms
12:49:38 <lennart> that's one definition of equality
12:50:38 <lennart> in constructive type theory circles it's the more modern definition of equality
12:50:52 <palomer> theory circles it's ?
12:51:52 <CosmicRay> Is there any way I can embed a deprecation warning in my own code, similar to how GHC does for FiniteMap?
12:52:49 <cm> "among constructive type theorists"
12:54:57 <Cale> hmm, that definition fails to deal with infinite terms, but that's easy to fix
12:55:34 <palomer> Cale: sure, take the co-inductive definition
12:55:46 <lennart> Cale: well, for co-inductive types you need a co-inductively defined euality
12:56:06 <palomer> I still don't see the exact link between types and program invariants
12:56:58 <palomer> I would so love to see a statement of the form "if we find a term for type T, then the formula phi(T) is true in this model which contains your program"
12:57:14 <lennart> I wish I had half an hour at a whiteboard to show you. :)
12:57:37 <Cale> lennart: yeah, well, not necessarily *need*, but that's an elegant way :)
12:57:41 <lennart> oh, you're still hung up on model theory
12:57:51 <palomer> or anything, really
12:57:59 <palomer> model theory is simply an easy way to state things about equality
12:58:20 <lennart> palomer: but what language would you expect to express such a statement in?
12:58:38 <palomer> first order logic?
12:58:40 <lennart> Cale: right
12:58:42 <palomer> second order logic?
12:59:11 <Cale> I'd probably just model values with sets and use transfinite induction :)
12:59:16 <palomer> higher order logic, linear logic, linear time logic
12:59:26 <palomer> Cale: oh you silly man
12:59:26 <lennart> But the whole constructive type theory is supposed to replace all of those.  It is the basic language for expressing things.
13:00:28 <palomer> constructive type theory is supposed to replace first order logic? what are the semantics?
13:00:44 <franka> It has a topos-theoretic semantics.
13:00:45 <palomer> what about non constructive proofs?
13:00:59 <Cale> All shall bow to the Lord Zermelo's Great Empire!
13:01:00 <lennart> I don't believe in non-constyructive proofs
13:01:10 <palomer> (and non constructively provable "true statements")
13:01:36 <Cale> I'm pro (axiom of) choice
13:01:49 <palomer> lennart: you don't believe "either A is true or not A is true" ?
13:01:54 <lennart> no
13:02:06 <simonf> Hi! Can I have ghc to run a source file immediately, without having to tell it to compile it first?
13:02:20 <CosmicRay> ghci can do that, or hugs.
13:02:20 <lennart> palomer: only if A is decidable
13:02:28 <humasect> runghc
13:02:29 <palomer> if I tell you "it is not raining", can you not deduce that "not raining" is provable?
13:02:42 <Cale> simonf: runghc
13:03:03 <simonf> Cale - thanks!
13:03:15 <palomer> lennart: either a program halts or it doesn't <--you don't believe this is true/
13:03:16 <palomer> ?
13:03:19 <Cale> hehe, humasect was actually first :)
13:03:28 <lennart> well, you claimed "not raining" is true, so I can deduce thet "not raining" is true
13:03:50 <Cale> heh
13:04:01 <lennart> palomer: but program termination is deciable :)
13:04:06 <lennart> decidable
13:04:27 <palomer> the halting problem is decidable?
13:04:28 <lennart> at least on my computers
13:04:40 <basti_> the problem is not decideable
13:04:43 <Cale> I don't really mind the fact that P or not P, despite the fact that neither may be provable.
13:04:45 <humasect> cale, i meant to add yesterday, monads = waterworks for transformation of state
13:04:51 <lennart> it's only decidable on machine with infinite memory
13:05:00 <lennart> non-decidable, I mean
13:05:05 <basti_> oh
13:05:08 <lennart> and I don't have any of those
13:05:43 <Cale> I sort of think that constructive logic is deceptive in its reuse of terms from classical logic.
13:05:56 <franka> That is like saying Int is as good as Integer.
13:05:58 <palomer> quick, someone give me a non recursively enumerable undecidable problem
13:05:59 <lennart> Cale: you're probably right
13:06:40 <franka> It sounds like a practical argument, but it is not practical to check for program termination...
13:06:47 <palomer> ok:
13:07:14 <palomer> a second order formula is either true in all second order models or false in at least one second order model
13:07:34 <lennart> franka: it only takes twice the memory and somewhat longer to run with a termination check
13:07:40 <CosmicRay> Is a HashTable thread-safe?
13:07:51 <franka> You could as well argue that nearly every program is intended to run on infinite-memory computers, and that actually we are running them on poor substitutes! :)
13:08:12 <lennart> yeah, i'm afraid that's true
13:08:17 <palomer> wait...how is the halting problem decidable on a finite memory machine?
13:08:21 <franka> lennart: How?
13:08:52 <Cale> So, when is unboxing day?
13:09:17 <lennart> franka: it's the same technique as for testing equivalence of finite state automata.  You run one at half the speed of the other and see if they two ever hit the same state.
13:09:49 <lennart> finite memory can only encode finite state machines
13:10:04 <palomer> sure
13:10:26 <franka> If they hit the same state, they don't terminate... I see that.
13:10:48 <franka> But how do you decide termination?
13:10:49 <palomer> good point
13:10:55 <musasabi> of course the moment they communicate with the outside world...
13:11:15 <palomer> nonetheless, I stick to my second order formula statement
13:11:30 <lennart> franka: they terminate if they terminate.
13:11:41 <palomer> there is no algorithm for finding out if a second order formula is true in all second order models, the problem isn't even recursively enumerable
13:11:51 <franka> Oh, because they're finite state...
13:11:55 <greenrd> lennart: Yes, but it's still useful to check for termination non-exhaustively, because in a language which assumes infinite memory, if you write a non-terminating program which was meant to be terminating, you've definitely made an error
13:12:26 <franka> Iff they fail to terminate, they eventually hit the same state.
13:12:27 <lennart> greenrd: oh, i'm not advocating my method in practice :)
13:12:31 <greenrd> heh
13:12:55 <franka> In finite time.
13:13:14 <greenrd> Finitude is a big place. :)
13:13:21 <palomer> is (Decidable A) -> (A or not(A))  provable in constructive logic?
13:14:21 <franka> palomer: I think that depends on how you encode it.
13:14:33 <franka> On how you encode the A's.
13:14:52 <palomer> A is a free variable
13:14:56 <musasabi> well if A is decidable A can be computed, thus A, not(A) and (A or not(A)) can be computed?
13:15:25 <franka> You mean satisfiability?
13:16:03 <palomer> nono
13:16:28 <lennart> palomer: Decidable is usually defined as 'A or not(A)' :)
13:16:38 <palomer> (Decidable A) -> (A or not(A)) is as statement is third order logic, certainly not propositional 
13:17:08 <Cale> I love the model-theoretic compactness argument for showing that a non-Archimedean ordered field exists.
13:17:43 <palomer> Cale: I love the model-theoretic  argument for showing that a countable model of the reals exist
13:17:45 <lennart> I love arguments I understand.
13:17:58 <Cale> hehe
13:18:16 <franka> A countable model of the reals?  How is that possible?
13:18:24 * musasabi loves understanding new proofs that looked like gibberish before
13:18:25 <palomer> lennart: nonetheless, I don't see how exactly cayenne types express program invariants
13:18:38 <lennart> Of course the (computable) reals are countable.
13:18:45 <franka> It must be a trivial model.
13:18:52 <palomer> nono, not trivial at all
13:19:03 <palomer> it's quite interesting
13:19:14 <Cale> palomer: does it use compactness? If so, what are the sentences leading up to the least upper bound property?
13:19:14 <lennart> palomer: I'm not sure what you mean by invariant
13:19:58 <palomer> Cale: no, it uses the fact that every for every model  there is a countable model satisfying the same theory
13:20:03 <Cale> ah, right
13:20:24 <Cale> The Lowenheim–Skolem theorem
13:20:45 <palomer> lennart: ok, how cayenne types say things about cayenne programs which correspond to how we would interpret the formula in mathematics
13:21:08 <palomer> I forget the construction, but it's very neat
13:21:25 <Cale> palomer: ah, right, but it's only first order statements
13:21:36 <Cale> and LUB is second order
13:21:49 <palomer> Cale: and models are assumed to deal with first order formulae
13:21:55 <Cale> right
13:22:10 <palomer> I wouldn't be surprised if we could do the same thing for second order formulae
13:22:11 <Cale> but that's less surprising anyway :)
13:22:44 <Cale> If it has to satisfy the least upper bound principle too, I'm fairly sure we can show it's uncountable.
13:22:48 <lennart> palomer: do you fail to see it on a shallow level or on a deep level?  I mean, if you want a model theoretic argument, I won't give you one.  But if you just want an intuitive understanding I could probably help you.
13:23:07 <Cale> In fact, I'm fairly sure we can show it's unique up to isomorphism. :)
13:23:07 <palomer> lennart:  I'll take what I can get then
13:23:51 <palomer> I would probably accept a category theoretic argument
13:23:59 <palomer> (because I can relate it back to model theory:P)
13:24:10 <palomer> Cale: the reals are unique?
13:24:14 <Cale> palomer: yes
13:24:36 <palomer> positive?
13:25:26 <lennart> are they really unique?  not that I believe in classical reals :)
13:26:04 <franka> If the reals are unique and uncountable, how can there be a countable model?
13:26:05 <Cale> Yeah, I have a proof right here
13:26:30 <Cale> franka: there's a countable model satisfying all *first order* sentences that the reals do
13:26:34 <lennart> what about the non-standard models with epsilon?  how do they fail?
13:26:48 <Cale> They fail the least upper bound property
13:26:53 <lennart> ah
13:26:54 <Cale> completeness
13:26:57 <franka> OK.
13:26:59 <Cale> http://planetmath.org/?op=getobj&from=objects&id=5607
13:28:53 <stesch> I'm printing the gentle introduction. Is there a book I could order at Amazon when I like what I read in the 64 page introduction? I'm coming from Ruby and Common Lisp. (Well, and from C and some C like languages.)
13:29:18 <palomer> ruby's fun
13:29:19 <neologism> haskell: the craft of functional programming
13:29:55 <Cale> stesch: the gentle intro isn't all that gentle
13:30:11 <Cale> stesch: You should also have a look at Yet Another Haskell Tutorial
13:30:19 <Cale> @google Yet Another Haskell Tutorial pdf
13:30:21 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
13:30:36 <stesch> neologism: Not available, yet.
13:30:56 <lennart> Cale: I presume you believe in the classical axiom of choice and all the weird things it implies?
13:31:05 <Cale> lennart: believe in?
13:31:12 <stesch> neologism: 2006-10-31 :-)
13:31:20 <neologism> uhm?
13:31:25 <neologism> what do you mean?
13:31:53 <stesch> (German Amazon) http://www.amazon.de/exec/obidos/ASIN/0201882957/302-9218197-8562432
13:31:55 <lennart> Cale: well, perhaps you don't believe in anything.  that mathematics is just symbol pushing. :)
13:32:04 <Cale> I like the classical axiom of choice, but I'm a formalist, yeah.
13:32:11 <neologism> I read that book some years ago
13:32:13 <neologism> 3 yrs or something
13:32:17 <neologism> in english
13:32:26 <lennart> Cale: ok, then it makes some kind of sense
13:32:37 <Cale> The axiom of choice actually makes a lot of things rather nice, while making some things a mess.
13:32:40 <Cale> It's a trade-off
13:32:58 <Cale> I rather like having cardinalities be comparable, for instance.
13:33:03 <lennart> Cale: you can prove things that are too weird for me with it
13:33:11 <stesch> neologism: Amazon doesn't have it. 
13:33:15 <Cale> and it's convenient that every vector space has a basis
13:33:40 <stesch> neologism: Many people have read "On Lisp", which isn't available atm, too. (unless you pay more than 300 EUR for a used book)
13:33:41 <lennart> but if you assume 0=1 you can also prove all sorts of useful things ;)
13:33:45 <neologism> I got that in local university library
13:34:00 <Cale> lennart: well, actually, you just end up proving that your ring isn't so interesting
13:34:11 <stesch> neologism: I don't know where to find the nearest university. :-)
13:34:22 <neologism> ;)
13:34:24 <PupenoL> stesch: on lisp can be downloaded, not that it matters.
13:34:27 <neologism> brno/czech republic
13:34:36 <stesch> Cale: Thanks, I take a look at the yaht
13:34:43 <Cale> If 0 = 1 in a ring, then that ring has one element, and is isomorphic to the trivial ring.
13:34:43 <lennart> Cale: you know what I mean
13:34:46 <stesch> PupenoL: Hard to read on the loo
13:35:03 <Cale> lennart: do you actually think that AoC trivialises set theory?
13:35:03 <lennart> 0=1 for the natural numbers, say
13:35:19 <Cale> lennart: well, that's obviously inconsistent
13:35:53 <humasect> laptop == book
13:35:56 <palomer> lennart: do you have any papers on this stuff to give me a good foundation?
13:36:05 <lennart> Cale: yes, and what with AC you can prove things I don't believe.  So it's similar
13:36:21 <Cale> What do you mean by "prove things you don't believe"?
13:36:22 <lennart> but hey, gotta go now
13:36:37 <Cale> You only ever prove implications :)
13:36:37 <lennart> Cale: like the Hausdorff things about spheres
13:36:41 <stesch> OK, "Yet Another Haskell Tutorial" is a bit too long for my taste. Can't print that on my small printer.
13:36:41 <franka> AC is just a choice like 0=1 is for a ring.
13:37:09 <franka> If you accept it you are proving results about a different universe, but not necessarily a wrong universe.
13:37:13 <Cale> lennart: the Banach Tarski paradox?
13:37:18 <lennart> yes
13:37:21 <Cale> (which isn't really a paradox)
13:37:32 <lennart> anyway, gotta go
13:37:44 <Cale> If you notice that the parts are actually nonmeasurable, it's not so surprising :)
13:37:49 <Cale> see you
13:39:04 <musasabi> 0=1 makes the ring very uninteresting, but with AC one can still do lots of interesting stuff
13:39:48 <Cale> I don't really find it all that bad that you can cut a ball up into finitely many disjoint subsets, some of which don't have defineable volumes, and rotate and translate those into two balls congruent to the original sphere.
13:39:51 <franka> It should not be hard for a computer scientist to accept that when you are doing a proof, you are not talking about the real world---you are talking about symbols, and what you derive from there depends on the rules you admit, not some absolute logic.
13:39:54 <stesch> No book that is still available/in print?
13:40:16 <palomer> cya lennart 
13:40:26 <Cale> Even thinking about the intuition of things, it doesn't seem all that bad to me.
13:40:41 <Cale> If you insist that the pieces be measurable, then everything is okay.
13:41:10 <palomer> I can take the integers, split them up and then get two things which are both isomorphic to the integers
13:41:26 <Cale> as sets, yeah
13:41:40 <franka> You don't need Choice for that...
13:41:51 <palomer> but it's still unintuitive
13:42:04 <franka> It's perfectly intuitive, if you know 2's complement.
13:42:24 <palomer> well, it's unintuitive as the sphere paradox
13:42:28 <mjl69_> do you mean like two sets with a one-to-one relationship?
13:42:32 <Cale> I think it's more unintuitive that you might take the infinite product of nonempty sets and end up with an empty one :)
13:43:04 <Cale> franka: also if you know about 'even' and 'odd' numbers :)
13:43:16 <franka> Cale: How does that work?
13:43:22 <Cale> franka: hm?
13:43:24 <Cale> which one?
13:43:35 <franka> About infinite product of nonempty sets.
13:43:40 <r3tex> most people that think things are unintuitive just haven't taken enough math courses
13:43:42 <Cale> oh, that's all that AoC says
13:43:51 <franka> Or is this an instance of Banach-Tarski?
13:43:53 <Cale> the infinite product of nonempty sets is nonempty
13:44:02 <Cale> that's the axiom of choice
13:44:19 <franka> Ah, OK.
13:44:38 <franka> I think of it as the absence of a constructive choice.
13:45:00 <mjl69_> whatever works
13:45:40 <franka> But when you put it that way it does sound counterintuitive.
13:45:55 <Cale> (for AoC to fail?)
13:46:24 <franka> No, I am agreeing with what you said about lack of Choice being unintuitive.
13:46:28 <Cale> yeah
13:46:47 <franka> But to me it seems symptomatic of infinite product being underdefined.
13:47:04 <Cale> Also, if the axiom of choice fails, you end up with bad things, like pairs of sets A and B for which there's no injection A -> B or B -> A either way.
13:47:06 <palomer> so...anyone have any papers discussing foundational dependent type theory?
13:47:51 <Cale> In fact, another formulation of the axiom of choice is that for every pair of sets A and B, there's an injection A -> B or an injection B -> A
13:48:33 <Cale> So when the axiom of choice fails, you end up with some interestingly shaped infinite sets which don't fit into one another.
13:49:06 <franka> Yeah, every epi has a section.
13:52:05 <franka> palomer: I only know the ones I mentioned before, which are books.
13:52:15 <palomer> you mentioned some before?
13:52:19 <palomer> which?
13:52:42 <franka> Bart Jacobs' "Categorical Type Theory and Logic" and Paul Taylor's "Practical Foundations of Mathematics".
13:53:39 <franka> Sorry, "Categorical Logic and Type Theory".
13:53:48 <Cale> actually, you don't even need the word "infinite" in AoC, since it will hold automatically for finite products
13:53:58 <palomer> are those easy to digest?
13:54:37 <franka> palomer: No.  Taylor builds up to it very slowly, as its a textbook.  Jacobs is difficult (for me) but more compartmentalized.
13:55:26 <franka> I'm sure there are some other treatments, though.
13:55:43 <stesch> neologism: Hmpf. The book is just called "Haskell" at Amazon. EUR 72.90 seems to be a bit too expensive for my taste, though.
13:56:47 <franka> Just looking through CiteSeer, here's one: http://citeseer.ist.psu.edu/480373.html
13:57:05 <franka> http://citeseer.ist.psu.edu/aczel98relating.html (Aczel)
13:57:13 <neologism> stesch: I Just know I read it and it was fine
13:57:22 <neologism> you dont have any univ. library around?
13:57:41 <stesch> neologism: I don't have any university around.
13:57:44 <franka> But I am not very familiar with the dependent types literature...
13:58:29 <neologism> where do you live?
14:00:18 <franka> More: http://citeseer.ist.psu.edu/birkedal00developing.html
14:00:42 <stesch> I'm no student. Is Haskell a student only language?
14:00:55 <CosmicRay> nope
14:01:05 <CosmicRay> plenty of us are doing non-academic haskell work.
14:01:18 <Cale> stesch: you don't have to be a student of course, though it helps to have that sort of mindset
14:01:35 <neologism> stesch: no.. but universities provide  ALOT of goodies for haskell ;)
14:02:06 <CosmicRay> jlouis: hey, didya get my patches for conjure?
14:02:28 <Cale> Yeah, there are lots of (unfortunately, depending on your perspective) copyrighted papers on Haskell with cool stuff in them.
14:02:41 <franka> palomer: This one is perfect: http://citeseer.ist.psu.edu/pitts01categorical.html
14:02:54 <adept> CosmicRay: ah! patches for conjure. From where I can pull them?
14:02:57 <Cale> there's also a lot of good freely available papers though
14:02:58 <adept> SamB: hi
14:03:08 <adept> @seen jlouis
14:03:09 <lambdabot> jlouis is in #haskell-blah and #haskell. I don't know when jlouis last
14:03:09 <lambdabot> spoke.
14:03:11 <CosmicRay> adept: I used darcs send to send them to jlouis.  Send me your e-mail address and I'll send them to you
14:03:20 <franka> I think I actually have Pitts' paper on my HD somewhere...
14:03:50 <palomer> franka: that's your favourite one?
14:03:58 * shapr wibbles
14:03:59 <adept> CosmicRay: sent in privmsg
14:04:01 * palomer just sent for an ILL, hoping they'll buy the book
14:04:01 <Cale> stesch: I recommend just starting out with YAHT, and coding some small things in Haskell as you learn it. Hanging around here is also a good way to absorb information :)
14:04:14 <franka> I think it's the most accessible.
14:04:20 <franka> I dunno the others, was just browsing under likely keywords.
14:04:34 <Cale> There's also a really great couple of mailing lists: Haskell and Haskell-cafe.
14:04:57 <CosmicRay> adept: email is on its way
14:04:58 <franka> But the rest are research papers, and Pitts' is an article from the Handbook of Logic in CS.
14:05:23 <Cale> stesch: If you're interested, you'll find those linked from http://haskell.org/mailinglist.html
14:05:28 <palomer> so, what's the best "cool" haskell book around?
14:05:37 <stesch> Cale: YAHT is too long.
14:05:46 <Cale> stesch: too long?
14:05:54 <Cale> There's a lot of material to cover
14:05:57 <franka> This looks promising too: "Syntax and Semantics of Dependent Types" (Hofmann) http://citeseer.ist.psu.edu/hofmann97syntax.html
14:06:20 <stesch> Cale: Sure. But I don't rad 190 pages on screen.
14:06:23 <CosmicRay> YAHT is actually pretty decent.
14:06:27 <stesch> s/rad/read/
14:06:41 <CosmicRay> I suggest Simon Thompson's book, Haskell: The Craft of Functional Programming
14:06:44 <Cale> stesch: read them while playing with an interactive environment like ghci :)
14:06:48 <CosmicRay> if you want a dead tree thing to read
14:07:04 <stesch> CosmicRay: EUR 73 at Amazon.
14:07:19 <adept> stesch: another approach is to write your own while playing with ghci
14:07:26 <Cale> Textbooks tend to cost quite a bit.
14:07:30 * adept seems to remeber that YAHT started that way
14:07:49 <CosmicRay> there is also the very, very preliminary and not really done haskell-v8
14:07:54 <CosmicRay> darcs get http://darcs.complete.org/haskell-v8
14:07:58 <gzl> haskell-v8?
14:08:01 <Cale> v8?
14:08:19 <CosmicRay> it's the project to write a new Haskell tutorial.
14:08:19 <palomer> CosmicRay: it's not at my library!
14:08:38 <gzl> just be thankful you don't have to buy Topological Groups by Pontryagin. it's USD 650+ at Amazon. :P
14:08:53 <neologism> topology sucks
14:09:00 <Cale> neologism: ?
14:09:07 <CosmicRay> I can send a PDF of the current draft of haskell-v8 to anyone that wants it
14:09:20 <fnord123> hi all
14:09:23 <neologism> Cale: I mean.. studying topology sucks :)
14:09:33 <Cale> gzl: What is it, an encyclopaedia?
14:09:37 <CosmicRay> to hack on it you should have a DocBook SGML environment installed.
14:09:55 * adept pull haskell-v8
14:09:58 <gzl> Cale: no. it's just a regular book on topological groups.
14:10:03 <gzl> it's a classic.
14:10:09 <palomer> hrm, anyone recommend another book other than craft of functional programming?
14:10:12 <gzl> I don't know why the moron publisher prices it so high.
14:10:17 <gzl> his Collected Works is over 750
14:10:23 <Cale> gzl: obviously it's working out for them
14:10:31 <gzl> maybe Pontryagin slept with the editor's wife
14:10:35 <Cale> or they'd have lowered the price
14:10:57 <gzl> I wonder about that.
14:11:09 <CosmicRay> adept: what do you think of those patches?
14:11:19 <adept> CosmicRay: patches to haskell-v8 are welcome?
14:11:25 <CosmicRay> adept: quite
14:11:26 <CosmicRay> adept: 
14:11:44 <CosmicRay> adept: I don't really have time to devote to haskell-v8 at this particular moment, but I am happy to apply any patches that fall my way
14:11:49 <adept> CosmicRay: haven't got yours yet. Seems to have trouble with my imap, going to pull them via web from gmail.
14:11:57 <CosmicRay> ah
14:12:27 <CosmicRay> adept: would you like me to send you a PDF of it so you can see what it is without installing the SGML environment?
14:13:05 <r3tex> I'm getting ERROR "libraries/blablabla/blabla.hs" - Can't find imported module "Control.Monad"
14:13:05 <r3tex>  when compiling hugs =(
14:13:17 <adept> CosmicRay: i think that I already have part of it (xmlto and friends). Is it hard to get going on debian/unstable?
14:13:17 <musasabi> /c/c
14:13:43 <CosmicRay> adept: oh, no, pretty easy.  see debianInstall.sh for a list of packages you'll need ;-)
14:14:09 <CosmicRay> adept: if you set up a public darcs repo for haskell-v8, please add yourself fo pullall.sh and darcs send that to me
14:14:32 <CosmicRay> s/fo/to/
14:14:46 <adept> CosmicRay: will do!
14:14:54 <CosmicRay> the command to build a pdf then is "scons pdf"
14:15:06 <CosmicRay> xpdf is a nice viewer as it will display the hierarchical Table of Contents on the left
14:15:48 <CosmicRay> adept: you may also want the package docbook-defguide, which is a guid/reference to DocBook.
14:16:10 <CosmicRay> it would be *great* to see some people jumping in and working on this project again.
14:16:34 <CosmicRay> adept: the basic idea is to make it accessible to imperitive programmers, and to include coverage of I/O from the very beginning.
14:16:57 <CosmicRay> Also, lots of examples to show people how to solve real problems with Haskell.
14:17:53 <adept> CosmicRay: i was thinking about "haskell cookbook" recently. What you describing seems to be a pretty close concept
14:18:14 <adept> CosmicRay: I've had some experience with DocBook, though i'ts over 3 years old
14:20:04 <humasect> CosmicRay, can you send the PDF to me as well?
14:20:30 <CosmicRay> humasect: sure, what's your email?
14:20:47 <adept> CosmicRay: will check it out tomorrow (00:20 here, plus i'll have wider channel for apt-get install than)
14:21:11 <adept> CosmicRay: ah. Got patches, they are cool. Thanks a lot!
14:21:19 <CosmicRay> adept: great (on both points).  Thanks!
14:21:45 * humasect @gmail.com
14:21:53 <xerox> blech.
14:22:23 <imix> how can I interpret this class? class AppendBits a b | b -> a where... (from http://www.haskell.org/hawiki/PacketClass)
14:22:38 <CosmicRay> humasect: sent
14:22:39 <humasect> also if anyone has seen, http://pleac.sourceforge.net/
14:22:49 <humasect> CosmicRay: thanks
14:23:09 <Cale> imix: well, look at the function provided
14:23:19 <Cale> b -> a means that b determines a uniquely
14:23:55 <Cale> the function that the class provides is  appendBits :: a -> a -> b
14:24:35 <Cale> which means, together with the fundep and the intention here, that b is twice the size of a in terms of bits :)
14:24:50 <TuringTest> imix: appendBits strictly doubles the length of the a to get b, so if you know type 'b' you can chop it in half to get 'a'.  So the 'b->a' tells the compiler there will only ever be a single instance of a given b
14:25:13 * adept is off to bed
14:25:37 <imix> got it, thanks
14:27:27 <imix> where would i find documentation for such things (tried different tutorials, hoogle, a reference without success)
14:28:39 <Cale> functional dependencies?
14:30:43 <Cale> you can find some mention of them in the GHC user's guide
14:30:51 <Cale> there are a few papers as well
14:30:52 <imix> maybe i should rephrase my question: Is there a complete syntax reference of haskell? I'm having a bit problems finding one (best success i had with hoogle)
14:31:17 <Cale> There's the Report, but functional dependencies are an extension
14:31:57 <Cale> As for documentation for various extensions to Haskell implemented in GHC... well the GHC User's Guide makes an attempt.
14:32:18 <Cale> Usually the papers that describe those extensions are better.
14:33:34 <Cale> Functional dependencies and multiparameter typeclasses are definitely worth learning. The rules are pretty simple (though the game is complex :).
14:33:46 <imix> makes learning a little tough, but i have to say, this channel is very helpful
14:34:08 <Cale> Basically, multiparameter typeclasses let you do the obvious thing -- having classes with multiple type parameters.
14:34:14 <imix> i will add them to my (growing) list of things to learn about haskell
14:34:33 <Cale> Functional dependencies, I can explain briefly :)
14:34:45 <greenrd> please do!
14:34:48 * xerox clears his ears
14:35:05 * TuringTest yawns
14:35:30 <Cale> a functional dependency is basically just a declaration that knowing certain sets of the type parameters will uniquely determine certain other sets of them
14:35:39 <Cale> usually these sets are of size 1 :)
14:35:48 <xerox> Well, yes.
14:36:00 <Cale> A functional dependency,  a -> b  reads as "a determines b"
14:36:03 <xerox> I still don't get how Oleg used them to do polyvariadic functions :)
14:36:40 <Cale> It tells type inference that if the type 'a' is known, it should be able to look up the type 'b' by searching for instances.
14:36:48 <TuringTest> xerox: That was 90% a different trick.  FunDeps were secondary.
14:37:08 <xerox> TuringTest: oh-uhm.  Could you elaborate on that, please?
14:37:09 <Cale> It also means that there's at most one instance of the class for any given type 'a'
14:37:54 <TuringTest> xerox: polyvaridic functions work because, unlike C,C++,and Java, the result type of the function can be used to decide which instance of the type class the compiler chooses.
14:38:15 <xerox> TuringTest: that's a good hint, thanks much.
14:38:37 <Cale> You're allowed to list that multiple things determine something or are determined by something, simply by listing the type parameters before and after the arrow with spaces.
14:38:42 <Cale> a b -> c
14:38:43 <TuringTest> xerox: ...and the typeclass can have itself as a constraint, so you have one base case and one recursive case.
14:38:56 <Cale> means that if you know a and b, then c can be determined
14:39:05 <Cale> a -> b c
14:39:17 <Cale> means that if you know a, then you know both b and c
14:39:33 <Cale> which is the same as a -> b, a -> c
14:39:54 <greenrd> that's nasty
14:39:56 <xerox> TuringTest: what do you mean by having 'itself as a constraint' ?
14:40:04 <Cale> greenrd: hm?
14:40:15 <greenrd> surely a -> b c should mean b is a type constructor, but the other one doesn't
14:40:30 <Cale> It can't be a type constructor
14:40:35 <TuringTest> xerox: "instance (Foo a) => Foo [a] where" defines a Foo instance with a Foo constraint.
14:40:37 <xerox> greenrd: it is used in another context then the one you think of, I think
14:40:40 <Cale> the only things allowed there are variables
14:40:50 <greenrd> well that's confusing syntax, that's all I can say
14:40:50 <xerox> TuringTest: Oh, yes, I know that one!
14:41:19 <Cale> it would occur like   class MyClass a b c | a -> b c where
14:41:28 <xerox> Let me load up the sensible code...
14:43:06 <lisppaste2> TuringTest pasted "polyvaridic" at http://paste.lisp.org/display/15037
14:43:26 <imix> makes sense to me (how about adding your explanations to the wiki?)
14:44:02 <lisppaste2> xerox annotated #15037 with "I was thinking of this one" at http://paste.lisp.org/display/15037#1
14:44:17 <Cale> http://www.haskell.org/hawiki/FunDeps
14:44:43 <imix> oh
14:45:08 <araujo> any parsec hacker around?
14:45:26 <TuringTest> xerox: That is the example from the paper.  To prove I understood it, I wrote what I posted, where I make a polyvaridic show function (which was my motivation) and a context sensitive scaled-sum function (because it illustrates a good point).
14:46:01 <xerox> I want to do something similar too :-)
14:47:53 <TuringTest> xerox: sL is "canShowList []" which is the build function, but only takes things that are Show instances.  It makes a list of them, then "pio" runs "map show" over them.
14:52:11 <xerox> Well, I'll think on that
14:52:17 <xerox> Kinda sleepy tonight.
14:52:25 <xerox> Thanks very, vert much, TuringTest.
14:55:43 <basti_> xerox: for the example of a bizarre fundep?
15:03:10 <humasect> PLEAC is good cookbook style
15:03:25 <Cale> Haskell PLEAC is bad Haskell style :)
15:03:55 <Cale> basically, if you look at that, you'll have no idea what ordinary Haskell code looks like
15:10:21 <humasect> aha
15:16:33 <Pupeno> is hGetBuf and hPutBuf the only way to read and write binary data to a handle (socket) ?
15:17:05 * basti_ cant answer that
15:25:29 <mjl69> so >>= is left associative?
15:26:16 <basti_> uhhhh
15:26:28 <Saulzar> Just looking at the strings page in PLEAC ... I've never seen this syntax in haskell "s5 = "bo beep".upcase" either that's perl code or pseudo-haskell?
15:27:04 <basti_> mjl69: i'm confused
15:30:59 <mjl69> I'm not totally sure either.  Or is it like + and * where it doesn't really matter which way you evaluate it?
15:31:22 <basti_> mjl69: oh yes. its "associative".
15:31:29 <basti_> i think that's one of the point of monads.
15:31:44 <basti_> but the parser associates it in a given way.
15:31:49 <basti_> and i think it associates right.
15:32:58 * basti_ should go to bed, but the album is so nice
15:33:29 <Pupeno> is there a higher level set of procedures to access binary data (one that doesn't require memory allocation by hand and so on ) ?
15:33:43 <basti_> Pupeno: Data.Bits?
15:34:12 <mjl69> The example of building sequences with lists and >>= is a great idea in MonadsAsConainers.  I'm going to play around with that for a while.
15:34:42 <Pupeno> basti_: no, thanks. That is not what I am looking for.
15:34:56 <basti_> Pupeno: what are you trying to do?
15:35:41 <Pupeno> basti_: read binary data from a socket (a handle) without having to allocate memory by hand and do C->Haskell conversions.
15:35:58 <basti_> "C->Haskell conversions"?
15:36:12 <basti_> you're looking for the FFI?
15:36:36 <Saulzar> I think he's trying to avoid it
15:36:45 <Pupeno> basti_: no, I am not looking for the FFI, I want to avoid it.
15:37:08 <basti_> so basically you're reading lots of "int" or something from the socket?
15:38:26 <Pupeno> basti_: no, there are mixed types of data.
15:38:32 <basti_> hmm
15:38:38 <humasect> c2hs
15:38:52 <basti_> there is this interface "Storable" or something.
15:38:56 <basti_> it might help you some
15:39:11 <Pupeno> the first 16 bits should be turned into an Integer, then I have a bunch of one bit booleans, etc.
15:39:20 <Pupeno> humasect: hello! is that for me ?
15:39:34 <humasect> yes. =) although i've never got it working for me
15:39:54 <humasect> or it was greencard, that has the translation step./
15:40:15 <Pupeno> humasect: what is c2hs ?
15:40:22 <basti_> Pupeno: c2hs and greencard are FFI simplifications, and you might want to use one, if you're going that way.
15:41:28 <Pupeno> I can't believe that I have to deal with FFI to read binary data, I've never seen something like that. There has to be another way.
15:41:52 <basti_> there are ways. but the way you're asking suggests that you'll complain about them being slow afterwards ^^
15:42:03 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#21
15:42:12 <Saulzar> Haskell types don't relate extremely well to packed C structs etc... 
15:42:30 <Saulzar> and that's essentially what you're dealing with
15:42:36 <xerox> Well, they do, if you specify a fair Storable instance.
15:42:49 <xerox> No?
15:42:52 <Pupeno> Cale: I've read that, that is what I am using.
15:42:53 <Saulzar> Well, they can be converted, yes :)
15:43:24 <xerox> Anyway, good marshalling!  Goodnight.
15:43:37 <basti_> good marshmallowing xerox .
15:46:25 <Pupeno> isn't there for example, a function that can read binary data untill EOF and return a Ptr (if nothing better) ?
15:47:17 <basti_> a Ptr?
15:48:15 <Pupeno> basti_: the same thing the only functions that read and write binary data return: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
15:49:13 <basti_> you mean, like FFI?
15:49:13 <basti_> ^^
15:49:54 <Pupeno> basti_: what do you mean by that ?
15:50:11 <basti_> Ptr is a thing that is only used in the Foreign Function Interface
15:50:12 <basti_> (the FFI)
15:50:19 <Cale> well, yes
15:50:26 <Cale> it's part of the FFI spec, so?
15:50:43 <Pupeno> basti_: no, Ptr is also used by hGetBuf and hPutBuf, the functions to read and write binary data.
15:50:44 <basti_> Cale: would you have a haskell function build a Ptr?
15:50:59 <Cale> Haskell 98 made no provisions at all for binary data.
15:51:04 <Pupeno> basti_: take a look at hGetBuf and hPutBufp
15:51:23 <basti_> Pupeno: besides pathological cases? ;)
15:51:52 <Cale> basti_: sure
15:51:58 <Pupeno> basti_: I am dealing with those pathological cases! since I am reading and writing binary data (dejavu!)
15:52:17 <basti_> I feel this debate is going in circles.
15:52:29 <Cale> this is a debate?
15:52:33 <Pupeno> basti_: indeed!
15:52:36 <basti_> more a conversation
15:54:44 <TuringTest> Pupeno: Have you read the wiki: http://haskell.org/hawiki/BinaryIo ?
15:55:06 <Pupeno> TuringTest: no, thanks for pointing it out.
15:56:05 <TuringTest> Also, I have a question.  Can I write type classes to define a function that will act as identity on a String, and show on all other Show instances?
15:56:36 <TuringTest> (I am willing to -f-allow-all-kinds-of-extensions)
15:57:18 <basti_> TuringTest: you mean like defining a different instance Show String?
15:57:20 <Pupeno> TuringTest: I like the functions defined there, like hGetWord8, are they defined anywhere ?
15:58:14 <TuringTest> Pupeno: No...that was a comment on the wiki requesting such a thing.
16:01:14 <TuringTest> Hmmm....seems I have stumped or bored the crowd.
16:01:42 * basti_ goes to bed
16:03:39 <franka> I would imagine with undecidable and overlapping instances, you can do it.
16:04:27 <franka> instance (Show a) => My Show a where myshow = show
16:04:42 <franka> instance MyShow String where show = id
16:04:49 <franka> But you don't want to do that.
16:05:10 <franka> er, where myshow = id
16:07:42 <TuringTest> That may work...
16:08:28 <Pupeno> How do I write the signature of a lambda expresion without using -fglasgow-exts ?
16:09:10 <Saulzar> Hm, what about using your own typeclass which uses Show as the default implementation?
16:09:20 <humasect> pupeno, i think that is the glasgow ext.
16:10:11 <Pupeno> humasect: -fglasgow-exts is the parameter that enambles the glasgow extensions on ghc and ghci, yes. My question remains the same.
16:10:21 <franka> Pupeno: You assign it a name.
16:10:37 <franka> let f :: a -> a = \x -> x in ...
16:10:38 <Pupeno> franka: there's no other way ?
16:10:58 <humasect> i am saying the let signatures are a glasgow extension.
16:11:07 <franka> Not if you use it at different polymorphic instances.
16:12:20 <franka> If it's monomorphic, you can write \x :: Int -> x
16:12:45 <franka> Or (\x -> x) :: Int -> Int
16:16:05 <lisppaste2> TuringTest pasted "myShow" at http://paste.lisp.org/display/15039
16:16:14 <TuringTest> That made it work.
16:16:38 <TuringTest> The output is:
16:16:39 <TuringTest> Hello World #[17,18,19]!
16:16:51 <TuringTest> With no quotes, or quoted quotes.
16:17:05 <TuringTest> It works for any number of arguments.
16:17:14 * franka didn't even know about incoherent-instances...!
16:17:37 * Saulzar looks around the channel for incoherent-instances :)
16:17:41 <TuringTest> If you poke at the type classes in ignorance, the error messages will mention it.
16:18:30 <TuringTest> I want an "-f-allow-whatever-I-need-to-compile-these-type-classes-and-instances" pragma
16:19:09 <Saulzar> -f-make-it-go!!
16:19:36 <TuringTest> I like my "swim" replacement for "show".
16:19:40 <TuringTest> I can go sleep now.
16:21:28 <TuringTest> I note that oleg can probably eliminate two or three of the -fallow flags, but I don't want to import half of HList to do it.
16:27:11 <Cale> Pupeno:  foo :: Integer -> Integer
16:27:16 <Cale> foo = \x -> x + 2
16:27:59 <Cale> well, in a lot of cases, you can explicitly type the results
16:28:25 <Cale> actually, in all cases, you can give a type to the function as a whole
16:28:35 <Cale> (\x -> x + 2) :: Integer -> Integer
16:29:20 <Cale> However, what you can't do is to give a name to the type of the lambda bound variable which scopes over the lambda term
16:32:19 <Cale> so if what you need is something like \(xs :: [a]) -> let ys :: [a]; ys = reverse xs in ys ++ xs
16:32:26 <Cale> then you can't do it without extensions
16:33:24 <Pupeno> How do I turn two Ptr into an Integer ?
16:33:45 <humasect> two? Ptr Ptr Integer?
16:33:47 <Cale> hm?
16:34:06 <Cale> @type Foreign.Ptr.minusPtr
16:34:07 <lambdabot> forall b a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b -> Int
16:34:09 <Pupeno> errr.
16:34:20 <Cale> like that?
16:34:36 <Pupeno> no.
16:34:42 * Pupeno changes the question.
16:35:02 <Pupeno> How do I turn the memory pointed by a Ptr into an Integer (or Int) ?
16:35:18 <Cale> @type Foreign.Ptr.castPtr
16:35:20 <lambdabot> forall b a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
16:35:24 <humasect> *ptr
16:35:46 * TuringTest thinks he needs a Peek function
16:35:54 <Cale> that casts the type pointed to arbitrarily
16:37:28 <Taral> @pl \f g x y -> f (g x) (g y)
16:37:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:37:31 <Taral> guh
16:38:15 <Cale> a paragon of clarity
16:38:39 <franka> That looks pornographic.
16:38:44 <sproingie> the nipple operator
16:39:12 <Taral> someone please add "sortWith f l = sortBy (\x y -> compare (f x) (f y)) l" in the standard library
16:39:44 <Cale> Taral: I usually define  comparing p x y = compare (p x) (p y)
16:40:03 <Taral> hm, that works too, but sortWith is lower-order :)
16:40:04 <Cale> sortBy (comparing snd) xs
16:40:18 <Cale> hm?
16:40:20 <Taral> @pl \p x y -> compare (p x) (p y)
16:40:21 <lambdabot> flip =<< (((.) . compare) .)
16:40:23 <Taral> heh
16:40:30 <Taral> not quite so nipply
16:40:51 <Taral> do you use "comparing" with anything else?
16:40:55 <Taral> or just sortBy?
16:41:21 <Cale> the other By functions mostly take compare-type functions too
16:41:46 <tennin> @pl \f g (x,y) -> (f x, g y)
16:41:47 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
16:41:58 <Taral> flip flip!
16:42:04 <Cale> insertBy, maximumBy, minimumBy
16:43:03 <skew> or, (***)
16:43:09 <TuringTest> @type \f g (x,y) -> (f x, g y)
16:43:10 <lambdabot> forall a b a1 b1. (a -> a1) -> (b -> b1) -> (a, b) -> (a1, b1)
16:43:22 <TuringTest> @djinn (a -> a1) -> (b -> b1) -> (a, b) -> (a1, b1)
16:43:23 <lambdabot> f a b (c, d) = (a c, b d)
16:43:33 <franka> Are the @pl's minimal??
16:43:36 <franka> -?
16:43:57 <TuringTest> @type flip flip
16:43:58 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
16:44:17 <franka> No, I see that; I am asking in general.
16:44:23 <TuringTest> @djinn b -> (a -> b -> c) -> a -> c
16:44:24 <lambdabot> f a b c = b c a
16:44:31 <TuringTest> I have no idea about @pl
16:44:40 <TuringTest> I don't particularly like @pl
16:44:53 <Cale> Sometimes @pl is good
16:44:53 <Saulzar> I guess it uses some heuristic, if you give it something gnarly enough it says "optimization paused"
16:45:23 <TuringTest> "flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)" is not good, however.
16:45:35 <Taral> @pl \a (b, c) -> (b, a:c)
16:45:36 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (:)
16:45:39 <Taral> gah
16:45:49 <Taral> @pl \a (b, c) ->(a:b, c)
16:45:50 <lambdabot> (`ap` snd) . (. fst) . ((,) .) . (:)
16:45:53 <Taral> heh
16:45:58 <Saulzar> Generally it does a good job at simplifying my (already pointless, but slightly verbose) expressions
16:46:06 <sproingie> it's flippping crazy :)
16:46:10 <Saulzar> Haha.
16:46:21 <TuringTest> Saulzar: That could be useful, I agree.
16:47:04 <skew> tennin: the Arrow instance for normal functions can be useful for stuff like that
16:47:13 <TuringTest> @pl \a b c -> b c a
16:47:14 <lambdabot> flip flip
16:47:18 <Taral> hrm, food time
16:47:20 <humasect> pupeno, i'm curious what you are developing. a server ?
16:47:20 <Cale> @type let f x = (x,x); f1 = f . f; f2 = f1 . f1; f3 = f2 . f2; f4 = f3 . f3 in f4
16:47:38 <lambdabot> type module failed: thread killed
16:47:45 <Pupeno> humasect: a library for developing different kind of servers, currently, DNS.
16:47:46 <Cale> @type let f x = (x,x); f1 = f . f; f2 = f1 . f1; f3 = f2 . f2 in f3
16:47:48 <lambdabot> forall a.
16:47:48 <lambdabot> -> ((((((((a, a), (a, a)), ((a, a), (a, a))),
16:47:48 <lambdabot>    (((a, a), (a, a)), ((a, a), (a, a)))),
16:47:48 <lambdabot> ((((a, a), (a, a)), ((a, a), (a, a))),
16:47:48 <lambdabot>    (((a, a), (a, a)), ((a, a), (a, a))))),
16:47:50 <lambdabot> [28 @more lines]
16:47:56 <TuringTest> Cale: You broke the matrix!
16:47:59 <Saulzar> Hah..
16:48:07 <humasect> pupeno, ok that would be very nice.
16:48:20 <tennin> skew: thanks, I'll look into it
16:49:05 <TuringTest> @type let f x = (x,x); f1 = f . f; f2 = f1 . f1; f3 = f2 . f2 in f.f3
16:49:07 <lambdabot> forall a.
16:49:07 <lambdabot> -> (((((((((a, a), (a, a)), ((a, a), (a, a))),
16:49:07 <lambdabot>    (((a, a), (a, a)), ((a, a), (a, a)))),
16:49:07 <lambdabot>    ((((a, a), (a, a)), ((a, a), (a, a))),
16:49:07 <lambdabot>    (((a, a), (a, a)), ((a, a), (a, a))))),
16:49:08 <lambdabot> [60 @more lines]
16:49:16 <TuringTest> @type let f x = (x,x); f1 = f . f; f2 = f1 . f1; f3 = f2 . f2 in f2.f3
16:49:18 <lambdabot> forall a.
16:49:18 <lambdabot> -> ((((((((((((a, a), (a, a)), ((a, a), (a, a))),
16:49:18 <lambdabot>     (((a, a), (a, a)), ((a, a), (a, a)))),
16:49:18 <lambdabot>     ((((a, a), (a, a)), ((a, a), (a, a))),
16:49:18 <lambdabot>     (((a, a), (a, a)), ((a, a), (a, a))))),
16:49:21 <lambdabot> [508 @more lines]
16:49:34 <Pupeno> humasect: thanks.
16:50:22 <Cale> good way to show that the type system can get out of hand even if types are decidable in theory
16:50:55 <humasect> pupeno, will it be open?
16:51:39 <TuringTest> "Decidable: Compiles", "Decidable:Error", "Undecidable aka OutOfMemory"
16:51:48 <Pupeno> humasect: it will be free, it is free http://software.pupeno.com/HaServers/ , not very usefull though (only Daytime is implemented).
16:52:18 <franka> Why should it be the case that you cannot write terms with big types?
16:52:30 <humasect> hm darcs, nice... i have a use for this.
16:52:41 <Cale> franka: well, you can of course. :)
16:53:30 <lisppaste2> TuringTest annotated #15039 with "Just show-what-I-mean" at http://paste.lisp.org/display/15039#1
16:53:55 <franka> That example also shows the value of type inference; with explicit typing, you would be forced to write that type yourself.
16:54:23 <TuringTest> And with that version of swim, I am really off to bed.
16:54:34 * TuringTest waves
16:54:41 <Cale> franka: :)
16:54:44 <franka> Bye, TuringTest.
16:56:47 <franka> (I was not joking.)
16:56:59 <franka> (Well, only half-.)
17:03:39 <Saulzar> Now find somewhere useful to use such a hideous type :)
17:05:35 <lennart> You can do anything with HM typechecking that a Turing machine with a finite tape can do.  So you can pretty much code anything you like as a type. :)
17:06:37 <stepcut> lennart: boring -- non-turing complete languages is where all the real fun is these days :p
17:07:34 <lennart> well, dang, and here I am stucking with a machine with finite memory.  guess i need to get a new one.
17:08:24 <Pupeno> musasabi: are you there ?
17:08:35 <musasabi> yes
17:09:24 <Pupeno> musasabi: hello, any recomendation in how to do binary io over a socket (both tcp and udp) before I start defining hGetWord8 and similar functions ?
17:10:09 <musasabi> Pupeno: what kind of binary - a given binary protocol or haskell datastructures.
17:10:25 <Pupeno> musasabi: a given binary protocol, DNS.
17:10:36 <musasabi> I think there are about a dozen libraries for binary serialization with new ones popping up and dying every few months.
17:11:26 <musasabi> You might like http://cs.helsinki.fi/u/ekarttun/haskell/DNS/ (that is quite old code, but has DNS parsing)
17:12:09 <Pupeno> that is why I ask, I've read http://haskell.org/hawiki/BinaryIo where there's a wish for something like what I need and a list of binary io libraries of which none may seem to do what I want.
17:15:01 <Pupeno> musasabi: any idea where Bufi comes from ?
17:18:32 <musasabi> Pupeno: I think http://www.cs.helsinki.fi/u/ekarttun/haskell/hdnsd-20051227.tar.bz2 is complete. (if it lacks something you can complain to me)
17:52:01 <carp> building ghc-api causes a panic for me :(
18:03:39 <Mitar> Is there any blog engine written in Haskell?
18:05:20 <sproingie> would be neat to see one
18:05:21 <CosmicRay> I think shapr may use one
18:05:24 <sproingie> using WASH and HaskellDB
18:05:35 <sproingie> could call it "Hails"
18:06:10 <Mitar> so there is none yet?
18:06:27 <CosmicRay> I said I think shapr may use one
18:06:32 <CosmicRay> scannedinavian.com or something
18:07:06 <araujo> any parsec hacker around?
18:08:03 * stepcut is a minor parsec hacker
18:09:30 <araujo> Thathelps :-)
18:09:59 <araujo> lisppaste2, help?
18:09:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:10:02 <sproingie> i love the t-shirt
18:10:03 <sproingie> http://www.scannedinavian.org/~shae/hm-t-shirt.png
18:10:25 <lisppaste2> araujo pasted "between '" at http://paste.lisp.org/display/15043
18:10:37 <araujo> stepcut, can you please take a look at it?
18:11:02 * stepcut takes a peek
18:11:36 <stepcut> despite the documentation manyTill does not work quite that way
18:11:57 <araujo> stepcut, you see what i am trying to do right?
18:12:12 <carp> anyone know if ghc-api failing to build on ghc-6.4.1 is a known problem? or have i broken something...
18:12:45 <araujo> stepcut, wanna get something like, "foo 'bar baz' foo1" = ("foo" , "bar baz" , "foo1")
18:12:57 <stepcut> manyTill will keep consuming anyChars even if the terminating case is found
18:13:00 <carp> seem to have managed to build the rest of hIDE except the HaskellSense plugin
18:13:34 <stepcut> araujo: let me ponder for a second
18:13:57 <araujo> stepcut, Sure.. yes, that's actually the problem i am trying to find my way around.
18:14:06 <araujo> It is happening some kind of overlapping.
18:14:13 <stepcut> araujo: do you want to worry about escaping like, 'bar\'baz' 
18:14:23 <araujo> stepcut, haha, gotcha, yes
18:14:34 <araujo> stepcut, _That's_ actually my problem
18:14:49 <araujo> stepcut, the \' gets overlapped 
18:16:37 <stepcut> hold on
18:17:39 <araujo> hah, ok :-]
18:18:10 <araujo> I think it is because of that anyChar is kind of agressive for what i wanna do.
18:18:45 <stepcut> it is more that manyTill does not even check the terminator until the anyChar fails
18:21:11 <araujo> Oh, i see.
18:22:49 <lisppaste2> stepcut annotated #15043 with "one possible parser" at http://paste.lisp.org/display/15043#1
18:23:24 <stepcut> that is probably closer to what you want -- it atleast parses this correctly,  "foo 'bar baz' foo1" = ("foo" , "bar baz" , "foo1")
18:24:27 <araujo> oh, nice, code, 
18:24:35 * araujo tests it
18:25:07 <stepcut> with only one test case, it's a bit hard to tell if I got it right ;)
18:27:58 <araujo> Ok, Good.
18:28:10 <lisppaste2> stepcut annotated #15043 with "using 'between' combinator" at http://paste.lisp.org/display/15043#2
18:28:33 <araujo> It seems working fine for the basic quotation hting.
18:28:36 * araujo checks
18:31:30 <stepcut> the trick with many of the combinators in parsec is that they are greedy, and will parses the longest possible string they can, even if they could convicibly match a shorter one
18:32:17 <stepcut> and since, anyChar will match anything, the parser will keep going until the end of input is reached
18:32:20 <araujo> stepcut, what is exactly the (many1 (noneOf ['\'']) in the between line for?
18:33:05 <stepcut> between takes three arguments, the starting parser, the ending parser, and the parser of things in the middle
18:33:32 <stepcut> many1 (noneOf ['\'']) will match the longest string of one or more characters that does not contain a '
18:34:26 <araujo> oh get it.
18:35:41 <stepcut> between (char '\'') (char '\'') (many1 anyChar) *won't* work, because it will not even check the (char '\'') until the (many1 anyChar) fails
18:36:49 <araujo> oh right, i see i see
18:37:16 <araujo> So that way, with the nonOf, you make sure that it checks the (char '\'') right?
18:37:21 <araujo> noneOf*
18:38:24 <araujo> stepcut, and yes.. i see the combinators are very greedy :-]
18:39:17 <stepcut> yes
18:39:59 <araujo> stepcut, Ok, i can see that, thanks
18:40:16 <araujo> stepcut, what if i want to do tricky things like 'bar\'foo' ?
18:40:57 <stepcut> araujo: then it is tricky :p
18:41:06 <araujo> I don't know if i am attacking this problem in the right way, but ive been trying to find sort of matching string case for "\'"
18:41:23 <CosmicRay> araujo: I have some examples of just this situation.
18:41:26 <CosmicRay> let me get you a url.
18:41:35 <araujo> CosmicRay, Please (Hi!) :-]
18:41:44 <CosmicRay> http://darcs.complete.org/hdbc-postgresql/Database/HDBC/PostgreSQL/Parser.hs
18:41:46 <CosmicRay> re ;-)
18:41:55 <araujo> Thanks!
18:41:56 <CosmicRay> look at the "literal" parser.
18:42:06 <CosmicRay> escapeseq = (try $ string "''") <|>
18:42:06 <CosmicRay>             (try $ string "\\'")
18:42:06 <CosmicRay> literal = do char '\''
18:42:06 <CosmicRay>              s <- many (escapeseq <|> (noneOf "'" >>= (\x -> return [x])))
18:42:06 <CosmicRay>              char '\''
18:42:07 <CosmicRay>              return $ "'" ++ (concat s) ++ "'"
18:42:52 <CosmicRay> In this particular instance, both \' and '' can serve to escape the ' character.
18:43:46 <stepcut> araujo: you can also try looking in the parsec code itself -- i think stringLiteral handles escaping
18:43:58 <CosmicRay> btw, I love how you can give people a plain URL into a darcs repo ;-)
18:44:05 <stepcut> CosmicRay: me too
18:44:20 <araujo> darcs++
18:44:28 <CosmicRay> araujo: does that help?
18:44:30 <stepcut> CosmicRay: and how you can do darcs get --partial
18:44:32 <araujo> CosmicRay, yeah, reading :-]
18:44:42 <araujo> yeah, i think this is it!
18:44:45 * araujo test
18:45:34 <stepcut> I wish I knew of a good tool for making a project webpage from darcs -- something what would generate tarballs, changelogs, rss, and a html webpage automatically when I do a release
18:45:45 <CosmicRay> stepcut: YES!
18:45:52 <CosmicRay> I have been pondering writing such a thing for months now.
18:45:58 <CosmicRay> the design is fairly straightforward.
18:46:03 <CosmicRay> problem is, that means the project is also boring.
18:46:04 <stepcut> I have libraries that I want to share, but I am too busy to bother making the webpages and stuff
18:46:24 <CosmicRay> trac is about 60% of the way there.
18:46:33 <araujo> hah goodie
18:46:39 <CosmicRay> araujo: <grin>
18:46:39 <stepcut> where is google summer of code when you need it
18:46:42 <araujo> CosmicRay, hah yeah, this seems working :-]
18:46:51 <CosmicRay> araujo: does it make sense to you *why* it's working? ;-)
18:46:57 * araujo now needs to tweak it to his code
18:47:18 <araujo> Ok, well, the only operator i am not so sure about what it is doing is $ 
18:47:30 <stepcut> CosmicRay: were you/are you playing with asterisk at all ?
18:47:32 <araujo> oh
18:47:34 <CosmicRay> stepcut: yes
18:47:36 <araujo> hah, i mean, escapseq
18:47:48 <CosmicRay> stepcut: been using it at home and we're going to deploy it at work next year
18:47:51 <stepcut> I have a nice start of a haskell AGI library if you ever want it 
18:47:57 <CosmicRay> stepcut: SWEET!
18:48:11 * araujo getting happy
18:48:17 <stepcut> CosmicRay: I would give you the link to the project page -- but I have not made it yet ;)
18:48:18 <araujo> Thanks CosmicRay stepcut 
18:48:29 <CosmicRay> araujo: well this will be a bit different from my example to most programs.  Most times, you are interested in *unescaping* things as you parse them.  Here, I'm interested in preserving the escape sequence verbatim.
18:48:39 <CosmicRay> stepcut: how about giving me the link to the darcs repo? ;-)
18:48:47 <stepcut> CosmicRay: i only implement 4 or 5 AGI commands, but that is because the rest have never been useful to me -- they are easy to add though
18:49:11 <CosmicRay> this week off has done wonders for my haskell coding ;-)
18:49:29 <CosmicRay> I'll probably roll my first HDBC tarballs tomorrow.
18:49:43 <stepcut> CosmicRay: okay, as soon as I put it in darcs I will send you the link
18:49:50 <CosmicRay> stepcut: excellent
18:50:17 <CosmicRay> honestly I haven't done anything in AGI yet because I couldn't be bothered to either mess with Perl or reimplement it in Haskell ;-)
18:50:25 <araujo> CosmicRay, oh, i see i see
18:50:46 <araujo> I am still getting used to this greedy features ;-)
18:50:48 <stepcut> I have a sample application where you can call up a phone line and calculate how the split the bill when taking two or more birthday guests out for lunch who want to treat each other, but not pay for themselves
18:51:09 <CosmicRay> heh, sweet
18:51:23 * CosmicRay points out http://darcs.complete.org/hdbc/doc/Database-HDBC.html for the API for the upcoming HDBC release.
18:51:25 <araujo> hah
18:51:31 <CosmicRay> I believe this makes it pretty much feature-complete with HSQL.
18:51:55 <stepcut> that happens a lot where I work :p I 'had' to use some computer algebra system to figure out the equation 
18:52:17 <stepcut> CosmicRay: do you have berkeley db4.4 interface ?
18:52:42 <CosmicRay> stepcut: well that's not a SQL database, so no, not with HDBC.  However, I do have a Sqlite3 interface, which is better.
18:52:53 <CosmicRay> stepcut: on the *db side, I have a module called AnyDBM in MissingH.
18:52:59 <stepcut> yeah, I saw that
18:53:08 <CosmicRay> stepcut: This is a generic interface to the *db databases similar to what Python has.
18:53:39 <stepcut> what makes sqlite3 better than bdb 4.4 ?
18:53:42 <CosmicRay> I don't have a direct AnyDBM binding for any C library, but Python does for several, and MissingPy will make them transparently visible in Haskell.
18:54:08 <CosmicRay> also I will shortly release hdbc-missingh which, among other things, will let you use any SQL database table as an AnyDBM backend.
18:54:45 <CosmicRay> stepcut: it is actually both smaller and faster than berkeley db
18:55:12 <stepcut> does it support replication ?
18:56:05 <CosmicRay> not afaik.
18:56:06 <CosmicRay> bdb does?
18:56:30 <stepcut> yes, atleast 4.4 does (which is the only version I am familiar with)
18:56:47 * araujo tweaking the code
18:56:54 <CosmicRay> huh, I wasn't aware of that.
18:56:55 <stepcut> you have a master and slaves, and if the master goes down they can elect a new master
18:57:05 <CosmicRay> interesting.  I had no idea that bdb had that feature.
18:57:11 <CosmicRay> usually I only see that in sql databases.
18:57:41 <stepcut> you have to provide some of the mechanisms to make it work, but they provide the tricky parts
18:57:54 <araujo> CosmicRay, escapeseq and noneOf is the light :-]
18:58:04 <CosmicRay> araujo: woohoo ;-)
18:58:08 <ForgeAus> gmmm
18:58:17 <stepcut> for example, they don't specify how the servers talk to each other -- it is up to use to decide if you want tcp/udp http, ssh, etc for moving the data around
18:59:05 <stepcut> which is nice in many respects. If you have a bunch of backplanes all in the same chasis, you can use a faster local protocol
18:59:23 <stepcut> they also have some discovery algorithm for figuring how the configuring of your database pool
18:59:28 <CosmicRay> stepcut: http://www.sqlite.org/cvstrac/wiki?p=SqliteCompetitors
18:59:48 <stepcut> the other theorectically neat thing is there db that uses xml as the backing store
19:01:14 <stepcut> some if you wanted to use sqlite instead of BDB you would just make two collumn tables with columns of type blob ?
19:01:37 <CosmicRay> well, for the AnyDBM backend, the tables would be of type TEXT
19:01:46 <CosmicRay> I don't yet support blobs in HDBC
19:01:51 <CosmicRay> s/tables/columns/
19:02:15 <Taral> Grr!
19:02:19 <Taral> STArray is biting
19:02:32 <Taral> sortWith f l = sortBy (\x y -> compare (f x) (f y)) l
19:02:34 <Taral> oops
19:02:37 <Taral>     No instances for (MArray (STArray s) [Int] (ST s1),
19:02:37 <Taral>                       MArray (STArray s) Bool (ST s1))
19:02:42 <Taral> why is this happening?
19:03:11 <CosmicRay> anyway, got to run for awhile...
19:03:56 <stepcut> I switched to BDB because I realized I almost never needed a relational database, and that I was just using sql for its storage, transaction, and replication abilities
19:05:02 <Lemmih> Taral: Using 'runSTArray'?
19:05:23 <Taral> No, I'm not.
19:05:29 <Taral> The array is temporary
19:05:58 <Lemmih> Taral: Got the code posted somewhere?
19:06:07 <Lemmih> *pasted
19:06:12 <Taral> er, no
19:06:13 <Taral> it's kinda long...
19:06:46 <Lemmih> How about just the function in question, then?
19:06:57 <Taral> Prelude Control.Monad.ST Data.Array.ST> runST (newArray (0,1) False >> return 1) 
19:07:03 <Taral> that fails with a similar problem
19:07:23 <Taral> Maybe I should just type-constrain newArray?
19:08:19 <Taral> looks like that works
19:08:20 <Taral> still annoying
19:09:01 <Taral> Prelude Control.Monad.ST Data.Array.ST> runST (newArray (0,1) False >> return 1) 
19:09:03 <Taral> oops
19:09:06 <Taral> damn clipboard
19:09:07 <Taral>     k <- newArray bnds False :: ST s (STArray s Int Bool)
19:14:05 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
19:14:05 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
19:14:05 --- names: list (clog_ triplah Taral Trixsey|Laptop _darius kpreid_ cjs ForgeAus Ashsong waltz mjl69_ sethk noclouds stesch conal tennin djw lisppaste2 Saulzar sylvan ex_nor SamB chucky xs mkhl jesse99 JohnMeacham pediddle luqui PupenoL eyck dcoutts__ Lokadin_ sproingie humasect AtnNn neurogeek carp Nioate_ Nomius takuan Pupeno ramkrsna mattam arguile eno-away jp-autark Zerthurd mauke nik_ integral jiing Korollary borism cmeme Cale kosmikus Wallbrak1r)
19:14:05 --- names: list (resiak frederik kala lambdabot Chilli boegel juhp araujo cbus dhpeterson ksandstr dany2k dons wolverian thedward spamsch Lokadin twb CLxyz kaol samx dcoutts Igloo gaal magagr wli_ ibid moonlite eivuokko tessier tromp_ palomer tic|school shapr gzl johs neologism lennart fatbrain Lemmih binary42 audreyt drbean stepcut cognominal tic svens_ ulfdoz kzm ValarQ Iome Lor flux__ ricebowl lispy cods C-Keen xerox SlowByte Spark skylan cathper_)
19:14:05 --- names: list (norpan WillKW rep tumm Heffalump shawn_ clog alch` Khisanth cooz seafood jlouis dcoutts_ sieni Matt-W earthy mornfall Ferret metaperl pejo emu kolmodin cpatrick gdsx tuomov kpk Azmo noj Lunar^ musasabi)
20:36:19 <Saulzar> Hmm, getting these data types right proves a tricky buisiness. I keep finding myself in the "butchering everything" mode
20:57:01 <Lemmih> Pupeno: There's NewBinary.
20:57:11 <Lemmih> @where NewBinary
20:57:12 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
20:58:18 <stepcut> whee!
20:58:42 <stepcut> NewBinary is *not* suitable for parsing random binary data
20:58:55 <stepcut> it does not deal with big endian vs little endian 
20:59:25 <stepcut> and it stores somethings in ways you would not expect, like Char is 4-bytes
20:59:32 <dons> it's easy enough to extend though.
20:59:38 <dons> I think it would be a good place to start
20:59:40 <stepcut> yes
21:00:11 <dons> then just add your own types (or newtypes) with their own custom instances
21:00:12 <stepcut> I would love to see it extended to support general purpose binary reading/writing
21:00:38 <dons> maybe I should look at what has been done in other typeful languages.. hmm
21:00:49 <araujo> dons, hi!
21:00:57 <dons> hey araujo
21:01:10 <araujo> dons, merry christmas btw!
21:01:15 <stepcut> Some parts of binary are a good start -- for example the bitwise reading/writing and the uniform interface to memory or binary files
21:01:40 <araujo> dons, wanna ask you something about hs-plugins ... Does it propagate its exceptions?
21:02:01 <dons> sure. they're just the same as any exceptions thrown in dynamically loaded code in ghci
21:02:12 <stepcut> the stuff with the currentry Binary class in it is better suited to serialization/deserialization of haskell values, but there is no reason someone could not extend it to support general purposed binary data structure parsing/writing
21:02:16 <dons> except ... ghc's rts does bad things with dynamically typed exeptions
21:02:34 <araujo> mmm
21:02:52 <araujo> dons, ive been tryinbg to catch eval exceptions with no luck.
21:03:24 <dons> eval exceptions? i.e. thrown in code that is the result of an eval()?
21:03:39 <araujo> yes.
21:03:50 <araujo> Is that possible?
21:05:15 <dons> I think so. I think I'm catching eval exceptions here:
21:05:20 <dons> > undefined :: ()
21:05:21 <lambdabot> Undefined
21:05:32 <dons> oh hmm. no that's no it.
21:05:42 <dons> that's post processing the output, after it's been thrown
21:05:46 <araujo> dons, im trying to catch something like:
21:05:51 <araujo> > (!! 2) []
21:05:52 <lambdabot> Add a type signature
21:05:56 <araujo> > (!! 2) [] :: Int
21:05:58 <lambdabot> Exception: Prelude.(!!): index too large
21:06:17 <dons> that is being caught, yes.
21:06:30 <dons> it catches the exception and adds "Exception :" ++ show e
21:06:48 <dons> DynExceptions won't work though (nor will they in ghci)
21:06:57 <dons> since the Typeable keys will be different
21:07:02 <araujo> Ok, but, is this exception being propagated?
21:07:06 <araujo> So i can catch it in my code.
21:07:18 <dons> it's being thrown in the eval code, and caugth in static code, yes.
21:07:28 <araujo> mm...
21:07:38 <dons> send me an example if you can't get it to work.
21:09:50 <Pupeno> What does boxed/unboxed mean ?
21:10:15 <dons> boxed values are ptrs to values allocated on the heap, unboxed values are raw machine values, basically.
21:10:23 <dons> boxed values are like Java Objects
21:10:56 <Ashsong> That's a good example: the point of boxed types is that they can be treated polymorphically because their "boxes" are all the same size.
21:11:14 <Ashsong> With unboxed types, you run into problems because they have different sizes.
21:11:51 <Ashsong> However, you pay for that extra layer of indirection when you're trying to do numerical computation.
21:12:11 <dons> luckily the compiler can do much unboxing on its own
21:12:32 <Cale> Another important point about the boxes is that they're part of the mechanism used to lazily compute values.
21:12:55 <Cale> The pointer is either a pointer to the result, or a pointer to code which computes the result.
21:13:34 <Pupeno> Cale: interesting.
21:15:22 <Ashsong_> Pupeno: Was your question adequately answered?
21:15:49 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html -- this will answer the question in more depth :)
21:16:08 <Pupeno> Ashsong_: yes, I think so.
21:16:17 <Pupeno> can anybody give me some hints about how to use NewBinary ?
21:17:04 <dons> there's a bit of an example on the hawiki page, iirc.
21:17:33 <Pupeno> lets see.
21:17:40 <dons> you define a type for the data you want to read as binary, and then write an instance of Binary for it.
21:17:56 <dons> examples of this are in lambdabot, hmp3, ghc, probably lots of other places. 
21:18:00 <dons> @google instance Binary
21:18:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/Binary.hs
21:18:03 <dons> heeh
21:18:04 <dons> !
21:19:44 * araujo points dons to the example
21:21:43 <stepcut> dons: for parsing binary data formats, do you think it would make sense to create newtypes like, newtype Word16le = Word16le Word16, newtype Word16be = Word16be Word16, and then implement instances of Binary for those types ?
21:22:15 <dons> that's how I was thinking, yes. though there's some other ways I guess
21:22:28 <stepcut> or would it be better to add new functions, like getLE getBE ?
21:22:59 <dons> joelr's picklers handle endianness with an Endian class, I wonder hwo that could be used.
21:23:18 <stepcut> I guess you could also use phantom types or something, like  class Binary endian a where ...
21:23:48 * Pupeno wishes to be working in a big endian computer.
21:24:15 <stepcut> It would be nice to combine NewBinary, joelr's pickles, and my new SerTH-like code into one glorious library but I don't have the time right now :-(
21:25:04 <stepcut> Pupeno: or maybe one of the dual-endian machines ?
21:25:47 <Pupeno> stepcut: yes, always running as big-endian of course ;)
21:25:49 <dons> araujo, did you get my reply? works for me
21:26:17 <araujo> dons, oh, no i didn't get it.. mm.. *are you registered*
21:26:23 <dons> eval "undefined :: ()" [] >>= \me -> case me of Nothing -> error "didn't type" ; Just (a::()) -> Control.Exception.evaluate a `Control.Exception.catch` (\e -> error "threw an exception")
21:26:49 <dons> the problem was that you're not unwrapping the Maybe
21:27:04 <dons> so the actual eval'd code isn't evaluated inside the catch
21:27:30 <dons> unwrap the Maybe with a case, then force it (with an evaluate, for example) and you can catch the exception as it's thrown
21:27:34 <dons> as the above code does.
21:29:08 <araujo> oh.. mm.. let's see
21:31:02 <dons> @type eval "undefined :: ()" [] >>= \me -> case me of Nothing -> error "didn't type" ; Just (a::()) -> Control.Exception.evaluate a `Control.Exception.catch` (\e -> error "threw an exception")
21:31:03 <lambdabot> Not in scope: `eval'
21:31:09 <dons> oh well :/
21:32:13 <araujo> ooh see it
21:32:16 <araujo> Thanks dons 
21:40:44 <Cale> araujo: how are you using eval in your program?
21:43:55 <Pupeno> what would be wrong in defining hGetWord8 in terms of peek p 1 where p :: Word8 and hGetWord16BE in terms of two hGetWord8 where I multiply one by 2^8 to sum it to the other (and hGetWord16LE the reverse) ?
21:45:04 <dons> sounds reasonable to do it in terms of hGetWord8
21:45:50 <Pupeno> would it be too slow or something ? (it definitly looks like something I can do now, modifing NewBinary doesn't).
21:46:46 <Cale> use Data.Bits.shift
21:47:41 <Pupeno> ok.
21:48:01 <Pupeno> and then or ?
21:48:03 <dons> yeah, look at all the other Data.Bits tricks in Binary.hs
21:53:12 <araujo> Cale, im using with a command line 
21:53:45 <dons> ah, like in h4sh?
21:53:56 <dons> for $ map 
21:54:05 <dons> sorry, map 'toLower' file
21:54:19 <araujo> dons, yes, 
21:56:08 <humasect> dons, thank you for yi.pdf and hs-plugins.pdf
21:56:19 <dons> sure :)
22:00:38 <dons> are you building something, humasect?
22:01:38 <humasect> yes. the view of an application with a central state and dynamic reload put things back in the right perspective for me
22:01:47 <humasect> in particular yi.pdf
22:03:42 <dons> oh, that's good :)
22:04:32 <dons> it's seems to be a good structure for largish apps doing a lot of imperative things, and needing dynamic update (or configuration)
22:04:49 <humasect> all this time i was doing things right. except my overuse of records in pattern match
22:05:28 <humasect> i haven't realised yet how come Yi has a static version as well. and how these can apply to ghci (i'm about to find out on this project)
22:06:57 <dons> the static version is useful on archs that don't have dynamic loading, and for people who don't wish to install hs-plugins
22:07:18 <humasect> ah
22:07:23 <dons> also, profiling binaries doesn't work if that binary contains dynamic components
22:07:32 <dons> so you need a statically linked version if you want to do profiling
22:07:35 <humasect> also i will have some ffi primitives in the "static core"
22:07:41 <dons> lamdbabot has the same issue with profiling.
22:07:50 <shapr> good morning #haskell!
22:07:52 <humasect> ahh, that is a shame
22:08:03 <dons> it's on my todo list though, humasect
22:08:07 <humasect> i wonder if that can be addressed with future evolutions of relateds
22:08:21 <humasect> ah, merry new year to that
22:08:30 <dons> heya shpar!!
22:08:37 <shapr> y0 dsno!
22:08:38 <dons> sphar!! pshar!!
22:08:56 <shapr> dson!! nods!!
22:09:25 <shapr> Wassup?
22:09:36 <shapr> Are you still on your eight days of vacation?
22:09:45 <humasect> how haskell programs are by default independant aside from state
22:09:52 <humasect> which is forced to be central
22:10:26 <dons> shapr, yep :)
22:10:48 <shapr> Spending time outside in the sun?
22:11:04 <dons> well, i got sunburnt playing volleyball. but it's fun!
22:11:22 <shapr> neat
22:11:47 <dons> nice and hot, cricket on the tv, yay for holidays :)
22:13:30 <shapr> Yeah, holidays are great. I got magnets for christmas!
22:13:44 <dons> cool! magnets! now you are magneto-shapr
22:14:34 <shapr> Yes, finally I have a magnetic personality!
22:14:49 <shapr> Did you do the gift swap thing down under?
22:15:23 <dons> gift swap? well, we give presents, and there's a semi-formal agreement that those you give to, should give you something back :)
22:15:33 <shapr> Did you get anything nifty?
22:15:47 <dons> i got an abacus, which can do cube roots and so on
22:15:51 <shapr> Cool!
22:16:15 <dons> it's got a nice treatise on the art of the abacus which i shall study
22:16:29 <shapr> That's something I'd like to learn.
22:16:43 <lisppaste2> Pupeno pasted "getInt8 and getInt16BE" at http://paste.lisp.org/display/15045
22:16:54 <shapr> I've learned how to drive a slide rule, and I'm learning how to do it in my head, but I want to learn the secrets of the abacus as well.
22:16:56 <Pupeno> Something like that seems to work.
22:17:21 <dons> shapr, oh! i have a slide rule, but havent' worked out its secrets yet
22:17:54 <shapr> Is there a slide rule generator online?
22:18:23 <shapr> For examlpe, can I configure my own order of scales and operations and generate a postscript file with the slide rule?
22:18:42 <Pupeno> What do you think about my getInt8 and getInt16BE ? I'd define hGetIntNN in terms of them.
22:19:28 * dons is off to the drinks fridge
22:20:21 <shapr> _darius: Hiya, how's life?
22:40:06 <_darius> hey shapr -- life is dvorakkeriffic
22:49:56 <shapr> _darius: cool!
22:50:29 <shapr> _darius: Written any Haskell code lately?
22:50:33 <shapr> Did you ever find a triple store?
22:50:57 <_darius> none at all, and no, i'm afraid i didn't look hard
22:59:26 <shapr> hoi boegel|home
23:11:58 <boegel|home> hey shapr 
23:14:59 <shapr> Wassup?
23:17:08 <boegel|home> shapr: busy, and a little bit sick :(
23:17:22 <boegel|home> and so is my gf, and she has to work from 8am until 9pm today :s
23:19:17 <shapr> sucks :-(
23:27:52 <boegel|home> yeah, it does big time
23:54:57 <C-Keen> re
