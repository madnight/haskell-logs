00:04:52 <araujo> geez... i thought it was earlier
00:07:55 <user317> so haskell doesnt have anything like ruby's gem does it?
00:11:15 <flux__> there's hackage, but I don't know how complete it is
00:11:28 <flux__> (or rather, I believe it to be rather incomplete)
00:16:30 <araujo> and.. what is it?
00:18:26 <user317> or does anyone have an ebuild for haskore :) that would be even better
00:19:06 <Taral> @pl a ++ b : c
00:19:06 <lambdabot> a ++ b : c
00:19:09 <Taral> @pl a ++ (b : c)
00:19:09 <lambdabot> a ++ b : c
00:24:10 <Lemmih> Hi Oejet.
00:24:28 <Oejet> Lemmih: Good morning. :-D
00:38:41 * Oejet is evaluating introductory programming reports and curses the grammar, spelling and writing skills of todays youth.
00:39:10 <flux__> @pl \a b c -> a ++ b : c
00:39:11 <lambdabot> (. (:)) . (.) . (++)
00:41:07 <flux__> @pl \b c -> a ++ b : c
00:41:08 <lambdabot> ((a ++) .) . (:)
00:41:13 <flux__> @pl \a c -> a ++ b : c
00:41:13 <lambdabot> (. (b :)) . (++)
00:41:17 <flux__> @pl \a b -> a ++ b : c
00:41:17 <lambdabot> (. (: c)) . (++)
00:42:42 <flux__> oejet, ITYM "today's", HTH!
00:42:46 <flux__> (or is that an idiom)
00:42:59 <flux__> ;)
00:43:36 <Oejet> flux__: Sorry, at least my English is better than their Danish.
00:44:53 <lispy> Oejet: what is your advice
00:45:06 <lispy> Oejet: your advice for those students
00:45:19 <lispy> take writing course?
00:46:02 <lispy> Oejet: my english was wrose than it is now(!!!) and i had a math professor that would mark up our grammar more than our proofs.  It was a huge help.
00:46:36 <lispy> he taught me that "but ... since" is not a valid grammatical construction in english
00:47:15 <lispy> i didn't believe him, so i looked it up and found out that because and since are synonyms
00:47:51 <lispy> anyway, my point is that because he consistently called us on grammatical mistakes over the course of several terms, i learned to make less mistakes
00:48:56 <Oejet> lispy: That's nice.  Writing _is_ important, since clear writing makes errors easier to find.
00:50:11 <Oejet> I think, I will advice them to take a writing course.
00:50:15 <lispy> Oejet: yes, writing is very important.  I suck at it.
00:50:19 <pengo> wow.. i know this isn't an ordinary programming channel now
00:51:00 <Oejet> lispy, are you a native English writer?
00:51:11 <lispy> Oejet: my advice (as you probably already guessed) is to suggest correct writings to the students.  Don't worry if they think you are a terrible professor for it.
00:51:28 <lispy> Oejet: yes, saddly english is my only language :(
00:51:56 <lispy> Oejet: although, i just got back from the bar, so my writing at this point may be worse than normal!
00:52:19 <Oejet> lispy: Hey, it's better to be called a terrible professor than a mediocre teaching assistant, right?  ;-)
00:52:35 <lispy> Oejet: definitely :)
00:53:20 <lispy> Oejet: i think, that the difference between a professor and a teaching assitant is that a professor can be harder on the students and get away with it :)  But being harder can be good for the students.
00:53:36 <Oejet> pengo: How so?  :-)
00:53:40 <pengo> but ... since makes sense in english, doesn't it? "i coded in haskell but still used curly brackets since i like how they remind me of C"
00:54:30 <lispy> pengo: nope
00:54:30 <pengo> Oejet: you talk about writing... in english.. actually talking of documentation or of self documenting code in a non-joking manner
00:55:00 <lispy> pengo: you inherintely have a run-on sentence there
00:55:21 <pengo> lispy, run on sentences are valid grammatically.
00:55:27 <lispy> hm...
00:55:31 <pengo> unless your name is MS Word
00:55:37 <lispy> hehe
00:55:46 <lispy> "MS Word is teh suck"
00:55:58 * lispy uses latex
00:56:16 * pengo uses notepad :/
00:56:39 <Oejet> pengo: Hopefully on Wine. ;-)  :-P
00:56:42 <lispy> or should i say \LaTeX2e
00:57:02 <pengo> i'm increasingly using gmail as a word processor (emailing to myself
00:57:20 <pengo> Oejet, i use linux when it likes all my peripherals.
00:57:48 <pengo> Oejet, and as i just got a new mouse, that might be right now
00:58:41 <pengo> windows beats linux at dealing with half-broken mice
00:59:14 <lispy> heh
00:59:17 <audreyt> @type List.nub
00:59:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:59:26 <Oejet> pengo: What programming languages do you like?
00:59:29 <lispy> yeah, most devices have windows drives at least
00:59:41 <pengo> Oejet, java, python, and increasingly haskell
01:00:24 <lispy> pengo: what do you like about python (i've never used it)
01:01:44 <pengo> lispy, nice simple clean syntax.. more or less cross platform.. dynamically typed, which is a nice change from java's everything-has-to-be-explicit typing
01:02:31 <lispy> pengo: okay, in that sense i can see why you like it.  Before I discovered haskell, i was pretty hardcore into lisp
01:03:15 <Taral> @pl (a ++ b) $ c
01:03:16 <lambdabot> (a ++ b) c
01:03:25 <Taral> @pl a ++ (b $ c)
01:03:25 <lambdabot> a ++ b c
01:03:29 <Taral> @pl a ++ (b $ c d)
01:03:29 <lambdabot> a ++ b (c d)
01:03:38 <Taral> @pl (a ++ b) $ c d
01:03:38 <lambdabot> a ++ b $ c d
01:03:41 <lispy> Taral: you're going to have to give a lambda to simplify it
01:03:46 <pengo> lispy, yeah i could never get into lisp.. i think it was the lack of a pattern book.. i could see the cool "features" of it, but i couldn't imagine using them on a day-to-day basis
01:03:50 <Taral> I'm just checking precedence
01:03:52 <lispy> @pl \a b c d -> (a ++ b) $ c d
01:03:52 <lambdabot> ((.) .) . (++)
01:04:09 <lispy> Taral: ah
01:04:27 <lispy> i tihnk that ((.) .) . (++) is a pretty cool definition :)
01:04:30 <Taral> heh
01:04:31 <lispy> cool but obtuse
01:04:36 <shapr> JohnMeacham: you called?
01:04:55 <lispy> pengo: well, CLOS is worth studying.  It's one of the few really object-oriented languages
01:04:57 <Taral> @pl a : (b ++ c)
01:04:58 <lambdabot> a : b ++ c
01:04:59 <lispy> shapr: hi
01:05:00 <Taral> @pl (a : b) ++ c
01:05:01 <lambdabot> (a : b) ++ c
01:05:05 <lispy> shapr: how's it going?
01:05:07 <shapr> hiya lispy, how's think?
01:05:18 <Taral> @pl (a : (b ++ (c : d))
01:05:19 <lambdabot> (line 1, column 20):
01:05:19 <lambdabot> unexpected end of input
01:05:19 <lambdabot> expecting variable, "(", operator, ":", "++" or ")"
01:05:21 <Taral> @pl (a : (b ++ (c : d)))
01:05:22 <lambdabot> a : b ++ c : d
01:05:27 <lispy> shapr: well, i'm taking a leave from school till i can get funding to start a different masters projec
01:05:47 <pengo> CLOS? hang on i haven't learnt haskell yet
01:05:49 <shapr> lispy: What was your previous project, and what will your next project be?
01:06:27 <lispy> shapr: previous project was related to HCI (not a field i'm interested in) and my new topic will be graphics and animation languages (with a functional bent)
01:06:30 <shapr> hiya pengo 
01:06:38 <pengo> hi shapr
01:06:38 <shapr> lispy: ooh, aardappel?
01:06:45 <lispy> shapr: sorry?
01:07:18 <shapr> lispy: graphical functional (aardappel) or functional graphics (dance) ?
01:07:42 <lispy> shapr: well, we're thinking about languages for describing 3d story telling
01:08:13 <pengo> lispy, have you considered sign language?
01:08:24 <lispy> no i haven't, what do you mean?
01:08:26 <shapr> Yeah, good point.
01:08:39 <twb`> pengo: the lisp community turns patterns into libraries, rather than books.
01:08:42 <shapr> ASL has some neat abstractions. I like the way it does pronouns.
01:09:10 <lispy> shapr: this is very interesting and i'll look into it and mention it to my research group
01:09:23 <pengo> lispy, sign languages are good at describing action in 3d.. look up the concept of "classifier" if you can
01:09:24 <lispy> so there is some structure to pronouns?
01:09:31 <pengo> twb`: good point
01:09:33 <lispy> sure thing
01:10:29 <lispy> hmm..
01:10:42 <shapr> The little bit of sign language I learned in Seattle had pronouns as angles away from the body of the storyteller.
01:10:48 <lispy> i just found a page showing 15 different classifiers in ASL
01:10:54 <shapr> oh, what's the url?
01:11:02 <lispy> http://www.jal.cc.il.us/ipp/Classifiers/
01:11:12 <pengo> he/she/you/it/me are just done by pointing
01:12:28 <shapr> So if a story had three subjects, you'd divide the 180° in front of you into three pieces, one for each person.
01:12:39 <shapr> Then you'd point in that direction to refer to that person.
01:13:00 <pengo> yeah that's one way
01:13:13 <shapr> I've thought of something vaguely similar for spoken programming where you turn pointless into pointful.
01:13:15 <pengo> or you have classifiers for each and treat them like hand puppets :)
01:13:16 <shapr> pengo: tell me more!
01:13:22 <shapr> oh that's cool.
01:13:40 <twb`> pengo: pointing won't work for distal objects.
01:13:49 <pengo> twb`: you use your imagination
01:13:50 <lispy> distal?
01:13:57 <twb`> lispy: things that are far away.
01:14:03 <lispy> ah
01:14:07 <pengo> you point to an imaginary person
01:14:19 <twb`> lispy: things that are nearby are called "proximal".
01:14:33 <lispy> well, i need to sign off for sleep, but these are good ideas and i'll leave my browse pointed at them
01:14:36 <shapr> Part of your personal space represents something.
01:14:44 <pengo> anyway i gotta get going.. nice chatting
01:14:50 <twb`> pengo: but what about "I want a bowl for fruit.  _It_ should be red."
01:14:54 <lispy> pengo: yeah, nice to meet you
01:14:56 <shapr> pengo: Nice to meet you, come back soon!
01:14:59 <twb`> pengo: bye.
01:15:10 <shapr> lispy: Good to see you too :-)
01:15:18 <lispy> shapr: thanks
01:15:23 * shapr bounces
01:15:26 <lispy> heh
01:15:35 <lispy> shapr: been keeping up on your uni?
01:15:37 <shapr> Oh dbremner pointed me to an alien message, that's nifty.
01:15:49 <shapr> lispy: Not so much, it's minus fifteen C around here lately.
01:15:50 <pengo> twb`: the grammar's different... perhaps you'd say "I want bowl, want fruit placed in, red".. i dunno.. i'm also talking Auslan (australian sign), ASL may be different
01:15:56 <lispy> shapr: ouch
01:16:16 <shapr> And there's very little sunlight.
01:16:16 <shapr> As we approach the solstice I approach zero energy.
01:16:17 <shapr> I swear I'm photosynthetic.
01:16:31 <pengo> but to do "it" there you could point to where you signed the "bowl" in front of you
01:17:01 <lispy> night all
01:17:05 <shapr> It sucks that each of .us .au and .uk have different sign languages.
01:17:06 <shapr> g'nite lispy
01:17:11 * shapr just woke up
01:17:20 <pengo> shapr, .uk and .au aren't really that different
01:17:25 <shapr> It's ten am here near the arctic circle.
01:17:35 <twb`> Is there a sign language which represents phonemes instead of morphemes?
01:17:42 <shapr> Are they as similar as the spoken language?
01:18:16 <twb`> shapr: hmm?
01:18:29 <pengo> twb`, spoken phonemes? no.. because the signers are deaf and dont know how to divide words into phonemes
01:18:38 <shapr> twb`: In my tiny experience, there was a, um, 'vocal' minority of deaf people who saw no need for speech/sound.
01:18:49 <pengo> twb`, actually i lie. .there's .. umm.. something i forget the name.. used for learning speech.. hang on
01:18:56 <twb`> Lexemes, then?
01:19:47 <twb`> For example, "food" would be f+oo+d, rather than a single morpheme "food".
01:20:18 <pengo> Cued Speech uses phonemes
01:20:32 <twb`> You could do consonants on one hand and vowels/diphthongs on the other, to speed it up :-)
01:20:51 <shapr> My hair stylist had deaf children, and they signed in their sleep. I thought that was especially cool.
01:20:52 <pengo> "Cued Speech is a manual system invented by Dr. R. Orin Cornett which, disambiguates spoken language at the level of the phoneme. It is a system of hand signals that allows people who are lipreading to differentiate between sounds that are impossible to tell apart using lipreading techniques alone." to quote wikipedia
01:21:02 <shapr> Like dvorak? :-)
01:21:10 <twb`> shapr: yeah.
01:21:18 <twb`> pengo: interesting.
01:21:21 <shapr> pengo: That's way cool.
01:21:30 <pengo> it's not too popular tho
01:21:44 <twb`> shapr: "stylist"?  You are female, then?
01:22:08 <pengo> ok i gotta go.. bye
01:22:09 <shapr> I know a few deaf programmers. One of the very best programmers I know is deaf.
01:22:16 <shapr> bye pengo 
01:22:26 <twb`> For some reason a lot of programmers I know have visual impairments, too.
01:22:40 <Saulzar> Staring at the screen is not good for your eyes
01:22:57 <shapr> I remember the first irc conversation I witnessed between one deaf and one blind programmer.
01:22:59 <twb`> Saulzar: no, not from that.
01:23:02 <shapr> Discussing elisp, no less...
01:23:02 <Saulzar> So it's probably not supprising :)
01:23:20 <shapr> twb`: I am male, though it's not terribly important on this channel.
01:23:45 <twb`> shapr: you must be pretty trendy, then :-)
01:23:52 <shapr> Shae is often a female name in the USA, but in my case, Shae is short for shapr.
01:24:03 <shapr> Because of the use of 'hair stylist'?
01:24:06 <twb`> Yeah.
01:24:25 <shapr> How did Humpty Dumpty put it... I just pay my words more?
01:24:29 <Taral> hmph
01:24:36 <Lemmih> The wonderful work of shapr's hair stylist: http://www.scannedinavian.com/images/need_haircut.jpg (:
01:24:36 <twb`> Eh?
01:24:38 <Taral> and we see the dangers of unsafePerform IO :(
01:24:39 <shapr> coi Taral .i ma nuzba
01:24:54 <twb`> Eek.
01:24:58 <Taral> hi shapr
01:25:04 <shapr> Lemmih: I hadn't been to my hair stylist in several years when that picture was taken :-)
01:25:42 <shapr> She was so good I swore I'd never go to another one...
01:25:44 <twb`> That's what a hair tie is for.
01:25:46 <shapr> Then I moved to another country.
01:25:50 <Saulzar> The hair-cut industry suffers as the number of programmers increase :)
01:26:40 <shapr> Last time I got a haircut was the last time I visited the states.
01:26:44 <twb`> Mine is just getting long enough to get stuck behind my back and cause problems when I lean forward.
01:27:23 <shapr> Luckily I have curly hair so it's not as long when dry. Even so, it's getting long enough to be irritating.
01:28:10 <shapr> twb`: Backpacks are a real problem then. I put on my backpack, turn my head, and yowch!
01:28:27 <twb`> Yeah, that too.
01:28:43 <shapr> Here is a more recent picture of me and my hair - http://www.scannedinavian.com/images/shae-sj.png
01:28:55 <timbod> Any mac users here? If so, which editor do you use for haskell?
01:29:07 <shapr> Taral: Cool code?
01:29:18 <shapr> I've heard that the Carbon gnumacs is good.
01:29:27 <shapr> @seen swiert
01:29:27 <lambdabot> I saw swiert leaving #haskell 8 days, 14 hours, 14 minutes and 40 seconds
01:29:27 <lambdabot> ago, and I have missed 3 days, 7 hours, 3 minutes and 39 seconds since
01:29:27 <lambdabot> then.
01:29:37 <shapr> @seen edwinb
01:29:37 <lambdabot> Last time I saw edwinb was when I left #gentoo-haskell, #haskell, #
01:29:37 <lambdabot> haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #scannedinavi
01:29:37 <lambdabot> an 16 days, 7 hours, 45 minutes and 23 seconds ago, and I have missed 7
01:29:37 <lambdabot> days, 3 hours, 44 minutes and 59 seconds since then.
01:29:47 <twb`> timbod: Emacs.
01:30:44 <timbod> twb`: fine, but I'm new to the osx world - which version?
01:31:13 <Taral> yay, stupid laziness bug fixed!
01:31:14 <twb`> timbod: plain ol' CVS Emacs.
01:31:20 <Taral> unsafePerformIO is evil.
01:31:35 <timbod> twb`: in a terminal?
01:31:55 <shapr> doi Taral .i ma pluka samselpla
01:32:11 <dons> shapr, http://www.cse.unsw.edu.au/~dons/images/yi-color.png  (only 1 year late ;)
01:32:36 <shapr> w00h00, there is no late for open source code.
01:32:57 <shapr> Oh hey, that means I'll be able to get rid of emacs! YES!
01:33:02 <dons> that is the right way to think :)
01:33:28 <dons> not yet. let me finish first.. a day or two. soon soon.
01:33:34 * dons hacks
01:33:45 <shapr> How about I start using it now and then I'll have good feedback?
01:33:57 <dons> well, I'll have to commit it first.
01:33:58 <shapr> Using the hIDE branch, or the original?
01:34:04 <shapr> ah, good point.
01:34:15 * shapr goes into delirium tremens
01:34:19 <dons> it's using the lexer from hide, with color code from hmp3
01:34:31 <dons> this is in the curses yi
01:34:33 <shapr> Spiffy, Lemmih's ghc-api?
01:34:46 <dons> nope. standalone lexer.x
01:35:05 <dons> (this is the bottom layer of colorisation in hIDe)
01:35:40 <shapr> Oh hey, on the subject of TTF non-monospace viewing of source code, geoff washburn was asking about a decent unicode font, and how to see that source code lined up without monospace.
01:36:11 <dons> hmm. i love monospace :)
01:36:40 <shapr> Last I investigated tengwar fonts, I heard about a way to composite TTF chars, do you know anything about that?
01:36:56 <shapr> I suspect that would give some ability to line up non monospaced TTF fonts.
01:37:00 <dons> it's an interesting problem. i don't know much on this issue. maybe (?) dcoutts does
01:37:42 <shapr> dcoutts: heippa hei
01:52:19 <twb`> shapr: I doubt you could do it in a terminal, unless you wrote the terminal.
01:52:46 <twb`> shapr: but for lining up variable-width fonts you should be able to just treat each character as being 1em wide.
01:58:16 * twb` looks up "떠난다" in his Korean textbook.
01:59:54 <astrolabe> I want to use parsec in a program, but it uses the 'forall' keyword.  I don't want to use that if it might not be compatable with future haskell compilers.  Is that a sensible attitude?  Can I get around the problem?
02:00:13 <twb`> *compatible
02:02:02 <twb`> The real question is: how likely is 'forall' to be included in the next standard?
02:02:48 <astrolabe> That is part of it.  Also, how easy is it to avoid use of the 'forall' part.
02:03:48 <lightstep> you usually can just elide it (and the name of the variable after it)
02:05:27 <twb`> lightstep: Presumably not in this case, since the packager hasn't already elided it.
02:11:46 <lightstep> the parsec docs at haskell.org/ghc/latest/html/libraries don't contain forall
02:15:57 <astrolabe> that link doesn't work for me.
02:16:22 <dons> astrolabe, forall isn't going to disappear anytime soon..
02:16:27 <astrolabe> the docs I'm looking at are http://www.cs.uu.nl/~daan/download/parsec/parsec.pdf
02:17:54 <lightstep> @type (+)
02:17:55 <lambdabot> forall a. (Num a) => a -> a -> a
02:18:10 <lightstep> lambdabot could've writter (Num a) => a -> a -> a
02:18:16 <lightstep> but it prefered to be clearer
02:18:51 <astrolabe> lightstep: if that is all there is to it, then it could have been left out.
02:19:12 <astrolabe> I suspect it's a language extension
02:19:25 <astrolabe> I can't tell if it is described here http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
02:19:47 <lightstep> i think you have to write an explicit forall in existential type (but i'm not sure about it), but you usually can choose
02:20:03 <lightstep> some people think that using forall is better documentation
02:26:26 <astrolabe> 'The module exports a single function (makeTokenParser) that returns a rather large record that contains all the lexical parse functions.  Unfortunately, some of those functions (like parens) are polymorphic which implies that we need to use the forall keyword to give their type signature inside the record'
02:27:26 <lightstep> which means it's not standard haskell anyway
02:27:47 <dons> it's not haskell98. but it's supported in all the compilers
02:27:49 <astrolabe> right.  not haskell 98.
02:28:45 <twb`> Where is it documented?
02:28:46 <astrolabe> I think people underestimate what a pain non-standard stuff is.  I don't want it breaking in 10 years time, when I can't remember anything about it.
02:29:01 <twb`> It must be specified by something if all the compilers support it.
02:30:09 <lightstep> why would you recompile the same code in 10 years from now?
02:30:38 <twb`> I'm amazed you expect the same program to be in use for 10 years.
02:31:13 <astrolabe> I use code I wrote 10 years ago.
02:31:13 <dons> it's a pretty uncontroversial extension. there are far weirder ones to worry about, and if parsec uses it, then I wouldn't worry too much.
02:31:25 <dons> probably the comment was written 10 years ago :)
02:31:29 <dons> when it was more controversial
02:32:30 <astrolabe> but I will need to use funny flags for the compiler.  I'm just not confident enough that nothing will change.
02:32:44 <dons> you sure you need funny flags?
02:33:04 <dons> and I guess all you mean is : -fglasgow-exts (in the case of ghc)
02:33:12 <dons> which everyone uses anyway
02:33:46 <lightstep> or you can use {-# OPTIONS_GHC -fglasgow-exts #-}
02:34:00 <lightstep> or whatever it is now
02:35:21 <astrolabe> blah!  well I guess I'm not going to be able to change it.
02:35:34 <dons> anyway, this is in parsec isn't it?/ not your code. so its up to the parsec author to deal with it
02:35:53 <astrolabe> dons: if you get an angry email in 10 years time, you'll know what it is ;)
02:36:07 <astrolabe> thanks for your help everyone.
02:36:14 * dons shakes head :)
02:36:25 * Oejet . o O ( Sometimes the obvious is the hardest to describe. )
02:36:41 <dons> and to think of some of the type-crazy extension-nutty hackery that goes on in this channel..
02:37:16 <astrolabe> well, it is nice to have the choice, sometimes you want to just use the standard with no hassle.
02:38:01 <genneth_> @seen shapr
02:38:02 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 1 hour and 19
02:38:02 <lambdabot> seconds ago.
02:38:50 <dons> astrolabe, yes. this is what haskell'06 will hopefully lead to.
02:39:05 <dons> so you won't have to worry about existentially quantified data constructors disappearing
02:39:22 <astrolabe> I would really apprechiate that
02:39:32 <neologism> How enterprises use functional languages, and why they don't
02:39:35 <neologism> where can I read this?
02:39:36 <dons> (btw, the slightly stressful comment in parsec has now been replaced in the src with just: (uses existentially quantified data constructors)
02:40:02 <astrolabe> src?
02:40:10 <twb`> src = source
02:40:19 <astrolabe> thanks
02:40:19 <dons> I'm reading the cvs version.
02:41:11 <astrolabe> thanks dons I'll read about the language extention.
02:41:53 <neologism> pls.. dont you know about the paper?
02:42:00 <dons> section 7.4.1.4 of ghc's user guide. but why worry? it's parsecs problem, not yours, isn't it?
02:42:06 <neologism> ah.. found it
02:43:12 <astrolabe> dons: In theory, but there is only one person you can rely on in life.
02:43:25 <astrolabe> thanks for the section no.
02:44:12 <astrolabe> also, it seems to be in my nature to get sidetracked.
02:50:32 <dons> @seen Lemmih
02:50:32 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 1 hour, 25 minutes
02:50:32 <lambdabot> and 56 seconds ago.
02:50:52 <dons> Lemmih, do you recall the semantics of Gtk.onInsertText, afterInsertText ?
02:51:34 <dons> what's the difference? is onInsertText actually run before the insert?
02:53:26 <timbod> in parsec, what's the cleanest way to read a line (ie any chars upto and including the first newline)?
02:55:02 <twb`> What about lines?
02:55:05 <twb`> @t lines
02:55:06 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
02:55:06 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
02:55:35 <twb`> @type lines
02:55:36 <lambdabot> String -> [String]
02:55:38 <shapr> genneth: you called?
02:55:42 <timbod> It's already embedded in another parser...
02:56:05 <timbod> Something like this looks ok: (manyTill anyChar newline)
02:57:43 <timbod> (that consumes but drops the newline, which is ok)
03:02:14 * timbod thinks parsec is the nicest parsing framework in the world
03:03:21 <lightstep> it misses a few class declarations (MonadState and such)
03:04:47 <timbod> lightstep: was that in response to my parsec enthusiasm?
03:05:05 <lightstep> yes (though i like it very much lots too)
03:05:14 <dons> fmapM is underutilised
03:05:18 <lightstep> and i like it, so i have to criticize it
03:05:28 <lightstep> dons, is that in FunctorM?
03:05:40 <dons> yep.
03:06:10 <lightstep> it there a haskellayman article about it?
03:06:51 <lightstep> it looks like something composed with a generalization of sequence
03:07:00 <lightstep> @type Monad.sequence
03:07:01 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:07:39 <timbod> lightstep: I don't understand in what way does parsec miss some class decs?
03:10:49 <lightstep> timbod, there is a MonadPlus instance for GenParser tok st, but there is no MonadState instance for GenParser tok
03:11:56 * timbod feels himself sinking out of his depth
03:12:16 <timbod> lightspeed, what does this mean in practice?
03:12:37 <timbod> (what would a MonadState instance let you do?)
03:12:40 <dons> you'd have to write your own instances
03:12:44 <Lemmih> dons: Yeah, it is.
03:13:13 <dons> Lemmih, ah, great. so onInsert is really beforeInsert :)
03:13:31 <dons> then that makes it much easier to hook in
03:13:40 <Lemmih> What are you working on?
03:14:18 <dons> I've (back)-ported the hIDE syn hl to ncurses yi: http://www.cse.unsw.edu.au/~dons/images/yi-color.png
03:14:38 <lightstep> timbod, instances let you write more generic code
03:14:41 <dons> after I finally worked out a nice way to compose colored fragments on the curses screen
03:15:08 <takuan> somebody here ever heard about fortress
03:16:17 <dons> that's just running the scanner over lines (as FastStrings) out of a yi FastBuffer 
03:16:35 <lightstep> takuan, some people here are readers and editors of LtU
03:17:09 <dons> none of the ghc-api stuff is used yet. just the standalone lexer out of HaskellSense
03:22:06 <timbod> Where in the standard libraries would I find a function to split a FilePath into (dir,filename)?
03:22:38 <Lemmih> There's no such function in the standard libraries.
03:23:09 <Lemmih> You need the FilePath library for that. http://scannedinavian.com/~lemmih/FilePath
03:24:10 <timbod> Lemmih  - thanks. I'm surprised to see it's not there when something as useful as createDirectoryIfMissing is there...
03:25:22 <timbod> Another library to depend on :-( Thank goodness for cabal, which makes it bearable.
03:25:25 <takuan> lightstep: ltu being?
03:25:45 <takuan> ah
03:25:48 <takuan> lambda the ultimate
03:56:44 <xerox> Oi.
04:05:24 <neologism> any prologer here?
04:06:07 <Lor> No doubt lots of people here know _something_ about prolog.
04:06:26 <Lor> I have taught a prolog course, but that doesn't mean that I'd know very much about it. :)
04:06:59 <neologism> lets say I have somethign like this:
04:07:00 <neologism> foo(a, b).
04:07:00 <neologism> foo(b, c).
04:07:00 <neologism> foo(c, d).
04:07:18 <neologism> how do I know the set of all values which connect to d via this foo/2 predicate?
04:07:25 <neologism> ie. [a,b,c]
04:08:36 <Lor> With bagof.
04:08:52 <neologism> how?
04:09:01 <neologism> - bagof(Z, foo(Z, d), B).
04:09:01 <neologism> Z = _G180
04:09:01 <neologism> B = [c] ;
04:09:21 <Lor> Not alone, of course. You need to define the transitive relation first
04:09:41 <neologism> can you show me how?
04:09:47 <neologism> I somewhat dont get it
04:09:49 <Lor> It's really a bit offtopic here.
04:09:55 <xerox> haskell-overflow?
04:10:06 <Lor> There's a #prolog, why don't you try there?
04:10:12 <neologism> I've tried
04:10:19 <neologism> and soory about being offtopic
04:10:25 <xerox> neologism: don't worry!
04:10:49 <neologism> so.. is anyone willing/able to help me?
04:11:21 <Lor> neologism, look up the definition of a transitive closure, and think of how to translate that to prolog.
04:11:26 <neologism> - bagof(Z, foo(Z, d), B).
04:11:26 <neologism> Z = _G180
04:11:26 <neologism> B = [c] ;
04:11:31 <neologism> sorry
04:11:42 <neologism> f(X, Y):-foo(X, Y1), foo(Y1, Y). is this the relation you talk baout?
04:12:37 <Lor> Not quite. That only accepts the cases where X is exactly two steps away from Y.
04:12:57 <neologism> yes.. but I dont know ohw to generalize it
04:13:20 <Lor> You need recursion.
04:14:16 <neologism> I am just thinking about it...
04:22:59 <neologism> I dont know how to return he result
04:23:39 <Lor> You don't "return" anything in prolog.
04:24:07 <neologism> I mean "return"
04:24:12 <neologism> ie. to get
04:24:20 <Lor> Well, right.
04:24:56 <neologism> f(X, Y):-foo(A, Y), append(A, X, X), f(B, A).
04:24:56 <neologism> f(X, _).
04:24:59 <Lor> The transitive closure of a relation R is a relation R' such that:
04:25:10 <Lor> if R(x,y) then R'(x,y)
04:25:27 <Lor> if R'(x,z) and R(z,y) then R'(x,y)
04:25:48 <Lor> ...the _smallest_ relation that satisfies these conditions, that is.
04:26:10 <neologism> I knwo what transitive closure is
04:26:16 <Lor> Right, now turn that to prolog.
04:27:22 <neologism> f(X, Y):-foo(A, Y), append(A, X, X), f(B, A).
04:27:22 <neologism> f(X, _).
04:27:25 <neologism> fuck...
04:27:33 <neologism> r(X, Y):-foo(X, Y).
04:27:33 <neologism> r(X, Z):-foo(X, Y), foo(Y, Z).
04:27:34 <neologism> this I mean
04:29:53 <Lor> Oh, for practical reasons, the second case in the above definition should better be expressed as:
04:30:03 <Lor> if R(x,z) and R'(z,y) then R'(x,y)
04:30:19 <neologism> what now? (in prolog I mean)
04:30:31 <Lor> neologism, you still don't have recursion
04:30:46 <neologism> yes.. because I dont understand what you want to tell me
04:32:31 <neologism> this
04:32:32 <neologism> f(X, Y):-foo(A, Y), f(B, A).
04:32:32 <neologism> f(X, _).
04:32:37 <neologism> satisfies the condition (I think)
04:32:40 <neologism> but doesnt return any result
04:32:53 <neologism> when I put there the append/3 clausule it doesnt work at all ;(
04:33:04 <Lor> Uh, what's the append for?
04:33:15 <Lor> I told you about bagof.
04:33:31 <Lor> The idea is that first you define the transitive relation as a plain relation, don't worry about lists at all.
04:33:44 <Lor> Then you use bagof to get all the answers as a single list.
04:34:04 <neologism> I dont bind the X to any variable
04:35:44 <Lor> Here's what my version returns:
04:35:57 <Lor> ?- r(X,d).
04:36:11 <romildo> Hi.
04:36:18 <Lor> X = c ;
04:36:18 <Lor> X = a ;
04:36:18 <Lor> X = b ;
04:36:18 <Lor> X = c ;
04:36:22 <Lor> No
04:36:30 <lightstep> is there bag->set?
04:36:41 <neologism> Lor: yes.. but thats just for 2 steps
04:36:44 <Lor> Yeah, there's setof as well, it removes duplicates.
04:36:46 <neologism> not arbitrary number of steps
04:37:02 <Lor> Your version currently only handles two steps.
04:37:08 <Lor> I told how to do an arbitrary amount.
04:37:17 <Lor> I.e. define a transitive closure.
04:38:06 <neologism> and?
04:38:10 <romildo> The link for the hsparser (a Haskell parser written using Happy) in the happy docs is dead (http://www.pms.informatik.uni-muenchen.de/mitarbeiter/panne/haskell_libs/hsparser.html). Does anybody knows where is the hsparser home page nowadays?
04:38:24 <neologism> transitive closure is what you defined - and thats for 2 steps
04:38:30 <neologism> I dont see the step to make it general
04:39:40 <chrisbrown> morning all
04:40:06 <chrisbrown> has anyone used DrIFT?
04:41:45 <romildo> The HParser link found at http://haskell.org/libraries/ is also dead.
04:48:27 <shapr> What sort of haskell parser do you need?
04:48:57 <shapr> I think there's one in HsColour. I know there's one in the ghc-api that works with hIDE.
04:51:55 <psi> dons!
04:51:58 <psi> hmp3 works now
04:52:27 <psi> SamB's patch must've fixed it (which means that the bug was related to ghci not working)
04:52:38 <romildo> I am going to write a compiler of SystemCT (http://www2.dcc.ufmg.br/~camarao/CT/) to Haskell. The syntax of the input language is Haskell without any reference to type classes, plus "overload" and "assume". So I am looking for existing Haskell parsers trying to find someting to base my work on.
04:53:08 <psi> @localtime dons
04:53:10 <lambdabot> Local time for dons is Sat Dec 10 23:47:53 2005
04:54:13 <Lemmih> @docs Language.Haskell.Parser
04:54:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Parser.html
04:54:55 <shapr> If overload and assume can be expanded into Haskell code you could write a preprocessor and call that.
04:55:00 <Lemmih> @where hsx
04:55:00 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
04:59:15 <Saulzar> Hmm, Yampa looks tricky with getting any values out of it - but provides IO, it seems sneaky to use IO to get the state out directly.
05:02:04 <romildo> SystemCT has a type system with, as we believe, a nicer overloading strategie, with infered types for overloaded symbols. No need of type declarations for them. Except for external symbols (from other modules), for which the assume keyword is used to inform its type.
05:04:40 <romildo> So, in SystemCT we abolish type classes and instances from Haskell. My project is to implement SystemCT by translating to Haskell.
05:06:15 <Saulzar> What is the benefit?
05:08:56 <romildo> The language has a much simpler approach to overloading than Haskell. It should be easier for the programmer.
05:10:21 <romildo> Given the complexity of the implementation of Haskell-like languages, the first implementation of SystemCT will just generate Haskell code that could then be compiled with a Haskell compiler.
05:13:05 <Lemmih> Modifying the haskell-src parser should be relatively easy.
05:14:18 <joelr1> @type fold1
05:14:19 <lambdabot> Not in scope: `fold1'
05:14:29 <joelr1> good afternoon
05:14:29 <benny> does ghc ever generate code that modifies itself, or generates additional code?
05:15:07 <Saulzar> It sometimes generates binary code when I run my source code through it :)
05:15:23 <Lemmih> benny: The latter.
05:16:03 <joelr1> assuming i had data Foo = Foo | Bar and a list [m Foo], how do i run through this list until Bar is returned?
05:16:08 <joelr1> or while Foo is returned
05:16:39 <Saulzar> takeWhile ?
05:17:16 <ndm> joelr1, sequence, then takeWhile
05:17:31 <joelr1> @type sequence
05:17:32 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
05:17:33 <ndm> although i think that will be strict in all the elements
05:17:52 <joelr1> but i do not want to eval all elements
05:18:09 <joelr1> i could do this recursively of course, that would be easy
05:18:39 <joelr1> it's like do { result = action } until result == Bar
05:19:04 <Lemmih> joelr1: Does Bar indicate success and Foo failure?
05:19:19 <joelr1> Lemmih: yes, it's more like Stop and Go
05:19:29 <joelr1> where Go means keep going and Stop means stop evaluating the list
05:19:30 <astrolabe> that only works if Foo is an instance of Eq
05:19:45 <Saulzar> Maybe the Maybe monad would be useful
05:19:50 <Lemmih> > foldr Control.Monad.mplus Control.Monad.mzero [Nothing, Just 10,undefined]
05:19:52 <lambdabot> Just 10
05:20:17 <joelr1> the type looks like 
05:20:17 <joelr1> data Status a
05:20:17 <joelr1>     = Start
05:20:17 <joelr1>     | Stop (Maybe (Event a))
05:20:17 <joelr1>     | Skip
05:20:30 <joelr1> Lemmih: it's not Nothing/Just
05:20:36 <joelr1> i suppose i would need to convert it into that somehow
05:20:49 <joelr1> how would i do that?
05:20:50 <Lemmih> joelr1: You can model success/failure directly in the monad with MonadPlus.
05:21:04 <astrolabe> I would use recursion with pattern matching
05:21:11 * astrolabe is a beginner
05:21:27 * joelr1 is trying to advance :-)
05:21:30 <xerox> Hi.
05:21:35 <Lemmih> Hiya xerox.
05:21:47 <xerox> What's 'that' ? :-)
05:22:00 <Lemmih> @type foldr Control.Monad.mplus Control.Monad.mzero
05:22:00 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => [m a] -> m
05:22:00 <lambdabot> a
05:22:04 <joelr1> Lemmih: i want to do that but how do i convert my Status into a Maybe for use with MonadPlus?
05:22:11 <xerox> @type sequence
05:22:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
05:22:14 <xerox> :-)
05:22:29 <Lemmih> joelr1: Maybe is just one of the many monads which are members of MonadPlus.
05:22:44 <Saulzar> joelr1, I think he's trying to say you could just make your datatype an instance 
05:22:55 <joelr1> hmm
05:23:05 <xerox> > sequence (fmap (Just) [1..3])
05:23:06 <lambdabot> Just [1,2,3]
05:23:26 <xerox> > sequence ((fmap (Just) [1..3]) ++ [Nothing])
05:23:27 <lambdabot> Nothing
05:23:50 <joelr1> make my data type an instance of MonadPlus ... hmm
05:24:36 <xerox> > sequence (fmap (Left) [1..3] ++ [Right 4])
05:24:37 <lambdabot>  add an instance declaration for (Monad (Either a))
05:24:37 <lambdabot>   In the definition of `dyb':
05:24:37 <lambdabot>    dyb = sequence ((fmap (Left) ([1 .. 3])) ++ [Right 4])
05:24:43 <xerox> Woops.
05:24:47 <xerox> Error Monad?
05:24:53 <tennin> I read some monad tutorials and even books on category theory, and think I understand monads pretty well conceptually, but I'm having a really, really hard time actually doing monadic programming
05:25:08 <joelr1> allright, MonadPlus it is
05:25:09 <joelr1> thanks
05:25:42 <astrolabe> tennin: do you mean using standard monads, or writing your own?
05:25:55 <tennin> writing my own
05:26:26 <astrolabe> tennin: what do you want to do with them?
05:26:32 <xerox> @google All About Monads
05:26:33 <lambdabot> http://www.nomaware.com/monads/html/
05:26:38 <tennin> haha, I read that one
05:26:56 <xerox> :-D
05:27:21 <xerox> I never read it completely.
05:27:38 <tennin> it's pretty good, although I question the totally contrived and confusing example they give for the continuation monad
05:27:58 <Saulzar> I keep reading it and getting a little further each time
05:28:25 <tennin> the author seemed to want to drive home his warning about the hazards of continuations =\
05:28:46 <xerox> What hazards?
05:29:10 <Saulzar> At the start he warns that use of continuations may make unreadable code
05:29:19 <Saulzar> If used unwisely
05:32:56 <dcoutts> shapr, dons, I think lining up non-monospaced fonts to look good in source code would be rather difficult. Pango probably will not help you.
05:33:33 <tennin> astro, for now this is a self-imposed exercise and not a real project, but I'm trying to implement an imperative command language, and use a monad for the command environment
05:34:17 <dcoutts> shapr, dons, I don't think Pango provides an api to adjust the space between glyphs so that you could get a non-monospace font to line up right. Eg to use a unicode arrow rather than the two chars "->".
05:34:31 <tennin> there are various resources that may or may not be available in a given environment, and each command should only depend on the resources it actually needs
05:35:44 <musasabi> Are the resources statically enforceable or dynamical?
05:37:35 <Lemmih> How do you build the GHC library with profiling enabled?
05:38:05 <xerox> What will be the next craziest question?
05:38:34 <tennin> I'm not actually implementing dynamic allocation, but I'd like it to be possible in principle to implement it in the environment itself
05:39:53 <tennin> like I said, it's just an exercise for me, but I want to think through the implications of each decision, and that's very difficult for me
05:41:57 <xerox> Hello, {twb,joelr1}!
05:42:03 <joelr1> folks, how do i make my "status" class an instance of MonadPlus?
05:42:08 <joelr1> data Status a
05:42:09 <joelr1>     = Start
05:42:09 <joelr1>     | Stop (Maybe (Event a))
05:42:09 <joelr1>     | Skip
05:42:09 <joelr1>     deriving Show
05:42:17 <Lemmih> You don't.
05:42:22 <joelr1> hmm
05:42:30 <joelr1> Saulzar said i should
05:42:33 <dcoutts> Lemmih, is it you who maintains haskell-src-exts ?
05:42:59 <joelr1> i want to foldr over a list of [m Status] until Stop is returned
05:42:59 <Lemmih> dcoutts: Nope. Niklas Broberg is.
05:43:07 <dcoutts> Lemmih, oh ok. Ta.
05:43:27 <Lemmih> joelr1: Only monads can be instances of MonadPlus.
05:43:30 <musasabi> btw what is the crucial difference between MonadPlus and Monoid ?
05:43:44 <musasabi> joelr1: why not Monoid?
05:44:00 <joelr1> i suppose i could iterate a lambda that takes Status and returns either Nothing or Just
05:44:09 <joelr1> musasabi: don't know the difference, not that advanced yet
05:44:53 <joelr1> actually, that would be foldl i think
05:44:53 <Cale> morning
05:45:00 <xerox> Howdy, Cale!
05:45:23 <joelr1> status <- foldl mplus mzero [x event | x <- dispatchers]
05:45:26 <joelr1> this is what i want to do
05:45:43 <joelr1> where dispatcher :: Event -> m Status
05:45:49 <Cale> http://vx.hn.org/autoshare/folds.png -- have you seen my diagram? :)
05:46:01 <musasabi> joelr1: and m is?
05:46:04 <joelr1> Cale: nope. thanks
05:46:09 <joelr1> musasabi: a monad, obviously :D
05:46:09 <Cale> (not that I know what you're referring to at the moment, I just woke up :)
05:46:18 <musasabi> joelr1: a MonadPlus hopefully.
05:46:27 * Cale looks for coffee
05:46:55 <tennin> so the results of a command are expressed as a function from resources to environmental actions -- where actions are things like "Quit" or "AddValue x" which must be processed by the environment -- bundled with the names of the resources used as the function's import, which must be retrieved by the environment
05:47:04 <joelr1> musasabi: yes, but... i don't want to use the failure of THAT monad
05:47:07 <tennin> is mplus commutative?
05:47:23 <joelr1> musasabi: dispatchers should really be in a monad of their own or something
05:47:24 <Cale> tennin: only in some monads
05:47:49 <musasabi> joelr1: I fail to see how you want to make Status a monoid.
05:47:53 <Cale> tennin: it's usually a monoid operation
05:48:11 <joelr1> musasabi: did i say i want to?
05:48:13 <tennin> i.e.  CmdResult {rscList :: [ResourceTag],  envCmd :: [Resource] -> (a, [EnvAction]}
05:48:19 <joelr1> all i want to do is this
05:48:19 <joelr1> http://vx.hn.org/autoshare/folds.png
05:48:21 <joelr1> err
05:48:28 <joelr1> status <- foldl mplus mzero [x event | x <- dispatchers]
05:48:29 <Cale> tennin: or are you referring to just joelr1's monad?
05:48:35 <tennin> is this a reasonable way of implementing a command environment?
05:48:38 <Lemmih> joelr1: It might be easiest to do it the explicit way.
05:48:41 <xerox> joelr1: are you using _both_ a datatype _and_ a Monad to express failure/success ?
05:48:59 <tennin> cale, sorry, I meant mplus in general
05:49:00 <joelr1> xerox: right. in this case
05:49:20 <joelr1> dispatchers are within another monad since they can update state, etc.
05:49:23 <joelr1> and fail too
05:49:29 <Cale> tennin: good examples where it's not are the List monad and the Maybe monad
05:49:44 <joelr1> but in this particular fold i just want to go through the list of dispatchers while they return Skip and stop when they return Stop
05:49:57 <xerox> joelr1: usually, to me, it seems that I have to rethink the approach when it happens.
05:49:59 <joelr1> i can do it recursively but i was wondering if there was a more elegant way of doing this
05:50:10 <joelr1> xerox: no need, thanks :D
05:50:10 <tennin> ah, right
05:50:43 <joelr1> xerox: it's gonna take me too long to rethink the approach
05:50:47 <xerox> Don't scream then :-\
05:51:12 <joelr1> the easiest solution here seems to iterate a wrapper around status
05:51:31 <joelr1> where status is converted to Maybe 
05:51:41 <joelr1> then i don't need to change anything 
05:51:49 <joelr1> but a wrapper seems like a bit of a klugdge
05:52:55 <joelr1> wrapper :: Status a -> Maybe (Status a)
05:52:55 <joelr1> status <- foldl mplus mzero [wrapper $ x event | x <- dispatchers]
05:57:54 <Lemmih> Going from 'm a' to 'Maybe a' will make such as strict as with 'sequence'.
05:58:07 <joelr1> hmm
05:59:34 <Lemmih> You could write a 'statusPlus :: m (Status a) -> m (Status a) -> m (Status a)' and use that instead of 'mplus'.
05:59:56 <joelr1> hmm
06:00:09 <joelr1> then i should probably write the mzero also :)
06:01:50 <Cale> joelr1: incorporating nondeterminism?
06:02:04 <joelr1> Cale: no, a very simple task
06:03:46 <lisppaste2> joelr1 pasted "simple task" at http://paste.lisp.org/display/14502
06:03:59 <joelr1> except of course i cannot do it this way
06:04:48 <Cale> hmm... you want to make Status a Monad?
06:05:06 <joelr1> Cale: dunno, should i? it seems like it would be a good way to go, no?
06:05:09 * xerox waves his 'I told you' banner.
06:05:22 <Cale> quite possibly -- what would return x do?
06:05:35 <Cale> Is there a natural candidate from the Event type?
06:05:57 <lisppaste2> joelr1 annotated #14502 with "what would x do" at http://paste.lisp.org/display/14502#1
06:06:16 <Cale> not that x
06:06:22 <Cale> er, hmm
06:06:34 <joelr1> Cale: i have a list of dispatchers, i want to feed each of them the event and keep going until dispatchers tell me to stop
06:06:40 <joelr1> or i run out of dispatchers
06:07:16 <Cale> you have  data Status a = Start | Skip | Stop (Maybe (Event a)), if you make this type a Monad, then  return :: a -> Status a
06:07:18 <joelr1> each dispatcher can return either Stop (Maybe Event a) or something else (preferrably Skip)
06:07:38 <Lemmih> I really doubt you want Status to be a Monad.
06:07:53 * joelr1 is listening carefully
06:08:06 <Cale> Well, it wouldn't be too unlike the Maybe monad
06:08:19 <joelr1> to me it looks very much like a Maybe monad
06:08:45 <joelr1> Stop = Just
06:08:54 <joelr1> anything else = Nothing
06:09:04 <Cale> not quite
06:09:12 <Cale> Stop . something = Just
06:09:36 <Cale> Stop . Just . something, more accurately
06:09:43 <joelr1> Stop (Maybe (Event a)) = Just (Maybe (Event a))
06:09:50 <Cale> where something is one of the constructors of Event probably
06:10:15 <joelr1> Cale: no, Stop (Maybe) = Just (Maybe)
06:10:17 <Cale> these aren't really equalities of course :)
06:10:44 <Lemmih> Why do we want Status to be a Monad?
06:10:46 <joelr1> just trying to explain my intent. whether the dispatcher returns Stop Nothing or Stop Something, it's still a stop
06:10:53 <Cale> right
06:11:03 <joelr1> so how do i do this?
06:11:06 <Cale> but return has to give Stop Something
06:11:14 <Cale> given a value of type 'a'
06:11:37 <Cale> Well, I suppose it doesn't *have* to, but it'd make for a boring monad otherwise
06:11:41 <joelr1> uh... Stop a of course
06:11:48 <Cale> type error
06:11:50 <joelr1> return a = Stop a
06:11:54 <Cale> nope
06:12:03 <Cale> a /= Maybe (Event a)
06:12:22 <joelr1> fine, return (Nothing) = Stop Nothing
06:12:27 <joelr1> return (Just x) = Stop (Just x)
06:12:33 <joelr1> that's how i want it anyway
06:12:34 <Cale> hmm
06:12:40 <Lemmih> (:
06:12:50 <joelr1> meaning that this is how i need it
06:12:53 <Cale> so you're changing it to  data Status a = Start | Skip | Stop a
06:12:53 <Cale> ?
06:13:25 <Cale> otherwise that's a type error
06:13:31 <joelr1> Cale: you are reading too deep into this :-) i'm singlehandedly abstracting (Maybe (Event a)) into a
06:13:39 <joelr1> because it does not matter what a is
06:13:47 <joelr1> Stop a = stop the processing and return a
06:13:49 <Cale> yes, but those can't be the same type -- the 'a' there is the same 'a'
06:13:58 <Cale> you'd get an infinite type if they were the same
06:14:12 <joelr1> ok, fine, lets do this by the book
06:14:15 <Cale> something like   Maybe (Event (Maybe (Event ....)))
06:14:34 <joelr1> data Status a = Start | Skip | Stop (Maybe (Event a))
06:14:42 <Cale> okay
06:14:54 <joelr1> thus return x = Stop x
06:14:56 <Cale> and so return has to pick a constructor from Event
06:14:57 <Cale> no
06:15:01 <Cale> that doesn't do it
06:15:20 <Cale> return x = Just (makeEvent x)
06:15:32 <Lemmih> *Stop (Just (makeEvent x))
06:15:33 <joelr1> no, i do not make events
06:15:36 <tibbe> anyone have the time to help explain combining State and Cont in a single monad (used for my interpreter implementation)?
06:15:38 <Cale> return x = Stop (Just (makeEvent x))
06:15:41 <joelr1> they are passed into the dispatcher
06:16:13 <joelr1> what's the right word... event is a free variable?
06:16:16 <Cale> joelr1: well, okay, then, you're not going to be able to continue if you can't make an Event :)
06:16:26 <joelr1> existing outside of the list comprehension
06:16:37 <joelr1> dispatch = 
06:16:37 <joelr1>     do (time, event) <- fetch
06:16:43 <Cale> because all you have is a value of type 'a', and you're trying to get a value of type 'Status a'
06:16:54 <Cale> you don't have an Event
06:17:04 <Cale> now, you might want some other combinator
06:17:11 <joelr1>        status <- foldr mplus mzero [x event | x <- dispatchers]
06:17:11 <joelr1>        case status of 
06:17:11 <joelr1>          Nothing -> No event
06:17:11 <joelr1>          Just x -> New event
06:17:15 <Cale> but to make this a monad, you'll need return
06:17:24 <joelr1> i did not say i want a monad
06:17:28 <joelr1> i just want to get the job done 
06:17:30 <joelr1> :D
06:17:36 <Cale> tibbe: hmm
06:17:48 <Cale> tibbe: combining them in which way?
06:17:59 <joelr1> Cale: i fetch the event before running the list comprehension
06:18:09 <Cale> joelr1: I suppose I ought to really ask what that job is... or you'll tell me :)
06:18:32 <joelr1> http://paste.lisp.org/display/14502
06:18:36 <joelr1> this is the job
06:18:41 <tibbe> Cale, well I've written an eval function that looks like, eval :: Expr -> State Variables Value
06:18:58 <joelr1> i want to run a list of dispatchers over an event while dispatchers something other than Stop
06:19:07 <tibbe> Cale, And now I want to combine that with a Cont monad to enable me to add things such as callcc / gotos / etc to the language
06:19:28 <joelr1> and i want to grab the result returned in Stop
06:19:47 <tibbe> Cale, but I'm a bit unsure of the type for the new monad, should I wrap State in ContT or the other way around (Cont in StateT)
06:19:50 <joelr1> simple, right?
06:20:02 <Cale> joelr1: reasonably so :)
06:20:34 <joelr1> it seems like foldr is a good approach too, going through the list left to right
06:20:38 <Cale> joelr1: you definitely want a foldr
06:20:49 <joelr1> well then
06:20:52 <Cale> foldl's don't know how to stop early
06:21:01 <joelr1> initial value should also be a Skip
06:21:10 <Cale> however, you may want a monadic foldr
06:21:22 <joelr1> yes, of course
06:21:37 <Lemmih> joelr1: You didn't like the idea of folding over 'statusPlus'?
06:22:12 <joelr1> Lemmih: well, will it still be a lazy eval? a
06:22:18 <Cale> hmm, or perhaps with just the right folding function, the right action could be taken :)
06:22:30 <Lemmih> joelr1: Yeah.
06:22:40 <Cale> You're not running the action until you've built it :)
06:22:46 <Cale> (that's a lie)
06:23:07 <Cale> but it's safe to think of it that way here
06:23:20 <Cale> you just want to build the action to shortcut
06:23:28 <joelr1> so then mplus Skip Skip = Skip, mplus Skip Stop = Stop, mplus Stop Skip = Stoo
06:23:31 <joelr1> right?
06:23:39 <Cale> joelr1: you can't use mplus
06:23:44 <joelr1> how do i apply the monadic laws here?
06:23:45 <Lemmih> joelr1: statusPlus a b = do a' <- a; case a' of Skip -> b; _ -> return a'; statusZero = return Skip
06:23:52 <joelr1> Lemmih: oh
06:25:00 <joelr1> Lemmih: isn't that the same as making status into a monad?
06:25:06 <Cale> tibbe: hmmm... I'd say ContT r State
06:25:11 <Lemmih> joelr1: Nope.
06:25:30 <joelr1> well, right, in spirit it is, though
06:25:51 <tibbe> Cale, would that mean that I'll "lose" the current state whenever I'll do a callCC?
06:26:15 <Cale> tibbe: well, you have an imperative-style language, and the state monad is holding all the variable assignments and such?
06:27:27 <tibbe> Cale, yeah, at least until I change my mind about what language I want, again ;)
06:28:15 <Cale> I suppose if you want just pure continuations, then you could get by with State s (Cont r a)
06:29:29 <tibbe> Cale, I also have a slight type problem, would the type be: type MyMonad a = Cont a (State Variables a) b
06:30:05 <Cale> hmm, looks like you need a second parameter thanks to continuations
06:30:11 <tibbe> Cale, what I thought, how about the type for the combined monad, I'll have both eval and exec so I produce either Value or ()
06:30:40 <Cale> by the way, look at http://www.haskell.org/hawiki/ContinuationsDoneRight
06:30:49 <tibbe> state transformer looks like, newtype StateT s m a
06:30:59 <Cale> the mtl has a watered-down continuation monad
06:31:14 <tibbe> oki, I'll have a look
06:31:32 <Cale> but that doesn't define a transformer version along the same lines
06:32:02 <tibbe> type MyMonad a b = StateT Variables (Cont a b) a  ??
06:32:33 <tibbe> and then define eval :: MyMonad Value  ? looks like I'm missing a type parameter
06:32:40 <Cale> that looks possibly like a kind error
06:32:47 <tibbe> yeah
06:32:49 <Cale> StateT Variables (Cont a b) ?
06:33:09 <tibbe> I dunno, that's why I asked ;)
06:33:33 <Cale> It's hard to say without really knowing the specifics of the operations you want to support, and how they'll interact with the other effects
06:33:36 <tibbe> I just know that eval should produce a Value in the monad
06:33:48 <tibbe> I see
06:34:15 <Cale> Like, all of these are valid constructions, and with continuations around, you'll have some kind of callCC :)
06:34:20 <tibbe> I'm glad if I just can move from just using the State monad to the combined monad and having the thing compile
06:34:27 <Cale> :)
06:34:37 <Cale> by the way, make it a newtype
06:34:57 <tibbe> okay, but then I'll need to add and strip away a contructor all the time?
06:35:00 <Cale> and use deriving to pull all the instances you want 
06:35:10 <tibbe> okay
06:35:14 <Cale> no, because you shouldn't want to use the constructor
06:35:29 <tibbe> ah
06:35:29 <Cale> You should, in fact hide the constructor
06:35:51 <Cale> you might need it at first to implement some extra operations
06:36:09 <Cale> but you should keep all this in a module, and hide it from the outside world
06:36:15 <tibbe> what I'm really unsure of is what goes in _ = StateT Variables (Cont _ _) _
06:36:27 <tibbe> I understand
06:36:29 <Cale> The generic monads and monad transformers in the libraries are usually overly general.
06:36:49 <Cale> well, that last _ isn't there
06:37:00 <tibbe> hmmm, okay
06:37:25 <tibbe> So in State s m a, the m a part both goes into the Cont thingie?
06:37:45 <Cale> it's StateT s m a
06:37:53 <tibbe> sorry I mean StateT
06:37:54 <Cale> State just takes two parameters
06:38:03 <Cale> oh
06:38:13 <Cale> You did write StateT, sorry :)
06:38:35 <Cale> okay, so you need to partially apply Cont
06:38:40 <tibbe> How about, type MyMonad a = StateT Variables (Cont a a) ?
06:38:42 <tibbe> hmmm
06:39:00 <Cale> newtype Eval r a = StateT Variables (Cont r) a
06:39:11 <tibbe> so what really gets me is that I thing I'm only producing one thing (a Value) but need two parameters
06:39:17 <Cale> that'll compile at least :)
06:39:23 <tibbe> :)
06:39:33 <tibbe> what would the type of eval be then?
06:39:34 <Cale> hmm
06:39:44 <Cale> maybe  newtype Eval a = StateT Variables (Cont a) a
06:39:47 <tibbe> eval :: Expr -> ?
06:39:59 <tibbe> that makes more sense
06:40:17 <tibbe> I'm computing the same "kind" of value in both the Cont and State monad
06:40:45 <shapr> hej Azmo 
06:40:53 <shapr> coi kpreid_ 
06:41:15 <tibbe> that's what I have now
06:41:18 * shapr hops
06:41:33 <Cale> tibbe: you'll have to excuse me, as I have very little experience with the continuation monad -- it's not the sort of thing you use every day :)
06:41:56 <tibbe> Cale, me nethier ;) in fact I've only done functional programming for 8 weeks
06:42:43 <Cale> http://www.nomaware.com/monads/html/contmonad.html -- this has a funny warning: "! Abuse of the Continuation monad can produce code that is impossible to understand and maintain."
06:43:08 <Cale> which is probably true, but sometimes you really do want continuations
06:43:37 <tibbe> Cale, how would I run the monad then? I've tried, runCont (execState (exec stmt) initalState) id
06:43:58 <tibbe> Cale, where exec :: Stmt -> MyMonad ()
06:44:32 <tibbe> Cale, Kinda hard to implement continuations without using continuations ;)
06:44:38 <psi> has anyone here got "frag" working?
06:45:18 <Cale> runCont (evalState (exec stmt) initialState) id
06:45:26 <Cale> psi: yeah
06:45:46 <psi> it exits upon launch with: a.out: {handle: leveleg.bsp}: hGetBufFully: end of file
06:46:31 <tibbe> Cale, hmm, I have some output in the state so I'd like to run the monad and then get back the state
06:46:35 <psi> SamB, ghci works now! :)
06:46:41 * shapr boings
06:47:37 <SamB> psi: cool ;-)
06:47:54 <SamB> now somebody has to submit the patch
06:48:05 <shapr> Patch to what?
06:48:12 <Cale> let (x,s) = runState (exec stmt) initialState in (runCont x id, s)
06:48:19 <SamB> shapr: Linker.c
06:48:33 <SamB> shapr: its for PPC Linux
06:48:41 <tibbe> Cale, I'll try that, thanks
06:48:43 * shapr is out of touch
06:48:43 <shapr> Probably send it to ghc-users?
06:49:01 <Cale> tibbe: hmm... I'm sort of wondering whether this evaluation order looks right
06:49:18 <Cale> It might be okay
06:49:26 <Cale> well, try it anyway :)
06:49:49 <tibbe> Cale, I'm feeling a bit like I'm trying to make the compiler happy instead of understanding what's going on ;)
06:50:01 <Cale> well, making the compiler happy is usually a good thing
06:50:14 <tibbe> yeah, it kinda makes running programs easier
06:50:15 <Cale> here's a relevant quote ...
06:50:28 <SamB> tibbe: the compiler is usually unhappy when you have not got the types quite right
06:50:49 <Cale> * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost
06:50:49 <Cale> <shapr> Didn't you write that code?
06:50:49 <Cale> <autrijus> yeah. and it works
06:50:49 <Cale> <autrijus> I just don't know what it means.
06:50:49 <SamB> tibbe: you may understand whats going on better if you give more type signatures
06:51:00 <SamB> ah
06:51:04 <SamB> I like that quote
06:51:33 <tibbe> SamB, I'm trying ;)
06:52:00 <tibbe> Cale, hehe, that
06:52:03 <psi> SamB, does it make sense that the patch fixed hmp3 (and probably yi) on ppc?
06:52:10 <tibbe> Cale, that's a bit how I feel
06:52:30 <SamB> psi: no!
06:52:44 <SamB> perhaps there was something else different between the source you built from and the source the .deb was built from?
06:53:01 <Cale> From 8 weeks to writing serious code with monad transformers and continuations is a bit of a rough start.
06:53:05 <SamB> it sorta makes sense if it fixed Yi, actually
06:53:07 <shapr> nice quote.
06:53:12 <psi> ugh. i dunno, they are both 6.4.1.
06:53:34 <SamB> psi: no idea why it would fix hmp3
06:53:36 <musasabi> Is GHC -threaded broken on Solaris? I get undefined references to sched-yield (see http://youzen.b2.fi/~musasabi/a.txt) when trying to build programs.
06:53:40 <shapr> @quote autrijus
06:53:41 <lambdabot>  Parrot is fine except every time I build it, it fails
06:53:45 <tibbe> Cale, yeah, did I mentioned that I'm supposed to be finished in a week?
06:53:53 <Cale> tibbe: eek
06:54:03 <shapr> Is this homework?
06:54:04 <psi> SamB, hmp3 and yi suffered from the same problem. the binary would segfault before even getting to main.
06:54:08 <lollan> sorry i begin to learn Haskell and i download Hugs (for win), i try to do : type Test = (String,Int) but i does'nt work
06:54:09 <jethr0> @quote autrijus
06:54:09 <lambdabot>  Mechanical and super-natty! Inspect the result and *if* happy; freeze,
06:54:09 <lambdabot> sell and get some sleep!
06:54:13 <lollan> is it normal ?
06:54:13 <SamB> psi: huh
06:54:28 <shapr> You have to do what in a week?
06:54:33 <Cale> then again, if you've mostly designed the algorithms and know what you want to do, a basic compiler in a week isn't unreasonable in Haskell.
06:54:38 <tibbe> well, school project, I'll pass anyway but I wanted to make something cool, not just your average imperative language
06:54:46 <SamB> psi: well, you could try also building ghc without that patch
06:54:50 <shapr> There's always Philippa's Template Haskell compiler.
06:54:55 <Cale> lollan: are you typing this at the prompt?
06:55:02 <Heffalump> lollan: you have to put declarations in a file and load that file
06:55:08 <Heffalump> the prompt in hugs is just for expression evaluation
06:55:09 <tibbe> shapr, just add continuations, the language works fine otherwise
06:55:21 <SamB> tibbe: what are you trying to make?
06:55:30 <lollan> ok thanks Heffalump and Cale
06:55:32 <Cale> SamB: he just said
06:55:46 <SamB> tibbe: seen ConT done right ?
06:56:07 <lollan> can tou tell me the commande to have some help ?
06:56:13 <tibbe> SamB, I've already made a small imperative language interpreter (and lexer/parser) and it runs in the State monad and now I want to add callCC support by using the Cont monad
06:56:15 <Cale> lollan: :?
06:56:25 <tibbe> SamB, yeah
06:56:32 <jethr0> samb, i am finally understanding the whole of your BFInterpreter :)
06:56:34 <psi> SamB: hm... would that be quick?
06:56:47 <shapr> Huh?
06:56:49 <jethr0> but i think you could write "read = get >>= liftIO peek"
06:56:49 <SamB> psi: well.
06:56:52 <Cale> jethr0: it's pretty elegant when you understand all the parts, eh?
06:56:59 <SamB> if you used the same build tree, yes
06:57:06 <jethr0> and "write = get >>= liftIO . poke"
06:57:11 <jethr0> hehe
06:57:18 <lollan> Cale : there is no way to print a doc ?
06:57:24 <SamB> psi: but it isn't terribly important
06:57:32 <Cale> lollan: hm?
06:57:40 <Cale> lollan: documentation is online
06:57:48 <lollan> ok thanks
06:57:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
06:58:04 <jethr0> cale, BF isn't the most complex of languages... but the interpreter is definitely concise!!
06:58:12 <SamB> jethr0: cool
06:58:13 <Cale> that's for GHC, but the libraries are similar in Hugs
06:58:22 * SamB needs to write an article on that
06:58:27 <jethr0> on what?
06:58:37 <psi> SamB, if it has to do with ncurses, is it definitely unrelated?
06:58:59 <Cale> jethr0: a good question is whether that way of writing them is clearer :)
06:59:23 <jethr0> true, but as i said earlier, i'm in a very concise mood lately
06:59:26 * shapr hops and HUPs
06:59:30 <psi> actually, nevermind that. i have no idea why they crash.
06:59:56 <Cale> did everyone notice that dons added syntax highlighting to ncurses yi?
07:00:00 <SamB> psi: I will only say that I was under the impression that Linker.c was not used by anything but GHCi and hs-plugins (and its ancestors)
07:00:08 <shapr> Cale: Yes! It's soo coool!
07:00:19 <SamB> Cale: he told me he was doing that
07:01:03 <jethr0> the "write" above doesn't work anyway :(
07:01:10 <shapr> Can I include a css file outside of the head of a page?
07:01:23 <shapr> I want to use malcolm's HsColour on LtU
07:01:27 <SamB> jethr0: I think I like read and write fine as-is
07:01:32 <jethr0> :)
07:01:56 <jethr0> samb, i definitely like your code... just trying not to make it look as if it took me days to understand it :P
07:02:08 <Cale> shapr: hmm... I'm not sure if link tags are really permitted outside the head, but you could try it
07:02:45 <SamB> jethr0: well, didn't it? not that there is anything wrong with that...
07:02:55 <SamB> its more my fault anyway
07:03:12 <SamB> musasabi: get any more sleep?
07:03:22 <jethr0> no, i just had to get up to speed with some of the more advanced features of haskell
07:03:42 <SamB> jethr0: well, yes, of course ;-)
07:05:14 <Cale> SamB: you should write some nice comments into the wiki page explaining it all :)
07:06:24 <shapr> ndm: Is the missing Note value in HsColour from ColourHighlight.hs ?
07:06:33 <SamB> Cale: well, I'm writing a TMR article on it
07:06:39 <ndm> shapr, it is indeed
07:06:49 <jethr0> cale, once you get the haskell involved, it's really mostly self-explanatory...
07:07:00 <shapr> ndm: Do you have a ColourHighlight.hs that includes Note? The darcs repo doesn't have it.
07:07:04 <Cale> SamB: ah, neat :)
07:07:17 <ndm> just getting it
07:07:24 <SamB> (none of which is in digital form just yet)
07:08:18 * shapr yodels hoppily.
07:08:23 <ndm> shapr, the original repo didn't have ColourHighlight, so i added it, then it seems my changes got lost...
07:08:37 <shapr> The file is there, but not the Note value.
07:08:54 <ndm> yeah, the file was added later, and seems to have clobbered my change
07:09:07 <tibbe> gah!
07:09:46 <SamB> jethr0: well, this article is going to be mostly a retcon that starts with the basics and works its way towards an interpreter similar to this one
07:09:47 <ndm> {
07:09:49 <ndm> hunk ./ColourHighlight.hs 19
07:09:50 <ndm> +  | Note String
07:09:52 <ndm> }
07:10:24 <jethr0> cool
07:11:37 <danY2K> hey guys. i got a noob question: why is foldr of type  foldr :: (a -> b -> b) -> b -> [a] -> b? what does that cant you actually write foldr :: (a -> a -> a) -> a -> [a] -> a
07:11:39 <tibbe> Cale, still there?
07:11:49 <danY2K> im not sure about the meaning of b here...
07:12:27 <Cale> tibbe: yeah
07:12:30 <tibbe> danY2K, it's a more general type, you could actually provide a function that returns a value of different type and get a list of that
07:12:43 <Cale> danY2K: one sec :)
07:13:00 <Cale> http://vx.hn.org/autoshare/folds.png
07:13:03 <Cale> there :)
07:13:18 <Cale> perhaps the diagram will help it to make sense
07:13:21 * SamB supposes he doesn't need to get it into MoinMoin format before posting
07:13:23 <tibbe> Cale, I think I'm almost there, the problem is that I can't run the monad since that requires first running the StateT and the the Cont, but StateT only produces a state and now value so I have nothing to pass to the Cont runner
07:13:24 <Cale> note that  foldr (:) [] = id
07:13:25 <musasabi> SamB: some hours in the morning. Thanks for asking.
07:13:40 <Cale> tibbe: runState
07:13:42 <Cale> tibbe: runStateT
07:14:01 <Cale> map f = foldr ((:) . f) []
07:14:16 <tibbe> Cale, yeah but the value will be () since exec :: Stmt -> MyMonad ()
07:14:26 <tibbe> assigns and such doesn't produce any value
07:14:37 * SamB would probably use ContT and State
07:14:38 <tibbe> (i.e. stmts doesn't produce any value)
07:14:39 * musasabi is slowly starting to think that all name and service resolution should ignore the OS completely.
07:14:51 <Cale> tibbe: hmm
07:14:57 <danY2K> Cale, thx, but this still doesnt enlighten the meaning of a and b and why the have to be different to each other...
07:14:59 <Heffalump> musasabi: why?
07:14:59 <Cale> Maybe try the other way around
07:15:02 <tibbe> SamB, what would be the difference? would callCC make my "lose" state in that case?
07:15:12 <Cale> danY2K: well, it's not that they have to be different
07:15:19 <SamB> tibbe: well, let me see.
07:15:19 <Cale> danY2K: it's that they can be
07:15:32 <Cale> look at the first example
07:15:32 <musasabi> Heffalump: just found a "nice" feature on older solaris machines which makes getaddrinfo fail on all services not in /etc/services
07:15:42 <Cale> > foldr (:) [] [1,2,3,4,5]
07:15:43 <lambdabot> [1,2,3,4,5]
07:15:49 <Cale> @type (:)
07:15:50 <lambdabot> forall a. a -> [a] -> [a]
07:16:13 <Cale> note that the left and right parameters aren't the same type
07:16:19 <musasabi> Heffalump: Even numeric ones (the numeric ones were fixed in later versions, but the basic /etc/services lacks e.g. entries for "http")
07:16:32 <SamB> tibbe: well, it doesn't look like I ever managed to write a working unlambda interpreter using ContT...
07:16:33 <tibbe> SamB, would that make me "lose" the state after the point I called callCC when calling the continuation?
07:16:45 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
07:16:46 <lambdabot> [5,4,3,2,1]
07:16:50 <tibbe> SamB, what's an unlambda interpreter?
07:17:09 <SamB> unlambda is an esoteric language
07:17:13 <Cale> http://www.madore.org/~david/programs/unlambda/
07:17:14 <tibbe> ah
07:17:43 <tibbe> SamB, which version makes u lose the state? is it StateT -> Cont or ContT -> State?
07:17:48 <Cale> ``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s``s`ks``s`kk`ks``s``s`ks``s`kk`kk``s`kk`ks
07:18:06 <musasabi> It seems that getaddrinfo is broken on most systems in various corner cases (and of course different ones).
07:18:11 <SamB> tibbe: not sure!
07:18:16 <Cale> tibbe: you have state in both of those
07:18:38 <Cale> ContT State is more likely what you want actually
07:18:59 <SamB> just try swapping and see what happens
07:19:00 <tibbe> but there's a difference right, I wanna know what it is! ;)
07:19:01 <Cale> since you know that your interpreter is working with just state
07:19:10 <Cale> and you're adding continuation support in
07:19:27 <SamB> maybe your types will make more sense this way ;-)
07:19:34 <tibbe> i'll try to make a small test case, I've been too lazy to do that yet, sorry
07:19:47 <Cale> StateT Cont is where you have continuation support, and you want to make them stateful
07:20:12 <tibbe> Cale, and what does that mean? that they share state?
07:20:40 <tibbe> Cale, hmmm, did my sentence even make sense...
07:20:41 <Cale> that they carry state along, possibly modifying it as they go
07:20:43 * SamB has no idea what StateT Cont means
07:21:08 <Cale> The exact semantics are a bit mysterious :)
07:21:14 <Cale> I'd have to try it and see
07:21:19 <SamB> in fact, I don't really have any idea what the point of Cont is
07:21:32 <kpreid_> shapr: ?
07:21:33 <tibbe> Cale, the point with callCC is that you "return" to some earlier point, the question is if you carry the updated state with you or if you continue with the old "saved" state
07:22:03 <Cale> tibbe: yes, it's exactly that which I don't know
07:22:27 <Cale> I'd have to think about it, and I've only had one coffee so far :)
07:22:37 <tibbe> Cale, well, that makes two of us who doesn't
07:22:38 <Heffalump> musasabi: oops
07:22:46 <Cale> tibbe: trying it would also work :)
07:22:52 <Heffalump> though I think you are risking getting into the qmail mentality by doing that
07:22:54 <Cale> perhaps I'll do that
07:22:55 <tibbe> Cale, nah, that's cheating
07:23:04 <SamB> tibbe: just try it with ContT State...
07:23:06 <Heffalump> apps work the same on all OSes, but an individual platform has no internal consistency
07:23:17 <SamB> ContT is how everyone always uses it...
07:23:22 <Cale> ContT State sounds more reasonable
07:23:31 <tibbe> SamB, All right, I will. No I know why it doesn't work the way I've done it so far at least
07:23:40 <Cale> ContT adds continuations to an existing language
07:23:49 <Cale> StateT adds state to an existing language
07:23:56 <tibbe> thanks both of you, i'll get back to hacking
07:24:11 <SamB> perhaps I should try StateT Cont sometime for a BF interpreter...
07:24:18 <tibbe> BF?
07:24:21 <SamB> or, well, StateT ConT IO
07:24:32 <SamB> er, unlambda rather
07:24:41 <SamB> bf hasn't got continuations...
07:24:45 <tibbe> ah
07:24:47 <Cale> StateT Cont is actually an interesting idea. I wonder if it's actually isomorphic to ContT State up to lifting
07:25:02 <SamB> (they are both esolangs, so I got the names mixed up)
07:25:17 <Cale> BF should have continuations
07:25:36 <Cale> It's too sane a language as it stands
07:25:46 <SamB> how would you represent them on the tape?
07:25:49 <tibbe> Cale, I don't even know what isomorphic means
07:26:00 <Cale> tibbe: the "same"
07:26:09 <tibbe> esolangs?
07:26:15 <Cale> literally, it means "same shape"
07:26:23 <tibbe> nod
07:26:37 <musasabi> Heffalump: is it better to force all clients to make a giant hurdle of #ifdefs ?
07:26:43 <Cale> I mean it here to mean that they'd have the same semantics (if things were all lifted the right way)
07:26:56 <Heffalump> musasabi: yes, I think so.
07:27:05 <twb> Where is parsec's darcs repo?
07:27:19 <Heffalump> otherwise you don't benefit from improvements in the OS either
07:27:21 <Cale> hmm, with the right state type, you can save continuations in the state
07:27:30 <Heffalump> ifdefs to work around the broken stuff, but rely on the OS when it does work
07:28:34 <SamB> twb: darcs repo?
07:28:41 <twb> SamB: I assume there is one.
07:28:43 <musasabi> it is stuff like "this combination of arguments does not work on OS X versions A..B" and the given set of alternative arguments does not work onon OS Y version C..D etc
07:28:52 <twb> (I want to correct some typos in the documentation.)
07:29:01 <SamB> twb: Parsec is in fptools cvs, dunno if it has a darcs repo...
07:29:09 <twb> Bleh.
07:29:15 <twb> @hptools
07:29:16 <lambdabot> Unknown command, try @listcommands.
07:29:17 <SamB> at least, I assume it is
07:29:18 <twb> @fptools
07:29:18 <lambdabot> Unknown command, try @listcommands.
07:29:23 <Cale> @where fptools
07:29:23 <lambdabot> I know nothing about fptools.
07:29:30 <twb> @hoogle fptools
07:29:31 <lambdabot> No matches found
07:29:37 <Cale> @google fptools
07:29:37 <twb> bleh.
07:29:38 <lambdabot> http://www.fptools.com/
07:29:39 <Heffalump> there is a current effort to move fptools etc to darcs, but I dunno if that's live yet
07:29:40 <Cale> no
07:29:43 <SamB> hmm
07:29:56 <SamB> twb: there is likely a darcs mirror of it, I suppose
07:29:58 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
07:30:10 <Cale> @where+ fptools http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
07:30:11 <lambdabot> fptools ~> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
07:30:26 <SamB> Cale: where are the instructions for checkout?
07:30:30 <Cale> hmm
07:30:41 <Cale> http://cvs.haskell.org/
07:30:42 <SamB> its a bit non-obvious, you know...
07:31:08 <Cale> CVS is brutal
07:31:19 <SamB> yes
07:31:21 <lollan> yes
07:31:58 <musasabi> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
07:31:59 <Cale> software that requires the setting of environment variables as part of ordinary use...
07:32:18 <lollan> svn is gentle
07:32:26 <Cale> darcs!
07:32:39 <Cale> lollan: you're in #haskell, you know :)
07:32:43 <lollan> lol
07:32:52 <lollan> yes sorry
07:33:01 <Cale> @where+ fptools http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
07:33:02 <lambdabot> fptools ~> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.
07:33:02 <lambdabot> html
07:33:03 <lollan> I ask everibody to forgive me
07:33:10 <Cale> perhaps that's a better mapping
07:35:02 <Heffalump> cale: isn't there a command-line flag for CVS_RSH?
07:35:26 <Heffalump> (yes, -s CVS_RSH=ssh :-)
07:36:11 <tibbe> my head hurts :(
07:38:21 <shapr> kpreid_: You called?
07:38:34 <kpreid_> shapr: You greeted?
07:38:42 <Azmo> does anyone know how to import a function from a DLL (without associated .h or .lib) file?
07:39:19 <shapr> kpreid_: Yup, just saying hi, wondering how's code/life/rsi/etc
07:39:49 <kpreid_> rather bland, at the moment
07:39:54 <lollan> no sorry Azmo
07:39:55 <kpreid_> I have a Haskell question, actually.
07:40:03 <shapr> Go for it
07:40:16 <Heffalump> kpreid_: you want #c for that. We only do imperative languages here.
07:40:36 <Lemmih> Azmo: Functions from a DLL are just like any other foreign function, afaik.
07:40:55 <neologism> Heffalump: does asm fits here?
07:41:14 <SamB> Heffalump: didn't you hear?
07:41:15 <Heffalump> absolutely ;-)
07:41:20 <Heffalump> SamB: no, what?
07:41:22 <SamB> its ##c now
07:41:28 <Azmo> Lemmih: but the ffi does not accept something like "foreign import stdcall "kernel32.dll Beep" beep :: ..."
07:41:32 <Heffalump> oh, I knew that, I was just ignoring it
07:41:40 <Heffalump> neologism: especially ARM asm, I like that
07:41:45 <neologism> heh
07:41:50 <Lemmih> Azmo: Remove the 'kernel32.dll'.
07:42:04 <SamB> Azmo: probably because kernel32.dll isn't a header file
07:42:19 <neologism> Heffalump: a lot of people like combining asm+sql :)
07:42:19 <Azmo> Lemmih: but how does the compiler/interpreter know what function i want then?`
07:42:31 <kpreid_> shapr: Am I wrong that it is impossible to write the non-magical functions f and g such that f (g (repeat x)) is equal to (repeat x), and that (g (repeat x)) is a finite String?
07:42:51 <Lemmih> Azmo: It knows that you want a function called 'Beep'.
07:43:15 <tibbe> could one provide me with an canonical (i.e. as short as possible) of callCC in use?
07:43:19 <tibbe> someone*
07:43:34 <Heffalump> kpreid_: looks pretty easy to me
07:43:39 <Heffalump> g = head, f = repeat
07:43:39 <shapr> kpreid_: What about repeat (head (repeat x)) ?
07:43:44 <kpreid_> erm
07:43:46 <shapr> ooh, in stereo :-)
07:43:46 <Azmo> Lemmih: but i want to import a certain function from a certain DLL, not just any function called Beep. even if i could import the Beep function, how could i import a function with ordinal 0x000d from a DLL i created myself?
07:43:48 <kpreid_> sorry, bad example
07:44:01 <Cale> kpreid_: perhaps you mean cycle rather than repeat?
07:44:02 <kpreid_> for (repeat x), read any cyclic value
07:44:21 <Cale> It's impossible to directly detect cyclic infinite values
07:44:22 <Heffalump> known to be cyclic, but of unknown period?
07:44:33 <kpreid_> OK, that's what I thought.
07:44:56 <shapr> kpreid_: There was a cool thread on hcafe recently about detecting infinite values.
07:45:09 <kpreid_> I'm comparing the semantics of my pet language (E) to Haskell WRT cyclic structures.
07:45:10 <Heffalump> how do you do it?
07:45:28 <Cale> You can do it in some restricted cases by cheating and remembering them in the first place
07:45:38 <Lemmih> Azmo: That's not how shared libraries work. At least not in Linux.
07:45:43 <SamB> Cale: it is not impossible if the infinite value is known to be from iterate
07:45:52 <kpreid_> So Haskell can work with infinite values, but it can't turn them into finite values.
07:45:58 <Cale> SamB: in Haskell?
07:46:15 <Cale> kpreid_: it can turn them into finite values to some extent
07:46:17 <SamB> Cale: yeah
07:46:26 <Cale> SamB: no FFI :)
07:46:32 <kpreid_> s/them/any of them, even trivial ones,/
07:46:39 <Azmo> Lemmih: i mean win32. i want to import a function from an arbitrary win32 DLL.
07:46:42 <SamB> Cale: as long as you know it will be cyclic
07:46:52 <Cale> SamB: if you don't know the period
07:47:26 <SamB> doesn't matter.
07:47:36 <SamB> all you have to do is find ONE repeated value
07:47:54 <Cale> SamB: um, and how exactly do you do the comparison?
07:48:20 <Heffalump> SamB: so what would you do with [2,1,2,3,2,1,2,3,...] ?
07:48:21 <Lemmih> Azmo: You import a symbol and then link with a library that provides said symbol.
07:48:31 <SamB> Heffalump: that isn't from iterate
07:48:32 <Cale> consider   cycle [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
07:48:51 <Heffalump> we didn't say it was
07:49:11 <SamB> <SamB> Cale: it is not impossible if the infinite value is known to be from iterate
07:49:17 <Heffalump> oh, sorry
07:49:20 <Heffalump> yeah, you're right there
07:49:36 <Heffalump> but only if there is Eq
07:49:50 <SamB> Heffalump: well, true.
07:50:03 <Azmo> Lemmih: i don't know what you mean really. what do you mean by linking? there is no linking in haskell?
07:50:16 <Cale> iterate swap ((+1), (*2))
07:51:12 <SamB> the context in which I was thinking about this is finding that one polynomial for GF
07:52:01 <sieni> azmo
07:52:08 <Cale> SamB: by GF, do you mean "Galois Field"?
07:52:21 <Lemmih> Azmo: Have you tried removing the 'kernel32.dll' from your foreign import?
07:52:47 <sieni> Azmo: I don't know if it is possible in haskell, but in mzscheme you can just import a dll and say what a function's name and signature is and it imports it automatically as a scheme object
07:53:38 <Cale> kpreid_: of course, you can always break the infinite construction off at some point
07:53:42 <Lemmih> Azmo: Do you want to access symbols from DLLs at runtime?
07:53:46 <SamB> Cale: yeah
07:53:55 <shapr> ndm: The patch works, thanks. I do wish I could specify the color scheme in a config though. The Magenta, Cyan, etc doesn't really match the LtU colors.
07:54:04 <kpreid_> Cale: then it isn't infinite, now is it? :)
07:54:12 <ndm> shapr, use the -css
07:54:19 <kpreid_> this isn't really a practical question, just musing
07:54:26 <ndm> although, that won't really work for pasting into blogs etc.
07:54:27 <Azmo> Lemmih: oh, ok. it worked. but that does not solve the problem from importing a function from an arbitrary DLL.
07:54:34 <Cale> kpreid_: well, you said "So Haskell can work with infinite values, but it can't turn them into finite values."
07:54:38 <ndm> you can customise the colour scheme, see .hscolour
07:54:46 <Azmo> Lemmih: no. not run-time. i need it at global scope in my program.
07:54:47 <kpreid_> Cale: ...yes?
07:54:47 <Cale> "take" will do just that
07:54:51 <kpreid_> oh
07:54:56 <Cale> take 20 [1,2...]
07:54:57 <Cale> take 20 [1,2..]
07:54:59 <shapr> ndm: ooh, nifty.
07:55:01 <Cale> > take 20 [1,2..]
07:55:01 <kpreid_> I mean, without discarding information. :)
07:55:02 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:55:12 <Cale> kpreid_: right, and in general, that's impossible
07:55:24 <ndm> shapr, i think the default colour scheme looks a bit ugly, see hscolour.css for what i use
07:55:30 <kpreid_> Cale: not for *cyclic* values, as opposed to general infinite ones
07:55:44 <Heffalump> Haskell makes no semantic difference between
07:56:00 <Cale> well, you'd need some extra data structure to represent the fixpoint formally
07:56:03 <Heffalump> cycle [0,1,2] and iterate (\x -> (x+1) `mod` 3) 0
07:56:25 <Heffalump> whereas a language in which cyclic values were observable would
07:56:31 <kpreid_> right
07:56:42 <shapr> ndm: Can I attach the css inline somehow? LtU uses drupal, meaning I'm allowed to put code inside the body tag only.
07:56:48 <Lemmih> Azmo: I don't understand how you want to import a function from an arbitrary DLL if you aren't doing it at runtime.
07:57:07 <shapr> ndm: I gotta make this a plugin for hawiki, I like it.
07:57:08 <ndm> shapr, change cssPrefix, so its
07:57:29 <ndm> <style type='text/css'> {all your css definitions} </style>
07:57:37 <ndm> and remove the head/body bits
07:57:59 <ndm> you could even make it readFile hscolour.css and shove it in there, as an option
07:58:00 * shapr tries that
07:58:06 <ndm> sort of -cssfile and -cssinline
07:58:14 <shapr> Yeah, that would be nifty.
07:58:16 <Azmo> Lemmih: lets say that i create a DLL myself by compiling some code in some language. i then want to import a function from that DLL into my haskell code. i know what DLL and function i need, and i need to write that name as some kind of import.
07:58:28 <shapr> I see a haskellpaste bot in the near future.
07:59:32 <shapr> I have the urge to do another International Obfuscated Haskell Code Contest, are there any interested jurors and entrants?
07:59:33 <Lemmih> Azmo: The name of the shared library doesn't have anything to do with the foreign import.
07:59:34 <ndm> sounds good :)
08:00:03 <shapr> TheHunter: Think you'd have time for an obfuscated Haskell entry?
08:00:11 <Cale> and perhaps the recursive datatypes would have to be constructed with explicit recursion to make that useful
08:00:12 <jethr0> shapr, i'd try to enter sth, but i'm a total haskell newbie and thus not very qualified
08:00:16 <jethr0> :P
08:00:29 <Azmo> Lemmih: but to import the function i need to specify from where. the Beep function might also exist in some other DLL. i might want to take it from that DLL instead.
08:00:36 <shapr> If you look at the past winners, I'm sure you can a) learn lots and b) come up with a cool entry.
08:00:50 <jethr0> shapr, got an url?
08:01:02 <Lemmih> Azmo: Do you know how to do what you want in C?
08:01:03 <jethr0> got it
08:01:15 <Cale> here's an idea: write a program which runs completely differently under hugs and ghc due to the recently discovered lexical differences :)
08:01:24 <Azmo> Lemmih: no, not really :/.
08:01:39 <shapr> jethr0: http://www.scannedinavian.org/iohcc/
08:01:41 <Heffalump> Cale: which is correct?
08:01:49 <Cale> Heffalump: hugs
08:02:09 <Cale> --: is allowed as an infix operator
08:02:18 <Cale> but ghc treats it as a comment
08:04:23 <Lemmih> Azmo: I don't think you're allowed to link with two DLLs which export the same symbol. You can check your linkers options to be sure.
08:04:34 <jethr0> shapr, could you use hs-plugins?
08:05:00 <jethr0> recursively produced/eval'd code seems like a nice touch :)
08:05:31 <shapr> jethr0: I think you're on the right track...
08:05:52 <Azmo> Lemmih: i don't really understand. two different DLLs could export something which has the same name.
08:05:55 <shapr> You could ask dcoutts for his partial evalutor code.
08:06:04 * jethr0 is a _huge_ fan of the obfuscated c contest, although i could never understand any of the entries
08:06:28 * shapr imagines a mix of hs-plugins, template haskell, partial evaluation, arrows, and lambda calculus.
08:07:00 <Azmo> Lemmih: are you talking about some kind of linking of DLLs with haskell programs?
08:07:01 <shapr> I wonder if you could intoautomatically compile naive lambda calculus into supercombinators...
08:07:24 <shapr> Dang, my Brain monad is flaky today, my words are out of order.
08:07:31 <Lemmih> Azmo: No, this has absolutely nothing to do with Haskell.
08:07:38 <tibbe> Cale, I'm almost there now, could you give your opinion one one final thing?
08:07:45 <Cale> tibbe: okay
08:07:48 <jethr0> is there a prettyprinter binary in the ghc distribution?
08:08:10 <tibbe> Cale, exec :: Stmt -> ProgramState ()
08:08:10 <tibbe> exec (Assign x e) = do v <- eval e
08:08:10 <tibbe>                        update x v
08:08:13 * jethr0 wonders what supercombinators might be
08:08:24 <Azmo> Lemmih: but my point is. when i compile my haskell program, there could be many DLLs in the system. and there could by a DLL which is not part of windows, that exports a function that i called Beep, and that i want to import.. :/
08:09:13 <Lemmih> Azmo: Do you understand the different between compiling and linking?
08:09:14 <tibbe> Cale, now v <- eval e   has type MyMonad Value so I get this: Expected type: ContT () (State State.State), Inferred type: ContT Value (State State.State)   (State.State is my variables)
08:09:30 <Azmo> Lemmih: sort of.
08:09:58 <tibbe> it complains that it is a Value but after the case it'll be a ()
08:11:25 <musasabi> What is the best way to do a mapM_ on a large Data.Map? foldWithKey or toAscList + mapM_ ?
08:12:00 <twb> Grr.  The parsec documentation isn't in the fptools repo.
08:12:21 <shapr> ndm: There's a bug that turns every > into } in the generated html.
08:12:25 <Azmo> Lemmih: i guess that it would be possible to import the function i want in a java or c program, and then import the c/java function in my haskell program. but that seems unnecessarily complicated compared to just importing the DLL function directly in my haskell code. less files and less work too.
08:12:51 <Lemmih> Azmo: You know how to do it in C?
08:13:10 <ndm> thats not good!
08:13:24 <Azmo> Lemmih: still no. but i could try.. could also try java. but would be much nicer to import directly into haskell.
08:14:09 <ndm> shapr, not in my copy...
08:14:11 <Lemmih> Azmo: How does Java resolve the ambiguity?
08:14:14 <shapr> Weird
08:14:30 <ndm> shapr, see http://www-users.cs.york.ac.uk/~ndm/temp/HsColour.html
08:14:34 <shapr> ndm: user error, sorry.
08:14:37 <ndm> that has >'s coming out correctly
08:14:43 <ndm> hehe, never mind
08:14:50 <musasabi> @pl (\f -> Data.Map.foldWithKey (\k a m -> m >> f k a) (return ()))
08:14:51 <lambdabot> ((Data . Map) .) . flip foldWithKey return . ((flip (>>) .) .)
08:15:02 <musasabi> grah.
08:15:06 <ndm> to be honest, i've only hacked HsColour for about 10 minutes tops, i still don't know how it works really
08:15:07 <musasabi> @pl (\f -> foldWithKey (\k a m -> m >> f k a) (return ()))
08:15:07 <lambdabot> flip foldWithKey return . ((flip (>>) .) .)
08:15:54 <Azmo> Lemmih: it specifies the DLL and the function. e.g "@dll.import("USER32")", and then the function name and type. i think there are various different extensions.
08:16:47 <shapr> grr, wtf is call-with-transparent-undo, and why can't emacs find it?
08:16:52 * shapr kicks emacs
08:17:07 <jethr0> shapr, i'm a bit unclear about the rules. they don't exclude "hs-plugins" (i think), and what about use of parsec?
08:17:09 <Lemmih> Azmo: If you figure out how to do it in C then it would be trivial to port it to Haskell.
08:17:49 <shapr> jethr0: Parsec is a standard library, it's allowed.
08:17:55 <jethr0> ok, cool
08:17:57 <Azmo> Lemmih: true, but i was hoping for a way to directly import into haskell.
08:18:01 <gour> dcoutts: ping
08:18:25 <Lemmih> Azmo: If you figure out how to do it in C then it would be trivial to write it directly in Haskell.
08:18:34 <shapr> FFI is allowed too, but obfuscated Haskell is the goal, so doing most of an entry in C would suck.
08:18:42 <Lemmih> Azmo: Without the extra C code, that is.
08:19:03 <Azmo> Lemmih: some kind of c-code inside the haskell code?
08:20:01 <Azmo> Lemmih: ..or how do you mean it could be done directly?
08:20:45 <Lemmih> Azmo: You would never name the DLL name in C so it gotta be some linker option.
08:21:02 <shapr> jethr0: Althought an entry that was designed around doing something insane in the C world from the Haskell world might be nifty.
08:21:50 <jethr0> like what? i've seen this weird haskell entry, that unboxes Ints in memory. how much weirder could i get?
08:22:08 <shapr> Weird has no limits.
08:22:10 <Azmo> Lemmih: the DLL must be named to give me the correct function. atleast in any language where one is not linking.. i think. since the DLLs that the function can come from is any DLL anywhere in the system, so there can be clashes..  like for any imported module in haskell, the module must be specified.
08:22:55 <Lemmih> Azmo: Haskell modules have nothing in common with shared libraries.
08:22:56 <shapr> jethr0: You could use hs-plugins and template haskell to do just in time compilation of running programs?
08:23:26 <jethr0> cale has some code for doing runtime "template haskell" (or was it dons?)
08:23:32 <Azmo> Lemmih: yes they have. they can export "functions".
08:23:34 <shapr> Maybe you could find some way to save profiling data of a running program, and dynamically recompile and reload a faster version based on usage stats?
08:23:57 <Azmo> Lemmih: and names from different modules can clash.. just as for DLLs
08:23:59 <takuan> i'm back again with one of my dirty questions
08:24:11 <sieni> well at least on un*x 
08:24:14 <shapr> Oh, dirty questions...
08:24:20 <shapr> I'm not telling you what I'm wearing.
08:24:27 <takuan> suppose I wanted to have a global kind of variable to count the amount of times one function is called
08:24:37 <takuan> what would you people suggest?
08:24:40 <sieni> it is trivial to load the same .so many times and call functions from whichever .so you want
08:24:50 <sieni> I don't know how windows works
08:24:57 <jethr0> takuan: trace / profiling :))
08:25:06 <jethr0> sieni, nobody does!
08:25:15 <takuan> jethr0: ...
08:25:18 <Lemmih> Azmo: Figuring out how to do it in C (ie. figuring out what you really want to do) would be the good first step.
08:25:20 <sieni> jethr0: how do you know that?
08:25:21 <shapr> takuan: Oh, I have some code by Steve Atkins that does that.. - http://www.scannedinavian.org/~shae/monads/
08:25:40 <jethr0> sieni, just trying to be glib :P
08:25:56 * shapr turns on extra glibs
08:26:01 <shapr> teleglibbed!
08:26:05 <jethr0> *yeah*
08:26:22 <sieni> jethr0: it is needed for example if you want to upgrade a library while the process is running so that operations that are not completed can use the old one
08:26:29 * jethr0 's on a glib'ing spree
08:27:01 <Lemmih> Azmo: Haskell modules are just convenient sugar. They don't exist in the compiled code.
08:27:03 <jethr0> aha
08:27:14 <sieni> you just dlopen() and bind approriate function pointers using dlsym()
08:27:26 <takuan> shapr: eval3?
08:28:10 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:28:23 <shapr> Yup. It's a demo of how you rewrite pure code into monadic code.
08:28:29 <Cale> hehe, have a look at the snippet I pasted :)
08:28:52 <Azmo> Lemmih: hmm.. ok. but names from different modules can still clash in the source, just as they can clash from different DLLs that i want to use. the concept of a namespace is the same in both cases, and names from modules are never used by guessing the module, like for the Beep function.
08:29:11 <Cale> It's a program which detects if it's being compiled by GHC :)
08:30:24 <Lemmih> Azmo: I can only suggest reading up on linkers now.
08:30:57 <Azmo> Lemmih: ok. thx.
08:32:57 <sieni> Azmo: can't you just call the windows api functions LoadLibrary and GetProcAddress
08:33:21 <takuan> shapr: that's not really what I meant to have
08:33:28 <takuan> I wanted something like a gloal variable
08:33:44 <takuan> this is just passing the counting from the one evaluation to the other
08:33:48 <sieni> then tell Haskell that this address is a function pointer of this-and-this type and then just call it using the FFI?
08:36:05 <Azmo> sieni: that would be doing it at run-time, which means i do not have the function at the global scope in my program, which makes it harder to use. anyway, i did try that, but by example crashed after succeeding to run the imported function. ghc gave "main.exe: internal error: resumeThread: thread not found" and ghci just died trying to write to address 0x00000000.
08:37:01 <sieni> Azmo: at least in c you can just bind the resulting address to a global function pointer
08:37:21 <sieni> bind = assign to
08:37:24 <shapr> takuan: State monad?
08:37:29 <Azmo> sieni: true, but not in haskell :].
08:37:52 <musasabi> Azmo: did you do the foreign import dynamic dance?
08:38:34 <musasabi> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html#2 etc
08:38:35 <shapr> Would you say that HsWebForms works roughly like Hibernate?
08:38:48 <Azmo> musasabi: i did: foreign import ccall "dynamic" ... yes.
08:39:26 <Azmo> musasabi: ah, yes, i sort of copied from there.
08:39:35 <musasabi> Azmo: I would just add debugging to see what goes wrong.
08:39:37 <takuan> shapr: dunno
08:39:49 <takuan> i'm reading a paper on global variables in haskell right now
08:40:00 <musasabi> shapr: isn't hibernate O-R mapping?
08:40:03 <shapr> Yup
08:40:14 <shapr> But this guy is talking about web forms as well, so...
08:40:27 <Azmo> musasabi: i'm not too familiar with debugging tools in haskell, and the example is small. it does not make too much sense why it fails.
08:40:53 <tibbe> Cale, woa that's scarry! i don't even have to state the fact that i'm using a contT anymore...
08:40:57 <musasabi> Azmo: can you print the FunPtr after you get it to check that you didn't get NULL ?
08:41:27 <musasabi> shapr: I am not very familiar with Hibernate, so that makes the comparison a little bit hard.
08:41:28 <tibbe> Cale, oh, perhaps that's because I haven't used callCC yet....
08:41:37 <shapr> True
08:41:46 <shapr> I think Hibernate would be like SerTHDB :-)
08:41:47 <musasabi> shapr: the hardest part with hswebforms is the lack of a proper record system in Haskell.
08:42:00 <takuan> shapr: would implicit parameters be something?
08:42:21 <musasabi> it would be much simpler if records would just work(tm)
08:42:23 <Azmo> musasabi: the function is called. i tried both the MessageBoxA in user32 and Beep in kernel32, they both run ok, but fail when returning or something.
08:42:46 <shapr> takuan: Yes, but they can get scary.
08:43:14 <shapr> Some people like them lots though, so you may want to try them.
08:43:24 <musasabi> Azmo: was the type correct? (that is my first intuition. Would result in invalid stubs and thus return into nonsense place)
08:43:53 <takuan> shapr: it's just for counting
08:43:57 <takuan> would it scare me?
08:43:58 <takuan> ;)
08:44:09 <Azmo> musasabi: the type i created for the functions seemed to be correct according to the documentation on MSDN.
08:44:34 <Azmo> type BeepFunction = Word32 -> Word32 -> IO Word32
08:45:24 <shapr> takuan: Ik veit het niet...
08:45:30 <Azmo> BOOL Beep(
08:45:30 <Azmo>   DWORD dwFreq,
08:45:30 <Azmo>   DWORD dwDuration
08:45:30 <Azmo> );
08:45:56 <Azmo> ..accoring to MSDN. where BOOL is 32bit unsigned integer anyway, just as DWORD.
08:45:57 <takuan> gni shapr 
08:46:13 <takuan> u spreikt hollands
08:46:31 <shapr> Ik begrijp het niet! :-)
08:46:36 <takuan> :D
08:46:39 <takuan> don't worry
08:46:40 <shapr> ndm: Check it out: http://lambda-the-ultimate.org/node/view/1169#comment-12705
08:47:03 <lisppaste2> joelr1 annotated #14502 with "dispatchers" at http://paste.lisp.org/display/14502#2
08:47:09 <joelr1> Lemmih: ping
08:47:15 <shapr> takuan: I had a girlfriend from Nijmegen.
08:47:19 <takuan> aha
08:47:25 <takuan> now the picture fits
08:47:26 <ndm> shapr: nice :)
08:47:28 <joelr1> hi sh10151 
08:47:32 <joelr1> hi shapr 
08:47:37 <joelr1> there
08:47:58 <shapr> ndm: I'm gonna have lots of fun with your extensions to HsColour, many thanks :-)
08:48:21 <ndm> shapr, no probs - i want to rewrite HsColour using the Yhc API at some point
08:48:34 <ndm> then i want to add hyperlinks to definitions of variables etc
08:48:37 <musasabi> Azmo: weird, sounds like you are doing things the correct way.
08:48:44 <takuan> damn
08:49:38 <takuan> how do you use implicit parameters?
08:49:44 <takuan> don't seem to find any docs on it
08:50:09 <Azmo> musasabi: is there any difference between "getModuleHandle" and "loadLibrary"? the haddock pages are lacking documentation :/.
08:50:10 <shapr> ndm: That already exists, see http://www.cse.ogi.edu/~hallgren/h2h.html
08:50:39 <Azmo> musasabi: they seem to do the same thing. and the resulting address i get is the same.
08:50:57 <joelr1> help!
08:51:07 <Lemmih> joelr1: pong.
08:51:17 <joelr1> did i do it right in the paste?
08:51:26 <joelr1> cause it's not working for some reason
08:51:48 <shapr> ndm: The downside of h2h is that it requires all the sources in order to make the links. That doesn't work so well for irc pastes, for example.
08:51:52 <ndm> shapr, thanks! i think i can do better though :)
08:52:10 <takuan> shapr: any links on how to use implicit parameters?
08:52:22 <Lemmih> joelr1: Looks right. Does it compile?
08:52:28 <ndm> although that is pretty nice, even if the first 3 examples are all broken...
08:52:50 <joelr1> Lemmih: compiles
08:52:54 <joelr1> does not work, though
08:53:03 <joelr1> no dispatchers are called
08:53:50 <shapr> takuan: This isn't exactly a tutorial - http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters
08:54:39 <Lemmih> joelr1: Will any of the dispatchers return 'Start'?
08:54:50 <joelr1> no
08:55:03 <joelr1> either Skip or Stop
08:56:35 <Lemmih> joelr1: You could print the number of dispatchers and put a debug statement in 'statusPlus'.
08:57:13 <joelr1> i do print the # of dispatchers (1) but i'll put a debug statement in StatusPlus
08:57:16 <joelr1> doing
09:00:15 <astrolabe> haskell hurts my head.
09:00:31 * shapr hugs astrolabe 
09:00:49 <astrolabe> ah thanks shapr
09:01:17 <pesco> Greetings everyone!
09:01:31 <astrolabe> hi pesco
09:01:48 <Saulzar> It's fun that way (hurt head), better sense of acheivement 
09:02:23 <astrolabe> yeah, if you don't hurt your head every now and again, you get stupid.
09:03:21 <poetix> @seen shapr
09:03:22 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 2 minutes and 50
09:03:22 <lambdabot> seconds ago.
09:03:37 <poetix> Ooh, got his own channel now...
09:10:02 <astrolabe> Is it always possible to be in just one monad at a time? or do they get tangled up sometimes?
09:10:46 <shapr> Er, what do you mean?
09:11:11 <tromp_> you can easilu nest them
09:12:24 <astrolabe> Well, I'm planning to have a monad to keep track of my program state, but I need to use IO too.  For the sake of my sanity, I would like to write only functions that see at most one monad.
09:12:50 <poetix> IORefs probably the easiest solution there
09:13:15 <Cale> well, State monads are for pure computations which you want to perform
09:13:22 <Cale> but which need a state parameter
09:13:30 <Cale> IO is just for IO
09:13:42 <astrolabe> Cale:right.
09:13:58 <astrolabe> does that mean I don't have to mix them up if I think about it correctly?
09:14:04 <Cale> yeah
09:14:06 <tromp_> IORefs is both easiest and ugliest solution:(
09:14:19 <Cale> I mean, you could write a State computation for computing an IO action
09:14:36 <Cale> state transforming the IO monad seems possibly silly
09:14:48 <Cale> seeing as there are IORefs, MVars, etc.
09:14:54 * astrolabe replaces his thinking cap
09:16:30 <int-e> hmm. How about ReaderT (MVar State) IO  ... (or IORef if concurrent access is not an issue)
09:18:30 <int-e> hmm. but that seems to solve a slightly different problem.
09:23:50 <benny> guys check it out, i made a gui for one of the examples in hs-plugins:
09:24:07 <benny> http://img16.imageshack.us/img16/1892/stringprocgui0014eb.png
09:25:04 <Lemmih> Cool.
09:25:10 <Lemmih> @karma+ benny 
09:25:10 <lambdabot> benny's karma raised to 1.
09:25:42 <shapr> benny: spiffy!
09:25:58 <benny> sweet :D i'm now adding a panel for showing compilation errors
09:28:25 <jethr0> shapr, unfortunately my idea for obfuscated haskell is unfeasible
09:28:46 <jethr0> i wanted to write an interpreter for a subset of haskell, write it in itself and then have some recursion fun
09:29:13 <jethr0> :(
09:29:45 <SamB> shapr: where shall I put my article?
09:30:12 <SamB> (it isn't done yet)
09:30:43 <shapr> Put it on TmrWiki?
09:30:46 <astrolabe> My problem: I'm writing a module that exports a parser ::[char]->[char].  The behaviour of the parser will depend on a user supplied 'function'::Command->Response, but I want the user to be able to make the 'function' dependent on history, IO, or anything else he wants.  Is there a way to get this functionality?
09:30:47 <shapr> Do you have a login there?
09:31:04 <shapr> astrolabe: Oh, check out Yi.
09:31:27 <astrolabe> sapr: you mean re my question?
09:31:37 <SamB> shapr: no
09:31:42 <ndm> astrolabe: Monad m => (Command -> m Response) -> String -> m String
09:31:45 <SamB> at least, I don't think so
09:31:53 <shapr> jethr0: http://www.haskell.org/tmrwiki/ImpureThoughts_2f1
09:32:09 <shapr> astrolabe: Yes, Yi does that.
09:32:44 <jethr0> shapr, cool. i'd read that one, but i'll have another look :)
09:32:54 <astrolabe> thanks, and thanks ndm:  I'll have to stare at that.
09:33:03 <shapr> SamB: Create an account, I assume you'll make SamuelBronson?
09:33:30 <SamB> shapr: oh. I was going to go with SamBronson like on hawiki
09:33:38 <shapr> ok, works for me
09:33:52 <astrolabe> shapr: does Yi use the solution ndm is suggesting?
09:33:53 <SamB> good, 'cause I already clicked the button ;-)
09:34:48 <shapr> astrolabe: Not exactly. Yi uses hs-plugins so you can change everything at runtime.
09:35:49 <astrolabe> shapr: that sounds like a sledge-hammer to crack a nut.  I only need to choose at compile time.
09:35:55 <SamB> so, shall I put it in "SamBronson/"?
09:36:38 <shapr> SamB: If you want. I'm not picky.
09:37:46 <shapr> hiya Xianianol 
09:37:56 * takuan really doesn't get the picture about implicit paramatere stuff
09:39:18 <shapr> takuan: Roughly, scope dependent expansion of a variable.
09:39:24 <astrolabe> takuan: it's worth perservering with, it's very cool stuff.
09:39:36 <shapr> It can break beta-reduction, that why I don't mess with it.
09:39:59 <shapr> Xianianol: Learning Haskell? Have any questions?
09:40:08 <astrolabe> oh, you mean you aren't talking about hiding parameters in a monad? :(
09:40:29 <takuan> mmm
09:42:01 <astrolabe> I think I'll try ndm's way.
09:45:10 <astrolabe> is there a predefined 'identity' instance of Monad?
09:46:32 <takuan> humz
09:46:39 <takuan> what's the deal with this?
09:46:41 <takuan> Implicit parameters escape from the monomorphic top-level binding
09:47:10 <takuan> how can I make it non-escaping?
09:49:36 <takuan> help?
10:08:44 <benny> anyone seen dcoutts?
10:09:02 <Lemmih> @seen dcoutts 
10:09:02 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #
10:09:02 <lambdabot> haskell. Last spoke 1 hour, 28 minutes and 19 seconds ago.
10:10:29 <jethr0> anyone got a recommendation for a good TemplateHaskell tutorial/paper?
10:10:41 <benny> anyone know if gtk2hs is supposed to have support for GtkMessageDialog? i can't find it :'(
10:10:56 <jethr0> there's so much material out there, but hard to decide which one would get met up to speed best/fastest...
10:14:50 <SamB> benny: tried grep?
10:16:27 <astrolabe> @eval filter even [1..10]
10:16:28 <lambdabot> [2,4,6,8,10]
10:16:43 <astrolabe> why doesn't lambdabot speak privately to me anymore?
10:17:20 <Cale> are you registered?
10:17:35 <takuan> can anybody help me out on this implicit parameter stuff?
10:18:05 <takuan> if you bind the variable from the top invocation, it doesn't seem to change anymore
10:18:17 <takuan> or do I consider them to be more than they are?
10:18:26 <astrolabe> Cale: I'm IDENTIFY(ed) if that's what you mean.
10:18:42 <Cale> astrolabe: hmm
10:22:39 <Xianianol> Humm, a mini-problem here. I am using lookup which returns a "Maybe a", however, the function I am using lookup returns "a". So, I thought that I just need to check if lookup == Nothing by using "isNothing", but it stills complains that it is returning "Maybe a" instead of "a".
10:23:16 <Heffalump> case lookup ... of {  Nothing -> error "..." ; Just x -> ... x ... }
10:23:38 <Cale> Xianianol: you have to deal with the case when the item isn't found
10:23:54 <Cale> 'maybe' is a handy function
10:23:57 <Cale> @type maybe
10:23:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:24:43 <Xianianol> Well, yes, I told it that: isNothing(lookup v env) = 0 // In a guarded conditional statement
10:24:56 <Xianianol> So, if it returns
10:25:09 <Xianianol> "Nothing", I will assign it as "0".
10:25:18 <Cale> maybe 0 id (lookup v env) ?
10:26:14 <takuan> why does
10:26:15 <takuan> do let ?count = 1 in print ?count
10:26:23 <takuan> print ?count
10:26:30 <takuan> give me as output
10:26:30 <takuan> 1
10:26:31 <takuan> 0
10:26:32 <takuan> ?
10:26:55 <Cale> takuan: um, why should it do anything else?
10:27:07 <takuan> well, because I expect ?count to have changed
10:27:09 <Cale> well, perhaps the second line should be an error
10:27:16 <takuan> but apparently I'm expecting the wrong thing
10:27:18 <Cale> because ?count isn't in scope
10:27:31 <takuan> well, ?count was bound lower
10:27:38 <Cale> oh
10:27:41 <Cale> to 0
10:27:43 <Cale> then yeah
10:27:44 <takuan> yup
10:27:55 <Cale> that's exactly what it should do
10:27:58 <takuan> mmm
10:28:02 <Cale> let rebinds it locally
10:28:06 <takuan> then i'm looking for the wrong thing
10:28:53 <Cale> it doesn't matter what order the lines are in
10:29:14 <takuan> i'm looking for something which changes and keeps changed
10:29:25 <Cale> takuan: use a State monad
10:29:44 <takuan> do I have to pass it everywhere around Cale?
10:29:45 <Cale> what are you trying to do?
10:30:00 <takuan> well
10:30:16 <takuan> say I wanted to debug a program and have some variable which counts
10:30:39 <Cale> counts?
10:30:42 <takuan> uhu
10:30:46 <Cale> counts what?
10:30:51 <takuan> no matter what
10:30:53 <takuan> no logic
10:30:57 <Cale> um
10:31:00 <Cale> huh?
10:31:02 <takuan> it's for debugging purposes
10:31:13 <Cale> uh, sure...
10:31:17 <Cale> but what is it counting?
10:31:21 <takuan> you want to be able to increase it on several places at once
10:31:29 <Cale> "increase it"?
10:31:38 <takuan> well, for example it might be counting how many times a value is computed
10:32:00 <takuan> at the end of the evaluation you want to show it in the terminal
10:32:11 <Cale> perhaps you want an IORef?
10:32:14 <takuan> and you don't want to have to pass it in parameters
10:32:16 <takuan> maybe
10:32:22 <takuan> how does it work?
10:32:24 <Cale> You can't do that in a pure expression
10:32:28 <takuan> I can't seem to get it to work
10:32:33 <Cale> that has to be in IO, or in State
10:32:37 <Cale> or some monad
10:33:02 <takuan> ok
10:33:08 <takuan> how do I do that?
10:33:12 <Cale> You can't assume that expressions are evaluated in any particular order (though there is an order to it)
10:33:18 <takuan> I know
10:33:33 <takuan> but the counting is something seperate from the result of the function
10:33:52 <Cale> functions only evaluate for their results
10:33:58 <takuan> uhu
10:34:15 <Korollary> takuan: if you want something simpler, look at mapAccumL
10:34:23 <Cale> yeah, you might want that
10:34:45 <takuan> mmm
10:35:45 <takuan> that's not really what I'm looking for
10:36:08 <takuan> probably it is impossible in Haskell except by using some form of debugger
10:36:35 <dcoutts> benny, hia
10:37:07 <Cale> takuan: exactly why do you want to count something?
10:37:23 <Cale> and I don't really understand how it is that the thing should count
10:37:48 <takuan> well
10:37:49 <takuan> look
10:37:56 <takuan> I have a diffusionequation solver
10:38:00 <Cale> okay
10:38:13 <takuan> I have devised several ways to let it iterate
10:38:15 <takuan> now
10:38:38 <takuan> I want a simple way of knowing how many times it has iterated without having to pass the counter with all the function calls
10:38:55 <Cale> perhaps you want to turn on profiling output?
10:39:00 <takuan> maybe
10:39:12 <takuan> the comparison is between C++ and Haskell
10:39:21 <takuan> in C++ you would declare some global variable
10:39:34 <takuan> increase it in the place you iterate
10:39:36 <takuan> and pronto
10:39:42 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:39:57 <Cale> but that's a side effect
10:40:03 <takuan> uhu
10:40:05 <takuan> I know
10:40:39 <takuan> but if you want to program something like that and check what's actually happening you want something like that
10:40:49 <Cale> what you could do is to write a function which does the iteration and passes a parameter along which increments with the recursion. Or do the evaluation in IO and write to an IORef.
10:41:16 <takuan> uhu
10:42:19 <takuan> how does the IORef thing work?
10:42:37 <Cale> or turn on profiling, and the output will tell you how many times each cost centre gets entred
10:42:57 <Cale> as well as how much time and memory are spent on the evaluation inside each cost centre
10:43:16 <takuan> uhu
10:43:17 <takuan> now
10:43:33 <Cale> do ref <- newIORef 0
10:43:46 <takuan> say there are a lot of places where some specific action happens (i.e. update an array)
10:43:52 <takuan> we want to count all those places
10:43:53 <Cale> er, I need to give this thing a name
10:44:06 <takuan> then you have to add all the info you get from your profiler
10:44:24 <Cale> not if the cost centre is in the updating function
10:44:29 <takuan> uhu
10:44:37 <takuan> but imagine it isn't
10:44:38 <takuan> :D
10:44:42 <Cale> um, okay
10:45:00 <Cale> so you open up ghci and get it to add the numbers for you :)
10:45:28 <Cale> possibly you can name the cost centres the same thing
10:45:37 <Cale> though I've never tried that
10:46:48 <Cale> no, I think they'll still be separate
10:47:07 <takuan> yup
10:47:10 <takuan> i'm afraid so
10:47:29 <Cale> however, that number is kind of stupid anyway
10:47:35 <Cale> it doesn't mean a whole lot
10:47:51 <Cale> well, it can
10:48:54 <takuan> it can very well mean a lot
10:49:04 <takuan> the emphasis in my thesis is on numerics
10:49:07 * pesco tries to survey the jungle of Haskell (binary) IO libraries.
10:49:08 <dcoutts> ibid, so I've changed my grammer to be exactly as specified in the C99 report. It is ambiguious unless one distinguishes ordinary identifiers from typedefed identifiers.
10:49:57 <takuan> if you want to compare both versions to see if they converge in the same amount of steps it would be a very important number
10:50:14 <Cale> oh, you're counting steps in that sense
10:50:21 <ibid> dcoutts: the grammar is ambiguous, but that's not how it's supposed to be resolved
10:50:24 <takuan> if one of both version (in C++ and Haskell) converges slower with the exact same algorithm it would show you a bug
10:50:26 <Cale> then for god's sake, use a writer monad :)
10:50:37 <takuan> ok
10:50:38 <dcoutts> ibid, how should it be resolved?
10:50:48 <Cale> If you actually care about that number
10:50:57 <Cale> and you don't just want something approximate
10:51:10 <Cale> you don't know what the compiler is going to do in optimisation
10:51:27 <takuan> that's true
10:51:32 <takuan> but that's true in C++ as well
10:51:39 <Cale> it assumes that it can do much stronger transformations than one can do with C++ code
10:51:46 <takuan> for debugging purposes you usually turn off optimisations
10:51:52 <dcoutts> ibid, in the Bison manual it says gcc uses the trick I use.
10:51:54 <dcoutts> http://dinosaur.compilertools.net/bison/bison_10.html
10:52:39 <takuan> Cale: where can I find the simplest example of a writer monad?
10:52:49 <takuan> (sorry me is absolutely noobs @ monads)
10:53:29 <Cale> http://www.nomaware.com/monads/html/writermonad.html has a bunch about it
10:53:48 <takuan> http://haskell.org/hawiki/MonadWriter?
10:53:51 <Cale> you might actually find it easier to work with State
10:54:13 <dcoutts> ibid, sorry I started talking about this issue again, I've actually got to go
10:54:16 <Cale> but yeah
10:54:36 <takuan> well, it seems to be intended for that purpose
10:55:45 <ibid> dcoutts: the resolution is that if a thing is syntactically both a declaration and an expression, it is resolved in favour of one of them, i can't remember which
10:55:49 <Cale> If you just want a count, do something like  newtype Counter = Counter Integer deriving (Eq, Show, Num, Ord, Enum); instance Monoid Counter where mempty = Counter 0; mappend = (+)
10:56:07 * ibid is checking the standard
10:56:11 <Cale> and use that as the w type in your writer
10:56:19 <dcoutts> ibid, the example is "foo (x);"
10:56:41 <dcoutts> ibid, if foo is a typedef then it parses one way, if it's not it parses another way.
10:57:06 <dcoutts> eg typdef int foo
10:57:25 <Cale> inc = tell (Counter 1)
10:57:50 <dcoutts> ibid, in that case it's a variable decl, otherwise it's a call to function foo.
10:58:00 * dcoutts actually really must go.
10:58:04 <Cale> actually,  inc = tell 1
10:58:10 <Cale> since it's deriving Num
10:58:31 <ibid> dcoutts: it seems to me that the correct resolution is to use GLR and disamb in the semantic code
10:59:12 <takuan> humz
10:59:23 <takuan> diffusion2d.o: In function `__stginit_Main_':
10:59:23 <takuan> : undefined reference to `__stginit_ControlziMonadziWriter_'
10:59:23 <takuan> collect2: ld returned 1 exit status
10:59:36 <Cale> compile with --make ?
10:59:50 <takuan> ah
10:59:56 <takuan> now it's o
10:59:56 <Cale> it's probably not linking with the mtl
10:59:57 <takuan> k
11:00:03 <takuan> now
11:00:20 <takuan> do I put inc = tell 1 simply in the code?
11:01:32 <Cale> newtype Counted a = Counted (Writer Counter a) deriving (Functor, Monad, MonadWriter Counter)
11:01:56 <Cale> then any function which needs to count gets a type of the form a -> Counted b
11:03:12 <takuan> uhu
11:03:19 <takuan> now how do I use the thing?
11:03:26 <cbus> aww fuck any zsh user here? :)
11:03:30 <takuan> I just use inc?
11:03:36 <takuan> to increase the value?
11:03:46 <Cale> well, you use do-blocks and put an inc to increment
11:04:01 <takuan> uhu
11:04:17 <Cale> inc :: Counted ()
11:04:18 <Cale> inc = tell 1
11:05:02 <takuan> humz
11:05:09 <takuan> Couldn't match `Counted' against `IO'
11:06:05 <Cale> runCounted (Counted w) = runWriter w
11:06:08 <Cale> it's not IO
11:07:02 <takuan> well
11:07:03 <Cale> here, I'll paste an example usage
11:08:04 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:08:45 <Cale> then at the ghci prompt, type runCounted (f 20)
11:09:54 <Cale> of course, that's the awful recursive version of fibonacci, so it won't perform very well, but it will tell you how many recursive cases it handled
11:10:18 <ibid> dcoutts: actually, i seem to be misremembering things. GCC's might be the best approach, actually
11:10:35 <takuan> ok
11:11:20 <xerox> @index const
11:11:20 <lambdabot> Prelude
11:11:25 <xerox> @libsrc Prelude
11:11:25 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
11:11:54 <Cale> heh, it's actually the next fibonacci number decremented by 1
11:12:04 <xerox> const f _ = f -- right?
11:12:15 <Cale> xerox: yep
11:12:29 <xerox> Is it the idiomatic way to write it?  hm.
11:12:50 <Cale> const k = \x -> k
11:12:58 <xerox> AH!
11:13:01 <takuan> thanks a lot Cale 
11:13:03 <benny> dcoutts: hey
11:13:06 <xerox> Okay.
11:13:08 <Cale> takuan: no problem
11:13:27 * shapr is idiotmatic!
11:13:32 <xerox> shapr: show you \k
11:14:01 <xerox> being stoned doesn't help very, very much programming.
11:14:45 <shapr> That's true. You should never stand under rocks while coding.
11:15:05 <shapr> Wow, the ten weirdest usb drives post on Slashdot really does have some weiiird drives.
11:18:55 * cjb` likes the sushi drives.
11:19:06 <xerox> cjb !!
11:23:01 <cjb> xerox: http://www.dynamism.com/sushidisk/
11:34:38 <Cale> I think mixing the spaghetti extension cable with the thumb drive would look nice
11:34:56 <xerox> How cool :-)
11:36:23 <Cale> An original documentary by Kirby Dick, called "This Film is Not Yet Rated" has been assigned an NC-17 rating by the MPAA.
12:00:44 <MacVince> Hello everyone.  Haskell newbie here, I just wanted to know if it was possible to define named functions in GHCi?  When I type 'double x = x * x', I get a parse error on input '='
12:00:57 <psi> let double x = x * x
12:01:31 <MacVince> psi: Thanks.
12:03:01 <MacVince> psi: while we're at it, how can I have the type signature of a function?  In O'Caml, you just type the name of the function as I recall.  Haskell gives an error message, with the signature, granted, but I don't feel this is the cleanest way.
12:03:16 <palomer> > let double x = x*x in double -5
12:03:17 <lambdabot>  add an instance declaration for (Num (a -> a))
12:03:17 <psi> :t <function>
12:03:37 <palomer> function application should be right associative.
12:03:55 <Cale> MacVince: however, you're not really intended to use it that way
12:03:59 <MacVince> psi: super, thanks a lot. 
12:04:19 <MacVince> Cale: use "what" that way?
12:04:24 <Cale> ghci
12:04:53 <MacVince> Cale: what do you mean?
12:05:07 <Cale> The most common usage is to keep an editor open alongside ghci, and add declarations to a file.
12:05:14 <Cale> You can get ghci to reload it with :r
12:05:41 <MacVince> Cale: okay.  Still fighting with haskell-mode
12:05:52 <MacVince> (in Emacs, of course)
12:05:57 <Cale> what exactly is wrong with it?
12:06:17 <MacVince> Oh nothing, just trying to figure out how the Return key works.
12:06:21 <Cale> ah
12:06:38 <Cale> I find that the simple indent mode is a lot more pleasant
12:06:41 <Cale> you might try that
12:07:26 <MacVince> I certainly will.
12:07:55 <MacVince> I'm going over Yet Another Haskell Tutorial.  The material in it seems quite good.
12:08:10 <Cale> yeah, it's a pretty decent tutorial
12:08:12 <MacVince> But they don't go deep into Emacs stuff at the beginning
12:08:22 <Cale> It's a little incomplete in various ways
12:08:40 <Cale> but there are more tutorials :)
12:09:10 <MacVince> Cale: I don't need something too newbish, I've done my share of O'Caml, Common Lisp and Scheme, so functional programming isn't foreign to me.  But YAHT is very well written and very nicely edited
12:09:25 <Cale> yeah
12:09:32 <MacVince> And for the more advanced stuff, I'll see if I'm still around in a month or so :)
12:09:41 <Cale> You might actually enjoy the "Gentle Introduction" too
12:09:59 <Cale> It's not all that gentle if you don't come from an FP background :)
12:10:42 <Cale> hmm, Haskell doesn't appear to have a way to break numeric literals across lines
12:13:27 <palomer> Cale: know anything about environment mapping?
12:13:53 <Cale> palomer: Well, I can guess how it's done :)
12:14:38 <Cale> just take the angles at which a ray leaves the scene and map that to a colour.
12:15:02 <palomer> leaves the scene?
12:15:09 <Cale> (in, say, spherical coordinates)
12:15:21 <Cale> yeah, you're raytracing right?
12:15:24 <palomer> yeah
12:15:29 <palomer> so I have rays leaving my eye
12:15:33 <Cale> right
12:15:35 <palomer> and hitting this sphere
12:15:43 <palomer> and bouncing off and hitting some colour
12:15:56 <Cale> and at each iteration, they either hit something, or they leave the scene to infinity
12:16:12 <palomer> assume they never leave the scene
12:16:33 <Cale> hmm
12:17:02 <Cale> doesn't that sort of defeat the point of environment mapping?
12:17:21 <palomer> except that the ray is assumed to leave from the center of the sphere
12:17:37 <Cale> uh, hm?
12:17:51 <palomer> ok, the ray hits the sphere and bounces off
12:17:59 <Cale> yeah
12:18:12 <palomer> the ray that bounces off is determined by: an initial position and 2 angles
12:18:13 <palomer> agreed?
12:18:33 <Cale> sure
12:19:03 <palomer> so you change the initial position so its the center of the sphere
12:19:22 <palomer> (if the sphere is small enough and the scene large enough then it's a good approximation)
12:19:27 <palomer> and then you trace it off that
12:19:43 <Cale> I suppose you could
12:19:50 <palomer> from my understanding, this means that you only need to project the scene once onto the sphere
12:20:07 <Cale> um, what about reflections?
12:20:33 <Cale> I suppose it will work
12:20:43 <palomer> the reflection is in the projection
12:21:15 <astrolabe> Are there any objects except the sphere?
12:21:29 <Cale> It'll look wrong if there's, say, a wall
12:21:43 <Cale> since you'll see through the wall to the environment
12:21:47 <Cale> in the reflection
12:21:59 <MacVince> Cale: is there a way to use GHCi from within Emacs?
12:22:25 <Cale> MacVince: I think so, but I never did
12:22:30 <MacVince> ok
12:22:33 <MacVince> I'll dig into that.
12:22:37 <palomer> http://www.cim.mcgill.ca/%7Elanger/557/lecture17.pdf
12:22:47 <palomer> I'll see through the wall?
12:22:49 <Cale> I basically just used emacs as an editor :)
12:23:00 <palomer> only if I could see through the wall if I was looking from the point of view of the sphere
12:23:39 <Cale> ah, okay, I see what you want to do
12:24:05 <Cale> That's a different sort of environment mapping than I'm used to
12:24:16 <Cale> but yeah, okay, you can do that
12:24:49 <astrolabe> I don't think it will work if there is anything close to the sphere (where 'close' is measured in radii).
12:25:09 <Cale> It'll work, but not if those things are reflective
12:25:29 <palomer> "The directions of the unit sphere and represented by a disk, and so the environment map is defined on this disk" <--does this make sense?
12:25:34 <astrolabe> because of the change in origin of the reflected ray.
12:25:55 <Cale> palomer: perhaps a disk with an additional point
12:26:20 <palomer> the directions of a unit sphere is a disk?
12:26:22 <palomer> what does that mean!
12:26:44 <Cale> palomer: think of taking a rubber disk and bending it around a sphere
12:27:04 <Cale> if it was really stretchy, you'd miss out only one point
12:27:09 <astrolabe> There is a map got by projecting from the south pole onto the plane through the equator.
12:27:12 <palomer> and you'd have huge overlap
12:27:27 <astrolabe> that is what astrolabes use!
12:27:28 <Cale> well, you can map a sphere to the complex plane
12:27:34 <Cale> which is basically an open disc
12:27:41 <palomer> true
12:28:10 <palomer> so I map to this disk?
12:28:26 <Igloo> Why would you miss a point? Wouldn't you rather duplicate the equator points?
12:28:37 <Cale> Igloo: hm?
12:28:47 <Cale> You mean, map to 2 discs?
12:29:12 <Igloo> Essentially, yes
12:29:20 <Igloo> I don't see the 1 disc
12:29:20 <Cale> but that's not the same thing :)
12:29:48 <palomer> don't you guys hate when students love a prof, and then you find out that he doesn't really know what he's talking about
12:29:50 <Cale> Imagine a stretchy sheet folding around the sphere
12:30:12 <Cale> If you take a sphere, and delete a point, it can be stretched out to a disc
12:30:25 <Igloo> Oh, I think I see
12:30:28 <int-e> Igloo: I think you're right - the 'point' directly behind the sphere is mapped to the equator.
12:30:49 <int-e> (I say 'point' but actually it's a direction)
12:30:50 <Igloo> Although I would have thought the discs circumference all mapped to teh same point
12:30:53 <Cale> int-e: ah, in that sense
12:31:08 <araujo> @pl (\ s -> if s == '%' then ' ' else s)
12:31:08 <lambdabot> flip if' ' ' =<< ('%' ==)
12:31:10 <Cale> yeah, you could do that too
12:31:11 <jethr0> anyone know a good template haskell tutorial? i can't seem to find one...
12:31:18 * araujo loves lambdabot 
12:31:37 <Cale> jethr0: it doesn't exist, though you can read through lots of papers and hope that things haven't changed too much
12:31:43 <astrolabe> an open disk doesn't contain its circumference.
12:31:43 <palomer> Cale: if you stretch a sheet around a sphere, you'll get overlap, no?
12:32:05 <jethr0> cale, what a pity... if i'm not too lazy, i might write one myself :P
12:32:05 <Cale> palomer: a closed disk?
12:32:22 <palomer> Cale: sure
12:32:42 <palomer> say you stretch taking the north pole as the center of your disk
12:32:45 <Cale> palomer: if you delete a point from a sphere, you get something homeomorphic to an open disc 
12:32:48 <palomer> then you'll get tons of overlap in south africa
12:33:01 <Cale> why?
12:33:39 <Cale> not if you don't crinkle the sheet :)
12:33:41 <palomer> because the circumference of the disk near the outer edge will be greater than the circumference of the sphere 
12:33:44 <araujo> > map flip if' ' ' =<< ('%' ==) "hello there"
12:33:45 <lambdabot>  Not in scope: `if''
12:33:51 <Cale> palomer: yes
12:33:58 <jethr0> imagine folding a circle in half, fusing the edge and then blowing air into it
12:33:58 <araujo> > map (flip if ' ' =<< ('%' ==)) "hello there"
12:33:59 <lambdabot>  parse error on input `if'
12:34:00 <Cale> but it's stretchy :)
12:34:02 <astrolabe> http://en.wikipedia.org/wiki/Stereographic_projection
12:34:29 <Cale> the sampling isn't uniform
12:34:41 <Cale> you'll have areas with higher and lower resolution
12:35:08 <palomer> you can't really use that mapping for environment mapping then, can you:O!
12:35:14 <Cale> Sure you can
12:35:37 <Cale> with a high enough resolution, you won't be able to tell
12:35:45 <araujo> If anyone has been paying attention to my @pl , does that make sense?
12:35:46 <int-e> or with clever alignment
12:35:57 <int-e> imagine a day with a blue sky, no clouds ...
12:35:58 <astrolabe> Though it might be easier just to use lan/long
12:36:16 <astrolabe> *lat/long
12:36:17 <araujo> @index if'
12:36:18 <lambdabot> bzzt
12:36:19 <Cale> astrolabe: I agree
12:36:20 <int-e> and you take a photo of a reflective sphere, pointing the camera upwards
12:36:21 <araujo> @index if
12:36:21 <lambdabot> bzzt
12:36:37 <int-e> that should work quite well
12:36:46 <Cale> araujo: if' isn't in the Prelude or libraries
12:36:58 <palomer> ok, so what do I use as my projection?
12:36:58 <Cale> @pl \x y z -> if x then y else z
12:36:59 <lambdabot> if'
12:37:01 <araujo> Cale, mmm.. isee...
12:37:11 <palomer> why not just trace rays from the center of the sphere?
12:37:20 <palomer> sounds soo much easier to me!
12:37:22 <araujo> lambdabot, That is cheating :-P
12:37:38 <Cale> palomer: the question is which set of rays?
12:37:47 <int-e> palomer: well, conceptually that's what environment mapping does
12:37:49 <palomer> Cale: eh?
12:37:52 <Cale> and how do you organise those rays?
12:37:57 <astrolabe> I thought we were doing that
12:37:58 <palomer> Cale: uniformally
12:37:59 <Cale> well, you can't trace them all
12:38:03 <int-e> palomer: only they want to use precalculated results which have to be stored somewhere
12:38:12 <palomer> Cale: sure, you get a spheremap of a certain resolution
12:38:12 <Cale> what do you mean "uniformly"?
12:38:14 <int-e> palomer: and the question is, how do you store them in a texture?
12:38:48 <Cale> random uniformly distributed points?
12:38:49 <palomer> err
12:38:58 <palomer> you set up a map: angle * angle -> colour
12:39:11 <Cale> yeah, an array
12:39:12 <palomer> where angle is, say, integral
12:39:30 <int-e> palomer: ok, but until recently, graphics hardware couldn't do that - calculate angles from rays.
12:39:33 <palomer> and then if you want the map at (2.5,3.4), you'd call map(2,3)
12:39:53 <Cale> palomer: but that's just one way
12:40:07 <Cale> that's like wrapping a rectangular sheet around the sphere
12:40:31 <Cale> the cube map will work better, I think
12:40:37 <palomer> I don't see how it's like wrapping a rectangular sheet around the sphere
12:40:45 <palomer> int-e: so how can you get around this?
12:40:56 <palomer> and there is a cube environment map
12:41:03 <palomer> but I have to use a sphere environment map
12:41:10 <Cale> palomer: imagine storing the results of map?
12:41:13 <int-e> palomer: well, disk projection is one trick. cube maps are also quite usable, but they require 6 textures
12:41:16 <Cale> What would you store them in?
12:41:34 <Cale> you have to memoise them somehow
12:41:39 <palomer> it's an array
12:41:44 <Cale> what kind of array?
12:41:55 <palomer> a 360x360 array
12:42:04 <Cale> 180 x 360
12:42:07 <palomer> yeah
12:42:15 <Cale> a rectangular array
12:42:17 <int-e> highly non-uniform
12:42:23 <palomer> how so?
12:42:24 <Cale> which you're wrapping around a sphere
12:42:26 <int-e> (after projecting to the sphere)
12:42:33 <Cale> you get lots and lots of points at the poles
12:42:40 <Cale> and few near the equator
12:42:49 <int-e> (but that's not an issue that's likely to go away)
12:42:53 <palomer> Cale: ok, given
12:43:05 <palomer> how do you fix this?
12:43:11 <Cale> there are other good projections
12:43:33 <palomer> int-e: yeah, non uniformality is a problem
12:43:34 <int-e> cube maps are actually quite good at being uniform ... not perfectly, but much better than disk maps or a longitude/latitude-map.
12:43:40 <palomer> int-e: I'm guessing that's where the disk comes in, right?
12:43:41 <Cale> If you wanted one which was quite smooth, but annoying to compute, you could use an icosahedron
12:43:53 <Cale> and store triangular textures
12:43:56 <int-e> palomer: nah, the disk map is also highly non-uniform.
12:43:59 <palomer> I need to use a disk
12:45:10 <Cale> a cube is nicer
12:45:26 <Cale> especially as the faces are a nice shape for data storage
12:46:08 <palomer> I have to admit, this is for homework
12:46:14 <palomer> and he wants me to use the disk
12:46:21 <palomer> so how do I sample the points on my sphere?
12:46:23 * int-e wonders if there will ever be hardware that can render *to* a cube map in a single pass.
12:46:23 <Cale> theoretically, as far as Platonic solids go, the dodecahedron will have the least distortion, but it's probably the most annoying storage-wise
12:46:52 <jethr0> cale, how would one smooth out the non-linearities?
12:47:29 <Cale> jethr0: well, really, the problem is that some areas are going to be at a somewhat higher resolution than others
12:47:43 <int-e> jethr0: you don't really need to. the projection takes a direction, makes a ray from the center of a cube from it and projects to the cube.
12:48:31 <astrolabe> Cale: I would guess the icosohedron has less distortion than the dodecahedron.
12:48:33 <int-e> jethr0: so as Cale says, nonuniform resolution is the only problem you have to deal with - and that'll probably be hidden by interpolation and maybe multisampling
12:48:46 <jethr0> hmm, i just thought one might run into problems at points where three polygons meet
12:49:04 <palomer> sphere -> disk is a stereographic projection?
12:49:19 <jethr0> but i guess this can be avoided by careful mapping in the first place
12:49:27 <astrolabe> sphere -> plane is stereographic
12:50:00 <palomer> gah! so what's sphere -> disk?
12:50:11 <astrolabe> palomer: there are lots
12:50:31 <palomer> what's the best for environment mapping?
12:50:35 <Cale> palomer: it's sphere -> plane -> disk :)
12:50:59 * palomer faints
12:51:01 <Cale> well, it could very well work that way
12:51:16 <Cale> you just take some function like, oh, arctan
12:51:29 <int-e> I find it easier to think of it as sphere -> half sphere -> plane, limited to disk
12:52:35 <palomer> but we'll be missing tons of points!
12:52:47 <int-e> (where the sphere -> half sphere transformations halfs the latitude, measured from 0 at one pole to 180 at the other pole.)
12:53:27 <int-e> it's actually the reverse of the reflection that's described in the pdf mentioned above.
12:53:35 <Cale> what looser types of rebindable syntax will be in GHC 6.6?
12:53:55 <palomer> wait, don't you need two of these projections?
12:54:03 <Cale> oh, I see the link :)
12:54:04 <astrolabe> (lat,long)->(r * cos long,r*sin long) where r = 1+sin lat
12:54:18 <astrolabe> ^^^^^^^^^^ is area preserving
12:54:42 <palomer> one for the bottom of the sphere and one for the top?
12:55:22 <astrolabe> palomer, just one for my scheme
12:57:06 <palomer> astrolabe: yeah, that's the one I first proposed
12:57:30 <palomer> but the people turned it down
12:57:44 <astrolabe> did they say why?
12:58:07 <int-e> astrolabe: hmm, that doesn't look right.
12:58:11 <palomer> the distribution is highley non uniform
12:58:24 <SamB> jethr0: had a look at the beginning of my article?
12:58:29 <palomer> and transforming to polar coordinates is too slow
12:58:36 <jethr0> not yet...
12:58:42 <jethr0> where's it at?
12:58:47 <SamB> thats fine, there isn't much to see.
12:58:55 <astrolabe> the distribution is uniform for area
12:58:58 <SamB> oh. I must have forgotten to identify...
12:59:07 <palomer> astrolabe: but if you discretize it, then it isn't
12:59:20 <SamB> you are away, are you?
12:59:30 <palomer> \x y -> yourmap(floor(x),floor(y)) 
12:59:42 <astrolabe> palomer true.
13:00:14 <palomer> so, to make a long story short, you install a projection plane at the equator and a camera at the pole
13:00:15 <palomer> right?
13:00:16 <astrolabe> Ah no, it isn't even right for area :(
13:00:26 <jethr0> samb, i'm not sure whether i was "technically" way, but i was away from the computer anyways
13:00:46 <jethr0> i've had a look now... keep it going :)
13:00:55 <astrolabe> palomer, that would work for a hemisphere.  for the whole sphere, you would cover the whole plane.
13:01:06 <SamB> anything I don't explain well enough?
13:01:20 <palomer> for the whole sphere, I would need to put my projection plane very close to my camera
13:01:34 <jethr0> samb, PLUS i am getting a little frustrated because i've once again taken on too big a project... a mixed parsec/TH idea of compiling a subset of haskell *g*
13:01:51 <SamB> jethr0: that does sound a bit over-the-top
13:01:55 <astrolabe> palomer: moving the plane just gives you a different enlargement, you still use the whole plane.
13:02:08 <SamB> particularly the part where you try to parse Haskell
13:02:37 <SamB> I guess its easier if you don't support the layout rule, though
13:02:37 <jethr0> samb, you might post a link to the (pretty good) wikipedia page. and you might allude to the turing machine at some point, saying sth about the tape, and so on...
13:02:57 <jethr0> samb, it's not haskell i want to parse. it just has to "look" like haskell :)
13:03:04 <palomer> astrolabe: no way, you don't see anything behind the projection plane
13:03:20 <jethr0> so, it would be accepted by a haskell compiler, but it won't accept _all_ haskell programs
13:03:26 <jethr0> thus "subset"
13:03:40 <astrolabe> palomer: ah, you are using an opaque plane?
13:04:15 <palomer> astrolabe: nope, but it's where the points are drawn
13:04:28 <jethr0> samb, TH is driving me crazy. and the absence of a tutorial doesn't necessarily help *grr*
13:04:44 <SamB> jethr0: theres a tip I left somewhere on hawiki
13:04:51 <astrolabe> palomer: why do you say you won't see anything behind the plane?
13:04:54 <SamB> @hawiki TemplateHaskell
13:04:55 <lambdabot> http://www.haskell.org/hawiki/TemplateHaskell
13:05:04 <palomer> astrolabe: because it's the projection plane!
13:05:21 <SamB> http://www.haskell.org/hawiki/TemplateHaskell#head-5ca50a838f8ee5bf4cf17c9c7e36af6d09ef00c2
13:05:23 <SamB> I think
13:05:27 <jethr0> cool, thx
13:05:40 <Cale> http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html
13:05:51 * xah juggling: http://www.jasongarfield.com/jasonballs.mov
13:05:52 <palomer> http://en.wikipedia.org/wiki/Projective_plane
13:06:27 <Cale> It's not the projective plane, unless your environment identifies opposite sides of the sphere
13:09:18 <SamB> @index appP
13:09:19 <lambdabot> bzzt
13:09:26 <SamB> @index litP
13:09:27 <lambdabot> Language.Haskell.TH.Lib, Language.Haskell.TH
13:09:42 <SamB> looking through Language.Haskell.TH.Lib is useful
13:09:49 <Cale> you might use the Albers Equal-area Conic projection, though it still doesn't quite solve the problem of evenly distributing the points on the cone
13:10:18 <Cale> er, hmm
13:10:30 <Cale> perhaps it does and I'm misinterpreting this :)
13:10:47 <Cale> http://mathworld.wolfram.com/Equal-AreaProjection.html -- there are a bunch of others, anyway
13:12:15 <Cale> http://mathworld.wolfram.com/CylindricalEqual-AreaProjection.html -- this has a nice parametrised formula for cylindrical equal-area projections
13:12:31 <SamB> jethr0: does that look at all useful?
13:14:18 <int-e> r = sqrt(2 - 2 cos(lat)) ... seems to be the right version for polar coordinates.
13:14:37 <int-e> (lat from 0 to 180)
13:14:51 <jethr0> samb, i'll have a look at it shortly...  still struggling with the parsing part :P
13:19:54 <Cale> One neat way to think about stereographic projection and its inverse simultaneously is to think of it as inversion of the sphere and tangent plane through a sphere tangent to the plane at the same point, with double the radius (so it's centred at the north pole)
13:20:04 <palomer> Cale: it's not the projective plane?
13:20:51 <Cale> palomer: oh which plane were you referring to?
13:21:08 <Cale> I thought you were referring to the plane onto which the sphere was being projected
13:21:20 <palomer> oh, you're right, it's an orthogonal projection
13:21:29 <palomer> Cale: I am
13:21:32 <kowey> hi, i just printed a FileMode in octal and got something weird like 100755... the 755 i get, but what's the 100 for?  I tried looking in man 2 chmod... but nothing jumps out
13:22:36 <palomer> I think of it as an orthogonal projection with the normal of the plane (the plane being the equator) with the came at the north pole, thus we get the whole southern hemisphere
13:22:53 <palomer> s/came/camera
13:24:56 <Cale> kowey: see  man 2 chmod
13:24:59 <palomer> oh wait, that's exactly the same as my first proposed projection
13:25:32 <palomer> no wait, it isn't
13:25:40 <kowey> Cale: i did, but i must be missing something, because there don't seem to be any digits defined out that far
13:26:11 <SineTwo> i'm trying to find a position of a certain character, does anyone know why this doesnt work? position :: Char -> [Char] -> Int;position y (x:xs);position y [] = 0;position (x:xs) = 1 + position (x:xs)
13:26:16 <Cale> S_IFIFO    0010000   FIFO
13:26:23 <Cale> from man 2 stat
13:26:38 <jethr0> is it possible to splice strings with TH?
13:26:42 <palomer> x,y -> intersection between vector(north pole, (x,y)) and the sphere
13:26:50 <kowey> ah-hah... would not have known about that... thanks!
13:26:58 <Cale> S_IFREG    0100000   regular file
13:27:09 <jethr0> like "let x = [| "3 + 2" |]" or something?
13:29:21 <kzm_> Good evening!
13:29:29 * kzm_ nods to kzm.
13:29:38 <Cale> jethr0: I don't think so
13:29:40 <Cale> er
13:29:42 <jethr0> :(
13:29:47 <Cale> Well, as strings
13:29:54 <Cale> not as code
13:30:05 <SamB> jethr0: why?
13:30:19 <jethr0> samb, well, it would've made my parsing easier, wouldn't it :)
13:30:28 <SamB> not that I can see!
13:30:42 <jethr0> never mind, 'twas a stupid question to begin with
13:31:13 <SineTwo> anyone? it should be fairly simple, but argh!
13:31:14 <SamB> wouldn't it be easier just do [| 3 + 2 |]?
13:31:43 <jethr0> samb, yes, but for that i have to dispatch the operator-string onto a "real" operator
13:31:49 <SamB> SineTwo: that code makes no sense to me
13:32:04 <jethr0> case oper of "+" -> (+); "-" -> (-); ...
13:32:19 <SamB> jethr0: oh
13:32:25 <SineTwo> SamB: well, i fant to do the following: position 'e' "haskell" gives 5 back
13:32:28 <SamB> you can use a map or something
13:32:34 <Cale> jethr0: what are you trying to do?
13:32:53 <SineTwo> fant = want
13:32:59 <jethr0> cale, writing a parser/interpreter for a (small) subset of haskell
13:33:11 <Cale> If you want typesafe eval of Haskell expressions at runtime, you can use hs-plugins
13:33:42 <jethr0> cale, i know, i just want to try it myself... for educational purposes!
13:33:52 <SamB> interpreter?
13:33:53 <Cale> then TH is cheating :)
13:34:04 <SamB> Cale: not really
13:34:18 <SamB> TH is less cheating than using the linker directly...
13:34:18 <jethr0> *lalala*
13:34:42 <jethr0> interpreter is the wrong word. compiletime compiler describes it better
13:35:04 <Cale> hehe, I have one of those, it's called id
13:35:07 <jethr0> never mind, i'll show it to you guys when (if ever) it works
13:35:07 <Cale> :)
13:35:35 <Cale> It compiles everything that GHC can :)
13:44:02 <gzl> compiletime compiler?
13:44:06 <gzl> isn't that ... redundant?
13:44:16 <jethr0> yes
13:44:42 <gzl> ok.
13:44:43 <jethr0> http://www.haskell.org/tmrwiki/ImpureThoughts_2f1
13:44:48 <gzl> just checking. :)
14:10:15 <jethr0> @seen
14:10:16 <lambdabot> Lately, I have seen jethr0, korollary, musasabi, poetix, sieni and
14:10:16 <lambdabot> syntaxninja.
14:10:22 <SyntaxNinja> y0
14:10:32 <jethr0> wazap
14:12:53 <Heffalump> boo!
14:12:55 <Heffalump> @seen
14:12:55 <lambdabot> Lately, I have seen heffalump, jethr0, korollary, musasabi, poetix, shapr,
14:12:55 <lambdabot> sieni and syntaxninja.
14:13:00 <Heffalump> yay :-)
14:13:22 <SyntaxNinja> heya Heffalump
14:25:18 <Cale> I wonder why people confuse Henning Thielemann and Lemmih, maybe it's the l and h :)
14:26:06 <jethr0> > reverse "hielemann" == "lemmie"
14:26:07 <lambdabot> False
14:26:26 <jethr0> sry, "lemmih"
14:30:18 <kzm_> > map sort ["thielemann","lemmih"]
14:30:19 <lambdabot> ["aeehilmnnt","ehilmm"]
14:30:31 <Korollary> interesting
14:30:47 <kzm_> well - note the core "ehilm"
14:31:13 <jethr0> @hoogle Q IO String -> IO String
14:31:14 <lambdabot> No matches, try a more general search
14:31:28 <jethr0> @hoogle IO String -> Q (IO String)
14:31:29 <lambdabot> No matches, try a more general search
14:31:33 <Korollary> What is Q?
14:31:44 <jethr0> some template haskell type
14:31:48 <Korollary> Ah
14:33:46 <palomer> is there a printf for haskell?
14:33:52 <jethr0> @type printf
14:33:53 <lambdabot> Not in scope: `printf'
14:33:57 <jethr0> @index printf
14:33:57 <lambdabot> Text.Printf
14:34:12 <jethr0> @type Text.Printf.printf
14:34:13 <lambdabot> forall r. (Text.Printf.PrintfType r) => String -> r
14:34:29 <jethr0> > printf "%s %s" "hello" "world"
14:34:30 <lambdabot>  Not in scope: `printf'
14:34:46 <jethr0> *damn* *it*
14:36:29 <palomer> heh
14:37:58 <Cale> try it in GHCi
14:38:24 <Cale> It's quite cool -- it does both printf and sprintf as the same thing
14:38:37 <Cale> no template haskell needed
14:42:20 <Heffalump> type class based?
14:46:48 <Xianianol> Humm, what does "Prelude.read: no parse" means ?
14:47:15 <Xianianol> I've never seen that error before.
14:48:32 <SyntaxNinja> Xianianol: you tried to use "Read" for instance to converta string to an int
14:48:46 <SyntaxNinja> but it wasn't an int; it couldn't parse the string value into whatever you claimed it to be
14:48:57 <SyntaxNinja> > (read "3")::Int
14:48:58 <lambdabot> 3
14:49:10 <SyntaxNinja> > (read "sdf")::Int
14:49:11 <lambdabot> Exception: Prelude.read: no parse
14:49:35 <Xianianol> Humm, I see...Thanks, let me see where did that do that silly mistake then...
14:49:42 <Xianianol> *di I do
14:49:44 <Xianianol> *did
14:51:15 <Heffalump> oh, GHC has switched to trac?
14:51:49 <musasabi> yes
14:52:19 <SyntaxNinja> is that official yet?
14:52:50 <SyntaxNinja> I'm negotiating w/ simon to get a common URL scheme for such things: http://hackage.haskell.org/cgi-bin/trac/trac.cgi/wiki
15:00:40 <Heffalump> is it running darcs+trac?
15:02:03 <twb> @hoogle wiki
15:02:03 <lambdabot> No matches found
15:02:36 <araujo> @where hawiki
15:02:37 <lambdabot> http://haskell.org/hawiki/
15:02:53 <SyntaxNinja> @wiki
15:02:53 <lambdabot> http://www.haskell.org/hawiki/
15:02:56 <twb> I want wiki software written in haskell, not a wiki about haskell.
15:03:03 <SyntaxNinja> @where flippi
15:03:03 <lambdabot> http://www.flippac.org/projects/flippi/
15:03:11 <twb> Cheers.
15:03:24 <SyntaxNinja> Heffalump: cvs.haskell.org/trac/ghc if I recall
15:03:32 <SyntaxNinja> Heffalump: probably, since that's the versin I instaled on that machine:)
15:09:59 <shapr> @seen
15:10:00 <lambdabot> Lately, I have seen araujo, heffalump, shapr, syntaxninja and twb.
15:10:09 <twb> Hullo.
15:11:47 <shapr> g'day
15:12:13 <Xianianol> Humm, what's the best way to debugging in Haskell ? Is there any function like TRACE in ProLog and C, or a proper debugger ? :P
15:12:15 <xerox> What are the semantics of @seen.
15:12:30 <integral> Xianianol: there is Debug.Trace.trace
15:12:42 <shapr> I'm fond of test first debugging.
15:13:01 <xerox> I'm fond of test, first debugging.
15:13:10 <shapr> ?
15:13:21 <shapr> Hey did you see my LtU post with pretty colors?
15:13:25 * xerox hides behind a lambda
15:13:26 <Xianianol> Humm, is just that I don't know where can it be causing an error that does not tell me much.
15:13:43 <shapr> What's the error?
15:13:52 <Xianianol> Prelude.read: no parse; The only part that I've used "read" looks 100% okay!
15:14:11 <shapr> Can you show the line of code?
15:14:23 <shapr> xerox: pretty colors! http://lambda-the-ultimate.org/node/view/1169#comment-12705
15:14:39 <Xianianol> Hard for me to debug when the error does not tell me the line of the error.
15:14:49 <Xianianol> for the function that I've used read ?
15:15:19 <Xianianol> lett :: Parser String
15:15:19 <Xianianol> lett = do xs <- many1 letter
15:15:19 <Xianianol> return (read xs)
15:15:28 * xerox is astonished, this is synhl!
15:15:32 <shapr> Can you show me the line of code where you use read?
15:15:42 <shapr> Xianianol: You must give a type signature.
15:16:02 <Xianianol> lett :: Parser String is the signature, isn't it ?
15:16:02 <shapr> @type read "5" :: Int
15:16:03 <lambdabot> Int :: Int
15:16:08 <SyntaxNinja> lambdabot: stop talking about me so much.
15:16:09 <shapr> @type read "5" :: [Char]
15:16:10 <lambdabot> [Char] :: [Char]
15:17:40 <SyntaxNinja> you can tell you're in #haskell when someone says "what are the semantics of @seen" instead of "what does @seen do?"
15:17:55 <shapr> hah'a
15:22:12 * xerox someoneses
15:25:46 <xerox> @seen
15:25:46 <lambdabot> Lately, I have seen integral, shapr, syntaxninja, xerox and xianianol.
15:25:51 <xerox> Gotcha.
15:43:20 <shapr> jiihaa
15:44:19 <jethr0> @index (if')
15:44:20 <lambdabot> bzzt
15:45:55 <xerox> jethr0: if' x y z = if x then y else z
15:46:21 <flux__> does ghc actually rewrite it that way?
15:46:28 <flux__> that is, ifs to if'
15:46:41 <xerox> I don't really know.
15:47:14 <flux__> hmm.. actually, to implement if you would need to use pattern matching?
15:47:34 <greenrd> to implement if' yes
15:47:49 <greenrd> if can't be implemented because it's not a function, it's a keyword
15:49:23 <flux__> well yeah, but if could be considered mostly to be syntax candy for if', no?
15:50:23 <greenrd> yeah
15:51:07 <flux__> hm, infact maybe an if-like construct could be implemented with plain haskell, something like if'' condition `then` a `else` b ;)
15:51:20 <flux__> then' else' of course
15:51:49 <jethr0> xerox, i was looking where it was defined, because lambdabot @pl returns it
15:51:58 <jethr0> @pl \x y z = if x then y else z
15:51:58 <lambdabot> (line 1, column 8):
15:51:58 <lambdabot> unexpected "="
15:51:58 <lambdabot> expecting pattern or "->"
15:52:04 <jethr0> @pl \x y z -> if x then y else z
15:52:05 <lambdabot> if'
15:55:57 <benny> argh it's hard to be a newbie :'(
15:56:53 <xerox> > let if'' True x _ = x; if'' False _ y = y in if'' (2 + 2 == 2 * 2) "yes" "no"
15:56:54 <lambdabot> "yes"
15:57:49 <jethr0> > let true = 0; false = 1; iff = \x y z -> [y,z] !! x in iff false 0 1
15:57:50 <lambdabot> 1
15:57:52 <xerox> > let if''' c x y | c = x | otherwise = y in if''' (1 > 0) "whooopee" "uh-oh."
15:57:53 <lambdabot> "whooopee"
15:58:52 <jethr0> xerox, that is cheating. guards are an abstraction of "if" already :P
15:59:11 <jethr0> i wanted to do it with "&&" and "||", but haskell's typing doesn't make it any easier
16:01:57 <sh10151> does anyone here have any experience with Scala?
16:03:25 <shapr> Is there anyone here who can't sleep without music?
16:03:33 <shapr> I should take this to #haskell-blah
16:04:34 <sh10151> shapr: heh, I used to be like that, then I married someone who couldn't sleep with music
16:05:35 <jethr0> sh10151, so who's the one that got to sleep?
16:07:28 * xerox laughs
16:07:36 <xerox> > let f = flip (flip . ((!!) .) . flip (:) . return) . fromEnum in f True "Yes!" "No :("
16:07:37 <lambdabot> "Yes!"
16:07:42 <xerox> > let f = flip (flip . ((!!) .) . flip (:) . return) . fromEnum in f False "Yes!" "No :("
16:07:43 <lambdabot> "No :("
16:09:18 <jethr0> > let f c t e = [e,t] !! (fromEnum c) in f False "yes" "no"
16:09:19 <lambdabot> "no"
16:09:48 <xerox> Spoiled.
16:10:01 <shapr> I am not spoiled, I'm just pampered.
16:10:19 <xerox> They hate me because the computer is noisy at 1 am...
16:10:40 <xerox> We'll play another time :-\
16:10:46 <xerox> Sleep well.
16:10:47 <shapr> Oh. My girlfriend is sleeping next to me, even though my keyboard is clicking, and my music is playing.
16:11:34 <shapr> That's actually why I asked that question :-)
16:16:28 <JohnMeacham> me. I can't work without music. or tv.
16:17:37 <astrolabe> I can't think with noise around, except when I'm playing go.
16:17:59 <JohnMeacham> but the best is a noisy bar or public place with lots of people around. I sometimes go to the one up the street just in order to think when it is really crowded. last night I was there telling some guy about impredicative types and HM inference.
16:18:34 <astrolabe> I wish I was like that.
16:19:18 <shapr> JohnMeacham: I feel the same way, but it's hard to find those around here.
16:19:23 <astrolabe> I get the impression that part of my mind doesn't like thinking, and will latch on to any excuse not to.  If there is a conversation it could listen to, it would.
16:19:38 <shapr> We need a Haskell pub.
16:20:49 <JohnMeacham> astrolabe: that's exactly why I need other stuff going on. to keep that part of my brain busy so it doesn't distract the other bits.
16:21:40 <JohnMeacham> shapr: we almost do here in pasadena, I mentioned that run in with the pugs developer, and I ran into a type theorist the other day... it is quite random.
16:21:54 <shapr> Who was the type theorist?
16:22:10 <JohnMeacham> I forget, a caltech postdoc.
16:22:36 <JohnMeacham> we talked theory for a while. he was interested in haskell for its type system but had little interest in programming.
16:24:29 <shapr> hi donghee, learning Haskell?
16:25:01 <shapr> pejo is in the next city over, but I never seem to have time to drop by and have a beer with him.
16:25:07 <shapr> I don't even know if he drinks beer :-)
16:25:12 <JohnMeacham> Caltech is very theory intensive, a lot of the CS classes don't involve computers at all. the first real class you have to take doesn't even teach programming, it is assumed you will pick it up. a prof was known for handing out the homework, and then saying... oh. and this week... let's do it in modula-3 or some other random language so you had to pick up the ability to learn languages quickly as an incidental skill.
16:25:15 <donghee> shapr, yes
16:26:10 <shapr> I'd like that sort of cs program. I like learning new languages.
16:26:23 <jethr0> how do you apply a function to a list of arguments? is there an apply function?
16:26:27 <shapr> My only problem is that I've run out of new and interesting languages to learn...
16:26:34 <shapr> donghee: Do you have any questions?
16:26:38 <gzl> jethr0: map function list
16:26:42 <JohnMeacham> intercal.
16:26:44 <astrolabe> @type map
16:26:45 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:26:55 <jethr0> no, the list contains the arguments to the function
16:26:56 <donghee> shapr, no I have :-)
16:27:04 <donghee> shapr: thx
16:27:07 <jethr0> sorry, i didn't explain that well :(
16:27:09 <gzl> jethr0: why are you doing that?
16:27:16 <shapr> Although I should pick up Mozart/Oz, and I'd like to learn more about Epigram.
16:27:17 <jethr0> template haskell
16:27:25 <gzl> ah, dunno anything about TH
16:27:39 <JohnMeacham> the 'joy' language looks interesting.
16:27:48 <jethr0> well, any ideas on "(+) [2,3]" => 5
16:27:51 <jethr0> ?
16:28:00 <Cale> fold? :)
16:28:19 <jethr0> "if' [True,2,3]" => 2
16:28:20 <Cale> Is this in TH?
16:28:29 <jethr0> no, just a general question
16:28:31 <Cale> of course, that list isn't a list
16:28:33 <jethr0> in scheme this would be apply
16:28:42 <greenrd> shapr: http://www.citeulike.org/user/greenrd/article/342281
16:28:42 <Cale> (think about the types)
16:28:51 <jethr0> true, didn't think about that, thx
16:29:12 <Cale> also, there's no way you'd be able to verify that the list had the exact right number of parameters
16:29:14 <greenrd> shapr: I think Epigram's proof methods are likely to be highly unwieldy
16:29:27 <shapr> How so?
16:29:51 <jethr0> cale, i'm gonna convert the list to a tuple and use curry/uncurry
16:29:56 <astrolabe> @learn
16:29:56 <lambdabot> http://www.haskell.org/learning.html
16:30:02 <greenrd> shapr: well, there are two styles of dependent types I've seen so far
16:30:06 <astrolabe> donghee: check this ^^^^^^
16:30:29 <greenrd> shapr: one is what I call "metrics", e.g. "this list is of length 2". They're ok.
16:31:12 <greenrd> shapr: the other is what I call "relations", where you use phantom types to denote theorems
16:31:17 <Xianianol> Any easy way to put some sort of "printf" statement in the middle of the function for debugging/tracing ?
16:31:41 <greenrd> shapr: The latter looks unwieldy, because it seems you have to contort your code to thread the proof through it.
16:32:16 <greenrd> shapr: Which is not how mathematicians actually work usually (threading their proofs through the theorems they want to prove) so why bother?
16:33:09 <shapr> Xianianol: Debug.Trace.trace
16:34:26 <shapr> Have you used Epigram much?
16:34:33 <greenrd> No.
16:35:03 <shapr> It may look unwieldy, but it's surprisingly fun.
16:35:18 <greenrd> Oh, I'm sure it's fun.
16:35:38 <shapr> For one thing, you incrementally refine the types of everything.
16:35:41 <greenrd> I just question whether it's a useful approach for the more complicated stuff (more complicated than "this list is of length N") :)
16:36:30 <Taral> @seen jethr0
16:36:30 <lambdabot> jethr0 is in #haskell. Last spoke 2 minutes and 51 seconds ago.
16:36:33 <Taral> hm
16:36:36 <shapr> Are there languages that the 'metric' system?
16:37:13 <shapr> I don't understand what the metrics describe.
16:37:47 <gzl> what?
16:38:34 <Lor> Parse error on "?". Expected a verb.
16:38:37 <astrolabe> parse error in shapr at column 20
16:38:57 <jethr0> taral, hm
16:39:55 <astrolabe> Does anyone know anything about natural language parsing?  Are there haskell programs to do it?
16:39:57 <shapr> I sort of understand the TaPL description of 'types indexed by terms' but I don't understand what you mean by metrics.
16:40:15 <shapr> astrolabe: Seen the using types to parse natural languages article?
16:40:29 <astrolabe> shapr: no!  link?
16:41:44 <shapr> http://www.cse.ogi.edu/~mpj/pubs/aug.html
16:41:47 <jethr0> how the f*ck is one supposed to use template haskell if there isn't even the tiniest of manuals/overviews or even commented code *ARG*
16:41:55 <Cale> shapr: I'd normally consider "metric" and "distance" to be about the same
16:41:56 <astrolabe> thanks!
16:42:21 <shapr> jethr0: Good question, I started on a tutorial but never finished it...
16:42:25 <greenrd> shapr: Epigram
16:42:30 <shapr> I think Lemmih worked on a tutorial as well.
16:42:33 <greenrd> shapr: Right at the start of http://www.e-pig.org/downloads/epigram-notes.pdf
16:42:54 <greenrd> shapr: "For example, matrix multiplication may be typed mult : ∀i , j , k : Nat ⇒ Matrix i j → Matrix j k → Matrix i k"
16:43:23 <jethr0> shapr, is that started tutorial available anywhere... maybe i could continue working on it...
16:44:03 * shapr looks
16:44:49 <shapr> http://www.haskell.org/hawiki/TemplateHaskellTutorial
16:45:01 <jethr0> thx
16:46:07 <hulahub> girls!
16:46:11 <shapr> boys!
16:46:45 * shapr turns up the music.
16:47:01 <hulahub> is there a way for embedding Haskell into C/C++/Obj-C or any other language (Ruby, Python, ...) ?
16:47:10 <shapr> Sure, no problem.
16:47:19 <shapr> http://www.haskell.org/hawiki/FfiTutorial
16:47:47 <dons> @seen psi
16:47:47 <jethr0> shapr, what does one have to do to get write access on the wiki?
16:47:47 <lambdabot> I saw psi leaving #haskell 4 hours, 40 minutes and 35 seconds ago.
16:47:55 <shapr> jethr0: login
16:47:59 <jethr0> ah
16:48:17 <shapr> g'day dons
16:48:45 <dons> SamB, do you know what psi means (regarding hmp3 now working on linux/ppc): "SamB's patch must've fixed it (which means that the bug was related to ghci not working)"
16:48:49 <dons> heya shapr.
16:48:53 <hulahub> ah lambdabot is back :D
16:49:05 <dons> lambdabot was away?
16:49:06 <shapr> Everybody loves lambdabot!
16:49:10 <hulahub> > [1,2] ++ [3]
16:49:11 <lambdabot> [1,2,3]
16:49:19 <benny> dons: hey man, you are in charge of hs-plugins, right?
16:49:24 <dons> yup
16:49:32 <hulahub> he was down two (?) days ago
16:49:38 <shapr> greenrd: I don't know, can you show me an example where Epigram is unwieldy, and how to do it better?
16:49:40 <hulahub> smoked too much i think
16:49:51 <jethr0> shapr, is it ok if i muddle with your TH tutorial?
16:49:55 <shapr> Smoked those lambdas.
16:49:58 <benny> dons: when there are errors in the plugin, the line/col numbers don't seem to be correct :|
16:49:59 <shapr> jethr0: Hey man, it's a wiki...
16:50:09 <shapr> jethr0: That means muddling is flat out required.
16:50:10 <jethr0> just asking, wikiquette
16:50:22 <dons> benny, hmm, it'll use line pragmas, so not sure how accurate they are
16:50:23 <shapr> Nah, wikiquette is "change it if you want"
16:50:50 <dons> benny, do you have an example somewhere?
16:50:55 <astrolabe> lambdabot ignores my /msgs   :(
16:51:12 <benny> dons: i have something even better...
16:51:13 <dons> are you registered?/
16:51:18 <astrolabe> she doesn't love me any more.
16:51:39 <astrolabe> I'm IDENTIFYed.  Is that the same thing?
16:51:48 <benny> dons: i have a screenshot :)
16:52:27 <dons> astrolabe, well, lambdabot is identified too. so not sure what's happening. I can talk to her
16:52:32 <dons> benny, yep ok. url?
16:53:29 <benny> http://img215.imageshack.us/img215/6171/stringprocgui0021gh.png
16:53:38 <astrolabe> dons weird
16:53:52 <greenrd> shapr: no I can't, because it's too unwieldy for me to spend time learning ;)
16:54:11 <greenrd> shapr: as for alternatives, I was hoping that paper I linked to might be one, but I haven't read it yet
16:54:16 <astrolabe> ooops: astrolabe has just won the stupid competition.
16:54:18 <dons> benny! lovely :)
16:55:06 <dons> so how is this evaluated? with a merge, make and load? or an eval?
16:55:33 <dons> and benny, what interesting games are you up to? this looks fun...
16:55:57 <benny> dons: hm... i'm not sure exactly, i'm a big haskell newbie... i copy and pasted the code from the StringProc example in the docs :=
16:56:11 <dons> but you wrote this gui?
16:56:19 <benny> yeah
16:57:36 <benny> uses makeWith i guess
16:59:12 <benny> works ok, except for: gui is ugly, those line/col numbers are incorrect, and sometimes i get crash because of error "openFile: resource busy (file is locked)
16:59:37 <dons> hmm. I see that ghc on its own produces the right line number. I suspect  its the pragmas being inserted, and then ghc gets confused. it'll only be 1 line out though.
16:59:52 <dons> use Control.Exception.catch to deal with the openFile issue.
16:59:53 <benny> but also the column is off as you can see
17:00:11 <benny> but i don't understand why the file isn't being closed properly
17:00:17 <benny> i only use readFile and writeFile
17:00:56 <benny> i think hs-plugins/ghc isn't closing the file properly sometimes when there is a compilation error
17:02:04 <dons> ok, so  I don't think there's much I can do about the line pragmas ( but newer versions of ghc have improved line numbers, so you could try that). regarding closing files, I'd need an example, to chase it down.
17:02:33 <benny> so you are the guy that actually wrote all of hs-plugins?
17:03:09 <dons> almost all of it, yes.
17:03:22 <benny> sweet
17:04:40 <shapr> Yeah, much ego boosting to dons for hs-plugins.
17:04:51 <dons> depending on what you're doing , you might want to look at eval()
17:05:27 <benny> yeah, eval might be good
17:05:28 <jethr0> ok, gotta hit the hay. good nite
17:05:33 <shapr> g'nite jethr0 
17:05:48 <shapr> sov gott :-)
17:05:55 <benny> but can eval do long listings, like define multiple functions?
17:05:58 <jethr0> :)
17:06:37 <shapr> dons: How would lambdabot get a message to announce a paste?
17:06:47 <dons> benny, nope. only a single expressoin. (but you can do le x = .. ; y = ... ..
17:07:12 <shapr> malcolm & ndm wrote HsColour, which works nicely: http://lambda-the-ultimate.org/node/view/1169#comment-12705
17:07:24 <benny> ok, that can be a bit annoying though, i think for what i need i won't use eval
17:07:29 <shapr> Now I want to turn that into a decent haskell paste plugin.
17:07:38 <dons> shapr, it can fork a thread that does call backs. some how we'd have to notify the thread (running in .au) of a paste.
17:07:57 <dons> the darcs plugin shows the call back mechanism.
17:08:14 <shapr> xmlrpc?
17:08:25 <shapr> Or wait..
17:08:29 <dons> maybe ? don't know anything about it.
17:08:52 <shapr> Does lambdabot run a tiny http server?
17:09:15 <benny> here's another shot, just for fun:
17:09:16 <benny> http://img220.imageshack.us/img220/8756/stringprocgui0030lp.png
17:09:20 <dons> I mean, it could scan an http pagge.
17:09:37 <dons> it has an http client.
17:09:42 <shapr> ah, good point.
17:09:57 <dons> so just make sure pastes are written in some nice format to an index page
17:10:12 <shapr> Oh I know, lambdabot needs an RSS client with a minor addition.
17:10:24 <dons> hmm!
17:10:42 <dons> good idea. that's exactly what is  needed for a number of problems like this
17:10:48 <dons> including non-local darcs patches..
17:10:54 <shapr> The minor addition is that instead of fetching the entire feed, it fetches a 'timestamp' file that holds just the unix time of the most recent paste.
17:10:57 <shapr> Right, exactly.
17:11:24 <shapr> With the timestamp extension, lambdabot could happily update several times a minute.
17:11:26 <dons> yeah, rss would be the way to go. then it could subscribe to all sorts of annoying noisy feeds :)
17:11:30 <shapr> heh, yes
17:11:43 <dons> this would be cool
17:11:50 * palomer would like to see a squeak like environment for haskell
17:11:54 <shapr> And I'd probably be embarassed into fixing my blog if lambdabot only said "day's entry" every day.
17:11:58 <shapr> palomer: So write it!
17:12:09 <shapr> palomer: Or just use Pivotal / Vitol.
17:12:14 <shapr> er, Vital?
17:12:15 <palomer> too busy writing my stupid ray tracer
17:12:30 <shapr> Well, you makes yer choices...
17:12:37 <benny> palomer: you're also doing a raytracer? :o
17:12:56 <palomer> benny: am I doing anything else?
17:13:08 <shapr> Aren't you chatting on irc?
17:13:24 * shapr 'they call him pendantic' erisson
17:13:47 <shapr> Ok, I'm obviously silly, I need sleep.
17:13:59 <shapr> dons: Hey, did you see the pretty colors on my LtU post?
17:14:04 <shapr> HsColour is cool!
17:14:12 <dons> oh, no?! url?
17:14:27 <shapr> http://lambda-the-ultimate.org/node/view/1169#comment-12705
17:16:17 <shapr> Poetix like that cool trick and tracked down the original polyvariadic args trick - http://okmij.org/ftp/Haskell/vararg-fn.lhs
17:18:27 <shapr> g'day m3ga 
17:19:05 <m3ga> howdy
17:19:49 <shapr> I wonder how I should phrase my posts in an effort to start a conversation rather than stop it.
17:20:09 <benny> this is actually a pretty fun way for a newbie like me to fool around easily with haskell :)
17:20:10 <benny> http://img223.imageshack.us/img223/5392/stringprocgui0046yk.png
17:20:21 <shapr> benny: Want to write a TMR article about this?
17:20:28 <benny> TMR?
17:20:31 <shapr> The Monad.Reader
17:20:40 <benny> ah, hm... when do you need an answer?
17:20:55 <shapr> Sometime before the heat death of the universe.
17:21:01 <dons> benny, really nice :)
17:21:19 <dons> writing your own haskell environment would be a good way to learn haskell ;)
17:21:23 <shapr> truly
17:22:21 <dons> hscolor looks cool shapr. i'll have to use it now.
17:22:34 <dons> hscolour. i've been colonised! :/
17:24:05 <shapr> haha
17:24:15 <benny> shapr: it's an idea i guess, but two things: i) my style of writing is "different" ii) i'd need someone to go over the code with me, i don't want to publish something embarrasing :)
17:24:47 <dons> benny, I'd be happy to review and suggest  things
17:24:48 <shapr> TMR uses wikipublishing, so you throw your content into the wiki, and all the other authors view your article.
17:25:15 <shapr> Some authors set their articles only readable by all the other authors, but I set mine publically readable and ask for any feedback.
17:25:29 <shapr> Of course, I don't always finish my articles :-)
17:25:36 <benny> dons: awesome, how would you like to work it? email? right here and now in prmsgs + pastebin?
17:26:20 <benny> also, do you guys think i should switch to glade for the gui?
17:26:22 <dons> privmsgs and email would be easiest. 
17:26:36 <dons> long questions are best answered  via email
17:26:53 <dons> and a wiki is even better
17:27:13 <benny> yeah... wiki
17:27:14 <shapr> I think you should do it however is most comfortable to you. If you like glade, go for it. If not.. don't :-)
17:27:24 * benny has never used glade
17:27:48 <shapr> You want write access on TmrWiki?
17:27:52 <benny> but the gui is ugly, and fixing it up manually feels like something i shouldn't have to do :)
17:28:07 <dons> you could write a curses ui ;)
17:28:24 <dons> @seen SamB
17:28:25 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 3
17:28:25 <lambdabot> hours, 54 minutes and 7 seconds ago.
17:30:53 <benny> curses...... hm.... no! :)
17:31:18 <dons> ah, SamB, I get it. psi means your Linker.c patch, not your hmp3 patch.
17:31:38 <dons> hmm. but then why would that help hmp3. that doesn't make sense.
17:31:52 <shapr> Chewbacca is a Wookie...
17:32:00 <shapr> But he lives on Endor...
17:33:54 <dons> it's an enduring mystery, eh shapr?
17:35:14 <benny> shapr: if you grant me such, then could i paste the code in a private wiki page?
17:35:28 <shapr> Sure, if you like.
17:35:45 <shapr> But I'm about to sleep, so if you want tmrwiki write access, ask me now.
17:35:46 <benny> ok swell, then um... make it so. please
17:35:50 <shapr> ok cool
17:36:02 <shapr> Do you have a last name?
17:36:14 <shapr> This is the list of authors for TMR - http://www.haskell.org/tmrwiki/AdminGroup
17:36:28 <shapr> You create an account here - http://www.haskell.org/tmrwiki/UserPreferences
17:36:44 <shapr> And I add your chosen account name to the AdminGroup, and you're good to go.
17:37:27 <shapr> Or if you just want to write a wiki page, you can put it on the haskell wiki instead.
17:37:34 <shapr> c'est votre choix
17:38:18 <benny> shapr: do i have to use my real name?
17:38:35 <pengo> hey shapr
17:39:14 <dons> it's a good idea, since it would be published to the community.
17:39:22 <dons> @quit fixing...
17:43:20 <benny> shapr: ok, my ID is 1134265323.35.55473
17:43:54 <shapr> What's the name you used?
17:44:13 <shapr> If you'd prefer to tell in a private message, you can.
17:44:30 <benny> BennyK
17:44:31 <benny> ramek
17:45:42 <shapr> ok
17:46:20 <shapr> Assuming I added your name correctly, you should now have write access to TmrWiki
17:47:05 <benny> seems to work
17:47:09 <shapr> spiffy
17:47:18 <benny> indeed, which page should i create?
17:47:36 <shapr> I dunno, what's your project? HsPluginsGui ?
17:47:43 <benny> StringProcGui
17:47:48 <shapr> Works for me.
17:47:57 <shapr> You probably want to use the article template when creating.
17:50:00 <shapr> anyway, it's nearly 3am, I'm falling over now.
17:50:55 <benny> 4am here :)
17:51:02 <benny> i've pasted the code if anyone is interested:
17:52:32 <benny> http://www.haskell.org/tmrwiki/StringProcGui
17:52:44 <shapr> dons: I just added you to TmrWiki as DonStewart, have you already created an account?
17:53:15 <benny> shapr: you should add hscolor support to the wiki ;)
17:53:22 <shapr> Truly
17:53:29 <shapr> I added the enscript support that's there now.
17:53:39 <shapr> But hscolour is better.
17:53:45 <shapr> I just added enscript coloring to your code too.
17:54:16 * benny should start a fork of hscolour called hscolor
17:54:34 <shapr> I want hscolr like flickr and shapr and ...
17:54:44 <benny> heh
17:55:02 <shapr> anyway, g'nite
17:55:13 <benny> night man
17:56:16 <benny> dons: do you have write access to that page?
17:56:24 <dons> shapr, I think I already have an account. let's see..
17:57:29 <dons> yep, i can og in
17:57:51 <dons> and looks like I can edit. good 
18:00:01 <SlowByte> antastic! ;)
18:00:08 <benny> ok, well if you have time and you feel like it you can read over that code and make comments and and changes, either in the code itself, or outside of it
18:00:43 <benny> dons: you can also talk to me in here of course :)
18:00:47 <dons> yep ok.
18:01:32 <benny> i'm gonna read up in the meantime about glade
18:16:10 <araujo> Hellu.
18:22:39 <musasabi> morning araujo 
18:26:51 <araujo> Hello musasabi , what's up?
18:27:24 <musasabi> woke up, some time ago, and I am wondering whether I could sleep again.
18:28:28 <araujo> hah
18:28:32 <araujo> Too early over there?
18:28:38 <araujo> @localtime musasabi 
18:28:40 <lambdabot> Local time for musasabi is Sun Dec 11 04:28:16 2005
18:28:44 <araujo> :-]
18:34:50 <musasabi> then again I don't feel tired.
18:34:55 <musasabi> but I should feel tired.
18:35:00 <araujo> hah
18:35:14 <araujo> got nothing interesting to hack?
18:41:22 <musasabi> not awake enough to hack anything sensible.
18:44:23 <benny> @seen dcoutts 
18:44:24 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #
18:44:24 <lambdabot> haskell. I don't know when dcoutts last spoke.
19:12:19 <sethk> musasabi, eventually, one way or another, you'll have to sleep again
19:16:09 <musasabi> sethk: I know, but just going to bed does not help if I just toss around.
19:16:18 <musasabi> and I don't want to wake my gf yet again.
19:16:31 <sethk> musasabi, large amounts of sleep inducing substances might help
19:20:44 <musasabi> sethk: I don't like drugs very much.
19:21:11 <sethk> musasabi, don't worry, you'll be asleep, you won't even feel them.  :)
19:50:16 <conal> is there a standard name (in a base library) for "fold (.) id", just as there are "and", "sum", and "maximum"?
19:51:58 <conal> @hoogle [a->a] -> a -> a
19:51:59 <lambdabot> No matches, try a more general search
20:02:23 <xah> hi comrads
20:05:56 <SamB> musasabi: why are you on the computer?
20:20:55 <Korollary> @type fold
20:20:56 <lambdabot> Not in scope: `fold'
20:21:00 <Korollary> @type foldl
20:21:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:22:09 <TheHunter> mconcat still does it in 6.4, I suppose.
20:22:24 <TheHunter> > mconcat [(+1), (+2)] 0
20:22:25 <lambdabot>  Not in scope: `mconcat'
20:23:01 <TheHunter> in current ghc-cvs, (a -> a) isn't a monoid anymore however.
20:25:44 <TheHunter> |appEndo . mconcat . map Endo| isn't really simpler than |foldr (.) id| anymore.
20:27:20 <TheHunter> @hoogle mconcat
20:27:20 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
20:27:44 <TheHunter> @hoogle a -> a
20:27:45 <lambdabot> Prelude.id :: a -> a
20:27:45 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:27:45 <lambdabot> Control.Parallel.par :: a -> b -> b
20:35:12 <musasabi> SamB: two rooms, one with beds one with computers. Either I am in bed, or I am sitting before a computer. (the other choices are floor)
21:13:20 * palomer is still figuring out how to map the image to the sphere
21:13:35 <palomer> Cale: little more help:P?
21:25:50 <cjb> palomer: That's what the "map" function is for, duh.
21:25:56 <cjb> </unhelpful>
21:31:38 <gzl> palomer: stereographic projection?
21:32:11 <palomer> hrmhrmph
21:32:23 <palomer> I don't know what it's called 
21:32:27 <palomer> I'm bouncing rays off a sphere
21:32:40 <palomer> so I have the reflected ray
21:32:51 <palomer> and I have to figure out how to index an image with that
21:33:00 <gzl> no, I mean, if you have something that's like R^2 and want to map it to the sphere, you could use the stereographic projection (maybe)
21:33:08 <gzl> err
21:33:26 <gzl> well, who knows. 
21:33:38 <palomer> I don't know if stereographic applies here
21:33:46 <palomer> probably not, since I'm reflecting an infinite plane
22:02:34 <gzl> palomer: ?
22:03:16 <palomer> I have an infinite plane being reflected onto a sphere
22:04:25 <gzl> well, the stereographic projection sends S^n - P -> R^n (where P is any one point you pick)
22:04:39 <gzl> so I guess it's not quite what you want
22:35:19 * araujo likes to see processes as functions
22:43:31 <araujo> Ive been thinking that processes are like one-time pure functions.
23:13:27 <jethr0> @seen
23:13:27 <lambdabot> Lately, I have seen jethr0.
23:17:38 <palomer> > loop = loop
23:17:39 <lambdabot>  parse error on input `='
23:17:46 <palomer> > let loop = loop in loop
23:17:47 <lambdabot> Add a type signature
23:17:52 <palomer> screw off
23:18:04 <jethr0> palomer, what're you tryin'?
23:18:15 <jethr0> > fix id :: Int
23:18:16 <lambdabot> Exception: <<loop>>
