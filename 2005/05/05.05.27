00:02:40 <jlouis> or you have to objects x, x' which comes from the same set, etc
00:10:23 <boegel> hi everyone
00:29:09 <musasabi> morning boegel
00:33:09 <boegel> hey musasabi
00:39:20 <boegel> hey amiddelk
00:42:50 <tom> @listcommands
00:42:51 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
00:42:51 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
00:42:51 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
00:42:51 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
00:42:51 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
00:42:52 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
00:42:54 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
00:42:56 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
00:42:58 <lambdabot> wiki wikipedia wn world02 yow
00:43:01 <tom> @help babel
00:43:02 <lambdabot> usage: babel lang lang phrase
00:43:12 <dons> @babel en de good day mr. bot
00:43:15 <lambdabot>  guter Tagesherr bot
00:43:43 <tom> are you always here ;)
00:44:04 <tom> I didn't realise before that lambdabot was yours
00:44:33 <dons> hehe.
00:44:36 <tom> @babel en fr what's the time mr wolf
00:44:38 <lambdabot>  ce qui est M. wolf de temps
00:45:17 <tom> lambdabot looks like fun. How does the dynamic code loading work?
00:45:19 <dons> it's not so much mine, more that I'm the maintainer -- though I do get to say what patches go in.
00:45:26 <dons> it uses hs-plugins
00:45:30 <dons> @google hs-plugins
00:45:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
00:45:47 <tom> I'll give it a look.
00:45:52 <dons> a library for dynamic loading wriitten in haskell
00:46:10 <dons> this is how @plugs works too
00:46:21 <kzm> @help hitchcock
00:46:22 <lambdabot> I perform dictionary lookups via the following 14 commands:
00:46:22 <lambdabot>  @all-dicts .. Query all databases on dict.org
00:46:22 <lambdabot>  @devils ..... The Devil's Dictionary
00:46:22 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
00:46:22 <lambdabot>  @elements ... Elements database
00:46:22 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
00:46:24 <tom> say would hs-plugins be useful for writng a plugin to apache
00:46:25 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
00:46:26 <lambdabot> [8 @more lines]
00:47:11 <kzm> @hitchcock window
00:47:15 <lambdabot> No match for "window".
00:47:32 <kzm> Hmm.
00:48:15 <dons> tom, yep. there's a couple of projects to do this in fact.
00:48:21 <dons> Lemmih is working on one.
00:48:39 <dons> a similar project is HSP, which uses the Haskell webserver.
00:49:08 <dons> @google HSP Haskell server pages
00:49:08 <tom> I saw HSP. Looks great pity it wasn't around a year or so ago
00:49:09 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
00:50:06 <tom> I used to work in IT and was really keen to use Haskell commercially
00:50:16 <Lemmih> My apache module is using HSP.
00:50:37 <tom> Oh, I though HSP was a stand alone webserver
00:51:26 <Lemmih> Nope, it's just a neat way of generating XML.
00:52:38 <tom> ok. is it pretty much like JSP or ASP then?
00:53:10 <tom> I did write one commercial haskell programme using CGI and HaXML
00:54:44 <tom> @easton david
00:54:47 <lambdabot> *** "David" easton "Easton's 1897 Bible Dictionary"
00:54:47 <lambdabot> David
00:54:47 <lambdabot>  beloved, the eighth and youngest son of Jesse, a citizen of
00:54:47 <lambdabot>  Bethlehem. His father seems to have been a man in humble life.
00:54:47 <lambdabot>  His mother's name is not recorded. Some think she was the Nahash
00:54:48 <lambdabot>  of 2 Sam. 17:25. As to his personal appearance, we only know
00:54:49 <lambdabot>  that he was red-haired, with beautiful eyes and a fair face (
00:54:51 <lambdabot> [396 @more lines]
00:54:59 <tom> @more
00:55:00 <lambdabot> 1
00:55:00 <lambdabot>  Sam. 16:12; 17:42).
00:55:00 <lambdabot>  
00:55:00 <lambdabot>   His early occupation was that of tending his father's sheep
00:55:01 <lambdabot> on
00:55:03 <lambdabot>  the uplands of Judah. From what we know of his after history,
00:55:06 <lambdabot>  doubtless he frequently beguiled his time, when thus engaged,
00:55:07 <lambdabot> [389 @more lines]
00:55:24 <tom> @daniel
00:55:25 <lambdabot> Unknown command, try @listcommands.
00:55:35 <tom> @easten daniel
00:55:38 <lambdabot> *** "Daniel" easton "Easton's 1897 Bible Dictionary"
00:55:38 <lambdabot> Daniel
00:55:38 <lambdabot>  God is my judge, or judge of God. (1.) David's second son, "
00:55:38 <lambdabot> born
00:55:38 <lambdabot>  unto him in Hebron, of Abigail the Carmelitess" (1 Chr. 3:1).
00:55:38 <lambdabot> He
00:55:40 <lambdabot>  is called also Chileab (2 Sam. 3:3).
00:55:42 <lambdabot> [87 @more lines]
00:55:51 <tom> quit
00:56:26 <^buggler^> is there some nice equivalent to or [map f xs]
00:56:34 <^buggler^> er
00:56:38 <^buggler^> or (map f xs)
00:57:03 <^buggler^> seems like it's looping twice
00:57:18 <Si\> Has anyone ever considered turning String into a type-class somewhat like Num, which String and PackedString and instances, so that e.g. "Hello" :: String a => a?
00:57:24 <^buggler^> although *shrug* haskell's evaluation is counter intuitive for me
00:57:30 <Lemmih> ^buggler^: I don't understand the question.
00:57:42 <boegel> @wiki H3D
00:57:43 <lambdabot> http://www.haskell.org/hawiki/H3D
00:57:45 <boegel> Lemmih: ^
00:58:39 <Lemmih> Si\: That comes up from time to time.
00:58:44 <nlv11757_> @easton jafet
00:58:46 <lambdabot> No match for "jafet".
00:58:51 <nlv11757_> @easton cham
00:58:53 <lambdabot> No match for "cham".
00:59:15 <kzm> @easton witch
00:59:18 <lambdabot> *** "Witch" easton "Easton's 1897 Bible Dictionary"
00:59:18 <lambdabot> Witch
00:59:18 <lambdabot>  Occurs only in Ex. 22:18, as the rendering of _mekhashshepheh_,
00:59:18 <lambdabot>  the feminine form of the word, meaning "enchantress" (R.V.,
00:59:18 <lambdabot>  "sorceress"), and in Deut. 18:10, as the rendering of
00:59:19 <lambdabot>  _mekhashshepheth_, the masculine form of the word, meaning
00:59:20 <lambdabot>  "enchanter."
00:59:22 <lambdabot>  
00:59:28 <Lemmih> boegel: What's STL?
00:59:56 <boegel> someone told me you were doing something with it
01:00:09 <boegel> I believe it was SyntaxNinja (or Igloo)
01:00:22 <boegel> Lemmih: maybe it's SDL ? don't remember :)
01:00:23 <Lemmih> I do have a SDL binding.
01:00:34 <boegel> oh, okay :)
01:00:58 <boegel> could you add some info on that ? I'm just gathering idea's and applications which could help developping a 3d modeller in Haskell
01:01:28 <Lemmih> Done.
01:01:32 <Si\> Because I'm fed up with have to resorting to overlapping instances if ever I want and instance of something for both String and [a]. PackedString is great, but it adds a layer of complexity which String doesn't have
01:02:35 <boegel> Lemmih: could you add some info on what it actaully is ?
01:04:39 <Lemmih> I added a link to www.libsdl.org
01:25:39 <boegel> thanks Lemmih
01:37:25 <Muad_Dibber> how smart is haskell's optimiser? :P
01:37:37 <Muad_Dibber> i mean: when i do appendFile, needs the file be opened before?
01:38:59 <Cale> that sounds like a semantics issue and not an optimisation issue
01:39:09 <Muad_Dibber> well what i meant is this:
01:39:31 <Muad_Dibber> suppose i do something like   map appendFile strings
01:39:45 <Muad_Dibber> will it open and close the file each time?
01:40:00 <Cale> It won't do anything
01:40:17 <Cale> @type map appendFile ["Hello", "world"]
01:40:19 <lambdabot> map appendFile ["Hello", "world"] :: [String -> IO ()]
01:40:27 <Muad_Dibber> you know what i mean :P
01:41:07 <Lemmih> 'mapM (appendFile "somefile") list' will open and close "somefile" for every element in the list.
01:41:19 <Lemmih> *mapM_
01:41:20 <musasabi> How do I get the (HostName,PortID) pair from a listening Socket with the standard Network module?
01:41:24 <Cale> It will probably open and close the filehandle, if I really do know what you mean
01:41:55 <Muad_Dibber> of course Lemmih  has the good syntax sincei t's a monad
01:42:06 <Muad_Dibber> but i just meant doing a sequence of appendFile's
01:42:28 <Muad_Dibber> so it's probably better to open the file, and with the filehandle start writing to the file?
01:42:46 <Lemmih> What about doing 'appendFile "somefile" (concat list)'?
01:44:13 <Cale> Muad_Dibber: why not open a filehandle if you're going to do lots of writes?
01:46:37 <Muad_Dibber> Cale : am going to do that now
01:49:20 <Lemmih> boegel: What do you mean by a 3D modeller? Something like Blender/Vertex?
01:50:29 <boegel> Lemmih: yeah, but at first it's just playing around a bit
01:50:46 <boegel> I would like to merge my raytracer with bourbaki's spline renderer at first
01:50:51 <boegel> I'm just gathering idea's
01:53:03 <Muad_Dibber> your raytracer finished then boegel ?
01:56:28 <boegel> Muad_Dibber: yeah, quite
01:56:46 <boegel> I'm correting some stuff in my thesis text now, it's due June 1st
01:57:01 <boegel> I'll release my code then, so you guys can tell me what I did wrong :)
01:57:15 <boegel> Muad_Dibber: I'll continue working on my raytracer though
02:01:53 <Muad_Dibber> boegel : like i have only near the knowledge to tell what you did wrong or what could possibly be nicer :P
02:02:38 <boegel> Muad_Dibber: I don't know how good you are :)
02:04:33 <Muad_Dibber> good :) then you wontl ook down on me ;)
02:07:02 <boegel> I wouldn't look down on anyone
02:07:06 <boegel> except on xerox :D
02:07:37 <reffie> well said!
02:08:25 <Muad_Dibber> hehe
02:09:25 <jlouis> boegel: raytracer based on octree-splitting of scene?
02:09:55 <boegel> jlouis: you mean my current raytracer?
02:10:03 <jlouis> hmmm, I should venture out to write a partial evaluator for Haskell 98
02:10:25 <jlouis> then we could PE your raytracer with respect to the scene
02:10:29 <jlouis> ;)
02:11:06 <boegel> PE ? *err
02:11:50 <boegel> hey Heffalump
02:11:56 <Heffalump> hiya
02:12:06 * Heffalump is in search of a Haskell-Perl binding
02:12:14 <dons> oh!
02:12:32 <Heffalump> (I need to run a small bit of Perl from a Haskell program)
02:13:01 <dons> too big for a forkProcess/String interface?
02:13:25 <Heffalump> I just want to read in some configuration values that are set up in an existing perl module
02:13:30 <Heffalump> so while I could do that, it'd suck
02:15:07 <Muad_Dibber> if you pe a raytracer to a specific scene, you get just a scene renderer right? :P
02:15:18 <boegel> what does pe mean ?
02:15:24 <Heffalump> partially evaluate
02:15:24 <Muad_Dibber> partial evaluate
02:15:35 <Heffalump> Muad_Dibber: or a bitmap :-)
02:15:46 <Heffalump> or do you mean PE to the scene but not the viewpoint?
02:15:49 <Muad_Dibber> Heffalump : depending on the amount you can PE
02:15:58 <Muad_Dibber> but i meant leaving the viewpoint dynamically
02:16:01 <Heffalump> ok
02:16:31 <Muad_Dibber> since if you get a bitmap from a raytracer, hte partial part actually means completly, right?
02:18:35 <boegel> hmm, I'm not sure that's possible in my model
02:18:47 <Heffalump> Muad_Dibber: good point.
02:19:05 <boegel> but you can PE the rayTrace function with an arbritraty view point, view window dimensions (and resolution)
02:19:33 <boegel> if you want to look at the scene under some angle, you can adjust the objects in the scene according to the angle...
02:21:42 <boegel> hey Itkovian
02:21:48 <Muad_Dibber> oh my
02:21:50 <Muad_Dibber> its amiddelk
02:22:06 <amiddelk> who?
02:22:11 <Muad_Dibber> over there :P
02:22:29 <amiddelk> *looks around*, nah, can't see him though
02:22:31 <Muad_Dibber> boegel : so basically then you only ahve a dynamic scene but fixed view point? :P
02:23:01 <boegel> *euh yeah
02:28:14 <Heffalump> ooh.
02:28:27 * Heffalump finds his own old perl-haskell binding
02:32:45 <yain> offtopic: anyone have links to good rant on "function pointers ain't HOFs"?
02:34:45 <lispy> yain: are they really that different?  If you have HOF without the ability to generate new functions at runtime then I think they would be the same
02:35:25 <lispy> for example, if you can't create lambdas and you can't do things like (1+)
02:35:53 <yain> well, i actually wanted existing discussion, not a new one :D
02:36:04 <lispy> hehe
02:36:15 <yain> or even better some pedantic paper
02:36:15 <lispy> you have me wondering about it :)
02:36:48 <Cale> Well, function pointers themselves certainly aren't HOFs. :)
02:36:50 <lispy> man, i swear my prof didn't type this problem correctly
02:36:59 <lispy> Cale: heh
02:37:06 <yain> Cale: right, i wasn't correct
02:37:16 <Cale> Of course you can use them to implement HOFs
02:38:01 <Cale> Keep in mind that GHC compiles Haskell to C. :)
02:38:51 <yain> that's different thing
02:39:37 <Cale> C functions aren't functions.
02:39:48 <Cale> That's a bigger concern :)
02:40:28 <Itkovian> wtf are HOFs?
02:40:37 <Cale> Higher order functions
02:41:21 <boegel> Itkovian: you should knwo those ;)
02:41:58 <Cale> Certainly you can write C code which is functional in style, with awkwardly handled foldrs and such :)
02:42:06 <Itkovian> ok ... yeah yeah
02:42:40 <Cale> In fact, it's a little less awkward if you use a GNU-specific preprocessor trick to approximate lambdas.
02:43:25 <Cale> not that I'd want to do it, but I know a guy who does :)
02:43:51 <Itkovian> poor bastard
02:44:05 <dons> @remember Cale In fact, it's a little less awkward if you use a GNU-specific preprocessor trick to approximate lambdas.
02:44:22 <dons> ;)
02:44:25 <Cale> heh
02:44:42 <lispy> Cale: i wrote a mapcar in C the other day for lists of ints :)
02:44:58 <Cale> I suppose that emphasizes just how awkward it is in the first place :)
02:45:16 <lispy> yeah, i did it as a challenge
02:45:30 <lispy> and to prove that point that programming in lisp had changed the way i think about writing C code :)
02:47:41 <yain_> yes it changes the style a lot
02:47:51 <yain_> some people reach the point when they cannot go back to c :P
02:48:09 <yain_> (or at least they say so)
02:48:46 <lispy> i cannot go back to C++ :)
02:49:02 <lispy> GCC is getting better but it really sucks at templates
02:49:34 <lispy> and i try to use as much abstraction in my C++ code as I can so that I spend less time debugging details and more time fixing design issues
02:49:49 <lispy> but yeah, i rarely do C++
02:50:07 <yain_> man, you haven't seen msvc if you think that gcc sucks
02:50:18 <lispy> in fact, the last time i did any serious C++ was preparing for interviews that never happened
02:50:38 <lispy> yain_: actually, for C++ standard compliance, VS C++ is in the lead
02:51:06 <lispy> BUT, i would rather use gcc any day
02:51:23 <lispy> VS C++ may be compliant, but it's pain to use
02:51:42 <yain_> i haven't read standard. what i did is insane amount of workarounds to make some things work with msvc
02:51:58 <yain_> like class template definition in one file and code in other
02:52:06 <yain_> stl implementation fixes.
02:52:10 <yain_> and so on
02:52:30 <lispy> when i was learning C i bought a copy of VS C++ for real cheap and while i was waiting for it to come in the mail i started using djgpp (the dos port of gcc) and then when it came i tried it once and uninstalled it :)
02:52:58 <jlouis> hehe
02:53:43 <yain_> i think last msvc release even ships with broken stl headers. they just don't compile if you include them
02:53:51 <yain_> i forgot which one exactly.
02:54:30 <lispy> yain_: this is interesting, i've not used recent msvc++, but I had heard from others that the compliance was very, very good
02:54:52 <lispy> and when i say others, these people should have been experts (but anything is possible)
02:54:53 <yain_> they improved some things. like loop local variables. but stl still sucks
02:55:11 <lispy> and gcc is getting better every day
02:55:39 <tuomov> stl inherently sucks.
02:55:44 <lispy> i measure the improvements by how often i can take random example out of bjarne's c++ book and get it to compile
02:56:21 <lispy> tuomov: given the constraints it's quite useful, but yeah, i'd rather be using something better than C++
02:56:54 <wilx> ...
02:57:07 <wilx> There is nothing better than C++!
02:57:10 <wilx> (half serious)
02:57:49 <lispy> i guess best language always depends on your useage
02:59:35 <yain_> that's cool how asking for links to hof discussion leads us to microsoft c++ compiler suckage
03:03:34 <lispy> nice observation
03:04:28 <zesjut> hi, ive installed hsql but the interpreter ghci doesnt find the imports
03:04:34 <zesjut> any help?
03:05:28 <Lemmih> Try starting GHCi with -package hsql.
03:05:47 <zesjut> ok
03:06:34 <zesjut> yes , it works :D thank you lemmih
03:07:35 <nlv11757_> an inner loop can be spliced into multiple basic blocks can it?
03:07:38 <Lemmih> No problem (:
03:07:52 <jlouis> nlv11757_: define
03:08:10 <nlv11757_> cause a basic block by definition enters at the top of the basic block and leaves at the end
03:08:19 <jlouis> the innards of a loop does not have to be a basic block, but it can be
03:08:31 <jlouis> the inner loop can ``return''
03:08:38 <nlv11757_> or do a goto
03:08:39 <jlouis> or branch
03:08:54 <jlouis> no-one says it is a basic block at all
03:09:19 <nlv11757_> i was wondering how to deal with inner loops when making basic blocks,
03:10:06 <jlouis> like all other basic blocks. You find an entry point and begin putting the successor instructions inside that block until you reach a jump point
03:10:27 <jlouis> the entry points are given by labels
03:10:55 <jlouis> if a label is in the middle of some instructions, insertion of an extra jmp x, before label x, servers
03:11:14 <nlv11757_> a label in the middle?
03:11:17 <nlv11757_> how would that look?
03:15:06 <jlouis>         add a, b, c
03:15:21 <jlouis> lbl_1:  add b,c,a
03:15:33 <jlouis>         addi a, b, 10
03:15:34 <jlouis> etc
03:15:48 <jlouis> you rewrite that to:
03:15:52 <jlouis>         add a, b, c
03:15:57 <jlouis>         jmp lbl_1
03:16:01 <jlouis> lbl_1:   ...
03:16:34 <jlouis> the trace scheduler will then kill the jmp again if that is the best thing to do
03:20:24 <lispy> <3 darcs
03:20:41 <lispy> it's such a nice way to synchronize all the accounts i have on various systems
03:21:12 <lispy> i do my homework on one computer, record, push, login somewhere else, pull, and start hacking
03:40:00 <nibro> Lemmih: wow, can I quote you? :)
03:40:00 <Lemmih> Sure.
03:40:00 <nibro> I haven't done any real tests on efficiency, so it's nice to hear that you find it fast compared to php
03:40:00 <jlouis> HSP... haskell server pages?
03:40:00 <nibro> jlouis: yep
03:40:00 <jlouis> nibro: performance is almost always tuneable
03:40:00 <nibro> jlouis: aye, but it can't hurt to have a good starting position :)
03:41:06 <Lemmih> It annoys me a bit that I can't get profiling information from modules loaded with hs-plugins.
03:42:19 <nibro> Lemmih: so is your apache binding usable in a general sense?
03:42:28 <nibro> anything I could steal and use? =)
03:51:22 <Lemmih> And it never returns NotReq.
03:52:08 <dons> Lemmih, re profiling, we have to modify things so that .p_a archives are handled.
03:52:21 <Lemmih> There's a 'hasChanged :: Module -> IO Bool' in hs-plugins which checks if the source file is newer than the object file for the module and its dependencies.
03:53:05 <Lemmih> dons: And we need profiling support in Cabal /-:
03:53:07 <nibro> Lemmih: yes, but I don't want to let hsp do those things. I'd love it if hs-plugins did all those checks internally though... ;)
03:54:21 <dons> Lemmih: and we need that too, right
03:54:57 <Lemmih> nibro: It would be hard to do recompilation checks in 'makeAll' since we don't know the dependencies of the source file.
03:58:55 * Lemmih hacks a 'recompileAll :: Module -> [Arg] -> IO MakeStatus'.
03:59:12 <dons> ooh. that would be nice
04:03:33 <boegel> is there like a central point or article on arrows ?
04:03:50 <boegel> I mention that in my thesis as a powerfull technique in Haskell, but I need a reference
04:04:03 <Lunar^> http://haskell.org/arrows/ ?
04:04:21 <dblhelix> john hughes's article?
04:04:28 <boegel> oh okay, great :)
04:27:05 <Lemmih> dons: Maybe we should store the source filename in Module?
04:29:07 <Lemmih> Hmm can't do that.
04:40:42 <dons> we've got the path and the module name already, don't we?
04:41:05 <Lemmih> We got the path to the object file.
04:41:44 <dons> oh, yep. but we can't have the source - we have to allow some users to not have .hs files at all
04:41:58 <Lemmih> Indeed.
04:42:30 <dons> there's some commands that don't even need .hi files - just a .o will do
04:42:47 <Lemmih> Indeed.
04:44:16 * jlouis is soon compiling 6.4 on NetBSD
04:44:24 <jlouis> then i'll hack a bit more on lambdabot ;)
05:13:15 <nlv11757_> hey jlouis, does it make sense for a basic block to contain another basic block?
05:48:10 * boegel cheers
05:48:37 <bourbaki> boegel: sucsessful?
05:51:17 <boegel> bourbaki: yeah, I finally finished my thesis text
05:51:22 <boegel> it's ready to print now
05:51:24 <bourbaki> congrats
05:51:39 <boegel> thanks
05:52:09 <boegel> I would let you browse through it, but it's in Dutch, so that wouldn't be usefull for you..
05:52:39 <bourbaki> :)
05:53:47 <bourbaki> i wish i would be done with my thesis and study as well
05:58:25 <bourbaki> from 2007 on we have to pay taxes to the gov for useing the internet!!!
06:00:01 <yain> cool.
06:00:08 <yain> were is that?
06:00:14 <bourbaki> cool?
06:00:17 <bourbaki> in germany
06:00:39 * yain takes note to never ever migrate to germany
06:00:41 <bourbaki> and from what i understand if you use inet in commercial areas you have to pay per machine
06:00:52 <bourbaki> they so suck
06:01:21 <yain> well per communication line it would make sense
06:01:23 <bourbaki> some time back the politicians made some really crappy laws for copying media and such
06:01:29 <yain> since those must be maintained etc
06:01:35 <bourbaki> they just dont have any clue about the stuff they do
06:01:48 <bourbaki> yain: but not by the gov
06:01:51 <yain> next step is per application protocol payment!
06:01:55 <bourbaki> thats why i pay my isp
06:02:04 <yain> $5/month for irc, $5 for icq
06:02:11 <bourbaki> i guess they are debateing taxes for email
06:02:17 <bourbaki> like buying a stamp
06:02:25 <bourbaki> cause noone sends letters anymore
06:03:20 <bourbaki> i wonder if they have the same expertise in all the other fields as well
06:04:42 <Philippa> if they tax email something's really wrong. A stamp's payment to a service provider, with email presumably the provider's been paid already
06:05:11 <bourbaki> Philippa: the same accounts for the inet thingy
06:05:22 <bourbaki> they just dont do anything but haveing a website in the internet
06:05:22 <Heffalump> how would they tax it, anyway?
06:05:45 <bourbaki> and that is why they want to get like 5 euros or so ber 1/4 year from you
06:05:59 <bourbaki> Heffalump: you pay tax for tv and radio here as well
06:06:09 <Heffalump> oh, a flat rate tax, that makes more sense
06:06:09 <yain> tax or rent+?
06:06:14 <bourbaki> they say that a pc with internet is nothing but a boradcast medium as well
06:06:17 <Heffalump> well, would be more enforceable
06:06:18 <bourbaki> not rent
06:06:20 <bourbaki> tax
06:06:29 <bourbaki> for non commercial radio and tv
06:06:31 <yain> you mean wireless radio?
06:06:37 <bourbaki> yes
06:06:40 <yain> that sucks
06:06:47 <bourbaki> no flatrate tax
06:06:59 <bourbaki> if you own a pc and a modem then you pay
06:07:07 <yain> we have radio outlets in some houses here, it's plus to rent
06:07:08 <bourbaki> even if it is a 286 without sound
06:07:11 <bourbaki> and command line
06:07:26 <bourbaki> its ok to pay something for non commercial tv and radio
06:07:36 <bourbaki> its good to have some real news on the tc
06:07:37 <bourbaki> tv
06:07:46 <bourbaki> but i am not willing to pay for internet
06:07:56 <bourbaki> cause they just dont do anything for that
06:08:02 <bourbaki> they dont provide the network
06:08:12 <bourbaki> and they dont provide any service at all
06:08:24 <yain> well who owes backbones?
06:08:24 <bourbaki> AND we already pay for computers with tv boards
06:08:29 <yain> ain't that goverment?
06:08:42 <bourbaki> but thats why i pay my isp
06:09:00 <yain> i think israel have this kind of fun too.
06:09:01 <bourbaki> they just want taxes because they provide non commercial sites in the internet or so
06:09:08 <yain> for tv.
06:09:12 <bourbaki> they are total shit heads
06:09:18 <yain> and computers with tv-cards.
06:09:26 <bourbaki> they dont have any clue about internet or any kind of that
06:09:39 <bourbaki> i bet they are just as well informed on economics and so as well
06:10:17 <bourbaki> this is what you get if any shit head can get a politician without haveing an education in the field he is acting in
06:10:35 <bourbaki> and all these lobbyist man i am really mad
06:10:42 <bourbaki> i wonder why i still work at all
06:10:56 <bourbaki> i just should send my paycheck to them every month
06:11:03 <bourbaki> that would make my life a lot easier
06:37:10 <CosmicRay> @seen shapr
06:37:11 <lambdabot> I saw shapr leaving #haskell 21 hours, 44 minutes and 23 seconds ago,
06:37:11 <lambdabot> and I have missed 7 seconds since then.
06:43:25 <Lycan359> Why isn't haskell fast like ocaml?
06:44:12 <metaperl> I think a major reason that Haskell programs can be slower is that it is a lazy language
06:44:20 <metaperl> both languages have strong typing
06:44:26 <metaperl> so that isn't it
06:45:00 * CosmicRay just replying to your blog entry now
06:45:09 <CosmicRay> "You could be right about Haskell being half as fast as OCaml.  But then again, Perl 5 and Python are also half as fast as OCaml, and Java fares even worse.  So while Haskell performance is not so stellar that it ranks up there with C, it also is by no means an outlier.  It seems to be pretty much a middle of the pack performer to me."
06:45:46 <Lemmih> It's mostly because Haskell encourages solutions which are easier for humans to comprehend.
06:47:03 <edwinb> The laziness is a big factor too.
06:48:20 <timbod> It's a shame that removing laziness from code is so hard - weird incantations of seq, deepseq etc. It always seems to need a guru level of understanding to control laziness.
06:49:29 <metaperl> does the 80-20 rule apply? can you simply optimize the slow part to get a fast program?
06:49:43 <CosmicRay> often yes
06:49:44 <musasabi> One can write very fast haskell code.
06:49:49 <Lemmih> Most definitely.
06:49:55 <musasabi> Of course the very fast haskell code is not very pretty.
06:50:08 <CosmicRay> and don't forget the cases where haskell runs so much faster than other languages because laziness can be an optimization in itself
06:50:15 <metaperl> musasabi: shouldnt that be "fast code can happen" ... I cant imagine a haskell programmer writing code so that a computer runs it faster
06:50:15 <musasabi> Because when you want most speed you want to specify evaluation order...
06:50:34 <CosmicRay> for instance, some of the shootout benchmarks finished instantly with haskell in the first iteration because the result of the computationw as never demanded :-)
06:51:09 <musasabi> metaperl: a haskell programmer writes a program - and if it has performance problems runs a profiler - most likely fixing a few functions will solve the problem. At least that is my experience.
06:54:32 <Cale> I find that ordinary haskell code can be very fast, so long as you can put your algorithm in terms of laziness. Certain kinds of coroutine-type evaluations are very efficient. The important thing to think about is the amount of work that needs to be done to get the next part of a result.
06:54:34 <metaperl> musasabi: yes, I agree with that approach
06:55:21 <metaperl> what I worry about is why C++ is a popular language with lots of libraries
06:55:25 <metaperl> and speed
06:55:38 <metaperl> and why Haskell has not attracted corporate america
06:55:55 <yain> because you cannot hire 10k haskell programmers.
06:56:02 <metaperl> Haskell is beautiful and elegant, but does it have what it takes for corporate-level demands
06:56:08 <CosmicRay> well, corporate america still likes Java
06:56:08 <goron> metaperl: You need an education for Haskell. Look at the america education. Q.E.D.
06:56:15 <metaperl> goron: lol
06:56:16 <yain> and even if you can, when they leave you cannot get a replacement.
06:56:24 <CosmicRay> metaperl: Python and Perl haven't attracted corporate america either, at least not in the way that Java has
06:56:46 <yain> as someone put it on lambda-the-ultimate
06:56:50 <metaperl> CosmicRay: corporate interest in Perl is much much greater than Haskell
06:56:54 <yain> language is one a small part of most projects
06:57:06 <CosmicRay> metaperl: but really, Haskell as it currently exists is: 1) a fairly new language, and 2) very different than what most people without a CS degree have ever seen
06:57:06 <yain> and people tend to chose ones that have most usebase
06:57:11 <Lemmih> @google LFSP LFM
06:57:13 <lambdabot> http://www.paulgraham.com/vanlfsp.html
06:57:13 <CosmicRay> metaperl: true, but still dwarfed by JAva
06:57:15 <goron> Anyone seen the NetBeans IDE? That's like very easy to program Java in. It's the only reason to use Java instead of Haskell.
06:57:30 <yain> bleh.
06:57:35 <goron> Haskell has very limited IDE's.
06:57:52 <yain> if you think that nice ide is real reason you've completely missed the problem.
06:58:16 <Cale> Until fairly recently, it was also kind of impractical to write large Haskell programs, because there weren't many libraries. The situation is getting better, but this also slowly ties Haskell down in various ways.
06:58:19 <metaperl> CosmicRay: I agree 100%. Java is the most popular language out there
06:58:35 <goron> yain: That's true, I don't know what you were talking about.
06:58:35 <CosmicRay> metaperl: I think, actually, that just within the past year, Haskell has started to branch outside of academia.
06:58:52 <metaperl> CosmicRay: are you religious?
06:58:54 <metaperl> I think you are
06:58:58 <CosmicRay> metaperl: why?
06:59:11 <goron> yain: What were you talking about?
06:59:24 <yain> let me find you a link
06:59:33 <yain> some people explained that way better than i can do
07:00:30 <metaperl> because I apply monotheism to languages. I want the One True Language, just a religious people want the One True God. I am stuck on either C++ or Haskell as the One True Language. C++ is very appealing to me all of a sudden. It seems like the next step from perl5. Perl6 is a mess and I must get away from Perl before perl6 gets out... although I'm predicting 5 more years of work before it ever gets
07:00:41 <goron> Is there anyone that does agree with me that development with intergrated haddock support and  autocompletion makes development WAY faster?
07:00:54 <CosmicRay> metaperl: I want the One Preferred Language :-)
07:01:02 <metaperl> for the task at hand?
07:01:15 <yain> alas, cannot find it now.
07:01:27 <CosmicRay> metaperl: I want a language that can readily solve 95% of my problems... while it might not be the best language for every of those 95% of problems, I want it to be at least fairly convenient for them.
07:01:32 <yain> there were a little jobs discussions on lambda-..
07:01:51 <CosmicRay> metaperl: so I think I'm saying pretty much the same as you are.
07:02:04 <metaperl> CosmicRay: have you looked at C++?
07:02:11 <CosmicRay> yes
07:02:12 <yain> and one of the primary points there was that people who make decisions about which language to use, have some criterias that programmes never or rarely consider
07:02:15 <CosmicRay> it is a mess
07:02:38 <yain> like possibility to find sufficient amount of workers
07:02:50 <yain> that's very important thing for any business.
07:03:08 <metaperl> C++ is a mess?
07:03:11 <edwinb> What about "amount of competent workers"?
07:03:12 <df__> yes
07:03:28 <metaperl> I wonder why C++ has both namespaces and classes
07:03:50 <metaperl> look at how many apps are delivered in C++ though: web browsers,  irc clients, word processors, etc, etc
07:04:05 <edwinb> That doesn't necessarily make it a nice language...
07:04:09 <goron> yain: Well, my experience is that businesses don't jump on the bandwagon because of nothing. They want higher productivity. IDE's do really help.
07:04:22 <CosmicRay> I do consider Java to be a great improvement over C++
07:04:22 <CosmicRay> however the Java standard library stinks on oh-so-many ways
07:04:22 <CosmicRay> s/on/in/
07:04:22 <CosmicRay> yes
07:04:26 <yain> if write something in haskell, my boss will have real big problems when i'll leave the company.
07:04:26 <yain> goron: you got the idea?
07:04:27 <metaperl> I cannot pick on a language which has delivered so much more functionality than Perl and which is more popular in corporate america than perl
07:04:40 <CosmicRay> if you want nice OOP, Python 2.2 is a good language.
07:04:40 <CosmicRay> Python is probably the best OOP language around, IMHO
07:04:40 <CosmicRay> though I am not so sure about its future direction.
07:04:42 <yain> IDEs are consequence, not reason.
07:04:47 <goron> yain: Ofcourse I get the idea, since I already knew that.
07:05:02 <yain> hrms, either i'm lagging or
07:05:03 <metaperl> CosmicRay: I think I'd take Ruby over Python ... ruby on rails interests me greatly
07:05:10 <yain> something with link.
07:05:13 <goron> yain: I think they are correlated very strongly.
07:05:33 <goron> yain: No such thing as consequence or cause.
07:05:43 <CosmicRay> metaperl: when I was looking at a language to learn after Python, I looked at Ruby briefly, and basically concluded it's "pretty much like PYthon", but you may find it an interesting starting point
07:06:04 <CosmicRay> metaperl: being popular in corporate america says very, very little about the quality of a language
07:06:05 <metaperl> goron: I would think you would be into Clean if you like functional programming and IDEs :)
07:06:11 <metaperl> goron: since you are from the netherlands
07:06:22 <goron> metaperl: I get the impression Clean is dead.
07:06:36 <CosmicRay> metaperl: look at how many apps are delivered in functional languages: telco routing systems, real-time applications, etc.
07:06:42 <goron> metaperl: Since the university has the same job-opening as two years ago.
07:06:46 <CosmicRay> metaperl: ada is quite popular in military applications.
07:06:50 <goron> metaperl: The compiler hasn't been updated.
07:06:59 <metaperl> goron: yes, there is much less support
07:07:07 <metaperl> CosmicRay: but Aetion does military apps in Haskell
07:07:08 <CosmicRay> metaperl: it all depends on what you are looking for.  Erlang is used for some damn important code.
07:07:10 <goron> metaperl: And I don't like its syntax.
07:07:23 <metaperl> Clean looks just like Haskell to me
07:07:32 <metaperl> they just use a different evaluation model
07:07:35 <goron> metaperl: Then you have to look closer.
07:07:41 <metaperl> graphs versus lambda calculus
07:07:54 <metaperl> goron: I skimmed their online book
07:07:55 <goron> metaperl: Did you download and installed it? Looked at real source?
07:08:04 <metaperl> goron: no
07:08:05 <metaperl> I didnt
07:08:16 <metaperl> CosmicRay: you think C++ is a mess?
07:08:19 <metaperl> why so?
07:08:22 <goron> metaperl: Ok, I didn that, and that's why I think that.
07:08:22 <CosmicRay> metaperl: http://www.google.com/search?q=c%2B%2B+sucks&sourceid=mozilla-search&start=0&start=0&ie=utf-8&oe=utf-8&client=firefox&rls=org.mozilla:en-US:unofficial
07:08:40 <CosmicRay> also http://weblog.pell.portland.or.us/~orc/2005/04/12/000/ has some good stuff in its first paragraph
07:08:46 <CosmicRay> ok there are several reasons.
07:08:56 <CosmicRay> one is that they can never decide on any particular way to do anything.
07:09:09 <yain> goron: btw one of the reason that so much java ides exist is necessity in a lot of boilerplate.
07:09:23 <CosmicRay> how many ways can you pass a variable in C++?  I don't even know anymore.  At least three (value, pointer, and reference)
07:09:33 <goron> yain: True, but boilerplate code is not my reason to use netbeans.
07:09:42 <musasabi> There is research done in clean still...
07:09:43 <mauke> CosmicRay: only two, really
07:09:48 <CosmicRay> C++ has inheritance, templates, and -- added since I first learned it -- patterns
07:09:54 <mauke> CosmicRay: by value and by reference
07:10:04 <CosmicRay> mauke: you can still do pointers, and people do
07:10:06 <goron> yain: The documentation integration is for me *the* reason to use it.
07:10:10 <mauke> CosmicRay: pointers are just values
07:10:28 <mauke> CosmicRay: what are C++ patterns?
07:10:34 <timbod> CosmicRay: what do you mean C++ patterns?
07:10:36 <metaperl> goron: use what?
07:10:46 <yain> goron: that's a minor point imho.
07:10:54 <yain> goron: really minor.
07:10:56 <goron> metaperl: NetBeans instead of vim for java development.
07:10:57 <metaperl> CosmicRay: what you are saying about C++ is what I have to say about Perl6
07:11:00 * Philippa_ reads up...
07:11:05 <metaperl> goron: have you seen Eclipse
07:11:11 <Philippa_> metaperl, not every religious person wants a One True God
07:11:15 <metaperl> CosmicRay: have you looked at Perl6
07:11:22 <metaperl> Philippa_: true true true!
07:11:30 <goron> yain: I don't know the order and types and names of all function signatures.
07:11:32 <CosmicRay> timbod: I'm not really sure, the C++ programmers I know are all excited about patterns since they make templates obsolete...  I thought templates were crap to start with, so...
07:11:36 <goron> metaperl: yes
07:11:38 <CosmicRay> metaperl: not really, no.
07:11:49 <goron> metaperl: Eclipse couldn't import ant files.
07:11:49 <metaperl> Philippa_: actually God would be absolute potential doing nothing... including programming
07:11:56 <yain> goron: you are basically saying that haskell is used less than java because of ides existance. and when you are asked about ide, you tell that you use it because of documentation integration. do you really think that's sensible reason for someone to chose java over haskell?
07:12:26 <goron> yain: It depends on whay you do.
07:12:35 <metaperl> I dont understand why I want Programming Language Monogamy and yet a Harem of Women
07:12:39 <yain> maybe because java doesn't haev repl
07:12:39 <CosmicRay> heh
07:12:47 <yain> not :type nor :info
07:12:52 <yain> you need that integrations with docs
07:13:02 <yain> come to think of it.
07:13:04 <metaperl> actually both desires are instances of a desire for Control
07:13:12 <goron> yain: If there was NetBeans for Haskell, I would never use Java again.
07:13:17 <CosmicRay> metaperl: that is an interesting way to express it.
07:13:18 <timbod> CosmicRay: I think the conventional meaning of patterns related to the GOF book of the same name. Patterns are really just names for regularly used techniques. The concept of a pattern is language independent.
07:13:39 <CosmicRay> timbod: hmm.  yes, I am aware of that meaning.  I wonder how they could obsolete templates, though.
07:13:47 <goron> yain: And Java has acceptable Corba support.
07:14:00 <goron> yain: But that's again a library issue.
07:14:10 <yain> sorry i don't get this.
07:14:19 <yain> if you need tab completion for haskell write some vim/emacs script
07:14:23 <yain> or something
07:14:27 <CosmicRay> metaperl: like I said, I tend to pick one language to use for most things.  My first such language was C, then Perl 5 for quite awhile.
07:14:50 <CosmicRay> metaperl: I grew disillusioned with Perl 5 because it was difficult to make it scale to really large projects
07:14:51 <metaperl> Perl5 was _sweet_
07:14:51 <timbod> CosmicRay: I don't believe they do. templates are the stand out feature that makes C++ distinctive. It's the only mainstream language with parametrised types.
07:14:56 <goron> yain: The point is I want to drive the highway, not first put it there.
07:15:09 <yain> ah well
07:15:12 <CosmicRay> metaperl: the same features that made it kick-ass for quick parsing hacks also made it volatile for larger projects
07:15:17 <metaperl> timbod: isnt Java 2 getting that
07:15:43 <mauke> java generics are just compiler-generated casts around Object containers
07:15:44 <metaperl> CosmicRay: yes and strong typing was what made me like Haskell immediately. coming from a Perl background
07:15:47 <CosmicRay> metaperl: that's when I switched to Python.  Scales better, but still develops creaks, and wasn't as efficient in terms of developer time as I'd like.
07:16:40 <CosmicRay> metaperl: I used OCaml for a few months after that, and then moved to Haskell.  Haskell seemed to have all the features I wished OCaml did :-)
07:16:45 <metaperl> the most amazing thing about Haskell is how easily you can return to code you ahve not looked at for weeks... I am not kidding. You can go right back something you haven't seen in weeks and almost immediately pick it up due to referential transparency and lack of state
07:16:57 <timbod> metaperl: yes. though I haven't looked at them, I understand they are largely limited to collection classes, etc, and not the amazing stuff that people abuse templates for.
07:17:02 <CosmicRay> metaperl: and the non-intrusiveness of the Haskell strong-typing makes me like it, having been forced to use Java in the workplace :-)
07:17:21 <goron> Yes, locality is the main advantage of Haskell.
07:17:49 <CosmicRay> metaperl: yes.  I find that true, too.  much more so than even in python, which is generally touted as having that feature.
07:17:50 <timbod> CosmicRay: haskell has all the feature of ocaml that I would like, except for an easy to understand execution model
07:17:59 <goron> We only need a Sufficiently Smart Compiler. :D
07:18:12 <CosmicRay> timbod: isn't that compiler-specific?  (or do I misunderstand what you mean by execution model)
07:18:22 <Philippa_> a Sufficiently Annotatable Language'll do
07:18:42 <metaperl> goron: if you saw all the question marks, overloaded colons, adjectives verbs, at-signs , percent signs , exclamation points in the Perl 6 language references, you would say the lack of punctuation is Haskell's greatest asset :)
07:19:14 <timbod> Phillapa_ may be right. It's that fact that most people seem to find it hard to write haskell code that works on large data sets in constant space.
07:19:36 <metaperl> because you never modify data in place
07:19:37 <goron> Philippa_: Why can't those annotations be derived from the source code? Or is it undecidable or something like that?
07:19:56 <metaperl> what is meant by annotation?
07:20:07 <Philippa_> it's either undecidable or intractable much of the time
07:20:09 <CosmicRay> timbod: on the other hand, for some problems, it is far easier.
07:20:19 <goron> metaperl: You put some meta-text to your program expressions.
07:20:21 <timbod> metaperl: no - It's much easier to right functional code in ocaml that runs in constant space.
07:20:28 <Philippa_> metaperl: adding a note to the code to supply extra info - for example, the type of an expression, or strictness info
07:20:41 <metaperl> timbod: yes I would imagine so.. what *functional* code?
07:20:45 <CosmicRay> for instance, if your data set is 2GB of data that is read in from disk, and you don't need to actually keep it all in memory at once (perhaps you are applying a transformation or analysis over each individual record), haskell makes this operation very nice compared to many others.
07:20:49 <Philippa_> being able to strictness-annotate haskell functions'd be useful, for example
07:20:51 <metaperl> oh
07:21:08 <goron> Would it be correct to say that a completely strict Haskell program is as fast as C?
07:21:22 <CosmicRay> depends on what you're doing, I'd say.
07:21:22 <metaperl> CosmicRay: what you say is true until you do web apps that you want to load in a lot of data when the server starts up..
07:21:27 <goron> (using the same programming style)
07:21:38 <timbod> CosmicRay: any language can do that: eg python:   for l in f.xreadlines(): ....
07:22:03 <Philippa_> timbod: most languages involve rather a lot more pain to do so
07:22:13 <reffie> when you are working on a project you should look in your garbage!!
07:22:14 <Philippa_> certainly you can't consume the value in most of them without knowing something like that's going on
07:22:21 <CosmicRay> timbod: but they can't do it in a transparent manner.  I can write a function that takes a String and returns an Int, and it doesn't matter if that string represents 2GB of data from readFile, or a simple 3-word literal
07:22:54 <metaperl> is it possible to limit a Haskell type by a boolean subroutine? e.g. the elements of this type all have been passed through a boolean subroutine which returned True for them
07:23:19 <timbod> how common is that approach in haskell? What I have read suggests that relying on lazy io is troublesome. I alway use strict IO in the IO monad...
07:23:21 <CosmicRay> metaperl: I'm not certain, but it seems to me that template haskell could do that.
07:23:25 <Philippa_> you could use Either on it and a wrapper type, or something of that ilk
07:23:36 <CosmicRay> timbod: I find lazy IO to be quite useful indeed, and I use it whenever I can
07:24:05 <Philippa_> data PassesPredicate a = PP a, or something like that
07:24:15 <metaperl> this is not real C++ code is it?
07:24:50 <timbod> CosmicRay: Sure, I'm not speaking from experience, just the number of posts that flow through haskell and haskell-cafe that talk about lazy IO wierdness.
07:25:15 <CosmicRay> timbod: there are tricks to it, for sure.  when dealing with disk files or stdin/stdout, it doesn't seem to be all that complex to me.
07:25:29 <CosmicRay> if you're writing network code or somethign like that, then you really do have to be more careful
07:26:05 <timbod> I don't think you have the choice of doing lazy network code do you?
07:26:18 <CosmicRay> yes
07:26:22 <CosmicRay> I have done it on occasion
07:26:46 <CosmicRay> in fact, my FTP client library in MissingH can give you a FTP file in the same manner as readFile gives you a local file
07:27:22 <timbod> Cool - I should take a look when I have time.
07:28:07 <musasabi> Does cabal support using preprocessors which are in the same package as executables as the library which needs them?
07:28:57 <metaperl> I want to thank you all for restoring my drive to learn Haskell...there is no good free resource on Haskell, but the Thompson book is right on the money
07:29:32 <timbod> Anyway it's time for me to go to work. Which is kind of topical for the above conversation: I work in a development team of approximately 20. C++ is the language of choice. Haskell is the most interesting language I know, but I can't imagine using it in a corporate environment.
07:29:46 <CosmicRay> timbod: haddock for it at http://www.quux.org/devel/missingh/html/MissingH.Network.FTP.Client.html
07:30:18 * Lor has used haskell in a corporate environment.
07:30:24 * CosmicRay imagines haskell would have a lot of advantages over c++ in that environment
07:30:29 <Cale> I can imagine using Haskell in a corporate environment to great success, if only the programmers could be trained/acquired
07:30:31 <Lor> It was for prototyping a C module.
07:30:32 <yain> eh, advantages.
07:30:45 <yain> when you have a team that's good at c++ there is no advantages.
07:30:59 <Cale> There ought to actually be quite a few
07:31:03 <Lor> There was a rather tricky algorithm that had to be implemented, and it was trivial to translate the algorithm directly into Haskell.
07:31:04 <yain> advantages doesn't lie in language itself.
07:31:11 <timbod> CosmicRay: thanks
07:32:03 <Cale> Haskell code is often much much shorter and easier to think about and easier to verify than equivalent C++ when it comes to tricky algorithms
07:32:13 <timbod> Lor: that's interesting - with how big a team?
07:32:18 <yain> that's common problems with all programmers. they think that if language is powerful then it immediately be an  advantage to use it in their company.
07:32:31 <metaperl> Haskell is well setup to handle metaprogramming tasks. That's why nitty-gritty in your face tasks take longer.
07:32:33 <yain> some of them understand library issues.
07:32:41 <yain> but rarely someone goes beyong that.
07:32:47 <Cale> It's an advantage to be able to show that your code does what you say that it does.
07:33:00 <CosmicRay> yain: you keep saying this, but what exactly do you mean?
07:33:29 <CosmicRay> yain: are you talking about "gets hit by a bus" replacement scenarios?
07:33:51 <yain> get hit by bus? run that by me again.
07:35:42 <yain> i mean that thing that's usually referred to as "corporate environment" often presents different requirements to languages.
07:35:50 <yain> different from what coder thinks to be important.
07:36:42 <Lor> timbod, I did it by myself. It was a module of a software that had maybe two or three developers in total.
07:37:20 <yain> i'm not opposed to haskell or something. i just want to say it's a bit more complex than pure feature comparison.
07:37:21 <keverets> Cale: definitely an advantage to show that it does what it says that it does, the difficulty comes in being able to show how the elegant code becomes actual machine code.  Assembly -> C -> C++ -> Java people understand.  The leap to how functional programming relates is not so easy.
07:37:49 <yain> i can even give you examples if you want.
07:37:56 <yain> to be clearer.
07:39:50 <Spark> companies want cheap features
07:40:00 <CosmicRay> yain: yes, I'm asking you for examples
07:40:16 <Spark> they hardly ever care about bug fixes let alone general maintanence, or such highbrow concepts as writing software that actually works :)
07:40:38 <Spark> and its always about interfacing with existing code bases and other general wank
07:40:40 <yain> CosmicRay: ok, for example i develop some data presentation software which is tied to oracle. can i use oracle from haskell?
07:40:53 <CosmicRay> yain: yes
07:40:58 <Spark> plus they seem to like php so i think theyre all clinically insane as well
07:41:02 <yain> CosmicRay: oh, very good! but now, to be consistent i want to write my SPs in haskell to.
07:41:09 <CosmicRay> SPs?
07:41:18 <yain> CosmicRay: because i don't want to have half of application written in haskell and the other half in c
07:41:23 <yain> stored procedures.
07:41:44 <yain> i bet you just cannot do it.
07:41:56 <CosmicRay> I have no idea how SPs work with oracle, so I don't know.
07:42:22 <CosmicRay> yain: but how is that any different than what you'd face with, say, perl?
07:42:38 <yain> the difference is that you can write sps in perl afaik
07:42:44 <metaperl> yain: you might look at HaskellDb
07:42:48 <yain> or at least you can do that in C, that's for certain.
07:43:02 <metaperl> yain: HaskellDb allows for database query abstraction/reuse from the Haskell level
07:43:07 <CosmicRay> yain: I wouldn't be so sure abuot Perl
07:43:19 <yain> ok, let's not oppse that to perl.
07:43:38 <metaperl> yain: you cant write SPs in Perl... save for MyPerl a MySQL extension
07:43:40 <yain> C will suffice for my example.
07:43:57 <metaperl> yain: do you mean Oracle Pro*C?
07:44:57 <Cale> Wouldn't the need for stored procedures be decreased by having a better language with which to compose SQL queries?
07:45:06 <musasabi> Has anyone used cabal to install executables successfully? It seems to install them with mask 744 instead of 755, which means that no-one else than root may execute them...
07:45:20 <Heffalump> musasabi: what's your umask?
07:45:40 <musasabi> 022
07:45:48 <yain> Cale: no it won't.
07:46:04 <yain> Cale: because sp are always faster, and sometimes they are 10x times faster.
07:46:19 <yain> Cale: and this is only one example of "corporate environment" view of things.
07:46:24 <Cale> that's a pretty small constant factor :)
07:47:19 <metaperl> Cale: you want to do everything server side instead of with client-server computing to avoid network latency. that's where stored procs are good
07:47:31 <yain> not only network latency.
07:47:44 <CosmicRay> yain: there are often language requirements for things.  Libary x is written in language y, can we use it in language z?
07:47:51 <CosmicRay> I don't see how this is unique to a corporate situation
07:47:53 <yain> they are usually get compiled etc. various database specific optimizations can come into play.
07:49:25 <yain> that's not unique.
07:49:33 <boegel> Cale: do you happen to know anything about L-systems ?
07:49:38 <tuomov> I see no problem with using multiple languages for a project. that happens all the time.
07:49:44 <yain> but let's evolve this example a bit.
07:49:55 <Cale> boegel: I know a bit about them. I do have to run though
07:50:11 <yain> or rather not.
07:50:14 <tuomov> nobody in their right mind writes a whole program in C(++)
07:50:18 <yain> i think it's pretty complete already.
07:50:29 <tuomov> you write the parts that need speed in it and then the rest in a higher-level language
07:50:36 <boegel> Cale: if you have any interesting articles/links on the topic, let me now
07:50:52 <boegel> tuomov: oh yes they do
07:50:52 <Cale> boegel: the wikipedia article is reasonable iirc
07:51:12 <boegel> Cale: read that, I meant about applications of L-systems, examples and such
07:51:18 <timbod> bye!
07:51:28 <Cale> oh
07:51:32 <boegel> bye ! *darn
07:52:53 <Cale> http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx seems to provide a pretty good argument against stored procedures.
07:53:38 <yain> well, i don't think that would be interesting to object this.
07:54:58 <yain> they are unevitable in any complex project.
07:55:17 <yain> *inevitable
07:55:47 <yain> especially if it's something scientific.
08:01:42 <yain> hehe, i don't think i should waste time to read arcticles written by VB guy :P
08:05:09 <yain> back on topic: is there an easy way to embed ghci-like repl into my program?
08:05:45 <musasabi> How does one sleep forever in GHC? The beast detects "takeMVar =<< newEmptyMVar" and kills of my program with "thread blocked indefinitely" :-(
08:06:34 <Lycan359> I don't think I understand list comprehensions :|
08:07:36 <jlouis> Lycan359: Do you understand map and filter from the List library?
08:07:37 <Lemmih> @plugs [ n | n <- [1,2,3] ]
08:07:56 <lambdabot> [1,2,3]
08:07:57 <Lycan359> jlouis, Yeah.
08:07:58 <Lemmih> @plugs [ n + 1 | n <- [1,2,3] ]
08:08:02 <lambdabot> [2,3,4]
08:08:18 <jlouis> Lycan359: [f x | x <- xs] is a shorthand for map f xs
08:08:35 <musasabi> @plugs [n | n <- [1,2,3,4], even n]
08:08:40 <lambdabot> [2,4]
08:08:43 <jlouis> [x | x <- xs, p x] is a shorthand for filter p xs
08:08:58 <jlouis> add what Lemmih and musasabi does and you are a good way to understanding them
08:09:37 <jlouis> cartesian_prod xs ys = [(x, y) | x <- xs, y <- ys]
08:09:53 <jlouis> (for each x, map the ys)
08:10:20 <jlouis> cartesian_product xs ys = ... would be better
08:10:39 <Lycan359> I think I understand...
08:11:03 <jlouis> Lycan359: play with hugs or ghci !
08:11:10 <yain> (especially power when nested)
08:11:14 <yain> *powerful
08:12:00 <jlouis> yain: that, that would be the next thing for Lycan359 to do: Nest list comprehensions like [... | x <- [ ... | ...], ...]
08:12:25 <jlouis> Beware though, that misuse creeps in quickly
08:14:15 <Lycan359> ... that looks pretty bad.
08:15:06 <yain> so, what about my question? :P
08:16:17 <jlouis> yain: hmmm that is more like dons' table I think
08:16:39 <jlouis> I haven't played enough with Haskell yet to know
08:17:34 <yain> @source
08:17:35 <lambdabot> Unknown command, try @listcommands.
08:17:48 <yain> hm.
08:18:49 <SamB> @version
08:18:50 <lambdabot> lambdabot 3p0, GHC 6.4 (OpenBSD i386)
08:18:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:19:01 <SamB> @help version
08:19:02 <lambdabot> Report the build date, ghc version and darcs repo of this bot
08:19:12 <SamB> @listmodules
08:19:13 <lambdabot> babel base dice dict dummy dynamic fact haddock help karma lambda
08:19:13 <lambdabot> more pl plugs quote search seen spell state system todo topic type
08:19:13 <lambdabot> version vixen
08:19:32 <yain> guess i have to look at plugs.
08:19:34 <yain> thanks.
08:28:10 <Lemmih> Finally we've got support for building profiling libraries with Cabal!
08:28:54 <Igloo> Cool
08:29:40 <glimming> how hard is it to be accepted at the Haskell workshop?
08:29:53 <glimming> what is the acceptance rate for 04?
08:31:35 <Lemmih> Guess he wasn't too interested in the answer.
08:33:11 <CosmicRay> Lemmih: where?
08:33:45 <Lemmih> CosmicRay: Haven't pushed it yet.
08:34:25 <Igloo> CosmicRay: Are you back from your travels now?
08:37:07 <SamB> @index readM
08:37:08 <lambdabot> bzzt
08:37:18 <SamB> @index f
08:37:19 <lambdabot> bzzt
08:37:22 <SamB> @index map
08:37:24 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
08:37:54 <TheHunter> there's no readM in the libs.
08:38:16 <SamB> yeah. I wish lambdabot would say something more usefull than "bzzt"
08:38:55 <Lemmih> @seen SyntaxNinja
08:38:56 <lambdabot> I saw SyntaxNinja leaving #haskell 15 hours, 11 minutes and 27
08:38:56 <lambdabot> seconds ago, and I have missed 7 seconds since then.
08:40:39 <SamB> @index catch
08:40:40 <lambdabot> Control.Exception, System.IO.Error, Prelude
08:41:33 <SamB> @docs Control.Exception
08:41:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
08:45:42 <basti_> hi
08:46:55 <Lycan359> What's are some interesting haskell programs that I can look at?
08:49:56 <Lemmih> cabal-get is pretty interesting IMHO.
08:50:19 <kaol> are there even any boring haskell programs around? :-P
08:50:31 * boegel is glad his thesis is at the copy shop to copy and bind it *yaay
08:51:11 * boegel leaves to enjoy the sun and such
08:51:18 <Lemmih> Have fun.
08:51:27 <Lycan359> Cabel?
08:51:48 <Lycan359> Cabal rather... what is it?
08:52:01 <Lemmih> Common Architecture for Building Libraries and Applications.
08:52:28 <kaol> what little I've programmed haskell, I've found that my code ends up having nice solutions and such in it quite automatically
08:52:56 <Lemmih> It's the new way of building libraries in Haskell. And cabal-get can download and install them automagically.
08:54:57 <Lemmih> (where 'them' = Cabal packages)
08:55:55 <Lycan359> Why do you think that functional programming isn't as popular as imperative right now?
08:56:35 <musasabi> Lemmih: have you used the install target with executables? (seems that permissions are off)
08:56:36 <Lemmih> Same reason fast food and smoking is popular, perhaps?
08:58:27 <Lycan359> Heh
08:59:41 <yain> food is very useful.
08:59:48 <yain> i cannot imagine my life without it.
09:00:27 <Lemmih> On a more serious note, imperative languages can be easier to get you head around and they do get the job done.
09:02:11 <musasabi> Figuring semantics of imperative programs is harder.
09:04:06 <basti_> imperative programming languages are not as strict
09:04:16 <Philippa> er...
09:04:19 <basti_> (like in, "bondage and discipline language")
09:04:23 <Philippa> I assume you don't mean that in the technical sense :-)
09:04:35 <Philippa> and if you want absence of strictness, lisp is your friend
09:04:37 <basti_> uhm no.
09:04:43 <basti_> not strict/lazy
09:08:33 <SamB> @source
09:08:34 <_samb_lambdabot> lambdabot 3p465, GHC 6.4 (Linux i686)
09:08:34 <_samb_lambdabot> darcs get /home/naesten/hacking/haskell/lambdabot/base
09:08:34 <lambdabot> Unknown command, try @listcommands.
09:09:03 <SamB> _samb_lambdabot: @quit
09:09:29 <Lemmih> @version
09:09:31 <lambdabot> lambdabot 3p0, GHC 6.4 (OpenBSD i386)
09:09:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:14:14 <Lemmih> musasabi: You wanted to try Cabal with profiling support?
09:19:23 <Lemmih> dons: We can't load .a libraries, right?
09:27:36 <am02> chaps, is there a good way to print haskell .hs files? a latex converter maybe?
09:30:15 <SyntaxNinja> am02: http://www.cs.uu.nl/~andres/lhs2tex/
09:30:25 <Lemmih> Hey SyntaxNinja.
09:30:31 <SyntaxNinja> hi Lemmih. just replied to you
09:31:52 <Lemmih> Profiling for executables? Oh yeah, you're right. For some reason I though you couldn't do that (:
09:32:18 <Lemmih> And yes, the default is with profiling disabled.
09:34:15 <SyntaxNinja> sounds good; just a small change, then
09:34:42 <am02> SyntaxNinja: cheers compiling that now.
09:35:01 <SyntaxNinja> am02: np
09:50:00 <Lemmih> Using the same flag to enable profiling in libraries and executables is bad /-:
10:08:10 <luqui> can I make a list that is a copy of another list but without the last element?
10:08:55 <Lemmih> @plugs init [1,2,3]
10:09:03 <lambdabot> [1,2]
10:09:18 <luqui> nice
10:09:21 <luqui> and without the first element?
10:09:24 <luqui> oh duh
10:09:31 <Lemmih> @plugs tail [1,2,3]
10:09:33 <lambdabot> [2,3]
10:09:39 <luqui> thanks
10:10:07 <Lemmih> Beware of the complexity of 'init'.
10:10:48 <luqui> yeah, infinite lists might get me killed
10:11:07 <yain> folks
10:11:11 <yain> is there something like x [f] -> [f1 x, f2 (f1 x), f3 (f2 (f1 x)), ..]?
10:11:32 <yain> just to avoid wheel reinvention.
10:15:47 <yain> i'll take this as "no"
10:17:19 <wilx> Hm...
10:17:28 <wilx> scanl/scanr?
10:17:33 <wilx> @index scanr
10:17:34 <lambdabot> Data.List, Prelude
10:17:42 <wilx> @type scanl
10:17:47 <lambdabot> scanl :: forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:18:05 <wilx> Maybe...
10:18:18 <edwinb> Seems a bit like foldl (.) id
10:18:41 <SamB> @type foldl (.) id
10:18:42 <lambdabot> foldl (.) id :: forall b. [b -> b] -> b -> b
10:18:49 <yain> hm yes, like foldl
10:18:59 <yain> but function accepts one parameter, so it's not operator
10:19:00 <SamB> @type foldl ($)
10:19:02 <lambdabot> bzzt
10:19:14 <SamB> @type foldl (flip ($))
10:19:15 <lambdabot> foldl (flip ($)) :: forall b. b -> [b -> b] -> b
10:19:53 <yain> hm, no
10:19:59 <yain> that will reduce list to one value.
10:20:00 <edwinb> foldl (.) id woudl like a list of functions and apply them to your input in turn...
10:20:10 <edwinb> oh!
10:20:16 <edwinb> I've misunderstood what you wanted, sorry.
10:20:53 <yain> well, nevermind than. i asked just to make sure that i didn't missed something obvious in prelude
10:21:04 <SamB> @type scanl ($)
10:21:05 <edwinb> It's slightly more complicated, so you probably haven't missed anything.
10:21:06 <lambdabot> bzzt
10:21:11 <SamB> @type scanl (.)
10:21:12 <lambdabot> scanl (.) :: forall b c. (b -> c) -> [b -> b] -> [b -> c]
10:21:18 <SamB> @type scanl (.) id
10:21:20 <lambdabot> scanl (.) id :: forall b. [b -> b] -> [b -> b]
10:21:54 <SamB> @type map (flip ($)) scanl (.) id
10:21:56 <lambdabot> bzzt
10:22:06 <SamB> @type map ($) scanl (.) id
10:22:08 <lambdabot> bzzt
10:22:18 <SamB> @type map ($) . scanl (.) id
10:22:20 <lambdabot> map ($) . scanl (.) id :: forall b. [b -> b] -> [b -> b]
10:22:32 <SamB> @type map (flip ($)) . scanl (.) id
10:22:34 <lambdabot> map (flip ($)) . scanl (.) id :: forall b b1.
10:22:34 <lambdabot>            [b1 -> b1] -> [((b1 -> b1) -> b) -> b]
10:22:43 <SamB> nope..
10:23:40 <SamB> @type \fs -> map (flip ($)) (scanl (.) fs)
10:23:42 <lambdabot> bzzt
10:24:05 <SamB> @type ($)
10:24:06 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
10:24:09 <SamB> @type flip ($)
10:24:11 <lambdabot> flip ($) :: forall b b1. b1 -> (b1 -> b) -> b
10:24:51 <SyntaxNinja> get a room ;)
10:26:31 * edwinb is bored so writes:
10:26:32 <edwinb> yain val [] = []
10:26:32 <edwinb> yain val (f:fs) = (f val):(yain (f val) fs)
10:27:54 <mauke> @pl \x fs = head fs x : foo (head fs x) (tails fs)
10:27:56 <lambdabot> (line 1, column 7):
10:27:56 <lambdabot> unexpected "="
10:27:56 <lambdabot> expecting pattern or "->"
10:28:00 <mauke> @pl \x fs -> head fs x : foo (head fs x) (tails fs)
10:28:02 <lambdabot> liftM2 ap (((:) .) . flip head) ((`ap` tails) . (foo .) . flip head)
10:28:13 <_SamB_> @type \x fs -> map ($x) (scanl (.) id fs)
10:28:15 <lambdabot> \x fs -> map ($x) (scanl (.) id fs) :: forall b.
10:28:15 <lambdabot>              b -> [b -> b] -> [b]
10:29:22 <SamB> @plugs (\x fs -> map ($x) (scanl (.) id fs)) 0 [(+1), (+2), (+3)]
10:29:48 <lambdabot> [0,1,3,6]
10:29:52 <SamB> @plugs (\x fs -> map ($x) (scanl (.) id fs)) 0 [(+1), (+2), (+3)]
10:29:54 <lambdabot> [0,1,3,6]
10:30:10 * SamB wonders what took so long the first time
10:30:20 <SamB> @pl (\x fs -> map ($x) (scanl (.) id fs))
10:30:22 <lambdabot> (. scanl (.) id) . map . flip id
10:31:06 <mauke> @pl \f -> f x
10:31:07 <lambdabot> flip id x
10:32:27 <SamB> @type scanl (flip id)
10:33:01 <lambdabot> scanl (flip id) :: forall c. c -> [c -> c] -> [c]
10:33:15 <SamB> @plugs scanl (flip id) 0 [(+1), (+2), (+3)]
10:33:44 <lambdabot> [0,1,3,6]
10:33:58 <yain> cool ;-)
10:34:25 <edwinb> heh
10:37:33 <yain> thanks everyone
10:45:25 <luqui> how do I do a compose sequence with a two arg thing on the end; i.e.
10:45:35 <luqui> quux x y = foo . bar . baz
10:45:39 <luqui> where baz takes two args
10:45:46 <mflux> you can ask the bot
10:45:56 <mauke> @pl \x y -> foo (bar (baz x y))
10:45:57 <lambdabot> ((foo . bar) .) . baz
10:46:03 <luqui> woah
10:46:14 <luqui> that bot kicks ass
10:46:30 <mflux> it might not be a good idea to use that in actual code though ;)
10:46:30 <luqui> I can't say that's terribly clear, though
10:46:42 <luqui> yeah no... I'll just name my args and use $s
10:47:17 <mflux> if you do that a lot, you could do some function dot2 and use it in infix-notation, maybe ;)
10:47:18 <luqui> thanks though
10:50:00 <luqui> hmm, I wrote a new op2 entry in Prim.hs, but it says it can't find the operator
10:50:05 <luqui> I mean
10:50:07 <luqui> wrong channel
10:50:10 <luqui> heheh
11:04:57 <sylvan> What's the current "best bet" for a statically typed, high-level, OO language.. Eiffel?
11:05:10 <sylvan> something like Ruby or Python but with static typing
11:05:15 <sylvan> (is what I want)
11:08:27 <mauke> OCaml maybe
11:09:15 <kolmodin> sylvan: is a .NET language ok? www.nemerle.org
11:10:01 <sylvan> Hmm... I'll just need to get .NET to work on linux then... =)
11:10:42 <kolmodin> "emerge mono" if you are using gentoo. then "emerge nemerle"
11:11:10 <sylvan> or apt-get in my case
11:11:18 <kolmodin> ah, ok
11:11:40 <yain> speaking of mono.
11:11:49 <sylvan> So why nemerle instead of, say, C#?
11:11:53 <yain> gtk bindings work already?
11:12:38 <kolmodin> you get type inference
11:12:52 <sylvan> ah, okay.. (looking at the web site now)
11:13:14 <kolmodin> a few nice examples http://nemerle.org/Second_Tutorial
11:14:11 <sylvan> it's not pure then?
11:14:41 <kolmodin> no. not more pure than ocaml
11:14:47 <sylvan> ok
11:26:55 <sylvan> Someone should do a wxWidgets binding in .Net... That way all apps would have a native look and feel...
11:31:16 <musasabi> sylvan: or just use wxHaskell
11:36:03 <shelarcy> WideStudio has OCaml binding, but WideStudio isn't native look&feel and latest (OCaml Support) binary is provied only Windows platform.
11:36:08 <shelarcy> http://www.widestudio.org/EE/index.html
11:40:52 <sylvan> musabi: well "some people" won't let you use Haskell always... Also you'd want access to the .Net libraries
11:52:26 <wilx> Wow.
11:52:33 <wilx> I hae never heard about Wide Studio.
11:58:50 <SamB> @docs Text.PrettyPRint
11:58:51 <lambdabot> Text.PrettyPRint not available
11:58:56 <SamB> @docs Text.PrettyPrint
11:58:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text.PrettyPrint.html
12:00:58 <Heffalump> what is the hierarchical modules equivalent of CForeign?
12:04:15 <monochrom> CForeign
12:04:22 <Heffalump> ah :-)
12:05:25 <Igloo> Isn't it Foreign.C?
12:05:39 <Igloo> Or are the names just similar?
12:07:51 <monochrom> oops, Foreign.C it is
12:08:00 <Heffalump> ta
12:08:13 <Heffalump> Perl.hsc lives!
12:08:21 <basti_> hmm
12:08:35 <basti_> can one introduce new Monads or Arrows foreignly?
12:08:51 <Heffalump> you'd need to define the type class instance itself in Haskell
12:09:06 <basti_> ah but the functions can be foreign?
12:09:10 <basti_> the implementations
12:10:43 <Heffalump> don't see why not
12:10:54 <basti_> hmm i see.
12:10:57 <Heffalump> oh, does the FFI have syntax to introduce foreign operators?
12:11:04 <basti_> uhm
12:11:12 <basti_> i don't know, but now I don't see why that should matter ;)
12:11:15 <Heffalump> in fact, I don't think you'll be able to directly make the implementations foreign
12:11:29 <Heffalump> you'll have to make the actual instance refer to other foreign functions
12:11:46 <basti_> hmm.
12:12:04 <basti_> that wouldnt be much of a problem.
12:12:07 <Heffalump> indeed, presumably this is how the IO and ST monads are defined
12:12:15 <basti_> i see
12:12:37 <basti_> Philippa had this idea about yampa and sound processing...
12:17:31 <Heffalump> what namespace should a Perl interface for Haskell go under?
12:17:43 <Heffalump> (embedding Perl in Haskell, rather than vice-versa)
12:18:22 <basti_> LanguageLikeThings.Perl? ;)
12:18:39 <luqui> you're embedding perl in haskell?
12:18:47 <Heffalump> yes
12:18:56 <luqui> are you working on pugs?
12:19:51 <Heffalump> no
12:20:04 <luqui> because we just did that...
12:20:09 <Heffalump> oh.
12:20:19 <luqui> I wasn't involved, but you can go to #perl6 and ask autrijus about it
12:20:25 <luqui> or ask him here :-)
12:20:58 <Heffalump> is the interface on the web somewhere?
12:21:13 <luqui> no, it's not really mature
12:21:14 <autrijus> Heffalump: yes
12:21:17 <luqui> okay fine
12:21:28 * luqui slinks into the shadows
12:21:41 <autrijus> Heffalump:
12:21:42 <autrijus> http://svn.openfoundry.org/pugs/src/Pugs/Embed/Perl5.hs
12:21:47 <autrijus> (scroll down)
12:21:48 <autrijus> http://svn.openfoundry.org/pugs/src/Pugs/Run/Perl5.hs
12:21:54 <autrijus> the C side API is http://svn.openfoundry.org/pugs/src/perl5/
12:22:05 <autrijus> I tried to keep it as independent of Pugs as possible
12:22:13 <autrijus> if you want to pick it up and make it System.Eval.Perl5
12:22:16 <autrijus> I'd be very grateful and just use that
12:22:34 <autrijus> Heffalump: Pugs can already call DBI etc
12:22:40 <autrijus> see http://use.perl.org/~autrijus/journal/ for details
12:22:55 <Heffalump> ok, ta.
12:24:47 <autrijus> :)
12:26:19 <autrijus> Heffalump: in my eval/apply APIs there is an extra "env" slot that can hold a HsPtr
12:26:24 <Heffalump> seems to depend on pugsembed.h, though
12:26:34 <autrijus> Heffalump: it's in the same dir
12:26:38 <Heffalump> ah, ok
12:26:39 <autrijus> you can also factor it away :)
12:26:47 <autrijus> the "env" is there to maintain perl 6's lexical context across calls
12:26:57 <autrijus> so perl 5 can "eval" back and resume the context
12:27:01 <autrijus> (control context too)
12:27:07 <autrijus> may or may not be useful generally
12:27:11 <autrijus> if not just pass nullPtr to it
12:27:41 <Heffalump> I think I'll stick with what I've done right now, cos I've got it doing hashes which I need, and an interface I prefer, but if/when I have time I'll certainly look at making a 'proper' System.Eval.Perl5 or whatever
12:27:53 <autrijus> Heffalump: ok. where are your code at?
12:27:57 <Heffalump> nowhere online yet
12:28:12 <Heffalump> I was just cleaning up a very nasty hack I put together a few years back.
12:30:02 <Heffalump> I'll put it online, hangon a bit
12:34:28 <autrijus> ok... I do think we should coordinate a bit :)
12:34:50 <autrijus> since pugs will likely integrate even more of perl 5 gradually
12:34:59 <autrijus> including the MG system and even Coro
12:35:23 <autrijus> so I'd like to do it in a way that cleanly separates the Pugs types and the generally reusable types
12:35:54 <yain> just out of curiosity, why embed perl in haskell? because of CPAN?
12:36:01 <autrijus> yain: aye.
12:36:10 <autrijus> to me, at least
12:36:27 <autrijus> although haskell makes it trivial to code things
12:36:38 <autrijus> "not coding" always trumps coding
12:36:38 <autrijus> :)
12:51:59 <mflux> hmh, I'm trying to make a wrapper for a function that takes a bunch of RealFrac-derived arguments, however, I can't apparently the get types right
12:52:01 <yain> @plugs cycle [1,2,3]
12:52:10 <lambdabot> [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,
12:52:10 <lambdabot> 2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,
12:52:10 <lambdabot> 3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,
12:52:10 <lambdabot> 1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,
12:52:10 <lambdabot> 2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,
12:52:10 <lambdabot> 3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,
12:52:12 <lambdabot> 1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,
12:52:13 <yain> ops.
12:52:14 <lambdabot> [24 @more lines]
12:52:33 <mflux> I guess there is something more to Integral, RealFrac, fromIntegral etc than I know. anyway, the source (working + non-working) is at http://www.modeemi.cs.tut.fi/~flux/software/Layout.hs if anyone bothers to check it out
12:54:02 <mflux> it is an algorithm attempting to nicely place objects in a horizontal or vertical box (in a user interface)
12:54:04 <Heffalump> autrijus: http://urchin.earth.li/darcs/haskell-perl5-binding/
12:54:12 <mflux> isn't quite perfect though ;)
12:54:47 <Heffalump> (I don't really grok perlembed/xs so you might be able to point out obvious flaws with what I'm doing)
12:56:06 <autrijus> Heffalump: ok... you don't need to use cpan modules?
12:56:17 <autrijus> Heffalump: like DBI etc
12:56:26 <Heffalump> I do need to use a module I've written - that was what I was going to do next.
12:56:27 <autrijus> because the way you wrote it it can't do dynamic loading
12:56:31 <Heffalump> oh.
12:56:37 <autrijus> but if your modules is pure perl
12:56:38 <autrijus> then it's fine
12:56:46 <autrijus> if so, don't need to worry about that
12:56:57 <Heffalump> well, I was planning on passing in an module to the embedding used by initPerl
12:57:06 <autrijus> if you need to use XS (.so) modules, then you need to link in DynaLoader and fix your xs_init
12:57:12 <autrijus> again, see Pugs src/perl5/* for how
12:58:31 <Heffalump> your xs_init looks like mine to me
12:58:43 <tuomov> mflux: haskell doesn't have a default realfrac? You need to tell it to use some particular instance?
12:59:06 <autrijus> Heffalump: no... you need perlxsi.c
12:59:11 <autrijus> see perlxsi.c
12:59:16 <Heffalump> I have perlxsi.c, it gets made by my Makefile
12:59:17 <autrijus> my xs_init does this
12:59:18 <autrijus>         newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
12:59:19 <autrijus> oh.
12:59:26 <mflux> tuomov, hmm, so how would I write the code so that it works all possible RealFracs?
12:59:27 <autrijus> ok then. didn't see that. sorry
12:59:43 <autrijus> then that's just fine. false alarm
12:59:57 <mflux> tuomov, I mean, the first function works fine.. the second doesn't quite get the wrapping conversions right
13:00:12 <tuomov> write another wrapper with more constrained type definition that layoutIntegral calls? Or put type definitions somewhere in the code
13:01:40 <tuomov> layoutDouble :: ...., layoutDouble = layout
13:02:03 <mflux> ah, so now I get what the problem actually is
13:02:07 <mflux> thanks
13:02:17 <tuomov> I'm not sure if this is the problem, but I guess...
13:03:58 <Heffalump> I'm a bit confused by your initPerl5 code, it seems to pass "-e -e foo" to the C version
13:04:09 <Heffalump> (as three separate strings)
13:05:21 <autrijus> yeah
13:05:23 <autrijus> -e is the program name
13:05:27 <autrijus> -e foo are the args
13:05:32 <autrijus> they are argvs
13:05:42 <Heffalump> ah.
13:06:03 <Heffalump> so it's coincidence they are the same?
13:06:13 <autrijus> yeah
13:06:21 <autrijus> well, it's customary for $0 of a evalled perl program to be called "-e"
13:07:07 <Heffalump> how would you load modules?
13:08:33 <autrijus> Heffalump: by evalling "use Foo"
13:08:46 <Heffalump> how do the begin blocks work, then?
13:08:59 <autrijus> begin blocks work in evals.
13:09:03 <Heffalump> ok
13:09:07 <integral> it's CHECK and INIT that are dubious
13:09:23 <autrijus> they are dubious anyway.
13:09:29 <autrijus> (i.e. not too worried)
13:09:35 <integral> (at yet still people (dconway) use them)
13:09:47 <autrijus> not sure if conway count as people :)
13:09:58 <integral> heh
14:03:07 <SyntaxNinja> phragmented: got any haskell questions?
14:09:33 * SyntaxNinja thwaps phragmented
14:09:41 <SyntaxNinja> @lart phragmented
14:10:31 <wagle> he disappeared around noon
14:10:49 <Heffalump> what's he done?
14:11:02 <wagle> SyntaxNinja: talking to vendor about his G5
14:15:10 * dblhelix calls it a day
14:20:57 <phragmented> ninja: nah, I'm pretty much set in that department.
14:30:33 <SyntaxNinja> wagle: he's a trouble maker.  I wonder where he went at around noon. hmmmmm
14:30:34 * boegel is sweating like hell
14:30:50 <boegel> damn, it's 23h30 over here, and still 20 C :s
14:31:08 <monochrom> need to move to australia
14:31:35 <jlouis> boegel: yeah, it is insane. Sweating here a couple of 1000 kms north of you
14:31:44 <SyntaxNinja> where are you guys?
14:31:55 <jlouis> Denmark, Copenhagen
14:32:31 <boegel> Torhout, Belgium
14:32:44 <boegel> jlouis: more like 1200 kms :)
14:33:25 <jlouis> boegel: ok. Cannot measure such distances
14:34:05 <boegel> jlouis: I know because we went on holiday to Denmark of few years ago
14:34:31 <jlouis> checking GHC.Handle.openFd new API... failed
14:34:31 <jlouis> configure: error: Couldnt figure out how to call GHC.Handle.openFd!
14:34:39 <jlouis> hmmm, ghc-6.4... darcs 1.0.2
14:36:37 <boegel> I won't be able to sleep in this heat, and I have a final on Monday for which I didn't study yet :s
14:37:58 <jlouis> boegel: more coffee, more book
14:38:17 <Igloo> jlouis: Try 1.0.3
14:38:24 <jlouis> Igloo: thanks
14:43:39 <boegel> jlouis: it's not about staying awake
14:43:56 <boegel> I can study now, but ten my biorithm gets fucked up
14:44:28 <stepcut> @seen shapr
14:44:30 <lambdabot> I saw shapr leaving #haskell 1 day, 5 hours, 51 minutes and 42
14:44:30 <lambdabot> seconds ago, and I have missed 7 seconds since then.
14:44:36 <stepcut> heh
14:46:51 <MachinShin> hey +
14:46:56 <SyntaxNinja> hiya
14:47:16 <boegel> hey stepcut
14:51:34 <SyntaxNinja> lambdabot needs a lart command.
14:51:43 <stepcut> so, I need to create a gpg key
14:52:14 <stepcut> (1) how many bits should I use? and (2) is it a bad idea to put it on a usb key drive ?
14:53:04 <jlouis> stepcut: what do you wish to protect yourself against?
14:53:11 <jlouis> that determines (1)
14:53:17 <autrijus> and also (2).
14:53:36 <jlouis> (2) has pros and cons: easy movement but risk of loosing it is greater
14:53:56 <stepcut> I needed it for signing debian packages
14:54:03 <autrijus> if you do so, though, be sure to save the revocation information somewhere
14:54:12 <stepcut> so... protection from microsoft I guess ?
14:54:34 <autrijus> then just use the default :)
14:54:42 <stepcut> I figure it is either going to be on my laptop or my keydrive, and my laptop is more likely to be stolen than my keys
14:54:46 <jlouis> 1024 bits is default. I think 2048 is recommended now.
14:55:04 <autrijus> I'm using 1024/2048
14:55:09 <autrijus> pub/sub
14:55:23 <jlouis> Beware that GPG uses a symmetric cipher below (AES i think) with a key size of 128 bit or something. So it might end up easier to attack that algorithm for a single message
14:56:03 <jlouis> OTOH attacking the assymetric ciphers breaks all messages from you
14:56:30 <autrijus> jlouis: I think stepcut is just signing things
14:56:39 <autrijus> so attacking AES does not do any good
14:56:51 <jlouis> then it is weaknesses in SHA1 we want ;)
14:57:12 <autrijus> it's hard to find a same-sized collision that is also malicious :)
14:57:29 <jlouis> autrijus: sure is, heh ;)
14:59:55 <boegel> do you guys think it would be usefull to post something about H3D on the haskell mailing list ? to gather idea's ?
15:00:07 <jlouis> Igloo: thanks, 1.0.3 darcs seems to work
15:03:15 <boegel> nobody has an opinion on this ?
15:05:02 <astrolabe> What kind of ideas are you after?
15:06:15 <boegel> astrolabe: just idea's, check out the wiki page
15:06:17 <boegel> @wiki H3D
15:06:18 <lambdabot> http://www.haskell.org/hawiki/H3D
15:12:09 <astrolabe> I think it would be worth trying.  When you say 3d modelling, do you specifically mean 3d graphics?
15:12:29 <boegel> yeah
15:12:34 <boegel> but we could start slow
15:12:47 <boegel> bourbaki mentioned using Ogre3D as basis
15:12:56 <boegel> and implement L-systems for some cool stuff
15:13:16 <boegel> the problem is, I have no idea what's around that I can
15:13:19 <boegel> use
15:13:38 <boegel> I don't want to create just another modeller, but want to use Haskell's strengths
15:13:52 <sylvan> You should probably start by implementing a scene graph
15:14:10 <sylvan> should be nice and easy in Haskell too
15:14:31 <boegel> sylvan: meaning ? (see, i don't know much about it :) )
15:15:01 <boegel> bourbaki suggested to start with implementing an L-systems, and going on from there
15:15:09 <sylvan> basically a graph where each node could be, say, a transformation, can contain meshes and stuff like that.. So to render you just traverse this tree and perform each operation at the nodes..
15:15:31 <boegel> once the L-system is built, try and make a simple Ogre3D binding to visualise the stuff we can make with the L-system
15:15:32 <sylvan> L-systems, AFAIK, is basically for rendering trees and stuff.. Not an overall strategy for rendering...
15:16:07 <boegel> sylvan: it is, the problem is, I don't know which direction to go
15:16:18 <boegel> L-systems can be used to generate surfaces and such too
15:16:25 <boegel> maybe that's a cool place to start
15:16:30 <boegel> don't knwo really :)
15:16:37 <sylvan> sure... but you'll need some way to render it too.. =)
15:17:13 <boegel> well yeah, that's where Ogre3D comes in
15:17:16 <sylvan> I'd go with an overall "scene graph" which is very general and then add stuff to that... Start out with easy things like polygon-soups, and then parametric surfaces and so on..
15:17:35 <boegel> sound like a good idea
15:17:51 <sylvan> Well if you don't want to do the actual 3D-stuff in Haskell then it would be a good idea to use an existing engine...
15:17:56 <boegel> sylvan: could you add this to the wiki ? i don't want to lose idea's like this :)
15:17:57 <Consystor> hi all
15:18:00 <astrolabe> Maybe at this stage you should be working on coming up with some more concrete questions, and then post them.
15:18:03 <boegel> hi Consystor
15:18:08 <sylvan> well, not now.. Must sleep!
15:18:31 <Consystor> does anybody know where i can get good example code for the happy parser generator?
15:18:46 <sylvan> another idea is to simply write a scripting plugin for Orge3D which uses Haskell.. But that has to do with games, and not 3D.. But it would be cool to write 3D games in Haskell using an existing engine
15:18:49 <sylvan> anyway, good night!
15:19:02 <astrolabe> g'night
15:19:03 <Consystor> in the doc there are only some few lines of code, no good examples
15:19:09 <Consystor> n8!
15:19:16 <boegel> Consystor: I have some, but I guess it's too complicated to start with
15:19:34 <boegel> bye sylvan
15:19:40 <boegel> astrolabe: questions like what ?
15:20:08 <yain> heh, did a quick google on l-systems.
15:20:10 <Consystor> boegel: k, do u know another resource
15:20:11 <yain> cool indeed.
15:20:31 <boegel> Consystor: I don't know where I got my information to create something
15:20:47 <stepcut> 'DSA & ELGamal' or 'RSA' ?
15:20:48 <boegel> yain: yeah, check the H3D wiki, there are some cool links there
15:21:08 <astrolabe> It might be because I know nothing about the subject, but I don't get a clear idea of your goals from the wiki page.
15:21:40 <boegel> astrolabe: hmm, I see
15:21:47 <yain> boegel: http://studwww.ugent.be/~kehoste/thesisPublic/website/ <-- that's yours i assume?
15:21:51 <boegel> maybe I could add a list of open questions
15:21:54 <boegel> yain: yes
15:21:56 <yain> nice stuff.
15:22:20 <yain> http://studwww.ugent.be/~kehoste/thesisPublic/website/21_04_2005/trans2.png
15:22:21 <yain> !
15:22:54 <boegel> yain: that's just the raytracing algorithm talking (and Perlin noise textures)
15:23:02 <boegel> anyone could create such an image :)
15:26:11 <Consystor> oh, now i c there r example codes in the src file..
15:29:38 <stepcut> this is one of my favorite perlin inventions:
15:29:39 <stepcut> http://mrl.nyu.edu/~perlin/experiments/draw/
15:30:07 <yain> no screenshots!
15:30:16 <yain> what's the use of book without pictures..
15:33:16 <yain> btw. anyone seen karl sims works?
15:33:41 <boegel> astrolabe: I edited the H3D page, added some questions (and temporary answers)
15:34:24 <astrolabe> I'll look
15:39:14 <astrolabe> I think that it's clearer now.  Would you have both a scene graph and L-systems as objects in the scene?
15:41:24 <boegel> I'm not sure I understand that question :)
15:41:38 <boegel> L-systems are a technique to create certain 'objects'
15:41:56 <boegel> a scene graph is something to describe transformations on a scene
15:42:00 <boegel> (I think)
15:42:07 <boegel> so neither could be objects in a scene :)
15:42:38 <boegel> but you mean, would we make different techniques available at the same time for the user ? I think that's a goal, yes
15:42:53 <astrolabe> Sorry.  I thought a scene-graph was like a list of objects in the scene, and the L-system represented certain objects.
15:43:08 <boegel> don't worry, I don't know much about it either :)
15:43:16 <boegel> but I'm learning, and that's the idea :)
15:51:00 * boegel posted a small mail to the Haskell mailing lists
15:51:31 <phragmented> stepcut: drawpad is cool!  Too bad I can't download it to my zaurus!
15:52:01 <stepcut> phragmented: indeed
15:52:13 <stepcut> phragmented: no java support ?
15:52:46 <phragmented> no jar download available that I could see. (zaurus does have a jvm...is there a download?)
15:52:55 * stepcut ponders
15:56:02 <stepcut> hrm, I guess you would have to email him and ask
15:56:54 <stepcut> I don't really know much about java, but i think the app is a single class file
15:57:03 * stepcut tries something
15:59:59 <stepcut> it appears to be a java applet, so you would need a java applet viewer for the zaurus
16:00:14 <stepcut> of course, there also does not appear to be a save function which limits the usefulness :)
16:07:17 <phragmented> I doubt it's only one class -- (at least I hope it isn't)...but you're right, without save, it's just a novelty. Thanks for the pointer, though. Neat!
16:09:12 * boegel goes to bed, g'night everyone
16:09:22 <astrolabe> night boegel
17:54:19 <Lunar^> It's so good to do some Haskell after hours of C... :D
17:54:27 <reffie> is it
17:54:32 <Lunar^> damn yes
17:54:37 <reffie> why?
17:55:01 <Lunar^> Because Haskell support your thought instead of fighting them
17:55:10 <Lunar^> the compiler helps you to get it rigth
17:55:12 <Lunar^> right
17:55:34 <Lunar^> once it compiles, it works, 90% of the time
17:58:37 <yain> and how often it works as you intended it to work?
17:59:04 <Lunar^> 90% of the time, as I said
18:11:08 <thou> so far i seem to be at about 2% of the time
18:11:19 <thou> but it's fun anyways
18:11:44 <thou> and i think there's just a little threshold that i'm still crawling over
18:13:43 <yain> sure, sooner or later you'll die.
18:16:35 <Lunar^> There sure is a step to take
18:16:47 <Lunar^> and then it's full of fun
18:21:36 <thou> yain: i'm not sure if maybe i'm already dead
18:22:03 <Cale> thou: your programs compile, and yet only work 2 of the time?
18:22:13 <Cale> 2%*
18:22:20 <thou> Cale: hehe, i don't have a very good sample size
18:22:25 <thou> :-D
18:26:13 <yain> thou shall not meddle with normal Man lifecycle!
18:32:01 <thou> why doesn't this print a line just after I hit Enter?  sequence (repeat getChar) >>= (putStrLn . show . head . lines)
18:32:10 <thou> (trying it in ghci)
18:33:09 <thou> i did hSetBuffering stdin NoBuffering
18:33:13 <thou> and for stdout, too
18:35:40 <thou> something to do with unsafeInterleaveIO?
19:24:21 <thou> hmmm, i asked the same question 2 years ago :-D  http://groups.google.co.nz/group/comp.lang.functional/browse_thread/thread/58dd32571bcd360a/8fdd4b6146a1b01f?q=unsafeInterleaveIO+getchar&rnum=1&hl=en
20:33:53 <thou> @paste
20:33:55 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:45:42 <lispy> hmm...lisppaste is better IMO
20:46:15 <dons> it is. the call back feature is better than the no-callback 'feature' of lambdabot
20:46:31 <dons> please submit a patch ;) we've started adding support for call backs
20:47:07 <lispy> dons: could we also do the webpage that goes with it?
20:47:08 <dons> or do you mean that lisp paste site is better than a wiki for the same purpose. that's true too
20:47:17 <lispy> the syntax highligting and so on, that's the part i really like
20:47:39 <lispy> the wiki is OK, but yeah i like submitting just the snip youcare about
20:47:44 <lispy> and seeing just it
20:47:48 <thou> i can never remember the @command to get the lisppaste url
20:47:50 <dons> people should wrap their wiki entries in {{{#!syntax:haskell }}}
20:48:13 <lispy> ah, i didn't know about that
20:48:27 <lispy> i think you can use lisppaste and say the channel is #haskell
20:48:35 <lispy> seems like i've done that before
20:48:49 <lispy> i was talking to a friend today and lambdabot came up :)
20:49:06 <lispy> my friend doesn't hang out in irc, but he still knew that version 3 was released
20:49:10 <lispy> i was impressed :)
20:49:33 <lispy> i think he's on the haskell mail list
20:49:44 <lispy> @lisppaste
20:49:45 <lambdabot> Unknown command, try @listcommands.
20:49:49 <lispy> @listcommands
20:49:50 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
20:49:50 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
20:49:50 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
20:49:50 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
20:49:50 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
20:49:51 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
20:49:52 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
20:49:55 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
20:49:56 <lambdabot> wiki wikipedia wn world02 yow
20:50:09 <thou> @lojban gismu
20:50:11 <lambdabot> ERROR: 501 Syntax error, illegal parameters
20:50:24 <lispy> what is lojban?
20:50:40 <cevans> A constructed spoken language.
20:50:40 <lispy> i don't understand a lot of those commands :)
20:51:14 <lispy> @moo
20:51:15 <lambdabot>          (__)
20:51:15 <lambdabot>          (oo)
20:51:15 <lambdabot>   /-------\/
20:51:15 <lambdabot>  / |     ||
20:51:15 <lambdabot> *  ||V---||
20:51:15 <lambdabot>    ~~    ~~
20:51:17 <lambdabot> Betty Ford-type
20:51:19 <thou> @lojban le gerku cu batci le nanmu
20:51:19 <lambdabot> cow with milk
20:51:25 <lambdabot> ERROR: 501 Syntax error, illegal parametersERROR: 501 Syntax error,
20:51:25 <lambdabot> illegal parametersERROR: 501 Syntax error, illegal parametersERROR:
20:51:25 <lambdabot> 501 Syntax error, illegal parametersERROR: 501 Syntax error, illegal
20:51:27 <lambdabot> parametersERROR: 501 Syntax error, illegal parameters
20:52:43 <thou> i don't like the @lojban command
21:07:01 <reffie> what does lojban do?
21:07:03 <reffie> @ghc
21:07:04 <lambdabot>  Simplifier reached fixed point
21:08:38 <dons> scary.
21:10:34 <conal> dons, i'm in CA now.  did you get my zip file?
21:10:53 <dons> yep, haven't had a chance to debug the code yet.
21:11:28 <conal> have you tried running it?  i'm wondering if it's all there.  and whether it runs under linux
21:11:37 <dons> ok. I'll have look now.
21:12:26 <conal> ok
21:13:20 <conal> dons, you could start with "make" and "make run"
21:14:47 <dons> doing so now. 
21:15:36 <dons> need wxHaskell. gimme a couple of minutes.
21:16:19 <conal> oh, right.
21:27:07 <Lemmih> Morning, #haskell.
22:00:29 <stefanh> how do I get the full path of the running program (getProgramName returns only the basename)
22:01:11 <kaol> that's OS dependant
22:02:38 <stefanh> ok, I should have mentioned that I'm using a unix-like system
22:02:46 <kaol> in Linux you can read it from /proc. I don't know what to do in other systems.
22:03:37 <dons> find it at configure time?
22:04:36 <dons> or Prelude> System.Cmd.system "which vim"
22:04:36 <dons> /usr/local/bin/vim
22:05:11 <kaol> IMHO any design depending on the full path of a program sounds like a bad idea (unless it's a program to specifically examine system statistics)
22:05:53 <stefanh> I want to find a configuration file which sits in the same directory as the binary
22:06:08 <kaol> don't do that.
22:06:14 <kaol> put it in /etc
22:06:29 <dons> shouldn't do that - that's not bsd friendly
22:06:41 <dons> $PREFIX/share/prog perhaps
22:06:48 <dons> $prog
22:07:05 <kaol> but anyway, it's something that's determined at install time
22:07:21 <stefanh> but it's not a "real" program as you don't install it. You just get it via darcs, compile it and run it
22:07:32 <stefanh> then change something and run it again.
22:07:35 <kaol> real programs get installed
22:07:48 <reffie> anyway, you can't find the full path of the running program.
22:07:55 <reffie> hard links.
22:08:14 <kaol> maybe assuming that the config file is at the current path might be sensible
22:08:21 <reffie> or it could not exist at all.
22:08:28 <kaol> s/path/working directory/
22:08:53 <kaol> or user's home directory
22:09:38 <stefanh> yeah, this I would do if it were a "real program". I'll do it with configure
22:13:05 * dons builds wxWidgets
22:13:42 <conal> dons, no binary version?
22:14:30 <dons> an obsolete one - I was getting undefined symbols.
22:14:59 <dons> eros built but wxGTK symbols were undefined when linking
22:15:29 <conal> oh
22:15:55 <dons> ... building .. building ...
22:18:03 <[TWiSTED]> hey all
22:18:19 <[TWiSTED]> can someone help me out with this problem, i know ive asked before but ive been stuck on it for ages
22:21:27 <Lemmih> Did you make a function which can do "Hi21He23" => ["Hi21","He23"]?
22:22:19 <[TWiSTED]> nah i can only do "Hi21He23" -> ["Hi","21He23"]
22:22:23 <[TWiSTED]> by using the filter fucntion
22:22:42 <[TWiSTED]> i mean
22:22:44 <[TWiSTED]> not filter
22:22:44 <Lemmih> 'break' you mean.
22:22:44 <[TWiSTED]> break
22:22:47 <[TWiSTED]> yeh
22:23:26 <[TWiSTED]> but that puts it in a tuple, not a list
22:23:30 <Lemmih> Ok. We also showed you how to do "21He23" => ("21","He23").
22:24:21 <Lemmih> So now you should be able to get "Hi", "21" and "He23", right?
22:24:29 <[TWiSTED]> break (not . isDigit) "21He23"
22:25:53 <Lemmih> Indeed. Now you have all the pieces. Time to put 'em together.
22:26:20 <[TWiSTED]> ok
22:29:01 <[TWiSTED]> so u gotta apply break (not . isDigit) on the 2nd element of the tuple that break (isDigit) "Hi21He23" creates?
22:29:04 <[TWiSTED]> if that makes sense
22:29:21 <Lemmih> Exactly.
22:29:32 <[TWiSTED]> ok
22:30:52 <[TWiSTED]> how do u access the 2nd element
22:30:54 <[TWiSTED]> snd?
22:31:11 <Lemmih> It would be easier to use pattern matching.
22:31:35 <Lemmih> (name,rest) = first break; (num,rest') = second break
22:31:38 <[TWiSTED]> hm ok
22:34:34 <[TWiSTED]> something like this?
22:34:34 <[TWiSTED]> parseFormula s  = (name,rest) = break (isDigit) name ; (num,rest') = break (not . isDigit) rest
22:35:09 <Lemmih> No. Use a 'where' clause.
22:35:48 <[TWiSTED]> parseFormula s  = (name,rest) = break (isDigit) name
22:35:48 <[TWiSTED]>                   where (num,rest') = break (not . isDigit) rest
22:36:21 <Lemmih> I advice you to read a Haskell tutorial.
22:36:34 <[TWiSTED]> aha ok
22:39:12 <[TWiSTED]> it says undefined variable 'rest'
22:39:59 <Lemmih> Did you try to compile the code you just pasted?
22:40:05 <[TWiSTED]> no
22:40:24 <[TWiSTED]> parseFormula s  | [(name,rest)] = break (isDigit) name
22:40:24 <[TWiSTED]>                   where [(num,rest')] = break (not . isDigit) rest
22:40:30 <[TWiSTED]> thats probably not correct either
22:41:07 <Lemmih> Don't expect you can write Haskell without reading a tutorial.
22:41:31 <[TWiSTED]> ok
22:48:30 <Lemmih> http://haskell.org/complex/introduction_to_programming.html is an easy read and tells you everything you need to know.
22:49:21 <[TWiSTED]> thanks man
22:53:28 <dons> yay. got eros to link :)
22:58:11 <[TWiSTED]> parseFormula s = (name, rest)
22:58:11 <[TWiSTED]>                  where
22:58:11 <[TWiSTED]>                      (name, rest) = break (isDigit) name
22:58:11 <[TWiSTED]>                      (num, rest') = break (not . isDigit) rest
22:58:15 <[TWiSTED]> hows that
23:03:01 <kaol> shouldn't you use s again somewhere? you're just throwing that away. are you even trying that one out with hugs?
23:03:58 <dons> conal, how do I get it to crash? switching to 'visual disk', sliding things, hitting apply -- doesn't seem to do it.
23:09:52 <conal> dons, oh!
23:10:10 <conal> sounds like it's working fine for you, while it crashes for me.  just a moment ...
23:10:43 <conal> okay, i looked at GFun.hs
23:11:02 <conal> line 96 is where i'm using your eval
23:11:33 <conal> do you have the version that is calling unsafeEval?
23:11:49 <dons> yep.
23:11:51 <conal> "SysEval.unsafeEval"
23:11:55 <dons>    eval' t = -- eval t
23:11:55 <dons>              let strA = "("++show t++") :: "++show tya in
23:11:55 <dons>              fromJust $
23:11:55 <dons>                unsafePerformIO (do putStrLn strA
23:11:55 <dons>                                    SysEval.unsafeEval strA [] :: IO (Maybe a))
23:12:20 <conal> yep, that's it.  so it doesn't crash for you.  are you running on linux?
23:12:25 <dons> now, what's 'a' -- shouldn't that be a more specific type?
23:12:34 <dons> i'm running on linux, yep.
23:12:58 <conal> a specific type?
23:13:46 <dons> or Float -> (Float,Float) -> Bool or something?
23:13:48 <conal> "a" is the type of the GUI.  For instance, Float -> (Float,Float) -> Bool
23:13:59 <conal> right!
23:14:23 <dons> and you know to apply the function you get from unsafeEval to the correct arguments?
23:14:40 <dons> let me compile hs-plugins with -DDEBUG and see what I get.
23:14:52 <conal> sure
23:15:26 <conal> yes, i know to make sure the function gets applied to correctly typed arguments.
23:15:49 <dons> yep. we have enough type info in startT don't we?
23:16:29 <conal> yes.
23:16:46 <conal> and i don't get a crash with "disk" (nonvisual)
23:16:57 <dons> oh!
23:17:03 <conal> and since you don't with the visual one, i guess the problem is windows-specific.
23:17:09 <dons> I wonder if this is wxHaskell related?
23:17:33 <dons> I'd expect *all* tests to fail if hs-plugins was the problem.
23:18:10 <dons> yep. it's definitely compiling and loading correctly for visual disk
23:18:32 <conal> oh.  could be a windows wxhaskell thing.  it's probably crashing in imageWPut in Image.hs.
23:18:43 <dons> i'm usnig the latest wxHaskell and wxWidgets
23:19:20 <conal> it's probably a subtle interplay between hs-plugins and wxHaskell, though.
23:19:39 <conal> the visual example works w/o crashing if i use my "eval" instead of yours.
23:19:52 <dons> yeah.
23:20:11 <conal> are you able to test under winxp?
23:20:39 <dons> nope, I can test on some other unix machines
23:21:34 <dons> cygwin support is very new - so there may well be `difficulties' to iron out of hs-plugins ;)
23:22:26 <conal> and who's doing that?
23:22:50 <conal> i mean cygwin support for hs-plugins
23:23:09 <dons> hmm. Vivian McPhail did the initial work, and Lemmih has helped some more since then.
23:23:38 <conal> i
23:23:51 <conal> i'm wondering what's a good strategy for tracking down this problem.
23:24:22 <conal> perhaps you could give me some tips on gathering more info, or maybe Vivian or Limmih could help track it down
23:24:45 <[TWiSTED]> parseFormula s = [(s, read rest)]
23:24:46 <[TWiSTED]>                  where
23:24:46 <[TWiSTED]>                      (s, rest) = break (isDigit) s
23:24:46 <[TWiSTED]>                      (s', rest') = break (not . isDigit) rest
23:24:52 <dons> conal, yep. firstly, what wxHaskell and wxWidgets versions do you have?
23:24:57 <Heffalump> hmm, another scrap your boilerplate paper, I wonder how readable it will be
23:25:04 <[TWiSTED]> compiles correctly, but when i input a string it has a 'c stack overflow' error
23:25:29 <conal> looking ...
23:25:53 <Lemmih> [TWiSTED]: (s, rest) = break isDigit s?
23:26:00 <dons> can I forward the src to vivian to see if he can reproduce it on his cygwin box?
23:26:20 <conal> yes, please.
23:26:43 <[TWiSTED]> yea that does the first part
23:26:55 <Lemmih> [TWiSTED]: You use 's' twice.
23:27:08 <[TWiSTED]> o rite
23:27:16 <conal> i'm using wxhaskell 0.9.4, updated May 8, windows ghc 6.4, linked here: http://wxhaskell.sourceforge.net/download.html
23:27:17 <dons> conal, also, can you run 'make regress' from within a new hs-plugins build, and send me the transcript -- just to check hs-plugins works ok on your box
23:27:37 <conal> sure.
23:27:46 <dons> ok. I'm using the same version, which I built just then.
23:27:58 <[TWiSTED]> so what should i change
23:28:03 <conal> by "new build", do you mean do another pull?
23:28:32 <dons> yep. clean out the bulid and pull the latest couple of patches.
23:28:46 <Lemmih> [TWiSTED]: Call it something different. Perhaps (name, rest) = break isDigit s
23:28:54 <conal> ok
23:28:55 <dons> there was 1 bug fix -- it shouldn't be related , but it's good to make sure you've got an identical hs-plugins src
23:29:02 <[TWiSTED]> ok
23:29:16 <[TWiSTED]> ok that works
23:29:20 <[TWiSTED]> but i still get an error
23:29:38 <[TWiSTED]> it outputs [("hi45hey23",
23:29:52 <[TWiSTED]> then 'program error: prelude.read: no parse'
23:30:03 <Lemmih> Of course it does.
23:30:11 <[TWiSTED]> o
23:30:27 <Lemmih> parseFormula s = [(s,...)]
23:30:58 <[TWiSTED]> that read function just turns rest into an int cos thats the required data type
23:32:31 <Lemmih> What's the contents of 'rest' when the input is "hi45hey23"?
23:33:12 <[TWiSTED]> o
23:33:14 <[TWiSTED]> null?
23:33:38 <Lemmih> No. It's "45hey23".
23:34:03 <[TWiSTED]> but like when i try use the function it outputs [("hi45hey23",
23:34:08 <[TWiSTED]> which is all the input
23:34:09 <conal> dons, there's no "regress" target.  do you mean "check"?
23:34:18 <[TWiSTED]> shouldnt that be atleast [("hi45",
23:34:34 <[TWiSTED]> i mean [("hi",
23:34:54 <dons> sorry, yep. 'make check'
23:34:57 <Lemmih> [TWiSTED]: You return 's' which is all of the input. Why does that surprise you?
23:35:04 <conal> ok.
23:35:37 <[TWiSTED]> hmm
23:36:07 <[TWiSTED]> arnt we applying break (isDigit) to 's' ?
23:36:27 <Lemmih> [TWiSTED]: All variables are immutable in Haskell.
23:36:54 <[TWiSTED]> ok
23:36:55 <Lemmih> [TWiSTED]: You put the result of 'break isDigit s' in 'name' and 'rest'.
23:37:23 <[TWiSTED]> o ok yep
23:38:39 <[TWiSTED]> so then we need to put the result of 'break (not . isDigit) rest in s' and rest'
23:40:26 <kaol> [TWiSTED]: BTW, break (not . isDigit) == span isDigit
23:40:53 <[TWiSTED]> o yeh, ehe thx
23:43:25 <conal> dons, just finished "make check".  sent you the result.
23:44:32 <[TWiSTED]> i see what the problem is Lemmih, you cant apply read to a string which contains characters, but im not too sure how else i can make it match the corresponding datatype
23:45:14 <Lemmih> [TWiSTED]: You've already broken the number out of the string. Use read on that.
23:46:34 <[TWiSTED]> read on s'
23:49:06 <dons> conal, looks like a couple failed, yep. but I don't know if they're relevant.
23:49:37 <conal> do you need any more info from my end?
23:50:10 <dons> not at the moment, I'll do some more testing, and forward it on to viv to look at. hopefully we'll get some result in the next couple of days
23:50:42 <conal> that's great.  i sure appreciate the help.
23:50:53 <dons> sure!
23:51:14 <conal> i'm off to bed now.  take care.
23:51:20 <[TWiSTED]> (name, rest) = break (isDigit) "hey12hi34" -> ("hey","12hi34")   and  (s', rest') = break (not . isDigit) rest -> ("12","hi34")  so do i apply read to s' ?
23:52:25 <dons> night, conal
23:52:52 <Lemmih> [TWiSTED]: What do you think?
23:54:22 <[TWiSTED]> well id think so considering thats the number broken out of the string
23:54:33 <Lemmih> Try it.
23:54:59 <[TWiSTED]> syntax error in input (unexpected comma)
23:55:55 <Lemmih> What did you write?
23:55:59 <[TWiSTED]> or do you apply read to the 2nd element of the tuple (using snd or something)
23:56:04 <[TWiSTED]> parseFormula s = [(s, rest)]
23:56:04 <[TWiSTED]>                  where
23:56:04 <[TWiSTED]>                      (name, rest) = break (isDigit) s
23:56:04 <[TWiSTED]>                      (read s', rest') = break (not . isDigit) rest
23:57:30 <kaol> don't put that read there. and you still have your whole input in [(s, rest)]
