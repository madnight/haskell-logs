00:00:31 <dblhelix> mmm .... seems quite dated to me
00:01:04 <dblhelix> perhaps his strict function is some kind of predecessor of 'our' seq function
00:01:17 <dblhelix> @type seq
00:01:19 <lambdabot> seq :: forall b a. a -> b -> b
00:01:31 <dblhelix> seq is built-in and cannot be defined in Haskell
00:02:21 <dblhelix> it takes two args, a and b: if a diverges seq a b diverges, otherwise seq a b yields b
00:02:27 * Lemmih frowns at GPGME.
00:02:45 <dblhelix> Lemmih: GPGME?
00:03:24 <vincenz> ooh it's got a bug
00:03:35 <vincenz> I mean an error
00:03:39 <vincenz> :D
00:03:52 <Lemmih> Gnu Privacy Guard Made Easy.
00:04:24 <vincenz> everything made easy is frownable upon
00:04:35 <dblhelix> vincenz: moreover, Wadler mentions that Strict is not a monad ;)
00:04:51 <vincenz> yip
00:04:58 <Lemmih> Some people think that making things easy means cutting out key features.
00:05:00 <vincenz> but the site that explains monads
00:05:04 <vincenz> uses sheep as example
00:05:09 <vincenz> and it's based on the strict monad
00:05:14 <vincenz> (which is a lax monad)
00:05:22 * vincenz looks at the two names and wonders
00:05:34 <dblhelix> vincenz: 'the site that' is a bit ambigious
00:05:44 <dblhelix> vincenz: do you have a url?
00:05:57 <vincenz> ugh
00:06:10 <vincenz> "All about monads"
00:06:29 <vincenz> http://www.nomaware.com/monads/html/
00:07:00 <vincenz> basically the Maybe is an example of Strcit
00:07:02 <vincenz> Strict
00:07:43 <dblhelix> vincenz: I do not quite agree, but I may be wrong
00:07:57 <vincenz> I'm no expert
00:08:11 <dblhelix> vincenz: Maybe captures the optionality monad; it has nothing to do with strictness
00:09:08 <vincenz> seems very similar
00:09:10 <vincenz> take bottom to be Nothing
00:09:41 <vincenz> bottom just like Nothing bubbles through
00:10:33 <dblhelix> vincenz: well, on that level you could say they're similar
00:10:46 <vincenz> semantically they seem equivalent
00:11:00 <dblhelix> vincenz: just like you can say they're similar because they both have monadic structure
00:11:19 <vincenz> nope
00:11:24 <vincenz> they're similar in behaviour
00:11:29 <vincenz> they do exactly the same thing
00:11:58 <dblhelix> yet Strict fails to satisfy the monad laws and Maybe obeys them ;)
00:13:19 <vincenz> dblhelix: I honestly think they're the same... the monad laws presented on taht site, I'm sure that Strict obeys them too
00:13:24 <autrijus> @pl \x -> if null x then undef else castV x
00:13:25 <lambdabot> liftM2 (flip if' undef) null castV
00:13:48 <autrijus> @type if'
00:13:50 <lambdabot> bzzt
00:14:04 <Cale> if' b t e = if b then t else e
00:14:06 <dblhelix> vincenz: then, no offense, I give up :)
00:14:37 <vincenz> none taken :)
00:14:47 <vincenz> I should get ready for work
00:15:12 <vincenz> nothing like reading monad papers with your cofffee
00:15:59 <MachinShin> night all
02:34:06 <dblhelix> vincenz: mmm ... thinking about your last remark, a couple of hours, ago: that's clearly wrong---no way the strictness 'monad' obeys the monad laws
02:34:57 <dblhelix> vincenz: return undefined >>= const (return ()) should equal return () but instead it equals undefined
02:36:07 <skew> dblhelix: I think sometimes we ignore strictness in formulating things
02:36:26 <skew> like free theorems and such, but I don't know if that applies here
02:36:38 <dblhelix> vincenz: the difference with the Maybe monad is that Nothing is itself a Maybe-value, while, for the strictness monad, undefined is a value of the argument type
02:37:08 <skew> It certainly sounds a little dodgey if the whole point of the monad is to mess with strictness
02:37:23 <dblhelix> skew: well, vincenz was explicitly talking about the strictness monad, so I think it's a little dubious to forget about strictness here
02:38:00 <dblhelix> skew: well his point is that Maybe and the strictness monad are essentially the same
02:38:11 <dblhelix> skew: I doubt that
02:38:38 <skew> you doubt what?
02:38:40 <dblhelix> skew: their similarity arises from both having some sort of monadic structure
02:38:56 <skew> oh, that Maybe and strictness are similar?
02:38:58 <dblhelix> shew: that Maybe and strictness are essentially the same thing
02:39:00 <dblhelix> yes :)
02:39:33 <skew> not being able to pattern match on undefined would spoil things, even if they are similar from the inside
02:40:07 <skew> unless vincenz has a solution to the halting problem he isn't sharing
02:40:15 <dblhelix> :)
02:41:10 <skew> finding and harnessing uncomputability in physics would be really cool
02:43:32 <skew> When I start a philosphy paper "Let us assume that the universe is drawn from a computable probability distribution", I'm probably buying into the Church-Turing thesis a bit much
02:44:39 <skew> That's one natural assumption from which the validity of induction is (mathematically) provable, btw.
02:45:20 <dblhelix> but probably a bit to ambitious for a Monday morning
02:45:20 <dblhelix> /s/to/too
02:47:06 <skew> I never did finish my argument for that assumption
02:47:28 <dblhelix> :)
02:47:40 <skew> something about how it's more or less equivalent to assuming that the universe is understandable, and if it isn't we shouldn't bother so much about things like philosophy anyway
02:48:11 <skew> @seen shapr
02:48:12 <lambdabot> I saw shapr leaving #haskell 3 days, 17 hours, 55 minutes and 27
02:48:12 <lambdabot> seconds ago, and I have missed 7 seconds since then.
02:48:35 <skew> hey, he's been back since I've last been here
02:48:41 <skew> I wanted to talk to him about TMR
02:49:28 <dblhelix> he's really going cold turkey on irc, I suppose
02:49:43 <skew> maybe he still gets email
02:52:36 <musasabi> skew: email works fine.
02:53:01 <skew> okay, as long as he hasn't joined some back-to-nature group
02:55:14 <skew> I've written a paper which is mostly useless blather about what type systems are and how you can use them in functional languages, and I'd like to get some advice about making it something possibly interesting/useful
02:55:28 <jaap_mac> where is it?
02:55:55 <skew> I suppose I should have done this while writing the thing, but I was thinking the class was about writing something vaugely resembling a research papser
02:56:30 <jaap_mac> skew: ah, so it's an e11 paper uh... i'd like to have a look at it, still, though
02:59:15 <skew> just a minute, looks like I need to review some config files after upgrading apache
02:59:42 <jaap_mac> skew: know how it feels, take your time
03:01:09 <skew> if you like you could poke around my cs and its accounts for a draft4.pdf, not sure if I ever uploaded one though
03:06:25 <skew> okay, here http://page-148.caltech.edu/~brandon/types.pdf
03:08:39 <bourbaki> moin
03:09:38 <skew> hi
03:25:46 <Lemmih> Hello easy4.
03:26:16 <easy4> hello Lemmih
03:55:55 <fullets> is there some way to write a HUnit test case that will pass iff a function calls error?
04:38:25 <blackdog> anyone know about ghc packages for macos x 10.4? my copies of ghc have stopped working, and a man cannot live on interpreters alone.
04:41:45 <boegel> hi Itkovian
04:42:56 <boegel> nothing beats a beer after a good exam :) *yaay
04:43:17 <bourbaki> congrats
04:43:28 <boegel> thx
04:43:36 <boegel> but 3 more are coming up though
04:43:40 <bourbaki> oh
04:43:47 <Itkovian> hi boegel
04:43:56 <Itkovian> so, what course was it?
04:44:07 <boegel> CG
04:44:26 <boegel> Itkovian: are you at your work tomorrow morning ? I'll come by with my final version of my thesis
04:45:43 <Itkovian> ok, I'm there from about 8.45 a.m.
04:47:16 <fullets> blackdog: ghc appears to be in darwin ports, that might be an avenue worth exploring
04:47:27 <boegel> Itkovian: that's way to early for me, but okay :)
04:49:16 <nlv11757_> will Map.union (Map.empty) somemap take O(1)
04:49:22 <nlv11757_> cause the doc says O(n + m)
04:49:32 <nlv11757_> but i cant image that in the special case of Map.empty
04:49:49 <nlv11757_> ?
04:51:27 <[TWiSTED]> if ive got a function that inputs a string, how can i change it such that it inputs a list of strings and applys that function to each string in the list ?
04:51:55 <Lemmih> [TWiSTED]: Take a look at 'map'.
04:51:55 <[TWiSTED]> map function?
04:51:59 <[TWiSTED]> ye
04:52:16 <Lemmih> @plugs map toUpper "hey"
04:52:21 <lambdabot> "HEY"
04:54:46 <boegel> map (\x -> x+1) [1,2,3]
04:54:53 <boegel> @plugs map (\x -> x+1) [1,2,3]
04:54:55 <lambdabot> [2,3,4]
04:55:09 <boegel> @plugs (\x -> x+1) <<= [1,2,3]
04:55:10 <lambdabot> Variable not in scope: `<<='
04:55:20 <boegel> @plugs (\x -> x+1) =<< [1,2,3]
04:55:22 <lambdabot> <Plugins.Eval>:1:
04:55:22 <lambdabot>   No instance for (Num [b])
04:55:22 <lambdabot>   arising from the literal `3'
04:55:26 <blackdog> fullets: ok, thanks.
04:55:27 <boegel> @plugs (\x -> x+1) >>= [1,2,3]
04:55:30 <lambdabot> Couldn't match `a -> a -> b' against `[t]'
04:55:36 * boegel grrs
04:55:36 <jaap> nlv11757_: if it says O(n+m), and the first map has size 0, and the second has size m, that adds up to O(m), no?
04:55:42 <boegel> @type (>>=)
04:55:48 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
04:55:48 <lambdabot>    (Monad m) =>
04:55:48 <lambdabot>    m a -> (a -> m b) -> m b
04:56:12 <boegel> @plugs [1,2,3] >>= (\x -> x+1)
04:56:14 <lambdabot> <Plugins.Eval>:1:
04:56:14 <lambdabot>   No instance for (Num [b])
04:56:14 <lambdabot>   arising from the literal `1'
04:56:20 <boegel> @plugs [1::Int,2,3] >>= (\x -> x+1)
04:56:21 <lambdabot> Couldn't match `[b]' against `Int'
04:56:27 <boegel> @plugs [1::Int,2,3] =<< (\x -> x+1)
04:56:29 <lambdabot> Couldn't match `a -> m b' against `[t]'
04:56:29 <Lemmih> @plugs (\x -> return (x+1)) =<< [1,2,3]
04:56:31 <lambdabot> [2,3,4]
04:56:35 <Lemmih> I win (:
04:56:40 <boegel> yeah, you do
04:56:42 <boegel> and I suck :(
04:58:14 <nlv11757_> jaap, it doesn't make sense that it would be O(m) thinking about it
04:58:42 <nlv11757_> it seems that when the second argument is the empty map, it returns immediately, but not when it is the first
05:00:12 <nlv11757_> uuh not true, they both react the same
05:00:32 <nlv11757_> sounds stupid to not have union be O(1) for this special case
05:04:04 <musasabi> nlv11757_: you can have it if you want.
05:04:49 <nlv11757_> sure wrap it :D
05:05:03 <musasabi> nlv11757_: myUnion m1 m2 = if null m1 then m2 else (if null m2 then m1 else union m1 m2)
05:05:14 <nlv11757_> but i cant image the authors didnt implement the special case
05:05:35 <nlv11757_> in a similar way to make it O(1)
05:05:36 <musasabi> nlv11757_: I wouldn't like to pay for that wrapper when doing unions.
05:05:51 <nlv11757_> pay?
05:06:09 <musasabi> nlv11757_: that incurs an extra cost (two checks for null) for every union operation.
05:06:30 <nlv11757_> is doing a case really that costly ?
05:07:14 <musasabi> may be, may not be.
05:08:37 <boegel> wow, the wiki book "Blender: Noob to Pro" is really nice
05:10:53 <bourbaki> boegel: whats the url?
05:12:57 <boegel> http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro
05:13:10 <boegel> I'm going to enjoy this
05:13:23 <boegel> btw, blender works _really_ fast, it's just great! :)
05:13:34 <boegel> way better than maya and 3Ds max if you ask me
05:13:44 <nlv11757_> looks like quite an investment of time before one could do something nice
05:13:57 <boegel> nlv11757_: yeah, but it's great fun
05:14:09 <boegel> I've always wanted to throw myself at this kinda thing
05:14:15 <boegel> and blender seems to make it really easy
05:14:35 <boegel> although it just crashed on me (segmentation fault :s)
05:15:03 <foxy> how do I specify the exception predicate to catchJust, I only want to catch exceptions of type isDoesNotExistError ?
05:15:21 <foxy> @type Control.Exception.catchJust
05:15:23 <lambdabot> Control.Exception.catchJust :: forall a b.
05:15:23 <lambdabot>            (GHC.IOBase.Exception -> Maybe b) -> IO a -> (b -> IO a) -
05:15:23 <lambdabot> > IO a
05:17:43 <Lemmih> Catch it and throw it again if it's not the wanted exception.
05:18:04 * boegel just fell in love with blender
05:21:15 <luqui> hi.  what does Just do?
05:22:22 <Lemmih> foxy: Sorry, misread your question.
05:22:42 * boegel just found out the book isn't finished at all :(
05:23:11 <Lemmih> luqui: 'Just' is a data constructor.
05:24:02 <Lemmih> luqui: 'data Maybe a = Just a | Nothing'
05:24:14 <luqui> okay
05:24:17 <luqui> I think I get it
05:36:52 * boegel leaves to toy with blender
05:40:26 <foxy> @seen dons
05:40:26 <lambdabot> dons is in #haskell. Last spoke 5 hours, 51 minutes and 54 seconds
05:40:26 <lambdabot> ago.
05:40:36 <dons> hey!
05:40:57 <foxy> hi, mingw is about 50% faster compiling than cygwin
05:41:02 <dons> thanks for the yi patch. 
05:41:10 <dons> oh, cool.
05:41:17 <foxy> sure :)
05:41:38 <foxy> I can't reproduce that bug using mingw, I think it's a cygwin bug
05:42:00 <dons> you can't reproduce conal's bug?
05:42:06 <foxy> no!
05:42:17 <dons> oh, that's good.
05:42:26 <dons> then mingw is an option.
05:42:42 <dons> and we've noticed that cygwin is flakey with dynamic loading sometimes anyway
05:42:58 <dons> @seen conal
05:42:59 <lambdabot> I saw conal leaving #haskell 7 hours, 9 minutes and 33 seconds ago.
05:43:14 <dons> i'll pass on the news to conal
05:43:18 <dons> @karma+ foxy
05:43:19 <lambdabot> foxy's karma has been incremented
05:43:37 <foxy> mingw is relatively painless and seems to work faster
05:43:40 <dons> and hs-plugins is working under mingw?
05:43:52 <foxy> yup
05:43:55 <dons> great!
05:44:04 <foxy> oh, I had to patch a wee bit
05:44:13 <foxy> (recording now)
05:44:22 <dons> ok, thanks.
05:44:36 <dons> hey Thehunter, how's code?
05:45:21 <TheHunter> hey dons
05:45:39 <TheHunter> i'm not coding much these days...
05:46:20 <dons> me neither. paper writing atm.
05:46:34 <TheHunter> about hs-plugins?
05:46:36 <dons> my cycle: hack -> write -> hack -> write ...
05:46:41 <dons> yi, for the HW
05:47:10 <dons> so i'm currently in the middle of a 'write'
05:47:21 <dons> looking forward to an extended 'hack'
05:47:42 <TheHunter> yi hacking?
05:48:01 <TheHunter> wow, 43 patches since i last darcs pulled yi.
05:48:19 <dons> there's been a little bit of activity while getting the paper going
05:49:00 <dons> foxy, would you say then that conal should try mingw?
05:49:31 <dons> and that cygwin is a less stable environment?
05:50:24 <TheHunter> i had tried to split Lambdabot.hs into two pieces a couple of weeks ago, but not understanding the networking issues sufficiently, it made lambdabot kind of unstable.
05:51:12 <mflux_> dons, sayy, you don't happen to have any idea when hscurses will nicely build (and register) with ghc 6.4 (&cabal)?-)
05:51:33 <dons> mflux_, hscurses? stefan's library?
05:52:11 <mflux_> oh, propably, I think you were the one who mentioned the library to me
05:52:15 <dons> I can mention it to him tomorrow (our desks are next to each other at uni :)
05:52:37 <dons> it may happen in the next few weeks.
05:53:19 <dons> TheHunter, I haven't noticed any instability?
05:53:33 <mflux_> thanks for doing any kind of pushing to the right direction ;)
05:53:34 <TheHunter> i never sent you the patches...
05:53:49 <dons> oh..
05:53:55 <dons> that's why I haven't seen it.
05:54:49 <dons> mflux_, I'm planning on cabalising a couple of libs, hs-plugins included, so hscurses might get done at the same time -- they all use the yi build system.
05:55:24 <foxy> dons: Yes, I reckon Conal should try mingw, it can be used from within the cygwin environment or standalone and doesn't rely on the cygwin layer
05:56:21 <dons> ok. I'll pass that on as a recommendation.
05:56:51 <foxy> maybe it should be a haskell-users recommendation;)
05:57:03 <foxy> ;)
05:57:11 <dons> yep. that's a good point.
05:57:34 <dons> it's a good test if you can get both hs-plugins and wxHaskell running
05:58:19 <TheHunter> i have no idea how to get a proper quit message.
05:59:04 <dons> "Client Quit" is a bit redundant as a quit msg, isn't it ;)
05:59:45 <TheHunter> the weird thing is, i typed "QUIT :foo" just as the RFC says.
06:00:24 <TheHunter> i think it's a bug in the irc server.
06:13:03 * Lemmih ponders why hs-plugins can't find Distribution.Package anymore.
06:13:36 <dons> hmm.
06:14:00 <Lycan359> What's the difference between where and let?
06:14:28 <dons> where isn't an expression, so no: (x where x = 1) + 2
06:14:45 <dons> however:
06:14:54 <dons> @plugs (let x = 1 in x) + 2
06:14:55 <SamB> @google "where" "haskell report"
06:14:59 <lambdabot> 3
06:15:00 <lambdabot> http://www.haskell.org/onlinereport/
06:16:19 <SamB> where scopes over a pattern binding, apparantly
06:16:32 <TheHunter> anybody managed to install ctk?
06:16:51 <SamB> not really.
06:17:07 <SamB> its better to just steal the modules you need, apparantly.
06:17:12 <SamB> well, a lot easier anyway.
06:17:17 <Lycan359> So would "x + 2 where x = 1" work?
06:17:33 <SamB> Lycan359: no
06:17:47 <SamB> @plugs x + 2 where x = 1
06:17:49 <lambdabot> parse error on input `where'
06:17:55 <TheHunter> i want to compile c2hs...
06:18:15 <Lemmih> dons: How does hs-plugins rebuild dependencies?
06:18:23 <TheHunter> the PCKS variable is "", and i have no idea what it should be.
06:18:39 <Lycan359> Then why does the following function work?
06:18:44 <Lycan359> "sortInts xs = m : (sortInts (removeFst m xs)) where m = minInts xs"
06:18:47 <SamB> TheHunter: oh :-(
06:18:58 <dons> Lemmih, it uses ghc -M to create 'depend' -- a Makefile fragment
06:19:08 <Lemmih> Lycan359: The 'where' is part of the function, not the expression.
06:19:22 <Lycan359> Oh I get it.
06:19:34 <dons> TheHunter, c2hs doesn't need ctk does it?
06:20:42 <TheHunter> when i try to compile c2hs, i get "unknown package: ctk"
06:22:15 * SamB thinks it would be nice if you could allow TH quotations without turning on splicing, and also if you could run them without IO...
06:22:25 <SamB> what do you want c2hs for anyway? I heard it works a lot better to use haskell signatures and have the FFI tool figure out the C type from that
06:24:01 <SamB> @plugs 1#
06:24:03 <lambdabot> Variable not in scope: `#'
06:24:08 <TheHunter> dependency hell. I need c2hs for hsx, and hsx for hs-plugins, and hs-plugins for yi and lambdabot...
06:24:20 <SamB> oh really?
06:24:22 <dons> you need c2hs for hsx?
06:24:36 <dons> not really, i hope.
06:24:54 <SamB> me too
06:24:56 <dons> SamB - no -fglasgow-exts in @plugs.
06:25:09 <SamB> dons: aw.
06:25:39 <musasabi> Is there a polyaddic generalization of arrows?
06:25:41 <Lemmih> hsx only depends on base and haskell98.
06:26:31 <TheHunter> so how do i compile hsx then?
06:26:49 <Lemmih> hsx == haskell-src-exts, right?
06:26:52 <SamB> huh, the hsx Makefile looks like it has a line with 8 spaces instead of a tab!
06:26:53 <TheHunter> yep
06:27:00 <dons> there's a Makefile, it just uses Cabal.
06:27:02 <Lemmih> It's a Cabal package.
06:28:24 <musasabi> Currently my code is monadic, with actions of the form "a -> b -> c -> D ()", and I need a way to handle metainformation for the actions. This seems very hard to do in a monadic context, and thus I started thinking about arrows, but "D (a,b,c) ()" is not a very clean approach :-(
06:30:23 <TheHunter> ok, the confusion arose because the haskell-src-exts darcs repo contains three libraries only one of which is haskell-src-exts.
06:30:40 <TheHunter> so i probably won't need c2hs, yay!
06:30:47 <dons> ah, ok.
06:31:02 <SamB> I don't see 'c2hs'mentioned anywhere, except as part of 'withHsc2hs = Just "/usr/bin/hsc2hs"'.
06:31:04 <dons> I didn't know any of them needed c2hs. -- i have them all installed, but don't have c2hs.
06:31:10 <TheHunter> Lemmih, where does -fhide-all-packages sneak in from?
06:31:31 <musasabi> haskell-src-exts lacks the support for infix type synonyms :-(
06:33:25 <Lemmih> TheHunter: Huh? There's a -hide-all-packages in GHC 6.5 ...
06:33:43 <TheHunter> runhaskell Setup.hs build
06:33:43 <TheHunter> Preprocessing library haskell-src-exts-0.2...
06:33:43 <TheHunter> Building haskell-src-exts-0.2...
06:33:43 <TheHunter> ghc-6.5.20050514: unrecognised flags: -fhide-all-packages
06:33:43 <TheHunter> Usage: For basic information, try the `--help' option.
06:34:07 <Lemmih> Update Cabal.
06:34:25 <TheHunter> isn't cabal included in ghc?
06:35:06 <Lemmih> A broken version is, apparently.
06:35:52 <Lemmih> That flag thing was fixed May 16 by Krasimir in the darcs repo.
06:36:01 <TheHunter> ok, i'll try that, thanks.
06:44:26 <TheHunter> Lemmih, seems to work, thanks.
06:44:40 * Heffalump notices that more ICFP 2005 contest info has appeared
06:44:44 <dcoutts_> I'm wondering if anyone can suggest some advice about a "Happy" parser I'm writing for the C language...
06:45:21 <Heffalump> don't do it ;-)
06:45:39 <dcoutts_> :-) but c2hs is so slow, I'm rewirting the parser
06:45:49 <Lemmih> TheHunter: No problem.
06:45:55 * Heffalump realises he's in no position to be rude, since he's in the middle of embedding Perl in Haskell.
06:46:40 <dcoutts_> As you may know, C has an unpleasent context dependency in its grammar, you have to know which identifiers are type names when doing the later parsing and you only find out which identifiers are the type names by doing the parsing...
06:47:05 <Heffalump> yeah
06:47:06 <skew> this is where you make a monadic parser
06:47:17 <dcoutts_> so we have a monadic parser which maintains a set of identifiers so it can know which ones are typedefs
06:47:31 <skew> keep the list of typedefs names in the monad somehow, and then pass those names to the lexer each time you ask for a token
06:47:47 <dcoutts_> now whenever we get a typedef production we do a monadic action to add that identifeir into the state
06:47:58 <dcoutts_> skew, you're with me :-)
06:47:58 <skew> the lexer consults that list when it has something that is either an identifier or a typedef name
06:48:17 <dcoutts_> so the problem is parsing this peice of code...
06:48:26 <dcoutts_> typedef int foo;
06:48:26 <dcoutts_> foo bar (int baz);
06:48:35 <malcolm> That's usually called a symbol table
06:48:55 <skew> playing with the GLR stuff might be fun if you don't like factorizing you grammar. I'm not sure if it's really all that useful, though
06:49:04 <Heffalump> he's trying to make it faster, not slower ;-)
06:49:32 <Heffalump> I'm not sure I see the specific problem with that piece of code
06:49:43 <dcoutts_> what happens is that by the time the "typedef int foo;" bit gets reduced the parser has already read the following "foo" token and so has read it as a normal identifier rather than a type identifeir
06:49:59 <Heffalump> ahh.
06:50:06 <Heffalump> you don't have deterministic control over the lexer?
06:50:07 <malcolm> I don't advise using a list for the symbol table: better a tree-based finitemap, or better still, a trie.
06:50:13 <dcoutts_> since it only gets recognised as a type identifier after reducing the "typedef int foo;" bit
06:50:25 <Igloo> I've never looked at the C grammar, but is it possible to either do a sloppy parse to work out what are type names first or to do a sloppy parse and then find such errors in a post-processing phase? Similar to how infix operators tend to get sorted out after parsing by Haskell parsers?
06:50:44 <Heffalump> as in you can't force the lexer to stop lexing until the parser actions have caught up at certain points? (e.g. a ';')
06:50:56 <skew> dcoutts_: perhaps your production should be "typdef" type ident, rather than "typedef" type typedefname
06:51:15 <dcoutts_> Heffalump, I think the problem it not the lexer but in the shift/reduce stuff in the parser
06:51:49 <dcoutts_> Igloo, it may be possible but the grammar for typedefs is actually rather complex, you can typedef whole structs and things not just simple names
06:51:58 <Heffalump> shouldn't the parser have reduced at the ';'?
06:52:09 <Lycan359> How do I convert an Int to a Float?
06:52:30 <Lunar^> @type toRational
06:52:32 <dcoutts_> Heffalump, exactly. I believe it should. but it doesn't. And adding a dummy token after the ';' doesn't help.
06:52:36 <lambdabot> toRational :: forall a. (Real a) => a -> Rational
06:53:15 <Igloo> @type realToFrac
06:53:16 <lambdabot> realToFrac :: forall b a. (Fractional b, Real a) => a -> b
06:53:31 <Lunar^> @type fromRational . toRational
06:53:34 <lambdabot> fromRational . toRational :: forall a a1.
06:53:34 <lambdabot>           (Fractional a, Real a1) =>
06:53:34 <lambdabot>           a1 -> a
06:53:38 <Igloo> Oh, in fact fromIntegral is all you need there
06:54:02 <dcoutts_> skew, I was thinking that might be one possability to refactor the grammar to ditinguish the typedefs more easily, but I suspect we'd run into the same issue, you only know you've got to the end of the production when you hit the ';' and happy only seems to want to do the recuction after seeing the token(s) following the ';'
06:54:47 <skew> dcoutts_: I think you can just change your typedef production so instead of expecting a typedef name as the name that you are defining, it expectes the other kind of identifier
06:54:52 <Heffalump> and it's definitely in the reduction of the "typedef" type ident; production that the thing gets added?
06:54:59 <dcoutts_> I thought it was just happy keeping one token of lookahead and so I tried makeing the lexer add a dummy token after each ';' but happy was smater than that and defeated me yet! :-)
06:55:03 <skew> that's what the lexer will make for you because the name isn't in the table yet, right?
06:55:31 <Lycan359> Ok, thanks, fromIntegral works.
06:56:01 <Lycan359> What's fromInt? It's in my book but it doesn't work.
06:56:57 <Lunar^> Lycan359: an old memory
06:57:07 <dcoutts_> Heffalump, yes after reducing each 'external declaration' it adds typedefed things to the monad state, but from running the happy parser in debug mode, it is clear that those reductions happen not when the ';' is encountered but one token later (or two tokens if I add a dummy token)
06:57:43 <skew> oh, it's the second foo that's a problem?
06:57:48 <Heffalump> yes
06:58:07 <dcoutts_> skew, the problem is not in the parsing of the typedef, it is in parsing the following line which expectes a typedef'ed name but the typedef production has not been reduced by that time.
06:58:24 <skew> that's odd, I think it should be reduced by then, unless you're grammar is wierd
06:58:54 <dcoutts_> happy seems to be reducing things one production late, if that makes any sense!
06:59:02 <skew> just one?
06:59:06 <dcoutts_> seems so
06:59:07 <Heffalump> either that or it's asking the lexer for things too early
07:00:02 <Lycan359> An old memory? Is it from Haskell 1.4 or something?
07:00:43 <dcoutts_> Heffalump, happy does keep one token of loo ahead but in that case it ought to have worked when I added the dummy tokens after each ';' but it still did the reduction upon seeing the token following the ';' dummy pair.
07:00:49 <dcoutts_> external_declaration
07:00:49 <dcoutts_>   : function_definition			{ CFDefExt $1 }
07:00:49 <dcoutts_>   | declaration				{% mapM_ addTypedef (getTDefNames $1)
07:00:49 <dcoutts_>                                         >> return (CDeclExt $1) }
07:01:20 <Heffalump> what productions did you put the dummy tokens into?
07:01:30 <Heffalump> and what characters caused the dummy tokens to be generated?
07:02:06 <skew> could "typedef int foo ;" possibly be parsed as anything but a complete declaration?
07:02:20 <dcoutts_> I mad the lexer output a dummy token after every ';' token and added dummy terminals aftyer each ';' in the grammar
07:02:30 <dcoutts_> here's the reductions:
07:02:31 <dcoutts_> state: 40,      token: 43,      action: reduce (rule 100), goto state 15
07:02:31 <dcoutts_> state: 15,      token: 43,      action: reduce (rule 98), goto state 64
07:02:31 <dcoutts_> state: 64,      token: 43,      action: reduce (rule 46), goto state 62
07:02:31 <dcoutts_> state: 62,      token: 43,      action: reduce (rule 48), goto state 63
07:02:31 <dcoutts_> state: 63,      token: 43,      action: shift, enter state 70
07:02:32 <dcoutts_> state: 70,      token: 89,      action: shift, enter state 193
07:02:34 <dcoutts_> state: 193,     token: 86,      action: reduce (rule 35), goto state 5
07:02:37 <dcoutts_> state: 5,       token: 86,      action: reduce (rule 5)addTypedef: Ident "foo" (-1) 1832934 (Attrs ("",2,13) 1)
07:02:39 <dcoutts_> , goto state 43
07:02:44 <dcoutts_> now, 43 = ';'
07:02:58 <Igloo> Adding dummy terminals like that won't help as they're still part of the rule you want to be reduced, surely?
07:03:01 <skew> adding tokens like that shouldn't change anything
07:03:04 <Igloo> You need the dummys to be a statement of their own
07:03:07 <dcoutts_> token 43 that is, 89 is the dummy token and 86 is an ordinary rather than typedef ident
07:03:30 <Heffalump> dcoutts_: that won't help
07:03:36 <blackdog> i found out about the game 'sudoku' this afternoon. my first reaction was to write a program to solve it, so i can never ever enjoy it manually again. does this make me twisted?
07:03:38 <dcoutts_> skew, no, it doesn't change the grammar but it should defeat the cached token of lookahead no?
07:03:44 <Heffalump> cos the dummy token will be holding up the reduction of the typedef..
07:03:50 <Heffalump> blackdog: that was exactly my reaction.
07:04:01 <blackdog> thank christ. i'm not alone.
07:04:06 <Heffalump> I thought first "what a pointless waste of time when you could just write a program to do it"
07:04:06 <dcoutts_> so I assume that the token of lookahead is not the problem
07:04:32 <Heffalump> dcoutts_: it doesn't help because if the dummy token is at the end of the typedef production, it'll only be able to reduce after the dummy token..
07:04:54 <malcolm> sudoku is supposedly a lot harder to compute than it looks at first glance
07:05:01 <dcoutts_> but why can't it reduce as soon as it sees the ';' / dummy token pair?
07:05:17 <dcoutts_> why does it have to see something following it?
07:05:19 <Heffalump> malcolm: someone at work said he wrote a reasonable solver for it without too much trouble
07:05:22 <blackdog> malcolm: i don't think so.
07:05:23 <ndm> blackdog: http://www-users.cs.york.ac.uk/~shackell/sudoku/Sudoku.html
07:05:26 <skew> dcoutts_: for whatever reason it can't reduce when it just has the ';' as lookahead
07:05:30 <ndm> an online solver
07:05:33 <Heffalump> dcoutts_: well, that doesn't change the behaviour from just having the ';'
07:05:38 <skew> is the ';' part of the typedef production?
07:05:40 <blackdog> i've got one running now that's doing it exhaustively
07:05:47 <Heffalump> if it's doing a single token look ahead, then it'll always be one token ahead of whatever it could really reduce
07:05:53 <dcoutts_> skew, yes but I don't understand why
07:05:54 <skew> if it is, then the ';' must be shifted onto the stack before it can reduce that typedef production
07:06:12 <skew> which means that it needs to get the next token of lookahead, because that's just what it does
07:06:23 <skew> lift the ';' out and see if that helps
07:06:32 <ndm> i also have one written (by someone else) in Eclipse, thats 15 lines of code and highly efficient
07:06:35 <Heffalump> or make the dummy token part of a higher production
07:06:42 <dcoutts_> skew, how do you mean? lift out?
07:06:47 <Heffalump> so have
07:07:03 <Heffalump> fake_decl -> "typedef" type ident;
07:07:09 <Heffalump> real_decl -> fake_decl dummy_token
07:07:17 <Heffalump> then make sure the action is on the fake_decl production
07:07:20 <skew> or fake_decl -> "typdef" type ident
07:07:28 <skew> real_decl -> fake_decl ';'
07:07:33 <Heffalump> skew: I think that would cause conflicts
07:07:50 <skew> how so?
07:07:51 <dcoutts_> ';' are part of the end of several declaration / statement type productions, you're suggesting I lift them up to the level of "list of decls" prduction or someting?
07:07:53 <Heffalump> cos it's only after the ; that you know the typedef has finished
07:08:12 <Heffalump> dcoutts_: I'm suggesting that, as a quick test, you use your dummy token in a different production.
07:08:20 <Heffalump> i.e. introduce a new layer of productions.
07:08:29 <Heffalump> What you're currently doing can't defeat single-token lookahead.
07:08:30 <skew> yeah, but if it's written like that then you should decide to reduce while the ';' is still lookahead
07:08:35 <blackdog> ndm: efficient how? it's just backtracking search, presumably...
07:08:43 <ndm> nope
07:08:51 <Heffalump> skew: you would, but introducing ambiguities would suck..
07:09:10 <Igloo> blackdog: You'll be able to get a lot faster by having it use similar logic to that humans use
07:09:11 <ndm> its using arc consistency, so like 0.2 seconds in the worse case time for the eclipse
07:09:28 <dcoutts_> hmm, ok I'll see if I can move the ';' upwards in the grammar and get the semantic rule that adds the typedef idents to the monad state to be below that
07:09:30 <Heffalump> my co-worker said that the key was to always take the most constrained choice
07:09:37 <ndm> the C version never goes about 0.005, and that includes writing out the result
07:09:42 <Heffalump> so look at all the decisions you could make, and make the one with the least choices
07:09:58 <Heffalump> dcoutts_: I'm deeply suspicious of that idea, I strongly suggest you try moving your dummy token up first
07:10:09 <Heffalump> and do it by introducing a new level of productions, just to test
07:10:50 <blackdog> that's a point.  I've been going from a blank page because i'm too lazy to write out proper test cases for idle code, which probably skews it a bit.
07:11:49 <ndm> if you go to the online solver, you can download the source, and that includes lots of examples to try it on
07:12:18 <Lemmih> @seen bringert
07:12:19 <lambdabot> I saw bringert leaving #haskell 4 days, 21 hours, 18 minutes and 8
07:12:19 <lambdabot> seconds ago, and I have missed 7 seconds since then.
07:12:34 * Igloo wonders how many valid squares there are
07:13:04 <Igloo> I suspect too many, though
07:13:11 <Heffalump> easily far too many
07:13:13 <skew> there shouldn't be that many
07:13:30 <skew> oh, wait 9 permutations
07:13:35 <Heffalump> some fraction of 9! x 9!
07:13:43 <Heffalump> no, 9! ^ 9
07:13:49 <dcoutts_> ok, currently all the declaration productions end in ';' so I'll move the ';' to after each use of the declaration non-terminal in other productions...
07:13:51 <Igloo> No, it's not that bad
07:14:07 <Igloo> @plugs product [ product [1..n] | n <- [1..8] ]
07:14:09 <lambdabot> 5056584744960000
07:14:11 <Heffalump> dcoutts_: I still think that will go badly wrong with ambiguities.
07:14:37 <skew> I don't think it will be that ambigous
07:14:41 <skew> try it and see
07:14:47 <Igloo> Less than about 2^52, then
07:16:31 <dcoutts_> Heffalump, skew, no that change is not ambiguous
07:16:49 <Heffalump> fair enough.
07:17:10 <Heffalump> I guess that means the lookahead is really being used.
07:20:41 <dcoutts_> hah ha! it seems to work now!
07:20:53 <dcoutts_> Heffalump, skew thank's a bunch :-)
07:21:51 <dcoutts_> so I moved the ';' terminal up and moved the reduction rule down below it
07:22:10 <Heffalump> cool
07:22:30 <dcoutts_> both changes seem necessary (I tried both) which does make sense
07:22:40 <Heffalump> right
07:23:22 <dcoutts_> so hopefully that'll mean c2hs will be much quicker and gtk2hs will be able to be built on machines with merely 256Mb ram rather than more like 400Mb
07:23:49 <dcoutts_> actually this parser takes about 28Mb heap where as the old one took 250Mb
07:24:09 <shelarcy> foxy: Is Windows 98 has OS environment variable?
07:24:18 <Heffalump> oh, wow
07:24:26 <skew> How was the old parser written?
07:24:41 <dcoutts_> using a combinator library from the CTK
07:24:47 <dcoutts_> not parsec
07:26:51 <shelarcy> I think your patch's OS syslibdir depend on Windows 9X.
07:28:34 <MarcWeber> Are there some little example applications written in haskell to learn from?
07:30:17 <Lemmih> @wiki HaskellDemo
07:30:17 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
07:31:41 <Lemmih> @wiki ImperativeHaskell
07:31:42 <lambdabot> http://www.haskell.org/hawiki/ImperativeHaskell
07:37:28 * boegel does a little dance
07:39:01 <dcoutts_> boegel, how'd the exams go?
07:39:04 <CosmicRay> metaperl: did you see my comments on http://sequence.complete.org/node/64?
07:46:44 <Igloo> Is it just me or are the attributions on sequence.complete.org written in invisible ink?
07:47:57 <skew> good old grey254
07:48:05 <boegel> dcoutts_: pretty good, but there are 3 more coming up
07:54:13 <dcoutts_> boegel, well good luck
08:00:54 * Philippa just did a scary bit of thinking while talking to Shae over ICQ...
08:01:27 <basti_> scary thinking?
08:01:30 * Heffalump looks worried
08:01:39 <Oejet> Philippa: You want to scare the rest of us too?
08:02:30 <Philippa> yeah. Haskell's type system has closed-world sums (algebraic datatypes) to which you can add a signiature of methods via typeclasses
08:02:44 <basti_> :-o
08:02:46 <Philippa> suppose you go the other way round? Open-world products are pretty much classes
08:03:18 <Philippa> and the equivalent thing to do with typeclasses is to sling on a form of pattern-matching to a type (er, I forget the exact mathematical reasoning for it, this may be mildly flawed)
08:03:34 <Philippa> taken to an extreme, that's classes with typecase
08:04:20 <Philippa> a wee bit close of a link with a certain flavour of OO language, no?
08:04:38 <Heffalump> not sure I see the point..
08:05:07 <Philippa> Heffalump: there isn't much of one, insofar as you can't really do anything clever with it
08:05:26 <Heffalump> fair enough
08:05:47 * Heffalump gets back to his own brand of evilness
08:06:03 <basti_> lol
08:07:15 <xerox> Philippa, do you know of any online reference helping understanding what you said about {Open,Closed}-worlds? :-)
08:07:35 <Heffalump> open and closed world just refers to whether you know all the elements of something at a given poin
08:07:47 <Heffalump> e.g. you always know all the constructors of a data type, so that's a closed world
08:07:52 <Philippa> if you've got subtyping, records can be open world
08:07:58 <Heffalump> but you don't always know all the instances of a type class, so that's open world
08:08:11 <Philippa> you don't /care/ about additional fields, but they're still different values
08:08:37 <Philippa> (whereas open world algebraic datatypes screw all your pattern-matching up, you can never know you've written a total function)
08:09:00 <Heffalump> course you can, you just always have a default case
08:09:29 <Philippa> point. It's not necessarily overly sane for a given purpose though
08:09:53 * xerox prays for an url about ADT :-)
08:10:01 <Philippa> xerox: the datatypes Haskell uses
08:10:35 * boegel just created his first blender-scene and is proud of it :)
08:10:46 <Philippa> boegel: cool
08:10:56 <Lor> ML has open adts: exceptions.
08:11:19 <boegel> Philippa: it's a real simple scene, but hey :)
08:11:21 <Philippa> yeah. Very much for the one special use though
08:11:46 <Lor> Yes. Personally, I'm rather fond of ocaml's polymorphic variants.
08:12:25 <yoda-> I have a question, to break strings into smaller strings at user defined points for example "Fas2Lew24La" -> "Fas2","Lew24","La" | How would i go about that?
08:12:28 <Philippa> okay, okay, point granted :-)
08:13:17 * Lemmih thinks [TWiSTED] and yoda- are attending the same class.
08:14:43 <Lemmih> yoda-: You want to break on 'L' or after the number sequence?
08:16:28 <yoda-> whenever there is a capital
08:16:45 <yoda-> after the number sequence is probably better though
08:19:25 <Lemmih> yoda-: You can ask [TWiSTED]. He did just that some time ago.
08:20:56 <yoda-> [TWiSTED], are you busy?
08:20:58 <yoda-> :)
08:22:27 <Lemmih> Anyhow, the functions you want are: 'break', 'span' and 'isDigit'.
08:22:43 <xerox> @index break
08:22:45 <lambdabot> Data.List, Prelude
08:22:49 <xerox> @type Data.List.break
08:22:53 <lambdabot> Data.List.break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
08:22:54 <xerox> @type Data.List.span
08:22:56 <lambdabot> Data.List.span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
08:23:02 <xerox> @index isDigit
08:23:03 <lambdabot> Data.Char
08:23:07 <yoda-> ah righto, thnx
08:23:07 <xerox> @type Data.Char.isDigit
08:23:09 <lambdabot> Data.Char.isDigit :: Char -> Bool
08:23:13 <TheHunter> @type groupBy
08:23:15 <lambdabot> bzzt
08:23:20 <TheHunter> @type Data.List.groupBy
08:23:21 <lambdabot> Data.List.groupBy :: forall a. (a -> a -> Bool) -> [a] -> [[a]]
08:23:40 <yoda-> would u be able to show me an example of groupBy
08:23:46 <xerox> I like to write groupBy's argument functions :-)
08:24:11 <TheHunter> @plugs (const $ (> 3)) [1,2,4,2,6,2,5,5,4]
08:24:13 <lambdabot> <Plugins.Eval>:1:
08:24:13 <lambdabot>   No instance for (Show (a -> Bool))
08:24:13 <lambdabot>   arising from use of `show'
08:24:17 <TheHunter> @plugs groupBy (const $ (> 3)) [1,2,4,2,6,2,5,5,4]
08:24:19 <lambdabot> [[1],[2,4],[2,6],[2,5,5,4]]
08:24:20 <xerox> eheh.
08:25:44 <xerox> @plugs groupBy (\x _ -> x > 3) [1,2,4,2,6,2,5,5,4]
08:25:45 <lambdabot> [[1],[2],[4,2,6,2,5,5,4]]
08:25:52 <xerox> Hmm.
08:26:10 <xerox> @plugs groupBy (\_ x -> x > 3) [1,2,4,2,6,2,5,5,4]
08:26:12 <lambdabot> [[1],[2,4],[2,6],[2,5,5,4]]
08:26:17 <xerox> Hmpf.
08:26:32 <TheHunter> ime, you usually want groupBy (const $ ...)
08:27:22 <TheHunter> yoda-, got it?
08:27:30 <yoda-> I think so
08:27:37 <yoda-> thnx very much for your help guys
08:28:17 <TheHunter> groupBy f [...,x,y,...] <= breaks at the ',' if f x y is False.
08:29:09 <TheHunter> hmm, i think |groupBy (const $ not . ...)| is even more common.
08:31:37 * Lemmih wonders how TheHunter would solve it with groupBy.
08:36:12 <xerox> Please do not paste the solution :-)
08:38:53 <TheHunter> yoda-, using groupBy you can implemente your "before capital" but not the "after number" policy.
08:39:26 <TheHunter> @libsrc Data.List
08:39:27 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
08:39:31 <yoda-> still trying to figure out the syntax of the function, i aint very good at this :(
08:40:03 <TheHunter> groupBy tries to generalize group:
08:40:13 <TheHunter> @plugs group "11112233334445"
08:40:15 <lambdabot> ["1111","22","3333","444","5"]
08:40:24 <yoda-> how do i pass the character into a function to do a test on it?
08:40:33 <TheHunter> so group = groupBy (==).
08:41:00 <yoda-> i am trying to do bad things that i know wont work but i dont know any better :\
08:41:16 <goron> I don't have Graphics.UI.GLUT (should it be in GHC 6.4) (if you compiled in support for it).
08:41:45 <shelarcy> dons: I send new patch for hs-plugins, because I found syslibdir definition depend on Windows 9X.
08:41:47 <Lemmih> goron: Does 'ghc-pkg' list the GLUT package?
08:41:57 <yoda-> groupBy (\_ x -> x -> isUpper x) "HeLlo"
08:42:12 <yoda-> i know its wrong
08:42:22 <TheHunter> @plugs groupBy (\_ x -> isUpper x) "HeLlo"
08:42:24 <lambdabot> ["H","eL","l","o"]
08:42:40 <yoda-> ah right
08:42:40 <Itkovian> @type groupBy
08:42:46 <lambdabot> bzzt
08:42:47 <goron> Lemmih: no it doesn't.
08:43:53 <goron> Lemmih: I do have OpenGL-2.0
08:44:43 <Lemmih> Try running ./configure again and check if it can detect your GLUT installation.
08:45:58 <xerox> @libsrc Data.Char
08:45:59 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Char.hs
08:46:25 <goron> Lemmih: I don't have GLUT installed (at least I didn't explictly installed it). I build from ports.
08:46:49 <goron> Lemmih: So your advice is to install GLUT first and then build it from ports again?
08:47:23 <Lemmih> ports == BSD build system?
08:48:26 <goron> Lemmih: yes
08:49:42 <yoda-> is there anywhere i can find a better description of function syntax (examples, etc)?
08:50:09 <Lemmih> goron: Yes, install GLUT and try again.
08:51:11 <derelm> argh, i am looking for a simple way to convert a integer to its binary representation (as a string, better as list of booleans). i have a rather ugly version using a bunch of functions but i wonder if it can be done really simple using scan and lambda functions
08:52:30 * basti_ ponders
08:52:36 <goron> Lemmih: Do I need libglut of freeglut? Does the first work better?
08:52:41 <goron> of->or
08:53:57 <basti_> map (0/=) $ map ((17::Int) .&.) (map (2^) [0..31])
08:53:59 <basti_> ups
08:54:09 <basti_> @plugs map (0/=) $ map ((17::Int) .&.) (map (2^) [0..31])
08:54:11 <lambdabot> [True,False,False,False,True,False,False,False,False,False,False,
08:54:11 <lambdabot> False,False,False,False,False,False,False,False,False,False,False,
08:54:11 <lambdabot> False,False,False,False,False,False,False,False,False,False]
08:54:21 <basti_> derelm: how about that?
08:54:47 <xerox> @plugs List.groupBy (\x y -> isAlpha y /= isDigit x) "Fas2Lew24La"
08:54:48 <lambdabot> ["Fas","2","Lew","24","La"]
08:54:54 <xerox> But it's wrong...
08:54:55 <Lemmih> goron: Not sure. But I have freeglut installed myself.
08:55:14 <TheHunter> @docs Data.Bits
08:55:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Bits.html
08:55:31 <derelm> basti_: is that supposed to be 17 in binary? well it's wrong isn't it?
08:55:39 <basti_> derelm: just the wrong way round
08:55:58 <goron> Lemmih: I installed the nvidia binary drivers. They have an implementation of OpenGL too (but I don't suppose development headers (which you need for HOpenGL)). /me is pretty n00b in graphics.
08:56:28 <basti_> one could do the shift trick too
08:56:32 <tromp> you can use "bit" instead of (2^)
08:57:08 <basti_> you'd need to use tuples for to use that with scan i think
08:57:33 <derelm> well, scan was just an idea ... but map seems to work quite well :)
08:57:36 <goron> Lemmih: Notice: freeglut is now a GLUT replacement.
08:57:47 <goron> Lemmih: I will try freeglut too.
08:59:28 <Lemmih> @plugs take 5 (map (testBit (7::Int)) [1..])
08:59:33 <goron> What is a fo=>dvi converter utility that I can use?
08:59:47 <lambdabot> [True,True,False,False,False]
08:59:53 <yoda-> gah :( cant figure this out :\
09:00:51 <yoda-> "He2Li4Uup66" needs to be split to go to "He2","Li4","Uup66"
09:01:14 <TheHunter> yoda-, you were almost there
09:01:33 <TheHunter> @plugs groupBy (\_ x -> isUpper x) "He2Li4Uup66"
09:01:33 <yoda-> is it ok to go
09:01:35 <lambdabot> ["H","e","2L","i","4U","u","p","6","6"]
09:01:46 <xerox> Am I wrong assuming that in |groupBy (\x y -> ...) "foobar"| at the first call, x = 'f', y = 'o' ?
09:01:52 <TheHunter> this breaks exactly at the places you don't want it to break.
09:02:02 <yoda-> lol yer i know :\
09:02:23 <TheHunter> @type not
09:02:29 <yoda-> lol
09:02:30 <lambdabot> not :: Bool -> Bool
09:02:33 <xerox> D'oh
09:02:42 <xerox> There were uppercase letters.
09:03:03 <xerox> @plugs groupBy (const $ not . isUpper) "He2Li4Uup66"
09:03:10 <lambdabot> ["He2","Li4","Uup66"]
09:03:17 <xerox> Silly me.
09:03:36 <yoda-> but this isnt fair, i cant use it if i dont understand it
09:03:38 <yoda-> :(
09:03:51 <xerox> TheHunter, anyway, was I wrong in my answer?
09:04:09 <TheHunter> xerox, this is what i was thinking of
09:04:19 <[TWiSTED]> yoda.. cs123 assignment?
09:04:23 <yoda-> hehe
09:04:31 <yoda-> shh dont tell ne one
09:04:35 <yoda-> ;)
09:05:09 <nlv11757_> asif we didnt notice that [TWiSTED] was asking his complete assignment last time ;)
09:05:15 <TheHunter> yoda-, groupBy f [a,b,c,d]. This tests f a b. If it's False, it breaks, otherwise it doesn't break and computes f a c.
09:05:51 <[TWiSTED]> hahah
09:05:53 <nlv11757_> note that only consecutive elements that evaluate to true will be grouped
09:06:39 <xerox> Look at this:
09:06:57 <xerox> @plugs groupBy (\x y -> x < (y-3)) [1..21]
09:07:01 <lambdabot> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[
09:07:01 <lambdabot> 16],[17],[18],[19],[20],[21]]
09:07:03 <xerox> Wrong
09:07:09 <xerox> @plugs groupBy (\x y -> x > (y-3)) [1..21] -- sorry
09:07:10 <lambdabot> parse error (possibly incorrect indentation)
09:07:14 <xerox> ...
09:07:19 <xerox> @plugs groupBy (\x y -> x > (y-3)) [1..21]
09:07:21 <lambdabot> [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]]
09:07:38 <TheHunter> in |groupBy (\_ x -> not (isUpper x))|, we break before every character x for which |isUpper x| evaluates to True.
09:08:31 <xerox> Why does this not work?
09:08:37 <nlv11757_> xerox, that proves me wrong?
09:08:52 <xerox> @plugs groupBy (\x y -> isDigit x && isAlpha y) "Fas2Lew24La"
09:08:53 <lambdabot> ["F","a","s","2Lew","2","4La"]
09:09:09 <xerox> nlv11757_, No, I can't understand how groupBy works, getting that output.
09:09:44 <TheHunter> it partially applies the test for each block it is checking.
09:10:21 <TheHunter> This is ok for equality, since it is transitive, but pretty much useless for anything else, well expcept if you forget about the first argument of the test.
09:10:48 <xerox> What does it mean it partially applies the test ?
09:11:03 <nlv11757_> i agree that most of the times, you want to use groupBy with some equality predicate
09:11:04 <TheHunter> @libsrc Data.List
09:11:05 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
09:11:33 <nlv11757_> @plugs groupBy (==) [1,1,2,2,1,3,3,4,3]
09:11:35 <lambdabot> [[1,1],[2,2],[1],[3,3],[4],[3]]
09:11:48 <nlv11757_> @plugs groupBy (==) . sort $ [1,1,2,2,1,3,3,4,3]
09:11:50 <lambdabot> [[1,1,1],[2,2],[3,3,3],[4]]
09:11:56 <TheHunter> groupBy eq (x:xs)	=  (x:ys) : groupBy eq zs
09:11:57 <TheHunter>                            where (ys,zs) = span (eq x) xs
09:12:39 <TheHunter> nlv11757_, i tend to use groupBy (const ...) more often
09:12:57 <xerox> span?
09:13:26 <TheHunter> @plugs span (>0) [0,0,0,1,0,1,0]
09:13:27 <lambdabot> ([],[0,0,0,1,0,1,0])
09:13:32 <TheHunter> @plugs span (<=0) [0,0,0,1,0,1,0]
09:13:33 <lambdabot> ([0,0,0],[1,0,1,0])
09:13:52 <TheHunter> @plugs break (>0) [0,0,0,1,0,1,0]
09:13:53 <lambdabot> ([0,0,0],[1,0,1,0])
09:14:07 <xerox> Being a little OT, do you know of some service of "internet blackboard" where two people can write/draw and show eachother the result?
09:15:03 <[TWiSTED]> @plugs groupBy (\_ x -> not (isUpper x)) "He2Li4Uup66NaCl"
09:15:06 <lambdabot> ["He2","Li4","Uup66","Na","Cl"]
09:15:45 * TheHunter finally got that this has something to do with chemical elements...
09:15:54 <[TWiSTED]> haha
09:16:08 <[TWiSTED]> @plugs break (isDigit) "He2Li4Uup66NaCl"
09:16:10 <lambdabot> ("He","2Li4Uup66NaCl")
09:17:26 <[TWiSTED]> @plugs break (isUpper) "He2Li4Uup66NaCl"
09:17:28 <lambdabot> ("","He2Li4Uup66NaCl")
09:18:16 <boegel> seams wrong ?
09:18:22 <boegel> 'H' is upper, right ?
09:18:53 <[TWiSTED]> it breaks it at the first occurance of a capital
09:20:15 <yoda-> yer i couldnt get that to work either
09:20:34 <yoda-> i think u need to do it recursivly, and rip off the bit that you have already processed
09:21:20 <boegel> @plugs break (isLower) "He2Li4"
09:21:21 <lambdabot> ("H","e2Li4")
09:32:47 * boegel dances around Lemmih 
09:33:45 * Lemmih dances with boegel
09:34:03 <Lemmih> Got some pretty Blender graphics for me?
09:35:05 <boegel> Lemmih: not really, I'm really nooby
09:35:39 <boegel> all I have is this for now: http://studwww.ugent.be/~kehoste/toys.png
09:37:45 <boegel> I'd like to try and make a simple JackJack looking character
09:37:55 <boegel> but I'm guessing that won't be easy for a noob like me
09:38:00 <Lemmih> JackJack?
09:38:16 <boegel> seen the movie The Incredibles ?
09:38:42 <boegel> http://studwww.ugent.be/~kehoste/toys2.png
09:39:25 <boegel> http://bachi.bitacoras.com/imagenes/jack.jpg
09:39:31 <boegel> that's JackJack
09:39:58 <Lemmih> Ah. Looks kinda complicated.
09:40:38 <boegel> yeah
09:40:51 <boegel> but I have a pluche here with me, I think I'll go for that one
09:41:04 <boegel> I've never really finished a scene yet, so this might be my first one :)
09:50:24 <goron> Anyone using FreeBSD with GHC6.4 present?
09:51:12 <goron> Never mind :D
10:09:30 <nlv11757_> using groupBy with const o_0
10:09:41 <nlv11757_> not the first thing i would about
10:10:48 <nlv11757_> i'll ask him tomorrow, for now, im off to home
10:10:49 <nlv11757_> cu
10:17:20 * Lemmih summons SyntaxNinja.
10:58:48 <mauke> @pl \x -> d (d n) == 4
10:58:50 <lambdabot> const (d (d n) == 4)
10:58:57 <mauke> @pl \x -> d (d x) == 4
10:58:58 <lambdabot> (4 ==) . d . d
11:02:39 <musasabi> How would I define fibonacci (fib n = if n <= 1 then 1 else fib (n-1) + fib (n-2)) if "fib" would be an arrow?
11:07:00 <musasabi> fib = proc n -> do if n <= 1 then pure (const 1) -< () else (proc () -> do { v1 <- fib -< n-1; v2 <- fib -< n-2; returnA -< v1+v2}) -< ()
11:07:08 <musasabi> is not very pretty...
11:27:49 <xerox> arrfib = arr fib
11:27:50 <xerox> :-)
11:30:30 <ski> @arr fib
11:30:31 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
11:31:38 <xerox> @type Control.Arrow.arr
11:31:44 <lambdabot> Control.Arrow.arr :: forall (a :: * -> * -> *) c b.
11:31:44 <lambdabot>        (Control.Arrow.Arrow a) =>
11:31:44 <lambdabot>        (b -> c) -> a b c
11:35:07 <musasabi> Of course, but that does not help when trying to understand how to use the arrow notation for different problems...
11:42:54 <wagle> @pl \s -> [c | c <-s , c `elem` "abc"]
11:42:55 <lambdabot> (: [c `elem` "abc"]) . ((c | c) <-)
11:43:24 <wagle> o_O
11:43:57 <wagle> is lambdabot confused?
11:44:08 <basti__> hmm
11:44:16 <basti__> @pl [(x,x) | x<-a]
11:44:17 <lambdabot> [(x, x) | x <- a]
11:44:21 <Lemmih> Hey SyntaxNinja (:
11:44:43 <Lemmih> SyntaxNinja: I got Cabal patches for you.
11:44:44 <vincenz> Woo
11:44:48 <wagle> i think it doesnt comprehend list comprehensions
11:44:59 * vincenz does a dance
11:45:07 <vincenz> hmm
11:45:07 <vincenz> where is shapr?
11:45:10 <vincenz> @seen shapr
11:45:11 <lambdabot> I saw shapr leaving #haskell 4 days, 2 hours, 52 minutes and 26
11:45:11 <lambdabot> seconds ago, and I have missed 7 seconds since then.
11:45:12 <basti__> missing.
11:45:18 <vincenz> been missing a lot lately
11:45:24 <basti__> he's working at FLM
11:45:45 * vincenz got a new laptop
11:45:45 <vincenz> :D
11:45:56 <vincenz> time for dinner
11:46:00 <vincenz> blbl
11:51:58 <SyntaxNinja> Lemmih: send 'em along
11:54:09 * boegel continues dancing with Lemmih 
11:55:43 * Lemmih barely managed to mail the patches before going off to dance with boegel.
11:59:51 * boegel would like to see Lemmih join a wet t-shirt competition
12:00:09 <Lemmih> hahaha
12:00:24 <boegel> would you ? :D
12:05:03 <boegel> hi dcoutts
12:05:16 <boegel> weren't you going to write an article for TMRx ?
12:06:35 <boegel> @seen shapr
12:06:36 <lambdabot> I saw shapr leaving #haskell 4 days, 3 hours, 13 minutes and 51
12:06:36 <lambdabot> seconds ago, and I have missed 7 seconds since then.
12:08:11 <dcoutts> boegel, yes and I still plan on doing so but too much other work at the moment to make it for the current deadline
12:08:33 <boegel> which one ?
12:08:50 <dcoutts> which deadline?
12:09:01 <boegel> yeah
12:09:15 <boegel> y0 Biker
12:09:31 <dcoutts> I was going to get an articlt into the June TMR but I'll have to delay it
12:09:59 <Biker> boegel: Hi
12:10:21 <boegel> dcoutts: which deadline are you facing ?
12:10:32 <boegel> Biker: new here ? haven't seen you around (I think)
12:10:51 <Biker> boegel: yeah...
12:11:03 <boegel> Biker: if you have any questions at all, feel free to ask
12:11:08 <boegel> we'll be glad to help
12:11:24 * boegel is feeling helpfull today
12:11:27 <dcoutts> boegel, my supervisor wants me to get a paper done, possibly for the Haskell workshop but that's looking increasingly unrealistic
12:11:40 <Biker> boegel: thanks... I will ask :) Just listening in for now...
12:11:54 <boegel> dcoutts: I see, we'll that's more important than TMR :) that can wait
12:12:04 <dcoutts> :-)
12:12:18 <boegel> Biker: a lot of bull going on in here too, nevermind that ;)
12:12:29 <boegel> Biker: new to Haskell too ? wondering what you can do with it ?
12:12:54 <Biker> boegel: np. I am not really new to Haskell... have been using it for a few years now...
12:13:01 <boegel> oh, I see
12:13:01 <SyntaxNinja> hm. which libs do I need to link with to get symbols from Storage.o
12:13:04 <SyntaxNinja> and PrimOps.o?
12:13:19 <Biker> boegel: learn something new every day though.
12:14:17 <boegel> Biker: ever heard about monads ? I've been discovering them in the last few days
12:14:32 <Lemmih> SyntaxNinja: From the RTS?
12:14:53 <Biker> boegel: yep.
12:15:08 <SyntaxNinja> Lemmih: yeah, if I link with HSrts, I get those symbols undefined
12:15:13 <boegel> oh, okay, you're a experienced user then... ever heard about lambdabot ?
12:15:16 <boegel> she's cool
12:15:25 <SyntaxNinja> boegel: lambdabot is a girl?
12:15:34 <boegel> SyntaxNinja: yeah, sure, why not ? :)
12:15:44 <Biker> boegel: I have seen it working here... not used it myself though
12:15:57 <boegel> so it's not your first time ,
12:16:00 <Biker> yeah... she could be :)
12:16:07 <boegel> you lied to me ! kick him ! :p
12:16:30 <Biker> I said I was new here... not that it is my first time :p
12:16:54 <boegel> okay okay, you can stay :p
12:17:11 <Biker> I promise to keep very quiet :)
12:17:14 <boegel> but be a good boy, okay ? and cut off your hair :)
12:17:22 <Lemmih> SyntaxNinja: Sounds bad.
12:17:22 <boegel> no, don't keep quiet
12:17:24 <boegel> just be good
12:17:36 <Biker> ok...
12:18:08 * boegel invites Biker for a dance
12:18:43 <Biker> I don't dance :-)
12:18:46 * boegel would like to press he's _not_ gay
12:18:59 <boegel> you should (virtually anyway)
12:19:29 <boegel> say Biker, seen my ray tracer ?
12:19:41 <Biker> nope...
12:20:00 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website
12:20:05 <boegel> feel free to comment on it
12:20:14 <Biker> ok
12:20:14 * boegel is bored and thus is spamming his website
12:20:55 <boegel> Biker: you're from the US?
12:21:01 <boegel> @whois Biker
12:21:02 <lambdabot> Unknown command, try @listcommands.
12:21:04 <boegel> woops
12:21:19 <Biker> good job... I saw you counter :-)
12:21:53 <boegel> what time is it over there now ? I'm always in doubt if you guys are 6 hours ahead or behind us
12:22:28 * boegel rushes off for a bit
12:23:21 <Biker> we're behind... the site looks pretty neat. I'll check out your presentation later - have some stuff I need to work on now. Thanks for posting it in English :-)
12:23:32 <boegel> no problemo
12:23:41 <boegel> I could post my last presentation too actually
12:23:49 <boegel> maybe I'll translate it this week
12:23:59 <boegel> my code is coming up there Wednesday or so
12:24:16 <Biker> nice... that would be great!
12:24:23 <boegel> so if you're interested, be sure to check it out
12:24:40 <Biker> I will. talk to you later..
12:24:45 <boegel> bye
12:25:47 <SyntaxNinja> does anyone know how to do the link step properly when you have a C main which calls  hs_init?
12:26:13 <Lemmih> Can't you let GHC do the linking?
12:26:17 <xerox> SyntaxNinja, there is an ld(1) option to specify the entry point, I think.
12:26:31 <xerox> I mean, I know there is, I don't recall what it is :-)
12:26:43 <SyntaxNinja> xerox: I'm not worried about the entry point (should I be?) it's a matter of linking w/ the right libraries
12:27:00 <xerox> Oh, sorry, I misread.
12:27:09 <SyntaxNinja> Lemmih: supposedly, but I'm not sure which is harder: getting this make system to use ghc to link, or getting the make system to link properly
12:27:33 <SyntaxNinja> xerox: no need to apologize BECAUSE WHAT GOES AROUND COMES AROUND!!!!11
12:28:06 <xerox> oneoneone.
12:29:14 <Lemmih> SyntaxNinja: Use 'ghc -v' to see what it links with.
12:30:57 <SyntaxNinja> OK I got GHC to do the linking... wasn't too bad. thanks
12:30:59 * SyntaxNinja lunch
12:31:44 <bourbaki> moin
12:32:32 <xerox> hiya
12:56:15 <SamB> what is with the mismatched quotes in the topic?
12:56:18 <SamB> @help topic
12:56:19 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-
12:56:19 <lambdabot> init
12:56:28 <SamB> @topic-tell #haskell
12:56:31 <lambdabot> http://meme.b9.com/cview.html?channel=haskell&date=today","http://
12:56:31 <lambdabot> www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/
12:56:31 <lambdabot> start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine",
12:56:31 <lambdabot> ICFP Contest! http://icfpc.plt-scheme.org/
12:56:53 <SamB> @help topic-cons
12:56:54 <lambdabot> Various commands for adjusting the channel topic
12:57:09 <SamB> @topic-cons foo #haskell
12:57:10 <lambdabot> I do not know the channel foo
12:57:16 <SamB> @topic-cons #haskell foo
12:57:17 <lambdabot> topic does not parse
12:57:56 <ski> don't you have to use a string ?
12:59:22 <ibid> there are no list brackets, and there are strange quoting there
12:59:32 <ibid> in the topic
12:59:37 <ibid> perhaps it means that?
13:00:22 <xerox> @help topic-snoc
13:00:23 <lambdabot> Various commands for adjusting the channel topic
13:01:01 <Igloo> I like the LiveCD idea
13:01:29 <jlouis> Igloo: I dislike it
13:01:33 <SamB> someone needs to improve the help on that thing. I don't know who did the last hack on that module, I got it to at least send error messages to the channel the command is given on ;-)
13:01:35 <Igloo> Why?
13:02:29 <SamB> which really makes it easier to get those "I do not know the channel foo" messages
13:02:42 <jlouis> Igloo: It almost certain means more work
13:02:57 <Igloo> You're no worse off than you were before
13:03:07 <Igloo> But now you can check for problems in the real environment
13:07:39 <musasabi> The topic commands of lambdabot are not very nice. Having @ta, @ti, @td, and @topic would be simpler ;)
13:08:51 <SamB> musasabi: be my guest
13:09:35 <Igloo> Perhaps you should be able to alias commands for yourself with MyLambdaBot?  :-)
13:11:17 <jlouis> @aliasmap topic-snoc ts
13:11:19 <lambdabot> Unknown command, try @listcommands.
13:11:21 <jlouis> or something like that?
13:11:37 <jlouis> would be drop-dead simple to do, but quite confusing also
13:13:59 <musasabi> SamB: I am quite hesitant to create a patch which just changes the interface to appeal more to me personally.
13:14:29 <SamB> musasabi: you will probably also fix stuff. just go ahead
13:14:50 <SamB> as long as you add help messages, your efforts will have not positive value
13:19:10 <jlouis> have not positive value?
13:21:25 <SamB> er, net.
13:22:11 * SyntaxNinja edited the topic by hand
13:22:16 <SyntaxNinja> but I think I matedh all the qutes
13:22:58 <SamB> wagle is the first suspect...
14:20:24 <lispy> @vixen can i have your number?
14:20:25 <lambdabot> you sure can
14:20:31 <lispy> sweet.
14:20:37 <lispy> @version
14:20:38 <lambdabot> lambdabot 3p2, GHC 6.4 (OpenBSD i386)
14:20:38 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:20:38 <jlouis> haha
14:33:00 <yain> anyone participating in icfp contest?
14:34:28 <lispy> i hope to, but i'll have just moved to CA that weekend
14:34:37 <lispy> so i can't commit to a team or anything
14:35:23 <yain> you that one cannot participate remotely?
14:35:34 <lispy> i entered last year and just ended up writing a graphical simulator instead of spending any time on the actual ant design :)
14:35:46 <lispy> eh?
14:37:33 <lispy> oh, i think i see what you mean.  I don't know if i'll have internet access
14:37:41 <lispy> plus things will be crazy
14:39:32 <jlouis> I do not have time those days, unfortunately. I would love to play around with some code
14:39:43 <yain> I'd like to take part in thatbut I'm unable to find any information about formal parts. Like registration etc.
14:39:55 <yain> or it's just to early?
14:40:38 <lispy> yain: just too early
14:40:47 <lispy> plus the contest is very open in past years
14:40:56 <SamB> @pl \x -> fmap mkPad . sequence $ x
14:40:57 <lambdabot> fmap mkPad . sequence
14:41:11 * boegel leaves for bed
14:41:12 <boegel> bye everyone
14:41:27 <SamB> @pl (\x -> fmap mkPad . sequence $ x) []
14:41:28 <lambdabot> fmap mkPad (sequence [])
14:42:30 <yain> lispy: ok, I see.
14:47:34 <yain> blah.
14:47:44 * yain just read last year task.
14:47:55 <yain> sounds like indeed team is desireable
14:48:14 <yain> *desirable
14:50:12 <lispy> yain: here are some screen shots from my simulator last year: http://www.codersbase.com/Icfp2004
14:50:28 <lispy> i always meant to make it nicer and clean up the code but i never did
14:51:13 <yain> did you worked solo?
14:51:21 <lispy> no
14:51:27 <lispy> i had one teammate ;)
14:51:40 <lispy> we were on opposites sides of the globe so we didn't work together much
14:51:44 <lispy> i don't even remember his name
14:52:04 <lispy> i wrote a simulator and he wrote a compiler
14:52:26 <yain> well, i guess it's pretty distinct duty spearation.
14:52:43 <yain> but considering that first place team had 10 members...
14:52:48 <lispy> yeah, and i couldn't really understand the language he came up with...
14:52:59 <dbremner> lispy - Lazy Lisp seems to resemble Philip Greenspun's idea for a modern lisp.
14:53:06 <yain> "John Dethridge" heh
14:53:31 <lispy> dbremner: yeah, i never made it very far with that idea :)
14:53:50 <lispy> after i get used to haskell i stopped wanted a lazy lisp so much...
14:53:57 <lispy> i can't type...
14:54:21 <lispy> after i GOT...stopped wantING...
14:54:23 <dbremner> lispy - I've tried to learn CL several times but kept losing interest.
14:55:15 <lispy> some of the nice things about lisp are the macros and object system.  But macros are just as evil as they are nic.
14:57:51 <dbremner> lispy - at the time, my primary interest was good SNMP bindings.
14:58:13 <lispy> ah, that's a very focused goal :)
14:58:27 <lispy> what did you end up using?
14:58:33 <dbremner> lispy - I work in MSS.
14:59:00 <dbremner> lispy - the current system is Perl, I may move to Python at some point.
14:59:32 <lispy> yeah, i never could like perl.  I've tried, and it's just not the right language for me
14:59:44 <shapr> Hi, I'm back again to try to recruit for last minute TMR articles. Anyone up for one?
14:59:57 <lispy> TMR?
14:59:57 <shapr> One more article and I'll have five, which is the minimum I would prefer to have.
15:00:00 <shapr> The Monad.Reader
15:00:02 <dbremner> lispy - I'm not too thrilled with it either, but it had the best SNMP bindings when I checked.
15:00:04 <yain> perl is ugly, but i try not to blame it.
15:00:12 <yain> it have very good reasons to be what it is.
15:01:14 <lispy> dbremner: seems like you could probably write some bindings for haskell if you could find the time
15:01:19 <shapr> tmoertel: You wouldn't happen to have a near-finished TMR article in the works, would you?
15:01:44 <dbremner> lispy - I probably could. It's on the list.
15:01:46 <tmoertel> shapr: unfortunately, no
15:01:50 <shapr> Ah, too bad.
15:01:54 <lispy> dbremner: heh, i know how that goes :)
15:02:28 <shapr> I'm torn between publishing with four and waiting till next month...
15:02:40 <lispy> i really, relaly need to put the projects on my site into darcs repos
15:03:55 <yain> heh. interesting.
15:04:19 <shapr> kolmodin: Want to write something about Haste for TMR?
15:04:26 <yain> looks like somone very close to ocaml took judez prize
15:04:27 <shapr> Lunar^: want to write about HFuse for TMR? :-)
15:04:36 <yain> and wiinners are clearly people from topcoder.
15:04:45 <shapr> judez?
15:04:56 <yain> err, judge's
15:05:09 <shapr> Which competition?
15:05:19 <yain> last year's icfp
15:05:21 <shapr> Lor: Want to write something for TMR?
15:05:40 <lispy> shapr: what sort of articles are you looking for?
15:05:50 <shapr> Pretty much anything Haskell related.
15:06:08 <shapr> There's a long list of article ideas too.
15:07:22 <shapr> yain: You mean team Dunkosmiloolump?
15:08:45 <shapr> "Team Dunkosmiloolump consisted of: Duncan Coutts, Andres Lh (kosmikus), Ian Lynagh (Igloo), Ganesh Sittampalam (Heffalump)"
15:08:52 <shapr> All of who are on this channel.
15:09:02 <shapr> lispy: Why, you have something in mind?
15:09:07 <shapr> lispy: tell me, tell me!
15:09:10 * shapr boings
15:09:19 <lispy> heh, no just wondering if I will want to read TMR
15:09:30 <lispy> if it's way over my head it will just confuse me
15:10:02 <shapr> If I had my druthers, each issue would include both hard and easy subjects.
15:10:02 <lispy> i'm still a haskell nook
15:10:02 <lispy> er noob
15:10:29 <shapr> Oleg says he may put part III of the Zipper as Tree of Subcontinuations into the next issue, that'll be fun.
15:10:31 * lispy goes looking for shapr's druthers
15:10:52 <shapr> Have you read the last two issues?
15:10:57 <lispy> no
15:11:01 <lispy> this is the first time i've heard of it
15:11:02 <shapr> Well what are you waiting for!
15:11:06 <lispy> hehe
15:11:09 <shapr> http://www.haskell.org/hawiki/TheMonadReader
15:12:08 <Lunar^> shapr: I won't, sorry
15:12:10 <yain> shapr: hm, i don't understand their concept of divisions.
15:12:30 <Lunar^> shapr: exam coming, student project to finish, and I'm sick with an alergy
15:12:39 <shapr> Lunar^: quel dommage :-) I already asked you last time too, so I already knew.
15:12:39 <lispy> gtk2Hs? hmm....
15:13:09 <Lunar^> shapr: maybe next issue
15:13:30 <shapr> Oh, that would be choueet!
15:13:38 <Lunar^> shapr: I would prefer GHC 6.4.1 out first, anyway
15:13:46 <shapr> Hm, I wonder if chouette and schweet mix well.
15:14:00 <shapr> schoueet?
15:15:15 <shapr> ibid: Want to write about formal specifications and functional programming for next issue?
15:16:16 <shapr> metaperl: hey, want to hack some of your nifty blog entries into a TMR article?
15:17:01 <shapr> Lunar^: Do you think getting -smp working with hOp will require major changes?
15:17:42 <Lunar^> shapr: I don't know anything about SMP
15:17:57 <Lunar^> shapr: I think the changes would be more intrusive in the RTS
15:18:07 <lispy> what does gtk look like on MacOS?  Does it look like a native app?  Do you need X11 to run gtk programs?
15:18:18 <Lunar^> shapr: because AFAIK, SMP support in GHC relies on pthreads
15:18:25 <shapr> Oh
15:19:26 <shapr> That will be exciting then.
15:20:29 <dcoutts> lispy, sadly yes at the moment gtk uses the X server but some of the Gtk hackers are working on a more native port
15:21:14 <dcoutts> so it'd be more like the windows port which uses the windows native GDI APIs
15:23:22 <foxy> shelarcy: in response to your question 8 hours ago, no, Windows 98 does not have an OS environment variable set natively.
15:23:59 <shapr> Is gtk planning to cairo as the lowest drawing layer?
15:24:04 <lispy> dcoutts: stupid mac
15:24:19 <lispy> dcoutts: and they're proprietary api
15:24:50 <shapr> Speaking of which, I'm thinking about buying a Powerbook and putting Linux on it.
15:25:07 <dcoutts> shapr, yes the development version of gtk is now heavily using cairo and it is expected that apps will directly use the cairo api
15:25:19 <lispy> shapr: linux on a powerbook loses some features, like suspend to ram
15:25:37 <shapr> It also gains a lot of free software :-)
15:26:12 <dcoutts> they can still mix that with the existing gdk api but for all the cool new pretty things apps will use cairo with it's X11/Render/OpenGL backends
15:26:43 <dcoutts> we intend gtk2hs to work with cairo and it's Haskell binding hscairo before the gtk2hs 1.0 release
15:26:56 <shapr> I'm actually not that picky about licensing, I just want to be able to modify and redistribute the source of anything I'm running. No vendor can know ahead of time what I need, not even I know that.
15:27:24 <dcoutts> hscario looks like quite an elegant drawing interface
15:27:28 <shapr> Cool, I look forward to that.
15:27:30 <lispy> i find that having a laptop that cannot suspend to ram is silly
15:27:33 <shapr> I've played with hscairo a bit.
15:27:47 <lispy> might as well buy a mac mini and just pack it around with you
15:27:58 <monochrom> haha
15:29:22 <shapr> I really would do something like that if there were a decent laptop-style power supply for a mac mini.
15:29:46 <lispy> no kidding
15:29:47 <shapr> I'd just strap the whole 'desktop' part onto the bottom of my kinesis keyboard.
15:29:58 <lispy> i think the power brick is the same size as the mini ;)
15:30:09 <shapr> And buy some of those nifty (expensive) eyeglasses displays.
15:30:14 <shapr> power brick?
15:30:21 <shapr> Oh,
15:30:21 <lispy> then get a small flat panel to throw in your backpack ;)
15:30:22 <shapr> the wall wart
15:30:30 <lispy> yeah, the wall wart
15:30:33 <shapr> hiya SyntaxNinja!
15:30:37 <lispy> it's more of a brick really ;)
15:30:58 <lispy> well, i should probably go into school
15:31:17 <shapr> Desktop box manufacturers are really missing sales by not having 'laptoppish' options.
15:31:56 <SyntaxNinja> hi shapr
15:32:07 <SyntaxNinja> what are acceptable types for "foreign export" calls?
15:32:31 <lispy> shapr: hehe, yeah what is that like, 8 sales?  me you and a couple other random people?
15:32:46 <shapr> Nah, buncha people would do that if they had the option.
15:32:52 <shapr> This is a case of a great need people just haven't noticed yet.
15:33:24 <shapr> Laptop keyboards suck with great vacuum.
15:33:39 <shapr> I mean, we're talking the black hole after a neutron star...
15:33:47 <lispy> i just wish my os would let me have sessions instead of logging in.  And then let me move sessions around and suspend/resume them
15:33:55 <shapr> No one with any wrist pain would use a laptop keyboard again.
15:34:01 <shapr> lispy: write it!
15:34:15 <monochrom> Solaris has sessions.
15:34:16 <dbremner> lispy - have you used screen?
15:34:37 <lispy> dbremner: am using it now in about 4 places
15:34:54 <shapr> So, we need the X flavor, monitor!
15:35:06 <monochrom> Solaris sessions are on X.
15:35:15 <shapr> Nift
15:35:16 <shapr> y
15:35:20 <lispy> i don't like solaris sessions tho
15:35:22 * shapr is tired
15:35:30 <lispy> i've tried to use them at least on solaris 8
15:35:43 <lispy> they felt dirty
15:36:06 <monochrom> You could insert a smartcard to get in, remove smartcard to get out, your session is just on suspend not destroyed.
15:36:23 <shapr> That would be cool.
15:36:31 <lispy> i want the whole state of my working environment to be capturable and reproducable.  So that I can suspend my session, turn off the machine, go to a new computer and resume the session
15:36:47 <dbremner> lispy - Jef Raskin's Canon Cat did that.
15:36:48 <lispy> hmm..yeah that would be cool
15:36:48 <shapr> lispy: You need to read about subcontinuations!
15:36:49 <monochrom> Of course you can resume your session on any other workstation.
15:37:02 <shapr> Jef Raskin had some amazing ideas.
15:37:05 <shapr> I met him last year.
15:37:09 <lispy> Canon cat?
15:37:21 <shapr> I was sad to hear of his death.
15:37:29 <lispy> monochrom: and usb sticks are getting cheap, and i could use one of those instead of a smart card
15:37:38 <arjanoosting> SyntaxNinja: hi, I have updated my haxml packages last friday, they now have manpages and are lintian and linda clean.
15:37:47 <shapr> Yeah, but USB sticks are a poor substitute for carrying around a real computer.
15:37:53 <dbremner> lispy - http://www.jagshouse.com/swyft.html
15:38:04 <monochrom> the smartcard doesn't remember the session.  the server does.  the smartcard is for authentication only.
15:38:06 <lispy> ah, but you put your session on the usb stick, and go to a new computer
15:38:11 <lispy> this is getting to be a cool idea
15:38:16 <monochrom> our student cards are all smartcards.
15:39:09 <monochrom> but of course, if Sun replaces Microsoft and rules the world, what's the difference between storing on server and storing on flash memory? :)
15:39:17 <lispy> dbremner: thanks, looks like the cat link is broken tho :(
15:39:35 <lispy> i want to take my session home sometimes
15:39:38 <lispy> and use it there
15:39:50 <lispy> or start it at home and use it at school
15:40:01 <monochrom> your home will have a Sun workstation connected by a Sun network to the Sun server at school.
15:40:13 <monochrom> (remember we're assuming Sun rules the world?)
15:40:18 <lispy> hehe
15:40:26 <lispy> anyway, gotta run
15:40:40 <shapr> I'd like to carry around my interface. I want a laptop with high-rez, ergo keyboard, and very little disk or cpu. Then I can run all my apps serverside.
15:41:17 <arjanoosting> SyntaxNinja: I think they are ready to be included into the Debian archive, so if you are willing to look at the packages when you have time that would be nice
15:42:20 <Heffalump> oh, I should set up a mini-dinstall archive
15:43:33 <kolmodin> shapr: the development of haste is frozen at the moment
15:43:56 <yain> hm this ant stuff sounds like a fun thing to do.
15:43:57 <shapr> Yes, but publicity might mean that more people would use it :-)
15:44:16 <kolmodin> true, true :)
15:44:42 <shapr> You could write a summary of features, include some screenshots, and maybe describe how it worked as a student development project.
15:45:13 <kolmodin> we are still missing some vital basic features that none of us has implemented yet
15:45:15 <shapr> I really want one more article, hopefully by June 2nd
15:45:35 <shapr> You could mention that too :-)
15:46:19 <kolmodin> so, it's quite "dangerous" to use.. you might lose code since it doesn't warn you about unsaved documents on quit, etc... :)
15:46:38 <shapr> Well, if it works...
15:46:58 <kolmodin> sort of.. :)
15:47:00 <SamB> Sun can't be stupid enough to think everyone would use Sun...
15:47:09 <shapr> The few people who have experience writing Haskell apps often have lots of experience. I'd like to hear from someone who's done it for the first time.
15:47:20 <shapr> SamB: I said that about Java.
15:47:34 <SamB> yes, but Java is a programming language.
15:47:52 <SamB> *nixes are more compatible with eachother than programming languages are!
15:51:04 <shapr> SamB: PPrint is part of the base GHC distro, isn't it?
15:51:57 <shapr> Oh, I have an in-progress reply to the HaskellForge thread...
15:52:16 <shapr> But it comes down to one point, haskell.org doesn't have an index.
15:52:34 <shapr> It's really hard to find libs and apps in the Haskell world.
15:52:52 <SamB> shapr: this is *not* your email!
15:53:08 <shapr> Cabal and Hackage will cover that though.
15:53:21 <shapr> Yeah, but after re-reading the draft, I wasn't sure if it was anything worth sending.
15:53:33 <SamB> go ahead
15:54:07 <mugwump> every language seems to reinvent CPAN eventually :)
15:54:18 <edwinb> this is a good thing ;)
15:54:23 <edwinb> I am scarily out of the loop
15:54:25 * edwinb looks up hackage
15:54:46 <shapr> Computers are all about automation. If I have to use google to find new code for my language of choice, summat's wrong.
15:55:02 <edwinb> google is usually where I start...
15:55:15 <shapr> Yeah, but if Perl were your language of choice, you wouldn't have to.
15:55:16 <SamB> well, if it comes up first, great
15:55:26 <edwinb> If perl were my language of choice, I'd have bigger problems...
15:55:42 <shapr> Speaking of which, filetype:hs is a great thing for finding unknown Haskell code.
15:55:49 <SamB> ooh
15:55:59 <SamB> @google pretty filetype:hs
15:56:01 <lambdabot> http://repetae.net/john/recent/src/Doc/Pretty.hs
15:56:10 <SamB> agg!
15:56:11 <shapr> @google filetype:hs suffix
15:56:13 <lambdabot> http://www.cs.bris.ac.uk/~pclark/j/code/haskell/myhomework/answers1.
15:56:13 <lambdabot> hs
15:56:14 <SamB> I have that one already.
15:56:24 <shapr> @google filetype:hs okasaki
15:56:26 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/
15:56:26 <lambdabot> Data/Tree.hs?rev=1.9
15:56:29 <shapr> @google filetype:lhs okasaki
15:56:31 <lambdabot> http://www.eecs.harvard.edu/~ccshan/prepose/prepose.lhs
15:56:40 <SamB> @google pretty filetype:lhs
15:56:42 <lambdabot> http://repetae.net/john/repos/DrIFT/src/Pretty.lhs
15:56:59 <shapr> @google filetype:lhs snmp
15:57:00 <lambdabot> No result found.
15:57:05 <shapr> @google filetype:hs snmp
15:57:06 <lambdabot> No result found.
15:57:06 <SamB> that one looks more interesting
15:57:07 <MachinShin> hey +
15:57:16 <shapr> hiya MachinShin
15:57:49 <SamB> but looks can be decieving
15:58:09 <shapr> g'day dporter
15:58:21 * shapr throws pretty lambdas
15:58:34 <dporter> hi there
15:58:44 <shapr> How's code in the far south?
15:59:52 <dporter> getting chilly
16:00:05 <shapr> Do you have snow?
16:01:12 <dporter> Not here in Canberra, but we're starting to get some on the nearby hills
16:10:54 <SyntaxNinja> arjanoosting: cool. send it along
16:11:12 <SyntaxNinja> Igloo: aliv3e? you wanted a heads-up for haxml or something?
16:12:42 <arjanoosting> SyntaxNinja: it's at my homepage: http://moonshine.dnsalias.org/debian/unstable
16:40:46 <Igloo> SyntaxNinja: Ta
16:41:13 <Igloo> And to arjanoosting for packaging it too, of course  :-)
16:41:55 <Igloo> I think nhc98 1.18 should be ready to go once I have removed haxml from it and added all the cabal package provides
16:42:57 <dcoutts> Heffalump, skew, thanks again for your help eariler. My C parser is now generating exactly the same output as the original c2hs parser (even down to the source locations and unique names) but it is doing it in 2 seconds rather than 10 seconds and more importantly it's only using 29Mb of heap space rather than 270Mb of heap space. We're bringing c2hs to the masses...
16:42:58 <arjanoosting> Well I hope my packaging is good enough :)
16:43:17 <dcoutts> dons, I'll be sending you the c2hs patches soon :-)
16:43:35 <shapr> dcoutts: Can you steal code from Knit?
16:43:43 <dcoutts> Knit ?
16:44:24 <SamB> it has to do with oskit?
16:44:41 <shapr> Yeah, that one.
16:44:48 <shapr> Hiya conal
16:45:07 <dcoutts> what's oskit? is that something to do with hOp ?
16:45:27 <SamB> dcoutts: it is a kit for making OSes
16:45:45 <shapr> Knit was written for a project vaguely like AspectJ, but for C.
16:47:19 <dcoutts> shapr, I was able to steal code from a yacc grammar for C and then port that to happy and then port the semantic actions from the existing c2hs C parser to the happy C parser
16:48:10 <dcoutts> I also looked at the gcc C grammar and the gcc docs to see about the syntactic extensions that gcc supports
16:48:45 <dcoutts> eg __attribute__ (( ... )) and __extension__ and a few other bits and bobs like empty structs etc
16:52:48 <conal> shapr, hi there
16:53:22 <conal> foxy, you here?
16:53:25 <SyntaxNinja> can something allocated w/ newCString escape from the Haskell runtime?
16:53:36 <foxy> conal, hi
16:53:38 <SyntaxNinja> are you meant to somehow clean it up?
16:54:20 <conal> i got your note and did my best to try the msys route, but with the same results.  i'm wondering if i really understood what your were suggesting.
16:54:33 <Igloo> You're supposed to free it, I think
16:54:45 <Igloo> The docs /should/ say
16:54:47 <foxy> what's happening?
16:54:51 <SyntaxNinja> but it should be OK if I hand it back to the C runtime, right?
16:54:58 <SyntaxNinja> and C can use it
16:55:17 <Igloo> As long as I'm right, yes  :-)
16:55:17 <SyntaxNinja> I mean, the function that returns it is foreign exported
16:55:22 <Igloo> It would be silly if I wasn't, though
16:55:25 <foxy> is eros still crashing?
16:55:30 <conal> foxy, i installed msys, and did a "make clean", "make", and "make install" in hs-plugins.  then "make clean", "make", and "make run" in Eros.
16:55:39 <conal> and yeah, same crash, same place.
16:56:01 <SyntaxNinja> ahh, the new docs do say that it must be explicitly freed
16:56:02 <SyntaxNinja> hmmmmmmmm
16:56:18 <conal> i put c:\msys\1.0\bin first on my path.  then c:\mingw\bin, then cygwin
16:56:34 <conal> foxy, is that what you did?
16:58:13 <foxy> no, I installed msys first, then installed mingw into the /mingw directory of msys, which automagically takes care of paths, I did it without cygwin
16:58:32 <foxy> I don't think setting path in autoexec.bat works, it has to be in a .bashrc file
16:59:29 <foxy> but if you install mingw into msys /mingw you don't have to set PATH manually
17:00:18 * SyntaxNinja gets thrown off again by C's sad attempt at types.
17:00:24 <foxy> is your wxHaskell a binary distribution?
17:00:25 <dcoutts> SyntaxNinja, it might be ok if the C side explicitly frees it with the C free () function, check if the docs say how the string is allocated
17:00:32 <Igloo> SyntaxNinja: "hmmmmmmmm"? That's what you want, surely?
17:00:35 <SyntaxNinja> see... it makes you THINK there is some type safety
17:00:49 <SyntaxNinja> Igloo: ja
17:00:54 <SyntaxNinja> dcoutts: I hope so :)
17:00:55 <conal> foxy, i go through the control panel "system" setting to change env variables.  and i verified in the msys shell that it's finding the msys versions of commands.  do you think it's worth uninstalling mings & msys and starting over?  i'm pretty sure msys understands my mingw setup, since it asked.
17:00:56 <SyntaxNinja> I'll check it out
17:01:03 <conal> foxy, yes binary wxHaskell distrib
17:01:08 <conal> is that another difference?
17:01:10 <dcoutts> I suspect it is allocated with malloc() but the ffi spec probably doesn't guarantee that it's allocated with malloc()
17:01:23 <dcoutts> ie ghc does it that way
17:01:54 <Igloo> It explicitly says some things aren't freeable with C's free, but I forget what
17:01:58 <foxy> conal, yeah, I compiled wxHaskell from scratch from a recent snapshot
17:02:06 <foxy> conal, and wxWidgets
17:02:43 <foxy> conal, what version of windows do you have?
17:02:58 <conal> i have xp, service pack 2.  you?
17:03:09 <foxy> win98 :D
17:03:23 <conal> oh.  another diff.  how about ghc version?
17:03:28 <foxy> 6.4.1
17:03:48 <SyntaxNinja> Igloo: scary. hmm
17:04:01 <conal> ok.  another diff.  i went back to 6.4 so i wouldn't have to compile wxhaskell myself.
17:04:08 <conal> which version of wxwidgets?
17:04:16 <foxy> 2.6.0
17:04:39 <conal> oh -- i thought that version wouldn't work w/ wxhaskell.  any problems?
17:05:05 <foxy> nope, couldn't see any, the program ran fine -- I could change the shape of the disk with the slider
17:05:14 <conal> great.  which c++ compiler did you use?
17:05:19 <foxy> g++
17:06:05 <conal> mingw version?
17:06:21 <foxy> 1.0.10
17:06:37 <conal> thanks.  i meant the mingw version of g++?
17:07:03 <foxy> ah, gcc version 3.4.2 (mingw-special)
17:07:24 <conal> where'd you get it?  with the mingw install?
17:07:52 <foxy> there are extra packages in the current section on the website with updates
17:08:06 <foxy> that you just extract into the directory hierarchy
17:10:11 <conal> ok, so you installed msys bin, mingw bin, and gcc-g++ tar bin?
17:10:58 <foxy> and autoconf automake libtool mingw-runtime mingw-utils w32api binutils
17:11:12 <conal> oh wow -- all of that.  i'm glad i asked.
17:11:17 <foxy> heh
17:12:06 <conal> i'm guessing the important difference is in our wxwidgets or wxhaskell.  so i'll compile up a version for myself.
17:12:18 <conal> did you run into any problems?
17:12:22 <foxy> yeah, it sounds like that's what the problem is
17:12:32 <foxy> yup, I had to edit some files
17:12:38 <conal> oh ?
17:13:38 <foxy> in wxHaskell db.cpp has columnSize and bufferLength, they should be columnLength and bufferSize
17:13:54 <foxy> (from a recent snapshot)
17:14:44 <conal> anything else?
17:14:46 <foxy> also, when running make install I had to edit the makefile part which runs ghc-pkg
17:15:18 <foxy> and remember to have a sane --prefix=C:/... to all the configure scripts
17:17:08 <conal> thanks for the tips.  i'll give it a try.
17:17:34 <foxy> good luck! what a pain eh
17:18:24 <conal> yeah.  thanks a lot for the help!
17:50:16 <wagle> SamB: what did i do?
17:52:37 <dons> conal, foxy: I'm using 2.6.0 of wxWidgets too on linux
17:53:11 <dons> dcoutts: how did you improve the parser performance/space?
17:53:37 <Heffalump> he rewrote it in Happy (it used to use a combinator library)
17:53:54 <dons> yep.
18:07:52 <SamB> wagle: you had been the last one to change the topic
18:08:13 <SamB> do you know who might have unbalanced the quotes and such?
18:17:44 <dons> @ghc
18:17:46 <lambdabot>  The instance types do not agree with the functional dependencies of
18:17:46 <lambdabot> the class
18:17:59 <dons> if only they'd just get along.
18:24:36 <SamB> heh
18:24:38 <SamB> @ghc
18:24:39 <lambdabot>  WARNING: SE CAFs unsupported, forcing UPD instead
18:24:50 <SamB> hmm?
18:25:01 <dons> cool.
18:25:07 <SamB> I don't get it!
18:25:35 <dons> CAF= constant applicative form, UPD is probably 'update'-related
18:25:44 <dons> SE=hmm. not sure.
18:26:00 <SamB> @ghc
18:26:01 <lambdabot>  adjustor creation not supported on this platform
18:26:04 <mauke> second edition!
18:26:15 <yain> @ghc
18:26:16 <lambdabot>  accepting non-standard pattern guards (-fglasgow-exts to suppress
18:26:16 <lambdabot> this message)
18:26:21 <SamB> mauke: and here I was thinking Special Edition
18:26:45 <SamB> @ghc
18:26:46 <lambdabot>  GHC's heap exhausted
18:26:53 <SamB> @ghc
18:26:54 <lambdabot>  Duplicate binding in parallel list comprehension
18:27:10 <yain> @help ghc
18:27:12 <lambdabot> GHC!
18:27:17 <yain> how informative.
18:27:29 <SamB> would be funnier if it came with witty remarks to go with the error messages...
18:27:35 <SamB> @silly
18:27:36 <lambdabot> Unknown command, try @listcommands.
18:27:40 <SamB> @quote
18:27:41 <lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *
18:27:41 <lambdabot> if* happy; freeze, sell and get some sleep!
18:27:51 <dons> oh, like "Duplicate binding in parallel list comprehension -- stupid!"
18:27:56 <dons> ;)
18:28:10 <SamB> more like "<dons> if only they'd just get along."
18:28:43 <reffie> http://segfaulted.com/stuff/nooooo!.jpg
18:28:50 <dons> we might need a version of vixen for that
18:32:32 <lispy> @pl \x -> do { x' <- x; return (foo x') }
18:32:33 <lambdabot> (line 1, column 10):
18:32:33 <lambdabot> unexpected "{"
18:32:33 <lambdabot> expecting variable, "(", operator or end of input
18:33:08 <lispy> @pl (\mm -> do { m <- mm; return (placeIn m) } )
18:33:09 <lambdabot> (line 1, column 12):
18:33:09 <lambdabot> unexpected "{"
18:33:09 <lambdabot> expecting variable, "(", operator or ")"
18:33:14 <lispy> hmm...
18:33:15 <mauke> @pl \x -> x >>= (\x' -> return (foo x'))
18:33:16 <lambdabot> (foo `fmap`)
18:33:34 <lispy> i should be using fmap?
18:35:42 <lispy> hmm..that last version i tried was valid code
18:35:48 <lispy> i wonder why lambdabot won't accept it
18:36:27 <mauke> looks like it doesn't understand do notation
18:37:16 <lispy> i tried to use (placeIn `fmap`) but i get a very odd type error
18:37:20 <yain> what is the connection between "boilerplate" page on m$ site and the one at http://www.cs.vu.nl/boilerplate/?
18:38:19 <lispy> ah, maybe i didn't give it the correct type
18:38:49 <lispy> ah, i would have to define a Functor
18:48:46 <blackdog> rargh. translating haskell to visual basic is not my idea of a morally uplifting time.
18:51:27 <MK-Mike>  hey guys check out my radio http://atomicradio.dyns.cx:8000/
18:51:56 <blackdog> You may need to do a better sales job than that.
18:52:21 <blackdog> autrijus is a tricky fan? Nice.
18:55:03 <wagle> SamB: I cut and pasted everything except a unmatched trailing ]
18:55:32 <SamB> wagle: hmm.
18:55:57 --- topic: set to '["http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by SamB
18:57:20 <SamB> @topic-cons #haskell foo
18:57:21 --- topic: set to '["foo","http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
18:57:34 <SamB> @topic-tail #haskell
18:57:35 --- topic: set to '["http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
18:58:04 <wagle> @topic-snoc baz
18:58:05 <lambdabot> I do not know the channel baz
18:58:11 <blackdog> Shapr is fine? What's wrong with Shapr?
18:58:22 <wagle> @topic-snoc #haskell baz
18:58:23 --- topic: set to '["http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/","baz"]' by lambdabot
18:58:43 <wagle> @topic-liat #haskell
18:58:44 <lambdabot> Unknown command, try @listcommands.
18:58:58 <wagle> @listcommands
18:58:59 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
18:58:59 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
18:58:59 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
18:58:59 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
18:58:59 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
18:58:59 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
18:59:01 <lambdabot> seen source spell state timein todo todo-add topic-cons topic-init
18:59:03 <lambdabot> topic-snoc topic-tail topic-tell type uptime vera version vixen
18:59:05 <SamB> @topic-init
18:59:05 <lambdabot> web1913 wiki wikipedia wn world02 yow
18:59:07 <lambdabot> I do not know the channel
18:59:15 <SamB> @topic-init #haskell
18:59:16 --- topic: set to '["http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
18:59:26 <SamB> @listcommands topic
18:59:27 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-
18:59:27 <lambdabot> init
18:59:33 <SamB> @help topic
18:59:34 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-
18:59:34 <lambdabot> init
18:59:46 <wagle> i wish it WOULD list all the commands
19:00:01 <SamB> wagle: when?
19:00:09 <wagle> nm
19:00:41 <wagle> did you see this:
19:00:52 <wagle> @pl \s -> [c | c <-s , c `elem` "abc"]
19:00:53 <lambdabot> (: [c `elem` "abc"]) . ((c | c) <-)
19:01:08 <mauke> hahaha
19:01:13 <thou_> awesome
19:01:21 <SamB> is that valid?
19:01:26 <wagle> no it isnt
19:01:44 <SamB> I thought that <- looked funny
19:01:58 <wagle> i think it just doesnt comprehend list comprehensions
19:02:07 <SamB> oh, rightr
19:02:28 <SamB> :i:
19:02:29 <mauke> @pl \s -> filter (\c -> c `elem` "abc") s
19:02:30 <lambdabot> filter (`elem` "abc")
19:02:36 <SamB> @type :
19:02:41 <lambdabot> bzzt
19:02:48 <SamB> @type (:)
19:02:49 <lambdabot> (:) :: forall a. a -> [a] -> [a]
19:02:59 <SamB> oh right.
19:03:25 * SamB is surprised he forgot about that...
19:43:11 <lispy> :t (<-)
19:43:17 <lispy> @type (<-)
19:43:18 <lambdabot> bzzt
19:43:23 <lispy> @bzzt
19:43:24 <lambdabot> Unknown command, try @listcommands.
19:43:30 <lispy> @vixen bzzt
19:43:31 <lambdabot> you're turning me on :)
19:43:40 <lispy> @vixen bzzt!
19:43:42 <lambdabot> Yes
19:44:01 <lispy> @type data
19:44:02 <lambdabot> bzzt
19:44:08 <lispy> @type (=)
19:44:09 <lambdabot> bzzt
19:48:32 <yoda-> hoi hoi
19:48:59 <lispy> @type instance
19:49:00 <lambdabot> bzzt
19:49:06 <lispy> @type where
19:49:07 <lambdabot> bzzt
19:49:36 <yoda-> "He2+2Le2" ---> ["He2","2Le2"]
19:49:40 <yoda-> how would i go about that?
19:50:21 <mattasdf> I'm trying to learn some haskell and I'm using hugs, but when I type any expression into the interpreter it just outputs a blank line, then gives me another prompt..?
19:50:31 <thou> yoda: missingh has split / join functions
19:51:13 <lispy> mattasdf: can you give an example
19:51:20 <yoda-> thou, I should be using split / join ?
19:51:30 <mattasdf> "print (1+2)", "myfunc", "putStrLn "test"" would all appear to do nothing
19:51:40 <thou> yoda-: no, it's just one way to do it, or you could look at their source code to see what they did
19:51:45 <lispy> what about just 1+2
19:51:50 <thou> yoda-: missingh is a package of handy functions
19:51:57 <yoda-> ah right
19:51:59 <mattasdf> same, another blank line
19:52:14 <lispy> mattasdf: try ghci instead ;)
19:52:19 <yoda-> where do i get it thou
19:52:23 <lispy> that's weird, never heard of that problem tho...
19:52:33 <thou> @google missingh
19:52:34 <lambdabot> http://quux.org/devel/missingh
19:52:46 <mattasdf> it looks like this right now "Hugs.Base> 1+2\n\nHugs.Base>"
19:52:47 <thou> there you go :-)
19:53:28 <mattasdf> although the newlines look like proper newlines...
19:55:28 <mattasdf> yeah I might as well try ghc, as I figured I'd use it eventually
19:56:45 <thou> yoda-: btw:  http://quux.org/devel/missingh/html/MissingH.List.html#v%3Asplit
20:00:01 <lispy> mattasdf: are you using it from emacs or something?
20:00:07 <lispy> something that could be interfeering
20:02:54 <mattasdf> nope. I just downloaded the latest hugs win32 (which isn't the latest hugs version), installed, and tried to use it with a tutorial. but I immediately had the problem. I tried loading a module I made, resetting the environment, etc... nothing
20:03:56 <lispy> mattasdf: yeah, it's weird.  I hope you can get it working.  Haskell is nice to program in and I've not heard of anyone having the weirdness that you're seeting
20:04:08 <lispy> so yeah, don't give up on it because of this :)
20:06:17 <mattasdf> I definitely want to learn the functional paradigm
20:06:18 <mattasdf> no problems there
20:06:23 <mattasdf> ghc is installing
20:06:50 <lispy> ghc has nicer error messages
20:07:05 <SamB> @ghc
20:07:05 <lispy> so it can be better for n00bs
20:07:06 <lambdabot>  Cycle in class declarations (via superclasses)
20:07:12 <lispy> @ghc
20:07:13 <lambdabot>  Use -fglasgow-exts to allow multi-parameter classes
20:07:27 <SamB> @ghc
20:07:28 <lambdabot>  Can't represent Oxford brackets
20:07:36 <SamB> ???
20:07:56 <lispy> damn, and i really wanted Oxford brackets
20:08:12 <SamB> I don't get it! why would it be *trying* to represent those?
20:09:04 <SamB> @ghc
20:09:04 <lambdabot>  Malformed context in instance header
20:09:14 <SamB> @ghc
20:09:15 <lambdabot>  GHC error in desugarer lookup
20:09:17 <wagle> @topic-tail
20:09:18 <lambdabot> I do not know the channel
20:09:24 <wagle> @topic-tail #haskell
20:09:26 --- topic: set to '["http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
20:09:35 <wagle> @topic-cons #haskell "logs: http://meme.b9.com/cview.html?channel=haskell&date=today"
20:09:36 --- topic: set to '["\"logs: http://meme.b9.com/cview.html?channel=haskell&date=today\"","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
20:09:52 <wagle> @topic-tail #haskell
20:09:54 --- topic: set to '["http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
20:10:07 <wagle> @topic-cons #haskell logs: http://meme.b9.com/cview.html?channel=haskell&date=today
20:10:08 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/"]' by lambdabot
20:10:19 <lispy> wagle: having fun yet?
20:10:20 <wagle> there
20:10:31 <SamB> @ghc
20:10:32 <lambdabot>  You need -fglasgow-exts to derive an instance for this class
20:10:37 <mattasdf> the interpreter isn't as pretty, but ghc is working fine
20:10:45 <SamB> @ghc
20:10:46 <lambdabot>  parse error on input
20:10:50 <wagle> didnt know to not put in the quotes
20:10:53 <SamB> @moo
20:10:54 <lambdabot>       vv    vv
20:10:54 <lambdabot>       ||----||  *
20:10:54 <lambdabot>       ||     | /
20:10:54 <lambdabot>      /\-------/
20:10:54 <lambdabot>     (oo)
20:10:54 <lambdabot>     (~~)
20:10:56 <lambdabot>  
20:10:57 <SamB> @moo
20:10:58 <lambdabot> Australian Cow
20:11:00 <lambdabot>               (__)
20:11:02 <lambdabot>          ____ (oo)
20:11:04 <lambdabot>        /-    --\/
20:11:06 <lambdabot>       / |     ||
20:11:08 <lambdabot>      *  ||___-||
20:11:10 <lambdabot>         ^^    ^^
20:11:12 <lambdabot>  
20:11:14 <lambdabot>      Freshman Cow
20:11:16 <lambdabot> After the "Freshman 15"
20:11:28 <SamB> @moo
20:11:29 <lambdabot>          (__)
20:11:29 <lambdabot>          (OO)
20:11:29 <lambdabot>   /-------\/
20:11:29 <lambdabot>  / |     ||
20:11:29 <lambdabot> *  ||----||
20:11:30 <lambdabot>    ^^    ^^
20:11:32 <lambdabot>  
20:11:34 <lambdabot> Cow who drank Jolt
20:11:52 <SamB> @quote
20:11:53 <lambdabot> shapr says: I encourage my competitors to use Windows.
20:12:00 <SamB> @quote
20:12:01 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
20:12:09 <SamB> @quote
20:12:10 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've
20:12:10 <lambdabot> realized they have to learn it for themselves.
20:12:14 <SamB> @quote
20:12:15 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping
20:12:15 <lambdabot> to remain that way until IA64 goes away :-)
20:12:31 <SamB> has it gone away yet?
20:12:44 <monochrom> No.
20:12:48 <SamB> (how long does it take a CPU to decompose?
20:13:03 <monochrom> It is yet to come.
20:13:04 <wagle> depends on the size
20:13:07 <reffie> @ghc
20:13:08 <lambdabot>  Command stack underflow at command
20:13:16 <monochrom> The more it is postponed, the longer we will suffer!
20:13:28 <lispy> @quote
20:13:29 <lambdabot> lispy says: i just remembered this dream i had the other morning.  I
20:13:29 <lambdabot> was trying to tell my alarm clock how to snooze by using a list
20:13:29 <lambdabot> comprehension
20:13:45 <lispy> hehe, i remember that
20:14:00 <monochrom> That is disturbing.
20:14:31 <SamB> yes, should have used monadic functions or functions from Data.List!
20:14:43 <monochrom> Hahaha
20:14:50 <SamB> LCs are for n00bs!
20:15:10 <SamB> I routinely forget they exist
20:15:30 <wagle> 8-p
20:15:39 <SamB> wagle: what?
20:15:52 <SamB> you like them or something?
20:15:56 <wagle> i needed one for the KAMIL thing
20:16:08 <SamB> KAMIL>
20:16:13 <lispy> list comprehensions rule
20:16:17 <SamB> s/>/?/?
20:16:27 <SamB> @quote
20:16:28 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
20:16:28 <wagle> http://spoj.sphere.pl/problems/KAMIL/
20:16:33 <lispy> so you can take your filter, mapM and shove it ;)
20:18:06 <yoda-> i cant do this :\
20:18:41 <yoda-> i need to write a function to split and remove a character at each instance in a string
20:18:59 <yoda-> so it needs to be recursive
20:19:09 <yoda-> but i just got no idea
20:19:16 <lispy> yoda-: is [TWiSTED] in your class?
20:19:20 <yoda-> yer
20:19:30 <lispy> he had a similar example, and similar question
20:19:39 <yoda-> its the same question
20:19:47 <yoda-> assignment
20:19:50 <lispy> yoda-: you should ask him
20:19:58 <yoda-> dont think hes there
20:20:02 <lispy> i think he figured it out...
20:20:09 <lispy> well, loop at span
20:20:12 <lispy> er look
20:20:18 <lispy> @type span
20:20:20 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
20:20:36 <yoda-> bleh, doesnt that solve it?
20:20:46 <yoda-> and then just tail each result?
20:20:48 <lispy> span (=='+') "hey12+hi2"
20:20:56 <lispy> @plugs span (=='+') "hey12+hi2"
20:21:01 <lispy> i always for get the plugs
20:21:02 <lambdabot> ("","hey12+hi2")
20:21:09 <lispy> hm...
20:21:12 <yoda-> lol
20:21:16 <lispy> that didn't do what i expected...
20:21:29 <yoda-> i think u need
20:21:38 <lispy> @plugs span (/='+') "hey12+hi2"
20:21:39 <lambdabot> ("hey12","+hi2")
20:21:44 <yoda-> yep
20:21:56 <lispy> @plugs break (=='+') "hey12+hi2"
20:21:57 <lambdabot> ("hey12","+hi2")
20:21:59 <yoda-> do i have access to run that script?
20:22:12 <lispy> what script?
20:22:16 <lispy> the @plugs thing?
20:22:18 <yoda-> ye
20:22:25 <lispy> anyone can do that i don't think lambdabot has any security features
20:22:30 <yoda-> ah ok
20:23:02 <lispy> @plugs let (x, y) = break (=='+') "hey12+hi2" in (x, drop 1 y)
20:23:04 <lambdabot> ("hey12","hi2")
20:23:31 <lispy> @plugs let (x, y) = break (=='+') "hey12+hi2+steve3" in (x, drop 1 y)
20:23:32 <lambdabot> ("hey12","hi2+steve3")
20:23:47 <lispy> so as you can see you'll still need to apply break recursively
20:23:53 <yoda-> yep
20:23:58 <yoda-> think there is an easier way
20:24:06 <yoda-> but i get it thnx very much
20:24:10 <lispy> np
20:26:13 <lispy> classes = whenMatch (((to_ (Addr "class-")) % ".*@") `refineBy`
20:26:14 <lispy>                      ((CheckMatch "()") % "[^@]+"))
20:26:15 <lispy>           (placeInUsingMatch (mailBoxFromMatch match))
20:26:26 <lispy> i think that's easier than the corresponding procmail
20:26:46 <lispy> but i should change `refineBy`
20:26:55 <lispy> it's realy just my logical and
20:27:21 <lispy> but i can't use the same function because % changes the type to something .&&. isn't defined on
20:27:23 <lispy> oi
20:55:47 * SamB wonders why [| 1# |] results in a kind error
21:04:27 <lispy> @type [| 1# |]
21:04:28 <lambdabot> bzzt
21:04:42 <lispy> i don't even know what it is trying to represent :)
21:05:02 <SamB> *Main> :t [| 1# |]
21:05:02 <SamB> <interactive>:1:3:
21:05:02 <SamB>     Couldn't match kind `*' against `#'
21:05:02 <SamB>     When matching the kinds of `t :: *' and `GHC.Prim.Int# :: #'
21:05:02 <SamB>       Expected type: t
21:05:02 <SamB>       Inferred type: GHC.Prim.Int#
21:26:08 <svens> foo
21:55:20 <lispy> bar
21:56:06 <Lemmih> Morning, #haskell.
21:59:25 <metaperl> good morning Lemmih
21:59:40 <metaperl> it is 10 o'clock at night here... where do you live?
21:59:52 <Lemmih> Denmark, GMT+1.
22:00:01 <Lemmih> It's 7am here.
22:00:02 <metaperl> oh, same place as Oejet
22:00:03 <metaperl> same city?
22:00:07 <Lemmih> Yep.
22:00:14 <metaperl> are you a student?
22:00:49 <Lemmih> Not yet.
22:01:23 <metaperl> I'm a professional Perl programmer, but I think Perl6 is going to be a poor language. So I am studying Haskell in hopes of getting away from Perl6
22:01:48 <metaperl> C++ looks like what Perl6 wants to be...
22:01:53 <Lemmih> Isn't Perl6 supposed to be some kind of Uber language?
22:02:10 <Khisanth> Lemmih: well yes but that is the problem :)
22:02:18 <metaperl> Well, I see it as a language attempting to integrate functional and oop
22:02:26 <metaperl> C++ has already done that quite well
22:02:38 <metaperl> Alexandrescu's book had my eyes blistering
22:02:40 <Khisanth> hmm how do you do functional with C++?
22:02:46 <metaperl> that is the most amazing book I have ever seen in my life
22:02:49 <metaperl> really
22:03:12 <metaperl> Khisanth: "Modern C++ Design" by Alexandrescu explains it well.
22:03:44 <Khisanth> if it is just OOP and functional programming then that is nothing new, perl5 can do that already
22:04:08 <metaperl> the switch is that perl5 does it with modules and perl6 is trying to create a bunch of language mechanisms for ALL of it
22:04:20 <metaperl> roles, optional variables, hyperoperators, etc etc
22:04:37 * Lemmih would go crazy if he used a language without type inference.
22:04:55 <metaperl> I dont understand how Ruby was designed to replace perl --- everytime I look at ruby I get bored and return to Perl
22:05:05 <metaperl> C++ has type inference enough for you Lemmih?
22:05:23 <metaperl> Strong typing is a very powerful feature.
22:05:45 <mflux_> btw, sometimes I've found it helpful to be able to grep for instances of certain type, but I guess there is no tool to annotate .hs-files with the types?
22:05:49 <Lemmih> Really? Then why all the "int i"s?
22:05:53 <metaperl> I would say that 50% of our problems with our Perl application have to do with Perl's seat-of-the-pants approach to typing
22:06:01 <mflux_> (that is something one loses with type inference)
22:06:09 <metaperl> Lemmih: oh I see
22:06:20 <SamB> mflux_: there is!
22:06:25 <Khisanth> mflux_: you just need better names :)
22:06:32 <SamB> you have the compiler invoke the programmer with warnings!
22:06:36 <Khisanth> s/better/more descriptive/
22:06:39 <mflux_> khisanth, I'm not planning to annotate symbols with their types ;)
22:06:40 <JohnMeacham> C++ has a very primitive and ad hoc type checker IMHO
22:06:53 <JohnMeacham> s/checker/system/
22:07:14 <mflux_> samb, hmm, warnings, for all used types?-o
22:07:15 <Lemmih> metaperl: Wont you miss Haskell features like ADTs and first class functions?
22:07:18 <Khisanth> mflux_: it is a bit ugly ...
22:07:22 <metaperl> I have new respect for C++. Perl6 is breaking backwards compatibility unlike C++
22:07:36 <mflux_> khisanth, it would be basically forgetting type inference, and worse, sometimes lying
22:07:38 <metaperl> Lemmih: miss them under what circumstances?
22:07:51 <SamB> [with the right settings, ]whenever a top-level name is defined without a type signature, the compiler issues a warning.
22:07:53 <mflux_> so it would need explicity type annotations to go with it
22:07:59 <JohnMeacham> It doesn't really have type inference, since you still have to annotate most things with their types.
22:08:13 <metaperl> JohnMeacham: yes, but would you say it is strongly typed?
22:08:14 <SamB> the programmer, being annoyed by all these warnings, then proceeds to put in type signatures for everything.
22:08:36 <mflux_> samb, oh, well maybe I'll try that
22:08:47 <Lemmih> metaperl: AFAIK, C++ doesn't have ADTs nor higher-order functions.
22:09:00 <mflux_> btw, ocaml has this thing -dtypes, which when used with the ocaml's emacs mode allows one to point at an expression and query for its type
22:09:03 <mflux_> it's sometimes handy too
22:09:15 <metaperl> Lemmih: no but they have 6000 jobs on dice.com :)
22:09:20 <JohnMeacham> metaperl: I would say it is statically typed. but also has universal types like 'void *' which weaken the type sytem in some sense.
22:09:23 <metaperl> as opposed to zero for Haskell
22:09:26 <Lemmih> metaperl: ah :D
22:09:39 <SamB> metaperl: well duh
22:09:52 <SamB> nobody would be looking on dice.com for a haskell job anyways!
22:10:07 <SamB> do people even *look* for those yet?
22:10:09 <mflux_> metaperl, what you need to do is to get in with the pretences of mastering c++, and then converting everyone on the place to use haskell!
22:10:27 <metaperl> lol @ mflux_
22:10:30 <metaperl> Lemmih: http://www.cc.gatech.edu/~yannis/fc++/
22:10:34 <metaperl> Functional C++ library
22:12:03 <Khisanth> metaperl: if you go by that then you should be using Java!
22:12:13 <mflux_> samb, btw, I wasn't thinking about toplevel definitions only, but also so stuff that's inside the functions..
22:12:27 <SamB> mflux_: oh.
22:12:29 <metaperl> Khisanth: you mean dice? yeah 12,000 java jobs on dice
22:12:35 <metaperl> 3000 Perl jobs
22:12:46 <mflux_> you only need one job
22:12:47 <mflux_> or two
22:12:56 <metaperl> mflux_: true and you need to love it
22:13:05 <metaperl> which is why I am learning Haskell
22:13:06 <mflux_> so 0 quite clearly doesn't cut it, but even 3000 do
22:13:21 <metaperl> you can get work in Haskell if you're good
22:13:26 <metaperl> Aetion, Galois
22:14:02 <Khisanth> well there is the problem, how good you have to be before you can get any job :)
22:14:03 <SamB> well, obviously one needs to be a little more creative to get a haskell job...
22:14:14 <Khisanth> but then you have to somehow prove you are as good as you claim
22:14:39 <SamB> I mean, you can't just use a mundane method to get a haskell job.
22:15:26 <Khisanth> get a job and then convince your employer to let you write it in Haskell? :)
22:16:03 <mflux_> khisanth, the trick: just write the 'prototype' of the product to come in haskell
22:16:04 <SamB> well, that is one possibility ;-)
22:16:19 <metaperl> FC++ does not look so hot after all
22:16:22 <mflux_> khisanth, but in reality nobody rewrites the actual product when they have a working prototype!
22:16:25 <mflux_> ;)
22:16:32 <Khisanth> heh
22:16:37 <SamB> hehe
22:16:42 <metaperl> Haskell isn't really corporate ready in some ways
22:16:47 <Khisanth> sneaky
22:16:58 <SamB> unless they wrote the prototype in, er, what is that language...
22:17:39 <metaperl> you are never going to be able to run to a huge repository of code and fill in the blanks for your project.. and there is no fudging in Haskell at the last minute to fix things that are broken in production.
22:18:48 <mflux_> what do you mean by 'no fudging' etc?
22:19:08 <metaperl> mflux_: well, it's kinda hard to describe
22:19:11 <SamB> functional purity, type safety...
22:19:12 <metaperl> let's see
22:19:22 <metaperl> yes, you can just stick in a little something to get things working
22:19:27 <metaperl> s/can/cant/
22:19:27 <mflux_> you mean you can't write kludges in haskell because of the io monad?-)
22:19:34 <SamB> all the things that keep you from shooting yourself in the foot?
22:19:38 <metaperl> :)
22:19:47 <SamB> well, there is unsafePerformIO...
22:19:49 <metaperl> corporate programming is about face value
22:19:54 <metaperl> and speed
22:20:02 <metaperl> and pre-existing pop-in code
22:20:34 <Khisanth> Perl seems rather good for fudging :)
22:20:38 <metaperl> yes
22:20:46 <metaperl> and mod_perl and text processing
22:20:51 <mugwump> that is, until said corporates find someone really really effective in said languages.  then they get hooked on the fast results :)
22:20:53 * SamB thinks it is too good for fudging
22:21:20 <metaperl> yes, Haskell creates the proper framework for creating stable code
22:21:22 <mugwump> "Perl developers seem to be a lot faster than Java developers" said my boss once :)
22:21:43 <mugwump> metaperl, and this is why we want Perl 6 to be a dialect of Haskell!  :)
22:21:53 <metaperl> mugwump: are you serious?
22:22:20 <metaperl> there are too many cutesy changes for Perl6: x is now xx ? : is now ?? ::
22:22:27 <metaperl> -> is now .
22:22:37 <metaperl> too much cutesy dabbling
22:22:56 <mugwump> well the syntax will be entirely different, but the idea is to grab as much good stuff from Haskell that makes it rock..
22:23:02 <Khisanth> that is only because the standard keyboard doesn't have enoughs keys ;)
22:23:03 <mugwump> ..as is possible
22:27:33 <SamB> too much syntax!
22:27:43 <SamB> not enough semantics!
23:36:21 <sjanssen> is there a float type that is longer than a Double?
23:44:10 <lispy> sjanssen: you could use rationals
23:44:25 <sjanssen> lispy: sadly, I need sqrt
23:44:31 <sjanssen> or a new algorithm
23:44:47 <lispy> you could use netwons method to approximate it :)
23:45:44 <lispy> personally i think more numerical algorithms need to admin that the reals sare not possible and that rationals can give arbitrary precision
23:45:55 <lispy> s/admin/admit/
23:46:35 <lispy> but i think everyone feels that being able to use the fp unit on the processor is worth more than the arbitrary precision
23:47:43 <sjanssen> lispy: perhaps you should add rationals to the instruction set
23:47:54 <lispy> hehe, sure, i'll get right on it
23:48:05 <lispy> now where did i put that soldering iron....
23:48:11 <musasabi> Is there a reason that functional dependencies and overlapping instances don't interact nicely?
23:48:30 <lispy> functional dependencies are undecidable in some cases
23:48:34 <lispy> i don't know if that is one of them
