00:07:31 <Gahhh> say meuning
00:40:51 <lispy> No instance for (Show (IO ()))
00:41:46 <lispy> i have no idea why i get that when i try to do output
00:41:51 <Lemmih> ioThingy >>= print
00:44:05 <lispy> same thing...
00:44:21 <Lemmih> Paste?
00:44:30 <lispy> (randomPermutation (randomInt 5)) >>= print
00:44:50 <lispy> randomPermutation :: forall a.
00:44:52 <lispy>     (Num a, Random a, Ord a) =>
00:44:54 <lispy>     IO a -> IO [a]
00:44:59 <lispy> randomInt :: forall a. (Num a, Random a) => a -> IO a
00:45:34 <Lemmih> randomInt 5 >>= randomPermutation >>= print
00:45:49 <musasabi> morning
00:45:56 <Lemmih> Oh wait.
00:46:20 <lightstep> lispy, try to put your expression as `main'
00:47:02 <Lemmih> lispy: Where's that (IO ()) coming from?
00:47:24 <lispy> Lemmih: i have no idea
00:47:39 <lispy> lightstep: that gives me an ambiguous type variable...
00:48:34 <lightstep> `default' declarations might confuse it
00:48:41 <lightstep> try default (Integer)
00:49:07 <lispy> lightstep: what do you mean?
00:49:34 <lightstep> it probably doesn't understand what 5 is
00:49:57 <Lemmih> lispy: How are you invoking the code?
00:50:13 <lispy> lightstep: okay, it accepts this main = testPerm (5::Int)
00:50:18 <lispy> Lemmih: ghci
00:51:04 <lispy> lightstep: although, when i type main, nothing appears to happen (it just hangs)
00:51:11 <Lemmih> No need for main then.
00:51:30 <lightstep> in ghci you can just write `testPern (5::Int)', and it'll run
00:51:47 * lightstep is to lazy to reach the mouse
00:52:36 <lispy> how bizaar, testPerm (5::Int) does work, whereas testPerm 5 tells me No instance for (Show (IO ()))
00:55:10 <lispy> i give testPerm a type signature so I won't have to worry about that in the future :)
00:55:26 <lispy> thanks for the help, sometimes these type errors blow my mind
00:55:38 <Lemmih> I think it's a known bug in GHCi.
00:57:11 <lispy> wow, they know it blows my mind :)
00:57:25 <lispy> those guys (and gals) are sharp :)
00:59:18 * Lemmih ponders if JaffaCake has fixed it already.
01:03:26 <nlv11757_> hmm, is there an editor that won't hang if i open a textfile which has only one line, but 9 million characters on that line
01:03:40 <lightstep> ed
01:04:59 <boegel> nlv11757_: why on earth would you want to do that ? :)
01:05:18 <nlv11757_> uhm, i print the ast of a C program on one line :D
01:05:58 <lispy> nlv11757_: does emacs have problems?
01:06:16 <lispy> it's usually pretty good about odd files
01:06:24 <boegel> 9 million character is more a memory problem I guess
01:06:29 <nlv11757_> ow damn, emacs works like a charm
01:06:33 <boegel> +s
01:06:40 <nlv11757_> im abandoning vim
01:06:49 <nlv11757_> thanks lispy
01:07:00 <lispy> np
01:07:09 <lightstep> vim doesn't work well for more than ~1/2 million chars per line
01:07:49 <nlv11757_> yeah, i cant have that
01:07:50 <nlv11757_> :D
01:08:46 <lightstep> `fmt' shouldn't ruin the validity of your c program, and it should break it to lines or reasonable length
01:36:30 <nlv11757_> wow compiling that file with 16 million characters on one line almost made my computer hang
01:43:20 <lispy> hmmm
01:43:37 <lispy> how large was the program before you started playing with it?
01:45:21 <lispy> i learned two lessons today.  1) unsafePerformIO is not safe to use with random numbers. (I thought it would be!) 2) when write a function that returns a monadic value, it is often best to return IO a instead of something like (IO a) or [IO a]  (those are weak examples...)
01:46:10 <nlv11757_> IO a instead of (IO a) ?
01:46:51 <lispy> er, that should have been a tuple
01:47:07 <lispy> like (IO a, IO a)
01:47:37 <lispy> if you return IO (a, a) then it is easy to use that function inside of another do block
01:58:28 <Lor> If you have [IO a], you can always get IO [a] (with sequence), but not the other way.
01:58:35 <Lor> (Unless you use unsafeInterleaveIO)
01:59:41 <Lemmih> unsafeInterleaveIO :: IO a -> IO a
02:01:54 <Lor> Ah, sorry. I meant you can get IO [IO a].
02:02:08 <Lor> But naturally not a pure list.
02:05:32 <hellish> lispy: what problem did you have using unsafePerformIO w/ random numbers?
02:05:47 <lispy> hellish: i was getting random results (in a bad way)
02:06:04 <hellish> you wanted predictable results?
02:06:10 <lispy> in a sense
02:06:43 <lispy> i was generating an adjacency matrix, for an undirected graph so (i,j)==(j,i), but I was finding that to not always be the case
02:06:59 <lispy> but now that I've stop using unsafePerformIO that problem seems to be gone
02:07:22 * hellish would probably understand that if you knew more about matrices.
02:08:07 <lispy> just think of a two dimensional array, then.  It all goes through the same :)
02:08:25 <lispy> Basically the entries should be reflected around the diagonal
02:09:56 <hellish> you couldn't generate a random 1/2 matrix and flip it?
02:10:16 <lispy> i was trying to do that actually
02:10:55 <hellish> and unsafePerformIO broke the flipping?
02:11:43 <lispy> with arrays in haskell you use a//[(index, value)] to update the array.  To generate the update array for each entry ((i, j), k), i also created ((j, i), k)
02:12:24 <lispy> i'm probably not making much sense
02:12:43 <lispy> but i think it was because the k's where generated with unsafePerformIO that caused the problem
02:13:34 <hellish> ah.
02:13:48 <hellish> I might understand.
02:32:58 <nlv11757_> darn, im being swapped to death
02:33:43 <nlv11757_> ast = ....16 million character ast...
02:33:49 <nlv11757_> thats the only thing in the file :S
02:34:01 <nlv11757_> why would it ask for so much?
02:34:31 <Lemmih> Why not place a few newlines in the file?
02:34:42 <nlv11757_> ok so my new approach was placing newlines
02:34:56 <nlv11757_> compiling still didnt work because i was being swapped to death
02:52:53 <nlv11757_> stack overflow :S
02:54:43 <lispy> sounds like you need multiple files more than multiple lines
02:56:31 <nlv11757_> is constructing this tree in memory so darn huge?
02:57:23 <lispy> well, the linux kernel is probably more characters and it compiles fine :)
02:57:59 <nlv11757_> i fail to see the comparison :)
02:58:19 <lispy> the kernel is in many small compilation units
02:58:47 <lispy> the compiler can handle each one, but i bet if you concatenated them together and tried to compile it would be crazy
02:58:48 <jlouis> /g 7
02:58:51 <jlouis> bleh
03:23:47 <foxy__> @seen dons
03:42:02 <nlv11757_> @seen nlv11757_
03:42:03 <lambdabot> You are in #haskell. Last spoke just now.
03:45:11 <glimming> Hej.
03:45:16 <glimming> En liten fr√•ga = a small question.
03:45:26 <glimming> How to write new line in Haskell hugs or ghci
03:45:29 <glimming> not \n
03:45:34 <glimming> e.g. I want to type do notation
03:45:42 <glimming> also a REQUEST
03:46:17 <glimming> I'd like ghci and hugs to have a smarter interactive interface where I can ask questions such as "what is this and that in the prelude"
03:46:41 <glimming> i.e. search the prelude query for definitions and types, wildcard and fuzzy search --- is this available? Maybe in some special Haskell version?
03:52:18 <glimming> Stunning Silence .. Where are the Haskell people?
03:52:23 <earthy> doesn't Helium help you a bit there?
03:52:48 <glimming> Helium?
03:52:56 <earthy> at least if you make a type error it will suggest a possibly correct other function
03:53:01 <earthy> or way of writing things
03:53:20 <glimming> my vital also?
03:53:31 <glimming> Sounds very nice.
03:53:42 <glimming> It would be really nice to add such features to the interactive interface.
03:53:56 <glimming> Maybe there is already a reflection interface so that we can query types and search prelude and ask for advise and refactorings?
03:54:08 <glimming> There should be a plugin standard for interactive Haskell compilers.
03:54:18 <glimming> Such that we can load plugins written in Haskell.
03:54:19 <glimming> ...
03:54:32 <glimming> Typing Haskell in Haskell ? I am not sure how this all fits together
03:54:47 <earthy> um... that's more of an issue for IDEs
03:54:48 <glimming> Don't forget the new-line question for typing do notation intercatively? How is it done?
03:54:56 <glimming> Nah, IDEs need support for this.
03:55:06 <earthy> oh, that
03:55:19 <glimming> an interactive Haskell interpreter should have support for reflection, etc IMO
03:55:25 <earthy> the answer is `don't use newline'
03:55:27 <glimming> And intelligent reflection
03:55:57 <glimming> do putChar c return [] works right away?
03:56:08 <earthy> but the 'old' syntax using braces and semicolons
03:56:13 <glimming> btw, what is the write and writeln functions in the prelude? Bird calls them and defines them write and writeln
03:56:15 <earthy> i.e.  do { putChar c; return [] }
03:56:16 <glimming> aha
03:56:19 <glimming> right
03:56:26 <glimming> do {putchar c; return [] }
03:56:53 <glimming> A plugin architecture could also allow to hang on a monad to the interactive evaluator.
03:57:00 <glimming> i,.e. show reductions do debugging etc
03:57:03 <glimming> VERY cool stuff
03:57:12 <earthy> you have completely lost me there
03:57:51 <glimming> Prelude> do {putChar 'c'; return [] }
03:57:51 <glimming> <<IO action>>
03:57:52 <earthy> you want a haskell IDE with an interpreter that keeps your current source interpreted and the ability to extend it?
03:58:00 <glimming> Hrm, what's the IO action and what's the [] ?
03:58:06 <glimming> Is this qwhat Wadler called monad comprehension?
03:58:16 <earthy> @type do { putChar 'c'; return [] }
03:58:22 <lambdabot> do { putChar 'c'; return [] } :: forall a. IO [a]
03:58:23 <glimming> Yes, I want a more dynamic interactive interpreter.
03:59:00 <glimming> Entering a special mode, e.g., can allow you to plug in more functionality to the interpreter writing some Haskell monads for debugging while interpreting etc
03:59:21 <earthy> and HAT and Buddha don't give you what you want?
03:59:23 <glimming> earthy, I do not understand that
03:59:30 <glimming> Not seen it
03:59:35 <glimming> Will check them
04:00:01 <glimming> why this type?
04:00:16 <earthy> simple. the type of the do-block you wrote is an IO action over elements of type of lists of a
04:00:45 <earthy> (+ that of )
04:00:51 <earthy> so, the thing itself is an IO action
04:01:01 <earthy> which is a static entity, that you can then manipulate further
04:01:18 <nlv11757_> ok import problems
04:02:02 <earthy> oh, and glimming, please switch to ghci. :P
04:02:20 <nlv11757_> CilPrinter.hs imports Ast.hs (which originates from Ast.ag), Main.ag includes Ast.ag and imports CilPrinter.hs.
04:03:06 <nlv11757_> CilPrinter.hs contains function pFile :: File ....., which i want to use in Main.ag, but then suddenly it referrs to CilPrinter.File instead of File
04:03:06 <glimming> I am using ghci
04:03:19 <glimming> but not this time...
04:03:27 <earthy> ;)
04:03:29 <glimming> thanks over and out for now!!!
04:03:30 <musasabi> nlv11757_: you are not exporting the type File.
04:03:30 <glimming> ;-)
04:03:43 <nlv11757_> not from CilPrinter
04:03:59 <nlv11757_> because Main.ag gets the type from Ast.ag
04:04:27 <earthy> you're defining 2 different types File
04:04:39 <nlv11757_> thats the problem
04:04:39 <earthy> even thoug they are defined in the same Ast.ag
04:04:44 <nlv11757_> exactly
04:04:47 <earthy> the compiler does not know that
04:04:58 <nlv11757_> i dont want to shove CilPrinter.hs into Main.ag
04:05:01 <earthy> it only knows that there are 2 types named File in 2 places
04:05:08 <nlv11757_> but atm i dont see a different solution
04:05:28 <earthy> don't define the File type in Ast.ag but in a seperate File.hs
04:05:39 <earthy> then import *that* in Ast.ag and in CilPrinter.hs
04:05:41 <earthy> problem solved
04:05:58 <nlv11757_> but earthy, that type is an ag type
04:06:04 <nlv11757_> i need it to define attributes on
04:06:05 <earthy> (every problem can be solved by adding another layer of indirection)
04:06:20 <earthy> hm.
04:06:31 <mwotton> and every program can be sped up by taking one away, right? I love the corollary of that. :)
04:06:38 <earthy> mwotton: :)
04:06:49 <bourbaki> moin
04:07:22 <earthy> nlv: is there a *need* to directly include Ast.ag in Main.ag or can you get away with importing Ast.hs in Main.ag?
04:08:43 <nlv11757_> no thats the thing, im defining an attribute grammar in Main.ag
04:09:17 <earthy> what part of an ag? are you extending the DATA in Ast.ag? the SEM?
04:09:33 <nlv11757_> Attrs and Sems
04:10:50 <earthy> well, due to the include behaviour of UU AG, CilPrinter.hs ought to include Main.hs then, and not Ast.hs
04:11:16 <earthy> as Ast.hs is only an instrument in generating Main.hs and Ast.hs, to your program, has no real meaning
04:11:26 <nlv11757_> ok but then i have circular imports
04:11:32 <earthy> yes. ;)
04:11:32 <nlv11757_> since Main.hs is using CilPrinter.hs
04:11:59 <earthy> but you *could* generate the DATA definitions from Ast.ag in its own seperate Ast.hs
04:12:10 <nlv11757_> i am doing that indeed
04:12:16 <earthy> uuagc --data Ast.ag Ast.hs
04:12:29 <earthy> and then Main.ag should import Ast.hs as well as CilPrinter.hs
04:12:47 <nlv11757_> but i'd still have to include Ast.ag in Main.ag
04:12:52 <nlv11757_> wouldnt that give problems?
04:13:01 <earthy> and be compiled using uuagc --module --semfuns --catas --signatures Main.ag
04:13:03 <nlv11757_> lots of ambigous definitions
04:13:12 <Itkovian> how much space does an Integer take?
04:13:21 <Itkovian> say, if it does fit in 32 bit
04:13:24 <earthy> (you're not making new DATA's in Main.ag, are you? :))
04:13:40 <earthy> Itkovian: it's a thunk pointing to a gmp structure
04:13:44 <musasabi> Is there any paper on arrows and continuations?
04:13:45 <nlv11757_> not yet earthy ;)
04:13:49 <Itkovian> ok.
04:13:53 <earthy> nlv: then don't ever. :)
04:14:24 <musasabi> Some of the problem listed in the monadic formulations sound like arrows could maybe help them...
04:14:26 <earthy> so, quite big.
04:14:36 <nlv11757_> it seems that you need to have all things in one ag to get away with imports
04:14:47 <earthy> um, no
04:15:09 <earthy> but conceptually, the grammar is one thing, even if defined over multiple ag files
04:15:21 <earthy> so that makes it slightly less clear-cut
04:16:17 <nlv11757_> having Main.hs import Ast.hs and include Ast.ag would still give errors of File referring to either Ast.File or the File included from Ast.ag right?
04:17:50 <earthy> no
04:17:55 <earthy> wrong
04:20:54 <nlv11757_> why not? cause we have a Ast.File and a Main.File ?
04:21:02 <nlv11757_> that should conflict
04:21:17 <earthy> but you *won't* have Main.File
04:21:23 <earthy> due to not generating the --data declarations
04:21:47 <nlv11757_> including Ast.ag will have the effect of creating Main.File...
04:22:02 <earthy> no. ;)
04:22:20 <earthy> not at the .hs file level, unless you specifically ask UUAG for it
04:22:35 <earthy> look at the commands I gave you earlier
04:22:45 <nlv11757_> ow wwait, no datas for main.ag
04:22:51 <earthy> bingo
04:23:07 <nlv11757_> you really need a drawing board with this kind of stuff lol
04:23:17 <earthy> you, possibly :P
04:25:20 <nlv11757_> hehe ofcourse i was talking about mere me
04:26:25 <earthy> and rereading the H98 Report confirmed to me that Haskell indeed Does The Right Thing with regards to imports. ;)
04:27:07 <nlv11757_> :) i never said it wasnt me who was doing the wrong thing :P
04:28:01 <nlv11757_> i am getting a lot of ambigous sem functions and T_ types
04:28:05 <nlv11757_> same trick i guess
04:32:32 <nlv11757_> it seems to work earthy, thanks
04:42:58 <tuomov> dons: ping?
04:53:54 <poetix> Is there a standard equivalent to the State monad that is also an instance of MonadPlus?
04:55:01 <lightstep> what should the semantics be? nondeterminism?
04:55:07 <poetix> That's right.
04:55:14 <lightstep> you can define it
04:55:27 <lightstep> State isn't abstract
04:56:01 <poetix> instance MonadPlus State (Maybe a) where...?
04:56:32 <lightstep> mzero is, of course, return Nothing
04:56:32 <Spida> hi
04:56:33 <Spida> *g*
04:57:35 <poetix> OK, so pretty much like what I did already... (I made a hand-rolled state monad, and am trying to convert the code to use standard components)
04:57:38 <lightstep> i never understood the difference between MonadPlus and Monoid
04:58:08 <poetix> Different laws?
04:58:54 <lightstep> the wiki page made it very unclear what the MonadPlus rules are
04:59:24 <poetix> http://www.nomaware.com/monads/html/writermonad.html
04:59:36 <poetix> says: You may notice that these laws are the same as the laws governing mzero and mplus for instances of MonadPlus. That is because monads with a zero and plus are monads that are also monoids!
04:59:52 <poetix> But presumably not all monoids are also monads.
05:00:18 <Spida> is there a way to use a list of functions on a single value without using recursion?
05:00:52 <poetix> map (\f -> f val) fs?
05:01:46 <lightstep> swing map
05:02:01 <poetix> @t swing
05:02:02 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-ini
05:02:02 <lambdabot> t topic-snoc topic-tail topic-tell type pl wn
05:02:08 <lightstep> @type swing
05:02:09 <poetix> @type swing
05:02:12 <poetix> d'oh
05:02:14 <lambdabot> bzzt
05:02:14 <lambdabot> bzzt
05:02:26 <lightstep> @pl flip . (flip . ($))
05:02:27 <lambdabot> id
05:02:30 <lightstep> (or something)
05:03:16 <lightstep>  swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
05:03:19 <lightstep>  swing f = flip (f . flip ($))
05:03:40 <lightstep> @pl swing f = flip (f . flip ($))
05:03:41 <lambdabot> swing = flip . (. flip id)
05:05:47 * boegel enters yawning
05:06:11 * Itkovian waves at boegel
05:06:37 * poetix boggles at the type signature for swing
05:07:43 <dons> tuomov: ack
05:09:20 <lightstep> poetix, only the formalism is complicated. the pointful implementation is simpler
05:10:54 <poetix> map is (a ->b) -> [a] -> [b]
05:12:46 <tuomov> dons: I'm trying to do some improvements in the Yi search code
05:12:58 <tuomov> for some reason moveToW doesn't seem to work in withWindow..
05:13:49 <dons> but in withWindow_
05:13:49 <dons> hmm
05:13:58 <tuomov> basically I'm making the last block of searchF configurable, and so I'd just move the pointer in the first block already.. but it doesn't work
05:16:57 <dons> you have to use moveToW outside of withWindow, I seem to recal.
05:17:07 <dons> there's blocking going on, I think
05:17:24 <dons> you would use moveTo inside withWindow
05:20:10 <tuomov> so there's no way to keep things synced within withWindow?
05:20:31 <dons> nope, the withWindow is supposed to be a lock
05:20:45 <tuomov> it doesn't restore the point, though?
05:20:57 <tuomov> restore would be ok too..
05:22:04 <dons> looks like you have to restore it by hand
05:22:17 <dons> (I think, I'm a bit sleepy)
05:25:28 * boegel joins dons in being sleepy
05:27:26 <xerox> Hi
05:29:11 <boegel> hi !
05:30:24 <xerox> Hmm, I can't connect to freenode with ERC today, it pass a loooong time on connect before it answers.
05:31:16 <boegel> xerox: neither did I, connecting to irc.freenode.org seems to be a problem
05:31:34 <xerox> :(
05:31:54 <xerox> Anyway, what does "| m -> e" mean in "class (Monad m) => MonadError e m | m -> e where" ?
05:32:08 <Cale> m determines e uniquely
05:32:42 <xerox> So that for any given monad there is only one possible e ?
05:32:46 <Cale> yes
05:33:31 <xerox> This way you can't make different instance of monaderror, with same monad and different error types?
05:33:37 <Cale> right
05:33:39 <xerox> OK, thanks.
05:33:39 <nlv11757_> what the hell is this; "/tmp/ghc28197.hc:225346: warning: integer overflow in expression"
05:34:22 <Cale> nlv11757_: crazy -- what was it doing at the time it gave that message?
05:34:58 <nlv11757_> it was compiling a program, that simply does this; "ast = .....a very big datatype instance...."
05:35:24 <dons> does -fasm help?
05:36:12 <nlv11757_> i'll try, compiling took almost two hours though the first time
05:36:43 <nlv11757_> it doesnt complain...how come?
05:47:19 <rmbruijn> How can I put a falsum symbol in a paper (LateX)?
05:48:00 <boegel> rmbruijn: you realise this is #Haskell, right ? :)
05:48:10 <boegel> and what symbol do you mean?
05:48:18 <nlv11757_> bottom?
05:48:41 <boegel> \mathbb{V} ?
05:52:18 <nlv11757_> @google latex symbol list
05:52:26 <lambdabot> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.
05:52:26 <lambdabot> pdf
05:52:42 <nlv11757_> that should contain allll the symbols you need :D
05:52:57 <nlv11757_> why does it cut it off at the extension....
05:53:27 <boegel> nlv11757_: because the url is too long I think, it's coincidence
06:08:38 <TheHunter> my fault..., we need flood protection...
06:09:32 <xerox> ...always Hunting ;-)
06:09:46 <rmbruijn> dpkg can also be killed easily.
06:10:19 <TheHunter> @moo
06:10:21 <lambdabot>    )__(
06:10:21 <lambdabot>    (oo)
06:10:21 <lambdabot>  *-------\/
06:10:21 <lambdabot>  / |     ||
06:10:21 <lambdabot> /  ||----||
06:10:21 <lambdabot>  vv    vv
06:10:23 <lambdabot>  
06:10:25 <lambdabot>  Polish Cow
06:11:47 <rmbruijn> boegel: yes, I know. In what package is \bottom defined?
06:12:13 <nlv11757_> @google nl.wikipedia.org/wiki/Galvaniseren
06:12:14 <lambdabot> http://nl.wikipedia.org/wiki/Galvaniseren
06:12:32 <nlv11757_> amsmath probably
06:12:34 <nlv11757_> or amssymb
06:12:59 <boegel> nlv11757_: ? :)
06:13:08 <nlv11757_> is it me, or is that cow a bit handycapped hunter?
06:13:44 <TheHunter> i didn't get that cow.
06:13:46 <TheHunter> @moo
06:13:47 <lambdabot>    (__)
06:13:47 <lambdabot>    (OO)
06:13:47 <lambdabot>  /-------\/
06:13:47 <lambdabot>  / |     ||
06:13:47 <lambdabot> *  ||----||
06:13:47 <lambdabot>  ^^    ^^
06:13:49 <lambdabot>  
06:13:51 <lambdabot> Cow who drank Jolt
06:14:10 <nlv11757_> i'd say his hoofs are a bit crooked
06:14:12 <dons> is the formatting wacked?
06:14:21 <nlv11757_> it has to be
06:15:05 <lightstep> i got a healthier polish cow 2 days ago
06:15:09 <dons> did the @more patch do something, TheHunter?
06:15:25 <TheHunter> dons, i guess so.
06:15:52 <TheHunter> @foldoc foo
06:15:55 <lambdabot> *** "foo" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
06:15:55 <lambdabot> "
06:15:55 <lambdabot> foo
06:15:55 <lambdabot>  
06:15:55 <lambdabot>    <jargon> /foo/ A sample name for absolutely anything,
06:15:55 <lambdabot>    especially programs and files (especially {scratch files}).
06:15:57 <lambdabot>    First on the standard list of {metasyntactic variables} used
06:15:59 <lambdabot> [70 @more lines]
06:16:03 <TheHunter> i reduced the indent.
06:17:46 <dons>  @moo is a bit sensitive
06:17:52 <TheHunter> how bout ircPrivmsg :: ContT [String] IO String -> IRC () too obscure?
06:19:35 <dons> hmm..
06:19:37 <TheHunter> -        ircPrivmsg src cow
06:19:39 <TheHunter> +        mapM_ ircPrivmsg' src cow
06:20:18 <TheHunter> that's the quick and dirty solution.
06:20:48 <dons> yep, sounds reasonable.
06:20:58 <TheHunter> i already did that kind of thing in More.hs.
06:21:22 * TheHunter has no idea how to design the output filters properly.
06:21:38 <dons> yeah, they're a bit icky at the moment
06:22:22 * dons -> time for sleep. night!
06:22:42 <nlv11757_> wow got to be gmt plus a lot or minus a lot :D
06:22:49 <TheHunter> night!
06:22:49 <nlv11757_> ah australia :D
06:23:16 <TheHunter> @timein Sydney
06:23:20 <lambdabot>  Wednesday, May 4, 2005 at 11:24:20 PM EST
06:23:29 <nlv11757_> owww its early dons
06:23:30 <nlv11757_> lol
06:23:50 <nlv11757_> @timein Appelscha
06:23:52 <lambdabot>  Sorry, don't know this city
06:23:59 <nlv11757_> what a shame
06:24:20 <xerox> @wikipedia Galvaniseren
06:24:29 <lambdabot> module "search" screwed up: No result found.
06:24:35 <xerox> :-\
06:24:55 <earthy> @wikipedia galvanize
06:25:08 <lambdabot> http://en.wikipedia.org/wiki/Galvanize
06:28:04 <nlv11757_> earthy, why did you decide to do phd?
06:35:27 <earthy> nlv: good question :)
06:35:47 <earthy> but the base answer is that I love being around students and love doing research
06:44:46 <nlv11757_> ok
06:44:54 <nlv11757_> cause doaitse just asked me a question i cant answer hahaha
06:45:16 <nlv11757_> im not really passionate about anything afaik
06:45:26 <nlv11757_> so therefore i dont really know what i want
06:47:12 <earthy> ghe
06:47:20 <earthy> well... tough questions need thought to answer ;)
06:47:44 <earthy> to wit: it took me 3 or so years to finalize my decision to try for a PhD
06:52:09 <nlv11757_> hehe doaitse wants to know in 4 weeks :P
06:52:38 <nlv11757_> some people are just so possessed with bringing a certain idea to the world, or solving certain things in a certain way
06:53:11 <nlv11757_> I'm fine with it all as long as i don't have to program C
06:53:16 <nlv11757_> that i know :P
06:56:20 <Spida> hm
06:56:42 <Spida> I still don't understand the answer poetix gave me some time ago
06:57:23 <lightstep> 2 hours ago you mean?
06:57:34 <Spida> yeah, about 2 hours
06:57:54 <lightstep> you can write such a function yourself
06:57:54 <nlv11757_> what was the question again
06:57:55 <nlv11757_> ?
06:58:03 <lightstep> or build it over map
06:58:08 <lightstep> or over map&swing
06:59:05 <Spida> about implementation of a function test :: [(a -> b)] -> a -> [b] that should apply all functions of the first list to the value and output the values in a second list
06:59:22 <Cale> Spida: swing is in LicensedPreludeExts on the wiki
06:59:43 <earthy> @type ap
06:59:49 <lambdabot> bzzt
06:59:59 <lightstep> @type Control.Monad.ap
07:00:01 <lambdabot> Control.Monad.ap :: forall b (m :: * -> *) a.
07:00:01 <lambdabot>        (Monad m) =>
07:00:01 <lambdabot>        m (a -> b) -> m a -> m b
07:00:14 <earthy> yeah, but that's not the one I wanted :)
07:00:32 <lightstep> but it'll work in this case (i think)
07:00:35 <earthy> I wanted ap :: (a -> b) -> a -> b
07:00:45 <lightstep> @type flip id
07:00:47 <lambdabot> flip id :: forall b c. b -> (b -> c) -> c
07:01:01 <lightstep> you want id=($)
07:01:03 <Cale> @type ($)
07:01:06 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
07:01:08 <earthy> $ indeed
07:01:11 <earthy> !autolart
07:01:33 <pediddle> @type let test x = map ($ x) in test
07:01:35 <lambdabot> let test x = map ($ x) in test :: forall a b. a -> [a -> b] -> [b]
07:01:52 <pediddle> flip that
07:02:04 <lightstep> @pl (\x -> flip (map $x00
07:02:05 <lambdabot> (line 1, column 22):
07:02:05 <lambdabot> unexpected end of input
07:02:05 <lambdabot> expecting letter or digit, variable, "(", operator, "$", "$!", "`seq`"
07:02:05 <lambdabot> or ")"
07:02:11 <lightstep> @pl (\x -> flip (map ($ x)))
07:02:11 <vincenz> @type let x = flip (map ($ x))
07:02:12 <lambdabot> flip . map . flip id
07:02:13 <lambdabot> bzzt
07:02:19 <earthy> @type flip (map ($ x))
07:02:20 <lambdabot> bzzt
07:02:22 <vincenz> @type let test x = flip (map ($ x)) in test
07:02:23 <lightstep> @pl flip (swing map)
07:02:23 <lambdabot> bzzt
07:02:23 <lambdabot> flip (swing map)
07:02:32 <earthy> bzzt?
07:02:40 <earthy> ah. bzt. :)
07:03:23 <reffie> three six nine damn you're fine
07:03:26 <vincenz> @type let test x = flip (map ($ x)) in test
07:03:29 <lambdabot> bzzt
07:03:31 <vincenz> ??
07:04:11 <lightstep> @type (\x -> flip (map ($ x)))
07:04:13 <lambdabot> bzzt
07:04:29 <lightstep> ghci (\x -> flip (map ($ x)))
07:04:30 <earthy> @type flip (\x -> flip (map ($ x)))
07:04:31 <lambdabot> bzzt
07:04:35 <earthy> err?
07:05:30 <earthy> !autolart
07:05:37 <lightstep> @type flip (\x -> map ($ x))
07:05:39 <lambdabot> flip (\x -> map ($ x)) :: forall a b. [a -> b] -> a -> [b]
07:05:40 <earthy> that's the one.
07:05:41 <earthy> :)
07:05:48 <vincenz> autolart?
07:05:49 <earthy> I had 2 flips where I only needed one. ;)
07:05:59 <earthy> loser attitude readjustment tool
07:06:03 <earthy> ==l art
07:06:08 <earthy> apply to self == autolart
07:06:16 <vincenz> and what does it do?
07:06:32 <earthy> it makes you stop being such a loser
07:06:38 <vincenz> lol
07:06:41 <earthy> in some cases quite terminally. :)
07:06:48 <vincenz> restarts lambdabot?
07:06:54 <earthy> nope
07:10:32 <Spida> Cale: is there any documentation about this swing?
07:10:47 <Spida> Cale: or can you tell me what it does and how to use it?
07:11:05 * Spida doesn't even understand the syntax of what is listed in the wiki
07:12:29 <lightstep> of the type declarations?
07:12:38 <lightstep> i don't think there's formal documentation
07:13:02 <lightstep> if you don't understand it, and it doesn't work, you can write a customized version for your program in a minute
07:13:40 <Spida> I am not sure if _I_ can *g*
07:14:23 <lightstep> in your case, you can write `test' as a recursive function
07:14:36 <Spida> lightstep: no
07:14:43 <Spida> no recursion
07:14:48 <lightstep> oh?
07:15:16 <Spida> would be no problem if I would be allowed to use recusion, but I am not
07:15:43 <lightstep> so you can use `map' to transform the list of functions to a list of results
07:15:49 <lightstep> or fold them
07:16:26 <lightstep> but the recursion will be there anyway
07:16:42 <nlv11757_> what is the best primer/intro for someone interested in getting to know functional programming?
07:16:56 <nlv11757_> just to see what it is about and maybe try a little and stuff
07:17:18 <lightstep> i liked the gentle introduction
07:17:23 <lightstep> *hiding*
07:21:02 <bourbaki> moin
07:22:04 <nlv11757_> hehe lightstep are you sure you want to expose a person curious what this functional programming is what some guys are talking about to the gentle introduction?
07:23:20 <lightstep> i liked it very much when i was starting
07:23:47 <lightstep> it states all the different assumptions very clearly
07:24:09 <Spida> lightstep: using a predefined function like map that uses recursion is no problem, but I can't define a function that uses recursion
07:24:15 <lightstep> i don't remember exactly, but the first chapters go like "here, that's cool, and you don't really want output"
07:24:26 <nlv11757_> the gentle introduction advices this: "If the reader wishes to learn more about the functional programming style, we highly recommend Bird's text Introduction to Functional Programming [1] or Davie's An Introduction to Functional Programming Systems Using Haskell [2]"
07:25:28 <lightstep> i saw [2] a little after i skimmed through get gentle introduction, but i already saw "ml for the working programmmer" by then
07:25:39 <lightstep> which is, btw, a fine book too
07:25:57 <TFK> Shalom lightstep
07:26:20 <lightstep> happy memorial evening
07:26:40 <nlv11757_> pfff im trippin from the expressos here
07:27:00 <TFK> Heh. It tried raining today in Jerusalem :D
07:27:22 <lightstep> here it's a little too warm for that
07:27:35 <TFK> Where are you again? (Sorry, forgot)
07:27:48 <lightstep> ramat gan
07:27:55 <lightstep> @google gentle introduction to haskell
07:27:57 <lambdabot> http://www.haskell.org/tutorial/
07:28:21 <lightstep> see? even an official url
07:29:01 <TFK> mm, gentle.
07:29:26 <xerox> err.. "Gentle"
07:29:46 <TFK> Capitalization nazi >_>
07:29:56 <nlv11757_> yeah but i also want to send this person a backuplink because he's just interested in functional programming and playing around to what it is
07:30:13 <nlv11757_> the gentle introduction maybe too blunt and haskell directed
07:30:39 <xerox> TFK the point is the '"'s :-)
07:31:08 <TFK> xerox, oh, yeah, I have to agree :-(
07:31:30 <TFK> But it's OK if you read each chapter 5 times. You get a warm fuzzy feeling inside when you grok something :-)
07:31:42 * xerox knows the feeling
07:31:59 <lightstep> the gent. intro. is very algebra-like
07:32:07 <sbeyer> hm, btw is it possible to indent haskell in a nice way? ;)
07:32:21 <xerox> sbeyer what do you mean by "nice" ?
07:32:32 <TFK> sbeyer, you can start from a newline after the = in the definition of a long function.
07:32:42 <sbeyer> TFK, I do, indented with a tab ;)
07:32:48 <TFK> :O
07:32:58 <TFK> I think 2 spaces works for Haskell o_O
07:33:21 <nlv11757_> i always substitute a tab by 2 softspaces
07:33:22 <sbeyer> e.g. using guards, many people put the =s in the same row
07:33:23 <TFK> You can probably get your editor to expand tabs.
07:33:30 <nlv11757_> or was it every softtab by 2 spaces
07:33:54 <nlv11757_> isnt there some article about how to write nice haskell code in TMR :)
07:34:28 <xerox> Emacs' haskell-mode has some nice behaviors
07:35:20 <sbeyer> hm, I should generally switch to emacs for functional programming ;) but yet too less time to work through the tutorial ;)
07:35:46 <xerox> It's worth it!  ...waiting for Yi ;-)
07:36:34 <nlv11757_> im already a bit used to vim, but vim doesnt have the fancy stuff afaik
07:36:45 * TFK starts using Darcs
07:37:05 <skew> I just started managing something with darcs too
07:37:41 <xerox> nlv11757_ IIRC it has Haskell synhl, dunno about the indentation.
07:37:45 <kowey> oh, hi, skew
07:37:49 <skew> hi
07:37:54 <skew> did you fix your xml thing?
07:37:56 <TFK> Just made a test run. It looks too easy o_O
07:37:57 <kowey> i've finally got that haxml profiling working... wanna see?
07:38:00 <nlv11757_> skew any introductory material for someone just interested in getting to know about functional programming and trying some programs. (apart from the gentle introduction)
07:38:03 <skew> sure
07:38:06 <kowey> (no, now i've just got a nice graph)
07:38:09 <nlv11757_> xerox, you're right, syn.hl. is there
07:38:24 <kowey> http://www.loria.fr/~kow/tmp/debugger-geniconvert.ps
07:38:49 <kowey> maybe malcom would be interested as well
07:39:40 <kowey> opps.. malcolm, i meant
07:39:54 <skew> that looks a bit odd
07:40:35 <skew> is that from parsing your whole file?
07:40:40 <kowey> yep
07:40:49 <kowey> i could also show you source code and the xml file in question
07:40:50 <skew> I wouldn't expect Lex to be sucking up so much memory
07:41:33 <kowey> the xml file is 1.4M if it helps
07:41:57 <skew> nlv11757_: I don't know of any tutorial-type material. I mostly just read random papers and tried things out
07:42:09 <skew> nlv11757_: the nomaware tutorial looks pretty good for monads
07:42:37 <skew> kowey: It looks suspiciously like the lexer is hanging on to all the input
07:42:43 <kowey> hmmm...
07:42:47 <kowey> if this helps,
07:42:53 <kowey> http://www.loria.fr/~kow/tmp/debugger-geniconvert-hc.ps
07:43:06 <kowey> one thing which i may be doing wrong in my code
07:43:22 <skew> but I'm doubting myself because I think somebody else would have already found and squished any space leak
07:43:36 <kowey> is that from the XML, i build a list of data structures, and then i use a function to write said structures to text
07:43:59 <kowey> i do vaguely recall reading something from the hxml guy
07:44:15 <kowey> and Malcolm did mention something about space efficiency on the haxml page... related?
07:44:49 <nlv11757_> man im stupid, instead of asking myself what i used for learning :D
07:44:51 <nlv11757_> http://www.cs.uu.nl/people/jeroen/courses/fp-eng.pdf
07:45:03 <nlv11757_> this is more gentle than the gentle introduction
07:45:30 <kowey> oh god, i'm up for lots of embarassement here, but....
07:45:31 <kowey> http://www.loria.fr/~kow/darcs/Geni/src/geni/GrammarXml.lhs
07:49:24 <nlv11757_> kowey, people here are not out to embaras you.
07:49:45 <kowey> showing one's code... *shiver*
07:49:51 <kowey> good for you, i know, but still...
07:49:55 <lightstep> the IO monad is way to coarse to be nice
07:50:22 <basti_> coarse?
07:51:28 <lightstep> you don't know whether an IO value throws exceptions
07:51:43 <basti_> oh.
07:51:46 <skew> kowey: wait, do you read the file once and then pass it to all your parsing functions?
07:51:47 <lightstep> which is really stupid, since we have Error for that stuff
07:52:11 <kowey> uh yes
07:52:12 <basti_> continuations should be used for errors anyway, shouldn't they?
07:52:15 <kowey> is that not a good idea?
07:52:24 <kowey> getContents says it's lazy, right?
07:52:27 <skew> kowey: of course that is going to keep the entire file in memory
07:52:43 <kowey> oh... but i thought ...
07:52:45 <kowey> hmm
07:52:55 <kowey> okay, i see, so lazy means it won't read the file until it has to
07:52:59 <skew> maybe if you're really luck it might work
07:52:59 <lightstep> it depends on optimization level
07:53:05 <kowey> but when it does read it... it dumps the whole thing into memory?
07:53:12 <skew> no, it reads it as required
07:53:21 <norpan> it will just memmap the file so what's the problem
07:53:25 <skew> but it can't garbage collect the start if you still have a reference to the string
07:53:33 <skew> norpan: unfortunately not
07:53:38 <lightstep> basti_, perhaps. the point is, not you can wrap things this way, but using IO is ugly
07:53:56 <skew> norpan: [Char] doesn't exactly match the raw string of bytes
07:54:20 <norpan> oh, you mean he uses the file string more than once
07:54:23 <norpan> that's bad
07:54:31 <kowey> uh... link coming up
07:54:36 <kowey> http://www.loria.fr/~kow/darcs/UnstableGeni/src/geni/Converter.lhs
07:54:40 <skew> norpan: I mean getContents never uses mmap, as far as I know
07:54:46 <kowey> see convertMacros
07:54:49 <nlv11757_> good day everyone
07:55:11 <norpan> getContents reads stdin so it can't
07:55:21 <norpan> or can it?
07:55:25 <norpan> if stdin is a file
07:55:42 <basti_> mmm i think i see your point
07:55:54 <skew> norpan: the issue is more that [Char] is like a linked list of heap allocated boxes containing a single character each, which isn't anything like the raw file layout
07:55:56 <norpan> but lf is only used once, in the call to parsXmlLexicon, so after that it could be garbage collected
07:56:06 <skew> norpan: exactly
07:56:27 <kowey> (well... here actually, it's parseXmlGrammar)
07:56:31 <kowey> for the file in question, but yeah
07:57:10 <skew> hmm, that doesn't look like a problem
07:57:44 <kowey> another thing i was thinking is that i am simply misusing haxml... i don't actually know how all this combinator stuff works
07:57:57 <kowey> i just sorta... dunno... kept staring at the doc until things sorta made sense
07:58:17 <skew> doing something like g <- readFile filename; print (map ($ g) [parseX,parseY,parseZ] would be bad
07:58:42 <kowey> because that would require holding g in mem
07:58:48 <skew> yes
07:59:35 <skew> about the only way to avoid it is if you happen to very luckily interleave outputtting different bits of X Y and Z so forcing those values happens to run down the file in synchronization
08:00:03 <skew> but this looks like it should be fine
08:01:19 <kowey> well... in the toplevel of parseXmlGrammar (i can resend the link)
08:01:33 <kowey> it does not look like i'm reusing the string g, either, does it?
08:01:40 <skew> I grabbed it for the syntax highlighting
08:02:54 <kowey> http://www.loria.fr/~kow/tmp/semFrenchLite.xml
08:03:00 <kowey> (biggish)
08:06:12 <basti_> reusing the g string?
08:06:19 <pediddle> um
08:06:33 <skew> not that I can see...
08:06:44 <kowey> basti_: back in my days of programming in Basic, we'd have variables like g$ and shoe$
08:06:53 <basti_> he he he
08:07:32 <pediddle> g.
08:07:36 <pediddle> (g spot)
08:08:06 <skew> how much memory does it take to just read in the whole file?
08:08:17 <basti_> O(n) i suppose :)
08:08:34 <skew> do f <- readFile "filename"; print (length f); print (head f) should do it.
08:08:36 <norpan> i would guess 8 times the file size
08:08:38 * Oejet wishes that '?' and '!' were legal in identifiers.
08:08:50 * kowey checks
08:09:03 <skew> norpan: it has to be more than that
08:09:27 <skew> there are 8 bytes of pointers in the cons cell alone, just to point to the character and the next cons cell
08:10:53 <skew> at least another 8 bytes for pointers to the code associated with the cons cell and the Char, and probably a full word to store the character in
08:11:26 <pediddle> does readFile do UTF-8?
08:11:34 <skew> I don't think so
08:12:10 <pediddle> Haskell 98 really dropped the ball on i18n
08:12:29 <norpan> 91 MB for a 5 MB file
08:12:45 <skew> IIRC, Char is specified to be a unicode character, but all the IO functions just use the low 8 bits
08:13:49 <norpan> 181 MB for a 10 MB file
08:13:55 <pediddle> but if there's no way to specify an encoding to readFile (at least not with the standard (simple) interface), then it's useless
08:13:56 <basti_> O(n) :)
08:13:57 <norpan> 18 times the size
08:14:02 <pediddle> ouch
08:14:13 <kowey> http://www.loria.fr/~kow/tmp/a.out.ps
08:14:18 <skew> hmm, I must be overcounting somewhere
08:14:24 <kowey> http://www.loria.fr/~kow/tmp/readfile.hs
08:15:15 <pediddle> skew: did you count the thunks?
08:16:43 <skew> pediddle: there won't be any left unevaluated by the time you have the whole file
08:17:47 <pediddle> if you don't actually print the chars, wouldn't the string be a list of pointers to thunks pointing to chars?
08:18:49 <skew> I don't think so, the characters are coming from IO, so you already know what they are
08:20:31 <skew> I was only counting one pointer to code plus one extra word for a Char on the heap, so any thunk (that holds any data) would be at least as big
08:22:05 <skew> but I must have something wrong because I count 20 bytes per character for a String, and you seem to see 18
08:22:32 <lightstep> maybe it's 16, with some gc overhead?
08:22:54 <skew> it could be
08:23:02 <norpan> see 18?
08:23:02 <skew> but how do you divide up that 16?
08:23:11 <skew> 181MB for a 10MB file, etc
08:23:20 <norpan> where do you cound 20?
08:23:51 <skew> 3 pointers in a (:) on the heap, plus 1 pointer and 1 word in a Char, on a 32 bit machine is 20 bytes
08:23:55 <skew> unless I'm just adding wrong
08:24:20 <lightstep> two pointers, onve char hy 3 pointers per (:)?
08:24:38 <norpan> 16 bytes per char
08:24:44 <norpan> that's two bits
08:24:51 <lightstep> how did this come?
08:24:53 <norpan> err, two bytes
08:25:24 <lightstep> maybe my brain is malfunctioning
08:25:36 <pediddle> lol
08:25:54 <skew> Isn't a full unicode character 4 bytes? Or, people like to allocate on word boundaries because x86 is happier fetching them?
08:26:06 <norpan> i think haskell has 16 bits per character
08:26:11 <norpan> or at least ghc
08:26:19 <skew> that would do it then
08:26:21 <pediddle> that would explain the missing 2 bytes
08:26:28 <norpan> a full unicode character is 21 bits
08:26:32 <norpan> or 20.something
08:26:44 <pediddle> there is UTF32 encoding though
08:26:59 <lightstep> ok, better now
08:26:59 <skew> I thought that was called UCS-4?
08:27:04 <pediddle> right
08:27:06 <norpan> that's the same
08:27:47 <norpan> is there a readFile that reads Word8?
08:28:32 <skew> not that I know of
08:28:53 <skew> there is something that reads into a Ptr
08:29:02 <skew> Ptr Word8, I think
08:29:19 <norpan> Array Word8 would be nice
08:29:20 <skew> treats the Ptr as raw memory, anyway
08:30:19 <Arsilan> f
08:30:19 <Arsilan> f
08:30:19 <Arsilan> f
08:30:19 <Arsilan> ff
08:30:20 <Arsilan> f
08:30:20 <Arsilan> ff
08:30:22 <Arsilan> f
08:30:24 <Arsilan> f
08:30:26 <Arsilan> f
08:30:28 <Arsilan> f
08:30:30 <Arsilan> f
08:30:32 <Arsilan> f
08:30:34 <Arsilan> f
08:30:35 <lightstep> please stop
08:30:36 <Arsilan> f
08:30:38 <Arsilan> f
08:30:40 <Arsilan> f
08:30:41 <goron_> Wft are you doing?
08:30:42 <Arsilan> ff
08:30:44 <Arsilan> f
08:30:45 <skew> Arsilan: wake up, your nose fell on the f key...
08:30:48 <Arsilan> f
08:30:49 <theorbtwo> /ignore arsilan
08:30:50 <Arsilan> f
08:30:52 <Arsilan> f
08:30:53 <theorbtwo> Dammit.
08:30:54 <Arsilan> f
08:30:54 --- mode: ChanServ set +o Igloo
08:30:56 <Arsilan> ok
08:31:44 <Oejet> Igloo: It's ok, I think.
08:31:53 <Igloo> That's why I hadn't kicked him  :-)
08:31:58 --- mode: Igloo set -o Igloo
08:32:41 <basti_> -?-
08:32:53 <skew> kowey: I've been wondering how hard it would be to use something like expat for the parser in an xml library, and if it would help
08:33:13 <kowey> hmm
08:33:22 <kowey> you mean ffi, or just write in some other language?
08:33:30 <skew> ffi
08:33:42 <kowey> might be interesting
08:33:48 <kowey> hxml implements a sax like thing
08:33:53 <kowey> i could never get it to compile though
08:33:59 <skew> you don't want to trade the combinators for a DOM, do you?
08:34:24 <kowey> DOM?.... eh... would rather not
08:34:32 <kowey> but honestly, whatever works?
08:35:07 <kowey> also guessing (from experience) that this would be even more big+horrible?
08:35:23 <kowey> (experience being java and maybe not being clever enough, naturally)
08:36:14 <skew> well, you're not hanging onto the input at the top level, and I don't have enough time to look carefully enough through the rest right now
08:36:29 <kowey> don't worry about it, skew
08:36:42 <kowey> you've been a big help so far, and i've got other stuff i can play with as well :-)
08:37:00 <skew> if this is a one-time conversion it probably doesn't matter so much anyway
08:37:16 <kowey> well. it's something i plan to use a lot
08:37:21 <skew> CosmicRay ran his CVS -> darcs program for hours and hours to covert the fptools repository
08:37:25 <kowey> but i might just go a head a write in something else
08:37:50 <kowey> mmm... like my darcs
08:37:58 <skew> making that something not Java would probably save a fair bit of code size
08:38:17 <kowey> man... so glad *those* days are over
08:38:28 <kowey> from ML to Java and back to Haskell
08:38:45 <skew> why go from ML to Java?
08:38:59 <kowey> erm... work related
08:39:09 <kowey> i don't think anybody actually *said* we had to use java
08:39:16 <kowey> but there was all this web service and xml stuff
08:39:25 <kowey> and i think the libs were available in java
08:39:40 <kowey> plus i was writing libs for use by java programmers
08:39:54 <kowey> (scala looks interesting -> ability to compile to jvm)
08:39:56 <skew> I wrote some stuff like that in Python
08:40:06 <skew> except for the making libs for Java programmers
08:40:50 <kowey> i guesss i should actually be thankful for the experience... java being a big community, got to learn about stuff like unit testing
08:40:53 <kowey> via junit
08:41:17 <skew> I saw QuickCheck first, and then JUnit doesn't look so impressive
08:41:25 <kowey> really?
08:41:33 <skew> Especially when you see how short HUnit is...
08:41:34 <kowey> i've been procrastinating on learning either QuickCheck or HUnit
08:41:42 <kowey> so go with QuickCheck, you say?
08:42:10 <skew> Well, I don't really do much testing, or write much code that needs it
08:42:36 <kowey> hmm... what do the rest of you folks think?
08:42:57 <skew> but I think QuickCheck is far and away better for convincing you that your code actually works, and HUnit is probably better for the regular unit testing / add a test for the old bug, etc. kind of stuff
08:43:09 <skew> HUnit is you write down canned test cases and it tries them
08:43:35 <skew> QuickCheck is you write down properties your code is supposed to satisfy and specify an input distribution, and it runs lots of tests from all over input space
08:43:49 <kowey> hmm
08:44:03 <kowey> not quite the same, but reminds of people who work on trying to prove programs correct
08:44:20 <basti_> this would not be done by testing
08:44:59 <kowey> well no, but it's the idea of giving a spec of what your code should do
08:45:14 <kowey> and it pushes bits of spec around until things look not wrong
08:45:38 <skew> I'm not sure how easy it is to use QuickCheck on things that are too big to prove by hand
08:46:15 <kowey> well... i mostly want to check stuff that's easy to get subtly wrong
08:46:21 <kowey> like logic variable unification
08:46:32 <basti_> you mean, like, proofchecking? :)
08:46:56 <skew> but I think even if you are proving your code it can still help by being something automated that catches bugs in your proof, or changes to code
08:47:11 <kowey> oh nononno....
08:47:13 <skew> I don't know of any tools to do the same thing with actual proofs of Haskell code
08:47:16 <kowey> certainly not going to try to prove my code
08:47:21 <kowey> don't feel up to that
08:47:31 <kowey> testing is the poor man's proving :-)
08:47:32 <skew> but I would like to.
08:47:45 <basti_> skew: coq?
08:48:10 <basti_> we can talk about this when im back from shopping
08:48:55 <skew> basti_: okay, I'll leave some questions
08:49:14 <skew> has anybody used this as part of their everyday coding?
09:04:28 <kowey> bye, #haskell, and thanks
09:36:19 <basti_> back
09:36:25 <basti_> so skew, any questions about coq?
09:54:15 <basti_> hmm i'm giving up... what would call/cc's sourcecode look like? i didnt find it
09:55:56 <basti_> i read that self application would be it's fixpoint
09:56:04 <basti_> but i dont know how to turn that into something useful
09:57:08 <goron_> basti_: call/cc's? What do you mean? I do understand the self-application part and fixpoint part though.
09:57:42 <basti_> "call/cc" is a common name for the construct "call with current continuation"
09:57:47 <basti_> it would mean:
09:58:42 <basti_> "call my first parameter with one parameter, and if a value is applied to it, return it immedately from this call"
09:59:09 <basti_> its somewhat similar to "try/catch" or "goto" (where call/cc would mark a "label" and the application inside it would be the goto)
09:59:47 <basti_> the fixpoint idea would be that (ccc ... (ccc ccc)) = ccc
10:00:00 <basti_> with ... being as many subsequent ccc applications as you want
10:00:10 <basti_> i don't have a clue how to turn that into a definition though
10:00:30 <goron_> basti_: You mean a Haskell def.?
10:00:35 <basti_> yes.
10:00:46 <basti_> or even a scheme or lisp definition. or one in lambda calculus
10:00:54 <goron_> Control.Monad.fix?
10:01:06 <basti_> i mean even shapr doesn't understand this, but i wondered if i would.
10:01:06 <basti_> ;)
10:01:51 <basti_> hum.
10:01:54 <goron_> My browser is broken(I am rebuilding my system), so I don't have a lot of resources to look (excpet for links ;) ).
10:02:52 <basti_> isnt monad.fix just a monad with the computation happening in one type?
10:03:23 <Heffalump> @type Control.Monad.fix
10:03:28 <lambdabot> bzzt
10:03:40 <basti_> i think its called MonadFix?
10:03:51 <basti_> @type Control.Monad.MonadFix
10:03:53 <lambdabot> bzzt
10:03:53 <goron_> API changed?
10:04:12 <Igloo> @type Control.Monad.Fix.fix
10:04:13 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
10:04:18 <basti_> ohh i found a definition
10:04:22 <basti_> http://www.norvig.com/paip/interp3.lisp
10:04:25 <basti_> at the very bottom
10:14:15 * basti_ ties a knot in his brain trying to figure out call/cc
10:17:09 * goron_ always gets a "what's the point"-feeling when reading programming language papers. 
10:17:45 <SyntaxNinja> @pointless programming language papers
10:17:47 <lambdabot> programming language papers
10:17:50 * SyntaxNinja nods
10:20:36 <sbeyer> programming language toilet papers? ;)
10:24:07 <Arsilan> Vi ses haskell gutter
10:38:55 <TheHunter> basti_, there's a callCC implementation in the libs.
10:39:00 <TheHunter> @type Control.Monad.Cont.callCC
10:39:02 <lambdabot> Control.Monad.Cont.callCC :: forall (m :: * -> *) a b.
10:39:02 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
10:39:02 <lambdabot>           ((a -> m b) -> m a) -> m a
10:39:35 <basti_> ahhhhh.
10:39:37 <basti_> thanks.
10:40:29 <TheHunter> well, perhaps it should be callCC :: ((forall b. a -> m b) -> m a) -> m a
10:40:39 <basti_> umph.
10:41:12 <TheHunter> that's exactly the thing sml is working around with its throw stuff.
10:41:28 <TheHunter> btw, if you want to play with call/cc, i recommend sml.
10:42:01 <TheHunter> (though you could also use my reflection library, or do it in monadic style with Control.Monad.Cont)
10:42:52 <basti_> i just wanted to understand the internal workings
10:43:48 <TheHunter> @libsrc Control.Monad.Cont
10:43:49 <lambdabot> Unknown command, try @listcommands.
10:43:49 <SyntaxNinja> Lemmih: hey
10:43:59 <basti_> before i do anything with it.
10:44:48 <TheHunter> i think playing with it is a nice (the only?) way to understand it.
10:45:20 <basti_> heheh
10:45:20 <TheHunter> for example, you can try to implement a (sml) function mapCont : (a -> b) -> Cont b -> Cont a
10:45:22 <basti_> i know what it does
10:45:42 <basti_> from scheme... but i never got around to look under the hood
10:48:30 <raver> hi
10:48:42 <SyntaxNinja> hi raver
10:48:54 <xerox> TheHunter there it is a @libsrc command ?!
10:49:11 <TheHunter> there'll soon be.
10:49:45 * xerox dances
10:50:16 <TheHunter> not today, though, gotta go.
10:50:36 <xerox> Ooh-kay :-)
11:20:32 <basti_> hmm does anyone have a usb modem running under linux?
11:25:09 <goron> basti_: Yes, but not me ;)
11:25:43 * basti_ sighs
11:25:56 <basti_> any hints on which brands are favourable?
11:28:16 <goron> I think taking an usb modem is a waste of your time (especially on open-source systems (unless there are open-source drivers (included in the standard kernel of your distro.))
11:28:54 <Corion> I've found some old code that says foreign import ccall "_getpid" unsafe getProcessID :: IO Int -- but GHC doesn't like it:Warning: foreign declaration uses deprecated non-standard syntax - how do I silence it/fix the notation?
11:29:09 <basti_> i see.
11:29:55 <basti_> i never was looking, a friend was asking.
11:30:11 * basti_ didnt use a modem for years now
11:31:00 <lightstep> Corion, `unsafe' should be before the name, perhaps?
11:31:40 <Corion> No, that gives me a plain parse error now :)
11:37:50 <lightstep> i assume you have -fffi
11:39:02 <Corion> lightstep: Yeah, I have it working Just now with foreign import stdcall "_getpid" getProcessID :: IO Int
12:25:18 <goron> basti_: If you don't use a modem. Then what do you use to irc?
12:27:00 <xerox> Why getpid should be IO Int instead of Int?
12:27:23 <keverets> because it depends on the current state of the system?
12:27:26 <lightstep> goron, http://www.faqs.org/rfcs/rfc1149.html
12:28:13 <basti_> goron: DSL. Well strictly spoken there's a modem too, but it's out of reach and my PC only needs a NIC
12:28:43 <lightstep> xerox, it's not a constant
12:28:59 <xerox> lightstep, isn't it for a given program?
12:29:11 <goron> basti_: I am on DSL to. And stricly I now connect to a router, (but that connects to a modem).
12:29:14 <mflux> xerox, you could think non-io-integers could be decided at compile time
12:29:17 <goron> er. too
12:29:23 <basti_> yes i know.
12:29:46 <basti_> i was talking like, ATDT
12:29:58 <CosmicRay> someone was asking about cvs conversion in here earlier?
12:30:18 <CosmicRay> it is true that it took a long time to convert fptools, but that was mostly due to tailor and cvs, not due to darcs
12:30:45 <CosmicRay> arch2darcs, for instance, can usually commit several changesets per second -- rather than several seconds per changeset that tailor+cvs requires
12:30:49 <CosmicRay> tailor+svn also is faster
12:31:00 <CosmicRay> abut the same speed as arch2darcs, or almost there
12:32:25 <earthy> +++ATH0
12:32:31 <CosmicRay> nice try
12:32:47 <earthy> especially fun as payload for ping packets :P
12:32:56 <CosmicRay> heh
12:33:01 <goron> lightstep: A lot of people on /. use this technology(err. biology) you know. :p
12:33:06 <CosmicRay> but it doesn't usually work over PPP though
12:33:23 <CosmicRay> last I knew it to work was on some very old dumb bbs chat software
12:33:28 <earthy> true enough, due to Van Jacobsen compression
12:33:41 <earthy> but, in ping packets it did stand a chance
12:33:48 <earthy> and I've seen people drop because of it :)
12:33:57 <CosmicRay> well, and the fact that most modems require a delay before those characters are sent, and there is *always* data before them due to ip headers
12:34:05 <xerox> It happened to me years ago
12:34:15 <CosmicRay> and most ISPs don't use oldish analogue AT-command-set modems anymore anyway
13:07:41 <JJore> Hi all. I'm trying to compile GHC for use on my Sparc running NetBSD. ATM, I'm following the directions for doing the compilation on my SuSE linux machine.
13:08:50 <JJore> I get up to the `cd ghc && make boot' and fail with ... wait, re-running `make boot' lets it go farther. Dang. Sorry for bothering.
13:16:46 <basti_> JJore: no harm done :)
13:33:32 <JJore> So now I'm getting linking errors during `cd libaries ; make boot' saying RTLD_NEXT is undeclared. That is, I'm building for sparc-unknown-netbsd on i386-unknown-linux. I've followed the steps in the Porting docs exactly so far.
13:34:43 <JJore> Oh I'm sorry, that's not a linking error. It can't be found in any includes.
13:37:01 <bourbaki> moin
13:58:29 <pesco> Hi #haskell!
13:58:44 <sbeyer> hi pesco ;p
13:58:56 <pesco> Hello sbeyer, what's up?
14:01:44 <sbeyer> my thumbs ;)
14:04:24 <xerox> Goodnight folks.
14:18:36 <SyntaxNinja> quiet today
14:21:05 <mwotton> a little ... too quiet.
14:31:59 <diotalevi> So I'm reading the porting docs and it says I shouldn't worry if it dies while making RTS. Well that happened but then it expected RTS to create the HC bundle at the end.
15:26:23 <Lemmih> SyntaxNinja: Yo.
15:30:49 * Lemmih yarns and jumps out of bed.
15:31:11 <StoneAway> is there a different tutorial than the one at haskell.org ?
15:38:59 <TFK> StoneAway, yeah, a bunch.
15:39:41 <TFK> For example, http://www.isi.edu/~hdaume/htut/tutorial.pdf <--- also avaliable in PS and another obscure format.
15:41:23 * StoneAway tries that one
15:41:36 <StoneAway> because frankly i don't want to wade through ten pages of it telling me what everything is about
15:41:40 <StoneAway> i just want the syntax and then to go
15:45:04 <Lemmih> Do you have experience with functional programming?
15:45:19 <StoneAway> mild, yes
15:45:25 <StoneAway> that doesn't really matter
15:45:30 <StoneAway> functional evaluation isn't rocket science
15:45:44 <StoneAway> i mean, technically c++ templates are a functional language
15:45:49 <StoneAway> hence the alexandrescu techniques
15:46:25 <Oejet> That's the spirit!
15:46:31 <jaap> Hmm... if you realy just want syntax you can read the "Tour of the Haskell Syntax"
15:46:32 <jaap> http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html
15:46:39 <StoneAway> that's probably what i need, thank you
15:46:47 <StoneAway> all i want is enough haskell to be able to read this algorithm
15:46:50 <StoneAway> then i'll be fine
15:46:58 <Lemmih> Still, many newbies are taken by surprise when they realize that everything is immutable.
15:47:11 <StoneAway> immutable - constant / final ?
15:47:44 <jaap> Immutable to the extent that there is no such thing as C's = operator or Pascal's := operator.
15:47:56 <jaap> Poof, just doesn't exist.
15:48:00 <StoneAway> so, yes, constant.
15:48:11 <StoneAway> meh, that's a logical upshot of there being only one evaluation ever.
15:48:21 <StoneAway> frankly i'm not sure how you could have variables in a language like that.
15:48:36 * sbeyer has (basic) experience in Lisp and the first "Basics of Programming 2 - Functional Programming in Haskell" lecture in university told me Haskell syntax ;)
15:48:37 <StoneAway> though maybe i'm missing something.
15:48:40 <Oejet> Magic. :-)
15:48:58 <Lemmih> It's like math. In math you also have immutable variables.
15:49:51 <StoneAway> Lemmih: they're called "constants."
15:50:10 <Lemmih> No, I'm talking about variables.
15:50:11 <StoneAway> unless i'm missing something?
15:50:15 <StoneAway> and?
15:50:21 <monochrom> You are missing something.
15:50:23 <sbeyer> constants and variables aren't the same ;)
15:50:27 <StoneAway> what about a constant isn't an unchanging variable, then?
15:50:48 <StoneAway> i mean, if i'm full of crap i'd love to know
15:50:49 <monochrom> But I don't think it's productive to philosophize on this.
15:50:50 <Lemmih> Consider the function 'f(x)=x+1'. Here x is not a constant, it's a variable.
15:51:05 <StoneAway> monochrom: there is no philosophy on definitions.
15:51:20 <monochrom> I just want to offer my http://www.cs.utoronto.ca/~trebla/fp/ and hope it helps.
15:51:34 <StoneAway> Lemmih: ... okay, i still don't understand how a constant is something other than a non-changing variable.
15:51:48 * StoneAway should probably point out that Knuth calls them constants, even when writing math.
15:52:09 <pesco> The question is your frame of reference.
15:52:18 <Lemmih> A constant always has the same value. In my example, 'x' can vary.
15:52:37 <StoneAway> oy
15:52:40 <StoneAway> pesco: okay
15:52:50 <StoneAway> pesco: do you at least understand why i'm saying what i'm saying?
15:53:04 <pesco> Yes.
15:53:07 <StoneAway> okay, good enough
15:53:17 <pesco> But I wouldn't say it that way, either.
15:53:21 <StoneAway> well
15:53:26 <StoneAway> variables don't nessecarily vary
15:53:30 <StoneAway> that's what mutability is
15:53:57 <sbeyer> StoneAway, Pi is a constant. You will never change Pi. The function f takes the variable x. x can be more than Pi. It can't vary *in* the function, it's immutable, but the parameter may vary.
15:54:11 <StoneAway> sbeyer: yeah, so that supports me, though
15:54:16 <StoneAway> sbeyer: that's pretty much what i said
15:54:34 <StoneAway> sbeyer: a constant is a special case of a variable - a symbolic name for a value - in that its value may not change
15:54:35 <sbeyer> that's ok ;)
15:54:35 <pesco> I agree with monochrome, that this is pretty pointless to philosophisize about.
15:54:45 <StoneAway> meh
15:54:47 <sbeyer> pesco, ack
15:54:47 <StoneAway> okay, back to reading
15:54:58 <StoneAway> but it makes a huge difference in classical languages to know that constants are variables :(
15:55:16 <StoneAway> especially imperative and object-oriented imperative languages
15:55:27 <StoneAway> but also procedural and declarative languages
15:55:30 <wilx> Humdydum..
15:55:49 <pesco> Although that use of terminology is utterly confusining and kind of begging the question.
15:55:55 <mr-onionhead> hello all.  I'm trying to build ghc (6.4) for the first time on mac os (10.3) using ghc 6.2 to boot strap.  The build dies with "/tmp/ghc18478.hc:3:17: Stg.h: No such file or directory".  Any ideas about what's going on?
15:56:11 <pesco> I need to go, time for bed.
15:58:06 <sbeyer> StoneAway, when I first saw Haskell syntax, I hated it ;) (and at the moment I can't decide, if I like it or not) ;)
15:58:20 * StoneAway can't find a tutorial on haskell. "They're all either borderline EBNF syntaxes or attempts to explain functional programming."
15:58:35 <monochrom> have you tried mine?
15:58:40 <StoneAway> monochrom: yes.  note the title.
15:58:45 <sbeyer> StoneAway, take a look at some university papers *g*
15:59:00 <monochrom> it contains both functional programming and haskell.
15:59:07 <StoneAway> i don't want functional programming
15:59:10 <StoneAway> and it doesn't explain haskell at all
15:59:14 <StoneAway> it explains functional programming
15:59:19 <StoneAway> i understand functional programming
15:59:20 <monochrom> It explains Haskell dammit.
15:59:28 <_metaperl> StoneAway, I recommend the Thompson book
15:59:43 <_metaperl> there is Yet Another Haskell Tutorial for free
15:59:47 <StoneAway> _meta: i just want to understand enough haskell to decipher one algorithm
15:59:56 <_metaperl> then read YAHT
16:00:00 <StoneAway> okay, where is it?
16:00:00 <sbeyer> StoneAway, well, to know basic Haskell syntax helps to understand Prelude.hs and this helps to understand Haskell, I think ;)
16:00:11 <StoneAway> sbeyer: an EBNF is not what to learn from.
16:00:22 <sbeyer> StoneAway, Basic Haskell syntax is, imo, functionname parameters = functiondefinition ;)
16:00:25 <Lemmih> StoneAway: Have you seen http://www.haskell.org/complex/ ?
16:00:33 <StoneAway> lemmih: no; back in a sec.
16:00:48 <StoneAway> god
16:00:51 <StoneAway> this is the same thing
16:00:59 <jaap> StoneAway: then you may have to end up reading a slightly longer, more expository text; I think the one on haskell.org really isn't *that* verbose, you can can skip over the bits you know already
16:01:01 <StoneAway> it starts with nine pages of why i need to live my life in functional languages
16:01:03 <sbeyer> StoneAway, and including guards: functionname parameters | condition = funcdefinition
16:01:25 <StoneAway> scheme has this problem too
16:01:33 <StoneAway> the scheme community does not write for programmers
16:01:38 <StoneAway> they write for novices and implementers
16:01:43 <sbeyer> .o( knowing this, someone with a bit of functional experience can easily go through Prelude.hs )
16:01:51 <jaap> StoneAway: ditto, read Teach Yourself Scheme in Fixnum Hours and skip over the bits you know
16:02:05 <StoneAway> jaap: your last name wouldn't be suter, would it?
16:02:18 <jaap> StoneAway: no, it's not
16:02:25 <StoneAway> okay, nevermind then
16:02:41 <StoneAway> i mean, you can break down the basics of c and c++ in like two pages
16:03:04 <monochrom> It is a good idea to write for novices and implementers, and forget about programmers.
16:03:23 <StoneAway> monochrom: hardly.
16:03:39 <StoneAway> monochrom: that way it's almost impossible for an existing programmer to learn the language.
16:03:45 <StoneAway> that's the worst thing you can possibly do.
16:03:47 <monochrom> Programmers have made up their mind on their favourite languages.  Why waste time convincing them?
16:03:49 <StoneAway> uh
16:03:51 * jaap will take a shower now ;-)
16:03:51 <StoneAway> not real programmers
16:04:03 <StoneAway> if that were the case i wouldn't be in here looking for a non-sucking tutorial, would i?
16:04:11 <monochrom> Instead, win novices for future generations, and win implementers for implementations.
16:04:16 <StoneAway> feh
16:04:21 <StoneAway> that's ridiculous
16:04:33 <StoneAway> you're casting away an entire generation of people because you expect them to all pan you
16:04:36 <StoneAway> that doesn't make any sense
16:04:37 <monochrom> I have great hope in our kids.
16:04:45 <StoneAway> well
16:04:47 * sbeyer not ;)
16:04:53 <StoneAway> maybe you should try reaching out to the people which want to learn your language
16:04:58 <StoneAway> but can't because it's so incredibly painful
16:05:01 <monochrom> Adults prove to be stubborn, over and over again.
16:05:05 <StoneAway> no
16:05:10 <StoneAway> nevermind
16:05:19 <StoneAway> you're telling me i can't learn your language because i already know others
16:05:22 <StoneAway> and because I'm stubborn
16:05:24 <StoneAway> whatever
16:05:34 <astrolabe> Is it really so bad stoneaway?
16:05:38 <StoneAway> astrolabe: yes
16:05:52 <StoneAway> astrolabe: almost any other language has one tutorial out there you don't have to be an idiot to tolerate
16:06:00 <astrolabe> To me the tutorials seem pretty short
16:06:15 <StoneAway> they're not about haskell
16:06:19 <StoneAway> they're about functional programming
16:06:23 <StoneAway> i don't need to learn functional programming
16:06:28 <StoneAway> i already know functional programming
16:06:29 <monochrom> If you are not stubborn, you would not mind the existing tutorials, even though they are somewhat not quite written for you.
16:06:41 <StoneAway> monochrom: goodbye
16:06:51 * sbeyer didn't read ANY Haskell tutorial
16:06:55 <erg255> stoneaway: why dont you write your own tutorial then?
16:07:06 <sbeyer> as I said: basic syntax and walk through Prelude.hs and examples ;)
16:07:53 <monochrom> I learned ocaml from the out-of-the-box ocaml tutorial.  It is written for functional programming novices.  I don't feel belittled.
16:10:25 <Heffalump> StoneAway: did you read the Gentle Introduction?
16:14:50 * Lemmih ponders why StoneAway doesn't just skip the first couple of pages if they annoy him so much.
16:15:16 <SyntaxNinja> StoneAway: if you are so hard core in FP and you just want to "learn the language" then just read the haskell report.
16:15:40 <monochrom> Ego.  "I want this."  "I don't want that."  "Intolerable."
16:16:09 <sbeyer> oh yes, the Haskell report is nice as a reference
16:16:09 <Heffalump> I want you all to bow down and worship my greatness.
16:16:20 <TFK> Heh. I think I told once about a guy who replied to my question, "what is functional programming", with a "you know map()? Well, that's what FP is."
16:16:35 <Heffalump> sbeyer: that's probably what he said was verging on EBNF
16:16:39 <Pseudonym> Clearly a point-free programmer
16:16:46 <wilx> :)
16:16:54 <Pseudonym> Though a true point-free programmer would point out that it's also fold.
16:17:09 <Heffalump> You're not all bowing down and worshipping my greatness. You all suck. Just think of the opportunity you're missing out on.
16:17:24 <lambdabot> I bow down to no human.
16:18:16 <monochrom> I have a conjecture.  StoneAway is deciphering the algorithm at http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs
16:18:57 <monochrom> or Shuffle.hs
16:19:09 <lambdabot> (well, except Heffalump, of course)
16:19:27 <monochrom> I make this conjecture because I authored those algorithms!
16:19:30 <TFK> Is lambdabot powered by a midget?
16:19:39 <lambdabot> (i do that to lull him into a false sense of security)
16:19:55 <TFK> Like those gnomes that hide in TV and make it work by magic! :O
16:20:26 <lambdabot> I bow before your greatness, Heffalump! (snicker, snicker)
16:32:31 <StoneAway> Heffalump: sorry it took so long to answer; a client showed up
16:32:36 <StoneAway> Gowilla: yes, i began to
16:32:53 <StoneAway> Gowilla: i can't really stomach it; it's wasting tremendous amounts of time trying to explain things like side effects
16:33:12 <Gowilla> oh well, your loss.
16:33:29 <StoneAway> yeah, i guess
16:33:35 <Lemmih> You can skip what you already understand.
16:33:51 * lambdabot bows down to Heffalump
16:33:52 * StoneAway thinks he's just going to write a real haskell tutorial
16:33:59 <StoneAway> there's no reason for anyone else to go through what i'm going through
16:34:01 <StoneAway> this is nonsense
16:34:09 <Gowilla> feel free.
16:34:19 <Gowilla> Though you're the first person to come up with that complaint.
16:34:27 <StoneAway> Gowilla: not in my experience.
16:34:40 <StoneAway> though, it could be that i just haven't found the right tutorial
16:34:44 <Gowilla> that I've seen, and I read this channel and the mailing list.
16:35:07 <StoneAway> Heffalump: efnet #c++ is fairly vocal about the topic
16:35:24 <Heffalump> about Haskell having inadequate tutorials?
16:35:31 <Pseudonym> efnet?  vocal?  You're kidding me.
16:35:34 <StoneAway> Heffalump: you'll find that the people already familiar with language X don't read tutorials for language X and therefore would not complain about said tutorials even were there a legitimate reason to do so
16:35:50 <Heffalump> we get a lot of people here and on the mailing list who are new to Haskell.
16:35:59 * StoneAway shrugs
16:36:03 <Pseudonym> You know, I'm yet to see a good C++ tutorial that isn't several volumes in size, too.
16:36:14 <StoneAway> Pseudonym: then you haven't looked terribly hard.
16:36:18 <StoneAway> they're all over the place.
16:36:23 * Lemmih still doesn't get what's wrong with all the tutorials.
16:36:24 <Pseudonym> Such as?
16:36:24 <StoneAway> hell, MSDN alone has like a dozen.
16:36:44 <Heffalump> Quite frankly, someone who is as apparently knowledgeable as you claim to be could easily skim read one of many tutorials and find the important bits. You just seem to lack patience and have ridiculous standards.
16:36:50 <Pseudonym> I bet they're not "good".
16:36:58 <StoneAway> Heffalump: there's nothing ridiculous about wanting a quick overview of a language.
16:37:14 <Heffalump> read the report, then.
16:37:17 <StoneAway> i'm sorry that you think it's unreasonable for me to not want to have to read a functional programming tutorial to get haskell syntax.
16:37:28 <Pseudonym> Hell, I program in C++ for a living, I had a desk next to someone on the standardisation committee, I use almost all of Boost, I've read Andrescu _and_ Generative Programming, and I don't understand C++ yet. :-)
16:37:35 <Heffalump> the report specifies Haskell syntax very clearly and concisely.
16:37:59 <StoneAway> Heffalump: is that the thing that looks like ebnf and has examples with no grounding in reality which use single letter variables?
16:38:05 <StoneAway> that sounds like using the standard to learn c++
16:38:18 <Heffalump> the report is several times shorter than the C++ standard.
16:38:28 <StoneAway> what i'm looking for would be about a page and a half.
16:38:36 <Pseudonym> By "several", Heffalump means "many".
16:38:37 <Heffalump> I can't remember if it looks like EBNF or not, but if you want a brief introduction to the syntax, that's the place to look.
16:38:40 <StoneAway> for c++ what i'm looking for would be about two pages.
16:39:07 <Heffalump> a Haskell file looks like
16:39:09 <Heffalump> module Foo where
16:39:11 <Heffalump> import Bar
16:39:12 <Heffalump> import Baz
16:39:19 <Heffalump> f x = g (x+x)
16:39:24 * Pseudonym has a theory that you never truly understand C++ until you've written a book about it, and sometimes not even then
16:39:29 <Heffalump> g y = y+z
16:39:33 <Heffalump>        where z = 2*y
16:39:36 <StoneAway> Pseudonym: nobody's asking for a true and deep understanding of a language
16:39:41 <Heffalump> there you go, basic syntax.
16:39:47 <StoneAway> Heffalump: great.  that's most of what i needed.
16:39:49 <Heffalump> anything more complicated, go and read the report.
16:39:51 <StoneAway> what does guard do?
16:39:58 <StoneAway> is that like contracts?
16:39:59 <Heffalump> h y | y==1 = 3
16:40:00 <StoneAway> that's what it looks like
16:40:10 <Heffalump> you wanted to know syntax, not semantics.
16:40:13 <Pseudonym> StoneAway: If you meant the "guard" function, you need to read the monad tutorial.
16:40:16 <Heffalump> you can't have everything :-)
16:40:25 <StoneAway> no i didn't
16:40:37 <StoneAway> oh, monads?  like to avoid side effects?
16:40:42 <StoneAway> okay, word
16:40:44 <Heffalump> (guards like that limit the applicability of a clause of a definition, so that particular clause will only match if y==1)
16:40:56 <StoneAway> aha, so they're asserted contracts?
16:41:07 <Heffalump> if it fails, you fall through to the next clause
16:41:08 <Pseudonym> StoneAway: It sounds like what you need isn't a tutorial, but a set of simple example complete programs.
16:41:13 <Heffalump> so it's not really an assertion.
16:41:16 <StoneAway> Pseudonym: i don't even need that much
16:41:26 <StoneAway> Pseudonym: i just need a quick list of the simple tools of the language
16:41:30 <Heffalump> you could read "Evolution of a Haskell programme"
16:41:38 <Heffalump> r
16:41:44 <StoneAway> i don't want to read an entire book to understand a single algorithm
16:41:45 <Cale> StoneAway: http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html has a bunch of the syntax
16:41:45 <Pseudonym> StoneAway: Ignore Heffalump's comment there. :-)
16:41:50 <Heffalump> hey!
16:41:54 <Heffalump> I was serious.
16:41:55 <StoneAway> cale: will look, back in a sec
16:42:12 <StoneAway> yeah, that's the ebnf-looking one
16:42:17 <Pseudonym> Really.  You want to explain bananas and lenses?
16:42:28 <Heffalump> that's not EBNF!
16:42:39 <Heffalump> well, it has some EBNF.
16:42:43 <StoneAway> it looks like the kind of document you use beckhaus-naur for
16:42:48 <StoneAway> it's a syntax document
16:42:48 <Heffalump> But since it introduces by example, I don't see what problem you have with it.
16:42:49 <Cale> StoneAway: It's just showing examples of syntax, which is what you want
16:42:52 <StoneAway> i do not want a syntax document
16:43:01 <StoneAway> how many times do i have to say i do not want a syntax document
16:43:06 <Cale> the EBNF for Haskell would be more hairy
16:43:17 <StoneAway> heffalump typed out half of what i needed
16:43:22 <StoneAway> i don't grasp what's so hard about this
16:43:41 <StoneAway> it's like none of you have ever tried to get an existing programmer up to speed in haskell before
16:43:44 <Heffalump> if you write one, someone will probably put it somewhere useful
16:43:49 <StoneAway> well, that's what i'm going to do
16:43:51 * Heffalump has done that many times.
16:44:03 <StoneAway> and then in anger i'm going to put this language down for probably quite some time
16:44:31 <Pseudonym> StoneAway: Most people actually learn Haskell by a form of pseudo-mentoring.
16:44:40 <StoneAway> well, that shouldn't be.
16:44:41 <Pseudonym> You pick a project, try doing it, and ask questions as you go.
16:44:44 <Heffalump> usually I do it by showing them a program that does something they want doing and letting them use language references/ask me to find out about it.
16:45:02 <StoneAway> Heffalump: so, wait.  a guard is just an asserted branch?
16:45:14 <Pseudonym> StoneAway: Actually, it's a better way.  Imagine if you learned C++ (having known C).  You really, REALLY don't want to get into any bad C habits, right?
16:45:24 <Heffalump> Haskell has a disproportionate set of language features that have no analogue in any other mainstream language. So just a syntax introduction isn't really good enough anyway.
16:45:33 <StoneAway> Pseudonym: i strongly disagree with the underlying logic of that analogy.
16:45:34 <Pseudonym> You want to learn the idiomatic C++ way to do things, even though the C version works.
16:45:37 <Heffalump> (Type classes, monad notation, list comprehensions unless you're coming from Python)
16:45:39 <StoneAway> no, i don't.
16:45:41 <StoneAway> that's the problem.
16:45:44 <StoneAway> i don't need the idioms.
16:45:48 <Heffalump> StoneAway: I don't know what you mean by an asserted branch.
16:45:56 <Pseudonym> Actually, it's pretty close.  A lot of people want to program Haskell in an imperative way.
16:45:57 <StoneAway> Heffalump: basically, compile time if()
16:46:04 <Heffalump> I would view it more as a cascade of C/java if-then-else statements
16:46:06 <Heffalump> it's runtime.
16:46:17 <StoneAway> so then what's the practical difference between if and guard?
16:46:23 <Heffalump> syntax
16:46:29 <Heffalump> guards interact with pattern matching nicely
16:46:36 <StoneAway> oh.
16:46:38 <Pseudonym> It's a personal opinion, of course.  But I find that you grok Haskell much better if you ask for feedback on your code.
16:46:39 <StoneAway> okay, that makes sense.
16:46:47 <Heffalump> f (x:xs) = 5
16:46:49 <Heffalump> f [] = 3
16:46:59 <StoneAway> Pseudonym: maybe you missed that i have no intention of writing any haskell.
16:47:03 <Heffalump> is a function that returns 5 for non-empty lists and 3 for empty lists
16:47:09 <Heffalump> f (x:xs) | x>2 = 5
16:47:12 <Heffalump> f [] = 3
16:47:15 <Pseudonym> StoneAway: Possibly, yes.
16:47:25 <Heffalump> is a function that returns 5 for non-empty lists header by a number greater than 2, and 3 for other lists
16:47:28 <Pseudonym> I'm the sort of person who learns by doing.  You might not be,
16:47:32 <StoneAway> Pseudonym: i just want to understand a two page stretch of existing code.  that's why i don't care about idioms.
16:47:37 <Pseudonym> Everyone is different.
16:47:41 * Pseudonym nods
16:47:44 <Heffalump> you couldn't write that with if-then-else without duplicating the 3
16:47:53 <SyntaxNinja> StoneAway: have you looked at the haskell report?
16:47:55 <StoneAway> Heffalump: aha.
16:48:05 <StoneAway> SyntaxNinja: i'm not sure.  i've looked at a dozen or so things.
16:48:24 <SyntaxNinja> StoneAway: it explains the language enough to implement it. it's pretty hard core if that's what you're looking for :)
16:48:37 <StoneAway> no
16:48:42 <StoneAway> god i don't want anything like that
16:48:44 <StoneAway> :(
16:48:53 <StoneAway> why doesn't anyone understand what i want?
16:48:54 <StoneAway> it's so simple
16:49:01 <Heffalump> we understand what you want.
16:49:01 <StoneAway> hold on, i'll write one for c++
16:49:06 <Lemmih> You want a one-to-one mapping of Haskell to C++, right?
16:49:08 <StoneAway> Heffalump: you seem to be the only one
16:49:09 <StoneAway> Lemmih: NO
16:49:13 <StoneAway> jesus
16:49:25 <Cale> http://www.haskell.org/hawiki/HaskellDemo ?
16:49:26 <Heffalump> I just think that you should stop whinging and extract the relevant information from any one of the number of sources we've already pointed you at.
16:49:33 <Pseudonym> No, I get it.  StoneAway wants to understand a specific Haskell program without understanding Haskell in general.
16:49:45 <StoneAway> just an algorithm, actually
16:49:47 <Heffalump> he wants a list of examples of code like I showed, with commentary.
16:49:51 <Pseudonym> Er... I didn't word that well.
16:49:51 <SyntaxNinja> I get it too, actually.
16:49:55 <StoneAway> Heffalump: ... no
16:49:55 <Heffalump> covering all major language features.
16:50:09 <StoneAway> well it seems that Pseudonym gets it
16:50:14 <Pseudonym> Can we see what you're trying to understand?
16:50:24 <Pseudonym> Maybe if you asked questions about it, we could answer them.
16:50:26 <SyntaxNinja> StoneAway: is there a tutorial for any language that's like what you're talking about?
16:50:26 <sbeyer> hm ;)
16:50:31 <StoneAway> Pseudonym: yeah, but it's in german :(  http://rafb.net/paste/results/Ia8I6r49.html
16:50:36 <sbeyer> have fun/success, I go to bed ;P
16:50:37 <StoneAway> SyntaxNinja: dozens.
16:50:46 <StoneAway> SyntaxNinja: start with the first five pages of the php manual.
16:51:04 <StoneAway> SyntaxNinja: then read the MSDN brief overview for c, c++, c#, java, f# or forth
16:51:05 * sbeyer is German ;)
16:51:16 <SyntaxNinja> StoneAway: URLs please
16:51:21 <Pseudonym> OK, I'm looking at this.
16:51:23 <StoneAway> SyntaxNinja: http://php.net/manual/en/
16:51:25 <Pseudonym> What don't you understand?
16:51:34 <Pseudonym> Ask specific questions and get specific answers.
16:51:51 <StoneAway> Pseudonym: pretty much any of it.  the variables are all very badly named and i don't yet grasp the flow or some of the operators, so i'm having a hard time unravelling it at all.
16:52:12 <StoneAway> Pseudonym: it's a pathfinding algorithm for a hex board to find closed loops surrounding at least one cell, said cell's contents immaterial.
16:52:26 <StoneAway> Pseudonym: its author claims it's significantly faster than my modification of Archimedes' maze algorithm
16:52:29 <SyntaxNinja> StoneAway: chapter 2?
16:52:31 <StoneAway> Pseudonym: AFAICT that's not possible
16:52:32 <Pseudonym> OK.
16:52:41 <StoneAway> Pseudonym: so i'm trying to figure out what exactly it's acutally doing
16:52:45 <StoneAway> SyntaxNinja: sounds right
16:52:48 <bourbaki> moin
16:52:50 <Pseudonym> Without going into the code, it is in fact possible.
16:52:59 <Pseudonym> Perhaps.
16:53:06 <Pseudonym> (I meant to say "it might be possible".)
16:53:13 <bourbaki> hehe
16:53:19 <StoneAway> the thing i think isn't possible is that his algorithm has a lower significant complexity than mine
16:53:22 <Pseudonym> Something you should know about Haskell, if you don't already, is that it's a lazy language.
16:53:28 <StoneAway> doesn't matter
16:53:30 <SyntaxNinja> StoneAway: I don't see 1-2 pages explaining every major language feature, can you give me a URL for such
16:53:33 <StoneAway> the board isn't runtime constant
16:53:42 <Pseudonym> Which means that you can get dynamic programming for free.
16:54:02 <StoneAway> what haskell calls dynamic programming, other languages call ... ?
16:54:10 <monochrom> dynamic programming
16:54:11 <StoneAway> SyntaxNinja: in a minute, someone's helping me
16:54:14 <Cale> StoneAway: dynamic programming
16:54:16 <Pseudonym> Haskell calls it lazy evaluation.  Other languages call it dynamic programming.
16:54:23 <StoneAway> well
16:54:25 <bourbaki> is there any library in haskell that does network object syncronization?
16:54:35 <StoneAway> c++ programmers use the phrase lazy evaluation.  same thing?
16:54:43 <Pseudonym> It can be, yes.
16:54:45 <StoneAway> okay.
16:54:56 <StoneAway> that's fine; there's no way to lazy evaluate, given the setting for the algorithm.
16:55:05 <StoneAway> besides he said that the algorithmic complexity was lower
16:55:11 <StoneAway> lazy evaluation doesn't affect that
16:55:11 <SyntaxNinja> StoneAway: gotta go. good luck.
16:55:15 <StoneAway> SyntaxNinja thanks
16:55:43 <jaap> dynamic programming is not a term related to Programming Languages as much as to Algorithms; it applies in pretty much any programming language; read a basic algorithms book to learn more about it; I recommend CLRS
16:56:13 <jaap> it is used for exactly that purpose, namely reducing time complexity
16:56:19 <StoneAway> oy
16:56:19 <Pseudonym> Right.
16:56:25 <Pseudonym> But I'm not saying this is how it does it.
16:56:27 <StoneAway> time complexity is not related to algorithmic complexity
16:56:38 <StoneAway> for someone willing to name Cormen LRS, you should know that
16:56:46 <Heffalump> you what?
16:56:55 <StoneAway> shadowcasting is still o(n^3) even if you do half of it beforehand
16:56:56 <Pseudonym> I'm just commenting that it's often easy to implement a dynamic programming algorithm in Haskell where it's tricky or impractical in another language.
16:56:56 <bourbaki> jaap clrs?
16:56:59 <monochrom> What is algorithmic complexity?
16:57:05 <StoneAway> bourbaki: it's arguably the definitive alg book
16:57:11 <StoneAway> bourbaki: http://sc.tri-bit.com/clrs
16:57:38 <StoneAway> oh, caps, sorry
16:57:41 <StoneAway> bourbaki: http://sc.tri-bit.com/CLRS
16:57:51 * StoneAway writes a redirect
16:58:30 <bourbaki> your site?
16:58:33 <StoneAway> yep
16:58:38 <bourbaki> nice
16:58:47 <StoneAway> heh, thanks; i don't really like it so much
16:59:00 <bourbaki> i like the colours ;)
16:59:34 <StoneAway> Pseudonym: so ayway, lazy evaluation - at least what C++ uses that phrase for - isn't what i'm hoping to get out of this alg
16:59:42 <StoneAway> Pseudonym: i just want to know what he's actually doing
17:00:02 <sbeyer> StoneAway, I don't know what it's all about, but the big comment in the beginning says, that it's a simple breadth-first search and that the directions of each reached point is saved
17:00:07 <StoneAway> Pseudonym: and between his alternate language and godawful naming style, i'm having a hard time getting purchase
17:00:13 <StoneAway> what?
17:00:15 <StoneAway> it's a* ?
17:00:25 <StoneAway> of for
17:00:56 <bourbaki> a* is a mixture of breadth and depth first search
17:01:11 <StoneAway> a* can be either
17:01:28 <bourbaki> it all depends on your heuristic
17:01:44 <StoneAway> anyway, a breadth first search won't do the whole task
17:01:50 <StoneAway> it's the loop identification logic i'm interested in
17:01:51 <bourbaki> if it does not take into account the payoff of the next step its just breadth first
17:01:57 <Pseudonym> There's a comment about "the crucial idea" in the header, but I can't make out all the German words.
17:02:03 <bourbaki> occams razor?
17:02:15 <StoneAway> occam's razor doesn't apply when you have no idea what's going on
17:02:25 <bourbaki> you can cut loops
17:02:33 <bourbaki> occams razor is just a concept
17:02:47 <bourbaki> that cuts off paths that hit the same state once again
17:03:00 <StoneAway> ... uh
17:03:07 <sbeyer> ok, I think you get on, have to go to bed ;P
17:03:10 <StoneAway> occam's razor says to eliminate all but the most likely explanation
17:03:12 <Pseudonym> G'day shapr.
17:03:19 <bourbaki> i have a lisp implementation of the paip on my homepage
17:03:25 <blackdog> where's the code for this search?
17:03:27 <shapr> g'day Pseudonym
17:03:30 <sbeyer> .o( bourbaki could translate it, too )
17:03:41 <bourbaki> what can i translate?
17:03:46 <bourbaki> sec let me get the link
17:04:16 <StoneAway> I have to be misreading what bourbaki said
17:04:30 <bourbaki> http://codemages.sourceforge.net/lispcode/a*.lisp
17:05:08 * StoneAway is getting a headache
17:05:16 <StoneAway> <StoneAway> anyway, a breadth first search won't do the whole task
17:05:17 <StoneAway> <StoneAway> it's the loop identification logic i'm interested in
17:05:25 <StoneAway> a* is not the interesting part of this alg
17:05:32 <StoneAway> i could just use boost::graph for that
17:05:35 <bourbaki> the cycle checking part
17:05:36 <StoneAway> or roll my own
17:05:48 <StoneAway> the a* cycle checker fails on havannah boards
17:05:57 <StoneAway> there are special considerations which a* cannot account for
17:05:58 <bourbaki> whats that?
17:06:04 <StoneAway> such as rejecting 0-contained loops
17:06:24 <bourbaki> all there needs to be made sure of is that your heuristic is admissable
17:06:30 <blackdog> StoneAway: afaict, you're trying to read some haskell code and failing. Is the code public? Can I see it?
17:06:34 <bourbaki> that is that it underestimates the real cost
17:06:56 <StoneAway> blackdog: http://rafb.net/paste/results/Ia8I6r49.html
17:07:09 <Pseudonym> bourbaki, could you have a go at translating the second paragraph, the one that starts with "die entscheidende idee ist..."?
17:07:23 <Pseudonym> Since that seems to be what StoneAway is most interested in.
17:07:29 <bourbaki> where on that rafb link?
17:07:33 <Pseudonym> Yeah.
17:07:44 <bourbaki> sec let me read it
17:07:45 <shapr> StoneAway: Are you trying to get #haskell to do your homework for you or something?
17:07:50 <StoneAway> no
17:07:58 <StoneAway> god, why is everyone so angry
17:08:03 <Pseudonym> shapr: Don't throw fuel on the fire.
17:08:03 <shapr> StoneAway: because you are
17:08:19 <Pseudonym> :-)
17:08:23 * shapr flames!
17:08:26 <StoneAway> no, i'm not.  i'm frustrated by a bunch of people answering questions that aren't my question and then calling me stupid or saying i ought to do something that doesn't apply to my problem.
17:08:32 <monochrom> StoneAway is angry at me only.
17:08:40 <Pseudonym> We've already had this argument.  The discussion has only just calmed down to the point that we can actually get something useful done.
17:08:45 <bourbaki> ^what is the prolbem that this code is applied on?
17:08:46 <shapr> I see.
17:09:01 <Heffalump> I don't think you're stupid, I think you're lazy.
17:09:02 <StoneAway> bourbaki: it's the loop evaluator for a haskell board.  http://wikipedia.net/Haskell
17:09:15 <StoneAway> Heffalump: that's stull contemptuous and frustrating.
17:09:21 <bourbaki> whats a board?
17:09:22 <StoneAway> and, for that matter, insulting.
17:09:28 <Pseudonym> shapr: For those who came in late, StoneAway wants to understand an algorithm written in a combination of Haskell and German, without learning either to any degree of fluency.
17:09:28 <StoneAway> bourbaki: a game state.
17:09:29 <bourbaki> what are these coloured stones?
17:09:39 <StoneAway> actually i speak german a tiny bit
17:09:53 <StoneAway> and no, that's not the case
17:09:59 <Pseudonym> I'm oversimplifying.
17:10:01 <bourbaki> i cant right away translate this with not uderstanding what the things mean ;)
17:10:02 <StoneAway> if you'll remember, what i came in here looking for were haskell tutorials
17:10:10 <StoneAway> so to characterize me as lazy is insulting
17:10:13 <Pseudonym> No, I don't remember since I wasn't here at the time.
17:10:19 <Heffalump> well, I find your criticism of the Haskell community offensive and untrue, so we're even.
17:10:19 <StoneAway> bourbaki: http://wikipedia.net/Haskell
17:10:34 <jaap> you've given that link before, but it's broken
17:10:38 <StoneAway> Heffalump: my criticism of the community refers to here, and it's been correct thus far.
17:10:52 <Cale> http://en.wikipedia.org/wiki/Haskell_programming_language ?
17:10:54 <StoneAway> jaap: no, it isn't.  wait five seconds.
17:11:06 <StoneAway> jaap: the reason i don't specify a language is that Germans should get the German version.
17:11:10 <StoneAway> etc.
17:11:10 <shapr> StoneAway: Being angry towards people that you want to learn from rarely helps.
17:11:24 <Heffalump> by implication it's the entire community that hasn't provided a tutorial that you like.
17:11:28 <StoneAway> oy
17:11:30 <Heffalump> anyway, I'm going to bed.
17:11:38 * StoneAway hasn't been angry towards anyone helpful, shapr
17:11:58 <Heffalump> that's clearly not true, since you acknowledged I was being helpful earlier.
17:12:02 <shapr> I read the logs, I disagree.
17:12:12 <shapr> StoneAway: Anyway, be nice, be polite, you'll get lots of help.
17:12:15 <StoneAway> Heffalump: I don't feel that saying "i find what you just said to me as offensive" is my being angry.
17:12:24 <Heffalump> fair enough.
17:12:26 <StoneAway> shapr: thank you for your admonition.  it is taken in stride.
17:12:38 <StoneAway> Heffalump: in fact, i'm biting my tongue as hard as I can.
17:12:38 <Cale> StoneAway: have you looked at "Yet Another Haskell Tutorial"?
17:12:42 <StoneAway> cale: yep.
17:12:42 * Heffalump goes to bed, leaving the channel in the state of peace that Pseudonym claimed it was in before I decided to butt in again.
17:12:54 <erg255> StoneAway: have you tried using babelfish to translate it?
17:13:05 <Cale> StoneAway: you might try reading that and doing the exercises
17:13:07 <StoneAway> erg: yeah.  you should too; the results are very funny and quite useless.
17:13:15 * Heffalump stops going to bed to rotfl at the idea of Babelfished Haskell.
17:13:23 <bourbaki> ok here is the direct translation
17:13:24 <StoneAway> Heffalump: i think he means the german
17:13:35 <bourbaki>  the core idea is that,
17:13:41 <StoneAway> blackdog: did you see my answer earlier?
17:13:45 <Heffalump> yes, but it left me the image of haskell passed through Babelfish, which I think would be even funnier than your usual Babelfish messup.
17:13:51 <StoneAway> Heffalump: mmm.
17:13:54 <bourbaki> only certain constrained paths need to be looked at
17:14:07 <bourbaki>  such that all of these paths that are closed is analogue to a circle with somthing in it
17:14:14 <blackdog> StoneAway: yep. was just looking at the code. my german is not what it could be - i know just enough to apologise for my crappy deutsch
17:14:17 <bourbaki> thats just a direct translation though
17:14:21 <StoneAway> blackdog: heh, me too
17:14:36 <StoneAway> bourbaki: apparently that's not the portion i needed to read, then.  sorry to consume your time in such a fashion.
17:14:51 <bourbaki> no problem
17:15:10 <StoneAway> all i want to know is how he's doing his non-emptiness detection for loops
17:15:11 <Pseudonym> The next paragraph might also be relevant.
17:15:12 <StoneAway> that's it
17:15:13 <bourbaki> do you have a certain problem with a*
17:15:14 <bourbaki> ?
17:15:18 <StoneAway> yeah, it fails
17:15:19 <Pseudonym> "the other idea is..."
17:15:25 <StoneAway> badly
17:15:26 <bourbaki> ok let me read further
17:15:34 <shapr> StoneAway: Do you have all of the source available?
17:15:36 <bourbaki> or and have a look at my commented lisp code
17:15:53 <bourbaki> the other idea is that,
17:16:05 <StoneAway> shapr: that's the germane portion, but yes
17:16:15 <StoneAway> shapr: that's pulled from sourceforge, actually
17:16:27 <StoneAway> bourbaki: i understand a*.
17:16:32 <StoneAway> bourbaki: it is not applicable here.
17:17:00 <bourbaki> in the ongoing game only succsesors of the last placed stone are considerd
17:17:08 <shapr> StoneAway: Where on sourceforge?
17:17:24 <StoneAway> shapr: http://141.57.11.163/cgi-bin/cvsweb/havannah/games/Havannah/Path.hs?rev=1.11;cvsroot=havannah is that particular file
17:17:31 <StoneAway> trim the URI and you'll get the whole project
17:17:43 <bourbaki> we implement a simple breadth first search,
17:18:33 <bourbaki> where for every explored stone we also save the direction from where you came
17:18:42 <bourbaki> that last part is a bit hard to translate
17:18:52 <StoneAway> that's fine, that makes sense
17:18:56 <bourbaki> origindirection maybe
17:19:14 <bourbaki> nothing more needs to be saved
17:19:25 <bourbaki> especially not the whole path
17:19:48 <bourbaki> and with this we get the targeted runtime
17:20:32 <bourbaki> additions
17:21:24 <bourbaki> we also print all pointsn that are accessable if we can place a lot of stones in a fixed way
17:21:54 <bourbaki> AND the extra stones are usable as bridge stones also
17:21:58 <bourbaki> ok thats it
17:22:22 <StoneAway> well, that's not what i'm looking for :(
17:22:30 <StoneAway> that doesn't discuss loop content detection at all
17:22:36 <bourbaki> and i have to add that i did not understand a word :)
17:22:41 <StoneAway> the essential problem is this
17:22:51 <StoneAway> haskell as a game has three win conditions, of which you need one
17:22:58 <StoneAway> 1) connect three sides, not counting corners
17:23:00 <StoneAway> 2) connect two corners
17:23:13 <StoneAway> 3) make a loop around at least one cell (that cell may contain anything including your own piece)
17:23:17 <StoneAway> so
17:23:20 <StoneAway> a* fails on a triangle
17:23:25 <StoneAway> and many many other structures
17:23:42 <StoneAway> i'm using a fairly ugly modification of archimedes' maze solving alg
17:23:51 <bourbaki> heh
17:23:56 <StoneAway> but the author of this code claims his alg is at least an order of magnitude less work
17:24:03 <StoneAway> and so i'm hoping to understand what he did, in case he's right
17:24:08 <bourbaki> this is for compileing haskell programs?
17:24:14 <StoneAway> i'm using this for simulated annealing, meaning the alg will be run tens of millions of times a day
17:24:15 <StoneAway> no
17:24:26 <StoneAway> no this has nothing to do with haskell programs
17:24:28 <bourbaki> just a game written in haskell?
17:24:30 <StoneAway> no
17:24:38 <bourbaki> but ?
17:24:42 <StoneAway> i mean yes there is a havannah client written in haskell
17:24:49 <StoneAway> all i want is to understand his loop detector
17:24:50 <StoneAway> that's it
17:24:51 <StoneAway> that's all
17:25:12 <bourbaki> and i want to understand this havannah thing
17:25:21 <StoneAway> that's why i gave you that wikipedia link twice
17:25:27 <StoneAway> it has a good and complete explanation of the game
17:25:30 <bourbaki> sry
17:25:39 <bourbaki> i was busy translateing the stuff
17:25:45 <StoneAway> but what i said about the win conditions is basically it
17:25:56 <StoneAway> it's a radius-10 hex board on which players place pieces on alternating turns
17:26:03 <StoneAway> whoever satisfies one of those win conditions first wins
17:26:04 <StoneAway> that's all
17:26:13 <bourbaki> why dont you build a modification of a*
17:26:15 <StoneAway> sometimes people use the pie rule to fix first player advantage
17:26:20 <bourbaki> one that has multiple goals
17:26:20 <StoneAway> because it's godawfully slow
17:26:23 <StoneAway> uh
17:26:30 <Cale> StoneAway: you gave the wikipedia page for Haskell :)
17:26:31 <StoneAway> how would i select the goals?
17:26:33 <StoneAway> oh
17:26:34 <StoneAway> d'oh
17:26:41 <StoneAway> http://wikipedia.net/Havannah
17:26:42 <bourbaki> the one that is closest
17:26:42 <StoneAway> sorry
17:26:47 <StoneAway> the what that's closest?
17:26:54 * d` oh
17:27:00 <StoneAway> d': huhu
17:27:03 <bourbaki> closest in the sense of the metric you have chosen
17:27:04 <d`> ;]
17:27:10 <bourbaki> the one your heuristic is based on
17:27:11 <StoneAway> bourbaki: what metric?
17:27:14 <StoneAway> bourbaki: what heuristic?
17:27:21 <StoneAway> bourbaki: there is no metric, and there is no heuristic.
17:27:24 <StoneAway> there's no goal situation.
17:27:25 <StoneAway> at all.
17:27:29 <bourbaki> yes
17:27:29 <StoneAway> that's why a* doesn't work here
17:27:30 <StoneAway> at all
17:27:35 <bourbaki> and you have states
17:27:44 <bourbaki> you can measure the distance of states
17:27:47 <bourbaki> thats all you need
17:27:54 <StoneAway> what?
17:28:01 <StoneAway> what distance of states?
17:28:08 <StoneAway> i totally do not understand what you're talking about
17:28:22 <bourbaki> a metric that underestimates the real costs
17:28:26 <StoneAway> what real costs?
17:28:28 <StoneAway> what metric?
17:28:35 <bourbaki> that fulfills the triangle inequality
17:28:42 <StoneAway> that's not the only fail condition
17:28:59 <StoneAway> there are 191!/2! fail conditions
17:29:05 <StoneAway> you really want me to set goalposts for all of them?
17:29:11 <bourbaki> no
17:29:16 <monochrom> But the subject matter at hand is what we can read out of that german algorithm, not how to play the game with a*
17:29:18 <Pseudonym> This is like the blind leading the blind.
17:29:27 <StoneAway> Pseudonym: well except mine already works just fine
17:29:33 <bourbaki> you need to have a metric that calculates the distance between two states
17:29:34 <StoneAway> Pseudonym: all i want is to understand someone else's approach
17:29:39 <StoneAway> there is no such metric
17:29:42 <Pseudonym> Yeah, you know what I mean, though.
17:29:49 <StoneAway> Pseudonym: sure i do, i just don't agree with it
17:29:58 <StoneAway> Pseudonym: it's more like the blind leading the deaf
17:29:59 <erg255> StoneAway: how about emailing the author?  maybe he/she speaks some english too.
17:30:08 <StoneAway> erg: unfortunately he's on sabbatical, or i would
17:30:13 <StoneAway> that is to say i did
17:30:17 <StoneAway> but got an autoresponder
17:30:22 <Pseudonym> Better analogy, yes.
17:30:25 <erg255> StoneAway: call his cellphone :-p
17:30:32 <StoneAway> erg: i will, if you have the number
17:30:39 <bourbaki> i think you can do anything in a*s framework
17:30:50 <StoneAway> bourbaki: that's already been proven false.
17:30:57 <StoneAway> in like 1960-something.
17:31:00 <bourbaki> then at least this problem
17:31:18 <StoneAway> bourbaki: well, feel free to show me how.  saying "define a metric and measure it" doesn't help.
17:31:26 <StoneAway> because a* fails for 191!/2! states
17:31:32 <StoneAway> and i just don't think that's reasonably cullable
17:32:25 <bourbaki> well i think i will think about this tomorrow or so when i read the actual game thingy
17:32:26 <shapr> Strangely, I still can't find the source.
17:32:49 <StoneAway> shapr: well, the bit i pasted is the only part which matters.  that said, if you can tell me what you're looking for, maybe i can find it for you.
17:33:07 <shapr> I want to get all of the source to this Havannah client in Haskell.
17:33:11 <StoneAway> oh
17:33:45 <shapr> So a working url would be simpler, then I could just grab it myself.
17:34:00 <StoneAway> shapr: http://141.57.11.163/cgi-bin/cvsweb/havannah/games/Havannah/?cvsroot=havannah#dirlist
17:34:33 <StoneAway> shapr: the breadcrumb navigator at the top is the easiest way to navigate that mess of a CVS browser
17:35:20 <shapr> Thanks.
17:37:19 <shapr> Foo, the cvs server won't talk to me.
17:37:35 <StoneAway> well, the web interface works, but that'd be painful and slow
17:37:42 <StoneAway> if you just want a haskell game, i can give you other links
17:37:54 <StoneAway> but if you're interested in specifically a haskell implementation, that's all i have
17:38:01 <StoneAway> s/haskell game/havannah game/g
17:38:35 <shapr> Thanks for the offer, but I'll just email the guys who run the server.
17:38:47 <StoneAway> kay
17:39:09 <StoneAway> anyway, if anyone feels like helping me find the loop identification logic, i'd very much appreciate it
17:39:27 <StoneAway> otherwise i'll keep reading these functional programming tutorials hoping to extremely slowly glean haskell knowledge
17:40:04 <Pseudonym> import Autolib.Schichten
17:40:18 <Pseudonym> I suspect there's more than one meaning of "schichten" in German./
17:40:22 <shapr> @wiki HaskellDemo
17:40:23 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
17:40:28 <shapr> StoneAway: I'd suggest starting there.
17:40:38 <Pseudonym> OK, looking at the code.
17:40:43 <StoneAway> oh wow
17:40:46 <bourbaki> nice
17:40:50 <StoneAway> that's what i was asking for originally
17:40:50 <Pseudonym> "nach" takes a state and produces a bunch of successor states
17:40:52 <StoneAway> thank you, shapr
17:40:56 <bourbaki> do you know carcassone?
17:41:02 <StoneAway> yes
17:41:04 <StoneAway> it's a fun game
17:41:07 <StoneAway> kind of simple, though
17:41:10 <bourbaki> is there a client?
17:41:10 <StoneAway> easily broken
17:41:17 <StoneAway> no: there's a commercial implementation.
17:41:25 <StoneAway> well probably somewhere
17:41:29 <StoneAway> i don't know of one, i should say
17:41:32 <Pseudonym> That's called from something called "schichten'"
17:41:33 <bourbaki> an ai for that would also be fun
17:41:36 <Pseudonym> Is that the A* implementation?
17:41:56 <bourbaki> this game thogh is a bit like go
17:41:57 <Pseudonym> AFAIK "schichten" should mean something like "stratify".
17:42:01 <StoneAway> shapr: that's what i wanted all along, thank you SO MUCH
17:42:13 <bourbaki> schichten is layer as a noun
17:42:17 <Pseudonym> Right.
17:42:20 <Pseudonym> Hmmm.
17:42:24 <bourbaki> and something like stack as a verb
17:42:29 <shapr> stoneaway: Actually, someone pasted that same url earlier.
17:42:37 <StoneAway> oh.  i must have missed it.  :(
17:42:59 <Pseudonym> StoneAway, I think I see your problem.
17:43:04 <bourbaki> i think a good strategy to an ai for this game would be like in go
17:43:09 <Pseudonym> The termination code doesn't seem to be in this module at all.
17:43:22 <Pseudonym> Let me explain...
17:43:28 <StoneAway> Pseudonym: heh.  you're giving me too much credit.  my problem is that i totally can't read what i have.
17:43:28 <bourbaki> identify structures that force the other player to extend at some point or such
17:43:32 <Pseudonym> Ah. :-)
17:43:49 <Pseudonym> A common idiom in Haskell is to produce a large data structure explicitly, then search it separately.
17:43:56 <StoneAway> aha.
17:43:57 <bourbaki> ill post that game in #ai that seems an interesting problem
17:44:00 <Pseudonym> Because of lazy evaluation, you don't ever create all of the large data structure.
17:44:04 <Pseudonym> Just the bit you need.
17:44:09 <StoneAway> bourbaki: havannah is a well known AI topic.  no need.
17:44:20 <Pseudonym> So the termination condition is going to be in whatever calls levels0.
17:44:25 <StoneAway> bourbaki: havannah tends to be attacked by the same people that go after Y*, Star, Anchor and Go.
17:44:34 <Pseudonym> Hope that helps.
17:44:36 <bourbaki> never heared of it
17:44:38 <StoneAway> bourbaki: actually, that's what got me here in the first place.
17:44:42 <bourbaki> and i live here in germany heh
17:44:54 <mr-onionhead> hello all.  I'm trying to build ghc (6.4) for the first time on mac os (10.3) using ghc 6.2 to boot strap.  The build dies with "/tmp/ghc18478.hc:3:17: Stg.h: No such file or directory".  Any ideas about what's going on?
17:45:11 <StoneAway> Pseudonym: well that's related, but no, unfortunately it doesn't
17:45:28 <shapr> mr-onionhead: Unless ozone or one of the other OSX guys is awake, your best bet is to ask on ghc-users.
17:45:31 <StoneAway> Pseudonym: the real issue here is "how does this author find a non-collapsed loop in less than o(n^4 log n) time?"
17:45:47 <StoneAway> i found a probabilistic alg that usually beats that time
17:45:50 <StoneAway> but that's the best i can do
17:45:52 <bourbaki> StoneAway what about a probabilistic approach?
17:45:56 <StoneAway> and he claims o(n^2 log n)
17:46:06 <StoneAway> bourbaki: yeah, that's what i tried
17:46:17 <StoneAway> bourbaki: i stapled a predictor onto archimedes' left wall algorithm
17:46:19 <bourbaki> and use that for your heuristic
17:46:25 <StoneAway> bourbaki: and the predictor is pretty decent
17:46:28 <mr-onionhead> shapr: is gch-users an irc channel or a list?
17:46:37 <StoneAway> bourbaki: but his claimed complexity beats even my probabilistic alg
17:46:41 <Pseudonym> If I had to guess, it looks like it's a dynamic programming combined with A* kind of solution.
17:46:44 <shapr> mr-onionhead: It's a mailinglist on haskell.org
17:46:45 <bourbaki> ah ok
17:46:50 <Pseudonym> Compiler writers use similar techniques sometimes.
17:46:52 <StoneAway> Pseudonym: yeah, that's correct.  but that's not the part i'm looking at.
17:46:55 <mr-onionhead> shapr: thanks
17:47:09 <StoneAway> Pseudonym: the part i'm looking at is specifically the non-collapsed loop detector, and that's not in a*.
17:47:18 <Pseudonym> No, and I don't think it's in this module.
17:47:20 <StoneAway> that's attached onto a* once a* realizes it's re-treading a path.
17:47:26 <StoneAway> and it's that attached part that i need to grok.
17:47:30 <shapr> StoneAway: Well, Johannes Waldmann does know a lot about automata.
17:47:58 <StoneAway> shapr: so do i.
17:48:16 <shapr> You might like Haskell then.
17:48:28 <StoneAway> i might, but i have other things on my plate right now.
17:48:34 <shapr> I can dig that.
17:48:48 <StoneAway> all i want is to understand this one algorithm, then i can port it to a language i know well and analyze its performance.
17:49:25 <StoneAway> I *think* the alg author is misestimating its performance
17:49:29 <StoneAway> i'm just not yet certain
17:50:25 <shapr> How hard is it to do dynamic programming techniques in your language of choice?
17:50:47 <StoneAway> it's not hard to do lazy programming in pretty much any language
17:50:52 <erg255> misunderestimating i believe
17:50:55 <StoneAway> but once again this is about algorithmic complexity, *not* time complexity
17:51:01 <StoneAway> erg255: huhuhuhuh
17:51:47 <StoneAway> i really don't care if 80% or 90% of the work can be done at compile time.  what i'm interested in is how much work there is to be done.
17:51:59 <StoneAway> for annealing the two topics are utterly unrelated.
17:52:26 <StoneAway> besides i still don't see how lazy evaluation could be applied, short of a dictionary approach.
17:52:29 <Pseudonym> StoneAway: Actually, I think the techniques used here (and bear in mind that I don't fully understand the code, being in German) would be a bit more difficult to port to a language like C++ than you think.
17:52:31 <Pseudonym> But I'm not certain.
17:52:44 <Pseudonym> StoneAway: Ah, well, it can.  In Haskell, anyway.
17:52:44 <StoneAway> Pseudonym: well, since i have no idea what techniques are being used here, i cannot comment.
17:53:09 <StoneAway> how can you lazy evaluate all possible boards at once?
17:53:14 <Pseudonym> I can think of a few nontrivial examples, but I don't know if I could explain them or not.
17:53:18 <StoneAway> that's fair.
17:53:32 <Pseudonym> Not knowing about this game specifically...
17:53:45 <StoneAway> Pseudonym, shapr: thank you for spending so much time on this with me, despite my having gotten defensive earlier when I believed I wasn't being understood
17:53:58 <Pseudonym> Probably the thing to do is learn about the game, decide how I'd do this in Haskell, and then see if it gels with what this guy did.
17:54:13 <shapr> StoneAway: You may want to check out the ICFP solutions to the racecar question. They had similar problems with too many states for A* to work.
17:54:30 <StoneAway> Pseudonym: the game is really simple, if you're used to abstract strategy games
17:54:34 * Pseudonym nods
17:54:38 <Pseudonym> Yeah, I am. :-)
17:54:50 <bourbaki> its like go
17:55:09 <StoneAway> Pseudonym: it's really very simple.  given two players on alternating turns, place stones of either color onto the cells of a radius ten hex board.  when either player achieves one of the three win conditions, game over.
17:55:13 <StoneAway> it's not like go at all
17:55:14 <bourbaki> so i think that the key to write a good algo is to play the game
17:55:34 <shapr> I think the glatt function is doing some sort of adjacency check. It's hard to tell without having the entire source to look at.
17:55:54 <StoneAway> Pseudonym: the three win conditions are: 1) connect any two corners, 2) connect any three sides (not counting corners,) or 3) make a ring - a connected loop surrounding at least one cell, its contents immaterial.
17:56:15 <StoneAway> so, for example, seven pieces of one color arranged in a regular hexagon constitute a winning ring.
17:56:22 <StoneAway> because they're six pieces around the center
17:56:27 <StoneAway> and it doesn't matter that the center is filled in
17:56:39 <Pseudonym> OK, I get the game now.
17:56:55 <Pseudonym> And what you're saying is that this code tests whether or not a winning condition has been reached?
17:56:55 <StoneAway> and so it turns out that to find that loop, predicated on the contained cell, is a pain in the ass to do efficiently
17:56:59 <Pseudonym> Or this code plays a move?
17:57:01 <StoneAway> well it's specifically case 3
17:57:06 <StoneAway> and yes, it's a win test
17:57:12 <Pseudonym> Right.
17:57:13 <StoneAway> he claims his alg is o(n^2 log n)
17:57:17 <shapr> I'm pretty sure glatt does test for case 3
17:57:23 <StoneAway> and i can't beat o(n^4 log n) without probabilistic approaches.
17:57:24 <Pseudonym> Where n is the number of stones on the board?
17:57:32 <StoneAway> in the connected sequence, not the board
17:57:36 <Pseudonym> Right.
17:57:39 <StoneAway> it's easy to ignore non-connected stones
17:57:47 <StoneAway> and in fact it's just the portion of the sequence already evaluated
17:57:49 <Pseudonym> OK.
17:57:54 <Pseudonym> One quick question.
17:57:59 <StoneAway> yah?
17:58:01 <Pseudonym> I would have thought that detecting a ring was easy.
17:58:06 <StoneAway> you'd thinl
17:58:14 <StoneAway> but it turns out to not be easy /efficiently/
17:58:50 <Pseudonym> Hmmm.
17:58:51 <Pseudonym> OK.
17:58:54 <Pseudonym> I'll think about it.
17:59:41 <monochrom> What is n when you say O(n^4 log n)?
17:59:42 <Cale> StoneAway: what's n?
17:59:45 <Cale> yeah
17:59:59 <StoneAway> cale: the length of the currently evaluated portion of the current connected sequence
18:00:52 <Pseudonym> My gut feeling is that you're looking for cycles in the graph first, and then you want to test each cycle to see if it has any spaces inside it.
18:01:04 <Pseudonym> Looking for cycles is easy.
18:01:08 <Pseudonym> Is it the latter part that's hard?
18:01:29 <Cale> You're testing the girth of the graph induced by the chains.
18:02:17 <Cale> hm... is that right? Perhaps not :)
18:02:51 <StoneAway> i don't know how to apply the term girth to the problem at hand
18:02:51 <Cale> It's actually the largest cycle we're concerned with
18:03:28 <Pseudonym> You can also eliminate all cycles smaller than size 6.
18:03:44 <StoneAway> that's true.
18:03:47 <StoneAway> that i hadn't considered.
18:03:49 <bourbaki> cant you fold the board topologically in a way that all the 3 conditions are one?
18:03:57 <StoneAway> still, there are many cycles over length six which fail.
18:04:01 <Pseudonym> Right.
18:04:06 <bourbaki> like in knot theory or origami?
18:04:12 <StoneAway> bourbaki: if so i don't understand how.  topology isn't my strong point.
18:04:32 <bourbaki> so its like always searching for a cycle
18:04:36 <Pseudonym> bourbaki: You might be able to do it with two of the conditions.
18:04:45 <Pseudonym> The "connecting three edges" would be tricky.
18:04:46 <StoneAway> the first two conditions are easy to solve near-optimally
18:04:55 <bourbaki> well all the 6 corner points are one
18:04:57 <Pseudonym> Because it has a different Euler number.
18:05:00 <StoneAway> folding the board would be a huge waste for them unless doing it was less work than doing case 3 seperately
18:05:11 <bourbaki> thats easily be done with a qoutient space
18:05:33 <bourbaki> the edges are equal but do not hold for reflexivity
18:05:47 <bourbaki> no thats not right ...
18:06:20 <bourbaki> the latter is a bit tricky
18:06:38 <bourbaki> but i think that would be a significant simplification wouldnt it?
18:06:49 <StoneAway> i don't understand what you mean, so i cannot answer
18:07:02 <StoneAway> math and i aren't best buddies past calc 1
18:07:16 <bourbaki> my idea is to make all the three conditions one
18:07:33 <StoneAway> yeah, that part i understood.  then you said folding and euler numbers, and my eyes glazed over.
18:08:07 <bourbaki> no the idea is that all the corners are actually one node in the graph
18:08:28 <StoneAway> ... they are?
18:08:41 <bourbaki> and that makes your graph searchable for that case as in the cycle problem
18:08:46 <Cale> bourbaki: but they can all be coloured differently :)
18:09:05 <Cale> well, they can be coloured in 3 ways, at least :)
18:09:40 <bourbaki> hm
18:09:43 <Cale> perhaps you could treat them as adjacent though
18:09:52 <bourbaki> yes
18:10:03 <bourbaki> like a node with 6 sides
18:10:13 <bourbaki> but i think you can do the same for the edges somehow
18:10:14 <Cale> which makes bridges look like rings
18:10:21 <bourbaki> right
18:10:33 <bourbaki> ah the joys of topology heh
18:10:33 <Cale> but rings have this extra annoying condition
18:10:39 <Cale> that bridges don't
18:10:45 <bourbaki> yes its not that easy
18:10:54 <StoneAway> yeah, bridges and forks don't care whether there's a contained cell
18:11:06 <bourbaki> maybe hand crafting of all the possibilities would help there?
18:11:20 <bourbaki> StoneAway then they do
18:11:30 <StoneAway> all of the possibilities?
18:11:37 <StoneAway> for a 271-digit trinary number?
18:11:38 <bourbaki> there is just no connection that way that does not contain area per se
18:12:29 <bourbaki> i guess the edge thing is just a bit tricky to think off cause its not able to be visualizable in 3d
18:12:53 <Cale> http://www.iwriteiam.nl/Havannah.html looks useful
18:13:30 <bourbaki> heh
18:13:57 <Cale> It defines the set of all cycles as the set of positions where there exists a chain where the distance between p_i and p_(i+2) >= 2
18:14:17 <Cale> (where indices are taken modulo the number of points in the chain)
18:14:41 <StoneAway> but that's not correct
18:14:48 <StoneAway> that fails on a two-cell-long line
18:14:52 <StoneAway> er, wide
18:15:24 <Cale> hm?
18:15:45 <bourbaki> thats really nice
18:15:46 <Cale> I don't see how it fails.
18:15:54 <Cale> there's a proof that it works on that page
18:16:05 <bourbaki> Cale do you think you can fold the edges the same way?
18:17:03 <bourbaki> ah i have an idea
18:17:22 <Cale> bourbaki: well, a fork looks quite different from a bridge or a cycle, topologically
18:17:23 <bourbaki> all fields at an edge are connected to all other edge fields
18:17:27 <bourbaki> all but itself
18:17:57 <bourbaki> hm no you are right
18:17:59 <StoneAway> cale: maybe i misunderstand then
18:18:17 <bourbaki> the problem is there is a condition in it
18:19:49 <Cale> StoneAway: the distance between two points is the shortest path between them. The condition stated there basically ensures that the corners of the cycle are not too sharp.
18:19:54 <ihb> rumour has it that Haskell is pretty good at type inferring. when is type signatures in Haskell useful?
18:20:01 <Cale> So that it must enclose at least one point
18:20:22 <skew> ihb: it's good to put a type signature on each function for documentation
18:20:22 <Cale> ihb: they improve error messages, and help the compiler check that your program is correct
18:20:41 <skew> ihb: people are not quite as good at type inference for complicated definitions
18:20:44 <Cale> (at least in terms of types)
18:20:50 <StoneAway> cale: well wait
18:21:05 <StoneAway> am I allowed to asciiflood a little diagram?  5 lines :(
18:21:13 <ihb> Cale: when does they help? can you demonstrate?
18:21:19 <ihb> s/does/do/
18:21:20 <Cale> sure, that seems reasonable
18:21:30 <bourbaki> Cale cant it be like a moebius strip?
18:21:45 <skew> @moo
18:21:46 <lambdabot>       /\
18:21:46 <lambdabot>      /  \
18:21:46 <lambdabot>    (__)  \  /
18:21:46 <lambdabot>    (oo)   \/
18:21:46 <lambdabot>  /-------\/    /S
18:21:47 <lambdabot>  / |     ||    /  S
18:21:49 <lambdabot> *  ||----||___/    S
18:21:51 <lambdabot> [3 @more lines]
18:21:59 <skew> see, lambdabot get to :)
18:22:16 <Lemmih> How is that a cow?
18:22:21 <skew> I don't know
18:22:25 <Lemmih> @more
18:22:26 <lambdabot>  ^^    ^^
18:22:26 <lambdabot>  Ben Franklin owned
18:22:26 <lambdabot>   this cow
18:22:31 <Pseudonym> Lemmih: Mu.
18:22:40 <bourbaki> will that distance 2 thingy work on an 8 on the board?
18:22:41 <StoneAway> so like, cale
18:22:45 <Cale> ihb: Well, if you give a type signature for something, and it doesn't match the inferred type signature, then there's a bug either in the type sig you provided, or in the function.
18:22:45 <StoneAway> why doesn't that fail on this?
18:22:47 <StoneAway>     *       * * *
18:22:48 <StoneAway>    * * *   * * * *
18:22:48 <StoneAway>   * * * * * *   * *
18:22:48 <StoneAway>  * *   * * *
18:23:02 <StoneAway> there is no ring there, but the distance between far points is >2
18:23:41 <ihb> cale: in short "it's easier to get the type right than to get the function body definition right". err, that wasn't so short. but anyway.
18:23:42 <dons> the cow is broken atm. I'll fix it now.
18:23:49 <skew> ihb: also, the type system allows some things like explicit foralls where the inference problem is undecidable, so you need to specify them yourself
18:23:52 <Cale> StoneAway: the idea is that the distance between the ith point in the cycle and the i+2 th point is >= 2
18:23:57 <shapr> ihb: I usually write my code without type signatures, and sometimes I come back and add type signatures to working code to prove to myself that I know what's going on. I often find that GHC sees different type signatures than I do, pointing out where I can find more generality or more specificity, and cases where I can improve the code.
18:25:01 <ihb> skew: can you give an example in code where the inference problem is undecidable?
18:25:14 <Cale> StoneAway: i.e. you have to number the points in that chain so that point i is adjacent to point i+1 (mod n), and so that point i is not adjacent to point i+2 (mod n)
18:25:28 <StoneAway> modulo is v.slow
18:25:40 <StoneAway> on cpu, it's almost always implemented as a divide
18:25:48 <skew> ihb: consider something like f myId = (myId 'a',myId False)
18:25:49 <Cale> StoneAway: that's wrong.
18:25:58 <pediddle> dons, did i break the cows?
18:26:00 <StoneAway> it is?
18:26:07 <Cale> Mod is quite fast in general
18:26:18 <ihb> shapr: i haven't used ghc so i don't know what you mean, but i'll keep an open eye when i try it.
18:26:20 <StoneAway> er.  on ARM7 it's the third slowest opcode.
18:26:34 <StoneAway> not counting special cases like STMIA.
18:26:55 <Pseudonym> On a superscalar CPU, it can usually run parallel to other ops.
18:27:00 <StoneAway> oh you know, maybe it's a firmware implementation
18:27:05 <dons> nope, pediddle, it was another issue that happened to break cows by accident
18:27:11 <ihb> skew: ok.
18:27:21 <skew> ihb: GHC only looks for types in prenex form, so it assumes myId will have some specific type a->b, but a can't be both Char and Bool
18:27:24 <Cale> but anyway, that's irrelevant here
18:27:29 <Cale> well, mostly
18:27:35 <skew> you can give f the type (forall a . a -> a) -> (Char, Bool)
18:27:53 <skew> but inferring types with explict foralls like that is undecidable
18:28:41 <skew> actually, there are algorithms that will work for cases like this and I think some that work if the foralls can be buried one level deeper, but they are very complicated
18:29:16 <skew> and if you allow foralls to be specified any deeper then you can build little Turing machines and it's undecidable
18:29:44 <ihb> skew: i'll look-up forall tomorrow when i've gotten some sleep. :-)
18:30:01 <Cale> StoneAway: basically, when you're searching, it means that you can ignore the points which are adjacent to the previous point you were at
18:30:06 <skew> You don't need to do stuff like that very often. I think signatures are mostly good so people don't have to figure out the types themself
18:30:13 <ihb> thanks for the answers, skew, Cale, and shapr.
18:30:21 <bourbaki> does that game have a rule like the ko rule in go?
18:30:32 <Cale> bourbaki: it doesn't need one
18:30:44 <bourbaki> why?
18:31:09 <bourbaki> cant the other player play on the same field?
18:31:10 <Cale> bourbaki: There's no capturing, and the board position is such that the number of stones on the board is always increasing
18:31:18 <bourbaki> ah ok
18:31:40 <bourbaki> then its not as hard as go i guess
18:33:06 <bourbaki> i guess that playing in the middle in the start is a bad move isnt it?
18:33:34 <Cale> Looks kind of good to me
18:33:54 <bourbaki> wouldnt it be worth to once calculate all possible circles and then have a look what fields are contained most often?
18:33:57 <Cale> because it allows for quite a lot of flexibility in the development of your position
18:34:16 <bourbaki> i mean i would play in the vicinity of coner stones and edges
18:34:30 <bourbaki> and then be able to extend to circles on the middle
18:34:43 <bourbaki> and beeing able to extend to corners and edges as well
18:35:02 <Pseudonym> BTW, does it help to know that any winning position must be due to the last played stone?
18:35:10 <bourbaki> i guess the number of circles in the game in the middle is lower then the others
18:35:30 <bourbaki> Pseudonym according to the comments of that guy yes
18:35:37 <Pseudonym> Right.
18:37:08 <Cale> StoneAway: anyway, did that make sense?
18:37:09 <bourbaki> Cale dont you think that is a better abstraction for the win condition that unifies the last of the three of the winning conditions with the unified other two?
18:38:37 <Cale> Pseudonym: yes, it does very much help
18:39:53 <Cale> I think I could write something that does the check reasonably quickly. Basically, it's depth first search inside the chain where you keep track of not only your current position, but the previous stone you were on. You can't move to points adjacent to your last position.
18:41:27 <bourbaki> Cale youd just have to check edges and corner stones
18:41:36 <bourbaki> and the stones around the last placed
18:41:52 <shapr> The Path.hs code makes mention of the previous stone and the adjacent points.
18:42:00 <shapr> Maybe it's doing the same thing?
18:42:17 <bourbaki> if there are 3 edge stones or two corner stones
18:42:49 <Cale> StoneAway: are you still here?
18:43:02 <shapr> I think he's been overwhelmed.
18:43:36 <wagle> you seen the "mathematical go" book?
18:43:54 <shapr> I found a cool trick: http://www.google.com/search?q=continuation+filetype%3Ahs&btnG=Search
18:43:57 <bourbaki> no is it online?
18:44:41 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/1568810326/qid=1115257524/sr=8-1/ref=pd_csp_1/104-1620051-1126362?v=glance&s=books&n=507846
18:45:24 <bourbaki> i guess though that the book is bad for the application to go as a problem
18:45:38 <wagle> how so?
18:45:59 <bourbaki> i think that these guys are unlikely to be go grandmasters
18:46:06 <bourbaki> and all good go ais are writen by these
18:46:23 <bourbaki> cause in go all good go players write the good ais
18:46:34 <wagle> there were analyzing the end of the endgame better than masters
18:46:37 <bourbaki> unlike in chess where you do not need to be a good player
18:46:49 <bourbaki> yes ok thats most likely
18:47:05 <bourbaki> since the searchtree gets reasonably small
18:47:20 <bourbaki> also on small boards it wont be that bad either
18:47:39 <wagle> well, they have an interesting way to give points to the nodes in the search tree
18:47:54 <Cale> There are good go AIs?
18:47:58 <bourbaki> do you have the book?
18:48:01 <bourbaki> no
18:48:03 <Cale> :)
18:48:12 <bourbaki> there is none that can beat a grandmaster
18:48:26 <bourbaki> there are still really high prices for an ai that beats one
18:48:30 <wagle> so i was recommending it as a possible way to compare positions
18:48:31 <Cale> There is none that can beat me, and I'm not even 1 dan. :)
18:48:42 <bourbaki> though i would like to use an algorithsm that beats one
18:48:46 <skew> Cale: that's more like what I've heard
18:49:00 <blackdog> i haven't found one i can beat yet. :) How many hundred-kyu does that make me?
18:49:03 <Cale> Go AIs are really funny.
18:49:15 <bourbaki> Cale oh you play go if so on which server?
18:49:19 <Cale> KGS
18:49:25 <wagle> i got runied years ago playing gnugo
18:49:26 <bourbaki> wich channel?
18:49:37 <Cale> English Game, Mathematics
18:49:43 <blackdog> wagle: how so?
18:49:54 <wagle> i could give it 17 stones, and kill everything
18:50:01 <bourbaki> ah we should play a 9x9 once :)
18:50:06 <Cale> sure
18:50:15 <wagle> had to play in a peculiar way to do that, though
18:50:38 <bourbaki> go is interesting cause shapes matter a lot
18:50:44 <blackdog> so it screws you for other players, then?
18:50:52 <bourbaki> imho the better go ais consider shapes a lot
18:51:12 <Cale> It's kind of funny playing against a machine since the emotion that it conveys is so bizarre. It's angry and blind :)
18:51:32 <bourbaki> if i have a look at the sensai lib then there are so much pages on shapes that it seems to be important to the knowledge of a go player
18:51:41 <bourbaki> heh
18:52:02 <bourbaki> Cale i think it will be really cool to get a review of you
18:52:10 <wagle> i took 5 years off go about 5 years ago..  8)
18:52:35 <blackdog> ... you sense emotions from go??
18:52:55 <blackdog> i suppose i think some moves are cheeky, but that's as far as it goes.
18:53:02 <bourbaki> sure its like in all strategy games
18:53:18 <bourbaki> you either are attacking or just moveing it save and such
18:53:46 <blackdog> yes, but i've never seen an angry chess move.
18:54:18 <bourbaki> go is a lot about these thing
18:54:19 <bourbaki> s
18:54:25 <blackdog> (oh, wait... there was that game where my opponent kept promoting pawns to knights to show how annoyed he was that i wouldn't resign.)
18:54:32 <shapr> haha
18:54:33 <bourbaki> there are afaik also a lot of playing styles
18:55:12 <bourbaki> whole philosophys come along with them
18:55:56 <Cale> There's a lot of emotion in go
18:56:22 <Cale> If I play with someone a lot, I can tell things about their mood from just the stones that they play.
18:56:28 <bourbaki> in the game there is always also this micro and macro thing
18:56:36 <bourbaki> territory or power
18:56:54 <bourbaki> Cale wow thats cool
18:57:04 <bourbaki> what level are you?
18:57:07 * shapr wants to learn go now.
18:57:19 <Cale> Somewhere in the single digit kyus
18:57:25 <bourbaki> why dont we found a haskell go channel ?
18:57:36 <wagle> after playing go for a while, i played a chess game.  it was bizarre!  i could see these aura's of influence around all the chess pieces.  unfortunately, i didnt see/predict how moving the pieces _changed_ the auras..  8/
18:57:39 <bourbaki> i once was ranked 10 on kgs
18:57:40 <shapr> There's HaskellGoPeople on the wiki.
18:57:46 <Cale> though I need some more serious games to get back into the swing of things
18:57:59 <Cale> I've been playing against only new players for too long
18:57:59 <shapr> I played go against Richard Braakman once.
18:58:30 <Cale> I've beaten a 1d player with a 6 stone handicap.
18:58:34 <bourbaki> when i was at lionhead two of the guys also played go at work
18:58:54 <bourbaki> Cale if its too stressing for you to play me its also ok
18:59:02 <ikegami--> hello
18:59:06 <Cale> bourbaki: we can play - are you logged in?
18:59:16 <bourbaki> its just that i learn so much more when i play against ppl like you cause there is this insight
18:59:28 <bourbaki> Cale not atm i need to install kgs first
18:59:42 <bourbaki> and i am quite tired atm cause its like 4 in the morning here
18:59:52 <Cale> bourbaki: I recommend the Java Web Start version
18:59:52 <bourbaki> if you do not mind id like to play tomorrow
18:59:56 <Cale> sure
19:00:06 * Pseudonym should learn Go
19:00:07 <bourbaki> what timezone are you it?
19:00:20 <bourbaki> id vote for a haskell channel on kgs
19:00:24 <Cale> Eastern Standard Time
19:00:26 <Pseudonym> I'm not really a chess player, either, though I like the theory.  I'm actually a Bridge player.
19:00:37 <bourbaki> so thats like -5 right?
19:00:43 <Cale> yeah
19:00:50 <bourbaki> Pseudonym chess and go are very different
19:00:53 <Cale> I pretty much suck at chess :)
19:00:55 <Pseudonym> Yeah.
19:00:58 <Pseudonym> I suck at chess, too.
19:01:01 <bourbaki> Cale whats a good time for you?
19:01:02 <Pseudonym> I fall for simple tactics.
19:01:09 <Cale> any time I'm online
19:01:14 <Pseudonym> Though my strategy is great. :-)
19:01:21 <bourbaki> ok then ill just come in here and give you a message
19:01:23 <wagle> @wiki go
19:01:24 <lambdabot> http://www.haskell.org/hawiki/go
19:01:26 <Cale> bourbaki: sure
19:01:32 <wagle> @wiki skjdfsdkjs
19:01:33 <lambdabot> http://www.haskell.org/hawiki/skjdfsdkjs
19:01:34 <bourbaki> cool thanks
19:01:37 <wagle> sigh
19:01:38 <Cale> @wiki HaskellGoPeople
19:01:39 <lambdabot> http://www.haskell.org/hawiki/HaskellGoPeople
19:02:29 <wagle> at one point, it acctually checked that the page existed
19:02:38 <ikegami--> shapr: good night
19:02:53 <bourbaki> i cant await your comments heh though i guess that they will be devastateing
19:04:14 <ikegami--> I notice that GHC's Data.Char on the CVS repos have been supported Unicode
19:04:23 <ikegami--> its good news for Japanese
19:04:38 <Cale> bourbaki: hehe, I hope I can say something interesting :)
19:04:42 <skew> there is code for handling Unicode now?
19:05:00 <skew> Char has always been big enough for a Unicode character
19:05:03 <wagle> cant you bounce unicode?
19:05:10 <bourbaki> i doubt that dang i think something is wrong with my account
19:05:24 <bourbaki> im so interested that id like to play now heh
19:05:27 <skew> I think a few people have even written code to handle UTF-8
19:05:53 <ikegami--> we need to handle UTF-8 very much
19:06:09 <ikegami--> but have not handled yet
19:06:53 <bourbaki> Cale on kgs it was also impossible to get the password right?
19:08:23 <bourbaki> Cale online now
19:08:38 <StoneAway> oof
19:08:43 <StoneAway> sorry i disappeared
19:08:48 <StoneAway> stupid clients :)
19:09:01 <StoneAway> cale: my apologies; that was rude of me
19:09:12 <bourbaki> Cale i opened a game in the english chan
19:09:47 <StoneAway> Pseudonym: Go is also a relatively simple and elegant game
19:10:06 <StoneAway> Pseudonym: Given a 19x19 grid, players play on the intersections of lines in order to dominate board territory
19:10:13 <bourbaki> simple at first sight heh
19:10:30 <StoneAway> Pseudonym: The game largely revolves around "ei"s, intersections whose lines to neighbors are occupied
19:10:51 <Cale> bourbaki: what level are you approximately?
19:10:52 <StoneAway> an ei around an intersection has a minimum of four surrounding stones (other than board edges and corners;) the diagonals are not considered
19:11:01 <Cale> bourbaki: even game at first?
19:11:10 <bourbaki> Cale i guess 25 or so i havent been playing in ages
19:11:15 <StoneAway> Pseudonym: in order to capture a stone or structure on the board, simply wholly surround it on every surface, including internal surfaces of loops
19:11:17 <bourbaki> yes plese
19:11:20 <bourbaki> please
19:11:23 <Cale> oh, okay
19:11:29 <Cale> I could probably give 3 :)
19:11:31 <bourbaki> i play good at times
19:11:33 <StoneAway> Pseudonym: this means that by definition a structure with two loops cannot be removed, as both holes cannot be filled simultaneously
19:12:23 <StoneAway> Pseudonym: Scoring is accomplished by counting the empty cells which are clearly in your control (this sounds vague and a dangerous way to interpret, but it turns out not to be; they're essentially always common sense, and the rule is in dispute to simply play it out) and adding that to the count of enemy pieces held
19:12:51 <wagle> i'm probably playing at 15k.  i just created a login on kgs.  how do i get a game?
19:12:56 <StoneAway> the upshot of a game is in the difference between scores, so if you're running low on pieces (doesn't really happen, but just if) you may make 1-to-1 exchanges of captured pieces without affecting the game score
19:13:11 <wagle> do i guess 15k somewhere first?
19:13:19 <StoneAway> Pseudonym: there are a few special rules, such as the rule which prevents recurring cyclic capture, but that's essentially the game in a nutshell
19:13:59 <StoneAway> Pseudonym: the game has a decidedly fractal feel; despite being simple playing it has an astounding amount of depth, which is not comparable to any other game I know
19:14:25 <StoneAway> Pseudonym: it is common for novices to start on a smaller (either 9x9 or 13x13) board
19:14:52 <StoneAway> cale: again, my apologies for disappearing while you were talking to me
19:15:01 <StoneAway> my job overrides my conversation :(
19:16:15 <wagle> any of you playing on kgs now?
19:25:41 <Cale> wagle: Bourbaki and I are playing
19:28:10 <JohnMeacham> Yay. jhc's typechecker now uses about 200megs of ram instead of 1gig. (for the mutually recursive set of all the standard libraries, this should be as big of a unit as it ever has to deal with)
19:28:32 <Gahhh> cheers
19:29:38 <JohnMeacham> Now if I can just fix the points-to analysis, that will be the two big speed bottlenecks.
19:29:43 <skew> nice, now I can probably run it out of RAM rather than swap
19:29:56 <skew> have you tried that linear time analysis?
19:30:02 <JohnMeacham> And I just bought another gig of ram too :)
19:30:27 <JohnMeacham> skew: not yet, but it is what I am going to work on next. I wanted to fix the typechecker first as it was embarasingly slow :)
19:33:24 <wagle> cale: what names?
19:36:32 <wagle> Cale: does your client flag "cale"?
19:42:18 <wagle> anyone know either of Cale or Bourbaki's go pseudo's?
19:43:05 * SamB wonders if anyone will respond to his post on the haskell list
19:43:37 <JohnMeacham> Okay. I checked in the changes if anyone wants to live on the bleeding edge. it is not very well tested yet though. I think it might have confusing some typechecking error messages.
19:47:23 <SamB> my post is the one called "Data.Array.ST, polymorphism, and escaping type variables"
19:48:18 <wagle> eh, ratz
19:49:37 <SamB> it is about nasty, nasty ST related type errors and a likely untypeable function that has no bussiness being untypeable.
19:54:10 <mwc> I'm stunned. 'GHC X11.dylib Mac OS X' produced no results for Google :O
19:54:53 <Cale> wagle?
19:55:11 <SamB> @google GHC X11.dylib Mac OS X
19:55:12 <lambdabot> module "search" screwed up: No result found.
19:55:13 <wagle> Cale
19:55:32 <Cale> I made a game in the English game room, if you're tensor
19:55:43 * wagle juggled five windows
19:55:50 <wagle> yeah, i'm tensor
19:55:56 <mwc> Cale: what rank of tensor?
19:56:01 <wagle> havent played in kgs before
19:56:07 <wagle> 14th
19:56:11 <Cale> hehe
19:56:39 <Cale> we should make a Haskell room :)
19:57:00 <mwc> Lambda Attack Squadron
19:57:00 <Cale> wagle: would you like a couple of stones, or shall we play even?
19:57:11 <wagle> play even first
19:57:13 * SamB goes to see what can be done about that misleading error message
19:57:13 <mwc> Functional Invaders
19:58:31 <mwc> Most curious this.. GHC is unable to load libX11.dylib
19:58:36 <wagle> yuck
19:58:44 <SamB> what is .dylib?
19:58:55 <SamB> I would have thought .dynlib
19:59:02 <mwc> Mac OS X dynamic library
19:59:25 <mwc> .so is used only for loadable object files
19:59:31 <SamB> who comes up with silly extensions like dylib?
19:59:49 <mwc> Maybe it's an NeXT thing?
20:00:07 <SamB> yeah, I guess so
20:00:25 <mwc> Is there a way to get more verbose output than this?
20:00:26 <mwc> Loading package X11-1.1 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 10): image not found)
20:01:48 <mwc> That's the best ghci -v can give me
20:04:15 <SamB> @timein sydney
20:04:18 <lambdabot>  Thursday, May 5, 2005 at 1:05:18 PM EST
20:04:33 <SamB> dons: are you around?
20:09:15 <SamB> @moo
20:09:17 <lambdabot>          (__)
20:09:17 <lambdabot>          (oo)
20:09:17 <lambdabot>   /-------\/-*
20:09:17 <lambdabot>  / |     || \
20:09:17 <lambdabot> *  ||----||  *
20:09:17 <lambdabot> \/|(/)(/\/(,,/
20:09:19 <lambdabot>   Cow munching
20:09:20 <mwc> Hmm, what's the X11 shared lib called on linux? X11.so? Or libX11.so?
20:09:21 <lambdabot>     on grass
20:09:28 <SamB> @moo
20:09:29 <lambdabot>          (__)
20:09:29 <lambdabot>          (oo)
20:09:29 <lambdabot>   /-------\/
20:09:29 <lambdabot>  )*)(\/* /  *
20:09:31 <lambdabot> \ |||/)|/()(
20:09:33 <lambdabot> \)|(/\/|)(/\
20:09:35 <lambdabot> Grass munching
20:09:37 <lambdabot>     on cow
20:09:41 <SamB> /usr/X11R6/lib/libX11.so
20:09:41 <SamB> /usr/X11R6/lib/libX11.so.6
20:09:41 <SamB> /usr/X11R6/lib/libX11.so.6.2
20:11:32 <SamB> @moo
20:11:34 <lambdabot>           (__)
20:11:34 <lambdabot>           (oo)
20:11:34 <lambdabot>    /-------\/
20:11:34 <lambdabot>   / |     ||
20:11:34 <lambdabot> ~~~~~~~~~~~~~~
20:11:34 <lambdabot>  
20:11:36 <lambdabot>  Cow in water
20:11:40 <SamB> @moo
20:11:41 <lambdabot>            (__)
20:11:41 <lambdabot>            (oo)
20:11:42 <lambdabot> ~~~~~~~~~~~~~~~~~~~~~
20:11:44 <lambdabot>  
20:11:46 <lambdabot>  
20:11:48 <lambdabot>  
20:11:50 <lambdabot>     Cow in trouble
20:11:52 <mwc> I have the same libs with a dylib prefix (excpet that dylib comes after version numbers.) Given that it's searching with the correct name, I can't fathom why this is failing
20:11:57 <mwc> er, postfix
20:12:29 <SamB> maybe you could strace?
20:13:48 <SamB> maybe the library path is not right in GHCi's process?
20:14:16 <mwc> As I said, nothing else has a problem tracing it.
20:14:17 <dons> hey
20:14:24 <mwc> er, finding it
20:14:43 <mwc> dons: my GHCI dynamic linker guru :P
20:14:59 <SamB> dons: what is with the U+007F?
20:15:19 <dons> ?
20:15:44 <SamB> right before "hey"
20:15:59 <SamB> just like this: ""
20:16:26 <dons> oh, I must have hit a key just before reconnecting over wireless
20:16:49 <SamB> oh
20:16:59 * dons discovers that the internet doesn't work if you unplug the antenna :}
20:17:42 <SamB> I was going to ask you about how to nicely report errors where the module did not actually screw up, but I just went with the unclean way...
20:18:11 <mwc> dons: is there a way to get ghci to give really verbose messages when linking in a library fails?
20:18:17 <SamB> @google GHC X11.dylib Mac OS X
20:18:18 <lambdabot> module "search" screwed up: No result found.
20:18:28 <SamB> see, that just plain looks silly ;-)
20:18:35 <dons> mwc, I don't think so, unless you compile the ghc rts with -DDEBUG
20:18:40 <skew> is this just failing in ghci?
20:18:44 <mwc> @google ghci libX11.dylib Mac OS X
20:18:48 <lambdabot> module "search" screwed up: No result found.
20:18:50 <SamB> my module is not going to magically coerce Google into having results
20:19:19 <SamB> so, it has not really screwed up...
20:19:38 <mwc> skew:  yeah, workds fine if I compile
20:19:56 <skew> have you tried running ghci wil -v5 or so?
20:21:15 <dons> possibly that will give you something, but the verbose details of what the linker is doing can only be got with a DEBUG rts... hmm.
20:21:21 <dons> don't we have the -debug flag for this?
20:21:30 <dons> it links against libHSrts_debug.a
20:21:48 <dons> oh, but ghci isn't linked against that rts.
20:22:04 <dons> so you have to compile a DEBUG ghc yourself, I would think.
20:23:12 <SamB> dons: are you going to recompile/reload the search module?
20:23:29 <foxy> why is the rts written in C not haskell?
20:23:33 <mwc> I'm going to try setting explicit paths in the fallback library path
20:23:44 <SamB> foxy: how can haskell code run without the RTS?
20:24:06 <skew> Hi jaap
20:24:12 <jaap> skew: hello
20:24:29 <foxy> SamB: bootstrap?
20:24:36 <mwc> back in a sec, need a relogin
20:24:38 <SamB> foxy: it is an RTS!
20:24:59 <SamB> next you'll be asking why the kernel doesn't run in userspace!
20:26:48 <foxy> ok, please excuse my ignorance, but if I have a running ghc, couldn't I write the next rts in haskell and compile it with ghc?
20:27:06 <skew> foxy: sure, but that code would need to run under the rts from this version of ghc
20:27:51 <SamB> foxy: if you could get jhc not to leak, maybe you could compile the RTS with it...
20:28:17 <SamB> or rather, get the output of jhc not to leak
20:28:19 <mwc> Ahah. on mac os x, dlopen should take a path to the library. given in that form, it's searched for in the DYLD_FALLBACK_LIBRARY_PATH
20:28:37 <mwc> well, first it's searched for in the cwd, then in fallback path
20:28:42 <skew> if you made sure your Haskell code didn't need a memory mnager and didn't need need a garbage collector you might be able to run it without the RTS
20:28:48 <jaap> SamB: but jhc runs fine on John's machine ;-)
20:29:26 <skew> but he has a few gigabytes of memory
20:29:36 <jaap> skew: exactly, hence the ;-)
20:29:44 <SamB> jaap: jhc may "run fine", but I heard the output leaks like a bucket, only without the bucket.
20:30:03 <skew> I remember getting 256K memory modules...
20:30:18 <foxy> @seen dons
20:30:23 <dons> @@seen me
20:30:24 <mwc> The fix for this problem is to put DYLD_FALLBACK_LIBRARY_PATH=/opt/local/lib:/usr/local/lib:/usr/lib:/usr/X11R6/lib in ~/.MacOSX/environment.plist
20:30:27 <dons> @seen me
20:30:30 <lambdabot> dons is in #haskell. Last spoke 8 minutes and 13 seconds ago.
20:30:32 <lambdabot> me has changed nick to metaperler.
20:30:34 <lambdabot> I saw metaperler leaving #perl6 and #haskell 1 day, 4 hours, 20 minute
20:30:36 <lambdabot> s and 48 seconds ago, and I have missed 10 seconds since then.
20:30:40 <dons> hehe
20:30:48 <dons> SamB, what's wrong with the search module?
20:31:00 <dons> did i forget to add a patch?
20:31:02 <SamB> dons: didn't you see the silly error message?
20:31:06 <lambdabot> me has changed nick to metaperler.
20:31:08 <lambdabot> I saw metaperler leaving #perl6 and #haskell 1 day, 4 hours, 20 minute
20:31:10 <lambdabot> s and 53 seconds ago, and I have missed 10 seconds since then.
20:31:17 <SamB> oh, oops, I forgot to hit y!
20:31:23 <jaap> does anyone know, if instance Enum Foo, how to make a function Foo -> Word8 without having to go through Integer? I'm probably being silly, but with the standard GHC libraries, that doesn't seem possible
20:31:35 <dons> the "module "search" screwed up" msg?
20:31:43 <SamB> darcs send was just sitting there waiting for me to hit y...
20:31:59 <dons> oh, that's probably why I haven't applied it yet.
20:32:05 <dons> got it now :)
20:32:06 <SamB> yes, indeed ;-)
20:32:29 <foxy> dons: any insights into the cygwin problem?
20:32:41 <mwc> SamB: the best is when you go to sleep to let something that takes forever to complete to find that it worked for 30 seconds and then waited for you to enter something
20:32:49 <skew> jaap: how do you get an Integer?
20:33:00 <dons> foxy, haven't had a chance yet.
20:33:05 <foxy> @type fromInt
20:33:06 <lambdabot> bzzt
20:33:20 <foxy> @type toInteger
20:33:21 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
20:33:22 <jaap> skew: i currently do word8_of_foo = fromInteger . toInteger . fromEnum
20:33:50 <jaap> skew: which seems exceedingly clumsy to me, since it goes from Foo to Int to Integer to Word8
20:34:02 <jaap> skew: while I *know* that the enum has < 255 members
20:34:16 <skew> not necessarily, fromInteger . toInteger is specialized for some conversions
20:35:09 <jaap> skew: okay... then maybe I should look at the output and see if it's really so bad; maybe I'm worrying about something the compiler doesn't actually generate code for
20:35:18 <skew> the documentation for Data.Word says you should use fromIntegral
20:35:36 <skew> "which is specialized for all the common cases so should be fast enough"
20:35:40 <foxy> dons: I looked in package.conf, and the module 'base' specifically includes the object files which have the unfound objects, and the package base gets loaded before attempting to resolve symbols
20:35:43 <dons> @google bdfss klqerre klaaadf
20:35:43 <SamB> * For coercing between any two integer types, use
20:35:44 <SamB>   'Prelude.fromIntegral', which is specialized for all the
20:35:44 <SamB>   common cases so should be fast enough.  Coercing word types to and
20:35:44 <SamB>   from integer types preserves representation, not sign.
20:35:44 <lambdabot> No result found.
20:36:04 * SamB found that in Data.Word
20:36:10 <dons> foxy, which sounds right, doesn't it?
20:36:11 <SamB> @docs Data.Word
20:36:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Word.html
20:36:12 <jaap> thanks; i spose i somehow missed that
20:36:18 <foxy> dons, yeah
20:36:23 <skew> you can check to see what that compiles to
20:36:45 <skew> or check that source for an appropriate RULES pragma
20:36:48 <foxy> dons: I looked at Linker.c, which tries four ways of resolving, and then, in this case, fails
20:37:20 <dons> wass there any special cygwin magic we need?
20:38:01 <jaap> skew: it's not that critical; it's for my little assembler, not exactly the pinnacle of performance-critical code
20:38:07 <SamB> "fromIntegral/Word8->a"       fromIntegral = \(W8# x#) -> fromIntegral (W# x#)
20:39:26 <skew> where is W8# defined?
20:39:41 <skew> or at least documented
20:40:11 <foxy> dons: I didn't see any reference to cygwin, but there are some mingw32 specific things.  But I've tried compiling hs-plugins with -D__MINGW32__ and that doesn't work
20:40:40 <SamB> Prelude> :i GHC.Word.W8#
20:40:40 <SamB> data Word8 = W8# GHC.Prim.Word#         -- Imported from GHC.Word
20:40:40 <SamB> P
20:40:49 <dons> did you re-build hs-plugins with -DDEBUG?
20:40:57 <foxy> yup
20:41:06 <dons> any extra information revealed?
20:41:16 <SamB> wait, I got the wrong one...
20:41:24 <dons> example, were the symbol names being guessed correctly?
20:41:33 <SamB> "fromIntegral/a->Word8"       fromIntegral = \x -> case fromIntegral x of W# x# -> W8# (narrow8Word# x#)
20:41:59 <skew> and then there should be a fromIntegral/Int->Word
20:42:01 <foxy> I think the symbols names were correct, except for one __stginit_Prelude
20:42:17 <skew> hmm, GHCi doesn't like the # in GHC.Prim.Word#
20:42:29 <foxy> make works but load (in the call to resolveObjs) doesn't
20:42:32 <SamB> skew: works better with -fglasgow-exts
20:42:51 <skew> I've already got that set
20:43:02 <dons> foxy, is it just the __stginit_* symbol that's not resolved? or were there others?
20:43:21 <SamB> skew: it doesn't work if you just set it in a pragma...
20:43:32 <foxy> dons: there were others, all the others were located in HSbase{1,2,3}.o which *should* be in the link path
20:43:44 <foxy> (from package.conf)
20:44:00 <skew> SamB: it doesn't seem to work as an option either. Try :browse GHC.Prim.Word# or :m + GHC.Prim.Word#
20:44:25 <SamB> Word# is not a modulename
20:44:43 <SamB> Prelude> :i GHC.Prim.Word#
20:44:43 <SamB> data Word#      -- <wired into compiler>
20:44:49 <skew> oh, okay
20:45:04 <SamB> @type GHC.Prim.Word#
20:45:06 <lambdabot> bzzt
20:45:12 <skew> I couldn't get any information on GHC.Prim
20:45:14 <dons> did you see a "loading package base" msg?
20:45:21 <SamB> @type undefined :: GHC.Prim.Word#
20:45:23 <lambdabot> bzzt
20:45:27 <foxy> dons: yup, that worked
20:45:56 <foxy> +Loading package base-1.0 ... linking ... done
20:45:56 <foxy> +Loading object API MBd4152209a.out:
20:45:56 <foxy> +C:\apps\cygwin\tmp\plugins.tmp.4015033/MBd4152209.o: unknown symbol `_GHCziBase_unpackCStringzh_closure'
20:46:17 <dons> hm
20:47:02 <dons> and it does have a leading underscore in HSbase.o?
20:47:16 <dons> what's HSbaes{1,2,3}.o by the way? that sounds odd.
20:47:45 <SamB> "fromIntegral/Int->Word"  fromIntegral = \(I# x#) -> W# (int2Word# x#)
20:48:18 <skew> I wouldn't be surprised if int2Word# doesn't actually generate any code
20:48:31 <SamB> skew: no kidding!
20:48:36 <foxy> there are four files HSbase.o HSbase1.o HSbase2.o HSbase3.o.  In package.conf package 'base' references these three files
20:48:42 <dons> it generates a (W_) cast.
20:48:51 <SamB> I would be surprised if it did generate any.
20:48:56 <SamB> dons: casts are not code.
20:49:13 <SamB> there are no casts in machine language!
20:49:52 <dons> yes, i know.
20:51:08 <foxy> $ nm HSbase1.o | grep _GHCziBase_unpackCStringzh_closure
20:51:09 <foxy> 000b8960 D _GHCziBase_unpackCStringzh_closure
20:51:55 <foxy> I also tried running load with ghc's package.conf as an argument, no joy
20:55:22 <dons> hmm. what does this package.conf entry look like for the HSbase* files?
20:56:26 <foxy> hsLibraries = ["HSbase1","HSbase2","HSbase3"]
20:57:44 <dons> ok, so that should work.
20:58:01 <dons> but it still seems that some of base isn't in memory when the resolution takes place.
20:58:15 <dons> mail me any more info you dig up.
20:58:34 * dons -> busy
20:59:13 <foxy> how do you do that? (emote stuff)
20:59:38 <foxy> thanks for your time dons
21:02:27 <blackdog> shapr: if the Dolls come to Sweden, you've got to go see them - they've got an awesome live show.
21:05:09 <mwc> foxy: use /me
21:08:03 <Pseudonym> @moo
21:08:04 <lambdabot>                 (__)
21:08:04 <lambdabot>                ([][])            "I have this recurring dream
21:08:04 <lambdabot>                __\/_--U              about golden arches."..  (__)
21:08:04 <lambdabot>               /\    \__                                 ^  :..("")
21:08:04 <lambdabot>              /\\\  /  /                         //\  ____\_____\/ //
21:08:04 <lambdabot>             /----^/__/\ /\                     // \\/     \___ / //
21:08:06 <lambdabot>                 \\\____/--\--                 // /-/__________/ //
21:08:08 <lambdabot>                  /======   \/            =======/==============//
21:08:10 <lambdabot>               *_/ /    \   /^              //  /              \\
21:08:12 <lambdabot>                  /      \ ^               //                   \\
21:08:14 <lambdabot>  
21:08:16 <lambdabot>                      Psycowlogist and patient
21:08:43 <SamB> @moo
21:08:44 <lambdabot>           \^^^^^^^^\   (__)
21:08:44 <lambdabot>            \^^^^^^^^\\ (oo)
21:08:44 <lambdabot>         *-----\_______\/\/
21:08:44 <lambdabot>       ^_______/   ---  \______^
21:08:44 <lambdabot>      ^--------\   \S/  /\_____^
21:08:45 <lambdabot>                \______/
21:08:45 <wagle> @mu
21:08:47 <lambdabot>  
21:08:49 <lambdabot>    It's a bird...
21:08:51 <lambdabot>     It's a plane...
21:08:53 <lambdabot> Maybe you meant: moo msg pl wn
21:08:55 * mwc complains that that exceeds 80 char line width
21:09:05 <Pseudonym> Indeed.
21:09:35 <SamB> mwc: at least lambdabot didn't mangle it!
21:09:38 <wagle> @mucow no cow
21:09:39 <lambdabot> Unknown command, try @listcommands.
21:09:43 <SamB> @moo
21:09:45 <lambdabot>    (___)
21:09:45 <lambdabot>    (o o)
21:09:45 <lambdabot>     \ /
21:09:45 <lambdabot>   \--O--/
21:09:45 <lambdabot>  // -----\
21:09:45 <lambdabot>  \\/_^{} /==V===[]
21:09:47 <lambdabot>    \_____\\//
21:09:49 <lambdabot>     \__/
21:09:51 <lambdabot>     //\\         The Boss
21:09:53 <lambdabot>     //  \\   (Bruce Holstien)
21:09:55 <lambdabot>     //   //
21:09:57 <lambdabot>     ^^    ^^
21:10:24 <skew> could we up the flood limit on lambdabot a bit?
21:10:44 <Pseudonym> Yes, we can't have the cows requiring @more
21:11:06 <mwc> SamB: yeah, but it looks like noise until you resize the terminal
21:11:19 <mwc> skew: maybe we can just get a 1 cow/5 minute limit
21:11:21 <skew> It looked to me like the first few lines came instantly, and then it hit some kind of rate limit
21:11:57 <SamB> mwc: you mean 5 cow/1 minute!
21:12:20 <SamB> skew: that is probably dancer's doing
21:12:23 <skew> would that be an upper or lower bound?
21:13:19 <mwc> upper i'd hope
21:24:03 <wagle> bogocows
21:24:44 <SamB> is that how many Mcows your CPU can pump in a second?
21:30:36 <wagle> hmm.. pogocows
22:02:27 * a5 programs in c++
22:02:44 <Pseudonym> This is #haskell, not #confessional.
22:03:12 <Pseudonym> But since you mentioned it, read "Why FP Matters" and recite Wadler's laws of programming language design three times.
22:03:32 <Pseudonym> While wearing a hair shirt.
22:03:43 <blackdog> bless me father for i have sinned. i have mutated three times; i have taken pointer references; i have used typecasts.
22:04:28 * a5 doesn't have a choice
22:04:30 <blackdog> unless you're doing compile-time metaprogramming in c++ templates, which is just twisted enough to be cool. :)
22:04:46 <Pseudonym> It's as cool as anything Oleg does.
22:05:25 <a5> i haven't seen that but it smacks of wankery
22:05:59 <Pseudonym> You're not a closet C programmer are you?
22:06:28 <a5> i'm not a closet anything
22:06:46 <Pseudonym> That's more hair shirt for taking Andrescu's name in vain by proxy.
22:06:46 <blackdog> a5: ... wanksmacking?
22:07:42 <a5> heh
22:07:48 <Pseudonym> Chant "Stepaunov" until you achieve enlightenment.
22:08:26 <a5> no thanks
22:08:42 <Pseudonym> Actually, read "Generative Programming".  That's REAL penance.
22:08:46 <Pseudonym> :-)
22:09:02 <a5> what's it about?
22:09:22 <Pseudonym> Or, for really real penance, you are sentenced to fixing a bug deep inside Boost.Spirit.
22:09:44 <Pseudonym> Oh, Generative Programming is an interesting book, if a bit wanky.
22:09:56 <Pseudonym> Coplien wrote the forward, which is never a good sign.
22:10:03 <Pseudonym> But the central idea is a good one.
22:10:13 <Pseudonym> The idea is that people don't write programs, they write program families.
22:10:36 <Pseudonym> GHC, for example, is a family of programs.  It can be retargeted for different platforms, it has an interactive version etc etc.
22:10:50 <Pseudonym> And that you have to design for that.
22:10:51 <a5> i'm in the middle of "the next 700 programming languages". it's ok
22:10:53 <Pseudonym> And implement for that.
22:11:12 <a5> man c/c++ need pascal's "with" operator
22:11:31 <a5> it would be so simple
22:11:32 <Pseudonym> C++ has references.  That gets you 95% of the way there.
22:12:01 <a5> more like 30%
22:12:09 <a5> no 27%
22:12:26 <Pseudonym> What is missing?
22:13:53 <a5> maybe i don't understand
22:14:07 <a5> 'with' lets you open the namespace of a structure or class and do assignments within it
22:15:18 <a5> well record in pascal. and it doesn't exist in c/c++
22:22:58 <Cale> Is there a difference between "with v1 do s" and "s" with every occurrence of each variable "x" in "s" replaced with "v1.x"?
22:26:04 <Gahhh> VB has that, too. It just lets you manipulate fields with less typing.
22:26:40 <a5> Cale: no
22:27:01 <a5> that's why it'd be super easy to implement
22:30:28 <a5> it seems that the gcc people are significantly less enthusiastic about adding new features than the ghc people are
22:30:35 <a5> either that or no one wants to add features
22:30:50 <a5> but i assume it's the former
22:31:26 <Cale> Well, C/C++ are fairly conservative languages.
22:31:48 <a5> that doesn't mean the compilers have to be
22:32:05 <mflux> people get bashed for using 'gnuisms' enough as it is ;)
22:32:26 <Gahhh> I was told that gcc source base was not much fun to fiddle with.
22:32:47 <Cale> The people who tend to want to use C/C++ aren't looking for lots of new features.
22:33:06 <a5> ... and just because you might resent microsoft embracing and extending doesn't mean you can't do the same. i mean, gcc is at least $0.
22:33:08 <Cale> but that's true as well, as far as I've heard, gcc is a bit of a mess
22:33:29 <a5> a lot of people are stuck with c/c++ for various reasons
22:33:49 <Cale> Something like with blocks, I'm sure you could write a preprocessor for.
22:34:32 <mflux> for example the qt-people added language features with a preprocessor
22:34:37 <Cale> Since it's basically just a little bit of syntax manipulation.
22:34:46 <a5> the thing is, if everybody writes a preprocessor for their own extensions, they won't necessarily be able to preprocess each other... :)
22:35:01 <mflux> why not? just pipe the preprocessors
22:35:31 <Cale> And if gcc adds lots of extensions, then GNU C won't compile in other C compilers also.
22:35:36 <a5> at least some kinds of preprocessors have to be able to parse the language
22:35:51 <mflux> write one parser, and each preprocessor will be able to use it
22:35:56 <Cale> yes, I'm not suggesting you do this with sed :)
22:35:57 <mflux> and the preprocessor works with all compilers
22:35:59 <mflux> not just gcc
22:37:01 <a5> mflux: what one parser? which preprocessor language does it parse?
22:37:13 <mflux> it would parse gnu C
22:37:19 <mflux> after CPP
22:37:27 <mflux> (for instance)
22:37:37 <a5> but in order to add 'with' syntax you need a symbol table
22:38:02 <mflux> symbol table isn't that difficult to obtain from a preprocessed .c-file
22:38:28 <Cale> You're going to parse the thing anyway
22:39:32 <mflux> I think the only technical objection would be that the parsing would be later done again by the compiler, but I still think it's better to live with that than throw in arbitrary extensions that may affect the compiler's behavior and would immediately lock you in to the certain compiler
22:39:54 <a5> i don't get it. there is a language A and an extension B to A and another extension C to A. someone writes a parser for B and someone else writes a parser for C. the B parser isn't necessarily going to be able to parse C, and vice-versa.
22:39:59 <mflux> also, debugging, if required, the extension would be easier, you could always peek the produced source
22:40:57 <mflux> I was thinking after each product would be plain C again
22:41:18 <Cale> a5: that's true, you're not always going to get a nice pushout of language extensions, but perhaps there's a way to ensure that in most reasonable cases, this will be possible.
22:41:27 <mflux> ah, I got it, there is a problem
22:41:37 <a5> yeah, duh
22:41:44 <a5> it's like having diverging cvs branches
22:41:50 <mflux> well, you could still write An Extension Toolkit
22:41:58 <mflux> which would still be usable with all the compilers
22:42:06 <a5> no it's better to have non-lame maintainers
22:42:23 <Cale> It's better to stay away from C/C++ as much as possible :)
22:42:30 <mflux> if you write an extension to gcc, it would be impossible to ever switch away without rewriting the code
22:42:38 <mflux> having a rewriting at that point could be useful
22:42:59 <mflux> but, extensions that cannot be done by rewriting the code should (must) still go to the actual compiler
22:43:40 <a5> i posit that (1) people can always stick to a language subset if they want to (and enforce this with compiler options) but (2) as soon as a language stops evolving it dies. so i conclude that there is no excuse not to keep evolving languages
22:43:45 <Cale> It would be neat to see something like that however. Have some toolkit which manages some algebra of extensions to the language syntax. :)
22:44:08 <mflux> well.. I would more preferably see that the extensions would need to be specifically enabled instead of disabled
22:44:16 <mwc> a5: like with how Common LISP killed LISP?
22:44:54 <a5> mwc: what, was Common LISP a standardisation of LISP?
22:45:00 * mwc cuts into Chicken Kiev inside a glove box
22:45:12 <mwc> a5: yeah, defines a standard library and language
22:45:19 <mwc> granted, it also defines a macro system
22:45:35 <a5> how tacky
22:45:36 <mwc> ultimately that's how language extensions ought to be done sanely: implementation in that language
22:45:38 <Cale> Have some syntax for adding branches to the grammar of the language, together with a translation of those subtrees back into the original language.
22:45:56 <mwc> Cale: are we on the same wavelngth?
22:46:07 <a5> Cale: that's lame.
22:46:14 <a5> Cale: but not obviously so.
22:46:17 <hefner> Cale: ever consider learning lisp? they've been doing this stuff for decades.  :)
22:46:24 <Cale> hefner: I know lisp
22:46:33 <Cale> and I've used lisp macros :)
22:47:02 <Cale> but they're talking about gcc, and how there's not enough language extensions going into it
22:47:16 <hefner> I guess I'm missing WHY they're talking about gcc. :)
22:47:44 <Cale> I don't know either. :)
22:47:53 <mwc> @karma+ hefner
22:47:54 <lambdabot> hefner's karma has been incremented
22:48:02 <mwc> it had to be said
22:48:23 <Cale> I prefer scheme to common lisp
22:48:27 <a5> the original reason was different. but it's become a conversation about what i think is gcc's failure to innovate
22:48:30 <Pseudonym> Sorry.
22:48:35 <Pseudonym> a5, the thing about with.
22:48:36 <mwc> I prefer neither next to Haskell
22:48:39 <Pseudonym> {
22:48:42 <mwc> a5: how can GCC innovate?
22:48:50 <Cale> mwc: yeah, I'm the same
22:48:50 <mwc> They're implementing standardized languages?
22:49:02 <Pseudonym>     Object& x = some->deep()->recursion->into.a->structure;
22:49:08 <Pseudonym>     x.foo = x.bar;
22:49:09 <Pseudonym> }
22:49:17 <Pseudonym> Like I said, that gets you 95% of the way there.
22:49:24 <Pseudonym> Namespaces are easier.  "using namespace".
22:50:49 <a5> ghc is implementing standardized languages too
22:51:05 <a5> look, our universe is a superposition of a bajillion quantum worlds. but we only experience one of them. we have to face that. we can't spend all of our engineering energy on a system which lets different versions coexist, because in reality, of the many possibilities, we always end up settling on one and sticking with it.
22:51:23 <mwc> yep, but the haskell community is small, connected, and academic
22:51:51 <Cale> Who cares about extending C at this point?
22:52:01 <mwc> What can C be extended to do?
22:52:04 <Cale> Why not just use another language?
22:52:27 <a5> why not? good question. but there's a ton of stuff that's still written in C.
22:52:33 <mwc> about the only useful thing GCC ever added were >? and <? operators
22:52:40 <a5> and a ton of people that are stuck with it.
22:52:54 <mwc> and those went bye-bye in 4.0
22:53:02 <a5> mwc: gasp!
22:53:07 <mwc> a5: so if they need to use codebase, pick any language with an FFI
22:53:37 <mwc> legacy codebases like that aren't having huge chunks rewritten
22:53:48 <mwc> they'd just build a new lib
22:54:13 <a5> maybe you have a point. a lot of extensions would have been mostly useful 5 or 10 years ago
22:54:43 <a5> still, the linux kernel isn't going haskell
22:55:04 <mwc> what syntax extensions are useful for kernel programming?
22:55:35 <mwc> Can't do GC. Can't do lazyness. Lambda expressions are too far removed.
22:55:40 <mwc> C is designed as a portable assembler.
22:55:51 <mwc> foo(x) is compiled into _foo
22:56:16 <mwc> the domain that C is good for is writing the lowest level of a system
22:56:39 <a5> i don't know. there are a lot of places where it could be more elegant. without becoming more difficult to compile.
22:56:45 <mwc> above that, something like Ada for the mid levels.
22:56:54 <mwc> Yeah, but elegant isn't a good thing with a low level language
22:56:59 <Pseudonym> It would make sense in a microkernel OS.
22:57:03 <mwc> precise determinism is what's much more important
22:57:05 <Pseudonym> Because the executive is in user space.
22:57:19 <Pseudonym> You could implement bits of the Hurd in Haskell, for examplew.
22:57:21 <a5> elegant and deterministic aren't exclusive
22:57:21 <Pseudonym> Or QNX.
22:57:29 <Pseudonym> Probably not QNX because of the real-time constraints.
22:57:35 <mwc> No not at all
22:58:11 <mwc> but having a very close 1-1 mapping of C constructs and the underlying instructions operated is a very important principle for C
22:58:37 <a5> so i'm not proposing a brave new extension. i'm just seeing a lot of resistance to adding extensions. and i think it shouldn't be there.
23:00:10 <a5> i think it's a great strength of haskell that it has a compiler which is being constantly extended
23:00:15 <Pseudonym> BTW, the only thing that C can be extended to do is play nice with modern CPUs and modern compiler techniques.
23:00:23 <Pseudonym> The "restrict" keyword is a good example.
23:00:45 <a5> no, it can be extended to do much more than that
23:01:12 <a5> it won't be as powerful as haskell, but it can be made much better
23:01:30 <mwc> There have been a lot of wierd extensions to C. Like complex numbers. Why?
23:01:38 <Cale> a5: So you extend it a bunch and get what? C++, Objective C?
23:01:39 <mwc> C is an absolute garbage numerical language
23:02:03 <Pseudonym> And complex numbers are such a specialised tool.
23:02:09 <a5> the problem with C++ and Objective C is that they haven't been extended enough!
23:02:18 <mwc> Pseudonym: really. What are they good for in kernel programming?
23:02:41 <a5> look at "evolution of C++". stroustrup talks about all of these great features which were taken out of the language because people didn't understand them
23:03:03 <mwc> a5: C++ is what you want. It's C with some smarter semantics and you don't require a new standard to add nice complex datatypes
23:03:29 <mwc> Somewhere along the lines, people started using C for Fortran
23:03:32 <a5> mwc: as i said, i have the same complaints about C++
23:03:48 <Cale> a5: Why not start with some other language which is ahead of C in terms of functionality and start extending it?
23:03:53 <Pseudonym> C++ certainly needs some new things.
23:03:57 <mwc> a5: the barriers to "extensions" is ISO/ANSI
23:04:07 <Pseudonym> But you would be better adding stuff to that than to C++.
23:04:11 <mwc> try and Push the C-2006 standard trhough that
23:04:12 <Pseudonym> Sorry, than to C
23:05:22 <mwc> C was pretty well set by the 80s.
23:05:30 <a5> Cale: lets stick to the point. obviously i'm in #haskell for a reason. the question is, why are people hostile to extensions to C/C++/Obj-C?
23:05:39 <mwc> Haskell has been something more than an academic curiosity since 1998
23:06:00 <Cale> a5: because if they wanted fancy language features, they wouldn't be using those languages :)
23:06:02 <mwc> a5: because they'll break portability
23:06:16 <Pseudonym> I'm more hostile to extensions to C than to C++.
23:06:30 <Pseudonym> Because I can't think of much more you could add to C and still keep the spirit of C.
23:06:37 <Pseudonym> Whereas adding things to C++ is very much in keeping.
23:07:00 <mwc> a5: if there were 200 Haskell compilers in common use, we'd be up in arms over each proposed extension that wasn't in the latest standard
23:07:00 <a5> but why do you resent a language feature if you're free to avoid using it?
23:07:07 <Pseudonym> I don't know enough about the spirit of Obj-C, but I suspect it's similar to C++.
23:07:28 <mwc> a5: that's not the way things work in practice. People use dozens of GNU-ism and it's not portable
23:07:49 <a5> but gcc is portable. and you can link code compiled with it
23:08:11 <mwc> a5: not as much as you think. Look how many breakages occur with 4.0
23:08:21 <a5> besides, the gcc maintainers shouldn't care about that
23:08:35 <a5> who are they maintaining for, microsoft?
23:08:49 <mwc> C is closed and standardized and set in stone
23:08:55 <mwc> Haskell is still a baby language
23:09:08 <a5> mwc: those statements are meaningless
23:09:24 <mwc> it's 7 y o. It's got its whole life ahead of it. C is 35, has a few kids and a mortage.
23:09:27 <mflux> shouldn't, as in must not?
23:10:40 <a5> mflux: someone should take maintainership from them if they don't.
23:10:42 <a5> as with egcs
23:11:12 <mwc> the feeling about C is that it's good at what it's meant for. It doesn't need cute tricks.
23:11:28 <mwc> as you pointed out, GCC and many other C compilers are open source
23:11:46 <mwc> feel free to fork away
23:12:09 <a5> bad attitude
23:12:14 <mwc> a5: I'm wondering what you think C needs?
23:12:22 <a5> enthusiasm
23:12:41 <Cale> It's not very inspiring
23:12:58 <mwc> too late. C had enthusiam when it was in development
23:13:18 <mwc> C is now ANSI/ISO standardized, has hundreds of implementations
23:13:45 <a5> sorry, but the reason it doesn't have enthusiasm is because people like you *expect* it not to
23:13:49 <a5> :)
23:14:07 <mwc> it's too ubiquitous and diverse to build consensus movements for extensions
23:14:22 <mwc> a5: as for C extensions, there are things like Cyclone and such
23:14:30 <mwc> that add a lot of new functionality
23:14:40 <Cale> Why does the extension have to be called C? :)
23:15:05 <a5> because there's only one best extension
23:15:12 <a5> once people decide on that they should call it C
23:15:12 <Cale> oh?
23:15:17 <a5> yeah
23:15:43 <Cale> I don't think language extensions form a nice lattice like that :)
23:15:51 <mwc> a5 so Objective-C's object extensions are inferior to C++ or what?
23:16:32 <a5> i would say so. they could be implemented on top of c++ maybe
23:16:36 <mwc> It's not so much that an extension is merely a superset of the old language. it's an actually different language
23:16:52 <mwc> a5: I would disagree, Objective-C's system is more practical
23:17:01 <a5> it's like set theory. is there a best set of axioms? arguably not. but we choose a best one and stick with it.
23:17:05 <a5> and we keep adding more
23:17:17 <Cale> a5: there is no best set of axioms for set theory
23:17:22 <a5> many disagree
23:17:44 <a5> for sure, there are reasons to prefer certain ones
23:17:46 <Cale> There's a practical set of axioms based on common agreement, but even that, there's controversy over.
23:17:48 <a5> and mathematicians do
23:17:57 <mwc> a5: I'd warn you against arguing thta point with Cale but this is fun to watch
23:18:20 <Cale> I use ZFC usually. Some people use ZF, some people use ZF+AD, some other things.
23:18:26 <a5> the controversy for any given axiom will die down over time
23:18:30 <Cale> no
23:18:45 <Cale> Choice and Determinacy are both desirable and incompatible
23:19:10 <Cale> (In the case of set theoretic axioms)
23:19:55 <Cale> Sometimes you want two features, but adding both breaks the system.
23:21:46 <mwc> Personally, as an applied mathematician, I think determinancy is overrated
23:21:49 <mwc> and go with ZFC
23:22:04 <Cale> mwc: but isn't it nice to have sets be measurable? :)
23:22:15 <Cale> (subsets of R)
23:22:37 <a5> planetmath says "AD itself is not taken seriously by many set theorists as a genuine alternative to choice"
23:22:48 <mwc> Cale: I'm a theoretical physicist. QM shows that no quantity is either deterministic or exactly measurable
23:22:59 <mwc> a5: what about ZF+AD?
23:23:25 <Cale> ZF+AD would be what they're talking about there. Set theorists like choice.
23:24:38 <a5> i disagree with "QM shows that no quantity is either deterministic or exactly measurable"
23:24:39 <Cale> Some people like Woodin are proposing extensions to set theory which involve forcing just to define the axioms.
23:25:05 <a5> what is forcing?
23:25:50 <mwc> a5: take it precisely measureable with Heisenburg, and determinism depends on your interpretation of QM
23:25:50 <smott> Let $(X_n)_{n\in{\rm I\!N}_0}$ be a sequence of random variables with values in S. Here, n denotes the time at which the state Xn occurs.
23:25:50 <Cale> http://en.wikipedia.org/wiki/Forcing
23:25:53 <smott> Definition 2.1 (Markov Chain)   The sequence $(X_n)_{n\in{\rm I\!N}_0}$ is called a homogeneous Markov chain with discrete time, state space S, and transition matrix ${\rm I\!P}$, if for every $n \in {\rm I\!N}_0$ the condition
23:25:56 <a5> Cale: do you know Morse-Kelley set theory?
23:26:01 <smott> oops, sorry about that
23:26:06 <Cale> nope
23:26:40 <a5> you can be forgiven. morse is my step-grandfather :)
23:27:17 <Cale> smott: This does look a lot like #math at the moment :)
23:27:31 <epichrom> Am I in #math?  I'm looking for #haskell....
23:27:45 <Gahhh> I think I am in ##ocaml
23:28:32 <a5> it's #haskell
23:28:55 <Pseudonym> Dammit, I'm in the wrong channel again.
23:29:09 <a5> that's right
23:29:21 <a5> :)
23:29:29 <Gahhh> how about some monadic physics
23:29:51 <a5> tell us
23:30:10 <Gahhh> I was hoping mwc would jump in
23:30:55 <epichrom> I think I'm in a nightmare and I should go to bed now so I can wake up.
23:30:58 <epichrom> :)
23:31:06 <mwc> Nah, I just like to arbitrarily impose my understanding of the universe on set theory
23:31:17 <mwc> Category theory I'd need to look up on wikipedia :P
23:32:31 <Gahhh> I think it's more appropriate to impose our understanding of physics of the brain to mathematics.
23:32:50 <Gahhh> "why does this grey matter come up with this stuff"
23:33:13 <epichrom> because it's a Markov chain
23:33:43 <mwc> nah, I thought we established that determinism is wishful thinking
23:34:12 <epichrom> so try neo-determinism
23:34:31 <Gahhh> Microsoft says: that's not a bug; it's just nondeterminisim.
23:34:34 <Cale> mwc: do you know what the axiom of determinacy is about?
23:35:07 <mwc> Cale: not in any rigourous sort of way
23:35:08 * epichrom conjures an AC++ and an AD#
23:35:15 <Cale> :)
23:35:38 <Cale> mwc: It basically says that certain games have a winning strategy
23:35:53 <mwc> sounds more like Game theory, but go on
23:36:20 <Gahhh> drive hard to the basket -- look for the open outside shooters.
23:37:01 <Cale> It implies lots of nice things about measure theory
23:37:55 <mwc> Cale: does it go by another name?
23:38:02 <mwc> Can't find it here: http://mathworld.wolfram.com/topics/GeneralSetTheory.html
23:38:31 <Cale> http://en.wikipedia.org/wiki/Axiom_of_determinacy
23:40:34 <mwc> Hmm, that assertion seems shaky to me
23:41:53 <a5> i take it you can't replace \omega^\omega with 2^\omega
23:42:26 <Cale> well, it's independent of ordinary set theory, so it's up for grabs
23:43:00 <a5> what?
23:44:16 <Cale> That is, it is a statement about sets which is made neither true nor false by ZF.
23:49:20 <Cale> a5: that wasn't referring to your statement
23:49:35 <Cale> \omega^\omega and 2^\omega are different
23:52:42 <Cale> oh, wikipedia says that AD hasn't been shown independent?
23:52:55 <Cale> I was fairly certain that it had been
23:55:02 <JohnMeacham> Yay. jhc now has a stopgap garbage collector while I work on the region inference algorithm.
