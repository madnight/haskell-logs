00:30:00 <andersca_> boom!
00:31:31 <Gahhh> touchdown !
00:32:43 <lispy> i heard an interesting factoid today.  If Moore's law continues to hold past 2010 then transistors will be the size of atoms.
00:34:26 <Gahhh> with die size held constant I assume
00:36:02 <tromp> it'll take until 2017
00:36:21 <tromp> to reduce feature size from 90nm to 0.3nm
00:36:59 <tromp> r although you'll prolly never see it below 10nm
02:20:41 <rtega> tromp: the end is very much near
02:28:57 <tromp> the end of shrinkage?
02:35:05 <tromp> plans exist to transition from 90nm to 65, then 45, then 32nm
02:35:43 <tromp> but i'm sure that last one is over 10 years away
02:47:21 <faiv> Any one understands free ring  categorically?
02:50:39 <faiv> join math
02:52:02 <boegel> faiv: Cale is your man (probably)
03:08:41 <JaffaCake> dcoutts_: the foreign import "&" fixes and the amd64 foreign import "wrapper" code is now merged
03:49:45 <glimming> How do I get a string containing backslash in Haskell
03:49:50 <glimming> e.g.
03:49:53 <glimming> "\"
03:49:56 <glimming> does not work
03:50:06 <JaffaCake> "\\"
03:50:22 <glimming> That gives me "\\"
03:50:30 <glimming> with show
03:50:34 <JaffaCake> that's right
03:50:39 <glimming> aha
03:51:46 <goltrpoat> i suspect i'll be asking a large amount of dumb questions in the coming days.
03:52:40 <goltrpoat> figured writing a program to calculate the derivative of an expression would be a good first haskell project
03:53:52 <goltrpoat> and parsing seems to be mildly less intuitive than it was in scheme..  hell of a lot more elegant once you get it, not to mention fewer parentheses, but still.
03:56:46 <skew> I think that describes Haskell as a whole pretty well
03:57:04 <skew> extremely elegant, not as immediately intuitive as some other languages
03:58:07 <skew> but then, I doubt people have good inborn instincts for mathematics or programming language design
03:58:54 <skew> how did the derivative stuff work out? That part should have been very nice
03:58:56 <goltrpoat> well.. im in a pretty common situation probably, been coding for 16 years or so, but just recently started playing with functional languages
04:00:13 <goltrpoat> well..  wrote the tokenizer yesterday, made it prettier today.  probably going to start on expression parsing tomorrow
04:00:58 <goltrpoat> im writing a compiler at work (in c++), so coming home and doing the exact same thing but in a totally different environment is a bit of a mindfuck
04:01:21 <skew> Ah, so unintuitive probably also means unlike languages you already know. That's even less surprising. Once you get some core ideas things start to fit together faster
04:02:26 <skew> I doubt I could stand writing an interpreter in anything but Haskell
04:03:15 <skew> I once wrote an interpreter in Python that was very nearly in monadic style, though somebody up on OO trends would probably talk about visitor patterns and command objects and the like
04:04:26 <skew> I don't like writing parsers very much, so I usually start by defining the AST and get internals working before I do the parser
04:05:12 <goltrpoat> yeah.  actually, the compiler project was what made me want to start looking at other languages.  c++ is definitely not optimal for that type of thing
04:05:21 <skew> Do you have any good pointers on compiler construction in C++ (or OO languages in general)?
04:05:48 <goltrpoat> any specific part of it? :)
04:06:11 <skew> what sort of objects to use, how to organize them
04:07:03 <skew> There's probably some way to represent the AST nicely, maybe even get some flexibility is places Haskell doesn't give you
04:07:45 <goltrpoat> i don't have an explicit AST actually.  the expression parser builds a list that essentially contains the in-order traversal of the AST, and collapses it as it goes
04:07:58 <skew> I'm learning Ruby at the moment, so I'm interested in how to do things nicely with objects
04:08:07 <skew> how did you write your tokenizer?
04:08:47 <skew> It's my duty here to mention that there are good tools like alex, happy, and parsec
04:08:51 <goltrpoat> the tokenizer takes an input stream and dumps out tokens, which are string literals paired up with a typeid.  it's a single character lookahead
04:09:02 <goltrpoat> the language is very c++ like, and the c++ tokenizer is greedy
04:09:22 <goltrpoat> so it's pretty simple.  i remember reading that tokenizing eg haskell is more difficult than it looks.
04:09:23 <skew> alex is pretty much functional lex
04:09:40 <skew> There are some rules that I think nobody actually implements
04:10:22 <skew> I think there is one about some expressions extending as far as they can without producing a type error
04:10:34 <goltrpoat> i never went the lex/yacc route.  i remember talking to a few people who'd used them in the past, and they were saying that it's hard to use them for anything but toy languages.  and i think i just wanted to see how it all works at the time
04:10:49 <skew> you might be interested in Parsec
04:11:01 <goltrpoat> link?
04:11:31 <goltrpoat> found it, i think..  http://www.cs.uu.nl/~daan/parsec.html ?
04:12:02 <skew> that looks good
04:12:05 <goltrpoat> there seems to be a simulation language called 'parsec' as well, being developed at ucla.  from par/seq, i guess.
04:12:26 <skew> Other parser/compiler tools are listed here http://www.haskell.org/libraries/#compilation
04:12:47 <goltrpoat> oh coolness.  thanks
04:13:04 <skew> I've only used Happy, Alex, Parsec, and the Utrecht combinators, UU_AG.
04:13:54 <skew> oops, UUAG is the Utrecht attribute grammar system which is a very cool and possibly very useful tool not listed on the library page
04:14:09 <goltrpoat> oh wait..  when you said 'how did you write your tokenizer', did you mean the one in haskell, for the derivative thingamabob?  i assumed you meant the compiler at work
04:14:12 <skew> their parsing combinators are called UU_Parsing I think
04:14:34 <skew> oh, I was talking about the Haskell one
04:14:38 <goltrpoat> ohh
04:14:47 <skew> why would a greedy tokenising rule prevent you from using lex?
04:15:10 <skew> I'm pretty sure lex grabs the longest prefix of the remaining input that matches any of the regular expressions you feed it
04:15:39 <goltrpoat> it's mildly ass-backwards.  it takes a string, writes out (groupBy (\x y -> (tokenClass x == tokenClass y)) str), where tokenClass basically classifies a char as operator, punctuator, digit, identifier or whitespace
04:16:03 <skew> to parse C you need a bit of a hack to feed the typedef names back to the lexer so it can report them as types rather than identifiers, or so I've heard
04:16:29 <skew> that is, if you want to use lex and yacc I hear that you need to use that hack, but other than that it's supposedly works pretty well
04:16:46 <goltrpoat> the actual tokenizer takes that and removes elements that are strings consisting of spaces, and dumps out a list of pairs of (stringliteral, typeid)
04:17:03 <skew> the Haskell one now?
04:17:09 <goltrpoat> yeah :)
04:17:32 <skew> I've never written compilers professionally in C though, so I don't really know. I've never even had the patience to write a complete C parser, actually
04:17:49 <goltrpoat> i didnt say that greedy tokenizing would prevent you from using lex btw
04:18:32 <goltrpoat> C is fairly simple to compile, actually.  i mean, K&R C compiler is probably a two week project even in C++
04:19:01 <skew> hmm, I wonder where I got that idea then
04:19:14 <skew> I've wondered if you could write a C compiler with a few passes of sed, actually
04:19:22 <goltrpoat> hehe
04:20:07 <goltrpoat> this is somewhat interesting:  http://compilers.iecc.com/crenshaw/
04:20:13 <skew> use different runs to turn the input into slighlty processed input, and a sed file for handling the defined names, then run the one through the other
04:20:35 <goltrpoat> a lot of it is either overly simplified or plain wrong, but he seems to make an effort towards simplifying a lot of the subtasks that are traditionally considered "complex"
04:22:49 <goltrpoat> eg the expression parser is fairly elegant..  although he's hardcoding the different levels of precedence, which is rather prohibitive if you have 15 of them, say.
04:23:05 <goltrpoat> but that's where i got the idea of not having an explicit AST
04:24:02 <skew> I'm not sure if that's a good idea
04:24:34 <goltrpoat> you mean from the high-level optimization standpoint?
04:24:44 <skew> no, just from simplicity of writing the program
04:25:00 <skew> Actually, mostly for the value in learning Haskell
04:25:06 <goltrpoat> oh.. no, that actually simplifies it a lot
04:25:14 <skew> Algebraic data types make a pretty nice AST
04:25:40 <goltrpoat> sorry, i keep jumping back and forth between the compiler and my haskell project
04:26:01 <skew> Let you define an AST pretty easily, that is. Certainly working with an AST will be a good introduction to working with algebraic data types
04:26:05 <jaap> goltrpoat: Crenshaw is a nice read, but a *very* old-fashioned approach to compilers IMHO
04:26:09 <goltrpoat> yeah
04:26:18 <Philippa_> seconded
04:26:20 <skew> what is the C++ thing compiling?
04:26:26 <goltrpoat> philippa
04:26:28 <Philippa_> Crenshaw's nice to get you playing quickly
04:26:36 <Philippa_> but that's about it, and really you don't wanna work in C no more
04:27:00 <Philippa_> 'lo goltrpoat. Took me a while to remember which chan I was in :-)
04:27:06 <jaap> Crenshaw was written back when the consensus was that parser generators are too slow, and multiple passes are too slow, so evrything should be in a single handcoded pass for maximum efficiency, modularity be damned
04:27:10 <goltrpoat> skew:  the language is basically c++ plus rudimentary coroutine support and functions as first-class objects in certain isolated cases.
04:27:13 <Philippa_> sadly I gotta go get ready for important stuff real soon - I'm still in what I was wearing last night
04:27:41 <goltrpoat> jaap:  well, one immediate problem with his stuff is that you can't even do constant folding with what he's doing
04:28:04 <goltrpoat> since he's not keeping track of the stack
04:28:37 <skew> that sounds pretty interesting. What are you intending to use the language for? Distribution, internal tool writing, research?
04:28:45 <Philippa_> game scripting
04:28:53 <goltrpoat> what philippa said
04:28:54 <Philippa_> (I know goltr from elsewhere, in case you hadn't guessed)
04:29:05 <goltrpoat> internal for a while.
04:29:08 <skew> interesting
04:29:26 <Philippa_> okay, shower. Goltr, good luck getting useful stuff out of these guys - it's prolly worth hanging around a while, interesting stuff happens at random far more than on #flipcode these days
04:29:39 <goltrpoat> philippa:  seems like it :)
04:29:42 <goltrpoat> later
04:29:54 <skew> Are you leaving out most of the complicated C++ stuff?
04:30:07 <goltrpoat> im leaving out most of the template handling
04:30:22 <skew> Okay, that probably helps a lot
04:30:35 <goltrpoat> you can specialize templates that are defined and implemented externally
04:30:50 <goltrpoat> but you can't eg define them natively
04:31:29 <skew> It sounds like a lot of work to get a bit of scripting...
04:32:08 <goltrpoat> well.. it drives large chunks of the system
04:32:44 <skew> I guess I'm mostly wondering what's so much better than just writing C++ if it's almost C++, and needs to be fast besides
04:32:51 <goltrpoat> it's actually sort of funny, after finalizing the design, we realized that we could write the entire app in script
04:33:16 <goltrpoat> the problem domain is somewhat specific
04:33:38 <goltrpoat> c++ was not designed as a parallel language, this one was
04:33:44 <skew> so it's domain specific, but a bit inspired by C++?
04:33:47 <skew> or mostly C++?
04:33:49 <goltrpoat> right
04:33:59 <skew> I'll take that as the first
04:34:00 <goltrpoat> it's mostly C++, but with several changes that make it fit the domain
04:34:09 <skew> oh, guess from timing wrong..
04:34:18 <goltrpoat> hehe
04:34:27 <skew> I guess you just type really fast
04:35:36 <skew> is the domain just being parallel, or more besides?
04:36:45 <goltrpoat> bit more than that.  initially, the language was designed to write node evaluators for a state graph
04:37:33 <skew> I guess it's a bit late for advice, but did you look at stuff like Cilk, or languages with lightweight userspace concurrency (eg Erlang, stackless Python, Haskell :) )
04:37:46 <goltrpoat> so it's like..  if we have a state machine, with f(input, state) = output, then the language was designed to implement f
04:38:05 <goltrpoat> input/output is constrained to vertices in a graph, hence state graph.
04:38:27 <skew> I'm not trying to tell you waht to do, I really want to know what design considerations lead to implementing your own compiler
04:38:40 <goltrpoat> so you have an evaluator function that runs, for a given agent in a given state, evaluates inputs, and goes, ok, i'm going to transition to another state.
04:38:43 <skew> and I'm just trying to outline your rationale with soem questions
04:39:18 <goltrpoat> yah, no problem :)  i looked at python, lua, ruby and a few others
04:39:20 <skew> That sounds vaugely related to something I want to write, and Aardappel interpreter
04:39:33 <goltrpoat> i wouldve had to retrofit them one way or another
04:39:59 <goltrpoat> ruby and .. uh.. something else, was out right from the start since there are no compilers for it
04:40:17 <skew> oh, so you need lots of speed too
04:40:22 <goltrpoat> yeah
04:40:39 <goltrpoat> as in, i'm pretty sure i'll end up writing a JIT for this thing in the near future
04:40:43 <skew> There's a graph involved too?
04:41:21 <skew> Aardappel is an wierd language designed around concurrently applying tree rewrite rules
04:41:30 <goltrpoat> conceptually.  it also helps people visualize how things work, if you present potential transitions as directed edges.  so i can go from "idle" to "walk" to "run" back to "idle", but i can't go from "walk" to "lightswitch_on", since i'm not a lightswitch.  etc.
04:41:53 <skew> oh, each agent has a state graph and you need them to transition
04:42:08 <skew> I was thinking about a graph of agents, where the applicable transition rules depended on the current set of neighbors
04:42:14 <goltrpoat> right.  it's one state graph, but each agent occupies exactly one node at a given time.
04:42:20 <goltrpoat> oh
04:42:41 <skew> so how is this not an FSM?
04:42:51 <goltrpoat> it's exactly an FSM
04:43:01 <skew> I mean, what extra data are you making the transition decisions with?
04:43:14 <goltrpoat> you associate a script function with each node
04:43:26 <goltrpoat> if an agent is in a given state, it runs that function on itself
04:43:47 <goltrpoat> which then evaluates situation and decides if/when to transition
04:44:07 <skew> It sounds like you could lightly preprocess your language into something with a label for each state and a bunch of gotos
04:44:28 <skew> except that doesn't buy you parallelism, I guess
04:44:38 <goltrpoat> -nod-
04:45:00 <skew> Except if you translate to Cilk, I guess. Have you looked at that? It's some kind of concurrent C MIT has been building for a while
04:45:41 <goltrpoat> is it anything like handel-c?
04:46:06 <goltrpoat> oh.  doesnt look like it
04:46:16 <skew> where can I find actual information on that language?
04:46:26 <goltrpoat> which
04:46:33 <goltrpoat> handel-c, or what im working on?
04:46:35 <skew> Handel-C, the main company site isn't willing to give it up easily
04:46:41 <goltrpoat> oh
04:46:50 <goltrpoat> hmm i remember looking at a few links a while back, gimme a minute
04:48:07 <goltrpoat> one of my partners worked at celoxica for about 8 years, the only reason i know about it is that he mentioned some of the constructs in it and i got interested
04:48:38 <goltrpoat> http://www.pa.msu.edu/hep/d0/l2/Handel-C/Handel%20C.PDF
04:48:41 <goltrpoat> try that one
04:48:49 <goltrpoat> brb smoke
04:50:15 <jaap> has anyone else noticed haskell-mode in emacs taking vastly excessive amounts of CPU? I'm trying to program in Haskell on my laptop, and between GHC eating all my memory and haskell-mode eating all my CPU, it isn't going too fast.
04:50:39 <jaap> i went to buy some memory at Fry's, but they gave me a bad stick...
04:52:01 <skew> I just grabbed haskell-mode as part of my plan to learn emacs
04:52:33 <skew> A buffer sitting there with two lines of code doesn't seem to suck up any CPU
04:52:44 <jaap> i think it's a peculiarity of my machine, somehow, that it doesn't work right; if it were this awful on other ppl's machines i'd have known it
04:53:13 <jaap> I have the impression that the main problem is when it tries to talk to a ghci session that no longer exists, and it goes into some sort of tight loop
04:53:17 <skew> It doesn't seem to be doing anything intelligent with indentation, though
04:53:29 <skew> Oh, I haven't spawned ghci with it
04:53:31 <jaap> tried pressing Tab multiple times?
04:53:48 <skew> yeah, it seems to just insert more space
04:53:56 <jaap> hmm...
04:54:06 <skew> hmm, there's no M-x inferior-ghci
04:54:08 <goltrpoat> jaap:  btw, are single-pass compilers considered to be a bad idea?  im single-pass right now, with a peephole optimizer planned as a second pass
04:54:40 <goltrpoat> well.. it's more like 1.5 pass, since i have to do a bunch of stack frame fixups
04:55:15 <jaap> goltrpoat: in general, it is easier to debug and keep track of if you first lex, then parse, then transform into a simpler language, then produce code, then allocate... than if you do it all at once, but it depends a lot on what's getting compiled to what
04:55:32 <jaap> e.g. if you're compiling into a high-level language rather than assembly it's different
04:55:33 <goltrpoat> oh im not counting the lexer
04:56:11 <jaap> i dunno, it depends on your taste, but to my taste putting much of anything into a parser but parsing is not very nice
04:56:12 <goltrpoat> speaking of, apparently gcc compiles to a lisp-like RTL as its intermediate language.  thought that was mildly weird.
04:56:32 <goltrpoat> hmm, yeah i see that.
04:56:42 <jaap> hmm... is it lisp-like to the extent that it is a tree-like data structure that they print out using parentheses?
04:56:55 <jaap> that's what i seem to recall
04:57:04 <goltrpoat> haha
04:57:14 <skew> I suppose a carefully designed Haskell program could use laziness to process a file in a single pass, and still be written modularly
04:57:31 <goltrpoat> i dont know, i didnt look into it too deeply.  it seemed like they were saying that it's a lisp derivative of some sort
04:57:42 <goltrpoat> that they're using as an RTL for the backend
04:57:56 <skew> jaap: how did you run the ghci?
04:58:01 <goltrpoat> which.. an RTL makes sense, but compiling to a higher-level language seems a bit ass-backwards
04:58:19 <goltrpoat> (rather, i should say, an RTL makes sense for a cross-platform compiler)
04:59:05 <jaap> in principle. if you are concerned about the efficiency of your compiler, the first thing to optimize is the lexer, because the n in O(n) is very big (every character in the file), and the second thing to optimize is the register allocator (if you have one), because it's usually a nasty exponential algorithm. in most compilers, the phases that operate on abstract trees and have no nasty exponential algorithms in them are very fast and not really worth
04:59:28 <goltrpoat> im compiling to a stack machine
04:59:45 <goltrpoat> i suspect i'll end up with the VM doing register allocating when i switch to JIT
04:59:54 <goltrpoat> allocation rather
05:00:15 <Philippa_> make sure the VM gets as much relevant info about that as is sane
05:00:21 <jaap> ah. stack machines eliminate the need for nasty register allocaters, mostly, so you're fine on that front then
05:00:26 <jaap> skew: (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
05:00:57 <Philippa_> jaap: depends quite how fast you want to go, no?
05:01:05 <Philippa_> I mean, it starts to make real sense on x86...
05:01:24 <skew> how does that work, and where does it go? Not in M-x, apparently
05:01:32 <goltrpoat> i honestly dont know how i'll approach register-rich architectures
05:01:36 <jaap> philippa_: an x86 is not really a stack machine, though. it provides stack manipulation instructions, but it has enough registers (barely) that it pays to treat it as a register machine
05:01:39 <jaap> skew: in .emacs
05:01:50 <skew> does it work in M-x eval-expression?
05:01:58 <Philippa_> jaap: it's still a lot more appropriate than it would be on MIPS (PS2)
05:02:26 <jaap> skew: you can stick it in an elisp-mode buffer, go to the end of it and do C-x C-e
05:02:53 <skew> it didn't seem to do anything with eval-expression
05:02:58 <jaap> skew: all it does is to automatically execute that every time you enter haskell-mode, so it makes no sense to do once
05:03:14 <jaap> skew: if you just want it now, just do M-x turn-on-haskell-ghci
05:03:41 <skew> okay, that makes sense
05:03:49 <goltrpoat> it seems to make more sense, conceptually, when compiling to a register-rich architecture, to pretend you have an infinite number of registers and put the overflow on the stack, as opposed to turning push acc / change acc / op acc, [stack] into register operations all over the place
05:04:12 <goltrpoat> (thinking MIPS here, yeah)
05:04:52 <musasabi> On i386 there is lots of register renaming which adds a twist to register allocation..
05:05:44 <jaap> goltrpoat: that is surely the simplest solution
05:06:21 <goltrpoat> -nod-
05:06:27 <jaap> goltrpoat: usually, an optimizing compiler will first compile to an IR that assumes an infinite number of "local variables, " wherever those go, and then have a separate graph-coloring thingy to allocate registers
05:07:18 <skew> and graph coloring is hard (NP)
05:07:24 <goltrpoat> hmm..  i think i should be able to get away with just doing what im doing and then replacing parts of the backend
05:07:45 <jaap> skew: indeed.
05:08:01 <jaap> goltrpoat: well, you're compiling to a VM, and thus you get to choose
05:08:05 <goltrpoat> there's a bunch of NP problems that pop up in optimizing compilers, i think
05:08:21 <skew> hardware synthesis seems to consist entirely of NP problems
05:08:32 <jaap> goltrpoat: I bet you. and undecidable ones to. in fact, optimal compilation is undecidable in principle.
05:08:56 <goltrpoat> jaap:  the VM is very low-level.  basically, i have the compiler dumping out something that looks a lot like x86 assembly, the assembler dumps out bytecode, and by the time the VM runs it, it has very little clue of the context
05:09:18 <goltrpoat> peephole optimization = BP, afaik :)
05:09:35 <goltrpoat> but that's one of the simpler ones, greedy algorithms work well on BP
05:09:46 <goltrpoat> 2-approximations, iirc
05:11:18 <skew> apparently there are some good approximation algorithms for the decision problem
05:11:55 <jaap> skew: sure, and similarly there are some good approximation algorithms for opttimal compilation
05:12:20 <goltrpoat> oh for got to mention..  skew:  if you're interesting in parallel stuff like handel-C, make sure to check out CSP if you haven't already.
05:12:25 <skew> I doubt there are approximation algorithms in the technical sense for optimal compilation
05:12:40 <goltrpoat> fuck, i seem to have lost the ability to type.
05:12:43 <goltrpoat> interesting=interested.
05:12:51 <Philippa_> goltrpoat: there's a few folks in here've played with the pi calculus, you might find that interesting
05:13:20 <jaap> skew: you mathematicians and your algorithms theory ;-)
05:14:00 <goltrpoat> philippa:  im actually pretty weak in this area.  been meaning to read up on it, havent had the chance to
05:14:03 <skew> approximation means you know it get yous e.g. half the optimum, the benefit usually being polynomial rather than exponential complexity
05:14:13 <skew> gets you, that is
05:14:28 <Philippa_> I have to admit, myself I'd probably pick something that looks a bit like Concurrent Haskell for a scripting language - it feels a lot like the pi calculus' grown-up, lambda-translation-done-for-you cousin
05:14:43 <goltrpoat> skew:  yeah, in algorithmics of hard problems you'll usually see stuff like "algorithm A is a 2-approximation to problem P"
05:15:01 <goltrpoat> "here's why"
05:15:01 <skew> yep, I don't think that works so well for undecidable problems
05:15:16 <bourbaki> moin
05:15:31 <Philippa_> 'lo. OK, I gotta go grab forms'n'stuff
05:17:40 <skew> for your Haskell program you should look at parsec
05:18:01 <skew> there's an included module that builds an expression parser, given a list of the operators at different precedence levels
05:18:11 <goltrpoat> whoa.
05:18:24 <goltrpoat> that makes things a bit easier.
05:18:38 <goltrpoat> i should probably write it from scratch anyway for the experience, but what's the module?
05:19:13 <skew> other stuff for generating nice parsers that match the lexical structure of your language, taking into account eating whitespace, and working with keywords and identifiers nicely
05:19:34 <skew> Text.ParserCombinators.Parsec.Expr
05:19:42 <skew> Parsec is included with recent ghc
05:20:04 <goltrpoat> hehe i think i wrote about 5 different functions to eat whitespace since yesterday..  i hope at some point i get out of the whole "dammit this needs to be prettier" mode
05:20:29 <bourbaki> does haskell support distributed network objects?
05:20:56 <skew> at least 6.4 and 6.2.2 come with parsec, I doubt you have an older version
05:21:10 <skew> bourbaki: not especially, as far as I know
05:21:19 <bourbaki> a pitty
05:21:26 <skew> nothing like moving code around a network and so on, at least
05:21:52 <bourbaki> like in lisp?
05:21:56 <skew> goltrpoat: doesn't your lexer handle whitespace, either project
05:22:07 <goltrpoat> what would be ridiculously cool is if there was a way to integrate haskell with eg., c#.  since the latter makes distributed computing just work, more or less.
05:22:44 <bourbaki> heh
05:29:10 <skew> jaap: how do I get at that ghci?
05:29:10 <goltrpoat> skew:  the compiler does of course.  the expression differentiation one eats whitespace before passing it to the lexer, since that way it knows it has valid input.
05:29:10 <bourbaki> is there anything real beside c#? that does distributed network objects? with low latency and such
05:29:10 <bourbaki> cause i want to use it for a game
05:29:10 <goltrpoat> well.  one of my partners wrote a build farm in a stupidly short amount of time with c#, from what he was saying, it just worked.
05:29:10 <goltrpoat> im in gamedev, btw.  c# seems to be making a splash in it (mostly client code, networking code and tools though)
05:29:10 <skew> jaap: turn-on-haskell-ghci doesn't seem to have resulted in horrible CPU usage
05:29:10 <jaap> skew: to load the current file into a ghci C-x C-l, to just execute :r in the current GHCI C-x C-r
05:29:10 <bourbaki> goltrpoat: its bad to infer things by single occurences :)
05:29:10 <skew> jaap: C-x X-l seems to be downcase-region here
05:29:10 <jaap> skew: i'm switching to using my free ITS ibook for now, I had some extra memory for that sitting around already
05:29:10 <jaap> skew: replace C-x by C-c
05:29:10 <goltrpoat> generally, yeah.  but we've gone through so many different development environments that the focus tends to be on the negative
05:29:10 <jaap> skew: also it has no IRC, which makes *me* faster ;-)
05:29:10 <skew> I've started and killed a few ghci instances (with :q in the ghci), but no CPU beyond spikes when GHCi starts
05:29:10 <jaap> skew: how much physical ram do you have?
05:29:10 <goltrpoat> bourbaki:  what are you doing with distributed network objects btw?  just curious
05:29:10 <skew> 256MB
05:29:10 <bourbaki> goltrpoat: i want to write a game
05:29:10 <bourbaki> the problem is that there is no really good network lib running on all systems
05:29:10 <goltrpoat> oh i think im misinterpeting.  took the 'distributed' part too literally and thought you wanted a farm of some sort
05:29:10 <bourbaki> so haskell would have been a good choice
05:29:10 <bourbaki> goltrpoat: well i want to have certain game objects that get distributed
05:29:12 <goltrpoat> is this server-client or peer to peer
05:29:38 <bourbaki> mixed topology
05:29:56 <goltrpoat> fun
05:29:57 <bourbaki> i want to update the player object ie peer to peer like from the server to the client
05:30:02 <goltrpoat> just curious -- why mixed?
05:30:13 <bourbaki> i just try to get this within some framework
05:30:27 <bourbaki> well i want to have several different types of servers
05:30:30 <bourbaki> like a map server
05:30:39 <bourbaki> and the map server itself is heiriachically
05:30:44 <bourbaki> like in the dns lookup case
05:31:48 <bourbaki> and then there are several map servers in each node
05:31:59 <bourbaki> which have a ring topology or distributed
05:32:03 <bourbaki> havent decided on that yet
05:32:17 <bourbaki> so they run in sync on the node level so you always get a good ping to them
05:33:14 <goltrpoat> with mmos, there seems to be a pretty standard formula..  all servers (game, logon, billing, database, etc) sit there locally, and one single thing acts as a proxy
05:33:37 <goltrpoat> but.. im not a networking or db guy, we're just sharing office space with a company that's been running an mmo for a while so things rub off
05:34:33 * TheHunter files a bugreport, hoping that it isn't already a known issue.
05:34:42 <goltrpoat> and it's very strictly client-server
05:35:01 <bourbaki> goltrpoat: i want my game to be distributed
05:35:10 <bourbaki> like in the old days with the muds
05:35:19 <goltrpoat> ??  muds weren't distributed
05:35:19 <bourbaki> everyone can contribute to the game
05:35:32 <bourbaki> i mean you were able to add sites to the mud
05:35:39 <musasabi> I think the greatest challenge is a good world and gameplay, not technical implementation details ;)
05:35:39 <bourbaki> i just want to outsource the sites
05:35:42 <bourbaki> like a website
05:35:49 <goltrpoat> muds sat on a single server, and you had admins and builders logging in on a special port
05:36:11 <bourbaki> musasabi: atm it is cause i need a lib that does DNO on osx linux and windoze
05:36:18 <goltrpoat> that had a Secret Password.  or something.
05:36:21 <musasabi> DNO?
05:36:28 <bourbaki> distributed network objects
05:37:14 <musasabi> corba ;p
05:37:14 <bourbaki> its quite slow isnt it?
05:37:25 <bourbaki> www.opentnl.org is what i want to pick now
05:37:46 <musasabi> On the serious side you can serialize haskell values and send them over the network, but there is no real support for DNOs as they are a fundamentalle statefull concept.
05:38:22 <bourbaki> im not too sure if i really want to do this in haskell cause there is no embeddable haskell
05:38:40 <bourbaki> and some things are too complicated for me to write them in haskell
05:38:40 <skew> bourbaki: what do you mean embeddable?
05:39:10 <skew> you can compile Haskell code into other programs
05:40:02 <bourbaki> what i want to do is set up all the network stuff in c++
05:40:20 <bourbaki> and then have some embedded language that handles all the objects and the engine part
05:40:39 <bourbaki> which is steered via the messages that are send within the network
05:40:40 <goltrpoat> like i said, this is not my area, but just logically speaking, it seems like the only reason you'd want peer-to-peer is redundancy
05:40:48 <goltrpoat> eg bittorrent
05:40:52 <bourbaki> so there would habe to be a haskell interpreter for my idea
05:41:07 <goltrpoat> musasabi:  jesus.  you said the C-word.
05:41:11 <skew> I think hs-plugins does what you want
05:41:29 <bourbaki> goltrpoat: yes redundancy to get a better ping from server to client
05:42:03 <skew> at least as far as dynamic loading of Haskell
05:42:45 <bourbaki> hm
05:42:55 <bourbaki> i would like to have haskell in certain parts of the game
05:43:04 <bourbaki> but i would like to have scheme or prolog in other parts
05:43:07 <musasabi> true C is very evil..
05:43:28 <bourbaki> :)
05:43:43 <goltrpoat> from what i remember, corba is like a bastardized non-working undocumented version of COM
05:43:45 <musasabi> as is C*rb*.
05:44:20 <musasabi> goltrpoat: I would like to say it in reversed order.
05:44:28 <goltrpoat> or.. well, no, not undocumented.  it's very well documented, it's just that the implementations don't actually implement the standard.
05:44:47 <bourbaki> there are a lot of other frameowrks like ilu
05:44:47 <goltrpoat> so you get a lot of "well, this is what it *should* be like"
05:44:49 <musasabi> Corba is just too heavy and overspecsed and does not work for any given real-world problem.
05:44:55 <bourbaki> er corba ... like ilu :)
05:45:18 <bourbaki> i wonder why there is nothing like the liunx virtual file system for something like that
05:45:44 <bourbaki> if all your objects would be data in a virtual file system with streams this would be not a problem right?
05:46:01 <mflux> it would be really cool if unix domain sockets/named pipes would work over nfs ;)
05:46:13 <goltrpoat> com is actually mildly interesting from a language standpoint.  it seems like a bunch of people with not a whole lot of OOD knowledge tried to implement dynamic typing
05:46:30 <goltrpoat> and did it reasonably well, considering the circumstances
05:46:35 <goltrpoat> but it's still rather ass.
05:47:11 <goltrpoat> (it's even more ass if you're not a fan of dynamic typing)
05:47:42 <bourbaki> well its not that it needs to be dynamic
05:47:55 <bourbaki> i just want to have something like internet shared memory
05:48:08 <bourbaki> and this could as well be implemented on system level already
05:48:16 <bourbaki> like threads with mutex and such
05:48:20 <goltrpoat> yeah that's what a farm is
05:48:27 <bourbaki> hm
05:48:40 <bourbaki> but this is not speedy is it?
05:48:42 <goltrpoat> like i said, c# seems to have a lot of that functionality built in
05:48:49 <mflux> bourbaki, there is a distributed shared memory patch for openmosix
05:48:51 <goltrpoat> no, of course not.  i dont think you could make it speedy.
05:49:02 <bourbaki> well c# is nothing i am going to use since its only running on x86 wondoze
05:49:12 <goltrpoat> no, that's wrong
05:49:41 <goltrpoat> mono is an opensource .net runtime, iirc.  you can run c# code on just about anything, modulo bugs.
05:50:08 <andersca_> mono is pretty cool
05:50:12 <bourbaki> hm
05:50:23 <SM_ax> where to get mono?
05:50:26 <bourbaki> but that mono thingy is just usable in java right?
05:50:35 <goltrpoat> what does java have to do with any of this
05:50:36 <bourbaki> i remember there was some tradeoff as well
05:50:45 <skew> goltrpoat: this seems to be the right website for the attribute grammar system http://www.cs.uu.nl/wiki/Center/AttributeGrammarSystem
05:50:54 <bubblesort> hi
05:51:15 <skew> hi
05:52:43 <goltrpoat> embarassing question.  is haskell LA?  or LALR?
05:53:13 <goltrpoat> LR rather on the first one.
05:53:37 <skew> I don't think it is actually either
05:54:28 <skew> at least, I think the layout rule certainly require preprocessing
05:54:48 <goltrpoat> right, you can't resolve identifiers on the first pass
05:55:15 <goltrpoat> but i just meant the grammar, assuming all identifiers are automatically assumed to be kosher
05:55:26 <skew> oh, operator parsing is really tricky too
05:55:36 <goltrpoat> the layout should be taken care of by the lexer, no?
05:55:44 <skew> yes, probably
05:56:39 <goltrpoat> since you generally want a token stream, it'd probably just insert {}s all over the place
05:56:57 <skew> that's how it is defined
05:57:00 <goltrpoat> so that layout information doesnt get to the parser
05:57:03 <goltrpoat> right
05:57:14 <skew> reading that section of the report helps to understand how to use layout
05:57:28 <skew> at least if some cases seem mysterious to you
05:58:42 <goltrpoat> it seems fairly straightforward
05:59:03 <skew> if you account for operator precedence declarations somehow I think the language is mostly LALR
05:59:03 <goltrpoat> indent blocks, outindent when you leave them
05:59:32 <swiert> what's the easiest way to get the contents of a web from Haskell program?
06:00:22 <goltrpoat> hmm..  plenty of LALR languages have operator precedence declarations and associativity in both directions.. am i missing something
06:00:23 <swiert> *web page from a Haskell program*
06:00:55 <skew> goltrpoat: I don't know of many languages where the program can define its own operators and specify their precedence and associativity
06:01:03 <goltrpoat> er.  pardon, not precedence *declarations*
06:01:53 <goltrpoat> but in, eg., c++, you have the unary operator ++() for instance, which is either prefix or postfix.  the two versions have different precedence and different associativity
06:01:59 <goltrpoat> and the parser has to figure out which one is which
06:02:22 <mflux> operator ++() is for prefix, operator ++(int) is for postfix?
06:02:29 <goltrpoat> ++x or x++
06:02:33 <mflux> or what was your point :)
06:02:41 <goltrpoat> preincrement vs postincrement
06:03:23 <SM_ax> only ++x can be defined afaik
06:03:29 <skew> technially, a let or lambda is supposed to extend as far as possible, so something like \x -> True == True == True is supposed to parse as (ill-typed)  (\x -> True == True) == True
06:03:42 <skew> SM_ax: that's what operator ++(int) is for
06:03:47 <goltrpoat> one's RA, one's not, one's higher than the other in precedence, one returns an l-value and the other doesn't.  so when you parse something like x++ x + ++x, there's a certain amount of work involved
06:03:52 <SM_ax> x++ is buil-in
06:03:56 <skew> but I'm not talking about operator overloading
06:04:02 <skew> I'm talking about adding *new* operators
06:04:04 <goltrpoat> sm:  hmm?  no.
06:04:23 <goltrpoat> skew:  ohh.  sorry, missed the point entirely.
06:04:37 <skew> like x %!* y = (x^2 + 11)/y
06:04:59 <skew> then 1 %!* 2 => -5.0
06:05:05 <goltrpoat> right, and then you see an %!* and have to figure out what it does even though the symbol isn't bound yet.
06:05:43 <skew> right, I wasn't even considering that the operator definition and the precedence specification could come after you see a use
06:05:44 <mflux> sm_ax, you are aware this is valid C++-code? class Foo { public: int operator++(int) { return 42; } }; int main() { Foo foo; foo++; } ?
06:05:51 <goltrpoat> -nod-
06:06:18 <skew> but anyway, that makes for fairly tricky parsing
06:06:26 <goltrpoat> so it does :)
06:06:58 <SM_ax> mflux: and what about returning some other type?
06:07:07 <mflux> sm_ax, just return it?
06:07:34 <mflux> Foo& operator .. return *this; works just as well
06:07:47 <goltrpoat> sm:  there are very few operators in c++ that have the type of restrictions you're talking about
06:08:59 <goltrpoat> basically..  both types of member selection, and that's all i can think of
06:11:05 <SM_ax> well, probably I'm wrong, it was a long time a go I used it last time..
06:19:26 <skew> hi john
06:23:55 <Cybertnt> Hey guys
06:24:27 <skew> hello
06:25:29 <Cybertnt> i wrote a program for the following problem: there is a number trick like this: 1 -> 11 -> 21 -> 1211 -> 111221 -> 312211 -> ..., get the n-th row and sum it up. so this is what i did: test n = sum (last (take n (iterate (\x -> concat (map (\y -> [length y, head y]) (List.group x))) [1])))
06:25:42 <Cybertnt> problem is, this consums a lot of memory :(
06:26:13 <Cybertnt> could anybody point me in the direction on how to optimize this?
06:26:39 <skew> last (take n values) can be written values !! n
06:26:59 <skew> How high is n getting?
06:27:10 <Cybertnt> roughly 100
06:27:27 <Cybertnt> already at 50 it tries to consum a few hundred megabytes ^.^
06:28:15 <skew> well, doubling each step is an easy upper bound on the size of the string
06:28:22 <skew> 2^50 is pretty big
06:28:42 <Cybertnt> well the 44th row would contain roughly 180000 elements
06:28:54 <goltrpoat> 1 -> one 1 -> two ones -> one two, two ones, etc?
06:29:26 <Cybertnt> two ones -> one two, one one
06:29:30 <Cybertnt> but yes :)
06:29:41 <goltrpoat> er, right, one one
06:29:41 <goltrpoat> hehe
06:33:00 <basti_> heya
06:33:08 <basti_> wilx`: are you there?
06:47:42 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=hs-proof.h
06:47:45 <glimming> feedback=?
06:50:02 <skew> that looks pretty good, but what's wrong with reducing with unknown subexpressions?
06:50:05 <basti_> glimming: looks good... found no mistakes
06:52:01 <skew> CR was shown for arbitrary terms
06:52:49 <skew> so that gives you a forall to play with (if you want to gloss over values, or translate to lambda expressions)
06:53:32 <skew> proving associativity and commutativity of multiplication would require induction
06:55:22 <skew> square (n*m) = (n*m)*(n*m) = n*(m*(n*m)) = n*((m*m)*n) = n*(n*(m*m)) = (n*n)*(m*m) = square n * square m seems perfectly valid to me, if you want to assume associativity and commutativity of multiplication
06:55:44 <skew> A better example might be map
06:56:17 <skew> say, map f (map g xs) == map (f . g) xs
06:57:15 <skew> If the function never inspects an argument I don't think there is any need to induct over it
06:59:06 <skew> map f (map g []) = map f [] = [], map f (map g (x:xs)) = map f (g x:map g xs) = f(g x):map f (map g xs) = f(g x):map (f . g) xs = map (f.g) (x:xs) seems to demonstrate induction pretty well, if you don't mind inducting over an algebraic data type rather than the numbers
07:00:24 <goltrpoat> wouldnt you just introduce f o g = f(g( )) axiomatically in algebra anyway
07:00:50 <skew> just the same as square x = x*x
07:01:22 <skew> showing that that lifts to map f . map g = map (f . g) is more interesting
07:01:38 <skew> actually, that probably comes from some sort of naturality property
07:02:31 <goltrpoat> are there any conditions for when map f x and map g x commute?  havent thought of that until just now
07:02:48 <goltrpoat> besides being type compatible i mean
07:02:49 <goltrpoat> heh
07:02:54 <skew> when f and g commute, if you mean map f (map g x) vs. map g (map f x)
07:02:59 <goltrpoat> yah
07:03:17 <skew> it's the same thing, by map (f.g) x = map f (map g x)
07:03:25 <skew> this is why we like referential transparency :)
07:04:33 <goltrpoat> i shouldve said when do f and g commute.  map is bijective.
07:04:33 <Cybertnt> why does "sum" cause a "*** Exception: stack overflow" when the list gets very large?
07:06:50 <goltrpoat> er.  scratch that last statement, that was dumb.
07:07:02 <goltrpoat> map is not necessarily bijective.
07:08:13 <skew> map has nothing to do with when f and g commute. It's just the morphism part of a functor from the category of ordinary types into the subcategory of list types
07:08:53 <skew> you probably have no idea what that means
07:09:51 <goltrpoat> im still mixing terms from algebra and cs, hopefully at some point i'll reconcile the two
07:10:04 <bubblesort> how do I write comments in Haskell?
07:10:07 <goltrpoat> --
07:10:17 <skew> okay, so I can talk algebra at you.
07:10:27 <goltrpoat> sure
07:10:28 <skew> or {- comment -}
07:10:35 <bubblesort> thanks
07:10:35 <Lemmih> Cybertnt: Because it's not strict enough.
07:10:59 <Cybertnt> Lemmih: would you know a way to sum up all elements from a very large list?
07:11:07 <Cale> Why isn't sum implemented as foldl' (+) 0 ?
07:11:16 <tromp> try sum
07:11:26 <Cybertnt> tromp: no
07:11:26 <skew> oh, sum :: (Num a) => [a] -> a
07:11:41 <Lemmih> Cybertnt: You just need to tell GHC to be more strict.
07:11:53 <Cybertnt> ok
07:12:01 <Cale> I suspect that merely compiling your code with optimisations will make it work
07:12:03 <skew> it doesn't seem to be enough to use the type [Int] -> Int
07:12:12 <Lemmih> (GHCi doesn't do strictness analysis)
07:12:16 <skew> Oh, sum works
07:12:48 <skew> it still starts to chew memory for big numbers
07:13:07 <Cybertnt> skew try sum (take 1000000 (repeat 3))
07:13:11 <Cale> sum [1..1000000] -- gives a stack overflow in GHCi for me, while  foldl' (+) 0 [1..1000000]  doesn't, so it's definitely strictness
07:13:36 <Cale> foldl' is from Data.List
07:13:45 <Cybertnt> thanks Cale
07:13:52 <ozone> i guess there should be a sum' = fold' (+) 0 definition
07:13:58 <ozone> foldl', even
07:14:55 <Cale> Seeing as integers have so little internal structure, ordinary sum might as well be implemented with foldl', no?
07:15:13 <goltrpoat> skew:  the first hour or so after i first started with haskell, i was all happy about how nifty my factorial function looked with the foldl, and so in my enthusiasm i went 'factorial 9000'.  and that's when i realized that when the tutorial i read said that integers are defined as all of Z, they weren't kidding.
07:15:14 <skew> sum is defined polymorphic over Num
07:15:33 <Cybertnt> does using Integer opposed to Int make your program slower?
07:15:40 <Cale> @type foldl' (+) 0
07:15:47 <lambdabot> bzzt
07:15:51 <Cale> @type Data.List.foldl' (+) 0
07:15:53 <lambdabot> Data.List.foldl' (+) 0 :: forall b. (Num b) => [b] -> b
07:15:54 <skew> Cybertnt: probably a bit, but it also makes it get the right answer for big numbers
07:16:17 <Cale> Cybertnt: It's not usually all that significant.
07:16:19 <skew> It uses GPM so it's pretty fast as far as arbitrary sized integers go
07:16:27 <skew> or was it GMP?
07:16:34 <Cale> GMP
07:18:31 <Cybertnt> HAH!
07:18:35 <Cybertnt> i love you Cale ;)
07:18:50 <Cybertnt> my program now doesnt consum ~ 1 GB of ram anymore
07:19:07 <basti_> hmm... is there a possibility of profiling running programs against their "maximum" mem usage and not the "total" (mem touched but released later)
07:19:10 <Cybertnt> (just on a platonic level though) :P
07:19:35 <skew> basti_: you can take a heap profile
07:19:42 <basti_> hmm
07:19:54 <mflux> so foldl is strict by default?-o
07:20:01 <skew> at least if you are talking about Haskell programs
07:20:02 <mflux> s/ by default//
07:20:02 <basti_> -prof -auto-all?
07:20:10 <skew> mflux: no, foldl' is the strict one
07:20:11 <basti_> of course i'm talking about haskell programs :)
07:20:30 <mflux> oh, so the problem was that it kept lots of incomplete results in the memory?
07:20:33 <basti_> ah -hXXX?
07:20:39 <skew> yes, those
07:20:41 <Cale> mflux: yeah
07:20:51 <Cybertnt> basti_: whats the option?
07:20:59 <skew> memory profiling
07:21:12 <mflux> I wonder if the haskell will ever be able to do such decisions.. (atleast runtime)
07:21:13 <basti_> Cybertnt: what option?
07:21:20 <Cybertnt> basti_: the one you where looking for
07:21:39 <skew> actually it's a whole family like -hp, -hr, -hc, etc
07:21:45 <Cale> Basically, if you don't care about associativity and want laziness, probably use foldr, and if you don't care about laziness, foldl'
07:21:52 <basti_> Cybertnt: profiling the "maximum memory usage", as opposed to the "memory touched usage"
07:22:10 <Cybertnt> basti_: yes, just wondered if you found the option for it
07:23:11 <basti_> -hXXX in the call yes.
07:23:17 <basti_> as in -hC
07:23:21 <Cybertnt> ah right
07:24:28 <basti_> hp2ps is cool.
07:25:07 <basti_> wilx`: i think i solved that problem... contact me for details, i got the mem usage down to O(1)
07:26:27 <basti_> mmm not O(1) but very close apparently. There is some-size dependant stuff left, but nowhere near O(n)
07:30:31 * Lemmih ponders if lesshaste is related to the Haste IDE project.
07:30:41 <lesshaste> but less so
07:30:50 <lesshaste> :) sadly no
07:41:13 <glimming> skew, basti_ check updated verrsion http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=hs-proof.h
07:41:18 <glimming> skew, what do you mean unknown subexpressions?
07:41:48 <glimming> I found a problem with HMTL btw, can't de-emphasise
07:42:04 <glimming> <em> long text long text <nf>normal font</nf> ... long text /<em>
07:42:05 <glimming> not supported
07:42:25 <glimming> I think one has to use <font style="font-style: normal">...</font> to de-emphasise and that is a bit annoying and tedious
07:42:43 <glimming> I tried to make this into span class="dem" and define span.dem = {font-style: normal}
07:42:49 <glimming> but that did not work!
07:42:55 <glimming> I wish HTML supported macro definitions.....
07:43:00 <glimming> That's a small remark off topic.
07:43:20 <basti_> simply define de emph as </i> <i>? ;)
07:43:31 <skew> I think this is a lot more confused than the original version
07:43:31 <glimming> juj?
07:43:42 <basti_> -g-
07:43:45 <glimming> skew, why?
07:44:09 <glimming> \whois skew
07:44:50 <glimming> basti_ what is </i> and <i> ?
07:44:53 <glimming> same as <em>?
07:45:10 <skew> mabye I was misreading the first time, but now you don't even use your "inductive assumption" in the second part of the square calculation
07:45:26 <glimming> true, I don't.
07:45:43 <glimming> One only needs to use assoc and commutativity of *
07:45:59 <basti_> glimming: uhm, ancient version of <em> probably
07:46:14 <CosmicRay> anyone here built hsql with ghc6.4?
07:46:16 <CosmicRay> I am getting:
07:46:17 <skew> it's strange to give half an inductive proof, then claim you are giving the second half while in fact giving a general, noninductive proof
07:46:18 <glimming> Maybe I should switch around fmap example and square example under induction
07:46:19 <basti_> or better, orthogonal but identically rendered version
07:46:25 <CosmicRay> HSQL/Types.hs:91:27:
07:46:26 <CosmicRay>     Couldn't match `TypeRep' against `TyCon'
07:46:26 <CosmicRay>       Expected type: TypeRep
07:46:26 <CosmicRay>       Inferred type: TyCon
07:46:26 <CosmicRay>     In the first argument of `mkAppTy', namely `sqlErrorTc'
07:46:26 <CosmicRay>     In the definition of `typeOf': typeOf _ = mkAppTy sqlErrorTc []
07:46:27 <basti_> (emphasize = italic for most people)
07:46:31 <glimming> and say square is an example where we USE inductive established laws
07:46:42 <glimming> ++ly
07:46:47 <skew> IT's really the text after the square proof that sounds confused
07:46:48 <Lemmih> CosmicRay: I got a cabalized version.
07:47:10 <glimming> ok, I'll rephrase it
07:47:13 <glimming> thanks
07:47:16 <CosmicRay> Lemmih: oh?  where?
07:47:18 <basti_> oh yes you're not actually doing induction
07:47:26 <CosmicRay> I have my own cabalized version that I did for Debian awhile back
07:47:27 <skew> Something is off with the grammar or meaning in "We did not even have to use induction on this theorem as it seems"
07:47:52 <Lemmih> CosmicRay: scannedinavian.org/~lemmih/packages/
07:48:00 <skew> I don't quite see how the "as it seems" hangs onto that sentence
07:48:03 <CosmicRay> Lemmih: did you have to patch the source at all?
07:48:10 <CosmicRay> Lemmih: do you have that in darcs?
07:48:23 <CosmicRay> Lemmih: why did you package 1.2 instead of 1.4
07:48:35 <skew> not that I know much about English grammar, I just speak it
07:48:36 <CosmicRay> Lemmih: I think that does it for my questions :-)
07:49:26 <Lemmih> Yes, I had to patch the source. No, I don't have a repo for it. And I didn't know they had released 1.4.
07:49:40 <CosmicRay> Lemmih: http://sourceforge.net/project/showfiles.php?group_id=65248
07:49:42 <CosmicRay> back in april 2004
07:49:47 <Cybertnt> Can anybody point me to where i could increase performance? http://pastebin.com/283194
07:50:12 <CosmicRay> Lemmih: better yet, though.... let me push my latest changes to my darcs repo, and maybe you can hack on 6.4 from there?
07:50:19 <CosmicRay> Lemmih: then I could just pull in your patches.
07:50:36 <bringert> Lemmih: I'm a HSQL developer, maybe I could put your stuff in HSQL CVS if you update it to work with that version
07:51:59 <CosmicRay> bringert: it probably wouldn't hurt to make a new release as well
07:52:19 <CosmicRay> bringert: since the release on your download page is apparently incompatible with ghc 6.4
07:52:30 <CosmicRay> Lemmih: darcs get http://darcs.complete.org/debian/haskell-hsql
07:52:45 <Lemmih> I don't like having HSQL as a single package with optional support for different backends.
07:53:04 <CosmicRay> Lemmih: you mean, in GHC?  why not?
07:53:47 <Lemmih> CosmicRay: Because you only depend on hsql, not hsql-postgresql.
07:57:22 <skew> glimming: I distincion I would like to see is that referential transparency is enough to work with things like square (n * m) as long as none of your reductions and expansions depend on the particular values of m and n, but to prove generic laws like that for functions like map which do inspect their arguments, you need to use induction
07:57:52 <glimming> I updaterd it again
07:58:51 <shelarcy> anyone use HSQL on SQLite3 by this patch?  http://aut.dyndns.org/sqlite3.diff
07:58:52 <glimming> skew, welll put
07:58:55 <skew> you repeat "functor laws functor laws"
07:58:58 <glimming> I will cite you on that one on theend of the
07:59:11 <glimming> Thanks agin
07:59:15 <glimming> ++a
07:59:25 <skew> the name is Brandon Moore, if you want something that looks halfway respectable
07:59:45 <skew> "The mysterious Haskell hacker known only by the pseudonym skew"
08:00:59 <Cybertnt> can somebody please help me out with this: http://pastebin.com/283194 ?
08:01:52 <glimming> skew, but remember map is polymorphic so in some sense it does NOT inspect its arguments!
08:01:53 <bringert> CosmicRay: I agree, though I'm not the maintainer
08:02:11 <skew> the right way to prove square (n*m) = square n * square m without assuming properties of * is to prove those properties of * and then work on square
08:02:22 <skew> referential transparency gives you some modularity in your proofs
08:02:31 * SamB wonders why nobody has responded to either of his posts to glagow-haskell-bugs yet
08:02:38 <skew> map does inspect the list part, even if it doesn't inspect the values in the list
08:03:35 <skew> the paper wavers back and forth in a few places
08:03:47 <SamB> well, when something inspects the resulting list, anyway...
08:03:57 <glimming> Check now.
08:04:05 <glimming> Now it is probably as good as I want it
08:04:07 <glimming> Many thanks
08:05:42 <skew> It's confusing where you saying that induction naturally springs to mind for proving the square example, then saying it isn't necessary, then saying we're going to do it anyway, in the space of three sentances. I think running with the same idea for a little longer is easier to follow
08:06:04 <glimming> ok
08:06:52 <skew> like, you could just say that induction springs to mind, let's try induction. We need to pick which argument to induct on, it looks pretty symmetrical so just take m, write the base case m = 0, assume for m-1, try to prove the general case
08:07:28 <skew> then the general case works out and you say something like "oh, it seems we didn't need induction here after all"
08:07:52 <skew> and then continue with the bit you already have about how you used a nontrivial induction road
08:08:21 <skew> right now that section reads kind of like a curvy mountain road that wiggles back and forth a lot so you can't go very fast
08:08:35 <skew> I like the first part quite a lot
08:08:38 <SamB> hmm, I wonder why I was expecting monadic let to give an error if I tried something like let x1:x2:xs = map undefined (():undefined)?
08:09:23 <skew> All of your first version flowed nicely and motivated the ideas, I just thought the square example was a bit confused
08:09:26 <glimming> maybe you like it better now?
08:10:17 <skew> I'm having some trouble explaining myself
08:11:46 <glimming> I think I'll go with this version.
08:12:14 <skew> there is at least a few typos in this version
08:12:26 <skew> I will look over it more closely
08:13:03 <glimming> I corrected three last 2 seconds ago.
08:13:11 <elk> @spell excersize
08:13:16 <lambdabot> excessive excesses exercises excises exercise
08:13:41 <SamB> hmm, Pan could use a better implementation of printing... this message from gmane.comp.lang.haskell.general has about a page of headers on it!
08:13:50 <glimming> Maybe I should use "Excessive" instead? ;-)
08:14:42 <skew> The two I've seen are in the formulas, map polymorphic in a vs. type List t, and mn * m * n * m
08:16:02 <glimming> I fixed that
08:16:31 <skew> okay, I refreshed athe page after you said you fixed a few and they were still there
08:16:41 <glimming> ok updatre again
08:16:46 <skew> hehe, somebody in #rubyonrails asked if anybody there is running colinux
08:17:07 <skew> what would the dual of an operating system be?
08:17:14 <glimming> a user.
08:17:17 <SamB> I tried to run that once but couldn't really get it to do anything...
08:17:59 <glimming> So Skew, that's it?
08:18:36 <glimming> I owe you a beer next time your'e in Stockholm
08:18:43 <glimming> Many thanks for the comments.
08:18:48 <skew> glimming: I think I've figured out what I wanted to say. The thing that I thought was most significant wasn't the example with square, but the bit where you say that working with unknowns like n and m requires more powerful proof techniques
08:19:14 <glimming> Aha, yes.
08:19:49 <skew> I think a lot of the power of CR is that you can reduce some bits of an expression without caring about the rest, like partial evaluation
08:20:10 <glimming> indeed
08:21:11 <skew> even if you felt you wanted a separate proof of square (n x m) = square n x square m for each of the infinite set of values of n and m, you can get that, even for a semi-constructive notion of proof, just by writing down the proof that leaves m and n unspecified and filling them in
08:21:36 <skew> okay, so maybe that's not such a good explanation
08:22:17 <glimming> argh, I have to continue now with other things which are due for today.
08:22:26 <skew> you seem to be much better at stating things like that clearly
08:22:28 <glimming> So I think I will thank you a lot for all the comments once again!
08:22:38 <glimming> Oh, thanks man!
08:22:59 <glimming> Make it two beers for the kindness... ;-)
08:23:03 <glimming> Later! Bye!
08:23:10 <skew> no problem, I think I should work on other things too :)
08:23:19 <glimming> (get to Stockholm some day as well)
08:23:28 <skew> hopefully
08:25:15 <CosmicRay> musasabi: are you here?
08:25:25 <CosmicRay> I am having trouble making something compile with ghc 6.4
08:25:27 <CosmicRay> I have this code:
08:25:31 <CosmicRay> type CPError = (CPErrorData, String)
08:25:32 <CosmicRay> instance Error CPError where
08:25:34 <CosmicRay> ghc 6.4 is giving:
08:25:40 <CosmicRay> ./MissingH/ConfigParser/Types.hs:83:0:
08:25:40 <CosmicRay>     Illegal instance declaration for `Error CPError'
08:25:40 <CosmicRay>         (The instance type must be of form (T a b c)
08:25:40 <CosmicRay>          where T is not a synonym, and a,b,c are distinct type variables)
08:25:40 <CosmicRay>     In the instance declaration for `Error CPError'
08:25:44 <CosmicRay> but this worked in ghc 6.2
08:25:51 <CosmicRay> (Error is Control.Monad.Error)
08:25:53 <CosmicRay> what am I doing wrong?
08:39:58 <Cale> CosmicRay: Type synonyms aren't new types
08:41:00 <CosmicRay> well, I found the problem in my .cabal file, I wasn't giving Extensions properly.
08:41:08 <CosmicRay> I guess this needs one of the GHC extensions to build
08:41:23 <Cale> hmm
08:41:59 <elk> Ray: i thought -fallow-undecidable-instances allows that
08:42:12 <CosmicRay> Extensions: ExistentialQuantification, AllowOverlappingInstances,
08:42:12 <CosmicRay>     AllowUndecidableInstances, CPP
08:42:18 <CosmicRay> elk: that is, in fact, one of the extensions I list...
08:42:22 <CosmicRay> elk: so I bet you're right
08:43:40 <elk> CosmicRay: ok, so it is called Extensions in cabal then, better start reading about it
08:44:47 <elk> @google cabal tutorial
08:44:49 <lambdabot> http://www.tw-cabal.com/
08:44:56 <Lemmih> heh.
08:45:18 <CosmicRay> elk: http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html
08:57:17 <wilx`> Whoa!
08:57:19 <wilx`> basti_?
08:57:57 <musasabi> CosmicRay: pong
08:58:01 <basti_> wilx: !
08:58:08 <wilx> I am all ears!
08:58:22 <basti_> wilx: there's a combination of reasons why you didn't think to be doing the right thing.
08:58:26 <basti_> ;)
08:58:52 <basti_> you were looking for O(1) mem consumption right?
08:59:02 <wilx> Yes.
08:59:24 <CosmicRay> musasabi: thanks, but I figured out my problem (MissingH testing and ghc 6.4)
08:59:25 <basti_> i think this is mutually exclusive with tail-recursion in our case.
08:59:29 <basti_> I'm not too sure though
08:59:45 <wilx> b00 :(
08:59:46 <musasabi> CosmicRay: it needs -fglasgow-exts.
08:59:56 <basti_> the normal profiling will give you the number of bytes "touched"
09:00:15 <basti_> i would suspect it to be problem-inherent O(n) in our case
09:00:16 <musasabi> because the instance is not for a simple type it is not haskell98.
09:00:36 <CosmicRay> yup, I discovered this :-)
09:01:10 <basti_> you can do a better profiling with -h* options
09:01:18 <basti_> -hC for example
09:01:34 <basti_> this will show you how many memory there is used "live" in every moment
09:02:07 <wilx> Hm.
09:02:10 <basti_> (hp2ps to convert the resulting .hp file to ps)
09:03:23 <basti_> i wrote code that (empirically) uses ~15k memory with any size of input
09:04:19 <basti_> and is way prettier than that late night stuff I wrote yesterday ;)
09:05:19 * basti_ arghs at his english
09:06:36 <wilx> Could you paste it somewhere?
09:06:40 <basti_> sure
09:06:48 <basti_> did you profile your code with -hC?
09:06:58 <basti_> lisppaste2: @url
09:06:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:07:10 <TFK> Or, hbin.dyndns.org
09:07:28 * TFK disappears into the darkness
09:07:54 <lisppaste2> basti_ pasted "accumulating bits - runs in O(1) mem?" at http://paste.lisp.org/display/8197
09:11:18 <dcoutts_> JaffaCake, thanks! I'll try it out (the compacting GC fixes were merged into the ghc-6-4-branch already wern't they?)
09:11:28 <JaffaCake> yep
09:11:32 <dcoutts_> ok, cool
09:20:41 <basti_> bbl, shopping for food
09:28:37 <glimming> Are the SOE answers available on-line?
09:28:42 <glimming> SOE = School of Expression, Hudak
09:29:04 <glimming> Particularly I'd like to see the recursive adjust function with Maybe monad
09:33:53 <Lemmih> @google haskell soe
09:33:55 <lambdabot> http://haskell.org/soe/
09:34:24 <ski> no answers there, from what i see
09:40:06 <glimming> nope
09:40:06 <glimming> hi ski
09:40:13 <glimming> check distributive laws
09:40:32 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=dist.h
09:40:57 <basti_> wilx: ?
09:42:44 <wilx> Well.
09:42:50 <wilx> I say "YAY!"
09:42:50 <basti_> any comments?
09:42:54 <basti_> =)
09:43:00 <basti_> did you profile your code?
09:43:20 <wilx> Not yet.
09:43:32 <basti_> hmm.
09:43:58 <ski> glimming : hi
09:44:00 <wilx> I haven't ever finished my try on that bit IO so I have nothing to profile.
09:44:12 <basti_> oh
09:44:25 <wilx> I will try to use your implementation and report back with the results :)
09:44:32 <basti_> ok
09:44:54 <wilx> But it already looks really good to me.
09:45:38 <wilx> From what I see it is properly lazy and O(1) memorywise...
09:46:04 <basti_> yours wasn't?
09:46:14 <basti_> i doubt that, thats what i tried to say
09:46:19 <wilx> Nope.
09:46:27 <basti_> how do you know?
09:47:51 <lispy> O(1) is overrated, i prefer O(2)
09:48:07 <ski> O(0) !
09:48:26 <lispy> heh, or O(2^m) where n is the input size
09:48:27 <ski> iterations with O(0) body is good
09:48:30 <wilx> Well, mine involved retreiving the final state and...hmm, but with your code I won't get the final state either...
09:48:43 <basti_> oh.
09:48:44 <wilx> The second point was to be able to restart the serialization.
09:48:58 <basti_> well this is built in via laziness isnt it?
09:49:17 <wilx> So that I could kind of processing by chunks or something...
09:49:24 <wilx> I will have to think about it :)
09:49:47 <SyntaxNinja> 'morning
09:50:09 <_metaperl> hi SyntaxNinja, so you work at Galois?
09:50:40 <SyntaxNinja> _metaperl: yeah
09:51:00 <_metaperl> that must be fun. how did you gain your strong background in Haskell?
09:51:50 <_metaperl> it seems that most of Galois' work is in cryptography. I think that Aetion's work would interest me more (planning, simulations, military)... but I dont know much about cryptography so maybe that would be fun too
09:52:06 <SyntaxNinja> _metaperl: I actually didn't know Haskell until I started Aetion in 2002.
09:52:20 <_metaperl> you moved from Aetioin to Galois?
09:52:53 <SyntaxNinja> _metaperl: Galois does cryptography and also other security related work, including cross-domain security (internal vs external networks, for instance)
09:52:56 <SyntaxNinja> _metaperl: yeah.
09:53:13 <SyntaxNinja> Galois is probably hiring soon, fwiw
09:53:32 <SyntaxNinja> I'll post the job description here when it's finished.
09:54:38 <SyntaxNinja> _metaperl: but yeah, Galois is lots of fun :)
09:54:44 <_metaperl> :)
09:54:55 <_metaperl> doesnt daan work there?
09:55:24 <_metaperl> the developer of Parsec and the "cleaner" FFI for haskell
09:55:40 <SyntaxNinja> _metaperl: nope.
09:55:48 <Lemmih> Daan Leijen is an american citizen?
09:56:22 <Muad_Dibber> afaik daan currently works in utrecht :P
09:56:41 <SyntaxNinja> _metaperl: not sure who you might be thinking of, actually.
09:57:19 <_metaperl> I dont know how I confused daan with this guy: http://www.galois.com/~sof/
09:57:27 <_metaperl> that's who I was thinking of, but I used the name daan
09:57:58 <SamB> I just added a tip to http://www.haskell.org/hawiki/TemplateHaskell
09:58:00 <SyntaxNinja> heh. sof rulz
09:58:29 <SamB> It could probably use some refactoring to make it a little more clear
10:13:11 <CosmicRay> SyntaxNinja: cabal question.  I build my library with cabal and want to build unit tests for it.
10:13:16 <CosmicRay> SyntaxNinja: what is the best way to do that?
10:13:45 <CosmicRay> SyntaxNinja: I tried adding an Executable stanza, but: 1) that forces everything to be compiled twice (maybe due to different hs-source than main module), and 2) cabal tries to install that executable
10:14:02 <CosmicRay> SyntaxNinja: my old hackery that I used with cabal 0.5 and ghc 6.2 no longer works
10:14:17 <CosmicRay> ideas?
10:15:50 * Lemmih recalls something about a test hook.
10:18:29 <SyntaxNinja> CosmicRay: there is a testing hook, where ./setup test runs it (only implemented in darcs cabal)=
10:18:46 <SyntaxNinja> it compiles things it should be skipping?
10:19:40 <SyntaxNinja> CosmicRay: what hackery?
10:20:14 <SyntaxNinja> CosmicRay: you could have a post-build hook which builds the unit tests
10:47:08 <Lemmih> SyntaxNinja: How's Cabal coming along?
10:47:24 <musasabi> @seen shapr
10:47:25 <lambdabot> I saw shapr leaving #haskell 4 days, 1 hour, 47 minutes and 6
10:47:25 <lambdabot> seconds ago.
10:47:57 <CosmicRay> SyntaxNinja: hmm.
10:48:08 <CosmicRay> SyntaxNinja: I would have all the information necessary to pass to ghc at that point?
10:48:24 <musasabi> One good way would be to make it possible for executables to depend on a library in the same cabal file.
10:48:25 <CosmicRay> dist/build/whatever.a and -i dist/build, etc?
10:48:42 <skew> I should comb the logs and gather all those queries to give shapr when he shows up again
10:48:46 <CosmicRay> musasabi: that would be ideal, as well as a boolean installable file
10:48:59 <CosmicRay> s/file/option/
10:54:45 <SyntaxNinja> executables do kinda depend on their library, the library source dir is included in the search path when building an exe
10:55:50 <SyntaxNinja> CosmicRay: no, building a proper, flexible postBuild hook is much harder than just a one-off one
10:56:40 <SyntaxNinja> CosmicRay: maybe we could add an 'installable' flag so that hte executable does't get installed
10:57:20 <CosmicRay> SyntaxNinja: that would solve the most important part of the problem
10:57:33 <SyntaxNinja> Lemmih: cabal is good; it's pretty much ready. maybe I'll make a release... I was thinking of waiting 'till hackage and releasing them together
10:57:44 <SyntaxNinja> but now I'm all worried about security in hackage, so maybe we should wait, and i should just do a cabal release
10:57:44 <CosmicRay> it still will force the library to be compiled twice, but that's not as much of a concern to me
10:57:53 <CosmicRay> SyntaxNinja: you mean gpg auth stuff?
10:58:09 <SyntaxNinja> only problem w/ releasing cabal actually is that I have to figure out how the isntall will go when building for ghc 6.4; if we need to remove the existing cabal first.
10:58:10 <SyntaxNinja> CosmicRay: yeah
10:58:32 <CosmicRay> SyntaxNinja: if you want my opinion, it's that gpg stuff would be a post-1.0 hackage thing
10:58:42 <CosmicRay> I don't see it as being a big deal right now
10:58:54 <CosmicRay> few people even provide md5sums with their software, let alone gpg sigs
10:59:03 <SyntaxNinja> CosmicRay: we need _something_ for "1.0" to deter trivial root exploits. I can't stand to release such a piece of software
10:59:40 <CosmicRay> SyntaxNinja: ahh, iswym...  what does cpan do?
10:59:57 <SyntaxNinja> CosmicRay: no idea.
11:00:05 <SyntaxNinja> I need to check, or Lemmih can :)
11:00:41 <SyntaxNinja> Lemmih: how's cabal-put going?
11:01:06 <CosmicRay> does darcs have repo signing yet?
11:01:10 <CosmicRay> (I think not...)
11:01:49 <Lemmih> SyntaxNinja: Kinda stalled. Isn't it still up for discussion how it should work?
11:02:20 <SyntaxNinja> Lemmih: yeah kinda, we mostly have consensus, imo.
11:03:12 <SyntaxNinja> Lemmih: but I think most of the argument is whether or not we should wait for it or do something simpler; if it can be done before the discussion is concluded,t hat's a strong argument for "waiting" ;)
11:03:34 <SyntaxNinja> because quite honestly, having accounts and stuff like sourceforge is going to be at least as hard to implement, maybe harder
11:03:38 <SyntaxNinja> but we should look at cpan
11:03:41 <SyntaxNinja> I don't think darcs has repo signing yet
11:03:56 <CosmicRay>  SyntaxNinja: is the current consensus something debian-like?
11:04:19 <CosmicRay> that is, upload a signed file to an incoming area, process it out of there, and provide a signed index to the entire thing complete with md5sums?
11:05:39 * Lemmih goes off to read about cpan.
11:05:39 <SyntaxNinja> CosmicRay: actually not md5sums, but signed packages
11:06:11 <SyntaxNinja> CosmicRay: hackage will add its sig to the packages
11:06:19 <CosmicRay> ah nice.
11:06:23 <CosmicRay> that sounds like debsigs.
11:06:24 <SyntaxNinja> anyway, that's my proposal, adn you can see dicussion on the list
11:06:52 <SyntaxNinja> CosmicRay: yeah... with the idea that people can add other folks they trust to their keyrings if they want, adn teh packages may be signed by them, though not by hackage.
11:07:06 <CosmicRay> SyntaxNinja: you may be interested in http://quux.org/devel/debian/debsigs.txt
11:07:16 <CosmicRay> SyntaxNinja: I wrote that some years back when I implemented signing of .debs
11:07:25 <CosmicRay> SyntaxNinja: it sounds very similar to what you're talking about
11:09:01 <CosmicRay> err wrong document...
11:09:50 <SyntaxNinja> CosmicRay: so as I remember, the disadvantage over that w/ the apt-secure style is that 1) you need to change the format of .debs and 2) the overhead of the sigs per package would be a lot considering the large number of packages
11:10:05 <CosmicRay> SyntaxNinja: apt-get install debsigs, then look at /usr/share/doc/debsigs/signing-policy.txt.gz
11:10:51 <CosmicRay> SyntaxNinja: since a .deb is just an ar file, I added new files to it.  completely transparent to old tols.
11:10:57 <CosmicRay> but anyway, I'm assuming you'd have, say, a tar.gz and a tar.gz.sig file with hackage?
11:11:04 <CosmicRay> a detached, rather than an intergrated, sig?
11:11:15 <CosmicRay> the implementation is different but the principle is the same
11:11:22 <CosmicRay> and the vulnerabilities are the same too
11:12:59 <SyntaxNinja> CosmicRay: yeah;
11:13:11 <SyntaxNinja> can you give me a run-down of pros and cons w/ apt-secure style?
11:13:59 <SyntaxNinja> sorry, at work so I can look at that later maybe
11:16:41 <lispy> CosmicRay: a .deb is just an ar file?
11:17:00 <lispy> CosmicRay: what are the advantages to using that format i wonder
11:17:38 <lispy> specificly, I'm wondering if darcs would benefit from using that format for patchs
11:19:02 <CosmicRay> SyntaxNinja: actually I haven't ever really looked at apt-secure, is there a url for it? (apt-cache doesn't see it)
11:19:15 <CosmicRay> SyntaxNinja: or is that just the signed-Release file format that they are using now?
11:19:23 <CosmicRay> lispy: that's right, just an ar file
11:19:35 <SyntaxNinja> CosmicRay: yeah, it's the signed release file thing
11:19:51 <SyntaxNinja> CosmicRay: http://www.syntaxpolice.org/apt-secure/
11:19:53 <CosmicRay> SyntaxNinja: ok then, I can give you a quick summary....
11:20:20 <SyntaxNinja> I also note that there's dpkg-sigs
11:20:23 <lispy> CosmicRay: thanks
11:21:24 <CosmicRay> brb phone...
11:25:33 * CosmicRay returns
11:27:09 <CosmicRay> SyntaxNinja: ok. the signed-Release method will let you verify that files you download at the same time as the Release file: 1) are part of the official archive represented by the Release file, and 2) are un-tampered.  It will not let you take any random .deb and verify its authenticity, unless it still happens to be the current version in the archive in a Packages file you have.
11:28:02 <CosmicRay> SyntaxNinja: the signed-deb method will let you take any random .deb and, depending on the signing policy in place, verify: 1) that it is unmodified since it left the maintainer's machine, 2) that it was part of a given official archive at some point
11:28:11 <SamB> hmm, nobody seems to be responding to my ghc bugreports...
11:28:22 <CosmicRay> SyntaxNinja: the signed-deb method will not let you verify that the .deb is part of the *current* archive
11:28:33 * SyntaxNinja nods
11:28:40 <SyntaxNinja> is overhead an issue?
11:28:57 <CosmicRay> so, a weaknesses of the signed-Release method are: there is no end-to-end integrity checking, there is no way to validate older or standalone debs
11:29:00 <sbeyer> oh hi CosmicRay ;)
11:29:12 <SyntaxNinja> it must be very costly to check the sigs on each pkg; also who signs the packages? how do you get the sigs of the developers onto the end-user machines?
11:29:15 <lispy> CosmicRay: so what is the proposed system?  to have a key for each deb, and then have each of those keys be signed by the distros that the deb is in?
11:29:19 <CosmicRay> weaknesses of the signed-deb method are: no ability to make sure the package is in the current archive
11:29:32 <CosmicRay> SyntaxNinja: not really, gpg sigs and ar operations are pretty fast
11:29:42 <CosmicRay> SyntaxNinja: we used debsigs for production progeny releases and it worked well
11:29:51 <CosmicRay> hi sbeyer
11:29:56 <SyntaxNinja> CosmicRay: can apt do that automatically?
11:30:23 <CosmicRay> SyntaxNinja: take a look at that signing policy document I pointed you to.  To answer the other question, there is also the debian-keyring package.
11:30:40 * lispy procrastinates
11:30:40 <SyntaxNinja> CosmicRay: ok
11:31:35 <CosmicRay> lispy: no, each maintainer has a key, and the deb is signed with that key at upload time.  Automated signatures are also added for certain events, such as: placement into an archive, released with a specific OS version, passed QA tests, etc.
11:31:43 <CosmicRay> lispy: each event would have its own key
11:32:13 <SyntaxNinja> <--- was one fo the apt-secure developers. that seemed to be what they wanted at the time; not sure why debsigs wasn't a bigger part of the conversation
11:32:33 <SyntaxNinja> but honestly we had a hell of a time finding anyone willing to talk to us about such things
11:33:20 <CosmicRay> SyntaxNinja: there was a long discussion somewhere, -devel maybe, back in 2001ish when I wrote debsigs
11:33:41 <CosmicRay> SyntaxNinja: at the time, one of the apt developers, anthony I believe, was firmly in the signed-release-file camp
11:33:59 <CosmicRay> but its weaknesses were showstoppers for our purposes, so I wrote debsigs anyway
11:35:24 <CosmicRay> there is also debsig-verify written by ben collins
11:35:54 <SamB> any idea why nobody has yet responded to my ghc bug reports (on the glasgow-haskell-bugs list, from Samuel Bronson <naesten at gmail.com>)?
11:36:27 <lispy> i know i'm missing details, but it seems like a simple way of doing things would be to have a signing key for each distro, and then put a signature on each package and then have the distros that include packages sign and revoke the packages as they move around
11:36:33 <CosmicRay> SamB: you would probably need to ask on the glasgow-haskell-users list
11:36:54 <CosmicRay> lispy: yes, if indeed you have distros copying binaries from each other
11:37:01 <CosmicRay> lispy: I don't know how common that is in practice
11:37:47 <lispy> CosmicRay: ah, well if they never do then it just simplifies it a little :)
11:38:03 <lispy> but like i said, i'm probably missing the bigger picture
11:39:15 <CosmicRay> lispy: the system was not really designed with inter-distro sharing in mind, more for the utility of end users of a particular distro
11:39:54 <lispy> yeah, i was under the impression that packages "move" from distro to distro as they become stable
11:40:11 <lispy> but that's probably more conceptual than a real process
11:40:26 <CosmicRay> you mean from unstable to testing, perhaps?
11:40:30 <lispy> right
11:40:41 <CosmicRay> usually when we use "distro", it means "debian" or "ubuntu" or something, so I read your statement differently
11:40:49 <lispy> oh
11:40:59 <SamB> don't the binaries that make it into stable get there via testing and unstable?
11:40:59 <lispy> yeah, i use it both ways ;)
11:41:03 <lispy> confusing is i :)
11:41:28 <CosmicRay> SamB: yes
11:41:38 <CosmicRay> and indeed this is one area where debsigs would help out
11:41:44 <CosmicRay> when its first uploaded, it gets the unstable sig
11:41:50 <CosmicRay> when it hits testing, it gains the testing sig
11:41:56 <CosmicRay> when it is released, it gains that sig as well
11:42:15 <CosmicRay> sigs are timestamped, so given any deb, you can see just what has happened
11:43:02 <lispy> right, then you'd need keyservers for 'net users.  How would you get the sigs to other debian users?
11:43:34 <CosmicRay> everyone would just have the debian-keyring package installed by default
11:43:46 <SyntaxNinja> man. everyone loves krasimir's idea. I'm starting to feel silly for being all "well, OK if you want to" ;)
11:43:53 <SyntaxNinja> (libraries mailing list)
11:44:03 <CosmicRay> as long as the sigs on this package, and the verification policy, are sane, it all works
11:44:27 <lispy> CosmicRay: yeah, i agree
11:44:39 <lispy> so why isn't it like that? :)
11:45:25 <CosmicRay> lispy: as I said, the apt people preferred signed Release files instead of signed debs
11:45:27 <lispy> and how can i be sure that my local keyring is valid (non-corrupted from HD failure and non-comprimised)
11:45:47 <CosmicRay> lispy: that is left up to you.  as it is with every gpg-based solution.
11:45:49 <lispy> so a signed release file, how does that work?
11:46:04 <lispy> fair enough
11:46:21 <CosmicRay> integrity of local gpg installation, gpg keyring, operating system installation, hardware, etc. are all outside the scope of this approach (and are standard well-documented issues)
11:46:52 <lispy> with a signed release file, does it at least store a checksum of the debs?
11:46:55 <CosmicRay> lispy: there is a Release file for a given archive.  It is signed with GPG.  It contains an md5sum for the Packages file in that archive.  The Packages file, in turn, contains md5sums for all the .debs
11:47:25 <lispy> ah, well that's a reasonable method
11:47:42 <CosmicRay> like I said, both that and debsigs have their strengths and weaknesses
11:47:48 <CosmicRay> there are weaknesses to both approaches
11:47:50 <lispy> yeah
11:49:07 <lispy> man, it's hard for me to be motivated about writing
11:53:29 <CosmicRay> what are you writing, lispy?
11:53:46 <lispy> a short paper about my research
11:53:51 <lispy> well, the research i'll be started
11:53:53 <lispy> er starting
11:54:40 <lispy> i told my advisor i'd probably do it yesterday and didn't.  so i feel kind bad.  But it's a low motivation task for me.
12:10:50 <Philippa> heh
12:10:55 <Philippa> don't talk to me about motivation...
12:14:39 <CosmicRay> SyntaxNinja: I used to be able to get data to feed to ghc-pkg from .installed-pkg-config from cabal
12:14:50 <CosmicRay> I don't see that available anywhere in the cabal shipped with ghc 6.4
12:14:56 <CosmicRay> SyntaxNinja: where should I look for it now?
12:17:53 <marcot> dcoutts: Hello.
12:19:05 <marcot> dcoutts: are you there?
12:20:55 <CosmicRay> what is the proper way to direct ghc to use a tree of .hi/.o files or a libHS*.a file?
12:21:05 <CosmicRay> i have tried -i and -L but it seems to not be working
12:32:20 <SamB> wow, playing with Template Haskell and type classes is really messy
12:32:26 <stepcut> hehe
12:32:47 <SamB> I'm getting GHC internal scope errors!
12:33:02 <SamB> and they don't seem to be my fault either
12:33:20 <stepcut> heh
12:33:29 <stepcut> GHC+TH is rather unstable in my experience
12:33:43 <stepcut> though, they are pretty quick to fix reported bugs
12:33:50 <SamB> for some reason the default methods are out of scope
12:35:47 <Philippa> stepcut: glad to hear somebody say it, now I don't have to feel guilty the 6.4 version of my Impure Thoughts code crashes my compiler :-)
12:38:19 <SamB> I've found two ways to outright crash the compiler (but not GHCi, GHCi catches the exception) with the same error message in probably the last 24 hours. One of which doesn't even use TH.
12:38:41 <SamB> Both of them involve mutually recursive modules, though.
12:38:57 <wagle> you have impure thoughts?
12:38:58 <basti_> with TH its easy
12:39:01 <wagle> what is it?
12:39:20 <Philippa> wagle: you need to ask?
12:39:49 <Philippa> SamB: oh fun. Flippi's rapidly becoming dependant on mutually recursive modules, 'shard to have a good plugin architecture without 'em...
12:40:01 <Philippa> (the damn Config module ends up in a whole pile of cycles)
12:41:05 <wagle> we're all Pur(e)itins over on this side of the pond
12:41:16 <SamB> Well the first one doesn't seem to happen unless the loop-breaker is only imported with {-# SOURCE #-}...
12:41:29 <Philippa> you won't let me flog your monads then? Damn
12:42:22 <SamB> the second one, I don't get, but it looks like this:
12:43:01 <SamB> % ghc -c --make RecClass.hs
12:43:01 <SamB> Chasing modules from: RecClass.hs
12:43:01 <SamB> Compiling RecClass[boot]   ( RecClass.hs-boot, RecClass.o-boot )
12:43:01 <SamB> Compiling RecClassTHStuff  ( ./RecClassTHStuff.hs, ./RecClassTHStuff.o )
12:43:01 <SamB> Compiling RecClass         ( RecClass.hs, RecClass.o )
12:43:02 <SamB> Loading package base-1.0 ... linking ... done.
12:43:04 <SamB> Loading package haskell98-1.0 ... linking ... done.
12:43:08 <SamB> Loading package template-haskell-1.0 ... linking ... done.
12:43:10 <SamB> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
12:43:12 <SamB>         expectJust upsweep_mod:old_linkable
12:43:19 <basti_> lol
12:43:24 <boegel> anyone know what I can use to format a negative number in LaTeX ? $-5$ isn't quite what I want, the "-" is too big
12:44:03 <SamB> there is a splice in RecClass that calls a function in RecClassTHStuff, but RecClassTHStuff doesn't call anything at all in the haskell code...
12:44:39 <SamB> that is, it doesn't call anything from RecClass at the haskell level...
12:45:19 <SamB> I guess I might get a clue if I looked at the core code
12:58:59 <SamB> hmm, maybe this is from __stginit_RecClassTHStuff_ trying to do something with __stginit_RecClass_?
13:05:24 <CosmicRay> hmm, is -package Cabal not a standard feature of GHC 6.4?
13:05:35 <CosmicRay> I seem to be able to build stuff with -package Cabal on i386 ghc
13:05:37 <CosmicRay> but not on amd64 ghc
13:05:39 <CosmicRay> both debian
13:05:42 <CosmicRay> I can't figure out why
13:05:51 <CosmicRay> ghc-pkg -l lists Cabal on i386 but not on amd64
13:07:24 <Lemmih> Have you tried installing Cabal on amd64?
13:07:34 <CosmicRay> it's part of ghc6.4 by default
13:07:40 <CosmicRay> so it's alerady installed
13:07:44 <Igloo> CosmicRay: With the deb?
13:08:05 <CosmicRay> Igloo: I have the ghc 6.4 deb installed on both my i386 and amd64 machine.  libghc6-cabal-dev is installed on neither.
13:08:27 <CosmicRay> Igloo: interestingly, /usr/lib/ghc-6.4/imports/Distribution exists on amd64
13:08:37 <CosmicRay> but there is no Cabal recognized by ghc -package
13:09:04 <SyntaxNinja> CosmicRay: strange
13:09:31 <SyntaxNinja> dons: someone was having some build problem on solaris related to cabal, do you know what that was?
13:09:37 <SyntaxNinja> seems like it's not always getting built properly
13:09:44 <Igloo> Oh, where are amd64 debs these days again?
13:09:58 <CosmicRay> Igloo: amd64.debian.net
13:10:26 <CosmicRay> ok, and here's the even weirder thing: I just checked my logs, and ghc -pacakge Cabal worked on my amd64 box this morning.
13:10:42 <CosmicRay> I wonder if something strange happened wrt libghc6-cabal-dev being removed out of order or something
13:11:13 <Igloo> Oh, you used to have libghc6-cabal-dev installed?
13:11:25 <CosmicRay> yes, before upgrading to ghc 6.4
13:11:40 <Igloo> So it worked with 6.2.2 but doesn't with 6.4?
13:11:51 <CosmicRay> correct, but that's to be expected and is not a bug
13:11:58 <CosmicRay> libghc6-cabal-dev sez:
13:12:02 <CosmicRay> Depends: ghc6 (>= 6.2.2), ghc6 (<< 6.2.3)
13:12:07 <CosmicRay> since it's been compiled for ghc 6.2.2 only
13:12:39 <Igloo> Right, the set of files in the two debs is identical
13:13:24 <Igloo> And package.conf.shipped in the amd64 deb has a Cabal stanza
13:13:29 <CosmicRay> Igloo: how is the default list of ghc packages created when you install ghc?
13:13:46 <Igloo> Does "ghc-pkg -l" list it?
13:13:50 <CosmicRay> no
13:14:09 <CosmicRay> -rw-r--r--   1 root root    30795 May 12 14:59 package.conf
13:14:09 <CosmicRay> -rw-r--r--   1 root root    37009 May  7 09:17 package.conf.old
13:14:09 <CosmicRay> -rw-r--r--   1 root root    32404 May  7 09:17 package.conf.shipped
13:14:27 <Igloo> Is it in /usr/lib/ghc-6.4/package.conf ?
13:14:42 <CosmicRay> /usr/lib/ghc-6.4# grep -li cabal package*
13:14:42 <CosmicRay> package.conf.old
13:14:42 <CosmicRay> package.conf.shipped
13:14:44 <CosmicRay> so, no.
13:14:47 <SyntaxNinja> CosmicRay: if the cabal postinst was called after ghc 6.4 was installed, then it might not be there
13:14:55 <CosmicRay> hmm.
13:14:58 <CosmicRay> how could I get it back?
13:15:13 <CosmicRay> and I wonder why apt let this happen...
13:15:15 <Igloo> But it should be unregistered in prerm shouldn't it?
13:15:25 <CosmicRay> let me check
13:15:26 <Igloo> And the old ghc6 should still be there?
13:15:38 <CosmicRay> prerm, yes.
13:16:00 <SyntaxNinja> yeah, of course... by postinst, I meant prerm.
13:17:58 <Igloo> If someone could try to reproduce it to check that's what happened, and/or check what policy says about what we can assume re ordering, then that would be great
13:18:01 <CosmicRay> I am mystified as to how this happened.
13:18:14 <Igloo> We don't have a circular dependency problem anywhere, right?
13:18:59 * basti_ goes ask himself
13:19:20 <Igloo> Although I wouldn't have thought that would break this way either
13:19:23 <CosmicRay> I wonder if it's possible that the new ghc 6.4 got unpacked before prerm was run
13:20:08 <CosmicRay> but apt died in a strange way recently as well, hmm.
13:20:23 <CosmicRay> could be that things were left in some weird temporary state and then it did the wrong thing next time through
13:20:53 <Igloo> In fact, ghc6's postinst would have had to happen before the cabal prerm for this to happen
13:21:34 <CosmicRay> very strange.
13:21:57 * Igloo is filing it under "CosmicRay broke it" unless someone can work out how to reproduce it  :-)
13:22:10 <CosmicRay> fair enough
13:22:27 <Igloo> (or checks policy and finds we have to cope with this, which will be fun)
13:23:51 <Igloo> We should have 6.4 everywhere in unstable shortly after sparc gets off its arse and builds it, BTW
13:26:42 <SyntaxNinja> sweet
13:41:42 <humasect> ghc without libz? hmm...
13:43:16 <dcoutts> marcot, hello yes, you called!
13:47:38 * CosmicRay uploads ghc 6.4 hsql
13:47:42 * CosmicRay prepares ghc 6.4 missingh
13:48:44 <Igloo> You realise you might have fun getting it built for ia64/sparc?
13:49:02 <CosmicRay> Igloo: well, it's unusable everywhere else
13:49:25 <CosmicRay> if you apt-get install ghc6 on sid, a whole load of stuff gets removed due to being compiled for ghc 6.2
13:49:26 <Igloo> True...
13:50:03 <marcot> dcoutts: I was looking about cabal and I had a doubt, but now I can't remember what was it..
13:50:04 <marcot> =D
13:50:22 <dcoutts> ok, well ask if/when you remember :-)
13:56:25 <Philippa> Bugger, just crashed GHC...
14:02:37 <SyntaxNinja> marcot: doubts are not permitted.
14:03:18 * Philippa wonders whether she's done anything vaguely daft or it's just mutually-dependant modules being broken
14:04:21 <SyntaxNinja> JaffaCake will be sad to hear you say that
14:04:42 * CosmicRay uploads a ghc6.4 haskelldb and missingh
14:04:49 <Philippa> yeah. Thing is, I'm repeatedly crashing GHC
14:04:56 <Philippa> so /something's/ broken
14:06:37 <Philippa> ghc: panic! (the `impossible' happened, GHC version 6.4):
14:06:37 <Philippa>         expectJust upsweep_mod:old_linkable
14:07:38 <Philippa> dunno how easy it'll be to narrow down the code making it go bang though
14:07:44 <ski> <SamB> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
14:07:44 <ski> <SamB>         expectJust upsweep_mod:old_linkable
14:07:56 <Lemmih> CosmicRay: Did you upload my cabalization?
14:08:03 <CosmicRay> Lemmih: no, my own
14:08:07 <Lemmih> Good.
14:08:17 <CosmicRay> Lemmih: I fixed the mkTyCon problem myself, as well as a System.Time issue
14:09:38 <CosmicRay> autrijus: ping
14:11:44 <autrijus> CosmicRay: pong
14:11:45 <Philippa> okay, I was feeding it broken code
14:11:51 <Philippa> the module didn't import stuff it needed
14:11:58 <Philippa> (which apparently didn't get checked)
14:12:12 <CosmicRay> autrijus: were you able to pull the missingh lgpl branch ok, and did it work for you?
14:12:32 <CosmicRay> autrijus: incidentally, I just checked in a slew of ghc 6.4 changes to it
14:12:34 <Philippa> still crashes with that fixed
14:13:08 <Philippa> it's never compiling the non-boot version
14:13:56 <autrijus> CosmicRay: yes, it worked for me, but I had not updated in a few days
14:14:22 <CosmicRay> autrijus: ok, glad to hear that
14:15:00 <JaffaCake> Philippa: that one's fixed now
14:15:28 <JaffaCake> you probably have a dependency on an .hi-boot file, but not on the module itself
14:16:06 <Philippa> well yeah - how does that arise though? I'm using values from the module...
14:16:31 <JaffaCake> you just import the module with {-# SOURCE #-}, and never import it normally?
14:16:49 <Philippa> yeah, am I not supposed to do that?
14:16:56 <Philippa> (can I legally double-import?)
14:17:00 <JaffaCake> sure, it's just broken :)
14:17:09 <SyntaxNinja> heya JaffaCake
14:17:15 <JaffaCake> the workaround is to add the module to the command line explicitly
14:17:20 <JaffaCake> SyntaxNinja: hiya ;)
14:17:32 * Philippa nods
14:17:56 <Philippa> am just feeling a bit unsure about ending up dependant on the latest version of GHC when I'm just writing Haskell 98 + libs
14:18:31 <Philippa> and a build with no makefile required is a good thing AFAIC
14:18:41 <JaffaCake> so use the workaround, or rearrange your module structure so that you don't have any modules that are only imported via {-# SOURCE #-}
14:19:20 <Philippa> will I get yelled at by the
14:19:28 <Philippa> compiler for importing it twice in the same module?
14:19:58 <SamB> Philippa: what are you doing with mutually recursive modules?
14:20:06 <JaffaCake> no... but I didn't mean necessarily in the same module
14:20:25 <JaffaCake> as long as it is imported *somewhere* in your program without {-# SOURCE #-}, you're fine
14:20:46 <Philippa> SamB: specifying a default page for Flippi in a config module terms of a function in PageTemplates. PageTemplates depends on the config module
14:21:17 <Philippa> I guess for now I go with the less flexible config option that doesn't let you give a non-wiki-page default
14:21:26 <Philippa> that way I eliminate the mutual dependency
14:22:13 <SamB> is it appropriate to chime on on glasgow-haskell-bugs when you have the same problem?
14:22:23 <SamB> s/on on/in on/
14:22:28 <Philippa> JaffaCake just said it's fixed now
14:22:34 <Philippa> (saved me finishing a post too)
14:22:35 <SamB> oh it is?
14:22:57 <Philippa> yeah. Being on windows I don't fancy building a new GHC though :-)
14:23:11 <SamB> Philippa: you mean you didn't even search the list for "expectJust upsweep_mod:old_linkable"?
14:23:19 <JaffaCake> google for the error, I just closed the bug on sourceforge today
14:23:33 <SamB> JaffaCake: there was a bug on sourceforge?
14:23:55 <SamB> so, where can I get fixed binaries?
14:24:13 <Philippa> SamB: it only literally just happened, so bitching in here seemed the thing to do :-)
14:24:15 <JaffaCake> http://sourceforge.net/tracker/index.php?func=detail&aid=1199529&group_id=8032&atid=108032
14:24:24 <Philippa> ah well, so much for implementing subpages tonight
14:24:40 <Philippa> but yeah, I should've searched the list
14:25:26 <Philippa> linking Flippi's starting to take a while on here, that's scary
14:25:35 <SamB> I think I misread that a little while ago...
14:27:00 <SamB> well, misunderstood it really...
14:27:03 <Philippa> and now I get to rebuild to hardware an extra space into some of the HTML :-(
14:27:08 <Philippa> (hey, 'smy own fault...)
14:27:25 <musasabi> Philippa: is Flippi something that I could consider for wikis - as compared to other wiki-engines?
14:28:01 <Philippa> not yet
14:28:16 <Philippa> give me a while and the core of it will be, but it'll be lacking in plugins for features that're usually built-in
14:28:46 <Philippa> was talking to Shae and realised you could build authentication and priviledges entirely via a plugin, for example
14:29:27 <Philippa> not quite in the current version, but it'd only take piping a little more info to the IO operations
14:30:03 <musasabi> Well currently I am using heavily hacked usemods, and a pmwiki which is also quite modified.. But I am not happy with either one. (killed the old twiki few months ago - that was the most painful one)
14:30:12 <Philippa> I'd love to have the tuits to turn it into something competetive, and I think Shae's planning on writing plugins once I'm API-stable
14:31:09 <musasabi> Having the authentication in a plugin is quite essential since some people need to do complex database driven authentication..
14:31:11 <SyntaxNinja> musasabi: why was twiki painful?
14:31:17 <Philippa> you'll find the lack of markup a really bad thing atm. If you need user priviledges beyond "I own the data dir and thus the data", that'd need implementing from scratch
14:31:38 <Philippa> musasabi: right. OTOH, normally the mere existance of hooks for authentication would be in the core system
14:32:22 <musasabi> SyntaxNinja: administration and changes took much more time than would have been nice.
14:33:08 <Philippa> musasabi: if you want to poke around the version in darcs and let me know what stuff you'd need featurewise that'd be useful to give me something to aim at if nothing else
14:33:56 <Philippa> adding new markup's fairly easy, though I've not fully documented the markup plugins yet (they involve a weird trick to let you write 'any valid markup except the bit I'm parsing here' in a Parsec parser)
14:34:30 <Philippa> adding the equivalent of MoinMoin's actions is dead easy, and you can muck around with metadata easily now
14:34:51 <musasabi> Philippa: maybe in the weekend, but I don't know how much time I will have.
14:35:22 <Philippa> fair enough
14:35:33 <Philippa> I'll be AFK all weekend though - want an email addy?
14:35:47 <wagle> @seen shapr
14:35:48 <lambdabot> I saw shapr leaving #haskell 4 days, 5 hours, 35 minutes and 29
14:35:48 <lambdabot> seconds ago.
14:35:57 <wagle> eek
14:36:05 <musasabi> Philippa: that would be nice.
14:36:11 <wagle> where'd he go?
14:37:34 <Igloo> Ooo
14:37:39 <Igloo>   Modified files:
14:37:39 <Igloo>     libraries/HaXml/docs index.html
14:37:39 <Igloo>   Log:
14:37:39 <Igloo>   Note location of new darcs repository.
14:38:19 <SyntaxNinja> yay malcolm :)
14:45:03 <SamB> JaffaCake: could you see if my other bug still happens?
14:45:27 <JaffaCake> SamB: I'm just looking for your bug reports, and I can't find em
14:45:52 <SamB> JaffaCake: sorry, I sent them straight to the mailing list. I only did what GHC told me to do!
14:46:03 <SamB> the glasgow-haskell-bugs list, that is
14:46:08 <JaffaCake> that's fine... but I don't seem to have them
14:46:33 <JaffaCake> oh, found one on the archives
14:46:48 <JaffaCake> maybe you got swallowed up by my crappy spam filter
14:46:59 <SamB> http://news.gmane.org/find-root.php?group=gmane.comp.lang.haskell.glasgow.bugs&article=2578
14:48:01 <Igloo> I'm surprised you spam filter the Haskell lists - they're virtually spam free (thanks to you, I think!)
14:48:01 <JaffaCake> there are two messages about the upsweep_mod crash.. is there something else?
14:48:10 <x3n0n> hm.
14:48:20 <x3n0n> @pl \g -> [length g, head g]
14:48:21 <lambdabot> liftM2 (:) length ((: []) . head)
14:48:28 <JaffaCake> Igloo: I don't, by choice - I've been trying to turn off Outlook's default spam filtering for ages without success
14:48:34 <x3n0n> @type \g -> [length g, head g]
14:48:35 <lambdabot> \g -> [length g, head g] :: [Int] -> [Int]
14:48:37 <SamB> JaffaCake: the one I just gave a url for also involves Template Haskell
14:48:51 <x3n0n> @type Control.Monad.liftM2 (:) length ((: []) . head)
14:48:53 <lambdabot> bzzt
14:49:00 <Lunar^> Daniel Carrera is really an interesting case :)
14:49:18 <JaffaCake> SamB: It's most likely the same bug
14:49:18 <SyntaxNinja> Lunar^: ?
14:49:28 <x3n0n> @pl \g -> (g,g)
14:49:29 <lambdabot> join (,)
14:49:49 <Lunar^> SyntaxNinja: I find it pretty fun to watch his progresses since one month
14:49:59 <poetix> Hi folks
14:50:19 <JaffaCake> and one week of that was trying to build GHC :-S
14:50:22 <SyntaxNinja> Lunar^: is he the one that started learning by asking a bunch of sorta deep questions about its nature
14:50:27 <SyntaxNinja> s/its/haskell's
14:50:39 <Igloo> JaffaCake: But you needed it for policy reasons, or having all the contact info in it, or something, presumably?  :-(
14:51:37 <SamB> JaffaCake: if you fixed the bug, you can presumably test to see what happens when compiling the TH code using a fixed GHC, right?
14:51:44 <poetix> I'm having trouble making State (Maybe s) an instance of MonadPlus
14:52:10 <JaffaCake> SamB: probably, yes :)  (I normally just punt anything related to TH on to Simon PJ)
14:52:36 <SyntaxNinja> JaffaCake: you're not supposed to punt to your own team
14:52:51 <JaffaCake> sorry, delegate
14:53:05 <SamB> I don't want an explanation of what is going on, just the stdout ghc --make RecClass.hs
14:53:29 <SamB> s/stdout/stdout of/
14:53:32 <Lunar^> SyntaxNinja: Duncan Coutts ask for packages like FooBar-1.2.3.. but that's a bit annoying to have uppercase letter for Debian packages, right?
14:53:55 <Lunar^> SyntaxNinja: sorry, tarballs like FooBar-1.2.3.tar.gz
14:54:09 <SamB> SyntaxNinja: your confusing software maintenance with sports, methinks
14:54:10 <Igloo> Only if they clash, which should be socially unacceptable anyway
14:54:35 <SyntaxNinja> Lunar^: nothing says that the debian packages have to be the same names as the cabal packages
14:54:48 <SyntaxNinja> well, maybe something does ;)
14:54:59 <Igloo> SyntaxNinja: The binary packages have to for automatical Debianisation to work
14:55:17 <Lunar^> SyntaxNinja: it's on libraries@
14:55:17 <SamB> couldn't we prefix "cabal-" to them?
14:55:29 <Igloo> Hmm, my fingers seem to have got half way to "automatically" before I stopped them
14:56:27 <SyntaxNinja> we can ask people not to have caps in the packagenames
14:56:43 <SyntaxNinja> Igloo: are debs not allowed to have caps?
14:56:58 <Igloo> No, but we can just lower case them
14:57:08 <Igloo> Although -s would probably be more readable
14:57:54 <SyntaxNinja> -s?
14:57:59 <Igloo> (i.e. it would result in more readable Debian package names if cabal disallowed caps)
14:58:04 <Igloo> '-'s
14:58:08 <Igloo> dashes
14:58:10 <JaffaCake> SamB: I'll look into that tomorrow.. I'm still mystified what happened to your emails, they don't seem to be in my junk folder either
14:59:24 <JaffaCake> later folks
15:01:37 * SamB wonders how much work it is to stick 3 attachments in a directory and run ghc --make RecClass.hs
15:45:56 <dcoutts> Lunar^, I'm not asking for upper case names, for Gentoo we make them all lower case too. But since Cabal specifies that the package names may contain upper case letters, we packagers/distributors just have to live with that. I thing it's better for the tarball name to match the cabal package.
15:46:40 <Muad_Dibber> Cabal?
15:46:41 <dcoutts> We'd be perfectly happy to require all lower case names as it'd make packaging easier, but it's something we can cope with.
15:50:47 <Cale> Muad_Dibber: http://www.haskell.org/cabal/
15:51:19 <Muad_Dibber> ah
15:52:39 <dcoutts> SyntaxNinja, if we're talking about names, as I've said is ok to have upper case package names (debian, fedora, gentoo etc can just lower case them), but it would be good for Hackage to enforce no name clashes using case insensitive names so that we don't get two distinct cabal/hackage packages that map to the same lower case name.
15:54:27 <Muad_Dibber> so in fact: case sensitive is more powerfull, but case insensitive is more practical
15:55:07 <tuomov> case insensitive is impossible
15:55:13 <tuomov> works with ascii but..
15:56:21 <dcoutts> tuomov, sadly I think most distro packaging systems do not support unicode either :-(
15:57:03 <tuomov> lowercase ascii and numbers is a good subset for most of the stuff on the filesystem
15:57:33 <Muad_Dibber> well
15:57:44 <Muad_Dibber> we could define lowercase unicode as:
15:58:00 <Muad_Dibber> the lowercase if it exists (like in standard [a..z])
15:58:03 <Muad_Dibber> itself otherwise
15:58:53 <tuomov> There may be differences in languages how things transform between cases
16:00:54 <tuomov> international character sets are a mess
16:01:42 <Muad_Dibber> so give me an example that is a problem :P
16:02:09 <tuomov> I don't know, but I've read that there are lots of problems with such things
16:02:17 <tuomov> some language might e.g drop accents for uppercase
16:02:39 <mauke> greek has two different lowercase sigmas
16:03:02 <mauke> which is used depends on the position within a word
16:03:03 <Muad_Dibber> mauke : that indeed is a problem
16:03:15 <Muad_Dibber> but then again we dont have to be context free
16:03:30 <mauke> german  doesn't have an uppercase equivalent
16:03:42 <Muad_Dibber> we when translating uppercase to lowercase we will know what sigma we have
16:03:52 <tuomov> mauke: it's written SS in upper case?
16:04:59 <tuomov> Muad_Dibber: in this special case of package names, but generally case insensitiveness is not viable
16:05:51 <Muad_Dibber> problem with computer science is always that trying to be general causes (sometimes currently insolvable) problems
16:06:00 <mauke> tuomov: yes, so you have to look at the word to decide whether SS lowercases to ss or to 
16:06:34 <tuomov> It can't always lowercase to ?
16:07:08 <mauke> nope
16:07:17 <mauke> lc("WASSER") should be "wasser"
16:07:39 <tuomov> so you can't always exchange ss and  in words?
16:07:48 <ski> iirc "" can always be replaced by "ss", but not vice versa ..
16:07:53 <tuomov> or is it just case translation?
16:08:06 <mauke> they're different
16:08:23 <mauke> ss indicates that the preceding vowel is short
16:08:29 <ski> (that's what german teacher said, anyways)
16:08:44 <tuomov> oh..
16:08:44 <Igloo> mauke: Do spelling mutate between the two over time more than other mutations OOI?
16:08:44 <mauke>  follows long vowels or diphthongs
16:09:10 <Igloo> I guess there's no reason why it should if you're used to a language that has it
16:09:29 <tuomov> well, that's a very good example why case insensitiviness doesn't work
16:09:44 <Muad_Dibber> is there currently any file system that supports unicode names?
16:09:59 <tuomov> iso9660+joliet?
16:10:04 <tuomov> fat32?
16:10:12 <mauke> there are additional problems because Swiss simply uses "ss" in all cases
16:10:13 <Muad_Dibber> wasnt sure about fat
16:10:21 <tuomov> and everything with long names in utf8?
16:10:36 <mauke> so you have to know if it's de_DE or de_CH
16:10:49 <tuomov> unix filesystem don't really care about the encoding..
16:11:45 <Muad_Dibber> problem is though that depending on the file system, the mapping from package name to file names has a different degree of "correctness"
16:15:13 <SyntaxNinja> dcoutts: OK.
16:16:47 <dcoutts> SyntaxNinja, ta
16:28:33 <SyntaxNinja> Lemmih: you might pull my hackage repo again
16:28:43 <SyntaxNinja> Lemmih: just added dcoutt's request to the TODO list
17:28:06 <juhp> dcoutts: can I msg you?
17:29:15 <dcoutts> juhp, sure
17:32:32 <SyntaxNinja> dcoutts: can I?
17:33:03 <dcoutts> SyntaxNinja, yes, if you don't mind me being slow and flitting between converstions :-)
17:33:11 <Pseudonym> Whoops.
17:34:19 <SyntaxNinja> \msg dcoutts I have something very important and very secret to tell you... there IS a Haskell Cabal
17:34:21 <SyntaxNinja> oops!
17:34:34 <Pseudonym> So like I said, we dump the body...
17:34:36 <Pseudonym> Oops!
17:34:39 <Pseudonym> Sorry, mistell.
17:36:01 <SyntaxNinja> Pseudonym: I've seen two very very funny "oops wrong window" things on IRC; one was a confession of a crush one of my friends, and one was something perverted
17:36:13 <dcoutts> SyntaxNinja, :-)
17:36:22 <SyntaxNinja> I think the person with the crush was more embarassed than the other guy
17:36:44 <Pseudonym> That makes sense.
17:37:03 <Pseudonym> Crushes are often private, whereas perversions are often not.
17:37:14 <Pseudonym> Certainly in this day and age.
17:37:18 <SyntaxNinja> I use the term "perverted" in the sense "stuff that you don't want to post to a public channel"
17:37:24 <Pseudonym> Right.
17:37:25 <SyntaxNinja> not as a judgement
17:37:39 <SyntaxNinja> but yeah, I agree
17:37:39 <Pseudonym> Look, pervs call themselves pervs.  It's kind of an owned word.
17:37:56 <SyntaxNinja> yeah
17:38:25 * Pseudonym knows a lot of pervs for some reason
17:38:40 <SyntaxNinja> Pseudonym: do they msg you a lot? ;)
17:38:48 <Pseudonym> Yes, but about geeky things.
17:39:13 <SyntaxNinja> isn't that always the way
17:40:11 <Pseudonym> One particular friend of mine had to split her website in two, so that people who were looking for her CV didn't find photos of her more intimate piercings.
17:40:11 * Pseudonym shrugs
17:44:00 <wagle> 60 something straightlaced conservative christian one-time landlord of mine was talking to young female nose/lip pierced tenant, and couldn't contain himself any longer: "doesn't that hurt?!" he asked.  "oh no!" she replied, and starts quickly describing her other piercings, flipping him a close view of exhibit A, her nipple piercings..
17:44:51 <kosmikus> HCAR out! :)
17:45:18 <dons> yay :)
17:46:27 <wagle> hcar?  google wants to know if you meant _hair_..  8)
17:47:15 <wagle> haskell communities and activities report?
17:48:18 * wagle waits
17:48:58 <dons> that's HCAR, yes.
17:49:13 <dons> http://www.haskell.org/communities/
17:51:24 <wagle> google showed me http://sequence.complete.org/node/55
17:51:34 <wagle> which leads to there
17:53:47 <wagle> egad, thats cool!
17:55:48 * kosmikus is tired ...
18:34:22 <stepcut> So, I want to parse a wiki-like input and produce xhtml 1.1 strict output, which xhtml generator should I use ?
19:01:57 <dons> @seen Phillipa
19:01:58 <lambdabot> I haven't seen Phillipa.
19:02:43 <dons> @seen Philipa_
19:02:44 <lambdabot> I haven't seen Philipa_.
19:02:47 <dons> @seen Philippa_
19:02:48 <lambdabot> I saw Philippa_ leaving #haskell 11 hours, 50 minutes and 36 seconds
19:02:48 <lambdabot> ago.
19:02:59 <dons> one l, two p's
19:03:23 <dons> @seen Philippa
19:03:24 <lambdabot> Philippa is in #haskell. Last spoke 4 hours, 27 minutes and 49
19:03:24 <lambdabot> seconds ago.
19:20:58 <Excedrin> would anyone here like to comment on http://mindview.net/WebLog/log-0025 ?
19:21:27 <Excedrin> it's an article about static and dynamic typing in C++ and Python
19:34:54 <stepcut> hrm, I wonder why my executable is linked against libreadline
20:39:47 <SamB> is it just me or do class constructors become type constructors in Core?
20:41:34 <dons> class constructors?
20:41:46 <SamB> whatever you call them
20:42:07 <SamB> they look like type/data constructors... they name classes...
20:43:02 <dons> class defns compile to data defns. instances create data values containing functions defined by instances. F => contraints become F_dict -> arguments
20:43:46 <Pseudonym> Isn't Core based on second-order lambda calculus?
20:43:58 <Pseudonym> i.e. doesn't it have type lambdas and type applications?
20:44:03 <dons> it's System F. so yep.
20:44:21 <SamB> is that what @ is for?
20:44:26 <dons> that's type application
20:44:29 <dons> like []@Int
20:44:53 <dons> where [] is really GHCziListziZMZN
20:45:22 <SamB> I'm looking at GHC/Base.hi
20:45:44 <SamB> for instance:
20:45:46 <SamB> $fEqBool :: Eq GHC.Base.Bool
20:45:46 <SamB>   {- HasNoCafRefs Strictness: m Unfolding:  (:DEq @ GHC.Base.Bool ==4 /=3) -}
20:46:16 <dons> Dictionary for Eq applied to Booleans
20:46:54 <dons> (remember that class names become dictoinary types)
20:47:28 <SamB> yes, I remember. How can I forget when I see $fEqBool :: Eq GHC.Base.Bool? thats what made me guess that in the first place ;-)
20:47:39 <SamB> well, that or another quite similar line
20:49:18 <SamB> I wonder why in the world I get errors like:
20:49:29 <SamB>     GHC internal error: `MMix.Memory.$dmtoSigned' is not in scope
20:49:30 <SamB>     In the definition of `toSigned': toSigned = MMix.Memory.$dmtoSigned
20:49:30 <SamB>     In the definition for method `toSigned'
20:49:30 <SamB>     In the instance declaration for `SignConversion Int64 Word64'
20:49:41 <SamB> when I try to splice in instance declarations...
20:49:44 <Pseudonym> Because of a bug in GHC.
20:49:51 <Pseudonym> Any "GHC internal error" is a bug.
20:49:54 <SamB> well, yeah, I figured that.
20:50:00 <Pseudonym> :-)
20:50:25 <SamB> Its so buggy, it doesn't even tell me to submit a bug report!
20:51:02 <Pseudonym> In 1993, there were over 65,000 open bugs in Solaris.
20:51:11 <dons> can you splice instances? or, if you are, perhaps you're constructing them incorrectly (a bug none the less)
20:51:16 <Pseudonym> The joke was that bug number 65,536 was "overflow in bug reporting software".
20:51:23 <dons> yeah. cool.
20:51:26 <Gahhh> cute
20:51:39 <SamB> but why would something like a splice make the default implementation of that typeclass function be out of scope?
20:51:40 <dons> that's a phenomenal number of open bugs.
20:51:48 <Pseudonym> Solaris was a new thing at the time.
20:51:59 <Pseudonym> And it was very ambitious.
20:52:12 <Gahhh> I expect massive amounts of duplicates there
20:52:21 <SamB> Gahhh: no doubt!
20:52:39 <SamB> how could you weed out the duplicates from 65000 open bugs?
20:52:48 <Gahhh> one by one
20:53:06 <SamB> don't they usually pop up faster than that?
20:53:16 <Gahhh> yes. isnt sw engr fun/
20:53:28 <dons> Data.List.nub of course.
20:53:38 <dons> nubBy
20:54:18 <SamB> dons: first you would need to define a usefull instance for Eq Bug
20:54:34 <dons> that's an exercise for the reader.
20:54:54 <SamB> dons: well, the trouble is all the implementions so far are in meat
20:55:14 <SamB> and there is no FFI to meat
20:55:40 <dons> does meat use a C calling convention?
20:55:45 <dons> then it might be possible.
20:55:48 <SamB> even if there was, the meat would get tired before nubBy returned...
20:56:03 <SamB> dons: no, it uses a variety of rather baroque calling conventions
20:56:25 <dons> then perhaps we can call meat though C, like perl
20:56:36 <dons> C -> hardware -> brain and back
20:56:49 <dons> seems doable..
20:57:07 <SamB> there is still the issue of meat not being as fast as greased lightning
20:57:22 <SamB> and the fact that meat wouldn't reliably implement Eq anyways
20:57:37 <dons> or perhaps we could use DrIFT to derive Eq on Bug. that might be easier.
20:57:37 <SamB> and there is no Unsure data constructor in Bool
20:59:04 <dons> Oleg chimes in on the fixed length vector question..
20:59:19 <SamB> any clue where I can get a copy of "An External Representation for the GHC Core Language" that gv can open?
20:59:35 <dons> it's in $fptools - so you could build it.
21:00:11 <SamB> if I still had the tree. Right now I'm on 56k, so I don't really want to try checking it out again...
21:00:15 <dons> also, there's some discussion of how to read Core in my jvm/haskell thesis. it's googleable, I think
21:00:55 <dons> what's wrong with http://www.haskell.org/ghc/docs/papers/core.ps.gz
21:00:55 <dons> ?
21:01:11 <SamB> I suppose I should try grabbing that one and see if it works...
21:01:36 <SamB> after all, I don't remember where I got it before, and they might have easily rebuilt it...
21:23:18 <stepcut> So.. I am trying to install the new Haskell XML Toolkit
21:23:35 <stepcut> which depends on the new HTTP library
21:23:45 <stepcut> which depends on the NewBinary
21:24:04 <stepcut> but the NewBinary cabal package is out of date
21:24:16 <stepcut> and guess who's fault *THAT* is
21:24:30 <shelarcy> HttpCurlOrNative depend on HTTP
21:25:07 <shelarcy> HTTP also depend on Cryptographic library
21:25:51 <shelarcy> Cryptographic Library's samples programm depend on NewBinary
21:26:17 * stepcut maintains the NewBinary cabal package
21:41:33 <Pseudonym> I can't believe I have to defend generic programming on haskell-cafe of all places.
21:41:35 <monochrom> haha, your mistake haunts you
21:41:44 <Pseudonym> On perl5-porters I could understand it.
21:43:41 * monochrom runs over to haskell-cafe - hasn't read it for days
21:56:43 * SamB wonders if anyone actually uses 100-tuples
21:57:46 <monochrom> I guess Oleg writes a program that writes a program that writes a program that .... (10 more stages) ... that uses 100-tuples.
21:58:21 <SamB> I thought he wrote types that wrote programs?
21:58:37 <monochrom> I'm being vague.
21:59:19 <Gahhh> I didn't even know about The Haskell Sequence. Sheesh.
21:59:37 <monochrom> I now see why people oppose generic programming.  It would produce programs that use 100-tuples.  The compiler guys won't like that. :)
22:00:09 <SamB> well, 100-tuples are fine. its when they try to use unboxed 101-tuples that we have problems.
22:01:23 <Pseudonym> 100-tuples are nothing.  It's not a real program generator unless it grows at least as fast as Ackerman.
22:03:04 <SamB> does ghc have bigger tuples than 100?
22:04:10 <SamB> hmm, the --show-iface for Data.Tuple looks *really* bad...
22:07:38 <SamB> okay, it looks like ghc can handle really really big boxed tuples...
22:09:04 <SamB> I just filled just about an entire terminal with :t (,,,,[...],,,,) and it is still printing the type...
22:09:38 <SamB> looks like GHC supports even 1907-tuples...
22:14:46 * SamB wonders why (according to this paper) the Int64# ops are implemented as ccalls...
23:08:00 <dons> SamB: they go via the gmp?
23:12:19 * lispy wonders if anyone know the spelling for the word that means place where sausage is made.
23:12:30 <lispy> My horrible phonetic attempt is shacutery
23:12:39 <lispy> sha-coo-tery
23:13:01 <dons> the spelling in french?
23:13:18 <Gahhh> I think there is an R
23:13:21 <lispy> dons: hmm...i had assumed german, but i bet it is french now that you mention it
23:13:50 <Gahhh> http://www.arobase.fr/CharcuterieM/
23:14:07 <unknow__> some girl it want's talking for me?
23:14:38 <dons> so much nicer sounding than "butcher"
23:14:41 <lispy> Gahhh: thanks!
23:15:15 <lispy> i often think it sounds like a womans naughty bits :)
23:15:35 <Gahhh> all words make me think of women.
23:15:44 <lispy> i have a silly use for it, i'm using it as a place holder in something i'm writing.  When I see it I will know to fix it :)
23:23:44 <dons> @plugs undefined
23:23:47 <lambdabot> Ambiguous type variable `a' in the top-level constraint
23:23:52 <dons> @plugs undefined :: ()
23:23:54 <lambdabot> Fail: Prelude.undefined
23:24:00 <dons> that's another option ;)
23:27:04 <dons> anonyone know of good graph libraries other than Data.Graph and Data.Graph.Inductive?
23:27:14 <dons> anonyones
23:27:45 <lispy> dons: there is one on the haskell.org site
23:28:02 <lispy> but prehaps you've already tried it
23:28:33 <dons> someone working with me is looking for one.
23:29:04 <dons> I think the problem is that the common ones don't let you test for cycles (?)
23:30:04 <lispy> i was looking for the one by Martin Erwig
23:30:35 <lispy> http://www.edite-de-paris.com.fr/~fpons/Caml/Ressources/graphs.html
23:31:03 <dons> is that Haskell?
23:31:21 <lispy> dons: should be Erwig is really into haskell
23:31:29 <lispy> and i orginally heard about it from the haskell.org site
23:31:36 <dons> ah!
23:31:50 <lispy> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
23:32:13 <Gahhh> the latest community report makes it look like everybody is writing in haskell !
23:32:37 <dons> lispy, thanks. (that's Data.Graph.Inductive isn't it?)
23:32:45 <dons> Gahhh, they aren't??
23:33:11 <Gahhh> dons: yes, they are, for some definition of everybody :)
23:33:30 <dons> for some definition.
23:33:54 <lispy> dons: it may be, if it is, sorry!
23:35:26 <Gahhh> OMG YUO!!!1
23:35:31 <Gahhh> oops
23:36:32 <zamez> heh
