00:05:32 <Itkovian> @seen boegel
00:05:33 <lambdabot> I saw boegel leaving #haskell 8 hours, 15 minutes and 52 seconds ago.
00:17:13 <[TWiSTED]> wow
00:26:45 <boegel> olleh everyone
00:26:58 <Lemmih> oy
00:29:37 <crab> oh, hi wli.
00:35:13 <Itkovian> hi boegel.
00:42:21 <Consystor> re
01:11:46 <boegel> @seen shapr
01:11:47 <lambdabot> I saw shapr leaving #haskell 2 days, 9 hours and 23 seconds ago, and
01:11:47 <lambdabot> I have missed 10 seconds since then.
01:11:55 <boegel> still working on FLM ?
01:18:32 <Lunar^> yep
01:19:05 <Lunar^> I wonder how shapr's new focus on working code will affect the Haskelll community
01:20:28 <boegel> Lunar^: it's can't be a negative thing, can it ?
01:21:18 <Lunar^> boegel: it can.. shapr kinda acted like our project hub
01:21:30 <Lemmih> Project hub?
01:21:40 <Lunar^> boegel: I mean, he mostly new every Haskell project
01:21:45 <Lunar^> knew
01:22:04 <Lunar^> maybe "hub" is not the right word
01:32:54 <boegel> Lunar^: I see
01:33:09 <boegel> but it's not like we _need_ shapr to start up new projects right
01:34:10 <Lunar^> boegel: nope, I didn't say that. But with shapr, you could ask if no one ever did it before first :)
01:38:17 <boegel> :)
01:40:55 <boegel> Lunar^: and still I'll try and set up 3d modelling application project with Haskell
02:12:01 <sylvan> boegel: Interesting. Anything particularly exciting about it, or just "3d in haskell"?
02:12:19 <Lunar^> JaffaCake: about nightly build, why not build a tarball on cvs.haskell.org and fetch it via HTTP?
02:12:46 <boegel> sylvan: well, I guess we could use my raytracing code as a start, and also bourbaki has some stuff with splines, maybe we can start combining those two
02:13:07 <JaffaCake> Lunar^: yeah, I could do that
02:13:47 <Lunar^> JaffaCake: was the build script already doing a full checkout each time?
02:13:49 <JaffaCake> I can also go back to using SSH
02:13:55 <JaffaCake> yes
02:15:07 <Lunar^> JaffaCake: Ok, so fetching a tarball each time is not really an overhead
02:15:31 <JaffaCake> seems a bit strange when we already have anon CVS, thought
02:15:37 <JaffaCake> s/thought/though/
02:16:56 <Lunar^> CVS.. *sigh*
02:17:04 <Lunar^> You could try OpenCVS, maybe
02:17:20 <Lunar^> (OpenBSD's implementation)
02:17:32 * Lunar^ don't understand this BSD folks, anyway
02:17:48 <JaffaCake> I don't think CVS is the problem
02:17:49 <Lunar^> Why reimplement CVS now? In C, even?
02:18:00 <JaffaCake> yeah, who knows
02:18:08 * JaffaCake shrugs
02:18:21 <Lunar^> JaffaCake: is it network related?
02:18:34 <JaffaCake> probably, I guess
02:18:55 <JaffaCake> maybe a problem with the proxy client we're using (dante), I might try upgrading that
02:21:09 <jlouis> RRR/g 7
02:21:12 <jlouis> rrrrarrr
02:36:33 <sylvan> bourbaki: Wouldn't you need a real-time mode s well? HOpenGL comes to mind...
02:37:00 <sylvan> that was for boegel
02:37:21 <sylvan> :-)
02:38:57 <boegel> sylvan: I have no idea about all those things... idea's are very welcome
02:39:06 <boegel> @wiki
02:39:07 <lambdabot> http://www.haskell.org/hawiki/
02:43:56 <boegel> @wiki H3D
02:43:57 <lambdabot> http://www.haskell.org/hawiki/H3D
02:44:02 <boegel> sylvan: ^
02:44:20 <boegel> sylvan: you're welcome to add any suggestions you might have
02:48:36 <nlv11757_> bah, you need to be identified for some chans
02:50:06 <swiert> does anyone here understand the theory of patches behind darcs?
02:54:27 <Lor> I think I grok a little bit.
02:55:14 <swiert> Lor: I've had a look at the darcs manual. What I'm not quite clear on is - what does darcs do with patches?
02:55:38 <Lor> Uh, quite a bit.
02:56:07 <dons> patches are `first class' values in darcs.
02:56:07 <swiert> obviously - in particular, why do you want to reorder/merge patches?
02:56:25 <dons> unlike cvs, which has no notion of a patch
02:56:32 <Muad_Dibler> swiert: wasnt that usefull for branches or something?
02:56:41 <Lor> Because in Real World, sometimes you get numerous patches that are against the same version.
02:57:05 <earthy> and you may get them in random order
02:57:09 <Lor> And branches, and whatnot. If you've ever used CVS, you should know why one sometimes needs to merge.
02:57:10 <earthy> and you may want to reorder them
02:57:17 <Lor> ...and that CVS does it pretty badly.
02:57:25 <earthy> pretty darn badly
02:57:25 <swiert> why would you want to reorder them?
02:57:48 <Lor> Reordering is just a way of merging them.
02:57:52 <Muad_Dibler> svn seems enough for practical assignments
02:57:56 <Muad_Dibler> but of course that is not real world :)
02:58:02 <earthy> swiert: suppose I make 2 patches, one of them to solve an issue, another to add a feature
02:58:10 <earthy> but I add the feature *before* I solve the bug
02:58:24 <earthy> then I may want to release the software with just the bugfix, not the added feature
02:58:36 <swiert> ok that makes sense
02:58:37 <earthy> but, to do that, I'd need to reorder the two patches
02:58:45 <Lor> Suppose you have a version A, and a patch AB, and a patch AC, and you want to get a patch BD which is as AC but applied to B.
02:59:27 <Muad_Dibler> but what if the patch solves a bug that is introduced with the feature?
02:59:33 <Lor> Then you invert AB and add AC, so you get a compound patch BAC.
03:00:15 <Lor> Then you swap the two patches, and get BXC, where BX is as AC but applied to B, and XC goes from X (the compound patch) to C.
03:00:44 <earthy> muad_dibler: then you wouldn't want to release that, now would you?
03:00:49 <Lor> And then you invert XC and get CX, and there you are.
03:01:05 <Lor> (Oops, sorry, now I generated CD instead of BD, but the other case is symmetric)
03:01:06 <swiert> what other patch manipulations are there besides merging parallel patches and reordering sequential patches?
03:01:16 <Lor> Inverting.
03:01:26 <Muad_Dibler> earthy: not about wanting
03:01:37 <Lor> You can implement merging with commutation and invesion, or you can implement commutation with merging and inversion.
03:01:39 <Muad_Dibler> earthy: i was wondering if you can then still reorder those patches
03:02:37 <RemiTurk> hi all
03:02:45 <earthy> well, probably not, muad_dibler
03:03:16 <earthy> although... it depends
03:03:29 <Muad_Dibler> does darcs know about that?
03:03:30 <earthy> if you add code to add the feature, then probably not
03:03:40 <earthy> yes, it knows whether or not it can reorder
03:03:47 <Muad_Dibler> okay
03:03:59 <Muad_Dibler> now this would've been a nice topic to add to software engineering :P
03:13:44 * boegel sees the term "software engineering" and start twitching all over his body
03:24:23 * Muad_Dibler calms down boegel
03:27:16 * boegel freaks out
03:27:22 <boegel> bliehblahbloehblaaaaargh
03:31:32 * Muad_Dibler ctrl-alt-deletes boegel :P
03:32:29 * boegel returns a bsod
03:40:47 * jlouis zaps boegel 
03:40:51 <jlouis> cattleprods good
03:47:31 <boegel> hey Itkovian (again)
03:53:06 <foxy_> *Main> let foo = show
03:53:13 <foxy_> *Main> :t foo
03:53:19 <foxy_> foo :: Integer -> String
03:53:25 <foxy_> hm
03:53:26 <boegel> @type show
03:53:31 <lambdabot> show :: forall a. (Show a) => a -> String
03:54:00 <foxy_> let bindings don't seem to work properly for Class instances
03:55:03 <Lemmih> foxy_: That's just the defaulting rule kicking in.
03:55:14 <foxy_> what's that?
04:05:56 <boegel> foxy_: Hugs uses a default type because it can't use polymorfic types (maybe my choice of words isn't 100%, but hey)
04:06:54 <Lemmih> Defaulting is nothing but a convenience feature.
04:08:04 <Lemmih> You really don't wanna specify the type every time you use a number.
04:22:41 <seidan> I'm trying to build a specific simulation system with the ST monad. But how can I dump intermediate sy
04:22:50 <seidan> ... states
04:23:17 <seidan> I mean from within foo in runST foo?
04:27:05 <Philippa> if you want a complete state dump you'll need some kind of structure that contains (references to) all the state
04:27:26 <Philippa> if you've got a live set of objects or something like that it'll do fine
04:30:49 <seidan> the state is basically a couple of STArrays and a (random access) priority queue I made from some more STArrays... I can't preserve references to because then the hidden state escapes. I guess I can use unsafe{Freeze,Thaw} on them...
04:31:49 <seidan> btw, what does ' a live set of objects' mean?
04:35:16 <bourbaki> moin
04:41:32 <Philippa> seidan: the set of (simulation) objects that are 'live' (in use)
04:41:48 <Philippa> 'lo
04:42:24 <yain> folks
04:42:40 <yain> Prelude> (16 ^ 8) * abs( sin 1 )
04:42:40 <yain> 3.6140903602828283e9
04:42:42 <yain> i don't get it
04:42:58 <yain> something wrong with my types?
04:43:37 <Igloo> What don't you get?
04:43:52 <yain> why it returns such a strange result
04:44:05 <mauke> what do you mean by "strange"?
04:44:12 <Igloo> @type sin
04:44:19 <Igloo> Oh
04:44:23 <yain> i mean that 16^8 * sin X is never 3
04:44:24 <lambdabot> sin :: forall a. (Floating a) => a -> a
04:44:29 <Igloo> Ah
04:44:35 <mauke> yain: ...e9
04:44:41 <Igloo> 3.6e9 = 3.6*10^9
04:44:51 <yain> omg
04:44:52 <yain> sorry
04:45:51 <Igloo> But for the record...
04:45:54 <Igloo> @plugs 16^8 * abs( sin 6.98491930961609e-10 )
04:46:11 <lambdabot> 3.0000000000000004
04:46:32 <seidan> Philippa: oh. hi. thanks. Maybe I should just be doing this within the IO monad instead... IOArrays seem better for what I havve described.
04:48:15 <musasabi> How do I get hugs to use cpp ?
04:49:35 <musasabi> Ghc seems to think it is nice to sit 5min on a single module without any optimizations :-(
04:50:19 <Philippa> seidan: what's the benefit?
04:50:36 <Philippa> musasabi: ow. Is there anything in the module you might expect to take time to compile?
04:51:50 <musasabi> Philippa: it is happy generated so that explains it, but I am trying to hunt down a bug in the grammar definition so it is highly annoying.
04:52:36 <musasabi> Still "19025 e         25   0  119m 117m 7800 R 98.1 23.3   8:04.28 ghc-6.4" seems quite slow on a 2ghz machine.
04:52:53 <seidan> Philippa: well, I had thought IOArrays would make doing IO of the intermediate state easier.
04:54:49 <yain> how do i print numbers in non-decimal base?
04:56:57 <foxy_> @index oct
04:56:58 <lambdabot> bzzt
04:57:09 <dons> @plugs "0x" ++ showHex 255 []
04:57:11 <lambdabot> "0xff"
04:57:20 <yain> thanks
04:58:17 <foxy_> dons: I think dynamic polymorphic types would require dynamic function lookup for classes, not a small task
04:58:31 <foxy_> (as well as unification)
05:52:29 <Itkovian> tralalala
05:55:14 <Itkovian> ok, so here's my question (yet) again. I would like to have some Haskell benchmarks, suitable for compilation with ghc-6.2.x or ghc-6.4. Preferably rather longer running stuff (i.e. > 10 seconds), non-interactive, and running within the limits of 1GiB of RAM
05:55:27 <Itkovian> any pointers are appreciated
05:56:21 <Igloo> Look at the testsuite and nofib suite in fptools CVS
05:59:36 <df__> itkovian :: <pedant>that isn't actually a question</pedant>
05:59:58 <Itkovian> yeah ... well,
06:00:33 <Itkovian> Igloo: ok, thx
06:20:03 <basti_> hmm does anyone have a nice C/Haskell "shootout" (not the great shootout, just a personal one) problem?
06:29:01 <Philippa> audio processing?
06:29:31 <basti_> dsp?
06:29:32 <Philippa> though I don't have a nice interface to something appropriate. If there was an existing haskell lib for it I'd suggest a quickie 303 clone VSTi
06:30:06 <basti_> heheh
06:30:32 <boegel> basti_: a friend of mine handles audio processing in Haskell
06:30:51 <boegel> although he casts a wav file into a dat file with a java program first
06:30:52 <basti_> boegel: like how? url?
06:31:00 <basti_> where what?
06:31:27 <Philippa> it'd be interesting to look at doing audio processing fast while keeping a lot of the neat tricks available
06:31:40 <boegel> basti_: it's in Dutch though
06:31:44 <basti_> aw.
06:31:52 <boegel> basti_: http://studwww.ugent.be/~arbracke/THESIS/index.html
06:32:40 <basti_> what would "nice tricks" be Philippa
06:33:05 <boegel> filters ! :)
06:33:10 <basti_> thats not a trick
06:33:14 <basti_> thats a few multiplications
06:33:35 <Philippa> basti_: all the compositionality you get with Haskell
06:33:48 <Philippa> getting that to play nicely with things running fast would be cool
06:34:11 <Philippa> the VSTi bit would be somewhat interesting because of the control aspect, too
06:34:11 <basti_> hmm
06:34:47 <Philippa> it might be interesting to look at using something yampa-like to do the control bits and generate a bunch of 'run these ops along this bunch of samples' stuff that then goes fast
06:39:41 <basti_> that yampa thing looks good
06:40:16 <basti_> and I can do "these ops" in a few minutes...
06:41:01 <basti_> is it possible to dynamically link ffi code to haskell?
06:41:46 <dons> yes.
06:42:08 <basti_> hmmm.
06:42:19 <basti_> Yi goes first, though =)
06:47:53 <boegel> yoda-: I've seen your second movie, so should learn to talk, really
06:48:08 <yoda-> clearly to talk, I shall learn
06:48:15 <yoda-> :P
06:48:29 <basti_> why yoda always talk like fortune cookie?
06:49:18 <bringert> OSV word order yoda likes
06:49:47 <basti_> lukasievich yoda?
06:50:11 <boegel> basti_: you mean lukasiewitz :)
06:50:17 <basti_> yes.
06:50:25 <boegel> I bet nobody knows how to write that name (neither do i)
06:50:34 <basti_> hmm
06:50:35 <basti_> ;)
06:50:46 <basti_> might be a transcription issue
06:51:02 <basti_> but this is the reason it's called "polish notation"
06:53:44 <boegel> hi Philippa_ , bye Philippa
06:58:26 <Philippa_> how I love my ISP...
06:58:58 <Philippa_> (with a cheesegrater, in case anybody's wondering)
07:02:13 <boegel> some crazy motherfucker is going to try and set a world record 'crowd surfing' :)
07:13:32 * SamB tries to figure out what you would do about map in a decent collection framework... for Map it changes values, but for Set it changes keys...
07:14:30 * SamB supposes it might be a good idea to characterize a map as a collection of (key, value) pairs...
07:14:44 <boegel> SamB: that's quite classical, no ?
07:15:09 <SamB> boegel: I mean just from a practicality standpoint, not for any theoretical reasons ;-)
07:15:24 <yain> eh, i'm entirely confused with typing.
07:15:50 <boegel> SamB: I mean from a pracitcal standpoint
07:15:59 <SamB> oh really?
07:16:07 <boegel> I'm not a theoretician at all (or howdo you spell that)
07:16:25 <boegel> public interface Map
07:16:25 <boegel> An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.
07:16:31 <boegel> http://java.sun.com/j2se/1.4.2/docs/api/java/util/Map.html
07:19:00 * boegel was glad to help once
07:19:09 <boegel> s/once/for once
07:22:12 <SamB> okay, so I'm making a class called Collection... but what should the head look like?
07:23:15 <SamB> I guess I'll go with 'class Collection c v | c -> v' for now...
07:30:28 <SamB> is map a morphism?
07:31:45 <SamB> @fact map
07:31:46 <lambdabot> I know nothing about map.
07:32:09 <SamB> @fact squiggol
07:32:11 <lambdabot> I know nothing about squiggol.
07:32:37 <boegel> @fact shapr
07:32:38 <lambdabot> I know nothing about shapr.
07:32:48 <boegel> obvious, he's never here :)
07:35:13 <SamB> do you like insert :: v -> c -> c (as in List.insert) or insert :: c -> v -> c?
07:36:38 <Cale> insert :: v -> c -> c, I think
07:36:56 <SamB> okay then
07:37:52 <Cale> map is a functor (specifically the part of the functor that acts on morphisms)
07:38:06 <boegel> SamB: you mean for a map ?
07:38:34 <SamB> boegel: any kind of collection
07:39:46 <SamB> oh dear, I can't find a typing for map that works with this class head...
07:40:40 <Itkovian> SamB: perhaps you should check out the book by Chris Okasaki
08:03:43 <yain> hm, otherwise is True, right?
08:05:48 <boegel> yain: otherwise is a condition which is always true, yes
08:05:52 <boegel> @type otherwise
08:05:58 <lambdabot> otherwise :: Bool
08:06:02 <boegel> @eval otherwise
08:06:03 <lambdabot> unbound variable: otherwise
08:07:15 <TheHunter> @plugs otherwise
08:07:22 <lambdabot> True
08:08:40 <basti_> obfuscation possibility!!!
08:08:40 <basti_> =)
08:09:45 <yain> ;-)
08:10:35 <yain> if otherwise, sounds like fun
08:10:51 <basti_> -g-
08:11:10 <basti_> if otherwise then yaddayadda else error
08:11:30 <basti_> or even better: if otherwise then error "otherwise!"
08:11:30 <basti_> ;)
08:49:21 <wilx> Hm, I've just noticed VCS poll on kerneltrap.org.
08:49:41 <wilx> Looks like Darcs is the third most faviourite free VCS.
08:55:34 <boegel> does anybody know if the gimp supports unicode characters ?
08:56:13 <Cale> It appears to
09:03:59 <yain> hm
09:05:00 <yain> (fromInteger (toInteger (f x))) <- is this a plausible idiom?
09:05:33 <Igloo> You probably want fromIntegral
09:05:53 <yain> no, I actually want fromInt, but I cannot find it
09:06:18 <Igloo> You want fromIntegral
09:06:55 <yain> you're right, thanks
09:06:58 <Igloo> np
09:43:23 <yain> it's impossible to nest lists infinitely?
09:43:36 <marcot> Hello.
09:43:48 <Cale> yain: yes
09:44:06 <marcot> i'm having a problem with c2hs. I can compile the program, but I have an error on linking:
09:44:24 <marcot> Main.o(.text+0x1e): In function `__stginit_Main_':
09:44:31 <marcot> : undefined reference to `__stginit_GPCHaskell_'
09:44:40 <marcot> And a lot of error messages as this one.
09:48:29 <am02> marcot: are you using -l<name of object>  ?
09:49:29 <marcot> am02: let me try with that.
09:50:00 <marcot> am02: you mean -lc2hs ?
09:50:56 <am02> no I mean the c object code.
09:51:03 <am02> that you are linking to.
09:51:49 <marcot> am02: I'm compiling with:
09:52:11 <marcot> ghc -I. -O2 -Wall -lc2hs `c2hs-config --cflags` '-#include<new_form.h>' gpc.o new_form.o  GPCHaskell.hs Main.hs
09:52:52 <SyntaxNinja> --make?
09:53:35 <marcot> SyntaxNinja: same error..
09:53:44 <am02> hmm...
09:53:55 <marcot> Just in 3 functions now.
09:54:03 <SyntaxNinja> what functions
09:54:17 <marcot> gpc_get_x, from new_form.h
09:55:32 <marcot> And the other functions from new_form.h are giving no trouble.
09:57:58 <SyntaxNinja> is it kosher to list the linking objects with the compiling source files on the same command-line?
09:58:47 <marcot> SyntaxNinja: sorry, what's kosher?
10:00:14 <basti_> "edible for jews under consideration of diet traditions"
10:00:38 <wilx> :)
10:03:26 <SyntaxNinja> I don't kwo what the problem is, but since no one else seems to have any ideas, I would compile the .hs files individually, and then link everything together in separate steps
10:03:46 <SyntaxNinja> btw, where do gpc.o and new_form.o come from?
10:05:48 <reffie> http://www.theforce.net/holonet/story/Star_Wars_Fans_Hopsitalized_After_Lightsaber_Accident_92855.asp
10:08:00 <marcot> SyntaxNinja: gcc -c gpc.c
10:08:08 <marcot> SyntaxNinja: gcc -c new_form.c
10:09:00 <marcot> SyntaxNinja: how do I do this in separate steps?
10:13:35 <marcot> SyntaxNinja: I don't know how to link...
10:13:57 <mflux> :i fifo
10:14:11 <wilx> Oh, hm, doesn't ghc support the same modus operandi?
10:14:12 <mflux> is there a fifo data structure with haskell (or ghc), I guess not?
10:25:36 <shapr> Greetings! I am here in search of TMR articles!
10:25:38 <basti_> shapr: !!!!!!!
10:25:44 <shapr> hey basti_, wassup?
10:25:54 <basti_> shapr: i have to greet you from that israeli soldier
10:25:56 <basti_> whats his name
10:25:57 <basti_> p something
10:25:58 <basti_> pipe
10:25:59 <basti_> ?
10:26:06 <shapr> pipe, formerly wolfman8k
10:26:10 <basti_> yep
10:26:24 <shapr> Yeah, I've been busy. I'm making real progress with FLM! w00!
10:26:27 <basti_> people are worried. how is FLM progressing?
10:26:28 <basti_> ah
10:26:30 <basti_> -g-
10:26:57 <shapr> The purely user side is almost finished, only one small feature missing. I haven't started on the darcs integration, but I think I can lift it directly out of something CosmicRay wrote.
10:27:28 <shapr> Anyway, I'm recruiting for TMR3 articles. I have two definites, and a large number of possible.
10:27:51 <basti_> when is the deadline/release date?
10:27:57 <shapr> first of the month, as usual.
10:28:11 <basti_> first of june or july?
10:28:18 <shapr> June, I hope.
10:28:23 <shapr> I'd rather do this monthly.
10:28:26 <basti_> uhh.
10:28:28 <basti_> okay.
10:28:30 <basti_> july then, for me.
10:28:31 <basti_> ;)
10:28:48 <basti_> I'll think something up about FM and harmonics maybe
10:29:01 <shapr> You have an article in issue two, so I won't even ask you about issue three unless I'm desperate.
10:29:02 <basti_> sadly the stuff i was doing in csound recently isnt at all haskore compatible =)
10:29:07 <shapr> Ah, too bad.
10:29:19 <shapr> autrijus: Think you'll have time for something about Pugs in TMR3?
10:29:37 <shapr> dcoutts_: Did I already ask you about something for tmr3? I think you said not likely, is that right?
10:30:18 <shapr> Lunar^: veux tu ecrire pour TMR?
10:30:48 <shapr> Lor: hei, want to write something for TMR3?
10:31:05 <shapr> dons: any spare time?
10:31:13 * shapr doubts dons has much spare time these days.
10:31:36 <basti_> shapr: btw, yi-emacs still did not anneal yet, but it's getting close ;)
10:31:41 <shapr> yay!
10:31:47 <shapr> I'm looking forward to it.
10:31:52 <basti_> the requested features are certainly possible now
10:32:18 <basti_> I just need to straighten out the evolutionary wrinkles
10:32:29 <basti_> still not more than 200 lines btw.
10:32:52 <basti_> and, "boilerplate reflection" ;)
10:33:28 <shapr> nice
10:33:47 <SyntaxNinja> shapr!
10:33:50 <shapr> SyntaxNinja!
10:34:20 * shapr boings
10:34:52 <SamB> Hmm, earlier:
10:34:52 <SamB> <SamB> oh dear, I can't find a typing for map that works with this class head...
10:34:52 <SamB> <Itkovian> SamB: perhaps you should check out the book by Chris Okasaki
10:34:53 <shapr> tromp: want to write something for TMR3?
10:35:49 <SamB> I wonder if that was a responce to what I had just said, or to my mention of representing a mapping as a collection of pairs?
10:36:57 <dcoutts_> shapr, I had said I'd probably be albe to do one, but I'm not so sure now, I'm under pressure to get a paper into another journal (about my real work rather than gtk2hs) so the tmr article will probably have to wait :-(
10:37:08 <shapr> OK, no worries.
10:37:14 <dcoutts_> prod me for next month
10:37:19 <shapr> Sure, will do.
10:37:23 <dcoutts_> :-)
10:37:27 <shapr> I've got two really nifty articles so far, I hope I can get five.
10:37:34 <dcoutts_> cool
10:38:25 <shapr> nibro: want to write about HSP for TMR3?
10:38:33 <shapr> gzl: want to write about WASH?
10:38:35 <SamB> anybody have any clue how to define a class Collection so that instances can be given for things like Map as well as ordinary collections?
10:38:56 <dcoutts_> actually by next month's tmr, gtk2hs 0.9.8 will be out which my gtk2hs demo program needs, so it's probabbly just as well really
10:39:12 <SamB> where a Map would be represented as a collection of (key, value) pairs?
10:39:13 <shapr> SamB: Itkovian is saying that you should look at the generic collection classes in the Monad Foundational Libraries or whatever Okasaki's collection libs are called.
10:39:42 <shapr> SamB: Pseudonym is maintaining them, I think the latest version is in haskell-libs cvs.
10:39:47 <SamB> oh, so he does type classes too, huh?
10:40:15 <SamB> cvs, that archaic VCS?
10:40:38 <shapr> yup
10:40:48 <SamB> @google haskell-libs cvs
10:41:08 <shapr> I dunno if Pseudonym has changed anything since I made a darcs version of haskell-libs years-ago .
10:41:38 <shapr> @seen skew
10:41:45 <shapr> lambdabot: @hello
10:41:48 <shapr> hmm
10:42:05 <SamB> lambdabot would appear to be dead
10:42:15 <SamB> or at least hung
10:42:18 <shapr> Does seem so.
10:43:00 <SamB> hey, does this mean that you got out that version of fermat's last margin?
10:43:13 <lambdabot> http://cvs.sf.net/viewcvs.py/haskell-libs/libs/takusen/
10:43:13 <lambdabot> I saw skew leaving #haskell 8 days, 10 hours, 11 minutes and 54
10:43:13 <lambdabot> seconds ago, and I have missed 21 seconds since then.
10:43:13 <lambdabot>  @help <command> - ask for help for <command>
10:43:15 <shapr> No, but I'm really claose!
10:43:34 <SamB> shapr: what, did you need help or something?
10:43:44 <shapr> Only two pieces missing, I need to list subpages, and I need to add darcs support.
10:43:47 <shapr> You want to hack on FLM?
10:44:05 <SamB> I dunno, I haven't seen it ;-)
10:44:25 <marco1> Hey... I'm having a lot of problems here.
10:44:31 <shapr> marco1: oh me too!
10:44:43 <yain> who isn't
10:44:49 * shapr looks at lambdabot 
10:44:49 <marcot> shapr: than we have something in common.
10:44:53 <shapr> Yay!
10:45:17 <SamB> @google google
10:45:18 <marcot> shapr: you weren't here when I've described my problems..
10:45:18 <lambdabot> http://www.google.com/
10:45:31 <shapr> marcot: well, I haven't even described my problems yet!
10:45:48 <shapr> I've found a novel problem, but it won't fit into this irc buffer.
10:45:52 * SamB wonders what lambdabot was hung on
10:46:15 <shapr> Probably got caught on a nail somewhere.
10:46:48 <SamB> I think it probably got caught on a blocking call
10:47:17 <SamB> maybe google was burping...
10:47:30 <marcot> I'm trying to compile a program with c2hs. It compiles, but when it's linking it sais:
10:47:54 <SamB> marcot: maybe you should use ghc --make?
10:48:25 <marcot> SamB: ok.
10:49:30 <marcot> SamB: I have the same problem.
10:49:41 <marcot> ghc -I. --make -O2 -Wall -lc2hs `c2hs-config --cflags` gpc.o new_form.o Main.hs
10:49:41 <SamB> what does it say then?
10:49:56 <marcot> ./GPCHaskell.o(.text+0x6a5): In function `GPCHaskell_zdwccall1_entry':
10:50:03 <marcot> : undefined reference to `gpc_get_contour'
10:50:10 <marcot> And the same error for more 2 functions.
10:50:28 <dcoutts_> marcot, you're not linking to your C .o files
10:50:56 <dcoutts_> you've presumably got some C file which defines gpc_get_contour and you need to link with the corresponding .o file
10:51:11 <dcoutts_> ghc / c2hs don't do this for you automatically
10:51:15 <shapr> Hiya perdix
10:51:23 <marcot> dcoutts: ok, new_form.h have the gpc_get_contour.
10:51:32 <perdix> hi shapr
10:51:33 <marcot> dcoutts_: How do I do that?
10:51:38 <shapr> perdix: how's code?
10:51:43 <SamB> marcot: what is gpc?
10:51:45 <dcoutts_> marcot, but which .c file has gpc_get_contour ?
10:51:55 <SamB> does it have documentation about how to use it with C?
10:52:06 <perdix> shapr: in c# and for a lame project, unfortunately
10:52:07 <dcoutts_> or is it in some system lib somewhere?
10:52:19 <SamB> try using that to find what library you must link with
10:52:28 <shapr> perdix: oh, well.. Any kind of programming is better than digging ditches I always say.
10:52:40 <shapr> SamB: want to write for TMR3?
10:52:41 <marcot> dcoutts_: Hum... let me check the things here. I think something is missing.
10:53:08 <perdix> shapr: you're probably right there.
10:53:12 <SamB> shapr: no, I think I want to figure out how to comment my code before I try anything of that scope...
10:53:16 <perdix> shapr: so how is fermat's last margin coming along?
10:53:28 <marcot> dcoutts_: Thanks. I've changed the name of the functions in the .h file, but I forget to change the names in the .c file.
10:53:57 <shapr> perdix: It's close! Only a few hours of coding left.
10:54:22 <dcoutts_> marcot, so it links ok now?
10:54:44 <marcot> dcoutts_: yes.
10:54:46 <tuomov> Hmm.. I'd rather dig ditches than do a lot of the shit that employers want you to do...
10:54:48 <dcoutts_> good good
10:55:06 <am02> marcot: glad its sorted
10:55:42 <marcot> am02: =D
10:55:46 <marcot> Thanks everyone.
10:56:03 <shapr> tuomov: want to write for TMR3?
10:56:20 <tuomov> I don't think I'll have to time
10:56:21 <shapr> tuomov: You could write about employers =)
10:56:27 * shapr grins
10:56:49 <tuomov> looking for a flat and moving sucks.
10:56:52 <SamB> @google haskell-libs
10:56:54 <lambdabot> http://sourceforge.net/projects/haskell-libs/
10:58:03 <tuomov> I also may not have time until tmr4/july either, and may soon be without a proper net access too
10:58:09 <mflux> hmm.. funny that if I have let foo a = (), it will still evaluate the function even though it can only have one return value
10:58:13 <mflux> can that behavior be depended on?
10:58:56 <shapr> Sure, that's how phantom types work.
10:59:09 <mflux> phantom types?
10:59:38 <SamB> mflux: it could also return bottom!
10:59:40 <shapr> @google phantom types haskell
10:59:41 <lambdabot> http://haskell.org/hawiki/PhantomTypes
11:00:16 <SamB> shapr: this haskell-libs darcs repo, is it synchronized with CVS?
11:00:22 <shapr> Nope
11:00:25 <shapr> hiya gnu_andrewh
11:00:59 <shapr> gnu_andrewh: So, are you competing with the other John Hughes in the Haskell community?
11:03:05 <marcot> Now I'm having a strange problem. I have written a simples Main.hs: main = putStr "Come√ßando"
11:03:07 * SamB thinks zsh ought to check the cwd every time it prints its prompt...
11:03:13 <marcot> And when I compile with:
11:03:22 <marcot> ghc -I. --make -O2 -Wall Main.hs
11:03:49 <marcot> everything goes fine. But if I compile with: ghc -I. --make -O2 -Wall gpc.o new_form.o Main.hs, when I run ./a.out nothing happens.
11:04:16 <shapr> Hm, who can I recruit for a TMR3 article? Any volunteers?
11:04:16 <shapr> musasabi: Do you have time for a TMR article?
11:04:16 <shapr> FrederikEaton: Want to write a TMR article?
11:04:33 <musasabi> evening
11:05:08 <musasabi> shapr: I may have something that would be very suitable for an article - but I am not quite sure how much I need to hack on it.
11:05:29 <dcoutts_> marcot, does your gpc.o define a main function perhaps that is overriding the ghc default one ?
11:05:44 <shapr> musasabi: what's the subject?
11:05:45 <marcot> dcoutts_: Yes, it could be it, let me check.
11:05:46 <dcoutts_> nm gpc.o | grep main
11:06:03 <musasabi> "Concurrent and distributed Haskell with Join-calculus"
11:06:30 <shapr> Oh boy, that does sound like fun.
11:06:31 <marcot> dcoutts_: Yes, it worked, thanks again.
11:06:42 <dcoutts_> :-) isn't remote debugging fun
11:06:50 <arjanb> does the (>>) operator have a name?
11:07:23 <shapr> hiya Biker
11:07:30 <musasabi> concurrent things compile at the moment, and I know how distribution can be added - just need to implement the distribution layer from my notes.
11:08:01 <shapr> Biker: Are you a motor-biker or a fixie biker, or what?
11:08:23 <Biker> shapr: I ride bicycles :0
11:08:46 * SamB is rather surprised to see a bugreport submitted by simonpj
11:10:30 <shapr> musasabi: I would very much like to read that article, I assure you. But you already know how much I want distributed haskell :-)
11:10:45 <shapr> This would give me an excellent excuse to implement Kademlia, which I have wished to write in Haskell.
11:10:54 * SamB wishes that sf.net would list cvs modules on the project cvs pages
11:11:07 <shapr> cvs generally sux
11:12:17 <shapr> erg: Are you dyne/cm?
11:12:19 <musasabi> Kademlia?
11:12:21 <SamB> hmm, cvs ... co . gets me a CVSROOT directory...
11:12:34 <shapr> http://en.wikipedia.org/wiki/Kademlia
11:13:07 <shapr> It's the first and only distributed hash table, afaik. All others are just versions of Kademlia with slighly different tradeoffs.
11:14:17 <shapr> yosemite: were you SamC?
11:14:34 <shapr> Man, I'm running out of people to ask for TMR articles.
11:16:18 <shapr> jlouis: want to write for TMR3?
11:17:12 <SamB> naesten@hydrogen:~/hacking/haskell/haskell-libs% find | xargs grep Okasaki
11:17:12 <SamB> ./libs/chess/Heap.hs:-- Heap interface taken from Okasaki
11:17:12 <SamB> ./libs/chess/LeftistHeap.hs:-- Leftist heap taken from Okasaki.
11:18:52 <shapr> SamB: whoops, sorry...
11:18:54 <shapr> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/
11:19:25 <shapr> Haskell Foundation Libraries contain Edison, which is the name of Okasaki's libs ported to Haskell.
11:19:40 * SamB skips viewcvs and goes directly to checkout
11:19:43 <shapr> Man, my mental index is getting rusty.
11:20:02 <SamB> this looks suspiciously like edison
11:20:14 <shapr> Do you already have a copy of Edison?
11:20:32 <SamB> I don't know.
11:20:36 <shapr> chucky: want to write for TMR3?
11:20:45 <SamB> I think I have the sources from ghc6-libsrc...
11:21:00 <SamB> (which are just for reading, not compiling)
11:21:19 <shapr> Oh, we should bug Pseudonym to cabalize HFS.
11:21:21 <shapr> um, HFL
11:21:39 <SamB> I also typed hfs by accident ;-)
11:21:57 <Igloo> edison should still be shipped with ghc6, but probably deprecated
11:22:04 <shapr> I haven't used Macs in years, dunno why I still typed HFS.
11:22:10 <SamB> is this just edison?
11:22:27 <shapr> Yes, Edison is the name of Okasaki's libs ported to Haskell.
11:22:28 <Igloo> Hmm, or perhaps it is no longer even compiled any more
11:22:37 <shapr> Edison has a unified collection interface, though I don't remember any details.
11:22:55 <shapr> Igloo: want to write for tmr3?
11:23:24 <shapr> I may have to get off my comfortable couch and write an article myself! Yow!
11:23:39 <SamB> wow, this looks a lot like what I was doing
11:23:41 <shapr> I'll still need two more if I write an article.
11:23:51 <SamB> only with way more classes
11:24:00 <SamB> and way further along
11:24:06 <SamB> I forgot edison had classes
11:31:46 * SamB tries to figure out how to send a patch that adds a directory
11:33:32 <chucky> shapr: :) Maybe if I can think of a topic
11:33:38 <mflux> I wondered this earlier too, but nobody reacted ;). Is there a way to see where the (uncaught) exceptions are coming from? Something similar to ocaml's OCAMLRUNPARAM=b that is..
11:33:46 <chucky> shapr: when would you want it ready?
11:36:28 <shapr> chucky: by the first of the month :-)
11:36:46 <shapr> You could write about HaskellDB.
11:37:04 * shapr unicycles away...
11:37:58 <SamB> @docs Edison
11:37:59 <lambdabot> Edison not available
11:38:26 <yain> is there an easy way to apply f1 to both arguments of f2 before passing them?
11:38:37 <yain> to avoid f2 (f1 x) (f1 y)
11:47:26 <chucky> shapr: Unfortunately not by that deadline. :)
11:47:52 <chucky> farre might be interested in describing his latest project though. But I'm not sure how ready it is. I'll ask him
11:50:53 <TheHunter> yain, you might just wanna define a function "(f `on` g) x y = f (g x) (g y). It has been proposed, but it never made it to the libs (e.g. because people are objecting against such short names).
11:52:26 <yain> ic
11:52:46 <yain> but then, i'll have to define on3, on4 or this can be made more generic?
11:54:02 <TheHunter> it could be with some template haskell or type class trickery, but i don't think it's worth the effort. it's extremely unlikely you'll ever need on4
11:54:09 <TheHunter> anyway, i'm off.
11:54:25 <yain> ok, thanks
12:05:35 <musasabi> How would I define a function which takes a function whose all args are in Read and creates [String] -> rt. e.g. with arity 2, tr2 c = (\[x,y] -> c (read x) (read y)). How would I use a class to generalize this for any arity?
12:07:19 <basti_> how can the first case in a case analysis "shadow existing bindings?
12:09:47 <goron> basti_: I think you use some name, and that name is also a function somewhere.
12:11:28 <basti_> ohh
12:11:31 <basti_> that might be.
12:12:58 <perdix> shapr: Say, have I ever thanked you?  For restoring my faith in Haskell and stuff?
12:13:01 * perdix hugs shapr
12:13:15 <basti_> perdix: what was wrong?
12:13:22 <perdix> basti_: nothing, why?
12:13:28 <basti_> with your faith in haskell
12:13:46 <goron> It should be otherwise it can't be restored ;)
12:14:44 <perdix> basti_: 'twas just a feeling I got. A friend and me coded an irc-like-server for uni, and ended up with 95% of our functions in the IO monad.  It just wasn't fun anymore.
12:14:52 <basti_> oh...
12:15:14 <perdix> basti_: it felt like declaring everything static in Java, forcing all code that uses it to be static as well
12:16:29 <perdix> when we were first taught to program (imperatively, in java) the idiom stuck for too long a time that "static funtion called from non-static context" was to be fixed by declaring code static
12:16:57 <basti_> uuuuhhhhmmmm.
12:17:08 <basti_> you mean "non-static function called from static context"? ;)
12:17:21 <basti_> i wouldnt see a problem the other way round
12:17:29 <perdix> basti_: oh, sure
12:17:38 <perdix> basti_: sorry, I mixed 'em up
12:17:41 <basti_> ;)
12:17:54 <basti_> but really, Monadic IO is kinda ugly
12:18:45 <goron> He, here's an idea: Use ; instead of >> and >>= (oh, wait that's called C) :D
12:20:44 <mflux> with monadic io and multiparameter fununctions you always need to assign names to intermediate results
12:21:26 <mflux> as to be really explicit about the evaluation order, even though in some cases it doesn't really matter
12:22:34 <basti_> yes thats ugly.
12:23:09 <SamB> it seems like it makes for relatively pretty parsers, though ;-)
12:23:34 <SamB> of course, with parsers the order does matter
12:24:32 <goron> mflux: I don't think your claim is true. Could you give an example that can not be transformed such that it uses less names?
12:24:47 <goron> "to assign names to intermediate results"
12:24:50 <goron> That claim.
12:25:10 <SamB> well, either that or get an unreadable mess
12:25:21 <mflux> goron, well, it could be due to my limited experience with haskell, but do { a' <- readIORef a; b' <- readIORef b; c' <- readIORef c; func a' b' c' } ?
12:25:38 <SamB> @type liftM3
12:25:43 <lambdabot> bzzt
12:25:43 <mflux> well, yes
12:25:51 <SamB> @type Monad.liftM3
12:25:53 <lambdabot> Monad.liftM3 :: forall r (m :: * -> *) a3 a2 a1.
12:25:53 <lambdabot>       (Monad m) =>
12:25:53 <lambdabot>       (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:25:54 <goron> SamB: That sounds more plausible.
12:25:56 <mflux> how about a mix of monadic an non-monadic arguments?
12:26:12 <goron> mflux: You can mix all you like.
12:26:18 <SamB> mflux: you can add returns to the non-monadic ones
12:26:22 <SamB> @type Monad.ap
12:26:24 <lambdabot> Monad.ap :: forall b (m :: * -> *) a.
12:26:24 <lambdabot>     (Monad m) =>
12:26:24 <lambdabot>     m (a -> b) -> m a -> m b
12:26:59 <SamB> @type Monad.liftM2
12:27:01 <lambdabot> Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
12:27:01 <lambdabot>       (Monad m) =>
12:27:01 <lambdabot>       (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:27:05 <SamB> @type Monad.liftM
12:27:07 <lambdabot> Monad.liftM :: forall r (m :: * -> *) a1.
12:27:07 <lambdabot>      (Monad m) =>
12:27:07 <lambdabot>      (a1 -> r) -> m a1 -> m r
12:27:14 <mflux> well, I suppose that can be useful. but still, using monads brings something explicit to the code that withohout monads doesn't need to be there; the number of arguments
12:27:44 <SamB> monads are all about being explicit really
12:28:07 <SamB> if you can figure out how to be explicit implicitly, though, its even nicer ;-)
12:28:11 <goron> mflux: The idea is that you can reason more easily about programs then.
12:28:41 <goron> Compiler writers are just too lazy ;)
12:28:47 <perdix> basti_: it's probably at least as ugly to know about the implicit monads around all code in impure languages
12:29:05 <SamB> goron: what do you need compiler writers for when you have type-based magic?
12:29:10 <wli> If only they were that well-founded.
12:29:25 <mflux> I maybe should familiarize myself with Clean, I understand it has another approach for doing IO in a pure language
12:29:58 <basti_> perdix: thats true yes.
12:30:17 <basti_> but maybe one could prettify all this stuff somewhat.
12:30:20 <goron> SamB: Ok, tell me how I can make a function that takes n arguments, and put those arguments in a list. For simplicity they all have the same type.
12:30:47 <SamB> goron: well it would be hard to get them in a list if they weren't the same type!
12:30:48 <basti_> mflux: clean does about the same with "unique" types. That's types that may only have one incarnation... you see the rest i suppose ;)
12:30:56 <SamB> I believe someone has done it
12:31:14 <mauke> http://okmij.org/ftp/Haskell/vararg-fn.lhs
12:31:17 <mauke> huhu
12:31:18 <goron> SamB: I remember someone doing something like that, but I wouldn't call it Haskell 98 anymore.
12:31:22 <SamB> ah yes
12:31:34 <basti_> "existential types"
12:32:03 <SamB> well, okay, so it isn't haskell 98.
12:32:07 <wli> I think the printf bit was much fancier codewise but didn't involve too many language features.
12:32:17 * SamB doesn't actually use haskell 98
12:32:22 <wli> (I think it could be done in Standard ML with some additional pain.)
12:32:36 <musasabi> shapr: ping.
12:33:20 <SamB> @get-shapr
12:33:21 <lambdabot> Unknown command, try @listcommands.
12:33:33 <wagle> @run shapr
12:33:36 <lambdabot> No match for "shapr".
12:33:42 <wagle> @bounce shapr
12:33:43 <lambdabot> Unknown command, try @listcommands.
12:33:46 <wagle> aww
12:35:03 <musasabi> What would be a good to write a tutorial in style of literal haskell ones, but that needs to be done in ghci (top level binding of IO values (file <- openFile ...) and so on) ?
12:35:09 <musasabi> *good way
12:35:31 <SamB> heh, use nullsofts installer for GHC on windows...
12:35:42 <goron> SamB: Could you explain in a few lines what multi-parameter classes are about?
12:35:55 <SamB> goron: they bind multiple type variables
12:36:30 <goron> Thus this part: instance BuildList a [a]
12:36:38 <goron> And this second a could also be a b, etc.
12:37:15 <goron> And the functional dependency part? class BuildList a r  | r-> a where
12:37:21 <SamB> I just sent a mail to haskell-libraries that had some multi-paramater type classes in it...
12:37:45 <SamB> right at the top of http://news.gmane.org/gmane.comp.lang.haskell.libraries
12:38:13 <SamB> hmm, gmane didn't do a very good job with the attachments...
12:39:04 <goron> SamB: It seems binary files, indeed.
12:39:36 <SamB> I guess I should just paste files into the body in the future...
12:40:51 <SamB> pipermail doesn't do a great job either
12:41:55 <shapr> @yow !
12:41:57 <lambdabot> Am I SHOPLIFTING?
12:43:16 <shapr> perdix: Wow! How did I restore your faith in Haskell?
12:43:30 <shapr> musasabi: pong
12:44:36 <perdix> shapr: I'm not sure, something you mentioned about arrows.  Got me to read Hughes' paper, and then a few by Wadler.  They contained enough advocacy to turn me ;-)
12:44:42 <shapr> Spiffy!
12:46:32 <SamB> neat, I've got enough defualts on my Collection class that to make [] an instance all I need to do is this:
12:46:47 <SamB> instance Collection [a] a where
12:46:48 <SamB>     toList   = id
12:46:48 <SamB>     fromList = id
12:46:48 <SamB>     insert   = (:)
12:48:23 <musasabi> shapr: about the monadic tutorial - currently I am using hack = unsafePerformIO, foo = hack $ exp, where-as the proper form would be foo <- exp, but then it would not be Haskell...
12:49:32 <shapr> The monadic tutorial?
12:50:13 <boegel> hey shapr
12:50:22 <boegel> nice to see you're coming back more frequently
12:50:24 <shrimpx> a monadic tutorial?!
12:50:30 <shapr> hoi boegel
12:50:40 <shapr> I'm looking for TMR article writers, but I'll disappear in a few minutes.
12:50:56 <boegel> I have no time, sorry
12:51:08 <boegel> but my ray tracer code will be online next week or so
12:51:11 <musasabi> I am writing a tutorial style thing and normally I would use literate haskell, but because everything is monadic top-level binding are hard.
12:51:17 <boegel> then you guys can point me on the mistakes I've made :)
12:51:43 <musasabi> shapr: I'll try to send you mail in the weekend about details of the article.
12:52:05 <SamB> @google fermats last margin darcs
12:52:06 <lambdabot> http://lambda-the-ultimate.org/node/view/498
12:54:29 <SamB> @google fermat's last margin darcs
12:54:30 <lambdabot> http://lambda-the-ultimate.org/node/view/498
12:54:49 <boegel> SamB: ? :)
12:55:19 <basti_> w0ah
12:55:24 <basti_> user error (Curses[-1]:waddnstr)
12:55:24 <SamB> shapr had said he wasn't going to use IRC until he released a certain version of that
12:55:27 <basti_> =)
12:56:34 <SamB> see http://www.scannedinavian.com/
12:56:52 <shapr> musasabi: spiffy, thanks.
12:56:56 * shapr bails out
12:57:51 <SamB> his excuse for getting on anyway was apparantly recruiting writers for TMR
12:59:50 <goron> @wiki functional dependencency
12:59:51 <lambdabot> http://www.haskell.org/hawiki/functional dependencency
13:00:17 <SamB> hmm
13:00:24 <SamB> @wiki FunDeps
13:00:26 <lambdabot> http://www.haskell.org/hawiki/FunDeps
13:00:58 <goron> That function s*cks. Ty, SamB
13:01:19 <SamB> okay, try this one:
13:01:24 <SamB> id
13:01:38 <alexj> does runghc ignore -i?
13:01:41 <boegel> SamB: not that he got any :p
13:01:53 <goron> @id id
13:01:54 <lambdabot> Maybe you meant: kind pl wn
13:01:57 <SamB> boegel: well he asked
13:02:00 <basti_> :)
13:02:04 <goron> @id 5
13:02:05 <lambdabot> Maybe you meant: kind pl wn
13:02:11 <SamB> @pl \x -> x
13:02:12 <lambdabot> id
13:02:28 <goron> That's PreLude, right?
13:02:43 <SamB> @plugs id [1, 2, 3, 4, 5]
13:02:49 <SamB> yes
13:02:52 <lambdabot> [1,2,3,4,5]
13:02:55 <SamB> @plugs id [1, 2, 3, 4, 5]
13:02:57 <lambdabot> [1,2,3,4,5]
13:03:06 <basti_> yi-emacs-newest-try is now on par with yi-emacs-older-try and able to fulfill all requested demands.
13:03:28 * SamB just got lagged and thought it was lambdabot that was lagged...
13:04:12 <basti_> what sense does it make to apply id to something like that?
13:05:55 <SamB> <goron> SamB: Ok, tell me how I can make a function that takes n arguments, and put those arguments in a list. For simplicity they all have the same type.
13:06:17 <SamB> of course, id takes them already in the list, but how hard is that?
13:06:31 <basti_> nggghhhhh ;)
13:06:41 <basti_> i guess this was about Monadic contexts
13:07:23 <SamB> in that case, try seqM:
13:07:26 <SamB> @type seqM
13:07:36 <lambdabot> bzzt
13:07:42 <basti_> not too promising.
13:07:43 <basti_> =)
13:07:47 <SamB> @type Monad.seqM
13:07:49 <lambdabot> bzzt
13:08:03 <basti_> @type Control.Monad.seqM
13:08:05 <lambdabot> bzzt
13:08:06 <basti_> hmm
13:08:07 <basti_> ;)
13:08:10 <SamB> okay, maybe that isn't the name
13:08:27 <SamB> @type sequence
13:08:29 <lambdabot> sequence :: forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:08:44 <basti_> hmm
13:08:50 <basti_> yep
13:09:10 <SamB> mapM may also be usefull
13:09:15 <SamB> @type mapM
13:09:17 <lambdabot> mapM :: forall b (m :: * -> *) a.
13:09:17 <lambdabot>    (Monad m) =>
13:09:17 <lambdabot>    (a -> m b) -> [a] -> m [b]
13:09:56 <basti_> ohh.
13:10:09 <basti_> once you zen monads, the ten thousand things are easy.
13:10:27 <SamB> what ten thousand things?
13:11:04 <basti_> thats what ancient chinese sayings say instead of "everything", or "the whole lot of things" ;)
13:11:45 <SamB> oh
13:11:49 <basti_> (ten thousand apparently is a chinese metaphor for "uncountably many")
13:11:50 <SamB> those ten thousand things
13:12:07 <SamB> well I sure can't count that high
13:12:11 <basti_> yes.
13:12:13 <basti_> hmm
13:12:17 <basti_> its no fun.
13:12:21 <basti_> been there done that etc.
13:12:24 <basti_> no j/k
13:14:37 <mflux> so did chinese too use base 10?
13:15:02 <mflux> well, I suppose everyone does ;)
13:15:08 <basti_> no
13:15:27 <basti_> ever wondered why clocks count to 12 and degrees to 360?
13:15:33 <basti_> sumer here we go...
13:15:42 <mflux> they are easier to divide
13:15:46 <SamB> some people use hexadecimal!
13:15:51 <basti_> yes that would be a reason to switch =)
13:16:09 <mflux> but, 10 fingers, it gives a great advantage to using base 10..
13:16:15 <SamB> not really
13:16:26 <basti_> but the tradition goes back to the ancient kingdom of sumer which used 12 as a base (at least in some contexts)
13:16:43 <basti_> but yes, you can enumerate up to 10 things without remembering how to count
13:16:53 <basti_> for 90% of humanity that's a real advantage
13:16:56 <basti_> :P
13:17:29 <basti_> no but really that's a stupid reason. It's not that we had 10x10x10 fingers or something which would make us REALLY prone to the 10 system
13:18:11 <basti_> and if the 10/12 thing teaches us something, then that our base should be a prime. At least there would be no easy divide then =)
13:18:56 <SamB> no, the base should be really-non-prime
13:19:03 <basti_> :P
13:19:03 <mflux> well, given 10 fingers, we could be using base 2 too
13:19:09 <basti_> j/k again! ;)
13:19:13 <mflux> (or any amount of fingers)
13:19:17 <basti_> mflux: yes and count to 1024 :)
13:19:24 <basti_> guess where "digital" comes from!
13:19:33 <resiak> 1023 ;-)
13:19:37 <mflux> basti_, yeah. and how great would that be, learning to do that in the first grade?
13:19:44 <basti_> yes really impressive too
13:20:08 <basti_> for example if you visit asia and embarass people to no matter with your super counting technique!
13:21:20 <mflux> the only problem I see is that if at the middle of calculation you turn your hands, the result could be wrong
13:21:37 <mflux> otoh, I wonder if there could be any useful calculus algorithms that could take advantage of flipping 5 bits ;)
13:21:44 <basti_> ahh no thats not a bug thats a feature
13:21:56 <basti_> two's complement and reverse in one
13:22:00 <mflux> and then there is this that if you want to show someone else the number
13:22:07 <basti_> i think an operation like this is useful in fft indexing
13:22:22 <basti_> well it would take a little practice
13:22:31 <basti_> but imagine base 3 (with half-stretched) fingers.
13:22:34 <basti_> that would be a PITA
13:22:54 <mflux> I didn't mean flipping as in xor, I meant flipping as in bit 0 <-> bit 4, bit 1 <-> bit 3?
13:22:55 <basti_> but i've heard about people learning to *add* with their fingers in binary
13:23:09 <mflux> (xor->binary not)
13:23:22 <basti_> both at the same time if you imagine stretched fingers as being bent when held the other way round
13:23:56 <basti_> about the adding, apparently it's possible to learn coordinating your fingers so that you do carry in your motoric cortex
13:24:05 <basti_> which IS a cool hack if i've ever seen one
13:24:40 <basti_> plus one 10-bit or 2 5-bit registers.
13:24:58 <basti_> which really is enough for many everyday purposes.
13:25:13 <basti_> and a way to impress people, too. not to forget.
13:25:14 <mflux> and for serious stuff, you can take your socks off
13:25:31 <mflux> although controlling toes isn't quite as accurate :-(
13:25:38 <basti_> i've seen handicapped people playing the guitar with their feet
13:26:38 <basti_> basically feet are feet-grown-to-hands-grown-back-to-feet-again
13:26:59 <basti_> look at a chimp, there's not much of a difference between their four feet/hands
13:27:12 <monochrom> @pl \x -> "&#" ++ show (ord x) ++ ";"
13:27:13 <lambdabot> ("&#" ++) . (++ ";") . show . ord
13:27:31 <monochrom> oh right!
13:28:44 <mflux> you do realize that you're not saving a single character in code by using that?-)
13:29:41 <goron> monochrom: You are entering a contest for most unreadable code?
13:30:39 <jix> it's my first day learning haskell .. i'd just like to know if my code is ok http://rafb.net/paste/results/eHmnu322.html
13:30:40 <monochrom> Tell that to unix shell scripters.
13:30:56 <SamB> sometimes @pl gives nice results, though I guess it should have been obvious that this wouldn't really be one...
13:31:11 <monochrom> Tell them their pipelines are unreaable, not saving a single character, theoretical, ...
13:31:37 <SamB> monochrom: well remember that the command line is limited in size!
13:31:42 <goron> monochrom: Good point. Bash is quite big. You can do < something > or >> or > r >2 or ...
13:31:52 <SamB> and also that it does not mesh well with newlines
13:32:16 <goron> monochrom: And it differs between OS's (have fun with macro's )
13:33:39 <monochrom> I find (("&#" ++) . (++ ";") . show . ord) easy to read.  Data flow clear.  Reading it aloud in English: turn into ascii code, make it a string, append ";", prepend "&#".
13:33:41 <boegel> jix: looks fine at a first glance
13:33:42 <mflux> @pl \a b -> show a ++ "." ++ show b
13:33:42 <lambdabot> (. (('.' :) . show)) . (++) . show
13:33:45 <SamB> the thing is that you can't stuff the output of a command into a command-line argument, in general
13:34:03 <mflux> I guess with only one parameter @pl is often somewhat readable
13:34:17 <monochrom> Whereas (\x -> "&#" ++ show (ord x) ++ ";") reads: a function that maps x to, whoa?!  where is my x used?
13:34:31 <SamB> I wonder if those nasty sectioned .s can be removed?
13:35:04 <goron> monochrom: Uh, yes, you are right... I was reading it from left to right... I didn't code much lately... shame on me.
13:35:36 <SamB> two bad the . is essentially symetrical
13:35:55 <monochrom> so is |
13:36:01 <SamB> true
13:36:11 <SamB> but that goes from left to right
13:36:49 <SamB> then again, nested functions applications go from right to left too...
13:37:00 <monochrom> Arabs say that "nub . sort" is more natural than "sort | uniq".
13:37:31 <monochrom> I agree that things like (.).(.) are better left as sex jokes.
13:38:15 <goron> monochrom: yes, single points are nice. More is just plain acting cool, but being stupid.
13:38:33 <SamB> @pl (.).(.)
13:38:34 <lambdabot> (.) . (.)
13:38:40 <SamB> @type (.).(.)
13:38:42 <lambdabot> (.).(.) :: forall a b c a1.
13:38:42 <lambdabot>     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:39:45 <SamB> @pl \f g x y -> f (g x y)
13:39:47 <lambdabot> (.) . (.)
13:40:15 <goron> What is a Quad?
13:42:49 <monochrom> The above exercise has this purpose.  We want to obfuscate email addresses on web pages without frustrating human readers.  Someone found that turning me@myself.com into &#109;&#101;&#64;&#109;&#121;&#115;&#101;&#108;&#102;&#46;&#99;&#111;&#109; works well: web browers turn them back into me@myself.com for humans, but spammers don't harvest it.
13:43:19 <monochrom> Someone even wrote a perl script for the translation.
13:43:38 <SamB> monochrom: that only goes from me@myself to &#109;&#101;&#64;&#109;&#121;&#115;&#101;&#108;&#102;&#46;&#99;&#111;&#109; ?
13:43:41 <monochrom> So I thought, to hell with perl scripts, I can do this in one line Haskell.
13:43:57 <monochrom> Actually his perl script can translate both ways.
13:44:00 <SamB> well lets see the line
13:44:11 <monochrom> I just need one way.
13:44:21 <mauke> perl -pe 's/(.)/"&#" . ord($1) . ";"/ge'
13:44:34 <monochrom> @plugs concatMap (("&#" ++) . (++ ";") . show . ord) "me@myself.com"
13:44:42 <lambdabot> "&#109;&#101;&#64;&#109;&#121;&#115;&#101;&#108;&#102;&#46;&#99;&#
13:44:42 <lambdabot> 111;&#109;"
13:45:17 <monochrom> I suppose the inverse is harder regardless.
13:45:51 <mauke> perl -e 's/&#(\d+);/chr $1/ge'
13:45:54 <mauke> er, -pe
13:46:02 <SamB> what do the g and e at the end do?
13:46:25 <mauke> g means global search (as many as possible)
13:46:27 <goron> SamB: global
13:46:35 <mauke> e means the replacement part is an expression, not a string
13:46:43 <goron> T0o slow :(
13:47:03 <monochrom> I also suppose his perl skillz isn't that great either.  Afterall pointfree functional training tunes your brain into writing better perl lines too.
13:47:55 <SamB> is that where the evil mangler came from?
13:51:24 <goron> Is HOpenGl distributed with GHC these days?
13:55:37 <wilx> Hmm.
13:55:43 <wilx> How does that obfuscation help?
13:56:00 <wilx> If one uses Perl's HTML::Parser with decoding entities on?
13:56:08 <wilx> :)
13:57:00 <monochrom> It just needs to evade spammers.
13:57:06 <yain> i think it's best to intermix literal letters with encoded
13:57:15 <yain> it's also obvious to avoid tho
13:57:37 <wilx> Well, if the spamers use Perl then there is no defense :D
13:57:56 <monochrom> In fact it is best to evade spammers and still be transparent to everyone else, including perl scripters using HTML::Parser.
13:58:27 <yain> lj puts different parts of email into different cells of table
13:58:39 <monochrom> There is an important difference between what spammers *could* do and what spammers *do* do.
13:59:58 <monochrom> But it's fine to imagine the next line of defense for use in the distant future.
14:00:08 <yain> it's all fine until people start to write ad hoc  scripts that's targeted to stealing something from your site ;-)
14:00:50 <monochrom> In the distant future, when spammers finally decode entities, we can add a javascript snippet that computes and outputs our email addresses.
14:00:59 <wilx> :)
14:01:21 <mflux> they could evalute that code too
14:01:29 <yain> that's even easier
14:01:37 <tic> then you do self-modifying code
14:01:38 <mflux> but, then it allows to DoS the robots
14:01:52 <mflux> tic, the robot can do everything a browser does..
14:01:59 <yain> self-modifiying code, doesn't helps. you just grab the script and run it locally
14:02:10 <tic> true.
14:02:16 <mflux> I suppose images are 'the solution'
14:02:28 <mflux> it'll take some time before they start ocr'ing all the images
14:02:35 <monochrom> Well, when that happens, I'll be too old to care.  I'll let my kids worry about it.
14:02:37 <mflux> and even then there's the captcha-approach ;)
14:02:47 <tic> mflux, "captcha"?
14:02:57 <yain> letters recognition
14:03:01 <yain> or something
14:03:29 <mflux> those funky characters that are obscured/twisted so that it becomes more difficult for ocr's to read
14:03:31 <monochrom> It does seem that for years to come, even a simple "me at myself dot com" works.
14:03:43 <mflux> easy to generate, difficult to parse, except for humans (except when it's difficult for humans too ;))
14:04:12 <yain> yeah, like one at yahoo
14:04:47 <yain> i have perfect eyesight, but it took some time to figure out what's written on the image
14:05:05 <tic> heh
14:05:39 <TFK> That probably has to do with pattern recognition and not eye sight per se, I think.
14:05:56 <mflux> I hear spammers have found a way to deter those too: on a (porn) website, give the browser some access for giving the right answer..
14:05:57 <tic> some of those pics have really low contrast, tfk.
14:06:36 <RemiTurk> hia ll
14:15:45 <RemiTurk> it's a lively night tonight :)
15:25:14 <Lemmih> Morning, #haskell.
15:25:58 <SyntaxNinja> hiya Lemmih
15:27:55 <Lemmih> What's up, SyntaxNinja?
15:29:11 <SyntaxNinja> eh. wishing I had a real debugger
15:30:43 <Lunar^> buddha?
15:30:48 <Lunar^> hatL
15:30:50 <Lunar^> ?
15:31:55 <SyntaxNinja> the problem is that we tend to be using extensions that those guys can't handle, and also using standard libraries that they don't handle
15:32:55 <Lunar^> *sigh*
15:33:52 <SyntaxNinja> do you sigh at me, or at them? ;)
15:33:55 <autrijus> as seen in #svk:
15:33:58 <autrijus> 03:00 < clkao> bad news. i like haskell
15:34:02 <SyntaxNinja> haha
15:34:02 <Lunar^> SyntaxNinja: the situation :)
15:34:06 <Lunar^> autrijus: \o/
15:34:07 <Lemmih> heh
15:34:24 <autrijus> <- talked clkao into hacking pugs
15:34:34 <wilx> :)
15:35:47 <SyntaxNinja> hiya foxy_ sorry I haven't gotten back to you.
15:36:09 <foxy_> Yo!   no worries
15:36:13 <SyntaxNinja> foxy_:  are you sure that the .cabal file is platform specific? or is it a package.conf or something?
15:37:07 <foxy_> Yup, the .cabal file has a directive to include shell32 on mingw
15:37:53 <foxy_> arg, not the Cabal.cabal file
15:38:28 <foxy_> the package.conf.in file does
15:38:53 <SyntaxNinja> ahhhhhh
15:39:13 <SyntaxNinja> because I was thinking... "now where did foxy_ get such a .cabal file?" :)
15:39:23 <foxy_> :)
15:40:39 <SyntaxNinja> so cabal itself produces that .in file in a platform-specific way.  so it all makes sense.
15:47:06 <foxy_> : Error; multiple packages match Cabal: Cabal-1.0, Cabal-1.0.1
15:47:14 <foxy_> how do I remove a previous package?
15:48:41 <SyntaxNinja> ghc-pkg --help
15:48:58 <SyntaxNinja> ghc-pkg unregister Cabal-1.0
15:49:07 <foxy_> thanks
15:51:06 <lispy> @pl x == y = (matrix x) == (matrix y)
15:51:07 <lambdabot> (line 1, column 8):
15:51:07 <lambdabot> unexpected "="
15:51:07 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">",
15:51:07 <lambdabot> "`elem`", "`notElem`" or end of input
15:52:16 <foxy_> Loading package Cabal-1.0.1 ... linking ... : unable to load package `Cabal-1.0.1'
15:52:41 <foxy_> "/usr/local\Cabal-1.0.1/HSCabal-1.0.1.o: unknown symbol `_SHGetFolderPath'"
15:53:09 <lispy> @pl matrix x == matrix y
15:53:10 <lambdabot> matrix x == matrix y
15:54:42 <monochrom> @pl \x y -> matrix x == matrix y
15:54:43 <lambdabot> (. matrix) . (==) . matrix
15:54:51 <monochrom> @pl \(x, y) -> matrix x == matrix y
15:54:52 <lambdabot> uncurry ((. matrix) . (==) . matrix)
15:55:22 <SyntaxNinja> foxy_: I didn't mean to imply that I've fixed the problem :)
15:55:58 <foxy_> P)
15:56:05 <foxy_> :P
16:02:46 <am02> Anyone know if there's a map function for mutable arrays that changes the arrays values in place and doesn't return a new array?
16:06:31 <malcolm> Hi SyntaxNinja, did I hear you complaining about Hat?
16:06:34 <lispy> am02: something destructive?
16:07:13 <lispy> am02: if so, i think it would have to be implemeted by the run-time...so no i don't know anything that doesthat
16:48:46 <MachinShin> hey +
17:13:07 <SyntaxNinja> malcolm left before I could answer ;)
17:18:21 <kaol> @moo
17:18:22 <lambdabot>          (__)
17:18:22 <lambdabot>          (oo)
17:18:22 <lambdabot>   /-------\/
17:18:22 <lambdabot>  / |     ||
17:18:22 <lambdabot> *  ||----||
17:18:23 <lambdabot>    ~~    ~~
17:18:24 <lambdabot>      Cow
18:45:23 <am02> does CUInt stand for C Unsigned Int?
18:56:46 <SamB> undoubtedly
18:56:52 <SamB> @index CUInt
18:56:54 <lambdabot> Foreign.C.Types, Foreign.C
18:57:04 <SamB> @docs Foreign.C.Types
18:57:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.Types.html
18:57:55 <SamB> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.Types.html#t%3ACUInt
18:58:04 <SamB> data CUInt
18:58:04 <SamB> Haskell type representing the C unsigned int type.
19:16:56 <am02> cool
19:33:07 <[TWiSTED]> hey all
19:33:28 <Lemmih> Yo
19:35:11 <[TWiSTED]> im trying to write a function in which it will input a String and output that String in the form [(String,Int)] eg func1 "Hi12Hello34Hey56" = [("Hi",12),("Hello",34),("Hey",56)]
19:35:45 <[TWiSTED]> i can get the integers out sorta.. filter (isDigit) s
19:35:58 <[TWiSTED]> where s is the input variable
19:36:42 <Lemmih> @plugs break Data.Char.isDigit "Hi12Hello34"
19:36:48 <lambdabot> ("Hi","12Hello34")
19:37:02 <[TWiSTED]> hm ok
19:37:17 <[TWiSTED]> then can i use recursion to do the 2nd element in the tuple?
19:37:21 <Lemmih> @plugs let (_,r) = break Data.Char.isDigit "Hi12Hello34" in case reads r of [p] -> p
19:37:23 <lambdabot> Ambiguous type variable `a' in these top-level constraints
19:37:47 <Lemmih> @plugs let (_,r) = break Data.Char.isDigit "Hi12Hello34" in case reads r of [p] -> (p::(Int,String))
19:37:49 <lambdabot> (12,"Hello34")
19:41:12 <[TWiSTED]> hm
19:45:14 <[TWiSTED]> no help? ehe
19:45:21 <Lemmih> @plugs let split "" = [];split a = let (n,r) = break isDigit a in case reads r of [(num,rest)] -> (n,num::Int):split rest in split "He12Hello32"
19:45:22 <lambdabot> [("He",12),("Hello",32)]
19:45:30 <[TWiSTED]> o wow
19:45:43 <Lemmih> @plugs let split "" = [];split a = let (n,r) = break isDigit a in case reads r of [(num,rest)] -> (n,num::Int):split rest in split "He12Hello34Hey56"
19:45:44 <lambdabot> [("He",12),("Hello",34),("Hey",56)]
19:45:53 <[TWiSTED]> awesome
19:46:10 <Lemmih> (Don't look at that if you wanna figure it out on your own :)
19:46:19 <[TWiSTED]> hehe
19:46:28 <[TWiSTED]> yeh
19:46:33 <[TWiSTED]> but like ive gotta use recursion
19:47:17 <[TWiSTED]> and ive already got a function that does that but only to "one" thing if u know what i mean
19:47:47 <[TWiSTED]> ie f "Hello3" = [("Hello",3)]
19:47:57 <[TWiSTED]> but if i do f "hello3hi5"
19:48:00 <[TWiSTED]> it has an error
19:48:16 <[TWiSTED]> so perhaps i can use that function and recursion to do the same as what you did
19:48:53 <Lemmih> What about returning the tuple and the rest of the input? eg. "He32Hello12" => (("He",32),"Hello12")?
19:51:29 <[TWiSTED]> yeyh
19:51:30 <[TWiSTED]> yeh
19:51:44 <[TWiSTED]> i dont really know
20:11:14 <jemfinch> I've got a bit of a data structure question I'd like to ask here -- haskellers are generally pretty good at thinking up data structures :)
20:12:28 <jemfinch> Conceptually, it's an array where each of the elements can be of type X, and interleaved (i.e., in the "spaces between the elements") can be instances of another type Y.
20:18:55 <dons> is there an association between the X elems and the Ys ?
20:19:43 <dons> i.e. is [(X,Y)] isomorphic to the type you're thinking of?
20:20:49 <Gahhh> eww you said the i-word
20:20:51 <jemfinch> no, not really -- there is an association between the two Xes that neighbor a given Y, though.
20:21:10 <dons> oh, so if there are n Xs, there is n-1 Ys?
20:21:20 <dons> XYXYX, for exxample?
20:21:23 <jemfinch> n+1, actually.
20:21:39 <jemfinch> you could have YXYXYXY
20:21:45 <dons> ok.
20:22:05 <Gahhh> so it's YXY, and for the X in between you care about the value of the two Y's that surround it
20:22:51 <jemfinch> it's also worth noting that the Ys may not be there; it could be XXX or XYXXXY or YXXXXXY.
20:22:58 <dons> hmm..
20:23:18 <Gahhh> that starts to look like a grammar
20:23:32 <dons> oh, that's an interesting idea
20:23:50 <dons> yes, so what are the formation rules?
20:25:30 <jemfinch> well, in a regexp, Y?(XY?)*Y?.  hmm.  It may be the case that a more appropriate formation would be Y?(XY?) -- YY wouldn't be valid, I don't think.
20:26:10 <dons> so you can always insert an X? but Ys can only appear at the start or end, or with an X on either side?
20:28:30 <jemfinch> a Y must always have an X next to it, but an X does not require a Y.
20:28:45 <jemfinch> YX and XY are valid, as well as X*, etc.
20:29:28 <dons> l   = Y l' l''
20:29:28 <dons>     |   l' l''
20:29:28 <dons> l'  = X Y X l'
20:29:28 <dons>     |     X l'
20:29:28 <dons> l'' = Y
20:29:31 <dons>     | epsilon
20:29:39 <dons> maybe?
20:31:18 <jemfinch> hmm.
20:31:41 <jemfinch> actually...
20:32:20 <jemfinch> (I do apologize for the many refinements/corrections, but I'm involved in a more domain-specific discussion about this data structure on another channel and it's turning out to be quite fruitful as well)
21:03:33 <Gahhh> FUCK GAMESURGE
21:10:26 * Lemmih wonders what ghc-asm is for and why it's so unbelievably slow.
21:12:19 <SamB> it must be the EVIL MANGLER!
21:13:48 <dons> it's the mangle alright.
21:14:21 <SamB> its so sloow because it is written in horribly tangled perl.
21:14:26 <dons> it probably seems  slow as it's invoking ghc?
21:14:35 <Lemmih> It 11mins to compile a 500 lines module. /-:
21:14:51 <dons> oh, something's clearly broken.
21:14:53 <Lemmih> On my 2Ghz Athlon box.
21:15:11 <SamB> that would be long on my 450 MHz PII...
21:15:22 <dons> the mangler is called by defaullt on all compilations that go via C, which is most of them -- and you've never noticed this befor, right?
21:15:50 <dons> Lemmih, does -fasm fix things?
21:16:12 * SamB has noticed it before, but only because he has wmtop running
21:16:44 <Lemmih> dons: Yeah that helped.
21:20:00 <dons> 11mins is bad. perhaps consider isolating test case that exhibbits this behaviour and reporting it to glasgow-haskell-bugs@ ?
21:50:21 <dons> @ghc
21:50:23 <lambdabot>  Inaccessible case alternative
21:53:24 <dons> hey conal
22:41:07 <conal> hi don
22:41:30 <conal> dons, thanks again for the help tonight.
22:41:56 <dons> sure. so reinstalling fixed the ghci problem?
22:42:11 <conal> sure did.
22:42:14 <dons> cool.
22:42:16 <conal> and it wasn't really about ghci
22:42:32 <conal> just that i was relying on ghc to find the package
22:42:41 <dons> yep.
22:42:42 <conal> and it found the old, since i hadn't reinstalled
22:42:46 <conal> like you said.
22:43:56 <conal> unsafeEval is working great for me.  a mysterious crash when i use it in the context of image display, though exactly the same function string evals & applies fine otherwise.
22:44:11 <conal> i hope it's not too hard to track down.
22:44:39 <dons> hmm.  and you provide the right type annotation, I guess?
22:44:57 <conal> yes, thanks.  i hadn't at first.
22:47:11 <dons> the first step then, to track it down its to compile hs-plugins with -DDEBUG so we can spot at what point the crash occurs.
22:47:23 <dons> s/its/is/
22:49:19 <conal> great.  i'm encouraged to have a place to start.  i'll give it a go in CA and write you.  actually i'm eager to try it now, but i better get to bed right now.  early morning.
22:49:30 <dons> yep. ok.
22:49:37 <conal> catch you later.
22:49:41 <dons> ciao!
22:54:08 <conal> dons, quick question.
22:54:24 <conal> how exactly do I recompile hs-plugins with -DDEBUG?
22:57:43 <dons> add -DDEBUG to config.mk's GHC_EXTRA_OPTS flag after running ./configure
22:57:57 <dons> s/flag/variable/
22:59:02 <conal> okay, thanks.
22:59:28 <conal> and then make clean; make; make install, right?
22:59:36 <conal> do i need to ./configure?
23:00:10 <conal> (and sorry; i see you already told me about GHC_EXTRA_OPTS)
23:00:34 <dons> no need to rerun configure if nothing changes.
23:00:47 <dons> yep, make clean ; make ; make install
23:01:00 <conal> and no need for unregister/register?
23:01:33 <dons> i don't think so -- the install should just overwrite the  old code, but no interfaces change, so the package.conf details are still correct
23:01:46 <conal> great.  just checking.
23:03:49 <conal> done.  i just emailed you a transcript.
23:04:00 <dons> got it
23:05:13 <conal> good
23:05:24 <conal> any clues there?
23:05:25 <dons> so it loads, then mysteriously exits?
23:05:36 <dons> make: *** [run] Error 5
23:05:57 <conal> yeah :(
23:06:46 <conal> the second and third examples are the same except that in the third (crashing) one, i'm displaying the function as a parameterized image (a disk).
23:07:24 <conal> while in the second case, just as a gui with two input fields (x,y) and a boolean output.
23:07:29 <dons> ah, so the first two unsafeEvals work?
23:07:33 <conal> yes.
23:07:37 <conal> which is great.
23:07:42 <conal> but odd about the third.
23:07:44 <dons> hmm..
23:08:18 <conal> i print the string and its type right before calling eval on exactly that string.
23:08:41 <conal> i mean i print a string containing the term (parenthesized) and its type
23:09:13 <dons> I see:
23:09:17 <dons> (\ a -> a * a) :: Float -> Float
23:09:21 <conal> right
23:09:31 <conal> that's the string i pass to unsafeEval
23:09:41 <dons> (\ a -> \ (b, c) -> sqrt (b * b + c * c) <= a) :: Float -> (Float,Float) -> Bool
23:09:53 <dons> (\ a -> \ (b, c) -> sqrt (b * b + c * c) <= a) :: Float -> (Float,Float) -> Bool
23:10:05 <dons> what's the difference between the last two??
23:10:09 <conal> right -- second & third -- identical
23:10:17 <conal> i don't see a difference
23:10:20 <dons> but third crashes?
23:10:32 <conal> yes.  i'm displaying it much different.
23:10:36 <conal> (ly)
23:10:36 <dons> ok.
23:11:03 <conal> sampling once per pixel in a wxhaskell panel.
23:11:15 <dons> oh, I see one difference in the debug output, we don't get a:
23:11:15 <dons> Looking for <<_MnlTGg2652_resource_closure>>
23:11:22 <dons> sg.
23:11:30 <dons> msg.
23:11:45 <dons> for the 3rd case.
23:12:16 <dons> so it's crashing before we finish the lookup. that's useful to know
23:12:24 <conal> oh, good.  that's something.
23:13:20 <conal> any way to get more info about where it's breaking?
23:14:08 <dons> well, I can add more debug stmts :)
23:14:15 <conal> yeah, there's that.
23:14:38 <dons> linkers are fiddly low-level thingies
23:14:52 <conal> i've never messed with them.
23:15:14 <conal> if you're up for doing that, i'd appreciate it.
23:15:42 <dons> is there any chance you could send me the code?
23:15:50 <conal> absolutely
23:15:56 <conal> can you unzip?
23:16:17 <blackdog_> a degree has to be useful for something.
23:16:31 <dons> :) it'll run on linux you think?
23:16:40 <seidan> I'm having trouble using the ST monad. For example, using the stack example from ImperativeHaskell on the Haskell Wiki, how could one: do some processing, dump some state, continue processing, dump some state, ...?
23:17:03 <dons> hey blackdog.
23:17:10 <blackdog_> G'day don.
23:17:48 <conal> dons, i hope so.
23:20:03 <dons> ok, if you send me the src, and a hint on how to reproduce the error -- then leave it with me and I'll try to find the bug today or tomorrow.
23:20:59 <conal> cool, thanks.
23:21:08 <conal> i just sent you a zip file.
23:21:08 <dons> it's weird the eval works, as the only difference between them is that eval also does a Dynamic unwrap after the load.
23:22:35 <conal> between which?
23:22:58 <conal> i sent another note with very brief directions for reproducing the error.
23:24:29 <conal> dons, okay -- now i'm *really* going to bed.  thanks again.
23:29:56 <dons> blackdog, heard the new sleater-kinney album?
23:30:13 <dons> damn good.
