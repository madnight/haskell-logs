00:29:42 <tuomov> jesse99: aren't flags usually lists of some flag type in haskell?
00:50:14 <musasabi> morning
00:55:35 <basti_> hi
01:23:55 <FrederikEaton> good night
01:51:29 <HL> hello
01:53:22 <nlv11757_> hello
01:53:41 <HL> im trying to understand some haskell code but im pretty new to this thing and i hope somebody here can help me out.
01:53:58 <HL> its some parser code and im missing some basic understanding of the syntax
01:55:23 <HL> if i have a parser and i give it a string and then "do char '-'" is the first command.. does this mean it looks for a "-" in first position of that string or just for the first available position?
01:56:56 <nlv11757_> what parser library are you using
01:57:05 <nlv11757_> parsec?
01:57:09 <HL> parselib
01:57:27 <nlv11757_> is your question a parselib specific question?
01:57:48 <HL> im not even sure about that but i doubt it
01:58:33 <nlv11757_> i don't know parselib, but judging on your question....i think it does mean try to eat up one '-' char from the string and continue with next parser
01:58:49 <nlv11757_> probably the next parser in the do
01:58:55 <HL> that sounds good
01:59:11 <nlv11757_> to be 100% sure i would have to see your code
01:59:16 <nlv11757_> @ircpaste
01:59:17 <lambdabot> Unknown command, try @listcommands.
01:59:21 <nlv11757_> @listcommands
01:59:22 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
01:59:22 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
01:59:22 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
01:59:22 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
01:59:22 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
01:59:22 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
01:59:24 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
01:59:27 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
01:59:29 <lambdabot> wiki wikipedia wn world02 yow
01:59:31 <nlv11757_> @paste
01:59:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:59:38 <HL> this means the pointer to the string gets incremented after each parser right?
02:00:12 <nlv11757_> i wouldnt think of it in that way....just think about it as the parser has eaten the first bit and returned the rest for other parsers to consume
02:00:25 <nlv11757_> how it is implemented is not relevant for the parsing concept i think
02:01:01 <HL> thats what i have guessed
02:01:16 <nlv11757_> may i ask btw why you are using parselib? is it because your institution uses that one?
02:01:34 <HL> i have some source which i try to understand
02:01:37 <HL> its not done by me
02:01:41 <nlv11757_> ow ok
02:01:41 <HL> and it uses parselib
02:02:05 <HL> d <- digit
02:02:23 <HL> this does fill variable d with a digit from the parser i guess?
02:02:33 <HL> im not sure about what "<-" means
02:02:44 <nlv11757_> are you familiar with monads?
02:02:53 <nlv11757_> cause this parser you are looking into is monadic
02:03:04 <nlv11757_> it uses the do notation and <- etc
02:03:24 <HL> well i have read monads on teh haskell page.. but i dont really understand it ;(
02:04:40 <nlv11757_> risking flames here with my explanation; doing <- kind of executes the monadic thing and returns it result
02:04:53 <nlv11757_> can you give me the type of that digit?
02:05:28 <HL> what do you mean by type? the actual character? or the function?
02:05:42 <HL> digit just runs isdigit as far i can understand
02:06:02 <nlv11757_> the type of the function digit
02:06:36 <HL> digit :: Parser Char
02:07:45 <nlv11757_> ok, so the Char here probably means it will return a Char as a result
02:08:02 <HL> as before i guess this will eat some char up in the string and the next parser will do the next one
02:08:06 <nlv11757_> it could also means this is a parser that consumes a Char...but then what would the return type be
02:08:29 <nlv11757_> when doing; d <- digit
02:08:39 <boegel> hey Itkovian
02:08:51 <nlv11757_> you eat up one char accoording to the definition of digit and store it in 'd'
02:08:58 <nlv11757_> then continue with next parse
02:09:00 <nlv11757_> r
02:09:10 <HL> yep thats what i assumed
02:09:23 <nlv11757_> so <- is a way to execute this parser
02:09:36 <nlv11757_> thats probably all you need to know about it at first
02:09:51 <HL> good ;)
02:09:57 <nlv11757_> :)
02:10:32 <HL> if i call a parser and it does not find something in the string.. it just returns nothing (if not set different) and it does not incrase the pointer i guess?
02:12:03 <nlv11757_> that depends on where this parser resides
02:12:31 <nlv11757_> there is also some kind of choice parser in parselib
02:12:46 <nlv11757_> let's call it 'choice'
02:13:14 <nlv11757_> it's often denoted with <|>
02:13:46 <nlv11757_> if i have two parsers p and q, then p <|> q is a new parser which first tries the parser p and if that one fails...it continues with q
02:13:53 <nlv11757_> and if that one fails...the parse fails
02:14:01 <HL> hm i thought of "or" when i saw this.
02:14:02 <nlv11757_> assuming no errorcorrecting stuff going on
02:14:22 <nlv11757_> it could have been named 'or' in parselib i dont know
02:14:46 <jlouis> nlv11757_: you might want to tell if the parser is predicative or not
02:14:55 <HL> ok. its only used in 1 function here..
02:15:20 <jlouis> ie, if p parses and consumes input, what does q get then? The original parse or the parse minus the consumed input?
02:16:40 <HL> i thougth it does not even get executed then?
02:16:42 <nlv11757_> if p succeeds in parsing, then q doesnt get anything i hope?
02:18:31 <nlv11757_> jlouis, im not sure if i understand what you mean?
02:46:13 <jlouis> nlv11757_: p tries to parse but fails
02:46:27 <jlouis> but has consumed input before failing
02:46:31 <jlouis> what does q get then?
02:46:49 <jlouis> if q gets the original input of p <|> q the parser is nonpredicative
02:47:17 <jlouis> if q gets the input minus what p parsed away successfully, the parser is predicative
02:48:09 <HL> why should it consume input when it fails?
02:53:29 <jlouis> HL: because p can be an arbitrary parser
02:54:23 <HL> "can" - how is that defined.. or how can i detect that?
03:11:49 <HL> ohwell.. i must go. thanks for helping
03:21:42 <alexj> anyone know why hackage isn't up anywhere?
03:21:53 <alexj> or where hackage is live?
03:22:20 <alexj> anyone awake?
03:24:35 <alexj> Hi JaffaCake.  Do you happen to know where there is a live version of hackage running.  ScannedInAvian is 404.  Do you know where it went?
03:24:52 <JaffaCake> sorry, don't knwo
03:36:28 <boegel> @seen shapr
03:36:30 <lambdabot> I saw shapr leaving #haskell 10 days, 18 hours, 36 minutes and 17
03:36:30 <lambdabot> seconds ago.
03:36:34 <boegel> a new record !
03:37:44 <dcoutts_> does anyone know whats happening with Haskell.org? the main server seems to have been moved to bugs.haskell.org (ie a different machine). Do we know if this is temporary or permanant?
03:39:22 <dcoutts_> ie do I need to reinstall software and recreate databases on the new machine or are we going straight back to the previous machine?
03:40:11 <JaffaCake> dcoutts_: bugs.haskell.org has always been a synonym for www.haskell.org, I believe
03:40:55 <dcoutts_> oh, hmm it does seem to be a different machine, but maybe I'm wrong... let me check more carefully...
03:41:19 <ibid> istr the machine was reinstalled with a new os
03:41:25 <ibid> r = read, in this case
03:42:27 <dcoutts_> ah, and do we know if the old disk is still available?
03:42:46 <dcoutts_> I'd need to transfer a database
03:43:32 <JaffaCake> cvs.haskell.org was reinstalled a while back, not haskell.org
03:43:47 <dcoutts_> it seems to be at /root/old-disk/ :-) yay, no data loss
03:44:17 <ibid> "Sorry for the downtime - haskell.org lost a disk today.  Everything is
03:44:21 <ibid> back to normal (I hope).  If you have software installed there, we
03:44:24 <ibid> upgraded to a new OS.  Hope this doesn't break anything!
03:44:27 <ibid> "
03:44:47 <ibid> on haskell@ yesterday
03:44:55 <dcoutts_> ibid, ah, ok, thanks.
04:10:18 <bourbaki> moin
04:10:54 <dcoutts_> phew, the db on the old disk was still ok, and I've reinstalled mysql, and the php mysql extension and reloaded apache (which made me nervous but it worked fine)
04:11:09 <dcoutts_> so the gtk2hs website is back online :-)
04:15:03 <Lunar^> ibid: new OS... is it Debian?
04:19:52 <dcoutts_> Lunar^, nope, still RHES 3.x
04:20:57 <Lunar^> *sigh*
04:28:18 <ibid> Khisanth: no idea
04:58:35 <boegel> dcoutts: were you having problems with the website ?
05:01:41 <dcoutts_> boegel, yes, haskell.org has it's OS reinstalled and all the normal files were restored but the mysql databases were not restored and mysql & php-mysql were not reinstalled
05:01:52 <dcoutts_> but I've done that now, so it's all ok :-)
05:10:16 <Philippa> @seen shapr
05:10:17 <lambdabot> I saw shapr leaving #haskell 10 days, 20 hours, 10 minutes and 4
05:10:17 <lambdabot> seconds ago.
05:10:21 <Philippa> didn't think so
05:10:31 <Philippa> in case anybody's wondering, he has a basic version of FLM that kinda works now
05:10:36 <Philippa> he just needs to make it use darcs
05:15:09 <boegel> Philippa: cool
05:23:53 <boegel> hey TheHunter
05:30:46 <TheHunter> hey boegel
05:35:29 <boegel> hey bringert
05:35:36 * boegel is having a "hey" day
05:35:42 <bringert> hey boegel
06:08:51 * boegel takes a well-earned break
06:30:05 <basti_> hi
06:33:28 <bourbaki> wo?
06:33:45 <basti_> aua
06:34:37 <bourbaki> :)
06:50:32 <nlv11757_> does underscore have a special meaning in lhs2TeX ?
06:50:52 <kosmikus> define "meaning"?
06:51:04 <kosmikus> but I'd say no
06:51:34 <nlv11757_> pfff my bad...suddenly big chunks of code dissappeared because i accidently put a closing parenthesis instead of braces....lol
06:51:48 <nlv11757_> totally unrelated to underscores
06:52:28 <kosmikus> ah, there's some strange stuff going on with vanishing code and parentheses sometimes
06:56:05 <basti_> hmm how do i get the command line parameters?
06:56:25 <df_> getArgs
06:56:46 <basti_> thanks
06:59:19 <Si\> has anyone ever made a comprehensive attempt at putting together a type-class based Collections hierarchy for Haskell?
07:00:36 <bubblesort> hi
07:00:50 <bubblesort> Is it possible to see the reduction steps haskell does?
07:04:55 <earthy> bubblesort: if you use Vital, you can
07:05:05 <earthy> http://www.cs.kent.ac.uk/projects/vital/
07:07:31 <basti_> hmm
07:09:12 <pharm> @seen shapr
07:09:13 <lambdabot> I saw shapr leaving #haskell 10 days, 22 hours and 9 minutes ago.
07:09:14 * basti_ takes a look into optimisation now
07:11:19 <pharm> oops
07:11:31 <basti_> hmm why don't unboxed values work even though i use -fglasgow-exts?
07:12:09 <ibid> define "don't work"
07:12:31 <basti_> continuation.hs:4:18: Not in scope: type constructor or class `Int#'
07:13:28 <ibid> you did import the relevant module?
07:13:37 <basti_> hm.
07:13:37 <kosmikus> you don't need glasgow-exts, you need to import GHC.Base or some other module that exports them
07:13:44 <basti_> ahh.
07:13:45 <basti_> okay.
07:13:57 <basti_> thanks that did the trick
07:14:53 <Igloo> You need -fglasgow-exts if you want to say Int# don't you?
07:14:59 <basti_> AND the module
07:15:07 <Igloo> Right
07:16:23 <kosmikus> sorry, I though you wouldn't need the flag
07:29:47 <bubblesort> earthy: How do I make the reductions visible in vital? Is it with these "styles" ?
07:36:26 <earthy> bubblesort IIRC, yes
07:36:39 <earthy> not exactly sure though, it's been a while since I looked at it
07:37:34 <boegel> bubblesort: I sweared on you some years ago, because you just wouldn't work properly :)
07:39:38 <bubblesort> hey, are you working properly always?
07:41:11 <bubblesort> ^^
07:41:50 <boegel> bubblesort: err, yes ?
07:41:53 <boegel> :p
07:42:04 <Lemmih> FUD sucks /-:
07:42:28 * boegel doesn't know FUD
07:42:40 <Lemmih> @dict-jargon FUD
07:42:41 <lambdabot> Unknown command, try @listcommands.
07:43:05 <Lemmih> @jargon FUD
07:43:07 <lambdabot> *** "FUD" jargon "Jargon File (4.3.1, 29 Jun 2001)"
07:43:07 <lambdabot> FUD /fuhd/ n. Defined by Gene Amdahl after he left IBM to found his
07:43:07 <lambdabot> own
07:43:09 <lambdabot>  company: "FUD is the fear, uncertainty, and doubt that IBM sales
07:43:10 <lambdabot> people
07:43:12 <lambdabot>  instill in the minds of potential customers who might be considering
07:43:15 <lambdabot>  [Amdahl] products." The idea, of course, was to persuade them to go
07:43:17 <lambdabot> [15 @more lines]
07:43:26 <Lemmih> @more
07:43:27 <lambdabot> with
07:43:27 <lambdabot>  safe IBM gear rather than with competitors' equipment. This
07:43:27 <lambdabot> implicit
07:43:27 <lambdabot>  coercion was traditionally accomplished by promising that Good
07:43:27 <lambdabot> Things
07:43:28 <lambdabot>  would happen to people who stuck with IBM, but Dark Shadows loomed
07:43:30 <lambdabot> over
07:43:33 <lambdabot> [8 @more lines]
07:44:01 <mflux> lambdabot fills the rows less than optimally
07:45:29 <Igloo> I'd be in favour of removing line breaking
07:45:50 <Igloo> (except in cases where it knows how to reflow input)
07:46:41 <boegel> Lemmih: that doesn't explain what FUD is :)
07:47:15 <Igloo> "FUD is the fear, uncertainty, and doubt"
07:47:18 <pharm> boegel: Fear, Uncertainty & Doubt !
07:47:24 <pharm> boegel: or the spreading thereof
07:48:59 <pharm> so who prods lambdabot then?
07:51:29 <Igloo> dons is its master
07:52:05 <JaffaCake> Igloo: any joy on HPPA?
07:52:31 <Igloo> JaffaCake: You haven't replied to my mails from last night have you?
07:53:05 <JaffaCake> I have one about the space leak problem.. was there another one?
07:53:41 <Igloo> There's that one, one from 2 nights ago about profiling in the head segfaulting, and one frmo last night about another SIGBUS on HPPA
07:54:09 <JaffaCake> er.. sent directly to me?
07:54:43 <Igloo> The first in the "GHC space behaviour confusion" thread, the last "More SIGBUS fun". To Simon Marlow <simonmar@microsoft.com>.
07:55:16 <JaffaCake> sigh... we are having some problems with mail getting lost here
07:55:27 <JaffaCake> can you try sending those again?
07:56:30 <JaffaCake> I have the "GHC space behaviour confusion" mail, but no "More SIGBUS fun"
08:00:25 <Igloo> I just forwarded 3 mails to you, but it looks like one of them failed again. I think the one I think you already have, though  :-)
08:01:33 <Igloo> I'm told fldd/fstd operate on doubles, 8 byte aligned, BTW
08:20:13 <JaffaCake> Igloo: I think this should have been fixed by my patch
08:20:27 <JaffaCake> could I take a peek at HeapStackCheck.hc after the change?
08:20:53 <Igloo> http://urchin.earth.li/~ian/HeapStackCheck2.hc
08:21:18 <pharm> To answer my question from yesterday (why isn't there a pdf of the Monad.Reader Issue 2 that is...) the answer is that there won't be one, since Shae has moved to using a wiki to do the publishing, and there's currently no filter from moinmoin wiki format to something like latex or pdf. First to write a wiki-syntax -> latex filter wins a prize of a printable copy of the Monad.Reader Issue 2 :-)
08:22:02 <JaffaCake> good, it is actually using ASSIGN_DBL
08:22:58 <JaffaCake> could you check the value of ALIGNMENT_DOUBLE in ghc/includes/ghcautoconf.h?
08:23:36 <Igloo> 8
08:23:44 <JaffaCake> and ALIGNMENT_LONG?
08:23:49 <Igloo> 4
08:24:05 <JaffaCake> that's odd
08:24:41 <JaffaCake> it *should* be using the definition of ASSIGN_DBL() at line 244 in Stg.h
08:25:07 <JaffaCake> which splits up the double into two words and assigns them separately, to avoid alignment trouble
08:30:53 <Igloo> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/cmm/PprC.hs.diff?r1=1.18;r2=1.19 is applied to both the built tree and the one it's trying to build
08:31:50 <JaffaCake> that's right
08:32:05 <JaffaCake> hmm, I don't grok HPPA assembly too well
08:32:10 <Igloo> If I add some printe statements to HeapStackCheck.cmm, how do I get ghc-inplace recompiled without doing too much redundant work?
08:32:51 <JaffaCake> it is the stage2 crashing, presumably?
08:32:51 <Igloo> It made my head spin trying to match up the hc to the assembly  :-)
08:33:18 <Igloo> It's genprimopcode compiled with 6.4 that's crashing
08:33:30 <JaffaCake> oh, there's your problem
08:33:43 <Igloo> (so I didn't really mean ghc-inplace above at all)
08:33:44 <JaffaCake> you're not compiling genprimopcode with the fixed compiler :)
08:34:01 <Igloo> I think I am...
08:34:33 * JaffaCake is slightly confused
08:34:43 <JaffaCake> what ghc are you building this tree with?
08:34:45 <Igloo> Oh, but I bet it's using the wrong header!
08:35:32 <Igloo> I hacked the paths in /home/igloo/cos/sm/ghc2inst/usr/bin/ghc to point at /home/igloo/cos/sm/ghc2inst/usr/... rather than /usr/...
08:36:07 <JaffaCake> ok
08:36:23 <JaffaCake> the header shouldn't make any difference
08:36:26 <Igloo> Hmm, but I don't see why that should be a problem as HeapStackCheck.cmm was already compiled during the original ghc build, wasn't it?
08:37:02 <JaffaCake> let me get this straight...
08:37:16 <Igloo> I built a 6.4+patch with 6.2.2 with prefix /usr or whatever
08:37:23 <JaffaCake> right
08:37:38 <JaffaCake> and you rebuilt the RTS after applying the patch?
08:37:44 <Igloo> I put it somewhere else and changed the paths in what would be /usr/bin/ghc{,-pkg} to match
08:37:56 <Igloo> The whole build was done after applying the patch
08:38:00 <JaffaCake> right
08:38:07 <Igloo> Then I got another copy of ghc, patched it, and tried building it with the first
08:38:18 <JaffaCake> ok, got it
08:38:45 <Igloo> I could try again with a sensible --prefix to start with, in case either I screwed up or that has broken things
08:39:17 <JaffaCake> you can add printf's to HeapStackCheck.cmm in the original build
08:39:28 <JaffaCake> then you just need to build the RTS, and try again
08:40:40 <JaffaCake> the thing I don't understand is how you ended up with those fldd instructions in stg_gc_gen: AFAICT, they shouldn't be there
08:44:00 <Igloo> OK, so I run make in ghc/rts and then just copy libHSrts.a to the appropriate place in the installed tree?
08:44:09 <JaffaCake> yup
08:49:06 <Igloo> Aha! The paths are in package.conf, so it's getting the rts from the broken installed GHC
08:49:24 <JaffaCake> there you go
08:50:21 <Igloo> I'll start afresh, and this time use --prefix sensibly  :-)
08:51:04 <JaffaCake> heh, sounds like  a plan
08:51:50 <Igloo> Ah rats, I think I made another unkillable process
08:52:11 * Igloo loves HPPA. No, really.
08:52:26 <Lemmih> alexj: http://scannedinavian.org/~lemmih/cgi-bin/hackage/hackage
08:53:12 <Lunar^> Igloo: I've installed Sarge on an old 715/100NX
08:53:28 <Lunar^> Igloo: few weeks ago.. even my wireless router has more bogomips
08:53:35 <Igloo> :-)
08:54:31 <Lemmih> alexj: There's a newer version here: http://haskell.galois.com/cgi-bin/hackage?action=view&type=all
08:55:09 <Igloo> JaffaCake: Does ghc use pthreads if you don't use -threaded?
08:55:33 <JaffaCake> no
08:56:06 <Si\> Lemmih: Is Hackage going to be hierarchical at some point (or is it now, I can't tell)?
08:57:07 * Igloo finds the mail from last time and discovers my memory had made up it being anything to do with pthreads
08:57:25 <Lemmih> Si\: I haven't given it much thought.
09:02:04 <basti_> @docs Data.Set
09:02:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
09:06:08 <boegel> has anyone seen the new Star Wars?
09:06:38 <boegel> I want to know if it's worth to go outside :p
09:09:40 <bourbaki> heh
09:09:41 <bourbaki> no
09:10:00 <bourbaki> and anakin is darth vadar "MUHAHAHAHA"
09:10:22 <Oejet> bourbaki: Nooooooooooo.
09:10:39 * bourbaki *evil laughter*
09:10:40 <Oejet> :-)
09:11:12 <bourbaki> sooner or later it will be shwon on tv
09:11:46 <bourbaki> im not willing to pay money for a movie that makes more money with merchandiseing
09:12:11 <bourbaki> boegel: how much do you pay in denmark for a ticket in the cinema?
09:13:19 <Lemmih> boegel is from Denmark?
09:13:40 <bourbaki> if i am not mistaken yes
09:13:54 <bourbaki> or belgium
09:14:56 <bourbaki> i wonder what lucas will do next i have high hopes for a new willow :)
09:15:21 <alexj> is there a version of hackage live somewhere to look at?  scannedinavian is giving 404
09:15:42 <alexj> lemmih:?
09:16:14 <Lemmih> bourbaki: We pay 11.86 to 16.95 dollars in Denmark.
09:16:30 <bourbaki> Lemmih: how much euros is that :)?
09:17:33 <Lemmih> 9.40 to 13.43 Euros.
09:19:25 <bourbaki> thats a lot
09:19:27 <Lemmih> alexj: They both work for me.
09:19:36 <alexj> what URL?
09:19:41 <Lemmih> How much do you pay?
09:21:50 <Lemmih> alexj: Check the two first lines I said after you joined.
09:23:07 <Lemmih> Morning.
09:24:36 <alexj> Lemmih: oh turned on my computer and then didn't look at the screen scrolled up and found the URLs thanks.
09:31:15 <basti_> hmm
09:32:58 <basti_> is it good to get all the results of the 8-queens problem in about 0.25 seconds?
09:33:55 <Igloo> Does hackage accept uploads of AllRightsReserved packages?
09:34:03 <Igloo> (see http://haskell.galois.com/cgi-bin/hackage?action=info&package=hsql )
09:34:34 <Igloo> I think it would be useful if it extracted the License-file so you could read it without downloading the package, too
09:34:39 <ibid> isn't it illegal to distribute sych package?
09:35:03 * basti_ burns some cycles
09:35:06 <Igloo> I'd have thought so
09:35:31 <Lemmih> The License field in the package description doesn't really mean anything.
09:36:02 <Igloo> Then it should be removed?
09:36:22 <ibid> or made to mean something
09:37:11 <Lemmih> Go tell SyntaxNinja.
09:37:48 <ibid> no, it's just another reason to ignore cabal for now
09:37:53 * Igloo didn't address it precisely because I didn't know which of you was the best to be talking to  :-)
09:37:59 <ibid> blah, not really
09:38:15 <SyntaxNinja> hiya
09:38:20 <Igloo> ibid: Do you have a problem with cabal?
09:38:27 <ibid> 19:38  <ibid> blah, not really
09:38:32 <Igloo> OK  :-)
09:38:50 <ibid> it felt good to say it, but it didn't mean really anything
09:38:59 <Igloo> heh
09:39:18 <ibid> the real reason i'm ignoring cabal is that i haven't yet needed to learn it
09:39:49 <ibid> but it *is* true that if the format is poorly defined, then its usefulness is diminished
09:40:30 <Igloo> SyntaxNinja: So, what's your take on this?
09:41:01 <Igloo> (the AllRightsReserved thing rather than the usefulness of cabal)
09:41:28 <Lemmih> (HackageDB will probably disallow packages licensed with AllRightsReserved in the future)
09:41:57 <Igloo> Ah, OK
09:44:44 <SyntaxNinja> lemmih: the license field does mean something; it's a computer-readable description of the license. just because it's not legally binding doesn't mean it's meaningless.
09:45:05 <SyntaxNinja> I agree w/ Lemmih, and don' tthink that the format is poorly defined.
09:45:16 <Igloo> What makes you think it isn't legally binding, OOI?
09:45:40 <SyntaxNinja> idono.  people have said so. who knows with licences.
09:49:03 <ibid> my "poorly defined" comment was not informed from the source, just from this discussion. take it appropriately.
10:13:49 <SyntaxNinja> Igloo: btw, the license-file field wasn't my idea. I liked just having the license field, but I don't mind having the license-file field.
10:14:39 <SyntaxNinja> ibid: there's really not much to learn about cabal. here's the user's guide: http://www.haskell.org/ghc/docs/latest/html/Cabal/
10:14:59 <ibid> SyntaxNinja: i'm sure i'll find that when i need to learn it :)
10:42:24 <Lemmih> @seen dons
10:42:24 <lambdabot> I saw dons leaving #haskell 58 minutes and 12 seconds ago.
10:42:49 <autrijus> wow. HaRe is huge
10:43:39 <SyntaxNinja> autrijus: you'll have to let me know if you find it useful.
10:43:48 <Lunar^> autrijus: reading your blog is a real pleasure btw
10:44:19 <autrijus> Lunar^: thank-you!
10:44:39 * autrijus is motivated by such kind words :)
10:46:15 <Lunar^> if only it wasn't perl :)
10:46:38 * autrijus tries out refactor.vim
10:46:41 <Lunar^> but maybe Pugs will get rid of my allergy
10:46:45 <autrijus> Lunar^: I know that feeling :)
10:46:58 <autrijus> <- trying very hard to inflict lambdasense to Perl 6 designers and community
10:47:14 <autrijus> it's working well, too
10:47:50 <Lunar^> I hope we will still get rid of the evil mangler someday
10:48:06 <Lunar^> It's evil, after all
10:48:58 <Lunar^> But running Perl on top of House could mean apt-get... mhhh dreams
10:49:01 <autrijus> maybe Pugs will compile it to haskell :)
10:55:29 <SyntaxNinja> Lunar^: apt is written in C++
10:56:09 <rtega> is it?
10:56:47 <Lunar^> SyntaxNinja: uh...
10:56:49 * Lunar^ hides
11:18:27 * Lemmih curses dynamic linking.
12:00:14 <xerox> @seen shapr
12:00:15 <lambdabot> I saw shapr leaving #haskell 11 days, 3 hours and 3 seconds ago.
12:04:21 * Lunar^ is getting tired of Alex lately
12:04:35 <Lunar^> xerox: he's still hacking FLM
12:06:39 * Lemmih ponders how to work around the limitations of hs-plugins.
12:10:23 <alexj> Lunar: should I take that personally or are you referring to a diferent alex?
12:11:29 <Lunar^> alexj: Oh, I didn't know you where on #haskell :)
12:11:34 <Cale> hehe
12:11:53 <Lunar^> alexj: You started two major thread lately, and it's hard for me to just skip them
12:12:21 <alexj> me too :- (
12:12:27 <Lunar^> alexj: even if I shouldn't be reading them
12:13:17 <alexj> I wasn't trying to be controversial and I wasn't trying to offend, but somehow I think I've done both.
12:13:31 <alexj> I am actually here so I can clarify things live for people who care.
12:13:41 <alexj> (I am not an IRC regular)
12:14:19 <Lunar^> good idea
12:14:32 <Igloo> alexj: FWIW I think people understand the essence of what you mean, but you and they just disagree on the fundamentals
12:15:27 <Igloo> Either that or I don't understand either  :-)
12:15:44 <Lunar^> alexj: AFAIU, Syntax's idea is too keep packages on the Hackage server, not elsewhere
12:18:04 <alexj> ok, but I don't know what follows from that re SSL/GPG or searchpath.
12:19:04 <alexj> re security, the question remains how you the results of a hackage query.
12:19:27 <Cale> It means that the packages themselves ought to be signed, since there's no other way to verify who they're coming from, when people upload them to the Hackage server.
12:21:20 <Lunar^> alexj: could you define what's an hackage query?
12:21:29 <alexj> http://haskell.galois.com/cgi-bin/hackage?action=info&package=HaXml
12:21:48 <alexj> it returns a package-url.  How do I know that package-url is correct?
12:22:35 <Lunar^> alexj: If you can verify a package, the problem disapear
12:23:10 <Lunar^> alexj: if package-url is incorrect, then we will not be able to check the package signature
12:23:18 <alexj> do I want the HaXml signed by Malcolm Wallace or the package signed by Joe Hacker?
12:23:36 <alexj> what package signature?
12:23:46 <Lunar^> if Joe Hacker is not in you keyring, then you'll get a warning
12:23:51 <Lunar^> s/you/pour
12:23:58 <Lunar^> damn... your\
12:24:02 <Lemmih> (:
12:24:07 * Lunar^ should turn on the light
12:25:40 <alexj> ok so I need a personal relationship with Malcolm in order to verify his packages.
12:25:49 <alexj> how does he get into my keyring?
12:26:04 <Lunar^> because of the web of trust
12:26:11 <Igloo> Or you need to trust me, and for me to assure you he is a good guy
12:26:21 <Cale> you just need to be in some chain of relationships which he is included in
12:26:35 * Igloo really dislikes the phrase "web of trust" in this context
12:26:48 <alexj> so I didn't necessarily have to have any prior awareness of Malcolm to trust him (as long as he was somewhere in my web of trust)
12:26:50 <alexj> ?
12:27:09 <Igloo> It implies people in the web of trust are trustworthy, in the sense of producing non-malicious packages
12:27:10 <alexj> Igloo: I don't like it either.  I think it obscures rather than illuminates.
12:27:40 <Igloo> alexj: Do you think SSL solves the problem you're currently talking about?
12:27:47 <alexj> Did I have to bless Malcolm's presence in my web explicitly or it is implicit in other keys in my keyring?
12:27:53 <Cale> I think the idea is that there is a graph of trust relationships, and you trust people in the same connected component as you :)
12:27:56 <ibid> Igloo: no, they are trusted to sign others' keys
12:27:58 <Lunar^> Igloo: good point
12:28:07 <Igloo> ibid: I know what it /means/
12:28:23 <Igloo> ibid: I just think the words /imply/ something else
12:28:34 <ibid> Igloo: i was trying to say that i don't :)
12:28:59 <alexj> So Malcolm is automatically trusted because I trust you and you trust him?
12:29:06 <ibid> Igloo: or rather, in technical jargon, it is a losing proposition to infer anything from the words used as terms
12:29:13 <Igloo> I think SyntaxNinja has talked about "Debian's web of trust", and I'm really not at all sure what he means there
12:30:36 <Igloo> alexj: Generally you would set gpg to have trust decay over chains of signatures
12:30:40 <ibid> to address an earlier question, "how does he [his key presumably] get into my keyring": by being imported into it. web of trust has nothing to do which keys are in your keyring
12:31:02 <Igloo> I'm not really sure how hackage is going to use it
12:31:14 <ibid> or i think i'm talking again without knowledge of what is being discussed, sorry
12:31:24 <Cale> http://people.debian.org/~weasel/weboftrust/index.php ?
12:31:30 <ibid> that's the gpg standard interpretetation in any case
12:32:03 * ibid goes read a little further into the backlog
12:32:15 <Igloo> Cale: Is that in answer to "Debian's web of trust"?
12:32:22 <Cale> Igloo: yeah
12:33:12 <alexj> igloo: the ssl model is that your keyring is a set of professional CAs rather than an ad hoc set of people you know.
12:33:13 <Igloo> Cale: Well, that's exactly my point. The Debian keyring is a set of trusted people, in the sense of doing-no-evil. I'm fairly sure it isn't a completely connected graph of keys/sigs
12:33:57 <ibid> actually, in the ssl case, you *can* (and many people do) include an ad hoc set of organisations they kniw
12:34:04 <Igloo> alexj: Paying CAs for keys is a non-starter for me. But ignoring that, how would it enable you to distinguish Malcolm's haxml from Joe Bloggs' haxml on the hackage site?
12:35:02 <ibid> the professional CA thing comes from the idea that to get your key to be trusted by everyone and their dog, you need to get a "signature" from somebody whose "signatures" everyone and their dog trust
12:35:09 <alexj> If you access hackage via SSL, you know that you are actually getting data from the hackage database rather than data provided by a MITM.
12:35:17 <ibid> leading to organizations that make their business to be trusted for that
12:35:33 * Igloo actually reads that URL and notes that it links to a page saying there are 112 developers outside of the web of trust
12:35:49 <ibid> afaiu, the ssl trust model is fairly faulty as it is deployed in the actual world wide web
12:35:50 <Lunar^> alexj: If the data is verified by itself, a MITM will be uneffective
12:35:52 <alexj> so, if you assume that the hackage is correct, then SSL guarantees you that its output is correct.
12:36:16 <alexj> ibid: yes
12:36:21 <alexj> Lunar: huh?
12:36:33 <alexj> lunar: oic.
12:36:35 <Igloo> Although I'm not sure if that is the WOT restricted to DD keys or the full thing
12:36:52 <ibid> a "yes" to which part of what i said, or all of it?
12:37:03 <alexj> lunar: I am finishing up how the SSL model authenticates the package.
12:37:22 <alexj> specifically the package URL.
12:37:33 <Igloo> alexj: You haven't actually answered my question
12:38:02 <Cale> Igloo: well, a fairly large number of people are connected through that. I think the idea is to extend that graph with Haskell/Hackage users, in the hopes that paths will form between those users and Isaac.
12:38:20 <Igloo> Cale: Connected through what?
12:38:22 <alexj> Igloo: Can we assume that the actual hackage database is correct?
12:38:38 <Igloo> alexj: I don't understand what "correct" means
12:38:53 <Cale> Igloo: the graph of key signings
12:39:09 <Igloo> Cale: But that's nothing to do with Debian
12:39:16 <alexj> igloo: I mean that the server itself knows the URL for HaXml.
12:39:55 <Cale> Well, that graph of keysignings is being referred to as the "Debian web of trust" as most (all?) of its current users are Debian developers.
12:40:14 <Igloo> alexj: Perhaps what I am missing is how you propose the database finds out what the correct URL for haxml is
12:40:39 <alexj> igloo: ahhh. ok thats what is at issue here!  great.  now we are getting somewhere.
12:41:18 <alexj> igloo: that is the big question.  how does a hackage database get populated?
12:41:19 <ibid> as i understand it, the debian web of trust refers to a subgraph of the graph of all signatures between dd gpg keys, where the subgraph is the largest strongly connected set or something like that
12:42:07 <alexj> presumanly it gets populated because some server operator has some way to decide what data is valid and what isn't.
12:43:12 <alexj> someone decides on the content of the HaXml record, right?
12:43:26 <Igloo> Cale: There were at least 9329 keys in the strongly connected set in 2000 according to http://www.earth.li/~noodles/pgpgpg.html vs around 1000 DDs who weren't all in it
12:44:55 <Igloo> alexj: AIUI, currently it is planned to be first come first served, with names being assigned to keys who use the name first
12:46:26 <alexj> ok then that is the definition of "correct"
12:47:21 <Igloo> alexj: OK, but that uses gpg...
12:47:50 <alexj> what uses gpg?
12:47:52 <Igloo> And end users get to decide whether to use a package or not based on whether they like the key being used
12:48:08 <Igloo> When I said "key" there I meant "gpg key"
12:48:50 <Igloo> So hackage isn't claiming Malcolm's haxml is any good or anything, it is just saying that his key owns the name
12:49:13 <Igloo> It's you, when you get the package signed by Malcolm's key, that decide whether or not you think it should be considered good
12:49:29 <alexj> how do you determine that his key owns the name?
12:49:35 <alexj> and not mine?
12:49:46 <Igloo> He uploaded first
12:50:19 <Igloo> If you upload first and I get a haxml package signed with your key (and I don't trust you) then I will not use the package
12:50:52 <Igloo> (In practice we hope name collisions will be sorted out amicably, of course)
12:53:05 <alexj> this isnn't an issue of name collisions. it is an issue of how you know if your accessing the correct record for some definition of correct.
12:53:21 <alexj> e.g. this URL http://haskell.galois.com/cgi-bin/hackage?action=info&package=HaXml is subject to a MITM attack.
12:53:50 <Igloo> Yes, but only by people who you trust
12:54:14 <alexj> so you have no particularly good reason to believe the returned data corresponds to anything in th database itself.
12:54:37 <Igloo> But you can trust the data
12:55:08 <alexj> Hackage says that Malcolm was the first guy to claim the HaXml name.  MITM says that HE is the first.
12:55:09 <alexj> who is right?
12:55:11 <Igloo> If people you trust want to screw you then they can anyway, by doing nasty things to a package of their own
12:55:30 <Igloo> Are you /trying/ to miss the point?
12:57:17 <alexj> I'm not trying.  But I guess I am missing it.
12:57:32 <zamez> I've got a parsing problem: given  declaration ::= IDENT S? COLON S? value S? | any_list.  , the second rule isn't matching for the token sequence  IDENT S RBRACE
12:57:39 <alexj> your argument is that MITM is not in your keyring.
12:57:44 <zamez> how can I solve that?
12:57:48 <Igloo> Right
12:57:58 <zamez> any_list does match that too
12:58:38 <zamez> as I understand it, that's because the first two token match either alternative, so it chooses the first one
12:58:44 <Igloo> SSL does make things very slightly better I'll admit
12:58:48 <alexj> so your security here is ENTIRELY dependent on the reliability of the people in your web of trust.
12:58:50 <zamez> and then can't change to the second because it's too late
12:59:10 <Igloo> Yes. But that is a fundamental fact.
12:59:17 <alexj> SSL actually makes things A LOT better here.
12:59:36 <alexj> SSL guarantees that you are getting the correct data from the hackage database.
12:59:39 <Igloo> If Simon Marlow decides to put a backdoor in GHC tomorrow then you are going to have a backdoor regardless of whether it is gpg signed and downloaded over an SSL connection or not
13:00:17 <Igloo> Only if you can guarantee trustworthy data is uploaded to hackage in the first place
13:00:39 <Igloo> SSL also means that one person decides what is trustworthy for all users
13:00:43 * zamez pokes the parsing experts here
13:00:49 <alexj> the hackage database can then just hold md5 checksums and authors don't need to deal with signing.
13:01:03 * Igloo gives up and goes to make some food
13:01:58 <alexj> igloo: the question is not whether it is trustworthy.  you just get a correct md5 checksum.
13:02:15 <alexj> or an HTTPS url for the package itself.
13:02:30 <alexj> Either way you are trusting hackage to be authoritative.
13:04:11 <Philippa_> you want a checksum rather than just an URL if you're serious
13:04:40 <alexj> depends whether you are pointing to an updatable repository or a specific version of a package.
13:04:47 <mflux> gpg signatures work even if hackage itself is compromised?
13:04:48 <Philippa_> true
13:05:12 <mflux> and I guess that has happened (repository compromised) atleast to debian and maybe some others..
13:05:25 * basti_ does not believe signing software makes much sense
13:05:33 <alexj> all they tell you  is that the author is in your web of trust.  they do NOT tell you that he is the official author of e.g. HaXml.
13:06:14 <alexj> the only way to know the official author of haxml is secured access to the hackage database.
13:06:45 <mflux> start distributing the 'root' keys now and be wary of changes to that list?
13:08:01 <alexj> the SSL answer is that there is a relatively fixed lists of CAs that have a professional obligation to be secure and a financial incentive to do so.
13:10:18 <mflux> ssl only makes a guarantee that there's a money trail from the site you're accessing
13:10:27 <mflux> (with a certificate from a ca that is)
13:10:48 <alexj> yes.  my assumption is that you have to trust the Hackage server no matter what.
13:11:07 <mflux> that it not true, if all you need to do is to trust the packagers
13:11:19 <mflux> you need to trust the packagers in any case
13:11:31 <mflux> with only ssl you need to trust _also_ the site
13:12:46 <alexj> with ssl you only need to trust the site (if the site is serving md5 checksums of the actual packages)
13:13:07 <alexj> (or the site is hosting them)
13:13:55 <mflux> so you're saying if the site has SSL certificate, the authors of the packages don't need to be trusted?
13:13:55 <alexj> if your point is that you don't know whether HaXml is good package to use.  That is orthogonal to the whole security issue.
13:14:33 <alexj> I am saying that if you know that HaXml has a particular md5 checksum, all you need to know is that the actual package you recieve has that checksum.
13:14:45 <mflux> and how is that md5 checksum calculated?
13:14:50 <mflux> by the author, no?
13:15:17 <alexj> when the package is uploaded to the hackage server or by the author.  it doesn't actually matter.
13:15:32 <alexj> if HaXml is a bad package, you have a problem in EITHER model.
13:15:41 <mflux> yes, I agree
13:15:57 <mflux> but if the site has been compromised, you have problem ONLY in the SSL-model
13:16:12 <mflux> the way I see it there are two compromises: author or the site
13:16:52 <mflux> signing package can help the site from being penetrated, whereas a ssl certificate doesn't help in either case
13:17:28 <mflux> s/can help.*,/can help in the case the site has been compromised/
13:17:31 <alexj> Signing packages just means that the MITM has to be somewhere in your web of trust.  If your web of trust is at all sizable, this is a substantial vulnerability.
13:17:48 <mflux> the 'web of trust' could for example have depth of two
13:17:59 <alexj> If the site runs SSL, then MITM has to hack the server as well.
13:18:31 <mflux> 'as well'? what else needs to be hacked?
13:18:40 <alexj> if the WoT has a depth of two then you probably need to go to A LOT of key signing parties.
13:19:00 <boegel> @seen shapr
13:19:02 <lambdabot> I saw shapr leaving #haskell 11 days, 4 hours, 18 minutes and 49
13:19:02 <lambdabot> seconds ago.
13:19:12 <mflux> well, if you're accepting packages from people you have never met, you can accept the keys as well
13:19:49 <mflux> all you want to verify is that the new version is from the same person as the previous
13:19:54 <alexj> If I you a package from you.  and your package build-depends on HaXml then I have reason to believe that HaXml is trustworthy.
13:20:05 <alexj> The only question is how do I get HaXml.
13:20:23 <alexj> Only Hackage can be authoritative about that.
13:20:42 <alexj> And you need SSL to get an authoritative answer from hackage.
13:21:09 <mflux> yes, even in the package signing model there would need to be an authoritative base identifying some trustworthy keys; that could be hosted in an ssl site
13:22:55 <alexj> yes.  and if a sizable population is in your web of trust, you need a way to make sure you are not vulnerable to MITM from any of them.
13:24:57 <alexj> or if you keep your web of trust small, you have the transaction cost of a lot of key signing parties.
13:27:23 <mflux> that is the argument I find difficult to believe, as as it is, trust has apparently been gained without much meetings
13:28:19 <basti_> i think this is a rather esoteric discussion i think
13:28:20 <alexj> you have a tradeoff between a large web of trust, a lot of code signing parties, or a limited set of trusted authors.
13:29:27 <Igloo> I'm sure a trust in the sense of trust, and trust in the sense of "web of trust", is just confusing this situation even more than necessary
13:31:10 <alexj> ok.  then i'll be more precise: either you implicitly accept a lot of signatures via a web, you explicitly accept a lot of signatures by attending key signing parties, or you accept a small set of signatures.
13:32:15 <SyntaxNinja> lost my connection about an hour ago. let me know if there were any quetsions I can help answer
13:32:23 <Igloo> Key signings aren't necessary to be reasonably confident a key owner is trustworthy
13:32:49 <mflux> if there was a requirement that a key can be used only for signing a certain package, there would not be much of a 'web of trust' to talk about
13:32:56 <alexj> igloo: how else do you get confidence?
13:32:59 <Igloo> Although many people believe it helps, sometimes because they come from a country where it is hard to change one's name
13:33:05 <mflux> basically the keys would need to be listed in somewhere
13:33:29 <alexj> mflux: per package keys == md5 checksums
13:33:30 <Igloo> alexj: If Malcolm Wallace put his key up on his website, I would be willing to add it to the keyring I accept packages from
13:33:51 <mflux> alexj, md5 checksums change for every release; the key doesn't
13:34:44 <alexj> igloo: how do you know you are accessing Malcolm's website?  Do you have to have already accessed his web site before you realize you want to use a package from him?
13:34:45 <mflux> so if some third party altered the package, changing the md5 sum would look like normal, but changing the key abnormal
13:35:39 <alexj> mflux: for simplicity I am assuming that every author is responsible for only one package.
13:35:56 <mflux> that was my assumption too
13:36:40 <mflux> in the key+signature-case attacking one package by an author would require attacking them all though
13:36:45 <mflux> (to remain stealthy)
13:41:42 <SyntaxNinja> and let me know if you've all had brillient ideas ;)
13:57:14 <autrijus> every CPAN module may have two keys
13:57:19 <autrijus> er, I mean, two signatures
13:57:28 <autrijus> one signed by the upload server, and one by author
13:57:41 <autrijus> the first one is implicitly checked via a pubkey bundled in the client
13:57:49 <autrijus> and second one is checked via standard PGP web of trust
13:58:14 <autrijus> the user may choose the policy of whether to install the package based on the two results
13:58:33 <autrijus> the first one signed automatically by the upload server using batch signing; the second one by the author manually during "make dist"
13:58:51 <autrijus> just a data point. may or may not be related :)
13:59:11 <Lemmih> That sounds exactly like what we're planning for HackageDB.
13:59:26 <autrijus> cool. :)
13:59:28 <autrijus> <- paid to design this
14:00:35 <autrijus> also, the upload server signs the tarball using detached signature
14:00:54 <autrijus> and the author sign for the extracted contents using a SIGNATURE file.
14:01:11 <autrijus> (which, coupled with the MANIFEST file, ensures no extra files can be passed in by a malicious party)
14:01:29 <autrijus> for example, the SIGNATURE file for pugs looks like
14:01:29 <autrijus> http://search.cpan.org/src/AUTRIJUS/Perl6-Pugs-6.2.3/SIGNATURE
14:02:33 <autrijus> and all my modules are signed in batch by the server:
14:02:34 <autrijus> http://www.cpan.org/authors/id/A/AU/AUTRIJUS/CHECKSUMS
14:03:02 <autrijus> I think both formats are quite self-explanatory -- not saying it's a particularly good format -- but it works quite well
14:14:56 <basti_> does anyone have a working example that shows how to make a single step with IOArray?
14:16:08 <basti_> i do not understand how to use them
14:16:56 <Igloo> I'm not sure I understand the question. writeArray arr 5 True   or something for an IOArray Int Bool should work
14:17:11 <basti_> hmm
14:17:22 <basti_> so how do i make a new one?
14:17:40 <Igloo> newArray or something
14:17:49 <Igloo> You want the Data.MArray interface, I think
14:18:03 <Igloo> M being mutable
14:18:17 * basti_ nods
14:18:22 <Igloo> Oh, Data.Array.MArray probably
14:18:50 <basti_>     No instance for (MArray a Int IO)
14:19:23 <basti_> this and similar tend to show up all the time
15:08:00 <SyntaxNinja> @moo
15:08:02 <lambdabot>               (__)
15:08:02 <lambdabot>               (-o)
15:08:02 <lambdabot>         /------\/
15:08:02 <lambdabot>        /|     ||
15:08:02 <lambdabot>       * ||----||
15:08:03 <lambdabot>  
15:08:05 <lambdabot> Flirtatious cow (winking)
15:08:46 <_JusSx_> lambdabot: bye
15:12:17 <sond> if anyone is interested, we are finnished with our final report on the Haste project
15:12:34 <sond> http://haste.dyndns.org/docs.php
15:12:38 <sond> oops
15:12:41 <sond> http://haste.dyndns.org:8080/docs.php
15:12:50 * dons reads
15:13:02 <davve> great :)
15:17:42 <dons> regarding plugins, they certainly make it easier to develop components in isolation - once you have a good api for them. yi's key bindings, and lambdabot's plugins are examples.
15:18:25 <Philippa_> that's one of the reasons I went for a plugin model for Flippi
15:18:27 <dons> yes, your comment about "external development contributions" is along these lines.
15:18:38 <dons> s/your/davve/
15:18:54 <dons> Philippa_, oh, cool.
15:19:30 <Philippa_> it's not using hs-plugins though, there's not much point in a CGI
15:19:38 <dons> yep.
15:20:24 <Philippa_> one of the things we're sorta aiming for is effectively allowing plugins to define authentication and priviledges from scratch
15:20:42 <dons> hmm. interesting
15:20:44 <Philippa_> in practise I think I'm going to have to allow them to intercept enough that it's sorta clear that's what was intended, but still
15:20:55 <Philippa_> they already get to affect all the IO operations on pages
15:21:24 <Philippa_> keeping a change history's done in a plugin, for example - it just intercepts page writes and dumps out the relevant info to a metadata field
15:23:22 <davve> dons, exactly. coming up with a good api could be tricky though.. but fun =)
15:23:34 <Philippa_> (I say 'intercepts' - plugins supply transformers for the page IO API, then you just build 'em into a stack)
15:23:43 <davve> dons, if we would do Haste 2, we certainly would use a plugin based system
15:25:53 <davve> where plugins could have their own dockable window if they wanted, using gtk2hs with an extension... mmm.. =)
15:27:02 <dons> I think you guys must have benefitted from using Scintilla, huh? developing  the low level text editor code from scratch in yi has been time consuming
15:27:25 <dons> (but as a result it's all Haskell :)
15:27:57 <dons> do you have any comments on your experience with scintilla?
15:27:57 <davve> yeah we benefitted a lot from Scintilla.. but we didn't have time to put all of its features to use
15:28:05 <stepcut> dons: how is syntax highlighting going these days ?
15:28:33 <davve> dons, well.. no not any written comments, except about the binding process
15:29:06 <dons> oh, no I meant more if you had any thoughts now on scintilla?
15:29:39 <dons> stepcut, there's a sketch and an idea - but i'm working on 3 papers simultaneously, so i don't have much time to hack :((
15:29:53 <dons> i guess this is what it's like to have a job
15:29:53 <davve> ah, well.. we think scintilla worked pretty good except for some strange bugs here and there
15:30:00 <stepcut> dons: sounds like you need a good synhi mode for yi + latex :)
15:30:17 <dons> stepcut: true!
15:30:21 <davve> dons, the actual Scintilla API is a mess though.. but the wxStyledTextCtrl wrapper is better
15:30:35 <dons> ah! that's interesting.
15:30:47 <dons> I should have a peek at that.
15:30:53 <davve> dons, the problem is that wxStyledTextCtrl doesn't wrap all Scintilla functionality
15:31:26 <dons> ok.
15:31:28 <davve> that will probably improve when wxHaskell works with the latest wxWidgets version though
15:31:54 <vincenz> ok, this is OT
15:31:59 <vincenz> but the proper channels are idlish
15:32:25 <dons> if you can encode your question in a type expression, then it's ok vincenz
15:32:54 <vincenz> if linux and firefox and click install extension then nil
15:34:22 <stepcut> vincenz: you missed the else statement...
15:35:10 <davve> dons, a problem with Scintilla is that loading external lexers dynamically doesn't work that well (atleast my friend didn't get it to work), so you have to link lexers in statically
15:35:32 <davve> the Haskell lexer is now part of the latest Scintilla release
15:35:37 <dons> hmm. you need, let me think, ... hs-plugins!
15:35:48 <dons> ;)
15:35:51 <davve> heh
15:36:02 <dons> yeah, so you guys contributed that back to scintilla?
15:36:12 <davve> yep
15:36:19 <dons> good good.
15:37:54 <davve> how suited is the yi editor to the kind of things that Scintilla does?
15:38:26 <Philippa_> JOOI, what /does/ scintilla do?
15:38:28 <dons> what kind of things?
15:39:14 <dons> yi's a pretty good vi at the moment. it has hopes for being a pretty good emacs.
15:39:50 <dons> to do that we need better dyamic haskell support, and just generallly more code: syntax highlighting, type checking, refactoring - that sort of stuff
15:39:52 <stepcut> but eventually it shall strike emacs and vi down to the ground and spit on their souls
15:39:54 <davve> the kind of things that you see in most IDE editors, like markers in the marginal, folding, auto completion with list boxes, call tips etc
15:40:08 <dons> oh, yi has none of that.
15:40:14 <davve> the kind of stuff you don't usually see in console editor, if you know what I mean
15:40:19 <dons> it's very much in the unix text editor tradition at the moment.
15:40:33 <davve> yeah.. okay
15:40:41 <dons> and will probably stay text editorish.
15:40:57 <dons> you could potentially build a nice wickywacky IDE on top of yi though
15:41:04 <dons> yi would be the scintilla component.
15:41:18 <davve> that's what I was thinking
15:42:00 <davve> I don't know how yi works, but i'm sure it's possible to create a backend that renders in some gui control, so that you can add gui elements in the editor? :)
15:42:38 <dons> probably.we have a bit of a wxHaskell gui: www.cse.unsw.edu.au/~dons/Yi.jpg
15:43:08 <davve> ah, okay.. cool
15:43:34 <tuomov> what IDE editors don't have is decent usability/bindings...
15:43:53 <davve> tuomov, like emacs/vim editors?
15:44:04 <tuomov> joe/jed with joe binding s:)
15:44:18 <davve> tumov, hehe.. I think there is a vim plugin for visual studio ;)
15:44:44 <tuomov> with minibuffers and everything?
15:44:52 <tuomov> I hate popup dialogs
15:45:01 <davve> i haven't got the slightest clue of how it works
15:45:29 <tuomov> Ion tries to make popups a bit less of a pain, but minibuffers are still nicer
15:46:03 <Pegazus> hi
15:46:04 <davve> hmm.. coming up with a good and general plugin based IDE core with yi integrated as an editor would be quite a project..
15:46:14 <davve> but it would be cool! :)
15:46:20 <Pegazus> is there any funciton that "adds" spaces to a string up to a length of N?
15:46:26 <Pegazus> (i want to align some things)
15:46:38 <dons> that would be pretty cool
15:46:43 <tuomov> Vis! :)
15:47:03 <stepcut> Pegazus: ??
15:47:14 <autrijus> Pegazus: (take n) . (++ repeat ' ')
15:47:52 <stepcut> autrijus: that will add spaces to the end of the line ?
15:47:58 <autrijus> yes.
15:48:08 <autrijus> padEnd n = (take n) . (++ repeat ' ')
15:49:08 <autrijus> padBegin n = reverse . padEnd n . reverse
15:49:23 <Pegazus> thx
15:49:34 <autrijus> np
15:49:36 <Pegazus> what does take n do?
15:49:46 <autrijus> it takes n elements from a list.
15:50:04 <Pegazus> mmmmmm
15:50:11 <Pegazus> and repeat how many times it repeats?
15:50:15 <davve> time to sleep.
15:50:16 <monochrom> take 2 [1,2,3] = [1,2]
15:50:19 <autrijus> infinity.
15:50:30 <autrijus> (repeat ' ') is an infinite string of spaces.
15:50:33 <Pegazus> ammm oks
15:50:37 <Pegazus> and what's the . for?
15:50:49 <autrijus> . combines two functions together
15:50:50 <autrijus> f . g
15:51:00 <monochrom> (f . g) x = f (g x)
15:51:03 <autrijus> is a function that accepts something, feed it to g, feed the result of that to f, then return.
15:51:41 <monochrom> where unix shell scripters write |, we write .
15:51:45 <autrijus> the use of . instead of adding another argument to padEnd and padBegin, is sometimes called point-free, or better known as pointless, programming.
15:51:50 <Pegazus> thx
15:52:32 <autrijus> @pointless \n ->  (take n) . (++ repeat ' ')
15:52:33 <lambdabot> (. (++ repeat ' ')) . take
15:52:53 <SyntaxNinja> Philippa_: does your wiki use cgi, or is it an apache module or what? :)
15:53:03 <monochrom> unix shell scripters write "sort | uniq".  we write "nub . sort".  It is very intuitive.
15:53:19 <autrijus> ...except it's right to left
15:53:30 <monochrom> Yeah you also need to be an Arab.
15:53:42 <autrijus> what's the conventional notation for (flip (.)) ?
15:53:48 <autrijus> # ?
15:54:05 <monochrom> I would use ; if I could choose.
15:54:19 <autrijus> (>>>) ?
15:57:11 <SyntaxNinja> arjanoosting: !
15:58:38 <autrijus> is there a library somewhere that defines LLVM IR as a haskell data structrure?
15:59:39 <dons> isn't that SSA?
15:59:51 <arjanoosting> Hi SyntaxNinja
16:00:44 <autrijus> ok. is there a library for emitting SSA trees?
16:00:59 <dons> let me find the link ...
16:02:15 <dons> ok. so first, SSA is equivalent to ANF, a restricted lambda calculus: www.cse.unsw.edu.au/~chak/papers/CKZ03.html
16:02:22 <dons> secondly, let me find the code ...
16:03:53 <Philippa_> SyntaxNinja: Flippi's a CGI
16:04:09 <Philippa_> even uses Network.CGI, though that'll probably change soon
16:04:14 <SyntaxNinja> Philippa_: OK thanks.
16:05:16 <dons> autrijus: www.cse.unsw.edu.au/~patrykz/papers/ssa-lambda/
16:05:35 <autrijus> dons++
16:06:09 <dons> grab lab.tar.gz - there's an SSA data type, parser, printer etc in there.
16:06:40 <Pseudonym> Nice!
16:06:48 <Pseudonym> I've been looking for a way to represent SSA in Haskell.
16:07:38 <autrijus> wonderful.
16:08:07 <autrijus> I was looking at Grin->Parrot, but it looks like SSA->Parrot is more straightforward (plus I get llvm for free)
16:09:46 <autrijus> wow. only 4 types and 9 constructors for ANF.
16:10:45 <dons> lambda calculus rules
16:11:15 <autrijus> hm, it doesn't do ANF->SSA
16:11:30 <autrijus> pity, because ANF looks easier to target
16:12:02 <Pseudonym> Why not just undo SSA to a non-SSA target language?
16:12:06 * autrijus ponders working on the reverse translator
16:12:21 <autrijus> Pseudonym: uh, I have this AST here
16:12:37 <autrijus> I was thinking I can maybe ->ANF->SSA->Parrot.
16:12:42 <Pseudonym> Ah.
16:12:50 <Pseudonym> You might be able to skip the SSA.
16:12:51 <dons> autrijus, check the paper. then mail patrykz. they may have worked it out since that paper was published. I have a feeling that patryk got ANF-> SSA sorted.
16:12:57 <autrijus> but the ->ANF stage is probably optional. I think I can manage ->SSA
16:13:06 <autrijus> dons: ok, will do so when I wake up
16:13:11 <autrijus> dons++ # amazingly helpful
16:14:54 <Pegazus> how do i take out "" form a string?
16:15:37 <autrijus> by using putStrLn instead of print? :)
16:16:09 <dons> @plugs filter (/= '\"') "foo\"foo\"bar"
16:16:10 <lambdabot> "foofoobar"
16:16:11 <dons> ?
16:16:38 <dons> but, yeah, you're probably using print/show instead of putStrLn
16:16:43 <Pegazus> im using show
16:17:11 <Igloo> You don't need the first \ there
16:17:25 <Pegazus> how do i use putStrLn in place of show?
16:17:33 <autrijus> Pegazus: instead of using show, use this "id" function
16:17:36 <autrijus> it's quite useful
16:17:46 <dons> @plugs '"'
16:17:47 <lambdabot> '"'
16:17:58 <Pegazus> this id? what'
16:18:07 <autrijus> @plugs id "string"
16:18:08 <lambdabot> "string"
16:18:36 <autrijus> Pegazus: the show function adds the "" to the string
16:18:43 <autrijus> Pegazus: if you don't want them, simply don't use show, just use the string.
16:18:52 <autrijus> if you want things escaped, but doesn't want ""
16:19:18 <autrijus> try using something like (init . tail . show)
16:19:43 <autrijus> which does show the string, then take the first/last chars away
16:20:00 <SyntaxNinja> all show does for strings is add the quotes
16:20:12 <SyntaxNinja> right? so why use show if you're trying to get rid of the quotes
16:20:47 <autrijus> SyntaxNinja: I think show also turns \n to \\n
16:20:55 <autrijus> I may be wrong.
16:21:06 <Igloo> You're right
16:21:10 <Igloo> Amongst other things
16:21:11 <SyntaxNinja> ahh
16:21:41 <SyntaxNinja> my guess is that Pegazus is not doing that, though.
16:22:26 <autrijus> we don't really know. there's no parameters declared for his implicit context.
16:23:12 <SyntaxNinja> we could have a side-bet
16:23:25 <autrijus> The.Mind.Reader
16:23:37 <SyntaxNinja> I suspect that the right answer for Pegazus is "don't use show" :)
16:24:26 <Pegazus> thx
16:25:08 <SyntaxNinja> hehe
16:29:30 <autrijus> hm, SSA has branches and goto; ANF has not. it looks like I'd better be generating SSA directly.
16:29:41 <autrijus> otherwise I'd be duplicating SSA->ANF work only have it ->SSA again
16:30:15 <dons> goto's are tail calls in ANF
16:30:20 <dons> branchs are if, iirc
16:30:58 <autrijus> but in ANF I'd have to remember the labels
16:31:15 <dons> I think that's right.
16:31:18 <autrijus> (my source language has labels and gotos ;))
16:31:23 <autrijus> sadly.
16:31:38 <dons> but ANF is designed to be a target for C
16:31:45 <autrijus> it is?
16:31:47 <dons> so I imagine this has been thought of.
16:31:58 <dons> I'll talk to patrykz about it.
16:32:06 <autrijus> > toANFe (SSA.GOTO l) g benv =
16:32:06 <autrijus> >  ANF.RETA (ANF.VAR (toANFx l)) (toANFg (beta benv l) g [])
16:32:12 <dons> he's writting a gnu C to ANF frontend.
16:34:31 <autrijus> it looks like SSAtoANF.lhs handles the required beta conversion
16:34:38 <autrijus> > beta ((l1,e):benv) l2 = if l1 == l2 then e else beta benv l2
16:35:30 <autrijus> ah. so it's reversible either way.
16:35:55 <autrijus> there's seems like to be no significant loss of expressiveness
16:36:13 <autrijus> I'm interested in ANFtoSSA now. :) will look paper and maybe ask afterwards.
16:36:19 <autrijus> but sleep first. thanks! &
16:36:37 <dons> cool.
16:36:46 <dons> ANF is certainly easier to work with than SSA.
16:36:54 <dons> all that meta-data in SSA is ugly and horrible.
16:37:06 <dons> and it's just simulating a functional language anyway.
16:57:45 <FrederikEaton> http://ofb.net/~frederik/pencilpond/
17:00:17 <FrederikEaton> so, the darcs copy of the source has code to automate releases and also contains the cgi script which does the project webpage
17:00:53 <FrederikEaton> working that out was why i went through the trouble of writing the web page
17:01:22 <dons> nice
17:01:55 <FrederikEaton> thanks. the web page change log is generated from a ChangeLog.hs module
17:02:17 <FrederikEaton> and the tarballs are all created automatically by checking out tagged revisions from darcs
17:03:03 <FrederikEaton> so there is no important state aside from what's in the repository. i don't know how other poeple do it but i think i'll use something similar for future projects
17:03:19 <FrederikEaton> whoa
17:03:46 <dons> yeah, it's a nice system.
17:16:34 <Pegazus> is there any debugger for haskell?
17:16:57 <Pegazus> (i wanna see how functions are called (and with wich arguments...))
17:17:22 <dons> ghci is useful for this. if you really need old-school type debugging you can use hat.
17:17:59 <dons> http://www.haskell.org/hat/
17:18:37 <dons> profiling can also be useful: ghc Main.hs -prof -auto-all ; ./a.out +RTS -p ; vi a.out.prof
19:10:00 <MachinShin> hey +
19:20:40 <kaol> @moo
19:20:41 <lambdabot>         (__)
19:20:41 <lambdabot>         (00)
19:20:41 <lambdabot>   /------\/
19:20:41 <lambdabot>  /|     ||
19:20:41 <lambdabot> * ||----||
19:20:42 <lambdabot>  
19:20:44 <lambdabot> Cow w/ Glasses
19:21:27 <Pegazus> hi
19:21:30 <Pegazus> is there any array
19:21:38 <Pegazus> or matrix type in haskell? by default?
19:22:50 <Pegazus> what does elem do?
19:24:03 <dons> @index Array
19:24:03 <Lemmih> @plugs 4 `elem` [1..10]
19:24:04 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.
19:24:04 <lambdabot> Diff
19:24:05 <lambdabot> True
19:24:48 <dons> for simple stuff, Pegazus, you should probably uses lists, and the stuff in Data.List
19:24:57 <Pegazus> what means Diff?
19:25:15 <dons> that's the end of Data.Array.Diff
19:25:51 <Lemmih> lambdabot should remove newlines and do word wrapping?
19:26:22 <dons> it shouldn't break on '.' or '-' anyway
19:27:09 <Pegazus> ahhh
19:27:12 <Pegazus> but what does elemen do?
19:27:15 <Pegazus> @index elem
19:27:17 <lambdabot> Data.List, Prelude
19:27:33 <Cale> @plugs 4 `elem` [1,2,3,4,5]
19:27:34 <lambdabot> True
19:27:38 <Cale> @plugs 4 `elem` [1,2,3,5]
19:27:40 <lambdabot> False
19:28:10 <Pegazus> ahh
19:28:11 <Pegazus> thx
19:28:22 <Pegazus> diferencia :: (Eq t) => [t] -> [t] -> [t]
19:28:22 <Pegazus> diferencia [] ys = []
19:28:22 <Pegazus> diferencia (x:xs) ys | (elem x ys) = diferencia xs ys
19:28:22 <Pegazus> | not(elem x ys) = (x:(diferencia xs ys))
19:28:30 <Pegazus> does that function makes "list" difference?
19:29:10 <Pegazus> and is there any way to debug haskell?
19:29:52 <Cale> open ghci and try it :)
19:30:13 <dons> usually you debug functions by trying them out in an interpreter.
19:30:36 <Pegazus> i have an interpreter
19:30:43 <Pegazus> and my function isnt working correctly
19:31:12 <Pseudonym> Then you've answered your first question. :-)
19:31:23 <Pseudonym> Oh, one comment
19:31:33 <Pseudonym> someFunction
19:31:38 <Pseudonym>    | someCondition = foo
19:31:43 <Pseudonym>    | not someCondition = bar
19:31:50 <Pseudonym> That would be better written as:
19:31:52 <Pseudonym> someFunction
19:31:54 <Pseudonym>    | someCondition = foo
19:31:59 <Pseudonym>    | otherwise = bar
19:32:26 <Pseudonym> @plugs otherwise
19:32:28 <lambdabot> True
19:33:37 <Pegazus> i know
19:33:39 <Pegazus> otherwise
19:33:44 <Pegazus> but my teachers like the other way
19:33:52 <Pegazus> anyway, how to debug'
19:33:54 <Pseudonym> Your teachers have no taste.
19:34:02 <Pegazus> i know
19:34:05 <Cale> btw, that code seems to work for me
19:34:07 <Pegazus> i am better at programming that them
19:34:17 <Pegazus> what's the erro cale?
19:35:22 <Cale> I didn't get an error
19:35:58 <Cale> that code works
19:36:21 <Cale> note that you should tab in the guard so that it lines up with the other one
19:36:26 <Pseudonym> What problem are you seeing, Pegazus?
19:36:50 <Pegazus> i dont know
19:36:51 <Pegazus> im asking
19:37:02 <Pseudonym> You say it doesn't work.
19:37:06 <Pseudonym> So how can you tell?
19:43:27 <Pegazus> i dont say nothing
19:43:37 <Pegazus> how to debug a program?
19:43:49 <Cale> <Pegazus> i have an interpreter
19:43:50 <Cale> <Pegazus> and my function isnt working correctly
19:44:10 <Cale> Pegazus: by evaluating expressions in the interpreter, usually
19:45:23 <Cale> there are other methods, like using Debug.Trace
19:46:25 <Cale> but they're not as important as simply breaking your program down into small testable functions, and checking that they work/reading the code to look for errors/proving that things work formally
19:47:08 <Pegazus> what is that?
19:47:16 <Pegazus> what is debug.trace?
19:47:31 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
19:47:38 <Cale> @type trace
19:47:40 <Pegazus> instance Show([Proyeccion]) where is possible to make that?
19:47:43 <lambdabot> bzzt
19:47:50 <Cale> @type Debug.Trace.trace
19:47:51 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
19:48:35 <Lemmih> @plugs trace "May I use trace in here?" True
19:48:36 <lambdabot> Variable not in scope: `trace'
19:49:09 <Pegazus> ?
19:49:12 <Pegazus> what?
19:49:18 <Lemmih> Just ignore me.
19:50:47 <Cale> Pegazus: trace takes a string and a value of any type, and produces the same value, except that when the value is evaluated, the string gets printed on stderr, possibly with some markup to let you know that it's from Debug.Trace (but there doesn't appear to be any at the moment)
19:51:28 <Pegazus> oks
19:51:58 <Cale> note that the Debug.Trace messages will get printed somewhat randomly, as evaluation is lazy
19:52:51 <Cale> It's not usually as useful as simple testing.
20:26:35 * thebug gives GHC on MIPS64/IRIX another spin
20:27:40 * thebug .o0(go "little" octane, go!)
20:28:49 <Lemmih> Isn't there a hDup in the libraries?
20:29:17 <thebug> hello Lemmih
20:29:25 <Lemmih> Hello thebug
20:31:33 <Sonarman> Lemmih: it's not in the index of the library documentation
20:32:26 <Lemmih> @type GHC.Handle.hDuplicate
20:32:27 <lambdabot> GHC.Handle.hDuplicate :: GHC.IOBase.Handle -> IO GHC.IOBase.Handle
20:32:54 <Lemmih> @index should perhaps search through GHC.*?
20:32:55 <lambdabot> bzzt
20:47:25 <kaol> @vixen I'm tired. Maybe I should go to sleep.
20:47:30 <lambdabot> how long have you gone there?
20:48:16 <kaol> @vixen Not very far, as I'm still awake.
20:48:20 <lambdabot> are you?
20:49:37 <Gahhh> @vixen are you?
20:49:41 <lambdabot> i truely am
20:49:54 <Gahhh> @vixen are you?
20:49:58 <lambdabot> i truely am
20:51:52 <Lemmih> Good night, #haskell.
20:52:32 <gord> @seen shapr
20:52:34 <lambdabot> I saw shapr leaving #haskell 11 days, 11 hours, 52 minutes and 21
20:52:34 <lambdabot> seconds ago.
20:52:51 <gord> Wow.  Shae told me he was busy with work, but that's insane!
20:53:21 <kaol> @vixen Have you seen shapr?
20:53:25 <lambdabot> you sound like an awesome guy... are you single?
20:55:09 <MachinShin> lol
20:55:48 <gord> I have a question: I'm a pre-newcomer to Haskell, and am trying to understand CT arrows as ``monadic computations with static properties'' as shapr put it to me in e-mail.  Is there anybody out there who would like to educate me?  I believe I grok monads, but I need some mentoring to make the connection.
20:56:41 <ibid> "pre-newcomer"?
20:57:17 <gord> Yup.  It means that I have some FP experience (Miranda), but have never written a line of Haskell.
20:57:29 <ibid> ah, ok
20:57:53 <ibid> i was just wondering as i wouldn't recommend a total fp newbie to start with monads in general and arrows :)
20:58:12 <Gahhh> warm fuzzy things, maybe.
20:58:35 * ibid confesses not to know any arrows :)
20:59:50 <gord> I've followed quite closely the work of TUNES, and grasp the basics of category theory, and on the other hand am a bottom-up OS developer, so I'm doing a kinda top-down bottom-up approach when it comes to Haskell. ;)
21:04:21 <Pseudonym> If you're actually an OS developer, you can't have followed TUNES that closely.
21:05:40 <jewel> Pseudonym, why do you say that?
21:05:57 <Pseudonym> The TUNES project doesn't really do any OS development.
21:05:59 <Pseudonym> THey produce text.
21:06:22 <jewel> they have recently started the slate project
21:06:23 <jewel> but it's userland
21:06:40 <Pseudonym> Yes, but I was following TUNES over ten years agi,
21:06:43 <Pseudonym> ago
21:06:48 <Pseudonym> They've RECENTLY started coding.
21:07:13 <jewel> what do you think of the text they produced?
21:07:20 <Pseudonym> I think there's a lot of it.
21:07:35 <jewel> and?
21:07:47 <Pseudonym> And I stopped reading it about eight years ago. :-)
21:08:06 <jewel> heh
21:08:32 * Pseudonym came to Haskell from Miranda too, BTW
21:08:45 <Pseudonym> Via Gofer, with a little Miracula thrown in.
21:09:15 <Gahhh> heh, I cant believe you named your daughter Miranda, too. It's a good name, but still :)
21:09:23 <Pseudonym> :-)
21:09:38 <Pseudonym> I didn't _really_ name her after the language.
21:09:47 <Pseudonym> But it's a good story.
21:09:57 <gord> I mentioned TUNES only because water's connection from CT to OS development pointed me to the theoretical underpinnings of my personal work, and I've been trying to get a broader perspective on what CT means to the FP crowd.  Jargon galore, that's for sure.
21:10:08 <Pseudonym> Better than Orwell or Gofer, anyway.
21:10:34 <Pseudonym> Ah, OK.
21:10:48 <gord> Miranda was fun.  I hope your daughter is, too. :)
21:11:39 <Pseudonym> :-)
21:13:33 <Pseudonym> Well Haskell is more fun than Miranda.
21:13:45 <Pseudonym> If you were ever annoyed that Miranda had this:
21:13:51 <Pseudonym> show :: * -> [char]
21:13:55 <Pseudonym> But you couldn't do this:
21:14:00 <Pseudonym> myshow :: * -> [char]
21:14:02 <Pseudonym> myshow = show
21:14:05 <Pseudonym> Then you'll like Haskell.
21:14:30 <gord> [I think TUNES hopes that somebody will come along with an AI so strong that it can just download www.tunes.org and automatically generate the world's perfect OS.]
21:15:56 <Gahhh> lol
21:16:53 <Gahhh> all managers would love that
21:20:59 <jewel> i think there are better sources of information to create a real OS
21:21:10 <Gahhh> I love the financial circles. Check this out: "...The industry's book-to-bill ratio, which measures orders received against product shipped, was 0.8-to-1". Now that's a "ratio".
21:21:44 <Pseudonym> 0.8 : 1 is a ratio
21:21:48 <jewel> it is  ration
21:21:53 <jewel> ratio
21:21:55 <Pseudonym> @plugs 0.8 % 1
21:21:57 <lambdabot> Ambiguous type variable `a' in these top-level constraints
21:22:00 <Pseudonym> Hmm.
21:22:03 <Pseudonym> @plugs 0.8 :% 1
21:22:04 <lambdabot> Data constructor not in scope: `:%'
21:22:10 <Pseudonym> Oh well.
21:22:35 <gord> Does anybody here know a broad overview of the *implementation* of Haskell (i.e. ghc runtime, or how hugs works)?
21:22:48 <gord> I know very little about graph reduction.
21:22:56 <Pseudonym> Do you know about Miranda's internals?
21:23:01 <Pseudonym> SK combinators?
21:23:18 <gord> SK I know in passing... let me google up that memory....
21:23:30 <Pseudonym> http://citeseer.ist.psu.edu/peytonjones92implementing.html <- This will probably do.
21:25:25 <gord> Excellent citation.  Thanks, Pseudonym!  I'll be quiet now as I read and try to understand.
21:25:30 <Pseudonym> :-)
21:28:30 * gord gulps at 87 pages, and thinks about sleeping sometime before he's done
21:29:19 <Pseudonym> Oh, another paper for you.
21:29:32 <Pseudonym> http://citeseer.ist.psu.edu/jones92glasgow.html
21:29:35 <Pseudonym> I think that's a little shorter.
21:29:48 <Pseudonym> 9 pages
21:29:52 <Pseudonym> You can probably get through that quicker.
21:38:50 <Pseudonym> And you know, they take 87 pages to describe the STG machine, and the STILL don't show how it's compiled to C.
21:39:02 <Pseudonym> More than one person has complained about that.
22:49:03 <gzl> @seen shapr
22:49:04 <lambdabot> I saw shapr leaving #haskell 11 days, 13 hours, 48 minutes and 52
22:49:04 <lambdabot> seconds ago.
22:49:08 <gzl> ...
23:34:57 <glimming> how do I detect EOF inside the Main of a program, I am getting
23:34:58 <glimming> Fail: <stdin>: hGetLine: end of file
23:45:19 <wilx`> hEof maybe?
23:45:32 <wilx`> @type System.IO.hEof
23:45:34 <lambdabot> bzzt
23:45:34 <wilx`> @type System.IO.hEOF
23:45:36 <lambdabot> bzzt
23:45:42 <wilx`> Well, maybe not ;)
23:46:33 <wilx`> Ah!
23:46:44 <dons> @type System.IO.hIsEOF
23:46:44 <wilx`> @type System.IO.hIsEOF
23:46:45 <lambdabot> System.IO.hIsEOF :: GHC.IOBase.Handle -> IO Bool
23:46:45 <lambdabot> System.IO.hIsEOF :: GHC.IOBase.Handle -> IO Bool
23:46:51 <wilx`> Right :)
23:46:54 <dons> @type System.IO.isEOF
23:46:56 <lambdabot> System.IO.isEOF :: IO Bool
23:55:08 <glimming> aha, thaks
23:57:04 <glimming> so I guess something like do input <- getLine
23:57:23 <glimming>    if isEOF then return () else ... ?
