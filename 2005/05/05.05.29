00:01:10 <dons> you're not running this in ghci are you?
00:01:35 <Lemmih> Nope.
00:03:17 <Lemmih> 'era' is defined in $fptools/ghc/rts/ProfHeap.c. Then why is it unknown?
00:05:22 <dons> are you loading the profiled rts?
00:06:02 <dons> we shold be loading libHSrts_p.a and friends, of course.
00:06:28 <Lemmih> Shouldn't they be filtered out?
00:07:20 <dons> yeah, sorry. the rts shouldn't be loaded. but it should certainly be the rts we're running in.
00:07:23 <dons> 00000004 C era
00:07:35 <dons> ProfHeap.p_o:
00:08:30 <dons> so you're trying to load a profiled object using a profiled hs-plugins in an application compiled with profiling?
00:08:47 <Lemmih> Yes.
00:12:47 * Lemmih has no idea how to fix this.
00:13:31 <dons> we need to work out where this symbol is, and double check that all the correct objects are in memory when symbol resolution occurs.
00:13:41 <dons> using -DDEBUG should help
00:13:54 <Lemmih> I already am.
00:13:55 <dons> as will chasing down the defn of era to see if it is magic in some way
00:14:18 <Lemmih> And 'era' is in the symbol table for the executable.
00:14:25 <dons> ghci uses the linker -- see if you can load the same profiled code in ghci?
00:15:10 <Lemmih> It dies on the missing 'era'.
00:15:17 <dons> oh!
00:15:23 <dons> well that's something.
00:15:29 <dons> now we can complain to Simon!
00:15:40 <dons> oh, that means 'era' should be in the GHCI linker table.
00:15:43 <Lemmih> Well so it should. GHCi wasn't linked to HSrts_p
00:15:53 <dons> ah, true.
00:30:59 <Lemmih> I think there's a bug in the code I wrote.
00:33:59 <Lemmih> oh wait, it's not a bug.
00:34:49 <lispy> Lemmih: just found a feature?
00:35:03 <Lemmih> Yeah actually (:
00:44:49 <RUXSPINZ> h4x0rs?
01:39:18 <Lemmih> dons: We need HS[lib]_p.o files?
01:40:19 * boegel greets #haskell
01:40:49 <Lemmih> Hey boegel.
01:42:47 <boegel> hey dblhelix, had time to read my thesis yet ? (I'm curious, aren't I :p)
01:43:12 <dblhelix> boegel: I just started reading :)
01:43:35 <dblhelix> boegel: I got a little distracted after I decided to take a quick peak at the Pixar website ;)
01:43:57 <dblhelix> boegel: but now I'm on it again
01:45:40 * Lemmih gives up and goes to the park.
01:46:14 <dblhelix> boegel: and I'm getting a bit jealous of the purity you Flemish can put the Dutch language
01:46:46 <dblhelix> /s/put/put into
01:47:51 <boegel> dblhelix: :)
01:48:14 <boegel> dblhelix: whta do you mean, purity ?
01:49:09 <boegel> Lemmih: the park ? as in outside ? DON'T dude !
01:49:20 <dblhelix> boegel: you speak of 'computergrafiek' f.i.
01:49:50 <dblhelix> boegel: Dutch people would insist of using the English 'computer graphics' for that
01:53:29 <boegel> dblhelix: we are forced somewhat to use Dutch terms instead of English ones
01:53:51 <boegel> the only thing I didn't translate was ray tracing, "straal jagen" seem somewhat stupid :)
01:54:09 <dblhelix> boegel: I really like that approach
01:54:51 <dblhelix> boegel: ... but not as much as I would have liked you to actually use 'straal jagen' :D
01:55:02 <boegel> :D
01:55:23 <boegel> then nobody would have any idea what the hell I'm talking about
01:55:59 <dblhelix> I guess :)
02:10:55 <musasabi> Have the haskell mailing lists been really quiet for the past few days?
02:15:53 <boegel> musasabi: yes, I have noticed it too
02:16:00 <boegel> maybe it's because of my H3D post :)
02:16:12 <boegel> I scared everyone off for some reason
02:19:19 <itior> how can i convert an Int to a String without using show?
02:20:23 <boegel> itior: why would you want that ? what's wrong with show ?
02:24:04 <mflux_> ..assignment?
02:27:16 <itior> oh
02:27:29 <itior> nm, i thought show returned IO::String
02:27:29 <itior> or whatever
02:27:33 <itior> thx anyway
02:28:44 <boegel> dblhelix: found any typo's yet ? :p
02:29:39 <dblhelix> no, I'm trying to get a grasp of Funmath, which will probably be the most challenging part for me
02:33:28 <boegel> I think so
02:33:52 <foxy> @pl \x -> chr (x + 48)
02:33:54 <lambdabot> chr . (48 +)
02:33:54 <boegel> although it's quite close to Haskell sometimes
02:34:28 <boegel> the man who 'invented' Funmath gave courses on it in Nijmegen in the 80's and 90's i think
02:35:44 <dblhelix> boegel: i noticed; I already find myself mentally translating v : X . e constructs to lambdas
02:40:24 <Lycan359> What's "Funmath"?
02:42:10 <boegel> Lycan359: a declarative funtional formalism to prove stuff and build an abstract model of an application
02:42:21 <boegel> I used it to build my raytracer (and write my thesis)
02:43:12 <Lycan359> raytracer huh? Got an nice looking images? :)
02:43:32 <dblhelix> boegel: time for a break, I'll continue reading this afternoon
02:43:52 <boegel> Lycan359: tons !
02:44:09 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website
02:44:17 <boegel> dblhelix: okay :)
02:46:30 <Lycan359> Think raytracing has a future in real-time graphics?
02:46:49 <mflux_> is there an existing operator for flip ($)?
02:47:13 <boegel> Lycan359: yeah, because speed is no longer an issue
02:47:18 <boegel> at least, we're going that way
02:47:38 <itior> how would i pattern match a | which gets passed as unicode %7C
02:47:44 <boegel> i believe they're already using is in some games, in combination with other techniques that is
02:47:46 <foxy> @pl flip ($)
02:47:46 <lambdabot> flip id
02:47:57 <boegel> @plugs flip ($)
02:48:02 <lambdabot> <Plugins.Eval>:1:
02:48:02 <lambdabot>   No instance for (Show (b -> (b -> b1) -> b1))
02:48:02 <lambdabot>   arising from use of `show'
02:48:06 <boegel> woops :)
02:48:24 * boegel leaves for lunch
02:48:37 <dons> @type flip
02:48:43 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
02:48:45 <dons> @type flip ($)
02:48:46 <lambdabot> flip ($) :: forall b b1. b1 -> (b1 -> b) -> b
02:49:28 <dblhelix> mflux_: usually one declares (#) = flip ($) but iirc this does not work with glasgow exts
02:49:52 <wilx> @pointless flip ($)
02:49:52 <lambdabot> flip id
02:50:07 <dons> usually ? who else does?
02:50:19 <mflux_> I was thinking maybe <$>
02:51:08 <dblhelix> dons: those who have done bindings to OO-stuff; see f.i. the work of Erik Meijer and Daan Leijen
02:51:38 <dons> ah! ok.
02:51:48 <dblhelix> dons: and, sometimes, I do :)
02:52:01 <dons> ok. i've not seen it in the hier libs source or ghc, that's all.
02:52:32 <dblhelix> dons, mflux_: well. I don't think it's a real convention or anything
02:54:05 <dons> hmm. $> and <$ might be nice
02:54:33 <mflux_> $> being just $ and <$ flip $?
02:54:42 <mflux_> or vice versa ;)
02:54:54 <mflux_> actually vice versa would maybe make more sense
02:55:27 <dons> reminiscent of >>=
02:55:38 <mflux_> I'm using it at the moment as 'poor man's monads', there are some steps in list evaluation
02:55:59 <dons> f <$ x and  x $> f
03:02:18 <mflux_> I put them infixr 1 and infixl 0, respectively
03:25:15 <boegel> themaximus: having fun ? :)
03:29:52 <musasabi> Does GHC close filehandles when using hGetContents?
03:36:06 <musasabi> This seems like a problem with the optimizer, it sees "the program does not use the handle for anything" => run finalizer => peer in Network notices => the node has gone down, lets purge his info => frustration.
03:37:33 <musasabi> Is there a way of saying "close this handle at exit (if possible), not sooner" ?
03:39:34 <Lemmih> dons: (re. prof in hs-plugins) You have any idea how I can debug it?
03:42:07 <dons> hmm
03:43:20 <dons> find the symbol, make sure it has been loaded. check that it's not some CPP macro problem? double check that the right packages are being loaded. think hard. get stuck and see if ghc has any clues. then try simonm
03:43:24 <dons> ?
03:43:51 <dons> maybe there's something special about the profiled symbols that we don't know about
03:44:19 <dons> btw, does this mean there's no way to do profiling inside ghci? I guess it does.
03:44:38 <dons> which means no one has ever dyn loaded a profiled lib -- so this is new
03:44:42 <Lemmih> objdump indicates the symbol is there. It's declared as an 'unsigned int' in ProfHeap.c. No packages are loaded at all.
03:45:56 <dons> it seems to suggest that the profiled rts isn't the one that is running.
03:46:11 <dons> you're running it +RTS -p ? does that change anything?
03:46:26 <Lemmih> Same error.
03:46:50 <dons> has the symbol been linked into the static binary?
03:47:08 <Lemmih> According to GHC and objdump, yes.
03:49:06 <Heffalump> +RTS -p is just an instruction to the RTS to actually do profiling, so it shouldn't affect symbol linkage, right?
03:49:13 <dons> yeah
03:49:28 <Heffalump> but I guess anything is worth trying when it's all confusing :-)
03:50:43 <Lemmih> I can access 'era' with 'foreign import ccall "&era" era :: Ptr CInt' from the application.
03:51:11 <dons> oh good. well it's there then.
03:51:29 <dons> maybe resolveObjs is being called at the wrong time?
03:59:37 <dons> if you get really stuck, using a debug rts will probably help. debug statements in the Linker.c are useful too.
04:00:05 <Lemmih> I'll try that then.
04:01:04 <Lemmih> No -lHSrts_debug_p (:
04:01:36 <dons> more work :/
04:02:02 <dons> people don't debug and profile at the same time??
04:02:07 <dons> ;)
04:04:25 <foxy> how do I increase the heap size for a program?
04:04:51 <Lemmih> Gotta wait for SimonM then *sigh*
04:05:15 <dons> -H80M ?
04:05:42 <dons> Lemmih, do you have an fptools tree?
04:06:13 <dons> you could edit Linker.c, recompile it,and use that modified rts in place. more hacking.
04:06:13 <Lemmih> Yes.
04:06:28 <Lemmih> Urk.
04:06:33 <dons> or maybe you can work around this problem -- is there a way to statically link in the stuff you're loading dynamically?
04:06:40 <dons> just for profiling purposes?
04:06:55 <dons> (this is how lambdabot and yi are profiled, as I said earlier)
04:07:20 <Lemmih> I'm playing with the Null example in examples/load
04:07:43 <Lemmih> So yeah.
04:08:04 <Lemmih> But I really don't wanna profile it (:
04:13:12 <jlouis> ghc 6.4 was just tried out here. It kicks major butt
04:13:30 <Lemmih> dons: Maybe 'era' should be in RTS_SYMBOLS?
04:14:04 <boegel> jlouis: why ?
04:15:07 <dons> Lemmih, good idea. worth a try.
04:15:27 <dons> i thought that was for symbols that need to be visible to the dynamic linker ... so sounds plausible.
04:16:28 <dons> there could be a bunch of such symbols we need to populate the symbol table with.
04:16:35 <jlouis> boegel: well it is faster and produces better code it seems
04:16:40 <dons> all the profiling related ones called from user code
04:16:56 <boegel> jlouis: maybe I should try my raytracer with 6.4 then
04:17:00 <dons> they wouldn't be added atm, as ghci doesn't 'do' profiled code.
04:17:52 <dons> Lemmih - yeah, I can talk myself into this being the problem. i've had to add symbols previously when trying to loda the dynamic linker dynamically.
04:18:05 <dons> that added some new symbols referenced in user code that weren't in the linker table
04:18:13 <dons> profiling would be the same.
04:18:56 <dons> I can commit a patch back if you work out what symbols we need.
04:19:11 <Lemmih> Is there some way to rebuild the RTS only?
04:19:33 <dons> cd ghc/rts ; gmake
04:19:43 <Lemmih> Thanks.
04:19:51 <dons> then rm compiler/stage2/ghc-* ; cd compiler; gmake
04:20:01 <dons> then use compiler/stage2/ghc-inplace
04:20:28 <dons> or I guess you could force a particular libHSrts with the write -l flag.
04:21:13 <dons> (so the above just forces ghc to relink - probably not nec.
04:21:27 <dons> ghc would just cause user programs to link against the in-place rts anyway.
04:54:44 <bourbaki> moin
04:55:06 <boegel> hey bourbaki
05:01:34 <boegel> @index replace
05:01:35 <lambdabot> bzzt
05:02:16 <hyperion> @moo
05:02:17 <lambdabot>          (__)
05:02:17 <lambdabot>          (oo)
05:02:17 <lambdabot>   /-------\/-*
05:02:17 <lambdabot>  / |     || \
05:02:17 <lambdabot> *  ||----||  *
05:02:17 <lambdabot> \/|(/)(/\/(,,/
05:02:19 <lambdabot>   Cow munching
05:02:22 <lambdabot>     on grass
05:14:59 <boegel> @moo
05:15:01 <lambdabot>           (__)
05:15:01 <lambdabot>           (oo)
05:15:01 <lambdabot>   /--------\/
05:15:01 <lambdabot>  * o|     ||
05:15:01 <lambdabot>     ||----||
05:15:01 <lambdabot>  ooo^^    ^^
05:15:04 <lambdabot>   Cow taking
05:15:05 <lambdabot>     a shit
05:15:08 <boegel> lol
05:16:41 <Lemmih> GHC from cvs is broken?
05:38:35 <dons> doesn't build?
05:38:55 <Lemmih> Cabal from darcs is broken.
05:39:18 <dons> oh. maybe. ghc appears to be fine
05:39:18 <Lemmih> Cabal depends on util, util depends on lang and GHC wants to use Cabal while hiding lang.
05:40:15 <Igloo> utils is an hslibs package, so cabal probably shouldn't be using it
05:40:20 <Igloo> What does it want from it?
05:40:38 <dons> I think there was a post about this last week.
05:41:11 <Igloo> I thought that was about rebuilding ghc, but I could be mistaken. Also, cabal comes with ghc anyway, so it could be effectively the same thing anyway
05:42:00 <Lemmih> Cabal doesn't need 'util' for anything.
05:42:17 <Igloo> Oh, sorry. But same applies for lang.
05:42:27 <Igloo> No, wait, you said it does
05:43:13 <Lemmih> It lists 'util' in its build-depends but it doesn't really need it.
05:43:25 <Igloo> Ah, well, remove it then  :-)
05:44:33 <Lemmih> I already did. (:
05:45:12 <Igloo> I wonder if something could warn about unused build-deps
05:46:23 <Lemmih> Probably not before compiling and only when using GHC.
05:49:37 <Igloo> When compiling is fine
05:53:26 <Lemmih> Hmm Sometimes, even when you don't import any modules from a package, you still want to link with it.
06:33:50 * boegel whistles
06:54:26 * SamB wishes you could use reify when running a quotation in the IO monad...
06:54:39 <vincenz> Hey
06:54:49 <vincenz> Anyone know some papers on turning imperative into applicative code?
06:55:31 <Lemmih> @google "turning imperative into applicative code"
06:55:32 <lambdabot> No result found.
06:56:04 <vincenz> I'd assume this is the right channel, haskell has a history of applicative code :D
07:01:40 <ibid> tried scholar.google?
07:13:21 <[TWiSTED]> parseFormula s  = ((name, read s') : parseFormula rest)
07:13:21 <[TWiSTED]>                       where
07:13:21 <[TWiSTED]>                          (name, rest) = break (isDigit) s
07:13:21 <[TWiSTED]>                          (s', rest') = break (not . isDigit) rest
07:13:25 <[TWiSTED]> this should work yea?
07:13:39 <[TWiSTED]> i swear i ahvent changed anything and now its not working
07:13:52 <[TWiSTED]> well doing what it was before
07:14:22 <boegel> [TWiSTED]: that isn't possible :) are you using the same example too ?
07:14:35 <[TWiSTED]> example?
07:15:08 <Lemmih> s/parseFormula rest/parseFormula rest'/
07:15:09 <boegel> well, yeah, you said it's not working as before
07:15:17 <boegel> how are you testing it ?
07:15:24 <[TWiSTED]> yeh i putting the same input
07:15:37 <[TWiSTED]> well same format (string then int, string then int)
07:15:43 <boegel> try what Lemmih just showed
07:15:47 <[TWiSTED]> ok
07:16:08 <Lemmih> You might be a little more inventive with your variable names.
07:16:23 <[TWiSTED]> it outputs correctly now
07:16:32 <[TWiSTED]> but doesnt 'stop' at the end of the string
07:17:00 <[TWiSTED]> like parseFormula "hi3hey4" -> [("hi",3),("hey",4),(
07:17:01 <[TWiSTED]> then an error
07:17:10 <Lemmih> Indeed.
07:17:25 <Lemmih> What do you think 'parseFormula ""' should do?
07:18:16 <[TWiSTED]> ooo
07:18:17 <[TWiSTED]> shit
07:18:19 <[TWiSTED]> my bad
07:18:42 <[TWiSTED]> ye got it now
07:18:43 <[TWiSTED]> thanks man
07:30:24 * boegel yawns
07:41:42 <boegel> hey dblhelix :)
07:41:56 <dblhelix> boegel: well I've read most of it; had to take some shortcuts here and there, but I think I've a rather good impression
07:42:09 <boegel> and, how do you like it ? (honest)
07:42:50 <dblhelix> I think it really cool; must have been fun to do this project
07:43:33 <boegel> it is :)
07:43:48 <boegel> how do you like the way it's been written ? fluently enough ? too simple ?
07:43:52 <dblhelix> the only thing I kind of missed, was pointing out where you actually make a significant contribution etc.
07:43:54 <Lemmih> It is available for download somewhere?
07:44:08 <boegel> Lemmih: not yet, but it's in Dutch
07:44:24 <boegel> dblhelix: heh, yeah, we'll, the contribution is the use of Funmath
07:44:39 <boegel> I've heard that comment before, and you have a point there
07:44:52 <dblhelix> well, I had to really hang in to get the first parts of Ch. 2 right; getting used to notation etc.
07:45:00 <boegel> the fact is, it shows that multimedia stuff can be implemented elegantly in functional languages
07:45:14 <boegel> yeah, I can imagine :)
07:45:18 <dblhelix> boegel: I think it would have hurt to stress that point more
07:45:24 <boegel> Lemmih: the code will be available online Wednesday or so
07:45:32 <Lemmih> Oki
07:45:45 <boegel> that's when my thesis is due, so no problems with anymore with throwing it online then
07:46:01 <boegel> Lemmih: the text is like 70 pages, so a bit much to translate I guess :)
07:46:09 <dblhelix> Lemmith: but you should already check out the screenshots
07:46:41 <boegel> I think he knows that, I tend to throw that in here regularly :)
07:46:48 <dblhelix> /s/Lemmith/Lemmih
07:46:51 <Lemmih> Yeah (:
07:46:58 <boegel> dblhelix: yeah, I could've
07:47:18 <boegel> but the thing is, only two people (me and a friend of mine) where mad enough to work with Funmath
07:47:48 <boegel> everybody hates that course :) and the last guy who did that got 18/20 for his thesis, because it's so theoretical (and interesing ;))
07:48:25 <boegel> the contribution part didn't seem a problem when I did my presentation (didn't get any questions on that matter)
07:49:01 <dblhelix> well, I guess the major advantage in your approach is that Funmath provides you with a machinery to reason about algorithms etc. quite rigorously
07:50:03 <dblhelix> a good follow-up would be to a more general framework for extracting Haskell programs out of (a subset of) Funmath specifications
07:50:16 <boegel> yeah, I've heard that before :)
07:50:17 <dblhelix> /s/to a/to describe a
07:50:36 <boegel> maybe I should suggest that to my professor
07:50:49 <boegel> but first, let's see how my grades are :p
07:51:43 <dblhelix> I think you can be quite confident about that; it really looks good
07:52:14 <dblhelix> but perhaps you're worrying about your test tomorrow a bit more ;)
07:52:15 <boegel> hey, thanks :) I'm quite pleased with it too
07:52:23 <boegel> dblhelix: nah, should be fine
07:52:32 <dblhelix> glad to hear
07:52:34 <boegel> I've studied more than I thought I would've
07:52:40 <boegel> and it's not that hard really
07:53:07 <dblhelix> you should be quite familiar with the topic by now
07:54:00 <boegel> yeah, I think so too :) I think it won't be as hard for me as it will for others
07:55:23 <dblhelix> boegel: so, it seems like you will be graduated at the end of this week?
07:56:32 <boegel> no, no, I have more final
07:56:55 <boegel> RTS, Compilers and Soft Computing (Fuzzy logic and such)
07:57:18 <boegel> my last final is 24th of June, and I won't get my results until 5th of July or so
07:58:13 <boegel> and then I'll go on holiday for 3 weeks to southern France
07:58:24 <boegel> and then start working (probably a Phd)
07:58:32 <dblhelix> rts? real time systems?
07:59:22 <dblhelix> any PhD positions available for you? which areas have your interest? well, functional programming, obviously :)
08:01:38 <boegel> dblhelix: well, no :)
08:01:46 <boegel> (rts = real time systems, yes)
08:02:08 <boegel> Itried getting a Phd position for Funmath related stuff, but they don't have money or 'room' for me
08:02:21 <dblhelix> ah, I've been there
08:02:35 <boegel> I'll probably do a Phd trying to predict the execution time of (Java) programs
08:02:44 <boegel> I'll be working along the side of Itkovian then
08:02:54 <dblhelix> ah, that sounds interesting too
08:03:06 <boegel> but I won't forget Haskell, and keep using it (as in with H3D probably)
08:03:09 <boegel> yeah, it does :)
08:03:30 <boegel> that reminds me, I should contact the man who I should contact about the position
08:03:37 <dblhelix> :)
08:04:50 <TFK> How will head quicksort list perform on average?
08:04:55 <boegel> what will you do ? you're graduated too, right ?
08:05:36 <dblhelix> boegel: I have to complete just one course; and I hope that will be done by next Tuesday
08:05:37 <TFK> I mean, will it perform better than O(nlogn), since it shouldn't evaluate anything but the head?
08:06:00 <dblhelix> boegel: I've obtained a PhD position at Utrecht
08:06:04 <thou> TFK: it's still nlogn, i think
08:06:06 <boegel> dblhelix: which subject ?
08:06:28 <TFK> But why?
08:06:30 <thou> TFK: don't have to sort the whole list, but still have to do the bulk of the work
08:06:31 <dblhelix> boegel: automatic program analysis
08:07:25 <TFK> But each time you have to evaluate only n/2 of the input list.
08:08:46 <TFK> That doesn't help, I suppose.
08:09:09 <dblhelix> boegel: it was the only position available, so I'm quite happy having got it
08:12:02 <thou> TFK: hmmm, i see your point; it is discarding a large portion of the work (i had to look at the qsort definition to see it)
08:12:46 <thou> TFK: still, it's better just to use a min function, no?
08:13:12 <TFK> Yes. While it does go through the entire list, only n/2 of it is passed on.
08:13:17 <TFK> Yes.
08:13:35 <TFK> It's a private, Python-related thing I have ;-)
08:20:39 <boegel> dblhelix: guess that kinda the some region as my work will be
08:20:58 <boegel> I have to analyse programs too to be able to predict their performance
08:22:22 <dblhelix> boegel: well, here the main point of attention will be type inference and type-error messages
08:24:37 <boegel> oh, okay
08:24:43 <boegel> no java programs then I guess :p
08:26:10 <dblhelix> boegel: hard to predict where it'll lead me, but it looks like I will be working on functional languages with advanced type systems mostly
08:26:38 <boegel> sounds nice
08:26:51 <boegel> maybe I'll see you on some meeting then, who knows :)
08:26:53 <dblhelix> yeah, I'm really looking forward to it
08:27:02 <dblhelix> yeah, that would be nice
08:29:09 <boegel> that's one of the reasons I want to do a Phd, meet interesting people
08:29:30 <boegel> and people who I can understand :) sometimes I think academic life is a bit too high for me
08:30:18 <dblhelix> boegel: i think it takes a little bit of getting used to
08:30:43 <boegel> probably
08:30:47 <boegel> I have to go now
08:30:51 <boegel> take another break :)
08:30:55 <boegel> ttyl
08:30:56 <dblhelix> boegel: I had the chance to see how research is done in utrecht for quite some time now, and i think i really like it
08:30:59 <dblhelix> bye, cu
08:37:06 <basti_> hi
08:37:13 <dblhelix> hi, basti_
08:51:36 <am02> Alright chaps, anyone know of a more efficent way to compute the inner product of a matrix than this:
08:51:38 <am02> fromIntegral(sum [((a!i * b!i)) | i<- [1..ra*ca]] )
08:52:29 <am02> the matrices I'm using are quite big and that gobbles up the stack
08:53:31 <basti_> why are people always trying to do numerics stuff in haskell? ;)
08:53:50 <am02> I have to....
08:54:09 <basti_> am02: do you need *all* of the resulting matrix or possibly just a bit.
08:54:44 <am02> well just the sum,
08:55:05 <am02> I suppose I could use an accumalating variable, w
08:55:05 <basti_> the sum over all of its entrys?
08:55:27 <am02> sum (a!i * b!i)
08:55:27 <basti_> that might make sense then
08:55:37 <basti_> uhm
08:56:05 <am02> the sum of elements in a multiplied by the corresponding element in b
08:56:37 <basti_> yes thats how you compute a matrix product.
08:57:14 <basti_> the scalar products of the vectors of the two matrices.
08:57:30 <basti_> and you just need one of these scalar products and your stack runs out?
08:58:06 <am02> yeah, well I have to increase its size
08:58:12 <am02> If I use an accumalating variable will it still gobble up the stack
08:58:25 <basti_> hmm thats a little hard to say.
08:58:25 <am02> due to the recursion?
08:58:36 <basti_> i do not think "sum" uses terrible amounts of stack
08:58:52 <am02> does it compute the whol list first though?
08:59:03 <basti_> @pl sum [1..100000]
08:59:04 <lambdabot> sum [1..100000]
08:59:11 <basti_> uh
08:59:13 <TheHunter> am02, you need to compile with -O for sum to be space efficient
08:59:14 <basti_> @plugs sum [1..100000]
08:59:22 <basti_> ahh.
08:59:24 <lambdabot> Stack overflow
08:59:24 <basti_> i didnt know that.
08:59:27 <basti_> hehe
08:59:28 <am02> ahh. very good
08:59:31 <basti_> qed.
08:59:41 <am02> cheers chaps
10:32:48 <basti_> what on earth is mfix good for?
10:32:51 <Lemmih> GHC 6.5 throws an exception on 'waitForProcess' *sigh*
10:33:44 <musasabi> basti_: for mdo.
10:33:54 <basti_> hm
10:34:25 <basti_> @info mdo
10:34:26 <lambdabot> Unknown command, try @listcommands.
10:34:29 <basti_> @docs mdo
10:34:31 <lambdabot> mdo not available
10:34:40 * Lemmih gives up on profiling support in hs-plugins.
10:34:41 <mflux_> @index mdo
10:34:41 <lambdabot> bzzt
10:34:54 <mflux_> lambdabot is not being very helpful now is he!
10:35:19 <basti_> http://haskell.org/hawiki/FixedPointCombinator
10:39:09 <basti_> this is not healthy.
10:46:26 <Cale> mdo is syntax, lambdabot doesn't look up syntax
10:50:02 <Cale> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
10:51:10 <Cale> http://www.cse.ogi.edu/PacSoft/projects/rmb/mdo.pdf
11:02:09 <musasabi> mdo is occasionally usefull.
11:02:26 <musasabi> very rarely, but when one needs it there are very few alternatives.
11:11:27 <Cale> I wonder how much breakage would actually occur if mdo simply replaced do.
11:11:51 <Cale> (where a bit of analysis would be done to check if mfix is really needed)
11:13:53 <Cale> There are a couple of incompatibilities, but they seem to occur only with uncommon code. (Reusing bound variables, polymorphic let inside the do block)
11:17:41 <basti_> hmm ahh i think i understand what mdo is.
11:31:30 <mflux_> hmm, has ghc-pkg changes between 6.2->6.4? hscurses fails to build (well, after actually building I understand) because ghc-pkg fails on reading the old hscurses.conf.in
11:31:44 <mflux_> it says 'ghc-pkg: Line 1: Invalid syntax (no colon after field name)'
11:32:08 <mflux_> the two first lines in the file are Package {\n name = "hscurses",\n
11:35:10 <mflux_> hm, it may be complaining about some other file
11:36:00 <autrijus> hey. so I've finally started working on the haskell workshop paper. Does http://autrijus.org/tmp/pugs-paper.txt look reasonable?
11:36:10 <mflux_> or not
11:36:12 <autrijus> <- had never written any academic paper before
11:39:49 <metaperl> section 6 looks delectable autrijus
11:40:51 <metaperl> what Perl 6 egos?? oh, those arent embedded languages
11:42:00 <Oejet> metaperl: Is delectable a common word?
11:42:25 <metaperl> i would say it has its place :)
11:42:30 <metaperl> it is not a rare word
11:42:33 <metaperl> by any means
11:42:50 <Oejet> Oh, that's delectable. :-P
11:43:11 <metaperl> delectable means delicious
11:43:20 <metaperl> but with a wicked little edge :)
11:43:26 <Oejet> Highly pleasing; delightful.
11:44:04 <metaperl> "delectable" is applied to food dishes 99% of the time
11:44:13 <metaperl> I used it here for dramatic effect
11:44:21 <Oejet> I see.  Nice.
11:47:37 <autrijus> I parsed "deletable"
11:47:40 <autrijus> :)
11:51:31 <mauke> autrijus: hah! 69 characters
11:53:03 <autrijus> congrats... I see you have 24 as well
11:53:30 <mauke> yes. my 24 char solution shares 12 chars with yours :-)
11:54:44 <autrijus> :)
11:55:37 <mauke> and my C solution is a one-liner now
11:57:07 <Igloo> What are you trying to do?
11:57:24 <mauke> http://spoj.sphere.pl/problems/KAMIL/
11:59:26 <Igloo> In perl or Haskell?
11:59:47 <Igloo> (for the 24 chars)
12:00:05 <autrijus> 24 is perl. 69 is haskell
12:12:54 <Igloo> 69 including any import statements necessary presumably?
12:14:42 <autrijus> yeah.
12:14:51 <autrijus> and exit code must be 0
12:15:02 <autrijus> and spaces/newline count as 1 char
12:15:32 <boegel> 24 in what ?
12:15:42 <autrijus> boegel: perl 5
12:15:54 <boegel> what about it ?
12:16:18 <autrijus> mm?
12:16:22 <boegel> hey bourbaki
12:16:38 <boegel> what did you guys pull of in 24 chars ?
12:16:54 <autrijus> boegel: http://spoj.sphere.pl/problems/KAMIL/
12:17:12 <Oejet> Paste, paste, paste,...!
12:19:50 <boegel> nice :)
12:19:55 <boegel> seems like fun
12:19:58 * boegel tries it in Java
12:19:58 <boegel> :p
12:22:41 <bourbaki> yikes the evil word
12:28:21 <boegel> bourbaki: I found a interesting link about L-systems, check at the bottom of the H3D page (the last one)
12:28:34 <boegel> apparently there has been a contest lately on L-systems
12:28:59 <bourbaki> ok
12:33:46 <boegel> also, I found an implementation in c++ which might help me understanding it
12:34:14 <boegel> I really want a decent implementation in Haskell, not just something that works
12:34:19 <boegel> I want to learn damned :)
12:35:40 <bourbaki> :)
12:35:55 <basti_> whats the problem about L-Systems?
12:36:05 <boegel> basti_: no problem yet
12:36:12 <boegel> but I'm looking for info on it
12:36:16 <basti_> basically its term expansion
12:36:30 <boegel> I think I'll try and implement it decently this week somewhere
12:36:43 <basti_> should be easy in haskell
12:36:48 <basti_> except for the "drawing stuff" part
12:36:49 <basti_> ;)
12:36:51 <boegel> I want a good implementation though... bourbaki mentioned the use of monads
12:37:02 <boegel> basti_: don't worry about that, we'll get there eventually :)
12:37:16 <basti_> hmm yes monads might help
12:38:57 <boegel> but that's where the learning part comes in :) I'm not familiair with creating my own monads, so I don't see why they might be handy
12:39:06 <boegel> but writing it might help :D
12:39:11 <lispy> so i have an "AST" and i'm having a very hard time transforming it
12:39:20 <basti_> hmm i see two obvious monads
12:39:35 <basti_> 1. abusing the list
12:39:40 <basti_> 2. creating a new one
12:40:07 <basti_> actually abusing the list would not be that much of an abuse i think
12:41:10 <boegel> basti_: what do you mean by 'abusing' ? using the list monad by it's full capacity ?
12:41:27 <boegel> or using it for stuff it's not intended for ?
12:41:32 <basti_> hmm one could argue that l-system terms are not lists
12:41:45 <basti_> and in fact, some are
12:41:58 <basti_> a tree representation might be better.
12:44:51 <boegel> that's maybe overdoing it
12:45:12 <boegel> they are meant to be lists, and are interpreted as trees later on (if you ask me)
12:45:34 <basti_> hmm right again.
12:45:36 <boegel> also, seeing them as trees won't help the performance
12:45:45 <basti_> not at all.
12:45:59 <boegel> so, seeing them as lists might be best
12:46:21 <basti_> as lists, you would have two exercises: 1. computing the nth iteration 2. transforming that to draw commands
12:46:29 <boegel> but, whu shouldn't I use [...] list then, in stead of the List monad ? those that have special operations ?
12:46:46 <basti_> (2 would be somewhat canonical in the tree case)
12:46:47 <boegel> basti_: the latter is for later on
12:47:08 <basti_> hmm
12:47:17 <boegel> basti_: hmm, okay, but still, the tree would have to be parsed to another datatype (probably C / C++)
12:47:18 <basti_> the monad notation saves you lots of concatMap ;)
12:47:28 <boegel> @index List
12:47:29 <lambdabot> bzzt
12:47:35 <basti_> why not use HopenGL to render them?
12:47:49 <boegel> can i see the 'contents' of the List monad with lambdabot ?
12:47:55 <basti_> uhm
12:47:57 * boegel doesn't have the slightest idea how List works
12:48:05 <basti_> well of course there is a bind, and a return ;)
12:48:13 <basti_> the bind is concatMap, and return is \a->[a]
12:48:35 <boegel> bind ? *err
12:48:39 <basti_> bind is >>=
12:48:43 <boegel> if I'm just being stupid, pls tell me
12:48:50 <basti_> that weird mondad thingy that noone knows ;)
12:48:52 <boegel> I don't know crap about monads :)
12:49:07 <boegel> say, I would want to use [1,3,5] in a List monad
12:49:08 <basti_> >>= is the glue for sequencing operations in a monad
12:49:10 <boegel> how would that work ?
12:49:15 <basti_> hmm maybe like that:
12:49:21 <basti_> (typing plugs command)
12:49:21 <boegel> basti_: something like . ?
12:49:22 <sorje> http://haskell.org/hawiki/MonadsAsContainers describes the list monad pretty well IIRC
12:50:01 <lispy> @eval [1..3] >>= id
12:50:03 <lambdabot> (line 1, column 4):
12:50:03 <lambdabot> unexpected "."
12:50:03 <lambdabot> expecting simple term
12:50:16 <bourbaki> how can i display an evironment variable in a *X system again?
12:50:18 <basti_> @plugs do {x<-[1::Int,3,5];return (x+1)}
12:50:29 <lambdabot> [2,4,6]
12:50:38 <lispy> @plugs [1..3] >>= id
12:50:40 <lambdabot> <Plugins.Eval>:1:
12:50:40 <lambdabot>   No instances for (Num [b], Enum [b])
12:50:40 <lambdabot>   arising from the literal `3'
12:50:52 <lispy> oh weird
12:50:56 <basti_> do {x<-[1::Int,3,5];[x,x+1]}
12:51:04 <basti_> lispy: coerce the type.
12:51:30 * basti_ .oÂ° ( now does that sound like sexual practices or what )
12:51:32 <lispy> [1..3] >>= show
12:51:35 <basti_> lambdabot: hi?
12:51:38 <basti_> oh
12:51:41 <lispy> @plugs [1..3] >>= show
12:51:42 <lambdabot> "123"
12:51:54 <autrijus> wagle: I win
12:51:58 <basti_> @plugs do {x<-[1::Int,3,5];[x,x+1]}
12:52:00 <lambdabot> [1,2,3,4,5,6]
12:52:34 <boegel> basti_: that's using the List monad ? list comprehensions?
12:52:37 <autrijus> wagle: like, totally. 47 chars in haskell!
12:52:50 <basti_> boegel: every line in a do expression is either a let, a "<-" (which is a hidden lambda & bind), or an expression of a value in the monad.
12:53:03 <basti_> boegel: its very similar to list comprehensions yes.
12:53:12 <basti_> monads give you some nasty tricks though.
12:53:15 <sorje> autrijus, I so want to see that one! ;-)
12:53:29 <autrijus> now translating it to 20 in perl
12:53:42 <boegel> basti_: you say <- is a hidden lambda and bind ? how's that ?
12:53:53 * boegel enjoys being taught about monads
12:54:08 <boegel> basti_: if I'm bothering you, please stop :)
12:54:17 <basti_> boegel: a <- b ... is transformed to "b =<< \a ->..."
12:54:38 <mauke> >>=?
12:54:44 <basti_> you aren't i just sometimes need time to type it up in a terse and understandeable way
12:54:47 <basti_> yes mauke sorry
12:54:59 <boegel> okay, I see
12:55:02 * basti_ gets confused all the time with these >> >>= <=< =<= etc. ;)
12:55:13 <boegel> so I've using this monad stuff all along without knowing :)
12:55:21 <boegel> as in the IO monad (of course) :)
12:55:21 <basti_> and =<< is taken from the monad instance definition
12:55:34 <lispy> >>= is just the flip of =<<
12:55:51 <boegel> I just taught <- was IO specific (take something and put it _in_ something else, hence the arrow)
12:55:57 <basti_> ah no
12:55:59 <basti_> its just a lambda
12:56:00 <boegel> @plugs flip =<<
12:56:01 <lambdabot> <Plugins.Eval>:1:
12:56:01 <lambdabot>   No instances for (Show ((b -> a -> b -> c) -> b -> a -> c),
12:56:01 <lambdabot>         Monad ((->) b))
12:56:01 <lambdabot>   arising from use of `show'
12:56:07 <lispy> show =<< [1..3]
12:56:13 <basti_> the magic is happening in the "bind" (=<<)
12:56:14 <lispy> @plugs show =<< [1..3]
12:56:16 <lambdabot> "123"
12:56:24 <lispy> @plugs [1..3] >>= show
12:56:25 <lambdabot> "123"
12:56:30 <boegel> heh :)
12:56:37 <boegel> @plugs show >> [1..3]
12:56:38 <lambdabot> Couldn't match `(->) a' against `[]'
12:56:42 <boegel> naughty boegel :)
12:56:46 <boegel> @plugs show >>= [1..3]
12:56:47 <lambdabot> Couldn't match `String -> a -> b' against `[t]'
12:57:00 <boegel> okay, I'm learning, w00 !
12:57:00 <basti_> then there's liftM et al.
12:57:03 <boegel> @seen shapr
12:57:04 <lambdabot> I saw shapr leaving #haskell 3 days, 4 hours, 4 minutes and 17
12:57:04 <lambdabot> seconds ago, and I have missed 7 seconds since then.
12:57:14 <lispy> think about it this way, you are piping the monad through the function, so you want the >> to point at the function
12:57:40 <lispy> so you type show =<< [1..4] for example
12:57:47 <mauke> @plugs [1..6] >>= \n -> if n `mod` 2 == 0 then return n else fail "error"
12:57:48 <boegel> makes sense
12:57:49 <lambdabot> [2,4,6]
12:58:01 <boegel> mauke: cool :)
12:58:10 <boegel> powerfull stuff
12:58:28 <basti_> "Maybe" is a nice monad as an example
12:58:51 <basti_> it evaluates things as long as some function results in "Nothing"
12:58:55 <boegel> @plugs "abaebaac" >>= \n -> if n == 'a' then return n else fail "error"
12:58:57 <lambdabot> "aaaa"
12:59:00 <boegel> w00 !
12:59:26 <boegel> cool stuff
12:59:41 * boegel thinks about a new thesis "Writing a ray tracer using monads" :D
12:59:45 <basti_> -g-
13:00:18 <basti_> liftM is cute too:
13:00:23 <basti_> @plugs do {x<-[1::Int,3,5];liftM (x+) [5]}
13:00:26 <lambdabot> [6,8,10]
13:00:31 <basti_> or even:
13:00:53 <basti_> or not.
13:00:55 <basti_> ;)
13:02:07 <basti_> a "monad" is not a lot, actually
13:02:24 <boegel> I hope I can wrap my head around it someday
13:03:26 <basti_> you can think of "do" as a nice way to write all the "cabling" stuff that always stays the same
13:03:37 <basti_> for example, concatMap in list processing codes.
13:03:51 <boegel> @type concatMap
13:03:58 <lambdabot> concatMap :: forall b a. (a -> [b]) -> [a] -> [b]
13:04:13 <basti_> thats an efficient synonym of concat.map
13:04:14 <dblhelix> concatMap == (==<)
13:04:27 <boegel> @type (==<)
13:04:29 <lambdabot> bzzt
13:04:33 <boegel> :)
13:04:37 <basti_> @plugs concatMap (\x->[x,x+1]) [1..3]
13:04:40 <lambdabot> [1,2,2,3,3,4]
13:04:51 <dblhelix> @type Monad.(==<)
13:04:53 <lambdabot> bzzt
13:05:01 <dblhelix> mmm :S
13:05:06 <boegel> cool, that will be very helpfull indeed with L-systems
13:05:13 <lispy> @type Monda.Control.(==<)
13:05:14 <lambdabot> bzzt
13:05:18 <lispy> @type Monad.Control.(==<)
13:05:19 <lambdabot> bzzt
13:05:26 <dblhelix> @type Monad.(<==)
13:05:27 <lispy> bleh who knows :)
13:05:28 <Cale> @plugs [1..3] >>= (\x -> [x,x+1])
13:05:28 <lambdabot> bzzt
13:05:30 <lambdabot> [1,2,2,3,3,4]
13:05:49 <Cale> @plugs (\x -> [x,x+1]) =<< [1,2,3]
13:05:51 <lambdabot> [1,2,2,3,3,4]
13:06:06 <Cale> =<< is concatMap for the list monad
13:06:07 <basti_> boegel: do you see that >>= (or a line break in do) actually is just a concatMap in disguise?
13:06:10 <bourbaki> nighto
13:06:14 <basti_> uhm or =<<
13:06:15 <dblhelix> duh :)
13:06:19 * basti_ dsylxecic
13:06:19 <xerox> @type (<-)
13:06:21 <lambdabot> bzzt
13:06:21 <boegel> and you can write this using <== too ? ?
13:06:24 <boegel> g'night bourbaki
13:06:34 * basti_ doesnt know about <==
13:06:38 <boegel> basti_: I do now
13:06:56 <boegel> or ==< even :)
13:06:57 <dblhelix> nope: it's =<<
13:07:06 <xerox> @index (==<)
13:07:08 <lambdabot> bzzt
13:07:09 <xerox> :-)
13:07:15 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
13:07:16 <dblhelix> it's been a long weekend
13:07:19 <boegel> because basti_ said concapMat == (==<)
13:07:20 <basti_> @plugs 1 <= 3
13:07:22 <lambdabot> True
13:07:30 <dblhelix> @type (=<<)
13:07:32 <lambdabot> (=<<) :: forall b (m :: * -> *) a.
13:07:32 <lambdabot>    (Monad m) =>
13:07:32 <lambdabot>    (a -> m b) -> m a -> m b
13:07:36 <dblhelix> ah
13:07:44 <Cale> That article is how I like to think about monads.
13:07:56 <boegel> Cale: thanks, I'll read it tomorrow or so
13:08:00 <dblhelix> well, subst [] for m: (a -> [b]) -> [a] -> [b]
13:08:02 * boegel phones a friend
13:08:03 <xerox> @type (=<<) :: (a -> [b]) -> [a] -> [b]
13:08:05 <lambdabot> (=<<) :: (a -> [b]) -> [a] -> [b] :: forall a b.
13:08:05 <lambdabot>              (a -> [b]) -> [a] -> [b]
13:09:02 <basti_> the stupid thing about the container metaphor is that it can be confusing especially in the IO monad sense
13:09:30 <boegel> are there any other ways to look at monads ?
13:09:43 <basti_> hmm i like the type notation...
13:09:49 <basti_> its not that bad once you got it
13:10:10 * dblhelix likes do notation for the Maybe monad
13:10:12 <basti_> or you think of IO happening in a box or something
13:10:30 <lispy> basti_: that's the way i think of IO
13:10:35 * dblhelix always thinks of IO values as executable imperative programs
13:10:48 <lispy> basti_: as boxed up computations that depend on an "environment"
13:10:57 <basti_> yes but whats the box then?
13:11:13 <basti_> is it the environment? mmmh.
13:11:27 <basti_> it's a "marker" that there is some environment
13:12:01 * dblhelix 's gf urges him to abandon his musings about monads
13:12:07 <basti_> heheh
13:12:12 <Cale> It's like there's some machine which can spit out a value (and cause some side effects), the value is what you think of as being contained.
13:12:14 * basti_ has urges towards his gf
13:12:27 <dblhelix> see you guys tomorrow :)
13:12:31 <basti_> cu dbl
13:12:34 <dblhelix> bye!
13:12:39 <wagle> augh!  mauke beats even my improved kamil!
13:12:50 * wagle gnashes teeth dramatically
13:12:52 <basti_> [x] you guys are sick
13:13:06 <autrijus> I think I'll stay at 47 for haskell :)
13:13:18 <wagle> autrijus: does it even look at the inputs?
13:13:23 <autrijus> wagle: it doesn't.
13:13:30 <wagle> hehe
13:13:40 <autrijus> I said as much yesterday :)
13:13:46 <autrijus> took me 20 minutes to hack to thru.
13:15:40 <wagle> algorithm was something like if answer == predicted then print answer else bottom?
13:16:03 <autrijus> nope.
13:16:05 <autrijus> that will take far too long.
13:16:12 <autrijus> I was a bit more clever :)
13:17:47 <wagle> sleep (5) instead of bottom, and do them all
13:18:44 <autrijus> sleep also won't do. :)
13:18:50 <autrijus> but yeah, something like that.
13:19:08 <wagle> spin cpu for 5, i meant
13:19:17 <autrijus> yeah. only it has to be 0.1
13:19:22 <autrijus> otherwise timeouts
13:19:50 <wagle> hm..  prisoners dilemma
13:20:09 <autrijus> ruby gives a disappointing 44.
13:20:13 * autrijus searches for better language
13:21:09 <wagle> putstr "3\n4\n..." was 40+ chars long?
13:21:18 <autrijus> sure
13:21:26 <autrijus> numeric encoding itself is 25
13:21:32 <autrijus> already disqualified for 1st place
13:21:36 <autrijus> so need to use string encoding
13:21:39 <autrijus> which is 12
13:21:56 <autrijus> then I have 11 chars more to run 2**ord and print
13:22:00 <autrijus> not impossible
13:22:04 <autrijus> but needs the right language
13:22:36 <autrijus> and sadly I can't hexpack them into 5 bytes
13:22:41 <autrijus> because some are >15
13:23:18 * autrijus ponders utf8
13:23:56 <xerox> What are you talking about?
13:24:09 <autrijus> xerox: how to solve http://spoj.sphere.pl/ranks/KAMIL/ in less than 24 characters
13:24:31 <autrijus> xerox: I've got the result set... only needs the encoding
13:25:16 <lispy> language TEXT?
13:25:25 <autrijus> lispy: yeah, I did that, 42
13:25:51 <lispy> what is text?
13:25:58 <autrijus> lispy: pasting the answer.
13:26:07 <autrijus> ignoring the input
13:26:38 <wagle> i got my noncheating haskell down to 70..
13:26:58 <wagle> but mauke got 69..
13:27:04 <wagle> i think you had 67?
13:27:10 <autrijus> no, I'm at 69 too
13:27:28 <autrijus> ideally I want something like
13:27:29 <autrijus> "xxxxxxxxxx">>2**>>out
13:27:41 <autrijus> where x is ascii encoding of the answers
13:27:55 <xerox> Haskell's >> ?
13:27:55 <autrijus> havn't found a language that does this efficiently
13:28:00 <mauke> wagle: does your solution use getLine?
13:28:02 <autrijus> no, something else's
13:28:11 <wagle> mauke: no
13:28:26 <mauke> cool, another 70 char solution
13:28:30 <mauke> I wonder how you did it
13:28:52 <wagle> no **
13:29:12 <mauke> what is **?
13:29:13 <wagle> (no exponentiation)
13:29:18 <mauke> oh
13:29:20 <wagle> i meant ^
13:29:42 <xerox> Can one see the submissions on that site?
13:30:01 <autrijus> xerox: not usually.
13:30:11 <xerox> Hmpf.
13:30:16 <autrijus> if you want the result set and #haskell doesn't object though, I can paste it here :)
13:31:24 <autrijus> it's quite ironic that even though I have the result set, a perl5 program still offers better domain compression
13:31:46 <wagle> i need a single monad with IO, [], and Maybe
13:33:02 * wagle grumps about the length of "getContents", etc
13:33:17 <xerox> You do not, in normal programming :-)
13:33:56 <wagle> whats normal programming?
13:34:24 <xerox> I mean, everyday programming - not short-programs-contests.
13:35:32 <wagle> this isnt everyday programming?
13:36:34 <xerox> If it is you either are lucky or have much free time :-)
13:36:35 <wagle> i saw it as an exercise in finding as many ways to do something as possible
13:37:50 <wagle> and really understanding the problem
13:38:16 <wagle> and seeing what really needs to be done
13:39:00 <wagle> i also liked the metric, since i want "replace equals with better" instead of a more blind "replace equals with equals"
13:39:53 <wagle> this was the most interesting (and simple) terrain for that sort of reasoning..  even if "code length" is a bogus measure of "better"
13:40:27 <mauke> ok, I replaced .(2^).length with .product.map(\_->2) but it's longer :(
13:40:27 <xerox> Anyway, goodnight.
13:41:23 <wagle> man, i really wanted "prod" instead of "product"..  8)
13:42:08 <wagle> i used a list comprehension instead of filter
13:43:14 <mauke> isn't that longer?
13:43:19 <lispy> if you have the data set i wonder if you could write a very short function that given the previous number does a simple computation to get the next number
13:44:05 <wagle> depends on your comprehension..  note that your current solution is one shorter than mine, though
13:44:28 <mauke> I'd really like to see your version
13:45:46 <wagle> i'm still working on pruning it..
13:46:23 <Cale> what are you computing?
13:46:49 <wagle> http://spoj.sphere.pl/problems/KAMIL/
13:55:43 <boegel> hey Itko
13:55:49 <boegel> vian :p
14:19:14 * boegel goes to bed
14:19:21 <boegel> wish me luck with my final tomorrow !
14:20:01 <boegel> mmmkay :|
14:25:31 <boegel> thank you guys for the support :s
14:26:27 <basti_> good luck!
14:26:28 <basti_> ;)
14:27:26 <boegel> bye
15:42:27 <SamB> @docs Language.Haskell.TH.Syntax
15:42:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language.Haskell.TH.Syntax.html
15:59:53 --- topic: set to 'http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine",ICFP Contest! http://icfpc.plt-scheme.org/' by wagle
16:03:29 <lispy> is ICFP already here?
16:03:48 <lispy> ah, okay soon, but not yet
16:04:08 <edwinb> As usual on a weekend when I can't play... Bah...
16:04:09 <wagle> just now got the email announce
16:05:17 * SamB wishes TH did not use the original module name of a thing to qualify it...
17:46:57 <SamB> something gives me the idea that HsSyn was written a long time ago, or by a newbie, or something like that...
17:47:25 <SamB> it uses list-comprehension terminology for HsStmt
17:52:37 <stepcut> @isfine shapr
17:52:38 <lambdabot> (line 1, column 1):
17:52:38 <lambdabot> unexpected end of input
17:52:38 <lambdabot> expecting white space or simple term
17:53:02 <stepcut> um...
17:55:35 <dons> spell checking.
17:55:53 <dons> @isfinexx
17:55:54 <lambdabot> Unknown command, try @listcommands.
17:55:56 <dons> @isfinex
17:55:57 <lambdabot> Unknown command, try @listcommands.
17:56:04 <dons> @isfixx
17:56:05 <lambdabot> Unknown command, try @listcommands.
17:56:07 <dons> @isfix
17:56:08 <lambdabot> Unknown command, try @listcommands.
17:56:12 <dons> @isfi
17:56:13 <lambdabot> Unknown command, try @listcommands.
17:56:14 <dons> doh
17:56:22 <kaol> @yow
17:56:24 <lambdabot> Actually, what I'd like is a little toy spaceship!!
17:56:56 <reffie> @ghc
17:56:58 <lambdabot>  On Alpha, I can only handle 4 non-floating-point arguments to
17:56:58 <lambdabot> foreign export dynamic
18:06:20 <dons> @seen Lemmih
18:06:22 <lambdabot> Lemmih is in #haskell. Last spoke 7 hours, 31 minutes and 41 seconds
18:06:22 <lambdabot> ago.
18:07:27 <stepcut> @seen aheller
18:07:29 <lambdabot> aheller is in #haskell. I don't know when aheller last spoke.
18:07:32 <stepcut> heh
18:08:30 <analpear> hello. how many bits are there in a haskell integer?
18:08:44 <autrijus> a haskell Integer has infinite precision.
18:08:46 <stepcut> analpear: Int or Integer?
18:08:49 <dons> an Integer? or andD Int
18:09:05 <analpear> Int
18:09:06 <dons> either as many as you need, or > 29
18:09:09 <analpear> and what's the difference? :/
18:09:28 <analpear> andf Integer?
18:10:01 <dons> @plugs 0xffffffff :: Int
18:10:03 <lambdabot> -1
18:10:05 <dons> @plugs 0xffffffff :: Integer
18:10:06 <lambdabot> 4294967295
18:10:28 <analpear> uh what
18:10:29 <autrijus> hey dons. I'm starting to learn latex for that hw2005 paper. do you have the latex source of "Plugging Haskell In" somewhere that I can learn from?
18:10:36 <stepcut> @plugs (12345678901234566787238917983124 ::  Integer) + 1
18:10:38 <lambdabot> 12345678901234566787238917983125
18:10:44 * autrijus dreads the idea of writing the entire thing in Word
18:10:46 <dons> @plugs 0xffffffffffffffffffffffffffffffffffffffff :: Integer
18:10:48 <lambdabot> 1461501637330902918203684832716283019655932542975
18:10:58 <analpear> dons what are you calculating
18:11:11 <dons> autrijus, yep. got an email address?
18:11:19 <autrijus> dons: autrijus at autrijus dot org. danke!
18:11:27 <autrijus> analpear: he's demonstrating that Integer is of arbitary precision
18:11:39 <analpear> oh
18:12:11 <dons> autrijus, note that the latex class used this year is new
18:12:27 * SamB does not understand how people are actually capable of using Word *at all*
18:13:19 <autrijus> dons: is it a simple matter of changing a class declaration?
18:13:25 <autrijus> <- totally latex noob
18:13:48 <dons> yep, pretty much. a couple of macros changed.
18:16:03 <autrijus> k. I'll read up.
18:18:21 <dons> sent.
18:19:14 * autrijus praises the helpfulness of #haskell in general and dons in particular
18:21:22 <foxy> dons: I'm still chasing that eros bug, It took all yesterday (12hrs) to compile and install wx{Widgets,Haskell}, and now I've found a cygwin bug, I'll get there eventually
18:21:59 <dons> 12hrs! slow machine?
18:22:20 <dons> or just configuration details
18:22:47 <foxy> slow machine
18:24:24 <dons> maybe installing from a binary would be better? though I guess it's built now ;)
18:24:40 <dons> you found a cygwin bug in wxHaskell?
18:25:53 <foxy> hi files weren't compatible (I have ghc 6.4.1), I found a cygwin bug in cygwin
18:26:25 <dons> oh!
18:26:44 <dons> this is a hint to use a different OS ;)
18:26:57 <foxy> agreed :P
18:27:03 <dons> as if that kernel trap thingo a while ago wasn't bad enough.
18:28:02 <autrijus> ghc 6.4.1? is it released?
18:28:23 <dons> nope, just tagged.
18:28:28 <autrijus> ooh.
18:28:37 <autrijus> does it usually mean a release is imminent?
18:29:19 <dons> not sure if it is really close. but probably in a  couple of weeks. then again, simon may surprise us all.
18:29:26 <autrijus> yay.
18:29:47 * autrijus is tired of a growing Pugs README with paragraphs starting with "Until 6.4.1 is released, use this workaround..."
18:37:09 <autrijus> is it worth using lambdaTex to format source code snippets, or are there other formatters?
18:38:23 <autrijus> ah, \lstset.
18:39:31 * autrijus wonders what is a Schlactfeld.
18:40:02 <dons> @babel de en Schlactfeld
18:40:04 <mauke> what context?
18:40:04 <lambdabot>  Schlactfeld
18:40:12 <mauke> "Schlachtfeld" is battle field
18:40:14 <dons> stupid bot.
18:40:28 <dons> we were playing with some german dictionary plugins to lambdabot when writing the paper ;)
18:40:38 <autrijus> I see :)
18:41:30 <autrijus> latex looks like sanity.
18:42:11 <dons> sometimes.. when people start programming in it, then there's trouble
18:42:51 <autrijus> is it like programming a web server in postscript?
18:43:52 <dons> yes!
18:44:42 <autrijus> ah. so it's just borderline insanity, unlike (say) universal turing machine in game of life.
19:08:04 * SamB wants Text.PrettyPrint.WadlerLeijen
19:09:45 <metaperl> I was just reading "Adventures in Financial Engineering" and noted the description of tree shapes using ordinary Haskell functions... is there a library for HTML/XML description like this? which verifies and/or generates HTML/XML
19:10:11 <SamB> tree shapes?
19:10:19 <metaperl> well HTML has a tree shape
19:10:28 <metaperl> and I was wondering if there were some DSL for this in Haskell...
19:10:45 <SamB> hmm, I don't know if any of the XML combinator libraries do that or not ;-)
19:11:06 <metaperl> how many are there? HaXML and 2 others I believe
19:11:14 <SamB> I think so too
19:11:29 <SamB> there is one called HXT (Haskell XML Toolkit)
19:11:34 <metaperl> and there are some sort of copyright issues with some of those libraries. I think Lemmih was having some sort of problem with that
19:11:38 <SamB> or something like that...
19:11:49 <SamB> copyright issues, really?
19:13:18 <metaperl> yeah, he was having to opt for a different one... I'll go check it out...
19:13:28 <SamB> huh
19:13:44 <metaperl> http://www.cs.york.ac.uk/fp/HaXml/#related
19:13:49 <metaperl> lists related technology
19:13:53 * metaperl checks on copyright issues
19:14:35 <SamB> speaking of copyrights, anyone know what the license on PPrint is?
19:14:44 <stepcut> my favorite is the Haskell XML Toolkit -- it supports DTDs and Unicode
19:15:25 <stepcut> and support of IO and state when doing tree walking operations
19:16:50 <stepcut> HaXml recently switched from BSD to GPL i think...
19:17:06 <reffie> stepcut what why
19:17:21 <SamB> nasty!
19:17:30 <reffie> that's crazy
19:17:35 <SamB> nasty incompatible GPL!
19:17:40 <SamB> did someone fork it?
19:18:13 <reffie> why do people even use the GPL
19:18:48 <SamB> because they think microsoft's dislike for it is purely evil, I guess...
19:19:10 <metaperl> The library is Free and Open Source Software, i.e., the bits we wrote are copyright to us, but freely licensed for your use, modification, and re-distribution, provided you don't restrict anyone else's use of it. The HaXml library is distributed under the GNU Lesser General Public Licence (LGPL) - see file LICENCE-LGPL for more details. We allow one special exception to the LGPL - see COPYRIGHT. T
19:19:25 <autrijus> LGPL sounds fine.
19:19:36 <SamB> oh, LGPL ought to be okay, only it is SOOO confusing.
19:20:04 * autrijus likes SQLite3's copyright policy.
19:20:12 <reffie> why not use BSD
19:20:21 <metaperl> is there a pragmatic HTML parser for Haskell? Or do they all expect well-formed XML? Yes sqlist is pure public domain I believe
19:20:55 <autrijus> metaperl: HXmlToolbox.hparser
19:22:07 <[TWiSTED]> hey all
19:22:35 <metaperl> I see, thanks
19:22:38 <metaperl> Hi [TWiSTED]
19:23:32 * metaperl is jammin Dancing Fool by the Butthole Surfers
19:24:04 <SamB> so, about PPrint!
19:24:11 <SamB> what license? or must email daan?
19:24:33 <[TWiSTED]> i got a function which inputs a string and takes the first occurance of an integer, and multiply that number by the next occuring integers and store it in a list of tuples eg. parseReactant "12Hi2Hey3Ahoy4" = [("Hi",24) , ("Hey",36) , ("Ahoy",48)]
19:25:27 <SamB> what use is such a function?
19:25:33 <autrijus> homework?
19:26:26 <[TWiSTED]> and ive already got a function multiplyCounts which takes an integer and a list of tuples and multiplies the 2nd element of each tuple by the integer eg. multiplyCounts 2 [("hi",2) , ("hey", 5)] -> [("hi",4),("hey",10)]
19:26:35 <[TWiSTED]> somewhat yes
19:27:19 <[TWiSTED]> this is what ive got so far
19:27:20 <[TWiSTED]> parseReactant [] = []
19:27:20 <[TWiSTED]> parseReactant s = (i', rest')
19:27:20 <[TWiSTED]>                       where
19:27:20 <[TWiSTED]>                          str = takeWhile (isDigit) s
19:27:20 <[TWiSTED]>                          (i', rest') = multiplyCounts str s
19:27:22 <kaol> I would consider myself lucky if I were in a place that actually teached Haskell instead of Java as they do here.
19:32:40 <kaol> [TWiSTED]: you might want to use span instead of takeWhile. and you probably don't want to pass s to multiplycounts and that str should be (read str) instead (don't you get a type error for doing that anyway?)
19:32:40 <lispy> kaol: they teach java at my school to the undergrads, them re-educate the grads with haskell ;)
19:33:01 <kaol> no such luck at my university :-(
19:33:12 <[TWiSTED]> yea kaol ive changed it abit
19:33:25 <[TWiSTED]> parseReactant s = multiplyCounts (read str) (parseFormula s)
19:33:26 <[TWiSTED]>                       where
19:33:26 <[TWiSTED]>                          str = takeWhile (isDigit) s
19:33:32 <[TWiSTED]> it complies
19:33:36 <[TWiSTED]> but what i get
19:34:17 <SamB> oh, its supposed to parse psuedochemical formulae?
19:34:25 <[TWiSTED]> yeh
19:34:41 <[TWiSTED]> parseReactant "2hi4hey5" -> [("",4) , ("hey",10) , ("hi"8)]
19:35:14 <kaol> <kaol> [TWiSTED]: you might want to use span instead of takeWhile.
19:35:29 <SamB> and what is the trouble?
19:35:40 <[TWiSTED]> ok
19:35:45 <lispy> first tuple should be ("hi",4)
19:35:49 <lispy> not ("",4)
19:35:57 <[TWiSTED]> yea
19:36:03 <SamB> oh
19:36:11 <lispy> and actually, there is an extra tugle
19:36:16 <lispy> er tuple
19:36:26 <lispy> i think my fingers are dyslexit
19:36:29 <lispy> gah
19:36:54 <[TWiSTED]> and dw parseFormula organises the tuples in alphabetical order so tahts why its hey before hi
19:37:07 <lispy> ah
19:39:52 <lispy> you realize that takeWhile does not modify s right?
19:40:07 <[TWiSTED]> yea
19:40:14 <[TWiSTED]> that just gets the first integer
19:40:14 <lispy> so when you call (parseFormula s), it's the same s that was given to the function
19:40:31 <[TWiSTED]> o ok
19:40:46 <[TWiSTED]> so like maybe
19:41:17 <[TWiSTED]> (parseFormula (dropWhile (isDigit) s)
19:41:21 <[TWiSTED]> (parseFormula (dropWhile (isDigit) s))
19:41:49 <lispy> or break....
19:41:59 <lispy> @get-definition span
19:42:00 <lambdabot> span = \p l.if null l then Pair [] [] else pair (\ys zs.if p (head l)
19:42:00 <lambdabot> then Pair (head l : ys) zs else Pair [] l) (span p (tail l))
19:42:11 <lispy> @type span
19:42:17 <lambdabot> span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
19:42:33 <lispy> span isDigit "123aoeu123"
19:42:41 <lispy> @plugs span isDigit "123aoeu123"
19:42:42 <lambdabot> ("123","aoeu123")
19:43:09 <lispy> maybe kaol has been right all along :)
19:43:14 <[TWiSTED]> parseReactant s = multiplyCounts (read str) (parseFormula (dropWhile (isDigit) s))
19:43:14 <[TWiSTED]>                        where
19:43:14 <[TWiSTED]>                           str = takeWhile (isDigit) s
19:43:18 <[TWiSTED]> that outputs fine for me
19:43:43 <[TWiSTED]> yea i could use span
19:44:23 <lispy> parseReactant s = multiplyCounts (read n) (parseFormula rest)  where (n, rest) = span isDigit s
19:44:44 <SamB> where should I ask about the license for PPrint?
19:45:03 <SamB> oh wait, it came in a zipfile, maybe I should look in the directory ;-)
19:45:07 <lispy> SamB: if i knew the answer i'd tell you :)
19:45:39 <SamB> hmm, that doesn't seem to help
19:45:48 <lispy> [TWiSTED]: the nice thing about the span solution is that it is less redundant.  So if you need to change it later, it will be easier
19:45:54 <SamB> okay, I'm thinking of mailing haskell-list and daan
19:46:28 <[TWiSTED]> yea that makes it less sloppy aswell. thanks lispy and kaol
19:47:01 <lispy> [TWiSTED]: np
19:48:10 <lispy> i have this DSL for procmail.  I want to be able to express rules where you take a part of the matching regexp and use it later.  But a nice syntax escapes me
19:48:41 <lispy> somethnig like this works for doing the first match LookFor "someprefix regexp" Remember ".*"
19:48:53 <lispy> but in procmail you can then refine your match
19:50:01 <lispy> forexample, you could put "* MATCH ?? ()\/[^@]+" on the next line to remove everything after (and including) the @ in an email addr
19:51:04 <lispy> so i need something like LookFor "someprefix regexp" Remember ".*" as "MATCH"  then later to be able to say Refine "MATCH" LookFor "()" Remember "[^@]+"
19:51:28 <lispy> and someway to to be able to use MATCH in expressions
19:51:50 <lispy> to put something in a folder i can use placeIn (Mailbox "nameofmailbox")
19:52:25 <lispy> so i need something like placeIn (Mailbox RecallMatch)
19:52:28 <[TWiSTED]> is there a function that splits a string into a list of strings everytime a certain character occurs?
19:52:35 <blackdog> lispy: this is that horrible time of the day when no-one's awake....
19:52:51 <lispy> blackdog: ah, it's evening in my timezone :)
19:53:07 <lispy> [TWiSTED]: i'm sure there is
19:53:22 <[TWiSTED]> ye ill try checkin it out
19:53:33 <blackdog> twisted: check out the implementation of 'words' or 'lines' in the prelude
19:53:41 <[TWiSTED]> ok thx
19:53:44 <SamB> what time when no-one's awake?
19:53:57 <blackdog> it's a bit annoying, i think they both call 'span' repeatedly. ought to be factored out.
19:54:27 <[TWiSTED]> o true
19:54:45 <blackdog> lispy: it's about lunchtime here. i don't know what time it is in EU & US-land, but nobody ever talks at lunch... :)
19:55:04 <[TWiSTED]> ye 10:56 am here
19:55:39 <kaol> EU is about to wake up. US people (the sane ones at least) should be asleep.
19:56:00 <blackdog> i'm askingquestions on #plone and #archetypes, and i can never tell whether people just hate me or are asleep... maybe my questions are just cosmically stupid.
19:56:04 <lispy> i'm in US and it's about 8pm here
19:56:16 <kaol> oh, forgot that US is that wide. :-)
19:56:42 <metaperl> lispy: you must be on the west coast like me
19:56:48 <lispy> yup, yup
19:56:54 <lispy> Oregoooon
19:56:58 <metaperl> lispy: westlake, village , CA
19:57:07 <metaperl> lispy: you dont work for Galois d oyou?
19:57:14 <lispy> no, i'm a student
19:57:19 <metaperl> oh I see
19:57:39 <lispy> working on my final project for a Haskell class :)
19:57:47 <metaperl> good luck
19:57:48 <lamer11174175538> its 3:36am here in England,, nobody's gonna be waking for a while
19:58:00 <lispy> metaperl: thanks
19:58:03 <lamer11174175538> I haven't gone to sleep yet!
19:58:28 <lispy> i can express most of the email filtering rules that i want using my dsl, but there are a few that still don't work
19:59:03 <lispy> when we take classes they put us on a mail list like class-csXXX@eecs.oregonstate.edu
19:59:27 <lispy> and i want to have a rule that takes the csXXX part and filters the mail into a folder by that name
20:01:51 <lispy> when (refineMatch (to_ "class-\/cs[0-9]+@") "()" "[^@]+") (placeIn "$MATCH")
20:02:04 <lispy> but i don't really like that
20:02:15 <lispy> it's just as ugly as procmail
20:04:40 <metaperl> they should use nntp and you just subscribe
20:04:56 <metaperl> but usenet is higher tech than email I guess
20:06:40 <lispy> teachers use it for announcements, so i dont' think you could really get people to check a news server often enough
20:07:07 <lispy> some students would, but i bet most don't even know what a news server is
20:16:48 <lispy> ah, i could use (\/) as an operator to combine conditions
20:17:28 <lispy> (to "class-") \/ "[^@]+"
20:17:50 <lispy> (to "class-") \/ (remember "[^@]+")
20:39:25 <mugwump> Does ghc come with a built-in ELF loader?
20:39:39 <mugwump> Loading object (dynamic) pthread ... failed.
20:39:39 <mugwump> Dynamic linker error message was:
20:39:39 <mugwump>    /usr/lib/libpthread.so: invalid ELF header
20:39:50 <mugwump> file /usr/lib/libpthread.so
20:39:51 <mugwump> /usr/lib/libpthread.so: ASCII C program text
20:40:21 <mugwump> that file claims to be a GNU ld script
20:41:24 <Khisanth> that is what I got
20:41:30 <dons> sort of, mugwump.
20:41:40 <dons> you can use ghci to dynamically load elf files.
20:41:56 <dons> or you can use hs-plugins to load objects into haskell apps
20:42:24 <dons> elf or otherwise (macho and whatever it is on windows also works)
20:42:34 <mugwump> yes, of course.. but the question is more a matter of whether it tries to do the mechanics of the ELF loading itself or just call the routines linked from /lib/ld.so
20:42:46 <dons> does both.
20:43:22 <dons> the stuff we get back from dlopen has to be relocated manually - so there's most of a linker provided in the ghc rts
20:44:10 <mugwump> ok, so when some system integrator delivers a .so which looks like this:
20:44:30 <mugwump> actually, better nopaste it
20:45:30 <mugwump> http://www.rafb.net/paste/results/dyAInQ62.html
20:46:09 <dons> what are you trying to do?
20:46:18 <dons> if you use the threaded rts, you get pthreads anyway.
20:46:59 <mugwump> this is when running the simple command:
20:47:01 <mugwump> /usr/bin/ghc --interactive -H0 -L. -Lsrc -Lsrc/syck -Lsrc/pcre -I. -Isrc -Isrc/pcre -Isrc/syck -i. -isrc -isrc/pcre -isrc/syck -static  -Wall  -fno-warn-name-shadowing  -isrc/perl5 -Isrc/perl5 -D_REENTRANT -D_GNU_SOURCE -DTHREADS_HAVE_PIDS -DDEBIAN -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -I/usr/lib/perl/5.8/CORE -L/usr/local/lib /usr/lib/perl/5.8/auto/DynaLoader/DynaLoader.a -L/usr/lib/perl/5.8/CORE -lperl -ldl -lm -l
20:47:15 <mugwump> :)
20:47:24 <mugwump> Sorry, *really* should have nopasted that
20:47:38 <metaperl> no one freaks out about that in #haskell though mugwump
20:47:53 <lispy> retaliate!
20:47:54 <lispy> @moo
20:47:55 <lambdabot>           .
20:47:55 <lambdabot>  
20:47:55 <lambdabot>  
20:47:55 <lambdabot>  
20:47:55 <lambdabot> Cow at 10,000 meters.
20:48:06 <dons> oh. you're linking against perl. fun :)
20:48:14 <Khisanth> rather poor retaliation
20:48:19 <dons> in ghci of all things.
20:48:25 <dons> double fun.
20:49:22 <foxy> dons: I'm migrating to mingw instead of cygwin, hopefully I shall have better results! :s
20:49:38 <mugwump> this is just `make ghci' from current head pugs
20:49:42 <dons> I've seen a post about this linker script-pretending to be a .so- problem on the mailing lists last year sometime, mugwump
20:49:58 <dons> foxy, you think mingw will be easier?
20:50:21 <dons> hmm. so conal must be using a different windows/cygwin
20:50:24 <foxy> dons: It's what ghc uses and doesn't link against a cygwin.dll
20:50:35 <dons> sounds reasonable.
20:51:06 <dons> @seen blackdog
20:51:07 <lambdabot> blackdog is in #haskell. Last spoke 55 minutes and 6 seconds ago.
20:53:26 <foxy> dons: what was Conal's error message, do you know? (He probably has a more recent windows version than me)
20:54:03 <dons> yep. i'll forward you the transcript. basically a segfault as soon as he tried a certain gui option
20:54:15 <dons> half-way through a symbol lookup
20:56:31 <foxy> I have to recompile the wx suite again - it was linked against cygwin, sigh
20:57:00 <dons> oh man.
21:00:36 <SamB> are there any frameworks for pretty-printing beyond the little combinator libraries?
21:01:30 <dons> litte? what about tearing out ghc's optimised version of Text.PrettyPprint?
21:01:48 <dons> that works for the *huge* amount of ppr that ghc needs to do.
21:01:59 <dons> i.e. everything's a Doc inside ghc
21:02:09 <dons> let me find a ref.
21:02:10 <SamB> I'm not talking about performance here
21:02:29 <dons> what's the problem you're having?
21:02:40 <dons> license? or coverage?
21:03:12 <dons> $fptools/ghc/compiler/utils/Pretty.lhs
21:03:15 <SamB> its slightly better than if you took parsec and only used the .Prim module ;-)
21:04:24 <SamB> anyway, I want synthesize Haskell... and Text.PrettyPrint.HughesPJ doesn't seem to do a very good job of that...
21:04:57 <dons> it's untyped.
21:05:07 <SamB> hmm?
21:05:21 <dons> you're saying you want to construct haskell expressoins programmatically?
21:05:35 <SamB> yeah
21:06:03 <dons> then either (a) use TH, or (b) don't use TH, but extend/copy the Syntax type
21:06:12 <dons> you're doing code generation
21:06:28 <dons> pretty printing is like doing TH where everything is a String
21:06:49 <SamB> well, I have to get the code printed too
21:07:21 <SamB> and I want it to have reasonable line-length...
21:07:23 <dons> yeah, that's the final step. construct your Haskell abs syntax value, then just print it using a ppr
21:07:37 <SamB> it doesn't seem to be that simple
21:07:42 <dons> but don't try and construct the code while trying to print it too
21:08:15 <dons> this is the idiomatic way to do code generation in Haskell, anyway. it'd say it applies generally
21:08:56 <dons> you need a data type for the language you're generating, and you need a Pretty instance for that language
21:09:13 <SamB> well, yes, I figured out that trying to generate the code in the pretty printer leads to really nasty code already ;-)
21:09:52 <dons> yep. because it's mixing two distinct phases.
21:10:12 <dons> so you'd write: gen :: Perl -> Haskell, say. and ppr :: Haskell -> Doc
21:11:11 <SamB> that is VERY oversimplified
21:11:38 <dons> it's how ghc works in lots of places
21:11:57 <SamB> how can you have a datatype called "Haskell"?
21:12:00 <dons> so I don't think it really is simplified. i've written compilers with functions like this
21:12:07 <SamB> there are so many contexts
21:12:19 <dons> you define the abstract syntax for the language. you call that type Haskell
21:12:25 <dons> standard thing to do.
21:12:28 <SamB> "that type"?
21:12:37 <SamB> there are a ton of types.
21:12:37 * mugwump chuckles
21:12:56 <dons> the same type the parser for Haskell constructs.
21:13:31 <dons> a parser is a function from [Token] -> AbsSyn, right?
21:13:40 <dons> the parser for Haskell is :: [Token] -> Haskell
21:14:34 <dons> code gen is :: Haskell -> Cmm, and then Cmm -> Asm
21:14:59 <dons> Haskell, Cmm and Asm are all data types to represent programs in a specific language as abstract syntax
21:15:54 <SamB> TH has no less than 17 types for various parts of the haskell grammer...
21:15:55 <dons> anyway, you don't have to definethis type -- it's defined for you in Language.Haskell.Syntax
21:16:05 <dons> SamB, but they're plugged together.
21:16:12 <SamB> true
21:16:22 <dons> so at the top level there's just the HsSyn type.
21:16:38 <SamB> TH doesn't even have a top level, though
21:17:41 <dons> TH isn't all of Haskell
21:17:46 <dons> no modules, for example
21:17:57 <dons> so just using the TH type doesn't cover everything.
21:17:59 <SamB> yes, I know
21:18:22 <dons> so you need something more like Language.Haskell.Syntax, or the one in Hsx
21:19:42 <SamB> hmm
21:19:46 <dons> a Haskell program is represented as an HsModule
21:19:47 <dons> data HsModule = HsModule SrcLoc Module (Maybe [HsExportSpec])
21:19:47 <dons>                          [HsImportDecl] [HsDecl]
21:20:16 <dons> which links you down into the rest of the language.
21:20:32 <dons> so you need a Perl -> HsModule, then HsModule -> Doc function, right?
21:20:58 <SamB> well, I think I would be using type classes, but sorta, yeah.
21:21:02 <dons> just like ghc has HsSym -> Cmm, Cmm -> C, Cmm -> Asm, and all of those  also go to Doc
21:21:37 <SamB> one thing I don't like about HsSyn is that it wants source code locations...
21:21:41 <dons> sure, you might define a class Gen where gen  :: Perl -> a
21:22:07 <dons> you don't have source locations in perl?
21:22:18 <SamB> hmm, good question
21:22:19 <stepcut> dons: well, it is perl
21:22:19 <dons> it might be useful if you want to debug the code generator
21:22:27 <dons> hehe
21:22:58 <SamB> but I bet they wouldn't be very closely related to Haskell structure at all...
21:23:46 <dons> most wouldn't be useful, but reading generated code might be easier with the occasional hint as to what it was compiled from
21:23:57 <dons> everything else can be set to Inf
21:24:02 <SamB> Inf?
21:24:09 <dons> or 0
21:24:38 <SamB> what in the world is an unboxed string?
21:24:48 <SamB> 	| HsStringPrim	String		-- ^ GHC unboxed string literal
21:25:03 <blackdog> char *? :)
21:25:06 <dons> @type "bytes!"#
21:25:07 <lambdabot> "bytes!"# :: GHC.Prim.Addr#
21:25:31 <SamB> whoa
21:25:38 <dons> if you want fast code...
21:25:49 <dons> and you're coming from a strict language. hmm..
21:26:28 <SamB> I want code that fits on screens of ordinary width with maybe a rather small font ;-)
21:27:42 <dons> what does width have to do with it? you can always break lines with ppr combinators
21:28:31 <SamB> true.
22:17:45 <Lemmih> Good morning, #haskell.
22:21:16 <Pseudonym> G'day.
22:28:19 <mauke> @pl \s -> a (b ('x' : s))
22:28:20 <lambdabot> a . b . ('x' :)
22:37:17 <musasabi> morning
22:39:41 <timbod> evening.
22:39:51 <xerox> 'morning :)
22:40:14 <timbod> OK, I'm  outvoted.
22:40:47 <dons> afternoon
22:53:35 <blackdog> you're three hours and 41 minutes late, don.
22:54:02 <dons> oh. oops.
23:21:33 <autrijus> data Foo deriving (Eq)
23:21:47 <autrijus> that's an error. oh well.
23:22:04 * autrijus can't easily see why it has to be an error.
23:25:06 <dons> "Can't make a derived instance of `Eq Foo' (`Foo' has no data constructors)" ?
23:25:38 <jaap> i wonder what that should do if it did work
23:25:43 <dons> bit hard to derivation on a nothing.
23:25:43 <musasabi> just say instance Eq Foo where _ == _ = True.
23:26:10 <musasabi> kind of pointless though.
23:32:13 <vincenz> Ooh
23:32:22 <vincenz> the typical example of monad is not a monad
23:33:49 <Lemmih> What's the typical example of a monad?
23:34:02 <vincenz> strictness monad
23:34:13 <vincenz> they typically use it with the sheep example
23:35:10 <Lemmih> URL?
23:36:12 <vincenz> it's this one
23:36:17 <vincenz> type Str x = x
23:36:23 <vincenz> map f x = strict f x
23:36:27 <vincenz> unit x = x
23:36:30 <vincenz> join x = x
23:36:50 <vincenz> strict f x = if x not bottom then f x else bottom
23:43:32 <foxy> how do you evaluate 'if x not bottom' ?
23:44:39 <foxy> @type bottom
23:44:40 <lambdabot> bzzt
23:44:53 <foxy> @type undefined
23:44:54 <lambdabot> undefined :: forall a. a
23:45:08 <foxy> @type not undefined
23:45:09 <lambdabot> not undefined :: Bool
23:45:45 <dblhelix> foxy: that won't work as you expect it to do
23:46:03 <foxy> ;)
23:46:10 <dblhelix> @eval not undefined
23:46:33 <lambdabot> out of fuel - use @resume to continue
23:46:43 <dblhelix> :)
23:47:03 <Lemmih> @plugs True == not undefined
23:47:09 <lambdabot> Fail: Prelude.undefined
23:47:59 <dblhelix> you cannot test a value to be equal to undefined; think of undefined as an infinite calculation
23:48:24 <dons> @eval False == not Y I
23:48:25 <lambdabot> type error
23:48:31 <dons> oh, good.
23:50:48 <Itkovian> meuning all
23:51:05 <musasabi> One can do something like (\a c1 c2 -> (a `seq` return c2) `catch` const (return c1)) in IO.
23:51:58 <musasabi> needs Control.Exception's version of catch though.
23:53:43 * dblhelix vincenz, foxy: maybe you mean:  strict f x = x `seq` f x
23:55:22 * vincenz doesn't code haskell
23:55:28 <vincenz> this comes straight from wadler
23:55:54 <dblhelix> maybe wadler was using some kind of pseudocode here?
23:56:11 <dblhelix> vincenz: reference?
23:56:32 <vincenz> Comprehending Monads
23:56:47 * dblhelix has a look
23:57:14 <vincenz> page 9
