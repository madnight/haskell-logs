00:00:19 <musasabi> morning
00:00:37 <pediddle> evening
00:00:53 <pediddle> oh, wait, 12:02
00:01:06 <pediddle> morning
00:03:35 <lispy> heh
00:04:46 <dons> @seen SamB
00:04:47 <lambdabot> SamB is in #haskell. I don't know when SamB last spoke.
00:05:22 <Gahhh> @ghc
00:05:23 <lambdabot>  At least one of the forall'd type variables mentioned by the
00:05:23 <lambdabot> constraint must be reachable from the type after the '=>'
00:05:40 <Gahhh> hmm. deep.
00:06:14 <dons> very reasonable I'd have thought.
00:06:25 <dons> @ghc
00:06:26 <lambdabot>  Implicit parameters escape from the monomorphic top-level binding(s)
00:06:41 <dons> oh! well that's what you get for using implicit parameters
00:06:59 * dons loves type errors
00:07:36 <Heffalump> is @ghc just a joke?
00:08:08 <Cale> Presumably @ghc spits out error messages from ghc
00:08:13 <Cale> @ghc
00:08:15 <lambdabot>  Too many parameters for class
00:08:19 <Cale> @ghc
00:08:20 <lambdabot>  bindings for unlifted types aren't allowed
00:08:40 <dons> they're real error messages from ghc.
00:08:47 <Cale> @ghc
00:08:48 <lambdabot>  Can't represent explicit kind signatures yet
00:09:09 <dons> but not, as someone thought, produced by automagically type-incorrect code generated by lambdabot ;)
00:09:59 <dons> Heffalump, what were you thinking?
00:10:01 <Heffalump> I was wondering if it was doing that internally in response to the lack of an argument.
00:10:12 <Heffalump> And that if you actually provided an argument it'd do something useful.
00:10:18 <dons> nope. @ghc is an alias for @quote ghc
00:10:23 <dons> @quote ghc
00:10:24 <lambdabot>  bindings for unlifted types aren't allowed
00:11:37 <dons> it's just that type errors in ghc are so much FUN!
00:13:04 <Gahhh> type errors in stl are fun, too.
00:13:27 <lightstep> is there an uncons (in some name), in addition to (splitAt 1)?
00:13:31 <dons> type errors in twelf are really good.
00:13:53 <dons> i'm sure Isabelle and Coq are similarly good
00:17:05 <Gahhh> something named Coq had better be superb at that.
00:18:09 <dons> @google Coq
00:18:10 <lambdabot> http://coq.inria.fr/
00:18:30 <dons> theorem prover, hence fancy type system.
00:32:29 <vegai> whouu, ocaml got a new site
00:34:26 <musasabi> Has anyone got a (possibly mutable) map structure with better union than Data.Map?
00:57:53 <glimming> I am working on distributiive laws still is ski here?
00:57:56 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=dist.off
00:58:10 <glimming> I am preparing some homework question and it ended up to be rather complicated.
00:58:17 <glimming> I would greatly appreciate some advise from any monad gurus.
00:58:58 <glimming> Currently I am giving a special Monad2 class (monads, i.e. the monoid form) but I think I'd better simply it back to Monad (Kleisli triples)
00:59:08 <glimming> before presenting it to the students
00:59:19 <glimming> I am afraid there might be typos in here.
00:59:32 <glimming> vegai, what is the url?
01:07:01 <lightstep> caml.inria.fr
01:20:35 <jlouis> glimming: that doesn't look too hard to me. But why present another view on monads? As far as I can see you will then have to show equivali
01:20:38 <jlouis> e
01:20:41 <jlouis> bleh
01:20:56 <jlouis> equivalence between Monad2 and Monad and that the dist. laws hold in Monad2
01:21:55 <glimming> yes
01:22:08 <glimming> I agree, but since Beck and most other maths people AFAIK use the monad form
01:22:15 <glimming> I prefer using it rather than haskell's Kleisli form
01:22:17 <glimming> For now.
01:22:23 <glimming> The final step will be to simplify it all to Monad.
01:22:36 <glimming> So that students will not have to actually prove the equivalence.
01:22:56 <glimming> jlouis, it looks hard to me! ;-)
01:24:22 <glimming> My first confusion is the composite triple's definiton
01:24:31 <glimming> where we have S delta T. mu_S . mu_T
01:24:52 <glimming> This S delta T  is a composition of type constructors with a polymorphic function.
01:24:59 <glimming> jlouis, do you know what this is exactly?
01:26:25 <jlouis> glimming: I have never looked into Monads as if they were mathematical objects. So manipulating them in mathematical space would probably take me a bit of time to get used to if I should work on that equivalence
01:27:46 <jlouis> glimming: I am still on the first pages of category theory, heh
01:28:50 <skew> glimming: where are you getting that equation from?
01:29:15 <Heffalump> morning bringert
01:30:04 <Heffalump> I pulled your changes, unfortunately the license on NewBinary just says 'AllRightsReserved' and nothing else, which makes it a bit hard to package for Debian, so I'm going to have to talk to Jeremy about that
01:30:56 <bringert> Heffalump: yeah, I noticed that too
01:31:37 <bringert> I talked to Dominic about the crypto library, and he says NewBinary isn't needed for Base64 and MD5, which is the only things used from the crypto lib
01:31:53 <Heffalump> hmm, right
01:31:59 <Heffalump> still, it's a bit messy
01:32:01 <bringert> so maybe we can get rid of the NewBinary dep somehow
01:32:12 <Heffalump> I'll just talk to Jeremy, he uses #haskell
01:32:30 <Heffalump> AllRightsReserved might just have been the default "I'll think about it later".
01:32:50 <Heffalump> if he actually doesn't want to provide it under a OS license we can worry about it then
01:33:28 <bringert> he didn't write NewBinary though
01:33:34 <bringert> I think the code is from nhc
01:33:42 <Heffalump> oh, right. Well, that's free.
01:34:01 <dons> if NewBinary is based on Binary, then it's from nhc.
01:35:15 <Heffalump> hmm, the nhc license basically says you can steal parts of it and relicense them.
01:35:33 <Heffalump> (under a new name)
01:35:49 <Heffalump> anyway, I'll talk to him.
01:35:49 <dons> oh hmm.
01:35:58 <glimming>  skew, Beck (1969, LNM 80)
01:36:33 <glimming> jlouis,
01:36:41 <glimming> The monad laws are statement of beta equality.
01:36:44 <glimming> AFAIK
01:36:58 <glimming> And the resemblence between category theory and Haskell is STRIKING
01:37:41 <jlouis> glimming: hehe, therefore I read category theory ;)
01:38:12 <skew> Well, I don't have a copy of that. T and S are the endofunctors for two separate monads, and mu_S and mu_T are the join operations?
01:38:32 * Heffalump runs away from all the category theory
01:38:48 <glimming> yepp
01:38:56 <glimming> join? is that terminology=?
01:39:19 <glimming> unit and multiplication normally AFAIK
01:39:26 <glimming> and AFA MacLane
01:39:48 <skew> That's the natural transformation from T (T (X)) to T X, if X is your base space
01:39:58 <skew> all these parts have lots of different names
01:39:58 <glimming> yes
01:40:08 <skew> what are you calling the unit?
01:40:16 <glimming> yes, but the haskell notion of bind is actually different because it is Kleisli form
01:40:20 <glimming> erta
01:40:21 <glimming> eta
01:40:23 <glimming> standard name
01:40:34 <glimming> eta :  -.--> m
01:40:39 <glimming> mu : m m a -> ma
01:40:48 <glimming> ewta : 1 -.-> m a
01:40:50 <glimming> sorry
01:40:51 <glimming> eta
01:41:07 <skew> shouldn't that be eta : a -> m a?
01:41:08 <glimming> So
01:41:16 <glimming> Not sure
01:41:23 <glimming> Yes I think so in fact!
01:41:30 <glimming> it is 1---.---> m
01:41:37 <glimming> lift it to   a ----> ma
01:41:40 <glimming> (why?)
01:41:45 <skew> Ah
01:41:47 <glimming> ahh. Yes.
01:42:01 <skew> as 1 -> m it's a natural transformation from the identity endofunctor to m
01:42:06 <glimming> does Haskell support calculus of type constructors well?
01:42:20 <skew> what do you want to do?
01:42:39 <glimming> So that we can actually write     m::*->*  =>  Id ---> m
01:42:43 <glimming> or something?
01:42:57 <glimming> I want to translate the distributive laws in to Monad2 above,
01:43:01 <glimming> then move them back to Monad form.
01:43:10 <glimming> My problem is the composition of natural transformation with fucntor.
01:43:19 <skew> Oh
01:43:44 <skew> Haskell makes a distinction between the object and morphism actions of a functor
01:44:05 <glimming> e.g. in the composite triple we have (st, eta_s.eta_t, s delta t. mu_s.. mu_t)
01:44:14 <glimming> I am a bit lost at the definition of composite triple.
01:44:23 <glimming> Mainly beacuse of the s delta t here
01:44:29 <skew> the object map is captured as a type constructor (say F) of kind * -> *, while the morphism map is an ordinary function of type (a -> b) -> (F a -> F b)
01:44:37 <glimming> ski said s delta t = mmap (delta t)
01:44:51 <glimming> sure
01:44:57 <skew> what is the delta?
01:45:15 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=dist.off is given here
01:46:02 <glimming> delta is a natural transformation satisfying some properties making it a distributive law
01:46:07 <glimming> Such laws allow us to compose monads.
01:46:18 <skew> okay
01:46:21 <glimming> I.e. given delta we can prove that the composite is indeed a monad, i.e. satisfies the monad laws
01:46:58 <skew> Your triple is missing some dots
01:47:14 <skew> (S.T, eta_S . eta_T, S.delta.T.mu_S.mu_T)
01:48:07 <skew> that last part doesn't quite look right
01:48:37 <skew> delta :: (S.T) a -> T (S a)
01:48:54 <skew> we need a mu_ST :: (S.T) (S.T) a -> (S.T) a
01:49:41 <skew> so, something like   S(mu_T).delta.T(mu_S).delta
01:55:44 <glimming> Are you sure about that?
01:56:08 <glimming> kidane, wll?
01:56:13 <glimming> wli
01:56:16 <glimming> wli=kidane?
01:57:50 <glimming> I guess not
02:00:46 <earthy> looks right, skew
02:01:20 <glimming> According to Beck we have
02:01:45 <glimming> Compose ST = (ST, eta_S.eta_T, S dist T . mu_S . mu_T)
02:01:57 <glimming> but we do have various properties of dist that can transfer th expression involving it.
02:02:03 <glimming> transform
02:02:04 <glimming> the
02:02:19 * earthy nods
02:02:57 <glimming> So I want to understand mu_ST here
02:03:10 <glimming> first S dist T - what is this?
02:03:24 <glimming> pre and postcomposing a natural transformation with a functor? I assume
02:03:29 <glimming> dist_A is the natural transformation
02:03:44 <glimming> we get S (dist_T A)
02:03:52 <glimming> pointwise
02:04:01 <glimming> correct?
02:04:27 <musasabi> JohnMeacham: Do you have any thoughts on TIMain and especially tiSeq - that seems to be a bottleneck..
02:05:24 <glimming> skew, i'd like to give the distributivity properties using Haskell's Monad rather than Monad2
02:05:34 * earthy nods, sounds right
02:20:01 <bourbaki> moin
03:30:30 <lightstep> is unlines . lines = id? it seems not to be so - unlines might add an extra newline. is that right?
03:32:34 <TheHunter> @plugs (unlines . lines) "foo"
03:32:36 <lambdabot> "foo\n"
03:32:43 <kosmikus> lightstep: that's right
03:33:00 <kosmikus> but "lines . unlines == id"
03:33:20 <kosmikus> oh no
03:33:30 <kosmikus> not even that
03:34:33 <lightstep> these are never the same, i think
03:34:38 <skew> I don't remember if there was a good reason for that
03:34:48 <lightstep> @ghci (lines.unlines) "foo"
03:34:49 <lambdabot>  Can't reify a non-Haskell-98 data constructor
03:35:02 <lightstep> @ghci map (lines . unlines) ["foo", "foo\n"]
03:35:03 <lambdabot>  GHC internal error
03:35:09 <lightstep> @plugs map (lines . unlines) ["foo", "foo\n"]
03:35:10 <lambdabot> Couldn't match `String' against `Char'
03:35:19 <skew> splitting on newlines in lines and interspersing a newline between each list element in unlines seems to give that identity both ways
03:36:05 <skew> That breaks lines (xs ++ ys) == lines xs ++ lines ys
03:45:22 <tromp> (xs ++ ys) == lines xs ++ lines ys is impossible to satisfy
03:46:10 <skew> lines = id would do it :)
03:47:22 <skew> well, lines (xs ++ ys) == lines xs ++ lines ys if xs and ys end in a newline under the current definition
03:47:46 <tromp> that's all you can hope for i guess
03:49:36 <tromp> does unlines put on a final newline?
03:50:40 <tromp> if lines "hi" equals lines "hi\n" then you cannot get an inverse
03:51:11 <tromp> you'd have to make lines "hi" undefined
04:09:02 <nlv11757_> can lhs2tex be used in combination with uuag ?
04:11:13 <skew> I suppose you could
04:11:33 <skew> you would probable have to use the code style to dump a file that uuag could process
04:22:46 <kosmikus> nlv11757_, skew: yes, Atze Dijkstra is using uuag and lhs2tex in this way, I think
04:23:18 <nlv11757_> Atze is using shuffle isnt he?
04:23:42 <nlv11757_> but i dont really have that versioned behaviour in my ags, there too small for that i think
04:24:23 <nlv11757_> so i was thinking; having 'literate ags' and using shuffle to either generate an lhs file or ag file
04:25:42 <tromp> i never realized how slow vi can be
04:25:53 <nlv11757_> when processing what tromp ?
04:26:05 <tromp> just replacing tabs by spaces in a big file
04:26:10 <kosmikus> nlv11757_: what's shuffle?
04:26:29 <tromp> 10 mins and counting
04:27:28 <nlv11757_> kosmikus, that's Atze his tool to manage the different versions of his EHC
04:28:00 <kosmikus> ah, ok; so his setup is more complicated than I thought
04:28:10 <kosmikus> but he's definitely using lhs2tex as well
04:28:13 <nlv11757_> yes
04:28:30 <nlv11757_> his shuffle tool outputs stuff that is to be processed by lhs2tex
04:28:38 <nlv11757_> (or thats the default setting)
04:28:56 <nlv11757_> but you can also say, i want ag code, and no lhs2tex stuff, then you get an ag file
04:29:37 <kosmikus> anyway, if you're willing to write uuag code in a slightly different syntax, there's no problem to get lhs2tex --newcode to translate it into proper uuag code and lhs2tex --poly to translate it into LaTeX
04:29:48 <kosmikus> no need for shuffle
04:30:15 <nlv11757_> depending on how different that syntax would be, that sounds good
04:30:51 <kosmikus> I think the main difference is that you'll have to write something like (A foo bar) instead of @foo.bar
04:32:59 * boegel joins he crowd
04:33:02 <nlv11757_> kosmikus, uuag ignores \begin{code} stuff
04:33:03 <nlv11757_> ?
04:44:11 <boegel> hey Oejet
04:45:04 <Oejet> Hello, boegel.
04:49:44 <bourbaki> moin
04:50:00 <Oejet> Hello, bourbaki.
04:51:22 <Oejet> bourbaki: I suspect that you have some kind of autogreeting setup, so that you automatically say "moin" on entering.
04:52:06 <bourbaki> no
04:52:20 <bourbaki> i just say that every time i join
04:53:56 <boegel> hey bourbaki
04:54:16 <lightstep> i need help with parsec. when (string "foo" <?> "bar") fails, it says `expecting "foo"', not `expecting bar'. how can i solve this?
04:54:18 <bourbaki> boegel i found a cool paper on bird song generation
04:54:29 <bourbaki> i just need to find out more about these filters
04:55:03 <boegel> bourbaki: nice :)
04:55:25 <boegel> bourbaki: I proof-read mitchkov's thesis book, it has some quite interesting stuff in it
04:55:36 <boegel> the filters definitions are _really_ simple
04:56:06 <bourbaki> if he would get online i could show him the paper and he could tell me if he features the filters
04:56:20 <bourbaki> i had the idea of a monad sound thingy dsp filters that is
04:56:45 <bourbaki> raw files to sound monad is the return
04:57:03 <bourbaki> but you also can write a generator as return as well
04:57:25 <boegel> he's online but has no time, I think he's having trouble with his pc
04:57:29 <boegel> you could mail it to him
04:58:09 <bourbaki> ah i see i will do that later though cause i am not at the pc where i have the papers on
04:59:19 <boegel> do you have his adress ?
04:59:23 <bourbaki> nope
05:01:35 <lightstep> i solved my problem: it only occured when the failure was in the middle of the string, and can be solved by adding "try"
05:04:00 <kosmikus> nlv11757_: it does, but that doesn't matter, because lhs2tex --newcode will produce a non-literate ag file as output
05:04:30 <Oejet> lightstep: Your idea seems to work on the Bzip2 binding.
05:05:42 <lightstep> i didn't understand which idea, at the time. which one?
05:06:35 <Oejet> Using (unsafeInterleaveIO :: IO a -> IO a) for lazy (de)compression of Bzip2 files.
05:06:45 <lightstep> oh
05:07:43 <lightstep> another parsec question: how do i parse chars until a newline?
05:07:51 <lightstep> Oejet, what do you use it for?
05:09:12 <Oejet> libbzip2 decompresses from a file into a bounded buffer and since that happens in the IO monad we need some way to pospone that IO action until needed.
05:10:46 <lightstep> but isn't it better for (de)compression to be strict?
05:12:13 <Oejet> No, because then we would have to either (a) expose the buffer or (b) return the whole string at once.  Neither is very Haskellish.
05:12:32 <lightstep> (solved my problem again: manyTill anyChar (char '\n'))
05:13:10 <lightstep> i'd take (b), since the string is created anyway
05:13:15 <lightstep> as a whole
05:14:23 <Oejet> That would mean decompressing the whole file to memory at once.
05:17:25 <Oejet> We want to lazily construct the decompressed string so it acts like a stream.
05:18:00 <lightstep> but the call to libzlib will create the whole buffer at once anyway
05:18:22 <Oejet> Ah, but the buffer is much smaller than the file usually.
05:18:52 <lightstep> libzlib fills a buffer at a tile?
05:19:13 <Oejet> *time?
05:20:16 <lightstep> yes
05:21:22 <Oejet> Yes.
05:23:39 <lightstep> lazy io is difficult
05:24:22 <Oejet> Yep, couldn't do it until you mentioned unsafeInterleaveIO.
05:25:20 <dons> forkIO and chans are good for this as well
05:27:44 <Oejet> dons: I think, I understand.
05:29:41 <lightstep> how can i construct a ParseError object?
05:30:40 <dons> chans are implemented on top of unsafeInterleaveIO
05:31:10 <dons> getChanContents :: Chan a -> IO [a]
05:31:11 <dons> getChanContents ch
05:31:11 <dons>   = unsafeInterleaveIO (do
05:31:11 <dons>         x  <- readChan ch
05:31:11 <dons>         xs <- getChanContents ch
05:31:13 <dons>         return (x:xs)
05:32:52 <Oejet> That's the construction I use.   My readChan is just called bzRead.
05:33:36 <dons> it's a good way to do this kind of problem, I think.
05:33:43 <Oejet> Well,
05:34:33 <Oejet> getChanContents ch
05:34:33 <Oejet>    = do x  <- readChan ch
05:34:33 <Oejet>            xs <- unsafeInterleaveIO $ getChanContents ch
05:34:33 <Oejet>            return (x:xs)
05:34:40 <dons> hence we do IO this way.
05:34:40 <dons> lazyRead handle =
05:34:40 <dons>    unsafeInterleaveIO $
05:34:40 <dons>         withHandle "lazyRead" handle $ \ handle_ -> do
05:34:40 <dons>         case haType handle_ of
05:34:40 <dons>           ClosedHandle     -> return (handle_, "")
05:34:42 <dons>           SemiClosedHandle -> lazyRead' handle handle_
05:35:18 <dons> no more $fptools code :)
05:35:45 <Oejet> What I actually do also seems to work, but why?
05:35:50 <dons> hmm.
05:36:26 <Oejet> Ah, mine is just strict in the first call.
05:38:09 <Oejet> dons: Thanks for the idea.
05:40:38 <dons> I  did the same thing in Yi for reading keystrokes lazily (has to be lazily)
05:40:56 <dons> (sequence_ . km =<< getChanContents ch)
05:41:56 <Oejet> Is unsafeInterleaverIO portable?  Why is it unsafe?
05:42:13 <dons> it's side effecting I guess. it's certainly portable
05:42:39 <dons> unsafeInterleaveIO :: IO a -> IO a
05:42:40 <dons> unsafeInterleaveIO (IO m)
05:42:40 <dons>   = IO ( \ s -> let
05:42:40 <dons>                    r = case m s of (# _, res #) -> res
05:42:40 <dons>                 in
05:42:42 <dons>                 (# s, r #))
05:44:53 <dons> @pl \ch km -> sequence_ . km =<< getChanContents ch
05:44:55 <lambdabot> (. (sequence_ .)) . (>>=) . getChanContents
05:44:58 <lightstep> "portable"
05:45:11 <dons> don't flip on me lambdabot
05:46:15 <dons> there's no super-super C pointer coerce mutable style magic
05:47:50 <musasabi> Has anyone got a version of Text.Html or similar for XHtml?
05:47:50 <dons> karma for the first person to write a well-typed Haskell function that uses unsafeCoerce#, mutable variables, and C pointers.
05:49:56 <lightstep> f x = (unsafeCoerce# newIORef) :: Ptr ()
05:50:26 <lightstep> or whatever
05:50:45 <lightstep> with unsafeCoerce#, every function is well-typed
05:51:11 <dons> I should have said "and doesn't segfault" -- that's more important
05:52:10 <dons> @type let f x = (GHC.Prim.unsafeCoerce# Data.IORef.newIORef) :: Foreign.Ptr () in f
05:52:11 <lambdabot> let f x = (GHC.Prim.unsafeCoerce# Data.IORef.newIORef) :: Foreign.
05:52:11 <lambdabot> Ptr () in f :: forall t.
05:52:11 <lambdabot>                            t -> GHC.Ptr.Ptr ()
05:52:57 <dons> Prelude> let f x = (GHC.Base.unsafeCoerce# Data.IORef.newIORef) :: Foreign.Ptr ()
05:53:01 <dons> Prelude> f 1
05:53:03 <dons> 0x04e756b8
05:53:06 <dons> hehe
05:53:20 <dons> @karma+ lightstep
05:53:21 <lambdabot> lightstep's karma has been incremented
05:53:27 <lightstep> omg
05:54:08 <lightstep> Ptr is a phantom type for Int? or is this just the Show instance?
05:54:27 <dcoutts_> dons, we've got plenty of safe use of C pointers and unsafeCoerce# in gtk2hs :-)
05:54:47 <dons> :)
05:54:56 <dons> throw them around!
05:55:03 <dcoutts_> it's how we implement our object up/down casting
05:55:29 <dons> lightstep, Ptr is a data Ptr a = Ptr Addr# deriving (Eq, Ord)
05:56:52 <dons> Prelude> Foreign.Ptr.nullPtr
05:56:53 <dons> 0x00000000
05:57:32 <dons> oh, wow. that's interesting
05:57:44 <bringert> musasabi: I do
05:58:22 <ozone> dons: and you think i'm scary
05:58:26 <bringert> musasabi: http://www.dtek.chalmers.se/~d00bring/darcs/blob/
05:58:30 <bringert> look in lib/
05:59:16 <dons> hehe
06:00:28 <musasabi> bringert: thanks.
06:02:23 <musasabi> bringert: how do you handle attributes - that is "(someTag ! [foo "bar"]) ! [foo "baz"]" ?
06:03:42 <TheHunter> Oejet, got an example for you where unsafeInterleaveIO causes a segfault.
06:03:42 <TheHunter> http://hbin.dyndns.org/pastebin/38.html
06:04:45 <dons> ooh!
06:05:09 <dons> you don't use implict parameters do you? :P
06:05:33 <TheHunter> no, STM.
06:05:49 <TheHunter> STM really doesn't like unsafePerformIO.
06:05:52 <bringert> musasabi: it's based on Text.Html, just modified to produce XHTML
06:06:23 <bringert> (that is to say, I don't actually remember :-)
06:06:34 <Oejet> TheHunter: Thanks for the example.  I'll have to chew on it a bit.
06:07:34 <dons> zsh: segmentation fault (core dumped)  ./a.out
06:10:17 <musasabi> bringert: ok, I will try to either modify my logic or just look at the xml toolkits.
06:12:58 <JohnMeacham> musasabi: have you tried my new patches? it is literally orders of magnitude faster.
06:13:47 <tromp> xtf
06:13:53 <tromp> oops, ignore
06:14:02 <musasabi> JohnMeacham: yes, noticed the huge improvement :-)
06:14:15 <musasabi> And the memory savings.
06:14:46 <Oejet> JohnMeacham: Sounds interesting.  What did you do?
06:14:46 <musasabi> E.SSimplify and TIMain seem to be the remaining places - and unioning maps the culprit.
06:15:30 <JohnMeacham> Oejet: I used IORefs in the unification algorithm rather than using substitution maps.
06:17:07 <JohnMeacham> musasabi: Yeah, those can be slow, but they only happen once and the results are cached in the ho files so I am not too worried about them. I am (personally) concentrating more on the backend right now, the points-to analyisis is the biggest sink as the size of programs grow.
06:18:50 <JohnMeacham> SSimplify can be improved, it has some rough areas. Using the dynamically extensible Info table instead of varmaps can help a lot. it was a relativly recent change and hasn't been taken advantage of to full effect yet.
06:19:34 <JohnMeacham> There are still several optimizations I am planning on adding to SSimplify so I havn't rewritten what is there yet since it will most likely change as I add new passes.
06:21:36 <JohnMeacham> timain probably can use a lot of work. I am hoping to spin off the front end as a standalone library as a contiuation of the hatchet project.
06:22:09 <musasabi> that could make sense.
06:22:41 <xerox> 'morning
06:28:34 <nlv11757_> does someone see why '$(BUILDDIR)/%.o: $(SRCDIR)/%.hs' is not working in a makefile?
06:49:42 <bringert> nlv11757_: not working how?
06:51:00 <bringert> nlv11757_: try adding %.hi: %.o
06:51:00 <bringert>         @:
06:51:05 <bringert> eh
06:51:11 <bringert> %.hi: %.o
06:51:11 <bringert>         @:
06:54:02 <nlv11757_> ok it seems my dependency is not working in "$(BUILDDIR)/Main.o $(BUILDDIR)/Ast.o: $(@:%.o=%.hs)"
06:54:13 <nlv11757_> is it forbidden to define dependencies like that?
06:55:41 <Oejet> http://hbin.dyndns.org/pastebin/39.html
06:55:45 <nlv11757_> or maybe $@ is not yet defined in the dependency?
06:56:21 <Oejet> The functions seem to be working great now.
07:05:08 <nlv11757_> is it forbidden to use automatic variables in dependencies of a rule in a makefile?
07:05:11 <nlv11757_> that would suck
07:21:46 <vikasgp> what's the canonical way to write a literate program in Haskell?
07:26:36 <basti_> hi
07:27:07 <boegel> hi basti_
07:27:43 <jlouis> vikasgp: canonical? build an .lhs file and use > whenever you want literate code is the bird form
07:28:04 <jlouis> There is also something with .tex and \begin{code} \end{code}, though i seldomly use literate style
07:29:14 <vikasgp> I'd like something like CWEB, which knows about the language and does special typesetting of operators, etc.
07:29:35 <vikasgp> I found lambdaTeX; just asking to see if there's any well-known better way
07:33:56 <kosmikus> vikasgp: you can use lhs2tex
07:34:53 <vikasgp> yeah, I just saw that. Seems to be good
07:37:11 <vikasgp> thanks
07:45:41 <boegel> does anyone know the url to wolfgang8k's website ?
07:46:59 * boegel wonders how he constructed the scene for this image: http://benny.kramekweb.com/hrayt/render03.png
07:48:45 <Cale> I constructed the scene for that image :)
07:49:15 <Cale> it's 4 spheres arranged at the vertices of a regular tetrahedron with radii such that they are tangent to one another
07:50:10 * boegel tries to understand what Cale just said...
07:50:30 <Maddas> I thought I understood it until I looked at the picture :-)
07:50:52 <nlv11757_> kosmikus, to which rules must i oblige in order for --newcode to produce valid uuag code
07:50:56 <boegel> a tetrahedron is a 4 triangles edge to egde, right ?
07:50:59 <Maddas> (Oh, if that's just reflection, it works)
07:51:30 <Cale> Yeah, they're just reflective spheres
07:51:41 <boegel> Cale: and where is the camera then ? in the base of the tetrahedron ?
07:51:44 <Cale> yeah
07:51:58 <boegel> okay, let me try that...
07:52:02 <Cale> and there are lights positioned at the centres of the sides (or perhaps a little out from that)
07:52:11 <boegel> that should generate a _lot_ of recursion steps, right ?
07:52:55 <Cale> yes, the picture shown uses unbounded recursion
07:53:09 <boegel> okay, that's exactly what I need :)
07:53:29 * boegel is constructing a cool formal proof on his raytracing model
07:53:57 <Maddas> Cool
07:54:00 <kosmikus> nlv11757_: I've never actually made a complete set, but you shouldn't need too many
07:54:51 <kosmikus> Cale: very nice idea for a raytracer scene
07:56:17 <nlv11757_> kosmikus, ow ok, because im using some %format things that inserts latex normally, but newcode also inserts them, which uuagc obviously isnt going to like
07:57:41 <Cale> kosmikus: you can also do it in real life with those silvery balls they put on christmas trees.
07:58:22 <boegel> Cale: that would result in a lot of rubbing of the balls :)
07:58:38 <kosmikus> nlv11757_: %if style == newcode, %else, %endif
07:59:13 <kosmikus> Cale: in very good light conditions, maybe
07:59:27 <nlv11757_> kosmikus, thnx
08:15:58 <skew> nlv11757_: have you got anywhere with the uuag code?
08:19:41 <dcoutts_> JaffaCake, just wondering if the compacting GC & foreign import "&foo" bug fixes had been merged into the ghc-6-4-branch? I think I've got a memory corruption bug that is independent of both of those but I can't be certain that's the case yet.
08:20:29 <JaffaCake> compacting GC bug: yes, foreign import "&foo": no
08:21:06 <dcoutts_> is the latter likely to get merged in to the 6.4 branch?
08:21:23 <JaffaCake> sure
08:21:32 <JaffaCake> there were a lot of follow-on changes, though
08:22:16 <dcoutts_> ok, I'll wait and test again when that's merged, I think this other bug is the cause of the gtk2hs/wxhaskell demos segfaulting :-)
08:22:42 <JaffaCake> right, ok
08:23:06 * JaffaCake unpacks his merge-o-matic
08:24:12 <araujo> morning
08:25:18 <nlv11757_> skew, sorry about my late reaction (was afk). But what uuag code are you aiming at specifically?
08:35:21 <earthy> hmnz. why oh why does UUAG not allow me to put class constraints on types of attributes
08:35:31 <earthy> oh well
08:38:50 <skew> nlv11757_: trying to generate UUAG code from lhs2TeX source, specifically
08:39:38 <nlv11757_> hehe that prevented another student recently from converting his monadic code to ag
08:40:03 <earthy> nlv: annoying, that
08:40:10 <nlv11757_> skew, ah yes, i'm now just using newcode style for uuag code and poly for document
08:40:49 <kosmikus> earthy: that would be useful?
08:41:31 <skew> nlv11757_: you are defining formatting directives conditionally on the style?
08:41:47 <nlv11757_> yep
08:41:59 <nlv11757_> didnt see a different solution
08:42:42 <nlv11757_> its even in the lhs2tex manual as an example, so it cant be *that* bad :P
08:43:02 <skew> It's nice to hear that it works
08:43:15 <kosmikus> no, I don't see why it should be bad
08:44:28 <skew> I'm planning on trying something similar to generate a pretty typeset version and a text version with haddock comments the next time I write something
08:45:19 <kosmikus> skew: interesting
08:45:21 <nlv11757_> its especially nice that it works because the documentation i am generation is going to be the implementation chapter of my thesis :D
08:45:35 <kosmikus> skew: I alway wanted to merge lhs2tex and haddock in some meaningful way, but I haven't got around to it yet
08:45:39 <skew> which thesis is that?
08:45:42 <nlv11757_> kosmikus, can i also just modify the searchpath on the cmdline instead of replacing it completely?
08:46:08 <nlv11757_> ow the C parallelize thing
08:46:22 <skew> kosmikus: I've thought for a while that the best way to document code would be haddock for the interface and lhs for the internals, I just haven't tried it yet
08:46:33 <kosmikus> nlv11757_: yes, just put a colon at the end or the beginning, depending on where you want ot add the additional directory
08:47:04 <nlv11757_> ok i was hoping to prevent enumerating the path in total :P
08:47:18 <nlv11757_> something like -P newpathwithoutreplacing
08:47:26 <kosmikus> nlv11757_: yes, that's what I mean
08:47:33 <kosmikus> -P bla:
08:47:38 <kosmikus> will prepend bla to the current search path
08:47:48 <nlv11757_> ow ok
08:48:50 <kosmikus> skew: sure, but how to achieve this? should lhs2tex interpret haddock comments, or should lhs2tex produce haddock input, or should haddock have an lhs2tex backend, or ...
08:49:04 <skew> nlv11757_: okay, I was a bit confused by the mention of boegel's raytracing stuff. Many people seem to be writing one around now
08:49:39 <skew> kosmikus: I think the easiest way is to have lhs2tex generate haddock input
08:50:33 <kosmikus> skew: ok, but that'll probably still require changes to lhs2tex, or do you think we can do it with what's currently there ...
08:51:03 <skew> I'm pretty sure there's a style directive for specifying how to format the comments
08:51:16 <kosmikus> there is
08:51:27 <kosmikus> but just one for all comments
08:51:40 <skew> is that really a problem?
08:51:46 <kosmikus> not sure
08:52:20 <skew> I don't see any reason to use the -- inline comments if you are also typesetting the file with lhs2TeX
08:53:27 <kosmikus> I think you'll still run into a few annoyances with this approach, but it certainly seems like the easiest modification to do
08:53:36 <kosmikus> I'm willing to think about this and make appropriate changes to lhs2tex
08:53:58 <kosmikus> so please contact me when you are trying this
08:54:25 <nlv11757_> gday all
08:54:35 <earthy> sorry, yes, I think adding class constraints to attributes might be useful
08:54:45 <earthy> especially to what I'm doing
08:55:15 <earthy> as I want to state `hey, I don't know exactly what I'm going to do here, I'll tell you later, it may well change, but I'll guarantee you these constraints'
08:58:09 <boegel> skew: that's because in Belgium and The Netherlands thesis's are due in June
08:58:20 <kosmikus> earthy: so why not pack it into a newtype?
08:58:49 <earthy> kosmikus: might do that, yeah
09:01:15 <skew> boegel: I mean specifically a lot of people on the channel. I'm not making that fine a distinction about when thesis time is
09:02:51 <boegel> oh, I guess that's just because Haskell is gaining in interest
09:03:25 <skew> I thought it was because a lot of people on #haskell happen to be finishing degrees this year
09:03:33 <boegel> also possible
09:16:05 * vincenz blinks
09:16:08 <vincenz> where is "shapr"?
09:16:33 <basti_> uhm.
09:16:43 * basti_ deeply worried now, too
09:17:22 <vincenz> anyone know a good blogging system to install on my webserver?
09:18:58 <Gahhh> @seen shapr
09:18:59 <lambdabot> I saw shapr leaving #haskell 1 day, 18 minutes and 37 seconds ago.
09:19:14 <vincenz> preferably easy to setup
09:21:53 <SyntaxNinja> 'morning
09:22:44 <Igloo> Nope
09:25:12 <boegel> hey SyntaxNinja
09:27:37 <SyntaxNinja> hi boegel how's it going?
09:30:49 <vincenz> Anyone here by any chance use plog?
09:31:21 <Lemmih> Why are you asking in #haskell?
09:31:44 <vincenz> Cause I saw scannedinavian use it
09:31:54 <vincenz> And I'm a regualr here and don't know where else to ask
09:34:20 <SyntaxNinja> hey Lemmih.  good chance I'll release cabal tonight.
09:34:28 <Lemmih> Shapr is using a fairly simple blog called plog.
09:34:29 <SyntaxNinja> Lemmih: it'll probably be 1.0.2 instead of 1.2, fwiw
09:35:57 <Lemmih> vincenz: It requires you to update a file and re-run the binary (which creates static pages) when you make a new entry.
09:35:59 <boegel> SyntaxNinja: busy, very busy
09:37:27 <raver> hi
09:38:10 <vincenz> hmm
09:40:52 <glimming> ski around?
09:41:11 <Lemmih> @seen ski
09:41:12 <lambdabot> I saw ski leaving #haskell 9 hours, 40 minutes and 46 seconds ago.
09:41:39 <boegel> hi raver
09:46:08 <glimming> Thanks Lemmih
10:08:08 <lightstep> does (//) take a lot of space or make the array slow?
10:32:48 <vincenz> done
10:49:25 <Oejet> Good evening gentlemen and gentlegirls.
10:51:35 <SyntaxNinja> hi Oejet
10:52:09 <Oejet> I really learnt alot in connection with writing that TMR article.
10:58:00 <TheHunter> Oejet, you didn't answer the interesting question. How does your example program compare with bzcat foo.bz2 | bzcat -z > bar.bz2 ?
10:58:55 <Oejet> TheHunter: Oh, sorry I guess, I missed that one.  Let me try.
11:02:46 <Oejet> Ups.
11:03:14 <basti_> your program crashes the system? ;)
11:03:39 <Lemmih> wilx:
11:03:51 <Lemmih> Ops Sorry.
11:04:09 <SyntaxNinja> hi stepcut
11:04:13 <Oejet> readBzip2: 3:12, bunzip2: 1:00.  That's just for reading linux-2.6.11.8.tar.bz2.
11:04:33 <stepcut> hi SyntaxNinja
11:04:53 <Oejet> basti_: Nah, I hit C-w in Gaim which closes the tab.  I wanted to cut some text. :-/
11:05:03 <TheHunter> good enough.
11:05:10 <basti_> :P
11:05:23 <stepcut> so, what is the 'best' library for converting latin1 to utf-8 in haskell ?
11:05:59 * TheHunter wonders if this bz2 file he found on his system has a finite or an infinite uncompressed size.
11:07:17 <mflux> I think bz2 cannot represent infinite sequenceecs
11:07:30 <basti_> one can always try.
11:07:32 <basti_> :)
11:07:59 <TheHunter> @plugs 2048/17/60
11:08:02 <lambdabot> 2.007843137254902
11:09:03 <Oejet> TheHunter: 6:23.70
11:09:46 <Oejet> And the binding was 16:30 if i recall correctly.
11:10:31 <TheHunter> Oejet, thanks.
11:11:22 <TheHunter> ok, it was at least larger than 6.5G.
11:45:24 <Oejet> @info Word8
11:45:25 <lambdabot> Unknown command, try @listcommands.
11:45:40 <Oejet> @docs Word8
11:45:41 <lambdabot> Word8 not available
11:45:55 <Lemmih> @docs Data.Word
11:45:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Word.html
11:46:23 <Oejet> Lemmih: Thank you, you are the best lambdabot I ever had.
11:46:47 <Lemmih> (:
11:48:02 <Oejet> I think, I got the new Puffathy song on my brain.
11:51:19 <wagle> 11:43 < riel> this is bloody insane
11:51:19 <wagle>               http://studentpages.scrippscollege.edu/~cherring/generallee.gif
11:52:08 <asmodai> guys, do we appreciate unknown logging bots in here?
11:52:33 <asmodai> http://www.aboutrealstuff.com/arc/fr/haskell/
11:52:33 <Oejet> Me not.
11:52:41 <asmodai> cause we're being logged
11:53:08 <asmodai> I banned *!*@pool-70-107-88-134.ny325.east.verizon.net from Undernet #FreeBSD and #Python already
11:53:43 <Cale> There are public logs anyway
11:53:47 <reffie> hi asmodai
11:53:55 <asmodai> rePPie!
11:53:55 <Heffalump> what client?
11:53:56 <reffie> i didn't know you were interested in haskell
11:54:09 <asmodai> reffie: too little time to really dive into it yet
11:54:12 <asmodai> reffie: but I am :)
11:54:21 <reffie> :)
11:54:26 <Heffalump> the logs seem pretty crappy.
11:54:33 <asmodai> reffie: how are you?
11:55:15 <Cale> http://tunes.org/~nef/logs/haskell/ -- these ones?
11:55:20 <asmodai> Heffalump: not sure what client or anything
11:55:29 * asmodai just doesn't like sneaky bots
11:55:33 <Cale> does the logger miss things?
11:55:49 <reffie> asmodai i'm ok.. you?
11:55:57 <asmodai> reffie: mmm, pretty ok :)
11:56:44 <asmodai> reffie: haven't played any go lately :(
11:57:22 <reffie> me neither :(
12:02:15 <asmodai> oh
12:02:17 <asmodai> wrt bot:
12:02:19 <asmodai> [21:01] <<+veins>> neither do i
12:02:19 <asmodai> [21:01] <<+veins>> but it is owned by a russion spammer
12:02:19 <asmodai> [21:01] <<+crasher>> Spammer?
12:02:22 <asmodai> [21:01] <<+veins>> yeah
12:02:24 <asmodai> [21:01] <<+veins>> they used the logs as part of a commercial stuff apparently
12:02:27 <asmodai> [21:02] <<+veins>> collecting email and websites, then sending targeted
12:02:29 <asmodai>                    advertisement
12:02:36 <Heffalump> it does seem to be part of some advert.
12:02:47 <Heffalump> but in practice there's nothing we can do to stop it
12:02:53 <asmodai> ban the userhost ;)
12:02:59 <Heffalump> how do we know what it is?
12:03:18 <Heffalump> (your assertion that it's the above one isn't really very strong evidence)
12:03:33 <fraxtal> I like the logs
12:03:45 <Heffalump> fraxtal: the ones on aboutrealstuff.com ?
12:03:50 <asmodai> Heffalump: *shrug* just helping along. :)
12:04:12 <Heffalump> the "real" logs are fine (well, I don't really like having them, but they aren't being used for commercial gain and they look decent)
12:15:52 <Corion> Is there any way to declare a function as unsafe (so it always gets executed)? I need getEnv() to be reexecuted (as I've "implemented" setEnv for Win32)
12:16:17 <Heffalump> shouldn't it just be run if you're in the IO monad and you call it?
12:16:55 <Corion> Heffalump: But I get my old values returned, which is wrong, because child processes see the new version :)
12:17:33 <Corion> ... and for some weird reason, my own implementation of getEnv doesn't want to link because of name mangling, while the implementation of setEnv links...
12:18:06 <Corion> Is there a pastebot here?
12:18:56 <Oejet> hbin.dyndns.org
12:19:00 * Corion discovers lisppaste2
12:19:28 <dcoutts_> SyntaxNinja, we were talking yesterday about building ghci .o files from ghc .a files. I should note that the code that I gave and that ghc-pkg uses is basically linux only. Yes that's right, ghc-pkg --auto-ghci-libs fails on Solaris (and I presume OSX too - unless the OSX packagers patch it). JaffaCake is aware of this problem so you might ask him if there is some code that does the right thing on other platforms.
12:20:58 <Corion> http://hbin.dyndns.org/pastebin/40.html
12:22:16 <Corion> Hmmm. The error message got cut off -- src/Pugs/Compat.o(.text+0xd4d):fake: undefined reference to `GetEnvironmentVariableW@4' -- which tells me that there is name mangling going on, but which should Just work because that looks like the signature of the function...
12:29:46 <Cale> Corion: and whatever library that function is in is actually being linked with the rest of the code?
12:30:31 <Corion> Cale: It's in the Win32 kernel. But I Just found my problem - I was reading the function definition wrong, and it actually takes more parameters than what I gave, so the name mangling error is what I deserve ...
12:30:40 <Cale> ah
12:31:47 <Corion> ... one day I'll start to listen to what the compiler tries to tell me ;)
12:36:03 <Oejet> I'm stuck trying to marshall from type Ptr () to [Word8].  Any ideas?
12:37:10 <dcoutts_> Oejet, try http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.Array.html#v%3ApeekArray
12:37:26 <Cale> There's an instance of Storable for (Ptr a)
12:37:50 <dcoutts_> and you'd need to castPtr to get from  Ptr () to Ptr Word8
12:38:57 <Oejet> dcoutts_: That was almost too obvous.  Thank you.
12:39:05 <dcoutts_> np
12:39:06 <Oejet> *obvious
12:39:47 <dcoutts_> anyway, it's only obvious once you find the right function :-)
13:13:46 * boegel bounces
13:15:12 * araujo chuckles
13:16:05 * boegel looks up "to chuckle"
13:16:30 <basti_> mmmwow i did backtrack stuff.
13:16:38 <basti_> not in the continuation monad though
13:16:54 <basti_> but amazingly clean
13:17:38 <basti_> almost feels like prolog.
13:17:57 <basti_> only works for lists though.
13:18:01 <basti_> lists of results.
13:18:50 * boegel likes prolog
13:21:23 * araujo thinks prolog is nice
13:21:43 <basti_> prolog is THE language to scare the shit out of wannabes
13:22:46 <SyntaxNinja> heh
13:25:40 <gzl> i thought it was perl
13:25:44 <gzl> you know, @#$@#$@#$@#$@#
13:26:12 <basti_> hmm but people percieve that as being normal
13:26:21 <basti_> you know computers being complicated and not understandable
13:26:29 <basti_> but then you got someone who has half a knowledge
13:26:35 <basti_> and then you show him this little prolog program
13:26:45 <basti_> which runs... and then again, and brings up a different result
13:26:48 <basti_> and then runs backwards
13:27:23 <basti_> and even knows what makes sense and what not
13:27:28 <basti_> that *scares* people
13:28:02 <basti_> of course you keep telling him its only resolution of horn clauses, but he won't believe you
13:28:22 <basti_> "but... how did it know kain could not have been abel's cousin since he was his brother!?"
13:28:54 <JohnMeacham> @seen shapr
13:28:55 <lambdabot> I saw shapr leaving #haskell 1 day, 4 hours, 28 minutes and 33
13:28:55 <lambdabot> seconds ago.
13:29:06 <basti_> there must be something going on
13:30:18 <basti_> the list monad is a nice little tool for making list processing intuitive.
13:33:28 * basti_ can even make it iterate to all potential solutions and then not backtrack.
13:33:41 * arjanb is playing with GADTs
13:33:53 <arjanb> data Peano a where
13:33:53 <arjanb>    Zero :: Peano ()
13:33:53 <arjanb>    Succ :: Peano a -> Peano (Peano a)
13:34:16 <basti_> uh
13:34:22 <integral> doesn't that imply a must be () ?
13:34:23 <arjanb> peano number at the type and term level at the same time :)
13:35:02 <basti_> does that make sense? ;)
13:35:50 * integral blinks
13:36:25 <arjanb> no idea, maybe it can be used for some nifty tricks
13:43:03 <Oejet> Heh.
13:50:16 <JohnMeacham> Are extensible kinds being worked on for ghc? tim sheard had a paper on how they combine with GADTs with grand consequences.
13:53:17 <JohnMeacham> It was once said that the best way to encode numbers in types is with balanced ternary.
13:54:00 <basti_> :-o
13:54:38 <boegel> Cale: are you still active ?
13:56:17 <FrederikEaton> what's an extensible kind?
13:56:56 <JohnMeacham> being about to say 'kind Num = One | Succ Num'
13:57:47 <JohnMeacham> This paper has lots of examples: http://www.cs.pdx.edu/~sheard/papers/GADT+ExtKinds.ps
13:58:58 <FrederikEaton> "a programming pearl for the 21st century"?
13:59:14 <FrederikEaton> where's my hovercraft
14:00:37 <Oejet> FrederikEaton: Your hovercraft is full of eels.
14:02:31 <mstevens> erk, it's full of gale
14:03:23 * boegel leaves to take a nap
14:03:26 <boegel> bye everyone
14:03:54 <JohnMeacham> It is just a scouting mission. for new recruits.
14:07:57 <FrederikEaton> what is a scouting mission?
14:09:23 <musasabi> restricted kinds would be very nice.
14:18:17 <JohnMeacham> FrederikEaton: it was in regards to mstevens comment about us galies.
14:28:10 <mr-onionhead> I'm reading some prelude code and have found comments like "{-# RULES "cmpUArray/Int" cmpUArray = cmpIntUArray #-}"  What does this mean?
14:28:32 <KrispyKringle> looks like it's something for testing. Hunit or something, maybe?
14:28:45 <KrispyKringle> {- -} is a comment, so this isn't actually Haskell.
14:28:59 <SamB> {-# #-} comments are actually pragmas
14:29:04 <KrispyKringle> Ah.
14:29:04 <arjanb> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
14:29:17 <Cybertnt> SamB: what are pragmas?
14:29:19 <Lemmih> mr-onionhead: It'll use cmpIntUArray instead of cmpUArray whenever it can.
14:29:27 <KrispyKringle>  You learn something new every day.
14:29:37 <SamB> Cybertnt: hmm, thats a hard question!
14:29:49 <mr-onionhead> wow, i had no idea haskell had such beasts:)
14:30:01 <KrispyKringle> me, either.
14:30:01 <Cybertnt> :/
14:30:05 <mr-onionhead> is this a ghc only feature?
14:30:06 * Cybertnt feels stupid
14:30:16 <KrispyKringle> neat
14:30:30 <musasabi> What is the proper way to suply multiple parameters to an arrow command? Using tuples does not seem very pretty..
14:31:01 <Cybertnt> musasabi: then again nothing seems very pretty in haskell if you programmed in any other language before :P
14:31:09 <SamB> http://haskell.org/onlinereport/pragmas.html
14:31:29 <musasabi> 'acmd -< (foo,"bar",455)' vs 'mcmd foo "bar" 455' with monads..
14:31:35 <Cybertnt> thanks SamB!
14:31:56 <mr-onionhead> samb: thanks also:)
14:32:07 <SamB> that doesn't tell you what pragmas are, but it tells you what haskell pragmas are
14:32:19 <SyntaxNinja> haskll is really beautiful compared to most language.
14:32:40 * musasabi ponders using the vararg trick to get that pretty again.
14:32:55 <Cybertnt> SamB: yeah, for what pragmas are, i might consider a dictionary :P
14:33:30 <mr-onionhead> cybertnt: in general a pragma is an instruction to a complier to do something.  Pragmas aren't part of the source language, but are included in a source files.  In C, for example, you can use pragmas to disable certain warnings.
14:35:38 <Cybertnt> hmm
14:36:04 <Cybertnt> you could say compiler options ?
14:37:48 <mr-onionhead> cybertnt: Kinda.   However a compiler option is usually something that you set once:  "gcc -03 foo.c" optimizes all of foo.c at O3
14:38:16 <mr-onionhead> pragams can be narrower in scope.  You could disable a particular warning for a particular function.
14:38:34 <Cybertnt> ah ok!
14:38:36 <Cybertnt> thanks
14:40:20 <Cybertnt> could anybody point me towards getting bit operations to work? i know there is the Bits library but i dont seem to get it to work
14:40:55 <Cale> Cybertnt: what are you trying to do?
14:41:10 <Cybertnt> Cale: same as last time :P the xor
14:41:26 <Cale> bitwise xor?
14:41:29 <Cale> of what?
14:41:36 <Cybertnt> 2 numbers
14:41:36 <Cale> (sorry, I forget)
14:41:47 <Cybertnt> like 2 xor 3
14:41:54 <SoulSurfer> wow there are a lot of people in here
14:42:21 <Cale> @plugs 3 `xor` 5 :: Integer
14:42:27 <lambdabot> 6
14:42:57 <Cybertnt> hmm alright
14:43:16 <Cybertnt> thanks!
14:43:26 <SoulSurfer> how can you xor two integers?
14:43:36 <Cale> SoulSurfer: bitwise
14:43:48 <SoulSurfer> ahh of course that makes sense
14:43:56 <Cybertnt> SoulSurfer: like 3 xor 5 <=> 11 xor 101 = 110
14:44:08 <Cybertnt> which is 6 in decimal again
14:44:10 * SyntaxNinja xors SoulSurfer with 0
14:44:17 <Cybertnt> :
14:44:18 <Cybertnt> :P
14:45:01 <SoulSurfer> lol class
14:45:15 * Cale xors SyntaxNinja with 18446744073709551615
14:46:39 <SamB> using the xor function
14:46:48 <SyntaxNinja> Cale: n0000000001111111!
14:46:52 * Cybertnt is just compiling ghc
14:47:04 <SyntaxNinja> Cybertnt: hasn't anyone told you!?
14:47:14 <Cybertnt> what?
14:47:21 <SyntaxNinja> "just compiling ghc" hah!
14:47:28 <Cybertnt> lol
14:47:29 * basti_ will soon xor himself with his own value
14:47:36 <SamB> @docs Data.Bits
14:47:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Bits.html
14:47:37 <Cale> Cybertnt: why are you compiling ghc?
14:47:53 <Cybertnt> Cale: how else am i supposed to install it on a Mac :P
14:48:00 <Cale> Download the binary?
14:48:01 <SyntaxNinja> Cybertnt: aren't there binaries?
14:48:13 <Cale> there's a nice installer package
14:48:18 <Cybertnt> well there isnt a binary for 6.4 afaik
14:48:21 <SoulSurfer> nahh there is a OS X installer package
14:48:28 <dcoutts_> basti_: no! don't leave us!
14:48:30 <SamB> 6.4? what are you, crazy?
14:48:41 <SamB> that is not unix!
14:48:43 <Cale> http://www.haskell.org/ghc/download_ghc_64.html#macosx
14:48:45 <SoulSurfer> which is what i used Cybertnt
14:48:50 <Cale> there you go :)
14:48:55 <SamB> oh, you meant GHC 6.4...
14:48:56 <basti_> im not talking about suicide
14:49:01 <SyntaxNinja> SamB: hahahahaha
14:49:18 <Cybertnt> SoulSurfer: does that run on tiger?
14:49:24 <SoulSurfer> should do
14:49:27 <dcoutts_> basti_, didn't think you were, I thought you were talking about 0
14:49:30 <Cybertnt> Cale: thanks for the link, didnt see that!
14:49:36 <Cale> It ought to run on Tiger. It ran on the beta.
14:49:38 <Oejet> SamB: You ever seen MacOS 6.0 ?
14:49:46 <SoulSurfer> 6.0?
14:49:51 <Cale> (well, the 6.2.2 release did)
14:49:52 <SoulSurfer> i started on 6.9 i believe
14:50:09 <Cybertnt> Cale: hmm well i had troubles with 6.2 on tiger
14:50:12 <Cybertnt> didnt compile at all
14:50:21 <SamB> Oejet: I don't think so
14:50:30 <Cybertnt> but since there is an installer :P
14:50:45 <SyntaxNinja> wagle was having trouble w/ 6.4 and tiger
14:50:54 <SoulSurfer> tiger rocks
14:50:58 <Cale> well, compiling GHC can be tricky -- for one thing you need another copy of GHC already, or you will have to be prepared to do some bootstrapping work
14:51:10 <basti_> dcoutts_: so?
14:51:14 <SoulSurfer> who wants to make a ghc tiger widget?
14:51:15 <Cybertnt> Cale: that might have been the reason then
14:51:19 <basti_> dcoutts_: sleep is something like 0 isnt it?
14:51:25 <Cybertnt> SoulSurfer: yeah, although i dont like mail.app that much
14:51:36 <Cybertnt> SoulSurfer: i can make a widget, what functions do you want?
14:52:24 <SoulSurfer> lol hadnt thought that far forward :P
14:52:33 <Cybertnt> haha :D
14:52:45 <SoulSurfer> i'm not using mail Cybertnt, i still prefer *cough* entourage *cough*
14:52:53 <Cybertnt> pffff!
14:52:56 <SamB> I've got OS 7.5.3 installed under Basillisk II...
14:53:08 <Cybertnt> SoulSurfer: that is just sick :P
14:53:31 <Cybertnt> i tend to stay far far away from microsoft products
14:53:41 <SoulSurfer> i know i know, but i still feel a connection from when i used to use outlook
14:53:48 <SoulSurfer> i use that and word thats about it for me
14:53:53 <Cybertnt> hehe :P
14:53:56 <SoulSurfer> oh and the microsoft mouse, the make good mice
14:54:03 <dcoutts_> basti_, I suppose so :-)
14:54:12 <jlouis> you guys are sick
14:54:23 <Cybertnt> well, i have to use word / excel /powerpoint for uni work, so thats the only ones i have installed, although i dont like it
14:54:29 <Cybertnt> its good that there is pages now though!
14:54:42 <Cybertnt> although pages is seriously laking some features compared to word
14:54:47 <Cybertnt> which is kind of sad :(
14:54:55 <basti_> jlouis: why?
14:55:11 <jlouis> basti_: because... ;)
14:55:23 <SoulSurfer> yeah it is, but word has had years on pages
14:55:31 <SoulSurfer> Cybertnt where you from?
14:55:31 <jlouis> This channel is now officially Mac+MS Windows land
14:55:39 <Cybertnt> SoulSurfer: i am from germany
14:55:44 <SoulSurfer> cool
14:55:56 <Cybertnt> jlouis: no place for linux / bsd / other unices then :/
14:56:13 <SamB> hey, I use Debian, wait a minute here!
14:56:25 <SoulSurfer> i have my haskell exam next week! wooo
14:56:38 <SamB> (how can anyone stand haskell in windows, anyhow?)
14:56:58 <Cybertnt> oh cool, i did quite well on haskell, although it was a mixed examen haskell + c. made a 2.3
14:57:12 <Cybertnt> out of 6 if anybody is unsure about german system :P
14:57:42 <SoulSurfer> SamB when they were trying to teach us haskell at uni and we had to use the windows machines, i would use putty to ssh to the linux server and use ghc
14:57:45 <basti_> (2.3 would be "still good", not almost the second lowest grade ;))
14:57:51 <Heffalump> @seen stepcut
14:57:52 <lambdabot> stepcut is in #haskell. Last spoke 3 hours, 52 minutes and 27
14:57:52 <lambdabot> seconds ago.
14:58:27 <Oejet> SoulSurfer: Weren't you punished for that?
14:58:40 <SoulSurfer> halol
14:58:47 <Cybertnt> basti_: psst, yeah 1,5 - 2,5 is considered "good"
14:59:29 <basti_> Cybertnt: there's system where "1" would be the worst grade
14:59:45 <Cybertnt> yeah i have seen that in scottland
14:59:48 <Oejet> An old Danish grading systam was way cool.  Grades from -16 to 4.  A zero would get you passed.
15:00:12 <basti_> ugh.
15:00:13 <SoulSurfer> ours is 1, 2.1, 2.2, 3, fail
15:00:54 <Cybertnt> 1 - 5 pass, 5-6 fail
15:01:24 <dcoutts_> Oejet, that's cool, they give a detailed rating of just *how* bad you are, rather than just fail "you're -14 bad!"
15:01:32 <SoulSurfer> and to be honest in haskell i will be happy with a 3, but i only need about 30% in the exam to pass :P
15:01:46 <basti_> SoulSurfer: thats almost cheating then
15:02:00 <SoulSurfer> i got 20/20 in the course work
15:02:08 <basti_> ;)
15:02:25 <SoulSurfer> and the lecutrer actually said he wants everyone to pass as he doesnt want to have to write a resit exam
15:02:59 <basti_> thats cheating.
15:03:00 <basti_> ;)
15:03:25 <Heffalump> stepcut: you around?
15:03:35 <SoulSurfer> absolutly basti_
15:03:52 <SoulSurfer> but with 10 exams to do, a couple of easy passes would be a blessing
15:03:53 <glimming> is ski around or jlouis?
15:04:02 <basti_> SoulSurfer: hehe
15:04:06 <glimming> or earth?
15:04:30 <glimming> Can someone check http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=H4.h for me?
15:04:52 <glimming> Especially
15:04:56 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=dist.h
15:04:58 <basti_> probably.
15:05:00 <glimming> for distributive laws in Haskell
15:05:53 <glimming> (proof-reading and suggesting improvements)
15:06:51 <basti_> mmmm sorry i'm not good enough in this sort of stuff to do anything near effective proofreading
15:07:18 <Cybertnt> btw, how does haskell compare against C when compiled?
15:07:36 <SoulSurfer> ooo we tried this on a recursive program
15:07:46 <SoulSurfer> haskell was only slightly worse on our test
15:07:46 <SamB> Cybertnt: C is easier to read when compiled than Haskell is
15:08:00 <Lemmih> Cybertnt: GT.
15:08:33 <SamB> Haskell is more interesting in source form, though
15:08:34 <Cybertnt> sorry my question wasnt formulated that well: How does haskell compare in terms of speed on average against C when compiled
15:08:52 <basti_> speed as in landau notation?
15:08:56 <basti_> O(f(n)) things?
15:09:05 <SamB> the haskell could run a lot slower, but will probably do something at least close to what you wanted
15:09:17 <Oejet> Cybertnt: You mean handwritten C or GHC produced C?
15:09:20 <Cybertnt> no speed as in time to finish
15:09:25 <Cale> Cybertnt: It differs by a reasonable constant factor generally.
15:09:28 <glimming> i some back-logger proof reads please mail suggestions to glimming @ kth.se   good'nite
15:09:36 <JohnMeacham> GHC is on the order of a couple times the speed of C.
15:09:40 <SamB> the haskell code will be written very much sooner, and won't take too long to run most programs
15:09:58 <Igloo> JohnMeacham: That depends entirely on what you are doing and how you write it
15:10:04 <JohnMeacham> I'd put it as somewhat faster than java, much faster than perl/python/etc..
15:10:06 <Cybertnt> ok so haskell code is not that much slower compared to C on average?
15:10:20 <SoulSurfer> yes
15:10:25 <Cybertnt> :)
15:10:33 <SamB> Cybertnt: how can you write a program in C, anyhow?
15:10:44 <JohnMeacham> Igloo: of course. I am assuming it is reasonably optimized haskell. (which can be non-trivial even for advanced haskell programmers)
15:10:46 <SoulSurfer> we did a test on C python perl java haskell and another one i cant remember
15:10:57 <Cybertnt> SamB: i guess with a text editor and then you compile it with a compiler like gcc ?
15:11:02 <SoulSurfer> C was the fastest with haskell close behind
15:11:13 <Igloo> JohnMeacham: You seem to also be assuming it is IO or list-heavy Haskell
15:11:18 <SamB> Cybertnt: thats not what I meant.
15:11:36 <basti_> were you talking about "taste" samb?
15:11:41 <Cybertnt> FORTRAN could maybe be faster than C in some cases ?
15:11:43 <Igloo> There are many things for which GHC is essentially as fast as C
15:11:44 <JohnMeacham> Igloo: I do?
15:12:21 <SamB> I was talking about how C code takes forever to do much of anything in...
15:12:33 <SoulSurfer> lol
15:12:37 <SoulSurfer> try java :P
15:12:40 <Cybertnt> haha
15:12:42 <SamB> because you have to write everything
15:13:14 <monochrom> I can write a program in C, if I get to choose which program to write.
15:13:14 <SoulSurfer> lol
15:13:14 <Cybertnt> well SamB, C might not be as convinient as other languages, but its certainly one of the fastest higher level languages out there
15:13:24 <SoulSurfer> functional programmers all the same :P
15:13:26 <SamB> Cybertnt: higher level than what?
15:13:39 <SoulSurfer> higher than machine code
15:13:41 <SamB> it was highere level 10, 20, 30 years back...
15:14:07 <SamB> but that was because people were writing stuff in assembler then
15:14:28 <SoulSurfer> ok so C is pretty low compared to stuff like java
15:14:36 <JohnMeacham> Cybertnt: Which is odd, because it is a surprisingly tricky language to write an optimizing compiler for (but dead-simple to write a non-optimizing one). to bad SISAL never took off, it would have optimized really well.
15:14:36 <SoulSurfer> but still its not assemble
15:14:57 <Cybertnt> SoulSurfer: exactly
15:15:06 <Cybertnt> JohnMeacham: what where you refering to?
15:15:31 <monochrom> Do you need the speed of execution?
15:15:42 <JohnMeacham> Cybertnt: that you said it was one of the fastest higher level languages out there.
15:15:57 <SamB> isn't FORTRAN faster?
15:16:14 <Cybertnt> SamB: well i would put them on the same level?
15:16:26 <Cybertnt> JohnMeacham: ah yes, gcc seems pretty optimized though?
15:16:44 <JohnMeacham> FORTRAN is faster. oddly enough, it is faster because it is higher level, because pointers arn't exposed (in the same way at least) pointer aliasing is not an issue. pointer aliasing is the bane of a C optimizer.
15:16:49 <SamB> I heard FORTRAN was faster... something to do with arrays and guarentees...
15:17:04 <JohnMeacham> Cpbertnt: Yes indeed. it is one of the best.
15:17:13 <Cybertnt> oh ok @ JohnMeacham, guess you are right then SamB
15:17:38 <Cybertnt> also FORTRAN doesnt check for array bounds right?
15:17:48 <JohnMeacham> Neither does C
15:18:05 <KrispyKringle> JohnMeacham: I've seen comparisons saying that the optimized compilers from e.g. intel, sun, etc, are faster on those archs.
15:18:19 <Cybertnt> does c allow you to access an array at index -1 ? i think that would throw a runtime error if not compile
15:18:40 <mwotton> yes, it does let you access it
15:18:44 <SamB> Cybertnt: of course it does.
15:18:50 <Cybertnt> hmm ok
15:18:54 <mstevens> krispy: I found sun's C compiler was faster than gcc when I tried it, but on extremely unscientific tests ("How long does the perl test suite take to run")
15:18:59 <JohnMeacham> SISAL was designed to be higher level than C (it was a functional language actually) but in just the right ways to allow an optimizing compiler to give it its best, making it the fastest code out there.
15:19:03 <mwotton> silently corrupting as it goes. :)
15:19:09 <KrispyKringle> mstevens: yeah, but one would expect it to be faster. :
15:19:10 <SamB> if that turns out to be in a page of memory which you can't read/write, then you get a runtime error
15:19:14 <Cale> Array lookups are just syntax sugar for some pointer dereferencing.
15:19:24 <Cybertnt> SamB: ah ok!
15:19:35 <Cale> so, it turns out a[n] has the same meaning in C as n[a]
15:19:36 <JohnMeacham> Yeah, accesing index -1 is not even unheard of. lots of pointerswizzing tricks involve pointers into the middle of arrays.
15:19:39 <SamB> a[b] = *(a+b)
15:20:48 <JohnMeacham> KrispyKringle: Yeah. there are better ones than gcc, but usually processor specific. There might be some commercial ones too, but I am not up on the market.
15:20:49 * SamB wonders how "how long does the perl test suite take to run" is unscientific
15:21:56 <Cybertnt> who said that SamB?
15:22:01 <mstevens> I did
15:22:05 <Cybertnt> ah ok
15:22:33 <JohnMeacham> This is part of the reason I believe that Haskell should and will compile to be _faster_ than C code. SISAL has shown that being higher level can make code faster, it is not necesarily a tradeoff. jhc is my constructive proof of this assertion.
15:22:55 <mstevens> SamB: Mostly because it runs lots of strange code, so it's not really a good benchmark of anything in particular, and there's a lot of system level stuff like process creation which I'd expect to put noise into measurements of how fast the code was.
15:23:12 <mwotton> JohnMeacham: SISAL is pretty carefully designed for performance, though.
15:23:30 <mstevens> SamB: I was using it as a fairly fuzzy measure of "which C compiler generates a faster perl interpreter for my code".
15:23:40 <SamB> mstevens: who would want a compiler with slow forks?
15:23:45 <Cybertnt> mwotton && JohnMeacham: FORTRAN too
15:24:12 <KrispyKringle> JohnMeacham: well, I've seen claims that at a higher level, you can do some profiling tricks to optimize some code--Java claims to do this, as does Psyco for Python. But in these cases, the memory footprint is still invariably bigger, and, it seems, so is the performance overhead.
15:24:16 <JohnMeacham> mwotton: by making it higher level and abstracting away machine details that would get in the way of a smart optimizer. Haskell is pure expression of intent, giving the optimizer great leeway to do things right.
15:24:21 <Heffalump> KrispyKringle: ARM's compiler (RVCT) is much better than gcc
15:24:37 <KrispyKringle> Heffalump: Yeah, figures.
15:24:41 <mstevens> SamB: Nobody, I just worry it'd be spending a lot of time in the OS doing unpredictable-time things and make the measurements wrong.
15:24:46 <Heffalump> [I work on it]
15:24:49 <KrispyKringle> Then again, Heffalump, it's an arch where there's probably not as much GCC use.
15:24:57 <Heffalump> yeah.
15:25:02 <SamB> mstevens: well, if you count only the user cpu time...
15:25:04 <KrispyKringle> I'd expect GCC to be best at more common archictectures, like x86.
15:25:08 <Heffalump> though a fair number of ARM users do use gcc.
15:25:12 <KrispyKringle> Yeah?
15:25:30 <KrispyKringle> Who does ARM development?
15:25:34 <KrispyKringle> I didn't think the adoption was that high.
15:25:53 <mstevens> gah, bloody earthlings, get everywhere
15:25:55 <Heffalump> you get them in lots of things, like PDAs
15:26:04 <Heffalump> mstevens: ? :-)
15:26:14 <SamB> Heffalump: some of which end up running mostly 68k code anyway
15:26:16 <JohnMeacham> I mean, I could be wrong. but attempting the proof is half the fun. and I am sure I can do better than ghc.
15:26:40 <KrispyKringle> Heffalump: d'oh, I was thinkint "crusoe" for some reason.
15:26:51 <KrispyKringle> heh
15:26:54 <Heffalump> SamB: true.
15:27:11 <mstevens> heffalump: I know kake (and a few others)
15:27:15 <mwotton> JohnMeacham: I suppose ghc is also a research platform - it's used for testing new features as well as Raw Blinding Speed~
15:27:24 <SamB> crusoe is supposed to run normal code anyway...
15:27:29 <Heffalump> the Nintendo DS has a couple in, for example
15:27:35 <Heffalump> mstevens: ah (who else?)
15:27:43 <KrispyKringle> SamB: yeah, but it runs x86 code in a software emulator, doesn't it?
15:28:02 <SamB> KrispyKringle: never underestimate the performance of JIT
15:28:11 <KrispyKringle> Wow. The Transmeta website is weird.
15:28:20 <KrispyKringle> "Since time immemorial, this mysterious website was an Internet version of a Zen koan. Then, suddenly, it was transformed radically into ... a tease."
15:28:38 <SamB> though it seems likely to yield less benefits when done for lower-level code...
15:28:43 <mwotton> John: are you looking at supporting things like TH and hs-plugins in jhc? I'm a bit worried about the situation that seems to be developing - there are a reasonable number of haskell compilers, but almost all of the time i end up using some ghc-specific extension and get locked in.
15:28:54 <mstevens> heffalump: to varying degrees, doop, david woolger, mbm, juliet, huggie.
15:28:58 <mwotton> although that is arguably my own fault. :)
15:29:11 <KrispyKringle> SamB: not necessarily. Intel does essentially the same thing, only the "emulation" is microcoded rather than software.
15:29:21 <Heffalump> ah, the London crowd :-)
15:29:25 <mstevens> indeed
15:29:30 <SamB> KrispyKringle: well, that is not the same thing...
15:29:31 <KrispyKringle> Making it software seems smarter, in a sense, since you can cut out the microcode crap and it's more upgradeable.
15:29:42 <KrispyKringle> No, it's not the same thing, but both have advantages.
15:29:51 <SamB> I was under the impression that the microcoded instructions were horribly slow...
15:29:59 <JohnMeacham> mwotton: which is why more compilers will be a good thing. haskell is in less danger of becoming implementation defined.
15:30:03 <KrispyKringle> I'm not sure about that.
15:30:10 <Heffalump> how is jhc doing?
15:30:15 <KrispyKringle> The reason behind it was an inability to implement features in their awful CISC ISA, apparnetly.
15:30:18 * Heffalump needs to get round to buying a new machine and trying it out
15:30:40 <KrispyKringle> So internally, the Pentiums became MIPS-ish, but they wanted to maintain outward compatibility with the same ISA.
15:31:03 <SamB> whereas the core instructions that get rewritten to RISC uOps run much faster
15:31:09 <KrispyKringle> I'm not sure what the implications are of doing it in microcode versus software. I would imagine software is slower, but probably not by a whole lot, since Transmeta does it.
15:31:12 <JohnMeacham> Heffalump: fine. there is a changelog on the homepage. typechecking is now speedy, once I fix the points-to analysis, that is the last big bottleneck. then it is just a matter of making it faster and faster.
15:31:44 <Heffalump> cool
15:31:54 <KrispyKringle> SamB: well, yeah, that's why they did the RISC implementation.
15:32:22 <KrispyKringle> anyway, i hate hardware
15:33:18 <JohnMeacham> I imagine jhc will support any extensions that are desired. TH is a long shot, I'd much prefer to see a standalone TH preprocessor, seems like a more productive goal. but I hope to implement everything that we reasonably think should be in the next revision of the language as well as experimental features that are easier to implement in jhc than ghc for whatever reason.
15:34:02 <Heffalump> is TH less of a dogs breakfast these days?
15:34:38 <SamB> I don't know that software is necessarily slower. I mean, self-modifying code is quite out of style.
15:35:13 <SoulSurfer> nahh self modifying code is great
15:35:19 <mwotton> JohnMeacham: one of the things that seemed a bit harder to me with the whole-world optimisation approach was runtime module loading. would you just forgo optimisation when you load modules?
15:35:20 <SamB> SoulSurfer: say what?
15:35:39 <SoulSurfer> i want to do a final year project on self modifying code so it does something different every time for no really reason or purpose
15:35:43 <SoulSurfer> or failing that
15:35:58 <SoulSurfer> a javascript web browser so you can run it in other web browsers
15:36:06 <KrispyKringle> hahaha
15:36:08 <mwotton> SamB: well, it depends on your definition - technically, you could say hs-plugins style runtime loading of modules is self-modifying. It's just a bit more controlled.
15:36:36 <JohnMeacham> mwotton: I don't know yet. modules with strict interfaces are no problem. optimizing through an dynamically loaded interface is a problem for any haskell compiler, not just jhc.
15:36:46 <SamB> mwotton: I would say that self-modifying code was code that altered instructions in its own instruction stream...
15:37:58 <JohnMeacham> mwotton: but that is one of the problems I hope to solve.
15:40:09 <mwotton> JohnMeacham: Sure, but GHC has a whole bunch of runtime system machinery in there - it'd be conceivable to jimmy a runtime optimiser in there as well, hooking into the profiling system. jhc goes down to standard C with no RTS, doesn't it?
15:40:56 <mwotton> SamB: well, if you want to get all Operating Systems about it, sure. but surely the intent is more important than the specific mechanism?
15:41:45 <JohnMeacham> mwotton: yup. so jhc will have to find a different solution.
15:44:47 <MachinShin> hey all
15:44:54 <JohnMeacham> I mean, honestly, ghc sounds like it would harder to deal with. all that RTS state to keep updated.. but perhaps that is because I have been thinking of things in terms of jhc for so long.
15:46:02 <Cybertnt> hmm, say i start of with a number and input that into a function, then i would want to use the result to put into the same function again and again. After a certain number of passes i would like to return true, all fairly simple. However how can i make it abort if the output after n passes, doesnt match a given number?
15:47:20 <Oejet> @type repeat
15:47:26 <lambdabot> repeat :: forall a. a -> [a]
15:47:31 <Oejet> @iterate
15:47:32 <lambdabot> Unknown command, try @listcommands.
15:47:38 <Oejet> @type iterate
15:47:41 <lambdabot> iterate :: forall a. (a -> a) -> a -> [a]
15:47:52 <Cybertnt> roger that :)
15:48:03 <JohnMeacham> yawn. I am starting to be incoherent though. I better take a nap.
15:48:22 <Oejet> JohnMeacham: Where can I get your compiler?
15:48:56 <Heffalump> someone tell me what kind of AMD64 motherboard I should get.
15:49:23 <JohnMeacham> http://repetae.net/computer/jhc - but it is still in development. mainly just useful for people that want to hack on it or are curious.
15:52:16 <dcoutts_> Heffalump, I think I got an Asus A8V, nearest equivalent I can see on the site I bought it from it here: http://www.overclockers.co.uk/acatalog/ASUS_Socket_939.html "Asus A8V Rev.2 Deluxe". Mine was the non-deluxe version :-)
15:52:43 <Heffalump> dcoutts_: I still wish I'd followed your suggestion for cardinal :-)
15:53:23 <Heffalump> ah, hmm, dual graphics card unnecessary, this is for a headless box
15:53:28 <dcoutts_> Heffalump, On the other hand it may have been the Abit AV8: http://www.overclockers.co.uk/acatalog/ABIT_Socket_939.html  Bloddy things have got such similar names!
15:53:45 <Heffalump> heh
15:55:16 <dcoutts_> Heffalump, what was my suggestion for cardinal (and what's cardinal?)
15:55:44 <Heffalump> AMD64 rather than P4 - it's that compute server we bought last year
15:56:01 <Heffalump> you ought to have root on it, you know :-) (same password as musketeer)
15:58:01 <dcoutts_> oh, yes :-)
15:59:11 <dcoutts_> I'm very happy with my amd64 :-) and in 9months or a year or so you'll be able to get dual code amd64s that'll plug into your existing amd64 motherboard :-)
15:59:24 <dcoutts_> code/core
16:00:24 <dcoutts_> when is ghc rts going genuinely multithreaded? :-)
16:00:32 <Heffalump> will they all be socket compatible, then?
16:00:42 <Heffalump> there's nothing I need to loo kout for now to make sure it is in future?
16:01:34 <dcoutts_> the dual core amd64's are socket compatible with the existing amd64s (so long as you get socker 939 rather than the older 754)
16:01:37 * Heffalump justifies the completely off-topic conversation to the rest of the channel by noting that he wants this mainly for doing Haskell Debian work.
16:02:26 <dcoutts_> me too! The main reason I upgraded was bacause I needed to run these gargantuan memory hungry haskell apps! :-0
16:03:03 <Heffalump> semiconductor companies should pay David Roundy a commission ;-)
16:10:52 <SyntaxNinja> Heffalump: sorry I haven't replied to your email. i'm a bit swamped. will get to it ASAP
16:10:55 <SyntaxNinja> that goes for anyone else too ;)
16:11:24 <Heffalump> SyntaxNinja: no problem, I'm a bit swamped for the next week or so anyway
16:14:25 <Oejet> Too bad TheHunter isn't around.  The binding has an overhead of the difference between 530s and 302s for decompression and compression of the Linux kernel.
16:14:42 <Oejet> Compared to bzcat that is.
16:32:52 <Cybertnt> Oejet: i see how the iterate would help, but i if i want 10 passes, how can i check that the result it returns is valid after the 1st, 2nd, ... pass?
16:34:45 <Cybertnt> say i do take 10 (iterate (2*) 1) and want to check after each pass that it matches with a valid answer like [1,2,4,8,16,32,64,128,256,512]. That way it wont have to calculate all 10 items if something goes wrong after the 2nd pass. (Ok that example will work for all 10 passes, but just as an example :P)
16:36:49 <Lemmih> Cybertnt: You know that Haskell is lazy, right?
16:37:15 <Cybertnt> heh you reckon i should calculate all 10 passes and do a check afterwards?
16:37:21 <Cybertnt> but wouldnt that be unefficient?
16:41:15 <Oejet> You could zip the two lists together.
16:41:30 <Cybertnt> ok!
16:43:00 <Oejet> Grrr, my evil memory sharing optimization only shaved 3s of those 530s.
16:46:07 <mugwump> what's the normal depiction of "such that" in a mathematical axiom?  Is it | or : ?
16:47:48 <cognominal> what is the meaning of ! in haskell?
16:48:47 <cognominal> mugwump, I try to understand the ! in Types.hs
16:49:00 <arjanb> @type (!)
16:49:04 <Cybertnt> Oejet: like that? checktwist seed = zipWith (\x y -> (mod x 6) + 1 == y) (take 14 (iterate twist seed)) [2, 6, 4, 5, 2, 3, 3, 1, 5, 1, 5, 1, 6, 3] <-- but that still doesnt safe me from making all parses
16:49:06 <lambdabot> bzzt
16:49:22 <Oejet> @type (Data.Array.!)
16:49:23 <lambdabot> (Data.Array.!) :: forall e i.
16:49:23 <lambdabot>       (GHC.Arr.Ix i) =>
16:49:23 <lambdabot>       GHC.Arr.Array i e -> i -> e
16:49:42 <cognominal> like that
16:49:45 <cognominal> data Type
16:49:46 <cognominal>     = MkType !String      -- ^ A regular type
16:49:59 <Oejet> Ah, that's a strictness flag.
16:50:03 <cognominal> ??
16:50:20 <cognominal> where is that documented?
16:50:21 <Oejet> There is some text about it in the GHC manual.
16:51:06 <Oejet> It means that that value will always be evaluated strictly.
16:51:29 <Oejet> It's an optimization trick.
16:51:40 <Lemmih> @google strictness site:haskell.org/ghc
16:51:41 <cognominal> meaning not lazily?
16:51:42 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/faster.
16:51:42 <lambdabot> html
16:51:55 <SamB> isn't that in the report too?
16:54:34 <SamB> I wonder how I should implement MIX in haskell...
17:04:21 <SamB> hmm, how should I represent the sign field...
17:05:04 <SamB> and should I use decimal or binary?
17:07:19 <SamB> oh well, I guess I'll go for binary.
17:09:32 <Oejet> Night all.
17:18:26 <reffie> @ghc
17:18:26 <lambdabot>  GHC stack-space overflow
17:18:26 <reffie> @ghc
17:18:26 <lambdabot>  parse error on input
17:18:26 <reffie> @ghc
17:18:26 <lambdabot>  Occurs check: cannot construct the infinite type
17:18:26 <reffie> :/
17:18:26 <SamB> oh boy, hmm, I have to decide whether to make -0 equal to +0 or not...
17:18:50 <SamB> I guess it would not be horrible to make them equal...
17:23:24 <Pseudonym> darcs get http://andrew.bromage.org/darcs/numbertheory/
17:23:32 <Pseudonym> My first attempt at darcs AND cabal.
17:23:45 <Pseudonym> Could someone please have a look and let me know if I've done anything wrong?
17:24:35 <Pseudonym> I know the Haddock documentation isn't so good. :-)
17:25:09 <fraxtal> I hear of so many strange languages from lurking in here
17:25:50 <fraxtal> I took a look at that proof veriying language
17:25:53 <fraxtal> what was the name of it?
17:25:56 <fraxtal> coqs I think
17:27:12 <fraxtal> pretty wild
17:29:11 <foxy> pseudonym: I tried running main.exe but got an error missing shell32.dll
17:29:38 <Pseudonym> Hmmm?
17:29:45 <Pseudonym> There isn't a main.exe there.
17:29:56 <Pseudonym> Oh, I fixed some module name problems.  Might want to pull again.
17:30:05 <foxy> pseudonym: that was my executable name
17:30:28 <Pseudonym> Hmm.
17:30:32 <Pseudonym> Well it sounds like a GHC problem.
17:30:39 <foxy> I don't think Cabal works on windows
17:30:48 <Pseudonym> Possibly not.
17:30:56 <Pseudonym> I haven't actually tested the Cabal bit.
17:31:10 <Pseudonym> Who needs testing when you can ship it?
17:32:32 <MachinShin> that's what the users are for! )
17:32:33 <MachinShin> :)
17:32:38 <Pseudonym> Right!
17:32:51 <foxy> When I tried running a Cabal package dependent program yesterday, ghci fell over when cabal was linking because of an undefined symbol
17:33:31 <foxy> I think there
17:33:59 <foxy> I think there are libraries missing in the extraLibs field of the ghc Cabal distribution
17:34:09 <foxy> package.conf file
17:34:18 <foxy> (on windows)
17:35:43 <SamB> hmm, why do I not want to implement (*) for MixWord...
17:37:35 <dvtoo> ok, so, perhaps this is a silly question, but where could I find the .hc files for bootstraping on unsupported platforms?
17:37:58 <dvtoo> or go about generating them on a supported platform?
17:38:55 <dvtoo> oh, sorry, nm, I see
17:40:00 <dvtoo> anyone around familar with the solaris sparc issues with 6.4, or have a pointer to what the issue actually is?
17:42:52 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi"]' by lambdabot
17:43:22 <Pseudonym> @topic-snoc "http://www.haskell.org/tmrwiki/IssueTwo"
17:43:23 <lambdabot> I do not know the channel "http://www.haskell.org/tmrwiki/IssueTwo"
17:43:29 <Pseudonym> @topic-snoc #haskell "http://www.haskell.org/tmrwiki/IssueTwo"
17:43:30 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","\"http://www.haskell.org/tmrwiki/IssueTwo\""]' by lambdabot
17:43:36 <Pseudonym> That's better.
17:46:09 <Lemmih> dvtoo: GHC 6.4 is kinda experimental. Is there some reason you can't use GHC 6.2?
17:46:29 <dvtoo> yeah, pugs requires 6.4
17:47:26 <dvtoo> and well, the traffic on the mailing list kind of indicated that the issue with it building on solaris/sparc is linking related, which is something I'm fairly familar with
17:47:34 <dvtoo> so was hoping maybe I could get some help resolving it
17:48:01 <Cybertnt> Top level:
17:48:01 <Cybertnt>     No instance for (Show (Integer -> Integer))
17:48:01 <Cybertnt>       arising from use of `print' at Top level
17:48:01 <Cybertnt>     Probable fix: add an instance declaration for (Show (Integer -> Integer))
17:48:01 <Cybertnt>     In a 'do' expression: print it
17:48:08 <Cybertnt> hmm
17:48:38 <mauke> you're trying to print a function?
17:48:49 <Cybertnt> trying to compile with ghc
17:48:52 <Cybertnt> main n
17:48:52 <Cybertnt>  | checktwist n == False = main (n + 1)
17:48:52 <Cybertnt>  | otherwise             = n
17:48:57 <Cybertnt> that would be the main function
17:49:44 <mauke> isn't main supposed to be an IO () object?
17:50:06 <Cybertnt> i guess so :/, i never did this
17:51:37 <mauke> I get     Couldn't match `IO a' against `Int -> Int' for your code
17:52:10 <Lemmih> dvtoo: Have you encountered any linking errors yet?
17:52:11 <Heffalump> GHC 6.4 is the most recent stable release, you know..
17:52:22 <Heffalump> it's not really 'experimental'
17:52:35 <Cybertnt> mauke: :s
17:53:05 <Lemmih> Heffalump: Cabal is very experimental.
17:53:05 <mauke> prefix s matches multiple commands (set,show)
17:53:23 <dvtoo> no, I can't even get 6.2.2 to bootstrap, it sigbus's for me during the build ;)
17:53:36 <Cybertnt> mauke: i tried using show n, but that doesnt work
17:53:48 <dvtoo> which might be a linking problem, but it's hard for me to troubleshoot that without some hints ;)
17:54:15 <Lemmih> dvtoo: Install a binary version of GHC first.
17:54:27 <dvtoo> yeah, I tried that
17:54:31 <dvtoo> I can try again though ;)
17:55:21 <dvtoo> so you'd recommend using the binary version of 6.2.2 to buld 6.4, or use it to build 6.2.2  then use that to build 6.4?
17:56:14 <Lemmih> The former.
17:56:31 <dvtoo> ok
17:59:29 <dvtoo> I'm able to do builds on sol8 and sol10 sparc and sol10 x86 if I can get this working, so at least people would stop asking how to do it ;)
18:03:31 <dvtoo> is there some sort of make test that I can run on this 6.2.2 binary package to verify that everything is working as expected?
18:06:14 <dvtoo> well, ghci doesn't even work, it's using an old version of readline, I'll fix that first I guess ;)
18:10:36 <dons> dvtoo, there's the testsuite. you could run that.
18:10:51 <dons> also, check that you can build ghc with the compiler you build.
18:11:04 <dons> (ghc and libraries exercise a lot of Haskell)
18:11:52 <dcoutts> @seen shapr
18:11:53 <lambdabot> I saw shapr leaving #haskell 1 day, 9 hours, 11 minutes and 32
18:11:53 <lambdabot> seconds ago.
18:12:51 <dvtoo> yeah, I need to build an ancient version of readline first, then probably an old ncurses too ;)
18:13:02 <dvtoo> well, maybe I don't, but getting ghci working seems like a good first step
18:26:25 <Cybertnt> @help
18:26:26 <lambdabot>  @help <command> - ask for help for <command>
18:26:45 <Cybertnt> @help commands
18:26:46 <lambdabot>  @help <command> - ask for help for <command>
18:26:50 <Cybertnt> hmm lol
18:31:36 <dons> @help help
18:31:37 <lambdabot>  @help <command> - ask for help for <command>
18:31:42 <dons> @help seen
18:31:43 <lambdabot> Report if a user has been seen by the bot
18:31:52 <dons> @help eval
18:31:53 <lambdabot>  @eval expr - evaluate the lambda calculus expression, expr
18:32:05 <dons> @help listcommands
18:32:05 <lambdabot> listcommands [module|command]
18:32:05 <lambdabot> show all commands or command for [module]
18:40:52 * Lemmih always giggles when he reads rants about "making Haskell useful beyond an academic context".
18:45:12 <foxy> @eval (^x.x) ^x y.y x
18:45:13 <lambdabot> (line 1, column 2):
18:45:13 <lambdabot> unexpected "^"
18:45:13 <lambdabot> expecting simple term
18:45:22 <foxy> @eval (\x.x) \x y.y x
18:45:24 <lambdabot> <<EM Dynamic -> EM Dynamic>>
18:45:55 <blackdog> Lemmih: because you don't think it's possible, or because it's already useful?
18:46:12 <xyzp> Or because it's not useful in an academic context, either?
18:46:54 <xyzp> Apparently my sense of humor is a bit dry.
18:47:36 <blackdog> Yes. I wouldn't cancel school for that little shit.
18:47:42 * blackdog is wilfully obscure
18:49:16 <xyzp> I always find some amusement when Paul Graham refers to Haskell.
18:49:39 <Lemmih> Because it mostly reflects the user's inability to google or reading manuals.
18:50:16 <xyzp> How?
18:52:47 <xyzp> I may be presuming a bit much, but typically when people refer to spreading any fringe language to a 'useful' realm it has more to do with the volume of its adoption rather than the feasability of its usage for solving some problem for which the existence of a solution composed with it would change their opinion.
18:56:43 <Lemmih> Take for example the latest mail to glasgow-haskell@. A guy ranted about incomplete/unmaintained graphics toolkits while I'm sure there are stable bindings to OpenGL and SDL for both GHC and Hugs.
18:56:55 <xyzp> Other times it's a code word for 'I wish x had some feature y.'
18:57:08 <xyzp> Was it Brandon?
18:57:32 <Lemmih> Nope, Mark Brooks.
18:57:35 <xyzp> Ah.
18:58:43 <xyzp> I distinctly recall the existence of a usable OpenGL binding.
19:04:36 <Pseudonym> Has Paul Graham referred to Haskell in a way that's not in passing?
19:04:43 <xyzp> No.
19:04:48 <xyzp> Well, not to my knowledge.
19:05:05 <xyzp> I've seen him speak and mention it briefly in a condescending manner.
19:05:20 <Pseudonym> Like the way I used to refer to C++ before I actually used it. :-)
19:05:31 <MachinShin> lol
19:06:13 <dvtoo> well, finally got old readline and ncurses built ;)
19:06:23 <Pseudonym> I personally think that's true of any language worth learning (in the Perlis sense).
19:10:51 <xyzp> I wonder if I joined this Harmony mailing list because I hate myself.
19:11:14 <Pseudonym> Is tht Harmony the Qt replacement, or Harmony the Apache Java thingy?
19:11:19 <xyzp> The latter.
19:11:27 <xyzp> I believe the former expired long ago?
19:12:47 <xyzp> I was curious if it would simply follow the pattern some quasi free software social groups do.
19:13:11 <xyzp> Namely to become little more than a replacement for a social life with philisophical discussions about licenses or other such things.
19:13:44 <Pseudonym> Like Tunes, you mean?
19:14:01 <xyzp> I must confess ignorance of their behavior.
19:14:24 <Pseudonym> That's not a confession, it's a boast.
19:15:49 <MachinShin> lol
19:16:11 <FrederikEaton> when i have to give a function a name which includes some indication of a type, should the type be first or last? e.g. rotatePoint or pointRotate?
19:19:33 <blackdog> Fred: I like verbnoun myself, but others may disagree.
19:20:50 <FrederikEaton> i guess there's no point in keeping operations on similar types close together in a lexical sorting, what with electronic searching...
19:20:57 <FrederikEaton> yet somehow it seems more organized
19:21:07 <FrederikEaton> ... to put the type first
19:21:47 <foxy> you could use qualified modules import Point as P --> P.rotate
19:21:53 <blackdog> what she said.
19:22:25 <dvtoo> ah, so, I got to the linking issue
19:22:41 <blackdog> really, if you're going to be that structured, you might as well get some support from the language - just call it rotate and qualify it...
19:22:49 <FrederikEaton> well in this case things have a reason to be in the same module
19:24:02 <blackdog> a good reason? :)
19:24:38 <foxy> is there a way to get ghci to compile to .o for future reloads?
19:26:54 <dvtoo> oh, I think I see the issue
19:27:04 <dvtoo> it's not building libghccompat right
19:28:30 <dvtoo> I imagine this works if you're using gnu ld with gcc, which no one on solaris does
19:29:09 <Pseudonym> FrederikEaton: My rule of thumb is that a function which represents an action should have the verb first.
19:29:23 <Pseudonym> If it represents a projection, then make it a noun.
19:29:37 <Pseudonym> So: addRational :: Rational -> Rational -> Rational
19:29:45 <Pseudonym> but: numerator :: Rational -> Integer
19:30:40 <FrederikEaton> hmm. that's almost what i've been doing
19:35:28 <Pseudonym> Actually, I've been playing with alternative schemes in the number theory library.
19:35:34 <Pseudonym> Traditionally, you'd write: isPrime 42
19:35:39 <Pseudonym> But I make you write: is Prime 42
19:35:57 <Pseudonym> class TestableProperty prop a | prop -> a where
19:36:00 <Pseudonym>     is :: prop -> a -> Bool
19:36:22 <foxy> what does that class definition mean? (with the  | and the -> )
19:36:23 <Pseudonym> Possibly a little _too_ generic for this purpose, but I want to see what using a library like this would be like.
19:36:31 <Pseudonym> That's a functional dependency.
19:36:34 <Pseudonym> @wiki FunDeps
19:36:34 <lambdabot> http://www.haskell.org/hawiki/FunDeps
19:38:20 <dvtoo> so, any equivalent of -Wl in ghc?
19:39:12 <dvtoo> (gcc's -Wl that is)
19:39:20 <Pseudonym> What does that do?
19:39:52 <Pseudonym> It turns on some warnings, obviously.
19:39:59 <Pseudonym> But I usually use -Wall -Wpedantic.
19:40:01 <dvtoo> actually, no
19:40:06 <dvtoo> it passes flags into the linker
19:40:10 <Pseudonym> Ah.
19:40:40 <dvtoo> ah ha, -optl
19:40:48 <Pseudonym> Right.
19:40:51 <Pseudonym> I was about to say that. :-)
19:40:59 <Pseudonym> It's kind of annoying that it's -W but it's not a warning.
19:41:01 <dvtoo> it takes a single argument?
19:41:22 <dvtoo> ie, if I need to pass -z allextract, I need to do -optl -z -optl allextract?
19:41:34 <Gahhh> quoting may work ?
19:41:43 <dvtoo> good idea
19:42:01 <Pseudonym> Otherwise, experiment.
19:42:02 <dvtoo> oh, heh
19:42:05 <dvtoo> it's calling into gcc
19:42:18 <dvtoo> so I need to do -optl "-Wl,-z,allextract"
19:43:29 <xyzp> Beware the mighty -Wp -Wa -Wl
19:43:34 <xyzp> Hmm.
19:43:49 <Pseudonym> Quoting of quoting of quoting.
19:44:01 <dvtoo> well, didn't fix the problem anyway ;)
19:44:03 <Pseudonym> Next exercise: Write a self-replicating program using only command-line options.
19:44:05 <dvtoo> but I'm in the ballpark ;)
19:46:27 <Pseudonym> Lunch.
19:46:28 <Pseudonym> BBL
20:02:19 <dvtoo> ok, well, turning off splitobjs solved the immediate problem
20:02:29 <dvtoo> let me build ghc-pkg
20:03:13 <dvtoo> anyone have a ballpark number on how long it takes to bootstrap 6.4?  this is a fairly slow box, I'm thinking sleep is a good idea
20:04:24 <dvtoo> huh, nm, it bombed out again
20:07:48 <Gahhh> I remember figures in "hours" from people. expect "long" if the box is slow.
20:08:07 <Gahhh> no binaries available for your platform ?
20:08:46 <dvtoo> nope
20:09:12 <dvtoo> kind of hoping to fix that, or at least fix it so it bootstraps cleanly
20:09:33 <dvtoo> righto, SIGILL in genprimopcode
20:09:43 <dvtoo> this is the problem I had before
20:11:05 <Gahhh> which platform is it ?
20:11:09 <dvtoo> sparc/solaris
20:12:03 <Gahhh> are you using ghc 6.2.2 to compile ?
20:12:07 <dvtoo> yup
20:14:34 <dvtoo> I'm wondering if I'd be better off bootstraping from .hc files
20:17:08 <dvtoo> ah ha
20:17:16 <dvtoo> compiling it without optimizations fixed it for now
20:17:30 <dvtoo> I should just turn that off globally for now
20:17:46 <dvtoo> kind of weird that that's turned on for stage1 compiler anyway
20:19:59 <dvtoo> ah, it doesn't appear to have obvious flags for the different stages
20:20:01 <dvtoo> that'd explain it
20:21:23 <dvtoo> just going to turn off -O globally until I get this to build once, I can rebuild it with 6.4 with -O if it works
21:36:44 <FrederikEaton> what's wrong with this:
21:36:45 <FrederikEaton> class Sym a where
21:36:45 <FrederikEaton>     allSyms :: [a]
21:37:00 <Pseudonym> What's the error message.
21:37:16 <FrederikEaton> Couldn't match kind `*' against `k_a2aS -> *'
21:39:28 <dons> compiles for me.
21:39:52 <FrederikEaton> oh thanks for checking. well i just noticed that when i change the name the error goes away
21:39:57 <Pseudonym> You might have another "Sym" in scope.
21:40:03 <Pseudonym> Which means something else.
21:41:49 <FrederikEaton> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
21:41:50 <FrederikEaton>         Unify.unifyTauTyLists: mismatched type lists!
21:42:17 <dons> very nice :)
21:42:37 <dons> is the module small? can you post it somewhere?
21:42:38 <Trevion> Eh.  I prefer "Urk!  Inventing strangely kinded void tycon."
21:42:56 <FrederikEaton> i think i'm in control, thanks though
21:43:17 <FrederikEaton> it's just that the compiler message was far from the actual error
21:43:26 <FrederikEaton> that threw me off
21:59:48 <foxy_> @wiki cabal
21:59:50 <lambdabot> http://www.haskell.org/hawiki/cabal
22:00:35 <SyntaxNinja> cabal!
22:00:37 <dons> FrederikEaton: I was more concerned that you produced an 'impossible' from the type checker -- that shouldn't happen.
22:00:55 <dons> possibly (probably?) a compiler bug. unless you're doing something evil
22:01:03 <SyntaxNinja> FrederikEaton is powerful
22:03:31 <FrederikEaton> i saved the directory so i can reproduce it
22:03:43 <FrederikEaton> but man, submitting bugs is so hard
22:04:03 <FrederikEaton> i always use the wrong From address by accident and then my message gets rejected like 10 times
22:04:11 <FrederikEaton> well that's exaggerating
22:38:25 <MachinShin> night all
22:39:22 <musasabi> morning
22:43:11 <Cybertnt> is there a way to get an Integer to an Int again, problem is i have a variable which is an Integer but i want to execute chr with it as parameter
22:49:29 <mflux> (fromInteger i)::Int (if you want to be explicit)
22:54:54 <Cybertnt> @type fromInteger
22:54:58 <lambdabot> fromInteger :: forall a. (Num a) => Integer -> a
22:58:02 <lispy> this is probably a common question, but if i want to define multiple modules within my project, how do i get ghc to find them?  For example, I defined a module Email, and in another module I put import Email.  The files are in the same directory
23:01:30 <lispy> OH
23:01:35 <lispy> it's case sensitive
23:01:43 <lispy> i have to rename my module :)
23:28:39 <Cale> Cybertnt: fromIntegral is a bit more general
23:28:47 <Cale> @type fromIntegral
23:28:48 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
23:30:46 <pediddle> why even bother having both?
23:31:06 <xerox> Do you know how to add space between lines in LaTeX?
23:31:11 <Cale> fromInteger is the fromIntegral for the Integer type
23:31:20 <reffie> xerox #verbaetc
23:31:46 <pediddle> xerox: \bigskip, \smallskip, \medskip i think
23:32:10 <xerox> pediddle, I mean, in general, in the document
23:32:22 <reffie> ah
23:32:32 <reffie> he wants double spacing
23:32:36 <xerox> Exactly
23:32:43 <reffie> no clue how to do it :((
23:32:44 <pediddle> oh, \documentclass[doublespace]{article} IIRC
23:32:50 <pediddle> or \documentclass[onehalfspace]...
23:32:51 <xerox> Let me try, thanks
23:33:12 <Cale> http://www.image.ufl.edu/help/latex/spacing.shtml
23:34:06 <pediddle> xerox, check Cale's link, you have to \usepackage{setspace} first
23:34:07 <pediddle> thanks Cale
23:35:05 <FrederikEaton> i want to filter my command line arguments for all flags which have a certain constructor
23:35:37 <FrederikEaton> is there a way using generics which is shorter than filter (\f -> case f of Constr _ -> True; _ -> False)?
23:35:53 <FrederikEaton> (i mean MyConstr)
23:35:55 <reffie> last night i dreamed of you
23:36:06 <FrederikEaton> who me?
23:36:53 <xyzp> I'm the man of your dreams.
23:37:20 <FrederikEaton> pinch me
23:37:37 <xyzp> If that's what does it for you.
23:37:39 <Cale> FrederikEaton: take the function (\f -> case f of Constr _ -> True; _ -> False) and give it a name like isConstr at least :)
23:37:48 * juhp discovers XMLDocWays ;)
23:37:50 <xerox> Great, thanks much everyone, i'm in a _hurry_ !
23:38:29 <FrederikEaton> Cale: but surely there is something more automatic with generics
23:38:53 <xyzp> Me too, and yet I seem to keep wasting occasional moments on IRC.
23:39:18 <pediddle> i was always disappointed that the lambda syntax doesn't allow giving a list of pattern-matching alternatives
23:39:33 <pediddle> without case, that is
23:40:34 <xyzp> What syntax would you propose?
23:41:04 <pediddle> (\p1 -> e1 | p2 -> e2 | ...)
23:41:09 <pediddle> or something
23:41:15 <xyzp> Ah.
23:42:04 <pediddle> or maybe ; instead of | to match case's syntax
23:43:43 <FrederikEaton> oh i found it. toConstr :: a -> Constr
23:44:11 <Cale> pediddle: (\x -> case x of ...)
23:44:32 <Cale> well, you wanted without case I suppose
23:44:41 <Cale> but I don't really see the problem with using case
23:44:41 <pediddle> i know, but that's like 10 extra keys to type :)
23:44:49 <pediddle> it's just annoying for quick 1-liners
23:44:52 <pediddle> no big problem
23:45:08 <pediddle> and it wastes the variable if that's all you need it for
23:46:08 <Pseudonym> (\x -> case x of { p1 -> e1; p2 -> e2 })
23:46:20 <Pseudonym> Right, like Cale said. :-)
23:46:51 <pediddle> anyway, is there a reason why (\p1 -> e1; p2 -> e2) never made it?
23:50:15 <mflux> I suppose it would be a replacement for case if it did exist; flip foo (\42 -> True; _ -> False) ?
23:50:41 <mflux> ..and you wouldn't need the keyword 'case'!
23:54:30 <Gahhh> Pseudonym: What do you think of this C++ snippet: http://www.artima.com/forums/flat.jsp?forum=106&thread=107360
23:55:42 <Pseudonym> Cute.
23:56:55 <Gahhh> is that sarcasm ?
23:57:22 <Pseudonym> No, it is cute.
