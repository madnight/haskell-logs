00:02:49 * boegel greets the haskell-world
00:04:53 <kaol> @yow
00:05:14 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
00:05:33 <kaol> @vixen are you always that slow?
00:05:35 <lambdabot> i truely am
00:06:28 <blackdog_> dons: no, not yet. PF practically wet itself, so i'll be checking it out.
00:12:23 <dons> 2ser album of the month too
00:15:12 <Itkovian> meuning
01:05:04 * Lemmih has just used unsafeInterleaveIO in a non-toy program for the first time.
01:11:32 <[TWiSTED]> given a function parseElement; which changes a String into a list of tuples eg. parseElement "hi123" = [("hi",123)] , i need to make a function that does the same as parseElement but allowing it to split the string up multiple times eg. "hi12hey34ahoy56" = [("hi",12) , ("hey",34) , ("ahoy",56)] . i know this can be done recursively but am unsure how to exactly go about it.
01:12:46 <metaperl> [TWiSTED]: did you write parseElement yet?
01:12:51 <[TWiSTED]> yep
01:12:57 <[TWiSTED]> parseElement s = (s', parseNumber i)
01:12:58 <[TWiSTED]> 	            where (s', i) = break isDigit s
01:13:18 <[TWiSTED]> and parseNumber is
01:13:21 <[TWiSTED]> parseNumber s | s == "" = 1
01:13:21 <[TWiSTED]>               | otherwise = read s
01:13:47 <Lemmih> You don't wanna give 'i' to parseNumber.
01:14:48 <[TWiSTED]> that just means if you input "hello" itll make it ("hello",1)
01:16:17 <Lemmih> Breaking "hi12hey34" to ["hi12","hey34"] is harder than breaking "hi12hey34" to (("hi",12),"hey34").
01:17:41 <[TWiSTED]> i want [("hi",12),("hey",34)] tho
01:19:57 <Lemmih> Indeed, but if you can break "hi12hey34" to (("hi",12),"hey34") then doing it again on "hey34" is easy.
01:20:24 <[TWiSTED]> o rite
01:20:25 <[TWiSTED]> yea
01:20:36 <[TWiSTED]> but can i store it in a list not in another tuple?
01:23:56 <Lemmih> The final result should be a list but the temporary state is ideal for a tuple.
01:24:29 <kzm> I notice there was some discussion on the libraries list about collection classes again.
01:24:38 <[TWiSTED]> o ok
01:24:54 <kzm> I wonder if it would be easier if a map was treated as a function from index to element, and a set a function from index to bool?
01:25:14 <kzm> I haven't thought it through, but it seems like an obvious idea, so I guess it must have been considered?
01:25:22 <[TWiSTED]> so i would use recursion for "hey34" and anything there after right?
01:25:45 <kzm> (it'd make 'fromList' or 'elems' pretty weird for Sets, I guess)
01:25:57 <Lemmih> [TWiSTED]: Yes.
01:26:03 <[TWiSTED]> ok
01:26:34 <[TWiSTED]> firstly, how would i get it in the (("hi",12),"hey34") form
01:27:03 <Lemmih> let ((str,num),rest) = ... in ...
01:27:18 <Lemmih> or: ... where ((str,num),rest) = ...
01:28:04 <[TWiSTED]> hmm ok
01:30:17 <[TWiSTED]> parseFormula s = let ((str,num),rest) = parseElement s
01:30:18 <[TWiSTED]>                  where rest = parseFormula s
01:30:22 <[TWiSTED]> that wont work will it
01:32:30 <sorje> It will run for a very long time if it even compiles
01:32:46 <[TWiSTED]> aha ok
01:33:07 <Lemmih> parseFormula "" = []; parseFormula s = pair : pairs where (pair,rest) = parseElement s; pairs = parseFormula rest
01:34:53 * Lemmih wonders why there's no :: SeekMode -> CInt in the standard libraries.
01:35:30 <[TWiSTED]> has an error with rest
01:35:43 <[TWiSTED]> expression : parseFormula rest
01:35:48 <[TWiSTED]> term : rest
01:35:52 <[TWiSTED]> type : Int
01:35:59 <[TWiSTED]> Does not match : [Char]
01:36:23 <Lemmih> parseElement has type :: String -> ((String,Int),String), right?
01:36:39 <[TWiSTED]> o nah
01:36:44 <[TWiSTED]> its
01:37:01 <[TWiSTED]> (String,Int)
01:37:24 <[TWiSTED]> then in parseFormula has type :: String -> [(String,Int)]
01:38:03 <Lemmih> It should evaluate to (("name","number"),"rest of the text").
01:38:12 <Lemmih> Didn't you read what I said before?
01:38:21 <[TWiSTED]> yeh
01:38:45 <[TWiSTED]> and then we turn it into a list ?
01:39:12 <Lemmih> Yeah. parseFormula turns it into a list.
01:39:21 <[TWiSTED]> o ok
01:39:53 <[TWiSTED]> ur above code doesnt evaluate to (("name","number"),"rest of the text") ?
01:41:56 <Lemmih> The 'parseFormula' I pasted expects a 'parseElement' of type :: String -> ((String,Int),String) and has the type :: String -> [(String,Int)]
01:42:47 <[TWiSTED]> ok
01:42:57 <[TWiSTED]> yep parseFormula has type :: String -> [(String,Int)]
01:43:21 <[TWiSTED]> but parseElement is of type (String,Int)
01:43:31 <Lemmih> It shouldn't be.
01:43:34 * boegel whistles
01:43:48 * lispy dances
01:43:56 <lispy> @moo
01:43:57 <lambdabot>          (___)
01:43:57 <lambdabot>          (o o)
01:43:57 <lambdabot>   /-------\ /
01:43:57 <lambdabot>  / |     ||O
01:43:57 <lambdabot> *  ||,---||
01:43:57 <lambdabot>    ~~    ~~
01:43:59 <lambdabot>      Bull
01:44:07 <[TWiSTED]> but if i change that type wouldnt my parseElement function not work?
01:44:11 <Lemmih> [TWiSTED]: Change parseElement so it has the type :: String -> ((String,Int),String).
01:44:48 * boegel dances with lispy and twirls him all over the room
01:44:49 <[TWiSTED]> ive been given those datatypes as part of the lab
01:45:11 <lispy> Lemmih: parseElement :: String -> ((String, Int), String) there done ;)
01:45:18 <Lemmih> parseElement _must_ be of type :: String -> (String,Int)?
01:45:39 <Lemmih> Bummer.
01:45:43 <[TWiSTED]> well yeh i guess so, it doesnt say that it can be changed
01:45:44 <[TWiSTED]> yeh
01:45:59 <lispy> hmm...
01:46:02 <Lemmih> Does it say that it can't be changed? (:
01:46:09 <[TWiSTED]> hehehe
01:46:30 <[TWiSTED]> i guess not technically heh
01:47:58 * lispy just remembered why he sat down in the first place
01:48:25 <Itkovian> omg
01:49:00 <[TWiSTED]> ay crap ive got work in 10 mins
01:49:14 <boegel> Itkovian: ?
01:49:56 <Itkovian> nvm
01:50:59 <Lemmih> [TWiSTED]: Happy work day to you.
01:53:14 <[TWiSTED]> haha
01:53:16 <[TWiSTED]> thx
01:53:23 <[TWiSTED]> yeh ive gotta go pretty soon
01:53:30 <[TWiSTED]> would we be able to continue this later?
01:53:39 <[TWiSTED]> been stuck on it for awhile
01:54:31 <lispy> [TWiSTED]: if you can do it Lemmih's way it's pretty easy...
01:54:40 <lispy> otherwise, i dunno
01:54:47 <[TWiSTED]> yeh true
01:55:06 <[TWiSTED]> theres no way at all to modify that code to allow for the other datatype?
01:56:06 <Lemmih> That would be a bit more complicated but still doable.
01:56:15 <[TWiSTED]> o ok
01:56:52 <[TWiSTED]> this is what it says to try help
01:58:14 <[TWiSTED]> 'split the string into the two parts: one, all the characters up to the next character, and two, all the characters following. use the parseElement function to process the first part and recurse on the second part.
02:00:08 <[TWiSTED]> doesnt really say much that we dont already know ehe
02:01:44 <Lemmih> parseElement (name++number) : ... where (name,str') = break (not.isDigit) str; (number,str'') = break isDigit str'
02:01:58 <lispy> chunk = liftM2 (++) (fst . break isDigit) (break (not . isDigit) . snd . break isDigit)
02:02:17 <Lemmih> Pointless, yay. (:
02:02:36 <lispy> Lemmih: yeah, i thought it was a great example :)
02:03:19 <[TWiSTED]> ill look at those when i get back
02:03:24 <[TWiSTED]> cheers heaps
02:03:24 <[TWiSTED]> bbl
02:07:21 * Itkovian mumbles
02:07:55 <boegel> Itkovian: wtf ?
02:11:37 <Itkovian> any of you guys read thedailywtf feed?
02:11:50 <lispy> no, what is that?
02:11:53 <lispy> (or where is that)
02:11:56 <Itkovian> http://www.thedailywtf.com
02:12:21 <Lemmih> They've finally found some ugly Haskell code?
02:12:40 <Itkovian> nah, don't think so
02:12:49 <Itkovian> but man, the code pieces are hilarious
02:14:05 <lispy> yeah
02:22:11 <lispy> wow, the "#define TO_UPPER( x )" example rocks
02:22:42 <Itkovian> yeah, especially the 'Z'
02:22:46 <lispy> yeah
02:23:00 <boegel> hehe
02:23:07 <boegel> Itkovian: I'm sure you see stuff like that too
02:23:19 <Itkovian> erm ... no comment ;-)
02:23:32 <Itkovian> actually, it's not that bad for the students I teach.
02:23:49 <boegel> I've seen some stuff in Java, omg :)
02:23:57 <Itkovian> a few years ago I taught Java (well, the exercises) to first years, and oh man ... that rocked
02:24:12 <boegel> some assignments come back every year, and so solutions go over from year to year
02:24:26 <boegel> I decided to rewrite it, because man, it was really unbelievable :)
02:25:02 <lispy> "Oh, and by "library function," I mean it was copy/pasted in every page that needed to use it."
02:25:12 <lispy> okay, i stop pasting :)
02:26:10 <boegel> you gotta love the SSN example :)
02:26:34 <lispy> yeah
02:26:39 <lispy> that's just....wow
02:27:05 <Itkovian> well ... my wife isn't really a programmer, but a few months ago she was asked to work with a few german collaegues on a php driven webapp
02:27:26 <Itkovian> she has trouble grapsing what goes on, cos oh man, the code is _ugly_ as hell
02:28:30 <Itkovian> and it's a nightmare to try and get some decent format in it ...
02:28:31 <Itkovian> grr
02:28:44 <boegel> I helped my gf with a php page for her thesis too once, and even she wouldn't write code like this :)
02:29:04 <Itkovian> and as it has to advance rapidly, in the beginning all she could do was copy and adapt ... because there were no functions as such ...
02:30:00 <Itkovian> at least now she can work on new pages, and I must say her style is improving rapidly ;-)
02:30:18 <Itkovian> but the colleagues still spout junk
02:31:16 <boegel> that's because they don't have a good teacher like she does, right ? ;)
02:31:20 <boegel> you should teach 'em !
02:32:28 <lispy> personally, i think abstractions are crap.  Especially functions.  Leave that stuff in the math books.  Real programmers just use nor everything together.  Why nor?  Because it's universal, that's why.
02:36:38 <Oejet> Lemmih: I guess, I beat you to using the "unsafeInterleaveIO" procedure then. ;-)
02:36:48 <lispy> i used to work for a place that wrote programs like that SSN example.  They had code for loading .ini files (why they didn't use the windows api is beyond me).  Well in each product they would copy and paste this code for reading ini files.  Debug it for each ini file, then not backport the bug fixes.
02:37:17 <Lemmih> Oejet: Huh?
02:37:59 <Lemmih> Ah oh. Lucky you. (:
02:38:22 <lispy> i should add that this code wasn't in a function or anything, it was just a stream of hardcoded stuff that would parse a file
02:38:41 <boegel> lispy: som people
02:38:43 <boegel> +e
02:39:30 <lispy> yeah, i wrote a replacement that took a file name, a section name and a key and return either the value or an error code.  They hated it :)
02:39:42 <lispy> i was young and dumb at the time
02:39:51 <Oejet> lispy: Did that get you fired? ;-)
02:39:55 <lispy> now i would just reuse the api :)
02:40:11 <lispy> Oejet: heh, no but it made them bitter
02:40:22 <lispy> but it saved their butts at least once
02:40:38 <Oejet> Bitter old programmers.  Gotta love 'em.
02:40:52 <lispy> they started using ini files as a database.  and my co-worker was able to make the changes in 45 minutes using the code i wrote :)
02:41:40 <lispy> now i just groan and move on :)
02:42:20 <lispy> like when i see things like (defun foo (bar) (let () ... ))
02:42:49 <lispy> to be honest, i'd love to clean up our code base
02:43:08 <lispy> but whenever i get close to that task i'm reminded that research not software is our deliverable
02:43:12 <Oejet> Which is just (defun foo (bar) (...)), right?
02:43:17 <lispy> yeah
02:43:38 <Oejet> Hehe.
02:43:45 <lispy> too many students who didn't like lisp or didn't know lisp have been assigned to the project over the years
02:44:23 <lispy> some functions look they are taking directly out of a C book
02:45:01 <lispy> seeing the code was the first time i realized that a multiparadigm language can be a terrible thing
02:45:34 <lispy> everytime you add a feature that adds power you may also be add a feature that can be used against you
02:45:37 <Oejet> It's very writable, no?  Not very readable, though.
02:45:54 <wli> I'm a programmer of multiple paradigms, in fact four: bananas, lenses, envelopes, and barbed wire.
02:45:59 <lispy> lisp is not bad to read once you've done it for a while
02:46:04 <Oejet> wli: Show off.
02:46:22 <wli> Oejet: Admit it, you're jealous of my nose.
02:46:28 <lispy> heh
02:46:36 * Oejet is very jealous.
02:47:05 <lispy> is the bananas paradigm of programming as follows: everything in the universe is either a banana or crap.
02:47:15 <wli> (If you missed the original, hunt for "You are a man of letters, in fact, three: A S S")
02:47:30 <lispy> and you go around saying, "Well, THAT's not a banana..."
02:48:20 <lispy> bleh, it's almost 3am
02:48:23 <lispy> night all
02:48:30 <wli> Okay, I'll just give up and say where it came from. Cyrano de Bergerac.
02:49:46 <wli> (hence the nose-related followup)
02:50:08 <Oejet> wli: Jeps, got it now. :-)
02:50:26 <Oejet> Or should I say :^)
02:50:33 <wli> heh
02:51:30 <wli> It's rather unfortunate that I have to explain my banter. It's so much better when it's understood immediately as opposed to explained.
02:52:21 <wli> I met a woman once who understood me as I naturally spoke. Such a shame I let her go.
02:53:16 <Oejet> Get her back.
02:53:43 <wli> Oejet: It's been 14-15 years since last we spoke.
02:53:46 <Oejet> I might read Cyrano de Bergerac sometime.
02:54:29 <Oejet> wli: No problem.  Just met an old class mate in the bus yesterday.  Didn't see him for 7 years.
02:55:10 <wli> If she graduated from Berkeley in 2004 she'd be a 32-year-old graduate...
02:55:57 <wli> If she had returned to Japan (presumably at her mother's behest?) she'd be unlikely to be interested in medicine.
02:57:05 <wli> (She didn't look Japanese in person.)
02:58:53 <wli> (About the only hint was her diet, upon which her mother had apparently had a large influence despite apparently otherwise total Westernization.)
02:59:31 <wli> None of the good stuff you get at restaurants either, all shag-nasty squid and urchins and so on.
03:00:45 * Itkovian looks up urchin on the wikipedia
03:00:52 <wli> Well, no idea what it really was, I couldn't bear either the sight or smell of it.
03:01:19 <Itkovian> people eat hedgehogs?
03:01:24 <wli> So sad, too much unintentional intimidation and other bull.
03:01:53 <Itkovian> yuk
03:02:10 <wli> Urchins are sea creaturs noted for having large poisonous spikes.
03:02:21 * Oejet chews on Sony.
03:02:57 <wli> But that are otherwise small and very biologically and structurally crude (coelacanths?)
03:05:34 * Lemmih thinks he has a phony ghc-asm installation.
03:06:01 <Itkovian> ok, those are the sea-urchins then
03:06:06 <Itkovian> still not edible imo
03:06:49 <boegel> everything is edible if you cook it right
03:08:01 <musasabi> grah. I want a type-lambda.
03:08:20 <musasabi> or at least a varargs type declaration.
03:11:01 <Itkovian> i'm off to lunch
03:11:04 <Itkovian> ttyl
03:19:35 <dons> varargs type declaration!
03:20:17 <dons> hmm. maybe a list (on the type level) would do
03:26:14 <tromp> @index showHex
03:26:15 <lambdabot> Numeric
03:46:01 * basti_ back from a short visit in #haksell
03:49:30 <basti_> @docs Map
03:49:32 <lambdabot> Map not available
03:49:34 <basti_> @docs Data.Map
03:49:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
03:50:49 * Lemmih tries to summon SyntaxNinja.
03:52:06 <Lycan359> Hey I'm looking to learn a functional language. What in your oppinion makes Haskell your choice? I don't have much experiance in functional programming though. I'm a C/C++ programmer.
03:53:28 <Lunar^> Lycan359: I have something for you
03:53:44 <Lunar^> http://www.haskell.org/~pairwise/intro/intro.html
03:53:58 <basti_> Lycan359: the static type system, that the code is very terse and though quite understandeable (as opposed to, say, terse C code)
03:54:08 <Lycan359> Hey thanks.
03:57:28 <Lycan359> I have messed around with scheme alittle bit so I'm not completly new to function programming. I just never written anything useful with it yet. All the parens in scheme kinda turned me off though.
03:58:29 <Prunery> The parens become invisible after a week or so
03:59:00 <Lycan359> How does Haskell compare with something like Ocaml?
03:59:11 <Lemmih> GT.
03:59:42 <Lunar^> Lycan359: Haskell syntax is way much nicer ; lazyness ; type classes ; monads
03:59:50 <Lunar^> Lycan359: O'Caml is faster
04:00:55 <basti_> o'caml is very confusing imo
04:01:18 <basti_> even now then i know haskell it's still pretty hard to read
04:01:24 <Lycan359> Functional programming is really bizarre :P
04:01:58 <basti_> @pl \x->"/".x.".txt"
04:02:00 <lambdabot> ("/" .) . (. ".txt")
04:02:02 <basti_> that sort of thing you mean?
04:02:14 <basti_> uhm
04:02:18 <basti_> @pl \x->"/"++x++".txt"
04:02:19 <lambdabot> ('/' :) . (++ ".txt")
04:02:19 <basti_> THAT
04:02:21 <basti_> i mean
04:02:21 <basti_> =)
04:03:43 <Lycan359> Just started reading Yet Another Haskell Tutorial... it any good?
04:05:12 <Lunar^> Lycan359: sems to be reckoned as one of the best
04:05:13 <basti_> its ok i think.
04:06:03 <Lunar^> Lycan359: Etheridge's one has an interesting approach if you are unfamiliar with FP
04:06:59 <Lycan359> Lunar^: Yeah, I'll read that as well.
04:16:19 <Prunery> What has Haskell got going for it over Scheme?
04:20:25 <Lemmih> Fewer parentheses.
04:20:44 <Prunery> So it's identical to scheme but with fewer parentheses.
04:20:55 <mflux> lazy evaluation
04:21:13 <mflux> I understand scheme also has static type checkers, but haskell has them in the specification
04:21:18 <Prunery> Does it have ml-style currying?
04:21:22 <mflux> yes
04:21:30 <Prunery> ace
04:22:34 <tromp> haskell has purer semantics
04:23:10 <tromp> and stronger typing
04:23:52 <Prunery> Searching for "haskell currying" is utterly useless, it only returns history lectures and basic descriptions of currying :)
04:24:24 <Prunery> Nothing do with the language Haskell
04:25:16 <Prunery> Does lazy evaluation make a big difference in how you do most things?
04:25:44 <Prunery> If yo have referential transparency anyway, surely it would only affect how you do infinite sequences or what have you
04:28:57 <mflux> prunery, well, lazy evaluation offers for example the capability to copy files using only a little memory while the code naively states a <- hGetContents file_in; hPutStr file_out a
04:29:42 <mflux> prunery, it allows higher separation of code, from code doing A B C to code doing A, then another code doing B, etc
04:30:22 <Prunery> mflux: Could you give an example of what you mean by higher separation of code?
04:30:56 <Prunery> I see what you mean about using less memory for reading a file etc
04:31:07 <mflux> prunery, well, as you can see in there was no code that does 'read a block, write a block'
04:31:18 <mflux> only 'read all characters, write all characters'
04:31:27 <mflux> the former would obviously need to loop etc
04:32:24 <mflux> or let's say we have data of unknown length, and we have function (map fun list) that applies function to each list element
04:32:43 <Prunery> So the 'read' is effectively the equivalent of a (lambda () (read-something)) in scheme, which is then passed to the write?
04:32:55 <mflux> we could write map operation1 (map operation2 read_data)
04:33:47 <mflux> sorry, I don't know scheme that well, is that a continuation?
04:33:59 <mflux> (I know the syntax of lambdaetc, but not the io library)
04:34:17 <Prunery> mflux: Ah ok, I see what you mean
04:34:43 <Prunery> No, that was just a function I made up
04:35:04 <Prunery> I suppose it would have to be a continuation to do what you're talkikng about
04:37:05 <mflux> anyway, the infinite lists-aspect is also sometimes useful, for example to form pairs of the elements of a list can be expressed with zip [1..] list (zip converts two lists to a list where the nth element of the other list is paired with the other list's nth element)
04:39:16 <Prunery> I'll have to check it out soon, it sounds fun
04:39:27 <mflux> and recursive infinite lists too: for example one algorithm for generating a sequence of prime numbers could be having such a sequence of integers for which the number must not be divisible by any prior prime up to the sqrt of the number
04:40:06 <mflux> and this can be expressed as: p = 2:filter (\n -> not $ any (\p -> n `mod` p == 0) $ takeWhile (<= truncate ( sqrt $ fromInteger n)) p) [3..]
04:40:41 <mflux> (now that might be a bit confusing at first if you're not aware of how currying and function composition works in haskell)
04:41:23 <Prunery> Actually I just don't get the syntax :)
04:42:36 <mflux> \n -> n is a lambda function, $ is basically an evaluation separator that avoids parenthesis: a (b) == a $ b
04:42:44 <mflux> and application has highest precedence
04:43:13 <mflux> and currying works like this too: (< 4) 6 == False (because not (6 < 4))
04:43:34 <mflux> infact ((<) 6 4) syntax should make you feel just like home ;)
04:43:39 <musasabi> "a $ b" can be transformed into "a (b)", but the reverse is not allways true.
04:44:03 <mflux> hmm, in which case?
04:44:35 <mflux> I used to define operator @@ in ocaml as let (@@) a b = a b
04:45:00 <mflux> oh, well obviosly that says nothing of the reverse
04:45:08 <musasabi> mflux: with complex types (e.g. ST monad).
04:45:29 <mflux> well, I havn't used the ST monad, so I know nothing of those ;)
04:45:51 <musasabi> there has been discussion about the issue on haskell lists.
04:59:34 <seidan> musasabi: I've been trying to do some stuff with the ST monad recently, but I still don't think I've fully wrapped my brain around it.
05:00:14 <musasabi> seidan: it takes some time - and one morning you will notice that you understand it.
05:02:03 <seidan> The only way I have been able to get logs of intermediate state is by doing stuff like "data myState s = ...; type thisIsAHack = myState RealWorld" plus a bunch of stToIO. That can't be right... :)
05:11:44 <bourbaki> moin
05:12:13 <boegel> hey bourbaki
05:12:20 <boegel> @wiki H3D
05:12:21 <lambdabot> http://www.haskell.org/hawiki/H3D
05:12:23 <boegel> bourbaki: ^
05:12:44 * bourbaki checks link
05:13:24 <boegel> feel free to add stuff :)
05:13:39 <boegel> I'll release my code next week, 'cause my thesis is due 1st of June
05:13:47 <bourbaki> sweet
05:14:12 <bourbaki> atm im concerned with my game though :)
05:15:47 <boegel> no prob, but it would be cool if you add to the wiki what your code does
05:16:11 <bourbaki> i can add up the url for the code of that homptopy stuff
05:16:13 <boegel> we can start this project slowly
05:16:48 <bourbaki> do i need an account for the site?
05:16:52 <boegel> 'cause I have finals in June, and in July I'm on holiday for 3 weeks, so I won't have much time either probably
05:16:57 <boegel> which site ?
05:16:59 <bourbaki> cause my second name is lazy
05:17:03 <boegel> the wiki ?
05:17:07 <bourbaki> yes
05:17:14 <boegel> no, not at all
05:17:20 <bourbaki> ok then ill add it
05:18:03 <boegel> bourbaki: are you from Japan ?
05:18:11 <bourbaki> why?
05:19:00 <boegel> 'cause I'm looking at my site stats, and someone from Japan just visited my website, I figured it was you
05:19:17 <bourbaki> :)
05:19:35 <bourbaki> you never know
05:19:42 <bourbaki> the internet is a village
05:20:02 <shelarcy> I'm from Japan, and I'm interested in Haskell and Raytracing.
05:20:29 <boegel> shelarcy: wanna help with H3D
05:21:07 <boegel> ?
05:21:10 <shelarcy> yes.
05:21:36 <seidan> I live in Japan and am interested in Haskall and Raytracing too. though mostly the optical design as opposed to the pretty picture kind of raytracing
05:22:04 <boegel> shelarcy: then add your stuff to the wiki !
05:22:47 <boegel> seidan: you too :)
05:23:07 <seidan> I'm just checking it out now.
05:23:39 <bourbaki> it would be cool to target something like a function plotter first
05:24:01 <boegel> bourbaki: that is a nice idea
05:24:02 <bourbaki> something that you can render surfaces with and the like with textures and so on
05:24:16 <bourbaki> thats not that hard with your code i guess
05:24:18 <boegel> but I was thinking to combine your spline renderer with my ray tracing code, if that's possible
05:24:27 <bourbaki> sure
05:24:32 <bourbaki> thats what i meant
05:24:36 <boegel> oh okay ;)
05:24:42 <bourbaki> and then just add textrues to it as well
05:24:51 <boegel> my code is very flexible with new types of Objects
05:25:05 <boegel> just adding a normal function and an intersection function should do it
05:25:36 <bourbaki> i dont think that i have my other code around anymore for sphere homotopies
05:25:53 <bourbaki> but i have done a landscape with the homotopy already
05:26:12 <bourbaki> the intersection is the most chellangeing in that one
05:26:30 <boegel> challenging ?
05:26:43 <boegel> do you have some screenshots too ?
05:26:50 <bourbaki> the normals are easily optained by getting the cross product of the jacobian
05:26:54 <bourbaki> nope
05:27:14 <bourbaki> as i said the landscape and shpere stuff is not on my disk anymore
05:27:19 <bourbaki> i just bought a new box
05:27:35 <boegel> oh, okay
05:27:52 <boegel> bourbaki: which GUI lib did you use ?
05:28:03 <bourbaki> none at all :)
05:28:13 <boegel> then how do you visualise your stuff ?
05:28:17 <bourbaki> you can render spline letters and texts with my code though
05:28:21 <bourbaki> and morph it
05:28:24 <bourbaki> opengl
05:28:41 <bourbaki> if you use ghc just dl and and compile it
05:28:50 <boegel> of, that would probably be the best idea for creating a decent 3D modeller
05:28:54 <bourbaki> i morph a text to a circle
05:29:04 * boegel tries
05:29:10 <bourbaki> well i am really bad with guis
05:29:38 <boegel> I rule at gui's :)
05:29:51 <bourbaki> you can build surfaces in just the same way i to the morph between the two objects there
05:30:11 <boegel> I'm not a math geek though
05:30:14 <bourbaki> that is a surface is just a honopoty of two homotopies
05:30:21 <bourbaki> neither am i :)
05:32:31 <shelarcy> I add tanakh's demo to wiki page.
05:32:36 <boegel> who' tanakh ? :) maybe it's best to add email-adresses too or so
05:33:19 <boegel> heh, the page in japanese :) the only word I can read is Haskell :)
05:34:00 <shelarcy> Okay, I'll  add summary for that page.
05:34:51 <boegel> shelarcy: okay, maybe mention your nick in here too
05:39:14 <boegel> I hope we can come up with some nice idea's and stuff
05:39:47 <bourbaki> boegel: do you know the function plotter in #math?
05:40:04 <bourbaki> something like that for lambdabot would be nice just with a bit more complexity
05:43:34 <boegel> bourbaki: no I don't
05:43:41 <boegel> I got your example working in windows
05:43:45 <boegel> look nice :)
05:44:15 <bourbaki> i havent done all letters
05:44:22 <boegel> no, I was
05:44:28 <boegel> but that's not a problem really
05:44:37 <bourbaki> no you just can type in some text
05:44:50 <bourbaki> and then he substitutes the letters with splines
05:45:01 <bourbaki> but i havent modeled the whole alphabet
05:45:13 <boegel> type where ?
05:45:14 <bourbaki> and some of the letters are still really edgy
05:45:21 <bourbaki> sec let me have a look
05:45:29 <boegel> oh, you mean in the code ?
05:45:33 <bourbaki> yes
05:45:40 <boegel> oh, I see
05:45:50 <bourbaki> you also can morph between two texts
05:46:24 <bourbaki> spline4 = buildSpline (buildSplineWord "hamkell")
05:46:56 <bourbaki> change
05:46:57 <bourbaki> homotopy = buildHomotopy spline4 spline3
05:46:58 <bourbaki> indo
05:47:00 <bourbaki> er into
05:47:06 <bourbaki> homotopy = buildHomotopy spline4 spline5
05:49:18 <boegel> nice ! :)
05:49:46 <bourbaki> if you have two splines paralell to each other for example
05:49:50 <boegel> does anyone know if it's possible to upload (small) pics to the wiki ?
05:50:11 <bourbaki> then you can do the homotopy thingy in between and end up with a surface
05:50:24 <boegel> nice !
05:50:26 <bourbaki> just with 2 parameters
05:50:42 <bourbaki> and its easy to write a linearization function to render it
05:50:48 <bourbaki> and to optain the normals
05:51:54 <bourbaki> i also thought about adding some vector fonts
05:52:37 <boegel> the glexcess stuff looks cool too
05:52:51 <bourbaki> mine?
05:54:10 <boegel> did you do work on glexcess too ?
05:54:21 <bourbaki> no
05:54:31 <bourbaki> i just build a small utility function
05:54:39 <bourbaki> nothing fancy though
05:54:57 <boegel> what is glexcess exactly ? the about on the webpage is a bit empty :)
05:55:31 <bourbaki> hm maybe i havent used it :)
05:55:43 <bourbaki> i thought you just meant the use of the ogl interface
05:56:23 <boegel> no, it's like some kind of renderer too
05:56:44 <bourbaki> i see then no
05:57:17 <boegel> I have to go now, fetching the final comments on my thesis text
05:57:20 <boegel> bye for now, ttyl
05:57:31 <bourbaki> bye
06:21:38 <wilx> @index StablePtr
06:21:39 <lambdabot> Foreign.StablePtr, Foreign
06:22:28 <wilx> @moo
06:22:29 <lambdabot>          (__)
06:22:29 <lambdabot>          (oo)
06:22:29 <lambdabot>   /-------\/-*
06:22:29 <lambdabot>  / |     || \
06:22:29 <lambdabot> *  ||----||  *
06:22:30 <lambdabot> \/|(/)(/\/(,,/
06:22:31 <lambdabot>   Cow munching
06:22:33 <lambdabot>     on grass
06:23:28 <xerox> @ghc
06:23:29 <lambdabot>  Data constructor does not return its parent type
06:40:06 <tintin> is graham hutton's complete book available somewhere ?
06:51:57 <Itkovian> less brackets
07:10:36 <GroMeZ> hi
07:14:14 <yoda-> Is it ok to post code and ask questions here?
07:14:49 <TheHunter> sure
07:14:53 <yoda-> ok
07:14:54 <TheHunter> http://hbin.dyndns.org/
07:14:59 <yoda-> its not long its only one line
07:15:17 <yoda-> combine xs = [(z, sum [ b | (a,b) <- xs, a == z]) | (z, x) <- xs]
07:15:29 <yoda-> the kind of input is
07:16:07 <yoda-> [("F",6),("Na",2),("Na",3),("Si",1)]
07:16:14 <TheHunter> @type \xs -> [(z, sum [ b | (a,b) <- xs, a == z]) | (z, x) <- xs]
07:16:19 <lambdabot> \xs -> [(z, sum [ b | (a,b) <- xs, a == z]) | (z, x) <- xs] ::
07:16:19 <lambdabot> forall a
07:16:19 <lambdabot>                         b.
07:16:19 <lambdabot>                      (Num b, Eq a) =>
07:16:19 <lambdabot>                      [(a, b)] -> [(a, b)]
07:17:27 <yoda-> I was wondering how i would take out repeated terms in the output
07:17:32 <yoda-> I cant seem to figure it out
07:18:03 <TheHunter> there's nub
07:18:09 <TheHunter> @type Data.List.nub
07:18:11 <lambdabot> Data.List.nub :: forall a. (Eq a) => [a] -> [a]
07:18:24 <yoda-> nub?
07:18:31 <yoda-> nub ()?
07:18:47 <TheHunter> @plugs nub "abcdefgace"
07:18:49 <lambdabot> "abcdefg"
07:19:02 <TheHunter> @plugs nub [("F",6),("Na",5),("Na",5),("Si",1)]
07:19:03 <yoda-> ah nice
07:19:04 <lambdabot> [("F",6),("Na",5),("Si",1)]
07:19:09 <yoda-> !!!
07:19:11 <yoda-> <3
07:19:13 <yoda-> much love
07:19:15 <yoda-> thanks
07:19:16 <yoda-> :)
07:19:22 <TheHunter> it's slow, but it might do.
07:20:08 <yoda-> thanks very much
07:20:43 <yoda-> Just out of intrest, where did you aquire the knowledge of that function?
07:20:48 <yoda-> is there a database somewhere?
07:20:57 <yoda-> or do i have to go through the libraries manually
07:21:10 <TheHunter> @docs Data.List
07:21:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
07:21:40 <TheHunter> it's wise to go through the documentation of Prelude, Data.List, Control.Monad etc, there are lots of interesting functinos there.
07:21:50 <yoda-> ok
07:21:54 <yoda-> thanks again
07:22:56 <TheHunter> if you want to write a more efficient version, you can have a look at Data.Map.
07:23:47 <basti_> Set is pretty fast for that purpose
07:26:11 <TheHunter> @type foldr (\(k,v) -> Data.Map.insertWith (+) k v) Data.Map.empty
07:26:13 <lambdabot> foldr (\(k,v) -> Data.Map.insertWith (+) k v) Data.Map.empty ::
07:26:13 <lambdabot> forall k
07:26:13 <lambdabot>                         a.
07:26:13 <lambdabot>                       (Ord k, Num a) =>
07:26:13 <lambdabot>                       [(k, a)] -> Data.Map.Map k a
07:27:13 <TheHunter> @pl foldr (\(k,v) -> insertWith (+) k v) empty
07:27:14 <lambdabot> foldr (uncurry (insertWith (+))) empty
08:13:01 <shapr> musasabi: ayh?
08:13:21 <shapr> pesco: hiya! Think you'll have time for a TMR article?
08:14:15 <shapr> So far I have two definite articles, and one possible article. So, TMR3 isn't looking likely. I really don't want to go bimonthly.
08:16:17 <shapr> g'day ozone
08:20:37 <shapr> basti_: Did you send in the patches for the latest yi-emacs?
08:20:47 <shapr> kolmodin: want to write about Haste for TMR?
08:21:17 <shapr> I can probably write a TMR article myself over the weekend, but that would make it a total of three articles, and five is the minimum.
08:21:59 <shapr> nom de fonction :-(
08:22:33 <ozone> oh, shapr's back
08:23:16 <shapr> But only to recruit TMR authors, if possible.
08:23:37 <shapr> I need at least two more or I'll have to skip next month.
08:23:46 <shapr> ozone: you want to write a TMR article, yeah?
08:23:47 <pesco> shapr: I'm really not sure right now. :(
08:23:58 <shapr> pesco: Ok, if you don't have the time, I understand.
08:24:00 <pesco> I'm terribly troubled by university duties.
08:24:10 <pesco> shapr: Thanks.
08:24:24 <shapr> You've already written articles, you've definitely 'paid your dues' ;-)
08:24:30 <pesco> :-)
08:24:49 <shapr> wli: Want to write an article for The Monad.Reader?
08:24:58 <ozone> shapr: i do?
08:25:06 <shapr> ozone: Sure ya do!
08:25:13 <ozone> shapr: ask me after the 10th, which is when haskell workshop papers are due :)
08:25:18 <shapr> oh. foo.
08:26:24 <basti_> shapr: no
08:26:30 <basti_> but i might do so soon
08:26:34 <shapr> basti_: spiffy
08:26:43 <basti_> when i implemented C-u, key rebinding and key lookup
08:26:50 <basti_> which is positively possible now though
08:26:54 <basti_> other than before
08:26:56 <shapr> Well, if I don't hear from two more definite authors today, I'll cancel the June 1st issue of TMR.
08:27:00 <pesco> I'm in need of psychological advice. I guess there are many students here. What do you do about mental blockades wrt. the feeling of "must"? I must do my homework, I must finish my exercises, I must read this book. Thus I can't.
08:27:27 <shapr> pesco: Think about it in terms of what you want and what you need.
08:27:45 <basti_> pesco: do you want an excuse, or an answer that tells you that you must? ;)
08:28:06 <basti_> honestly, yes, this is a problem.
08:28:10 <shapr> pesco: I want to do a good job, so I want to be well prepared. I need to eat so I have a job.
08:28:41 <pesco> shapr: I want to know about Algebra, so I need to read this book.
08:28:55 <pesco> shapr: Etc.
08:29:15 <shapr> pesco: Also, you should mention solutions that involve abstraction. If you start your student career with the right tools, exercises and reading go quickly and are more profitable.
08:29:35 <pesco> shapr: What tools?
08:29:55 <shapr> "Sharpen the tools first" as in, make sure and take courses in "how to study" "how to read faster" "how to memorize effectively"
08:30:22 <shapr> The faster you can read and remember, the less time each book takes.
08:30:42 <pesco> They call them "soft skills". They have seminars. It sounds like a bunch of hippies patting each others' backs and "communicating" wildly. I don't want to go there.
08:30:55 <shapr> Soft skills?
08:31:03 <shapr> Ich verstehe nicht.
08:31:12 <pesco> That's what they call them. Learning to learn and so on.
08:31:45 <basti_> "soft skills" is mainly hype afaik.
08:31:48 <shapr> Oh. Well. I've never been to any of the classes, but I have read several of the books. Half of the books I've found really did help me, the other half were bullshit.
08:31:50 <basti_> mnemotechnique isn't
08:32:12 <basti_> "soft skills" means: do not complain if someone is kicking your ass
08:32:14 <pesco> basti_: That's exactly my suspicion.
08:32:24 <pesco> basti_: Ah, right.
08:32:35 <pesco> shapr: Can you recommend me a book?!
08:33:19 <basti_> i have problems learning only when I'm bored by the stuff i have to learn
08:33:22 <shapr> If you do learn these skills well, you can use them to meet fellow students that interest you. For example, "gee, studying for the final took me only four hours because I learned a more efficient way." and the interesting student responds "Wow, can you teach that to me?"
08:34:01 <pesco> I'd think I'm not that bad at remembering. But I can't pick myself up and keep concentrated.
08:34:44 <pesco> It feels to me as if this was largely due to the fact alone that there's a feeling of having to do it which automatically provokes some childish "no I won't" response.
08:35:14 <basti_> it's not bad to know what you won't do.
08:35:19 <shapr> pesco: I have that feeling too.
08:35:46 <basti_> i suspect everyone who's honest and not a heißdüse has that feeling
08:35:55 <shapr> I've found two beneficial responses in that situation. First, take a five minute break and play a game or do something fun. But make sure to set a timer =)
08:36:06 <shapr> Second, look at the need/want structure that got you there.
08:37:08 <shapr> If you can view the not-very-fun thing as something that will give you the ability to do a very-much-fun thing, that increases my motivation.
08:37:23 <basti_> like in programming? ;)
08:37:43 <pesco> basti_: Good allegory!
08:37:56 <shapr> Here's one book that's somewhere along those lines - http://www.amazon.com/exec/obidos/tg/detail/-/0884150879?v=glance
08:38:11 <shapr> The book I've been reading recently is fun, but not terribly serious.
08:38:11 <pesco> Thinking of all the pains I've gone through to achieve the most simple results in programs.
08:39:50 <pesco> Wow, quick calculating could come in really handy, as I've often thought.
08:41:19 <shapr> My recent goal is to be able to estimate the height of buildings, distance of vehicle, etc from knowing the basics like sin/cos/tan and the length from my eye to my thumb.
08:42:23 <pesco> Ah yes, such things are very useful.
08:42:42 <pesco> Also remembering the length/span of certain body parts can provide valuable.
08:42:49 <shapr> I'm also *very interested* in other books along those lines. If anyone knows of some, please tell me!
08:43:51 <shapr> Here's one I've been reading lately - http://www.amazon.com/exec/obidos/ASIN/0553353489
08:44:24 <shapr> It's cute.
08:49:19 <shapr> My favorite part of that "Brain Building" book is that the goal of many of the exercises is to get people to challenge their own assumptions. I guess you can sum up the whole book with "Think for yourself"
08:52:44 <shapr> Well, I hope to hear from some authors...
08:52:46 * shapr bails out
08:59:55 <enexar> can someone help me with sortBy ?
09:00:34 <basti_> you gotta try to be sure
09:00:48 <enexar> im not sure what is meant by the function definition (a -> a -> Ordering)
09:00:50 <basti_> @plugs sortBy (<) [1..5]
09:00:57 <lambdabot> Couldn't match `Ordering' against `Bool'
09:01:00 <basti_> hmm
09:01:04 <basti_> @plugs sortBy (flip compare) [1..5]
09:01:06 <lambdabot> [5,4,3,2,1]
09:01:20 <basti_> well data Ordering = GT | LT | EQ iirc
09:01:30 <basti_> with obvious associations holding.
09:02:20 <enexar> hrm
09:02:38 <enexar> do i add this myself or is it in the list module?
09:02:47 <sylvan> It's in the List module
09:02:57 <enexar> oh ok
09:02:59 <sylvan> just write a function that orders your data returning one of GT, LT or EQ
09:03:10 <sylvan> or if the data type is in the Ord type class, just use Compare
09:03:10 <enexar> ok sweet
09:03:13 <sylvan> "compare"
09:03:14 <basti_> @plugs compare 4 5
09:03:30 <enexar> ok cool
09:03:34 <lambdabot> LT
09:03:42 <sylvan> Took its sweet time didn't it`
09:03:58 <basti_> huh?
09:04:23 <sylvan> lambadbot took quite some time to answer there.. Or was that just me?
09:05:02 <basti_> ah
09:05:04 <basti_> yes it took
09:05:22 <basti_> Took not Look like i was reading first...
09:05:28 <basti_> which explains my confusion
09:05:29 <enexar> thanx guys
09:05:37 <basti_> nP
09:05:37 <basti_> :)
09:13:05 <mflux> hmm.. elegant way to sum up all except the last number in a list?
09:13:22 <basti_> @plugs init [1..4]
09:13:24 <lambdabot> [1,2,3]
09:13:35 <mflux> oh, thanks
09:23:24 <enexar> <3 haskell elegance
09:23:45 <boegel> <begin spam>
09:23:48 <boegel> @wiki H3D
09:23:49 <lambdabot> http://www.haskell.org/hawiki/H3D
09:23:55 <boegel> </spam>
09:24:19 <wilx> illformed XML.
09:24:33 <boegel> *beep: syntax error
09:24:33 <wilx> Or SGML :)
09:24:37 <wilx> ;)
09:24:38 <boegel> I got your attention didn't I :p
09:29:07 <mflux> @pl \x y -> snd (size x y)
09:29:08 <lambdabot> (snd .) . size
09:37:37 <bourbaki> hi esap
09:37:44 <esap> Hi
09:37:47 <esap> what's up?
09:38:11 <bourbaki> nothing much on my side of the cable :)
09:39:38 <SyntaxNinja> 'morning
09:39:58 <esap> good evening
09:42:00 <musasabi> evening
09:50:51 <boegel> does anyone have shapr email ?
09:52:32 <musasabi> boegel: yep.
09:55:02 <SyntaxNinja> don't worry, he's fine ;)
09:56:13 <boegel> SyntaxNinja: no, I just want to ask him something not related to his not being here
10:00:43 * boegel summons Lemmih 
10:01:45 <basti_> yi-emacs can now describes keys!
10:01:46 <basti_> -s
10:02:33 <basti_> now I'll add rebinding & repeat (C-u) and then everybody is happy.
10:02:42 * basti_ has not had such a larval stage for months
10:08:39 * boegel leaves for a while
10:08:48 * xerox waves to boegel
10:51:47 <saynte> does anyone know much about the symbols ghc generates? for instance, if i have a module A, what would A_d1MB be in reference to?
10:58:25 <Igloo> You'll probably be able to match it up to something in the -ddump-simpl or -ddump-stg output
10:59:49 <saynte> alright, i think i need to read the ghc guide a little and find out what those do :)
11:39:15 <lispy> oh, i could have used init the other day
11:39:51 <lispy> with such a rich set of "primitives" it's easy to overlook the easy way
11:40:11 <basti_> yes.
11:40:41 <basti_> @type liftM
11:40:42 <lambdabot> bzzt
11:40:45 <basti_> hmm
11:40:53 <lispy> @type liftM2
11:40:54 <lambdabot> bzzt
11:40:59 <basti_> @type Control.Monad.liftM
11:41:01 <lambdabot> Control.Monad.liftM :: forall r (m :: * -> *) a1.
11:41:01 <lambdabot>         (Monad m) =>
11:41:01 <lambdabot>         (a1 -> r) -> m a1 -> m r
11:41:03 <basti_> there it is
11:41:03 <lispy> ah
11:51:06 <lispy> doesn't (Monad m) also imply m :: * -> *  ?
11:51:21 <lispy> so that in that type the m :: * -> * part is not really needed
12:02:44 * basti_ wants another haskell n00b to give him the "that stupid IO thing" talk
12:04:01 <lispy> how does that talk go?
12:04:17 <basti_> "don't fear!"
12:04:18 <basti_> ;)
12:04:39 <basti_> or: "It's called a monad, but if it had been for us, we had called it 'cute fuzzy little thing'"
12:04:55 <lispy> ah yeah
12:05:05 <lispy> or, that thing you do all the time in perl
12:05:15 <basti_> ;)
12:05:40 <basti_> "actually its just a verbose '2;"
12:05:42 <basti_> ugh
12:05:43 <basti_> ';'
12:06:05 * musasabi likes the 'cute fuzzy little thing' explanation
12:06:06 <lispy> say what?
12:06:11 <musasabi> but it is definitely pink.
12:06:42 <lispy> verbose ';' sounds weird to me
12:06:43 <basti_> i wanted to say "its just a verbose ';'"
12:06:57 <basti_> in C you go: printf("%i",i) ; i++ ; ...
12:07:24 <basti_> like, do {print =<< i ; i<-i+1 ; ... }
12:07:28 <lispy> so it's just a ';' that speaks?
12:07:35 <basti_> hmm.
12:07:38 <basti_> maybe not verbose.
12:07:58 <lispy> i like thinking of IO monad as a ';' that speaks :)
12:08:13 <basti_> hm.
12:08:21 <basti_> it kinda IS in a way yes.
12:08:39 <basti_> i just did do {(print::Int->IO())=<< (liftM2 (+) readLn readLn)}::IO ()
12:08:43 <basti_> and it worked.
12:08:43 <lispy> yeah, because IO Int isn't an int, it's a computation that results in an Int
12:10:05 <lispy> why do you need Int->IO()
12:10:12 <lispy> woludn't it have worked without it?
12:10:15 <basti_> hmm?
12:10:17 <basti_> just for fun
12:10:22 <lispy> ah
12:10:33 <basti_> i wanted to try out if i grokked =<< and liftM2
12:11:48 <lispy> :t (<<)
12:11:58 <lispy> @type (<<)
12:12:04 <lambdabot> bzzt
12:12:18 <lispy> hmm...there is =<< what is the other one?
12:12:25 <SamB> @pl (=<<)
12:12:25 <lispy> @type (=<<)
12:12:26 <lambdabot> (=<<) :: forall b (m :: * -> *) a.
12:12:26 <lambdabot>    (Monad m) =>
12:12:26 <lambdabot>    (a -> m b) -> m a -> m b
12:12:26 <lambdabot> (=<<)
12:12:41 <SamB> @pl flip (>>=)
12:12:42 <lambdabot> (=<<)
12:13:05 <basti_> @hugs do liftM2 (+) [1..4] [2..5]
12:13:14 <lambdabot> [3,4,5,6,4,5,6,7,5,6,7,8,6,7,8,9]
12:13:27 * basti_ mondo mystic monad magician
12:14:01 <lispy> =<< is known as bind right?
12:14:07 <basti_> no bind is >>=
12:14:12 <lispy> oh
12:14:29 <basti_> @type (>>=)
12:14:30 <lispy> @type (>>=)
12:14:31 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
12:14:31 <lambdabot>    (Monad m) =>
12:14:31 <lambdabot>    m a -> (a -> m b) -> m b
12:14:31 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
12:14:31 <lambdabot>    (Monad m) =>
12:14:31 <lambdabot>    m a -> (a -> m b) -> m b
12:14:33 <lispy> heh
12:14:34 <basti_> hmm
12:14:55 <basti_> say has anyone ever discovered a use for a comonad?
12:14:59 <lispy> @type (>>)
12:15:00 <lambdabot> (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m
12:15:00 <lambdabot> b
12:15:14 <lispy> never heard of a comonad
12:15:18 <basti_> I've seem some reformulation/obfuscation of IO as OI
12:15:33 <lispy> uh?
12:15:55 <basti_> well for example: a Int->IO() function would be recasted as OI(Int) -> ()
12:15:58 <basti_> thats a comonad then
12:16:28 <basti_> it behaves the same, just the other way round. It wouldn't let go of the types of your function parameters.
12:16:38 <basti_> (instead of of their results)
12:17:03 <lispy> heh
12:17:20 <lispy> i'll just stick to monads for now :)
12:17:24 <basti_> -g-
12:17:30 <lispy> i have enough trouble with them
12:17:47 <basti_> hmm
12:17:51 <basti_> one could have a roundmonad
12:17:58 <basti_> OIOI (Int) -> OIOI ()
12:18:06 <basti_> but that's an arrow then I suppose.
12:18:24 <SamB> what about a spear?
12:18:45 <basti_> maybe thats an arrow of arrows.
12:19:05 <SamB> I heard they had a hundred laws to satisfy...
12:19:41 <lispy> if you have a monad Foo and you write a function to unwrap it you could pull the "on" in monad out to the front and switch them around to spell no.  Then you'd have nomad :: Foo a -> a
12:20:08 <pesco> Sounds more like a punk monad.
12:23:19 <basti_> hmm how would that be possible? i only can think of one possible use: List Monad = ND computation, "head" will give you "some" result.
12:24:41 <lispy> basti_: depends on the monad
12:25:03 <lispy> unsafePerformIO is basically unwraps an IO monad
12:25:17 <basti_> hmm yes it might make sense in other contexts too
12:58:23 <boegel> what happened here ? netsplit ?
12:58:33 <jlouis> boegel: yes
12:58:45 <jlouis> boegel: Around (CEST) 21:32
13:00:06 <boegel> jlouis: what is a netsplit really ? I've heard about it, but I don't know what it is actually
13:05:11 <jlouis> boegel: the irc network consists of serveral servers routing irc messages between them. You connect to one of them. When the servers loose connections between each other somewhere, this is known as a net split. The consequence can be that the network breaks over in 2
13:05:23 <jlouis> boegel: does that suffice to answer your question?
13:06:23 <boegel> so when one node in the network becomes isolated, all the users on that node will be transferred to another one ?
13:06:26 <boegel> right ?
13:06:45 <jlouis> nope
13:07:06 <jlouis> they will remain on the disconnected node
13:07:44 <jlouis> therefore you will see massive parts when the network splits and massive rejoins when the network connection is reestablished
13:10:12 <boegel> oh, I see
13:10:19 <boegel> hey sylvan :)
13:10:38 <sylvan> hey
13:12:56 <boegel> does someone know how to put something in bold on the wiki ?
13:13:29 <lispy> '''bold''' ?
13:13:37 <lispy> i think that's how you do it on mediawiki
13:13:40 <boegel> yeah lispy, thanks
13:13:42 <lispy> but i dont' know about the haskell wiki
13:13:47 <boegel> I was using "' '"
13:15:56 <boegel> if anyone would like to help (in any way) on the H3D project in the future, please add your name on the wiki (no strings attached)
13:16:50 <lispy> H3D?  graphics?
13:17:05 <boegel> @wiki H3D
13:17:06 <lambdabot> http://www.haskell.org/hawiki/H3D
13:17:58 <lispy> finding housing in san jose is insane
13:18:13 <lispy> the prices seem to be $1200-$1800/month USD
13:18:32 <lispy> i have a two bedroom where i live for only $550/month
13:18:57 <tuomov> uh
13:19:20 <lispy> those san jose prices are for 1 bed room or studio
13:20:25 <tuomov> 550e/month maybe gets you a medium-sized "two rooms" (bad room and living room) over here
13:20:32 <tuomov> s/bad/bed/ :)
13:21:14 <boegel> 550€ over here gives you a nice appartment or small house
13:21:21 <lispy> ah, okay because the $550/month i pay now is a lot compared to where i used to live :)
13:21:22 <tuomov> depends on the area of course
13:21:33 <tuomov> in the middle of nowhere it gets you a lot
13:21:47 <tuomov> but close to city centres it's rather expensive
13:22:47 <tuomov> I pay 300e/month for 27m2 studio including utilities and net, but it's state-subsidised student flat
13:23:01 <lispy> e is euro?
13:23:04 <tuomov> yes
13:23:09 <xerox> As in: €
13:23:12 <xerox> ;)
13:23:49 <boegel> tuomov: those are student prices, it's similar over here
13:24:00 <jlouis> I am moving these days. Probably end up around 600-700e
13:24:05 <boegel> but when you're renting as a grown up (:p), then it costs you quite some more
13:24:23 <tuomov> a similar flat in the "open market" would be around 450 or more (it was built in 2002)
13:24:30 <tuomov> without utilities and net
13:28:38 <boegel> tuomov: where are you from ?
13:28:52 <tuomov> .fi, and tampere more specifically
13:29:08 <tuomov> although I'm trying move to jyväskylä atm
13:30:02 <xerox> @get-definition S
13:30:04 <lambdabot> S = \f g x.f x (g x)
13:31:36 <lispy> @get-definition Y
13:31:37 <lambdabot> Y = \f.U(\g.f(U g))
13:31:45 <lispy> @get-definition U
13:31:45 <lambdabot> U = \f. f f
13:32:14 <lispy> @get-definition head
13:32:15 <lambdabot> head not defined
13:32:48 <boegel> @get-definition map
13:32:48 <lambdabot> map = \f.foldr (\x y.f x:y) []
13:32:56 <boegel> why isn't head defined ? :)
13:32:57 <xerox> aha!
13:33:30 <wagle> 4@get-definition hd
13:33:43 <wagle> @get-definition hd
13:33:44 <lambdabot> hd not defined
13:33:53 <wagle> @get-definition List.head
13:33:54 <lambdabot> List.head not defined
13:33:56 <xerox> @get-definition foldr
13:33:57 <lambdabot> foldr = \c n l.if null l then n else c (head l) (foldr c n (tail l))
13:33:59 <wagle> huh
13:34:04 <boegel> strange eh ?
13:34:08 <xerox> Nice one.
13:34:11 <boegel> @get-definition tail
13:34:12 <lambdabot> tail not defined
13:34:23 <xerox> ahah.
13:34:23 <boegel> at least that makes sense :p
13:34:30 <xerox> oh sure :P
13:34:33 <boegel> :p
13:34:36 <wagle> @help
13:34:37 <lambdabot>  @help <command> - ask for help for <command>
13:34:46 <wagle> @list
13:34:46 <lambdabot> Maybe you meant: listchans listcommands listmodules dict
13:34:47 <boegel> @help get-definition
13:34:48 <lambdabot>  @get-definition name - get the expression defining name
13:35:21 <TheHunter> boegel, head and tail are probably built-ins
13:36:22 <wagle> whats the command for lambdabot to compute something (i forgot)
13:36:37 <TheHunter> @plugs 3 + 4
13:36:43 <lambdabot> 7
13:36:46 <TheHunter> @eval 3 + 4
13:36:47 <lambdabot> 7
13:36:51 <TheHunter> @pl 3 + 4
13:36:52 <lambdabot> 7
13:36:58 <xerox> @ 3 + 4
13:36:58 <wagle> @eval head "abc"
13:37:00 <lambdabot> Maybe you meant: all-dicts arr babel define definitions del-definition
13:37:00 <lambdabot> devils dice dict dict-help docs dummy dynamic-load dynamic-reload
13:37:00 <lambdabot> dynamic-unload easton echo elements eurohaskell eval fact fact-cons
13:37:00 <lambdabot> fact-delete fact-set fact-snoc fact-update foldoc fortune gazetteer
13:37:00 <lambdabot> get-definition ghc google help hitchcock index jargon join karma
13:37:00 <lambdabot> karma+ karma- kind learn leave libsrc listchans listcommands
13:37:02 <lambdabot> listmodules lojban moo more msg part paste pl pl-resume plugs
13:37:04 <lambdabot> [4 @more lines]
13:37:06 <xerox> ahah, sorry.
13:37:06 <lambdabot> a
13:37:26 * boegel hits xerox with a stone he just found
13:37:36 * xerox ouchs, and feels really sorry
13:37:55 * boegel pets xerox
13:38:01 <boegel> didn't mean to hit you that hard
13:38:20 <xerox> :| ooh-kay..
13:39:04 * SyntaxNinja pets xerox with boegel's stone
13:39:14 * boegel takes his stone back from SyntaxNinja 
13:40:03 * xerox puts the stone in a IO monad, now noone can get it out... and hit him.
13:40:27 * reffie shoots xerox 
13:40:38 <xerox> ...
13:40:43 * SyntaxNinja calls unsafeHitXeroxWithStone
13:41:06 * SyntaxNinja goes away to eat ice cream
13:41:08 <xerox> It's unsafe, I risk real damage this way... stoooop :(
13:41:10 <wagle> SyntaxNinja: thanks, thats what i was trying to come up with..  8)
13:41:10 * xerox hides
13:41:42 * boegel would like some ice cream
13:41:43 <jlouis> return (xerox)
13:41:49 <jlouis> ;)
13:41:53 * lispy agrees to the ice crea
13:41:59 <boegel> no, return (stone)
13:41:59 <boegel> :)
13:42:17 <jlouis> boegel: if both are inside the IO monad
13:42:19 <xerox> You can't!
13:42:32 <jlouis> ...
13:42:32 <xerox> I can't be put in a IO monad, obviously.
13:42:37 <boegel> *sigh
13:45:37 <boegel> hi icb, welcome to the famous #haskell channel
13:46:24 <lispy> quite famous actually
13:46:29 <xerox> icb, boegel just hit me multiple times with a stone, just to warn you.
13:46:43 <lispy> or wait, is this channel infamous...
13:46:51 <lispy> i forget...
13:47:51 <boegel> icb: don't listen to xerox, he was just hit by a stone and doesn't even remember who he is
13:48:06 <boegel> he's talking gibberish about someone named 'IO monad' or something
13:48:18 * xerox scratches his head...
13:48:51 * boegel thinks icb is really quiet
13:49:15 * xerox thinks boegel it's quiet not quiet as the nice icb is.
13:50:19 <basti_> @plugs drop 20 $ (foldl (.) id $ take 20 $ repeat $ scanl (+) 0) (take 20 [1..])
13:50:21 <lambdabot> [1,22,253,2024,12650,65780,296010,1184040,4292145,14307150,44352165,
13:50:21 <lambdabot> 129024480,354817320,927983760,2319959400,5567902560,12875774670,
13:50:21 <lambdabot> 28781143380,62359143990,131282408400]
13:50:25 <basti_> thats the ackermann function isnt it?
13:50:37 <basti_> or maybe something vaguely related
13:51:44 <boegel> @plugs (foldl (.) id $ repeat $ scanl (+) 0) (take 20 [1..])
13:51:48 <lambdabot> Terminated
13:51:52 <boegel> eh ? :)
13:52:03 <basti_> :-O
13:52:16 <boegel> I don't know what scanl or repeat do, but this looks strange :)
13:52:23 <boegel> did I just kill lambdabot ?
13:52:28 <boegel> it wasn't be !
13:52:31 <boegel> s/be/me
13:53:05 <basti_> @plugs take 10 $ repeat 'a'
13:53:07 <lambdabot> "aaaaaaaaaa"
13:53:29 <basti_> @plugs scanl (+) 0 $ take 10 [1..]
13:53:29 <zesjut> hi
13:53:31 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55]
13:53:32 <basti_> hi
13:54:04 <zesjut> has someone installed HSQL in Linux for MySQL?
13:54:10 <lispy> @get-definition scanl
13:54:10 <lambdabot> scanl = \c n.reverse . foldl (\x y.c (head x) y:x) [n]
13:54:25 <basti_> reverse my ass... tssss
13:54:25 <xerox> @type scanl
13:54:28 <boegel> hi zesjut
13:54:31 <lambdabot> scanl :: forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:54:37 <zesjut> hi boegel
13:54:57 <boegel> zesjut: whatever xerox says, don't pay attention to him :)
13:55:16 <zesjut> ok
13:55:29 <xerox> zesjut, whatever boegel said, don't pay attention to him :)
13:55:29 <boegel> hehe :D
13:55:46 * boegel heard something blow past his ear, and wonder what it is
13:55:53 * xerox picks a stone...
13:56:56 <zesjut> plz i need help, has anyone installed HSQL in Linux for MySQL?
13:57:05 * basti_ hasn't
13:57:07 <basti_> really
13:57:26 * boegel doesn't even know HSQL
13:57:42 <boegel> zesjut: tell us what your problem is, maybe we can help anyway
13:57:49 <lispy> zesjut: i would start by telling the channel what you have done and where you are stuck.  Be detailed and perhaps someone will know how to help.
13:58:11 <zesjut> ok
13:58:35 <boegel> lispy: I was first ! :p
13:58:54 <zesjut> i have ubuntu and i downloaded the HSQL package from sourceforge.net
13:59:11 <zesjut> when i type ./configure --enable-mysql
13:59:18 <zesjut> i get an error message
13:59:31 <lispy> boegel: ah....
13:59:36 <lispy> i wanted to be first...
13:59:57 <zesjut> the message is : configure: error: mysql_config is required to build MySQL binding
14:00:07 <lispy> zesjut: can you paste the somewhere like a pastebin and give us a url so we may examine?
14:00:14 <lispy> hmm...
14:00:18 <lispy> myslq_config
14:00:22 <basti_> zesjut: maybe you should have mysql_config.
14:00:40 <zesjut> i dont know what is mysql_config
14:01:00 <basti_> that's a little program that hands back lots of useful info about your mysql configuration
14:01:17 <basti_> like, where the database is, where a client is, where the pipe file is etc.
14:01:25 <lispy> which package is it in?
14:01:37 <lispy> ubuntu should be similar to debian
14:01:41 <basti_> hmm
14:01:44 <basti_> I'll have a look wait
14:01:47 * basti_ debian
14:03:05 <zesjut> ok ty
14:03:18 <zesjut> i cannot find mysql_config in google.com
14:04:14 <basti_> hmm
14:04:19 <basti_> apparently its a perl program in CPAN
14:04:19 <basti_> wait
14:05:15 <zesjut> okay
14:05:16 <arjanoosting> zesjut: have you tried apt-get install  libghc6-hsql-dev
14:05:56 <basti_> you can get mysql-config on cpan and build it by hand
14:06:00 <basti_> (google mysql config cpan)
14:06:23 * boegel enjoys finishing his thesis text while drinking a beer
14:06:23 <basti_> i have slight doubt if this is really the m-c we're talking about, but i do not find anything else
14:06:31 <zesjut> arjanoosting, no i have not tried apt-get isntall
14:07:03 <lispy> apt is your friend
14:07:25 <zesjut> i have synaptic packet manager
14:07:26 <arjanoosting> well i don't now whether the package is in Ubuntu but in Debian there is a package for hsql
14:07:46 <arjanoosting> well try to find it with synaptic then
14:08:01 <zesjut> iv trie already
14:08:04 <arjanoosting> but you should have apt-get installed as well
14:08:04 <zesjut> nothing
14:08:24 <zesjut> ok I shall try apt-get then
14:08:26 <arjanoosting> maybe you could download the debian package and try to install it
14:08:35 <arjanoosting> if apt-get doesn't work
14:08:52 <basti_> http://search.cpan.org/~DARREN/MySQL-Config-1.03/
14:09:18 <basti_> http://perl.active-venture.com/pod/perlmodinstall.html
14:10:19 <zesjut> output of apt-get install libghc6-hsql-dev: Reading Package Lists... Done
14:10:19 <zesjut> Building Dependency Tree... Done E: Couldn't find package libghc6-hsql-dev
14:10:32 <arjanoosting> download ftp://ftp.debian.org/debian/pool/main/h/haskell-hsql/libghc6-hsql-dev_1.4-3_i386.deb
14:10:47 <zesjut> ok
14:10:53 <arjanoosting> and do dpkg -i libghc6-hsql-dev_1.4-3_i386.deb
14:11:47 <arjanoosting> o wait
14:12:07 <arjanoosting> what version of ubuntu do you have? hoary
14:12:09 <arjanoosting> ?
14:12:34 <zesjut> i think i have warty
14:12:47 <lispy> warty?
14:12:50 <lispy> hoary?
14:12:52 <lispy> omg....
14:13:01 * lispy hugs his silly debian names
14:13:05 <arjanoosting> lispy: next one is breezy
14:13:12 <zesjut> output of dpkg : dpkg: dependency problems prevent configuration of libghc6-hsql-dev:
14:13:25 <zesjut> how can i resolve the dependencies
14:13:33 <basti_> hm
14:13:44 <arjanoosting> zesjut: what version of ghc do you have?
14:13:44 <basti_> how about you tell us WHAT dependencies aren't fulfilled? =)
14:14:08 <zesjut> arjanoosting, i have ghc 6.?
14:14:19 <lispy> 6. what?
14:14:24 <arjanoosting> ghc 6.4 or ghc 6.2.*?
14:14:24 <zesjut> dunno
14:14:30 <arjanoosting> ghc --version?
14:14:34 <zesjut> ok
14:14:39 <SamB> zesjut: why don't you give more of the dpkg output?
14:14:54 <zesjut> version ghc 6.2.1
14:15:20 <zesjut> samB:  libghc6-hsql-dev depends on ghc6 (>= 6.2.2); however:
14:15:21 <zesjut>   Version of ghc6 on system is 6.2.1-3.
14:15:21 <zesjut>  libghc6-hsql-dev depends on postgresql-dev; however:
14:15:21 <zesjut>   Package postgresql-dev is not installed.
14:15:21 <zesjut>  libghc6-hsql-dev depends on libmysqlclient12-dev; however:
14:15:21 <zesjut>   Package libmysqlclient12-dev is not installed.
14:15:28 <zesjut>  libghc6-hsql-dev depends on unixodbc-dev; however:
14:15:32 <zesjut> dependencies
14:15:50 <zesjut> i dunno how to resolve them manually
14:16:04 <arjanoosting> hmpf: the debian package won't help you then
14:16:10 <SamB> zesjut: you don't! you use apt.
14:16:22 <arjanoosting> dpkg --purge libghc6-hsql-dev
14:16:25 <boegel> hey Itkovian
14:16:33 <boegel> shouldn't you be in bed by now ? :)
14:16:50 <arjanoosting> SamB: ubuntu warty hasn't got libghc6-hsql-dev
14:16:59 <SamB> hmm
14:17:06 <lispy> apt-get update && apt-get upgrade
14:17:12 <lispy> that may help
14:17:22 <Itkovian> hey boegel
14:17:26 <lispy> apt-get install ghc/unstable
14:17:26 <SamB> apt-get --remove?
14:17:32 <SamB> er, s/--//
14:17:49 <arjanoosting> zesjut: best to upgrade to hoary which does have libghc6-hsql-dev
14:18:26 <zesjut> what is the difference between hoary and warty?
14:18:30 <arjanoosting> zesjut: the debian package won't help you anyway, so better just remove it dpkg --remove libghc6-hsql-dev
14:18:43 <SamB> zesjut: presumably one is newer than the other
14:18:50 <zesjut> i did dpkg --purge
14:18:50 <arjanoosting> new release of ubuntu
14:19:01 <arjanoosting> zesjut: thats allright
14:19:08 <lispy> zesjut: i can't speak for hoary and warty, but in the debian world the biggest difference is that the packages are newer
14:19:09 <zesjut> ok
14:19:28 <Igloo> Is it possible to ask dpkg if a deb came from ubuntu, BTW?
14:19:39 <zesjut> but debian is more difficult to use
14:20:00 <zesjut> i think
14:20:19 <arjanoosting> Igloo: don't think so
14:20:48 <zesjut> how can i upgrage to hoary?
14:20:51 <Igloo> Hmm  :-/
14:21:14 <lispy> zesjut: ah, my point was just that upgrading between releases shouldn't break anything, and will hopefully give you more recent copies of all the software youuse
14:21:16 <zesjut> have i to format the entire disk?
14:21:24 <lispy> no
14:21:28 <lispy> not if you can use apt
14:21:32 <arjanoosting> zesjut: change all the warty keywords in /etc/apt/sources.list to hoary; do an apt-get update ; apt-get dist-upgrade
14:21:54 <lispy> and you will want to check on it periodically
14:22:04 <lispy> it will probably ask you configuration questions
14:22:04 <arjanoosting> zesjut: and if it breaks you can keep the pieces :)
14:22:05 <zesjut> ty arjanoosting , going to try that
14:22:08 <lispy> on some packages
14:22:42 <arjanoosting> zesjut: just be a little bit carefull, cause I'm not an ubuntu man, i use plain Debian
14:23:37 <lispy> same here
14:24:13 <arjanoosting> zesjut: maybe read this first though: http://www.ubuntulinux.org/support/ReleaseNotes504
14:24:41 <arjanoosting> that should get you started with the upgrading process
14:25:32 <arjanoosting> seems the upgrade from warty to hoary is simpler than from woody to sarge though :-D
14:25:50 <zesjut> i have the ubuntu cd, how can i install hoary from scratch ?
14:26:07 <zesjut> i have my data backuped and all that
14:27:07 <zesjut> or how can i manage to install debian with gnome
14:27:16 <zesjut> bc i couldnt install it
14:27:44 <Igloo> zesjut: Have you tried the latest sarge pre-release?
14:27:57 <arjanoosting> zesjut: you don't need to install hoary from scratch; just follow the instructions from http://www.ubuntulinux.org/support/ReleaseNotes504
14:27:58 <zesjut> nope
14:28:24 <Igloo> If you last tried woody I think sarge is meant to be simpler (and will have better support for recent hardware)
14:28:49 <zesjut> like flash memories?
14:28:59 <zesjut> usb
14:29:21 <arjanoosting> yes that work
14:29:21 <Igloo> They should certainly be supported in sarge. Woody too I'd have thought
14:30:20 <zesjut> well, i shall try to install debian from scratch, but how can i install gnome when debian sarge installed
14:30:49 <zesjut> thank you all anyway :)
14:30:51 <arjanoosting> apt-get install gnome
14:31:19 <zesjut> and xwindows are installed automatically?
14:31:25 <Igloo> I'd have thought it would ask you about it when you install
14:32:35 <arjanoosting> well it does ask you what kind of machine you wan't to install (server, desktop etc) and install the appropriate packages
14:33:17 <arjanoosting> but it has been some time since i last installed Debian :)
14:35:18 <Igloo> I think I've actually installed sarge not too long ago, but not for a desktop, so I wasn't looking out for an option to install GNOME  :-)
14:35:41 <zesjut> well, i have to format my disk, thank you again and see you :)
14:40:19 <zesjut> hi
14:40:31 <zesjut> where can i download sarge prerelease?
14:41:30 * boegel leaves, bye everyone
14:41:45 <lispy> http://compsoc.dur.ac.uk/whitespace/index.php
14:42:41 <zesjut> ok ty lispy
14:43:31 <xerox> OK, goodnight folks.
14:43:52 <zesjut> goodnight
14:44:17 <zesjut> i cannot find sarge
14:44:25 <zesjut> any help is appreciate
14:44:26 <zesjut> d
14:45:10 <lispy> zesjut: sarge is a debian thing
14:46:09 <zesjut> so...
14:46:23 <zesjut> what do i do first
14:46:29 <zesjut> install debian woody?
14:47:22 <arjanoosting> zesjut: http://www.debian.org/devel/debian-installer/
14:47:46 <lispy> zesjut: are you switching to debian?
14:47:56 <zesjut> yeah
14:47:59 <zesjut> i am
14:48:01 <lispy> ah
14:48:19 <lispy> if you have a good fast 'net connection i'd use the net install
14:48:24 <lispy> or just burn the first cd
14:48:54 <lispy> and you may find it helpful to idle in #debian while you're installing it
14:49:07 <lispy> some real smart debian users there
14:50:15 <zesjut> ok
14:50:17 <zesjut> im in http://www.debian.org/CD/netinst/
14:50:45 <zesjut> but i want to install sarge, i cannot find it
14:51:00 <arjanoosting> zesjut: http://www.debian.org/devel/debian-installer/
14:51:16 <lispy> iirc, testing == sarge at the moment, but that's about to change
14:51:52 <zesjut> what do i choose arjanoosting?
14:51:56 <arjanoosting> you can download the netinst image from http://www.debian.org/devel/debian-installer/
14:52:25 <zesjut> ok for i386 right?
14:52:35 <lispy> yeah
14:52:38 <zesjut> and when sarge appears
14:52:41 <lispy> if you have a pentium style processor
14:53:02 <zesjut> yes i have a duron
14:53:22 <arjanoosting> just use the netinst image, then you will be install testing which is sarge
14:53:23 <zesjut> 100 MB im going for a cigarrete :P
14:53:39 <zesjut> testing
14:53:40 <zesjut> ok
14:53:51 <zesjut> ty
14:54:00 <lispy> good luck
14:54:08 <lispy> and don't forget about #debian
14:54:09 <arjanoosting> I must learn to type better English :)
14:54:19 <arjanoosting> he is already in #debian
14:55:41 <lispy> ah, cool
16:06:51 <anhanguera__> Haskell seems very different from lisp. In the quicksort example at haskell's website, it actually looked like prolog. Why is it considered functional?
16:08:05 <SamB> because it is based on lambda calculus!
16:12:04 <Cale> Haskell is more functional than lisp is, in my opinion.
16:12:29 <SamB> yes
16:12:30 <SamB> definately
16:12:44 <SamB> lisp is like macronal
16:13:26 <lispy> lisp is a programmable language and very multiparadigm
16:13:54 <lispy> but yeah, Haskell is pure functional, lisp is just functional (plus a bunch of other paradigms)
16:14:38 <autrijus> somehow this thing amuses me
16:14:40 <autrijus> (Nothing :: Maybe ())
16:18:26 <autrijus> omg
16:18:33 <autrijus> pugs_Apply("&isa", val, isa)
16:18:41 <autrijus> dear clkao this is so borked
16:18:43 <autrijus> check prototype
16:19:02 <Khisanth> autrijus: aren't you typing in the wrong channel?
16:19:09 <autrijus> I am.
16:19:12 <autrijus> sorry.
16:19:12 <Khisanth> :)
16:19:17 <autrijus> thanks!
16:19:55 * kaol is about to use map (>>=) to [a -> Maybe b]. Can you get more cool than that?
16:20:21 <kaol> does that make sense? I don't know.
16:20:39 <kaol> maybe fold instead...
16:21:38 <monochrom> (.).(.) is still the coolest
16:21:56 <lispy> what does (.).(.) do?
16:22:02 <lispy> @type (.).(.)
16:22:08 <lambdabot> (.).(.) :: forall a b c a1.
16:22:08 <lambdabot>     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:22:22 <monochrom> The cool part is I don't know what it's good for :)
16:23:14 <SamB> it looks cute
16:23:21 <SamB> thats what it does
16:25:11 <kaol> ooh, now I know. fold and mplus.
16:29:04 <lispy> this is weird
16:29:11 <lispy> @type (.).(.)
16:29:12 <lambdabot> (.).(.) :: forall a b c a1.
16:29:12 <lambdabot>     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:29:17 <lispy> @type (.).(.) negate
16:29:18 <lambdabot> (.).(.) negate :: forall b a b1.
16:29:18 <lambdabot>       (Num b1) =>
16:29:18 <lambdabot>       (b -> b1) -> (a -> b) -> a -> b1
16:29:21 <lispy> @type negate
16:29:22 <lambdabot> negate :: forall a. (Num a) => a -> a
16:30:09 <lispy> shouldn't (.).(.) negate :: forall a b c a1. (a -> a1 -> b) -> a -> a1 -> c
16:30:50 <lispy> @type ((.).(.)) negate
16:30:52 <lambdabot> ((.).(.)) negate :: forall a b a1.
16:30:52 <lambdabot>        (Num b) =>
16:30:52 <lambdabot>        (a -> a1 -> b) -> a -> a1 -> b
16:30:59 <lispy> @type ((.).(.)) negate (+) 1 2
16:31:01 <lambdabot> ((.).(.)) negate (+) 1 2 :: forall a. (Num a) => a
16:31:11 <lispy> @hugs ((.).(.)) negate (+) 1 2
16:31:13 <lambdabot> -3
16:31:16 <lispy> nice
16:32:29 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [1..4]
16:32:30 <lambdabot> -4
16:32:41 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [1..5]
16:32:43 <lambdabot> -1
16:32:47 <lispy> i love this function
16:33:04 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [1..-3]
16:33:05 <lambdabot> Variable not in scope: `..-'
16:33:12 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [-1..-3]
16:33:13 <lambdabot> Variable not in scope: `..-'
16:33:16 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [-1.. -3]
16:33:18 <lambdabot> Fail: Prelude.foldl1: empty list
16:33:56 <lispy> @hugs foldl1 (((.).(.)) negate (+)) [2.. 4]
16:33:58 <lambdabot> 1
16:34:44 <lispy> @hugs foldl1 (((.).(.)) id (+)) [2.. 4]
16:34:46 <lambdabot> 9
16:35:26 <lispy> well, enough of that :)
17:14:39 <Spark> @hugs foldl1 (((.).(.)) id (+)) [1..10]
17:14:41 <lambdabot> 55
17:14:55 <Spark> @hugs foldl1 (((.).(.)) id (*)) [1..4]
17:14:56 <lambdabot> 24
17:15:04 <Spark> @hugs foldl1 (((.).(.)) id (^)) [1..4]
17:15:05 <lambdabot> 1
17:15:10 <Spark> @hugs foldl1 (((.).(.)) id (^)) [2..4]
17:15:11 <lambdabot> 4096
17:16:29 <^buggler^> anyone know where I can find a guide to spacing on haskell?
17:16:46 <^buggler^> I have this function that has several equations and also some of which are piecewise defined
17:16:58 <^buggler^> I am trying to make a where clause for everything but it's still saying undefined variable
17:17:17 <dons> you should read the layout guide in the haskell98 defn, at haskell.org
17:17:22 <Spark> @hugs foldl1 (((.) (.) (.)) id (*)) [1..4]
17:17:24 <lambdabot> 24
17:17:26 <dons> but undefined variable could be anything
17:17:44 <dons> btw guys, the real command is @plugs, @hugs is getting spell-checkeinto @plugs
17:17:51 <dons> @help plugs
17:17:53 <lambdabot>  @plugs <expr>
17:17:53 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
17:18:30 <Spark> @type (.)
17:18:35 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
17:19:24 <Spark> @hugs foldl1 ((.) (.) (.) (+) (*)) [1..4]
17:19:26 <lambdabot> Occurs check: cannot construct the infinite type: b = b -> b
17:19:26 <lambdabot>    Expected type: (b -> b) -> (b -> b) -> b
17:19:26 <lambdabot>    Inferred type: (b -> b) -> (b -> b) -> b -> b
17:19:38 <Spark> @hugs foldl1 ((.) (.) (.) (+1#) (*)) [1..4]
17:19:39 <lambdabot> parse error on input `)'
17:19:48 <Spark> @hugs foldl1 ((.) (.) (.) (+ 1) (*)) [1..4]
17:19:50 <lambdabot> 41
17:19:54 <Spark> @hugs foldl1 ((.) (.) (.) (+ 1) (*)) [1..10]
17:19:56 <lambdabot> 6235301
17:20:08 <Spark> @hugs foldl1 ((.) (.) (.) (- 1) (*)) [1..4]
17:20:09 <lambdabot> <Plugins.Eval>:1:
17:20:09 <lambdabot>   No instance for (Num (c -> c))
17:20:09 <lambdabot>   arising from the literal `1'
17:20:22 <Spark> @hugs foldl1 ((.) (.) (.) (+ ~1) (*)) [1..4]
17:20:23 <lambdabot> Pattern syntax in expression context: ~1
17:20:46 <Spark> @hugs foldl1 ((.) (.) (.) (+ (-1)) (*)) [1..4]
17:20:48 <lambdabot> 7
17:20:52 <Spark> :)
17:21:15 <Spark> @hugs print "moo"
17:21:16 <lambdabot> No IO allowed
17:21:36 <Spark> @plugs \x.xx
17:21:37 <lambdabot> parse error on input `.'
17:21:55 <Spark> @plugs \x->x
17:21:56 <lambdabot> <Plugins.Eval>:1:
17:21:56 <lambdabot>   No instance for (Show (t -> t))
17:21:56 <lambdabot>   arising from use of `show'
17:22:05 <^buggler^> Hm i'm pretty sure it's due to layout error
17:22:06 * ^buggler^ shrugs
17:22:12 <^buggler^> i'll read the thing, thanks
17:22:25 <Spark> @plugs (\x -> x x) (\y -> y y)
17:22:26 <lambdabot> Occurs check: cannot construct the infinite type: t = t -> t1
17:22:26 <lambdabot>    Expected type: t
17:22:26 <lambdabot>    Inferred type: t -> t1
17:22:55 <Spark> @plugs \f -> (\x -> f(x x)) (\y -> f(y y))
17:22:56 <lambdabot> Occurs check: cannot construct the infinite type: t = t -> t1
17:22:56 <lambdabot>    Expected type: t
17:22:56 <lambdabot>    Inferred type: t -> t1
17:23:35 <Spark> @hugs performUnsafeIO (print "moo")
17:23:36 <lambdabot> Variable not in scope: `performUnsafeIO'
17:23:59 <Spark> @plug let I = \x->x in I I
17:24:01 <lambdabot> Data constructor not in scope: `I'Data constructor not in scope: `I'
17:24:02 <lambdabot> Data constructor not in scope: `I'
17:24:05 <Spark> @plug let i = \x->x in I I
17:24:06 <lambdabot> Data constructor not in scope: `I'Data constructor not in scope: `I'
17:24:09 <Spark> @plug let i = \x->x in i i
17:24:10 <lambdabot> <Plugins.Eval>:1:
17:24:10 <lambdabot>   No instance for (Show (t -> t))
17:24:10 <lambdabot>   arising from use of `show'
17:24:21 <Spark> @plug let i = \x->x in (i i)
17:24:22 <lambdabot> <Plugins.Eval>:1:
17:24:22 <lambdabot>   No instance for (Show (t -> t))
17:24:22 <lambdabot>   arising from use of `show'
17:24:27 <Spark> @plug let i = \x->x in (i i) 1
17:24:29 <lambdabot> 1
17:26:34 <^buggler^> dons: Is it possible to provide where statements for the whole function definition even when the function is speciied with more than one equation
17:26:37 <^buggler^> for example say I had
17:26:39 <Spark> @plug let fix f = f (fix f) in fix (\f n -> if n = 0 then 1 else n * f (n - 1)) 4
17:26:40 <lambdabot> parse error on input `='
17:26:53 <^buggler^> f [] = t
17:26:57 <Spark> @plug let fix f = f (fix f) in fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 4
17:26:59 <lambdabot> 24
17:27:04 <^buggler^> f x | a = t*t
17:27:10 <^buggler^>     | b = t*t - t
17:27:34 <^buggler^>     where t = c
17:27:37 <^buggler^> or something
17:27:52 <^buggler^> bah, I'll just try it out :P
17:28:05 <Spark> @plug let i = i in 1
17:28:07 <lambdabot> 1
17:28:10 <Spark> @plug let i = i in i
17:28:11 <lambdabot> Ambiguous type variable `a' in the top-level constraint
17:28:25 <dons> Spark, you might want to try this out in a /msg window to lambdabot?
17:28:25 <Spark> mmm constraints
17:28:30 <Spark> ah yes probably
17:28:33 <dons> :}}
17:29:26 <^buggler^> yeah it says "undefined variable t" :(
17:29:39 <^buggler^> foo :: [a] -> Int
17:29:39 <^buggler^> foo [] = t*t
17:29:39 <^buggler^> foo x | length x > 3 =  -1 * t
17:29:39 <^buggler^>       | otherwise = t
17:29:39 <^buggler^>         where t = 4
17:29:44 <dons> ^buggler^: no, 'where' is local. common functions would either have to be floated out too the top level, or you could merge the separate defns into a single one: f s = case s of [] -> t ; a -> ...
17:30:08 <dons> that 't' isn't visible in the foo [] line.
17:30:33 <^buggler^> is there any way I can make it visible?
17:30:47 <dons> merge the separate defns
17:31:05 <dons> foo x | x == [] = t*t | length x > 3 = ...
17:31:24 <^buggler^> so I just remove the enters? :/
17:31:34 * ^buggler^ looks at his function that spreads over 20 lines and cries
17:31:37 <dons> no.
17:31:47 <dons> you remove the separate defns for 'foo'
17:31:50 <dons> so you would write:
17:31:58 <dons> foo x | x == [] = t*t
17:32:03 <^buggler^> oh
17:32:05 <dons>       | lenght x > 3 = ..
17:32:07 <dons> and so on.
17:33:01 <^buggler^> How would I do pattern patching without the use of ==, for example I want to match to certain data types
17:33:19 <dons> use 'case'
17:33:31 <dons> case x of [] -> ... for example
17:39:01 <dons> @seen basti_
17:39:02 <lambdabot> I saw basti_ leaving #haskell 2 hours, 4 minutes and 35 seconds ago.
17:47:50 * dons tags lambdabot 3
18:11:45 <lispy> i usually use nested wheres
18:12:01 <lispy> i'm not a fan of case, although, it certainly comes in handy
18:13:10 <Cale> I think case is a pretty fundamental construction, it's pretty hard to avoid it, except by only using it implicitly by making multiple declarations.
18:13:55 <resiak> Ordering doesn't matter with case, does it?
18:14:40 <mugwump> case as in, | (cond) = result | otherwise = result ?
18:15:09 <lispy> mugwump: those are guards i think
18:15:48 <mugwump> but you can do case-like things with them...
18:15:56 * mugwump hmms
18:16:48 <dons> it's all compiled to a case anyway though
18:17:16 <dons> all allocations are done via lets, and all patterns matching and evaluation is done via case
18:18:46 <Cale> case as in the sort of thing which lets you write case x of Just u -> 2 * u; Nothing -> 0
18:19:49 <dons> yeah. it's the only construct for forcing or pattern matching in the backend of ghc
18:20:25 <dons> and let is the only way to do allocations (in haskell code)
18:34:39 <lispy> has one one made a haskell compiler that targets thet jvm yet?
18:37:10 <vincenz> Hi!
18:37:30 <dons> there's been a few research projects, going back to the early 90s
18:42:07 <lispy> ah
18:42:29 <lispy> i found release notes for a JVM bridge
18:45:13 <lispy> Mondrian.Net
18:45:21 <lispy> that comes up searching for haskell on the jvm
18:49:50 <lispy> not sure why i care :)
18:53:36 <mugwump> just how do you compile a continuation to a JVM anyway?
18:54:20 <vincenz> Hello
18:54:32 <vincenz> are typeclasses possible without doing runtime stuff?
18:54:34 <SamB> mugwump: with a trampoline?
18:54:37 <dons> anything that doesn't have a direct representation in the jvm you implement as an object running on top.
18:54:44 <dons> so you may need to write your own stack
18:54:51 <mugwump> ouch
18:55:05 <SamB> vincenz: I think so, jhc seems to
18:55:34 <dons> typeclasses aren't too magic.  they're just data structures with functions inside -- sounds like a Java class to me
18:56:04 <dons> anyway, there's been 4 or 5 successful ports to the jvm. but performance always sucks
18:56:47 * vincenz is thinking of making a caml variant with typeclasses
18:56:52 <dons> the way that haskell messes with the heap is completely unlike how the jvm expects it to be used -- jvms are optimised for different patterns of use
18:57:13 <dons> also, destructive updates of closures (which are represented by classes) is *hard*
18:57:30 <dons> so you end up with a redirection instead, further killing performance
18:57:49 <dons> summary: don't compile haskell to the jvm
18:57:53 <SamB> dons: isn't JVM performance supposed to suck? Java's does!
18:57:55 <lispy> heh
18:58:13 <dons> yeah, maybe it was just designed that way
18:58:20 <lispy> dons: so you should have an interpreter for haskell that runs on the jvm instead :)
18:58:22 <dons> to make us all buy faster computers
18:59:30 <SamB> you should write the JVM in Haskell
19:00:46 <mugwump> didn't take autrijus long to do that for the parrot machine..
19:01:28 <mugwump> (if that's what I understand he did, that is)
19:04:34 <lispy> sweet, that's two computers in my house today that have turned off because of the heat
19:22:03 <sylvan> has anyone managed to try out jhc? I can't get it to work.. When making it complains that hashPS in Atom.o is not in scope...
19:23:09 <sylvan> (anyone know where hashPS is defined?
19:25:39 <dons> @version
19:25:40 <lambdabot> lambdabot 3p1, GHC 6.4 (OpenBSD i386)
19:25:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:25:44 <dons> :)
19:27:10 <lispy> @uptime
19:27:11 <lambdabot> uptime: 2 minutes and 10 seconds
19:27:28 <lispy> dons: version 3 has terrible uptime :)
19:28:04 <lispy> what is new in this version?
19:29:13 <dons> I've just tagged all the work we've done over the last 2 months.
19:29:25 <dons> i'll make an announce in a few minutes
19:31:23 <lispy> (looking at TODO) i agree, factoring out an irc library would be nice
19:37:17 <lispy> i should finish the bot i was writting in CL
19:37:27 <lispy> only reason i stopped was a threading bug
19:37:47 <lispy> but i believe it has been fixed in the compiler now
19:39:05 <lispy> then the next challenging place in implementing MegaHal, the only implemenation i have to go by is some ugly C code, and I know it can be done better :)
19:41:56 <MachinShin> hey +
19:42:20 <lispy> @type hey +
19:42:21 <lambdabot> bzzt
19:42:34 <lispy> @type hey (+)
19:42:36 <lambdabot> bzzt
19:42:50 <lispy> @type 1 +
19:42:52 <lambdabot> bzzt
19:42:55 <lispy> @type (1 +)
19:42:57 <lambdabot> (1 +) :: forall a. (Num a) => a -> a
19:43:09 <lispy> @type $ 1 +
19:43:10 <lambdabot> bzzt
19:43:22 <lispy> interesting
19:44:44 <dons> @type ($) (+1)
19:44:46 <lambdabot> ($) (+1) :: forall a. (Num a) => a -> a
19:49:19 <mugwump> @type $
19:49:20 <lambdabot> bzzt
19:49:33 <mugwump> @type ($)
19:49:34 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
19:49:54 <mugwump> @type (+)
19:49:56 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
20:02:38 <lispy> @get-definition ($)
20:02:39 <lambdabot> ($) not defined
20:20:21 <[TWiSTED]> hi Lemmih you there?
20:23:15 <[TWiSTED]> or perhaps someone could help us out?
20:28:13 <kaol> @moo
20:28:14 <lambdabot>          (__)
20:28:14 <lambdabot>          (oo)
20:28:14 <lambdabot>   /-------\/
20:28:14 <lambdabot>  / |     ||
20:28:14 <lambdabot> *  ||----||
20:28:14 <lambdabot>    ~~    ~~
20:28:16 <lambdabot>      Cow
20:29:11 <[TWiSTED]> @meow
20:29:12 <lambdabot> Maybe you meant: moo yow
20:29:23 <[TWiSTED]> @yow
20:29:25 <lambdabot> 	Talking Pinhead Blues:
20:29:25 <lambdabot> Oh, I LOST my ``HELLO KITTY'' DOLL and I get BAD reception on
20:29:25 <lambdabot> channel
20:29:25 <lambdabot>   TWENTY-SIX!!
20:29:25 <lambdabot>  
20:29:25 <lambdabot> Th'HOSTESS FACTORY is closin' down and I just heard ZASU PITTS has
20:29:28 <lambdabot> been
20:29:29 <lambdabot> [9 @more lines]
20:29:47 <[TWiSTED]> @more
20:29:49 <lambdabot>   DEAD for YEARS..  (sniff)
20:29:49 <lambdabot>  
20:29:49 <lambdabot> My PLATFORM SHOE collection was CHEWED up by th' dog, ALEXANDER
20:29:49 <lambdabot> HAIG
20:29:49 <lambdabot>   won't let me take a SHOWER 'til Easter ... (snurf)
20:29:49 <lambdabot>  
20:29:51 <lambdabot> So I went to the kitchen, but WALNUT PANELING whup me upside mah
20:29:53 <lambdabot> HAID!!
20:29:55 <lambdabot>   (on no, no, no..  Heh, heh)
20:30:21 <[TWiSTED]> i see
20:31:20 <kaol> @woof
20:31:20 <lambdabot>          (__)
20:31:20 <lambdabot>          (oo)
20:31:20 <lambdabot>   /-------\/
20:31:20 <lambdabot>  / |     ||
20:31:20 <lambdabot> *  ||W---||
20:31:21 <lambdabot>    ~~    ~~
20:31:24 <lambdabot>   Cow laden
20:31:26 <lambdabot>   with milk
20:35:29 <dons> lambdabot 3.0 is released!
20:35:49 <kaol> does it do any tricks?
20:37:26 <dons> all the stuff you've been playing with for the last 2 months :)
20:37:58 <lambdabot> I have many talents
20:40:02 <kaol> @vixen make me a cup of tea
20:40:03 <lambdabot> Wouldn't it be funny if I really was a super model?
20:44:57 <vincenz> Ugh, I hate pdf
21:00:21 <MachinShin> night all
21:03:26 * Cale is currently listening to a reggae version of "Dark Side of the Moon". This is surreal.
21:04:29 <dons> oh, I think i've heard that.
21:04:39 <dons> some new york guys?
21:08:36 <Cale> It's called "Dub Side of the Moon" by the "Easy Star All Stars" apparently.
21:09:23 <dons> yep, that's the one.
21:20:50 <vincenz> do type classes require runtime dispatching?
21:20:57 <vincenz> or can it be fully resolved at compiletime?
21:24:19 <jemfinch> ok, I didn't really get an answer to my question from last night, so I'm back to ask it again :)
21:24:23 <mugwump> Cale: there is no Dub side of the moon.  It is all dub, mon
21:24:47 <jemfinch> I need to keep a sequence of two different types, interleaved in some way.
21:25:16 <jemfinch> Obviously, I could just use a list of a datatype with two members, X and Y, but that doesn't capture the "interleaving" invariant.  I'd like a data structure that would.
21:25:40 <dons> it's known at compile time exactly which function you are calling, vincenz. => is a short hand for a data structure argument containing the required instance. so classes just compile to normal function calls
21:26:50 <vincenz> yes
21:26:52 <vincenz> but you have an overhead
21:26:57 <dons> jemfinch, what about a list of X | Y? would that do it?
21:26:59 <vincenz> each time you have to go look inside the tuple for the func
21:27:04 <vincenz> I'm reading Wadler's original paper
21:27:09 <jemfinch> dons: that's what I said didn't capture the interleaving invariant.
21:27:59 <dons> what about X | Y, and a "smart" constructor that controls how you build the list
21:28:01 <jemfinch> I can have "Y", "YX", "XY", "XYX", "XX", etc.  Basically, the language is "Y?(X+Y?)*"
21:29:42 <dons> so newtype InterList = InterList [Either X Y], hide the constructor InterList, export a icons (or   whatever) that only adds to the list if the interleaving conditions are satisified
21:30:02 <dons> then you know that InterList is always going to be well formed
21:30:18 <jemfinch> dons: yes, that'd be a possibility, if I were doing this in Haskell.
21:30:41 <dons> oh. :/
21:30:41 <jemfinch> but I'm not really interested in tricks that solve the problem; I'm interested in an actual data structure that (no tricks involved) solves the problem.
21:31:51 <jemfinch> I'm actually writing in a dynamically typed language, but as a general rule, data structures that I can't represent in a language like Haskell or SML, I don't understand fully, which is why I'm trying to figure out how I could represent this.
21:32:57 <autrijus> it may be that you need a type-regex level language to specify this
21:33:09 <autrijus> which can be compiled down to haskell
21:35:55 <autrijus> using typeclasses and fundep and friends
21:35:55 <vincenz> dons: specifically, how much performance do you lose
21:35:55 <dons> since you can represent the properties with a regex, you should be able to write a lexer (smart constructor) in any language to build a data structure with the required property. the lexer would be your constuctor. or encode the grammar on the type level with a GADT perhaps
21:35:55 <dons> there's quite a few ways to reflect a list into a type
21:35:55 <dons> vincenz, lose compared to?
21:35:55 <jemfinch> you haskellers have far too many tools at your disposal :)
21:35:55 <dons> oh, once again - you have no way to encode this property in the language youu're using. i keep forgetting :}
21:35:55 <autrijus> what is the language you're using anyway?
21:35:55 <dons> i think using a lexer as your constructor will work everywhere.
21:35:55 <jemfinch> dons: there is a way to encode this property in any standard HM typesystem, I'm sure.
21:35:55 <dons> sure: an abstract syntax
21:36:39 <vincenz> dons: Wadler's original paper "It is worthwhile to compare the efficiency of this translation technique with polymorphic equality as found in Standard ML or Miranda.  The individual operations, such as eqInt are slightly more efficient than polymorphic equality, because the type of the argument is known in advance.  On the other hand, operations such as member and eqList must explictly pass an equality operation around, an overhead that polym
21:36:40 <dons> Sy  = L (Maybe Y) L' ; L' = L' X Y X L'' ; L'' = L'' (Maybe Y) or so
21:37:57 <dons> vincenz, I see what you mean. the overhead of looking up a data structure to find the function to use. one indirection I guess.
21:38:57 <vincenz> well how much penalty hit do you get in a system built up from type classes
21:40:21 <dons> one extra indirection per type-classed method call? versus how much less code you need to write, which has  its own costs.
21:41:02 <vincenz> performance is an issue with me
21:41:35 * vincenz is thinking of making a caml variant with type classes
21:42:33 <vincenz> what I really like is the link between type classes and category theory
21:42:36 <dons> I have never heard of a performance problem related to type classes before
21:43:23 <vincenz> haskell is slow
21:44:16 <dons> that's a generalisation.
21:44:56 <dons> you can easily write fast haskell - it looks like C or some strict functional language
21:45:10 <Cale> Not necessarily
21:45:19 <dons> or just plain normal haskell
21:45:26 <Cale> I suppose it depends heavily on what you're writing
21:45:42 <Cale> Sometimes the laziness is exactly what you want for things to be fast.
21:45:50 <vincenz> mm
21:45:51 <vincenz> anyways
21:45:54 <vincenz> I have to go sleepy
21:45:57 * vincenz waves
22:01:02 <[TWiSTED]> given a function parseElement; which changes a String into a list of tuples eg. parseElement "hi123" = [("hi",123)] , i need to make a function that does the same as parseElement but allowing it to split the string up multiple times eg. "hi12hey34ahoy56" = [("hi",12) , ("hey",34) , ("ahoy",56)] . i know this can be done recursively but am unsure how to exactly go about it.
22:02:49 <dons> [TWiSTED], is this a homework question?
22:03:30 <Lor> From your description it is quite unclear what parseElement does.
22:04:03 <dons> you've been given several hints - in particular Lemmih wrote the code yesterday, if I recall correctly..
22:05:47 <dons> @hawiki HomeworkHelp
22:05:48 <lambdabot> http://www.haskell.org/hawiki/HomeworkHelp
22:06:34 <[TWiSTED]> yea
22:06:36 <[TWiSTED]> i got that code
22:07:00 <[TWiSTED]> but i still dont but i cant really modify it to match the datatype i require
22:07:49 <Cale> [TWiSTED]: figure out how to cut the string as: "hi12hey34ahoy56" -> ["hi12", "hey34", "ahoy56"]
22:08:56 <[TWiSTED]> ok
22:09:00 <Cale> You can do this in a nice abstract way with library functions, or in a fairly low level way with recursion.
22:09:59 <Cale> The strategy I suggest is to figure out how to just cut out the first one: if you can do "hi12hey34ahoy56" -> ("hi12", "hey34ahoy56")
22:10:10 <Cale> then you can finish the work rather easily
22:10:58 <[TWiSTED]> yea so basically have a test where it breaks the string when the next character occurs
22:15:25 <[TWiSTED]> @break (isDigit) "hi12hey34ahoy56"
22:15:27 <lambdabot> Unknown command, try @listcommands.
22:15:32 <[TWiSTED]> @listcommands
22:15:34 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
22:15:34 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
22:15:34 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
22:15:34 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
22:15:34 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
22:15:34 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
22:15:36 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
22:15:38 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
22:15:40 <lambdabot> wiki wikipedia wn world02 yow
22:15:56 <Lemmih> @plugs break isDigit "hi12hey34"
22:16:00 <lambdabot>   Warning: Module `Data.FiniteMap' is deprecated: Please use Data.
22:16:00 <lambdabot> Map instead.
22:16:12 <Cale> @plugs break isDigit "hi12hey34ahoy56"
22:16:14 <lambdabot>   Warning: Module `Data.FiniteMap' is deprecated: Please use Data.
22:16:14 <lambdabot> Map instead.
22:16:16 <Cale> hmm...
22:16:19 <Lemmih> Heh
22:16:20 <Cale> @plugs 2 + 2
22:16:22 <lambdabot>   Warning: Module `Data.FiniteMap' is deprecated: Please use Data.
22:16:22 <lambdabot> Map instead.
22:16:24 <Cale> heh
22:16:26 <[TWiSTED]> lol
22:16:31 <Lemmih> Hurrah for version 3!
22:16:35 <Cale> :|
22:16:39 <dons> oops.
22:16:40 <Cale> ouch
22:16:52 <dons> my fault. gimme 2 secs.
22:17:16 <[TWiSTED]> is there a function like isChar ?
22:17:23 <dons> @plugs 1 ++ 2
22:17:25 <lambdabot> <Plugins.Eval>:1:
22:17:25 <lambdabot>   No instance for (Num [a])
22:17:25 <lambdabot>   arising from the literal `2'
22:17:26 <dons> @plugs 1 + 2
22:17:28 <lambdabot> 3
22:17:35 <Cale> @plugs break isDigit "hi12hey34ahoy56"
22:17:36 <lambdabot> ("hi","12hey34ahoy56")
22:17:46 <Lemmih> @plugs break (not.isDigit) "hi12hey34"
22:17:48 <lambdabot> ("","hi12hey34")
22:18:06 <Cale> @plugs break (not.isDigit) "12hey34ahoy56"
22:18:08 <lambdabot> ("12","hey34ahoy56")
22:19:21 <[TWiSTED]> hm
22:19:35 <[TWiSTED]> how can i get it so it includes that 12 aswell
22:26:21 <mihochan> names
22:28:23 <mihochan> names #haskell
22:30:07 <dons> hi mihochan, new to #haskell?
22:30:34 <dons> new to haskell even? or long time hacker?
22:30:36 <mihochan> no not really.
22:30:57 <mihochan> i've been using haskell for about three or four years
22:31:12 <dons> cool. good to see some more .au haskellers.
22:31:30 <mihochan> i am pretty new to irc though
22:31:40 <dons> hehe :}
22:31:41 <[TWiSTED]> im .au but a shit haskeller aha
22:31:57 <mihochan> i am here searching for the haskell bot
22:32:04 <dons> @version
22:32:05 <lambdabot> lambdabot 3p0, GHC 6.4 (OpenBSD i386)
22:32:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:32:22 <mihochan> looks like it found me.
22:32:50 <mihochan> how do I address someone ( ie the bot ) directly?
22:33:03 <dons> what do you mean?
22:33:27 <dons> you can run the known commands (which are all prefixed with '@')
22:33:28 <mihochan> i want to talk to lambdabot
22:33:39 <dons> privately, on on the main channel?
22:33:47 <dons> @plugs 1 + 2
22:33:49 <lambdabot> 3
22:33:50 <dons> @type 1
22:33:52 <lambdabot> 1 :: forall t. (Num t) => t
22:33:53 <mihochan> don't care much
22:33:58 <dons> @kind Int -> Int
22:33:59 <mihochan> ok I get it now
22:33:59 <lambdabot> Int -> Int :: *
22:34:11 <dons> @listcommands
22:34:12 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
22:34:12 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
22:34:12 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
22:34:12 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
22:34:12 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
22:34:12 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
22:34:14 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
22:34:16 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
22:34:18 <lambdabot> wiki wikipedia wn world02 yow
22:34:27 <yain> @info print
22:34:28 <lambdabot> Unknown command, try @listcommands.
22:34:30 <yain> hm
22:34:34 <dons> @index print
22:34:35 <lambdabot> System.IO, Prelude
22:34:36 <mihochan> ok pretty cool.
22:34:47 <dons> @google lambdabot
22:34:49 <lambdabot> http://sourceforge.net/projects/haskell-libs/
22:34:49 <yain> think @kind/@type made me thought it's like ghci ;-)
22:34:51 <mihochan> it is really just a ghci terminal on irc
22:35:06 <dons> sort of. there's a few restrictions
22:35:11 <dons> @help plugs
22:35:13 <lambdabot>  @plugs <expr>
22:35:13 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
22:35:28 <dons> @plugs last [1..]
22:35:33 <lambdabot> Terminated
22:35:34 <dons> for example
22:35:37 <yain> cool
22:35:43 <mihochan> @1+1
22:35:45 <lambdabot> Unknown command, try @listcommands.
22:35:49 <dons> @google lambdabot site:.au
22:35:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:35:54 <dons> that's it.
22:36:01 <yain> @plugs log -1
22:36:03 <lambdabot> <Plugins.Eval>:1:
22:36:03 <lambdabot>   No instance for (Num (a -> a))
22:36:03 <lambdabot>   arising from the literal `1'
22:36:14 <yain> @plugs log (-1::Float)
22:36:16 <lambdabot> -Infinity
22:36:21 <mihochan> @listcommands
22:36:22 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
22:36:22 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
22:36:22 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
22:36:22 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
22:36:22 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
22:36:23 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
22:36:24 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
22:36:26 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
22:36:29 <lambdabot> wiki wikipedia wn world02 yow
22:36:32 <mihochan> @eval 1+1
22:36:33 <lambdabot> 2
22:36:50 <mihochan> so what will it do with an infinite list hehe
22:37:09 <mihochan> @eval take 20 [1..]
22:37:10 <lambdabot> (line 1, column 12):
22:37:10 <lambdabot> unexpected "."
22:37:10 <lambdabot> expecting simple term
22:37:21 <dons> @eval Y I
22:37:24 <lambdabot> out of fuel - use @resume to continue
22:37:40 <[TWiSTED]> ok ive got : break (isDigit) "hey12hey34ahoy56" = ("hey", "12hey34ahoy56") . how do i 'bring' that 12 over
22:38:15 <mihochan> @eval zip [1,2,3,4,5] [a,b,c,d,e]
22:38:16 <lambdabot> [<<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>, <<EM
22:38:16 <lambdabot> Dynamic -> EM Dynamic>>, <<EM Dynamic -> EM Dynamic>>, <<EM Dynamic -
22:38:16 <lambdabot> > EM Dynamic>>]
22:38:36 <thou> @plugs zip [1,2,3,4,5] [a,b,c,d,e]
22:38:37 <musasabi> morning
22:38:37 <lambdabot> Variable not in scope: `a'
22:38:37 <mihochan> @hitchcock
22:38:54 <thou> @plugs zip [1,2,3,4,5] ['a','b','c','d','e']
22:38:56 <lambdabot> [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e')]
22:39:06 <thou> mihochan: is that what you wanted?
22:39:13 <mihochan> yeah
22:39:18 <thou> k
22:39:25 <mihochan> so what is the difference between plugs and eval?
22:39:26 <dons> @help eval
22:39:27 <lambdabot>  @eval expr - evaluate the lambda calculus expression, expr
22:39:39 <mihochan> @help plugs
22:39:40 <lambdabot>  @plugs <expr>
22:39:40 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
22:40:11 <mihochan> shall we try an infinite list ?
22:40:16 <thou> please do
22:40:30 <mihochan> @plugs [1..]
22:40:32 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
22:40:32 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
22:40:32 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
22:40:32 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
22:40:33 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
22:40:35 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
22:40:37 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
22:40:39 <lambdabot> [24 @more lines]
22:41:01 <mihochan> so it just allocates a certain amount of processor time?
22:41:40 <dons> you have 3 seconds, yep.
22:41:47 <seidan> I wish that said [countably many @more lines]
22:41:52 <yain> @vera
22:42:04 <mihochan> @help
22:42:05 <lambdabot>  @help <command> - ask for help for <command>
22:42:15 <mihochan> @listcommands
22:42:16 <lambdabot> all-dicts arr babel define definitions devils dice dict dict-help
22:42:16 <lambdabot> docs dummy easton echo elements eurohaskell eval fact fact-cons fact-
22:42:16 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer get-
22:42:16 <lambdabot> definition ghc google help hitchcock index jargon karma karma+ karma-
22:42:19 <lambdabot> kind learn libsrc listchans listcommands listmodules lojban moo more
22:42:21 <lambdabot> paste pl pl-resume plugs pointless prelude quote remember resume
22:42:22 <lambdabot> seen spell state timein todo todo-add topic-cons topic-init topic-
22:42:24 <lambdabot> snoc topic-tail topic-tell type uptime vera version vixen web1913
22:42:26 <lambdabot> wiki wikipedia wn world02 yow
22:42:30 <yain> @karma
22:42:31 <lambdabot> I can't find the karma of nobody.
22:42:40 <yain> @help karma
22:42:41 <lambdabot> return a person's karma value
22:42:45 <yain> @karma lambdabot
22:42:46 <lambdabot> lambdabot has a karma of 2
22:42:57 <yain> @karma dons
22:42:58 <lambdabot> dons has a karma of 6
22:43:06 <yain> what does that mean?
22:43:23 <yain> @help karma+
22:43:24 <lambdabot> increment someone's karma
22:43:32 <mihochan> @define fib 1 = 1
22:43:33 <yain> @karma+ lambdabot
22:43:33 <lambdabot> (line 1, column 4):
22:43:33 <lambdabot> unexpected "="
22:43:33 <lambdabot> expecting operator, simple term or end of input
22:43:34 <lambdabot> lambdabot's karma has been incremented
22:43:46 <mihochan> @define fib 2 = 1
22:43:47 <lambdabot> (line 1, column 4):
22:43:47 <lambdabot> unexpected "="
22:43:47 <lambdabot> expecting operator, simple term or end of input
22:44:00 <yain> @help define
22:44:01 <lambdabot>  @define name expr - define name to be expr
22:44:17 <mihochan> @define fib n = (fib (n-1)) + (fib (n-2))
22:44:19 <lambdabot> (line 1, column 4):
22:44:19 <lambdabot> unexpected "="
22:44:19 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[",
22:44:19 <lambdabot> string, "(", operator, simple term or end of input
22:44:54 <mihochan> bye all must work
22:45:11 <dons> ok.
22:46:14 <thou> @paste
22:46:15 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:47:04 <yain> @uptime
22:47:05 <lambdabot> uptime: 3 hours, 22 minutes and 4 seconds
22:47:14 <yain> not very impressive :D
22:47:24 <yain> @pointless
22:47:25 <lambdabot> (line 1, column 1):
22:47:25 <lambdabot> unexpected end of input
22:47:25 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
22:47:25 <lambdabot> expression
22:47:26 <dons> today was version 3's debut.
22:47:37 <yain> @help pointless
22:47:38 <lambdabot>  @pointless <expr> - play with pointfree code
22:47:43 <dons> 13:39  lambdabot:: uptime: 27 days, 2 hours, 29 minutes and 10 seconds
22:48:13 <dons> the usual reason to quit is because of new code in the static core, or networks playing up
22:48:36 <dons> it's been a *long* time since we've had a crash
22:48:42 <yain> ic
22:49:07 <dons> @pl \x -> x x
22:49:08 <lambdabot> join id
22:53:10 <thou> would anyone mind helping my with some style question?  the code at http://www.haskell.org/hawiki/HaskellIrcPastePage works, but it feels ugly and hard to understand / maintain
22:55:23 <yain> looks like c :D
22:55:31 <thou> hehe
22:55:57 <thou> it was prompted by someone asking on haskell-beginners how to do it without using hGetLine
22:56:40 <thou> i thought, hmmm, i'll just cook up a quick example and answer him, and then it turned out to be harder for me than i expected.  :-)
22:57:42 <thou> oops, aside from the fact that it's broken (a single '\n' won't end a line, it has to be "\r\n")
22:57:43 <musasabi> Usually using getContents + lines is a simple solution.
22:58:00 <thou> yeah, i was trying to learn how to do it w/o them
22:58:06 <thou> i.e., using getChar
23:00:07 * earthy hums sequence
23:00:41 <earthy> and other generalizations of the list functions
23:00:48 <earthy> e.g. zipWithM foldM etc
23:00:56 <thou> ok
23:01:01 <thou> thanks, i'll play with them
23:01:32 <thou> i think i could use parsec too, but that seems like overkill
23:01:45 <thou> and i'd have to learn parsec (that's another lesson)
23:27:36 <[TWiSTED]> can you apply map to a list of tuples?
23:27:51 <Cale> @type map
23:27:53 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
23:28:08 <Cale> replace a with (c,d) :)
23:28:28 <Lemmih> @plugs map fst [('a','b'),('c','d')]
23:28:30 <lambdabot> "ac"
23:29:34 <[TWiSTED]> so to apply (3 *) to the 2nd element of each tuple
23:30:05 <[TWiSTED]> @plugs map (3 *) [(3,5),(2,4)]
23:30:07 <lambdabot> <Plugins.Eval>:1:
23:30:07 <lambdabot>   No instance for (Num (t, t1))
23:30:07 <lambdabot>   arising from the literal `3'
23:30:27 <Cale> that tries to apply (3 *) to (3,5) and (2,4)
23:30:52 <Cale> @map (\(x,y) -> (x,3*y)) [(3,5),(2,4)]
23:30:53 <lambdabot> Maybe you meant: moo msg
23:30:57 <yain> @plugs map (\x -> (snd x) * 3) [(3,5],(2,4)]
23:30:57 <Lemmih> @plugs map (\(a,b) -> (a,3*b)) [(3,5),(2,4)]
23:30:59 <lambdabot> parse error on input `]'
23:30:59 <lambdabot> [(3,15),(2,12)]
23:31:00 <Cale> @plugs map (\(x,y) -> (x,3*y)) [(3,5),(2,4)]
23:31:01 <lambdabot> [(3,15),(2,12)]
23:31:12 <yain> eww
23:32:16 <SamB> @pl (\(x,y) -> (x,3*y))
23:32:18 <lambdabot> second (3 *)
23:32:35 <[TWiSTED]> oo
23:32:48 <Cale> @plugs let appPair (f,g) (x,y) = (f x, g y) in map (appPair (id, (3*))) [(3,5),(2,4)]
23:32:50 <lambdabot> [(3,15),(2,12)]
23:33:50 <Cale> second is defined in Control.Arrow
23:34:18 <Cale> it's being used there for the trivial case of the arrow (->)
23:34:42 <[TWiSTED]> map (\(x,y) -> (x,3*y)) [(3,5),(2,4)]    that works fine doesnt it?
23:35:23 <Cale> yes
23:35:57 <Cale> there are just some other tools around for dealing with functions and tuples
23:36:31 <[TWiSTED]> yea
23:36:33 <[TWiSTED]> cheers
23:36:47 <SamB> (->) is the only arrow I ever use
23:38:10 <SamB> my favorite function from Control.Arrow is ***
23:38:37 <[TWiSTED]> what does *** do again
23:38:50 <SamB> @type (***)
23:38:52 <lambdabot> bzzt
23:38:58 <SamB> @type (Control.Arrow.***)
23:39:00 <lambdabot> (Control.Arrow.***) :: forall (a :: * -> * -> *) c' c b' b.
23:39:00 <lambdabot>         (Control.Arrow.Arrow a) =>
23:39:00 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
23:39:15 <wilx> It would be nice if somebody did some comparison of arrows to monads. So that I can actually see what it can/does do.
23:39:25 <wilx> With examples.
23:41:03 <SamB> @type (Control.Arrow.***) :: (a -> b) -> (a' -> b') -> (a, a') -> (b, b')
23:41:05 <lambdabot> (Control.Arrow.***) :: (a -> b) -> (a' -> b') -> (a, a') -> (b, b') :
23:41:05 <lambdabot> : forall a
23:41:05 <lambdabot>                           b
23:41:05 <lambdabot>                           a'
23:41:05 <lambdabot>                           b'.
23:41:05 <lambdabot>                         (a -> b)
23:41:08 <lambdabot>                         -> (a' -> b')
23:41:09 <lambdabot>                         -> (a, a')
23:41:11 <lambdabot>                         -> (b, b')
23:42:25 <yain> what is convention about adding ' after name?
23:43:06 <SamB> it comes from mathematics, when mathemeticians run out of letters (or for other reasons) they start adding prime symbols...
23:43:17 <yain> oh.
23:43:56 <Cale> It's often to indicate that the primed variable has some relationship to the unprimed one.
23:44:31 <SamB> for instance, they might refer to an (x, y) coordinate system and an (x', y') coordinate system...
23:44:44 <yain> i see, thanks.
