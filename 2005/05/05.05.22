00:12:02 --- mode: irc.freenode.net set +n
02:22:01 --- topic: '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo"]'
02:22:01 --- topic: set by Muad_Dibber on [Wed May 18 11:34:54 2005]
02:31:06 <boegel> @seen shapr
02:33:52 <mugwump> moo
02:34:06 <mugwump> @moo
02:34:12 <xerox> moo@
02:35:07 <dons> lambdabot didn't reconneect
02:36:28 <dons> @seen shapr
02:36:29 <lambdabot> I saw shapr leaving #haskell 13 days, 17 hours, 36 minutes and 19
02:36:29 <lambdabot> seconds ago, and I have missed 11 seconds since then.
02:47:42 <boegel> almost 2 weeks without shapr
02:47:51 * boegel is in stage 4 of cold turkey
03:10:15 <det> Where is he?
03:11:24 <basti_> @docs Set
03:11:25 <lambdabot> Set not available
03:11:27 <basti_> hi all
03:11:29 <basti_> @docs Data.Set
03:11:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
03:23:24 <boegel> det: he has joined some secret society, and is not allowed too touch a computer
03:23:31 <boegel> s/too/to
03:26:45 <boegel> @type foldl
03:26:52 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
03:34:59 <basti_> hmm
03:35:07 <basti_> search.o(.rodata+0x9cc): undefined reference to `ControlziMonadziState_execState_closure'
03:35:14 <basti_> and lots of similar linker errors
03:35:17 <basti_> how does that happen?
03:46:25 <dons> you don't have the -package foo flag  you need?
03:46:31 <dons> -package mtl perhaps
03:46:38 <dons> or is this in Yi? (no, right?)
03:49:15 <basti_> hmmm
03:49:18 <basti_> no it isnt
03:49:29 <basti_> yes package mtl
03:49:32 <basti_> strange
03:51:19 <basti_> thank you dons.
03:53:47 <basti_> oh btw, Yi-Emacs is still constantly changing... but I now have a structure that will allow all requested features (repeat commands, show/manipulate bindings, visual feedback)
04:01:01 <dons> cool! darcs send once you've got something you feel is working enough.
04:22:08 <glimming> @seen esap
04:22:11 <lambdabot> I saw esap leaving #haskell 11 hours, 22 minutes and 22 seconds ago,
04:22:11 <lambdabot> and I have missed 11 seconds since then.
05:16:23 <basti_> @pl concat $ map swaps' $ concat $ map (\(a,b)->map (\(x,y)->(a,x,y)) $ zip (inits b) (tails b)) $ zip (inits a) (tails a)
05:16:26 <lambdabot> swaps' =<< join (zipWith ((. liftM2 zip inits tails) . map . (`ap`
05:16:26 <lambdabot> snd) . (. fst) . (,,)) (inits a) (tails a))
05:16:40 <basti_> uhm.
05:16:58 <jlouis> hehe
05:17:24 <jlouis> Funny to be pointless?
05:17:40 <basti_> sometimes pl makes things better
05:17:44 <basti_> sometimes it doesn't ;)
05:24:30 <itior> hey all, how can i use debug to trace to print stuff as my function is recursing without stopping the program?
05:27:22 <basti_> itior: debugging in haskell is a little tricky. If you're doing IO anyway, you might want to just print some stuff.
05:27:41 <itior> basti_: ahh nm, figured it out
05:27:42 <itior> thx though
05:28:37 <mflux_> Debug.Trace.trace?
05:37:48 <xerox> @plugs arr (id) :: Control.Arrow.Arrow (~>) => b ~> b
05:37:56 <lambdabot> parse error on input `~>'
05:37:59 <xerox> Does it work for you?
05:38:20 <basti_> mflux_: i don't know that.
05:39:03 <basti_> but, cool
07:44:49 <sylvan> hOp is cool
07:55:42 <mflux_> is there a way to negate a parser in parsec? some function that would allow something in effect of noneOf chars = negate (oneOf chars)?
07:56:39 <Philippa_> uh, you could probably hack one up by saving and restoring the input stream
07:56:48 <sylvan> hmm... maybe something like negate p = do { p ; fail} <|> char
07:56:58 <Philippa_> oh, point
07:57:01 <sylvan> or not
07:57:02 <Philippa_> you'll need a try in there
07:57:46 <mflux_> I'm simply trying to simply implement a parser fields separator = sepBy (field separator) (negate separator)
07:58:27 <mflux_> that is, split the input into fields by the given separator, propably a char ' '
07:59:27 <mflux_> maybe 'satisfy' is sufficient for me, which'll allow doing that for a single character
08:00:35 <Philippa_> manyTill anyChar separator?
08:02:14 <mflux_> to replace 'word'?
08:06:45 <mflux_> anyway, satisfy works ;)
08:30:02 <autrijus> @pointless \f -> foldl f start_elem [elems]
08:30:05 <lambdabot> flip (flip foldl start_elem) [elems]
08:31:39 <kaol> @vixen I'm bored.
08:31:48 <lambdabot> being bored isn't fun
08:53:15 <benmos> Hi, does anyone know whether it's possible to enter a multi-line definition into ghci?
08:53:45 <Lemmih> It's not.
08:54:03 <Lemmih> But you can use ; as a separator.
08:54:08 <benmos> ok, thx
08:54:42 <Lemmih> @plugs let x 0 = 10; x n = n in (x 0, x 5)
08:54:49 <lambdabot> (10,5)
08:55:31 <benmos> great, thanks - btw are there any docs on the lambdabot anywhere?
08:57:34 <Lemmih> @version
08:57:34 <lambdabot> lambdabot 2p463, GHC 6.4 (OpenBSD i386)
08:57:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:58:20 <benmos> ok, thanks - I've been needing an excuse to install darcs...
08:58:40 <mauke> @pl \x -> let l = x : l in l
08:58:41 <lambdabot> fix . (:)
09:01:19 <mauke> hmm. what is fix?
09:01:29 <Lemmih> @type fix
09:01:39 <lambdabot> bzzt
09:01:44 <Lemmih> @index fix
09:01:52 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
09:01:52 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
09:01:52 <lambdabot> Control.Monad.Error
09:02:00 <Lemmih> @type Control.Monad.Fix.fix
09:02:01 <lambdabot> Control.Monad.Fix.fix :: forall a. (a -> a) -> a
09:02:14 <mflux_> is there a way to do @index without the bot?
09:03:24 <Lemmih> @google hoogle haskell
09:03:26 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/hoogle/
09:03:33 <TheHunter>  @index' information is derived from http://haskell.org/ghc/docs/latest/html/libraries/doc-index.html
09:04:17 <mflux_> oh, well that's useful too
09:07:10 <TheHunter> @pl f (fix f)
09:07:11 <lambdabot> f (fix f)
09:17:13 <jlouis> 7
09:17:34 <jlouis> hmmm, should I try GHC6.4 compilation on NetBSD now I have a working 6.2.2?
09:17:38 <jlouis> 6.2.1 even
09:18:11 <sylvan> Go for it! :-)
09:19:45 <jlouis> ;)
09:43:20 <mflux_> hmm, if I want to interactively, with ghci, to use for example hGetStr, can I get the string into some value I can later use?
09:43:44 <mflux_> without re-evaluating hGetStr (and obviously getting a new string)
09:43:59 <TheHunter> sure, you're living in an IO monad, so you can bind stuff with str <- hGetStr h
09:45:03 <mflux_> oh, great, I hadn't realized that ;)
09:45:17 <cognominal> hi, where is @ documented?  people in #perl6 gave me some info, but I would like to read the doc
09:47:00 <TheHunter> in the report. It's called `as pattern'.
09:47:08 <Igloo> In http://www.haskell.org/onlinereport/ under patterns somewhere
09:47:14 <cognominal> thx
09:58:13 <mflux_> if instead of hGetContents I just iterate hGetStr, will the laziness still remain there?
09:58:25 <mflux_> I understand hGetContents uses some magic
09:59:12 <Lemmih> @index hGetStr
09:59:12 <lambdabot> bzzt
09:59:42 <mflux_> hGetLine even
09:59:51 <mflux_> apparently the laziness goes away in that case
10:00:32 <TheHunter> hGetContents uses unsafeInterleaveIO, so it is more lazy than what is implementable using hGet...
10:13:22 <mauke> @pl \a b -> (a == 'x') == (b == 'x')
10:13:23 <lambdabot> (. ('x' ==)) . (==) . ('x' ==)
10:23:03 <mflux_> hmm, if I just iterate with hGetLine, wouldn't the code effectively be doing safe interleaving of io of its own
10:23:28 <mflux_> and whenever it adds a new element to the list those depending on the data should retrieve it.. oh well, maybe I'll try tracing the code
10:24:47 <TheHunter> no, the result will only become available after all IO necessary to compute the result has been performed.
10:25:39 <TheHunter> in your example, that means a function readEverything::Handle -> IO String will return the string after everything is read.
10:26:27 <mflux_> yeah, but I don't care if one single line is read lazily?
10:26:33 <TheHunter> getContents is different, a pure computation is able to trigger IO (which can be used unsafely :).
10:26:42 <mflux_> only that that eventually I interleave some processing while reading the whole data
10:26:59 <TheHunter> then you can use unsafeInterleaveIO
10:27:47 <mflux_> http://www.modeemi.cs.tut.fi/~flux/software/NNTP.hs, function untilEnd
10:28:40 <mflux_> wouldn't function groups construct new Groups (with parseGroup) while reading the data?
10:28:55 <mflux_> instead of constructing a temporary list of all the data and then start processing it
10:29:14 <TheHunter> it wouldn't.
10:29:17 <mflux_> hmm
10:29:35 <TheHunter> if you want that, you should use uiIO.
10:29:39 <mflux_> hmm
10:29:41 <mflux_> 2 ;)
10:30:04 <mflux_> so the function does rest <- untilEnd socket, but apparently that cannot be avoided
10:30:16 <mflux_> (before returning anything)
10:31:37 <TheHunter> i don't understand your question
10:32:42 <mflux_> it doesn't matter, I got your insight ;)
10:33:54 <TheHunter> you can (i) use uiIO directly (ii) implement untilEnd in terms of hGetContents.
10:35:01 <mflux_> (ii) isn't an option, as I believe that would mean the connection would be closed after that
10:35:24 <mflux_> but (i) doesn't seem that bad
10:35:52 <TheHunter> there's also (iii) do the interleaving manually, which would force you to modify almost all of your code.
10:36:17 <TheHunter> gotta go.
10:36:25 <mflux_> thanks for the suggestions
11:01:23 <mflux_> @pl \g -> foo g = "bar"
11:01:24 <lambdabot> (line 1, column 13):
11:01:24 <lambdabot> unexpected "="
11:01:24 <lambdabot> expecting variable, "(", operator or end of input
11:01:30 <mflux_> @pl \g -> foo g == "bar"
11:01:31 <lambdabot> ("bar" ==) . foo
11:10:15 <mflux_> is there a way to easily see where exceptions are coming from?
11:17:26 <mflux_> @pl \r -> return $ l:r
11:17:27 <lambdabot> return . (l :)
11:28:04 <wagle> wow..  does it get better, or is @pl == @obfuscate for everyone else
11:28:42 <wagle> really cool mind twisters, but ...
11:28:51 <Cale> @pl can sometimes make things simpler
11:28:53 <lambdabot> can sometimes make things simpler
11:28:55 <Cale> heh
11:29:07 <Cale> see? lambdabot agrees :)
11:29:13 <wagle> s/@pl// is simpler
11:29:24 <wagle> so he disagrees too
11:29:45 <Igloo> He must be a very confused bot
11:29:46 <wagle> 8)
11:29:51 <Cale> return . (l :) isn't too bad
11:30:14 <Cale> it's just a slightly different way of looking at the same thing
11:30:23 <wagle> @pl swing
11:30:24 <lambdabot> swing
11:30:58 <Cale> @pl \f -> flip (f . flip ($))
11:30:59 <lambdabot> flip . (. flip id)
11:31:35 <Gahhh> how many characters on average do you save by going pointfree ? I dont think it's worth it.
11:31:49 <Cale> It's not really about saving characters
11:32:10 <Cale> Sometimes the point-free version gives you another way to look at the same code
11:32:11 <wagle> @pl (\f x y -> f (\z -> y z) x)
11:32:12 <lambdabot> flip
11:32:44 <wagle> @pl (\f x y -> f (\z -> z y) x)
11:32:45 <lambdabot> flip . (. flip id)
11:33:15 <basti_> "flipdot"
11:33:18 <wagle> @pl (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id))
11:33:19 <lambdabot> flip flip (flip . (. flip id))
11:33:28 <wagle> @pl (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id))
11:33:29 <lambdabot> flip flip (flip . (. flip id))
11:33:45 <Cale> @pl \x -> 1 + x + x^2 + x^3
11:33:47 <lambdabot> liftM2 (+) (liftM2 (+) (1 +) (^ 2)) (^ 3)
11:33:53 <wagle> @pl (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id)) (flip . (. flip id))
11:33:55 <lambdabot> flip flip (flip . (. flip id)) . (. flip id)
11:33:58 <autrijus> point free code is more composable and decomposable.
11:34:06 <autrijus> but that is not always a good thing ;)
11:34:59 <wagle> notice that 5 swings is eq to 7
11:35:10 <Cale> @pl \x -> (1 + x + x^2 + x^3) * (1 + 2 * x + x^2)
11:35:11 <lambdabot> liftM2 (*) (liftM2 (+) (liftM2 (+) (1 +) (^ 2)) (^ 3)) (liftM2 (+) ((
11:35:11 <lambdabot> 1 +) . (2 *)) (^ 2))
11:35:39 <Gahhh> heh
11:35:41 <autrijus> @pl lambdabot
11:35:41 <lambdabot> lambdabot
11:36:38 <autrijus> @pl lamb (da bot)
11:36:39 <lambdabot> lamb (da bot)
11:37:28 <wagle> @pl i'm da bot!
11:37:29 <lambdabot> (line 1, column 12):
11:37:29 <lambdabot> unexpected end of input
11:37:29 <lambdabot> expecting white space or simple term
11:37:34 <wagle> @pl i'm da bot
11:37:35 <lambdabot> i'm da bot
11:37:42 <mauke> huhu, this is like perl
11:38:03 <mauke> perl -ce "I'm da bot"
11:39:17 <wagle> $ perl -ce "I'm da bot"
11:39:17 <wagle> -e syntax OK
11:40:10 <mauke> it does something entirely different, of course :-)
11:41:45 <aFlag> it's just like foldl (flip (:)) [], but it does a completely different thing, of course
11:42:45 <mauke> perl is like haskell in that any sequence of whitespace-separated words (where words may contain ') is syntactically valid
11:43:07 <Paltas> I've a: type Sometype = (Int, Int) can i use the ordering class on it?
11:43:14 <Muad_Dibber> but not semantically
11:43:22 <autrijus> mauke: not really
11:43:28 <autrijus> "if if if" is invalid in b oth haskell and perl
11:43:33 <mauke> ah, right
11:43:48 <mauke> non-keyword words then
11:43:50 <Cale> Paltas: if it's just a "type" and not a "newtype" then you can't, since (Int, Int) already has an instance of Ord.
11:44:04 <Paltas> ah okey
11:44:24 <Cale> Is emacs really the best terminal emulator for windows?
11:44:36 <wagle> i think there is an instance (Ord a, Ord b) => Ord (a, b)
11:44:53 <Cale> It's strange being on a windows machine and not having basic stuff which you take for granted
11:45:03 <jlouis> only teh dictionary order makes sense on that one
11:45:04 <wagle> Cale: yes and no
11:45:12 <tuomov> Hmm.. I wonder how much work would be involved in making a terminal emulator based on putty
11:45:18 <tuomov> +plain
11:45:34 <jaap> cale: probably. it's a damn good terminal emulator and/or driver in general. we once had a TVI-920, and the only thing that really talked to it correctly was emacs, i believe
11:46:01 <Igloo> autrijus: It can be a valid fragment, though
11:46:03 <Muad_Dibber> auch
11:46:23 <Igloo> if if if True then True else True then True else True then 'x' else 'y'
11:46:24 <Igloo> 'x'
11:46:32 <Muad_Dibber> i was trying to install lambdabot, but it tells me "Rebuilding dependencies ... ghc-6.2.2: unknown package name: plugins"
11:46:40 <wagle> depending on what you want, i'm sure there's a better terminal emulator than emacs on windows
11:47:08 <Gahhh> Cale: tried rxvt ?
11:47:09 <wagle> cygwin doesnt have one?
11:47:25 <Cale> Oh, perhaps cygwin would be nice.
11:47:39 <wagle> could get x11 running on windows, then use xterm..  8)  8/
11:47:50 <Cale> Ah well, I'm not really going to be here that long :)
11:47:54 <jaap> cygwin has a fairly decent one that's actually for windows, and indeed xterm
11:47:57 <Gahhh> if you are ssh'ing, then you can just use Putty.
11:48:15 <Cale> yeah, I found putty and pscp quite a while ago
11:48:31 <wagle> the windows terminal emulator hasnt been horrible
11:48:42 <wagle> not that i've pushed it that hard
11:48:50 <Cale> I feel cut off from the world on a windows machine with the default configuration.
11:49:17 <wagle> its your chance to experience something differenty
11:49:22 <wagle> its your chance to experience something different
11:49:41 <SyntaxNinja> wagle: that's why we have live Linux CDs :)
11:50:12 <Cale> the default windows terminal emulator here is terrible - it is a win98 machine though. I seem to remember NT4 even having something with a scrollback buffer at least
11:50:19 <Gahhh> heh
11:50:26 <wagle> ooohhhh
11:50:32 <Lemmih> Muad_Dibber: You need hs-plugins for lambdabot.
11:53:33 <tuomov> I don't even try to do anything else but launch putty on a windows box and then forget about it being a windows box and consider it a text terminal
11:53:41 <wagle> there's lots of ways to beef up the programmer experience on a windows machine..  (i was pleasantly surprised at the quality of debuggers etc when trying to figure out what was going on with some freezes associated with an ATI gfx card) its just not that friendly out of the box..
11:54:06 <tuomov> even cygwin has problems with windows stealing keys
11:54:28 <tuomov> it supposedly has some stealing switch itself too, but the last time I tried, it didn't work
11:54:44 <tuomov> no way to use alt-tab in the X wm or even switch to some windows modifier
11:55:29 <Gahhh> you can use the new window manager for cygwin where individual X apps get their own windows. Then you can alt-tab.
11:55:34 <Muad_Dibber> Lemmih , but now it gives me: "Rebuilding dependencies ... Boot.hs: can't locate import `System.Plugins.Load'"
11:55:48 <tuomov> if cygwin could completely steal the console in full screen mode, one could almost forget being on windows
11:55:58 <Lemmih> Muad_Dibber: Have you installed hs-plugins?
11:56:26 <Muad_Dibber> yup
11:56:43 <Gahhh> tuomov: I use litestep and cygwin. People who see my desktop get mightilt confused.
11:56:53 <Lemmih> Muad_Dibber: Did you register it?
11:57:08 <Muad_Dibber> Lemmih : assuming it was not done automatically with gentoo, how should i register it?
11:58:02 <Lemmih> Muad_Dibber: Does 'ghc-pkg list' list plugins?
11:58:33 <Muad_Dibber> yup
11:59:13 <Lemmih> Then it's probably too old. Download a recent cvs snapshot.
12:00:04 <Muad_Dibber> 0.9.8 is the one i installed :P
12:00:52 <Muad_Dibber> but i'll try from the darcs repo
12:08:49 <chucky> has anyone ever experienced problems when running ghc --make on large projects?
12:09:40 <Lemmih> Performance problems?
12:10:57 <chucky> no, crashing
12:11:09 <chucky> the impossible happened, maybe.fromJust Nothing
12:11:20 <mflux_> @ghc
12:11:21 <lambdabot>  Urk infer
12:12:48 <basti_> Urk infer?
12:12:54 <Lemmih> Is the behaviour reproducible?
12:13:58 <chucky> Lemmih: I think so. I'm gonna look into it later
12:14:07 <chucky> when I don't have to hand in this lab. :)
12:15:14 <chucky> it certainly reproduces itself a lot on my box
12:29:50 <Gahhh> @ghc
12:29:51 <lambdabot>  CPR Analysis tried to take the lub of a function and a tuple
12:29:55 <Gahhh> lol
12:30:05 <xerox> @moo
12:30:06 <lambdabot>          (__)
12:30:06 <lambdabot>          (oo)
12:30:06 <lambdabot>   /-------\/
12:30:06 <lambdabot>  / |     ||
12:30:06 <lambdabot> *  ||----||
12:30:06 <lambdabot>    ~~    ~~
12:30:08 <lambdabot>      Cow
12:30:24 <SyntaxNinja> hm. how do I learn about the provider given an ip address?
12:30:31 <Gahhh> reverse dns lookup ?
12:30:36 <SyntaxNinja> no dice
12:30:47 <Gahhh> tracert ?
12:31:11 <SyntaxNinja> I'd like them to not see my connection
12:31:29 <Gahhh> There's got to be some blackhat hacker irc channels where people should be able to tell you the credit number of the address' owner ;)
12:31:41 <SyntaxNinja> I'm curious about a port scan someone did against me
12:31:44 <Gahhh> ah
12:32:04 <Gahhh> I can do the tracert for you if you want
12:34:18 <integral> whois?
12:42:26 <jlouis> SyntaxNinja: whois, dig
12:42:57 <jlouis> SyntaxNinja: did they decoy scan?
12:42:57 <SyntaxNinja> yeah, whois is what I was after.  thanks
12:43:03 <SyntaxNinja> what's decoy scan?
12:43:38 <FrederikEaton> what's the name of that one alternative prelude?
12:43:46 <jlouis> you port scan with a lot of packets against the same port, most source ips fake but one real.
12:44:14 <jlouis> SyntaxNinja: is impossible to figure out the real IP unless you have a lot of resources
12:44:24 <SyntaxNinja> no, all the same source IP
12:44:30 <jlouis> script kiddiots then
12:45:01 <SyntaxNinja> and all > 35000 ports, no interesting ports like telnet. what's up w/ that?
12:45:18 <jlouis> trojans
12:46:06 <FrederikEaton> once i scanned my college DSL subnet to get a breakdown of OS use. and then they blocked my MAC address and called me in the morning
12:46:12 <SyntaxNinja> they're looking for an already infected machine?
12:46:19 <jlouis> SyntaxNinja: sure is
12:46:40 <SyntaxNinja> FrederikEaton: yeah, port scanning is shady ;)
12:46:55 <FrederikEaton> i should have used decoy scans
12:46:57 <nmoore> can anyone tell me if this is to be expected?:
12:47:01 <jlouis> You send them an email with some funny flash, dump trojan zombie on them. Then you scan the range for trojans
12:47:07 <nmoore> List> groupBy (\x y -> x<y) [1,2,3,1,0]
12:47:07 <nmoore> [[1,2,3],[1],[0]]
12:47:12 <nmoore> but
12:47:17 <nmoore> List> groupBy (\x y -> x<y) [1,2,3,1,2,3,2]
12:47:17 <nmoore> [[1,2,3],[1,2,3,2]]
12:47:17 <FrederikEaton> anyway i was like "oh, i was just about to change my mac address"
12:47:22 <jlouis> FrederikEaton: when the administrator has control over the switches, you have lost
12:47:29 <jlouis> MAC locks
12:47:31 <SyntaxNinja> hi wli
12:47:48 <xerox> @type groupBy
12:47:54 <lambdabot> bzzt
12:47:55 <xerox> @type List.groupBy
12:47:56 <lambdabot> List.groupBy :: forall a. (a -> a -> Bool) -> [a] -> [[a]]
12:48:28 <nmoore> the question is, shouldn't the answer to the second expression be
12:48:34 <mauke> @plugs List.groupBy (\x y -> x<y) [1,2,3,1,2,3,2]
12:48:38 <nmoore> [[1,2,3],[1,2,3],[2]]
12:48:40 <lambdabot> [[1,2,3],[1,2,3,2]]
12:48:44 <jlouis> FrederikEaton: the trick is to lock on a WiFi LAN of some poor soul and scan from there, with a fake MAC of course ;)
12:48:47 <FrederikEaton> nmoore: 1<2
12:49:31 <nmoore> i think i misunderstand the exact purpose of the function, i thought it applied the function to consecutive pairs
12:49:38 <jlouis> FrederikEaton: also, proper egress/ingress filtering kills decoy scans
12:50:17 <nmoore> is there a function that does the job i'm thinking of? these expressions should return all the ascending sequences
12:53:49 <nmoore> thanks
12:54:02 <FrederikEaton> nmoore: i would just do it by hand
12:54:04 <FrederikEaton> uh
12:54:15 <FrederikEaton> oh well
12:54:38 <kaol> how to turn a string to integer? (An easy one to find from the documentation surely, but apparently I'm blind.)
12:55:14 <mauke> how would you split "12.3.456.7" into ["12", "3", "456", "7"]?
12:56:53 <FrederikEaton> kaol: 'read'
12:57:07 <FrederikEaton> kaol: you're not blind :)
12:57:13 <kaol> ERROR - Unresolved overloading
12:57:22 <FrederikEaton> read (1::Int)
12:57:23 <othernoob> would someone mind helping me to figure out these 3 programs: http://pastebin.com/288074 ?
12:57:27 <jlouis> read (a::Int)
12:57:31 <jlouis> grr
12:57:45 <musasabi> kaol: read "123" :: Int
12:57:59 <FrederikEaton> oh oops
12:58:01 <FrederikEaton> heehee
12:58:08 <Cale> mauke: http://www.haskell.org/hawiki/LicensedPreludeExts -- split
12:59:17 <Cale> othernoob: sure
12:59:28 <Cale> othernoob: what are you having trouble with?
12:59:33 <othernoob> Cale: thanks
12:59:46 <othernoob> Cale: with prog 1 i dont know what "f" does ?
12:59:55 <othernoob> or what it is
13:00:04 <Cale> othernoob: well, do you know what zipWith does?
13:00:31 <kaol> hmm. and how would I gracefully handle strings that do not map into integers?
13:00:31 <othernoob> Cale:i think it adds two lists together
13:01:01 <kaol> "Program error: Prelude.read: no parse" seems a bit harsh
13:01:03 <Cale> othernoob: nope :)
13:01:13 <Cale> well, that's not all it can be used for
13:01:43 <jlouis> othernoob: zip does that. zipWith is another beast ;)
13:02:02 <Cale> zip doesn't do that :)
13:02:17 <Cale> @plugs zip [1,2,3,4,5] [6,7,8,9,10]
13:02:20 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
13:02:27 <Cale> @plugs zipWith (*) [1,2,3,4,5] [6,7,8,9,10]
13:02:29 <lambdabot> [6,14,24,36,50]
13:03:09 <Cale> @plugs zipWith (\x y -> (x-1) `div` y == 0) [1,2,3,4,5] [6,7,8,9,10]
13:03:11 <lambdabot> [True,True,True,True,True]
13:03:29 <xerox> yay
13:03:29 <Cale> @plugs zipWith (\x y -> (x-1) `mod` y == 0) [1,2,3,4,5] [6,7,8,9,10]
13:03:31 <lambdabot> [True,False,False,False,False]
13:03:50 <Cale> or any other function :)
13:04:27 <othernoob> okay, so "f" is a variable for a function which isn't defined ?
13:04:28 <Cale> basically, it takes a function of two parameters and two lists, and applies the function to pairs of corresponding elements from the lists
13:04:29 <kaol> running "all isDigit" on the string prior to "read" seems suspicious to me
13:04:33 <jlouis> Cale: for the correct definition of ``add'' it does, hehe ;)
13:04:42 <Cale> jlouis: I suppose :)
13:05:11 <mauke> Cale: nice, and it's only semibroken :-)
13:05:34 <mauke> > split "x" "axbx"
13:05:35 <mauke> ["a","b"]
13:06:56 <othernoob> Cale: so zipwith f xs (x:xs) --> [f x1 x2, f x2 x3.. ] ?
13:07:25 <Cale> othernoob: f x2 x1,... actually
13:07:35 <Cale> but yeah, basically
13:07:47 <jlouis> kaol: that is one way to go
13:07:51 <Cale> try differenzen xs (-)
13:08:00 <Cale> for some appropriate xs :)
13:08:31 <mauke> @pl (\x -> concatMap (\s -> case s of y : ys | x == y -> replicate (length ys) []; _ -> [s]) . List.groupBy (\a b -> (a == x) == (b == x)) . (++ [x]))
13:08:32 <lambdabot> (line 1, column 51):
13:08:32 <lambdabot> unexpected ">"
13:08:32 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">",
13:08:32 <lambdabot> "`elem`", "`notElem`" or ")"
13:08:41 <othernoob> Cale: ok i think i understood this now
13:09:42 <othernoob> Cale: prog 2. what does !!
13:10:42 <mauke> lambdabot: wtf? unexpected ">", expecting ... ">" ...?
13:11:48 <musasabi> kaol: reads
13:11:51 <musasabi> @type reads
13:11:57 <Muad_Dibber> mauke : x == y -> replicate?
13:11:58 <lambdabot> reads :: forall a. (Read a) => ReadS a
13:12:15 <mauke> Muad_Dibber: case s of ... -> replicate ...
13:12:46 <musasabi> case reads "100" of [x] -> x \n _ -> defaultCode
13:13:23 <jlouis> hmmm
13:14:21 <mauke> @pl (\x -> concatMap (\s -> case s of { y : ys | x == y -> replicate (length ys) []; _ -> [s] }) . List.groupBy (\a b -> (a == x) == (b == x)) . (++ [x]))
13:14:22 <lambdabot> (line 1, column 35):
13:14:22 <lambdabot> unexpected "{"
13:14:22 <lambdabot> expecting variable, "(", operator or ")"
13:14:39 <mauke> ok, just a guess
13:16:33 <Muad_Dibber> mauke : well, i was just wondering what this part meant: y : ys | x == y
13:17:22 <jlouis> mauke: what is that supposed to do anyway?
13:17:35 <mauke> jlouis: it should do a single element split
13:17:48 <mauke> Muad_Dibber: a pattern with a guard
13:18:28 <Muad_Dibber> i might be wrong, but for me hugs mostly complains when i do a pattern like y : ys without parenthesis (y:ys)
13:18:41 <jlouis> mauke: can you tell me the output of "123.123.123.123" then?
13:18:55 <Muad_Dibber> secondly, i'm not sure whether its valid to do a pattern and a guard both at the same place at that spot?
13:19:43 <mauke> No instance for (Show ([[Char]] -> [[[Char]]])) arising from use of `print' at <interactive>:1
13:20:12 <mauke> split '.' "123.123.123.123" ==> ["123","123","123","123"]
13:20:21 <jlouis> mauke: I am more concerned about what you want to do
13:21:43 <mauke> I wanted to split a sequence into subsequences separated by a single element
13:22:07 <mauke> I found a solution, which I wanted to see in points-free style
13:23:15 <jlouis> mauke: I think you can boil that down to something far more readable
13:24:26 <jlouis> something with break and unfoldr maybe
13:28:51 <kaol> musasabi: thanks, that was what I was looking for
13:33:26 <mauke> hmm, yes
13:40:40 <mauke> @pl \l -> let (a, b) = break (x ==) l in Just (a, rest b)
13:40:41 <lambdabot> (line 1, column 11):
13:40:41 <lambdabot> unexpected "("
13:40:41 <lambdabot> expecting natural, identifier or "in"
13:44:07 <mauke> jlouis: http://rafb.net/paste/results/cnZvMi15.html seems to work
13:44:44 <Cale> ah, a noble spirit embiggens the smallest man
13:45:27 <jlouis> mauke: yes, something along those lines
14:08:42 <hellish> dons: got a minute to help me? I can't get hs-plugins from darcs to build.
14:10:13 <musasabi> hellish: do you have hsx?
14:11:16 <musasabi> hellish: darcs hs-plugins started to depend on that sometime ago (the README mentions it). I know because I had to ask dons why it didn't work ;)
14:11:32 * hellish re-reads that.
14:12:13 <hellish> ./configure should really check for that.
14:15:27 <boegel> @seen shapr
14:15:28 <lambdabot> I saw shapr leaving #haskell 14 days, 5 hours, 15 minutes and 18
14:15:28 <lambdabot> seconds ago, and I have missed 11 seconds since then.
14:15:36 <boegel> unbelievable
14:16:02 <Cale> he broke his arms, didn't he?
14:16:09 <boegel> he did ?
14:16:13 <boegel> :)
14:16:15 <Cale> that's what I heard
14:16:21 <boegel> you're kidding right ?
14:16:22 <Cale> unicycle accident
14:16:30 <boegel> Philippa_: is this true ?
14:16:31 <Cale> maybe someone was kidding
14:16:36 <boegel> I hope so :s
14:16:49 <boegel> I think you have to have really bad luck to break both your arms
14:18:38 <boegel> I made someone believe he joined a secret society and isn't allowed to touch computers :)
14:18:55 <boegel> it's time he comes back :)
14:19:28 <jlouis> Maybe he won't come back before he can juggle 3 clubs
14:21:46 <boegel> jlouis: with broken arms ? :p
14:22:11 <jlouis> boegel: okay, I've seen balls done with the feet
14:24:05 * boegel doesn't even try to imagine touching his balls with his feet
14:24:22 <wilx> ...
14:24:23 <wilx> :)
14:25:07 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine"]' by SyntaxNinja
14:27:43 <musasabi> At least yesterday he posted one email.
14:27:48 <boegel> SyntaxNinja: :)
14:29:03 <boegel> so he can still type.. I guess that rules out your story Cale :)
14:32:50 <boegel> has anyone seen the movie "The Thirteenth Floor" (1999)
14:33:47 * esap remembers something like that, or maybe it was the B5 episode that had the missing floor? :-)
14:35:26 <aFlag> boegel, i've seen it
14:35:27 <boegel> I just heard about it, and it sounds kinda cool
14:35:34 <boegel> aFlag: is it any good ?
14:35:38 <aFlag> i liked it
14:35:48 <boegel> did you like The Matrix ?
14:36:10 <aFlag> yes, the first one was alright, the other ones were a bit worse
14:36:26 <boegel> true
14:36:29 <aFlag> the thirteenth floor makes more sense than matrix
14:36:34 <esap> The last Matrix movie was clearly the best one. Because of the amount of abstract algebra it had.
14:36:35 <boegel> oh ok
14:36:47 <boegel> it had abstract algebra ?
14:36:47 <aFlag> matrix story is not really nice
14:36:53 * boegel must have must that part
14:37:03 <boegel> s/must/missed
14:37:27 <aFlag> i mean, the humans had much more to lose without the sun than the machines
14:37:46 <aFlag> and humans are not a good energy source for all i know
14:37:57 <esap> that was not essential to the story.
14:37:58 <boegel> it's still fiction you know :)
14:38:12 <boegel> I liked the idea though
14:38:23 <aFlag> yeah, but it looks like they didn't even try to make it good :P
14:38:29 <boegel> when you saw the first movie, you couldn't help pondering about it before you went to bed
14:38:40 <aFlag> the idea of it is in the thirteenth floor and the story makes more sense
14:39:32 <boegel> ok
14:39:41 <boegel> I'll see if I can find it on the web
14:40:03 <aFlag> the idea of it is even in that jim carrey movie, trueman show, something like that
14:40:17 <esap> The Matrix had great structure.
14:40:27 <Cale> hey, he's back!
14:40:33 <shapr> The rumors of my death have been greatly exaggerated!
14:40:37 <Cale> hehe
14:41:04 <shapr> FLM isn't quite ready to use yet...
14:41:08 <aFlag> i thought by matrix 2 or 3 they would come up with a better explanation why humans were used as power source by the machines
14:41:31 <musasabi> Welcome back shapr :-)
14:41:35 <shapr> hei musasabi
14:41:49 <shapr> musasabi: I've been following the shootout list with much amusement.
14:42:03 <esap> aFlag: They didn't even try, and I think for a good reason. Having bad explanations for bugs will not make the movie work.
14:42:17 <boegel> shapr !
14:42:18 <boegel> w00 !
14:42:24 <shapr> esap: hei! You think your article will be ready for the next TMR?
14:42:29 <musasabi> shapr: yep, lots of pseudo-trolling there.
14:42:53 <shapr> Your response to Skaller about concurrency caused much laughter for me.
14:43:17 <aFlag> what's pseudo-trolling?
14:43:29 <boegel> shapr: latest rumors: you joined asecret society and wasn't allow to touch computers, you broke both arms whilst unicycling
14:43:31 <esap> shapr: I still haven't had any time to do it. I got involved in another project to write a paper :-( I need to try to find some way to finish both of those.
14:43:44 <shapr> It seems like almost everyone has deep assumptions on the shootout list, it makes me wonder what unrealized assumptions I might have.
14:43:55 <boegel> aFlag: the trailer of the 13th floor looks nice
14:44:05 <shapr> boegel: oh that's a good rumor :-)
14:44:26 <aFlag> yeah, it's a good movie, and i live in the 13th floor, so i found that amusing :)
14:44:28 <boegel> which one :)
14:44:59 <musasabi> I think the largest problem with shootout is that the new problems are specsed to be quite complex - so they end up having very different bottlenecks in different languages.
14:45:13 <shapr> boegel: both of them!
14:45:39 <esap> shootout?
14:45:55 <shapr> I still like my idea best, "unit test what you can and treat the rest as literature".
14:46:06 <musasabi> esap: shootout.alioth.debian.org - microbenchmarking till death.
14:46:09 <shapr> haha
14:46:14 <shapr> That's an excellent motto.
14:46:38 <shapr> The scary part is that most of the vocal people on the list want microbenchmarks that put their religion in a positive light.
14:46:39 * boegel leaves to watch 24
14:46:50 <boegel> shapr: don't leave again for 2 weeks, we missed you :)
14:47:01 <shapr> I did get a lot of code written.
14:47:08 <shapr> Sadly it was mostly work code, but I got stuff done!
14:47:33 <xerox> yay! A shapr!
14:47:45 <boegel> and you made us worry :)
14:47:55 <musasabi> Any interesting tidbits?
14:48:18 * xerox hugs shapr - wlcome back
14:48:21 <xerox> +e
14:48:25 * shapr hugs xerox 
14:48:29 <shapr> nice to be back :-)
14:48:40 <shapr> musasabi: not really... Lots of fun to hack on FLM though.
14:49:24 <shapr> As for FLM, the broad brush strokes are present, but the picky details are missing.
14:49:30 <xerox> For one joining, another one leaves.  Goodnight ;)
14:49:41 <musasabi> night.
14:49:59 <shapr> xerox: sleeping so soon?
14:49:59 * musasabi waits eagerly to get his hands on FLM
14:50:09 <musasabi> I should really find the time to write an optimizer for parrows so I could publish that too.
14:50:21 <shapr> You have a parrowsec?
14:50:38 <musasabi> yep :-)
14:50:44 <shapr> ooh
14:50:47 <shapr> have you benchmarked it?
14:51:11 <shapr> oh I see!
14:51:13 <musasabi> Currently it runs a little bit slower than parsec (~10% for most benchmarks) with absolutely no optimization.
14:51:33 <shapr> impressive.
14:51:53 <musasabi> But it could have an optimizer pass, which should make it faster.
14:52:36 <musasabi> My main motivation was to make it possible to generate a parser in haskell and then emit it as javascript (but that is still an open idea)
14:52:40 <shapr> I've thought of a bunch of interesting parrows optimizations, not sure if they'll all work though.
14:52:48 <shapr> Oh that's a neat idea!
14:53:00 <shapr> That would mean Links would have no real advantages.
14:53:12 <musasabi> One problem is that the arrow syntax is clunkier than the parsec one - might be that it is not as familiar.
14:53:37 <shapr> On the speed end, GHC is optimized for monads, not arrows.
14:55:21 <shapr> peti benchmarked the exact same pipes implementation written as arrows and monads, and the monadic implementation was the fastest.
14:56:05 <shapr> I'm relatively sure Parrows can guarantee fewer function calls and less memory leaked per parse.
14:57:58 <musasabi> Well the arrow creates a simple pure data-structure describing the parser (and dataflow).
14:58:10 <musasabi> Then the matcher function just runs over that.
14:58:27 <tic> Oh, hi Shapr!  Done working?
14:58:49 <shapr> tic: not really, but I'm taking a break here because the rumors were getting too wild.
14:58:55 <tic> shapr :)
14:58:57 <musasabi> Now one can transform that structure to more optimized forms or just emit a visual description.
15:00:41 <blackdog> shapr! I heard you were on a CIA black ops mission, and they broke all but 3 bones in your body trying to get you to say "PHP is better than Haskell"! What up, man?
15:00:47 <musasabi> I think I should write first a alex/happy generator from a parrows parser - but there are still some remaining problems that need solving first like cycles.
15:00:48 * shapr laughs
15:01:17 <shapr> blackdog: I'm just chilling, distracting myself from some Plone work I gotta do.
15:01:20 <shapr> blackdog: wassup with you?
15:01:27 * blackdog is working in PHP at the moment and not enjoying it all that much.
15:01:37 <shapr> @yow !
15:01:38 <lambdabot> It's OBVIOUS ... The FURS never reached ISTANBUL ... You were an
15:01:38 <lambdabot> EXTRA
15:01:38 <lambdabot> in the REMAKE of "TOPKAPI" ... Go home to your WIFE ... She's
15:01:38 <lambdabot> making
15:01:38 <lambdabot> FRENCH TOAST!
15:01:55 <blackdog> the other end is rubyonrails, which is actually kind of fun, although the implicitness of everything scares the hell out of me.
15:02:14 <shapr> I want to learn rubyonrails, see if I can steal anything for the Haskell world.
15:02:15 <tic> PHP is teh suck.
15:03:46 <blackdog> I'm probably not far along with it to make a good judgment yet, but the scaffolding thing is really nice - lowers the barrier of entry to getting a working program to 10 minutes or so. That really helps with that whole incremental never-more-than-one-step-away-from-working thing you XP guys get all excited about. :P
15:04:10 <shapr> heh, us XP guys?
15:04:22 <shapr> btw, I'm pissed off at microsoft for stealing all the cool worsd..
15:04:30 <shapr> Windows XP, the Monad shell, wtf is going on?
15:04:53 <wagle> @seq shapr
15:04:54 <lambdabot> shapr is in #haskell. Last spoke 24 seconds ago.
15:05:03 <blackdog> access, excel, word for Wadler's sake... if anyone else tried it, they'd be ungooglable...
15:05:04 <wagle> whoa
15:05:07 <shapr> wagle: shocking!
15:05:19 <Lunar^_> hellish: !
15:05:26 <Lunar^_> oops
15:05:27 <Lunar^_> shapr: !
15:05:30 <shapr> salut Lunar^_ !
15:05:36 <wagle> so after all the rumors, whats The True Story?
15:06:17 <wagle> (you know, like the movies telling The True Story)
15:06:17 <shapr> Um, just like I said in my blog, I want to produce code, not just organize other people into producing code.
15:06:39 <Lunar^_> shapr: Any progress thenL??
15:06:54 <shapr> Lunar^_: yes, but it's not ready for release yet.
15:07:11 <Lunar^_> cool
15:07:40 <wagle> whatisit?
15:07:44 <shapr> Just a few more hours work and I'll release the minimal 0.1 version, and then update to the latest Flippi
15:08:09 <Lunar^_> yeah!
15:08:10 <shapr> wagle: Fermat's Last Margin, A distributed decentralized wiki-based darcs-backed research paper annotation tool.
15:08:32 <wagle> Final Comargin
15:08:34 <KrispyKringle> wha?
15:09:10 <wagle> hmm..  sounds possibly related to something i want/need
15:09:30 <KrispyKringle> sounds like something i'd use just because it has so many neat words in the title.
15:09:35 <KrispyKringle> screw functionality.
15:09:39 <shapr> We are buzzword compliant.
15:09:55 <KrispyKringle> heh
15:10:09 <shapr> I still dunno if it'll really work in practice. The code will work, I'm sure. As for the social pattern, anything could happen.
15:10:11 <KrispyKringle> i keep meeting people and asking them what they do, and they tell me some project with a code name i've never heard of.
15:10:14 <KrispyKringle> it's weird and scary.
15:10:24 <blackdog> prety restricted set of buzzwords. if your boss starts nodding eagerly at those, I envy you.
15:10:27 <KrispyKringle> shapr: so the idea is that annotations are kept as patchs on the original?
15:10:29 <Lunar^_> shapr: darcs was never meant to be something that big, you know :)
15:10:55 <wagle> A distributed decentralized wiki-based darc-backed fully-buzzword compliant research paper annotation tool.
15:11:06 <KrispyKringle> shapr: i just discovered that MS Word does something sort of relevant. You can annotate other people's documents with changes, and send it back, and the author can then choose to accept or reject changes. It's very version-controlly.
15:11:09 <shapr> Lunar^_: Yes, I know. I can only hope that Igloo will keep tuning darcs, or that a feature to import history from --partial will be added.
15:11:15 <shapr> I may have to add it myself, but that would be fun.
15:11:16 <blackdog> shapr: open access for everyone, or controlled users?
15:11:41 <shapr> blackdog: Neither and both, it's all read-only darcs repos, you can pull from whoever you want.
15:12:02 <blackdog> ahhh. clever
15:12:22 <blackdog> like subscribing to the rss feeds you want rather than reading a newsgroup
15:12:47 <shapr> Yup, but in this case the rss feeds are content, and you can directly reply in your own repo.
15:13:22 <blackdog> so you might see a conversation where you only know one of the participants, then decide to check out the other?
15:14:05 <musasabi> I sense an small addition to darcs for having multiple repos to pull from (or just do 'for f in `cat repos`; do darcs pull $f; done')
15:14:43 <shapr> blackdog: I think you'd end up pulling all the patches for a conversation because they'd depend on each other.
15:15:00 <musasabi> Another trend might be that groups use central servers with authenticated users pushing their comments and having them world-readable.
15:15:15 <blackdog> so if a viagra manufacturer adds a comment about monads, I'd pull in his whole repo? :(
15:15:58 <shapr> blackdog: likely you wouldn't know any viagra manufacturers directly, but if you got viagra spam from someone you knew, you could just unpull that and remove them from the list of people you pull from.
15:16:07 <wagle> repo spammers.. o_O
15:16:19 <musasabi> blackdog: it is quite easy to create patches that cancel the effects of a single patch.
15:16:33 <wagle> sort of like adding keywords to confuse google
15:16:34 <musasabi> that might be cleaner if you still want to pull from the same source.
15:17:03 <shapr> #haskell doesn't have much spam, I think that's partially because we all know each other.
15:17:13 <shapr> So I hope the same pattern can work here
15:17:18 <blackdog> shapr: ok, so basically you're trusting the people on your list not to reply to fake posts either... that sounds reasonable.
15:19:06 <musasabi> blackdog: I think it is more like trusting people subscribed to haskell mailing lists not sending you spam.
15:20:00 <blackdog> musasabi: that's the first level, but you know how occasionally, somebody gets cranky with some spammer everyone else has killfiled and blasts him in an open channel? For most people, the blast is the first they see of it.
15:20:14 <shapr> The way I see it: When I download a new research paper, I check to see if anyone else already has a repo about that paper. If so, I pull their repo. If not, I create my own.
15:20:59 <shapr> Let's say Cale already read SPJ's subcontinuations paper and he's made notes on the various pages. So I pull his repo and add my own notes.
15:21:35 <blackdog> does Cale then get notified?
15:21:57 <shapr> I don't know, that's the only design bug I'm really not sure about.
15:22:27 <shapr> if SPJ has his own repo, he probably doesn't want to get notified each time there's a pull, it could be a large number of pulls.
15:23:04 <musasabi> Cale will note if he pulls from shapr's repo, and shapr can darcs send?
15:23:49 <blackdog> i hope Cale wasn't upset to be used as an Alice,Bob,Charlie figure. :)
15:23:52 <shapr> But, assuming that Cale has someway to find my own repo, he'd probably do a pull just to look at the patches and see if there's any interesting discussion.
15:24:34 <shapr> Actually, darcs send is a simple approach to find new connections.
15:25:13 <musasabi> darcs seems to be suitable for a vast amount of models - so trying things out might be the best way.
15:25:20 <shapr> Yeah, I think so.
15:25:58 <shapr> I had a bunch of different ideas, like keeping the comments of each person in a separate place so you could turn them on and off at will, but I think the best approach is to just throw it out there and see if it sinks or swims.
15:26:25 <KrispyKringle> shapr: how do you track the aavailable repos?
15:26:29 <shapr> It might sink like a rock and then I'll have a good reason to refine the design. I dunno what will happen.
15:26:37 <KrispyKringle> just some sort of routing-table kind of thing?
15:27:33 <shapr> At the moment, I think each research paper will have its own repo. So, you either create a repo or pull from your friends if someone already has a repo.
15:28:01 <KrispyKringle> ah
15:28:20 <KrispyKringle> that does make the most sense, assuming that there's some canonical home page for the paper. which there should be.
15:28:27 <shapr> So, routing is purely on a "I pull from people I know" basis.
15:28:38 <shapr> But I think that's more than enough.
15:28:45 <KrispyKringle> what i find more interesting is methods of sharing information for which there *isn't* a canonical original source--pgp keys, for example.
15:28:59 <musasabi> In haskell use just having a page in hawiki could be enough.
15:29:01 <KrispyKringle> but that doesn't really apply here.
15:29:20 <musasabi> but now -> sleep, good night.
15:29:28 <shapr> g'night musasabi
15:29:52 <Igloo> What do you do about conflicts?
15:29:58 <shapr> I don't know.
15:30:24 <shapr> I think it's quite likely that I'll throw FLM 0.1 out there and then a week later I'll know what needs to change.
15:31:09 <shapr> My best option for conflicts is to build a simple FLM-specific darcs interface.
15:31:58 <shapr> That would be useful for specific purposes like "Show some of the contents of this other repo so I can choose if I want to slurp their content" and "Here's a conflict, how to fix it?"
15:32:46 <wagle> a java XP'er pointed out (and recommended) this to me: http://www.codingmonkeys.de/subethaedit
15:33:09 <shapr> But I am not a fan of "big design upfront" so I'll just throw it out there and see what happens.
15:33:54 <shapr> "Plans are useless, but planning is essential" --Ike
15:34:26 <wagle> shapr: thats the XP way
15:36:36 <shapr> Anyway, FLM may not be a good way to do research paper annotation. Autrijus told me about Annotea, and it might be a better approach. - http://www.w3.org/2001/Annotea/
15:39:28 <shapr> In any case, I hope that a good way to share research paper annotations does happen, because I would like to read the margin notes of all the smart people on #haskell, the haskell mailing lists, lambda-the-ultimate.org, etc (but not slashdot).
15:40:35 <edwinb> It sounds like it would be useful... but I still prefer annotating with pencil and paper...
15:40:35 <kaol> why do I get an error with this expandSeq? http://haskell.org/hawiki/HaskellIrcPastePage?action=show
15:40:43 <SyntaxNinja> hi shapr :)
15:40:48 <shapr> hi SyntaxNinja!
15:40:57 <edwinb> I'd be impressed by a collaborative pencil and paper gadget...
15:41:00 <SyntaxNinja> shapr: how are the arms?
15:41:05 <shapr> Unbroken!
15:41:52 <SyntaxNinja> :P
15:42:31 <wagle> not typing by bouncing?
15:43:07 <kaol> never mind, I found my error myself
15:43:22 <Igloo> We can do remove surgery now, can't we? I'm sure remote scribbling ought to be possible too
15:43:41 * shapr wants his arms!
15:43:49 <shapr> No surgery please!
15:45:26 <wagle> the hci guys here do have interactive whiteboards
15:45:54 <edwinb> I tried an interactive whiteboard thingy the other day and was hopelessly incompetent with it.
15:46:39 <shapr> I can barely wait for the e-ink stuff to go on sale. I think that will allow the perfect combination of FLM and pencil and paper.
15:47:16 <SyntaxNinja> me
15:47:18 <SyntaxNinja> er
15:47:38 <wagle> whoa: they are playing LP records here
15:47:39 <SyntaxNinja> me and this other guy were interactively writing on a white board, but we kept fighting over the marker.  I think we need gpg sigs... or maybe SSL
15:47:43 <Igloo> I knew it was you! Guards!
15:48:03 <shapr> Corporal Carrot!
15:48:22 * kaol perfected his haskell implementation of bash's brace expansion for an article he's writing
15:48:24 * SyntaxNinja throws up a veil of obfuscation and escapes igloo's clutches.
15:48:24 <edwinb> I kept wanting to rub off minor errors with my finger.
15:48:50 <kaol> ok, maybe not "perfected" with my skills, but I still think it's beautiful
15:49:28 <fraxtal> shapr returns
15:49:45 <shapr> but only temporarily!
15:49:53 <fraxtal> why
15:50:07 <shapr> Because I have to go back to work, and go back to fun code after that.
15:50:26 <SyntaxNinja> @seen shapr
15:50:27 <lambdabot> shapr is in #haskell. Last spoke 20 seconds ago.
15:50:28 <shapr> I get a lot more code done when I'm not on IRC. So I'm planning on coming online in small doses.
15:50:29 <SyntaxNinja> yay!
15:50:31 <fraxtal> don't you live on an oil rig ?
15:50:55 <SyntaxNinja> shapr: as you can see, your legend has grown
15:51:10 <shapr> @yow !
15:51:11 <lambdabot> I'd like some JUNK FOOD ... and then I want to be ALONE --
15:51:29 <shapr> fraxtal: We can't show movies here on our oil rig.
15:52:02 <kaol> anybody ever used do notation with lists? I did that a few times accidentally while doing this code.
15:52:14 <shapr> Sure yeah, it's really useful.
15:52:39 <shapr> The monad instance for lists is used for simulating backtracking, or for cartesian products.
15:52:40 <jlouis> shapr: back from the secret society, I see
15:52:52 <shapr> In the case of cartesian products sequence is usually simpler.
15:52:59 <shapr> jlouis: They let me touch my computer today!
15:53:08 <kaol> I only did that while thinking I was handling Maybe monads instead. It didn't quite do what I thought it would.
15:55:37 <kaol> I tried to avoid a case statement with do. A bit like what I wrote about on MaybeMonad page.
15:56:52 <shapr> Once you get comfy with the various monad instances it's like having a higher gear or something. You can go faster.
15:57:30 <kaol> I think I can say that I've had the most fun with coding while coding in haskell. It makes me feel smart.
15:57:50 <shapr> It gets better too :-)
15:58:38 <Gahhh> for there to be shapr there must be air and water
15:58:53 <shapr> and code!
15:59:06 <Gahhh> you got Pseudonym worried heh
15:59:55 <Gahhh> "he makes blog entries -- he must be alive"
15:59:59 <shapr> haha
16:11:16 <shapr> Right, time to go back to work!
16:11:18 * shapr waves
16:11:32 <jlouis> haha
16:11:36 <jlouis> @seen _shawn
16:11:37 <lambdabot> _shawn is in #haskell. I don't know when _shawn last spoke.
16:11:38 <jlouis> bleh
16:11:47 <jlouis> I am too fast
16:11:51 <_shawn> @seen shapr
16:11:52 <lambdabot> I saw shapr leaving #haskell 25 seconds ago.
16:12:09 <jlouis> heh
16:12:27 <SyntaxNinja> do I have to run latex, then bibtex, then latex again?
16:13:36 <jlouis> yup
16:14:15 <jaap> you may have to run them more then once if you have complicated references
16:14:39 <jaap> there exist scripts that run latex cum suis whatever number of times it takes to reach a steady state, I believe
16:14:48 <SyntaxNinja> omg
16:15:13 <jaap> tex was implemented a long time ago on systems and with constraints where this apparently made sense
16:15:38 <Igloo> I like rubber
16:15:46 * SyntaxNinja nods slowly... backs away
16:18:21 <SyntaxNinja> how does one normally cite tools in a paper, rather than citing a paper or anything, I'd probably want to cite their website
16:18:22 <kaol> "show 'a'" results "'a'". I don't like that. Is there a function that gives "a" and works for Ints too?
16:21:00 <Igloo> SyntaxNinja: :-þ
16:25:46 <kaol> I tried "show x :: Char = [x]", but that only gave error "Haskell 98 does not support pattern type annotations"
16:26:32 <kaol> and with hugs -98 I get error about ambiguousness "Could refer to: Main.show Hugs.Prelude.show". What's the syntax here?
16:27:06 <SyntaxNinja> kaol: are you trying to override the 'show' function?
16:27:10 <SyntaxNinja> kaol: have you read about typeclasses?
16:28:29 <kaol> whatever it takes to work around that broken standard show
16:28:49 <mauke> it isn't broken
16:29:58 <SyntaxNinja> @plug show 'a'
16:30:05 <lambdabot> "'a'"
16:30:48 <kaol> ok, then it isn't. "a" doesn't parse as a char, but "'a'" does.
16:33:59 <SyntaxNinja> kaol: you want a function to convert chars and integers to strings?
16:36:16 <kaol> yes. show does almost what I want. I can use it as it is for integers, but I want (\x -> [x]) for chars.
16:36:53 <SyntaxNinja> kaol: I see.  I don't think there is a function that does what you want, but you can make a new typeclass to do this.
16:39:32 <kaol> SyntaxNinja: ok, I'll look what I can do with typeclasses then. thanks for the hint.
16:40:19 * kaol reads the tutorial
16:42:24 <kaol> I've begun understanding monads before haskell's type system's intricacies. I must be abnormal.
16:45:40 <mauke> hmm, can you create generic instances? like instance (Show a) => Whatever a where ...?
16:56:54 <foxy_> @index hFlush
16:57:01 <lambdabot> System.IO
16:58:01 <foxy_> what's wrong with: import qualified Data.Map as M? I get not in scope data constructor M.Map
16:59:25 <Igloo> I don't
17:01:56 <SyntaxNinja> foxy_: have you played with visual studio for haskell?
17:02:11 <foxy_> no I haven't, is it good?
17:03:02 <SyntaxNinja> don't know... it uses cabal... were you the windows user having trouble linking w/ a library?
17:03:10 <foxy_> yeah
17:05:25 <foxy_> My problem is that I use Win9x.  I imagine that most users of visual studio have more modern hardware
17:05:54 <SyntaxNinja> I  wouldn't be surprised
17:09:52 <Pegazus> hi
17:09:56 <Pegazus> what is the rem function?
17:10:46 <SyntaxNinja> @rem
17:10:51 <SyntaxNinja> er
17:10:52 <SyntaxNinja> @type rem
17:10:58 <lambdabot> rem :: forall a. (Integral a) => a -> a -> a
17:11:07 <SyntaxNinja> @plugs rem 4 2
17:11:09 <lambdabot> 0
17:11:11 <Gahhh> need @doc. rem sounds like remainder
17:11:14 <Pegazus> what the hell means that?
17:11:29 <SyntaxNinja> @doc rem
17:11:31 <lambdabot> rem not available
17:11:40 <SyntaxNinja> Pegazus: looks like remainder to me
17:12:21 <kaol> I wish I could just do something like this: http://haskell.org/hawiki/HaskellIrcPastePage?action=show
17:16:42 <kaol> If I understand correctly, instead of that I have to make a newType from Char and all that follows from that. It seems so verbose...
17:17:35 <Gahhh> kaol: I dont even understand what you are trying to do.
17:17:56 <JohnMeacham> Yo.
17:18:12 <SyntaxNinja> Gahhh: ooi, why do you want a single function to print both chars and ints?
17:18:21 <SyntaxNinja> or I should say 'convert'
17:18:23 <SyntaxNinja> hi JohnMeacham
17:19:04 <Igloo> kaol: If you just want Ints and Chars then you can just make your own Show/show-a-like class/function
17:19:24 <JohnMeacham> Howdy.
17:24:18 <kaol> I took the easy way out and did this instead: http://haskell.org/hawiki/HaskellIrcPastePage?action=show
17:24:49 <kaol> no sense in forcing show to do my bidding, when I don't really need to use it in the first place
17:25:17 <kaol> I think I should've done this in the first place...
17:48:34 <kaol> which one is better? http://haskell.org/hawiki/HaskellIrcPastePage?action=show
17:49:59 <kaol> the second one has that (++) in it, which might make it slower. But otherwise it seems prettier to me.
17:50:24 <kaol> except that they don't seem to do the same thing at all. oops.
17:52:10 <kaol> no, wait... they do after all. hmm.
17:55:39 <JohnMeacham> do-notational... hehehe.
17:58:30 <kaol> nonetheless, it's a small nice example of refactoring
17:58:32 <kaol> IMHO
18:10:22 <lamer11167708702> I'm having a few problems with hGetArray:
18:10:43 <lamer11167708702> b <- newArray_ (1,10)
18:11:04 <lamer11167708702> bytesRead <- hGetArray h b 10;
18:11:11 <lamer11167708702> does this fill b?
18:12:14 <lamer11167708702> print (b!1); doesn't work instead complains no instance arries.
18:12:22 <lamer11167708702> Anyone?
18:12:51 <Igloo> You need to use readArray (or whatever it's called)
18:12:56 <Igloo> (!) is for immutable arrays
18:19:05 <lamer11167708702> that doesn't sem to work. I've replaced print (b!1) with:
18:19:13 <lamer11167708702>  b2 <- freeze b;
18:19:26 <lamer11167708702>  print (b2!1);
18:20:37 <JohnMeacham> You want: x <- readArray b i; print x
18:21:02 <JohnMeacham> Or, freeze is okay, but very expensive, so you probably don't want to use it unless you actually need an immutable array.
18:21:55 <wagle> @type freeze
18:21:57 <lambdabot> bzzt
18:22:05 <wagle> @index freeze
18:22:06 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
18:22:32 <wagle> @type Data.Array.MArray.freeze
18:22:33 <lamer11167708702> your x <- readArray b i; print x works
18:22:33 <lambdabot> Data.Array.MArray.freeze :: forall e
18:22:33 <lambdabot>             i
18:22:33 <lambdabot>             (b :: * -> * -> *)
18:22:33 <lambdabot>             (m :: * -> *)
18:22:33 <lambdabot>             (a :: * -> * -> *).
18:22:35 <lambdabot>           (Data.Array.Base.IArray b e,
18:22:36 <lambdabot>           Data.Array.Base.MArray a e m,
18:22:38 <lambdabot>           GHC.Arr.Ix i) =>
18:22:40 <lambdabot>           a i e -> m (b i e)
18:22:43 <lamer11167708702> thanks
18:22:50 <wagle> o_O
18:23:37 <lamer11167708702> but freezing doesn't. Ideally i'd  like and immutable array.
18:25:06 <lamer11167708702> No instance for (IArray b Word8)  arising from use of `!' at Main.hs:116
18:26:22 <wagle> what is freeze, or should i go look?
18:26:48 <JohnMeacham> Oh, seems like ambiguity. try putting an explicit type signature on b2
18:27:06 <JohnMeacham> freeze turns a mutable array into an immutable one.
18:27:24 <JohnMeacham> or, I should say, creates an immutable array from a copy of a mutable one.
18:27:32 <lamer11167708702> how do I do that johnmech?
18:27:45 <lamer11167708702> :: ?
18:28:16 <JohnMeacham> Umm.. 'UArray Int Word8' I think.
18:28:47 <lamer11167708702> cheers
18:28:58 <wagle> what benefit to make it immutable, if the cost is a copy?
18:29:31 <JohnMeacham> you can pass it to pure functional code or/and you can go on to modify the original without affecting your immutable version.
18:32:41 <lamer11167708702> sorry John I mean't where do I put the :: ?
18:33:57 <JohnMeacham> Oh, after b2. as in replace one of your b2's with (b2 :: UArry Int Word8 ) (assuming that is what you waint, which I think it is..)
18:38:18 <lamer11167708702> ah UArray not in scope. I have Data.Array.IArray .Marray and .IO imported. what do I need?
18:38:49 <lamer11167708702> ST perhaps?
18:40:00 <JohnMeacham> Data.Array.Unboxed
18:40:48 <lamer11167708702> good man John. cheers
18:41:14 <JohnMeacham> sure thing :)
19:17:29 <lispy> data DExp = LitInt Int | Add DExp DExp | ...; data Exp a = E DExp; instance Num (Exp Int) where ...; then ghc says illegal instance declaration for `Num (Exp Int)'
19:17:46 <lispy> but this code appears in a paper so I suspect it worked at some point
19:18:57 <Gahhh> lispy: check if they state whether they used any ghc extensions
19:19:24 <lispy> they do mention phantom types
19:19:37 <lispy> but i was hoping that was just a technique...
19:25:56 * esap wonders why latex doesn't seem to understand the \times command (accepts it but nothing displayed).
19:26:40 <lispy> esap: weird
19:27:05 <lispy> Gahhh: i found the paper that this paper got the idea from but i don't see much about ghc extensions
19:29:32 <lispy> ah, but turning them on changes the error message
19:39:42 <lispy> got it working
19:45:23 <esap> uhuh, I found what's the problem. It was emacs :-( It replaced \times with just one character which latex didn't understand :-(
19:45:39 <lispy> really?
19:45:55 <lispy> what mode do you use?
19:46:42 <esap> it automatically chooses LaTeX XS:tex8-i1/si Font  mode :-)
20:00:28 <lamer11167708702> how to you create a pointer to an array? (for use with the second argument of hGetBuf)
20:02:07 <foxy_> @index hGetBuf
20:02:07 <lamer11167708702> anyone?
20:02:08 <lambdabot> System.IO
20:02:20 <foxy_> @type System.IO.hGetBuf
20:02:21 <lambdabot> System.IO.hGetBuf :: forall a.
20:02:21 <lambdabot>        GHC.IOBase.Handle -> GHC.Ptr.Ptr a -> Int -> IO Int
20:04:06 <foxy_> lamer: you need to set up a ByteArray or some such and then make a pointer to it (Ptr ByteArray)
20:04:22 <lamer11167708702> b <- newArray_ (1,rows*cols*4)
20:04:44 <lamer11167708702>  bytesRead <- hGetBuf h (Ptr b) (rows*cols*4);
20:04:56 <lamer11167708702>  Couldn't match `GHC.Prim.Addr#' against `a Int e'
20:04:57 <foxy_> seems correct
20:06:13 <lamer11167708702> fails at typechecker
20:06:23 <foxy_> @index ByteArray
20:06:24 <lambdabot> bzzt
20:10:24 <foxy_> @type Foreign.Marshal.Array.newArray
20:10:25 <lambdabot> Foreign.Marshal.Array.newArray :: forall a.
20:10:25 <lambdabot>             (Foreign.Storable.Storable a) =>
20:10:25 <lambdabot>             [a] -> IO (GHC.Ptr.Ptr a)
20:11:52 <foxy_> lamer: b <- mallocArray (rows*cols*4)
20:12:16 <foxy_> lamer: bytesRead <- hGetBuf h b (rows*cols*4)
20:14:31 <lamer11167708702> mallocArray not in scope, do you know what modules thats in?
20:15:19 <lamer11167708702> @index mallocArray
20:15:23 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
20:19:40 <lamer11167708702> foxy now that b is a pointer to the array, how do I get at the array?
20:20:35 <foxy_> @type Foreign.Marshall.Array.peekArray
20:20:36 <lambdabot> bzzt
20:20:57 <foxy_> @type Foreign.Marshal.Array.peekArray
20:20:58 <lambdabot> Foreign.Marshal.Array.peekArray :: forall a.
20:20:58 <lambdabot>             (Foreign.Storable.Storable a) =>
20:20:58 <lambdabot>             Int -> GHC.Ptr.Ptr a -> IO [a]
21:47:51 <conal> lispy: that code (DExp, Exp) looks familiar
21:49:40 <TFK> Ooooh, Haskell for C programmers :-D
21:51:48 <KrispyKringle> huh?
21:51:52 <KrispyKringle> they can do that?
21:51:55 <KrispyKringle> :P
22:02:28 <Pseudonym> Yes.  The first lesson is "forget everything", thus reducing it to the previous problem.
22:02:45 <Pseudonym> .
22:03:54 <Cale> Pseudonym: heh
22:10:17 <TFK> Is it me or are a and b undeclared and uninitialized in the second C snippet of the fibonacci function?
22:32:46 <musasabi> morning
22:40:03 <lispy> conal: it should :)
22:40:33 <lispy> conal: i was reading one of your papers for a presentation i'm giving tomorrow
22:40:44 <conal> lispy: nifty
22:40:51 <conal> how's it going?
22:40:58 <lispy> pretty good
22:41:04 <lispy> i do have a question tho
22:41:12 <conal> fire away
22:41:39 <lispy> "Becasue we do not (yet) work with recursively defined images, laziness in a host language appears not to be vital in this case."
22:41:45 <lispy> I'm not sure how laziness would help
22:42:09 <conal> that's in my paper?
22:42:30 <lispy> yeah, "Compiling Embedded Languages"
22:42:41 <conal> let me look.  what section?
22:42:58 <lispy> last paragraph in future work
22:43:05 <lispy> er second to las
22:43:08 <lispy> last*
22:43:42 <conal> looking ...
22:43:53 <lispy> i'm going to try and apply this same stuff for making a DSL for procmail recipies
22:44:16 <lispy> i probably won't need as much optimization
22:44:39 <conal> got it.
22:45:12 <conal> back to your question/comment.  help with what?
22:45:37 <lispy> yeah, what are some of the ways laziness would help?
22:45:50 <lispy> i'm not sure i understand the statement
22:46:32 <lispy> what would make laziness in a host language vital?
22:46:48 <conal> okay.  i meant that if Pan handled recursively defined images (like Fran handles recursively defined behaviors), then laziness would probably be very useful.
22:46:52 <offby1> Ok, super newbie time: I start hugs (or ghci; no matter); I type in "bob :: Int"; I see ERROR - Undefined variable "bob".  But many tutorial examples begin with justh that sort of line.  What blindingly obvious thing have I failed to grasp?
22:47:15 <conal> for instance, infinite shrinking detail, defined recursively with no base case.
22:47:22 <lispy> ah
22:47:30 <lispy> so, fractals come to mid
22:47:32 <lispy> mind*
22:47:41 <Cale> offby1: well, ghci just evaluates expressions
22:47:49 * offby1 stares blankly
22:47:50 <Cale> as does hugs
22:48:04 <Cale> so you want to put your source code in a file and load it with ghci or hugs
22:48:15 <Cale> like ghci mySource.hs
22:48:15 <conal> something like that, though not mandlebrot-style
22:48:35 <Cale> or :load mySource.hs from within ghci
22:48:37 <lispy> conal: maybe the L-series (or whatever they are called)?
22:48:40 <offby1> you mean, the semantics of statements differ, depending on whether they were read from a file as opposed to being typed on the command line ?!
22:48:50 <conal> lispy: yes, like that.
22:49:01 <lispy> conal: thanks
22:49:04 <Cale> offby1: well, the syntactical context is different
22:49:10 * offby1 stares blankly
22:49:12 <conal> btw, did you see cfdg?
22:49:22 <lispy> cfdg?
22:49:28 <offby1> so, given a tiny 3-line example in a tutorial, I have to put it in a file, and then load the file, in order to see it work?
22:49:35 <Cale> yeah
22:49:36 * offby1 's mind boggles
22:49:45 <offby1> does that strike anyone else as silly?
22:49:47 <offby1> Or is it just me?
22:49:53 <Cale> just type :re to reload the file
22:50:05 <lispy> offby1: as a lisp programmer it does strike me as annoying, but i can see why it's that way, so not silly
22:50:08 <Cale> it's pretty simple to have an editor window and your interpreter open at the same time
22:50:15 <conal> lispy: context free design grammar
22:50:18 <offby1> lispy: can you explain?  I'm a lisp guy too
22:50:45 <lispy> offby1: in interactive haskell you can't compile, so you can't create functions, only use them
22:50:52 <conal> lispy: http://chriscoyne.com/cfdg/
22:50:57 <lispy> offby1: that's an oversimplified point of view
22:51:00 <offby1> lispy: hmph
22:51:06 <offby1> well, it certainly works, to load the file.
22:51:12 <offby1> Prelude> :load sumAll.hs
22:51:12 <offby1> Main> sumAll [1, 2, 3]
22:51:12 <offby1> 6
22:51:12 <offby1> Main>
22:51:18 <offby1> but ... but ...
22:51:18 <lispy> conal: thanks, i'll take a look
22:51:27 <offby1> what's the point of a REPL if you can't use it to mess around with?
22:51:42 <lispy> offby1: it's still pretty powerful
22:51:49 <pimaniac> i thought one of the haskell repls could take definitions
22:51:54 <lispy> offby1: and you can introduce some definitions via let
22:51:56 <offby1> well, they say Ada is powerful, too :-|
22:52:16 <conal> lispy: you're welcome.  i love the images, but not the language style.  it'd be fun to redo it in haskell.
22:52:23 <Cale> offby1: In ghci, you can use  "let f x = x + 1" to define a new function f
22:52:33 <Cale> but you still can't define new types
22:52:34 <offby1> oho!  I must try that
22:52:57 <offby1> Main> let bob x = x + 1
22:52:57 <offby1> ERROR - Syntax error in expression (unexpected end of input)
22:53:07 <offby1> what subtlety now evades me?
22:53:08 <Cale> Is that hugs?
22:53:13 <offby1> yes
22:53:18 <Cale> hugs doesn't have that :)
22:53:21 <offby1> oh :-|
22:53:24 * offby1 tries ghci
22:53:42 <conal> lispy: what's your presentation about?  is it in martin's FP class?
22:53:49 <lispy> conal: yes!
22:54:02 <offby1> Cale: works.
22:54:05 <lispy> conal: mostly i'm explaining your paper and answering questions
22:54:34 <lispy> conal: it's lucky i bumped into you tonight, that one question had me stumped, the rest i had figured out answers to :)
22:54:43 <conal> lispy: oh, cool.  :)
22:54:46 <Cale> offby1: but usually if the definition you're trying to make is the least bit interesting, you'll want to put it in the source, so that you have it for later
22:55:08 <lispy> offby1: do you know about dynamic bindings in lisp?
22:55:12 <conal> i just recently started watching #haskell.  got some great help from dons with hs-plugins
22:55:22 <offby1> Cale: that implies that I know what I'm going to write before I write it :-)
22:55:32 <lispy> offby1: think of the haskell repl as having no dynamic binding ability
22:55:37 <offby1> lispy: you mean, as opposed to lexical?  Yes.
22:55:50 <lispy> conal: yeah, irc can be a great tool or a great distraction :)
22:56:15 <conal> lispy: i'll bet!  btw, was it you who commented in class about the GIMP?
22:56:20 <conal> i've forgotten who it was.
22:56:36 <lispy> conal: actually it was, and i regret having to leave before i could finish the comment
22:56:49 <lispy> i was just trying to say that the gimp used scheme
22:57:57 <conal> scheme as a sort of scripting/glue language, rather than for writing fast effects?
22:58:26 <lispy> scripting/glue
22:59:05 <lispy> but, i could imagine Pan in scheme, and generating code that the gimp dynamically links into and runs
22:59:54 <conal> could work.  i'd hate to lose the concise syntax and static typing, though.
22:59:55 <lispy> and actually, i bet gimp uses scheme for some effects
23:00:28 <lispy> yeah, i come from the lisp camp, so i've not had static typing long enough to miss it :)
23:00:33 <conal> do you think we could tie haskell code in, ie build a bridge instead?
23:00:52 <conal> i also did a lot of lisp & scheme programming, and enjoyed it a lot
23:00:56 <lispy> i bet you could, but i don't know gimp that well
23:01:09 <conal> lisp in grad school.  scheme at Sun Micro
23:01:18 <lispy> wow
23:01:29 <lispy> i wouldn't have expected Sun to use anything but java :)
23:01:43 <conal> well, there's a neat story there.
23:02:28 <lispy> did gossling (was that the name of the java inventor?) used to be a scheme hacker?
23:02:41 <conal> my college roommate (by coincidence) was at Sun also, and he made a nifty scheme system he called "esh" (embedded shell).
23:02:42 <pimaniac> steele was, i think
23:02:55 <conal> definitely steele.  gosling did a bunch of lisp at cmu.
23:02:59 <lispy> steele invented scheme, iirc
23:03:03 <conal> right.
23:03:19 <lispy> heh, esh also means emacs shell :)
23:03:30 <conal> and gosling's dissertation was on a constraint language embedded in Lisp.
23:03:39 <Cale> offby1: well, you sort of have to know what you're going to write, because it must be well-typed.
23:03:52 <conal> coincidentally, steele's dissertation was also on constraints, iirc.
23:04:22 <lispy> offby1: if you don't know the code sometimes it helps to start with the types
23:04:39 <Cale> yeah, I was about to say just that :)
23:04:45 <conal> lispy: anyway, John Rose, who did the scheme system i used at sun, then went to the java group, where he designed inner classes & anonymous classes, which are transliterations of scheme's lambda.
23:04:55 <offby1> thanks, Cale & lispy
23:05:22 <lispy> conal: ah, yeah and they help a lot if you want to create a scheme implementation on the JVM
23:05:50 <conal> not too coincidentally!
23:06:24 <lispy> that's a cool bit of history to know
23:06:51 <lispy> i think i want to study language design
23:07:00 <lispy> but, then i'm never sure
23:07:22 <conal> lots of interesting stuff out there.  hard to choose.
23:07:34 <lispy> definitely
23:07:56 <lispy> graphics is very seductive, esp. to someone who enjoys math
23:08:30 <conal> totally.  graphics & math & functional programming go great together.
23:08:52 <conal> nice specifications, pretty pictures, motivation for optimization.
23:08:55 <conal> it's a great area.
23:09:00 <lispy> yeah, i've been wanting to combine functional programming and machinima
23:09:11 <lispy> for hobbiests
23:09:31 <conal> i haven't heardof machinima
23:10:03 <lispy> hang on and i'll find the site
23:10:07 <conal> oh, like red-vs-blue
23:10:23 <conal> my son showed me that one.
23:10:34 <lispy> http://www.machinima.com/
23:10:47 <lispy> yeah, looks like machinima.com has redesigned their site
23:10:52 <lispy> i didn't recognize it
23:11:26 <lispy> the nice thing about the movies is their amateur quality.  I think it's fun to see the stuff that is made by "real" people
23:11:43 <conal> thanks for the pointer.  i'll check it out.  you have an idea for fp+machinima?
23:12:04 <lispy> yeah, i wanted to create a machinima tool kit so to speak
23:12:36 <lispy> so that everyone can have a copy of the engine and just share the data
23:12:57 <lispy> the way machinima worked in the beginning
23:13:33 <lispy> quake was one of the first engines used, and people would record the engine to a .dem file and just share that to others with quake
23:13:45 <lispy> the nice thing is that you can reproduce it at any quality
23:14:05 <conal> very neat.
23:14:20 <lispy> my idea was to use fp for the scripting and anywhere else it will fit :)
23:14:48 <lispy> of course you'll need a visual editor
23:15:11 <conal> super.  i'd love to see more fp people work in rich, detailed application areas, discovering, refining, and sharing useful abstractions.
23:15:36 <conal> i'm working on a new Pan design, which i want to have run on linux & mac os, besides windows.  and create gimp plugins.  i'd love to find a student to help.
23:15:41 <lispy> yeah, it's mostly a dream tho.  I'm too busy to work on it these days :(
23:16:13 <lispy> yeah, wish i had time to work on something like thta
23:17:09 <conal> that's why your gimp comment stuck in my mind.  i wished i'd mentioned my project and asked if anyone was interested in helping.
23:18:05 <conal> i like a lot the idea of a visual editor that generates haskell code
23:18:13 <lispy> yeah
23:18:20 <lispy> that makes a lot of sense
23:18:38 <foxy_> is a -> a -> a of type a -> b?
23:18:47 <Cale> yes
23:18:54 <conal> i noticed over the years that some authoring tools are built on what can be viewed as an AST.
23:18:55 <Cale> a -> a -> a = a -> (a -> a)
23:19:13 <conal> especially when they support nonlinear editing and/or resolution independence.
23:19:30 <conal> but the languages are not designed well.
23:19:48 <lispy> conal: one of the things i really liked about Pan was the freedom from bitmaps
23:20:06 <lispy> i think vectors (or more generally functions) are a much better way to work
23:20:11 <conal> thanks.  continuity is one of my major themes, in time & space.
23:21:21 <conal> programmers often think that apis necessarily have to treat time & space as discrete & finite.
23:21:42 <conal> so i've been pushing on continuous & infinite.
23:21:52 <lispy> right, well when you are thinking of only being able to pass values that seems like a resonable limitation
23:22:36 <conal> what backus called the "von neumann bottleneck"
23:22:44 <conal> both physically and mentally
23:23:01 <lispy> backus of BNF?
23:23:30 <conal> yes.  that's why i started with his quote in my talk in your class.
23:23:54 <conal> and backus of Fortran.  And more relevant, of the language FP
23:24:28 <conal> i found his "can programming be liberated ..." paper very inspirational.
23:24:45 <lispy> hmm...i should write that down and read it some time
23:25:00 <conal> definitely!  i hope you like it.
23:25:17 <Gahhh> conal: That's a very good paper.
23:26:43 <conal> gahhh: sure is!
23:27:18 <conal> lispy: there's a reference in this paper: http://conal.net/papers/bridges2001/
23:28:11 <lispy> cool
23:28:26 <conal> oh, and an online version: http://www.stanford.edu/class/cs242/readings/backus.pdf
23:29:05 <conal> yoiks, it's late.  i'd better get to bed.
23:29:26 <lispy> yeah, same here :)
23:29:30 <lispy> conal: thanks
23:29:42 <conal> my pleasure.  have fun tomorrow. :)
23:29:55 <conal> catch you later.
23:29:56 <lispy> i will, i like presenting once i get over the nerves
23:30:01 <conal> ditto
23:30:17 <lispy> g'night
23:30:25 <conal> 'night
