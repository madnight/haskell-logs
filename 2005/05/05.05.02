00:00:15 <Gahhh> @timein sydney
00:00:18 <lambdabot>   Monday, May 2, 2005 at 5:01:18 PM EST
00:00:27 <blackdog> Yay! I can go home and code haskell!
00:02:34 <Gahhh> I think I can spend months reading the stuff http://pobox.com/~oleg/ftp/
00:04:54 <Gahhh> hmm, the ubuntu people apparently started working on a version control tool on their own.
00:05:35 <wilx> Hm, it seems to be very "in" to have one's own VCS.
00:05:45 <dons> hehe
00:06:06 <blackdog> oh, i've had one for years. I call it "where's that bloody file"...
00:06:19 <dons> it's good to see some innovation, after years of cvs hell
00:06:26 <dons> s/good/really really good/
00:06:31 <reffie> i don't think cvs is all that bad.
00:06:32 <wilx> I guess.
00:06:36 <shapr> The ubuntu people also have a Plone-based gettext .po file translator product that I very much want, but they won't release the source for whatever reason.
00:06:38 <dons> and "why didn't we do it years ago?"
00:06:42 <wilx> This is phase of expansion.
00:06:48 <shapr> reffie: have you tried darcs?
00:06:53 <wilx> In few years we get consolidation.
00:06:57 <wilx> And then stagnation again.
00:07:01 <reffie> shapr barely
00:07:07 <reffie> but it does seem nice
00:07:12 <blackdog> i used to think i was just wilful and lazy because i never got cvs. darcs took half an hour. 1 hour tops.
00:07:18 <dons> yeah, reffie, play with darcs some more. cvs doesn't come close.
00:07:20 <shapr> reffie: The easy comparison is, try to teach your significant other both cvs and darcs.
00:07:37 <blackdog> shapr: your SO sounds like a very patient woman.
00:07:55 <reffie> the thing with darcs is that it doesn't seem adapted for projects that have a central repository + several developers
00:07:56 <shapr> Nah, she just doesn't know anything about cvs except its name.
00:08:01 <Gahhh> SO's are not labrats you know heh
00:08:22 <shapr> reffie: What about the patch via email plus gpg sig checking?
00:08:50 <reffie> shapr and some script that automatically commits when it receives such a mail?
00:08:57 <shapr> Yup.
00:09:14 <shapr> Try the GettingStarted page on http://darcs.net/DarcsWiki/GettingStarted
00:09:16 <wilx> Hmm...
00:09:23 <reffie> that could be done, but i don't know if it's really ideal
00:09:46 <shapr> I've been doing it for awhile.
00:10:27 <shapr> I put up a non-gpg-checked darcs repository named wikiwiki that's used in the GettingStarted tutorial page.
00:11:11 <shapr> It's been up since Jan 20, 2004 - http://www.scannedinavian.org/cgi-bin/darcs.cgi/wikiwiki/?c=patches
00:11:21 <reffie> i should really go to bed
00:11:43 <reffie> i mean sleep
00:12:11 <dons> reffie, darcs works well with a central repo.
00:12:23 <dons> you hand out an ssh key, or other ssh access
00:12:26 <dons> just like cvs.
00:15:58 <Pseudonym> Sorry, boss key.
00:16:15 <Pseudonym> shapr: I couldn't tell you the answer to that question without actually trying out some AOP.
00:16:41 <Pseudonym> I'm the sort of person (like most people here, I suspect) that has to do it for himself in order to understand it.
00:17:09 <Pseudonym> (And I've found more than one bug that way, such as in the comonads paper!)
00:17:17 <shapr> Good point.
00:17:53 <skew> I think naming would be really anoying, also getting the types to work out for injecting actions
00:18:05 <Gahhh> is there a link to that discussion ?
00:18:31 <JohnMeacham> I really like how the development model for darcs is the same whether you are a 'central developer' or just an 'occasional hacker' it is just the different between darcs push and darcs send.
00:18:40 <JohnMeacham> I think that is one of its most powerful properties.
00:19:23 <shapr> Part of a not-yet-sent reply to Sven Panne - "There are many projects (including fptools) to which I would have contributed patches if the startup cost of sending a patch weren't so high."
00:19:49 <dons> I agree with that.
00:19:58 <dons> darcs lowers the barrier considerably.
00:20:34 <dons> as we've seen with, say, lambdabot. and it eases the burden on the main developers, who don't have to worry about setting up anoncvs
00:21:08 <shapr> Yeah, I was going to mention lambdabot specifically.
00:21:42 <dons> and no longer do developers get malformed diffs because the contributor doesn't know the precise diff args
00:21:51 <shapr> Most irritating thing about svn/cvs/etc is that I have to have a separate authenticated checkout to submit the patches I made to my intiial anon checkout.
00:21:51 <Pseudonym> I'm not entirely convinced that fptools is the "right" project for it, though.
00:21:55 <Pseudonym> Especially if you have cabal./
00:22:07 <Pseudonym> Oh, yeah, I hate that!
00:22:16 <Pseudonym> But thankfully you only have to do that once.
00:22:55 <dons> it's annyoning though. I have two fptools trees. and I invariably forget that I'm in the anoncvs tree.
00:23:12 <shapr> 1. debian package for X is broken but I really want to play with it 2. I grab the repo 3. it's still broken, so I fix it 4. How, where, what to do with the fixes?
00:23:18 <Pseudonym> Why do you have two fptools trees?
00:23:25 <Pseudonym> What do you need the anon one for?
00:23:42 <dons> just for safety.
00:24:02 <dons> i don't want to screw up :}
00:24:41 <reffie> i have to admit that "darcs send" is pretty cool
00:25:24 <Pseudonym> It'd be doubly nice if receiving patches were as easy.  I, unfortunately, use webmail now.
00:25:32 <JohnMeacham> Also, non core members can share patches. if darcs send sends to a public list then people who absolutly need a patch can just apply it before it is decided whether it gets in the main tree.
00:25:53 <dons> darcs push is good for testing on diverse machines, I find. I produce a patch on my openbsd box, then push it through my freebsd -> mac -> linux boxes, testing as I go.
00:25:57 <shapr> That's one reason I'd like to have hackage archives also be darcs repos, because if every deb were a darcs repo I would send out a bunch more fixes.
00:26:49 <dons> @seen Cale
00:26:50 <lambdabot> Cale is in #haskell. Last spoke 1 hour, 15 minutes and 49 seconds
00:26:50 <lambdabot> ago.
00:26:52 <JohnMeacham> Also, darcs saves embarasment. you can amend-record, unrecord and rerecord and pull to a private repo to ensure things work before sending the public patch. this is a huge advantage.
00:26:54 <shapr> JohnMeacham: Right, like the low latency robert-love patchset for the early linux 2.6 kernels. I wanted it even though it wasn't in the mainline tree, because it's so much faster with SMP.
00:27:34 <dons> @karma+ darcs
00:27:35 <lambdabot> darcs's karma has been incremented
00:27:49 <Pseudonym> What is the advantage of darcs over arch?
00:27:54 <JohnMeacham> Indeed. also, since patches are not sent to a specific repo, the patches sent to ghc-stable can be pulled into ghc-parallel, ghc-eager and ghc-johnsprivatecopynooneknowsabout and it is all just works!
00:28:02 <shapr> Pseudonym: Carpal tunnel prevention.
00:28:04 <Pseudonym> Despite being more theory than politics.
00:28:17 <Pseudonym> "arch" is one fewer characters than "darcs".
00:28:24 <JohnMeacham> Psuedonym: much smarter design. much lower barrier to entry.
00:28:27 <reffie> well shapr nothing stops you from using patches that are have been mailed to the mailing lists, even without darcs
00:28:28 <shapr> Nah, try using arch.
00:28:42 <Pseudonym> And "darcs" uses only one hand to type, and "arch" uses two, which is easier n the wrists.
00:28:54 <reffie> Pseudonym not if you use dvorak
00:28:55 <Pseudonym> OK, point taken.
00:28:59 <reffie> actuall
00:29:02 <Pseudonym> Having never used arch...
00:29:03 <reffie> even if you use dvorak
00:29:06 <shapr> reffie: It's not that easy, robert-love patches often required patches from Ingo, rik, etc
00:29:07 <reffie> ah no
00:29:11 <reffie> nevermind
00:29:25 <reffie> anyway, shapr, real men use freebsd :P
00:29:27 <shapr> With darcs I could just pull one patch and automagically get the ones it requires.
00:30:24 <reffie> i wanted to XXX something, but i forgot what
00:30:25 <reffie> sigh
00:30:28 <shapr> It was too much trouble to find the exact development versions of Ingo/Rik/etc kernels so that the robert-love patches would apply and not explode.
00:30:35 <JohnMeacham> The main thing about arch that bugs me is it kind of sucks for personal branches. like, I developed on my laptop and on my main machine, but there was no way to share code within arch that didn't advertise to the whole world my set up because patches are tied to the repo they were created in, not the user that creates them.
00:31:25 <shapr> Happily, someone created a sourceforge project where several people would track the robert-love repo and bundle everything needed to apply to a stock kernel to get the fun kernel.
00:31:30 <JohnMeacham> I ended up having to bypass arch alltogether and use 'unison' which of course screwed up arch's inode caching because they have an irrational fear of hash functions for some reason...
00:31:53 <reffie> ah now i remember.
00:31:56 <reffie> good night.
00:31:58 <shapr> g'night
00:32:16 <tuomov> And there's no local record. You must always inform the central repo of all you changes
00:32:33 <wilx> Hmm...
00:32:35 <Pseudonym> Gotta go.
00:32:36 <JohnMeacham> indeed. amend-record is huge.
00:32:38 <Pseudonym> Nytol!
00:32:42 <tuomov> I sometimes record things in small steps, and only push when I'm done
00:33:16 <wilx> Sounds like only darcs, svk and monotone are really decentralized VCS...
00:33:36 <JohnMeacham> Yeah, me too. I have lots of little changes which i might want to individually pull between my private repos, but when I pack up the patch for external consumption I merge it into a nice patch tied to the functionality it implements.
00:34:47 <vincenz> are data-constructors first class values in haskell?
00:35:21 <tuomov> You can use them just like functions
00:35:30 <JohnMeacham> Sometimes I think arch is purposefully complicated because they want to make money on their 'commercial arch support' company. Well, maybe not purposfully, but subconciously I don't think they have much impetus to simplify things.
00:35:44 <vincenz> tuomov: but can I store them?
00:35:49 <shapr> Tom Lord is darcs' ArchEnemy!
00:35:56 <Itkovian> meuning
00:36:20 * vincenz thinks that data constructors should be storeable just like functions, after all they have a similar typing interface
00:36:29 <JohnMeacham> vincenz: yup. you can use them anywhere you can use a function.
00:36:33 <vincenz> cool
00:36:43 <vincenz> so that's why TheZipper works so well in haskell
00:36:51 <dons> @type Just
00:36:52 <lambdabot> Just :: forall a. a -> Maybe a
00:36:53 <skew> you can't use a stored constructor for pattern matching
00:36:53 <dons> for example
00:37:04 <JohnMeacham> vincenz: assuming the typing is right of course.
00:37:09 <vincenz> skew: of course not, you can't pattern match a function either
00:37:19 <vincenz> but in ocaml, they don't work like functions
00:37:26 <vincenz> so you can not pass a data constructor around
00:37:32 <vincenz> you have to make a minifunction
00:37:36 <JohnMeacham> vincenz: really? I didn't know that. poor ocaml.
00:37:38 <vincenz> let con a b = Con a b
00:37:44 <vincenz> alpha con
00:37:44 <dons> oh, that's a bit silly
00:37:47 <vincenz> yip
00:37:52 <vincenz> it's a shame
00:38:13 <JohnMeacham> That seems like something the compiler could do under the hood automatically. Haskell does, which is convienient because it can add the 'seq' calls there for strict fields.
00:38:16 <vincenz> that and type classes and some lexing issues regarding symbols is what bothers me about ocaml
00:38:32 <vincenz> JohnMeacham: of course...after all a data constructor is jsut a function
00:38:43 <dons> so you're more inclined towards Haskell now, vincenz?
00:38:52 <dons> after a couple of months trying it out.
00:38:54 <vincenz> dons: I have issues with the lazyness and the lowperformance
00:39:07 <vincenz> dons: haven't really tried it out yet, don't really have a project to use it on which is my main stumbling block
00:39:07 <shapr> Laziness is optional.
00:39:26 <shapr> At least, somewhat.
00:39:28 <skew> Haskell is simpler language than O'Caml in many ways
00:39:41 <blackdog> vincenz: and yi is lightning quick. slow programs are also optional. :)
00:39:42 <dons> vincenz, ok, that's reasonable. you now reach Haskell Level 2: profiling, strictness, ..
00:39:42 <skew> but laziness is default, so you have to write stuff to turn it off
00:40:20 <skew> laziness makes it easier to think about your program, though
00:40:20 <vincenz> well I've tried looking at Flippi as shapr recommended, but one easily gets lost in all the different functions... that at times it's hard to split functions from syntax
00:40:24 <shapr> Right, I think that Haskell's default setting is "As little programmer time as possible to get something that works right."
00:40:50 <shapr> vincenz: Did Flippi help at all?
00:40:52 <vincenz> dons: what I'm using ocaml for right now is quite intensive
00:41:00 <vincenz> shapr: not too much, I get lost in what all the symbosl eman
00:41:07 <vincenz> some, but not enough
00:41:13 <vincenz> and then I got lost in the Parser thinsg
00:41:16 <skew> vincenz: what are you doing in O'Caml?
00:41:16 <JohnMeacham> Indeed. its the compilers job to optimize. :)
00:41:18 <vincenz> do char "a"; char "b"
00:41:24 <vincenz> skew: analyzing profiling data from C++ programs
00:41:40 <dons> oh, that seems like very much in Haskell's domain
00:41:49 <Gahhh> when jhc is out, lowperformance will be history, yes ?
00:41:54 <blackdog> shapr: that's a nice saying, but you probably need "on an unbounded computer" for it to be accurate.
00:42:25 <dons> just employ someone to plug in extra cpus and ram as required..
00:42:26 <skew> blackdog: computers are getting closer to unbounded all the time...
00:42:34 <JohnMeacham> Gahhh: That is the theory.
00:42:42 <shapr> blackdog: thing is, once you get it working right, then you can profile.
00:43:01 <blackdog> skew: ... ok, that just bork my brane.
00:43:11 <mauke> what is jhc? java haskell compiler?
00:43:15 <JohnMeacham> Gahhh: first I need to fix the low performance of jhc itself. which may be closer than I thought, I found some papers on linear time algorithms which should make jhc compile times competitive with ghc.
00:43:39 <JohnMeacham> mauke: http://repetae.net/john/computer/jhc
00:43:39 <skew> it's not quite so easy to make the program run fast and then profile until it's correct
00:43:43 <mauke> thanks
00:43:46 <blackdog> shapr: sometimes. profiling space leaks can be very frustrating - i had problems getting a dump a while back. perhaps it's better now, or i was just doing something wrong...
00:43:48 <vincenz> dons: multi-gigabyte files of profilign data
00:43:48 <skew> mauke: John's Haskell Compiler
00:44:03 <shapr> Space leaks can be a real pain.
00:44:04 <dons> ah, multi-gigabytes. so that's more interesting..
00:44:35 <vincenz> with dependencies that makes parallellisation imho quite impossible
00:45:22 <dons> the FFI is one tool you have to play with.
00:45:27 <skew> do you actually need all those gigabytes?
00:45:31 <vincenz> yes
00:45:43 <skew> I would be inclined to write a preprocessor to squish it down to a reasonable size
00:45:55 <dons> but mult-gigabytes cause problems in all languages, right?
00:46:11 <dons> the techniques for dealing with this much data aren't well publicised in haskell, though
00:46:38 <vincenz> no it doesn't, most languages can open files with 64 bit addressing
00:46:44 <vincenz> in fact I think it's pretty defacto
00:46:45 <dons> but it's not surprising that you'd have to use more sophisticated techniques to get good performance.
00:46:59 <vincenz> not much sophistication to my ocaml programs, pretty straightforward.
00:47:05 <skew> what kind of analysis are you doing?
00:47:12 <vincenz> it's a lot of tallying in different tables (I use maps personally)
00:47:21 <shapr> A big fold?
00:47:37 <vincenz> sorta...but I have to keep certain environments active
00:47:52 <shapr> I think that can be efficient in Haskell, since you don't have to have so much of the data in memory at once.
00:48:12 <vincenz> basically...whenever I allocate a block or free a block, I have to save this somewhere, and then whenever I have a memory access, I look through my blocks to see which one it is
00:48:32 <vincenz> it's not the space that would get very big, it's mostly just all the lookups and compares adn whatnot
00:48:45 <skew> that sounds pretty straightforward
00:48:53 <shapr> Oh neat, vincenzgrind = strace + post-mortem?
00:49:13 <skew> I thought you meant random access over many gigabytes
00:49:33 <vincenz> shapr: strace?
00:49:37 <vincenz> post-mortem?
00:49:58 <shapr> You're replaying and analyzing a malloc log, right?
00:50:00 <vincenz> yes
00:50:05 <vincenz> and memory access log
00:50:10 <vincenz> (and function-call log)
00:50:24 <vincenz> I have a few simple to use templates that allow me to do this logging
00:50:27 <shapr> I think that'll be pretty straightforward.
00:50:41 <vincenz> it's just raw performance I need...
00:51:11 <vincenz> I used to have it in python (before it had many whistles and bells) it took 50 minutes, I switched to ocaml, 2-3mins
00:51:11 <dons> I don't see anything yet that wouldn't be doable in Haskell. but if you're new to haskell, knowing what's fast and what's slow is not obvious
00:51:42 <skew> have you tried writing something in C?
00:51:57 <vincenz> nope
00:51:59 <shapr> Haskell can give you some interesting performance options like in-progress display, partial traces, etc Laziness can be much fun.
00:52:24 <vincenz> well it's not particularly complex code
00:52:35 <Gahhh> yeah, it's almost at the harddisk speed.
00:52:44 <vincenz> nah, faster than that
00:52:47 <vincenz> I mean slower :P
00:52:54 <skew> good point, how long does it take to just read the data?
00:53:02 <skew> like cat > /dev/null?
00:53:43 <vincenz> trust me, it's the comparisions in the different lookup tables
00:55:53 <skew> are you using a hashtable?
00:56:13 <dons> there's no reason for that to be slow in Haskell. you can write code that compiles to the exactly assembly instruction you need, if necessary
00:56:30 <vincenz> skew: no, map
00:56:57 <vincenz> especially for the blocks it's gotta be a map
00:57:05 <Gahhh> dons: is there an _asm keyword or what ?
00:57:09 <vincenz> seeing as when I look for an address it's never an exact match
00:58:34 <dons> Gahhh, no :} Use the unboxed primops, and check the C or assembly output. In particular, Word# ops map to single instructions
00:58:47 <musasabi> hmm, my 6.4 version of HSQL does not work :-(
00:59:10 <dons> this is 2 or 3 assembly instructions from what I recall:
00:59:11 <dons>     return (I# (word2Int# ((int2Word# i `and#` int2Word# 0xffff#)
00:59:12 <dons>                     `remWord#` int2Word# 52#)))
00:59:56 <Gahhh> ah
01:00:06 <Lemmih> musasabi: I got a properly cabalized HSQL if you're interested.
01:00:28 <musasabi> Lemmih: yes, I would like that very much.
01:01:12 <bourbaki> moin
01:01:15 <Lemmih> http://www.scannedinavian.org/~lemmih/packages/hsql-1.2.tgz or just 'cabal-get install hsql' (:
01:02:34 <dons>         _s6aw_=(StgWord)((I_)(R1.p[1]));
01:02:35 <dons>         _s6az_=_s6aw_&0xffff;
01:02:35 <dons>         _s6aC_=_s6az_%0x34;
01:02:37 <dons> :)
01:02:47 <musasabi> thanks.
01:03:14 <vincenz> dons: what platform is that?
01:03:52 <dons> that's the C code it compiles to
01:04:33 <vincenz> ah
01:04:34 <Lemmih> musasabi: './Setup.lhs configure' takes a combination of --enable-{postgres,mysql,odbc,sqlite}.
01:05:28 <dons> it compiles to this asm:
01:05:29 <dons>         andl $65535,%eax
01:05:35 <dons>         pushl $0;  pushl %eax;  pushl %edx;  pushl $52
01:05:35 <dons>         movl %eax,%eax;  xorl %edx,%edx
01:05:35 <dons>         divl 0(%esp);  movl %edx,12(%esp)
01:05:35 <dons>         popl %edx;  popl %edx;  popl %eax;  popl %eax
01:05:50 <dons> the last 4 lines are 'rem'
01:06:28 <dons> so if you pay attention to how critical code is compiled, you can get what you want.
01:07:02 <dons> probably compiling via C, as above, is faster, as gcc then decides how to translate those 3 lines of C
01:15:20 <xkb> hi
01:15:32 <xkb> is issue 2 of the monad reader also available in pdf?
01:15:56 <shapr> Some of the articles are, but not the whole issue.
01:16:13 <xkb> ah :D
01:16:14 <vincenz> got a link?
01:16:16 <shapr> Though if you miss the pdfs, send in feedback, and why you want PDFs.
01:16:20 <xkb> ok.. so disregard my email then :D
01:16:38 <vincenz> shapr: we want PDF so we can copy and paste it into word and see all the stuff that has been deleted :P
01:16:45 * shapr snickers
01:16:58 <xkb> I'd like em because I print the issue and distribute it here, at my work
01:17:04 <xkb> where em = pdf
01:17:25 <shapr> You have coworkers who like to read a Haskell ezine?
01:17:30 <vincenz> that reminds me of that other time when microsoft sent out some document....you just turned on "show undos" and you could see all the crap they had striked out
01:17:41 <xkb> shapr : yeah.. at least a few of them do
01:17:52 <shapr> Neato. Can you print from a browser?
01:18:23 <xkb> not that good here..
01:18:33 <xkb> Im in a shielded environment here
01:18:35 <xkb> old IE only
01:18:38 <shapr> yuck.
01:18:42 <xkb> yeps
01:19:14 <vincenz> got a link to Monad.Reader.2?
01:19:27 <shapr> Next issue may have the ability to turn wiki format into LaTeX for nicer printing. If/when that happens I'll backport issue two so you can print it.
01:19:30 <xkb> ah yuck.. no paste support
01:19:32 <xkb> http://www.haskell.org/tmrwiki/IssueTwo
01:19:45 <xkb> shapr : ok.. thanks
01:19:49 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo"]' by shapr
01:20:05 <xkb> I'm off to work now.. cya
01:20:10 <shapr> Have fun.
01:26:40 <boegel> shapr: how's TMR2 ?
01:34:55 <shapr> boegel: done!
01:35:24 <shapr> JohnMeacham: may I quote you in my reply? JohnMeacham said "Also, non core members can share patches. if darcs send sends to a public list then people who absolutely need a patch can just apply it before it is decided whether it gets in the main tree."
01:35:42 <boegel> shapr: where can I see it ?
01:37:04 <shapr> boegel: in the topic
01:45:31 <shapr> Is it possible to commit locally with svn? Can I do that without needing a user account on the original svn server?
01:46:10 <bourbaki> moin boegel
01:48:25 <boegel> hey bourbaki
01:49:56 <tuomov> shapr: you can with svk.. but it's a bit of a hack
01:50:17 <shapr> But not with svn?
01:50:33 <tuomov> not with plain svn
01:50:37 <shapr> Ok, thanks.
01:51:36 <tuomov> note that the central repo doesn't need to be using svk for you to be able to locally use it, though
01:51:49 <shapr> Hm, neato
01:53:01 <tuomov> you still can't do working-copy-local records, but must go through setting up a heavyweight mirror
01:53:20 <shapr> Yeah, that's the point I was trying to make.
02:23:05 <dons> @ghc
02:23:06 <lambdabot>   No constructor has all these fields
02:24:51 <dons> maybe it should randomly capitalise words, this is more like zippy: no CONSTRUCTOR has all THESE fields!!
02:25:50 <dons> Can't SPLICE the polymorphic local VARIABLE!
02:28:56 <mauke> ARGH
02:31:10 <dons> @yow
02:31:11 <lambdabot> Content:  80% POLYESTER, 20% DACRON ... The waitress's UNIFORM
02:31:11 <lambdabot> sheds
02:31:11 <lambdabot> TARTAR SAUCE like an 8" by 10" GLOSSY ...
02:31:54 <JohnMeacham> shapr: sure.
02:32:08 <jlouis> how do you view ppt files when OO is not an option?
02:32:34 <dons> OO?
02:32:37 <Oejet> Yay!
02:32:53 <tuomov> openoffice?
02:32:56 <dons> Other Operating-system?
02:33:00 <tuomov> I think there was some viewer..
02:33:05 <jlouis> dons: If I provide a patch ... does it go in?
02:33:19 <dons> abiword reads them.
02:33:26 <dons> jlouis, for lambdabot?
02:33:32 <jlouis> dons: yes ;)
02:33:38 <dons> depends on the patch...
02:33:41 <jlouis> abiword... hmm
02:33:44 <jlouis> dons: haha
02:34:04 * Oejet got scilab_2.6-4_i386.deb installed on GoboLinux.  Next up is GHC and friends.
02:34:15 <dons> if it's the patch that reverts all my patches, well..
02:35:20 <dons> if it's the patch that solves P=NP as a lambdabot plugin, then sure!
02:36:19 <skew> ... and I couldn't have done it without Haskell
02:39:38 <vincenz> Anyone know how to display source code in a latex document?
02:39:47 <skew> haskell source?
02:39:52 <vincenz> not particularly
02:39:57 <skew> I like lhs2TeX for Haskell
02:40:10 <Oejet> vincenz: The listings package.
02:40:11 <dons> \begin{quote}\begin{verbatim} is ok for some uses
02:40:17 <dons> listings is good
02:40:26 <vincenz> problem is that you can't put a verbatim inside a \fbox
02:40:33 <Oejet> texdoc listings
02:40:34 <dons> there's a number of haskell typesetters too.
02:41:20 * skew writes himself a reminder about finding a nice way to mix lhs2TeX and Haddock
02:43:00 <vincenz> ah thank you, listings is perfect
02:43:53 <Lemmih> Fooey. I have to learn something I don't understand well enough to describe /-:
02:44:08 <dons> stefan weir had a question about lhs2TeX on haskell-cafe@ today, anyone know the answer? (how to get correct tex error line numbers)
02:44:16 <vincenz> now I just have to know how to make it smaller
02:44:18 <vincenz> Lemmih: what's that?
02:45:25 <Lemmih> How to correctly implement package signing.
02:47:10 <vincenz> get a pen ;)
02:47:22 <vincenz> and make sure the package is within handreach
02:47:58 <skew> Lemmih: what are you trying to guarantee with the crypto?
02:48:52 <Lemmih> Validity of cabal packages (for HackageDB/cabal-put).
02:49:12 * Lemmih will read through the darcs sources.
02:53:17 <derelm> hi, i wonder if i cannot use let inside of a case statement?
02:53:52 <Lor> There are no case statements, just case expressions.
02:53:57 <skew> no, that works just fine
02:54:03 <Lor> And yes, you can use let in a case branch.
02:54:12 <derelm> Lor, ah ok ... hmm
02:54:48 <skew> what's the error?
02:55:06 <Oejet> derelm: Think of (let .. in..) as a value.  You can put it any place you can put a value.
02:55:21 <dons> @plugs case 1 + 2 of x -> let y = x + x in y
02:55:22 <lambdabot> 6
02:55:59 <dons> @plugs let x = 1 + 2 in case x + x of y -> y
02:56:00 <lambdabot> 6
02:56:19 <derelm> the error is expected type [char] inferred type t -> t1
02:56:48 <dons> jouis, yeah. I enjoyed espie@'s java rant too :)
02:57:00 <derelm> but the function used to work when i simply used pattern matching outside of case
03:01:09 <Lemmih> @paste
03:01:10 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:01:31 <TheHunter> @plugs case () of _ | let x = 2, x == 2 -> x
03:01:34 <lambdabot> Warning: accepting non-standard pattern guards (-fglasgow-exts
03:01:34 <lambdabot> to suppress this message)
03:01:34 <lambdabot>                  [let x = 2, x == 2, x]
03:02:25 <Lemmih> No result?
03:02:30 <TheHunter> are there security implications with -fglasgow-exts?
03:05:18 <dons> I think there may be
03:05:24 <dons> too many extensions are enabled.
03:05:30 <skew> TheHunter: for pugs?
03:05:41 <dons> or @plugs
03:05:49 <skew> yeah, that's what I meant
03:06:04 <skew> I think it should be safe if you leave out -ftemplate
03:06:05 <TheHunter> even with -fno-th ?
03:06:36 <dons> not sure.
03:06:54 <dons> my guess is that there's something. too many dark corners
03:07:08 <skew> actually, even templates are not an issue if you just have one module
03:07:15 <dons> your recent TMR2 article makes me no more confident..
03:07:43 <skew> really, if you are somehow robustly excluding access to IO
03:07:51 <TheHunter> but the article uses unsafeCoerce# and unsafePerformIO...
03:08:04 <dons> well, simonm pointed out:
03:08:05 <dons> paprika$ ghci -fglasgow-exts
03:08:05 <dons> Prelude> :t "bytes"#
03:08:05 <dons> "bytes"# :: GHC.Prim.Addr#
03:08:28 <TheHunter> oh.
03:08:39 <dons> which surprised me.
03:09:01 <Philippa_> it did me slightly, but it seems to me that's just a literal
03:09:08 <dons> just a literal, yep.
03:09:14 <Philippa_> it's not much good if you can't do anything with it
03:09:17 <dons> but a good way to pack byte arrays.
03:10:17 <dons> i'd prefer to selectively turn on known extensions
03:10:23 <dons> -fjust-pattern-guards
03:10:58 <dons> but we don't have such fine-grained flags
03:11:19 <TheHunter> i see your point.
03:18:31 <kosmikus> dons: lhs2TeX-question negatively answered on -cafe
03:18:33 <bourbaki> Philippa_ on which server was #flipcode again?
03:19:14 <dons> kosmikus, cheers
03:23:54 <Philippa_> bourbaki: enterthegame
03:24:01 <Philippa_> (ain't you lucky I'm up? ;-)
03:25:15 <bourbaki> heh
03:25:18 <bourbaki> i guess and thanks
03:25:22 <TheHunter> anyone opposed to unwikifying the links on http://www.haskell.org/tmrwiki/IssueTwo ?
03:26:36 <Philippa_> er, clarify?
03:26:46 <bourbaki> Philippa_ .net or .org?
03:26:55 <Philippa_> bourbaki: net IIRC
03:27:05 <Philippa_> com works
03:27:16 <TheHunter> instead of "#
03:27:16 <TheHunter> Impure Thoughts 1 by PhilippaCowderoy
03:27:16 <TheHunter> "
03:27:30 <Philippa_> turning it into the article name
03:27:35 <Philippa_> rather than the page name
03:27:36 <Philippa_> ?
03:27:40 <Philippa_> that'd be good for me
03:27:55 <TheHunter> "Impure Thoughts 1" instead of "ImpureThoughs/1"
03:28:24 <Philippa_> "Impure Thoughts 1 - Thtatic Compilathionth without a Lisp" would be better
03:28:42 <Philippa_> (rip the title from the page itself though, I've probably mis-lisped)
03:28:53 <TheHunter> ok.
03:29:24 * Philippa_ is somewhat bothered by the layout of the feedback stuff though
03:29:52 <bourbaki> whats the url to that mag anyway?
03:29:59 <Philippa_> I'd created an index page for any and all Impure Thoughts articles that get written at ImpureThoughts, with the intention of linking to discussion stuff from there
03:30:21 <Philippa_> I guess I can live with it all being under the relevant issue - I'd intended discussion as opposed to just feedback though, IYSWIM
03:31:03 <TheHunter> i see.
03:31:43 <TheHunter> i'll be finished with my changes in 5 minutes. Feel free to change it to whatever you like then.
03:31:55 <Philippa_> I'd also told shapr about that. I'm starting to wonder if there's a single communication point about this stuff yet and if not where it should be
03:39:33 <TheHunter> Philippa_, ok, i released the lock.
03:40:00 <Philippa_> cheers. I'm trying to decide what I should do though
03:40:43 <TheHunter> the thing about the discussion links is that we needed them now, cause if people comment, they'll do that right after they've read the article.
03:44:46 <Philippa_> okay, changed
03:44:58 <Philippa_> (on the grounds that they've been given ordinary text links so it's no big deal)
05:05:33 <vincenz> Philippa_: where are you from?
05:06:41 <Philippa_> Nottingham, UK - why?
05:07:15 <vincenz> curiousity
05:07:36 <skew> have you found Connor yet?
05:08:21 <Philippa_> I've not been looking - haven't been onto campus in months
05:08:26 <vincenz> Philippa_: and your real last name is cowderoy?
05:08:30 <Philippa_> yes
05:08:34 <vincenz> neat
05:08:45 <skew> I thought you were a student there?
05:09:04 <Philippa_> yeah. Suspended atm though - the last three years've been an ongoing pile of personal problems
05:09:25 <skew> I'm not so good about attending class, but I at least head out once per week per class to turn in homework
05:09:40 * Philippa_ nods
05:09:45 <Philippa_> sounds like I was in the first couple of years
05:10:05 <Philippa_> mind you, this may've been helped by eg the Java lecturer telling me to skip all the lectures and read a book instead
05:10:50 <bourbaki> heh
05:11:05 <Itkovian> afternoon.
05:12:48 <Philippa_> he was cool. He told me that after we'd been chatting about Mode X VGA programming
05:13:20 <bourbaki> :) usually i just go to lectures where the prof is fun
05:13:36 <bourbaki> like in my algebra course that guy looks like gandalf
05:14:10 <bourbaki> and is totally bored doing all that crappy first year math stuff and is also acting like it heh
05:16:09 <Philippa_> I get the impression Thorsten Altenkirch quite likes doing the first year maths and logic, in an 'I get to be silly' kind of way
05:17:06 <bourbaki> :) i guess its cause hes a pure mathematician and does really fancy stuff usually hes also into computer algebra systems and such
05:17:12 <earthy> mode x vga programming. wow. that brings back memories. ;)
05:17:17 <bourbaki> once he asked the students if they where bored also
05:17:18 <earthy> of e.g. Lemmings. :)
05:17:27 <bourbaki> heh
05:17:31 <skew> DHTML Lemmings :)
05:17:52 <earthy> nah, that's just throwing lots of firepower at the problem
05:18:07 <shapr> SVG Lemmings?
05:18:27 <vincenz> AVR lemmings
05:18:30 <Philippa_> bourbaki: Thorsten's a fairly serious logic type - I suspect he enjoys making sure he's not missed a single nuance regarding the basics though
05:18:31 <skew> have you seen DHTML Lemmings?
05:18:38 <shapr> It really exists?
05:18:41 <skew> yes
05:18:57 <earthy> the PC lemmings was cool in that it used the capability of VGA hardware to split the screen in two with different parts of video memory being used to fill each part of the screen
05:19:10 <earthy> and also using the viewport mode for one of the two parts
05:19:16 <earthy> so the entire level was in video memory
05:19:28 <earthy> and all the game had to do was shift viewport and animate lemmings
05:19:41 <Philippa_> was it using two parts or four?
05:19:46 <Philippa_> (background, version you actually show)
05:19:52 <earthy> two parts
05:19:57 <bourbaki> Philippa_ i guess there are just different kinds of profs the ones that want to teach something and make the ppl interested and the ones that do not care about that and just support the ones that make it through
05:20:17 * Philippa_ nods
05:20:59 <Philippa_> our other main maths bod I find... uninspiring, even when he's showing stuff that I find interesting. Though it probably doesn't help that I missed all the meat of the first module I had with him and've been coping with severe depression during all the subsequent ones (and thus not got round to playing with stuff on paper)
05:22:17 * Oejet hugs Philippa_.
05:22:23 <bourbaki> most important for math and all other technical courses is a good script and that prof did a really good script
05:22:53 <bourbaki> it features a lot of the high level linear algebra stuff and is connecting a lot of things
05:23:34 * Philippa_ nods
05:23:42 <Philippa_> having all the key stuff down on paper matters
05:24:05 <bourbaki> i havent seen a better scipt for LA yet
05:24:09 <Philippa_> and all the links to other material're key, they're where you get an intuition from
05:24:21 <skew> understanding what you are doing makes it a lot more interesting
05:24:42 <bourbaki> thats not of real interest in pure math :)
05:25:06 <bourbaki> another prof once told me that pure math can be really tricky cause it leads out of reality heh
05:25:26 <Philippa_> one of my problems was I never got the hang of showing my working enough. I don't have the knack for lengthy proofs (not helped by the fact that we don't get taught to do them properly at A level)
05:25:31 <Philippa_> heh
05:25:48 <bourbaki> neither have i
05:25:56 <bourbaki> but the good proofs are like 3 lines
05:25:58 * Philippa_ has commented before that suitably high level maths is a good replacement for LSD...
05:26:09 <Philippa_> and a lot of stuff in-between that you're assumed to know how to do
05:26:16 <bourbaki> we did a lot for fancy stuff like dual spaces and such to make proofs more elegant
05:26:23 * Philippa_ nods
05:26:29 <Philippa_> I do like that kind of thing
05:26:48 <Philippa_> I tend to do it on an intuitive level - the problem is I'm crap at getting it onto paper
05:26:58 <bourbaki> but in math you get to the interesting things on top thats why i often work top down in math
05:27:11 <bourbaki> reading the highlevel things and refine where i need to
05:27:44 <skew> algebraic topology is great stuff
05:27:59 <bourbaki> topology in general is
05:28:04 <lispy> heh, yeah, but it takes a bit of background :)
05:28:10 <vincenz> Philippa_: me too, intuitively I can place it down but not on paper
05:28:12 <bourbaki> i like to see topology as the language of analogies
05:28:28 <lispy> i could see that
05:28:50 <lispy> asteroids (the game) is analogous to donuts
05:28:53 <Philippa_> bourbaki: yeah, I'm a top-down type too
05:29:03 <skew> actually, I think Hatcher assumes very litle specific background
05:29:10 <Philippa_> although not in code
05:29:24 <skew> just "a level of mathematical sophistication rare in an undergraduate", IIRC
05:29:36 <bourbaki> same here thats why i finaly got to haskell :)
05:30:01 <skew> Philippa_: working on stuff you don't really understand just sucks
05:30:04 <lispy> skew: hmm...okay, i haven't taken a course on alg. topology, just talked with friends that have.  It was all very confusing to me ;)
05:30:05 <Cale> Hatcher does homology really well, but I don't like his treatment of Seifert-van-Kampen
05:30:27 <skew> Hmm, I don't think we really covered that
05:30:28 <Philippa_> skew: I have a mixed level of understanding when it comes to type systems
05:30:37 <Philippa_> eg I couldn't do most of the proofs without a lot of study
05:31:11 <Philippa_> OTOH, my intuition as to what's possible is fairly good
05:31:30 <Philippa_> (but not being able to do the proofs is equivalent to not knowing for certain you've got it right when you implement)
05:32:00 <bourbaki> why isnt there something like these old scheme lectures of ableson and sussman for haskell?
05:32:11 <tuomov> the kind of formal proofs used with type system are tedious..
05:32:22 <Philippa_> tuomov: damn right
05:32:33 <skew> I've been taking a physics class by Kip Thorne, and it was just last week I actually understood what was going on rather than just fudging the equations with everyone else... turns out the sucky part wasn't staying up till the sun rises.
05:33:10 <skew> there is some good quote about proofs in CS being trivial
05:33:44 <Philippa_> yeah, they're generally only interesting insofar as they exist
05:34:05 * vincenz sighs, as he is an EE and hasn't had many of these topics
05:34:14 <bourbaki> there are a lot of proofs that are trivial but it took a long time to find them
05:35:28 <Philippa_> vincenz: I've not had many of them seriously anyway - what type theory I know I've taught myself (with the aid of a pile of papers and TaPL and ATTaPL)
05:35:49 <Philippa_> yeah. And some people wonder why we want to let machines do that bit
05:36:26 <tuomov> I only had one course in theoretical cs back in uni..
05:36:30 <bourbaki> a lot of these proofs also show a good thing of creativity
05:36:46 <bourbaki> i doubt that machines will be able to do creative proofs for a long time
05:37:39 <Philippa_> tuomov: genuine theory I've not really done at all. I've got a bit of logic and set theory behind me
05:37:41 <tuomov> Even humans don't generally do that.. they just ape existing proofs
05:37:46 <Philippa_> oh okay, and the automata stuff and all that
05:38:10 <Philippa_> a lot of creativity is just realising you can ape one you wouldn't expect
05:38:16 <Philippa_> not all of it, mind
05:38:59 <bourbaki> like the pumpong lemma
05:39:03 <bourbaki> er pumping
05:39:18 <bourbaki> or that other proof that i do not have in mind atm or the cyk algo
05:40:07 <bourbaki> i seriously doubt that machines will do neat things for a while in that field simple proofs within a closed domain arent much of a challenge
05:42:58 * Philippa_ nods
05:43:09 <Philippa_> having the computer drop out the tedium's the main thing
05:43:21 <Philippa_> being able to check whether a given avenue of attack's viable quickly, that kind of thing
05:44:47 <bourbaki> but thats where topology comes into play again
05:45:32 <bourbaki> if you would have a giganti database with proofs then you could say that something is similar to something else and then try to proof it in a similar way
05:45:47 <bourbaki> once you have mapped the elements of the one problem to the other one
05:46:18 <skew> that would be one crazy topology
05:48:07 <bourbaki> sure but that is what you do in math all day
05:48:18 <bourbaki> ie you show that a linear function is nothing but a matrix
05:48:29 * shapr shaboings
05:48:37 <bourbaki> then you do your stuff with matrices once you showed that its all the same and you can do a lot of nice proofs that way
05:50:15 * boegel shaboings with shapr
05:51:09 <vincenz> Philippa_: what do you do now?
05:51:29 <boegel> vincenz: anoy her bf
05:51:30 <shapr> whee
05:51:37 * vincenz snickers
05:52:01 <shapr> I am both tired and totally wound up.
05:52:15 <vincenz> shapr: Go do some sport, it'll help
05:52:20 * vincenz went swimming during lunch
05:52:24 <shapr> Yeah, I should go unicyling.
05:52:32 <vincenz> or hackeysacking
05:52:39 <shapr> I don't have a hackeysack.
05:52:48 <shapr> Plus you really need other people to do that with.
05:53:20 <vincenz> not true
05:53:28 <vincenz> usually it goes much better alone
05:54:49 <boegel> shapr: try and beat your computer in calculating the sqrt of 188742189731
05:54:55 <boegel> and...GO !
05:55:07 <shapr> yow, my brain is already tired!
05:55:22 <lispy> heh, sqrt(188742189731), done
05:55:27 <boegel> well, now you'll be tired enough to sleep
05:55:32 <lispy> my brain is lazy :)
05:55:40 <boegel> lispy: :D
05:56:52 <dons> go!
05:56:53 <dons> go!
05:56:55 <dons> @plugs sqrt 188742189731
05:56:57 <lambdabot> 434444.69122202427
05:57:01 <dons> doh.
05:57:30 <Philippa_> <vincenz> Philippa_: what do you do now? <- fill my time. Personal projects, gaming, slowly attempting to piece my day-to-day life together, that kind of thing
05:57:45 <Philippa_> usually my bf doesn't get /that/ annoyed :-)
05:57:47 <shapr> (and Write about FlippaCat and Tyop)
05:58:21 <Philippa_> shapr: I'm in no position to write about the former seriously, I don't have enough theory to do more than prod it in front of people who do (who're already using terms like 'Idiom' for similar ideas)
05:58:35 <Philippa_> but yeah, Tyop and a writeup thereof would be one of those personal projects
05:58:40 <dons> quoteable!
05:59:05 <dons> "who're already using terms like 'Idiom' for similar ideas"
06:00:20 <Philippa_> heh
06:00:49 * Philippa_ was playing around with variants of what Conor McBride calls Idioms, in case you hadn't guessed - though I'd derived them by generalising arrows instead
06:01:28 <shapr> That reminds me, I never did figure out Conor's Idioms mailing list post.
06:02:14 <shapr> In the Python,Java,etc worlds I used to keep a list of stuff I didn't understand so I could come back and fill in my understanding later. I had to switch to keeping the other kind of list in the Haskell world.
06:03:33 <reffie> hyv‰‰ p‰iv‰‰
06:03:49 <shapr> hyv√§√§ huomenta reffie
06:04:04 <reffie> :)
06:06:40 <boegel> hyvaa paivaa too ! *ahum
06:06:57 <skew> shapr: I think it's really that nobody ever noticed or named or did those things in Python / Java / etc
06:07:04 <shapr> reffie: Hey, have you had time to try darcs and the patterns we talked about?
06:07:12 <reffie> heh no, shapr
06:07:30 <reffie> i was too busy sleeping :)
06:07:39 <shapr> Bah, what a waste of time.
06:09:19 <shapr> Admittedly, sleep is good for high quality thinking.
06:09:38 * xerox reads You and Your Research between those words
06:12:16 <sorje> High quality thinking :-)
06:23:37 <boegel> is there someway to multiply two lists with eachother?
06:23:54 <boegel> as in f [1,2,3] [2,3,4] = [2,6,8]
06:24:06 <lispy> boegel: zipWith (*)
06:24:12 <boegel> lispy: thanks
06:24:29 <lispy> @plugs zipWith (*) [1,2,3] [2,3,4]
06:24:37 <lambdabot> [2,6,12]
06:24:53 <lispy> not exactly the answer you wanted, but it's correct :)
06:25:29 <skew> LiftM2 will give you a Cartesian product
06:25:42 <skew> @plugs Control.Monad.liftM2 (,) [1,2,3] [2,3,4]
06:25:44 <lambdabot> [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
06:25:56 <boegel> lisppaste2: heh, sorry :)
06:26:10 <Heffalump> :t (,)
06:26:13 <Heffalump> @type (,)
06:26:19 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
06:26:25 <Heffalump> @type (,,)
06:26:27 <lambdabot> (,,) :: forall c b a. a -> b -> c -> (a, b, c)
06:26:28 <Heffalump> cool.
06:26:39 <Heffalump> @type (,5,)
06:26:40 <lambdabot> bzzt
06:26:43 <Heffalump> aww
06:26:50 <skew> @kind (,)
06:26:51 <lambdabot> (,) :: * -> * -> *
06:26:55 <lispy> but shouldn't you use sets instead of lists if you are doing to do cartesian producs?
06:26:57 <skew> @kind (,,)
06:26:59 <lambdabot> (,,) :: * -> * -> * -> *
06:27:13 <skew> It works at the type level too
06:29:05 <lispy> what is the difference between a -> a and * -> *
06:29:08 <lispy> or rather a -> b
06:29:15 <Heffalump> a -> b is a type
06:29:18 <Heffalump> * -> * is a kind
06:29:41 <lispy> hmm..i haven't discovered types in my exploration of the haskell landscape...
06:29:46 <Heffalump> a type specifies a range of possible values
06:29:51 <Heffalump> a kind specifies a range of possible types
06:29:58 <Heffalump> you haven't run into _types_? EEK!
06:30:23 <lispy> er i meant kids
06:30:24 <lispy> er kinds!
06:30:32 <lispy> i'm tired and not typing right :)
06:30:34 <lispy> (get it)
06:30:54 <lispy> i should have went to bed, but i had so much work i did an alnighter
06:31:07 <lispy> but it's starting to wear on, and i've been spending my time in irc :)
06:31:31 <Heffalump> so, for example, Maybe is a type constructo
06:31:37 <Heffalump> it takes a type and gives you another type
06:31:45 <Heffalump> so Maybe is of kind * -> *
06:32:09 <lispy> ah
06:33:19 <xerox> @kind (:)
06:33:28 <lambdabot> bzzt
06:33:44 <xerox> Hmm.
06:33:50 <TheHunter> @kind (->)
06:33:52 <lambdabot> (->) :: ?? -> ? -> *
06:34:08 <xerox> @kind (~>)
06:34:10 <lambdabot> bzzt
06:39:39 <skew> kowey: did you fix your xml performance problem?
06:39:44 <kowey> hi skew
06:39:51 <kowey> i didn't have a chance to look at it
06:39:56 <kowey> but i did create a patch which allows haxml
06:40:01 <kowey> to be compiled for profiling
06:40:08 <kowey> (hairier to do than i thought)
06:40:24 <kowey> only thing is that i still haven't worked out the diff switches so that patch doesn't complain about strip
06:40:32 <malcolm> Don't forget to send that patch to the maintainer of HaXml :-)
06:40:43 <kowey> that would be you :-) ?
06:40:45 <kosmikus> TheHunter: why does (->) have such a strange kind?
06:41:42 <skew> kosmikus: I think it's something to do with unboxed types and tuples
06:41:52 <malcolm> kowey: yep.
06:42:06 <skew> IIRC, ? can be an ordinary type, of kind *, or an unboxed type, of kind #
06:42:09 <TheHunter> kosmikus, i think ? is either unboxed or boxed. no idea what ?? means.
06:42:21 <kosmikus> skew, TheHunter: ok
06:42:37 <skew> ?? can be *, #, or an unboxed tuple as well
06:43:12 <TheHunter> ah, ok.
06:43:54 <skew> @kind (# GHC.Prim.Int# , GHC.Prim.Int# #)
06:44:00 <lambdabot> (# GHC.Prim.Int# , GHC.Prim.Int# #) :: (#)
06:44:48 <JohnMeacham> ? can contain foralls and ?? can't. I think. I am not positiv.
06:45:11 <JohnMeacham> @kind (,)
06:45:12 <lambdabot> (,) :: * -> * -> *
06:46:23 <boegel> does anyone know how I can place stuff in red in a LaTeX document without too much fuss ? I want to flag a few things I have to check
06:46:33 <TheHunter> @type (\_ -> Int) :: (forall a. a -> a) -> Int
06:46:34 <lambdabot> bzzt
06:46:38 <kosmikus> \textcolor{red}{...}
06:46:44 <TheHunter> @type (\_ -> 0) :: (forall a. a -> a) -> Int
06:46:46 <lambdabot> (\_ -> 0) :: (forall a. a -> a) -> Int :: (forall a. a -> a) -
06:46:46 <lambdabot> > Int
06:46:46 <boegel> that easy? nice :)
06:46:47 <kosmikus> requires \usepackage{color}
06:46:48 <skew> @kind (forall a. Maybe a) -> Int
06:46:50 <lambdabot> (forall a. Maybe a) -> Int :: *
06:47:06 <skew> JohnMeacham: I think it's the stuff I said about unboxed things
06:47:23 <skew> a * can't be an unboxed value, which is why you can't make [Int#] and such
06:47:29 <boegel> kosmikus: thanks
06:47:46 <JohnMeacham> Yeah, but that doesn't explain the difference between ? and {?
06:47:50 <JohnMeacham> ? and ?? I mean.
06:48:05 <skew> unboxed tuples are only allowed to be used as arguments to functions
06:48:12 <TheHunter> @kind Int -> GHC.Prim.Int#
06:48:14 <lambdabot> Int -> GHC.Prim.Int# :: *
06:48:19 <skew> and they are reported with kind (#). I think that explains it
06:48:22 <TheHunter> @kind Int -> (# GHC.Prim.Int# , GHC.Prim.Int# #)
06:48:24 <lambdabot> Int -> (# GHC.Prim.Int# , GHC.Prim.Int# #) :: *
06:48:28 <kosmikus> skew: only as results, I think
06:48:50 <kowey> malcom: off it goes!
06:48:54 <TheHunter> @kind (# GHC.Prim.Int# , GHC.Prim.Int# #) -> Int
06:48:56 <lambdabot> bzzt
06:49:10 <JohnMeacham> foralls may only appear to the right of arrows in haskell 98. unless you use explicit type annotations and rank-n types. I am not sure how the rank-n stuff interacts with kinds in ghc, the ?? may mean a polymorphic type is never infered.
06:49:18 <skew> Kind error: Expecting kind `??', but `(# GHC.Prim.Int#, GHC.Prim.Int# #)' has kind `(#)'
06:49:34 <kosmikus> JohnMeacham: in Haskell 98, there is not forall keyword at all
06:50:14 <JohnMeacham> kosmikus: indeed. but there is an implicit forall across all the universally quantified types. and they always scope over the right side of an arrow, never the left.
06:50:39 <kosmikus> JohnMeacham: usually, a polymorphic type is always of kind *; I don't know how this extends to unboxed types and tuples
06:50:53 <JohnMeacham> which is why you don't need a keyword, there is always only one possible interpretation.
06:51:15 <kosmikus> JohnMeacham: well, in Haskell 98, the implicit foralls always scope over the *complete* type
06:51:47 <JohnMeacham> a minor point, they are isomorphic.
06:51:53 <JohnMeacham> but yeah.
06:52:08 <skew> JohnMeacham: examples of applying (->) to things with foralls show that it works. Examples with primitives show that you can use e.g. Int# in those ? positions but not in * positions
06:52:46 <skew> TheHunter's last two tests showed that unboxed tuples are accepted in the ? position but not the ?? position
06:54:46 <JohnMeacham> Ah, I guess the kinds are not representing what can be infered. which makes sense. Hmm.. I wonder where this is documented for real.
06:54:52 <skew> I think the existence of *,?,?? can be accounted for from their interaction with kinds # and (#)
06:55:03 <JohnMeacham> and #
06:55:13 <skew> I don't know about documentation, I just looked over the section in the guide on unboxed stuff, and didn't see it
06:56:15 <JohnMeacham> Yeah, I will look around the source. I am very curious. I was under the impression the unboxed tuple constraints were 'on the side' and not part of the type system itself. but I guess I am wrong.
06:57:57 <skew> does jhc have any support for unboxed values?
06:58:08 <skew> does that make any sense?
06:59:16 <JohnMeacham> skew: yes. I wish it did from day 1. I put them off thinking they would be complicated, but it turns out once I implemmented them they simplified sooo much.
06:59:55 <JohnMeacham> skew: not user visible. but used internally in the same way as ghc. it would be quite simple to make them user visible, just modify the parser to accept them.
07:00:06 <JohnMeacham> Ah.
07:00:24 <JohnMeacham> ghc/compiler/types/Kind.lhs has the tree.
07:00:38 <JohnMeacham> 		 ?
07:00:38 <JohnMeacham> 		/ \
07:00:38 <JohnMeacham> 	       /   \
07:00:38 <JohnMeacham> 	      ??   (#)
07:00:38 <JohnMeacham> 	     /  \
07:00:39 <JohnMeacham>             *   #
07:00:53 <JohnMeacham> Ooh. that didn't work at all. darn IRCs line-basedness.
07:01:02 <reffie> http://www.theinquirer.net/?article=22945
07:01:35 <Igloo> It only didn't work because you used evil tabs
07:01:40 <JohnMeacham> ?? is the lub of * and #, ? means any type at all.
07:02:09 <lispy> lub == least upper bound ?
07:02:16 <JohnMeacham> Igloo: I blame the line-basedness for making it hard to use proper tabs :)
07:02:34 <JohnMeacham> yeah, I think so. will have to look at the file more to see what that means in this context.
07:07:45 <autrijus> hey
07:07:54 <autrijus> anyone with hsc2hs or FFI foo?
07:07:54 <JohnMeacham> Yeah. so ?? effectivly means no unboxed tuples :). I think I was confused because the lambdacube paper I was reading uses ** vs * to express poly vs monomorphic types
07:07:57 <autrijus> I've made this to work:
07:08:08 <autrijus> http://svn.openfoundry.org/pugs/src/Data/Yaml/Syck.hs
07:08:34 <autrijus> but it doesn't use the proper #peek calls for struct access. once that's done, I'd also like a walkthru on getting it cabalized
07:09:31 <autrijus> (it is currently built as part of Pugs's "make")
07:14:19 * mwc makes disparaging remarks about the chromosomal integrity of postal employees
07:14:19 <lispy> autrijus: does ghc look for those first two lines and set the compiler options automatially?
07:14:19 <autrijus> lispy: yeah
07:14:19 <lispy> mwc: hmm...i suspect there is a good story behind that :)
07:14:19 <lispy> autrijus: ah, nice
07:14:19 <mwc> lispy, 10 AM and my new haskell book still isn't here
07:14:21 <lispy> mwc: my brother lives in a different city and gets about half my mail
07:14:37 <lispy> mwc: i have to wonder what would happen if my last name were more common
07:14:41 <mwc> heh
07:14:46 <shapr> TheHunter: SPJ enjoyed your article.
07:15:03 <mwc> I have the 66th most common name in America
07:15:22 <mwc> I don't know of anybody else getting my mail... how would I?
07:15:26 <lispy> mwc: where do you get a static like that?
07:15:44 <mwc> lispy, geneology hobbies
07:15:50 <lispy> ah
07:15:59 <lispy> makes me wonder how my name ranks
07:16:04 * shapr is more into djinniology
07:16:18 <lispy> the study of genies?
07:16:19 <mwc> Cox, #66, Descended from a lieutentant under William The Conquerer. He was called "Le Cocque" for his strutting, arrogant attitude
07:16:26 * shapr grins
07:16:33 <lispy> heh
07:16:40 <mwc> His kids became known as "Les Cocques" and that was anglicanized to Cox
07:17:20 <shapr> My former last name was Gilliam, traceable to Guillame, also for William the Conquerer.
07:17:25 <lispy> dagit isn't very common on the west coast, but i have a hunch there are many dagits in the other parts of the US
07:18:04 <mwc> I think you oughta Check Kobol
07:18:11 <lispy> Kobol+
07:18:13 <mwc> rumor has it there were plenty of Dagits thereabouts
07:18:18 <lispy> er s/+/?
07:18:26 * Cale posts a proof of mathematical induction to haskell-cafe
07:18:34 <mwc> Battlestar Galactica
07:18:44 <lispy> heh
07:18:53 <lispy> i've heard there was a character on that show named that...
07:18:54 <mwc> Dagits were something that didn't make it into the new series, thank god
07:19:12 <lispy> and nickelodeon had a cartoon with a character (a beaver) named dagit
07:19:16 <mwc> it's some sort of cybernetic dog like thing
07:19:18 <mwc> the les said, the best
07:19:34 <shapr> You are attacked by a gang of COBOLds. You wield your vorpal Curry.
07:19:46 <lispy> oh dear
07:19:48 <mwc> I have to go break GHC now
07:19:49 * xerox hehs
07:19:51 <mwc> back in a bit
07:20:22 <lispy> quick someone name their favorite NP-complete problem
07:20:31 <lispy> i need to choose a topic to study for my class :)
07:20:33 <shapr> Where's my socks!?
07:20:45 * boegel is glad to understand Cale's proof
07:20:57 <shapr> Finding my socks seems to be an NP-complete problem to me.
07:21:01 <lispy> heh, "shapr socks" not sure how the reduction works :)
07:21:06 <astrolabe> does it have to be np-complete?
07:21:12 <lispy> astrolabe: yup
07:21:29 <astrolabe> finding socks is p-space complete
07:21:40 <TheHunter> shapr, hehe, did he write you a mail?
07:21:55 * TheHunter feels flattered.
07:21:55 <shapr> Yeah, he did.
07:22:31 <boegel> Cale: kind of strange to find someone who doesn't know induction :)
07:22:45 * shapr doesn't!
07:22:53 <shapr> But I can deduce how it would work.
07:22:57 * shapr is too silly
07:23:02 <lispy> suggested problems included, steiner trees, protien folding, n^2-1 puzzle, rubick's cube, sorting by reversals, "recursive" structured graohs, graph isomorphism, upper and lower set approximations, world of cfl, resolution, boolean invertibility, knight's tour
07:23:45 <astrolabe> rubick's cube is np-comlete?
07:23:48 <lispy> i didn't really grasp induction until a friend challenged me to prove that induction is logically equivalent to well ordering on the naturals
07:23:53 <shapr> Protein folding is nifty, I've had some nutty ideas about that recently.
07:23:53 <lispy> astrolabe: i guess so
07:24:03 <Cale> the Rubick's cube is O(1) :)
07:24:15 <astrolabe> In the size of the cube I guess
07:24:16 <lispy> astrolabe: but there are heuristics, so the np-complete version is probably to find the minimum set of moves
07:24:22 <boegel> Cale: O_o
07:24:24 <xerox> Cale, yow! How?
07:24:26 <shapr> TheHunter: "I enjoyed reading about the amazing ways in which people are abusing GHC :-)"
07:24:36 <Cale> well, it's a finite cube
07:24:41 <boegel> xerox: when it's solved probably
07:24:45 <reffie> @ghc
07:24:47 <lambdabot>   Can't represent explicit kind signatures yet
07:24:52 <shapr> @ghc
07:24:53 <lambdabot>   Can't mix generic and non-generic equations for class method
07:25:01 <Cale> I suppose that if you generalise it, it gets harder
07:25:04 * shapr blinks
07:25:24 <Cale> but I'd bet (not too much) that it's polynomial time solvable in general
07:25:49 <lispy> i'm going to have to look up Graohs
07:25:50 <astrolabe> But cale, how are you specifying the complexity of the problem?
07:25:57 <lispy> never heard the term before
07:26:04 <Cale> the n*n*n rubick's cube
07:26:13 <astrolabe> right :)
07:28:01 <astrolabe> How about an n^k hyper-rubiks cube?
07:28:56 <shapr> Cale: I've lost that equation again, do you remember the guy's name who did the "how to find tiles in n-dimensions" ?
07:29:16 <reffie> rubiks hypercube?
07:29:17 <Cale> astrolabe: there the number of cubies to reconfigure is growing exponentially
07:29:25 <shapr> Next time I find it I'm putting it into my blog, then I can't lose it.
07:29:52 <sorje> shapr, penrose?
07:30:31 <shapr> Nah, some guy in the mid 1900s found an equation that can pull out the tiling shapes for any numbered dimension.
07:30:52 <Cale> http://www.ics.uci.edu/~eppstein/junkyard/tiling.html -- maybe something here?
07:30:56 * CosmicRay pops in
07:31:29 <xerox> http://dogfeathers.com/java/hyprcube.html (requires Java)
07:31:34 <shapr> Cale: Nice url, thanks.
07:33:25 <astrolabe> Cool link xerox
07:34:17 <astrolabe> I wrote a programme to do that on my spectrum.  It wasn't as smooth though!
07:34:17 <Cale> http://dogfeathers.com/java/hyperstar.html :)
07:35:31 <Cale> I wonder if I was 4 dimensional and had 3 dimensional retinas, whether the 120 cell would seem less complex :)
07:37:32 <shapr> I've wondered about being 4D and having 3D retinas also.
07:37:32 <shapr> You've read Flatland?
07:38:00 <xerox> Oh, there it is! http://www.superliminal.com/cube/cube.htm
07:38:36 <Philippa> shapr: have you read Diaspora by Greg Egan?
07:42:23 <astrolabe> Wow!
07:42:23 <Philippa> similar kind of mind candy
07:42:23 <skew> It's all in the visual cortex
07:42:23 <skew> I was just about to mention Diaspora
07:42:23 * Philippa read it about a month back
07:42:23 <astrolabe> Any good?
07:42:23 <Philippa> yes
07:42:23 <Philippa> it's almost exactly the sort of thing the SF-can't-be-good-fiction crowd hate the most
07:42:23 <Philippa> not least because it takes the whole "it's all about the ideas" thing and runs with it to the extent that if you intend to do lit crit you'd have to do it about how it's that for the characters too
07:42:23 <Cale> shapr: yeah, I read it a while back
07:42:23 <Philippa> Egan's good at postulating interesting Theories of Everything
07:42:30 <Philippa> not necessarily ones that could be our universe, but fun ones
07:43:33 <astrolabe> hmmm amazon are going to love me.
07:45:46 * xerox was playing with the 4x4x4x4 rubik hypercube, it is not possible for a human to solve, yay :-P
07:45:59 <kowey> a likely FAQ here...
07:46:07 <kowey> I tend to use the following code to print warning messages
07:46:16 <kowey> unsafePerformIO $ do
07:46:18 <xerox> But the program can solve it, whoa.
07:46:21 <Cale> xerox: are you sure?
07:46:28 <Cale> I think someone did it
07:46:29 <kowey>   when (some_error_condition) $ putStrLn "my warning"
07:46:29 <xerox> Cale, dunno, at least I cant.
07:46:31 <kowey>   return result
07:46:56 <Cale> I hear that once you learn a couple extra moves it's not much harder that 4x4x4
07:47:08 <Cale> maybe that's not true
07:47:31 <kowey> (whoops, sorry, i thought i'd intervene when i'd hit a lull)
07:47:39 <xerox> OK, gotta move, see you later.
07:48:01 <Cale> kowey: okay
07:48:25 <TheHunter> kowey, there's Debug.Trace
07:48:32 <Cale> kowey: that's not too different from trace
07:48:33 <TheHunter> @type Debug.Trace.trace
07:48:38 <kowey> hmm
07:48:40 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
07:48:57 <kowey> this is warnings for my end-user
07:49:18 <kowey> i thought trace was for me to hack around my code? (yes, of course, i could always use it for some other thing)
07:49:57 <kowey> the idea is that i have a function - just a normal, run of the mill function
07:50:08 <kowey> except sometimes i call that function with "odd" input
07:50:21 <kowey> the function doesn't break... but it should mention that there's something "odd" going on
07:50:25 <TheHunter> otoh, this is pretty much (module stdin <-> stderr) how trace is implemented, anyway.
07:50:25 <lispy> 1, 3, 5, ...
07:50:42 <kowey> interesting
07:52:31 <kowey> hmm... ok. anyway so using trace might save me loc, but other than that, is there any reason why this would be a bad thing to do
07:52:37 <lispy> weird, it's really hard to find info about Graohs
07:52:47 <shapr> kowey: Also, no point in waiting for a lull, just jump right in.
07:52:53 <shapr> Philippa: Nah, haven't read that.
07:52:58 <Cale> kowey: That's a not so good way to handle that, since those messages could get printed at basically any time. You have no guarantee as to when they'll print.
07:52:58 <kowey> i only ask because of the scary word "unsafe" <- i figure that all i do is a putStrLn, no harm in that, eh?
07:53:13 <kowey> well... that doesn't really bother me much
07:53:20 <kowey> i just want it to get out there
07:53:21 <Cale> no, that's an example of a case where it's not safe
07:53:31 <kowey> although i will say that laziness has bitten me many times
07:53:37 <kowey> (1) timing code (yes, i know, profile)
07:53:58 <kowey> (2) stuff like putStr "loading file..."; load_the_file; putStr "done\n"
07:54:37 <lispy> i've yet to get bitten by laziness
07:54:53 <Cale> It's only safe if you don't care when or how many times the code in the unsafePerformIO gets run
07:55:42 <Cale> generally, you want to check that there will be no visible side effects of that sort of code
07:55:43 <kowey> lispy : actually, i suppose i shouldn't complain, when i say "many", i mean "2"
07:55:51 <Oejet> Like when you are launching Inter Continental Balistical Missiles.
07:56:13 <kowey> hmmm... would like to see a snippet of that code
07:56:20 <kowey> import ICBM
07:56:52 <shapr> CosmicRay: Hey, did you see my thoughts on having fptools in darcs? Did I leave out any notable items? btw, you think you'll have time for a TMR3 article this month?
07:56:57 <Oejet> launch :: Integer -> IO Integer.
07:57:10 <CosmicRay> I did see it, let me pull it up again to refresh my memory...
07:57:14 * shapr is trying to get TMR organized before the release date this time
07:57:21 <kowey> anyway, thanks for the reassurance, Cale and all
07:57:26 <CosmicRay> unknown on time right now...
07:57:28 <Oejet> And you want to know in you pure code how many actually launched: unsafePerformIO# (launch 1000).
07:58:01 <lispy> kowey: ah, yeah 2 is not bad
07:58:07 * Oejet stops making noise.
07:58:13 <CosmicRay> shapr: that was on -cafe, right/
07:58:19 <shapr> Yes.
07:59:06 <CosmicRay> shapr: very good post.
07:59:15 * shapr boings happily
07:59:50 <CosmicRay> shapr: I think I read the first page of it, thought "I agree with that, shapr will probably explain the rest well, so I don't need to bother with this subthread anymore" :-)
07:59:58 <CosmicRay> (when I first skimmed the article)
08:00:15 <Cale> kowey: It would be (much) better style to report errors in a monad.
08:00:19 <CosmicRay> I like the point about lambdabot.  I had missed that before.
08:00:37 <shapr> haha
08:00:47 <kowey> well... yeah, but then that would involve propogating monadicness all the way up my chain
08:00:53 <kowey> ooof
08:00:59 <kowey> although, for actual errors
08:00:59 <shapr> I appreciate your confidence that I will explain the rest well.
08:01:03 <vincenz> Anyone familiar with teh xy-package of latex/
08:01:04 <vincenz> ?
08:01:21 <lispy> no
08:01:27 <lispy> i found it hard to use
08:01:33 <lispy> and gave up :)
08:01:37 <vincenz> crap, trying to make a categorical drawin
08:01:53 <vincenz> basically I have one diagram and then I want an arrow to a second diagram
08:01:59 <shapr> vincenz: It's installed on haskell.org, but I couldn't find out where on the net it really lives or how to install it locally.
08:02:05 <lispy> vincenz: hm...can you use a commutative diagram?
08:02:11 <vincenz> not really
08:02:16 <vincenz> it's more an explanation...
08:02:23 <shapr> You could ask on #latex
08:02:36 <vincenz> Yeah, but I figured you guys would make categorical drawings P
08:02:39 <lispy> vincenz: i usually fall back to using dia, it's not perfect, but it's quick and dirty usually
08:02:55 <shapr> I just keep all my categorical discussions on haskell.org ;-)
08:03:25 <lispy> i used to have "Math into LaTeX" (great book BTW) but even it didn't explain xy
08:03:27 <vincenz> ok...stupid question
08:03:33 <vincenz> how would I draw the following...
08:03:46 <CosmicRay> shapr: Yes, I find that I am able to extrapolate all of your main points on topics like that after reading the first third of your posts :-)
08:03:57 <CosmicRay> subconsciously, even.
08:04:07 <CosmicRay> though I didn't predict lambdabot  this time :-)
08:04:13 <vincenz> Cond is a functor that takes a Tuple Tlist and returns R.....  and Cond is a template built out of three functors..... one that takes Tlist and returns bool and two that take a Tlist and return R
08:04:36 <shapr> Next time I send you an email I'll send it in sz compression, that is, I'll just leave off the last two thirds.
08:04:44 <CosmicRay> hehe
08:05:05 <CosmicRay> shapr: I think you have invented an excellent new data compression technology.
08:05:19 * shapr laughs
08:05:19 <CosmicRay> shapr: you can call it subconscious predictive compression.
08:05:33 <shapr> Geez, now I know why people ask me if I'm a bot.
08:05:39 <CosmicRay> heh
08:06:10 <lispy> lol
08:06:13 <boegel> shapr: you're not ?
08:06:17 <lispy> i've had a few people ask me that
08:06:25 <lispy> i'm never sure if it's an insult...
08:06:27 <CosmicRay> shapr: truly, you are what MegaMonad always aspired to be.
08:06:29 <boegel> lispy: that's because of lisppaste2
08:06:40 * shapr infects boegel's computer and chews on his thesis.
08:06:51 * boegel is glad he has a backup
08:06:55 <shapr> mmm, proofs!
08:06:57 <lispy> boegel: and my nick used to be lispservice, lispy was just easier to login with :)
08:06:58 <boegel> that reminds me :D
08:07:05 <boegel> :)
08:07:23 <CosmicRay> lispy: hmm, given your nick, can I assume that the parens on your keyboard are well-worn? :-)
08:07:46 <lispy> CosmicRay: what parens?  lisp doesn't have any...at least, i can't see them anymore...
08:08:02 <skew> CosmicRay: any seasoned lisp hacker has a whole stack of spare keys just sitting there
08:08:09 <lispy> lol
08:08:09 <shapr> CosmicRay: oh hey, I can pay you to do sz decompression for those who haven't learned it yet!
08:08:27 <CosmicRay> shammah: <grin>
08:08:35 <CosmicRay> er, s/shammah/shapr/
08:08:36 * shapr does tag-team Haskell advocacy...
08:08:41 <CosmicRay> and grin at skew too :-)
08:08:44 <shapr> Haskell has lots of great points!
08:08:46 * shapr tags CosmicRay 
08:08:53 <lispy> does anyone have a one line description of protein folding?
08:09:00 * CosmicRay close-tags shapr
08:09:08 <CosmicRay> lispy: folding.stanford.edu might
08:09:13 * shapr laughs
08:09:21 <lispy> <shapr> Haskell has lots of great points! </shapr>
08:09:33 * boegel jumps the ropes to attack shapr: Java rules
08:09:33 <lispy> CosmicRay: thanks
08:10:28 <lispy> CosmicRay: yeah, that does somehow explain it
08:10:38 <CosmicRay> heh
08:11:10 <lispy> i'm really tempted to pick this last problem, but it's an open question so i'm a little worried about the amount of work it may require :)
08:11:52 <jlouis> Haskell has a lot of great points, but it is not for the pointy haired
08:11:59 <lispy> it's some sort of proof that the heuristic that my prof found using Warnsdorff's heuristic for generalized knight's tour is really an algo
08:12:25 <lispy> generalized knights tour being the case where there are tiles missing from the board
08:12:31 <Philippa> jlouis: yet another reason I shouldn't use hair gel, then :-)
08:12:45 <lispy> hair gel, my anti-haskell
08:13:33 <lispy> (i guess you'd have to live in the US and see the terrible anti-drug ad campaign, (Okay, I admit it's better than just say no))
08:14:02 * CosmicRay doesn't see much of that stuff anymore, thanks to MythTV
08:14:18 * boegel is offended by jlouis's remark
08:14:27 <lispy> i mostly catch it on the radio, as i don't have TV.  But it's the same idea :)
08:14:52 * CosmicRay listens to almost no radio other than public radio
08:14:55 <jlouis> boegel: dilbert reference in fact
08:14:59 <CosmicRay> it's not on public radio either :-)\
08:15:34 <SamB> they have anti-drug stuff on the radio?
08:15:39 <CosmicRay> over on public radio, we deal with weighty issues such as what color is the t-shirt we offer to people that pledge $120 or more during Prairie Home Companion? :-)
08:15:47 <SamB> or rather, "the anti-drug" stuff
08:16:22 <CosmicRay> yeah, commercial radio stations have to air a certain amount of "public service" content I think
08:16:30 <CosmicRay> so you mostly hear it at 3am when the advertising rates are the lowest
08:17:30 * SamB suspects most public radio listeners do not have problems involving drugs
08:17:36 <lispy> CosmicRay: our campus station has a PSA quota too
08:17:40 <CosmicRay> SamB: probably true :-)
08:17:50 <CosmicRay> lispy: interesting
08:18:09 <CosmicRay> lispy: I wonder if that doesn't apply to public radio stations, or perhaps 90% of their content qualifies as public service anyway :-)
08:18:19 <lispy> hehe
08:20:46 <SamB> CosmicRay: why only 90%?
08:20:54 <CosmicRay> SamB: Car Talk
08:21:05 <SamB> car talk is not public service?
08:21:09 <CosmicRay> SamB: heh
08:21:13 <SamB> humour is good for health, you know!
08:21:15 <CosmicRay> SamB: I suppose it could be :-)
08:21:22 <shapr> CosmicRay: I think you should write a blog series, MythTV replaces TVs with Linux, Asterisk replaces POTS with Linux, what's next? IBM's X10?
08:21:23 * CosmicRay is glad to spot someone who gets that reference
08:21:40 <CosmicRay> shapr: heh
08:21:44 * shapr used to listen to Car Talk
08:22:10 <CosmicRay> there are so many people that would love that program that just don't know about it because they don't know about public radio
08:22:35 <shapr> Oh hey, I had the coolest idea for distributed infantry HUD software recently.
08:22:54 <shapr> Do they keep Car Talk audio archives online?
08:23:36 <CosmicRay> I think so, let me look...
08:24:42 <CosmicRay> shapr: I think you have to subscribe to audible.
08:24:47 <shapr> oh
08:25:00 <shapr> Speaking of downloadable audio, ITConversations is quite nifty.
08:26:14 <shapr> Cale: You started a nifty thread with that post.
08:26:22 <CosmicRay> shapr: http://www.cartalk.com/Radio/Overseas/index.html
08:26:30 <shapr> Oh, I hope Sven Panne responds to my darcs post.
08:26:42 <CosmicRay> shapr: was that the subversion fan?
08:27:03 <shapr> Yeah, he seems to be a fan of subversion, and was wondering what darcs can do that makes it more interesting.
08:27:41 <shapr> Personally, I think 'using your own code' is enough... If the GHC developers keep GHC in darcs, I'm sure it would do wonders for both of them.
08:28:08 <CosmicRay> indeed
08:29:27 <SamB> that doesn't seem like it would be very fun for dialup users... I guess they could set up an svn mirror?
08:29:33 <shapr> btw, I took a multi-hour interconnected blog tour a coupla nights ago and I realized you can get just about anywhere with a very few steps in the blogosphere.
08:29:51 <Philippa> like that's a surprise
08:30:00 <SamB> also, people with little spare diskspace...
08:30:04 <Philippa> I don't know about anywhere else, but UK geekdom is a very, very small world indeed
08:30:09 <Philippa> space or quota
08:30:23 * Philippa may have to build GHC6.4 on one of the uni boxes sometime, for example
08:30:35 <SamB> Philippa: space. well, partitioned space, actually.
08:30:39 <shapr> It was surprising to me. I didn't expect to see Darius Bacon connected to autrijus with two intermediate steps. I found that and many other surprising connections among interesting programmer people.
08:30:57 <SamB> Philippa: or was that not a question but a statement?
08:31:06 <Philippa> statement
08:31:18 <shapr> Has anyone built an online browseable blog map?
08:31:26 <Philippa> obviously quota is just "available space" from another POV :-)
08:31:35 <SamB> true
08:31:51 <Philippa> shapr: did it not occur to you that /you're/ a connection between the two? :-)
08:31:57 * shapr blinks
08:32:06 <shapr> Well, that's one intermediate step.
08:32:13 <PerlJam> SamB: how much more space does darcs use than subversion?
08:32:21 <shapr> But I'm discounting myself since I'm the observer here.
08:32:32 <PerlJam> Does darcs have *three* copies of the repository?
08:33:19 <shapr> Two copies, I think.
08:33:27 <Philippa> shapr: the point was that if you're one bridge, it's not surprising if others exist
08:33:30 <shapr> Plus forks can be easily hard-linked.
08:33:34 <integral> and all the patches too
08:33:42 <Philippa> were they both people you know, by any chance?
08:33:43 <Igloo> Darcs normally has the workinig directory, the pristine direcrtory and the patches
08:33:49 <shapr> darcs --optimize --relink --sibling=../foo
08:34:03 <PerlJam> Igloo: that's real close to what subversion does (minues the patches)
08:34:04 <Igloo> pristine is the patches all applied but no other changes, so things like whatsnew and record are fast
08:34:22 <shapr> Philippa: only vaguely, luqui and kimbly.
08:34:30 <Igloo> You can have a repo without a pristine if you don't mind such commands being slow
08:35:01 <Igloo> (I can't remember if you can also tell it not to have a working directory, but I can't see why you shouldn't be able to in principle)
08:35:22 <Igloo> PerlJam: Do you mean a checkout of an svn repo?
08:35:41 <shapr> Oh, I discovered that someone else has thought about my idea of describing protocols in BNF, but he's using Python and having lots of problems that would be solved by Haskell.
08:36:14 <shapr> Anyway, I'm sure the first person to consider BNF-described protocols thought of it before I was born.
08:37:24 * earthy hums ASN.1
08:37:52 * earthy hums ISO/OSI Network model
08:39:36 <earthy> `everything old is new again'
08:39:38 <shapr> ASN.1 isn't a protocol, it's more an ADT.
08:39:47 <earthy> yes. it's like BNF
08:39:51 <shapr> ISO/OSI doesn't let me describe new protocols in BNF.
08:40:00 <shapr> I want to describe the whole state machine.
08:40:25 <earthy> ASN.1 lets you describe protocols at one of the layers of the OSI model
08:40:34 * lispy wonders why he doesn't get anything done, then drifts off to irc and email before the thought completes
08:40:34 <shapr> Where?
08:40:51 <shapr> How can you use ASN.1 to describe a state machine?
08:41:15 <lispy> shapr: i love questions like that
08:41:21 <lispy> just something about it...
08:41:48 <earthy> ASN.1 is included at this point in the text as the notation is effectively part of the interface between the application layer and the presentation layer.
08:41:51 <earthy> ;)
08:41:54 <earthy> you can't.
08:42:01 <earthy> anyway, time to go cook
08:44:06 <shapr> Maybe I'm just confused from lack of sleep.
08:44:33 <lispy> heh, reminds me of the gcc error message
08:44:58 <lispy> shapr: #haskell line 4012: confused from lack of sleep.  Quit
08:45:14 <lispy> er, wait is it "Bailing out."?
08:45:20 <lispy> shapr: #haskell line 4012: confused from lack of sleep.  Bailing out.
08:45:33 <lispy> i thinki need sleep too :)
08:45:36 * shapr grins
08:51:38 <basti_> hi
08:56:18 <shapr> shazam!
08:57:28 <basti_> ka-zam!?
08:57:34 <basti_> where's the tmr2 pdf?
09:02:01 <shapr> There isn't one. Some articles have pdfs, but there's not a single full-issue pdf.
09:02:38 <ibid> will there be one?
09:04:13 <basti_> ahh
09:05:26 <shapr> There are rumors that someone may develop a simple wiki format to LaTex converter. If that happens, PDFs will be created and uploaded.
09:06:00 <basti_> i see
09:06:11 <ibid> a pdf makes it much easier to print it out and put on the workplace coffee table to tease people :)
09:17:07 <shapr> ibid: want to join the project to turn wiki syntax into LaTeX?
09:17:21 <ibid> not really
09:17:34 <shapr> In my opinion, wikipublishing has been a great success, it got me out of being the single critical path.
09:17:34 * ibid has enough code projects atm
09:17:57 <basti_> hehehe
09:17:59 <musasabi> Are there any good papers on web DSLs?
09:18:08 <shapr> For example, I forgot the feedback pages before sending out the announce and falling over, so Philippa fixed it, yay!
09:18:27 <shapr> musasabi: looked at Links, SeaSide, RubyOnRails, UncommonWeb?
09:18:40 <musasabi> RubyOnRails and UncommonWeb yes.
09:18:58 <shapr> Have you written them up in a blog or something? I'd very much like to hear what you think.
09:19:42 <shapr> blackdog is considering writing a survey of Haskell web tech article for the next TMR.
09:20:14 <shapr> autrijus: Do you think Subcontinuations could actually be serialized for a continuation based webframework in Haskell?
09:21:25 <musasabi> I am mostly brainstorming - the hardest part seems to integrate a highlevel framework with the need to occasionally fall back into normal html.
09:21:55 <musasabi> (of course one can just insert a node of html but that creates problems if it is something nontrivial)
09:22:18 <shapr> Plone Archetypes uses html automatically derived html templates for input/edit and view, and allows the user to specify an explicit replacement if desired.
09:23:48 * Oejet wants something like http://brl.sourceforge.net/ Beautiful Report Language in Haskell.
09:23:50 <shapr> I thought about a higher level view where there were multiple flavors of the 'Show' class, much like repr and str in Python.
09:24:23 <shapr> Since Read and Show are already used for input and output, I thought a WebPublish class might have ReadXml and ShowXml.
09:24:24 <Cale> named instances sound somwhat like a good idea
09:24:42 <Cale> somewhat*
09:24:44 <shapr> Cale: like what?
09:25:01 <musasabi> The problem is that higher level components map to many different places in a html document - so concatenating two components is not the same as cncatenating their pretty-printed html.
09:25:05 <Cale> http://www.cas.mcmaster.ca/~kahl/Publications/Conf/Kahl-Scheffczyk-2001.html
09:25:27 <musasabi> shapr: using extra type-parameters should solve that.
09:25:57 <Cale> but yeah, I suppose musasabi's point is good.
09:26:22 <Cale> except that with that method, you sort of need to know you'll need them beforehand
09:26:24 <basti_> why would continuations be useful for a web framework?
09:26:42 <shapr> basti_: because you can hit back twice and then go from there.
09:26:53 <basti_> ohhhhh.
09:26:55 <basti_> yes i seee.
09:27:02 <basti_> that would be cool.
09:27:14 <musasabi> e.g. a form language usually needs javascript integration for checking input validity.
09:29:58 * vidvandre thinks he needs a book on Haskell
09:30:04 <shapr> I don't see a general fix for the high to low with static fixes.
09:30:21 <lispy> vidvandre: the standard report is online, maybe that will hold you over :)
09:30:45 <musasabi> static approaches can of course provide existential wrapping as a fallback.
09:31:20 <musasabi> but that needs more than just type parameters.
09:32:26 <shapr> Basically, you need the Evil Mangler.
09:33:36 <SyntaxNinja> 'morning
09:33:41 <vidvandre> lispy, good idea, I'll try that one first :)
09:33:45 <shapr> y0 SyntaxNinja
09:39:30 <pkeeken> has anyone experience met hsregex-0.2?
09:39:49 * vidvandre is listening to a radio show with RMS.. while reading the Haskell Report
09:40:10 <Muad_Dibber> hi peter
09:40:21 <Muad_Dibber> still at work?
09:41:35 <pkeeken> yes, iam still at work if your question was addressed to me
09:41:44 <Muad_Dibber> it was :)
09:42:16 <pkeeken> Eeh Raymon now i see
09:42:40 <SyntaxNinja> vidvandre: the report is a little steep; if you're looking for something gentler, you might try...
09:42:41 <Muad_Dibber> hehe
09:42:45 <SyntaxNinja> @goolge yet another haskell tutorial
09:42:48 <lambdabot> http://www.isi.edu/~hdaume/htut/
09:43:09 <SyntaxNinja> heya shapr
09:43:43 <vidvandre> SyntaxNinja, I think you gave me that url a couple of days ago, but thanks anyway :)
09:45:48 <SyntaxNinja> vidvandre: I must have garbage-collected that memory ;)
09:45:53 <vidvandre> hehe
09:46:15 <SyntaxNinja> did anyone give you the info about books yet? :)
09:46:15 <vidvandre> I agree though, the report looks rather steep.. grammar all over the place
09:46:26 <vidvandre> nope
09:46:44 <vidvandre> I guess there's Hudak vs Thompson or something?
09:48:51 <SyntaxNinja> yeah
09:48:58 <shapr> Celebrity Deathmatch!
09:49:08 <SyntaxNinja> but I think it's good to get warmed up on the online tutorials.
09:49:33 <SyntaxNinja> I'm annoyed at Hudak's book lately because it's hard to get the library that you need working; at least it was with the previous veriosn of hugs, not sure about march 05 version.
09:50:02 <SyntaxNinja> the last thing that a n00b haskell hacker wants to do is mess with libraries
09:50:58 <shapr> I've been talking to Claus Reinke about that
09:51:38 <shapr> I'd like to use his FunWorlds/HOpenGL to do cute graphics demos.
09:56:48 <vidvandre> I've read several tutorials on Haskell so far.. not the entire "Yet Another Haskell Tutorial" yet though
09:57:49 <SyntaxNinja> vidvandre: well, then maybe you're ready for a book :)
10:01:09 <vidvandre> :)
10:03:08 <vidvandre> "My excitement to learn Haskell faded with every page turned. The Author presented the subject with such excitement comparable only to that of watching paint dry.". nice
10:04:31 <Muad_Dibber> lol
10:04:44 <Muad_Dibber> at least thats better than starting your introduciton to haskell with parser combinators ;)
10:05:24 <SyntaxNinja> vidvandre: what's that describing?
10:06:07 <vidvandre> Thompson's book
10:06:14 <vidvandre> at amazon.com
10:06:39 <SyntaxNinja> eh, his book is pretty good, IMO.
10:06:48 <SyntaxNinja> @google slashdot review haskell school of expression ijones
10:06:51 <lambdabot> http://www.syntaxpolice.org/
10:06:54 <SyntaxNinja> hehe
10:07:15 <SyntaxNinja> http://books.slashdot.org/article.pl?sid=04/03/12/221232
10:07:59 <Oejet> Yay! I got feedback on my article. :-)
10:12:17 <SyntaxNinja> hiya malcolm
10:12:23 <SyntaxNinja> or malcolm_ as it were
10:12:43 <malcolm_> yo
10:13:20 <SyntaxNinja> malcolm_: you had mentioned how ranlib works on solaris, that it's the same on OS X, but someone yesterday told me that on modern solarises ranlib = exit 0
10:13:43 <malcolm_> what does "modern" mean?
10:14:12 <SyntaxNinja> > 5.something?
10:14:54 <malcolm_> You could be right - I just remember having to support ranlib at some point in the distant past.
10:16:24 <SyntaxNinja> OK cool. I think my fix is OK, the guy using mac OS who had the original problem says it works, and I don't think it'll cause any problem w/ other systems
10:24:48 <shapr> Oejet: Did the feedback show up on the wiki? or was it email only?
10:45:05 * Lemmih has been reading up on GPG.
10:47:06 <SyntaxNinja> Lemmih: yay
10:49:38 <Oejet> shapr: Email, but I found it interesting, so now I'm waiting to get allowance to put it on the Wiki,
10:50:09 <Lemmih> Does Peter Simons ever come here?
10:50:47 <shapr> Yes, he's peti
10:50:58 <Lemmih> @seen peti
10:50:59 <lambdabot> I haven't seen peti.
11:03:44 <Lemmih> What do you guys think of the Eternal Compatibility thingy?
11:04:18 <vegai> url?
11:04:40 <Lemmih> @google TMR Ternal Compatibility
11:04:42 <lambdabot> http://www.cmj.hr/2003/4403/16NUTINI.pdf
11:04:48 <Lemmih> @google TMR Eternal Compatibility
11:04:50 <lambdabot> http://amandasue.deviantart.com/
11:05:20 <Lemmih> http://www.haskell.org/tmrwiki/EternalCompabilityInTheory
11:08:43 <Oejet> shapr: The feedback pages does not seem to display {{{#!syntax haskell}}} properly.
11:14:10 <gzl> shapr: do you mean the first of June?
11:14:16 <gzl> er, you must.
11:14:32 <gzl> if so, yeah, probably, but I'm hardly an expert.
11:14:46 <Oejet> gzl: Me neither. :-)
11:16:22 <gzl> I don't mind writing it, I'm just skeptical that I'm qualified. :P
11:39:16 <shapr> gzl: Then you should start early and get qualified! I write tutorials to teach myself something. I'm slowly working on this Template Haskell tutorial in order to teach myself how to use TH.
11:39:37 <boegel> hey, there ?
11:39:42 <shapr> there, hay
11:39:42 <boegel> woops :D
11:39:47 <gzl> if you were suggesting writing about anything besides WASH, I would completely agree with you. :)
11:41:13 <shapr> gzl: You can pick something else that interests you more.
11:41:55 <gzl> hmm. I'll think about this a little. I was kind of interested in Generic Haskell earlier, but it's a little *too* rough around the edges still, I think
11:42:36 <musasabi> gzl: what about continuations?
11:43:05 <musasabi> There is no "how can one use non-escape continuations in haskell and retain one's sanity" tutorial.
11:43:34 <gzl> that would require too much work for this month. :)
11:43:53 <gzl> (I don't know anything about it yet.)
11:44:17 <gzl> I may just take the path of least resistance and do WASH
11:56:07 <a5> non-escape?
11:59:04 <musasabi> a5: escape continuations are for escaping to a lower level in the computation (like exceptions) while non-escape continuations support resuming execution.
12:01:12 <a5> ok.
12:01:18 <a5> your stack grows up?
12:01:23 <a5> :)
12:02:25 <a5> is there a good value of type (s->m a) -> ((s->a)->m b) -> m b
12:03:18 <shapr> That's state stacked on top of something else?
12:03:26 <lightstep> if all the foralls are stacked on the left, no
12:03:32 <Oejet> a5: It looks a bit like >>=.
12:03:57 <lightstep> unless you have reify or something like that
12:03:58 <a5> shapr: i don't think so, it's for a sort of continuation monad
12:04:06 <a5> lightstep: how did you know?
12:04:23 <lightstep> to use the second argument, you need some value of (s->a)
12:04:31 <lightstep> but you only have (s->m a)
12:04:45 <lightstep> but i didn't understand the article at all
12:04:59 <lightstep> i can only guess that reify is somewhat (m a->a)
12:05:35 <a5> i could use "m (s->a)" if i could get it
12:06:24 <lightstep> that's a container whose elements are functions
12:06:42 <a5> yeah?
12:07:14 <lightstep> that is, if you believe monads are containers
12:08:07 <a5> are you concluding something?
12:08:22 <lightstep> Monad m
12:17:05 * shapr is highly tempted to take over haskell.org website responsibilities.
12:17:48 <CosmicRay> shapr: please do
12:18:02 <CosmicRay> shapr: I will then forward you a copy of the messages I have sent to the current maintainers requesting changes :-)
12:18:07 <shapr> CosmicRay: Of course you realize I'll immediately delegate most of it, right?
12:18:12 <CosmicRay> heh
12:18:19 * CosmicRay will forward, and then immediately hide :-)
12:18:47 <shapr> Much like wikis and darcs, I prefer systems that let the community make their own changes.
12:18:49 <CosmicRay> shapr: that reminds me, for web page development with haskell, there's halipeto and HSP, right?  which do you prefer?  is hsp the one that may be usable for dynamic stuff soon?
12:19:03 <shapr> There's Hemplate by Lemmih
12:19:10 <shapr> You know WASH already.
12:19:14 <CosmicRay> right
12:19:18 <shapr> um
12:19:38 <shapr> Peter Thiemann hacked Simon Marlow's HWS to include hs-plugins
12:19:49 <shapr> nibro_afk is the public face of HSP
12:19:58 <CosmicRay> so if hemplate, hsp, and helipeto thing, what would you choose for generating static pages?
12:20:00 <shapr> HSP uses hs-plugins too, so that seems like a good combo.
12:20:09 <Huschi> SyntaxNinja: i've got the wxhaskell packages ready.
12:20:18 <shapr> halipeto already does static pages, but I want more!
12:20:45 <shapr> malcolm mentioned that HaXml was planned to have subdtd 'typechecking' at one point, that's what I'd like.
12:20:53 <CosmicRay> shapr: is it the only one that does static pages?
12:21:08 <shapr> Hemplate is Halipeto extended to do dynamic stuff.
12:21:14 <CosmicRay> on interesting
12:21:16 <CosmicRay> s/on/oh/
12:21:32 <shapr> You could use HaXml or HXT as pure XHTML tools to generate pages.
12:22:09 <shapr> blackdog has a neat modification of HWS-plugins that I haven't yet tried.
12:22:20 <CosmicRay> yes, I could.  However, I have used them already.  And if I'm going to be redoing www.complete.org from using php to generate static pages to using some Haskell thing to generate static pages, I might as well make it some haskell thing I've never used, so I learn something in the process.
12:22:39 <shapr> I'd suggest starting with Halipeto then.
12:22:49 <shapr> That's what I'm using for www.scannedinavian.org
12:23:06 <shapr> stepcut is using it for his sites, they look much better than my hacked up version of the demo.
12:23:08 <CosmicRay> I notice the little blurb about that on the halipeto page :-)
12:23:17 <CosmicRay> stepcut == andrew?
12:23:55 <CosmicRay> whoa, halipeto looks a lot like tal
12:23:58 <CosmicRay> is this intentional?
12:24:07 <shapr> Yes, it's a direct ripoff.
12:24:10 <CosmicRay> sweeeeet.
12:24:19 <CosmicRay> shapr: now I know why you like it, Mr. Zope
12:24:34 <shapr> I don't like Zope so much, but I am smart enough to recognize worthwhile features :-)
12:24:38 <CosmicRay> hehe
12:24:50 <CosmicRay> but, I notice the distinct lack of a darcs repository for halipeto! :-)
12:25:04 <shapr> You could ask andrew.
12:25:16 <CosmicRay> I will if I remember to. :-)
12:25:31 <shapr> Andrew is a very cool guy.
12:25:40 <CosmicRay> I will probably have to debianize this.
12:25:53 <Muad_Dibber> open source rocks.
12:26:01 <shapr> I'd call Andrew overly modest.
12:26:05 <CosmicRay> and cabalize.
12:26:22 <CosmicRay> yet another cool haskell technology.
12:26:25 <CosmicRay> this community is great.
12:26:28 * shapr agrees
12:26:49 <CosmicRay> we have  alot of overly modest people in this community.
12:27:04 <shapr> I think this summer may be the beginning of the Zope equivalent in Haskell.
12:27:27 <CosmicRay> shapr: I'm not porting the Data.fs bit :-)
12:27:33 <shapr> Me neither.
12:27:41 <shapr> But now I don't need to, I finally got Ape working.
12:27:44 <CosmicRay> heh
12:27:47 * CosmicRay curses Data.fs
12:28:03 * CosmicRay ncurses Zope's module system, while he's at it.
12:28:03 <shapr> I'm surprised no one has done a zodb/fuse binding.
12:28:17 <CosmicRay> shapr: the sheer evilness of it all
12:28:26 <CosmicRay> shapr: besides, they do have the ftp server already....
12:29:23 <shapr> Oh speaking of which, someone wrote .. oh yeah
12:29:31 <shapr> Alistair Bayley said something about MissingH
12:29:34 * shapr tries to remember
12:29:44 <shapr> I'm too far into lack of sleep :-(
12:29:46 <CosmicRay> but really, after I used zope for something like 3 or 4 years, I finally got fed up with that whole not being able to use a regular filesystem thing
12:29:56 <shapr> Now you can, sort of.
12:30:07 <CosmicRay> but not for hacking, right?  just for storage?
12:30:16 <shapr> What do you mean?
12:30:17 <CosmicRay> see, I'd want to shove my stuff into darcs, use emacs to edit it, etc.
12:30:22 <shapr> yeah, you can do that.
12:30:27 <shapr> It's a pain, but you can.
12:30:38 <CosmicRay> oh?  that must have happened after I swtiched away from it
12:30:52 <shapr> Nah, it's been there for awhile, but no one has really been able to use it.
12:30:57 <CosmicRay> heh
12:31:10 <shapr> It's arcane, picky, undocumented, and I used a large amount of time and ritalin making it work.
12:31:23 <CosmicRay> two things I don't have ready access to :-)
12:31:40 <shapr> At this point I can teach others how to do it, but it's not as easy as it could be.
12:31:58 <shapr> Of course, I plan on simplifying it via Haskell...
12:32:39 <shapr> Anyway, at this point you can define what, how, and where to store objects outside of the ZODB.
12:32:53 <shapr> Currently it only supports SQL and FileSystem backends, but that's enough for me.
12:33:26 <goron> hi shapr
12:33:34 <shapr> Personally, I think the ZODB is a good example of what might happed if reiser goes bad.
12:33:38 <shapr> hoi goron, hoe gaat het?
12:33:44 <CosmicRay> shapr: haha
12:33:46 <goron> ok, you?
12:33:51 <shapr> btw, how's your reiser experiments?
12:34:02 <shapr> goron: tmr2 is out! w00! I am lacking much sleep! w00!
12:34:11 <CosmicRay> shapr: pretty good, I've got two workstations and one laptop switched to reiser4 for everything but / (or /boot, for those that have it separate)
12:34:12 <det> shapr, You have had bad experiences with ZODB?
12:34:19 <goron> shapr: What's tmr2?
12:34:20 <CosmicRay> shapr: the speed of reiser4 kicks some damn serious ass
12:34:22 * Oejet really enjoys reading Eternal Compatibility In Theory.
12:34:28 <lightstep> @wiki TheMonadReader
12:34:29 <shapr> det: I had one good experience with the ZODB.
12:34:29 <lambdabot> http://www.haskell.org/hawiki/TheMonadReader
12:34:33 <bourbaki> moin
12:34:35 <goron> WOW
12:34:39 <shapr> Then I had a few bad years ;-)
12:34:42 <CosmicRay> shapr: that's one more than most :-)
12:34:44 <goron> I read the first issue :)
12:35:07 <shapr> CosmicRay: is it stable?
12:35:15 <CosmicRay> shapr: so far :-)
12:35:22 <shapr> hmm
12:35:24 <det> I tried Reiser with it was version 3 and I got corrupter a few times
12:35:27 <CosmicRay> shapr: I'm going to do some fun power-cutting experiments in the next day or so
12:35:30 <det> corruption*
12:35:33 <shapr> yipes
12:35:35 <CosmicRay> det: yes, that is why I avoid reiser3 like the plauge
12:35:51 <CosmicRay> basically it can crosslink blocks after a crash
12:35:57 <CosmicRay> if your system never crashes, reiser3 is fine
12:36:02 <shapr> det: Bad experiences with the ZODB mostly have to do with being unable to get data back out.
12:36:03 <CosmicRay> I still run it on my alpha
12:36:31 <det> shapr, Worst case senario :-)
12:36:34 <CosmicRay> det: JFS and XFS also have that corruption on crash problem, though XFS especially makes it much less common due to its algorithms
12:36:47 <det> CosmicRay, I have had great experiences with XFS
12:36:52 <CosmicRay> det: ext3 in data=ordered mode doesn't have the problem
12:36:58 <CosmicRay> det: nor does reiser4 from what I have read
12:37:04 <shapr> det: If you use custom folder types (and there are many), stuff can happen that means they become broken, and thereby opaque.
12:37:08 <det> CosmicRay, I use ext3 now just so I can mount it from windows
12:37:22 <CosmicRay> det: I tried XFS a bit last week, didn't really seem much of an improvement over jfs so I tried reiser4 :-)
12:37:30 * goron is configuring his new FreeBSD box :-)
12:37:35 <CosmicRay> XFS, to me, is "slightly less buggy than JFS" :-)
12:37:51 <shapr> XFS was awesome in Irix.
12:38:32 <CosmicRay> shapr: must have been the only thing then :-)
12:38:40 <shapr> Irix and XFS were tuned to be good for each other.
12:38:50 <CosmicRay> in fairness, I just had to admin some irix boxen, never actually got to use them for graphics or anything
12:38:55 <CosmicRay> irix made every unix admin I knew cringe
12:39:08 <shapr> I know, I was sysadmin for a bunch of irix boxen myself.
12:39:13 <CosmicRay> heh
12:39:25 <shapr> Indys, Indigos, Irix 5.2 and 5.3
12:40:03 <shapr> They really had amazing graphics power compared to anything else. And the default 21" monitors were spectacular.
12:40:10 <CosmicRay> heh
12:40:20 <shapr> But getting Python and MySQL built on Irix took me three weeks.
12:46:01 <basti_> mmm
12:46:08 <basti_> i know i've been saying this for some time now
12:46:15 <basti_> but, yi-emacs is really starting to make sense
12:46:20 * shapr agrees!
12:47:10 <basti_> a phenomenon unique to haskell (to my knowledge)... the more sense your code is making, the shorter it gets
12:47:58 <stepcut> basti_: yi-emacs == emacs type bindings for yi ?
12:48:01 * Oejet agrees.
12:48:11 <basti_> stepcut: yes. I'm trying myself at them.
12:48:34 <Huschi> Igloo: are you a registered debian developper?
12:49:15 <stepcut> basti_: nice! I tried a while ago, but ran out of time (plus, don was changing the way keymaps worked every other day back then :p)
12:49:22 <basti_> hehe
12:49:35 <basti_> he has arrived at fast lazy lexers now
12:50:39 <stepcut> basti_: so, have you figured out how to do all the emacs  things like describe-key and rebinding keys at run time ?
12:50:50 <Igloo> Huschi: I am a DD, yes
12:50:52 <Igloo> Why?
12:50:53 <basti_> well I'm coming closer
12:51:18 <basti_> Lexers are generated from lists now at runtime.
12:51:42 <basti_> That should make rebinding easy, and bring describe-key to reach
12:52:29 <Huschi> Igloo: i build packages for wxhaskell-0.9. could you put them into the debian repository anyway?
12:52:43 <basti_> (I didn't figure out how to put the lists into IORefs and still have that make sense, but i suppose i could)
12:53:46 <Igloo> Huschi: I'm not likely to have time for a bit, so you might be better off asking CosmicRay or SyntaxNinja
12:53:59 <Igloo> Huschi: What happened about the shared library?
12:54:32 <Huschi> Igloo: i tried to follow the debian policy as far as possible.
12:55:04 <Huschi> Igloo: i called it libgh6-wxhaskell0.9.so an put it into the libghc6-wxhaskell0.9 package
12:56:48 <Igloo> OK
12:59:11 <musasabi> Has anyone worked with combining boilerplate style generics with HList style records?
13:07:44 <lightstep> shawn, are you the shawn from Shawn's Radio Weblog?
13:13:07 <shawn> nope
13:13:17 <Lemmih> shapr: Can I get you to take down scannedinavian.org/cgi-bin/hackage?
13:24:13 * Lemmih throws angry lambdas at GPG.
13:30:35 <wilx> It doesn't want to give you your data without the right password? :)
13:31:11 <Lemmih> Heh
13:35:41 <xerox> Hi!
13:36:00 <Lemmih> 'gpg --clearsign' fails on input greater than 19995 bytes and I don't know why.
13:36:30 <xerox> What kind of failure?
13:36:31 * basti_ doesnt know if it's healthy that he now used haskell and fast lazy lexers just to make them go stateful, with all the potential harm that could cause
13:37:10 <Lemmih> xerox: "gpg: input line longer than 19995 characters"
13:37:37 <xerox> Lemmih, it's strange!
13:37:41 * basti_ .o¬∞ ( \n\r )
13:38:02 <basti_> this sounds like a hardcoded limit
13:38:15 <basti_> somewhat
13:38:19 <xerox> basti_, do you usually wonder of linebreaks? ;)
13:38:21 <Spida> hi
13:38:35 <xerox> 'lo Spida
13:38:40 <basti_> xerox: sometimes I'm dreaming in IT constructs.
13:40:02 <Spida> how can I limit the data type of entries in a list (or a set) to be (Integer, Integer) ?
13:40:23 <basti_> test :: [(Integer,Integer)]
13:40:33 <Huschi> as a parameter to a function?
13:40:38 <Spida> yes
13:41:06 <Huschi> test :: Integral a => [a]
13:41:15 <basti_> uh?
13:41:32 * basti_ thinks Huschi answered another question than i did.
13:41:45 <Huschi> i misunderstood the question. i read "Integer or Int" :)
13:41:54 <basti_> ahhhh.
13:41:55 <Huschi> or something like this.
13:41:58 <meurvin> hi
13:42:12 <meurvin> i wanted to ask a question
13:42:21 <meurvin> i am new to functional programming
13:42:29 <Huschi> why haven't you done it?
13:42:32 <basti_> most people are, at some point in their life
13:42:34 <basti_> =)
13:42:49 <meurvin> i wanted advice...like where should i start
13:43:11 <Huschi> what do you want to start?
13:43:14 <mauke> write "hello, world"
13:43:15 <xerox> meurvin, what are un interested it?
13:43:31 <xerox> s/un/you/ (what a typo)
13:43:35 <meurvin> i am not really sure at the moment...which is kind of pathetic
13:43:37 <basti_> xerox: that was a freudian slip
13:43:47 * xerox grins
13:43:49 <monochrom> haha
13:43:53 <basti_> meurvin: first get rid of the idea that you can write into variables.
13:44:01 <basti_> ban it from your head.
13:44:05 <basti_> :)
13:44:05 <meurvin> okay
13:44:09 <basti_> again.
13:44:10 <basti_> ;)
13:44:15 <monochrom> Don't write hello world. That's for imperative wimps. Write binary search tree algorithms.
13:44:19 <xerox> err, you actually _can_, but you can't modify them.
13:44:44 <basti_> xerox: well, thats a question of semantics of "write" i think.
13:44:49 <Huschi> xerox: recently you had a problem i almost solved for you. you wanted to make a list of conway values instance of Show.
13:44:58 <basti_> meurvin: are you specifically aiming at haskell?
13:45:14 <meurvin> could anyone advise on what language would be...well...helpful to learn?
13:45:27 <meurvin> wrong sentence
13:45:30 <basti_> for haskell, or generally?
13:45:38 <xerox> Huschi, nice!
13:46:00 <meurvin> generally...what language..in the functional arena...should i start with?
13:46:24 <basti_> well it depends on what you're aiming for
13:46:33 <xerox> Huschi, I always have this problem.  I think it's resolvable in two ways, and using 'data' and an explicit Constructor is the one I don't like.
13:46:36 <Huschi> xerox: but finally there was a compiler error about overlapping instnaces. you can pass -fallow-overlapping-instances to ghc to solve it. i remembered afterwards
13:46:36 <mauke> what language(s) do you know?
13:46:37 <lightstep> start with the one with the syntax you like most
13:46:42 <basti_> haskell would be a great start if you want to learn new things
13:46:47 <meurvin> okay
13:47:05 <xerox> Huschi, do you have any actual code showing that?
13:47:15 <meurvin> i am not aiming at anything specifically at the moment...just want to learn something
13:47:29 <Huschi> xerox: i'll paste it to the wiki.
13:47:37 <monochrom> then haskell. aim high, blow your mind.
13:47:45 <basti_> in temporal order: hp41c, different basic dialects, 6502 assembler, c, 80x86 assembler, scheme, prolog, haskell
13:47:48 <basti_> and some others.
13:47:55 <basti_> that i won't mention here.
13:48:07 <mauke> I started with O'Caml, which introduces concepts like (auto-)currying, type inference, pattern matching etc. but still lets you modify variables and do I/O
13:48:07 <xerox> I can't find that wiki page showing an intro by examples.
13:48:22 <basti_> ocaml is great but not for the faint of the heart
13:48:28 <meurvin> hmm...okay...
13:48:39 <monochrom> haskell isn't for the faint of the heart either
13:48:40 <Huschi> xerox: you meant me?
13:48:44 <basti_> but haskell is readable
13:48:47 <monochrom> but aim high, blow your mind
13:48:48 <meurvin> let me put it this way...what langaage will be the easiiest to start with
13:48:50 <basti_> ocaml is somewhat.... difficult
13:48:52 <xerox> Huschi, nope, I was searching it for meurvin
13:48:57 <skew> I think Haskell does the basic stuff like data types at least as cleanly as any functional language
13:49:04 <basti_> haskell is pretty tame in the lower levels
13:49:19 <xerox> @wiki HaskellDemo -- yow!
13:49:20 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo -- yow!
13:49:21 <skew> There are less annoying restrictions than O'Caml, for one
13:49:29 <meurvin> umm...i know a little lisp...dont know if thats helpful...?
13:49:45 <monochrom> I made some slides at http://www.cs.utoronto.ca/~trebla/fp/  I hope you'll find them useful.
13:49:55 <basti_> meurvin: probably
13:49:57 <basti_> in some way.
13:50:03 <basti_> you don't have to understand lambda anymore.
13:50:04 <mauke> I don't know, O'Caml was pretty easy coming from C and Perl
13:50:07 <meurvin> okay
13:50:26 <lightstep> basti_, what?
13:50:27 <skew> The complexity you get in Haskell is that people like to invent really fancy things from those basic tools
13:50:32 <Itkovian> I find haskell easier than Ocaml
13:50:38 <basti_> lightstep: ?
13:50:47 <meurvin> ahan
13:51:00 <Philippa> skew: I just had the mental image of somebody building an ivory tower, standing on top of it and pissing off the side ;-)
13:51:00 <lightstep> basti_, you don't have to understand lambda in ocaml in haskell? just 'cause it's spelled differently?
13:51:05 <basti_> huh?
13:51:16 <Huschi> xerox: it's in the wiki.
13:51:22 <basti_> lightstep: no, you dont have to learn "lambda", when you already know it from lisp
13:51:27 <lightstep> oh
13:51:39 <mauke> ... or perl
13:51:49 <meurvin> is haskell used by a specific sort of programmers only?
13:51:51 <metaperl_> what's the easiest way to get ghc6.4 for debian unstable?
13:52:00 <meurvin> does it have some sort of...um...concentration?
13:52:11 <shapr> metaperl_: deb http://haskell-unsafe.alioth.debian.org/archive/i386 unstable .
13:52:12 <basti_> meurvin: "a specific sort of programmers" is a nice wording for it yes.
13:52:13 <basti_> =)
13:52:30 <musasabi> Haskell is mostly for people who want good solutions.
13:52:31 <gzl> not in the sense of people only writing specific kinds of software, though.
13:52:36 <basti_> meurvin: it concentrates on being clean and as "basic" as possible i think
13:52:43 <meurvin> okay
13:52:57 <basti_> it's a good way of learning programming, i'm convinced meanwhile
13:53:00 <skew> It's very very good for making interpreters and compilers
13:53:02 <musasabi> Making dirty patchwork is easier with different languages, but haskell excels in clean solutions.
13:53:05 <Philippa> I don't know that's quite true, even Core Haskell has a couple of constructs you can go without if you ditch the type system ;-)
13:53:06 <basti_> and its very very terse and shorthand
13:53:39 <musasabi> but on the other hand that means that finding the right abstractions can be very important.
13:53:46 <meurvin> i have had experiance in c perl and such...
13:53:54 <basti_> its amazing what you can do with such a little code
13:53:59 <skew> I think for a long time it was mostly adopted by people exploring languages, but that's been changing
13:54:05 <basti_> @pugs map (*5) [1,2,3,4]
13:54:05 <mauke> do you know how to do closures in perl?
13:54:12 <lambdabot> [5,10,15,20]
13:54:17 <basti_> try that in c.
13:54:19 <basti_> ;)
13:54:37 <skew> int result[] = [5,10,15,20];
13:54:39 <rtega> hehe
13:54:43 * basti_ sighs
13:54:47 <meurvin> i know...as i interpret it...c is more of a 'group' language
13:54:54 <basti_> "group"?
13:55:00 <lightstep> how can i tell mozilla to show text/x-haskell in the browser window?
13:55:07 <Muad_Dibber> @pugs  take 5 (map (*5) [1..])
13:55:10 <lambdabot> [5,10,15,20,25]
13:55:14 <Muad_Dibber> try that in c :P
13:55:25 <Itkovian> if one uses group, does it produce intermediate results? I'd think so, but how can I be certain? I mean, does it deliver a group as soon as it finds a different element in the list?
13:55:29 <meurvin> developing larger software in groups is convinent in c...but i could be wrong
13:55:39 <basti_> oh
13:55:44 <basti_> large groups of people know c
13:55:45 <shapr> lightstep: change your mimetype settings
13:55:48 <basti_> that might explain that.
13:55:57 <Muad_Dibber> large groups of people also know java
13:56:01 <skew> meurvin: there are a lot of people working on pugs
13:56:02 <basti_> oh yes.
13:56:03 <meurvin> dont think it got thru
13:56:07 <shapr> large groups of people know Visual Basic
13:56:15 <skew> which is perl6 being implemented in Haskell, because there wasn't an implementation
13:56:43 <meurvin> skew: that is actually where i got the haskell refrence...but i am not sure what that is
13:56:50 <mauke> basti_: int times(int a, int b) { return a*b; } void iter(int (*f)(int), int *p, size_t n) { while (n--) p[n] = f(p[n]); } ... int arr[] = {1,2,3,4}; iter(wrap_vfunc(times, 5, sizeof 5), arr, 4);
13:57:09 <basti_> mauke: that looks... distinctive.
13:57:36 <basti_> meurvin: haskell is about programming concepts i think.
13:57:36 <mauke> wrap_vfunc is totally nonportable and leaks memory, of course
13:57:47 <mwc> Well, now that I'm on a GCC 4.0 system, I guess it's time to let GHC weep :(
13:57:50 <basti_> well but its a hell of a lot faster, i'm sure.
13:57:50 <basti_> :)
13:58:11 <meurvin> basti_: for learning programming you mean?
13:58:20 <basti_> meurvin: for example.
13:58:32 <xerox> @pugs let fib = 1:1:zipWith (+) fib (tail fib) in take 15 $ fib
13:58:33 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
13:58:34 <basti_> but at the same time it's not so slow that it'd be completely unusable.
13:58:43 <meurvin> ahan
13:59:07 <Muad_Dibber> haskell isnt that slow anymore is it?
13:59:15 <basti_> in fact, most problems can be solved so that they're fast enough, runtime-wise
13:59:18 <musasabi> gcc 4.0 does not automatically have performance benefits.
13:59:41 <shapr> Personally, I think that Haskell is the best language for speed of programming. Many people focus on other languages for speed of execution.
13:59:52 * basti_ nods
13:59:57 <basti_> which is so 90's
14:00:01 <meurvin> okay...another question...do lisp and haskell fall in the same grouping?
14:00:06 <basti_> haskell is lazy
14:00:08 <basti_> lisp isnt
14:00:17 <meurvin> ahan
14:00:20 <basti_> uhm
14:00:26 <lightstep> the style is very different
14:00:27 <Huschi> the results in the icfp affirm that haskell is fast in coding.
14:00:37 <meurvin> somehow i find lisp to be more intuitive...and i come from a c background...
14:00:38 <basti_> you can define an infinite list in haskell, for example
14:00:40 <Maddas> meurvin: There is no "official" grouping, but probably not
14:00:51 <astrolabe> I never programme anything that I don't wish ran faster.
14:00:53 <musasabi> shapr: actually as most people see things like python as alternatives then haskell *is* fast.
14:00:56 <mauke> lisp is dynamically typed, haskell is statically typed
14:01:08 <musasabi> of course most of the time speed is not a very large consern.
14:01:47 <skew> shapr: I've noticed that for a given amount of time a nicer language usually translates to better performance because you aren't afraid of implementing the efficient, complicated algorithm
14:02:26 <basti_> i think haskell ist fast enough for most things, and its a very elegant way of expressing programs
14:02:33 <basti_> "elegant" being a very subjective criterion
14:02:40 <Itkovian> I like the statical typing of haskell programs
14:02:47 <meurvin> hmm
14:03:00 <basti_> learning it would certainly widen your horizon
14:03:07 <astrolabe> Maybe it is that I code odd things, but run time always seems to limit me.
14:03:13 <tuomov> otoh, a language like C makes you favour the simplest solution, may sometimes be the good thing to do
14:03:16 <basti_> not only a few inches wide, like learning java does.
14:03:20 <tuomov> +which
14:03:43 <basti_> astrolabe: maybe you're focusing on "number crunching" things?
14:04:02 <astrolabe> basti: yeah, and tree search.
14:04:14 <basti_> haskell is definitely not good for the hot spots of any application. but for all the other parts (like the other 99%), it's perfectly suited. I think.
14:04:48 <meurvin> depends on how one defines hot spots...?
14:04:51 <basti_> astrolabe: you should maybe investigate the ffii, there were articles about it on TMR.
14:04:58 <shapr> Yes, I agree. The ability to quickly and easily change algorithm, abstraction, or the whole approach means you can often end up with faster programs.
14:05:00 <CosmicRay> anyone here have ghc6.4 and would be willing to tell me if the latest missingh in darcs compiles for them?
14:05:05 <basti_> meurvin: a hot spot would be where your application burns many cycles
14:05:09 <Itkovian> meurvin: the 10% of the code 90% of the time is spent in
14:05:27 <astrolabe> thanks basti.  I'll look
14:05:31 <musasabi> CosmicRay: I can test that.
14:05:59 <CosmicRay> musasabi: thanks.  please darcs get http://darcs.complete.org/missingh and just run "make"
14:06:03 * Spida is writing imperative code in haskell
14:06:06 <Spida> args
14:06:12 <lightstep> why?
14:06:16 <basti_> astrolabe: you would be able to export the "crunch" part of your application to some "really fast" language, and do the tendious bits in haskell
14:06:28 <basti_> astrolabe: lol i meant ffi.
14:06:33 <basti_> ffii is something different
14:06:48 <astrolabe> Ah :) google was having problems
14:06:51 <basti_> hehehe
14:06:56 <musasabi> CosmicRay: running it now.
14:07:01 <CosmicRay> musasabi: thanks much
14:07:01 <sylvan> I'm not convinced most application spend 90% of their time in 10% of the code... Aside from MPEG-encoders and that type of tools..
14:07:07 <basti_> i don't want to know what google turns up on ffii + haskell :P
14:07:20 <basti_> sylvan: many do.
14:07:21 <kaol> @google ffii haskell
14:07:23 <lambdabot> http://www.ffii.us/
14:07:34 <astrolabe> It sounds right to me sylvan
14:07:35 <Muad_Dibber> sylvan : try profiling :)
14:07:40 <sylvan> I have
14:07:53 <sylvan> I think that saying is old, and doesn't apply anymore in the way it used to
14:08:02 <basti_> even many "normal world" apps do
14:08:06 <Itkovian> sylvan: say 20 - 80 then. But it is correct.
14:08:06 <basti_> webbrowser
14:08:17 <Itkovian> still correct.
14:08:22 <astrolabe> Algorithms don't change much
14:08:30 <basti_> email client
14:08:31 <lightstep> Official Friends and Food International Addendum - i like the sound of that
14:08:53 <basti_> lol bizarre
14:09:08 <basti_> ffii is also the "f√∂rderverein f√ºr eine freie informationelle infrastruktur"
14:09:19 <basti_> thats how that happened
14:09:38 <shapr> sylvan: Do you know of specific application(s) that don't spend 90% of their time in 10% of the code?
14:09:45 <sylvan> Basically, when a program grows, it does so by adding more features (most often), so time is "spread out" quite a bit.. There may be some hot spot (like 10% or less of the code) that gets a disproportionately large amount of cpu-cycles (like 50% or something) but I don't think 10-90 or 20-80 (though it sound neat) is accurate anymore
14:10:18 <basti_> but still, the rule is that few lines get many cycles, and that's still an important observation
14:10:20 <sylvan> shapr: almost anything that isn't unix =)
14:10:34 <tuomov> most of the features aren't used at all..
14:10:34 <Oejet> Spida: Imperative code like in:
14:10:34 <basti_> it allows you to concentrate optimizing where you need to, and not where you're just wasting time
14:10:36 <shapr> In my experience, when a program grows you end up with an inner loop or event loop that takes most of the cycles.
14:10:38 <lightstep> big programs tend to implement greenspun's tenth rule, therefore the fetch-execute loop takes a lot of the time
14:10:41 <Oejet> @wiki ImperativeHaskell
14:10:43 <lambdabot> http://www.haskell.org/hawiki/ImperativeHaskell
14:11:34 <sylvan> shapr: most programs, at least on windows, are idle most of the time and when they do do something that something can be a variety of different things..
14:11:51 <tuomov> I'd dare to venture that Ion is an exception to this rule, although I have not profiled it..
14:12:11 <sylvan> unix programs usually do a much more specific task, there aren't as many "suites"
14:12:24 * shapr wants to see profiling data
14:12:39 <shapr> Actually, I have a bunch of Haskell code lying around, I can poll myself.
14:12:39 <xerox> Oejet, couldn't "if (i == 0) then return True else return False" be expressed as "return (i == 0)" ?
14:12:54 <Itkovian> sylvan: if they idle most of the time, then they need not be optimized.
14:12:58 <tuomov> If there is any hotspot, it is likely the lua vm
14:12:58 <basti_> of course the rule doesnt match as well in programs that have many tasks, and many hotspots.
14:13:01 <sylvan> If you look at all the code run by a user throughout a day (regardless of which program) I doubt that you're gonna see the same 4 rows in grep come up 90% of the time (because you don't use grep all that often)
14:13:04 <Itkovian> a wrong statement, well, not completely coreect, but you get the idea
14:13:08 <tuomov> but even it doesn't do much most of the time
14:13:12 <basti_> no holy wars about this question please
14:13:17 <Oejet> xerox: Sure, but then it would look as close to the pseudo code as possible.
14:13:25 <shapr> sylvan: What do you mean?
14:13:32 <basti_> holy wars are stupid, and lead to nothing.
14:13:47 <Itkovian> yeah
14:14:03 <sylvan> I mean that in windows you usually have one program that does a ton of things, whereas on unix you have one program for each task.. So on windows that rule doesn't really apply as much..
14:14:08 <Itkovian> but they allow us to procrastinate :-)
14:14:14 <sylvan> =)
14:14:17 <shapr> sylvan: oh I see.
14:14:29 <Itkovian> sylvan: ok, but then in each of the different parts the rule still applies
14:14:36 <basti_> we're having a perspective debate here
14:14:50 <xerox> Oejet, nice page :-)
14:15:05 <basti_> not one about facts
14:15:19 <sylvan> Itkovian: yep, but if you're going to choose 10% of the code across all of the apps you use on unix, you'd have trouble finding which 10% needed the most attention because they're spread out over so many different applications..
14:15:44 <shapr> For my income, I do webdev with Zope/Plone, and that does end up with most of the cycles concentrated in a very small percentage of the code.
14:15:46 <sylvan> So even if you find some part of "grep" which could do with optimizing, it's not worth the effort because the average user may only use grep 1% of their time
14:16:00 <astrolabe> Weird junk mail I'm getting.  Like something out of PKDick.
14:16:00 <Itkovian> sylvan: ah but you focus on the 10% in _each_ of the apps.
14:16:19 <basti_> you.are.having.a.perspective.debate.
14:16:20 <basti_> =)
14:16:24 * shapr grins
14:16:31 <Itkovian> sylvan: wrong. if the one job they use grep for takes a long time, it may be worthwile optimizing, if only to speed up that single task
14:16:37 <sylvan> Itkovian: ideally yes, but in "reality" that may not be a possibility
14:16:46 <shapr> sylvan: So, want to write a TMR3 article that profiles a bunch of different Haskell apps and discusses the results?
14:16:53 <sylvan> nope!
14:16:53 <basti_> if a program is too slow, you go and find where it is. it will be in a tiny portion of the whole.
14:16:54 <tuomov> reality=corporate software development?
14:17:15 <Oejet> shapr, sylvan: That would be so cool!
14:17:18 <basti_> shapr: is that your slaughter argument now? ;)
14:17:24 <shapr> slaughter argument?
14:17:29 <sylvan> true, I'm just saying that hotspot optimization isn't as gratifying as it used to be because a program may have hundreds of them and each one takes way to long for way too little reward
14:17:52 <basti_> shapr: that you use to slaughter all kinds of debates ;)
14:17:54 <Itkovian> what I have seen on x86 is that the ghc generated code usually has a very low IPC
14:18:02 <Itkovian> I mean _really_ low
14:18:03 <shapr> I think that if someone is strongly convinced about something, they should write it up. Then you don't have flamewars but instead reasoned debates.
14:18:12 <basti_> sylvan: if.one.app.is.slow.go.and.find.where.it.is.it.will.be.in.the.one.hotspot.
14:18:17 <Oejet> Itkovian: What does IPC mean?
14:18:26 <Itkovian> Instructions Per Cycle
14:18:27 <basti_> if your computer is responding laggy, consider choosing a different environment
14:18:29 <astrolabe> The "System idle process" seems to use 99% of my cycles.  If only someone would optimse that.
14:18:34 <shapr> IRC is more a verbal discussion medium, so people often don't define their assumptions.
14:18:37 <Itkovian> the true measurement of efficiency.
14:18:38 <shapr> astrolabe: haha
14:18:41 <sylvan> basti_: but "one app" on windows may have 100 hotspots and ALL of them contribute to the program being perceived as slow
14:18:54 <basti_> you mean as in sluggish
14:18:57 <sylvan> yep
14:19:00 <basti_> thats right yes.
14:19:02 <shapr> sylvan: want to write an article about this for TMR3?
14:19:06 <basti_> thats not a problem of computer science though
14:19:07 <Itkovian> sylvan: well, in reality that's not true
14:19:09 <sylvan> nope!
14:19:17 <Itkovian> real world apps do have hot code.
14:19:26 <sylvan> Itkovian: I think it is for a bunch of programs..
14:19:27 <basti_> thats more of a sociological problem i think ;)
14:19:28 <shapr> basti_: Yes, I'm getting close to the slaughter argument ;-)
14:19:30 <Itkovian> otherwise JVM's would fail utterly in their goals
14:19:42 <CosmicRay> Itkovian: wait, I thought they had? :-)
14:19:45 <sylvan> Like Office.. It does so many things there really isn't one part you can optimize and see any sort of respectable payoff
14:19:48 <Oejet> Itkovian: Any other processors have a higher IPC for GHC generated code?
14:20:04 <Itkovian> CosmicRay: nope, in fact the run-time optimisation is very good for long running apps.
14:20:06 <tuomov> a word processor most likely spends most of the time doing the layout
14:20:07 <shapr> Ok, you guys have established the difference in opinion, now let's see some profiling results or detailed write-ups, otherwise this discussion doesn't teach us anything.
14:20:14 <tuomov> so you want to optimise that
14:20:14 <Itkovian> Oejet: yeah, take C, java, ...
14:20:31 <tuomov> oh, well, word's output looks like shit..
14:20:39 <CosmicRay> Itkovian: was just a joke about java :-)
14:20:41 * basti_ is having a look for HaskellOffice
14:20:42 <sylvan> So basically: optimizing isn't that important anymore... few applications have that type of clear hotspots that can give you several hundred percent improvement with a few days of optimizing
14:20:52 <shapr> sylvan: write this up!
14:20:59 <shapr> I want numbers!
14:21:10 <sylvan> I don't have time!
14:21:12 <shapr> Especially because I won't believe you until I see some numbers =)
14:21:16 <tuomov> another hotspot in a word processor could be spelling correction
14:21:18 <xerox> Install it! <grin>
14:21:31 <Itkovian> However, it may be that the code simply uses very complex instructions
14:21:35 <basti_> nowadays word processors don't do ANYTHING useful in their time.
14:21:36 <skew> I've apparently lost the profile, but I think the biggest cost centre in pugs on a number crunching example was about 12%
14:21:45 <astrolabe> I think there is a distinction between batch type processes and interactive ones.
14:21:46 <lightstep> sylvan, that's only correct if you write big app suites (like office). if you use others' programs and libraries, you only need to optimize some code
14:21:54 <shapr> skew: That's interesting.
14:21:56 <tuomov> basti_: not useful, but they do some slightly intensive tasks
14:22:02 <basti_> tuomov: yes.
14:22:13 <basti_> but most of the results end up in nirvana.
14:22:21 <shapr> C'mon, I want to see real profiling data.
14:22:23 <skew> AST.hs should be done compiling in a few minutes and I can run it again
14:22:29 <shapr> skew: spiffy!
14:22:29 <sylvan> lightstep: that's basically my point.. On unix it's less true, but on windows applications tend to grow "horizontally".. Ie they don't do "same stuff more often" but rather "more stuff"..
14:22:44 <tuomov> most of which is useless
14:22:50 <shapr> sylvan: You could use this time to write it up on the wiki, and then we could write a reply.
14:22:54 * shapr grins evilly
14:23:04 <sylvan> bah.. sounds like an excuse to not do real work
14:23:05 <skew> on the TMR wiki even...
14:23:07 * Itkovian feels slaughter in the air
14:23:26 <astrolabe> hmmm not like irc then.
14:23:31 <sylvan> exactly
14:23:33 * shapr snickers
14:23:45 <shapr> IRC is so productive.
14:23:54 <sylvan> indeed
14:23:54 <basti_> oh yes
14:23:58 <skew> IRC is about getting valuable technical advice for collegues around the globe
14:24:02 <xerox> It is essentially a myth.
14:24:02 * Maddas coughs
14:24:05 <basti_> i've reworked emacs-yi 5 times now
14:24:16 <shapr> skew: Right, exactly.
14:24:18 <basti_> because i felt guilty facing you with that mess
14:24:25 <shapr> Is it a working mess?
14:24:26 <skew> actually *for* is maybe not so far off
14:24:36 <basti_> it's coming close to where i projected it to be.
14:24:51 * esap just wrote: fold_stack :: (forall f. f b -> b) -> Stack a -> b
14:24:57 <skew> okay, now it's on AST.hs with -prof in the options
14:24:59 <basti_> like, the point where it could be useful
14:25:31 <lightstep> esap, does it make sense?
14:25:42 <shapr> hei esap
14:25:49 <esap> lightstep: I think it does. fold_stack f (Frame x) = f (fmap (fold_stack f) x)
14:26:43 <lightstep> but a /= b ?
14:26:49 <lightstep> @type fmap
14:26:54 <lambdabot> fmap :: forall (f :: * -> *) b a.
14:26:54 <lambdabot>         (Functor f) =>
14:26:54 <lambdabot>         (a -> b) -> f a -> f b
14:27:40 <lightstep> it seems a=[f b] (if x is a list)
14:27:50 <esap> lightstep: yes. That's because date Stack a where { Frame :: (Functor f) => f (Stack a) -> Stack (f a) }
14:27:59 <esap> lightstep: s/date/data/
14:28:24 <lightstep> wow, gadts are funny
14:28:28 <bourbaki> hey esap
14:29:04 <esap> hey bourbaki!
14:29:47 <bourbaki> hows it going esap?
14:30:08 <esap> I've been busy trying to build too many things at once :-(
14:30:45 <esap> Like the OO lib, an article for TMR and the compiler.
14:30:47 * shapr knows that feeling
14:31:30 * Maddas resigned by not doing anything at all :-P
14:31:48 <bourbaki> esap your CT compiler?
14:31:59 * esap nods.
14:32:17 <skew> does ghc --make just keep sucking up more memory as it runs?
14:32:29 <bourbaki> i have been giveing up my idea so far
14:32:36 <CosmicRay> skew: shouldn't afaik
14:32:42 <bourbaki> just turned to something else
14:32:47 <CosmicRay> note that it can suck up a lot of memory for individual files
14:33:31 <skew> well, I just killed a run that was deep into swap on a particlar file, and when I restarted it finished that file without breaking 80% of physical memory
14:34:15 <shapr> weird
14:34:39 <skew> I think I need more RAM if I'm going to work on pugs much
14:34:49 <malcolm> ghc --make used to leak memory, but I thought it had been improved in 6.4
14:35:30 <stepcut> skew: heh, I had the problem recently, I had to upgrade from 128 to 640MB (thought I was compiling wash/cgi + haskelldb apps not pugs)
14:36:31 <lightstep> i tried to compile gtk2hs with 128MB of ram, it just overrode the video driver's memory (leading linux to crash)
14:36:35 <xerox> skew, it happened to me for pugs while ago, too.
14:36:47 <malcolm> but as you say, restarting helps, because the already-compiled files don't waste memory
14:36:54 <skew> okay, largest cost center on the mandelbrot example was "op2Numeric", at 13%
14:37:56 <malcolm> Using 'hmake' in preference to 'ghc --make' might help space usage...
14:40:05 <skew> you have to get pretty far up the call tree to find anything that takes much more than that
14:41:40 <Itkovian> sorry, was afk
14:48:14 <astrolabe> skew:  I guess it depends on how you partition the code
14:49:09 <astrolabe> I've got a signal processing algorithm at work, and most of the time it is doing an FFT, but if I looked inside the fft...
14:49:16 * Spida is not sure if he is following the idea of haskell when he implements a global boolean variable by using two different functions recursively: iterator_variable_true ans iterator_variable_false
14:49:21 <Spida> *g*
14:49:43 <Heffalump> you could at least pass it as a parameter :-)
14:50:25 <Spida> I did THAT with 3 arrays
14:50:29 <Spida> *g*
14:50:54 <lightstep> who is "he"?
14:51:06 <Spida> but the program seems to do what it should do, so all is fine
14:51:09 * Spida is he
14:51:22 * Spida himself
14:51:26 <lightstep> oh
14:51:28 <Spida> *g*
14:51:33 <lightstep> too late here
14:51:45 <Spida> lightstep: where?
14:52:28 <basti_> was that asterix parody? ;)
14:52:29 <lightstep> UTC+2 or 3
14:52:33 <lightstep> 1am
14:55:30 <shapr> hiya pesco
14:55:38 <pesco> Hey shapr.
14:56:01 * pesco shivers on all the feedback about ETC. I just got back online.
14:56:13 <basti_> etc?
14:56:18 <pesco> ECT. :)
14:56:33 <pesco> Ah, fsck it.
14:56:39 * pesco opens the first mali.
14:56:40 <pesco> mail.
14:57:11 <pesco> Phew. Not a flame. :)
14:57:17 <Itkovian> hmm ... I hope they don't complain about yr typing skills :-)
14:57:25 <pesco> Heheh.
14:57:52 <pesco> I don't worry about that. I tend to pay good attention. I'm just tired now.
14:58:45 * esap refined the fold_stack to type: (forall f. (Functor f) => f b -> b) -> Stack a -> b. This might be actually useful...
14:59:02 <pesco> Oh, nice sig quote, Philippa.
15:00:51 <pesco> Woohoo, none of them said "Your article is total bullshit - YOU SUCK"!
15:00:56 * pesco dances the happy dance.
15:01:19 <Muad_Dibber> what article? :)
15:01:30 <pesco> "Eternal Compatibility in Theory"
15:02:06 <pesco> See http://haskell.org/tmrwiki/IssueTwo.
15:03:42 <shapr> Yargh, I found an SPJ paper that discusses AOP and FP together. Why have I never seen this before?? Dammit, where's SPJ's discography?
15:04:18 <Itkovian> grmbl ... map length $ group $ f doesn't seems to yield results, even when the first lengths are small, and length x is large, erm huge
15:04:29 <sylvan> Someone referred to Philip Wadler as Philip "Judas" Wadler today... heh..
15:04:34 <Muad_Dibber> well shapr : i did once in  a way :P
15:04:37 <sylvan> (w.r.t. links)
15:05:02 * Oejet does the "Linus---just press apply on patches" dance.
15:05:08 <shapr> Muad_Dibber: you did once what?
15:05:33 <Muad_Dibber> discuss AOP and FP together :P
15:05:45 <Muad_Dibber> aalthough i'm not sure i was talking about what you mean right now
15:05:48 <Itkovian> maybe I will have to resort to perl
15:05:51 <shapr> sylvan: I think Wadler has a clue, the mainstream really needs the great things the FP researchers have found.
15:06:03 <shapr> Itkovian: what are you doing?
15:06:13 <Itkovian> dumb stuff prolly
15:06:20 <Itkovian> this is the line:
15:06:25 <sylvan> Yeah I think Links looks good too, but I can't find any good info on it.. He just felt that we needed more help with HSP and not more competition, or something =)
15:06:41 <Itkovian> shapr: putStr $ show $ take 22 $ map length $  group $ process $ contents
15:07:04 <Itkovian> where contents is gotten like contents <- hGetContents file
15:07:34 <Itkovian> process simply turns the string into a [T]
15:07:35 <shapr> sylvan: Oh, was it nibro_afk who said that? :-)
15:07:44 <sylvan> hehe, nope! I'm not telling!
15:07:45 <Itkovian> but I'd excpect it to work completely lazily.
15:08:09 <Itkovian> Been breaking my head over it for three days
15:08:14 <shapr> sylvan: Anyway, HaskellDB will be very hard to beat.
15:10:04 <sylvan> Yeah, next fall ther's a 3rd year project that are going to integrate it with HSP
15:12:43 <shapr> Personally, I think the best solution for client side code generation is to write a simple scheme interpreter and generate scheme code the way HaskellDB generates SQL.
15:12:52 <sylvan> anyone have a more in-depth look at Links (more in-depth than the slides on Wadler's homepage)?
15:13:20 <stepcut> hrm, I am build gcc, and all the tests are failing, I wonder if that is normal :-/
15:13:34 <shapr> I thought he had several docs on his site about it.
15:13:53 <sylvan> I found some slides and an "intro" paper that's like 5 pages long
15:15:15 <thou> morning
15:15:20 <shapr> g'day
15:19:06 <SyntaxNinja> lalala
15:20:03 <Itkovian> night
15:27:26 <shapr> Well, this SPJ paper makes some interesting points about AOP.
15:32:00 <a5> aop?
15:32:13 <Muad_Dibber> aspect oriented programming
15:32:13 <shapr> Can I use the polyvariadic args trick to fake trex?
15:32:58 <a5> Maud_Dibber: thanks. shapr: which paper?
15:35:03 <shapr> http://lambda-the-ultimate.org/classic/message3091.html
15:35:16 <reffie> http://www.pointless.nl/~peter/stuff/supercoder.jpeg
15:37:02 <shapr> As far as I know, Hugs is the only Haskell implementation that supports trex, and I'd much rather use GHC.
15:38:39 <stepcut> reffie: haha
15:44:06 <Lemmih> Personal breakthrough! I've signed and verified a file. (:
15:45:28 <pesco> Ooh, a cabal package?
15:45:49 <Oejet> Great, now you just have to convince us that it really is you who said that. :-P
15:46:00 <Lemmih> Cabal-get actually.
15:47:01 <Lemmih> Gonna start working on cabal-put unless SyntaxNinja thinks otherwise.
15:47:43 <pesco> What's the relation of cabal-get and cabal-put to Hackage?
15:47:54 <SyntaxNinja> Lemmih: I still think that the HTML interface is higher priority
15:48:08 <SyntaxNinja> pesco: cabal-put would sign and upload a package
15:48:16 <Lemmih> And you still haven't said what's wrong with the HTML interface (:
15:48:23 <SyntaxNinja> pesco: instead of doing it over the web
15:48:25 <SyntaxNinja> Lemmih: oh, does it work now?
15:48:29 <Lemmih> Yes.
15:48:31 <pesco> SyntaxNinja: To a Hackage server, I take it.
15:48:34 <SyntaxNinja> pesco: yeah
15:48:38 <pesco> Cool.
15:48:52 <SyntaxNinja> pesco: this is all my brilliant idea, actually. all of it. stolen fair and square from Debian ;)
15:49:01 <pesco> Hahaha.
15:49:15 <SyntaxNinja> but Lemmih is doing all the hacking
15:49:27 <pesco> Harharhar.
15:50:15 <SyntaxNinja> Lemmih: I think we're just waiting on DNS for the server, btw
15:51:38 <Lemmih> Btw, did you guys understand that google-as-cabal-packages-listing mail?
15:52:01 <Lemmih> From DimitryG some hours ago.
15:56:56 <Oejet> Yes, you have the name of some package (e.g. from a dependency list) and you want to fetch it from somewhere.  Then you just ask Google where it is.
15:57:51 <Lemmih> Isn't that what HackageDB should do?
15:59:13 <pesco> Yes.
15:59:48 <pesco> But it is an observation that we could also auto-abuse Google.
15:59:57 <pesco> Maybe as a fall-back for cabal-get ;)
16:00:56 <SyntaxNinja> it wouldn't be easy to spam if we implement apt-secure-like signing!
16:01:36 <skew> I just had an idea to make an interpreter that would remember what code you typed in contributed to which values, so you could get something working in an intepreter and export it
16:01:40 <Igloo> Eek, please don't fall back to that by default
16:01:55 <pesco> Why not?
16:02:04 <SyntaxNinja> Igloo: the whole earth is a wiki, get used to it ;)
16:02:12 <Igloo> Because I don't want the old, broken version that google happens to find first
16:02:51 <pesco> Proper dependency tracking required.
16:03:03 <skew> probably more useful for something like ruby where you're building objects and redefining their methods independently, but still neat
16:05:53 <thou> skew: i bet people would find plenty of uses for it
16:06:35 <pesco> Maybe we should think about deprecating dependencies without a version annotation.
16:06:42 <pesco> It's not that hard to look those up.
16:06:52 <pesco> Harder to know when to bump them up of course...
16:07:28 <pesco> But I need to go to bed.
16:07:38 <pesco> Good night, #haskell!
16:08:06 <Lemmih> Night, pesco.
16:17:40 <putter> I would like advice on avoiding gc under ghc rts. (I'm sidestepping a ghc 6.4 gc bug).  +RTS -A600M works, but is there is an easier way...?
16:18:33 <liquidengineer> hello, Haskell Gods.  I come forth in supplication.
16:18:50 <SyntaxNinja> liquidengineer: proceed, but proceed with caution
16:19:17 <liquidengineer> I actually have a question about Fields
16:19:20 * thou gives liquidengineer some bones to roll
16:19:46 <liquidengineer> Say I have a Field with seven possible elements, created by mod'ing the results of add, sub, mult, and inverse
16:20:30 <liquidengineer> I'm using this list comprension to give the invs of a Feild element
16:20:52 <liquidengineer> invs (F z) = head [F x | x<-[1..6],((x*z ) `mod` 7) == 1]
16:21:13 <liquidengineer> it craps out whenever I try to take the invs of field element 7
16:21:33 <liquidengineer> it should be 1 to 6, shouldn't i?
16:21:34 <liquidengineer> it?
16:21:43 <liquidengineer> err.. 1..7
16:22:00 <Cale> 1..6
16:22:09 <Cale> later, must run
16:22:14 <liquidengineer> oh
16:22:17 <liquidengineer> it's right the way it is?
16:22:19 <liquidengineer> damn it
16:22:27 <skew> 7=0 mod 7
16:22:29 <skew> no inverse
16:23:41 <liquidengineer> skew: this is ungood
16:23:52 <liquidengineer> I've got polynomials represented by lists of Field elements
16:23:58 <skew> you can't make a field of 8 elements...
16:24:06 <liquidengineer> I don't want to
16:24:10 <liquidengineer> I want to do this
16:24:13 <liquidengineer> [last a <*> invs (last b)]
16:24:20 <liquidengineer> where a and b are my lists of Flds
16:24:25 <liquidengineer> but last b is a 7
16:24:31 <liquidengineer> so it royally screws it up
16:24:38 <liquidengineer> a need to divide last a by last b
16:24:57 <skew> why is the last b 7?
16:26:00 <skew> that's trying to divide by zero
16:26:21 <skew> <*> is your field multiplication?
16:26:49 <liquidengineer> yeah
16:26:55 <liquidengineer> that's multiplication
16:27:05 <liquidengineer> it's seven because that's the end of hte test polynomial g I was given
16:27:28 <skew> oh, you need to write your polynomial division to handle zero terms then
16:28:07 <skew> you might want to get the inverse with a GCD algorithm rather than exhaustive search if you start working in bigger fields
16:28:22 <liquidengineer> my polyDiv function can handle division by zero, it just prints out an error
16:28:31 <liquidengineer> the invs function totally frells up, though
16:29:38 <liquidengineer> Program error: {head []}
16:29:38 <liquidengineer> invs (F 7)
16:30:11 <skew> yeah, you get an empty list and try to take the head
16:30:22 <liquidengineer> exactly
16:30:50 <skew> you could make your polynomial division function mod by 7 before it checks for zero
16:31:21 <liquidengineer> Is having a seven in a polynomial in this field illegal behavior
16:31:22 <liquidengineer> ?
16:31:36 <skew> your field is integers mod 7
16:31:43 <skew> so 7 means the same thing as 0
16:31:50 <skew> and -7, and 14, etc
16:32:24 <liquidengineer> okay
16:32:30 <liquidengineer> that makes sense
16:32:39 <liquidengineer> so I should be able to define a field element F 7
16:32:51 <skew> it just means the same thing as F 0
16:33:27 <liquidengineer> okay.  That makes sense
16:34:25 <liquidengineer> so how do I divide F 8 by F 7?
16:34:37 <skew> how would you divide F 1 by F 0?
16:34:41 <liquidengineer> I can't, can I?
16:35:27 <liquidengineer> and f 'div' g does mean f/g, correct?
16:35:54 <skew> it rounds to get an integer out, but yes
16:36:01 <dons> @plugs 5 `div` 2
16:36:07 <lambdabot> 2
16:36:16 <dons> bot is a bit sleepy.
16:36:23 <dons> @plugs 10 `div` 4
16:36:25 <lambdabot> 2
16:36:45 <liquidengineer> so....if he wants us to divide sample f by sample g
16:37:01 <liquidengineer> sample g must be screwed up
16:37:17 <dons> @plugs 5 / 2
16:37:17 <skew> not necessarily
16:37:18 <lambdabot> 2.5
16:37:35 <skew> x^3+x^2+x can be divided just fine by x+0
16:38:11 <liquidengineer> coincidentially, I'm storing my polys in ascending power order
16:39:06 <skew> leading 0 terms should be even less trouble
16:39:17 <skew> why don't you just filter them out?
16:39:40 <a5> skew: who can't make a field of 8 elements?
16:39:53 <skew> well, you can't do it as integers mod a prime
16:40:04 <skew> and certainly not as integers mod 7
16:40:27 <Oejet> dons: lambdabot is not very "portable" to other channels.  Do you accept patches which makes lambdabot less #haskell centered?
16:41:00 <liquidengineer> most of my functions look like this
16:41:01 <liquidengineer> polyAdd (a:as) (b:bs) = stdz ( (a <+> b):(polyAdd as bs) )
16:41:10 <liquidengineer> where standardize eats zeroes off the end of a list
16:41:27 <dons> Oejet, not portable?
16:41:33 <liquidengineer> polyDiv doesn't do that
16:42:16 <liquidengineer> come to think of it, it's the only algebraic operation that doesn't eat leading zeroes on the result
16:42:40 <liquidengineer> still...I don't think that's the problem.
16:42:57 <liquidengineer> it's the division of individual terms that's mucked up
16:43:02 <blackdog> Oejet: you only have to change Config.hs. I put algaebot up on #algtop in about 2 minutes hacking.
16:43:08 <Oejet> I mean, I tried to get lambdabot running in another channel on another server.  I wasn't very successful.  At least it takes a recompile.  How about reading a configuration file at startup?
16:43:22 <dons> yes. that would be fine.
16:43:42 <liquidengineer> skew: mind if I show you my div function?
16:43:47 <dons> i partially started in this direction with the Config type.
16:44:02 <skew> oh, it's not just the normal integer div?
16:44:05 <dons> the next step is to make it readable. or use hs-plugins to dyn load config data.
16:44:14 <dons> a patch to read it at startup would be most welcome.
16:44:23 <Oejet> blackdog: Ah, I think, I did the same as you.  But most of the plugins didn't work, e.g. dictionaries, plugs,...
16:44:41 <dons> dictionaries?/ hmm..
16:44:47 <blackdog> really? That's surprising. then again, i only tested @vixen. :)
16:44:59 <dons> plugs requries the RunPlugs script in scripts/ to be installed
16:45:00 * blackdog is absurdly self-centred
16:45:10 <dons> a couple of others use external tools too, @timein for example
16:45:22 <dons> perhaps you need to edti the proxy settings?
16:45:54 <dons> I run lambdabot in another channel quite fine, fwiw. On a different machine to #haskell's bot.
16:46:22 <dons> if you document what plugins don't appear   to work, I can clarify the environment they require
16:46:56 <dons> and @spell requires aspell to be installed. @type/@kind need ghci-6.4
16:47:51 <Oejet> Yes, that would be nice.  For example I don't know how to install what is in scripts/.  Maybe compiling/chmod and put in PATH is enough?
16:48:17 <Oejet> But it will not be now.
16:48:41 <dons> timein can just be dumped in the path somewhere. RunPlugs needs to be compiled against hs-plugins, and must be compiled with 6.2.2. then just dumped in $PATH
16:50:09 <Oejet> Ok, thanks. Time for sleep.
16:50:17 <dons> time for breakfast!
16:50:25 <Oejet> :-P
16:50:37 * dons hunts for the coffee
16:54:23 <stepcut> @coffee
16:54:24 <lambdabot> Unknown command, try @listcommands.
16:57:45 <kaol> @cow
16:57:48 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!
16:57:48 <lambdabot> !
17:00:47 <putter> so... no suggestions on avoiding gc other than by using +RTS -A<lots of memory> ?
17:01:19 <dcoutts> putter, you mean +RTS -M<lots of memory>
17:01:32 <dcoutts> and indeed -H
17:05:32 <putter> my understanding is -M sets the maximum heap size, which doesn't seem to help here.  yes?
17:06:07 <putter> I tried -H, but got better results with -A (though I am sufficiently disorganized at the moment that I cant say what the test case was).
17:06:28 <dcoutts> well a large heap means fewer collections
17:07:23 <dcoutts> or rather less frequent collections since you can let garbage pile up for longer before having to clean up
17:08:41 <putter> yes, completely avoiding gc is the objective.  to gc is to die.
17:10:16 * putter regrets there doesn't seem to be a --no-gc switch.
17:12:42 <putter> ah well.  thanks for your help.
17:13:40 <dcoutts> well you can't avoid gc entriely, you might be able to avoid major gc collections, minor gc collections are however completely unavoidable unless you never allocate or run for a very short time
17:16:20 <mwc> Yay! My Haskell book just arrived
17:18:51 <mwc> I guess we find out if Hugs can be built by GCC 4.0 :P
17:21:29 <hellish> Will the problem where I spend long periods of time finding solutions to non-existant problems before realizing that the problems are non-existant go away with time?
17:21:47 <blackdog> hellish: that's a problem you'll have to solve
17:22:10 <hellish> kick myself every time?
17:22:13 <hellish> I've tried that.
17:22:19 <mwc> hellish: knowing the difference requires knowing the answers
17:22:32 <mwc> hellish: your best bet is to spend 20 years in a tibetan monestary
17:23:07 <hellish> Ah. Know of any good monestaries, then?
17:23:58 <mwc> Nah, I follow the Tao myself
17:24:21 <mwc> "The only true solutions are those to the problems unasked."
17:24:44 <putter> dcoutts: ah, two flavors of gc?  major and minor?  my at-the-moment (very) fuzzy understanding/recollection is that I am experiencing a bug in ghc's compacting gc.
17:25:10 * hellish ponders mwc's quote.
17:25:54 <putter> can one affect the two separately?  I would ideally like to do something more subtle than -A'ing a 1GB heap.
17:26:51 <dcoutts> putter, are you using amd64 ?
17:28:09 <dcoutts> ghc-6.4 on amd64 has a bug in the compacting gc
17:29:45 <dcoutts> since ghc uses generational garbage collection you get collections of the young (small) generation relatively frequently, then less frequently you get collections of the older generation(s) (by default there are only two generations)
17:29:58 <putter> dcoutts: yes.  said to be fixed in HEAD and upcomming 6.4.1, but I haven't tested that.
17:30:34 <dcoutts> you only end up using the compacting gc if you start running low on heap space, hence the option you want to set is a large -M value
17:31:24 <dcoutts> the -A and -H options will not make any difference to whether compacting gc is used
17:31:58 <putter> -M?  the man page suggests -M defaults to "unlimited".  is an explicit -M<large> better?
17:34:01 <dcoutts> probably not, I'm not actually sure if without any -M option there is any kind of auto-regulation so the rts doesn't use up all available ram (my experience would suggest not)
17:34:26 <putter> hmm.  -M doesn't seem to help.  nor -H.  but -A does.
17:34:48 <blackdog> putter: you could use jhc. it doesn't have gc at all. :)
17:34:58 <dcoutts> if you are using 100's of Mb already and still getting compacting gc kick in you're probably stuffed
17:35:26 <putter> blackdog: ;)
17:35:29 <dcoutts> have to run ghc in 32bit more or update to the latest cvs version in the ghc-6-4-branch
17:35:42 <dcoutts> more/mode
17:36:51 <blackdog> so you're trying to avoid gc because there's a bug in the collector, or because you're trying to do some kind of realtime thingamebob?
17:37:57 <putter> dcoutts: right.  ok, then I guess I know where I am at.
17:38:09 <putter> blackdog: bug
17:46:01 <putter> dcoutts: thanks.  unfortunately the context is pugs, so while building from cvs might fix things for me, in general it is rather a barrier to entry.
17:46:14 <dcoutts> yes of course
17:46:17 <putter> using 32bit could be worth exploring though.
17:46:40 <dcoutts> I hear it works fine, I've never tried setting it up however
17:53:59 <putter> ok.  my thanks for your help.
17:54:42 <shapr> "I can't think of any other case where two different programming language cultures literally at the opposite sides of the universe have come together like this." from http://cooking-with-lisp.blogspot.com/2005/04/haskell-and-perl-community.html
17:56:11 <blackdog> there are a lot of orthogonal axes there. i think they're both at the right end of the 'not stupid and tedious' axis, for instance\
17:57:53 <shapr> Yeah, I agree with that.
17:57:54 <Pseudonym> I don't think that the Haskell and Perl communities really are on opposite sides of the universe.
17:58:14 <shapr> From the perspective of Common Lisp it may appear so.
17:58:20 <Pseudonym> Well, perhaps, yes.
17:58:39 <Pseudonym> But the thing is, Haskell has FINALLY developed a community of people who Want To Get Things Done(tm).
17:58:45 <blackdog> well, if perl is lisp on acid, then haskell is just lisp in leather and chains
17:59:00 <Pseudonym> And it's also developed a set of features (-fglasgow-exts) which give you More Than One Way To Do It(tm).
17:59:30 <Pseudonym> And Perl, on the other hand, has started taking theory seriously.
17:59:33 <Pseudonym> Well, semi-seriously.
17:59:52 <blackdog> how so?
18:00:04 <shapr> Look at Perl6
18:00:07 <Pseudonym> Right.
18:00:12 <shapr> currying, infinite lists, etc
18:00:21 <Pseudonym> Perl 6 is much more like a real programming language rather than a bunch of awk extensions.
18:00:29 <dons> Are the communities really cross-fertilizing though? Or is it actually just one way (Perl is getting more Haskellish)
18:00:52 <blackdog> dons: i dunno... some silly bugger is working on extensions to ghc to make dynamic behaviour easier. :P
18:01:04 <shapr> Well, the Perl6 guys found several GHC bugs, and they definitely made a lot of interesting points about learning Haskell.
18:01:05 <dons> hehehaha
18:01:20 <dons> shapr, true.
18:01:29 <Pseudonym> I don't think that Perl is fertilising Haskell from a language point of view, but it IS from a sociological point of view.
18:01:35 <shapr> Right
18:01:37 <dons> yep.
18:01:40 <Pseudonym> In that the Haskell community is taking cues from the Perl community.
18:02:26 <dons> I'd like a t-shirt: "Does your favourite language look like Haskell yet?"
18:02:41 <Pseudonym> Haskell and Perl are very common in all ways except those ways which are of interest to LtU.
18:03:15 * hellish prays no Haskell gold competitions start.
18:03:16 <shapr> My dream is that GHC continues to be a vehicle for bleeding edge research like GADTs, STM, etc and at the same time is stable enough to be used for commercial apps. If the Haskell culture stays the way it is now, that's likely.
18:03:25 <Pseudonym> It helps that Haskell has finally got a couple of killer apps.
18:03:27 <hellish> s/gold/golf
18:03:29 <blackdog> hellish: do you mean golf?
18:03:34 <Pseudonym> (And no, lambdabot is NOT one of them!)
18:03:35 <blackdog> there's already the IOHCC
18:03:40 <dons> lambdabot!
18:03:50 <Pseudonym> I'm thinking of darcs and Pugs.
18:03:53 <shapr> Right, it's about time for the SSZ IOHCC, isn't it?
18:04:24 <reffie> i think i'm in love
18:04:28 <dons> uh oh. maybe there should be a special category for perl hackers who enter
18:04:41 <blackdog> reffie: who's the lucky girl/boy/goat?
18:04:45 * shapr laughs
18:04:50 * Pseudonym laughs
18:04:51 <reffie> this chick
18:04:58 <Pseudonym> Or is it a programming language?
18:05:09 <hellish> or is it vi?
18:05:19 <blackdog> not even a mother could love vi
18:05:21 <Pseudonym> "chick"... sounds like some kind of fowl.
18:05:32 <Pseudonym> I propose this slogan:
18:05:38 <Pseudonym> "VI: At least it's not ed."
18:05:53 <shapr> I swear, I gotta visit XXXX and absorb the humor.
18:06:05 <Pseudonym> XXXX?  You mean the Queensland beer?
18:06:30 <dons> 4-X land?
18:06:34 <shapr> Nah, it's the Terry Pratchett name for .au
18:06:39 <blackdog> shapr: if you're equating australia with that watery horsepiss, you're about to be invited outside.
18:06:48 <blackdog> 'scuse my klatchian
18:06:49 <Pseudonym> Yeah, he took the name from the beer that Queenslanders drink.
18:06:52 * shapr grins
18:07:03 <Pseudonym> http://www.xxxx.com.au/
18:07:25 <Pseudonym> XXXX: Because Queenslanders can't spell "beer".
18:07:28 <shapr> Never tried it. Foster's ok though.
18:07:32 <dons> hah
18:07:54 <Pseudonym> shapr: You think Foster's is okay?
18:07:55 <blackdog> perhaps they have a different brand of fosters overseas.
18:07:57 <shapr> At least, those two liter cans mean you don't need to go up to the bar so often.
18:08:01 <Pseudonym> Man, you HAVE been drinking bad beer.
18:08:24 <blackdog> here, fosters is the canonical beer that aussies don't drink that foreigners think is quintessentially australian
18:08:26 <shapr> Actually, I rarely drink, so all of it tastes like rotten plants anyway.
18:08:28 <Pseudonym> Oh, I forgot that you were in Scandinavia, not Belgium.
18:08:47 <shapr> But then, I don't drink either beer or coffee for the taste.
18:09:10 <Pseudonym> My wife isn't much of a beer drinker at all.  Especially couldn't stand US beers.
18:09:17 <Pseudonym> But she's developed a taste for Boag's Premium.
18:09:23 <Pseudonym> So if you want to try an Australian beer, try that one.
18:09:25 <blackdog> Belgian beer is pretty good. 'cept stella artois.
18:09:35 <shapr> What about Hoegaarden?
18:09:44 <blackdog> hoegaarden is awesome.
18:09:45 <Pseudonym> blackdog: Much like Foster's, Stella Artois is what they flog to foreigners.
18:10:03 <putter> what happens long-term to Inline::Haskell.  On pugs, its fine.  But once perl6 is bootstrapped on to something else, there is the usual Inline::Foo problem.
18:10:11 <blackdog> if any of you come by sydney, remember to check out the redoak beer cafe.
18:11:00 <putter> Window's folks dont have the ghc rts, so perl6 folks are disuaded from using Inline::Haskell in things which need to be portable.
18:11:20 <shapr> Why doesn't win32 have the rts?
18:11:30 <shapr> hs-plugins?
18:11:34 <dons> doesn't Inline::Haskell use hs-plugins?
18:11:44 <putter> I wonder if a ghc rts CPAN module might be created?
18:12:00 <dons> it's not to do with the rts
18:12:08 <dons> hs-plugins hasn't been ported to windows.
18:12:14 <shapr> This is the first time in several years I've actually wanted to have a copy of windows handy.
18:12:16 <dcoutts> ghc rts is just C code, it could probably be seperated into a shared lib
18:12:19 <dons> we almost got it working on cygwin this weekend.
18:12:38 <shapr> neat!
18:12:47 <dons> so if any perl hacker wants to grab the darcs repo of hs-plugins, try  to build it on windows, and send me the log, that'd be cool
18:13:20 * shapr looks at putter 
18:13:29 <dons> it actually builds and runs some things, like eval, on cygwin I think.
18:13:34 <blackdog> dons: a thought: cse has some copies of vmware. I'm sure you could get a licence...
18:13:39 <dons> ah!
18:13:50 <dons> but do I want to do that.
18:14:11 <dons> (install ghc on windows. hurting myself in the process, I'm sure)
18:14:15 * putter looks over sholder.  wouldn't know what to do with a windows box.  hmm, door jam...
18:14:18 <shapr> yrlnry: hey, are *you* Mark Jason Dominus?
18:14:26 <blackdog> uh, that's more or less up to you. But presumably it means you could script builds as well... dunno how hard it is.
18:14:45 <dons> it's a good point though, blackdog
18:15:19 <blackdog> dons: it always annoyed me that the only people who got stuff at cse were the complainy ones. tell chak to ask SS for more stuff, they love him to bits because he never asks stupid questions.
18:15:37 <shapr> I gotta admit, it must be nice to work with chak.
18:15:46 <dons> ok! i'd like more stuff.
18:15:52 <shapr> I bet he's demanding but about as far away from a PHB as you can get.
18:16:14 <dons> I remember we used to deal with them a fair bit when setting up the cluster
18:16:42 <Pseudonym> Actually, you could put the evil mangler in a CPAN module.
18:16:42 <shapr> I remember having to explain OOP to one of my former bosses in COBOL terms, since that was his most recent experience with programming.
18:17:25 <putter> the problem with Inline is having requirements that users (crippled compiler-free windows) dont match.
18:17:47 <shapr> I think Inline::Haskell will only require pugs and ghc, right?
18:18:01 <blackdog> putter: how does Inline work? Does it need both the compiler and the runtime environment?
18:18:21 <putter> if using Inline::Haskell requires anything of users other than mumble CPAN, then developers will tend not to use it.
18:18:39 <dons> afaik, it needs hs-plugins linked into pugs, and ghc sitting on the box to do the compilation
18:18:43 <shapr> It'll require a Haskell compiler.
18:19:29 <dons> just like you'd need to install guile/lisp/scheme/blah if you wanted to embed them in your app
18:20:06 <putter> shapr: ?  "pugs and ghc" seems plausible.  I'm wondering what happens next, when running perl6 doesnt necessarily mean you're using pugs.
18:20:31 <dons> I think autrijus already knows how to call hs-plugins over the ffi
18:20:46 <dons> so it wouldn't matter. you'd need ghc installed, and the haskell libs
18:21:35 <shapr> putter: In that case, it wouldn't work unless ghc was linked into the  underlying layer, Parrot or whatever.
18:21:41 <shapr> Greetings JohnMeacham
18:21:44 <shapr> How's code?
18:21:49 <JohnMeacham> shapr: greetings!
18:22:00 <JohnMeacham> shapr: code is good times
18:22:04 <CosmicRay> can anyone tell me why this cabal file works with cabal 0.5 but not with the cabal in ghc 6.4:
18:22:06 <CosmicRay> http://darcs.complete.org/arch2darcs/arch2darcs.cabal
18:22:16 <shapr> Btw, a5 mentioned that you also sleep better with meds? Any interesting details there?
18:22:20 <CosmicRay> Apparnetly it is saying: Error: Non-empty library, but empty exposed modules list. Cabal may not
18:22:20 <CosmicRay> build this library correctly
18:22:50 <JohnMeacham> shapr: ambien is fun with alcohol. but don't tell your doctor that or he won't prescribe it.
18:22:58 <shapr> CosmicRay: I think you need an ExposedModules: field, or something like that.
18:23:15 <CosmicRay> shapr: except I really want to only build a binary
18:23:25 <CosmicRay> I don't really want to expose any modules
18:23:38 <JohnMeacham> Although, my current job lets me set my own hours so I have just been letting my schedule freewheel.
18:24:04 <blackdog> JohnMeacham: what does ambien + alcohol do?
18:24:05 <shapr> JohnMeacham: All methylphenidate or amphetamines derivatives are exciting with alcohol. I still can't really get drunk though.
18:24:19 <JohnMeacham> makes you hallucinate something mad.
18:24:20 <dons> CosmicRay, a library that exports no functions? how do you use it?
18:24:24 <putter> blackdog: usually yes.  but "Inline" is a fuzzy/family label.  can include "developer includes compiled version so you only need compiler if you edit".
18:24:34 <CosmicRay> dons: I'm not trying to build a library, I'm just trying to build an arch2darcs binary
18:24:37 <shapr> Oh, not that exciting.
18:25:12 <dons> hmm. not sure then. it looks like there's a package.conf involved though.
18:25:31 <CosmicRay> hmm.
18:25:31 <dons> maybe just exporting Main would work.
18:25:45 <dons> maybe some  other magic is at work, however.
18:25:47 <shapr> JohnMeacham: btw, any observations on schedule freewheeling? I tend to sleep about nine times in ten days.
18:26:21 <JohnMeacham> How would people feel about a haskell type checking library? I was thinking it could be useful for a number of things: yi being able to tell you the exact type of the expression under the cursor. haddock which can fill in missing type signatures. a hsgrep command line tool to search for type patterns in code. umm.. probably other stuff too...
18:26:42 <dons> yes please!
18:26:52 <JohnMeacham> shapr: It is really the only thing I know. I have tried to get on a normal schedule before. but it never lasts.
18:26:54 <shapr> Would be great for type error slicing too
18:26:57 <dons> kind of like -package ghc, but in a more convenient form
18:27:10 <hellish> JohnMeacham: yes. Warm fuzzies for implementing that.
18:27:19 <blackdog> so you just drift in and out of normal waking hours?
18:27:20 <dons>  lots of @karma ..
18:27:24 <shapr> JohnMeacham: I can stick with a normal schedule for about two weeks before something happens.
18:27:30 <JohnMeacham> I am discussing with the author of hatchet what its future should be. and a type checking library seems like a great idea to me.
18:27:49 <shapr> Bernie?
18:27:53 <blackdog> yeah, agree doubleplus. if it can typecheck fragments, even better. :)
18:27:57 <JohnMeacham> yeah.
18:28:00 <shapr> Why doesn't he ever show up here?
18:28:03 <JohnMeacham> is he ever on IRC?
18:28:15 <shapr> I met him at ICFP03, talked to him for a few minutes.
18:28:39 <shapr> I've never seen him here.
18:29:05 <JohnMeacham> however, both of us are pretty busy so we might need a new maintainer. I figure we would work together on backporting jhc's improvements and setting up one more release, but then find someone else to take over. I still need to talk to bernie some more on this though.
18:29:36 <JohnMeacham> preferably on some nice darcs server somewhere.
18:29:47 <shapr> I'm usually willing to adopt orphaned code to the point of hosting and updating for new GHC releases.
18:30:46 <putter> shapr: re linked, yes.
18:30:59 <shapr> Assuming I'm still able to do that when you want to orphan hatchet, I volunteer.
18:32:21 <JohnMeacham> Yeah, there are quite a few improvements that could be made too. but it really is 'almost there'. I certainly would be a regular contributer at least until jhc diverges too much.
18:33:02 <shapr> typechecking of fragments would be the most valuable feature to me because that would be good for Yi.
18:33:07 * shapr wants out of emacs!
18:33:30 <Lunar^> shapr: That requires compositional analysis
18:33:48 <Lunar^> shapr: thus not possible with System F, as far as I understand sebc's work
18:34:06 <JohnMeacham> Yeah, part of the improvements I made for jhc was to annotate every subterm with its type.
18:36:06 <JohnMeacham> some work could be done to make it somewhat more incremental, but that shouldn't be hard. imagine if yi had syntax highlighting that also highlighted type errors and told you about them when you mouseovered :). In any case, if implemented as a general library I think there will be a lot of uses. like "[^jgn]hc" :)
18:38:41 <Lunar^> JohnMeacham: have you look at type error slicing?
18:38:46 <Lunar^> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/
18:38:52 <JohnMeacham> Lunar^: no. will take a look.
18:39:41 <Lunar^> that's a simple demo
18:40:11 <JohnMeacham> Hmm.. the pdf appears to be broken.
18:40:25 <Lunar^> *sigh*
18:40:43 <JohnMeacham> Ah. there we go.
18:41:02 <JohnMeacham> it is actually a gz'ed pdf but being served as a normal pdf.
18:41:22 <JohnMeacham> gziping a pdf usualy doesn't help because it is already compressed. (unlike postscript)
18:42:40 <shapr> coi jewel
18:42:44 <Lunar^> good to know
18:42:48 <JohnMeacham> cool. looks interesting.
18:47:49 <Lunar^> sebc's last paper is damn interesting too
18:47:56 <Lunar^> http://www.macs.hw.ac.uk/~sebc/Car+Wel_ITRS-2004.pdf
18:48:14 <Lunar^> It's a comprehensive review and explanation of intersection type systems
18:49:24 <Lunar^> and it was trimmed down to 28 pages
18:49:45 <Lunar^> I hope they will publish the full version (50+) somewhere
18:50:11 <JohnMeacham> Hmm.. I know nothing about intersection types. seems like an interesting topic. I have been fascinated by using type systems to derive properties useful for optimization recently. like the paper that does a points-to analysis via type inference and region inference and ghc's update avoidance typesystem.
18:50:49 <JohnMeacham> Before I was used to abstract interpretation and fixpoint iteration for all those things, now it looks like novel type systems are the way to go...
18:51:15 <Lunar^> You will enjoy your reading, then :)
18:52:45 <shapr> JohnMeacham: which paper is that? region allocation in GHC?
18:53:13 <putter> To wrap up the earlier Inline::Haskell discussion, I guess one thought is this...
18:53:31 <putter> The ability to write perl6 libraries using Haskell is currently tied to pugs.
18:53:46 <putter> If/when running perl6 doesnt necessarily mean pugs (eg, parrot), then
18:53:48 <JohnMeacham> 'Simple Usage Polymorphism' I think. the one that blasts their previous paper. UsageSP.
18:54:14 <putter> using Haskell will again require "a non-trival extra step" for users.
18:54:39 <putter> Well, mostly for windows users.  But that deployment cost/barrier disuades developers
18:55:02 <putter> from using anything but pure perl (plus some C/C++).  However, with pugs,
18:55:19 <JohnMeacham> "time to write a parrot back end for ghc"
18:55:30 <putter> we have a perl6/Haskell hybrid.  Using Haskell is straight forward.  If
18:55:59 <JohnMeacham> actually, we should make sure they include at a minimum a constant stack tail-call so it is possible to target it from a FP language...
18:56:04 <putter> that property can be preserved, then Haskell might leverage its association
18:56:46 <putter> with perl to become a pervasively available and widely used language.
18:57:28 <putter> pugs becomes the "toe in the door"...
18:58:15 <shapr> JohnMeacham: Parrot benefitted nicely from Dan Sugalski's discovery of continuations.
18:58:18 <putter> so what would it take?  doing the work to make ghc installable via CPAN might be sufficient.
18:58:42 <putter> ok, end of thought.
18:58:44 <shapr> That would be challenging.
18:58:58 <JohnMeacham> shapr: cool. now, if we can just have them specify it as a monadic form.... :)
18:59:06 * shapr grins
18:59:24 <shapr> Speaking of which, do you understand the subcontinuations paper?
18:59:37 <JohnMeacham> shapr: although, are they into SSA at all? there is a very direct correspondence between monadic and SSA form.
18:59:49 <shapr> I dunno
19:00:01 <JohnMeacham> shapr; more direct than the CPS - SSA relationship IMHO.
19:00:47 <shapr> I still see monadic as a flavor of CPS, I don't yet have the experience to see why monadic has serious performance advantages over pure CPS.
19:00:53 <shapr> But I know it does in GHC at least.
19:01:18 <shapr> I've been swapping email with Peter Simons about his possible fast I/O article for TMR.
19:02:09 <JohnMeacham> shapr: Well, it is really hard to talk about performance without specifying an abstract machine. I have no doubt they could have radically different performance characteristics between ghc and jhc. I still can't decide whether a CPS or state passing implementation of the IO monad will produce better code yet.
19:03:13 <putter> shapr: re challenging, with FreePAN, one might simply drop binary ghc distributions there.  pugs has the influence to get whatever serverside support there is needed.
19:03:44 <putter> Though if ghc x86 dynamic -fPIC code still doesnt work, that would need to be fixed.
19:04:07 <putter> Hmm, or maybe not.
19:04:18 <JohnMeacham> shapr: Well, monads abstract away the actual details of how things are implemented. for instance, ghcs IO monad desugars into a state passing system (as does jhcs at the moment) but the implicit monad in GRIN desugars into nothing :) it is the monad that is inherent in C procedural code. if it were expressed as CPS, it would be hard to just make it disapear like that since it isn't abstracted away.
19:04:20 <shapr> I don't think it works yet. I've heard WolfgangT is still working on it.
19:04:24 <JohnMeacham> if that makes sense.
19:04:41 <shapr> Hm, that does make sense.
19:05:36 <shapr> putter: I also would like -fPIC for x86, I'll email WolfgangT and find out the status.
19:07:18 <putter> Getting a language accepted as mainstream is a long long hard slog.  pugs could be one of those windows of opportunity where
19:08:11 <putter> if you focus and grab the timing, you win, and if you miss the window, you curse yourself years to come.
19:09:01 <shapr> Well, not me.
19:09:22 <shapr> I'm using Haskell because it's currently the most powerful thing for me.
19:09:42 <shapr> I'd like to get paid to do it, but if I never do, it won't kill me.
19:09:50 <blackdog> shapr: wouldn't it be nice to have legions of developers making little widgets for a haskellish zopealike, though?
19:10:20 <shapr> I seriously doubt there are legions of developers of the same quality as the average #haskell denizen.
19:10:30 <blackdog> I don't think they need to be that good.
19:10:44 <blackdog> Writing a CalendarWidget or a discussion board is not terribly difficult.
19:10:53 <shapr> Being out of the mainstream has some advantages, you rarely get people who are just in it for the money.
19:11:05 <blackdog> but you're not going to do it 'less you get paid, and neither am I.
19:11:33 <shapr> What, make a zope-alike? or a CalendarWidget?
19:11:43 <blackdog> a calendarwidget
19:11:54 <blackdog> i'd write a zopealike for fun. hell, i am. :)
19:11:57 <shapr> I've been thinking about how to make a good calendarwidget actually.
19:12:21 <shapr> One thing I discovered is that Python doesn't make it easy to create interval types.
19:12:41 <blackdog> but you need lots of second-tier developers who don't necessarily grok everything but can write useful little mini-apps. Even lambdabot's a good example of that: I didn't need to know anything about hs-plugins to write a silly little plugin, and that's awesome.
19:13:17 <blackdog> do you mean mathematical interval types, or just tuples of dates?
19:16:06 <putter> re "not me", there is indeed appeal in nitch communities.  the scheme, prolog, and forth folks have been living there, despite their efforts to break out, for a human generation.  but...
19:16:29 <shapr> hiya dbremner
19:16:36 <dbremner> shapr - hi.
19:16:48 <dbremner> shapr - for about 10 seconds, I was worth over $260k+
19:17:09 <shapr> putter: The appeal for me isn't in the niche, it's in the language, in the system. Epigram is the second favorite.
19:17:14 <shapr> dbremner: and then?
19:17:19 <Pseudonym> dbremner: You had VA Linux stock, right?
19:17:41 <dbremner> shapr - I looked more closely at the balance number and realized the teller had made a mistake.
19:17:48 * shapr laughs
19:18:09 <shapr> putter: Do you know lambda calculus?
19:20:27 <putter> but... big picture, our field soo needs to change.  software engineering is a self-inflicted wound of a disaster.  C++ and Java.   Each
19:20:31 <CosmicRay> shapr: is there a good place to find some halipeto examples?  I need something a little more detailed than hello world and a little less detailed than the author's own pancito demo site
19:21:11 <dbremner> putter - I'm not thrilled with Java but you can say interesting things about it.
19:21:40 <shapr> CosmicRay: you want my site?
19:21:53 <shapr> putter: Why are you into programming?
19:21:54 <wagle> Pseudonym: haha
19:22:01 <CosmicRay> shapr: as long as you didn't do anything really complicated with halipeto, that would probably be helpsful, sure
19:22:13 * wagle mourns the fate of his LNUX stock
19:22:28 * CosmicRay did OK with his
19:22:32 <Pseudonym> I mourn the fate of its would-be employees.
19:22:32 <putter> year another cohort hits school without the tools we should be able to provide.   Arg.  Before I retire I want to be able
19:22:41 <CosmicRay> did you all get it at the IPO?
19:22:43 <Pseudonym> They bought an Australian company that a lot of my friends worked at/owned.
19:22:47 <Pseudonym> Long story.
19:22:48 <JohnMeacham> I love haskell too much to do it for a living.
19:22:59 <CosmicRay> heh
19:23:06 <wagle> .. was worth $20000 more than i paid for it, wheni paid for it.. 8/
19:23:11 <Pseudonym> And then their bean counters decided that they should turn a profit that quarter, so couldn't acquire them after all.
19:23:18 <CosmicRay> wagle: that sounds like a yes :-)
19:23:25 <Pseudonym> The Australian company was basically destroyed.
19:23:49 <Pseudonym> Yet another victory for small green pieces of paper.
19:23:57 <wagle> advice was "dont flip"
19:24:01 <wagle> hoho
19:24:02 <putter> to get just a little bit of work done.  Haskell is great, but I also need non-committed choice constraint space collapse and dozen other things.  That requires bodies.  Bodies using good tools.  Collective process.  Haskell still being a nitche language 5 years from now is a failure case for that objective.
19:24:40 <JohnMeacham> hehe. I sold my LNUX the day I bought it. I did the math wrong and was runnig around the dorm saying. "I just made $2000 on the stock market!" then my friend told me.. you know. its not 2000... its 20,000. I nearly passed out. paid for my last year of college.
19:24:41 <putter> shapr: re, lambda calc, yes.  or at least, once upon a time.
19:24:48 <Pseudonym> It does sound like you need a niche language, putter.
19:24:50 <Pseudonym> Or a library.
19:24:58 <CosmicRay> JohnMeacham: I did something similar but made more like $10,000
19:25:08 <shapr> I made fifty cents once.
19:25:11 <CosmicRay> I sold it about 2-3 hours after IPO IIRC
19:25:18 <wagle> so i eventually got out and put my money into "real" stock, which is only worth a 1/3 of what i paid for it, instead of 1/30th..  8)
19:25:21 <mwc> I wanna make some money too
19:25:27 <Pseudonym> I've made a net profit out of gambling.
19:25:31 <mwc> how are we doing that?
19:25:45 <putter> "collective process" =~ s/process/progress/
19:25:48 <CosmicRay> we're not.  this was back in 1999 :-)
19:25:57 <CosmicRay> (or early 2000?)
19:25:59 <JohnMeacham> Anyone else make out on SCO? I can't wait for more companies to sue linux. it is quite profitable to be against them.
19:26:00 <mwc> Pseudonym: me too, I made 10k
19:26:02 <wagle> fall 1999
19:26:05 <mwc> but unfortuneatly it was "pretend chips."
19:26:17 <mwc> Sucks being a card-counting 15 y o
19:26:29 <CosmicRay> JohnMeacham: I with I would have shorted SCO about 2 years ago
19:26:33 <CosmicRay> s/with/wish/
19:26:35 <JohnMeacham> bet against them.
19:26:41 <Pseudonym> Oh, I made a net profit in money and in kind.
19:27:14 <shapr> putter: Well, I do programming because I love it.
19:27:23 <mwc> I've made a pile on an outfit called Brookstone Capital
19:27:25 <wagle> i made money,. but lost it reinvesting..  dont take my stock advice!
19:27:31 <JohnMeacham> unfortunatly, since I work for a stock trading company, my personal trading is severly limited and I was only able to make about 3k off of SCOX. though, it was very satisfying to make money off of their downfall.
19:27:43 <shapr> In the years where I am not able to get paid programming, I go back to what I'm naturally good at.
19:27:48 <Pseudonym> (I don't count gambling that could reasonably be interpreted as "a donation", such as "You could win [prize]!  Just donate to [good cause]!"
19:27:49 <mwc> JohnMeacham: heh
19:27:59 <mwc> shapr: what is that?
19:28:14 <wagle> sco fell?  i thought they were lurching ever on.. (not that i pay much attention)
19:28:18 <shapr> Creative art, writing and visual.
19:28:41 <shapr> Talent doesn't mean enjoyment though.
19:29:14 <putter> dbremner: re Java, agreed.  it's just not enough.  it has my undying gratitude for allowing me never to have the "gc
19:29:15 <JohnMeacham> They used to be at like 15-20.
19:29:28 <a5> does anyone else find it humiliating how the way that typechecks is always more elegant than the way you originally had it
19:29:30 <JohnMeacham> now they had to change their ticker because they are in danger of being delisted.
19:29:32 <shapr> Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
19:29:58 <putter> is a good idea" conversation again. but I dont want to spend the next decade arguing "type inference is a good idea".
19:30:06 <JohnMeacham> I think it is SCOC or something now. scottrade forced out my short position a while ago. (I don't blame them)
19:30:20 <putter> ML isnt enough of a delta to make that case.  Haskell going mainstream would be.
19:30:44 <CosmicRay> JohnMeacham: what exactly do they do when they force out your short position?  force you to buy SCOX at its present negligible market price?
19:31:08 <wagle> are statically typed programs more susceptible to memory corruption?
19:31:09 <dbremner> potter - this is the neatest application of Java I've seen. http://www.jxos.org/
19:31:13 <JohnMeacham> CosmicRay: Yup. exactly. they forced me out at around $5 i think.
19:31:34 <mwc> JohnMeacham: isn't it SCOXE?
19:31:55 <JohnMeacham> mwc: possibly. I stopped paying attention when I stopped being able to short them.
19:31:59 <mwc> wagle: hmm, you mean because the data type isn't checked at runtime?
19:32:00 <CosmicRay> heh
19:32:21 <CosmicRay> gotta suck to be SCO if what people are saying about you is "I stopped paying attention when I stopped being able to short them"
19:32:34 <CosmicRay> closed at $3.50 today
19:32:42 <wagle> dbremner: ahh cool..  i wondered what happened to the state of java os's
19:32:42 <JohnMeacham> a5: you mean when it turns out the code you wrote has a much more general type than you thought of?
19:32:47 <mwc> wagle: I'd say it wouldn't make a difference since if a dynamically typed executable had the type field bit-flipped, it would lead to even more hilarity
19:33:16 <dbremner> wagle - no particular reason that couldn't be done with ML, Haskell, Scheme, Hermes, etc.
19:33:30 <wagle> mwc: corrupting the type tag might cause the program to abort
19:33:31 <mwc> Heh, JavaOS?
19:33:32 <a5> JohnMeacham: no, where it won't type check until you fix something and then it becomes much more general
19:34:13 <mwc> Does anybody else think that using a language without pointers to write an OS is just masochism?
19:34:17 <shapr> putter: How would you suggest Haskell become a mainstream language?
19:34:40 <mwc> They must write a pile of assembler glue.
19:34:42 <shapr> mwc: depends on the language.
19:34:42 <dbremner> mwc - there's a small core in C.
19:34:47 <mwc> shapr: I say it still needs an FPS
19:34:55 <Gahhh> mwc: lol
19:34:59 <wagle> mwc: but i'm expecting statically typed programs to operate with more "dead reckoning" than dynamic languages or type unsafe (like C)
19:35:17 <shapr> Fight the Strictness?
19:35:35 <mwc> shapr: we have an RCS, a Perl6 implementation, we just need a good solid FPS now
19:35:43 <wagle> "suspensions are processes"  8)
19:35:45 <shapr> hmmm
19:35:55 <CosmicRay> mwc: First-Person Shooter?
19:36:02 <mwc> wagle: I tend to think of bitrots as being the beginning of the end of sanity
19:36:06 <mwc> CosmicRay: yep
19:36:15 <mwc> and no, a quake port doesn't count
19:36:22 <JohnMeacham> mwc: wasn't there a doom port in haskell or something? I thought there was on the HOpenGL page.
19:36:31 <CosmicRay> mwc: I'd play if I get to kill evil java Objects using a fancy lambda chain-gun
19:36:31 <JohnMeacham> Ah.
19:36:38 <CosmicRay> oh yeah, I'd sequence those evil Objects.
19:36:38 <mwc> I'm talkin Half-Life 2 or something like that. Just to shut up once and for all the idea that Haskell is slow
19:36:55 <Gahhh> mwc: you have other proof that haskell is not slow ?
19:37:11 <wagle> security attacks often involve one piece of code in an address space corrupting the control or data structures of another piece of code in that address space
19:37:13 <shapr> Sure, we can do an FPS for TMR4
19:37:13 <JohnMeacham> How about an MMORPG with perma-death. since haskell doesn't mind being controversial if it is a good idea in the long run it seems like a good fit.
19:37:23 <mwc> Gahhh: I think there's no reason haskell shouldn't be faster than C
19:37:26 <CosmicRay> shapr: grin
19:37:29 <shapr> First we get Pseudonym to do the graphics
19:37:38 <mwc> since analysis is more tractable for optimization purposes
19:37:39 <shapr> JohnMeacham will optimize jhc for OpenGL purposes
19:37:44 <shapr> CosmicRay will do networking...
19:37:44 <JohnMeacham> mwc: I agree completly! Haskell should compile to be faster than C IMO.
19:37:49 <shapr> I'll be the irresponsible parasite..
19:37:57 * shapr snickers
19:37:57 <CosmicRay> Gahhh: for the language shootout, several haskell programs had to have extra code *added* so that they wouldn't finish instantaneously because the entire problem had been optimized away.
19:38:05 <shapr> Yeah, that was way funny.
19:38:09 <mwc> and then of course there's no aliasing issues whihc make Fortran optimize faster than C already
19:38:10 <Pseudonym> No way you're getting me involved in game programming.
19:38:22 <shapr> Pseudonym: no, not game programming just graphics, that's all...
19:38:31 * shapr cackles evilly
19:38:39 <Pseudonym> Uh huh.
19:38:49 <JohnMeacham> CosmicRay: I still think that isn't needed. if haskell has to deal with the disadvantages of lazy evaluation, it should be able to take advantage of the advantages, like not having to evaluate things that arn't used.
19:38:53 <mwc> JohnMeacham: have you given any thought to targetting the LLVM?
19:39:04 <JohnMeacham> mwc: LLVM?
19:39:04 <CosmicRay> JohnMeacham: I agree with you
19:39:07 <shapr> JohnMeacham: yeah, but the imperatives whined.
19:39:28 <Gahhh> how about something like an mpeg4 encoder ?
19:39:39 <CosmicRay> I think the shootout authors didn't expect that there would be a language smart enough to detect that the results of evaluating the problem were never used.
19:39:41 <mwc> JohnMeacham: http://llvm.cs.uiuc.edu/ Compiler backend
19:39:47 <JohnMeacham> We should make them turn off things like CSE. because then they arn't really calculating everything... seems like a slippery slope.
19:39:50 <putter> shapr: re joy of programming, :).  broad :).  it's just, on a person level, I'm getting tired of the maze of twisty little passages, of things being "broken all the way down".  on a profession level, I feel the field is failing it responsibility to society.
19:39:52 <CosmicRay> Gahhh: my memory seems to vaguely recall someone working on things like that
19:40:37 <mwc> Gahhh: the problem is that language flamewars are mostly the concern of freshman CS students. And you need something with flashing lights and loud noises to attract their attention
19:40:39 <Gahhh> putter: the field's failure is due to business decisions
19:40:41 <putter> dbremner: re jxos, I'll look at it.  tnx.
19:40:45 <reffie> i need someone to lend me $35000.
19:40:49 <shapr> JohnMeacham: yeah, there's no flat part to the slope.
19:40:52 <JohnMeacham> mwc: no. I have not looked at that. the only backends I have thought of are C, a direect gcc interface, c-- with gcc backend (my current favorite, when it exists), and .NET
19:41:00 <wagle> reffie: for what?
19:41:03 <reffie> a car
19:41:09 <putter> shapr: How would you suggest Haskell become a mainstream language? ...
19:41:11 <shapr> putter: What's our responsibility to society?
19:41:15 <shapr> putter: I think it already is.
19:41:17 <CosmicRay> JohnMeacham: if you spit out ansi c, pnetc could compile it to .net already, theoretically
19:41:39 <mwc> JohnMeacham: oh well, guess I have a 4-manyear project for myself then :P
19:42:00 <JohnMeacham> CosmicRay: Yeah, but a direct translation shouldn't be too hard and there are probably things I can take advantage of like the .NET GC.
19:42:46 <mwc> Gah, I know mono isn't as bad as the JVM
19:43:00 <mwc> but I'm still dreading the VM overhead
19:43:11 <putter> perl6 is a mainstream language.  if the perl community putters over and finds that, cool, perl6 has rules and threads, and cool, perl6 has Haskell...  then Haskell just became a mainstream language.  With breathtakingly less work than that accomplishment usually requires.
19:43:24 <CosmicRay> mwc: yeah but all the windows twits who don't realize it exists and assume that shipping everything as a self-extracting .exe is no problem really get on my nerves :-)
19:43:27 <mwc> memory, startup time
19:43:46 <JohnMeacham> mwc: indeed. the VM overhead is pretty bad. especially when you layer a lazy functional abstract machine on top of it.
19:44:23 <mwc> I'm not  compiler expert, but it seems to me Haskell would lend nicely to transformation to SSA form
19:44:26 <wagle> oh bummer..  jxos looks dead
19:45:00 <shapr> putter: so what are you saying?
19:46:12 <mwc> What seems to be a win for LLVM to me is that it has both bytecode and native code generators
19:46:13 <Gahhh> I dont think in this day and age anybody expects lightning fast code. You'd need to demonstrate haskell's versatility and productivy rather than a potential to reach C speeds.
19:46:17 <wagle> LLVM is pretty cool
19:46:40 <mwc> so you can run your app on the bytecode VM and get all the profiling and debug benefits out of that
19:46:51 <JohnMeacham> mwc: The problem is all the indirect calls, each evaluation of a thunk can potentialy call ANY thunk creation point. jhc's whole big thing is to transform all evals away into static calls and then represent it in GRIN (SSA) form.
19:46:53 <mwc> and then turn around and mix down to native code for shipping
19:46:56 <wagle> speed is easy to measure..  and relates to cost
19:47:01 <dbremner> Gahhh - Todd Proebsting made a similar point in his Disruptive Programming Languages presentation.
19:47:31 <putter> re LLVM, pypy is/was making good progress on doing a python bootstrap on LLVM.
19:47:35 <Gahhh> heh nice title for a presentation
19:47:48 <wagle> and there are a lot fewer haskell programmers than C programmers
19:47:50 <mwc> What bugs me about intermediate ocmpiles to C is that you loose huge amounts of debugging information
19:47:58 <dbremner> Gahhh - he was inspired by the Innovator's Dilemma.
19:48:16 <mwc> JohnMeacham: hmm, so you turn Haskell into an SSA form?
19:48:27 <JohnMeacham> mwc: but a naieve translation to SSA will have every single block having arrows to the eval block. (or you make the evals implicit, but loose the ability to optimize them well)
19:48:52 <JohnMeacham> mwc: Yes. a monadic form which is equivalant to SSA form.
19:49:16 <mwc> Hmmm
19:49:23 <mwc> If I get ambitious I'll try to port that to LLVM
19:49:42 <dbremner> Gahhh - here's slides. http://64.233.179.104/search?q=cache:NrNLCkq81nkJ:research.microsoft.com/~toddpro/papers/disruptive.ppt+disruptive+programming+languages&hl=en&start=1&client=safari
19:49:55 <mwc> LLVM's instruction set is SSA, has an exact GC system, etc.
19:51:15 <JohnMeacham> mwc: shouldn't be too hard actually, the entire translation from Grin -> C is in C/FromGrin.hs, it is only 300 lines. that just needs to be replaced for each backend. grin is much closer to native imperitive forms than core so backends are signifigantly easier.
19:51:23 <wagle> the April 24, 2002 ppt slides?
19:51:25 <Gahhh> dbremner: I believe HL2, Doom3, et al very much relied on compiler optimizations heh.
19:52:28 <wagle> i keep meaning to sit down and compare current treessa and llvm, but nothing find my round tuit
19:52:54 <putter> shapr: re "so what are you saying?".  pugs is a "nice success story for Haskell".  something to add to the list.  but a small amount of vision and work might perhaps leverage it to much greater consequence.
19:52:56 <shapr> Autrijus was wondering about grin -> parrot earlier.
19:53:12 <shapr> putter: Like what vision and work?
19:54:08 <JohnMeacham> shapr: should be possible. but I wish parrot were strongly typed (with a convienient universal type), we would take a huge hit from the dynamic type checks.
19:55:59 <JohnMeacham> I am somewhat more interested in parrot -> C via grin. The points-to analysis would be perfect for determining static typings whenever possible.
19:57:16 <putter> shapr: re "Like what vision and work?", preserving the "if you have a perl6, then haskell is obviously there too" property.  that requires...
19:57:43 <mwc> anybody know how the GHC bootstrap works? Does it do 3 passes like GHC?
19:57:58 <JohnMeacham> mwc: ?
19:58:14 <mwc> er, 3 passes like GCC
19:58:23 <Gahhh> mwc: 2 passes minimum I believe
19:58:32 <mwc> one pass build with old compiler, then compile self with new compiler, then do again and check they're identical?
19:58:37 <mwc> Just wondering why it's taking so long
19:58:46 <wagle> after watching stage1 run for several hours, I went to sleep.  when i woke up, there was no log or build area..  (stupid darwinports!)
19:58:56 <mwc> Heh, yeah
19:59:02 <mwc> that's -v
19:59:05 <wagle> mwc: which platform?
19:59:14 <putter> compatible licencing, hooking into the perl6 library distribution system, being portable enought that at least the platforms people care about are supported, interfacing with parrot or whatever other perl6 backends are used, and...
19:59:21 <mwc> Still no 10.4 build of GHC
19:59:23 <JohnMeacham> I think it does one unregistered build, then a registered one. but that might just be when moving to a new arch.
19:59:29 <mwc> wagle: mac os x 10.4
19:59:33 <Gahhh> mwc: compile sources with current ghc, recompile with the binary produced in the previous stage. you can go for a 3rd stage to be sure.
20:00:05 <wagle> the latest gcc (nov 2004 patch anyway) seems to slow it down 2-3 x
20:00:08 <mwc> letting darwinports do it, just wondering why it took so long
20:00:23 <mwc> wagle: yeah, too bad it's not GCC 4.0 compat
20:00:35 <wagle> if you didnt upgrade the 10.3 compiler, then its a bit faster
20:00:39 <mwc> GHC won't be -mcpu=7450 -Os -ftreevectorize
20:00:46 <JohnMeacham> ghc doesn't work with gcc 4.0? glad I didn't upgrade.
20:00:51 <mwc> -ftree-vectorize
20:01:01 <wagle> gcc 4 apparently isnt a speed demon yet
20:01:06 <mwc> JohnMeacham: that's what I heard, there's some GCC-3'isms
20:01:20 <mwc> it's faster on C++
20:01:20 <wagle> 10.4 comes with gcc4?
20:01:22 <putter> having some nifty "perl6" libraries written in haskell so that anyone looking at perl6 will see haskell as a natural and dependable part of the system, rather than a speculative graft.  that might be sufficient.  what am I missing...?
20:01:23 <dbremner> wagle - gcc 4 is slower on all of the Acovea benchmarks, IIRC.
20:01:24 <Gahhh> I thought gcc4 compiled quicker and produced faster code.
20:01:28 <mwc> wagle: yep
20:01:45 <wagle> whoa, thats getting ahead of itself
20:01:47 <dbremner> Gahhh - it compiles C++ much faster.
20:02:27 <wagle> upgrading to 10.4 might cost me $600..  sigh
20:02:32 <Gahhh> ow
20:02:45 <mwc> wagle: how's that?
20:02:51 <Gahhh> that apple monopoly forcing users to upgrade. tee hee
20:03:00 <wagle> upgrading the proprietary software)
20:03:10 <mwc> wagle: ah...
20:03:17 <dbremner> Gahhh - here are the numbers. http://www.coyotegulch.com/reviews/gcc4/index.html
20:03:38 <mwc> glad that I just have to waste time and increase the entropy of the universe by recompiling my ports tree
20:03:58 <mwc> hmm.... I wonder if Gentoo compiles have noticibly affected the entropy of the universe.
20:04:05 <JohnMeacham> putter: seems like a good idea.
20:05:22 <Gahhh> dbremner: it seems to compile the linux kernel faster too (on ia32, not on 64)
20:07:03 <dbremner> Gahhh - you're using IA64?
20:07:21 <Gahhh> no :)
20:08:03 <Gahhh> since the modern apps are not fast by design, I am deferring upgrades indefinitely.
20:08:56 <dbremner> Gahhh - at work we have the museum of 90s Sun hardware.
20:09:01 <Gahhh> eventually spam filters will require etaflops capable cpu's. then I'll upgrade.
20:09:13 <Gahhh> dbremner: I still have an ultrasparc 10 in my cube.
20:09:49 <wagle> i have 8 sparc 2's gathering dust..
20:09:59 * mwc will become rich after inventing a quantum spam filtering algo
20:10:14 <dbremner> Gahhh - we have a bunch of random Sun hardware that runs most of the business.
20:10:55 <shapr> putter: are you part of the development team for pugs?
20:11:14 * shapr is going to save cpu cycles by skipping out of email
20:12:28 <wagle> someone else will become richers inventing a quantum spam generating algo
20:12:35 <wagle> richer
20:13:01 <dbremner> wagle - there was an article in Interesting People about quantum crypto networks today.
20:13:22 <putter> JohnMeacham: yeah, there might be something there.  the thread started on perl6/haskell cross-fertilization, then the question of what happens "post pugs".  the punch line seems to be that if Haskell gets a good grip and hangs on, it could grab quite a ride.
20:13:23 <wagle> "interesting people"?
20:14:12 <dbremner> wagle - mailing list run by Dave Farber. Lots of smart people post to it.
20:14:40 <putter> maybe.  that's the idea anyway.  it seems a possibility worth pondering.
20:15:01 <mwc> Speaking of Perl, my top two syntax psychotic hatred are $variables and := assignment
20:15:16 <mwc> perl of course, has not :=
20:15:19 <mwc> but $variables
20:15:21 <putter> shapr: re dev team, I've puttered, but nothing significant.
20:15:45 <Gahhh> Intel & AMD would appreciate if somebody wrote an app that sucked 80%+ cpu time over prolonged periods. It could be in haskell.
20:15:56 <Gahhh> yeah I hate $variables too
20:16:48 <mwc> comments that require a shift key to escape, eg: (* *), /* */, <!--, etc. also make the list
20:17:30 <mwc> but i'm mostly used to them
20:17:32 <dbremner> Gahhh - a supercompiler for Haskell could eat a lot of cpu. http://www.supercompilers.com/technology.shtml
20:17:34 <Gahhh> why doesnt your editor insert comment delimiters for you anyway
20:18:00 <mwc> Gahhh: that's why I can tolerate them
20:18:21 <mwc> it's an objection in principle rather an an actual practical irritation
20:18:36 <mwc> commenting should be the easiest most natural thing in the syntax
20:19:03 <shapr> I've got H-c bound to comment-regian
20:19:05 <shapr> region
20:19:23 <JohnMeacham> dbremner: funny you should mention supercompliation, my second to last jhc programming spurt was inspired by reading those pages.
20:19:35 <Gahhh> mwc: yeah language designers save no-shift-required characters for actual lexemes that make it to the parser.
20:19:50 <mwc> Gahhh: like ;, --, // ?
20:19:52 <Gahhh> selfish imho
20:19:52 <mwc> :P
20:20:07 <mwc> ; to end of line comments a la gas are pretty good
20:20:14 <dbremner> JohnMeacham - I play with a language design every once in awhile.
20:20:39 <JohnMeacham> mwc: * and / are right next to each other on the numeric keypad. if you have one. I find {- and -} pretty awkward, but I have assigned gestures to them so it is not so bad.
20:21:43 <mwc> I just use literate programming tools.
20:21:51 <mwc> easiest commenting ever.
20:22:20 <Gahhh> like Leo ?
20:22:25 <mwc> I want to interrupt this GHC build and rerun with -v to be sure it's not hung
20:22:44 <mwc> but I'm scared I'll potentially discard a few hours of useful work :P
20:23:39 <dbremner> mwc - you could run lsof and see if it's opening and closing files.
20:23:57 <mwc> too late :P
20:26:27 <shapr> hiya mugwump
20:26:39 <shapr> Want some Haskell cookies?
20:26:50 * shapr cuts out little lambda shapes
20:27:21 <shapr> time for sleeeeep
20:28:17 * mugwump chomps on a lambda cookie
20:30:32 <putter> night shapr.  thanks for the discussion.  was fun.
21:57:05 <JohnMeacham> Hmm. Daniel is likely to get a lot of responses.
21:59:18 <mwc> hmm, is float div by int not defined?!
21:59:22 <mwc> *** Expression     : s / (2 * sin (pi / n))
21:59:22 <mwc> *** Term           : s
21:59:22 <mwc> *** Type           : Float
21:59:22 <mwc> *** Does not match : Int
21:59:31 <Pseudonym> @type (/)
21:59:36 <lambdabot> (/) :: forall a. (Fractional a) => a -> a -> a
21:59:43 <Pseudonym> Do you understand that type, mwc?
22:00:04 <mwc> Looking at the docs right now
22:00:28 <mwc> Although I'm trying to do an exercise before types have been introduced
22:00:37 <mwc> well, type classes at any rate
22:00:37 <Pseudonym> Ah.
22:00:41 <Pseudonym> I'll help you out, then.
22:00:49 <Pseudonym> First off, (/) is of type a -> a -> a
22:00:58 <Pseudonym> i.e. its arguments have to be of the same type
22:01:00 <Gahhh> JohnMeacham: Daniel who ?
22:01:17 <Pseudonym> Secondly, a has to be a member of Fractional, and Int isn't fractional.
22:01:17 <mwc> yeah, there's no implicit conversion from Int -> Float?
22:01:20 <Pseudonym> Nope.
22:01:28 <Pseudonym> No implicit conversions in Haskell at all.
22:01:33 <Pseudonym> It plays havoc with type inference.
22:01:59 <mwc> Wow, that's going to make geometry a pain. I was looking for a type conversion function in the prelude but didn't find anything
22:02:03 <Pseudonym> @type fromIntegral
22:02:04 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
22:02:14 <Pseudonym> You can use that.
22:02:40 <mwc> heh, I looked at that and it didn't seem to be what I was after
22:04:55 <JohnMeacham> Carrera, just posted on haskell-cafe.
22:13:07 <mwc> does it make sense to nest a let in under a where?
22:13:23 <pediddle> sure, if it makes sense
22:13:24 <mwc> f = x where let subdefs in x = etc.
22:13:26 <pediddle> :)
22:14:08 <a5> people should help me design my haskell mua
22:14:36 <pediddle> mwc: i don't think that's syntactically correct
22:14:53 <pediddle> let is an expression, whereas "where" expects a sequence of bindings
22:15:05 <mwc> No I know, I'm trying to figure out how to write this bloody mess
22:15:12 <mwc> I've got about a half million float/int divs
22:15:37 <pediddle> can't you just put "subdefs" straight under the "where"?
22:15:40 <mwc> I was gonna try to do the conversion to float in the let
22:15:54 <mwc> yeah, but it's not so easy, I fear.
22:16:12 <mwc> does a sub-where bind upward into all the bindings?
22:16:33 <musasabi> morning
22:16:36 <pediddle> only the one to which it's attached
22:16:43 <pediddle> if i understand your question
22:16:53 <mwc> Gah, so I'd need to do it in multiple places.
22:16:57 <mwc> Urge to kill. risings.
22:17:52 <a5> morning
22:17:57 <pediddle> hehe
22:18:11 <pediddle> there's probably something sneaky you can do with a monad
22:18:14 <pediddle> ... or something
22:18:36 <Gahhh> why not define a function that div's a float by an int ?
22:19:08 <mwc> I'm thinking the easiest way is to convert the ints to floats to begin with
22:19:14 <mwc> just need to figure out a convenient place to do it
22:20:38 <mwc> I need to compute the unit vector increments through an n-step cycle.
22:20:51 <mwc> So that's an m(n-2)/n*pi degree rotation
22:20:56 <pediddle> oh, it sounds so simple when you put it like that :)
22:21:10 <mwc> yeah, it does.
22:21:32 <pediddle> and you're hardcoding the increments as a bunch of bindings?
22:22:16 <Pseudonym> [ (sin theta, cos theta) | i <- [0..n-1], let { theta = 2 * pi / fromIntegral i } ]
22:22:26 <Pseudonym> Only needed to write fromIntegral once there.
22:23:03 <mwc> oh, right, those list things... haven't covered those yet, but that's good
22:23:05 <Pseudonym> (Technically you don't have to write it at all if n is small enough.  Say, less than 2^32ish.)
22:23:27 <Pseudonym> @plugs let n = 4 in [ (sin theta, cos theta) | i <- [0..n-1], let { theta = 2 * pi / i } ]
22:23:32 <lambdabot> [(NaN,NaN),(-2.4492127076447545e-16,1.0),(1.2246063538223773e-
22:23:32 <lambdabot> 16,-1.0),(0.8660254037844387,-0.4999999999999998)]
22:23:37 <Pseudonym> Hmmm.
22:23:39 <Pseudonym> Oh, duh.,
22:23:47 <Pseudonym> @plugs let n = 4 in [ (sin theta, cos theta) | i <- [0..n-1], let { theta = 2 * pi * i / fromIntegral n } ]
22:23:49 <lambdabot>     Ambiguous type variable `b' in these top-level constraints:
22:23:49 <lambdabot> `Integral b' arising from use of `fromIntegral'
22:23:59 <Pseudonym> @plugs let n = 4 in [ (sin theta, cos theta) | i <- [0..n-1], let { theta = 2 * pi * i / n } ]
22:24:01 <lambdabot> [(0.0,1.0),(1.0,6.123031769111886e-17),(1.2246063538223773e-16,
22:24:01 <lambdabot> -1.0),(-1.0,-1.836909530733566e-16)]
22:24:04 <Pseudonym> That's more like it.
22:24:55 <pediddle> @type \n -> [ (sin theta, cos theta) | i <- [0..n-1], let { theta = 2 * pi * i / n } ]
22:24:57 <lambdabot> \n -> [ (sin theta, cos theta) | i <- [0..n-1], let { theta =
22:24:57 <lambdabot> 2 * pi * i / n } ] :: forall a.
22:24:57 <lambdabot>  
22:24:57 <lambdabot> (Enum a,
22:24:57 <lambdabot>  
22:24:57 <lambdabot> Floating a) =>
22:24:59 <lambdabot>  
22:25:01 <lambdabot> a -> [(a, a)]
22:25:13 <pediddle> woah
22:25:34 <pediddle> Enum a and Floating a at once?
22:25:40 <Pseudonym> Double fits.
22:25:54 <pediddle> @plugs [1.0..3.0]
22:25:55 <lambdabot> [1.0,2.0,3.0]
22:26:01 <pediddle> huh
22:26:07 <Pseudonym> @plugs [1.0,1.1..3.0]
22:26:08 <JohnMeacham> Yeah, Enum is an odd class. it really should be split into two.
22:26:09 <lambdabot> [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,
22:26:09 <lambdabot> 1.5000000000000004,1.6000000000000005,1.7000000000000006,1.80000000000
22:26:09 <lambdabot> 00007,1.9000000000000008,2.000000000000001,2.100000000000001,2.
22:26:09 <lambdabot> 200000000000001,2.300000000000001,2.4000000000000012,2.500000000000001
22:26:09 <lambdabot> 3,2.6000000000000014,2.7000000000000015,2.8000000000000016,2.900000000
22:26:10 <lambdabot> 0000017,3.0000000000000018]
22:26:17 <pediddle> @plugs [1.1..3.1]
22:26:19 <lambdabot> [1.1,2.1,3.1]
22:26:19 <Pseudonym> Gotta be careful of roundoff error, though.
22:26:44 <pediddle> agreed
22:27:31 <mwc> I'd be happy just to figure out how to do this in a less convuluted method than doing it in C :P
22:32:23 <mwc> i
22:41:39 <a5> design mua
22:45:06 <a5> sigh
23:05:00 <lispy> "Associated Types with Classes" makes no sense to me...
23:05:55 <lispy> lambdabot's output would be much easier to read if it didn't chop up the lines
23:06:02 <lispy> at least on my client
23:07:58 <mwc> lispy: at a @todo
23:08:11 <mwc> *add
23:08:18 <mwc> Wow, 6 hours later, I have bootstrapped GHC 6.4. Go Team.
23:09:01 <mwc> Ah I see. this port helpfully includes every known haskell package under the sun
23:12:37 <lispy> mwc: yeah, i'm not really sure what would be better tho.  I just know it's not right :)
23:12:50 <lispy> mwc: and i feel bad creating a todo item if i can't suggest something better
23:38:43 <ozone> lispy: what bits of it makes no sense to you?
23:44:29 <lispy> ozone: section 4 is especially problematic.  :)
23:45:11 <lispy> ozone: if you're curious i mean section 4 of the second paper listed here: http://research.microsoft.com/Users/simonpj/papers/assoc-types/
23:45:42 <lispy> ozone: but, fortunately, i just have to understand enough to ask questions and a classmate will try to explain it :)
23:46:29 <lispy> functional dependencies are also new to me
23:46:57 <lispy> and i don't think i understand what problem it solves, or how it solves it
23:48:59 <ozone> lispy: it completely abstracts how the data structure stores the data from its type
23:49:47 <ozone> hmm, don't really have time to go into it now, but email me if you really want to know
23:50:07 <lispy> ozone: it's quite alright :)
23:50:18 <lispy> ozone: hopefully my classmate will shed light for me
23:53:37 <lispy> well, bed time for me
23:53:59 <skew> good night, I'll take over for you
23:54:14 <lispy> skew: sweet!
