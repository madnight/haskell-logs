00:48:03 <musasabi> How would I uniquely decorate values with an unique integer when they are lifted into an arrow?
00:48:56 <musasabi> My basic problem is that I need a way to break cycles and numbering nodes would be an easy way to do that.
00:51:51 <boegel> @seen shapr
00:51:52 <lambdabot> I saw shapr leaving #haskell 6 days, 15 hours, 51 minutes and 35
00:51:52 <lambdabot> seconds ago.
00:52:08 <boegel> seems like shapr is really kicking off his IRC adiction
00:55:44 <glimming> I am working on a simplification of Oleg's lambda interpreter. http://www.nada.kth.se/kurser/kth/2D1456/LAM.hs
00:55:47 <glimming> Any suggestions?
00:56:04 <glimming> I'd like to make it monadic and use monads for tracing a derivation into a nice style e.g.
00:57:15 <glimming> "(\x.\y. x a) b ~~beta~~> \y. a b ~~eta~~>  a b"
00:57:25 <glimming> is accumulated during the evaluation of the first expression in a state monad.
00:57:29 <glimming> Or similar.
00:57:37 <glimming> Maybe not a state monad but a List monad.
00:57:57 <glimming> Next, I'd like it to use monad to handle (as prooposed) free variables.
00:58:19 <glimming> A state of fresh variable, i.e.
00:58:24 <glimming> replacing the Stack
01:03:51 <boegel> damn fucking rich boys
01:04:00 <boegel> gumball racers, tss
01:23:35 <musasabi> dcoutts_: ping, gtk2hs ebuild dies on gentoo x86.
01:25:55 <glimming> If I want to prove a law L=R
01:26:01 <glimming> is it sufficient to show L=X
01:26:02 <glimming> and R=X
01:26:04 <glimming> ?
01:26:20 <glimming> no
01:26:38 <glimming> ?
01:26:53 <glimming> note "law" is an equality of Haskell programs
01:27:05 <musasabi> equality is transitive.
01:27:23 <glimming> yes, but this is not transitivity AFAIK
01:27:37 <glimming> Yes it is
01:27:38 <glimming> sorry
01:28:01 <glimming> Establishing L = R in Haskell
01:28:11 <glimming> means establishing two reductions
01:28:13 <glimming> L ---> R
01:28:16 <glimming> and R---> L
01:29:36 <glimming> hmmm
01:32:15 <xyzp_> What version of gtk2hs?
01:34:40 <xyzp> I suppose USE flags and ghc version wouldn't hurt, either.
01:39:27 <musasabi> dev-haskell/gtk2hs-0.9.7  -doc -gnome +mozilla 0 kB, with ghc-6.4. adding swap seems to help.
01:39:42 <musasabi> This is with 512mb of ram.
01:41:52 <basti_> hi
01:44:23 <musasabi> hello basti.
01:44:48 <xyzp> Ah.
01:45:53 <xyzp> Yes, it's a RAM hog.
01:52:22 <glimming> can someone simply this
01:52:26 <glimming> (x >>= id) . \m -> m >>= (\x -> return f x)
01:52:53 <glimming> basti pls check backlog
01:53:08 <basti_> i just joined glimming
01:53:16 <basti_> but i'll look up the log
01:53:28 <glimming> I know, I am working on the lambda interpreter, a simplified monadic version.
01:53:40 <glimming> I am designing a take-home examination in Haskell and lambda calculus for the moment.
01:54:20 <glimming> I was thinking of using the lambda interpreter someow, e.g. asking them to make certain variations etc.
01:54:38 <basti_> hmm yup
01:54:43 <xerox> @pl (x >>= id) . \m -> m >>= (\x -> return f x)
01:54:44 <lambdabot> join x . (return f =<<)
01:54:49 <glimming> But I wanted to take Oleg's work on lambda interpreters (see link above to a simplified version of Oleg's code) and make it more easy
01:55:02 <glimming> huh? what is pl ??
01:55:07 <xerox> @help pl
01:55:08 <lambdabot>  @pointless <expr> - play with pointfree code
01:55:19 <glimming> very impressive, who wrote this?
01:55:26 <xerox> TheHunter
01:55:37 <glimming> rewrite rules?
01:55:43 <xerox> @version
01:55:44 <lambdabot> lambdabot 2p463, GHC 6.4 (OpenBSD i386)
01:55:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:55:50 <basti_> i think its about combinatory logic
01:55:56 <xerox> You can darcs-get the sources and check :)
01:56:08 <glimming> right
01:56:18 <basti_> hmm okay glimming
01:56:24 <glimming> what's join?
01:56:45 <basti_> where?
01:56:53 <xerox> @pl \f x -> x >>= return . f
01:56:54 <lambdabot> fmap
01:56:58 <glimming> @pl (x >>= id) . \m -> m >>= (\x -> return f x)
01:56:58 <lambdabot> join x . (return f =<<)
01:57:10 <xerox> @pl x >>= id
01:57:11 <lambdabot> join x
01:57:26 <glimming> aha, so it is "mu"
01:57:54 <glimming> I am trying to derive the monad law for unit from
01:57:58 <xerox> @type join
01:58:02 <xerox> bzzt.
01:58:03 <lambdabot> bzzt
01:58:06 <xerox> :-\
01:58:29 <integral> @type Control.Monad.join
01:58:30 <lambdabot> Control.Monad.join :: forall a (m :: * -> *).
01:58:30 <lambdabot>         (Monad m) =>
01:58:30 <lambdabot>         m (m a) -> m a
01:58:40 <xerox> join :: (Monad m) => m (m a) -> m a
01:58:42 <xerox> oh yes.
01:58:51 <xerox> @wiki MonadsAsContainers
01:58:52 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
01:59:51 <glimming> @pl mu.mu
01:59:52 <lambdabot> mu . mu
01:59:58 <xerox> @moo
01:59:58 <glimming> @pl join.join
01:59:59 <lambdabot>              (__)
01:59:59 <lambdabot>              [##]
01:59:59 <lambdabot>       /-------\/
01:59:59 <lambdabot>      / |     ||
01:59:59 <lambdabot>     *  ||----||
02:00:00 <lambdabot>        ^^    ^^
02:00:02 <lambdabot>  This cow belonged
02:00:04 <lambdabot>   to Flash Gordon
02:00:06 <lambdabot> join . join
02:00:18 <glimming> @pl join. fmap join
02:00:19 <lambdabot> (join =<<)
02:00:36 <glimming> @pl join. fmap return
02:00:37 <lambdabot> id
02:00:48 <xerox> @pl \f xs -> join (fmap f xs)
02:00:49 <xerox> >>=
02:00:49 <lambdabot> (=<<)
02:00:52 <xerox> Hmpf.
02:00:59 <xerox> @pl \xs f -> join (fmap f xs)
02:01:00 <lambdabot> (join .) . flip fmap
02:01:11 <glimming> I am lost.
02:01:16 <xerox> heh.
02:01:25 <basti_> lol
02:01:27 <glimming> can we do it manually?
02:01:38 <xerox> I suppose.
02:01:57 <glimming> mu . \m -> m >>= (\x -> return f x)
02:02:03 <glimming> is what I want to simplify
02:02:11 <glimming> so I expand mu into it's definition
02:02:22 <glimming> (x >>= id) . \m -> m >>= (\x -> return f x)
02:02:45 <xerox> mu . \m -> m >>= return . f
02:03:28 <glimming> yes
02:04:32 <glimming> ( I want to arrive at p >>= return = p or (return e) >>= q = q e )
02:04:52 <glimming> RHS is id here
02:06:00 <xerox> Where does f come from, anyway?
02:06:15 <xerox> \f -> \m -> m >>= (\x -> return f x) ?
02:06:34 <xerox> This is equal to \f -> (return f =<<)
02:06:53 <xerox> I think!
02:06:53 <glimming> there is a  typo, yes
02:07:54 <glimming> We have
02:07:55 <glimming> mu . fmap eta = mu . \m -> m >>= (\x -> return eta x) =
02:07:56 <glimming>    (x >>= id) . \m -> m >>= (\x -> return return x) =
02:07:56 <glimming>    (x >>= id) . \m -> m >>= return . return
02:08:48 <xerox> What's eta?
02:18:06 <boegel> xerox: a greek letter :p
02:18:26 <basti_> lol
02:18:41 * xerox snickers
02:20:05 <glimming> @pl (x >>= id) . \m -> m >>= return . return
02:20:06 <lambdabot> join x . (return `fmap`)
02:20:28 <glimming> fantastic
02:20:38 <basti_> yes.
02:20:43 <xerox> Why? :)
02:20:52 <basti_> much shorter
02:21:01 <basti_> completely anti-intuitive
02:21:06 <basti_> :)
02:21:06 <xerox> Oh yes, that's enjoyable :-)
02:22:31 <xerox> Anyway, what does it do? <grin>
02:23:27 <xerox> @type \x -> Control.Monad.join x . (return `Control.Monad.fmap`)
02:23:33 <lambdabot> \x -> Control.Monad.join x . (return `Control.Monad.fmap`) :: forall
02:23:33 <lambdabot> a
02:23:33 <lambdabot>                        (f :: * -> *)
02:23:33 <lambdabot>                        (m :: * -> *)
02:23:33 <lambdabot>                        a1.
02:23:34 <lambdabot>                      (Monad ((->) (f (m a1))),
02:23:36 <lambdabot>                      Functor f,
02:23:38 <lambdabot> [4 @more lines]
02:23:42 <xerox> ...
02:25:53 <glimming> We areb proving that Kleisli-laws are implied by the monoid-style (normal) monad laws
02:26:01 <glimming> And maybe also the other direction.
02:58:16 <blackdog_> @seen dons
02:58:17 <lambdabot> dons is in #haskell. Last spoke 5 hours, 42 minutes and 47 seconds
02:58:17 <lambdabot> ago.
03:04:30 <musasabi> dons: the newest hs-plugins darcs seems to have problems compiling - 'Rebuilding dependencies ... Could not find module `Language.Haskell.Hsx':'
03:05:28 <glimming> What's a hs-plugin?
03:06:04 <musasabi> Dynamically loaded plugins with ghc - http://www.cse.unsw.edu.au/~dons/hs-plugins/
03:13:19 <dons> musasabi, we now use nibro's hsx package for parsing (parses more of .hs than the library parser) . check the README for the darcs path.
03:13:34 <dons> hsx should be part of the standard libs soon
03:14:06 <musasabi> dons: ok, will add that.
03:14:24 <glimming> why is this useful?
03:14:52 <dons> dynamic loading, runtime compilation -- they're very useful.
03:14:56 <dons> lambdabot for example, and @plugs
03:14:59 <dons> @plugs 1 + 2
03:15:02 <lambdabot> 3
03:15:03 <dons> plugins!
03:15:27 <glimming> I do not see this example.
03:15:28 <dons> it's essentially a form of runtime meta programming.
03:15:49 <dons> what do you mean?
03:15:49 <glimming> Smalltalk-like system?
03:15:57 <musasabi> glimming: it makes possible to have plugins in haskell aplications which is very usefull.
03:16:00 <Lunar^> *sigh* Where's shapr?
03:16:25 <glimming> but is not dynamically linked libraries better?
03:16:26 <musasabi> Lunar^: He said in a blog that he wants to get FLM 0.1 finished..
03:16:26 <Lunar^> Gour is talking about a revival for its gforge
03:16:38 <Lunar^> @seen shapr
03:16:39 <lambdabot> I saw shapr leaving #haskell 6 days, 18 hours, 16 minutes and 22
03:16:39 <lambdabot> seconds ago.
03:16:50 <Lunar^> musasabi: Do you think he was drawn by the code?
03:17:07 <dons> we only have .so's on the Mac, glimmming. and nonetheless, user-scripted dynamic loading and *runtime compilation* useful in their own right.
03:18:01 <dons> we need a lambdabot plugin to report what shapr is doing..
03:18:09 <dons> @shapr-is-where-now?
03:18:10 <lambdabot> Unknown command, try @listcommands.
03:18:34 <glimming> yes, and I think it would be really sweet to make GHCI itself support plugins e.g. adding a tracer function, debugger easily
03:18:56 <xyzp> @creepy-stalkerbot
03:18:57 <lambdabot> Unknown command, try @listcommands.
03:19:10 <dons> ah, that's a different thing, glimming -- you should look at the ghc-plugins branch
03:19:27 <Lunar^> dons: I'm starting to be affraid.. he was never off the IRC for so long
03:19:38 <dons> plugins for the compiler, rather than plugins for user code.
03:19:52 <dons> Lunar^, yeah. me too. but this blog rumour seems to be ok.
03:19:57 <dons> though I'd like to see a url..
03:21:00 <Lunar^> http://www.scannedinavian.com/index.html
03:21:23 <halcyon10> good morning all
03:21:55 <Lunar^> dons: the actual comment is date 8th
03:22:06 <musasabi> http://www.scannedinavian.org/~shae/blog/
03:23:08 <dons> @timein stockholm
03:23:11 <lambdabot>  Sunday, May 15, 2005 at 12:24:11 PM CEST
03:23:43 <dons> oh, but there's a post  from Wed.
03:24:44 <dons> but that looks like what he's doing "Ok then, no more IRC until FLM 0.1 is finished."
03:25:14 <dons> we will have to entertain ourselves :}
03:25:18 <dons> @yow
03:25:19 <lambdabot> Yow!  Are you the self-frying president?
03:26:47 <basti__> hmm
03:30:44 <boegel> @seen mt
03:30:45 <lambdabot> I haven't seen mt.
04:44:18 <TheHunter> @docs Language.Haskell.Hsx
04:44:19 <lambdabot> Language.Haskell.Hsx not available
04:50:13 * TheHunter hates chasing dependencies.
04:53:17 <dons> check the README. it's nibro's better .hs parser library -- to be integrated into fptools soon.
04:54:28 <TheHunter> yeah i figured that out, now i'm installing ctk...
04:54:50 <dons> lotsa deps! what needs ctk?
04:54:56 <TheHunter> c2hs
04:55:13 <dons> oh, that's right.
05:01:42 <TheHunter> *** Installing packages...
05:01:52 <TheHunter> *** Installing packages...
05:02:12 <TheHunter> oh, great the new xchat-version is broken, too.
05:02:26 <TheHunter> ctk-0.26.0# make install
05:02:26 <TheHunter> *** Installing packages...
05:02:31 <TheHunter> what the hell is that?
05:06:51 <TheHunter> ah, the configure script chose nhc98.
05:11:25 <TheHunter> dammit!
05:16:30 <TheHunter> is there a way to install debian packages without there dependencies without rendering apt-get useless?
05:17:49 <TheHunter> s/there/their/
05:23:04 <TheHunter> someone ever successfully installed ctk?
05:24:28 <skew> TheHunter: I think "there" is the correct usage
05:25:06 <skew> I think I've tried CTK sometime
05:25:23 <TheHunter> skew, oh, i meant the second "there" which must be completely wrong.
05:25:40 <glimming> How do I simplify (>> id) . fmap eta . p ?
05:25:43 <TheHunter> i can't install it
05:25:47 <skew> ordinarily I would try it now, but I'm in the middle of updating ~300 outdated packages on my system
05:25:54 <TheHunter> @pl  (>> id) . fmap eta . p
05:25:55 <lambdabot> (>> id) . fmap eta . p
05:26:13 <skew> (>> id)?
05:26:14 <glimming> viva the Brain
05:26:19 <skew> what kind of monad are you in?
05:26:31 <glimming> unspecified.
05:26:34 <glimming> any monad
05:26:42 <skew> @type (>>)
05:26:43 <TheHunter> glimming, you sure you don't mean (>>= id) ?
05:26:45 <lambdabot> (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m
05:26:45 <lambdabot> b
05:26:49 <TheHunter> @pl  (>>= id) . fmap eta . p
05:26:50 <lambdabot> (eta =<<) . p
05:27:14 <skew> your monad type m a must unify with b->b if you really mean >>id
05:27:53 <skew> a >>= id == a is one of the monad laws, IIRC
05:28:30 <integral> don't you mean a >>= return . id == a ?
05:28:34 <glimming> oops >>= id
05:28:40 <skew> oh, right
05:28:41 <TheHunter> @pl a >>= return
05:28:42 <lambdabot> a
05:28:56 <skew> >>= id is join
05:29:21 <glimming> yes, but I don't want it in that form
05:29:30 <glimming> I want to prove the Kleisli law for unit
05:29:32 <glimming> left unit
05:29:40 <glimming> ASSUMING the join law (monoid form)
05:30:06 <glimming> @pl  (>>= id) . fmap eta . p
05:30:07 <lambdabot> (eta =<<) . p
05:30:12 <glimming> But what is =<<
05:30:20 <TheHunter> @pl flip (>>=)
05:30:22 <skew> it's just >>= written the other way around, I think
05:30:22 <lambdabot> (=<<)
05:30:29 <glimming> so what is flip?
05:30:35 <skew> flip f a b = f b a
05:30:36 <glimming> flip f a b = f b a ?
05:30:36 <TheHunter> @pl flip f x y
05:30:38 <lambdabot> f y x
05:30:42 <glimming> I was faster! ;-)
05:31:10 <glimming> (experiment- was I? In my window it popped up before your, skew, did it on others as well?)
05:31:18 <glimming> (nondeterminism)
05:31:23 <TheHunter> skew won here.
05:31:31 <skew> I saw mine first
05:31:36 <glimming> argh
05:31:57 <skew> if you are trying to prove the law, I would start in monad form
05:32:09 <basti_> i sak glimming first
05:32:11 <skew> then, use the definition m >>= f == join (fmap f m)
05:32:12 <glimming> I might need to do both directions.
05:32:16 <basti_> w
05:32:31 <skew> then, work with the join laws, then use the identity the other way
05:32:58 <glimming> skew, last line did I do not understand
05:33:21 <glimming> What is the type of do do do do return () ?
05:33:41 <basti_> :-O
05:33:51 <skew> we have referential transparency, so you can use the definition of (>>=) to turn join (fmap f m) into m >>= f as well as the other way around
05:33:52 <glimming> Prelude> :t do do do do return ()
05:33:52 <glimming> do {...} :: Monad a => a ()
05:34:26 <glimming> But I was probably going to postcompose with p here which means that I had to assume epic etc and I can't to work in both directions simultaneously.
05:34:33 <glimming> But maybe the other direction works more easily.
05:34:57 <skew> Oh, I was just talking about being able to put things back into monad form
05:35:13 <glimming> precompose with p, sorry
05:35:15 <skew> but isn't the law you are trying to prove just an equality?
05:35:20 <glimming> indeed.
05:35:34 <glimming> but they are different RHS and different LHS's on the two laws
05:35:43 <glimming> there
05:36:37 <glimming> if you have nothing better to do, do do do do return undefined
05:37:12 <glimming> Yes...
05:37:16 <glimming> I have a law t_1 = t_2
05:37:21 <glimming> and want to deduce s_1 = s_2
05:37:26 <glimming> I cannot reason t_1 =.... s_1
05:37:30 <glimming> onlyt
05:37:41 <glimming> s/t//
05:39:56 <Tommy> hi guys, I've got  a problem with a small haskell program, that defines its own datatype for arithmetic expressions. Can anyone help me?
05:40:14 <musasabi> probably..
05:40:17 <glimming> can @pl show trace?
05:40:54 <glimming> I'd like to set @pl free and extend it.
05:41:04 <glimming> there is MAG of course.
05:41:07 <TheHunter> @pl only simplifies expressions.
05:41:08 <lambdabot> (line 1, column 29):
05:41:08 <lambdabot> unexpected end of input
05:41:08 <lambdabot> expecting white space or simple term
05:41:09 <glimming> You could plug your @pl to mag.
05:41:18 <glimming> ;-)
05:41:23 <Tommy> one moment, i'll show you the source.
05:41:38 <TheHunter> Tommy, http://hbin.dyndns.org/
05:41:40 <glimming> Magdalen college in Oxford ==> MAG
05:42:10 <TheHunter> glimming, so which law do you wanna proof?
05:42:31 <glimming> @pl (>>= d). fmap eta. p
05:42:31 <lambdabot> (d =<<) . fmap eta . p
05:42:39 <glimming> do do do do return undefined
05:42:50 <glimming> @pl (>>= id). fmap eta. p
05:42:51 <lambdabot> (eta =<<) . p
05:42:51 <glimming> sorry
05:42:59 <glimming> I need this to be p
05:43:04 <Tommy> thx ... and done
05:43:19 <Tommy> should be up now:-)
05:43:38 <Lemmih> URL?
05:43:47 <Tommy> http://hbin.dyndns.org/pastebin/47.html
05:43:50 <glimming> Take the left unit law in monoid form
05:43:52 <Tommy> sorry:-)
05:43:57 <glimming> I want to derive the left unit form in Kleisli form
05:43:58 <glimming> and so on
05:44:59 <glimming> What's the greatest name of a software development company?
05:45:04 <glimming> I came across VITO Technology
05:45:10 <glimming> VITO being latin meaning "avoid"
05:45:26 <glimming> and also being Finish and meaning (harshly) feminine genitals
05:45:32 <glimming> This is a russian company.
05:45:42 <glimming> Needless to say, there customer service sucks.
05:45:58 <basti_> lol
05:47:22 <TheHunter> (>>= id) . fmap eta . p === (join . fmap id) . fmap eta . p === join . eta . p === p
05:47:52 <TheHunter> the last "eta" meaning "fmap eta"
05:47:58 <Tommy> Lemmih: any hints?
05:48:47 <glimming> yes
05:48:53 <glimming> in fact I started from your RHS! ;-)
05:49:02 <glimming> So we are sort of equationally back to where we begun.
05:49:05 <glimming> Which is reassuring.
05:49:33 <Lemmih> Tommy: Is Aexpr an instance of Num?
05:49:48 <Lemmih> Tommy: Otherwise you can't compare it with a number.
05:51:53 <Tommy> Lemmih: Not at all, and my haskell-Know-How is very limited:-) How do i declare??
05:52:40 <Lemmih> You probably don't want to.
05:53:52 <Tommy> might be right... but hugs tells me: ERROR "simplify.hs":4 - Instance of Num Aexpr required for definition of simplify
05:54:06 <glimming> Nah, TheHunter your proof is not circular I think
05:54:46 <Lemmih> Instead of filtering '0' you should filter 'Con 0'.
05:56:34 <TheHunter> join . fmap eta === id is the law you find in every CT book, so i prooved (>>= id) . fmap eta . p === p, but i'm not sure if that's what you wanted.
05:57:03 <Tommy> sure, you are right ... then hugs tells me: ERROR "simplify.hs":4 - Instance of Eq Aexpr required for definition of simplify
05:57:20 <glimming> so let's prove mu.fmap eta = id as well then
05:57:32 <Tommy> alright, it works now:-) thx a lot
05:57:34 <glimming> i.e. join . liftM eta = id
05:57:39 <glimming> oops.
05:57:43 <glimming> join . liftM return = id
05:57:44 <Tommy> just added ... deriving (Show,Eq)
05:57:52 <glimming> @pl join . liftM return
05:57:53 <lambdabot> id
05:57:56 <glimming> wow
05:57:58 <glimming> I am impressed
05:58:05 <Lemmih> Tommy: Great.
05:58:06 <glimming> I really want tracing for this one!
05:58:15 <glimming> TheHunter, add a tracing monad?
05:58:37 <glimming> I.e.   123 = {def of ...} = ... = {def of ...} = blal = {beta red} = RESULT
05:58:42 <glimming> This ought to be in ghci as well
05:59:04 <glimming> did you write @πl from Bird's book?
05:59:10 <TheHunter> optimize :: Expr -> [Expr], so tracing should be easy.
06:00:05 <TheHunter> i did it on my own, so it's much less general than you might expect.
06:01:37 <Tommy> Lemmih: one last qestion:-) I added two lines, see http://hbin.dyndns.org/pastebin/48.html
06:01:56 <Tommy> now hugs tells me: ERROR "simplify.hs":7 - Undefined variable "a"
06:02:41 <glimming> so how did @pl prove join.liftM return ?
06:02:47 <skew> Tommy: that's not a pattern match
06:02:51 <TheHunter> one sec.
06:02:58 <skew> you want [a] <- relargs
06:03:16 <Lemmih> Tommy: (==) is a normal function.
06:03:28 <skew> relargs == [a] is passing relargs and [a] to the == function
06:03:35 <skew> except a is undefined
06:03:40 <skew> this isn't curry :)
06:04:16 <skew> curry was a logic language based on Haskell
06:05:39 <TheHunter> hmm, where's my libreadline?
06:06:32 <glimming> TheHunter, how did you deduce (>>= id) = (mu.fmap id) ?
06:06:40 <glimming> of course
06:06:41 <glimming> sorry
06:06:43 <TheHunter> that's the definition of (>>=)
06:06:50 <glimming> no
06:06:55 <glimming> mu == >>=id
06:06:57 <glimming> fmap id is just lifted id
06:07:05 <TheHunter> that's what @pl does:
06:07:08 <TheHunter> join . liftM return
06:07:08 <TheHunter> (return =<<)
06:07:08 <TheHunter> id
06:07:42 <TheHunter> there's a rule join . fmap f ==> (=<<) f and (=<<) return ==> id
06:07:50 <Tommy> Lemmih: What does that mean :-)
06:09:25 <Lemmih> Tommy: That means that you can't compare something to an undefined value.
06:09:51 <Lemmih> eg. 'putStrLn a' doesn't make sense if 'a' isn't defined.
06:09:57 <dcoutts> @seen vidvandre
06:09:58 <lambdabot> I saw vidvandre leaving #haskell 14 hours, 46 minutes and 13 seconds
06:09:58 <lambdabot> ago.
06:11:59 <glimming> TheHunter
06:12:03 <glimming> Your proof is not ok
06:12:10 <glimming> You use the result in the proof.
06:12:21 <glimming> I am wanting to DERIVE the monoid form unit law.
06:12:24 <glimming> Not use it in the proof.
06:12:34 <Tommy> Lemmih: *argh* How do I express that there is a list with just one value?
06:13:06 <TheHunter> glimming, ah ok, that was the proof of the opposite direction
06:13:13 <Lemmih> Tommy: Use pattern matching (like skew said).
06:13:25 <glimming> hmm, W8 I am not so quick
06:13:52 <basti_> Tommy: type wise or value wise?
06:13:58 <glimming> indeed
06:15:12 <dcoutts> musasabi, re gtk2hs: symptoms? Does your machine have less than 400Mb ram?
06:15:21 <TheHunter> join . return === (=<<) id . return === \x -> return x >>= id === \x -> id x === id
06:15:36 <TheHunter> using the laws from http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AMonad
06:23:04 <Tommy> alright, it works now:-) For everyone interested see http://hbin.dyndns.org/pastebin/49.html
06:23:58 <Pegazus> hi, is it possible to make a function IsPermutation :: [Int] -> [Int] -> Bool? without any aux function?
06:24:49 <TheHunter> check out Data.List.sort
06:28:22 <TheHunter> @pl uncurry (const id)
06:28:23 <lambdabot> uncurry (const id)
06:28:26 <TheHunter> arggh!
06:35:46 <musasabi> dcoutts: no it has 512mb, the build process was taking ~480mb with ghc 6.4 and there was ~100mb of other software -> oom killer kicked in.
06:36:02 <resiak> Hmm. I found the ghc-6.4 patch for gtk2hs, but I suspect that it won't play nicely with the overlays (I have a mere quarter-gig of ram). Anyone have a convenient Debian package?
06:36:41 <dcoutts> resiak, the two should be orthogonal, try applying the patch first then unpacking the overlay
06:37:55 <dcoutts> musasabi, hmm, try the [ make HSTOOLFLAGS="-H380m -M380m" ] thing to limit the heap usage
06:38:18 <dcoutts> musasabi, we're you ussing the gentoo ebuild? I forget
06:39:30 <dcoutts> resiak, but if you can pester the debian folk to build a debian package, that'd be great. they're still stuck at 0.9.6 (and we're getting close to 0.9.8 now! :-) )
06:40:19 <resiak> dcoutts: I'm in the process of getting onto the appropriate lists :)
06:40:33 <resiak> dcoutts: Their packages don't even work any more, since they depend on a ghc older than that in Sarge.
06:41:04 <dcoutts> ho hum :-(
06:43:27 <dcoutts> musasabi, so if that limit is still not enough (given how much other software is running at the same time) you can also try the overlay method: http://haskell.org/gtk2hs/archives/2005/04/29/building-on-machines-with-less-ram/
06:44:46 <dcoutts> but it should build ok on a 512Mb machine, though you may need to close down evolution, mozilla and OpenOffice to get enough free ram. :-)
06:44:59 <basti_> uhm
06:44:59 <basti_> @ping
06:44:59 <Igloo> dcoutts: What are the disadvantages of the overlay method OOI?
06:45:01 <lambdabot> bzzt
06:45:25 <basti_> hi?
06:45:25 <basti_> am i live?
06:45:48 <dcoutts> Igloo, it means you don't have to run c2hs, but you use the output of c2hs from another machine
06:45:55 <TheHunter> ahh, @ping --> @kind
06:45:58 <skew> basti_: I see you
06:46:06 <basti_> great.
06:46:09 <Igloo> OK, ta
06:46:16 <dcoutts> but it means the version of gtk+ has to be the same
06:46:22 <basti_> I experienced some lockup
06:46:23 <Igloo> Oh, hmm
06:46:38 <resiak> dcoutts: Seems to be building. Where do I post beverage_of_your_choice? :)
06:46:56 <dcoutts> and it probably would not work between OSs, eg between Linux, FreeBSD, etc
06:47:16 <Igloo> Packaging something in a way that it needs 512M of RAM to build for Debian isn't really ideal  :-)
06:47:20 <skew> can c2hs be fixed?
06:47:54 <dcoutts> resiak, send beverage_of_your_choice to Igloo or one of the other DDs here to persude them :-)
06:48:10 <dcoutts> Igloo, the debian build machines don't have 512Mb ram?
06:48:26 <Igloo> The m68ks have at most 192M I think
06:48:44 <dcoutts> skew, we'd love to fix c2hs but it's quite hard, help is always apreciated :-)
06:48:54 * Igloo has things like fixing ghc on my list before I think about gtk2hs
06:49:00 <dcoutts> we're looking into alternatives too (not to c2hs, but other cunning hacks)
06:49:24 <skew> how about splitting the header files into pieces?
06:49:27 <dcoutts> Igloo, it probably will not build on m68ks anyway :-)
06:49:36 <Igloo> How come?
06:49:59 <dcoutts> well, it might but no one has ever tried, does ghc work there ?
06:50:05 <Igloo> Yes
06:50:12 <dcoutts> well done :-)
06:50:43 <dcoutts> I'm not even sure I know what an mk68 is :-)
06:51:10 <dons> a pre 1995 macintosh!
06:52:03 <dcoutts> ha, and people still want to run linux on these things I suppose.
06:52:12 <dons> mine's 11 years old -- and i've never had a failed battery, power supply, hd or anything.
06:52:45 <dons> it's on the network, it filters packets fine. disk is a bit small (1G) and not enough ram really (36m)
06:52:58 <dons> also noisy hdd
06:53:07 <dcoutts> well, if you get gtk2hs to build on it I will definately give you beverage_of_your_choice !
06:53:10 <dons> and, oh, they're kinda slow (36Mhz)
06:53:16 <pipe> hello
06:53:27 <dons> hehehe
06:53:39 <pipe> sup dons
06:53:57 * dons says "time for sleep!"
06:54:04 <pipe> have a good one
06:54:29 <dcoutts> skew, one plan is to distribute the pre-processed .hs files after c2hs has done with them, we think they're almost completely the same between arches
06:55:15 <dcoutts> and the bit's that are not the same (eg field offsets) we'd move into .hsc files (the hsc2hs preprocessor is quick and not ram hungry)
06:56:13 <dcoutts> and then finally, to deal with the gtk version problem, we could run the cpp preprocessor over the .hs files after they have gone through c2hs
06:56:52 <dcoutts> that way we could end up with .hs (& .hsc) files, portable over all arches and gtk versions
06:57:21 <dcoutts> but it'd be quite a bit of work to change c2hs & build system etc
07:00:08 <glimming> @pl fmap f (a >>= id)
07:00:09 <lambdabot> fmap f (join a)
07:02:06 <glimming> can this be reduced? fmap f (a >>= id
07:02:17 <pipe> where is shapr?
07:02:27 <basti_> writing code, allegedly
07:02:28 <basti_> ,)
07:02:49 <pipe> give my regards to that maniac
07:02:57 <pipe> danke
07:03:04 <basti_> what for?
07:03:44 <pipe> i only got one chance to come here now, next time will only be in the distant future
07:03:56 <basti_> thats sad.
07:04:05 <basti_> got married? ;)
07:04:14 <pipe> no, i joined the army :(
07:04:18 <basti_> ahh
07:04:19 <basti_> :(
07:04:32 <glimming> isn't that isomorphic?
07:04:41 <pipe> and the shit keeps getting worse and worse :'( 72 hour perimeter guard totally sucks the ass :'(
07:04:43 <basti_> bisimilar.
07:04:51 <basti_> army sucks.
07:04:58 <basti_> always.
07:04:58 <glimming> oh.
07:05:05 <glimming> so does wives I heard.
07:05:19 <basti_> some do, allegedly.
07:05:47 <basti_> never asked one about that.
07:06:05 <pipe> perimiter guard duty is even worse than basic :(
07:06:22 <basti_> afaics there is only one solution for that
07:06:35 <glimming> at least your are empowered with a gun.
07:06:37 <Lemmih> pipe: Why did you join the army?
07:06:50 <basti_> i think isrealians dont have a choice do they
07:07:36 <pipe> indeed
07:07:45 <Lemmih> That sucks.
07:07:47 <basti_> sucks bigtime.
07:07:58 <basti_> in germany there's drafting too, but you have the alternative to do civil duty
07:07:59 <pipe> it's actually what makes this country so unique
07:08:11 <glimming> I'd like to reason (fmap f . mu) a = ... = a >>= f
07:08:14 <glimming> where mu is join of course
07:08:31 <pipe> but i now suddenly understand why israel society is so fucked up, the army totally ruins all people
07:08:34 <basti_> which is no way as harsh, but still sucks bigtime and does not suit a modern nation.
07:08:37 <glimming> @pl (liftM f. join) a
07:08:37 <lambdabot> fmap f (join a)
07:08:38 <basti_> pipe: yes.
07:09:19 <basti_> saw it with my own eyes.
07:10:09 <pipe> you basiclly have to be an asshole to survive in the army, and so you learn to be one
07:10:36 <basti_> the problem is when people are FORCED to join the army.
07:10:44 <basti_> which is a crime in my opinion
07:11:34 <basti_> i dont have any problem with a club of assholes...
07:11:42 <pipe> i think it has good aspects, like forced education
07:13:06 <basti_> you can educate people without breaking their minds
07:13:12 <basti_> you even SHOULD
07:13:35 <pipe> did you go to high school? :)
07:13:58 <skew> only physically :)
07:14:01 <basti_> heheh
07:14:16 <basti_> education was a waste of time imo.
07:14:39 <basti_> but it didn't break my will, or make me an asshole or something
07:15:36 <pipe> it doesn't really make you into an asshole, it actually makes you more considerate deep down, but it kills all the manners you may have had and stuff
07:16:06 <basti_> manners isnt a problem
07:16:14 <basti_> it IS a problem when people tell you "don't think, do what I say"
07:16:26 <basti_> (and have the power to make you do"
07:16:50 <pipe> israel army is not like what you see in the movies about american army :)
07:17:05 <pipe> you can refuse any order and the worse thing that can happen to you is jail, after you get a trial
07:17:14 <basti_> well yes.
07:17:23 <basti_> i mean its like that everywhere isnt it?
07:17:30 <pipe> in us of a they can hit you and shit
07:17:31 <basti_> isnt that "having the power to make you do"?
07:17:39 <basti_> only in the movies i think
07:18:04 <basti_> i *really* see it as a problem when people take your free will by threatening you with putting you in jail
07:18:19 <basti_> in fact, if it wouldn't be the army, this would be a crime in most states
07:19:00 <pipe> i get your point, but it's not really like that... i guess you have to experience it to understand
07:19:20 <basti_> hmm yes of course.
07:19:25 <basti_> it's not like that...
07:19:26 <halcyon10> thats why you agree to loose some of your human rights when you become a soldier
07:19:40 <basti_> you dont even doubt that it would be possible NOT to do what your boss says :)
07:19:55 <basti_> in other contexts, this would be "hypnosis"
07:20:04 <basti_> halcyon10: well IF you agree. What if you're made soldier
07:20:08 <pipe> dude it's not like that at all
07:20:08 <basti_> wanna move to #politics?
07:20:12 <basti_> btw.
07:20:22 <wilx> basti_, hypnosis cannot make you do anything you wouldn't do.
07:20:31 <pipe> it's not like a stand up like a stick and shout "YES SIR!" at everything the commander says
07:20:42 <basti_> wilx: i know.
07:20:45 <wilx> It is urban myth that you can make a person do whatever you want in hypnosis.
07:20:49 <basti_> wilx: i know.
07:20:52 <wilx> :)
07:20:54 <wilx> Ok.
07:21:00 <wilx> Carry on, private :)
07:21:06 <basti_> lol
07:21:16 <pipe> even in basic everyone was arguing with the commander and yelling at the bitch and stuff
07:21:21 * basti_ is on #politics
07:22:38 <Pegazus> how to power in haskell?
07:23:15 <basti_> ** works in some contexts i think
07:23:23 <Lemmih> @plugs 2^64
07:23:25 <lambdabot> 18446744073709551616
07:23:31 <Pegazus> thx
07:23:53 <skew> ^, ^^, or **
07:24:38 <skew> ^ takes any number to a non-negative integral power
07:24:56 <halcyon10> basti: i also think it would be better if the default wouldn't be to send young men to the army and if they don't want they have to prove why they can't but if you had to prove why you want to the army and teached in weapons
07:25:20 <skew> ^^ takes a rational number to an arbitrary integer power
07:25:25 <basti_> halcyon10: #politics, i didnt understand that sentence
07:25:33 <skew> and ** takes a real number to a real power
07:25:48 <pipe> btw: israel army is mandatory for women also
07:26:39 <TheHunter> glimming, "fmap f . join === (=<<) f" doesn't typecheck and "fmap f . join === fmap ((=<<) f)" does not hold.
07:28:08 <glimming> oops
07:34:32 <glimming> TheHunter, Just as we gave the translation from Kleisli-style to monoid-style
07:34:32 <glimming> above (this is the join function!), we can also go the other direction, in which case we define |a
07:34:36 <glimming> >>= f = (fmap f . mu) a|. This equality can
07:34:38 <glimming> also be proved assuming the definition of |mu| in terms of |>>=|, by
07:34:41 <glimming> calculating, I hope.
07:35:27 <glimming> s/|// in the text it's for lhs2TeX-enabled humans
07:36:25 <TheHunter> sure, the definitions are all equivalent.
07:38:19 <Pegazus> how to use where clause?
07:38:40 <Lemmih> @plugs let x = y where y = 10 in x
07:38:41 <lambdabot> 10
07:38:47 <glimming> And that's what I am trying to do for the moment.
07:39:05 <glimming> But I assume the definition of >>= in terms of mu  and try to DERIVE the other way around.
07:39:07 <Pegazus> can i put it at the end of the function?
07:39:08 <glimming> rather than defining it.
07:39:10 <Pegazus> or something like that?
07:39:26 <TheHunter> which law?
07:39:32 <Pegazus> palabraMasLarga :: [Char] -> [Char]
07:39:32 <Pegazus> palabraMasLarga [] = []
07:39:32 <Pegazus> palabraMasLarga xs | (long SiguientePalabra) >= (long SiguenteMasLarga) = SiguientePalabra
07:39:32 <Pegazus> palabraMasLarga xs | otherwise = SiguenteMasLarga
07:39:32 <Pegazus> where SiguientePalabra = primeraPalabra xs
07:39:32 <Pegazus> where SiguenteMasLarga = (palabraMasLarga (ultimasPalabras xs))
07:39:41 <Pegazus> whats wrong with those wheres??
07:41:01 <Lemmih> Remove the function name before the 'otherwise' guard, strip the second 'where' keyword and use proper indentation.
07:41:42 <Lemmih> And variable must start with a lower case letter.
07:41:46 <Pegazus> what means proper indentation?
07:41:47 <Pegazus> thx
07:42:19 <Pegazus> how do i indent the wheres?
07:43:06 <Pegazus> and how do i put 2 wheres in the same function?
07:43:14 <glimming> Aha
07:43:24 <Lemmih> Pegazus: Just like you do with let.
07:43:32 <Pegazus> i dont know how to use let :)
07:43:38 <Pegazus> palabraMasLarga :: [Char] -> [Char]
07:43:39 <Pegazus> palabraMasLarga [] = []
07:43:39 <Pegazus> palabraMasLarga xs | (long siguientePalabra) >= (long siguenteMasLarga) = siguientePalabra
07:43:39 <Pegazus> | otherwise = siguenteMasLarga
07:43:39 <Pegazus> where siguientePalabra = primeraPalabra xs;
07:43:40 <Pegazus> siguenteMasLarga = (palabraMasLarga (ultimasPalabras xs))
07:43:41 <glimming> a >>= f = (fmap f . mu) a   taken as a law rather than definition
07:43:41 <Pegazus> i have that
07:43:45 <Pegazus> with palabraMasLarga :: [Char] -> [Char]
07:43:46 <Pegazus> palabraMasLarga [] = []
07:43:48 <Pegazus> palabraMasLarga xs | (long siguientePalabra) >= (long siguenteMasLarga) = siguientePalabra
07:43:50 <Pegazus> | otherwise = siguenteMasLarga
07:43:52 <Pegazus> where siguientePalabra = primeraPalabra xs;
07:43:54 <Pegazus> siguenteMasLarga = (palabraMasLarga (ultimasPalabras xs))
07:43:56 <Pegazus> sorry
07:43:58 <Pegazus> haha
07:43:58 <Lemmih> Pegazus: Please don't spam.
07:44:00 <Pegazus> xD
07:44:07 <Pegazus> the | and the where are aligned
07:44:08 <basti_> there's paste pages for that btw.
07:44:09 <Pegazus> sorry
07:44:15 <Pegazus> where can i paste the code?
07:44:17 <Pegazus> wheres the link?
07:44:17 <basti_> lisppaste2: @url
07:44:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:44:23 <Lemmih> @paste
07:44:23 <Pegazus> thx
07:44:24 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:44:42 <Lemmih> Others can edit the code if you paste to the wiki.
07:44:49 <lisppaste2> Pegazus pasted "Haskell" at http://paste.lisp.org/display/8275
07:45:26 <Pegazus> there it is
07:45:54 <Pegazus> (unexpected symbol "siguenteMasLarga")
07:46:17 <Lemmih> Pegazus: Indent 'siguenteMasLarga' to the same level as 'siguientePalabra'.
07:46:25 <Pegazus> thx
07:46:42 <Pegazus> how to get the length of a list?
07:46:54 <Lemmih> @plugs length [1..10]
07:46:55 <lambdabot> 10
07:47:00 <Pegazus> thx
07:47:13 <basti_> it even works for all types!!
07:47:18 <basti_> :)
07:48:50 <glimming> Here is a question about lhs2TeX
07:49:00 <glimming> How do I write backslash inside |...| ?
07:49:18 <Pegazus> haha thx
07:49:34 <Pegazus> another question, how to do "polymorhpics" or template functions? with generic type T?
07:50:33 <Lemmih> What are you trying to do?
07:50:38 <Pegazus> cuentaElemento :: Int -> [Int] -> Int
07:50:43 <thou> data T a = C a | K
07:50:49 <Pegazus> that i want to work like cuentaElemento :: T -> [T] -> Int
07:50:53 <Pegazus> with any type...
07:51:12 <thou> just don't specify a type, and then ask haskell for the type of your function
07:51:26 <Pegazus> how do i make that?
07:51:30 <thou> it will tell you the more general type
07:51:32 <thou> use ghci
07:51:39 <Lemmih> Or Hugs.
07:51:44 <thou> and say ":t cuantaElemento"
07:51:52 <Pegazus> what?
07:51:55 <Pegazus> i use hugs
07:52:14 <glimming> Project idea:
07:52:31 <glimming> make lhs2TeX a generic preprocessor for theorem provers, Haskell, SML, Haskell extensions etc etc
07:52:39 <glimming> a framework for literate TeX programming
07:52:54 <Lemmih> Pegazus: Have you loaded the code into Hugs?
07:55:02 <Pegazus> yes
07:55:13 <Pegazus> how to convert 1 to '1'=
07:55:15 <Pegazus> ?
07:55:36 <Lemmih> @plugs show 1
07:55:37 <lambdabot> "1"
07:55:43 <Pegazus> nono but in code
07:56:07 <Lemmih> I don't follow...
07:56:18 <Pegazus> i have an int and i need to return it as a char
07:56:19 <TFK> Pegazus, show 1 will return the string representation.
07:56:27 <Pegazus> amm thx :)
07:56:37 <TFK> Pegazus, so, map show [1,2,3] => ["1", "2", "3"]
07:56:38 <Pegazus> i thought it was just for showing
07:56:41 <Pegazus> thx
07:57:15 <Igloo> I think there's also a function for single digits to Chars
07:57:18 <TFK> Note that it will give a string, not a char
07:57:22 <Lemmih> Pegazus: Are you reading a Haskell tutorial?
07:57:39 <Pegazus> <Lemmih> nope :)
07:57:41 <Pegazus> sorry hehehe
07:57:47 <Pegazus> but i learn quite fast, dont worry ;-)
07:58:49 <Pegazus> yeah, it compiled :) thx!
08:04:29 * resiak fights import directories.
08:05:37 <Pegazus> how to cast from '1' to 1?
08:06:23 <glimming> i.e. how to use backslash in inline lhs2TeX code?
08:06:47 <glimming> kosmikus?
08:07:03 <glimming> the magic word...
08:07:19 <skew> Pegazus: use read
08:07:35 <skew> class Read a where read :: String -> a
08:07:41 <skew> more or less
08:07:51 <Pegazus> thx
08:09:12 <glimming> @seen kosmikus
08:09:13 <lambdabot> kosmikus is in #haskell. Last spoke 2 days, 14 hours, 13 minutes and
08:09:13 <lambdabot> 27 seconds ago.
08:09:20 <glimming> darn.
08:11:43 <Pegazus> is this valid 0 <= n <= 10 ?
08:12:19 <Lemmih> No.
08:12:54 <Pegazus> k
08:13:43 <resiak> dcoutts: Thanks for your help -- it's all working perfectly.
08:16:16 <Pegazus> is this valid 0 <= n <= 10 ?
08:16:19 <Pegazus> sorry
08:16:32 <Lemmih> Still not valid (:
08:16:40 <Pegazus> haha
08:17:03 <autrijus> so I'm writing a proposal to Euro Oscon for a talk on "Learning Haskell" in the Emerging Topics track.
08:17:18 * resiak runs down to Jericho and gives dcoutts a beer.
08:17:41 <autrijus> I started with some old boring intro:
08:17:42 <autrijus> "Haskell is an emerging general-purpose functional language, with unique features that enables extremely rapid development of bug-free, concise and maintainable code.  This talk shows how to apply Haskell to day-to-day tasks, and tips for integrating it with other languages.
08:17:58 <autrijus> but now I can't carry on with this, so I wrote this instead:
08:18:00 <autrijus> "What's as fast as C++, as concise as Perl, as regular as Python, as flexible as Ruby, as typeful as Java, and has absolutely nothing in common with PHP?  It's Haskell!
08:18:11 <autrijus> ;)
08:18:15 <resiak> Heh.
08:18:48 <Pegazus> ?????
08:19:03 <Pegazus> as fast as c++?
08:19:03 <chucky> autrijus: "as typeful as Java" seems a bit insulting to Haskell's type system. :)
08:19:05 <Pegazus> is that a joke?
08:19:40 <skew> Pegazus: if you want to play around with stuff like mutableByteArray#, you can be
08:19:47 <TFK> autrijus, since when is Haskell as fast as C++?
08:19:58 <TFK> You're welcome to prove this assertion on SPOJ :-)
08:19:59 <skew> but that is stretching things a bit...
08:20:03 <autrijus> SPOJ?
08:20:09 <Pegazus> mutableByteArray# what the hell is that?
08:20:18 <Lemmih> Pegazus: It's a mutable byte array.
08:20:21 <TFK> Lord, didn't I spam enough the link already? :-P spoj.sphere.pl
08:20:23 <Pegazus> what does that means?
08:20:31 <skew> char*
08:20:36 <Pegazus> so?
08:20:51 <TFK> Anyway, it's kinda pointless to claim that Haskell is faster than C++, only when you turn the language inside-out.
08:21:00 <autrijus> TFK: well, in my day job I write things like http://perlmonks.org/?node_id=450426 all the time:)
08:21:05 <Pegazus> i doubt really much you can make any program that runs faster or equal in haskell than in c++ (if you do it properly on both)
08:21:37 <autrijus> and even if written that way, it is still a lot more concise and robust than the equivalent C/Perl code, imvvho :)
08:21:55 <Pegazus> what do you mean by robust?
08:22:07 <autrijus> robust, as in very hard to make errors by mistake.
08:22:23 <TFK> autrijus, what does it do?
08:22:26 <Pegazus> in c++ if you do things right, its also very robust...
08:22:39 <autrijus> TFK: it randomly shuffles lines of a file.
08:22:53 <TFK> I suppose it's pretty robust if you don't rape the type system and don't use pointer arithmetic. Right?
08:23:11 <Pegazus> you dont need pointer arithmetic at all in C++
08:23:16 <TFK> Oh. Looks pretty short.
08:23:25 <Pegazus> and what do you mean by rape the type system on c++?
08:23:45 <TFK> I could do this in a few lines of Python :3 but of course I can't vouch for the performance.
08:23:53 <Lemmih> Pegazus: Learning Haskell before voicing your opinion on it would be wise.
08:23:56 <Pegazus> i could do that in more or less the same lines on C++
08:24:03 <Pegazus> and it will rape you in speed
08:24:04 <Pegazus> :)
08:24:35 <Pegazus> haskell is really nice for a lot of things, i dont say it isnt
08:24:41 <Pegazus> but you can't compare its speed against c++
08:24:48 <Pegazus> its totally nonsense....
08:24:49 <TFK> As Lemmih said, do you actually know Haskell?
08:24:55 <Pegazus> some :)
08:25:01 <TFK> Define "some" :-)
08:25:13 <Pegazus> some part of the language i know
08:25:19 <autrijus> Pegazus: do you know STUArray and plusPtr as used in my program? :)
08:25:21 <Pegazus> anyway, i know more or less its capabilities....
08:26:03 <glimming> Can TheHunter justify the last step in      fmap f . mu
08:26:03 <glimming>   == {- definition of |mu| -}
08:26:03 <glimming>      fmap f . (>>= id)
08:26:03 <glimming>   == {- -}
08:26:03 <Pegazus> haskell will never compete against c++ in speed
08:26:03 <glimming>      >>= f
08:26:23 <autrijus> TFK: yeah. later in that thread I also said it's far easier to throw together the same thing in python/perl/ruby for far less lines
08:26:42 <Lemmih> Pegazus: How so?
08:26:47 <autrijus> TFK: but chances are they'll be much slower and consume more memory -- anyway perl's is, and I doubt python/ruby is better.
08:26:56 <glimming> @pl fmap f . (>>= id)
08:26:57 <lambdabot> fmap f . join
08:27:26 <Pegazus> c++ is compiled, and type strong and 2342 things that makes its really fast
08:27:36 <Pegazus> one of the fastest languages abaiables, if you dont use just asm
08:27:39 <TFK> Haskell is compiled and is statically typed.
08:27:47 <autrijus> and also has that 2342 things, if you use GHC :)
08:27:59 <Pegazus> haskell syntaxis doesnt allow it to be as fast as c++
08:28:04 <TFK> Or C. Or Fortrant.
08:28:07 <Lemmih> Pegazus: How so?
08:28:08 <Pegazus> the "Maybe" type
08:28:12 <Pegazus> or those things
08:28:17 <autrijus> Pegazus: again, do you know what STUArray and plusPtr does in Haskell?
08:28:25 <Pegazus> surely it is a pointer
08:28:29 <Pegazus> and a array of i dont know what
08:28:49 <autrijus> yeah. an array of unboxed, imperative values
08:28:53 <TFK> Hmm... from random import shuffle; lines = open("myfile"); shuffle(lines); open("myfile_shuffled").write(''.join(lines)) # autrijus, can you benchmark that as well? :3
08:29:03 <autrijus> so they are compiled down to C--, then to C
08:29:15 <Pegazus> so?
08:29:18 <pipe> can't you make something similiar to IO monad that is like an assembly language, and then have a specialized haskell compiler that translates this directly to real asm? :D :D
08:29:19 <autrijus> and the resulting code is quite close as if it's written in C. :)
08:29:27 <thou> gah
08:29:30 <Pegazus> what?
08:29:30 <pipe> haskell can now be as fast as asm!
08:29:33 <autrijus> pipe: you can use FFI to #include C code that has inline asm :)
08:29:35 <Pegazus> i doubt that
08:29:45 <autrijus> feel free to benchmark :)
08:29:50 <TFK> *Frotran
08:29:55 <TFK> **Fortran
08:29:58 <Pegazus> make a 3d game in haskell
08:29:59 <Pegazus> :)
08:30:03 <Pegazus> and we benchmark...
08:30:19 <TFK> Hmmm. Can I build custom hardware?
08:30:21 <Lemmih> Haskelll got an excellent OpenGL binding.
08:30:23 <TFK> >:3
08:30:26 <skew> Pegazus: glxgears rewritten in Haskell had exactly the same framerate as the C version
08:30:38 <Pegazus> yes?
08:30:42 <autrijus> Pegazus: done :) http://www.haskell.org/HOpenGL/examples/pk1.jpg
08:30:42 <Pegazus> write a real game with that
08:30:46 <Pegazus> that has big scenarios
08:30:55 <Pegazus> and i will se how good is your btree algorithm...
08:31:08 <TFK> The real bottleneck will be the algorithmics rather than the 3D part.
08:31:14 <TFK> Yes, AI and stuff like that.
08:31:30 <skew> Pegazus: the bigger the program gets, the less proportionally annoying it gets to define a really efficient data structure for the important bits
08:31:32 <Pegazus> and i want to see you do that in haskell fast
08:31:35 <reffie> quake1?!?!?!
08:31:39 * Lemmih thinks Pegazus is just trolling.
08:31:45 <Pegazus> im not trolling
08:31:48 <TFK> What's wrong with btrees in Haskell?
08:31:48 * autrijus just reached the same conclusion :)
08:31:52 <Pegazus> but you cant compare haskell in speed vs c+++
08:31:57 <skew> heck, I want to see you write a huge game in C fast...
08:32:05 <Lemmih> Pegazus: But you are. You have no real Haskell experience at all.
08:32:11 <Pegazus> i have some :)
08:32:12 <Lemmih> skew: (:
08:32:35 <skew> I think Cube was written over a weekend or so
08:32:47 <TFK> What was it written in?
08:32:58 <Lemmih> Pegazus: No you don't. You haven't messed with IO or other imperative features in Haskell.
08:33:25 <Pegazus> Lemmih seriously talking
08:33:35 <Pegazus> do you think that haskell can beat, or even compete with speed against c++?
08:33:40 <halcyon10> Pegazus: that's really not very based on fact
08:34:03 <TFK> Pegazus, seriously talking, there must be empirical data to back up any claim.
08:34:05 <Pegazus> c++ speed is exactly the same as c if you make a good design...
08:34:06 <halcyon10> oops: that refered to an old statement, nm
08:34:10 <skew> Pegazus: just one example, Maybe can generally be totally compiled out by inlining and a case of constructor transform
08:34:22 <skew> leaving you with *ta-da* a conditional jump
08:34:22 <Lemmih> Pegazus: In overall speed, yes. But not in micro benchmarks.
08:34:40 <Pegazus> what do you mean by in micro benchmarks?
08:35:04 <TFK> skew, ah, Cube was written in C++.
08:35:19 <skew> and there's alway the strategy of using the hours you save by not writing the bulk of the program in C to play with fancy algorithms, and to rewrite the critical bits in really really optimized C
08:35:41 <TheHunter> glimming, sure about fmap f . mu ?
08:35:51 <TFK> skew, yeah, that's Python's excuse as well :-P
08:36:04 <basti_> -g-
08:36:10 <skew> that's the idea with just about everything that tries to make it easy to write code
08:36:18 <basti_> if you like C that much why do you want to learn haskell? :)
08:36:21 <skew> I think that was the excuse for C, back in the day
08:36:28 <TFK> Although Python does seek out JITs (so far only Psyco seems to be working). (If you want to write one, we want to use one :-)
08:36:30 <Pegazus> <basti_> who are u talkinG?
08:36:35 <Lemmih> Pegazus: Small benchmarks like those in the Great Language Shootout.
08:36:47 <skew> "It's so much easier to write C that you can write much fancier assembly for the bits that matter"
08:36:49 <basti_> Pegazus: just generally
08:36:49 <TFK> skew, back in the day of the dinosaurs :-P
08:37:00 <Pegazus> <basti_> i dont like c, i like c++
08:37:03 <TFK> skew, I think it was better than Fortran because it supported recursion :-/
08:37:30 <TFK> Of course, they had Lisp back then, and Icon.
08:37:52 <Pegazus> and as far as i know, you can do nearly all in c++ that you can do in haskell (yes, you can do pattern matthinc if you want...) and not the other way
08:37:57 <TheHunter> mu . fmap f === {- Composition -} (=<<) id . (=<<) (return . f) === (=<<) ((=<<) id . return . f) === {- right identity -} === (=<<) (id . f) = (>>= f)
08:38:06 <autrijus> Pegazus: well, check this out: http://shootout.alioth.debian.org/benchmark.php?test=nsieve&lang=all&sort=fullcpu
08:38:22 <TFK> Pegazus, all these languages are Turing Complete, so there is nothing you can do in one but can't do in the other, computationally speaking.
08:38:29 * autrijus likes numbers :)
08:38:30 <Pegazus> i am meaning by the way
08:38:37 <Pegazus> in c++ you can use recursion if you want
08:38:47 <Pegazus> you can do pattern matching, you have lambda functions
08:38:56 <TFK> Really, how?
08:39:00 <Pegazus> you have infinite precicion numbbers...
08:39:04 <Pegazus> how what?
08:39:13 <skew> how about lazy evaluation?
08:39:19 <TFK> (Not that it's relevant; you could build a Haskell interpreter and get pattern matching/lambdas/lazy evaluation that way.)
08:39:22 <autrijus> Pegazus: that url shows that, for the n-sieves problem, Haskell GHC is some 50% faster than C++ :)
08:39:40 <autrijus> (and it performs generally well in other benchmarks as well -- browse for yourself)
08:39:42 <Pegazus> i doubt its has been done correctly on c++
08:39:43 <TFK> I didn't know that C++ has lambda functions.
08:39:50 <Pegazus> <TFK> www.boost.org
08:39:55 <Pegazus> go to boost::lambda...
08:39:59 <TFK> Pegazus, you are welcome to correct their source.
08:40:06 <autrijus> Pegazus: there's full source on that page; you can check it for yourself.
08:40:06 <TFK> Coo, will check it out
08:40:10 <autrijus> it looks correct to me.
08:40:16 <glimming> I prefer TheHunter before @pl
08:40:51 <autrijus> also note that the performance ranking is: Haskell, C, Ada, C++, (and the rest)
08:41:01 <autrijus> so the C++ one is probably not terribly off.
08:41:43 <TheHunter> hrm?
08:42:01 <TFK> Python is ~6-7 times slower :-(
08:42:35 <TFK> 15 lines of Forth o_O
08:42:38 <glimming> ;-)
08:43:07 * autrijus thinks it's time to submit perl6 programs :)
08:43:19 <Pegazus> for (int i=2; i<=m; i++)
08:43:19 <Pegazus> isPrime[i] = true;
08:43:27 <Pegazus> a memset would be a lot faster...
08:43:28 <autrijus> as it stands it's probably at the Java level.
08:43:39 <Pegazus> like up to 8 times fasters or even more...
08:43:47 <autrijus> Pegazus: yes, the C version uses memset.
08:43:50 <autrijus> yet it is still slower than Haskell :)
08:44:16 <Pegazus> yes
08:44:18 <Pegazus> gcc C
08:44:26 <TFK> I do wish they'd use psyco for that benchmark.
08:44:31 <Pegazus> use microsoft Visual c for start, or even better borland one
08:44:57 <autrijus> er. Intel C compiler, generally regarded as quite fast, gives similar results as gcc
08:45:00 <skew> Pegazus: or you could just grab the C intermediate files from GHC as submit those :)
08:45:09 <autrijus> so I doubt visual c and/or borland c will make much difference.
08:45:12 <TFK> autrijus, I don't think that #2 is considered idiomatic Haskell, right?
08:45:20 <TFK> autrijus, because #1 didn't do so well :-/
08:45:22 <glimming> many thanks to TheHunter, you seem to be a clever guy
08:45:22 <autrijus> TFK: neither is memset idiomatic C :)
08:45:24 <Pegazus> <autrijus> intel compiler sux
08:45:29 <Pegazus> gcc too
08:45:41 <Pegazus> the best one is borland surely
08:45:43 <TFK> autrijus, heh, dunno what that is anyway :-P
08:45:48 <glimming> But, what was the last derivation?
08:45:50 <Lemmih> The C code generated with GHC is compiled by GCC so it's pretty fair.
08:45:53 <autrijus> TFK: it's poke :)
08:46:03 <TFK> It's a-what?
08:46:21 <autrijus> @type Foreign.poke
08:46:26 <lambdabot> Foreign.poke :: forall a.
08:46:26 <lambdabot>       (Foreign.Storable.Storable a) =>
08:46:26 <lambdabot>       GHC.Ptr.Ptr a -> a -> IO ()
08:46:36 <glimming> aha
08:46:42 <TheHunter> (=<<) (id . f) = (>>= f) ? That's just syntactic sugar
08:46:44 <TFK> o_O
08:46:47 <glimming> aah
08:46:48 <glimming> GREAT
08:47:06 <Pegazus> 2cond, in place of using bool, you should use int, i think it will be faster (but you would use more memory,...)
08:47:28 * TFK wonders why there is a 'not not m % i' in the Python source code...
08:47:30 <TheHunter> usually, i find it easier to work with (=<<), as thats like the star that lifts kleisli functions.
08:47:32 <thou> TheHunter: but can you justify that sugar?
08:47:38 <thou> :-)
08:47:48 <TheHunter> @pl (=<<) (id . f)
08:47:49 <lambdabot> (f =<<)
08:47:58 <autrijus> Pegazus: so, if Borland C is faster, then GHC can be used to compile with Borland C too, so the speedup is likely similar.
08:48:11 <skew> Pegazus: do you think it is a bad thing that using Haskell you can write both one of the shortest and one of the fastest programs?
08:48:14 <autrijus> Pegazus: but would you grant that, in this case, Haskell's speed is at least _comparable_ to C/C++? :)
08:49:12 <TFK> What about other problems in the shootout, then?
08:49:15 <Pegazus> 3rd, u should put register to all c vars, that speeds up things more than 1000x some times
08:49:32 <TFK> 1000x, that beats assembley :D
08:49:38 <Pegazus> if you do things properly in c/c++ haskell will never compete with tem
08:50:01 <pipe> haskell can theoretically outperform c/c++ :D
08:50:01 <Pegazus> <TFK> 1000x, --> with a properly c compiler you can nearly achive asm speed using naked functions...
08:50:12 <Lemmih> We should all listen to Pegazus. After all, he is the Haskell expert d-:
08:50:14 <Pegazus> <pipe> haskell can theoretically outperform c/c++ :D --> can't
08:50:17 <autrijus> TFK: try this: http://shootout.alioth.debian.org/great/benchmark.php?test=all&lang=ghc&lang2=python&sort=fullcpu
08:50:22 <pipe> pediddle: um... why not?
08:50:33 <TheHunter> @pl join . fmap join
08:50:34 <Pegazus> so?
08:50:35 <lambdabot> (join =<<)
08:50:42 <Pegazus> python sux
08:50:47 <Pegazus> compare it with lua at least
08:50:47 <TFK> Pegazus, I doubt C->Asm gives a thousandfold increase in speed.
08:51:02 <Pegazus> it can
08:51:11 <autrijus> er. I wasn't sure Pegazus was trolling. now I'm convinced :)
08:51:11 <Pegazus> for example you can use stack in place of heap :)
08:51:24 <TFK> autrijus, why are you comparing it to Python?
08:51:30 <TheHunter> @pl (=<<) ((=<<) id)
08:51:31 <lambdabot> (join =<<)
08:52:16 <Lemmih> Pegazus: Such changes makes programs harder to maintain and the extra speed is almost never needed.
08:52:22 <autrijus> TFK: er, was just looking at that in a tab and pasted the url
08:52:31 <Pegazus> <Lemmih> you dont know c++ if you say that :)
08:52:35 <TFK> http://shootout.alioth.debian.org/great/benchmark.php?test=all&lang=ghc&lang2=gpp&sort=fullcpu <--- this one is more interesting :-)
08:53:06 <TheHunter> @pl (=<<) ((=<<) id . id)
08:53:07 <lambdabot> (join =<<)
08:53:20 <TheHunter> c'mon, @pl
08:54:24 <TheHunter> @pl (=<<) id . (=<<) id
08:54:25 <lambdabot> join . join
08:54:40 <autrijus> TFK: the two long white stripes are "objects" using type classes
08:54:49 <autrijus> I'll concede it's not Haskell's forte :)
08:54:55 <autrijus> speed-wise, that is
08:54:57 <TFK> Yeah, I noticed.
08:55:03 <TFK> Kinda pointless doing that in Haskell, no?
08:55:06 <autrijus> but otherwise it fared pretty well
08:55:26 <TFK> What about that "spectral norm" thingie?
08:55:41 <TFK> Then there's word-frequency and spellcheck.
08:55:49 <autrijus> no idea at all
08:56:32 <skew> well, spellcheck code size is 6% of the C version, so a little speed is probably acceptable...
08:56:37 <TFK> And harmonic and heapsort :-)
08:57:10 <autrijus> still I'd call that "comparable", as opposed to "not even comparable" :)
08:57:28 <TFK> Ja
08:57:44 <skew> a factor of 5 is getting a bit slowish
08:58:19 <TheHunter> i guess someone should work on ghc's deforestation.
08:59:50 <skew> when did ghc -v pick up the Glorious?
08:59:50 <TFK> I do wish they'd use Psyco for Python, though.
09:00:25 <autrijus> TFK: there is a Psyco one
09:00:36 <autrijus> # http://shootout.alioth.debian.org/great/benchmark.php?test=all&lang=ghc&lang2=psyco&sort=fullcpu
09:00:39 <TFK> Ah, yes, sorry ^_^;
09:01:48 <TFK> Nice, generally faster
09:02:01 <basti_> TFK: spectra norm is euclidian distance
09:02:47 <TFK> oh
09:02:50 <skew> hmm, not a # to be seen in spellcheck or wordfreq
09:08:03 <skew> maybe somebody should rewrite those examples a bit more
09:12:37 <Pegazus> is there any way to debug a haskell function with hugs'
09:12:58 <basti_> besides testing its parts?
09:13:04 <Pegazus> yes
09:13:28 <Lemmih> Debug.Trace and/or refactoring.
09:13:31 <skew> what do you want?
09:13:38 <Pegazus> debut what?
09:13:44 <Pegazus> @url
09:13:44 <Pegazus> ?
09:13:45 <lambdabot> Maybe you meant: arr pl
09:13:46 <autrijus> "Tired of writing unit tests to cover corner cases?  Let the compuer write it for you with QuickCheck.  Find regex-based parsing unmaintainable?  Learn how to write a complete parser for Perl 6's grammar in 15 minutes with Parsec.  Stuck in deadlocks and racing conditions?  STM solves all your concurrency woes.  XS and Swig gives you headaches?  FFI lets you embed C code quickly and safely.
09:13:52 <autrijus> any highlights I should mention?
09:14:08 <Pegazus> whats the url
09:14:11 <Pegazus> for the paste thing?
09:14:32 <Lemmih> @doc Debug.Trace
09:14:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
09:14:39 <skew> Pegazus: oh, sticking things in a pastebin and asking #haskell works pretty well too :)
09:14:48 <Lemmih> lisppaste2: url
09:14:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:15:03 <TFK> Or, hbin.dyndns.org
09:15:52 <lisppaste2> Pegazus pasted "Heeelp" at http://paste.lisp.org/display/8278
09:16:37 <Pegazus> sumaMas [1,2,3,4,5,1,6] is returning [2,3,4,5,1,6]
09:17:20 <TFK> there's a sum function, ya know
09:17:30 <Pegazus> hehe, anyway :)
09:18:26 <Pegazus> are the little functions right?
09:18:28 <Pegazus> the 2 last?
09:18:48 <Pegazus> hahaha
09:18:48 <Lemmih> Pegazus: Test them.
09:18:49 <TFK> Probably.
09:18:50 <Pegazus> i am a stupid
09:18:52 <Pegazus> sorry
09:18:54 <Pegazus> i've found it xD
09:19:30 <skew> those little functions look fine. They are also "init" and "sum" from the Prelude
09:19:33 <zamez> how can I compile something on debian unstable that will run on stable using ghc?
09:19:53 <zamez> unfortunately I can't compile it on stable, because I need alex which needs a newer ghc
09:20:24 <Lemmih> GHC on stable == 6.2.2?
09:21:04 <zamez> 5.02.2
09:21:11 <skew> eek!
09:21:42 <skew> if you are just talking about running the program on a debain stable system somewhere, have you tried it?
09:21:46 <Lemmih> zamez: Stick to haskell98 (:
09:21:51 <zamez> yes
09:21:57 <Pegazus> sumaMas [1,2,3,4,-3453,5,1,6,-5435353,7777,0,-20,-345,-345,77777,21]
09:21:59 <Pegazus> he
09:22:03 <Pegazus> that function is taking some time :)
09:22:04 <zamez> /lib/libc.so.6: version `GLIBC_2.3' not found
09:24:02 <skew> Pegazus: look at map inits (tails [1..5])
09:24:18 <Pegazus> what is the function to sum a list?
09:24:19 <TFK> Pegazus, doesn't that grow exponentially?
09:24:24 <skew> err, import Data.List first
09:24:26 <skew> Pegazus: sum
09:24:50 <Igloo> You can get a newer GHC from haskell-unsafe.alioth.debian.org
09:27:56 <Pegazus> how to sort a list on haskell? not a made in function, but how to make a nice one? :)
09:28:08 <skew> Pegazus: how about sumaMas numbers = fst (maximum [(sum xs, xs) | xs <- concatMap inits (tails [1..5])])
09:28:11 <Pegazus> mmmm i could do qsort
09:28:27 <skew> er, "numbers" instead of [1..5]
09:28:28 <Pegazus> i can't use that type of lists :)
09:29:16 <Pegazus> mmm what is the easiest algorithm of sorting to implement of haskell?
09:29:18 <basti_> what does the keyword "default" do?
09:29:36 <skew> there's something about defaulting for numeric types
09:29:47 <basti_> i see.
09:29:53 <basti_> wanted to use the word as a function name
09:30:23 <halcyon10> Pegazus: quicksort in haskell is easy : quicksort [] = []
09:30:23 <halcyon10> quicksort (x:xs) =  quicksort [y | y<-xs, y<x] ++ [x] ++ quicksort [y | y<-xs, y>=x]
09:30:30 <skew> like if you write show 1 you get "1" rather than an error about undefined overloading
09:30:44 <basti_> hmm
09:31:05 <basti_> ah because "1" is just some unknown numeric type huh
09:31:14 <basti_> you'd have to type show (1::Int) or something
09:31:57 <skew> yeah. I think you list some types in parens, like default(Int,Double,Complex Double), and it tries those types in order if it has an otherwise unconstrained numeric type somewhere
09:32:13 <Pegazus> i cant use that types of list :)
09:32:24 <basti_> i see.
09:32:29 <skew> Pegazus: there is a paper about making that maximum sublist thing faster than you should read. I will find it soon
09:32:39 <Pegazus> haha dont worry
09:32:42 <Pegazus> i dont care about speed
09:32:59 <skew> Pegazus: those list comprehensions can be translated into just using some functions like filter and map
09:33:00 <basti_> @doc sort
09:33:01 <lambdabot> sort not available
09:33:08 <skew> @doc Data.List.sort
09:33:09 <lambdabot> Data.List.sort not available
09:33:14 <skew> :(
09:33:18 <Pegazus> i know how to implement the fastest algorithm of a sublist in imperative :)
09:33:22 <halcyon10> Pegazus: hehe, it's not that hard to learn how to use those lists. but if you don't like them you could also use 'filter' in this case
09:33:31 <Pegazus> is not that i dont like them
09:33:34 <skew> Pegazus: the linear time one?
09:33:36 <Pegazus> is for the univ this
09:33:44 <Pegazus> and they prohibited me to use those lists :)
09:33:50 <halcyon10> oh, i see
09:33:56 <Pegazus> they want us to use recursion...
09:35:24 <glimming> TheHunter, you wrote (=<<) id
09:35:32 <glimming> but I suppose this is the same as (>>= id) ?
09:36:15 <basti_> @pl (\(x,_) (y,_) -> compare x y)
09:36:16 <lambdabot> flip (ap . (. fst) . (const .) . compare) snd . fst
09:36:18 <basti_> ugh
09:36:34 <basti_> okay, 1:13898 in the eternal lambda vs. pointless game
09:36:38 <glimming>       mu . fmap f
09:36:38 <glimming>   == {- composition and definition of |mu| -}
09:36:38 <glimming>      (>>= id). (=<<) (return . f)
09:36:47 <glimming> I am reluctant to the use of =<< here
09:36:48 <TheHunter> yes, sure. if you're typesetting this you might even do id_*
09:37:04 <skew> Here's the paper: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/calculating.ps.gz
09:37:27 <glimming> heh, I attended that scool ;-)
09:37:36 <skew> it shows how to turn the cubic algorithm in terms of inits and tails that I gave into the linear algorithm, step by step
09:37:42 <glimming> No, I did not.
09:37:46 <glimming> There is a later paper that I think is better.
09:38:15 <skew> Pegazus: recursion is kind of pointless when you have the right higher order functions to use
09:38:43 <TFK> skew, many uni assignments are.
09:39:05 <Pegazus> i know skew
09:39:06 <skew> you can always just define the catamorphism yourself and go from there :)
09:39:08 <Pegazus> but they want us to learn that
09:39:09 <Pegazus> :)
09:39:15 <Pegazus> qsort [] = []
09:39:17 <Pegazus> qsort (x:xs) = (qsort (lowerlist xs x)) ++ [x] ++ (qsort (upperlist xs x))
09:39:19 <Pegazus> lowerlist [] _ = []
09:39:21 <Pegazus> lowerlist (x:xs) k | x < k = (x:(lowerlist xs k))
09:39:22 <Pegazus> lowerlist (x:xs) k | x >= k = lowerlist xs k
09:39:24 <Pegazus> upperlist [] _ = []
09:39:27 <Pegazus> upperlist (x:xs) k | x > k = (x:(upperlist xs k))
09:39:29 <Pegazus> upperlist (x:xs) k | x <= k = upperlist xs k
09:39:31 <Pegazus> :) thats qsort with recursion (but deleting duplicates xD)
09:40:11 <skew> just use >= in upperlist, or <= in lowerlist
09:40:19 <Pegazus> hehe k
09:41:10 <TheHunter> glimming, basing monads on (>>=) is motivated by imperative applications, and is usually not the best way to manipulate monadic terms. (=<<) (or the subscripted star) is much nicer, since it may be interpreted as a lifting from |a -> m b| to |m a -> m b|.
09:41:19 <TFK> Pegazus, oh, and another thing: primeros list = take (len list - 1) list
09:41:38 <glimming> superscripted you mean f^*
09:41:38 <Lemmih> Or just 'init'.
09:41:41 <Pegazus> what?
09:41:42 <TFK> Not sure how recursive it is, though o_O
09:41:43 <Pegazus> k
09:41:59 <glimming> yes, that's the Kleisli form in fact
09:41:59 <TFK> Lemmih, oh, cool, didn't know about that :-)
09:42:01 <Lemmih> @plugs init [1..5]
09:42:07 <lambdabot> [1,2,3,4]
09:42:13 * TFK must sit down and read the Prelude in its entirety one day
09:42:29 <TheHunter> glimming, really, is it usually superscripted?
09:42:52 <Lemmih> TFK: The standard libraries are full of goodies (:
09:43:08 <TFK> Heh, yeah.
09:44:01 <skew> Data.List and Control.Monad go on the reading list too
09:45:05 <glimming> Moggi at least, TheHunter
09:45:26 <glimming> super for me is "TOP" anyway
09:45:30 <glimming> and for Word and LaTeX
09:45:46 <glimming> but that's not important-
09:45:58 <musasabi> How would I uniquely decorate values with an unique integer when they are lifted into an arrow? I want to have a way to break cycles inside the arrow structure and unique numbers seem like the simplest solution.
09:46:35 <Pegazus> you have [44444555555555557777777773333333333388888] (each separated with comma) and a function to turn it [44444,55555555555,777777777,33333333333,88888]
09:46:46 <TheHunter> i would have thought it's closer to homology than to cohomology...
09:52:53 <zamez> Igloo: are those backports?
09:56:07 <Igloo> There is a 6.2.2 backport in there IIRC
09:57:02 <kolmodin> Question about Cabal: when using makefiles to compile my project I can say "make develop" to compile without optimizations and with warnings. when building files I'm going to install I simply say "make" which uses optimizations but not warnings. Is there a standard way to do this in Cabal?
09:57:02 <Lemmih> Wow. HSP is nice.
09:57:03 <zamez> yep, found it, thanks
09:59:32 <Pegazus> hey
09:59:37 <Pegazus> how to get last elemnt of a list?
09:59:45 <kolmodin> I'm trying to replace my Makefiles by Cabal, but I might have to keep them for this purpose
09:59:54 <kolmodin> Pegazus: last
10:00:22 <kolmodin> last :: forall a. [a] -> a
10:01:41 <Pegazus> is that defined on prelude?
10:01:59 <kolmodin> yes, you don't have to import anything
10:02:09 <Pegazus> thx
10:02:20 <kolmodin> np
10:03:51 <kolmodin> Pegazus: you might want to have a look in Data.List which supplies many usable functions to manipulate lists. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
10:04:05 <glimming> @pl (=<<) id
10:04:05 <lambdabot> join
10:04:24 <Pegazus> thx
10:04:48 <glimming> which binds hardest >>= or .
10:06:07 <Lemmih> glimming: GHCi can tell you that.
10:06:32 <TheHunter> @pl x >>= return . f
10:06:33 <lambdabot> f `fmap` x
10:06:37 <TheHunter> @pl return . f =<< x
10:06:38 <lambdabot> f `fmap` x
10:09:55 <Gahhh> glimming: Prelude says infixr 1 >>=, infixr 9 .
10:18:49 <glimming> many thanks
10:19:08 <glimming> and higher precedence means what? Sorry... very basic Q.
10:21:43 <TheHunter> $ has low prec, application high, iirc
10:22:55 <basti_> rule of thumb: " " has a very high precedence
10:23:06 <basti_> (application)
10:29:49 <Spherical`> I want a happy hacking keyboard. I don't understand why the are so expensive!
10:30:49 <basti_> happy hacking keyboard?
10:34:13 <mflux> low volume keyboards have the tendency of being expensive..
10:37:31 <Spherical`> Apparently there was/is a site available for buying one for around 20 GBP.
10:38:54 <basti_> 20 pounds is not an expensive keyboard is it?
10:40:00 <Spherical`> Not at all, however, the standard UK price seems to be around 60 for the lite version. The professional is 160, so yes, it's a tad bit expensive.
10:40:51 <basti_> uhh.
10:40:55 <basti_> yes that would be expensive ok
10:41:44 <zamez> got it working, thanks Igloo
10:41:51 <zamez> http://zamez.org/factorcss
10:41:54 <zamez> powered by Haskell
10:42:00 <zamez> with a bit of PHP too
10:48:45 <Lemmih> zamez: It fails to parse http://haskell.org/haskell-org.css
10:51:00 <zamez> looks like a mistake in the CSS in this case, Lemmih
10:51:05 <zamez> should be #0000CC
10:51:11 <zamez> but there are some bugs too
10:57:02 <dcoutts_> vidvandre, re your gtk2hs build problem: it looks from the error message you pasted that you were building using ./configure --disable-deprecated (or had previously used that)
10:58:14 <dcoutts_> if you try the build from a clean build tree, it should be fine.
11:00:38 <dcoutts_> it looked like the build system was confused about wether you were using --disable-deprecated or not, one part had been built using that option and another bit hadn't. Applying the ghc-6.4 patch could have caused that by changing various timestamps and thus confusing make.
11:02:48 <dcoutts_> but as I say, applying the patch to a fresh build tree should be ok (or doing make distclean would probably do it too)
11:21:43 <zamez> is there anything similar to showFloat that doesn't output .0 for floats with no fraction?
11:24:21 <Igloo> There's a family of functions in Numeric, but I don't know if any can do what you want
11:25:00 <zamez> doesn't look like it, I'll just test for  floor x == x
11:25:05 <vidvandre> dcoutts, ah. thanks. I'll try without in a minute
11:26:52 <vidvandre> dcoutts, I did try to build it with --disable-deprecated
11:31:24 <dcoutts_> vidvandre, in general --disable-deprecated should work but it is less tested than the normal (but I think I tested it for the 0.9.7 release) but if the build system gets confused about that setting then things certainly will break because it adds/removes quite a few functions & types
11:32:13 <dcoutts_> it should work for a fresh build
11:33:54 <Spherical`> Is anyone aware of any proxy applications for linux that will filter unwanted sites?
11:38:25 <basti_> Spherical`: i have a filter in my webbrowser.
11:38:34 <basti_> or are you talking censorship? ;)
11:38:48 <Spherical`> basti_, yes I'm talking censorship.
11:38:58 <Spherical`> Any tips?
11:39:03 <basti_> i do not believe this works or makes sense...
11:39:17 <basti_> if you do, most proxies probable provide some degree of filtering
11:40:24 <Spherical`> Can you tell me how to directly filter through the browser interpretation. I use firefox?
11:40:34 <basti_> i do too... there's a plugin
11:40:40 <basti_> it's not suitable for censorship though
11:40:52 <basti_> "adblock"
11:41:00 <Spherical`> Oh :( that's not suitable then.
11:41:00 <basti_> it can't be locked
11:41:22 <basti_> why would you want to censor something, and ask for how to do it on an IRC channel?
11:54:00 <glimming> basti_, TheHunter, ski et al - I need some serious persons to review a take-home examination with confidentiality
11:54:12 <glimming> I am preparing it, and it cannot contain errors.
11:54:47 <glimming> I am looking for volunteers...
11:55:31 <basti_> i would have a look, but i can't promise i can say something that actually makes sense... maybe I don't know enough about the topic.
11:55:48 <glimming> the topic? Haskell.
11:55:59 <glimming> AFP
11:56:19 <basti_> well theres a difference if you pose some programming exercices, or if you go lambda-pointless-wacko
11:56:29 <glimming> program transformations, but also of course some lambda calculus, System F, type inference, but I am asking for help on the Haskell part (part III) of the exam
11:56:57 <basti_> let me have a look then
11:57:09 <glimming> grat
11:57:13 <glimming> greaaat
11:57:38 <basti_> the others will catch the errors that i miss, then ;)
12:00:47 <basti_> for example, i thought i know quite a bit of haskell. Then TheHunter wrote this article about that callCC monad
12:03:19 <SyntaxNinja> hiya
12:03:23 <SyntaxNinja> Igloo: alive?
12:03:26 <Igloo> Yup
12:03:30 <glimming> hooha
12:05:19 <SyntaxNinja> @seen shapr
12:05:21 <lambdabot> I saw shapr leaving #haskell 7 days, 3 hours, 5 minutes and 4
12:05:21 <lambdabot> seconds ago.
12:05:30 <SyntaxNinja> :(
12:07:55 <glimming> @pl concat ([concat (map h (k a))])
12:07:55 <lambdabot> join [h =<< k a]
12:08:47 <basti_> SyntaxNinja: he's rumoured to be working at fermat's last margin and not chatting because of that
12:09:22 <SyntaxNinja> hehe
12:09:25 <glimming> I don't like the form of that
12:09:32 <glimming> hwy introduce joins and =<< ??
12:09:35 <glimming> why
12:09:57 <glimming> It is nice to have few standard syntax
12:09:59 <Cale> concatMap is bind
12:10:17 <Cale> (in the list monad)
12:10:20 <glimming> yes but we got flip bind
12:10:30 <glimming> and join >>= id instead of just >>=
12:10:50 <glimming> too me that makes things more complicated
12:11:03 <Cale> =<< is no worse than >>=
12:11:05 <glimming> (spelling is horrible here after a glass of Finish beer)
12:11:13 <glimming> we can argue about that.
12:12:14 * esap prefers arrows anyway.
12:13:32 <glimming> esap probably knows what I mean when I say "Finnish beer".
12:13:40 * esap nods.
12:14:12 <esap> depends on the brand, of course.
12:14:18 <basti_> vodka?
12:14:24 <basti_> green dragon?
12:14:30 <basti_> something worse?
12:15:35 <TFK> Finnish deer?...
12:15:54 * TFK goes back to his tea
12:17:20 <tuomov> piss?
12:17:33 <tuomov> that's what 99% of it is
12:17:57 <tuomov> (aside from a few brewery-restaurants)
12:21:11 * esap is not an expert in discussing beer.
12:23:57 <esap> glimming: I started writing some description of the principles used in OOLib.
12:24:37 <glimming> Nice!
12:39:46 <TheHunter> glimming, i'll have a look.
12:42:08 <TheHunter> hrm, seems like @pl needs a rule [x] ==> return x
12:48:00 <glimming> thanks, maybe esap can also look at the home-exam I am giving soon and give me some feedback. I will send this tomorrow to you if you give me your email addresses
12:49:00 <esap> sure.
12:50:31 <glimming> maybe basti_ too?
12:50:36 <glimming> and ski?
12:50:40 <glimming> @seen ski
12:50:41 <lambdabot> I saw ski leaving #haskell 21 hours, 21 minutes and 15 seconds ago.
12:53:41 <SyntaxNinja> did all folks who are interested in becoming DDs email me?
12:54:09 <esap> DD?
12:54:21 <SyntaxNinja> debian developers. sorry
12:55:24 * esap doesn't have time for that, sorry.
12:56:29 <SyntaxNinja> esap: np
13:09:18 <vidvandre> dcoutts, it compiled this time! :)
13:24:07 <christos_13> Is there any really good book about haskell?
13:24:24 <gzl> Hudak is good
13:24:51 <Lemmih> "The Craft of Functional Programming" is the best Haskell book I got.
13:26:06 <christos_13> ok i ll take a look at those two. thnx
13:26:33 <dbremner> christos_13 - I would second that recommendation and vote against SoE.
13:28:36 <Gahhh> I don't have CFP, but I have SoE and it's somewhat dry.
13:29:32 <jesse99> why does ghci give me the following error: 'file name does not match module name `Main''?
13:29:48 <jesse99> m
13:29:58 <sylvan> Has anyone tried HSP?
13:30:32 <jesse99> hmm, maybe it was because I had module after the import
13:31:16 <dbremner> Gahhh - the two Haskell books I want are: a quick tutorial along the lines of Accelerated C++ and a complete guide to the language ala The C++ Programming Language.
13:31:52 <dcoutts> vidvandre, great!
13:32:59 <Igloo> I don't suppose anyone knows what a retainer of "(2)SYSTEM" means?
13:33:03 <dcoutts> vidvandre, 0.9.8 (which should be out in a week or so) will support ghc 6.4 without patching
13:33:50 <dcoutts> Igloo, your guess is as good as mine (actually it's proably better :-)
13:34:59 <Gahhh> dbremner: I have neither of those C++ books. Actually, I've never had a C++ book. Hmm.
13:36:09 <jesse99> it's way easier to learn c++ than haskell -)
13:37:09 <dbremner> Gahhh - Accelerated C++ teaches the standard libraries from day 1, it's by Koenig and Moo.
13:37:20 <Gahhh> jesse99: Not actually. But I think it's easier to "think you know C++" heh
13:37:30 <jesse99> not true gahh
13:37:54 <jesse99> i am quite familiar with all aspects of c++ including meta-programmiung
13:38:32 <jesse99> well it is true that a lot of c++ programmers know the language, yet dont have a clue about templates or design
13:38:43 <jesse99> [think they know]
13:41:24 <dbremner> Gahhh - I haven't looked at YAHT yet, though. That's supposed to be quite good.
13:43:20 <Gahhh> has anyone used metaocaml ?
13:43:50 <dcoutts> Gahhh, I know a little about it but never actually used it. I stick to Template Haskell.
13:47:37 <wagle> what is yaht?
13:47:51 <Gahhh> yet another haskell tutorial
13:47:59 <glimming> I'd like to paste something rather long, how do I do that?
13:48:19 <Gahhh> glimming: use haskell irc paste wikipage
13:48:26 <wagle> カテゴリ検索
13:48:27 <Gahhh> @wiki paste
13:48:28 <lambdabot> http://www.haskell.org/hawiki/paste
13:48:45 <Gahhh> ugh
13:49:16 <Gahhh> lambdabot lies
13:49:18 <glimming> can I not lisp paset?
13:49:21 <glimming> paste?
13:49:26 <glimming> It so seems
13:49:59 <Gahhh> yes youcan
13:50:13 <glimming> How?
13:50:17 <Gahhh> http://paste.lisp.org/
13:50:58 <glimming> great
13:51:03 <glimming> Let's pray.
13:51:11 <Gahhh> ah
13:51:13 <Gahhh> @paste
13:51:16 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:51:42 <wagle> @wiki sjhfjsreu34uedjdj
13:51:43 <lambdabot> http://www.haskell.org/hawiki/sjhfjsreu34uedjdj
13:52:05 <lisppaste2> glimming pasted "proof that state monad abides the monad laws, sketch" at http://paste.lisp.org/display/8283
13:52:06 <wagle> teh @wiki command really needs to be removed
13:52:16 <glimming> I wish it worked.
13:52:22 <glimming> Oh it did!
13:52:38 <glimming> Now, that's something for TheHunter
13:52:40 <TheHunter> wagle, how so?
13:52:42 <glimming> or esap?
13:52:57 <wagle> TheHunter: garbage in, garbage out
13:52:58 <glimming> Left and right unit are fine
13:53:10 <glimming> But I am getting tired so the proof for associativity is a bit fishy
13:53:14 <wagle> what about bottom?
13:53:27 <glimming> I was hoping to get a little bit of comments to complete also assoc.
13:53:57 <glimming> Btw, note the beautiful use of kosmikus' excellent lhs2TeX preprocessor
13:54:05 <glimming> (for derivations)
13:56:15 <wagle> TheHunter: all it does is prepend the string "http://www.haskell.org/hawiki/" to the input, without checking for existence
13:56:52 <TheHunter> glimming, you can write data SM s a = SM { apply :: s -> (a,s) } where apply would be more conventionally named runSM.
13:56:58 <TheHunter> wagle, it's still useful.
13:57:17 <glimming> argh, I think I won't for my students sake.
13:57:36 <TheHunter> feel free to write something that checks for existence.
13:57:40 <glimming> they have enough problem understanding value constructors
13:57:45 <TheHunter> point
13:58:09 <Lemmih> dons: Awake?
13:58:16 <TheHunter> @docs Prelude
13:58:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
13:59:50 <wagle> TheHunter: the only use i've seen is to send people on wild goose chases
14:01:06 <mflux> wagle, that's completely unfounded..
14:01:06 <mflux> @wiki HowWikiOfLambdabotWorks
14:01:07 <lambdabot> http://www.haskell.org/hawiki/HowWikiOfLambdabotWorks
14:01:32 <glimming> In apply (SM f >>= r) s there is no reason for adding apply ((SM f)  >>= r) s since >>= binds looser than function application (does it) ?
14:01:36 <Gahhh> @wiki Proof_NP=P
14:01:37 <lambdabot> http://www.haskell.org/hawiki/Proof_NP=P
14:01:37 <TheHunter> @wiki FundamentalConcepts
14:01:38 <lambdabot> http://www.haskell.org/hawiki/FundamentalConcepts
14:01:43 <mflux> (I too think that if the feature is useful as it is, it is only extremely slightly so)
14:01:45 <TheHunter> @wiki ThatAnnoyingIOType
14:01:47 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
14:01:47 <wagle> @wiki mflux_is_wrong_wrong_wrong
14:01:48 <lambdabot> http://www.haskell.org/hawiki/mflux_is_wrong_wrong_wrong
14:02:03 <TheHunter> @wiki ThingsToAvoid
14:02:04 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid
14:02:22 <glimming> (Maybe it should check for non-empty page as well)
14:02:29 <TheHunter> works great, doesn't it?
14:02:30 <wagle> yesssss
14:02:44 <mflux> atleast lambdabot always has an answer
14:02:54 <glimming> even if it is undefined
14:03:13 <Lemmih> hs-plugins should work with GHC 6.4, right?
14:03:32 <TheHunter> glimming, yep, application binds tightest. (SM f) >>= r looks horrible.
14:03:34 <wagle> if the entire address space is mapped, then you cant get segmentation faults, and so dont need type checking?
14:04:40 <glimming> regarding semantics of where
14:04:43 <glimming> is        where f s = apply (q x) s'
14:04:43 <glimming>        where (x,s') = apply p s
14:04:46 <glimming> equivalent to
14:04:55 <glimming>        where f s = apply (q x) s'
14:04:55 <glimming>                   (x,s') = apply p s
14:05:03 <glimming> maybe permuted order though
14:05:05 <glimming> ?
14:05:39 <TheHunter> the latter probably gives an error
14:09:26 <TheHunter> just applying the definitions to |p >>= (\x -> q x >>= r)| doesn't work?
14:09:30 <lisppaste2> glimming pasted "corrected proof, last bits missing still" at http://paste.lisp.org/display/8284
14:13:34 <glimming> substitute x for y on some places
14:14:41 <glimming> I would have thought that associativity of . would appear in the proof but I cannot see where
14:14:59 <wagle> can apply observe everything that is observable?
14:20:17 <glimming> Do TheHunter agree with      p >>= return
14:20:17 <glimming>   == {- translation of |>>=| into |mu| -}
14:20:17 <glimming>      (mu . fmap return) p
14:20:17 <glimming>   == ((mu . fmap id) . fmap return) p
14:20:17 <glimming>   == (mu . eta) p
14:20:19 <glimming>   == p
14:24:20 <TheHunter> why do do the fmap id step?
14:24:25 <TheHunter> *you
14:24:51 <jesse99> is there any way to use ghc to find the context at which fail wsa called?
14:25:21 <glimming> arghhhh
14:25:31 <glimming> this does not even type
14:25:53 <TheHunter> mu . fmap eta === id is a basic law.
14:26:16 <glimming> but mind you I am trying to establish these laws
14:26:22 <glimming> given the Kleisli form
14:26:25 <glimming> so I cannot assume them
14:26:28 <glimming> then it is circular
14:27:06 <TheHunter> jesse99, i assume you mean fail. If you really need to, you can compile using profiling (ghc -prof -auto-all) and then ./a.out +RTS -xc, IIRC will give you kind of a stack trace.
14:27:22 * basti_ just used >>= as a parameter to something the first time
14:27:35 <jesse99> hmm
14:27:51 <TheHunter> s/fail/error/
14:27:52 <basti_> glimming: sorry for disappearing... my gf isnt feeling well today
14:28:08 <basti_> i was looking at the proof you pasted but didn't see the answer so far
14:28:15 <glimming> grand father?
14:28:20 <TheHunter> glimming, if you want to proof mu . fmap eta === id, why don't you start with mu . fmap eta?
14:28:23 <basti_> girl friend
14:28:28 <basti_> significant other
14:28:28 <glimming> aha
14:28:31 <glimming> such
14:28:51 <glimming> I am lost here I think w8
14:29:12 <glimming> We are asked to prove that the laws are equivalent. Assume |m| is an
14:29:12 <glimming> instance of |Monad| and |m'| is the derived instance of |Monad2|
14:29:12 <glimming> according to the above translation. Suppose |m| satisfies the
14:29:12 <glimming> monoid-style laws. Under this assumption, we want to show that |m'|
14:29:12 <glimming> satisfies the Kleisli-style laws. This means that we can use all the
14:29:15 <glimming> monoid-style laws and the definitions in our proof. For the
14:29:17 <glimming> identities, we reason: ...
14:29:33 <glimming> aha
14:29:41 <glimming> so I actually wanted to prove the Kleisli laws this tiem
14:29:43 <glimming> time
14:29:46 <glimming> ;-(
14:29:55 <glimming> /me swearing
14:30:01 <glimming> \me swearing
14:30:07 <glimming> even more
14:30:27 <Spherical`> lol @ grandfather.
14:30:43 <glimming> ;-) yes
14:30:48 <glimming> and serious too
14:32:09 <glimming> ok fine, then I  CAN use monoid laws freely of course
14:33:20 <glimming> fantastic
14:33:20 <glimming>      p >>= return
14:33:21 <glimming>   == {- translation of |>>=| into |mu| -}
14:33:21 <glimming>      (mu . fmap return) p
14:33:21 <glimming>   == {- monoid-style law -}
14:33:23 <glimming>      p
14:33:32 <glimming> how hard was that?
14:34:15 <glimming> for the other law, I am more confused still
14:34:16 <glimming>      (return e) >>= q
14:34:16 <glimming>   == {- translation of |>>=| into |mu| -}
14:34:16 <glimming>      (mu .fmap q) (return e)
14:34:16 <glimming>   == {- since |return=eta| -}
14:34:19 <glimming>      (mu . fmap q) (eta e)
14:34:21 <glimming>   == q e
14:34:24 <glimming> Now you see this mu.fmap q
14:34:32 <glimming> why?
14:34:51 <glimming> the last step is guesswork
14:35:06 <glimming> fishy
14:36:11 <glimming> undefied == {- definition of God -} = miracle
14:36:24 <basti_> "oracle"
14:36:25 <basti_> =)
14:36:30 <glimming> yes
14:37:52 <glimming> @pl (>>= id) . fmap return
14:37:52 <lambdabot> id
14:38:25 <glimming> how's that? I really want tracing for this one.
14:38:45 <glimming> I do not understand fmap return here
14:38:59 <glimming> I guess I gave the students too hard exercises! ;-)
14:39:16 <glimming> Not a single person could do this!
14:39:27 <glimming> And the teacher has pretty much a headache too
14:39:52 <TheHunter> join . fmap return === id is a monoid law.
14:40:04 <glimming> aha
14:40:22 <glimming> I did not see that!!
14:40:35 <glimming> oh... for a good reason
14:41:00 <glimming> NOW I am doing it the other way around, i.e. from monoid LHS I want to enter monoid RHS assuming all Kleisli laws
14:41:58 <glimming> is this correct?
14:41:59 <glimming>     (>>= id) . fmap return
14:41:59 <glimming>   == {- definition of composition -}
14:41:59 <glimming>      >>= fmap return
14:42:09 <glimming> NO
14:43:53 <glimming> @pl (>>= id) . liftM return
14:43:54 <lambdabot> id
14:43:58 <glimming> sure
14:44:26 <glimming> TheHunter, can you explain fmap here?
14:44:30 <glimming> aka liftM
14:46:41 <TheHunter> @pl (=<<) id . (=<<) return . return
14:46:42 <lambdabot> id
14:46:52 <Lunar^> @seen shapr
14:46:53 <lambdabot> I saw shapr leaving #haskell 7 days, 5 hours, 46 minutes and 37
14:46:53 <lambdabot> seconds ago.
14:47:00 * Lunar^ is worried now
14:47:33 <TheHunter> (=<<) id . (=<<) return . return === (=<<) ((=<<) id . return) . return === (=<<) id . return === id
14:48:29 <TheHunter> btw. for mu . fmap q . eta === q you need the naturality of mu.
14:48:35 * TheHunter counts laws.
14:49:00 <basti_> you guys are sick.
14:49:02 <glimming>      (p >>= q) >>= r
14:49:02 <glimming>   == {- translation of |>>=| -}
14:49:02 <glimming>      (mu . fmap r) ((mu . fmap q) p)
14:49:02 <glimming>   == ... ???
14:49:38 <wagle> seq shapr
14:49:54 <glimming> (I am now going into associativity)
14:49:58 <glimming> I consider units done.
14:50:05 <glimming> FINALLY
14:50:28 <glimming> there might be errors but I will send the TeX to you TheHunter for your all-seeing eyes to parse over them
14:50:53 <glimming> I would imagine assoc. being ahrder.
14:50:54 <glimming> harder.
14:51:15 <glimming> also, TheHunter, do you agree that state monad assoc. would have to fall back to assoc. of function composition?
14:51:22 <wagle> i understand it gets much tougher if you consider bottom when proving the monad laws
14:51:49 <TheHunter> glimming, not sure about this.
14:52:28 <TheHunter> (=<<) f . (=<<) g === (=<<) ((=<<) f . g)
14:53:36 <glimming> that's assoc?
14:54:15 <TheHunter> assoc, kleisli form
14:54:23 <glimming> yes.
14:55:19 <glimming> @pl (>>= id) . (>>= id)
14:55:20 <lambdabot> join . join
14:55:23 <glimming> fantastic
14:55:55 <glimming> @pl mu. liftM mu
14:55:56 <lambdabot> mu . fmap mu
14:56:01 <glimming> wonderful
14:56:13 <glimming> completely vacuous
14:57:17 <wagle> i hope my life never depends on faux proofs
14:57:53 <glimming> faux?
14:58:32 <TheHunter> (=<<) ((=<<) f . g) === mu . fmap (mu . fmap f . g) === mu . fmap mu . fmap (fmap f) . fmap g === mu . mu . fmap (fmap f) . fmap g === mu . fmap f . mu . fmap g === (=<<) f . (=<<) g.
15:00:06 <glimming> please repeat
15:00:13 <glimming> pressed "close window" by mistake
15:00:19 <glimming> TheHunter,
15:00:22 <glimming> that is
15:00:23 <TheHunter> (=<<) ((=<<) f . g) === mu . fmap (mu . fmap f . g) === mu . fmap mu . fmap (fmap f) . fmap g === mu . mu . fmap (fmap f) . fmap g === mu . fmap f . mu . fmap g === (=<<) f . (=<<) g.
15:00:49 <glimming> I pressed it again...
15:00:51 <glimming> Damn
15:01:02 <glimming> emacs copy is close window in IRC
15:01:10 <glimming> can you repeat?
15:01:14 <TheHunter> (=<<) ((=<<) f . g) === mu . fmap (mu . fmap f . g) === mu . fmap mu . fmap (fmap f) . fmap g === mu . mu . fmap (fmap f) . fmap g === mu . fmap f . mu . fmap g === (=<<) f . (=<<) g.
15:01:54 <glimming> did you use functor laws?
15:02:05 <TheHunter> yes, that's the second ===
15:02:17 <TheHunter> then, monoid, then naturality of mu.
15:02:40 <glimming> hum hum
15:02:45 <glimming> That's too bad
15:02:52 <glimming> That naturality was needed
15:03:18 <glimming> that means 0 chance for students to have solved it which was indeed proved in reality.
15:03:33 <TheHunter> yep naturality is needed. For one identity eta's and for associativity mu's
15:07:43 <glimming> goodnight!
15:08:07 <TheHunter> 'night
15:39:37 <Lemmih> Yay. Got my mod_haskell code working with GHC 6.4.
15:39:43 <Lemmih> Next stop: HSP.
15:43:43 <arjanoosting> Hi, i have compiled HaXml with ghc 6.4 and I'm now trying to compile a program which uses HaXml but I get undefined references
15:45:09 <arjanoosting> Main.o(.text+0x535): undefined reference to `TextziXMLziHaXmlziCombinators_tag_closure'
15:45:25 <arjanoosting> Does someone know what I'm doing wrong
15:45:29 <Lemmih> -package HaXml or --make
15:46:21 <arjanoosting> yep i have -package HaXml
15:47:01 <arjanoosting> and with GHC 6.2 everything is working fine...
15:47:27 <Lemmih> Try --make.
15:49:39 <arjanoosting> Also doing that: ghc -package HaXml -package uust -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances -cpp -O2 -funbox-strict-fields -o Main --make Main.hs
15:50:22 <Lemmih> Bad cabalization of HaXml perhaps?
15:51:38 <arjanoosting> ghci -package HaXml works fine
15:51:53 <arjanoosting> What do you mean by bad cabalization?
15:53:20 <Lemmih> Missing some modules in the Cabal file may cause such problems.
15:54:02 <arjanoosting> In the exposed-modules list?
15:54:42 <Lemmih> Yes, or in other-modules.
15:56:26 <arjanoosting> How do I find out which modules are missing?
15:58:57 <Lemmih> arjanoosting: Find all the .hs files.
16:04:23 <Lemmih> nibro: Awake?
16:08:30 <arjanoosting> ok in the the exposed modules list I have 3 modules for which there are no corresponding .hi files installed
16:09:12 <arjanoosting> that could be the problem
16:22:41 <arjanoosting> Lemmih: Hmm it seems that the call from ghc to gcc misses the -lHSHaXml flag, any idea how that could happen?
16:25:37 <Lemmih> Most likely an error-code 40.
16:26:20 <arjanoosting> error-code 40?
16:26:33 <Lemmih> User error.
16:28:29 <Lemmih> Go through everything and make sure you catch tyops.
16:29:15 <arjanoosting> I found it: the pkg-config file used by HaXml misses an hs-libraries entry
17:03:09 <thou> @wiki hsc2hs
17:03:10 <lambdabot> http://www.haskell.org/hawiki/hsc2hs
17:45:17 <arjanoosting> Limmih: thanks for the help! Goodbye
17:51:53 <thou> hi, i'm having trouble w/ Setup.lhs install --user
17:51:59 <thou> in a package i'm making
17:52:08 <thou> it's trying to write it in /usr/local/lib/HSCurses-1.0
17:52:35 <thou> i think i must be missing something obvious (in the .cabal file, maybe?)
17:53:00 <Igloo> You should be able to give it --preifx at some point. If that doesn't work, sounds like a bug
17:53:32 <thou> Igloo: i thought that was only needed for the --global install
17:53:43 <thou> the docs say that --user will install in the user's home directory
17:53:53 <thou> oops
17:54:04 <thou> maybe not, i see now in the example they *do* use --prefix
17:54:33 <thou> ok, cool, sorry to not see that....
17:54:33 <Igloo> Add to the package.conf in your homedirectory. Although trying to do that while installing into /usr/local does seem silly
17:55:19 * Igloo isn't sure if a default of ~/.haskell_packages/ or something would be better - perhaps mail the list about it?
17:56:20 <thou> Igloo: i think it should just warn you when you run configure
17:56:44 <dons> thou, are you cabalising Stefan's hscurses lib?
17:56:53 <thou> erm, well, i guess that's impossible because it won't know that you're going to use --user on install step
17:56:56 <thou> dons, yes
17:57:02 <thou> dons: i found out the problem i was having
17:57:29 <thou> there are a bunch of #def foo lines that are commented out in Curses.hsc
17:57:29 <Igloo> Oh, if the build knows what directory it's installing to then a different default for install isn't possible
17:57:47 <thou> they don't get processed by hsc2hs, so they stay in the Curses.hs file
17:57:50 <dons> ah right.
17:57:54 <thou> but then cabal is using -cpp
17:58:01 <dons> ah!
17:58:04 <thou> so when it gets fed into cpp, then it breaks
17:58:16 <thou> not sure what the right fix is for that, shouldn't be too hard though
17:58:21 <dons> but doessn't show up in Yi, where we control the build flags more precisely
17:58:25 <thou> right
17:58:46 <thou> took me probably 20 hours to figure it out
17:58:50 <thou> but i learned a lot along the way
17:58:51 <thou> :-)
17:59:31 <dons> hehe
17:59:36 * thou feels kind of dim, after reading the above 2 sentences
18:00:06 <thou> i'm like the horse in 1984
18:00:12 <thou> s/1984/animal farm/
18:07:27 <foxy> @docs returnIO
18:07:28 <lambdabot> returnIO not available
18:08:42 <thou> hmmm, maybe someone has seen this.  in this same package, i've successfully built & installed; trying to test it, i'm getting this error when linking: : undefined reference to `__stginit_CForeign_'
18:08:58 <thou> i'm passing -ffi flag to ghc
18:09:19 <thou> ghc -package HSCurses -ffi --make t.hs -o t
18:09:55 <dons> hmm.
18:10:18 <dons> that symbol is in -package haskell98
18:10:37 <thou> adding that to the line doesn't help
18:11:31 <dons> has the HSCurses package been registered in the package system?
18:11:48 <thou> yes; i used ./Setup.lhs install --user
18:12:09 <thou> @url paste
18:12:10 <lambdabot> Maybe you meant: arr pl
18:12:24 <thou> nope
18:12:47 <dons> @paste
18:12:48 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:14:46 <thou> dons: i just pasted the .cabal file
18:16:04 <Lemmih> Cabal-get installs local packages to ~/usr
18:17:23 <dons> oh! this is a different hs-curses?
18:17:32 <thou> dons: no
18:17:45 <dons> what's http://hs-curses.sourceforge.net/ ?
18:17:59 <thou> err, it's cruft
18:18:35 <thou> http://pastebin.com/284937
18:18:36 <dons> but you are hacking on stefan's binding out of yi?
18:18:40 <thou> yes
18:18:50 <dons> ok.
18:19:13 <thou> i just added Setup.lhs & HSCurses.cabal and modified a few files
18:19:40 <thou> the above pastebin is the output of ghc --make -v
18:19:48 <thou> showing what ghc is trying to do underneath
18:20:13 <thou> not sure if that's helpful
18:20:28 <stefanh_> dons, thou: I about the push a new version of the binding in the repo
18:20:43 <dons> ok.
18:20:57 <stefanh_> atm, it only works with ghc 6.2 because ghc-pkg complains
18:21:10 <thou> stefanh_: ok, cool; that's why i'm trying to cabalize it
18:21:28 <dons> yeah, you need a 6.4 package.conf , but I think thou might have written one? or replaced it with Cabal?
18:21:41 <thou> trying to replace w/ cabal
18:22:07 <dons> either way, there's also a 6.4 package.conf in yi that could be stolen.
18:22:14 <thou> w/ the HSCurses.cabal file, it now builds with :  ./configure; ./Setup.lhs configure; ./Setup.lhs build;
18:22:25 <thou> i tried, but got confused
18:23:03 <thou> w/ some of the GNU make stuff
18:24:06 <thou> weird
18:24:12 <dons> the make system out of yi is a bit complex -- it's a function programming system almost
18:24:16 <thou> this works:  ghc -o t t.hs ~/tmp/lib/HSCurses-1.0/libHSHSCurses-1.0.a -lncurses
18:24:33 <thou> so there's something screwy with the package registration done by that .cabal file
18:28:56 <dons> thou, you don't ha~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~ppen to work with foxy do you?
18:29:03 <dons> yikes! wirreless goes nuts.
18:29:11 <thou> here's the package.conf that cabal created:  no
18:29:14 <thou> oops
18:29:16 <thou> no, i don't
18:29:27 <thou> work with foxy
18:29:34 <dons> oh, I thought there was a bit of a .nz cabal appearing ;)
18:30:08 <reffie> yikes!
18:30:19 <Philippa_> dons: any idea how long before I can play with yi yet?
18:30:32 <thou> http://pastebin.com/284944
18:30:56 <thou> there's the package.conf file from ~/.ghc/i386-freebsd-6.4
18:30:58 <dons> Philippa_, well hs-plugins runs on cygwin and supposedly windows now.
18:31:12 <dons> I've had patches from a guy running it on windows anyway.
18:31:16 <thou> (I added newlines for legibility)
18:31:30 <Philippa_> "supposedly windows" - that mean the mingw build that most windows users download?
18:31:31 <dons> so cygwin / curses should work NOW!
18:31:46 <Philippa_> heh
18:31:56 <dons> Philippa_: I think so.. but /me is clueless in this area.
18:32:17 <Philippa_> fair enough - I'll have to find a mingw curses, too
18:32:26 <dons> yeah.
18:32:56 <dons> hs-plugins works with the pure windows ghc you get from the download page.
18:32:58 <Philippa_> though realistically I'll be looking at duplicating the wxHaskell UI fast - any idea how hard it'll be to go MDI?
18:33:01 <thou> what do dos programs use - some borland library?
18:33:34 <dons> we have a wxHaskell proposal from Wolfgang. if you wanted  to look at this, I can send you the code.
18:33:41 <Philippa_> either the ANSI driver that came with DOS or some of the BIOS facilities
18:33:45 <Philippa_> (or raw hardware manipulation)
18:33:56 <thou> Philippa_: there's no higher-level lib that's in general use?
18:33:57 <Philippa_> sure
18:34:07 <dons> yeah! write some bios/haskell ;)
18:34:07 <thou> akin to curses?
18:34:10 <thou> hehe
18:34:20 <Philippa_> no one higher-level lib
18:34:23 <thou> k
18:34:27 <Philippa_> borland had one, IIRC
18:34:37 <wagle> wxHaskell proposal?
18:34:44 <Philippa_> but post-1990 it didn't really matter
18:35:11 <thou> yeah
18:35:50 <thou> only lusers write non-gui programs :-)
18:36:04 <reffie> only lusers use gui programs :-)
18:36:13 * wagle is missing the context.  is there a (very) short summary?
18:36:45 <wagle> ..  therefore everyone is a luser?
18:37:05 <thou> that's probably an accurate statement
18:37:11 <Philippa_> wagle: yi under windows -> curses for mingw -> what people did under DOS
18:37:38 <wagle> Philippa_: thanks
18:38:05 <Philippa_> "cry", AFAICT :-)
18:39:37 <dons> wagle: http://www.cse.unsw.edu.au/~dons/Yi.jpg
18:40:14 <reffie> yi on os x?
18:40:19 <wagle> o_O
18:40:34 <reffie> i was never able to get wxhalskell to work in os x
18:40:35 <wagle> s/^/w/ ; s/$/t/
18:41:32 <wagle> yeah., i tried, but wxmac barfed, and i havent gotten around to sitting down with it and figuring out why
18:41:53 <wagle> hence my interest
18:42:29 <wagle> it just getting to about 3rd on my job queue..  8/
18:42:42 <wagle> it keeps getting to about 3rd on my job queue..  8/
18:42:57 <Pseudonym> Sheesh.
18:43:05 <Pseudonym> "Unexported functions are evil" indeed.
18:43:16 <wagle> eh?
18:43:21 <Pseudonym> haskell-cafe
18:43:34 <wagle> oh yeah, i gotta subscribe to that
18:43:53 <Pseudonym> Someone seriously asked why we have modules where not everything is exported.
18:44:02 <Pseudonym> Go back to software engineering 101.
18:44:12 <dons> that was a WEIRD question
18:44:18 * Pseudonym nods
18:44:21 <wagle> should be allow modules that export everything?  8)
18:44:32 <wagle> s/be/we/
18:44:37 <Pseudonym> wagle: Actually, I believe that we shouldn't.
18:44:56 <Pseudonym> Moreover, I think that any exported function should have a mandatory explicit type signature.
18:45:21 <Gahhh> preferably a long one
18:45:25 <Pseudonym> That way, you can generate a .hi file from the .hs file alone.
18:45:34 <thou> Pseudonym: that would be good checks for the compiler to enforce at least, when given certain flags
18:45:39 <Pseudonym> Right.
18:45:51 * wagle ponders what desirable thing that might throw out
18:46:08 <Pseudonym> wagle: Apart from brevity, I can't think of anything.
18:46:17 <dons> another point is that explicit export lists let the compiler inline like a madman
18:46:30 <wagle> nothing comes immediately to mind, but i'm wary
18:47:21 <wagle> i think i've had stuff that I couldnt assign explicit types to
18:47:39 <Pseudonym> Were they top-level declarations?
18:47:47 <wagle> but i was confused, so don't know exactly what the issue was
18:47:51 * Pseudonym nods
18:47:55 <wagle> yeah top-level
18:48:05 <Pseudonym> Oh, there are a couple of things I couldn't easily assign explicit types to.
18:49:14 <Pseudonym> When you mix phantom types with typeclass metaprograms.
18:49:32 <Pseudonym> Then the "type" of something might be a complex beast computed by a metaprogram.
18:49:48 <Pseudonym> But I have a simple fix for that.
18:49:54 <Pseudonym> Well, not so simple, possibly.
18:50:15 <Pseudonym> class ExpensiveComputation a b | a -> b
18:50:20 <Pseudonym> Then you should be able to say:
18:50:26 <wagle> that sounds about right (multiparameter, overlapping, etc)
18:50:31 <Pseudonym> foo :: (ExpensiveComputation String a) => a
18:50:47 <Pseudonym> foo has a unique type, but you have to run the typeclass program to work it out.
18:51:45 <thou> ok, here's a diff of what ghc is actually doing in the two cases (first is broken, 2nd is working):  http://pastebin.com/284953
18:51:59 <thou> to me, it looks like the -package HSCurses one is just linking the libs in the wrong order
18:52:15 <dons> oh, that's probably the problem then.
18:52:17 <thou> (puts -lHSHaskell98 too early)
18:52:24 <dons> yeah.
18:52:24 <thou> how do i fix that, though...
18:52:41 <dons> the order in the package.conf (or wherever it is in the cabal file) needs to be sorted in dependency order
18:55:13 <thou> ok, i don't see how to rearrange things in the .cabal file:  http://www.haskell.org/hawiki/HaskellIrcPastePage
18:55:16 <mugwump> is the distance between a type and a value 1 lambda?
18:56:01 <thou> i tried moving the Build-Depends: line below the Extra-libraries: line, but it made no difference
18:57:33 <dons> you can't add: base haskell98 to Build-Depends?
18:57:34 <wagle> Pseudonym: i don't remember exactly what my problem was, but adding type constraints (| a -> b, etc) feels right
18:57:48 <thou> dons: let me try that
18:57:54 <wagle> didnt have them then
18:58:04 <Pseudonym> Right.
18:58:42 <wagle> no principle type or something
18:59:28 <thou> dons: bingo, that's it
18:59:33 <thou> thanks!
18:59:37 <dons> :)
18:59:38 <wagle> i like the idea of at least trying requiring modules to have explicit types
18:59:50 <thou> stefanh_: i think i have working .cabal file for your HSCurses library
19:00:12 <thou> stefanh_: it should be better integrated with the autoconf stuff
19:01:21 <thou> dons: by the way, is it a bug in cabal that I have to explicitly list the *_hsc.c files in C-sources?
19:01:48 <thou> otherwise they don't get included in libHSHSCurses-1.0.a on the ar line
19:02:15 <foxy> dons/Phillipa: I haven't got Yi to work under cygwin yet, hsc2hs can't resolve some references
19:03:28 <dons> ok.
19:13:54 <foxy> I'd be interested if mingw is a better way to go than cygwin for yi (i.e. does it work), Phillipa
19:17:38 <stefanh_> dons/thou: I just uploaded to latest version to http://www.stefanwehr.de/darcs/hscurses
19:18:02 <stefanh_> thou: what's the problem with autoconf?
19:19:08 <Denvull> wow
19:19:20 <Denvull> i didn't know there was an irc channel for haskell, nice
19:20:01 <Pseudonym> Thanks for choosing the Haskell IRC channel!
19:20:07 <Pseudonym> Q1: Where did you find out about us?
19:21:01 <Denvull> google search "haskell irc channel"
19:21:17 <Denvull> thought i'd give it a shot
19:21:39 <Svrog> hi
19:22:17 <Denvull> hi
19:22:28 <Lemmih> Hey
19:22:36 <Svrog> would anyone be able to tell me why the following code doesn't sequence the io operations correctly:
19:22:40 <thou> stefanh_: no real problem; just need to make the .cabal file depend on autoconf values
19:22:45 <Svrog> runStateT (liftIO (putStr "moooo") >> liftIO getLine >>= liftIO . putStrLn) 0 >>= return . const ()
19:23:20 <Svrog> seems to work in ghci but doesn't work when compiled with ghc
19:23:36 <thou> stefanh_: e.g., the Versioin string, and the extra-libraries, etc.
19:25:14 <thou> stefanh_: e.g., on my system i need to have Extra-lib-dirs: /usr/local/lib and Include-dirs: /usr/local/include, to find the iconv stuff
19:26:23 <Svrog> what happens is that when i run it through ghci first 'moooo' gets printed on screen, followed by getLine, followed by printing out of whatever you entered as input - when I compile it with ghc getLine executes first before anything is displayed
19:27:18 <Svrog> i thought the state transformer and the lifting operations were supposed to take care of the sequencing or am i missing something here?
19:28:16 <arjanoosting> Svrog: It is printed to the stdout first, which is buffered
19:28:25 <arjanoosting> Svrog: see http://www.haskell.org/ghc/docs/latest/html/users_guide/faq.html
19:28:35 <Svrog> ah
19:28:41 <Svrog> so how would i go around fixing that?
19:29:25 <Svrog> nevermind - just read the link
19:29:26 <arjanoosting> Svrog: print  a new line or disable buffering on the stdout
19:29:26 <Svrog> thanks :)
19:29:32 <Svrog> yup
19:29:41 <Svrog> this was driving me nuts yesterday
19:30:09 <arjanoosting> Svrog: you're welcome
19:31:48 <Pegazus> hi, i have a Transformation function that takes a number and returns another one... 20->4->8->16->12->4 so i have to find the number, where the serie starts repeating itself... any idea how to make a function with that? given that you have the Transformate function?
19:32:19 <Pegazus> (i know how to make it in a ugly way, i want a nice one without comprenhensive lists :) )
19:37:45 <dons> @seen blackdog
19:37:46 <lambdabot> I saw blackdog leaving #haskell 5 hours, 59 minutes and 55 seconds
19:37:46 <lambdabot> ago.
19:38:31 <CosmicRay> @seen shapr
19:38:32 <lambdabot> I saw shapr leaving #haskell 7 days, 10 hours, 38 minutes and 16
19:38:32 <lambdabot> seconds ago.
19:39:11 <Svrog> well im off - thanks again!
19:39:23 <Pseudonym> shapr did blog last week.
19:39:31 <Pseudonym> So he's not dead.  Or at least he wasn't then.
19:39:37 <CosmicRay> heh
19:52:35 <Lemmih> dons: Awake?
19:53:56 <dons> yeah
19:55:06 <MachinShin> night all
19:55:35 <Lemmih> You know why HSP is using System.Plugins instead of Plugins?
19:56:12 <dons> yep. hs-plugins has just moved under the System.* namespace. grab the latest darcs
19:59:59 <Lemmih> Oki
20:28:34 <cm> hi
20:48:38 <SyntaxNinja> Lemmih: alive?
21:18:01 <foxy_> class (Ord k, HMap m) => HLookup k m a | k m -> a where
21:18:01 <foxy_>     hLookup :: k -> m -> Maybe a
21:18:01 <foxy_> instance Ord k => HLookup k HTip a where
21:18:01 <foxy_>     hLookup _ _ = Nothing
21:18:23 <foxy_> I'm getting an illegal instance declaration...
21:18:58 <foxy_> (HTip is an instance of HMap)
21:19:47 <thou> k
21:20:01 <thou> foxy_: i don't see anything wrong with it :-(
21:20:13 <Pseudonym> What exactly is the error?
21:20:19 <dons> you get -fglasgow-exts on ?
21:20:28 <foxy_> yup
21:20:29 <foxy_>     Illegal instance declaration for `HLookup k HTip a'
21:20:29 <foxy_> 	(the instance types do not agree with the functional dependencies of the class)
21:20:29 <foxy_>     In the instance declaration for `HLookup k HTip a'
21:20:54 <Pseudonym> What's the kind of HTip?
21:21:06 <foxy_> *
21:21:32 <Pseudonym> Your problem here is that the fundep suggests that a is a concrete type, but it isn't.
21:21:51 <Pseudonym> i.e. that the combination of k and m determines a.
21:21:54 <Pseudonym> But it doesn't.
21:21:56 <Pseudonym> a could be anything.
21:22:42 <foxy_> it works when HTip is replaced by (HBin k a l r) because the a's unifies, is this what is lacking in the above code?
21:22:57 <foxy_> could I say forall a?
21:23:18 <Pseudonym> I don't know.
21:23:22 <Pseudonym> Try it and see.
21:25:02 <foxy_> forall doesn't seem to help
21:26:49 <Pseudonym> Thinking about how GHC is implemented, I can't really see how you could implement that instance.
21:29:36 <foxy_> I must be doing something wrong, I'm attempting to translate heterogeneous lists to balanced trees
21:29:53 <foxy_> and the lists are working code
21:31:51 <Pseudonym> Hmmm.
21:31:57 <Pseudonym> What's the corresponding HList instance?
21:47:59 <x3n0n> Is this an @pl bug or is it just me:
21:48:25 <x3n0n> @pl f l = [length l, head l]
21:48:26 <lambdabot> f = liftM2 (:) length ((: []) . head)
21:48:51 <x3n0n> @type Control.Monad.liftM2 (:) length ((: []) . head)
21:48:52 <lambdabot> bzzt
21:50:29 <Pseudonym> @type liftM2
21:50:30 <lambdabot> bzzt
21:50:37 <Pseudonym> @type Control.Monad.liftM2
21:50:38 <lambdabot> Control.Monad.liftM2 :: forall r (m :: * -> *) a2 a1.
21:50:38 <lambdabot>         (Monad m) =>
21:50:38 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:51:06 <Pseudonym> @pl \l -> [length l, head l]
21:51:07 <lambdabot> liftM2 (:) length ((: []) . head)
21:51:22 <Pseudonym> @pl \l -> length l : head l : []
21:51:23 <lambdabot> liftM2 (:) length ((: []) . head)
21:51:32 <Pseudonym> @pl \l -> length l : (head l : [])
21:51:33 <lambdabot> liftM2 (:) length ((: []) . head)
21:51:49 <Pseudonym> @pl \l -> (c length l (c (head l : []))
21:51:50 <lambdabot> (line 1, column 36):
21:51:50 <lambdabot> unexpected end of input
21:51:50 <lambdabot> expecting variable, "(", operator or ")"
21:51:58 <Pseudonym> @pl \l -> c length l (c (head l : []))
21:51:59 <lambdabot> ap (c length) (c . (: []) . head)
21:52:27 <x3n0n> hm.
21:52:29 <x3n0n> @type ap
21:52:30 <lambdabot> bzzt
21:53:56 <Pseudonym> @type \l -> [length l, head l]
21:53:58 <x3n0n> @pl \l -> cons (length l) (cons (head l) nil)
21:53:59 <lambdabot> \l -> [length l, head l] :: [Int] -> [Int]
21:53:59 <lambdabot> liftM2 cons length (flip cons nil . head)
21:54:15 <Pseudonym> @type let s f g x = f x (g x) in s ((:) . length) (flip ((:) head) [])
21:54:17 <lambdabot> bzzt
21:54:45 <Pseudonym> @type flip ((:) head) []
21:54:47 <lambdabot> bzzt
21:58:15 <Pseudonym> Aaah.
21:58:21 <x3n0n> aah?
21:58:44 <Pseudonym> Oh, I worked out why my pointless derivation was wrong.
21:59:21 <x3n0n> the "s" version?
21:59:41 <Pseudonym> @type let s f g x = f x (g x) in s ((:) . length) (flip ((:) . head) [])
21:59:42 <lambdabot> let s f g x = f x (g x) in s ((:) . length) (flip ((:) . head) []) ::
21:59:42 <lambdabot> [Int]
21:59:42 <lambdabot>                         -> [Int]
21:59:47 <Pseudonym> That's it.
21:59:53 <Pseudonym> @plugs let s f g x = f x (g x) in s ((:) . length) (flip ((:) .
21:59:54 <lambdabot> parse error on input `;'
22:00:04 <Pseudonym> @plugs let s f g x = f x (g x) in s ((:) . length) (flip ((:) . head) []) [1,2,3]
22:00:06 <lambdabot> [3,1]
22:00:15 <Pseudonym> I don't know how to do it without s, though.
22:00:42 <x3n0n> yeah, I'm wondering if liftM2 is intended to be some sort of S/W derivative by the @pl code
22:00:47 <Pseudonym> Maybe.
22:01:07 <Pseudonym> @pl \l -> [length l, head l]
22:01:08 <lambdabot> liftM2 (:) length ((: []) . head)
22:01:08 <x3n0n> think putting this in the logs is enough of a lambdabot bug report? :)
22:01:27 <Pseudonym> Nope.
22:02:10 <dons> use @todo, if you think  there is a bug.
22:02:20 <x3n0n> aha
22:02:27 <dons>  @todo-add
22:02:56 <x3n0n> @todo-add fix @pl \l -> [f l, g l]
22:02:57 <lambdabot> Entry added to the todo list
22:03:00 <x3n0n> @todo
22:03:02 <lambdabot> 0. dons: Release lambdabot 3.0
22:03:02 <lambdabot> 1. SamB: A way to get multiple results from a google search
22:03:02 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
22:03:02 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
22:03:02 <lambdabot> the command was given on
22:03:03 <lambdabot> 4. SamB: stop mangling long urls
22:03:05 <lambdabot> 5. dons: improve formatting of @dict
22:03:07 <lambdabot> 6. SamB: @karma+ should report total karma
22:03:09 <lambdabot> 7. x3n0n: fix @pl \l -> [f l, g l]
22:03:28 <Pseudonym> Ah.
22:03:31 <Pseudonym> @pl \l -> f l (g l)
22:03:31 <lambdabot> ap f g
22:03:33 <Pseudonym> That's what app is.
22:03:35 <Pseudonym> It's S.
22:04:36 <Pseudonym> Bingo.
22:04:39 <Pseudonym> liftM2 is S'
22:05:21 <Pseudonym> Excelt ist isn't.
22:05:23 <Pseudonym> Except
22:05:30 <x3n0n> aha
22:05:56 <Pseudonym> It kind of is, in a certain Reader monad.
22:07:12 <x3n0n> @todo-del 7
22:07:13 <lambdabot> Removed: fix @pl \l -> [f l, g l]
22:07:41 <x3n0n> @todo-add @pl: don't use liftM2 for S'
22:07:41 <lambdabot> Entry added to the todo list
22:09:04 <x3n0n> thx; that was bugging me.  I can go to sleep now. :)
22:28:40 <foxy_> @wiki pastebin
22:28:41 <lambdabot> http://www.haskell.org/hawiki/pastebin
22:28:50 <Gahhh> @paste
22:28:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:28:58 <xerox> @wiki HaskellIrcPastePage
22:28:59 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:29:05 <xerox> oh k :-)
22:29:15 <foxy_> ah
22:33:18 <foxy_> I broke ghc in 15 lines, see the end of the paste page
22:36:13 <foxy_> (the code isn't correct btw, but it breaks the compiler)
22:39:28 <ozone> SyntaxNinja: cabal question ...
22:39:46 <ozone> SyntaxNinja: i need to generate some in-place ghc package .conf files
22:41:08 <ozone> SyntaxNinja: currently i'm doing this by modifying the build process, so i have a foo.cabal.in file that's processed by autoconf to make a foo.cabal file, and then i echo '[]' > foo.inplace.conf, and run ghc-pkg register -f foo.inplace.conf foo.cabal
22:41:23 <ozone> the foo.inplace.conf is then used by other bits in the source tree
22:41:41 <ozone> (that compile with ghc --package-conf=../foo/foo.inplace.conf)
22:41:47 <ozone> is there an easier way to do this?
22:42:03 <ozone> seems like that seems to be the de facto way of doing it, but it seems awfully mangly
22:56:54 <SyntaxNinja> ozone: you shouldn't generate the foo.cabal file, if you can avoid it. that's what the .buildinfo file is for
22:57:23 <SyntaxNinja> so you need a temporary place to register the package so you can build something else against it?
22:58:22 <ozone> right
22:58:29 <ozone> that seems pretty common
22:58:45 <ozone> at least, the two projects i just worked on needed it, and i'm cabalising c2hs now, and that needs it ...
22:58:46 <SyntaxNinja> ozone: because you have two libraries in one package or something?
22:58:51 <ozone> nod
22:59:02 <SyntaxNinja> so cabal doesn't support two libraries in one package yet
22:59:23 <SyntaxNinja> you should split them into several packages if you can; cabal packages have a one-to-one relationship w/ ghc packkages
22:59:46 <SyntaxNinja> we want to be able to support this in the future, but we don't yet.
23:00:20 <SyntaxNinja> there are a number of complexities to it, and we haven't even put together a proposal for how to solve the problem; other stuff is more pressing, since the vast majority of packages only have one library, and there's a workaround
23:00:40 <ozone> ok, that's alright
23:01:20 <ozone> what's this .buildinfo file?  looking at the docs now, but i don't know the different between a .buildinfo and a .cabal file
23:02:36 <SyntaxNinja> .buildinfo has a subset of the fields that the .cabal file uses.  those that are OK to generate; the other fields are required in the source, since they describe the package.
23:02:57 <ozone> ah, ok
23:03:02 <SyntaxNinja> and if you generate the cabal file, then the cabal system can't build it anymore, and you've broken the interface
23:03:10 <ozone> i.e. it's system-dependent
23:03:11 <SyntaxNinja> s/build/read
23:03:14 <SyntaxNinja> yeah
23:03:22 <ozone> roger, thanks
23:03:37 <SyntaxNinja> but stuff like version, build-depends and what-have-you need to be in the .cabal file for the sake of layered tools, including the cabal api and hackag.
23:04:16 <ozone> ok
23:42:55 <kaol> @moo
23:42:57 <lambdabot>             (__)
23:42:57 <lambdabot>             (@o)
23:42:57 <lambdabot>      /-------\/
23:42:57 <lambdabot>     / |     ||
23:42:57 <lambdabot>    *  ||----||
23:42:58 <lambdabot>       ^^    ^^
23:43:00 <lambdabot> This cow lived with
23:43:02 <lambdabot> the Little Rascals
