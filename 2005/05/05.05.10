00:05:32 <xyzp_> Which snippet?
00:05:51 <Gahhh> you lost the link ?
00:06:08 <xyzp_> No, I just meant which piece of code in the thread.
00:06:35 <Gahhh> the 1st mainly
00:08:25 <Pseudonym> I think that RAII is a fairly good thing.
00:08:48 <xyzp> You should probably only have to check the invariant when it's necessary.
00:08:55 <xyzp> Hmm.
00:08:56 <Gahhh> I actually don't see how you have fewer lines of code between OddNumber2 and OddNumber3
00:09:27 <Gahhh> oh I do
00:09:29 <xyzp> There should also be conditional compilation for disabling the check.
00:09:49 <xyzp> Hmm.
00:09:53 <Gahhh> the destruction of the InvariantChecker checks it again after setting a new value
00:13:43 <Gahhh> It's a neat trick but accomplishing the goal in a side effect somehow feels wrong to me.
00:15:49 <xyzp> The examples don't really use const well.
00:16:05 <xyzp> But I suppose that's not really the point.
00:16:21 <Gahhh> nope
00:18:34 <xyzp> C++ is a pretty nasty language.
00:18:44 <Gahhh> I believe the environment is multithreaded or something and the object is vulnerable.
00:19:31 <xyzp> Vulnerable how?
00:20:00 <Gahhh> quoting the author: "Basically, if your instance is scribbled on between calls on its members, it's possible to call on an object that's become invalid through some other code's misdeeds."
00:20:23 <xyzp> Hmm.
00:20:28 <nlv11757_> morning
00:20:35 <reffie> ever heard of locks?
00:20:45 <xyzp> If that's happening it's broken anyway.
00:21:18 <Gahhh> well, I thought about locks, too. So I don't truly understand the intention here.
00:23:32 <Pseudonym> Gotta go.  Nytol.
00:23:35 <xyzp> I wonder if they'll pile DBC primitives into a future revision.
00:24:05 <Gahhh> well, the thread has a post that says design by contract has been proposed for C++ which shall add invariant checking...
00:24:31 <xyzp> Yes, I'm sure lots of things have been suggested for future standards.
00:25:21 <Gahhh> so this must be a real problem
00:25:44 <xyzp> People just like to add features to languages.
00:26:07 <xyzp> Until they're Perl or C++ ;)
00:26:26 <xyzp> At least DBC is useful.
00:27:24 <Gahhh> not to me :)
00:27:44 <Gahhh> There you go: http://www.cse.ohio-state.edu/~weide/rsrg/documents/2004/04ESWH.pdf
00:27:58 <Gahhh> contract checking for C++
00:28:29 <Lemmih> @seen SyntaxNinja
00:28:30 <lambdabot> I saw SyntaxNinja leaving #haskell 55 minutes and 32 seconds ago.
00:29:41 <Gahhh> ok, this paper is about violation of contract between the object and its owner. no multiple threads.
00:30:09 <xyzp> In about four minutes I'll get to read it.
00:31:01 <Gahhh> oh, dialup ?
00:31:08 <xyzp> Yep.
00:31:44 <xyzp> I Hope I Work with Mediocre People
00:31:47 <xyzp> Haha.
00:31:51 <Gahhh> ?
00:31:54 <xyzp> I wish I didn't.
00:32:10 <xyzp> I decided to peruse other forum topics.
00:32:16 <Gahhh> oh
00:33:44 <xyzp> Hmm.
00:36:00 <xyzp> Meh.
00:36:10 <Gahhh> ok, so the example was apparently simplified for brevity.
00:36:30 <xyzp> Next time don't let me stray into reading random forum flotsam.
00:36:59 <Gahhh> you can somehow violate the contract via public methods by a) your fault b) implementation fault.
00:37:14 <Gahhh> and you want to know if that is happening.
00:38:13 <Gahhh> that was educational. phew.
00:49:46 <xyzp> That approach is really inefficient.
00:50:23 <xyzp> Oh well.
00:59:48 <nlv11757_> does someone have a nice example of a makefile calling latex, makeindex, rerun latex when necessary, etc. ?
00:59:56 <nlv11757_> would save me a great deal of trial and error
01:08:03 <Itkovian> nlv11757_:  I think I've got something lying somewhere
01:08:08 <Itkovian> let me look it up
01:12:29 <Itkovian> nlv11757_: grab it at http://elis.ugent.be/~ageorges/makefile
01:14:28 <nlv11757_> ah thanks Itkovian
01:14:42 <Itkovian> I hope it works as it should :-)
01:14:56 <nlv11757_> does it also rerun if necessary?
01:15:13 <nlv11757_> i also found one that claims to do so, but yours looks clener
01:15:15 <nlv11757_> cleaner
01:18:05 <Itkovian> I didn't write it myself, so don't blame me if it doesn't work
01:20:11 <nlv11757_> heheh thanks anyway, it's bound to save me time anyhow
01:20:17 <kosmikus> that file runs LaTeX only a fixed number of times
01:21:22 <Itkovian> hmm
01:21:29 <Itkovian> so shoot me :-)
01:24:45 <nlv11757_> http://www.math.ohio-state.edu/~jeffh/projects/make/
01:24:50 <nlv11757_> claims to be the ultimate makefile for latex :D
01:24:56 <nlv11757_> it does rerun and stuff
01:53:35 <Heffalump> hah, mine is better than that.
01:54:41 <Heffalump> for one thing it handles bibtex
01:55:05 <Heffalump> and makes pdfs with thumbnails
01:55:06 <kosmikus> "Rerun to get cross-references" is too conservative
01:55:15 <kosmikus> there are many other "Rerun" warnings that LaTeX produces
01:55:15 <Heffalump> I use "Rerun to get"
01:55:33 <Heffalump> (which is all I've ever run into)
01:57:39 <kosmikus> I use "Warning.*Rerun"
02:02:14 <nlv11757_> ok so if you guys have better makefiles to run latex, share :)
02:02:24 <Heffalump> mine is rather project-specific
02:02:28 <Heffalump> you can have it if you like, though
02:02:49 <nlv11757_> if the latex part is distillable sure
02:03:03 <Heffalump> http://urchin.earth.li/~ganesh/temp/latex-makefile
02:03:14 <Heffalump> some of the inputs are generated by project-specific stuff
02:04:34 <nlv11757_> ah i c, well i will just merge all those ultimate makefiles to get one uberultimate :P
02:04:50 <nlv11757_> kosmikus sharing also? :P
02:06:39 <Heffalump> the set of dependencies between .aux, .dvi, .bbl is relatively finely tuned
02:07:58 <kosmikus> nlv11757_: Heffalump's seems clearly superior
02:08:17 <nlv11757_> heheh humble humble
02:08:37 <Heffalump> I had to do _something_ while avoiding writing my thesis, you know.
02:08:38 <kosmikus> nlv11757_: but you might want to look at the "rubber" program; if you don't want to share your projects with other people, I've had good experiences with that one
02:09:07 * earthy grins at hef
02:09:15 <nlv11757_> ow lol, rubber in google is not working out well :P
02:09:23 <Heffalump> rotfl
02:09:24 <kosmikus> no :)
02:09:29 <Heffalump> @google rubber LaTeX
02:09:31 <lambdabot> http://www.immune.com/rubber/
02:09:35 <kosmikus> rubber latex isn't any better
02:09:44 <nlv11757_> heheh my thoughts exactly
02:09:44 <nlv11757_> :D
02:09:48 <kosmikus> rubber.sf.net, I think
02:10:14 <tuomov> someone should rewrite latex without turing-completeness and call it pvc
02:10:25 <earthy> rubber ctan   did the trick
02:10:57 <earthy> but resulted in a broken link. dang. :)
02:11:17 <nlv11757_> http://www.pps.jussieu.fr/~beffara/soft/rubber/
02:11:23 * earthy nods
02:11:47 <nlv11757_> ow they even got a darcs repos
02:12:17 <nlv11757_> is darcs going to be the next best thing in version management? maybe i should look into it
02:12:50 <kosmikus> going to be?? ;:
02:13:00 <Heffalump> it's very cool, but it has some performance and usability issues
02:13:46 <earthy> the latter are mostly related to the former, right?
02:14:00 <musasabi> How should (~>) be defined ? I cannot find the definition anywhere. Do I need ghc-6.5 or is 6.4 fine?
02:14:00 <Heffalump> I think the UI needs some work in itself.
02:14:25 <Heffalump> there's a fair number of things that should be simple operations in the underlying algorithms but don't exist
02:14:50 <earthy> the UI sucks, yes
02:14:53 <Heffalump> (I also think the conflict handling is wrong, but it's no worse than in any other VCS)
02:15:12 <earthy> single-keystroke all the way.... there is exactly 1 other program I know of that worked like that
02:15:32 <Heffalump> darcs record is just too hard to use with a big patch
02:16:18 <kosmikus> not if you want to record everything
02:16:35 <Heffalump> and you know you do
02:16:53 <Heffalump> oh, no, even if you don't know it's ok
02:17:03 <Heffalump> but if you want to leave out some bits it's really hard work
02:17:19 <Heffalump> but the idea at all is more than most VCSes give you :-)
02:17:31 <kosmikus> it's a bit better now because there's "f" to record everything else in a file
02:18:02 <Heffalump> I think that's been there for over a year
02:18:49 <nlv11757_> but is it an improvement over cvs/subversion (i know it fundamentally differs)
02:18:53 <kosmikus> really? I think it wasn't there at icfp contest time, but I might be wrong
02:18:59 <earthy> nlv: yes, it is
02:19:21 <Heffalump> nlv11757_: yes
02:19:27 <Heffalump> (if you don't have a huge tree to handle)
02:19:50 <earthy> i.e.: as long as you're not trying to do the Linux kernel
02:20:07 <earthy> it seems to do reasonably okay on GHC itself, right?
02:20:15 <Heffalump> errm, not sure.
02:20:27 <Heffalump> I had the impression John's computer was spending days on importing fptools
02:20:32 <Heffalump> but it might be quite fast once that's done
02:20:40 <earthy> I had the impression it was only the import that took time
02:21:48 <earthy> and I also had the impression that was (at least partly) due to the fact he imported the entire history as well
02:22:59 <nlv11757_> ok so it doesnt scale to business projects then?
02:24:28 <nlv11757_> hey i already like rubber after reading the first line "The purpose of Rubber is to make the building of a document automated, fromt the source files to the final document file, replacing the work of a Makefile."
02:28:56 <musasabi> Heffalump: doing darcs record FileA FileB FileC helps doing the record in a nice fashion.
02:30:43 <Heffalump> if you know the files, yeah
02:34:29 <earthy> nlv: depends on what you classify as 'business projects'
02:38:36 <nlv11757_> earthy, my adviser at philips is enthousiastic and wants to try it for his next project.
02:38:53 <nlv11757_> so what kind of business....no idea :D
02:47:09 <earthy> ;)
02:48:47 <Oejet> It seems in a loop like withArray uses exactly as much memory as pokeArray on a reused array.  Is the array in withArray actually reused also?
03:03:28 <tromp> wow, i never realized how awesome css was
03:03:47 <tromp> but http://csszengarden.com/ convinced me
03:14:14 <dons> very nice.
03:28:33 <wilx> Whoa!
03:28:37 <wilx> Nice.
03:29:21 <dons> makes me want to rework some of my css
03:59:29 <nlv11757_> "This file based on 'Tranquille' by Dave Shea"
03:59:44 <nlv11757_> that wouldnt happen to be shapr now would it
04:00:19 <nlv11757_> ok so he's the only person i know with the name shae :P
04:00:43 <boegel> Shae /= Shea
04:01:08 <dons> it's a moderately common name. I know 3.
04:01:37 * boegel knows 1, but he's worth 3
04:02:20 <dons> Indeed!
04:03:07 <nlv11757_> quite nice css stuff, but i never quite find the motivation to delve into it
04:09:09 <nlv11757_> hmm, anyone with rubber experience (the program!!)
04:09:46 <dons> @pl addToEnv g i t = union g (i,t)
04:09:47 <lambdabot> addToEnv = (. (,)) . (.) . union
04:10:02 <dons> hehe. @karma+ @pl
04:14:07 <wilx> ebil
04:31:43 <musasabi> Why is the following not valid with HaskellDB records? ((foo << constant "foobar") ! foo)
04:33:53 <foxy__> @seen dons
04:33:55 <lambdabot> dons is in #haskell. Last spoke 23 minutes and 52 seconds ago.
04:34:26 <dons> yikes!
04:34:28 <foxy__> dons: Hi, my program seems to break Eval.Haskell.eval
04:34:35 <dons> hmm!
04:35:02 <foxy__> it successfully loads and runs some code.  When I load it again the program crashes
04:35:24 <dons> hmm. on cygwin, or anywhere?
04:35:31 <foxy__> linux and cygwin
04:35:52 <dons> ok. better send me the code. and how to reproduce the bug.
04:42:19 <shelarcy> foxy: Do you test hs-plugin by make check?
04:42:42 <dons> that's a good way to check it works, yes.
04:44:13 <foxy__> yes I've run make check
04:45:41 <foxy__> ooo, does readFile close a file?
04:46:20 <dons> explicit hClose doesn't hurt.
04:47:13 <dons> it's lazy, so it's not going to close it immediately, is it?
04:47:26 <dons> it just runs hGetContents (no hClose)
04:48:45 <foxy__> hm, readFile gives no handle on the file though, and files open for reading should allow other files to read, it crossed my mind that the second pass could cause a FD crash, but I don't think it would
04:49:30 <foxy__> and I parse the whole file straight away
04:49:36 <foxy__> dons: did you get the code?
04:49:59 <dons> got it. I'll have a look tomorrow.
04:50:16 <dons> you could check with openFile/hClose
04:50:33 <dons> but not sure why it would cause a crash... more likely some caught fd error
04:53:04 <vdrab> good evening haskellers. I summon Thy great Optimization Powers
04:53:43 <vdrab> I have a fairly simple algorithm that crunches 5-tuples of Int's .... nothing very involved, just lots and lots of them....
04:53:55 <karingo> The source of their greatest power is to know when not to use their powers.
04:54:08 <vdrab> hehe
04:54:39 <vdrab> would there be any obvious optimization to get better performance? unbox the tuples?
04:54:46 <dons> definitely
04:54:57 <dons> but a strictness annotation would do this job
04:55:02 <vdrab> what would that look like? never
04:55:03 <vdrab> oh
04:55:08 <dons> data D = C !(Int,Int)
04:55:26 <vdrab> a data type would be more performant than a bare tuple?
04:55:30 <dons> crank up -O. also, profile!
04:55:52 <nlv11757_> hey dons, i have an AST of a C program, would strictness annotations in the tree for integers, strings help me too?
04:55:59 <dons> you could explicitly use an unboxed tuple. (# Int#, Int# #) I think.
04:56:03 <Lemmih> musasabi: Because it's a Record, not a Rel.
04:56:20 <vdrab> I did, the program spends all its time in a function that compares tuples
04:56:30 <dons> nlv11757_: maybe. a lot of good Haskell hackers habitually strictify constructor fields
04:57:07 <vdrab> so, type C = (#Int#,#Int#,...) would do it?
04:57:26 <nlv11757_> probably improves my memory consumption drastically, since there are a lot of occurences of these integer, string constants in a syntax tree
04:57:31 <nlv11757_> or not?
04:57:31 <Philippa_> OTOH, laziness on some program transformations is really useful
04:57:32 <dons> (# #) was the syntax I was thinking of. (unboxed tuples)
04:57:49 <dons> or critical
04:58:01 <Philippa_> right. Probably fine on strings and ints though
04:58:14 <nlv11757_> yeah im targeting those constants
04:58:18 <foxy__> dons: my linux version is running... woops only cygwin crashes
04:58:18 <vdrab> does that mean I need to declare a data type, or does it work on  just type or newtype as well?
04:58:22 <Philippa_> fair enough, I'd say go for it
04:58:22 <nlv11757_> cause there are sitting there anyway
04:58:41 <Philippa_> Ints are major offenders for laziness doing silly things IME
04:58:57 <nlv11757_> Philippa_, do you have experience with rubber?
04:59:25 <nlv11757_> the python script that is taking care of invoking latex and friends
04:59:28 <vdrab> that's good to hear... I need a BIG performance increase for this program to be usable
04:59:29 <nlv11757_> that is
05:00:05 <dons> vdrab, start profiling. without seeing your code, I can see you can improve it ;)
05:00:05 <Philippa_> nlv11757_: nope
05:00:33 <dons> hmm, that didn't sound right. I mean that I have great confidence in the ghc profiling tools.
05:01:19 <musasabi> Lemmih: got that one fixed :-)
05:01:34 <dons> vdrab, and it's probably not the data representation that slowing things down -- more likely your code is just inefficient.
05:01:43 <musasabi> Violating monomorphism restriction gets weird error messages.
05:03:08 <vdrab> dons: I'm not so sure.... the central algorithm is taken from a paper on computing lattices that was published last year... it gives me very good results for small data sets, it's just that these sorts of operations don't scale well in any case
05:03:40 <vdrab> it's orders of magnitude faster than my previous algorithm :)
05:03:46 <vdrab> but still...
05:03:48 <dons> ok. maybe. but profiling will tell you in no time at all...
05:03:53 <dons> ghc -prof -auto-all Foo.hs
05:03:57 <dons> ./a.out +RTS -p
05:04:04 <dons> read a.out.prof
05:04:53 <vdrab> I did some time ago, ... let's see if anything changed from then
05:06:28 <dons> fix $ \repeat -> profile >> edit >> run >> repeat
05:06:31 <dons> ;)
05:06:45 <bourbaki> moin
05:07:18 <vdrab> right... *sigh*
05:07:21 <Oejet> bourbaki: Hehe.  Too much delay this time.
05:07:33 <vdrab> I'll still implement that unboxing thing though...
05:07:35 <bourbaki> Oejet: ?
05:07:53 <dons> vdrab, yeah. sounds reasonable. probably get good wins with arith code
05:08:28 <vdrab> right now they are just bare Int tuples.... in order to unbox, do I need to make them into a data type?
05:08:44 <vdrab> ... newtype?
05:08:50 <dons> you can use unboxed tuples for example.
05:08:52 <shelarcy> foxy : cygwin crashes by make check or your program?
05:09:06 <dons> (# x, y #)
05:09:15 <vdrab> doesn't seem to work
05:09:36 <Oejet> bourbaki: Just my speculation about automatic join messages.
05:09:36 <vdrab> in GHCi, that is.... maybe that's normal
05:09:47 <vdrab> I'll look at the GHC docs.... thanks though.
05:10:00 <dons> vdrab, sure it does. (1) you need -fglasgow-exts. (2) read S 7.2.2 in the ghc user guide
05:10:17 <vdrab> aha
05:10:26 <dons> then (3) you may want to have unboxed ints in your unboxed tuple.
05:10:46 <dons> When an unboxed tuple is returned the components are put directly into registers
05:11:00 <dons> so no allocs
05:11:21 <boegel> hey bourbaki
05:11:24 <vdrab> I remember reading that you need to rewrite function definitions that operate on them too though... is that true?
05:11:28 <dons> so you might want something like (# Word32#, Word32# .. #)
05:13:01 <dons> well, they can only be deconstructed in case expressions.
05:13:17 <dons> (not patterns in function defns)
05:13:27 <dons> so there's some pain for your gain
05:13:38 <vdrab> hehe.... so it seems
05:14:03 <vdrab> right, back to slaying the dragon
05:14:07 <vdrab> thanks dons
05:14:09 <dons> but unboxed tuples of unboxed words seem a good way to do this, I reckon.
05:15:10 * vdrab makes note to self... " out ... with ... the ...booo...x..es.."
05:15:21 <_JusSx_> loala
05:16:10 <Oejet> _JusSx_: Ciao.
05:21:22 <foxy__> shelarcy: crashes by my program
05:22:07 <dons> I wonder then if there's some unsupported magic in the runtime loader.
05:22:22 <dons> unsupported on cygwin, that is.
05:22:45 <shelarcy> hmm, my enviroment on cygwin, dynload/should_fail_3/ and pdynload/spj3/ freeze hs-plugin sample program.
05:23:13 <dons> do you have the latest darcs hs-plugins?
05:23:25 <shelarcy> Yes.
05:24:59 <dons> no idea what's happening there, maybe foxy__ knows?
05:29:50 <dons> those two are limit cases, though. I'm not too surprised.
05:33:55 <vdrab> dons: which module gets me those unboxed integer types? I imported Word, but it doesn't seem to like that.
05:34:21 <vdrab> (sorry to keep pulling your sleeve)
05:34:27 <dons> GHC.Word should work
05:34:33 <dons> @kind GHC.Word.Word32#
05:34:40 <lambdabot> bzzt
05:35:01 <dons> @kind GHC.Base.Word32#
05:35:02 <lambdabot> GHC.Base.Word32# :: #
05:35:22 <dons> @type 42# :: GHC.Base.Word32#
05:35:23 <lambdabot> bzzt
05:36:14 <vdrab> ok. thank you.
05:38:26 <dons> @type 42#
05:38:27 <lambdabot> 42# :: GHC.Prim.Int#
05:39:48 <dons> lots of other fun stuff in GHC/Word.hs
05:42:35 <vdrab> but which module do you need to load? GHC.Base? Word?
05:43:27 <dons> you'll need GHC.Baes and GHC.Word, I think.
05:43:45 <dons> GHC.Int too maybe
05:44:30 <vdrab> I see.
05:45:03 <dons> @type int2Word# 0x7FFFFFFF#
05:45:05 <lambdabot> bzzt
05:45:29 <dons> @type GHC.Base.int2Word# 0x7FFFFFFF#
05:45:31 <lambdabot> GHC.Base.int2Word# 0x7FFFFFFF# :: GHC.Prim.Word#
05:46:48 <vdrab> I defined a type :   type Plot = (# Word32#, Word32#, Word32#, Word32# #).
05:47:04 <vdrab> now when I say      states :: [Plot]
05:47:31 <vdrab>     Kind error: Expecting a lifted type, but `Plot' is unlifted
05:47:32 <vdrab>     In the type: [Plot]
05:47:32 <vdrab>     While checking the type signature for `states'
05:47:36 <vdrab> is what I get
05:47:48 <dons> kind error :)
05:48:22 <vdrab> can I just close my eyes and it will go away? :)
05:48:31 <dons> you can't have lists of these things. those lists are probably a bad thing for performance anyway (maybe you'd like to use arrays?)
05:48:45 <dons> gimme sec..
05:48:46 <vdrab> argh...
05:49:55 <dons> no, it's not all bad. we can deal with it. hacking.. hacking..
05:50:41 <foxy__> shelarcy: the make check programs worked for me, although I left the computer running for a while
05:51:34 <dons> vdrab, so we can start with data Plot = P !(Int,Int,Int,Int,Int)
05:51:45 <dcoutts_> vdrab, the point is that these unboxed tuples are not propper first class values and you can't stick them in data structures etc, you can basically only use them as temproary values that get constructed, returned from a function (for example) and immediately deconstructed. See the ghc user manual for the exact rules concerning unboxed values & unboxed tuples
05:51:48 <dons> where the strictness annotation will do the unpacking.
05:52:34 <vdrab> right
05:53:34 <dcoutts_> dons, vdrab: better would be data Plot = P !Int !Int !Int !Int !Int
05:54:06 <vdrab> dcoutts : I was thinking just that
05:54:07 <dons> true.
05:54:09 <dcoutts_> since otherwise you get a strict tuple (but tuples are lazy in their components)
05:54:24 <dcoutts_> the tuiple itself will be strict but not the elements
05:54:51 <dcoutts_> and if you use the unpack pragma, it'll put raw ints directly into the P constructor - very compact
05:55:34 <dons> this is what you usually see -- I guess  I was being a bit ambitious suggesting unboxed tuples of unboxed ints ;)
05:56:03 <dons> as the restrictions on their use mean you have to plan with that to begin with.
05:56:29 <vdrab> on a side note : what happens when you have an enumerated data type like      data Color = Red | Blue | Yellow     how efficient / compact is memory representation there?
05:56:39 <dons> tags!
05:57:08 <dons> it turns into case analysis on bytes or smalls in the back end, iirc
05:57:10 <vdrab> do the constructors get boxed too? wouldn't make a lot of sense, intuitively
05:57:17 <vdrab> I see
05:57:23 <dons> the constructors are just numeric tags.
05:57:31 <vdrab> I would have thought so
05:57:46 <vdrab> so they are quite fast then?
05:58:01 <dons> yep.
05:58:26 <dons> switch tag { case 0x01: foo ; break ; case 0x02: bar ; break }
05:59:17 <vdrab> maybe I can reformulate things like that, define constructors instead of Ints, I only need a very small integer range anyways
05:59:25 <TheHunter> speaking of "tags", how does one use hasktags with vim?
06:00:04 <dons> vdrab, it would be a bit hacky.. packing stuff into a Word with Data.Bits might be nicer.
06:00:56 <Oejet> TheHunter: The binding has an overhead of the difference between 530s and 302s for decompression and compression of the Linux kernel.
06:01:27 <vdrab> dons : probably yeah
06:01:59 <Oejet> TheHunter: (The former numbers was with profiling enabled.)
06:02:05 <vdrab> so, in case of that  "data Plot = P !Int !Int !Int !Int", can those be stored in lists?
06:02:25 <dons> yep.
06:02:30 <vdrab> sweet
06:03:09 <dons> if lists turn out to be too slow, you can look at unboxed arrays. (but i should stop suggesting all these speed hacks)
06:03:16 <vdrab> then it's back to the drawing board. thanks for the input, I appreciate it.
06:03:20 <vdrab> dons : hehe
06:04:17 <vdrab> arrays would not be feasible I think.... I don't need fast access, just some structure to hold all the plots
06:04:33 <dons> oh, ok.
06:17:53 <foxy_> shelarcy: do you get CYGWIN98-4.10 for `uname`?
06:19:39 <shelarcy> my uname is CYGWIN_NT-5.0.
06:20:06 <foxy_> there might be differences in our runtime systems
06:21:42 <foxy_> which might account for differences in behaviour
06:27:19 * foxy_ plugs hs-plugins
06:49:09 <boegel> kosmikus: are you active ? I have a LaTeX related question
06:54:25 <earthy> he's present
06:54:31 <earthy> not necessarily on channel
06:54:36 <earthy> but, ask away. ;)
06:56:27 <boegel> we'll, I'm using the align* environment to construct proofs in my thesis
06:56:45 <boegel> but I'd like some pieces to be centered, and other to be aligned on the right
06:57:00 <boegel> as in= left & center & left & center & left (for example)
06:57:16 <boegel> is there any way to achieve this ? it seems now everything is aligned right
06:59:27 <earthy> okay, I see what you mean
07:00:28 <boegel> I hope I made it clear :)
07:01:05 <boegel> I know a table environment has something like [lcl] to achieve this kind of stuff, but I don't know if (or how) align has it
07:01:10 <earthy> but align does not align on more than 1 vertical part, or does it?
07:01:20 <earthy> I mean,
07:01:22 <earthy> \begin{align}
07:01:28 <earthy>    left & op right \\
07:01:32 <earthy>   left & op right
07:01:34 <earthy> \end{align}
07:01:37 <earthy> will align the op's
07:02:01 <earthy> and there seems to be no support for aligning more than 1 op, according to this latex companion
07:02:51 <earthy> maybe you want the alignat environment?
07:03:08 <earthy> \begin{alignat}{nrofcolumns}
07:03:27 <earthy>     left & op rigth & left & op right &  left & op rithg \\
07:03:29 <earthy>     left & op rigth & left & op right &  left & op rithg \\
07:03:30 <boegel> earthy, aligning more than 1 part works fine with me
07:03:38 <earthy> \end{alignat}
07:04:26 <kosmikus> boegel: ask
07:04:34 <boegel> kosmikus: see above :)
07:04:37 <kosmikus> ok
07:04:39 <kosmikus> too slow
07:04:55 * ski ponders ... rigth .. right .. rithg ...
07:05:47 <kosmikus> looks like you should use the good old array environment
07:06:57 * earthy nods
07:07:08 <earthy> that'd give you exactly the control you want
07:07:12 <kosmikus> at least if none of the align/aligned/alignat/whatever environments do what you want
07:07:14 <boegel> okay, let's try alignat
07:07:16 <kosmikus> they're not very flexible
07:10:39 * boegel sighs
07:11:00 <earthy> what? :P
07:11:47 <boegel> neither align, alignat or aligned works how I want it to work
07:13:01 <earthy> well, array it is then. ;)
07:13:14 <boegel> I have some like : left & = & <expl> right
07:13:33 <boegel> and the right part is always aligned to the right :s
07:17:50 <nlv11757_> pfff never thought making a nice Makefile that generates all your documentation nicely separated using lhs2tex, rubber, etc would take up so much time
07:29:40 <kosmikus> kolmodin: why haven't you submitted the haste ebuild to Gentoo?
07:52:07 <nlv11757_> kosmikus, what would you consider better style; calling lhs2tex on separate files and using latex input/include commands, or in the main file use lhs2tex %include and only call lhs2tex on the main file to generate one big tex
07:52:08 <nlv11757_> ?
07:54:04 <nlv11757_> or anyone using lhs2TeX for that matter
07:57:32 <Cale> Whichever way works for you sounds good to me :)
07:59:18 <nlv11757_> ok, i thought maybe there were some style advantages
07:59:58 <Cale> I'm not sure -- having to call lhs2tex only on the main file sounds convenient
08:00:46 <bringert> oh, the impossible happend
08:00:48 <bringert> again
08:13:43 <Oejet> TheHunter: PING
08:14:42 <TheHunter> Oejet, PONG
08:18:01 <Oejet> Did you see the timings I wrote just after you entered?
08:18:50 <TheHunter> yes.
08:19:21 <TheHunter> but i don't know much about how to optimize that sort of thing.
08:19:52 <TheHunter> what are your main cost-centers?
08:21:05 <Oejet> Not very clear.  It seems it's the C calls with some proportional overhead.
08:24:10 <kolmodin> kosmikus: haste requires a patched version of wxhaskell. it shouldn't be any problems if you are willing to add that one too
08:24:24 <TheHunter> it's probably haskell's string representation that's killing your performance.
08:25:10 <kosmikus> nlv11757_: depends. I use both styles, depending on context. lhs2tex on main file is usually more convenient, but if you want to use very different setups of lhs2tex in one document, then running it on included files might be better. The lhs2tex documentation is an example of the latter case.
08:25:26 <kosmikus> kolmodin: what sort of patch?
08:26:22 <nlv11757_> kosmikus, if pieces use different styles you mean?
08:26:30 <kosmikus> yep
08:26:57 <kolmodin> a copy of wxStyledTextCtrl and bindings to it
08:28:07 <kolmodin> with a little luck it will be part of wxhaskell. then we won't need any patches at all
08:28:17 <Oejet> TheHunter: http://hbin.dyndns.org/pastebin/41.html and the profile http://www.student.dtu.dk/~s022018/Temporary/a.out.prof
08:28:22 <kosmikus> but it's not in 0.9.4?
08:28:35 <kolmodin> no
08:29:16 <kosmikus> ok, then maybe we wait for the next release, but please remind me again, or file a bug about it, so I won't forget it
08:29:45 <kolmodin> btw, what stops us from allowing ghc 6.2.2 and ghc 6.4 in gentoo at the same time?
08:29:57 <kolmodin> I mean, in different slots
08:30:48 <kosmikus> it's on our todo list
08:30:58 <kolmodin> ok
08:31:00 <basti_> hi
08:31:15 <kosmikus> the difficulty is that it's then unclear for which version a package should be installed
08:31:33 <kolmodin> mm, that might be a problem
08:31:39 <kosmikus> i.e., it's not entirely trivial to setup, just adding SLOT to ghc is not enough
08:32:29 <kolmodin> haste uses ghc 6.4 so I had to uninstall the old version and all its packages...
08:35:26 <kolmodin> I'll fix new ebuilds to haste and patched-wxhaskell within a few days (I hope)
08:38:29 <TheHunter> Oejet, have you tried a larger buffer_length?
08:43:59 <Oejet> Yes, 1024^2, 1024, 512, 256 and 64.  128 is the fastest.
08:46:27 <kolmodin> kosmikus: the ebuild for HaXml doesn't work with GHC 6.4. don't know if it's the ebuild or if we need to use (yet to be released) HaXml 1.12.2 from the cvs
08:47:22 <kolmodin> kosmikus: tried this: "emerge haxml; ghci -package HaXml; :m Text.XML.HaXml"
08:48:01 <kolmodin> kosmikus: it yields "Could not find module `Text.XML.HaXml': it is not a module in the current program, or in any known package."
08:48:05 <kolmodin> brb
08:48:58 <Lemmih> kolmodin: GHC 6.4 is not backwards compatible w.r.t packages.
08:49:26 <wagle> oh really..  so it should have been 7.0?
08:52:25 <nlv11757_> later
08:54:32 <Lemmih> Greetings, mighty GHC hacker!
08:54:44 * JaffaCake bows
08:55:21 <Oejet> Привет, ТФК.
08:55:23 <kosmikus> kolmodin: it's a bug, it should work
08:56:24 <TFK> Oejet, добрый вечер
08:56:51 * JaffaCake twiddles thumbs waiting for libraries to build
08:56:55 <Oejet> TFK: Good evening to you too.
08:57:03 <TFK>  :-)
09:01:41 <Oejet> If withArray is used inside a loop is the allocated array reused over iterations?
09:20:12 <hyperion> rehi :]
09:22:05 <kosmikus> kolmodin: (hopefully) fixed in CVS
09:22:25 <skew> Oejet: I would guess that it probably isn't, but it might get optimized
09:22:33 <skew> reading Core is fun, right?
09:29:23 <Philippa> would be nice to have some kind of tool for helping analyse flows and stuff within Core code
09:29:44 <Philippa> enough to find out "did this get inlined?" "did this get specialised?" "is this running the way I think it is/should be?"
09:30:37 <skew> It sounds like you really want something for matching core up to the original code, or maybe following an expression through the compiler
09:30:48 <skew> at least for the first two
09:31:31 <basti_> oh did i mention i did backtracking in haskell yesterday?
09:31:52 <skew> that's fun. []?
09:32:00 <basti_> yes in the list monad
09:32:21 <basti_> very intuitive. besides the notation.
09:32:29 <Philippa> skew: yup
09:33:12 <skew> Actually, I think the notation is pretty nice, except for being associated with lists
09:33:36 <skew> I mean, there's nothing particularly bad about the notions, it's just that everybody is used to using it for lists
09:33:45 <basti_> uh?
09:33:55 <basti_> i used the do notiation
09:34:35 <skew> Did you use the [a,b,c] notation to specify explicit choices?
09:34:45 <skew> I'
09:34:51 <basti_> only to input them
09:35:24 <basti_> the backtracking algorithm was written in "do"
09:35:31 <basti_> not as "concat map"
09:35:35 <skew> I think I've completely adjusted to thinking of do as computation under arbitrary semantics, so getting nondeterminism out of it doesn't bother me much any more
09:36:18 <basti_> hmm.
09:36:24 <mr-onionhead> Hi, i'm looking at typeclass with the definition "class (Monad m, Monad b) => BaseM m b | m -> b where ..."  What does the pipe mean?
09:36:27 * boegel leaves to please his gf
09:36:44 <skew> that's called a functional dependency
09:36:45 <basti_> mr-onionhead: thats a fundep notation iirc.
09:36:49 <kolmodin> kosmikus: you get a copy of mails to haskell@gentoo.org, right?
09:36:59 <skew> I don't know where the "functional" part in the name comes from
09:37:07 <basti_> it'd say "what b is depends, depends on m"
09:37:12 <basti_> uh
09:37:15 <kolmodin> just submitted the HaXml bug.
09:38:11 <skew> But the arrow means that if you have an instance for BaseM m b and you know type m that uniquely determines type b
09:38:31 <skew> the | separates the dependencies foom the instance head bit
09:39:19 <boegel> kolmodin: is HaXml hard to work with if you're familiar with it ?
09:39:36 <mr-onionhead> ah! is this a "functional dependancy" then?
09:39:41 <ski> yes
09:39:41 <basti_> yes.
09:39:42 <boegel> I'll have to drop my own parser and create a xml parser thingie (usign HaXml)
09:40:01 <skew> boegel: Is this for your ray tracer?
09:40:11 <mr-onionhead> (opps)
09:40:14 <boegel> skew: yes
09:40:32 <boegel> skew: I wrote my own little parser using Happy, but it kinda sux
09:40:35 <mr-onionhead> skew: do can you recommend a link on them>
09:40:54 <boegel> if you place a space in the wrong place, my tracer crashes upon parsing
09:41:04 <boegel> and my professor suggested to use xml
09:41:14 <kosmikus> kolmodin: yes, why?
09:41:17 <boegel> I hope I won't have to much problems
09:41:30 <boegel> s/to/too
09:41:30 <skew> nvl##### had some problems with memory consumption on XML files a few megabytes in size. I haven't heard whether the problems have been sorted out, and if it was some leak in his code
09:41:44 * SamB thinks Knuth could have done a better job on the MMU for MMIX
09:41:50 <skew> boegel: I've heard that if you have a problem and try to solve it with xml you then have two problems
09:41:51 <kolmodin> kosmikus: just posted the buggy HaXml ebuild to the buglist
09:42:06 <kosmikus> kolmodin: er, didn't I just tell you I fixed it?
09:42:11 <boegel> skew: why ?
09:42:14 <skew> Specifically, you'll have to think about how people are going to create scene definition files if you go for XML input
09:42:18 <kolmodin> ehh... hmmmm.
09:42:31 <kolmodin> ah, ops. sorry :)
09:42:32 <jlouis> SamB: heh, why?
09:42:39 <kosmikus> kolmodin: never mind, just verify whether it's really working now
09:42:42 <boegel> skew: just by creating an xml file and checking that with a Schema or DTD or so?
09:42:46 <kosmikus> kolmodin: if it is, close the bug :)
09:42:57 <skew> There are probably cool tools I don't know about, but writing XML with a text editor really sucks
09:43:22 <Lemmih> Hey SyntaxNinja.
09:43:27 <skew> It's the "creating an XML file" that can be painful...
09:43:36 <boegel> skew: now they have to create a text-file which conforms my syntax, and that's a lot harder than creating a good xml file
09:43:37 <tromp> is it possible to compile a module not called Main.hs into an executable?
09:43:57 <boegel> tromp: using ghc ?
09:43:58 <kolmodin> I would like irssi to highlight lines with my name in it.. anyone who knows how to do it?
09:44:02 <tromp> yes, with ghc
09:44:07 <boegel> tromp: why not ?
09:44:23 <kolmodin> using irssi throuh a screen (if that makes any difference)
09:44:24 * boegel is probably missing something
09:44:33 <tromp> when i called it something other than Main it didn't produce an a.out
09:44:43 <boegel> tromp: bull !
09:44:46 <kosmikus> kolmodin: my irssi through screen does that automatically
09:44:56 <mauke> try /set hilight_nick_matches on
09:44:59 <boegel> tromp: ghc --make Bleh.hs -o program
09:45:02 <boegel> for example
09:45:22 <skew> mr-onionhead: There's a section (7.4.7) in the GHC user's guide on them, that doesn't actually provide any documentation, but does link to a paper
09:45:35 <boegel> that should produce an executable file 'program'
09:45:47 <mr-onionhead> skew: thanks, that'll be a good start:)
09:45:50 <kosmikus> JaffaCake: if I read it correctly, you didn't tell me what I should do with the "redesigned IO library" entry ... any suggestions?
09:46:00 * boegel really leaves now
09:46:06 <skew> boegel: if your current input format is hard to write XML might be better. I'm just saying that in my experience XML is pretty verbose to be writing by hand, and pretty hard to read too
09:46:06 <kolmodin> kosmikus: strange. the screen is running against chalmers so i'm sure its old version of all programs :)
09:46:37 <tromp> ok, so the module must be called Main but the file needn't be called Main.hs
09:46:37 <boegel> skew: my input is quite simple, so I think XML might be a good option, I'll see when I get to that
09:46:51 <mr-onionhead> \q goes back to work
09:46:57 <SyntaxNinja> 'morning
09:47:11 <boegel> tromp: neither should the module
09:47:27 <boegel> my main module is called HRayMain, and that works fine
09:47:45 <boegel> it does have a main function though, maybe that's why :)
09:47:59 <SyntaxNinja> there's a main-is flag in ghc 6.2 and greater
09:48:09 <SyntaxNinja> which should probably be in cabal somewhere ahem, but isn't
09:49:29 <tromp> i got: Warning: output was redirected with -o, but no output will be generated
09:49:29 <tromp> because there is no Main module.
09:50:00 <tromp> when doing ghc --make Games.hs -o b.out
09:50:04 <SyntaxNinja> tromp: either rename your module to be Main, or use main-is
09:50:19 <SyntaxNinja> like ghc --make -main-is Games.main -o b.out
09:50:29 <tromp> ok, thx
09:50:32 <SyntaxNinja> or maybe  ghc --make -main-is Games.main Games.hs -o b.out
10:09:23 <SamB> hmm, how should I implement the MMIX physical memory...
10:18:12 <Igloo> bar foo
10:18:19 <Igloo> Ooops
10:18:55 <xerox> baz quux
10:27:19 <kolmodin_> ah! that's better. irssi with colors and highlights and stuff
10:46:25 <pesco> Moin.
10:46:37 <Lemmih> Moinmoin.
10:46:46 <Oejet> pesco: Guten Abend.
10:55:02 <stepcut> I can never figure  out how to get HaXml to do what I really want
10:56:13 <integral> @pointless \p -> f p || g p
10:56:13 <lambdabot> liftM2 (||) f g
10:56:37 <pesco> Lemmih, Oejet: What's up?
10:57:11 <Lemmih> Paying Haskell work! (:
10:58:20 <Heffalump> oh, stepcut. You're responsible for NewBinary in some way, right?
10:58:48 <Lemmih> And Hackage/cabal-get/cabal-put for fun.
10:59:00 <skew> what are you doing?
10:59:59 <Lemmih> me?
11:00:12 <skew> You said paying Haskell work
11:01:19 <Lemmih> Drone work for a friend.
11:01:30 <skew> Drone work?
11:02:02 <Lemmih> GUI for a crm system.
11:02:07 <pesco> Lemmih: What's the latest news from the cabal-get front?!
11:03:00 <pesco> I'll have a new version of pesco-cmdline to release in less than five minutes!
11:03:01 <pesco> :)
11:03:24 <Lemmih> pesco: It'll be ready for serious use once we iron out the security issues.
11:03:56 <Lemmih> pesco: How does it compare to System.Console.GetOpt?
11:08:53 <pesco> Lemmih: Have a look at the "Motivation" section of http://scannedinavian.org/~pesco/distfiles/pesco-cmdline-2.0.pdf .
11:10:44 <pesco> Lemmih: What are you planning to do for security, currently?
11:20:36 <Lemmih> Requiring users to sign their packages.
11:21:00 <musasabi> Has anyone played around with parsers and arrows? The arrow-class methods (like &&& and ***) don't seem to make much sense in in parsers...
11:27:35 <dcoutts_> does anyone have a suggestion as to how I install ghc on windows when I'm not allowed to install .msi packages. Is there a .zip verision of ghc anywhere or does anyone know of a tool for extracting the contents of .msi files?
11:28:14 <pesco> Lemmih: What about dependencies? Can I put PGP key fingerprints in the description file?
11:29:42 <Lemmih> pesco: Dependencies must be located on a Hackage server and are thereby secure.
11:30:16 <pesco> Are they?
11:30:55 <Lemmih> Yes. Hackage only accepts signed packages.
11:31:55 <pesco> And there are only official Hackage servers?
11:32:21 <Lemmih> No, everyone can setup their own Hackage server.
11:33:13 <Lemmih> You can for example use a local Hackage server as primary and an official as secondary.
11:33:35 <pesco> And the assumption is that bogus hackage servers are not a problem?
11:34:00 <hyperion> becuase packages are signed
11:34:44 <Lemmih> pesco: You shouldn't be downloading packages from a Hackage server you don't trust.
11:34:50 <pesco> The signatures are completely meaningless to me as long as I don't know which one I need.
11:35:53 <pesco> Lemmih: So I must require the server to identify itself to me.
11:36:06 <Lemmih> Huh?
11:37:07 <pesco> I must trust DNS to return the correct IP of the server and the Net to route that IP to the correct machine.
11:37:17 <pesco> Or ask the machine for proof of its identity.
11:37:23 <Lemmih> Read the mail from SyntaxNinja to libraries@.
11:37:30 <pesco> OK.
11:44:17 <SamB> hmm, I want to write an MMIX simulator, but I don't know what data structure to put the memory in...
11:44:42 <skew> SamB: why not Data.Map?
11:45:16 <SamB> I guess that would work
11:45:21 <reffie> skew just use knuth's!
11:45:21 <skew> are you planning on running MMIX programs with huge performance requirements?
11:45:33 <SamB> no
11:45:34 <reffie> i mean SamB
11:45:50 <dcoutts_> SamB, or if you want something quicker, one of the unboxed array types (unless you memory address space is sparse)
11:45:54 <SamB> reffie: knuth's doesn't really implement kernel-space
11:46:27 <SamB> I'm going to use STUArray or IOUArray for individual pages
11:46:29 <skew> I'm not sure if lazy evaluation is quite enough to implement an interpreter where the internals rely on interpreted code
11:47:07 <SamB> (not MMU pages, those are of variable size)
11:47:49 <SamB> skew: oh, this will be thouroughly imperative.
11:48:31 <skew> I was talking about reffie's suggestion to use knuth's map, which is presumably presented in MMIX code
11:50:05 <SamB> skew: Knuth's real implementation is in CWEB
11:50:42 <SamB> he uses something called a treap
11:54:41 <SamB> is there a nice way to spell \n -> (0, 2^n-1) ?
11:55:17 <skew> That's probably about as nice as it gets
11:55:31 <skew> @pl \n -> (0, 2^n-1)
11:55:32 <lambdabot> (,) 0 . subtract 1 . (2 ^)
11:55:50 <SamB> thats horrid
11:56:04 <SamB> @type (^)
11:56:10 <lambdabot> (^) :: forall a b. (Integral b, Num a) => a -> b -> a
11:56:58 <SamB> @type log
11:56:59 <lambdabot> log :: forall a. (Floating a) => a -> a
11:57:01 <mflux> @pl -1+2^n
11:57:02 <lambdabot> (line 1, column 1):
11:57:02 <lambdabot> unexpected "-"
11:57:02 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
11:57:02 <lambdabot> expression
11:57:14 <mflux> @pl 0-1+2^n
11:57:15 <lambdabot> -1 + 2 ^ n
11:57:21 <SamB> heh, it doesn't support - as negation
11:57:22 <mflux> hmh, obviously I meant..
11:57:25 <mflux> @pl \n -> 0-1+2^n
11:57:26 <lambdabot> (-1 +) . (2 ^)
11:58:21 <SamB> well, seing as n is actually a constant...
11:58:48 <SamB> I guess I'll just use (0, 511)
11:59:10 <pediddle> @plugs (-1 +) . (2 ^) $ 5
11:59:18 <lambdabot> 31
11:59:36 <pediddle> wouldn't have thought (-1 +) would be unambiguous syntax
11:59:59 <skew> - is kind of wierd in operator slices anyway
12:00:04 <mflux> @pl \n -> (0, -1+2^n)
12:00:05 <lambdabot> (line 1, column 9):
12:00:05 <lambdabot> unexpected ","
12:00:05 <lambdabot> expecting digit, variable, "(", operator or ")"
12:00:10 <mflux> argh, I did it again
12:00:13 <mflux> @pl \n -> (0, 0-1+2^n)
12:00:14 <lambdabot> (,) 0 . (-1 +) . (2 ^)
12:00:38 <SamB>  @pl has a parser?
12:00:43 <mflux> it should be able to do such simple conversions, the earlier version was worse ;)
12:01:04 <pediddle> @moo
12:01:05 <lambdabot>          (__)
12:01:05 <lambdabot>          (oo)
12:01:05 <lambdabot>   /-------\/-*
12:01:05 <lambdabot>  / |     || \
12:01:05 <lambdabot> *  ||----||  *
12:01:06 <lambdabot> \/|(/)(/\/(,,/
12:01:07 <lambdabot>   Cow munching
12:01:09 <lambdabot>     on grass
12:01:11 <pediddle> @moo
12:01:12 <lambdabot>          (__)
12:01:13 <lambdabot>          (oo)
12:01:15 <lambdabot>   /-------\/
12:01:18 <lambdabot>  )*)(\/* /  *
12:01:19 <lambdabot> \ |||/)|/()(
12:01:21 <lambdabot> \)|(/\/|)(/\
12:01:23 <lambdabot> Grass munching
12:01:25 <lambdabot>     on cow
12:01:37 <qmole> !
12:01:41 <Heffalump> :-)
12:02:19 <pediddle> that makes me happy
12:03:13 <SamB> hmm, what should I use for the elements of the little arrays... the indices, too, for that matter...
12:04:38 <SamB> should I use Int64, Word64, or Word32...
12:05:48 <SamB> (for the elements)
12:08:58 <pediddle> is MMIX 64-bit?
12:09:27 <SamB> yes
12:09:42 <SamB> but my computer is not
12:10:50 <SamB> Oh well, I'll use Word32 for now. I can change it later, if I don't scatter knowledge of the array type everywhere.
12:11:07 <pediddle> even if you do, would be a simple search-and-replace-and-recompile
12:11:55 <SamB> if I did, I would have to modify nearly every place that depended on the type by hand, I think
12:14:34 <SamB> hmm, how to thread access to memory, registers, etc through the program...
12:14:35 <dcoutts_> just in case anyone wanted to know, you can extract the contents of .msi files without admin privilidges (and thus install ghc on machines where you are not admin) by using MsiEx 0.2 which you can download from a really dodgy looking Russian "warez" site. :-)
12:14:57 <skew> SamB: sounds like you need a monad
12:15:15 <skew> you have never written a monadic interpreter before?
12:15:28 <SamB> skew: not really
12:15:45 <SamB> I mean, not to my knowledge, and it wouldn't have been very big anyway.
12:15:54 <skew> have you read Wadler's "The Essence of Functional Programming"?
12:16:22 <SamB> what is the usual filename for that?
12:17:02 <SamB> never mind, I found it
12:18:15 <SamB> now how to read it without a laser printer...
12:18:16 <skew> If I've got the right title, it should be a paper on monads that uses an interpreter as the running example
12:18:38 <skew> xpdf or gv should work
12:18:51 <SamB> skew: in a technical sense, yes.
12:18:58 <SamB> in a practical sense, not very well.
12:19:42 <SamB> like, you could build an entire bussiness model around getting people stuff on paper...
12:35:06 * boegel bounces
12:35:51 * araujo giggles
12:36:33 * basti_ goes boom
12:37:35 <RemiTurk> hi boombasti_
12:37:42 <RemiTurk> and hi to everyone else
12:37:44 <basti_> hey remiturk
12:38:23 <boegel> hi RemiTurk
12:39:37 <basti_> why do i always think about semiturk when i read your nick
12:39:43 <RemiTurk> lol
12:40:10 <RemiTurk> I'd need to do some quite serious brain-surgery to be able to tell you :P
12:40:22 <basti_> heh
12:40:27 <RemiTurk> (though you most certainly wouldn't survive to listen to the wrong answer I'd give you afterwards)
12:40:44 <RemiTurk> I actually wanted to use Remi as a nick, but it was already taken IIRC
12:40:49 <basti_> oh
12:42:03 <RemiTurk> @seen RemiTurk
12:42:03 <lambdabot> You are in #haskell. Last spoke just now.
12:42:23 <RemiTurk> is there a command to find out (without digging my logs up) when I was here last?
12:44:03 <basti_> apparently not.
12:47:55 <SamB> @pl \x e -> return $ fromMaybe Wrong $ lookup x e
12:47:56 <lambdabot> ((return . fromMaybe Wrong) .) . lookup
12:48:46 <basti_> what uses does pointless have beyond obfuscation?
12:48:50 <SamB> ironic that making a piece of code pointless adds so many dots to it...
12:49:08 <basti_> are lambdas out of fashion?
12:49:28 <pediddle> SamB, where'd you find wadler's document?
12:51:01 <monochrom> http://groups.google.ca/group/comp.lang.functional/msg/03b0d81c68c8e72c?hl=en
12:51:50 <SamB> pediddle: in my homedir
12:52:00 <pediddle> :)
12:52:02 <SamB> it looks like I downloaded it from citeseear
12:52:15 <SamB> only spelled correctly
12:52:52 <pediddle> let's see if the UW pays their subscription fees...
12:53:35 <SamB> is it on ACM's horrid site?
12:53:57 <pediddle> oh, i guess it's free
12:53:58 <pediddle> http://citeseer.ist.psu.edu/wadler92essence.html
12:54:05 * theorbtwo wonders if there's a standardish haskell library for charsets.
12:54:12 <pediddle> complete with horrid bitmap fonts
12:54:36 <SamB> pediddle: which version did you download?
12:55:01 <SamB> and what were you expecting, vector fonts?
12:55:21 <Heffalump> theorbtwo: if you find one, let me know :-)
12:55:33 <pediddle> just something that's readable on my screen :)
12:55:35 <SamB> METAFONT fonts don't really translate into cubic or quadratic bezier splines... they have a higher degree, or something like that...
12:55:55 <pediddle> all i know is when I write a paper in Latex, it looks nice
12:56:11 <SamB> pediddle: maybe you downloaded the PDF version?
12:56:23 <pediddle> i did, but PS version sucks too
12:56:49 <SamB> and you are using gv?
12:57:11 <pediddle> Mac OS X Preview
12:57:16 <pediddle> I'll try gv
12:57:35 <pediddle> no biggie
12:57:46 <SamB> hmm, I would think it would look nice on OS X...
12:58:04 <pediddle> most documents do, but it seems all the "old" papers i download look bad
12:58:22 <pediddle> like i said, i think it's the bitmap fonts, and since OS X antialiases them they get all blurry
12:58:32 <SamB> anyhow, I guess you probably meant as opposed to nice bitmap fonts?
12:58:55 <pediddle> probably
12:59:31 <pediddle> if i zoom in to 300% the (blurry) pixels are clearly visible
13:00:41 <Maddas> Yeah, some PDFs look very ugly :-)
13:01:28 <SamB> maybe it is OS X, then. It sounds like it uses a stupid algorithm for antialiasing bitmap fonts...
13:01:55 <SamB> my copy claims to have 300 dpi fonts
13:02:05 <monochrom> some programs make very bad pdfs.  maybe they can be configured to be better, but the default configuration (and very obscure to change it) is bad.  ps2pdf is the most prominent one.
13:02:25 <monochrom> may the birth date of the author of ps2pdf be cursed.
13:03:06 <pediddle> i don't think it's OS X's fault, the bitmaps are so coarse there's nothing it can do
13:03:20 <pediddle> :)
13:03:31 <monochrom> ps2pdf will include font in the pdf file, and the font included is bad.
13:03:33 <SamB> okay, then, I guess citeseer is doing something nasty to both the PS and the PDF...
13:03:44 <monochrom> yeah citeseer uses ps2pdf
13:03:52 <monochrom> may the birth date of the author of ps2pdf be cursed.
13:04:40 <pediddle> i bet OS X uses ps2pdf when it converts from PS too
13:04:43 <monochrom> perhaps citeseer does a fixpoint of ps2pdf | pdf2ps | ...  :)
13:05:14 <SamB> wouldn't it be more productive to get ps2pdf unbundled from tetex?
13:05:30 <monochrom> I don't think it is bundled.
13:05:33 <SamB> rather than placing curses upon the birth date of the author?
13:05:45 <SamB> monochrom: what package is it in so I can uninstall it, then?
13:05:55 <monochrom> ghostscript
13:06:04 <SamB> oh, right.
13:06:12 <SamB> then unbundled from ghostscript...
13:06:44 * SamB has obviously forgotten that other programs can produce postscript output besides dvips
13:07:25 <Maddas> I don't know whether it's Preview's fault (I thought I had observed the same problems in other applications already, but I'm not sure about that), but it works using gv.
13:07:32 <Maddas> (I have gv installed for just those pdfs :-)
13:08:10 <SamB> wait, are we talking about the postscript or the pdf for these old papers?
13:08:29 <SamB> does preview support postscript?
13:08:35 <monochrom> May Adobe be cursed. :D
13:08:47 <SamB> monochrom: but postscript is nice
13:09:23 <monochrom> I am not sure it is nice when you can use it to do ray tracing. :D
13:09:39 <SamB> but you can also do escher tilings!
13:10:24 <wagle> printed on strips of moebius paper?
13:10:43 <SamB> and, well, I don't think I want to ever write a program that outputs PDF
13:10:46 <wagle> mmm..  ray tracing on escher tilings...
13:10:46 <Maddas> SamB: preview converts to PDF
13:10:56 <SamB> wagle: they tend to get caught in the printer
13:11:10 <SamB> Maddas: ah
13:11:14 <Maddas> SamB: But I've downloaded PDF files showing exactly the same behaviour, so it's not just Preview's converter that's broken
13:11:34 <monochrom> "Preview" may be isomorphic to ps2pdf
13:11:55 <pesco> !showinfo Enterprise
13:11:56 <Maddas> Indeed, I don't know.
13:12:00 <pesco> arrrgh
13:12:17 * pesco goes back to #bt.
13:12:20 <monochrom> by isomorphic I mean bisimular.  Now that can be proved. :)
13:15:31 <monochrom> Theorem: Preview and ps2pdf are bisimular.  Proof: display one of Andrew Gordon's bisimularity and co-induction tutorials with Preview and ps2pdf side by side, see that they're the same, and use co-induction.
13:16:05 <monochrom> err, s/see that they're the same/see that they look the same/   # very important!
13:17:34 <glimming> I hereby invite you Haskellers to check particularly the slides on monads http://www.nada.kth.se/kurser/kth/2D1456/, and the appendix to homework 4 on distributive laws and monads.
13:17:46 <glimming> I welcome all feedback, and if it is substantial I will give credit.
13:18:04 <monochrom> I looked at the pdf spec.  I think it is not too nasty to write a few combinators for producing pdf.
13:19:04 <monochrom> It is mucho nasty to do in C, of course!
13:19:23 <monochrom> Even in Perl it's intolerable.
13:19:36 <monochrom> Haskell = universal beautifier.
13:22:30 <SamB> I wish wadler had used the Monad class...
13:25:40 <ski> glimming : hi
13:26:04 <glimming> hi ski
13:26:07 <glimming> nice to hear from you
13:26:20 <glimming> mail me, remember!
13:26:24 <glimming> glimming AT kth.se
13:26:42 <glimming> Have a look at what the result for distribitutivity became...
13:26:46 <glimming> on the above mentioned page
13:26:50 <glimming> (for ski)
13:27:07 <ski> which page ?
13:29:21 <ski> glimming : i reconstructed the diagram from mem today, but haven't come much further yet ..
13:30:45 <FrederikEaton> cabal doesn't let me specify an --exec-prefix ?!
13:32:38 <SamB> hmm, how to replace showM...
13:34:00 <FrederikEaton> glimming: how did you generate the page?
13:38:10 <FrederikEaton> glimming: anyway, i'm too tired to read it in detail. but last week i was dealing with that stuff a lot, composition via swap
13:38:50 <FrederikEaton> i read it in Jones et al, Composing Monads
13:38:57 <FrederikEaton> MP Jones that is
13:41:14 <SamB> agg, this showM stuff is a mess if you use typeclasses...
13:43:40 <faiv> what is closure operatior?
13:46:02 <SamB> hmm, this does not look good. after getting something with no type errors which seemed reasonable, I did:
13:46:08 <SamB> *Figure1> test term0 >>= print
13:46:08 <SamB> "<wrong>"
13:47:37 <monochrom> assume a partial order "<=".  f is a closure operator iff (forall x,y. x <= f y iff f x <= f y)
13:48:51 <faiv> aha
13:51:43 <SyntaxNinja> y0
13:51:48 <Lemmih> Hey
13:51:58 <Lemmih> No mouse?
13:52:01 <SyntaxNinja> hi Lemmih
13:52:03 <tromp> i'd call such an f monotone
13:52:35 <tromp> you mean fx <= f y iff x <= y ?
13:52:38 <SyntaxNinja> oh... it ran out of battery. i was pretty confused at first.
13:52:52 <Lemmih> (:
13:54:59 * boegel can't get his gf to go to bed
13:55:41 <monochrom> No.  I mean what I write, and I write what I mean.
13:56:09 <faiv> it should be some thing like  f.fx < fx
13:59:13 <monochrom> The traditional formulation is more clumsy and intuitive.  (You see a correlation?)  (forall x. x<=y implies fx<=fy) "monotonic", (forall x. x<=fx) "increasing", (forall x. fx=ffx) "idempotent".
13:59:40 <monochrom> The two formulations are equivalent.  I don't care about tradition and intuition.
14:00:08 <faiv> I see it now
14:01:52 <faiv> so perhaps this is the best way to understand what monads are
14:02:01 <glimming> I kid
14:02:05 <glimming> Ooops.
14:02:10 <glimming> Hi Kid. I mean
14:03:16 <monochrom> I learned the elegant formulation from a Roland Backhouse paper.
14:03:44 <faiv> I have to check that
14:03:45 <glimming> FrederikEaton, there seems to be many n otions of compositino around. What sort of composition is it in that Jones' paper.
14:03:54 <glimming> Which paper, monochrom?
14:04:23 <faiv> in the mean time what does it mean to compose to closure operator, if at all
14:05:52 <monochrom> "Galois connections and fixed point calculus", that is Chapter 4 in LNCS 2297.
14:06:17 <monochrom> do you know what is meant by composing two functions?
14:06:26 <faiv> I think so
14:06:52 <monochrom> a closure operator is a function too.  same composition.
14:07:04 <FrederikEaton> glimming: uh, the kind that you were talking about, i thought. where you have an operation n (m a) -> m (n a)
14:07:06 <faiv> so it always compose
14:07:34 <glimming> FrederikEaton, but there are also monad transformers as a means for composing monads
14:07:38 <glimming> Are they related?
14:08:38 <FrederikEaton> glimming: these are stronger
14:08:46 * jlouis should pick up a NetBSD port of ghc again
14:09:07 <glimming> Yes, so not all monads compose using dist-approach, e.g. state monads ST1 and ST2 --- can you give me a dist?
14:09:16 <FrederikEaton> glimming: ... he calls the operation 'swap'. and it lets you define a monad which is equivalent to m (n a)
14:09:39 <FrederikEaton> read the paper, he gives three different routes to composability
14:09:52 <faiv> FrederikEaton:  Does swap always exists?
14:10:05 <FrederikEaton> no!
14:10:22 <faiv> OK
14:10:28 <FrederikEaton> he has a proof at the end that not all monads are composable
14:10:50 <FrederikEaton> i should be saying "they"
14:11:48 <FrederikEaton> they have:
14:11:49 <FrederikEaton> class (Monad m, Monad n) => SComposable m n where
14:11:50 <FrederikEaton>     swap :: n (m a) -> m (n a)
14:12:16 <FrederikEaton> instance (SComposable m n) => Monad (SComp m n) where ...
14:12:26 <FrederikEaton> data SComp f g x = SC (f (g x))
14:12:44 <FrederikEaton> i used it for my parsing library. there is a:
14:12:46 <FrederikEaton> instance Monad m => (SComposable m [])
14:12:49 <ski> FrederikEaton : not "newtype" ?
14:13:15 <FrederikEaton> ski: whatever
14:13:24 <glimming> I will read it.
14:13:35 <faiv> glim: good idea
14:13:44 <FrederikEaton> instance Monad m => (SComposable m Maybe)
14:13:49 <glimming> faiv, deja vu
14:14:01 <glimming> vis-a-vis
14:14:09 <glimming> haphazard
14:14:19 <FrederikEaton> instance Monad m => (SComposable m (Either e))
14:14:41 <FrederikEaton> but you don't have for instance (SComposable [] m)...
14:24:27 <SamB> hmm, did I mention that I wanted to use mutable arrays for chunks of MMIX memory?
14:30:30 <FrederikEaton> i made a cabal package: http://ofb.net/~frederik/pencilpond-0.1.tar.gz
14:30:34 <FrederikEaton> it was pretty easy
14:31:11 <FrederikEaton> people should install it
14:31:20 <SamB> Okay, I've at least skimmed the paper...
14:31:22 <Lemmih> Upload it to a Hackage server (:
14:32:55 <FrederikEaton> is there an automatic way to install packages like that? there is 'toast' for autoconf
14:33:23 <FrederikEaton> very convenient, lets you install and uninstall easily, creats a symlink farm in ~/.toast
14:33:32 <Lemmih> There's cabal-get.
14:34:10 <FrederikEaton> oh that's you
14:34:25 <Heffalump> FrederikEaton: what's it do?
14:34:58 <FrederikEaton> Heffalump: it shows you pretty pictures. run it!
14:35:20 <FrederikEaton> there are no subliminal messages in the pictures
14:35:26 * MachinShin having dinner here : http://fireofbrazil.com/  tonight. paid for by the client :P 
14:36:09 <FrederikEaton> Lemmih: so, cabal-get... maturity? how automatic is it?
14:36:26 <FrederikEaton> do i have to be root to run it?
14:37:01 <Lemmih> Nope. You can install packages locally.
14:51:48 <kosmikus> Lemmih: SyntaxNinja mentions you by your nick in his HCAR entry. Is that your preferred name, or should I replace that with a real name of yours?
14:52:59 <Lemmih> Yes, I prefer Lemmih.
14:53:18 <kosmikus> ok
14:59:55 * RemiTurk leaves to watch THHGTTG 2/6 on bbc2 before going to bed
15:03:10 <FrederikEaton> Lemmih: should i get head or stable? can i specify packages by URL?
15:04:39 <SyntaxNinja> Lemmih: I think you should start going by your real name personally. especially if you want to get professionally established.
15:05:28 <SyntaxNinja> FrederikEaton: it's beta quality
15:06:08 <Lemmih> FrederikEaton: Stable. And no, all package urls are managed by the Hackage server.
15:06:11 <SamB> @docs Data.Array.MArray
15:06:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.MArray.html
15:07:23 <FrederikEaton> Lemmih: why require centralization?
15:07:33 <SyntaxNinja> Lemmih: stable is a bit exadurated :)
15:08:01 <SyntaxNinja> i  just answered that questiomn on the libraries mailing list
15:08:35 <SyntaxNinja> frederik: http://www.haskell.org//pipermail/libraries/2005-May/003773.html
15:08:40 <Lemmih> FrederikEaton: To keep track of dependencies.
15:09:22 <Lenny1729> Does haskell have a kind of marshal-pickle-serialize module?
15:09:38 <SyntaxNinja> we can maybe relax that eventually later though
15:10:40 <FrederikEaton> Lemmih: why not depend on things by URL? also, what if my package is not depended on by anything? a lot of useful packages are "leaves"
15:12:29 <Lemmih> Putting everything on one server is less error-prone.
15:12:44 <Lemmih> But hey, feel free to mail patches (:
15:13:29 <SyntaxNinja> lemmih: it's practically
15:13:32 <SyntaxNinja> er
15:13:33 <FrederikEaton> toast is neat because it uses either URLs or the freshmeat.net database. it may have other fallbacks too.
15:13:40 <SyntaxNinja> practically
15:13:51 <SyntaxNinja> sorry new keyboard
15:13:55 <FrederikEaton> but of course freshmeat.net just serves to alias package names to URLs
15:14:38 <SyntaxNinja> practically already does this. all the URLs are there. its just a policy decision
15:14:57 <FrederikEaton> huh.
15:15:22 <SyntaxNinja> FrederikEaton: we're making the concervative choice for now. may change it later.
15:15:54 <FrederikEaton> so, i'm reading the libraries post. i don't understand webs of trust. like, if a key is compromised, how do you revoke your trusting of it?
15:17:36 <SyntaxNinja> the end user doesn't operate on the web, hackage does
15:17:49 <Lemmih> kosmikus: My real name is David Himmelstrup. You can use that instead of Lemmih.
15:18:17 <kosmikus> Lemmih: I'll use what you prefer.
15:18:28 <SyntaxNinja> and if a key is compromised, it gets removed from the hackage keyring
15:18:42 <SyntaxNinja> but well probably do it by hand.
15:19:23 <stepcut> @pointless (\t -> (fst t, map f $ snd t))
15:19:24 <lambdabot> liftM2 (,) fst (map f . snd)
15:19:32 <stepcut> heh
15:19:56 <Heffalump> oh, stepcut, I wanted to ask you about the license of NewBinary
15:20:05 <stepcut> oh ?
15:20:12 <Heffalump> well, it just says AllRightsReserved
15:20:12 <SamB> @pl \a i -> liftM fromIntegral (readArray a i)
15:20:13 <lambdabot> (fmap fromIntegral .) . readArray
15:20:16 <stepcut> oops
15:20:45 <stepcut> that is probably not correct :)
15:21:48 <Heffalump> secondly, I want it to go into Debian, because it's an indirect dependency for the new version of HTTP; I noticed that you already made a package, but I think it should be renamed haskell-newbinary or something along those lines
15:22:19 <Igloo> I'm not sure the cabal package should
15:22:31 <Igloo> The Debian package probably should
15:22:46 <Heffalump> yes, that's what I meant
15:23:07 <Igloo> Oh, right
15:23:10 <Heffalump> stepcut made a Debian package that calls itself newbinary
15:29:03 <stepcut> Heffalump: ok, I was planning to bring that package up to date this weekend, so I will add those requests to the list
15:30:50 <Heffalump> are you a debian developer, btw?
15:31:21 <stepcut> Heffalump: not officially (not even sponsered)
15:31:53 <Heffalump> right - I'm not either (but planning to start NM soonish)
15:32:07 <SyntaxNinja> i was thinking that we could haave a few folks go through NM together.
15:32:23 <Heffalump> the more the merrier :-)
15:32:54 <stepcut> cool
15:35:49 <Lunar^> SyntaxNinja: I think I would be interested
15:42:06 <SyntaxNinja> stepcut: you?
15:42:31 <SyntaxNinja> can anyone who is interested send me email? i'll try to organize things.
15:42:50 <SyntaxNinja> there's someone else too, probably.
15:42:53 <stepcut> SyntaxNinja: I'll do it
15:45:40 <mwc> Damn you, Haskell. I can't do calculus anymore without seeing glaring nonsensical type errors.
15:46:05 <mwc> F(x,y,z) = foo; r(t) = [P,Q,R]
15:46:14 <mwc> F(r(t)) isn't properly typed, damnit
15:46:49 <SyntaxNinja> damn your nonsensical code!
15:47:21 <mwc> I can't evaluate a function of three complex numbers at a complex 3-vector
15:47:36 <mwc> I wonder if I should flame the author of this text.
15:48:47 <SyntaxNinja> flaming is always the answer.
15:48:57 <skew> math is usually done up to trivial isomorphism
15:50:02 * kosmikus hopes that mwc is not serious
15:50:21 <skew> Frank Atanassow was talking about making a language on the same principles
15:50:36 <mwc> kosmikus: I can read it and translate it to a vector function on the fly
15:50:54 <mwc> but that strikes me as the mathematical equivalent of Engrish
15:51:05 <kosmikus> no, it's convenient
15:51:36 <kosmikus> mathematicians are only able to do the things they're doing nowadays because they take a certain freedom of notation
15:52:00 <kosmikus> if not, the content might become machine-checkable at a certain point, but it would very soon be completely incomprehensible for any human being
15:52:11 <mwc> kosmikus: F(x) = <x_1*x_2, etc> isn't just as legible?
15:52:51 <skew> I think a lot of the notational freedom mwc is talking about has been justified with the development of category theory as natural isomorphism
15:53:31 <kosmikus> possibly, but most mathematicians I know don't care about CT
15:54:07 <kosmikus> mwc: it might be in this case; you gave incomplete examples; but I also thought you were making a general point
15:54:31 <kosmikus> surely, there are many examples of CS and mathematics authors using bad and confusing notation
15:54:44 <mwc> kosmikus: Yeah, but it just bugs the hell out of me... function of three scalars vs. function of a vector
15:54:58 <mwc> i'm just saying that I'm too used to a type system that makes sense
15:54:59 <kosmikus> but demanding that mathematicians write type-correct code in a type system as restricted as Haskell is simply impractical
15:55:16 <mwc> kosmikus: hahaha, you sound like one of them!
15:55:25 <kosmikus> I don't see a problem with that particular example
15:55:40 <kosmikus> well, I am a mathematician
15:55:51 <kosmikus> or at least, I used to be
15:56:05 <mwc> kosmikus: I'm just saying that a vector to me is a completely seperate thing from a triple of scalars.
15:56:36 <mwc> f :: C -> C -> C -> C^3 vs. R :: C -> C^3
15:56:38 <kosmikus> a vector of length 3 is not
15:56:41 <mwc> that's what's bugging me
15:56:50 <mwc> kosmikus: yeah, but I don't see it that way anymore
15:57:21 <mwc> I phrased it poorly, it's not a function of a triple of scalars, it's a function of three seperate scalars
15:57:22 <mwc> that's what's irritating me
15:57:30 <mwc> nevermind, I thought it was humorous
15:58:05 * mwc composes flaming hatemail to author of text.
15:58:50 <kosmikus> "humorous" and "flaming hatemail" seems a bit contradictory to me
15:58:50 <skew> C -> C -> C -> C is equivalent to C^3 -> C, that's what curry (and schoenfinkel) pointed out a long time ago
15:58:52 <tuomov> You don't see f :: C -> C -> C -> ... in maths
15:59:41 <tuomov> It's always uncurried
15:59:59 <kosmikus> yes
16:00:09 <Cale> though I tend to do that now :)
16:00:10 <astrolabe> You might see f:C-> Hom(C,C)
16:00:47 <Cale> (if they really are arbitrary functions, or all obviously morphisms of a particular kind
16:11:33 <kosmikus> JohnMeacham: why are you ignoring all my HCAR requests? could you please say if you're generally not interested, or if you're just so busy that you don't get around to react?
16:21:39 <FrederikEaton> what is HCAR?
16:22:00 <Cale> Haskell Community Activity Report, something like that
16:22:25 <FrederikEaton> are you sending him email?
16:22:39 <FrederikEaton> you can find John Meacham on gale. gale is better than IRC, except for not having enough haskell people
16:23:21 <kosmikus> FrederikEaton: yes, I sent mails
16:23:49 <kosmikus> FrederikEaton: haskell.org/communities, if you want more information
16:24:12 <FrederikEaton> "he's so productive because he ignores you"
16:35:58 <FrederikEaton> john, meet kosmikus. kosmikus, john.
16:38:02 <dons> :}
16:40:23 <FrederikEaton> now they're both ignoring *me*
16:41:33 <kosmikus> we're talking off channel
17:03:32 <vincenz> !seen shapr
17:12:46 <skew> @seen shapr
17:12:47 <lambdabot> I saw shapr leaving #haskell 2 days, 8 hours, 12 minutes and 27
17:12:47 <lambdabot> seconds ago.
17:15:45 <vincenz> wow
17:16:12 <skew> yes, maybe we should send a search party
17:16:17 <dons> @uptime
17:16:18 <lambdabot> uptime: 2 days, 12 hours, 2 minutes and 25 seconds
17:17:58 <Pseudonym> I propose a binary search.
17:18:53 <dons> hehe
17:35:19 <dvtoo_> heh, so, has anyone used the 6.2.2 binary build for solaris?
17:35:39 <dvtoo_> everything I build with it with optimization turned on dumps core
17:39:05 <dvtoo_> I guess I'll try bootstrapping 6.2.2 with it, instead of 6.4
17:39:12 <dvtoo_> then maybe if that works I can build 6.4 with the result
17:40:35 <dons> sounds like a goodd idea.
17:41:15 <dvtoo_> well, someone suggested I try building 6.4 first, but I guess this is a reasonable fallback
17:41:27 <dvtoo_> if this doesn't work, I guess I'll try .hc files, which looks like a pain in the ass to do
17:41:31 <dvtoo_> at least in comparison
17:41:37 <dons> it's very reasonable to try a binary that works first.
17:41:45 <dons> and then use that to build 6.4
17:41:53 <dvtoo_> yeah, I just thought the 6.2.2 binary worked
17:42:03 <dvtoo_> well, it was probably built with an older version of gcc or some such
17:42:20 <dons> which solaris do you have - 10 I guessS?
17:42:28 <dons> sparc/x86?
17:43:14 <dons> can you use any of the binaries here: http://www.haskell.org/ghc/download_ghc_601.html
17:43:16 <dvtoo_> I'm doing this on sparc/10 atm
17:43:28 <dvtoo_> I have sparc 8 and x86 10 available also
17:43:35 <dons> I think you need gcc 2.95, btw.
17:43:47 <dvtoo_> I'm using sparc 10 since the 6.2.2 binary was built on 9
17:43:47 <dons> or maybe gcc > 3.3 is ok too.
17:43:55 <dvtoo_> 3.4 or higher is supposed to be ok
17:44:00 <dons> ok.
17:44:07 <dvtoo_> the 6.2.2 uses libgcc, so it must be 3.x I believe
17:44:18 <dons> does ldd tell you?
17:44:23 <dvtoo_> no
17:44:36 <dvtoo_> I could probably look at the symbol versions, but I don't care that much yet ;)
17:44:55 <dons> well, try the binaries. but if they don't work, just follow the "porting" guide in the user guide.
17:45:07 <dvtoo_> nod, that's the plan currently
17:45:07 <dons> i've used that to bootstrap Sol2.8/sparc.
17:45:18 <dvtoo_> ah, that's good to know
17:45:27 <dvtoo_> what version of ghc?
17:45:29 <dons> it's actually reasonably supported -- compared  to some of the archs out there.
17:45:41 <dons> I did the 6.0.1 port on the download page.
17:46:11 <dvtoo_> I guess worst case I can try that
17:46:14 <dons> there's a native code generator, and ghci support, for example.
17:46:23 <dons> well, 6.0.1 isn't too old.
17:46:28 <dons> and you can use thhat to bulid 6.4
17:46:45 <dvtoo_> that's good to know, that's not a bad route if this doesn't work
17:46:47 <skew> how far back is bootstrapping supposed to work?
17:46:59 <dons> 5.02?
17:47:00 <dvtoo_> I got 6.4 stage1 to build, but it segv's building the libraries
17:47:29 <dons> oh, that's pretty close then. you have split objs turned off?
17:47:55 <dvtoo_> yeah, first thing I had to do
17:48:19 <dvtoo_> I'm not sure what the goal of split objs is
17:48:23 <dons> also, 6.2.2 is very good for .hc bootstraps - we put a lot of work into it.
17:48:37 <dons> makes binaries smaller, as less code from libs has to be linked in.
17:49:37 <dvtoo_> yeah, but does it work at all on solaris?
17:49:54 <dons> possibly - but don't worry about ift for now.
17:50:02 <dons> it relies on ld linker scripts.
17:50:50 <dvtoo_> hrm
17:51:03 <dvtoo_> ghc-6.2.2: unrecognised flags: -K2m
17:51:14 <dvtoo_> while building 6.2.2 with 6.2.2
17:51:47 <dons> so turn that off - it's not crucial (is that when compiling the parser?)
17:51:51 <dvtoo_> yeah
17:51:56 <dvtoo_> I just didn't know if it was expected
17:52:09 <dons> oh ... hmm. sounds like happy isn't installed?
17:52:43 <dvtoo_> not unless it came with the binary on the web site ;)
17:52:45 <dons> are you doing a .hc bootstrap, or do you have a working 6.2.2 binary already?
17:52:58 <dvtoo_> well, I have the 6.2.2 one from the website
17:53:01 <dons> ok. so build happy and alex from haskell.org/{alex,happy}
17:53:12 <dons> then you have the parser and lexer generators.
17:53:47 <dvtoo_> is that required for bootstraping, or just nice to have?
17:54:15 <dons> if you've just got the raw src, you need to regenerate the lexer and parser.
17:54:44 <dons> possibly just touching ghc/compiler/parser/{Parser.hs,Lexer.hs} might do it (do they exist though?)
17:54:55 <dons> if they don't exist then you need happy and alex.
17:55:15 <dvtoo_> I'll check if/when it bombs out again ;)
17:55:19 <dons> if they do, make sure they're newer than $foo/{Parser.y,Lexer.x}
17:55:59 <dvtoo_> btw, thanks, this has been really helpful =)
17:56:15 <dons> sure  :)
17:56:44 <dons> my goal in life is to show that ghc isn't so hard to port - compared to other 1/2 million line compilers.
17:56:49 <dons> think gcc, for example.
17:57:02 <dvtoo_> oh, nod, I can definitely see that
17:57:16 <dvtoo_> btw, is there a code generator for x86_64?
17:57:24 <dons> in ghc cvs, yes.
17:57:57 <dvtoo_> while I've been reading a bit about haskell, I have other motives.  I want to be able to run and test pugs on solaris, to make sure that works ;)
17:58:35 <dons> sure. that's reasonable. building darcs is another good reason ;)
17:59:05 <dons> does pugs use darcs? I can't remember
17:59:15 <dvtoo_> no, they're using subversion/svk
18:00:10 <dvtoo_> ok, so, yeah, I think this compiler is just broken
18:00:27 <dvtoo_> it died on the first thing it tried to build with the stage1 compiler with 6.2.2 also
18:00:33 <dvtoo_> I'll grab your sol8 port
18:00:53 <dons> how did it die?
18:01:06 <dvtoo_> SIGILL
18:01:13 <dons> hmm.
18:01:29 <dvtoo_> I did a truss on one before, it looked like it was dying after running the source through cpp
18:01:53 <dons> oh. I wonder if you need to use gnu cpp.
18:02:01 <dvtoo_> well, it is
18:02:05 <dons> I recall having trouble with solaris cpp.
18:02:08 <dons> ok.
18:02:14 <dvtoo_> it's calling the one in the gcc libexec dir
18:02:22 <dvtoo_> actually, it's calling gcc -E afaict
18:04:07 <dvtoo_> I'll try bootstraping 6.4.0 with your sol8 6.0.1 binary
18:06:29 <dons> sounds reasonable
18:07:04 <Pseudonym> That's the fourth person who's asked for a cabalised Edison.
18:11:55 <stepcut> heh
18:24:00 <dvtoo_> dons: looks like programs that 6.0.1 builds segv too if -O is used
18:24:10 <dvtoo_> so maybe it's some weird interaction with sun ld or gcc
18:24:39 <dons> hmm. sun ld doesn't sound good. do you have gnu binutils?
18:24:50 <dvtoo_> gnu binutils doesn't work with newer gcc's
18:25:08 <dons> what about gcc 2.95? do you have access to that?
18:25:15 <dvtoo_> well, I could build it
18:25:19 <dvtoo_> but I'd really rather not ;)
18:25:28 <dons> I would recommend starting with gnu ld if possible.
18:25:52 <dvtoo_> gnu ld just doesn't work at all on 10 afaik
18:26:02 <dvtoo_> because it can't understand crt1.o or whatever
18:26:05 <dons> not sure though why -O would have any effect on which ld you use though..
18:26:27 <dons> ok. so maybe you need to look at .hc bootstrapping.
18:26:38 <dvtoo_> well, I think it's native code generator vs compiling to c
18:26:56 <dons> why would the native code gen be involved yet?
18:27:07 <dvtoo_> does it always compile to c?
18:27:21 <dons> when booting ghc by default.
18:27:25 <dvtoo_> oh, hrm
18:27:51 <dvtoo_> well, trying it again without -O with 6.0.1
18:28:03 <dons> you can force -fasm
18:28:07 <dvtoo_> i'm guessing it'll bomb out on the first thing it tries to build with the stage1 compiler, but easy to try
18:28:18 <dons> buut it's more likely to break with --fasm
18:43:05 <dvtoo_> well, looks like the 6.0.1 build build a working compiler
18:43:07 <dvtoo_> yay ;)
18:43:18 <dvtoo_> err, build built ;)
18:43:32 <dvtoo_> at least it's compiling things and not dying ;)
18:47:35 <dvtoo_> oops, sigill again
19:03:29 <elk> does ghc --make support recursive modules ?
19:07:47 <Cale> does ghc support recursive modules?
19:08:39 <SamB> is there such a thing as .hs-boot?
19:08:44 <elk> mutually recursive that is
19:08:55 <Cale> yeah
19:09:16 <elk> SamB : yes, there is
19:10:11 <elk> the whole thing used to compile just fine
19:10:39 <SamB> does it complain?
19:10:55 <elk> now when I am using ghc --make I am getting linking errors
19:11:11 <SamB> linking errors such as?
19:12:20 <elk> don't remember exactly - like undefined _stginit_ModuleName and something about fake
19:12:57 <elk> it was on ghc 6.2.2 - on my machine at work
19:13:50 <elk> i have 6.4 at home and it panics
19:20:58 <elk> ok, tried it on a trivial example and it works
19:21:20 <SamB> ghc is going insane. it is trying to find Even.hs-boot-boot...
19:22:01 <SamB> maybe because I am trying to use ghci?
19:23:34 <elk> hmm, ghci works for me - I pasted the code from ghc docs - modules A and B
19:27:59 <SamB> maybe it works better if I also give function type declarations in the .hs files...
19:29:56 <dvtoo_> dons: still around?
19:30:04 <SamB> for some reason when I load the module without the .hs-boot file in ghci, it seems to forget to compile the one with the .hs-boot twice...
19:30:29 <dvtoo_> anyone know how to generate .hc files?
19:33:52 <SamB> to the point where I get strange errors... the kind that would result in a segfault if GHCi were written in C...
19:34:12 <elk> tried my project with ghci - fails with the same error as ghc panics:
19:34:15 <elk> *** Exception: expectJust upsweep_mod:old_linkable
19:34:40 <SamB> thats what I mean, exactly
19:35:10 <SamB> *Even> :l Odd
19:35:10 <SamB> Compiling Even[boot]       ( Even.hs-boot, Even.o-boot )
19:35:10 <SamB> Compiling Odd              ( Odd.hs, interpreted )
19:35:10 <SamB> Ok, modules loaded: Odd, Even.
19:35:10 <SamB> *Odd> odd 1
19:35:11 <SamB> *** Exception: expectJust upsweep_mod:old_linkable
19:40:04 <SamB> works fine if I do :l Even, though
19:40:47 <elk> did you try --make ?
19:43:31 <elk> ghci with example from the docs works:
19:43:34 <elk> Compiling A[boot]          ( A.hs-boot, A.o-boot )
19:43:35 <elk> Compiling B                ( ./B.hs, interpreted )
19:43:35 <elk> Compiling A                ( A.hs, interpreted )
19:43:35 <elk> Ok, modules loaded: A, B, A.
19:43:35 <elk> *A> f $ MkTB 42
19:43:36 <elk> MkTA 42
19:43:59 <SamB> the same thing happens if I try ghc --make OddMain.hs (where OddMain.hs imports Odd and is a Main)
19:45:07 <SamB> I think this may be worthy of the Haskell list.
19:45:16 <SamB> as in, a bug.
19:45:45 <SamB> it certainly does not appear to be well documented
19:46:53 <SamB> its definately not what I would call a feature.
19:48:35 <SamB> would you like to write it or should I?
19:49:14 <elk> you have a not-working example, would you do it ?
19:49:39 <SamB> sure
19:49:52 <elk> thanks, and thanks for you help!
19:51:03 <SamB> hmm, should I tar up my sources or attach them one-by-one?
19:51:18 <SamB> I guess one-by-one would be easier to read...
19:53:15 <SamB> @spell wierdness
19:53:17 <lambdabot> weirdness wideness weediness wordiness wetness
19:54:18 <SamB> elk: how shall I refer to you? or should I not refer to you?
19:56:41 <SamB> arg, gmail is being a pain...
19:57:01 <SamB> I guess I'll post with Pan via gmane...
19:57:44 <elk> SamB: no need to refer ;-)
20:23:04 <SamB> hmm, I just noticed that this should go to glasgow-haskell-bugs@haskell.org, not haskell@haskell.org...
20:29:57 <SamB> you'd think I would have learned to reply to the mailman list-join-verification before sending my email to a new list, but no...
20:33:29 <SamB> you know, it is sad that they have Simon Marlow using Outlook...
20:34:47 * SamB is bored and has run out of email!
20:34:55 * SamB is at least glad not to have spam
20:35:14 * Gahhh sends SamB some email regarding viagra and mortgages
20:35:34 <SamB> Gahhh: doncha think gmail is wise to that kind of thing?
20:36:00 <Gahhh> I don't know. I have an account but never use it. in fact I suspect I don't remember my password.
20:36:30 <Trevion> Oh, yes, Gmail is quite wise to that kind of thing.
20:36:43 <SamB> gmail is like the best free email evar!
20:37:01 <SamB> or at least, better than what I had before
20:37:01 <Trevion> Plus, Google reads all your mail!
20:37:11 * Trevion never forgets his tinfoil hat
20:37:27 <Gahhh> heh. I deby cookies to google
20:37:31 <Gahhh> deny
20:38:16 <SamB> actually, I wish they had a way to send mails to the gmail people and complain about how gmail should have detected how they were in the same thread and things like that...
20:38:25 <Gahhh> ahah I remembered my password but cookies are disabled lol.
20:38:28 <SamB> or how the ads that you see are all boring and useless
20:38:40 <Trevion> Oh, the ads are not boring and useless.  The ads are generally hilarious.
20:38:43 <Gahhh> you can use pop3 iirc
20:38:44 <Trevion> (and useless)
20:39:43 <SamB> Gahhh: if and when I decide to migrate away, that will be nice. until then I have no clue how to administrate mail properly...
20:40:37 <Gahhh> my main account is with fastmail.fm. Free imap (receive). 20Mb inbox, tho
20:46:25 <SamB> @pl \my_inbox your_inbox -> my_inbox > (100*your inbox)
20:46:26 <lambdabot> const . (> 100 * your inbox)
20:46:35 <SamB> @pl \my_inbox your_inbox -> my_inbox > (100*your_inbox)
20:46:36 <lambdabot> (. (100 *)) . (>)
20:46:58 <SamB> my inbox is (. (100 *)) . (>) your inbox!
20:47:17 * SamB likes pointless taunting ;-)
20:51:52 * SamB wonders about the distinct non-groaning sound he is hearing
20:53:00 <SamB> I wonder if @pl can be made to find prettier solutions?
20:56:09 <wagle> SamB: you can be fixpointed.
20:56:55 <SamB> wagle: say what?
20:57:11 <wagle> weak attempt at humor
20:57:51 <wagle> sometimes it works better than i think..  uhh..  sometimes not
20:59:21 <dbremner> Gahhh - gmx.de has 1gb mailboxes and free pop3. I've used them for 9 years or so.
21:00:06 <Gahhh> dbremner: doesnt that require a german postal code to join ? I vaguely remember checking that one out.
21:00:38 <Pseudonym> You could get prettier @pls if you had B* and C' combinators, I think.
21:00:43 <Pseudonym> C' in particular.
21:00:53 <Pseudonym> There would be fewer flips.
21:01:01 <dbremner> Gahhh - I joined before they had an English version. There was an English version of their site for awhile, but it was discontinued. I use babelfish and such to change account settings.
21:01:27 <Gahhh> heh
21:01:52 <dbremner> Gahhh - I thought I filled in my real .us address, though.
21:02:52 <Gahhh> dbremner: the choices are germany, austria and switzerland heh.
21:03:19 <dbremner> Gahhh - they had gmx.* for most of the EU at one point.
21:04:03 <Gahhh> gmx.it redirects to gmx.de
21:05:03 <dbremner> Gahhh - when they discontinued an English version, I got an email suggesting I learn German.
21:05:54 <jaap> you could try freeshell... I use ugcs, but I'm afraid we can't offer that to anyone outside caltech
21:06:58 <Gahhh> dbremner: I speak german. a bit rusty tho. in any case, I already have a 2Gb inbox that I don't use :)
21:07:29 <dbremner> Gahhh - I mostly use my gmail account for files and bookmarks.
21:07:38 <lispy> are most people in this channel students or faculty?
21:07:53 <lispy> dbremner: does it do a good job with bookmarks?
21:08:13 <dbremner> lispy - I upload the Firefox bookmark file.
21:08:20 <lispy> i have a friend that uses gmail for his mailling lists and it seems to be pretty good for that
21:08:27 <lispy> dbremner: ah, cool
21:08:35 <dbremner> lispy - I get a fair amount of spam, though.
21:08:49 <SamB> dbremner: on gmail?
21:08:55 <lispy> i try to have as few email accounts as possible, that's the only reason i don't have gmail account yet
21:09:17 * puetzk runs his own server, and has a gmail in case it's broken :-)
21:09:21 <dbremner> SamB - yes. I registered for a private enterprise number and now the address is on the web.
21:09:23 <puetzk> but that's all
21:09:38 <puetzk> too many is not a good thing :-)
21:09:41 <lispy> puetzk: i run my own server and use my school account if it breaks :)
21:09:43 <SamB> dbremner: a what?
21:10:04 <Trevion> dbremner: how's Gmail's spam filter?  I don't get much spam in my account, so I've never really noticed.
21:10:31 <lispy> is gmail still technically beta?
21:10:38 <lispy> heh, i should just chekc
21:10:52 <lispy> ah, yup it is
21:11:03 <SamB> doesn't it say something if you don't get much spam? I was under the impression that it blocked most stuff hard, so it never hit the Spam bin...
21:11:15 <dbremner> Samb - http://www.iana.org/cgi-bin/enterprise.pl
21:12:17 <dvtoo_> ah, I see.  so it's the tail call optimization out of gcc probably that's broke
21:12:21 <dvtoo_> err, broken
21:13:02 <wagle> what's wrong with it?
21:13:02 <mwc> hello
21:13:02 <mwc> PING!
21:13:03 <SamB> my gmail address is most likely all over the web by now, since I've been using it mostly for mailing lists
21:13:18 <wagle> can anyone see mwc?  i cant
21:13:30 <mwc> 00:14 -!- Irssi: Join to #haskell was synced in 91 secs
21:13:30 <mwc> Somebody tell me I'm barking
21:13:32 <mwc> Ah
21:13:37 <SamB> which have multiple sets of publicly-viewable archives
21:13:42 <mwc> Lag just dropped from 37 seconds to 2.94.
21:13:48 * Trevion can't see nicks that start with m...
21:14:00 <Gahhh> I do see mwc
21:14:02 <dvtoo_> wagle: I'm thinking it's breaking the asm generated by gcc 3.4.x on sparc
21:14:05 <dbremner> SamB - the list of private enterprise numbers is public, and that's when I started getting spam.
21:14:27 <SamB> I guess gmane wouldn't do harvesters any good...
21:14:29 <dvtoo_> apparently there is a perl script that ghc uses to mangle the gcc asm output
21:14:29 <Pseudonym> @pl \f x y z -> f (x z) y
21:14:29 <lambdabot> (flip .) . (.)
21:14:33 <dbremner> Trevlon - I get about 1-2 spams per day.
21:14:36 <Pseudonym> @pl \f x y z -> f x (y z)
21:14:37 <lambdabot> ((.) .)
21:14:43 <SamB> well, not for the haskell.org mailing lists, anyway.
21:14:45 <Pseudonym> Actually, that one isn't too bad.
21:14:51 <Pseudonym> But C' needs some work.
21:14:58 <SamB> dvtoo_: yes, the Evil Mangler
21:15:02 <wagle> need unflip  8)
21:15:15 <Gahhh> let flip = unflip
21:15:15 <mwc> that's okay, I can't see those weird capitalized names
21:15:16 <wagle> duh, i mean pointful
21:15:34 <wagle> unpoint?  dull?
21:15:42 <dvtoo_> I commented out the &mangle call in that, so going to try building it again and see if that fixes my problem in the short term
21:15:46 <wagle> ugh.. its late
21:15:57 <Pseudonym> Actually, something I'd find handy is a type-to-free-theorem converter.
21:16:00 <dvtoo_> I'm not sure I know enough about sparc assembly to fix it if that's the real problem
21:16:15 <mwc> Woah, what's C'
21:16:32 <SamB> C prime?
21:17:12 <wagle> C.
21:17:14 <dbremner> dvtoo_ - have you tried compiling w/o strict aliasing?
21:17:19 <wagle> C composite?
21:17:32 <JohnMeacham> inv(C)
21:17:38 <SamB> hmm, I guess gmail couldn't find any slate- or haskell- related ads.
21:17:41 <dvtoo_> no, I haven't
21:17:46 <wagle> C flipped
21:17:51 <Pseudonym> @pl f x y = f y x
21:17:52 <lambdabot> f = fix flip
21:17:52 <Pseudonym> That's C
21:18:00 <dvtoo_> you mean passing that into ghc and having it pass it on to gcc?
21:18:02 <Pseudonym> Hey, it handles recursion!
21:18:09 <Pseudonym> @pl \ f x y -> f y x
21:18:10 <lambdabot> flip
21:18:12 <Pseudonym> That's C
21:18:12 <dbremner> dvtoo_ - yes.
21:18:15 <dvtoo_> hrm
21:18:31 <wagle> @pl flip flops
21:18:31 <dbremner> dvtoo_ - and if TRE is broken, I'm sure they'd appreciate a bug report.
21:18:31 <lambdabot> flip flops
21:18:32 <Pseudonym> @pl let { a = 1 : b; b = 2 : a } in a
21:18:33 <lambdabot> (line 1, column 5):
21:18:33 <lambdabot> unexpected "{"
21:18:33 <lambdabot> expecting natural, identifier or "in"
21:18:36 <Pseudonym> Damn.
21:18:37 <dvtoo_> TRE?
21:18:55 <Pseudonym> @pl let (a,b) = (1 : b, 2 : a) in a
21:18:56 <lambdabot> (line 1, column 5):
21:18:56 <lambdabot> unexpected "("
21:18:56 <lambdabot> expecting natural, identifier or "in"
21:19:03 <dbremner> dvtoo_ - tail recursion elimination.
21:19:05 <Pseudonym> OK, it doesn't have a PMC.
21:19:17 <dvtoo_> well, this isn't actually an issue with gcc afaict
21:19:18 <SamB> you didn't *really* expect @pl to parse full Haskell?
21:19:35 <wagle> SamB: yes
21:19:47 <mwc> Can we just start using new names now? C++ was fine, but C--, C#, C'
21:19:47 <mwc> C* The Complicated Hyperreal Language
21:19:47 <mwc> Damn, cales not here, he might have gotten it
21:19:47 <mwc> wasted a good joke.
21:20:08 <SamB> C-- actually means something!
21:20:11 <dbremner> mwc - I read a book that featured a language called C^3
21:20:14 <MachinShin> hah
21:20:26 <MachinShin> there's a C--  & a C' ? wtf?
21:20:30 <MachinShin> don't forget D :)
21:20:32 <wagle> csh
21:20:35 <Gahhh> www.cminusminus.org
21:20:35 <SamB> it is meant to be not much more than an IL...
21:20:58 <dbremner> MachinShin - there have been several languages called D.
21:20:59 <JohnMeacham> it is a portable assembly language.
21:21:01 <wagle> c.run
21:21:04 <SamB> as in, not something to write programs in
21:21:04 <wagle> run.run
21:21:22 <dbremner> SamB - there was also a C-- for DOS.
21:21:44 <SamB> dbremner: who cares! nobody uses dos anymore.
21:21:49 <Gahhh> vb.net has an IsNot operator.
21:21:52 <wagle> freedos
21:21:57 <JohnMeacham> I was thinking it would be useful for programing PICs. the explicit tailcalls would be important because you typically only have a handful of stack frames and so you have to conciously decide when to use them.
21:21:59 <MachinShin> dbremner: yah. but this is the 'newest' one. it's C, C++, Java, VB and a bit of whatever thrown in. and of course the logic behind it was 'c++ is too complex. we nned a simple, easy to implement language. "
21:22:03 <SamB> okay, hardly anyone uses dos anymore.
21:22:29 <dbremner> Gahhh - and they patented it. Algol 68 is prior art.
21:22:52 <mwc> SamB: yeah, but C-- doesn't feel like C
21:22:53 <mwc> I understood it included primitives for various things like GC and that
21:22:55 <mwc> Exceptions, etc
21:22:57 <mwc> I can't call that C--, it seems wrong
21:22:59 <mwc> C+- maybe
21:23:01 <mwc> Hmm
21:23:03 <mwc> *(C--)++
21:23:04 <Gahhh> dbremner: I pinned that excerpt from the algol manual that you showed me.
21:23:14 <MachinShin> mwc: lol
21:23:19 <wagle> C->
21:23:24 <SamB> how about Ci?
21:23:29 <JohnMeacham> it doesn't include a GC, but it gives you the information and hooks needed to write one.
21:23:38 <wagle> Magnum Ci
21:23:48 <mwc> (C--)&rand()
21:23:49 <SamB> Ci meaning C*sqrt(-1)
21:23:59 <Gahhh> C >>=
21:24:13 <mwc> SamB: heh
21:24:18 <mwc> COMPLEX(0,C)
21:24:34 <SamB> mwc: that doesn't really express rotation, though...
21:24:37 <wagle> Quaternions and Octonions
21:24:57 <mwc> Or a tensor product...
21:25:18 * mwc blanches as he realizes he can't type that in ASCII
21:25:19 <Gahhh> doh. <C/>, of course, as XML is sublime and the silver bullet, etc.
21:25:32 <mwc> Gahhh: I think you mean:
21:26:04 <mwc> <C xmlns="foo.org/bar" lang="en" /> at the very least
21:26:04 <Trevion> (C) - XML is just s-expressions with funny syntax.
21:26:09 <mwc> in order to localize keywords
21:26:28 <Gahhh> <!DOCTYPE uncommentedcode>
21:27:19 <mwc> I never managed to get used to those S-expr
21:27:28 <SamB> mwc: which ones?
21:27:49 <SamB> the ones with too many parentheses?
21:28:11 <SamB> and the jokes about spare cards consisting of ")))))))))))))))))))))))))))))...."
21:28:38 <wagle> )) ] ) ) ))) ] )
21:28:41 <batkins_> does haskell optimize tail recursion?
21:28:43 <Trevion> Lots of Idiotic, Stupid Parentheses.
21:28:58 <SamB> batkins_: only if you do it just right
21:29:09 <batkins_> SamB: ah
21:29:18 <mwc> They claimed it would go away in time but after 4 days I was still Shift-%'ing
21:29:18 <mwc> SamB: scheme
21:29:18 <mwc> I think it's because I tend to write functions from the middle out
21:29:18 <mwc> SamB: those are the ones
21:29:19 * mwc has a screaming fit as he realizes he has somehow got a perfect solution albeit v' = x
21:29:21 <batkins_> i got a stack overflow for a actorial function
21:29:22 <JohnMeacham> batkins_: definitly. otherwise you wouldn't be able to write space efficient code.
21:29:40 <batkins_> fac 0 = 1       fac n = n * fac (n - 1)
21:29:43 <JohnMeacham> are you sure it is not running out of heap due to lazy evaluation.
21:30:05 <JohnMeacham> that is not a tail call. the recursive call fac is passed as an argument to *
21:30:06 <batkins_> JohnMeacham: nope :)  i used that definition above and did fac 3000
21:30:07 <wagle> the n * fac (n - 1) is not in tgail recursive form
21:30:20 <batkins_> oh
21:30:33 <mwc> batkins_: it's tail recursion with cons
21:30:46 <mwc> that's harder to optimize
21:30:57 <JohnMeacham> add another parameter to 'fac' to accumulate the result.
21:31:14 <SamB> I like the fac n = product [1..n] definition myself...
21:31:21 <mwc> batkins_: or you can create a list [1..n] and then fold across it
21:31:39 <Pseudonym> @pl let p = fix (\(a,b) -> (1 : b, 2 : a)) in fst p
21:31:40 <lambdabot> fst (fix (uncurry (flip ((,) . (1 :)) . (2 :))))
21:31:49 <SamB> @pl \n -> product [1..n]
21:31:50 <lambdabot> product . enumFromTo 1
21:31:58 <mwc> foldl' (*) (1) [2..n] for instance
21:32:08 <Pseudonym> @plugs take 20 $  fst (fix (uncurry (flip ((,) . (1 :)) . (2 :))))
21:32:13 <lambdabot> Variable not in scope: `fix'
21:32:13 <xerox> @type foldl'
21:32:18 <lambdabot> bzzt
21:32:25 <Pseudonym> @plugs let fix f = f (fix f) in take 20 $  fst (fix (uncurry (flip ((,) . (1 :)) . (2 :))))
21:32:27 <lambdabot> [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
21:32:27 <SamB> mwc: bah, there is already a perfectly good product in Prelude isn't there?
21:32:28 <JohnMeacham> foldl' is not in the standard libraries...
21:32:30 <SamB> @type product
21:32:31 <lambdabot> product :: forall a. (Num a) => [a] -> a
21:32:31 <Pseudonym> Damn, it works.
21:32:32 <wagle> Prelude> product [1..1000] :: Int
21:32:32 <wagle> 0
21:33:00 <Cale> wagle: well, of course :)
21:33:11 <SamB> @plugs product [1..1000] :: Integer
21:33:13 <lambdabot> 4023872600770937735437024339230039857193748642107146325437999104299385
21:33:13 <lambdabot> 1239862902059204420848696940480047998861019719605863166687299480855890
21:33:13 <lambdabot> 1323829669944590997424504087073759918823627727188732519779505950995276
21:33:13 <lambdabot> 1208749754624970436014182780946464962910563938874378864873371191810458
21:33:13 <lambdabot> 2578364784997701247663288983595573543251318532395846307555740911426241
21:33:14 <lambdabot> 7474349347553428646576611667797396668820291207379143853719588249808126
21:33:16 <lambdabot> 8678383745597317461360853795345242215865932019280908782973084313928444
21:33:18 <lambdabot> [23 @more lines]
21:33:26 <JohnMeacham> Way to DOS the lambdabot :)
21:33:31 <batkins_> is that a factorial?
21:33:32 <mwc> SamB: sure, but that's a horrible implementation for a factorial function, so obviously it's a pedantic example
21:33:32 <SamB> @more
21:33:32 <wagle> newtype UnsafeInt = Int
21:33:33 <lambdabot> 0328123155861103697680135730421616874760967587134831202547858932076716
21:33:33 <lambdabot> 9132448426236131412508780208000261683151027341827977704784635868170164
21:33:33 <lambdabot> 3650241536913982812648102130927612448963599287051149649754199093422215
21:33:33 <lambdabot> 6683257208082133318611681155361583654698404670897560290095053761647584
21:33:33 <lambdabot> 7728421889679646244945160765353408198901385442487984959953319101723355
21:33:34 <lambdabot> 5566021394503997362807501378376153071277619268490343526252000158885351
21:33:35 <mwc> Common, it's O(n)
21:33:36 <lambdabot> 4733161170210396817592151090778801939317811419454525722386554146106289
21:33:38 <lambdabot> [16 @more lines]
21:33:47 <SamB> mwc: how would you do it?
21:33:47 <mwc> @more
21:33:48 <lambdabot> 2187960223838971476088506276862967146674697562911234082439208160153780
21:33:48 <lambdabot> 8898939645182632436716167621791689097799119037540312746222899880051954
21:33:48 <lambdabot> 4441428201218736174599264295658174662830295557029902432415318161721046
21:33:48 <lambdabot> 5832036786906117260158783520751516284225540265170483304226143974286933
21:33:48 <lambdabot> 0616908979684825901254583271682264580665267699586526822728070757813918
21:33:50 <lambdabot> 5817888965220816434834482599326604336766017699961283186078838615027946
21:33:50 <mwc> What the hell
21:33:52 <lambdabot> 5955131156552036093988180612138558600301435694527224206344631797460594
21:33:54 <lambdabot> [9 @more lines]
21:33:59 <Gahhh> you got all those digits ?
21:34:09 <wagle> type UnsafeInt = Int
21:34:09 <mwc> SamB: probably use Sterling's formula to get an approximation and then refine with a fixed point iteratrion
21:34:11 <wagle> i mean
21:34:13 <SamB> Gahhh: it is a thing called Integer!
21:34:21 <JohnMeacham> I wonder if 'product' is ever useful outside of writing a semi-concise factorial function.
21:34:25 <wagle> Int makes Haskell unsafe
21:34:55 <Gahhh> JohnMeacham: no biggie if it is not, is it
21:34:59 <mwc> SamB: http://mathworld.wolfram.com/StirlingsApproximation.html
21:35:03 <SamB> wagle: modular arithmatic is still referentially transparent!
21:35:06 <Cale> wagle: Everyone should know that Ints are machine integers, and hence are just Z_(2^n) for some n :)
21:35:08 <mwc> for FP math that might just be good enough on it's own
21:35:30 <wagle> many people use Int as if it were Integer
21:35:34 <JohnMeacham> It doesn't make it unsafe, it is just not an integer.
21:35:39 <Cale> well, they shouldn't :)
21:35:40 <SamB> @plugs product [1..1000] :: Float
21:35:41 <Gahhh> wagle: like C programmers ?
21:35:42 <lambdabot> Infinity
21:35:53 <wagle> Gahhh: like Haskell programmers
21:35:55 <SamB> huh, I didn't know that Float was so limited!
21:36:03 <SamB> @plugs product [1..1000] :: Double
21:36:05 <lambdabot> Infinity
21:36:19 <Cale> wagle: I tend to stay away from Int unless the standard library forces it on me
21:36:54 <Pseudonym> BTW, the product in the prelude is _not_ perfectly good.
21:36:57 <mwc> SamB: jut to be pedantic, I'd use formual 13 on that page as an error bound on my intial estimate and then given the order of magnitude and the max precision at that magnitude I'd iterate until I was within that precision
21:36:59 <wagle> Cale: yup..  but it does force itself
21:37:08 <SamB> Pseudonym: what is wrong with it?
21:37:09 <JohnMeacham> We should be careful not to dilute the word 'unsafe' since there are things that really are 'unsafe'. I have been trying to introduce a word 'unwise' which basically means, thinks marked unsafe can violate static semantics, thinks marked unwise can violate the dynamic ones.
21:37:16 <Pseudonym> SamB: Try it on very large integers./
21:37:17 <mwc> But then I'm studying for a numerical analysis final
21:37:30 <Pseudonym> @plugs product [1..20000] `seq` ()
21:37:31 <Gahhh> JohnMeacham: I think that is called unsound somewhere else in the lit
21:37:32 <lambdabot> ()
21:37:40 <Pseudonym> @plugs product [1..100000] `seq` ()
21:37:42 <lambdabot> Stack overflow
21:37:45 <Pseudonym> Bingo.
21:37:50 <SamB> oh.
21:37:58 <SamB> maybe we should report a bug in the report...
21:38:15 <Pseudonym> I had to write my own for the number theory library.
21:38:15 <JohnMeacham> Yeah, but unsound has a strong theoretical meaning. I am talking more about practical naming of API functions.
21:38:17 <wagle> 1 + 1 = 0 seems bad
21:38:20 <SamB> @plugs foldr (*) [1..100000] `seq` ()
21:38:21 <lambdabot> <Plugins.Eval>:1:
21:38:21 <lambdabot>   No instance for (Num [t])
21:38:21 <lambdabot>   arising from use of `*'
21:38:34 <Trevion> wagle: not in Z_2
21:38:44 <Pseudonym> @plugs foldr' (*) 1 [1..100000::Integer] `seq` ()
21:38:44 <lambdabot> Variable not in scope: `foldr''
21:38:45 <SamB> @plugs foldr (*) 1 [1..100000] `seq` () ::
21:38:45 <lambdabot> parse error on input `)'
21:38:48 <Pseudonym> Hmmm.
21:38:53 <Pseudonym> @plugs foldr (*) 1 [1..100000::Integer] `seq` ()
21:38:55 <lambdabot> Stack overflow
21:38:58 <Pseudonym> @plugs foldl (*) 1 [1..100000::Integer] `seq` ()
21:39:00 <lambdabot> Stack overflow
21:39:02 <Pseudonym> @plugs foldl' (*) 1 [1..100000::Integer] `seq` ()
21:39:05 <SamB> @plugs foldr (*) 1 [1..100000] `seq` ()
21:39:06 <lambdabot> Terminated
21:39:06 <lambdabot> Stack overflow
21:39:11 <Pseudonym> OK, that one terminates.
21:39:13 <wagle> most people are NOT programming in modular arithmetic
21:39:13 <Cale> wagle: 1 + 1 = 0 implies that (x + y)^2 = x^2 + y^2, which is sometimes nice :)
21:39:24 <wagle> even if they do use Int
21:39:50 <Pseudonym> Oh, I _think_ mine from the number theory library actually terminates there.
21:39:57 <Pseudonym> Because it's faster.
21:40:06 <wagle> there's a whole genre of integer wrap bugs
21:40:16 <SamB> @plugs foldl (*) 1 [1..90000] `seq` ()
21:40:18 <lambdabot> Stack overflow
21:40:33 <SamB> @plugs foldl' (*) 1 [1..90000]
21:40:37 <lambdabot> Terminated
21:40:47 <SamB> @type foldl'
21:40:48 <lambdabot> bzzt
21:40:53 <SamB> @type foldl
21:40:54 <lambdabot> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
21:41:12 <Pseudonym> @type Data.List.foldl'
21:41:14 <lambdabot> Data.List.foldl' :: forall a b. (a -> b -> a) -> a -> [b] ->
21:41:14 <lambdabot> a
21:41:28 <Pseudonym> It's like foldl, only with a strict accumulator.
21:41:35 <SamB> ah
21:41:49 <SamB> @plugs foldl' (*) 1 [1..50000]
21:41:53 <lambdabot> Terminated
21:41:58 <SamB> @plugs foldl' (*) 1 [1..20000]
21:42:02 <lambdabot> Terminated
21:42:07 <SamB> @plugs foldl' (*) 1 [1..10000]
21:42:10 <lambdabot> 2846259680917054518906413212119868890148051401702799230794179994274411
21:42:10 <lambdabot> 3400037644437729907867577847758158840621423175288300423399401535187390
21:42:10 <lambdabot> 5242116138271617481982419982759241828925978789812425312059465996259867
21:42:10 <lambdabot> 0656016157203603239792632873671705574197596209947972034615369811989709
21:42:10 <lambdabot> 2611277500484198845410475544642442136573303076703628825803548967461117
21:42:11 <lambdabot> 0973695786036701910715127305872810411586405612811653853259684258259955
21:42:13 <lambdabot> 8468814643042558983664931705925171720427659740744613340005419405246230
21:42:15 <lambdabot> [23 @more lines]
21:42:29 <MachinShin> wtf?
21:42:33 <SamB> why does it just say Terminated with the bigger ones? ran out of time?
21:42:49 <Pseudonym> let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bip [1..100000]
21:43:03 <Pseudonym> Oops.
21:43:15 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct [1..100000]
21:43:19 <lambdabot> Terminated
21:43:26 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct [1..100000] `seq` ()
21:43:28 <lambdabot> ()
21:43:30 <SamB> @plugs foldl (*) 1 [1..10000]
21:43:31 <Pseudonym> Woohoo!
21:43:33 <lambdabot> 2846259680917054518906413212119868890148051401702799230794179994274411
21:43:33 <lambdabot> 3400037644437729907867577847758158840621423175288300423399401535187390
21:43:33 <lambdabot> 5242116138271617481982419982759241828925978789812425312059465996259867
21:43:33 <lambdabot> 0656016157203603239792632873671705574197596209947972034615369811989709
21:43:33 <lambdabot> 2611277500484198845410475544642442136573303076703628825803548967461117
21:43:34 <lambdabot> 0973695786036701910715127305872810411586405612811653853259684258259955
21:43:36 <lambdabot> 8468814643042558983664931705925171720427659740744613340005419405246230
21:43:38 <lambdabot> [23 @more lines]
21:43:44 <Pseudonym> It actually computed factorial of 100000.
21:43:48 <Pseudonym> Though refused to print it out.
21:43:57 <SamB> was it just too long?
21:44:00 <Pseudonym> Right.
21:44:07 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct [1..100000] `mod` 1000
21:44:09 <lambdabot> 0
21:44:14 <Pseudonym> Unsurprising.
21:44:26 <SamB> why can't it just print out the first bit of it and truncate the @more?
21:44:35 <wagle> @plugs product [1..100000] `seq` ()
21:44:36 <lambdabot> Stack overflow
21:44:41 <wagle> ugh
21:44:43 <Pseudonym> It's the show function on the large integer which is the problem.
21:44:49 <Pseudonym> That's what's taking the time.
21:44:56 <SamB> oh, I see.
21:45:00 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct [1..100000] `mod` 100001
21:45:02 <lambdabot> 0
21:45:08 <SamB> so it takes a while to find the first digit?
21:45:09 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct [1..100000] `mod` 100003
21:45:11 <lambdabot> 50001
21:45:12 <Pseudonym> Right.
21:45:35 <Pseudonym> See, showing it modulo a small number works.
21:46:41 <SamB> so, why doesn't foldl' work?
21:46:42 <wagle> @plugs length (uct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12
21:46:42 <wagle>                    `seq` x12 `seq` x12 : bip xs; bip xs = xs } in bproduct
21:46:42 <wagle>                    [1..100000] `mod` 100003
21:46:43 <Pseudonym> It's actually cheaper to multiply [1..100000] in a binary tree formation rather than ( ... ((1 * 2) * 3) * 4 ... )
21:46:43 <lambdabot> parse error on input `;'
21:46:54 <wagle> i hate cut & paste
21:47:11 <wagle> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs
21:47:11 <wagle>                    = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12
21:47:12 <lambdabot> parse error on input `)'
21:47:18 <Pseudonym> Even though it's the same number of multiplies.
21:47:55 <Pseudonym> It's because multiplying two large integers is not a constant-time operation.
21:47:59 <SamB> Pseudonym: yeah, but that doesn't work on arbitrary lists very well, does it?
21:48:26 <wagle>                    `@plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in length (show (bproduct [1..100000]  )
21:48:29 <Pseudonym> SamB: Why not?
21:48:45 <wagle> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in length (show (bproduct [1..100000]  )
21:48:46 <lambdabot> parse error on input `;'
21:49:02 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in length . show . bproduct $ [1..100000]
21:49:06 <lambdabot> Terminated
21:49:11 <Pseudonym> See?
21:49:18 <SamB> Pseudonym: is that what you have then?
21:49:41 <wagle> log10
21:50:04 <Pseudonym> Sorry, is what what I have?
21:50:07 * SamB can't read code like that with no newlines...
21:50:53 <wagle> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in length . show . bproduct $ [1..100000]
21:50:57 <lambdabot> Terminated
21:51:11 <wagle> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs } in log . bproduct $ [1..100000]
21:51:12 <lambdabot> Infinity
21:51:25 <wagle> eh?
21:51:36 <SamB> Pseudonym: what does bproduct do?
21:51:40 <wagle> ugh
21:51:41 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs; l10 1 = 0; l10 n = 1 + (n `div` 10) } in l10 . bproduct $ [1..100000]
21:51:45 <lambdabot> Terminated
21:51:59 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 `seq` x12 : bip xs; bip xs = xs; l10 1 = 0; l10 n = 1 + l10 (n `div` 10) } in l10 . bproduct $ [1..100000]
21:52:03 <lambdabot> Terminated
21:52:54 <SamB> what is with x12 `seq` x12 `seq` x12 ?
21:53:35 <Pseudonym> Errr.
21:53:36 <Pseudonym> Bug.
21:53:54 <wagle> maybe seq wasnt as strict as you though?
21:53:58 <wagle> maybe seq wasnt as strict as you thought?
21:54:26 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 : bip xs; bip xs = xs; l10 1 = 0; l10 n = 1 + l10 (n `div` 10) } in l10 . bproduct $ [1..100000]
21:54:31 <lambdabot> Terminated
21:55:17 <wagle> hugs on a 1 GHz G4 is taking 2 minutes so far on the l10 expr
21:55:21 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 : bip xs; bip xs = xs; l10 1 = 0; l10 n = 10 + l10 (n `div` 10000000000) } in l10 . bproduct $ [1..100000]
21:55:26 <lambdabot> Terminated
21:55:30 <Pseudonym> Hmmm.
21:55:40 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 : bip xs; bip xs = xs; l10 1 = 0; l10 n = 12 + l10 (n `div` 1000000000000) } in l10 . bproduct $ [1..100000]
21:55:45 <lambdabot> Terminated
21:56:00 <Pseudonym> Can't get a better estimate without an integer square root, I think.
21:56:48 <wagle> i suspect its not computing the int until you actually try to decompose it
21:57:03 <Pseudonym> No, the seq would have done the trick.
21:57:15 <Pseudonym> Note:
21:57:34 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 : bip xs; bip xs = xs } in bproduct  [1..100000] `mod` 100003
21:57:36 <lambdabot> 50001
21:57:39 <Pseudonym> Right?
21:57:47 <Pseudonym> That was pretty quick.
21:57:54 <wagle> div
21:58:12 <Pseudonym> I think it's that large integer div is very, very expensive.
21:58:44 <wagle> (the mod is more convincing, since it has to take an int
21:58:49 <Pseudonym> Right.
21:58:50 <wagle> integer)
21:59:00 <Pseudonym> Large integer mod is much cheaper.
21:59:03 <Pseudonym> Than large integer div.
21:59:17 <wagle> but mod would have to look at the entire Integer
21:59:26 <Pseudonym> Yes, that's right.
21:59:30 <wagle> i think
21:59:34 <Pseudonym> But it's a linear algorithm, whereas div is quadratic.
21:59:37 <Pseudonym> I think.
21:59:41 <wagle> ERROR - Garbage collection fails to reclaim sufficient space
22:00:03 <wagle> after maybe 4 minutes on a 1 GRAM system
22:00:10 <Gahhh> 1 gram ?
22:00:11 <Pseudonym> My actual factorial algorithm for the number theory library doesn't use binary product.
22:00:15 <wagle> gig ram
22:00:30 <Pseudonym> Except for small factorials (say, less than 100! or so).
22:00:41 <Pseudonym> @plugs let { bproduct [] = 1; bproduct [x] = x; bproduct xs = bproduct (bip xs); bip (x1:x2:xs) = let x12 = x1*x2 in x12 `seq` x12 : bip xs; bip xs = xs } in bproduct  [1..100]
22:00:42 <lambdabot> 9332621544394415268169923885626670049071596826438162146859296389521759
22:00:42 <lambdabot> 9993229915608941463976156518286253697920827223758251185210916864000000
22:00:42 <lambdabot> 000000000000000000
22:00:49 <Pseudonym> (This is a small factorial.)
22:01:09 <wagle> time for me to go now.. cyall
22:01:14 <Pseudonym> Fare well.
22:02:44 <SamB> hmm, I wonder why explicitly requested specializations get names beginning with $s but automatic ones don't...
22:06:21 * SamB also wonders why he doesn't see inlinings for bip or bproduct specialized for Int or Integer, but he does for the general version...
22:07:41 <SamB> oh, I guess it can use the general inlinings at whatever type it likes, huh
22:08:04 <SamB> also, it calls them Unfoldings
22:10:32 <skew> That's a confusing name
22:11:23 <Pseudonym> Hey, that's bizarre.
22:11:39 <Pseudonym> I have binaryProduct, which is approximately identical to bproduct above.
22:11:41 <skew> It sounds too much like list stuff
22:11:47 <Pseudonym> And I {-#SPECIALIZE#-} it for Integer.
22:11:59 <Pseudonym> But it never actually specialises it!  Not really.
22:12:12 <Pseudonym> It creates a specialised version which passes the dictionary to the general version.
22:12:25 <Pseudonym> Oh, duh.
22:12:28 <Pseudonym> I forgot to -O2
22:12:43 <Pseudonym> Double duh.
22:17:16 <FrederikEaton> i'm trying to fix toast to work with cabal. in general if it sees Setup.hs then it can assume that cabal takes care of everything, right? like even if there is a ./configure then cabal will run it, etc. so all that needs to be done is work through cabal, with "runhaskell Setup.hs configure" etc.
22:23:41 <skew> JohnMeacham: do you know of any techniques for compiling indirect jumps out of strict functional code? Judging by the name GRIN isn't really designed for that case
22:25:15 <MachinShin> night all
22:34:12 <foxy> could someone suggest an sql package that interoperates with postgres and works with ghc 6.4?
22:49:42 <JohnMeacham> skew: the same techniques should apply. you would just have 'apply' functions to inline instead of 'eval' one.
22:50:32 <FrederikEaton> foxy: HSQL or HaskellDB? does HSQL still not work with 6.4? if it doesn't i presume the upgrade shouldn't be difficult
22:59:15 <JohnMeacham> I should say, you would only need to worry about the 'apply' ones. GRIN needs to care about both apply and eval ones.
23:05:58 <FrederikEaton> rederikEaton
23:06:01 <FrederikEaton> oops
23:06:54 <FrederikEaton> misuse of 'screen'
23:15:53 <wilx> Hmm, question about case:
23:15:53 <wilx>     case formal of
23:15:53 <wilx>         [[]]   -> return $ if hasParens then Just [[], []] else Nothing
23:15:53 <wilx>         [args] -> return $ Just [[], args]
23:15:54 <wilx>         [_,_]  -> return $ Just formal
23:16:12 <wilx> With code like this, doesn't the [args] case shadow the last one?
23:28:29 <Cale> wilx: args would be the list of length 1 case
23:28:39 <Cale> wilx: and [_,_] is a list of length 2
23:28:42 <wilx> Oh.
23:28:50 <wilx> Indeed.
23:28:57 * wilx dusts of his Haskell-fu.
23:28:58 <wilx> Duh.
23:36:38 <musasabi> morning
