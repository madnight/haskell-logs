00:49:28 <FrederikEaton> can i have strings run across multiple lines?
00:51:45 <wilx> String literals?
00:51:49 <wilx> I don't think so.
00:52:01 <FrederikEaton> that sucks. how am i supposed to write web pages in haskell?
00:53:43 <FrederikEaton> i guess if my editor could format paragraphs of the form 'unlines ["...", "...", ...]'
00:53:58 <FrederikEaton> but it can't
00:57:38 <nibro> FrederikEaton: yes you can, it's called literal gaps in Haskell lingo
00:57:55 <nibro> FrederikEaton: start a string literal with ", then end the line with a \
00:58:33 <nibro> then start the next line with a new \, and all blanks between the two will be removed
00:58:54 <nibro> myStr = "beginning of string that will \
00:59:09 <nibro>          \span multiple lines"
00:59:39 <nibro> but of course if you want to write web pages in haskell, you should use HSP :)
00:59:51 <nibro> http://www.cs.chalmers.se/~d00nibro/hsp
01:00:02 * nibro appologizes for the shameless plug...
01:09:30 <FrederikEaton> nibro: what is your thesis written in?
01:11:49 <FrederikEaton> nibro: you should link to examples from the web page
01:24:35 <FrederikEaton> ((compare EQ .) . compare) == flip compare
01:25:22 <nlv11757_> hey eric meijer, former co-professor at UU :D
01:32:50 <kolmodin> nibro: you have got a copy'n'paste error in the TOC of http://www.cs.chalmers.se/~d00nibro/hsp/
01:36:44 <glimming> how close is this to haskell?
01:36:44 <glimming> http://www.haskell.org/hawiki/RankTwoPolymorphism
01:36:57 <glimming> What is the best example of rank 2 in GHC *today* using its existing syntax?
01:37:08 <glimming> I do not understand the /\ here, i.e. explicit typing isn't supported is it?
01:37:27 <glimming> also, how does rank 2 compare to System F?
01:37:46 <nlv11757_>  /\ is like a normal lambda \ but for type variables
01:37:51 <glimming> Eric Meijer around?
01:38:17 <nlv11757_> it abstracts away a type instead of a value
01:38:32 <glimming> sure, I know System FG
01:38:33 <glimming> F
01:38:34 <glimming> sorry
01:38:38 <glimming> but I do not know rank 2
01:39:53 <nlv11757_> then i guess im not understanding your problem
01:40:10 <glimming> is nlv11757_ = Erik Meijer?
01:40:14 <nlv11757_> hahaha
01:40:23 <nlv11757_> far from close
01:40:29 <glimming> Ok.
01:40:42 <glimming> So my problem is that Rank 2 limits System F somehow for type inf to be decidable.
01:40:45 <glimming> How does it do it?
01:40:52 <glimming> And what is the GHC syntax for explicit types and type app?
01:43:12 <autrijus> hey. how do I read everything from stdin without closing it?
01:43:15 <autrijus> or semi-closing it
01:43:41 <nlv11757_> i wouldnt know enough about the place of rank 2 in type inferencing on the top of my head to answer that glimming, sry.
01:44:20 <FrederikEaton> what do you call something that's like a functor, taking objects of category A to objects of category B, but instead of taking arrows A->A' to arrows B->B' it does the opposite, i.e. takes arrows B->B' to arrows A->A'
01:44:22 <glimming> but the syntax on loc cit wiki page is not correct it says for GHC? so what syntax is used?
01:46:54 <FrederikEaton> glimming: like id :: forall a. a -> a?
01:47:18 <FrederikEaton> autrijus: fdToHandle?
01:49:16 <autrijus> FrederikEaton: hm. I hand hacked a getChar
01:50:02 <glimming> yes, can you give id definitiion for that one?
01:50:05 <glimming> id is not AFAIK rank 2
01:50:09 <glimming> it is just polymorphic
01:50:13 <glimming> but I may be wrong
01:50:27 <glimming> I'd expect    A -> (FORALL B. B -> B) to be rank 2, but why?
01:50:44 <glimming> Or am I missing smthg?
01:52:53 <nlv11757_> glimming, afaik something is rank2 if you have nested foralls like you say
01:52:58 <nlv11757_> top level is rank 1 i think
01:53:01 <FrederikEaton> glimming: i think that's equivalent to (forall b. a->b->b)
01:53:10 <nlv11757_> no thats not true FrederikEaton
01:53:32 <FrederikEaton> what's the difference?
01:53:45 <glimming> count inhabitants.
01:54:04 <glimming> Eaton, do you have a reference to this?
01:54:21 <FrederikEaton> i think you guys are both wrong
01:54:29 <FrederikEaton> ghci says: (const id) :: forall a b. b -> a -> a
01:55:19 <FrederikEaton> no ref just my memory
01:55:35 <nlv11757_> FrederikEaton, the nested forall is different from the top level qualified one
01:56:33 <FrederikEaton> nlv11757_: but (const id) has both types, no?
01:57:00 <earthy> http://www.haskell.org/ghc/docs/6.4-latest/html/users_guide/type-extensions.html#universal-quantification
01:57:55 <FrederikEaton> maybe: rank (f->g) = max (rank f + 1) rank g?
01:58:01 <earthy> (arbitrary rank polymorphism)
01:59:18 <FrederikEaton> but that doesn't look right
02:01:14 <glimming> there is some paper my LÃ¤mmelk
02:01:16 <nlv11757_> glimming, 7.4.9.2. Type inference in that link of earthy answers your question about decidability i think
02:01:17 <glimming> LÃ¤mmel Ralf
02:04:40 <earthy> (the haskell report and the ghc docs aren't all _that_ frightening... why don't people simply browse them?)
02:07:49 <FrederikEaton> yeah, look at http://www.haskell.org/ghc/docs/6.4-latest/html/users_guide/type-extensions.html#hoist too
02:08:23 <FrederikEaton> i think it answers why a->(forall b. b->b) is the same as (forall b.a->b->b)
02:08:47 <FrederikEaton> unless glimming and nlv11757_ still disagree with me on that one
02:10:45 <nlv11757_> why is (forall a . (forall b. b -> b) -> a) /= (forall a b. (b -> b) -> a)
02:11:19 <dons> the scope of b doesn't escape the first argument
02:11:32 <nlv11757_> so its existential?
02:11:42 <dons> it's locally quantified
02:11:56 <nlv11757_> that goes for FrederikEaton's example also
02:12:00 <FrederikEaton> no
02:12:14 <nlv11757_> in (a->(forall b. b->b)) the b doesnt escape either
02:12:24 <FrederikEaton> with (forall a . (forall b. b -> b) -> a) you could pass different types to the first argument
02:13:10 <Lor>  (forall a . (forall b . b -> b) -> a) is isomorphic with exists b . forall a . (b -> b) -> a
02:13:18 <nlv11757_> with yours you could pass different types to the second?
02:13:50 <FrederikEaton> nlv: who could pass different types to the second?
02:14:33 <nlv11757_> why would you be able to pass different types to the first....and not to the second in your example
02:14:58 <FrederikEaton> well it's not even "the second" it's not an argument, it's the return type
02:16:26 <FrederikEaton> you can pass different types in both cases, but only in your case would the function itself do the passing since only in your case is the argument type given a 'forall'
02:16:55 <nlv11757_> ow wait, add another argument
02:17:37 <FrederikEaton> if there is a rank-n type on the LHS of an arrow, then your type is at least rank-(n+1).
02:18:02 <nlv11757_> so forall a. a -> (forall b. b -> b) -> a /= forall a b. a -> (b->b) -> a ??
02:18:25 <Lor> Yes, they are different.
02:18:40 <FrederikEaton> like i guess "forall a. Int -> a" is not even rank-1 polymorphic because only 1 value of a is ever used
02:18:46 <Lor> There is only one function of type (forall b. b -> b), namely the identity.
02:19:00 <FrederikEaton> (or i don't know if that makes sense)
02:19:06 <Lor> OTOH, there are a gazillion different functions of type (b -> b), for _some_ b.
02:19:21 <nlv11757_> so nested universial quantifiers are existential types right?
02:19:26 <nlv11757_> it's been a while for me
02:19:57 <Lor> Well, they can sometimes be encoded as existentials.
02:20:06 <Lor> (Or rather, existentials can be encoded as higher-rank universals).
02:20:25 <FrederikEaton> yeah i don't understand Lor's "(forall a . (forall b . b -> b) -> a) is isomorphic with exists b . forall a . (b -> b) -> a"
02:22:23 <nlv11757_> i understand that 'embedding' a universal type hides the real type, so you know there's one, but can't define one....something like that right
02:24:14 <Lor> \f : Aa.(Ab.b->b)->a . (pack Unit, \\a. \g:b->b. f Unit (\\b'.\x:b.x))
02:24:20 <Lor> That's one direction, I think.
02:25:19 <FrederikEaton> i'm unfamiliar with that syntax
02:26:13 <nlv11757_> A means forall \\ is abtracting type variables no?
02:26:23 <Lor> \(b:*,f:Aa.(b->b)->a). \\a':*. \g:(Ab.b->b). f a (\x:b.x)
02:26:32 <Lor> That's the other direction.
02:26:37 <Lor> Probably some typos, but anyway.
02:26:54 <nlv11757_> it does look rather cryptic :P
02:27:07 <Lor> Aa.t is short for "forall a . t"
02:27:24 <nlv11757_> i think i'll reread that part in TaPL
02:27:29 <Lor> (pack Unit, e) is an existential package.
02:27:44 <Lor> This is not standard syntax, just a concise adaptation.
02:27:57 <nlv11757_> ok call it compression
02:27:57 <nlv11757_> :P
02:28:26 <Lor> Oh, and \(b:*, f:t). .... means that the function takes an existential package and opens the abstract type b and the value f.
02:32:00 <FrederikEaton> you don't seem to use the value of g in the second one
02:33:15 <FrederikEaton> or the first one. i'm confused
02:33:41 <FrederikEaton> Lor: do you have a reference for this?
02:34:49 <Lor> Oops, right, it should be used.
02:39:15 <FrederikEaton> oh, TaPL p. 377 maybe?
02:39:16 <Lor> Hm, actually, neither of those types is inhabited, so this is pretty moot.
02:39:43 <FrederikEaton> how do you prove that a type is uninhabited?
02:40:49 <Lor> e.g. by creating a term of type t->_|_
02:41:49 <Lor> \f: Aa. (Ab.b->b) -> a. f _|_ (\\b.\x:b.x)
02:42:30 <Lor> Since there is a closed term of type Ab.b->b, you can give it to Aa. (Ab.b->b) -> a, so you can get an instance of any type a.
02:46:18 <FrederikEaton> neat
02:48:14 <nlv11757_> struct mystruct { int* f[10][10];} s[10];
02:48:14 <nlv11757_> int main(){
02:48:14 <nlv11757_>   *(s[0].f[0][1]) = 1;
02:48:14 <nlv11757_> }
02:48:18 <nlv11757_> what am i doint wrong here?
02:48:43 <nlv11757_> but offtopic :P
02:48:46 <nlv11757_> but=bit
02:49:08 <nibro> FrederikEaton: the thesis is written in ms word (yeah yeah, I know), and I would link to examples if I had any ;)
02:49:21 <Lor> nlv: you are dereferencing a null pointer.
02:49:29 <nibro> kolmodin: thanks for spotting that :)
02:49:53 <Lor> You need to have some int whose value to set to 1.
02:50:28 <nlv11757_> Lor, but i thought i was giving this pointer to an int a value
02:51:14 <Lor> No, you are dereferincing it with the *.
02:51:31 <nlv11757_> yeah, in order to give it a value...
02:51:37 <Lor> if you want to set the pointer, do e.g. int i; s[0].f[0][1] = &i;
02:51:51 <Lor> No, you are giving the int a value, not the pointer to it.
02:52:09 <nlv11757_> the problem is that there's no space yet allocated for the array then?
02:52:20 <Lor> Your array of pointers is allocated.
02:52:23 <Lor> (statically)
02:52:31 <Lor> But you don't have anything to point to.
02:53:14 <nlv11757_> ow wait, of course...i have a 2 dim array of pointers...just pointers
02:53:40 <nlv11757_> i was thinking like this...i have an array of pointers and now im going to have them point to the value 2....but it has to reside somewhere ofcourse....
02:54:05 <Lor> Yep.
02:54:32 <nlv11757_> ty
02:55:15 <glimming> Eaton, I never said disagree. I just said "count inhabitants"
02:57:42 <FrederikEaton> uh
03:01:37 <FrederikEaton> what's your point?
03:08:20 <FrederikEaton> shapr says he's taking a "code sabbatical"
03:47:11 <nlv11757_> shapr overworked?
03:48:54 <goron> House actually works :D
03:58:48 <Si\> Can anyone think of a good way of defining default method instances for the super class of a particular class? Obviously you can't do it via instance Parent a => Child a, due to overlap, but is there another way?
03:59:08 <Si\> I mean Child a => Parent a rather
04:01:22 <nlv11757_> house works?
04:01:31 <nlv11757_> in what way goron :)
04:06:13 <nlv11757_> using literate style programming works so well. I document 200% more and my code is so much better maintainable (for myself anyway).
04:22:47 <basti_> hi
04:23:02 <nlv11757_> oi
05:03:16 <othernoob> hey, does anyone here use Ubuntu ?
05:09:30 <othernoob> does anyone use linux at all ?
05:09:45 <xs> yes
05:09:59 <Lemmih> I think most Haskellers do.
05:10:26 <othernoob> heh, so, does anyone of you use Ubuntu ? ;)
05:10:45 <Lemmih> Nope, I'm a Debian guy.
05:12:19 <othernoob> mmh Lemmih, do you use ghc or hugs ?
05:12:26 <Lemmih> Both.
05:12:32 <Lemmih> Mostly GHC though.
05:13:25 <nlv11757_> i recently stepped to debian
05:13:51 <nlv11757_> although i still didnt manage to compile a new kernel :P still getting panics a lot
05:14:28 <othernoob> Lemmih, i assume you downloaded the ghc 6.4 for generic linux ?
05:14:45 <Lemmih> Yeah.
05:15:34 <othernoob> uhm, how do you install that ? .. i use fc3 at the moment and am still new to linux :/
05:16:12 <thebug> othernoob: isn't there a readme with that?
05:16:16 <Lemmih> ./configure && make && sudo make install
05:17:00 <othernoob> thebug: possibly, but i dont have the bandwidth to download 22mb just to see if a readme is in the tar.bz2 ;)
05:17:19 <othernoob> Lemmih: thanks
05:17:36 <Lemmih> Isn't there an Ubuntu package for GHC 6.4?
05:18:07 <othernoob> cant find one on the ghc site..only fedora and redhat
05:26:21 <Lemmih> dons: ping.
05:38:39 <Igloo> JaffaCake: Is this patch going to need a full rebuild, or can I get away with just make clean in the RTS then make?
05:39:32 <JaffaCake> you need to rebuild the libraries, but it'd be good to just rebuild the RTS first and see if it fixes the crash in stg_gc_ut (it'll probably move the crash elsewhere)
05:40:56 <Igloo> OK, thanks
05:42:15 <machack666> Hi.  In my program I'm trying to write a datatype which can take multiple types of values, including a list of values of this same type.  Understandably, ghc complains about infinite datatypes.  Is there some way to get the type system to treat a list as an opaque values, but have the runtime system operate on the value like it was an actual list?
05:42:30 <machack666> (I've taken a look at Data.Tree, and I don't think it's what I need)
05:44:15 <basti_> hmm
05:44:24 <TheHunter> two options:
05:44:24 <basti_> machack666: lets make this clear...
05:44:26 <basti_> oh
05:44:56 <TheHunter> either something like data U = Int Int | Char Char | List [U], or Data.Dynamic.
05:45:23 <basti_> hmm and then there's existential types
05:46:16 <machack666> TheHunter: I'm currently trying to do something like the first option
05:46:24 <TheHunter> Data.Dynamic uses existentials under the hood.
05:46:40 <machack666> My problem is that I need to represent data types which do not yet have haskell primitives associated with them
05:46:44 <basti_> i see
05:47:01 <basti_> machack666: hm?
05:47:03 <TheHunter> @docs Data.Dynamic
05:47:03 <machack666> so I've been using a parameterized data declaration
05:47:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Dynamic.html
05:47:22 <basti_> thats good.
05:47:36 <TheHunter> well, dynamics are pure evil, imo.
05:47:42 <basti_> -g-
05:47:46 <ozone> machack666: C types, you mean?
05:47:48 <nlv11757_> too bad the world is dynamic :P
05:47:50 <machack666> thanks for the info
05:48:11 <machack666> ozone: I'm writing a PDF parser as my first self-assigned "real" haskell program
05:48:14 <basti_> TheHunter: you think existential types are bad?
05:48:19 <basti_> machack666: :-O
05:48:51 <TheHunter> existentials are often ok.
05:48:52 <ozone> machack666: go on
05:48:57 <machack666> they have things like data streams which (as far as I'm concerned) are really compound objects
05:49:36 <ozone> sounds somewhat similar to a problem i'm working on, but again, go on
05:49:58 <TheHunter> basti_, the evilness lies in Typeable.
05:50:09 <machack666> so, while the stream is serialized as a string (obviously), each stream includes a dictionary with information about it which is parsed separately and is referenced as an indirect reference with its own syntax
05:50:21 <basti_> TheHunter: yes types at runtime are debateable at least.
05:50:36 <machack666> dictionary can have arbitrary keys and values, including other dictionaries and arrays
05:50:48 <xerox> hi.
05:50:53 <TheHunter> hey xerox
05:51:15 <ozone> TheHunter: you'd prefer statically typed runtime metaprogramming?
05:51:16 <machack666> I was hoping to use Data.Map as the type for the dictionaries and the built-in list support as emulating the arrays
05:51:39 <machack666> but I need a unifying datatype to get the list to function as haskell expects it to
05:52:00 <basti_> hmm
05:52:19 <ozone> machack666: hmm, OK.  if you know all the possible types that can go into these dictionaries, probably the best approach is is to existentials
05:52:29 <ozone> with one data constructor for each type
05:52:30 <basti_> as TH said... there's basically two approaches: first you can make the datatype decide which type is inside a value, and then you can use existential types
05:53:00 <ozone> what am i talking about, not existentials.  what TH said, rather
05:53:10 <machack666> so in the case of more complicated structures such as the stream, I've been trying to treat the value as opaque: i.e. "data PType a b c = PBool Bool | PInt Integer | PArray a | PDict b | PStream c | ... etc
05:53:48 <TheHunter> ozone, i prefer as little runtime metaprogramming as possible, but in case it is needed, it should be as statically typed as possilbe.
05:53:55 <basti_> machack666: the variables in there are not very useful, but certainly this is possible.
05:54:22 <machack666> I'm certainly open to suggestions about a better way to do it...:)
05:54:39 <basti_> machack666: do you know which types you are going to need?
05:54:50 <ozone> TheHunter: well, while i agree dynamics are somewhat evil, they're a pretty necessary evil.  so, in the abscence of dynamics, i was wondering if you had better ideas for their replacements
05:55:11 <machack666> there are 8.  I believe I need to keep them as distinct types because of their serialization requirements
05:55:51 <basti_> machack666: well if the number is static, and you do know which type you want to reflect each in in haskell, why dont you just use a datatype without variables
05:55:58 <basti_> and synonyms for the types themselves
05:55:58 <ozone> machack666: not that i know much about what you're trying to do, but that doesn't seem true to me
05:56:02 <TheHunter> ozone, you have an example where you consider them absolutely necessary?
05:56:20 <basti_> as in "type Hash = Data.Builtin.Hash" then "Data Foo = Bool Bool | Hash Hash | ..."
05:56:25 <FrederikEaton> how do i use runProcess to send input to a process? do i have to call createPipe and then wrap the fds it returns in handles or is there an easier way?
05:56:45 <ozone> machack666: serialising a single type doesn't mean that every data constructor for that type has to have the same serialisation structure, if that's what you're thinking
05:57:03 <basti_> though, if this is encouraged by pdf (I don't know if it is), i would reflect the structure of the pdf itself inside the datatype
05:57:15 <ozone> TheHunter: type-safe communication, say.  or dynamic loading.  in a more broad sense, any ninja-fu that you can do with hs-plugins
05:57:35 <machack666> ozone: that's been the approach I've been (planning on) taking.  I'm still working on the parsing phase
05:58:37 <machack666> I need to distinguish internally between a vanilla string and a name, as they will have different syntaxes when serialized
05:58:40 <machack666> for instance
05:59:09 <basti_> you should do that, definitely, then
05:59:09 <ozone> machack666: well, basically, if you know exactly how many different types of vales you want to stick into the dictionary, use an algebraic data type like TheHunter recommended
05:59:43 <ozone> the weakness of algebraic data types is that you can't extend them with more constructors later, but that's not a problem if you know exactly how many constructors you need
06:00:15 <machack666> ozone: for the time being, this is a fixed domain
06:00:22 <ozone> well, there you go then :)
06:00:55 <machack666> as far as primitives are concerned, anyway.  I haven't gotten to any semantic parsing yet.
06:01:38 <machack666> ok, thanks for the pointers everyone
06:02:14 <TheHunter> ozone, ok, they're somewhat necessary in those cases. But even there, after you've converted them to "statically typed" values, you should never use dynamics again.
06:02:43 <ozone> TheHunter: agreed
06:03:05 <ozone> but they're essential to write extensible programs
06:03:34 * basti_ thinks, existentials might be the only thing essential to dynamic programs
06:03:43 <basti_> or extensible
06:03:54 <TheHunter> ozone, i'm not sure about that.
06:04:13 <TheHunter> you should always try to replace them (at least with existentials).
06:04:30 <ozone> quite possibly
06:04:41 <basti_> haskell doesn't have a clear idea on how to be dynamic though... or, so it seems to me
06:04:43 <ozone> i've never needed to use a Dynamic before
06:04:55 <ozone> existentials, though, i use liberally
06:05:02 <ozone> basti_: talk to dons some time :)
06:05:03 <basti_> really?
06:05:07 <basti_> ozone: :P
06:05:27 <basti_> i know there's helpers...
06:05:41 <basti_> but to me it seems more like a wart than an intended feature ;)
06:05:49 <ozone> don's done amazing stuff with hs-plugins
06:05:59 <TheHunter> for example lambdabot had a FiniteMap Module Dynamic keeping the modules' state. The solution we're using now, using IORefs and existentials seems much nicer.
06:06:01 <basti_> i know, hs-plugins is fun
06:06:11 <ozone> now the haskell community is going to learn that writing extensible programs is really hard
06:06:31 <ozone> TheHunter: yeah
06:06:31 * TheHunter didn't manage to compile the latest hs-plugins snapshot :(
06:06:35 <basti_> TheHunter: can you explain what you mean with "IORefs and existentials"?
06:06:46 <TheHunter> @versino
06:06:47 <lambdabot> lambdabot 2p463, GHC 6.4 (OpenBSD i386)
06:06:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:06:47 <ozone> TheHunter: i guess, i should probably say that i consider existentials to be a form of dynamic typing
06:06:53 <basti_> hmm
06:07:01 <xerox> Yay, so you added mistyping-autocorrection!
06:07:10 <TheHunter> dons did.
06:07:13 <TheHunter> @karma+ dons
06:07:14 <lambdabot> dons's karma has been incremented
06:07:16 <xerox> @karma+ dons
06:07:17 <lambdabot> dons's karma has been incremented
06:07:34 <xerox> @karma xerox
06:07:35 <lambdabot> You have a karma of 0
06:07:45 <xerox> gee.
06:07:58 <TheHunter> basti_, look at "the module type class" in Lambdabot.hs
06:08:15 <basti_> i'm already darcs getting it
06:08:34 <basti_> darcs still doesn't flush its buffers!
06:08:52 <TheHunter> the class not only specifies the module, but also the type of the state the module wants to keep.
06:08:54 <Igloo> Flush what buffers?
06:08:54 <basti_> (it doesn't display dots while downloading on my system)
06:09:13 <xerox> (it doesn't too on mine)
06:09:18 <basti_> Igloo: i say "darcs get" and it mumbles 10 minutes or more, and then it outputs a LOAD of dots
06:09:21 <Igloo> Oh, to compensate for that change in ghc 6.4 you mean? OAIC?
06:09:42 <basti_> TheHunter: hmm.
06:09:46 <xerox> 465 patches... wee.
06:09:47 <Igloo> Hmm, perhaps that is just when a program finishes
06:09:48 <basti_> TheHunter: that sure seems like a good idea.
06:10:01 <TheHunter> readMS/withMS is all modules need to do to access there state
06:10:14 <ozone>  that statement :)
06:10:17 <basti_> Igloo: darcs needs a call to flush the buffers after each ".", nothing more, nothing less...
06:10:17 <TheHunter> (ModuleT it uses implicit params under the hood)
06:10:20 <ozone> though i do definitely regard them as a form of dynamic dispatch
06:10:44 <ozone> err, rather, thehunter: i retract that statement about existentials being a form of dynamic typing
06:10:52 <Igloo> Hmm, the code is   do putStr "."\n   hFlush stdout  in darcs-unstable at least
06:10:54 <ozone> anyhoo
06:11:11 <Igloo> What version of darcs do you have?
06:11:13 <basti_> Igloo: maybe it's just my version then
06:11:23 <basti_> 1.0.2
06:11:33 * xerox too
06:12:08 <Igloo> That has the same code
06:12:18 <basti_> TheHunter: this is extremely clean
06:12:34 <TheHunter> ozone, yeah, existentials can be very OO-like.
06:12:46 <basti_> Igloo: bizarre
06:13:27 <TheHunter> in fact, i think lambdabot's module stuff is a pretty direct translation of OO concepts into haskell.
06:13:32 <bourbaki> moin
06:13:37 <TheHunter> moin
06:13:42 <basti_> hi
06:14:06 <TheHunter> basti_, still the Lambdabot.hs module needs to be seriously refactored...
06:14:39 <saynte> Hello all, does anyone have any experience with trying to use the FFI on frustrating C code?
06:14:48 <basti_> TheHunter: yes.
06:17:49 * basti_ will work a little at yi first, though
06:18:29 <Lemmih> Frustrating C code?
06:18:46 <nlv11757_> wow Lemmih just read my mind
06:18:56 <basti_> lol i also was wondering
06:19:07 <saynte> Heh. Well, it has an odd interface.
06:19:13 <basti_> decide not to comment on it though... maybe some more information will reveal what this is about ;)
06:19:20 <nlv11757_> i was thinking about some frustrating C code just when Lemmih said that
06:19:32 <basti_> which C code is NOT frustrating?
06:19:37 <nlv11757_> good one
06:19:42 <saynte> well, some is less frustrating than others ;)
06:20:01 <basti_> nlv11757_: as in "daylit night"?
06:20:04 <basti_> =)
06:20:08 <wilx> Hmm...
06:20:17 <nlv11757_> here this, a pointer gets passed to a function, but first they add an offset to it....how am i every going to find out if this is safe for multithreading lol
06:20:26 <wilx> My C code ain't frustrating! :))
06:20:56 <saynte> but anyway, basically it's a relation calculator. but it returns pointers, so what i'm wondering is, if i want to make my own Relation type from it... how do i make it as 'haskelly' as possible?
06:21:22 <basti_> saynte: whats a Relation supposed to keep? A relation in the Mathematical sense?
06:21:23 <saynte> and by that i mean, staying out of the IO monad
06:21:42 <saynte> basti_: yep, those sorts, this is a mandate from higher-up to keep the relation operations speedy
06:21:52 <basti_> hmm.
06:22:23 <basti_> this is ill-defined i think ;)
06:22:27 <basti_> but nevertheless.
06:22:37 <basti_> The obvious approach would be a function a->a->Bool
06:22:55 <basti_> how large are these relations?
06:23:06 <basti_> 100 members? 10000s? billions?
06:23:52 <saynte> i have no clue :)
06:24:05 <saynte> but it would be nice if they COULD be upwards of 10000 i suppose
06:24:49 <basti_> for example there might be a setting with small relations being really quick, and when these are the bulk of the operations, then i would head for the small->fast approach
06:25:32 <basti_> OTOH, if the relations are large, or even grow larger at runtime, this would rule out the trivial solutions
06:25:37 <saynte> small and fast being: keep it in haskell and out of C ?
06:26:02 <basti_> well or, use a trivial C implementation maybe
06:26:08 <basti_> table or something
06:26:35 <saynte> hmm. well i've been handed a c-implementation of something that i've been advised to use.
06:27:25 <saynte> and apparently it's fast because it uses (yet another c library) BDDs for it's calculations
06:27:45 <basti_> bdd?
06:27:55 <saynte> binary decision diagram, i don't really know much about those
06:28:12 <basti_> maybe youre in the wrong channel... ;)
06:28:15 <basti_> sounds a bit like prolog
06:28:16 <saynte> :)
06:28:26 <saynte> believe me... it's gotta be haskell :)
06:28:39 <basti_> what a luck that haskell speaks a little prolog too ;)
06:30:08 <saynte> heh
06:30:09 <basti_> if someone believes that using something like BDD (which to me seems to be like relation calculus) pays off, then he sure believes the numbers are rather large
06:30:54 <basti_> probably you're heading for backtracing?
06:31:02 <saynte> backtracing?
06:31:07 <basti_> hmm.
06:31:24 <basti_> do you know the 8-queens problem?
06:31:42 <saynte> oh, yeah i think so. a ways back i think i read a monadic tutorial using that as an example
06:31:55 <basti_> this is usually done with backtracing
06:32:01 <saynte> tutorial explaning monads. i suppose the tutorial itself wasn't monadic :)
06:32:04 <saynte> right, gotcha
06:32:18 <basti_> "put a queen on the board, repeat. if there is no space left but queens left, then go back until you find another spot to put a queen on"
06:32:55 <basti_> probably a similar alogrithm will happen to you?!
06:33:27 <saynte> you mean in the BDD sense?
06:33:59 <saynte> i'll be honest, these were sort of dropped in my lap, i've been trying to just get away using the libraries without learning more than i have to about them.
06:33:59 <basti_> well apparently BDD does some of that yes
06:34:18 <basti_> (a part of the actual backtracking)
06:34:25 <basti_> (the main part to say)
06:34:27 <saynte> ahhhhh
06:35:01 <basti_> i never heard BDD before you mentioned it, but to me that seems a lot like the "table algorithm" in prolog
06:35:45 <saynte> well, lets just suppose i have some interface to a C library. and it deals in pointers, is there a nice way to cram that into a haskell type without the use of the IO monad?
06:35:55 <basti_> no.
06:36:03 <basti_> at least i do not believe so.
06:36:42 <basti_> well you can use "unsafe" things
06:36:47 <basti_> but thats... disgusting.
06:36:57 <saynte> unsafe like unsafePerformIO ?
06:37:03 <basti_> yes
06:37:15 <basti_> but thats black magic.
06:37:17 <saynte> i played with that a little.
06:37:20 <saynte> yeah, it seemed as much
06:37:58 <basti_> it will, too, stain your haskell code and it will never get clean again ;)
06:38:51 <basti_> ahh.
06:38:59 <basti_> i found a descrption of BDD's
06:39:17 <Igloo> JaffaCake: Hmm, still getting a SIGBUS in stg_gc_ut
06:39:37 <basti_> saynte: so the requirements are: in haskell, damn quick?
06:39:51 <basti_> or are the requirements, "do BDD in haskell"
06:39:57 <saynte> saynte: essentially, and possibly "Use these libraries in C"
06:40:04 <saynte> it's not even BDD
06:40:22 <saynte> it's just relations, but the relation package that has been recommended uses a BDD package to speed things up (as i understand it)
06:40:35 <basti_> hmm
06:40:52 <basti_> a BDD package won't make any sense until you get input in BDD form
06:40:57 <basti_> unless
06:41:41 <saynte> suspense
06:42:03 <basti_> huh?
06:42:04 <basti_> =)
06:42:41 <saynte> lol, the last word you said was 'unless' now i realize it was a correction :)
06:42:47 <saynte> so i thought there was more coming :)
06:43:04 <basti_> ahh
06:43:04 <basti_> lol
06:43:06 <basti_> ok
06:43:11 <basti_> no there wasnt
06:43:25 <basti_> the hard part is getting a relation into BDD form AFAICS
06:43:45 <basti_> (probably that is even a non-P task)
06:43:47 <saynte> yes, tha'ts what it seems, the library does all that heavy lifting, which is nice. i may have to mangle the library around in c a little
06:44:12 <basti_> but if you DO have a BDD form, the actual implementation doesnt matter lots i'd say
06:44:29 <basti_> (except for you're planning to evaluate the function a million times)
06:46:17 <saynte> hmm, if the data weren't a ptr would that work better? i mean if i weren't asking for references from C and just the structs, would that help the translation to haskell?
06:46:41 <basti_> hmm thats quite hard to say.
06:46:48 <basti_> i do not see an inherent problem in pointers
06:47:04 <basti_> (besides the pervert things C programmers do with them)
06:47:32 <saynte> lol
06:47:38 <basti_> they'll probably be a few bits of data to the haskell side
06:48:01 <basti_> not more... just an integer with special semantics
06:48:58 <saynte> http://www.informatik.uni-kiel.de/~progsys/relview/KURE/kureLib.h
06:49:03 <saynte> that's the interface i have now
06:49:45 <basti_> mmm basically the pointers are used as call-by-reference semantics
06:49:53 <basti_> (so that functions may manipulate their arguments)
06:50:02 <saynte> yep
06:50:19 <basti_> hmmm I'm not profound in FFI, but I would guess there's two approaches
06:50:27 <basti_> or no three
06:50:36 <basti_> 1) doing all the dirty work in haskell
06:50:54 <basti_> 2) wrapping the lib in something sane (a wrapper that just handles a single relation or something), then wrap that in haskell
06:51:23 <basti_> or 3) using a monad to care about the state
06:51:36 <basti_> (which may or may not include the IO Monad)
06:51:45 <saynte> oh right, just a sec, remembering something new....
06:51:55 <saynte> i was also advised that the use of the ST monad may be needed/useful
06:52:03 <basti_> hmm
06:52:32 <basti_> well
06:52:41 <basti_> thats true afaics.
06:52:46 <basti_> it might be either needed or useful.
06:52:47 <basti_> ;)
06:52:49 <basti_> or not.
06:52:49 <basti_> ;)
06:53:06 <basti_> no but honestly, probably doing that stuff in a monad is a good way
06:53:08 <saynte> the one technique i was going to use was have a concrete representation in haskell, then let the relational library do all the math-stuffs.
06:53:31 <basti_> whats the problem with monads?
06:53:46 <saynte> nothin :) just don't know how their usefulness applies here, that's all :)
06:53:56 <basti_> oh a monad will take care for you.
06:54:01 <basti_> that you don't drop your state or something
06:54:19 <saynte> ohhh, will it hold me close and tell me everything is ok? because sometimes i need that :)
06:54:25 <basti_> yes kinda.
06:54:41 <basti_> the problem is that you might have to do some plumbing work first
06:55:00 <basti_> but luckily, for example the ST monad keeps an arbitary state for you
06:55:40 <basti_> the IO monad could do the same, via memory access
06:55:44 <saynte> hmm, i also don't know how to use ST. i looked at the hierarchal library info on it and it seemed sparse
06:56:09 <basti_> hmmm IIRC you've got to declare something a processeable state
06:56:18 <basti_> maybe a collection of C pointers and whatnot
06:57:13 <saynte> hmm
06:57:58 <basti_> I'm just reading up some stuff about that
06:59:33 <basti_> hmm
06:59:42 <basti_> I'm not clear on that, but:
07:00:14 <basti_> There seems to be "State x y" which is a monad that hides a state of type x, and delivers a result of type y
07:00:39 <basti_> but i remember hazily some monad called "ST". I do not know what that would be or why.
07:01:03 <basti_> http://haskell.org/hawiki/StateMonad
07:01:13 <basti_> State can even wrap IO which could make even more sense for you
07:01:44 <xerox> Wrap IO? Do you mean you can do IO inside State without getting IO out if it back?
07:01:50 <basti_> xerox: no way!
07:01:55 <saynte> sounds like voodoo again :)
07:02:03 <basti_> xerox: you just may perform IO while inside the "State" monad
07:02:17 <basti_> saynte: can you give a typical type (heh) of one of your calls?
07:02:43 <saynte> the calls into the relation library?
07:02:47 <basti_> yes
07:02:51 <basti_> their type signatures
07:03:22 <saynte> ok, in some order (as a direct translation) KureInit :: IO(Ptr RelManager)
07:03:56 <basti_> not all of them, just 2 or 3 ;)
07:03:59 <saynte> KureNewRel :: Ptr RelManager -> CString -> Int -> Int -> IO(Ptr Relation)
07:04:23 <saynte> KureRelSetBit :: Ptr RelManager -> Ptr Relation -> Int -> Int -> IO(Int)
07:04:29 <basti_> thats enough i think.
07:04:31 <basti_> k
07:04:38 <saynte> yeah, this library wants to name all the realtions too
07:04:43 <saynte> that's where the c-string comes in
07:04:44 <basti_> poor thing.
07:04:45 <basti_> ;)
07:04:48 <saynte> yes, lol
07:04:56 <basti_> no but...
07:05:04 <saynte> but i looked around and i think i can bypass that
07:05:21 <basti_> 1. are you sure that you actually return all arguments returning values?
07:05:25 <basti_> (call by reference!)
07:06:34 <saynte> urk?
07:06:44 * autrijus suddenly realised that oleg's Zipper ContT thing can be made to implement SubEthaEdit-like stff
07:06:47 <basti_> well for example there is some ominous RelManager
07:06:51 <saynte> righto
07:07:17 <basti_> but this is a bad example.
07:07:17 <basti_> ;)
07:07:22 <basti_> there is some Kure_Rel
07:07:40 <basti_> you do something to it, and it's different then
07:07:54 <basti_> so you need to keep track of that: your function will need to return a Kure_Rel
07:08:19 <saynte> right
07:08:40 <basti_> otherwise noone will know there is a ominous thing outside the haskell world which always changes state
07:08:54 <basti_> if you got that, then i would wrap a reasonable subset of things inside a type
07:09:23 <basti_> a RelManager for example, or a RelManager and a single Relation, or more of them, or whatever you deem necissary.
07:09:41 <basti_> then i would write some helpers that do all the state interaction for me (plumbing)
07:10:37 <basti_> and in the end a sensible thing to do might just look like: "do askRel a b"
07:11:12 <saynte> hmm, gosh i'm sorry, i don't understand, heh.
07:11:25 <basti_> did you read that page about the State monad?
07:11:57 <xerox> autrijus, SubEthaEdit-like stuff inside Yi would be THE thing.
07:12:19 <saynte> sorry, i read part of it, but then i started on an email to my boss
07:12:51 <xerox> Anyway we could simply call it collaborative editing.
07:13:19 <basti_> saynte: basically the plumbing can be hidden in the "do" notation
07:14:11 <saynte> in this case, what would we say the plumbing is?
07:15:06 <basti_> "plumbing" would be: a) *keeping* the state between things you do b) changing it in a ergonomical and correct way
07:15:44 <basti_> i.e., when you do 'changeRelation "ancestors" ...' or something, haskell will know that you changed a variable that just isn't reflected as a name, and keep track of this
07:16:26 <basti_> (instead of doing something like (newPtr,result) <- changeRelation oldPtr "ancestors" ...
07:17:05 <saynte> ohhhh i think i'm seeing what you mean now
07:17:22 <saynte> it's going to take a little while to propery sink in, but i think i'm getting there, hehe.
07:17:58 <basti_> basically a State monad will be able to do both of this
07:18:29 <basti_> the monad part will "keep" the state, and you will be responsible the ergonomy (and the correctness of your C interface!)
07:18:33 <saynte> the state portion basically making a unique set of operations on the relation unique elsewhere?
07:19:16 <basti_> uhm
07:19:21 <basti_> hm.
07:19:23 <basti_> no.
07:19:34 <basti_> the state portion keeps a hidden variable.
07:19:53 <basti_> it will force you to make visible where you use this hidden variable
07:20:01 <basti_> it pretends it's value can change
07:20:46 <saynte> i didn't think it was hidden?
07:21:00 <basti_> its not really hidden.
07:21:06 <basti_> you have to feed it in somewhere
07:21:08 <saynte> yeah
07:21:29 <basti_> the user might never see it
07:21:34 <basti_> except in type errors or something
07:21:43 <saynte> right, hm.
07:21:50 <basti_> (which is a good thing)
07:22:06 <basti_> isnt it?
07:22:25 <saynte> i think so...
07:23:31 * Igloo fights GHC's make system
07:36:58 <Lemmih> alexj == Alexander Jacobson?
07:40:19 <boegel> @seen shapr
07:40:20 <lambdabot> I saw shapr leaving #haskell 9 days, 22 hours, 40 minutes and 6
07:40:20 <lambdabot> seconds ago.
07:40:29 <alexj> alexj is alexjacobson
07:40:36 * boegel is starting to fear that we won't see shapr again for months orso
07:40:36 <alexj> yes
07:42:12 <jlouis> he is maybe working
07:42:14 <jlouis> hard
07:42:38 <boegel> he hasn't been gone for this long since I got here
07:43:50 <Lemmih> @seen dons
07:43:50 <lambdabot> dons is in #haskell. Last spoke 5 hours, 32 minutes and 7 seconds
07:43:50 <lambdabot> ago.
07:46:15 <wilx> @seen me
07:46:16 <lambdabot> me has changed nick to metaperler.
07:46:16 <lambdabot> I saw metaperler leaving #perl6 and #haskell 14 days, 15 hours, 36
07:46:16 <lambdabot> minutes and 53 seconds ago, and I have missed 10 seconds since then.
07:46:20 <wilx> lol
07:46:54 <Philippa> boegel: he's off 'til he get a release for FLM. AIUI he's getting reasonably close to that (I've been talking to him on ICQ)
07:46:55 <jlouis> wilx: our seen module is quite clever
07:47:39 <wilx> Well, I didn't expect anybody with nick `me' :)
07:47:52 <boegel> FLM ?
07:48:30 <boegel> wilx: what does it mean, "I have missed 10 seconds ?"
07:48:48 <wilx> I have no idea.
07:49:09 <boegel> lambdabot has been online for 14 days with only 10 seconds of downtime ?
07:49:15 <boegel> @uptime
07:49:16 <lambdabot> uptime: 10 days, 2 hours, 35 minutes and 31 seconds
07:49:41 <basti_> boegel: maybe he was split away
07:49:55 <boegel> apparently
07:50:06 <basti_> Philippa: why is FLM so important to shapr?
07:50:32 <basti_> does he plan to make money on it?
07:50:49 <metaperl_> what is FLM?
07:50:54 <basti_> fermat's last margin
07:51:10 <basti_> a page-annotation-system that shapr is working on
07:51:18 <basti_> a webapp
07:51:20 <basti_> quite practical
07:54:46 <boegel> wtf is neight ? :)
07:55:04 <xerox> "night" :-)
07:55:16 <boegel> it's not right now, is it :p
07:55:26 <basti_> in some parts of the world it is
07:55:48 <boegel> oh, it's right in Dutch too
07:55:50 * boegel blushes
07:56:15 <boegel> usually these things are ment to be pronounced in English
07:57:13 <Philippa> basti_: he wants to get the damn thing done, because he wants to use it
07:57:19 <basti_> ah.
07:57:24 <Philippa> and he's fed up of thinking of it constantly
07:57:34 <basti_> that sounds bad.
07:57:56 <basti_> but i see
07:58:04 <Philippa> well, every time somebody mentions a paper related to another, or a neat idea they had while reading one, or...
07:58:33 * basti_ nods
08:04:32 <Igloo> Hmm, isn't there supposed to be a branch called STABLE of fptools CVS?
08:13:31 <dustin`> If I have overlapping type classes, is there a way to make GHC choose "the most specific" ?
08:14:11 <dustin`> Err, rather.... overlapping instances of a type class
08:16:23 <nlv11757_> i dont know what the default behaviour is when you do -fallow-overlapping-instances
08:17:43 <boegel> are there any people (besides bourbaki), who would like to help coding a 3D modelling program in Haskell ?
08:18:17 <nlv11757_> im still occupied with doom3 in haskell :P
08:18:48 <boegel> nlv11757_: is it working ? :D
08:18:51 <nibro> dustin`: well, GHC is supposed to choose the most specific :)
08:19:07 <nlv11757_> haha surprisingly it's a bit slow :P
08:19:32 <boegel> nlv11757_: the idea is not to be the fast 3D modelling program, but the most elegant (in code)
08:20:56 <pharm> Is there a PDF of the Monad.Reader Issue 2 ?
08:21:09 * pharm likes to read stuff offline...
08:21:21 <dustin`> nilbro: My types must be very complex then... this error looks like Alonzo Church barfed all over my console
08:21:36 <nlv11757_> ok im off, cu all
08:21:57 <basti_> lol
08:22:33 <boegel> pharm: I don't think so, I think it's a mistake too
08:23:03 <TheHunter> for the record, i think it's a mistake, too.
08:23:07 <pharm> boegel: darn
08:23:10 <TheHunter> some articles have pdf/ps versions.
08:23:39 <basti_> at least there could be some printer friendly css
08:43:04 <autrijus> x ¡³ y   -- this works in pugs now via the "fp" module :D
08:45:55 <TheHunter> x i^3 y ?
08:46:29 <autrijus> no, ¡³ as in the unicode function composition
08:46:34 <autrijus> U+25CB
08:47:08 <autrijus> sub infix:<¡³> (Code &f, Code &g) { sub($x) { f g $x } }
08:47:24 <Igloo> You aren't sending correct utf8
08:47:57 <autrijus> sub infix:<â—‹> (Code &f, Code &g) { sub($x) { f g $x } }
08:47:59 <autrijus> hm, still not?
08:48:03 <integral> yeah, that's it
08:48:11 <Igloo> Yup
08:48:25 <autrijus> cool
08:48:53 <jaap> bletch, i still can't see it... but it's in the logs all right
08:49:05 <jaap> cool, anyhow!
08:49:09 <autrijus> :)
08:49:32 <Igloo> Hmm, my gucharmap searching is broken
08:49:38 <Igloo> Eeek, sorry about that
08:50:08 * autrijus goes adding âˆ€ âˆƒ âˆ… Î» etc
08:50:12 <Igloo> Ah, there we go; âˆ˜ U+2218 is "composite function"
08:50:34 <autrijus> hm, I see it defined as "Ring Operator". does it mean composition?
08:50:53 <integral> hmm, that's what I suggested, but some fonts seem to have it raised rather high
08:51:06 <Igloo> "composite function" is one of its alias names according to gucharmap
08:51:36 <Igloo> U+25CB is WHITE CIRCLE
08:52:04 <autrijus> ok, 2218 is correct then. sad, because 25cb looks better.
08:52:38 <TheHunter> 25cb looks wrong here, it's too far left, too low and not really round.
08:52:41 <Igloo> 25CB is far too big in a normal font
08:53:58 <TheHunter> then again, my computer's unicode support is very poor.
08:59:21 <jaap> autrijus: i was trying to get pugs off darcs, but that seems to have been down for a while; is that on purpose?
08:59:42 <autrijus> jaap: no it is not
08:59:48 <autrijus> the machine hosting darcs is down in flames
09:00:06 <autrijus> I'll do a replay and bring it back soon
09:00:09 <autrijus> sorry for the inconvenience
09:00:12 <jaap> i see
09:00:14 <autrijus> <- caught totally unprepared
09:00:32 <autrijus> the sync script that syncs svn with darcs is down too
09:00:48 <autrijus> so for the moment you need to check out via http://svn.openfoundry.org/pugs/ with wget/svn/webdav. sorry
09:01:33 <jaap> no worries; i'm plenty impressed you manage to administer svn so i should be able to at least use it ;-)
09:01:48 <TheHunter> what's with U+2219, it gucharmap renders it as like ten different symbols, depending on the font.
09:02:01 <TheHunter> s/it //
09:02:11 <autrijus> jaap: I have svk with its patch dependency thing ;)
09:02:58 <Igloo> TheHunter: Which fonts is it different in?
09:04:01 <TheHunter> cmmi10 : kappa, cmsy10: <=, msam10: two vertical arrows...
09:04:07 <Igloo> Oh, it is wrong in the tex fonts for me too
09:04:16 <Igloo> I imagine that's becuase they aren't unicode fonts
09:05:21 <TheHunter> probably, but they all have the integral and angle symbols
09:05:55 <autrijus> it looks like a single âˆ™ dot
09:06:08 <CosmicRay> @seen shapr
09:06:09 <lambdabot> I saw shapr leaving #haskell 10 days, 5 minutes and 55 seconds ago.
09:06:19 <Igloo> gucharmap substitutes glyphs from other fonts if they are missing I think
09:06:36 <Igloo> Pressing the right mouse button on them might show you, but it is broken for me
09:07:58 <TheHunter> it's broken for me too, but apparently, i have a slower computer than you, so i can still read it
09:31:02 <bubblesort> hi
09:31:44 <bubblesort> what is the difference between  Â»some_expression where definitionsÂ« and Â»let definitions is some_expressionÂ«
09:32:12 <SamB> bubblesort: where doesn't work on expressions, really
09:32:30 <dcoutts_> bubblesort, often there is not much difference and people write things in both styles according to taste
09:33:24 <dcoutts_> technically, 'let' is part of an expression while 'where' is part of decleration syntax
09:33:48 <bubblesort> oh
09:34:06 <bubblesort> so it is a top-level construct?
09:34:24 <dcoutts_> no, neither are top level constructs
09:35:14 <dcoutts_> if you look at some examples, you'll see how they are both used
09:35:36 <edwinb> "where" gives you local function definitions, "let" binds a variable in an expression. Often it's just a matter of style which you prefer...
09:36:11 <bubblesort> let looks like scheme :)
09:36:18 <edwinb> Euw ;)
09:37:25 <dcoutts_> for example if it makes more sense to you to define named values / functions above their point of use, then use 'let', if it seems better to put them below the place they are used, then use 'where'
09:56:37 <pharm> what's happened to haskell.org?
09:56:59 <Leadhyena> I'm glad it's not just me, pharm
09:57:15 <Leadhyena> wondering the same thing
09:57:22 <pharm> it was there a few minutes ago...I was reading the wiki
09:59:34 <dcoutts_> you can still ping it but all web and ssh connections are refused :-(
09:59:35 <pharm> dcoutts_:that's kind of bad...
09:59:35 <dcoutts_> indeed
10:00:08 <Leadhyena> maybe they're upgrading the site?
10:00:25 <Leadhyena> although I'd think that this would happen at night
10:02:16 <Leadhyena> maybe one of y'all can help me... I was reading about state monads when the site went down
10:02:25 <Leadhyena> and state monads are still clear as mud
10:02:27 <edwinb> What is night on the internet anyway ;)
10:02:38 <Leadhyena> lol edwinb good point
10:03:09 <Leadhyena> I wish to bind a history to a very simple shell I'm writing in Haskell...
10:04:06 <Leadhyena> Should I write an independent monad or use StateT, and if I use StateT how exactly do I use it?
10:04:32 <Leadhyena> discalimer: I'm still a haskell n00b as should be evident.
10:06:03 <Leadhyena> if it makes a diference I'm using GHC 6.4
10:12:45 <Leadhyena> test...
10:13:29 <SyntaxNinja> Leadhyena: C-
10:13:54 <Leadhyena> lol thanks... my laptop has been a little flaky lately
10:14:58 <Leadhyena> but it has helped me in Haskell exposure... been going through the tutorials at a coffee shop nearby. Wonderful how coffee allows the info to sink in
10:15:44 <Leadhyena> anyway I think I may have figured out the StateT thing
10:16:33 <SyntaxNinja> in that case, you're doign pretty well :)
10:16:47 <SyntaxNinja> if you figure out how to strictify the stuff in a StateT monad, let me know.
10:17:05 <Leadhyena> thanks... but I can't claim anything until it actually works...
10:17:35 <Leadhyena> ?strictify? the state in StateT?
10:18:13 <SyntaxNinja> yeah, like seq
10:18:58 <Leadhyena> oh.. man I have a lot to learn
10:19:45 <SyntaxNinja> nah, don't worry about it. seq is an abomination.
10:20:30 <Leadhyena> I'll allay my fears of a lack of aesthetics until I get this shell running the way I want it
10:23:42 <SyntaxNinja> :)
10:25:51 <Lemmih> SyntaxNinja: I've cleaned up HSQL and HaskellDB for release.
10:26:30 <SyntaxNinja> cool
10:26:53 <SyntaxNinja> Lemmih: did you push everythign relevant? upload it to hackage?
10:26:57 <SyntaxNinja> send 'em upstream?
10:27:06 <Lemmih> Not yet.
10:27:53 <SyntaxNinja> nice work.
10:28:07 <Lemmih> @seen bringert
10:28:08 <lambdabot> I saw bringert leaving #haskell 2 days, 2 hours, 31 minutes and 53
10:28:08 <lambdabot> seconds ago.
10:39:07 <shelarcy> $B?2$^$9(B
10:39:11 <shelarcy> $B$*$d$9$_$J$5$$(B
10:39:44 <SyntaxNinja> NO CARRIER
10:39:48 <CosmicRay> heh
10:40:02 <SyntaxNinja> CosmicRay knows what's up ;)
10:40:02 <alexj> is syntaxninja Isaac?
10:40:22 <SyntaxNinja> alexj: ja
10:40:37 <CosmicRay> SyntaxNinja: the hook switch on the other phone? :-)
10:41:52 <alexj> i just replied to your mails, but perhaps we can talk this out live here...
10:43:37 <SyntaxNinja> alexj: looks like the libraries list is down; we can talk here, if you don't mind me being a bit off and on, since I'm at work.
10:43:44 <SyntaxNinja> (but I got your mails because you CCd me)
10:44:18 <alexj> no worries we can talk later if you are busy.
10:44:18 <Lemmih> SyntaxNinja: I've uploaded the packages to scannedinavian.org/~lemmih/packages/
10:44:47 <SyntaxNinja> Lemmih: cool.
10:44:57 <glimming> ObjectCalculus.hs:2:
10:44:57 <glimming>     Failed to load interface for `Method':
10:44:57 <glimming>         Could not find interface file for `Method'
10:44:57 <glimming>         (use -v to see a list of the files searched for)
10:45:01 <SyntaxNinja> alexj: like I said, we can talk here if you don't mind me being a bit off and on.
10:45:03 <glimming> says ghc, but not ghci
10:45:05 <glimming> why?
10:45:08 <alexj> k
10:45:11 <alexj> cool
10:45:21 <Lemmih> glimming: Have you compiled Method?
10:45:27 <glimming> what?
10:45:38 <glimming> is that not automatic?
10:45:44 <Lemmih> glimming: ghc doesn't compile dependencies unless you tell it to.
10:45:48 <glimming> aha
10:47:11 <glimming> --make
10:47:13 <glimming> ok
10:47:22 <SyntaxNinja> alexj: I don't know how to get the information from the .hi files, maybe simon will reply to that once he gets the mail.
10:47:28 <glimming> Is there more I should know, e.g. what are the standard parrameters for efficiency etc?
10:47:45 <Lemmih> hs-plugins includes a .hi file parser.
10:47:48 <alexj> are .hi files a haskell standard or specific to ghc?
10:47:52 <glimming> this did not give me an executable file
10:48:23 <Lemmih> glimming: ghc --make MainModule.hs -o binary
10:48:53 <dcoutts_> SyntaxNinja, one can get info from .hi files by looking at the output of ghc --show-iface
10:49:26 <SyntaxNinja> dcoutts_: tell alexj :)
10:49:31 <alexj> ah cool thanks.
10:49:32 <glimming> does the Main module actually *have* to have the name "Main" ? ;-(
10:49:48 <dcoutts_> it's the text format of the .hi file, normally .hi files are binary. (alexj: yes they are specific to ghc)
10:50:22 <Lemmih> glimming: You can use the --main-is flag.
10:50:59 <dcoutts_> alexj, I beleive that in an early version of the Haskell standard, the .hi format was specified. That is no longer the case, and it allows ghc to stick wadges of information useful to cross-module optimisation into the .hi files
10:51:07 <glimming> why do I get a parse error?
10:51:07 <glimming>     cmdLine :: IO ()
10:51:08 <glimming>     cmdLine = do
10:51:08 <glimming>         inpt <- getLine
10:51:08 <glimming>         if inpt == "q" then
10:51:10 <glimming>             return()
10:51:13 <glimming>             else do
10:51:15 <glimming>                 let newS = getObjString(killBlanks(inpt))
10:51:17 <alexj> hmm, I'd like to keep searchpath relatively general.
10:51:18 <glimming>                 let o = Object "self" (getFunctions(newS))
10:51:21 <glimming>                 putStr (toString(invoke(Obj o, Expr (skipObject(inpt)))))
10:51:23 <glimming>                 putStr "\n"
10:51:25 <glimming>                 cmdLine
10:51:28 <glimming>     main = cmdLine
10:51:34 <SyntaxNinja> glimming: please use the paste page
10:51:43 <SyntaxNinja> @paste
10:51:43 <glimming> ok
10:51:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:51:45 <xerox> ...and less parens, gee :P
10:51:53 <glimming> LISPish not my code
10:52:05 <glimming> student
10:52:09 <alexj> if .hi files are ghc specific, then I assume that I don't have to worry about them if I download packages directly.
10:52:24 <dcoutts_> alexj, the output from  ghc --show-iface varies only slightly between ghc versions, but there's plenty of stuff you want to ignore, epecially if you look at the .hi file for a module compiled with -O !
10:52:43 <Lemmih> glimming: You use an incorrect indentation for your if-expression.
10:53:06 <alexj> I want to be able to obtain the external module dependencies of a package.
10:53:13 <dcoutts_> alexj, not if you intend to recompile the .hs file, then you don't need the .hi, since the .hi is produced as a side effect of compiling the .hs
10:53:14 <Igloo> if expressions don't have indentation rules
10:53:55 <dcoutts_> alexj, the .hi file will tell you which other modules the module in question depends upon
10:54:19 <dcoutts_> at least the modules that ghc though it depended upon at the time that it compiled it
10:55:18 <dcoutts_> I think it may be fully transative too, and may pull include indirect dependencies as a result of cross module inlining
10:56:13 <dcoutts_> I'm not sure if you can find the simple direct dependencies from the .hi, obviously you can get that from the .hs file itself (if you know the module search path)
10:56:23 <alexj> that sounds complex.  it may be simpler to download required packages and operate directly on the source.
10:56:31 <dcoutts_> indeed
10:57:02 <alexj> I'll install the package if required and just query the source otherwise.
10:57:20 <dcoutts_> you can look at hs-plugins for a practical example, it's compilation dependency manager module uses information from the binary .hi files
10:58:28 <alexj> oh, right.  I guess hs-plugins had to implement a lot of the stuff I am doing in SearchPath
11:01:33 <alexj> SyntaxNinja: what was the answer to whether you can do link traversal of packages for non haskell stuff?
11:05:26 <chris2> yrlnry: how is hop conversion going?
11:05:45 <arjanb> is haskell.org down or has my connection a bad day?
11:05:56 <yrlnry> It hasn't really gone anywhere this week.
11:06:37 <chris2> i remember converting the other way round, html->texinfo. that was a mess :)
11:07:22 <chris2> will you publish the latex too?
11:09:18 <SyntaxNinja> alexj: I didn't understand that question
11:09:34 <SyntaxNinja> chris2: I haven't beeng etting libraries@haskell.org emails
11:09:40 <alexj> a cabal package can have C code, makefiles, etc.
11:10:00 <chris2> SyntaxNinja: i'm not subscribed
11:10:21 <alexj> is there a path from a cabal file to all files in the package?
11:10:41 <SyntaxNinja> chris2: I'm saying haskell.org may indeed be down, but I meant to address arjanb. sorry
11:10:51 <chris2> SyntaxNinja: i figured that :)
11:11:17 <alexj> I'd like SearchPath to be able to point at a cabal file in a darcs/svn repository rather than a tarball.
11:11:18 <SyntaxNinja> alexj: c sources, yeah, I don't know what you mean about makefiles. go and read the PackageDescription type
11:11:32 <SyntaxNinja> that'll pretty much answer your questions about what's available.
11:13:39 <alexj> what does "extraLibs" mean?
11:13:48 <Muad_Dibber> someone can point me to a good short parsec tutorial?
11:14:39 <alexj> and why both includes and includeDirs?
11:14:39 <SyntaxNinja> alexj: libraries that ghc needs to link to, for instnace, C libraries like libreadline or something
11:14:58 <alexj> oic  libs are not part of the package.
11:15:55 <alexj> and why both includes and includedirs?
11:17:47 <SyntaxNinja> I think includes are .h files or something
11:17:52 <SyntaxNinja> can't remember offhand.
11:18:08 <alexj> ok but there is also an includedirs?
11:18:11 <Lemmih> Then you can say eg. Includes: SDL.h, IncludeDirs: @get this from sdl-config@
11:19:30 <alexj> ?
11:19:45 <alexj> they are both filepaths
11:20:10 <SyntaxNinja> the FilePath type includes files and directories
11:20:57 <alexj> yes.  but what is being gotten from sdl-config?
11:21:46 <Lemmih> SDL keeps its header files in a separate directory.
11:24:51 <dcoutts_> Gtk and all similar packages do this too, eg $ pkg-config --cflags --libs gtk+-2.0
11:24:51 <dcoutts_> -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/gtk-2.0/include -I/usr/X11R6/include -I/usr/include/atk-1.0 -I/usr/in bla bla bla bla bla bla...
11:25:00 <alexj> ok, but is there a list of header files  or is the assumption that I downloaded the directory?
11:25:13 <SyntaxNinja> alexj: the user's manual (if you can get to it now that haskell.org is down) may also answer some of your questions
11:25:29 <alexj> e..g the context here is that I want to be able to spider an unpacked package on ther internet.
11:26:09 <dcoutts_> I think that will be impossible when it comes to C library dependencies, you'll have to assume the C libs are already installed
11:27:29 <dcoutts_> but where they are installed varies from machine to machine, eg /usr/{lib|include}, /usr/local/{lib|include}, /opt/sfw/{lib|include} etc
11:28:16 <dcoutts_> the package file know where they are because the package file was probably generated on the machine in question and so was able to call sdl-config --cflags or pkg-config or whatever
11:28:26 <alexj> my point is that I want users to be able to publish packages as urls of cabal files in svn or darcs repositories rather than having to build a tarball.
11:29:12 <dcoutts_> but many packages require configuration on the machine they are going to run on to find the location of their deps etc
11:29:21 <alexj> I suppose if you know the URL of the cabl file and know that it is part of a darcs or svn repository that may be enough.
11:30:32 <dcoutts_> yes in that case, you can probably just download the repo and build the cabal package
11:32:11 <alexj> does cabal guarantee that there is only one .cabal file in the root directory of a package?
11:32:50 <dcoutts_> I don't think so, there are plans to have multi-package 'distributables'
11:33:03 <dcoutts_> but at the moment that is true
11:33:14 <alexj> ok then the url will have to be the URL of the cabal file rather than the url of the package root directory.
11:33:25 <SyntaxNinja> alexj: for now, it does guarentee that there's only one .cabal file. in fact, there's a function to go find it.
11:33:41 --- topic: set to 'hmm["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo"]' by Muad_Dibber
11:33:47 <Muad_Dibber> aarrrr
11:33:52 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo"]' by Muad_Dibber
11:33:57 <SyntaxNinja> but that may change in the future. multi-package distributions are high on my todo list.
11:34:09 <Muad_Dibber> what was that?
11:34:44 <Oejet> Muad_Dibber: Your subconciosness.
11:35:35 <Muad_Dibber> hehe
11:36:03 <alexj> ok then I'll assume that pointing at a Cabal file means it is a package in a svn or darcs repo.
11:36:42 <alexj> what is the correct handling for a tarball?
11:38:11 <SyntaxNinja> what's the question?
11:38:52 <alexj> I'd like to be able to handle the case where the URL is of a cabl tarball rather than a directory.
11:39:11 <alexj> when you have multiple cabal files in the tarball, how do you know which one to use?
11:39:27 <SyntaxNinja> for now, only one .cabal file has meaning. in the future, they may be mutually dependent .cabal files
11:39:47 <SyntaxNinja> like multiple packages
11:40:27 <alexj> oic.  ok.  do I just have to search the root directory for a .cabal file or does it have a standard name like root.cabal?
11:41:41 <SyntaxNinja> you have to search for it. cabal has a function for that
11:43:22 <alexj> ok.  do you happen to know its name (or the name of the function that produces a packagedescription)?
11:45:15 <Muad_Dibber> am i the only one for whom haskell.org isnt working?
11:45:29 <SyntaxNinja> alexj: Distribution.Simple.Utils.findPackageDesc
11:45:37 <SyntaxNinja> probably not exposed tot he outside
11:46:26 <alexj> its in the documentation, at least...
11:47:23 <alexj> is Distribution.* intended to be part of Haskell base or is it specific to GHC?
11:48:17 <SyntaxNinja> the cabal package is in the new releases of ghc, nhc, and hugs
11:49:18 <alexj> thats good enough (assuming "the cabal package" refers to Distribtion.*)
12:09:26 <xerox> @seen shapr
12:09:27 <lambdabot> I saw shapr leaving #haskell 10 days, 3 hours, 9 minutes and 13
12:09:27 <lambdabot> seconds ago.
12:10:30 <wilx> I wonder how long can he stand this withdrawal :)
12:21:35 <Leadhyena> I give... can anyone explain StateT to me like I'm a complete moron?
12:23:46 <Leadhyena> how long has the wiki been gone?
12:24:24 <SyntaxNinja> Leadhyena: haskell.org seems to be down
12:24:39 <Leadhyena> the page is back up... just the wiki is gone
12:25:30 <SyntaxNinja> I'm guessing the machine went down and someoen forgot to restart the wiki
12:25:38 <Leadhyena> could be
12:27:47 <Igloo> Leadhyena: Do you know how to use other monads?
12:28:06 <Leadhyena> yeah... just having trouble binding StateT to IO
12:28:54 <Igloo> OK, you use StateT as if it was State, but you can also do IO actions by doing  x <- lift (io action here)
12:29:23 <Igloo> (you may prefer to use liftIO rather than lift)
12:29:51 <Leadhyena> now why do I need the lift? is it because of the difference between StateT etc IO () and IO ()
12:30:27 <Leadhyena> any difference between liftIO and lift?
12:30:28 <Igloo> If you have x <- foo in the StateT St IO monad, then foo must have type StateT St IO t
12:30:43 <xerox> @index lift
12:30:44 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
12:30:44 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
12:30:44 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
12:30:44 <lambdabot> ParserCombinators.ReadPrec, Text.Read
12:30:47 <xerox> @index liftIO
12:30:48 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
12:30:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
12:30:48 <lambdabot> Monad.Error, Control.Monad.List
12:31:05 <Igloo> lift lifts an IO action into a StateT St IO action
12:31:23 <Leadhyena> interesting... lambdabot seems quite useful :)
12:31:27 <Oejet> Leadhyena: When the wiki comes back up, maybe you will find the ImperativeHaskell page interesting.
12:31:29 <Leadhyena> I see
12:31:36 <Igloo> lift always goes up just one level; IO will go through a monad hierarchy until it gets to somewhere it can do IO
12:31:53 <Leadhyena> ah! that's where I messed up
12:32:12 <Leadhyena> I have my shellLoop defined as IO and thought I had to drop down
12:32:21 <Lemmih> Eeek! People are starting to confuse Hackage/cabal-get with SearchPath /-:
12:32:46 <Leadhyena> instead I define my shellLoop as StateT St IO () and lift IO up
12:32:56 <Leadhyena> I get it... thanks a bunch
12:37:19 <viblo> hi
12:37:26 <viblo> anyone here?
12:37:28 <Lemmih> Hey
12:37:38 <Lemmih> Yes.
12:37:42 <viblo> :)
12:37:56 <viblo> I have a little problem with my th-program:
12:38:13 <viblo> parseArgs _ = appT (appT ioType arrowT) ioType
12:38:23 <viblo> where ioType is IO ()
12:38:55 <viblo> but when I try to compile it I get a panic! error from ghc
12:39:29 <Lemmih> With a type-error in it, right?
12:39:48 <viblo> hsSyn/Convert.lhs:(339,8)-(350,91): Non-exhaustive patterns in function
12:40:25 <viblo> what I want is a type IO () -> IO ()
12:40:43 <viblo> (or something a little more complicated..)
12:42:51 <Lemmih> What about [t| IO () -> IO () |]?
12:43:07 <viblo> I want to be able to do different lengths
12:43:45 <Igloo> You mean  appT (appT arrowT ioType) ioType
12:44:29 <viblo> when I try that ghc crashes
12:45:02 <viblo> or maybe it worked now, on the second try :)
12:45:18 <viblo> yeha, thanks!
12:53:05 <Muad_Dibber> hmm
12:53:11 <Muad_Dibber> anyone can help me a bit with parsec?
12:56:27 <Lemmih> Sure
12:57:45 * SamB thinks knuth has forgotten how to do things in ways that are simple...
12:59:05 <Muad_Dibber> arg
12:59:07 <Muad_Dibber> got my problem already
12:59:10 <Muad_Dibber> and its silly
12:59:12 <Oejet> SamB: Thinking of TeX, MMIX?
12:59:13 * Muad_Dibber goes away :P
12:59:42 <Oejet> Muad_Dibber: Have fun.
13:00:24 <SamB> Oejet: I was just looking at how mmixal encodes the symbol table...
13:00:42 <SamB> and yes, MMIX itself is rather complicated.
13:01:37 * Oejet thinks that almost all simple things in the world have been uncovered.  There are only complicated things left to create.
13:02:24 <SamB> well, I mean, he could have done it in a way that a real object file format might...
13:03:26 <Oejet> Nah, why bother, then he'd actually had to read about it. :-P
13:03:36 <SamB> not really.
13:04:15 <SamB> and really, encoding a trie into the object file... that is, like, sick!
13:04:51 <Oejet> What's a trie?
13:05:38 <SamB> I'm not sure, but it looks something like a ternary tree to my uneducated eye...
13:06:54 <SamB> oh, it looks like the full name of the data structure is "ternary search trie"
13:07:17 <kosmikus> tries are search trees that store (values of) keys with a common prefix in a common subtree
13:07:35 * kosmikus hasn't looked at MMIX (yet), though
13:08:52 <SamB> what do they call it when they merge in the corrections from the errata and print fresh copies? a new edition, or a new printing?
13:09:05 <SamB> I guess edition...
13:10:53 <kosmikus> I think there's no clear rule; if there have been major revisions, they definitely call it a new edition, but I'm quite certain that sometimes small mistakes are corrected between printings as well ...
13:13:54 <SamB> Well, I think I'd like to get a copy of the MMIXware book, but it would be like $60 on amazon.com *and* the errata look pretty extensive...
13:16:59 <SamB> and knuth has a lot of nerve not defining any real hardware besides the CPU and expecting someone to write NNIX for him.
13:17:30 <SamB> (or even mythical hardware)
13:19:31 <earthy> samb: hey, mmix already is a whole lot better than MIX was.
13:19:46 <earthy> plus, algorithmics does not need hardware
13:20:12 <SamB> but how am I supposed to write an operating system for it?
13:20:49 <earthy> first, you build a computer using it
13:20:57 <earthy> then, you write the OS for that
13:21:04 <SamB> where am I supposed to get an MMIX cpu?
13:24:42 <SamB> I don't want to learn EE just to write an OS for a computer that was intended to be mythical!
13:24:43 <Leadhyena> SamB: a trie is actually a special type of tree that is used to encode strings for fast search
13:25:25 <Leadhyena> example: if you have this, that and thought in a trie then
13:25:54 <SamB> yeah, I think I figured out how it works...
13:25:56 <Leadhyena> th would be by itself with three branches to is, at, and ought
13:26:19 <Leadhyena> ok... I had seen them before and thought the same thing you thought
13:26:30 <Leadhyena> confused me for a long time
13:26:42 <Leadhyena> they're a real pain to mess with IMHO
13:27:16 <Leadhyena> good luck
13:27:57 <SamB> oh, I don't actually have to deal with mmo files. I have a GNU toolchain built to target MMIX ;-)
13:29:00 <Leadhyena> nice to be able to encapsulate that. Tries can be wicked fast for searches, and that's how you do the Aho search for multiple strings on the same file.
13:30:14 <SamB> just about every object file format out there seems to work just fine with linear-search
13:31:03 <Leadhyena> well... excpey for DNA I'll agree with you :D
13:32:01 <SamB> I didn't mean object file formats to include DNA (or for that matter SREC or DOS EXE or COM or anything like that)
13:32:37 <SamB> where by like that I mean "not supporting symbols"
13:34:32 <Leadhyena> what is DNA but a library file, if you allow me to wax philosophical... There are symbols of a sort.
13:34:51 <Leadhyena> still I agree it's too much work for just a simple compilation
13:38:02 <SamB> and why in the world did he make the instruction for successfull termination come out #00000000?
13:38:18 <earthy> to make null-pointer dereferences painful
13:38:35 <earthy> trust me, you don't want a machine where null-pointer derefs are safe
13:38:48 <earthy> *0 == 0 should not work, *ever*
13:38:57 <earthy> (to put it in C terms)
13:39:20 <SamB> I know, but I don't want a machine where accidentally jumping into nothing results in silent failure
13:39:47 <earthy> why not? it's the safest bet. it won't ruin the machine...
13:40:02 <tuomov>  I just learned yesterday that sizeof(void *) is not necessarily sizeof(void (*)())
13:40:06 <tuomov> C sucks.
13:40:07 <SamB> it should result in noisy but fairly safe failure
13:40:20 <earthy> ah. mkay.
13:40:28 <earthy> tuomov: C is tricky. ;)
13:40:32 <earthy> *very* tricky. :)
13:40:33 <SamB> tumm: they went and made it too general
13:40:45 <SamB> er, s/tumm/tuomov/
13:41:12 <earthy> samb: not so. imagine a harvard-style machine, where code and data live in separate memories
13:41:13 <tuomov> everyone still assumes that fact, though.
13:41:27 <earthy> these memories may well have different address spaces
13:41:33 <tuomov> yep
13:41:46 <earthy> tuomov: everyone but embedded hardware developers ;)
13:41:54 <earthy> (and yes, I've been there ;))
13:41:56 <SamB> I'm not writing code for no harvard architectures!
13:42:11 <earthy> anyway, getting way too late to chat
13:42:25 <earthy> g'night all
13:42:41 <SamB> anyway, I don't care if the memory is the same unless I am actually writing code into memory and expecting it to run...
13:45:53 <SamB> actually, I think they did do that with some PDP-11's... severed/spliced a line somewhere so that code and data areas were seperate, thus increasing the address space to 128KiB...
13:49:13 <tuomov> 8086
13:49:20 <tuomov> code segment and data segment
13:50:14 * stepcut notes that debugging code that uses MonadStateIO inside an Arrow can be a bit confusing
13:50:27 <tuomov> apparently function pointers could be 32bit in some compilers
13:50:33 <tuomov> I remember having to use far* though..
13:51:04 <SamB> tuomov: does anyone actually use 286 or less anymore?
13:51:18 <tuomov> maybe on some embeddeds?
13:51:28 <SamB> well maybe.
13:52:17 <stepcut> palm OS ?
13:53:02 <SamB> palm OS is 68k (possibly with ARM internals) and 32-bit, isn't it?
13:53:54 <ibid> palmos is m68k or arm
13:54:03 <stepcut> I think it has some addressing issues -- like it can't address for than 32k or something...
13:54:13 <SamB> I mean, the cpu might not have a 32-bit data or address bus, but as far as I know the wordsize is 32 bits...
13:54:15 <ibid> though all palmos application software are mk68k (with optional arm libs)
13:57:23 <SamB> my understanding is that many 68ks had 16-bit internal or external data busses and 24-bit address busses...
13:57:36 <SamB> I don't know a thing about dragonballs though
14:08:52 <Roch> I've just heard about the Esther shell and I've seen it mentioned in the logs of this channel.  Is there any code downloadable yet ?
14:11:17 <stepcut>  Roch: is that the clean thing ?
14:11:45 <Roch> yes
14:12:10 <stepcut> dunno
14:12:26 * boegel greets the gang
14:13:04 <Roch> too bad
14:14:05 * Lemmih greets the boegel
14:17:12 <glimming> If someone completes the answers here
14:17:13 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/H4-answer.pdf
14:17:23 <glimming> I will send that person a free copy of Cambridge University Press
14:17:25 <glimming> Haskell Report
14:17:28 <glimming> Book
14:17:32 <glimming> unused
14:17:46 <glimming> hardback
14:18:06 * basti_ detects bribery
14:18:14 <glimming> basti_ is very correct
14:18:19 <glimming> ;-)
14:18:39 * ibid aready has a hardback copy of the haskell _revised_ report :)
14:18:48 <glimming> My course is finished but for curtisity for my students I'd like to have the template solution
14:18:51 <SyntaxNinja> glimming: heh, I think folks who can do that homework already hvave the report
14:18:53 <glimming> This is the revised one
14:18:54 <ibid> or is this some collector's item, haskell 1.0 or so? :)
14:19:18 <glimming> No, the latest version "The Revised Report
14:19:20 <SyntaxNinja> glimming: how 'bout the winner gets a new Haskell standard? ;)
14:19:25 <ibid> b
14:19:33 <glimming> That's also plausible.
14:19:48 <glimming> I have done most of it anyway.
14:19:54 <ibid> how about the winner gets to do the next haskell standard? ;)
14:20:00 <glimming> If someone want to complete it (I'll send LaTeX) that's worth a book to me. ;-)
14:20:15 <glimming> I have to work on my thesis
14:20:16 <glimming> also
14:20:19 <glimming> this was quite hard actually.
14:20:31 <glimming> not a single student could do it.
14:20:38 * ibid needs to work on my dissertation too
14:20:39 <glimming> and the teacher is reluctant to doing it himself. ;-)
14:20:45 <ibid> and plan for next year's fp course
14:20:58 <SyntaxNinja> glimming: you're a TA for this course?
14:21:03 <glimming> I am the teacher
14:21:09 <glimming> main teacher
14:21:11 <glimming> ;-)
14:21:17 <glimming> Ok, so I can do this, and I have almost done it.
14:21:40 <glimming> There are some stuff remaining e.g. carefully proofreading it and also fixing the proof for state monad.
14:21:47 <glimming> Also the proofs for Kleisli and monad laws needs a second go.
14:22:01 <glimming> Clearly this is worth a copy of the revised report since I happen to have two copies anyway
14:22:30 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/
14:22:32 <glimming> is the course
14:22:52 <glimming> In fact, very little is left to do
14:22:59 <glimming> So I am almost giving it away just because I am so lazy.
14:23:15 <glimming> these are the qestions
14:23:17 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=H4.h
14:24:07 <glimming> EOB
14:24:10 <glimming> end of bribe
14:24:37 <ibid> hmm, vegai isn't here
14:24:47 <glimming> why vegai?
14:24:54 <ibid> can't tease him about putting those questions on our next fp course .9
14:25:09 <glimming> in finnland?
14:25:10 <ibid> he might be my ta on the course
14:25:10 <glimming> Were?
14:25:11 <ibid> yes
14:25:14 <ibid> jyvÃ¤skylÃ¤
14:25:22 <glimming> Link?
14:25:31 <glimming> So there is research in Finnland?
14:25:31 <ibid> no link yet to the new course
14:25:36 <glimming> I thought you just made bad phones.
14:25:39 <ibid> on fp? very little
14:25:44 <glimming> ;-))
14:25:51 <glimming> Swedish hostility at it's best.
14:25:58 <glimming> (ice hockey e.g.)
14:26:10 <ibid> my own research, such as it is, is on programming languages more generally
14:26:12 <glimming> Is jyvÃ¤skylÃ¤ north?
14:26:16 <glimming> nice
14:26:17 <ibid> glimming: middle
14:26:18 <glimming> Mine too
14:26:25 <glimming> My girlfriend is from Turku
14:26:48 <jlouis> Turku... where is that in sweden?
14:26:55 <ibid> well, you do know, i hope, that it was finnish hakkapeliittas who won your wars for you back in the day of gustav adolf :)
14:26:56 <glimming> Ã…bo
14:27:01 <glimming> Turk
14:27:03 <glimming> Turku
14:27:06 <glimming> Is in Finland
14:27:07 <glimming> Finnland
14:27:08 <ibid> jlouis: in finland, used to be part of sweden
14:27:12 * tuomov will be moving to jyväskylä, btw
14:27:13 <jlouis> oh, bingo
14:27:20 <marcot> Hello, what's the C function similar to haskell reverse for a string?
14:27:22 <ibid> finnland is german :)
14:27:28 <ibid> marcot: is there one?
14:27:33 <ibid> tuomov: to do what? :)
14:27:35 <glimming> One N only?
14:27:37 <jlouis> marcot: a while loop and pointers
14:27:38 <ibid> glimming: yes
14:27:39 <marcot> ibid: is there not?
14:27:43 <tuomov> ibid: grad. studies
14:27:52 <glimming> Bad Mac OS X spell checker then
14:27:55 <ibid> tuomov: jyu? cool
14:27:58 <ibid> tuomov: which dept?
14:28:05 <tuomov> mit.jyu.fi
14:28:10 <ibid> cool!
14:28:11 <glimming> ibid a URL to your page?
14:28:14 * ibid works there :)
14:28:17 <glimming> MIT wow
14:28:28 <ibid> mathematical information technology
14:28:35 <glimming> Good name.
14:28:37 <ibid> tuomov: which professor have you been in contact with?
14:28:39 <glimming> But bad acronym.
14:28:53 <ibid> glimming: http://www.mit.jyu.fi/antkaij/
14:28:54 <tuomov> my supervisors are kÃ¤rkkÃ¤inen and neittaanmÃ¤ki
14:28:57 <ibid> cool
14:29:06 * ibid works for kÃ¤rkkÃ¤inen
14:29:24 <ibid> of course, i won't speak publicly about neittis :)
14:29:51 <jlouis> Is the Scheme monster still alive up there?
14:29:57 <glimming> mail me at glimming@kth.se ibid
14:30:02 <glimming> I might come visiting
14:30:05 <glimming> or vice versa
14:30:11 <glimming> Keep me updated on your publications.
14:30:17 <glimming> What are you working in at the mo?
14:30:23 <ibid> jlouis: i think that was in hut?
14:30:48 <jlouis> ibid: I cannot remember where it was. Closest thing is: ``somewhere inside finland''
14:30:48 <glimming> on
14:31:14 * jlouis builds nhc98
14:31:25 <ibid> glimming: i'm currently wrestling with something that with luck will become a monograph dissertation
14:31:27 <glimming> isn't that Niclas Haskell Compiler 98?
14:31:29 <glimming> Any good?
14:31:42 <glimming> topic?
14:31:55 <glimming> how many years total + done?
14:32:26 <ibid> glimming: what do you mean?
14:32:44 <jlouis> it is a haskell compiler. Though it does not sport as many extensions as GHC does
14:32:45 <ibid> glimming: too bad the summer school admissions are closed now
14:32:55 <glimming> I ask ibid for research area, planned date for PhD and how long you have worked.
14:32:59 <glimming> And also your salary while we are at it.
14:33:00 <ibid> glimming: they had a couple of cool courses this years
14:33:02 <glimming> Sorry for the intriution
14:33:05 <marcot> Can I compile haskell to c?
14:33:10 <glimming> I just want to learn the finish system.
14:33:26 <jlouis> marcot: Yes and no.
14:33:32 <glimming> try TYPES 2005 in Chalmers and we might meet
14:33:34 <glimming> search web
14:33:36 <glimming> grants available.
14:33:38 <ibid> glimming: the date i have on the official forms is end of 2007
14:33:47 <glimming> 5 years?
14:33:48 <marcot> jlouis: can I get the C code from reverse compiling something for C?
14:33:52 * wli lost 2 disks himself yesterday
14:33:54 <ibid> glimming: i got my masters at the end of 2002
14:34:10 <glimming> 20% teaching?
14:34:10 <wli> it's costing me a small fortune to replace the whole array
14:34:16 <jlouis> marcot: define reverse compiling, please. I am not familiar with that term
14:34:36 <marcot> jlouis: code from reverse
14:35:11 <glimming> what are the best examples of program calc?
14:35:12 <ibid> glimming: 4-5 years is the target time for a phd after masters if doing full-time
14:35:13 <glimming> max seg sum?
14:35:22 <glimming> and you get paid? formal employment?
14:35:36 <glimming> Finland is strikingly similar to SWE
14:35:58 <glimming> language is of course a barrier, but then some significant %age speaks swedish
14:35:59 <tuomov> there's just the language barrier..
14:36:02 <jlouis> marcot: that is easy. Take length of string. malloc() char array of length+1. Walk the source array in reverse and the destination array from the front copying bytes
14:36:16 <glimming> du fÃ¶rstÃ¥r svenska antar jag?
14:36:20 <jlouis> yay!
14:36:23 <marcot> jlouis: ok, I'm doing it right now, thanks.
14:36:25 <jlouis> even I understood that ;)
14:36:39 <tuomov> I don't know what antar means, but yes
14:36:51 <ibid> glimming: i'm an "assistant", which means i'm supposed to be doing mostly my own research and phd studies, and some supporting teaching and some supporting administration
14:36:58 <ibid> tuomov: "assume", i assume :)
14:37:04 <glimming> jag utgÃ¥r frÃ¥n att jlouis i egenskap av att inte vara en svensk medborgare inte fÃ¶rstÃ¥r eller har lust att slÃ¥ upp innebÃ¶rden av detta.
14:37:17 <glimming> Aha.
14:37:23 <glimming> This is some special Suomi thing.
14:37:32 <glimming> In Sweden, Research Assistnat means postdoc.
14:37:42 <ibid> glimming: my salary is something like 2kâ‚¬ gross in month
14:37:43 <glimming> That's a very attractive position at Univ.
14:37:50 <tuomov> in tut.fi research assitant means undergrad..
14:38:01 <ibid> glimming: my actual duties are 50-50 teaching and doing my research/studies
14:38:03 <glimming> That's what we get in Sweden, roughly.
14:38:04 <tuomov> don't know about the rest of finland
14:38:10 <ibid> tuomov: yes, same here
14:38:27 <ibid> i was a research assistant as undergrad
14:38:33 <tuomov> undergrads can also be teaching assistants, but then there's a separate assitant tenure
14:38:38 <glimming> Oh, I have just 20% teaching, giving me an additional year of the PhD (5 years total, finished in two years time now)
14:38:39 <tuomov> I also was
14:38:44 <ibid> not really a tenure
14:39:37 <ibid> there's now a big salary restructuring in the whole finnish university scene, which should up my salary a little
14:40:02 <ibid> in the current system, i get paid based on my title though my actual duties are more than usually required of an assistant
14:40:09 <glimming> jlouis, you don't want the translation but roughly I just managed to write a long sentence in Sweden saying that you won't be able too understand it.
14:40:38 <ibid> that's why i'm hoping the new system will help me :) - it's supposed to be based on actual duties and not formalities like title
14:40:57 <glimming> I am really tired here, time is getting close to midnight.
14:40:59 <glimming> Goodnight.
14:41:02 <ibid> tuomov: what brings you to jyu?:)
14:41:03 <glimming> yawn
14:41:15 <jlouis> glimming: jeg forstaar fint svensk. Vi har jo ligget i krig med svensken gennem mange aar tidligere...
14:41:15 <ibid> tuomov: i mean, why jyvÃ¤skylÃ¤
14:41:29 <glimming> jlouis, VAFAN en norrman!
14:41:31 <glimming> ;-)
14:41:44 <jlouis> glimming: dansker faktisk. Taet paa. ;)
14:41:47 <glimming> (PS. Oslo Ã¤r underbart. FÃ¶rlovade mig dÃ¤r nÃ¤r jag var dÃ¤r sist.)
14:41:49 <glimming> Aj.
14:41:55 <glimming> Ã„nnu vÃ¤rre.
14:41:56 <glimming> ;-)
14:41:59 <ibid> glimming: you wanted me to mail you. anything in particular, or just to have a reference email?
14:42:12 <glimming> B'st att jag gÃ¥r och lÃ¤gger mig innan jag sÃ¤ger mer dumma saker.
14:42:21 <jlouis> hehe, good night
14:42:23 <tuomov> well, I'm not really all that interested in continuing at TUT, and being from jyvÃ¤skylÃ¤ it was basically between jyvÃ¤skylÃ¤ and helsinki and I got funding from comas..
14:42:28 <glimming> send me your best desktop background, wjy don't you... ;-)
14:42:41 <ibid> tuomov: cool
14:42:47 <glimming> No, seriously, I don't know.
14:42:48 <ibid> tuomov: when are you moving?
14:43:02 <tuomov> when I find a flat
14:43:04 <glimming> Because of physical locality it is good to have you in my addressbook.
14:43:44 <glimming> You never know what happens, and in Nordic area, excluding Chalmers and Martin-LÃ¶f etc, there is not so many places they do research on programming language theory related things.
14:44:37 <ibid> tuomov: come and find me when you come to the dept next time, yes?:)
14:44:44 <tuomov> ok
14:45:24 <ibid> glimming: sent mail
14:45:29 <glimming> ok
14:45:33 <glimming> let's keep in touch then
14:45:46 <glimming> come to Stockholm and give a seminar. If it's good my dept' will pay your visit.
14:45:52 <glimming> Good night,.
14:45:57 <ibid> theh
14:46:05 * ibid has relatives in stockholm
14:46:09 <ibid> and he went...
14:46:50 * ibid realizes that there is an empty room in this soluasunto
14:46:57 <ibid> of course, i am a very messy flatmate
14:47:51 <tuomov> hmm.. I also have some very far relatives in... uppsala I think
14:48:22 <ibid> my father's two sisters and their families live in sweden
14:48:47 <ibid> my father's mother used to, too, but she moved to pori a few years ago
15:19:15 <Lemmih> @seen nibro
15:19:17 <lambdabot> nibro has changed nick to nibro_afk.
15:19:17 <lambdabot> nibro_afk is in #haskell. Last spoke 7 hours and 24 seconds ago.
15:20:11 <wilx> @seen wilx
15:20:12 <lambdabot> You are in #haskell. Last spoke just now.
15:20:14 <wilx> :)
15:23:06 <SyntaxNinja> heh
15:23:17 <autrijus> @seen lambdabot
15:23:18 <lambdabot> Yes, I'm here.
15:23:38 <Lemmih> lambdabot is getting smart.
15:24:04 <SamB> @seen me
15:24:05 <lambdabot> me has changed nick to metaperler.
15:24:05 <lambdabot> I saw metaperler leaving #perl6 and #haskell 14 days, 23 hours, 14
15:24:05 <lambdabot> minutes and 41 seconds ago, and I have missed 10 seconds since then.
15:24:11 <SamB> not very smart
15:24:24 <metaperl> ?
15:24:29 <ibid> @get smart
15:24:30 <lambdabot> smart not defined
15:24:35 <Lemmih> haha
15:24:37 <SamB> @get shapr
15:24:39 <lambdabot> shapr not defined
15:24:43 <ibid> would you believe that? ;)
15:24:57 <ibid> missed it by that much
15:24:57 <SamB> @get food
15:24:58 <lambdabot> food not defined
15:25:12 <SamB> @get bored
15:25:13 <lambdabot> bored not defined
15:28:11 <ibid> @get Ï€
15:28:11 <lambdabot> Ï€ not defined
15:28:24 <ibid> @get undefined
15:28:24 <lambdabot> undefined = undefined
15:28:28 <ibid> hui
15:28:39 <kaol> @moo
15:28:40 <lambdabot>             (__)
15:28:40 <lambdabot>             (oo)    o     /| /|/|_
15:28:40 <lambdabot>            / \/    /    /      _ /
15:28:40 <lambdabot>           /  _\===^   ___\_____/___
15:28:40 <lambdabot>       ___|__/ |/\    (___________(_)
15:28:40 <lambdabot>      *        ^ ^
15:28:43 <lambdabot>  
15:28:44 <lambdabot>             Mrs. O'Leary's Cow
15:29:07 <ibid> aptitude moo
15:29:21 <kaol> There are no Easter Eggs in this program.
15:29:31 <ibid> try with -v
15:29:33 <ibid> and -vv
15:29:34 <ibid> and so on
15:29:50 <ibid> there are even finnish translations
15:30:50 <FrederikEaton> cabal is installing things to be only executable by user, is that a bug?
15:32:21 <SyntaxNinja> @moo This is a test
15:32:22 <lambdabot>       (__)
15:32:22 <lambdabot>       (oo)
15:32:22 <lambdabot>      /'^^^-m
15:32:22 <lambdabot>     / '' ` )
15:32:22 <lambdabot>    |      /|
15:32:22 <lambdabot>    |  |  | |
15:32:25 <lambdabot>    |_____|_|
15:32:27 <lambdabot>     //|| ||
15:32:29 <lambdabot>    *  ww ww
15:32:30 <lambdabot>  
15:32:33 <lambdabot> Cow'nt Dracula
15:33:36 <SyntaxNinja> FrederikEaton: that probably has to do with your umask, I'd guess, since it doesn't do that on my machine.
15:34:22 <arjanoosting> SyntaxNinja: I have go my key signed today, and drift is the debian archive now! :)
15:34:56 <arjanoosting> @moo let me see another cow
15:34:57 <lambdabot>  ____             ____                                |+++++|
15:34:57 <lambdabot> |++++|    ___    |++++|                       ____    |+++++|
15:34:57 <lambdabot> |++++|   |++ ______________________          |++++|   |+++++|
15:34:57 <lambdabot> |++++|   |++/      /( )\           \         |++++|   |+++++|   __
15:34:57 <lambdabot> |    |   |+|      |-oo- |           \______  |++++|   |+++++|  |++|
15:34:58 <lambdabot> -----(__)--|       \__\/           _(__)_  \ --------------------------------
15:34:59 <lambdabot>  o   ( oo /_______________________| (oo)  \ |         __
15:35:02 <lambdabot>  |  _/\_| |  M O O - B U S T E R S|__\/\ /| |        /oo| - Bleaurgh!
15:35:03 <lambdabot>  |-|  \\____                         ------  )_    /|  /\
15:35:06 <lambdabot>   -|_  \_|-_|^^^^^^^^^^^^^^^^^^^^^^^^^^ 0     _|  *  \/  *
15:35:08 <lambdabot>      \  |  __________________________________/
15:35:10 <lambdabot>      |  W|  \ \_/ /----------------- \ \_/ /
15:35:11 <lambdabot>      / /\ \  \___/                    \___/
15:35:14 <lambdabot>     / /  \ \
15:35:16 <lambdabot>     ^^^   ^^^                                      Who you gonna call...?
15:36:10 <SyntaxNinja> my font is aparently no good for moobots, since that looks like junk to me
15:36:21 <Igloo> arjanoosting: Nifty  :-)
15:36:23 <SyntaxNinja> but I did write a program to grab a random cow and pipe the output from fortune to it, does anyone NEED that module?
15:36:27 <SyntaxNinja> arjan yay!!
15:36:38 <SyntaxNinja> arjanoosting I mean.
15:36:50 <SyntaxNinja> it would make a better moo module.
15:37:16 <SyntaxNinja> haha, I just noticed that htere's "cowsay" and "cowthink"
15:37:24 <arjanoosting> SyntaxNinja: could you package it? ;-)
15:38:44 <arjanoosting> SyntaxNinja: have you looked at my haxml packages yet?
15:39:25 * arjanoosting still has to write some manpages for it
15:39:36 <SyntaxNinja> arjanoosting: no, haven't had a chance yet.
15:40:55 <kosmikus> arjanoosting: is that really you? ;)
15:41:13 <arjanoosting> kosmikus: yes it is
15:41:50 <SyntaxNinja> @paste
15:41:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:41:53 <kosmikus> what are you doing these days?
15:41:57 <SyntaxNinja> see that page for the randycow executable
15:41:58 * arjanoosting is reading "Exploring Generic Haskell right now"
15:42:12 <kosmikus> that's a good answer :)
15:42:18 <SyntaxNinja> I shoudl cabalize it so we can have libghc6randycow.a
15:42:39 <Igloo> Yeah, that's what we're really missing  :-)
15:42:53 <SyntaxNinja> Igloo: think we can get it into sarge? ;)
15:43:06 <Igloo> SyntaxNinja: How could sarge release without it?  :-)
15:43:23 <SyntaxNinja> who can hack lambdabot?  we need to add randycow right away
15:44:10 <SyntaxNinja> actually, maybe it's hard because it uses system and pipe
15:44:11 <arjanoosting> Igloo: did you start packaging nhc98 1.18 already?
15:45:27 <Igloo> I think I did a test build of it, but I'll probably start again with the missing hc files in the "upstream tarball" to reduce the pain later on. Why?
15:45:49 * Igloo doesn't plan to do an upload until ghc is sorted as I want nhc built with ghc 6.4
15:46:28 <arjanoosting> just curious, i'm busy packaging haxml with a libnhc98-haxml-dev package but nhc98 already includes haxml IRC
15:46:29 <Igloo> But I think Simon's fix for hppa works, so once my test build finishes it should just be a matter of applying the ia64 fix I have in ghc-cvs, uploading and waiting
15:47:21 <Igloo> Hmm, yes
15:47:28 <foxy> I am stuck.  I need to partially apply functions of (almost) arbitrary type which are loaded at runtime.  Using class Typeable and GADTs doesn't seem to work
15:48:02 <Igloo> I could disable haxml in the nhc deb?
15:48:50 <arjanoosting> well I don't think that's necessary, haxml isn't maintained very actively upstream anyway
15:48:51 <foxy> Is there a way to get the type information of a function and package it with that function and then use that information to cast
15:49:00 <Igloo> (he says looking for a flag)
15:49:17 <arjanoosting> and my packages aren't in the archive anyway
15:49:36 <Igloo> I think it would be preferable if the impls came with the same set of libraries, and the libraries came from the same source for all impls
15:50:44 <arjanoosting> maybe, but I guess the nhc98 guys just took the libraries from haxml upstream
15:50:57 <Igloo> The nhc guys /are/ haxml upstream  :-)
15:51:11 <Igloo> Everything used to come in one bundle, I think, and they're gradually splitting it out
15:51:13 * arjanoosting didn't know that...
15:54:28 <arjanoosting> i am still wondering if I should take some of the improvements Graham Klyne made to haxml and include that in my package...
15:54:53 <arjanoosting> last time i tried to build his version i was missing some other modules
15:54:59 <Igloo> What improvements? It's probably better to stay compatible with everyone else than to make observable changes
15:55:49 <FrederikEaton> SyntaxNinja: umask is 002
15:56:46 <arjanoosting> There is an link on the webpage of haxml to some work of Graham, which should over time be included in the main CVS archive
15:57:04 <arjanoosting> Graham Klyne has extended the 1.12 version of HaXml significantly, in particular to ensure that the parser passes a large XML acceptance test suite, and to deal more correctly with Unicode, namespaces, and parameter entity expansion.
15:58:18 <arjanoosting> But his last changes seems to be from august 2004, so he isn't that active either, so i guess i stick with haxml 1.13 for now
16:02:05 <arjanoosting> SyntaxNinja: you were willing to be my advocate?
16:03:50 <SyntaxNinja> arjanoosting: yeah, I think so. I just have to double-check to make sure I know everything that this entails.
16:04:01 <SyntaxNinja> FrederikEaton: mine's 022
16:04:28 <SyntaxNinja> someone should let me know if my email to the libraries mailing list just now is too harsh.
16:04:53 <Igloo> I was just fighting the urge to reply reply myself  :-)
16:05:32 <SyntaxNinja> I do everythign I can to help AlexJ with his work, and he does nothing but tear down mine.
16:05:37 <SyntaxNinja> I might put him in the bitbucket
16:07:09 <FrederikEaton> SyntaxNinja: so ... ? i'm not masking out exec bits, only write bits
16:07:38 <Igloo> Will you accept "Ian Lynagh (low security foo hackage key)" (not sure if signed or not) into the hackage keyright, BTW?
16:08:24 <SyntaxNinja> Igloo: there are two hackage keyrings.  one of trusted, and one of untrusted keys. hackage will add its sig to the trusted ones.
16:08:40 <Igloo> So the above wouldn't be trusted?
16:09:04 <SyntaxNinja> if it's not signed
16:09:16 <Igloo> What if it is signed?
16:09:34 <SyntaxNinja> trusted keys have an acceptable path from me.
16:09:35 <Igloo> (low security == no password or on a machine where other people have root or both, incidentally)
16:10:10 <SyntaxNinja> I think that's good enough, personally.
16:10:41 * Igloo isn't sure I want to sign such a key, but I'll sign a message saying I made it, which ought to be good enough for your purposes?
16:11:43 <SyntaxNinja> yeah, probably. sign the message with your trusted key, you mean?
16:11:47 <Igloo> Yup
16:12:06 <SyntaxNinja> I'd prefer you use your trusted key, of course, but I think it's good enough.
16:13:08 <Igloo> It'll depend how often I want to update packages, and how often from random other machines
16:13:53 <Igloo> Ah nuts, build fell over
16:14:31 <FrederikEaton> SyntaxNinja: the email seems OK to me
16:15:11 <Igloo> Ah, I didn't update the paths. Oh to be root
16:15:23 <FrederikEaton> SyntaxNinja: although i don't know where i stand on the argument - still haven't looked at gpg. but if you can make it as transparent as you say, with wrapper scripts ...
16:15:37 <SyntaxNinja> FrederikEaton: I do believe so.
16:15:48 <SyntaxNinja> as long as you don't mind saying "cabal-put foo.tgz" instead of negotiating a web interface :)
16:16:06 <SyntaxNinja> the only non-trasparent bits are the keysigning things, which not everyone has to do.
16:18:01 <FrederikEaton> well ssh hides key management pretty well. i don't know how much more complicated gpg is but it seems doable
16:18:16 <FrederikEaton> so, what about the exec bit bug?
16:24:57 <SyntaxNinja> FrederikEaton: don't know. email me about it and I"ll try to look at it later.
16:32:13 <FrederikEaton> done
16:35:30 <FrederikEaton> i wonder if there should be functions withStd{in,out,err} like withArgs... so you could redirect output from a library without going through the OS
16:51:20 <foxy> @index concat
16:51:20 <lambdabot> Data.List, Prelude
16:52:54 <Lemmih> @seen dons
16:52:55 <lambdabot> dons is in #haskell. Last spoke 14 hours, 41 minutes and 12 seconds
16:52:55 <lambdabot> ago.
16:57:27 <Lemmih> dons: Pn
16:57:36 <Lemmih> s/Pn/Ping/
17:17:04 <SyntaxNinja> ooi, does anyone know how Handles are implemented?  that is, they hold state; when you do a read or something, you don't get a handle back
17:17:22 <SyntaxNinja> the file pointer may have changed, but that's statefully tracked in the IO monad
17:17:43 <SyntaxNinja> is that done by C, or do Haskell implementations handle this explicitly by having an internal state or table of handles or something?
17:18:16 <Igloo> Things like file descriptors are just integers in C, they don't need updating when you read them or whatever
17:18:45 <Igloo> s/them/from them/
17:19:22 <SyntaxNinja> yeah. so is a Haskell Handle just a thin layer on top of a C file descriptor?
17:21:13 <Igloo> I think so (or maybe FILE *), but I haven't checked
17:28:14 <dons> moin
17:28:22 <Lemmih> Hey dons.
17:28:58 <dons> a Handle is a FILE * and a buffer inside Haskell, isn't it?
17:29:43 <Igloo> Isn't the buffering done by the underlying libraries?
17:29:47 <dons> data Handle
17:29:47 <dons>   = FileHandle                          -- A normal handle to a file
17:29:47 <dons>         FilePath                        -- the file (invariant)
17:29:48 <dons>         !(MVar Handle__)
17:29:58 <dons> data Handle__
17:29:58 <dons>   = Handle__ {
17:29:59 <dons>       haFD          :: !FD,
17:30:04 <Igloo> Oh, I guess you'd have to write single chars all the time then
17:30:08 <dons> ..
17:30:18 <dons> type FD = Int
17:30:34 <dons> hmm. can't see my byte array. maybe it is done underneath.
17:30:46 <Pseudonym> It'd be a bit of a waste, since a FILE * is a file descriptor plus a buffer.
17:30:46 <dons> no. got it:
17:30:47 <dons>       haBuffer      :: !(IORef Buffer),      -- the current buffer
17:31:11 <dons> -- The buffer is represented by a mutable variable containing a
17:31:12 <dons> -- record, where the record contains the raw buffer and the start/end
17:31:12 <dons> -- points of the filled portion.
17:31:12 <Pseudonym> I wouldn't bother buffering twice.
17:31:29 <Pseudonym> Besides, buffering in Haskell has got to be safer than stdio.
17:31:36 <Pseudonym> And probably more efficient, too.
17:31:40 <dons> data Buffer
17:31:41 <dons>   = Buffer {
17:31:42 <dons>         bufBuf   :: RawBuffer,
17:31:48 <dons> type RawBuffer = MutableByteArray# RealWorld
17:31:58 <dons> that's what Yi buffers used to be as well
17:32:24 <dons> Lemmih?
17:33:13 <Lemmih> dons: Is there some way of unloading/reloading dependencies of a Module with hs-plugins?
17:33:18 <SyntaxNinja> dons: thanks for the details.
17:33:42 <dons> Lemmih, doesn't happen automatically at the moment :/
17:33:57 <dons> you can do it if you know the deps yourself.
17:34:21 <dons> and, really, there's no reason not to do it -- the code's just not there yet
17:34:36 <dons> Peter Thiemann wants this too.
17:34:52 * dons adds to the todo list
17:35:00 <Lemmih> Thanks.
17:35:42 <dons> the dependency graph is stored in the linker's env already. we just need to walk it to do the unload or reload
17:36:43 * Lemmih wonders how to work around this.
17:37:40 <dons> can't you just leave them loaded, or you need to know that if deps change, they'll be reloaded?
17:38:02 <Igloo> Is there a canonical place to look up what assembly instructions mean (preferably HTML)?
17:38:33 <dons> Lemmih, in that case, perhaps you could bundle a module and it's deps into an archive (libHSfoo.a/.o style), and use the package load/unload functions.
17:41:09 <Lemmih> dons: I would rather have something automatic since I'll be making lots of small changes.
17:42:12 * Lemmih is using Haskell (HSP) as HTML templates.
17:45:01 <dons> well, maybe you could add the required patch to hs-plugins? depends on how soon you need this behaviour.
17:46:31 <Lemmih> What files should I be looking at?
17:47:28 <dons> ok. you'll have to add some code to System.Plugins.Load, probably using load() and loadDepends() as a model.
17:48:37 <dons> the dependencies are stored in the .hi files for each module.
17:48:54 <dons> you can get at them hiface <- readIface hifile; let ds = mi_deps hiface;
17:49:09 <dons> where ds are a list of modules that the current module depends upon.
17:50:50 <Lemmih> Thanks.
17:51:27 <dons> I imagine you could write a unloadAll :: Module -> IO (), for example
17:51:50 <dons> that recursively calls unloadAll on the depes of m, and uses unload itself on each node
17:56:48 <foxy> @index trace
17:56:54 <lambdabot> Debug.Trace
17:57:01 <dons> Lemmih, hmm. looks like we don't keep track of dependencies in the state after all. we throw them away in loadDepends. storing them in Env might be useful, rather than reconstructing them from .hi files (which could potentially change)
17:57:03 <Lemmih> Iface keeps dependencies as Strings. Is it possible to get the Module from that?
17:57:54 <dons> I don't think so at the moment. we should fix this. ifaces are components of a Module
17:58:37 <dons> something like a String -> Module map in the env. and a  Module -> [Module] map, I think
17:59:27 <dons> then unloadAll find it's deps easily in the Module -> [Module] map.
18:00:08 <Lemmih> What's this environment you're mentioning?
18:00:19 <dons> Env.hs
18:00:35 <dons> it's mostly used for storing package.confs
18:00:41 <dons> but will be useful for other state
18:09:05 <Lemmih> I'll change ModEnv from 'FiniteMap String Bool' to 'FiniteMap String Module' and add DepEnv 'FiniteMap Module [Module]', OK?
18:11:35 <dons> that sounds ok.
18:15:21 <dons> once you're done, you may like to add some tests for the new code to examples/
18:20:44 <Lemmih> Foo. Load.hs and Env.hs are mutually recursive. /-:
18:21:26 <Lemmih> dons: Does your build system handle .hs-boot files automagically?
18:21:41 <Igloo> You can't get around it?
18:21:50 <dons> I have no problems with mutual recursion.
18:22:12 <dons> there's been mutuallyy recursive modules in hs-plugins in the past, so I think it'll work
18:22:15 <Igloo> Fair enough  :-)
18:22:25 <dons> we use ghc -M to get the dependency list anyway
18:22:35 <dons> so if it can't handle mutual recursion...
18:23:36 <dons> Lemmih, you could factor the Module type out, if nec, couldn't you? (I'm guessing that where the recursion is?)
18:23:58 <dons> anyway, go for it. if the build system doesn't work, I'll import the fixes from yi or lambdabot.
18:26:01 <Lemmih> "No rule to make target `System/Plugins/Load.hi-boot'."
18:26:51 <Lemmih> I'll just do some refactoring.
18:27:47 <dons> .hi-boot. hmm.
18:28:12 <dons> ah true. i'll import the make rules now, anyway.
18:35:01 <foxy> dons: your Altdata.Dynamic functions fromDyn and fromDynamic have crossed definitions incomparison to those of Data.Dynamic
18:35:54 <dons> foxy, yeah. i seem to recall this being the case:} now, what was the reason for this. hmm..
18:36:30 <foxy> had me head-scratching for a while :)
18:38:10 <dons> sorry. I'll fix this.
18:42:26 <lispy> what are you working on?
18:43:51 <lispy> i think haskell monands and lisp macros have some overlap (but only a little)
18:44:13 <lispy> both can allow you to define "code" that will transform other code
18:49:44 <Cale> Template Haskell and Lisp macros perhaps have more overlap :)
18:51:50 <lispy> yeah, i guess it depends on how generic template haskell is
18:52:03 <lispy> if it's like c++ templates I would say not much
18:53:40 <lispy> for example, in lisp one of the classic uses of macros is to define with-*, such as with-open-file.  So you can do things like, (with-open-file (s "path/to/file") (file-operation s) (another-file-operation s) )
18:54:00 <lispy> then the macro with-open-file does all the error handling
18:54:40 <lispy> lisp programmers often have the mindset that the "right way" should be the easy way, otherwise programmers won't use it
18:54:53 <lispy> i think that's why they use macros :)
18:56:22 <lispy> this is the case where i was thinking monads and macros are similar
18:56:44 <lispy> perhaps my example makes sense :)
18:57:25 <lispy> although, with lazy evaluation i'm not sure if you ever need macros
18:57:46 <lispy> because that's the big technical reason to have them
18:58:05 <lispy> sometimes in lisp you need to control the order of evaluation.  Macros let you do that
19:04:47 <Cale> lispy: Template Haskell lets you construct abstract syntax trees for Haskell code programmatically at compile time, and splice it in.
19:05:09 <lispy> very nice
19:05:17 <Cale> It's even possible to do IO at compile time :)
19:05:46 <lispy> ah, so this is nice indeed
19:06:15 <lispy> wish i had some time tonight to play with it :(
19:06:22 <lispy> stupid school work :)
19:07:21 <Cale> http://www.haskell.org/tmrwiki/ImpureThoughts_2f1 -- using Template Haskell to turn a Haskell compiler into a compiler for another language. :)
19:10:35 <Lemmih> dons: Couldn't I accidentally be unloading some dependencies of other in-use modules?
19:11:17 <dons> this is a problem... you'd have to reload those modules too, yes?
19:11:38 <dons> have a look at Hampus Ram's dynamic loader documentation. he has a discussion of this problem I think.
19:12:07 <dons> I think this is why I stopped implementing where I did, in fact.
19:12:16 <lispy> Cale: that's a cool example
19:12:29 <arjanoosting> Igloo: are you there?
19:12:31 <Lemmih> dons: Can't I just put a reference counter in the Env?
19:13:01 <Igloo> possibly
19:13:49 <arjanoosting> my package drift failed to build on hppa due to a bus error
19:13:59 <Igloo> Ignore it
19:14:05 <dons> Lemmih, problem mentioned here : http://www.dtek.chalmers.se/~d00ram/dynamic/dynamiclinker.pdf
19:14:12 <Igloo> It's a ghc problem, not yours
19:14:17 <dons> i think it would be ok to use a ref counter.
19:14:37 <dons> for now, at least.
19:14:45 <arjanoosting> i thought so; after a quick google a saw similar problems (also with nhc98)
19:15:09 <arjanoosting> so i just have to sit back and wait until the problem gets fixed?
19:15:15 <Igloo> Yup
19:15:22 <arjanoosting> ok thanks
19:15:36 <Igloo> And have some developer karma points for noticing  :-)
19:16:32 * arjanoosting was just curious how the package was building, since it's only my second package included in the archive :)
19:16:37 <Pseudonym> @karma+ arjanoosting
19:16:38 <lambdabot> arjanoosting's karma has been incremented
19:16:46 <arjanoosting> Yeah
19:17:13 <arjanoosting> well time to sleep, goodnight!
19:18:12 <MachinShin> hey +
20:07:06 <Lemmih> dons: Your code is really nice.
20:07:33 <Gahhh> that doesnt cut it. Buy flowers. :)
20:10:25 <dons> Lemmih, really? hs-plugins is one of my messier projects. talking to linkers isn't so elegant.
20:10:31 <dons> yi is so much nicer
20:11:39 <Lemmih> You've managed to do something really hackish without getting spaghetti code.
20:11:54 <Lemmih> I'm done btw.
20:12:30 <Lemmih> Gonna write a bit of documentation before I mail you a patch.
20:12:38 <dons> oh great! thanks.
20:12:44 <dons> @karma+ Lemmih
20:12:45 <lambdabot> Lemmih's karma has been incremented
20:14:29 <Lemmih> Open Source kicks ass!
20:14:49 <lispy> open sores?
20:14:52 <lispy> eeeewww
20:14:57 <dons> free the source!
20:15:29 <Lemmih> Kicking ass gives open sores?
21:00:42 <dons> foxy: the AltData.Dynamic weirdness should be fixed now
21:00:49 <Khisanth> Lemmih: that depends on where the sores were ...
21:01:10 <foxy> cool! ;)
23:49:42 <jesse99> goddamn, the ghc lib docs suck
23:50:26 <jesse99> been thinking the int arg in recvLen was flags, when it really is bytes to read
