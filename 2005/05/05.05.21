00:00:19 <shelarcy> And I am erong about latest code. latestest code doen't warn unknown symbol `__errno'
00:00:50 <shelarcy> wrong > erong
00:02:06 <dons> conal, Sean Seefried suggested a way of writing heterogenous collections where the type of the collection is encoded with GADTs, removing the need for toDyn. foxy I think has adjusted Sean's original idea to handle polymorphic values in the collection, as long as they are monomorphically annotated when applied. Foxy has the code.
00:02:36 <dons> shelarcy, so the latest code still fails, but with the above 'undefined reference?'
00:03:05 <dons> conal, I forward you sean's original code.
00:03:57 <dons> the nice thing about GADTs is that the elements of the heterogenous list (or whatever) don't need to be wrapped in anything to be stored.
00:04:10 <dons> @spell heterogeneous
00:04:12 <lambdabot> heterogeneous
00:04:30 <conal> dons, that may be very helpful to me
00:04:33 <conal> thanks.
00:04:35 <conal> :)
00:05:02 <shelarcy> ah, I mean hs-plugins works well on windows 2000 without both addDLL problem and  'undefined reference'.
00:05:50 <dons> it all works then?
00:05:50 <conal> i want to apply a polymorphic function (first, second, and similar for function types rather than pairs) to a dynamic
00:06:21 <conal> dons, after the application, the result will be monomorphic.
00:07:42 <dons> hmm.
00:08:01 <magnus--> How can i create a record in haskell?
00:08:20 <conal> dons, got your email, thanks.  coincidentally, i'm also using gadts, but i don't know if for a related purpose.
00:09:09 <conal> i'm using them for statically typing a term representation and for the GUIs that input and output them
00:09:56 <shelarcy> some program freezed, and I don't know why this is not ok.
00:10:04 <shelarcy> === testing examples/conf/simple                               ... failed with:
00:10:04 <shelarcy> -sh
00:10:04 <shelarcy> +sh
00:10:04 <shelarcy> === testing examples/dynload/io                                ... === testing e
00:10:04 <shelarcy> xamples/dynload/poly                              ... failed with:
00:10:05 <shelarcy> -True
00:10:07 <shelarcy> -True
00:10:09 <shelarcy> +True
00:10:11 <shelarcy> +True
00:10:44 <dons> hmm. weird. that looks ok..
00:10:55 <dons> maybe exit status was different.
00:11:00 <dons> hmm. no.
00:11:12 <dons> probably linefeed/^M at the end of the file?
00:11:28 <dons> this is on windows, but the files are unix. so the end of line terminator is different, isn't it?
00:13:21 <shelarcy> but some program notice ok message.
00:13:43 <shelarcy> === testing examples/eval/eval1                                ... ok.
00:13:43 <shelarcy> === testing examples/eval/eval2                                ... ok.
00:13:43 <shelarcy> === testing examples/eval/eval3                                ... ok.
00:13:43 <shelarcy> e.g.
00:13:43 <shelarcy> === testing examples/eval/eval_fn1                             ... ok.
00:13:43 <shelarcy> === testing examples/eval/foreign_eval                         ... ok.
00:13:45 <shelarcy> === testing examples/eval/foreign_eval1                        ... ok.
00:13:47 <shelarcy> === testing examples/eval/foreign_should_fail                  ... ok.
00:13:49 <dons> yes, I don't know what's happening, but it doesn't look ike a big problem.
00:13:50 <shelarcy> === testing examples/eval/foreign_should_fail_illtyped         ... ok.
00:13:52 <shelarcy> === testing examples/eval/unsafeidir                           ... ok.
00:15:08 <musasabi> Anyone think this is worth posting to the haskell list http://youzen.b2.fi/~musasabi/omr.lhs - open mutable record types in less than 100 lines of code.
00:17:18 <dons> I'd be interested to read that if it arrived in my mail box. So probably others would.
00:17:52 <magnus--> haskell doesn't have built in structs/records?
00:18:09 <dons> of course.
00:18:24 <musasabi> magnus--: haskell has records. Haskell does not have open records or mutable ones by default.
00:19:15 <magnus--> musabi: i don't need mutable, i just need names instead of tuple positions
00:19:30 <dons> use a data type
00:19:41 <musasabi> magnus--: data Foo { field1 :: Aaa, field2 :: Bbbb }
00:19:50 <musasabi> magnus--: data Foo = Foo { field1 :: Aaa, field2 :: Bbbb }
00:19:56 <magnus--> Ahh, thanks
00:19:59 <musasabi> (should drink more coffee)
00:20:21 <magnus--> I was trying to type  { a = 5, b = 6 } directly at the prompt
00:20:44 <dons> and for a bonus, the field names can be used a functions from Foo -> the type of the field they name :)
00:20:57 <magnus--> that's good
00:20:59 <foxy> musasabi: I thinks thats interesting.  Have you thought of a way of having labelled fields.  You use a type for each index
00:21:19 <foxy> whereas labelled fields could be defined dynamically
00:21:43 <musasabi> foxy: types serve as the cheapest labels - using a proxy value (which still needs the unique type) helps only for printing the field names.
00:23:34 <musasabi> foxy: like an association list of [(LabelType,Ref Dynamic)] + some fancy accessors.
00:24:08 <musasabi> But that is yet an another topic - and OO languages don't offer that either usually ;)
00:24:41 <foxy> musasabi, yeah, in which case each labeltype is different.  Have you thought of a way to have [(String,a)] type association?
00:25:44 <dons> ah, foxy want's his polymorphic heterogenous symbol tables..
00:25:56 * foxy grins
00:25:56 <dons> heterogeneous
00:27:08 <musasabi> like: field (!) alist = fromDyn $ maybe (error "no such field") id $ lookup (mfunFieldValue field) alist
00:28:06 <foxy> @index maybe
00:28:07 <lambdabot> Data.Maybe, Prelude
00:28:53 <musasabi> maybe :: (a -> b) -> b -> Maybe a -> b
00:29:16 <foxy> yup, but fromDyn has a monomorphism restriction
00:31:08 <musasabi> that compiles just fine.
00:31:39 <foxy> try it on an association ("id",id)
00:31:54 <musasabi> is id Typebeable?
00:32:03 <foxy> there should be an ambiguous type variable
00:32:22 <dons> it's polymorphic, so not Typeable
00:32:28 <magnus--> can functions have multiple return values and be composed accordingly?
00:32:37 <foxy> You can give it a monomorphic type
00:32:55 <dons> yep. or you can wrap it in a data structure
00:33:11 <dons> and have it locally quantified. let me see..
00:33:40 <dons> data Fn = Fn {fn :: forall t. Eq t => t -> t -> Bool}
00:34:29 <dons> you can derive Typeable on that, for example
00:35:32 <musasabi> http://youzen.b2.fi/~musasabi/a.hs has a working type.
00:35:39 <musasabi> s/type/example.
00:36:31 <dons> that's nice: x = MyField ! l
00:37:50 <musasabi> I'll post the open record types later tonight or tomorrow morning, now have to run/
00:51:40 <conal> i'm off to bed.  thanks for the chats.
00:55:15 <FrederikEaton> so what's the deal with distributing libs, do i basically have to give all my modules globally-unique names?
00:55:58 <FrederikEaton> or is there a way to import a package qualified ... ?
00:56:35 <boegel> conal: to bed at 10am ? you're crazy :p
00:57:19 <boegel> FrederikEaton: you can use the 'hiding' keyword
00:57:29 <musasabi> FrederikEaton: use Foo.Bar.MyLibrary and submodules as Foo.Bar.MyLibrary.*, where Foo.Bar comes from the guidelines.
00:58:36 <FrederikEaton> guidelines?
00:59:52 <musasabi> yes there is an informal set of guidelines how the basic division of hierarchial libraries goes (don't remember where that was).
01:00:18 <musasabi> If you say what kind of library people might be able to tell the natural place...
01:00:37 <FrederikEaton> do i have to put everthing in a subdir called Foo/Bar if I do that?
01:00:45 <FrederikEaton> it's a bunch of misc. stuff
01:01:18 <FrederikEaton> an automatic differentiation library, a more general parser than i could find elsewhere, a naive bayes library
01:01:44 <mflux> are there curses bindings for haskell around?
01:02:16 <musasabi> mflux: multiple ones - e.g. in yi.
01:02:18 <mflux> frederikeaton, I could be interested in that..
01:02:24 <mflux> musasabi, so, basically, it's roll-your-own?-)
01:02:55 <FrederikEaton> i hate long qualified names
01:03:03 <musasabi> FrederikEaton: one solution is using FrederikEaton.Bayes etc.
01:03:15 <musasabi> pesco uses names like that at least.
01:03:29 <musasabi> mflux: there is no standard - but lots of ready code that you can adapt.
01:04:21 <FrederikEaton> but if i just call it NB.* then there is a danger that it wouldn't be able to be installed together with something else that happened to have an NB module?
01:04:53 <mflux> I wouldn't mind if one such 'packaged' existed somewhere, atleast Yi's Curses-thingy has the label "Yi" all around it ;) (although I think no dependencies to the rest of they Yi though)
01:06:26 <musasabi> they could be installed but not used together with the other NB thing. of course after a simple, "mv NB NB-Foo && perl -i -pe 's/NB\./NB-Foo./g' NB-Foo" they should work.
01:06:30 <musasabi> but now really out =>
01:07:24 <dons> mflux, there's an (almost) standard one based on the one in yi here: http://www.stefanheimann.net/
01:08:02 <dons> darcs get http://www.stefanwehr.de/darcs/hscurses/
01:09:08 <mflux> great, thanks
01:10:29 <FrederikEaton> seems like you should be able to import a package with a set of remapping rules to get around conflicts
01:10:52 <FrederikEaton> i hate this global hierarchy thing. it's neurotic
01:11:04 <FrederikEaton> almost as neurotic as java
01:14:20 <FrederikEaton> i'm exaggerating but hopefully the point is understood
01:18:32 <mflux> frederikeaton, java doesn't have qualified import.. (does it?-))
01:19:08 <mflux> in java most of the time I don't want to use import, because it'll make more difficult later on to check where the constructors are coming from
01:19:23 <mflux> well, unless you happened to use some fancy editor which did that for you ;)
01:20:44 <FrederikEaton> no, qualified import is good. but it's not enough, if every package namespace has to be disjoint
01:24:34 <FrederikEaton> things don't naturally fit into a static global hierarchy. i believe the desire to try to squeeze them into one is regressive
01:24:59 <malcolm> wait, only the module names need to be globally distinct (and in future, compilers might change that to locally distinct within the package)
01:26:26 <FrederikEaton> yeah, still makes me unhappy (except for the future part)
01:27:20 <malcolm> Well, you can always adopt AlexJ's SearchPath tool, and remap individual module names to different implementations if you like.
01:28:26 <FrederikEaton> if i understand correctly, the packages themselves still need the full names though right?
01:28:56 <malcolm> I don't understand the question
01:29:32 <FrederikEaton> i mean the modules within the packages
01:30:59 <malcolm> Well a compiler still needs to be able to find the imports of a module, so they must be named.
01:34:33 <FrederikEaton> i'm arguing that you should for instance be able to remap the module namespace of a package when you specify that you are using it on the ghc command line, so that your code can refer to its modules under different names than exist locally within the package
01:37:27 <magnus--> is there a pastebot in this channel?
01:39:18 <FrederikEaton> @paste
01:39:19 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:39:29 <FrederikEaton> what's a pastebot?
01:39:49 <magnus--> You'll see in a minute
01:40:32 <malcolm> FrederikEaton: Yes, well I think you can do that (remap module namespace on the cmdline), sort of.
01:40:47 <FrederikEaton> oh really...
01:41:27 <malcolm> For instance, the -Idir flag
01:41:53 <FrederikEaton> huh?
01:42:03 <FrederikEaton> i don't see how that does what i said
01:42:13 <malcolm> Maybe I still don't understand what you want to be able to do.
01:42:39 <malcolm> How about "module NewName (module OldName) where import OldName"
01:43:08 <lisppaste2> magnus-- pasted "First haskell prog in a long time" at http://paste.lisp.org/display/8456
01:44:03 <magnus--> if anyone wants to point out improvements, please do so
01:44:14 <FrederikEaton> you need to be able to use this to avoid conflicts. so you can import two packages with some of the same module names.
01:45:10 <malcolm> Ah, so it is the no-module-overlaps problem that worries you.
01:46:19 <_shawn> pr05it
01:46:29 <_shawn> wrong window
01:47:32 <FrederikEaton> only partly. it's why i think a solution external to the haskell language is preferable
01:48:18 <malcolm> I agree that two packages defining the same module name is potentially a problem - it makes the namespace slightly more fragile than it should be.  But I don't see any good solution.
01:49:03 <FrederikEaton> you think what i proposed is not a good solution?
01:49:33 <malcolm> The main cause of the problem is that the linker insists all symbols should be unique.
01:50:23 <malcolm> If your conflicting packages are distributed in binary form, then you have to go into the object files and start renaming at that level.
01:52:15 <malcolm> magnus--: Have you just re-invented the embedded-control-code approach to pretty-printing? :-)
01:52:32 <FrederikEaton> well that is an implementation problem. i've proposed an interface. the implementation problem should be surmountable
01:53:38 <magnus--> malcolm: I guess so :)
01:53:39 <FrederikEaton> so is that link (http://paste.lisp.org/display/8456) a pastebot?
01:53:53 <magnus--> It is the result of using one
01:54:20 <magnus--> If you want to paste things yourself, you can do so here: http://paste.lisp.org/
01:54:44 <magnus--> it is useful to avoid flooding irc channels
01:55:22 <malcolm> At one point, we were considering assigning globally-unique numeric identifiers to modules (hidden from the programmer), to avoid the overlap problem.  There would be a different GUID for every new version.
01:56:05 <FrederikEaton> but then you have to recompile when you might not have had to right?
01:57:10 <malcolm> No, recompilation not necessary.  The GUID would be embedded in every linker symbol defined within that module.
01:58:17 <basti_> lol
01:58:24 * basti_ just fooled himself
01:58:52 <FrederikEaton> so why was the idea not taken further?
01:58:58 <basti_> in my yi emacs keybinding, i inserted mapping names for "cursor up" etc.,
01:59:02 <malcolm> But the question is how to assign GUIDs so they really are globally unique.  Think about hundreds of people all compiling stuff on their own machine, then swapping binary packages with each other.
01:59:33 <basti_> didnt bind them yet... but then they suddenly worked... i thought i was getting insane, before i discovered that i did the binding yesterday already (works without reference and was plannable ahead...)
02:01:38 <FrederikEaton> malcolm: 64 random bits? 128?
02:02:16 <magnus--> malcolm: did you see anything clumsy in my code? (my lisp code for this is shorter)
02:02:45 <malcolm> Maybe every installation of ghc would need to reserve its own portion of the GUID namespace.
02:03:48 <malcolm> magnus--: blanks n = replicate n '  '
02:04:17 <magnus--> :) thanks
02:05:01 <FrederikEaton> malcolm: what's wrong with just choosing random bits?
02:05:50 <malcolm> FrederikEaton: You can't be certain they won't overlap with someone else's random bits.
02:06:05 <chucky> hey everyone
02:06:18 <mflux> if the package name is also considered, I imagine the chance of that happening would be extremely small?
02:06:39 <FrederikEaton> malcolm: you can't be certain that your computer won't spontaneously combust either. which might be more likely if you use 128 bits
02:06:43 <chucky> has anyone ever experienced crashing with ghc --make when using symbolic links for the dependencies of a module?
02:06:51 <FrederikEaton> malcolm: or at least 256
02:06:52 <malcolm> magnus--: I get the feeling there is a state monad struggling to get out...
02:07:37 <magnus--> malcolm: Hmm, I'll read up on that
02:09:10 <malcolm> magnus--: alternatively, I might be inclined to just process the list directly in tail recursive style
02:09:51 <malcolm> magnus--: e.g. processList :: State -> [Input] -> Output
02:10:40 <magnus--> yes, i suppose that should be easier
02:11:13 <malcolm> magnus--: processList st (Newline : xs) = '\n': processList (st{freshLineP=True}) xs
02:11:40 <magnus--> I'll have a go with this before I tackle state monads
02:21:28 <magnus--> It went from 14 lines to 9 lines. Not bad
02:22:07 <magnus--> I notice it's hard to use long variable names in haskell
02:23:04 <magnus--> I'll research state monads now
02:23:09 <scalopus> Hi
02:24:19 <mflux> magnus--, emacs has dynamic name completion, great when you get used to using it ;)
02:24:43 <magnus--> mflux: Which key combo?
02:24:59 <mflux> M-/ I think, but I may have bind it myself
02:25:15 <magnus--> works!:)
02:25:46 <magnus--> wah, this will save me lots of typing
02:26:34 <mflux> it grabs the completions from all the buffers, so if you're interfacing with something it may be helpful to have the source open..
02:26:44 <magnus--> I see
02:27:11 <magnus--> Do you mind if I use it also for lisp coding? :)
02:27:29 <mflux> sorry, it is allowed only for c, c++, java and haskell-code :-/
02:27:37 <magnus--> dang
02:34:52 <lispy> heh, i use that all the time, even in irc and emails and so on
02:35:01 <lispy> basically anything i type in emacs :)
02:35:32 <magnus--> You're running emacs as an operating system it seems :)
02:35:38 <lispy> indeede
02:35:45 <tic> the problem with / is that it's only possible to type it if you've got an american keyboard layou.
02:35:53 <tic> emacs -is- an operating system
02:36:02 <wli> tic: careful
02:36:03 <lispy> tic: i have a dvorak layout :)
02:36:07 <wli> tic: define "operating system"
02:36:16 <basti_> tic: thats not true-.
02:36:33 <basti_> tic: / is shift-7 on german keyboards, M-shift-7 works
02:36:37 <magnus--> I am swedish, but i always use american keyboard for coding since the swedish keyboard is very clumsy for that
02:36:41 <tic> lispy, same same.  the Swedish dvorak (svorak) still has the same keys on the number row.
02:36:49 <tic> basti_, ah, nice
02:37:00 <tic> oh well.  I'm not using emacs anyway, so.... :)
02:37:38 <lispy> i start up a couple emacs sessions for major tasks using screen
02:37:38 <wli> tic: I don't see SCSI drivers or TLB miss handlers or interrupt handling in emacs' source... do you?
02:37:47 <lispy> than i can connect back to my work sessions from anywhere
02:37:54 <tic> magnus--, use a swedish keyboard and remap {}[]|<> to the home row using the Win key as modifier.
02:38:06 <tic> wli, *yawn*
02:38:09 <lispy> wli: or threading
02:38:33 <magnus--> tic: american is fine for me, i never need to type swedish letters while coding
02:39:07 <tic> wli, and I don't see a VM, spinlocks and locks either.  So wow, you know your OS development glossary.  Don't be so anal about it.
02:39:26 <tic> magnus--, same here, I suppose. although Dvorak is a bunch better than qwerty.
02:39:29 <wli> tic: I'd better know it or I'm out of a job.
02:39:31 <tic> magnus--, not for C coding (mostly) though.
02:39:50 <tic> wli, so why bother pointing it out?  Do you have a need to show off?
02:40:14 <tic> wli, I _know_ it's not an operating system /as such/, but it's a lot more than a "regular application".
02:40:24 <wli> tic: I point it out because the "emacs as an operating system" crud irked me.
02:40:57 <tic> wli, aww, someone stepped on your toe? yeah, I'm very sorry for that....
02:41:59 <tic> anyway, I don't want to argue.  I'm going to spend a lot of time in #haskell next "year" starting September :)
02:42:05 <lispy> heh, it might be fun to hack emacs to run on bare metal when needed
02:42:07 <wli> My toe is untouched. The "emacs is an operating system" bull OTOH is.
02:42:26 <tic> lispy, someone replaced init with emacs, iirc.
02:42:56 <wli> Some guy who used to IRC as eihrul did something much closer to it.
02:43:24 <lispy> a friend of mine tried using it inplace of a window manager
02:43:30 <lispy> he didn't do it for long :)
02:43:48 <lispy> and i say "in place" loosely
02:43:53 <wli> Another one named Zhivago didn't bother with the emacs part but otherwise had a Lisp repl running on the bare metal for a while.
02:44:10 <lispy> well, Zhivago is crazy :)
02:44:43 <tic> Hm.. I could use an "advanced vim usage" tutorial.
02:44:45 <lispy> there is another lispnik that is doing an OS capstone project thingy and using lisp for his kernel.  frodef iirc
02:45:26 <wli> House is vaguely interesting. I hope they've not frozen task management semantics just yet.
02:46:33 <chucky> wli: It's a haskell project. How often do they generally freeze semantics? :)
02:47:01 <wli> chucky: This particular piece is rather difficult to reverse decisions on.
02:47:32 <chucky> hmm I can imagine. Don't know much about OS hacking unfortunately
02:47:42 <chucky> House might be a nice way to learn
02:48:03 <wli> chucky: it's pretty easy to understand the difference given an example.
02:48:11 <wli> chucky: Do you know setjmp()/longjmp() in C?
02:48:38 <lispy> i know the basic idea
02:49:11 <chucky> wli: sorry, no
02:49:13 <lispy> and you've got my attention :)
02:49:24 <wli> task model program is basically doing setjmp()/longjmp() to emulate multithreading at the kernel level (hardware itself is usually ignorant of all this)
02:49:37 <wli> s/model program/model programming/
02:50:08 <chucky> ah, so we use different jumps to jump between the different processes?
02:50:14 <chucky> that was not a good way to put it
02:50:21 <chucky> but I think I understand the basic idea. :)
02:50:27 <chucky> (my way, that is)
02:50:28 <wli> chucky: No, it's perfect.
02:50:43 <lispy> why would you want to reinvent the wheel so to speak...
02:50:51 <chucky> seems very similar to continuations?
02:50:54 <lispy> i should read about house
02:50:54 <wli> Interrupt model programming OTOH doesn't try to use fake tasks in the kernel lik eexist in userspace.
02:51:09 <chucky> but at a much more basic level
02:51:12 <wli> Instead, what a task in userspace is trying to do inside the kernel is represented as a closure.
02:51:44 <wli> Called with "normal" function calls for the implementation language instead of low-level stack/register/etc. switching.
02:51:54 <mflux> does hOp have potential to run on SMP environment?
02:51:58 <lispy> uh, so how do you google for haskell house?
02:52:00 <wli> Given that the implementation language has higher-order functions.
02:52:17 <mflux> lispy, haskell hop house ?
02:52:27 <mflux> 'operating system' if not those ;)
02:52:31 <wli> Which is why I find the prospect of interrupt model programming in hOp/House rather interesting. =)
02:52:34 <lispy> ah yeah that looks better
02:53:11 <lispy> "Bored by those lemmings who use wildly popular operating systems such as the HURD?" lol, i tried the hurd twice.  It's terrible! :)
02:53:31 <lispy> terrible == not complete
02:53:45 <lispy> i guess that's a bit harsh, but anyway
02:53:54 <mflux> so does hOp use memory protection, or is it all working under the assumption that everything running will originate from a haskell compiler?
02:53:59 <wli> Anyway, when you try to do interrupt model programming in C, all kinds of horrendous things suck.
02:54:20 <wli> Basically because there are no language constructs making closures convenient.
02:54:37 <lispy> i've wondered if it would be possible to add circuitry to support GC
02:54:45 <wli> And some other garbage involving tailcalls and stack balance.
02:54:55 <lispy> TLBs didn't use to be part of the hardware
02:55:05 <malcolm> Does house's interrupt model come from Gadgets?
02:55:07 <mflux> didn't symbolics have some support?
02:55:22 <wli> lispy: It's been tried, I don't recall the results. Something is out there to find on the subject. Check Jones and Lins, they may have some reference.
02:55:48 <wli> Let me quickly say that any "interrupt model" that may exist is almost definitely unrelated to the "interrupt model programming" I mentioned before.
02:56:14 <wli> (It's somewhat obscure and its usage is almost exclusively confined to microkernels lacking virtual memory support).
02:56:18 <malcolm> Oh, OK
02:56:54 <wli> There are other niceties I'd like to see, at least partially inspired by k42, surrounding coremaps -- very specifically, avoiding having one.
02:57:17 <lispy> i have to say, i'm not sold on the idea of microkernels.  I've seen successful monolithic kernels, but macos and win2k/xp don't convince me that microkernels are worth all the extra debugging
02:57:20 <wli> (coremaplessness is not unique to k42 but also a common feature of microkernels)
02:57:29 <FrederikEaton> what's happening:
02:57:30 <FrederikEaton> ./GenUtil.hs:1:0:
02:57:30 <FrederikEaton>     Module `GenUtil' is a member of package MyHSLibs-0.0.0.
02:57:30 <FrederikEaton>     To compile this module, please use -ignore-package MyHSLibs-0.0.0.
02:58:19 <wli> lispy: These are just kernel internal design decisions used most commonly in microkernels, not anything to do with the microkernel notion itself.
02:58:50 <lispy> fair enough, but i was hoping you'd have some insight :)
02:59:17 <wli> The way certain prominent monokernels seem to be going these days is such that the distinction is getting rather blurred.
02:59:48 <lispy> yeah, that's true
03:00:01 <lispy> linux modules have done a lot
03:00:09 <wli> I can explain coremaplessness (particularly why it's desirable) if that's of interest.
03:01:12 <wli> lispy: Modules aren't really it, that's just dynamic kernel code loading. It centers more around system-level functionality being taken on by userspace in the form of e.g .udev and/or hotplug scripts handling device insertion/removal events, initramfs, and similar affairs.
03:02:12 <lispy> ah
03:02:16 <wli> I think I won't pique anyone's interest in coremaplessness without spraying something out there to give a notion of what's meant to go on when one does it.
03:02:24 <wli> Mind if I go on?
03:02:32 <lispy> sure
03:02:34 <mflux> please, go ahead ;)
03:03:02 <wli> So, traditional UNIX typically has a header for each "page" of memory in the system, meant to be used for various accounting purposes, and it tends to get heavily relied upon, so once in place, it's almost impossible to remove.
03:03:35 <lispy> right
03:04:12 <wli> This has a number of issues, starting with the fact you're globbing together sets of these things with no spatial relationship into aggregate data structures and traversing them, creating horrors for the cpu caches, and atop that, often dangling auxiliary structures off them, similarly scattered about memory, to track fs metadata.
03:04:29 <wli> So there's 2 layers of poor cache affinity etc.
03:04:42 <wli> Plus there's more or less linear memory overhead with no hope of being reduced.
03:05:33 <FrederikEaton> after i install my cabal package, i can't build it anymore (generates an error)
03:05:48 <wli> And atop all that, the fs and the vm and other kernel-internal users of these things have varying needs wrt. what fields they need, so there are too many fields in the structures for some users, and too few for others (which then attach dynamically-allocated structures for more cache horror).
03:06:19 <lispy> so it becomes a managment nightmare
03:07:08 <wli> No, sort of the opposite. It trades off "easier" memory management (via static memory reservations) for space waste and poor cache behavior of kernel algorithms.
03:07:53 <wli> So the "alternative" is not to reserve memory for any kind of analogous structure serving to track each page of memory at boot-time.
03:08:19 <wli> You end up having the fs allocate its own structures to track them, allocators having their own structures to track them, etc.
03:08:26 <wli> The fs part is the most important.
03:08:38 <wli> The fs is then free to change the structure since it's private to the fs.
03:08:51 <wli> Auxiliary fields can be folded into whatever structure it uses.
03:09:37 <wli> So there's no need for dynamically-allocated auxiliary structures dangling off the per-page structures and living in a separate cacheline: you just fold those into the fs' private notion of a per-page structure.
03:09:52 <wli> Similarly, the fs knows file-offset contiguity, and does lookups based on file offset.
03:10:03 <lispy> er...hmm
03:10:23 <wli> So you can allocate the fs' notion of a page structure in bulk, contiguously, for file offset ranges, and thereby achieve more cache contiguity.
03:10:45 <wli> You save memory overall because field adjacency replaces pointer links.
03:10:50 <wli> But you save more.
03:11:01 <wli> Free pages don't need headers, you can track ranges of free memory.
03:11:25 <wli> Pages used for kernel-internal allocations need at most minimalistic header information, saving more.
03:11:40 <mflux> this would look like a clear and simple alternative, but what are the downsides? why not always use this approach?
03:11:46 <wli> And the user controlling these allows for superior cache effects.
03:11:59 <wli> mflux: It's neither clear nor simple. It's very difficult to program.
03:12:20 <wli> mflux: Though nowhere near as big a PITA as the interrupt model programming stuff I mentioned earlier.
03:12:44 <lispy> most real-world kernel "stuff" is a PITA tho, right?
03:12:46 <wli> Microkernels use it because they are targeting embedded systems or systems with extremely strong cache effects.
03:12:52 <wli> lispy: For different reasons.
03:13:39 <wli> (i.e. they have requirements imposed on them they must use extreme measures to satisfy, this being one of those extreme measures)
03:14:33 <wli> It's difficult to convey the sorts of inconvenience that go on. One of them is referring to a page without any publicly-accessible structure representing it.
03:14:49 <wli> I've tried to retrofit Linux to do this and failed so I have some vague notions. =)
03:15:03 <lispy> so let me see if i get this.  The fs gets to have it's own reserved page, then it has pointers to the memory for the other modules?
03:16:15 <wli> lispy: I can't tell if you're saying the right thing. If it were correct I would say it as: "The filesystem allocates its own data structures to use for page-level accounting, and ..." (I can't make sense of the rest in terms of anything that would actually happen in this kind of scheme).
03:16:47 <wli> well, let me give you an idea of what SVR4 does
03:16:48 <lispy> hmm...okay
03:17:12 <wli> In C: struct page pfdata[]; (set up by low-level bootstrapping junk)
03:17:33 <wli> void free_page(struct pfdata *); void alloc_page(struct pfdata *); /* vm *
03:17:54 <wli> int write_page(struct pfdata *); int read_page(struct pfdata *);
03:18:07 <wli> there's a big fat global array there
03:18:16 <wli> 1 element for each 4K-sized, 4K-aligned block of memory
03:18:35 <wli> the vm, the fs, and other things all fiddle with the internals of this structure at will
03:18:48 <lispy> right
03:19:00 <wli> in the alternative pfdata[] doesn't exist
03:19:07 <lispy> ah
03:19:39 <wli> free_page()/alloc_page() use numerical identifiers to figure out what they're freeing or allocating
03:20:15 <wli> the filesystem similarly has to use a number or similar identifier for externally-visible interfaces
03:20:33 <wli> internal to the filesystem there is a structure like struct page but visible nowhere outside the fs
03:21:19 <wli> and the fs has complete freedom to add its metadata to the structure, and allocate structures representing pages close together in the file close together to each toher.
03:21:35 <wli> and to remove any unnecessary part of the structure
03:22:44 <wli> the vm has to come up with methods for e.g. page replacement that avoid relying on being able to infer certain things (e.g. what fs a page belongs to) from the page itself
03:23:03 <lispy> yeah
03:23:09 <lispy> that sounds hard
03:23:25 <wli> or otherwise some strange kinds of cooperation must go on between the vm and vfs where some standard "vm chunk" of the data structure is used by every fs, and the vm then deals with the page that way.
03:24:16 <wli> Like I said, it's more difficult than using the "coremap" (struct page pfdata[]; in SVR4 or struct vm_page *cmap; in BSD)
03:24:36 <lispy> so in the "normal" way, the vm would have a fixed pointer to the data it needs.  This way, it instead just knows how to communicate with the fs which could move around?
03:24:45 <wli> (sometimes cmap_t *cmap in certain flavors of BSD)
03:25:12 <wli> lispy: in the most common arrangement (when there even is a vm) yes
03:26:03 <wli> lispy: another way I've never heard of is to have something like a struct vm_page every fs uses as part of its struct my_fs_page, and then hand the struct vm_page back to the vm, and infer the struct my_fs_page from pointers to those when given them.
03:26:29 <wli> (basically, the structure offsets are fixed in C by all that)
03:26:40 <lispy> right
03:27:02 <wli> lispy: It's hard but the rewards are significant in terms of cache locality for kernel algorithms and reduction of asymptotic (as well as absolute) memory overhead.
03:27:07 <lispy> but you'd need to make a special case for everything that need access to data "hidden inside" the fs, right?
03:27:20 <wli> lispy: Callbacks into the fs
03:27:39 <lispy> yeah, it's sort of like the fs now has system calls
03:27:51 <lispy> and everything else is just a program
03:28:00 <wli> This is one of the trio of kernel design decisions that beguiles me.
03:28:36 <wli> lispy: You can see how this completely turns a kernel upside-down were you to attempt to retrofit it onto e.g. Linux and/or FBSD or just about anything that's not done it up-front.
03:28:43 <lispy> i was really intruiged by exo-kernel design, but that research seems to have dried up
03:28:46 <wli> At least I hpe you do now.
03:29:08 <lispy> i can kind of see it.  About as much as you can without trying to implemet it
03:29:36 <wli> lispy: Well, part of it is that none of these have any explicit exploration apart from the Fluke paper where it tries to flaunt its atomic system call API/ABI.
03:29:53 <lispy> atomic?
03:29:55 <wli> i.e. these things happened but nobody talks about them
03:30:01 <lispy> heh
03:30:11 <wli> lispy: Your guess is as good as mine. Most intepretations of "atomic" I could come up with didn't apply.
03:30:45 <lispy> according to a book i have on the linux kernel those system calls are amazingly fast
03:31:01 <wli> This has largely to do with passing syscall parameters in registers.
03:31:13 <lispy> and in some cases, the kernel can actually return your process and let you finish your time slice because the system call is fast enough
03:31:28 <wli> As opposed to copying them off the user stack and similarly putting the results on the user stack when done.
03:31:40 <lispy> right
03:31:43 <wli> lispy: That's not unique.
03:31:58 <lispy> i had hoped not :)
03:32:01 <wli> And actually the whole fast syscall affair is not unique.
03:32:11 <wli> e.g. DYNIX/ptx
03:32:44 <lispy> yeah, i've seen benchmarks that show freebsd to be almost identical performance to linux
03:32:53 <wli> it had faster syscalls than Linux on i386 for a long while despite using something called "XKVA", which involves TLB switching between a dedicated kernel MMU context and a user MMU context
03:33:23 <wli> First, the effect of XKVA was almost entirely mitigated by using some lazy MMU context switching affairs involving u areas.
03:33:54 <lispy> don't update things unless you have to?
03:34:01 <wli> Second, it used the same register-passing and so on, but one-upped and used lcalls for syscalls, which were faster than "software interrupts" (the "int" instruction).
03:34:26 <wli> Third, it had sysenter/etc. long in advance of Linux for machines supporting it.
03:34:56 <wli> This story is not unique.
03:35:14 <wli> Linux' claim to fast system calls is probably only valid for older versions of freenix BSD's.
03:35:32 <lispy> ah
03:35:36 <wli> The commercial unices trounced Linux thoroughly until recently (where it achieved parity as opposed to dominance).
03:35:46 <wli> this is, wrt. syscall overhead
03:36:46 <wli> As someone who needs to make Linux work where it doesn't already I have a need to know when something is propaganda and pissing people off that it's false.
03:36:52 <lispy> solaris 8 and hp-ux are the only commercial unices i've compared linux with, and i like it WAY better than hp-ux and better than solaris
03:37:10 <wli> Those concerns probably don't have a lot to do with the kernel.
03:37:27 <wli> Anyway
03:37:38 <lispy> in the case of hp-ux they do
03:37:41 <wli> Interrupt model programming is "worse" than coremaplessness.
03:37:46 <lispy> but compared to solaris maybe not
03:38:05 <wli> HP-UX has some throwback semantics that you may trip over but it's probably still just userspace-visible stuff.
03:38:22 <lispy> hmm...possibly
03:38:43 <lispy> i remembering being told that the hp-ux didn't support auto-mounting because of the kernel
03:39:10 <wli> It's worse because almost all OS hackers except the ones who have already worked on kernels doing this are stuck in a task model mindset, which there's nothing particularly wrong with, but sort of attests to how big a PITA it is (though nowhere near as much as what I'm about to dive into).
03:39:56 <wli> In the task model you have these sorts of notions that a user task has a kernel context backing it up, and you can do actions on the task's behalf, and do things like, say, sleep and wait for things.
03:40:17 <lispy> right, that's what they teach in OS classes
03:40:33 <wli> So you have this private area of memory (per-task kernel stack) and the ability to defer execution with just what looks like a function call.
03:40:42 <wli> You lose both these in the interrupt model.
03:41:07 <wli> Everything you want to keep track of you have to save somewhere if you're not going to finish with it right away.
03:42:10 <wli> If you want to "sleep" for the user you have to set up a continuation, which in C involves shoving variables somwhere a function pointer can get at it, writing a function for what you're going to do later (chopping your function in half where you would sleep instead of just calling something), and similarly nightmarish things.
03:42:40 <wli> And there's low-level asm junk you need to do, too, in order to avoid just calling down forever into callbacks coming in from somwhere.
03:42:51 <wli> One way to think of it is that everything in the kernel acts like an interrupt handler.
03:42:52 <lispy> nice
03:43:51 <wli> (this calling down forever you must avoid because you're doing indirect calls that can't really be made tailcalls without "forcing" them to be such, and unless they are made such, you allocate infinite stack)
03:44:12 <wli> (in functional languages tailcalls are often "easier" so this entire problem evaporates)
03:44:36 <lispy> so you are planning on doing this in a functional language?
03:44:43 <wli> So, for instance, a page fault now needs to be treated like an interrupt.
03:44:47 <lispy> such as extending hOp?
03:45:12 <wli> lispy: Unless I win the lottery or otherwise acquire the financial/whatever freedom to go off and bang out my own kernel or jump on something like hOp/House, no.
03:46:09 <lispy> so you're starting it tomorrow? :)
03:46:32 <wli> So, for instance, a page fault now needs to be treated like an interrupt, and where in e.g. UNIX or Linux a task would sleep and have a complex callstack down through the vm and fs and block layers and driver and so on for it, you are instead in incredible amounts of pain.
03:47:05 <lispy> then why would you want this?
03:47:15 <wli> This almost seems to want more than functional programming, but outright continuation-passing style.
03:47:22 <wli> lispy: 2-3 major reasons.
03:47:25 <lispy> the point of sleeping threads is to make things simple to understand
03:47:33 <wli> lispy: The first is that except for register-windowed architectures, it's faster.
03:47:51 <wli> lispy: The second is that the per-thread memory overhead is significantly reduced.
03:49:28 <lispy> this is good stuff, but it's way past my bed time
03:49:33 <wli> lispy: The third is that the semantics of all operations in the operating system are forced to be inherently asynchronous. Things like AIO, BSD's kernel event notification stuff, and so on are all suddenly super-efficient, super-scalable, and precisely the intended semantics.
03:50:05 <wli> lispy: For instance, you can run millions of threads on a system with a very small amount of memory (e.g. 100MB)
03:50:22 <lispy> that's a nice feature for servers
03:50:33 <wli> Well, it's a matter of degree.
03:50:47 <wli> A certain amount of overhead is eliminated that's proportional to the number of threads.
03:50:56 <wli> The asynchronous semantics are extremely interesting.
03:51:46 <wli> It's sort of a permanent chase for where an fs or similar is accidentally blocking processes doing aio if you aren't inherently asynchronous all the time by design.
03:52:06 <wli> Now it Just Works (TM) for free.
03:52:11 <lispy> yeah
03:52:19 <lispy> everyone knows how to play nice
03:52:38 <wli> This allows even more drastic reductions in memory overhead, because now userspace doesn't even need to fork off more processes or spawn more threads.
03:52:53 <wli> And it's typically faster, mostly due to cache effects on the stack.
03:53:27 <wli> The stack switching in traditional UNIX incurs overhead from stacks being cache cold after sitting idle when a thread is blocked.
03:53:38 <wli> The interrupt model never switches stacks. The stack is always hot.
03:54:05 <lispy> ah yeah
03:54:07 <lispy> i think i get it
03:54:44 <wli> I suppose it's off to bed for you and off to hunting for more pagetable walking bugs for me.
03:54:56 <lispy> heh, good luck
03:55:01 <lispy> yeah, i need sleep
03:55:08 <lispy> long day ahead of me tomorrow
03:55:10 <wli> Well, nice chatting with you, rest easy.
03:55:20 <lispy> thanks, you too
03:55:40 <wli> mflux: I'm no salesman. These things are rather far from free rides.s
04:53:36 <bibi> how to get the last of a tuple?
04:54:05 <bibi> the first i know. fst
04:54:44 <dons> pattern match
04:54:59 <Igloo> or snd
04:55:02 <dons> f (_,_,_,_,x) = x
04:55:12 <bibi> but if there are more than two, snd will not work
04:55:21 <Igloo> Neither will fst
04:55:37 <bibi> yes you're right..
04:55:55 <bibi> i was mistaken about tuples
04:56:18 <bibi> how to get the size of a tuple then_
04:56:38 <Oejet> bibi: You know the size.
04:56:55 <tic> hehe
04:56:57 <bibi> unfortunately i don't!
04:57:05 <Oejet> bibi: You do.
04:57:20 <tic> bibi, how would you use a tuple in Haskell if you don't know how it's defined?  The type checker will fail otherwise
04:57:49 <bibi> i'm using the bounds function in the Data.array
04:58:00 <bibi> it returns a list of tuples
04:58:14 <tic> so check up its definition.
04:58:36 <tic> it's not like it can have the type [generic-tuple], it has to be [n-tuple].
04:59:15 <bibi> Data.Array.bounds :: (Ix i) => Array i e -> (i, i)
05:00:21 <dons> so you can use snd after all.
05:00:28 <bibi> ok it's not a tuple it's a Ix
05:00:41 <bibi> there seems to be a range function for those...
05:05:07 <shelarcy> dons: I fixed two hs-plugins  examples for Windows.
05:05:11 <shelarcy> System.Process use cmd or command.com on Windows, not cygwin or MSYS shell. so makewith/io and makewith/unsafeio call wrong date command or fail.
05:08:48 <dons> ah, cool. thanks.
05:35:18 <ves> would anybody know any decent resources for learning how to deduce haskell types?
05:37:58 <dons> using ghci is very effective
05:38:50 <dons> @type map (+1) [1..10]
05:38:52 <lambdabot> map (+1) [1..10] :: forall a. (Num a, Enum a) => [a]
05:38:55 <dons> for example
05:39:00 <dons> @type map (+1) [1..10::Int]
05:39:02 <lambdabot> map (+1) [1..10::Int] :: [Int]
05:39:11 <ves> yeah, that stuff just slays me though on paper
05:40:10 <musasabi> Using ghci helps get you started and after a few weeks/months you will just see the types.
05:40:30 <ves> @type f x y (z:zs) = (y (x+z)) : f x y zs
05:40:32 <lambdabot> bzzt
05:40:33 <ves> hmm
05:41:06 <dons> @type let f x y (z:zs) = (y (x+z)) : f x y zs in f
05:41:07 <lambdabot> let f x y (z:zs) = (y (x+z)) : f x y zs in f :: forall a a1.
05:41:07 <lambdabot>                 (Num a) =>
05:41:07 <lambdabot>                 a -> (a -> a1) -> [a] -> [a1]
05:41:23 <ves> ah, I see
05:42:27 <ves> @type let f x y w z = foldr x y (z:w) in f
05:42:28 <lambdabot> let f x y w z = foldr x y (z:w) in f :: forall a b.
05:42:28 <lambdabot>               (a -> b -> b) -> b -> [a] -> a -> b
05:57:53 <FrederikEaton> neat, i didn't know you could do this
05:57:54 <FrederikEaton> test@(bar,baz) = (1,2)
05:57:54 <FrederikEaton> main = do print test
05:57:54 <FrederikEaton>           print baz
06:00:20 <xerox> Me neither, nice!
06:07:49 <FrederikEaton> now if only there were extensible records
06:10:59 <dons> FrederikEaton, see musasabi's extensible records discussion earlier today.. :)
06:16:15 <FrederikEaton> there is nothing in the logs
06:19:03 <FrederikEaton> well nothing i would call a discussion. are there plans to implement extensible records? i read a paper about them from 1999 or so, SPJ and MPJ? they proposed a lot of changes to the core syntax
06:19:16 <dons> 17:15  musasabi:: Anyone think this is worth posting to the haskell list
06:19:16 <dons>                   http://youzen.b2.fi/~musasabi/omr.lhs - open mutable record types in less than 100
06:19:19 <dons>                   lines of code.
06:19:45 <dons> I was just pointing this out. There's Trex, right?
06:20:41 <dons> And weren't there extensible records in the HList paper?
06:22:20 <FrederikEaton> too much overhead
06:24:22 <FrederikEaton> musasabi's example *is* pretty neat
06:24:58 <FrederikEaton> but it sucks to have to predeclare fields
06:26:17 <Lunar^> musasabi: at least haskell-cafe@ I would say
06:33:03 <xerox> What was that main difference between folding left and right, in Haskell?
06:33:14 <xerox> I mean, what was it about... lazyness perhaphs?
06:34:12 <resiak> xerox: Well, they work in the opposite direction? :-) Oh, and one of them is happier than the other about infinite lists? (as I understand things)
06:34:23 <xerox> I think that's it.
06:39:14 <dons> @plugs foldl (+) 0 [1..65008]
06:39:15 <lambdabot> 2113052536
06:39:17 <dons> @plugs foldr (+) 0 [1..65008]
06:39:19 <lambdabot> Stack overflow
06:39:21 <dons> :)
06:41:17 <metaperl> I think that happened because foldr didn't do any addition until it got to the end of the list
06:43:58 <kaol> curious... I have a piece of code, that seems to spew out Nothings and Just (Just xs), but apparently no Just (Nothing)s. Yet I seem to fail to make it return only Nothings and Just xs.
06:45:44 <kaol> ah. I had one return too much. No wonder.
06:50:03 <kaol> hmm. I have 5 consecutive ')'s. I wonder if '$' could help here.
07:18:05 <FrederikEaton> with template haskell, can i append a new definition to the module where a splice occurs, even if the splice is not at the top level?
07:18:52 <FrederikEaton> or do i have to like write all these definitions to a separate file and compile that file last and use tricky recursive module functionality?
07:20:51 <Igloo> Why not to a top-level splice?
07:22:10 <FrederikEaton> the splice will turn into a value that gets used where the splice is, but it also needs a helper definition at the top-level
07:25:06 <Igloo> I'd have thought you can do something like $( do d1 <- ...; d2 <- [|d what is currently outside the splice $( your current splice using d1's name ) |]; return [d1, d2] )
07:26:26 <FrederikEaton> i don't understand
07:48:12 <FrederikEaton> class HListTyCon t l where projectHList :: (forall a . t a -> b) -> l -> [b]
07:48:12 <FrederikEaton> instance HListTyCon t HNil where projectHList f Nil = []
07:48:12 <FrederikEaton> instance HListTyCon t l => HListTyCon t (t a :* l) where projectHList f (e :. es) = f e : projectHList f es
07:48:30 <FrederikEaton> example: projectHList length ([1,2,3] :. ['a','b'] :. Nil) => [3,2]
07:48:44 <FrederikEaton> interesting?
08:31:04 <jlouis> FrederikEaton: The impossible can happen!
08:47:15 <jlouis> malcolm: hi, did you get your FTP/firewall problems solved?
08:47:26 <jlouis> (with the nhc98 package that is)
08:47:47 <malcolm> Our support staff say they have make a kind-of fix
08:48:12 <jlouis> heh
08:48:19 <jlouis> if it works....
08:48:34 <malcolm> I think they chose a very restricted number of ports to open through the firewall for passive FTP
08:48:57 <malcolm> I don't know whether it works - fancy giving it a test?
08:50:21 <jlouis> Sure, it doesn't seem to work
08:51:15 <malcolm> Oh, OK.  what is your diagnosis of the problem?
08:54:14 <jlouis> The problem is extended passive ftp mode. Some firewall in between blocks it. Disabling extended passive ftp mode at my end solves the problem
08:54:43 <jlouis> apart from a NAT, there should be nothing at my place irritating and passive mode should be smooth over a NAT
08:55:16 <malcolm> Maybe I should just place a note about EPASV on the download page.
08:55:51 <jlouis> malcolm: yes, or provide downloads via HTTP. It is faster anyway
08:56:22 <malcolm> Well, HTTP downloads are already available, and have been for a few years now.
08:57:06 <jlouis> malcolm: ok, I must have overlooked it
08:58:55 <jlouis> FTP has to go away soon. The protocol is a mess, it is hard to program secure ftp-clients and unless you keep attention to detail, it is rather hard to firewall them properly.
09:00:19 <malcolm> I think it is still sometimes the only way to upload files to a remote webserver (e.g. at an ISP)
09:02:38 <jlouis> malcolm: oh yes, forgot about that
09:15:01 <FrederikEaton> uh oh
09:15:19 <FrederikEaton> oops
09:33:10 <jaap> has anyone compiled greencard 3 with ghc6.4? it seems to fail in a number of ways over here...
09:33:46 * Lemmih has.
09:33:59 <jaap> did you have to modify things?
09:34:35 <Lemmih> I think so. What errors are you getting?
09:34:49 <Lemmih> /-:
09:35:00 <Lemmih> Welcome back, jaap.
09:35:04 <jaap> i got one error about a flag that ghc no longer takes
09:35:22 <jaap> (I have this weird irc client in which C-k is close window instead of delete rest of line, and i always forget)
09:35:25 <jaap> i fixed that
09:35:37 <jaap> a wait
09:35:48 <jaap> i changed a #include somewhere and now it compiles, i think
09:36:44 * jaap did it again
09:37:42 <cbaoth> I'm having problems building ghc on solaris without a existing haskell compiler.
09:38:24 <cbaoth> make[1]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop. <- it dies there after running distrib/hc-build.
09:38:48 <Lemmih> cbaoth: I need to have GHC installed before you can compile GHC.
09:41:43 <Igloo> cbaoth: Are you following the porting instructions?
09:42:20 <cbaoth> Igloo: On further reading no. :I)
09:42:55 <Igloo> Also, you'll probably have to either build CVS or apply the recent SIGBUS fix to the released version
09:43:41 <cbaoth> D:
09:44:09 <cbaoth> Got a link to a patch?
09:45:08 <Igloo> No, but it's a recent change to ghc/compiler/cmm/PprC.hs
09:46:13 <callthephone> hello
09:46:15 <cbaoth> Hmm... would a CVS snapshot work reasonably well?
09:46:46 <Lemmih> Hello, callthephone.
09:47:23 <Igloo> In theory it will...
09:47:50 <mflux> according to the famous 'it compiles, it works'-theory?
09:59:58 <musasabi> What was the location of haskell-src-ext package (extended haskell parser) ?
10:02:59 <Lemmih> @google haskell harp
10:03:01 <lambdabot> http://www.cs.chalmers.se/~d00nibro/harp/
10:03:48 <shelarcy> @google hsx haskell
10:03:50 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
10:05:32 <musasabi> thanks.
10:05:53 * musasabi tried googling haskell-src-ext and was thus not getting any results.
10:13:10 <callthephone> does anyone know of a place i can learn about the runIpni command?
10:14:06 <Lemmih> @index runIpni
10:14:07 <lambdabot> bzzt
10:14:21 <Lemmih> runIpni?
10:14:34 <callthephone> yeah
10:14:53 <callthephone> or runIt
10:18:20 <jaap> all right, I have greencard compiling, now i'm stuck at install-pkg; they have a package.conf file that looks like a Haskell record, whereas ghc-pkg wants one with key/value pairs with colons in between
10:18:23 <jaap> is that a recent change?
10:18:59 <Igloo> Yes
10:19:16 <Igloo> 6.4 wants cabal format
10:19:19 <jaap> is there any way of getting it to accept the old syntax, or do I just rewrite the package file?
10:19:30 <Igloo> Rewrite it AFAIK
10:21:56 <Lemmih> You can have mine.
10:22:28 <jaap> ah, i just finished ;-)
10:23:04 <jaap> except it doesn't work
10:23:09 <jaap> can you send/link to yours?
11:27:30 <Lemmih> Anyone got a libgpgme binding?
12:03:54 <_JusSx_> ff
12:04:00 <Lemmih> 255
13:10:51 <TheHunter> @moo
13:10:52 <lambdabot>       ______________________            _______________________
13:10:52 <lambdabot>       |                    |            |                     |
13:10:52 <lambdabot>       |            (__)    |            |  (__)               |
13:10:52 <lambdabot>       |            (oo)    |            |  (oo)               |
13:10:52 <lambdabot>       |     /-------\/     |            |---\/           /----|
13:10:53 <lambdabot>       |    / |     ||      |            |  ||           / |   |
13:10:55 <lambdabot>       |   *  ||----||      |            |--||          *  ||--|
13:10:57 <lambdabot>       |      ~~    ~~      |            |  ~~             ~~  |
13:10:59 <lambdabot>       |--------------------|            |---------------------|
13:11:01 <lambdabot>             Normal Cow                  0   Cow  modulo one   1
13:14:45 <wilx> Heh.
13:24:52 <Huschi> hi. usually i develop with haskell under linux. but now i have to do it under windows. is there any good introduction?
13:33:05 <Lemmih> Is Windows really that different?
13:34:22 <Gahhh> no
13:34:36 <ves> @type let g x = 3 + head(x) in g
13:34:41 <lambdabot> let g x = 3 + head(x) in g :: forall a. (Num a) => [a] -> a
13:35:13 <Huschi> for example i don't know how to change the path environment variable and the "shell" is more than ugly.
13:35:35 <Gahhh> Huschi: You can try mingw or cygwin if you want a better shell
13:36:03 <Huschi> but i need to develop native windows apps.
13:36:15 <Gahhh> you can do that
13:36:20 <Huschi> and in mingw you always have the unix-like paths and so on.
13:36:36 <Gahhh> no, in mingw and cygwin you can use c:/tmp kind of paths
13:36:39 <Huschi> than yoz can't install packages for ghc to my mind.
13:36:51 <Huschi> really?
13:37:14 <Gahhh> yes
13:38:22 <Huschi> and how do i link against dll's under windows?
13:40:39 <tromp> let's see if i can use haskell for the
13:40:41 <tromp> http://www.pythonchallenge.com/
13:40:52 <tromp> one down, 25 to go
13:40:53 <Gahhh> umm, I am no expert but iirc, mingw/gcc can produce win32 dlls and use them. You should be able to get that to work.
13:41:44 <Gahhh> tromp: I read that some of the challenges require specific python modules.
13:41:51 <Huschi> is there a good ide supporting haskell for windows?
13:42:36 <Lemmih> There's Haste and emacs.
13:42:46 <wilx> Emacs.
13:42:58 <wilx> Huhuhu.
13:43:57 <tromp> yes, i expect so
13:44:48 <Huschi> has anybody experience with wxhaskell under windows?
13:45:17 <lispy> Huschi: you may want to aske in the #darcs channel it has a wxHaskell interface
13:46:35 <Huschi> i just want to know if it is normal that the black shell window alwas pops up, if i start a wxhaskell application from the explorer.
13:47:38 <tromp> two down;)
13:50:05 <Huschi> tromp, you meant me?
13:50:29 <tromp> nope, i solved another riddle
13:50:37 <Huschi> ok.
13:51:24 <sylvan> wth? Darcs has a GUI now?
13:52:04 <sylvan> Huschi: I believe I get the same behaviour...
13:52:23 <wilx> Does it?
13:52:24 <wilx> Where?
13:52:35 <Huschi> i just looked at gebop. it's also written in haskell and to my mind it doesn't happen there.
13:52:53 <Huschi> wilx: how do you compile your programs?
13:53:01 <mflux> hmh, import IOExts complains about not being able to find module IOExts, I'm missing something obvious?
13:53:08 <Huschi> i meant gebop is written using wxhaskell.
13:54:14 <wilx> ghc --make etc. Why?
13:54:33 <Huschi> mflux, IOExts no longer exists.
13:54:45 <mflux> oh
13:54:51 <Huschi> wilx, maybe it depends on how you compile your program.
13:55:04 <wilx> Oh.
13:55:23 <wilx> I meant the Darcs GUI...
13:55:23 <Huschi> wilx, do you compile it in the windows shell?
13:55:53 <mflux> ah, Data.IORef
13:56:42 <sylvan> lispy said something about a wxHaskell interface
14:07:45 <Huschi> windows more than bullshit!
14:15:24 <FrederikEaton> what's this about downtime?
14:49:26 <basti_> hey pipe
14:49:30 <pipe> sup mate
14:51:04 <basti_> not much so far
14:51:22 <pipe> cool... was i dreaming or did i talk to you on thursday?
14:51:29 <basti_> you did but just a few lines
14:51:38 <pipe> ok, good
14:51:47 <basti_> shapr didnt show up yet
14:51:57 <pipe> i figured. well, in 8 hours i gotta be back in the base :(
14:52:26 <basti_> :/
15:03:53 <xerox> Why can I do: add (+2) $ 2, and get back 4 ?
15:04:47 <mauke> <interactive>:1: Variable not in scope: `add'
15:05:27 <xerox> whoops
15:05:28 <xerox> arr!
15:05:31 <xerox> Control.Arrow.arr
15:05:43 <xerox> @type Control.Arrow.arr (+2) $ 2
15:05:44 <lambdabot> Control.Arrow.arr (+2) $ 2 :: forall a. (Num a) => a
15:06:18 <xerox> @plugs Control.Arrow.arr (+2) $ 2
15:06:23 <lambdabot> 4
15:08:37 <Cale> @type Control.Arrow.arr
15:08:38 <lambdabot> Control.Arrow.arr :: forall (a :: * -> * -> *) c b.
15:08:38 <lambdabot>        (Control.Arrow.Arrow a) =>
15:08:38 <lambdabot>        (b -> c) -> a b c
15:08:59 <Cale> @type Control.Arrow.arr (+2)
15:09:00 <lambdabot> Control.Arrow.arr (+2) :: forall (a :: * -> * -> *) b.
15:09:00 <lambdabot>          (Control.Arrow.Arrow a, Num b) =>
15:09:00 <lambdabot>          a b b
15:09:36 <Cale> @type Control.Arrow.arr (+2) :: (Num b) => b -> b
15:09:38 <lambdabot> Control.Arrow.arr (+2) :: (Num b) => b -> b :: forall b.
15:09:38 <lambdabot>                 (Num b) =>
15:09:38 <lambdabot>                 b -> b
15:10:54 <xerox> Cale, why does it work this way? (Fortunately :))
15:11:29 <Cale> (->) is an instance of Arrow, I suppose :)
15:11:50 <xerox> Uhm
15:11:53 <xerox> I can't find it
15:12:35 <xerox> :info (->) gives back errors
15:20:24 <xerox> Does anybody know where I can find that instace... maybe in GHC sources?
15:20:57 <Cale> it's probably just the obvious one
15:21:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Arrow.html lists it
15:22:08 <xerox> I only see
15:22:22 <xerox> Arrow (->)
15:22:28 <xerox> under "Instances"
15:22:38 <Cale> yeah
15:22:38 <basti_> hmm
15:22:48 <basti_> how do i sort tuples by their fst?
15:22:56 <xerox> That's the usual problem of documentation not being linked to source
15:23:07 <Cale> sortBy (comparing fst) :)
15:23:13 <basti_> ahh.
15:23:16 <basti_> cool.
15:23:19 <basti_> thanks.
15:23:21 <Cale> hehe, but that needs comparing
15:23:25 <xerox> @pl \x y -> compare (fst x) (fst y)
15:23:26 <lambdabot> (. fst) . compare . fst
15:23:32 <basti_> ohh.
15:23:46 <xerox> sortBy ((.fst).compare.fst)
15:23:47 <xerox> :-)
15:23:57 <Cale> comparing p x y = compare (p x) (p y)
15:24:05 <Cale> is a handy definition
15:24:12 <basti_> both very nice yes.
15:24:19 <xerox> What do you mean by "obvious instance", anyway?
15:24:51 <xerox> (Talking about of Arrow (->))
15:24:58 <Cale> I'd write arr = id, (>>>) = flip (.), first f (x,y) = (f x,y)
15:25:39 <xerox> Uhm, ok
15:26:14 <xerox> I can't completely get
15:26:20 <xerox> what 'a' is in Arrow a.
15:27:17 <Cale> It's like the m in Monad m
15:27:22 <Cale> It's a type constructor
15:27:35 <xerox> What kind does (->) have?
15:27:35 <Cale> except that it takes two type parameters
15:27:41 <Cale> * -> * -> *
15:28:00 <xerox> What I don't get is probably which objects can have "kind"
15:28:05 <basti_> i should foldl' to convert a list of Monadic Operations to a big one with >>= shouldnt i?
15:28:22 <Cale> xerox, type constructors can
15:28:34 <Cale> basti_, sequence?
15:28:54 <basti_> sequence is the name of this operation?
15:28:59 <Cale> @plugs sequence [Just 5, Just 6, Nothing, Just 8]
15:29:01 <lambdabot> Nothing
15:29:06 <Cale> @plugs sequence [Just 5, Just 6, Just 7, Just 8]
15:29:07 <lambdabot> Just [5,6,7,8]
15:29:07 <basti_> cooool.
15:29:08 <basti_> thanks.
15:29:18 * basti_ finds ever so often that things have been thought of before
15:29:29 <xerox> So, (->) isn't a type constructor, or is it?
15:29:36 <Cale> xerox, it is
15:29:36 <xerox> I mean, I can't :info (->).
15:29:42 <Cale> it constructs function types
15:29:49 <pipe> Cale: wasssssssssup man?
15:29:51 <Cale> (->) a b
15:29:56 <Cale> is the type of functions from a to b
15:30:03 <Cale> which is also written a -> b
15:30:09 <Cale> pipe, hello
15:30:13 <xerox> hmm
15:30:17 <xerox> Let me find a thing
15:30:44 <xerox> From the report: 6.1.6  Function Types
15:30:44 <xerox> Functions are an abstract type: no constructors directly create functional values.
15:31:06 <Cale> That refers to data constructors
15:31:21 <pipe> Cale: it's me, i used to have a different nick... i'm the dude who made that cheapo haskell raytracer that you helped me with... remember?
15:31:27 <Cale> yeah
15:31:49 <Cale> I noticed that you were wolfman8k by the fact that your username is still set to that :)
15:31:59 <xerox> Oh, yes!
15:32:14 <pipe> hm... indeed it is! but please don't mention that name ever again!
15:35:10 <xerox> Cale, is it possible to write Id in some transparent sense?
15:35:50 <xerox> Maybe it exist an identity type constructor
15:36:50 * basti_ finds ever so often that things have been thought of before
15:36:52 <basti_> wah
15:38:06 <xerox> Something like type Id a = a would probably not be usable everywhere
15:38:54 <xerox> But it "does work" for (->) in some sense, doesn't it?
15:47:23 <xerox> gee, type Id a = a; data Foo m = Foo (m Int);  and  :kind Foo Id  outputs Foo Id :: *  does work O_o
15:51:29 <xerox> but, :type 2 :: Foo Id gives: Type synonym `Id' should have 1 argument, but has been given 0
16:01:21 <Lemmih> Evening, SyntaxNinja.
16:06:25 <SyntaxNinja> greetings master Lemmih
16:06:33 <SyntaxNinja> what does Lemmih mean, anyway?
16:08:59 <Lemmih> I'm done playing around with mod_haskell/HSP and am hacking a binding to libgpgme as we speak.
16:09:09 <SyntaxNinja> sweeeeeet
16:09:28 <SyntaxNinja> btw, I forget; is the xml-rpc stuff a set of bindings, or is it native? did you write it?
16:10:04 <Lemmih> Bjorn Bringert is the author of haskell-xml-rpc.
16:10:41 <xerox> 'night
16:11:12 <SyntaxNinja> cool.  hackage and cabal-get both should get awards for the amount of code reuse they have ;)
16:12:34 <pipe> any medical doctors here by any chance?
16:13:03 <SyntaxNinja> pipe: I hope you're not havnig an emergency
16:13:18 <pipe> no
16:13:29 <pipe> well, i do have a sort of emergency
16:13:31 <autrijus> just seen on #perl6: "You have a weakly symmetric lax monoidol functor -- but don't worry, we can lift it out with a Kleisli operation."
16:13:43 <autrijus> monoidal, even.
16:14:10 <Cale> autrijus: nice :)
16:14:22 <SyntaxNinja> haha
16:14:55 <SyntaxNinja> pipe: if you're wondering if it's an emergency, call a hospital and ask tol talk to a nurse or something.
16:15:16 <pipe> no, it's not really like that
16:16:04 <SyntaxNinja> should an introduction paper to a section have "see section 2.2" when introducing different bits of an architecture?
16:16:04 <SyntaxNinja> pipe: OK :)
16:16:35 <pipe> SyntaxNinja: maybe you can help me? can i pm you? this isn't really something on-topic in this channel
16:17:00 <SyntaxNinja> pipe: I have no medical experience, but you're welcome to pm me.
16:29:23 <wagle> .. i had a emt-a certification once
16:29:37 <pipe> wagle: can i pm you?
16:29:46 <wagle> sure
16:52:18 <mwc> Poll: How sick were you the last time you were too sick to Haskell
16:53:15 <pipe> haskell is a verb?
16:53:31 <mwc> pipe: it's a gerund.
17:01:44 <foxy> does Cabal have a darcs repo?
17:03:18 <SyntaxNinja> foxy: yeah. look on the web page haskell.org/cabal
17:03:39 <SyntaxNinja> foxy: if you're going to hack on it, feel free to ask questions!
17:05:26 <foxy> When I try to run Cabal there's an undefined ref to _SHGetFolderPathA in HSCabal.o, I was going to try and track it down.  I think my version of windows doesn't support that call
17:07:43 <SyntaxNinja> yow.  never heard of that one :)
17:08:13 <SyntaxNinja> sadly, I know nothing of these windows of which you speak; post to the libraires list if you can't figure it out.  thanks for the bug hunting!
17:09:47 <Cale> foxy, which version of GHC?
17:10:30 <Cale> I recall having a similar problem just installing GHC 6.4 on my friend's windows machine when it first came out
17:11:06 <Cale> The problem is that the program needs to be linked with an extra library to run on Win9x than on WinXP apparently.
17:11:51 <wagle> readline/
17:11:52 <wagle> ?
17:12:13 <Cale> no, it's a windows library
17:12:19 <Cale> I can't recall which
17:12:48 <Cale> My bug report might still be on the GHC bug tracker, even though they fixed it
17:19:55 <foxy> Cale 6.4, thanks for the heads up
17:22:14 <foxy> Cale when did you report the bug?
17:23:37 <Cale> a few months ago
17:26:43 <foxy> Cale: was the fix to include that dll file in the Cabal package.conf ExtraLibraries field?
17:29:11 <Cale> foxy: It wasn't specifically about cabal -- GHC wouldn't run at all
17:29:25 <Cale> But it was the same error message
17:29:31 <foxy> ah, I only get the error when package cabal tries to run
17:35:12 <foxy> SyntaxNinja: That error is fixed by adding ShFolder to ExtraLibraries in the package.conf, after installing the dll from windows (for Win9x)
17:38:55 <SyntaxNinja> foxy: can you send me an email about that?  darn. at the moment, we don't have any system-dependent code in cabal's .cabal file.
17:39:31 <foxy> sure, I see that there's mingw specific code in cabal but nothing for cygwin
17:41:33 * SyntaxNinja stares at such windows-related distinctions much like windows users stare at linux distinctions ;)
17:44:19 <SamB> what linux distinctions?
17:47:21 <SyntaxNinja> SamB: for instance, among different shells or distributions
17:47:31 <SyntaxNinja> I use "linux" in the popular sense here ;)
17:47:46 <SamB> can't we just point out the different distributions of XP?
17:47:57 <SamB> Home, Professional, and 2003 Server?
17:49:12 * SyntaxNinja had no idea there was such a distinction.  I don't realy know what mingw is, but I thnk I know what cygwin is
17:50:07 <SamB> mingw is a way to use msvcrt with gcc-compiled programs
17:50:53 <SamB> many people call the version of the GNU toolchain configured for this purpose mingw
17:51:16 <SamB> and I think the installer does too...
17:58:35 <SamB> wow, ##c is a crazy name for a channel... it should be illegal to have more #s than letters in a channel name...
18:04:13 <SyntaxNinja> I think we should add a feature to darcs...
18:04:34 <SyntaxNinja> do you ever find yourself in an SVN or CVS source tree and type "darcs whatsnew" instead of "svn diff"?
18:04:46 <SyntaxNinja> we should just make darcs take over the source tree if someone does that.
18:11:27 <Lemmih> haha
18:35:00 <foxy> when will ghc 6.4.1 be released?
18:37:05 <Lemmih> SyntaxNinja: check your mail.
19:42:00 <dons> afternoon foxy.
19:42:21 <foxy> gday, how bout the Warratahs!
19:43:28 <dons> hehe. pretty good.
19:43:48 <dons> about time they made a final
19:44:33 <foxy> I'm becoming convinced of the need for runtime unification for dynamic types that allows polymorphism (by extending Typeable)
19:44:41 <foxy> like you mentioned earlier
19:44:53 <dons> ah!
19:45:16 <dons> check the hs-plugins paper - that describes the basic idea using pdynload.
19:45:34 <foxy> ok ;)
19:45:36 <dons> I'm currently working on use the -package ghc to call the type checker directly.
19:46:15 <dons> so, unlike the existing Dynamic check:
19:46:16 <dons> fromDynamic (Dynamic t v) =
19:46:16 <dons>   case unsafeCoerce v of
19:46:16 <dons>     r | t == typeOf r -> Just r
19:46:16 <dons>       | otherwise     -> Nothing
19:46:25 <dons> we'd  replace that TypeRep equality with:
19:46:38 <dons>   r | t `unifiesWith` typeOf r -> Just r
19:47:15 <dons> where that's a call to GHC's type checker, and the typereps have to be a complete binary representation of GHC's internal Type data type
19:49:32 <foxy> nice
19:50:27 <foxy> can you give a polymorphic type to pdynload? > pdynload "Plugin.o" ["api"] [] "a -> a" "resource"
19:51:02 <dons> yep. it's just a string inserted into a .hs file
19:52:21 <dons> have a look at $hs-plugins/examples/pdynload/poly*
19:54:29 <dons> btw, have a bibliography of papers in this area: www.cse.unsw.edu.au/~dons/safe.html
19:54:46 <foxy> so if I have "data Fun where Fun :: forall a.a -> Fun" can I wrap up any possible function? > pdynload "Plugin.o" ["api"] [] "Fun" "resource"
19:56:25 <dons> I think so. if _ = Plugin.resource :: Fun makes sense
19:56:44 <dons> that's the test pdynload uses.
19:57:36 <dons> oh, i think pdynload expects Fun to be qualified: i.e. API.Fun
19:58:49 <dons> note that each time you call pdynload, ghc is going to be called. so there's performance consequences. but if it's the only way to do something..
20:01:06 <foxy> One way I had thought of was using TH to embed the type of an expression, and then use that info at runtime
20:01:55 <foxy> in say a funapp :: (Type,Fun) -> (Type,Fun) -> (Type,Fun)
20:01:58 <dons> that's how I was going to do type reps in the args to unify. because we can represent most ghc types inside [| |]
20:02:24 <dons> it's effectively a way of getting GHC data types out of GHC
20:02:48 <dons> btw, have you read "Type-Safe Cast", Weirich -- she discusses the heterogeneous symbol table problem.
20:03:08 <foxy> Is that the TAL/Load paper?
20:03:14 <dons> nope.
20:03:29 <foxy> is it on your bibliography?
20:04:13 <dons> yep.
20:04:30 <dons> entry 4 in the dynamic typing section
20:06:30 <foxy> I don't have access to that portal
20:06:44 <dons> I'll find you a url
20:07:14 <dons> by the looks of it, she can store polymorphic values in the table, as long as you search for them with a monomorphic type
20:07:25 <foxy> I found a copy
20:07:44 <dons> should be a link from her website anyway
20:09:33 <dons> I see: table = insert (cfFn cfInt cfInt) t2 ("add1", (\x->x+1))
20:11:41 <dons> and you've read "Strongly Typed Heterogeneous Collections"?
20:12:24 <foxy> Is that the HLists paper? If so yup
20:12:35 <dons> (though Sean seemed to think the GADT solution was basically the same as HLists)
20:12:38 <dons> but simpler!
20:13:20 <dons> hmm. one idea I just had is to use the Module type as a sort of Dynamic
20:14:09 <dons> a table of [(String,Module)] would let us map strings to functions in .hs files, that've been dynamically loaded.
20:14:31 <dons> hmm...
20:27:17 <foxy> The problem with HLists is that their indexed by a type
20:27:27 <foxy> s/their/they're/
20:30:36 <dons> hehe. got a neat h-sym-table using Eval and TH.. I'll mail it to you
20:31:24 <dons> it delays compilation (and type checking) of table elements until they're required.
20:41:10 <dons> you'll like this foxy..
20:41:11 <dons> *M> lookupH "c" >>= \(fn :: a -> (a,a)) -> print $ fn 'c'
20:41:11 <dons> ('c','c')
20:41:11 <dons> *M> lookupH "c" >>= \(fn :: a -> (a,a)) -> print $ fn "foo"
20:41:11 <dons> ("foo","foo")
20:42:17 <foxy> ooo %)
20:45:23 <dons> sent.
20:46:16 <dons> has to be a prize for using both compile time meta programming, and runtime meta programming, in the same module :}
20:47:05 <foxy> heh
20:50:31 <foxy> fancy!  Is it possible to insert polymorphic values dynamically?
20:50:43 <dons> I *think* so. Let's see..
20:51:46 <foxy> So you call eval which runs TH every time you insert something?
20:52:08 <dons> eval runs ghc. we only use TH so we can reuse the [| |] syntax
20:52:38 <dons> eval gets run when we *retrieve* something from the table -- to compile the [| foo |] code into a real Haskell value
20:53:13 <foxy> hm, so the inserted value is plain text?
20:53:38 <dons> yep. it's a unevaluated call to: eval "foo"
20:55:35 <dons> *M> let table' = ("x", delay [| \x -> x |]) : table
20:55:39 <dons> *M> lookupH "x" table' >>= \(f :: x -> x) -> print $ f 1
20:55:39 <dons> 1
20:55:39 <dons> *M> lookupH "x" table' >>= \(f :: x -> x) -> print $ f ()
20:55:40 <dons> ()
20:56:29 <foxy> :)
20:57:08 <dons> the e' <- e, is like a $( ) in TH, and delay [| |] directly corresponds to [| |]
20:57:23 <dons> the difference being that our splices are happening at runtime
20:57:33 <dons> hmm. this is pretty crazy stuff
20:58:13 <foxy> I dubious about having raw code sitting in a data type, I'd rather have a compiled function
20:59:05 <foxy> but it does work!
20:59:16 <dons> well, it's the same as passing around [| |]
20:59:28 <dons> it does work. that's true. and just the way we want, right?
20:59:45 <dons> and only required Unsafe,Eval and TH :D
21:02:38 <dons> they're not even that magic. TH and Unsafe could be merged into a Meta module, so that all is exported is the 'delay' and 'splice' functions, where delay == [| |], and splice = e >>= \v -> return v
21:12:13 <dons> now, of course, if you provide the wrong type annotation when you retrieve the value, you're in trouble:
21:12:16 <dons> *M> lookupH "c" >>= \(fn :: a -> (Int,a)) -> print $ fn "foo"
21:12:19 <dons> (zsh: segmentation fault (core dumped)  ghci -v0 M.hs
21:13:23 <dons> as type constraints in the table aren't propagated outside. if we also paired values with their type representation, then we'd be ok (or used the safe 'eval :: Typeable a => String -> Maybe a')
21:13:58 <dons> however, this mightn't be too much of a problem, as the program does both the insertion and retrieval, so presumably knows the type.
21:14:41 <foxy> Hm, I',m thinking about automagic retrieval, where the application graph is generated at runtime
21:15:14 <foxy> which is why I keep thinking about runtime unification
21:16:11 <dons> we can provide monomorphic types for poly values too:
21:16:11 <dons> *M> lookupH "c" table >>= \(fn :: Int -> (Int,Int)) -> print $ fn 1
21:16:12 <dons> (1,1)
21:18:33 <machack666> questions, questions, always more questions... :D
21:19:50 <foxy> here the type annotation is provided at compile time.  I'd like something that occurs at runtime...
21:19:52 <machack666> I'm using Parsec to parse a fixed format section, where I'd like to extract records of a fixed size and then read out parts of them, but I cannot see operations which let me specify (for instance) the number of times to run a parser
21:20:35 <machack666> My thought is that I could use something like take to grab out the number of bytes that I need, but I believe that take is destructive... is this true?
21:20:40 <SyntaxNinja> you could use (sequence . replicate)
21:20:50 <SyntaxNinja> @type replicate
21:20:51 <lambdabot> replicate :: forall a. Int -> a -> [a]
21:21:11 <machack666> @type sequence
21:21:13 <lambdabot> sequence :: forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
21:21:36 <dons> foxy, yeah. so I can see two options. 1. we extend typereps to handle polymorphic values (i.e. runtime unification) or 2. you implement an interpreter for a simple expression language, with enough expressibility to encode the values you have in symbol tables. then you can run your own type check on the expression language.
21:22:03 <machack666> thanks SyntaxNinja I'll try that out
21:22:03 <dons> 3. we hook into ghci at runtime..
21:22:36 <dons> 3. is a case of 1., where the typereps are actually GHCs. much like pdynload.
21:23:50 <foxy> dons: yup.  I think (1) is the most elegant and (2) is a reasonable solution.  I'm essentially being lazy and using haskell as my expression language, hence the attempt to get GHC to do the typechecking
21:24:25 <foxy> Why reinvent the wheel! :P
21:26:12 <machack666> SyntaxNinja: that worked great--figured there was a higher-order way of doing that.
21:26:48 <SyntaxNinja> machack666: cool
21:48:33 <foxy> SyntaxNinja: where does the executable name get defined in Cabal?
21:50:52 <foxy> SyntaxNinja: ".exe" is not appended to the executable name in Install.hs in the step which copies the executable to the target directory
21:51:02 <foxy> (on windows)
21:52:52 <foxy> machack666: count  :: Int -> GenParser tok st a -> GenParser tok st [a]
21:54:03 <foxy> @type Text.ParserCombinators.Parsec.count
21:54:05 <lambdabot> Text.ParserCombinators.Parsec.count :: forall a st tok.
21:54:05 <lambdabot>              Int
21:54:05 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st
21:54:05 <lambdabot> a
21:54:05 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [
21:54:06 <lambdabot> a]
22:05:09 <SyntaxNinja> foxy: are you saying that .exe doesn't ever get appended, or are you asking where it gets appended?
22:05:25 <foxy> it doesn't ever get appended
22:05:54 <SyntaxNinja> hm. that stinks.  it's in the Executable type in PackageDescription
22:06:04 <SyntaxNinja> so look for "withExe" functions
22:06:05 <foxy> so the copy command fails with file not found (It looks for "foo" not "foo.exe")
22:06:32 <SyntaxNinja> wait, so it outputs foo.exe, but copy / install looks for foo?
22:06:40 <foxy> yup
22:06:49 <SyntaxNinja> we clearly need more windows users... don't quote me on that
22:06:59 <SyntaxNinja> look for "exeName"
22:10:54 <foxy> I've found its uses in Install.hs but I can't find where its defined
22:11:19 <SyntaxNinja> what do you mean defined?
22:12:09 <SyntaxNinja> it's directly from the package description file; so it's value will be something like "foo", not "foo.exe" so you should change the spots where its used
22:13:03 <SyntaxNinja> or write a functino like "exeFileName :: PackageDescription -> FilePath" which is exeName on unix and (joinExt (exeName p) "exe")
22:13:20 <foxy> ah, its a field label, that's why it wasn't in an export list
22:15:19 * SyntaxNinja nods
22:30:19 <dons> bad Lemmih.
22:32:51 <Lemmih> Bored Lemmih.
22:32:54 <Cale> bad Lemmih?
22:34:50 <dons> ["lambdabot",":@moo"]
22:34:51 <dons> ["lambdabot",":@moo"]
22:34:52 <dons> ["lambdabot",":@moo"]
22:34:53 <dons> ..
22:34:58 <dons> Running reader loop...
22:34:58 <dons> NOTICE: ["AUTH",":*** Looking up your hostname..."]
22:34:59 <dons> ...
22:35:39 <dons> we should sort out that flood control stuff one day
22:37:46 <SyntaxNinja> dons: is Lemmih trying to crack you again?
22:38:04 <Lemmih> I was just mooing!
22:38:09 <dons> oh, yeah. seems so! the moo-exploit, it seems.
22:38:16 <dons> :P
22:38:54 <SyntaxNinja> Lemmih: moos must be used for good, instead of evil
22:38:57 <foxy> how do I pass flags to LD on the ghc command-line?
22:39:04 <SyntaxNinja> dons: btw, did you see my randyCow program?
22:39:22 <dons> umm. i'm scared to ask..
22:39:25 <Lemmih> foxy: -optl flag
22:39:28 <dons> foxy, -optl
22:39:32 <SyntaxNinja> @paste
22:39:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:39:37 <Lemmih> I win!
22:39:40 <dons> doh!
22:39:58 <Cale> A throttle of 80 chars/second averaged over 5 seconds seems to work well
22:40:27 <dons> ok. good idea.
22:40:42 <SyntaxNinja> dons: it might make a good moo pluggin, but I don't know the right way to pipe the output of a program into the input of another in Haskell ; I just use system |
22:41:30 <dons> you can plug together PosixCompat.popen
22:41:40 <foxy> SyntaxNinja: I'm getting the undefined SHFolderPath when trying to run 'make install' on Cabal
22:41:40 <dons> in lambdabot. it's on top of forkProcess
22:42:22 <dons> (out,err,exit_status) <- popen "foo" in1; (out',err',exit2) <- popen "bar" out
22:42:31 <dons> hmm. we need a pipe monad.
22:42:49 <SyntaxNinja> foxy: ok
22:44:14 <dons> let s = runPipe (foo |>> bar) or so.
22:44:47 <SyntaxNinja> isn't there a new module to make htis easier?
22:44:53 <Lemmih> dons: I've mailed you another patch for hs-plugins.
22:45:04 <SyntaxNinja> at least he mails patches while cracking
22:45:27 <dons> yeah, as long as they're not more @moo back doors
22:45:35 <dons> ;)
22:45:48 <SyntaxNinja> @moo
22:45:49 <lambdabot>           (__)
22:45:49 <lambdabot>           (oo)
22:45:49 <lambdabot>    /-------\/
22:45:49 <lambdabot>   / |     ||
22:45:49 <lambdabot> ~~~~~~~~~~~~~~
22:45:50 <lambdabot>  
22:45:52 <lambdabot>  Cow in water
22:46:25 <dons> thanks Lemmih! nice patch
22:52:18 <foxy> SyntaxNinja: Is there a way to build cabal without using the Cabal package of ghc?
22:52:56 <dons> libs that build with cabal require ghc 6.4, is that right?
22:53:42 <SyntaxNinja> foxy: if you run "make setup" it should use the one in the current directory, not hte one that comes w/ ghc
22:53:58 <SyntaxNinja> you mgiht have to hide the one that comes with ghc though
22:57:32 <SyntaxNinja> we're working on a process to fix that problem
23:32:55 <foxy> @moo
23:32:56 <lambdabot>            (__)
23:32:56 <lambdabot>            (oo)
23:32:56 <lambdabot> ~~~~~~~~~~~~~~~~~~~~~
23:32:56 <lambdabot>  
23:32:56 <lambdabot>  
23:32:57 <lambdabot>  
23:32:59 <lambdabot>     Cow in trouble
23:33:08 <foxy> @vixen The Cow needs you.
23:33:14 <lambdabot> ever just get the urge to go out and kill a puppy?
23:33:38 <foxy> @vixen you're evil!
23:33:42 <lambdabot> are you coming on to me?
