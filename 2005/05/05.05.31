00:12:55 <Lemmih> @paste
00:12:56 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:03:54 <nlv11757_> watskeburt
01:08:04 <Itkovian> meuning
01:15:33 <nlv11757_> meuning, watskeburt
01:24:36 <SM_ax> Now to make a hash with O(log n) access time in haskell?
01:25:24 <Lemmih> @docs Data.Map
01:25:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
01:26:20 <SM_ax> oh, thx
01:26:49 <Lemmih> @libsrc Data.Map
01:26:50 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Map.hs
01:29:44 <Itkovian> anybody participating: http://icfpc.plt-scheme.org/ ?
01:31:10 <SM_ax> Lemmih, actually was more interested in link, provided in that documentation :)
01:31:45 <SM_ax> ltkovian, I think I will
01:32:25 <SM_ax> but i really doubt that I'll be using functional lang
01:37:08 * juhp wonders again when ghc will be able to make shared libs on Linux
01:40:15 <juhp> it is already possible on OSX and windows right?
01:40:18 <juhp> bsd?
01:44:58 <dcoutts> juhp, I think the windows dll support bitroted but the OSX PIC shared lib stuff is of course new and the way of the future! :-)
01:45:12 <juhp> aha
01:45:38 <juhp> so no dll even on windows - hmm
01:57:45 <Si\> can you use continuation monads to find alternative answers in a backtracking monad?
01:59:47 <Si\> like in Prolog
02:06:20 <musasabi> Si\: isn't list + some other monad good for that also.
02:06:38 <Si\> I don't know, that's why I'm asking
02:06:55 <musasabi> you probably could use ContT (or a variant of it) but that does not seem like the clearest way.
02:07:34 <musasabi> http://www.nomaware.com/monads/html/xformerexamples.html#example24 seems quite relevant.
02:08:02 <Si\> well, it's just I'm thinking if you've got a bunch of operation composed with mplus, it ought to be possible to continue to get another answer
02:09:52 <nlv11757_> hmmmm possible exceptions being thrown is kind of not nice if you want to make a control flow graph
02:12:49 <musasabi> nlv11757_: not nice as in "I have been three days redesigning because of that" ;)
02:40:31 <nlv11757_> heheh musasabi, actually im quite simple in my solution...screw C programs using microsoft C extensions for exception handling
02:40:34 <nlv11757_> :D
04:13:27 <nlv11757_> leading text: \end{pboxed} :S
04:13:33 <nlv11757_> how annoying is finding that one
04:15:58 <bourbaki> moin
04:18:30 <Itkovian> noon
04:28:06 <musasabi> What are the correct terms for "supporting only a single return value" and "supporting multiple return values"? (like for arguments polyadic vs monadic)
04:49:08 <Itkovian> erm ...
04:49:28 <Itkovian> as in their types or the actual number of values?
04:49:31 <Philippa_> musasabi: take a look at the logic programming literature? They're most likely to have something
04:51:12 <musasabi> Philippa_: thanks will have to do something like that.
04:51:49 <Philippa_> is logic programming the context by any chance?
04:51:57 <Philippa_> Or will you be talking about the use of tuples to fake it, or?
04:52:34 <Lor> In logic programming (if that means prolog and the like) you cannot really distinguish between input and output arguments.
04:52:51 <wli> Mercury can and does.
04:52:55 <musasabi> not logic programming..
04:53:09 <Lor> Yes, but mercury is more limited than prolog.
04:53:28 <wli> If you say so.
04:54:17 <Lor> In prolog, a single argument can contain both input and output at the same time. In mercury that is not possible.
04:54:47 <musasabi> a function which will return the values it is passed as a value, and how this is hard in Haskell.
04:55:37 <musasabi> f (a,b) => return one value (a,b), f a b => return two values a and b i.e. (a,b)...
04:56:00 <wli> I'm not entirely convinced of that. I think I could express such in its mode system with a custom mode.
04:58:46 <Philippa_> musasabi: it's fixable with a sufficiently powerful tuple type (which Haskell doesn't have, but haskell-with-GHC-exts-and-subtyping could have)
04:59:43 <musasabi> Philippa_: like HLists?
05:00:39 <Philippa_> yeah, those work too :-)
05:00:41 <musasabi> I tried something like that but I ran into problems trying to avoid having to explicitely specify End markers to the tuples.
05:00:43 <blackdog> ...responding 24 hours later, there doesn't seem to be much point optimising sudoku solvers for speed. i haven't been able to find a problem which takes more than .2 seconds in my dumb-as list-based exhaustive solver.
05:01:06 <blackdog> should anyone care.
05:01:18 <dons> hey blackdog
05:01:36 <Philippa_> yeah. Which is why I'd like that subtyping thing into GHC-Haskell. If it makes Haskell 2 you could then have ordinary tuples be syntactic sugar for this datatype which then gets optimised back to a tuple rep and possible tags if the user ever pattern-matches on the tuple size
05:02:09 <blackdog> g'day don. hey, heard Spoon's new one? Ben keeps raving about it to me...
05:02:46 <musasabi> "data a :.: b = a :. b" basic tuple constructor, data END = END, and then have types like, Chan (Int :.: Int), but that seems hard (getting the END to the right place...)
05:02:57 <dons> blackdog, heard a bit on 2ser, iirc.
05:03:54 <musasabi> with typelevel lambdas it would be easy, but I am not quite sure how to do a transformation to put an END to the right place with typeclasses.
05:05:01 <musasabi> Basically newtype Chan a = Chan (a `nestEndProperlySomeHow` END)
05:05:44 <dons> hmm. there's an OS written in OCaml
05:05:55 <musasabi> Philippa_: if you end up doing something to that end please let me know...
05:10:51 <nlv11757_> in lhs2tex, can you find out the current filename...
05:10:59 <nlv11757_> im about to do something realllly dirty
05:11:16 <Itkovian> Philippa_: nice last entry on the journal :-)
05:25:44 <Philippa_> Itkovian: ?
05:26:01 <Philippa_> ah, yeah. Damien's standing behind me, btw :-)
05:26:19 <Itkovian> er, no need to go into detail there
05:26:36 <Philippa_> clothed. As am I, much as I spend enough time NIFOC :-)
05:28:14 <Itkovian> well, geeks can't be bothered to dive through the clothing heap on the way to the nearest machine, can they ...
05:29:53 <Philippa_> or there's the time between showering and getting dressed, or...
05:29:55 <musasabi> Clothes are nice to keep one warm, but usually a blanket is the perfect solution.
05:30:08 <Philippa_> right now it's hot enough round here not to particularly need either
05:31:13 <tuomov> PSU outflow keeps feet warm so no socks are needed
05:31:13 <Itkovian> same here, but with three guys in the same office, one can hardly take of too much coverage ;-)
05:31:18 <Itkovian> lol
05:31:29 <Itkovian> actually, my machine is running quite cool
05:31:42 <Itkovian> despite being loaded all the time
05:31:56 <tuomov> my machine isn't loaded, and it's still hot
05:32:12 <tuomov> hmm... I wonder if my extra chassis fan has stopped again..
05:32:48 <tuomov> no. It's just getting rather hot in this flat this time of the year
05:33:02 <tuomov> but ATM it's too cold outside to keep the door open
05:33:21 <Itkovian> well, I have a nice Athlon with a Barton core, and a fan that goed right through the side of the machine, preventing hot air fwloing around on the case inside
05:33:39 <musasabi> tuomov: actually it is just right to sleep outside on the balcon on nights.
05:33:50 <tuomov> I have an athlon xp 2500+ in an old pentiumpro case (circa 97)
05:33:56 <Itkovian> and the power supply fan isn't even running half its possible speed
05:33:59 <musasabi> summer + inside => unbearable.
05:34:15 <Itkovian> summer + outside = wet ... mostly
05:35:33 <Philippa_> Itkovian: was the anonymous comment I just got from you by any chance?
05:35:36 <tuomov> musasabi: yeah, but opening the door would mean putting on more clothes..
05:35:43 <Itkovian> nope
05:36:04 <Philippa_> just wondering
05:36:13 <Philippa_> 'twas to a vaguely relevant meme, that's all
05:36:13 <boegel> Philippa_: comment ?
05:36:23 <Philippa_> boegel: to a livejournal post
05:36:44 * earthy nods
05:36:49 <Itkovian> boegel: u should _sign_ yr thesis!
05:36:52 <earthy> a somewhat unbelievable livejournal post. ;)
05:37:01 <nlv11757_> hmm
05:37:11 <Philippa_> earthy: I wasn't the originator of that particular meme :-)
05:37:20 <Itkovian> earthy: depends on the bf, and the activity preceding the diablo download, no?
05:37:25 <Philippa_> oh, that one
05:37:29 <boegel> Itkovian: ow :s I've signed the one I handed in though
05:37:32 <Philippa_> Damien's just nerdy and easily distracted
05:37:35 <Itkovian> not mine :-)
05:37:37 <boegel> wasn't sure I had to sign your copy too
05:37:38 <nlv11757_> when i use the SELF copy rule, it uses constructors like "Tuple_StringTypAttributes__Tuple"...is there also a flag that generetes these?
05:37:39 <Philippa_> hell, easily distracted from distractions
05:37:46 <earthy> philippa: *very* easily distracted
05:37:47 <boegel> I only signed 1 copy
05:37:51 <earthy> even more easily than I am
05:37:52 <Itkovian> ah
05:37:54 <Itkovian> ;-)
05:38:02 <Philippa_> yeah, I couldn't help laughing when he said it
05:38:08 <boegel> Itkovian: why do you want my signature ? am I _that_ famous ? :p
05:38:14 <Philippa_> ah well, got stuff to do
05:38:15 <Philippa_> later
05:38:22 <boegel> anyone entering the ICFP contest this year ?
05:38:29 <Itkovian> btw, I hardly did anything .. so you might have oimitted my in the foreword
05:38:37 <Itkovian> boegel: asked them this morning
05:38:47 <Itkovian> later
05:38:58 <boegel> yes you did, you read it and corrected some stuff
05:39:16 <boegel> Itkovian: we'll, is anyone joining ?
05:39:22 <Itkovian> hmm, don't recall that
05:39:28 <Itkovian> the helping I mean
05:39:31 <boegel> I don't have time thoug, I'm going on a trip 10 of July
05:39:40 <Itkovian> anyway, yeah, somebody mentioned he/she might have a go at it
05:39:43 <boegel> otherwise I'd try and join
05:39:49 <Itkovian> go ahead.
05:39:59 <boegel> not that I'd win or anything, but it seems like fun
05:40:01 <Itkovian> it won;t be a raytracer though
05:40:03 <Itkovian> :-)
05:40:09 <boegel> Itkovian: I know :)
05:40:18 <boegel> maybe something with L-systems :)
05:42:37 <blackdog> i think don's having a go. I'd be there too, 'cept i'll be in the air for most of it.
05:43:08 <boegel> ok nice
05:43:53 <blackdog> it's a real pity, i've been trying to get don to have a go for two years now, and the first year he's willing, i'm gone.
05:44:48 <boegel> why are you gone ?
05:45:11 <blackdog> doing a bike ride through thailand+cambodia+vietnam. doubleplusgood.
05:45:17 <boegel> nice
05:45:55 <blackdog> 5 weeks without a laptop, though. bit weird.
05:46:07 <boegel> I wouldn't have a problem with that
05:46:13 <nlv11757_> hey maybe you'll even survive it blackdog
05:46:46 <blackdog> there's every chance. :)
05:49:12 <Lemmih> Yay. I've upload the first secure package to HackageDB with cabal-put!
05:49:32 <musasabi> Lemmih: congratulations :-)
05:51:02 <nlv11757_> hah, bug in uuagc
06:00:13 <Itkovian> the contest livecd may be worth fetching ...
06:01:44 <timbod> morning - anyone got any guesses as to what the icon on the contest page might represent?
06:03:12 <Itkovian> nope
06:03:26 <Itkovian> memory regions ...
06:03:37 <Itkovian> as in codewars stuff
06:03:39 <Itkovian> ?
06:04:14 <timbod> It got methinking of cellular automata...
06:06:02 <Itkovian> similar ...
06:16:17 <boegel> timbod: a bitmap ? :) raytracing ? :p
06:16:43 <boegel> maybe it's just random, so people will go look for some reason behind it :)
06:17:50 <Itkovian> maybe it's the ants from last? year
06:21:05 <timbod> boegel: I hope not raytracing again
06:23:14 <timbod> I just looked at the pic again - has it changed since yesterday? I don't remember the middle row being solid white before (or perhaps I just didn't look close enough).
06:27:37 * CosmicRay looks in, finally!
06:27:40 <CosmicRay> metaperl: http://sequence.complete.org/node/64
06:27:54 <metaperl> ...
06:28:17 <CosmicRay> metaperl: I have no idea why that example managed to be so huge
06:28:39 <CosmicRay> it is certainly a very non-Haskell-ish solution, with the state monad and everything
06:28:50 <metaperl> oh...
06:28:55 <CosmicRay> looks like it was written by someone very determined to do imperative programming in haskell or something
06:29:00 <metaperl> :)
06:29:57 <Cale> yeah, I was thinking that too, back when he posted it. I was going to write a proper solution, but I had other things to do at the time. Speaking of which, I'd better run :)
06:30:03 <metaperl> :)
06:30:07 <CosmicRay> heh
06:30:22 <metaperl> now why would the sample code at Aetion be so shabby?
06:30:43 <metaperl> the company seems to do neat work with Haskell
06:30:53 <CosmicRay> I don't know.  where did you find that link?
06:30:56 <Cale> Perhaps it was an example for using StateT
06:31:01 <CosmicRay> that could be
06:32:45 <Cale> and ErrorT. There's no real reason in this case to override Haskell's default error handling.
06:32:52 <CosmicRay> right
06:33:11 <CosmicRay> my 5-line program is pretty simple and I didn't even spend any time trying to make it short.
06:33:21 <CosmicRay> I just wrote the solution that naturally occured to me
06:33:29 <metaperl> CosmicRay: it was at their website under "About" --- they said you should be able to demonstrate use of monads to work here: http://www.aetion.com/jobs.html
06:33:40 <boegel> timbod: nah, I was just joking
06:33:58 <CosmicRay> metaperl: ah.
06:34:20 <CosmicRay> metaperl: I suspect Cale was right then; it was specifically designed to be a moderately-complex example of using monads
06:35:14 <metaperl> its actually one line in Perl if you dont have to recurse a directory tree
06:35:40 <Itkovian> metaperl: well, as perl uses ';' to separate statements, anything can be on one line ;-)
06:35:54 <metaperl> (sort { $a <=> $b } opendir '.')[0]; # should work
06:35:55 <CosmicRay> the example, which I imitated, opens each filename given on the command line, counts the number of lines (not bytes!) in each, and then prints the one with the highest number
06:35:56 <TheHunter> the Stack and StackM programs could be considerably shortened too...
06:36:47 <CosmicRay> metaperl: doesn't that just sort by filename?  (it seems to be solving a different problem)
06:37:11 <metaperl> not only that, it doesnt work :)
06:37:21 <metaperl> oh, file *length* is what we want
06:37:22 <CosmicRay> heh
06:37:27 <CosmicRay> by lines.
06:37:38 <CosmicRay> so you can't just use stat() :-)
06:37:46 <metaperl> oh, now things get longer unless I use wc -l
06:38:00 <CosmicRay> that's cheating :-)
06:38:05 <metaperl> heh
06:38:38 <metaperl> my @lines = split /\n/, (<F>); my $length = scalar @lines; # presuming file can fit in memory
06:39:02 <metaperl> my $length = scalar (split /\n/, (<F>)) ;
06:39:02 <CosmicRay> yes, see, haskell has you beat there, I think
06:39:07 <metaperl> oh ?
06:39:24 <CosmicRay> a proper perl implementation would probably have a loop reading one line at a time and incrementing a counter
06:39:25 <arcasin> Umm.. hello. First I would like to say that when joining Haskell channel it's very interesting that first line said is perl code
06:39:42 <metaperl> arcasin: we are comparing a Haskell and Perl implementation of something
06:39:43 <CosmicRay> my haskell example doesn't require the file to fit in memory
06:39:47 <metaperl> arcasin: welcome!
06:39:52 <arcasin> metaperl: fine definition and thank you
06:39:57 <metaperl> CosmicRay: laziness to the rescue
06:40:37 <CosmicRay> arcasin: welcome.  we are discussing http://sequence.complete.org/node/64 fwiw, but feel free to change the topic :-)
06:40:38 <CosmicRay> exactly
06:41:17 <CosmicRay> my perl skillz are rusty, but I don't think I could write a Python version that is any shorter than the Haskell one
06:42:02 <arcasin> yeah, I have a problem. I'm very new to Haskell and I'm reading this tutorial: http://haskell.org/~pairwise/intro/. I'm using hugs and when I try for example this simple fibbonacci example, it complains about unexpected comma in line fib :: Num a, Num b => a -> b
06:42:31 <arcasin> or any other type line with commas between, euh, class definitions, I guess
06:42:50 <wilx> Use ().
06:43:36 <arcasin> wilx: thank you, it works indeed!
06:43:48 <arcasin> I'm too slow :(
06:43:52 <metaperl> arcasin: buy a good book on Haskell ... the free resources are not very good
06:44:00 <arcasin> metaperl: I've noticed that
06:44:08 <metaperl> i recommend "Craft of Functional Programming" by Thompson
06:47:09 * Lemmih wonders what's wrong with the online tutorials.
06:47:45 <reffie> other than the fact that they suck?
06:48:35 <metaperl> lol @ reffie
06:48:44 <metaperl> Lemmih: how did you learn Haskell?
06:48:59 <metaperl> I think I tried to rush too fast with the free online stuff
06:49:08 <metaperl> I am taking Thompson's book step by step
06:49:26 <metaperl> I  _was_ happy with my progress up until a month ago
06:49:32 <metaperl> now I need to get back on track
06:50:05 <Lemmih> I got lured in by the online tutorials and later bought a book
06:50:14 <metaperl> a book... which?
06:50:34 <metaperl> Lemmih: are you planning to goto undergrad or grad school ?
06:50:39 <Lemmih> "The Craft of Functional Programming".
06:50:48 <metaperl> yes, that's the book I'm using
06:51:02 <Itkovian> ttyl
06:52:41 <nlv11757_> just do TaPL
06:52:42 <nlv11757_> :P
06:53:23 <Lemmih> metaperl: Yeah I am. Not sure if I can get accepted with my current level of education, though.
06:53:29 <metaperl> which?
06:54:03 * Lemmih bets he's the only high-school drop out in #haskell.
06:54:32 <nlv11757_> how old are you Lemmih if i may ask
06:54:46 <nlv11757_> all these different school systems prevent me from finding it out :)
06:54:49 <Lemmih> I'm 18 years old.
06:55:59 <nlv11757_> ah thats about the age you go to university right
06:56:00 <nlv11757_> ?
06:56:14 <Lemmih> Yeah.
06:56:55 <nlv11757_> then it doesnt differ that much i guess
06:59:44 <nlv11757_> but Lemmih, what do you currently do then for money?
06:59:46 <Lemmih> Well, I'm kinda stuck until I learn how to bend the rules.
07:00:29 <boegel> Lemmih: I had NO idea you're only 18
07:00:41 <Lemmih> nlv11757_: I got some savings in the bank.
07:00:42 <boegel> you're just a script kiddie then ? :)
07:00:48 <Lemmih> boegel: (:
07:03:05 <nlv11757_> better not stay too long in this position
07:05:46 * CosmicRay returns
07:06:56 <CosmicRay> imho, the best online tutorial is YAHT, http://www.isi.edu/%7Ehdaume/htut/
07:07:02 <CosmicRay> several of us are working on a new one
07:07:12 <CosmicRay> darcs get http://darcs.complete.org/haskell-v8 if you are interested in contributing
07:07:15 <dcoutts> Lemmih, did I answer your question about cabal features sufficiently?
07:07:20 <CosmicRay> it is not yet to the point where it would be something good to learn from
07:08:32 <Lemmih> dcoutts: Yes, and thanks a lot.
07:08:36 <dcoutts> cool
07:09:25 <dcoutts> so are there any plans for cabal features to support more complex packages?
07:11:09 <Lemmih> Yeah, but we're still in the poke-it-with-a-stick phase.
07:12:13 <dcoutts> well if you ever get anything less squidgey then give me a shout and I'll see if I can give any useful feedback
07:12:49 * Lemmih hops back to his dev box.
07:40:17 <analpear> is there a way to have a function recurse while some condition is true?
07:41:11 <nlv11757_> what should it do when the condition is false?
07:41:41 <analpear> finish
07:41:56 <dcoutts> analpear, let myRecursiveFunc param = if condition then finalResult else myRecursiveFunc (f param)
07:42:43 <analpear> what im doing is very simple just want to return the first word from a string
07:42:46 <analpear> so i look for the first space
07:42:54 <nlv11757_> yeah or with case statements, guards, pattern matching. whatever
07:43:07 <nlv11757_> ow thats even simpler
07:43:20 <nlv11757_> head . words
07:43:25 <chris2> can anyone point me to papers on ANF available online?
07:43:29 <analpear> firstword (x:xs) = x : (firstword xs) "as long as !isSpace(x) remains true"
07:43:32 <nlv11757_> @plugs head . words $ "bla foo bar"
07:43:38 <lambdabot> "bla"
07:43:51 <nlv11757_> or
07:44:15 <nlv11757_> @plugs takeWhile (/=' ') "bla foo bar"
07:44:17 <lambdabot> "bla"
07:44:27 <nlv11757_> or
07:44:46 <nlv11757_> but if you want to do it recursively like in your function
07:44:47 <nlv11757_> do this
07:45:19 <nlv11757_> firstword (x:xs) | x /= ' ' = x: firstword xs
07:45:34 <nlv11757_>                   | otherwise = []
07:45:45 <nlv11757_> that will work too
07:45:59 <analpear> i don't get the x /= ' ' = x
07:46:02 <analpear> why the = x bit?
07:46:09 <nlv11757_> double ==
07:46:14 <nlv11757_> ow no
07:46:19 <analpear> it says such that x is not an empty character
07:46:20 <nlv11757_> that is a guard
07:46:37 <nlv11757_> so only when the part between | and = is true the part to the right of the = will be the answer
07:47:10 <analpear> ah
07:47:17 <nlv11757_> firstword (' ':_) = []
07:47:25 <analpear> what if you have equals in your boolean expression ?
07:47:27 <nlv11757_> firstword (x:xs) = x: firstword xs
07:47:29 <nlv11757_> will also work
07:47:35 <analpear> example
07:47:53 <analpear> | x = 5 = x : firstword xs
07:48:02 <analpear> will that work or will there be ambiguity
07:48:05 <nlv11757_> the first = should be ==
07:48:10 <nlv11757_> in haskell  equals is ==
07:48:10 <analpear> ahh of course
07:48:15 <analpear> ok
07:48:16 <analpear> thanks
07:48:34 <nlv11757_> is there a reason to do it recursively? cause using standard functions in this case is more beautiful
07:48:47 <analpear> hmm not really
07:49:02 <analpear> but i don't know any of the standard functions
07:50:29 <analpear> and the otherwise clause(?) is a standard thing to use?
07:50:59 <analpear> these are disjoint conditions : x is either an empty space or it's not
07:51:09 <nlv11757_> otherwise is the same as True
07:51:16 <nlv11757_> so that guard will always be taken when encountered
07:51:21 <analpear> ah
07:51:30 <analpear> so it goes down the guards from top to bottom
07:51:34 <nlv11757_> yep
07:54:49 <analpear> could anyone explain briefly how the waterfall approach to programming works? i tried googling but had no real luck
07:54:55 <analpear> also wikipedia doesn't seem to have an entry on it
07:55:09 <analpear> and im having difficulty distinguishing it from "spiral" programming and "extreme" programming
07:55:13 <analpear> what are the main distinctions of each?
07:55:59 <esap> Waterfall assumes that one phase is complete before the next one is started. [That part is why waterfall is often not used exactly as such].
07:56:32 <nlv11757_> yeah
07:56:46 <nlv11757_> so first complete functional design, then complete implementation, then testing etc
07:56:50 <esap> And each phase is pretty heavy-weight.
07:56:54 <nlv11757_> yeah
07:57:23 <nlv11757_> if all these are just about some functionalities, or a small part...then you're talking about an iterative approach
07:57:38 <nlv11757_> where the complete process takes several iterations
07:58:06 <esap> Iterative has smaller steps. Waterfall often has just one iteration.
07:58:16 <analpear> spiral = iterative?
07:59:26 <analpear> "if all these are.." all what?
07:59:28 <esap> spiral is iterative, but there are other iterative processes that are not spiral
08:00:00 <analpear> what distinguishes spiral programming from other iterative programming styles
08:00:49 <esap> "programming styles"? It's more like style of process of developing software.
08:01:06 <esap> lifecycle
08:01:07 <analpear> ok
08:01:10 <analpear> yeah
08:01:12 <nlv11757_> analpear
08:01:13 <nlv11757_> http://en.wikipedia.org/wiki/Software_engineering#Processes_and_methodologies
08:01:23 <analpear> thanks
08:01:42 <nlv11757_> i love wikipedia, it has virtually anything
08:01:57 <esap> Wikipedia has lots of good information.
08:02:58 <analpear> " it has virtually anything" yes too much
08:04:00 <nlv11757_> :D
08:04:02 <esap> too much?
08:04:05 <analpear> http://en.wikipedia.org/wiki/Snorlax
08:04:07 <nlv11757_> no such thing as too much info :P
08:04:29 <nlv11757_> looool
08:04:35 <nlv11757_> that is sick hahaha
08:04:41 <nlv11757_> but master at the same time
08:04:42 <analpear> most "information" is just irrelevant and transient garbage
08:04:58 <nlv11757_> a complete description of a pokemon....come on :D
08:05:19 <nlv11757_> garbage to some, valuable to others
08:05:36 <nlv11757_> it even states how this pokemon is written in japanese :D
08:05:49 <boegel> omg: 87.5% male, 12.5% female
08:06:05 <nlv11757_> hahah gender distribution haha
08:06:09 <analpear> hmm maybe i should not have posted that link
08:06:30 <boegel> analpear: yeah, sure
08:06:32 <nlv11757_> lots of people out there are less then 87,5 % male hahaha
08:06:34 <boegel> did you create it ?
08:06:42 <boegel> nlv11757_: speak for yourself :)
08:07:51 <nlv11757_> haha what i meant was...there are probably also many girls out there that you wouldnt recognize as being women
08:07:55 <nlv11757_> i.e. not being 100% :D
08:10:18 * earthy remembers the one time where he was mistaken for a girl quite clearly
08:10:34 <earthy> man, was I annoyed at that busdriver
08:10:42 <boegel> earthy: did you kick him in the nuts ?
08:10:45 <earthy> nah
08:10:50 <earthy> he was behind steel
08:11:02 <earthy> and I needed to take a different bus anyway
08:11:05 <boegel> you should've lured him out :)
08:11:39 * boegel says: "Love is like peeing your pants: everyone can see it, but you're the one with the warm feeling"
08:11:39 <nlv11757_> hahaha earthy, are you serious?
08:11:47 <nlv11757_> you dont even have long hair or anything
08:11:52 <nlv11757_> or was that in you hippy time?
08:11:52 <nlv11757_> :D
08:12:22 <boegel> earthy: do you have man-boobs or something ? that might be a reason, although they would have to be really big
08:12:26 <earthy> it was something like 13 years ago
08:12:47 <earthy> and I was late in puberty. Sang Alto until I was 16 or somesuch. ;)
08:13:11 <nlv11757_> ow ok, my beardthingy prevents people from making that mistake hehe
08:13:27 <earthy> owh, right, beard... didn't have that then. :)
08:15:33 <analpear> in waterfall programming, how can one go straight from implementation into testing? surely the idea of testing is so you can go back to the implementation and make changes
08:16:27 <nlv11757_> i actually had it when i was 16 come to think of it
08:17:18 <earthy> analpear: the waterfall falls both ways
08:17:35 <earthy> (and yes, that's slightly counterintuitive)
08:18:03 <analpear> both ways? you mean comes down and then back up?
08:18:21 <boegel> analpear: yep
08:18:51 <analpear> how does one know when one has finished?
08:18:59 <nlv11757_> when the customer is happy
08:19:12 <analpear> heh
08:19:13 <analpear> ok
08:19:14 <boegel> that's the point, you never are
08:19:25 <esap> There are various feedback loops in all practical uses of waterfall. You do need that feedback anyway. And finishing a testing phase means that all tests pass.
08:20:01 <esap> Waterfall has quite strict borders between different stages
08:20:30 <analpear> what kind of software production does it suit best?
08:20:42 <earthy> and usually quite strict differences between 'programmers' and 'designers' and such
08:20:46 <analpear> smaller, simpler software?
08:20:49 <earthy> analpear: none.
08:20:53 <nlv11757_> spacestation software
08:20:59 <earthy> nlv: not even that.
08:21:08 <nlv11757_> hello world
08:21:08 <nlv11757_> :P
08:21:16 <esap> The primary thing that waterfall does is that is makes time schedules more predictable, at the expense of everything else :-)
08:22:07 <nlv11757_> waterfall is also a bit of....all or nothing
08:22:22 <nlv11757_> after the waterfall...you should have all...but in between...you have nothing
08:23:10 <analpear> Documentation
08:23:10 <analpear>     An important (and often overlooked) task is documenting the internal design of software for the purpose of future maintenance and enhancement. Documentation is most important for external interfaces.
08:23:18 <analpear> but this comes *after* the design phase
08:23:44 <earthy> http://www.fastcompany.com/online/06/writestuff.html
08:23:56 <analpear> maybe what im seeing here is that waterfall is not a strictly non iterative approach
08:24:03 <analpear> just less iterative than say, spiral
08:33:48 <boegel> y0 FPBiker
08:34:15 <dcoutts> does anyone know if ghc works on ARM machines? Igloo? JaffaCake? I notice Nokia are bringing out a ARM+Linux+GNOME based hand held thingy.
08:34:55 <Igloo> Currently you need to change the floating point reading/writing, but that should change with gcc 4
08:35:31 <dcoutts> Igloo, the float parsing you mean?
08:35:39 <Igloo> yeah
08:35:54 <dcoutts>  in ghc or gcc?
08:35:58 <Igloo> ghc
08:36:35 <dcoutts> because the arm doesn't use ieee7xx floating point format or something?
08:37:00 <Igloo> yup
08:37:08 <dcoutts> right
08:37:19 <FPBiker> boegel: how's it going?
08:38:39 <nlv11757_> as Hannibal always put it....i love it when a plan comes together
08:38:52 <boegel> FPBiker: lot's of work, but I'm used to it :)
08:39:04 <boegel> I have to study 450 pages on RTS by next Monday
08:39:20 <boegel> and I haven't had time to read anything because of my thesis
08:39:26 <nlv11757_> RTS?
08:39:32 <nlv11757_> Real Time Systems
08:39:33 <boegel> real-time systems
08:39:35 <nlv11757_> lol
08:39:39 <boegel> :)
08:40:27 <FPBiker> you getting ready to wrap up your PhD?
08:43:37 <nlv11757_> its msc am i not mistaken?
08:45:26 <boegel> FPBiker: me ?
08:45:39 <FPBiker> boegel: yes
08:46:06 <boegel> FPBiker: wrap up ? no, I'm not finishing a Phd, I want to start one... I'm graduating from university
08:46:35 <FPBiker> boegel: oh..ok.
08:49:28 <nlv11757_> i hate to move for a job....
08:49:39 <nlv11757_> but still...i know it has to happen some time
08:50:49 <dcoutts> Igloo, so I take it that debian has ghc package for ARM then? ;-) You know this Nokia hand held thingy is using the .deb package format.
08:51:36 <Igloo> No, I'm waiting either for someone who cares about arm to support the current format or gcc 4 to go into Debian
08:51:49 <Igloo> I hope the latter will happen RSN
08:51:56 <dcoutts> seems fair.
08:53:21 <nlv11757_> k im off, cu all
08:59:21 <analpear> the spiral approach looks at the program as a whole amirite?
08:59:36 <analpear> the spiral model page on wikipedia is not very detailed
09:22:48 <analpear> what are some advantages of haskell over java and C
09:23:00 <analpear> so far i can think of , ability to use higher end functions
09:23:11 <analpear> shorter, tidier, more readable code
09:23:23 <analpear> disadvantage : it is slower
09:23:29 <analpear> and less widely used
09:23:40 <kaol> an advantage: you get to keep your sanity
09:23:44 <Lemmih> I doubt Haskell slower than java.
09:26:23 <ndm> disadvantage is if you are trying to do GUI programming, its not as mature
09:26:47 <analpear> how can you do GUI programming in C, would you need to download tons of libraries etc?
09:26:55 <analpear> i've done some gui in java with the swing package
09:27:01 <Lemmih> ndm: Really?
09:27:03 <ndm> you just pick the gui language
09:27:39 <ndm> as far as my experience goes, yes - its really natural to do a GUI in an OO language, in a functional language you are immediately talking Monads
09:27:53 <basti_> most C gui packages are not convincing
09:27:54 <ndm> in C you can use WxWindows, which is cross platform
09:27:56 <Lemmih> Monads aren't bad.
09:28:06 <analpear> what is a Monad?
09:28:08 <basti_> they're just different ways to do ugly stuff
09:28:12 <analpear> isn't it like an "arrow" or something?
09:28:12 <Lemmih> We got WxHaskell and Gtk2hs.
09:28:17 <basti_> a monad is a cute fuzzy little thing.
09:28:25 <Lor> I haven't seen a non-ugly way of doing GUIs.
09:28:26 <ndm> monad's aren't bad, but they aren't as nice if you have to code in them all the time
09:28:39 <Lemmih> ndm: You can do drag'n'drop GUI work in Haskell with gtk+ and glade.
09:28:45 <tuomov> a non-ugly way of doing guis is not doing a gui but something more abstract
09:28:46 <nnunley> basti_: With big sharp pointy teeth
09:29:16 <analpear> in programming : what is a buffer?
09:29:20 <ndm> Lemmih: yes, but once you start interacting it gets harder - glade just gives you a picture
09:29:26 <Lemmih> ndm: You only have to use the IO monad where you want side effects.
09:29:33 <analpear> i know a buffer overflow can happen when, for example you access a non existent array entry (in c)
09:29:55 <analpear> or you get an integer bigger than 255 for an 8 bit unsigned
09:29:56 <ndm> yes, but almost all gui code is side effecting - the user clicks on something, so you update the GUI in reaction
09:31:37 <ndm> Lemmih: I don't think GUI programming in Haskell is fundamentallly wrong, but I think its a lot less mature - the "great" gui ideas have yet to come
09:32:10 <tuomov> GUI programming is fundamentally wrong.
09:32:18 <Lemmih> I still got get why it's less mature than GUI work in C or Java.
09:32:25 <Lemmih> s/got/don't/
09:32:40 <ndm> I have programmed a GUI in C, Java and Haskell
09:33:00 <ndm> C - the GUI stuff feels "a bit wrong" - the event loop and message passing all hurt more than they should
09:33:20 <ndm> Haskell - you have big monad's, it doesn't feel like standard Haskell
09:33:36 <Lemmih> Big monads?
09:33:42 <ndm> Java/C# - It feels right, the events come to you properly, every item is an object, all of them have properties
09:33:46 <Lemmih> They can grow!?
09:33:57 <ndm> Yes, they growl at me!
09:34:23 <ndm> I don't like Monad's, I appreciate they are useful, but if you always have to use a monad you are basically writing imperative code
09:34:36 <Spark> what is a bit wrong about gtk for example
09:34:49 <Lemmih> ndm: And what's wrong with that?
09:34:50 <analpear> what does the buzz-phrase "integrating the components" actually mean?
09:35:01 <liyang> Nothing wrong with imperative code...
09:35:02 <Spark> if anything i'd think the ability to do closures would mean setting up signals was far easier
09:35:04 <analpear> putting everything from the design process together?
09:35:16 <Lemmih> ndm: Haskell is my favorite imperative language.
09:35:17 <Spark> but other than that is it not all the same
09:35:37 <ndm> Lemmih: Haskell is fine for imperative code, but imperative code still has a lot of the disadvantages that Haskell was trying to get round
09:35:44 <basti_> when i had a look at OpenGL i dint feel it was wrong to do that in haskell
09:36:11 <tuomov> hmm.. in haskell you can do glBegin/glEnd properly with some glWith or something..
09:36:16 <Lemmih> ndm: Then is writing imperative code in Java so much better than in Haskell?
09:36:16 <liyang> GL looks wrong in any imperative language...
09:36:21 <tuomov> I wonder if hgl or whatever it is called has such?
09:36:39 <ndm> Lemmih: Maybe, the tools are more tuned for it, debuggers, easier integration
09:36:49 <basti_> the same is probably true for GUI programming, if someone finds out how to do it the right way
09:37:07 <Lemmih> ndm: But it's not specificly GUI related?
09:37:13 <basti_> ndm: have you ever integrated a C function to haskell or vice versa?
09:37:14 <dcoutts> Spark, indeed the ability to define colsures makes GUI programming Haskell very nice, signals are a breeze.
09:37:20 <tuomov> I just started wondering if TH could be used to get typed Vis..
09:37:36 <tuomov> (Vis is my idea how ho do (G)UI programming properly)
09:37:37 <ndm> Lemmih: Yes and no, in a way Java is better if you want to go imperative
09:37:47 <Lemmih> ndm: Why?
09:37:50 <ndm> basti_: No
09:37:56 <dcoutts> I think it was Simon PJ who said that Haskell is the worlds finest imperitive programming language.
09:38:05 <reffie> heh
09:38:24 <basti_> ndm: go and try, its not as hard as you might think
09:38:29 <ndm> Lemmih: Debugger, state management, less strict rules about Monads, easier composition
09:39:03 <Lemmih> ndm: Less strict rules about monads? Elaborate please.
09:39:21 <Lemmih> And "state management" == global state?
09:39:32 <tuomov> is there some TH tutorial already?
09:39:33 <boegel> ndm: when he says that, he means you're wrong ;)
09:39:35 <ndm> Lemmih: In Haskell if you want to access a file within a map, you can't use "map" - you have to go beoyond
09:39:35 <tic> dblhelix, in what way?
09:39:41 <tic> dcoutts, in what way?
09:39:41 <tuomov> something with nice examples etc.?
09:39:47 <analpear> how many bits are there in a java int type? in 2^x
09:39:54 <analpear> is it 2^50
09:39:55 <analpear> ?
09:40:02 <Lemmih> ndm: That's why we have mapM.
09:40:07 <boegel> analpear: hell no !
09:40:14 <ndm> Lemmih: In java, everything is "in a monad" - so the syntax disappears, and it looks like everythign else
09:40:25 <Lor> A java int is 32 bits wide.
09:40:36 <analpear> how tall
09:40:38 <analpear> ?
09:40:39 <ndm> Lemmih: In Haskell you are either in a Monad, or not. Its like two different types of programming. In Java its more consistent.
09:40:45 <boegel> analpear: that would mean the biggest number is 1000^5, that too high
09:41:03 <analpear> how do you get that?
09:41:03 <boegel> analpear: 2^32 is about 4 times 1.000.000.000
09:41:06 <ndm> boegel: I'm usually wrong :)
09:41:10 <basti_> ndm: a "memory map" file interface is a way different thing than Prelude.map, if you were talking about that.
09:41:15 <analpear> oh
09:41:16 <Lemmih> ndm: You know that you can use monads without using the 'do' notation, right?
09:41:19 <boegel> analpear: 2^10 = 1000 approximatly
09:41:28 <boegel> so 2^50 = 1000^5
09:41:32 <analpear> oh sorry i phrased it wrong
09:41:40 <ndm> Lemmih: Yes, although I admit that I'm not great at them
09:41:42 <analpear> well i just asked the wrong question
09:41:47 <boegel> heh
09:41:51 <analpear> i meant he maximum possible value
09:42:02 <analpear> which is 2^32?
09:42:08 <Lor> Here's a neat way of doing guis: http://www710.univ-lyon1.fr/~exco/ZMW/
09:42:21 <Lemmih> ndm: You have probably used lots of monad without using the 'do' notation.
09:42:21 <analpear> surely it's 2^32 + 2^31 + ... + 2^1
09:42:35 <Lemmih> ndm: Lists are monads, 'Maybe' is a monad.
09:42:59 <Lor> For a java int, the maximum expressible value is 2^31-1.
09:43:00 <tuomov> Lor: yuck. Has the word "widget" in it.
09:43:09 <ndm> Lemmih: They are instances of Monad, but don't have many of the restrictions of IO Monad
09:43:18 <Lemmih> ndm: Confusing the word 'Monad' for the IO monad is very bad.
09:43:20 <tuomov> Widgets must be forgotten on the code side.
09:43:29 <basti_> another precompiler to build lambda into a rotten language.
09:43:29 <basti_> ;)
09:43:50 <ndm> Lemmih: Have you seen Clean? They have no Monad's, and the concept of a uniqueness type - an interesting alternative
09:43:53 <tuomov> no buttons and boxes and so on, just commands, modifiable values and canvases
09:44:05 <tuomov> with no regard for how they are presented in the program code
09:44:07 <ndm> Lemmih: My bad, I did mean IO Monads
09:45:07 <Lemmih> ndm: So the problems with Haskell are: no debugger and inconsistent semantics?
09:45:13 <tuomov> http://iki.fi/tuomov/vis/ is a longer write-up on how I think (G)UIs should be written
09:46:19 <SyntaxNinja> 'morning
09:46:37 <ndm> Lemmih: I am well aware of http://www.haskell.org/hat, and not semantics - merely inconsistent thoughts in my head
09:47:07 <ndm> Lemmih: There are no problems with Haskell, but there are things that other languages are more suited to
09:48:03 <Lemmih> I agree that Haskell lacks an debugger. Hat has several limitations and is hard to apply on large applications /-:
09:48:06 <liyang> inconsistent styles.
09:48:12 <Lemmih> Morning, SyntaxNinja.
09:48:25 <liyang> But why limit yourself to purely functional or imperative (Monads) anyway?
09:48:42 <ndm> tuomov: Thats nice, will read it later
09:48:58 <Lemmih> SyntaxNinja: I've uploaded a signed package from cabal-put to HackageDB!
09:49:00 <basti_> liyang: you can mix both.
09:49:05 <basti_> liyang: thats the trick.
09:49:19 <ndm> Even when Haskell has a perfect debugger, it will probably not debug state like a java debugger can
09:49:19 <liyang> They're perfectly consistent within themselves. Nothing forcing you to use one over the other. (Other than ease of use and clarity of expression.)
09:49:30 <liyang> basti_: yes, you're preaching to the converted. :)
09:49:32 <boegel> analpear: yeah, but approximatly you can determine the value of 2^32 as follows
09:49:47 <basti_> ah
09:49:48 <SyntaxNinja> Lemmih: w000h000000
09:49:54 <boegel> 2^32 = 2^30 * 2^2 = 2^30 * 4 = 1000^3 * 4 = 4.000.000.000
09:50:04 <basti_> ndm: because in haskell there is not much state.
09:50:18 <musasabi> When one has defined a monadic abstractions it is usually easy to add debugging features to it.
09:50:25 <ndm> basti_: unless you start going the imperative route
09:50:34 <basti_> see what musasabi wrote =)
10:05:57 <analpear> "input from keyboard, and in Macintosh files" - do these use a return line character or a newline character?
10:07:33 <gaal> i'm trying to write a function that takes an arbitrary string and escapes it into a form that can be inlined inside haskell source as a string. i can't get gaps right, though:
10:07:53 <gaal> i want to do something like
10:08:03 <gaal> this is line1\n\
10:08:13 <gaal> \this is line2\n\
10:08:22 <gaal> \\n\
10:08:32 <gaal> \that was an empty line\n
10:08:54 <gaal> but the \\ in the start of the empty line seems to be confusing the compiler
10:09:00 <gaal> (or, more likely, me)
10:09:42 <gaal> what should i do?
10:11:58 <shapr> musasabi: Hei, can you create an author page as well?
10:13:12 <gaal> without adding the newlines it'll fail too (as well as not preserving my string correctly), since i'll have lines with only \\ in them.
10:13:12 <shapr> musasabi: Your article is great. I did make some spelling fixes, I hope I didn't change the meaning.
10:14:57 <basti_> gaal: that kinda sounds like a homework problem.
10:15:53 <gaal> i can't help what it sounds to you. i'm staring at section 2.6 of the report and to me it looks like a bug in the spec. :)
10:16:54 <gaal> but for the record: this isn't homework, this is pugswork.
10:17:04 <basti_> oh.
10:17:05 <basti_> ;)
10:17:25 <gaal> i'm inlining perl6 code in haskell -- implementing our version of the prelude.
10:17:33 <basti_> i see
10:18:07 <gaal> in the tradition of proving this is not homework, here's my perl code to do this so far:
10:18:22 <gaal> y{\\}{\\\\};
10:18:22 <gaal> s{"}{\\"}g;
10:18:22 <gaal> s{\n}{\\n\\\n\\};
10:18:24 <gaal> :-p
10:24:28 <SyntaxNinja> that's OK. you are all the cool kids anyway
10:30:44 <gaal> ouch split. can anyone who answered me kindly /msg ?
10:52:55 <shapr> metaperl: want to write for TMR?
10:56:39 <analpear> how would i evaluate the complexity of
10:56:39 <analpear> reverse2 :: [Int] -> [Int]
10:56:39 <analpear> reverse2 xs = move xs []
10:56:39 <analpear> move :: [Int] -> [Int] -> [Int]
10:56:39 <analpear> move [] ys = ys
10:56:39 <analpear> move (x:xs) ys = move xs (x:ys)
10:57:39 <analpear> is it just O(1)?
10:58:55 <mauke> looks more like O(n) to me
10:59:35 <analpear> what counts as a computation here?
10:59:45 <analpear> each time the function iterates?
11:00:36 <Igloo> Doing a pattern match, building a cons cell and doing a function call
11:04:09 <analpear> yeah i get n
11:04:23 <analpear> reverse :: [Int] -> [Int]
11:04:23 <analpear> reverse [] = []
11:04:23 <analpear> reverse (x:xs) = reverse xs ++ [x]
11:04:35 <analpear> for this one though i get O(n(n-1)/2)
11:06:53 <analpear> apparantly the xs ++ [x] operation is of order n where n is the number of elements in xs
11:07:36 <musasabi> shapr: thanks, I'll create the author page now and make some extensions :-)
11:08:10 <analpear> maybe it's even O(n^2(n-1)/2)
11:08:15 <analpear> since it has to do n pattern matches
11:16:38 <ndm> analpear: reverse written without an accumulator is O(n^2), not O(n^3)
11:17:37 <ndm> when inserting the n+1 th element, it has to call ++ with an n length list as the first arg
11:17:54 <ndm> there are only O(n) pattern matches
11:18:04 <ndm> and O(n) + O(n^2) = O(n^2)
11:18:08 <analpear> but it has to do n pattern matches and n-1 + n-2 + .... + n - (n-1) + n - n ++s
11:18:36 <ndm> reverse does n pattern matches in its pattern
11:18:50 <ndm> ++ does n pattern matches in its, when n is the length of the first list
11:18:51 <analpear> yeah
11:19:01 <analpear> yes
11:19:09 <ndm> hence only O(n) pattern matches are perfromed inside reverse
11:19:14 <ndm> and O(n) inside ++
11:19:19 <ndm> but ++ is called n times
11:19:29 <ndm> hence O(n) + n*O(n) = O(n^2)
11:20:25 <analpear> the number of ++ it does is decerementing by 1 each iteration
11:20:52 <ndm> yes
11:21:09 <ndm> which makes it O(n) + O(n-1) + ... + O(1)
11:21:17 <analpear> so the number of ++ it does is given by sum from k=0 up to n-1 of n
11:21:31 <ndm> which is the same as O(0.5 n^2)
11:21:44 <ndm> which (when using big O), can be reduced to O(n^2)
11:21:56 <ndm> in big O, O(10000n) = O(n)
11:22:01 <analpear> yes
11:22:17 <analpear> i see
11:22:30 <analpear> i agree now
11:22:39 <analpear> i was thinking it does a pattern match for every ++
11:22:41 <analpear> lol
11:22:52 <ndm> nope, glad you understand now
11:23:37 <analpear> but number of ++ is (n(n-1))/2
11:24:05 <analpear> but in big O that is just n^2
11:24:10 <analpear> ok
11:24:12 <analpear> rite
11:25:04 <analpear> data LinkedList = Null | List Int LinkedList
11:25:11 <analpear> could anyone explain this line to me
11:25:20 <analpear> it is defining a data type called linked list
11:25:33 <analpear> which is either Null, or a list int linked list?
11:25:38 <analpear> i don't understand that 2nd bit
11:26:59 <mauke> ... or a List containing an Int and another LinkedList
11:27:37 <analpear> so embedded lists? :/
11:27:57 <analpear> [1,[2]] would be of type linked list?
11:28:12 <mauke> no
11:28:25 <mauke> List 1 (List 2 Null) would be
11:28:48 <mauke> that's (:) 1 ((:) 2 []) in standard haskell notation
11:29:19 <analpear> what is (:)
11:29:24 <analpear> i thought that was just join together
11:29:33 <mauke> (:) is List :-)
11:29:56 <Igloo> More commonly called Cons
11:30:05 <CosmicRay> around lispers, anyway :-)
11:30:07 <analpear> concatenate?
11:30:11 <mauke> no, prepend
11:30:23 <mauke> it takes an item and a list, not two lists
11:30:36 <analpear> so this linked list is embeddeD?
11:30:46 <mauke> huh?
11:30:47 <CosmicRay> it's the basic haskell list
11:31:07 <analpear> List 1 (List 2 Null) = [1,2] ?
11:31:18 <mauke> yeah, basically
11:31:29 <mauke> [1,2,3] is just syntactic sugar for 1:2:3:[]
11:37:45 <basti_> a list is either [] or an element and another list
11:39:45 <analpear> lol @ elegant recursive definitions
11:39:58 <analpear> what do you mean by elements AND another list
11:40:02 <basti_> thats the ADT view
11:40:03 <analpear> what do you mean by element AND another list
11:40:15 <basti_> you could view it as a tuple for example
11:40:22 <basti_> a pair
11:40:46 <basti_> just that it isnt, haskell-technically
11:40:52 <reffie> http://www.vr-zone.com/?i=2265&s=1
11:47:03 <analpear>  data LinkedList = Null | List 4 LinkedList means what?
11:47:58 <mauke> looks like an error to me
11:48:27 <analpear>  data LinkedList = Null | List Int LinkedList means what?
11:48:29 <analpear> lol
11:51:33 <SamB> @docs Data.Generics
11:51:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Generics.html
11:51:47 <analpear> if the linked list is not null then,...
11:56:11 <musasabi> analpear: A linked list is either null or an int and a linked list.
12:02:18 <Itkovian> evening
12:02:51 <shapr> hoi Itkovian
12:04:57 <Itkovian> hi shapr
12:05:00 <Itkovian> long time no see
12:06:10 <shapr> Yeah well, I'll fade back into obscurity once I've got this month's TMR out.
12:06:13 <shapr> How's code?
12:09:07 <shapr> Sure is quite here tonight.
12:09:10 <shapr> um, Quiet
12:10:44 <basti_> quite quiet
12:12:30 <shapr> Well, anyone want to check out IssueThree of TMR before it goes online?
12:12:58 <basti_> <
12:13:04 <shapr> >
12:13:11 <reffie> ^
12:13:13 <basti_> >_<
12:13:26 <reffie> v
12:13:32 <basti_> >>=
12:13:35 <tuomov> )v(
12:13:39 <liyang> TMR?
12:13:56 <liyang> ah, look at the topic.
12:15:19 <shapr> Ok, check it out - http://www.haskell.org/tmrwiki/IssueThree
12:15:31 <shapr> Tell me if you see any problems!
12:18:06 <ibid> there is no single-issue pdf :)
12:18:19 <musasabi> Is it 00:00 swedish time?
12:18:28 <ibid> unlikely
12:18:53 <shapr> musasabi: no, but I want more eyes to ferret out the bugs.
12:19:09 <shapr> There's still time to change stuff.
12:19:21 <shapr> Though that's always true with a wiki.
12:20:21 <musasabi> sorry, I meant to say "is the deadline 00:00 Swedish time" ?
12:20:22 <shapr> musasabi: you think I should have waited till 0:00?
12:20:42 <shapr> Not really. The deadline last time was the second of the following month, so...
12:21:17 <musasabi> ah.
12:22:13 <shapr> I try to get everything together by midnight of the last day of the month, but it doesn't always work.
12:26:07 <CosmicRay> shapr!!!
12:26:37 <shapr> Hiya CosmicRay
12:27:33 <shapr> How's code?
12:27:40 <CosmicRay> pretty good
12:27:40 <shapr> Want to write about MissingH for next TMR issue?
12:27:44 <CosmicRay> you?
12:27:55 <shapr> Code is slow, but progressing.
12:28:23 <CosmicRay> yes.  I really do.  I hope I will have time.  way too many things going on right now.
12:30:46 <liyang> shapr: the bit on existential types in Graham Kline's notes doesn't seem to be finished...
12:31:15 <shapr> Ah, good point
12:31:21 <shapr> liyang: thanks
12:41:18 <shapr> I'll be back in an hour. If anyone sees any bugs, please tell me!
12:42:09 <shapr> One more time, here's the preview - http://www.haskell.org/tmrwiki/IssueThree
12:50:48 <Lemmih> @seen shapr
12:50:49 <lambdabot> shapr is in #haskell. Last spoke 8 minutes and 39 seconds ago.
12:51:18 <kaol> @woof
12:51:20 <lambdabot>             (__)
12:51:20 <lambdabot>             (@@)
12:51:20 <lambdabot>      /-------\/
12:51:20 <lambdabot>     / |     ||
12:51:20 <lambdabot>    *  ||----||
12:51:20 <lambdabot>       ^^    ^^
12:51:22 <lambdabot>  
12:51:24 <lambdabot>    Cow who ate
12:51:25 <Lemmih> Greetings, shapr.
12:51:26 <lambdabot> psychadelic mushrooms
12:52:50 <Itkovian> I am wondering about JoinHS
12:53:30 <Itkovian> How does it dal with things like dataraces? Does the programmer have to take care of most of the synchronisation required, or does the system doe this for him?
12:54:53 <musasabi> Itkovian: the join patterns define the synchronization points.
12:56:10 <Itkovian> I am always a tad scared when people mention concurrency.
12:56:53 <liyang> shapr: there's also an example missing under ``Error messages from Compilers''
12:58:14 <musasabi> Itkovian: is there something that could be done to explain the issue?
12:58:50 <Itkovian> I am thinking about it.
13:02:00 <alexj> Igloo: Does DES.lhs work with recent versions of GHC or am I doig sometihng wrong?
13:02:37 <Igloo> What error do you get?
13:02:55 <alexj>    Illegal instance declaration for `Bits [Bool]'
13:02:55 <alexj>        (The instance type must be of form (T a b c)
13:02:55 <alexj>         where T is not a synonym, and a,b,c are distinct type variables)
13:02:55 <alexj>    In the instance declaration for `Bits [Bool]'
13:03:39 <boegel> hey shapr
13:04:00 <Lemmih> alexj: Looks like a missing flag to me.
13:04:09 <alexj> (the only change I made was to paste  "type Zord64 = Word64" directly in (rather than have than having it import)
13:04:35 <Igloo> You'll probably need -fglasgow-exts
13:04:37 <alexj> I added a -fglasgow-exts flag at the top
13:04:56 <Igloo> With -fglasgow-exts that instance should be accepted
13:05:01 <alexj> I guess,  I don't know how to do that with lhs files
13:05:16 <Igloo> It needs to be in a code section of the file
13:05:22 <Igloo> Or just put it on the commandline
13:05:23 <alexj> I added {-# OPTIONS -fglasgow-exts #-} at the top of the file
13:05:38 <alexj> code section?
13:05:52 <Igloo> Either bird-tracked or in a code block
13:06:31 <alexj> I never use lhs.  what does that mean?
13:06:53 <boegel> hey, you did get 5 articles for TMR3, nice!
13:07:52 <Itkovian> musasabi: Maybe a formal description of the synchronisation could help people flesh out possible mistakes
13:08:14 <alexj> how does literate work with pragmas/options?
13:09:14 <boegel> Itkovian: prof Boute has someone working on formal description of concurrency
13:09:19 <alexj> ah just figured it out.  now the error is     No instance for (Num [Bool])
13:09:20 <alexj>       arising from the superclasses of an instance declaration at
13:09:25 <boegel> alexj: > {- pragma -} i'd say
13:09:29 <alexj> line 70
13:09:55 <liyang> I believe the source just gets de-literated and passed to the compiler. Where deliteration means either removal of birdtracks or ignoring anything not in \begin{code} and \end{code}
13:10:14 <alexj> yeah the solution was > {-# OPTIONS -fglasgow-exts #-}
13:10:43 <alexj> now I am getting a more code related error... (I think)
13:12:37 * musasabi tries an informal description as a formal one could do much to confuse people.
13:15:37 * boegel is wondering if he should release his HRay code tonight or tomorrow
13:16:15 <Itkovian> tonight ;-)
13:16:19 <alexj> Igloo: No instance for (Num [Bool]) appears to be more real.
13:16:19 * Itkovian is putting up the laundry. brb.
13:17:16 <reffie> cause tonight is the night when two become one!
13:17:50 <boegel> I think I'll change my website first, make it more usefull...
13:19:31 <musasabi> Itkovian: I put up a small explanation in the start.
13:30:29 <alexj> the problem is that [Bool] needs to be an instance of Num.
13:30:37 <alexj> did it used to be?
13:31:41 <basti_> bizarre
13:31:45 <basti_> not that i know of though
13:32:36 <alexj> is the requirement that instances of Bits also be instances of Num a new requirement?
13:33:20 <basti_> well it kinda makes sense
13:33:51 <alexj> it does make sense.  but if the requirement is what was added, that is what has broken Ian's DES implementation.
13:35:03 <alexj> and if I need to add it to make the DES work, should I assume that head [Bool] is the lowest order bit or highest order bit?
13:35:23 <basti_> good question.
13:35:30 <musasabi> alexj: just write "instance Num [Bool]" (no methods to make it die if it is actually used).
13:35:32 <basti_> lowest order makes more sense for me right now
13:35:38 <boegel> Itkovian: do you know if it's ok to 'publish' my thesis text on a website ?
13:35:56 <musasabi> alexj: if it does use them add a proper definition.
13:36:19 <alexj> musasabi: worked.  now I just get a lot of warnings.
13:37:22 <musasabi> it warns that the methods are undefined. To get rid of them define each method to be 'error "this should not happen"' and see whether it is triggered.
13:38:09 <alexj> musasabi: ok, thanks.
13:47:58 <shapr> hoi boegel
13:50:18 <reffie> http://www.fftimes.com/index.php/3/2005-05-30/21415
13:55:30 <shapr> boegel: Yeah, I got five by republishing two.
14:02:10 <boegel> shapr: républishing ?
14:02:46 <Itkovian> boegel, sure, why not?
14:14:47 <Itkovian> it's your text after all ...
14:14:58 <Itkovian> did you sign a copyright trnasfer agreement? I think not.
14:15:04 <Itkovian> you didn't sign anything. lol
14:17:35 <boegel> Itkovian: :)
14:18:00 <boegel> alrighty then, I'll throw it online... I'm setting up a nice website for it now
14:31:50 <boegel> in which format should I provide my Haskell code for HRay ? will zip do it, or are there other common ways ?
14:32:32 <Igloo> tar.gz is the standard for OS stuff IME
14:32:35 <musasabi> zip or tar.gz.
14:32:48 <Igloo> Well, except Windows or old-mac specific OS stuff
14:32:54 <musasabi> windows people prefer the first, while the *nix crowd the second.
14:33:05 <boegel> musasabi: how can I create the tar.gz file properly ?
14:33:33 <Igloo> tar -zcf hray-1.0.0.tar.gz hray-1.0.0/
14:33:46 <Igloo> With the files in the hray-1.0.0/ directory
14:36:54 <boegel> Igloo: thanks
14:40:45 <metaperl> tuomov: Philippa wrote a Template Haskell tutorial for TMR2
14:41:03 <Itkovian> or perhaps tar.bz2 ... tar -jcf hray-1.0.0.tar.bz2 hray-1.0.0
14:43:58 <boegel> does this channel have a wiki page ?
14:44:26 <boegel> nvm: http://haskell.org/hawiki/HaskellIrcChannel
14:48:34 <shapr> yow!
14:50:21 <kaol> @yow indeed
14:50:23 <lambdabot> Will the third world war keep "Bosom Buddies" off the air?
14:52:08 <musasabi> arr..
14:52:11 <shapr> @arr !
14:52:12 <lambdabot> I want me grog!
14:52:43 <kaol> @meow
14:52:44 <lambdabot> Maybe you meant: moo yow
14:53:19 <kaol> a strange cat, one that would say "moo yow"
14:53:22 <shapr> @y0w!
14:53:23 <lambdabot> HAIR TONICS, please!!
14:53:43 <kaol> @squeak
14:53:45 <lambdabot> Unknown command, try @listcommands.
15:06:51 <kaol> @vixen Is there a worse fate than having to fix other people's C code?
15:06:54 <lambdabot> there must be
15:07:26 <shapr> @vixen Are you foxy?
15:07:28 <lambdabot> yes, i am
15:08:18 * Lunar^ is trying to instantiate MVar's during parsing (with Parsec)
15:08:59 <shapr> @vixen Are you a rat?
15:09:01 <lambdabot> yes, i am
15:27:23 <shapr> Since no more errors are turning up, I'm going to announce tmr3 and go to sleep.
15:27:44 <shapr> Thanks for the proofreading help :-)
15:31:20 <mwc> Hey, shapr, you around?
15:31:43 <shapr> Not really.
15:31:46 <shapr> Why?
15:31:56 <shapr> What can I do for you?
15:32:23 <mwc> YOu recommended me a book on algorithms that treated them from a functional standpoint, what was it?
15:32:29 <mwc> I finally am un-broke
15:32:39 <dons> hi shapr. rumours of your kidnapping have apparently been greatly exaggerated.
15:32:51 <shapr> hah
15:32:58 <dons> ;)
15:33:05 <shapr> The Bureau of Procedural Programming finally released me.
15:33:42 <dons> didn't rough you up too much? I hope they didn't make you write loops as torture.
15:34:06 <dons> just as long as you didn't give away all our type inference secrets...
15:34:07 * shapr cries
15:34:26 <shapr> They did! I had to write "I will not fold my loops" on the blackboard a thousand times!
15:34:39 <dons> oh no!
15:34:58 <dons> we should contract the eu to see if this is a breach of your human rights
15:35:04 <dons> contact
15:35:11 <mwc> heh, has anybody made Haskell bindings to any of the major numerical algorithm packages like BLAS or NUMPACK?
15:35:17 <shapr> Yup, Hal Daume
15:35:32 <dons> we need hackage!
15:35:53 <mwc> heh
15:36:24 <mwc> I better go put $300 into my VISA account before all $1200 of costs hit it and it explodes
15:36:43 <mwc> $75 key deposit, $800 fedex fees, $100 books
15:36:51 <shapr> Anyway, it's the rabhi and lapalme book
15:37:04 <mwc> yeah, thanks, I founnd it
15:37:16 <mwc> I remembered I had it on my Amazon wishlist
15:37:19 <shapr> http://sequence.complete.org/node/17
15:38:01 <mwc> excellent. Have to go stave off financial explosions
15:48:36 <shapr> Man, I can't think of anything to put into the Editorial.
15:49:21 <kaol> haskell is fun.
15:49:37 <kaol> but that's kind of obvious. never mind.
15:49:41 <boegel> shapr: call for more writers
15:49:45 <shapr> Yeah, truly.
15:50:29 <musasabi> Editorials are hard...
15:53:11 <shapr> Hm, how to tactfully say that there's no wikizine without contributed articles?
15:54:54 <boegel> say you don't won't a good idea like TMR to go to waste, and you need more writers to keep it going
15:56:07 <lispy> yeah
15:56:20 <lispy> those bastard non-writers should stop muching and contribute!
15:56:27 <lispy> mooching...
15:56:30 <lispy> i dunno...
15:56:32 <lispy> @moo
15:56:34 <lambdabot>           (__)
15:56:34 <lambdabot>           (xx)
15:56:34 <lambdabot>    /-------\/
15:56:34 <lambdabot>   / |     ||
15:56:34 <lambdabot>  *  ||----||
15:56:34 <lambdabot>     ^^    ^^
15:56:36 <lambdabot>  
15:56:36 <shapr> Yeah, I should write an article or two
15:56:38 <lambdabot>  Cow who used Jolt to wash
15:56:40 <lambdabot> down psychadelic mushrooms
15:56:42 <lispy> @mooching
15:56:43 <lambdabot> Unknown command, try @listcommands.
15:57:02 <shapr> lispy: so, you wanna write for TMR4?
15:57:20 <lispy> shapr: hehe, i don't think i know enough about haskell to write anything interesting
15:57:34 <lispy> and the other thing is that it would have to wait till after the 6th for me start it
15:58:03 <shapr> That's fine :-)
15:58:04 <boegel> yaay, my new website is online, _with_ my ray tracer code on it
15:58:11 <lispy> boegel: url!
15:58:14 <lispy> now, damn it ! :)
15:58:18 <boegel> http://studwww.ugent.be/thesisPublic/website
15:58:35 <kaol> you use a ray tracer to serve http? :-P
15:58:35 <shapr> boegel: Can I expect a short HRay announcement and description for TMR4?
15:58:55 <boegel> shapr: err, don't know :)
15:59:07 <boegel> maybe I could write on yeah
15:59:08 <shapr> lispy: C'mon, a deadline is a great motivation. Your deadline is July 1st. That's a month.
15:59:12 <boegel> but you'll have to ask me again
15:59:18 <shapr> Awright, will do.
15:59:23 <boegel> I won't have time this week, but I will probably next week
15:59:26 <Biker> boegel: good stuff - you're ahead of schedule :-)
15:59:31 <shapr> boegel: Your first article is popular :-)
15:59:35 <lispy> http://allserv.ugent.be/helpdesk/error404stud-busy.html
15:59:39 <lispy> that's what i got...
15:59:47 <boegel> lispy: woops :)
15:59:49 * edwinb wonders if he should stop making excuses and write something
15:59:54 <boegel> http://studwww.ugent.be/~kehoste/thesisPublic/website
15:59:55 <shapr> edwinb: yes please!
15:59:56 <dons> shapr, havve you thought of making an announcement inviting submissions?
16:00:07 <dons> I'd be happy to review them
16:00:16 <lispy> boegel: thanks
16:00:17 <dons> and I'm sure others here would too
16:00:20 <shapr> dons: er, when I first announced TMR I did that, you think I need to do it again?
16:00:28 <boegel> feedback is welcome :)
16:00:30 <edwinb> I can only think of scary excessively techy stuff though.
16:00:36 <lispy> boegel: although, i can't read normal font on that backround :(
16:00:49 <lispy> but if i select it with the mouse i can read it :)
16:00:51 <boegel> shapr: I think you should with every issue, because you want more readers before you'll get more writers
16:01:07 <boegel> lispy: you can't ? damn, let me adjust the style sheet :)
16:01:20 <shapr> edwinb: Like dependent types?
16:01:29 <dons> oh, hmm. I think each TMR should have a line saying "TMR invites submissions on Haskell and related topics ... send 5000 words to blah blah. ... "
16:01:30 <shapr> edwinb: I would definitely like to read about dependent types.
16:01:40 <edwinb> To keep it haskelly, I was thinking of an implementation in haskell...
16:01:42 <lispy> boegel: i think either the text or the bg needs to be a bit darker
16:01:45 <edwinb> but that gets scary pretty quickly
16:01:50 <edwinb> Although I think it's fun...
16:02:04 <shapr> edwinb: But, part the readership really prefers scary articles.
16:02:17 <lispy> boegel: this is one of my favorites: http://studwww.ugent.be/~kehoste/thesisPublic/website/img/refl1.png
16:02:22 <edwinb> Hmm, well, I'll see what I can think of in the next week or two.
16:02:22 <shapr> I've got Oleg recruited for a future issue, you think you be more scary than him? ;-)
16:02:31 <dons> ok. that's cool.
16:02:36 <edwinb> I don't think anyone can ever be more scary than Oleg.
16:02:47 <dons> you get 1 Oleg article in, and a lot of  the other academics might consider writing
16:02:51 <edwinb> I am panicking at the mere thought.
16:02:59 <SamB> it is called "horror programming"!
16:02:59 <shapr> He says he might publish part III of the Zipper as tree of subcontinuations in TMR.
16:03:06 <Biker> nice
16:03:14 <boegel> lispy: done ! refresh
16:03:17 <dons> those oleg emails would be perfect. yes.
16:03:20 <lispy> boegel: yea, this one is nice too
16:03:22 <lispy> http://studwww.ugent.be/~kehoste/thesisPublic/website/img/trans2.png
16:03:41 <lispy> boegel: yeah, much easier on my eyes :) thanks
16:03:45 <boegel> lispy: that's the one I used for my logo :)
16:03:48 <musasabi> A scary article would be nice :-)
16:03:51 <dons> TMR serves a good role in that respect -- it can serve to gather together some of the ideas currently posted in long emails to haskell@
16:04:05 <shapr> Yeah, true.
16:04:26 <lispy> boegel: do you use an source version tools?
16:04:32 <lispy> boegel: like cvs or darcs?
16:04:33 <shapr> edwinb: I'm part of the readership too, and I'm very interested in dependent types.
16:04:38 <boegel> lispy: no, because I don't know how :)
16:04:46 <boegel> maybe I should though
16:04:54 <lispy> boegel: ah, we could get you setup using darcs and you could share your code tha way ;)
16:05:02 <SamB> boegel: "know how"?
16:05:09 <shapr> I really wish wouter would finish his attribute grammars article. I still don't see how they're different from arrows, and I'd like to debate it.
16:05:13 <dons> shapr, how hard would it be to have RSS abstracts for each TMR?
16:05:24 <lispy> mkdir hray && cd hray && darcs init
16:05:25 <boegel> SamB: well yeah, I don't know how stuff like darcs works
16:05:26 <SamB> how do you expect to know how before you *do* it.
16:05:41 <boegel> SamB: true, very true :)
16:05:45 <shapr> dons: oh that's a good idea!
16:05:46 <lispy> boegel: have you used cvs at all?
16:05:54 <musasabi> I think many potential writers are interested in scary articles - so they might be good for atracting new contributors. Of course each issue should have easy to understand articles too.
16:05:55 <boegel> lispy: no :)
16:05:57 <dons> shapr, I read the OCaml Weekly News that way.
16:06:03 <lispy> boegel: okay, then no unteaching to do :)
16:06:10 <dons> (also, did you know about the OCaml weekly news?)
16:06:11 <boegel> lispy: lol
16:06:24 <shapr> Yes, OCaml weekly news made me so jealous I started TMR.
16:06:33 <edwinb> I suppose I could do a brief introduction to dependent types, but it'd have almost zero haskell content.
16:06:38 <shapr> (with lots of encouragement from boegel!)
16:06:42 <boegel> lispy: what should I do after 'darcs init'
16:06:58 <boegel> shapr: hehe :) I though it was a good idea
16:07:01 <boegel> I still do :)
16:07:04 <lispy> boegel: copy in your source code
16:07:07 <shapr> boegel: you were, and are, right.
16:07:26 <alexj> you might also try getting people to write articles promoting libs they have written, explaining the design rationalle etc.
16:07:33 <SamB> what kind of 'skeller isn't interested in all kinds of scary things?
16:07:35 <lispy> boegel: then, you do a darcs record --look-for-adds
16:08:03 <dons> TMR is more formal than the CWN, http://sardes.inrialpes.fr/~aschmitt/cwn/2005.05.31.html
16:08:08 <boegel> lispy: so I just do 'cp *.lhs hray' for example ?
16:08:21 <lispy> boegel: an "add" is a file that is in the directory, but not one that darcs is recording
16:08:31 <dons> the debian weekly news thingy is a between the two, I think.
16:08:35 <lispy> boegel: yeah, put it in the directory the normal way
16:08:41 <boegel> okay
16:09:02 <boegel> and then the 'darcs record' command takes up the code in the repository (is this the correct term ?)
16:09:25 <lispy> boegel: well, the record tells darcs to basically create a snap shot
16:09:26 <juhp> @topic-snoc ghc added to Fedora Extras
16:09:28 <lambdabot> I do not know the channel ghc
16:09:28 <shapr> dons: Yeah, I thought TMR might be more formal than CWN, but I wasn't sure. I just tried to get a bunch of people to write stuff, and they did!
16:09:43 <boegel> lispy: okay
16:09:43 <shapr> @topic-snoc #haskell ghc added to Fedora Extras
16:09:44 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]' by lambdabot
16:09:45 <lispy> boegel: it will create a set of patches that represent the change since darcs init and darcs record
16:09:59 <juhp> shapr: thanks
16:10:03 <shapr> :-)
16:10:06 <boegel> shapr: the topic still says IssueTwo
16:10:09 <shapr> oh right
16:10:13 <lispy> boegel: then later when you make changes you do darcs record again and it creates patches that represent the changes between now and the last record
16:10:15 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","Shapr is fine","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]' by boegel
16:10:26 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueThree","Shapr is awesome","ICFP Contest! http://icfpc.plt-scheme.org/","ghc added to Fedora Extras"]' by shapr
16:10:33 * shapr cackles evilly
16:10:43 <boegel> lispy: I see, and then I can just provide the pathces ?
16:10:45 <lispy> boegel: and when you have other copies of the source code you can "push" and "pull" patches between them
16:10:52 <boegel> lispy: cool :)
16:10:56 <lispy> boegel: right, but darcs automates it ;)
16:11:03 <shapr> alexj: Yes, that could be interesting.
16:11:12 <lispy> there is a darcs send as well that uses email to transfer the patches, but i don't know how it works
16:11:25 <boegel> lispy: is it okay if some stuff is in subdir's ?
16:11:46 <lispy> boegel: yeah, that --look-for-adds (or -l for short) should recurse
16:11:51 <lispy> what version of darcs is it?
16:12:19 <lispy> boegel: it's interactive so it should ask you about each file before adding it
16:12:41 <boegel> lispy: 1.0.2
16:12:44 <boegel> is that good enough ?
16:13:03 <lispy> yeah, 1.0.3 is a bit better, but i think i'm still using 1.0.3
16:13:11 <lispy> er 1.0.2
16:13:23 <lispy> and i'm not sure if 1.0.3 has reach a stable release
16:13:38 <lispy> most performance enhancements in .3
16:13:54 <musasabi> But performance is not an issue for small repos.
16:14:19 <lispy> musasabi: kaol was having problem with a 6mb repo, but that's an odd case
16:14:25 <foxy> shapr: To echo an earlier sentiment, I think the previous two Oleg zipper posts would benefit from a more permanent status (TMR article?)
16:14:29 <dons> 1.0.3 is stable now.
16:14:35 <shapr> foxy: That's a good point.
16:14:39 * SyntaxNinja should package that...
16:14:45 <boegel> lispy: okay, that's done
16:15:02 <boegel> now I can throw this darcs repository online, right ?
16:15:03 <shapr> foxy: Oleg keeps those sort of article on his website, but it would be nice to have in a zine format.
16:15:04 <lispy> boegel: cool, so now when ever you make a set of changes do a darcs record
16:15:13 <SyntaxNinja> what could be more perminant than Oleg's emitings?
16:15:25 <SyntaxNinja> emissions
16:15:33 <lispy> boegel: now the next part is really hard :) you get to share a repositiory
16:15:45 <boegel> ok :)
16:15:57 <lispy> boegel: go into ~/public_html and do darcs get <path> where <path> is the path to the directory you just created
16:16:15 <lispy> if you have the permissions set correctly then we should be able to grab a copy using darcs
16:16:16 <boegel> btw, the patch darcs created has this crazy name?
16:16:29 <lispy> boegel: the one in _darcs/ ?
16:16:45 <boegel> lispy: the one in _darcs/patches
16:16:47 <shapr> I really enjoyed the Zipper series. Huet's Zipper is cool by itself, but adding subcontinuations makes it extremely nifty.
16:16:55 <shapr> And I like autrijus' idea to apply the zipper of subcontinuations to distributed programming.
16:17:07 <lispy> boegel: yeah, don't worry about things in _darcs, it uses that stuff for accounting and what not
16:17:17 <lispy> boegel: the patch's name is what you typed in
16:17:22 <boegel> lispy: the problem is, my website is on a student server of the univerisity, and I'm guessing they don't have darcs :)
16:17:31 <boegel> okay
16:17:46 <lispy> boegel: so do you have ~/public_html/hray  now?
16:18:14 <am02> whois boegel
16:18:24 * lispy points at boegel
16:19:01 <boegel> lispy: I do
16:19:07 <lispy> sweet
16:19:28 <boegel> can I throw that on the webserver, and then you guys can use darcs to pull it in ?
16:19:35 <shapr> dons: Mind if steal your 'invites submissions' text verbatim?
16:19:51 <lispy> boegel: yeah, i just tried it, but i got a webpage...
16:20:07 <boegel> lispy: it's not on the webserver yet :)
16:20:10 <lispy> ah
16:20:27 <boegel> one moment pls :)
16:20:30 <lispy> ah, that public_html thingy was meant to be on the web server :)
16:20:40 <boegel> well yeah, that's the problem :)
16:20:45 <boegel> I have no webserver of my own
16:20:48 <musasabi> boegel: you can either put a darcs binary on the server (if you got shell access) or just copy the whole repository over.
16:21:01 <boegel> musasabi: okay, thanks
16:21:14 <dons> shapr, go for it.
16:21:21 <lispy> boegel: yea, i use darcs that way to synch my homedir
16:21:30 <boegel> lispy: oh, okay
16:21:36 <shapr> dons: thanks
16:21:47 <lispy> boegel: the computers all have darcs on them, and i just pull and push to my server from the local accounts
16:22:15 <SyntaxNinja> "the computers all have darcs on them"
16:22:18 <SyntaxNinja> mmmmmm
16:22:23 <lispy> it's a perverted use of a version control system, but it gets the job done
16:22:37 <shapr> I think it's sane rather than perverted.
16:22:53 <shapr> Everyone should keep their homedir in a version control system.
16:23:00 <shapr> filesystems don't have an undo button.
16:23:04 <SamB> huh, there seems to be something wrong with my ghc -M ...
16:23:15 <lispy> it's sane until you find out that i have like 200mb of files, and it takes a darcs get about 6hours to grab a copy
16:23:39 <dons> SamB?
16:23:57 <lispy> often i just scp over a copy of the repo and then start synching
16:24:06 <SyntaxNinja> yeah
16:24:06 <lispy> it's a lot faster
16:24:28 <dons> hmm. darcs over rsync?
16:24:44 <dons> for simultaneous push/pulls
16:24:47 <dons> i.e. darcs sync
16:24:48 <SamB> dons: when I run ghc -M Foo.hs, it doesn't generate any make rules! the particular foo in this case is DrIFT...
16:24:56 <lispy> dons: can rsync be made secure?
16:25:04 <dons> sure, you can run over ssh.
16:25:13 <lispy> ah, cool
16:25:38 * lispy gets in a tank and runs over ssh.
16:25:54 <shapr> Huh, I thought rsync required ssh, I've never used it any other way.
16:25:55 * boegel just deleted everything in his local directory for his home page using 'rm -rf'
16:25:57 <boegel> doh !
16:26:13 <lispy> boegel: oh no...
16:26:29 <boegel> lispy: no worries, I can just pull in it from the server again :)
16:26:30 <lispy> boegel: well, it's still on the webserver
16:26:58 <boegel> lispy: try http://studwww.ugent.be/~kehoste/thesisPublic/darcs/hray as location for the darcs repository
16:27:05 <lispy> i had a directory named "~" the other day and foolishly typed  "rm -rf ~"
16:27:09 <shapr> Awright, I'm sending the email and I'm outta here
16:27:14 <shapr> lispy: ouch
16:27:22 <edwinb> !
16:27:44 <lispy> no worries it was about 1 month after switching to darcs
16:27:47 <shapr> whew
16:27:58 <lispy> i just did an scp from the server to get my repository back
16:28:13 <shapr> I whacked five hundred messages out of my inbox today, and they're just gone. I haven't done a backup lately :-(
16:28:22 <lispy> boegel: i still get the 404 page
16:28:32 <lispy> boegel: is it world read able?
16:29:02 <lispy> i don't backup my mail
16:29:06 <lispy> which is bad
16:29:17 <lispy> but a lot of my mail is stored on the schools server
16:29:22 <lispy> which they do daily backups on
16:29:31 <boegel> lispy: yeah
16:29:37 <lispy> boegel: hm...
16:29:38 <boegel> try using a browser to check it out
16:29:42 <lispy> dons: any suggestions?
16:29:42 <shapr> I think Alistair Bayley's OoVsFp article will cause some excitement.
16:29:59 <boegel> lispy: sorry, this is the correct one -> http://studwww.ugent.be/~kehoste/thesisPublic/website/darcs/hray
16:30:08 <boegel> forgot the 'website'-part
16:30:42 <boegel> so now people can do patches on it too ? or send my patches ? how does that work ?
16:30:44 <dons> lispy, ?
16:30:48 <lispy> boegel: sweet!
16:31:04 <lispy> dons: oh, i thought maybe you would have an idea how to debug a problem we're not having anymore
16:31:23 <boegel> using the right url always helps :
16:31:24 <boegel> :)
16:31:33 <lispy> boegel: you need darcs.cgi to be able to accept patches via the web if i understand correctly
16:31:42 <lispy> boegel: but we should be able to mail you patches
16:31:50 <boegel> nice !
16:31:54 <boegel> go ahead then ;)
16:32:27 <boegel> I've added the darcs url to the download page too
16:32:47 <lispy> cool
16:33:14 <lispy> boegel: just remember to record often
16:33:20 <lispy> it's usually better to have lots of small patches
16:34:15 <boegel> lispy: okay
16:34:42 <lispy> i change machines often, so i usually just record when i'm about to leave a computer
16:34:55 <boegel> okay, I see
16:35:16 <boegel> I won't be playing around with the code this week, but using darcs helps me when i get back to it later
16:36:09 <lispy> boegel: hehe, did you borrow the ppm code from GRT?
16:36:27 <lispy> not that there is much to borrow
16:36:37 <lispy> as formats go it's pretty trivial
16:37:46 <lispy> boegel: so are scene files just haskell code?
16:37:52 <lispy> no i guess not
16:38:02 <lispy> some language you cooked up?
16:38:25 <musasabi> I find the whole OO in Haskell thing quite hard to understand. The implementations are usually nifty, but usually things are much more naturally done without OO in a Haskell setting. More powerfull records are needed of course.
16:40:02 <boegel> lispy: yeah I did, that's one the first things I saw when doing 'research'
16:40:16 <musasabi> but sleep =>
16:40:23 <boegel> lispy: just some 'language' I cooked up, but not a good one though
16:40:38 <analpear> how do i work out how many fields there are in a java class?
16:40:40 <boegel> lispy: I created a small parser with Happy to read the files
16:40:51 <lispy> boegel: have you thought about generating scenes using haskell?
16:40:58 <analpear> indeed, what is a field in this context?
16:41:15 <boegel> lispy: no, not really... my first version had hard-coded scenes
16:41:25 <lispy> boegel: right, of course
16:41:39 <boegel> I use the Happy parser to create an instance of a datatype I created
16:42:01 <lispy> yeah, i'm looking at the happy output now
16:42:48 <lispy> i was thinking of going the other way.  You have a collection of function in haskell that allow you to define a scene, when you run that program it generates the .hry file and then you read it back in and render it
16:42:59 <boegel> lispy: I have considered using XML like syntax (or even XML) to describe scenes
16:43:14 <lispy> hmm....
16:43:17 <boegel> sounds nice
16:43:30 <lispy> boegel: i don't know if using features of haskell would be nice or not for defining scenes
16:43:38 <lispy> but the intuition is yes
16:43:52 <boegel> lispy: it might, but then the hry would be in a totally different format
16:44:06 <boegel> now it contains keywords because you have to create them by hand
16:44:37 <lispy> boegel: i have a program that generates procmailrc files from haskell programs
16:44:46 <lispy> so it wouldn't have to change the syntax
16:44:47 <boegel> nice :)
16:45:01 <boegel> lispy: yeah, I wouldn't, but it would be easier
16:45:08 <boegel> the syntax kinda sucks now :)
16:45:09 <lispy> okay, that may be true :)
16:45:29 <boegel> anyways, I should go to bed
16:45:36 <lispy> boegel: yeah, good luck
16:45:36 <boegel> i have to study tomorrow !
16:45:44 <lispy> boegel: when do you defend?
16:45:53 <boegel> lispy: already done it
16:46:01 <lispy> ah, nice
16:46:09 <boegel> my final presentation is online, but only in Dutch (for now)
16:46:19 <boegel> I'll translate it in English this week orso
16:46:32 <lispy> cool
16:47:23 <boegel> bye for now
16:47:28 <lispy> bye
17:02:06 <bourbaki> moin
17:04:23 <SyntaxNinja> what does moin mean again?
17:04:41 <bourbaki> heh :)
17:04:45 <bourbaki> sec
17:05:10 <Lunar^> Does anyone have a pointer or a short explaination on how to type mutually recursive definitions?
17:06:13 <bourbaki> SyntaxNinja: http://en.wikipedia.org/wiki/Moin
17:06:27 <dons> Lunar^, there's a good defn in SPJ's online book
17:06:59 <Lunar^> dons: the one describing on how to implement a FP?
17:07:00 <dons> "The Implementation of Functional Programming Languages"
17:07:43 <SyntaxNinja> bourbaki: thanks
17:07:53 <bourbaki> SyntaxNinja: you are welcome
17:08:40 <Lunar^> 1987... damn
17:10:01 <dons> the theory is still much the same
17:10:15 <dons> lambda calc hasn't changed that much ;)
17:10:18 <Lunar^> hehe :)
17:10:48 <dons> maybe I should update to lambda calculus 2000!
17:10:53 <dons> with agile programming support!
17:11:25 <SyntaxNinja> heh
17:11:37 <lispy> aspect oriented lambda calc
17:11:46 <dons> hopefully in lambda calculus 2006 we'll finally get aspect orientation
17:11:48 <SyntaxNinja> lispy: that's the first thing I thought too
17:12:09 <dons> can't wait for the release
17:12:45 <lispy> i thought moin was short for "morning" which is short for "good morning"
17:12:54 <lispy> i was wrong...
17:13:14 <dons> moin is short for moin moin ;)
17:13:34 <bourbaki> both wrong :)
17:13:42 <bourbaki> moin is not short for morning
17:13:51 <bourbaki> and moin is not the same as moin moin either
17:14:00 <dons> that's a joke :P
17:14:04 <lispy> bourbaki: yeah, just learned that from the wiki
17:14:27 <Lunar^> lispy: I was also believing that :)
17:14:34 <bourbaki> though most use it as a universal greeting here
17:14:49 <bourbaki> space and time unbound
17:16:14 <lispy> "The word derives from the Frisian word mooi, meaning beautiful. "
17:16:26 <lispy> so yeah, i could see using it without time bounds
17:17:17 <bourbaki> i think that expressions like that are just great for the internet
18:28:33 <kaol> @moo it's too quiet.
18:28:35 <lambdabot>              (__)
18:28:35 <lambdabot>              SooS
18:28:35 <lambdabot>       /------S\/S
18:28:35 <lambdabot>      / |     ||
18:28:35 <lambdabot>     *  ||----||
18:28:35 <lambdabot>        ^^    ^^
18:28:37 <lambdabot>     This cow belonged
18:28:39 <lambdabot>   to George Washington
18:28:50 <reffie> @ghc
18:28:51 <lambdabot>  GHC's heap exhausted
18:28:57 <reffie> @ghc
18:28:58 <lambdabot>  Cannot unify a type variable with a type scheme
18:29:34 <am02> @moo
18:29:35 <lambdabot>                 /\
18:29:35 <lambdabot>                /  \
18:29:35 <lambdabot>          (__)  \  /
18:29:35 <lambdabot>          (oo)   \/
18:29:35 <lambdabot>   /-------\/    /S
18:29:35 <lambdabot>  / |     ||    /  S
18:29:37 <lambdabot> *  ||----||___/    S
18:29:39 <lambdabot>    ^^    ^^
18:29:41 <lambdabot>  Ben Franklin owned
18:29:43 <lambdabot>     this cow
18:36:09 <am02> Anyone know of a way to get system time to an accuracy better than a second in ghc?
18:36:36 <am02> System.Time and System.Posix.Time have nothing to offer.
18:37:48 <dons> use the ffi to talk to whatever your OS kernel offers
18:38:12 <dons> isn't there nano second accuracy on linux?
18:39:00 <am02> Won't the ffi add an overhead though?
18:39:30 <dons> tiny tiny overhead -- you think a C call is going to hurt?
18:39:43 <dons> anyway, System.Posix is calling C functions too
18:40:11 <am02> ok, I guess its a measurable overhead anyways
18:40:19 <am02> which can be mitigated
18:43:27 <am02> cheers, thought this would be what I'd have to do. Just wasn't looking forward to it.
18:45:10 <dons> pretty easy to write a binding
18:46:08 <dons> foreign import ccall safe "myCfun" myCFunFun :: IO Int
18:46:09 <dons> say
18:47:54 <am02> cool, that is quite simple.
19:01:02 <Cale> Er, System.getCPUTime?
19:01:21 <Cale> Er, System.CPUTime.getCPUTime?
19:01:25 <Cale> heh
19:02:11 <am02> lol, good work cale.
19:04:03 <kaol> @moo for that.
19:04:05 <lambdabot>           __
19:04:05 <lambdabot>           ||
19:04:05 <lambdabot>         (_||_)
19:04:05 <lambdabot>          (oo)
19:04:05 <lambdabot>   /-------\/
19:04:05 <lambdabot>  / |     ||
19:04:07 <lambdabot> *  ||----||
19:04:09 <lambdabot>    ^^    ^^
19:04:11 <lambdabot> Abe Lincoln's
19:04:13 <lambdabot>      cow
19:14:58 <wagle> arent there one-armed if's in the do notation?
19:16:49 <foxy> @index when
19:16:53 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
19:16:53 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
19:16:53 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
19:17:04 <foxy> @type Control.Monad.when
19:17:09 <lambdabot> Control.Monad.when :: forall (m :: * -> *).
19:17:09 <lambdabot>         (Monad m) =>
19:17:09 <lambdabot>         Bool -> m () -> m ()
19:20:43 <lispy> i sometimes wish Bool was a type class
19:21:00 <lispy> instance Bool Boolean where ... Then define the default
19:21:21 <lispy> then if i have some other thing which follows boolean algebra, i can do instance Bool myBool where ...
19:22:20 <lispy> then if could work on the bool type class
19:22:43 <lispy> but then people would define Ints to be an instance of Bool and we'd have C again :)
19:24:17 <am02> do you know how many instances there are of people writing while(1==1) in the linux kernel? Bloody C :)
19:26:49 <am02> oh, actually theres only one these days. I take it all back.
19:30:05 <lispy> int x = 1; while(x==1), while(x=1) while(1) all do the same thing...
19:30:15 <lispy> oh and while(x)
19:31:05 <kaol> there's for(;;) too
19:31:24 <kaol> @vixen What do you think of C coders?
19:31:26 <lambdabot> i dunno...
19:31:41 <lispy> @vixen what do you think of C code?
19:31:43 <lambdabot> let's don't talk about that
19:31:54 <lispy> @vixen what are you wearing?
19:31:56 <lambdabot> nothin but my ol tank top and a pair of shorts :)
19:32:33 <lispy> @vixen are you coding?
19:32:35 <lambdabot> i truely am
19:32:41 <lispy> @vixen naked?
19:32:52 <lambdabot> Is that a real poncho or is that a Sears poncho?
19:32:55 <kaol> @vixen is the code hot too?
19:32:57 <lambdabot> My instant messenger doesn't work.
19:33:15 <mauke> @pl \n -> replicate (a ! n) (print n)
19:33:16 <lambdabot> liftM2 replicate (a !) print
19:33:18 <lispy> @vixen do you have a wizard hat and robe?
19:33:20 <lambdabot> i do occassionally, i guess
19:33:32 <kaol> @vizen eww.
19:33:33 <lambdabot> there is nothing going on in your pants that the dictatorship of the
19:33:33 <lambdabot> proletariat will not solve
19:34:18 <lispy> @type replicate
19:34:20 <lambdabot> replicate :: forall a. Int -> a -> [a]
19:34:58 * wagle is learning to write unix filters in haskell
19:35:06 <lispy> unix filters?
19:35:16 <wagle> stdin to stdout
19:35:53 <lispy> somecommand | waglesPog > foo  ?
19:36:21 <wagle> how do you read an integer from stdin?  the best i find is to do line <- getLine ; let x = readDec line
19:36:33 <wagle> Pog?
19:36:38 <mauke> I think it's x <- readLn
19:36:44 <lispy> oh, sorry i meant Prog
19:37:03 <lispy> @type readLn
19:37:05 <lambdabot> readLn :: forall a. (Read a) => IO a
19:37:20 <wagle> what if you have two ints per line?
19:37:32 <lispy> hmm...
19:37:40 <lispy> or half an int on a line
19:37:48 <lispy> and the other half on the next line
19:38:00 <mauke> wagle: have you seen http://spoj.sphere.pl/problems/BCEASY/ ?
19:38:02 <lispy> this is when you start needed a tokenizer
19:38:34 <lispy> wagle: get a line and look at span and break
19:39:12 <lispy> do { line <- getLine; (i, rest) <- return (span isDigit line) }
19:39:16 <lispy> that might do it
19:39:27 <lispy> for getting the first number
19:39:37 <wagle> lispy: yeah, thats what i would have done by default..  wondered if i was missing a shortcut
19:39:41 <kaol> words might work too, if they're separated by white space
19:39:45 <wagle> mauke: looking at it now
19:40:08 <mauke> it's pretty cool :-)
19:40:09 <lispy> @type words
19:40:10 <lambdabot> words :: String -> [String]
19:40:31 <lispy> words is not parametrizable?
19:40:56 <lispy> @plugs words "this is a story.  Of a man named Brady."
19:40:58 <lambdabot> ["this","is","a","story.","Of","a","man","named","Brady."]
19:41:04 <kaol> no, but you can always do map reads (words x)
19:41:57 <mauke> I have a generalized split :: (Eq a) => a -> [a] -> [[a]] function here
19:41:57 <kaol> @plugs map reads (words "123.2 123.1 35.0")
19:41:59 <lambdabot> Ambiguous type variable `a' in these top-level constraints
19:42:13 <kaol> bah.
19:42:53 <lispy> @plugs (map reads (words "123.2 123.1 35.0")) :: [Int]
19:42:55 <lambdabot> Couldn't match `Int' against `[(a, String)]'
19:43:05 <lispy> @type reads
19:43:07 <lambdabot> reads :: forall a. (Read a) => ReadS a
19:43:17 <lispy> @plugs (map read (words "123.2 123.1 35.0")) :: [Int]
19:43:19 <lambdabot> Fail: Prelude.read: no parse
19:43:25 <lispy> @plugs (map read (words "123.2 123.1 35.0")) :: [Double]
19:43:28 <lambdabot> [123.2,123.1,35.0]
19:43:43 <lispy> @plugs (map read (words "123.2 123.1 35.0"))
19:43:45 <lambdabot> Ambiguous type variable `a' in these top-level constraints
19:43:56 <lispy> does that mean read is monomorphic?
19:44:27 <mauke> @type sequence
19:44:29 <lambdabot> sequence :: forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:44:31 <kaol> @plugs (map read (words "123 123 35")) :: [Int]
19:44:31 <SamB> it is gratifying that most of my type errors these days are really either syntax errors or just me forgetting what I was doing ;-)
19:44:33 <lambdabot> [123,123,35]
19:45:05 <lispy> SamB: yeah, but it took a while to get there, which is what turns a lot of people off
19:46:33 <wagle> mauke: interesting..!
19:46:35 <SamB> the most common reason being that I tried to use $ someplace where I really needed parens
19:46:55 * lispy likes parens over $ anyday
19:47:05 <lispy> but my nick is lispy so it's not surprising ;)
19:47:26 <mauke> parens are overrated
19:47:52 <SamB> I don't like the way I parens effect indentation...
19:48:31 <SamB> I should probably break more things out and name them, but I have such a short module that I don't know what would make sense to break out ;-)
19:49:44 <Cale> I usually take some appropriate blend of parens and $
19:49:55 <mauke> and .
19:49:56 <SamB> this time
19:50:06 <SamB> (arg! bad enter key, bad!
19:50:08 <SamB> )
19:50:27 <Cale> yeah, and .
19:50:53 <SamB> anyhow, this time I don't think I can squeeze any $s in due to precendence
19:51:22 <SamB> well, maybe one.
19:51:32 <SamB> but I think I liked it better without
19:52:51 <SamB> either haskell-mode is looking ahead to the operator on the next line, or there has been some freak coincidence where it somehow indents my code nicely...
19:53:48 <MachinShin> hey +
19:54:28 <Khisanth> SamB: that sounds like a good thing
19:55:06 <SamB> yeah, sort of.
19:55:25 <SamB> it would be nicer if helpful indentation was what I was expecting!
19:55:53 <SamB> oh great, now I get link errors!
19:56:30 <SamB> hmm, I guess I need my sourcefile to Makefile.am...
19:58:51 <wagle> mmm..  first answer is easy..  the other two are hard
19:59:04 <mauke> which one did you find first?
19:59:14 <wagle> n--
20:00:34 <mauke> heh, same here
20:03:47 <wagle> w00t!
20:06:43 <wagle> mauke: what was you other answer?
20:07:04 <mauke> I found all of them
20:07:35 <mauke> which one do you want to know?
20:16:15 <wagle> ah... found all three answers
20:33:28 <wagle> if "cnt <- readIO text", how do i say that "cnt :: Integer" in haskell98?
20:35:15 <mauke> cnt <- (readIO text) :: IO Integer
20:37:06 <wagle> ugh
20:37:35 <wagle> that was what i was about to try, too.. but only as a last resort.  8/
20:40:35 <wagle> wheee:   text <- getLine
20:40:52 <wagle> stupid cut & paste
20:41:14 <wagle> [begin, end] <- getLine >>= (mapM readIO) . words :: IO [Integer]
20:43:05 <lispy> wagle: i think this problem is called monomorphism
20:43:21 <lispy> wagle: you may find a way to deal with it, if you look up that term
20:43:26 <lispy> (a nice way that is)
20:44:11 <wagle> actually i was wanting
20:44:33 <wagle> [begin, end] :: [Integer] <- getLine >>= (mapM readIO) . words
20:44:40 <wagle> but that isnt haskell98
20:46:35 <wagle> huh..  whats the best way to write a for loop in haskell?  8/
20:47:10 <wagle> (while in the IO monad)
20:47:18 * SamB wishes DrIFT supported deriving stuff for types defined in modules that came with the compiler...
20:50:38 <lispy> wagle: i'd write the loop body give it a name and then write a looping function...
20:50:45 <SamB> (maybe it could run GHCi and parse the output of :i)?
20:51:41 <lispy> do syntax needs a goto
20:51:46 <lispy> then we'd be set
20:52:02 <wagle> AIEEEE!!!:
20:52:06 <wagle> @type replicate
20:52:08 <lambdabot> replicate :: forall a. Int -> a -> [a]
20:52:14 <wagle> Int?!?!?!?
20:52:21 <mauke> yeah
20:52:30 <mauke> do you need a list with more than 2 billion elements?
20:52:40 <wagle> Int is evilllllll
20:52:43 <lispy> mauke: i use inifinite lists all the time
20:52:49 <lispy> wagle: yes
20:52:55 <lispy> wagle: but mauke has a good point
20:53:02 <SamB> lispy: you don't need to use replicate to make infinite lists!
20:53:15 <wagle> and thus is haskell type unsafe
20:53:17 <lispy> but what about when i have enough ram to have 80 billion elements?
20:53:26 <SamB> you never could, not with Integral a => a
20:53:37 <lispy> SamB: no, but if you want to index an inifinite list
20:53:43 <lispy> arbitrarily
20:53:51 <mauke> :t genericReplicate
20:53:52 <SamB> @type List.genericIndex
20:53:53 <lambdabot> List.genericIndex :: forall b a. (Integral a) => [b] -> a ->
20:53:53 <lambdabot> b
20:53:58 <wagle> Int overflow is all the rage in script kidie circles
20:54:01 <mauke> @type genericReplicate
20:54:03 <lambdabot> bzzt
20:55:10 <lispy> @type List.genericReplicate
20:55:11 <lambdabot> List.genericReplicate :: forall a i. (Integral i) => i -> a -> [a]
20:57:02 <wagle> sequence_ $ replicate cnt $
20:57:10 <wagle> yuck
21:59:35 <wagle> if my .hs file contains a number of definitions, and i then :l it into ghci, howcome I can see the first defn (main), but not the others?
21:59:58 <dons> they're not exported by default?
22:00:20 <dblhelix> wagle: does your file start with module Bla (main) where ... ?
22:00:46 <dons> or if it's missing that line, module Main (main) where is being inserted by default, iirc
22:01:05 <wagle> i just usually use hugs
22:01:16 <wagle> no module line
22:02:08 <dblhelix> dons: mmm, that does not seem to be the problem (just tested it)
22:02:26 <dblhelix> have you paste your file somewhere, wagle?
22:02:44 <wagle> the symbols exist as Main.foo
22:02:58 <wagle> i guess hugs just automatically exports
22:03:03 <dons> just add either a null export list, or an explicit export list
22:03:25 <dblhelix> it should be working fine without a module header
22:03:46 <dons> oh, and in an interpreter things are all different -- like in ghci where you can get at any top level defn of an interpreted file, whether export or not.
22:03:58 <wagle> part of what i'm doing is working through all this administrivia that i didnt manage picking up
22:04:01 <dons> but if it's compiled, then only what the module system says is visible
22:04:14 <dblhelix> dons: true
22:04:21 <dons> there's karma for obeying the module system anyway.
22:04:51 <dblhelix> dons, wagle: I tend to write module headers and export list for even the smallest toy programs, yeah
22:15:58 <Lemmih> Morning, #haskell.
22:18:56 <kaol> @arr
22:18:57 <lambdabot> Get out of me way, yeh landlubber
22:19:56 <dblhelix> morning Lemmih
23:44:30 <kzm> Good morning.
23:44:52 <kzm> Anybody notice the new Monad Reader?
23:46:27 <Pseudonym> Yup.
23:48:30 <reffie> there's nothing finer than having a vagina.
23:49:10 <earthy> 'good morning' to you too, reffie
23:49:18 <reffie> :)
23:55:08 <kzm> umm...sorry, was away a sec.
23:55:21 <kzm> Is there a way to get a print version of it?
23:55:30 <kzm> (The Monad.Reader, that is, not a vagina)
