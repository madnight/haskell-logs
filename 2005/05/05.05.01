00:18:11 <foxy_> has anyone got gtk2hs(2.6) working on windows with ghc-6.4?
00:24:37 <nothingmuch> quick clarification on type classes: type classes say what can be done to a type, and instances say how it can be done?
00:25:10 <TFK> I think that a type class can also define some behaviour, although it doesn't have to.
00:25:33 <nothingmuch> sort of like an implicit instantiation?
00:25:58 <dons> default methods.
00:26:21 <nothingmuch> ah, i see
00:26:49 <nothingmuch> and the 'deriving' clause, it means to let the compiler compose an instance based on the subtypes?
00:27:20 <dons> the component types, I would say
00:27:21 <pediddle> only for certain classes whose template instances are built in to the compiler
00:43:19 * nothingmuch oohs and aaahs at how do blocks are translated to >>=+lambda
00:45:06 <dons> @type \a b -> a >>= \x -> b >>= \y -> return (a,b)
00:45:07 <lambdabot> \a b -> a >>= \x -> b >>= \y -> return (a,b) :: forall a
00:45:08 <lambdabot>                                                        a1
00:45:10 <lambdabot>                                                        (m :: *
00:45:12 <lambdabot> -> *).
00:45:14 <lambdabot>                                                 (Monad m) =>
00:45:16 <lambdabot>                                                 m a -> m a1 ->
00:45:18 <lambdabot> m (m a, m a1)
00:45:26 <dons> for example ;)
00:48:06 <ski> @type \a b -> a >>= \x -> b >>= \y -> return (x,y)
00:48:08 <lambdabot> \a b -> a >>= \x -> b >>= \y -> return (x,y) :: forall a
00:48:08 <lambdabot>                                                        a1
00:48:08 <lambdabot>                                                        (m :: *
00:48:08 <lambdabot> -> *).
00:48:08 <lambdabot>                                                 (Monad m) =>
00:48:08 <lambdabot>                                                 m a -> m a1 ->
00:48:10 <lambdabot> m (a, a1)
00:49:46 <xerox> 'morning!
00:51:04 <ski> good morning
00:55:20 <skew> good morning
01:04:54 <pediddle> anyone compiled yi lately?
01:05:06 <pediddle> i get this at ./configure:
01:05:07 <pediddle> config.status: error: cannot find input file: mk/config.h.in
01:11:59 <Lemmih> Si\: Ping.
01:13:22 * basti_ is back, this time with the right configuration
01:17:14 <Si\> yes?
01:17:22 * basti_ nods
01:19:17 <Lemmih> Si\: I got a bug fix for 'formdata'.
01:19:47 <Si\> formdata?
01:20:43 <Lemmih> You're Peter Simons, right?
01:20:51 <Si\> no
01:20:58 <Lemmih> Oh, sorry then (:
01:21:00 <basti_> ohh yesterday evening we (that is, liquidengineer, almost reaching insanity in his desparation) encountered a funny phenomenon in readLine
01:21:19 <basti_> readLine wouldn't take an EOF as a line end, but just die coughing
01:36:55 <xerox> Why do I get a name clash about  map  if I do  import Data.Set as Set  ?
01:39:30 <Lemmih> xerox: Try "import qualified Data.Set as Set"
01:40:04 <Lemmih> Good night, Oejet.
01:40:12 <xerox> Lemmih, oh, thanks.
01:41:53 <Oejet> Lemmih: Good morning. ;-)
01:42:12 <xerox> Why Data.Set do say "This module is intended to be imported qualified, to avoid name clashes with Prelude functions. eg.  import Data.Set as Set" ?
01:42:31 <xerox> s/Data.Set/Data.Set's Haddock documentation/
01:43:53 * Lemmih heads to bed.
01:44:01 <xerox> Good night Lemmih
01:45:07 <pediddle> xerox: because Data.Set.map conflicts with Prelude.map
01:45:41 <xerox> pediddle, I mean, it should say "eg.  import qualified Data.Set as Set", doesn't it?
01:46:11 <pediddle> oh yeah, you're right
01:46:30 <TheHunter> @pl \a b -> a >>= \x -> b >>= \y -> return (x,y)
01:46:32 <lambdabot> (. ((. return) . (>>=))) . (>>=)
01:46:38 <TheHunter> @pl \b a -> a >>= \x -> b >>= \y -> return (x,y)
01:46:39 <lambdabot> (=<<) . (. return) . (>>=)
01:46:54 <TheHunter> @pl \a b -> a >>= \x -> b >>= \y -> return (y,x)
01:46:55 <lambdabot> liftM2 (flip (,))
01:47:08 <TheHunter> grrr.
01:47:30 <pediddle> holy crap that's awesome
01:48:39 <TheHunter> it used to be able to do the other two, too.
01:48:58 <vegai> piis pl short for "perlify"
01:49:16 <TheHunter> nah, it's short for pointless.
01:49:34 <nothingmuch> i see in http://www.nomaware.com/monads/html/laws.html that 'mplus' is '++' in
01:49:36 <nothingmuch> lists
01:49:40 <vegai> it *could* be
01:49:42 <nothingmuch> and `mplus` elsewhere
01:49:54 <vegai> cos that is _ugly_
01:49:56 <nothingmuch> is there some kind of convention?
01:50:31 <skew> vegai: I think he was hoping to get out liftM2 (,), flip (liftM2 (,)) and liftM2 (flip (,))
01:51:03 <pediddle> @type (++)
01:51:05 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
01:51:10 <pediddle> @type mplus
01:51:11 <lambdabot> bzzt
01:51:14 <skew> nothingmuch: mplus is defined as ++ on lists
01:51:18 <sjanssen> @type Control.Monad.mplus
01:51:19 <lambdabot> Control.Monad.mplus :: forall (m :: * -> *) a.
01:51:19 <lambdabot>                        (Control.Monad.MonadPlus m) =>
01:51:19 <lambdabot>                        m a -> m a -> m a
01:51:29 <skew> so writing [1,2,3] `mplus` [4,5,6] is the same as [1,2,3] ++ [4,5,6]
01:51:35 <skew> it's defined as other things for other monads
01:51:37 <TheHunter_> @pl \a b -> a >>= \x -> b >>= \y -> return (x+y)
01:51:39 <lambdabot> liftM2 (+)
01:51:52 <nothingmuch> so it's pretty arbitrary, based on what looks pretty?
01:52:06 <pediddle> if you're in the list monad, it's arbitrary
01:52:14 <sjanssen> nothingmuch: or, how generic you want your code to be
01:52:15 <pediddle> if you're in another monad, you have to use mplus
01:52:36 <skew> nothingmuch: the choice of how to implement mplus for a particular monad isn't arbitrary
01:52:57 <nothingmuch> skew: that much I understand... it's the naming convention that confused me
01:53:12 <nothingmuch> so basically the purpose of the infix '++' is to be clear that we are only talking about lists?
01:53:29 <skew> pretty much
01:54:58 <skew> there's no point in writing mplus if your code only works on lists
01:55:41 <nothingmuch> okay, not for a substantial question
01:55:52 <nothingmuch> http://www.nomaware.com/monads/html/exercises.html <-- excercise two
01:56:38 <nothingmuch> parent s = (father s) `mplus` (mother s)
01:56:41 <nothingmuch> grandparent is a little less elegant: (parent $ father s) `mplus` (parent $ mother s)
01:56:44 <nothingmuch> any ideas on how to make it more chic?
01:56:58 <nothingmuch> is 'parent s >>= parent' enough?
01:57:34 <sjanssen> nothingmuch: I think that misses a case
01:58:01 <nothingmuch> if sheep has two parents, and only the non default one has a parent?
01:58:10 <sjanssen> nothingmuch: exactly
01:58:55 <nothingmuch> can i do something like foldl mplus on [father s, mother s]?
01:59:19 <nothingmuch> err, their parents
02:00:27 <nothingmuch> err, don't answer yet, i'd like to try
02:06:33 <nothingmuch> oh right, it's on the wiki
02:06:38 <nothingmuch> nopaste?
02:08:03 <TheHunter_> @seen shapr
02:08:04 <lambdabot> shapr is in #haskell and #webwitches. Last spoke 3 hours, 33 minutes
02:08:04 <lambdabot> and 19 seconds ago.
02:09:38 <nothingmuch> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:10:00 <nothingmuch> does 'folding ancestrial sheep' look sane?
02:11:29 <sjanssen> nothingmuch: have you run this through a type checker?
02:11:58 <sjanssen> @type \xs -> foldl mplus Nothing [xs]
02:12:01 <nothingmuch> no, i can't get MonadPlus to exist
02:12:03 <lambdabot> bzzt
02:12:13 <TheHunter_> import Control.Monad
02:12:26 <sjanssen> @type \xs -> foldl Control.Monad.mplus Nothing [xs]
02:12:28 <lambdabot> \xs -> foldl Control.Monad.mplus Nothing [xs] :: forall a.
02:12:28 <lambdabot>                                                  Maybe a -> Maybe
02:12:28 <lambdabot> a
02:12:29 <nothingmuch> TheHunter_++
02:13:54 <TheHunter> instead of foldl, it's better to use foldr, and foldr mplus mzero already has a name: msum.
02:14:02 <nothingmuch> aha
02:14:10 <TFK> http://hbin.dyndns.org/ <--- is still online, btw.
02:14:49 <pediddle> why better to use foldr -- just to keep the list in order?
02:15:33 <TheHunter> foldr mplus mzero [Just 1, Just 2, Just 3] ==> Just 1 `mplus` foldr ... ==> Just 1
02:16:10 <TheHunter> foldl mplus mzero [Just 1, Just 2, Just 3] ==> ((Just 1 `mplus` Just 2) `mplus` Just 3`) `mplus` mzero
02:16:44 <TheHunter> ==> (Just 1 `mplus` Just 3) `mplus` mzero ==> Just 1 `mplus` mzero ==> Just 1
02:17:09 <pediddle> thx
02:26:33 <nothingmuch> could someone please review the wiki nopaste again?
02:28:28 <sjanssen> nothingmuch: does it typecheck? (esp. safeAncestorsAtLevel)
02:28:40 <nothingmuch> it compiles
02:28:45 <nothingmuch> and it looks sort of OK
02:28:57 <sjanssen> nothingmuch: oh, sorry, I misread something
02:29:11 <nothingmuch> how stupid is the code though? i must be reinventing *something*
02:29:55 <TheHunter> you are not supposed to use the list monad at this level, are you?
02:30:02 <sjanssen> nothingmuch: instead of "Nothing:[]" you can write "[Nothing]"
02:30:53 <nothingmuch> TheHunter: Isn't my use naive enough? to me it's just a list
02:31:08 <skew> mplus is very appropriate here
02:31:30 <skew> you might want to look at concatMap :: (a -> Maybe b) -> [a] -> [b]
02:31:37 <skew> no, mapMaybes
02:31:57 <sjanssen> @type Data.Maybe.mapMaybes
02:32:04 <lambdabot> bzzt
02:32:09 <sjanssen> Data.Maybe.mapMaybe
02:32:16 <xerox> @index mapMaybe
02:32:17 <lambdabot> Data.Maybe
02:32:19 <skew> yeah, that's it
02:32:24 <TheHunter> nothingmuch, i think how you use lists is ok. But you didn't really take advantage of the maybe monad.
02:32:25 <sjanssen> @type Data.Maybe.mapMaybe
02:32:26 <lambdabot> Data.Maybe.mapMaybe :: forall b a. (a -> Maybe b) -> [a] -> [b]
02:32:29 <xerox> Hurray! We got @index back!
02:33:18 <TheHunter> you don't wanna know how it's implemented, though.
02:33:23 <skew> why did you make a list of nothing rather than just an empty list?
02:33:40 <nothingmuch> skew: now that I think of it: no clue
02:34:22 <nothingmuch> okay, so if i return the empty list instead of [Nothing] then i can use mapMaybe, right?
02:34:49 <skew> no, I think that's unrelated
02:34:59 <nothingmuch> oh, it chucks the Nothing for me anyway
02:35:02 <skew> why are you making a list of Maybe Sheep in the first place?
02:35:14 <TheHunter> don't use mapMaybe, you want to learn about monads, not about Data.Maybe.
02:35:33 <skew> where was this tutorial anyway?
02:35:45 <nothingmuch> skew: i was trying to generalize grandparent and parent into a case that basicaly returns the msum of the ancestor level of the sheep
02:35:48 <skew> and what was the deal about not using mplus?
02:35:59 <nothingmuch> http://www.nomaware.com/monads/html/exercises.html
02:36:29 <skew> how are sheep defined?
02:36:38 <nothingmuch> and i did use mplus initially
02:36:41 <nothingmuch> parent = (father s) `mplus` (mother s);
02:36:43 <TheHunter> but still, this exercise looks very list-monadish to me.
02:36:43 <skew> you're given mother and father of type Sheep -> Maybe Sheep?
02:36:45 <nothingmuch> grandparent = (parent $ father s) `mplus` (parent $ mother s);
02:36:54 <sjanssen> nothingmuch: are you familiar with the List monad?  you can express this more easily with lists
02:36:56 <nothingmuch> skew: yes
02:37:05 <nothingmuch> sjanssen: not fully
02:37:32 <skew> then use that maybeToList to get a list of mother and a list of fathers, and have at it with mplus and iterate and such
02:37:56 <nothingmuch> @t maybeToList
02:37:57 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
02:37:57 <lambdabot> init topic-snoc topic-tail topic-tell type pl wn
02:38:08 <nothingmuch> @type maybeToList
02:38:09 <lambdabot> bzzt
02:38:16 <skew> the mention it in the text
02:38:25 <skew> it's just the obvious Maybe a -> [a] function
02:38:26 <pediddle> i wonder if this works too:
02:38:26 <pediddle> ancestorsAtLevel s n = concatMap $ flip safeAncestorsAtLevel (n-1) $ map ($ s) [father, mother]
02:38:52 <pediddle> @pl ancestorsAtLevel s n = concatMap $ flip safeAncestorsAtLevel (n-1) $ map ($ s) [father, mother]
02:38:53 <lambdabot> ancestorsAtLevel = ((=<<) .) . (. subtract 1) . safeAncestorsAtLevel
02:38:53 <lambdabot> . flip map [father, mother] . flip id
02:38:55 <pediddle> woohoo
02:39:20 <nothingmuch> skew: it's not discussed though, so i missed it =/
02:39:32 <nothingmuch> and  Nothing -> []?
02:39:40 <TheHunter> ancestorsAtLevel s 0 = Just s; ancestorsAtLevel s n = (do mom <- mother s; ancestorsAtLevel mom (n-1)) `mplus` (do dad <- father s; ancestorsAtLevel dad (n-1)).
02:40:28 <pediddle> or use list comprehension
02:40:36 <nothingmuch> TheHunter: that is just one ancestor, and not a list of thereof, right?
02:41:17 <TheHunter> nothingmuch, yep, just one.
02:41:25 <TheHunter> but it uses the list monad.
02:42:11 <nothingmuch> where does it do that?
02:42:15 <sjanssen> TheHunter: your version uses the list monad?
02:42:22 <TheHunter> you have parent = ancestorsAtLevel 1 (swapping the argument order of aal), grandparent = aal 2
02:42:24 <nothingmuch> reading it i don't see how it's not maybe
02:42:39 <TheHunter> sjanssen, no, just maybe.
02:43:13 <skew> TheHunter: that kind of breaks
02:43:45 <TheHunter> @wn breaks
02:43:47 <lambdabot> No match for "breaks".
02:44:21 <skew> if the sheep has a mother and father the first level gets committed to following the mother up, even if she has no ancestors
02:44:50 <TheHunter> oh, misread.
02:44:52 <skew> wait, no it doesn't
02:45:53 <skew> if there isn't the first do gets Nothing and we continue to the other side of the mplus
02:47:51 * nothingmuch lunches
02:48:31 * basti_ lynches
02:48:40 * Oejet runs
03:02:55 <lightstep> is there a known cause for c2hs to be very slow? i'm compiling gtk2hs, and it's running the local c2hs on some files. but the serialisation phase doesn't finish after tens of minutes, and almost doesn't take cpu (it does allocate tens of megabytes, however)
03:05:46 <dcoutts> lightstep, yes the known cause is that for some reason the serialisation allocates loads of garbage when it really ought to run with zero allocations
03:06:19 <lightstep> but will it finish, if i leave it to run until i return at the evening?
03:06:50 <jlouis> hmmm, I need malcolm and some nhc98 makefile expertise
03:06:56 <dcoutts> it will eventually finnish. I was talking to JaffaCake about this the other day and he had a couple more suggestions to try to improve the situation, so we'll see how that goes.
03:07:02 <jlouis> I think I'll write him a mail
03:07:20 <lightstep> great
03:07:46 <dcoutts> lightstep, it'll either finnish or die due to causing an OOM situation :-)
03:08:21 <basti_> well there's still swap :)
03:08:25 <nothingmuch> hola lightstep
03:08:37 <lightstep> hi
03:08:54 <dcoutts> basti_, sadly the swap doesn't help much :-(
03:09:01 <lightstep> it won't oom, since the makefile is smart enough to limit the heap
03:09:14 <basti_> no it won't be helping ;)
03:09:21 <basti_> but it will keep things from crashing
03:10:10 <dcoutts> lightstep, yes it is memory limited so it's ok if that memory limit is less that your system's free ram. That's not the case for everyone.
03:10:37 <dcoutts> we have to provide a workaround for people with less ram, there's an FAQ about it on the web site
03:11:31 <lightstep> doesn't adding exclamation marks everywhere solve this?
03:12:26 <dcoutts> lightstep, you mean more strictness? not realy, the problem is not space leaks (at least we don't think so) but just holding far too much data in memory at once
03:13:17 <lightstep> strictness should also make everything be done immediately, without creating thunks and holding things in memory
03:14:16 <dcoutts> true, but the heap profiles show us that it's not thunks that are the memory hog but large finite maps and syntax trees
03:16:13 <lightstep> wow. limiting memory caused c2hs to finish in seconds instead of hours
03:16:48 <dcoutts> lightstep, is that because it was causing lots of swapping?
03:16:51 <basti_> o.0
03:17:15 <lightstep> yes
03:17:28 <dcoutts> lots of slow compacting gc collections is always better than swapping
03:17:30 <lightstep> o thought the swapping was almost meaningless
03:17:56 <lightstep> now i get lexingmport GHC.Base (unsafeCoerce#) error on
03:18:04 <lightstep> fuck copy&paste
03:18:17 <dcoutts> you're using ghc-6.4 right?
03:18:44 <lightstep> yes, and it missed spaces
03:18:58 <lightstep> oh, it didn't
03:19:15 <dcoutts> 0.9.7 came out before ghc-6.4 :-(
03:19:44 <dcoutts> you can either wait for 0.9.8 in a couple weeks or use the current cvs version, or pester us enough to provide a backport
03:20:15 <lightstep> it won't compile? it still goes well
03:20:37 <dcoutts> or use ghc-6.2.2, or ask us to provide a semi-tested cvs snapshot
03:21:16 <dcoutts> it needs a couple makefile patches to build with 6.4, but mainly it needs the package files converting to the new cabal format
03:21:46 <dcoutts> 6.4 dropped the previous package format with no backwards compatability
03:22:07 <dcoutts> the current cvs version has all this stuff in
03:26:18 <lightstep> anonymous login doesn't work?
03:27:38 <lightstep> nevermind, i fogot my cvsque
03:29:22 <wizard73> hi
03:29:46 <wizard73> hows the programming folks, do you laugh atpoor sods forced to use java?
03:30:21 <lightstep> autoreconf launches aclocal, which complains that configure.ac is buggy
03:30:29 <basti_> wizard73: only behind our hands
03:30:54 <lightstep> specifically, it doesn't recognize AM_PROG_CC_C_O
03:31:09 <skew> we have pity and compassion for the less enlightened
03:31:13 <lightstep> is there a debian package that contains those macros
03:31:14 <lightstep> ?
03:31:44 <wizard73> I went to a kinda smoky bar with a group o fpals who are like no sex rows but instead of waring my usual fancy gap shirt I wore australian t shirt
03:31:46 <wizard73> and jeans
03:31:48 <wilx> It's automake part.
03:31:49 <zamez> the fun of autoblah
03:31:50 <wizard73> it was cool
03:32:04 <wizard73> then i didnt leave with them but hooked up with some drung guy
03:32:09 <wizard73> and went  to strip club
03:32:15 <wizard73> a cheap ass one
03:32:17 <wizard73> lol
03:32:36 <lightstep> wilx, do you know which version of automake is good enough? i have 1.4
03:32:50 <dcoutts> lightstep, this seems to be a problem with debian's autotools setup. You need automake 1.8
03:32:53 <wizard73> the blonde in the group of friends getting a divroce wont bang me
03:32:57 <lightstep> yay
03:33:04 <wizard73> and I think she is banging  my pal with tattoos
03:33:07 <wizard73> gross
03:33:20 <wilx> lightstep, too old I guess. Recent automake is 1.9.5.
03:33:21 <dcoutts> but you've probably got 1.8 installed but debian's automake is running the wrong one
03:33:26 <wizard73> maybe shes not giving it up at all i dont know
03:33:39 <skew> wizard73: we haven't quite figured out how to solve *that* sort of problem with Haskell
03:33:48 <wilx> lightstep, try something like autoreconf19.
03:33:48 <lightstep> dcoutts, surprisingly not, but i will install in a sec
03:33:51 <wizard73> my life is shallow drivel
03:33:55 <dcoutts> I found that actually we don't need the AM_PROG_CC_C_O line...
03:34:06 <wizard73> but I really do wish to have sex not alone once in a while
03:34:14 <dcoutts> you can edit configure.ac and remove the AM_PROG_CC_C_O line
03:34:16 <wilx> Hmm, reconf is probably autoconf part though...
03:34:19 <wilx> Hmmpf.
03:34:33 <wizard73> moving tomorrow and starrting sysadmin job with java suport ant cvs tomcat on solaris and etc
03:34:34 <wizard73> scary
03:34:41 <dcoutts> then you also need to edit Makefile.am and remove the subdir-objects bit from the first line
03:34:42 <wizard73> I think i lied a bit on my resume
03:34:55 <dcoutts> then autoreconf and I think you've got a better chance
03:35:15 <wizard73> nasty a giant mosquito bug is in my partment
03:35:24 <wizard73> flying just outa reach
03:35:33 <wizard73> like thos emutant mosquito like 2 inch long
03:35:51 <wizard73> oh when driving home 2 black girls stoped in the car next to us
03:35:59 <wizard73> and almost wanted to know whats up
03:36:07 <wizard73> I dunno what scared em off
03:37:31 <lightstep>  required file `./missing' not found
03:37:43 <dcoutts> $ autoreconf --install
03:37:47 <lightstep> strange. the workd `missing' doesn't appear in configure.ac
03:38:22 <dcoutts> no, it's not actually used, just autotools want it to exist. [grrr]
03:39:01 <lightstep> yes
03:39:25 <lightstep> you might like to expand the autoconf section of INSTALL
03:39:41 <dcoutts> yes, it's on my TODO list :-)
03:41:31 <lightstep> why doesn't ghc6.4 like FiniteMap?
03:41:57 <dcoutts> because GHC 6.4 adds Data.Map and deprecates Data.FiniteMap
03:42:18 <lightstep> but FiniteMap will stay supported, won't it?
03:42:32 <dcoutts> but we need to be compatible with older ghc versions so we're continuing to use FiniteMap
03:42:54 <dcoutts> I think it will stay supported for some time since very many programs use it
03:43:39 <wilx> Backward compatibility is evil.
03:43:47 <wilx> wrt/ coding.
03:43:58 <dons> there's a useful Map<->FiniteMap layer in yi and lambdabot
03:44:04 <dons> also POpen<->System.Process
03:44:34 <Heffalump> lack of backward compatibility leads to CPP
03:44:38 <Heffalump> CPP leads to suffering
03:45:07 <dons> hehe
03:45:09 <dcoutts> :-), gtk2hs uses a fair bit of CPP, since it also works with Gtk+ 2.0 to 2.6 :-)
03:46:21 * Heffalump had to CPP-ise HTTP to support GHCs 6.2 and 6.4 at the same time :-/
03:46:32 <dons> yeah, cpp isn't so bad.
03:47:15 <dcoutts> dons, yes, it depends on how it's being used, it certainly can lead to suffering
03:47:23 <dons> yi, lambdabot and hs-plugins all do that. I don't think it's a huge problem between 6.2 and 6.4 (except TH)
03:47:35 <dons> it can certainly lead to suffering.
03:48:02 <dons> I think I saw a fp in C++ using CPP link earlier today, for example...
03:50:04 <dons> and you can say it's really cpphs that we're targetting ;)
04:03:46 <dons> @ghc
04:03:47 <lambdabot>   Kind error
04:03:58 <dons> @ghc
04:03:59 <lambdabot>   Cycle in class declarations (via superclasses)
04:04:05 <dons> @ghc
04:04:06 <lambdabot>   Can't represent explicit kind signatures yet
04:04:15 <dons> really? more please
04:04:18 <dons> @ghc
04:04:19 <lambdabot>   GHC error in desugarer lookup
04:04:29 <dons> hehe. that's bad.
04:04:43 <TheHunter> hey dons
04:04:53 <dons> hey TheHunter.
04:05:02 <dons> read your article through once. very impressive!
04:05:15 <TheHunter> thanks.
04:05:27 <dons> no major flaws, but i'll reread it in close detail for typos and grammar
04:06:04 <TheHunter> cool, thanks.
04:06:09 <dons> I think I saw germanic-looking "Operator" once or twice, instead of operator.
04:07:09 <TheHunter> hehe.
04:07:12 <dons> ".. uses two unsafe Operations.."
04:07:13 * TheHunter reruns aspell on it.
04:07:37 <TheHunter> ok, fixed.
04:09:34 <TheHunter> ooo, "invokation"
04:09:38 <dons> hehe
04:16:10 <pesco> Heh, a year of English has completely ruined my (native) German capitalization skill.
04:16:23 <pesco> I tend to capitalize adjectives.
04:18:42 <skew> pesco: you can capitalize your english Nouns if you like
04:18:56 <skew> we won't mind.
04:20:15 <pesco> Cool, that's very nice! I think I'll do that. ;)
04:20:37 <skew> visitng Germany totally scrambled my prepositions
04:20:45 <pesco> Heh, how so?
04:21:17 <pesco> I hope you won't mind either if i conversely drop the capitalizations as they would be required in English?
04:21:59 <skew> many english prepositions sound like a german preposition used in different situations
04:22:35 <skew> I would use the word that sounded like the right german word
04:22:38 <pesco> Oh, like vor/for?
04:22:56 <skew> sort of
04:23:13 <pesco> Cool. :)
04:23:48 <skew> like meeting on the coffee shop
04:23:56 * pesco laughs.
04:23:59 <pesco> I see.
04:24:05 <tuomov> prepositions are confusing. to this day I haven't learned to use them properly in english
04:25:27 <skew> I'd like a script for keeping only the expensive parts of the call tree, leaving the ancestors
04:25:45 <skew> see, that's another thing - forgetting what IRC window I'm typing in
04:27:47 <pesco> But that was not caused by visiting Germany, i suppose?
04:28:51 <skew> I don't think so
04:33:20 <dons> skew, and I was just starting to schedule some brain time to what seemed a quite difficult problem
04:33:36 <dons> only to find it was just a fragment out of context
04:34:01 <skew> dons: you're welcome to help, if you like
04:34:24 <skew> I'm inspecting the results of profiling pugs
04:35:18 <dons> oh, the profiling output call tree
04:35:28 <skew> but I'd like to just keep any individual items that contribute more than a percent, and their ancestors (so grep isn't good enough)
04:35:59 <dons> sed!
04:36:07 <dons> perl!
04:36:21 <dons> parsec!
04:36:23 <skew> I already asked for suggestiong on #perl6
04:36:31 <skew> I think I see how to do it in sed...
04:37:00 <nothingmuch> skew: how does the result file look?
04:37:03 <skew> I just need to keep all the current ancestor lines, newlines and all, in that extra buffer thing, and do some fancy conditionals and regexps and stuff
04:37:16 <dons> the hold space
04:37:36 <nothingmuch> it should be trivial in perl
04:37:57 <skew> compile a Haskell program with -prof, run it with +RTS -p -RTS tossed into the arguments somewhere, and you will have a profiling dump of your very own
04:39:13 <skew> the part I care about has on each line (space separated) name, module, #calls, %time, %alloc, inherited %time, inherited %alloc
04:39:27 <skew> the name is indented varying numbers of spaces to indicate the call tree
04:45:33 <basti_> :-o
04:46:12 <TheHunter> dons, "Don Stewart" ok?
04:46:25 <dons> yep.
04:46:59 <TheHunter> great.
04:51:18 <dons> last line "of feature (GHC) Haskell" -> "feature of (GHC) Haskell"
04:52:49 <TheHunter> yep, thanks.
04:53:32 <TheHunter> "A also want to thank Peter Eriksen, Cale Gibbard and Don Stewart for proof-reading the article and their valuable suggestions, as well as Brandon Moore and Autrijus Tang for their advice on the references."
04:53:35 <TheHunter> is that ok?
04:53:57 <skew> A -> I
04:54:09 <dons> fine with me :)
04:54:09 <TheHunter> right.
04:54:44 <TheHunter> oki.
04:56:14 <TheHunter> so let's re-pdf-ize this thing.
04:57:00 <Oejet> TheHunter: Do you have a Wiki -> PDF translator?
04:57:24 <TheHunter> nah, didn't start that one.
04:57:35 <TheHunter> i'll do it with a few regexps.
04:57:45 <TheHunter> i can do yours too, if you like.
04:58:32 <skew> TheHunter: are you generating a PDF directly with regexps?
04:58:40 <Oejet> Do you go Wiki -> LaTeX -> PDF?
04:58:49 <skew> that would be cool
04:58:57 <TheHunter> skew, sure is there any other way ?
04:59:20 <TheHunter> nah, i'll try to use kosmikus' tmr package.
04:59:27 <basti_> :-o
04:59:36 <dons> doesn't everyone write compilers with regexes?
04:59:37 <skew> I suppose you could make an image file, but PDFs are much better for text things
05:00:15 <Oejet> A grammar that doesn't fit in a regexp is too compilcated.
05:00:41 <skew> but a regexp that fits a grammar is too complicated too
05:00:59 <basti_> no i write compilers with shift-reduce parsers, for example.
05:00:59 <skew> oops, almost said that on #perl6...
05:01:01 <Oejet> TheHunter: kosmikus' TMR package is the one used in issue one?
05:01:09 <TheHunter> yep.
05:01:56 <TheHunter> :%s/==== \(.*\) ====/\\musthavesubsection{\1}/...
05:02:27 <TheHunter> *subsubsection
05:03:41 <Oejet> TheHunter: That would be very nice.  Maybe it would be worth while to put the regexps in a script?
05:04:16 * TheHunter admits ashamedly that he's never written a vi script.
05:06:32 <TheHunter> :%s/{{{\([^}]*\)}}}$/|\1|/eg <-- why doesn't that match {{{IO}}} ?
05:08:37 <TheHunter> ahh, the $ was wrong...
05:09:18 <basti_> of course.
05:09:20 <basti_> :)
05:12:23 <skew> well, the big link on http://users.rowan.edu/~afshar/ goes to a uselessly vauge description of the experiment
05:12:42 <skew> ah,  heck, you will will all be interested too...
05:20:30 <_JusSx_> gaum
06:33:14 <shapr> slow day today...
06:33:20 <shapr> isomer: how's life?
06:33:24 <xerox> Yep :-\
06:33:29 <musasabi> very slow..
06:33:32 <isomer> hi shapr !
06:33:36 <isomer> it's good thanks. with you?
06:33:38 <musasabi> may day causes things like that.
06:34:03 <isomer> hey, shapr, any chance you're heading home this summer?
06:34:09 <shapr> I had a code breakthrough last night with this pluggable zope persistence.
06:34:14 <shapr> isomer: nah, don't think so.
06:34:39 <musasabi> shapr: please tell more :-)
06:34:40 <shapr> isomer: especially since missing subarctic summers is a real waste. It's warm, sunny, and totally photosynthetic here.
06:34:42 <ski> hiya shapr
06:35:04 <Maddas> shapr: yay :-)
06:35:09 <isomer> shapr: ah... too bad. i was hoping to meet up when i go to visit my dad.
06:35:46 <shapr> isomer: maybe next year
06:37:09 <pesco> Does cabal-get use the Hackage database?!
06:38:12 <shapr> I'm thrilled I got this code working, too bad the problem was lack of docs rather than a difficult task.
06:38:31 <pesco> :( Good is good!
06:38:46 <shapr> We need one more TMR article to get up to the minimum, I'll have to hack up a Template Haskell tutorial when I get back from being social.
06:38:56 <pesco> :)
06:39:22 <pesco> I will be finished with mine in 30-60 minutes.
06:39:32 <shapr> It'll be a few hour for me.
06:39:35 <shapr> hours
06:41:39 <shapr> TMR2 is close to release! w00!
06:41:43 <pesco> My god. This thing has grown LONG!
06:41:54 * pesco hums some NIN tune.
06:42:17 <shapr> Oejet: Hey, your bzlib article is ready, right?
06:42:43 <shapr> Oh,  maybe I won't have to write an article myself then, w00
06:42:58 <shapr> pesco: would that be "A Warm Place"?
06:43:35 <pesco> shapr: I'm not sure about the title, but I think that's another one.
06:44:29 <Oejet> shapr: What does the Definite Articles section say?
06:46:19 <shapr> Oejet: it says yes!
06:46:28 <shapr> w00
06:48:10 <shapr> Ok, I have to disappear and be social, when I return I shall enable the access control on tmrwiki and kick TMR2 out the door!
06:48:13 * shapr dances the happy dance
06:49:32 <pesco> shapr: "Ruiner"!
07:11:46 <ski> hm .. "Mercury 0.12.0-beta available"
07:44:37 <raver> hi mates
07:46:50 <Cale> raver: hello
07:47:23 <ski> lambdabot: @hello
07:47:24 <lambdabot>  @help <command> - ask for help for <command>
07:47:53 <TheHunter> @seen Philippa
07:47:54 <lambdabot> I saw Philippa leaving #haskell 38 minutes and 20 seconds ago,
07:47:54 <lambdabot> and I have missed 6 seconds since then.
07:48:11 <TheHunter> yay, works!
07:48:21 <TheHunter> @seen pesco
07:48:23 <lambdabot> pesco is in #haskell. I don't know when pesco last spoke.
07:48:38 <TheHunter> that's a bug, i guess.
07:49:24 <ski> TheHunter : you updated @seen ?
07:49:38 <pesco> Bug?
07:49:39 <TheHunter> yeah, some time ago.
07:49:40 <pesco> @seen pesco
07:49:41 <lambdabot> You are in #haskell. Last spoke just now.
07:49:45 <pesco> Haha!
07:49:58 <TheHunter> the bot quit, reconnected and forgot when you last spoke.
07:50:08 <pesco> Oh, I see it should save the state.
07:50:12 <jlouis> IIRC I was down over SeenModule too and cleaned it up a bit
07:50:19 <jlouis> but i did not add functionality
07:50:55 <TheHunter> hacking on @seen isn't really fun.
07:51:01 <TheHunter> that's all way to stateful.
07:52:07 <jlouis> haha
07:55:24 * esap wonders what would be the best way to implement joining of stateful variables in Haskell.
07:57:00 * esap thinks of something along the lines of: join_vars :: IORef a -> IORef b -> IORef (a,b)
07:58:52 <Lemmih> It better be :: IORef a -> IORef b -> IO (IORef (a,b)) (:
07:59:04 <esap> true, that's better.
07:59:37 <ski> joining ?
07:59:41 <ski> hm
07:59:57 <esap> splitting is easy, but joining is harder.,
08:02:37 <esap> Well you could allocate new memory for it, but that's actually what I'd like to avoid.
08:03:29 <ski> that reminds me of my lvalue-language
08:04:09 <xerox> C ?
08:04:15 <ski> no
08:04:17 <esap> The thing is, I'm currently having some trouble implementing OO because whatever I do, I have to allocate every variable in separate chunk of memory. It's hard to make the allocation occur at coarse-grained level.
08:04:22 <ski> more powerful lvalues
08:05:08 <ski> esap : maybe you need another Ref type for such a join op to be efficient ..
08:05:20 <esap> yes of course.
08:06:22 <esap> The problem is, I can build large values which refer to the variables, but if I wanted to store the whole object in such variable, then I can't use the same storage for those variables.
08:06:30 <ski> a join could be passed references to cells far away from each other
08:06:32 <integral> join_vars :: IORef a -> IORef b -> IORef (a, b) -> IO () ?
08:06:50 <esap> integral: what would that do?
08:07:07 <integral> set the value in the third IORef, rather than returning a new one...
08:07:28 <jlouis> pure side effect
08:07:30 <tuomov> hmm.. mutable records could be handy
08:07:47 <TheHunter> @seen jlouis
08:07:48 <thbot> jlouis is in #haskell. I don't know when jlouis last spoke.
08:07:49 <lambdabot> jlouis is in #haskell. I don't know when jlouis last spoke.
08:07:59 <TheHunter> grrrr.
08:08:22 <ski> (hmm, RefM a ~= WriteRef a -> M () )
08:09:39 <esap> I can currently implement variables in OO by using either IORef, a Chan, or an MVar. But it's hard to have member variables use the object's memory instead of external memory.
08:10:15 <tuomov> some IOArray kludge with unsafeCoerce..
08:10:44 <esap> I've been thinking about IOArrow support for my allocators, but I'm not sure if it'll work.
08:10:49 <esap> IOArray I mean.
08:10:55 <ski> esap : object's memory ?
08:11:19 <tuomov> of course, the "object's memory" would only store pointers to the actual data unless you unbox things
08:11:19 <esap> ski: Objects need to be stored somewhere.
08:11:27 <ski> of course
08:11:53 * ski tries to get what esap wants
08:12:15 <tuomov> mutable records?
08:12:55 <esap> tuomov: Does GHC have mutable records? You can change record members, but it's not mutable.
08:13:09 <tuomov> I mean, that's what you essentially want, right?
08:13:29 <tuomov> you could update fields without reallocating the whole record
08:13:58 <tuomov> just like IOArrays, but structurally more complex..
08:14:16 <esap> tuomov: well almost. I tried to do that. Update is very complex that way.
08:16:11 <esap> tuomov: Because it's not possible to quantify over record projections.
08:17:04 <esap> tuomov: so the user would have to provide an instance for every conceivable member.
08:18:00 <tuomov> yeah, it's complicated to implement with arrays
08:19:18 <TheHunter> hmm, does -O2 optimize traces away?
08:33:36 <TheHunter> lisppaste2, ?
08:33:48 <TheHunter> lisppaste2, paste
08:33:54 <TheHunter> lisppaste2: ?
08:34:11 <TheHunter> lisppaste2: what's the matter with you?
08:34:58 <TheHunter> hi RemiTurk
08:37:20 <RemiTurk> hi
08:37:55 * RemiTurk loves his university's website: I have an exam on tuesday but can't find the website of the course :)
08:40:00 <TheHunter> thbot, @seen RemiTurk
08:40:00 <thbot> RemiTurk is in #haskell. I last heard RemiTurk speak 2 minutes
08:40:00 <thbot> and 5 seconds ago, but I have missed 6 seconds since then.
08:40:40 <TheHunter> lambdabot, @seen RemiTurk
08:40:41 <lambdabot> RemiTurk is in #haskell. I last heard RemiTurk speak 2 minutes
08:40:41 <lambdabot> and 46 seconds ago, but I have missed 3 seconds since then.
08:41:33 <RemiTurk> hi thbot, are you family of lambdabot?
08:42:24 <thbot> hi RemiTurk, yep, i'm his brother.
08:42:47 <TheHunter> @seen jlouis
08:42:47 <thbot> jlouis is in #haskell. I don't know when jlouis last spoke.
08:42:48 <lambdabot> jlouis is in #haskell. I don't know when jlouis last spoke.
08:43:09 <RemiTurk> thbot, nice to meet you.
08:43:34 <TheHunter> RemiTurk, the bots seem to like you better than jlouis. The remeber you, but they don't remember him under very much the same circumstances.
08:45:05 * RemiTurk feels flattered
08:45:42 * TheHunter wonders if the state is accessed concurrently and this is some kind of race condition.
08:46:27 <TheHunter> nah, looks very single-threaded.
08:47:32 * RemiTurk wonders if this is some instance of "when in doubt, blame concurrency" :P
08:47:44 <TheHunter> @seen tuomov
08:47:45 <thbot> tuomov is in #haskell. I don't know when tuomov last spoke.
08:47:45 <lambdabot> tuomov is in #haskell. I don't know when tuomov last spoke.
08:47:57 <TheHunter> lambdabot, @seen ski
08:47:58 <lambdabot> ski is in #haskell. I last heard ski speak 36 minutes and 4 seconds
08:47:58 <lambdabot> ago, but I have missed 3 seconds since then.
08:48:30 <RemiTurk> @seen TheHunter
08:48:31 <thbot> TheHunter is in #haskell. Last spoke 34 seconds ago.
08:48:31 <lambdabot> TheHunter is in #haskell and #uiuiui. Last spoke 6 seconds ago.
08:48:53 <RemiTurk> thbot doesn't know #uiuiui?
08:49:13 <TheHunter> aargh, that's another bug.
08:49:29 <TheHunter> what have i done to SeenModule?
08:49:51 <TheHunter> @seen thbot
08:49:51 <thbot> Yes, I'm here.
08:49:52 <lambdabot> thbot is in #haskell and #uiuiui. Last spoke 1 minute and 20 seconds
08:49:52 <lambdabot> ago.
08:50:51 <RemiTurk> I hope it's in revision control?
08:51:29 <TheHunter> sure it is. But it won't be reverted. The old code was horrible, too.
08:52:13 <RemiTurk> but it might make searching what went wrong a little easier
08:53:27 <TheHunter> i don't know. I added a lot of stuff.
08:54:15 <TheHunter> this whole @seen module is a mess, and always has been. You fix one bug, and bang, you've introduced another one.
08:54:25 <RemiTurk> :-/
08:54:45 * TheHunter is bad at writing stateful code.
08:56:02 <RemiTurk> does "People are bad at riting stateful code." make you feel better? ;0
08:56:08 <RemiTurk> s/riting/w&/
08:57:34 <TheHunter> thbot, @join #uiuiui
08:57:45 <TheHunter> thbot, @seen TheHunter
08:57:45 <thbot> You are in #uiuiui. Last spoke just now.
08:59:49 <jlouis> equal rites
09:02:04 * TheHunter gives up. Chasing heisenbugs is not my thing
09:05:23 <jlouis> seen has a lot of state-tracking
09:08:39 <Cale> TheHunter: Debug.Trace is handy to spit out a representation of the input to your function that you're looking for
09:10:21 <TheHunter> basti_, not much interesting going on there :)
09:10:36 <basti_> ;)
09:11:04 <basti_> "uiuiui" isnt that what samson from the sesame street always was saying?
09:11:17 <basti_> "ulli. tiffy. herr von bööööhnefeld. UIUIUIUIUIUI"
09:11:40 <basti_> s/from/of/
09:12:19 <TheHunter> i just chose that name because it was easy to type.
09:12:26 <basti_> =)
09:18:33 <TheHunter> anyone got an idea how i can get pretty haskell typesetting with kosmikus' tmr style?
09:20:11 <Oejet> TheHunter: Listings.sty.
09:20:49 <pesco> shapr: DONE!
09:21:08 <TheHunter> Oejet, how do i include that?
09:21:37 <Oejet> You have already. ;-)
09:21:51 <TheHunter> so what do i have to do to make it pretty?
09:22:06 <Oejet> ]texdoc listings
09:22:22 <TheHunter> or how do i do a listing, for that matter?
09:22:42 <Oejet> I'll look it up.
09:23:28 * TheHunter installs tetex-doc...
09:23:51 <TheHunter> wow 28MB
09:25:55 <Oejet> \usepackage{listings} \lstset{language=HAskell} ... \begin{lstlisting}...
09:27:52 <TheHunter> cool, thanks
09:29:46 <pesco> TheHunter: lhs2TeX?
09:30:25 <TheHunter> pesco, tmr style, for the pdf.
09:32:05 <pesco> TheHunter: I think you can use that in conjunction with the tmr style, can't you?
09:32:59 <TheHunter> yeah, i guess that's what i'm doing
09:33:15 <reffie> i just use regular latex
09:33:30 <reffie> i don't like the lhs2TeX output
09:33:44 <TheHunter> but i'm not sure it looks prettier.
09:36:14 <TheHunter> why does it highlight lookup and insert?
09:42:39 <pesco> Ew, right, it highlights Prelude functions.
09:43:11 <pesco> lhs2TeX --poly produces ugly output by default, that's an ugly bug, if you ask me.
09:43:48 <pesco> But given the right fmt definitions, the output becomes gorgeous.
09:47:28 <TheHunter> oh, well. sounds too complicated for now.
09:47:59 <pesco> :/
09:51:21 <bourbaki> moin
10:11:35 <wizard73> yeah
10:11:46 <wizard73> complication killed the cat
10:12:09 <wizard73> is haskell a lisp dialect?
10:12:39 <Igloo> No
10:13:10 <Igloo> They're about as far apart as they can be while still both being classified as functional programming
10:13:11 <mauke> Not just no, but HELL no.
10:19:46 * basti_ is curious for TMR
10:20:04 <basti_> wizard73: knowing lisp will help you learning haskell, though.
10:20:17 <basti_> you won't be confused by all of the bizarre concepts.
10:20:20 <basti_> just by most of them
10:28:28 <Cale> basti_: heheh
10:28:54 <Cale> actually, knowing no programming language is probably the best point to start learning Haskell
10:29:01 <Cale> or just mathematics
10:29:27 <Cale> because then you won't get hung up comparing it to programming languages you already know :)
10:32:40 <RemiTurk> knowing e.g. Miranda might help, I'd think
10:32:59 <RemiTurk> or *grin* Curry
10:33:29 <Cale> yeah, or Gofer
10:33:59 <RemiTurk> :)
10:34:00 <Cale> or other things either Haskell was based on, or which are themselves based on Haskell. :)
10:36:02 <Muad_Dibber> is there already complete new languages based on haskell then?
10:37:26 <RemiTurk> for some value of "complete new"
10:37:35 <hyp3rion> happy birthday gdsx :)))
10:37:44 <RemiTurk> Curry = Haskell + logic programming
10:37:52 <RemiTurk> O'Haskell = Haskell + OO
10:37:53 <RemiTurk> etc
10:44:15 <vegai> Haskell = ?
10:46:27 <tuomov> Miranda++?
10:47:20 * RemiTurk just had the pleasure of seeing bzflag cause X to do
10:47:22 <RemiTurk> die
10:47:37 <basti_> there's a LP dialect of haskell?
10:47:39 * basti_ drools :)
10:47:50 <RemiTurk> there is
10:47:57 <hyp3rion> i had the pleasure of seeing enigma cuase my monitor to die
10:47:58 <hyp3rion> :(
10:48:13 <basti_> Cale: this might be true yes
10:48:33 <RemiTurk> basti_, http://www.informatik.uni-kiel.de/~mh/curry/
10:48:58 <RemiTurk> it appears to have more implementations than Haskell ;)
10:49:32 <basti_> hehe
10:50:30 <tuomov> I wonder if the Makefile has a 'curry' target
10:51:11 <RemiTurk> :)
10:52:11 * RemiTurk was very surprised for a moment when he read the word "LP" on a site about music, until he realized it was about another kind of "LP"
10:52:40 <basti_> lol
10:54:22 <hyp3rion> you heard about logic programming before long play records?
10:55:04 <RemiTurk> no I didn't, but my multi-tasking occasionally confuses me :)
10:55:54 <hyp3rion>      * in popular usage in Taiwan, an abbreviation for testicles ("lan pa")
10:56:59 * RemiTurk decides not to confuse myself even more and use the word "testicles" for the rare occasions I need to
10:58:08 <Gahhh> lol
10:58:09 * basti_ just read a blog by some journalist in japan, who stumbled over the similarity of the word for "testicles" to the one for a popular game (similar to single-person-pingpong)
10:58:38 * RemiTurk thinks it must be sunday evening
10:58:45 <basti_> he actually went around the store, telling everyone "i used to have testicles when i was younger, i played with them all the time"
10:59:03 <RemiTurk> now you did it
10:59:08 <RemiTurk> you scared elk away
10:59:48 <hyp3rion> 14400 seconds ago
11:00:00 <hyp3rion> that's how long such a timeout takes iirc
11:01:20 <basti_> o0
11:03:20 <Cale> connection timeouts seem much shorter to me
11:03:35 <Cale> maybe a few minutes
11:03:53 <hyp3rion> hm
11:04:04 <hyp3rion> indeed
11:04:18 <RemiTurk> May 01 19:43:49 -->	elk (~elk@c-67-188-139-215.hsd1.ca.comcast.net) has joined #haskell
11:04:18 <RemiTurk> May 01 20:03:39 <--	elk has quit (Read error: 145 (Connection timed out))
11:04:18 <RemiTurk> May 01 20:03:49 <RemiTurk>	you scared elk away
11:04:59 <basti_> thats an upper limit
11:06:20 * RemiTurk guesses it's 20 minutes in here
11:06:31 <basti_> maximum =)
11:12:55 <hyp3rion> 2013.55 CTCP PING reply from ChanServ: 77.252 seconds
11:13:03 <basti_> -g-
11:13:12 <hyp3rion> whoops i didnt block for enough time
11:13:58 <Cale> I think it's either 90 or 180 seconds. 90 seems about right.
11:15:22 <hyp3rion> ok now i only blocked the other client
11:16:43 <Cale> It's about 25 seconds if you don't say anything at all to the IRC server -- let's see if I log in
11:18:06 <hyp3rion> [Lag: 193 (??)]
11:19:22 <Cale> now I just wait for a PING, and not respond to it :)
11:19:47 <hyp3rion> hehe :
11:20:17 <hyp3rion> 2014.57 2020.56 6 minutes
11:20:45 <Cale> I've been on a while without it sending a PING though
11:21:01 <xerox> PONG!
11:21:12 <_JusSx__> è
11:21:13 <_JusSx__> +
11:21:16 <_JusSx__> ù
11:25:24 <Cale2>  In fact, this has been a few minutes now without a ping.
11:26:12 <hyp3rion> Cale2: maybe tcp connection timeout is six minutes and ping timeout is 14400 seconds :)
11:26:17 <hyp3rion> 4 hours
11:26:40 <hyp3rion> becuase you've been on for more than 6 minutes
11:27:21 <Cale> Yeah, I'm quite surprised that I haven't got even one ping :)
11:28:07 <Khisanth> you are testing that on freenode?
11:28:11 <Cale> yeah
11:29:05 <integral> freenode doesn't ping very often at all
11:29:35 <Khisanth> s/(?=at)/if /
11:29:38 <Cale> heh, telnetter friendly IRC services :)
12:18:03 <seba> i have a compile problem...
12:18:05 <seba> module Termino (Termino) where
12:18:06 <seba> data Termino t = Term (Float,Int) deriving (Eq,Show)
12:18:06 <seba> suma :: Termino t1 -> Termino t2 -> Termino
12:18:06 <seba> suma (Term (a,b)) (Term (c,d)) = Term (a+c,d)
12:18:27 <seba> the problem is in suma
12:18:53 <seba> but i dont understand why is the problem
12:21:13 <mauke> what is t for?
12:21:35 <mauke> can't you just write data Termino = Term (Float, Int) deriving (Eq, Show)?
12:22:08 <seba> yes...
12:22:12 <seba> its true
12:22:25 <seba> but the problem is in suma... i dont understand the cause
12:23:03 <Lemmih> seba: You need to parameterize the resulting 'Termino'.
12:23:28 <Lemmih> s/Termino$/Termino t3/
12:23:54 <seba> ok
12:25:12 <Lemmih> But why Termino takes a parameter is still a mystery. (:
12:25:51 <reffie> :)
12:41:44 <goronx> reffie: I tried the acpi off option also, btw.
12:41:57 <reffie> and?
12:42:37 <goronx> reffie: nothing.
12:42:43 <reffie> then i don't know.
12:42:49 <goronx> reffie: As expected.
12:57:21 <SyntaxNinja> 'morning
12:57:33 <musasabi> evening
12:57:43 <xerox> http://news.uns.purdue.edu/UNS/html4ever/2005/050426.Fischbach.pi.html
12:57:47 <xerox> Fascinating
12:58:46 <kosmikus> pesco: what's so ugly about default lhs2TeX typesetting, except for the vertical spacing?
12:59:25 <kosmikus> pesco: I wouldn't mind to put additional .fmt files on the lhs2TeX homepage, so that it becomes easier for new users to select/define their own styles
13:01:22 <Lemmih> Hey SyntaxNinja.
13:11:18 <SyntaxNinja> hiya Lemmih
13:18:15 <TFK> http://spoj.sphere.pl/problems/HMRO/ <--- do you reckon this can be done in Haskell under 11 seconds (provided that the fastest solution is 2 seconds in C)?
13:18:35 <TFK> 2.1 seconds, to be precise.
13:18:53 <TFK> Ah, it was done in Caml, 9.55 seconds :-)
13:20:01 <SyntaxNinja> anyone keen to talk about ACM latex junk for haskell workshop? :)
13:20:24 <SyntaxNinja> I'm wondering how to specify a4, why the template is explictly 1-column, when the document says it should be 2-column
13:20:32 <SyntaxNinja> and how to cite web pages, but I can probably find that out.
13:24:22 <autrijus> say, I have an almost working Data.Yaml.Syck.
13:24:28 <autrijus> has it been done before?
13:25:30 <autrijus> and more importantly, if I cabalize it, does it make sense to submit it to hackage database?
13:25:39 <autrijus> (and is Data.Yaml the correct name?)
13:29:17 <Lemmih> It most certainly makes sense (:
13:29:35 <autrijus> ok. :)
13:30:04 <Gahhh> TFK: That problem needs some clarification.
13:30:50 <Gahhh> if there are 5 recruits and 2 MRO's, which one gets the extra ? arbitrary decision ?
13:32:11 <RemiTurk> autrijus: Data.Yaml as module name? Don't the various html/xml parser libraries use Text.xxxML?
13:33:14 <TFK> Gahhh, each recruit is assigned to an MRO. If that MRO closes, he will move to the MRO specified as the new MRO.
13:33:21 <TFK> Or so I understand it, at least :-/
13:33:58 <Gahhh> sorry wrong question
13:34:15 <Gahhh> I mean if there are 2 recruits assigned a new MRO and you have to pick only one, which one.
13:34:24 <Gahhh> to the same new MRO
13:35:08 <TFK> I'm not sure I follow. Why do I have to pick only one?
13:35:49 <Gahhh> 5 guys at age, but 4 recruits needed
13:36:15 <TFK> Hmmm.
13:36:40 <Gahhh> look at the example. there are 2 guys originally assigned to GDA2. Only one is chosen.
13:36:49 <mauke> I understand it as follows: you get a list of (key, value) pairs
13:36:59 <mauke> then a list of (value1 -> value2) redirections
13:37:17 <mauke> then a list of key requests for which you have to output the right values
13:37:31 <TFK> However, you are given all the PESEL codes of people to be recruited. You only need to pick them.
13:39:07 <Gahhh> I think they also mean that the PESEL codes will be sorted in decreasing age order, and you're to pick the older one. 22222 is in, 33333 is out.
13:39:34 <othernoob> could someone help me for a few minutes ?
13:40:06 <xerox> othernoob, what's your problem?
13:40:37 <othernoob> pascal n = zipWith (+) (0:pascal(n-1)) (pascal(n-1) ++ [0])  << i dont understand that code
13:40:39 <TFK> What makes you think so? In the input, they give the list of codes to be recruited. You don't need to guess.
13:40:50 <othernoob> i know what its doing, but i dont know why
13:41:03 <Gahhh> TFK: Not everybody will be recruited tho. So you have to leave out some of them.
13:41:18 <TFK> Gahhh, look at the second list of codes.
13:41:19 <xerox> @type pascal n = zipWith (+) (0:pascal(n-1)) (pascal(n-1) ++ [0])
13:41:25 <lambdabot> bzzt
13:41:44 <TFK> 3 recruits, 3 codes, minus the MRO numbers. I think that's the list of recruits to track down.
13:41:48 <Gahhh> ah
13:41:59 <xerox> othernoob, it looks like an infinite list.
13:42:10 <xerox> @type zipWith
13:42:12 <lambdabot> zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
13:42:40 <othernoob> it's the pascal triangle.. i just dont get why there's 0:pascal ...and what the ++ [0] is there for ?
13:43:07 <Gahhh> TFK: That makes it a lot simpler
13:43:11 <TFK> This doesn't look right.
13:43:16 <TFK> Isn't there a base case?
13:45:08 <Gahhh> pascal 4 = [0,a,b,c] -> [a,b,c,0] -> [a+0, a+b, b+c, c+0]
13:46:31 <Gahhh> if pascal 0 = []
13:46:34 <Gahhh> this may work ?
13:46:55 <TFK> I don't see how o_O
13:47:48 <Gahhh> pascal 1 = zipWith (+) [0,0] [0,0]
13:47:49 <Gahhh> baah
13:47:53 <Gahhh> heh
13:48:04 <TFK> That can't work :-/
13:48:14 <TFK> othernoob, surely there must be more to the definition.
13:48:18 <Gahhh> if pascal 1 = [1]
13:48:49 <Gahhh> pascal 2 = zipWith (+) [0,1] [1,0] = [1,0].
13:48:57 <othernoob> TFK: pascal :: Integer -> [Integer]
13:48:57 <othernoob> pascal 0 = [1]
13:48:57 <othernoob> pascal n = zipWith (+) (0:pascal(n-1)) (pascal(n-1) ++ [0])  this is the entire program
13:49:08 <TFK> I knew it! A basecase :D
13:49:27 <TFK> Gahhh, shouldn't that => [1,1] ?
13:49:49 <Gahhh> pascal 1 = zipWith (+) [0,1] [1,0] = [1,1]
13:50:19 <Gahhh> pascal 2 = zipWith (+) [0,1,1] [1,1,0] = [1,2,1]
13:50:53 <othernoob> Gahhh: why is the first 0 not  [0] ?
13:51:12 <Gahhh> first what ?
13:51:32 <othernoob> 0:pascal(n.-1) ...that 0
13:52:00 <xerox> pascal 0 = [1]
13:52:06 <Gahhh> 0:pascal(1-1) = 0:pascal(0) = 0:[1] = [0,1]
13:52:11 <mauke> othernoob: do you know what : does?
13:52:14 <xerox> Yep.
13:52:38 <othernoob> mauke: unfortunately, no.. i've been thrown into water at school with haskell:(
13:52:45 <mauke> ah
13:52:58 <mauke> : prepends an element to a list
13:53:13 <mauke> 0 : [1,2,3] results in [0,1,2,3]
13:54:08 <othernoob> i see... so could this be done at the end of that line too ? instead of ++ [0]  ... ++ :0 ?
13:54:44 <wagle> [0] ++ [1,2,3] results on [0,1,2,3]..  (notice ++, not :)
13:54:47 <mauke> no, there is no reverse-: operator
13:54:49 <xerox> ++ concatenates two lists. [...] creates a list
13:55:01 <mauke> : can only be used to add stuff at the front
13:55:27 <othernoob> ah okay, that explains that difference..
13:55:40 <wagle> [0,1] ++ [2,3] == 0 : 1 : [2,3]
13:55:46 <xerox> Also, in Haskell, lists can't be of values of different types.
13:56:15 <TFK> http://www.kontraband.com/show/show.asp?ID=931&rtn=main-topten <--- :D
13:56:23 <othernoob> and am i right in assuming that pascal(n-1) will be done till n equals 1 ? thus it being pascal(1-1) => pascal (0) => [0] ?
13:56:45 <wagle> notice that the left list in the ++ gets decomposed, but not the right liste
13:56:49 <xerox> othernoob, Yep.
13:56:49 <mauke> yes
13:58:08 <shapr> @yow !
13:58:09 <lambdabot> YOW!!  I'm in a very clever and adorable INSANE ASYLUM!!
13:58:19 <shapr> Ain't that the truth!
13:58:27 <wagle> eek
13:58:40 <othernoob> okay..mmh.. and the (+) does what ? does it add the integers inside the[..]  when it puts both lists together ?
13:59:04 <TFK> @type (+)
13:59:05 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
13:59:09 <wagle> 1 + 2 == (+) 1 2
13:59:31 <mauke> (+) is a function that adds two numbers
13:59:33 <wagle> 1 + 2 == (+) 1 2 == (1 +) 2 == (+ 2) 1
13:59:59 <mauke> it is used by zipWith
14:00:04 <othernoob> mmh..looks like infix-writing
14:00:10 <wagle> putting ()'s around + makes it a NON infix function
14:00:53 <othernoob> what does that mean wagle ?
14:01:04 <wagle> which "that"?
14:01:07 <xerox> othernoob, they're called sections.
14:01:24 <xerox> othernoob, you can partially apply arguments to functions.
14:01:26 <othernoob> wagle: the non infix part..
14:01:37 <xerox> @type (+)
14:01:38 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
14:01:39 <xerox> @type (1+)
14:01:41 <lambdabot> (1+) :: forall a. (Num a) => a -> a
14:01:56 <xerox> And you get a function with that argument "consumed".
14:02:06 <othernoob> xerox: okay i see..
14:02:21 <mauke> othernoob: 1 + 2 <-- infix notation
14:02:29 <mauke> othernoob: (+) 1 2 <-- prefix (not infix)
14:02:40 <wagle> infix mean the function symbol goes in the middle (eg, 1 + 2).  prefix would be the beginning (eg, plus 1 2).
14:02:52 <othernoob> ah yea,i tend to mix infix and prefix up
14:03:15 <xerox> othernoob, you can also make a function infix by putting ` around it.
14:03:21 <othernoob> boy, do i feel stupid now lol
14:03:35 <wagle> reverse polish notation uses postfix notation (eg "1 2 plus")
14:04:34 <wagle> haskell only has prefix and infix, i think
14:05:05 <wagle> though i've seen some odd tricks that seems a lot like postfix..  8)
14:06:19 <xerox> Perl6 can make any *fix notation, even "aroundfix", yay!
14:06:35 <TFK> aroundfix? o_O
14:06:37 <othernoob> thanks :) i think i understand that little program now :)
14:06:37 <mauke> circumfix
14:06:42 <xerox> circum! sorry.
14:06:44 <mauke> like []
14:07:39 <TFK> Ah. So [] is built-in sugar? As in, you can't build that notation yourself?
14:07:43 <xerox> There is an example somewhere defining <!-- and --> to be circumfix, avoiding evalling the inner expressions, so it becomes like comments. HTML comments in perl6 sources, eheh.
14:07:51 <xerox> TFK, right.
14:08:41 <TFK> I've heard some horror stories about readability, but isn't this just a tad too far?
14:09:18 <wagle> saying perl is unreadable is like saying chinese is unreadable
14:10:01 <TFK> And that's why the Japan is a more thriving country than China, they got themselves syllabaries.
14:10:22 <xerox> wagle, heh.
14:10:22 <wagle> darn..  i was hoping to bring that up.  8)
14:10:37 <wagle> you stole my punchline!
14:10:48 <TFK> Korea too, btw :-P
14:11:06 <wagle> well, actually, china seems to be doing better and better these days
14:11:11 <Maddas> Bah, insects. I already wish it were winter again.
14:11:27 <RemiTurk> ahhh, a ping timeout of 14400 seconds!
14:11:28 <wagle> korea uses chinese characters?
14:12:01 <TFK> They also have a syllabary (or was it an alphabet?_)
14:12:07 <TFK> So no, not only chinese characters.
14:12:41 <wagle> technically, the problem is that chinese characters dont represent japanese very well.
14:13:27 <wagle> really need conjugations, etc..  which purpose the phonetic alphabets (hiragana, katakana) serve
14:15:48 <wagle> i have two extra headlights..
14:17:59 <det> Do you live in antartica?
14:19:52 <xerox> Goodnight folks.
14:23:17 <wagle> aww..  i scared him off..  8(
14:23:31 <wagle> no, wait, maybe not..
14:23:55 <Spida> hi
14:23:55 <basti_> ??
14:24:00 <basti_> hi Spida
14:24:13 <wagle> hey
14:30:17 <Spida> I have some problems with a data-structure
14:30:33 <basti_> tell us about them
14:30:39 <Spida> I have data Set a = Insert a (Set a) | EmptySet
14:31:05 <Spida> I have a show function for that (see http://pastebot.gentoo-se.ath.cx/10)
14:31:49 <basti_> whats the difference between your Set and a List?
14:32:04 <Cale> well, that's not really how you want to show it, it'll look like {x,{y,{z,{}}}
14:32:08 <Spida> I may not use a List
14:32:20 <basti_> ah
14:32:23 <Spida> *g*
14:32:28 <basti_> :)
14:32:35 <basti_> homework yes? :P
14:32:39 <Spida> yes
14:33:02 <basti_> thats important because we can't give you the solution if we know it, then.
14:33:02 <Spida> I need to show {x, y, z}
14:33:12 <RemiTurk> if you may not use a list, are you sure you /are/ allowed to use an isomorphic type?
14:33:52 <Cale> How is "Insert 5 (Insert 5 EmptySet)" supposed to be printed?
14:34:11 <Spida> RemiTurk: I am sure I am allowed to do it like I pasted.
14:34:23 <Cale> Spida?
14:34:24 <Spida> Cale: {5, 5}
14:34:33 <Cale> okay, so they really are lists
14:34:39 <Spida> yeah
14:34:55 <Cale> If they were sets, you'd want {5} :)
14:34:57 <Spida> at least, I do not want to check for duplicates
14:35:02 <Cale> hehe
14:35:05 <basti_> :)
14:35:21 <basti_> well one could define another function
14:35:34 <basti_> one prints the {}, and the other one fills it if neccisairy
14:35:34 <Spida> I tried something like that
14:35:49 <basti_> i mean, all in all, two functions
14:36:28 <RemiTurk> something like ... where show x = "{" ++ f x ++ "}"
14:36:50 <Cale> show (Insert x xs) = "{" ++ show' (Insert x xs) ++ "}"
14:36:56 <Cale>    where show' ...
14:37:22 <basti_> or even
14:37:32 <basti_> show a = "{"++show' a++"}"
14:37:37 <Spida> I had http://pastebot.gentoo-se.ath.cx/11
14:37:43 <basti_> that could catch {}
14:37:43 <Spida> but this didn't work
14:38:17 <basti_> i wouldn't expect it to, to be honest.
14:38:17 <mauke> yeah, showsub doesn't handle empty sets
14:38:21 <basti_> =)
14:38:48 <basti_> your compiler could have printed you a warning
14:39:25 <Spida> it did
14:39:27 <Spida> *g*
14:39:36 <Spida> but I did not understand it *g+
14:39:39 <basti_> :)
14:40:02 <shapr> Good morning #haskell!
14:40:19 <Spida> No member "showsub" in class "Show"
14:40:55 <basti_> thats an indentation error
14:41:04 <basti_> do you see it?
14:41:34 <Spida> ah
14:41:35 <Spida> yes
14:42:00 <Spida> showsub has to be indented some more
14:42:07 <basti_> yup
14:42:51 <mauke> @pl \x -> "a" ++ x ++ "b"
14:42:52 <lambdabot> ('a' :) . (++ "b")
14:43:13 <Heffalump> @pl \x -> "ab" ++ x ++ "cd"
14:43:14 <lambdabot> ("ab" ++) . (++ "cd")
14:43:24 <Heffalump> @pl \x -> ("ab" ++ x) ++ "cd"
14:43:25 <lambdabot> (++ "cd") . ("ab" ++)
14:43:33 * basti_ gets headaches when thinking about pointless
14:43:42 <Heffalump> @pl \x y -> y x
14:43:43 <lambdabot> flip id
14:44:14 <Heffalump> @pl \f x -> f (f (f (f x)))
14:44:15 <lambdabot> ap (.) (ap (.) (ap (.) id))
14:44:50 <basti_> ap is application?
14:45:10 <mauke> @pl \x -> "{" ++ show' x ++ "}"
14:45:11 <lambdabot> ('{' :) . (++ "}") . show'
14:45:56 <mauke> yay, it works
14:46:44 <mauke> show (Insert 2 (Insert 3 (Insert 5 (Insert 1 EmptySet)))) ==> "{2, 3, 5, 1}"
14:46:52 <Spida> second problem I have... I have to check if a value is an element of my Set... http://pastebot.gentoo-se.ath.cx/13
14:47:07 <Spida> but I get Inferred type is not general enough
14:47:52 <mauke> I'd call memberSet contains
14:48:08 <mauke> yeah, a must support ==
14:48:24 <arjanb> you use == so a Eq class constraint is needed
14:48:28 <basti_> and then you can only compare values of same type
14:49:04 <pesco> kosmikus: I don't remember specifically, I just remembered that it looked ugly until you sent me new fmt files. ;)
14:49:46 <pesco> kosmikus: On a more important note, I've got a patch for you attached to my TMR article!
14:50:32 <Spida> but I use == on values out of my set... so that shouldn't matter?
14:50:54 <basti_> Spida: yes it matters.
14:51:07 <Spida> hm
14:51:17 <basti_> Spida: you only can == values that belong to a type that's a member of the class "Eq"
14:52:01 <basti_> but your error comes from a different place
14:52:09 <Spida> ok, but when I have Integers in my Set, it should work?
14:52:51 <mauke> this is a typing problem
14:52:59 <mauke> runtime values don't matter
14:53:34 <basti_> Spida: well many many types are Eq.
14:54:02 <basti_> Spida: but "some type" (a type variable like "a", or a type that isn't fixed) isn't Eq
14:54:42 <basti_> thats what "type constraints" are for.
14:54:48 <Spida> ok
14:54:57 <basti_> they basically say, "do this with some value thats of a type of class X"
14:55:09 <basti_> @type show
14:55:13 <Spida> and how can I use this?
14:55:15 <lambdabot> show :: forall a. (Show a) => a -> String
14:55:31 <basti_> this is how you write down a constraint
14:55:41 <basti_> (you don't need to type forall a., thats implied)
14:55:56 <basti_> "Show a" is the constraint here
14:56:40 <basti_> this type means something like: you can "show" each value, that's of class Show, and to do that, "show" consumes such a value, and then returns a String
14:56:45 <pesco> kosmikus: http://haskell.org/tmrwiki/EternalCompatibilityInTheory at the very bottom.
14:57:09 <pesco> kosmikus: That's my patch for the pragma issue we talked about some weeks ago.
14:57:24 <pesco> cptchaos: Ins Bett sollst Du! ;-P
14:58:22 <pesco> shapr: What's the status? How close are we to release?
14:58:44 <basti_> mmm a few seconds? :P
14:59:13 <mauke> instance Show a => Show (Set a) where -- ah, a type constraint
14:59:37 <Spida> basti_: do I use the constraint in the type definition, or in the memberset function?
14:59:46 <basti_> doink, 1st of may is over, tmr2 released? =)
15:00:05 <pesco> Hehe
15:00:09 <basti_> Spida: uhm you need to constraint something in memberSet, because you're comparing things im memberSet.
15:00:22 <basti_> but, think about what you're constrainting, and why this is a little difficult.
15:00:28 <basti_> there is another problem in your code
15:00:50 * Spida is new to haskell
15:00:58 <mauke> ah, right
15:00:58 <basti_> i noticed.
15:01:04 <Spida> *g*
15:01:10 <mauke> probably just a typo
15:01:12 <pesco> Hm, shouldn't we have a prominent link to TMR on the haskell.org frontpage?
15:01:13 <basti_> maybe
15:01:18 <kosmikus> pesco: er, but the pragma thing can hardly be considered a serious "bug" regarding lhs2TeX output in general ...
15:01:28 <basti_> Spida: you will learn most when you find it yourself.
15:01:47 <kosmikus> pesco: sorry. forget it, I didn't read the two lines you wrote before
15:01:48 <pesco> kosmikus: No no, the pragma thing is not a bug.
15:01:50 <Spida> I heard about 6 hours worth of lectures, and have been trying to get some things working the whole day
15:01:53 <pesco> kosmikus: :)
15:02:35 <aheller> TMR?
15:02:59 <Spida> basti_: what other problem are you talking about?
15:03:00 <shapr> y0 pesco
15:03:04 <pesco> aheller: The Monad.Reader, the Haskell electronic magazine.
15:03:14 <pesco> shapr: Yo yo.
15:03:24 <basti_> Spida: well, its about the type of memberSet, and is connected to the error you got
15:03:42 <basti_> about types being not general enough
15:03:51 <shapr> Any comments before TMR goes live?
15:04:01 <aheller> pesco: ah, of course.  apparently my internal wtf(6) is apparently broken.
15:04:03 <pesco> shapr: How will it go live?
15:04:24 <Gahhh> on cnn, of course
15:04:27 <mauke> or you could cheat, delete the type signature and let the interpeter tell you the type
15:04:28 <pesco> Haha.
15:04:29 <pesco> :)
15:04:37 <basti_> Spida: mauke is right
15:04:45 <Gahhh> I want shapr on Larry King
15:04:55 <basti_> i dont
15:05:05 <shapr> TMR live means, I'll change the access privs so that only AuthorsGroup can change stuff default, setup some comment pages that can be changed by anonymous, and announce on the mailing list.
15:05:12 <shapr> Gahhh: why?
15:05:14 <shapr> basti_: why not? ;-)
15:05:39 <Gahhh> shapr: why not ;)
15:05:42 <basti_> i wouldnt want to know what happens if shapr talks live on tv about haskell
15:06:03 <shapr> I wouldn't talk much about Haskell live on TV
15:06:04 <pesco> shapr: I'll make us a little front page, OK?
15:06:09 <shapr> pesco: yes please!
15:06:22 <basti_> maybe it would be a little like a squirrel on crack?
15:06:51 <shapr> I'd talk about how much I enjoy being part of a team that contributes to useful code and carefully explained knowledge for the benefit of the world.
15:07:11 <shapr> basti_: bah, that's nowhere close
15:07:17 <shapr> basti_: I'm at least as large as a capybara
15:07:26 <basti_> capywhat?
15:07:47 <basti_> i know the chupacabra
15:07:52 <shapr> capybara: http://images.google.com/images?q=capybara&num=100&hl=en&lr=&safe=off&sa=N&tab=ii&oi=imagest
15:08:02 <basti_> ow
15:08:10 <shapr> @wn capybara
15:08:12 <lambdabot> *** "capybara" wn "WordNet (r) 2.0"
15:08:12 <lambdabot> capybara
15:08:12 <lambdabot>      n : pig-sized tailless South American amphibious rodent with
15:08:12 <lambdabot> partly webbed feet; largest living rodent [syn: {capibara},
15:08:12 <lambdabot>           {Hydrochoerus hydrochaeris}]
15:08:28 <shapr> Since you were comparing me to a small rodent, I thought I'd go for something larger.
15:08:32 <basti_>  This picture of a handsome male clearly shows the scent gland on his snout which he probably uses to mark his territory.
15:08:42 <basti_> http://www.rebsig.com/capybara/capy9.jpg,
15:08:45 <basti_> whoops
15:08:52 <Spida> basti_: oh, ok
15:08:55 <Spida> got it working
15:08:59 <basti_> Spida: :)
15:09:07 <Spida> mauke, basti_: thx
15:09:22 <basti_> Spida: so what was wrong about the type?
15:09:45 <shapr> pesco: I guess I should write up an editorial page...
15:09:51 <Spida> basti_: ()
15:10:16 <basti_> ()?
15:10:26 <shapr> 8-()
15:10:47 <Spida> http://pastebot.gentoo-se.ath.cx/15 <- thats my ocde now
15:10:52 <Spida> seems to be working
15:11:13 <basti_> yes that looks much better
15:14:46 * basti_ is watching "lost highway" with half an eye
15:15:34 * shapr instantly quotes bits of "Lost Highway"
15:15:59 <shapr> I thought the movie had a rather obvious structure, but I guess it's not obvious if you've never heard of call/cc.
15:16:23 <basti_> -g-
15:18:03 <basti_> i like the way lynch plays tricks
15:18:12 <basti_> he tells impossible stories
15:19:31 <pesco> Heheh.
15:19:33 <RemiTurk> does anyone here know where to find SPJs On the importance of being the right size:
15:19:33 <RemiTurk> the challenge of conducting realistic experiments.
15:19:33 <RemiTurk>  ?
15:19:53 <pesco> "Building on Tiger using the Panther toolchain will lead to frustration and misery."
15:19:53 * RemiTurk wonders where all those newlines came from
15:19:57 * Lemmih is itching to release cabal-get 0.2.0.
15:21:02 <pesco> Lemmih: I'm itching to try cabal-get! Where can I get it? (no pun intended *g*)
15:21:58 <Lemmih> pesco: http://scannedinavian.org/~lemmih/cabal-get/stable/dist/cabal-get-0.2.0.tgz
15:22:14 <Lemmih> But it depends on a cabal patch which haven't been approved yet.
15:22:27 <pesco> Hm.
15:25:07 <shapr> Oy, Sven Panne wants to switch to subversion rather than darcs.
15:25:15 <pesco> Eek!
15:25:18 <pesco> :)
15:26:32 <tuomov> having been there, I'd stay away from svn
15:26:39 * Lemmih mentally pokes SyntaxNinja.
15:26:42 <wilx> Hmm.
15:26:49 <tuomov> in the end, the branches-and-tags-as-copies approach sucks bigtime
15:26:52 <Gahhh> is there a std::endl equivalent for putStr ? hFlush stdout gets boring.
15:27:12 <wilx> I find Darc's lack of branches inconvenient...
15:27:28 <shapr> It does hardlinking.
15:27:39 <Lemmih> Gahhh: putStrLn?
15:27:47 <Gahhh> Lemmih: that doesnt flush tho
15:28:03 <Gahhh> unless I set buffering to flush on \n
15:28:09 <shapr> wilx: What about copy and hardlink?
15:28:25 <RemiTurk> does std::endl really always force a flush?
15:28:30 <Gahhh> RemiTurk: yes
15:28:57 <wilx> Don't you have to be able to access the remote archive to do that?
15:29:05 <shapr> Huh?
15:29:06 <basti_> uh btw, there was this issue about readLn not understanding EOF as End of line
15:29:10 * RemiTurk wonders why ("end-of-line" doesn't sound all that flushly)
15:29:29 <mauke> RemiTurk: otherwise it would be useless
15:29:33 <mauke> (because of '\n')
15:29:44 <Lemmih> pesco: I installed pesco-cmdline with cabal-get (:
15:30:10 <RemiTurk> mauke: in that case I'd think of something like "cout << ... << flush;" first I think
15:30:18 <pesco> Lemmih: Woohoo! :)
15:30:19 <Gahhh> RemiTurk: yeah it confuses people. They should have named it "elfl" or something
15:30:39 <shapr> pesco: Oh, the FrontPage looks lots better!
15:30:46 <pesco> :)
15:30:52 <RemiTurk> shapr: does windows support hard-linking? (doesn't personally really care, but worries about those poor souls stuck with it ;))
15:31:13 <wilx> NTFS does.
15:31:34 <shapr> I dunno, I lost my copy of windows 95 some years back due to lack of installation.
15:32:02 <RemiTurk> okay, so in the long term that at least shouldn't really affect darcs' growth
15:32:05 <shapr> It's probably in the back of drawer somewhere next to my old college id cards.
15:32:12 <pesco> Everyone feel free to improve on the front page, I'll leave it so far.
15:32:41 * RemiTurk searches for better words, but cannot even find the dutch words, let alone englihs..
15:32:54 <RemiTurk> adoption
15:33:42 * shapr adopts darcs and treats it like his own
15:33:58 <pesco> I think we should reverse the order of author - article in the article list.
15:34:02 <pesco> Do you agree?
15:34:14 <Cale> Windows 9x treats hard linking as filesystem damage iirc.
15:34:25 <tuomov> I'm actually thinking copy-on-write would be much more useful than hardlinking..
15:35:27 <RemiTurk> Cale: I have a vague memory of abusing a home-made "sector editor" to hard link files :) (on floppies, I wasn't _that_ stupid ;))
15:36:08 * basti_ had fun with c64 floppies in his youth
15:36:49 <basti_> you could set the file type to "?"
15:37:12 <basti_> and files starting with the pound sign would be read into the drive's ram and executed there
15:37:38 <RemiTurk> :)
15:38:34 <shapr> Anyone mind if I throw out my ideas for an editorial?
15:38:57 <basti_> as long as you gather them afterwards...
15:39:02 <shapr> heh
15:39:43 * RemiTurk looks lost
15:39:55 * shapr finds RemiTurk with a GPS!
15:40:02 <shapr> Look! You're right here!
15:40:08 <RemiTurk> ah, thanks
15:40:15 <pesco> I've vamped up the IssueTwo page a bit. Have a look please.
15:40:18 <RemiTurk> but, err, an editorial about what?
15:40:40 <shapr> Three things come to mind, darcs, pugs, and links.
15:40:57 <Philippa_> darcs and pugs're both out there to the extent people can /see/ them
15:41:01 <tuomov> links?
15:41:16 <shapr> Wadler's Links language is about getting recent research into the webdev world.
15:41:21 <Philippa_> if you want to do a "yay haskell!" congratulatory thing, I'd pick those two :-)
15:41:21 <tuomov> ah.
15:41:23 <tuomov> that links.
15:41:36 <pesco> shapr: You might also want to mention the switch to Wiki publishing this issue.
15:41:42 <shapr> I actually have a clue about webdev, so I could actually make informed comments about that.
15:41:43 <shapr> pesco: oh right!
15:43:42 <shapr> pesco: and I should definitely solicit comments on the wikipublishing format versus the pdf/ps format.
15:43:49 <pesco> Yes.
15:44:29 <wilx> @wiki
15:44:30 <lambdabot> http://www.haskell.org/hawiki/
15:44:35 <pesco> @tmr
15:44:36 <lambdabot> Avast!
15:44:39 <pesco> ;)
15:44:39 <shapr> haha
15:46:15 <shapr> The Haskell community has grown a lot, darcs and pugs have recently been responsible for most of the recent cross pollination in the community.
15:46:33 <Gahhh> pugs has poisoned many young minds
15:46:45 <pesco> Cross pollination is good.
15:46:52 <Gahhh> I hold lambdabot responsible as well
15:47:01 <Gahhh> @moo
15:47:02 <lambdabot>          (__)
15:47:02 <lambdabot>          (oo)
15:47:02 <lambdabot>    /------\/
15:47:02 <lambdabot>   / |    ||
15:47:02 <lambdabot>  *  /\---/\
15:47:03 <lambdabot>     ~~   ~~
15:47:05 <lambdabot> ...."Have you mooed today?"...
15:47:06 <basti_> :-o
15:47:28 <shapr> Recent research into effective teams showed that the best papers and the best authors regularly teamed up with new people to gain new insights, so I think this cross-pollination is good for all the communities involved.
15:47:49 <shapr> Yeah, I think I'll end up skipping the Links bit for the moment.
15:49:36 <pesco> Wow, I think IssueTwo is really cool. As was IssueOne. We have high-quality content!
15:49:42 <shapr> Yes :-)
15:49:54 <shapr> And look at the possible articles for IssueThree, it's massive.
15:49:57 <basti_> is it done?
15:50:00 <shapr> I think it'll just get better.
15:50:20 <basti_> I'm curious
15:50:22 <pesco> Hm, wouldn't the editorial fit best at the top of the IssueTwo page?
15:50:26 <shapr> basti_: not yet, but I can go ahead and do the access control and logo adding before I finish the editorial.
15:50:34 <shapr> pesco: sure, go for it.
15:50:50 <basti_> aww no i'll have a look when its done
15:51:04 <pesco> Er, OK. ;)
15:51:08 <basti_> i like complete hings
15:51:24 <shapr> basti_: I rarely finish stuff, I like starting things.
15:51:26 <Oejet> shapr: Is issue two out yet?
15:51:29 <basti_> -g-
15:51:35 <basti_> i didnt say im good at finishing things
15:51:38 <shapr> Working on TMR with others has encouraged me to get stuff finished!
15:51:39 <RemiTurk> Oejet: you shot me this afternoon!
15:51:55 <shapr> Oejet: not yet, see the todo list
15:52:12 <shapr> Bah, I'll do two of those while I'm thinking about editorial content
15:54:10 <shapr> I'm not sure what to say other than to point out the trends. For example, the growth of the #haskell channel. For darcs, the amazing volume of the darcs mailing list, and the recent regular emails from Linus Torvalds on the darcs-users list. For Pugs, the increased visibility of Haskell and Perl6, the number of GHC bugs found and reported by the #perl6 folks. In general, all are benefits of cross-pollination.
15:54:58 <pesco> Hm, it would be best if you could relate somehow to the contents of the issue. Not sure if that's possible though.
15:55:50 <shapr> I don't see how to do that.
15:56:08 <shapr> I could surf the high points of the articles though.
15:56:12 <Igloo> Linus Torvalds has really been posting to the git list
15:58:10 <shapr> Template Haskell, FFI, Domain Specific Languages, Exploring Dark Corners, and Better module compatibility.
15:58:34 <shapr> Igloo: well, I'm not subscribed to the git list, and messages from him show up on darcs-users.
15:59:01 <basti_> I'd say cross pollination is better than this mental incest that goes on in some corners of #h ;)
15:59:19 <Igloo> Mails can go to more than one address, you know?  :-)
15:59:21 <shapr> I'm afraid to ask!
15:59:43 <shapr> Igloo: right, so, email from Linus Torvalds on the darcs-users list, yes?
16:00:27 <Igloo> shapr: If you are trying to imply that LT is a darcs user and has been posting to the darcs-users list, then no
16:00:35 <shapr> oh, I wasn't trying to imply that.
16:00:51 <shapr> I was just trying to imply that he's actually heard of Haskell, and looked at darcs.
16:01:34 <shapr> Basically, Haskell may not be mainstream, but the community has grown to the point that it's not a margin language either.
16:01:39 <shapr> Though I guess that's debatable.
16:01:58 <shapr> I know that when I got into the community a few years back, most programmers had never heard of Haskell.
16:02:13 <shapr> You're right, I should explicitly describe it that way, thanks :-)
16:02:40 <pesco> Ah, the old days!
16:03:10 <Gahhh> I thought he just considered darcs and haskell didnt have much to do with it.
16:03:12 <shapr> Back when it was just eleven people, very few of which had any clue.
16:04:09 <pesco> It's good people don't raise their eyebrow that high anymore when told you're writing something in Haskell.
16:04:23 <shapr> Gahhh: Right, being written in Haskell didn't have any effect, but one of the arguments I often hear are "If FP is so great, where are the great FP applications?"
16:04:48 * shapr loves lazily evaluating an editorial :-)
16:05:03 <shapr> pesco: yeah!
16:06:18 * Gahhh enjoys the fact that his compile error rate after edits is under 50%. 
16:07:24 <reffie> yeah where are the great FP applications!
16:07:33 <shapr> reffie: now we can point to lambdabot!
16:07:36 <shapr> I mean, darcs and pugs!
16:07:44 <reffie> and soon, Yi!
16:08:03 <shapr> Right, I'd like to mention hs-plugins if I can fit it in.
16:08:22 <shapr> Heh, maybe I should call my editorial "shapr's pulpit"
16:08:24 <reffie> postmaster?
16:08:35 <shapr> Postmaster is way cool, have you tried it?
16:08:39 <reffie> no
16:08:42 <reffie> i use postfix :(
16:08:42 <pesco> Gahhh: Actually, that's quite a nice observation. Compare to, say, C or C++ where the all but the first compiler error were usually consequences of that one.
16:08:48 <shapr> I got to do alpha testing on postmaster.
16:08:55 <reffie> cool :)
16:09:09 <reffie> is it actually used in production? :P
16:09:47 <shapr> By the author at least. I'm going to use postmaster on the new ScannedInAvian server.
16:10:17 <reffie> does it perform decently?
16:10:47 <shapr> Greased lightning comes to mind.
16:10:49 <Gahhh> pesco: I didn't mean that. What I meant is while you're learning you're making all kinds of syntax and type errors that it doesn't translate to higher efficiency. Once you start writing haskell code that compiles 90+% of the time after your edits, I (hope) you get more productive with haskell than with <insert lang>.
16:10:53 <reffie> heh
16:11:11 <pesco> Oh, OK>
16:11:24 <Lemmih> Has anyone made haddock documentation for TH?
16:11:31 <shapr> I seriously dbout you could get postmaster to even notice the load without less than an 8Mbits line.
16:11:45 <reffie> i wonder, shapr
16:11:46 <shapr> er "with less than"
16:12:05 <shapr> reffie: Read up on Peter Simons' Fast I/O library and tell me what you think ;-)
16:12:15 <reffie> i think that if you start using stuff like spamassassin and clamav, you would start to feel it
16:13:37 <shapr> pesco: oh, you want the text of the editorial directly in the IssueTwo page?
16:13:52 <pesco> Yeah!
16:13:56 <shapr> ahh
16:13:58 <shapr> ok then
16:14:14 <pesco> :)
16:15:52 <pesco> I think I've a nice idea for a logo.
16:15:57 <shapr> yeah?
16:16:53 * pesco starts the gimp.
16:16:57 <jlouis> @vixen hi nice gal, where are the new TMR magazine you bought me?
16:16:59 <lambdabot> bad is better than nice ;)
16:17:11 <jlouis> @vixen ok, bad b*tch
16:17:13 <lambdabot> just ok?
16:17:55 <pesco> shapr: I'm thinking about something simple, a right-pointing triangle with some stylized lines of text in the background.
16:18:12 <pesco> The triangle representing monadic sequencing.
16:18:48 <skew> you should try to work in something about the reader monad
16:19:20 <shapr> pesco: Sure, go for it.
16:19:33 <shapr> It'd be neat to have a different logo each month and then a gallery page.
16:28:36 <shapr> Yick, my editorial is totally ininspired.
16:28:54 <reffie> yick
16:32:01 <skew> ininspired?
16:32:47 <Igloo> uninspired
16:34:18 <Oejet> shapr: Could you verify for me, that the PostScript version of my article has the right TMR look?
16:34:46 <shapr> Oejet: btw, want me to upload your ps to haskell.org?
16:34:56 <shapr> You could also attach the file directly to your article page.
16:35:36 <Oejet> Hm, sure.  Just check that it looks sane, please.
16:36:25 <shapr> I think 'syntax c' will work for that chunk of C code.
16:36:38 <Lemmih> @plugs let x::(->)((,,)Char Int Char)Int;x((,,)x' v_ x'')=v_ in(x('c',20,'b'))
16:36:45 <lambdabot> 20
16:36:51 * Lemmih giggles.
16:37:33 <shapr> Oejet: it looks fine to me, but pesco and kosmikus know the TMR look far better than I do.
16:37:39 <shapr> g'day Pseudonym
16:38:17 <Pseudonym> G'day.
16:39:40 <Pseudonym> No TMR yet?
16:41:38 <shapr> very close
16:41:38 <Lemmih> Oejet: Have you cabalized your libbz-binding yet?
16:41:52 <shapr> Pseudonym: want to check out the TmrWiki to check for bugs?
16:43:07 <Pseudonym> Probably a good idea.
16:43:25 <Oejet> Lemmih: No, not yet.
16:44:34 <Oejet> Lemmih: The binding is not very mature (yet).
16:44:38 <pediddle> bs
16:44:51 <pediddle> oops, wrong channel
16:46:00 <zamez> heh
16:46:50 <shapr> pesco: You doing the logo?
16:47:58 <shapr> Ok, time to add the access controls.
16:55:46 <shapr> Oh, I gotta add a license.
16:56:37 <pesco> shapr: Yes, I have a simple version, but it's looking a bit dull.
16:58:31 <shapr> Ok, access control is partially on (haven't shut off anon view by default)
17:00:11 <shapr> Anyone editing the wiki without being logged-in? If so, save your edit and login, I'm about to turn off anonymous rights by default.
17:00:27 <shapr> hiya seebyr
17:00:43 <shapr> Looking for Haskell info?
17:01:13 <cm> y0
17:01:40 <shapr> y0 y0
17:01:43 <shapr> wazzup?
17:01:50 <cm> not much
17:01:57 <cm> silent sunday
17:02:00 <shapr> TMR2 is very close to release!
17:02:11 <cm> what's that?
17:02:30 <Cale> the logo should contain (\k -> f (x k) k) somewhere :)
17:04:33 <cm> ah, The Monad Reader, google helps.
17:05:08 <cm> i want my linux desktop to look cute :[
17:05:26 * Cale runs gnome and enlightenment :)
17:05:54 <cm> ..and the GUI be more responsive.
17:06:01 <shapr> ion3?
17:06:43 <cm> nah, my mouse doesn't like me when I use ion.. and I like these animals ;)
17:07:27 <shapr> ok
17:07:40 <cm> I miss my gerbils :(
17:07:40 <Cale> Oh, interesting - it's Tuomo Valkonen who wrote ion
17:07:55 <shapr> Cale: sounds vaguely familiar?
17:08:16 <pesco> http://haskell.org/tmrwiki/LogoSuggestions
17:08:16 * shapr looks suspiciously at tuomov 
17:08:53 <Cale> ooh, access control lists :)
17:08:54 <shapr> Gwahr, I've screwed up the security
17:09:24 <Oejet> shapr: Nicely locked down.
17:09:34 * shapr grumbles
17:10:06 <shapr> Ok, turned it back off
17:11:29 <Oejet> Hm, that looks a bit Korean.
17:17:25 <shapr> I like it.
17:18:04 <Oejet> Maybe some text added?
17:22:01 <RemiTurk> good night
17:22:05 <shapr> g'night RemiTurk
17:32:52 <shapr> pesco: want to put that up as the logo?
17:33:41 <Oejet> shapr: Going to bed now.  Good luck on releasing TMR 2.
17:34:07 <shapr> thanks :-)
17:35:15 * Oejet will ponder in his dreams on how to install .debs on GoboLinux.
17:46:11 <Lemmih> @seen SyntaxNinja
17:46:12 <lambdabot> I saw SyntaxNinja leaving #haskell 3 hours, 56 minutes and 50
17:46:12 <lambdabot> seconds ago.
17:49:07 * SamB tries to figure out a simple way to convert array indices to words and back
17:49:25 <Lemmih> words?
17:49:49 <SamB> well, either that or ints
17:50:36 <pesco> shapr: Sure, but I don't know how.
17:51:30 <Lemmih> SamB: As in 'bounds' + 'range'?
17:51:42 <shapr> pesco: it's up as the wiki logo.
17:52:03 <pesco> Yay!
17:52:03 * shapr fights the acls
17:52:20 <SamB> Lemmih: doesn't that just give me a list of the indices as-is?
17:52:56 <pesco> I need to get to bed!
17:53:07 <Lemmih> Yes, but you can then use 'index' to get the real index.
17:53:21 <pesco> See you tomorrow everyone.
17:53:29 <Lemmih> Night, pesco.
17:53:43 * pesco waves his arms about in an elaborate manner.
17:53:57 * pesco disappears in a puff of smoke.
17:57:01 <SamB> Lemmih: well, okay, so I have indices to Ints, but what about the other way round?
18:00:59 <Lemmih> That's not possible.
18:01:11 <Lemmih> At least not in a clean way.
18:01:18 <SamB> hmm.
18:05:36 <SamB> well range (l,u) !! index (l,u) i == i, when inRange (l,u) i (from the docs), but that is almost bound to be slow.
18:07:13 * SamB just does what he wants to do for arrays with Int indices for now
18:10:19 <cm> 3
18:10:33 * SamB realizes that there is no point restricting it to Ints when STUArray supports all sorts of stuff
18:13:58 * SamB is glad ghc -fglasgow-exts agrees with him on this point
18:15:20 <Lemmih> What are you hacking?
18:21:51 <Cale> Why is the LogoSuggestions page immutable?
18:23:10 <Cale> ah
18:24:21 <Cale> the whole wiki is :)
18:25:49 <shapr> doh
18:26:27 <shapr> Cale: create an account, I'll add you to AdminGroup
18:26:31 <Cale> I did a Monad Reader logo. :) http://vx.hn.org:81/autoshare/TMR-block.png http://vx.hn.org:81/autoshare/TMR-banner.png
18:27:32 <shapr> Wow, nice
18:29:48 <reffie> nice indeed!
18:30:51 * shapr kicks Moin ACL
18:36:11 * shapr kicks Moin 1.2 ACLs with great fervor
18:37:39 <Cale> heh, the ACLs were pretty painful as I recall
18:40:32 <shapr> Yeah, definitely.
18:40:56 <shapr> I can't figure out how to take edit away from anonymous but leave it for AdminGroup
18:42:56 <reffie> someone should write a wiki in haskell.
18:43:27 <reffie> and an irc client
18:43:32 <reffie> and and and
18:43:33 <Cale> #acl +All:read +AdminGroup:read,write,admin -All:write
18:43:35 <Cale> ?
18:43:40 * cm_ forks shapr & steals a copy
18:45:20 <Cale> I think it's to be read as a composition of functions which grant and remove rights from users matching the specified group
18:46:17 <Cale> oh, no, it's first match
18:46:26 * Lemmih throws hircules and flippi to reffie.
18:46:29 <Cale> hmmm
18:48:20 <Cale> okay, if you use + and -, then processing doesn't stop until you find the correct user and right
18:49:30 <Cale> #acl +AdminGroup:read,write,admin,revert +All:read -All:write,admin,revert,delete
18:49:38 <shapr> ohh
18:49:59 <shapr> You think that works for the acl_rights_default as well?
18:50:12 <Cale> perhaps...
18:50:34 <Cale> try it -- it looks like the right syntax
18:50:39 <camel__> is anyone currently working on a haskell implementation?
18:50:54 * shapr tries
18:51:04 <Cale> camel__: in general, or of the people logged in here?
18:51:12 <camel__> cale: in general
18:51:15 <shapr> camel__: There are three Haskell implementation authors who show up here, but none here right now.
18:51:16 <Cale> yes
18:51:39 <camel__> ah okay
18:51:52 <shapr> Are you also working on one?
18:51:56 <Cale> GHC, Hugs and NHC are under active development, as well as JHC, which isn't finished yet.
18:51:58 <camel__> this is going to sound wrong, but why are they implementing it? i mean what sort of things are they trying to do?
18:52:06 <reffie> is pugs an interpreter?
18:52:15 <shapr> reffie: and compiler
18:52:16 <Cale> pugs is an interpreter for perl
18:52:24 <Cale> and compiler now, I guess :)
18:52:26 <camel__> cale: oh sorry, I meant "working on building a new implementation" (what's JHC?)
18:52:34 <reffie> to what does it compile?
18:52:36 <reffie> C?
18:52:40 <reffie> haskell??
18:52:44 <shapr> reffie: read the docs
18:52:47 <reffie> okay
18:52:48 <camel__> shapr: no, I'm working on a "back end" for building compilers/interpreters
18:52:55 <Cale> http://repetae.net/john/computer/jhc/
18:52:57 <shapr> Like C--? or what?
18:53:23 <shapr> reffie: alternatively, ask on #perl6
18:53:27 <camel__> do you know LLVM?
18:53:48 <reffie> so i see pugs is only temporary until perl6 becomes selfhosting
18:53:49 <camel__> you can think of it as a typed assembly language (in SSA form)
18:54:00 <camel__> i'd love to see a haskell front end for it
18:54:02 <shapr> Yes, I know LLVM.
18:54:24 <camel__> so, was thinking of whipping one up myself, but thought I'd best check to see if there isn't something I could steal/borrow first
18:54:26 <shapr> Do you know lambda-the-ultimate.org ?
18:54:42 <camel__> yeah a friend pointed me there a while ago
18:56:03 <shapr> Are you one of the LLVM authors?
18:57:11 <shapr> I've seen LLVM discussed on ll1-discuss and LtU, but I haven't yet seen what benefits it has over C--
18:57:25 <shapr> Mostly because I haven't really read the LLVM discussions. :-)
18:57:31 <camel__> to some extent ;) I wrote the IA64 backend, for example, and do what I can to help out with the innards now and then
18:57:55 <camel__> well, I haven't heard much about C-- but from its name I can guess what it's like ;-)
18:58:28 <shapr> http://www.cminusminus.org/
18:58:51 <shapr> Cale: I think you fixed it!
18:59:06 * shapr hops cheerfully
18:59:10 <Cale> yay
18:59:12 <cm> (reading or coding, hmm)
18:59:23 <camel__> oh right
19:00:35 <camel__> OK, LLVM and C-- certainly have some things in common
19:00:38 <shapr> I suspect it's less trouble to explicitly hide pages, since it's a wiki.
19:01:28 <camel__> can someone explain what C--'s "runtime interface" is?
19:01:42 <camel__> i'm trying to download some PDFs files but am behind a very slow dialup connection at the moment ;(
19:02:10 <shapr> Sadly, I don't know enough details to usefully discuss.
19:02:38 <camel__> np, one of the PDFs just appeared ;)
19:03:06 <Cale> "But each of these impressive systems has a rich, complex, and ill-documented interface..."
19:03:40 <shapr> argh, I still can't edit by default.
19:04:22 <Cale> I can edit the AdminGroup page
19:04:29 <camel__> right, I think it's safe to say that LLVM is what you would get if you gave 10 angry PhD students C-- and told them that they wouldn't graduate unless they did something better ;)
19:04:33 <shapr> Right, because it has the explicit acl at the top.
19:04:51 <Cale> yeah
19:05:36 <shapr> Right now I have - acl_rights_default = "+AdminGroup:admin,read,write,delete,revert +All:read -All:write,admin,revert,delete" \n acl_rights_before = "+AdminGroup:admin,read,write,delete,revert" \n acl_rights_after = ""
19:05:45 <shapr> Anything obviously whacked about that?
19:05:47 <Cale> actually, I cant
19:05:51 <Cale> can't*
19:06:03 <shapr> Ack, suddenly I can't either.
19:06:32 <shapr> wtf is going on?
19:07:00 <cm> camel__: is LLVM that bad? ;)
19:07:31 <shapr> camel__: Send email to SPJ, and/or ask on ghc-users.
19:07:38 <camel__> cm: in terms of pragmatics? yeah, it is. ;) the result is a very, very useful bit of software though
19:08:34 <cm> camel__: I'm just confused about that statement.. I thought you just learned about C-- :/
19:08:51 <shapr> hiya SyntaxNinja
19:08:55 <Lemmih> Yo SyntaxNinja.
19:09:20 <SyntaxNinja> shapr, Lemmih y0y0
19:09:56 <SyntaxNinja> I just got a shredder.  it's fun to shred things.
19:09:58 <notu> hey, syntaxninja
19:10:22 <SyntaxNinja> notu!
19:10:25 <cm> have you guys seen that 'a very short introduction' book series thing?
19:10:25 <Cale> http://wiki.marcont.org/HelpOnAccessControlLists seems relevant, but I can't tell what's wrong with those settings
19:11:36 <camel__> cm: well from looking at it for just a couple of minutes, LLVM is what you'd end up with if you took C-- and locked yourself in a room for 10 years. (seriously)
19:11:53 <Lemmih> SyntaxNinja: Got my mail?
19:12:13 <shapr> camel__: can you quantify that?
19:12:22 <SyntaxNinja> Lemmih: just got it.
19:12:50 <cm> camel__: in which sense? "losing track of reality" surely isn't what you mean?
19:12:53 <reffie> yaaaay
19:12:54 <shapr> Or as I say to my clients sometimes "I can't unit test that description"
19:12:58 <SyntaxNinja> Lemmih: cabal-get doesn't depend on the new cabal, right?
19:13:01 <reffie> i'm finally done with this stupid project
19:13:03 <SyntaxNinja> doesn't depend on your patch
19:13:24 <SyntaxNinja> Lemmih: because we don't want people to have to install a new cabal if we can avoid it.
19:13:45 <mwc> This night is better than christmas eve.... Hudak's book is supposed to arrive tomorrow
19:13:50 <camel__> cm/shapr: OK, so I just read "what c-- is not" and it struck me as a little bogus. they're *trying* to say that xyz is out of the scope of their work/interest (things like a JIT, say) but they actually make it sound like those are bad things
19:14:03 <SyntaxNinja> mwc: you can spend the day getting the libraries working to prepare.
19:14:22 <Lemmih> SyntaxNinja: Should I strip out the verbosity changes?
19:14:24 <shapr> camel__: I seriously doubt SPJ would say those are bad things.
19:14:32 <Lemmih> SyntaxNinja: Cabal-get does depend on the patch.
19:14:36 <mwc> SyntaxNinja, hhahaha, I'm getting Mac OS X 10.4 tomorrow too.
19:14:41 <mwc> I'm gonna break GHC first
19:15:10 <SyntaxNinja> Lemmih: why?
19:15:34 <SyntaxNinja> Lemmih: I would like to avoid releasing a new cabal at this stage, if possible.
19:15:50 * shapr checks to see if he's editing the right file
19:16:20 <Lemmih> SyntaxNinja: I _really_ need stuff like 'getInstalledPackages' (:
19:16:28 <mwc> I once asked why GHC didn't target the GCC backend for free optimizing code generation... because it was a moving target to hit. Yet GHC 6.4 is broken by GCC 4.0 ?!
19:17:01 <SyntaxNinja> Lemmih: ahh, true. hm
19:17:44 <shapr> I really don't want to upgrade to moin 1.3 just because I can't figure this out.
19:18:19 <SyntaxNinja> Lemmih: well, I could do a release. I definitely agree that you need that. OTOH, I would sorta like to wait until the hackage server is in its perminent home
19:18:47 <camel__> shapr: from "the c-- language specification": "...these virtual machines are extremely high-level compared to C--. Each provides a rich type system, garbage collector, .... ....and depending on your language model, they may impose a significant penalty in both space and time."
19:19:23 <Lemmih> SyntaxNinja: OK. I'll just copy the needed functions then.
19:19:50 <cm> camel__: true it is.
19:19:52 <SyntaxNinja> Lemmih: well, if you're going to make a public release, and ask people to upload packages and stuff; then I could make a cabal release
19:19:54 <camel__> that's being needlessly spooky I think. anyway, I just think it would be nice to have a haskell front end for LLVM
19:19:59 <SyntaxNinja> have you checked with shapr to see if he's OK with that?
19:20:09 <shapr> ok with what?
19:20:11 <camel__> because the one implementation would give you an interpreter and a compiler
19:20:22 <SyntaxNinja> Lemmih: the only thing is that we'll have to tell everyone how to move over to the new server once its up.
19:20:53 <shapr> I think snowblind is going down in the next week, so I wouldn't recommend putting anything new on it right now.
19:20:58 <cm> camel__: think of .NET or JVM. every bullet hits :]
19:22:51 <camel__> yeah but the claim it's an "important non-goal" is a lie :) or it should be! there's no reason one couldn't provide all the "extra goodies" for C--, and to some extent LLVM does just that. (the LLVM purists would kill me for saying that, but anyway...)
19:23:27 <cm> hm?
19:23:29 <camel__> anyway, this JHC thing looks like I could make it spit out LLVM easily enough, so I might start there
19:23:46 <cm> thing is, .NET's type system doesn't quite match Haskell's
19:23:59 <cm> and such stuff is exactly what is paraphrased there
19:24:14 <cm> 'depending on your language model'.. Haskell is not quite Yet Another OO Language
19:24:39 <Lemmih> SyntaxNinja: ETA on haskell.galois.com?
19:25:16 <shapr> camel__: does LLVM support region allocation?
19:25:35 <camel__> cm: ok, suppose you wrote a haskell compiler targetting the JVM. where's the significant penalty in space and time?
19:25:40 <shapr> Hm, doesn't seem so.
19:25:48 <shapr> camel__: JVM doesn't handle tail calls.
19:26:21 <SyntaxNinja> Lemmih: Most probably this coming week.  I honestly don't know what the holdup is, but I can probably beg and plead.
19:26:28 <camel__> shapr: (no, not that I'm aware of)
19:26:40 <camel__> shapr: OK, so what would you do?
19:26:54 <cm> camel__: choose a more adequate target. like C-- :)
19:26:59 <cm> (s/choose/build)
19:27:00 <SyntaxNinja> Lemmih: so let's guess monday or tuesday
19:27:00 <shapr> I wouldn't try to compile Haskell to the JVM.
19:27:08 <camel__> and what are you _really_ doing when you do that?
19:27:14 <shapr> What do you mean?
19:27:27 <cm> camel__: inventing a target which is suited to Haskell
19:27:38 <SyntaxNinja> Lemmih: and that'll give me a little more time to make a proper cabal release
19:27:40 <cm> camel__: or low-level enough that it doesn't matter
19:27:45 <camel__> exactly. you're dropping down a level
19:27:53 <camel__> and remind me why you couldn't get this target running on the JVM?
19:27:58 <camel__> (efficiently, at that?)
19:28:08 <cm> didn't shapr just name a reason?
19:28:38 <shapr> Tail calls don't work on the JVM.
19:29:20 <cm> also, think about the overhead you get when you stuff Haskell semantics onto a VM optimized for Java semantics..
19:29:36 <cm> like, how would you implement certain stuff..
19:29:44 <cm> anyhoo, bed time. nn.
19:29:59 <camel__> ok I should stop being so obscure ;) all I'm trying to say is that no matter how "weird" your environment is, you should hopefully be able to ignore most of it, and use it as a simple assembly language
19:30:28 <shapr> C-- is designed to be a portable assembly language.
19:30:59 <shapr> And it's designed to improve upon C for that same purpose. C-- supports pluggable GC, tail calls, and some other goodies.
19:31:40 <camel__> ah ok, that's the heart of it I think
19:31:54 <shapr> Maybe LLVM is a really great way to do a Haskell implementation, I don't know enough about LLVM to say anything about that.
19:31:54 <camel__> whereas with C-- or LLVM you can _choose_ your garbage collector and optimizations
19:32:25 <camel__> "embracing" the JVM or .NET tie you down to specific ways of doing things, to some extent
19:32:28 <shapr> Well, hack up a Haskell LLVM, I promise to try it :-)
19:32:35 <cm> :]
19:32:53 <SyntaxNinja> camel__: so do you have to impelment the GC on top of LLVM?
19:33:22 <camel__> SyntaxNinja, you can one provided or you can roll your own. or you can go without
19:33:31 <camel__> +use
19:33:52 <SyntaxNinja> does llvm compile into the executable?
19:33:55 <shapr> Would I be able to implement a region allocator and drop it into LLVM?
19:33:56 <SyntaxNinja> like an RTS?
19:34:57 <camel__> shapr: _absolutely_, you might want to look at the papers on "pool allocation" on the site
19:34:59 <shapr> I'm interested in a fast path to mixing type theory and region allocation for NUMA SMP.
19:36:02 <camel__> SyntaxNinja: LLVM doesn't currently spit out an ELF/COFF binary by itself. it gives you JITs but currently depends on an external assembler/linker to emit executables, someone is working on that though
19:36:09 <shapr> Is the LLVM license DFSG compatible?
19:36:30 <camel__> shapr: yes, it is, I think there are .debs of LLVM 1.4 around somewhere too
19:37:29 <camel__> there was a quick discussion about it a few weeks ago, the conclusion was that it's a standard BSD license for all intents and purposes
19:39:11 <shapr> You can probably get Haskell quickly if you implement a GHC Core frontend for LLVM.
19:40:35 <camel__> ok, i'll take a look. :)
19:41:17 * SamB is having trouble with Data.Array.ST, wonders about a tutorial or somesuch...
19:42:55 <camel__> shapr: good luck with the parallel work? what do you mean by mixing type theory and region allocation?
19:43:25 <camel__> have types differing by memory semantics?
19:44:43 <SyntaxNinja> Lemmih: why are you exporting getInstalledPackagesAux?
19:45:40 <shapr> camel__: I want to use region allocation to get the right data next to the right code for something like the nine-core Cell cpu.
19:45:57 <Lemmih> SyntaxNinja: getInstalledPackages uses ConfigFlags which I'm not interested in.
19:46:57 <SyntaxNinja> I see
19:47:04 <shapr> Each sidekick cpu in the Cell has 256k of ram/cache, I think region allocation may be able to do traffic analysis well enough to cut down on distributed GC, and improve data locality.
19:47:23 <SyntaxNinja> Lemmih: but you're exporting both of them?
19:47:54 <camel__> shapr: what sort of parallelism are you trying to handle, though?
19:48:38 <shapr> SPMD, Sisal/Nesl/etc
19:48:41 <camel__> I mean if you just have completely distinct tasks that need to be done, that's the easy case for such a processor I'd imagine
19:48:44 <camel__> ah okay
19:49:06 <Lemmih> SyntaxNinja: That's a mistake then.
19:49:21 <camel__> well, can you walk me through an example? (I'm trying to think of how I could extend LLVM here ;)
19:49:43 <camel__> suppose you have a boatload of numbers and you just want their sum
19:50:06 <SyntaxNinja> Lemmih: in that case, I"ll probably switch the names around; and only export the non-aux functoins. how does that sound?
19:50:16 <SyntaxNinja> since the "aux" functions would then be nice & local to this module.
19:51:38 <Lemmih> Sounds great.
19:52:10 <shapr> camel__: Splitting that isn't hard, that's just unrolling I think.
19:52:45 <SyntaxNinja> Lemmih: so in general, that's how i'd do it, for future reference. if a function is going to be useful outside of cabal, then give it the "good" name, and export it
19:53:01 <shapr> But I don't know if I can use region allocation to split the code and data as well to put the right amount into the right places.
19:53:49 <shapr> It sure sounds right though.
19:54:30 <camel__> what do you mean by "split" the code? I'm imagining everything running on one processor, but if a large enough loop comes along, it gets "unrolled" into multiple tasks, which get forked off onto each core
19:54:49 <camel__> is that the sort of thing you want to end up with?
19:55:38 <SyntaxNinja> does megamonad still come around here?
19:56:32 <shapr> camel__: GHC is getting SMP support, and has some support for nested data parallelism - http://www.cse.unsw.edu.au/~chak/nepal/
19:58:40 <shapr> But I want to be able to use something like the 64 core Cell from the end of Sony's roadmp, which will have 512 sidekick cpus each with their own 256k of memory.
19:58:59 <camel__> ah that's great :) because the trick will be how to support that nicely in LLVM, and we haven't yet had a front end properly stumble across that problem yet (java on llvm will probably be the first, not sure though)
19:59:04 <shapr> Especially if garbage collection is used you want the data to be next to the code.
20:01:30 <shapr> Cale: looks like " *Name" is not the same as " * Name" for the ACLs. Is that irritating or what?
20:02:08 <camel__> hmm. well, i'm going to run off and will hopefully get GHC or JHC coughing up LLVM sometime
20:02:33 <camel__> have fun ;D
20:02:47 <shapr> camel__: Anyway, I am living two lives, in one life I am shapr - FP researcher, but in another life I am a self-employed web developer. One of these lives has futures (and subcontinuations!)
20:02:47 <shapr> doh
20:03:07 * shapr horribly misquotes The Matrix
20:05:25 <Gahhh> Umm, yes Mr Erisson
20:06:24 <shapr> I think I'm going to use that for my next email signature.
20:07:00 <SyntaxNinja> Lemmih: what do you use config compiler for ooi?
20:09:13 <Cale> shapr: haha - that's awful
20:09:35 <shapr> Cale: moin? or my matrix misquote?
20:09:51 <SyntaxNinja> Igloo: you should make a version of the ghc6.4 package that can be installed alongside 6.2 :)
20:09:57 <SyntaxNinja> because I need them both!
20:10:07 <Cale> moin
20:10:08 <shapr> shades of alexj!
20:10:41 <SyntaxNinja> shapr: 'eh?
20:10:59 <Cale> heh, the matrix misquote is pretty good too
20:11:18 <Lemmih> SyntaxNinja: It returns a Compiler type which can be parsed to getInstalledPackages.
20:11:28 <shapr> Futures are the same thing as continuations aren't they?
20:11:52 <shapr> SyntaxNinja: Just about having multiple things installed at once. I just wanted to see if your blood pressure would go up.
20:13:31 <SyntaxNinja> shapr: hehe
20:13:43 <reffie> ghc 4.x is written in C isn't it?
20:13:48 <SyntaxNinja> shapr: I should be able to have ghc6.4 AND ghc 6.2 installed at the same time, and the internet should be able to decide which one I use!
20:14:54 <reffie> or let me ask more directly: is there an haskell compiler in C?
20:15:04 <Gahhh> reffie: ghc is in haskell
20:15:13 <Gahhh> erre
20:15:14 <Gahhh> yes
20:15:18 <SyntaxNinja> reffie: nhc and hugs
20:15:23 <Gahhh> 4.x was in c iirc
20:15:42 <reffie> so how does one compile ghc, if he doesn't have it already?
20:16:09 <Gahhh> need binaries, or need C files generated on a similar cpu arch
20:16:11 <SyntaxNinja> Lemmih: you can pull the new cabal from darcs.
20:16:20 <shapr> SyntaxNinja: haha!
20:16:41 <SyntaxNinja> shapr: we can take a poll ;)
20:16:46 <reffie> Gahhh what if you want to compile ghc to a new arch?
20:16:54 <SyntaxNinja> reffie: cross-compile it first
20:16:54 <shapr> You make .hc files.
20:17:06 <Gahhh> reffie: that's a bit of work heh. ghc is on many arch's already tho
20:17:16 <SyntaxNinja> reffie: but I think it's painful, so you should be sure there's not a GHC for your arch already
20:17:17 <shapr> I do wish darcs .hc files were available.
20:17:25 <reffie> well
20:17:41 <reffie> can't you use ghc-4 to compile newer ghcs?
20:18:05 <Gahhh> reffie: you could supposedly go from ghc 4 to ghc 5 then to ghc 6 that way. ghc 6 requires at least ghc 5 iirc
20:18:22 <reffie> i see
20:18:52 <shapr> yes, 4.08 -> 5.04 -> 6.x
20:19:20 <shapr> hoi pediddle
20:19:38 <Gahhh> is TMR#2 out yet ?
20:19:56 <pediddle> you'll be happy to learn i'm IRCing via iChat
20:19:57 <shapr> No, but I think I just fixed the last problem.
20:20:16 <shapr> Now I have to add acl to all the pages that should be invis, and I'll be done.
20:20:19 <pediddle> through much tribulation, i have connected to a jabber irc transport -- woohoo
20:20:19 <Gahhh> does iChat have somethign to do with iPods ?
20:20:29 <reffie> pediddle i didn't know ichat could irc
20:20:39 <pediddle> it can in tiger, via jabber
20:20:43 <pediddle> kinda clunky
20:21:11 * pediddle tests /me
20:21:11 <reffie> well
20:21:19 <reffie> it seems that even ghc 4.08 is written in haskell!
20:21:29 <Cale> yes
20:21:41 <Gahhh> reffie: for those versions I believe they had .hc tarballs
20:22:02 <pediddle> /msg lambdabot @moo
20:22:05 <pediddle> d'oh
20:22:08 <pediddle> guess that doesn't work
20:22:35 <reffie> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/yaccParser/?cvsroot=;hideattic=0;sortby=#dirlist
20:22:38 <reffie> maybe this is it?
20:22:48 <foxy> @seen dons
20:22:49 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
20:23:14 <foxy> dons : have you had a chance to look at those cygwin-generated hs-plugin errors?
20:23:23 <Gahhh> reffie: no, that's only part of ghc.
20:24:13 <reffie> well, Gahhh i'm looking for the stuff that was used to compile the first ghc
20:24:59 <Gahhh> reffie: See the hc files at the bottom of this page: http://haskell.org/ghc/download_ghc_406.html
20:25:15 <reffie> you don't understand, Gahhh.
20:25:57 <shapr> reffie: You want to start at the beginning?
20:26:06 <reffie> yes
20:26:24 <shapr> In that case, GHC is by far too recent.
20:26:32 <shapr> But you can read this to get you started - http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
20:26:42 <reffie> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/yaccParser/Attic/hsparser.y?rev=1.3;content-type=text%2Fplain;hideattic=0  <-
20:27:28 <SamB> Hmm, the documentation for Data.Array.ST is sorely lacking. Apparantly one must go through complicated gymnastics to do anything even slightly polymorphic with Data.Array.ST, due to (ST s) leaking into MArray constraints...
20:27:29 <shapr> There's another similar book from the 80s that SPJ wrote, but I can't remember the name.
20:27:44 <reffie> so the first haskell compiler was written in that "core language"?
20:28:28 <shapr> Look up the Spineless Tagless G-machine, and the Three Instruction Machine before that.
20:28:37 <reffie> ok
20:28:59 <shapr> Or for instant gratification, look at the output of -ddump-core when you compile a program with GHC.
20:29:23 <shapr> I think SPJ used supercombinators before TIM.
20:33:49 <Pseudonym> Miranda used SK combinators.  I believe SPJ first played with the G machine.
20:35:57 <vdrab> hello #haskell...
20:36:53 <vdrab> I'm trying to get my new linux box up and running, and I apt-got GHCl binaries, but it's version 6.2
20:37:11 <SamB> really, all this about quantified type variables escaping is enough to drive one to unsafePerformIO...
20:37:14 <Pseudonym> 6.2 is a good version.
20:37:17 <shapr> vdrab: deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable
20:37:35 <vdrab> oooh
20:37:47 <vdrab> thanks
20:37:58 <vdrab> how do you people find those things?
20:38:09 <shapr> Get on the debian-haskell mailing list.
20:38:19 <vdrab> i see
20:38:20 <Pseudonym> And it was in the topic once upon a time.
20:38:21 <SyntaxNinja> vdrab: 6.4 won't go into unstable until after sarge releases
20:38:34 <Pseudonym> SyntaxNinja: Great.  We'll be waiting for years.
20:38:43 <blackdog> shortly before the sun explodes, no?
20:38:49 <SyntaxNinja> vdrab: 6.2 is nice and stable, as Pseudonym points out, and ghc is a stress on the auto-builders, so we're being nice :)
20:38:53 <vdrab> so most of you linux people are still on 6.34?
20:39:57 <SyntaxNinja> 6.34?
20:40:19 <Pseudonym> I don't think I've ever used 6.34.
20:40:21 <SyntaxNinja> Pseudonym: blackdog: no way! I hear that sarge is going to release Real Soon Now!
20:40:25 <vdrab> er,,, 6.3_something
20:40:28 <pediddle> fink on OS-X also only has version 6.2
20:40:32 <SyntaxNinja> vdrab: is that the ghc-cvs version?
20:40:42 <SyntaxNinja> pediddle: what's their excuse ;)
20:40:45 <Pseudonym> Did the Simons finally add the TimeWarp module?
20:40:50 <vdrab> no, i probably just got the version number wrong
20:40:51 <pediddle> i have no idea, it's very frustrating
20:40:56 <SyntaxNinja> at least Igloo has made 6.4 available
20:41:00 <blackdog> SyntaxNinja: keep the faith, dude.
20:41:03 <pediddle> hugs is version 200102
20:41:09 <pediddle> four years old, ouch
20:41:18 <reffie> will sarge EvER release?
20:41:22 <reffie> EVER
20:41:41 <blackdog> yeah, it's called Ubuntu now. :)
20:41:46 <vdrab> hehe
20:41:50 <vdrab> i'm on Ubuntu
20:41:52 * SyntaxNinja whips self
20:41:59 <Pseudonym> Does anyone have a tool which takes a type and produces the free theorem?
20:42:11 <Pseudonym> I can write one easily enough, just curious if I have to reinvent the wheel or not.
20:42:24 <blackdog> SyntaxNinja:  ... any reason in particular, or just your own special kink?
20:42:42 <SyntaxNinja> one problem is that everyone wants the latest version of everything :)
20:42:59 <Pseudonym> SyntaxNinja: Just the latest version of Debian would be fine.
20:42:59 <SyntaxNinja> blackdog: I just thought that, as a representative of the debian project, #haskell would like me to suffer for the release
20:43:25 <blackdog> Oh, that's right. Yeah, it's hessian and cold showers and Fox television for you, m'boy.
20:43:35 <shapr> What's hessian?
20:43:39 <blackdog> sackcloth
20:43:42 <blackdog> uh, burlap?\
20:43:43 <Pseudonym> shapr: The hair shirt.
20:43:45 <shapr> Other than cavalry and a section of Germany.
20:43:49 <blackdog> i think it's a UKism
20:44:11 <shapr> Is hair shirt the same as flax shirt?
20:44:32 <Pseudonym> @google hair shirt
20:44:34 <lambdabot> http://www.newadvent.org/cathen/07113b.htm
20:44:37 <shapr> I've always thought self flaxellation was just as evil as self flagellation.
20:44:55 <blackdog> Neither is as evil as wilful punning, though
20:45:08 <shapr> I'm not convinced that goat hair is more painful than flax.
20:45:09 * Pseudonym didn't find it particularly punny
20:45:56 <shapr> Oh, the hair shirt is just a symbol.
20:46:11 <SyntaxNinja> we should see if Philippa_ knows anything about this
20:46:24 <shapr> Social flagellation rather than actual masochism.
20:46:56 <Pseudonym> I don't think Philippa is into religious penance.
20:47:18 <SyntaxNinja> she might know about it on the side, though.
20:47:24 <vdrab> not to change the topic or anything, but I heard some time ago that the Ocaml people were looking to include GADT's in their next release. anyone know something about this?
20:47:41 <pediddle> ocaml? what's that?
20:47:42 <Pseudonym> What a bunch of geeks we are.  We have to wait until the person who knows about kinky stuff turns up.
20:47:46 <vdrab> hehe
20:48:10 <shapr> Pseudonym: There's also the possibility that some of us would rather hide our knowledge.
20:48:44 <shapr> Pseudonym: Oh, did you see my FP matrix sig I just came up with?
20:48:48 <blackdog> shapr: that's a scurrilous lie. I'll see you in court, bub!
20:49:07 <Pseudonym> No...
20:49:23 <Pseudonym> blackdog: Make sure you send me the court transcripts.
20:49:37 <Pseudonym> They'll make interesting reading in the next TMR, I'm sure.
20:49:53 <shapr> I am living two lives. In one life I am shapr, FunctionalProgramming researcher
20:49:53 <shapr> but in another life I am a self-employed web developer | www.ScannedInAvian.com
20:49:53 <shapr> One of these lives has futures (and subcontinuations!) |  --Shae Matijs Erisson
20:50:06 <Pseudonym> :-)
20:50:19 <Pseudonym> It's amazing how well computer metaphores work in real life.
20:50:24 <Pseudonym> metaphors
20:51:06 <Gahhh> for some values of real life, maybe
20:51:47 <SyntaxNinja> my best information is that Sarge will release in one month. you heard it here first ;)
20:52:34 <shapr> Yesterday I tried to describe turning a Zipper data structure into a mutable tree of parallelizable subcontinuations, but I don't think my fiancee was particularly appreciative.
20:53:01 <blackdog> i'm not surprised. it sounds filthy.
20:53:15 <blackdog> you permissive scandinavians, i don't know...
20:53:48 <Pseudonym> I successfully explained the basics of special relativity to my wife last week.
20:53:59 <Pseudonym> She has dyscalculia, which makes it even more of a challenge.
20:55:44 <shapr> That depends on what sort of dyscalculia, doesn't it?
20:55:53 <SyntaxNinja> Pseudonym: is this back along the lines of our previous discussion?
20:56:16 <Pseudonym> I dunno.  What was our previous discussion?
20:56:34 <Pseudonym> Well, she is a fine arts major.  I explained it in terms of geometry.
20:56:56 <SyntaxNinja> does anyone have experience w/ mutually recursive mods in ghc 6.4?
20:57:08 <shapr> hs-plugins is using them.
20:57:10 <shapr> Yi too
20:57:14 <Pseudonym> She can't handle numbers, basically.
20:57:36 * blackdog manfully resists the temptation ask about her figures.
20:57:45 <blackdog> s/ask/to ask/g
20:57:53 <SyntaxNinja> blackdog: you failed
20:58:05 <blackdog> we are all of us in the gutter
20:58:09 <SyntaxNinja> shapr: does that mean that you know about them? :)
20:58:51 <shapr> No, but I could stare at Yi/hs-plugins and see what works there.
20:59:08 <SyntaxNinja> I'm wondering why its better than in 6.2
20:59:14 <SyntaxNinja> it's more work for cabal, it seems :)
20:59:19 <shapr> Oh, I don't know.
20:59:20 <SyntaxNinja> and how --make works
20:59:38 <shapr> I surely hope that the link checking is in 6.4.1
20:59:48 <shapr> That will save huge amounts of CPU time the world over.
21:00:03 <shapr> Pseudonym: random interesting thingy I found - http://www.kimbly.com/blog/000404.html
21:04:33 <Pseudonym> Oh, that is interesting.
21:07:50 * SamB wants foralls in constraints...
21:09:27 * SyntaxNinja hands SamB constraints in forall
21:11:19 <SamB> @paste
21:11:20 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
21:13:21 <Gahhh> This is great: http://www.kimbly.com/blog/000402.html
21:13:37 <Gahhh> I'd seen it before, but still great.
21:16:03 <SamB> SyntaxNinja: they don't seem to work, though they do seem to parse.
21:16:11 <SamB> see @paste
21:16:38 <SyntaxNinja> SamB: it was a joke... you asked for foralls in constraints, I gave you constrained foralls
21:16:41 * SamB remembers to save
21:16:45 <Gahhh> ok this is an interesting claim: "One of the other interesting facts he pulled out was that >30% of OO.org's binaries and libraries are symbol tables, because no matter how private your funcitons and variables are, all other C++ applications need to know their addresses for a multitude of reasons."
21:17:07 <SamB> SyntaxNinja: they don't help much when I'm trying to escape from fascist ST running functions!
21:18:02 <SamB> how is Data.Array.ST supposed to be used?
21:22:57 <SamB> the nastiness with MArray and escaping existentially quantified type variables is really nasty... hasn't anyone actually tried to *use* Data.Array.ST yet?
21:23:32 <Gahhh> I havent
21:23:58 <SyntaxNinja> SamB: I've used STUArrays
21:27:08 <SamB> SyntaxNinja: did you use it monomorphically or something?
21:28:36 <SyntaxNinja> SamB: eh not sure what you mean.
21:29:05 <SamB> well, basically, did you use a fixed index type?
21:29:22 <SyntaxNinja> SamB: doh! I have used IOUArrays... sorry
21:29:28 <SyntaxNinja> I was just trying to get you excited
21:29:57 <SamB> oh
21:30:40 <shapr> I'm excited!
21:30:55 <SyntaxNinja> shapr: but you're always excited
21:31:17 <SamB> I guess I'll just cave and use unsafePerformIO
21:31:53 <SamB> fascist ST thingies hurt my head...
21:32:00 <shapr> SyntaxNinja: Well, yeah. That's true.
21:32:25 <SyntaxNinja> shapr: run! he's using unsafePerformIO!
21:32:32 <shapr> ohnoo
21:32:46 <daveo_wales> nooo
21:33:09 <blackdog> god, you're all such prudes.
21:34:01 <SamB> I have the distinct impression that nobody actually uses Data.Array.ST, except maybe HM/GHC wizards.
21:34:24 <Gahhh> SamB: Then, maybe there are test cases for that in GHC sources ?
21:34:25 <spoonspleen> is the haskell compiler created in haskell?
21:34:27 <SyntaxNinja> blackdog: oh hey, care to field any questions about latex template for the haskell workshop?
21:34:30 <SyntaxNinja> spoonspleen: GHC is
21:34:50 <blackdog> ... latex template? i know nothing about latex templates...
21:34:50 <SamB> Gahhh: I don't know!
21:34:53 <shapr> I'm being so useful - http://www.hfml.science.ru.nl/froglev.html
21:35:01 <blackdog> whatchoo talkin' about, willis?
21:35:14 <spoonspleen> SyntaxNinja: GHC is created in haskell?
21:35:38 <SyntaxNinja> spoonspleen: yes
21:35:42 <SamB> @index unsafePerformIO
21:35:43 <lambdabot> System.IO.Unsafe, Foreign
21:36:09 <SyntaxNinja> blackdog: well, I thought you had some paper in the haskell workshop or icfp in 03, so I thought you might know about such things
21:36:51 <blackdog> SyntaxNinja: not me. I gave a talk at IFL, but that's it.
21:37:46 <SyntaxNinja> blackdog: maybe it's just that your presence was so powerful that I thought you had given a talk at the end ;)
21:38:20 <blackdog> it's the leather jacket and the facial scarring. :)
21:38:26 <SyntaxNinja> hehe
21:38:48 <SyntaxNinja> there was never a hamsomer mug that graced ICFP
21:39:28 <blackdog> hamsome? Are you calling me porky?
21:40:07 <SyntaxNinja> no, i've been drinking, though.
21:40:14 <Pseudonym> Sometimes I wonder if my job in life is to be someone else's search engine.
21:40:50 <SyntaxNinja> Pseudonym: could you look up that hair-shirt question, actually?
21:42:53 <Pseudonym> You know, I've been looking at @wiki ModelizingInHaskell for some time now.
21:42:59 <Pseudonym> And I still don't get it.
21:43:09 <Pseudonym> Is it a real problem looking for a solution?
21:43:19 <Pseudonym> Or am I just particularly dense?
21:44:07 <Pseudonym> Or is the person in question really looking for extensible algebraic data types?
21:44:11 <Gahhh> @wiki ModelizingInHaskell
21:44:12 <lambdabot> http://www.haskell.org/hawiki/ModelizingInHaskell
21:52:17 <Gahhh> Pseudonym: it looks like a special-case problem.
22:06:05 <SamB> ST is so safe it could kill you...
22:13:30 <shapr> Personally, I think ThingsToAvoid is eponymous.
22:15:46 <Cale> http://vx.hn.org:81/autoshare/15-gon.png -- I've been busy tonight :)
22:17:16 <shapr> What is that?
22:17:29 <Cale> ruler-and-compass construction of a 15-gon
22:17:34 <Cale> (regular 15-gon)
22:17:37 <shapr> oh
22:18:02 <Cale> 17 is trickier :)
22:18:55 <reffie> ubuntu?
22:19:02 <Cale> hm?
22:19:11 <Cale> debian
22:19:12 <reffie> your distro
22:19:20 <reffie> ah
22:19:30 <Cale> I'm running gnome + enlightenment
22:22:05 <smott> Cale: which gtk2 engine is that? i've been looking for that one
22:22:38 <shapr> flat?
22:22:40 <reffie> industrial?
22:22:45 <Cale> industrial
22:22:54 <smott> thanks
22:23:17 <Cale> http://art.gnome.org/themes/gtk2/
22:23:42 <Cale> has practically all of the good gtk2 themes
22:25:03 <nailbiter> i'm trying to write a red-black tree implementation (as a personal challenge), my head is about to explode
22:25:19 <Gahhh> and you're biting your nails, too.
22:25:21 <nailbiter> i think i understand now why so many C programmers use hash tables instead. :)
22:25:25 <nailbiter> yah. :-P
22:25:57 <SamB> also linked lists are popular, afaik
22:30:54 <nailbiter> most red-black tree algorithms assume you can have 'parent' pointers in tree nodes.  but there's no such thing in haskell, which is driving me nuts
22:31:00 <Pseudonym> C++ has a built-in red-black tree implementation.  C++ programmers just use that.
22:31:10 <Pseudonym> nailbiter: Ah, that's what you need the zipper for!
22:31:21 <nailbiter> Pseudonym: the STL 'map' container?  that's pretty cool actually. :)
22:31:26 <Pseudonym> Yes, it is.
22:31:32 <Pseudonym> Particularly cool is that it has iterators.
22:31:33 <nailbiter> Pseudonym: zipper?
22:31:35 <Pseudonym> That work. :-)
22:31:38 <Pseudonym> @wiki TheZipper
22:31:39 <lambdabot> http://www.haskell.org/hawiki/TheZipper
22:31:44 <nailbiter> danke. :)
22:32:30 <nailbiter> Pseudonym: by the way, i once benchmarked the 'map' container against a Perl hash. :) Perl won, for some reason
22:32:44 <Pseudonym> That's unsurprising.
22:33:00 <Pseudonym> Binary search trees on strings require O(log n) comparisons.
22:33:04 <Pseudonym> Hash tables require 2.
22:33:11 <Pseudonym> Well, effectively two.
22:33:31 <Pseudonym> One pass over the key to compute the hash function, and one comparison to check that you've got the right element.
22:33:59 <nailbiter> ah, i see. i suppose all the pointer-chasing in the tree might also slow things down
22:34:20 <Pseudonym> Less than you'd think.
22:34:22 <shapr> Huh, I didn't know Jan-Willem Maessan was part of the Fortress effort.
22:35:42 <shapr> Ok guys, what did I miss? http://www.haskell.org/tmrwiki/FrontPage
22:36:44 <Pseudonym> The most efficient string dictionary data structure that I've seen is a depth-limited ternary trie structure with binary search trees to handle the suffixes.
22:37:04 <nailbiter> trie
22:37:08 <nailbiter> ?
22:37:20 <nailbiter> it's been a decade since i last studied computer science, and i think it shows. :)
22:37:24 <Pseudonym> Ah. :-)
22:37:33 <Pseudonym> Well, imagine that you're storing a string of bits.
22:37:47 <Pseudonym> You could, in principle, store them using a binary tree.
22:38:01 <Pseudonym> Where you go down the "left" branch if the bit is zero and the "right" branch if the bit is one.
22:39:10 <nailbiter> ah, so the edges in the tree store bits? and the path to a leaf contains the string being stored?
22:39:17 <Pseudonym> No, that's just one example.
22:39:21 <Pseudonym> That's a "digital trie".
22:39:31 <Pseudonym> "Digital" because it stores bits.
22:39:51 <Pseudonym> A ternary trie branches on a whole character at a time.
22:40:12 <Pseudonym> Which would normally require a node with n branches, where n is the size of the character set.
22:40:20 <Pseudonym> Sorry, 2^n branches.
22:40:35 <Pseudonym> e.g. for Latim-1, you'd need a 256-way branch node
22:40:38 <Pseudonym> Latin
22:40:48 <Pseudonym> For Unicode... you get the idea.
22:41:00 <Pseudonym> So instead, Ternary tries store each "level" as a binary search tree.
22:41:21 <Pseudonym> Kind of like how red-black trees are really 2-3-4 trees.
22:41:24 <nailbiter> ah, i see. :)
22:41:33 <Pseudonym> You store the 2, 3 and 4-nodes using 2-nodes only, but adding a colour bit.
22:42:15 <Gahhh> shapr: I can see all the articles. looks like a lot of content. I am sure the FFi article will be appreciated by many :)
22:42:40 <shapr> Yes, I think so.
22:42:52 <shapr> What do you think about the editorial? Too cheesy?
22:43:50 <nailbiter> hmm .. it sounds very space-efficient, because the trie doesn't need to store whole-keys at each node. :)
22:44:02 <Pseudonym> Right.
22:44:12 <Pseudonym> To search for a key, you only need to scan the key once.
22:44:18 <Gahhh> shapr: No, it's to the point.
22:44:23 <Pseudonym> WIth hashing, you neeed at least two passes.
22:44:45 <shapr> Gahhh: cool, thanks for the feedback. Oh one more question, can you edit the feedback pages?
22:44:54 <reffie> shapr what happened to the TH article?
22:45:09 <nailbiter> Pseudonym: a very cool data structure. :)
22:45:11 <shapr> I ended up binging on paying work instead, sorry.
22:45:35 <reffie> :)
22:45:43 <shapr> Next Issue, or sooner.
22:46:00 <shapr> It occurs to me that if an article is done early, might as well publish it.
22:46:54 <Gahhh> shapr: I just did.
22:47:07 <shapr> thanks
22:47:20 <shapr> heh
22:48:35 <Gahhh> I haven't read joelonsoftware much before. to a guy like me who writes COM, it's painfully sweet to read him bash MS...
22:50:55 <shapr> Ok then
22:51:06 <shapr> If no one else sees any bugs in TMR2, I'll announce on the mailing list.
23:09:05 <Cale> shapr: do you think anyone would mind if I replaced runsum from the Haskore article with scanl (+) 0 ?
23:09:15 <Cale> (i.e. its definition with that)
23:10:37 <shapr> I suggest the STM approach.
23:10:55 <shapr> (ask for forgiveness rather than permission)
23:11:01 <Cale> okay
23:11:41 <Pseudonym> I heard a rumour that that famous quote was actually from Grace Murray Hopper.
23:11:51 <Pseudonym> It might just be that she used it a lot. :-)
23:12:28 <Gahhh> that's asking lazily evaluated
23:16:43 <gzl> Pseudonym: which quote?
23:17:30 <Pseudonym> The one about it being better to beg forgiveness than ask permission.
23:18:54 <shapr> Pseudonym: Any idea if aspects are different from or better than a post/pre/replace hook monad?
23:19:45 <gzl> ah, that.
23:25:49 <skew> shapr: I think it's pretty close to the same thing
23:26:49 <shapr> Did you see the long involved discussion on LtU about it? I never did figure out if Frank Atanassow's response meant "yes it's a monad" or was purely informational.
23:27:05 <skew> I like the compatibility proposal in Issue Two
23:27:06 <shapr> Obviously the correct solution here is to try to implement the AOP monad.
23:27:54 <skew> People have decided a while ago to trade CPU for ease of programming, I think it's also reasonable to trade storage space for compatibility
23:36:20 <shapr> gzl: think you'll have time to do a WASH/CGI demo/tutorial by the first of next month?
23:36:40 <shapr> dcoutts: gtk2hs demo for TMR3?
23:36:59 <shapr> skew: typesystem goodies for TMR3?
23:37:33 <shapr> dons: hs-plugins for TMR3?
23:38:00 <shapr> Ah, I need to bug Wouter. I really want to understand AGs.
23:38:16 <shapr> shapr: Template Haskell Tutorial for TMR3?
23:38:18 * shapr grins
23:38:43 <Gahhh> shapr: you said on LtU that you would post the later issues to the home page heh.
23:38:51 <shapr> Yeah, I know.
23:38:56 <skew> I'll working some tonight on the paper I hope to adapt for TMR3
23:39:07 <shapr> But I think LtU is really about PL theory.
23:39:12 <skew> what does Wouter have to do with AGs?
23:39:15 <shapr> And this issue doesn't have so much.
23:39:34 <shapr> skew: if you're logged in, http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
23:40:04 <shapr> Though the articles by pesco and TheHunter could count as PLT... hmm.
23:40:19 <shapr> Gahhh: Ok, you've persuaded me.
23:41:13 <skew> strange, I think I'm logged in and I can't see it
23:41:36 <shapr> What's your username on TMR?
23:41:41 <skew> BrandonMoore
23:42:10 <shapr> oops, try now.
23:42:40 <skew> oh, that wouter
23:43:06 <shapr> Oh, you thought Aardappel.
23:43:12 <skew> yes
23:43:32 <shapr> I could ask him for an outside perspective on Haskell.
23:43:43 <skew> oh, I need to remember to look at that stuff some more. I think I figured out how STM solves the locking problems with the concurrent tree reduction stuff
23:44:12 <shapr> Oh, you were prototyping Aardappel in Haskell, yeah?
23:44:32 <skew> I'm planning to
23:44:45 <skew> I started by trying to figure out how to do the tree stuff
23:46:44 <skew> Well, I started writing some stuff, then realized that concurrent tree reduction was going to be complicated
23:46:47 <Gahhh> STM = ?
23:46:58 <skew> the concurrenct stuff
23:47:16 <skew> memory-only transactions
23:48:22 <Lemmih> Software Transactional Memory.
23:49:43 <skew> it's a monad that gives you mutable variables, where you can execute an action atomically
23:51:17 <Gahhh> sounds neat
23:52:14 <skew> I think it solves all the headaches of coding with locks
23:54:25 <shapr> It's like lazy evaluation applied to concurrency.
23:54:56 <skew> better, it's like compositionality for concurrency
23:55:13 <shapr> Yeah, that's more important.
23:55:18 <Gahhh> well, the problem with coding with locks is the manual management of stuff, yes ? I have written very little MT stuff.
23:56:20 <skew> yeah, it's not easy to write code that deals with several data structures correctly
23:56:28 <dons> yeah.
23:56:33 <shapr> g'day dons
23:56:37 <dons> hey shapr.
23:56:48 <Gahhh> so if this looks and works like a monad, then everybody can write threadsafe code without even knowing it.
23:56:56 <skew> also, you can't convert between testing for a condition and blocking until it holds with locks
23:57:01 <wilx> Must be pita in languages without well defined destructor semantics :)
23:57:45 <skew> it's trivial under STM
23:58:06 <skew> Gahhh: pretty much
23:58:17 <Gahhh> dons: there's a blog site clevercs.org at unsw.edu.au. Do you have something to do with it ?
23:58:26 <shapr> I was wondering that myself.
23:58:36 <shapr> I just found clevercs yesterday.
23:58:42 <blackdog> Gahhh: it's amir michail's baby
23:58:47 <skew> you wrap an STM action in "atomic" to run it in IO, and the system guarantees that everything will eventually get done
23:58:49 <dons> nothing to do with me.
23:59:06 <dons> but it does have interesting links occaisionally. like the cs paper generator
23:59:16 <dons> @spell occaisionally
23:59:16 <skew> so we have all freedom to write easy and horribly inefficient code that we love in other domains
23:59:18 <lambdabot> occasionally occasional vocationally occupationally locationally
23:59:18 <lambdabot> occasions occasion
23:59:51 <dons> oc-casio-nally
