00:00:38 <musasabi> Itkovian: it has at least some CSE, but making the sharing explicit is usually good.
00:01:02 <Itkovian> Well, I'm just vreading boegel's thesis.
00:01:18 <musasabi> CSE is a gamble in haskell - sometimes it is a performance boost, but it kills of deforestation.
00:01:33 <Itkovian> ok
00:01:50 <musasabi> but lecture =>
00:35:03 * boegel greets
00:37:40 <Itkovian> hi boegel
00:56:26 * boegel shivers
01:00:18 * boegel points Itkovian to PM
01:05:59 <[TWiSTED]> hi anyone here to help with out with a haskell problem
01:06:48 <[TWiSTED]> help me out rather
01:12:14 <Cale> If you ask it and wait, there will probably be a response... I have to sleep
01:12:26 <Cale> but if it's real quick, I might be able to say something :)
01:12:40 <[TWiSTED]> hehe ok
01:14:08 <[TWiSTED]> well basically ive gotta create a function where it inputs a String and returns a tuple (String, Int) in which the user will enter a string containing both letters and numbers (eg. Hello123) and so it will output ("Hello",123)
01:15:34 <Cale> have a look at the prelude function "break"
01:15:43 <Cale> as well as "isDigit" from the Char module
01:16:18 <Cale> you'll also need "read" to turn a string of digits into a number
01:16:25 <[TWiSTED]> ok
01:28:42 <[TWiSTED]> u can convert a list into a string ye?
01:29:06 <[TWiSTED]> so like ['h','e','l','l','o'] = "hello"
01:29:31 * integral mentions: type String = [Char]...
01:30:31 <[TWiSTED]> yeh a string is a list of chars?
01:30:38 <jaap> yep
01:30:45 <boegel> [TWiSTED]: yes
01:31:41 <[TWiSTED]> so would this work
01:32:19 <[TWiSTED]> type AtomCount = (String, Int)
01:32:19 <[TWiSTED]> parseElement :: String -> AtomCount
01:32:19 <[TWiSTED]> parseElement s = ( [x | x <- ['a' ..], x == s], [y | y <- [0 ..]], y == s] )
01:33:47 <[TWiSTED]> kinda trying to make it do "grab the letters from a list of a to z where x is equal ot the letters in s, and grab the numbers from a list of 0 to infinity where y is equal to the numbers in s
01:34:31 <boegel> [TWiSTED]: is the first part always letters and the second part always numbers ?
01:34:38 <[TWiSTED]> yep
01:34:45 <lispy> is that typed correctly?
01:35:02 <lispy> x == s, but x is a Char and S is [Char]
01:35:09 <boegel> [TWiSTED]: then you might take a look at isDigit or something like that
01:35:13 <boegel> @type split
01:35:34 <boegel> no lambdabot today ?
01:35:36 <[TWiSTED]> yeh im abit confused as to what it should be
01:36:13 <[TWiSTED]> so is it possible to make x of data type [Char]
01:36:16 <[TWiSTED]> so that it matches
01:36:30 <lispy> [x] == s
01:36:35 <[TWiSTED]> oo ok
01:36:37 <[TWiSTED]> cool
01:36:38 <[TWiSTED]> ta
01:36:39 <lispy> but that won't do what you expect
01:36:44 <[TWiSTED]> o
01:36:44 * integral wonders what an AtomCount is
01:36:53 <[TWiSTED]> type AtomCount = (String, Int)
01:37:39 <lispy> in your code x <- ['a'..], so x = a, b, c, d, e, ... and then you compare x with the whole string s
01:37:52 <[TWiSTED]> the whole thing is so like if u type parseElement "Fe4" itll store it as ("Fe",4)
01:38:06 <lispy> so you are doing a bunch of comparisons like 'a' == "Hello123", 'b' == "Hello123"
01:38:20 <[TWiSTED]> m
01:38:23 <[TWiSTED]> ok
01:39:25 <[TWiSTED]> im confused hehe
01:39:27 <lispy> what about looking at the elements of s and taking any which are alphabetic characters UNTIL you hit a digit
01:39:28 <Lemmih> [TWiSTED]: You should really look at 'break', 'isDigit' and 'read' as Cale said.
01:39:53 <[TWiSTED]> ok
01:40:51 <lispy> [TWiSTED]: http://www.zvon.org/other/haskell/Outputprelude/break_f.html
01:41:31 <lispy> [TWiSTED]: that first example should look pretty helpful ;)
01:41:39 <[TWiSTED]> ah ok
01:41:55 <lispy> except don't use (3==), i'd replace that with isDigit
01:41:56 <[TWiSTED]> but how do i make it break it when it hits any integer
01:42:00 <[TWiSTED]> o right
01:42:33 <[TWiSTED]> so like
01:42:33 <[TWiSTED]> parseElement s = break (isDigit ==) s
01:43:05 <lispy> [TWiSTED]: what would (isDigit ==) do?
01:43:18 <[TWiSTED]> o
01:43:20 <lispy> [TWiSTED]: check the types of those functions
01:43:21 <[TWiSTED]> return a bool
01:44:18 <lispy> what is the type signature of isDigit?
01:44:39 <[TWiSTED]> ([a],[a]) ?
01:45:07 <lispy> [TWiSTED]: you should look it up
01:45:07 <boegel> Char -> Bool
01:45:11 <boegel> or something like that
01:45:14 <Lemmih> Where's lamdabot when you need her?
01:45:20 <boegel> Lemmih: yeah
01:45:24 <boegel> the bitch
01:45:31 <[TWiSTED]> o rite yea
01:46:04 <lispy> [TWiSTED]: isDigit :: Char -> Bool, is the function (==) of type Char?
01:46:48 <[TWiSTED]> ah nah
01:46:52 <[TWiSTED]> its bool
01:46:56 <[TWiSTED]> isnt it
01:47:04 <lispy> [TWiSTED]: look it up
01:47:51 <[TWiSTED]> yeh its bool cos == is used to compare two values and return true or false whether or not their equal
01:48:14 <jaap> but what is the type of isDigit ?
01:48:26 <[TWiSTED]> Char
01:48:35 <lispy> [TWiSTED]: not, exactly, if it was of type Bool it couldn't take arguments
01:48:56 <[TWiSTED]> ye
01:48:57 <[TWiSTED]> ok
01:48:59 <lispy> the arrow -> is important
01:49:30 <lispy> anyway, isDigit can't take (==) as an argument because the types don't match
01:49:47 <lispy> isDigit is looking for a Char, so how can you use break to give isDigit a Char?
01:49:50 * Lemmih looks as JaffaCake.
01:49:50 <[TWiSTED]> ah ok
01:50:01 <Lemmih> *at JaffaCake.
01:50:07 <JaffaCake> morning ;)
01:50:19 <[TWiSTED]> umm
01:50:43 <lispy> [TWiSTED]: take a good look at the type signature of break that might help
01:51:15 <[TWiSTED]> not exactly sure what u mean by 'type signature'
01:51:22 <Lemmih> I've been wondering if I should go dig some tech docs or annoy a GHC guru.
01:51:47 <lispy> [TWiSTED]: do you see the line in the table that says "Type:"
01:51:56 <lispy> [TWiSTED]: that line gives what we call a type signature
01:52:03 <[TWiSTED]> ah ok
01:52:17 <[TWiSTED]> yeh so its (a -> Bool) -> [a] -> ([a],[a])
01:52:19 <JaffaCake> Lemmih: what's the problem?
01:52:31 <lispy> [TWiSTED]: right, do you know what a means here?
01:52:47 <lispy> [TWiSTED]: that it's a type variable, that can be substituted for any type
01:53:21 <[TWiSTED]> yep
01:53:32 <lispy> [TWiSTED]: in our case a is being replaced by Char, so for this example it becomes (Char -> Bool) -> String -> (String, String)
01:53:54 <[TWiSTED]> ahh yep
01:54:03 <lispy> and hey look, isDigit :: Char -> Bool
01:54:20 * JaffaCake is wondering whether to write a plugin for Google Desktop Search to index Haskell files
01:54:20 <[TWiSTED]> o
01:54:57 <Lemmih> JaffaCake: I want to look at profiling data for modules loaded with hs-plugins. Not really important now... will bug you later if I run into trouble.
01:55:10 <[TWiSTED]> so like
01:55:12 <[TWiSTED]> it can be
01:55:13 <JaffaCake> ok
01:55:26 <[TWiSTED]> um
01:55:44 <lispy> [TWiSTED]: which haskell environment do you use?
01:55:56 <[TWiSTED]> hugs?
01:55:59 <[TWiSTED]> hugs 98
01:56:20 <lispy> okay, there should be a command that lets you check the types of expressions
01:56:28 <lispy> maybe @type
01:56:54 <[TWiSTED]> ok
01:57:08 <[TWiSTED]> just type that in the prelude?
01:57:21 <[TWiSTED]> cos it says an error
01:57:25 <lispy> you mean the prompt that says prelude?
01:57:31 <[TWiSTED]> yeh
01:57:41 <lispy> ah, try :type
01:57:52 <[TWiSTED]> same again
01:57:59 <lispy> :type isDigit
01:58:03 <[TWiSTED]> ok
01:58:07 <lispy> i just tried that in hugs and it works
01:58:10 <[TWiSTED]> yep
01:58:18 <[TWiSTED]> isDigit :: Char -> Bool
01:58:43 <lispy> right, so now using the string "Hello123" how would you use break and isDigit?
01:59:17 <[TWiSTED]> ok
02:00:23 <[TWiSTED]> break isDigit "Hello123"
02:01:03 <lispy> right
02:01:29 <[TWiSTED]> that works fine
02:01:39 <[TWiSTED]> but not when i have the parseElement :: String -> AtomCount definition
02:01:58 <lispy> take a close look at the return value
02:02:08 <lispy> notice that the number part still has quotes
02:02:14 <[TWiSTED]> yep
02:02:31 <lispy> so you have to use read to convert it a number
02:02:40 <[TWiSTED]> ah ok
02:02:56 <lispy> are you familiar with where?
02:02:56 <[TWiSTED]> how do i do that when i only want it done to the number
02:02:59 <[TWiSTED]> not the text
02:03:07 <[TWiSTED]> not the string rather
02:04:11 <[TWiSTED]> yeh not sure about that
02:04:30 <lispy> have you seen things like foo x = y where y = bar x
02:04:43 <lispy> usually it's on the next line
02:04:47 <lispy> foo x = y
02:04:52 <lispy>        where y = bar x
02:04:55 <[TWiSTED]> yea
02:04:59 <[TWiSTED]> that looks familiar
02:05:10 <lispy> you can use the where to be able to do pattern matching
02:05:12 <[TWiSTED]> what does 'bar' do
02:05:22 <[TWiSTED]> ok
02:05:23 <lispy> foo and bar are just example functions
02:05:28 <[TWiSTED]> ah ok
02:05:48 <lispy> parseElement s = (s, read i)
02:06:04 <lispy> now add a where so thta s and i are what you need them to be
02:06:14 <lispy> oh my bad
02:06:25 <lispy> parseElement s = (s', read i)
02:06:34 <[TWiSTED]> o
02:06:54 <lispy> do you know what the where should be?
02:06:57 <[TWiSTED]> where s' = break isDigit s
02:07:00 <[TWiSTED]> ?
02:07:03 <lispy> close
02:07:06 <lispy> use pattern matching
02:07:16 <lispy> break will return a tuple and you want the first and second part
02:07:25 <[TWiSTED]> yep
02:07:31 <lispy> where (s', i) = break isDigit s
02:07:48 <[TWiSTED]> ooo
02:08:07 <[TWiSTED]> omg awesome
02:08:09 <[TWiSTED]> it works
02:08:12 <mauke> hmm, I'd have used a let there
02:08:13 <[TWiSTED]> thanks heaps
02:08:32 <mauke> parseElement s = let (a, b) = break isDigit s in (a, read b)
02:08:34 <lispy> mauke: i like where because it looks simpler to me :)
02:09:01 <lispy> [TWiSTED]: np, and remember to check the types of expressions
02:09:09 <lispy> [TWiSTED]: that can save a lot of work
02:09:28 <[TWiSTED]> hehe ye
02:09:33 <[TWiSTED]> o wait
02:09:35 <[TWiSTED]> one more thing
02:09:59 <[TWiSTED]> theres meant to be where theres no integer, it should store 1
02:10:37 <[TWiSTED]> so parseElement "C" = ("C",1)
02:10:46 <jaap> then instead of read, write a function that does *that*
02:10:48 <jaap> and call it
02:11:22 <[TWiSTED]> ok
02:11:51 <lispy> the easy way to follow jaap's advice is to use pattern matching to detect your special case, and in the regular case to call read
02:12:03 <lispy> if that makes sense
02:12:52 <[TWiSTED]> sort of
02:13:40 <lispy> to see what i mean, try break isDigit "Hello"
02:14:05 <[TWiSTED]> actually
02:14:12 <[TWiSTED]> i used another function i did before
02:14:21 <lispy> ah, that works
02:14:21 <[TWiSTED]> they tell us to use it :/
02:14:27 <[TWiSTED]> parseNumber :: String -> Int
02:14:27 <[TWiSTED]> -- pre: s is null or represents an integer greater than 0
02:14:27 <[TWiSTED]> -- parseNumber s returns 1 if s is null or the number is equivalent of s
02:14:27 <[TWiSTED]> parseNumber s | s == "" = 1
02:14:27 <[TWiSTED]>               | otherwise = read s
02:14:43 <[TWiSTED]> so instead of read i, i just wrote parseNumber i
02:14:58 <[TWiSTED]> awesome
02:15:01 <lispy> parseNumber [] = 1
02:15:12 <lispy> parseNumber s = read s
02:15:18 <lispy> that's another way to define the same function
02:15:27 <mauke> or parseNumber "" = 1
02:15:36 <[TWiSTED]> ahh ok
02:16:24 <lispy> [TWiSTED]: good luck, i'm off to sleep
02:16:59 <[TWiSTED]> cheers
02:17:01 <[TWiSTED]> thanks for all ya help
02:17:20 <lispy> np, i hope you enjoy functional programming
02:17:42 <[TWiSTED]> hehe not really, i prefer java or c++
02:17:43 <[TWiSTED]> haha
02:18:00 <[TWiSTED]> pretty annoyed i have to do this actually
02:18:06 <wilx`> :)
02:18:07 <[TWiSTED]> cos java seems so much easier
02:18:22 <mauke> java is also retarded
02:18:38 <[TWiSTED]> haha
02:19:44 <[TWiSTED]> fuk the other problems i have to do are alot harder haha
02:22:29 <jaap> basic haskell is'nt really *that* hard; it's just that you have to not assume you can do without carefully reading an introduction just because you already know imperative programming; the most common problem for people who have programmed before is that they fail to go slowly at first
02:22:45 <jaap> just get a copy of a Gentle Intro from the net and actually read it, you'll be fine
02:22:47 <[TWiSTED]> yea thats true
02:23:25 <[TWiSTED]> cos when i try program in haskell i just think 'why the fuk cant i just use if and for statements'
02:23:25 <[TWiSTED]> aha
02:23:45 <mauke> you can use if
02:23:49 <jaap> well, lemme tell you a story
02:23:59 <jaap> here at my college they teach Scheme to freshman
02:24:09 <jaap> Scheme is a functional language, like Haskell, but without the types
02:24:15 <jaap> and second term, they teach Java
02:24:26 <[TWiSTED]> ye
02:24:28 <jaap> this year, at least one freshman asked me:
02:24:33 <jaap> how do you do lambda in Java?
02:24:37 <mauke> hahaha
02:25:04 <jaap> he was very upset when I told him he had to use an inner class here and a method there and then maybe he could kind of fake it
02:25:13 <jaap> so once more, it's all a matter of perspective
02:25:31 <[TWiSTED]> yea
02:25:36 <mauke> "oh, just write a class with an overloaded operator(), except you can't overload operators, so uh ..."
03:11:28 <Itkovian> ;-)
04:39:33 <[TWiSTED]> how would i compare a list of tuples with the first element of the tuple and if they match, add the values of the second element of the tuple
04:40:35 <mauke> huh? what's the type of this operation?
04:40:51 <[TWiSTED]> ie [("a",2) , ("a",4) , ("b",5) , ("c",6)] = [("a",6) , ("b",5) , ("c",6"]
04:41:58 <musasabi> [TWiSTED]: sortBy + groupBy + map
04:42:11 <[TWiSTED]> oo
04:43:02 <[TWiSTED]> what do i have to import so that sortBy works?
04:43:24 <musasabi> Data.List
04:43:27 <[TWiSTED]> thx
04:45:44 <kzm> as Haskell allows almost arbitrary infix operators, perhaps the tagline could read "we put the punk in punctuation"?
04:45:53 <kzm> (sorry - silly pun.  Too much coffee)
04:46:03 <[TWiSTED]> haha
04:47:01 <kzm> Thanks.  You're too kind :-)
04:47:06 <kzm> Any Haskell talk here?
04:47:07 <[TWiSTED]> hehehe
04:47:32 <[TWiSTED]> musasabi: would u be able to help me out with what u mean by sortBy + groupBy + map
04:47:35 <[TWiSTED]> yea there is abit
04:50:18 <mauke> if your input list looked like this: [[("a", 2), ("a", 4)], [("b", 5)], [("c", 3), ("c", 3)]], would you know how to do it?
04:50:49 <[TWiSTED]> umm
04:51:20 <[TWiSTED]> hehe id know what the outcome would be
04:51:56 <nlv11757_> i think i might be trying a too brute force approach and advice is welcome; i have a map where identifiers are associated with some set of values by means of a Map. Now identifiers also depent on other identifiers....i want to calculate the final set of values for every identifier....thus doing fixed point. Im thinking to rewrite the sets acoording to the dependencies.....
04:52:05 <nlv11757_> until a least fixed point is arrived
04:56:08 <musasabi> [TWiSTED]: you first want to sort the list to have pairs with the same first component adjacent to each other. for that use sortBy - (or even plain sort is enough)
04:56:18 <nlv11757_> [TWiSTED], to do what you want to do, you need to group every tuple with the same first element, this is done using groupBy....but since groupBy only groups elements in sequence of eachother, you have to first sort it
04:56:43 <nlv11757_> then when you have all those things grouped, you can apply an accummulating function by using map
04:56:45 <musasabi> [TWiSTED]: When you have them in the correct order you use groupBy to group the tuples with the same first element into sublists.
04:57:04 <[TWiSTED]> wait one says use sortby first the other says groupby first
04:57:16 <nlv11757_> you didnt read my complete comment
04:57:28 <[TWiSTED]> o yep
04:57:29 <[TWiSTED]> my bad
04:57:34 <nlv11757_> i first explained the meaning of groupby, so you'd understand why you need sortby
04:57:42 <[TWiSTED]> yep
04:57:44 <[TWiSTED]> ehe soz
04:57:47 <nlv11757_> np
04:57:50 <musasabi> nlv11757_: your problem sounds like type inference - and there is quite a lot of works in doing that in a fast way.
04:58:45 <nlv11757_> yeah i realize its exactly the same basically, thats why i asked if anyone here could give me a few pointers
04:59:05 <nlv11757_> bound to be some type inference peeps here i thought :D
04:59:39 <musasabi> nlv11757_: most people end up using mutable references behind the scenes.
05:00:01 <musasabi> nlv11757_: that and remembering to shorten the chains help a long way.
05:01:52 <nlv11757_> not doing the actual rewriting by using mutable references?
05:02:41 <musasabi> hmm?
05:02:55 <nlv11757_> i was wondering about the role of the mutable references
05:04:24 <[TWiSTED]> ok i got sortBy working
05:06:55 <nlv11757_> i think the grammar analysis problem of reachability is in essence the same to mine, i'll search for efficient solutions to that problem
05:07:18 <[TWiSTED]> how do you indentify the 'first element' of a tuple
05:07:36 <dons> @type fst
05:07:39 <mauke> pattern matching or fst
05:07:43 <[TWiSTED]> o ok
05:07:45 <[TWiSTED]> thx
05:09:54 <[TWiSTED]> type AtomCount = (String, Int)
05:09:54 <[TWiSTED]> type AtomCounts = [AtomCount]
05:09:54 <[TWiSTED]> combine :: AtomCounts -> AtomCounts
05:09:54 <[TWiSTED]> combine xs = groupBy (== fst) sortBy compare xs
05:10:01 <[TWiSTED]> does that sorta make sense
05:10:21 <mauke> looks like a type error
05:10:32 <[TWiSTED]> yeh ur right
05:13:55 <musasabi> @type (\xs -> groupBy (== . fst) $ sort xs)
05:14:01 <lambdabot> bzzt
05:14:22 <musasabi> make that groupBy (\a b -> fst a == fst b)
05:14:54 <[TWiSTED]> what does the \ mean
05:15:47 <musasabi> lambda
05:16:01 <[TWiSTED]> lambda?
05:16:05 <[TWiSTED]> ehe what does that mean
05:16:23 <musasabi> an anonymous function.
05:16:29 <[TWiSTED]> o ok
05:17:01 <[TWiSTED]> so i got
05:17:01 <[TWiSTED]> combine xs = groupBy (\a b -> fst a == fst b) (sortBy compare xs)
05:17:04 <mauke> @pl \(s, i) -> (s, sum i)
05:17:06 <lambdabot> second sum
05:17:10 <mauke> huhu
05:17:30 <mauke> @type second
05:17:32 <lambdabot> bzzt
05:18:37 <mauke> @pl \a b -> fst a == fst b)
05:18:38 <lambdabot> (line 1, column 23):
05:18:38 <lambdabot> unexpected ")"
05:18:38 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">",
05:18:38 <lambdabot> "`elem`", "`notElem`" or end of input
05:18:42 <mauke> @pl \a b -> fst a == fst b
05:18:43 <lambdabot> (. fst) . (==) . fst
05:19:11 <mauke> hmm, not bad
05:20:15 <[TWiSTED]> what does that all mean
05:20:52 <mauke> what do you mean by "all"?
05:21:25 <[TWiSTED]> o actually ur just testing the code
05:21:39 <nlv11757_> owww lambdabot extension
05:21:56 <nlv11757_> @help plugs
05:21:56 <lambdabot>  @plugs <expr>
05:21:56 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
05:22:11 <nlv11757_> abbreviated @pl
05:22:17 <nlv11757_> uuuh
05:22:22 <nlv11757_> pl is pointless
05:22:23 <nlv11757_> sry
05:22:26 <nlv11757_> @help pl
05:22:27 <lambdabot>  @pointless <expr> - play with pointfree code
05:22:49 <nlv11757_> it produces pointless code; i.e. not using named parameters
05:23:42 <mauke> I @pl'd (\a b -> fst a == fst b) by hand first, and my result was flip (.) fst . ((==) . fst)
05:25:17 <nlv11757_> probably with more parenthesis than that
05:26:13 <mauke> why more parentheses?
05:26:37 <Philippa> nlv11757_: the technical term is "point-free" :-)
05:26:57 <nlv11757_> i always was a star at technical terms
05:29:31 <nlv11757_> mauke its fine i forgot to realize ofcourse . binded weak there
05:29:47 <nlv11757_> but your flip is not necessary because (. fst) is the same
05:29:54 <mauke> yep
05:30:07 <Philippa> nlv11757_: pointless is what people who, er, didn't see the point started calling it
05:30:23 <mauke> I'm not that used to sections yet
05:30:39 <[TWiSTED]> anyone able to help me fix this : combine xs = groupBy (\a b -> fst a == fst b) (sortBy compare xs)
05:31:12 <nlv11757_> sortBy compare can be safely replaced by just sort since i think you are using the standard compare
05:31:29 <[TWiSTED]> ok
05:31:41 <nlv11757_> you already saw the pointless (;-P) version of the anonymous function....
05:32:07 <nlv11757_> so now you need to further process the outcomings of groupBy
05:32:52 <nlv11757_> @type groupBy
05:32:54 <lambdabot> bzzt
05:32:58 <nlv11757_> @type List.groupBy
05:32:59 <lambdabot> List.groupBy :: forall a. (a -> a -> Bool) -> [a] -> [[a]]
05:33:07 <mauke> @pl \l@((s, _) : _) -> (s, map snd l)
05:33:08 <lambdabot> (line 1, column 3):
05:33:08 <lambdabot> unexpected "@"
05:33:08 <lambdabot> expecting letter or digit, operator, pattern or "->"
05:36:32 <[TWiSTED]> hm ok
05:37:08 <[TWiSTED]> its returning [[(String, Int)]] but i just want [(String, Int)]
05:39:10 <musasabi> [TWiSTED]: that is why you have to do the final step - map.
05:39:27 <[TWiSTED]> oo
05:39:53 <nlv11757_> soh worklist algorithm
05:40:25 <nlv11757_> to fold each sublist by accumulating the right-hand-sides
05:42:20 <[TWiSTED]> how do you indentify the '2nd element' of a tuple
05:42:27 <[TWiSTED]> lst ?
05:42:31 <nlv11757_> snd
05:42:33 <[TWiSTED]> o ok
05:42:34 <[TWiSTED]> thx
05:42:49 <nlv11757_> @pl \(x, y) -> (head x, sum y)
05:42:50 <lambdabot> head *** sum
05:42:54 <nlv11757_> ahh
05:43:00 <nlv11757_> beautifull
05:43:16 <nlv11757_> map (head *** sum . unzip)
05:43:24 <[TWiSTED]> given combine xs = (groupBy (\a b -> fst a == fst b) (sort xs)
05:43:30 <[TWiSTED]> would map (snd a + snd b) make sense ?
05:43:46 <jaap> no
05:43:52 <nlv11757_> a and b only exist within the anonymous function
05:43:53 <nlv11757_> so no
05:43:57 <[TWiSTED]> o ok
05:44:30 <nlv11757_> @plugs map (head *** sum . unzip) [[("a",2) , ("a",4)] , [("b",5) , ("c",6)]]
05:44:34 <lambdabot> Couldn't match `[a]' against `([a1], [b])'
05:45:17 <nlv11757_> @plugs map ((head *** sum) . unzip) [[("a",2) , ("a",4)] , [("b",5) , ("c",6)]]
05:45:19 <lambdabot> [("a",6),("b",11)]
05:45:25 <nlv11757_> wazaap
05:45:36 <[TWiSTED]> o wow
05:45:56 <mauke> @plugs map (\l@((s, _) : _) -> (s, sum (map snd l))) [[("a",2) , ("a",4)], [("b",5)], [("c",6)]]
05:45:59 <lambdabot> [("a",6),("b",5),("c",6)]
05:46:11 <[TWiSTED]> what is *** ?
05:46:14 <nlv11757_> @type Control.Arrow.(***)
05:46:16 <lambdabot> bzzt
05:46:24 <nlv11757_> @type (***)
05:46:26 <lambdabot> bzzt
05:46:31 <mauke> @type (Control.Arrow.***)
05:46:33 <nlv11757_> @type Control.Arrow.***
05:46:33 <lambdabot> (Control.Arrow.***) :: forall (a :: * -> * -> *) c' c b' b.
05:46:33 <lambdabot>         (Control.Arrow.Arrow a) =>
05:46:33 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
05:46:34 <lambdabot> bzzt
05:46:39 <nlv11757_> ah there it is
05:47:22 <nlv11757_> basically, you feed it two functions, and it applies each of them to its own part of the tuple
05:47:45 <nlv11757_> @plugs unzip [("a",2) , ("a",4)]
05:47:47 <lambdabot> (["a","a"],[2,4])
05:47:56 <nlv11757_> the first list you just want to take the head
05:48:00 <nlv11757_> the second you want to sum
05:48:13 <nlv11757_> so
05:48:17 <[TWiSTED]> o ok
05:48:26 <nlv11757_> @plugs (head ** sum . unzip)  [("a",2) , ("a",4)]
05:48:27 <lambdabot> Couldn't match `[a]' against `([a1], [b])'
05:48:29 <[TWiSTED]> the head is just the first element tho yea?
05:48:31 <nlv11757_> ow oops
05:48:34 <nlv11757_> yeah
05:48:38 <[TWiSTED]> ah ok
05:48:39 <nlv11757_> so it takes the first "a"
05:48:40 <jaap> the first element of a _list_
05:48:42 <nlv11757_> which is good enough
05:48:49 <[TWiSTED]> yeh
05:48:52 <mauke> my \l@((s, _) : _) -> (s, map snd l) does essentially the same
05:49:05 <nlv11757_> but doesnt look nearly as readable imho mauke :D
05:49:05 <mauke> except it uses pattern matching to extract the name
05:49:20 <[TWiSTED]> but i need to make it take the whole string
05:49:30 <nlv11757_> define 'whole'
05:49:32 <mauke> well, I have no idea what arrows are so I prefer my own solution :-)
05:49:34 <nlv11757_> what is whole here?
05:49:44 <[TWiSTED]> like
05:49:54 <[TWiSTED]> [("abcd",2)]
05:50:03 <[TWiSTED]> ur code would just take "a" right?
05:50:08 <mauke> no, why?
05:50:13 <[TWiSTED]> cos of head
05:50:21 <nlv11757_> @plugs unzip [("abcd",2), ("abcd", 3)]
05:50:23 <lambdabot> (["abcd","abcd"],[2,3])
05:50:32 <mauke> @plugs head ["abcd","abcd"]
05:50:34 <lambdabot> "abcd"
05:50:38 <nlv11757_> there you go
05:50:41 <[TWiSTED]> o i see
05:50:52 <nlv11757_> unzip gathers all left hand sides and right hand sides
05:51:00 <nlv11757_> you only need one left hand side
05:51:02 <nlv11757_> so take the first
05:51:05 <[TWiSTED]> o ok
05:51:06 <[TWiSTED]> yep
05:51:16 <[TWiSTED]> is there another function that does what *** does?
05:51:40 <mauke> why?
05:51:50 <[TWiSTED]> it doesnt seem to work
05:51:54 <[TWiSTED]> but ive probably done it wrong
05:51:59 <nlv11757_> you need to import Control.Arrows
05:52:02 <nlv11757_> in your program
05:52:11 <[TWiSTED]> yeh did that
05:52:24 <nlv11757_> so what did it say then?
05:52:27 <[TWiSTED]> actually *** is fine, theres no error with that
05:52:32 <nlv11757_> ok
05:52:52 <[TWiSTED]> "type error in explicitly typed binding"
05:53:04 <nlv11757_> that thing alone doesnt tell me anything :)
05:53:08 <nlv11757_> or not enough anyhow
05:53:09 <[TWiSTED]> hehe
05:53:16 <[TWiSTED]> ok
05:53:22 <[TWiSTED]> it also says
05:53:27 <[TWiSTED]> *** term : combine
05:53:52 <[TWiSTED]> *** type : AtomCounts -> [[(a,b)]] -> [(a,b)]
05:54:03 <[TWiSTED]> *** does not match : AtomCounts -> AtomCounts
05:54:12 <[TWiSTED]> so basiaclly data mismatch?
05:54:13 <nlv11757_> show the complete definition of your function
05:54:20 <mauke> missing map?
05:54:26 <[TWiSTED]> combine :: AtomCounts -> AtomCounts
05:54:26 <[TWiSTED]> -- pre: xs must be sorted in increasing order of element symbol
05:54:26 <[TWiSTED]> -- combine xs returns xs with the atom-count of adjacent elements with
05:54:26 <[TWiSTED]> -- the same elemental symbol added together. The resultant list
05:54:26 <[TWiSTED]> -- contains no duplicated elements and remains sorted.
05:54:26 <[TWiSTED]> combine xs = map ((head *** sum) . unzip)
05:54:30 <nlv11757_> probably you forgot to put the unzip inside the mapped function
05:54:33 <[TWiSTED]> where
05:54:42 <[TWiSTED]> type AtomCount = (String, Int)
05:54:46 <mauke> oh, heh
05:54:55 <[TWiSTED]> and type AtomCounts = [AtomCount]
05:55:07 <nlv11757_> where did the groupby stuff go [TWiSTED]
05:55:08 <nlv11757_> ?
05:55:09 <mauke> and where's the sort/groupBy part?
05:55:22 <[TWiSTED]> o
05:55:38 <[TWiSTED]> does it go after the map?
05:55:41 <nlv11757_> 'map ((head *** sum) . unzip)' only meant to process what groupby produced
05:55:59 <[TWiSTED]> ah ok
05:57:29 <[TWiSTED]> fuk so how does it all fit in
05:57:34 <[TWiSTED]> combine xs = map ((head *** sum) . unzip) (groupBy (\a b -> fst a == fst b)) (sort xs)
05:58:10 <mauke> missing parentheses
05:58:17 <nlv11757_> @pl \xs -> map ((head *** sum) . unzip) ((groupBy (\a b -> fst a == fst b)) (sort xs))
05:58:18 <lambdabot> map ((head *** sum) . unzip) . groupBy ((. fst) . (==) . fst) .
05:58:18 <lambdabot> sort
05:58:30 <mauke> you're trying to apply map to three arguments instead of two
05:58:42 <[TWiSTED]> o ok
05:59:12 <nlv11757_> @plugs map ((head *** sum) . unzip) . groupBy ((. fst) . (==) . fst) . sort $ [("a",2) , ("a",4) , ("b",5) , ("c",6)]
05:59:14 <lambdabot> [("a",6),("b",5),("c",6)]
05:59:37 <nlv11757_> combine = map ((head *** sum) . unzip) . groupBy ((. fst) . (==) . fst) . sort
06:00:17 <[TWiSTED]> awesome
06:00:19 <[TWiSTED]> it works
06:00:21 <[TWiSTED]> thanks heaps
06:02:27 <nlv11757_> anyone has an efficient worklist algorithm lying around ?
06:02:45 <tromp> what's that?
06:02:55 <nlv11757_> for doing fixed point calculation
06:03:02 <nlv11757_> iteratively
06:03:15 <jaap> it's used a lot in register allocators, iirc
06:03:29 <nlv11757_> dataflow analysis
06:03:35 <nlv11757_> also
06:03:36 <jaap> I wrote one in ML recently, but it was full of mutable cells
06:03:52 <jaap> it was for a class, that how they made us do it
06:04:00 <jaap> no idea how you could do that prettily
06:04:15 <nlv11757_> yeah thats why i was hoping anyone here wrote one using mutable references so i dont have to do it :D
06:05:29 <nlv11757_> what was the main use for the mutable cells in your ML version jaap?
06:13:44 <jaap> it was a straightforward way of doing the imperative thing you'd find in a textbook and not worrying too hard
06:14:37 <jaap> i just looked at it and realized that the other guy did most of the worklist stuff, so i don't think i understand it any better than you -- sorry
06:14:55 <Philippa> there's a lot of stuff where you want a controlled amount of mutability - I've lost count of the number of ST-wrapper monads I've written
06:22:41 <nlv11757_> doesnt sound that attractive no
06:24:22 <[TWiSTED]> how would i go about sorting the tuples with respect to the string
06:24:41 <mauke> sort tuples
06:24:53 <nlv11757_> sort uses standard behaviour for tuples
06:24:58 <[TWiSTED]> o ok
06:25:02 <nlv11757_> sort on first element first then second then etc
06:25:07 <[TWiSTED]> so i can just add sort to the front of that code?
06:25:11 <nlv11757_> as long as it knows how to sort the elements of the tuple
06:25:21 <mauke> of what code?
06:25:27 <nlv11757_> combine = map ((head *** sum) . unzip) . groupBy ((. fst) . (==) . fst) . sort
06:25:30 <nlv11757_> kinda already had sort
06:25:35 <[TWiSTED]> yeh
06:25:35 <mauke> yeah
06:25:44 <nlv11757_> o_0
06:27:04 <[TWiSTED]> wow
06:27:11 <[TWiSTED]> reorder as = sortBy compare (combine as)
06:27:14 <[TWiSTED]> seems to work
06:27:20 <[TWiSTED]> where combine xs = map ((head *** sum) . unzip)
06:27:20 <[TWiSTED]>              ((groupBy (\a b -> fst a == fst b)) (sort xs))
06:27:46 <mauke> huh?
06:27:49 <nlv11757_> [TWiSTED], combine already leaves the thing sorted if im not mistaken
06:27:52 <mauke> why do you want to sort it again?
06:28:16 <[TWiSTED]> to sort the first elements of the tuples
06:28:22 <[TWiSTED]> in alphabetical order
06:28:37 <nlv11757_> but combine already does that
06:28:39 <mauke> but why do you want to sort it AGAIN?
06:29:18 <nlv11757_> and why use sortBy if you're not using a custom compare....
06:29:38 <[TWiSTED]> i dont know but i tested it out and it seems to work ehe :/
06:29:49 <mauke> of course it "works"
06:30:01 <nlv11757_> sort . sort . sort . sort also works
06:30:05 <mauke> that's like defining intToInt i = i
06:30:13 <[TWiSTED]> oo
06:30:16 <[TWiSTED]> hehe ah ok
06:30:18 <mauke> then doing intToInt 2 + intToInt 2 == 4
06:30:24 <nlv11757_> sort . doabsolutely nothing that influences the order . sort
06:30:34 <[TWiSTED]> aha ok ok i get ur point
06:30:42 <nlv11757_> [TWiSTED], know what the code does
06:30:48 <nlv11757_> otherwise it will always seem like magic
06:30:56 <[TWiSTED]> to be honest i dont really understand haskell
06:31:06 <[TWiSTED]> as u can probably tell
06:31:32 <nlv11757_> read a tutorial/primer/introduction
06:32:39 <[TWiSTED]> ok
06:32:41 <musasabi> yet another haskell tutorial is quite good.
06:32:51 <nlv11757_> http://www.cs.uu.nl/people/jeroen/courses/fp-eng.pdf is old but still contains the basis
06:32:58 <nlv11757_> lots of stuff basically
06:33:05 <[TWiSTED]> aite ill check it out
06:33:49 <[TWiSTED]> wow 155 pages
06:34:37 <nlv11757_> it progresses slowly, so you can take a fast pace.
06:34:51 <nlv11757_> its better than having too little pages and wishing they'd explain more imho
06:35:55 <[TWiSTED]> yea true
06:37:32 <nlv11757_> argh why doesnt Data.Set provide a way too take one element out
06:37:42 <nlv11757_> (i dont mean delete but extract one)
06:38:01 <nlv11757_> without doing a conversion to a list or whatever
06:38:54 <Philippa> the list's a more general interface?
06:39:32 <nlv11757_> sure, but why is there no possibility to simply take an element out of the set and return that element along with the smaller set
06:40:08 <nlv11757_> that doesnt sound like some perverted use of a set or does it?
06:41:45 <[TWiSTED]> im off
06:41:47 <nlv11757_> k
06:41:48 <[TWiSTED]> thanks for ya help guys
06:41:50 <[TWiSTED]> cyas
06:42:29 <Philippa> nlv11757_: it's somewhat perverted if you're not specifying the element to remove
06:42:44 <Philippa> because it shouldn't really have deterministic semantics
06:43:12 <nlv11757_> but what if i just want 'an' element, no matter what
06:43:18 <TheHunter> nlv11757_: i've been annoyed by this, too.
06:43:50 <nlv11757_> how did you solve it TheHunter, cause the concept Set perfectly fits what i want....no duplicate elements, no order, etc.
06:43:56 <TheHunter> (you can implement it with unsafeCoerce# ...)
06:44:35 <Philippa> you could make a wrapper function that does toList/fromList
06:45:24 <TheHunter> ime, using lists instead of sets  and occasional nubbing ist often faster than using sets throughout your algorithm.
06:45:27 <nlv11757_> Philippa, that sounds horribly inefficient
06:45:48 <TheHunter> Philippa: it's an O(log n) vs. O(1) issue.
06:46:23 <nlv11757_> fromList is O(n*log n)
06:46:33 <nlv11757_> and toList O(n)
06:47:00 <Philippa> yeah, it sounds like the implementation'd admit a faster "remove from the place that's fastest to remove from" op
06:47:08 <TheHunter> nlv11757_: extracting one element using fromList is O(log n).
06:47:13 <Philippa> but tbh, lists and nubbing if you're doing that so much
06:47:25 <nlv11757_> TheHunter, i use it as a worklist, so i need to nub every use of the worklist
06:47:46 <TheHunter> nlv11757_: oh, you want the smaller set, too
06:47:47 <nlv11757_> @type unsafeCoerce
06:47:48 <lambdabot> bzzt
06:48:02 <TheHunter> i only needed one arbitrary element.
06:48:02 <Philippa> what're the operations that require nubbing? You might be able to find faster implementations of them
06:48:17 <TheHunter> @type GHC.Exts.unsafeCoerce#
06:48:18 <lambdabot> GHC.Exts.unsafeCoerce# :: forall b a. a -> b
06:48:31 <nlv11757_> ok i want to remove one thing of the worklist, do something with it, and add all things to the worklist that are affected....
06:48:59 <TheHunter> @libsrc Data.Set
06:49:00 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Set.hs
06:49:03 <nlv11757_> the algorithm ends when the worklist is empty, so i really want to nub after every addition of new elements in the worklist
06:49:09 <Philippa> sounds like a hashtable might be a better implementation for what you're doing?
06:50:38 <nlv11757_> but inserting is still adding with a hashtable right?
06:51:04 <Philippa> but it has an update op
06:51:09 <Philippa> which does what you want
06:51:19 <nlv11757_> when not present update inserts?
06:51:19 <calvin_> Philippa: asl??
06:51:31 <Philippa> calvin_: 78/sure/your underwear
06:51:40 <calvin_> :x
06:51:54 <nlv11757_> ....
06:52:00 <nlv11757_> what does asl mean in irc land?
06:52:44 <TheHunter> @vixen asl
06:52:46 <lambdabot> 19/f/California
06:52:49 <earthy> 'age sex location'
06:52:53 <TheHunter> there you go calvin_
06:53:03 <nlv11757_> lol
06:53:13 <nlv11757_> the abbreviations irc people have
06:53:17 <calvin_> TheHunter: far out
06:53:34 <earthy> weird, weird.
06:53:34 <nlv11757_> why would you ever want to know that kind of information of anyone
06:53:48 <earthy> what, age, sex and location?
06:53:52 <nlv11757_> yeah
06:53:59 <earthy> sounds pretty relevant if you're looking for a date
06:54:00 <Philippa> you might want into their underwear, for example
06:54:03 <nlv11757_> hahah
06:54:21 <calvin_> nlv11757_: something you might experience one day too!
06:54:30 <nlv11757_> that is *exactly* my point....why would you want to do that through irc
06:54:34 <Philippa> I'm kinda fond of a number of people I first met online
06:54:39 <earthy> nlv11757: why not?
06:54:43 <musasabi> Someone asking asl is a quick way to filter out people you don't want to talk with on some channels.
06:54:58 <earthy> I have good friends that I first met online
06:55:04 <musasabi> People asking asl = people that can be safely ignored.
06:55:10 <nlv11757_> earthy, internet people stay internet people for me.
06:55:19 <earthy> a befriended couple actually met eachother online.
06:55:25 <nlv11757_> im not remotely interested in getting to know internet people
06:55:41 <Philippa> even the ones who're fun to talk to?
06:55:55 <nlv11757_> you got to keep in mind these are internetcontacts
06:55:58 <nlv11757_> big difference
06:56:00 <earthy> I'll close my door next time you're at the uni then. :P
06:56:09 <nlv11757_> hahaha
06:56:10 <Philippa> not much difference at all
06:56:14 <nlv11757_> be my guest earthy
06:56:15 <nlv11757_> :D
06:56:22 <Philippa> sure, often people online're acquaintances rather than friends
06:56:46 <earthy> yeah, that's a difference
06:57:05 <earthy> the net is a good place to meet people, but not so good a place to make friends
06:57:26 <Philippa> depends where you go. One IRC channel I'm on's an offshoot of a community responsible for many marriages let alone friendships
06:57:39 <nlv11757_> meet for me means just dropping a msg once in a while
06:58:02 <earthy> owh... but those didn't marry each other until after having consolidated their online affinity for each other through physical contact, right?
06:58:09 <Philippa> right
06:58:15 <earthy> that's my point, kinda
06:58:42 <nlv11757_> i just dont believe in that meeting through the inet thing
06:58:51 * Philippa shrugs
06:58:56 <earthy> it's very well suited for meeting and getting to know eachother, but strong emotional bonds need more
06:59:22 <nlv11757_> and since i dont believe in it, there's no reason why i should ever let a talk get personal
06:59:27 <Philippa> earthy: depends. I've seen some really strong stuff happen without any face-to-face contact, though usually there're things you can point to that explain it somewhat
06:59:35 <musasabi> Is there a quick predicate that tests that all elements of a list are the same (with ==) ?
06:59:41 <earthy> any
06:59:42 <Philippa> which in turn is the only reason you have to not believe it
06:59:51 <earthy> ;)
07:00:16 <earthy> or all, musasabi
07:00:50 <ndm> musasabi: without respecting order - i.e. so [1,2] == [2,1]
07:00:50 <edwinb> Not quite... foo (x:xs) = all (==x) xs  ?
07:00:58 <nlv11757_> Philippa, i dont feel like missing out so i dont care :)
07:01:24 <musasabi> edwinb: that does it :-)
07:01:44 <Philippa> that's not grounds for insisting nobody else could have a good reason to want to though
07:02:09 <nlv11757_> Philippa, i never said that, everyone should do whatever they see fit
07:02:31 <Philippa> well, you /were/ asking why anybody'd want to...
07:03:03 <nlv11757_> true, but that was because *me* personally cant think of a reason for myself
07:03:19 <earthy> ah, but you see now that there are reasons, right? :)
07:03:32 <nlv11757_> noj, because i dont they are valid for *me* :P
07:03:35 <nlv11757_> -j
07:03:37 <noj> what?
07:03:42 <nlv11757_> i meant to say no
07:03:44 <nlv11757_> :D
07:03:48 <noj> ah, ok :)
07:03:58 <noj> what?
07:04:07 * earthy rolls his eyes ;P
07:04:11 <calvin_> :)
07:04:12 <nlv11757_> noj, because i dont they are valid for *me* :P
07:04:15 <nlv11757_> huh
07:04:21 <nlv11757_> noj, because i dont they are valid for *me* :P
07:04:23 <noj> :)
07:04:25 <nlv11757_> wtf
07:04:35 <nlv11757_>  no, automatically expands to your name
07:04:36 <nlv11757_> lol
07:04:40 <nlv11757_> "no,"
07:04:43 <nlv11757_> no followed by a comma
07:04:47 <nlv11757_> sick
07:04:51 <noj> yeah, morbid
07:05:09 <earthy> you're using one twisted IRC client
07:05:17 <nlv11757_> there, i took care of the abomination
07:05:25 <Philippa> auto-completion's evil
07:06:00 <nlv11757_> im using the Hashtable then....why dont the authors of Data.Set add that functionality for me
07:06:02 <nlv11757_> :)
07:07:06 <Philippa> I guess an existential quantifier'd make sense for it
07:07:20 <TheHunter> do you want to replace the old element with exactly one or arbitrary many new ones?
07:07:37 <Philippa> the latter, AIUI
07:07:42 <TheHunter> s/rary/rarily/
07:07:48 <nlv11757_> ideally, i just want to throw it into the datastructure without causing duplicates
07:07:51 <nlv11757_> i.e. a Set
07:12:07 <nlv11757_> ctcp version o_0
07:12:29 <TheHunter> hope you didn't mind :)
07:13:03 <TheHunter> in my defense, i'm at uni where they only have crappy irc clients
07:13:26 <nlv11757_> hehe
07:13:46 <nlv11757_> as long as it works
07:15:21 <TheHunter> having finally found the configuration panel, i can try to make it look a little bit better, maybe.
07:15:44 <nlv11757_> looks are so overrated :D
07:16:42 <TheHunter> man this thing even has color schemes with fore and background color identical...
07:16:51 <Philippa> what you really /need/ in an IRC client is for it to show you stuff, let you type back and PONG the PINGs for you
07:17:22 <nlv11757_> yeah, ponging would get annoying i think
07:17:40 <edwinb> telnet does that ;)
07:18:14 <Philippa> no, it doesn't
07:18:21 <Philippa> the PINGs are on the IRC layer
07:18:33 <nlv11757_> telnet doesnt have knowledge of irc msgs i think
07:18:41 <nlv11757_> ow Philippa was faster
07:19:25 <earthy> you could do it by hand
07:19:35 <earthy> but having to type the pongs is *highly* annoying
07:19:35 <Philippa> not always practical
07:19:41 <Philippa> damn right it is
07:19:56 <nlv11757_> but i would be considered hardcore right haha
07:29:52 <nlv11757_> btw why would one prefer Hashtable over Map?
07:31:15 <Lor> Efficiency in some situations.
07:32:41 <nlv11757_> ow crap, where it all began....it also cant *just* extract an arbitrary element
07:34:10 <nlv11757_> is Map.elems lazy?
07:34:36 <nlv11757_> nm, doesnt matter sigh
07:37:26 <[TWiSTED]> hey
07:37:37 <nlv11757_> yo
07:37:48 <[TWiSTED]> is there a way to combine the tuples without ordering them first?
07:38:00 <[TWiSTED]> same thing with what we were talking about before
07:38:38 <[TWiSTED]> cos one question just asks to combine the like first elements and add the values of the second elements, but not sort them
07:38:45 <[TWiSTED]> then the 2nd question is do the same but sort them
07:38:57 <[TWiSTED]> we already sorted them
07:39:06 <[TWiSTED]> if that makes sense
07:39:21 <nlv11757_> so basically you need to do it in the first part without making use of sort....
07:39:37 <[TWiSTED]> so like
07:39:41 <[TWiSTED]> combine xs = map ((head *** sum) . unzip) ((groupBy (\a b -> fst a == fst b)) (xs))
07:39:59 <nlv11757_> without sort groupBy is useless in your case
07:40:06 <[TWiSTED]> o
07:40:27 <nlv11757_> cause groupBy will only group equal elements in sequence
07:40:56 <[TWiSTED]> o rite
07:41:29 <nlv11757_> @plugs (groupBy (\a b -> fst a == fst b)) [("a", 5), ("b", 6), ("b",7), ("a",8)]
07:41:34 <lambdabot> [[("a",5)],[("b",6),("b",7)],[("a",8)]]
07:41:40 <nlv11757_> see
07:41:51 <[TWiSTED]> ahh yea
07:43:05 <[TWiSTED]> ok
07:45:15 <nlv11757_> ofcourse you can do it disgustingly ineffcient using a filter for every unique lefthand side
07:45:23 <nlv11757_> that would not involve using sort
07:45:31 <[TWiSTED]> true
07:45:37 <[TWiSTED]> i think thats what ive got to do then
07:47:02 <Cale> [TWiSTED]: what are you writing?
07:47:37 <[TWiSTED]> basically a number of functions that will eventually lead to balancing element equations
07:53:44 <Cale> [TWiSTED]: Looking at what you had written up there -- perhaps using Data.Map would be handy? Like (toList . fromListWith (+)) [[("a",5)],[("b",6),("b",7)],[("a",8)]]
07:53:54 <Cale> er
07:54:03 <Cale> [("a",2) , ("a",4) , ("b",5) , ("c",6)] rather :)
07:54:26 <[TWiSTED]> o
07:55:13 <[TWiSTED]> says cant find imported module Data.Map
07:56:07 <Cale> which haskell implementation/version are you using?
07:56:20 <[TWiSTED]> hugs 98
07:57:26 <Cale> maybe Data.FiniteMap is available, in which case you'd write it as fmToList (addListToFM_C (+) emptyFM xs)
07:57:39 <[TWiSTED]> ah ok
07:57:41 <[TWiSTED]> ill try that
07:58:08 <Cale> Data.Map is new in GHC 6.4
07:58:25 <nlv11757_> you can use updateWithKey to do the addition
07:58:33 <jlouis> Data.Map is cool
07:59:06 <[TWiSTED]> cool
07:59:08 <[TWiSTED]> that seems to work
08:00:23 <[TWiSTED]> now is it possible to use that same function to sort it
08:00:44 <nlv11757_> you dont need sorting when using the Map right?
08:00:51 <nlv11757_> or do you still want to have a sorted output?
08:01:02 <[TWiSTED]> yeah sorted for the next function
08:01:18 <nlv11757_> didnt you already had a version that sorted o_0
08:01:23 <[TWiSTED]> yeh
08:01:47 <[TWiSTED]> but i think ive gotta incorporate the previous function to sort it
08:02:15 <nlv11757_> do a "sort . Map.toList"
08:02:24 <Cale> er
08:02:30 <nlv11757_> :D
08:02:37 <Cale> the result of toList is sorted already
08:02:51 <Cale> unless you intend to use a different ordering
08:03:33 <SamB> Cale: so? the extra sort keeps the CPU busy ;-). wouldn't want the CPU getting lazy, would you?
08:03:38 <[TWiSTED]> this is starting to look hell complex then what i had before hehe
08:03:58 <Cale> what did you have before?
08:04:08 <[TWiSTED]> map ((head *** sum) . unzip) ((groupBy (\a b -> fst a == fst b)) sort (xs))
08:04:15 <[TWiSTED]> but that sorted it
08:04:24 <jlouis> SamB: yeah, in fact, execute sort . sort just to make it happy
08:04:37 <jlouis> twice
08:08:36 <Cale> That actually looks to me a bit trickier to understand than the fmToList one :)
08:09:21 <Cale> So, who introduced you to arrows? :)
08:10:25 <jlouis> Arrows rock
08:10:36 <jlouis> I have begun to play with them and they are quite quite nice
08:11:56 <[TWiSTED]> hehe
08:11:58 <[TWiSTED]> um
08:12:07 <[TWiSTED]> nlv11757_ is the culprit hehe
08:13:22 <[TWiSTED]> ill use urs cale
08:14:02 <nlv11757_> [TWiSTED], didnt show the nice pointfree version i recommended :)
08:14:14 <[TWiSTED]> haha
08:14:19 <[TWiSTED]> which one was that?
08:14:33 <nlv11757_> combine = map ((head *** sum) . unzip) . groupBy ((. fst) . (==) . fst) . sort
08:14:39 <nlv11757_> all these nice points
08:14:45 <[TWiSTED]> oo
08:14:48 <Cale> that is nice :)
08:15:07 <Cale> but in a different way from "nicely readable" :)
08:15:08 <[TWiSTED]> i dont really understand the . thingos
08:15:16 <Cale> . is composition of functions
08:15:19 <Cale> f . g
08:15:35 <Cale> is a function which when applied to x has the same effect as f(g x)
08:15:43 <[TWiSTED]> ooo yea
08:16:03 <[TWiSTED]> ok
08:16:15 <[TWiSTED]> so which one should i use? :)
08:18:16 <nlv11757_> whatever seems fit to you
08:18:18 <nlv11757_> im gone
08:18:18 <nlv11757_> later
08:18:25 <Cale> I like the Data.Map or Data.FiniteMap versions, but it is sort of a cheap (ab)use of finite maps :)
08:18:30 <Consystor> hi all
08:18:34 <Cale> hello
08:19:03 <Consystor> i have some questions to haskell... i think im not the first 1...
08:19:14 <[TWiSTED]> heheh
08:19:39 <[TWiSTED]> ok ill use combine xs = fmToList (addListToFM_C (+) emptyFM xs)
08:19:53 <[TWiSTED]> but how would i modify that so that it sorts the tuples?
08:20:08 <Consystor> maybe its not hard for you an normally if i learn anew language i try to google or i read references but for haskel i didnt find good ones...
08:20:49 <Consystor> ok, i've here this lineof code: "infix 5 :^:"
08:20:56 <Cale> [TWiSTED]: does it not sort them already?
08:21:00 <Consystor> what down that mean
08:21:23 <Consystor> down=dows
08:21:28 <Consystor> down=does
08:21:41 <Cale> Consystor: that declares :^: as a (nonassociative) infix operator, and gives its precedence as 5
08:22:02 <[TWiSTED]> o yea it does
08:22:12 <[TWiSTED]> how would i make it so it doesnt sort it hehe
08:22:13 <Consystor> k
08:23:13 <jlouis> Ah, so you have tuples of type Eq a, Num b => (a, b) and which to group together a's and count how many b's you have for each a?
08:23:22 <jlouis> and wish
08:23:31 <[TWiSTED]> yep
08:23:32 <[TWiSTED]> tahts it
08:23:48 <[TWiSTED]> and for the first function they dont have to be sorted
08:23:54 <[TWiSTED]> but for the 2nd they do
08:24:05 <[TWiSTED]> so weve already done the 2nd function
08:24:09 <Cale> [TWiSTED]: It's more expensive not to sort them
08:24:19 <[TWiSTED]> true
08:24:39 <jlouis> [TWiSTED]: no, that is not it. You cannot use Cale's or your version on that. You have Ord a, Num b => ...
08:25:14 <jlouis> in which case the total order gives rise to ordered 2-3 trees (Data.Map) or sorting
08:25:52 <jlouis> I'd go with Cale's version
08:26:05 <[TWiSTED]> ok
08:26:09 <[TWiSTED]> yeh i did
08:27:37 <[TWiSTED]> o wait
08:27:49 <[TWiSTED]> it needs to be sorted in terms of the atom count
08:28:03 <Consystor> and then i have this: "data Tree a = Leaf a | Tree a :^: Tree a deriving (Eq,Read,Show)" it declares a new type "Tree a" but what does the ":^:"?
08:29:02 <[TWiSTED]> actually
08:29:05 <[TWiSTED]> i dont know
08:29:44 <jlouis> Consystor: it is a operator which is declared in your source code. You will have to look elsewhere in the source to see what it actually does
08:31:20 <Consystor> oh there are no more lines of code and my exercise is to implement the funktion fmap of the Class Functor a
08:31:43 <Cale> Consystor: It's a data constructor for the Tree type defined right there
08:32:05 <Cale> Consystor: Leaf 5 :^: Leaf 6
08:32:12 <Consystor> and how do i use that contructor
08:32:15 <Cale> is a tree with two leaves
08:32:22 <Consystor> oh
08:32:23 <Cale>   *
08:32:26 <Cale>  / \
08:32:29 <Cale> 5   6
08:32:29 <jlouis> Consystor: oh, sorry. Forget my blurb. Sun hit laptop in wrong way
08:32:43 <Consystor> jlouis: k, np
08:33:17 <Consystor> Cale: do i have to implement this functionality or is it done already by the code
08:33:37 <Cale> Consystor: that data declaration takes care of it
08:34:32 <Cale> it defines a new data type where you can write things like (Leaf 7 :^: Leaf 5) :^: Leaf 6, and pick them apart using pattern matching and such
08:34:41 <Consystor> ok then (Leaf 5 :^: Leaf 6) is of type Tree Integer ???
08:34:46 <Cale> yeah
08:34:56 <jlouis> exactly Consystor
08:35:06 <Consystor> cool
08:35:06 <Cale> Or really (Num a) => Tree a, but that's being nitpicky :)
08:35:23 <Consystor> hehehe, haskell codeis really short
08:35:29 <jlouis> You bet ;)
08:35:50 <jlouis> btw, does anyone know how to compile ghc without ghci?
08:36:06 <Consystor> oh, ask ./configure --help
08:36:27 <Consystor> or "./configure --help | grep interactive"
08:37:16 <Cale> Consystor: compile ghc recently?
08:37:48 <Consystor> cale: if i compiled it???
08:39:00 <jlouis> there is no interactive line, sadly
08:39:04 <jlouis> now we try with ghci
08:39:18 <Consystor> hmm, there must be something without interactive
08:39:25 <Cale> Consystor: oh, compiling ghc is a bit of an ordeal :)
08:39:32 <Consystor> i've installed last time ghc on a 64 bit system
08:39:39 <[TWiSTED]> combine xs = map ((head *** sum) . unzip) ((groupBy (\a b -> fst a == fst b)) sort (xs))
08:39:43 <[TWiSTED]> that seems right yea?
08:39:46 <[TWiSTED]> its giving me an error
08:39:56 <Consystor> but it was a fedora rpm an it didnt have ghc --interactive
08:40:51 <Consystor> Cale: oh yes, i thought i could do that on a hp machine - no way - lol
08:40:58 <Cale> :)
08:41:12 <jlouis> patch < /usr/pkgsrc/lang/ghc/patches/patch-ae solves the problem
08:41:31 <jlouis> (proper linker directives on NetBSD)
08:41:59 <Consystor> jlouis: do you compile it under NetBSD, i've done it on freebsd
08:42:21 <Consystor> but with ports
08:42:22 <jlouis> Consystor: actually yes. From 6.2.1 to 6.2.2 and later today, if all goes well to 6.4
08:43:42 <Consystor> ok there was no problem with 6.4 on FreeBSD-5.4 from the ports so i think you will have a chance ;-)
08:44:02 <jlouis> FreeBSD and NetBSD are quite different beasts here
08:44:55 <Consystor> oh, i thought it also has ports?
08:45:22 <Consystor> i thought the port collection is originally from netbsd but mambe im wrong
08:45:33 <Consystor> mambe = maybe
08:46:11 <Consystor> its a long time ago that i played with netbsd...
08:46:42 <farre> hi nibro
08:46:42 <Consystor> its nice but nothing for my SMP machines, maybe in futre...
08:46:54 <Consystor> one more question to my fmap
08:47:54 <jlouis> yeah?
08:48:15 <Consystor> it shall apply a function on each element of the datatype a
08:48:31 <Consystor> so it should work like the normal map function
08:48:57 <Consystor> but why does haskell or i need this function
08:49:19 <jlouis> yes, when a type is member of the Functor type you can ``map'' that type in the sence you do for lists
08:49:32 <jlouis> sense
08:49:34 <jlouis> grrr
08:49:37 <Consystor> for example if i declare a new typethen i take the (+) function and soon from (Num a)
08:49:49 <Cale> Consystor: it can be quite handy to take a data structure and apply a function to every value stored in it
08:50:42 <Cale> It saves you from writing your whole library for values again on each container type :)
08:51:03 <Consystor> ok that means
08:51:40 <Consystor> that i have to call the passed functionon each leaf???
08:51:50 <Cale> yes
08:51:57 <Cale> so...
08:52:06 <Cale> fmap f (Leaf x) = ...
08:52:18 <Consystor> ok than i first have to descend the tree?
08:52:27 <Consystor> k
08:52:33 <Cale> what should ... be replaced with there?
08:53:20 <Consystor> first: (Leaf x) says haskell that this is my fmap for (Leav a) ?
08:53:29 <Spida_> hi
08:53:30 <Consystor> is that correct?
08:53:30 <Cale> yeah
08:53:33 <Consystor> hi
08:53:39 <Consystor> k
08:53:43 <Consystor> mom
08:53:43 <Spida_> how can I get the n-th element of a list?
08:53:51 <Cale> Spida_: xs !! n
08:53:52 <Consystor> (!!) i thought
08:53:59 <Spida_> thx
08:54:27 <Cale> Spida_: if you find yourself using it a lot, then you might consider using another data structure, or algorithm
08:54:36 <Consystor> fmap f (Leaf x) = Leaf (f x)
08:54:44 <Cale> Consystor: exactly
08:54:57 <Cale> Now, there's just one other case
08:55:07 <Cale> fmap f (t1 :^: t2)
08:55:25 <Consystor> or (Tree x)???
08:55:48 <jlouis> we must RECURSE on HOMEWORK till we get it CORRECT!
08:55:57 <jlouis> (yow)
08:55:57 <Cale> Leaf and :^: are constructors for values of type Tree a
08:56:08 <Consystor> ok
08:56:09 <Consystor> mom
08:56:14 <Consystor> fmap f (t1 :^: t2)
08:56:41 <xerox> Why ":^:" ? :-)
08:56:56 <jlouis> xerox: the data type is defined that way
08:57:02 <jlouis> xerox: scroll up a bit
08:57:05 <Consystor> fmap f (t1 :^: t2) = (fmap f t1) :^: (fmap f t2) ???
08:57:10 <Spida_> Cale: hm, have to think about it
08:57:13 <Cale> Consystor: yes :)
08:57:13 <xerox> Just joined. Anyway it's strange :-)
08:57:20 <Consystor> really???
08:57:33 <jlouis> Consystor: really.
08:57:38 * xerox yays Functors
08:57:42 * Consystor happy
08:57:48 * Consystor is very happy
08:57:53 <Consystor> thanx!!!
08:57:58 <Cale> no problem
08:58:21 <jlouis> Spida_: often, when you want to access element no. k in a list, you are actually searching for a data structure which lends fast searches on elements
08:58:34 <Cale> you should be aware that you want to put that definition inside an "instance Functor (Tree a) where"
08:58:41 <Cale> er
08:58:42 <Consystor> :^: is a new function but what must i know if i definenew functions
08:58:49 <Cale> instance Functor Tree where
08:58:51 <Cale> rather
08:58:54 <xerox> :^: is a data constructor
08:59:07 <Consystor> could i declare this as a new function: ":l:"
08:59:22 <Consystor> oh, thats already implemented?
08:59:32 <xerox> I think not.
09:00:43 <Consystor> Cale: "instance Functor (Tree a) where" <-- it should be (Tree a) ???
09:00:54 <Cale> no
09:00:59 <Cale> I corrected myself there
09:01:07 <Consystor> k
09:01:52 <Consystor> :^: is haskell's normal constructor?
09:02:10 <jlouis> ah, playing a bit around with a couple of Makefile's and emacs made it happily compile again
09:02:17 <Consystor> or did i define it by oneof the first 2 lines?
09:02:28 <Cale> you defined it
09:02:53 <jlouis> you defined 2 constructors for the Tree a data type: Leaf and :^:
09:02:54 <Consystor> could I also define another symbol as my constructor?
09:03:12 <Cale> Consystor: sure
09:03:15 <jlouis> Consystor: yes, you are free to choose them as you see fit
09:03:39 <Consystor> for example ":foo:" <-- would that work?
09:04:06 <Cale> no, if you're going to use an infix constructor, it should start with : and consist entirely of symbol characters
09:04:18 <Cale> :@*$: should work
09:04:23 <Spida> I need to implement a list-based algorithm to calculate fibonacci-numbers (yes, its a homework).
09:05:03 <Consystor> ok
09:05:15 <wli> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
09:05:21 <jlouis> Spida: what wli said
09:05:42 <Cale> Consystor: you can also use infix for ordinary functions, but they must not start with a colon
09:06:28 <Consystor> for example if i have one function f
09:06:48 <Consystor> i can make it important by infix 1 f
09:06:52 <jlouis> Spida: it is tricky to figure out however, without an explanation
09:07:13 <Consystor> is that correct?
09:07:16 <wli> This method is generalizable to arbitrary linear recurrences with constant coefficients and more.
09:07:38 <Consystor> or give it a higher precedence
09:08:27 <Spida> jlouis, wli: thx
09:08:30 <Cale> heh, that has me running to the Haskell spec -- that certainly works if "f" is an infix operator
09:09:46 <wli> If you need F_n for isolated, large n, I have O(lg(n)) pure integer methods for such (for large n floating point will break anyway).
09:09:52 <Consystor> ok if my function f would be  "f n = 2^n"  then it sould work?
09:10:05 <Cale> well, that's not an infix function
09:10:14 <Consystor> ohh
09:10:18 <Consystor> shit
09:10:23 <Consystor> infix would be +
09:10:28 <Consystor> and not(+)
09:10:35 <Consystor> sorry
09:11:09 <Cale> if you have something like foo a b = a * 2^b
09:11:10 <Consystor> `f` would be infix???
09:11:27 <Cale> then you can write a fixity declaration like infix 6 `foo`
09:11:30 <wli> http://holomorphy.com/~wli/Fib.hs shows the O(lg(n)) pure integer method for computing F_n
09:11:32 <Cale> yeah
09:12:04 <Consystor> k, and than i could write: infix 2 `f` ???
09:12:30 <Cale> sure
09:12:50 <Consystor> funny
09:13:21 <Consystor> thanx again
09:13:27 <Cale> no problem
09:14:03 <Cale> some examples of functions with fixity declarations in the prelude are div, mod, rem, quot, elem, and notElem
09:14:16 <Cale> as well as seq
09:15:07 <Consystor> what does fixitiy means - i cannot change the precedence of them?
09:20:20 <wli> sum (map (fib . (2^)) [0..20]) `mod` 10 sees (2.75 secs, 0 bytes) with the O(lg(n)) methods
09:20:32 <wli> and effective nontermination with the O(n) method
09:23:17 <wli> (The linear methods should never be used for such...)
09:24:16 <wli> (there are duplication, triplication, etc. formulae that should always be used for fibonacci numbers of indices in geometric progression.)
09:27:04 <Consystor> Cale: how can i test my fmap?
09:27:49 <Cale> fmap (+5) ((Tree 1 :^: Tree 2) :^: Tree 3)
09:29:04 <Cale> er
09:29:05 <Cale> Leaf
09:29:14 <Cale> :)
09:29:16 <Cale> not Tree
09:29:18 <Consystor> k
09:29:32 <Cale> I'm still half-asleep :)
09:29:40 <Consystor> works fine, thnx!!! i only tested 5:^:6 before
09:29:50 <Consystor> it didnt work but i c my mistake
09:30:12 <Consystor> Cale: that's ok, i also have to think...
09:31:37 <Consystor> Cale: how long do you program in haskell
09:31:57 <Cale> a few years now
09:32:00 <Consystor> do you know a good reference in theinet or a book?
09:32:14 <Cale> I like "Yet Another Haskell Tutorial"
09:32:59 <Cale> The wiki is a good place to ask questions and look at other things people have written
09:34:44 <Consystor> k but if i need informations to functions or other thinks - is there a compendium?
09:35:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
09:35:35 <Cale> http://www.haskell.org/onlinereport/ is also useful - it's the language spec, so it's a bit dry, but there are useful bits in it all over
09:36:31 <lispy> Cale: as for as language specs go, it's a pleasant read
09:36:40 <Consystor> oh, i know the first link but it a little hard for beginners
09:36:41 <Cale> lispy: indeed
09:37:21 <Cale> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html might be useful
09:37:34 <Consystor> the second link i use very often
09:38:05 <Consystor> cale: oh yes, this one is nice
09:38:11 <Consystor> has many examples...
09:41:36 <Cale> http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html is also nice to look at, though you might be past it at this point.
09:44:16 <basti_> hi
09:45:07 <SyntaxNinja> good morning #haskell
09:45:37 <Consystor> cale: the last link is also very nice - now i see the syntax for datatypes - hehe
09:45:51 <Consystor> hi baschti
09:46:50 * SyntaxNinja is happy to see a long thread on libraries@haskell.org where I'm not involved ;)
09:46:57 <SyntaxNinja> makes me feel leess guilty
09:47:11 <Igloo> :-)
09:52:10 <basti_> hi
09:53:09 <[TWiSTED]> how would i made a function such that when entered a string, it will separate the letters from the numbers and store it in a list of tuples
09:53:50 <[TWiSTED]> eg. function1 "Hello123Goodbye456" = [("Hello",123),("Goodbye",456)]
09:54:11 <SyntaxNinja> [TWiSTED]: is that a homework problem?
09:54:19 <[TWiSTED]> somewhat
09:54:35 <SyntaxNinja> [TWiSTED]: you should look at the Data.List module for a bunch of interesting functions
09:54:37 <SyntaxNinja> @type filter
09:54:43 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
09:54:46 <[TWiSTED]> oo ok
09:54:47 <SyntaxNinja> @type takeWhile
09:54:48 <lambdabot> takeWhile :: forall a. (a -> Bool) -> [a] -> [a]
09:54:53 <SyntaxNinja> some of those might be useful
09:54:56 <[TWiSTED]> cheers
09:55:23 <SyntaxNinja> np
10:28:19 <SyntaxNinja> fewer employed programmers in the Portland area :( http://www.zdnet.com.au/news/software/0,2000061733,39193252,00.htm
10:28:31 <SyntaxNinja> well, maybe.  it doesn't actually say where they're located
10:28:48 <wli> It's Portland (Beaverton).
10:33:00 <Trevion> I don't suppose anyone knows a good way to typeset grammars in TeX?
10:46:30 <SyntaxNinja> wli: that sucks :(
10:46:41 <SyntaxNinja> (those guys work in this building)
10:47:07 <SyntaxNinja> anyone have suggestions about where I should post info about a (somewhat) FP related job?
10:49:16 <Trevion> Don't those get sent to the haskell list with at least some regularity?
10:52:19 <SyntaxNinja> yeah, I posted one to haskell-cafe, but we're not getting enough applicants
10:54:53 * Muad_Dibler not applying, but still curious of to what kinda job itll be :)
10:55:32 <SyntaxNinja> muad_dibler: thanks for asking :) http://www.galois.com/job_testengineer.php
10:57:32 <Muad_Dibler> 0o0
10:57:39 <Muad_Dibler> is haskell considered scripting? :P
10:57:49 <SyntaxNinja> it depends, I think.
10:57:58 <mflux_> I guess it depends how you define scripting
10:58:16 <Muad_Dibler> in the sence of bash, perl and python :P
10:58:29 <mflux_> I think I draw the line to not having capability to compile to executables and not having static typing
10:58:46 <SyntaxNinja> IMO, you can use Haskell for any task where you can use Python :)
10:58:58 <autrijus> mflux_: but perl can compile to executables and has static typing :)
10:59:08 <mflux_> autrijus, you mean perl6 has static typing?
10:59:12 <autrijus> it's just it only has some 5 types and you can't add in newtype ;)
10:59:16 <autrijus> mflux_: yes.
10:59:33 <mflux_> hmm, or do are you refering to %$@etc?
10:59:48 <mflux_> autrijus, well maybe perl6 is then a Programming Language
11:00:02 <mflux_> however not having user defined types really hinders the static typing :-o
11:00:07 <autrijus> mflux_: I'm referring to perl5 :)
11:00:13 <mflux_> maybe even is a disqualifying feature ;)
11:00:18 <autrijus> perl 6 has user defined types, subtypes, and constraints :)
11:00:43 <autrijus> (and yes, by static types in perl 5 I mean Hash, Array, Scalar, Regexp, Ref)
11:00:56 <mflux_> autrijus, does perl6 still need the %@$-differentiation?
11:01:13 <autrijus> mflux_: not anymore; you can use $foo throughout, or even use the siglless variant.
11:01:22 <autrijus> (where $foo is written as foo)
11:01:30 <autrijus> (but you lose string interpolation that way)
11:01:45 <SyntaxNinja> I see scripting more as a kind of programming, not a kind of language
11:01:45 <mflux_> ooh
11:01:57 * autrijus happens to agree with SyntaxNinja
11:02:09 <SyntaxNinja> typically short programs that do system-type stuff, often gluing together several other programs
11:02:14 <autrijus> but scripting also means "really fast compilation" for me :)
11:02:16 <Trevion> True, but certain languages are more suited to that than others.
11:02:19 <autrijus> eg. hugs
11:02:29 <autrijus> and not eg. ghc
11:02:33 <SyntaxNinja> Trevion: true, and I think Haskell is suited to it :)
11:03:25 <Trevion> I wouldn't argue against Haskell - on the other hand, I don't think you would want to coerce FORTRAN into being a useful scripting language.
11:28:12 <Consystor> re
11:42:21 <SamB> @docs Data.List
11:42:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
11:51:27 <SamB> @pl \x -> (x, x)
11:51:28 <lambdabot> join (,)
11:51:52 <SamB> @type join
11:51:59 <lambdabot> bzzt
11:52:29 <Muad_Dibler> where can i find more info about the import thing?
11:52:40 <SamB> where does this join come from?
11:52:40 <Muad_Dibler> i have this file with contains a module Main
11:52:51 <Muad_Dibler> now i want to import the module main
11:53:15 <SamB> Muad_Dibber: into what?
11:53:29 <Muad_Dibler> into anothe module :P
11:53:35 <SyntaxNinja> "import Main"
11:53:36 <SamB> why?
11:53:42 <SyntaxNinja> the module should be called Main.hs or something
11:53:46 <Muad_Dibler> SyntaxNinja: thats the point
11:53:51 <Muad_Dibler> the file isnt Main.hs
11:53:56 <Muad_Dibler> but the module name is :P
11:53:57 <SamB> most compilers don't support mutually recursive modules...
11:54:10 <SamB> (without extra information)
11:54:22 <SyntaxNinja> SamB: Oo
11:54:31 <SyntaxNinja> Muad_Dibler: rename the file :)
11:54:59 <Muad_Dibler> SyntaxNinja: since it hasnt anything to do with my Main, i'd prefer not to
11:55:04 <Muad_Dibler> so i'll prolly just rename the module :P
11:55:46 <SyntaxNinja> Muad_Dibler: imports look for modules based on filenames.
11:59:16 <SamB> though oddly enough, if you do ghc --make foo.hs where foo.hs is a Main module, and something it imports {-# SOURCE #-} Main, ghc looks for foo.hs-boot...
11:59:35 <SamB> s/imports/imports imports/
12:02:30 <SyntaxNinja> powerful
12:04:02 * SyntaxNinja lunch &
12:04:05 * Lemmih yarns.
12:07:20 <Lemmih> ehm. *yawns
12:11:07 <SamB> hmm, ':i (->)' isn't working...
12:14:23 <basti__> "->" is not a normal operator
12:15:02 <SamB> yes, but it is a type constructor!
12:15:07 <Lemmih> @kind (->)
12:15:12 <lambdabot> (->) :: ?? -> ? -> *
12:15:29 <basti__> lol
12:15:29 <xerox> SamB, I got the same problem some day ago, eheh!
12:15:38 <basti__> ?? -> ? -> * yes?
12:15:44 <SamB> I wanted to see what classes it was related to
12:15:54 <xerox> I know Arrow (->)
12:23:02 <glimming> @seen esap
12:23:03 <lambdabot> esap is in #haskell. I don't know when esap last spoke.
12:23:40 <SamB> @pl (\acc x -> let y = acc + x in (y, y))
12:23:42 <lambdabot> ((join (,) . fix . const) .) . (+)
12:23:54 <SamB> @type ((join (,) . fix . const) .) . (+)
12:24:00 <lambdabot> bzzt
12:24:11 <SamB> where is this join from?
12:36:44 <SamB> is it from Control.Monad?
12:36:52 <SamB> @index join
12:36:52 <Lemmih> @index join
12:36:54 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
12:36:54 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
12:36:54 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
12:36:54 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
12:36:54 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
12:36:55 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
12:38:43 <SamB> @index fix
12:38:44 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
12:38:44 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
12:38:44 <lambdabot> Control.Monad.Error
12:39:55 <SamB> hmm, now all I need is an instance for Monad ((->) a)
12:41:51 <SamB> Prelude Control.Monad.Fix Control.Monad Data.List> :t ((join (,) . fix . const) .) . (+)
12:41:51 <SamB> ((join (,) . fix . const) .) . (+) :: forall a.
12:41:51 <SamB>                                       (Monad ((->) a), Num a) =>
12:41:51 <SamB>                                       a -> a -> (a, a)
12:42:03 <SamB> @help pl
12:42:04 <lambdabot>  @pointless <expr> - play with pointfree code
12:42:13 <Lemmih> SyntaxNinja: Is Arthur Baars' cabal patch available online?
12:45:21 * boegel greets the gang
12:45:32 <Lemmih> Yo boegel.
13:01:36 <boegel> any exciting news?
13:03:18 <Lemmih> I'm almost done with my libgpgme binding...
13:06:03 <tromp> wonder wht a rigid variable is...
13:06:23 <tromp> ghc complains:     Couldn't match the rigid variable `a' against `[Int]'
13:06:54 <boegel> hey tromp :)
13:07:04 <boegel> I tried catching you the last few days, but always missed
13:07:34 * boegel 's back is killing him
13:07:40 <SamB> how would you determine the empiracle complexity of an algorithm?
13:07:45 <tromp> hi boegel
13:18:35 <Philippa> SamB: empirically, surely?
13:18:48 <Philippa> IOW, experiment
13:18:49 <SamB> well yeah
13:19:19 <SamB> but are there any frameworks (clever QuickCheck hacks?) for that?
13:20:22 <Philippa> hmm, a modification of QuickCheck that does timing might be useful, though you'd get a graph out of it rather than anything else
13:20:29 <Philippa> what kind of value do you want out at the end?
13:21:15 <SamB> hmm, good question.
13:24:43 <SyntaxNinja> Lemmih: what patch is that?
13:26:19 <Lemmih> Support for building profiling libraries with Cabal.
13:27:37 <SyntaxNinja> Lemmih: I don't remember seeing such a patch!
13:29:00 <Lemmih> Oh, must have misread something then.
13:30:09 <SyntaxNinja> I'd love such a patch
13:34:03 <Igloo> Someone sent a hack to make a package /always/ build with profiling I think; perhaps that's what you're thinking of?
13:34:21 <SyntaxNinja> I don't remember that either.
13:37:48 * SamB wishes there was a nice class Mapping d k for things like Map...
13:38:08 <SyntaxNinja> a typeclass?
13:38:18 <SamB> yes, yes
13:39:18 <SyntaxNinja> write one, then mail it to libraries@haskell.org :)
13:39:32 <SamB> okay
13:41:36 <marcot> Hello, I've just compiled c2hs0.13.6 with ghc6.4, but when I try to compile with ghc using -package-conf /usr/local/lib/c2hs/ghc6/c2hs.conf it sais:
13:41:44 <marcot> ghc-6.4: /usr/local/lib/c2hs-0.13.6/ghc6/c2hs.conf:1:0:
13:41:51 <marcot>     parse error on input `name'
13:42:52 <marcot> How should the package-conf file be formatted?
13:42:56 <marcot> It seems to be right.
13:43:20 <SyntaxNinja> marcot: ghc 6.4 has a different format from 6.2
13:43:53 <SyntaxNinja> marcot: it might be easiser to cabal-ize it, and then cabal will produce the right package.conf file for the version of GHC you're using.
13:44:11 <marcot> SyntaxNinja: and how do I cabal-ize it?
13:44:41 <SyntaxNinja> marcot: is it a complex tool? does it have a lot of dependencies or anything? or multiple libraries and executables?
13:44:53 <SyntaxNinja> marcot: cabal users's guide is linked from: http://www.haskell.org/cabal
13:45:07 <marcot> SyntaxNinja: I think that this will not be simple.
13:45:14 <marcot> SyntaxNinja: is there other solution?
13:45:19 <marcot> SyntaxNinja: using ghc 6.2?
13:45:21 <Igloo> SyntaxNinja: "Subject: [Haskell] Workaround for building profiling libs and apps with Cabal" from Satnam Singh
13:45:43 <SyntaxNinja> Igloo: which list?
13:45:47 <Igloo> (also went to libraries@ and you directly)
13:45:57 <Igloo> That subject is from haskell@
13:46:25 <SyntaxNinja> ahh... yeah
13:46:59 <SyntaxNinja> that's nto a cabal patch
13:47:29 <SyntaxNinja> marcot: I'm just assuming that the build system is designed for 6.2
13:48:06 <marcot> SyntaxNinja: I'll try to do that.
13:48:28 <SamB> @index insert
13:48:30 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap,
13:48:30 <lambdabot> Data.IntSet, Data.List, Data.Map, Data.Set
13:48:42 <MachinShin> hey +
13:58:54 <integral> @pl \a -> f a b
13:58:55 <lambdabot> flip f b
13:59:23 <lispy> heh
13:59:32 <basti__> what? :)
13:59:35 <lispy> pointless versions are sometimes so hard to understand :)
13:59:45 <basti__> this time not.
14:00:03 <lispy> i dunno, i think \a -> f a b is a lot easier
14:00:25 <integral> yes, for one letter variable names it is.
14:00:39 <integral> with big long, descriptive, useful variable names, the flip version is shorter :-)
14:01:27 <lispy> it's shorter yes, but i let emacs type long variable names for me.  Using flip that way makes it require more time to read :)
14:02:09 <lispy> don't get me wrong, i think pointless is a good
14:02:35 <basti__> i find "flip" intuitive, really!
14:02:35 <basti__> ;)
14:07:43 <Philippa> basti__: I actually /like/ reverse = foldl (flip (:)) []
14:07:55 <basti__> =)
14:08:17 <Philippa> ("turn the conses round and shove the nil at the other end")
14:08:36 <lispy> hmm..yeah, i like that definition too
14:08:53 <lispy> just something about the first one strikes me as odd :)
14:09:12 <alexj> lemmih, you said yesterday that you are working on the security model for hackage.
14:10:04 <alexj> syntaxninja: this gets to the heart of our backchannel as well so I figured on addressing it in this context
14:12:12 <SyntaxNinja> alexj: hm. I'd be surprised.
14:13:25 <wagle> pl flop
14:13:28 <wagle> @pl flop
14:13:29 <lambdabot> flop
14:13:32 <wagle> 8(
14:13:47 <boegel> wagle:  ?
14:13:52 <boegel> what did you expect
14:14:04 <wagle> epiphany
14:14:40 <wagle> if there is flip, there must be flop
14:15:30 <lispy> always too there are
14:15:34 <lispy> er two
14:15:49 <wagle> using the projection function pi (py), the commutative diagram does contain flippi and floppy
14:17:50 <monochrom> flip is an involution.
14:18:06 <monochrom> flip . flip = id
14:18:23 <monochrom> therefore if flop is to be the inverse of flip, just use flop = flip.
14:18:29 <alexj> syntaxninja: I guess lemmih isn't here right now.   Are you game to seeing if this works?
14:18:55 <monochrom> "everything has a flip side.  every flip has a flop side." ??  :)
14:18:59 <wagle> @type flip . flip
14:19:04 <lambdabot> flip . flip :: forall a b c. (b -> a -> c) -> b -> a -> c
14:19:10 * Lemmih is here alright.
14:19:28 <wagle> @type id
14:19:30 <lambdabot> id :: forall a. a -> a
14:19:49 <monochrom> yeah yeah yeah, I need a specialized id in flip . flip = id
14:20:00 <SyntaxNinja> alexj: I'm happy to discuss your ideas. I probably won't want to talk about your ideas of my ideas, though ;)
14:20:09 <alexj> lemmih: oh ok.  yesterday, you said something that caused me to believe that you had a security model for hackage that was neither ssl or running hackage on the clientside.
14:20:20 <alexj> syntaxninja: ok :- )
14:20:49 <wagle> i was amazed recently that flip ($) == flip id
14:21:09 <alexj> lemmih: whats the secret sauce!?
14:21:48 <Igloo> wagle: ($) is a type restricted version of id
14:22:11 <SyntaxNinja> alexj: fwiw, I believe he's working on the security model that I proposed.
14:22:30 <SamB> hmm, jhc does not like it when I put -fcpp in a pragma... I think it is not seeing the pragma because the module fails to parse...
14:22:35 <monochrom> So I can write "putStrLn `id` show 10" instead of "putStrLn $ show 10" ?
14:22:57 <monochrom> @plugs take 10 `id` repeat "id"
14:23:03 <lambdabot> ["id","id","id","id","id","id","id","id","id","id"]
14:23:07 * monochrom dances
14:23:22 <SamB> @type flip id
14:23:23 <lambdabot> flip id :: forall b c. b -> (b -> c) -> c
14:23:29 <SamB> @type flip ($)
14:23:31 <lambdabot> flip ($) :: forall b b1. b1 -> (b1 -> b) -> b
14:23:57 <monochrom> @plugs repeat "id" `flip id` take 10
14:23:59 <lambdabot> parse error on input `id'
14:24:03 <SamB> @type id
14:24:05 <lambdabot> id :: forall a. a -> a
14:24:08 <SamB> @type ($)
14:24:09 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
14:26:15 <wagle> Igloo: yeah, i know that _now_
14:26:16 <monochrom> this is a cool idea for the next haskell obfuscation contest.
14:26:32 <wagle> run @pl on the ghc source
14:26:55 <monochrom> @plugs (take `id` 10) `id` (repeat `id` "id")
14:26:56 <lambdabot> ["id","id","id","id","id","id","id","id","id","id"]
14:27:07 <Igloo> Ah, OK. I hadn't realised frmo what you said that you'd got the whole truth  :-)
14:27:37 <Lemmih> alexj: I'm just doing what SyntaxNinja instructs me to.
14:27:51 <monochrom> @plugs (flip id) (repeat `id` "id") `id` (take `id` 10)
14:27:52 <lambdabot> ["id","id","id","id","id","id","id","id","id","id"]
14:28:21 <wagle> Igloo: just explaining my over eagerness to differentiate by types
14:28:37 <wagle> gotta use my shiny new hammer!
14:29:22 <monochrom> @pl (flip id) (repeat `id` "id") `id` (take `id` 10)
14:29:23 <lambdabot> take 10 (repeat "id")
14:29:43 <monochrom> Damn strong normalizing simplifying whatever.
14:30:06 <monochrom> @pl, the premium *de*obfuscator!
14:30:07 <lambdabot> (line 1, column 28):
14:30:07 <lambdabot> unexpected end of input
14:30:07 <lambdabot> expecting white space or simple term
14:30:10 <cpjvelde> is there a debian package available somewhere for new ghc?
14:30:31 <wagle> the irony...
14:30:34 <jlouis> monochrom: I believe it has quite a number of rewriting rules and it is good at choosing
14:30:44 <jlouis> haven't read the source completely for it yet though
14:30:56 <SyntaxNinja> alexj: and I don't undersand your question
14:30:57 <arjanoosting> cpjvelde: yeah in unstable
14:31:05 <monochrom> I am always of the opinion that pointfree is less obfuscated, not more.
14:31:17 <wagle> actually would be interesting if @pl ghc was significant smaller than ghc
14:31:24 <musasabi> Is (x:xs) in pattern context considered an infix pattern or a list pattern?
14:31:35 <alexj> I don't understand the security model you proposed.
14:31:36 <cpjvelde> really? i have testing in my apt sources but i only get 6.2
14:31:36 <monochrom> hahah @pl ghc.  that will be cool.
14:31:38 <cpjvelde> weird
14:31:41 <alexj> syntaxninja
14:31:50 <basti__> musasabi: its a list pattern built with an infix operator?
14:32:02 <alexj> syntaxninja: how do you defend against a MITM on communications w/ a hackage server?
14:32:14 <arjanoosting> do you you have entries for unstable in /etc/apt/sources.list?
14:32:28 <monochrom> I've never heard of "infix pattern" or "list pattern".  I've only heard of "pattern" period.
14:32:35 <musasabi> basti__: yep, but need a way to choose either or.
14:32:45 <arjanoosting> if so, apt-get update ; apt-get -t unstable install ghc
14:33:03 <musasabi> In the Language.Haskell context.
14:33:23 <basti__> musasabi: hmmm.
14:33:25 <MachinShin> l8r all. off to kung fu class
14:33:29 <SyntaxNinja> alexj: it depends on which communications; they might feed you a bad tarball URL, but the tarball itself must be signed. this was mentinoed several tmes, I believe.
14:33:31 <monochrom> Ah. I see the problem.
14:33:45 <basti__> enlighten us momo
14:33:49 <basti__> mono lol
14:33:50 <SyntaxNinja> alexj: I think in the future, though, we'd probably want to add SSL to the XML-RPC interface, but I see that as overkill for now.
14:33:52 <alexj> syntaxninja: but how do you know which key should be the one to sign the tarball?
14:33:58 <monochrom> I bet infix pattern.  list pattern would be like ([x,y,z])
14:34:34 <monochrom> Imagine:  isthreesome [x,y,z] = True; isthreesome _ = False
14:34:41 <cpjvelde> arjanoosting, no i just have the testing there, i thought it also covered stuff in unstable, only newer
14:34:45 <basti__> hmm
14:35:21 <musasabi> It was infix - I found out how to try out stuff like that easily.
14:35:23 <arjanoosting> cpjvelde: no testing will be the new Debian release (sarge) and unstable is the development version of Debian.
14:35:38 <monochrom> I always bet right.
14:35:39 <SyntaxNinja> alexj: if a key is trusted, it's trusted, since you're installing code from them.
14:35:48 <boegel> monochrom: that's possible using (x:(y:(z:[]))) right ?
14:36:07 <alexj> then you are saying that any trusted key can sign any package?
14:36:36 <arjanoosting> cpjvelde: sarge is frozen now, so ghc 6.4 is only available in unstable and won't be in the sarge release
14:36:52 <SyntaxNinja> alexj: from cabal-get's POV, yes, but not from Hackage's point of vbiew.
14:37:43 <monochrom> Yes boegel.
14:37:59 * boegel corrected some Haskell-dude and cheers
14:38:07 <boegel> atleast one positive thing today
14:38:09 <boegel> *sigh
14:38:17 <monochrom> what did you correct?
14:38:26 <boegel> you ? :$
14:38:39 <cpjvelde> arjanoosting, then i'll just add the unstable also in my apt and it should work fine i guess, thanks
14:38:40 <arjanoosting> cpjvelde: you could add unstable lines to /etc/apt/sources.list, and use apt-pinning to make sure you don't upgrade your complete installation to unstable
14:38:48 <alexj> syntaxninja: why not just make the hackageserver ssl and rely on passwords for uploaders?
14:38:51 <monochrom> Have you tried isthreesome [x,y,z] = True; isthreesome _ = False  ?
14:39:07 <arjanoosting> cpjvelde: good luck
14:39:18 <alexj> then you don't have to invent anything new and you get security from the author to the user?
14:39:31 <cpjvelde> ow crap, i certainly dont want my complete system to become unstable instead of testing
14:39:43 <SyntaxNinja> alexj: because you can't then authenticate packages on a per-packager basis, for one, and for another, I think getting passwords right on a web server is harder htan getting gpg right.
14:40:24 <monochrom> @plugs let {f [x,y,z] = True; f _ = False} in (f [1,2,3], f [1])
14:40:26 <lambdabot> (True,False)
14:41:06 <arjanoosting> cpjvelde: just add APT::Default-Release "testing"; to /etc/apt/apt.conf
14:41:11 <alexj> re package authentication.  You have to trust the server operator in anycase (so you can use md5).  re passwords vs gpg.  ok, that makes sense.
14:41:57 <alexj> so there is no web of trust in this model.  its just raw keys.
14:42:00 <arjanoosting> that should keep the rest of the system from upgrading to unstable
14:42:04 <SyntaxNinja> alexj: you don't have to trust the server operator
14:42:29 <SyntaxNinja> alexj: it's up to the end-user who to trust.  if the end-user wants convinience, then he can trust the package key, if paranoia, then just trust individual authors.
14:42:43 <alexj> syntaxninja: yes you do.  otherwise you don't know which key has the right to sign the package (or what the package's md5 signature is)
14:43:28 <arjanoosting> cpjvelde: for more info see http://www.debian.org/doc/manuals/apt-howto/ch-apt-get.en.html
14:43:53 <alexj> from the end-user/cabal-get PoV saying that any key can sign any package?
14:43:59 <SyntaxNinja> alexj: it's the case that if you trust a key, you trust it to install any package, but you cna choose which keys to trust.
14:44:07 <SyntaxNinja> any _trusted_ key
14:46:14 <alexj> syntaxninja: ok, then you had better keep your set of trusted keys fairly small.
14:46:17 <cpjvelde> im i understanding that it would have been better for me to have installed unstable instead of testing?
14:46:47 <SamB> how does one summon JohnMeacham?
14:47:10 <basti__> chant his name backwards 7 times?
14:47:52 <SamB> the last time I saw him respond as if to a summons, I saw no such activity in the channel...
14:48:04 <monochrom> @plugs take 7 `id` repeat "mahcaeMnhoJ"
14:48:08 <lambdabot> ["mahcaeMnhoJ","mahcaeMnhoJ","mahcaeMnhoJ","mahcaeMnhoJ","mahcaeMnhoJ"
14:48:08 <lambdabot> ,"mahcaeMnhoJ","mahcaeMnhoJ"]
14:48:22 <alexj> syntaxninja: this goes to bulat's point about not necessarily having Simon's key in his trust group ( or vice versa)
14:48:23 <monochrom> Oh bother, why do I reverse manually?
14:49:05 <SamB> @plugs concat $ interpserse " " $ take 7 $ repeat "JohnMeacham"
14:49:11 <lambdabot> Variable not in scope: `interpserse'
14:49:18 <SamB> @plugs concat $ interperse " " $ take 7 $ repeat "JohnMeacham"
14:49:21 <lambdabot> Variable not in scope: `interperse'
14:49:26 <monochrom> List.intersperse
14:49:35 <alexj> syntaxninja: wouldn't it be better for the user/cabal-get to differentiate between a claim that a file has been signed by a particular to key and a claim that a package is owned by a particular key?
14:49:39 <SamB> @plugs concat $ List.interperse " " $ take 7 $ repeat "JohnMeacham"
14:49:43 <lambdabot> Variable not in scope: `List.interperse'
14:49:50 <monochrom> List.intersperse
14:49:55 <wagle> s
14:49:56 <SyntaxNinja> alexj: it depends on how paranoid you are.  most people will download stuff from web pages that look legit... if you want something better, you need a web of trust.
14:49:58 <SamB> oh, right.
14:50:00 <jlouis> monochrom: take 7 $ repeat (reverse "JohnMeacham")
14:50:01 <arjanoosting> cpjvelde: depends :)
14:50:09 <SamB> @plugs concat $ List.intersperse " " $ take 7 $ repeat "JohnMeacham"
14:50:11 <lambdabot> "JohnMeacham JohnMeacham JohnMeacham JohnMeacham JohnMeacham
14:50:11 <lambdabot> JohnMeacham JohnMeacham"
14:50:24 <monochrom> you also forgot to reverse
14:50:32 <jlouis> hehe
14:50:34 <jlouis> this is fun
14:50:37 <SamB> @plugs concat $ List.intersperse " " $ take 7 $ repeat $ reverse "JohnMeacham"
14:50:37 <SyntaxNinja> alexj: we could add that functionality; maybe in the non-beta release.
14:50:45 <lambdabot> "mahcaeMnhoJ mahcaeMnhoJ mahcaeMnhoJ mahcaeMnhoJ mahcaeMnhoJ
14:50:45 <lambdabot> mahcaeMnhoJ mahcaeMnhoJ"
14:50:58 <arjanoosting> cpjvelde: unstable is a little bit more unstable (broken dependencies and stuff) and testing will be the next release
14:51:02 <jlouis> @help fact
14:51:04 <lambdabot>  @fact <fact>, Retrieve a fact from the database
14:51:07 <monochrom> And finally you need to obfuscaterize by replacing $ with `id`
14:51:14 <SyntaxNinja> alexj: the point of the original proposal is to get a sound base; start getting signed packages in, have a reasonable security model. then later we can add stuff like hackage signing the mapping between packages and keys if that's necessary
14:51:16 <wagle> are you supposed to reverse the string of 7 chants, or reverse each, and chant 7 times?
14:51:40 <SyntaxNinja> alexj: but you should realize that if you're running arbitrary code from "any" trusted user, then they could always just download someone else's package and install it. once you run code, you're trusting them
14:51:42 <SamB> wagle: what do you think this is, C?
14:51:52 <wagle> time complexity
14:51:52 <SamB> they are the *same*
14:52:01 <SyntaxNinja> alexj: so any trust model that differentiates between who can install which packages (from the user's side) is just icing on the cake
14:52:05 <alexj> syntaxninja: but hackage already tracks the mapping between package and keys.  can't you just expose it in the hackage record?
14:52:07 <wagle> space complexity
14:52:13 <arjanoosting> cpjvelde: but you can upgrade packages selectively to unstable anyway so it doesn't matter that you have installed testing
14:52:16 <monochrom> there is a commuting diagram...
14:52:17 <SyntaxNinja> alexj: sure, and we migth do that later.
14:52:18 <SamB> time complexity is O(1) because we have no variables!
14:52:32 <SyntaxNinja> alexj: but in practice, IMO, it's not any more secure.
14:54:02 <monochrom> I suppose reversing a short string and reusing it is more efficient.
14:54:09 <wagle> asymptotic time complexity does little for real time
14:54:20 <alexj> syntaxninja: it is substantially more secure because then the signature actually tells the end-user something.
14:54:32 <cpjvelde> arjanoosting, after reading that apt stuff, its pretty simple actually :) thanks
14:54:37 <alexj> can you expose the package key in the hackage record?
14:54:42 <SamB> especially when there are *no variables* and thus *no assymptotes*
14:54:58 <monochrom> but in the future the compiler will visualize a commuting diagram and choose the more efficient path.
14:55:01 <alexj> (does a hackage record have a formal spec?)
14:55:15 <arjanoosting> cpjvelde: np
14:55:25 <wagle> and the software to midi out the chanting has only n milliseconds to emit the next sound
14:55:33 <SamB> first we have to figure out to get a compiler to visualize!
14:55:37 <SyntaxNinja> I don't know what you mean by hackage record.
14:55:47 <SamB> imaginet that! a compiler with imagination!
14:55:58 <wagle> SamB read my thesis in 2-3 years..  8/
14:56:02 <monochrom> it will laugh at our code
14:56:06 <SyntaxNinja> alexj: do you understand that once you run code from someone, they can do what they want? so if you'r installing a package from user A, you implicitly trust user A.
14:56:06 * SamB needs a spell checker
14:56:59 <SamB> SyntaxNinja: why can't you install a package even though you don't trust the author?
14:57:03 <SyntaxNinja> alexj: like I said twice now. we might add that later.
14:57:09 <alexj> yes, but to attack me somone has to convince me to download package A *in particular* and subvert package A.
14:57:13 <Heffalump> I am right that _foo (to give a name to an unused parameter) is Haskell 98, aren't I?
14:57:19 * SyntaxNinja has to go to a meeting.
14:57:28 <alexj> in the any package any time model.  Somone only has to subvert someone in my trust network.
14:57:39 <SyntaxNinja> SamB: the definitino of trust is that you trust the author to allow them to install a package.
14:57:47 <wagle> matrix multiplication:  A x B x C..  matrices of matching, but different sizes..  which associativity is optimal?
14:58:10 <Heffalump> wagle: depends on the sizes
14:58:15 <Heffalump> (IIRC)
14:58:34 <SyntaxNinja> alexj: You haven't demonstrated that you understand my point about running arbitrary code.
14:58:48 <alexj> I understand your point.  My point is how you end up getting the code.
14:58:49 <wagle> i had the impression it was NP-complete
14:59:05 <Heffalump> wagle: just work out the number of operations required for each option, surely?
14:59:13 <Heffalump> oh, where A x B x C x ... is a long list?
14:59:32 <alexj> in the anyone/anytime model.  a MITM has to subvert hackage and ANY key in my web of trust.
14:59:44 <SyntaxNinja> don't call it the anyone/anytime model.
14:59:53 <Heffalump> it can't be NP-complete, there's only a quadratic number of ways to bracket that (aren't there?)
14:59:53 <wagle> doesnt seem NP-complete, but real complexity people were poking at it 10 years ago..  (I'm not a real complexity person)
14:59:55 <alexj> in the package ownership model, MITM has to subvert hackage and the owner of the package I actually want.
14:59:56 <monochrom> In the future the compiler will take a longer time.  Here is a scenerio explaining why.  A first-year student writes "reverse $ concat $ take 2 $ map reverse $ repeat "eh"".  The compiler takes 5 minutes to laugh, then 5 milliseconds to replace it with "hehe".
14:59:56 * SyntaxNinja meeting &
15:00:01 <SamB> multiply together matrices that vary together ;-)
15:00:03 <alexj> ok later.
15:00:19 <wagle> there was something surprisingly difficult about it
15:00:46 * Heffalump declares #haskell useless and pulls out his report
15:00:59 <jlouis> wagle: CLRS has the details on that.
15:01:01 <wagle> long list
15:01:08 <wagle> Heffalump: long list
15:01:29 <SamB> well, the one that doesn't take hours to find is probably good in most cases...
15:01:50 <Igloo> alexj: SyntaxNinja: Can you /please/ stop saying web of trust?
15:02:00 <jaap> wagle: that's done as an example in CLRS, I believe
15:02:09 <jaap> bleh, i need to read better
15:02:12 <alexj> igloo: how about cloud of trust :- )
15:02:14 <wagle> CLRS?
15:02:14 <jaap> someone said that
15:02:28 <jaap> Cormen, Leiserson, Rivest, Stein: Intro to Algorithms
15:02:32 <monochrom> what is wrong with w*b *f tr*st?
15:02:35 <jlouis> wagle: what jaap said
15:02:37 <wagle> ah
15:02:37 <Igloo> alexj: I think "web of identity" is a reasonable phrase
15:02:52 <Igloo> monochrom: It gets confused with the concept of trusted keys
15:03:14 <jaap> wagle: it's in the chapter on dynamic programming
15:03:15 <jlouis> wagle: 2nd edition even has a chapter on the bastard
15:03:54 <wagle> there are factorial associations
15:04:20 <alexj> yes, I buy the authentication vs authorization concept in theory.  But the whole point of the gpg web of trust model is to blur them.  to say that an entity that has an identity is also an entity that is trusted to make identity claims.
15:04:22 <wagle> i never did get 2nd edition yet..
15:04:44 <alexj> in fact that is the substance of my objection to the existing hackage security model.
15:04:55 <Igloo> alexj: Yes, but not trusted to write code
15:05:08 <Igloo> Please, just use a different phrase for it?
15:05:13 <wagle> never read first edition.. used purdom and brown instead
15:05:22 <SamB> alexj: I thought you were allowed to say different things about whether you believe someone to be who they claim to be and whether you trust them to do the same about others?
15:07:00 <alexj> samb, the question is how you establish a claim about their identity.
15:07:09 <alexj> or to focus on hackage.
15:07:30 <alexj> the question is whether simply having them in your keyring is enough to authorize them to sign any package.
15:07:44 <alexj> syntaxninja finds that acceptable.  I think it is a problem.
15:07:49 <SamB> oh, they can sign packages all they want ;-)
15:08:13 <SamB> whether or not they are in *my* keyring, anyway.
15:08:26 <alexj> samb: :- )
15:10:07 <alexj> igloo: http://www.google.com/search?hl=en&q=%22web+of+trust%22&btnG=Google+Search http://www.google.com/search?hl=en&q=%22web+of+identity%22&btnG=Google+Search
15:10:33 <alexj> you may be fighting a loosing battle on the usage issue.
15:11:12 <cpjvelde> can i control the search path of ghc through an environment variable?
15:11:30 <Igloo> alexj: I'm asking you to make this particular discussion clearer. Why does everything have to be such a fight with you?
15:11:31 <SamB> so? Isn't Haskell about avoiding success at all costs?
15:12:27 <alexj> igloo: that was just an FYI.  not taking a position one way or another.
15:12:52 <SamB> #haskell and haskell.org are not the internet ;-)
15:13:16 <alexj> :- )
15:13:22 <SamB> the hackage security model discussion is definately not the internet
15:15:29 <autrijus> is haskell about avoiding success anymore?
15:15:37 <autrijus> I thought it's doomed to succeed so we might as well accept it
15:17:37 <SamB> can haskell be successful without continuing to avoid success?
15:18:05 <wagle> just how are you going to get joe programmer to use haskell?
15:18:26 <wli> You don't try to do that.
15:18:37 <jlouis> SamB: We just have to form an open neighbourhood around success
15:18:50 <SamB> heh
15:18:50 <wagle> what is "success"?
15:19:12 <wli> SUccess is one thing, world domination is another.
15:19:43 <wagle> open neighborhood around a small finite set
15:19:59 <jlouis> There is the space of outcomes-of-programming-languages. You can form a topology on it, obviously
15:20:04 <wli> Success is a lot easier and doesn't involve trying to displace C etc.
15:20:04 <monochrom> joe programmers use VB.net.  No one is competing with VB.net.
15:20:26 <wagle> ok..  the success i envision is using haskell to program about other people's programs (which arent haskell)
15:20:29 <SamB> I thought joe used C#
15:21:06 <wagle> nah..  C# is niche
15:21:07 <jlouis> Joe uses C# or Java
15:21:10 <monochrom> There are a lot more VB programmers than C# or Java programmers.
15:21:13 <wli> Code generators, formal methods, rapid construction of domain-speicifc languages, etc.
15:21:14 <wagle> Java is semi-niche
15:21:25 <monochrom> Except that usually we don't say "VB programmers".
15:21:45 <wli> I see Haskell's niche encompassing those areas though not necessarily being limited to them.
15:22:27 <jlouis> ... world domination is when your programming language are listed on thedailywtf.["com", "org"]
15:22:31 <wli> Well, a fair amount of VB is "written" via GUI-building apps, so there are more questions to be raised along that front should one care to investigate it.
15:22:51 <jlouis> We try to avoid it
15:23:20 <wagle> i've just been surrounded by people who think haskell will achieve world domination..  (OGI has no undergrads to whine loudly and endlesskly about how stupid and useless haskell/scheme/etc is in the real world)
15:23:28 <SamB> haskell should not go the way of Python
15:23:46 <wagle> what way did python go?
15:23:53 <SamB> it didn't go yet
15:24:11 <monochrom> I suppress my cliche joke
15:24:24 <SamB> monochrom: cliche joke?
15:24:31 <wli> wagle: Realistic assessments of that need to go about serious surveys of industrial use, which I don't see happening for any purpose whatsoever, including determining things like e.g. whether the Linux efforts of various .com's are actually making any money.
15:24:33 * wagle runs off to do errands
15:24:59 <monochrom> Alright I yield.  The joke suppressed is "the way of Python is removing reduce". :)
15:25:19 <monochrom> perhaps I mean lame joke.
15:25:30 <SamB> well I was more upset about map, filter, and lambda...
15:26:18 <wli> I never really seriously looked at python anyway.
15:26:52 <SamB> its not like I actually use it anymore... but that could change
15:27:32 <SamB> like, say, if I actually had to write code that does things, and write it quickly
15:29:49 <wli> IMHO the path to success is by deeds, not words. The best publicity campaign possible involves some high-impact app/system/etc. written using whatever methods you'd like to promote (e.g. written in Haskell).
15:30:04 <wli> Or several of them. =)
15:36:10 <SyntaxNinja> alexj: 3rd time I'm saying it: I find that acceptable in the _short term_
15:36:21 <Heffalump> I don't think anyone else wants to keep it in the rack at all :-)
15:36:21 <SyntaxNinja> oh, that was the 4th actually.
15:36:50 <Heffalump> ahem.
15:37:20 <SamB> Heffalump: what?
15:37:33 <Heffalump> (sorry, a connectivity outage caused me to say something to the wrong channel)
15:37:51 <jlouis> Heffalump: inside the brain?
15:37:58 <jlouis> I usually get hit by that
15:39:36 <Heffalump> jlouis: no, I'm using a screen session on the other end of ADSL. I typed something and hit enter, but my ADSL had temporarily frozen up. When it came back I attached another client to the screen and switched windows, at which point the first attachment woke up and sent what I typed.
15:40:47 <jlouis> Heffalump: oh, outage by screen then
15:50:30 <alexj> syntaxninja: because if you follow the logic of my point, you might not be investing time in codesigning (you could get more security for less work)
15:51:25 <alexj> I want to talk about the overall security model because I feel like codesigning vs passwords is a server administrative issue not a network architecture issue.
15:52:22 <alexj> (I am assuming there will be more than one hackage server.  if that is incorrect then nevermind)
15:52:45 <alexj> s/architecture/protocol/
15:54:02 <SyntaxNinja> alexj: I suggest you try saying something useful about SSL or whatever your idea is, instead of poking random non-holes in the gpg idea.
15:55:36 <alexj> syntaxninja: I expect that I will end up interacting with hackage so I care about it coming out well.
15:56:29 <alexj> but i'll construct a specific proposal rather than making individual points.
15:56:32 <alexj> fair enough.
15:57:08 <SyntaxNinja> alexj: if you do, please refrain from mentioning the hackage model in comparison.  Try to let your ideas stand up on their own.
15:58:21 <Lemmih> SyntaxNinja: What's the correct way of handling stub files with Cabal?
15:58:31 <alexj> I think you think there is some competition here.  I am specifically wanting hackage to work well.   That is why I am on this issue.
15:58:43 <SyntaxNinja> Lemmih: what do you mean handling them?
15:58:46 <alexj> but, I'll make a specific proposal.
15:59:06 <SyntaxNinja> alexj: I'm not concerned with competition, I'm concerned with misunderstandings due to your inaccurate comments.
15:59:27 <SyntaxNinja> alexj: if you are truly not interested in competition, then I think you would be more fair to my ideas.
16:00:49 <Lemmih> SyntaxNinja: Cabal doesn't recompile stub files when they change, and putting them in C-Sources causes them to be linked twice.
16:01:19 <alexj> syntaxninja.  I'm sorry you feel that way.  I think I have been fair to your ideas.  Otherwise, I would ignore them.
16:01:42 <alexj> your ideas are smart enough to deserve comment/critique.
16:02:05 <SyntaxNinja> alexj: if "the anyone / anytime model" is a fair characterization, you've been reading too much FUD.
16:03:10 <alexj> you said that anyone could sign any package.   So it would be exactly correct to refer to it as the "anyone/anypackage" model.  Would that be beter?
16:03:16 <SyntaxNinja> Lemmih: when should it recompile stub files? shouldn't they just get regenrated when GHC recomples the .hs files?
16:03:31 <alexj> (the name don't sound substantially different to me)
16:04:08 <SyntaxNinja> alexj: how about "any trusted key may sign any package from the client side perspective"
16:04:58 <SyntaxNinja> alexj: to put this in perspective, Debian has not been checking signatures on the client side for years and years, and yet I've heard of NO man-in-the-middle attacks, against a much larger target.
16:05:23 <alexj> thats because debian provides signed release files.
16:05:44 <alexj> if hackage just allowed people to download a signed copy of the underlying database file that would be equivalent.
16:05:58 <SyntaxNinja> alexj: that's in apt 0.6, not in any current debian distribution, and I wrote that code, so don't lecture me on it :P
16:06:40 <Lemmih> SyntaxNinja: Ops my bad. GHC generates and compile them. Cabal just doesn't link with them correctly.
16:07:38 <SyntaxNinja> Lemmih: which version of cabal?
16:07:56 <Lemmih> 1.1
16:09:34 <SyntaxNinja> Lemmih: can you send me an email w/ any details bout how it's incorrectly linking them? It should be linking them. WFM :)
16:09:54 <alexj> syntaxninja: if debian was secure, then why add that feature?
16:10:55 <alexj> note, debian people appear to have been worried about this issue.  see e.g. http://www.debian.org/News/weekly/2000/11/
16:11:40 <alexj> if you implemented it, I assume you care too?
16:15:09 <SyntaxNinja> alexj: actually, the release files are signed by the server, not by the packager, and this is a different issue. it's definitely the case that anyone in Debian can r00t your box by getting you to install a package.
16:16:20 <alexj> right, but if the package does not match the release file  signed by the server you might decide not to install it.
16:16:47 <alexj> my whole point is that the security in the system is provided by the server and not the packager so that is where to focus.
16:17:56 <SyntaxNinja> trust me, release files don't prove your point.
16:19:42 <alexj> ok then we can talk about hackage and not debian.
16:20:31 <alexj> but something needs to let cabal build-depends chase.
16:20:59 <SyntaxNinja> I brought up Debian to demonstrate that the kind of _extremely_ complex (and non-automatable) MITM attack you're describing is not somethig i'm worrie about for the beta release of hackagedb
16:21:34 <SyntaxNinja> I gotta go.
16:21:35 * SyntaxNinja &
16:21:44 <alexj> l8r
16:59:48 <wli> A corresponding list of my own would be lengthy.
17:10:43 <moomlyn> sweetie?
17:12:05 <ski> hiya moomlyn
17:13:01 <moomlyn> hi ski *grin*
17:13:11 <ski> heh
17:14:09 * ski thought moonlyn was mostly in #math ..
17:48:51 <SamB> @pl ((,) x)
17:48:53 <lambdabot> (,) x
17:49:02 <SamB> @pl (x, )
17:49:03 <lambdabot> (line 1, column 3):
17:49:03 <lambdabot> unexpected ","
17:49:03 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:49:26 <SamB> @pl (,x)
17:49:27 <lambdabot> (line 1, column 2):
17:49:27 <lambdabot> unexpected ","
17:49:27 <lambdabot> expecting lambda abstraction or expression
17:49:33 <SamB> @plugs (,x)
17:49:37 <lambdabot> parse error on input `x'
17:49:49 <SamB> why can't you take right or left sections of (,)
17:49:52 <SamB> ?
17:51:29 <SyntaxNinja> who's going to ICFP this year?
17:56:21 <SyntaxNinja> gotta go. l8r all
18:01:28 <SamB> @pl a -> [a]
18:01:29 <lambdabot> (line 1, column 3):
18:01:29 <lambdabot> unexpected ">" or "-"
18:01:29 <lambdabot> expecting variable, "(", operator or end of input
18:01:34 <SamB> @pl \a -> [a]
18:01:35 <lambdabot> (: [])
18:02:55 <ski> @pl \a -> [(a -)]
18:02:56 <lambdabot> (: []) . (-)
18:03:36 <SamB> what is that for?
18:06:32 <ski> nothing
18:06:53 <ski> just tried to get lambdabot to generate a nicer smiley
18:07:05 <ski> but my evil scheming failed :(
18:07:21 <SamB> you must learn evil haskelling instead ;-)
18:08:13 <ski> or, maybe, learn to go to sleep when the body feels exhausted ..
18:09:59 <ski> SamB : i guess (,) isn't formally a section (compare with more general (special cases of) "mixfix" (,,) , (,,,) , ...)
18:11:17 <SamB> hmm
18:17:29 <dons> @type ((,) 2)
18:17:34 <lambdabot> ((,) 2) :: forall a b. (Num a) => b -> (a, b)
18:24:28 <jaap> SamB: for inexplicable reasons i looked at the logs and saw that you asked about barendregt. He's a mathematician at Radboud Uni in Nijmegen (NL), who thought of this thing he calls the lambda cube but other ppl call the Barendregt cube. I honestly don't really recall what it is (nor whether I have ever known), but John uses it in jhc I believe
18:24:44 * jaap goes have dinner
18:32:39 <jaap> it's in ch. 30 of TaPL, actually;  it's a diagram that relates various type systems, if that makes it any clearer ;-)
18:32:42 * ski thinks (ihrc) the lambda cube has to do with relating different versions of the lambda calc. (monomorphic/polymorphic , other decisions) to each other .. or something like that
18:36:22 <ski> SamB : also http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm
18:46:25 <SamB> @pl \(x, y) -> (f x, y)
18:46:26 <lambdabot> first f
18:46:45 <SamB> @pl \(x, y) -> ([x], y)
18:46:46 <lambdabot> first (: [])
19:32:30 <foxy_> @plugs id
19:32:32 <lambdabot> <Plugins.Eval>:1:
19:32:32 <lambdabot>   No instance for (Show (a -> a))
19:32:32 <lambdabot>   arising from use of `show'
19:35:42 <foxy_> @plugs typeOf id
19:35:43 <lambdabot> Ambiguous type variable `a' in the top-level constraint
19:37:39 <foxy_> @plugs typeOf undefined
19:37:40 <lambdabot> Ambiguous type variable `a' in the top-level constraint
19:38:58 <foxy_> *Main> :t id
19:39:06 <foxy_> id :: a -> a
19:44:26 <wli> use an explicit type signature
19:45:19 <SamB> @type id
19:45:20 <lambdabot> id :: forall a. a -> a
19:45:32 <SamB> @type undefined
19:45:34 <lambdabot> undefined :: forall a. a
19:45:38 <SamB> @type typeOf
19:45:39 <lambdabot> bzzt
19:46:06 <Lemmih> @type Data.Typeable.typeOf
19:46:07 <lambdabot> Data.Typeable.typeOf :: forall a.
19:46:07 <lambdabot>         (Data.Typeable.Typeable a) =>
19:46:07 <lambdabot>         a -> Data.Typeable.TypeRep
19:46:22 <Lemmih> @type Data.Dynamic.typeOf
19:46:24 <lambdabot> Data.Dynamic.typeOf :: forall a.
19:46:24 <lambdabot>         (Data.Typeable.Typeable a) =>
19:46:24 <lambdabot>         a -> Data.Typeable.TypeRep
20:08:52 <SamB> @pl \d -> size d == 0
20:08:53 <lambdabot> (0 ==) . size
20:09:18 <SamB> {-# OPTIONS_JHC -fcpp #-} does not work very well
20:10:02 <JohnMeacham> SamB: That doesn't surprise me. it would have to back out of the parser and reread the file via cpp.
20:10:48 <SamB> JohnMeacham: GHC doesn't seem to parse much at all before it processes dependencies...
20:11:07 <JohnMeacham> But I supose it would be useful. especially since it is tricky to apply options to just some files on the command line.
20:11:16 <SamB> I noticed I didn't get a parse error in one module I was working on until I fixed a type error in a module it imported...
20:11:44 <SamB> (with GHC)
20:12:14 <JohnMeacham> Hmm? how can you compile something if its dependencies arn't compiled first?
20:12:49 <SamB> you can't, but you might try to parse it
20:13:20 <SamB> I suppose you can't parse far anyway though
20:13:29 <SamB> since you have to worry about fixities...
20:13:45 <JohnMeacham> oh. you mean with --make? yeah, that is sort of hacked on before the actual compiler proper just doing enough to get the dependencies.
20:14:23 <SamB> I think GHC requires {-# OPTIONS #-} to be before the module declaration, so it shouldn't be hard...
20:14:32 <SamB> er, OPTIONS_GHC now.
20:14:50 * SamB wonders if some version of the standard will define {-# OPIONS #-}
20:14:52 <JohnMeacham> ghc always assumes it has proper 'hi' files (or hi-boot) for modules it depends on. jhc computed the full transitive closure of required modules in order to support mutually recursive modules properly.
20:15:06 <JohnMeacham> SamB: I hope not.
20:15:24 <SamB> JohnMeacham: it would be nice to have a few standard options, I think.
20:15:53 <JohnMeacham> SamB: There can be conventions, but it shouldn't be in the language spec.
20:16:03 <SamB> whatever
20:16:43 <JohnMeacham> sort of like how the language spec specifically leaves out anything to do with files or directories.
20:17:25 <Gahhh> unlike visual basic
20:17:28 <JohnMeacham> not that it would be impossible to do the -fcpp thing. I just need to add a way for it to back out and reparse.
20:18:09 <Trevion> I feel like the fewer features Haskell shares with Visual Basic, the better off we'll all be.
20:18:26 <SamB> VB has a spec?
20:18:26 <Gahhh> fortunatley there is such a trend, yes
20:19:04 <Gahhh> vb.net has, iirc. even a ebnf grammar, tee hee.
20:20:16 <JohnMeacham> cabal specifies a semi-standard compiler independent pragma for specifying language extensions. that makes more sense to make portable rather than OPTIONS.
20:21:07 <SamB> are they taking (n+k) patterns out of the next Haskell spec?
20:21:43 <SamB> JohnMeacham: oh, sure
20:22:56 <JohnMeacham> No one knows. It is hard to say what the next haskell spec will look like since things seem to be progressing as extensions to haskell 98 rather than incompatable new specs.
20:23:27 <SamB> I think the Prelude needs trimming
20:23:40 <SamB> wouldn't that require a new spec?
20:23:46 <JohnMeacham> Yeah, that is a common thought.
20:24:09 <Gahhh> it would. the report defines Prelude.
20:25:05 <JohnMeacham> I think we would need to wait until someones 'NewPrelude' became popular. In general, the haskell community likes to try things out a while before standardizing them.
20:25:46 <Gahhh> doesnt simonM have a new IO library or something ?
20:25:56 <SamB> a new IO library?
20:26:13 <JohnMeacham> I am working on an extension to make it easier to migrate to a new prelude.. since that is something I wanted to explore with jhc.
20:28:11 <JohnMeacham> Yeah, it is probable it will be replaced in pieces. like a new IO library as a unit, then perhaps a better thought out numerical hierachy, the new time library. then once everyone is using these 'new' libraries everyone will try to figure out which ones should be declared part of the new standard and what should be officially deprecated.
20:29:09 <Gahhh> yeah someone else has a new Numeric module too
20:29:09 <SamB> I think flat libraries (besides the toplevel Prelude) should be deprecated...
20:29:12 <JohnMeacham> Or I should say, experiment with a new prelude. I'd like to see 3 or 4 competing prelude designs that can coexist before settling down on something new.
20:29:52 <JohnMeacham> SamB: they more or less are. At least, no new ones are being made.
20:30:16 <SamB> what I meant was, replace references to them in the standard with the heirarchical names
20:31:44 <JohnMeacham> That would be problematic. Data.List is not compatable with List for instance and is a moving target. In order to put Data.List in the standard we'd have to standardize what routines it contains and we are back to the creating a new prelude problem
20:32:50 <SamB> hmm
20:32:58 <SamB> okay then maybe not.
20:33:39 <JohnMeacham> I mean, yeah we should do that when we define a new prelude definitly. in the meantime it is handy to have them seperate since we can experiment in the hierarchitaical ones without breaking haskell 98 programs.
20:34:55 <SamB> are there any left?
20:36:57 <JohnMeacham> Yeah, I always try to write to the standard unless absolutely needed. I worry about haskell becoming an implementation defined language, which is a bad thing.
20:37:28 <MachinShin> how many implementations are there? like 3-4 right?
20:37:30 <SamB> true...
20:38:06 <JohnMeacham> Plus, it makes things easier, I have run into problems where importing Data.List rather than List causes programs to break with new cvs versions of ghc since it adds functions, might as well stick with the standard and not have to worry about such things.
20:38:15 <SamB> GHC, hugs, nhc, and now jhc
20:39:23 <JohnMeacham> hbc used to be da bomb. it tends to switch around.
20:40:23 <JohnMeacham> but ghc is definitly where all the development is at. I worry (not seriously, but a little) the next haskell spec will say 'Whatever GHC does'.
20:41:00 <SamB> JohnMeacham: you know the GHC people are smarter than to let the Haskell standard say that!
20:41:16 <MachinShin> SamB: say it no. but effectively do that? :)
20:41:52 <SamB> well that would be better than what we have now, because then we would have a specification of what GHC does.
20:42:37 <JohnMeacham> Yeah.
20:43:28 <SamB> Hopefully they'l not put all of that in the one report, of course, since I think most people would like to see extension specs first...
20:45:48 <JohnMeacham> Yeah. I imagine that the next version of haskell will look like a lot of independent extensions, the same basic haskell 98 language core we have now, new libraries, and perhaps the only syntatic incompatability being a new record syntax.
20:46:07 <JohnMeacham> new as in replacing the old libraries/prelude.
20:47:57 <SamB> what about the hierarchical module syntax?
20:51:00 <JohnMeacham> that will go in. but it is not syntatically incompatable because it doesn't make old programs not work. however, changing what the record syntax does would break old programs.
20:51:26 <SamB> It can.
20:51:32 <JohnMeacham> that is what I meant bi independent extensions.
20:51:46 <JohnMeacham> rarely :) but true, it can.
20:51:58 <SamB> not often I'm sure ;-)
20:52:50 <JohnMeacham> Hmm.. yeah, some of the new record proposals also change the meaning of . with no spaces around it... so that could be a big change too.
21:25:49 <foxy_> I'd prefer . to stay as it is instead of being changed to #, which would be possible if surrounding spaces matter
21:26:34 <SamB> foxy_: say what?
21:26:50 <SamB> GHC already uses # pretty extensively
21:27:09 <SamB> I don't think you'll see it in the standard any time soon...
21:27:18 <foxy_> yeah, one of the records papers suggests # for composition
21:29:49 <SamB> ugly!
21:30:28 <SamB> I'm sure lowId.lowId syntax is still free, anyway
21:30:45 <SamB> @t id.id
21:30:46 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
21:30:46 <lambdabot> init topic-snoc topic-tail topic-tell type pl wn
21:31:07 <SamB> @type id.id
21:31:09 <lambdabot> id.id :: forall a. a -> a
21:31:23 * SamB does not see how he could have meant pl or wn
21:32:05 <SamB> well, I mean, what with . with no space around it being discouraged for composition and all...
22:23:40 <Denvull> I don't understand the "binary type constructor" (->)
22:24:45 <Cale> a -> b is the type of functions from a to b
22:25:32 <Denvull> Should I be looking at it as though a is the argument and b the return type?
22:25:36 <lispy> Denvull: maybe the name binary is confusing you.  So don't think binary as in true/false or 1/0
22:25:50 <Cale> yeah
22:25:50 <Cale> a -> b = (->) a b
22:25:55 <Cale> in case that's the confusing part
22:26:27 <crab> hi.
22:26:34 <Cale> Integer -> String, for example, is the type of functions from Integers to Strings
22:26:40 <Cale> crab: hello
22:26:59 <Denvull> Okay, that makes sense I suppose
22:27:20 <Cale> -> is right associative, which means that a -> b -> c = a -> (b -> c)
22:27:54 <Cale> that is, a -> b -> c is the type of functions which take a value of type a, and return a function of type b -> c
22:28:12 <Cale> @type (+)
22:28:13 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
22:28:17 <Denvull> But when constructing a type equation for an application f E, I don't understand how the equation is f = E -> f E
22:29:09 <lispy> i don't understand f = E -> f E
22:29:28 <Cale> Yeah, I'm not sure what that syntax is -- it's certainly not Haskell :)
22:29:32 <lispy> can you give more context?
22:29:49 <Denvull> Well I hope I'm reading it off the lecture slide correctly :P
22:29:53 <SamB> @google Cayenne
22:29:55 <lambdabot> http://www.objectstyle.org/cayenne/
22:30:07 <lispy> @google google
22:30:08 <lambdabot> http://www.google.com/
22:30:14 <SamB> @google Cayenne haskell
22:30:15 <lambdabot> http://www.cs.chalmers.se/~augustss/cayenne/
22:30:24 <lispy> @google google fight
22:30:25 <lambdabot> http://www.googlefight.com/
22:30:43 <crab> i decided to learn haskell this week.
22:30:55 <lispy> crab: good for you
22:31:13 <Denvull> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/12.pdf
22:32:14 <Denvull> I'm looking at the last page where it says " - eg. for an application fE we have the equation: r121 = r122 -> r12"
22:33:10 <Cale> ah, yes
22:33:18 <SamB> hmm, for some reason f = E -> f E reminded me of that but I can't find anything that looks like that...
22:33:30 <SamB> (cayenne, I mean)
22:33:43 <foxy_> Denvull: It should be r121 :: r122 -> r12 (note the double semicolon)
22:33:52 <foxy_> for haskell syntax
22:34:01 <Cale> no
22:34:16 <Cale> r121, r122 and r12 are all type variables
22:34:18 <SamB> there is no = in haskell types...
22:34:20 <Denvull> But it's not a function definition
22:34:26 <Cale> It's explaining the inference
22:34:32 <foxy_> it's a type signature
22:34:33 <Denvull> yep, type inference
22:34:47 <Cale> so
22:34:51 <foxy_> ignore me
22:34:51 <Cale> what it says
22:35:44 <SamB> how can you explain type inference without long lines?
22:36:34 <Cale> is that if f x :: b, f :: c -> d, and x :: a, then c = a and b = d
22:36:36 <Denvull> Well I don't need type inference explained to me just yet, I just want to understand how this binary type constructor defines a type
22:37:00 <Cale> Denvull: well, have you written much Haskell code?
22:37:11 <Denvull> Yeah, a fair bit
22:37:19 <SamB> @google system f
22:37:20 <lambdabot> http://www.cs.cornell.edu/talc/papers/tal-popl.pdf
22:37:36 <Cale> You probably use the -> all the time in declaring the types of your functions
22:37:42 <Denvull> Yep
22:38:36 <Cale> If a and b are types, then a -> b is the type of all functions which take a value of type a as a parameter and return a value of type b.
22:38:50 <Denvull> Yep
22:38:54 <Cale> that's pretty much it :)
22:39:29 <Denvull> Heh ok, I'll see how I go
22:39:40 <Denvull> Thanks Cale :)
22:40:01 <SamB> if a and b are implicitly quantified type variables, than a -> b is the type of all functions that map values of any type to values of any other type... which would have to mean ignoring the argument and producing bottom...
22:40:53 <Cale> SamB: I didn't implicitly quantify them though :)
22:40:56 <Cale> hehe
22:41:03 <foxy_> @type GHC.Base.unsafeCoerce#
22:41:05 <lambdabot> GHC.Base.unsafeCoerce# :: forall b a. a -> b
22:41:21 <Cale> that's a terrible example :)
22:41:25 <SamB> foxy_: now you know that does *not* count!
22:41:34 <foxy_> :P
22:42:11 <SamB> @plugs GHC.Base.unsafeCoerce# (Just 1) :: Int
22:42:13 <lambdabot> Variable not in scope: `GHC.Base.unsafeCoerce'
22:42:26 <SamB> @pl GHC.Base.unsafeCoerce# (Just 1) :: Int
22:42:28 <lambdabot> (line 1, column 22):
22:42:28 <lambdabot> unexpected "#"
22:42:28 <lambdabot> expecting letter or digit, variable, "(", ".", space, operator or
22:42:28 <lambdabot> end of input
22:42:28 <lambdabot> ambiguous use of a left associative operator
22:43:23 <SamB> Prelude> :set -fglasgow-exts
22:43:23 <SamB> Prelude> GHC.Base.unsafeCoerce# (Just 1) :: Int
22:43:23 <SamB> zsh: segmentation fault  ghci
22:44:16 <SamB> what is unsafeCorece# for anyway?
22:44:29 <SamB> er, s/re/er/
22:44:34 <Lemmih> Grep GHC and you'll see.
22:44:54 <SamB> you mean the compiler or the library?
22:45:42 <Lemmih> It's used in both.
22:47:14 <SamB> so that is a primop, huh...
22:48:05 * SamB wonders if a thread-safe non-primitive unsafeCoerce can be written?
22:51:17 <dons> thread safe? isn't it already thread safe?
22:51:31 <dons> why wouldn't it be.. it's a noop at runtime.
22:52:49 <Lemmih> @seen shapr
22:52:50 <lambdabot> I saw shapr leaving #haskell 2 days, 6 hours, 41 minutes and 26
22:52:50 <lambdabot> seconds ago, and I have missed 10 seconds since then.
22:53:25 * wli gets stabbed in the toe by a severely weatherbeaten copy of "The Bird-Larsen Attack"
22:54:03 <Denvull> Cale, did you read how r11 and r12 were being assigned to the LHS and RHS of those equations?
22:58:50 <Denvull> These type equations are really confusing me, take a look at http://brent.bur.st/haskell/eg2.txt and underneath "(MY TRANSLATION)" you will see which one I get stuck on.
23:10:54 <SamB> dons: of course that one is thread-safe.
23:11:00 <SamB> but that one is a primop!
23:11:10 <dons> it's a type inference macro, really.
23:11:19 <SamB> I am wondering if it can be done threadsafe without making it a primop...
23:11:32 <dons> perhaps look at Dynamic.cast ?
23:11:32 <SamB> even noops can be primops!
23:11:57 <SamB> I don't actually want to use it ;-)
23:16:08 <SamB> it looks like it gets used about three times in the entire library...
