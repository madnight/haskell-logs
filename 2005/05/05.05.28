00:00:35 <[TWiSTED]> where can the read go?
00:02:06 <kaol> how about: parseFormula s = [(name, read s')]
00:02:27 <kaol> and the rest as it is (minus that read on the last row)
00:02:38 <[TWiSTED]> ok ill try that
00:02:53 <[TWiSTED]> omg champ
00:02:55 <[TWiSTED]> it works
00:02:58 <[TWiSTED]> but
00:03:06 <[TWiSTED]> doesnt do the next 'part'
00:03:27 <[TWiSTED]> parseFormula "hi34hey56" -> [("hi",34)]
00:03:39 <kaol> well, you can use parseFormula for rest' too.
00:04:01 <[TWiSTED]> so like
00:04:12 <[TWiSTED]> (s', rest') = parseFormula rest
00:04:29 <kaol> no
00:04:48 <kaol> but give rest' to parseFormula instead
00:05:19 <kaol> think of what rest''s value is
00:06:04 <[TWiSTED]> o yeh rest' would be the rest of the string heh
00:07:52 <kaol> for your sanity, put parseFormula [] = [] before parseFormula s = ...
00:07:57 <kaol> to handle the trivial case
00:08:04 <[TWiSTED]> o ye
00:09:05 <kaol> then, as you have it now, you have a function to parse one part of strings like "abc123" and have at hand the rest of such strings too
00:09:05 <[TWiSTED]> is this what u mean
00:09:05 <[TWiSTED]> (s', parseFormula rest') = break (not . isDigit) rest
00:09:14 <kaol> no
00:09:48 <kaol> think of the line parseFormula s = [(s, rest)]
00:09:58 <kaol> all the rest are just fine now, don't touch them
00:10:00 <[TWiSTED]> ooo
00:10:23 <[TWiSTED]> wait
00:10:24 <[TWiSTED]> but i got
00:10:27 <[TWiSTED]> parseFormula s  = [(name, read s')]
00:10:38 <kaol> yeah, sorry, my bad
00:10:44 <kaol> that's correct
00:10:46 <kaol> think of that line
00:11:02 <kaol> hint: ++
00:11:02 <[TWiSTED]> ok
00:11:06 <[TWiSTED]> oo
00:11:38 <[TWiSTED]> fuckin awesome
00:11:41 <[TWiSTED]> parseFormula s  = [(name, read s')] ++ parseFormula rest'
00:12:10 <kaol> right!
00:12:23 <[TWiSTED]> thanks heaps man
00:12:35 <[TWiSTED]> and thanks Lemmih if ur still here
00:12:36 <kaol> but instead, parseFormula s  = (name, read s'):parseFormula rest' would be even better
00:12:45 <[TWiSTED]> o ok
00:12:49 <kaol> no need for append here
00:13:17 <[TWiSTED]> ehe it comes up with an error if i put that instead
00:13:26 <kaol> hmm.
00:13:48 <[TWiSTED]> o wait
00:14:24 <[TWiSTED]> yea i didnt take out the square brackets
00:14:29 <[TWiSTED]> my bad
00:21:09 <musasabi> morning
00:23:44 <[TWiSTED]> wish wordpad had line markings
00:25:25 <mauke> are you writing programs in wordpad?
00:25:32 <[TWiSTED]> ye
00:25:44 <mauke> why god why
00:25:47 <[TWiSTED]> hahah
00:25:51 <[TWiSTED]> what do u recommend
00:26:17 <musasabi> For Haskell emacs is quite good.
00:26:19 <mauke> gvim
00:26:26 <[TWiSTED]> true
00:26:31 <[TWiSTED]> yeh gvim is alright
00:26:33 <mflux> search for programmer's editor on the web, you must find something
00:26:41 <mflux> although I prefer (x)emacs
00:28:29 <mflux> ghc should produce more accurate (locationwise) error diagnostics though, so the editor would be able to highlight the stuff like in many other languages ;)
00:28:42 <mflux> it does make an effort to describe the location though
00:35:27 <dons> it is very good with accurate position information - this was added so that the visual studio ghc plugin could highlight source errors
00:36:28 <mflux> oh
00:36:38 <mflux> how is it enabled?
00:36:59 <dons> use ghc 6.4. the errors messages contain line and column ranges for the errors
00:37:09 <mflux> oh right, I still have 6.2
00:39:12 <mflux> I guess haskell-mode needs some upgrading before it knows about those
01:18:06 <boegel> @seen Pseudonym
01:18:07 <lambdabot> I saw Pseudonym leaving #haskell 2 days, 1 hour, 42 minutes and 52
01:18:07 <lambdabot> seconds ago, and I have missed 7 seconds since then.
01:31:54 <lispy> lambdabot: what do you mean you have missed 7 seconds?
01:33:01 <lispy> explain yourself!
01:33:14 <lispy> @take-me-to-your-leader
01:33:15 <lambdabot> Unknown command, try @listcommands.
01:33:19 <mflux> I guess there have been 7 seconds he hasn't been on the channel?
01:33:26 <kaol> @vixen where did those seconds go?
01:33:27 <lambdabot> When i get kinky, i have been known to engage in watersports... Does
01:33:27 <lambdabot> that turn you on as well?
01:33:48 <kaol> that explains it. the bot had gone to play in water.
01:33:56 <lispy> heh, yeah
01:34:01 <lispy> makes a lot more sense now
01:34:10 <lispy> for some values of sense
01:34:36 <kaol> eep, sense not defined for the whole domain. bad function.
01:35:00 <kaol> wait, sense _is_ the domain. never mind.
01:35:31 <lispy> foo :: sense -> ???
01:35:47 <lispy> or mkSense :: a -> sense
02:06:48 <GroMeZ> hi
02:07:02 <Lemmih> yo
02:07:09 <dblhelix> hi GroMeZ
02:07:43 <GroMeZ> I want to implement the minimax function for a tic tac toe game but I don't know how it works :(
02:08:18 <GroMeZ> someone have an example of it ?
02:10:19 <dblhelix> nope, no examples, sorry
02:11:23 <GroMeZ> ok, thanks
02:12:07 <Lemmih> minimax?
02:12:33 <GroMeZ> yes, it's a tree search algorithm
02:12:46 <musasabi> Is there a way to get "class A ; class B ; class C ; instance B a => A a ; instance C a => A a" ?
02:13:19 <dblhelix> musasabi: not in Haskell 98 ;)
02:13:24 <musasabi> This should be safe as long as there is no type which is not a member of both B and C.
02:13:39 <musasabi> What should I feed GHC to make it acceptable?
02:13:59 <dblhelix> glasgow-exts and allow-overlapping-instances, I guess
02:14:02 <musasabi> s/not a//
02:14:49 <musasabi> That does not help.
02:15:31 <musasabi> First it complains that I need -fallow-undecidable-instances, and with that about "Duplicate instance declarations".
02:16:25 <dblhelix> yes, I see
02:16:35 <dblhelix> so, then, maybe you're screwed ;)
02:17:38 <dblhelix> I know Bastiaan Heeren en Jurriaan Hage address this and introduce a "disjoint" directive with which you can specify that no type can be an instance of both B and C
02:17:57 <dblhelix> but I see that is of little practical use for you now
02:19:43 * musasabi is trying to first encode B with an existential and then just sidestep the issue.
02:20:27 <dblhelix> what if you write:
02:20:41 <dblhelix> instance (B a) => A (WrapB a)
02:20:50 <dblhelix> instance (C a) => A (WrapC a)
02:20:55 <dblhelix> data Wrap a
02:21:00 <dblhelix> data WrapB a
02:21:06 <dblhelix> data WrapC a
02:21:15 <dblhelix> forget about the first data :)
02:21:45 <dblhelix> and proceed from there
02:22:27 <musasabi> That works, now only to handle the wrapping.
02:23:40 <dblhelix> instead of f :: (A a) => ... a ... you get f :: (A (f a)) => ... a ... or isn't that allowed?
02:24:50 <dblhelix> seems to work, but I don't like it that much
02:25:11 <dblhelix> I'll have to think about it some more :)
02:25:22 <dblhelix> let me know if you find a more elegant solution
02:26:05 <musasabi> I think I found a cludgy way of doing it:
02:26:42 <musasabi> for each instance of B: instance B b => A (expanded instance here)
02:31:13 <musasabi> My final instance was "instance (ShowTransform t, ReadTransform (a -> IO ())) => ShowTransform ((a -> IO ()) -> t)"
02:39:37 * boegel swears on his CG course
02:40:33 <foxy> ghc implements typeclasses as dictionaries, are thsse compiled away or are they present in the object code?
02:42:13 <earthy> both :)(
02:50:46 * boegel dances around a bit
03:13:58 <wilx> @moo
03:13:59 <lambdabot>          (___)
03:13:59 <lambdabot>          (o o)
03:13:59 <lambdabot>   /-------\ /
03:13:59 <lambdabot>  / |     ||O
03:13:59 <lambdabot> *  ||,---||
03:13:59 <lambdabot>    ~~    ~~
03:14:01 <lambdabot>      Bull
03:14:08 <wilx> Tee hee hee.
03:16:56 <Philippa> foxy: depends whether it's possible to compile them away, no?
03:36:55 <bourbaki> moin
03:46:01 <boegel> hey bourbaki
03:48:14 <bourbaki> boegel: hows it going?
03:48:44 <boegel> bourbaki: I'm studying for my CG final on Monday
03:48:46 <foxy> Philippa: Iim trying to understand whether a function like Show a => a -> String can be dynamically loaded.
03:48:50 <boegel> but it's quite boring :(
03:50:48 <dons> foxy, if it's in an export list, then it's required that the exported value has this type, no? otherwise it wouldn't work in the presence of separate compilation and (static) linking. dynamic linking adds nothing new. it's late static linking ;)
03:51:22 <dons> this wouldn't work:
03:51:23 <dons> Prelude> :t show
03:51:23 <dons> show :: (Show a) => a -> String
03:51:23 <dons> Prelude> show 1
03:51:23 <dons> "1"
03:51:49 <foxy> @plugs typeof show
03:51:54 <lambdabot> Variable not in scope: `typeof'
03:51:55 <foxy> @plugs typeOf show
03:51:57 <lambdabot> Ambiguous type variable `a' in these top-level constraints
03:52:28 <bourbaki> i guess i just managed to not pass my math exam :)
03:52:50 <boegel> bourbaki: omg :) what kind of math ?
03:52:55 <foxy> dons: are you saying that "show"couldn't be dynamically loaded?
03:53:11 <bourbaki> boegel: analysis i guess that means that i wont finish my study
03:53:11 <dons> it must be able to be loaded, otherwise it wouldn't work in ghci
03:53:22 <boegel> bourbaki: :s
03:53:24 <dblhelix> boegel: CG?
03:53:31 <boegel> dblhelix: computer graphics
03:53:43 <boegel> bourbaki: just because of 1 course ?
03:53:49 <bourbaki> boegel: but i dont really care ill just get a real job
03:54:06 <bourbaki> boegel: i need to pass that to be allowed to go to the final exam
03:54:16 <bourbaki> boegel: and i need that to get my bsc
03:54:21 <dons> the fact that typeOf has a Typeable constraint is another issue.
03:54:23 <dons> @plugs typeOf (show :: Int -> String)
03:54:25 <lambdabot> Int -> [Char]
03:54:41 <foxy> dons: *Main> let foo = show
03:54:52 <foxy> *Main> :t foo
03:55:00 <foxy> foo :: Integer -> String
03:55:14 <boegel> bourbaki: you'll find a job in IT without a CS degree ?
03:55:15 <dons> that's ghci's defaulting, isn't it?
03:55:39 <bourbaki> boegel: i guess so but i am fed up with codeing
03:55:40 <jlouis> boegel: just did, no problemo ;)
03:55:47 <dblhelix> bourbaki: never considerded to pursue a career in academia; you sure need a degree then
03:56:25 <bourbaki> id rather like to do something at the fresh air
03:57:06 <bourbaki> maybe im gonna make a certificate to lead tracks near the woods i am liveing
03:57:15 <foxy> dons: when you load a function you look up some mangled name ending in "_closure", does that code (if necessary) include code to resolve ad hoc polymorphism?
03:57:21 <boegel> bourbaki: does that mean you won't help wtuh H3D? :)
03:57:39 <bourbaki> that is for fun
03:58:03 <bourbaki> boegel: btw theres a guy in #ogre3d who wants to write a c interface for ogre to wrap it with D
03:58:24 <dblhelix> boegel: did you get any reactions on your postings to the haskell mailing lists?
03:58:26 <bourbaki> so if he either finds a c interface or writes one hell let me know
03:58:45 <boegel> dblhelix: yeah, from someone who won't be back before June 6th (auto-reply)
03:58:50 <boegel> other than that, none at all :(
03:58:57 <dblhelix> :)
03:58:59 <foxy> dons: because I can imagine that most typeclass code can be resolved during  compilation?
03:59:38 <dons> foxy, but normal separate compilation has the same issue
03:59:57 <foxy> ah, good point... hm
04:00:34 <dblhelix> boegel: never cared paid much attention to CG and I am still a bit intimidated by matrices and linear algebra; otherwise ... ;)
04:01:27 <dons> btw, foxy, I have a possible bug report to check with hs-plugins and cygwin
04:01:50 <boegel> dblhelix: the problem is the final is Monday, and I haven't sutdied on it because of my thesis
04:01:52 <foxy> dons: I'm thinking about dynamically applying polymorphic functions (which Dynamic can't handle)
04:02:12 <dblhelix> boegel: what's your thesis about?
04:02:12 <foxy> dons: I'll help with the bug if I can
04:02:18 <dons> ah! did you look at  the rank-N soln -- which still uses Typeable -- in the hs-plugins paper?
04:02:28 <dblhelix> boegel: if you don't pass it on Monday, do you get another chance?
04:02:41 <boegel> dblhelix: yeah, but I don't want one :)
04:02:41 <dons> i'll forward you the problem code
04:02:52 <boegel> I want to pass it the first time
04:03:07 <dblhelix> boegel: and your thesis? is it finished?
04:03:12 <boegel> it's my final year, and I would want one last big vacation before I start working
04:03:23 <boegel> dblhelix: yes, I'll pick it up in the copy shop this afternoon
04:03:36 <dblhelix> boegel: what's it about?
04:03:40 <boegel> dblhelix: if you want to read it, let me know :)
04:03:48 <boegel> dblhelix: writing a raytracer in Haskel (duh)
04:03:59 <dblhelix> boegel: cool
04:04:13 <dblhelix> boegel: surely I want to read that (H)
04:05:22 <dblhelix> boegel: do you have a link to it?
04:06:51 <boegel> dblhelix: check PM
04:07:14 <boegel> brb
04:10:45 <boegel> dblhelix: if you give my your email-address, I could mail it to you
04:12:36 <foxy> dons: I've tried using "Symbol (forall a.a)" but get seg faults when I apply functions (even when I know the types are correct)
04:12:54 <dons> foxy, the ad hoc polymorphism code is added in when you compile the module you want to load. if you do no type checks, then it's possible to play tricks: if an application expects an Int, and you load a Num a => a value, you'll get a segfault when you try to use Num a => a as an Int, unless the Int constraint is somehow around when you compile the plugins.
04:13:34 <dons> Symbol (forall a. a) should be ok. can you construct a small test case?
04:13:52 <foxy> dons I can send you my test rig
04:14:06 <dons> ok.
04:15:48 <foxy> I'm using unsafeEval btw
04:16:28 <dons> should be ok. plugs uses this too
04:17:08 <boegel> does anyone know if it would be possible to write an interface to ogre3D with Haskell (without using an intermediate C interface)
04:17:13 <dons> foxy, just means you can compile anything, but you have to provide some other evidence as to the type of the compiled value.
04:17:29 <dons> boegel, what's ogre3D written in?
04:17:36 <foxy> ghc uses "data HValue = HVal (forall a.a)" for the types of expressions compiled by ghci
04:17:37 <dons> or is it hardware??
04:17:50 <dons> interesting.
04:18:23 <dons> but ghci is quite different - you're seeing the results of the interpreter values.
04:18:39 * boegel doesn't know
04:18:41 <dons> and then there's some magic of interfacing interpreted bytecode with compiled code.
04:19:01 <bourbaki> ogre is c++
04:19:01 <dons> System.Haskell.eval should use the ghci bytecode interpreter
04:19:10 <boegel>  OGRE (Object-Oriented Graphics Rendering Engine) is a scene-oriented, flexible 3D engine written in C++ designed to...
04:19:33 <dons> C++. then you've got to do whatever people do to talk to C++
04:20:37 <boegel> and what's that ? :)
04:21:21 <dons> google will be your friend.
04:22:13 <bourbaki> ?
04:22:22 <bourbaki> i guess the question boils down to
04:22:34 <bourbaki> can you write an interface to c++ classes in haskell
04:22:43 <bourbaki> and i expect the answer to be no right?
04:23:04 <dons> I think the answer is a conditional "yes".
04:23:22 <dons> you need to do some googling for this -- it comes up on the email lists every now and then
04:24:30 <bourbaki> it would really shock me if haskell was able to do that cause no other language can do that directly afaik
04:25:02 * boegel feels a shock coming up
04:25:28 <dons> or maybe it's a "maybe"
04:25:38 <boegel> http://www.reid-consulting-uk.ltd.uk/docs/ffi-Common_Problems.html#SECTION00030200000000000000
04:25:58 <dons> and we all know maybe could be Just yes, or Nothing ;)
04:26:05 <bourbaki> heh
04:26:06 <dons> mwhahaha
04:26:13 <bourbaki> or maybe maybe again ;)?
04:26:24 <dons> never trust a haskell programmer who says "maybe"
04:26:44 <bourbaki> :)
04:26:48 <bourbaki> maybe say maybe ;)
04:27:42 <boegel> so, the best way is to write a C interface first ?
04:28:50 * boegel goes back to his CG course
04:29:04 <bourbaki> boegel: yes it always is for all ffis afaik
04:32:20 <dons> foxy, ok. how can I get it to fail?
04:32:28 <dons> i'm sitting at the toy> prompt
04:32:45 <foxy> dons: :d one = 1 :: Integer
04:32:52 <foxy> dons: one
04:33:03 <dons> toy> :d one = 1 :: Integer
04:33:03 <dons> toy> one
04:33:03 <foxy> dons: :s
04:33:03 <dons> toy>
04:33:12 <dons> and there's no output?
04:33:31 <dons> ok. all done. now what?
04:33:36 <foxy> I made the show step separate, type ":s"
04:33:48 <dons> I gt a blank line
04:34:01 <dons> should be "1", right?
04:34:04 <foxy> yeah
04:34:15 <dons> do you get a blank line?
04:34:31 <foxy> try :d plus = (+) \n plus one one \n ":s"
04:34:40 <foxy> I get a segfault
04:35:55 <dons> blank line again. hmm
04:36:22 <dons> on linux and openbsd. no crash though
04:36:58 <foxy> but no result value?
04:37:19 <dons> nope
04:37:36 <dons> so   lift $ putStrLn e is empty
04:38:59 <dons> why do you need to unsafeCoerce# the thing inside the Symbol?
04:40:00 <dons> so the thing after apply_term in show_it should be a Symbol String?
04:40:26 <foxy> yup
04:41:04 <foxy> it compiles without that unsafeCoerce#
04:41:21 <dons> yep. just noticed that
04:41:38 <dons> same result though
04:42:56 <foxy> You got a blank line on linux! I get a segfault on linux
04:43:16 <dons> hmm.
04:43:25 <dons> haven't had a seg fault yet.
04:43:34 <dons> what's going on..
04:44:08 <dons> should this crash:
04:44:08 <dons> toy> :d one = 1
04:44:08 <dons> toy> one
04:44:08 <dons> toy> :s
04:44:44 <foxy> exactly that crashes on my machine
04:44:56 <dons> hmm
04:45:57 <dons> tweaking 'loop' to use readline..
04:47:29 <dons> need a darcs repo for this ;)
04:47:38 <foxy> :)
04:47:42 <dons> oh yeah, line editing rocks
04:47:54 <dons> i'll send you a diff
04:50:26 <dons> how old is your hs-plugins?
04:52:32 <foxy> less than a week
04:52:51 <dons> why is the show in the env String -> String?
04:53:03 <dons> won't that break plus one?
06:33:43 --- topic: '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi","http://www.haskell.org/tmrwiki/IssueTwo","Shapr is fine"]'
06:33:43 --- topic: set by SyntaxNinja on [Sun May 22 14:26:07 2005]
06:34:54 <Lemmih> Yep.
06:35:03 <sylvan> sylvan@sylvan:~/dev/SDLstable/src/Core$ runhaskell Setup.lhs build
06:35:03 <sylvan> Preprocessing library SDL-0.2.0...
06:35:03 <sylvan> can't find source for Graphics.UI.SDL.AudioSpec in ["."]
06:35:16 <sylvan> Which of the dirs in src should I install first?
06:35:23 <sylvan> And as you can see it still didn't work
06:35:32 <derelm> btw, is there some function like eval which evaluates a given string (as haskell code)?
06:35:33 <Lemmih> Pull again.
06:35:40 <sylvan> head or stable?
06:35:51 <Lemmih> 'Core' is the core SDL binding. All the others are just addons.
06:35:52 <sylvan> derelm: check out hs-plugins
06:35:55 <Lemmih> stable.
06:36:14 <cptchaos> Hi, does anyone know, why something like "type Show a => S a = a"  is not allowed?
06:36:22 <sylvan> ah, now it showed up (two seconds ago there weren't any new patches)...
06:40:33 <sylvan> Lemmih: Any particular order one must install these addons? Image doesn't seem to work...
06:40:35 <sylvan> sylvan@sylvan:~/dev/SDLstable/src/Image$ sudo runhaskell Setup.lhs build
06:40:35 <sylvan> Preprocessing library SDL-image-0.2.0...
06:40:35 <sylvan> Version.hsc: In function `main':
06:40:35 <sylvan> Version.hsc:23: error: `SDL_IMAGE_MAJOR_VERSION' undeclared (first use in this function)
06:40:35 <sylvan> Version.hsc:23: error: (Each undeclared identifier is reported only once
06:40:37 <sylvan> Version.hsc:23: error: for each function it appears in.)
06:40:39 <sylvan> Version.hsc:24: error: `SDL_IMAGE_MINOR_VERSION' undeclared (first use in this function)
06:40:41 <sylvan> Version.hsc:25: error: `SDL_IMAGE_PATCHLEVEL' undeclared (first use in this function)
06:40:43 <sylvan> *** Exception: got error code while preprocessing: Graphics.UI.SDL.Image.Version
06:41:19 <Lemmih> What version of sdl-image do you have installed?
06:41:45 <sylvan> 1.2
06:44:03 <Lemmih> Weird.
06:44:30 <Lemmih> What are the version macros called in SDL/SDL_image.h?
06:46:58 <sylvan> can't find that file
06:47:37 <Lemmih> You need the development files for sdl_image.
06:48:18 <sylvan> ah.. I thought those headers came with the package.. I have the dev files... let me find the SDL_image.h
06:49:35 <sylvan> no version macros at all, as far as I can see
06:50:46 <sylvan> Mixer seems broken too... sylvan@sylvan:~/dev/SDLstable/src/Mixer$ sudo runhaskell Setup.lhs build
06:50:46 <sylvan> Preprocessing library SDL-mixer-0.2.0...
06:50:46 <sylvan> can't find source for Graphics.UI.SDL.Mixer.Version in ["."]
06:51:19 <Lemmih> Pull again (: I always forget files.
06:51:55 <sylvan> No remote changes to pull in!
06:52:54 <Lemmih> Try now.
06:54:49 <sylvan> ok
06:55:38 * Lemmih should setup nightly builds of his repos.
06:58:03 <sylvan> hmm.. when I try to install GFX I get "SDL_framerate.h" No such file... but I did install GFX 2.0
06:58:41 <Lemmih> You've got some very weird packages...
06:59:25 <sylvan> yeah =)
06:59:38 <sylvan> do  you only include /usr/include and not /usr/local/include?
06:59:42 <sylvan> cause that's where my includes are
07:00:05 <Lemmih> I use sdl-config to figure that out.
07:00:30 <sylvan> hmm.. for some reason GFX put it in /usr/local/include whereas SDL put them in /usr/include
07:01:01 <Lemmih> That's bad. It should all be in the same directory.
07:01:10 <sylvan> yeah.. I just copied them there for now...
07:02:12 <sylvan> Version.hsc:23: error: `SDL_MIXER_MAJOR_VERSION' undeclared (first use in this function)
07:02:20 <sylvan> weird...
07:04:38 <Lemmih> What distribution are you using?
07:05:55 <Lemmih> I would recommend installing SDL_image-1.2.4 and SDL_mixer-1.2.6
07:06:21 <sylvan> ubuntu
07:14:26 <boegel> hey again bourbaki
07:14:57 <bourbaki> thx
07:15:21 * boegel scratches his head
07:15:41 <bourbaki> boegel: whats up?
07:15:52 <boegel> bourbaki: still studying my CS course :(
07:16:19 <bourbaki> boegel: heh :) is it that hard?
07:17:49 <boegel> well it's not hard, but I'm not used to studying anymore :) I'm used to working
07:18:23 <bourbaki> heh
07:18:35 <boegel> it features stuff like Roberts and Warnoks method for clipping stuff
07:19:10 <bourbaki> once i have implemented a clifford clipping for 3d
07:19:25 <bourbaki> in order to implement a box collision test :)
07:19:44 <bourbaki> 2400 lines of bit tests :)
07:21:26 <boegel> omg :)
07:21:39 <boegel> I'm glad it's not that complicated
07:22:11 <MachinShin> l8r all
07:26:38 <Lunar^> "    Contexts differ in length
07:26:46 <Lunar^> I've never seen this before :)
07:27:27 <boegel> seen it where ?
07:27:49 <Lunar^> It's an error from GHCI
07:27:51 <Lunar^> GHC
07:28:01 <Lunar^>     Contexts differ in length
07:28:01 <Lunar^>     When matching the contexts of the signatures for
07:28:01 <Lunar^>       runAgent :: ISpace -> TMVar WaitMap -> Action -> IO ()
07:28:01 <Lunar^>       eval :: forall a.
07:28:01 <Lunar^>               (Storable a) =>
07:28:03 <Lunar^>               Action -> StateT Env IO [(Channel a, a -> StateT Env IO ())]
07:28:06 <Lunar^>     The signature contexts in a mutually recursive group should all be identical
07:28:35 <Lunar^> Is it talking about "forall a. Storable a =>" ?
07:29:09 <TheHunter> spj wants to lift that restriction in the near future.
07:29:37 <Lunar^> TheHunter: I can't get what that means, actually :)
07:30:08 <TheHunter> oh runArgent and eval are mutally recursive.
07:30:19 <TheHunter> therefore they must have the same signature contexts.
07:30:40 <TheHunter> do you need both of them at the top level?
07:31:19 <Lunar^> I don't need eval at top level
07:31:32 <Lunar^> putting it in a "where" would be enough?
07:31:37 <TheHunter> iirc, yes.
07:31:45 <Lunar^> good news
07:33:27 <TheHunter> @plugs let foo :: Int; foo = bar `seq` 1; bar :: Num a => a; bar = foo `seq` 2 in bar
07:33:32 <lambdabot> Mismatched contexts
07:33:32 <lambdabot>   When matching the contexts of the signatures for
07:33:32 <lambdabot>   foo :: Int
07:33:32 <lambdabot>   bar :: forall a. (Num a) => a
07:33:32 <lambdabot>   The signature contexts in a mutually recursive group should all be
07:33:32 <lambdabot> identical
07:33:34 <lambdabot>   When generalising the type(s) for foo, bar
07:36:30 <Lunar^> TheHunter: doesn't seem to be enough :(
07:37:15 <TheHunter> is the a only instantiated to one specific Storable?
07:37:37 <Lunar^> yep
07:38:52 <TheHunter> then you can just give eval a less polymorphic signature.
07:39:08 <TheHunter> a brute-force solution would be eval :: Storable a => (ISpace -> TMVar WaitMap -> Action -> IO ()) -> Action -> StateT Env IO [(Channel a, a -> StateT Env IO ())]
07:39:42 <Lunar^> It seems that inligning evalAction was enough
07:39:58 <Lunar^> which was only a wrapper around execStateT
07:40:11 <Lunar^> but...     Couldn't match the rigid variable `a' against the rigid variable `a1'
07:40:20 * Lunar^ is discovering new GHC error message today
07:40:31 <TheHunter> that's probably due to scoped type variables
07:40:36 <TheHunter> try without foralls.
07:40:41 <Lunar^> There's GADT in the whole thing :)
07:44:28 <TheHunter> oh, ghc adds the forall in the error-message, so that's probably not it.
07:45:01 <Lunar^> Should I paste the rest of the message ?
07:46:15 <TheHunter> the message usually doesn't help much
07:46:37 <TheHunter> you can paste the code.
07:46:50 <Lunar^> @paste
07:46:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:48:55 <Lunar^> I've pasted the whole module, as I'm in the middle of a fog here
07:49:00 <Lunar^> it's at the end
07:49:36 <TheHunter> ok, i'll have a look
07:50:20 <TheHunter> which line is the error on?
07:50:44 <Lunar^> 171 ->  `[(channel, \ v -> (eval (cont v)) >>= doReceives)]'
07:50:59 <Lunar^>     Couldn't match the rigid variable `a' against the rigid variable `a1'
07:50:59 <Lunar^>       `a' is bound by the type signature for `eval'
07:50:59 <Lunar^>       `a1' is bound by the pattern for `Receive' at ./VM.hs:170:10-29
07:53:33 <Lunar^> I think I really want a = a1, here
07:53:43 <TheHunter> this can't type check.
07:53:53 <TheHunter> eval :: forall a. => ...
07:54:06 <TheHunter> but the GADT gives you only an existential a.
07:54:28 <Lunar^> mhh  polarity
07:55:18 <Lunar^> Is the whole approach wrong, or is there any magic I can use?
07:56:26 <TheHunter> looks fixable :)
07:56:54 <Lunar^> :)
07:57:02 <TheHunter> if i understand correctly, we really want eval :: exists a. Storable a => Action -> EvalM [(Channel a, a -> EvalM ())]
07:57:26 <Lunar^> I think, yes
07:59:29 <TheHunter> data EvalResult = forall a. Storable a => ER (EvalM [(Channel a, a -> EvalM ())]); eval :: Action -> EvalResult; eval (...) = ER $ do ...
07:59:30 <TheHunter> ?
07:59:50 <Lunar^> might help, I try
08:00:13 <TheHunter> i'll be back in 15 minutes
08:01:37 <Lunar^> Is that equiavlent to: data EvalResult :: * where ER :: Storable a => EvalM [(Channel a, a -> EvalM ())] -> EvalResult ?
08:08:24 <Lunar^> I think I got it
08:09:59 <Lunar^>       Quantified type variable `a' escapes
08:10:00 <Lunar^> :(
08:12:28 <Lunar^> Yeah !
08:12:40 <Lunar^> data ReceiveCont :: * where
08:12:40 <Lunar^>     RC :: Storable a => Channel a -> (a -> EvalM ()) -> ReceiveCont
08:12:49 <Lunar^>     eval :: Action -> EvalM [ReceiveCont]
08:13:04 <Lunar^> That's the correct scoping for 'a'
08:14:49 <Lunar^> TheHunter: thanks!
09:26:17 <cptchaos> @arr
09:26:18 <lambdabot> Smartly me lass
09:27:35 <cptchaos> could anyone help me with understanding an typeerror, please?
09:27:58 <Cale> sure
09:28:04 <Cale> I could try :)
09:28:16 <Cale> what is the error?
09:28:36 <cptchaos> ok
09:28:42 <cptchaos> I have a class:
09:28:48 <cptchaos> class (Monad m,Num b) => MRep r m b | r -> m, r -> b where
09:29:20 <Cale> okay
09:29:21 <cptchaos> a type :
09:29:31 <cptchaos> newtype MRep r m b => SMRep r m b
09:29:40 <Cale> Does the class have any methods?
09:29:56 <Cale> (Just out of interest, what is it for?)
09:29:57 <cptchaos> yes:
09:30:17 <cptchaos> class (Monad m,Num b) => MRep r m b | r -> m, r -> b where
09:30:17 <cptchaos>     rep_new        :: Int -> Int -> m r
09:30:17 <cptchaos>     rep_elem       :: r -> Int -> Int -> b
09:30:17 <cptchaos>     rep_read_elem  :: r -> Int -> Int -> m b
09:30:17 <cptchaos>     rep_write_elem :: r -> Int -> Int -> b -> m r
09:30:17 <cptchaos>     rep_map        :: (b -> m b) -> r -> m r
09:30:56 <cptchaos> now I try to make an instance:
09:31:02 <cptchaos> instance MRep r m b => MRep (SMRep r m b) m b where
09:31:02 <cptchaos>     
09:31:02 <cptchaos>    rep_read_elem (SMRep (mat0,_,_,i0,j0)) i j
09:31:02 <cptchaos>      = (rep_read_elem mat0 (i0+i) (j0+j))
09:31:02 <cptchaos>    
09:31:03 <cptchaos>    rep_write_elem (SMRep (mat0,_,_,i0,j0)) i j b
09:31:04 <cptchaos>      = (rep_read_elem mat0 (i0+i) (j0+j) b)
09:31:06 <cptchaos>    rep_elem (SMRep (mat0,_,_,i0,j0)) i j
09:31:08 <cptchaos>      = (rep_elem mat0 (i0+i) (j0+j))
09:31:10 <cptchaos>  
09:31:12 <cptchaos>    rep_new i j
09:31:15 <cptchaos>      = do rep <- (rep_new i j)
09:31:16 <cptchaos>           return (SMRep (rep,i,j,0,0))
09:31:18 <cptchaos>  
09:31:20 <cptchaos>  
09:31:22 <cptchaos> and get the following error:
09:31:24 <cptchaos>  
09:31:36 <cptchaos> Math/Matrix2.hs:276:
09:31:36 <cptchaos>     Cannot unify the type-signature variable `m' with the type `(->) b'
09:31:36 <cptchaos>         Expected type: m
09:31:36 <cptchaos>         Inferred type: (->) b
09:31:36 <cptchaos>     When using functional dependencies to combine
09:31:36 <cptchaos>       MRep r m b,
09:31:38 <cptchaos>         arising from the instance declaration at Math/Matrix2.hs:276
09:31:41 <cptchaos>       MRep r ((->) b) (m (SMRep r m b)),
09:31:42 <cptchaos>         arising from use of `rep_read_elem' at Math/Matrix2.hs:282
09:31:45 <cptchaos>     When trying to generalise the type inferred for `rep_write_elem'
09:31:47 <cptchaos>         Signature type:     forall r m b.
09:31:48 <cptchaos>                             (MRep r m b) =>
09:31:51 <cptchaos>                             SMRep r m b -> Int -> Int -> b -> m (SMRep r m b)
09:31:52 <cptchaos>         Type to generalise: SMRep r m b
09:31:55 <cptchaos>                             -> Int -> Int -> b -> m (SMRep r m b)
09:31:58 <cptchaos>  
09:33:38 <cptchaos> I even not quite sure, what (->) b means
09:33:41 <Cale> (->) b is a Reader monad...
09:33:55 <ski> (b ->)
09:33:57 <Cale> It's the type of functions from the type b
09:34:17 <cptchaos> am, ok, thanks
09:34:18 <Cale> (well, really, a type constructor)
09:35:19 <Cale> <cptchaos>    rep_write_elem (SMRep (mat0,_,_,i0,j0)) i j b
09:35:19 <Cale> <cptchaos>      = (rep_read_elem mat0 (i0+i) (j0+j) b)
09:35:26 <Cale> Is that right?
09:35:39 <cptchaos> no!
09:35:53 <Cale> (that's what it's complaining about)
09:36:01 <cptchaos> hm, getting to tired, should make a break ...
09:36:32 <yain> what is "_"?
09:36:54 <Cale> _ occurring on its own can occur in patterns as a placeholder for anything
09:37:02 <Cale> that thing doesn't get a name
09:37:22 <cptchaos> Cale, thanks a lot ;-)
09:37:29 <yain> ah.
09:37:30 <Cale> It's common when you're breaking up some structure and there are bits you don't care about.
09:37:42 <Cale> cptchaos: no problem
09:37:46 <TheHunter> |newtype MRep r m b => SMRep r m b| is not portable.
09:37:51 <Cale> cptchaos: does it compile now?
09:39:12 <TheHunter> oops, i was sure ghc wouldn't accept it, but it does...
09:39:48 <Cale> I get the impression that if anything accepts things, then GHC accepts them :)
09:40:08 <Cale> but perhaps I don't use the other implementations enough
09:40:45 <cptchaos> Cale: not jet, but I am back on track with what the errors mean
09:40:52 <TheHunter> i vaguely recall a message where spj said that he wanted to remove that.
09:41:57 <cptchaos> Cale: now it compiles
09:42:03 <Cale> cptchaos: cool
09:42:58 <cptchaos> however, I will make a break jet, and eat something
09:45:37 <TheHunter> Cale, well hugs accepts |newtype Foo = forall a. Foo a| (which is of course pure nonsense) and ghc doesn't.
09:46:33 <ski> nonsense ?
09:47:10 <Cale> oh
09:47:39 <Cale> isn't that kind of a kind error?
09:47:52 <TheHunter> it
09:47:58 <TheHunter> 's a newtype existential.
09:48:22 <Cale> oh
09:48:27 <Cale> I see how it works
09:48:47 <ski> Foo :: forall a. a -> Foo
09:48:49 <Cale> (excuse me I just woke up :)
09:48:56 <ski> Foo :: (exists a. a) -> Foo
09:49:08 <ski> would such an iso be nonsense ?
09:49:20 <ski> hm
09:49:41 <ski> maybe with hidden type arg ..
09:49:58 * TheHunter thinks it over...
09:50:15 <ski> depends on how one thinks on it, i guess
09:50:54 <ski> Foo being iso to the lone a could be nonsense
09:51:28 <ski> Foo being iso to (a :: *,a) seems more ok, to me
09:54:34 <TheHunter> ski, ok, you're right, it makes some sense.
10:23:41 * xerox just did rafting, yay
11:46:56 <sjanssen> from the Scrap Your Boilerplate paper: "Trying to understand the type of gfoldl directly can lead to brain damage"
11:48:08 <autrijus> (forall a b . Data a => c (a -> b) -> a -> c b) -> (forall g . g -> c g) -> a -> c a
11:57:23 <Cale> wtf?
11:57:32 <Cale> messed up irc client?
11:57:39 <jlouis> something like that yes
11:57:41 --- mode: ChanServ set +o Igloo
11:58:02 --- mode: Igloo set +b dblhelix!*@*
13:33:59 --- mode: Igloo set -b dblhelix!*@*
13:34:14 --- mode: Igloo set -o Igloo
13:43:06 <goron> When will #haskell become ##haskell? Since that's FreeNode new policy?
13:43:54 <goron> Although, you could consider it an "official" channel, since most language implementors come here too.
13:48:18 * Igloo considers it an "official" channel
13:55:29 <lispy> what ##haskell?
13:55:33 <lispy> i have not heard about this...
13:56:07 <ibid> me neither
13:56:48 <lispy> i'm checking the channels guidelines on the freenode site, maybe it will shed some light
13:57:37 <ibid> there's no channel ##haskell as far as i can tell
13:58:17 <lispy> wel, that's the worng link...that just tells you how to behave
13:58:39 <ibid> what?
13:58:44 <lispy> http://freenode.net/policy.shtml#primarychannels
13:59:35 <ibid> aha
13:59:45 <ibid> and why should #haskell become ##haskell, then?
14:01:08 <lispy> the reasoning would be that it is about haskell, but not representing a group known as haskell
14:01:21 <lispy> but i don't like the convention of ##haskell
14:01:35 <lispy> personally, i would have never found the channel if that were thecase
14:04:45 <ibid> the name haskell is informally claimed by a group of an informal organization that is at least partially represented in this channel
14:04:50 <ibid> i don't see the problem
14:08:36 <lispy> in that case, the wording "informal organization" is probably not capturing the right meaning.  Perhaps "informal community" would be better
14:09:03 <ibid> and the difference is...?
14:09:10 <lispy> to me informal organization does not include haskell hackers, but informal community would
14:09:51 <lispy> in my mind organization implies more structure and purpose
14:10:28 <ibid> organization is anything organized. when "informal" is applied to it, it becomes less organized, the structure and purpose become less pronounced
14:11:17 <ibid> i think it is fair to say that there is an organization which comprises of forex the organs of the language committee, the haskell.org people, the people on the mailing lists, and, yes, this channel
14:12:11 <ibid> communities are almost always organizations
14:12:17 <ibid> hence, where's the difference :)
14:12:47 <ibid> or rather, communities are always organizations, but some organizations lack the communal flavor
14:12:55 <lispy> either way, no one is going to object to our usage of #haskell, so we have nothing to worry about
14:13:01 <ibid> exactly :)
15:47:01 <cakoose> When you have a parameterized type (type T a b c = ...), does currying come into play?
15:48:56 <wagle> yes
15:49:19 <cakoose> How?
15:49:35 <cakoose> I realize that type constructor functions will curry their arguments...
15:49:48 <cakoose> But does any curring go on at the level of types?
15:50:06 <Cale> You can't partially apply type synonyms, afaik
15:50:22 <wagle> try it and find out...  8/
15:50:34 <Cale> but you can partially apply type constructors
15:50:43 <wagle> can you give a concrete example of what you are trying to do?
15:51:00 <cakoose> Err...I'm not trying anything in particular, actually.
15:51:33 <cakoose> Which might explain why my question may not make sense.
15:51:39 <wagle> i know of many instance declarations that partially apply
15:52:51 <wagle> but if type T a b c = ..., i dont think T Int is a type, i would guess its a kind, but i dont know that for sure
15:53:20 <wagle> and the contexts for kinds is kindof limited
15:54:09 <wagle> ... the contexts into which you can put kind expressions ...
15:54:51 <wagle> mmm..  dont think its a kind..  i dont know what it would be
15:55:25 <wagle> maybe its time for me to sit down and become a lawyer for modern haskell
15:55:35 <wagle> maybe its time for me to sit down and become a language lawyer for modern haskell
15:59:33 <edwinb> T Int would be a type expression of kind * -> * -> *
16:00:01 <SamB> @index VarE
16:00:07 <edwinb> This sort of thing might be useful sometimes...
16:00:13 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
16:10:55 <MachinShin> hey +
16:30:18 <buggler> Hey, does anyone know why I may be getting this error
16:30:19 <buggler> fixNum :: Int -> Int -> Int
16:30:20 <buggler> fixNum i l | (div (l*2 + 1)  10 == 0) = 0
16:30:23 <buggler> For that I get
16:30:33 <buggler> ERROR "./Project.hs":55 - Instance of Fractional Int required for definition of fixNum
16:31:05 <buggler> I don't see how this has anything to do with fractional ints
16:31:19 <buggler> and I don't know haskell well enough to make sense of that error
16:31:33 <lispy> @type div
16:31:40 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
16:31:46 <Lycan359> Hey why does Haskell use infix operators for things like + and -?
16:31:59 <Cale> Lycan359: why not?
16:32:03 <lispy> Lycan359: it doesn't have to be infix....
16:32:16 <Cale> you can write ((+) 5 3) if you like
16:32:28 <Lycan359> Yes, but I'm asking why it's default to infix
16:32:28 <lispy> or (+ 5) 3
16:32:29 <buggler> Hm sorry about my question, the reason it didn't work was silly
16:32:34 <buggler> haskell told me the error was in line 55
16:32:36 <lispy> buggler: what was it?
16:32:39 <buggler> But it was actually in line 56
16:32:49 <lispy> buggler: which compiler?
16:32:55 <buggler> Hugs interpeter
16:33:19 <lispy> buggler: you may want to try ghci, you can use it the same way, but error messages are generally better
16:34:57 <Lycan359> What benefit is there to Haskell defaulting to infix.
16:35:02 <lispy> Lycan359: probably because most people learn math in school using infix
16:35:43 <Cale> Prefix notation would be irritating
16:35:49 <lispy> haskell tries to have a friendly syntax
16:36:12 <Cale> You use it in scheme and such, but not doing so would break some of the nice properties of scheme.
16:36:13 <Lycan359> But prefix notation makes more sense.
16:36:24 <Cale> Haskell doesn't lose anything by using infix notation
16:36:49 <lispy> Lycan359: depends on who you are that it "makes more sense"
16:36:56 <buggler> prefix notation does get irritating, imagine writing a huge arithmetic expression in prefix notation
16:37:02 <gzl> prefix is really annoying
16:37:15 <buggler> can't include /'s in the middle of stuff, need to go back to the start and throw it in
16:37:19 <yain> i think people looking for prefix notation just should use scheme or something
16:37:27 <edwinb> writing a huge arithmetic expression in infix is often bad enough...
16:37:32 <yain> why complain about it if there are good languages which use prefix.
16:37:46 <edwinb> anyway, you can use prefix if you prefer ;)
16:37:49 <gzl> yeah, lots of things would be nearly unreadable in prefix
16:37:51 <lispy> at least in scheme/lisp it's not ambiguous what the order of computation in an arthimetic expression should be
16:38:23 <lispy> but, personally, if the expression get huge, i like to create local definitions via let or where
16:38:25 <Cale> the whole point of laziness is that the order of evaluation should be irrelevant :)
16:38:42 <lispy> Cale: i mean precedence then
16:38:49 <lispy> ^, *, +
16:39:02 <Cale> precedence is clearly specified in the prelude :)
16:39:08 <Cale> but yeah
16:39:10 <buggler> just use brackets whenever you feel it's ambiguous, you can remember the precedences if you want though
16:39:50 <gzl> yeah, reasonable use of parentheses solves that problem
16:40:43 <lispy> reading other peoples code is when it's nice
16:40:58 <Lycan359> I have another question. Why is laziness forced? Wouldn't it be better to be able to use it when you want?
16:41:20 <lispy> Lycan359: what do you mean forced?
16:41:31 <Cale> Lycan359: you can use strict evaluation when you really need it
16:41:35 <Lycan359> I mean that it's lazy all the time.
16:41:38 <Cale> Usually laziness is what you want.
16:41:49 <edwinb> I think laziness is overrated...
16:41:57 <Cale> I think it's underrated :)
16:42:15 <Cale> Laziness increases compositionality
16:42:20 <edwinb> There's a lot of verhead, and a lot of the time, functions get evaluated to normal form anyway so you're just building thunks then evaluating them
16:42:38 <edwinb> It's often neater, of course.
16:42:40 <Cale> It generally only affects things by a constant factor.
16:43:23 <Cale> and where it doesn't, you can add a couple strictness annotations, or use strict hofs.
16:43:23 <edwinb> Is that a big or small constant?
16:43:30 <lispy> how do haskell programs compare in performance to the "same" program in C?
16:43:33 <lispy> on average?
16:43:34 <Cale> I find it to be reasonably small.
16:43:42 <lispy> is there any sort of well known comparison?
16:43:53 <edwinb> It's impossible to do a fair comparison really
16:43:58 <Cale> C compilers have a hard time compiling Haskell code :)
16:44:00 <lispy> of course
16:44:05 <Cale> (and vice versa :)
16:44:08 <edwinb> Robert Ennals' thesis is intersting on the subject of strictness.
16:44:18 <Lycan359> How good  is something like GHC right now?
16:44:30 <SamB> ghc seems to no what to do with C code, though ;-)
16:44:36 <lispy> 6.4 is supposed to be a lot faster than 6.2
16:45:03 <lispy> benchmarks are always biased, and yet, they are still useful
16:45:26 <Lycan359> lispy, then you can check the computer language shootout if you want.
16:45:45 * lispy googles
16:45:47 <Cale> There's also the matter of what it's actually possible to write in a language in a given amount of time.
16:47:20 <Lycan359> What are some other pure functional languages besides Haskell?
16:47:58 <lispy> maybe ML counts
16:48:48 <edwinb> Is Clean pure functional?
16:50:37 <Cale> Clean is pure functional.
16:53:44 <lispy> haha, i love that they have emacs lisp listed in the great programming language shoot out
16:54:21 <edwinb> well it's a language ;)
16:54:44 <lispy> yes, and several large applications have been written using it
16:54:51 <lispy> but it's still funny
16:56:37 <lispy> i use gnus all the time as my mail reader, but lately i was wishing i didn't
16:56:54 <edwinb> gnus scared me
16:57:04 <edwinb> I used it for a while then went back to mutt
16:57:32 <lispy> i used pine for a couple years, but i like to use emacs as my mail composer
16:57:37 <Lycan359> WIll there be a new Haskell version in the next 5 years? Or is Haskell 98 basically it?
16:57:59 <SamB> most likely there will be, but it might take longer than that ;-)
16:58:28 <Cale> GHC 6.4 is way ahead of Haskell 98, though
16:58:29 <edwinb> There's plenty of extensions to Haskell 98 of varying degrees of scariness.
16:59:02 <lispy> at this point implemenations will drive the next standard
16:59:05 <mauke> heh, we need mandatory scariness declarations
16:59:17 <SamB> in the report?
16:59:39 <mauke> in programs
16:59:40 <edwinb> Maybe a compiler flag to say how scary you're prepared to be
16:59:50 <SamB> scared, you mean?
16:59:55 <edwinb> ghc --f-don't-tell-my-mum
17:00:03 <edwinb> No, definitely scary.
17:00:11 <mauke> and if your code is too scary, the compiler runs away
17:01:18 <lispy> what we really need is a proof that P = NP and real AI
17:01:55 <edwinb> Maybe in GHC 7.
17:02:52 <lispy> ghc --f-allow-P=NP
17:05:16 <esap> {-# OPTION assume-axiom-of-choice #-}
17:05:52 <esap> maybe that's not scary though.
17:06:09 <lispy> it's pretty reasonable IMO
17:06:49 <lispy> {-# OPTION no-law-of-excluded-middle #-} may be scary tho
17:13:11 <TheHunter_> 'sup?
17:16:40 <dcoutts_> {-# OPTION -fallow-axiom-of-choice #-}
17:16:47 <esap> right
17:17:10 <dcoutts_> that one would have upstet my logic tutors :-)
17:17:45 <esap> {-# OPTION -fallow-undecidable-termination-checking #-}
17:17:52 <dcoutts_> :-)
17:18:40 <dcoutts_> I know someone who's working on termination analysis, sadly it's a bit slow
17:19:02 <TheHunter> {-# OPTION -fallow-mesaurable-cardinals
17:19:10 <TheHunter> -#}
17:19:12 <edwinb> Does it have to wait until the program either finishes or doesn't?
17:19:37 <esap> {-# -fallow-V=L #-}
17:19:49 <lispy> measurable cardinals?  not familiar with that discussion
17:20:20 <lispy> i know some basic measure theory, but i guess i missed that part ;)
17:20:47 <dcoutts_> no it is actually more cunning than that, it will tell you if it is terminating but it may not be able to tell you that your algorithm is terminating even though it is indeed terminating, but crucially it'll never tell you it is terminating if it's not actually terminating
17:21:34 <edwinb> what sort of method? I've seen a few ways of doing it, automatic or otherwise...
17:21:37 <dcoutts_> and it works in lots of useful cases including some higher order cases, but it is slow
17:22:53 <dcoutts_> it's an extension of Neil D. Jones's first order termination analysis by size change graphs
17:23:02 <edwinb> aha
17:23:11 <esap> size change graphs?
17:24:00 * esap found http://www.diku.dk/~neil/
17:24:09 <dcoutts_> you build these little graphs from the program, stich them together and then run this slow graph algorithm looking for possible paths of infinite decent, see the paper :-)
17:24:43 <dcoutts_> the first order case is sufficient to explain the idea
17:24:52 <edwinb> the idea being that there is some value in recursive calls that eventually gets to the base case...
17:25:07 <dcoutts_> right, over some well founded data structure
17:25:29 <dcoutts_> like any algabraic data type or positive integers
17:39:30 <Lycan359> What does "where" mean?
17:42:49 <Cale> "where" introduces a "where-clause" which is part of a function declaration in which you can make local definitions
17:43:19 <lispy> it is translated to a let
17:43:27 <Cale> It is similar to let, but different, syntactically. It is not part of an expression.
17:43:57 <Cale> i.e. you can't write (x + x where x = 2) + 5
17:44:00 <lispy> foo x = y where y = bar x
17:44:27 <lispy> foo x = y where (_, y) = bar x
17:44:30 <lispy> that's probably a better example
17:46:59 <Cale> primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]
17:48:33 <lispy> i used that same thing with graphs the other day
17:48:59 <lispy> the condition inside of sieve was ==
17:49:24 <lispy> and instead of [2..], i have a function which took n and generate random graphs with n vertices
17:49:39 <lispy> so then i could get a list of unique graphs
17:50:15 <lispy> not terrible efficient, but it was very simple and worked perfectly
17:54:32 <mauke> man, golfing haskell feels weird
17:56:09 <wagle> golfing?
17:56:30 <mauke> optimizing for source size
17:56:32 <buggler> This may sound very easy but my mind is totally stuck atm.
17:56:44 <buggler> Is there an easy way to append two ints to one another
17:56:50 <buggler> ie) append 10 25 = 1025
17:57:04 <wagle> show i ++ show j
17:57:15 <mauke> @pl \a b -> read (show a ++ show b)
17:57:16 <lambdabot> (read .) . (. show) . (++) . show
17:57:22 <wagle> read (show i ++ show j)
17:57:39 <wagle> bleah
17:58:02 <buggler> well that makes sense. thanks ;P
17:58:09 <mauke> it's for this context; runtime or memory usage don't matter
17:58:11 <lispy> don't you need to tell it what type read will be returning tho?
17:58:16 <mauke> s/text/test/
17:58:22 <wagle> mauke: what is "golfing"?
17:58:52 <dons> shortest code possible contests
17:58:53 <wagle> lispy: depends on the type context of the read
17:58:58 <dons> very popular in perl world
17:59:06 <buggler> I was actually looking for an arithmetic way but this way works fine.
17:59:14 <buggler> i'm a bit sad i couldn't think of a neat arithmetic way though
17:59:20 <buggler> I could do it thruogh a long procession of mods and divs
17:59:23 <wagle> 1 + read (show i ++ show j)
17:59:24 <lispy> dons: also popular with lisp crowd
17:59:25 <buggler> but it wasn't looking good
17:59:51 <dons> I think we should have 'longest type possible' contests ;)
17:59:53 <wagle> truncate . log10 ...
17:59:55 <lispy> buggler: i'd just use log and multiply by 10 ;)
18:00:13 <buggler> heh yeah I could use log to see how much i'd need to multiply with
18:00:18 <wagle> exp10 . truncate . log10 ...
18:00:18 <lispy> i think you want ceiling instead of truncate
18:00:31 <buggler> append x y = 10^(log y) * x + y
18:00:47 <buggler> (Where everything is rounded off to integers)
18:00:51 <wagle> lispy: i decided not to bother thinking it out, leaving it to him to fill in the details
18:01:13 <buggler> oh
18:01:20 <buggler> ceiling !
18:01:39 <buggler> yeah.. because if x had log 10 of 0.something, i'd want to multiply by 10
18:01:45 <dons> @seen shapr
18:01:46 <lambdabot> I saw shapr leaving #haskell 2 days, 9 hours, 8 minutes and 59
18:01:46 <lambdabot> seconds ago, and I have missed 7 seconds since then.
18:01:54 <buggler> although i'd want log 10 = 1 to go to 2
18:01:56 <buggler> so I want + 1
18:01:59 <buggler> and then truncate
18:02:18 <buggler> truncate (1 + 10^(log y)) * x + y
18:02:28 <buggler> i'll stick with read (show x ++ show y) for now ;)
18:02:51 <wagle> could blow it when you get to appending really large numbers due to roundoff errors
18:03:12 <wagle> log10 9999999999999999999999999999999999999 == ??
18:03:29 <lispy> ceiling won't work
18:03:31 <buggler> i somehow doubt this program will ever get to numbers that large :P
18:03:36 <buggler> each number corresponds to a single file
18:03:42 <wagle> eeek!  eeek!
18:03:46 <buggler> that many files on my computer wouldn't be desirable
18:03:51 <lispy> @hugs ceiling (logBase 10 10)
18:03:56 <lambdabot> 1
18:04:03 <wagle> see!  see!  haskell is type unsafe!
18:05:06 <wagle> people should not be able to build in assumptions about the range of the inputs (some being "impossible")
18:05:37 <wagle> @hugs floor (logbase 10 10) + 1
18:05:38 <lambdabot> Variable not in scope: `logbase'
18:05:44 <wagle> @hugs floor (logBase 10 10) + 1
18:05:45 <lambdabot> 2
18:05:54 <wagle> @hugs floor (logBase 10 9) + 1
18:05:55 <lambdabot> 1
18:06:01 <wagle> @hugs floor (logBase 10 99) + 1
18:06:03 <lambdabot> 2
18:06:08 <wagle> @hugs floor (logBase 10 100) + 1
18:06:10 <lambdabot> 3
18:06:39 <wagle> huh..  i think i knew about the problem with 10, hence my choice of truncate (floor)
18:06:51 <wagle> "instinct"
18:07:00 <wagle> (intuition?)
18:07:34 <wagle> i hate not knowing why i'm right
18:07:35 <lispy> i always forget that 1+ floor x != ceilling x
18:07:58 <wagle> s/knowing/remembering/
18:08:28 <wagle> clopen segments
18:08:41 <wagle> no, no clopen..  nm
18:09:01 <wagle> [a,b)
18:09:17 <dons> clopen?
18:09:27 <buggler> heh, noclopen? :P
18:09:33 <dons> dlopen?
18:09:33 <lispy> yeah, it's a topology term ;)
18:09:34 <buggler> clopen means closed and open
18:09:43 <dons> ok :}
18:09:49 <wagle> both open and closed..  but [a,b) is neither open nor closed
18:09:59 <dons> not dlopen(3)
18:10:06 <lispy> nope
18:11:55 <buggler> there's a funny term called a 'door space'
18:11:59 <buggler> where every set is either closed oe open
18:14:33 <lispy> nice
18:14:55 <lispy> there are spaces where every set is clopen, but i can't remember them
18:17:25 <mauke> damn
18:17:52 <mauke> length "interact$unlines.map(show." == length "getContents>>=mapM_(print."
18:17:58 <wagle> i like the second defn: http://en.wikipedia.org/wiki/Clopen
18:19:31 <wagle> mauke: True
18:19:34 <Cale> lispy: spaces under the discrete topology
18:19:54 <mauke> wagle: but I need it to be shorter!
18:20:00 <wagle> why?
18:20:15 <mauke> http://spoj.sphere.pl/problems/KAMIL/
18:20:28 <wagle> string length for those sorts of strings seems to have no meaning
18:22:24 <wagle> i dont see the relationship
18:22:57 <mauke> I want to shorten my program (which uses interact)
18:23:12 <wagle> ooohhh
18:23:24 <wagle> Submissions are not allowed to exceed 256 bytes.
18:25:11 <buggler> heh
18:25:15 <buggler> i dont see relationship
18:25:22 <buggler> i just want, short program
18:25:52 <buggler> i dont want to know its name... i just want, short program :P
18:26:09 <mauke> huh?
18:26:28 <buggler> i'm guessing you haven't seen the flash video :(
18:27:01 <mauke> ah, bang bang bang?
18:27:12 <buggler> yeah
18:27:48 <wagle> oh, i get it
18:28:22 <wagle> i think i have the short version they are looking for
18:28:44 <mauke> how many chars?
18:29:58 <wagle> dunno yet..  still need to write it..  i just know the algorithm
18:30:37 <Lemmih> Is there a paper describing the details of profiling in GHC?
18:34:54 <Lemmih> n/m.
18:38:03 <wagle> foo '' = 2
18:38:17 <wagle> foo '' = 2
18:38:23 <wagle> argh
18:39:59 <wagle> foo '' = 2
18:40:05 <wagle> wtf>!>!!
18:40:27 <wagle> $ wc kamil.hs
18:40:27 <wagle>        6      29      82 kamil.hs
18:40:57 <wagle> Main> kamil "filipek"
18:40:57 <wagle> 4
18:41:16 <wagle> any other test cases?
18:41:37 <mauke> 82 chars? that's rank 45
18:42:35 <wagle> haskell, not perl
18:42:47 <wagle> perl is easier
18:43:08 * Lemmih wonders what wagle is doing.
18:43:17 <wagle> mines the best haskell one though
18:43:21 <mauke> wrong
18:43:37 <wagle> duh..  sorry..  i was thiking 68 for some reason
18:43:53 <autrijus> rehi.
18:43:55 <mauke> and there is a 70 char solution, damn
18:43:57 <autrijus> haskell golfing?
18:43:59 <mauke> yes
18:44:23 <mauke> (because I couldn't find the 24 char perl solution)
18:44:56 <SamB> hmm, anyone know how Template Haskell pretty-prints the spliced-together code?
18:45:19 <autrijus> SamB: Language.Haskell.TH.Ppr
18:45:27 <SamB> ah.
18:45:31 <wagle> $ wc kamil.hs
18:45:31 <wagle>        1      19      75 kamil.hs
18:46:21 <wagle> doing trivial whitespace compression
18:46:22 * SamB does not think writing code that uses Text.PrettyPrint directly is the best way to produce Haskell code
18:46:23 <wagle> woot!
18:46:23 <wagle> $ wc kamil.hs
18:46:23 <wagle>        1      11      67 kamil.hs
18:46:51 <autrijus> so it's just counting occuences of TDLF
18:47:01 <autrijus> and calculate 2** that?
18:47:04 <mauke> yes
18:47:33 <mauke> there are two different 25 char solutions in perl
18:47:40 <autrijus> SamB: aye, but that's because my $client's platform has no ghci.
18:47:44 <wagle> autrijus: i used a similar homomorphism
18:47:45 <autrijus> SamB: you are welcome to improve it.
18:47:54 <Lemmih> Language.Haskell.TH.Ppr doesn't even print correct Haskell code in GHC 6.4
18:48:22 <SamB> Lemmih: is it valid GHC code?
18:48:29 <Lemmih> Nope.
18:48:34 <mauke> wagle: is your program runnable as ./a.out <test-input?
18:48:41 <dons> SamB, can you use [| |] :
18:48:41 <SamB> oh, then I guess that won't help much...
18:48:42 <dons> > pprint (unsafePerformIO (runQ [| \x -> (x,x) |] ))
18:48:42 <dons> "\\x_0 -> (x_0, x_0)"
18:49:08 <wagle> no, i just define kamil s =
18:49:11 <SamB> dons: yes, that was the whole point in wanting to know what TH used to pretty-print ;-)
18:49:19 <autrijus> mauke: 25 char? I don't understand
18:49:30 <dons> otherwise using nibro's Hsx haskell parser/ppr lib is a good idea
18:49:51 <autrijus> I can easily do it in 18
18:50:03 <mauke> how?
18:50:05 <wagle> i'm not even sure how to write such a a.out
18:50:14 <autrijus> $ perl -ple '$_=2**tr/TDLF//'
18:50:20 <mauke> wagle: ghc kamil.hs
18:50:30 <mauke> autrijus: it has to be in a file
18:50:38 <wagle> dunno how to input or output
18:50:44 <SamB> I dunno if we want to add a dependency on Hsx to Pugs...
18:50:54 <dons> meh.
18:51:09 <dons> p = unsafePerformIO . runQ
18:51:11 <wagle> how do you write reverse < test.input
18:51:32 <mauke> autrijus: perl -le 'print length "#!perl -pl\n\$_=2**tr/TDLF//"'
18:52:08 <wagle> use pugs instead of perl
18:52:14 <dons> p x = pprint (unsafePerformIO (runQ x))
18:52:17 <dons> I mean.
18:52:28 <dons> p :: (Ppr a) => Q a -> String
18:53:15 <mauke> wagle: the easiest way is to use interact
18:53:48 <mauke> @type interact
18:53:53 <lambdabot> interact :: (String -> String) -> IO ()
18:53:58 <autrijus> mauke: understood
18:54:28 <wagle> @type main
18:54:30 <lambdabot> bzzt
18:54:37 <autrijus> then there's a obvious solution at 26 chars
18:55:16 <wagle> i've never actually done a standalone haskell program.. whats the entry point?
18:55:23 <autrijus> wagle: main
18:55:28 <wagle> 18:55 < lambdabot> bzzt
18:55:31 <mauke> main :: IO ()
18:55:39 <mauke> yeah, because it isn't predefined
18:55:53 <wagle> ewww
18:56:22 <autrijus> ah. I got it to 25.
18:57:02 <wagle> main = interact id
18:57:03 <SamB> now if only I could run reify in the IO monad...
18:57:07 <wagle> cool
18:59:32 <wagle> aww..  i'm up to 88 now
18:59:41 <autrijus> sigh. I can't see a way past 25. ;)
19:00:27 <mauke> autrijus: do you see the other solution with 25 chars?
19:00:48 <wagle> perl is cheating and ot for this channel!  8) 8) 8)
19:00:49 <autrijus> no. where do I see solutions?
19:01:19 <mauke> you have to discover them yourself :-)
19:01:55 <mauke> well, it's mostly just an explicit loop instead of command line args
19:02:11 <autrijus> warn+1<<tr/TDLF//,$/for<>
19:02:36 <mauke> hmm
19:02:48 <mauke> probably not allowed as warn prints to stderr
19:06:45 <autrijus> ok.
19:06:50 <autrijus> I'm not terribly interested in p5 anyway :)
19:06:57 <autrijus> there is obvious solution at 23 chars for Pugs
19:07:01 <autrijus> i.e. Perl6
19:07:05 <autrijus> but I'm not sure if they will count that ;)
19:07:18 <wagle> 63!
19:09:34 * wagle is the weiner!
19:09:40 <mauke> whoa
19:10:09 <mauke> how did you do it?
19:11:33 <buggler> how do I nest guards in haskell?
19:11:36 <buggler> I want something like this
19:11:43 <buggler> f :: Int -> Int
19:11:44 <buggler> f x | x > 100 | x > 200 = 4
19:11:44 <buggler>               | otherwise = 3
19:11:44 <buggler>     | x < 100 = 2
19:11:44 <buggler>     | otherwise = 1
19:11:46 <buggler> that doesn't seem to work
19:12:35 <Lemmih> Use comma.
19:13:02 <Lemmih> @plugs let x y | y > 0, y < 10 = True in x 3
19:13:03 <lambdabot> Warning: accepting non-standard pattern guards (-fglasgow-exts to
19:13:03 <lambdabot> suppress this message)
19:13:03 <lambdabot>       [y > 0, y < 10, True]
19:13:19 <Lemmih> Bah.
19:13:41 <wagle> do they publish the solutions at some point?
19:14:34 <Lemmih> oh wait, I don't think you can use guards like that.
19:14:48 <mauke> wagle: I don't think so
19:15:31 <buggler> aw ;(
19:15:34 <Lemmih> What about: x > 200 = 4; x > 100 = 3; x < 100 = 2; otherwise = 1?
19:15:48 <buggler> well this is just an example function
19:16:04 <wagle> awww..  it say wrong answer..  OHH
19:16:05 <buggler> my actual function is much larger and i can't simply change the ordering like I can here
19:16:13 <Lemmih> Refactoring is the key then.
19:16:44 <autrijus> wagle: hm, I quickly got to 70
19:16:47 <buggler> ah so you mean doing &&'s around the place?
19:16:53 <autrijus> then can't see how to go from there
19:17:33 <SamB> autrijus: TH splicing is not working with perl5 embedding. please advise.
19:17:36 * buggler can't see why haskell doesn't allow nested guards but i'll take it in good faith and throw in some &&s around the place
19:17:51 <autrijus> SamB: disable it under p5 embedding for now and report bug :-/
19:17:58 <Lemmih> buggler: Divide and conquer. Split your function down to smaller pieces.
19:18:11 <SamB> autrijus: it isn't a bug!
19:18:17 <wagle> does it want both upper and lower case?
19:18:42 <mauke> wagle: "Only 26 capital leters are used."
19:19:26 <Lemmih> buggler: Nested guards would cause a parsing problem.
19:19:42 <wagle> ugh
19:23:54 <wagle> hahah
19:24:51 <wagle> haskell sure is nasty for transducers
19:26:06 <wagle> nm, my solution wasnt handling io correctly
19:26:55 <wli> What flavor of transducer are these?
19:27:20 <wagle> http://spoj.sphere.pl/problems/KAMIL/
19:27:50 <wagle> ./a.out < test-cases > results
19:28:29 <wagle> i just never actually wrote one from scratch in haskell before
19:31:44 <lispy> @pl \x -> show x++"\n"
19:31:45 <lambdabot> (++ "\n") . show
19:32:23 <wagle> ugh
19:32:34 <dons> beautiful
19:32:44 <wagle> bloated
19:33:07 <wagle> (++"\n"). show
19:33:18 <wagle> been there, done that..  8)
19:33:45 <lispy> it's nice because now i can easy map it onto a list
19:34:42 <lispy> @pl \x -> concat (map showLn x)
19:34:43 <lambdabot> (showLn =<<)
19:34:49 <lispy> nice!
19:39:32 <wagle> woo..  finally, a correct answer!
19:39:40 <wagle> 97..  rank 58
19:39:49 <wagle> NOW, i can start optimizing
19:40:34 <autrijus> bah. I'm stuck at 69.
19:41:59 <wagle> the wrapper is half the size of the program..  yuck
19:43:48 <autrijus> I don't see a way out of 69, so I'll quit at that :)
19:44:20 <wagle> until you arent number 1 any more, anyway..  8)
19:44:25 <mauke> argh, how do you get below 70?
19:44:33 <mauke> I'm still stuck at 72
19:45:14 <autrijus> I got to 59.
19:45:25 <autrijus> breakthrough!
19:45:36 <wagle> hahaha..  ghc arcana?
19:45:58 <autrijus> nah. standard haskell
19:46:10 <wagle> i was doing well until i had to turn it into a transducer
19:46:20 <wagle> getContents?  interact?
19:46:27 <autrijus> none.
19:46:33 <autrijus> none of above
19:46:39 <wagle> arcana then..  8)
19:46:45 <autrijus> nope. haskell98 :)
19:46:59 <mauke> getLine?
19:47:02 <autrijus> yeah
19:47:03 <wagle> did you submit it?
19:47:20 <autrijus> no, hadn't registered
19:47:50 <wagle> i thought i was doing well until it rejected my first several attempts
19:49:10 <wagle> ohh..  the getChar defn isnt "close" to the getContents defn.. was combing the docs for other ways to read from stdin
19:49:15 <autrijus> ah. stderr can't work.
19:49:35 <wagle> yeah, getLine will be good for me
19:51:08 <mauke> The Haskell 98 Report: 7  Basic Input/Output
19:51:09 <wagle> monad transforms
19:56:53 <autrijus> my 69char is in
19:57:19 <wagle> how does getLine handle eof?
19:57:37 <lispy> you could use ctrl+d to test it
19:57:50 <autrijus> wagle: sigh.
19:58:01 <autrijus> wagle: want to see my 80char? :)
19:58:25 <wagle> nah.. i'm still learning on my own
19:59:06 <wagle> lispy: i already did that, i was wondering how to handle it
19:59:43 <autrijus> wagle: catch
19:59:48 <autrijus> wagle: but that is long
19:59:52 <autrijus> trying to find a better way
20:00:17 <mauke> damn, why is fromEnum so long?
20:00:32 <wagle> technically, passing their regression is what's necessary
20:01:57 <autrijus> wagle: it detects for exitcode
20:02:00 <autrijus> so have to handle eof
20:02:25 <wagle> oh, so it didnt accept your 69?
20:02:40 <autrijus> my 69 is accepted
20:02:41 <mauke> oh god, you should see my C solution :-)
20:02:45 <autrijus> my 58 isn't.
20:02:52 <autrijus> the 58 is getLine without eof handling
20:03:06 <autrijus> when I add eof handling it became 80 or so
20:03:12 <autrijus> not competitive anymore
20:09:28 <mauke> ok, down to 59 without EOF handling
20:11:07 <autrijus> sadly
20:11:12 <autrijus> the handling cost at least 19
20:11:36 <autrijus> there's no way to reduce it to 9
20:11:43 <autrijus> so I've gave up that approach
20:13:51 <mauke> what do you use for input?
20:16:49 <buggler> Is there a set difference function
20:17:08 <buggler> like difference :: Eq a => [a] -> [a] -> [a]
20:17:19 <autrijus> \\
20:17:22 <buggler> thanks
20:17:28 <autrijus> not in prelude.
20:17:44 <autrijus> also see Data.Set for real difference
20:19:41 <buggler> Thanks autrijus
20:20:31 <lispy> autrijus, mauke: do whitespace chars count?
20:20:45 <mauke> yes
20:20:49 <wagle> lispy: try it, find out
20:21:05 <lispy> i would but i don't have time
20:21:23 <lispy> i was just going to suggest that whitespace language if they didn't count :)
20:22:42 <wagle> i'm doing things like "foo . (baz)" ~~> "foo .(baz)"
20:23:28 <lispy> and i guess you can use $ in some spaces to save chars
20:23:51 <mauke> wagle: foo.(baz)
20:24:05 <wagle> mauke: true
20:24:13 <mauke> my solutions contain no whitespace
20:24:17 <wagle> maybe
20:24:35 <wagle> i thought . was a module qualifier in some contexts
20:24:59 <dons> it's always (I'm fairly sure) possible to remove all lexical whitespace from .hs programs, btw.
20:25:23 <dons> except in module M where ..
20:25:46 <dons> we can't write: module(M)where :/
20:25:54 <dons> e.g. http://www.cse.unsw.edu.au/~dons/pretty.html
20:26:09 <wagle> it works..no whitespace
20:26:09 <dons> also in other module system syntax.
20:26:47 <dons> imports for example. we can't write: import(Data.List)as(Foo)
20:27:13 <wagle> 84..  8/
20:27:45 <dons> I wonder if the requirement for whitespace in the module system syntax should be considered a deficiency
20:28:36 <SamB> dons: no!
20:29:01 <mauke> wagle: I see you're coming close to my C solution :-)
20:29:06 <dons> well, it's nice to not require whitespace in expression syntax, so why in the module system. seems .. inconsistent
20:29:28 <dons> and unhaskellish
20:29:37 <SamB> well, okay, so maybe.
20:29:53 * dons makes a note to write a proposal for an extension to module system syntax
20:30:06 <SamB> but Foo.Bar and Foo . Bar don't mean the same thing...
20:30:38 <dons> sure. Foo.Bar is a qualified name. no problems.
20:31:03 <dons> the requirements for ' ' after "module", "import", "as", "qualified" are onerous though
20:31:36 <dons> the '.' in qualified names leads to, (Data.Bits..&.) too remember
20:31:48 <dons> which can be surprising when first encountered
20:31:52 <autrijus> so I'm rank 7. ;)
20:32:25 <wagle> they should show rank by programming language
20:32:55 <autrijus> yeah
20:34:11 <SamB> how can you write a rank-7 polymorphic program in 69 chars?
20:34:32 <dons> crikey!
20:34:38 <autrijus> ;)
20:35:07 <autrijus> I can't imagine how that 24 is done though.
20:35:28 <dons> can you invent a language to solve each problem in a single token?
20:35:41 <autrijus> dons: right, but it's limited to selected language
20:35:47 <autrijus> on that machine
20:35:49 <dons> i.e. write an EDSL in Haskell for each problem, where 'x' solves the problem.
20:35:50 <SamB> autrijus: why would PUGS_HAVE_TH not be defined?
20:35:54 <dons> oh well.
20:36:36 <autrijus> ah of course!
20:36:38 * autrijus arrives at 24.
20:37:21 <autrijus> ok, so I'm now tied for the first place. not feeling motivated to improve :)
20:38:32 <mauke> autrijus: HOW?
20:38:47 <SamB> mauke: that would be telling
20:39:02 <dons> oh, the code is secret??
20:39:03 <autrijus> well...
20:39:07 <autrijus> print$/,1<<y,TDLF,,for<>
20:39:10 <autrijus> is how I did it.
20:39:21 <autrijus> dons: I'm not buying this secrecy thing, but yeah
20:39:24 <mauke> isn't that cheating?
20:39:49 <autrijus> why?
20:39:57 <mauke> the whitespace is wrong
20:40:03 <autrijus> it's not.
20:40:05 <autrijus> it's in separate lines.
20:40:08 <autrijus> that's all it requests
20:40:28 <autrijus> "For every testcase write an integer in a single line with a single integer, denoting the number of words which Kamil's word can mean."
20:41:03 <wagle> 76
20:41:39 <wagle> i really need to lift [] into IO or vice versa
20:41:56 <autrijus> sadly lift* is not in prelude
20:42:34 <lispy> is it possible to make @ be a data constructor?
20:42:51 <autrijus> but I should now sleep. if someone beat me at 69, let me know :)
20:42:52 * autrijus waves &
20:42:53 <wagle> ooo.. 75
20:42:56 <lispy> i want something like data EmailAddress = String @ String
20:43:08 <buggler> How do I grab the left item of an Either a b type
20:43:17 <buggler> I'm after some sort of :: Either a b -> a function
20:43:38 <buggler> I know Left :: a -> Either a b
20:43:59 <buggler> but I don't know where to find the projection function
20:44:01 <autrijus> fromLeft (Either l _) = l
20:44:07 <autrijus> fromLeft (Either _ r) = error "impossible"
20:44:15 <buggler> Where would I find these functions
20:44:15 <autrijus> need to define something like that yourself
20:44:18 <buggler> I looked in Either.hs
20:44:21 <buggler> oh
20:44:34 <wagle> ooo!  autrijus is number 2!
20:44:35 <Lemmih> lispy: You can get: data EmailAddress = String `At` String.
20:44:51 <lispy> Lemmih: that would perfect, thanks
20:45:20 <mauke> <interactive>:1: Data constructor not in scope: `Either'
20:45:58 <mauke> fromLeft (Left l) = l  seems to work, though
20:46:49 <wagle> damn!  73
20:51:23 <autrijus> I think I found a way to solve it at 13.
20:51:29 * autrijus suddenly woke up ;)
20:51:43 <wagle> woo!  71
20:51:48 <autrijus> it is definitely cheating though.
20:52:26 <wagle> take THAT, mauke!  8) 8)
20:52:30 <autrijus> (it involves sending over a number of programs to retrieve the input set, by sleep()'ing a certain amount of time.)
20:52:52 <mauke> hah
20:53:08 <autrijus> then you send in a final program that just prints out the output.
20:53:26 <wagle> hahaah
20:53:31 <autrijus> that process can be automated of course, and will probably involve some 1000s of tries
20:53:35 <autrijus> but I _think_ it works :)
20:53:40 <wagle> if they did it right, that will be a large program
20:54:06 <autrijus> you mean a huge input set?
20:54:10 <mauke> the input file is at most 210 bytes
20:54:11 <wagle> all the inputs hundreds of chars long
20:54:32 <autrijus> well then the output info is at most 3 byte
20:54:44 <autrijus> to encode the length of exponent
20:55:04 <autrijus> and can probably be encoded with a single byte using ord()
20:55:06 <mauke> it's exactly ten lines long, and each word is no longer than 20 chars
20:55:19 <autrijus> piece of cake then :)
20:55:25 <wagle> oh..  duh..
20:55:45 <wagle> i forgot the output was numbers
20:56:06 <autrijus> so for each of the ten lines you send in a program
20:56:14 <autrijus> and sleeps the output * 5 second
20:56:19 <autrijus> for that line
20:56:31 <autrijus> then you look at the running time for each
20:56:35 <autrijus> and send in the 11th program :)
20:57:14 <cakoose> What's the quickest way to take an "[IO ()]" and conver it to an "IO ()" that runs all the actions in order?
20:57:20 <autrijus> cakoose: sequence
20:57:23 <dons> sequence_
20:57:28 <autrijus> both works.
20:57:33 <autrijus> er, no.
20:57:33 <cakoose> ok, thanks
20:57:35 <autrijus> sorry.
20:57:37 <autrijus> only sequence_ works.
20:57:49 <autrijus> (sequence will have converted it to IO [()])
20:57:54 <mauke> my best sequence_ solution is 74 chars :/
20:58:43 <SamB> @pl sequence_
20:58:44 <lambdabot> sequence_
20:59:09 * autrijus fades into sleep again, having happily hacked the system...
20:59:34 <dons> or foldr1 (>>)
20:59:55 <mauke> too long
21:01:20 <wagle> autrijus: you are still rank 2!
21:04:59 <cakoose> Do people mind if I post my solution here and ask for suggestions?
21:05:13 <mauke> hah.
21:05:22 <mauke> the output checking is totally borked
21:06:44 <mauke> cakoose: I don't mind
21:07:04 <wagle> ah well..  gotta go now..
21:07:16 <wagle> still have some room for compression
21:07:35 <SamB> @docs Language.Haskell.Syntax
21:07:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language.Haskell.Syntax.html
21:07:52 <cakoose> Here's my counting function: count s = 2 ^ (length $ filter(`elem`"TDLF") s)
21:08:37 <cakoose> And here's main: main = sequence_ $ replicate 10 (getLine >>= \s -> putStrLn $ show $ count s)
21:08:51 <mauke> main=sequence_$replicate 10$getLine>>=print.(2^).length.filter(`elem`"DFLT")
21:09:37 <mauke> note: no whitespace; inlined functions; putStrLn.show replaced by print
21:09:47 <cakoose> Ah...
21:09:53 <cakoose> I'm really really bad at IO
21:10:08 <dons> hmm. is it ok to set replace "main" with "m", and use the ghc flag: -main-is m ?
21:10:09 <cakoose> Haven't done any practical Haskell before
21:10:24 <cakoose> dons: I don't know if they let you set the compiler flags
21:10:31 <cakoose> dons: I don't think so.
21:10:32 <mauke> they don't let you
21:10:45 <mauke> otherwise I could write the entire program as a perl command line option
21:10:52 <dons> so perl guys don't get -p for example?
21:11:08 <dons> sure, you can use -e to ghc to write it on the command line too
21:11:21 <SamB> dons: that would require you to put in an OPTIONS pragma
21:11:26 <dons> paprika$ ghc -e 'putStrLn "foo"'
21:11:26 <dons> foo
21:11:36 <mauke> dons: they do, but you have to make the first line of your script #!perl -p
21:12:00 <cakoose> Wow...I gotta learn to use the (.) properly
21:12:01 <dons> oh, and there's no benefit to #!runhaskell -main-is m
21:12:36 <mauke> cakoose: it's rather simple in this case
21:13:04 <mauke> foo (bar (baz (quux x))) can be replaced by (foo . bar . baz . quux) x
21:13:21 <mauke> and (\x -> foo x) is just foo
21:13:36 <dons> or foo.bar.baz.quux$x
21:14:22 <dons> @plugs sort.reverse.sort$[1..10]
21:14:24 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
21:16:01 <SamB> @pl foo (bar (baz (quux x)))
21:16:02 <lambdabot> foo (bar (baz (quux x)))
21:16:10 <SamB> @pl \x -> foo (bar (baz (quux x)))
21:16:11 <lambdabot> foo . bar . baz . quux
21:19:06 <cakoose> mauke: Did you get compiler warnings with your solution?
21:19:14 <mauke> no
21:19:24 <lispy> @type (=<<)
21:19:26 <lambdabot> (=<<) :: forall b (m :: * -> *) a.
21:19:26 <lambdabot>    (Monad m) =>
21:19:26 <lambdabot>    (a -> m b) -> m a -> m b
21:19:42 <lispy> @type show
21:19:44 <lambdabot> show :: forall a. (Show a) => a -> String
21:19:58 <mauke> hmm, what's the shortest way of writing sequence_$replicate 10$foo?
21:22:13 <lispy> @type (=>>)
21:22:14 <lambdabot> bzzt
21:22:23 <dons> >>= ?
21:22:25 <lispy> @type (>>=)
21:22:26 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
21:22:26 <lambdabot>    (Monad m) =>
21:22:26 <lambdabot>    m a -> (a -> m b) -> m b
21:22:30 <lispy> ah, cool
21:22:37 <mauke> my best try is sequence_[foo|_<-[0..9]]
21:23:35 <lispy> you can use _ in side a list comprehension, ah nice
21:23:54 <dons> oh my.
21:24:02 <lispy> when i wanted to do that i had been using i <-[0..9] then not using it anywhere
21:24:21 <dons> why not replicateM_
21:24:35 <dons> @type Control.Monad.replicateM_
21:24:37 <lambdabot> Control.Monad.replicateM_ :: forall (m :: * -> *) a.
21:24:37 <lambdabot>           (Monad m) =>
21:24:37 <lambdabot>           Int -> m a -> m ()
21:24:49 <dons> ;)
21:24:49 <mauke> because it doesn't exist
21:24:55 <dons> umm.
21:25:19 <mauke> well, not in the prelude
21:25:22 <dons> -- | Like 'replicateM', but discards the result.
21:25:22 <dons> replicateM_       :: (Monad m) => Int -> m a -> m ()
21:25:23 <dons> replicateM_ n x   = sequence_ (replicate n x)
21:25:36 <dons> oh. you don't want Control.Monad
21:25:40 <dons> oh well.
21:25:52 <mauke> import Control.Monad is too long
21:26:06 <dons> yeah. this sucks.
21:26:31 <SamB> import Monad?
21:26:42 <dons> hmm!
21:27:08 <SamB> @type Monad.replicateM_
21:27:10 <lambdabot> bzzt
21:27:15 <SamB> maybe not
21:39:11 <Lemmih> @type GHC.Exts.addrToHValue#
21:39:12 <lambdabot> GHC.Exts.addrToHValue# :: forall a. GHC.Prim.Addr# -> (# a #)
21:39:19 <Lemmih> Neat.
21:41:49 <dons> @type "magic"#
21:41:50 <lambdabot> "magic"# :: GHC.Prim.Addr#
21:41:51 <dons> :D
21:42:24 <Lemmih> @type GHC.Exts.addrToHValue# "magic"#
21:42:26 <lambdabot> GHC.Exts.addrToHValue# "magic"# :: forall a. (# a #)
21:43:02 <mauke> huhuhu, down to 70
21:44:15 <dons> seems like a good way to write a bunch of bytes into memory, and then convince ghc to treate it as a normal vale ;)
21:44:28 <dons> dropping chars.. hmm. need coffee
21:45:57 <Lemmih> dons: Is it easy to build hs-plugins with profiling enabled?
21:46:26 <dons> yep.
21:46:50 * Lemmih is adding support for loading of profiling libs now.
21:46:53 <dons> roll back the patch to Makefile that switched off building way=prof
21:47:03 <dons> cool. thanks.
21:47:19 <dons> the relevant code is commented out in Makefile
21:48:05 <dons> @karma+ Lemmih
21:48:06 <lambdabot> Lemmih's karma has been incremented
21:52:23 <Lemmih> Uh I can't find it.
21:52:39 <Lemmih> Is there easy way of unpulling the patch?
21:55:35 <dons> patch "Disable way=p for now."
21:55:42 <dons> Fri May 13 21:24:22 EST 2005
21:55:52 <dons> and "Don't try to install profiled libs"
21:56:35 <Lemmih> Thanks
21:57:48 <Lemmih> Why did you disable it?
21:58:49 <lispy> anyone here use procmail?
21:59:14 <lispy> i'm working on a DSL for filtering (using procmail as backend) and i was wondering if people i this channel would benefit
22:00:01 <dons> Lemmih, after the Hsx import, I could no longer build profiled hs-plugins, as it relied on the non-existent Cabal profiling support.
22:01:45 <Lemmih> Ah
22:32:09 <Lemmih> dons: 'make clean && make way=p && make way=p install' fails.
22:33:03 <dons> does it build? is it just the install process that fails?
22:33:29 <Lemmih> It just fails to install.
22:34:32 <Lemmih> It tries to install the non-profiling HSaltdata which doesn't exist.
22:34:53 <dons> looks like the install-me target doesn't use $(_way) when it should
22:34:56 <dons> in src/build.mk
22:35:36 <dons> install .p_hi's looks ok. but the last 3 lines clearly are missing a way variable
22:36:06 <dons> that code got rewritten when the module namespace changed, and hasn't since been tested with profiling on.
22:40:58 <Lemmih> *Sigh*
22:41:12 <dons> it's like 2 lines of shell code, right?
22:41:27 <Lemmih> Cabal handles this so much better.
22:41:48 <dons> hs-plugins is clean enough now that it can be moved over to Cabal I think.
22:41:55 <dons> it used to be too messy, but it's now doable.
22:42:05 <dons> i plan to do this before the next release
22:42:21 <Lemmih> That would be really neat.
22:42:40 <dons> anyway, all that $(way) stuff is stolen from ghc, so blame Simon ;)
22:43:12 <Lemmih> (:
22:59:16 <Lemmih> *sob* This isn't going to be easy.
23:01:31 <dons> getting hs-plugins to build profiled? or to load and use .p_o files?
23:01:41 <Lemmih> The latter.
23:01:49 <dons> why?
23:01:59 <dons> i suspect there are hardcoded assumptions we'll have to find.
23:02:01 <dons> what else?
23:02:10 <Lemmih> hi syntax changes.
23:02:18 <dons> (I had a go at this a couple of times)
23:02:28 <dons> .hi file syntax changes!?
23:02:57 <dons> no, you just mean we have to chase .p_hi files
23:03:12 <dons> and assumptions about this are hardcoded all over the place :
23:03:13 <dons> :/
23:03:18 <dons> sorry.
23:04:27 <dons> this job seemed so fiddly that I tended to instead implement static compilation support for any project that uses hs-plugins that I wanted to profile: yi and lambdabot for example
23:04:51 <Lemmih> I'm getting: "Ix{Int}.index: (112) out of range ((0,13))" when I load a file compiled with profiling.
23:05:47 <dons> that's the .hi file parser breaking. hmm...
23:05:49 <Lemmih> I guessed it was due to changes in the .hi files since they differ when compiled with -prof.
23:06:19 <dons> but we use the same parser as ghc
23:07:10 <Lemmih> GHC must use a special parser when parsing p_hi files.
23:07:26 <dons> maybe.
23:08:02 <dons> not sure. -show-iface works on both styles of file
23:08:25 <dons> doesn't look that different.
23:08:50 <Lemmih> But the files _are_ different. Although the changes aren't visible through --show-iface.
23:09:31 <dons> ok. can you investigate $fptools/ghc/compiler/iface ?
23:09:44 <Lemmih> Sure thing.
23:10:12 <dons> oh, there's a magic byte that says if it's a profiled .hi file, I think
23:11:17 <dons> BinIface.hs is what the hs-plugins parser is based on
23:13:28 <dons> build_tag <- get bh :: IO Word8
23:13:45 <dons> is where we read the .p_hi flag in the .hi file, in hi/Language/Hi/Parser.hs
23:20:19 <Lemmih> So 'writeIORef v_Build_tag "p"' should solve it?
23:20:57 <Lemmih> Ops no.
23:21:12 <dons> nah.
23:21:27 <Lemmih> modifyIORef v_Ways (\lst -> WayProf:list)
23:21:39 <dons> that tag just exists. I'm not sure if it means anything to hs-plugins
23:22:20 <dons> it lets ghc emit a sane error if you attempt to use .p_hi files where they shouldn't be.
23:22:38 <dons> but I can't see how that affects the stuff we're reading from the file
23:23:20 <dons> it may be useful to debug the parser by printing out each value as its read until we find which type doesn't parse anymore when it's a .p_hi
23:30:02 <Lemmih> You don't think GHC reading a String and you reading a Word8 has anything to do with it?
23:31:18 <dons> hmm...
23:31:28 <Lemmih> (:
23:31:59 <Lemmih> How did that ever work?
23:32:07 <dons> so check_ver is a String?
23:32:15 <Lemmih> Yes.
23:32:29 <dons> it'd work if check_ver was 1 byte long in the normal case.
23:32:29 <Lemmih> *check_way
23:32:33 <dons> then all the offsets would be ok.
23:32:59 <dons> yeah, it's a String. huh.
23:33:07 * dons is sheepish
23:33:30 <dons> maybe it was a Word8 at one point, /me hopes
23:33:37 <dons> and it changed, and I never noticed ;)
23:33:40 <Lemmih> Hmm. Binary can't save/load list bigger than 255 elemes.
23:34:18 <dons> why do we care?
23:34:29 <Lemmih> We don't.
23:34:39 <dons> ok.
23:34:46 <dons> interesting restriction though.
23:35:14 <dons> byte length?
23:35:18 <Lemmih> It makes it easy to mistake String for Word8 (:
23:36:10 <Lemmih> Byte length?
23:36:20 <dons> instance Binary a => Binary [a] where
23:36:21 <dons>     get bh         = do h <- getWord8 bh
23:36:22 <dons> ...
23:36:31 <dons>                         case h of
23:36:32 <dons>                           0 -> return []
23:36:41 <dons> so empty lists are just a single 0 :: Word8
23:36:57 <dons> which must be what the normal 'way' is.
23:37:29 <dons> which explains why it worked when the way was normal, yeah?
23:37:52 <Lemmih> Indeed.
23:38:10 <dons> good bug! cheers.
23:38:17 <Lemmih> 'do x <- get bh; xs <- get bh; return (x:xs)'
23:38:41 <dons> yeah, the recursive case.
23:38:58 <dons> so the index is stored at each point.
23:39:15 <dons> and that also restricts lists to 255
23:39:18 <Lemmih> Oh now it get it. It doesn't save the length of the list. It just puts '0' in the end.
23:39:21 <dons> all for a single byte.
23:40:08 <dons> ah, yyeah. so it's just /= 0 for all other elems
23:40:10 <Lemmih> Wouldn't saving the length of the list once as a 16bit word be more efficient?
23:40:24 <dons> seems so.
23:40:34 <dons> even a Word32 doesn't seem too wasteful.
23:40:44 <dons> hmm... maybe they want to write lazy lists to a network
23:41:02 <Lemmih> Oh well, we're a bit off track now.
23:41:09 <dons> then you want to start writing before you know the length
23:41:33 <dons> Binary came from nhc's general purpose binary lib, so maybe that's the reason
23:42:11 * Lemmih changes Word8 to String and prays everything will go OK.
23:42:36 <dons> it's so untyped and icky!
23:43:08 <Lemmih> GHC should be a library.
23:43:54 <dons> agreed.
23:44:11 <dons> i've mentioned this to SimonM, with ref to our .hi parser.
23:45:29 <Lemmih> It (kinda) worked!
23:46:29 <Lemmih> "unknown symbol `era'"
23:46:38 <dons> cool.
23:46:43 <lispy> Word8?  wasn't that released over a decade ago?  You should upgrade :)
23:47:15 <dons> oh, that's probably the problem -- I was parsing a byte, but it was really Word v8 I was supposed to be looking for.
23:47:31 <lispy> yeah, happens to the best of us
23:49:22 <Lemmih> @google GHC era
23:49:23 <lambdabot> http://www.sxnewera.com.cn/allcotton.htm
23:53:39 <Lemmih> Where does 'era' come from?
23:54:08 <Lemmih> Grep'ing the source of GHC shows nothing.
23:54:46 <Lemmih> D'oh. -R did the trick.
23:55:44 <dons> no idea what it is. haven't seen it before.
23:56:32 <Lemmih> loadEra :: CmmExpr
23:56:33 <Lemmih> loadEra = CmmMachOp (MO_U_Conv cIntRep wordRep)
23:56:33 <Lemmih>           [CmmLoad (mkLblExpr (mkRtsDataLabel SLIT("era"))) cIntRep]
23:58:39 <Lemmih> I wish JaffaCake was here.
