00:29:05 <basti_> hi
00:29:54 <musasabi> shapr: morning
00:32:32 <araujo> "I think the limitations of other languages lead their communities into a mindset of constantly adding features as if it were a Microsoft Office product."
00:33:12 <basti_> -g-
00:33:22 <basti_> so C meta-sucks?
00:35:47 <basti_> it sucks because it makes people write sucky programs
00:36:46 <tuomov> people suck for using C for things it isn't good for
00:37:09 <tuomov> but then again, there aren't too many popular alternatives to it
00:37:43 <tuomov> with alternative being imperative, natively compiled and statically typed (or "typed" as we're talking about C..)
00:38:11 <basti_> PASCAL?
00:38:12 <musasabi> ada ;)
00:38:16 <basti_> :P
00:38:20 <tuomov> ada is popular?-)
00:38:30 <basti_> it has some supporters i think
00:38:33 <tuomov> delphi is used on windows, though
00:38:36 <musasabi> No... which is quite od.
00:38:38 <musasabi> *odd
00:38:45 <basti_> right
00:38:47 <tuomov> don't know how related it is to pascal, and it has never been popular on *nix
00:39:07 <basti_> well afaik ADA was created by the US military and is used a lot there
00:39:24 <tuomov> but not anywhere else
00:39:32 <musasabi> Is there a good reason Ada has never become more popular?
00:40:13 <basti_> it combines the wickedness of functional programs with the pretty notation of imperative ones? ;)
00:40:19 <tuomov> C(++) hegemony
00:40:27 <basti_> i think so too.
00:40:39 <musasabi> point.
00:40:42 <basti_> cobol and c were doing the jobs that ada would habe taken.
00:40:47 <basti_> do not forget cobol!
00:40:55 <basti_> its still twitching
00:48:32 <xerox> 'morning!
00:49:43 <basti_> hi xerox
01:08:51 <basti_> hmm
01:08:56 <basti_> darcs get http://cvs.haskell.org/darcs/cabal
01:09:00 <basti_> nothing is happening though
01:14:28 <beschmi> Copying patch 43 of 526.. <- works here
01:15:05 <basti_> when i ctrl-c it, it lists a whole bunch of patches.
01:15:09 <basti_> but it appears not to work
01:15:17 <basti_> [before failing, of course]
01:15:33 <basti_> no sort of feedback
01:16:07 <beschmi> which darcs version do you use?
01:16:55 <basti_> 1.0.2
01:17:21 <basti_> i'm waiting now, letting it do its thing.
01:17:24 <basti_> maybe something will happen
01:21:25 <basti_> oh
01:21:30 <basti_> it worked.
01:21:41 <basti_> it just didnt give any feedback upon copying the patches
01:57:40 <a4st> hello! how can i create a shared object file (so) to be able to access it later by dlopen (System.Posix.DynamicLinker)?
02:02:39 <Gnosis> hiya all
02:05:44 <beschmi> hi Gnosis
02:06:33 <Gnosis> ppl what is best haskell editor for u?
02:06:49 <basti_> the best editor written IN haskell or FOR haskell?
02:06:51 <blackdog> Yi!
02:06:56 <Gnosis> for
02:06:58 <blackdog> sorry, sorry. back in my box
02:07:21 <basti_> i use emacs.
02:07:26 <basti_> but i use emacs for everything.
02:08:08 <Gnosis> does it has highlight syntax?
02:08:15 <basti_> yes.
02:08:28 <basti_> even indention. (but this still lacks a bit)
02:08:28 <Gnosis> mmm and windows vwesion?
02:08:33 <Gnosis> version?
02:08:53 <basti_> yes.
02:09:02 <Gnosis> tx m8
02:13:42 <a4st> Is it possible to make a library in ghc?
02:14:52 <a4st> just simple static or dynamic library???
02:15:29 <basti_> it is possible to compile libraries.
02:15:39 <basti_> it is possible to make things loadable dynamically
02:15:55 <a4st> how can i compile a so file for example?
02:16:06 <a4st> just 'hello world'
02:16:09 <basti_> you mean like calling from somewhere else?
02:16:16 <a4st> yes
02:16:27 <a4st> i mean ghc switches
02:16:53 <beschmi> you want to call haskell code from C?
02:16:53 <basti_> i mean, do you want to call your haskell program from another haskell program?
02:17:00 <basti_> or do you want to call your haskell code from outside?
02:18:10 <a4st> i just want to compile a shared library that contains a function 'abc' that prints 'hello world'. later i want to link this file dynamically and call the function
02:18:21 <basti_> from haskell or from somewhere else?
02:18:25 <a4st> from haskell
02:18:45 <basti_> okay this point we got.
02:18:51 <a4st> ;-)
02:18:56 <basti_> then, there's a slight obstacle in dynamic linking
02:19:01 <a4st> ?
02:19:11 <basti_> i mean, you probably want something like a plug in dont you?
02:19:25 <a4st> exactly ;-)
02:19:39 <basti_> so you do not only want to link dynamically, but link different things dynamically
02:19:53 <basti_> there's a few frameworks that do exactly that.
02:19:55 <a4st> what do you mean?
02:20:12 <a4st> just one file no more
02:20:24 <basti_> theres a difference if you do an ".so" file and link it dynamically or if you got several files (at least potentially) and link any one of them
02:20:51 <a4st> for beginning only one single file
02:21:12 <a4st> one so file, can i create such one with ghc?
02:21:15 <basti_> yes but its a difference if there might be more than once
02:21:19 <basti_> eh one
02:21:27 <basti_> yes but you wont be able to switch it.
02:21:49 <a4st> what do u mean by 'switch it'?
02:22:09 <basti_> i mean, this file will be the only one that ever works in it position
02:22:16 <basti_> you will not be able to do something like a "Plug in" with that
02:23:14 <a4st> sorry, i don't understand. if i compile a .so file in C, than i'll be able to link it dynamically and call my functions. can ghc this or not?
02:23:40 <basti_> i'd say yes, although i dont know for sure by now (but I'll find out for you)
02:23:47 <basti_> the question is, is that what you really want.
02:25:10 <a4st> i want dynamically determine what file (plug in) should be linked, then i link the chosen file (created in ghc) and call my functions. afterwards i'd like to unload the file.
02:25:43 <basti_> then you need a plugin facility and not only an .so file
02:25:58 <basti_> haskell's type system makes life a little harder concerning plugins
02:26:06 <a4st> in C it's the same, isn't it so in ghc?
02:26:14 <a4st> aaa ok, i see
02:26:14 <basti_> http://www.cse.unsw.edu.au/~dons/hs-plugins/ < you could take this for example
02:26:21 <a4st> ok thx!
02:26:34 <basti_> but there are more frameworks
02:27:08 <a4st> which one would u recomend?
02:27:15 <basti_> i never had to use one
02:27:20 <basti_> but hs-plugins seems to do its job
02:27:26 <a4st> ok
02:28:18 <a4st> looks preaty nice, i'll study it, thx!
02:29:00 <basti_> btw. in c it should be like that also. That you can kludge your linking facilities to do their job despite of that youre conning them into taking other code is just pure luck ;)
02:36:01 <basti_> ld -G x.o -o x.so btw. to turn a .o into a .so
02:36:07 <basti_> a4st:
02:38:01 <basti_> omfg. my gf insists on listening to BOYZONE. Right now.
02:47:40 <a4st> basti_: thx, i'll try
02:54:36 <Philippa> basti_: I feel your pain - I've threatened to destroy speakers to avoid having to listen to boy bands before :-)
02:57:25 <basti_> -g-
02:58:37 <Oejet> Congratulations on Yi 0.1.0!
03:01:09 <TNKS> hey everybody
03:01:31 <shapr> w00
03:02:00 <basti_> hey-y0!
03:02:22 <TNKS> I have a question.  Is there a function (that I would call "unique") that removes redundant entries in a list?  say turning [1,4,2,4,6] into [1,4,2,6]?
03:02:44 <Oejet> @type uniq
03:02:49 <lambdabot> bzzt
03:02:53 <musasabi> nub.
03:02:59 <TNKS> I could write one from scratch, but it seems basic enough that it should exist.
03:03:04 <musasabi> @type Data.List.nub
03:03:05 <lambdabot> Data.List.nub :: forall a. (Eq a) => [a] -> [a]
03:03:16 <TNKS> nice.
03:03:32 <Oejet> Ah, No doUBlicates.
03:03:49 <musasabi> a version needing Ord could be more efficient... (but wouldn't work as nicely with infinite structures)
03:05:21 <basti_> i always thought of nub as being the sound that an element falling out of a list makes
03:06:31 <sylvan>  (map head) . group . sort ?
03:06:35 <Gnosis> tate quietecito tontin
03:07:08 <Oejet> The name nub is like the names car and cdr.
03:17:43 <sylvan> What kind of sort is Data.List.sort nowdays?
03:18:27 <basti_> ascending order.
03:18:32 <basti_> so the 0 is in front if there is any.
03:18:44 <basti_> or did you mean the implementation? :)
03:20:09 <sylvan> the implementation
03:20:49 <basti_> ah i dont know.
03:21:57 <basti_> JHGHGkljhskdfgsd: 'blessya.
03:31:55 <sylvan> it appears to be nlogn so it's probably mergesort
03:34:33 <Lemmih> YES! I can send mails again!
03:38:49 <Oejet>  Quicksort replaced by mergesort, 14/5/2002.
03:38:58 <Oejet> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/List.hs?rev=1.26
03:39:01 <sylvan> sweet
03:39:31 <basti_> mergesort is the choice on nowadays architectures i think.
03:41:39 <sylvan> Why did they ever use Quicksort?
03:42:00 <sylvan> It's O(n^2) for some cases
03:42:14 <sylvan> so it baffles me that they at one point used it for the standard sort
03:42:26 <basti_> its easily implemented? =)
03:42:32 <Oejet> sylvan: No one complained. ;-)
03:42:33 <sylvan> so is mergesort =)
03:42:37 <sylvan> =)
03:42:41 <basti_> and, the average of quicksort is still O(nlogn) isnt it?
03:42:54 <Philippa> yes, or nobody'd call it quick
03:43:27 <sylvan> well mergesort does use more memory, but IMO a guaranteed O(nlogn) is more important than low memory usage... if someone wants lower memory usage they can implement qsort themselves and worry about the special cases where it's O(n^2)
03:43:32 <basti_> yes it is.
03:43:49 <basti_> and mergesort converges well with cache architectures
03:43:53 <sylvan> anyway, it's good that it's mergesort now
03:44:01 <TNKS> hey guys.  Is there a function to repeat iterations of a function of type (a -> a) n times?
03:44:08 <sylvan> iterate
03:44:24 <TNKS> sylvan, nice, thanks.
03:44:28 <sylvan> np
03:44:50 <sylvan> you'll need a "take n" though, since it will do it an infinite number of times
03:45:01 <basti_> or (...) !! n
03:45:07 <TNKS> gotcha
03:45:08 <sylvan> yep
04:10:16 <shapr> dons: synhl today?
04:13:05 <shapr> musasabi: y0
04:13:27 <dons> shapr, yo, me sleeps now :) synhl tomorrow .au time
04:13:30 <shapr> musasabi: just wondering about 'source as literature' and the shootout.
04:13:33 <shapr> dons: awright! w00!
04:13:40 * shapr hops cheerfully
04:13:59 <dons> have you tried out yi-0.1.0 ?
04:14:14 <shapr> I'm building it now.
04:14:16 <sylvan> is there a windows binary available?
04:14:36 <Oejet> How about a Solaris binary? :-)
04:14:43 <dons> no. it is probably not to hard to build with cygwin.
04:14:50 <dons> Solaris should build out of the box
04:15:07 <shapr> it works =)
04:15:14 <dons> cool :)
04:15:35 <dons> I got an interesting email from Malcolm Wallace about what it would take to work with nhc98
04:15:40 <shapr> I found that insChar allows ^1 to show up as 1, and a few other strange props, but I think it calls for QC tests more than anything else.
04:15:46 <shapr> oh that *is* interesting!
04:16:24 <dons> yeah, threading is the main challange, he thinks. but there's some sketch of what would need to be done
04:16:56 <dons> so I'll look again at nhc, and maybe give hugs a whirl. hugs does threads, yeah?
04:18:06 <shapr> I dunno
04:18:11 <dons> sharp: re insChar. yeah. there's still a few simple things like to do deal with.
04:18:26 <shapr> but most of them won't be found without quickcheck tests.
04:18:36 <shapr> Which I would enjoy writing, I think
04:18:49 <dons> that'd be really useful!
04:18:50 <shapr> anyway, I gotta do work right now.
04:19:13 * dons has to sleep now
04:19:31 <shapr> cya tomorra
04:20:59 <shapr> metaperl: hey, I want details!
04:21:09 <metaperl> on?
04:21:15 <shapr> On the compose thingy
04:21:28 <metaperl> i dont know what you are talking about?
04:21:35 <shapr> Your post on sequence
04:21:45 <shapr> http://sequence.complete.org/node/35
04:21:50 <metaperl> omit the question mark... oh , url? ... ok checking
04:22:28 <shapr> Do you have a blog?
04:22:51 <metaperl> sortof -- a sequence.complete.org
04:22:56 <metaperl> sortof -- at sequence.complete.org
04:23:07 <shapr> ok
04:23:11 <metaperl> that idea came to me while reading the Algorithms book
04:23:29 <Oejet> I get an error while building Yi 0.1.0 on  Solaris.
04:24:03 <metaperl> my ideas about implementing those algorithms involved lots of state. So when I looked at how definitional their solutions were, I realized what I wrote... I was actually looking at the heap implementation when it hit me
04:24:17 <metaperl> but I can't be more concrete than that
04:25:18 <shapr> metaperl: ok, if you think up more details, I want to hear.
04:25:36 <shapr> I think you meant that you separate out the basic pieces, and then compose them later.
04:25:50 <shapr> But I'm not sure about that.
04:25:54 <shapr> Oejet: expliquez!
04:28:25 <shapr> metaperl: maybe it would help if I could see what stateful implementation you had in mind when you were looking at the heaps.
04:28:49 <metaperl> yes, it ties in with what Lemmih told me that a function should either access or modify but not do both
04:28:58 <shapr> I really like that Algorithms book. I wonder if Okasaki's book is as good.
04:29:09 <metaperl> how do I get a list of everything I have posted to sequence.complete.org?
04:29:18 <shapr> probably at your user page.
04:29:21 <shapr> Hiya astro
04:29:32 <astrolabe> wotcha shapr
04:29:49 <shapr> How's code?
04:29:52 <lightstep> module A (A) {data A = A}  <-  what is exported?
04:30:06 <musasabi> back
04:30:07 <astrolabe> Code is in C++ :(
04:30:19 <shapr> musasabi: literature, benchmarks?
04:30:37 <shapr> astrolabe: well, it's better than digging ditches for a living.
04:30:41 <lightstep> (with where in the middle)
04:30:47 <musasabi> shapr: I think the code elegance is quite hard to measure - everyone thinks their own petlanguage is the most readable one.
04:30:49 <tuomov> ghc -Wall -Werror -funbox-strict-fields -O2 -fasm -Icbits -Imk  -package-name yi -c Yi/Curses.hs -o Yi/Curses.o -ohi Yi/Curses.hi
04:30:51 <shapr> lightstep: Why not ask ghci? load it and find out.
04:30:52 <tuomov> Curses.hsc:224: parse error on input `import'
04:30:55 <tuomov> make: *** [Yi/Curses.o] Error 1
04:31:01 <metaperl> it's actually right on the homepage: [14:38] [ibid] metaperl: there is a guideline - often forgotten in popular programming - that a subroutine be either a mutator or an inspector but not both
04:31:10 <musasabi> shapr: one idea I have had is a one-liners section into the shootout.
04:31:16 <_JusSx__> how can i bind a command to a key?
04:31:19 <shapr> musasabi: cyclomatic complexity is one way.
04:31:23 <lightstep> shapr, thaqnks, i forgot all about :info
04:31:26 <shapr> _JusSx__: in Yi? or emacs? or what?
04:31:31 <_JusSx__> for example f1 for running my gnome-terminal
04:31:35 <_JusSx__> with X
04:31:39 <musasabi> shapr: with the idea how "elegant and short can this benchmark be expressed in the languages".
04:31:53 <_JusSx__> sorry i know i'm out of topic
04:32:07 <shapr> _JusSx__: depnds on your window manager.
04:32:12 <_JusSx__> gnome
04:32:19 <shapr> musasabi: what about darcs for easy workflow of shootout commits?
04:33:47 <musasabi> shapr: I don't think that would work for alioth - for the haskell solutions setting up darcs and committing from that to alioth via cvs would be possible - if there are more people that would like to work on it.
04:33:57 <shapr> If I hypothesize an elegance benchmark website started to match the alioth shootout, I would want something vaguely like the deviantart website that allows people to critique a solution.
04:34:44 <musasabi> shapr: the problem is that it is very hard to think whether something is intuitive if the language is foreign.
04:35:00 <musasabi> e.g. the forth and haskell solutions for a typical php programmer.
04:35:04 <shapr> Which is why I wouldn't say much about the OCaml solutions.
04:35:56 <shapr> A cyclomatic complexity benchmark would give an advantage to partial application based solutions.
04:36:42 <shapr> I guess you'd need to start with a core of trusted language-specific judges for each lang.
04:37:26 * musasabi has no real experience with cycl. complexity measurements.
04:37:45 <shapr> Any other ideas for a website that rewards source code as communication with humans?
04:38:10 <shapr> cyclomatic complexity is essentially just calculating parse tree metrics.
04:38:27 <shapr> Hiya hlafarge
04:38:41 <musasabi> shapr: but is it really comparable between languages?
04:38:52 <musasabi> e.g. how would monads work with that?
04:38:54 <shapr> I included an url that discussions that.
04:38:59 <shapr> Good question.
04:39:25 <shapr> In the source, monads have a tiny parse tree impact. In the fully filled in external core, I bet it's huge.
04:39:39 <shapr> Arrows are even further along that imbalance.
04:39:41 <musasabi> yes...
04:39:50 <shapr> tiny little input, *huge* output.
04:39:56 <shapr> But isn't that the strength of high-level languages?
04:40:07 <lightstep> such as perl?
04:40:19 <astrolabe> The strength and the weakness I think
04:40:21 <musasabi> I think it is very important how robust and intuitive those abstractions are.
04:40:28 <musasabi> and that is very hard to measure.
04:41:19 <shapr> Best I can suggest there is the extensible monadic interpreters paper.
04:41:49 <shapr> So the code for reading website would need a section on patterns for speedy change, I guess.
04:42:12 <Oejet> tuomov: I also get errors in Yi/Curses.hsc
04:42:28 <tuomov> It seems to have been something in my repository..
04:42:50 <Oejet> I have the 0.1.0 tarball.
04:42:55 <tuomov> I re-getted it (dons: please run optimize --checkpoint...) and pull my own patches (joe mode) and it seems to work
04:43:17 <shapr> I can do optimize --checkpoint on the Scannedinavian repo
04:43:38 <Oejet> ~/yi-0.1.0 > gmake way=static
04:43:38 <Oejet> Makefile:109: depend: No such file or directory
04:44:10 <musasabi> What state is Yi 0.1 ?
04:44:19 <musasabi> featurewise that is.
04:44:23 <shapr> musasabi: I think it's impossible to unit test poetry, but it is possible to recognize some poetry as better than others.
04:44:47 <shapr> And I think specific points can be described, pointing out how one poem is better than another.
04:45:01 <tuomov> well, scannedinavian is fast without optimisation.. should switch to it perhaps
04:45:02 <shapr> That's the best thing I can think of for a website that encourages code as communication with humans.
04:45:08 <musasabi> shapr: but to hold a poetry contest you have to select judges and cannot really claim that it is anything else than a subjective claim.
04:45:30 <musasabi> of course one can measure invidual metrics of a poem.
04:45:45 <musasabi> but whether a poem is good or not is about the whole, not those metrics.
04:45:49 <basti_> you could claim that there is some sort of average score
04:46:08 <basti_> and that it is stable.
04:47:05 <tuomov> hm... killLineE has been broken
04:47:08 <Oejet> tuomov: Is this what it's doing correctly? hsc2hs -Imk -Icbits  -DGLASGOW_HASKELL=604  Yi/Curses/Curses.hsc
04:47:23 <tuomov> it doesn't kill the linefeed
04:47:52 <shapr> Some code is more elegant than other code. That may be Quality Without A Name, but it can be somewhat discussed.
04:48:17 <shapr> I'd like a website that gets as close as it can get. But I'm not sure how to approach that.
04:49:27 <basti_> Are we going Tao/Zen & the art of motorbike maintance here? ;)
04:49:39 <shapr> You almost have to.
04:49:58 <basti_> sure...
04:50:12 <basti_> makes more sense than most philosophy
04:51:07 <shapr> I'd like to grab the benchmarks that the alioth shootout has, and get elegant solutions from users.
04:51:51 <shapr> Then I'd like to critique those solutions for implementation elegance, communication with readers (ease of understanding), and flexibility (speed of change).
04:53:44 <shapr> Because I learned *lots* about better Haskell when I did the ICFP content with Heffalump and Igloo. And I think such a code as human communication website could pass the same sort of knowledge to others.
04:54:49 <astrolabe> It sounds good shapr.  I think trying to make a metric would be counter-productive.
04:55:48 <shapr> That's a possibility I hadn't considered.
04:56:27 <astrolabe> On that subject, is there a moderately efficient way of calculating fibonnaci numbers in Haskell?
04:56:52 <shapr> yes
04:57:05 <astrolabe> Without using the golden ratio formula!
04:57:19 <shapr> fib = 0 : 1 : zipWith (+) fib (tail fib)
04:57:53 <astrolabe> Ooooh that's nice
04:58:17 <smott> fibs@(_:rest) = 0 : 1 : (zipWith (+) fibs rest)
04:58:33 <smott> i found that on wikipedia and it's supposed to be fast, but i'm not sure how it works
04:59:04 <shapr> take 5 fib
04:59:46 <shapr> musasabi: cyclomatic complexity across languages - http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR141.pdf
04:59:53 <xerox> hiya !
05:01:47 <musasabi> shapr: thanks, I'll read that. Now laundry =>
05:01:59 <shapr> Yeah, I gotta go back to work too.
05:02:05 <xerox> Good work shapr
05:02:10 <TNKS> smott, wierd.  A day or so ago, I was on here asking some questions about memoizing using Fibonacci as an example, and the topic seems to have resurfaced
05:04:59 <TNKS> smott, Slide 99 at http://www.cs.utexas.edu/users/ham/UTCS/CS345/Lectures/cs345LectureNotes.html covers memoization pretty well, using Fib as an example.
05:09:53 <smott> TNKS: interesting, thanks. i must admit i've been hearing a lot about memoization recently, i'll have to look into it
05:10:08 <shapr> memoize' f range = ((map f range) !!)
05:11:33 <shapr> You should check the logs, about a month ago autrijus showed several versions of fib, and that shows memoization in action.
05:11:56 <xerox> If you find it in the logs paste the url please :)
05:12:35 <shapr> smott: btw, where on wikipedia?
05:14:34 <smott> shapr: http://en.wikipedia.org/wiki/Haskell_programming_language
05:14:37 <TNKS> shapr, I didn't find any reference to a memoize' function in GHC's Heirarchical Libaries documentation.
05:14:48 <TNKS> but I've seen reference to it.
05:14:52 <TNKS> where is it?
05:14:54 <shapr> memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
05:15:03 <shapr> I got that from Lauri Alanko, aka Lor here on #Haskell.
05:15:29 <TNKS> nice.
05:16:16 <astrolabe> shapr: I've finally understood your comment about astrophyiscists brains.  Groan!  An astrolable was the pre-mechanical version of a pocket watch.  All educated men used to have them.
05:17:19 <shapr> What was the comment?
05:17:25 * shapr tries to remember.
05:18:12 <astrolabe> 'astrolabe?  Is that what astrophysicists have in their brains', or something like that.
05:18:45 <shapr> Oh, part of that joke was an 'astrolobe' like the 'frontal lobe'
05:19:03 <astrolabe> Yeah.  Only took me a few days to get it :)
05:19:23 <shapr> People claim I'm a highly nonlinear process.
05:19:37 <shapr> And that it often takes days to understand what I said.
05:19:42 * shapr isn't sure why that is...
05:21:28 <shapr> astrolabe: Speaing of 0ld sk00l hardware, I collect slide rules.
05:21:56 <astrolabe> Ah cool!  I've recently bought a slide rule.
05:22:07 <shapr> Oh, what flavor?
05:22:12 <astrolabe> And I've got one on my watch.
05:22:22 <shapr> wow, spiffy!
05:22:49 <astrolabe> Concise No.300 circular
05:22:58 <shapr> ohhh circular is the best!
05:23:15 <xerox> What's a slide rule?
05:24:20 <astrolabe> It is a way of performing calculations mechanically and in analogue
05:24:33 <shapr> http://www.hpmuseum.org/srinst.htm
05:25:11 <astrolabe> Imagine how you would do addition using two rulers to slide against each other.  Now make the ruler scales logaritmic, or something else.
05:26:08 <shapr> The circular and cylidrical slide rule sections here are interesting - http://www.hpmuseum.org/prehp.htm
05:26:22 <xerox> Ah
05:26:29 <astrolabe> What kind do you have shapr?
05:26:54 <shapr> I forget the name of it. It's a straight rule with very many scales.
05:27:36 <shapr> it's about 1.5 feet long and two inches tall. It has one slidey bit.
05:28:05 <shapr> Amusingly, I got it from my high school when they were throwing it in the trash.
05:28:18 <shapr> leather case, full instructions, etc
05:28:29 <astrolabe> You are in high school?!
05:28:47 <shapr> No, I was in high school until 1989.
05:29:14 <astrolabe> LOL that makes more sense, and is less scary.
05:42:09 <shapr> Yow, wikipedia calls Haskell an academic language?
05:42:54 <shapr> Same for Pascal, Scheme, and Smalltalk. Hm.
05:42:55 <ibid> if you think it's wrong, why don't you fix it?
05:43:07 <ibid> (be bold in updating pages)
05:43:27 <shapr> What qualifies as academic?
05:43:43 <shapr> Two companies use Haskell primarily, you think that works?
05:45:22 <astrolabe> Do you think most haskell code is written by students and professors?
05:45:36 <ibid> well, it is an ambiguous term
05:45:44 <ibid> which is why it probably should be written out
05:46:34 <ibid> haskell. pascal and scheme (but not smalltalk!) are academic in the sense that they were created by academians as academic activity
05:46:40 <shapr> I'd call unlambda an academic language, it's designed to enlighten rather than make real programs.
05:46:58 <ibid> c and c++ are industrial in that ... you get the picture
05:47:36 <ibid> quite possibly it's even against NPOV
05:47:41 <shapr> NPOV?
05:47:43 <shapr> neutral?
05:48:01 <ibid> neutral point of view, the cornerstone of wikipedia's code of conduct
05:48:04 <shapr> ah yes
05:52:06 <xerox> Hello hunter :D
05:55:56 <metaperl> shapr, you might find this interesting: http://sequence.complete.org/node/40
05:56:19 <metaperl> I just wrote it.
05:56:39 <metaperl> It's funny you all would be discussing theoretical purity of language at the same time I would be writing a post on it
05:57:15 * Heffalump asserts that he is better than metaperl
05:57:22 <metaperl> lol
05:57:33 <Heffalump> :-)
05:57:46 <metaperl> you are: anyone that can write a 2-pass optimizing compiler for an Ant Language and take 1st place in ICFP 2004 is pretty damn good
05:58:12 <metaperl> Heffalump, were you born in India?
05:58:20 <Heffalump> no, England (my parents are Sri Lankan)
05:58:36 <metaperl> I see. Do your parents practice a religion?
05:58:39 <Heffalump> I think our compiler was more than 2 passes. They were all a bit random, really.
05:58:47 <Heffalump> not really. Certainly not one they taught me.
05:59:15 <ozone> metaperl: one bit of advice for you.  you write "I have yet to see one arrogant hothead anywhere."
05:59:18 <TheHunter> hey xerox.
05:59:26 <ozone> metaperl: if you ever meet a guy named jerzy, just ignore him ;)
05:59:39 <Heffalump> anyway, I have no idea what kind of programming skills you have, so I have no way of comparing us :-)
05:59:47 <Heffalump> ozone: Karczmarczuk?
05:59:48 <ozone> that's my arrogant claim for the day
05:59:48 <metaperl> I see: I am fascinated by religious systems and how certain religious systems adherents are family groups and other religious systems have only individiual non-family adherents
05:59:51 <Heffalump> possibly not quite spelt that way
06:00:03 <ozone> Heffalump: maaaaaaaaybe :)
06:00:09 <Heffalump> ozone: he's never struck me as arrogant
06:00:16 <Heffalump> a bit odd, maybe
06:00:25 <ozone> i prefer the word "idiot"
06:00:39 <ozone> though "closed-minded" is less offensive, and more accurate
06:00:40 <metaperl> is he ever on this IRC channel?
06:00:47 <Heffalump> he's written some quite cool stuff
06:00:53 <ozone> metaperl: don't think so, but if he is, i guess i'll find out soon
06:01:02 <Heffalump> he has a unique way of thinking that sometimes seems like rubbish, and sometimes seems to come up with neat ideas
06:01:04 <ozone> Heffalump: totally agreed
06:01:19 <ozone> Heffalump: but his closed-mindedness irks me
06:01:36 <Igloo> I think there's a reasonable amount of arrogance around, but it doesn't tend to manifest itself in a nasty form
06:02:10 <ozone> Igloo: heh, true
06:02:14 <ozone> except in debates about unicode ;)
06:02:46 <Heffalump> metaperl: are you saying that for some religions there's more of a family correlation than for others?
06:03:00 <Heffalump> see, it's conversations like this (about Jerzy) that make me wish the logs weren't googlable.
06:03:04 <metaperl> "On compositionality of languages and their ability to do useful things in the Real World"
06:03:14 <metaperl> Heffalump: yes, and that fascinates me
06:03:37 <Heffalump> I reckon it's mostly tied to age.
06:03:39 <metaperl> Heffalump, Judaism and Quakers and Mormons for instance have a high family value
06:03:57 <ozone> Heffalump: if only i had some alcohol in me
06:03:58 <Heffalump> The newer religions (what most people would consider to be 'cults') tend to be more random than the older ones.
06:04:09 <ozone> life would be much more fun!
06:04:15 <metaperl> well, some cults are family-oriented
06:04:24 <metaperl> Koresh's cult was
06:04:26 <Heffalump> I'm not arrogant, but Australians are all useless </ob-troll>
06:04:29 <metaperl> Jim Jones' cult was
06:04:34 <Heffalump> metaperl: true.
06:04:49 <metaperl> but let's consider massage a spiritual path...
06:04:50 <ozone> Heffalump: right you are!
06:05:07 <metaperl> very few families all study to become massage therapists/bodyworkers en masse
06:05:40 <Heffalump> metaperl: Catholicism has a fair high family value too
06:05:53 <Heffalump> as well as this requirement for mixed marriages to bring up children Catholic
06:06:10 <metaperl> mixed? racially?
06:06:44 <Heffalump> Catholic+non-Catholic.
06:07:03 <Heffalump> For the Catholic church not to kick out the Catholic, the couple have to promise to bring up their children as Catholics.
06:07:29 <Heffalump> (such coercive behaviour is IMO one of the evil things about the Catholic church)
06:07:31 <shapr> ozone: I lik jerzy.
06:07:35 <basti_> why is catholic bashing so popular in the USA btw? ;)
06:07:44 <shapr> I think bashing is popular in general.
06:08:00 <Heffalump> is it popular in the USA?
06:08:05 <shapr> Sure.
06:08:09 <shapr> bashing, tha tis.
06:08:16 <ozone> bashing sure is more popular than zshing
06:08:17 <Heffalump> I thought half the USA liked that kind of rabid right-wing sentiment.
06:08:22 <basti_> i mean for example, John F. Kennedy...
06:08:30 <shapr> metaperl: I have a followup to your article... I propose that libraries are a crutch for insufficiently expressive languaes.
06:08:30 <basti_> everyone is sure to mention he was catholic
06:08:41 <shapr> I didn't know he was a catholic until you just said it.
06:08:41 <basti_> as if that would mean anything
06:08:56 <basti_> hmm oka
06:08:57 <basti_> ;)
06:09:00 <Heffalump> isn't that cos he was the first Catholic president and it was considered that there was discrimination against Catholics?
06:09:00 <metaperl> shapr, please post that: I have a rebuttle
06:09:06 <shapr> oh, nifty
06:09:15 <basti_> Heffalump: something like that yes
06:09:23 <Spark> shapr, metaperl: this is all rather civilised
06:09:24 <Heffalump> how can having a CGI cookie library count as a crutch?
06:09:37 <metaperl> lol
06:09:55 <basti_> Heffalump: but then, wtf? whats bad about catholics? about 30% or something of usa citizens are catholic...
06:10:08 <metaperl> shapr: we can also say: Perl is a big language with big libraries. Scheme is a small language with big libraries
06:10:23 <shapr> metaperl: ok, posted
06:10:24 <Heffalump> I dislike Catholicism, not Catholics per se.
06:10:25 <metaperl> can I get a degree in Sociology of Software Engineering?
06:10:30 <shapr> Spark: what's civilized?
06:10:44 <Heffalump> (and about 50% of the US voted for Bush, so claiming that something is good by sheer numbers is meaningless :-p)
06:10:57 <Heffalump> well, 50% of the US that voted, which probably does work out at about 30%.
06:10:58 <basti_> hmmm ok
06:10:59 <basti_> ;)
06:11:08 <metaperl> Heffalump, Bush rigged the polls
06:11:21 <shapr> oh, you mean this discussion? Personally, I'm looking for new ideas and new solutions. I have greater access to ideas and solutions if the discussion stays civilized.
06:11:25 <Spark> shapr: telling him you had a followup before posing it
06:11:31 <Heffalump> he couldn't have rigged them that much. Somewhere close to 50% voted for him, even if it wasn't over 50%.
06:11:31 <Spark> heh
06:11:31 <metaperl> I'm stating that without solid evidence. But in certain cases, it is almost 100% obvious
06:11:40 <Spark> you have control over your emotional state? geek!
06:11:46 <shapr> Mostly, yes.
06:11:47 <basti_> lol
06:11:49 <basti_> spark
06:12:04 <shapr> Emotional discussions rarely help communicate new ideas.
06:12:17 <basti_> I think the "rigging" in the us elections was a) subtle b) effective c) illegal
06:12:22 <metaperl> shapr: in some cases, your assertion is correct
06:12:34 <basti_> eg. "garrymandering"
06:12:35 <metaperl> shapr: note that on CPAN people write things liek Language::Functional
06:12:45 <Heffalump> gerrymandering isn't illegal in the US, is it?
06:12:49 <metaperl> but haskell people rarely write Language.Perl
06:12:56 <metaperl> what is gerrymendaring?
06:13:00 <basti_> Heffalump: its not by the letters of the law.
06:13:01 <shapr> @wn gerrymandering
06:13:03 <lambdabot> No match for "gerrymandering".
06:13:06 <shapr> @wn gerrymander
06:13:08 <lambdabot> *** "gerrymander" wn "WordNet (r) 2.0"
06:13:08 <lambdabot> gerrymander
06:13:08 <lambdabot>      n : an act of gerrymandering (dividing a voting area so as to
06:13:08 <lambdabot>          give your own party an unfair advantage)
06:13:08 <lambdabot>      v : divide unfairly and to one's advantage; of voting districts
06:13:13 <Heffalump> redrawing electoral boundaries to improve the electoral outcome for yourself
06:13:32 <basti_> but thats not the only rigging that happened.
06:13:36 <Heffalump> you get some *really* weird shaped ones in the US, because the state legislatures generally control the boundaries of congressional districts
06:13:50 <basti_> i fear that the truth about these election computers will never be known.
06:14:21 <metaperl> I have some pretty damning evidence about 911
06:14:31 <Heffalump> elections in the UK are becoming more and more fucked up too :-(
06:14:44 <Spark> wordnet is awesome
06:14:44 <basti_> which shows the bad technical maintance state of the US democracy.
06:14:48 <basti_> metaperl: like what? ;)
06:14:58 <Spark> its the only decent online thesaurus ive found :) (i know its not intended for this)
06:15:04 <Spark> but a nice thesaurus is useful for programming
06:15:15 <metaperl> basti_ : 2 films....
06:15:19 <metaperl> I will give you the URL
06:15:22 <Spark> to help lift the lexical burden
06:15:34 <basti_> k
06:16:12 <shapr> metaperl: hey, did you read the blog entry I linked to?
06:16:36 <basti_> but you know i'm a false belief debunker?
06:16:40 <shapr> metaperl: anyway, I'd like to solve the problem you mention, that there aren't enough libraries for Haskell.
06:16:51 <shapr> basti_: I don't believe you.
06:16:52 <metaperl> shapr, not yet
06:16:59 <basti_> hmm how about a swig thing for haskell?
06:17:11 <ozone> metaperl: well, cabal will hopefully help a lot
06:17:14 <basti_> is there one?
06:17:17 <metaperl> shapr: libraries is just the start. PHP has become king of web scripting and shall not be dethroned
06:17:28 <ozone> it's been very, very overdue and very needed
06:17:45 <ozone> perl with no CPAN would have been much less successful
06:17:51 <metaperl> PHP is the worst language but the best for doing things... PHP puts its money where its mouth is: it _delivers_
06:18:00 <ozone> so hopefully cabal will have some real positive impact
06:18:05 <metaperl> CPAN is like a mushroom on a wet stump ozone
06:18:08 <metaperl> it had to occur
06:18:12 <basti_> lol
06:18:13 <shapr> man, I hate top-posting.
06:18:29 <shapr> metaperl: what's next after libraries?
06:18:43 <vegai> is there a haskell replacement for autotools?
06:19:00 <shapr> There's a make replacement named maak, but it's not maintained.
06:19:06 <metaperl> shapr: apps
06:19:07 <shapr> I'm tempted to steal it and update it.
06:19:15 <ozone> metaperl: only because your community demanded it
06:19:16 <metaperl> shapr: phpMyAdmin, drupal, phpBB
06:19:30 <shapr> metaperl: ok, I'm in.
06:19:35 <metaperl> moinmoin --- how could haskell.org use a python-powered wiki instead of Phillipa's
06:19:41 <vegai> what about checking dependencies: libraries, headers, et al?
06:19:41 <ozone> demand for cabal hasn't been as high in the haskell community as demand for CPAN would have been in the perl community
06:19:51 <shapr> metaperl: because we want solutions, and Flippi wasn't available.
06:20:01 <shapr> I switched from PikiPiki to MoinMoin
06:20:06 <shapr> and I wanted a Haskell wiki!
06:20:17 <metaperl> that's just my point: the worst languages have the most solutions for real-world problems
06:20:27 <basti_> is that inherent?
06:20:31 <metaperl> Haskell is great for Ant simulations, but where is Microsoft Word?
06:20:33 <metaperl> :)
06:20:46 <shapr> I think that's because those languages are easier to start using, and so people tend to focus on their solution rather than learning a powerful language.
06:20:52 <metaperl> basti: I think it is a great Sociology of Computer Science question
06:20:59 <shapr> Are more documents written in notepad than ms word?
06:21:03 <basti_> maybe "real world problems" are just pretty hairy most of the time
06:21:13 <shapr> Yeah, but Haskell handles hairy problems just fine too.
06:21:18 <basti_> yes.
06:21:19 * metaperl is an ethno-computational sociologist
06:21:26 <basti_> but haskell is hard to lern. if you believe C-users
06:21:32 <shapr> I claim it's because most people don't want to (mentally) move very far from where they sit to do something.
06:21:47 <shapr> Most people want a passable solution for the least amount of effort.
06:21:54 <shapr> Rather than a *good* solution for more effort.
06:21:56 <basti_> yup
06:22:06 <basti_> the perl problem
06:22:09 <metaperl> haskell does not allow you to hand-hold things... you have to be ready to say do this instead of taking 5 lines to do it
06:22:10 <shapr> I'm a more effort for better solution kind of guy.
06:22:21 <shapr> metaperl: eh?
06:22:51 <basti_> I think he meant haskell is pretty terse and abstract
06:22:55 <metaperl> the reason that imperative languages are popular is that people get to spend 5 lines doing something. which would take 1 line of Haskell
06:22:59 <metaperl> basti: yes
06:23:13 <basti_> as opposed to java where even in the most high level program you would encounter some "int i=0" things
06:23:30 <metaperl> human beings live life oriented towards objects and state and then this computer language called haskell takes all of that from them
06:23:34 <shapr> Why is verbose popular?
06:23:41 <shapr> ohh!
06:23:45 <basti_> thats another end of the problem i think. in haskell, "the language" (the one used) changes
06:23:52 <shapr> metaperl: hey! I bet that explains why I like Haskell so much! My life is purely functional!
06:23:55 * shapr bounces
06:24:06 <shapr> metaperl: ADHD means state leaks out of my head.
06:24:14 <shapr> So I require patterns that work in any situation.
06:24:17 <basti_> theres this song line...
06:24:31 <metaperl> ooooooooooooooooooooooooooooooooooopppppp
06:24:44 <shapr> ?
06:24:49 <basti_> my body's fully functional, but totally remote controlled.
06:24:54 <metaperl> the "o" key on my laptop keeps sticking... and I am using an external keyboard. I think a banshee is touching the keys
06:25:00 <shapr> oh, neat.
06:25:11 <basti_> some swandive song... if I just could remember the title
06:25:21 <shapr> basti_: yeah, Haskell changes the rules with monads. You're extending the language, embedding a new language, etc.
06:25:26 <shapr> But that's *powerful* !
06:25:29 <basti_> yes
06:25:34 <shapr> If the rules suck, change 'em!
06:25:36 <basti_> but it makes code hard to read in the beginning
06:25:41 <shapr> That's true.
06:25:44 <basti_> you open a file and there's stuff you dont understand
06:25:48 <shapr> Yeah, good point.
06:25:50 <basti_> (because you dont understand the problem)
06:25:58 <shapr> And because your assumptions can change.
06:26:07 <basti_> in java theres still "class MyThingFactoryConsumerProducer {"
06:26:14 <basti_> and "i++"
06:26:25 * vegai groans.
06:26:33 <basti_> i blame a whole lot of C's success on this "++" operator.
06:26:41 <shapr> metaperl: The movie Memento was obviously about Haskell.
06:26:42 <metaperl> vegai, I know you from some where .. # scheme perhaps?
06:26:49 <shapr> vegai: groan about what?
06:26:54 <metaperl> I dont know about that movie
06:27:02 <vegai> class MyThingFactoryConsumerProducer
06:27:05 <basti_> lol
06:27:08 <metaperl> oooooooooooooooooooooooooooooooooooooooooooooooooooooo
06:27:13 <autrijus> shapr: I'm changing the Pugs evaluator into a compiler
06:27:14 <vegai> metaperl: yes
06:27:17 <shapr> autrijus: yay!
06:27:19 <autrijus> shapr: without touching a line in Eval.hs
06:27:21 <shapr> wow
06:27:25 <metaperl> ooooooooooooooooooooooooooooooooooooo
06:27:31 <autrijus> shapr: simply by redefining the Eval monad and some TH magic
06:27:31 <metaperl> i am not touching my laptops keys!
06:27:41 <autrijus> so, yay for monadic programming.
06:27:45 <basti_> metaperl: if it wouldnt be so annoying for you, i would laugh.
06:27:52 <metaperl> lol
06:27:56 <shapr> autrijus: very impressive
06:27:58 <basti_> maybe you have caught some malware?
06:28:36 <ozone> hooray for pugs, maybe the best publicity haskell has ever received :)
06:28:43 <basti_> i remember this guy, who had some old wacko microcomputer as a chat terminal.
06:28:53 <basti_> the computer used a special keyboard
06:29:04 <shapr> I think Pugs may end up being the best Haskell intro also.
06:29:07 <basti_> with unusual wiring.
06:29:31 <basti_> once he slept in, laying on his kb, and his kb was posting confusing things into the channel
06:29:34 <Heffalump> PUgs is cool.
06:29:39 <Heffalump> s/PU/Pu/
06:29:53 <basti_> pugs is really impressive.
06:29:55 <ozone> if Heffalump declares Pugs is cool, it must be cool
06:30:01 <ozone> (no sarcasm intended)
06:30:20 <shapr> cm: is leetspeak.org yours?
06:30:20 <Heffalump> I haven't looked at the implementation itself, it's just what I've read about it.
06:30:25 <autrijus> hi Heffalump :)
06:31:01 <Heffalump> hi :-)
06:31:20 * Heffalump wonders what the chances of it ending up as the 'real' Perl6 implementation are
06:34:27 <autrijus> 100%.
06:34:30 <autrijus> :)
06:35:07 <Heffalump> :-)
06:36:32 <Heffalump> hmm. So actually, it's bad, cos it's advancing Perl ;-)
06:36:49 <autrijus> except Perl will be functional :)
06:36:53 <autrijus> at its core, that is.
06:37:20 * autrijus thinks perl is a nice scripting language for haskell libraries, really.
06:37:35 <autrijus> the "imperative skin" is still syntactically inconvenient at times.
06:38:06 <RemiTurk> hello
06:38:09 <Heffalump> does your implementation have an easy escape route into Haskell, then?
06:38:30 <autrijus> that's what my client pays me for.
06:38:31 <Heffalump> i.e. how complicated is the interface that some Haskell wanting to pretend to be Perl has to satisfy
06:38:53 <autrijus> look at this?
06:38:54 <autrijus> http://svn.openfoundry.org/pugs/modules/SHA1/lib/SHA1.pm
06:39:03 <autrijus> (which wraps http://svn.openfoundry.org/pugs/modules/SHA1/src/SHA1.hs)
06:39:18 * Heffalump rereads the FAQ about Pugs and Haskell libraries.
06:39:49 <Heffalump> cool.
06:40:09 <autrijus> the code is in http://svn.openfoundry.org/pugs/src/External/Haskell.hs
06:40:17 <autrijus> needs some cleanup and I need to walk .hi better
06:40:22 <autrijus> but that's the idea :)
06:40:25 <xerox> Sigh, I'm having lookup problems, can you resolve svn... for me?
06:40:33 <ozone> autrijus: geez, nice++
06:40:38 <Heffalump> [ganesh@rocky house-accounts]$ host svn.openfoundry.org
06:40:38 <Heffalump> svn.openfoundry.org     A       140.109.17.109
06:40:40 <autrijus> 140.109.17.109
06:40:46 * metaperl feels left out of Perl 6
06:41:27 <metaperl> I feel like I'm not as involved as I could be
06:41:36 <autrijus> metaperl: tell you what, I feel the same way.
06:41:38 <metaperl> I think I know more Haskell than most of the Perlers working on Pugs
06:41:51 <autrijus> at this speed I don't think anyone can follow :)
06:41:53 <metaperl> but I am doing less for the project and know less Perl6 than most of them
06:42:00 <autrijus> so we just, like, batch-sync once in a while
06:43:15 <metaperl> yes, I was working on Wadler's monadic implemetation of compilers and interpreters
06:43:29 <metaperl> it is very interesting but way below the technology in pugs
06:44:14 <metaperl> oh well, it is best for me to just not feel obligated to work on pugs and know it... best just to keep doing what I like and stay focused and do it well
06:48:07 <shapr> metaperl: you'll be able to apply that to p6 at some point.
06:48:56 <metaperl> yes, I think so. my goal is to methodically improve my Haskell
06:49:33 <metaperl> how that ends up mapping to pugs/perl6 is important only to my interest in looking important in the Perl community
06:49:46 <shapr> heh
06:50:01 <metaperl> the key thing is to really get comfortable with the new and powerful mindset that is required for using Haskell well
06:50:14 <shapr> I try to apply myself purely functionally, I improve what I can and don't worry about what I can't.
06:50:31 <shapr> No side-effects, er, I mean regrets.
06:51:32 <shapr> Though I don't know what to do about Python. I see great need for change, but imho Guido and the community are going in the wrong direction.
06:51:50 <metaperl> what are they doing?
06:51:56 <metaperl> I know nothing about python
06:51:57 <xkb> hello all
06:52:02 <metaperl> hi xkb
06:52:09 <shapr> FP bits will be cut out of Python 3K.
06:52:11 <xerox> Stripping out functional style from python, I think.
06:52:12 <shapr> hoi xkb
06:52:24 <xkb> Does anyone here know how statically typed languages handle exceptions in their type system?
06:52:33 <esap> xkb: sure.
06:52:38 <xkb> as an exception does not match with the normal return type
06:52:43 <shapr> no more lambda, map, reduce, filter. Use generators instead. But generators aren't about first class functions.
06:52:46 <shapr> hei esap! ltns!
06:52:58 <esap> hei shapr
06:53:36 <shapr> esap: would you have time to collaborate on an article for the May issue of TMR ?
06:53:48 <xkb> do they return bottom when an exception is raised?
06:53:57 <xkb> shapr: I really liked issue 1 of TMR
06:54:05 <metaperl> sounds like those people who refuse to prove things by contradiction. the constructivists
06:54:05 <shapr> I think you and Alistair Bayley (and maybe me) would turn out a fascinating article on FPvsOO
06:54:08 <shapr> xkb: yay!
06:54:15 <shapr> xkb: credits to the authors
06:54:24 * xkb showed it to a few of my collegues.. they also liked it alot. even though they are Clean(ers)
06:54:52 <Heffalump> xkb: well, Java just lists the exceptions as part of the method type
06:54:53 <shapr> There won't be an April 1st issue, sadly. But there will be a May issue.
06:54:59 <Heffalump> Haskell essentially ignores them
06:55:03 <esap> shapr: I've written lots of text already, but it got a bit lengthy and I noticed some problems with the current text, which I need to fix.
06:55:14 <Heffalump> you could also imagine listing the exceptions in the type using something like Either
06:55:26 <xkb> Heffalump: so you can't typecheck your exceptions compile time with haskell
06:55:52 <tuomov> there aren't typed exceptions in non-IO (and other monad?) haskell code
06:55:53 <Heffalump> correct
06:56:14 <Heffalump> exceptions aren't really typed at all in Haskell, you just get a chance to inspect the type of thrown values
06:56:19 <tuomov> and within the monad its up to the monad to interpret the result
06:56:22 <shapr> esap: could I see what you've written?
06:56:32 <esap> xkb: I've seen two kinds of exception typing. One based on double-negation elimination.
06:56:32 <Heffalump> oh, yes, exception monads make the exception type explicit
06:56:34 <shapr> esap: have you already seen Alistair's various writings?
06:56:37 <xkb> aha.. I am writing a piece on exceptions in Clean now, using a third file to describe the type of errors that can be returned
06:57:00 <esap> xkb: and another which uses subtractive logic.
06:57:02 <shapr> I wish I had the TMR author's wiki up already.
06:57:15 <xkb> esap: Ill google for those terms
06:57:17 <esap> shapr: which writings?
06:57:51 <shapr> The ward's wiki page, and some email he sent to me. Obviously you haven't seen the emails yet :-)
06:58:02 <esap> shapr: Sure, hold on, I'll make a .dvi of the text and put it so you can get it, hold on a sec.
06:58:05 <shapr> yay
06:58:15 * RemiTurk hopes he won't be shot for abusing #haskell in his attempts to stop his xchat from SEGVing on exit
06:58:41 <shapr> lambdabot is our channel enforcer, you have to be nice to him.
07:00:23 <RemiTurk> shapr: that's the kind of abuse I meant: connecting with a version with various kinds of compileflags/debugging settings (and this one still died a miserable death)
07:01:34 <shapr> You could also do that on a test channel.
07:01:53 <shapr> just join #remiturk and try it there?
07:02:02 <Heffalump> it's not exactly excessive yet
07:02:06 * RemiTurk will do that
07:04:58 <Lemmih> shapr: Still hosting Haskell software on scannedinavian.org?
07:05:07 <shapr> yeah, sort of...
07:05:23 <shapr> As in, I haven't had much time to dedicate to it recently.
07:05:27 <Lemmih> Could I get you to host http://212.242.49.100/repos/SDL ?
07:06:52 <shapr> Yes. Btw, one way to do auto-patches would be for me to cron a darcs pull from your box for repo mirrors.
07:09:27 <Lemmih> Yeah but I would rather fix the problem at its source.
07:10:08 <shapr> Our ability to send email?
07:10:17 <shapr> I have the same problem since SASL is such a PITA.
07:16:21 <shapr> metaperl: I'd like to hear your thoughts on libraries as crutches for low level languages. My intuition tells me that the idea is right, but something fundamental is wrong in how I express the idea.
07:16:36 <metaperl> shapr, remember Heffalump's comment?
07:16:54 <metaperl> I do agree to some extent and will postnw
07:16:57 <metaperl> post now
07:17:25 <metaperl> in the meantime.... please comment: is unlamba the ultimate in setting up a problem so that it is composed from simple parts?
07:17:30 <shapr> oh, about a cgi cookie library as crutch.
07:17:46 <shapr> logpacker: hi
07:18:00 <shapr> metaperl: No, the ultimate is NAND / NOR.
07:18:23 <shapr> logpacker: learning Haskell?
07:18:54 <shapr> logpacker: are you a log bot?
07:19:37 <shapr> metaperl: Everything can be made from one of NAND or NOR.
07:19:47 <metaperl> oh
07:20:07 <shapr> http://en.wikipedia.org/wiki/Logical_nand
07:20:14 <xerox> nand = (.not).(&&)
07:20:15 <xerox> ^__^
07:21:58 <RemiTurk> not = flip
07:22:03 <RemiTurk> etc
07:22:08 <xerox> ?
07:22:18 <Igloo> xerox: Doesn't work for False True
07:22:29 <RemiTurk> true = \x y -> x
07:22:32 <metaperl> The Haskell Road To Logic, Maths And Programming has a very seductive intro and table of contents... I am starting to realize that I am going nowhere in Haskell unless I learn to think and know functions well... humbling after 5 years as a well-paid Perl programmer
07:22:33 <RemiTurk> false = \x y -> y
07:22:38 <RemiTurk> if = id
07:23:02 <RemiTurk> not = flip
07:23:03 <shapr> metaperl: I realize I'm not learning much if I don't get humbled on a regular basis.
07:23:07 <xerox> metaperl: I am reading it too!
07:23:20 <metaperl> xerox, do you like it?
07:23:52 <xerox> metaperl: I'm just at page 28, good so far.
07:24:14 <shapr> http://lambda-the-ultimate.org/ is one good place to find humbleness. I also like to put forth my ideas in my blog and here on #haskell and ask people to poke holes. That mostly works.
07:26:16 <xerox> metaperl: do you like it?
07:26:27 <metaperl> I'm thinking about buying it
07:27:05 <shapr> Isn't it free online?
07:27:08 <metaperl> I think you are just playing with air until you lock in a rigourous command of logic and functions. And this book doesnt play around... it takes you right to the foundation and builds you up from there
07:27:14 <metaperl> the first chapter and toc is
07:27:36 <metaperl> all the other books give you a chance to fool yourself about knowing haskell --- not this one
07:27:48 <metaperl> this book puts logic first and the language second
07:27:50 <xerox> shapr: no it isn't :\
07:28:07 <metaperl> all the others put the language first and hope you can build the logical reasoning... and it wont happen
07:28:45 <shapr> Strange, I wonder where I got my ps.gz copy.
07:28:59 <xerox> Its first example is a prime number test, it first prove to you some things -mathematecally- then implement it in Haskell, err, rewrites the proofs in Haskell :D
07:29:20 <xerox> shapr: hm, it could be really.
07:29:57 <xerox> http://homepages.cwi.nl/~jve/HR/
07:30:02 <xerox> There's a sample TOC.
07:31:37 <metaperl> here's the PDF for the TOC: http://www.hcoop.net/~terry/tmp/HR-27.pdf
07:31:44 <metaperl> shapr, you have  the whole book?
07:31:54 <shapr> yes, I do. Not sure how I got it though.
07:32:01 <metaperl> lol
07:32:04 <metaperl> that is funny
07:32:19 <metaperl> well, maybe he sent it in for review by THe Monad Review
07:32:42 <shapr> I think I downloaded from his website when he sent a mail to the list.
07:33:28 <metaperl> to what list? haskell-cafe?
07:33:37 <shapr> I don't know, checking now.
07:36:44 <shapr> Weird, I can't find it.
07:37:15 <_JusSx_> so post it
07:37:21 <shapr> I wouldn't do that.
07:37:30 <_JusSx_> ok send it to me
07:37:31 <shapr> If it's not available from the website, I'm sure I shouldn't post it.
07:37:35 <shapr> I won't do that either.
07:37:40 <_JusSx_> lol
07:37:42 <_JusSx_> thanx
07:38:26 <shapr> I will send him an email and ask him if I'm not supposed to have it. If I got it from a mistake on his part, I'll just delete the file and buy the book.
07:38:31 <_JusSx_> so how did you get it?
07:38:34 <shapr> I don't know!
07:38:45 <xerox> Poor shapr :(
07:38:47 <shapr> I know I downloaded it from his website.
07:39:00 <_JusSx_> ok
07:39:07 <_JusSx_> i give you my email
07:39:09 <_JusSx_> sent it
07:39:45 <shapr> hiya CosmicRay
07:39:51 <CosmicRay> morning shapr
07:39:52 <metaperl> hi CosmicRay
07:39:57 <CosmicRay> hi metaperl
07:40:06 <metaperl> well, my days of starting a web hosting cooperative have ended
07:40:14 <metaperl> I had a lifespan of 3 days :)
07:40:17 <CosmicRay> heh
07:40:29 <metaperl> day 1: Debian and Webmin and confusion
07:40:43 <metaperl> day 2: Fedora and DirectAdmin and feeling like I was inside a locked box
07:41:04 <metaperl> day 3: return to hcoop.net with profuse apologies and gratitude for all the system tools that Smerdyakov developed
07:41:25 <metaperl> I am a computer programmer but far from a sysadmin. I now know that for damned sure
07:41:29 <_JusSx_> Smerdyakof? ocaml?
07:41:39 <metaperl> SML
07:41:56 <_JusSx_> i found him in #ocaml channel
07:42:04 <CosmicRay> metaperl: heh
07:53:08 <xerox> How do you profile Haskell programs?
07:53:29 <shapr> -prof
07:53:50 <Igloo> -prof -auto-all  is the normal startpoint (assuming ghc)
07:54:22 <Igloo> The GHC manual is the best place to look for the options to then pass to the compiled program
07:55:15 <xerox> Oh. Can you remind me how to get command line arguments?
07:58:53 <bourbaki> moin
07:59:48 <wilx> Hmm, System.Environment iirc.
08:00:03 <wilx> @type System.Environment.getOpt
08:00:10 <lambdabot> bzzt
08:00:17 <wilx> @type System.Environment.getArgs
08:00:19 <lambdabot> System.Environment.getArgs :: IO [String]
08:00:22 <xerox> Hm, getArgs, yes
08:01:24 <Igloo> Ooo, nhc98 pointer hack seems to be breaking on x86 with gcc 3.4.3
08:02:47 <Heffalump> what's the pointer hack?
08:03:08 <Igloo> Using the MSB for a flag
08:03:32 <Heffalump> does it remove it before dereferencing the pointer?
08:03:42 <Igloo> Yes
08:03:57 <wilx> Huhu, sounds like some aliasing issues.
08:04:11 <Igloo> The problem comes when malloc gives you addresses > 0x80000000
08:04:19 <Igloo> Well, >=
08:04:41 <wilx> Ah.
08:04:55 <wilx> Fragile :)
08:05:13 * Heffalump found a good bug in gcc at work: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=20607
08:05:35 <Heffalump> it schedules the read from a stack slot before the write to the same stack slot if you confuse it enough
08:06:24 <wilx> Hmm, have you tested it against 4.0.0?
08:08:13 <xerox>  /usr/lib/ghc-6.4/libHSrts.a(Main.o)(.text+0x10): In function `main':
08:08:13 <xerox>  : undefined reference to `__stginit_ZCMain'
08:08:13 <xerox>  /usr/lib/ghc-6.4/libHSrts.a(Main.o)(.text+0x36): In function `main':
08:08:13 <xerox>  : undefined reference to `ZCMain_main_closure'
08:08:21 <xerox> What could it be the cause?
08:08:34 <Oejet> xerox: ghc --make?
08:09:05 <xerox> Oejet: no ghc -o foo foo.hs
08:09:29 <Oejet> xerox: Try --make then
08:09:54 <xerox> Oejet: it creates a .hi and a .o
08:10:34 <Igloo> Were there any .o or .hi files in that directory before you started?
08:10:43 <xerox> Igloo: no
08:12:20 <xerox> Same error when trying to link it.
08:12:31 <esap> xerox: Do you have a Main module that contains main function?
08:12:58 <xerox> esap: I put the main function in that foo.hs, do I need a main.hs ?
08:13:12 <esap> xerox: What is the name of the module?
08:13:22 <xerox> esap: The same as the file.
08:15:31 <esap> xerox: That's what's causing the problem. You need a module called 'Main'.
08:16:06 <esap> xerox: The file name doesn't matter, but the module name must be 'Main'.
08:16:42 <esap> xerox: For the module that will be used for the main function.
08:17:03 <xerox> Yep, it works.
08:17:05 <xerox> Thank you very very much.
08:17:09 <basti_> venus is the name of the song with that line
08:18:05 <basti_> wb M.D.
08:19:49 <Muad_Dibber> thx
08:26:58 <xerox> Do you know why I get "Failed to load interface for `Prelude':" when doing ghc -prof Main.hs Foo.hs ?
08:27:41 <Igloo> You probably need a ghc6-prof package or similar
08:28:29 <xerox> haskell-unsafe.alioth.debian.org has it. Great.
08:29:08 <xerox> Big package btw :)
08:32:12 <xerox> a.out.prof should contain the profiling?
08:32:22 <_JusSx_> yeah
08:32:24 <_JusSx_> open it
08:32:58 <xerox> It's zero-length
08:33:41 <basti_> did you run the executable with those weird options?
08:34:31 <xerox> basti_: which executable, a.out?
08:35:08 <xerox> Hm, it creates the .prof when I run it, can you suggest me `those weird options' ?
08:35:34 <TheHunter> xerox, compile with -prof -auto-all, then ./a.out +RTS -p
08:35:42 <basti_> xerox: see TheHunter.
08:35:43 <basti_> =)
08:36:09 <xerox> Oh great.
08:36:44 <xerox> -RTS my arguments, perfect.
08:37:28 <xerox> whoops :D
08:37:32 <basti_> wb.
08:37:46 <xerox> Pressed the wrong key in the wrong window ;)
08:38:22 <basti_> -g-
08:38:49 <xerox> 69 secs lag, oh yeah.
08:39:04 <basti_> o0
08:39:09 <basti_> to where?
08:39:21 <xerox> -!- Join to #haskell was synced in 69 secs <- it says
08:39:36 <basti_> oh thats not your lag
08:39:45 <xerox> pheewww.. ?
08:39:47 <xerox> :)
08:39:58 <basti_> thats some internal stuff
08:40:25 <basti_> the tables that store who's in what chan need to be synchronized or something
08:40:31 <basti_> dont ask why they're not
08:40:34 <basti_> IRC is a crock
08:40:34 <basti_> ;)
08:40:43 <xerox> Oh yes :)
08:42:01 <xerox> All this to profile factorizing a big random number, yay.
08:42:55 <basti_> oh the joys
08:43:16 <xerox> Thermal 1: ok, 56.0 degrees C
08:43:33 <xerox> Let's melt this laptop..
08:43:57 <basti_> did i mention i wrote a cute permutation routine?
08:44:14 <xerox> Dunno really, how does it look like?
08:44:24 <xerox> what, even (?)
08:44:44 <basti_> hm?
08:44:55 <xerox> Are you going to show it? :D
08:45:10 <basti_> yes i'm putting it up
08:45:46 <basti_> http://www.students.uni-marburg.de/~Zapf/perm.lhs
08:46:53 <basti_> aw i think thats an older version
08:47:43 <xerox> print = putStrLn.show  --right?
08:47:59 <basti_> maybe?
08:48:13 <basti_> :)
08:48:51 <xerox> It would be nick to have a link to the implementation, in the GHC docs, other than the type declaration.
08:49:07 <basti_> hm
08:49:50 <basti_> newer version now
08:51:37 <xerox> print           :: Show a => a -> IO ()
08:51:37 <xerox> print x         =  putStrLn (show x)
08:51:39 <xerox> oh yes.
08:51:44 <basti_> :)
08:51:56 <basti_> someone should go and write it in lambdabot.
08:52:03 * xerox whistles
08:52:41 <basti_> hm?
08:53:15 <xerox> Usually when someone ask for features, he get the shapr's default answer "do it!" ^__^
08:53:24 <basti_> -g-
08:53:45 <xerox> (It's still factorizing)
08:53:55 <basti_> what does the temperature say?
08:54:03 <xerox> Ouch, I must check.
08:54:15 <xerox> 55.0 degrees C
08:54:20 <basti_> hehe
08:54:20 <xerox> (I opened the window, tought ;))
08:54:29 <xerox> brr.
08:54:48 <xerox> It didn't take this long time without profiling enabled..
08:55:07 <xerox> It does so much overhead?
08:55:07 <basti_> what did you expect? ;)
08:55:27 <basti_> it depends i think.
08:55:48 <xerox> It's only 49838843073407303407.. it would be *really* funny if it was a prime number, I typed it "randomly".
08:56:08 <basti_> aw i wouldnt worry. prime numbers are pretty rare up there.
08:56:16 <xerox> yay.
08:56:57 <xerox> 13259 paolo     25   0  4564 2108  992 R 86.4  0.4  18:45.39 a.out
08:56:58 <basti_> go go go go go go go.
08:57:00 <xerox> O_o
08:57:08 <basti_> 18 minutes?
08:57:15 <xerox> It seems so.
08:58:18 <xerox> I'm not going to break RSA this way..
09:00:25 <cm> :d
09:01:05 <xerox> 22:34.54 a.out
09:08:04 <logpacker> is haskell better than lisp?
09:08:49 <ibid> that's like asking whether apples are betteer than oranges ;)
09:09:57 <cm> i prefer apples
09:10:02 <cm> (for the record)
09:10:09 <cm> orange screw up my skin
09:10:14 <cm> neurodermitis etc
09:10:59 <RemiTurk> logpacker: that depends on what language you're planning to write in
09:13:16 <ibid> yeah, oranges are hard to peel
09:17:37 <vegai> depends a lot on the quality of the orange
09:17:58 <cm> ..there are common oranges, and orangeme
09:18:35 <basti_> re
09:41:01 <xerox> [[107,465783580125301901]]
09:41:03 <xerox> Whoa.
09:41:38 <basti_> hm?
09:41:40 <basti_> 107?!
09:44:06 <xerox> http://segfaulted.com/~xerox/a.out.prof
09:45:19 <basti_> 107% mem? ;)
09:45:35 <xerox> 107 * 46578350125301901=4983883463407303407
09:45:43 <basti_> ah
09:46:00 <xerox> I got a very big prime, btw :D
09:46:11 <cm> lol
09:46:15 <basti_> hehe
09:49:51 * TheHunter starts profiling QuickCheck
09:50:20 <TheHunter> the 33% performance increase after a trivial change to fmap made me confident.
09:50:31 <basti_> -g-
09:52:21 <TheHunter> ok, so choose, variant vector and forAll are the main cost centers.
09:52:24 <xerox> To fmap, from .. ?
09:53:37 <TheHunter> from "fmap f m = m >>= return . f" to "fmap f (Gen m) = Gen (\n r -> f (m n r))"
09:54:13 <xerox> Ok, dunno really :)
09:54:27 <xerox> ..at least the second part
10:03:28 <Lemmih> SyntaxNinja: Yo.
10:05:42 <SyntaxNinja> y0
10:07:26 <xerox> yo.
10:09:41 * Lemmih wonders why setting up a MTA to deliver mail to a smtp server is so much harder than in a mail-client.
10:11:02 <stepcutHM> my mta has to autodetect if I am at home or work and using different smart hosts
10:17:57 <SyntaxNinja> Lemmih: so no luck?
10:18:50 <dustin`> Can anyone recommend good haskell literature on the type system for someone with moderate familiarity with category theory?
10:19:45 <SyntaxNinja> Lemmih: got a minute?
10:20:02 <Lemmih> Sure.
10:20:18 <SyntaxNinja> Lemmih: so you have an account on the machine where hackage is hosted, right?
10:20:26 <SyntaxNinja> you don't need to configure your MTA, you can use push instead of send.
10:22:00 <Lemmih> Oh yeah (:
10:23:18 <Lemmih> "Pushing to ssh URLs is not supported."
10:29:18 <Lemmih> Ah. Wrong syntax.
10:30:33 <Lemmih> Bah. Permission denied.
10:30:43 * Lemmih goes to bug shapr.
10:35:48 <Si\> I'm trying to convert arbitrary parameter functions of the form a -> b -> ... -> z to functions of the form (a :*: b :*: c ....) -> z, can anyone think of a way of doing this using type-classes and fun-deps?
10:38:25 <bringert> Si\: kind of
10:38:47 <bringert> you may get some inspiration from the tricks XmlRpc uses
10:39:08 <bringert> http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/
10:40:11 <bringert> look for example at the Remote class in src/Network/XmlRpc/Client.hs
10:43:28 <Lemmih> bringert: You're the author of Haskell-xml-rpc?
10:44:35 <bringert> Lemmih: yes
10:45:34 <Si\> hmmm I've got the class to work, but can't get the fundeps to work
10:46:18 <Lemmih> I've cabalized it and made some other trivial changes to make it work with GHC 6.4
10:46:49 <Si\> HTTP needs a few changes too I believe
10:48:09 <xerox> basti_: I got a better prime test, let's see if my big random prime takes again that long to factorize :D
10:49:06 <astrolabe> How are you doing the factorisation xerox?
10:49:38 * Lemmih isn't using the HTTP module so he isn't the one who's gonna be hacking it (:
10:49:59 <xerox> Hm, dinner, I'll shoow you later.
10:51:12 <Lemmih> bringert: It would be neat if you could host the cabalized version since Hackage depends on it.
10:58:00 <Lemmih> SyntaxNinja: Yihaa. Hackage is now available from scannedinavian.org/~lemmih/hackage
11:07:52 <bringert> Lemmih: I thought I had cabalized it already, though that was a while ago, guess cabal changed
11:08:00 <CosmicRay> Lemmih: is this source or demo site?
11:08:06 <bringert> Lemmih: can you send me a patch?
11:08:14 <bringert> I should put it i darcs somewhere
11:08:47 <Lemmih> CosmicRay: Source. The demo is elsewhere on the server.
11:08:52 <bringert> Si\: what changes are needed for HTTP?
11:09:00 <Lemmih> bringert: I can mail the tarball to you.
11:09:35 <bringert> Lemmih: ok
11:09:55 <CosmicRay> Lemmih: the demo croaked on my file for MissingH.  Appears to not like ghc-options.
11:10:03 <Si\> basically it's the new URI stuff
11:10:24 <Lemmih> CosmicRay: It's some months old and using the cabal code from that time.
11:10:29 <CosmicRay> ah
11:10:37 <Lemmih> I'll get shapr to rebuild it (:
11:11:36 <Si\> regarding my original question, a simpler thing to say first is, is it possible to be able to create a type-class which takes a function, and uses functional dependencies to establish its final non-function output type?
11:12:03 <Si\> e.g. outType ((+) :: Int -> Int -> Int) :: Int
11:15:54 <SyntaxNinja> hey CosmicRay
11:16:08 <bringert> Si\: probably :-)
11:16:21 <SyntaxNinja> Lemmih: cool. I'll try that out tonight. is that available on the web?
11:17:14 <TheHunter> Si\, i think it's only possilbe if you know all the ground types your type is built up from.
11:17:33 <Si\> I do now what all the ground-types are
11:17:38 <bringert> Si\: oh, right, I guess I'll get Graham Klyne's HTTP verion
11:19:12 <Si\> the point is I have a function, which is monomorphically typed and a string containing a sequence of serialized values, and I want to use the type of the function to deserialize the string, and then apply the values to the function and deserialize back the output
11:20:14 <bringert> sound pretty much like what XmlRpc does
11:20:27 <Lemmih> SyntaxNinja: Is what available on the web?
11:20:57 <bringert> the trick I use to make it simple is to have the return type be IO something, that way the instances are fairly straightforward
11:21:32 <TheHunter> class Foo a b | a -> b where
11:21:32 <TheHunter>   outType :: a -> b
11:21:32 <TheHunter> instance Foo a c => Foo (b -> a) c
11:21:32 <TheHunter> instance Foo Int Int
11:21:32 <TheHunter> *Main> :t outType ((+) :: Int -> Int -> Int)
11:21:33 <TheHunter> outType ((+) :: Int -> Int -> Int) :: Int
11:22:33 <Si\> that would be ok, but it means you have to create instances for every single type
11:24:13 <Si\> it won't accept instance Foo a a
11:24:36 <TheHunter> yes, you said you wanted a functional dependency.
11:25:30 <bringert> Si\: Foo a a would mean that Int -> Int has return type Int -> Int
11:25:33 <SyntaxNinja> Lemmih: the darcs repo
11:25:40 <SyntaxNinja> the latest darcs repo
11:26:12 <Lemmih> SyntaxNinja: scannedinavian.org/~lemmih/hackage
11:26:34 <Lemmih> That is the updated darcs repo.
11:26:54 <Si\> bringert: Yes, because the outtype of Int is Int
11:26:56 <esap> Hmm.. for a type class for a type variable of kind * -> *, is there a good way to represent run-time information about the choice of the type satisfying that type class? Requirement is that you can pass it around as data, and then use it later to choose one of the instances to use.
11:28:01 <SyntaxNinja> Lemmih: OK cool.
11:28:37 <Si\> TheHunter: what I want is a type-level tail recursive function which can, for any conceivable function define the final non-function output type
11:32:06 <wilx> Huh.
11:32:13 <wilx> Magic :)
11:32:23 <TheHunter> Si\, i don't think it's possible without explicitely specifying all possible ground types.
11:32:40 <Si\> that's a shame
11:37:50 <Si\> it's probably best that I create instances for each number of parameters
11:42:14 <wilx> Some kind of template magic wouldn't help?
11:43:50 <Si\> dang I can't even do that
11:46:27 <Si\> class LamToSeq a b | a -> b
11:46:28 <Si\> instance LamToSeq (a -> z) ((a :*: HNil) -> z)
11:46:28 <Si\> instance LamToSeq (a -> b -> z) ((a :*: b :*: HNil) -> z)
11:46:38 <Si\> why do those instances clash?
11:47:11 <TheHunter> the first z could be b -> z
11:47:27 <Si\> of course it could
11:47:32 <Si\> how frustrating
11:52:43 <wilx> Hm. Can't you just enable overlapping instances?
11:53:05 <wilx> It should pick the more specific ones, shouldn't it?
12:03:38 * TheHunter just used unsafeCoerce# to get around the limitation that cunning newtype deriving doesn't work for recursive types.
12:04:09 <Si\> yes, but I want it to infer the type, since it should be able to work it out from the function type
12:16:33 <babemagnet> is there something beyond a spreadsheet available in heaskell
12:16:40 <babemagnet> some kind of really kick butt app
12:16:49 <babemagnet> like an evoleved spreadsheet?
12:17:23 <babemagnet> is there an MTA written in haskell?
12:17:32 <babemagnet> how about a DNS implementation?
12:17:38 <babemagnet> secuity firewall?
12:17:50 <Lemmih> Hey shapr.
12:17:57 <shapr> esap: hey, this is a really article.
12:18:02 <shapr> um "really cool"
12:18:03 <xerox> hiya shapr!
12:18:04 <Lemmih> babemagnet: GHC is written in Haskell.
12:18:25 <shapr> greetz
12:18:40 <boegel> hey shapr
12:19:06 <shapr> babemagnet: if you're a babemagnet, is it the kind that attracts babes? or the kind that repulses babes?
12:19:25 <shapr> I always thought I was the second type of babemagnet.
12:19:48 <Lemmih> babemagnet: And I think I've heard of an MTA and DNS resolver written in Haskell.
12:20:01 <shapr> Yes, both from peti
12:20:16 <shapr> hiya tmoertel, wassup?
12:20:37 <tmoertel> shapr: howdy! I'm having a little fun w/ Ruby.
12:20:47 <shapr> babemagnet: You can find both MTA and DNS code for Haskell here - http://cryp.to/
12:20:49 <shapr> neat
12:21:13 * shapr hops cheerfully
12:22:14 <tmoertel> shapr: ruby has some cool control flow constructs
12:22:25 <tmoertel> shapr: I had to model them in Haskell to get a better grip on them
12:22:26 <shapr> like what?
12:22:30 <tmoertel> shapr: http://community.moertel.com/ss/space/start/2005-03-25/1#Writing_a_simple_Ruby_evaluator
12:23:11 <shapr> conal: greetings!
12:23:33 <tmoertel> shapr: when a function is called, it can be passed a "block", which is essentially another function that works coroutinishly with the original function
12:23:51 <shapr> oh yeah, I've read about that.
12:24:49 <shapr> esap: Your article on duality will fit together perfectly with Alistair Bayley's article on the nature of FP and how it compares to the nature of OOP.
12:24:59 <shapr> conal: Are you still on sabbatical?
12:28:02 <shapr> tmoertel: that's quite spiffy!
12:28:07 <shapr> I gotta try that.
12:28:55 <shapr> tmoertel: do you have the .hs file available? pasting from galeon loses \n
12:29:00 <shapr> ramza2: greetings, learning Haskell?
12:29:10 <tmoertel> shapr: hold on, let me put the file up
12:29:14 * boegel is off to read The Da Vinci Code
12:29:15 <boegel> bye !
12:29:20 <xerox> Bye boegel
12:29:27 <shapr> boegel: come back soooon
12:29:29 <ramza2> shapr: not really, trying to revive 'jython' again, we might need your help
12:29:35 <shapr> oh, ok.
12:30:03 <basti_> jython?
12:30:14 <shapr> JavaPython
12:30:16 <tmoertel> shapr: It's here: http://community.moertel.com/~thor/MiniRuby.hs
12:30:46 * basti_ shudders
12:31:05 <shapr> basti_: if forced to write Java, Jython is a good salve.
12:31:21 <basti_> mmh right.
12:46:39 <defcon8> what is haskell?
12:46:42 <defcon8> a db?
12:47:00 <shapr> It's a programming language.
12:47:10 <shapr> Want to see the short demo?
12:47:43 <defcon8> could you show a helloworld?
12:47:49 <shapr> @wiki HaskellDemo
12:47:50 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:48:05 <defcon8> cheers
12:48:09 <defcon8> i have never heard of haskell :|
12:48:24 <Oejet> defcon8: main = print "Hello World!"
12:48:25 <shapr> S'okay, there's lots of stuff people haven't heard of.
12:48:43 <defcon8> oh so it is OOP
12:48:52 <shapr> No, it's not OOP, it's functional programming.
12:49:13 <defcon8> oh ok
12:50:24 <Oejet> defcon8: What languages do you know already?
12:50:39 <defcon8> a bit of C
12:52:15 <shapr> Haskell works more like math equations.
12:52:40 <shapr> The result of a function can only depend on the arguments to the function.
12:53:51 <shapr> defcon8: what do you think about the HaskellDemo?
12:54:17 <defcon8> i have looked sorry
12:54:21 <defcon8> ill look now
12:56:23 <shapr> defcon8: Haskell is a very different approach to programming compared to C. I think both are worth learning.
12:56:48 <defcon8> hmm
12:57:01 <defcon8> i dont really want to learn a lang that i wont use and will not be of use to me
12:57:09 <defcon8> though i really encourage the making of new langs
12:57:19 <shapr> I use Haskell. I get paid to use Haskell too.
12:57:36 <shapr> Haskell will be of use to you if you want to be a great programmer.
12:57:36 <defcon8> damn that looks really strange
12:57:39 <defcon8> it costs
12:57:43 <_JusSx_> what?
12:57:54 <shapr> What costs?
12:57:58 <_JusSx_> no one here encouraged me to learn haskell
12:58:05 <SyntaxNinja> _JusSx_: learn haskell.
12:58:09 <shapr> _JusSx_: did you need some encouragement?
12:58:14 <defcon8> you mean you donated?
12:58:14 <Khisanth> defcon8: it is good to learn different ways of solving problems :)
12:58:16 <_JusSx_> defcon8 comes here and you encouraged him
12:58:20 <shapr> _JusSx_: did you want some? :-)
12:58:29 <_JusSx_> defcon8: learn C well
12:58:30 <defcon8> well im planning to learn C# atm
12:58:31 <_JusSx_> first
12:58:34 <defcon8> i learnt C man
12:58:40 <_JusSx_> then you have time to learn what you wnat
12:58:43 <_JusSx_> then you have time to learn what you want
12:58:47 <SyntaxNinja> if you already know C, then you should learn Haskell next :)
12:58:49 <SyntaxNinja> and so should _JusSx_
12:59:02 <shapr> _JusSx_: learn Haskell! It's GREAT!
12:59:08 <_JusSx_> i know C, C++, Pascal, Java, Cobol, Ocaml
12:59:21 <_JusSx_> and Ada
12:59:23 <_JusSx_> sorry
12:59:26 <SyntaxNinja> _JusSx_: you'll have no trouble learning haskell
12:59:31 <_JusSx_> so it's time for Haskell
12:59:48 <_JusSx_> functional languages are my love
12:59:49 <_JusSx_> now
12:59:54 <sylvan> Actually you should learn Haskell before C. C is a very unintuitive way to program and makes you learn stuff which are pretty weird and far from natural human thought (like "x = x+1")
13:00:07 <shapr> I know C, Python, Java, Visual Basic, elisp, JavaScript, SQL, ... hm, lots.
13:00:19 <_JusSx_> ah sorry even SQL i kwno
13:00:22 <sylvan> Comparing languages is stupid! :-)
13:00:28 <_JusSx_> if you call it program language
13:00:48 <shapr> managers call SQL a programming languae.
13:00:54 <_JusSx_> humm
13:01:02 <SyntaxNinja> sql is a language, and is interesting in its own right.
13:01:04 <_JusSx_> i'm a manager
13:01:08 <_JusSx_> and i don't call it
13:01:10 <SyntaxNinja> which isn't to say that I like to program in it
13:01:45 <psi> sylvan: what's weird about that?
13:01:51 <sylvan> psi = harry
13:01:53 <shapr> defcon8: Anyway, Haskell is worth learning. If you choose to learn it, we'll get you introduced to the language.
13:01:56 <sylvan> isn't that weird?
13:02:15 <sylvan> when have you ever just changed the name of something? chair = table
13:02:17 <sylvan> strange
13:02:18 <defcon8> hmm i dunno :|
13:02:27 <sylvan> have you ever updated the value of a variable in maths?
13:02:31 <defcon8> i need to go to bed now its 12:00 and i have school tomorrow
13:02:32 <psi> sylvan: ok, i see your point
13:02:51 <shapr> g'night defcon8
13:02:54 <sylvan> good =)
13:02:55 <defcon8> byer
13:02:57 <defcon8> thanks for the help
13:03:00 <shapr> sure
13:03:04 <defcon8> im leaving the xchat open as i am dling
13:03:31 <shapr> psi: in Prolog, you can give any two of x = y + z and get the third in return.
13:03:46 <basti_> no you cant can you?
13:03:53 <_JusSx_> mahh
13:04:03 <shapr> I thought you could...
13:04:05 <psi> shapr: cool
13:04:40 <shapr> procedural is about step by step directions, functional is about simplification like an equation, logical is about relationships.
13:04:52 <shapr> This is the way I understand it at least. I would be happy for more/other enlightenment.
13:05:05 <Khisanth> OOP is about naming headaches? :)
13:05:15 <basti_> logical is unification & backtracking.
13:05:24 <shapr> basti_: tell me more!
13:05:45 <basti_> well basically, logical programming has only functions that are "true" or "false"
13:06:10 <basti_> the interpreter will try to find a "true" value for every query you give
13:06:35 <basti_> and "true" are tuples that are in your database, or ones that satisfy a function
13:07:18 <basti_> this is solved by unification and in many cases via backtracking
13:08:53 <basti_> basically your program is a list of horn clauses
13:09:30 <psi> sylvan: i think the ability to update a variable makes it harder to verify correctness. just a few minutes ago, i was trying to verify an algorithm i made, and i tried to hold the variables in my head like, "here x is 5, and then y becomes 7, and then we increment x, etc". it was a bit of a pain.
13:09:41 <conal> shapr: hi
13:09:45 <psi> i get the feeling it is easier to verify corrected of haskell  programs
13:09:50 <conal> this is my first time on an irc
13:09:52 <psi> correctness*
13:09:55 <basti_> which are formulae like "forall x,y,z: (term)/\(term)/\ ... -> (term)
13:10:13 <conal> shapr: yes, i'm still on sabbatical
13:10:18 <SyntaxNinja> hi conal. welcome to #haskell
13:10:30 <conal> thanks :)
13:10:30 <babemagnet> hi
13:10:39 <basti_> and which serve a purpose similar to lambda expressions... the way they do it is unique though...
13:10:50 <basti_> thats why prolog programs work backwards
13:11:04 <basti_> (they don't!)
13:12:23 <sylvan> psi: I think you're right
13:13:00 <sylvan> and also, it's just "weird" to solve stuff by updating the contents of memory cells, humans don't think that way - unless they've learnt it from programming C
13:14:03 * Khisanth didn't think people actually thought of variables in terms of memory locations
13:14:29 <sylvan> Khisanth: well they normally don't, but they have to in C
13:15:06 <Khisanth> you mean for memory management purposes or just in general?
13:15:10 <sylvan> again, "x = x + 1", doesn't really make sense unless you realise that it's not actually the name of a value, it's the name of a memory cell which holds a value (and that values is implicitly read and written)
13:15:15 <sylvan> in general
13:15:33 <Cale> x = x + 1 doesn't make sense, but x <- x + 1 does.
13:16:02 <sylvan> is that even legal?
13:16:07 <ibid> variables designate memory locations in all imperative languages
13:16:07 <Cale> In the sense that = denotes equality and <- denotes assignment.
13:16:25 <sylvan> y <- x + 1, makes sense
13:16:32 <sylvan> or even y = x + 1
13:16:47 <Cale> x <- x + 1 is fine
13:16:52 <sylvan> x <- x + 1 is just messy, if it's even legal... the leftmost x isn't the same x as the right one
13:17:20 <Cale> Well, it is if <- means assignment. I didn't intend do notation :)
13:17:31 <sylvan> ah
13:18:05 <sylvan> still, when humans solve problems they generally don't think about "modifying state" in a given sequence...
13:18:12 <sylvan> rather they evaluate expressions..
13:18:13 <Cale> That's very true
13:18:39 <Khisanth> depends on the human :)
13:18:45 <Cale> You don't assign your dishes numbers and increment a loop counter variable as you wash them.
13:18:49 <sylvan> yeah.. if you program C for a while you start thinking like that...
13:19:05 <cpage> In Dylan, I tend to write "let x = x + 1", which introduces a new variable, also named "x", and hides the outer "x" until the end of the current scope. It's basically a shorthand for coming up with lots of other names for each intermediate value (instead of, say, "x1 = x + 1", "x2 = ...").
13:19:19 <sylvan> If the language you use doesn't have a significantly small semantic gap to your "thinking language", then you'll lower the level of your thinking language after a while =)
13:19:57 <sylvan> which is why learning Haskell is beneficial to the quality of your C-programs
13:20:19 <Muad_Dibber> while infact there should be designed a new, higher level language on top of the original language :P
13:20:38 <cpage> I concur. The same can be said about several other languages, btw. Learning at least some of a couple of other languages will make you a better C programmer.
13:21:20 <shapr> conal: hiya
13:21:23 * shapr boings
13:21:24 <sylvan> Yeah, you need to mix it up with new langauges every now and then to avoid limiting your ability to solve problems to what's natural in your "favourite" language
13:21:38 * SyntaxNinja boings
13:22:00 <bercmarihe> boing
13:22:11 <sylvan> example: I hardly did any recursion in C before I learned Haskell, even though I knew about it and understood it - it just wasn't the natural way in C and because of that an important problem solving technique wasn't used
13:22:29 <shapr> conal: what do you do on a sabbatical?
13:22:32 <Khisanth> cpage: should that be a better programmer in general as oppose to just C?
13:22:34 * sylvan feels like he's preaching to the converted :-)
13:22:45 <cpage> Khisanth: Yes.
13:22:56 <norpan> haskell + c is a very good combo
13:23:04 <shapr> conal: hi, I'm Shae Erisson 'in real life'
13:23:25 * basti_ thinks there is some lag going on
13:23:26 <SyntaxNinja> sylvan: I was starting to wonder who you were talking to ;)
13:23:33 <cpage> But if you've only learned C, then you *really* need to learn at least one other language.
13:23:36 <sylvan> indeed... Haskell for the high level stuff, and C in the low level time-critical bits (much like C/ASM used to be used)
13:23:43 <Khisanth> sylvan: you are :)
13:23:48 <sylvan> hehe
13:24:01 * SyntaxNinja blinks at shapr
13:24:02 <cpage> Some other languages would probably be "okay" if you only knew one language.
13:24:03 <SyntaxNinja> real life?
13:24:14 <sylvan> I'm a chatty bitch today
13:24:15 <cpage> ...if you only knew that one language.
13:24:28 <shapr> SyntaxNinja: like, in meatspace as opposed to cyberspace. In Cyberspace my name is shapr!
13:24:54 <cpage> I prefer, however, a high-level language that can compile to efficient code so that the use of a lower-level language for efficiency is a rarity.
13:25:17 <bringert> Si\: darcs version of HTTP now should support ghc 6.4
13:25:29 <shapr> I prefer code I can read, understand, and change easily.
13:25:30 <basti_> oh sometimes the more elaborate code is more efficient
13:25:50 <basti_> maybe because you looked at the problem in another way
13:26:05 <basti_> and did not have to bother with counting indexes.
13:26:10 <cpage> Higher-level semantics can be more efficient, because compilers have more information available about the program behavior.
13:26:13 <shapr> SyntaxNinja: do you have a real life also?
13:26:21 <sylvan> LIES!
13:26:33 <basti_> ? ;)
13:26:47 <SyntaxNinja> I think sylvan was just tired of everyone agreeing
13:26:51 <SyntaxNinja> shapr: I suppose
13:26:54 <shapr> conal: So, I guess I don't need to offer you the Haskell tutorial?
13:28:13 <sylvan> shapr: http://conal.net/  I think he knows Haskell a bit... =)
13:28:20 <shapr> sylvan: yes, I know ;-)
13:29:00 <sylvan> okay =)
13:29:18 <shapr> conal: How do you think PanTHeon compares to Pan?
13:53:08 <tic> hey sylvan
13:56:50 <sond> tic, pluggat nn mer matstat?
13:57:45 <sylvan> hey
14:07:37 <jlouis> C is rather constraining as a language for most problems you will face
14:08:23 <astrolabe> jlouis:  How so?
14:14:54 <jlouis> astrolabe: Lack of abstraction primitives hurts. OTOH you have a plethora of libraries of varying quality at your disposal
14:18:46 <astrolabe> As a beginning functional programmer, I find haskell code too distant from the algorithm itself, but very elegant.
14:19:08 <Cale> It's not distant, it's very close :)
14:19:14 <SyntaxNinja> strange; I find it very close tot he algorithm
14:19:18 <Heffalump> it's close to the specification
14:19:20 <Darius> astrolabe: More distant then imperative code?  And further are you sure you are not just looking at imperative renditions of the algorithm?
14:19:20 <shapr> Can you show a specific example?
14:19:33 <Heffalump> if the algorithm is a clever implementation, the natural functional program will be far from the algorithm
14:19:56 <astrolabe> LOL that woke you all up huh :)
14:19:57 <Cale> Heffalump: well, sometimes
14:20:03 <Oejet> Well, if you have a traditional algorithms book with imperative pseudo code, then it can be quite difficult to realise e.g. a queue in Haskell.
14:21:02 <Oejet> From that pseudo code.
14:22:16 <SyntaxNinja> true
14:22:32 <astrolabe> As a simple example  f (a:as) = (g a) : (f as)    (ie map)
14:23:29 <astrolabe> To me, the natural algorithm describes how I would evaluate the function with pencil and paper
14:24:15 <Cale> "To wash the dishes, wash a dish, then wash the rest"
14:24:36 <astrolabe> With pencil and paper, I would not have intermediate lists.
14:24:41 <Cale> but of course, there's a nice abstraction there
14:24:51 <SyntaxNinja> Cale: nono! first, count how many dishes you have...
14:25:29 <Cale> map f (x:xs) = (f x) : (map f xs) -- now you don't need to look at the elements at all anymore
14:25:57 <jlouis> first, count how many dishes you have, then label them from 0 to n-1. Then write 0 on your paper. Take up dish 0, wash it, put it down, scratch out zero and write 1.
14:26:08 <jlouis> etc
14:26:50 <SyntaxNinja> jlouis: feels very natural to me! my dishes even come with a convinient marker so I can write directly on them, and the washing process removes the mark!
14:27:06 <SyntaxNinja> very advanced you see
14:27:10 <jlouis> ah, cool
14:28:27 <Cale> astrolabe: also, what intermediate lists?
14:28:35 * Darius wonders if the picture in the Shift To Control slides is from "Lauf Lola, Lauf!"
14:29:42 <astrolabe> I'm not sure I'm convincing myself.  My main problem, is I'm not sure how the computer will actually evaluate Haskell code.
14:30:34 <Darius> astrolabe: Substitute formals for actuals.
14:30:38 <Darius> That is all.
14:30:40 <astrolabe> Cale: The lists I meant are the as  and the f as
14:31:44 <astrolabe> Darius: please would expand a little.
14:32:29 <Cale> astrolabe: In practice, the only actual lists here are (a:as) and f (a:as), every other list is just part of one of those
14:33:01 <Cale> (in fact, a tail of one of those)
14:33:07 <jlouis> astrolabe: you program is one big function. By substitution.
14:33:31 <Cale> let's expand  map (+1) [1,2,3]
14:34:12 <Cale> map f (x:xs) = (f x) : (map f xs), so we substitute:
14:34:45 <Cale> map (+1) (1 : [2,3]) = ((+1) 1) : (map (+1) [2,3])
14:35:26 <Cale> = ((+1) 1) : ((+1) 2) : (map (+1) [3])
14:35:43 <Cale> = ((+1) 1) : ((+1) 2) : ((+1) 3) : (map (+1) [])
14:35:48 <Cale> and map f [] = []
14:35:48 <Darius> When you see int fac(int n) { if(n<2) return 1; else return fac(n-1); } and then see fac(4) you think (probably 4! but if you didn't grok fac in fullness) if(4==0) return 1; else return fac(4-1);
14:35:52 <Cale> so you get
14:35:59 <Cale> = ((+1) 1) : ((+1) 2) : ((+1) 3) : []
14:36:30 <Cale> = 2 : 3 : 4 : []
14:36:44 <Darius> While that's bending the truth a bit in general in C, that's all there is to it in Haskell.
14:37:28 <Darius> astrolabe: This is -exactly- how you work with functions in middle school algebra.
14:37:39 <Cale> but of course, what really happens when you write map (+1) [1,2,3] is not much. It's only when you actually look at the elements that f will be applied.
14:38:19 <Cale> Evaluation is based entirely on demand.
14:40:12 <Cale> If you can use the definitions (and just the definitions) to figure out the head of a list, then Haskell will be able to as well.
14:40:14 <astrolabe> Thanks Cale, but I still don't really see what a haskell interperater would do when confronted with that definition.
14:40:42 <Cale> well, it wouldn't do much until you looked at the list.
14:41:00 <Darius> astrolabe: The only remaining pernicky thing is in algebra class, you probably evaluated f(x) = x+3, f(4+5) as f(4+5)->f(9)->9+3->12 while in Haskell you (conceptually) always do it as f(4+5)->(4+5)+3->12
14:41:04 <Cale> it might set up some code in anticipation, but it wouldn't evaluate
14:41:51 <Darius> astrolabe: When a function is applied in Haskell, it (conceptually) does exactly what you'd do when you see f(5) in algebra class.
14:44:01 <astrolabe> What does conceptually mean here?  I think that for many programming problems, one needs to know roughly what kind of thing the CPU will be doing.  For many others, it doesn't matter, as long as you get the right answer out.
14:44:09 <Cale> consider this definition:  nats = 0 : map (+1) nats
14:44:19 <Cale> what is the head of this list?
14:44:30 <Cale> (that's pretty easy, right?)
14:44:42 <Cale> how about the head of the tail?
14:44:45 <astrolabe> :)  Not too hard Cale
14:45:57 <Darius> astrolabe: "Conceptually" means that that's the semantics (what the program means) but not likely how it's implemented (though is a possible implementation).  Technically, I believe, making any more assumptions would go beyond what the Report specifies.
14:46:08 <Cale> how would you compute the head of the tail of that list?
14:46:54 <Cale> that requires applying map, but only enough to get the first element of the result.
14:47:25 <astrolabe> Cale, The tail is defined by the bit after the colon on the rhs
14:47:35 <Cale> right
14:47:43 <Cale> so the tail is map (+1) nats
14:47:52 <Cale> and what is the head of that?
14:48:05 <Cale> well, we know what nats is,
14:48:14 <Darius> astrolabe: Beyond what I said about f(4+5) reducing to (4+5)+3 instead of to f(9), the only thing to think about is sharing, i.e. f(x)=x+x, f(4+5) reduces to (4+5)+(4+5) but the two (4+5)s are shared so when one is evaluated both will get the result.
14:48:20 <Cale> so we can do a little replacement
14:48:37 <Cale> map (+1) (0 : map (+1) nats)
14:48:41 <Cale> is the tail of nats
14:49:14 <Cale> but we in fact won't ever need to evaluate the inner map
14:49:22 <astrolabe> Darius, so does Haskell have a hash table behind the scenes to check if has already calculated a result?
14:50:25 <Darius> astrolabe: Not in any current implementations, but how sharing behavior is achieved is an irrelevant implementation detail.
14:51:13 <astrolabe> But Darius, irrelevant to what?
14:51:22 <Cale> astrolabe: basically, the evaluation does what you would do if you were expanding out the definitions to get at a value
14:52:39 <astrolabe> It doesn't at all Cale.  I'd look at the definition of nats, and work out what it meant on some deeper level, and I'd just know what nats !! 3204 was.
14:53:11 <Cale> ... if you were expanding out the definitions ...
14:53:26 <Darius> astrolabe: Irrelevant because the thing that makes an (asymptotic) difference in speed/space is -what's- shared not how sharing is implemented (assuming a sane implementation).
14:54:02 <Darius> There are also multiple ways of implementing sharing.
14:54:03 <Cale> Of course it won't go and prove some theorem to be able to compute the nth element from its index.
14:54:15 <astrolabe> Darius: right, but what is the rule for what is shared?
14:54:52 <Darius> astrolabe: As I said, the Report doesn't specify it at all.  I believe, call-by-name (no sharing at all) is a legal implementation of Haskell.
14:55:22 <Darius> astrolabe: But for the most part in practice things with the same name.
14:55:36 <Darius> astrolabe: I.e. the two x's in f(x)=x+x
14:56:38 <Darius> But the sharing policy is only necessary for the speed/space behavior, not for the meaning of the code.
14:56:46 <astrolabe> But practically implementation speed is sometimes important.
14:57:08 <Cale> Profiling is useful for that.
14:57:11 <astrolabe> At least the O() behaiviour.
14:57:40 <xerox> Cale: do you mean calculating the nth element without the prior ones?
14:58:02 <Cale> xerox: basically, yeah
14:58:13 <xerox> Cale: how nice.
14:58:44 <Darius> astrolabe: I agree, but in practice the sharing behavior is the "intuitive" one in most cases, so there is a de facto standard for all but corner cases.
14:58:52 <xerox> Sounds like that formula to compute the nth digit of pi in hexadecimal representation
14:59:31 <Cale> xerox: well, I was saying that Haskell *won't* do that :)
14:59:40 <xerox> Cale: oh :(
14:59:56 * xerox disilluded :D
14:59:59 <Cale> xerox: it's too much to expect in general
15:00:08 <xerox> Cale: oh sure, in general.
15:00:11 <Cale> xerox: it can be hard enough for humans to do :)
15:00:27 <astrolabe> There is a haskell implementation of the fibonnaci function on some 'shootout' page that doesn't seem to take advantage of sharing.
15:00:38 <xerox> Cale: you agree it would be really nice ;)
15:00:50 <Cale> xerox: well, of course it would
15:01:27 <xerox> Cale: could be something real, even for limited application? Or it's just a dream?
15:01:30 <Darius> astrolabe: so?
15:02:02 <Cale> xerox: perhaps some day, after all, humans are capable of it.
15:02:45 <xerox> Cale: interesting tought, by the way. Something to note up.
15:03:29 <astrolabe> In my ignorance, I couldn't tell whether it would be able to take advantage of sharing or not.  When trying to programme practically, that uncertainty is unacceptable.
15:04:12 <astrolabe> http://shootout.alioth.debian.org/benchmark.php?test=fibo&lang=ghc&id=0&sort=fullcpu
15:04:15 <Cale> astrolabe: don't worry about it until after you are having trouble with performance, and have profiling information
15:05:20 <astrolabe> For most things, I agree with you Cale.  But some problems take a long time, and it is not clear why.
15:06:04 <Lemmih> Optimizing without profiling info is kinda like fixing a punctured tire without first figuring out where the hole is.
15:07:11 <astrolabe> Lemmih: Or like removing astronoughts appendicies, whether they will need it or not.
15:07:11 <Darius> astrolabe: It's pretty clear that that isn't sharing anything (there is nothing with the same name (well 'n' but...)) and it purposely isn't.  As long as it shares when you think it should and not when you don't things are fine.
15:09:05 <astrolabe> That is comforting to hear Darius, thanks.  Perhaps with a bit more experience, it will be clear to me too.
15:10:12 <wilx> Huh, how the hell does Data.Queue work?
15:10:30 <wilx> I am looking at its implementation in GHC and I completely do not get it.
15:11:01 <Darius> @wiki TyingTheKnot read down to --DerekElkins; that will probably help give you an idea of when things are shared or not and what one of the consequences is.
15:11:02 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot read down to --DerekElkins; that
15:11:02 <lambdabot> will probably help give you an idea of when things are shared or not and
15:11:02 <lambdabot> what one of the consequences is.
15:11:14 <Darius> wilx: Link?
15:11:37 <wilx> Link?
15:11:43 <wilx> I am reading the page...
15:12:02 <astrolabe> I will do.  Thanks.
15:13:55 <Darius> wilx: I was wondering if you were using the CGI interface to the CVS server.
15:13:57 <Oejet> <off topic>Does anyone know Omondo's UML plugin for Eclipse?</off topic>
15:14:41 <wilx> Nope, locally extracted sources.
15:15:06 <wilx> fptools/libraries/base/Data/Queue.hs
15:17:54 <Darius> Well it references the paper that explains it (or mostly why it has the complexities it has).
15:36:13 <shapr> kosmikus: do you think Eelco Visser will ever pick up Maak again?
15:38:31 * shapr hops
16:07:02 <shapr> So, where's the excitement?
16:07:44 <astrolabe> Definitely not here.
16:08:09 <shapr> I'm having fun coding.
16:08:24 <shapr> What are you doing?
16:08:40 <astrolabe> I have noticed that I want to stay up late coding haskell, which is nice.  Reminds me of when I was a kid.
16:08:54 <shapr> How long ago were you a kid?
16:10:12 <astrolabe> I'm reading through 600 odd lines of C++ I wrote 6 months ago, as part of a new strategy for a programme to play hex.  I'm trying to remind myself of how it works.
16:11:05 <astrolabe> Too long!  I'm remembering a 16k spectrum.
16:12:04 <astrolabe> The problem with exposure to haskell, is that it makes you realise how clunky C is.
16:12:08 <shapr> Wow, I started on a sinclair.
16:12:26 <shapr> Not that I did much with it.
16:12:43 * Heffalump did too
16:12:49 <astrolabe> I actually started on a ZX81 owned by my friends dad.  What did you start on?
16:13:04 <Heffalump> I think that's what we had.
16:13:18 <Heffalump> though I was only 6 or 7 at the time so I don't remember very well
16:13:50 <xerox> What does it mean "branch to" ?
16:13:51 <shapr> My friend won a Sinclair something, it had a membrane keyboard.
16:14:48 <astrolabe> The ZX81 had keys that didn't depress at all when you used them.  The ZX80 was the same, but the screen turned to snow whenever you pressed a key, because it used the same processor.
16:15:35 <shapr> xerox: depends on context. What's the whole sentence?
16:16:08 <xerox> "b label: Branch to label; if label is omitted, branch to end of script."  or  "t label: If  a  s///  has  done  a successful substitution since the last
16:16:11 <astrolabe> A membrance keyboard sounds like what my spectrum had.  Sort of a sheet of grey rubber, partially poking through holes to make 'keys'
16:16:17 <xerox> input line was read and since the last  t  or  T  command,  then branch to label; if label is omitted, branch to end of script.
16:16:36 <shapr> astrolabe: yeah, that's it.
16:17:04 <shapr> xerox: it means jump to the label.
16:17:12 <xerox> I see, thanks.
16:17:21 <astrolabe> maybe conditional jump?
16:17:24 <shapr> Branch as in move the instruction pointer there.
16:18:50 <astrolabe> 'Goto' used to be my best programming friend.
16:19:17 <Darius> Who needs functions when you have goto!
16:20:35 <Oejet> Heh, tail call's are just a complicated way to say "goto". :-)
16:20:43 <Oejet> -'
16:23:01 <Darius> Oejet: Yes, yes.  But the interesting part is implementing non-tail calls.
16:23:32 <dons> Oejet: like so:
16:23:33 <dons>       __target = (void *)(cont);        \
16:23:33 <dons>       goto *__target;                   \
16:23:46 <Darius> Though you could use CPS, then the interesting part is closures and parameter passing.
16:23:50 <dons> :) $fptools/ghc/includes/TailCalls.h
16:23:56 <shapr> g'day dons
16:24:07 <dons> morning shapr
16:26:50 <Darius> Of course you could lambda-lift the continuations reducing the problem to parameter passing.
16:27:28 <Darius> and maybe code-pointers.
16:38:06 <astrolabe> Can fib be written in Haskell using O(1) space?
16:39:59 <dons> sure
16:40:06 <dons> if it can in C
16:41:01 <astrolabe> I mean supposing integers use a fixed amount of space (which they don't)
16:41:22 <dons> Integers, you mean?
16:41:34 <dons> you could use Word64 if you wanted ;)
16:42:16 <eixei> hi there
16:43:51 <SyntaxNinja> hi
16:43:54 <astrolabe> You could in C.  I meant the mathematical meaning of the integers, but I don't think it matters much.  Should I be looking at monads to see how it is done?
16:44:36 <Darius> No
16:44:43 <dons> I don't think that would matter so much, as looking at the generated Core code.
16:45:07 <johs> astrolabe: http://folk.uio.no/johs/fib.hs
16:45:12 <johs> Like this, you mean?
16:46:47 <Darius> fib n = fib' n 0 1 where fib' 0 u v = u;fib n u v = fib' (n-1) v $! u+v
16:46:56 <astrolabe> Thanks johs, that might work.  I don't know enough haskell to tell.
16:47:53 <astrolabe> What is '$!'?
16:48:11 <Darius> f $! x = x `seq` f x
16:50:16 <astrolabe> Sorry to be a pain, I can't find seq in the tour of the prelude.
16:50:29 <johs> http://haskell.org/onlinereport/prelude-index.html
16:50:42 <johs> http://haskell.org/onlinereport/standard-prelude.html#$vseq
16:50:58 <johs> Hm.
16:51:09 <johs> Actually, that only says that seq is a primitive.
16:51:24 <johs> Oh, no.
16:51:29 <johs> http://haskell.org/onlinereport/basic.html#sect6.2
16:51:34 <johs> There's this, as well.
16:53:46 <astrolabe> Ah, that is exactly what I wanted to know.  Thanks guys.
16:54:18 <xerox> dons: with sed is possible to match un/correctly matching parens, right?
16:54:53 <johs> It is?
16:54:58 <johs> Doesn't sed use regexps?
16:55:08 <xerox> I'm reading it has some extensions.
16:55:27 <dons> you can write loops, with conditions in sed, so I imagine it is possible
16:55:30 <johs> Oh.
16:55:47 <dons> there's a turing machine and a lambda calculus interpreter written in sed
16:55:57 <dons> so simple algorithms shouldn't be too hard ;)
16:56:04 <xerox> yay :)
16:56:35 <dons> you could use the hold space as a stack to keep track of your recursion depth
16:56:48 <dons> then, pop the stack when you find a match
16:56:51 <dons> easy peasy
16:57:07 <xerox> I don't know enough, but I'm trying.
16:57:21 <dons> good docs here: http://sed.sourceforge.net/
16:57:30 <xerox> Reading "info sed" as now :)
16:59:37 <dons> loop labels will be your friend, I think.
17:00:12 <xerox> They're called "Commands for `sed' gurus" in the doc, yay.
17:00:38 <xerox> I can't completely understand how to use them, I'll better check some code.
17:01:00 <dons> :label .. some code... b label
17:01:04 <dons> b = branch
17:01:29 <xerox> dons: can you show me a complete example?
17:05:04 <dons> :loop
17:05:04 <dons> /x/ { s/x/y/
17:05:04 <dons>       b loop
17:05:05 <dons> }
17:05:23 <dons> that illustrates code blocks too
17:05:32 <xerox> I see, thank you.
17:05:33 <dons> and conditionals
17:06:00 <dons> the fun thing in sed is that you have only 1 variable (of infinite size) for you to partition as you want
17:06:01 <xerox> The regexp as line selector?
17:06:17 <dons> if line matches 'x' enter code block
17:06:35 <dons> so it loops over each line replacing 'x' for 'y'
17:06:46 <dons> s/x/y/g is usually how you'd write it
17:07:40 <xerox> Yep
17:07:49 <dons> and the sed variable (the hold space) is accessed via pattern matching, not, say, ptr addresses ;)
17:08:24 <xerox> Just.. where does it loop? In the pattern space?
17:08:37 <dons> no. 'pattern space' is a variable.
17:08:51 <dons> the sed virtual machine applies it's program to each line of input
17:09:13 <dons> lines of input are stored in the pattern space.
17:09:23 <dons> yeah, so it does loop over the pattern space in some sense
17:09:51 <dons> it won't go to the next line until you've removed all 'x's from the current pattern space/current line
17:10:04 <dons> where 'it'='sed machine'
17:10:29 <xerox> Yep
17:10:35 <xerox> Let me try hacking it
17:11:25 <dons> besides loops, the real power is in the 'hold space' which persists across individual lines of input
17:11:56 <xerox> Oh yes, s/b l/T l/ in your script changes only the first occurrence, i.e. exits the loop after the first substitution.
17:12:19 <xerox> (Not *that* regexp, I mean, using T loop instead of b loop :D)
17:13:07 <dons> T is new. Bonzini must have added it to gnu sed
17:13:35 <dons> that's something to be aware of: gnu sed as a few extensions of BSD sed now.
17:13:38 <xerox> Nice, any example of the "real power"? :D
17:13:45 <dons> let me see..
17:14:51 <liquidengineer> hi
17:14:58 <xerox> hi liquidengineer
17:15:21 <dons> xerox: oh, and you get a few extra variables via \( \)
17:15:32 <liquidengineer> question
17:15:36 <dons> which you can refer to in patterns \1 \2 \3 ... etc
17:15:37 <xerox> "Internal REGEXPs" ?
17:15:48 <xerox> Ah, okay I know those!
17:15:58 <xerox> I don't remember the term
17:16:03 <dons> they're really powerful, as you can match an unknown pattern repeatedly
17:16:06 <dons>     # subtract 12 from the hour...
17:16:06 <dons>     s,$,;130114021503160417051806190720082109221023112412,
17:16:06 <dons>     s,^\(..\)\(.*\);.*\1\(..\).*,\3\2,
17:16:08 <liquidengineer> what exactly is this error trying to tell me?
17:16:09 <liquidengineer> Syntax error in data type definition (unexpected numeric literal)
17:16:30 <dons> there's a syntax error
17:16:41 <liquidengineer> I'm trying to define this data type>data ExamNbr = 1 | 2 | 3
17:16:46 <liquidengineer> dons: I gathered that... ;)
17:16:47 <dons> can't do that
17:16:55 <liquidengineer> why not?
17:17:10 <xerox> Because 1, 2, 3 aren't types?
17:17:11 <dons> 1 2 3 etc are numeric literals, not valid constructor names
17:17:16 <liquidengineer> oh
17:17:23 <liquidengineer> that makes sense
17:17:30 <dons> they're not types either, they're values
17:17:39 <xerox> One Two Three would work
17:17:48 <liquidengineer> oh
17:17:55 <liquidengineer> the data thing is wierd coming from Java
17:17:58 <liquidengineer> but neat
17:18:23 <dons> it's just a union type when used like this. even C has them :)
17:18:24 <xerox> dons: it gives me unterminated `s' command
17:18:38 <dons> the above code?
17:19:01 <dons> unterminated 's' means the final / is missing from a s///
17:19:11 <xerox> dons: yep, the two lines for "subtracting 12 from the hour"
17:19:55 <dons> checking on gnu sed..
17:20:32 <xerox> Does it really finish with a `,' ?
17:20:46 <dons> pill00$ cat a.sed
17:20:47 <dons> #!/bin/sed -f
17:20:47 <dons> # subtract 12 from the hour...
17:20:47 <dons> s,$,;130114021503160417051806190720082109221023112412,
17:20:47 <dons> s,^\(..\)\(.*\);.*\1\(..\).*,\3\2,
17:20:49 <dons> pill00$ ./a.sed
17:20:51 <dons> 17:28
17:21:00 <dons> 05:28
17:21:23 <dons> yeah, the 's' command can use any char for it's delimiters
17:21:30 <liquidengineer> I gotta go
17:21:31 <xerox> oh yes!
17:21:32 <liquidengineer> thanks, guys
17:21:33 <dons> so , is often useful when / appears in the pattern
17:21:35 <xerox> bye bye liquidengineer
17:21:48 <xerox> eheh
17:21:51 <xerox> 12:34
17:21:51 <xerox> 41:34
17:22:10 <xerox> 00:00
17:22:11 <xerox> 82:00
17:22:22 <dons> do you see how it works though?/
17:22:32 <xerox> Not really
17:22:42 <xerox> Substitute the end of the line
17:22:56 <xerox> ..then I don't understand :)
17:22:58 <dons> yep, with an association list
17:23:08 <dons> 13 -> 01, 14 -> 02 ...
17:23:21 <xerox> Is it what ';' mean?
17:23:46 <dons> the ';' is a char literal to separate the current pattern, eg. "14:28" from the association list
17:24:04 <dons> so the pattern space is: "14:28;13011402..."
17:24:21 <dons> then the second line does what?
17:24:45 <xerox> 17:48
17:24:45 <xerox> 17:48;130114021503160417051806190720082109221023112412
17:24:49 <xerox> Without the second line
17:25:14 <dons> yep. input pattern, plus our own data structure.
17:25:35 <xerox> Now, that line doesmatch the first two chars
17:25:43 <xerox> and the rest
17:25:44 <dons> yep.
17:25:49 <xerox> literal ;
17:26:09 <xerox> everything but the first two char matched
17:26:25 <xerox> and matches the two charaters after those
17:26:33 <xerox> It's *SO* smart :D
17:26:39 <dons> so, (17)(:48);.*17(..).*
17:26:49 <xerox> It actually searches in the "association list"
17:26:59 <dons> yeah
17:27:10 <dons> this is in general how you do math in sed
17:27:17 <xerox> yay
17:27:26 <dons> and any other kind of data manipulation
17:27:31 <xerox> Where did you find that example?
17:27:36 <dons> i wrote it :)
17:27:53 <dons> so the final job is the 2nd side of the s///
17:27:57 <xerox> Yep
17:28:11 <xerox> Constructing the output
17:28:21 <dons> which has to clean up the whole pattern space, and return 05:48
17:28:22 <xerox> \3 is the "found string"
17:28:28 <dons> yep
17:28:39 <xerox>  Interesting.
17:28:49 <xerox> Why doesn't work with '12' ?
17:29:07 <dons> the code assumes x > 12 (it's just a fragment from a larger program)
17:29:25 <dons> so if you look in the assoc list, keys start at 13
17:29:37 <xerox> Oh yes, sorry, it's clear.
17:29:42 <dons> so if you insert '12' you get some garbage -- sed is not type safe!
17:29:49 <xerox> ^__^
17:31:01 <dons> other things to try to do: write a counter that adds a value to the hold space to count the number of lines
17:31:19 <dons> often it is easier to count in unary in sed
17:31:44 <dons> then you can use .\{13\}, say, to match number 13
17:32:22 <xerox> .\{13}\ means 13 single chars?
17:32:29 <dons> yep. hmm. I should write a tutorial on basic haskell-ish programming in sed.
17:32:57 <shapr> dons: is metaM the right way to do nested keymaps? ex - C-x C-s is save but C-x C-f is prompt for open file
17:33:31 <dons> metaM lets you jump to an alternative keymap. so you could use it for nested keymaps, yeah.
17:33:39 <shapr> Is there a more sensible approach?
17:34:08 <dons> you could, though, just lex C-x, then try to discriminates C-s|C-f
17:34:25 <dons> metaM is more for changing the keymap based on the return value of an IO action
17:34:42 <shapr> Ah, I see.
17:34:45 <dons> let me find an example in nano for C-c C-?
17:35:17 <shapr> The nano keymap is nearly a tutorial by itself.
17:35:41 <xerox> Last thing, then sleep: I can't see how the "buffers" are two in that sed script.  It seems to me that we're working on just one.. ?
17:36:02 <dons> they are only working on the pattern space.
17:36:48 <dons> you get at the hold space by modifying the pattern space to construct some value, then transferring it to the hold space
17:37:01 <dons> h or H
17:37:18 <xerox> And then to get the content of the hold space?
17:37:32 <xerox> Pattern matching with some special command?
17:37:38 <dons> g or G
17:38:00 <xerox> So it's only "holding", no work is possible on what holding space is holding?
17:38:02 <dons> no, there's no commands to access the hold space, you can pull it in to the pattern space, or use 'x' to swap them.
17:38:07 <xerox> yay, I'm asleep :)
17:38:14 <xerox> x! nice..
17:38:25 <xerox> If only wasn't 03:39AM :)
17:38:33 <dons> the best sed programming time!
17:38:38 * shapr grins
17:39:06 <xerox> I'd like to continue, my eyes say "no" :\
17:39:06 <eixei> good night xerox
17:39:14 <eixei> :-)
17:39:17 <xerox> Thanks much dons. Goodnight folks!
17:39:26 <dons> night xerox
17:39:26 <shapr> g'night xerox
17:40:20 <dons> shapr, normally you'd just use `meta` to return the next keymap to use (a pure type)
17:43:48 <shapr> I could hack theActionOf to take data Amap = A Action | M (M.Map Char Amap) or something similar.
17:44:05 <shapr> I suspect I'm asleep, I'm sure that datatype could be more sensible.
17:44:23 * SyntaxNinja throws bucket of water on shapr
17:44:26 * eixei gives shapr a coffe injection
17:44:48 <shapr> I think I just need sleep.
17:44:51 <dons> if you lived in .au you'd be awake now :)
17:45:04 <shapr> yeah, too bad.
17:45:36 <SyntaxNinja> no sleep!
17:45:45 <SyntaxNinja> water and coffee, that's all you get!
17:49:37 <eixei> I was just wondering... what do you call "university associations" (Hochschulgruppen) in english?
17:49:53 <eixei> (if you don't mind me being a bit offtopic)
17:53:09 <SyntaxNinja> what do they do?
17:53:53 <eixei> well... it depends
17:53:56 <eixei> some are political
17:54:02 <eixei> other sport associations
17:54:31 <SyntaxNinja> student organized?
17:54:31 <eixei> others just gather to play around with stuff.. for example haskell :-)
17:54:35 <eixei> yep!
17:54:46 <eixei> is that the name?
17:55:03 <SyntaxNinja> Student Organizations or Student Groups
17:55:07 <eixei> Thanks a lot :-)
17:55:18 <SyntaxNinja> student clubs maybe
17:55:54 <dons> student societies? e.g. compsoc
17:57:08 <eixei> judging from compsocs homepage I would say yes
19:05:12 <Oejet> Phew, finished my Eclipse Java tutorial and configuration.  Off to bed.
19:05:54 <Oejet> Good night all.
19:06:02 <eixei> good night
19:44:44 <cm> shapr
20:37:06 <lisppaste2> metaperl pasted "is this type defintion valid?" at http://paste.lisp.org/display/6987
20:39:45 <metaperl> I dont think it is valid, but it is on p.8 of Simon Thompson's book
20:40:06 <dons> what does the typechecker say?
20:40:37 <Gahhh> I don't think you pasted enough
20:41:13 <metaperl> no , never mind it is obvious
20:41:19 <metaperl> just think
20:41:25 <metaperl> add4 :: Int
20:41:26 <metaperl> won't work
20:41:33 <metaperl> add4 :: Int -> Int
20:41:36 <metaperl> is correct
20:41:46 <Gahhh> it doesnt have to take an arg
20:42:11 <metaperl> for add4 = (4 +)
20:42:12 <wagle> foo :: Int ; foo = 1
20:42:43 <metaperl> yes, but this book defines invertHorse = invertColor horse
20:42:54 <metaperl> which means the signature must be Picture -> Picture
20:43:01 <Gahhh> inverting horses is a disturbing thought...
20:43:01 <metaperl> not Picture as the author wrote
20:43:13 <metaperl> happens to cows everyday
20:43:22 <wagle> Gahhh: sortof like cow tipping?
20:43:22 <metaperl> if you've seen a slaughterhouse video
20:43:26 <metaperl> no, worse
20:43:29 <cm> good evening..
20:43:35 <metaperl> GE cm
20:43:37 <metaperl> cm GE
20:43:41 <metaperl> cm GE Ge cm
20:43:43 <Gahhh> apparently you tip cows, but you 'invert' horses. heh.
20:43:46 <cm> :o)
20:44:24 <metaperl> it just aggravates me that he would put something wrong in the book and then a page later do it right
20:44:36 <metaperl> but he is certainly giving you Haskell in gentle baby steps
20:44:39 <wagle> what type is horse?
20:44:51 <metaperl> instead of a giant leep with each sentence
20:44:58 <metaperl> horse's type is Picture
20:45:06 <Kkaa> Thompson is correct
20:45:11 <metaperl> ?
20:45:18 <keverets> if horse :: Picture and invertHorse :: Picture -> Picture, then blackHorse :: Picture
20:45:19 <metaperl> blackHorse = invertColour horse
20:45:33 <Kkaa> exactly
20:45:40 <wagle> ok..  what type should a color inverted horse have?
20:45:40 <metaperl> blackHorse :: Picture -> Picture
20:45:46 * Khisanth emails PETA
20:45:51 <Kkaa> ha ha
20:45:51 <metaperl> lol
20:46:19 <metaperl> I dont follow
20:46:21 <Kkaa> no, blackHorse does not take an argument
20:46:21 <wagle> alternatively, what is the type of invertColor?
20:46:52 <metaperl> oh you are right
20:47:06 <metaperl> I read too much into the example
20:47:31 <metaperl> blackHorse = (invertColor) -- type signature Picture -> Picture
20:47:40 <metaperl> curry inventColor
20:48:21 <Kkaa> correct
20:53:43 <cm> this is bizarre
20:53:53 <cm> every mouse action seems to be duplicated ;o
20:54:24 <cm> when i click an item in the waimea menu, it launches xterm twice.. and the cursor is way too fast :o)
20:55:26 <wagle> click on some money
20:55:31 <cm> lemme try..
20:57:45 * wagle waits for his cut of the profits
20:57:54 <cm> doesn't work :p
20:58:16 <wagle> darn
20:58:48 <Kkaa> how do I reimplement the show function for a type I've created in a module without hiding the Prelude's show function?
20:59:38 <cm> instance Show <yourtypegoeshere> where show .. = ..
21:00:13 <Kkaa> ah
21:00:15 <Kkaa> thanks
21:13:46 <Kkaa> hmm... does anyone know a way to get around Haskell 98's non-support for multiple parameter classes?
21:22:57 <Kkaa> nm, it seems this is a bigger problem than I thought
21:33:22 <SyntaxNinja> shapr: you've got mail
21:39:56 <SyntaxNinja> quiet here.
21:40:06 <SyntaxNinja> I'm at a coffee shop. I have coffee.
21:40:21 <eixei> I'm at home... but I too have coffee
21:40:24 <SyntaxNinja> and either the CD player here is broken, or the music is really COOL
21:40:33 <eixei> :-)
21:40:58 <SyntaxNinja> I accidentally got 4 books from slashdot to review.  I thought they were only going to send me 1 or 2
21:41:59 <Kkaa> how did that happen?
21:43:59 <SyntaxNinja> they sent me a list of books, and I marked the ones I COULD review, and they maybe sent all of them to me, or close to all of them.
21:44:15 <SyntaxNinja> I figured there would be some competition, and I'd only get my top pick, or they'd spread it out more or something.
21:44:29 <SyntaxNinja> but I guess if no one else wanted them, they won't care that it'll take me a year to read all of them.
21:44:44 <Kkaa> sounds like fun
21:44:49 <SyntaxNinja> hope so!
21:44:49 <Kkaa> :-)
21:44:55 <SyntaxNinja> otherwise, it'll be really tedious ;)
21:51:46 <vdrab> hi #haskell. Anyone know if someone is working on a book on monadic programming in haskell? I went through all the existing tutorials and then some, and I have the basic idea down, but I am not sure I really got all the intricacies and possible applications of monads, which problems tend to go well with which monads, etc.... something like a GOF design patterns book for monads... :-)
21:52:09 <vdrab> not a chance? : (
21:52:20 <vdrab> not in this life time?
21:52:43 <Kkaa> i wish
21:53:05 <vdrab> \me sighs
21:53:12 <vdrab> doh
21:53:13 <Kkaa> try http://www.nomaware.com/monads/html/
21:53:23 <vdrab> sure, I read it.
21:53:32 <vdrab> like I said, I get the basic picture
21:53:45 <Kkaa> k
21:53:58 <vdrab> I just can't really see how to go from here to being a monad-spewing super guru....
21:54:05 <Kkaa> :-)
21:54:44 <vdrab> feels like there's a big gap between the sheep cloning tutorials to writing a monadic OS kernel
21:54:56 <vdrab> maybe it's a basic IQ problem, I dunno
21:54:58 <vdrab> hehe
21:55:04 <Kkaa> wow, that is a big leap
21:55:50 <vdrab> kkaa : well, exagerating a bit
21:56:29 <araujo> Ive heard that cloning procedures are very trivial actually
21:56:47 <Kkaa> well, maybe if this recent wave of interest in Haskell continues someone will write it
21:57:00 <vdrab> that's what I was hoping for
21:57:50 <vdrab> but layman - style introductory books don't get people published in the journal of functional programming, which is probably why we don't have them. : (
21:58:15 <vdrab> oh well. end of rant ; )
21:58:59 <Kkaa> too bad FP is still relegated largely to academia
23:12:29 <Itkovian> meuning
23:12:38 <Lemmih> Morning.
23:26:26 <kosmikus> shapr: it's Eelco Dolstra's project, but I think it is possible, yes
23:42:01 <Lemmih> Oeje1: God morgen.
23:44:38 <Oeje1> Lemmih: God morgen.   Such a nice (but cold) day today.  I was up until five o'clock to do Eclipse tutorial and setup.
23:45:01 <Lemmih> (:
23:45:18 <Oeje1> *Godmorgen
23:49:09 * Oeje1 celebrates the completness and accuracy of the Danish states registers of personal information on it's citizens.
23:49:27 <Oeje1> *completeness.
23:49:31 <Cybertnt> Anybody awake that can help me with the Bits library? I just dont understand how to use the function xor. Everything i try results in an error
23:49:44 <Oeje1> Cybertnt: Yes!
23:49:47 <Oeje1> Me.
23:50:03 <Oeje1> Could you paste your expression?
23:50:05 <Cybertnt> wonderful :)
23:50:24 <Cybertnt> Bits> xor 1 2
23:50:32 <Lemmih> xor 1 2 :: Int
23:50:48 <Cybertnt> i tried that one as well
23:50:52 <Cybertnt> results in an error too
23:51:01 <Lemmih> Works for me.
23:51:06 * Oeje1 is too slow. :-/
23:51:11 <Heffalump> what error do you get?
23:51:12 <Lemmih> Is Data.Bits in scope?
23:51:35 * Oeje1 gives up trying to help Cybertnt. :-P
23:51:35 <Cybertnt> Bits> xor 1 2 :: Int
23:51:35 <Cybertnt> ERROR - Illegal Haskell 98 class constraint in inferred type
23:51:35 <Cybertnt> *** Expression : 1 `xor` 2
23:51:35 <Cybertnt> *** Type       : Bits Int => Int
23:52:20 <Lemmih> Works for me in Hugs.
23:52:40 <Heffalump> Prelude> :m Data.Bits
23:52:40 <Heffalump> Prelude Data.Bits> xor 1 2 :: Int
23:52:40 <Heffalump> 3
23:52:43 <Heffalump> (in ghci)
23:52:56 <Lemmih> Data.Bits> xor 1 2 :: Int
23:52:56 <Lemmih> 3
23:53:03 <Lemmih> (hugs)
23:53:29 <Cybertnt> Prelude> :l Bits
23:53:37 <Cybertnt> thats what i do to load it
23:53:39 <Oeje1> Prelude> Bits.xor 1 2 :: Int     ==>  3     (GHCi 6.4 on Windows)
23:53:50 <Cybertnt> ( i am using hugs )
23:54:03 <Igloo> Cybertnt: What version?
23:54:18 <Cybertnt> -- Hugs Version February 2001
23:54:19 <Heffalump> ahah
23:54:29 <Oeje1> Er, 6.2.1 on Windows. :-(
23:54:31 * boegel pats everyone on the back "How you doin'"
23:54:33 <Lemmih> Time to upgrade (:
23:54:41 * Heffalump reproduces on hugs December 2001 (Igloo: version on urchin)
23:55:22 <Cybertnt> :/ is that out of date *blush* ?
23:55:34 <Heffalump> seems that way
23:55:40 <Heffalump> it works ok with the November 2003 version
23:56:04 <Cybertnt> hmm thats the newest version i have in my port manager though (running Mac OS)
23:56:36 * Itkovian has got his book on 'Types and Programming Languages'. And there was much rejoicing.
23:57:00 <Cybertnt> whats the newest version for ghc? I see a 6.2-2 there..
23:58:25 <Gahhh> Itkovian, heh
23:58:26 <wilx> 6.4.
23:58:29 <wilx> Very recent.
23:58:37 <Cybertnt> ok thanks
23:58:37 <Lemmih> Cybertnt: 6.2.2 is good. 6.4 still has some issues.
23:59:08 <Cybertnt> ah i have found a version of hugs for Mac OS X thats from 2005 :)
23:59:53 <Gahhh> I'd skip hugs directly for ghci.
