00:10:17 <musasabi> Does the haddock-cvs have fixes so it does not crash on template haskell?
00:10:34 <musasabi> 'name is too much for it.
00:25:04 <glimming> parametricity:    what is the mathematical meaning of   tau -> sigma    being polymorphic?
00:25:33 <musasabi> pesco: you posted the unicode-haskell thing?
00:25:54 <musasabi> pesco: have you tried using xsymbol?
00:30:44 <hellish> Was there a bug in ghc 6.2 that allowed segfaults without using Foreign?
00:31:27 <musasabi> hellish: you can get segfaults multiple ways without foreign.
00:31:58 <musasabi> Data.Array.Base (unchecked array indexing), unsafePerformIO + polymorphism, ...
00:32:29 <musasabi> of course it can be a bug too (might be fixed in 6.4 ;)
00:32:49 <hellish> Should I wait for 6.4 to build then?
00:33:26 <musasabi> hellish: I would install 6.4 and see if the problem persist - if you think it is not a problem in your code.
00:35:16 <hellish> musasabi, allright.
01:22:51 <metaperl> I need some parsec help... the Main.hs in the intro examples has some issues. First it required an import Char for the digitToInt function... I added that... now the function factor is  calling a function parens but there is no such function... changing parens to matching (another function) does no good as it yields type errors... the Parsec distro Main.hs is here: http://www.hcoop.net/~terry/haskell/parsec/distro/examples/
01:25:56 <skew> metaperl: parens is something like between (char '(') (char ')')
01:26:35 <metaperl> yes, but can you get Main.hs to interpret?
01:26:51 <metaperl> it isnot in the Main.hs and ghci cannot interpret it
01:28:45 <nlv11757_> anyone read/seen that new book edited by pierce: "Advanced Topics in Types and Programming Languages" ?
01:29:02 <metaperl> well, autrijus is using it to implement Perl6 :)
01:29:14 <metaperl> you might join #perl6 and talk to him about it
01:29:26 <nlv11757_> ow really?
01:29:28 <nlv11757_> sweet
01:29:52 <skew> metaperl: parens comes from a token parser
01:30:33 <metaperl> so what do I do to fix Main.hs
01:30:47 <skew> I'd look for an up to date version
01:31:04 <skew> Check out http://www.cs.uu.nl/people/daan/parsec.html
01:31:21 <metaperl> I have the .zip from there... itdates year 2000 (Main.hs does)
01:32:26 <skew> is it parsec-2.0.zip, or parsec-1.1.zip?
01:32:34 <metaperl> 2.0
01:33:18 <nlv11757_> wow dejavu
01:33:51 <metaperl> oejet, are you a parsec user? can you help with getting Main.hs to compile? here's my problem description: http://sequence.complete.org/node/38
01:34:39 <Oejet> metaperl: I'll take a look.
01:38:12 <skew> looks like it should work
01:38:24 <metaperl> skew, did you run it?
01:39:02 <Oejet> metaperl: ]ghc --make Main.hs  ==> The main function `main' is not defined in module `Main'   When checking the type of the main function `main'
01:39:03 <skew> it loaded fine after adding Data.Char
01:39:21 <skew> it found parens just fine
01:39:22 <metaperl> reallY?
01:39:32 <metaperl> you mean you did Import Data.Char
01:39:33 <Oejet> ]ghci Main.hs   is ok.
01:39:33 <metaperl> ?
01:39:40 <metaperl> not here it isnt
01:39:43 <skew> This is examples/UserGuide/Main.hs from parsec-2.0.zip, right?
01:39:50 <metaperl> yes
01:39:51 <skew> I ran ghci Main.hs -package parsec
01:40:32 <skew> what do you get when you try to run it?
01:40:45 <metaperl> oh, that works
01:40:50 <skew> parse is used correctly, as a record selector on the lang record
01:40:54 <metaperl> I didn't know to run -package parsec
01:41:07 <metaperl> I just type ghci Main.hs
01:41:12 <metaperl> thanks
01:41:22 <skew> loads without the -package parsec here
01:41:50 <skew> I don't know how I'm suppsoed to try running these examples
01:42:28 <Oejet> skew: run testOr2 "abekat"
01:42:28 <metaperl> run simple "a"
01:42:38 <skew> yeah, just got that
01:42:41 <metaperl> runs the simple parser which expects a letter
01:43:29 <skew> ghci Main.hs works fine and run expr "(1 + (2*3))" prints 7, so the definition with parens is fine too.
01:44:16 <metaperl> no, plain ol' ghci Main.hs didnt work for me
01:44:22 <metaperl> also, the file needs import Char
01:44:25 <skew> what error do you get?
01:44:27 <metaperl> to digitToInt to work
01:44:36 <skew> yeah, once you've added import Char
01:45:24 <metaperl> actually it is working now for me too
01:45:44 <metaperl> It really was failing... I dont know why it is now working
01:45:45 <metaperl> odd
01:46:43 <skew> There does seem to be a parsec package
01:47:07 <metaperl> well this parsec thing is cool... I found a simple interpreter written in Haskell: http://www.cs.kent.ac.uk/projects/refactor-fp/Monadification.html
01:47:33 <metaperl> I got the idea to interpret/parse a language into the interpreter
01:48:01 <metaperl> maybe parse many different syntaxes into the same abstract evaluation engine
01:48:08 <metaperl> hey, it excites _me_ :)
01:49:30 <skew> have you read "The essence of functional programming" by Wadler?
01:49:38 <metaperl> parens fails....
01:49:41 <metaperl> no skew I have not
01:49:58 <skew> It's an introduction to monads using an interpreter as the running example
01:50:17 <skew> Extending the interpreter monad step by step to add language features
01:50:23 <metaperl> interesting.. I want to compile to an abstract machine... I have never done that
01:50:37 <metaperl> I think interpretation is a bit of an out-of-control wayto do things
01:50:47 <metaperl> I want to build a machine and compile to i
01:51:27 <metaperl> *Main> run parens "()"
01:51:27 <metaperl>  
01:51:27 <metaperl> <interactive>:1:
01:51:27 <metaperl>     Couldn't match
01:51:27 <metaperl>         `Parser a'
01:51:27 <metaperl>         against
01:51:29 <metaperl>         `TokenParser st -> CharParser st a1 -> CharParser st a1'
01:51:31 <metaperl>         Expected type: Parser a
01:51:33 <metaperl>         Inferred type: TokenParser st
01:51:35 <metaperl>                        -> CharParser st a1 -> CharParser st a1
01:51:43 <metaperl> parens is breaking... let me try matching
01:52:29 <metaperl> matching is not really matching anything
01:52:55 <metaperl> *Main> run matching "()"
01:52:55 <metaperl> ()
01:52:55 <metaperl> *Main> run matching "[]"
01:52:55 <metaperl> ()
01:52:55 <metaperl> *Main> run matching "["
01:52:55 <metaperl> ()
01:52:57 <metaperl> *Main> run matching "a"
01:52:59 <metaperl> ()
01:53:01 <metaperl> *Main> run matching "5"
01:53:03 <metaperl> ()
01:55:30 <skew> Huh? it's working just fine...
01:55:45 <skew> read the definition again
01:56:18 <skew> you are thinking runLex matching.
01:56:37 <metaperl> the definition?
01:56:45 <skew> of parens and of run
01:57:01 <skew> or to be fair, the docs of the parse function
01:57:15 <skew> in particular, not consuming all input is not a parse error
01:58:21 <skew> runLex matching "["
01:58:32 <skew> parse error at (line 1, column 1):
01:58:36 <skew> unexpected "["
01:58:38 <metaperl> run matching "6" should have thrown unexpected data error
01:58:40 <skew> expecting "(" or end of input
01:59:10 <skew> metaperl: nah, it matching the empty string at the start of input, and leaves '6':[] unconsumed
01:59:55 <skew> I'm not quite sure why it works that way, but the behaviour you saw and the definition of runLex reminded me
02:00:31 <metaperl> matching expects ( matching ) matching
02:00:36 <metaperl> how can an empty string satisfy that?
02:00:39 <skew> or nothing
02:00:54 <metaperl> oh!
02:00:59 <metaperl> <!> return ()
02:01:06 <metaperl> nice catch
02:01:08 <metaperl> :)
02:01:21 <metaperl> that's an interesting concept of nothing
02:01:22 <skew> if there wasn't a base case it could only accept '(' <infinite matched parens go here> ')' <infinitely more parens>
02:01:36 <skew> not quite as useful
02:03:29 <skew> Although, I have a vauge idea that that sort of thing might make possible a language that computes solely by seeing what parse errors you get.
02:04:16 <skew> (Useful for the Succ Succ Zero'th IOHCC of course, or is that the Twice Succ Zero'th IOHCC?)
02:05:46 <skew> unary isn't really planning for the future, unless you count the vauge hope that sufficiently intelligent humans will eventually be able to optimize the convention to Succ^k Zero'th IOHCC...
02:07:55 <metaperl> I see that runLex is a curried function,but I don't know how the string input to this curried function becomes consumed
02:08:06 <skew> expand it out
02:08:31 <skew> in particular, eta expand
02:08:43 <skew> runLex p -> run <some parser involving p>
02:08:55 <skew> so, runLex p str -> run <some parser involving p> str
02:09:11 <Oejet> metaperl: Look at the type signature of parens again.
02:09:39 <skew> For that matter, runLex itself has signature (Show a) => Parser a -> String -> IO ()
02:10:05 <skew> it promises to take a parser and a string and give you a gob of side effects to perform
02:10:52 <skew> if you _are_ asking about the implementation, notice that neither side is fully applied, and both still want a string
02:11:31 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/SerTH/ - binary serialization library - opinions wanted.
02:11:58 <metaperl> ok, I think the deep implementation of parsec is beyond me
02:12:11 <skew> metaperl: it's not that hard
02:12:34 <skew> suppose we have add :: Int -> Int -> Int, defined like add a b = a + b
02:12:52 <skew> then we can define addOnePlusXtoY x y = add (x+1) y
02:13:40 <metaperl> that bird article "essence of fp" is not available free online is it? yes skew, that makes sense add and addOnePlusXtoY
02:13:48 <nlv11757_> musasabI: what do you mean with 'reified' ?
02:13:59 <skew> run and runLex have exactly the same shape as that
02:13:59 <Itkovian> meuning
02:14:12 <Itkovian> @seen shapr
02:14:12 <lambdabot> shapr is in #haskell.
02:14:14 <skew> metaperl: that article can be found
02:14:27 <musasabi> nlv11757_: to reify.
02:15:12 <nlv11757_> it's not in my english vocabulaire I guess
02:15:33 <skew> do you know what reify means?
02:15:44 <metaperl> I got it in pdf from citeseer
02:16:33 <earthy> well then
02:16:46 <nlv11757_> no skew
02:16:49 <nlv11757_> i don't
02:17:02 <Philippa> "to make real", HTH HAND :-)
02:17:39 <skew> Merriam-Webster says "to regard (something abstract) as a material or concrete thing"
02:17:43 <nlv11757_> ok I almost got this locked down, now what does HTH mean :P
02:17:56 <Philippa> Hope That Helps
02:18:00 <nlv11757_> ah ;)
02:18:00 <Philippa> and HAND is Have A Nice Day
02:18:10 <nlv11757_> ok that was my next question
02:18:12 <Philippa> often sarcastic :-)
02:18:30 <musasabi> nlv11757_: the TH paper explains it, basically to tell the structure of a type in this context.
02:18:35 <nlv11757_> owww you were being sarcastic
02:18:36 <nlv11757_> :)
02:18:48 <nlv11757_> ok musasabi
02:19:04 <skew> in programming, reify almost always means to take something and represent it with a first-class value
02:20:37 <skew> the reify expressions/statements is written around a type and gives you a value in an algebraic data type representing types, for example (that's probably the reify you were refering to all along)
02:21:33 <nlv11757_> kind of instantiating the type?
02:22:21 <skew> more like reify (A -> B) gives you a value like ArrowT (TyCon "A") (TyCon "B"), in some algebraic data type Type
02:22:42 <Philippa> which you can then manipulate to your own foul ends
02:23:05 <Philippa> a classic example might be creating a typeclass instance for it
02:36:12 <nlv11757_> owwww ok, this example made it much clearer than words
02:37:21 <nlv11757_> TH HAND
02:43:30 <metaperl> skew, that is an earth-shattering article
02:43:35 <metaperl> thanks for the reference
02:47:16 <metaperl> http://sequence.complete.org/node/39
02:47:17 <metaperl> The Essence of Functional Programming by Bird
02:49:21 * metaperl slumbers
02:52:08 <musasabi> @seen shapr
02:52:08 <lambdabot> shapr is in #haskell.
02:52:14 <musasabi> duh.
02:57:14 <kosmikus> metaperl: wadler and bird a different persons though ;)
03:12:59 <Oejet> shapr: PING
03:16:24 <Lemmih> Wee. I've successfully uploaded a file with my DC client written in Haskell.
03:17:01 <skew> Neat. I've been trying to get scroll bars working in wxHaskell for a while
03:17:02 <Oejet> Lemmih: What is DC?
03:17:36 <Lemmih> Oejet: Direct Connect. Used for P2P filesharing.
03:24:11 <skew> I don't understand the wxHaskell layout model at all
03:24:24 <skew> my program is just making a teensy little square
03:29:24 <Lemmih> Have to tried 'fill'?
03:29:36 <skew> I've tried it in a few places
03:30:21 <skew> I'm trying to follow the examples, but I don't understand how the combintors and the size attributes interact
03:31:39 <skew> wow, I had forgotten how annoying traditional window managers can be
03:32:16 <Oejet> skew: Traditional?
03:33:05 <skew> I usually use ion, but that hides some brokenness in the wxHaskell programs I'm writing
03:33:15 <skew> ion is about partitioning the screen and putting programs in those panels
03:33:38 <skew> rather than trying to manage the windows yourself with a mouse
03:33:55 <Oejet> skew: Ok.
03:34:41 <skew> specifically, my programs tend to start as a minimally sized box
03:36:17 <Lemmih> clientSize := Sz 640 480?
03:36:26 <skew> clientSize?
03:36:37 <Lemmih> clientSize!
03:36:54 <skew> how is that different from outerSize, area, or virtualSize?
03:37:04 <skew> is there a good explanation somewhere?
03:37:50 <skew> outerSize seems to work too
03:43:45 * Lemmih kicks the DC-protocol info in the monads.
03:44:40 <Lemmih> Erroneous documentation is _so_ annoying.
03:45:06 <skew> that's why descriptive types are so cool
03:48:04 <skew> and having a compiler check that they match the code
03:55:33 <basti__> uhm hi
03:56:22 <Lemmih> Weird. I can't get transfer speeds higher than 2.5MB/s over a LAN... and my program isn't using any CPU.
03:56:41 <skew> that's not the maximum capacity of the lan?
03:56:45 <basti_> what speed is the lan?
03:56:53 <basti_> 10mbit or 100mbit?
03:56:57 <Lemmih> 100mbit.
03:57:05 <mflux> it obviously isn't 10Mbit :)
03:57:09 <basti_> then i would expect 10 mbyte/s as ABSOLUTE maximum.
03:57:20 <earthy> basti_: bzzt.
03:57:22 <skew> that's assuming just tcp overhead, I think
03:57:24 <nlv11757_> no CPU usage...who said Haskell couldn't compete with C
03:57:25 <nlv11757_> :P
03:57:36 <basti_> i think 2.5 is a reasonable value though
03:57:37 <earthy> 11 MBytes/s is maximum attainable on 100mbit
03:57:46 <earthy> over TCP
03:57:56 <basti_> i believe you if you say so.
03:58:08 <earthy> 2.5MBytes is not unreasonable
03:58:26 <nlv11757_> 12 Mbyte/s overhead?
03:58:30 <skew> Lemmih: can you get more speed with anything else?
03:58:41 <basti_> there's stopbits.
03:58:42 <earthy> nlv11757: 100/8 == 12.5
03:58:53 <earthy> there's stopbits, there's IP and TCP headers
03:58:59 <basti_> in fact i think ethernet uses both start and stopbits for every byte
03:59:02 <Lemmih> Erhm... I skrewed up (-:
03:59:08 <basti_> which would make it 10 bits per byte transferred
03:59:09 <nlv11757_> i meant 12 Mbit/s
03:59:09 <earthy> ethernet headers, even
03:59:11 <nlv11757_> sry
03:59:26 <basti_> then theres ethernet headers and tcp/ip headers.
03:59:41 <basti_> and then theres the fact that a network card can not ever claim the medium all the time
03:59:55 <skew> plus the time for tcp to ramp up the transmission window
04:00:30 <mflux> hm, ethernet really uses start/stop-bits for each bit? I would expect it to synchronize during the preample, and not need any per-byte-marking?
04:00:43 <mflux> s/bit\?/byte?/
04:01:03 <earthy> not sure about that oen
04:01:32 <basti_> aw no 100 mbit ethernet uses a 4-to-5 code
04:01:51 <basti_> but that means 10 bits per byte too
04:03:46 <basti_> "4b5b" allegedly
04:04:33 <basti_> mflux: this sort of oscillator desynchronizes within a few bits, btw.
04:06:44 <icewater> hello
04:06:53 <icewater> is there a haskell webserver?
04:07:03 <icewater> better than apache
04:07:05 <basti_> beyond experimental?
04:07:13 <icewater> is there a haskell irc client that works on windows?
04:07:19 <nlv11757_> does there exist a haskell irc client
04:07:20 <nlv11757_> :o
04:07:26 <nlv11757_> sick, i was about to ask that
04:07:30 <skew> There is a client for gale
04:07:48 <icewater> does haskell work on winxp?
04:07:54 <basti_> yes it does.
04:08:07 <basti_> resp., many of the haskell compilers and interpreters do
04:08:09 <icewater> how does haskell handle macros, or is lisp the only one able to do that
04:08:27 <basti_> theres "template haskell" (and similar constructions) that basically do macros
04:08:41 <basti_> but not in the genuinely beautiful lisp way.
04:08:47 <icewater> can non computer science majors learn haskell?
04:08:52 <basti_> yes.
04:08:56 <skew> no, you must be a martian
04:08:59 <vegai> one could take out the IRC parts from lambdabot and slap in an interface
04:09:10 <icewater> is it usible for internet site building?
04:09:11 <shapr> I learned Haskell and I've never had a computer science class in my life.
04:09:17 <shapr> I built my website with Haskell.
04:09:20 <icewater> what do you use it for
04:09:28 <vegai> shapr: s/and/thanks to the fact that/ :P
04:09:28 <icewater> what is your website?
04:09:36 <basti_> lol
04:09:45 <shapr> I use Haskell to make money. I'm self-employed.
04:09:53 <icewater> you are my idol
04:10:01 <icewater> I quit an insurance job
04:10:04 <basti_> that was quick.
04:10:09 <icewater> I want to do computers
04:10:13 <xerox> yo
04:10:14 <icewater> ;)
04:10:31 <basti_> you should maybe have learned about computers BEFORE, then :P
04:10:39 <icewater> lol
04:10:47 <shapr> Haskell will definitely get you into one of the good parts of computers. There's a lot of good stuff to learn here.
04:10:51 <skew> what is IRC?
04:10:56 <icewater> I used to work as a unix troll
04:11:02 <skew> what are these computers everybody is talking about?
04:11:16 <shapr> skew: they're like an abacus but, the beads are smaller.
04:11:28 <icewater> want to hear some comedy?
04:11:33 <skew> cool! Is that the core?
04:11:38 <icewater> I installed this www.gobolinux.org
04:11:46 <icewater> then tried this www.netbsd.org
04:12:04 <Itkovian> icewater: well, what was wrong with those?
04:12:06 <icewater> netbsd from the floppies
04:12:09 <icewater> well
04:12:17 <shapr> skew: Intel trains microscopic people to do abacus stuff inside their chips.
04:12:18 <icewater> gobo put me in 640 resolution
04:12:21 * basti_ goes well with debian.
04:12:26 <icewater> adn netbsd wouldnt install anything
04:12:42 <Itkovian> icewater: yeah, so? you can easily crank up the resolution. rtfm.
04:12:43 <basti_> even though I use my computer primarly desktop wise
04:12:59 <basti_> netbsd installation/package management sucks galore, imo.
04:13:04 <icewater> on gobo it was a bugger since they rearranged the unix dir tree
04:13:12 <basti_> no wonder you didnt get that.
04:13:15 <Itkovian> no xp with metbsd, but you might have a go a freebsd.
04:13:34 <Itkovian> icewater: try one of the less experimental distro's then.
04:13:37 <basti_> if there are any similarities in the package distribution, i would say, triple no
04:13:39 <icewater> in netbsd i got somehting pkgsrc and it started to downlaod firefox and got kinda gummed up
04:13:39 <Itkovian> take suse, redhat, gentoo, ...
04:13:48 <Itkovian> or try freebsd
04:13:49 <icewater> on netbsd I got X working with 1024x768
04:13:55 <Itkovian> yay
04:14:04 <basti_> i think debian is the finest distro in a way.
04:14:05 <shapr> icewater: you might want to try webmin on whatever setup you're trying
04:14:09 <basti_> i another way, its the most sucky one.
04:14:10 <basti_> ;)
04:14:39 <basti_> but in fact i never had a debian installation "fubar"
04:14:48 <basti_> which has happened with other installations
04:15:11 <Oejet> icewater: Did you also get only 640 pixels on the GoboLinux LiveCD?
04:15:14 <icewater> one thing that makes me nervous is ac97 sound under linux
04:15:19 <icewater> how do i get sound going?
04:15:22 <icewater> is it hard?
04:15:32 <shapr> icewater: no, it's not hard.
04:15:35 <icewater> no on gobo live cd 1024x768
04:15:50 <icewater> I tried to mount a floppy and copy xfonfig off of live cd
04:15:51 <basti_> how about we move on to a linux chan for that discussion?
04:15:58 <icewater> but I couldnt get floppy formatted
04:16:03 <icewater> I used reiserFS
04:16:07 <icewater> in hd install
04:16:07 <Oejet> icewater: You might have found http://gobo.kundor.org/kb/index.php/Afterboot useful.
04:16:22 <icewater> hmm
04:16:38 <icewater> I have posted on thier forum about X its a known bug in 11
04:16:42 <icewater> release 11
04:16:44 <icewater> lol
04:16:49 <icewater> live CD doesnt copy it over
04:16:58 <Oejet> icewater: Nope.
04:16:59 <icewater> also, why does dhcp pick up almost everything in XP
04:17:06 <icewater> and not under gobo or netbsd?
04:17:10 <icewater> ok
04:17:17 <icewater> thats it for now
04:17:26 <basti_> because you have to configure your dhclient to do so
04:18:29 <Oejet> icewater: GoboLinux has nice support for Haskell related packages, though.  Hopefully even integrated Cabal someday.
04:18:40 <basti_> btw. how's cabal doing?
04:18:50 <basti_> i've heard it reporting some kind of release?
04:18:58 <icewater> cabal is?
04:19:06 <icewater> what is cabal again?
04:19:08 <nmoore> where can i get a list of lambdabots commands?
04:19:13 <basti_> its a kind of haskell related package management
04:19:14 <basti_> @list
04:19:15 <lambdabot> Sorry, I don't know the command "list", try "lambdabot: @listcommands"
04:19:22 <basti_> nmoore: see?
04:19:40 <nmoore> basti_: yes, it'd be good if it was @help surely?
04:19:45 <icewater> see if I can get 1024x768 resolution and a web browser going I wont complain
04:19:47 <shapr> nmoore: fix it!
04:19:54 <icewater> I could not with either
04:19:55 <icewater> :(
04:20:03 <icewater> <---loser
04:20:04 <nmoore> shapr: so you agree?
04:20:10 <basti_> icewater: thats a matter of xserver configuration
04:20:17 <shapr> nmoore: lambdabot's primary purpose is to be a code-toy that anyone can play with, only secondarily is it useful in other ways.
04:20:25 <skew> nmoore: He means "patches welcome"
04:20:36 <icewater> is it simpler to learn programming ona unix box?
04:20:41 <shapr> icewater: *YES*
04:20:50 <skew> icewater: in many ways
04:20:54 <shapr> icewater: programming on windows is like learning to dance in a body cast
04:20:56 <icewater> damn
04:20:58 <musasabi> back from lunch.
04:20:59 <icewater> lol
04:21:09 <icewater> hey that is by that hacker guy quote
04:21:10 <Lemmih> Doesn't really matter once you've installed X, ghc and emacs on your windows box.
04:21:10 <shapr> musasabi: yay SerTH!
04:21:12 <Oejet> icewater: You are not a loser.  That's silly.
04:21:34 <icewater> is freebsd prety cool?
04:21:44 <icewater> paul graham of lispiness said he used it
04:21:49 <Oejet> shapr: When is the deadline for TMR2?
04:21:52 <shapr> icewater: We all start at the beginning.
04:22:14 <vegai> Lemmih: I find the Windows GUI very restrictive
04:22:14 <shapr> Oejet: have an outline to me by Thursday April 7th
04:22:15 <Itkovian> shapr: I heard you gave one of my students the grand tour ;-) (so boegel told me)
04:22:17 <vegai> and hard to work with
04:22:18 <skew> shapr: what will the next Obfuscated Haskell contest be called?
04:22:28 <shapr> skew: quick suggest something =)
04:22:35 <musasabi> shapr: nice if you like it :-)
04:22:38 <nmoore> skew: obshask?
04:22:46 <skew> Twice Succ Zero'th?
04:23:13 <skew> I figure unary doesn't scale that well
04:24:48 <nmoore> is the prelude different in hugs windows and linux, because my program using toLower works fine in windows but doesn't work in linux
04:25:01 <nmoore> toLower::Char->Char
04:25:29 <skew> I doubt that is the problem
04:25:41 <skew> describe the problem more
04:25:49 <nmoore> me?
04:25:56 <skew> yep
04:25:58 <musasabi> I think you have different versions of hugs - one automatically imports Char the other doesn't.
04:26:15 <nmoore> musasabi: i suspected as much, thanks
04:26:18 <Oejet> shapr: Any prefered submission format?
04:26:25 <TheHunter> toLower depends on the locale, iirc.
04:26:46 <skew> does anyone here understand the wxHaskell layout stuff?
04:27:06 <TheHunter> so if the locale is C, toLower probably doesn't know what to do with an "Ã„".
04:28:02 <earthy> probably
04:28:03 <nmoore> TheHunter: it's a naming problem not a logic problem, i should have explained that
04:28:50 <TheHunter> ah, ok
04:32:27 <ikegami--> hello
04:32:34 <skew> I have a panel with a huge outerSize laid out with floatCenter inside a scrolledWindow with a smaller outerSize, laid out with fill inside the frame
04:32:34 <basti_> hi ikegami--
04:32:57 <ikegami--> I'm trying to use the current hs-plugins on GHC 6.4
04:33:17 <skew> I want to be able to resize the window down to the smaller size, growing scroll bars as needed, but I can't shrink it past the larger size of the widget inside the scrolledwindow
04:34:00 <skew> ikegami--: how it that working? I heard something a while ago about needing the CVS version to work with 6.4
04:34:05 <ikegami--> but it does not work yet, and I met a dynamic error "Ix{Int}.index: Index (256) out of range ((0,17))"
04:34:23 <ikegami--> aha
04:34:34 <ikegami--> I didn't try the CVS head
04:34:40 <ikegami--> should try it
04:34:43 <basti_> 256 is a power of 2... that sounds a bit bizarre
04:35:59 <skew> Does anybody understand my wxHaskell problem?
04:36:37 <basti_> skew: i did wxWindows a few times, and I can see that there is a problem, but I can not offer any valuable help i think
04:38:02 <JaffaCake> ikegami--: sounds like you might have old interfaces lying around
04:38:13 <shapr> Oejet: hopefully I'll have the author wiki setup, in which case you won't have to ask me.
04:38:15 <basti_> skew: i remember there being "minimum" and "maximum" size hints in wx, which never served any useful purpose to me, and certainly did not do what their name might imply.
04:43:01 <Oejet> shapr: I hope it will look as good as the first issue.
04:43:49 <basti_> I will submit my article for issue #2. Promised.
04:45:28 <Oejet> basti_: Would you like to coorporate with me on proof reading and testing?
04:45:36 <basti_> sure thing.
04:46:31 <basti_> I'll have to get things in order, first... the move/heart attack of gf's dad left everything in a state of chaos
04:54:08 <basti_> Oejet: I'm offline for now though
04:58:48 <nlv11757_> "..Shall I be pure or impure.."
04:59:06 <musasabi> Why be dirty if you can be pure?
04:59:14 <Philippa> because dirty's more fun? ;-)
05:00:10 <musasabi> then one has to clean up yet again.
05:00:57 <Philippa> nah, wait 'til the morning then shower as usual...
05:02:57 <nlv11757_> functional programming is supposed to be two camps, I read here
05:02:58 <nlv11757_> :)
05:03:32 <nlv11757_> can one do without impurities?
05:04:23 <musasabi> Philippa: that only means that I have to do the laundry sooner.
05:04:25 <Oejet> nlv11757_: If you don't want to do any I/O.  :-P
05:04:33 * musasabi prefers coding haskell to laundry ;p
05:04:50 <musasabi> well depends whether we consider monadic code to be pure.
05:17:16 --- topic: '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]'
05:17:16 --- topic: set by shapr on [Sun Mar 06 12:29:48 2005]
05:30:59 <ikegami--> yay
05:31:27 <Lemmih> Hurrah.
05:40:46 <ikegami--> the CVS head of hs-plugins works with ghc 6.4
05:41:20 <ikegami--> I wish the new release will come soon :)
05:42:57 <Lemmih> The piece of code I've pasted at the HaskellIrcPastePage is optimal, right?
05:43:23 <nlv11757_> @whereis HaskellIrcPastePage :P
05:43:23 <lambdabot> Sorry, I don't know the command "whereis", try "lambdabot: @listcommands
05:43:32 <nlv11757_> @wiki HaskellIrcPastePage
05:43:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:44:56 <skew> Lemmih: that looks pretty good
05:45:26 <skew> you might want to try to divine from the core whether it is getting specialized and unboxed and so forth
05:46:07 <Lemmih> But it's not using a significant amount of CPU (:
05:46:26 <skew> then it doesn't matter how optimal it is
05:46:49 <skew> at least, the performance doesn't matter
05:47:34 <Lemmih> Optimal as in optimal throughput.
05:48:07 <Lemmih> I can't figure out why I'm limited to 2.5MB/s
05:48:39 <skew> it looks like it alternates between reading from the file and writing to the socket
05:48:47 * Philippa reckons it'd be nice to have a graphical tool for browsing Core against haskell source and seeing just how everything's translating after optimisation, inlining, specialisation and so forth
05:49:16 <skew> one or both of these operations are probably really fast, but explicit concurrency might help a bit
05:49:39 <Philippa> yeah, buffering good
05:51:50 <beschmi> hi
05:52:31 <Lemmih> I would like to use a fixed amount of memory.
05:52:50 <skew> You could use a bounded buffer
05:53:08 <skew> Have you written that code in C?
05:54:43 <skew> I think Haskell runs all IO in one thread
05:54:55 <skew> so there's little point playing around with concurrency
05:55:26 <skew> in Haskell with the standard IO library, that is
05:56:08 <skew> there's probably nothing to be gained - writing to a socket is almost certainly just pushing around memory
05:58:16 <Lemmih> Oh well. It doesn't really matter.
05:58:39 <Philippa> skew: not true. IO can still be asynchronous
05:58:46 <Philippa> and IO's what the code is blocking on
06:00:02 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
06:01:53 <Lemmih> D'oh. Suddenly rember that I uploaded a file from /network/ which is mounted with nfs (:
06:02:23 <Lemmih> The C++ client is exactly as slow.
06:03:16 <skew> Philippa: the call to write to the network card almost certainly just copies the data into some buffer and then asynchronously does the real IO later anyway
06:03:58 <musasabi> Lemmih: if you want to have a highperformance socket library you might want to look at network-alt ;)
06:04:05 <skew> so the only time to be saved there is the memcpy, I think
06:05:26 <Philippa> yeah, that's essentially what I'm suggesting though - you do that and the disk IO (which /is/ slow) simultaneously
06:05:43 <Philippa> oh, and odds are the network writes start to block after while when the relevant buffer's full too
06:05:59 <Lemmih> musasabi: Is there anything faster than hPutBuf?
06:06:23 <Lemmih> I'm getting 8MB/s on a non-nfs file, btw (:
06:07:09 <musasabi> Lemmih: if you are interested in server performance - then yes.
06:07:25 <skew> Philippa: I don't think <wait for disk><memcpy><wait for disk> is much slower than blocking all the time on the disk
06:08:11 <skew> especially considering that with sequential reads the operating system has an easy time getting the buffering right
06:09:46 <Philippa> I'm running windows, it's generally best to assume the OS thinks buffering is spelt with two gs ;-)
06:10:29 <Lemmih> haha
06:11:18 <skew> I spend last summer trying to improve the IO performance of a windows program
06:11:52 <skew> In the end, just calling open on all the files took something like 90% of the time
06:13:23 <musasabi> Performance on windows is a black art.
06:14:04 <skew> I just finished writing a little binary clock with wxHaskell
06:14:13 <Lemmih> Yay. It now outstrips Valknut (written in C++) by a factor of two (:
06:14:26 <Philippa> heh
06:14:28 <Philippa> what'd you change?
06:15:37 <Lemmih> Stopped reading files from another server (mounted with nfs so I didn't realize it at first).
06:16:47 <Oejet> Lemmih: Does Valknut have the same functionality?
06:18:07 <Lemmih> Oejet: We're talking about uploading a file here. Another client send you a filepath + offset and then you respond with the contents. Not much room for advanced features (:
06:18:49 <Oejet> Lemmih: Ah, I was thinking about error handling and such.
06:20:08 <Lemmih> hPutBuf should throw an exception if the handle is closed, right?
06:20:38 <Oejet> Don't know.
06:24:24 <Lemmih> Valknut supports bandwidth limitation. That's probably a slowdown even when disabled.
06:28:22 <skew> I've always thought it was a bit lame to just code hours/minutes/seconds independently in binary, so I just give seconds since the epoch :)
08:00:37 <wilx> Hmm, how long does it take before there is x.y.1 release after x.y.0 release?
08:01:16 <wilx> GHC.
08:01:26 <musasabi> Are you meaning a 6.4.1 after 6.4 ?
08:01:30 <wilx> Yup.
08:02:06 <desrt> wilx; if anyone tells you it will be out in august, don't believe them
08:02:20 <wilx> :)
08:02:58 <musasabi> wilx: history seems suggest 3-4 months between x.y and x.y.1
08:03:13 <wilx> Hm...
08:03:29 <wilx> I guess I will have to learn to bootstrap it myself then.
08:03:39 <musasabi> wilx: what os/platform?
08:03:43 <wilx> Windows.
08:03:55 <musasabi> ick
08:03:56 <desrt> O_o
08:04:03 <desrt> don't the windows binaries on the site work?
08:04:33 <wilx> They do. But there is a bug that has been fixed on 6.4 branch that I'd like to have.
08:04:36 <musasabi> http://haskell.org/ghc/dist/stable/dist/
08:04:46 <desrt> wilx; so don't bootstrap
08:04:47 <musasabi> wait.
08:04:48 <wilx> Windows apps crash with -p.
08:04:54 <desrt> use 6.4 to compile cvs stable
08:05:02 <wilx> Oh, I see...
08:05:06 <musasabi> windows snapshow are not built.
08:05:11 <desrt> or if 6.4 is crashing, use 6.2.2 to build it
08:05:24 <musasabi> yes that should work fine, but you may need to have cygwin
08:05:26 <wilx> Well, I am used to bootstrapping GCC so I thought that GHC does the same.
08:05:43 <desrt> bootstrapping ghc is an interesting process that is best not done more than once :)
08:06:08 * desrt is the master of unrequired bootstraps :)
08:06:26 <wilx> I mean, building GHC with host compiler, then build GHC again with stage1 compiler, and then again and compare results etc.
08:06:42 <desrt> no.  it's not really like that
08:06:50 <desrt> since windows doesn't come with a "host" haskell compiler
08:06:56 <wilx> Well, that is what GCC does. I assumed...
08:07:00 <musasabi> desrt: any pointers how to bootstrap on solaris or tru64nix ?
08:07:07 <desrt> musasabi; use hc.
08:07:23 <wilx> desrt, I already have the 6.4.
08:07:25 <wilx> Binary.
08:07:32 <musasabi> desrt: is there hc for 6.4?
08:07:36 <desrt> wilx; oh.  it's not called bootstrapping then
08:07:41 <wilx> It is :)
08:07:41 <desrt> wilx; it's just compiling, straight up
08:07:44 <desrt> no
08:07:51 <desrt> bootstrapping is doing the initial port to the platform
08:07:54 <desrt> and it's a lot more work
08:08:13 <wilx> Hmm, GCC and GHC terminoloy seems to differ then :)
08:08:23 <desrt> not really
08:08:26 <kosmikus> no, I think desrt is right
08:08:33 <desrt> in both cases you're creating a compiler out of a C compiler and nothing else
08:08:42 <wilx> Nope.
08:08:53 <wilx> GCC bootstrap process has at least three stages.
08:09:04 <wilx> Each uses different compiler binary.
08:09:37 <wilx> It is not plain "run make that compiles all .c files into gcc binary."
08:09:40 <desrt> i understand how gcc works.  i'm just saying ghc is different
08:10:02 <wilx> 'k
08:10:04 <wilx> So...
08:10:15 <desrt> so you don't need to worry about it :)
08:10:28 <desrt> just do the ./configure; make (assuming it's the same on windows)
08:11:04 * humasect uses ghc --make
08:11:30 <kosmikus> to compile ghc itself?
08:11:40 <humasect> ~_~ nope.
08:12:30 <desrt> wilx; ghc will do a multi-stage boot so you don't have to worry about the old compiler producing bad code
08:12:39 <desrt> since the final compiler will, essentially, have compiled itself
08:22:39 <wilx> Hmm, do I need Happy and Alex or is it part of the tree I am checking out?
08:22:46 <desrt> part of the tree
08:23:05 <wilx> Cool.
08:23:08 <desrt> when you do the checkout you need to checkout fpconfig
08:23:22 <desrt> then from inside the fptools directory, checkout: alex happy ghc libraries hslibs
08:24:11 <desrt> i'm not sure if you really need hslibs anymore or not, but it doesn't hurt :)
08:49:29 <basti_> hi
08:49:31 <Lemmih> Hey
08:50:57 <basti_> numa numa
08:51:50 <Oejet> Manamanam dub dubi duu.
08:53:41 <basti_> Oejet: so what about your article? :)
09:02:42 <boegel> @seen samc
09:02:42 <lambdabot> I haven't seen samc
09:02:48 <boegel> yes you have ! liar !
09:10:14 <musasabi> Ja nythän
09:10:17 <musasabi> sorry.
09:16:08 <boegel> musasabi: np ;)
09:22:22 <wilx> Wheee.
09:22:27 <musasabi> Anyone tested SerTH ? I would like to have some feedback before announcing to the mailing lists...
09:22:28 <wilx> Configuring...
09:22:35 <wilx> SetTH?
09:24:06 <wilx> Errm, SerTH?
09:26:53 <musasabi> Binary Serialization via template-haskell.
09:27:06 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/SerTH
09:39:07 <gzl> are there any wikis written in haskell?
09:41:02 <stepcutHM> gzl: probably :p
09:43:13 <wilx> So.
09:43:38 <wilx> How long does it take to do make in GHC on Athlon 1.2? :)
09:43:45 <gzl> ah, here we go.
09:49:23 <Oejet> wilx: 5-8 hours I would guess.
09:52:13 <Lunar^> musasabi: waow
09:52:27 <Lunar^> gzl: wiwiwi at least
09:52:59 <chucky> wilx: depends a lot on how much memory you have
09:53:34 <chucky> I had an Athlon 1.2 with 256 megs of memory, that took a LONG time to make ghc with, since it hit swap pretty hard when linking
09:54:20 <smott> can i ask ghc related questions here?
09:54:32 <musasabi> smott: yes.
09:54:40 <musasabi> Lunar^: nice if you like it :-)
09:55:26 <smott> when building ghc-6.4 i'm getting the error: /usr/bin/ar: GHC/Word_split/Word__537.o: Memory exhausted. I have 384mb ram so i don't quite see how this can be a problem..
09:56:55 <Lunar^> musasabi: I would be interested in trying to make an HaskellFS by using this and HFuse
09:57:07 <wilx> Hmm, 512 but I am using it...
09:57:40 <musasabi> smott: Is it possible that your OS has a limit on how much memory a process may consume - the other easy solution is just to add a swapfile.
09:58:40 <musasabi> Lunar^: Sounds nice, tell me if you need any specific features.
09:58:40 <smott> i remember building 6.2 and some snapshots fine on a machine with 256mb, has lots changed in 6.4?
09:59:39 <musasabi> Currently I have LZF compression that can be added on top of that (very very fast, constant memory, no external dependencies), but I am still trying to figure the right place for that module.
10:18:58 <wilx> I have LZW compression.
10:19:02 <wilx> Very very slow :D
10:46:58 <_metaperl> bind for monads ~= . for normal functions... one difference is the order of chaining. f $ g $ h data versus data >>= f >>= g >>= h
10:49:46 <TheHunter> `Â»=' is the monadic version of reverse application, `=<<' is like application, i.e `$' but left associative.
11:13:22 <Ruller> Hello, my friends!
11:16:20 <musasabi> good evening
11:18:58 <wilx> Hmm, my make bootstrap3 died.
11:19:33 <wilx> Linker.c:2195: error: label at end of compound statement
11:19:46 <musasabi> wilx: is that windows?
11:19:52 <wilx> Yup.
11:19:58 <musasabi> wilx: I remember that talked about.
11:20:10 <musasabi> let me grep my inbox for the ml.
11:22:56 <musasabi> found it.
11:23:32 <musasabi> 'Without semicolon after "foundit:" at least mingw32-gcc raises "error: label at end of compound statement".' revision 1.180     +1 -1      fptools/ghc/rts/Linker.c
11:23:48 <musasabi> I think that is merged back to the 6.4 tree.
11:23:56 <wilx> Hm, I've added ;.
11:23:58 <musasabi> (that was committed on 15.3.)
11:24:02 <wilx> hmm.
11:24:24 <wilx> I've checked out with ghc-6_4-branch...shouldn't be there?
11:25:58 <wilx> Err, my Engrish, I meant "shouldn't it be there."?
11:26:25 <Philippa> though "should be there?" would work too
11:26:46 <Philippa> English is surprisingly amenable to creative bastardisation :-)
11:27:22 <wilx> Heh.
12:20:56 <am02> I'm currently porting some old hugs code to ghc-6.0.1, I've written some .hi-boot files as there are mutually recursive modules but can't derive instances. Is there any way around this?
12:21:26 <_JusSx__> ll
12:21:33 <_JusSx__> haskell?
12:21:59 <autrijus> am02: 6.4 is supposedly better.
12:22:07 <autrijus> am02: see ghc 6.4 release notes about mut recurs modules
12:22:13 <musasabi> am02: you cannot derive instances with .hi-boot files.
12:22:30 <humasect> yep, 6.4 uses .hs-boot
12:22:39 <musasabi> am02: 6.4 has hs-boot which is better (but don't know the details)
12:23:12 <am02> ah can't use 6.4 unfortunately. Need Real Time GC which is being targeted at 6.0.1
12:26:57 <musasabi> Is that open source?
12:30:56 <am02> Not sure,I think it will be when it's finished, it's a phd project.
12:34:19 <wilx> musasabi, does your serialization allow IO with bit granularity?
12:35:08 <wilx> Like putting two bits into output stream and then later more bits...?
12:35:22 <musasabi> wilx: nope, that is not very performance friendly.
12:35:56 <wilx> Yeah, well, I thought I could use it for the LZW :)
12:36:02 <wilx> I need someting like that.
12:36:39 <musasabi> wilx: I think it is better in serialization to output byte based representation and then use a compression layer.
12:38:19 <wilx> Hmm, like constructing [(code, bitwidth)] and than have later pass fold it into byte stream...?
12:38:22 <wilx> Hm...
12:40:01 <musasabi> well I only have a flat buffer that is poked.
12:45:33 <autrijus> Template Haskell saved the day :)
12:45:44 <basti_> again.
12:45:46 <autrijus> I stopped worrying and metaprogrammed a compiler in one sitting.
12:45:48 <autrijus> # http://use.perl.org/~autrijus/journal/23794
12:45:52 <Philippa> hehehe
12:45:59 <Philippa> yeah, BTDT :-)
12:46:06 <autrijus> :D
12:46:19 <autrijus> sure, lisp folks have been doing that for decades.
12:46:27 <autrijus> still feels very good the first time I actually did this though :)
12:46:35 <autrijus> instead of merely hearing about how nice it is.
12:46:44 * Philippa nods
12:46:54 <Philippa> remind me, did I pimp the idea at you myself?
12:47:14 <autrijus> no, someone else on perlmonk did
12:47:14 <Philippa> only I'm kinda fond of it, on account of how there's even a rather sane interpretation of what the compiler code looks like ("staging annotations")
12:47:17 <autrijus> citing the ocaml paper
12:47:21 <autrijus> s/paper/slides/
12:47:23 <Philippa> fair enough
12:47:34 <Philippa> I'm supposedly writing a little article for TMR about doing it
12:47:43 <autrijus> that'd be nice.
12:47:59 <Philippa> I've got most of it, but it needs a good intro and probably a few paragraphs rewritten
12:48:05 <Philippa> the latter it'll live without, admittedly
12:48:17 <basti_> Oejet proofread my article today
12:48:21 <autrijus> the ocaml link is http://www.venge.net/graydon/talks/mkc/html/index.html
12:48:26 <autrijus> the suggestion was http://perlmonks.org/index.pl?node_id=433234
12:48:59 <am02> anyone here ever played with FVision?
12:49:33 <basti_> autrijus: your blog entry is really cool.
12:50:06 <autrijus> thanks!
12:50:07 <autrijus> it has an rss feed and I'm committed to update it daily. :)
12:50:44 <basti_> is that perlmonks article to be taken literally?
12:50:51 <basti_> the questions
12:53:19 <Darius> "Would you be opposed to Pugs becoming /the/ Perl 6 compiler/interpreter?"
12:56:33 <Philippa> autrijus: http://www.flippac.org/Compiler.hs
12:57:02 <Philippa> I figure you can live without the Parser and AST modules, Main was just module Main where import Compiler; main = ($compile FILENAME) :-)
12:59:32 <autrijus> basti_: uh, yes. it was before TMR01 tho.
12:59:51 <Darius> Parsec's not a parser generator
13:00:15 <autrijus> Philippa: that's 6.2 API right?
13:00:25 <autrijus> I'm having a bit problem trying to make mine work on both 6.4 and 6.2.
13:00:26 <Philippa> right, not tried it in 6.4
13:02:46 <Philippa> the module names don't match - FFS!
13:04:10 <Darius> Song of Earendil
13:04:57 <Philippa> woo, I managed to make GHC crash!
13:06:32 <wilx> :)
13:06:37 <_JusSx__> lambdabot: where is source?
13:06:38 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:06:46 <_JusSx__> lambdabot: @listcommands
13:06:47 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
13:06:47 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
13:06:47 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
13:06:47 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
13:06:47 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
13:06:48 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
13:06:50 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
13:06:52 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
13:06:54 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
13:07:01 <_JusSx__> lambdabot: wiki
13:07:02 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:07:06 <_JusSx__> lambdabot: @wiki
13:07:07 <lambdabot> http://www.haskell.org/hawiki/
13:07:17 <_JusSx__> lambdabot: @eval
13:07:18 <lambdabot> (line 1, column 1):
13:07:18 <lambdabot> unexpected end of input
13:07:18 <lambdabot> expecting white space or simple term
13:07:22 <_JusSx__> lambdabot: @eval 2+2
13:07:23 <lambdabot> 4
13:07:27 <_JusSx__> humm
13:07:38 <wilx> lambdabot, yow!
13:07:42 <_JusSx__> lambdabot: @quit
13:07:42 <lambdabot> not enough privileges
13:07:46 <_JusSx__> lambdabot: @lol
13:07:47 <lambdabot> Sorry, I don't know the command "lol", try "lambdabot: @listcommands"
13:07:48 <wilx> lambdabot: yow
13:07:48 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:07:53 <_JusSx__> lambdabot: @index
13:07:53 <wilx> lambdabot: @yow
13:07:53 <lambdabot> bzzt
13:07:53 <lambdabot> If you STAY in China, I'll give you 4,000 BUSHELS of "ATOMIC MOUSE"
13:07:53 <lambdabot>  pencil sharpeners!!
13:08:06 <musasabi> Philippa: what did you feed it? (=ghc)
13:08:09 <_JusSx__> lambdabot: @ne
13:08:10 <lambdabot> Sorry, I don't know the command "ne", try "lambdabot: @listcommands"
13:08:13 <_JusSx__> lambdabot: @me
13:08:14 <lambdabot> Sorry, I don't know the command "me", try "lambdabot: @listcommands"
13:08:25 <_JusSx__> lambdabot: @fortune
13:08:26 <lambdabot> This fortune is dedicated to your mother, without whose invaluable assistance
13:08:26 <lambdabot> last night would never have been possible.
13:08:36 <_JusSx__> ok
13:08:39 <_JusSx__> too funny
13:12:17 <Philippa> musasabi: a slightly modified version of the compiler I wrote for my Impure Thoughts article for TMR (worked on 6.2.2)
13:19:17 <Philippa> musasabi: the code I showed Autrijus, only with a couple of minor changes to make it get past the type checker
13:19:29 <Philippa> (qIO -> runIO, accounting for Name not being String any more)
13:21:20 <musasabi> I am not too familiar with 6.4 TH :-(
13:23:26 <Oejet> Philippa: I peeked into Compiler.hs and it's a lot shorter that I expected, so my curiosity is poked.  Is [|  $(foo) |]  a macro evaluating foo() at compile time and substituting in the AST/core/value?
13:27:27 <Philippa> anything inside [| |] is quoted code to be manipulated at compile time, a $foo inside there would evaluate $foo within the quotation (or at least did in 6.2.2)
13:28:17 <Philippa> $foo evaluates foo at compile-time and splices it in anyway, using it inside the [| |] brackets is so I can do the usual recursive evaluation thing as if I were writing an interpeter
13:28:28 <Philippa> I like to think of [| |] and $ as staging annotations in that sense
13:29:34 <Philippa> the language it compiles isn't overly complex btw - it's basically a series of statements that either assign arithmetic results to variables or print results
13:30:16 <Philippa> [Statement] where Statement = Print Expr | Assign Var Expr and Expr's your typical expressions with +-*/, constants and variables kinda lang
13:32:52 <autrijus> Philippa: just fyi, I had both 6.4 and 6.2 working now.
13:33:08 <Philippa> cool
13:33:25 <autrijus> # http://svn.openfoundry.org/pugs/src/Internals/TH.hs  -- the trick
13:33:30 <autrijus> zzz &
13:33:48 <Philippa> I was about to ask how dirty you had to get :-)
13:33:49 <wilx> Man, the GHC is still bootstrapping...
13:34:01 <autrijus> very not dirty.
13:34:30 <Philippa> I consider cpp to be dirty :-)
13:34:57 * autrijus shrugs :)
13:35:39 <Philippa> though in the end my compiler sorta uses it to specify what file to compile...
13:38:29 <Oejet> Philippa: Are you writing about TH for TMR2?
13:39:41 <Philippa> sort of
13:39:53 <Philippa> I was writing up how to use it to do quick'n'dirty compilers
13:40:05 <Philippa> and it was intended for TMR1 and might make TMR3 at this rate
13:40:42 <Oejet> Philippa: Great, I'm looking forward to it; I'd really like to read it.
13:43:28 <Philippa> basically it goes "here's us doing a little compile-time IO, here's a somewhat twisted 'staged evaluator', the rest's fairly traditional"
13:45:57 <Oejet> Philippa: Ah, qIO does compile time IO like reading a file.
13:47:44 <Philippa> bingo
13:47:50 <Philippa> only it's called runIO in GHC6.4
13:48:42 <Oejet> Maybe this can be used for partial evaluation.  Feeding some input at compile time and letting the optimize the partially evaluated program.
13:49:09 <Philippa> perhaps
13:49:31 <Oejet> Hm, Common Lisp doesn't have IO in it's macro expansion does it?
13:49:36 <Philippa> not AFAIK
13:49:43 <Darius> It has the full power of the language.
13:49:47 <Darius> As does TH.
13:49:50 <Philippa> fair enough
13:50:12 <Philippa> I'm guessing restricting them to no IO is something only the saner lisps do? ;-)
13:50:19 <Darius> What TH is lacking that CL has is the ability to write macro-writing macros.
13:50:46 <Darius> Philippa: There's no way to do that if you allow "procedural" macros.
13:51:16 <Oejet> Darius: Could you give an example of a CL macro doing IO on expansion?
13:51:36 <Darius> (defmacro foo (a b) (read))
13:51:49 <Philippa> Darius: I thought you could use TH to generate a function which is then used in a subsequent stage to generate code?
13:51:58 <Philippa> or do you mean something else?
13:56:10 <Darius> Well, you can't use TH to make a macro that uses splicing, but I guess you could expand the splicing manually assuming it all has a "function" counterpart.
13:57:10 <musasabi> btw is the new name quoting syntax broken? 'name seems quite problematic for names like a'
13:58:04 <Darius> It parses as a char presumably.
14:00:54 <Darius> Philippa: Thinking about it (though I have a feeling I may need to think more), it seems less of an issue in TH as TH "macros" are simply functions executed at compile time with quoting explicit.
14:02:05 <skew> Darius: I'm pretty sure TH macros can be used in the definition of other TH macors
14:02:36 <Darius> skew: That wasn't the issue.
14:04:12 <skew> oh, you are just talking about exposing the splice synatx somehow
14:04:46 <skew> for that matter, TH can't quite represent all the GHC extensions yet
14:04:47 <Philippa> yeah, certainly you can pass a 'macro' another 'macro'
14:05:24 <Philippa> it's all in a monad, so you've got all the usual higher-order trickery
14:06:04 <skew> not just that, I mean use  $() splice and one macro to generate code of a function that will later be used as a macro. That's whay macro-writing-macro suggests to be
14:06:07 <skew> to me
14:06:43 <Philippa> to me it means a macro that generates a macro. Perfectly doable, it just needs to be in another module atm due to GHC restrictions
14:06:50 <skew> The annoyance is the restriction that splices can only refer to things in other modules
14:13:54 <Darius> It seems to mostly a non-issue versus CL because Haskell "macros" are normal functions that execute at compile-time, CL macros are "call-by-text" functions.  Since a TH macro can obviously generate a function, it can generate a TH "macro".  The "cost" is that splicing and quoting must be explicit in TH.
14:14:40 <djo> hello
14:14:56 <djo> how can I set a value of an array cell ?
14:15:06 <Darius> djo: Depends on the array.
14:15:11 <djo> I found "!" which give the value
14:15:34 <djo> its Array Int String
14:15:39 <Darius> @type Data.Array.(//)
14:15:40 <lambdabot> bzzt
14:15:44 <Darius> @type Data.Array.(\\)
14:15:46 <lambdabot> bzzt
14:15:52 <Darius> @type (Data.Array.//)
14:15:54 <lambdabot> (Data.Array.//) :: forall e i.
14:15:54 <lambdabot> 		   (GHC.Arr.Ix i) =>
14:15:54 <lambdabot> 		   GHC.Arr.Array i e -> [(i, e)] -> GHC.Arr.Array i e
14:16:15 <Darius> But note that Array is an -immutable- array, so that function -copies- it.
14:16:33 <Darius> And is therefore pretty inefficient
14:17:32 <Philippa> <Darius> The "cost" is that splicing and quoting must be explicit in TH. <- I'm not sure I consider it much of a cost unless you want to use TH to add syntactic sugar
14:18:16 <Philippa> certainly it feels rather nice in the compiler example I posted, you can tell what's done statically and what's dynamic which is good
14:18:47 <skew> some sort of quoting and splicing is necessary if the compiler is supposed to generate fresh names auotmatically
14:19:29 <Darius> I'm actually torn on the issue.
14:19:36 <skew> Also, I think the quoting brackets can be necessary to work with Haskell syntax
14:19:38 <Darius> Also I put "cost" in quotes for a reason.
14:20:03 <basti_> humna
14:20:07 <basti_> law + order with gf
14:20:31 <Darius> The issue I'm worried about is having macros that can make arbitrary changes looking like pure code.
14:21:15 <skew> The explicit splices could be dropped if some magic type was recognized as "splice the result here before continuing to compile". I'm not sure that's a good thing.
14:21:34 <Darius> On the other hand, not distinguishing is a bit of implementation hiding.  Whether something is a macro or not is irrelevant in some cases.  Also there's just the prettiness aspect.
14:21:56 <skew> yeah, but you can't map a macro over a list
14:23:39 <skew> All you really have to write is the '$' - you would be writing the parens anyways in lisp :)
14:23:56 <Darius> skew: And I have to quote the code.
14:24:22 <skew> yeah, but that's fairly unavoidable with Haskell syntax, though I guess () could be used there too.
14:24:45 <Darius> skew: Why?
14:24:46 <Philippa> how many cases are there where it's truly irrelevant whether it's a macro?
14:25:04 <Philippa> it seems to me they're all stuff like forcibly inlining parts of a HOF
14:25:24 <skew> Philippa: Hardly any I'd say, but ideally there are few cases where it matters if something is a macro or built-in syntax
14:25:33 <Darius> Philippa: Certainly any time it's being used for optimizations.  Simple ones like that or more complex transformations.
14:26:23 <skew> Darius: consider something like $(macro [[if a == c then 0 else f]] [[inc 12]])
14:26:56 <skew> this is also valid $(macro [[if a == c then 0 else f inc 1])
14:27:36 <Darius> skew: You'd treat it as a function, you wouldn't write func if a == c then 0 else f inc 12 if you didn't mean that.
14:28:52 <skew> treating it like a function would rule out using definitions (or someday patterns) as arguments
14:29:58 <skew> you probably can always leaave out the last brackets without ambiguity
14:30:25 <skew> Anyway, using a macro for optimiziation doesn't mean it acts like a function
14:31:22 <skew> you can't write let newthing = (my_fancy_macro, 12) ; fastfunctions = map (fst newthing) functions_to_be_optimized in ...
14:32:51 <skew> Personally, I the biggest thing I miss is being able to use TH to define relatively nice new syntax.
14:33:50 <skew> which ties in with somehow being able to recognize and quote the right bits of code
14:35:51 <skew> Maybe ogdl could help, or wo should make Haskell with parentheses
14:37:02 <Philippa> it /would/ be nice to have an extensible haskell parser that goes to the TH types
14:37:27 <skew> I should look at the SyntaxMacros stuff again. I never got it to build the first time around, IIRC
14:37:59 <skew> I don't think we want to write our own parser, at least not all the time
14:38:37 <Darius> Why would you make "Haskell with parentheses"?
14:39:14 <skew> To make syntax definition and implicit quoting and all that as easy as in lisp
14:39:39 <Philippa> why not just write a type-checker for lisp? ;-)
14:39:42 <Darius> If you are writing a "Haskell with parentheses" parser, why not just write a parser for the language you want?
14:40:18 <Philippa> he might want a language with vastly similar semantics
14:40:54 <skew> I mean alternative syntax for Haskell so that macros can blend in and look like native syntax
14:43:37 <Oejet> skew: Like "if then else" and "case of"?
14:43:50 <skew> yes
14:44:18 <Darius> skew: That doesn't seem like it would get you any closer to extensible Haskell parser it would just make a simple "style-guide" for extensions.
14:45:23 <Darius> Also, what is the difficulty with "syntax definition" and "implicit quoting" now?  The compiler certainly knows what the subexpressions of an expression are, and the former just looks ugly and different.
14:45:37 <skew> well, macros seem to get along well enough in lispy languages. They look like syntax extensions to me
14:46:03 <Darius> They only change the abstract syntax.
14:46:16 <Darius> (so to speak)
14:47:13 <metaperl_> @type (++)
14:47:15 <lambdabot> (++) :: forall a. [a] -> [a] -> [a]
14:47:15 <skew> Darius: A major reason for extending the syntax is that you can handle things that were parse errors before. For example, if you are just thinking about subexpressions you are fine. If you want to have a binding growp in the arguments to your macro, or implement the arrow syntax as a macro, that isn't just recognizing subexpressions anymore
14:47:53 * SamB notices that the definitions of unsafePerformIO and unsafeInterleaveIO both involve throwing out the world
14:48:01 <Philippa> skew: see my comment about an extensible haskell syntax -> TH parser
14:48:12 <Philippa> SamB: they're both compiler hacks :-)
14:48:13 <Darius> The former can be done uglily now, the latter would require an extensible parser for the -concrete- syntax which wouldn't come immediately from "Haskell with parens"
14:48:26 <Philippa> as such, they don't need to work on a "pure functional" level
14:48:32 <SamB> Philippa: I'm aware
14:48:48 <SamB> they aren't *supposed* to be pure
14:49:06 <Philippa> well no, but you can view the IO monad as still being pure for example
14:49:15 <dons> hmm. you could check out the ghc-pluggable branch, and drop in your own haskell parser plugin
14:49:29 <Philippa> thing is, by being impure they inherantly do something screwy with the world value the IO monad's threading
14:49:55 <skew> Philippa: Darius yes, but consider something like cond. The arrow notation doesn't come immediately from the parentheses, but the parentheses do provide most of the tree structure of the AST
14:49:55 <Philippa> that reminds me: is GHC6.4 sufficient to get hs-plugins working under windows?
14:50:14 <dons> getting very close - i'm killing of posix deps this week, most are now gone
14:50:30 <SamB> it just seems rather appropriate that the implementations involve throwing out the world ;-)
14:50:34 <dons> then there's only the / or \ separator issue
14:50:55 <dons> which I will tackles as ghc does, by preprocessing windows paths on input and again on output
14:51:11 <Darius> skew: What's your point about "it provides most of the tree structure of the AST", either your arrow syntax looks Lispy or it doesn't.
14:51:18 <dons> so hopefully soon, Philippa. then you  can test  it! (I  don't have a win box to test on)
14:51:48 <dons> System.Process solved the only really difficult portability problem
14:51:53 <Darius> If it looks Lispy it can just as well look (Template) Haskelly.
14:52:22 <Philippa> cool, I'll look forward to it
14:52:30 <Philippa> doubly so as Shapr and I have a potential project in mind
14:52:35 <Philippa> JOOI, does hs-plugins do TH?
14:52:51 <dons> does it do TH - in what sense?
14:53:14 <dons> there are weird people who've written plugins that use TH
14:53:41 <Darius> It just calls the compiler, no?  So it has all the power of the implementation.
14:54:21 * pesco falls over into bed.
14:54:41 <dons> TH+hs-plugins is scary I reckon: runtime metaprogramming via plugins, with a runtime-staged compile-time metaprogram
14:54:54 <skew> Darius: it's the difference between adding one generic parser, for parens or something equally general like ogdl, or adding a hook for everybody to add their own synatx to the Haskell grammar
14:55:36 <skew> the first gets you pretty far, and the second is nearly impossible as long as GHC keeps using happy (I suppose they could use hs-plugins)
14:55:38 <Darius> skew: True, but Lispy syntax is not needed.  The issue is whether you are changing the concrete syntax or not.  If you aren't then you just need a "macro" facility.
14:55:57 <dons> skew: that's what the ghc pluggable branch is for!
14:56:01 <skew> How do you make the distinction?
14:56:15 <Darius> skew: Whether it will parse or not.
14:56:51 <skew> dons: I mean I think it's a bit strange to go running new parsers through happy and linking against them as compilation proceeds and you find out about new syntax
14:57:25 <Philippa> that's not what dons is suggesting
14:57:29 <dons> oh, you wouldn't run them through happy, would you? you'd have precompiled parser plugins that you load with an OPTIONS pragma
14:57:35 <Philippa> yep
14:57:50 <Philippa> sort of like the parsing extensions in the darcs version of Flippi, only more thoroughly developed
14:57:57 <skew> Darius: I see. You are thinking that lisp macros only transform things that are already valid lisp synatx, lisp syntax being pretty free.
14:58:03 <dons> OPTIONS_PLUGINS -plugin haskell98+foo
14:58:31 <skew> Darius: I am thinking that lisp macros give you things that look exactly like new syntax
14:59:43 <skew> So you seem to think the natural generalization to Haskll is a system for transforming already-valid code, while I'm thiking that the appropriate analogy is to a system that wouild enable you to make stuff that looks like new syntax
15:00:12 <Darius> skew: No, you are suggesting to make -all- syntax look the same, so that new syntax looks like old syntax.
15:00:30 <skew> That's the next step after my basic conception
15:00:36 <Darius> skew: That's fine, but not particularly challenging or interesting.
15:01:10 <Darius> And my point is, if you count Template Haskell syntax as Template Haskell syntax, additions look like old syntax just ugly.
15:01:19 <SamB> Lisp already has that
15:27:49 <skew> I think macros are not so interesting for their semantic in Haskell, but more for performance and providing nicer syntax
15:30:45 <astrolabe> Is there anything on the web that explains the connection between category theory monads and haskell monads?
15:30:58 <Darius> Moggi's paper.
15:31:28 <skew> astrolabe: they are really pretty much the same thing
15:31:49 <Darius> Actually, Haskell monads are "strong monads with a mono 'return'"
15:31:57 <Darius> (or rather, Moggi's)
15:32:33 <astrolabe> Thanks.  I'll try googleing moggi.
15:32:46 <Darius> I think the title is "Notions of Computation"
15:32:56 <skew> Right, return should be mono.
15:33:12 <Darius> astrolabe: But you need to understand category theory speak reasonably well
15:33:22 <skew> Except I think that parametricity forces that in Haskell anyways
15:33:22 <gzl> also I think Wadler has stuff on it
15:33:30 <Darius> skew: Actually, there is a Haskell monad where return isn't a mono.
15:33:40 <gzl> and I've heard Wadler's stuff is more readable than Moggi's
15:33:45 <skew> Wadler has very good papers on monads in Haskell
15:33:49 <astrolabe> I used to know a bit of category theory.
15:34:04 <Darius> gzl: Wadler's is more geared toward the practice rather than the category theory aspects.
15:34:35 <skew> Darius: well, there are trivial cases like data M a = M () where 'a' doesn't show up at all, and there's always undefined
15:34:49 <Darius> skew: That's it.
15:35:03 <gzl> Darius: ok.
15:35:12 <astrolabe> Found it. http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf .  Thanks guys
15:35:18 <Darius> I believe (ignoring undefined) that that is the only one (up to isomorphism)
15:35:51 <skew> I suppose I should say that as long as the 'a' in the monad type shows up in covarient position in the definition of the type, then return either builds undefined or is mono - probably
15:38:59 <wagle> doesnt -fglasgow-exts turn on overlapping instances in ghc?
15:40:33 <TheHunter> no, overlapping instances are too nasty to be turned on by -fglasgow-exts.
15:40:52 <wagle> noooOOooooOoooOooooo
15:41:01 <wagle> so how do you turn them on?  8)
15:41:13 <TheHunter> -fallow-undecidable-instances
15:41:32 <stepcut> don't you mean, -fallow-overlapping-instances ?
15:41:47 <TheHunter> well, obviously ;)
15:43:11 <wagle> well, i've got a round tuiy to check out Philippa's assertion that, unlike hugs, ghc is conservative about the overlapping it allows..  so allowing "undecidable-instances" probably wont be what she was talking about
15:43:19 <wagle> s/tuiy/tuit/
15:44:25 <skew> what is a round tuit?
15:45:03 <wagle> you know..  sometimes you cant do something until you get around to it?
15:47:05 <skew> Oh, it swhen u finally do some thing.
15:47:26 <humasect> htoolkit =(
15:47:32 <wagle> around to it ~> a round tuit
15:47:51 <skew> What if I want a square tuit?
15:48:14 <skew> It sounded like you had a bet for a "round tuit" with Phillipa
15:48:31 <wagle> you cut a disk out of a piece of cardboard, write "tuit" on both sides, and hand it to people who say they will do something when they get around to it
15:48:50 <skew> that's a good idea
15:48:56 <humasect> is nothing current using ObjectIO?
15:50:48 <redhatPT> hi there
15:51:00 <redhatPT> were is the page with the irc code?
15:51:17 <redhatPT> or better the code that we cant post on the channel
15:51:18 <TheHunter> @wiki HaskellIrcPastePage
15:51:18 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:51:21 <redhatPT> thx
15:52:21 <wagle> two years ago, i was farting around with using Liang's overlapping Subtype class to try to get subtyping of as particular kind..  to my chagrin and disappointment, i discovered that the typechecking didnt occur until run-time..  philippa mentioned maybe a week or so ago that ghc was more conservative about the overlapping instances it allowed..  now i've trying to remember what all I was trying to do with the code i just unearthed
15:53:43 <skew> What sort of subtyping are you trying to get?
15:54:20 <TheHunter> typechecking at runtime? i don't believe that.
15:54:37 <wagle> subtype typechecking at runtime
15:54:43 <skew> I think oleg knows everything about typeclasses.
15:55:01 <TheHunter> ah, i see.
15:56:17 <wagle> the Subtype class that Liang uses in his monad transformers papers does the subtype type checking at run-time
15:56:37 <skew> okay.
15:57:22 <wagle> i what compile time subtype checking, so ...
15:57:38 <wagle> i want compile time subtype checking, so ...
15:59:10 <wagle> basically, i think that the problem revolves around using pattern matching on
15:59:10 <wagle> ex1 = prj minute :: Time
15:59:23 <wagle> wrong paste
15:59:31 <wagle> ex1 = prj minute :: Time
15:59:35 <wagle> grrr
16:01:01 <wagle> .. pattern matching on a data structure (OR, sortof like Either) to decide which subtype is being used
16:01:41 <skew> are you sure oleg hasn't already written some typeclasses to do that?
16:02:59 <skew> Do you just want to be able to project from an OR type to a static type?
16:03:10 <skew> I could write that in a few minutes
16:04:09 <wagle> i have no idea what Oleg has done in this area..  what should i read?
16:04:53 <skew> the trick is recoding instances (Subtype a b) => (Subtype (OR a c) b) ; instance (Subtype a b) => (Subtypes (OR c a) b) as an explicit search, because the typechecker doesn't backtrack
16:04:59 <wagle> data OR a b = L a | R b deriving (Show, Eq, Ord)
16:05:04 <skew> which is really a shame because it's almost prolog...
16:05:36 <wagle> class SubType sub sup where
16:05:36 <wagle>     inj :: sub -> sup  -- injection
16:05:36 <wagle>     prj :: sup -> sub  -- projection
16:05:45 <wagle> instance SubType a (OR a b) where
16:05:51 <wagle> instance SubType a b => SubType a (OR c b) where
16:05:58 <wagle> ...
16:06:09 <skew> is that all you want?
16:06:22 <wagle> (thought i'd not spam the channel with the gorey details)
16:06:37 <wagle> skew: well, i'll start there
16:06:40 <skew> I don't know where to find oleg's stuff other than the haskell list archives, but he's done stuff like that
16:06:52 <wagle> keywords?
16:07:04 <skew> He helped me encode the Java inheritence system into Haskell type classes...
16:07:23 <skew> and your problem can be solved with some of the same ideas
16:07:53 <wagle> yeah, i was able to do a lot with subtypes in java
16:08:09 <Darius> wagle: His name is Oleg Kiselyov and he has a http://pobox.com/~oleg/ftp/
16:11:11 <wagle> what what would you do to the OR and Subtype gizmo's above?
16:14:00 <skew> what is prj supposed to do if the types don't agree?
16:14:10 <wagle> "stanamically balanced AVL trees"  heh
16:14:28 <wagle> skew: fail the type check
16:14:55 <wagle> where i got stuck:
16:14:56 <wagle> instance SubType a (OR a b) where
16:14:56 <wagle>     inj x = L x
16:14:56 <wagle>     prj (L x) = x
16:14:56 <wagle>     prj _ = error "prj1 failure!" -- Nothing
16:15:27 <wagle> (likewise for the other instance)
16:18:54 <skew> the instances you gave seem to work
16:19:26 <wagle> i want to get my subtype errors at "compile time"
16:19:39 <wagle> error doesnt get called until run-time
16:20:07 <skew> how do you want to decide at compile time?
16:20:36 <wagle> i dunno..  you said you could transform it
16:21:14 <skew> I don't think it would be easy to statically determine what type something really is starting from your code
16:21:43 <skew> What do you want to be able to write?
16:22:08 <wagle> ex1 = prj minute :: Time
16:22:08 <wagle> ex1' = prj minute :: Length
16:22:20 <wagle> ex1 should work
16:22:28 <wagle> ex1' should get type eerror
16:22:30 <bourbaki> moin
16:22:37 <skew> what type should minute have?
16:22:55 <wagle> minute  = inj (inj Minute :: Time)   :: Dimension
16:23:26 <skew> there's no way the type system can distinguish values with the same type, so something has to give
16:24:02 <wagle> i said i wanted subtypes
16:24:38 <wagle> i didnt claim i could get them in haskell..  though the trickery available in haskell makes one wonder
16:25:15 <skew> The thing is, if you have [Dimension] and some values are Time and some are not, then you can only tell at runtime
16:25:27 <wagle> i shoulod probably see what Hliss can do
16:25:57 <wagle> wow, that was mispelled
16:26:04 <skew> I think I get it
16:26:09 <wagle> i should probably see what Hlist can do
16:26:10 <skew> Your types are a bit off
16:26:25 <TheHunter> @wiki SimulatingDependentTypes
16:26:25 <lambdabot> http://www.haskell.org/hawiki/SimulatingDependentTypes
16:26:37 <skew> Writing some function taking Dimension won't give you what you want
16:26:54 <skew> A function polymorphic in a such that (SubType a Dimension) might
16:27:12 <skew> I mean, write the polymorphic bits like that
16:28:07 <wagle> mult :: ([Dimension],[Dimension]) -> ([Dimension],[Dimension]) -> ([Dimension],[Dimension])
16:29:04 <wagle> oops..  make that add, not mult
16:29:06 <skew> I don't understand that type
16:29:32 <wagle> restricted so that the Dimensions have to agree.
16:30:00 <wagle> inch/sec == ([inch],[sec])
16:30:02 <skew> You have hidden all the importnat information from the type system
16:30:32 <skew> I don't know of any subtyping system that can statically express that corresponding list positions must match
16:30:40 <skew> At least with uniformly typed lists like that
16:30:50 <wagle> they are sets, not lists
16:31:03 <skew> sets?
16:31:17 <wagle> inch sec = sec inch
16:32:01 <wagle> recall that this is a path i abandoned two years ago...
16:32:23 <wagle> but i still want to do dimensional analysis
16:33:24 <wagle> which means that units get attached to scalars, compatible units get converted, etc
16:33:49 <skew> I think your code is a pretty good start
16:34:12 <wagle> so if x == 2 sec, and y == 3 minutes, then i can add x + y, but i cant add 1 meter to x
16:34:24 <skew> Working with values of the supertype are a mistake if you want static safety
16:35:48 <wagle> but if z = 3 meter, then i should be able just say x * z or x / z
16:36:10 <wagle> and get the right dimensionally tagged type
16:36:37 <skew> I think the solution is to have types like Seconds Minutes Meters, etc
16:36:45 <skew> and then typeclasses that work with those
16:36:53 <wagle> this is all quite statically decidable..  dunno yet how to get haskell to do that for m
16:36:56 <wagle> me
16:37:31 <wagle> type Time   = OR Second (OR Minute (OR Hour ()))
16:37:31 <wagle> data Second = Second deriving (Show, Eq, Ord)
16:37:31 <wagle> data Minute = Minute deriving (Show, Eq, Ord)
16:37:31 <wagle> data Hour   = Hour   deriving (Show, Eq, Ord)
16:38:10 <skew> Your problem is that you seem set on injecting Second Minute and Hour into Time, where they are only distinguished by constructor, i.e. at runtime
16:38:11 <wagle> i dont remember if or what happened when i tried newtype instead
16:38:49 <skew> Pass around Second, Minute, Hour, and use subtype constraints on your function
16:40:00 <wagle> you know, initially i presented the problem statement, and avoided my previous attempt at an implemented.  you insisted on the details of my implementation -- WHICH I KNOW DOESNT WORK AND IS WRONG-HEADED -- and now here we are bogged down criticizing my broken implementation
16:40:33 <skew> no, I'm saying that your implementation probably can do what you want, you were just using it wrong
16:41:00 <skew> say we have orf f g (Left x) = Left (f x) ; orf f g (Right x) = Right (g x)
16:41:10 <wagle> can you point me at some reading?
16:41:22 <skew> let type Test = OR Char (OR Int Bool)
16:41:39 <wagle> (i have to go do my wash before the laundrymat closes)
16:42:01 <skew> then we can defined fiddle :: SubType a Test => a -> a by fiddle x = prj (orf toLower (orf negate not) (inj x :: Test))
16:42:22 <wagle> ("orf"?)
16:42:25 <skew> fiddle 'C' -> fiddle 'c', fiddle True -> False, fiddle "hello" is a type error
16:42:30 <skew> well, or is already taken
16:42:41 <wagle> ok
16:42:47 <skew> it's the action of the bifunctor on functions
16:43:45 <skew> Actually, why do you care about the specific unit of length used?
16:43:47 <wagle> no pointers to reading?
16:43:56 <skew> I don't know of any reading on this sort of typeclass hackery
16:44:02 <wagle> ok
16:44:03 <skew> HList probably has a paer
16:44:05 <TheHunter> @wiki DimensionalizedNumbers
16:44:06 <lambdabot> http://www.haskell.org/hawiki/DimensionalizedNumbers
16:44:22 <skew> but I don't know of anything specifically trying to teach typeclass hackery
16:44:27 <wagle> if you add inches to centimeters, one needs to be converted to the other
16:44:38 <skew> Anyway, why not pick a standard length and convert at the beginning?
16:44:46 <wagle> skew: i have the Hlist paper
16:45:15 <skew> I guess you would end up building ratio types
16:45:29 <wagle> million line module A uses inches.  million line module B uses meters.  they need to talk correctly to each other
16:45:44 <skew> but that's a question of handling type equality, rather than subtypin
16:46:07 <skew> well, A and B already need to use your library, right?
16:46:14 <wagle> i really gotta head off..  thanks
16:46:20 <skew> will you be back?
16:46:29 <wagle> surely
16:46:32 <skew> okay
16:47:10 <wagle> my irc client is persistant
16:49:41 <araujo> anybody using ghc6.4 here?
16:50:17 * Darius downloaded it and installed it, but hasn't really used it for anything major yet.
16:54:15 <araujo> Darius, did you 'make install-docs' ?
16:54:57 <Darius> I just downloaded the binary.
16:57:52 <fodbms> is there such a thing as a function oriented database maangement system?
16:58:00 <fodbms> FODBMS?
16:58:53 <neilc> what would it store?
16:59:51 <fodbms> processes
17:00:12 <neilc> you've lost me
17:00:36 <fodbms> well I dont know strings and numbers I guess and then functions and relations between them
17:00:47 <fodbms> a tool to store info
17:00:53 <fodbms> and do interactive apps
17:04:28 <fodbms> ok
17:04:36 <fodbms> I guess relational databases are the way to go
17:07:16 * araujo wonders what fodbms talks about
17:08:34 <fodbms> say I want to write a server side web application
17:08:53 <fodbms> and I have a celeron 2600 256ram running win xp and dsl
17:09:04 <fodbms> what is simplest way to create such an app
17:09:37 <Darius> It depends on what the app is supposed to do.
17:11:02 <fodbms> it is supposed to be an online store and a way for me to update the store,get accounting numbers, and provide email for my company and custoemr management
17:11:15 <fodbms> [eg everything]
17:11:17 <fodbms> :)
17:12:14 <ballofiron> is there any frameowrk for haskell to do this kind of thing?
17:12:58 <Darius> For the front parts you may want to look at WASH (Web Authoring System Haskell) and Halipeto.  There are various libraries to do XML and DB stuff as well.
17:14:45 <Darius> http://www.haskell.org/libraries/#xml
17:55:35 <ballofiron> this scares me
17:55:40 <ballofiron> stuff seems unfinished
17:55:42 <ballofiron> hmm
17:55:51 <ballofiron> gosh so hard to choose where to go to build web apps
18:01:40 <ballofiron> why do you guys  choose haskell?
18:01:55 <ballofiron> out of novelty ? grad student? app u want to build?
18:03:04 <skew> wagle: I've handled a fair bit of your problem with type classe
18:07:02 <skew> wagle: I'm just using functional dependencies to bind each type to it's category, the category being a standard representation type
18:07:41 <skew> wagle: then the addition operation requires that both arguments are associated with the same category
18:57:58 <Pseudonym> OK...
18:58:20 <Pseudonym> Does it work?
18:58:32 <Pseudonym> Sorry.
20:01:55 * SamB wonders how you would use quickcheck to test a parser
20:07:57 <Darius> Check the lexer(-like parsers) then make a random "token" stream and check the parser.
20:09:43 <Darius> CFG's can be used to generate as well as parse, so the remaining tricky part are the non-context-free aspects.
20:11:28 <Pseudonym> The problem with that is that it does not help at all to debug the grammar.
20:11:44 <Darius> Or maybe a pretty-printer and the property that parse . print === id
20:12:04 <Pseudonym> If the grammar is wrong, then using it to generate text to parse won't help.
20:14:20 <Darius> Indeed, but if the grammar is your specification... Comparing against other or simpler implementations might work, though QuickCheck is probably not appropriate for those.
20:14:47 <Darius> (well it should be for a simpler implementation)
20:19:17 * SamB thinks an ugly-printer might do a better job
20:20:43 <Darius> Pretty-printing usually aims at "like a human would write" which is likely your most important use-case.
20:20:55 <Darius> Unless this is an XML parser.
20:22:21 <SamB> well, actually, it occurs to me that there is plentifull Self code to test my parser on already...
20:23:24 <Darius> Yes, I was and would suggest that as a systems test.
20:23:48 <Darius> Not a good fit for QuickCheck though (but of course no one is holding a gun to your head saying you must only use QuickCheck)
20:23:56 * Darius assumes
20:24:00 <SamB> yeah.
20:24:08 <SamB> noone is making me write this at all
20:24:34 <Darius> So you going to make a killer RTS for it?
20:24:46 <SamB> killer? probably not.
20:24:59 <SamB> one that can be comprehended by mere mortals? I hope so.
20:26:02 <SamB> I'm not exactly expecting to write one in Haskell, but then again how should I know?
20:27:40 * Darius should have written a register allocator back when he was in to those kind of things; of course, it'd probably produce good code slowly rather than okay code quickly rendering it useless but...
20:28:29 <SamB> I honestly don't expect to do a JIT
20:31:01 <SamB> Its a good thing Jecel put somehing like the Self grammar in a comment in TinySelf, or I would be rather lost ;-)
20:33:13 <Darius> Isn't Self's syntax pretty simple?
20:33:37 <SamB> yes, but even so I don't think I would have known where to start
20:34:09 <SamB> and resends look like they could get ugly
20:35:39 <Darius> One annoying thing I found is that parens are used for grouping indirectly or at the semantic level almost.
20:37:08 <SamB> I haven't done that part yet
20:37:36 <SamB> and I don't remember how it is supposed to work
20:38:30 <Darius> Unless I'm mistaken, if you look at the syntax for object creation it conflicts with using parens for grouping, but if you go through the semantics the meaning works out to be the same.
20:39:16 <Mask> Hugs is telling me that I can't have a list of Arrays in my type definition... why not?
20:39:16 <SamB> this comment from TinySelf only seems to mention parens in the "method" production
20:39:54 <SamB> Mask: maybe you didn't give Array enough args?
20:40:27 <Mask> oh, yeah, thanks
20:42:20 * Darius tries to think up an unholy mixture of Prolog and Haskell syntax.
20:42:37 <SamB> Darius: what ARE you doing?
20:43:07 <SamB> hmm, that came out a bit wierd-looking
20:43:13 <dons> of course he's trying to take over the world, what else?
20:44:18 <Darius> It just for some psuedo-code of code that will be written in Haskell but using Prolog-y like features.  The pseudo-code is Prolog plus higher-order functions which doesn't really work.
20:44:37 <Pseudonym> It kinda works.
20:44:45 <Pseudonym> Most Prologs have higher-order calls.
20:44:54 <Pseudonym> Dunno if it's in the standard or not...
20:47:20 <Darius> Pseudonym: What would typical syntax be for mapping a production over a list collecting the results in a logic var?
20:48:19 <Pseudonym> Can't remember. :-)
20:48:29 <Pseudonym> I know how to do it in Mercury, but that doesn't help you.
20:48:39 <autrijus> greetings \folks.
20:50:07 * SamB wishes haskell-mode properly supported indentation for do blocks in parentheses
20:50:20 * Darius tried to write map using the reflective abilities of Prolog but stopped not because he couldn't figure out how, but because he was getting more and more scared.
20:51:18 <Lemmih_> Bah. I so don't get this Alex guy.
20:52:51 <Darius> Lemmih: That may be healthy.
20:53:22 <cm> his name is dangerously similar to Ajax
20:54:00 <SamB> cm: so don't eat him
20:54:45 <Pseudonym> Fair enough.  Prolog is scary when you try to do anything nontrivial.
20:55:36 <SamB> how did anyone manage to write a whole text editor in it, then?
20:55:48 <Pseudonym> Fail.
20:56:04 <SamB> huh?
20:56:13 <Pseudonym> That's the Prolog answer to any question.
20:56:26 <cm> what's the meaning of life? Fail.
20:57:30 <Darius> SamB: There's a text editor written in Prolog?
20:58:35 <dons> it's not a real language till someone's written a text editor in it ;)
20:58:58 <SamB> maybe its actually written in C, now that I look at it
20:59:27 <SamB> no, I think not...
20:59:34 <Darius> it's not a real language till someone's written an operating system in it
20:59:53 <dons> ah, true.
20:59:57 <SamB> swi_prolog seems to have something called "emacs" written in it.
21:00:10 <SamB> obviously not your usual emacs
21:01:01 * SamB notices the odd way he spelled SWI-Prolog
21:04:47 <Lemmih> Good morning, #haskell!
21:06:12 <autrijus> yo Lemmih.
21:06:33 <Darius> If by morning you mean beginning of the AM, Good Morning!
21:06:40 <Lemmih> autrijus: Feeling productive today?
21:07:11 <autrijus> just had some ritalin.
21:07:15 <autrijus> first time in my life
21:07:24 <autrijus> may or may not make me productive.
21:07:42 <Lemmih> You got ADD?
21:08:00 <Darius> I don't know, you seemed to be flying along on Pugs before.
21:08:26 <autrijus> yup.
21:09:24 <cm> how old are you (pardon the question)?
21:09:29 <autrijus> 23yr old
21:09:36 <autrijus> going to be 24 in a month
21:10:28 <cm> was the "yup" re ADD?
21:10:37 <autrijus> yes.
21:10:56 <cm> thx
21:11:03 <autrijus> np
21:11:28 * Lemmih is off for food.
21:31:54 * SamB notices that his parser parses just plain "*" as BinarySend SelfRef "*" SelfRef
21:32:13 * SamB tries it in the real thing, discovers it results in a parse error
21:32:33 * SamB decides to try it in tinySelf
21:33:12 <SamB> parse error there too. I better stop for tonight...
21:38:06 * SamB thinks about calling garbage collectors undertakers, since they take care of dead objects
21:40:26 <Darius> But they are recycled, dead people aren't.
21:40:38 <Darius> Well, technically...
21:40:55 <dons> hmm..
21:42:06 <hellish> Is there any performance hit to using arrays over lists?
21:42:52 <Darius> hellish: They have different performance characteristics, just as in any other language.
21:43:26 <SamB> Darius: any other language?
21:44:54 <Darius> SamB: Some languages (Python *cough* *cough*) call arrays lists and such chicanery, but a singly-linked list and an array have pretty well understood complexities.
21:45:26 <SamB> Hey, why not call an array a list?
21:45:55 <SamB> they are extensible arrays, after all.
21:46:14 <Darius> SamB: Because most people (by which I mean programmers) associate the term "list" with linked lists.
21:46:24 <Gahhh> yah
21:46:37 <Darius> cdring down a Python "list" would be a bad bad idea.
21:46:52 <SamB> true
21:47:02 <SamB> which is why python doesn't have cdr
21:47:03 <Gahhh> what makes python lists arrays ?
21:47:16 <SamB> Gahhh: their implementation and documentation?
21:47:43 <Gahhh> I didnt get that impression
21:47:53 <SamB> go read the source then!
21:48:06 <Darius> SamB: You can cdr fairly well with slice notation if I'm not mistaken.
21:48:07 <Gahhh> wow fun
21:48:32 <SamB> Darius: apart from the O(n)-ness, sure
21:49:57 <Lemmih> Do you really have to open a file to get its size on non-posix systems?
21:50:04 <cm> hooray for javascript
21:50:09 <SamB> Lemmih: who knows?
21:50:18 <SamB> Microsoft probably does.
21:50:25 <Lemmih> shapr!
21:50:27 <Darius> Lemmih: I don't believe you do on (some) Windows systems.
21:50:28 <shapr> Lemmih!
21:51:12 <cm> shapr..
21:51:17 <shapr> yes?
21:51:34 <cm> hi :o
21:51:36 <shapr> hiya cm
21:51:52 <cm> how are you?
21:52:08 <shapr> I'm asleep.
21:52:29 <cm> Lemmih: GetFileAttributesEx
21:52:53 <Lemmih> @index GetFileAttributesEx
21:52:53 <lambdabot> bzzt
21:54:16 <Lemmih> 'bracket (openFile path ReadMode) hClose hFileSize' is good enough for now.
21:54:40 <cm> shapr: I'm trying to code an Othello browser game as quick as possible :o
21:55:46 <Darius> cm: Break out APL!
21:55:56 <cm> huh?
21:56:10 <Lemmih> Is there a non-posix (u)sleep?
21:56:34 <cm> Lemmih: if complete, above function would probably be in the win32 package
21:57:23 <Lemmih> Is there a non-posix (u)sleep in the standard libraries?
21:58:47 <Darius> APL should be able to implement Othello quickly. 'not sure what "browser" is about.
21:58:50 <cm> not that I know
21:58:56 <cm> Darius: firefox and stuff
21:59:19 <cm> Darius: think kurnik.org in small & quick & simple & buggy
22:00:13 <shapr> sounds like fun
22:00:29 <shapr> How about an array and placement functions that check for pieces to swap?
22:00:40 <shapr> simplest render would be to just 'show' it
22:00:53 <shapr> players type in their moves with letter/number
22:01:17 <Darius> See with APL you could probably do that part with a few non-printable characters
22:01:38 <shapr> I always get unprintables when describing my code.
22:01:46 <cm> Darius: hehe
22:01:48 <shapr> @#!
22:01:48 <lambdabot> Sorry, I don't know the command "#!", try "lambdabot: @listcommands"
22:02:33 <Darius> shapr: But those are actually in a character set and accessible from a standard keyboard
22:02:35 <cm> shapr: I started with the (HTML/JavaScript) GUI to delay the question which implementation language to use :-)
22:02:35 <Pseudonym> @#!/usr/bin/runhugs
22:02:35 <lambdabot> Sorry, I don't know the command "#!/usr/bin/runhugs", try "lambdabot: @listcomma
22:02:35 <lambdabot> ds"
22:03:00 <shapr> cm: Haskell, of course.
22:03:21 <Darius> Anyways, it's 1 in the morning and I should probably sleep at somepoint.
22:03:29 <cm> shapr: would probably be a pretty good option :)
22:03:34 <cm> and a way to test-drive my toy web server
22:04:04 <cm> it lacks session management, though =(
22:04:30 <shapr> you could use the session management in WASH
22:05:28 <cm> hm, is WASH still CGI-only?
22:06:54 <cm> wow, I'm impressed by the preprocessor. nice.
22:29:03 * cm wants type
22:29:12 <shapr> what type?
22:30:30 <cm> ..in javascript
22:31:15 <cm> maybe we should have our HsJavascript, like the lisp folks ;o)
22:33:17 <shapr> hiya jewel
22:37:37 <cm> it's so fucked up, i feel so.. "restricted" when i'm coding at my laptop. hacking all the time because i already think i know i won't be motivated long enough to finish stuff. when coding at work, it's totally different. fuck. nites.
22:37:54 <shapr> Dang, I've just finished the board
22:38:04 <shapr> now I'm writing the functions for placing pieces
22:38:40 <cm> (after some hours I get pissed because I see only hacks and no features, and stop)
22:39:48 <autrijus> dons: around?
22:39:56 <cm> shapr: http://www.unfinity.de/othello/othello.html
22:40:00 <cm> (hooray o_0)
22:40:38 <shapr> wow, I won in a single click.
22:41:00 <cm> yeah, it's client-side only atm.
22:41:05 <cm> server says "you won" ;o)
22:41:58 <cm> http://www.unfinity.de/othello/gui.js
22:42:37 <shapr> I wonder if you can already mix SVG and JavaScript in Mozilla. That would be fun.
22:43:08 <cm> yeah you can
22:44:12 <shapr> oh neat, I can directly use Char as an Ix
22:45:35 <cm> :)
22:51:36 <autrijus> dons: I can build hs-pluigns only after I rm the inplace conf
23:00:10 <cm> /o/ moving works. uhu.
23:02:25 <shapr> too bad, I have to go to migrationsverket, I can't continue with my Othello.
23:05:10 <cm> I feel you want to implement the server side vocabulary (:
23:05:13 <cm> good night
23:07:35 <dons> autrijus: ok. i'll have  a look. what os you using, btw?
23:08:28 <autrijus> freebsd
23:08:31 <autrijus> 5.3 release
23:08:41 <dons> ok.
23:09:12 <dons> and ghc-6.4, right?
23:12:55 <dons> builds fine for me out of the box with 6.4. are you having build problems or use problems?
23:13:37 <dons> autrijus: and you have the a very recent nightly snapshot?
23:15:05 <dons> otherwise, mail me a transcript of the error, with any relevant info.
23:16:07 <autrijus> ok.
23:16:16 <autrijus> hm. you depend on alex right?
23:19:38 <autrijus> alex fails to install.
23:19:56 <autrijus> do you have a ./src/plugins/Plugins/ParsePkgConfCabal.hs somewhere?
23:24:22 <autrijus> does hs-plugins work on win32?
23:26:27 <dons> not on win32 yet.
23:26:39 <dons> yes, it needs alex if you're using cvs
23:29:45 <dons> time for dinner. autrijus, mail if you're still stuck or have bug reports
23:38:03 <autrijus> ok.
23:44:25 <Ruller> what means "pesco"?
23:44:59 <pesco> Nothing. It's a name.
23:45:22 <pesco> Well it does mean something in spanish or italian I think, something about fish, but I don't remember.
23:46:01 <pesco> But I'm neither Spanish nor Italian, so that doesn't apply.
23:51:28 <dons> pesco = I fish ?
23:51:35 * pesco shrugs.
23:51:48 <jewel> heh
23:51:52 <dons> in both espanol and italian
23:52:02 <pesco> You sure?
23:52:16 <dons> babelbot says
23:52:27 <pesco> Ah, good.
23:52:40 <dons> and portugese too
23:52:59 <pesco> Woohoo. I'm all international.
23:53:06 <dons> reminds me I should merge babelbot.hs into lambdabot main tree
23:53:19 <pesco> Right.
23:53:26 <dons> if only I could trade my soul for more hours in the day.
23:53:31 <dons> 28 would be good. or 32
23:53:55 <pesco> Yeah, ah well.
23:54:01 <pesco> I need to go, get some work done. ;)
