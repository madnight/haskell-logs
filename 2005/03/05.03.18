00:48:22 --- topic: '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]'
00:48:22 --- topic: set by shapr on [Sun Mar 06 12:29:48 2005]
00:48:22 --- names: list (clog ex__nor martink Ruller magr boegel ex_nor nlv11757_ iblechbot jak pipe metaperl ozone Asta Nioate autark-jp tintin jewel waltz Cale themaximus Igloo humasect djo sh10151 icb1 SamB Khisanth emu psi vincenz gabor stepcutHM araujo karingo Philippa_ jiing JaffaCake tic wilx jlouis Squider earthy gnufan skew tarantul wagle isomer yonkeltron lumi metaperl_ aleator chucky vegai sqrt mayhem mornfall|work isomer_ desrt_gabriel johs lambdabot)
00:48:22 --- names: list (xerox Lemmih polli cathper rtega tumm dude4545 calvin_ ksandstr keverets shrimpx rossberg noj cmeme musasabi tuomov autrijus integral hllu chip desrt tromp a5 CLxyz esap Matt-W tmoertel juhp dons ingy det cooz Gahhh kosmikus djw MegaMonad mflux _shawn skylan borism kpk Spark_ Taaus hcchien gdsx jesse99 mauke edwinb chaven ibid kolmodin thebug mattam ned tinus asmodai Lunar^ gzl)
00:50:06 <wilx> Geeez!
00:50:10 * wilx hates /.
00:50:21 <wilx> Why cannot I see all messages at once?
00:50:30 <wilx> I hate how it folds deeper threads...
00:50:40 <mflux> if only slashdot provided nntp-backend
00:50:51 <mflux> hmh, s/backend/interface/
00:51:24 <wilx> ...then nobody would use the web one with ads...
00:54:25 <mflux> text-messages nearby the message signatures
00:54:32 <mflux> or maybe whole ads-messages!
00:54:58 <mflux> of course, they could easily be filtered out by the client, but so can (and propably are too) the banners
00:55:57 <earthy> wilx: switch to nested
00:56:11 <mflux> well yeah, I use nested too
00:56:13 <mflux> but then there are n pages
00:56:24 <earthy> yeah, comment overflow
00:56:26 <earthy> that's annoying
00:56:29 <mflux> and it's still impossible to follow threads after a while
00:56:46 <mflux> plus the page-splitting feature is somehow buggy, same messages may appear in multiple pages ;)
00:56:51 <wilx> Nice, much better.
00:57:51 <earthy> owh, that's not a bug, that's a feature
00:57:59 <mflux> yeah, that's what they tell you
00:58:19 <mflux> I really so much like about reading the messages again and again
00:58:34 <earthy> actually, in this case I think it really is, so that the entire thread that flows over is on the next page as well
00:58:54 <mflux> infact I've seriously considered writing an nntp(/google-groups/mailinglist-web-archives/slashdot)-client which would have that nested view, so that many messages could be viewed simultaneously
00:59:14 <mflux> well why not just force the whole thread to one page?
00:59:20 <mflux> and then not any messages of it to the next?
00:59:29 <mflux> (more compilcated to implement I would guess)
01:11:56 <wilx> Hehe, /. posts are so funny :)
01:12:05 <nlv11757_> earthy: do you know if it's possible to compile uust with -prof
01:12:13 <nlv11757_> it seems to be failing
01:18:14 <wilx> Tee hee hee, Perl6 vs Perl5 vs Ruby vs Python wars...
01:19:07 <nlv11757_> sounds like mudslinging
01:22:09 <jlouis> everyone loses in wars. Lets keep out of it
01:22:22 <jlouis> remember: at all costs -- Do _NOT_ succeed!
01:24:41 * pesco waves a ragged flag.
01:25:02 <pesco> wilx: Which post are you refering to?
01:29:30 <wilx> http://it.slashdot.org/article.pl?sid=05/03/16/2151205&tid=145&tid=8
01:29:48 <metaperl> I am trying to make sense of Cale's reificiation of this type signature: (>>=) :: (Monad m) => m a -> (a -> m b) -> m b     .... he says: If I have a box of apples (m a) and for each apple, you will give me a box of blueberries (a -> m b) then I can get a box with all the blueberries together (m b).   My question is: is the (m b) that the function produces from a single a the same (m b) that (>>=) promises to return?
01:30:56 <metaperl> Dozen apples and f apples = Dozen blueberries implies that (>>=) will produce 144 blueberries for 12 apples
01:31:09 <metaperl> that confuses me
01:31:38 <metaperl> this is like feeding the multitude with 3 loaves of bread and 5 fish
01:31:42 <metaperl> :)
01:32:38 <nlv11757_> 144 is the right answer you mean?
01:33:21 <metaperl> I'm saying I dont know whether (m b) of (a -> m b) is quantitatively the same as the (m b) that (>>=) returns
01:34:16 <pipe> this new generation of wrigley's orbit gum loses it's flavor way sooner then the old shit :(
01:34:36 <pipe> this is not good :|
01:37:41 <nlv11757_> im confused what you mean with quantity in this context
01:38:01 <metaperl> Prelude> map snd $ sort $ zip [15,9,6,12,4,5,1,16,8,2,10,3,13,14,11,18,17,7] (i\
01:38:01 <metaperl> terate (map pred) ":Lmmnnoopssuuxyy{~" !! 12)
01:38:01 <metaperl>  
01:38:01 <metaperl> <interactive>:1: Variable not in scope: `sort'
01:38:59 <metaperl> what do I need to import to get the sort function? using GHCI
01:39:12 <nlv11757_> my guess would be List
01:39:41 <tromp> Data.List
01:40:13 <nlv11757_> or Data.List whichever suits you best :]
01:43:32 <metaperl> I'm gettting an incorrect indentation error when I paste this Haskell code: http://haskell.org/hawiki/CaleGibbard
01:44:53 <metaperl> fixed:
01:44:53 <metaperl> import List
01:44:54 <metaperl>  
01:44:54 <metaperl> firstpart = (iterate (map pred) ":Lmmnnoopssuuxyy{~" !! 12)
01:44:54 <metaperl> seconpart = zip [15,9,6,12,4,5,1,16,8,2,10,3,13,14,11,18,17,7] firstpart
01:44:54 <metaperl> finalpart = map snd $ sort $ seconpart
01:45:46 <Lemmih> The one-liner works for me.
01:46:24 <metaperl> I just broke it into 3 functions and updated the wiki: http://haskell.org/hawiki/CaleGibbard#preview
01:46:57 <metaperl> Lemmih, does the English example Cale gave along with the type signature for (>>=) make sense to you?
01:47:01 <Lemmih> Why did you do that?
01:47:06 <metaperl> do what?
01:47:11 <nlv11757_> ok i give up, no profiling then
01:47:17 <Lemmih> Break it down into three parts.
01:47:32 <Lemmih> nlv11757_: Did you try with --make?
01:47:39 <metaperl> becauase I was getting indentation errors when I pasted it verbatim into a file along with an import List call
01:47:39 <nlv11757_> yeah
01:47:50 <nlv11757_> i added to the Makefile the -prof option
01:47:55 <Lemmih> metaperl: It's an expression not a declaration.
01:48:09 <Lemmih> metaperl: Run it in hugs/GHCi.
01:48:14 <metaperl> oh
01:48:38 <metaperl> so Lemmih, does the English example for (>>=) make sense to you?
01:49:02 <metaperl> why would taking one of something to produce a container of it yield the same of taking a whole container of thatother something
01:49:25 <nlv11757_> hmmm now that is one vague sentence
01:49:27 <Lemmih> Yes. But I think just looking at some code is ten times easier.
01:49:28 <metaperl> (a -> m b) versus (m b) in the type signature of (>>=)
01:49:36 <metaperl> @type (>>=)
01:49:37 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
01:50:11 <metaperl> can you make a quantitatve statement about what is returned by the 2nd arg to (>>=) versus what is returned by (>>=) ?
01:50:58 <Lemmih> Doesn't the typesig say it all?
01:51:49 <metaperl> I'm not sure entirely
01:51:54 <tromp> think of it as aggregating the mb you get from all the a in ma
01:52:04 <metaperl> we see b twice in this type signature
01:52:14 <metaperl> (a -> m b) and also m b
01:52:19 <Lemmih> Yes.
01:52:23 <Lemmih> Exactly.
01:52:43 <metaperl> what have a container of b but it is not clear whether the b's are equal
01:53:03 <metaperl> @type show
01:53:04 <lambdabot> show :: forall a. (Show a) => a -> String
01:53:29 <metaperl> this could be the second arg to (>>=)
01:53:44 <metaperl> because it takes a single a to List Char
01:53:54 <metaperl> in this case our b would be Char
01:54:25 <Lemmih> Yes.
01:54:35 <metaperl> >>= List 1,2,3  (show)
01:55:54 <Lemmih> And 'b' will always be equal to 'b' (:
01:58:38 <metaperl> but read this: If I have a box of apples (m a) and for each apple, you will give me a box of blueberries (a -> m b) then I can get a box with all the blueberries together (m b).
01:59:38 <metaperl> if you get a box of blueberries for one apple, i.e. (m b) then for several applies you will get several boxes of blueberries, which is more than you got for one apple... there b /= b
01:59:49 <tromp> that's what happens if you do [berries a | a <- apples]
01:59:53 <metaperl> of course this is where join comes in to defy all logic:
01:59:56 <metaperl> @type join
01:59:58 <lambdabot> bzzt
02:00:08 <metaperl> join :: m (m b) -> m b
02:00:16 <Lemmih> metaperl: I would say (m a) is a box with only one apple.
02:00:47 <tromp> that's obviously wrong in case of m = []
02:00:48 <Lemmih> metaperl: which can be transformed to a box with one blueberry with the (a -> m b) function.
02:01:22 <Lemmih> tromp: How the monad is implemented is irrelevant.
02:02:14 <tromp> i'm saying that many interesting monads involve multiple a's in an m a
02:02:45 <Lemmih> It still has no meaning in this context. We're talking about types only.
02:03:19 <metaperl> yes, I was thinking of physical amounts and I should just be looking at types I imagine
02:03:41 <metaperl> @type (+)
02:03:42 <lambdabot> (+) :: forall a. (Num a) => a -> a -> a
02:03:45 <tromp> ok, inside an ma are things of (only) type a :)
02:03:47 <metaperl> look at tat
02:04:02 <metaperl> + can take a 5 and 6 and 5/=6
02:04:05 <metaperl> therefore
02:04:08 <metaperl> @type (>>=)
02:04:09 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
02:04:20 <metaperl> the two b's in this type signature do not have to equal either
02:04:45 <metaperl> the use of a in the type signature of (+) is different from (>>=)
02:04:57 <metaperl> (>>=)'s use of b
02:04:59 <Lemmih> Dude. The last 'b' can either be buttom or the 'b' in the second argument.
02:05:18 <Lemmih> Which one do you think it is? d-:
02:05:30 <metaperl> I dont know what you mean?
02:05:35 <metaperl> never mind
02:05:47 <Lemmih> 'b' will be of same type as 'b'.
02:05:59 <pesco> metaperl: I think the question is, what do you mean by "the b's being the same"?
02:06:00 <metaperl> you said b would be equal to b
02:06:17 <Lemmih> metaperl: Yes. The type of 'b' is equal to the type of 'b'.
02:06:33 <Lemmih> metaperl: We're still only talking about types.
02:06:36 <metaperl> ok, but the quantities may vary
02:06:45 <pesco> metaperl: What quantities are you talking about?
02:07:04 <metaperl> Lemmih, _you_ were only talking about types but my initial question implied some concern with quantity. That's where I got confused
02:07:23 <Lemmih> metaperl: Sure. But it can only get a value of type 'b' via the second function or via buttom.
02:07:27 <metaperl> myfunc apple = Dozen blueberry
02:07:46 <metaperl> Lemmih, I think you mean bottom = bot = _|_
02:08:06 <Lemmih> s/buttom/bottom/
02:08:08 <pesco> metaperl: The container metaphor is only a metaphor. There is no way to measure quantity in general.
02:08:29 <metaperl> >>= Dozen apple myfunc    -- yields Dozen blueberry
02:09:34 <metaperl> so a single apple yields the same as a dozen apples when using ... Ithink I need to quit thinking of amounts... "Dozen" is just a word in front of an expression
02:09:41 <metaperl> ok
02:09:49 <pesco> metaperl: Exactly.
02:09:53 <metaperl> :)
02:13:40 <wilx> Hmpf. I wish there was to Haskell native Unsigned type...using Int in some situations feels like I am leaving a space for error.
02:13:53 <tromp> Word
02:14:05 <wilx> Don't you have to suffix bit width?
02:14:25 <tromp> yes, if it's 8, 16, or 64
02:14:37 <wilx> Omg! 1::Word works!
02:14:41 <wilx> Cool.
02:14:46 <Vytas> Hello, how much memory do you need to compile gtk2hs with mozilla support?
02:14:58 <Vytas> I fail with standart 350M setting
02:15:06 <earthy> wilx: why wouldn't it?
02:15:13 <wilx> Dunno :)
02:15:28 <tromp> the default Word is usually a Word32 (whatever the size Int is)
02:15:40 <wilx> You know, I have re-started learning Hasekll after few years and I haven't really re-read all the tutorials :)
02:16:15 <wilx> I just somewhat thought that there is only Int and Integer and then Word<x> ....
02:17:07 <pesco> Heh. Hugs does not provide a Num instance for Word though.
02:17:22 <pesco> (At least not the Nov. 2004 snapshot)
02:17:55 <wilx> GHC does, good enough for me.
02:18:08 * pesco shrugs.
02:18:18 <musasabi> Vytas: swap may be your key to success.
02:18:52 <Vytas> well, I have 512M ram
02:18:58 <musasabi> Vytas: more seriously though I have built gtk2hs in the past on machine with 512mb of ram without problems.
02:19:18 <Vytas> I succeeded without gtkmozembed
02:19:42 <Vytas> I'm using gentoo, and in the ebuild, there's option 350M as I can guess
02:23:00 <basti_> hi
02:23:54 <musasabi> ah I don't think I tried to build mozembed
02:23:58 <musasabi> hello basti_
02:24:24 <Vytas> musasabi, gtk2hs includes mozilla support by default
02:24:31 <Vytas> *version 0.9.7
02:28:54 <metaperl> another way to answer my question would've been to say: "Dozen" is not a container. It is an amount
02:29:08 <metaperl> The instructions talked about about containers not amounts
02:48:48 <pesco> re
02:48:50 * pesco frowns
02:49:04 <basti_> whats wrong? crash?
02:50:01 <pesco> Yes.
02:50:06 <basti_> aww
02:50:18 <Ruller> I feel the power of Haskell
02:50:37 <basti_> -g-
02:51:06 <basti_> earthquake like? or rather a little stir? ;)
02:51:25 <Ruller> like a vulkano!
02:52:08 <pesco> Ruller: Tell us about your experience! :-)
02:54:13 <Ruller> I have read the Gentle introduction and wrote some first simple programms
02:54:39 <pesco> Ah, I see.
02:54:39 <Ruller> now I need some more complete documentation
02:54:44 <tromp> so you can write a neat factorial function now?
02:55:03 <Ruller> yes
02:55:04 <basti_> the power of haskell is all inside the clever basics i think.
02:56:46 <Ruller> now I'm going to read "The Haskell Road to Logic, Math and Programming - Kees Doets   Jan van Eijck"
02:56:56 <basti_> oh thats a nice one
02:57:05 <Ruller> got as pdf from e-donkey
02:57:39 <Ruller> I whish you good luck and hope to see you later!
02:57:45 <basti_> =)
02:57:48 <basti_> we won't vanish
02:57:53 <Ruller> good :)
03:04:28 <metaperl> Ruller
03:04:39 <metaperl> oh never mind
04:05:11 <Philippa_> oh shit
04:05:21 <Philippa_> folks, if your client has any known exploits, they're about to get exploited...
04:05:35 <basti_> what client?
04:05:41 <Philippa_> IRC client
04:06:55 <tromp> i use xchat 2.0.7
04:06:56 <basti_> ...
04:07:05 <CosmicRay> that's... old.
04:08:14 <tromp> came with this fedora core 2 install
04:08:53 <tromp> it's a little over a year old
04:09:41 <TheHunter> ok, this is it, i'm installing a PaX-kernel again.
04:22:34 <nlv11757_> im being ctcp flooded by INFOTHEK ?
04:22:50 <basti_> that was what Philippa_ was warning about i guess.
04:23:04 <nlv11757_> ah my xchat stated he was ignoring it
04:23:12 <nlv11757_> so i guess no prob then
04:23:24 <nlv11757_> fedora core 3 chips xchat 2.4.0
04:23:29 <nlv11757_> chips=ships
04:26:02 <musasabi> nlv11757_: well he was checking version probably looking for vulnerable clients.
04:26:30 <nlv11757_> see if the client couldnt handle the flood or something like that?
04:26:59 <musasabi> nlv11757_: no, checking the client program versions.
04:27:16 <nlv11757_> hehe well he did it enough times to be ignored because of a flood attempt
04:41:28 <TheHunter> ok, according to nmap, he's running linux 2.1.19 - 2.2.25 and squid 2.3.STABLE4
04:44:26 * basti_ drools
04:46:48 <basti_> jussx!
04:52:34 <nlv11757_> who? the ctcp-er?
05:04:03 <_JusSx_> basti_: ?
05:04:18 <basti_> jussx: hi!
05:04:24 <_JusSx_> who are you?
05:04:35 <basti_> we talked a few days ago.
05:04:44 <_JusSx_> about what?
05:04:57 <basti_> i dont remember.
05:05:01 <_JusSx_> lol
05:05:04 <_JusSx_> me too
05:05:06 <basti_> :)
05:05:06 <boegel> this is _so_ funny :)
05:18:49 <TheStar> Does haskell support infinite recursion without excessive RAM useage?
05:19:04 <autrijus> why yes.
05:19:08 <autrijus> because it's lazy.
05:19:21 <autrijus> although, there's recursions and recursions. :)
05:19:24 <basti_> i would say it uses ram O(n) to recursion depth.
05:19:34 <TheStar> I'm so much more interested in functional languages now because I tried to make my own language - then discovered that it was becomming far more lispy.
05:19:35 <basti_> with the optimal cases being better.
05:19:48 <TheStar> basti_, Why couldn't it be O(1) ?
05:20:02 <autrijus> TheStar: that's the optimal case.
05:20:08 <TheStar> Ahh, cool.
05:20:18 <autrijus> there is many forms of expression that reduce its space usage.
05:20:21 <basti_> because in the general case, you would need to store some recursion context.
05:20:36 <TheStar> basti_, The general case is when there's two functions to call one after the other?
05:20:38 <autrijus> recommended: "Algorithms : A Functional Programming Approach", By: Fethi A. Rabhi, Guy Lapalme
05:20:54 <nlv11757_> is that book haskell specific?
05:20:55 <musasabi> argh @ wallop
05:21:01 <nlv11757_> or does it use haskell i mean
05:21:09 <nlv11757_> it probably applies to more than just haskell
05:21:22 <musasabi> Okasaki's book is btw quite good, but of course that needs adaption inside one's head.
05:22:40 <autrijus> yup.
05:22:51 <autrijus> nlv11757_: it uses haskell.
05:23:00 <autrijus> and is the best haskell intro I've seen.
05:23:08 <autrijus> "Purely Functional Data Structures" works too.
05:23:10 <TheStar> What does haskell try to excell at? I gather it isn't as good at threading and the like as erlang, for starters...
05:23:36 <autrijus> TheStar: why, GHC excels at threading.
05:23:58 <TheStar> autrijus, How does it manage it?
05:24:17 <nlv11757_> autrijus, does that book delve into complexity analysis as well?
05:24:19 <autrijus> TheStar: this may be helpful: http://research.microsoft.com/Users/simonpj/papers/stm/
05:24:22 <autrijus> nlv11757_: yes.
05:24:24 <nlv11757_> nice
05:24:55 <musasabi> TheStar: It is simple and plain fast.
05:25:26 <TheStar> musasabi, And I could easily have 30000 threads?
05:25:27 <musasabi> In some benchmarks it kills of even erlang ;)
05:25:54 <TheStar> Nice.
05:27:08 <musasabi> TheStar: spawning 30000 threads with one message passing through took 1.7 sec, just tested.
05:27:14 <autrijus> I think Haskell excels at everything but user base :)
05:27:49 <musasabi> e.g. http://shootout.alioth.debian.org/benchmark.php?test=process&lang=all&sort=fullcpu
05:28:03 <TheStar> I have recently purchased a book on: The Haskell School Of Expression (Hadon)
05:28:10 <nlv11757_> Hudek
05:28:13 <TheStar> Hudak, sorry.
05:28:31 <TheStar> Seems to be quite nice - read it in a car trip :)
05:29:10 <nlv11757_> here is another free one: http://www.cs.uu.nl/people/jeroen/courses/fp-eng.pdf
05:29:22 <nlv11757_> might not add anything, but then again...it's free ;)
05:29:55 <TheStar> Currently, I use Python, it does what I use it for quite well, but it seems...  Well, inflexible.
05:30:46 <TheStar> I particularly don't like it's recursion limitations.
05:31:05 <basti_> like obscene memory usage?
05:31:21 <autrijus> TheStar: welcome to the next stage then :)
05:31:40 <TheStar> autrijus, Which is currently the implementation of a language of my dreams.
05:32:04 <autrijus> for some application areas, GHC produces ~10x faster code with constant (versus linear) memory usage than Perl 5.
05:32:17 <autrijus> TheStar: cool. you will also learn that using Haskell to implement your dream language is very easy.
05:32:26 <TheStar> autrijus, Featuring no limitation of recursion, and in the _usual_ case, O(1) memory useage to recursion depth, etc, etc.  Then I suddenly realised that this suddenly became a functional language.
05:32:59 <autrijus> I implemented a sizable subset Perl 6 in less than a month. Chances are your dream language will be even easier to implement.
05:33:05 <TheStar> autrijus, Yes, but due to my obsessive nature, I'll probably still implement it in C, for speed.
05:33:16 <ozone> autrijus: not really sure if it's a fair comparison, since perl 5 is bytecode-based with no JIT
05:33:21 <ozone> (at least no JIT that i know of)
05:33:28 <autrijus> ozone: same as python :)
05:33:31 <TheStar> autrijus, My dream language simply has too many features.
05:33:44 <autrijus> TheStar: You'll also find that GHC does pointer arithmetic and compile to C, and you can include arbitary C code and use unboxed types.
05:33:48 <nlv11757_> my dream language is dutch
05:33:57 <ozone> autrijus: yeah, python too :)
05:33:59 <autrijus> which means you can pretty much write C in GHC.
05:34:11 <nlv11757_> who dreams in lambda's anyway
05:34:15 <autrijus> the code thus produced is then as fast as you'd like to be :)
05:34:16 <TheStar> autrijus, What kind of C does it compile to?  I intend to make my language faster than C, by nature of the removal of stacks.
05:34:31 <autrijus> TheStar: the C GHC produces is full of lambda lifted continuations.
05:34:35 <autrijus> so, no stacks.
05:34:38 <basti_> "faster than C"? in what respect?
05:35:19 <TheStar> autrijus, What are "lambda lifted continuations"?  I only know of lambda's in the context of python :(
05:35:20 <autrijus> I also don't know many domains that C is too slow for.
05:35:29 <musasabi> TheStar: many people have moved from python to haskell.
05:35:37 <basti_> i do not think speed is an inherent feature of any language.
05:35:39 <nlv11757_> i know a couple of domains C is unsuitable for
05:35:40 <TheStar> musasabi, I may become one of those.
05:35:42 <nlv11757_> most actually
05:35:46 <autrijus> TheStar: basically a series of goto()s that can go backward in time :)
05:35:47 <TheStar> basti_, Yes, but it is a good goal!
05:35:56 <basti_> yes.
05:36:04 <TheStar> autrijus, Ahh, be hard to get faster than that.
05:36:12 <ozone> i do believe that's the coolest explanation of lambda lifted continuations i've ever heard
05:36:16 <ozone> autrijus++
05:36:16 <TheStar> ALthough, I mean "faster than human-written C code".
05:36:33 <TheStar> autrijus, What do you mean "can go backward in time"?
05:36:36 <musasabi> TheStar: if you want to create a language faster than C then it would not make sense to write the implementation in C ;)
05:36:59 <TheStar> musasabi, The core implementation could easily be in C...
05:37:25 <musasabi> TheStar: why not just write an interpreter in e.g. haskell and then the real compiler in your own language?
05:37:29 <TheStar> I intend to make a very minimal C support foundation, then build the bulk of the language from what's then provided.
05:37:41 <nlv11757_> wow that book of yours autrijus, extremely varies in price
05:37:45 <ozone> TheStar: you may be interested in C--
05:37:50 <nlv11757_> one shop sells it for 70 euros, one for 35
05:37:50 <ozone> www.cminusminus.org
05:37:51 <autrijus> TheStar: or D.
05:37:57 <TheStar> No, not D.
05:38:03 <ozone> GHC uses C-- as a code generation backend
05:38:03 * TheStar checks C--
05:38:10 <boegel> nlv11757_: maybe it's hardback and paperback ?
05:38:16 <autrijus> http://www.digitalmars.com/d/
05:38:21 <TheStar> I also don't want to make my language a compiled one - I like interpreted languages.
05:38:43 <musasabi> TheStar: an interpreted language won't beat C at least not without JIT.
05:38:44 <autrijus> an interpreted, faster than C language.
05:38:51 <ozone> you plan to make a language faster than C and have it interpreted?
05:38:54 <autrijus> mmm machine code.
05:38:56 <ozone> you deserve a medal if you can do it :)
05:39:02 <autrijus> it's interpreted and faster than C.
05:39:05 * autrijus grins
05:39:09 <TheStar> musasabi, A given function should be interpreted only once.
05:39:31 <JaffaCake> do you count JIT compilation as interpreting?
05:39:31 <musasabi> TheStar: nah it needs to be interpreted each time it is called with different arguments.
05:39:44 <ozone> ah, hey jaffacake.  congrats on the 6.4 release
05:39:48 <TheStar> musasabi, I don't agree.
05:39:50 <musasabi> TheStar: then you need to calculate what results you can keep in memory and what to discard.
05:39:52 <JaffaCake> ta ;)
05:40:22 <musasabi> TheStar: or do you mean by interpreting "compiling to native with dynamic optimizations on the fly" ?
05:40:29 <nlv11757_> boegel: nope, checked it, same isbn same description, same book...VERY different price
05:40:33 <TheStar> musasabi, To bytecode.
05:41:13 <boegel> nlv11757_: strange... are you sure it includes VAT, and it isn't for buying it in large amounts or so ?
05:42:08 <nlv11757_> ive just ordered it from donner.nl for 36 euros...and bol.com sells it for 70 euros (all include shipping costs)
05:42:15 <nlv11757_> insane difference
05:42:26 <boegel> indeed
05:42:36 <nlv11757_> actually, i had to buy some math statistical book....it differed 100 euros !!!!
05:42:54 <nlv11757_> i always use vergelijk.nl whatever
05:43:14 <nlv11757_> comparison site i mean, doesnt mean much if you're not dutch
05:43:17 <TheStar> I'm not sure how useful C-- would be for me.  PErhaps if I were making a compiled language...
05:43:18 <musasabi> TheStar: isn't it hard to make interpreted bytecode as fast as compiled native code?
05:43:57 <TheStar> musasabi, Yes.  Hasn't been done and I doubt I'll be able to do it, but it's a good goal! :)  Small can achieve being merely 6 times slower.
05:44:26 <autrijus> you may be interesting in JITing then.
05:44:44 <autrijus> and a good op dispatcher
05:44:48 <boegel> nlv11757_: I'm from Belgium, so I understand :)
05:44:51 <autrijus> see http://www.parrotcode.org/ for a pretty good example.
05:44:52 <nlv11757_> ah
05:44:54 <TheStar> autrijus, I intend to allow a JIT to be used, but I don't have the skill to actually do it.
05:45:08 <autrijus> TheStar: you can target Parrot bytecode and let it do all it for you :)
05:45:24 <autrijus> that way your language can call python and perl libraries natively too.
05:45:59 <TheStar> That would be no fun! :)
05:46:07 <autrijus> eh, that would be no fun? :)
05:46:14 <musasabi> replicating work is not fun ;)
05:46:16 <autrijus> well, have fun then :)
05:46:30 <musasabi> writing JIT is not my idea of fun.
05:46:52 <TheStar> I don't intend to do a JIT, just allow one to be implemented at a later date.
05:46:55 <autrijus> and parrot has spent ~2 years to get JIT just right.
05:47:46 <TheStar> Although, I have considerable overhead in my design in the case that the code is 100% aspect oriented, with no difference from a code point of view between say, an int and a string.
05:48:19 <musasabi> You need *heavy* dynamic optimization then.
05:48:21 <autrijus> so you can square "PK\0x03\x04"
05:48:30 <autrijus> and get something interesting?
05:49:14 <TheStar> It's more that I can't optimize for the case of integers, I must always deal with objects at arms length.
05:50:46 <musasabi> What sort of type information will you have?
05:51:26 <TheStar> A class hierachy.
05:51:52 <TheStar> But that's it, and type checking is not done - if type checking is wanted, it's done manually.
05:52:26 <nlv11757_> yeah mean with paper and pen?
05:52:39 * basti_ jumps
05:52:52 <TheStar> nlv11757_, Of course :)
05:53:04 * boegel calms down basti_ 
05:53:20 <musasabi> TheStar: that sounds quite hard to optimize.. Are you familiar with dynamic optimization techniques (as e.g. in Self) ?
05:53:22 <basti_> i kinda like the idea of "no type" languages.
05:53:32 <basti_> like, C. or brainf_ck
05:53:41 <TheStar> musasabi, I have not done any language design courses, and this is my first entry into langauges.
05:53:45 <musasabi> Types are usefull contracts.
05:54:16 <basti_> in fact, many things are like types.
05:54:21 <TheStar> musasabi, Yes, but I feel that it's unneccessary most of the time.
05:54:35 <basti_> for example, if we think of "variable x always holds a power of 2"
05:54:41 <basti_> thats a type.
05:55:05 <basti_> if language X might think of it as an integer variable with no additional constraints, somethings broken in language X
05:55:06 <basti_> ;)
05:55:41 <tromp> weird; i write      newscore x = ((7 .&. 7) xor 4) - 4
05:55:53 <tromp> and get     No instance for (Bits ((a -> a -> a) -> t -> Int))
05:55:53 <tromp>       arising from use of `.&.' at ./GameTreeSearch.hs:45:17-19
05:56:14 <musasabi> tromp: you have parenthesises in wrong place.
05:56:29 <musasabi> tromp: `xor`
05:56:40 <TheStar> Hmm, it appears that Haskell and likewise langauges are commonly used to implement other languages.
05:56:46 <tromp> ah, thx:)
05:57:22 <musasabi> Functional languages like Haskell or SML are very useful in compiler construction.
05:57:53 <TheStar> Because of the optimizations they offer?
06:00:32 <musasabi> TheStar: because they make it simple.
06:00:41 <TheStar> Hmm.
06:02:29 <musasabi> Generally constructing a compiler that does not crash or generate incorrect code should be the first goal ;)
06:02:39 <musasabi> Then you can start looking at the speed.
06:02:45 <TheStar> Indeed.
06:07:18 <TheStar> Historically, I gather that lisp was a slow language?
06:08:05 <CosmicRay> well, it could be, there were lots of implementations of lisp
06:08:12 * TheStar wonders what's the difference between a Lisp and a Turing machine.
06:08:16 <CosmicRay> and there was an os written in lisp, so it couldn't have been all that bad
06:08:41 <CosmicRay> anyway, hello TheStar, are you new here or is my memory just bad?
06:09:10 <TheStar> CosmicRay, I may have appeared here briefly last year, but I would say that I am new.
06:09:16 <CosmicRay> TheStar: http://en.wikipedia.org/wiki/Turing_machine
06:09:21 <CosmicRay> well, welcome then
06:09:26 <TheStar> Thanks :)
06:09:41 <CosmicRay> have you done much with haskell, or are you just tring to find out what it is all about at this stage?
06:10:36 <TheStar> CosmicRay, Basically, I've purchased a book, and read it in the car, and have been investigating making my own language.
06:10:50 <CosmicRay> TheStar: which book?
06:10:53 <TheStar> CosmicRay, I have now found my language becomming very lisp-like, and thus my interest in #haskell :)
06:10:58 <CosmicRay> heh
06:11:00 <TheStar> CosmicRay, The Haskell School Of Expression.
06:11:12 <CosmicRay> ahh.  one that CosmicRay does not yet own :-(
06:11:21 <TheStar> It's very simple :)
06:11:30 <CosmicRay> anyway, Haskell is very popular among people that design languages
06:11:31 <musasabi> TheStar: the lisp OS run on special hardware afaik
06:11:49 <basti_> i think haskell is popular among people that favour clearness over tradition :P
06:11:59 <TheStar> musasabi, And why was that hardware so expensive, slow and use so much electricity to run?
06:12:00 <CosmicRay> however, haskell is also so flexible that often times, you don't have to design your own language, and yet still arrive and something that doesn't look very haskellish :-)
06:12:00 <musasabi> TheStar: and modern lisp implementations usually compile to native and do type inference if they are fast
06:12:11 <basti_> might be that language designers are a rather large subset of these people
06:12:26 <CosmicRay> TheStar: wash, parsec, and haxml are all examples of this
06:13:08 <Philippa_> TheStar: it was custom hardware, therefore it didn't get the sheer weight of work done on making it go quick that the same-old-same-old kit did and does
06:13:28 <CosmicRay> TheStar: the fact that you can specify your own operators, as well as omit the Prelude (and thus all pre-defined operators and functions) can be powerful
06:13:52 <TheStar> CosmicRay, Infix notation and all that?
06:13:57 <basti_> i really LIKE the fact that the haskell parser supports on the fly extension
06:14:02 <CosmicRay> TheStar: yes
06:14:12 <Philippa_> no distfix, but hey
06:14:22 <basti_> distfix? as in a+b+c+d?
06:15:07 <basti_> ah
06:15:08 <basti_> no
06:15:12 <basti_> http://wwwacs.gantep.edu.tr/foldoc/foldoc.cgi?distfix
06:15:17 <CosmicRay> TheStar: every binary operator in haskell is a function, and any function that takes two arguments can be expressed as a binary operator
06:15:27 <CosmicRay> TheStar: for instance, (+) is the function representing +
06:15:36 <TheStar> I am familiar with that.
06:15:42 <TheStar> My background is Python.
06:16:01 <wilx> Hmm...
06:16:15 <basti_> Philippa_ but you could emulate a distfix operator couldn't you?
06:16:29 <CosmicRay> TheStar: mine too
06:16:31 <Philippa_> yeah, you could
06:16:46 <CosmicRay> TheStar: http://quux.org/devel/offlineimap, for isntance
06:17:43 <CosmicRay> TheStar: you might appreciate my MissingH library, http://quux.org/devel/missingh.  It's got various things that I liked from Python, such as a file object abstraction, some string-manipulation functions, and a ConfigParser implementation
06:17:57 <Philippa_> which reminds me. The news about python3000 and functional programming has put me off ever bothering to try the language
06:18:12 <TheStar> Philippa_, Python3000 is fictional.
06:18:17 <ozone> ah, so that's who you are cosmicray :)
06:18:35 <CosmicRay> TheStar: I also have MissingPy, which is both a general low-level interface to Python, and some higher-level interfaces to things like gzfile and python file-like objects
06:18:42 <Philippa_> okay. Guido's views still bug me enough I'm not sure I want to bother trying though
06:18:43 <CosmicRay> ozone: crap, my secret is out! :-)
06:19:01 <TheStar> I believe that Python is starting to show age.
06:19:13 <boegel> ozone: are you the guy from The Incredibles ? :)
06:19:25 <CosmicRay> TheStar: it is very interesting that Perl 6 looks more appealing to me than Python sometimes.
06:19:42 <CosmicRay> TheStar: while Guido is busy yanking functional stuff out of Python, the Perl people are putting it in.
06:19:43 <TheStar> Perl 6 is supposed to be completely redesigned from scratch.
06:19:52 <TheStar> CosmicRay, Please explain.
06:20:08 <ozone> boegel: yeah, that's me, but don't tell anyone
06:20:18 <ozone> CosmicRay: i agree about perl 6
06:20:30 <CosmicRay> TheStar: shapr reported yesterday that guido is planning to remove lambda from python, and possibly other functional-like features such as map
06:20:33 * boegel screams "It's him ! The freeze-guy from The Incredibles !"
06:20:37 <basti_> uggghhhhhhh
06:20:43 <wilx> Huhuhu.
06:20:45 <wilx> Why?
06:20:47 <ozone> if tit doesn't have exact correspondences with mainstream functional programming concepts, it certainly has stuff very close to it
06:20:48 * CosmicRay doesn't get it, alas
06:20:50 <wilx> What is the rationale?
06:20:52 <ozone> e.g. their -> operator vs map
06:20:54 <basti_> python without functional?
06:21:13 <wilx> (Not that I use or know Python...)
06:21:28 <TheStar> My biggest beaf is their restriction of recursion depth, and their explicit string type checking.
06:21:35 <CosmicRay> wilx: I don't know, someone was just mentioning this here yesterday
06:21:43 <wilx> Hm...
06:22:03 <CosmicRay> TheStar: in many ways, when I saw Haskell, it struck me as the language I always wished Python was
06:22:23 <CosmicRay> TheStar: the haskell type system is great -- it's as inobtrusive as python's, yet catches type errors at cmopile time.
06:22:26 <CosmicRay> I love that.
06:22:33 <TheStar> CosmicRay, THat'd be nice.
06:22:45 <TheStar> At uni I'm always learning Java and C#, and likewise languages.
06:23:15 <basti_> i had java + prolog in a 3rd semester lab
06:23:20 <CosmicRay> wilx: http://www.python.org/peps/pep-3000.html has several "to be removed" sections, and they list lambda, map, and filter there
06:23:30 <basti_> i already knew a bit of java. but then, prolog was fun.
06:23:36 <TheStar> Sem1: C Sem2: Java Sem3(current): C#
06:23:37 <CosmicRay> TheStar: yeah, everbody gets something like that, but they're no fun
06:23:51 <basti_> i think every CS student should learn at least one wacko language.
06:23:53 <CosmicRay> pfft, three languages that are fairly similar to each other
06:24:01 <basti_> like, prolog, or haskell
06:24:06 <CosmicRay> basti_: yeah.  I got lisp, prolog, and c++.  still trying to decide which is wacko.
06:24:12 <basti_> -g-
06:24:12 * TheStar thinks every cs student should *invent* a language.
06:24:20 <basti_> oh i did that too.
06:24:22 <basti_> way back.
06:24:31 <basti_> with an interpreter in basic.
06:24:33 <basti_> :)
06:24:39 <basti_> [ ] did loops.
06:24:40 <ozone> basti_: problem is, most CS students will end up hating wacko language
06:24:45 <ozone> rather than learning why it's different ...
06:24:54 <basti_> ozone which wacko language? c++? :P
06:24:58 <CosmicRay> ozone: yes, I have a word for them.
06:25:02 <CosmicRay> ozone: "vb programmers" :-)
06:25:03 <basti_> -g-
06:25:15 <basti_> "managers"
06:25:17 <ozone> CosmicRay: no comment :)
06:25:18 <xerox> basti_: sounds BrainF*ck :)
06:25:20 <CosmicRay> haha
06:25:35 <basti_> xerox no it wasnt like that... rather like, stacked loop counters
06:25:38 <ozone> basti_: well, how many people do you know who understand prolog
06:25:39 <TheStar> I'm told BF can be very fast.
06:25:44 <ozone> as in, why it exists, why it's used in its domain, etc
06:25:56 * TheStar has never even seen prolog
06:26:01 <CosmicRay> ozone: you know, from what I remember of prolog, it reminds me somewhat of haskell
06:26:02 <basti_> ozone hmm i think at least about 10 people from that lab "got" it
06:26:17 <Philippa_> CosmicRay: when I did a course on it I took to describing it as "Haskell backwards"
06:26:20 <ozone> basti_: yeah, now extend those 10 people to your whole CS department
06:26:20 <basti_> haskell reminds me of prolog now and then
06:26:23 <CosmicRay> Philippa_: heh
06:26:33 <Philippa_> basti_: like when you use the List monad? :-)
06:26:34 <ozone> you think >50% of CS folks will understand why they're learning prolog instead of just programming it all in java instead?
06:26:35 <basti_> ozone well the entire semester was about 40 people at that point
06:26:36 <CosmicRay> Philippa_: fnuny, I describe Haskell as "OOP backwards" :-)
06:26:46 <basti_> Philippa_ no, when matching patterns
06:26:54 <basti_> ozone: no.
06:26:55 <ozone> CosmicRay: there's a pretty tight relation between logic programming and functional programming
06:26:55 <Philippa_> fair enough
06:27:01 <basti_> ozone: but they should not pass, then. I think.
06:27:14 <ozone> basti_: well, maybe not.  but that's another point entirely :)
06:27:18 <basti_> yes.
06:27:18 <basti_> =)
06:27:20 <TheStar> In general, I believe *all* languages suck when it comes to the gui.
06:27:22 <CosmicRay> ozone: yeah.  it seems especially clear with haskell and prolog, moreso than with the lisp that the university taught with prolog that semester.
06:27:47 <basti_> what i'd love to do in functional languages is unification.
06:27:49 <CosmicRay> ozone: haskell's laziness and pattern matching in function declarations especially helped with that
06:27:54 <basti_> i've heard it is possible, but i dont know how
06:27:55 <CosmicRay> in my mind at least
06:27:58 <Philippa_> TheStar: the problem is libraries rather than languages. Though Haskell's having a good go at producing some non-sucky libs
06:28:03 <musasabi> Do I just dream or will multi session GHC support mean free distributed compilation?
06:28:03 <basti_> (besides the obvious way of implementing it)
06:28:03 <ozone> CosmicRay: yep
06:28:18 <Philippa_> basti_: you write a unification algo?
06:28:19 <TheStar> Philippa_, I'm wondering if XMl really is the best way to do guis.
06:28:21 <wilx> Prolog gives me headaches >_<
06:28:21 <ozone> CosmicRay: i'm still surprised there's no standard backtracking monad library for haskell
06:28:27 <basti_> Philippa_ well yes.
06:28:39 <basti_> Philippa_ but you know, prolog does it all the time, and everywhere.
06:28:40 <ozone> as in, something which GHC supplies to you that you can just use, rather than wrapping some other monad library like the cont monad or so
06:28:41 <wilx> One needs to think too different to do anything.
06:28:43 <CosmicRay> ozone: whoa, that sounds interesting
06:28:51 <Philippa_> TheStar: It isn't. HTH, HAND
06:28:55 <basti_> i know it can because of its special structure
06:28:57 <CosmicRay> ozone: what about parsec?  not quite what you mean but, maybe close?
06:28:58 <ozone> only surprised due to the number of papers written abuot it
06:29:00 <JaffaCake> musasabi: what's mean free distributed compilation?
06:29:00 <TheStar> Philippa_, Explain.
06:29:23 <ozone> TheStar: check out mac os x's cocoa framework for GUI stuff
06:29:33 <Philippa_> TheStar: XML is crap in specialised instances. Therefore XML is not the best way to do anything other than interoperability
06:29:37 <ozone> i've not seen any better
06:29:42 <TheStar> ozone, I Seriously need to look at cocoa.
06:29:51 <TheStar> ozone, Especially given that I own a mac.
06:29:52 <CosmicRay> problem is, it's not portable, which hurts.
06:29:57 <Philippa_> a lot of GUIs end up involving some structures that resemble the one XML's built on, but that's about it
06:30:01 <ozone> TheStar: laugh, indeed
06:30:17 <ozone> CosmicRay: yeah, i wonder how daan did it
06:30:17 <basti_> I'd love to say something like "yadda 0 b = yadda a 1" in a language other than prolog, and then being able to use that statement in both directions
06:30:32 <CosmicRay> is cocoa the one that's similar to openstep?
06:30:36 <ozone> CosmicRay: i have some papers here if you're interested in doing backtracking in haskell
06:30:43 <Philippa_> basti: the full generality is a bit of a bugger to work with
06:30:44 <ozone> a backtracking monad, rather
06:30:48 <CosmicRay> ozone: not yet, but thanks :-)
06:30:49 <ozone> CosmicRay: basically, yes
06:30:56 <basti_> ozone urls? :)
06:31:04 <musasabi> JaffaCake: Well if GHC will support multiple sessions, could one not drive a it on top of distributed haskell and forkIO the actual compilations? Although sharing filesystem would be problematic.
06:31:07 <Philippa_> but a backtracking monad with unification support might be a place to start. You'd end up with a UVar type and so forth
06:31:19 <ozone> basti_: heh, if you google for "haskell backtracking", you'll probably get a ton of relevant hits
06:31:23 <basti_> hmmk
06:31:29 <ozone> in fact, the first one seems rather good :)
06:31:33 <JaffaCake> musasabi: sure, there's no problem with that
06:31:48 <CosmicRay> ozone: either that, or a ton of hits about the haskell native americans hunting practices :-)
06:32:26 <JaffaCake> musasabi: but multiple sessions is like multiple --make's running under one GHC, whereas I think you want to compile multiple modules in parallel within a single --make
06:33:15 <ozone> we have a distghc honours project up for grabs at our uni :}
06:33:18 <JaffaCake> the latter is quite possible too... a couple of IORefs need to turn into MVars (or TVars), but that's about it
06:33:57 <basti_> oh wow. ok
06:34:03 <basti_> o.0
06:34:06 <musasabi> nice :-)
06:35:13 * ozone wants associated data types in GHC before distributed GHC
06:35:18 <ozone> :D
07:19:08 <wilx> >_<
07:29:58 <boegel> wilx: taking a dump ?
07:30:08 <wilx> lol
07:30:12 <wilx> Nope.
07:30:22 <boegel> what then ?
07:31:32 <wilx> Realizing that either I will use STArray and will have to do everything in ST monad or I  will use Data.Map or maybe IntMap and will lose O(1) lookup.
07:32:11 <musasabi> IntMap is quite fast. and you can contain ST computations inside pure functions.
07:33:16 <ozone> wilx: try using a finite map
07:33:21 <ozone> or as musasabi said, a map
07:33:50 <ozone> you'll probably be surprised that the performance is good.  at least for quite a few cases i've seen where arrays seemed optimal, maps outperformed them
07:34:00 <wilx> Yeah, but trading O(1) for O(log N) doesn't make me feel comfortable :/
07:34:10 <wilx> Huh.
07:34:12 <wilx> Ok.
07:34:28 <ozone> the difference between theory and practice is small in theory, but big in practice ;)
07:36:25 <wilx> What is the W in O(min(n,W)) for IntMap?
07:39:36 <Philippa> <musasabi> IntMap is quite fast. and you can contain ST computations inside pure functions. <- but then you have to contain the ST-based values inside them as well
07:42:25 <musasabi> Philippa: runST ?
07:42:36 <Arsilan> h
07:42:36 <Arsilan> h
07:42:36 <Arsilan> h
07:42:37 <Arsilan> h
07:42:37 <Arsilan> h
07:42:37 <Arsilan> h
07:42:38 <Arsilan> hh
07:42:40 <Arsilan> h
07:42:42 <Arsilan> h
07:42:45 <Arsilan> h
07:42:49 <Arsilan> h
07:42:50 <Arsilan> h
07:42:52 <Arsilan> h
07:42:54 <xerox> ..askell?
07:42:54 <Arsilan> h
07:42:57 <Arsilan> h
07:42:58 <Arsilan> hh
07:43:01 <Arsilan> h
07:43:02 <musasabi> What I meant is that you can perform ST-based computations and return their result and the result is pure.
07:43:03 <Arsilan> h
07:43:04 <Arsilan> h
07:43:05 <TheHunter_> @seen shapr
07:43:05 <lambdabot> I saw shapr leaving #haskell.se 22 hours 2 minutes 46 seconds ago.
07:43:07 <Arsilan> h
07:43:09 <Arsilan> h
07:43:10 <Arsilan> h
07:43:12 <Arsilan> h
07:43:16 <musasabi> well /ignore is a friend.
07:43:18 <Arsilan> h
07:43:22 <Arsilan> h
07:43:25 <Arsilan> h
07:43:25 <wilx> omh
07:43:26 <Arsilan> h
07:43:29 <Arsilan> h
07:43:30 <Arsilan> h
07:43:32 <Arsilan> h
07:43:33 <xerox> No one can do anything?
07:43:34 <Arsilan> h
07:43:36 <Arsilan> h
07:43:39 <Arsilan> h
07:43:40 <Arsilan> h
07:43:42 <TheHunter_> Arsilan, shut the hell up!
07:43:42 <Arsilan> h
07:43:45 <Arsilan> h
07:43:48 <Arsilan> h
07:43:50 <musasabi> xerox: You can do "/ignore Arsilan"
07:43:50 <Arsilan> h
07:43:52 <Arsilan> h
07:43:54 <Arsilan> h
07:43:56 <Arsilan> h
07:43:59 <Arsilan> h
07:44:00 <wilx> Yay!
07:44:00 <Arsilan> h
07:44:02 <wilx> Works :)
07:44:03 <Arsilan> h
07:44:05 <Arsilan> h
07:44:06 <Arsilan> h
07:44:08 <Arsilan> h
07:44:10 <Arsilan> h
07:44:12 <Arsilan> h
07:44:19 <Arsilan> h
07:44:21 <Arsilan> hh
07:44:22 <Arsilan> h
07:44:24 <Arsilan> h
07:44:25 <Lunar^> Do people saw http://code.google.com/ ?
07:44:26 <xerox> :(
07:44:26 <Arsilan> h
07:44:29 <Arsilan> h
07:44:31 <Arsilan> h
07:44:32 <Arsilan> h
07:44:35 <Arsilan> h
07:44:36 <Arsilan> oki
07:44:38 <Lunar^> "goopy/functional: This library brings functional language attributes to python."
07:44:38 <wilx> How can one handle people like this on FreeNode except using /ignore?
07:44:38 <Arsilan> shut up
07:45:15 <Arsilan> well ask me politely
07:45:22 <musasabi> wilx: wait till one of the ops wakes up and does /kickban
07:45:32 <Arsilan> to shut up
07:45:45 <pesco> Why does "he" do that?
07:45:45 <musasabi> Arsilan: to get politeness you should probably start by being polite.
07:45:47 <wilx> Ops?
07:45:52 <JaffaCake> Lunar^: haven't actually looked at it yet, but seems they have some interesting bits of code
07:46:20 <Arsilan> yeah, oki doki
07:46:40 <pesco> Er, that wasn't a bot?
07:46:46 <pesco> What in the hell?
07:46:47 <musasabi> no..
07:47:07 * musasabi is not sure whether I want to understand
07:47:30 <pesco> Maybe you're right.
07:49:34 <Lunar^> Google frightens me
07:50:35 <Lunar^> It's like my daily life depends on Google a bit more each day
07:51:24 <wilx> Hmm, SourceForge or Google, what's the difference?
07:54:25 <CosmicRay> wilx: google doesn't have a serious Systemwide Catastrophe (TM) every month?
07:54:41 <CosmicRay> wilx: google's CVS servers work?
07:54:48 <CosmicRay> wilx: google's ads aren't annoying?
07:54:53 <CosmicRay> wilx: stop me anytime :-)
07:55:03 <wilx> lol
07:55:07 <wilx> I have no idea :))
07:55:20 <CosmicRay> :-)
07:55:58 <CosmicRay> wilx: I hope you can sense the amazing level of apreciation I have for sourceforge.
07:56:34 <wilx> So, you're saying that Google is actually better?
07:56:36 <tuomov> It annoys me whenever I have to download software from them
07:56:47 <tuomov> the javascript download kludge is awful
07:56:55 <tuomov> why not just provide direct links to all the mirrors?
07:57:00 <CosmicRay> wilx: I'm saying that MS-DOS 2.0 is actually better.
07:57:08 <CosmicRay> tuomov: ugh.  I HATE THAT.
07:57:08 <wilx> Hehe.
07:58:06 <CosmicRay> that's right, many of the world's best free software projects storing their files with a company that's been bankruptcy-free since 2003!  And proudly announces a "site upgrade" everytime they manage to get their cvs server working again!
07:58:42 <CosmicRay> and laid off all the people that actually had a clue back when it started...
07:58:59 <wilx> Heh.
07:59:02 <wilx> really?
07:59:10 <CosmicRay> yeah
07:59:24 <CosmicRay> back when it was VA Linux Systems, they employed a number of top-notch hackers
07:59:29 <CosmicRay> people like joey hess
07:59:47 <CosmicRay> these guys were their sysadmins and wrote the early sourceforge versions, I believe
08:00:01 <CosmicRay> then when VA "got out of the Linux business", they laid off all their good tech people
08:00:09 <CosmicRay> probably kept the marketing department, who knows
08:00:15 <wilx> Heh.
08:00:46 <CosmicRay> I know this for a couple of reasons.  1) joeyh is a debian developer, and moved across the country to california to work for them
08:00:58 <CosmicRay> 2) I turned down a job offer from them once because I did not want to move to california :-)
08:01:05 <wilx> :))
08:01:25 <CosmicRay> 3) joeyh and the other clueful people got laid off about a year later
08:02:44 <CosmicRay> wilx: by all means, please use sf.net for all your, err, java code!
08:02:53 <wilx> :S
08:02:56 <wilx> I do no Java.
08:03:13 <CosmicRay> wilx: ahh, a redeeming quality :-)
08:03:20 <wilx> :))
08:03:33 * CosmicRay is either on a roll today, or embarassing himself horribly.
08:03:38 * CosmicRay doesn't know which :-)
08:03:46 <wilx> Nah, you are fine :)
08:03:56 <CosmicRay> :-)
08:06:04 <CosmicRay> hello ex_nor
09:04:37 <vegai> whoa
09:04:53 <vegai> I wonder if this is a little far-fetched... from "The Haskell Road to Logic, Math and Programming":
09:05:16 <vegai> "The programming language that will be our tool for this is Haskell, a member of the Lisp family."
09:07:55 <stepcutHM> heh
09:09:25 <araujo> see it as the step-son of Lisp
09:09:52 <kosmikus> I don't like it either, but one can argue that it's true
09:10:11 <araujo> greetings kosmikus
09:10:25 <kosmikus> hi there
09:11:01 <musasabi> kosmikus: any ideas for a cabal ebuild?
09:11:08 <musasabi> s/ebuild/eclass.
09:12:02 <kosmikus> there is an ebuild, or not?
09:15:48 <musasabi> kosmikus: well GHC6.4 has it as built-in.
09:16:24 <musasabi> kosmikus: what I am interested in is an eclass, for packages using Cabal for building.
09:17:38 <kosmikus> I meant, there is a cabal ebuild; and in there I have already made some functions, that could probably be used in an eclass in some time
09:18:02 <kosmikus> but currently, there's a lack of cabal-based packages to actually see what's needed
09:18:12 <kosmikus> are you creating an ebuild for something?
09:19:15 <musasabi> kosmikus: I could do ebuilds for the libraries I use, because currently I am using them outside portage.
09:20:56 <kosmikus> which libraries?
09:21:34 <musasabi> e.g. lzf compression, and when I get around releasing the binary serialization stuff ;)
09:25:44 <kosmikus> ok
09:31:02 <wilx> musasabi, what kind of interface does your compression have?
09:31:20 <wilx> Do you give it a list of bytes and get a list of bytes or something?
09:32:09 <musasabi> wilx: it has a convenience interface to Strings, but I really use the raw Ptr interface only.
09:32:48 <wilx> Oh.
09:32:53 <wilx> Hmm.
09:40:20 <tromp> nothing finds bugs better than porting a program to several different languages:)
09:41:05 <wilx> Bah.
09:41:17 <wilx> I just cannot wrap my head around this...
09:41:35 <Cale> metaperl_: digesting MonadsAsContainers still?
09:41:48 <Cale> I noticed that you were talking about it above
09:42:06 <wilx> So, it seems I want to use MonadReader but it seems that one cannot update the environment and that confuses me...
09:42:08 <metaperl_> I'm pretty much through it...
09:42:21 <metaperl_> it was a useful exercise
09:42:30 <metaperl_> I will move on to the nomaware tutorial next
09:43:13 <wilx> @wiki MonadsAsContainers
09:43:13 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
09:45:26 <TheHunter_> @type Control.Monad.Reader.local
09:45:27 <lambdabot> Control.Monad.Reader.local :: forall r m a.
09:45:27 <lambdabot> 			      (Control.Monad.Reader.MonadReader r m) =>
09:45:27 <lambdabot> 			      (r -> r) -> m a -> m a
09:45:58 <TheHunter_> so you can update the environment, but only for a subexpression.
09:46:03 <wilx> Hmm, I see.
09:49:42 <TheHunter_> (do x <- local (+1) ask; y <- ask; return (x,y)) 0
09:49:46 <TheHunter_> ==> (1,0)
09:49:58 <TheHunter_> (do x <- (modify (+1) >> get); y <- get; return (x,y)) `evalState` 0
09:50:01 <TheHunter_> ==> (1,1)
09:51:41 <Cale> metaperl_: cool, did you try the Tree example?
09:58:27 <wilx> Ah!
09:58:35 <wilx> Something is getting brighter!
09:58:53 <TheHunter_> hmm, i guess MonadState s m => MonadReader m s would make some sense...
09:59:10 <TheHunter_> s/m s/s m/
10:00:37 <TheHunter_> what's the matter with me? class MonadReader s m => MonadState s m, of course.
10:01:19 <wilx> Hmm, I think I am making things too complicated...
10:05:56 <wilx> Yeah, seem so. MonadReader looks like MonadState with some special features :)
10:06:08 <wilx> Read only and local...
10:06:11 <wilx> Hmm...
10:06:36 <wilx> So.
10:06:45 <TheHunter_> local m = do s <- get; x <- m; put s; return x
10:09:12 <wilx> My LZWEncState will be state and the resulting LZW indice will be result. Right.
10:09:20 <wilx> I've finally made up my mind.
10:14:20 <pesco> Are spaces in filenames evil?
10:15:08 <wilx> Hm, I would not so much. :)
10:15:23 <wilx> Errr.
10:15:31 <wilx> Insert say to the appropriate place.
10:15:36 <TheHunter> no, but dots or underscores instead of spaces because someone fears spaces'd be evil are.
10:15:55 <pesco> TheHunter: That's true.
10:16:35 <wilx> Gagh!
10:16:36 <wilx> So.
10:16:38 <wilx> Again.
10:16:45 <wilx> Context is state.
10:17:18 <wilx> Then I have (Maybe Code) and so far uncompressed part of input of type [a].
10:17:44 <wilx> Aaaaaa!!!
10:18:02 <wilx> I am so indecisive.
10:19:07 <wilx> Maybe I should use [Code] as the writer part... and [a] as result which would mean I would use RWS...
10:19:10 <wilx> Huh.
10:25:47 <Cale> you can solve indecision using abstraction :)
10:26:01 <Cale> what operations do you need?
10:59:38 <Lemmih> Good morning, #haskell.
11:00:05 <pesco> Morning, Lemmih.
11:08:37 <CosmicRay> heh, iblechbot
11:09:57 <stepcut> so, i think I want to make a number class for handling financial numbers
11:10:44 <stepcut> but I can't seem to find good information on what is accepted practice
11:10:47 <stepcut> :-/
11:11:19 <stepcut> I got a book on accounting, and it did not really cover how to split a dollar three ways, for example
11:12:24 <pesco> When are we _finally_ going to get *real* currency!?
11:12:44 <stepcut> pesco: you mean the euro ?
11:12:44 <stepcut> :p
11:12:48 <CosmicRay> pesco: when the US stops importing billions more from china than it exports? :-)
11:13:09 <stepcut> I do want my number class to have units so you can't accidental mix dollars and euros!
11:14:07 <stepcut> I'll just put all the left over fractional cents in my bank account I guess :p
11:14:11 <CosmicRay> hmm
11:15:02 <CosmicRay> sounds like Data Currency = Currency String Rational
11:15:06 <CosmicRay> s/Data/data/
11:15:59 <CosmicRay> stepcut: pretty easy, eh? :-)
11:16:31 <stepcut> only if Rational is exact
11:16:43 <pesco> It is.
11:16:50 <stepcut> And I don't think I would want to represent the currency as a String...
11:17:51 <stepcut> and I think I would probably want a instances of +,-, etc
11:17:56 <CosmicRay> stepcut:
11:17:59 <CosmicRay> type Rational = Ratio Integer
11:17:59 <CosmicRay> Arbitrary-precision rational numbers, represented as a ratio of two Integer values. A rational number may be constructed using the % operator.
11:18:17 <CosmicRay> sure, you can just make it an instance of Num, Ord, Show, Read, and Ratio
11:18:20 <CosmicRay> it'll be quite nice.
11:18:27 <CosmicRay> what would you represent the currency as?
11:18:41 <stepcut> abstract type maybe ?
11:18:42 <CosmicRay> if it's anything else, you'd probably have to re-build the library everytime something changes in the world currency markets
11:18:44 <musasabi> Why not use newtype Currency = Currency Integer ?
11:19:02 <musasabi> make that Currency a = Currency Integer
11:19:05 <pesco> stepcut: So you want  class Num c => Currency c where name :: String; rus :: c -> Rational  ?
11:19:15 <CosmicRay> musasabi: because it doesn't represent which currency it is (USD, etc.), and also, it doesn't represent fractions
11:19:22 <pesco> rus = reference units
11:19:35 <CosmicRay> Ratio is the only sane choice because it can also represent pre-decimalization British currency :-)
11:19:38 <musasabi> CosmicRay: but aren't currencies fixed precision?
11:19:52 <CosmicRay> not in Britain prior to 1971? I think
11:20:17 <musasabi> CosmicRay: so you did bookkeeping with rationals there?
11:20:18 <CosmicRay> also the US stock market used fractional values up until just a few years ago
11:20:31 <stepcut> the gas station still does...
11:20:40 <CosmicRay> musasabi: well, if you're restricting to US values, one would probably just use an integer
11:20:49 <musasabi> So how do you pay for 1/3 monetary unit ?
11:20:52 <CosmicRay> musasabi: a double is even used in some cases
11:21:09 <stepcut> some US accounting systems use 1/10 cent precission
11:21:15 <CosmicRay> musasabi: your broker, for instance, would round to the nearest cent when buying things.
11:21:26 <CosmicRay> musasabi: in britain, they had coins that were 1/12 of a pound, I believe
11:21:30 <CosmicRay> stepcut: even more than that
11:21:51 <CosmicRay> stepcut: if you're in manufacturing, say, and you are tracking the cost of an item that you use 100,000 times in a day...
11:21:56 <CosmicRay> it can be a big deal.
11:22:33 <stepcut> indeed! that is why I am looking for something from GAAP, or the like, that talks about what CPAs actually do in practice
11:22:36 <musasabi> CosmicRay: didn't they have a smaller unit (penny?) ?
11:22:59 <musasabi> but you have a point.
11:23:19 <Philippa> <CosmicRay> musasabi: in britain, they had coins that were 1/12 of a pound, I believe <- yes, pre-decimalisation our system was a bit screwed up...
11:23:22 <CosmicRay> musasabi: from memory, they had a pound, schilling, penny, crown, guinea...
11:23:35 <CosmicRay> I don't remember exactly
11:24:00 <CosmicRay> I looked it all up once so I could understand sherlock holmes books better, and translated it into modern dollars, accounting for inflation :-)
11:24:25 <Philippa> no c in shilling
11:24:26 * musasabi takes a note to not look into historical british currencies if not forced
11:24:27 <stepcut> in US currently, a bit is 12.5cents or 1/8 of a dollar, i think..
11:25:30 <CosmicRay> yeah, but that's a pretty much outdated unit
11:26:01 <CosmicRay> http://gouk.about.com/cs/literature/l/blbritcurr.htm
11:26:33 <CosmicRay> apparently, I left out the farthing, silver threepence, florin, nobel, and sovereign!
11:26:50 <CosmicRay> and silly me, the farthing circulated from 1279 through 1956! :-)
13:01:02 <shapr> @yow !
13:01:02 <lambdabot> Sorry, wrong ZIP CODE!!
13:01:07 <shapr> wazzup?
13:02:08 * Lemmih pokes shapr.
13:02:13 * shapr pokes back
13:02:24 <shapr> pokes and peeks may wipe my memory but...
13:02:28 <shapr> what was I saying?
13:03:43 <musasabi> evening
13:03:49 <shapr> y0 musasabi, how's code?
13:04:02 <xerox> yo shapr
13:04:06 <shapr> hiya xerox
13:05:22 <Lunar^> shapr: hi
13:05:29 <shapr> salut Lunar^, ca va?
13:05:37 <Lunar^> shapr: plutt bien, merci :)
13:06:05 <shapr> essayez vous House avec net?
13:06:17 <Lunar^> O'Caml still disgust me, but they revamped their homepage
13:06:40 <Lunar^> shapr: not yet.. I would like to finish HFuse for my next Haskell work next session
13:06:44 <Lunar^> s/for/during/
13:07:01 <shapr> I'd like to use HFuse also.
13:07:44 <Lunar^> shapr: I have a lot of work for my compiler and semantics classes though
13:08:11 <Lunar^> shapr: And I'm somehow afraid by the panel for  LSM OS/Kernel track
13:08:11 <shapr> pas de problem
13:08:25 <shapr> You'll do fine :-)
13:08:54 <Lunar^> Yeah, sure, they've invited every name I suggested ;)
13:09:30 <Lunar^> http://2005.rencontresmondiales.org/sections/conference/noyau_et_systeme
13:10:15 <Muad_Dibber> HFuse?
13:10:31 <Lunar^> Muad_Dibber: A binding for the Linux FUSE library
13:10:38 <Muad_Dibber> mmkay
13:11:05 <Muad_Dibber> you creating a compiler?
13:12:17 <Lunar^> Muad_Dibber: at university, throughout the compiler course
13:12:32 <Lunar^> as usual, would I say
13:12:57 <Muad_Dibber> indeed :)
13:13:14 <Muad_Dibber> but i learned that a compiler using stratego is way more easier than using haskell
13:13:21 <Muad_Dibber> probbly you also doing stuff with attribute grammars?
13:13:30 <shapr> Lunar^: that's a nice list
13:13:50 <shapr> Lunar^: and I notice it's using Localizer ;-)
13:14:06 <Lunar^> shapr: Oh, yeah! That's freaking me out :)
13:14:28 <Lunar^> shapr: There's Ewout from JNode, and Shapiro from EROS/Coyote/BitC
13:14:41 <shapr> very nice
13:15:19 <shapr> UML, Bossa, and HURD are also interesting.
13:15:23 <Lunar^> shapr: I don't know how I would not feel crap in front of them, but yeah, it'll be interesting
13:15:33 <Lunar^> shapr: There's a problem for Bossa, though, I need to mail Thomas
13:15:41 <Lunar^> shapr: Bossa's compiler isn't free
13:20:41 <wagle> whats bossa's compiler?
13:20:54 <wagle> tempo?
13:21:42 <musasabi> shapr: quite slow, haven't gotten much done in the past few days.
13:21:56 <musasabi> shapr: I think I'll have time tomorrow for something productive :-)
13:22:52 <wagle> Lunar^: what's bossa's compiler?  tempo?
13:23:17 <Lunar^> wagle: http://www.emn.fr/x-info/bossa/
13:23:17 <shapr> I've been fighting Zope's Ape, trying to get it to serialize my own archetypes so I can permanently escape the ZODB.
13:23:24 <Lunar^> wagle: cb.opt on that webpage
13:23:29 <Lunar^> wagle: I don't know anything else
13:23:53 <Lunar^> wagle: It might be based on Tempo
13:26:11 <shapr> Lunar^: any other bands like Spook and the Guay?
13:26:13 <wagle> well, most all the old tempo people are working on bossa now
13:26:48 <wagle> i hadnt gotten around yet to actually giving it a whirl, though
13:29:06 <shapr> musasabi: did you have a modified Network.CGI that handled file uploads?
13:29:19 <shapr> greetings type-error, how's your FP adventure?
13:29:48 <type-error> shapr: ah it's basically over with my course that ended in january :)
13:29:55 <type-error> but i still drop by once in a while
13:30:15 <shapr> Have you had a chance to write anymore Haskell?
13:30:16 <Lunar^> shit
13:30:28 <Lunar^> I've just hit Goerzen's mail
13:31:02 <type-error> shapr: not really, fired up hugs sometime to play a little
13:31:03 <Lunar^> he seems do be working on another FUSE binding
13:31:14 <Philippa> type-error: see how you feel when you end up with a project that's a good fit for Haskell - I found that's the real way to jump in seriously
13:31:27 <shapr> Lunar^: you should collaborate! John Goerzen is CosmicRay here on #haskell
13:31:41 <Lunar^> shapr: Yeah, I've just remembered that :)
13:35:39 <Lunar^> shapr: I've just sent him a mail
13:35:41 <shapr> cool
13:36:51 <wagle> Lunar^: hmm..  thanks for reminding me about bossa..  8)
13:37:50 <Lunar^> wagle: We're in contact with Muller and Lawall to add Bossa support to GHC RTS
13:38:27 <musasabi> shapr: no..
13:38:39 <wagle> Lunar^: who is "we"?
13:39:03 <musasabi> shapr: I think that needs quite much hacking.
13:39:08 <Lunar^> wagle: another student from my university
13:39:21 <musasabi> shapr: as one cannot really use a String for file uploads in anything but a toy application.
13:40:26 <shapr> it would be sufficient for gpg-signed darcs patch uploads though.
13:40:39 <shapr> er, base64 encoded
13:41:00 <Philippa> yeah, it'll survive for something that's not seeing hugely heavy use
13:41:21 <Philippa> the CPU will hate you though
13:42:26 <wagle> Lunar^: cool, how about lemeur?
13:43:40 <Lunar^> wagle: I don't know
13:45:16 <musasabi> I think about 1.6mb / 100k upload.
13:45:23 <shapr> eek
13:47:12 <shapr> hei vegai
13:47:19 <musasabi> usage n = 16.0 * n * kb / kb^2 where kb = 1024
14:04:41 * Lemmih bounces.
14:04:49 * boegel joins Lemmih
14:04:50 <Lemmih> 8 down, 40 to go.
14:05:01 <boegel> Lemmih: ?
14:05:33 <Lemmih> boegel: Porting NeHe lessons to SDL/HOpenGL.
14:05:58 <boegel> I have _no_ clue what that means, but what the hey :p
14:06:47 <Lemmih> nehe.gamedev.net has a couple of tutorials which I'm rewriting in Haskell.
14:07:19 <boegel> Lemmih: nice :)
14:07:53 <boegel> how's the efficiency in Haskell ?
14:09:37 <Lemmih> Very close to the speed of the native C apps.
14:09:54 <boegel> Lemmih: nice !
14:10:14 <boegel> is there any raytracing in OpenGL ? (I don't know much about it)
14:11:32 <_JusSx_> what's the best haskell compiler?
14:11:46 <boegel> there only one as far as I know... GHC
14:11:51 <Lemmih> _JusSx_: Depends on what you need.
14:11:52 <dons> ghc (though depends onn what you mean by best)
14:11:52 <musasabi> _JusSx_: GHC is the most popular answer to that.
14:11:53 <_JusSx_> ok
14:12:01 <_JusSx_> thanx
14:12:17 <musasabi> boegel: e.g. nhc98 and hbc exist too.
14:12:44 <thunkee> hmm is there a x86_64 ghc for linux?
14:12:49 <boegel> musasabi: never heard of them
14:13:09 <Lemmih> boegel: I'm not really qualified to answer. Haven't used OpenGL very much.
14:13:11 <musasabi> well hbc is quite dead. haskell.org/nhc98 for nhc.
14:13:24 <dons> boegel: come on - we talk about them all  the time on this channel :)
14:13:40 <boegel> Lemmih: but you did rewrite the tutorials... is there any raytracing in them so far ?
14:13:42 <musasabi> thunkee: yes.
14:13:48 <boegel> dons: you do ? :)
14:14:07 <dons> I do, Igloo does, CosmicRay does sometimes, I'm sure others do. http://www.haskell.org/implementations.html
14:14:57 <dons> there's also Helium, of course - anyone know if they plan to add H98 typeclasses?
14:15:09 <thunkee> only for fedora
14:15:13 <shapr> Lemmih: hey, I patched some of your nehe OpenGL demos, but I couldn't submit the patches, of course.
14:15:17 <Lemmih> boegel: One of the tutorials had a light source... not sure if that's what you want.
14:16:18 <boegel> Lemmih: just curious if OpenGL uses some form of raytracing...
14:16:22 <Lemmih> shapr: I don't really maintain them. SDL is a lot more friendly than GLUT.
14:17:11 <musasabi> thunkee: for what linux would you need it?
14:17:24 <thunkee> musasabi: i use suse
14:17:49 <Lemmih> shapr: If I got working darcs then I could update the tutorials and you could host my sdl binding (:
14:18:33 <thunkee> musasabi: just read about ghc that i should take binaries instead of src esp. for an unusual (64bit) hw
14:19:02 <musasabi> thunkee: doesn't suse use RPM too?
14:19:18 <thunkee> musasabi: yes suse is a rpm distri
14:19:29 <musasabi> thunkee: so why not try that rpm?
14:19:52 <dons> thunkee: you requrie a ghc binary installed to build ghc, this is less likely to be the case on a 64 bit arch, hence the binary recommendation
14:21:31 <thunkee> at first i will try the fedora rpms
14:21:43 <thunkee> although hugs runs fine :)
14:22:02 <Lunar^> CosmicRay: hi!
14:22:07 <CosmicRay> hi lunar
14:31:16 <Igloo> Speaking of which, anyone know anything about zinc-compiler?
14:31:29 <Igloo> (http://packages.debian.org/unstable/devel/zinc-compiler)
14:33:48 <shapr> Igloo: nothing except that it exists, I checked it out when it first hit debian a few days ago.
14:33:57 <musasabi> http://zinc-project.sourceforge.net/
14:34:01 <yonkeltron> GOOD SHABBOS!
14:34:18 <shapr> I am not a shabbo!
14:34:35 <shapr> shalom yonkeltron
14:34:57 <CosmicRay> well.
14:35:03 <shapr> y0 CosmicRay
14:35:04 <CosmicRay> I understood "shalom" in all of that. :-)
14:35:06 <CosmicRay> hi shapr
14:35:21 <CosmicRay> got some asterisk hardware today, woohoo
14:35:24 <shapr> spiffy!
14:35:33 <CosmicRay> got more (theoretically) coming tomorrow
14:35:40 <dons> Igloo: huh!
14:35:48 <CosmicRay> fedex says it'll be delivered tomorrow, but I don't believe em
14:35:49 <stepcut> CosmicRay: sweet!
14:36:00 <shapr> Lemmih: I tried to figure out file upload via Haskell, seems to be not easy, so I'll try SASL again.
14:36:07 <kosmikus> hmm, I don't even know Curry; has anyone here tried it?
14:36:11 <kosmikus> :)
14:36:18 <CosmicRay> kosmikus: great with chicken
14:36:31 <shapr> Isn't that Lennart Augustsson's thingy?
14:36:34 <stepcut> CosmicRay: any idea how hard/possible it would be to write 'built-in' asterisk applications in haskell (as opposed to using the AGI)
14:36:56 <CosmicRay> stepcut: hmm.  well, it can load .so's at runtime, right?
14:37:06 <CosmicRay> stepcut: I guess we'd need to get ghc support for compiling to a .so to work
14:37:17 <CosmicRay> saw something about it working on osx in the 6.4 release notes
14:37:18 <kosmikus> shapr: no, I think you're confusing that with Cayenne
14:37:19 <Lemmih> shapr: I got some CGI uploading code in Hackage.
14:37:36 <CosmicRay> stepcut: or, perhaps it could link into the executable directly
14:37:37 <shapr> kosmikus: ah, right
14:37:42 <CosmicRay> stepcut: that would probably be not too bad
14:37:48 * stepcut has no idea :-/
14:37:52 <kosmikus> I think Curry is a language developed in Germany, possibly in Muenster by Herbert Kuchen and others
14:37:59 <dons> CosmicRay: Wolfgang Thallerr hacked the native gen to produce relocatable objects, so you can use the system dyn linker.
14:38:05 <dons> s/rr/r/
14:38:09 <CosmicRay> stepcut: I think the general approach, though, is to use AGI wherever possible
14:38:17 <stepcut> CosmicRay: indeed
14:38:19 <CosmicRay> dons: works on linux?
14:38:31 <kosmikus> no, seems to be Kiel
14:38:33 <shapr> -fThaller
14:38:34 <dons> hmm. he's looked at it. maybe it works. probably not fully.
14:38:39 <stepcut> CosmicRay: are you working on a module for interfacing to the AGI ?
14:38:56 <shapr> I thought -PIC worked for x86 and ppc?
14:39:03 <CosmicRay> shapr: it does
14:39:16 <shapr> What's the difference between .so and pic?
14:39:17 <CosmicRay> stepcut: I was going to, but then I got everything I need done in the dialplan, so probably not at the moment
14:39:20 <dons> ok. maybe all's good then.
14:39:27 <CosmicRay> .so is where PIC is stored.
14:39:32 <stepcut> CosmicRay: heh
14:39:32 <CosmicRay> PIC == position-independent code
14:39:37 <dons> there's just been so many patches, and I didn't see too many tested in x86.
14:39:48 <CosmicRay> stepcut: I'm very much of a "don't write code until I'm annoyed by something" sort of guy
14:39:49 <shapr> How can we test the PIC code in 6.4?
14:39:51 <stepcut> CosmicRay: yeah, there built-in power is pretty useful
14:40:07 <musasabi> PIC support is best on OS-X.
14:40:18 <dons> but, does best == only ?
14:40:21 <shapr> Which makes sense, as that Thaller's OS of choice.
14:40:32 <CosmicRay> dons: from what I recall of the release notes, yes, for now
14:40:37 <dons> @seen tuomov
14:40:37 <lambdabot> tuomov is in #haskell.
14:40:42 <shapr> tuomov: good morning!
14:41:00 <dons> tuomov: played with wmi or wmii?
14:41:12 <shapr> Man, I want some free quality sci-fi or fantasy. I've read everything on baen.com/library
14:41:35 <dons> anyone else played with wmi?
14:41:45 <shapr> url?
14:41:48 <dons> "The vim of window managers"
14:41:53 <CosmicRay> shapr: you mean, book form, or tv form?
14:42:07 <musasabi> shapr: libraries can be quite good..
14:42:10 * CosmicRay runs away screaming COLON QUEUE EXCLAMATION ENTER!!!
14:42:12 <dons> shapr: http://wmi.modprobe.de/
14:42:13 <shapr> CosmicRay: I don't much like tv form, the input speed is too low.
14:42:36 <shapr> hiya jyasskin
14:42:42 <jyasskin> hi, shapr
14:42:45 <shapr> How's code?
14:43:20 <jyasskin> I'm not sure how much you've heard from danb; we've got the EventLoop module mostly working
14:43:40 <shapr> spiffy
14:44:06 <tuomov> I've tried it a few times... very flaky
14:44:16 <shapr> Is there a darcs repo for the player?
14:44:29 <jyasskin> still needs some elaboration, and I expect as we use it we'll find other abbreviations to define.
14:44:47 <dons> tuomov: one of (or the?) author was interested in a haskell rewrite, or on my haskell wm-based-on-ion project. just tentative though.
14:45:01 <jyasskin> shapr: we're using arch, but the repo isn't public yet. I guess I'll get that done today
14:45:08 <tuomov> dons: a garbe?
14:45:17 <tuomov> I guess he's the main author
14:45:17 <CosmicRay> shapr: sometimes it is nice to have a low input speed
14:45:28 <CosmicRay> shapr: on another topic, ever seen babylon 5 or stargate?
14:45:44 <shapr> CosmicRay: I suspect you've never had a ritalin prescription.
14:45:53 <CosmicRay> ah
14:46:02 <shapr> jyasskin: cool, I'd like to see it when the repo is online.
14:46:15 * CosmicRay forgot about that
14:46:15 <tuomov> hm... wmi was c++ IIRC and wmii is C. Will wmiii be haskell? At least he's got lots of energy...
14:46:16 <dons> tuomov: someone in .de, anyway :} i don't have the email (msg came through my supervisor)
14:46:43 <CosmicRay> shapr: oh, you just need mythtv.  It can speed up tv programs by up to 2x and scales the audio frequency so it doesn't get high-pitched
14:46:55 <shapr> oh that would be *interesting* to try!
14:46:58 <CosmicRay> :-)
14:47:02 <dons> the gist was something like that. a complete haskell implementation, along with haskell scripting (scripting is what which wmi* seems to lack)
14:47:05 <shapr> Could I do that with existing DVDs, you think?
14:47:12 <CosmicRay> not with mythtv
14:47:22 <CosmicRay> I think it works only with its tv system
14:47:27 <tuomov> garbe(am) seems to be against scripting..
14:47:40 <tuomov> at leats he criticices ion for supporting such
14:48:03 <dons> yeah, saw that. maybe someone else. this guy just finished undergrad in .de
14:48:14 <jyasskin> shapr: oh, I forgot I did this smart. The archive's at http://jeffrey.yasskin.info/archives/hsaudio/ the project is hsaudio--main--0
14:48:26 <shapr> cool, I'll grab it.
14:48:33 <shapr> If I can remember how to drive tla...
14:48:58 <jyasskin> tla register-archive <uri>; tla get <project>; should work
14:49:01 <shapr> ok
14:49:25 <dons> tuomov: I see a garbe lists Haskell as his second language of interest..
14:49:40 <CosmicRay> jyasskin: make that tla get archive-name/project
14:49:47 <dons> hmm, and openbsd, and vi. :)
14:49:59 <shapr> and what part is the project?
14:50:09 <CosmicRay> the project is hsaudio--main--0
14:50:15 <CosmicRay> he didn't tell you his archive name
14:50:38 <CosmicRay> but it is hsaudio@jeffrey.yasskin.info
14:50:47 <tuomov> hmm..
14:51:00 <shapr> Shall I compare tla to a summer's day? or shall I compare it to darcs which would be really evil? =)
14:51:10 <CosmicRay> I knew this would happen
14:51:12 <CosmicRay> :-)
14:51:26 <tuomov> oh, ion also switched to darcs a while ago if someone didn't notice it already
14:51:27 <CosmicRay> it is quite true that tom lord must be getting bribes from carpal tunnel surgeons
14:51:41 <shapr> tom lord is darcs arch-enemy.
14:51:47 <CosmicRay> why?
14:51:50 <shapr> ARCH
14:51:55 <dons> tuomov: yeah! now we just have to switch lua to haskell :P
14:51:58 <CosmicRay> ha ha
14:52:02 <det> HAR
14:52:32 <tuomov> hah
14:53:05 <shapr> ok, I'm done whining about arch for the moment, what's the checkout command again?
14:53:09 <dons> though binding haskell to lua may be more productive
14:53:14 <stepcut> arch 1.3.1 was just released :)
14:53:32 <tuomov> it would be an interesting project to rewrite ion in haskell.. but I don't think I'll have the time
14:53:47 <shapr> You could rewrite Lua in Haskell...
14:53:55 <dons> hmm..
14:53:56 <xerox> Is there ghc6.4 .deb?
14:54:04 <tuomov> hmm.
14:54:06 <shapr> xerox: yes, debian/unstable
14:54:22 <xerox> shapr: do you know if it would be sane to install it on ubuntu?
14:54:31 <tuomov> it should be too big a work to convert the all the EXTL_EXPORT statements to FFI
14:54:43 <stepcut> xerox: absolutely not, you should install on linspire 5.0 only ...
14:54:44 <shapr> I don't know.
14:54:49 * CosmicRay must run
14:54:51 <tuomov> the all that is needed is to rewrite the few thousand lines of lua code in haskell
14:55:01 <dons> hmm. ok.
14:55:31 <dons> you think replacing lua would be easier than binding to lua?
14:55:43 <xerox> Is it ghc-cvs?
14:55:59 <tuomov> binding would probably be easier
14:56:04 <tuomov> but it shouldn't be too big a work to replace lua
14:56:13 <dons> a few thousand lines == honours project slave ;)
14:56:15 <xerox> This <http://packages.debian.org/unstable/devel/ghc6> seems to be 6.2
14:56:26 <tuomov> however, emulating tables may be a bit inconvenient in haskel
14:56:27 <stepcut> xerox: I think it is only in experimental right now
14:56:29 <shapr> xerox: um, maybe I'm wrong, haskell-unsafe.alioth.debian.org ?
14:56:42 <dons> tuomov: yeah. so that becomes the research component
14:56:45 <tuomov> Ion does expect tables that may contain elements indexed and having as value arbitrary tables
14:57:10 <dons> yeah, hence all that hlist and dynamic stuff we talked about, right?
14:57:29 <dons> it seems like an interesting ffi problem, in fact.
14:57:38 <tuomov> http://modeemi.fi/~tuomov/repos/libextl-3/luaextl.h
14:57:42 <Igloo> experimental has a slightly better deb than H-U
14:57:44 <tuomov> basically you need to provide that api to ion
14:58:15 <musasabi> tuomov: you could use StablePtrs in haskell.
14:58:16 <tuomov> I was more thinking of the internals in case of hlist
14:58:31 <tuomov> there are many lists with arbitrary WRegions
14:58:49 <musasabi> or just a datatype containing the cases.
14:59:04 <tuomov> but -fglasgow-exts and and an AnyRegion instance is quite good a solution there
14:59:09 <dons> I wonder if there are solutions in some of the binding to dynamically typed languages
14:59:23 <dons> the objective C bindings use a lot of existentials, iirc
15:00:16 <tuomov> AnyRegion would be an existential
15:00:27 <tuomov> there's just lots of work in writing the wrapper instances of all functions
15:00:35 <dons> yeah.
15:04:45 <Lunar^> Cabal rocks
15:04:56 <shapr> jyasskin: cute comments "Using unsafePerformIO is ok here ... (SPJ did it...)"
15:05:09 <dons> :)
15:05:21 <dons> better than "Don't look"
15:05:35 <shapr> Where's that from?
15:06:11 <dons> nowhere. but it's unsafeCoerce# that's more to be worried about, anyway.
15:06:53 <Lunar^> xerox: There's an x86 GHC 6.4 package in experimental AFAIK
15:07:44 <xerox> Lunar^: I found it in the haskell-unstable.*.debian link from shapr, thank you.
15:07:50 <xerox> (...and installed)
15:08:22 <Lunar^> xerox: cool
15:09:22 <Lunar^> Cabal just rocks, simply, purely
15:09:30 <Lunar^> It's damned easy
15:09:31 * shapr cheers for the Cabal
15:10:16 <bourbaki> moin
15:10:21 <shapr> greetz bourbaki
15:10:47 <dons> tuomov: if you're bored in the next couple of years, feel free to come down to .au and do some hacking :)
15:10:59 <Lemmih> Ops. It's past midnight. Time to unicycle!
15:11:33 <bourbaki> ... o.O
15:12:32 <shapr> jyasskin: cool ideas
15:12:50 <Lemmih> bourbaki: Unicycling at night is great because then there's no cars on the roads.
15:13:27 <bourbaki> i see
15:13:35 <shapr> I put my unicycle down just inside the front door of intersport while I was shopping, and when I came back, four kids were poking at it like it might bite them.
15:13:44 <Lunar^> lol
15:15:06 <shapr> This is the setup I want on my next unicycle - http://www.gb4mfg.com/temp/surly_monster/DSCF6220.JPG , 65mm rim, 3.7 inch tire. Mmmm!
15:16:58 <shapr> Right, back to coding =)
15:18:30 <tuomov> dons: it would be nice to visit that part of the world some time. I'll probably be doing a bit more mathematical stuff for the few following years, though.
15:19:18 <dons> mathematical stuff?
15:19:21 <Lunar^> cool
15:19:24 <Lunar^> I found a bug in Cabal
15:20:04 <tuomov> I have my M.Sc in (applied) maths and I'll probable be continuing studies somewhere along that line
15:20:21 <dons> cool!
15:20:53 * Lunar^ will wait for Syntax
15:21:09 <jyasskin> shapr: thanks :)
15:21:32 <dons> hope you find something interesting to work on.
15:23:13 <jyasskin> Are there any minimum gcc requirements for ghc 6.4? I haven't seen any stated, but it doesn't work with apple's gcc 3.3 build 1666.
15:23:32 <dons> hmm. gcc 3.3 is fine.
15:23:52 <dons> there's a codegen problem with large switches and gcc 2.95.x
15:24:05 <jyasskin> It gave me a "Unknown pseudo-op: .subsections_via_symbols" error
15:24:15 <dons> hmm. maybe some apple issue.
15:24:37 <dons> see if wolfgangT or one of the other mac guys have some recommendations
15:25:11 <jyasskin> I'm using wolfgangT's build, and upgrading to Apple's latest gcc fixed the problem.
15:25:24 <dons> (normally ghc cleans up the gunk that gcc produces, using the 'evil mangler', and the apple gcc tends to leave a lot of gunk)
15:25:42 <jyasskin> Is reporting a bug to sourceforge the right thing to do?
15:26:29 <dons> to ghc's sourceforge page? yes, it can't hurt. we'll ponder what is wrong, and one of the mac hackers will probably spot it. you could also email glasgow-haskell-bugs@haskell.org
15:26:39 <jyasskin> 'k, thanks
15:27:22 <dons> I see the mangler knows about this directive. hmm.
15:27:32 <dons> elsif ( $TargetPlatform =~ /-darwin/ && (/^\s*\.subsections_via_symbols/
15:27:41 <jyasskin> oh, it was build 1495, not 1666
15:28:46 <dons> I wonder why the mangler didn't catch it.
15:34:47 <Lunar^> mhh.. Cabal has no way to specify that it needs a threaded RTS
15:34:55 <Lunar^> s/it/the package/
15:38:07 <Lunar^> JaffaCake: Is there documentation anywhere about the "threadsafe" FFI flag?
15:38:36 <dons> Lunar^: in the ffi spec, surely?
15:39:18 <Lunar^> dons: I was thinking more specificaly about GHC
15:39:38 <dons> ok.
15:39:47 * dons goes src snooping
15:40:15 <Lunar^> dons: I have a problem with C->Haskell->C->Haskell
15:40:27 <Lunar^> dons: the second time, it just blocks
15:41:47 <Lunar^> http://www.reid-consulting-uk.ltd.uk/docs/ffi-Common_Problems.html#SECTION000301100000000000000 <- is unfortunately empty
15:41:52 <dons> there's some comment around prelude/ForeignCall.lhs:52.
15:42:05 <dons> not too detailed though
15:44:29 <Lunar^> dons: might do the trick, then
15:48:27 <Lunar^> dons: *sigh*, threadsafe doesn't help
15:49:00 <dons> hmm.
15:49:24 <Lunar^> I think I will release HFuse and let people pull their hair on that particular case
15:49:36 <Lunar^> maybe I am doing something wrong, I don't know
15:53:00 <Igloo> Are you compiling with -threaded?
15:53:12 <Igloo> (linking, I should say)
15:58:37 <desrt_gabriel> Igloo; i did a powerpc binary release for linux
15:58:45 <desrt_gabriel> (plz package for ubuntu) :)
16:00:28 <desrt_gabriel> i tried to do it myself, but there's all this scary debian rules business
16:01:12 * Igloo has the packaging done (although I haven't backported that patch you made a few days ago)
16:01:40 <desrt_gabriel> the only part of it that matters if you're building from source is the MachRegs.h part
16:01:48 <desrt_gabriel> the other thing only affects building binary dists
16:02:14 <Igloo> I'm not sure when binaries will become available, though. I'll probably try to look at the alpha problem first, if no-one else does
16:02:21 <Igloo> And Debian, not Ubuntu  :-P
16:02:29 <desrt_gabriel> whatever
16:02:32 <desrt_gabriel> :)
16:02:39 <desrt_gabriel> i'm a freeloading ubuntu user
16:02:49 <desrt_gabriel> i went into #debian and asked for help.  they kickbanned me :P
16:03:00 <Igloo> Heh
16:03:11 <desrt_gabriel> it was seriously a question about dpkg, tho
16:03:26 <Igloo> If you grab the 6.4-1 from Debian experimental and apply your patch then you should be able to build debs, though
16:03:44 <desrt_gabriel> oh.  i don't really care to build it
16:03:49 <desrt_gabriel> i already have 6.4 installed on all my boxes
16:03:55 <Igloo> Fair enough  :-)
16:04:05 <desrt_gabriel> i just want it to be dpkg'd so i can nuke the /opt
16:04:06 <Igloo> Is powerpc all nicely registerised now, BTW?
16:04:20 <desrt_gabriel> powerpc32 is fully supported as of 6.4
16:04:32 <desrt_gabriel> powerpc64 is registerised as of 6.4
16:04:50 * Igloo makes a note to add it to the registerised list, if it's not already
16:05:16 <desrt_gabriel> ppc64 doesn't have splitobjs, ncg or ghci
16:05:35 <desrt_gabriel> splitobjs and ghci are coming soon (maybe 6.4.1) but ncg is a ways out
16:05:44 * stepcut kicks CGI monad in the ass
16:13:15 <djo> what is the parse error here "else let kk = (length l) + 1" I'm going crazy
16:13:33 <dons> let kk = (length l) + 1 in ...
16:13:34 <dons> ?
16:14:22 <djo> but all I want is to declare a new varaible to hold the value "(length l) + 1"
16:15:23 <joey_> you can't assign kk, you can only pass it somewhere else
16:15:31 <dons> the fragment of code you posted doesn't give enough context for us to help fully.
16:16:04 <djo> ah
16:16:22 <Lemmih> 'let kk = if .. then .. else (length l) + 1' perhaps?
16:19:48 <djo> yes it was that Lemmih
16:22:22 <Lunar^> Igloo: sure, it won't link without it (libfuse depends on pthread)
16:29:30 <wagle> anyone found a modernization of Garey and Johnson's Computers and Intractability book?
16:30:04 <wagle> stepcut: not kick CGI in the monads?
16:31:40 * stepcut kicks CGI in the monads
16:31:57 * wagle puckers in empathy
16:32:16 <stepcut> 'tis annoying to have to calculate things in the CGI monad and then pass them into a function that calculates things the HTML monad :-/
16:35:15 * wagle timidly googles for "CGI monad" ph33ring what he may find
16:37:21 <wagle> whoa
16:40:31 <wagle> "thats no moon, thats the CGI monad!"
16:43:56 <TheStar> desrt_gabriel, Ubuntu, knoppix et al are _not_ debian.
16:44:41 <TheStar> In my hypothetical language, would it be a limitation to only allow the _last_ function called in a function to recurse?
16:45:00 <Oeje1> desrt_gabriel: I know what you mean; I got kickbanned from #java. :-/
16:45:24 <TheStar> ie, all functions between it's definition and the last function it calls must be guaranteed not to call the function so described, no matter how it does things.
16:55:11 <Oeje1> Yay!  I found a way to make table like layout with CSS:  display: table, display: table-cell. :-D
16:55:31 <Lemmih> Hurrah
16:56:24 <Oeje1> Lemmih: The boxes in my two column layout were not equally long; now they are.
17:07:53 <Cale> I'm trying to install GHC-6.4 on my friend's Win98 machine, and after installing, attempting to run ghc/ghci gives a "linked to missing export SHELL32.DLL:SHGetFolderPathA" -- did anyone else run into this problem?
17:14:49 <stepcut> sweet! I can link between the general journal and a ledger now!
17:35:52 <TheStar> SUppose you have:
17:36:08 <TheStar> f x:xs = (whatever)
17:36:24 <TheStar> How does it know that you mean that x is _one_ element, and xs is the rest?
17:36:44 <dons> f (x:xs) = ... you mean
17:36:50 <TheStar> Yup.
17:37:07 <dons> they're separated by the ':' constructor, which provides the type information for 'x'
17:37:15 <dons> @type (:)
17:37:20 <wagle> @type (:)
17:37:22 <lambdabot> (:) :: forall a. a -> [a] -> [a]
17:37:22 <lambdabot> (:) :: forall a. a -> [a] -> [a]
17:37:34 <wagle> haha
17:37:46 <skew> TheStar: just like if you write f (x,y) = x + y it knows that x is the first part of the pair and y the second
17:38:05 <dons> @type (,)
17:38:06 <lambdabot> (,) :: forall b a. a -> b -> (a, b)
17:38:19 <wagle> [1,2,3,4] = 1 : (2 : (3 : (4 : [])))
17:38:31 <wagle> [1,2,3,4] == 1 : (2 : (3 : (4 : [])))
17:38:31 <TheStar> skew, Yes, but in the case of f (x,y), it doesn't need to deal with x, y, z
17:38:40 <skew> TheStar: lists are the same way
17:38:45 <TheStar> And I have never written lisp at all.
17:38:47 <wagle> the + example wanst too good
17:38:49 <skew> it's not really a uniform sequence of elements
17:39:27 <skew> like wagle writes above, a list is really one element connected to a list with :
17:39:43 <skew> A pattern with : matches the first : in the list,
17:39:44 <wagle> the left of the : is never a list
17:39:48 <TheStar> Oh! So all lists are implemented as linked lists?
17:39:57 <skew> just like a pattern with (x,y) matches the outer , in (1, (2, 3))
17:40:09 <skew> TheStar: the normal ones anyway
17:40:12 <skew> there are also arrays
17:40:15 <TheStar> Aha!
17:40:27 <wagle> TheStar: consistent with linked lists, can be a number of representations
17:40:28 <dons> :)
17:40:29 <TheStar> I just assumed that they were arrays.
17:40:55 <dons> no, very different. the [] syntax does confuse people sometimes.
17:41:23 <wagle> "xyz" == 'x' : ('y' : ('z' : []))
17:41:52 <TheStar> What does [] mean?
17:41:59 <wagle> empty list
17:42:32 <dons> @type []
17:42:32 <wagle> lists have two constructors, (:) and []
17:42:33 <lambdabot> [] :: forall a. [a]
17:42:52 <dons> remember that ':' needs something of type [a] as its 2nd arg
17:42:56 <dons> hence 'z' : []
17:43:07 <wagle> : has arity 2, and [] has arity 0
17:43:51 <TheStar> Hmm.
17:45:06 <dons> play around in ghci or hugs, and use :t to find the types of things
17:45:13 <dons> it's a good way to try things out
17:45:18 <TheStar> How many people end up just using Haskel once they try to make their own language?
17:45:41 <dons> heh :)
17:45:50 <TheStar> Seriously.
17:46:02 <Lemmih> 42.
17:46:04 <dons> oh, I don't think we have statistics on that
17:46:19 <dons> though lots of haskell users have written their own (usually small) languages
17:46:32 <TheStar> Because I've been trying to make my own language, with particular "features".
17:46:41 <TheStar> These features appear to be just a subset of Haskell.
17:47:07 <TheStar> For one part, truely infinite recursion.
17:48:51 <dons> it's not surprising - Haskell is based on lambda calculus, providing a theoretical basis for arbitrary language constructs
17:49:37 <dons> hence things like control flow in Haskell are just libraries
17:52:06 <jyasskin> shapr: if you're here: danb suggests that you know of a Haskell FFI binding for GStreamer. Could you send a link?
17:54:29 <dons> TheStar: if you're interested in designing languages, I recommend "Programming Languages - Theory and Practice", http://www-2.cs.cmu.edu/~rwh/plbook/ and "Types and Programming Languages", http://www.cis.upenn.edu/~bcpierce/tapl/main.html
17:59:25 <shapr> jyasskin: Igloo wrote it, lemme get you the darcs repo url
17:59:45 <shapr> dons: have you read ATTaPL yet?
18:00:04 <dons> TheStar: it's a pretty common game here, and elsewhere, to try to implement in Haskell some weird language feature of some language X. I can't actually think of any object-level runtime construct that can't be done (off the top of my head). Implementing arbitrary type system features is another issue altogether, though.
18:00:13 <wagle> neato..  whats the diff between offline.pdf and online.pdf?
18:00:24 <dons> shapr: not yet - saving up my "pacific pesos" though.
18:00:31 <dons> wagle: just the pagination
18:00:39 <dons> left/right margins, I think.
18:00:44 <shapr> I'm too poor also, so many books I want, so little cash.
18:00:55 <TheStar> dons, More to the point, I'm trying to develop language features, such as high efficiency, concurrency, etc, rather than the language itself.
18:01:14 <shapr> Do I buy a new PC, better mountain unicycle equipment, books I want, or should I go to ICFP?
18:01:21 <shapr> It's so hard to choose.
18:01:26 <TheStar> dons, But I've found that those concerns are very highly related to the internal structure of the VM, which I'm finding to be increasingly more like Haskell.
18:01:43 <TheStar> dons, Hence my interest :)
18:01:49 <dons> yeah, so check out Bob Harper's book above for a general approach to designing, and adding language features.
18:01:55 <shapr> jyasskin: http://urchin.earth.li/darcs/ian/hgstreamer
18:02:08 <wagle> shapr: buy unicycle, use it as escape vehicle after then robbing bank
18:02:29 <jyasskin> shapr: thanks
18:03:21 <shapr> jyasskin: for the whole package, put http://urchin.earth.li/darcs/ian/{hgstreamer,hgobject,hcurses} inside the main dir for http://urchin.earth.li/darcs/ian/minstrel
18:03:38 <dons> hcurses? /== hscurses?
18:04:34 <shapr> I think it's yet another binding.
18:05:01 <dons> ah, YetAnotherCursesBinding
18:05:31 <shapr> Igloo wrote it, so it requires -fth, and that's a bit more interesting.
18:05:35 <jyasskin> shapr: Guess I'll finally have to install darcs then
18:05:46 <shapr> darcs is extra-spiffy
18:05:47 <dons> here's hscurses, based on yi's, based on riot's, based on ginsu's: http://www.stefanheimann.net/darcs/hscurses/
18:06:03 <dons> ah -fth! inneresting.
18:06:19 <shapr> absotively
18:06:22 <jyasskin> ooh, th :)
18:06:24 <shapr> posolutely
18:07:13 <shapr> jyasskin: I think you'll like darcs. Maybe you won't like it better than arch, but it's probable that you'll enjoy darcs' good points.
18:08:13 <shapr> This enigma game is addictive.
18:08:58 <vdrab> 'morning all
18:09:07 <shapr> Greetings vdrab
18:09:43 <jyasskin> I've been meaning to try out darcs anyway. We almost used it for HsAudio, but decided to stay with what we knew.
18:10:08 <vdrab> i was thinking the other day, how would you go about implementing a quick and dirty object system in haskell? i'm sure there's a bunch of ways to do this, and there's things like O'Haskell, but i would be interesting in people's versions... :)
18:10:26 <vdrab> interesting > interested
18:10:32 <shapr> Have you seen OOHaskell as opposed to O'Haskell?
18:10:43 <vdrab> nope...
18:10:55 <jyasskin> shapr: Is that the HList-based one?
18:10:57 <TheStar> What's the point of object oriented haskell code?
18:11:04 <vdrab> i'm not really looking for an object-oriented haskell, just curious
18:11:05 <shapr> http://lambda-the-ultimate.org/node/view/319
18:11:20 <dons> well, type classes compile to runtime (dictionary) objects carrying methods, so that's pretty much it, right?
18:11:35 <vdrab> TheStar: "Just because we can ... !'" (evil laughter)
18:11:40 <TheStar> vdrab, Heh.
18:11:58 <shapr> I just like learning cool stuff, that's my point for most things.
18:12:16 <vdrab> dons: but how do you give objects a 'self' pointer?
18:12:23 <TheStar> dons, I believe that is easily emulated with conventional tactics, if we have inheritance of data types.... Do we have that?
18:12:25 <shapr> Finding powerful solutions is nice for my paycheck, but that's secondary for my porpoises.
18:13:24 <dons> TheStar: data A => B = ...
18:13:39 <shapr> Still, that won't allow more than one instance will it?
18:13:44 <dons> vdrab: good point - don't know. Pretty sure there's several papers describing solns though ;)
18:13:46 <vdrab> exactly
18:13:58 <vdrab> was just wondering about that
18:14:24 <dons> I think you get a fairly full system using existentials on the right hand side of the '='
18:14:25 <vdrab> an object can easily be a record type
18:14:38 <vdrab> but self-reference is a no-go
18:14:39 <dons> There's an oleg paper on this, I believe (or email)
18:15:00 <shapr> oleg papers are wonderful things.
18:15:14 <dons> I've certainly heard rumours about typeclasses+existentials == objects
18:15:19 <shapr> vdrab: you can self-reference a value of a record type.
18:15:48 <vdrab> i tried to work around it with "let self = {...a = myMethod self, ... } in self" for a constructor, but the compiler rejected it
18:16:07 <dons> an closures are represented almost identically to a Java-like object too, for what it is worth.
18:17:46 <dons> Some of the bindings to OO languages from Haskell provide OOish features too
18:18:49 <vdrab> i'm sure type classes do all the hard work for you, I just can't think of a way to distinguish between object instances off the top of my head... have to chew on that one a bit.
18:19:04 <vdrab> MVars?
18:19:10 <shapr> One thing I like about closures as opposed to Java objects is that the 'possible futures' are limited.
18:19:21 <dons> vdrab: argh! typeclass hacker alert.
18:19:26 <vdrab> hehe
18:19:30 <shapr> vdrab: use the Unique suppyl?
18:19:47 <vdrab> shapr: enlighten me...
18:20:35 <shapr> There's a built-in unique supply in GHC, you could use that to give your instances identity other than their value alone. Sort of.
18:21:16 <vdrab> never heard of it. i'll have a look at that
18:23:33 <jyasskin> Does Typeable include typeclass information?
18:23:47 <dons> ah, ozone used multiparameter typeclasses to model OO in the Mocha stuff
18:24:05 <dons> Typeable doesn't, no.
18:24:12 <dons> it's monomorphic all the way.
18:24:36 <dons> there's ways around this though. One is mentioned in the hs-plugins paper
18:24:49 <dons> using existentials, again.
18:25:47 <dons> Here's the OO/Haskell paper by ozone: http://www.cse.unsw.edu.au/~chak/papers/PC03.html
18:25:48 <vdrab> where would be a good starting point to read up on existentials?
18:26:12 <shaleh> newbiew question
18:26:33 <dons> vdrab: the user's guide has a 'type system extensions' chapter covering it
18:26:59 <vdrab> the user's guide as in, the report?
18:27:13 <dons> nope, sorry, GHC user's guide
18:27:13 <shaleh> I want to say [x, y, .. sqrt n ] where the List is type [Int]. I tried using floor $ sqrt n, but that did not work
18:27:34 <vdrab> dons: thanks
18:28:38 <dons> shaleh: you want to convert a Floating a to an Int?
18:28:48 <shaleh> dons: I believe so, yes
18:28:58 <shaleh> unless there is something I am missing
18:29:21 <dons> :t GHC.Float.float2Int (sqrt 4.0)
18:29:26 <dons> GHC.Float.float2Int (sqrt 4.0) :: Int
18:29:36 <shaleh> I have to use a ghc extension?
18:29:47 <dons> nah, there's a normal way.. hmm.
18:30:01 <shaleh> (I like to try to be hugs compatible)
18:30:15 <dons> I mentioned it on this channel last week.. escapes me...
18:30:38 <shaleh> toSomething $ fromSomething?
18:30:55 <jyasskin> fromRat?
18:31:13 <dons> @type Numeric.fromRat
18:31:15 <lambdabot> Numeric.fromRat :: forall a. (RealFloat a) => Rational -> a
18:31:22 <dons> hmm.
18:31:49 <shaleh> ok, from within ghci how do I import Numeric?
18:31:58 <jyasskin> mm, not quite
18:32:09 <dons> :m + Numeric
18:32:13 <shaleh> confusing that a simple import doesn't work
18:32:47 <dons> there's magic dyn loading happening, though
18:33:08 <dons>  /= src level 'import'
18:33:17 <shaleh> k
18:33:49 <shaleh> I am surprised this is so hard to accomplish. sqrt -> Int seems like a common enough request
18:34:01 <jyasskin> toInteger
18:34:15 <jyasskin> @type floor
18:34:16 <lambdabot> floor :: forall a b. (RealFrac a, Integral b) => a -> b
18:34:19 <jyasskin> @type toInteger
18:34:21 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
18:34:38 <dons> oh, floor + fromRat looks good
18:34:56 <dons> no it doesn't.
18:35:13 <jyasskin> so, toInteger . floor . sqrt :: Floating a => a -> Integer
18:35:33 * TheStar returns to coding his crappy assignment in C#
18:36:15 <dons> @type toInteger . floor . sqrt $ 4.0
18:36:17 <lambdabot> toInteger . floor . sqrt $ 4.0 :: Integer
18:36:21 <dons> looks good to me.
18:36:31 <jyasskin> oh, neat, didn't realize it could do that
18:36:48 <dons> clever bot can type expressions, yeah.
18:38:27 <shapr> TheStar: I feel sorry for you.
18:38:34 <shaleh> Couldn't match `Int' against `Integer'
18:38:34 <shaleh>       Expected type: Int
18:38:34 <shaleh>       Inferred type: Integer
18:38:34 <shaleh>     In an arithmetic sequence: [3, 5 .. maxVal]
18:38:34 <shaleh>     In the second argument of `map', namely `[3, 5 .. maxVal]'
18:38:39 <shapr> y0 shaleh
18:38:46 <shaleh> shaleh: yo
18:38:55 * shaleh is having a hell of a time with type conversions
18:39:03 <TheStar> shapr, I liked C, Java was _ok_, but C# is just continuing with the pain.
18:39:08 <shaleh> maxVal          = toInteger $ floor $ sqrt n
18:39:16 <dons> @type fromIntegral (toInteger . floor . sqrt $ 4.0) :: Int
18:39:17 <lambdabot> fromIntegral (toInteger . floor . sqrt $ 4.0) :: Int :: Int
18:39:37 <shapr> @index toInteger
18:39:37 <lambdabot> GHC.Real,Prelude
18:39:43 <shapr> @type toInteger
18:39:45 <lambdabot> toInteger :: forall a. (Integral a) => a -> Integer
18:39:51 <shapr> @type fromIntegral
18:39:52 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
18:39:53 <dons> once you've got it in Num a => a land (Integer), then fromIntegral can do the rest.
18:40:03 <shaleh> nope, fromIntegral doesn't compile
18:40:16 <dons> > fromIntegral (toInteger . floor . sqrt $ 4.0)
18:40:17 <dons> 2
18:40:24 <Lemmih> @type floor . sqrt $ 10 :: Int
18:40:25 <lambdabot> floor . sqrt $ 10 :: Int :: Int
18:40:34 <Lemmih> @type floor . sqrt $ 10 :: Integer
18:40:35 <lambdabot> floor . sqrt $ 10 :: Integer :: Integer
18:40:52 <TheStar> Seems that all imperative languages are the same.
18:41:06 <shaleh> gah this is stupid
18:41:09 <TheStar> And yet they all try to be fundamentally better than each one.
18:41:16 <shaleh> floor claims to be an int, but I can't USE it for an int?
18:41:38 <dons> [3.0 .. ]
18:41:51 <dons> @type [3, 5 .. ]
18:41:52 <lambdabot> [3, 5 .. ] :: forall t. (Num t, Enum t) => [t]
18:41:56 <dons> @type [3.0, 5 .. ]
18:41:58 <lambdabot> [3.0, 5 .. ] :: forall t. (Fractional t, Enum t) => [t]
18:44:03 <dons> TheStar: yeah, imperative programming is just a specific case of functional programming anyway
18:44:13 <TheStar> dons, Really?
18:44:41 <dons> it's just threaded implicit state, hence we have monads
18:45:11 <TheStar> What are monads?
18:45:26 * dons signals shapr
18:46:01 <Lemmih> It's a specific way of handling data.
18:46:05 <shaleh> TheStar: Simply, monads are state and using them you get imperative behavior in a purely functional language
18:46:16 <TheStar> Nice.
18:46:25 * jyasskin must be rusty. shaleh, what's the actual error you're getting?
18:46:48 <Lemmih> Not quite. Maybe and lists are also monads but they aren't very imperative.
18:46:51 <Cale> Monads are not state :)
18:47:03 <shaleh> see, that woke up the sleepers (-:
18:47:21 <shaleh> first rule to net chatter, get it wrong enough to wake up the people who really know (-:
18:47:35 <jyasskin> nm, see it up there
18:48:11 <TheStar> I think I might try implmementing my own Functional language.
18:48:38 <shaleh> TheStar: why, we are all just recreating lisp, right?
18:48:47 <dons> TheStar: highly recommended. you can produce a simple strict functional language interpreter in a day or two.
18:48:50 <TheStar> shaleh, Seems that way.
18:48:58 <dons> Try MiniML from Bob's book.
18:49:08 <shaleh> dons: link?
18:49:23 <TheStar> dons, I'm sure you could, although I'm trying to make the language itself.  That'll take longer given that I don't really even know functional languages that well.
18:49:41 <shaleh> [3, 5 .. sqrt max] -- can someone get this to compile, please?
18:49:53 <dons> TheStar: make the language itself? design on paper, do you mean?
18:50:00 <TheStar> dons, Correct.
18:50:19 <dons> then step through Bob's book anyway!
18:50:27 <dons> That's how to design a language on paper
18:50:29 <shaleh> dons: who is 'bob'?
18:50:39 <dons> sorry, Bob Harper (aka. Mr. ML)
18:50:45 <jyasskin> shaleh: in ghci, [3, 5, floor $ sqrt 73] works
18:51:00 <jyasskin> shaleh: make sure your x and y are typed as Int's, rather than Integers
18:51:04 <dons> shaleh, link: http://www-2.cs.cmu.edu/~rwh/plbook/
18:51:19 <dons> R.Harper is to ML what SPJ is to Haskell, in many ways.
18:51:45 <jyasskin> shaleh: The type defaulting for "3" and "5" makes them Integers if they're otherwise just Num's
18:51:49 <dons> "Defn. of Standard ML" is a must read for language designers, I would think
18:51:53 <shaleh> jyasskin: that's just it, I can get it to work in ghci, but not in the real code.
18:52:07 <shaleh> how do I make 3 be an Int?
18:52:11 <dons> 3 :: Int ?
18:52:29 <shaleh> do I have to say [3 :: Int, 5 ::Int .. floor $ sqrt n]?
18:52:38 <dons> nah, just one will be enough for the type inference
18:52:54 <jyasskin> If that doesn't help, paste the whole function into http://haskell.org/hawiki/HaskellIrcPastePage
18:53:00 <dons> [a ,b ,c ] :: [Int], for example
18:54:07 <dons> TheStar: you in .au?
18:54:12 <TheStar> dons, Yes.
18:54:26 <dons> Sydney?
18:54:41 <shaleh> bah
18:54:47 <TheStar> dons, Give or take a few hours ;)
18:55:18 <dons> oh, ok. well, if you were at unsw you could do my course on implementing MiniHS
18:56:16 <dons> those two books I pointed at are the texts for the course.
18:57:18 <shaleh> pasting now, one sec
18:58:28 <shaleh> ok, it is up
19:00:48 <dons> where's member and fromList ?
19:00:57 <shaleh> dons: imported from data.set
19:01:16 <shaleh> import Data.Set(elems, fromList, member, union)
19:01:22 <dons> oh, that's right.
19:02:52 <dons> you want  to do sqrt n, where n :: Int ?
19:03:06 <shaleh> this started as a quick python -> haskell translation. but then I got stuck on the sqrt thing. The code works with just n, but the optimization is helpful
19:03:40 <shaleh> dons: what I want is for list comprehension to work. if sqrt n needs to be an Int, then that is what I want
19:04:47 <shaleh> forgive me, but I am new and learning. Sometimes when learning, the things you ask for are not what you really need.
19:05:01 <dons> yeah, it's fine.
19:05:26 <shaleh> not trying to be a prick and evade the question, really (-:
19:05:59 <jyasskin> shaleh: sqrt only applies to Floating's. So, you need to replace that line with:
19:06:12 <jyasskin> maxVal          = floor $ sqrt $ fromInteger $ toInteger n
19:06:55 <shaleh> why does sqrt 4 work at the ghci prompt then?
19:07:03 <jyasskin> I may have missed a conversion function that would go more directly. I'm looking in http://haskell.org/onlinereport/standard-prelude.html for the available stuff
19:07:17 <Cale> shaleh: 4 will get interpreted as Double in that context
19:07:20 <jyasskin> "4" isn't an integer, it's actually a "Num a => a"
19:07:29 <jyasskin> @type 4
19:07:31 <lambdabot> 4 :: forall t. (Num t) => t
19:07:45 <dons> yeah, floor . sqrt . fromInteger $ toInteger n looks good.
19:08:10 <dons> wouldn't be surprised if there's a more direct way, but that's not too bad
19:08:23 <Cale> @type fromIntegral
19:08:25 <lambdabot> fromIntegral :: forall b a. (Num b, Integral a) => a -> b
19:08:39 <jyasskin> that's it
19:08:59 <shaleh> it is hard, because you try to test at the ghci prompt and it works. But then it fails in the actual code
19:09:24 <dons> you can work in a file, and just use ':reload' at the ghci prompt to check typesafety though
19:09:31 <Cale> shaleh: well, it will also work in actual code
19:09:45 <Cale> shaleh: but you're not doing the same thing in your code :)
19:10:08 <shaleh> Cale: how is floor $ sqrt n not the same?
19:10:16 <jyasskin> @type sqrt
19:10:18 <lambdabot> sqrt :: forall a. (Floating a) => a -> a
19:10:35 <shaleh> Cale: so floor $ sqrt $ fromIntegral n?
19:10:37 <jyasskin> But n::Int, and Int isn't an instance of Floating
19:10:39 <dons> you can't use sqrt directly on the 'n' in your file.
19:10:56 <dons> you've got an Int constraint, that was absent when testing in ghci
19:11:20 <jyasskin> shaleh: but you're right that this is confusing. Look how long it took us to find the problem.
19:11:43 <Cale> I should have been looking :)
19:12:05 <dons> yeah, so it's definitely better to work in the typing environment you're actually going to have
19:12:25 <shaleh> dons: I thought I was (-:
19:13:36 <shaleh> so, having seen the code, any other comments?
19:13:52 <dons> I'd indent the 'where' keyword less
19:14:00 <dons> otherwise looks ok.
19:14:36 <jyasskin> You don't actually need the ::Int on the 3. maxval provides your type there
19:14:47 <jyasskin> no, maxval doesn't, but the other environment should
19:15:02 <dons> usual convention is: function = ... \n <half-indent>where \n <full indent> a = b ..
19:15:32 <shaleh> dons: thanks, I have been lining up under the '='
19:16:34 <shaleh> jyasskin: yeah, I added that in a few minutes ago when we talked about it
19:16:45 <jyasskin> I know, we were wrong though
19:16:55 <shaleh> jyasskin: as I found out (-:
19:17:13 <shaleh> jyasskin: wanted to leave the current state as is, even if it was broken
19:18:44 <shaleh> dons: emacs' haskell mode does not like half-indents too much, so I end up lining up under a fully indented where
19:19:33 <shaleh> dons: thanks for the style comment.
19:19:45 <shaleh> well, off to help the wife cook
19:19:48 <shaleh> night all
19:29:08 * TheStar curses VS.NET
21:39:29 <jyasskin> Does anyone know of documentation for unsafeInterleaveIO? Particularly descriptions of when it's actually safe?
21:45:33 <dons> there's some docs in GHC.IOBase
21:45:39 <Cale> I think it's safe when you don't mind your IO happening arbitrarily far into the future.
21:46:15 <dons> I agree.
21:46:53 <dons> really though, you should use e.g. Chans (implemented on top of unsafeInter..) if possible (or one of the other abstractions)
21:51:58 <dons> actually hGetContents, getChanContents and fixIO (used by mfix for IO) are the only functions that use unsafeInterleaveIO
21:57:37 <jyasskin> So, unsafeInterleaveIO does allow its IO actions to be performed out of order with respect to IO actions done later, not just out of order within itself? I guess I should have expected that.
22:01:23 <dons> it just defers evaluation of the action, until that value is demanded
22:24:32 <pidhash> hello !
22:24:36 <pidhash> anyone ?
22:26:17 <pidhash> I tryed map Char.toUpper "Hello World" in hugs
22:26:21 <pidhash> but I got
22:27:03 <pidhash> ERROR - Undefined qualified variable "Char.toUpper"
22:28:04 <xerox> pidhash: you have to enclose Char.toUpper in parens
22:28:36 <pidhash> let me try
22:29:49 <pidhash> nothing
22:30:16 <xerox> @type map (Char.toUpper) "foo"
22:30:18 <lambdabot> map (Char.toUpper) "foo" :: [Char]
22:30:53 <xerox> @type map Char.toUpper "foo"
22:30:55 <lambdabot> map Char.toUpper "foo" :: [Char]
22:31:33 <xerox> Maybe the problem is with hugs..
22:31:44 <pidhash> meybe my some troubles with this hugs
22:31:46 <pidhash> here
22:32:08 <xerox> Check the :command to import Char
22:32:17 <xerox> In GHCi is :module + Char
22:32:30 <pidhash> :load Char ?
22:32:38 <xerox> Probably not.
22:32:46 <xerox> Sorry, gotta go to school, bye.
22:32:53 <pidhash> bye
22:32:58 <pidhash> :also Char |
22:32:59 <pidhash> ?
22:34:01 <Lemmih> :l Char
22:34:11 <Lemmih> map toUpper "hello"
22:34:45 <pidhash> good
22:34:50 <pidhash> worked
22:35:24 <pidhash> when I make :names
22:35:34 <pidhash> it show me only Hugs.*
22:35:41 <pidhash> where is Char module ?
22:37:32 <Lemmih> I have no idea (:
22:38:59 <pidhash> heh
22:39:14 <pidhash> raskell have commnets like ada
22:39:16 <pidhash> --
22:45:59 <Cale> -- is a good comment delimiter
22:46:33 <pidhash> well seems x=x-1 :)!
22:46:45 <pidhash> but it is olther old language
22:46:47 <pidhash> :)@
22:46:58 <Cale> hehe :) That's an infinite loop, by the way :)
22:47:47 <pidhash> I m new with raskell
22:48:08 <pidhash> but it seems very interesting
22:48:20 <Cale> Haskell, you mean :)
22:48:21 <Lemmih> s/raskell/haskell/
22:48:24 <Cale> yeah
22:48:34 <pidhash> sure
22:48:39 <pidhash> :)@
22:49:00 <pidhash> i like idea of a truely pure functional language
22:50:19 <pidhash> but I m not fine with func defs and hugs enviroment
22:51:17 <Lemmih> The Hugs prompt is only for evaluating expressions. Try saving your declarations in a file and then load it.
22:51:42 <pidhash> like a shell script
22:51:46 <pidhash> guessing
22:53:28 <pidhash> I cant create a executable (bin) with hugs
22:53:53 <pidhash> is it only a interpreted
22:53:56 <pidhash> ?
22:54:30 <Lemmih> Hugs is only an interpreter but you can use GHC or nhc to create binaries.
22:54:53 <pidhash> ok
22:56:42 <pidhash> python seems have some indeas of haskell
22:58:04 <Ruller> Guido tryed to get the best things of all languages into Python
22:59:42 <pidhash> seems a good language
23:00:18 <autrijus> Ruller: then how come he is dropping map{} grep{} and reduce{}? :)
23:00:23 * Gahhh wants reduce to stay heh
23:02:32 <pidhash> heh I hope that here haven't C haters :)!
23:03:59 <autrijus> C is a nice language. :)
23:04:13 <Ruller> autrijus: there are map and reduce in python
23:04:15 <autrijus> I just don't want to be caught writing complex dynamic systems with it.
23:04:20 <Ruller> but I have never heard about grep
23:05:00 <tuomov> python currently has map and friends, but there's been talk of removing all that functional stuff
23:05:09 <pidhash> grep in haskell is seems grep of shell ?
23:05:24 <autrijus> Ruller: http://www.artima.com/weblogs/viewpost.jsp?thread=98196
23:05:36 <pidhash> sorry if it's silly
23:06:02 <autrijus> pidhash: no, I was using perl notation, sorry. it is called filter() in both python and haskell.
23:06:03 <Gahhh> not all of it. just(!) lambda's and reduce. list comprehensions stay.
23:06:19 <pidhash> ah ok !
23:06:28 <autrijus> but explicit calls of map() and filter() is gone too, in favor of list comprehensions.
23:06:57 <autrijus> problem is, list comprehensions doesn't combine well. but maybe I'm full of this point-free drug.
23:06:57 <tuomov> so not even anonymous functions anymore? what a piece of crap
23:06:59 <Gahhh> autrijus, how are things in perl6 ?
23:07:16 <autrijus> Gahhh: very good. letrec landed yesterday
23:07:28 <autrijus> (see http://use.perl.org/~autrijus/journal for more updates)
23:07:46 <autrijus> and people are porting real world p5 scripts to p6 now.
23:08:04 <pidhash> not compatilble
23:08:14 <pidhash> i coded in perl 4 sometimes
23:08:23 <autrijus> pidhash: a translator is in the works. :)
23:08:28 <Gahhh> I thought it was supposed to be backwards compatible with 5 ?
23:08:28 * Ruller is crying
23:08:30 <autrijus> actually, three translators.
23:08:50 <autrijus> Gahhh: yup, via translator interface. still in the works :)
23:08:57 <Gahhh> ah
23:09:25 <Ruller> autrijus: thank you
23:09:37 <Ruller> I saw the real face of Guido now
23:09:50 <pidhash> heh
23:09:56 <autrijus> Ruller: no problem. I gather they are not really going away this minute, but probably Guido is not interested in borrowing more haskell features :)
23:10:09 <Ruller> [:=)
23:10:13 <Gahhh> I believe they were added by a certain lisp hacker anyways.
23:10:18 <autrijus> true.
23:10:59 <tuomov> there's some point in replacing map, filter etc. with list comprehensions, but removing lambda is unforgivable
23:11:13 <Cale> Guido probably realised that he was losing Python users to Haskell through these "gateway HOFs".
23:11:25 <Cale> heh
23:12:24 <Gahhh> heh
23:12:24 <autrijus> HOF?
23:12:34 <Gahhh> higher order func
23:12:42 <Gahhh> ?
23:12:45 <Cale> yeah
23:13:07 <Gahhh> I found haskell by stumbling on Mertz' FP with Python articles
23:13:13 <pidhash> heh almos DOF
23:13:30 <autrijus> ahh. one of the first replies to guido's blog reads:
23:13:33 <autrijus> "By gosh! They will have to completely remove David Mertz's articles from IBM-developworks!"
23:13:33 <pidhash> of CG stuff :)!
23:13:50 <Gahhh> autrijus, heh I saw that.
23:14:34 <pidhash> what about articles
23:14:38 <pidhash> lambda stuff ?
23:15:41 <pidhash> haskell features in python ?
23:15:58 <autrijus> something like that.
23:16:26 * Lemmih wonders if JaffaCake is making a habit out of iding in #haskell.
23:19:01 <pidhash> ok notthing bad this my haskell hello world :)!
23:19:06 <pidhash> see you later
23:19:08 <pidhash> thansk
23:19:18 <pidhash> ks
