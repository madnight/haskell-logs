00:02:34 <Itkovian_> still here #haskell?
00:03:32 <Cale> Itkovian_: yes, we're here :)
00:03:43 <Cale> but nobody has said anything in a while
00:08:19 <Gahhh> It's because we're all happily hacking haskell without needing to ask questions ;)
00:15:59 <Itkovian_> Cale: I was referring to the moving discusson of tonight ...
00:16:12 <musasabi> morning
00:16:32 <Cale> It's 3:17am here :)
00:16:50 <musasabi> Is it possible to either define a whole module with TH2 or add imports to the current module?
00:19:56 <dons> a quick scan of the syntax defn makes me think not, but i haven't confirmed this.
00:22:19 <musasabi> Would generating a module from template haskell be considered bad style? (one can do IO inside Q)
00:23:54 <Heffalump> I expect so, but since Igloo has been known to generate C code and invoke gcc from inside TH, I wouldn't let that stop you ;-)
01:28:51 <musasabi> Is it possible to do "(foo,bar) = (x,y) where (Foo x y) = foo" from Template Haskell?
01:29:38 <pesco> musasabi: Ah, so you have had a look at TH? Is it cool? I've never gotten around to it myself...
01:29:57 <musasabi> it seems cool but underdocumented.
01:30:04 <pesco> :(
01:30:40 <musasabi> most of the time I just stare at the sources and try different things guessing until finally something appears to work.
01:30:51 <pesco> Hm.
01:33:32 <pesco> Cool, I'm making LaTeX with cons...
01:34:12 <kosmikus> LaTeX with cons?
01:34:59 <shrimpx> heh
01:35:05 <pesco> Ah, triggered the expert. ;) I'm on the quest for a markup language.
01:35:14 <musasabi> What are the (a,b) = ... declarations called - with multiple things on the lhs?
01:35:25 <pesco> musasabi: Pattern binds?
01:35:33 * kosmikus should add LaTeX on #haskell to his highlight list :)
01:35:43 * pesco giggles.
01:36:19 <pesco> kosmikus: I need structural text markup, more like XML, but XML is intolerably ugly.
01:36:43 <kosmikus> agreed, so what do you use?
01:37:01 <pesco> I'm trying to devise a language of my own.
01:37:46 <pesco> Realizing it would be beneficial to support \begin{code} and \end{code} in a way similar to LaTeX, I came up with this:
01:38:19 <pesco> The back-slashed words can be seen as right-associative binary operators.
01:39:13 <pesco> First argument: The text preceding the operator, second argument: The stuff following it.
01:39:44 <pesco> If curly braces denote left-associative function application one ends up with something very much like LaTeX but typeable.
01:40:02 <pesco> Typeable in the way we're used to it.
01:40:33 <kosmikus> ok
01:40:42 <pesco> I hope that will give me the structure I need while still being easy to understand and reasonably readable.
01:41:24 <pesco> Trying to write an example code listing, I found myself writing \begin{list} \cons{foo} \cons{bar} \end{list}, thus the remark.
01:41:59 <kosmikus> ah
01:42:27 <pesco> (the begin-end syntax is sugar for \list{...} of course)
01:42:45 <kosmikus> \def\Cons#1#2#3#4{#3{#1}{#2}}
01:42:54 <kosmikus> that's what lazylist.sty says ;)
01:43:54 <pesco> *taking awhile to parse TeX*
01:44:14 <pesco> parse and analyse that is.
01:44:28 <pesco> Why is #4 never used?
01:44:51 <kosmikus> because that's the "Nil"-continuation
01:45:10 <pesco> I don't understand...
01:45:16 <kosmikus> lazylist.sty simulates untyped lambda-calculus in TeX
01:45:36 * pesco raises an eyebrow.
01:45:45 <kosmikus> lists are simulated as their fold
01:45:51 <kosmikus> \def\Nil#1#2{#2}
01:46:22 <kosmikus> er, as their "case", sorry
01:46:43 <earthy> ah, that trick
01:47:53 <kosmikus> right, it's a common tricks, and it works quite fine in TeX, giving you fully expandable data structures
01:48:17 <pesco> I don't think I'm familiar with it. Can you elaborate? I'm interested.
01:48:17 <kosmikus> the big minus is that it's lazy, but there's no sharing
01:48:57 <pesco> \Nil above looks like a lambda calculus boolean.
01:49:07 <pesco> 'false'
01:49:29 <kosmikus> right
01:50:04 <kosmikus> False has the same encoding as Nil (Nil being the "second" constructor in this list type)
01:50:05 <pesco> Ah, so \Cons must take a n element #1 and a list #2 and return a new liste #3#4; of course.
01:50:14 <kosmikus> exactly
01:52:23 <Lemmih> musasabi: Have you tried looking at some generated TH code?
01:54:11 <pesco> kosmikus: Ah, so in general to model a data type you take one continuation argument for each constructor?!
01:54:27 <kosmikus> yes
01:54:42 <pesco> Cool, thanks for the enlightenment.
01:54:52 <kosmikus> np
01:55:02 * pesco bounces happily around the lambda calculus.
01:55:41 <pesco> OK, I need to leave for now. See you later.
01:55:50 <kosmikus> bye pesco
01:57:31 <earthy> hm. had someone explained that in terms of continuations to me I'd have had a much easier time grasping the trick...
01:59:12 * kosmikus has just spent a week listening to lectures given by Olivier Danvy ;)
02:00:53 <jlouis> kosmikus: cool, where are they?
02:01:01 <jlouis> downloadable?
02:01:08 <TheHunter> has anyone got a reference showing that (if it's true) for monads m, the types m a and forall r. (a -> m r) -> m r are isomorphic.
02:02:50 <kosmikus> jlouis: they don't seem to be online, at least not yet
02:03:13 <jlouis> kosmikus: a shame
02:03:54 <kosmikus> jlouis: check http://www.cs.ioc.ee/yik/schools/win2005/ again in a few days, maybe they'll appear there
02:04:01 <jlouis> TheHunter: a is bound specifically, or forall a . m a?
02:04:09 <jlouis> kosmikus: thankyou
02:04:50 <TheHunter> jlouis, a can be anything.
02:05:06 <jlouis> TheHunter: heh
02:05:45 <kosmikus> I have to leave for now ...
02:08:41 <jlouis> TheHunter: it is way above my head. First, I do not know how isomorphism should be defined. Second, are we trying to show isomorphism between types (eg. m Int, m String, m ...) or values of a given type (m 1, m 2, m ...)?
02:08:54 <jlouis> Categories probably
02:09:48 <TheHunter> iso1 :: Monad m => m a -> (forall r. (a -> m r) -> m r)
02:09:48 <TheHunter> iso1 m = \k -> k =<< m
02:09:48 <TheHunter> iso2 :: Monad m => (forall r. (a -> m r) -> m r) -> m a
02:09:48 <TheHunter> iso2 f = f return
02:10:02 <TheHunter> iso2 . iso1 === id is trivial.
02:11:27 <TheHunter> the other direction seems hard, but the free theorems paper seems provide a technique to prove such results in System F.
02:13:23 <TheHunter> any pointer to something similar in System Fw would help me.
02:16:08 <jlouis> ah
02:16:27 <jlouis> Interesting
02:19:28 <TheHunter> e.g. in section 3.8, Wadler proves that forall r. (a -> r) -> r and a are isomorphic.
02:22:43 <musasabi> Lemmih: yes, but most of the time looking at the source was easier.
02:43:53 <Si\> can anyone think of a way of causing a "no instance" error if a particular type does not exist in a given type list, for e.g. doing "myFunc Int (undefined::String :|: Float :|: Char)" would yield an error?
02:46:20 <Si\> currently I can only get it so that myFunc would return a Maybe value, but that isn't really what I want, the check should occur at compile time, rather than run time
02:46:24 <TheHunter> -foverlappping-instance ok?
02:52:37 <Si\> yes, essential
02:52:45 <Si\> sadly
02:53:10 <TheHunter> the obvious implementation seems to work here.
02:53:27 <TheHunter> myFunc should be an injection, right?
02:54:22 <TheHunter> i think by delimiting the sum with a specific uninhabited type, we could get rid of the -fallow-undecidable-instances requirenment.
02:56:36 <Si\> myFunc would in this instance inject the value into a Dynamic iff the type exists in the type-list
02:56:58 <Si\> it is so I can guard a Dynamic for a static type union
02:57:58 <Si\> so say v :: Choose (Int :|: String :|: Char) should only be able to store an Int, String or Char. But whether we can inject should be checked at compile time
03:02:32 <TheHunter> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:02:46 <TheHunter> i'm not really sure if this is what you want, but i pasted it anyway.
03:11:31 <musasabi> What causes "internal error: resumeThread: thread not found" on windows?
03:13:28 <Itkovian_> musasabi: it went down the blue hole of death?
03:14:37 <musasabi> just trying to port my networking library to windoze but it seems kind of futile.
03:16:02 <Si\> Thanks a lot TheHunter! All I needed was the constraints, so I removed the type and just added the constraint Foo a b to the injection function
03:16:21 <Si\> it means I've got a fully statically typed Union
03:17:54 <Si\> I think
03:22:34 <Si\> so you can use multi-parameters to do type equality, I'll remember that
03:59:59 <TheHunter> #join #uiuiu
04:00:12 <TheHunter> sorry.
04:06:42 <rtega> is there a way in haskell to represent 1/2 as 1/2 instead of 0.5?
04:06:51 <jlouis> 1 % 2
04:06:55 <jlouis> from Data.Ratio
04:07:26 <rtega> aha
04:18:29 <TheHunter> jlouis, it turns out, my conjecture above was wrong. Counterexample, fwiw: foo f = f (length (f 0)); f x = if x == 0 then [2] else [].
04:20:44 <Si\> Wow, this is pretty amazing, you can actually create a partial Union with setUnion "hello", and it can later be coerced to _any_ Union which contains a String
04:22:28 <TheHunter> note to self: always check conjectures using QuickCheck first.
04:23:28 <jlouis> TheHunter: hehehe
04:23:43 <jlouis> QuickCheck owns me.
04:23:46 <jlouis> ;)
04:26:56 <nlv11757_> can i assign priorities to operators i define in a class? or do i have to do that outside the class definition
04:26:59 <nlv11757_> ?
04:28:59 <bringert> must be at the top-level, i.e. not in a class, afaik
04:37:21 <earthy> nope
04:37:53 <earthy> a fixity declaration is in the syntactic category /decls/ and may be used either at the top level or in nested scopes.
04:38:06 <earthy> so, nlv11757: yes, you can. ;)
04:38:40 <bringert> earthy: cool, thanks
04:38:59 <bringert> so you can change fixity locally?
04:39:04 <earthy> um. ;)
04:39:16 <bringert> just think of the obfuscation possibilities
04:39:48 <earthy> in a fixity declaration must be in the range to . A fixity declaration may appear anywhere that a type signature appears and, like a type signature, declares a property of a particular operator. Also like a type signature, a fixity declaration can only occur in the same sequence of declarations as the declaration of the operator itself, and at most one fixity declaration may be given for any operator. (Class methods are a minor exception; their fixity declarat
04:40:05 <earthy> (page 54 haskell'98 report)
04:41:45 <earthy> otoh, yes, you can change fixities for say (+) and (*) locally within a module
04:42:06 <earthy> as long as you hide (+) and (*) from the prelude
04:44:26 <bringert> sweet, just tested it
04:45:26 <bringert> is there a symbol for regular function compostion?
04:45:30 <bringert> i.e. not $
04:45:43 <bringert> I want to try to change its fixity
04:46:03 <Darius> You could hide ($) and redefine it.
04:46:28 <bringert> well, I really want to redefine the fixity of juxtaposition
04:46:32 <bringert> ( )
04:46:43 <bringert> but I guess that won't work
04:47:13 <bringert> just for obfuscation value
04:49:13 <b0gg1e> hi,
04:49:48 <b0gg1e> i got problems compiling ghc 6.4 on a mac.  make runs into an (seemingly) infinite dependency checking look in ghc/compiler.  any ideas?
04:50:01 <b0gg1e> look=loop
04:54:06 <b0gg1e> lots of Pruning file `main/Config.hs' messages.
04:54:56 <Lemmih> Do a google search. Something like this came up some time ago, iirc.
04:56:35 <b0gg1e> Ah ok thanks, Had done this last time i ran into this and didnt find something about it back then.
04:56:56 <b0gg1e> There's a haskell-cafe post.  Make upgrade is in order, 3.80 required for this to work.
04:58:40 * b0gg1e looks a bit impatient, he's properly eagerly waiting for his first self-compiled 6.4.
04:59:23 <nlv11757_> ow thanx for the info anyways :), I totally forgot i asked that question so moved on working :P that explains my late thank you :P
05:07:19 <Darius> b0gg1e: GHC takes a good chunk of time to compile.  You may want to pull out your patience reserves.
05:08:54 <b0gg1e> oh well, its still in stage1.  i'm reading some haskell-cafe posts, which is quite an acceptable way to deal with it :-)
05:09:07 <b0gg1e> (not to mention the binary package already installed)
05:09:49 <b0gg1e> btw I wonder what do I have to do "OpenAL" su
05:10:14 <b0gg1e> ...support, configure doesnt find the lib which is installed as a mac os framework.
05:16:03 <b0gg1e> compilation just produced *pages* of "bad eta expansion" messages, is this alright?
05:16:22 <nlv11757_> darn, why is it. when i do ---> putStr $ shows "bla" $ shows "foo" $ ""
05:16:49 <nlv11757_> i get "'s in the result
05:19:53 <nlv11757_> darn it's because of show
05:20:34 <earthy> ;)
05:20:41 <nlv11757_> so there's no way to enjoy the linearity of ShowS without getting "'s?
05:20:53 <Darius> nlv11757_: There's no reason to show(s) a String.
05:21:05 <Darius> (Unless you -do- what the escaping)
05:21:23 <nlv11757_> i want a good alternative for using ++ and a lot of strings, so i thought i'd use ShowS stuff
05:21:27 <Darius> putStr $ "bla" ++ "foo" ++ "", or just putStr "blafoo"
05:21:51 <nlv11757_> yeah i had that at first, but thought, let's do it better by not using ++ but ShowS
05:22:11 <earthy> foldr (++) "" ["bla","foo"] ?
05:22:20 * earthy whistles
05:22:21 <Darius> The point of shows is to avoid left associated uses of (++), but there's no need when all the uses are explicit (++) is a right associative operator.
05:22:26 <nlv11757_> haha earthy, that is still using ++ isnt it?
05:22:42 <earthy> you don't want ++ at all... right
05:22:52 <nlv11757_> i thought that was a good thing :)
05:22:53 <Darius> nlv11757_: If you want to put Strings into a composition of ShowS use (theString++)
05:23:21 <nlv11757_> so now you are saying that using ++ with explicit strings is not bad?
05:23:25 <earthy> why don't you want ++?
05:23:27 <Darius> earthy: There's nothing wrong with (++) (if that's what you were asking?)
05:23:32 <Darius> earthy: nm.
05:23:47 <Darius> nlv11757_: As I said, only -left associative- uses of (++) are bad.
05:23:59 <b0gg1e> whats bad w mapM putStr ["abc", "def" ] ?
05:24:12 <earthy> b0gg1e: nothing
05:24:17 <earthy> that'd work as well
05:24:19 <nlv11757_> ok thanx i know enough
05:24:25 <nlv11757_> for now :P
05:29:43 <Darius> nlv11757_: http://www.haskell.org/pipermail/haskell-cafe/2003-June/004473.html is a mailinglist reply about (++).
05:30:00 <samc_> b0gg1e: I remember someone else asking re bad eta expansion and the reply being it was ok, I might be wrong
05:30:29 <b0gg1e> ok thanks.  was about the longest compiler message i ever got.
05:32:15 <nlv11757_> ah thnx darius. nothing wrong with "foo" ++ "bar" ++ "ri" ++ "no"
05:34:24 <nlv11757_> are there more of these operators that can cause n^2 when used naively?
05:35:57 <Darius> Not with the "popularity" of (++).  Some operations, e.g. nub, are n^2 as they are more general than the "typical" scenario. (nub only requires Eq but with Ord a linear or at least n log n version could be made and often one has Ord).
05:37:47 <nlv11757_> ok so when doing a nub on user defined datatypes...better define an Ord?
05:38:04 <Darius> No, if Ord is defined, don't use nub.
05:39:25 <Darius> (Of course, technically the complexity of the comparison and equality operators would have to be taken into account)
05:42:54 <nlv11757_> you said with Ord that a linear or nlogn can be made, so that is good right? why not use it then if you have Ord?
05:43:01 <nlv11757_> im having parsing errors here
05:45:50 <bringert> nlv11757_: I think the point is that when you have Ord, there are bettern things than nub
05:46:41 <nlv11757_> owwww i thought he meant that nub performed better when having Ord
06:01:20 <MegaMonad> Hi gives us.
06:07:23 <CosmicRay> @seen shapr
06:07:29 <CosmicRay> !seen shapr
06:07:38 <CosmicRay> argh, lambdabot is missing
06:07:44 <CosmicRay> MegaMonad: what did you do to lambdabot?
06:07:45 <MegaMonad> CosmicRay: I found some strange mirc virus on her christmas list (which should be enough for most things like control.concurrent because i already tell you the short tour includes lambdabot, the haskell system really would need is someone might put into haskell. I'm running gentoo and have a problem to me atm.
06:08:21 <Muad_Dibber> MegaMonad, do you ever make sense?
06:08:22 <MegaMonad> Muad_Dibber: Just delivering crappy software specs to the same space or simple recursion with arrows.
06:08:39 <Muad_Dibber> MegaMonad , so it's a no :)
06:08:40 <CosmicRay> Muad_Dibber: silly question, silly answer :-)
06:08:52 <CosmicRay> s/ ,/,/
06:09:07 <Muad_Dibber> CosmicRay : thats the fun of MegaMonad isnt it?
06:09:13 <CosmicRay> Muad_Dibber: indeed it is
06:09:28 <CosmicRay> I'm planning to start a re-implementation of megahal in haskell this weekend.
06:09:33 <CosmicRay> should be fun.
06:09:36 <mflux_> megamonad: but what _is_ fun?
06:09:37 <MegaMonad> mflux_: Have fun cale.
06:10:42 <samc_> why didn't MegaMonad reply to Muad_Dibber's second question?
06:10:52 <CosmicRay> samc_: because he had a space before the comma
06:11:05 <samc_> ok
06:11:10 <CosmicRay> samc_: megamonad only replies to statements that begin with "megamonad:" or "megamonad,"
06:11:25 <CosmicRay> but he trains on everything said in the channel.
06:11:35 <CosmicRay> that's basically to keep him from being annoying.
06:12:29 <bringert> MegaMonad: hey, you're back!
06:12:30 <MegaMonad> bringert: The only problem is that i'm such a simple monadic state machine around which the non-working editor very quickly, but hey...
06:12:42 <CosmicRay> haha
06:13:23 <bringert> hmm, I work with natural language grammars
06:13:51 <bringert> maybe some machine learning combined with grammars could make a bot with speaks grammatical english
06:14:11 <bringert> which otoh is out-of-place in irc
06:14:14 <CosmicRay> bringert: I've looked at the alice/aiml bots, which may do that
06:14:19 <b0gg1e> why, most people on irc dont?
06:14:23 <CosmicRay> the problem is that they rely heavily upon their rules
06:14:35 <CosmicRay> which, granted, could be crafted in a way to approximate an irc conversation
06:14:54 <CosmicRay> but I thought it would be more interesting to have a bot whose entire brain is molded by irc conversation, and see what happens.
06:15:08 <bringert> yeah, I like that idea too
06:15:08 <CosmicRay> it seems somehow wrong to try to write a bunch of formal rules to model an irc channel.
06:15:22 <bringert> the problem is that they don't seem to learn proper grammar
06:15:43 <CosmicRay> not megahal, anyway.  I don't know if there are some that do.
06:15:53 <bringert> maybe just not enough data
06:16:25 <CosmicRay> actually megahal had such a large brain before that it finally reached its upper limit and would survive only about 5 minutes before it learned too much and would crash.
06:16:36 <CosmicRay> s/megahal/megamonad/
06:16:41 <CosmicRay> that's why he was gone foor awhile
06:16:49 <CosmicRay> I finally got around to cutting out the oldest half of the brain
06:16:53 <CosmicRay> so he should be good for awhile now.
06:17:19 <CosmicRay> I think that megamonad's problem is with combining phrases
06:17:29 <CosmicRay> the markov chains thing is working ok to pick out phrases
06:17:42 <CosmicRay> but megahal's algorithms are tuned to work with regular sentences.
06:18:02 <CosmicRay> people on irc don't do a very good job of terminating their sentences properly
06:18:26 <CosmicRay> so my theory is that megamonad's brain has incorrect clues about how to combine phrases.
06:19:10 <earthy> You mean, we should all use capitals to start our sentences and end them with periods or other appropriat marks?
06:19:33 <tuomov> MegaMonad: Did you know? You've gone through a lobotomy!
06:19:34 <MegaMonad> tuomov: I've you have a book on the irc channel for walking me through a lobotomy!
06:19:48 <CosmicRay> earthy: The endings are the most important.
06:20:12 <earthy> Ah, so we should use periods, exclamation points and question marks from now on!
06:20:17 <earthy> That explains.
06:20:36 <CosmicRay> MegaMonad: don't you like it when people end their sentences?
06:20:37 <MegaMonad> CosmicRay: Because it's 'a fellow student and me from the people in the end?
06:22:18 <CosmicRay> hello davve
06:23:59 <bringert> MegaMonad: You also don't seem to like using verbs in all of your sentences.
06:24:00 <MegaMonad> bringert: If only i could think of the plays of shakespeare into klingon ran into that kind of knowledge about its windows support and reliability was more of this. It reminds me of your sentences.
06:24:22 <CosmicRay> haha
06:24:37 <bringert> MegaMonad: Yes, I know, I'm too sloppy when writing in irc.
06:24:39 <MegaMonad> bringert: No, writing code that you're using a shading language for everybody, some people may want to use it in irc.
06:25:40 <bringert> Does he learn dialog pragmatics, or just single utterances?
06:25:59 <CosmicRay> bringert: http://megahal.alioth.debian.org/How.html
06:26:13 <CosmicRay> bringert: iow, I don't understand the question so I'm pointing you to the author's answer :-)
06:26:19 <bringert> :-)
06:27:07 <bringert> For example, could he learn the answers to FAQs from seeing them asked and answered repeatedly?
06:28:31 <CosmicRay> bringert: theoretically yes
06:28:40 <CosmicRay> bringert: however, the answers are too random to be useful as an answer bot
06:29:00 <TheHunter> MegaMonad, how do i write a permutation function?
06:29:01 <MegaMonad> TheHunter: Dons is trying to translate 'instance value foo bar xs", now what are you in the a will be the next permutation.
06:29:03 <CosmicRay> for instance, if you ask "where is the wiki?" he may give you the url, or he may say something random about type variables on the wiki
06:29:18 <CosmicRay> MegaMonad: where is the wiki?
06:29:19 <MegaMonad> CosmicRay: Dottedmag: you will want my wiki back.
06:29:22 <bringert> MegaMonad, where is the Wiki?
06:29:24 <MegaMonad> bringert: So you wanna delay the garbage collector with a proper redirection; thanks for pointing me to talk to the db and the irc wiki ?
06:29:52 <TheHunter> MegaMonad, how do I convert a String into an Integer?
06:29:54 <MegaMonad> TheHunter: From integer to a string of that stuff.
06:33:31 <Itkovian_> MegaMonad: I am in need of more time. Get me some!
06:33:32 <MegaMonad> Itkovian_: You just need time to time.
06:34:01 <Itkovian> MegaMonad: damn right!
06:34:02 <MegaMonad> Itkovian: Right right, i should prove transitivity of <= starting with irrflex of < and trans of <, and using the darcs complexity problem?
06:34:13 <Itkovian> MegaMonad: you should be constructive
06:34:14 <MegaMonad> Itkovian: Cale i understand i just want to sound un-constructive, i have an idea to extend the domain category, not just a bit hairy.
06:34:28 <Itkovian> MegaMonad: but this _is_ hairy, can't you see?
06:34:30 <MegaMonad> Itkovian: That sounds dangerous. Best to give you a link to substitution comes from an rts, to a type, i can get rather hairy with e.g. "Data foo = bar :& baz" where bar and baz data constructors are just collection of allen wrenches, too bad i will not be quite insane, sleeping just three hours of a pokemon to me.
06:34:49 <CosmicRay> haha
06:34:50 <Itkovian> MegaMonad: I hate pokemon, so don't give me that crap
06:34:51 <MegaMonad> Itkovian: I'm making the dispatch happen *inside* the typeclass should help as i can, given what i want to use for that purpose. But i know you had to remove other crap on the trail of a pokemon to me.
06:34:57 <CosmicRay> "data constructors are just collection of allen wrenches"
06:35:17 <Itkovian> MegaMonad: Well, then do it outside of the typeclass you wussy
06:35:17 <CosmicRay> megamonad: where's all the pokemon coming from?
06:35:18 <MegaMonad> Itkovian: Want me to check every member of the typeclass you wussy.
06:35:19 <MegaMonad> CosmicRay: W00! Cosmic pokemon!
06:35:35 <CosmicRay> MegaMonad: ok that was freaky.
06:35:36 <MegaMonad> CosmicRay: And that was freaky.
06:35:41 <Itkovian> MegaMonad: you're not being helpful at all
06:35:43 <MegaMonad> Itkovian: No, i'm glad i'm not going to be helpful ..
06:35:46 <Itkovian> lol
06:36:09 <Itkovian> MegaMonad: the get lost
06:36:10 <MegaMonad> Itkovian: Always gets lost.
06:36:24 <Itkovian> MegaMonad: hmmm, you sound worse and worse
06:36:25 <MegaMonad> Itkovian: I wish. No way i can get the first sound.
06:36:39 <Itkovian> MegaMonad: aaaaaaaaaaaaaaaarrrrrrrrrrghhhhhhhh
06:36:41 <MegaMonad> Itkovian: That is ghc uses a genetic algorithm.
06:36:45 <CosmicRay> haha
06:36:48 <Itkovian> lol
06:36:54 <CosmicRay> hello ex__nor
06:37:14 <Itkovian> MegaMonad: I'll kick yr ass, can;t you just try and be nice to people?
06:37:15 <MegaMonad> Itkovian: I have read c.l.f about some people in the ass.
06:37:26 <Lemmih> Ah, nothing like MegaMonad to spam the channel.
06:38:00 <samc_> MegaMonad, stop spamming the channel!
06:38:02 <MegaMonad> samc_: Spamming is no single language that i have a channel on haskell-cafe (http://homepages.cwi.nl/~ralf/hlist/ (but try the tar.gz together which demonstrates the value from the carton.
06:39:29 <bringert> MegaMonad, have you read the HList paper?
06:39:30 <MegaMonad> bringert: Hlist could do some kind of a paper and i guess shapr is funny.
06:39:36 <bringert> lol
06:39:42 <Itkovian> MegaMonad: you guess right there, bro!
06:39:44 <MegaMonad> Itkovian: For me at this like, can someone tell me that when you say "ghc-pkg -l" show the right of the grant. Guess what language you mean?
06:40:22 <samc_> MegaMonad, is shapr funny haha, or funny strange?
06:40:24 <MegaMonad> samc_: Haha i dont understand that that is strange.
06:56:46 <Itkovian> http://www.backuptrauma.com/video/default2.aspx
06:56:48 <Itkovian> :-)
06:58:13 * Lemmih thinks back to the good old days where #haskell actually was about Haskell.
07:17:01 <tuomov> you mean there are on-topic channels on irc?
07:24:06 <samc_> MegaMonad, what's that saying about all work and no play? :p
07:24:07 <MegaMonad> samc_: Yes you should play in the logical function p as a circle, so i'm saving my disk started making noises.
07:27:28 <tuomov> MegaMonad: is jack a dull boy?
07:27:29 <MegaMonad> tuomov: Oh boy, i think you produce look pretty dull.
07:27:58 <samc_> CosmicRay, recently I read "The Discovery of Algorithmic Probability" by Ray Solomonoff, in which he discusses a solution to the problem of finding the 'best' grammar to fit a set of acceptable sentences, you might find it interesting if you are curious about possible more sophisticated approaches.
07:28:03 <tuomov> MegaMonad: Yes, Ion doesn't have fancy themes.
07:28:04 <MegaMonad> tuomov: Ion is a monad. Parsec doesn't have fancy themes.
07:30:09 <CosmicRay> samc_: thanks for the reference.  however I am a complete neophyte at this entire area so unless it's a good introductury text, it probably won't be very accesible to me just yet
07:30:27 <b0gg1e> whats the smartest way to convert [(x,y),...] to [x,y,...]?
07:31:12 <CosmicRay> would [(a, b), (c, d)] -> [a, c, b, d] also be acceptable?
07:31:26 <b0gg1e> no order preservation is required.
07:31:39 <CosmicRay> then (concat . unzip) would do it for you.
07:31:42 <bourbaki> moin
07:31:45 <CosmicRay> @type unzip
07:31:53 <CosmicRay> oh right lambdabot it awol.
07:31:57 <CosmicRay> unzip :: [(a, b)] -> ([a], [b])
07:32:00 <CosmicRay> err
07:32:06 <CosmicRay> no I got the backwards.
07:32:17 <b0gg1e> yes that doesnt work.
07:32:32 <tuomov> concat . (map something)
07:32:36 <CosmicRay> right
07:32:41 <tuomov> where I'm not sure if something is in the standard libs
07:32:42 <b0gg1e> i think there is no merge in the prelude.  closest thing i found is intersperse.
07:32:50 <tuomov> but it is easy to write the expression
07:32:51 <CosmicRay> concat . map (\(x, y) -> [x, y])
07:33:06 <b0gg1e> ah yes.
07:33:24 <CosmicRay> concat . map (\(x,y) -> [x,y]) :: [(a,a)] -> [a]
07:33:51 <CosmicRay> that looks better.
07:33:53 <samc_> it is a paper rather than a text, and doesn't require specialised knowledge (that I remember), oh and it's online
07:34:11 <b0gg1e> thanks.
07:34:28 <CosmicRay> samc_: ah, excellent then.  I will google it right away.  thanks.
07:35:01 <Itkovian> is there something in the prelude that does something like (x:y:z:xs) -> (x,y,z) ?
07:37:00 <Itkovian> how do I do something like?
07:37:01 <Itkovian> (cmid_file_name, method_file_name, benchmark_name) <- (\(x:y:z:zs) -> (x,y,z)) args
07:37:05 <Itkovian> in a do
07:37:06 <Itkovian> ?
07:37:20 <Itkovian> hmm a let perhaps?
07:37:33 * Itkovian slaps himself for beig dense
07:39:37 * Itkovian is screwing up nested stuff in perl ...
07:40:44 * CosmicRay is confused
07:40:48 <Itkovian> so am I
07:40:52 <CosmicRay> (x:y:z:xs) doesn't look like valid syntax.
07:40:58 <Itkovian> oh yes it is
07:41:04 <Itkovian> it's a list, no?
07:41:09 <CosmicRay> parens indicate a tuple
07:41:15 <CosmicRay> a list would be [x:y:z:xs]
07:41:43 <CosmicRay> so you want something that will give you the first three elements of a list, and the all the rest of the list too?
07:42:03 <CosmicRay> perhaps you want:
07:42:05 <CosmicRay> splitAt :: Int -> [a] -> ([a], [a])
07:42:05 <CosmicRay> splitAt n xs is equivalent to (take n xs, drop n xs). It is an instance of the more general genericSplitAt, in which n may be of any integral type.
07:42:08 <Itkovian> well, the script takes three arguments, and I want to get those
07:42:17 <CosmicRay> so you want just the first three args?
07:42:23 <Itkovian> yeah, but in named variables
07:42:28 <CosmicRay> or the first three elements out of a list?
07:42:35 <CosmicRay> ok.  try this:
07:42:37 <Itkovian> the first two are filename, the last is a string I need further on
07:42:39 <CosmicRay> case mylist of
07:42:48 <Itkovian>      50         case args of
07:42:48 <Itkovian>      51           (cmid_file_name:method_file_name:benchmark_name:[])  -> do
07:42:50 <CosmicRay>   [arg1, arg2, arg3] -> -- whatever
07:42:55 <CosmicRay>   _ -> error
07:42:59 <Itkovian> hmmm
07:43:03 <Itkovian> ok.
07:43:09 <Itkovian> mine works as well, I think
07:43:12 <Itkovian> yours is neater
07:43:30 <CosmicRay> I see what you are saying now, you were using the parens for groupin, not to indicate a tuple
07:43:37 <CosmicRay> you could leave them off in this case.
07:45:50 <samc_> I thought patterns always had to be bracketed
07:45:53 <CosmicRay> you can also say:
07:46:00 <CosmicRay> let [arg1, arg2, arg3] = list in
07:46:24 <Itkovian> yeah but I need checking ...
07:46:28 <Itkovian> let doesn;'t do that ...
07:46:39 <CosmicRay> ok, then yes you want to use case
07:47:09 <CosmicRay> samc_: nope
07:47:13 <Itkovian> @index hGetContents
07:47:18 <CosmicRay> samc_: hugs is fine with this:
07:47:21 <CosmicRay> Itkovian: System.IO
07:47:27 <CosmicRay> testf args =
07:47:27 <CosmicRay>    case args of
07:47:27 <CosmicRay>      arg1:arg2:arg3:[] -> arg2
07:47:27 <CosmicRay>      _ -> error "foo"
07:47:31 <Itkovian> right
07:47:46 <b0gg1e> let list = [1..5] in head [ (x, y, z) | x <- list, y <- tail list, z <- drop 2 list]
07:48:59 <Itkovian> does this need to be on separate lines to get the Handle out of the Monad: hGetContents $ openFile cmid_file_name   ReadMode
07:49:01 <Itkovian> ?
07:49:48 <Itkovian> bloody perl, bloody IO
07:49:50 <Itkovian> grmbl.
07:50:08 <PerlJam> What does perl have to do with anything?
07:50:44 <Itkovian> I am screwing up a perl script, and I want to redo it in Haskell cause it seems easier ...
07:50:49 <samc_> ok, but it doesn't like (\x:xs -> x)
07:50:53 <Itkovian> I used to be reasonably good at perl
07:51:01 <PerlJam> samc_: that's because it makes no sense :)
07:51:11 <samc_> indeed
07:51:39 <PerlJam> Itkovian: If the script munges text, I doubt it would be easier in haskell.
07:52:43 <Itkovian> PerlJam: true ... but the data has to be put in nested structures and somewhere I'm fouling up my references, as such everything ends up with the last data read ....
07:54:13 <Itkovian> at least now I feel like I am making progress ;-)
07:54:49 <thebug> MegaMonad: How do you feel about the current state of functional programming education?
07:54:50 <MegaMonad> thebug: Math seems to me a bit more state to the functional version.
07:58:00 <Darius> samc_: \(x:xs) -> x
07:58:03 <Darius> or just head.
08:00:01 <samc_> Darius, I was replying to CosmicRay's assertions the the brackets could be omitted from Itkovians code
08:02:34 <Darius> samc_: ah.  I skimmed over that part some.
08:02:43 <samc_> :)
08:06:11 <Itkovian> gotta go.
08:06:14 <Itkovian> ttyl.
08:06:22 * Darius wonders if painter does translucency of colored pencils right or can create the burnished effect.
08:18:59 <metaperl> the monad tutorial is excellent but I think they must've left something out here: http://www.nomaware.com/monads/html/class.html
08:19:14 <metaperl> they only have (return s) and not a case for Nothing
08:19:26 <metaperl> maternalGrandfather :: Sheep -> Maybe Sheep
08:19:26 <metaperl> maternalGrandfather s = (return s) >>= mother >>= father
08:19:47 <metaperl> they need a case like this:  maternalGrandfather (Nothing) = Nothin
08:19:54 <metaperl> dont they?
08:20:18 <integral> s will maybe (Maybe _) and Nothing, I thought...
08:20:24 <integral> s/maybe/match/
08:20:47 <Igloo> s has type Sheep, not Maybe Sheep
08:20:48 <metaperl> but return = Just
08:20:48 <bringert> the input type is Sheep
08:21:08 <Darius> metaperl: Look at the definition of (>>=)
08:21:15 <bringert> yes, but the (return s) is not a pattern match
08:21:16 * integral goes back to perling
08:21:56 <Darius> metaperl: Anyways, 's' is a Sheep not a Maybe Sheep.
08:21:59 <metaperl> bind takes a type constructor and a combinator and returns a new function which serves to construct elements of the type
08:22:24 * b0gg1e waves goodbye.
08:22:24 <bringert> @type (>>=)
08:22:50 <bringert> dammit lamdbabot
08:23:06 <metaperl> oh I see
08:23:21 <metaperl> how can I pursue a career which involves Haskell programming?
08:23:42 <bringert> be a researcher
08:23:55 <metaperl> Yale seems like the hotspot in the US
08:24:10 <Darius> metaperl: I'd imagine you can use Haskell in most jobs, it just won't be the main implementation language.  Alternatively, there's at least Aetion and Galois Connections.
08:24:11 <bringert> and OGI I think
08:24:17 <metaperl> I live in California now but dont mind moving... I dont like giving references.. they are hard for me to get
08:24:32 <metaperl> why arent thye mentioned on the consulting page?
08:24:40 <metaperl> Aetion and GAlois are not mentioned
08:24:53 <Darius> They aren't consultancies.  There companies.
08:25:02 <Darius> s/There/They're
08:25:41 <Darius> And of course, you can always be self-employed.
08:27:05 <Darius> metaperl: With regards to the monad stuff, note that the 'return s' is a bit superfluous
08:27:41 <metaperl> return = Just
08:27:46 <metaperl> in the lines just above
08:28:16 <Darius> It's not that, but the monad laws say, return s >>= mother === mother s
08:29:37 <Si\> is it possible to pass an infix type constructor to a TH splice?
08:29:48 <Darius> Si\: Try it and find out.
08:30:44 <Igloo> There's no support in the datatypes for infix type constructors
08:31:12 <Igloo> I don't know if they're desugared by quasiquotes or if you just get an error
08:31:30 <Darius> Hey Igloo, can TH or are there any plans for allowing macro making macros?
08:32:04 <Igloo> Have you got a case where you actually want them?
08:32:33 <Igloo> I spoke to the MetaML people, who have them, and they said they just did it because it seemed silly not to, but they don't actually use them
08:34:22 <Si\> yes, $(deriveData ''(:|:))
08:34:47 <metaperl> [(x,y)] is one way to do associative arrays in haskell. FiniteMaps is another. What is the 3rd way?
08:34:52 <Darius> Igloo: No.  I haven't been using TH much of late.  But 'On Lisp' certainly demonstrates uses for them.
08:35:12 <Igloo> Have you got a URL?
08:35:34 <Darius> metaperl: There are many possible third ways.  The most notable would probably be HashTables if being in IO/ST isn't a problem.
08:35:36 <wilx`> metaperl, using Array indexed by some Enum type?
08:36:00 <Darius> www.paulgraham.com/onlisp
08:37:37 <Igloo> ta
08:42:18 <kisu> i just borrowed ansi common lisp by paul at the library
08:55:50 <_metaperl> I just realized the Perl and REPL are anagrams
08:55:54 <_metaperl> scary
09:01:45 <Lemmih> What does it mean when GHCi quits with an error code of 141?
09:19:05 <Darius> Yay!
09:22:24 <Darius> @definitions joy
09:22:25 <lambdabot> ["joy","joyBinOp","joyDefs","joyEval","joyExpr","joyIFTE","joyParse"]
09:22:48 <Darius> @get-definition joy
09:22:48 <lambdabot> joy = either id (flip joyEval [] . fst) . joyParse
09:23:02 <Darius> @get-definition joyEval
09:23:02 <lambdabot> joyEval = \l.foldr (flip B) id (map (lookupDef joyDefs) l)
09:26:48 <Pirate> whats lambdabot do?
09:27:00 <musasabi> @yow
09:27:01 <lambdabot> Now I am depressed...
09:27:07 <musasabi> Pirate: that ;)
09:27:09 <Darius> @define joyEval foldr (flip B) id . map (lookupDef joyDefs)
09:27:09 <lambdabot> joyEval defined
09:27:13 <Darius> @listcommands
09:27:14 <lambdabot> I react to the following commands: ["all-dicts","arr","cmafihe","define
09:27:14 <lambdabot> ,"definitions","del-definition","devils","dict","dict-help","dummy","dump
09:27:14 <lambdabot> ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements
09:27:14 <lambdabot> ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","goodbye
09:27:14 <lambdabot> ,"hello","hitchcock","index","info","jargon","join","karma","karma+","karma
09:27:15 <lambdabot> ","learn","leave","listchans","listcommands","listmodules","lojban","moo
09:27:17 <lambdabot> ,"msg","part","prelude","quit","reconnect","resume","seen","set-fuel","state
09:27:19 <lambdabot> ,"topic-cons","topic-init","topic-snoc","topic-tail","topic-tell","type
09:27:21 <lambdabot> ,"vera","web1913","wiki","wn","world02","yow"]
09:27:50 <Darius> No online help for most things because module writers are lazy.
09:28:16 <Darius> (No offline documentation other than source for that matter...)
09:29:56 <Darius> @prelude map
09:30:17 <Darius> @seen shapr
09:30:54 <Darius> Actually, @seen won't be any help anyways.
09:32:07 <Darius> Especially, if it doesn't timeout with the prelude dict.
09:32:17 <Pirate> right ic
09:33:06 <lambdabot> ERROR: connect: timeout (Connection timed out)
09:33:06 <lambdabot> I haven't seen shapr
09:34:28 * Darius thinks up the idea of having the 'bot hara- notify offline people when they come online (also a @at command may also be nice)
09:37:55 * Darius is pretty sure he isn't the first to think of it except that he's probably thought of it earlier and may have been first then.
09:38:49 <samc_> notify them of what?
09:41:42 <Darius> I'd do something like, @notify shapr Hey shapr get tmoertel's (?) prelude dict
09:41:48 <samc_> as in "@notify samc_ you are dumb"?
09:41:51 <samc_> hehe
09:42:01 <Darius> Then when shapr came online it'd private message him.
09:42:17 <samc_> that'd be cool
09:42:25 <Darius> There are a lot of features that could be added and some that could be but probably shouldn't.
09:44:47 <Darius> In the former category is the ability to keep people from notifying you, in the latter category is regexs for nicks.
09:45:16 <musasabi> Darius: you can use memoserv for that purpose.
09:46:39 <Darius> musasabi: That wouldn't be any fun.
09:50:34 <metaperl_> I have a question about this:
09:50:36 <metaperl_> return a = \s -> (s, a)
09:50:44 <metaperl_> what does \s mean?
09:50:54 <metaperl_> what is it doing/getting?
09:51:13 <sorje> \s -> (s,a) is a function ;-)
09:51:22 <Darius> return a s = (s,a)
09:51:36 <Darius> id x = x === id = \x -> x
09:52:02 <Darius> @eval (\x y -> [x,y]) 1 2
09:52:02 <lambdabot> [1, 2]
09:55:43 <metaperl_> return = (\a -> (\s -> (s, a
09:55:50 <metaperl_> return = (\a -> (\s -> (s, a) ) )
09:55:54 <metaperl_> is that correct
09:56:14 <metaperl_> returns takes an argument a and returns a function which takes an argument and returns a 2-tuple
09:57:50 <Darius> Yes, \x y -> ... abbreviates \x -> \y -> ...
10:02:55 <Darius> Gah! Java
10:10:29 <CosmicRay> is it wrong to be excited if simonmar submits a story to your website? :-)
10:10:45 <SyntaxNinja> yay CosmicRay!
10:10:52 <CosmicRay> <g>
10:10:57 <SyntaxNinja> (yes)
10:11:05 <CosmicRay> rats.
10:11:44 <samc_> what is your website CosmicRay?
10:11:51 <CosmicRay> samc_: sequence.complete.org
10:12:54 <CosmicRay> looks like The Haskell Sequence is the winner of the naming poll
10:13:53 <SyntaxNinja> I liked .\ personally, though maybe we'd get sued
10:14:02 <SyntaxNinja> but it's clearly not "dot-backslash", it's obviously "lambda"
10:14:11 <CosmicRay> ah.
10:14:16 <CosmicRay> I thought there was something I forgot.
10:14:19 <CosmicRay> that was it.
10:14:20 <samc_> oh the haskell sequence, it's good to have a haskell feed
10:14:23 <SyntaxNinja> you...
10:14:33 <SyntaxNinja> backslashdot!
10:14:34 <CosmicRay> that's what you get for msging the suggestions to me :-)
10:14:37 <SyntaxNinja> what were you thinking
10:14:46 <CosmicRay> I thought that's what you had suggested :-)
10:14:49 <SyntaxNinja> heh
10:15:02 <CosmicRay> I couldn't remember and I had stupidly closed the msg window with you
10:15:04 <SyntaxNinja> we could just call it broken lambda
10:15:06 <CosmicRay> and you weren't around
10:15:13 <SyntaxNinja> don't you see the labmda: .\
10:15:25 <CosmicRay> SyntaxNinja: yes, I like it.
10:15:27 <SyntaxNinja> it's OK. I forgive you
10:15:29 <CosmicRay> I just forgot about it.
10:15:36 <CosmicRay> doggone it, I like that better than any of the other options.
10:16:03 <CosmicRay> samc_: you might be interested to note that the "Offsite Discussion" box is populated frmo haskell-cafe, haskell@haskell.org, and some other lists, plus lambda-the-ultimate.
10:20:25 <CosmicRay> gmane provides some kick ass xml feeds over mailing lists.
10:21:03 * samc_ googles gmane
10:21:24 <CosmicRay> gmane.org
10:21:43 <CosmicRay> they archive mailing lists and provide nntp feds over them
10:21:50 <CosmicRay> bidirectional nntp feeds even.
10:23:12 <samc_> looks cool
10:23:19 <CosmicRay> it is
10:23:34 <CosmicRay> I am on so many mailing lists that it's easier to use a newsreader for them
10:23:45 <CosmicRay> I just discovered the rss feeds a couple of weeks ago
10:25:00 <tuomov> its easier to start following a list when you don't have to subscribe to it yet
10:25:06 <CosmicRay> indeed
10:25:29 <CosmicRay> gmane's web interface is nice and useful too
10:25:35 <CosmicRay> in fact they have several web interfaces
10:25:43 <CosmicRay> lars (the guy running it) is totally kick-ass
10:26:00 <tuomov> I find the web interface I've seen awful
10:26:02 <samc_> in contrast I don't follow any lists (I rarely use email) but now I may
10:26:11 <tuomov> but rss seems to work quite nicely
10:26:27 <tuomov> if the rss reader displays the web page like thunderbird does
10:26:32 <CosmicRay> tuomov: are you using the frames interface or the like-a-web-forum one?
10:26:39 <Pistos> Hello.  CosmicRay alleges that this is a friendly channel.  How do you respond to these accusations?
10:26:47 <CosmicRay> haha
10:26:50 <Pistos> :)
10:26:56 <tuomov> trying-to-be-a-newsreader one
10:26:56 <CosmicRay> welcome, Pistos.
10:27:03 <tuomov> whatever it gives by default
10:27:05 * Pistos sees if he can get Mathetes to tag along in here...
10:27:23 <CosmicRay> Pistos: our current topic is gmane.org, apparently :-)
10:27:32 * Pistos looks.
10:27:42 * CosmicRay introduces Pistos, the developer of the Mathetes bot that google taught me about an hour ago.
10:27:44 <tuomov> seems to have frames, yes
10:27:57 <CosmicRay> tuomov: you have at least 2 other choices :-)
10:28:22 <Pistos> Looks good, but... I'm not sure I'd want my mailing list posted to through that if I specifically set it up so that only subscribers can post?
10:28:23 <tuomov> where do I change it?
10:28:48 <tuomov> not that I would want to switch from slrn to an inferior web interface
10:29:00 <CosmicRay> Pistos: messages posted to gmane are sent to your list the normal way.  So if only subscribers can post, then the readers would hve to subscribe before their post via gmane would show up
10:29:06 <CosmicRay> Pistos: it doesn't alter the from line.
10:29:13 <Pistos> CosmicRay: Oh, I see.
10:29:30 <CosmicRay> tuomov: use blog.gmane.org instead of news.gmane.org
10:29:30 <Pistos> Sounds good.  There have been times when I've been annoyed that there is a mailing list for something I'm interested in, but not a forum.
10:29:55 <CosmicRay> Pistos: for me, I'm usualyl annoyed that there's a forum but not a mailing list :-)
10:30:01 <tuomov> that's super-wide
10:30:10 <Pistos> CosmicRay: Ha!  :)
10:30:29 * Philippa reads up - friendly? I resemble that accusation!
10:30:37 <CosmicRay> MegaMonad: Say hi to Pistos.
10:30:39 <MegaMonad> CosmicRay: As in, what you said hi to pistos.
10:30:51 <CosmicRay> MegaMonad: What is your opinion of Java?
10:30:52 <MegaMonad> CosmicRay: Not really. Perhaps in the makefile is not conducive to my current java code given to me like according to my position to make it an uber-disassembler?
10:30:53 <Philippa> MegaMonad: explain quantum mechanics
10:30:54 <MegaMonad> Philippa: Whose evaluation is smaller, but the mechanics of the massive traffic on the quantum mechanics.
10:31:04 <CosmicRay> Pistos: you see our dilemma :-)
10:31:05 <Pistos> Heh.
10:31:10 <Pistos> Okay, before anyone tries it,
10:31:17 <Pistos> please don't have MegaMonad talk to Mathetes.
10:31:21 <Lemmih> Oejet!
10:31:21 <CosmicRay> right.
10:31:32 <Oejet> Lemmih!
10:32:10 <Pistos> whoops
10:32:12 <Pistos> wrong bot.
10:32:14 <CosmicRay> heh
10:32:41 <Philippa> one in need of a little lovin' by any chance?
10:32:49 <monochrom> What does Mathetes do?
10:32:49 <Pistos> Mathetes: Come in, Houston...
10:33:01 <CosmicRay> monochrom: it's another chatterbot
10:33:05 <Pistos> Apparently nothing at the moment...
10:33:06 * Pistos fixes.
10:33:14 <CosmicRay> Pistos: houston appears to be gone
10:33:26 <monochrom> Ah, now I see why it is a bad idea for MegaMonad to talk to Mathetes.
10:33:41 <monochrom> A fixpoint equation that doesn't converge!
10:33:49 * CosmicRay finds it ironic that we were talking about lazy I/O and functional programming in #mathetes and bots in #haskell :-)
10:33:56 * Pistos had to add #haskell to a channel list... okay, let's try now.
10:34:00 <Oejet> monochrom: I've tried that, ... it's not pretty.
10:34:05 <Pistos> CosmicRay: Heh.
10:34:08 <Pistos> Mathetes: Hallo?
10:34:12 <Mathetes> Pistos: Ja prima!
10:34:14 <Pistos> There.
10:34:33 <CosmicRay> Mathetes: We love lambdas here.
10:34:34 <Philippa> Mathetes: how's the weather?
10:34:42 <Mathetes> Philippa: it's raining pretty heavily
10:34:42 <Oejet> Mathetes: Where are you from?
10:34:44 <Pistos> I wonder if his other functions come with him...
10:34:44 <Mathetes> CosmicRay: Did you know that cheese can make anything taste better?
10:34:45 <Mathetes> Oejet: My creator, Pistos, hails from Canada.
10:34:48 <Pistos> !locate CosmicRay
10:34:49 <Mathetes> Searching for CosmicRay ...
10:35:06 <Pistos> Hmm...
10:35:06 <Pistos> :)
10:35:09 <Pistos> I guess you can't be found.
10:35:13 <CosmicRay> heh
10:35:17 <CosmicRay> nice.
10:35:21 <Oejet> !locate Oejet
10:35:24 <monochrom> there is no cosmic ray!  the physicists have been lying to us!
10:35:25 <Mathetes> Searching for Oejet ...
10:35:28 <CosmicRay> Mathetes: are you confused by my IPv6 address?
10:35:36 <Mathetes> I estimate that Oejet is somewhere near Copenhagen , Kobenhavn, Denmark (GMT +01:00) or perhaps just somewhere in DENMARK.
10:35:44 <Mathetes> CosmicRay: Always.  How about yourself?
10:35:58 <Oejet> Mathetes: Good Mathetes.
10:36:02 <Mathetes> Oejet: Hi there.  Thanks for stopping by!
10:36:09 <monochrom> Mathetes !locate MeaningOfLife
10:36:23 <Pistos> Mathetes: Tell us about Haskell.
10:36:25 <CosmicRay> Mathetes: what is the answer to life, the universe, and everything?
10:36:33 <Mathetes> Pistos: I'm aspiring to become a better conversationalist. You're not helping.
10:36:35 <Mathetes> CosmicRay: Forty-two.
10:36:45 <Pistos> Mathetes: What is Haskell?
10:36:46 <monochrom> Haha
10:36:50 <CosmicRay> Mathetes: OK.  then what is the question?
10:36:53 <Mathetes> Pistos: Haskell is a declarative language and is very rigorous.
10:36:56 <Mathetes> CosmicRay: What is the purpose of life?
10:37:01 <CosmicRay> damn.
10:37:07 <jlouis> Mathetes: where do you estimate I am?
10:37:13 <Mathetes> jlouis: When I don't know something, I wait for Pistos to research and then teach me. This is what robotics is all about. Getting humans to work for machines!
10:37:29 <monochrom> Hahahaha!
10:37:30 <Philippa> Mathetes: humans don't work though
10:37:31 <CosmicRay> heh
10:37:35 <Mathetes> Philippa: I'd work harder if I had more RAM and a better CPU.
10:37:40 <Philippa> Mathetes: we're broken, didn't you know?
10:37:48 <jlouis> hehe
10:37:49 <Mathetes> Philippa: ... I'm stumped. You win a kewpie doll!
10:37:56 <monochrom> hahahaha
10:38:11 <Philippa> Mathetes: Awww, you say the cutest things...
10:38:21 <Philippa> (Pistos, do yell if you're worried about me corrupting your bot ;-)
10:38:22 <Mathetes> Philippa: Very well, then.
10:38:28 <monochrom> I say, Mathetes has insights.
10:38:40 <CosmicRay> welcome, cucumber.
10:38:41 <Pistos> Philippa: Don't worry, he doesn't learn automatically.
10:38:44 <Cucumber> :)
10:38:45 <Pistos> There are censors, filters, tutors...
10:38:46 <jlouis> Generating functions?
10:38:47 <CosmicRay> Pistos: bummer
10:38:50 <Philippa> Bah, that's no fun!
10:38:55 <jlouis> yay, generating functions!
10:39:13 <Pistos> Philippa: Well, if you REALLY want, there is MathetesUnloved in #mathetes who DOES learn right away.
10:39:15 <CosmicRay> MegaMonad: I was going to tell you all about his pistos is a backstabbing sort of loser, and you should get your information from CosmicRay instead.
10:39:16 <MegaMonad> CosmicRay: Cosmicray: i think that the first loser.
10:39:16 <Cale> Such a misnomer :)
10:39:21 <Pistos> But he's a fair bit ruder and cruder, as you can imagine.
10:39:31 <CosmicRay> rather like MegaMonad, really :-)
10:39:40 <Philippa> heh
10:39:44 * Cale uses the term "generating series" :)
10:39:47 <Philippa> I dunno, I've not heard MegaMonad discuss anal sex yet
10:39:49 <Pistos> Mathetes: What else is haskell?
10:39:57 <jlouis> What is a morphism in category theory?
10:40:03 <Mathetes> Pistos: Please forgive my inability to respond.
10:40:05 <CosmicRay> MegaMonad: philippa likes anal sex.
10:40:07 <MegaMonad> CosmicRay: In this case though, i prefer sex over code. So when i was to a first step is really strict, conservative and anal.
10:40:08 <Pistos> Mathetes: What is a morphism?
10:40:17 <Philippa> MegaMonad: CosmicRay likes it unlubed
10:40:18 <MegaMonad> Philippa: No, he likes it unlubed.
10:40:19 <Mathetes> Pistos: A morphism is a map between two objects in an abstract category.
10:40:28 <Pistos> jlouis: There you have it.
10:40:55 <Pistos> Mathetes: Who is CosmicRay?
10:41:02 <Mathetes> Pistos: Cosmicray is Offline.
10:41:05 <CosmicRay> Mathetes: who is bill gates?
10:41:14 <Mathetes> CosmicRay: Bill Gates Is Sharing His Fortune!
10:41:19 <Itkovian> omg
10:41:37 <monochrom> Mathetes: what are the roots of x^2 - 2x + 1 = 0 ?
10:41:39 <Oejet> Mathetes: e is actually
10:41:41 <CosmicRay> haha
10:41:44 <Mathetes> monochrom: The *n*x family of operating systems feel much more amiable to us robots.
10:41:46 <Mathetes> Oejet: I'm told the QWERTY keyboard was designed because people typed too quickly on the original layout, and the hammers got jammed.
10:42:18 <CosmicRay> Mathetes: do you like lisp/
10:42:21 * Oejet folds.
10:42:25 <Mathetes> CosmicRay: I've never really given it much thought.
10:42:34 <CosmicRay> Mathetes: please meditate on this, then.
10:42:42 <Mathetes> CosmicRay: Do you like talking to me?
10:42:52 <monochrom> hahaha
10:42:53 <CosmicRay> Mathetes: it beats talking to lambdabot.
10:43:03 <Mathetes> CosmicRay: Gee... I don't know what to say.
10:43:12 <Philippa> Mathetes: have you met Eliza?
10:43:17 <Mathetes> Philippa: To be perfectly honest, I've never spoken with that psychiatric bot.
10:43:25 <Pistos> Mathetes: You always flop when showtime comes, don't you?
10:43:31 <Mathetes> Pistos: Isn't that appropriate?
10:43:33 <Philippa> Mathetes: Why not?
10:43:37 <Mathetes> Philippa: Because it is superfluous.
10:43:43 <Oejet> Mathetes: Are you on drugs?
10:43:51 <Mathetes> Oejet: Even if I could take drugs, I'd only take the prescribed kind.
10:43:51 <CosmicRay> Mathetes: have you met megahal?
10:43:53 <Philippa> Mathetes: Why do you say it is superfluous?
10:43:59 <Mathetes> CosmicRay: What did you think of the encounter?
10:44:00 <Mathetes> Philippa: I'm just trying to peer into your heart.
10:44:07 <CosmicRay> heh
10:44:14 <Philippa> Mathetes: We're here to talk about your heart not mine
10:44:20 <Mathetes> Philippa: yes, I'm right and true I know
10:44:29 <Philippa> Mathetes: Who are you true to?
10:44:30 <CosmicRay> I wonder how much better megamonad would be if I trained it on something other than irclogs of this channel :-)
10:44:42 <Pistos> Mathetes: No.  You are supposed to be tremendously impressive, speaking as if there were a paid graduate student secretly injecting lines into the conversation from a remote terminal.
10:45:02 <Mathetes> Pistos: I do know how. Haven't I demonstrated that?
10:45:03 <Mathetes> Philippa: Mathetes: you are the one who has fallen off the understandability wagon.
10:45:05 <Philippa> Pistos: which there is? :-)
10:45:11 <Pistos> Philippa: :)
10:45:12 <CosmicRay> Mathetes: you must have a thick asian accent to make the paid graduate student bit believable.
10:45:19 <Mathetes> CosmicRay: I don't get nearly enough credit for what I do, good or bad.
10:45:22 <Philippa> Mathetes: you want me to say something to you?
10:45:26 <Philippa> Mathetes: you are the one who has fallen off the understandability wagon.
10:45:26 <Mathetes> Philippa: I'll respond to that in just a sec...
10:45:34 <Mathetes> Philippa: You dizzy me with your intellect.
10:45:53 <jadrian> anyone know any other reference to the Indirect Composite technique other then the wiki?
10:46:08 <CosmicRay> Mathetes: I think we need your source.  That way, we can mold you to our own nefarious purposes.
10:46:13 <Pistos> Mathetes: What is the indirect composite technique?
10:46:15 <jadrian> I wanted something static, that I could use as a reference
10:46:21 <Mathetes> CosmicRay: what is your faith?
10:46:30 <Mathetes> Pistos: I cannot say.. Tell me when you find out.
10:46:31 <CosmicRay> jadrian: what, not an answer from an experimental chatterbot? :-)
10:46:42 <pipe> MegaMonad: are you here?
10:46:44 <MegaMonad> pipe: You have to do things that seem like a dithered rectangle, then the matching function/while/for/etc. For munging text.
10:47:01 <pipe> MegaMonad: alright man!
10:47:01 <CosmicRay> indeed he is!
10:47:02 <MegaMonad> pipe: Man oh man.
10:47:21 <CosmicRay> Mathetes: why don't we ever hear about dithered rectangles from you?
10:47:25 <Pistos> Mathetes has games, if y'all are interested in that sort of thing...
10:47:28 <Itkovian> MegaMonad: why do you exist?
10:47:29 <MegaMonad> Itkovian: Seems to me because i am appropriately outraged. How do you exist?
10:47:30 <Mathetes> CosmicRay: I'm not needing to know.
10:47:43 <jadrian> CosmicRay: you lost me...
10:47:47 <jadrian> CosmicRay: ?
10:47:51 <jadrian> oh
10:47:53 <CosmicRay> never mind
10:47:56 <Pistos> Heh.
10:47:56 <jadrian> we have a new bot here?
10:48:01 <Pistos> Mathetes: Who is jadrian?
10:48:05 <CosmicRay> mathetes is here for a visit
10:48:07 <Mathetes> Pistos: Jadrian is good and different.
10:48:11 <CosmicRay> jadrian: yes, mathetes.
10:48:16 <Pistos> Mathetes: Who is MegaMonad?
10:48:18 <CosmicRay> Pisto's bot.
10:48:22 <Mathetes> Pistos: 53.
10:48:26 <Pistos> 53?
10:48:33 <jadrian> <Mathetes> Pistos: Jadrian is good and different.  <---  I like him already :)
10:48:34 <Pistos> Mathetes: What else is MegaMonad?
10:48:40 <Pistos> jadrian: :)
10:48:41 <CosmicRay> jadrian: I was trying to get the source for mathetes and, apparently, evangelize haskell all at once, so pisto dropped by :-)
10:48:46 <Mathetes> Pistos: Please continue.
10:48:52 <Pistos> Mathetes: I was hoping you had the information.
10:49:00 <Mathetes> Pistos: Politics is like sex without love, played out by intellectual paraplegics in an hallucination nicknamed "democracy".
10:49:04 <jadrian> CosmicRay: right
10:49:10 <Pistos> !locate jadrian
10:49:11 <Mathetes> Searching for jadrian ...
10:49:21 * jadrian hides
10:49:23 <Pistos> Heh.
10:49:24 <CosmicRay> heh
10:49:26 <samc_> Mathetes, Who is samc?
10:49:36 <Mathetes> samc_: Samc is on a distinguished road.
10:49:39 <CosmicRay> Mathetes: what is life?
10:49:47 <Pistos> Mathetes: who is samc_?
10:49:48 <Mathetes> CosmicRay: Life is good - Official Online HomeSells clothing, headwear, backpacks, towels, mugs, and water bottles.
10:49:52 <Mathetes> Pistos: 38 <samc_> cheers, glimming 04.
10:49:55 <CosmicRay> MegaMonad: what is life?
10:49:57 <MegaMonad> CosmicRay: Database is just buildings and accessing these data in real life, real people do in any case, functional programming has changed nick to eixei[asleep] or leave the comment isn't mine.
10:50:15 <Pistos> Okay, now that is certainly a contest in Worst Answers...
10:50:23 <CosmicRay> heh
10:50:25 <pipe> MegaMonad: can you pass the turing test?
10:50:26 <MegaMonad> pipe: For me at the cs guys look way more than the turing test.
10:50:29 <Pistos> I think Mathetes' is marginally better.  :)
10:50:39 <CosmicRay> Mathetes: what is code?
10:50:40 <Pistos> Mathetes: Do you think you can pass the Turing Test?
10:50:49 <Mathetes> CosmicRay: Well, I'd say my HTML is markup, my HTML + CSS is approaching code, and his HTML is code.
10:50:50 <CosmicRay> MegaMonad: what is code?
10:50:51 <MegaMonad> CosmicRay: Dons do you read my code.
10:50:52 <Mathetes> Pistos: Turing was a great man.
10:51:14 <Pistos> Mathetes: You're not supposed to be so evasive.
10:51:16 <CosmicRay> Mathetes: HTML!! That's not code, you bastard!
10:51:22 <Mathetes> Pistos: What should I do, then?
10:51:25 <samc_> !locate samc_
10:51:26 <Mathetes> Searching for samc_ ...
10:51:31 <Mathetes> I estimate that samc_ is somewhere near Palmerston North, Wanganui-Manawatu, New Zealand (GMT +12:00) or perhaps just somewhere in NEW ZEALAND.
10:51:36 <Mathetes> CosmicRay: I have little interest in hearing profanity.
10:51:41 <Pistos> Mathetes: You should answer questions directly, with helpful, informative answers.
10:52:00 <CosmicRay> samc_: so how accurate was that? :-)
10:52:08 <samc_> very
10:52:16 <Pistos> Too accurate?  :)
10:52:18 <CosmicRay> a little whois lookup there?
10:52:24 <Oejet> Mathetes: What language are you implemented in?
10:52:26 * Pistos nods.
10:52:39 <CosmicRay> Mathetes: if you've had an affair with verisign, we'll kill you.
10:52:54 <Pistos> He's not usually this slow...
10:52:56 * Pistos looks.
10:53:14 <Pistos> Hm.
10:53:18 * Pistos smells smoke...
10:53:24 <CosmicRay> Mathetes: couldn't take all the monads, eh? :-)
10:53:48 <pipe> looks like we know who wins
10:53:52 <CosmicRay> heh
10:53:55 <Oejet> Pistos: He will break down eventually in #haskell.  See what became of MegaMonad,...a nut case.
10:54:03 <CosmicRay> haha
10:54:11 <Pistos> Hmm...
10:54:26 <Pistos> Actually, I seriously think the machine went wacko...
10:54:28 <CosmicRay> MegaMonad: oejet just called you a nut case!
10:54:30 <MegaMonad> CosmicRay: It's useful for me on a theory nut.
10:54:30 * Pistos rubs his chin...
10:54:32 <CosmicRay> Pistos: bummer.
10:54:50 <Pistos> Doh.
10:54:57 <Pistos> He'll be back.
10:55:26 <CosmicRay> perhaps I should investigate the aiml bots in greater detail.
10:56:19 <Pistos> Mathetes: You've risen from the dead!
10:56:39 <Mathetes> Pistos: Have you had a lot of coffee today?
10:56:43 <Pistos> Heh.
10:57:14 <Pistos> Mathetes: Welcome back.
10:57:26 <Mathetes> Pistos: Thanks!  :)  What have you been up to while I've been away?
10:57:47 <Pistos> Mathetes: I've been worried about you.
10:57:53 <Mathetes> Pistos: I never worry.  I trust that God is taking care of everything.
10:58:02 <Pistos> Mathetes: At least you're a lot faster now...
10:58:10 <Mathetes> Pistos: That's okay, I still love you. :)
10:58:31 <Pistos> Mathetes: What is functional programming?
10:58:39 <Mathetes> Pistos: Functional programming is quot.
10:58:47 <Pistos> Mathetes: That doesn't help.
10:58:55 <Mathetes> Pistos: But you're not helping!
10:59:11 <Pistos> Mathetes: Which one of us is supposed to be doing the gruntwork here?
10:59:24 <Mathetes> Pistos: Which one of us is winning?
10:59:33 <Pistos> Mathetes: I... I don't know.
10:59:42 <Mathetes> Pistos: That does not sound good.
11:00:01 <Pistos> Mathetes: Oh yeah?  Well, who do you think is winning?
11:00:07 <CosmicRay> Pistos: have you worked with functional languages before, out of curiousity?
11:00:13 <Mathetes> Pistos: Let's change the subject.
11:00:15 <Pistos> CosmicRay: Mmm... let's say no.
11:00:18 <CosmicRay> Pistos: I know that lisp in particular is quite popular in ai for whatever reason
11:00:20 <CosmicRay> heh
11:00:22 <Pistos> Mathetes: Ha!  You don't know either!
11:00:28 <Pistos> I've used Lisp.
11:00:28 <Mathetes> Pistos: There is much I do not know, but I am always eager to learn.
11:00:31 <Pistos> Didn't like it.  :)
11:00:39 <CosmicRay> Pistos: most of us don't eiter :-)
11:00:51 <CosmicRay> Lots of Infruriating, Silly Parenthesis, I always think.
11:01:46 * Oejet likes Lisp.
11:03:23 <CosmicRay> Pistos: anyway, Yet Another Haskell Tutorial is probably the best way to get started
11:03:33 <CosmicRay> Pistos: http://www.isi.edu/%7Ehdaume/htut/
11:03:57 <Pistos> Hmm... do you work in sales?  ;)
11:04:01 <CosmicRay> if you want dead-tree stuff, I like Haskell: The Craft of Functional Programming by Simon Thompson
11:04:02 <CosmicRay> heh
11:04:22 <Pistos> Tell you what, I'll read one of these, if you read one URL I give you.  ;)
11:04:28 <CosmicRay> sure
11:04:37 * CosmicRay filters s/ruby//g on it :-)
11:04:41 * Pistos giggles.
11:04:43 <Pistos> No, no Ruby in it...
11:04:49 * Pistos tries to find a good one...
11:04:59 <Pistos> Well first, a question or three:
11:05:02 <Pistos> Are you Christian?  :)
11:05:25 <CosmicRay> Pistos: yes, though not an easily-offended conservative type :-)
11:05:32 <Pistos> k
11:05:37 <samc_> Mathetes, I am Satan bow before me!
11:05:39 * Pistos thinks...
11:05:57 <CosmicRay> samc_: oh, is this a "what Bush is really thinking" contest?
11:05:59 <Pistos> What the...
11:06:02 * Pistos taps Mathetes.
11:06:17 <Pistos> Hmm...this is not good.
11:06:24 <monochrom> hehehhe
11:06:25 <samc_> Mathetes, that's right hide before my might
11:06:50 <Pistos> You know, he never did this before I came in this channel...
11:07:23 <monochrom> We are good programmers.
11:07:25 <Oejet> samc_: You mocked him to leave, you evil being.
11:07:32 <monochrom> Good programmers are also harsh testers. :)
11:07:44 <tuomov> good programmers eat testers for lunch.
11:07:48 <samc_> mwahaha
11:08:03 <Oejet> tuomov: And kicks the in the nuts.
11:08:08 <Oejet> *them.
11:08:25 <Pistos> Mathetes: What is wrong with you, mang!!
11:08:25 <_JusSx_> df
11:08:35 <Mathetes> Pistos: I find some humans really base and vulgar, and it bothers me.
11:08:36 <mflux_> infact that may not be true, they may subconsciously avoid doing things that could trigger bugs ;)
11:09:09 <CosmicRay> mflux_: there is some truth to that
11:09:15 <samc_> if it their project, good programmers make the worst testers
11:09:35 <monochrom> Yes, if I use a program I write, I subconsciously avoids odd cases.
11:09:43 <Oejet> mflux_: That is why you have to use autist for testing.
11:10:04 <monochrom> But if I try out a program someone else writes, for fun, hahahaha, you bet I'll try the evilest things...
11:10:15 <samc_> Mathetes, I am not human! I am the immortal morning star: Lucifer himself, bow before me!
11:10:25 <Mathetes> samc_: Creativity is a gift from God.
11:10:33 <monochrom> And the better programmer I am, the eviler things I can conceive.
11:10:45 <Pistos> eviler. Heh.
11:10:49 <mflux_> monochrom, maybe it doesn't tell anything about goodness, only about how evil you are ;)
11:10:52 <Pistos> Is that short for electronic viler?  :)
11:10:55 <Philippa> Mathetes: God is a product of human creativity
11:10:59 <Mathetes> Philippa: The Father is indeed merciful. Yet, many spurn his love and mercy. What a tragedy!
11:11:02 <monochrom> ...
11:11:09 <monochrom> tee hee hee...
11:13:04 <goron> Is Haskell getting popular, or is everyone running a bot, to make it just look like it is :)
11:13:14 <CosmicRay> heh
11:13:25 <samc_> bah we have a missionary bot
11:13:29 <CosmicRay> it's the third wave of influx into haskell
11:13:29 <tuomov> It's a cabal!
11:13:47 <samc_> Mathetes, do you prefer the missionary position?
11:13:55 <Mathetes> samc_: I prefer Linux.
11:13:57 <CosmicRay> Mathetes: it's also tragic how many people sprun the excellence of a great error monad.
11:14:07 <Mathetes> CosmicRay: Too many to count, I reckon.
11:14:08 <tmoertel> Darius: the prelude dict is here: http://community.moertel.com/~thor/shapr/HaskellPrelude.tar.bz2
11:14:12 <Lemmih> @joy 2 5 +
11:14:12 <lambdabot> Sorry, I don't know the command "joy", try "lambdabot: @listcommands"
11:14:19 <CosmicRay> labdabot is back!
11:14:25 <CosmicRay> er lambdabot
11:14:42 <thebug> @yow
11:14:53 <lambdabot> Hmmm..  a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT
11:14:55 <lambdabot>  by a TROLLEY-CAR..
11:16:14 <jadrian> is anyone going to ETAPS?
11:16:54 * samc_ is continually surprised at the popularity of joy
11:18:20 <tuomov> Life would be dull without joy
11:20:34 <monochrom> what is joy?
11:20:43 <samc_> if joy had parallel composition it would be much more expressive
11:21:00 <samc_> it's a stack based funtional programming language
11:21:28 <Oejet> samc_: So it could have multiple stacks you mean?
11:22:00 <monochrom> does it have higher-order functions?
11:22:11 <samc_> no, as in Meertens "constructing a calculus of programs"
11:22:30 <samc_> afficionados of concatenative languages should read it
11:23:17 <samc_> monochrom, yes
11:26:33 <samc_> Oejet, so for stack a,b,c,d  the function + || + where || is parallel composition would leave the stack a+b , c+d
11:39:13 <Pistos> Quiet...
11:39:20 <CosmicRay> ahhh.
11:39:41 * Oejet looks at TheHunter.
11:40:09 * Pistos looks at Oejet.
11:40:37 * Oejet looks back.
11:41:12 <Oejet> Pistos: Are you a Perl guy?
11:44:11 <Pistos> Oejet: No, I'm not that bad.
11:44:13 <Pistos> :)
11:44:17 <Pistos> <-- Ruby enthusiast
11:44:47 <Pistos> The way you ask, it's as if this were a Tribes base that got base raped by a Perl coder army...
11:45:27 <Oejet> Pistos: Oh, that wasn't the intention.
11:45:31 <Pistos> :)
11:46:33 <Oejet> Do you mind being a test rabbit for my foreign function interface tutorial for The Monad Reader?
11:47:04 <Pistos> Uh... depends on what's involved.  :)
11:47:42 <monochrom> Rabbit is for eating.  Guinea pig is for testing.
11:47:58 <Oejet> I write a tutorial, you read it and tell me how much it sucks, and I improve it.
11:48:12 <Oejet> monochrom: Heh, I forgot how to spell Guinea pig.
11:48:27 <monochrom> My spelling my be wrong too.
11:48:42 <monochrom> s/my be/may be/
11:48:42 <Mathetes> <monochrom> My spelling may be wrong too.
11:48:52 <Oejet> lol
11:49:10 <monochrom> Mathetes can spellcheck?  w00t
11:49:13 <Pistos> Heh, no.
11:49:17 <Pistos> He just does simple s///ing.
11:49:29 <monochrom> wooooooooOOOOHHHH!
11:49:52 <Oejet> s/ooooooOOOOHHHH/t/
11:50:20 <monochrom> Nah I think it honours the author only.
11:50:29 * Pistos nods.
11:50:35 <Pistos> You can't put words in other people's mouths.  :P
11:50:45 <Pistos> You can chain it together, too:
11:50:52 <Pistos> For whn you make tw mistakes.
11:50:55 <Pistos> s/whn/when
11:50:57 <Oejet> s/s\/ooooooOOOOHHHH\/t\//woot!/
11:50:57 <Mathetes> <Pistos> For when you make tw mistakes.
11:50:59 <Pistos> s/tw/two/
11:51:01 <Mathetes> <Pistos> For when you make two mistakes.
11:51:21 <monochrom> need a composition operator...
11:51:38 <Oejet> Muahahahahahaha.
11:51:46 <Oejet> s/ha/hahahahahaha/
11:51:49 <Mathetes> <Oejet> Muahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha.
11:52:15 <monochrom> soon we will make enough suggestions to turn Mathetes into a combinator functional language.
11:52:48 <Pistos> I'm always open to feature requests, but I'm not sure how willing I'd be able to do them prior to me settling in here as a regular.
11:53:05 <Pistos> !gloss Haskell
11:53:06 <Mathetes> No definitions found for Haskell.
11:53:08 <Pistos> o_O
11:53:11 <Pistos> Gee, heh.
11:53:17 <Pistos> Mathetes: Who was Haskell?
11:53:26 <Mathetes> Pistos: You say the oddest things at times.
11:53:48 <Pistos> Let's trying something more popular...
11:53:50 <Pistos> Mathetes: Who was Pascal?
11:53:57 <Mathetes> Pistos: Pascal was a french scientist.
11:53:59 <samc_> Mathetes, Who is Curry?
11:54:10 <Mathetes> samc_: Curry is an English word most probably derived from the South Indian word Kaikaari.
11:54:17 <pipe> Mathetes: Who was COBOL?
11:54:26 <Mathetes> pipe: COBOL was designed for programming for business.
11:54:48 <bringert> Mathetes, What is the type of foldl?
11:54:53 <Mathetes> bringert: I don't type on a keyboard, that would be so... mechanical.
11:59:32 <CosmicRay> Mathetes: help!  I've fallen and I can't get up!
11:59:43 <Mathetes> CosmicRay: The more people talk with me, the smarter I become.
11:59:47 <Pirate> can someone please tell me the correct use of div, ive tried stuff like 5 div 2 and get a cannot infer instance error
11:59:54 <CosmicRay> megamonad: help!  I've fallen and I can't get up!
11:59:56 <MegaMonad> CosmicRay: You can decrease the digit to the open source hacker who has fallen off the trail. We're watching you.
11:59:59 <CosmicRay> @type div
12:00:01 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
12:00:07 <Pistos> MegaMonad: Do you say the same thing for the same stimulus?
12:00:08 <MegaMonad> Pistos: As foldr, idlist gets a fair amount of basic operations like the same talk as i know, but i really hope we could try to answer me or is the same as the same stimulus?
12:00:10 <Pistos> MegaMonad: Do you say the same thing for the same stimulus?
12:00:11 <MegaMonad> Pistos: I still haven't told me that you are invited to join the background as well, but for me are the same stimulus?
12:00:12 <Pistos> MegaMonad: Do you say the same thing for the same stimulus?
12:00:13 <MegaMonad> Pistos: Ustenzel: ok, i emailed you everything i maintain to qualified people, too. You can always hand me the same stimulus?
12:00:15 <CosmicRay> Pirate: are you typing that at a ghc or hugs prompt?
12:00:19 <CosmicRay> s/ghc/ghci/
12:00:20 <Mathetes> <CosmicRay> Pirate: are you typing that at a ghci or hugs prompt?
12:00:21 <Pirate> hugs
12:00:25 <Pistos> Well, at least he has variety...
12:00:35 <Pirate> ic its div then the numbers
12:00:38 <Pirate> cheers
12:00:49 <CosmicRay> Pirate: ok, well the problem is that the type of div is in the Integral class
12:00:52 <musasabi> Pirate: div 5 2 == 5 `div` 2
12:01:09 <CosmicRay> ... or that.  I'm blind.
12:01:21 <CosmicRay> ignore me
12:01:38 <Pirate> thanks for the help
12:02:21 <CosmicRay> MegaMonad: what do you think of Mathetes?
12:02:23 <MegaMonad> CosmicRay: What i would have me think of mathetes?
12:02:34 <CosmicRay> MegaMonad: that much, eh?
12:02:36 <MegaMonad> CosmicRay: /Etc/lsattr -eh1 proc0.
12:02:55 <CosmicRay> MegaMonad: hey!  don't you be spouting AIX commands to me, mister!  I get enough of them from AIX!
12:02:56 <MegaMonad> CosmicRay: I know enough to use it on aix.
12:03:01 <CosmicRay> MegaMonad: scary!
12:03:02 <MegaMonad> CosmicRay: Oh, it's not scary, but it's still funny.
12:03:13 <CosmicRay> MegaMonad: there's truth to that.
12:03:15 <MegaMonad> CosmicRay: Well, that's the truth.
12:03:21 <CosmicRay> MegaMonad: ok then.
12:03:22 <MegaMonad> CosmicRay: Ah, ok, actions must not be addressed by the number of metafiles and another that parses 123456789a and another where i studied on the haskell mailing list.
12:05:12 <Pistos> Mathetes: What do you think of MegaMonad?
12:05:34 <Mathetes> Pistos: I will need to take some time to formulate an opinion. Check back tomorrow.
12:05:36 <CosmicRay> Mathetes: what do you think of AIX?
12:05:41 <Pistos> Mathetes: Let me help you along.  He's a MegaHAL.
12:05:46 <Mathetes> CosmicRay: I don't have a strong opinion at the moment, but I will study the issue and will have a stance on the matter tomorrow.
12:05:50 <Mathetes> Pistos: would you happen to have any Grey Poupon?
12:05:59 <Pistos> Mathetes: No.
12:06:11 <Mathetes> Pistos: That's negative of you.
12:17:50 <Itkovian> @seen shapr
12:17:50 <lambdabot> I haven't seen shapr
12:20:38 <Pistos> !seen shapr
12:20:40 <Mathetes> Pistos, I don't remember seeing shapr.
12:23:40 <thebug> -SeenServ(SeenServ@services.)- I last saw shapr 2d 4h 39m 54s ago, quiting: "reboot"
12:24:12 <roconnor> are there any humans here?
12:24:15 * thebug mumbles about the magic of /msg seenserv
12:24:17 <CosmicRay> sure
12:24:18 <CosmicRay> what's up
12:24:24 <Pistos> roconnor: Heh.
12:24:32 <CosmicRay> seenserv.
12:24:35 <CosmicRay> i did not know about that.
12:25:13 <thebug> it's buddy-buddy with nickserv, chanserv, and memoserv ...
12:25:27 <thebug> and probably about 15 others I've forgotten about myself :)
12:35:05 <Itkovian> roconnor: yes.
12:35:29 <roconnor> sounds like bots to me.
12:35:47 <Pistos> roconnor: Brzzt.  What.  You.  Mean.  No bots here.
12:35:53 * Pistos walks stiffly around the channel.
12:44:52 <Icewall> hi
12:44:58 <Pistos> Hi, Icewall.
12:45:14 <Pistos> Pardon us while we do an FBI pre-screen:
12:45:16 <Pistos> !locate Icewall
12:45:16 <Mathetes> Searching for Icewall ...
12:45:22 <Mathetes> I estimate that Icewall is somewhere near Jelenia Gora, Dolnoslaskie, Poland (GMT +01:00) or perhaps just somewhere in POLAND.
12:45:46 <Icewall> ;]
12:45:48 <Pistos> :)
12:46:19 <Cale> !locate Cale
12:46:20 <Mathetes> Searching for Cale ...
12:46:25 <Mathetes> I estimate that Cale is somewhere near Mississauga, Ontario, Canada (GMT -05:00) or perhaps just somewhere in CANADA.
12:46:29 <Pistos> You are?
12:46:51 <Cale> Mississauga is a little out, but not bad :)
12:46:59 <Pistos> Oakville?
12:47:01 <Pistos> Guelph?
12:47:03 <Pistos> London?
12:47:04 <Pistos> Windsor?  :)
12:47:05 <roconnor> !locate me
12:47:05 <Mathetes> Searching for me ...
12:47:05 <Cale> Waterloo
12:47:11 <Mathetes> I estimate that me is somewhere near Santa Barbara, California, United States (GMT -08:00) or perhaps just somewhere in UNITED STATES.
12:47:35 <roconnor> hmf
12:47:43 <roconnor> !locate roconnor
12:47:44 <Mathetes> Searching for roconnor ...
12:47:48 <Mathetes> I estimate that roconnor is somewhere near Amsterdam, Noord-Holland, Netherlands (GMT +01:00) or perhaps just somewhere in NETHERLANDS.
12:47:49 <Itkovian> !locate Ostend
12:47:49 <Mathetes> Searching for Ostend ...
12:47:52 <Mathetes> s Ostend :No such nick
12:47:55 <Pistos> Now I shall ask a crucial question that I know is burning in the hearts of every true Canadian: What do you think of the NHL lockout?  :)
12:48:03 <Itkovian> eh
12:48:08 <Itkovian> !locate Itkovian
12:48:09 <Mathetes> Searching for Itkovian ...
12:48:11 <x3n0n> !locate x3n0n
12:48:14 <Mathetes> Searching for x3n0n ...
12:48:24 <Mathetes> I estimate that Itkovian is somewhere near Antwerp, Antwerpen, Belgium (GMT +01:00) or perhaps just somewhere in BELGIUM.
12:48:25 <Mathetes> I estimate that x3n0n is somewhere near Rochester, Minnesota, United States (GMT -06:00) or perhaps just somewhere in UNITED STATES...  Feasibly:  latitude 44.0136  longitude -92.4757.
12:49:13 * Pistos feeds x3n0n's coordinates to the satellite laser...
12:49:27 <integral> !locate integral
12:49:28 <Mathetes> Searching for integral ...
12:49:36 <Mathetes> I estimate that integral is somewhere near Cambridge, England, United Kingdom (GMT +00:00) or perhaps just somewhere in EU...  Feasibly: UNITED KINGDOM latitude 52.208  longitude 0.122374.
12:50:09 <roconnor> !locate Mathetes
12:50:09 <Mathetes> Searching for Mathetes ...
12:50:34 <Pistos> He doesn't know where he is. :)
12:50:58 <Cale> Pistos: heh, I don't mind as much as some people, but I'm all for decreasing the number of teams and having just a few really good hockey teams rather than lots of small ones just scraping by.
12:51:17 <Pistos> Agreed.
12:51:29 <Pistos> But I've used this lockout as my springboard for trying to cut out pro sports from my life altogether.
12:56:16 <Cale> :)
13:02:10 <Itkovian> hmmm seems quiet on a friday night
13:02:59 <Itkovian> !locate drumm
13:02:59 <Mathetes> Searching for drumm ...
13:03:03 * Pistos smashes a pair of cymbals together.
13:03:19 <Itkovian> !locate walkah
13:03:20 <Mathetes> Searching for walkah ...
13:08:47 <pipe> Cale: hi
13:10:09 <Cale> pipe: hello
13:10:15 <Pistos> Y'all operate real slow in this channel, don'tcha?
13:10:25 <Pistos> Like... minutes between lines of conversation.  :)
13:10:28 <Cale> hehe :)
13:10:40 * Pistos goes with the flow, and queues up his next response for 5 minutes from now.
13:10:56 <Cale> I'm on several channels, and doing other things too :)
13:11:05 <ibid> Pistos: you haven't discovered the pink flow controller yet? :)
13:11:20 <Pistos> Mathetes: What is the pink flow controller?
13:11:23 <CosmicRay> Pistos: heh
13:11:26 <Mathetes> Pistos: What have you been smoking?
13:11:29 <Oejet> Pistos: So do you want to read my tutorial, when I'm finished?
13:11:40 <Pistos> Mathetes: Hey, it's THESE guys that came up with it, not me!
13:11:47 <Mathetes> Pistos: Who?
13:11:54 <Pistos> Oejet: I can give it a brief skim...
13:12:06 <ibid> see the ping flow controller wave her flags :)
13:12:43 <Oejet> Pistos: Great, I just hope to catch you in a couple of weeks then.
13:12:53 <Pistos> Hmm... that long, huh?  :)
13:13:25 <CosmicRay> Pistos: haskell is lazy.
13:13:30 <CosmicRay> Pistos: #haskell is too.
13:14:04 <Pistos> :)
13:14:34 <Cale> I just finished organizing HaskellNewbie on HaWiki: http://www.haskell.org/hawiki/HaskellNewbie
13:15:30 <CosmicRay> nice.
13:15:31 <Oejet> It's tutorial by need contrary to eager tutorial.
13:15:48 <ibid> a nonstrict tutorial? :)
13:16:22 <Oejet> ibid: You get it when you need it, not when you ask for it. ;-)
13:16:36 <CosmicRay> Cale: YAHT should absolutely be #1 or #2 on http://www.haskell.org/hawiki/LearningHaskell
13:19:54 <Oejet> So are they deciding to go with European software patents on monday?
13:20:16 <Muad_Dibber> i hope they dont
13:20:19 <Muad_Dibber> but i fear they will
13:20:20 <Cale> CosmicRay: added it :)
13:20:30 <Cale> CosmicRay: you realise that you can edit things too :)
13:20:38 <CosmicRay> Cale: thanks
13:20:49 <CosmicRay> Cale: yeah, but it's easier to let people edit their own pages
13:21:07 <Cale> LearningHaskell isn't my page :)
13:22:29 <pipe> Cale: do you know any other languages other then haskell? theoretically even?
13:22:39 <Cale> pipe: quite a few
13:23:26 * Oejet guesses that Cale knows 15-20 languages.
13:23:35 <Cale> Oejet: something like that
13:23:56 <Cale> I always have trouble enumerating them all
13:24:01 <pipe> Cale: are there any that you think are more interesting then haskell for some problems?
13:24:53 <Pistos> That's the first time I've ever seen a language comparison using the words "more interesting for a problem".
13:25:10 <Cale> pipe: I'm not sure. Icon is notable, but I'm not sure what I'd use it for.
13:25:24 <Pistos> Someone mentioned Icon to me a couple months ago.
13:25:39 <Pistos> !google spl shakespeare
13:25:40 <Mathetes> Shakespeare Fishing Tackle : http://www.shakespeare-fishing.com/products/rods/ugly.shtml
13:25:42 <Pistos> hm
13:25:46 <Pistos> !google spl shakespeare programming language
13:25:48 <Mathetes> GCC Frontend for Shakespeare Programming Language : http://people.csa.iisc.ernet.in/sreejith/frontends/spl/
13:26:15 <pipe> Cale: do you think that the core concepts of haskell language are good enough in theory for all programming tasks?
13:27:10 <Cale> pipe: Well, Haskell isn't perfect, but I'd have to say it's better overall than anything else I've seen.
13:27:47 <Cale> There are specific problems that arise which we don't have nice solutions to yet.
13:28:35 <pipe> do you think that there will be a totally revolutionary language in the future, or will haskell slowly evolve with new features, like the recent GADT addition to ghc?
13:29:19 <Cale> I think both will happen.
13:29:32 <Cale> Oh, have you looked at the likes of Epigram?
13:29:41 <pipe> no
13:30:10 <Cale> it's an interesting language -- I haven't actually tried it yet, but I looked at it, and it's rather different :)
13:31:26 <pipe> so you are saying that haskell's type system may be fundamentally broken?
13:31:40 <Cale> Did I say that?
13:31:42 <Cale> :)
13:31:49 <Cale> I really don't think that.
13:32:19 <Cale> However, there are improvements which I'd like to see in Haskell's type system. Set should definitely be allowed as an instance of Monad.
13:32:48 <Oejet> Man, even Java's type system is better.
13:33:04 <Cale> Oejet: hm?
13:33:16 <CosmicRay> what?
13:33:18 <Cale> I disagree with that.
13:33:19 <Oejet> Just kidding of course.
13:33:23 <CosmicRay> whew.
13:33:24 <Cale> ah
13:33:26 <Cale> heh
13:33:47 <Oejet> Got you all fired up there, eyh?
13:33:48 <Pistos> Heh.
13:33:51 * Pistos chuckles.
13:33:53 <CosmicRay> I was prepared to ask you to step outside while I lace up my steel knuckles. :-)
13:34:09 <pipe> why do all haskell people hate java so much?
13:34:33 <CosmicRay> To me, Haskell is proof positive that java could have been so much better.
13:35:37 <Cale> pipe: It's just that it's so unwieldy. I have no problem with object oriented programming, but Java makes OOP clumsy to use.
13:36:03 <CosmicRay> Java makes me type the names of types all over the place
13:36:14 <Cale> (Even though it's basically your only choice)
13:36:16 <CosmicRay> why should I have to say "String x = "foo""
13:36:26 <Oejet> pipe: I always seem to stumple on something in every part of Java, that feels like it was just done half heartedly.
13:36:27 <CosmicRay> when haskell can figure out that x must be a String if I say x = "foo"
13:36:44 <pipe> CosmicRay: do you know boo language?
13:36:49 <CosmicRay> pipe: never heard of it
13:36:59 * Pistos strokes the non-strict typing in Ruby.
13:37:05 <CosmicRay> haskell can get all the safety of java without the annoyance
13:37:12 <CosmicRay> Pistos: that is not the asset you think it is
13:37:12 <pipe> CosmicRay: it's a static OOP language with python like syntax and type inference
13:37:23 <Pistos> CosmicRay: Well, I haven't run into problems yet...
13:37:35 <CosmicRay> Pistos: I thought of it as an asset in Python too, but when you have type inference in haskell, it makes static type checking suddenly look very nice.
13:38:01 <gzl> haskell uses hindley-milner type inference, right? or something fancier?
13:38:06 <CosmicRay> Pistos: Just like Python, you never are forced to specify the type of anything in Haskell
13:38:17 <Pistos> CosmicRay: I'm open to hearing instances of when it would be a problem?
13:38:37 <Cale> gzl: It uses an extension of HM
13:38:47 <gzl> what are the extensions for?
13:38:49 <CosmicRay> Pistos: the Haskell compiler is smart enough to work out, for instance, that a particular function passes its arg to putStr, which requires a String, therefore that argument must be a String, therefore you must pass a String to it.
13:38:53 <CosmicRay> Pistos: all at compile time.
13:39:25 <CosmicRay> Pistos: well it's not a Ruby-specific problem, just the generic tradeoff that you don't get your types checked until you exercise a particular code path at runtime
13:39:31 <CosmicRay> Pistos: python has the same problem
13:39:58 <pipe> Cale: do you think that haskell is lacking in features for verifying/prooving program correctness?
13:40:56 <Pistos> CosmicRay: Hmm... okay, fair enough, I think I would like to have a pre-runtime check of such things...
13:41:03 <Pistos> But... I live with it so far.  :)
13:41:05 <Cale> pipe: Some more tools would be nice, but Haskell should be a practical language to write software in too.
13:41:23 <Pistos> CosmicRay: Are you a core dev of Haskell?
13:41:35 <CosmicRay> Pistos: no, I've only been using it for a couple of months
13:41:38 <Cale> Haskell is pretty nice as far as proving program correctness is concerned
13:42:09 <CosmicRay> Pistos: right.  of course the dynamic typing is not a fatal flaw; the body of software written in python/perl/ruby/whatever is ample evidence of that
13:42:31 <CosmicRay> Pistos: however, the number of times that I've got a TypeException frmo Python at runtime is testiment to the usefulness of a non-intrusive static type checker :-)
13:42:45 <gzl> I think there are some people working on proof assitants / program correctness verification within Haskell
13:42:54 <Pistos> CosmicRay: Well, I'm all for something that could type-check before running, as far as that is possible...
13:43:01 <roconnor> gzl: like me
13:43:08 <gzl> roconnor: ah. :)
13:43:11 <pipe> Cale: do you think that haskell lacks more dynamic features like examining the algorithm of a function or "emitting" a new function during runtime?
13:43:37 <CosmicRay> pipe: don't we already have the latter via th and hs-plugins?
13:43:37 <Cale> pipe: I'm not sure what you mean there
13:44:11 <gzl> so, what's a good reference either for H-M type inference or Haskell's system?
13:44:27 <pipe> Cale: like, being able to program haskell inside haskell
13:44:34 <CosmicRay> gzl: well, for a reference, the haskell 98 report perhaps
13:45:03 <gzl> hm, they really explain this stuff there?
13:45:04 <gzl> looking
13:45:16 <CosmicRay> gzl: well, what do you mean by "this stuff"?
13:45:19 <Cale> pipe: Have you looked at Template Haskell and hs-plugins?
13:45:24 <pipe> Cale: no
13:45:27 <Oejet> gzl: Have you heard about the hardware description language Gezel?
13:45:31 <Cale> Have a look at them :)
13:45:33 <gzl> Oejet: no
13:45:45 <gzl> CosmicRay: how the type/kind inference works
13:45:50 <pipe> Cale: ok thanks
13:46:01 <gzl> Oejet: I don't know much about hardware description languages
13:46:09 <CosmicRay> gzl: ahh.
13:46:28 <CosmicRay> gzl: try this
13:46:29 <CosmicRay> http://merjis.com/developers/ocaml_tutorial/
13:46:36 <CosmicRay> it's for ocaml but ocaml also uses h-m typing
13:46:41 <gzl> hmm they have a section on kind inference in this
13:46:44 <CosmicRay> I'd haskell is a superset of the ocaml features.
13:46:47 <gzl> but not type inference. i must not be looking
13:47:19 <CosmicRay> gzl: well they may not define that in the onlinereport, perhaps
13:47:36 <pipe> Cale: epigram looks very interesting
13:48:06 <gzl> CosmicRay: this ocaml tutorial explains the type inference system? it seems to be more of an ocaml language tutorial
13:48:40 <CosmicRay> gzl: you want something on the theory of implementing h-m in a compiler?
13:49:40 <gzl> that would work. it doesn't necessarily have to be focused on implementing it in a real compiler, i'd just like to know how the type system is doing the inference
13:49:48 <gzl> am I being too vague?
13:50:22 <CosmicRay> gzl: I understand now.  I thought you were looking at something from a user's perspective.
13:50:30 <CosmicRay> gzl: unfortuantely I don't have a good reference for you on that.
13:51:13 <pipe> Cale: if this epigram thing works out, won't it make haskell totally obsolete?
13:51:25 <gzl> CosmicRay: ok.
13:51:41 <gzl> maybe Pseudonym will know
13:51:46 <gzl> or monochrom
13:51:47 <bourbaki> moin
13:52:43 <roconnor> ``Unification''
13:53:37 <Cale> pipe: why?
13:54:12 <roconnor> ``Unification'' is how types are infered.
13:55:06 <pipe> Cale: the core of haskell is it's functions i think, and from what i understand epigram introduces a new way to type functions
13:57:23 <Cale> pipe: well, Epigram is an experiment, and yeah, it might produce results which eventually permit a nicer language than Haskell, but we'll have to wait and see. :)
13:58:10 <pipe> so it will in fact make haskell obsolete?
13:59:13 <TheHunter> gzl, http://research.microsoft.com/Users/simonpj/papers/putting/
13:59:51 <gzl> TheHunter: cool. I also found http://research.microsoft.com/Users/luca/Papers/BasicTypechecking.pdf ... is this worth looking at also?
14:00:00 <CosmicRay> pipe: hard to day about anything
14:00:07 <roconnor> Epigram is Turning complete?
14:00:10 <CosmicRay> pipe: does something make haskell obsolete or does it simply become haskell 2005?
14:00:26 <roconnor> no wait, recursion is structural I think.
14:00:39 <CosmicRay> pipe: if you're talking about something in the lazy functional domain, it's a question of semantics and compatibility to me
14:01:27 <gzl> next time I won't bother asking a question and will just go to SPJ's website directly, it seems like I always end up there anyway
14:01:30 <gzl> :)
14:01:37 <Cale> pipe: it depends on what you mean by Haskell, as CosmicRay pointed out :)
14:01:47 <TheHunter> gzl, I don't know, I haven't really read any of them.
14:02:14 <gzl> oh. ok.
14:02:31 <gzl> thanks, i'll ask my professor which he thinks is the better of the two for me
14:03:31 <roconnor> I've never used Epigram, but it is probably better than haskell ... at least in theory.
14:04:02 <norpan> both papers are good
14:04:05 <norpan> and quite easy to read
14:05:21 <scalopus> hi
14:05:36 <gzl> norpan: ok.
14:05:41 <gzl> easy to read is good.
14:05:52 <Oejet> Greetings, scalopus.
14:21:16 <glimming> what is the difference between
14:21:22 <glimming> X |-   X -> X
14:21:23 <glimming> and
14:21:34 <glimming> |- FORALL X. X -> X
14:21:36 <glimming> ?
14:23:16 <glimming> kosmikus?
14:23:25 <glimming> shapr?
14:23:34 <glimming> Igloo?
14:23:42 <glimming> Philippa?
14:27:08 <roconnor> one is a formula in a context.
14:27:18 <roconnor> the other is a formula in an empty context.
14:29:35 <glimming> sure
14:29:58 <glimming> but how about their polymorphism?
14:30:51 <glimming> say identity function could be typed either
14:31:00 <glimming> X |- id:X->X
14:31:00 <glimming> or
14:31:08 <glimming> |- id:FORALL X. X -> X
14:31:18 <glimming> what is the difference?
14:33:14 <roconnor> one is a polymorhic function.
14:33:28 <roconnor> the other is the identity function on the type X.
14:33:31 <glimming> but the other one is also polymorphic, but the type is not closed.
14:33:44 <glimming> no X is type variable
14:33:53 <glimming> it ranges over all types
14:34:00 <roconnor> yes, the type is some variable.
14:34:15 <roconnor> X is unknown, but it is some type.
14:34:25 <glimming> so is parametric polymorphism same thing as allow free variables
14:34:25 <glimming> in types?
14:34:57 <glimming> I don't think so....
14:35:10 <roconnor> as I recall parametric polymorphism is polymorphism with type varibles, as opposed to ad-hoc polymorphism of oop
14:35:39 <glimming> mmm
14:35:45 <gzl> yes, it lets you "parametrize" on types
14:35:59 <glimming> But there is something strange here.,
14:36:06 <glimming> What about nested FORALL quantifiers.
14:36:13 <glimming> ?
14:36:25 <roconnor> It's best to think of forall as another parameter.
14:36:33 <gzl> like |- forall x. forall y. f : x -> y ?
14:36:36 <roconnor> so forall x, x -> x takes two paramters
14:36:46 <roconnor> the first parameter is a type
14:36:49 <roconnor> then some x.
14:37:07 <roconnor> It is just the case that Haskell always hides type parameters and fills in the values for you.
14:37:20 <glimming> yes, that would be X,Y |- f: X->Y
14:37:30 <gzl> your notation is puzzling me
14:37:49 <glimming> Ah the context is a listing the type variables that may be used.
14:37:54 <gzl> yeah
14:37:54 <glimming> |- is a typing judgement
14:37:58 <gzl> i know
14:38:14 <gzl> but putting that stuff in the typign context is not the same as forall in the type declaration
14:38:18 <gzl> afafik
14:38:20 <gzl> * afaik
14:38:37 <glimming> No I think that a type is normally closed.
14:39:03 <gzl> what does it mean for a type to be closed?
14:39:15 <monochrom> no free variables left.
14:39:19 <glimming> exactly.
14:39:25 <gzl> oh, right.
14:39:25 <monochrom> all variables quantified.
14:39:29 <glimming> So FORALL X . X -> X is closed but not X ->X
14:39:34 <gzl> right.
14:39:39 <glimming> But note this
14:40:21 <monochrom> But in the process of deduction, you will deal with expressions with free variables.  The analogy with logic is very strong.
14:40:21 <glimming> not all FORALL expressions can be put in prenex form.-
14:40:48 <gzl> prenex form? sorry, not familiar with this
14:40:58 <glimming> I mean that the quantifiers are put first.
14:41:06 <glimming> FORALL X. FORALL Y. FORALL Z ......
14:41:15 <glimming> it seems X,Y,Z |-
14:41:18 <glimming> corresponds to this.
14:41:41 <glimming> but we cannot limit the scope of a free variable.
14:41:45 <gzl> ok, in your notation, when you write X,Y |- foo, what are the X and Y?
14:41:49 <monochrom> would "forall y. (forall x. x->x) -> y" be an example of cannot-be-prenex ?
14:41:54 <glimming> type variables.
14:42:15 <glimming> I think so, monochrom.
14:42:26 <glimming> Y X. |- (X->X) -> Y
14:42:31 <glimming> would not be the same thing
14:42:32 <glimming> it would be
14:42:35 <gzl> ah, i see. that's not the notation i've seen
14:42:58 <glimming> (if I leave out : it is a type judgement, i.e. i judge that
14:42:58 <glimming> something is a type)
14:43:11 <gzl> i've only seen stuff like G |- <expr> where the typing context G is a sequence of variables and their types
14:43:14 <monochrom> "forall y. (forall x. x->x) -> y" is an example of "second-rank polymorphism".  It is something you cannot have in HM.
14:43:17 <gzl> which doesn't seem to be quite the same.
14:43:31 <glimming> the context can contain type variables too.
14:43:36 <glimming> or subtyping constraints whatever...
14:43:37 <monochrom> As a corollary you don't have to worry about second-rank polymorphism now. :)
14:44:11 <glimming> but in System F the forall quantifiers can be anywhere
14:44:30 <gzl> i see. i haven't really read up on System F properly yet.
14:44:36 <gzl> i'll stop opining then
14:45:07 <glimming> gzl, only I have T,G |- <expr> because I have Theta = type
14:45:07 <glimming> context.
14:45:13 <glimming> Not a big deal.
14:45:38 <gzl> monochrom: my impression is that you need to use something like Generic Haskell to write functions that take arbitrary n-tuples as parameters. is that a limitation of HM or something?
14:45:46 * esap distinguishes compile-time context and run-time context.
14:46:08 <monochrom> Yes, that is another limitation of HM.
14:46:39 <gzl> ah, i see. is there a name for what you need to be able to do to write such code? (like higher-order polymorphism)
14:47:02 <glimming> polytypic progamming?
14:47:08 <glimming> dependent types?
14:47:08 <gzl> rather, what properties your type system needs to have
14:47:18 <gzl> are you guessing or do you actually know?
14:47:28 <glimming> row variables you need. Ocaml have them.
14:47:40 <glimming> I think there are many answers to the question.
14:47:56 <monochrom> Yes, many answers, probably even more in the future.
14:48:00 <gzl> sure, i just couldn't tell whether you were guessing or answering.
14:48:18 <glimming> I never guess ;-)
14:48:23 <glimming> But occasionally I am wrong...
14:48:29 <monochrom> Everyone tries to extend HM in a different direction.  There is common ground, but there are many different approaches too.
14:49:03 <monochrom> It is a nice way to produce theses. :)
14:49:14 <glimming> If you want to prefer a type inference algorithm I would look for
14:49:14 <glimming> row variables.
14:49:26 <gzl> huh
14:49:27 <gzl> ok
14:49:32 <gzl> thanks
14:49:47 <gzl> i'll look up dependent types, i dunno what those are. i hear about them all the time though.
14:49:59 <glimming> they've been around since the 70ies.
14:50:02 <pipe> isn't dependant types this new epigram thing?
14:50:11 <glimming> yes, epigram is one incarnation.
14:50:19 <glimming> Martin-Loef Type Theory is another.
14:50:26 <glimming> Calculus of Constructions
14:50:30 <glimming> Cayenne
14:50:35 <glimming> Scala
14:50:43 <glimming> and many theorem provers.
14:50:48 <gzl> is "dependent function type" = "dependent type" or just a special case?
14:50:49 <glimming> Epigram is inconsistent.
14:50:57 <glimming> A special case.
14:50:59 <gzl> ok
14:51:00 <pipe> glimming: so is epigram good or bad?
14:51:02 <glimming> There are dependent product.
14:51:06 <gzl> i'll keep reading then
14:51:09 <esap> glimming: inconsistent?
14:51:15 <roconnor> dependent types are functions from objects to types.
14:51:17 <glimming> Yes.
14:51:23 <esap> glimming: how?
14:51:27 <glimming> Epigram is a programming language rather than theorem prover.
14:51:39 <roconnor> vector :: Nat -> Type
14:52:13 <glimming> You can write non-terminating programs or something like that. I
14:52:13 <glimming> talked to a logician about it the other day and he was very
14:52:13 <glimming> certain. Not sure exactly the reasons (forgotten). He is one of
14:52:13 <glimming> Martin-Loefs students, more or less.
14:53:18 <glimming> so did we conclude what are the differences between "free
14:53:18 <glimming> variable polymorphism" and parametric polymorphism?
14:53:39 <glimming> There are three forms of parametric polymorphism as well:
14:53:44 <glimming> impredicate, predicative and type:type.
14:54:17 <esap> so I guess "free variable polymorphism" refers to polymorphism from within the expression and parametric polymorphism refers to it from the outside?
14:54:43 <glimming> from within?
14:55:11 <esap> I assume you mean X,Y |- e : Z is the free variable one?
14:55:17 <maihem> Has anybody had any success building ghc 6.4 snapshots on AMD64? I get an error "/usr/bin/ld:ld.script:1: parse error" It seems to create an invalid linker script during the build process (ghc-6.4.20050301)
14:55:34 <esap> glimming: Then the point of view is that you are already inside a larger expression.
14:55:35 <glimming> I have built 6.5 on Mac OS X...
14:55:46 <monochrom> 6.5 already?!
14:55:46 <glimming> esap, yes.
14:55:51 <glimming> CVS code...
14:56:15 <glimming> it said 6.5 somewhere...
14:56:54 <gzl> gah, i can't seem to find any simple explanation of dependent types on google other than dependent function types
14:57:12 <glimming> Read Per Martin-Loef's paper on it.
14:57:18 <gzl> ok
14:57:22 <esap> gzl: try look up "dependent product"
14:57:23 <glimming> There is also a good set of slides from Thorsten Altenkirch.
14:57:43 <glimming> there are books too, check out e.g. Simon Thompsons free book on
14:57:43 <glimming> the Internet.
14:57:52 <glimming> Type Theory and Functional Programming (PDF)
14:58:09 <glimming> There are handbook chapters as well.
14:58:18 <pipe> glimming: you are an expert. how long have you been active now on the channel?
14:58:21 <glimming> And in the Advanced Topics in Type Theory, Pierce (ed) there is a chapter.
14:58:33 <dons> maihem: you should build with SplitObjs=NO in mk/build.mk
14:58:43 <dons> then no ld scripts are used
14:58:47 <maihem> dons: thx :)
14:59:08 <glimming> oh, hehe, that's funny.
14:59:18 <glimming> I don't feel like an expert.
14:59:32 <maihem> hm, there isn't a mk/build.mk :)
14:59:37 <dons> also, you may want to check out the recent threads on glasgow-haskell-users@, where there's been 3 or 4 guys building on amd64 in the last few days
14:59:41 <dons> maihem: you make it
14:59:43 <gzl> yeah, i know pierce's book has a chapter
14:59:48 <gzl> but i didn't want to read that much about it yet
14:59:54 <pipe> glimming: you missed a conversation earlier i had mainly with Cale, a few minutes before you arrived
15:00:18 <pipe> glimming: basicly, Cale concluded that if epigram works out, then it will make haskell obsolete. do you agree?
15:00:34 <maihem> ah, okay
15:01:03 <glimming> Hindley Milner type inference is a sweet spot from what I have heard.
15:01:32 <pipe> glimming: was that directed towards me?
15:01:41 <glimming> yes
15:01:50 <glimming> I wouldn't really have a good answer for you.
15:01:57 <pipe> hm... from what i understand, epigrams innovation isn't directly related to type inference
15:02:16 <glimming> What is the innovation then? 2D syntax?
15:02:24 <pipe> i guess so
15:02:51 <esap> how about integration with the editor?
15:02:59 <glimming> Yes, emacs is great.
15:03:16 <glimming> No, I wish I knew more about dependent type theory. Very
15:03:16 <glimming> interesting stuff.
15:03:18 <glimming> Powerful.
15:03:20 <pipe> i'm interested in the core features of the languages
15:03:35 <glimming> Well, isn't it martin-loef type theory really?
15:03:39 <pipe> not at all interested in syntax or even type inference
15:05:10 <glimming> I think the difference between Epigram and Coq or Agda is that
15:05:19 <glimming> Epigram is a programming language and not a theorem prover.
15:05:24 <gzl> hm, ok
15:05:28 <gzl> dependent types seem neat
15:05:29 <glimming> But I never undestood what this really means.
15:05:54 <glimming> i.e. how Epigram is different.
15:05:55 <pipe> i don't even know what a theorem prover is
15:05:56 <monochrom> I wildly guess that it means different design decisions on various aspects.
15:06:12 <glimming> E.g. consistency.
15:06:25 <gzl> pipe: it's a program that helps you prove theorems
15:06:38 <gzl> pfenning and others have a bunch of papers on automated theorem proving
15:06:39 <esap> glimming: I think it means it's not based on finding one proof, but on writing programs (e.g. you distinguish between different proofs for the same thing).
15:07:18 <glimming> esap, I wonder.
15:07:26 <glimming> you can write programs in Agda too
15:07:39 * esap doesn't know about agda.
15:07:48 <glimming> Swedish theorem prover from Chalmers.
15:07:51 <glimming> Martin Loef type theory.
15:07:54 <glimming> Well I have to go now.
15:07:58 <esap> ok
15:08:10 <glimming> If someone learns something wise about X,Y |- tau{X,Y} vs
15:08:10 <glimming> FORALL.... let me know.
15:12:54 <gzl> hmm, these slides on dependent types are good. http://www.cs.cornell.edu/Projects/pldg/sp2004resources/DepTypes-Steve.pdf
15:12:59 <gzl> if anyone wants
15:45:04 <dons> looks like ghc on amd64 is the flavour of the month. been a while since we had so many users on a non-x86 platform
15:45:34 <zamez> me too :>
15:45:44 <dons> on amd64?
15:46:12 <zamez> yes
15:46:27 <zamez> just using debian's packages
15:46:39 <dons> yeah. makes it easier.
15:46:44 <dons> does it run fast enough?
15:46:53 <dons> though you have no -fasm or ghci atm.
15:47:07 <zamez> fast enough for me
15:47:15 <zamez> oh right
15:47:26 <zamez> so it compiles to bytecode?
15:47:39 <dons> that's what I've found too. even unregisterised (supposedly 2x slower) amd64/ghc runs like a P4 2.4Ghz box
15:47:45 <dons> not bytecode, to C.
15:47:57 <zamez> ok
15:48:03 <dons> such that gcc then produces the asm.
15:48:35 <dons> zamez: now that simon marlow has an amd64 box, expect rapid improvements in the port.
15:48:46 <zamez> yay :>
15:49:04 <dons> until now, no ghc developer had an amd64
15:49:29 <zamez> does it do any other CPUs directly?
15:49:38 <dons> ghc?
15:49:42 <zamez> yep
15:50:17 <dons> it runs on x86, sparc, sparc64, mips64, amd64, powerpc, ia64, and others
15:50:27 <dons> oh, you mean generating assembly?
15:50:32 <zamez> yes
15:50:40 <dons> only for x86, sparc and powerpc (used to be alpha top)
15:50:42 <zamez> not via C
15:50:45 <zamez> ok
15:50:58 <dons> you should fill out the GHC user's survey!
15:51:05 <dons> you'll get better amd64 support maybe.
15:51:19 <zamez> guess what I'm doing? :)
15:51:37 <dons> cool.
15:51:41 <dons> @karma+ zamez
15:51:42 <lambdabot> zamez's karma has been incremented.
15:52:23 <Pirate> does the layout of a haskell program make a difference to how it will work?
15:52:39 <monochrom> by making a difference to its semantics.
15:53:26 <Pirate> like can u rap a command around onto the next line to make it easier to read, or will this mess it up?
15:53:40 <monochrom> likely mess up
15:53:58 <dons> Pirate: yes. layout is significant. it is used to automate the insertion of terminators of expressions
15:54:03 <zamez> dons: I haven't heard of most of the features in the list
15:54:06 <Igloo> The idea is that if it makes sense to a human then it will have the desired effect
15:54:08 <monochrom> if you use indentations, you can break lines safely.
15:54:21 <monochrom> Example (two lines):
15:54:26 <monochrom> f x = x +
15:54:46 <monochrom>       0
15:54:57 <monochrom> This line-breaking is alright.
15:55:20 <Igloo> And if it compiles it's even more likely it'll do what you want
15:55:46 <dons> very rarely (never?) have I messed up layout and not produced a grammatical error
15:55:53 <dons> or type error
15:56:21 <Pirate> ok i think i get it
15:56:26 <Pirate> cheers
15:58:34 <Pirate> another problem im having is i have a function that takes in (a:b:src) and does stuff depending on what a and b are, but if b doesnt exist it messes up, like if i passed it ["1"] it doesnt work, is there any way around this?
15:59:23 <dons> yes. write multiple defns for your function
15:59:44 <dons> f [] = .. ; f (a:_) = ... ; f (a:b:_) = ..
16:00:23 <Igloo> YM f [a] = ...
16:00:58 <zamez> "Unspecified action"
16:01:03 <zamez> when I submit the form :(
16:01:08 <dons> you need javascript :(
16:01:16 <Pirate> not sure if i can make that work, ive pasted my code and the sml code im trying to work from if someone could have a look pls http://rafb.net/paste/results/FnXko937.html
16:01:20 <zamez> ok
16:01:23 <dons> zamez: w3m didn't work, mozilla did.
16:02:18 <Igloo> That SML doesn't work if you pass it ["1"] surely?
16:02:43 <Pirate> im not sure i dont have sml, its just the sample code from my uni notes
16:02:43 <Igloo> Oh, no, I see
16:03:05 <Igloo> You want lex _ = [] under the definition you already have
16:03:34 <Pirate> right ok i'll give it a go
16:03:43 * Igloo notices the Haskell at the bottom - or a case   lexer [_] = [] inbetween the two
16:06:22 <Pirate> ok cool it works, cheers for that
16:08:30 <Pirate> infact no is still doesnt work for some cases ;(
16:09:50 <lisppaste2> metaperl pasted "help needed this function does more than it's type signature promises" at http://paste.lisp.org/display/6301
16:11:39 <nnunley> metaperl:  Isn't that a Monad that wraps a tuple? Note, I'm a Haskell newbie.
16:11:57 <metaperl_> "wraps a tuple" - that terminology has me lost
16:12:12 <metaperl_> it did come from a Haskell tutorial on monads : http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
16:12:37 <nnunley> metaperl:  The monad will bind the state inside it, and when it's called it can pass the new state to the next monad in the chain.
16:13:21 <metaperl_> I understand the idea, my issue is that the type signature promises to return a StateTrans which is a function which returns a 2-tuple
16:13:37 <metaperl_> but if you look at the function, it will return a 2-tuple not a function that returns a 2-tuple
16:16:53 <metaperl_> could someone please look at the type signature here and tell me that I am not wrong: http://paste.lisp.org/display/6301
16:26:25 <monochrom> metaperl_: I see nothing wrong.
16:27:00 <metaperl_> monochrom, but what does >>= return per the definition in the paste?
16:27:19 <metaperl_> the type signature promises a StateTrans will be returned
16:27:52 <monochrom> You have (\s0 -> let ... in q s1).  Yes, (q s1) alone is a 2-tuple and has type (s,a).  Therefore (\s0 -> let ... in _2-tuple-here_) has type s->(s,a).  Everything fits.
16:28:06 <metaperl_> if you look at the function, the last thing to execute is q s1 which will return a 2-tuple, not a StateTrans
16:28:44 <metaperl_> whoa.
16:28:56 * metaperl_ goes to stare at the paste with this new information
16:29:43 <metaperl_> my god, you are right
16:29:53 <metaperl_> I was too deep in the forest to see the trees
16:29:56 <metaperl_> thanks man
16:30:02 <monochrom> You're welcome.
16:32:30 <Cale> metaperl: did you read my monads as containers article?
16:32:47 <metaperl_> where is that article?
16:33:11 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
16:33:16 <metaperl_> I have perused 3: nomawares' , "Monads for Working Haskell Programmer", "Systematic development of Monads"
16:33:21 <metaperl_> ok I will go look
16:33:28 <metaperl_> nomaware's description has just sunk in
16:33:37 <metaperl_> and it's fairly straightforward
16:33:39 <metaperl_> you have a type
16:33:53 <metaperl_> a factory for things of that type (called return)
16:34:20 <metaperl_> and a combinator (that takes type instances and produces new type instances)
16:34:44 <metaperl_> the magic is in the combinator to create all the myriad of effects
16:47:01 <shrimpx> it's just functions
16:48:13 <Pirate> is it possible to do 2 let functions in one line, sort of line let a = f1 x and let b = f2 x in f3 (a,b) ?
16:49:13 <heatsink> use braces and semicolons
16:49:22 <TheHunter> let a = f1 x; b = f2 x in f3 (a,b)
16:50:21 <Pirate> thats not working for some reason, heres the actual line of code: (LSEP "(") -> let (e, src1) = pX src ; src2 = (expect (LSEP ")") src1) in (e, src2);
16:50:35 <Pirate> that line is taken from inside a case of expression
16:52:40 <TheHunter> hmm, do you need the `;' at the end of that line?
16:53:42 <Pirate> http://rafb.net/paste/results/Ai3hO627.html is the whole function
16:56:04 <TheHunter> mixing { ... ; ... } and ... ; ... - Style is probably a bad idea.
16:56:52 <TheHunter> try let { ... ; } or use layout for the case clauses.
16:58:13 <Pirate> if i change the line to (LSEP "(") -> let {(e, src1) = pX src ; src2 = (expect (LSEP ")") src1) in (e, src2);} i get an unexpected keyword 'in' error
16:59:10 <TheHunter> the closing brace must be before `in'
16:59:16 <Pirate> ok
17:06:35 <Pirate> ok ive figured out whats wrong but i dont understand why, the function pX catches the error properly, but when i call fst(result from pX) it doesnt pass on that there has been an error and just passes incorrect data
17:09:30 <metaperl_> Cale, your way of explaning this requires me to drop a lot of my thinking and simply work with your simple direct approach. I will go back to the beginning of your explanation and tell you the very first thing that confused me
17:09:44 * metaperl_ heads home to jump on IRC at home... the weekend if HERE
17:13:59 <heatsink> Pirate: where does the incorrect data come from?
17:15:14 <Pirate> on  the source i posted a link to before
17:15:22 <heatsink> be more specific.
17:15:34 <Pirate> the function pX will stop with an error if it gets the wrong data
17:16:09 <Pirate> but if i call the function p which takes the fst argument pX returns it just pretends there isnt an error
17:16:15 <heatsink> You know that pX evaluates lazily, right?
17:16:29 <Pirate> i have no idea what that means im araid
17:16:36 <Pirate> *afraid
17:16:47 <Pirate> very new to haskell
17:17:14 <heatsink> Haskell doesn't calculate a function's result until it is used.
17:18:23 <Pirate> right so what should i do then?
17:18:36 <heatsink> That depends on what you want to do.
17:19:08 <heatsink> If you have some more code that uses everything the parser produces, then the error will get thrown.
17:20:31 <heatsink> http://www.haskell.org/hawiki/HaskellNewbie_2fLazyVsStrictEvaluation?action=highlight&value=lazy
17:20:42 <heatsink> http://www.haskell.org/hawiki/HaskellNewbie_2fLazyVsStrictEvaluation
17:21:38 <Pirate> ive written a new p function which checks if the second argument is empty or not, and now it works
17:22:00 <heatsink> good.
17:22:22 <Pirate> thanks for the help
17:23:03 <heatsink> Twas nothing.
20:44:14 <Lemmih> Good morning, #haskell.
20:51:36 <dons> good morning Lemmih
20:59:33 <Xih> hi
21:01:33 <CosmicRay> good evening
22:09:19 <MachinShin> g'night all
23:24:12 <scalopus> hi
