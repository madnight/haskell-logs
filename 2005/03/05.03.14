00:57:53 <dons> @plugs 2^127
00:57:53 <lambdabot> Sorry, I don't know the command "plugs", try "lambdabot: @listcommands"
00:58:02 <dons> oh, no plugs here.
01:39:22 <tromp> g'morning
01:40:34 <Magical1> morning
02:04:22 <araujo> Good morning.
02:05:10 <_mordechai> goof afternoon
02:05:13 <_mordechai> bleh
02:05:16 <_mordechai> i hate typos
02:52:12 <bourbaki> moin
03:19:11 <swiert> any type class experts around today?
03:19:34 <musasabi> Any good tools to create colored html out of haskell source files from the command line?
03:20:21 <swiert> Text.Html?
03:21:09 <musasabi> swiert: that would mean writing up a program to do it..
03:22:47 <swiert> musasabi: true - but it should be pretty easy for simple stuff.
03:22:50 <earthy> musasabi: ever tried vim?
03:23:19 <earthy> open a haskell file in vim, syntax colorise it, write the colorised html
03:24:16 <musasabi> earthy: can that be scripted? (I don't know vim that well)
03:24:25 <earthy> musasabi: not sure
03:24:27 <earthy> I think it can
03:27:47 <Heffalump> the mod_haskell stuff has some things that do that, I think.
03:27:52 <tromp> vim can output html?
03:32:21 <musasabi> googling does not yield much
03:32:54 <earthy> tromp: it can
03:33:24 <Heffalump> http://losser.st-lab.cs.uu.nl/mod_haskell/demo but the links to the actual highlighted stuff are broken
03:34:31 <earthy> musasabi: fire up vim and type :help
03:35:13 <earthy> the trick is to use  :runtime! syntax/2html.vim
03:35:28 <earthy> or even :TOhtml
03:35:53 <earthy> there we go: for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
03:36:00 <earthy> I knew it'd be in the docs. ;)
03:36:40 <earthy> (that will turn all .c and .h files into colorised HTML)
03:38:51 <musasabi> thanks
03:39:05 <tromp> what's diff between vim and gvim?
03:39:15 <bourbaki> the g
03:39:20 <earthy> tromp: gvim sports a gui
03:39:38 <earthy> which is useful, as it does better where it comes to color
03:40:22 <tromp> cool
03:56:30 <bourbaki> does anyone of you know hackers and painters?
03:57:23 <ibid> i know a few hackers but no painters, sorry
03:57:24 <ibid> ;)
03:57:54 <ejt> bourbaki: the book is good if that's what you mean
03:58:26 <bourbaki> i just have lend it and i dont like it too much somehow
03:58:51 <ejt> it's very much ones mans opinion
03:59:27 <bourbaki> thats not what makes me dislike it
03:59:32 <bourbaki> its somehow the length
03:59:53 <ejt> too long ? too short ?  too near a prime number of pages ?
03:59:55 <bourbaki> if i want to give anything like tips itll be short and pregnant
04:47:59 <jlouis> tromp: added power of gvim: gtk+2 bindings give antialiased fonts with color
05:47:03 <basti_> hi all
05:51:43 <bringert> I get a segfault when using +RTS -xc with ghc 6.4
05:51:51 <bringert> with ghc 6.4 compiled ocde that is
05:51:56 <bringert> code
05:53:01 <bringert> seems like a C stack problem
05:53:17 <bringert> backtrace in gdb gives 2792 calls
05:54:21 <Lunar^> bringert: bad news
06:02:16 <bringert> Lunar^: :-)
06:02:26 <bringert> ghc bug I guess?
06:06:09 <Lunar^> bringert: Could you try with -fvia-C ?
06:10:13 <bringert> trying...
06:13:32 <bringert> segfaults too
06:16:21 <Lunar^> What's the default, though ? ;)
06:16:31 <Lunar^> 6.4 should have been 7.0
06:16:33 <Lunar^> reallfy
06:16:49 <musasabi> I remember -xc crashes with 6.3 too.
06:17:00 <musasabi> so that is not really isolated.
06:33:59 <wilx> -xc?
07:35:01 * earthy reads `monadic operators' and is thrown for a moment asking himself `what does this have to do with monads?' until he realises what it really is about
08:06:36 * Lemmih pops a mail to the ghc-users.
08:22:38 <Ruller> Hello, everybody! :))
08:23:47 <Lemmih> Hey Ruller.
09:12:55 <Remi> hi al
09:12:56 <Remi> l
09:13:49 <Lemmih> Hey Remi.
09:15:33 <Remi> remind me to think of a nick which doesn't clash with someone elses ;)
09:20:31 * nlv11757__ sighs verrrrrry deep
09:21:10 * Remi gets enlightened
09:24:52 <nlv11757__> why does read only say...no parse :/
09:26:10 <_0222895_Remi_> bad answer: because that's what the report says it should
09:26:57 <nlv11757__> im going to cry
09:27:12 <musasabi> nlv11757__: reads might help.
09:27:27 <nlv11757__> @eval reads
09:27:27 <lambdabot> unbound variable: reads
09:27:33 <nlv11757__> @info reads
09:27:37 <nlv11757__> @type reads
09:27:39 <lambdabot> -- reads is a variable
09:27:39 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
09:27:40 <lambdabot> reads :: forall a. (Read a) => String -> [(a, String)]
09:27:54 <_0222895_Remi_> (the definition of "read" in the report does say "no parse" and semantics usually are to be the same as the report version. However, I'm not sure whether that counts for bottom too, and either, I think it would be a usefull "backward incompatible extension" if it were to say something more useful)
09:28:25 <musasabi> read is slow and awkward anyways for anything real ;)
09:30:56 <nlv11757__> i was hoping read prevented my from writing a parser myself
09:31:27 <_0222895_Remi_> that depends on how complex your parsing needs are
09:31:35 <nlv11757__> i do have to note that im trying to read a complete syntax tree of a C program....go figure why im crying about the "no parse" response :)
09:31:54 <_0222895_Remi_> eeks
09:32:15 <_0222895_Remi_> uhm, good luck pretending to be a binary search algorithm :S
09:32:17 <nlv11757__> i kinda had a bad feeling it wasnt going to succeed :P
09:32:32 <nlv11757__> binary search algorithm?
09:33:11 <_0222895_Remi_> as in "remove half of the failing syntax tree and see if it fails. if it does, the culprit is somewhere inside it, if it doesn't, leave it out. repeat"
09:33:59 <musasabi> nlv11757__: you might want to look at parsec.
09:34:27 <nlv11757__> im using a different parser combinator library from UU by doaitse swierstra
09:35:00 <nlv11757__> it will do the job
09:35:21 <nlv11757__> ow well, i guess i'll be writing an ast parser tomorrow :#
09:35:41 <nlv11757__> g'night all
09:41:12 <_0222895_Remi_> anyone in favour of on/compose2 (see also ThingsToAvoid on the wiki) and against comparing?
09:41:40 * _0222895_Remi_ just saw Simon wanting to add comparing comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
09:46:33 <_0222895_Remi_> at http://www.haskell.org//pipermail/libraries/2005-March/003427.html
10:03:58 <musasabi> What is the latest incarnation of hOp / house ?
10:10:01 <Cale> whoa
10:10:04 <Cale> cool
10:12:34 <Lunar^> musasabi: House CVS afaik
10:12:42 <Cale> I should subscribe to the libraries list.
10:12:49 <Lunar^> musasabi: There's networking support ! :)
10:13:14 * _0222895_Remi_ invites Cale to read the whole thread ;)
10:13:18 * _0222895_Remi_ goes to dinner
10:16:27 <Lunar^> great one: http://www.phdcomics.com/comics/archive.php?comicid=562
10:18:06 <musasabi> Lunar^: nice, I'll fetch that :-)
10:20:18 <xerox> Lunar^, what does "defending" means in al of those strips? :D
10:21:30 <Lunar^> xerox: When you finish your thesis, you must defend it
10:46:15 <det> Lunar^, Can you use a sword?
10:47:59 <wagle> one theory i heard that was successfully applied was to serve donuts and to keep your committee (carefully selected for just this purpose) arguing with each other instead of you
10:50:58 <bourbaki> moin
11:01:09 <Cale> wagle: haha
11:49:17 <Arsilan> halÃ¸jsa
11:49:24 <Arsilan> David hvor er dy
11:49:35 <musasabi> evening
11:49:46 <Arsilan> HVem er du
11:49:53 <wagle> anyone want to admit to understanding how to learn something from a User.dmp file emitted by drwatson on win2kpro?
11:49:57 <Lemmih> Arsilan: Use PM.
11:50:04 <Oeje1> Arsilan: Hvem er du selv?
11:50:35 <Arsilan> JEg hedder Arsilan og gÃ¥r i HTX 1g
11:51:05 <Oeje1> Arsilan: Nøj, cool.  Hvorhenne?
11:51:58 <Arsilan> Emdrup
11:54:32 <Oeje1> Arsilan: Ah, det ved jeg hvor ligger, tror jeg.  KTS?
11:54:51 <Oeje1> Ved Emdrup Station?
11:55:03 <Lemmih> Oeje1: Yep.
11:55:40 <Oeje1> Så er det jo ligefør at vi skal have en #haskell.dk op at køre. ;-)
11:56:01 <Lemmih> Oeje1: He's not really a Haskeller /-:
11:56:08 <Arsilan> En privat hjemmeside
11:56:19 <Arsilan> Sygt nok jeg har alerde en
11:56:23 <Lemmih> Oeje1: I went to high school with him there for a couple of months.
11:56:45 <Arsilan> www.Arsilanhamid.1go.dk
11:57:04 <Lemmih> Arsilan: Don't spam.
11:57:15 <Arsilan> hva er det
11:57:31 <Oeje1> Arsilan: Kan du programmere?
11:57:42 <Arsilan> NEj
11:57:53 <Lemmih> Arsilan: #haskell is for Haskell (and Haskell related) info only.
11:58:03 <Oeje1> Arsilan: Kunne du tænke dig at lære det?
11:58:39 <Arsilan> HVa kan man bruge det der programering til
11:58:47 * musasabi tries to parse all that with a limited swedish skill (written danish is close enough)
11:59:09 * _0222895_Remi_ doesn't even try
11:59:15 * Lemmih slaps Arsilan and Oeje1 for speaking Danish.
12:00:27 <Arsilan> Hva kan man bruge det er programering til
12:00:34 <wagle> try parsing it with a very poor grasp of german..  8)
12:01:52 <Arsilan> What can you use programing to
12:02:38 <Oeje1> Arsilan: Good question.   Automating computations f.ex.
12:03:45 <Oeje1> Arsilan: And writting all of the applications on your computer yourself. :-)
12:04:10 <Arsilan> Well if its some lessons wich you all take togehter in a place its ok with me
12:06:06 <zugzwang> the ghc readline library appears not to handle signals as one might like - in particular ctrl-c'ing has no immediate effect (the signal is not passed up from readline, as the docs suggest it should be). Anyone know of a fix/workaround?
12:06:07 <Lemmih> Does 'the internet' qualify as the same place?
12:07:23 <zugzwang> getCatchSignals returns True, btw
12:07:48 <Arsilan> HEy check out my website
12:07:58 <Arsilan> www.Arsilanhamid.1go.dk
12:08:09 <Lemmih> Somebody please kick him.
12:08:21 <Arsilan> And tell me your opnion
12:08:42 <Arsilan> Hey David shut up, hehe , im proud of my website
12:08:56 <_0222895_Remi_> hm, anyone planning to write a bayesian irc-spamfilter in haskell?
12:09:25 <lightstep> Arsilan, something in your site keeps the scrolling wheel on mozilla1.7/linux2.4 from working
12:09:46 <musasabi> Remi: ignoring all urls except from 1) registered nicks 2) whitelisted domains ;)
12:10:20 <_0222895_Remi_> musasabi: But then I'll have to register a nick myself...
12:10:44 <lightstep> and we'll have to actually use auto-identify scripts
12:10:46 <musasabi> Remi: that is the easiest way to keep a nick.
12:11:01 <musasabi> Using nickserv is not that hard.
12:11:18 <Arsilan> Lighstep: it does scroll ihave tryied rigt now
12:11:38 <Lemmih> Arsilan: Not everyone is using IE.
12:11:57 <_0222895_Remi_> haha
12:12:12 <_0222895_Remi_> Lemmih: haven't you played bzflag enough today yet? :P
12:12:32 <Lemmih> Huh?
12:12:32 <Arsilan> Oh I did not now
12:13:28 <_0222895_Remi_> Lemmih: nevermind
12:15:12 <Khisanth> lightstep: depends on the IRC client you use
12:15:28 * _0222895_Remi_ goes kitchencleaning while GHC is being compiled once more
12:15:37 <Arsilan> Why do you get kicked out if you spam
12:16:01 <lightstep> i have a (n almost) clean install of irssi. it doesn't auto-identify on freenode, so i have to configure it
12:16:22 <zugzwang> _0222895_Remi_: huh... 6.4 has been compiling for 2 days and counting on my machine...
12:17:25 <_0222895_Remi_> zugzwang: it take something like 5 hours here, but I'm keeping thousands of little .o and .a files, all alike, around to speed the damn thing up when I changed one line ;)
12:17:49 <_0222895_Remi_> though the dependency checking doesn't seem to be exactly what I hoped it was, so I occasionally have to remove some of them to get it to compile :(
12:20:11 <zugzwang> _0222895_Remi_: I haven't tried it, but I happened to see in the docs that 'gmake FAST=YES' will forego dependency checking. Would that help?
12:21:25 <Oeje1> GHC 6.4 compiles flawlessly on Solaris 9. :-)
12:23:04 <musasabi> Oeje1: do you have a build which does not have external dependencies?
12:23:10 <musasabi> i.e. readline etc
12:24:33 <Oeje1> musasabi: Uh, I don't know.  I just did:  configure --prefix=$MYROOT; gmake; gmake install. :-)
12:25:42 <wagle> musasabi: why not build the stuff it depends on first?
12:26:19 <musasabi> wagle: because I just want to try whether a library of mine works on solaris.
12:26:58 <musasabi> wagle: and installing various libraries + dealing with differing C compilers etc does not sound like fun
12:27:48 <_0222895_Remi_> zugzwang: I _do_ want dependency checking. Thing is that when I compile, add a primop (or change its signature) and compile again, it dies
12:28:52 <wagle> hmm..  i've spent so much time bending my mind around it that its trivial to me
12:29:33 <wagle> main tool is ./configure --prefix=<path_root>
12:30:59 <_0222895_Remi_> configure does lots of dependency checking that make doesn't, or am I misunderstanding you?
12:31:03 <wagle> then for solaris, you (1) set PATH to include <path_root/bin, (2) set LD_LIBRARY_PATH to include <path_root/lib, and (3) set MANPATH to include <path_root>/man
12:31:48 <Oeje1> wagle: Why do I have much trouble getting most things to compile on Solaris then?
12:31:51 <musasabi> The process is more like 1) install gmake, 2) notice that you will need gcc in addition sun cc, 3) notice your version of gcc is ancient 4) ...
12:32:09 <_0222895_Remi_> sounds like fun ;)
12:33:29 <wagle> Oeje1: dunno..  mind you the last solaris i admin'd was 2.5.1 in 1997, though I built an entire GNU software suite for 2.5.1 for a bunch of old sparcs (and the cse dept server) in 1999
12:34:24 <wagle> the gnu for the cse dept server was --prefix=~/gnu
12:34:50 <wagle> Oeje1: what happens when you try to compile under solaris?
12:36:33 <Oeje1> wagle: Mostly it tells me that some recent enough library is missing. :-P
12:49:27 <wagle> Oeje1: does strace (ptrace?) show it looking for the library in the correct directory?
12:50:28 <Oeje1> wagle: That was just a general statement.  But look at Darcs on Solaris compiled with GHC 6.4:
12:50:32 <Oeje1> checking GHC.Handle.openFd... NOT old API
12:50:32 <Oeje1> checking GHC.Handle.openFd new API... failed
12:50:32 <Oeje1> configure: error: Couldnt figure out how to call GHC.Handle.openFd!
12:51:30 <wilx> Wheee! I have a working LZW encoder and decoder!
12:51:38 <wilx> Now only storage.
12:51:44 <wilx> I am soo leet.
12:52:12 <musasabi> Oeje1: that is not solaris specific.
12:52:40 <musasabi> Oeje1: darcs-unstable at least works with 6.4
12:52:54 <wagle> Oeje1: which version of solaris?
12:53:57 <_0222895_Remi_> Oeje1: which darcs is that?
12:54:07 <_0222895_Remi_> Oeje1: (version, that is)
13:00:14 <musasabi> wilx: what kind of compression/performance are you getting?
13:02:21 <wilx> Heh, none yet. I have really onle the two routines that do the encoding and decoding.
13:02:41 <wilx> I doubt that it will be any good wrt performance. I did it very naively I think.
13:03:20 <wilx> I guess I could try it though... Let me see...
13:04:08 <Oeje1> musasabi, wagle, _0222895_Remi_: Machine: sun4u, OS version 5.9, Processor: sparc.  Darcs 1.0.2 stable.
13:04:24 <musasabi> btw what are you calling the module - Codec.Compression.LZW ?
13:04:36 <wilx> Just LZW for now :)
13:04:49 <musasabi> Oeje1: using a newer version of darcs should work.
13:06:34 <wilx> This is my first more complicated program in Haskell so it will need whole lot of polishing to be usable in general.
13:06:54 <wilx> s/in general/generally/
13:07:16 <Oeje1> musasabi: Ah! 1.0.2 also fails with GHC 6.4 on GoboLinux.
13:07:37 <_0222895_Remi_> Oeje1: where "newer version" means the versino from darcs (i.e. not released yet)
13:08:44 * Oeje1 gets Darcs from the main repository.
13:13:13 * Lemmih bangs his head against the wall trying to port some OpenGL C code to Haskell.
13:15:47 <lightstep> how should i split a string by a substring? is there a ghc library with some good algorithm?
13:18:07 <_JusSx_> lightstep: with a funk
13:18:55 <lightstep> funk?
13:19:00 <_JusSx_> function
13:19:35 <lightstep> is there splitBy :: String -> String -> (String, String), which returns "before" and "after"?
13:22:24 <wagle> bummer..  irssi doesnt parse "," as a delimiter, and thus doesn't highlight for the substring " wagle, "
13:30:53 <musasabi> Anyone willing to test network-alt? I am thinking of linking it to libraries@h.o tomorrow...
13:31:42 * boegel jumps
13:33:32 <Lemmih> musasabi: Got haddock documentation for it?
13:33:49 <musasabi> Lemmih: yes, http://www.cs.helsinki.fi/u/ekarttun/network-alt/doc/
13:37:53 <Oeje1> Darcs is really slow at fetching changes, it feels.
13:40:25 <zugzwang> Oeje1: try darcs get --partial
13:42:40 <Oeje1> zugzwang: "get partial repository using checkpoint"; what is a checkpoint?
13:43:01 <musasabi> darcs optimize --checkpoint creates them
13:43:07 <musasabi> they are related to tags.
13:43:25 <Oeje1> musasabi: Ah, thanks.
13:43:40 <zugzwang> so it means you only get patches after a certain point
13:43:47 <zugzwang> rather than the entire history of the project
13:44:10 <Oeje1> zugzwang: I think, I understand.
13:58:41 <wilx> Yay!
13:58:56 <wilx> Got bitten by GHC's unicode Char.
13:59:32 <wilx> Building an array (minBound :: Char, maxBound :: Char) is no good :)
14:00:10 <wagle> wilx: how about a sparse array?
14:00:50 <wilx> Nah, I need the whole array. Just not for Char but for Word8 :)
14:00:54 <wilx> C++ habbits :)
14:01:24 <wagle> dwim
14:01:28 <wagle> a dwim array
14:01:39 <wagle> 8|
14:01:44 <wilx> Heh.
14:02:24 <Oeje1> wagle: I get a warning configuring Darcs and making.  Do you want to take a look? www.student.dtu.dk/~s022018/configure.log  and gmake.log
14:03:31 <wagle> Oeje1: i'm taking off for a bit now..  remind me if i dont remember
14:04:52 <Oeje1> wagle: Shure.
14:06:57 <_mordechai> morning! :>
14:13:39 <boegel> g'night everyone :D
14:15:48 <kosmikus> what happened to SyntaxNinja? is he no longer on #haskell?
14:17:00 <Khisanth> he was here just yesterday
14:18:41 <kosmikus> ok
14:19:08 <Oeje1> lambdabot: @seen SyntaxNinja
14:19:09 <lambdabot> I saw SyntaxNinja leaving #haskell 1 day 19 hours 50 minutes 58 seconds
14:19:09 <lambdabot> ago.
14:19:56 <kosmikus> thanks. nickserv told me something having seen him 11 weeks ago
14:20:17 <Muad_Dibber> he can have been online without identifying :)
14:20:48 <kosmikus> right
14:20:52 <Oeje1> Ah, spying to see if anyone talks about him behind his back. :-P
14:23:25 * Oeje1 goes to bed still not liking Solaris very much.
14:34:47 <wilx`> Ewww.
14:34:54 <wilx`> The performance is terrible.
14:35:20 <wilx`> It hasn't finished encoding 4MB text yet.
14:35:46 <wilx`> Two minutes...
14:37:08 <wilx`> Hmm....and it crashes when I try to profile it...
14:37:48 <Lemmih> With a segfault?
14:38:06 <wilx`> Seems so.
14:38:13 <wilx`> And it died now too: Stack space overflow: current size 8388608 bytes.
14:38:19 <Lemmih> Report it as a bug.
15:11:55 * _0222895_Remi_ hasn't quit
16:13:00 * stepcut has ghc 6.4 on his crappy dev box now \o/
16:13:21 <Lemmih> Hurrah.
16:13:29 <stepcut> now I just need to install haskelldb and wash...
16:13:51 * _0222895_Remi_ decided he doesn't want to wait for Yet Another Compile to finish and goes to sleep
16:14:52 <stepcut> fortunately my laptop is debian based, so I can just apt-get :)
16:15:32 <Igloo> stepcut: Please let me know what does and doesn't work with it (are you on the Debian Haskell list?)
16:15:50 <stepcut> no, but I probably should be
16:16:14 <stepcut> of course, even though I *can* just apt-get it, I haven't yet ;)
16:16:44 <Igloo> Oh, I didn't notice you were talking about different machines  :-)
16:17:38 <Igloo> Oh, I'll have to wait fort the power to come back on before pointing you at URLs
16:21:19 <Igloo> stepcut: Aha, http://urchin.earth.li/mailman/listinfo/debian-haskell and http://urchin.earth.li/pipermail/debian-haskell/2005-March/000075.html
16:21:56 <Lunar^> Igloo: this list is not on haskell.org?
16:22:03 <stepcut> my crappy dev box is a freebsd machine with a 600MHzDuron
16:22:22 <stepcut> with 128MB of ram
16:22:28 <Igloo> Correct
16:22:54 <stepcut> during the 6.2 compile process, ar needs about 600MB of memory which totally thrashes the disk :)
16:23:01 <stepcut> not sure if that still happens in 6.4
16:23:21 * Lunar^ will never understand how the haskell.org domain is managed...
16:23:38 <Igloo> I think there was resistance towards creating many low-traffic lists, and I prefered to Just Do It than to fight red tape
16:24:00 <dons> Igloo strikes a blow for the people :)
16:24:21 <Igloo> stepcut: I'm fairly sure it does
16:24:36 <Lunar^> Igloo: the fedora list is on haskell.org though
16:25:09 <Lunar^> Igloo: btw, experimental aren't going to buildd, are they?
16:25:26 <Igloo> Yeah - I don't know if the files also being on haskell.org is a factor, or if opinions have just changed, or what
16:25:57 <stepcut> I hope to install ghc6.4 on my debian machine later this week, but I have a big deadline coming up on wednesday
16:26:04 <Igloo> I believe most arches have experimental buildds, although they are taking longer to do anything than I'd assumed
16:27:44 * Lunar^ apt-get update again
16:28:25 <Igloo> Lunar^: What are you looking for?
16:28:57 <Lunar^> Igloo: PPC
16:32:01 <wagle> waugh.  i finally get fink to work again, find that it supplies ghc 6.2-2, and get that..  now i gotta wait for someone to get a round tuit and get ghc 6.4 into fink
17:18:54 <CosmicRay> hmm.
17:19:01 <CosmicRay> it seems CTime is no longer a member of the Integral class.
17:19:05 <CosmicRay> it is a member of Real now.
17:19:13 <CosmicRay> how can I convert something that I know is a Real into an Integer?
17:20:15 <Igloo> Real the type or the class?
17:20:21 <CosmicRay> Real the class
17:20:21 <Igloo> Prelude> :i Real
17:20:23 <Igloo> instance Real Int
17:20:28 <CosmicRay> specifically I need to convert a CTime into an Integer
17:20:37 <Igloo> Err, or even
17:20:38 <Igloo> instance Real Integer
17:20:51 <CosmicRay> that doesn't help me
17:20:59 <Igloo> I don't understand the question then
17:21:00 <CosmicRay> I need to go *to* Integer, not from it
17:21:04 <CosmicRay> I have a CTime
17:21:09 <CosmicRay> I need to convert it to an Integer
17:21:27 <Igloo> Oh, ISWYM
17:22:01 <Igloo> {floor,round,ceiling} . realToFrac?
17:22:50 <Igloo> Or if CTime is in RealFrac then you can drop the realToFrac
17:23:25 <Igloo> Ah, and it's required to be
17:23:46 <CosmicRay> that's got it.
17:23:54 <CosmicRay> nah, we're not that helpful in Foreign.C.Types :-)
17:24:14 <Igloo> Oh, sorry, I'm thinking the wrong way round
17:24:39 <CosmicRay> floor . realToFrac does what I want
17:24:45 <Igloo> Is this 6.4 breaking something?
17:24:50 <CosmicRay> I suspect so
17:24:54 <CosmicRay> this is actually the new hugs
17:25:00 <CosmicRay> CTime used to be an Integral
17:25:02 <CosmicRay> but it is no longer
17:25:06 <CosmicRay> in hugs
17:25:09 <CosmicRay> I haven't checked ghc
17:26:38 <Lemmih> Same in GHC.
17:27:13 <Igloo> Hmm, how do I get ghci 6.2.2 to tell me instances?
17:27:48 <CosmicRay> aw crap.  a finitemap is now showable.  stupid progress, interfering with my code :-)
17:27:55 <Lemmih> You upgrade to 6.4 (:
17:28:12 <Igloo> Lemmih: That doesn't help me confirm it's changed  :-)
17:30:01 * Igloo hacks around it with nested type sigs
17:30:14 * Igloo starts to think 6.4 in sarge isn't such a good idea
17:30:49 <CosmicRay> well, we've got the new hugs in sid
17:30:57 <CosmicRay> it is going to be *worse* to not have the new ghc in sid also
17:31:03 <Igloo> Although then we have everyone creating non-forwards compatible code
17:31:10 <CosmicRay> because there will have to be all sorts of special-casing
17:31:31 <CosmicRay> yeah, and it turns out that this is non-forwards-compatible code:
17:31:37 <CosmicRay> instance (Show a, Show b) => Show (FiniteMap a b) where
17:31:37 <CosmicRay>     show fm = show (fmToList fm)
17:31:47 <CosmicRay> and also effectively the same approach as used in the new fptools
17:32:06 <CosmicRay> Igloo: I think that since hugs is in sid, ghc should follow in short order
17:32:13 <CosmicRay> Igloo: having seen this
17:32:25 <CosmicRay> I have code that relies on FiniteMap being showable
17:32:39 <CosmicRay> this is going to be a mess unless we get the same fptools in both ghc and hugs
17:33:03 <Igloo> CosmicRay: Well, see my debian-haskell message  :-)
17:33:19 <CosmicRay> I did
17:33:24 <CosmicRay> haven't had time to reply yet
17:33:27 <CosmicRay> uh oh
17:33:34 <CosmicRay> ### Error in:   18:GZiptest:0:inflate:0:t1.gz
17:33:35 <CosmicRay> <handle>: IO.getContents: protocol error (invalid character encoding)
17:33:52 * Igloo thinks this would be a good time to write something to give a package -> rev-build-deps mapping
17:34:18 <Igloo> Hmm, is getContents assuming utf8 now?
17:34:59 <CosmicRay> that'll piss me off
17:35:20 <CosmicRay> oh well, SyntaxNinja can sort it out once he gets my bug :-)
17:40:06 <CosmicRay> and it'll break the gzip code I so painstakingly crafted around your Inflate :-)
17:46:41 <Igloo> Oh, I can't give runhaskell an expression on the commandline?
17:46:47 <Igloo> How annoying
17:49:18 <cm> peace
17:51:19 <Igloo> CosmicRay: OK, I can't break 'main = do xs <- IO.getContents; print xs' with the file "\x00\x80" that causes "iconv -f utf8 -t utf8" to say "iconv: illegal input sequence at position 1". Can you try to get a minimal failing case please?
17:53:02 * Igloo assumes this is a ghc error rather than one in your own code?
18:08:04 <Lemmih> Bwahaha. I've been staring at my code for the last 5 hours and I just now realized the mistake. I should blit the image to the tmp instead of the tmp to the image.
18:08:23 <heatsink> :)
18:09:36 <Igloo> heh
18:09:38 <Lemmih> Oh well. At least it works now.
18:10:32 <heatsink> That's like the time I spent a day figuring out why my program was outputting garbage, when the only problem was that it was reading the wrong file.
18:12:56 <Lemmih> SDL + OpenGL rocks, btw!
18:19:39 <Igloo> Lemmih: What platform are you on?
18:20:00 <Igloo> Oh, n/m
18:20:40 <Lemmih> Debian GNU/Linux.
18:43:04 <Igloo> ick, 955214 lines of nhc98 diff
18:43:55 <CosmicRay> whoa
18:43:58 <CosmicRay> something smells wrong
18:51:27 <sh10151> thanks for clearing up that it's not Debian BSD/Hurd
18:51:28 <sh10151> :-P
18:52:24 <CosmicRay> sh10151: stop it, you're giving people ideas!
18:52:53 <CosmicRay> we already have one hurd port and three bsd ports in progress, that's enough :-)
20:00:11 <stepcut> is there a cabal package for WashNGo (2.3.1) ?
20:04:04 <tmoertel> stepcut: not yet, but SyntaxNinja cabalized an earlier release; I have RPMs if you need them
20:15:50 * stepcut is on freebsd :)
20:16:13 <stepcut> compiling HtmlMonad98 with only 128 Mb of RAM is not a good idea :-/
20:21:43 <Cybertnt> Hey, if i have:
20:21:43 <Cybertnt> test :: Int -> Int
20:21:43 <Cybertnt> test n = test2 n
20:21:43 <Cybertnt> test2 n = n
20:21:43 <Cybertnt> But i would also make test2 print something to the console
20:22:39 <Lemmih> test2 = trace "Hello world" n
20:23:09 <Lemmih> Import Debug.Trace first. And only use it when debugging.
20:24:35 <Cybertnt> hmm ERROR Debug - Unable to open file "Debug"
20:25:09 <Lemmih> Cybertnt: Try ':l Debug.Trace'
20:25:44 <Cybertnt> ERROR Debug.Trace - Unable to open file "Debug.Trace"
20:25:51 <heatsink> :module Debug.Trace
20:26:26 <Cybertnt> ERROR - Cannot find module "Debug.Trace"
20:26:43 <Lemmih> :q [enter] ghci [enter]
20:27:32 <Cybertnt> -bash: ghci: command not found
20:27:49 <Lemmih> apt-get install ghc; ghci
20:28:02 <Cybertnt> why?
20:28:04 * Lemmih is just joking, btw.
20:28:41 <Lemmih> Why do you wanna do IO in a pure function?
20:29:18 <Cybertnt> because i need to print something to the console but the function also needs to return something again
20:29:36 <Cybertnt> or can i call a a function that just prints out and returns nothing?
20:29:50 <Lemmih> What about :: IO Int?
20:30:19 <Lemmih> test2 n = putStrLn "Hello world" >> return n
20:31:25 <Cybertnt> then i get:
20:31:26 <Cybertnt> *** Expression : test
20:31:26 <Cybertnt> *** Type       : (Num a, Num (IO a)) => a -> IO a
20:31:52 <Lemmih> Did you change the type of test to :: Int -> IO Int?
20:32:52 <Cybertnt> ah works now :)
20:34:06 <Cybertnt> thanks
20:34:26 <Lemmih> No problem.
20:38:13 <Cybertnt> but it wont work for this?
20:38:20 <Cybertnt> test 0 = test3 0
20:38:20 <Cybertnt> test n = test2 n
20:38:20 <Cybertnt> test2 n = putStrLn "Hello world" >> return n
20:38:20 <Cybertnt> test3 n = n
20:39:05 <Lemmih> test2 has type ':: Int -> IO Int' where test3 has type ':: Int -> Int'.
20:41:00 <Lemmih> @wiki ThatAnnoyingIoType
20:41:00 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
20:41:37 <Cybertnt> ok
20:41:41 <Cybertnt> thanks
21:03:07 <tmoertel> stepcut: I think that compiling HTMLMonad98 took about 700MB on my workstation
21:17:19 <Cybertnt> Hmm, i have a list and need to increase the value of a element in the list by 1. Whats the best way to do that? i thought of take and drop..
21:17:48 <tmoertel> which element?
21:18:45 <Ruller> Good Morning!
21:20:52 <Cale> Cybertnt: a single element? Any one in particular?
21:21:15 <Cybertnt> the element at position x
21:23:47 <tmoertel> take a look at Data.List.splitAt
21:24:23 <Cybertnt> ok :)
21:26:32 <Cale> but if you have to update the list like that a lot, then you might want another structure.
21:26:48 <Cybertnt> yeah it will happen quiet a lot..
21:27:06 <Cybertnt> i thought of recursivly traveling through the list until i am at position x
21:27:12 <Cybertnt> would that be efficent?
21:28:02 <tmoertel> can you provide more context? what is the bigger problem that you are trying to solve?
21:31:08 <Cale> Insertions/replacements are O(log(n)) time on maps from Data.Map (probably the finite maps in Data.FiniteMap as well)
21:31:20 <Cybertnt> i want to call a function valueIncrement with 2 parameters (one is the list, one is the position of the element in the list that should be incremented), this must be a pretty fast method as the valueIncrement will be called often. Thats why i thought of traveling recursivly through the list until i am at the position and then increment the value. Now i was wondering if that would be the fastest way?
21:31:25 <Cale> whereas on lists, they'll be linear time
21:31:59 <tmoertel> Cybertnt: if you're just doing this once per list, it will be hard to beat splitAt.
21:32:51 <tmoertel> Cybertnt: but, if you're doing this a lot on the same list, it will likely be more efficent to use a representation with less expensive lookups (Data.Map or Data.Array)
21:32:53 <Cale> I don't mean to replace the splitAt implementation on lists, it's good, but you might consider not using lists at all if you're really talking about something else.
21:33:16 <Cale> It sounds more like you have an array or a finite map, if you're updating things in the middle of it.
21:33:35 <Cybertnt> the list can theoretically be infinite
21:34:15 <Cale> What does it actually represent?
21:34:29 <Cybertnt> a list of numbers
21:34:47 <Cale> just a list of numbers?
21:34:56 <Cybertnt> yes just a list of numbers
21:34:58 <tmoertel> a list of what kind of numbers, and what do the numbers represent?
21:35:11 <Cale> I mean, what does that list of numbers actually mean to your program?
21:35:13 <tmoertel> and what is their distribution?
21:36:24 <Cybertnt> the program will represent a turing machine, thus the list is the "storage band"
21:36:46 <Cale> ah, okay
21:37:47 <Cybertnt> well if i use splitAt how would i go about accessing the element in the tupel ?
21:38:12 <tmoertel> case splitAt n xs of (before, e:after) -> ...
21:38:46 <Cybertnt> ah ok thanks :)
21:39:11 <sylvan> inc xs n = a ++ (b+1) ++ c where (a, b:c) = splitAt n xs
21:39:45 <sylvan> or rather : instead of ++ there in front of c
21:40:10 <sylvan> er, the first c...
21:40:10 <sylvan> too early...
21:40:24 <Cybertnt> yeah i get what you mean :P
21:44:47 <Cale> Since in the case of a Turing machine tape, you're going to have some point which is under the marker, and you want fast access to things close to that, you might represent a TM tape as a value (under the pointer) and two lists of values of the same type: those before the pointer (in reverse order) and those after.
21:45:09 <Cale> This might actually be more convenient for you
21:45:39 <Cale> e.g. data Tape a = Tape [a] a [a]
21:46:26 <Cale> then you can define actions on these tapes such as moving the marker to the left or right by shuffling things around
21:46:40 <Cale> and writing at the pointer is trivial
21:46:57 <Cybertnt> yes, and that why i wouldnt need to have a pointer variable
21:46:57 <sylvan> I think Cale is on to something here...
21:47:09 <Cybertnt> *way
21:49:38 <Cybertnt> Cale: i will try that way, thanks :)
22:03:39 <SyntaxNinja> w00t
22:03:47 <SyntaxNinja> damn haskell badmouthers on slashdot
22:04:15 <tmoertel> SyntaxNinja: where? what did they way?
22:05:05 <SyntaxNinja> http://developers.slashdot.org/article.pl?sid=05/03/14/2258219&
22:05:36 <SyntaxNinja> so someone writes some lame-ass OCaml code and doesn't bother asking if it's good code before posting to slashdot.
22:05:49 <SyntaxNinja> and to boot they say, "And OCaml is still faster than Haskell"
22:06:14 <tmoertel> SyntaxNinja: gee, I'm not sure how we could hope to find flaws in this "analysis" ;-)
22:06:51 <SyntaxNinja> and then of course someone posts, "Haskell is really pretty for fake problems, but if you want to do anything for real, then you have to learn monads, and who knows what that is" basically
22:09:51 <Khisanth> that is amusing ... so the poster is basically saying "Haskell sucks because I am too dumb to understand it"? :)
22:10:15 <ozone> you guys are surprised at these responses?
22:10:28 <tmoertel> no, just a little disappointed, is all
22:10:43 <ozone> get used to it :}
22:11:17 <tmoertel> did anybody get a link to the guy's Haskell version?
22:13:41 * SyntaxNinja posted a follow-up :)
22:13:51 * tmoertel reloads the page
22:13:54 <SyntaxNinja> it's still scored a 1, but it's only been 20 minutes or so
22:14:32 <tmoertel> what's your /. userid?
22:14:34 <SyntaxNinja> probably no one will read it; it's a sub-thread to a developer-only story from a post that's a few hours old, at night in the US.
22:14:44 <SyntaxNinja> ijones
22:14:58 <Cybertnt> Cale: still there?
22:15:03 <Cale> yeah?
22:15:29 <monochrom> slashdot is full of unleanred people.
22:15:35 <Cybertnt> i implemented the tape now
22:15:35 <Cybertnt> pointerIncrement (Tape l p [])      = Tape (l ++ [p]) 0 []
22:15:35 <Cybertnt> pointerIncrement (Tape l p (h:r))   = Tape (l ++ [p]) h r
22:15:35 <Cybertnt> pointerDecrement (Tape [] p r)      = Tape [] 0 ([p] ++ r)
22:15:35 <Cybertnt> pointerDecrement (Tape l p r)       = Tape (init l) (last l) ([p] ++ r)
22:15:35 <Cybertnt> is that how you meant it?
22:15:58 <Cale> why not put the things at the beginning
22:16:00 <Cale> ?
22:16:16 <SamB> Cybertnt: the first list isn't backwards!
22:16:27 <monochrom> slashdot = the blind modding-up the blind
22:16:29 <Cybertnt> Cale: what things?
22:16:52 <Cale> data Tape a = Tape [a] a [a] | TError deriving Show
22:16:52 <Cale> moveLeft (Tape [] m as) = TError
22:16:52 <Cale> moveLeft (Tape (b:bs) m as) = Tape bs b (m:as)
22:16:52 <Cale> moveRight (Tape bs m []) = TError
22:16:52 <Cale> moveRight (Tape bs m (a:as)) = Tape (m:bs) a as
22:16:58 <Cale> is what I had
22:17:16 <tmoertel> SyntaxNinja: I guess you figured "main = interact id" would be to obscure; probably a good call
22:17:57 <tmoertel> tmoertel: I think it's funny how people complain about how difficult Haskell becomes when you try to do stateful stuff and interact with the real world
22:18:05 * tmoertel is talking to himself ?
22:18:17 <monochrom> haha
22:18:25 <Cybertnt> Cale: ok, but you shouldnt Error, because its a infinite Tape
22:18:42 <tmoertel> when the reality is quite the opposite; it's very elegant because you can keep the pure and the impure cleanly partitioned
22:18:44 <SyntaxNinja> tmoertel: maybe a more advanced cat would use that :)
22:18:47 <Cale> okay, so I suppose you want that case to expand the tape
22:18:54 <Cybertnt> yes
22:19:01 <Cybertnt> well i adopted it in your code :)
22:19:05 <Cybertnt> thanks for the advice
22:19:29 <SyntaxNinja> tmoertel: yep, exactly.  I've been on an "anti-non-idiomatic" kick lately, that is, "there's no such thing as non-idiomatic Haskell"
22:19:33 <SyntaxNinja> or at least, it's way over-hyped
22:19:44 <SamB> tmoertel: its just that sometimes the pure parts twist your head inside out
22:19:59 <Cale> Cybertnt: maybe we want it to be data Tape a = Tape [Maybe a] (Maybe a) [Maybe a], or something -- depending on the behaviour you want
22:20:18 <ozone> SyntaxNinja: eh?  you think everything in haskell is idiomatic?
22:20:20 <Cybertnt> what does Maybe do ?
22:20:37 <Cale> data Maybe a = Just a | Nothing
22:20:39 <SyntaxNinja> ozone: more just that using Monads does not mean that you're writing bad haskell code
22:20:56 <SyntaxNinja> ozone: using mutable arrays for the sake of efficiency, for instance. I think some people would consider that non-idiomatic
22:20:56 <Cybertnt> Cale: oh i guess not, as i want it to be strict
22:20:58 <tmoertel> SamB: to be honest, i /do/ think it takes some time to grok pure fp
22:21:22 <SyntaxNinja> tmoertel: but is it any harder than groking imperative or OO languages?
22:21:25 <ozone> SyntaxNinja: you can write crappy code in any language, but you knew that
22:21:45 <Cale> Cybertnt: if you're sure the tape must only contain integers, then you could of course have something like  data Tape = [Integer] Integer [Integer]
22:21:54 <monochrom> A friend took me when he learned BASIC as a kid it took him quite some time to grok "X = X + 1".
22:21:59 <Cale> and then defaulting to 0 is fine
22:22:01 <monochrom> s/took me/told me/
22:22:03 <tmoertel> SyntaxNinja: I would argue that it is easier because there is rich theory to explain what is going on. OO semantics are evolving and nebulous.
22:22:10 <SamB> I'm not sure whether having your head twisted inside out means that you need to come up with another way of doing it, or if you need to think about it differently...
22:22:15 <Cybertnt> Cale: would that make it increase the efficiency?
22:22:18 <tmoertel> by comparision w/ haskell, that is
22:22:22 <SyntaxNinja> ozone: not sure what you're getting at; crappy code is one thing, but my argument is that the kinds of things we do to improve efficiency or extend Haskell's capability are not "wrong" or "less haskell"
22:22:38 <Cale> Cybertnt: it would probably not be much different with regard to efficiency
22:22:46 <ozone> SyntaxNinja: ah, ok.  now i understand
22:22:46 <SyntaxNinja> I mean, it's really cool that people are working on things like functional reactive programming so that GUIs don't have to be in the IO monad
22:22:52 <Cybertnt> ok, but would be clearer?
22:22:58 <SyntaxNinja> but I don't see anything wrong with GUIs in the IO monad, I guess.
22:23:10 <monochrom> After my friend told me that, I have proof that it is imperative programming that twists kids minds, brainwash them, and deny them of the pleasure of pure functional programming.
22:23:12 <Cale> Cybertnt: Well, it depends on how you want your Turing machines to work
22:23:19 <SamB> the IO monad is not a particularly fun place
22:23:31 <ozone> SyntaxNinja: though i'd argue that half the attractiveness of haskell is that you can express your ideas better than in other languages.  if you start having to write non-straightforward code in the name of e.g. performance, well, there goes half the neatness of it all
22:23:34 <SyntaxNinja> tmoertel: agreed; I think it's just that people are too lazy to learn a new way to think. plenty of people in my college were too lazy to learn to program in the first place, so...
22:23:35 <Cybertnt> Cale: ok, i will consider that
22:23:49 <musasabi> morning
22:24:19 <SyntaxNinja> ozone: yeah, you definitely lose some of the neatness, which is why the FRP work is cool, but then people say "Why not just program in C++"; they throw up their hands.
22:24:34 <ozone> well, for some problem domains, why not indeed
22:24:37 <tmoertel> SyntaxNinja: The STM monad is the perfect example. It costs a little bit to read the STM paper and grok the semantics, but once you do, you can do a whole lot of complex concurrent programming that would absolutely kill you in C++, and you can now do it with ease. Definitely worth the small investment in learning.
22:24:53 <Cale> My friend Adeel who is just beginning to learn Haskell, wnd who hadn't done much programming in imperative programming languages before, mentioned that it seemed as if Haskell related a bit better to how people normally think about problems.
22:24:59 <SyntaxNinja> ozone: because you still have the rest of Haskell, and the non-idiomatic stuff still ends up being just as clean as in C++, IMO.
22:25:11 <SamB> people who say "Why not just program in C++" are in trouble anyway, so...
22:25:16 <SyntaxNinja> SamB: hehe
22:25:37 <Cale> His example was washing dishes: You don't set up a loop counter and number your dishes, you wash all the dishes (map wash dishes)
22:25:49 <ozone> SyntaxNinja: yes and no.  sometimes it does -- but the haskell code is less maintainable than what you would have in C/C++
22:25:53 <ozone> use whatever's appropriate
22:25:54 <SyntaxNinja> Cale: that's a good example.
22:26:03 <SyntaxNinja> ozone: you mean because of the language changing?
22:26:06 <tmoertel> Cale: that's (mapM_ wash dishes)
22:26:17 <Cale> tmoertel: perhaps :)
22:26:18 <tmoertel> :)
22:26:19 <SyntaxNinja> tmoertel: you throw away the resulting dishes? ;)
22:26:42 * SamB bursts into a laughter
22:26:54 <tmoertel> SyntaxNinja: I certainly drain the dish water afterward.
22:26:56 * SamB laughs at his stray "a"
22:26:59 <Cale> SyntaxNinja: after giving up, as things have become so thoroughly encrusted on them that it's hopeless
22:27:18 <SyntaxNinja> tmoertel: fair enough
22:27:19 <monochrom> I had a BBQ example that is similar to this dishwashing example.
22:27:28 <SyntaxNinja> monochrom: let's hear it
22:27:45 <musasabi> btw how does STM behave if some of the peers are badly behaved?
22:27:48 * tmoertel hopes the example involves "liquid smoke"
22:27:48 <ozone> SyntaxNinja: mostly, yes.  hardcore performance is possible in haskell, but (1) you have to really, really know what you are doing, and (2) it sometimes ends up looking like a dog's breakfast.  ("unmaintainable", as i said)
22:28:28 <tmoertel> musasabi: just fine because the type system prevents you from mixing STM and IO operations in the same transaction
22:28:46 <SyntaxNinja> ozone: worse than the C++ code, then?
22:28:54 <ozone> SyntaxNinja: yes, worse than the C++ code
22:28:56 <tmoertel> musasabi: if a peer misbehaves, it must happen outside of an STM transaction; and you can easily catch it and handle as usual.
22:29:14 <SyntaxNinja> ozone: I guess I'll have to take your word for it
22:29:23 <musasabi> tmoertel: So STM is safe for even clients trying to use it an malignous way? (I don't think the paper was very clear on this)
22:29:27 <SamB> C++ code might not look like a dogs breakfast, but it seems to take on a close resemlblance to a labyrinth fairly quickly...
22:29:29 <ozone> SyntaxNinja: look at duncan's example on ghc-bugs posted earlier
22:29:30 <monochrom> A sane person would say "please take all the sausages from the bag the the grill".  A C++ programmer would say for (bag<sausage>::iterator i = b.begin(); i != b.end(); i++) grill.add(*i);
22:29:35 <ozone> what's easier to read: C version or haskell version?
22:30:22 <tmoertel> musasabi: of course, if you have antagonistic participants in an STM action, you can have deadlock, etc.
22:31:02 <monochrom> A C++ programmer doesn't know how to write a specification without also writing an implementation.
22:31:28 <SyntaxNinja> ozone: yeah, the C code is nicer
22:32:00 * SamB likes b do: [ :i | i addTo: grill ]
22:33:55 <musasabi> tmoertel: Isn't deadlocking other processes impossible (if they are not coded in that way) with STM?
22:34:29 <SamB> or maybe b do: [| :i | i addTo: grill ] (Slate version)
22:34:36 <tmoertel> musasabi: no, you can have two processes waiting on ouput from each other but never emitting any output (in fact the paper uses this very example)
22:35:16 <musasabi> tmoertel: yes, they can lock out eachother - but can a rogue process lock out a process which does not really want to be locked out.
22:35:35 <musasabi> tmoertel: think e.g. about an OS interface implemented with STM.
22:36:23 <tmoertel> musasabi: think about the ways one normally deadlocks: some process is waiting on a resource that never becomes available.
22:36:50 <SamB> is that really a deadlock?
22:37:09 <musasabi> tmoertel: that can be prevented, having trusted components never wait for untrusted ones.
22:37:23 <musasabi> tmoertel: but what about e.g. liveness?
22:38:00 <tmoertel> musasabi: i guess it all comes down the protocol between the processes.
22:38:26 <tmoertel> musasabi: if the protocol could be boiled down to a single STM transaction, you might be able to make some stronger claims.
22:38:44 <tmoertel> musasabi: otherwise, I wouldn't feel confident w/out running the protocol thru a model checker.
22:38:52 <musasabi> tmoertel: Does a single STM transaction guarantee liveness?
22:39:03 <musasabi> that is my basic question.
22:39:37 <tmoertel> i didn't see that claim made in the paper
22:40:29 <musasabi> yes.. But that is one of the first things I think about a concurrent system..
22:43:13 <tmoertel> musasabi: STM doesn't prevent you from creating deadlocking, but if you have non-deadlocking systems I believe that you can safely compose them
22:43:35 <tmoertel> musasabi: i.e., if you implement a flawed protocol via STM, you can deadlock the system
22:44:05 <musasabi> yes, but that is a little bit harder than without STM.
22:44:19 <musasabi> that is to deadlock.
22:45:40 <tmoertel> musasabi: I would agree. STM makes it much easier to reason about what is happening and thus to avoid nasty situations.
22:49:35 * tmoertel must go to SleepyTown
22:49:59 <SyntaxNinja> 'night tmoertel
22:51:47 <musasabi> good night
23:15:57 <Cybertnt> Cale: any idea how i could print the pointer with a function but that function must return the tape again...
23:16:49 <Cale> Cybertnt: well, you can't print things using functions. You can only print to the screen inside of an IO action.
23:17:36 <Cybertnt> would that work for me though?
23:18:25 <Cale> Well, why do you need such a function?
23:19:45 <Cybertnt> because i need to read values from the tape
23:20:31 <Cale> do you need them for printing to the screen, or for another reason?
23:20:48 <Cybertnt> just printing them to the screen
23:21:38 <Cale> okay, so I suppose you could make an IO action: printHead :: Tape -> IO (), or even printHead :: Tape -> IO Tape, but nothing which prints something and returns a Tape.
23:22:41 <sylvan> Are you _REALLY_ sure you want to print it to the screen?
23:22:49 <Cybertnt> yes i am really sure
23:23:21 <Cale> all you would do is: printHead (Tape bs p as) = print p
23:23:36 <sylvan> It's one of those things that new Haskell programmers do, they think they want to do lots of I/O intermixed with their code when they really don't... They've been tainted by programming too much C :-)
23:23:50 <ozone> instance Show Tape where show ...
23:23:53 <Cybertnt> Cale: yeah but i need to return the tape to keep the process going
23:24:06 <sylvan> uh-oh...
23:24:11 <Cale> Cybertnt: why, you just passed it to printHead, so presumably you have it
23:24:11 <sylvan> :-)
23:24:25 <Cale> so pass it to the next thing
23:24:32 <Cybertnt> huh?
23:24:50 <Cybertnt> i dont understand
23:25:05 <sylvan> do { yayadaydaya; printHead myTape ; processTape mytape ; yadaydaydaya }
23:25:13 <Cale> well, if you pass a Tape to printHead, it gives you an IO action for printing the head of that tape on the screen
23:25:35 <Cale> you can't actually execute that action
23:25:47 <Cale> the only IO action which executes is main
23:26:14 <Cale> you build main out of things like printHead, the IO primitives, and pure functions
23:26:44 <SamB> zxcxzv
23:26:51 <sylvan> the "program" should be in the pure functions, and only the IO-stuff are IO actions...
23:27:07 <sylvan> So you could write a pure function which returns a list of results or something like that, and then the IO action prints it to the screen
23:27:07 <SamB> oops. I was trying to type into an emulator...
23:27:15 <Cale> SamB: :)
23:27:25 <Cybertnt> sylvan: with your suggested do {} i get an error : ":13 - Type error in final generator"
23:28:02 <Cale> Cybertnt: sylvan pasted some pseudocode there
23:28:04 <sylvan> well that depends on what you do in the IO action, what type it has and so on. The typ of a do-expression is the type of the final action
23:29:27 <Cale> One major difference between Haskell and most other languages is that Haskell keeps things capable of doing (and being influenced by) IO separate from things which don't depend on IO
23:29:33 <Cybertnt> Cale: oh :/ well i recursivly call a function like test and on special occassions test should continue to work recursivly but also print out something. Could that be done?
23:30:06 <sylvan> It could, but it's probably not what  you want :-)
23:30:11 <Cale> Cybertnt: well, you might ask why you'd want to do that, since you're simply recursively defining test -- the calls happen in a random order
23:30:15 <sylvan> it's to "C-ish"
23:30:58 <Cale> If I define a function like square x = x * x, and I do something like square (square x)
23:31:06 <Cale> then it might get evaluated like:
23:31:18 <Cale> (square x) * (square x)
23:31:34 <Cale> = (x * x) * (x * x)
23:31:38 <Cale> or like:
23:31:44 <Cale> square (x * x)
23:31:52 <Cale> = (x * x) * (x * x)
23:32:00 <Cale> in both cases, the result is the same
23:32:12 <Cybertnt> yeah but i start with a list like : test (x : l) = test l and when x matches some integer i want to print something
23:32:14 <Cale> the compiler gets to decide which actually occurs
23:32:47 <Cale> however, if square was permitted to do IO, then the result would be different
23:32:56 <sylvan> do you REALLY want to print it? or do you want to return some result? I mean is WHY do you want to print it? Is it for some debug purpose, or does it have some actual value?
23:33:13 <sylvan> What you _probably_ want is return a list of all values that match some integer...
23:33:18 <sylvan> and then you could print that list
23:33:21 <Gahhh> Cybertnt, you will need to build up a list of things you want to print and print them all at the end of evaluation.
23:33:41 <Cybertnt> sylvan: i am REALLY REALLY REALLY sure that i want to print it
23:33:50 <sylvan> what does the printing represent?
23:33:55 <sylvan> debug info?
23:33:58 <Cybertnt> no
23:34:00 <sylvan> or an actual program result?
23:34:03 <Cybertnt> yes
23:34:06 <Cale> Cybertnt: do you care if they print in any particular order?
23:34:11 <Cybertnt> no
23:34:20 <Cybertnt> i just want them to print :(
23:34:25 <sylvan> then you probably don't want to print it _in_ the function which computes the result, but rather _after_ the result has been computed
23:34:44 <sylvan> In Haskell the presentation of the result needs to be separate from the computation of it
23:34:50 <Cybertnt> sylvan: no, they should be printed out when the value matched, right at that instant
23:35:00 <sylvan> why?
23:35:01 <Cale> Cybertnt: this happens randomly
23:35:13 <Cybertnt> it doesnt matter if it happens randomly
23:35:13 <Cale> The order of evaluation is effectively random
23:35:16 <Cybertnt> sylvan: because
23:35:24 <Gahhh> He may have a requirement to print a match immediately
23:35:39 <Cybertnt> Gahhh: exactly
23:35:51 <sylvan> you can do that, but it's messy and involves writing all your code as an IO action.. I still don't think you really want this, you just think you do :-)
23:36:13 <Cale> Remember that Haskell is lazy though, so you can print the list afterward and each entry won't even be computed at all until you print it.
23:36:19 <sylvan> Gaah: If you generate all matches, and then print them, lazy evalution will make sure it actually gets "matched" right before printing
23:36:25 <sylvan> (internally)
23:36:40 <Cybertnt> sylvan: ok even if you think i dont really want this, could you tell me how to make my code as an IO Action?
23:36:43 <Gahhh> sylvan, there are sometimes the case where you are not allowed to consume input
23:37:19 <Cale> Cybertnt: you can definitely have something like:
23:37:21 <Gahhh> Cybertnt, you would really like reading "Tackling the awkward squad" by Simon Peyton Jones. It gives a nice intro.
23:37:25 <sylvan> sure, something like do { let x = pure value; y <- someIOaction ; etc ; etc; if match then print blah else return () ; some recursion }
23:37:54 <Cale> printHead (Tape bs m as) = do {print m; return (Tape bs m as)}
23:37:59 <sylvan> But it all gets very imperative in flavour, and you really probably don't want that :-)
23:38:04 <Cale> but this will not return the original tape
23:38:13 <sylvan> You should keep presentation separate from computation, that's what makes Haskell cool
23:38:23 <sylvan> (or one of the things that make it cool)
23:38:51 <Cale> the return type is an IO Tape
23:39:29 <Cybertnt> ok
23:40:04 <Cale> and I'll tell you that having it return the input isn't very useful
23:40:46 <Cale> because in order to pass that Tape in, you must already have it, and you didn't need to do any IO to get that new tape (you didn't do anything at all to it), so why bother returning it?
23:40:47 <Gahhh> Cybertnt, read this one for a nice intro: http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/mark.pdf.gz
23:41:07 <Cybertnt> ok
23:41:25 * Gahhh spent the whole day learning how to write COM
23:41:34 * Gahhh would sue if he could
23:42:03 <ozone> in soviet russia, COM writes you
23:42:11 <Gahhh> 1) COM
23:42:15 <Gahhh> 2) Visual Basic
23:42:18 <Gahhh> 3) Excel
23:42:20 <Gahhh> 4) ???
23:42:24 <Gahhh> 5) Profit !!!
23:44:26 <Gahhh> european union passed what ?
23:45:33 <Cybertnt> Cale: ok if i would define Tape like: data Tape = Tape [Integer] Integer [Integer] String deriving Show and then let the relevant classes put their stuff in the String and at the end let it prints out.
23:45:43 <Cybertnt> could that work?
23:46:05 <Cybertnt> s/classes/functions
23:46:07 <Cale> That could work
23:46:11 * Cybertnt coded to much java
23:46:44 <Cale> but I think you can actually get along fine without carrying that along in the Tape type
23:47:05 <Cybertnt> as an extra variable?
23:47:18 <Cale> That's an option
23:47:48 <sylvan> Yeah.. Let the processing function return the string which represents the output... Like if match then "somethihng" ++ process rest else ""
23:48:04 <sylvan> process :: Tape -> String
23:48:25 <pesco> Good morning.
23:48:29 * pesco wakes up.
23:48:41 <Cybertnt> ok
23:48:43 <pesco> (Why do I say good morning before waking up?)
23:49:06 <Cale> pesco: you woke up in your dream, and then in real life
23:49:07 <pesco> Cybertnt: You're building a TM simulator?
23:49:12 <Cale> and then on IRC
23:49:14 <Cybertnt> pesco: yes
23:49:29 <pesco> Cale: You're right.
23:49:33 <pesco> Cybertnt: Fun!
23:49:43 <Gahhh> In my dreams I never wake up. Too much fun.
23:49:46 <Cybertnt> pesco: especially if the evil java has changed your mind
23:50:11 <pesco> Cybertnt: Ew, yes. Java mind-mangle is to be avoided.
23:50:43 <pesco> I was lucky enough to escape any such effects.
23:51:20 <pesco> Because I had enough time to read my Haskell book, carefully getting into the mind-set.
23:51:33 <Cale> Cybertnt: try to forget everything you know about programming when learning Haskell, and you'll have an easier time :)
23:51:40 <Cybertnt> hehe
23:51:46 <pesco> Also I've always been good at "mind-rewrite", I think.
23:51:51 <pesco> Cybertnt: Exactly.
23:52:28 * Cybertnt frees his mind
23:52:55 <pesco> Segfault.
23:53:47 <pesco> Cybertnt: Now carefully reinsert Haskell stuff. :) Congratulations, you're reprogrammed. ;P
23:53:48 <Cybertnt> whats the difference between Integer and Int?
23:53:59 <pesco> Cybertnt: Integer has infinite range.
23:54:07 <pesco> "infinite"
23:54:07 <Cybertnt> and Int?
23:54:18 <pesco> ~30 bits. I forget the number.
23:54:22 <Cybertnt> ok
23:54:56 <Cybertnt> in that case i just need int
23:55:01 <lightstep> it's a machine signed word in ghc
23:55:18 <lightstep> but guarenteed to have at least -2^29..2^29-1
23:55:54 <musasabi> and especially Int != C's int.
23:56:12 <Cybertnt> Cale / sylvan: as a end result i have a ([Char],Tape) but it cant print it out. Does the IO come into play now?
23:56:14 <sylvan> anyone know why they said 2^29 instead of 2^31 which seems more reasonable (32 bits minus sign bit)
23:56:56 <sylvan> yeah, just do something like main = do { let (str,tape) = process newTape ; print str}
23:57:17 <sylvan> why do you need to return the Tape as well as the string, though?
23:57:36 <Gahhh> sylvan, they may be using some bits to mark the thing. I believe O'caml uses one bit to distinguish between ints and pointers, or something like that.
23:57:43 <sylvan> ah
23:57:46 <Cybertnt> sylvan: i want to print the tape to :)
23:57:51 <sylvan> ah okay
23:58:04 <Cybertnt> isnt do some evil c syntax :P ?
23:58:16 <sylvan> well it's definatly imperative in flavour
23:58:36 <sylvan> but you only use it for very limited parts of your program (the only parts that really NEED to be sequenced, in other words IO, mostly)
23:58:48 <sylvan> Haskell - the world's finest imperative programming language
