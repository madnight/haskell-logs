00:26:12 <Mowa> hey google :)  http://www.playzero.com
00:26:41 <Lemmih> Damn spammers /-:
00:34:33 <xerox> :(
00:38:00 <Lemmih> What's up, xerox? Hacking something nifty?
00:39:40 <xerox> I'm reading "The Haskell Road to Logic, Math and Programming" these days.
01:09:37 <Oejet> Good morning.
01:10:59 <Lemmih> Yo Oejet.
01:39:17 <shapr> Man I hate spammers.
01:40:25 <Oejet> shapr: How about trolls?
01:41:15 <shapr> I don't like trolls, but spammers are worse.
01:41:43 <Oejet> Ok.
01:52:02 <shapr> I think it's time to either apply LocalBadContent to the irc logs or kill off the log bots.
01:54:30 <xerox> LocalBadContent, good idea.
01:56:56 <Oejet> What's that?
01:57:32 <Lemmih> List of things which will be blocked from the logs.
01:57:51 <xerox> Let's sed them out ;) (/me awaits for the dons point)
01:59:44 * shapr grins
01:59:47 <Lemmih> shapr: Have you unicycled today?
02:00:14 <shapr> I have unicycled only once in the last nine days. But my cold is mostly gone today.
02:06:49 <shapr> any new goodness in recent Haskell sources?
02:18:48 <skew> shapr: new source?
02:19:59 <shapr> Yeah, I'm always interested in new code.
02:20:23 <skew> well, my binary clock grew a hex display of the time :)
02:20:54 <shapr> Is it a graphical clock?
02:21:08 <skew> yes, I built it with wxHaskell
02:21:32 <xerox> Any screenshot? :)
02:29:46 <skew> I'll put my webserver back up
02:33:51 <shapr> yay
02:35:06 <xerox> ^__^
02:35:41 <skew> okay, kill -s HUP is not how to tell X you changed hostname
02:36:10 <shapr> Probably works though.
02:36:20 <shapr> it was over kill.
02:36:37 <skew> Well, it worked once I ran a new X server :)
02:37:11 <shapr> I wonder if the kill -N values are ascending? If so, too large values would obviously be overkill.
02:39:27 <xerox> ETOOHIGHSIG
02:41:45 <shapr> greetings astrolabe.
02:42:04 <astrolabe> Hi shapr
02:42:05 <shapr> Do cosmologists have one part of their brain named an astrolobe?
02:42:27 <shapr> I wish I could write Haskell code for Zope/Plone. Would be so much nicer.
02:42:51 <astrolabe> As far as I'm aware, no.  But I've never looked.
02:42:51 <shapr> Cale`: I'm still cogitating upon your idea about lazy evaluation.
02:43:10 <shapr> astrolabe: how's code?
02:43:13 <skew> shapr: why can't you?
02:43:47 <astrolabe> I'm very much a beginner with haskell.  Code is buggy.
02:43:57 <shapr> My clients probably wouldn't go for it.
02:44:33 <skew> have you tried writing Haskell to work with zope?
02:44:58 <shapr> I've written XmlRpc code in Haskell that works with Zope.
02:45:11 <shapr> skew: btw, your Haskell dir is 403
02:45:22 <shapr> But your cooling setup is still visible.
02:45:24 <skew> Sounds like I should get back to working on PHI
02:45:39 <skew> I'm in the process of making sure everything is good
02:45:40 <shapr> Alternatively, a Zope rewrite in Haskell might be better.
02:45:52 <shapr> musasabi wrote SerTH, which is one step in that direction.
02:47:02 <skew> hmm.
02:47:14 <skew> the permissions look good
02:47:54 <xerox> I think I missed the url.
02:47:55 <shapr> Darius said that web app servers look like two pieces to him, control flow and persistence.
02:48:35 <shapr> ZODB lets your code pretend that the zope application never exits.
02:48:50 <shapr> Much like Smalltalk.
02:49:07 <shapr> workflow is the closest thing Zope has to control flow abstraction.
02:49:25 <shapr> Well, there's also post and pre hooks.
02:50:19 <astrolabe> It would be nice to have a haskell debugger
02:50:34 <basti_> hi
02:50:38 <shapr> Have you tried using HUnit?
02:50:51 <skew> astrolabe: what do you see the debugger doing?
02:52:08 <astrolabe> Good question skew.  But the interpreter must be doing something to get its crazy ideas about what I want.  I would like to see what.
02:52:24 <skew> The standard "set a breakpoint, inspect local variables" type of debugger doesn't map too well
02:52:44 <skew> It might be useful to have something like that for debugging code in IO, I suppose
02:52:46 <astrolabe> I haven't shapr, thanks.  I'll look.
02:53:05 <shapr> HUnit isn't a debugger, it's a unit testing module.
02:53:44 <skew> simply loading your code into the interpreter can be useful too
02:54:03 <astrolabe> I guess haskell performs a sequence of transformations on a statement.  Couldn't they be stepped through?
02:54:05 <skew> At least, that's what I usually do.
02:54:23 <shapr> astrolabe: do you know about call-by-name evaluation?
02:54:28 <skew> Does Vital do something like that?
02:54:38 <astrolabe> I don't think so shapr
02:55:49 <shapr> astrolabe: in most languages [1/0,2] !! 1 would always throw an error
02:56:27 <shapr> But in Haskell, it works just fine.
02:56:47 <astrolabe> Ah, is that the lazy thing?
02:56:57 <xerox> Yes, who need to calculate (/0)?
02:56:58 <xerox> ;)
02:57:51 <xerox> skew: did you fix the httpd think?
02:58:01 <skew> I'm reading about apache permission stuff
02:58:37 <astrolabe> skews me everyone.  I've got to go and try to buy a car.
02:58:48 <shapr> Cars are fun!
03:02:16 <shapr> skew: can I use iterators and generators to beat the recursion limit? Can I use them to replace lambda by generating anonymous functions?
03:03:24 <Lemmih> shapr: You really think cars are fun?
03:03:32 <shapr> They're fun to drive.
03:05:16 <tuomov> cars are trouble
03:05:25 <shapr> I have some ideas for improving cars.
03:06:48 <Lemmih> Not using them would be a major improvement, IMHO.
03:46:26 <skew> okay, I've changed the permissions around.
03:46:43 <skew> http://page-148.caltech.edu/~brandon/clock.html
03:48:56 <skew> shapr: I bet you could do something tricky with metaclasses so you could write an expression that would evaluate to a function
03:50:02 <shapr> interesting thought
03:54:12 <Philippa> but not unakin to hacking up HOFs with templates in C++
03:54:21 * shapr has an idea for an incremental drink lid
03:54:41 <skew> more like the anonymous subclass stuff in java
03:54:48 <skew> but class definitions are not expressions
04:01:34 <skew> shapr: def execstr(str): exec str; return x
04:01:58 <skew> shapr: execstr('def f(x,y) return x+y\nx=f')
04:04:41 <skew> or even def lmbda(str): exec 'def f'+str; return f
04:04:55 <skew> lmbda('(x,y): return x+y')(2,3) => 5
04:06:25 <skew> shapr: what does an incremental drink lid do?
04:22:07 <bourbaki> moin
04:23:30 <skew> hello?
04:23:45 <xerox> skew: ahah, lmbda is nice :)
04:24:20 <skew> I was just thinking, if you memoize it the performance may even be acceptable
04:24:34 <xerox> skew: write it down ^__^
04:29:20 * Oejet curses Haskells global record accessors.
04:30:13 <skew> Oejet: what is wrong with them?
04:30:33 <Oejet> skew: They are global
04:30:59 <skew> they have the same scope as everything else, I think
04:31:19 <skew> I mean, types, constructors, classes, etc. Anything at the top level
04:32:00 <xerox> skew: it isn't possible to use "if" inside lmbda, right?
04:32:50 <skew> xerox: I think it should work
04:33:25 <xerox> skew: mmh, how?
04:36:43 <skew> lmbda('(x):\n if x == 3: return "three"\n else: return "not three"')(4) => 'not three'
04:36:43 <skew> that may be clearer with the ''' strings
04:37:02 <skew> xerox: how what? I just gave working code
04:37:46 <xerox> There is some lag, I asked "how" before seeing your code, obviously :)
04:38:08 <skew> wow, that's a lot of lag
04:40:02 <Igloo> 3 mins worth according to my timestamps
04:40:16 <skew> 4 by mine
04:40:36 <xerox> 4 to me too.
04:40:51 <xerox> Something happened in the universe?
04:42:38 <skew> it's pretty annoying that Python just has layout
04:42:50 <xerox> It has.
04:42:57 <xerox> err, it is
04:43:45 <Oejet> skew: Why?
04:45:33 <Oejet> skew: Na, just kidding.
04:46:05 <skew> you can't cram a bunch of code onto one line with only layout
04:51:09 <skew> shapr: how do you like my lmbda?
04:57:46 <shapr> skew: an incremental drink lid would mean that only a tiny amount of liquid could spill out of a liquid container.
04:58:47 <shapr> Since my original inspiration I realized I'm talking about an artificial pomegranate structure.
04:59:05 <skew> shapr: only a tiny bit at a time, at least
05:00:46 <shapr> Since I'd want to drink out of the container without manually opening each separate section, I thought of a coke can with plastic-covered holes in the sides. The external holes have stretchier plastic than the internal partitions, so creating negative pressure on the top of the can should pop open the sections
05:01:06 <shapr> Is that understandable at all? :-)
05:01:15 <skew> how does the pomegranate come in? Drinkin pomergranate juice from a pomegranate is pretty annoying
05:01:49 <shapr> Right, so how to design a better pomegranate? Allow the user to create negative pressure like sucking on a sports bottle, and that opens another partition.
05:01:51 <skew> Oh, I was expecting a reusable container
05:02:06 <skew> sounds like it might work
05:02:07 <shapr> So was I at first, but I couldn't figure out a way to make it totally worry-free.
05:02:42 <shapr> Once I thought about the pomegranate similarity, I figured I'd sell it to the Coke-a-Cola company with a spherical design, call it a Coke-a-Nut =)
05:03:05 <autrijus> hi shapr!
05:03:10 * autrijus is on 4th day of ritalin
05:03:16 <shapr> Not that it would actually work with pressurized liquids.
05:03:20 <shapr> autrijus: and? what do you think?
05:03:26 <autrijus> shapr: I took 5mg, 5mg, 10mg, 5mg
05:03:35 <shapr> Sounds good. What's your body weight?
05:03:41 <autrijus> 75 kg
05:03:44 <autrijus> 180cm
05:03:57 <shapr> Sounds just fine to me.
05:04:01 <autrijus> *nod*
05:04:08 <shapr> What do you think so far? Does it make it easier to do stuff you don't want to do?
05:04:13 <autrijus> a bit.
05:04:17 <autrijus> well, not really.
05:04:20 <autrijus> but it makes me calm :)
05:04:22 <shapr> heh
05:04:25 * Lemmih wonders if you need ritalout to get off the drug.
05:04:50 <skew> hmm, I also dislike doing stuf I don't want to do.
05:05:01 <shapr> skew: so much that you lose your job over it?
05:05:16 <skew> I don't know, I've never had a job
05:05:28 <shapr> blackdog: yow!
05:05:52 <tuomov> hmm..
05:06:04 <tuomov> I dislike doing stuff I don't like so much that I lost my job :)
05:06:12 <shapr> tuomov: sounds familiar.
05:06:24 <skew> I was not being entirely facetious
05:06:39 <shapr> But I would recommend that anyone who suspects they have ADD and ADHD should talk to a licensed psychiatrist.
05:06:53 <shapr> Best would be an ADD specialist, like the one I went to in Birmingham.
05:07:32 <shapr> For once I got a high score on a test =) 94% chance of ADHD according to the computer test, and 96% according to the interview.
05:08:25 <tuomov> I can concentrate on doing things I like just fine, though
05:08:36 <tuomov> I just won't even start doing stuff that I hate
05:08:39 <shapr> Yeah, that's part of it. Especially concentrating for 36 hours in a row.
05:09:01 <skew> but your phrasing was a bit funny
05:09:06 <shapr> My friend and I used to play the alpha release of Quake from Friday night to Monday morning, and then go to work.
05:09:20 <skew> I know the feeling
05:09:44 <tuomov> and, well, I can do stuff that I hate if I decide that it needs to be done myself
05:09:53 <tuomov> but I hate being bossed into doing shit
05:09:54 <shapr> tuomov: yes, that also sounds familiar.
05:10:07 <skew> I get things done by last minute desperation
05:10:20 <Philippa> AOL the lot of that...
05:10:36 <integral> hrm, AOL too :-/
05:10:41 <skew> AOL?
05:10:41 <shapr> Part of ADD is poor I/O, which means that it's easy to adjust if you're the person organizing, because it all happens in your head, but it's difficult to adjust if someone else is telling you what to do, and not why.
05:11:01 <Philippa> skew: "me too"
05:11:05 <integral> skew: AOL = me too; AOLers like posting just that on its own
05:11:21 <skew> So it is related to the nice people that mail out frisbees
05:11:27 <Philippa> nearly - they traditionally quote all 200 lines of the original post as well
05:11:34 <skew> and coasters, and microwave test targets
05:12:08 <astrolabe> Birmingham, England?
05:12:09 <shapr> Speaking of which, I've been reading about microwave metal casting recently.
05:12:14 <shapr> astrolabe: Alabama
05:12:27 <astrolabe> Ah :)  Not so close then
05:12:33 <shapr> Though I'm about 10,000km from there at the moment, I'm in Sweden now.
05:12:38 <skew> what brought you to Alabama?
05:12:45 <shapr> I was born there.
05:12:55 <skew> so this was before moving to Sweden
05:12:59 <shapr> Yup.
05:13:42 <shapr> Did you know that household microwaves can be used to cast iron? They also can be used to make nice EMP bombs.
05:14:17 * shapr nominates household microwaves for the 'Most Versatile Household Appliance' award of 2005
05:14:49 <shapr> autrijus: In my experience, Ritalin lets me build better habits.
05:15:33 <shapr> I'd like to hear your thoughts on good and bad points of Ritalin, when you have some.
05:16:08 <blackdog> shapr: hey there. fyi: xemacs + MacOS X + CEDET == pain
05:16:24 <shapr> Before Vitamin R, I drank extremely large amounts of caffeine via Mountain Dew, Jolt, etc
05:16:34 <shapr> blackdog: which parts of CEDET?
05:16:41 <blackdog> semantic bovinator.
05:16:42 <shapr> Truly, CEDET is flaky.
05:16:46 <Philippa> BTDT, eventually decided caffeine tends to cause me too many problems
05:16:56 <Philippa> so I have a minor binge once in a while and drink coke in restaurants
05:17:07 <shapr> Yeah, semantic is the best bit of cedet, and it's too bad they haven't made it nice and shiny.
05:17:13 <astrolabe> What happens if you don't get caffine?
05:17:27 <shapr> astrolabe: I am immensely fun at parties.
05:17:48 <Philippa> me? Not a lot now. I've been addicted to the point of headaches and constant drowsiness before though (it may not've helped that I wasn't getting enough sleep /anyway/, mind)
05:17:48 <blackdog> it's frustrating. i want an open development environment so i can hack it the way i want it, but at the same time, it shouldn't be quite this hard to get going.
05:18:07 <shapr> Yi is getting closer.
05:18:36 <blackdog> Is it? Last time I talked to Don, he said Chak had forbidden him from working on it until he'd finished his paper. :)
05:18:45 <blackdog> No hacking for you till you've written some greek!
05:18:46 <astrolabe> Sounds a bit like me, but  I suspect I might just be a slacker
05:18:48 <shapr> Jump in, start hacking :-)
05:19:12 <shapr> astrolabe: There's this great book about ADD that's called "You mean I'm not Lazy, Crazy, or Stupid?"
05:19:32 <skew> Lazy like Haskell!
05:19:42 <blackdog> crazy like perl
05:19:44 <Philippa> Stupid like, um...
05:19:50 <shapr> Of course, I have two copies of that book because I forgot I had the first one :-/
05:19:57 <astrolabe> LOL
05:20:23 <astrolabe> Stupid like Matlab.  That drives me up the wall.
05:20:47 <blackdog> shapr: got enough private projects at the moment. I just want a niceish environment to do paying work in - editing perfection can wait for a little bit.
05:22:02 <tuomov> I rather live on unemployment benefits than doing shit work..
05:22:45 <shapr> I want something open that has all the good points of semantic. I think Yi and Eclipse are possibilities for that outside of emacs.
05:22:53 <blackdog> australians who live on unemployment benefits tend to end up getting dragged over the coals on current affair shows.
05:23:04 <Philippa> that's true in a lot of places
05:23:14 <Philippa> dunno what it's like in australia, but here they amount to poverty
05:23:25 <shapr> tuomov: One thing that's different about ADD (afaik) is that frustration is terminally painful.
05:23:29 <tuomov> I still got over a year left of earnings-related u.e. benefits. that's quite good money
05:23:38 <shapr> I don't think that's true for most people. I think most people just keep going.
05:23:42 <Philippa> shapr: very literally? Certainly it affects me a lot
05:24:11 <blackdog> shapr: I found eclipse a bit painful to use - slow and generally clunky. subjective, i know.
05:24:11 <Philippa> I mean, it sorta depends, but there's a reason I really don't get much done in more verbose languages
05:24:17 <Philippa> too easy to frustrate myself over something
05:24:21 <shapr> blackdog: I felt that myself, and I don't like Java.
05:24:32 <Philippa> ("this should be f*cking easy, it's taking ages!")
05:24:46 <shapr> Yeah, I have that same feeling, that's why Python irritates me so much.
05:24:58 <shapr> Once I know a better way to do something, I want to use it.
05:25:05 <tuomov> if I just enrolled as a (grad) student -- which is what I eventually want to do -- my income would drop to third..
05:25:38 <tuomov> even normal (not earnings-related) unemployment benefits are about half more than study benefits..
05:25:38 <shapr> On the other hand, doing something frustrating in a pair with someone else is *much* easier for me.
05:26:10 <shapr> And the other person tends to refocus me when I start staring out the window or reading slashdot.
05:26:27 <blackdog> you've got somebody to bitch to about how much your editor/language/coffee sucks?
05:26:35 <shapr> yeah, that too.
05:27:06 <Philippa> shapr: I don't even have to know a better way, just know that I can picture the system in a simpler manner as it were
05:27:24 <Philippa> 'sone of the reasons I picked up parsec and ran with it so quickly
05:28:15 <shapr> speaking of ADD, I should be working now...
05:28:22 <skew> hmm, how should I handle 'return' in a C interpreter. I want to use StateT Env IO as my monad
05:28:33 <shapr> I'll bbl
05:28:53 <Philippa> skew: the obvious way. It's what the computation returns
05:29:39 <skew> It sounds like I need to change the monad somehow
05:29:53 <skew> maybe use ErrorT and raise the result
05:29:58 <Philippa> um, why?
05:30:32 <skew> I'm trying to build the interpreter from eval :: Expr -> CMonad Value, exec :: Stmt -> CMonad ????
05:30:51 <Philippa> Value again. Sometimes the value's ()
05:31:22 <skew> still, that's not exactly what I wat
05:31:24 <Philippa> alternatively, exec just calls the next statement in line when it's not a return, and if there isn't one does whatever the C standard defines for no return
05:31:30 <Philippa> why not?
05:32:08 <skew> I want sequencing together the interpretation of statements to give the same result as interpreting a sequence of statements
05:33:23 <skew> if "return X" just goes to (return <value of X>), then interpret "return X; return Y" will be different from interpret "return X" >> interpret "return Y"
05:34:42 <skew> (That's your cue to say "Oh, good point. You can just <elegant solution>")
05:34:43 <Philippa> you have to interpret block-statements rather than statements in general then
05:34:54 <skew> hmm
05:36:15 <skew> besides breaking the symmetry, it seems like the only way of doing that is evaluating all the statements and checking if they've returned something
05:36:26 <skew> and then grabbing the first thing returned
05:36:37 <skew> To me, that sounds like doing the plumbing of ErrorT by hand
05:37:05 <skew> I guess ErrorT isn't that bad
05:37:16 <Philippa> getting on for it. Myself I'd ditch the interpret "return X; return Y;" = interpret "return X" >> interpret "return Y" formula
05:37:53 <skew> Using ErrorT keeps that formula too
05:37:57 <Philippa> it seems to me that the latter probably /should/ return from two functions in a row
05:38:06 <Philippa> yes, I know
05:38:29 <Philippa> the stack representation starts to get messy though
05:38:48 <skew> how is that?
05:39:12 <skew> I'll be using runErrorT at each function call
05:39:18 <Philippa> exactly
05:40:07 <skew> That could easily be turned into a combinator "functionCall :: ErrorT e m () -> ErrorT _ m e"
05:40:33 <skew> well, I also need to cons on a fresh stack frame
05:41:16 <Philippa> yeah. It depends on whether you want return itself to remove the stack frame or the caller to do it
05:42:12 <skew> Well, the code for interpreting an application already needs to delimit the scope of the return
05:42:45 <skew> You can think of the code as belonging to the caller or the callee, but it's really the code for interpreting an application
06:13:30 <Philippa> thinking about it, one reason not to ErrorT is that you'll effectively pattern-match twice
06:13:39 <Philippa> you know to stop executing statements when you hit a return
06:14:17 <Philippa> and it's not really any more code than putting the return-returns branch in for return and calling exec on the next statement for everything else
06:15:02 <skew> isn't that exactly the work the error monad encapsulates?
06:15:11 <skew> I don't understand what you mean about pattern matching twice
06:15:25 <Philippa> to return, you're going to have to recognise that it was a return statement either way
06:15:40 <Philippa> to return via ErrorT, you /then/ chuck the error and the transformer does another pattern-match to recognise that
06:16:09 <skew> but I need to check something to catch a return in a nested statement in any case
06:17:12 <Philippa> could do. Or you could un-nest them by putting a pseudo-goto at the end of the nested bits
06:17:43 <Philippa> works well if you're working with a complex data structure rather than a list of statements
06:18:14 <Philippa> everything gets a 'next' pointer still, but eg the last in the block of a for loop goes back to the for (which checks and terminates or otherwise as appropriate)
06:19:22 <Philippa> you preprocess the code a bit more, but it executes faster
07:50:08 <RemiTurk> hello
07:50:26 <Lemmih> Hallo.
07:53:40 <_metaperl> @seen Darius
07:53:41 <lambdabot> I saw Darius leaving #haskell 11 hours 44 minutes 47 seconds ago.
07:59:14 * RemiTurk is having ghci :info instance showing trouble again
07:59:56 <RemiTurk> could someone verify for me that the Functor instance for (r->) isn't shown by ghci?
08:00:03 <RemiTurk> (after :m +Control.Monad.Reader)
08:41:58 <TheHunter> RemiTurk, confirmed :)
08:49:49 <Oejet> Greetings, JHGHGkljhskdfgsd.
08:52:41 <Heffalump> did you tab complete that?
09:04:45 <Oejet> Heffalump: What is tab completion?
09:04:52 <Oejet> Heffalump: :-P
09:06:12 <Heffalump> khah
09:06:14 <Heffalump> s/k//
09:07:18 <Oejet> Somehow I didn't expect him to commence in an interlectual conversation with me.
09:08:02 <Heffalump> interlectual, eh? :-)
09:09:35 <Lemmih> Is that a joke on internet or a misspelling?
09:10:51 <Lemmih> 'unexpected "$" \n expecting ">" or "$"'
09:18:17 <Lemmih> @seen SyntaxNinja
09:18:17 <lambdabot> I haven't seen SyntaxNinja
09:23:11 <Oejet> Heffalump: ...*cough* "intellectual".  Sorry. :-)
09:24:15 <Heffalump> :-)
09:24:59 <Oejet> Oejet: <-- is not shining today.
09:25:26 <Oejet> Doh.
09:25:30 <Oejet> Sigh.
09:30:20 <_metaperl> does ghc ship with fedora 2?
09:47:21 <RemiTurk> TheHunter: thanks, I guess that'll mean yet another ghci :info bug report romorrow ;)
09:47:21 <Philippa> _metaperl: you happy you've learnt all you can from my little toy app now? :-)
09:47:30 * RemiTurk has another one in the queue too
09:49:09 <Philippa> (just dug through the logs, guess I'm not too surprised it was a laziness thing)
09:51:25 <Philippa> (being dragged next door - will prolly be away a fair while, the new Doctor Who's on in an hour here)
09:52:15 * Heffalump is watching the stuff about the previous Doctors
09:57:56 <Igloo> Is it an international thing or is most of the channel lost?
09:58:40 * Igloo is curious to see how Stephen Fry will do on Millionaire, too
09:59:10 * kosmikus isn't ...
10:00:31 <Heffalump> Millionaire?
10:00:46 <Igloo> "Who Wants to Be a Millionaire?"
10:00:56 <Igloo> kosmikus: isn't lost?
10:02:04 <kosmikus> isn't curious
10:02:12 <kosmikus> but isn't lost either, I hope
10:02:18 <kosmikus> lost case, perhaps
10:38:48 <skew> @seen shapr
10:38:49 <lambdabot> I saw shapr leaving #haskell.se 5 hours 10 minutes 13 seconds ago.
10:43:56 <Oejet> Yay, Denmark - Kazakstan begins in a moment.   Huhuhu-Ååååå.  \o/
10:44:39 <Heffalump> bah, bloody Unicode
10:44:50 <basti_> þłð
10:47:49 <basti_> theres no alternative to unicode, since it's the only system that tries to integrate all known fonts
10:48:05 <basti_> or, character sets
10:48:06 <Oejet> Heffalump: Are you refering to me?
10:48:23 <Heffalump> yes.
10:49:20 <Oejet> ÆØÅæøå
10:49:38 <Oejet> Heffalump: Sorry.
10:50:37 <Heffalump> it's illegible :-)
10:50:39 <basti_> äöüÄÖÜß
10:50:52 <Heffalump> I guess I probably should just upgrade my client setup, it is the only thing that really makes sense.
10:54:35 <astrolabe> @seen lambdabot
10:54:36 <lambdabot> Yes, I'm here
11:09:50 <musasabi> basti_: unicode is not without problems.
11:09:56 <musasabi> basti_: e.g. han-unification.
11:10:21 <musasabi> not to say iso-2022 would be simple and working.
11:11:59 <tuomov> unicode is too complex with multiple ways to present a single character and so on
11:12:12 <tuomov> utf-8 is a nice encoding of it, however
11:12:16 <Gahhh> how did we manage to botch that up in this day and age ?
11:13:18 <Darius> ha ha
11:13:44 <Darius> Gahhh: We drew upon are vast experience of botching things up.
11:14:04 <Gahhh> standing on the shoulders of giants eh
11:14:42 <basti_> musasabi: han unification?!
11:14:58 <Darius> Gahhh: 'need that extra height so we can fall farther!
11:22:49 * basti_ is happy that his character set is so simple.
11:24:34 * Darius is happy that his country "invented" the Internet leading to a massive bias towards his character set.
11:25:11 <Gahhh> Gore invented the Internet, not your country.
11:25:42 <basti_> but you must admit that < 300 characters is a good thing to have when it comes to implementation
11:27:08 <Darius> Yes, the fact that the English alphabet is simple and, even before the Internet, widespread is also a contributing factor.
11:27:59 <basti_> yup
11:40:38 <_metaperl> Philipa, I got your comment. I am still plugging away at your program
11:41:02 <_metaperl> you might want to abstract the multiple uses of ".siggen" into a variable
11:49:45 <musasabi> basti_: cjk issues.
11:54:06 <tuomov> english alphabet doesn't contain all the sounds in the language..
11:55:11 <Philippa_> metaperl: it was a quickie hack, I would've done otherwise but when there're only two occurances it's slower to bind it separately
11:55:22 <Philippa_> in terms of development time, that is
11:55:30 <metaperl> ah
11:55:59 <Philippa_> I mean, it's the sort of thing people'd more normally write in perl
11:56:35 <Philippa_> though I did make some more general effort towards readability (eg the default could've been defined Config "" "")
11:56:55 <tuomov> infact, latin-1 doesn't contain all the characters/sounds that can be found in finnish loan words these days
11:57:39 <tuomov> "chess" should be written "[s with a v on top of it]akki".. used to be written with sh
11:59:08 <Darius> tuomov: I'm not getting your point
12:00:15 <tuomov> point is that ascii is not enough for representing all the sounds in languages with phonetic writing, and even latin-1 is insufficient with some of the languages that it was meant for
12:00:45 <Philippa_> with a side-order of IRC being a finnish invention
12:02:10 <tuomov> s with a upside-down hat can probably be found in some other character set in the iso8859-1 family
12:02:54 <tuomov> but that one is probably missing the a and o with two dots and a with ring (öäå) that appear in native finnish words and (the last) in names of swedish origin
12:03:03 <tuomov> s/-1/-*/
12:06:13 <tuomov> http://en.wikipedia.org/wiki/International_Phonetic_Alphabet
12:06:41 <tuomov> make a character set with all that information and then you can start asking people to dump other special characters
12:08:01 <Gahhh> in year 2100 maybe, right after the US switches to the SI system.
12:08:15 <alex-a> Hello
12:09:00 <alex-a> Is there a program (like indent) that allows to correctly indent files (in batch mode)?
12:15:13 <Darius> Presumably, you mean Haskell files.
12:21:48 <Darius> heya shapr
12:22:07 <shapr> hiya Darius, what's up?
12:22:54 <skew> hi shapr. How did you like my lambda?
12:23:16 * shapr checks
12:23:20 <Darius> shapr: Reading the papers the Wobbly types paper references
12:23:31 <alex-a> Darius: yes, haskell source code
12:24:20 <shapr> skew: it's cute.
12:25:13 <shapr> I've realized that Fermat's Last Margin would be a better discussion medium than LtU
12:25:36 <Darius> alex-a:  You can check the libraries and tools page.  Alternatively, you could run it through vim in a script.
12:25:50 * shapr kicks liferea
12:26:04 <shapr> Liferea crashes way too often. I want a better RSS aggregator.
12:26:07 <Darius> Though from what I hear/experience, not too many editors do a wonderful job indenting Haskell correctly.
12:26:48 <alex-a> I had problems with haskell-mode doing indenting, hence the question.
12:27:03 <alex-a> ok, I'll check it
12:27:55 <Darius> alex-a: I don't know if something is there that does what you want, but if there is it should be there for some value of "should".
12:28:37 <Philippa_> defining 'what you want' isn't easy though
12:29:05 <Philippa_> I mean, I really don't like 2-char-per-indent or similar code in Haskell
12:30:00 <alex-a> correctly indenting source code with messed up indentation, so it would compile
12:30:03 <Darius> alex-a: Doing 'pprint . parse' may produce reasonable results if the code is very messed up.
12:30:34 <Lemmih> Yihaa. Hackage/cabal-get is picking up speed.
12:30:47 <alex-a> ok
12:31:41 <Darius> Well, if it doesn't parse, parsing it probably won't work, so that'd be a problem.  But if you only need it to parse, then less than ideal indentation engines may work.
12:32:14 <Philippa_> alex-a: the problem there is that there're probably situations where there're two or more correct ways to indent
12:32:18 <kosmikus> alex-a: if the code doesn't even compile right now, then it needs human intervention anyway, because it can be highly ambiguous what's actually meant
12:32:52 <Philippa_> what would be useful is a "de-layoutifier" that put in the braces and semicolons for you
12:33:13 <alex-a> ok
12:33:24 <Philippa_> that way you could check you're writing what you mean (and for something like the VS.net/haskell stuff, it'd be nice to have that on-the-fly in the IDE much like syntax highlighting)
12:35:20 <alex-a> I see
12:37:14 <alex-a> thank you
12:39:06 <Philippa_> you might find that reading the bit of the haskell report that defines layout helps
12:39:21 <Philippa_> as in the absence of a de-layoutifier you can always work it out by hand or in your head
12:39:59 <skew> reading that bit of the report two or three times might help, at least
12:42:18 <TNKS> hey guys, can you enter type statements into the interactive GHC interpreter (ghci)?
12:42:40 <xerox> TNKS: yep
12:42:57 <Darius> You can use :type and :kind, but you can't type a type declaration in or any declarations for that matter.
12:43:16 <Darius> @type \x xs c n -> c x (xs c n)
12:43:17 <lambdabot> \x xs c n -> c x (xs c n) :: forall t t1 t2 t3.
12:43:17 <lambdabot> 			     t -> ((t -> t1 -> t2) -> t3 -> t1) -> (t -> t1 -> t2) -> t3 -> t2
12:43:18 <xerox> Darius: I thought it was possible, in the form expression :: type
12:43:36 <Darius> xerox: A type annotated expression is still an expression.
12:44:01 <TNKS> okay, so the consensus is that I need to put all my type statements in a script?
12:44:04 <xerox> Maybe it's what he was asking for.
12:44:40 <xerox> TNKS: It's a good practice, not strictly needed, except in some cases.
12:44:50 <Darius> TNKS: If by "type statement" you mean things like, 'type Foo = Int; data Bar = Baz' then yes, it needs to be in a source file.
12:45:03 <skew> TNKS: "type statement" isn't a standard term
12:45:06 <TNKS> Darius, okay, that's what I was talking about.
12:45:33 * xerox shuts up, sorry.
12:46:13 <skew> the report calls that those type declarations
12:48:17 <TNKS> here's another question.  type declarations can't be self-referential, can they?
12:48:33 <_JusSx__> yes they can
12:48:38 <KrispyKringle> you can have recursive type defs
12:48:48 <KrispyKringle> for instance, list is recursive, i believe.
12:48:54 <skew> type declarations like type X =
12:49:08 <skew> like type Foo = [(Int,Bool)} cannot be self referential
12:49:13 <Darius> 'type' statements can't because they are implemented conceptually by syntactic expansion, but other forms can.
12:49:14 <_JusSx__> data Tree a = (a, Tree a, Tree a)
12:49:51 <xerox> You're missing a Data Constructor there, I think.
12:49:52 <TNKS> yeah, I guess that's what I'm driving at, that "type" can't be recursive, but "data" can.
12:49:56 <KrispyKringle> yeah, that's right. sorry.
12:50:05 <KrispyKringle> data declarations can be recursive.
12:50:09 <KrispyKringle> i didn't know about type definitions.
12:50:17 * KrispyKringle goes back to not paying attention. 
12:50:23 <_JusSx__> type is for synon
12:50:30 <skew> A data type declaration like data Tree a = Leaf | Branch a (Tree a) (Tree a) can be recursive
12:50:37 <_JusSx__> data for creating new datatypes
12:50:59 <TNKS> well, I'm getting an error in ghci when I try to recurse a type declaration, so I think I'm straight on this point now.
12:51:01 <TNKS> thanks.
12:51:11 <skew> Although it can be fun to open up the recursion like TreeF a t = Leaf | Branch a t t so you have the base functor around.
12:51:17 <KrispyKringle> _JusSx__: ah, right. of course :P
13:04:14 <shapr> TheHunter: hey, have you looked at QuickCheckM anymore? I wonder if the imperative function is just one instance for ST, and whether one could exist for IO
13:13:09 <TheHunter> `imperative' relies on the fact that there is a way from ST back to pure code. (iirc, it is there because hugs doesn't like monadic runST)
13:14:57 <TheHunter> a clean solution would need to rewrite quite a few functions.
13:19:49 <shapr> "Finally, we can convert monadic properties back to ordinary ones, given a "run function" for the underlying monad, " :-/
13:22:06 <Philippa_> =unsafePerformIO, duh
13:22:33 <shapr> I'd rather find a clean way to do it.
13:22:38 <rik> hello.
13:22:47 <shapr> hi rik
13:22:53 <rik> hi shapr! long time, etc.
13:22:57 <shapr> How's life in the big city?
13:23:06 <rik> i dunno, i live in a small city.
13:23:20 <rik> but it's a small city where they pay me money to work, so that's good.
13:23:26 <shapr> That is good, I agree.
13:23:46 <rik> i've decided that i want to learn haskell properly.
13:24:01 <rik> functional programming has made sense to me, since people stopped trying to teach it to me
13:24:23 <Philippa_> heh
13:24:29 <rik> so, i need to get started with Hugs, and see how often people are alive, and to leap in feet first, to learn by doing.
13:24:34 <shapr> rik: welcome aboard!
13:24:51 <shapr> Get GHC, we're often alive, and yes.
13:24:57 <rik> it's all the python. i realised i was using map and filter and lambda more than anything else
13:25:06 <rik> i used hugs at university
13:25:13 <shapr> GHC will help you learn faster.
13:25:17 <rik> okay
13:25:23 <rik> is there a windows port?
13:25:31 <shapr> Yes
13:25:55 <shapr> http://www.haskell.org/ghc/download_ghc_64.html#windows
13:26:20 <rik> i am downloading.
13:26:21 <TheHunter> "class TestableM m where propertyM :: a -> PropertyM m b", "checkIO :: Testable IO a => Config -> a -> IO ()"
13:26:26 <TheHunter> but it's quite a bit of work.
13:26:29 <shapr> rik: how much FP background do you have?
13:27:08 <shapr> TheHunter: It's worth it to me, I think.
13:27:11 * shapr starts hacking
13:27:14 <rik> they rtied to teach me for a year. some things stuck, but largely nohting made sense at the time. since then, i've been pythoning a lot, and have found myself reducing everything to lists.
13:27:27 <Heffalump> what university was this, OOI?
13:27:35 <rik> cs.bristol.ac.uk
13:28:00 <Heffalump> ah, we get people from there on here occasionally
13:28:06 * rik nods
13:28:40 <rik> i probably know a little more than i thnk, but i couldn't tel lyou how much.
13:28:46 <shapr> @wiki HaskellDemo
13:28:46 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
13:28:51 <Heffalump> how long ago did you use hugs before?
13:29:03 <rik> someone once said to me that it's not worth learning a language unless it changes the way you think about programming. i think it's that time.
13:29:03 <shapr> In that case, there's the intro for the impatient.
13:29:10 <rik> oh. uh.. years ago.
13:30:11 <rik> shapr: excellent. i knew everything on that page.
13:30:25 <rik> not that I read "Haskeel: The Art Of Functional Programming" last night, or anything.
13:31:07 <shapr> Ah, you have that book?
13:31:53 <rik> yes.
13:31:56 <rik> next to me.
13:32:49 <shapr> In that case, have you tried to write something small that doesn't do much i/o?
13:33:10 <shapr> I wrote a text mandelbrot thingy for my first program.
13:34:05 <rik> nope.
13:34:28 <rik> actually, iw as going to write an encoder/decoder for (a subset of) ASN.1
13:34:52 <rik> brb
13:35:43 <shapr> Some ASN.1 code already exists in the cryptolib, so that's a good way to get started and then see how someone else did it.
13:35:50 <Heffalump> I have a feeling that's been done, though if you just want to do it as an exercise that would make sense.
13:39:21 <rik> yup
13:39:31 <rik> crypto is where most of my projects end up heading.
13:40:17 <rik> okay.
13:40:21 <rik> i wonder where ghc installed.
13:41:09 <Darius> c:\ghc\ghc-6.4 though you could've changed it.
13:41:40 <rik> i didn't change it.
13:42:01 <rik> okay, let's get started.
13:42:21 <Darius> http://www.haskell.org/crypto/ReadMe.html is a reasonable overview of what's already there.
13:44:16 * rik nods
13:44:39 <rik> i'm beginning to wonder whether there should be something else that i should write, to learn
13:45:46 <Darius> If you're interested in what you're thinking about then go with it, if not go with something you think you'd find interesting.
13:46:26 <Darius> Heck, Pugs started as a solution to an exercise in TaPL.
13:46:33 <shapr> What's that new crypto algorithm that's just been proposed? I vaguely recall it's simpler than AES, and claims to be just as secure.
13:47:08 * rik shrugs
13:49:53 <Darius> rik: How about functions to support chaffing and winnowing?
13:50:01 <shapr> That would be cool.
13:50:06 <rik> blah
13:50:40 <rik> chaffing and winnowing is uninteresting to me.
13:50:54 <rik> why would i want to use up *more* bandwidth and entropy than i need to?
13:51:34 <shapr> What is interesting to you?
13:51:43 <rik> i don't know
13:51:55 <shapr> I've been playing with a simple Othello game.
13:52:00 <Darius> With a packet transform I don't think it's too bad.
13:52:24 <shapr> rik: you could add support for your Network card to hOp/House
13:52:28 <rik> i've been writing a small crypto library in C for a while, but i've not had the chance to dfinish it.
13:52:29 <shapr> Right now it only does NE2000
13:53:10 * rik wonders why ghc depends on X11
13:54:11 <Philippa_> it does? Damn, that leaves me a bit screwed running on windows...
13:54:18 <rik> on FreeBSD it does
13:54:30 <Philippa_> (there's an X11 lib available for it, odds are /that/ depends on it and thus the main GHC package does)
13:54:33 <rik> decided to install it on my hosted machine, for toying with.
13:55:09 * Darius decides to find out if wxHaskell 0.9 will work with GHC 6.4 with just some binary file munging.
13:55:19 <smott> FLAVOR=no_x11 make install
13:55:53 <shapr> Is the RealTek 8139 driver significantly more complex than the NE2000 driver?
13:57:11 <rik> evcerything is more complex than the ne2k
13:57:19 <shapr> ok then :-)
13:58:34 <integral> do hOp/House both just use GHC heap stuff for their memory management?  something more sophisticated would be a bit fun
13:59:26 <shapr> House adds protected memory, that's as much as I know without checking the source.
13:59:48 <integral> hmm, a heap is all you really need though
14:01:26 * rik shrugs, yawns. tired.
14:02:08 <shapr> rik: what editor do you use?
14:03:19 <rik> vim
14:04:05 <shapr> Well, I won't dump my collection of emacs tricks in your direction then.
14:05:01 <rik> i appreciate that. thanks :)
14:05:11 * shapr grins
14:07:29 <shapr> Codec.ASN1 screams out for Template Haskell.
14:07:33 <shapr> or at leat Generic Haskell.
14:09:29 <Philippa_> 'lo cm
14:10:30 <cm> hi
14:12:41 <Philippa_> how's life these days?
14:13:17 <cm> good, good.. 'it is weekend, though, hence i'm bored ;)
14:13:24 <cm> -i
14:14:08 <shapr> write code!
14:14:12 <_JusSx__> lol
14:14:24 <_JusSx__> bored writing code
14:14:36 <cm> shapr: hmm, othello
14:16:50 <_JusSx__> what to code?
14:17:02 <rik> that's the same problem i have
14:17:15 <cm> "what not to code?" is a much more severe problem ;)
14:18:18 * rik curses windows networking.
14:18:44 * cm hugs rik
14:18:45 <KrispyKringle> rik: yeah, i use vim, too. but its a shame abotu the poor haskell indenting. :-/
14:19:09 <rik> KrispyKringle: i don't know yet. i guess i'll find out.
14:19:17 <rik> i'd probably just set it to use python indenting :)
14:19:24 <KrispyKringle> rik: i just do it by hand.
14:19:34 <KrispyKringle> make sure expandtabs is set, though.
14:19:39 <KrispyKringle> otherwise,w eird errors.
14:19:46 * rik nods
14:19:48 <KrispyKringle> i've considered using emacs in viper mode for haskell, but...meh.
14:20:17 <pipe> emacs' haskell indenting doesn't seem so great either :\
14:20:23 <_JusSx__> so what to ccde? any idea?
14:20:28 <pipe> but yeah, i use vim for everything except haskell :(
14:25:04 <Heffalump> Igloo uses vim for Haskell, I haven't heard him complain abou tit
14:25:50 <Darius> I usually just use ai and handle the first line myself.  I haven't cared enough to try to make things smarter.
14:31:13 <shapr> What's the difference between Array and IArray? I don't really get it.
14:31:46 <shapr> y0 SyntaxNinja
14:32:21 <shapr> hey, did get anywhere with QuickCheckM?
14:32:31 * Philippa_ reads _JusSx__'s line and wonders how long he's been in pratchett fandom for a mo...
14:32:33 <shapr> g'day blackdog
14:32:53 <SyntaxNinja> hey all
14:33:11 <SyntaxNinja> shapr: nah, haven't pursued it
14:33:20 <shapr> awright
14:33:28 <SyntaxNinja> hi Philippa_, hi blackdog
14:33:29 <SyntaxNinja> Lemmih: alive?
14:33:55 <Philippa_> 'lo SyntaxNinja
14:33:58 <Philippa_> sadly 'moff to bed
14:34:04 <SyntaxNinja> 'night.
14:35:46 <pipe> hi shapr
14:36:00 <shapr> hiya pipe
14:36:12 <pipe> what's up?
14:36:19 * SyntaxNinja has been on vacation this past week, which is why I wasn't around.
14:36:33 <shapr> playing with QuickCheck, hOp, and a half-finished Othello game
14:36:48 * Darius doesn't think lying to GHC about wxHaskell is going to work...
14:37:13 <Darius> LOC for the Othello game so far?  And what "technologies" does it use (i.e. is it GUI and which?)
14:37:31 <cm> :|
14:38:28 <shapr> It's just an array with some useful functions so far
14:38:47 <shapr> about twenty lines of code without whitespace and comments.
14:38:58 <shapr> It does show a text version of the board nicely.
14:39:55 <Darius> What characters do you use for black and white chips?
14:40:02 <shapr> X and O
14:40:04 <shapr> easier to see
14:40:21 <shapr> . is empty board
14:40:58 <shapr> Right now I'm trying to figure out if any of the steps to the algorithm are already implemented by code in Data.Array
14:41:48 <shapr> Plus this should serve as a passable Data.Array tutorial, seems needed.
14:43:21 <blackdog> shapr: hey there.
14:43:39 <shapr> wassup?
14:44:06 <blackdog> still struggling with CEDET on xemacs
14:44:19 <Darius> shapr: The Array libraries need some more general functions.
14:44:24 <shapr> like what?
14:44:44 <shapr> blackdog: I ended up ripping out everything except speedbar, and nowadays I don't even use that.
14:45:31 <blackdog> don't think it's worth it, then? I quite like the intellisense thing - whenever I see the windows developers, i get a bit jealous.
14:45:59 <Darius> shapr: Various mappings and index transforms.  Slicings.  Functions that manipulate arrays that don't go through lists.
14:46:11 <blackdog> I think haskell would work really well with that too, because you've got all that type info to cut down the possible choices.
14:46:20 <SyntaxNinja> yeah, mappings would be nice
14:48:15 <shapr> I love the intellisense bit, when it works. But it's so much trouble to get it to work that I just use hippie-expand instead.
14:48:27 <shapr> Yi is the answer to intellisense.
14:48:54 <shapr> blackdog: parse tree macros =)
14:48:56 <cm> shapr: is it, already?
14:48:57 <shapr> mmm
14:49:05 <shapr> no, it isn't yet.
14:49:13 <SyntaxNinja> what do you guys think about hackage hosting packages from remote sites?
14:49:15 <blackdog> shapr: yeah, you're probably right. But to abandon the mountains of code you get with Emacs...
14:49:20 <shapr> SyntaxNinja: I think it's good.
14:49:24 <SyntaxNinja> that is, someone uploads a .cabal file with a package-url field
14:49:43 <Heffalump> is it secure?
14:49:46 <SyntaxNinja> and the client queries hackage to get the location, to download and install
14:49:49 <shapr> blackdog: if it only it were *coherent* code. I bet two weeks with a high-end refactoring browser would turn emacs into a mole-hill, half the code and twice the functionality.
14:49:53 <SyntaxNinja> none of it is secure.  we'll add security next ;)
14:49:57 <shapr> Not that RMS would allow that.
14:50:12 <Heffalump> hack on xemacs instead
14:50:13 <cm> SyntaxNinja: like ADSF & cliki?
14:50:20 <SyntaxNinja> cm: no idea :)
14:50:35 <SyntaxNinja> I definitely want hcakage to also be able to accept tarballs and host packages on-site
14:50:41 <shapr> xemacs is losing users because most active development happens in the gnumacs world.
14:50:48 <SyntaxNinja> the offsite thing just seems kinda scary somehow.
14:51:11 <cm> SyntaxNinja: it gets the d/l URL from the cliki (a wiki).. and packages are signe with the author's gpg key, which you have to trust, or something
14:51:14 <Darius> SyntaxNinja: In what ways?
14:51:16 <shapr> Does cryptolib do everything you'd need for signed packages?
14:51:51 <SyntaxNinja> Darius: it just seems more fragile I guess. more moving parts, more to go wrong, an extra layer of trust
14:51:56 <shapr> Darius: slicings would be patricularly nice.
14:51:57 <SyntaxNinja> but it's not actually an extra layer of trust
14:52:22 <SyntaxNinja> shapr: probably; signed packages is pretty easy from a crypto pov, all you need is a keyring and signing ability; haven't looked into it though.
14:52:35 <SyntaxNinja> cm: makes sense.
14:52:39 <Darius> Couldn't hackage "cache" packages anyways?
14:52:51 <shapr> Yeah, I'd go for that option.
14:53:01 <SyntaxNinja> Darius: yeah; then which URL does it report for the client to download?
14:53:16 <shapr> both, author site and cache backup
14:53:27 * SyntaxNinja nods
14:53:29 <Darius> It goes for the given URL but returns the cached version if the given one doesn't work.
14:53:48 <SyntaxNinja> is there an http way to check if a document exists without getting the document?
14:54:12 <Darius> I think so.  If nothing else you could start a download then cancel it.
14:54:15 <shapr> head?
14:54:33 <SyntaxNinja> shapr: huh?
14:54:50 <SyntaxNinja> we should probably try to add security infrastructure soon, ala apt-secure.
14:54:51 <cm> HEAD
14:54:52 * shapr checks
14:54:52 <Darius> head | netcat "foo.bar/file"
14:54:59 <Darius> Er switch that pipe
14:55:13 <SyntaxNinja> oh, HEAD is an http command?
14:55:17 <shapr> right
14:55:19 <cm> like GET
14:55:31 <shapr> but it only asks about status and stuff, it's just a few lines of response
14:55:34 * SyntaxNinja nods
14:55:41 <cm> it returns the HEADers only IIRC
14:55:56 <SyntaxNinja> I like the idea of returning a list of URLs, though. that way we can extend it to mirrors without changing the interface
14:56:39 <cm> is it going to be an ordered list (1st this then this then that) , or a set of URLs (like on sf.net, "equal" mirrors)?
14:56:57 <SyntaxNinja> idono
14:57:03 <SyntaxNinja> could be interpreted by the client I guess
14:57:18 <SyntaxNinja> maybe the server could randomize them first
14:57:22 <SyntaxNinja> (the order, that is)
14:59:31 <Darius> How about an ordered list of sets, or a primary and a set of mirrors.
15:00:13 <cm> randomization is a pretty good idea to avoid clients who always use set[0] because of lazyness, hmm.
15:00:25 <cm> (ofc you can have that in your approach, too, Darius)
15:00:43 <SyntaxNinja> apt-secure has a three-step process in authenticating packages; a signed 'release' file which has MD5 sums of the 'packages' files (one per "mirror") and the packages file has md5 sums of the packages themselves
15:01:27 <SyntaxNinja> the release and packages files are there to facilitate caching
15:01:31 <cm> I just read some blog post which said that Microsoft's download _URLs_ contain the hash
15:01:57 <cm> (it being nifty because you cannot just replace the file on the server etc)
15:02:00 <SyntaxNinja> but then of course you have to update the cache
15:02:27 <SyntaxNinja> cm: you still have to check the hash on the client side, right?
15:02:35 <cm> only on the client side
15:03:01 <cm> (in their scheme, IIRC)
15:03:12 <SyntaxNinja> I don't see what that buys you
15:03:41 <cm> in contrast to <foo> and <foo>.md5?
15:04:39 <SyntaxNinja> it doesn't buy you any security or authentication, right?
15:04:48 <SyntaxNinja> some convenience, though
15:04:50 <cm> the links will be borken when you change the md5 in the file system (i.e. rename the directory) (modulo symlinks)
15:05:18 <cm> and you gain some convenience by squeezing the hash into the URI
15:06:00 <Darius> cm: Won't that not work for mirrors though?
15:06:03 <cm> ..I just felt it was interesting enough to mention, don't expect coherent plans at 6 PM.. :)
15:06:14 <SyntaxNinja> cm: it's interesting, I'm just curious.
15:06:40 <SyntaxNinja> <foo> and <foo>.md5 is not useful for security in any case :(
15:06:47 <cm> Darius: as long as they mirror the directory structure it should work, no?
15:06:51 <cm> let me look for that post..
15:07:00 <Darius> Yeah, I need to think at it more.
15:07:08 <SyntaxNinja> I'm sorta toying with the idea of signing each package verses signing a list of package md5 sums or whatever
15:07:29 <shapr> yeah, sign the package
15:08:11 <cm> sign the package IMO
15:08:18 <SyntaxNinja> the reason apt-secure doesn't do that is because it would be too much overhead for so many packages
15:08:23 <SyntaxNinja> but we won't have that kinda volume
15:08:54 <SyntaxNinja> also, it does a smart two-step thing where you only need the key of the server, not the key of each individual package author
15:08:59 <SyntaxNinja> but the server needs to have the key of the package authors
15:09:11 <SyntaxNinja> and I'm leaning in that direction
15:10:58 <cm> hmm
15:11:02 <SyntaxNinja> that is, the server signs everything
15:11:17 <cm> could that be just an additional convenience thing?
15:11:33 <SyntaxNinja> of course, debian needs to do that because it builds binary packages that the uploader has never touched
15:11:36 <cm> (consider that the non-hackage download URL is used)
15:11:48 <SyntaxNinja> yeah
15:12:32 <SyntaxNinja> you could have a keyring, and as long as its signed by someone who is in your keyring, it's secure
15:12:39 <shapr> I like that.
15:13:31 <Gahhh> I always trust content signed by Microsoft.
15:14:15 <TNKS> hey guys, I'm just now figuring out a little more how to do dynamic programming or memoization.
15:14:29 <shapr> I wonder why cracker script kiddies don't use their botnets to run a distributed.net client to crack microsoft's signatures?
15:14:40 <TNKS> Is there any way to accomplish a hashmap with dynamic programming?
15:14:50 <SyntaxNinja> Gahhh: maybe we could just have ms sign everything
15:14:52 <Darius> shapr: Because they would fail?
15:15:28 <pipe> fucking 8 inch mosquitos :'(
15:15:37 <Gahhh> They might as well go for the root CA's and reign.
15:15:40 <shapr> What was slashdot reporting? half a million cracked PCs on the botnets?
15:15:48 <shapr> scary thought.
15:15:50 <Gahhh> yeah about that number
15:15:57 <SyntaxNinja> wow
15:15:58 * cm tells ./configure scripts to die
15:16:10 <SyntaxNinja> die ./configure, long-live ./setup configure!
15:16:12 <Darius> killall configure
15:16:32 <Gahhh> what the monad is ./setup configure ?
15:16:33 * cm is unsure whether he should even try to get WashNGo to run on win32
15:16:54 <SyntaxNinja> Gahhh: cabal of course
15:16:58 <Gahhh> ah
15:17:04 <Gahhh> jawohl
15:17:31 <TNKS> whoa.  I seem to have found Data.HashTable.
15:17:40 <TNKS> This is probably all I need.
15:17:57 <SyntaxNinja> TNKS: ther'es Data.Map or maybe Data.FiniteMap, depending on which version of ghc you use
15:19:10 <Gahhh> runas on windowns is nowhere near su on linux. most apps get so confused.
15:19:24 <Gahhh> including firefox uninstall
15:19:37 <TNKS> SyntaxNinja, hmm. . . these return IO Monads.  I was hoping to use something more functional (at a basic level).
15:19:46 <cm> Gahhh: it's a social problem :o)
15:20:02 <cm> noone complains about such bugs because too few people use runas..
15:20:10 <SyntaxNinja> TNKS: nah, those are purely functional
15:20:56 <Darius> TNKS: DiffArray may also be worth looking at.
15:23:11 <beschmi> TNKS: you can use a slightly modified version of HashTable in the ST Monad
15:23:15 <shapr> Darius: Ix seems to do part of the subarray stuff.
15:32:33 <dons> morning #haskell
15:32:40 <shapr> g'day dons
15:32:43 <shapr> hey, is the synhl code in?
15:32:54 <dons> today :)
15:32:58 <shapr> yay!!!
15:33:01 * shapr bounces!
15:33:05 * dons adds to the todo list
15:33:27 <dons> shapr, I'm thinking of putting out yi 0.1 this week sometime, what do you think?
15:33:32 <shapr> w00h00!
15:33:40 <shapr> I am IN FAVOR.
15:33:45 <dons> ok.
15:33:47 <pipe> dons: you are yi author?
15:33:51 <Darius> Hey dons, what were the issues with 6.4 and/or Win32?
15:33:51 <dons> yeah
15:33:54 <pipe> sweet
15:33:56 <Darius> (for hs-plugins)
15:34:26 <pipe> yi is that text editor right?
15:34:33 <dons> Darius: oh, hs-plugins has now been ported to 6.4. There were library changes to deal with: FiniteMap, System.Process. Also the format of .hi files changed, and there was a big change to package.confs.
15:34:41 <shapr> happiness!
15:34:45 <dons> win32 isn't quite there yet, have to deal with \ in path names
15:34:47 * shapr grabs the nightly
15:34:49 <dons> pipe: yep.
15:35:12 <blackdog> dons: hah, i was about to mail you about that. :)
15:35:20 <dons> seafood helped a lot - he wrote the cabal compatibility code.
15:35:24 <dons> hey blackdog!
15:35:40 <blackdog> G'day Don. How's tricks?
15:35:57 <dons> shapr: so I might just tweak yi to run under 6.4  (needs new .hs-boot file) then release
15:36:04 <shapr> yay!
15:36:07 <pipe> dons: so you must be haskell master, right?
15:36:19 <dons> blackdog: good. even better now I've got my lindt bunny :}
15:36:36 <blackdog> Yeah, i'm substituting quantity for quality this year.
15:36:40 <dons> hehe
15:37:02 <dons> got a Cocolo bar, very nice.
15:37:26 <blackdog> go do that yi rebuild. Me want hack yi.
15:37:31 <dons> cool!
15:37:35 <blackdog> What's a Cocolo bar?
15:37:44 <shapr> want hack yi
15:37:47 <shapr> mmm
15:38:00 <blackdog> and did Wolfgang give you the Cocoa gui for it he started working on?
15:38:05 <dons> Cocolo is a really nice, new chocolate brand they sell at hippy health food stores, and at some iga's in newtown.
15:38:08 <dons> yep.
15:38:18 <dons> not in yet - it was more a redesign plan.
15:38:43 <blackdog> Ah, ok. Not in hackable state, then?
15:38:53 <pipe> is there lots of docu for yi, or do you have to use it and read it's source to learn what it's about?
15:39:01 <dons> ok, so the yi plan is: get the current tree to build with 6.4, tag and release, then add in synhl, and cocoa gui to the 0.2 branch
15:39:12 <shapr> I like that plan.
15:39:17 <dons> pipe: not many docs, but the code is well documented
15:39:30 <pipe> dons: mind if i ask you a few questions about it now?
15:39:36 <dons> go for it :)
15:39:52 <pipe> awesomeness... so it's like emacs or something?
15:40:18 <dons> it's a text editor, written in Haskell, that uses Haskell for all it's 'scripting'
15:40:29 <dons> so like emacs, yeah. but nowhere near as big
15:40:48 <blackdog> dons: hs-plugins nightly should build on macos, right?
15:41:05 <dons> blackdog: yeah. reckon so.
15:41:13 <dons> seafood builds it there
15:41:23 <blackdog> cos i geet a ghc-pkg error:
15:41:28 <pipe> dons: here's something i've been wondering about functional languages, theoretical optimizing compilers, and editors with undo+redo capabilities...
15:41:31 <blackdog> ghc-pkg: plugins.conf.inplace: parse error in package config file
15:41:41 <blackdog> while building AltData
15:42:02 <dons> can you try a 'make distclean ; autoreconf ; ./configure ; make' ..
15:42:19 <dons> I think I heard autrijus say that you just have to kill the package.conf.inplace
15:42:27 <shapr> yeah
15:42:47 <dons> it might be left over from the linux build (which tests the tarball before release)
15:42:57 <blackdog> sweet as a nut. Cheers.
15:43:00 <shapr> Is the hs-plugins anonymous cvs repo available? I could keep a darcs mirror on ScannedInAvian.
15:43:02 <pipe> dons: in OOP-land, there is a pattern for doing editors with undo+redo capabilities where you have a "command" class/interface that has execute/undo methods. then you add commands to a queue for each edit operation, and you slide through the queue, executing the undo/execute methods of the elements as you go along... are you familiar with this pattern?
15:43:04 <shapr> hiya Kkaa
15:43:21 <Kkaa> hi
15:43:30 <Darius> pipe: Command pattern === higher-order function
15:43:41 <dons> pipe: yeah. not as a pattern, just as the general api for undo/redo
15:44:00 <dons> pipe: you should look at Yi.Undo
15:44:13 <Darius> pipe: (As well as the Strategy pattern, and Template pattern, and others)
15:44:26 <blackdog> barfs on Cabal stuff, but you told me that already. :)
15:44:27 <pipe> dons: ok, well i've been thinking that implementing the execute + undo method for a new command is kind of too verbose... i mean, in theory, if i right code for execute, then the computer should be able to figure out how to undo it, right? :)
15:44:42 <dons> shapr: good point. I might move hs-plugins over to darcs, I think.
15:45:10 <shapr> I can use tailor.py to keep a darcs mirror of your cvs repo. Or you can do that.
15:45:29 <dons> the cvs repo isn't anonymous atm.
15:45:39 <dons> :/ which is the problem.
15:45:54 <dons> pippe: maybe...
15:46:02 <shapr> you could cron a tailor.py run that updates your local darcs repo, and then I could mirror from that.
15:46:08 <dons> if it is purely functional, perhaps.
15:46:16 <shapr> Kkaa: learning Haskell?
15:46:26 <dons> shapr: good idea. I'll do that.
15:47:04 <dons> blackdog: does cleaning it out do any good?
15:47:15 <pipe> dons: yeah, well i've been thinking that you have the state of your editable-object as a value, then a "command" is just a function that takes the state/value and returns a new state/value
15:47:42 <blackdog> pkg-conf.inplace, you mean? I don't know, I just did your autoreconf thing...
15:47:42 <pipe> then the computer can automatically figure out undo+redo. a simple implementation just stores a history of all values
15:47:57 <pipe> but a more intelligent implementation can figure out the diffs between values automatically
15:48:06 <Darius> pipe: You can always support undo by "taking a snapshot" after each change (at least conceptually), but that usually isn't too efficient.
15:48:09 <dons> pipe: yep. there are known undo algos for this.
15:48:22 <pipe> and an even more intelligent implementation can work out the algorithm of the command and figure out a reverse algorithgm... automatically
15:48:24 <dons> and Darius' point is known in the literature
15:48:41 <dons> pipe: that would be cool, but hard
15:48:49 <Kkaa> shapr: yeah, I read on of those introductory tutorials about a year ago, but then I decided to really learn the language recently
15:48:57 <shapr> pipe: plus, that's more how darcs does it.
15:49:00 <dons> the 'reverse algo derived by hand' is how yi works.
15:49:02 <shapr> tuomov suggested that.
15:49:11 <SyntaxNinja> blackdog: cabal troubles?
15:49:15 <shapr> Kkaa: spiffy, how far along are you? any questions?
15:49:22 <pipe> dons: so do you think that one day there will be optimizing compilers that will be able to do this kind of advanced stuff and create binaries that are even more optimal then hand created reverse-algos?
15:49:39 <dons> SyntaxNinja: nah, I think just cpp issues in my 6.4 package.confs
15:50:07 <dons> I can imagine, pipe, a compiler plugin, or even TH transformation, that could do this
15:50:34 <Kkaa> shapr: I'm a little more than half-way through Thompson's book... no questions yet, I was just curious to see if there was a good community to get help from should I need it in the future.
15:50:55 <shapr> Kkaa: I claim that #haskell is a good community. A bit too good even, I have to leave irc to get any work done.
15:51:12 <Kkaa> ha ha
15:51:18 <shapr> Kkaa: Would you like the short tour of #haskell?
15:51:21 <pipe> dons: i've been thinking a lot lately about optimizing compilers and i think that there needs to be some kind of unification between automatic algorithmic optiziation and the "regular" compilation stage
15:51:26 <Kkaa> shapr: sure
15:51:29 <Darius> Kkaa: Here and the mailinglists are good.  c.l.f is also pretty Haskelly.
15:51:45 <Kkaa> Darius: clf?
15:51:50 <Darius> comp.lang.functional
15:51:53 <shapr> Ok! First stop on the tour is the channel topic, listing the logs, the learning page, and ... other good stuff.
15:52:12 <shapr> Next stop is the ever useful channel irc bot (also written in Haskell). lambdabot has some nice tools.
15:52:14 <pipe> dons: i think a compiler should be extendable, and i think even compilation and runtime should come together closer
15:52:16 <shapr> @index anyChar
15:52:17 <lambdabot> Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
15:52:22 <shapr> @type Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char
15:52:23 <lambdabot> bzzt
15:52:25 <shapr> @type Text.ParserCombinators.Parsec,Text.ParserCombinators.Parsec.Char.anyChar
15:52:27 <lambdabot> bzzt
15:52:31 <shapr> @type Text.ParserCombinators.Parsec.Char.anyChar
15:52:32 <dons> pipe: yeah. we have the GHC pluggable branch for this
15:52:33 <blackdog> shapr:demo effect
15:52:34 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: forall st.
15:52:34 <lambdabot> 					      Text.ParserCombinators.Parsec.Char.CharParser st Char
15:52:37 <shapr> blackdog: totally
15:52:58 <dons> and TH which merges runtime into compilation, and hs-plugins approaches merging compilatoin into runtime :)
15:53:10 <shapr> Kkaa: last but not least, there's the Haskell wiki, with lots of goodies.
15:53:12 <shapr> @wiki QuotesPage
15:53:13 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
15:53:19 <shapr> @wiki FundamentalConcepts
15:53:20 <lambdabot> http://www.haskell.org/hawiki/FundamentalConcepts
15:53:23 <pipe> dons: do you think that AI techniques like genetic algorithms could be used for optimizing compilers?
15:53:37 <dons> scary. don't know.
15:53:50 <blackdog> IT's been done for gcc already
15:53:54 <dons> the languages we work on are usually defined well enough that conventional techniiques work.
15:53:58 <dons> blackdog ;)
15:54:04 <Darius> pipe: Reproducibility is usually desired.
15:54:05 <blackdog> it's got so many optimisation options that someone hooked up a GA to it...
15:54:12 <shapr> If the GHC-api allows programmatic output of -prof, you could run a GA to optimize hs-plugins code.
15:54:37 <shapr> You could mix Template Haskell and Data.Generics in there to try loop unrolling, etc.
15:54:46 <Kkaa> have you guys found that there's been a lot of people interested in learning Haskell after hearing about PUGS?
15:54:56 <dons> Kkaa: yeah.
15:55:02 <dons> and after darcs too
15:55:04 <Darius> Kkaa: Yes, we are being infested by Perlers.
15:55:15 <shapr> and after SyntaxNinja's slashdot book review, and ...
15:55:19 <pipe> we don't want them perl guys! they will corrupt the haskell community! i kid
15:55:27 * Darius finds the results of Pugs kind of ironic.
15:55:39 <shapr> There's an upswing every four months or so, but the period is getting smaller.
15:56:00 <pipe> what was it that that british microsoft dude Peyton Jones said?
15:56:10 <pipe> "Avoid success at all costs" ... or something
15:56:11 <dons> hehe Darius
15:56:11 <shapr> Avoid Success At All Costs
15:56:15 <Darius> Kkaa: Even without those highlights, the Haskell community seemed to be steadily growing.
15:56:48 <Darius> E.g. when I first joined #haskell about two-ish years ago, the average size was about 45 people.
15:56:50 <shapr> But I think he really meant "avoid the molasses of backwards compatability"
15:56:56 <shapr> Haskell was the first agile language!
15:57:20 <shapr> When I first joined #haskell the average was ...
15:57:23 <dons> blackdog: yeah. there's a bug in the nightly build script that leaves the plugins.conf.inplace there. i should fix that.
15:57:35 <Darius> Another highlight that shapr surprising didn't mention was that Haskell was pragprog's language of the year a year or two ago.
15:58:04 <shapr> Surprisingly few people really learned Haskell from that event.
15:58:26 <shapr> I think the committee effect came into play.
15:58:53 <Kkaa> committee effect?
15:59:18 <dons> blackdog: you got it to build?
15:59:20 <shapr> The guys on the pragprog mailing list were trying to coordinate their learning, they were using a wiki.
15:59:39 <shapr> They tried to do the same things at the same time, the same homework, etc.
16:00:41 <TheHunter> does anyone know a (dirty) trick to convert a "forall a. Foo a => b" into a "FooDict a -> b"?
16:01:10 <dons> compile the code ?
16:01:25 <shapr> The Language of the Year project sort of blew up as a coherent effort after that.
16:01:41 <Kkaa> well, thanks for your help... I will be back for sure.
16:01:47 <shapr> I think Aryeh Friedman had something to do with that though. He's in the same category as TopMind, Thaddeus Olczyk, etc
16:02:03 <dons> TheHunter: seriously, you'd have to desugar the code in the way the haskell compiler does it.
16:02:05 <shapr> Kkaa: sure, feel free to ask any questions
16:02:12 <Kkaa> okay, later
16:02:24 * Darius hasn't come across Aryeh Friedman anywhere.  He's just pragprog?
16:02:37 <shapr> possibly
16:03:05 <blackdog> dons: not yet - some Cabal thing.
16:03:35 <TheHunter> dons, i need the function at runtime...
16:03:53 <dons> TheHunter: you want to do what with what at runtime??
16:05:19 <dons> TheHunter: how do you mean 'convert'? => is just sugar for the dictionary, after all. they're the same.
16:05:58 <dons> I'm finding this question very puzzling
16:06:24 <TheHunter> dons, if there's an instance declaration "instance Arbitrary a => Arbitrary (m a)", i want to be able to get a function of type "ArbDict a -> ArbDict (m a)" in order to be able to define an Arbitrary intance  for a recursive newtype.
16:07:10 <dons> and 'at runtime'?
16:07:14 <TheHunter> of course the clean way is to define an Arbitrary1 class (as it has been done with Typeable).
16:07:27 <dons> ah, ok.
16:07:37 <TheHunter> yeah, 'at runtime' didn't really make sense.
16:08:54 <TheHunter> I guess just using unsafeCoerce# isnt't really safe, because I can't be sure what the exact representation of the dictionary is.
16:09:07 <dons> no way. very super evil in this case.
16:09:23 <Darius> What would you unsafeCoerce#?
16:09:35 <Darius> A function?
16:10:19 <dons> you were thinking of unsafeCoerce'ing something with a class context? that wouldn't make sense though, and would screw up compilation
16:10:46 <TheHunter> hmm, i'm not really sure that i can even get the function to unsafeCoerce.
16:11:08 <dons> _maybe_ you could use an external core transformation
16:11:20 <dons> I can't think of anything else short of compiler hacking
16:11:38 <TheHunter> ok, thanks.
16:11:52 <dons> there are people with better typeclass knowledge than me on haskell@ though ;)
16:12:00 <dons> haskell-cafe@ sorry
16:12:19 <dons> just say 'it's impossible to do this' :)
16:12:34 <Darius> TheHunter: What would the code you'd like to write?
16:12:42 <TheHunter> dons, i like that trick.
16:12:47 <Darius> (look like)
16:13:43 <blackdog> dons: bah, me==idiot. hs-plugins is ok now - didn't have happy and alex.
16:13:51 * blackdog wears the pointy hat
16:13:58 <dons> hehe. ok.
16:14:01 <TheHunter> Darius, something like Arbitrary (m CrazyNewtype) => ArbDict a -> ArbDict (m a)
16:14:25 <dons> blackdog: you shouldn't actually need it. looks like I need to touch some files in the tarball
16:15:02 <Darius> TheHunter: Which you'd use to do what?
16:15:21 <dons> where ArbDict is the actual dictionary argument?
16:15:27 <dons> if so, that type doesn't make sense
16:15:33 <blackdog> dons: ... hm. Well, it didn't actually ask for happy and alex, but it worked when i installed 'em...
16:16:00 <TheHunter> instance Arbitrary (m CrazyNewtype) => Arbitrary (SomeRecursiveNewtype m)
16:16:05 <Darius> blackdog: What prompted you to install Happy and Alex?
16:16:16 <TheHunter> dons, anything isomorphic will do.
16:16:20 <dons> ok.
16:16:29 <blackdog> Darius: repressed memories.
16:16:30 <dons> blackdog: fixing now.
16:17:16 <dons> these are just issues with what gets left in the nightly snapshot tarball after regress testing :/
16:18:12 <blackdog> fair enough.
16:19:02 <TheHunter> oh, i probably CrazyNewtype isn't good enough for that sort of thing.
16:19:07 <blackdog> ...waiting on those hs-boot files, dude. :)
16:19:15 * shapr waits patiently
16:19:48 <blackdog> if i don't have something to hack on, I'll have to go brave the family and cop flak for not going to church...
16:19:52 <shapr> Oh, I could write them myself, I bet.
16:20:02 <shapr> maybe...
16:20:08 <blackdog> what does an hs-boot file look like, anyway?
16:20:20 <shapr> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
16:20:27 <shapr> That's not too bad.
16:21:49 <dons> blackdog: you want yi right now?
16:22:03 <blackdog> dons: kinda
16:22:07 <dons> ok. you have to do the hi-boot to hs-boot for me, then.
16:22:24 * shapr tries cp
16:22:31 <dons> checkout yi. then try to get it to build with 6.4. send me the patch.
16:22:40 <blackdog> alright.
16:22:57 <dons> otherwise I'll get round to it in an hour or two
16:23:16 <dons> also, new hs-plugins tar ball up seems to work without complaints
16:23:52 <shapr> but plugins.conf.in needs some fixes
16:23:54 * shapr hacks
16:24:13 <shapr> I think...
16:24:51 <dons> commit coming in.
16:24:56 <dons> (for that)
16:25:59 <blackdog> commit on hs-plugins or yi?
16:26:12 <dons> for yi package.conf
16:26:20 <shapr> just remove the "1," in plugins.conf.in, right?
16:26:24 <shapr> for make register
16:27:08 <dons> oh, sorry. plugins.conf.in is broken?
16:27:19 <shapr> I think so
16:27:27 <shapr> should be "depends: altdata, hi, haskell-src, posix, Cabal"
16:27:41 <dons> oh, unix bug.
16:27:47 <dons> linux bug
16:27:51 <dons> should be: depends:              altdata, hi, unix, haskell-src, posix, Cabal
16:28:00 <dons> but on linux the 'unix' word get's cpp'd to '1'
16:28:10 <shapr> ohh
16:28:11 <dons> there should be a -U to cpp to fix that. hmm.
16:28:16 <dons> maybe I forgot   to commit it
16:29:01 <dons> yep. looks like it got misplaced. trying again..
16:31:24 <dons> why does debian -Dunix=1 ?
16:31:49 <shapr> Where's the rules for Yi/Undo.hi-boot ? Isn't a hs-boot good enough with 6.4?
16:32:12 <blackdog> shapr: i copied hi-boot to hs-boot, compiled it wiith ghc -c, andd it seems to work...
16:32:23 <dons> but did 'make depend' work?
16:32:54 <blackdog> says it is...
16:35:54 * Darius really needs to make a default Parsec module.
16:36:12 <shapr> default?
16:36:56 <araujo> Hello here.
16:37:00 <dons> now, how to include both hi-boot and hs-boot. hmm.
16:37:04 <araujo> Is there a way to use type with ghci?
16:37:12 <dons> ah! use sed on the depends file ;)
16:37:17 <shapr> :type
16:37:27 <shapr> dons: of course, that's worth one dons point!
16:37:40 <dons> :)
16:37:40 <blackdog> some unix people, when faced with a problem, think "Iknow, i'll use sed!"
16:37:46 <blackdog> now they have two problems.
16:38:06 <dons> bah! double bah!
16:38:41 <Darius> shapr: Something which does Parsec's "parameterized" modules dance and re-exports TokenParser's fields as normal functions.
16:39:01 <shapr> oh
16:39:25 <blackdog> dons: oh joy. finitemap -> map, here i come...
16:39:49 <dons> blackdog: I've written a compatibility module.
16:40:02 <blackdog> Yeah? Where can i get it?
16:40:11 * blackdog hurriedly backs out changes
16:40:18 <dons> :}
16:40:31 <shapr> I found more bits to fix with make -k
16:40:39 <dons> anyway, just committed a yi package.conf
16:40:51 <shapr> MkTemp.hsc:51:34: Module `System.IO' does not export `isAlreadyExistsError'
16:41:26 <dons> that should be fixed in hs-plugins, I'll grap the patch from there.
16:41:43 <shapr> g'day itior
16:42:05 <itior> hey everyone
16:42:22 <shapr> Looking for Haskell info?
16:42:36 <itior> is this a help channel?
16:42:47 <shapr> For Haskell, sure.
16:43:00 <blackdog> I also do marriage counselling
16:43:14 <SyntaxNinja> and for Debian, and as blackdog points out, marriage counselling, but only in privmsg
16:43:18 <itior> ok, well im doing an assignment, and i have it partially working, but i can't figure out how to make it work for other cases...
16:45:13 <shapr> I can also help with emacs, southeast USA culture, and other unexpected subjects.
16:45:31 <blackdog> dons: compat module? (not pushing, but agog with anticipation)
16:45:38 <SyntaxNinja> itior: we'll need more info :)
16:45:38 <itior> shapr: it's kind of long, do you mind if i pmsg?
16:45:45 <SyntaxNinja> @paste
16:45:46 <lambdabot> Sorry, I don't know the command "paste", try "lambdabot: @listcommands"
16:45:48 <shapr> There's a paste page
16:45:51 <itior> ah ok
16:45:52 <shapr> @wiki HaskellIrcPastePage
16:45:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:45:58 <dons> I have a module in minhs, not in yi, so I'll send it and you can adapt it.
16:45:58 <shapr> SyntaxNinja: truly, that would be a useful command.
16:46:14 <SyntaxNinja> shapr: :)
16:46:26 <blackdog> sweet. by email?
16:46:38 <SyntaxNinja> shapr: or abstract it; you could make typedefs of commands like "@type paste "wiki HaskelIrcPastePage" :)
16:46:50 <dons> blackdog: sent.
16:46:55 <SyntaxNinja> or @alias
16:47:27 <itior> well, the assignment is to solve a 'choose your own adventure' book
16:47:49 <itior> the structure of a book is given by 3 functions...
16:47:57 <itior> ill paste the type signatures and my code
16:48:08 <SyntaxNinja> shapr: maybe you can make lambdabot into a functional language
16:48:27 <shapr> Yeah, Darius suggested lambdabot as an irc DSL.
16:48:56 <SyntaxNinja> shapr: thought: with code-as-communication, darcs will evolve to be an email reader, like every other program of sufficient complexity ;)
16:49:04 <dons> hmm. I still think ghc -M is broken somewhat.
16:49:11 <SyntaxNinja> stupid stupid
16:49:24 <dons> I get: Yi/Undo.o-boot : Yi/Undo.hs-boot, Yi/Buffer.o : Yi/Undo.hi-boot
16:49:30 <shapr> SyntaxNinja: haha
16:49:31 <dons> which don't look right: /
16:49:36 <SyntaxNinja> was it broken in 6.2.1? I think I designed a makefile based on its broken behavior
16:49:36 <shapr> dons: yeah, I agree.
16:49:49 <shapr> I went with blackdog's ghc -c and that worked.
16:49:50 <dons> nah 6.2.2 works properly.
16:50:05 <shapr> Though now I'm having other problems.
16:50:05 <dons> shapr: ok.
16:50:25 <shapr> /usr/lib/ghc-6.4/bin/ghc-6.4 -Wall -Werror -fvia-C -funbox-strict-fields -O2  -iYi/Curses -IYi/Curses -Icbits -Imk  -package-name yi -c Yi/Curses/CWString.hs -o Yi/Curses/CWString.o -ohi Yi/Curses/CWString.hi <next line> /tmp/ghc4442.hc:5:36: Yi/Curses/CWString_hsc.h: No such file or directory
16:50:28 <blackdog> shapr: hurrah for dirty hacks. :)
16:50:28 <itior> hm
16:50:36 <shapr> itior: you screamt?
16:50:45 <dons> shapr: maybe -I semantics?
16:51:05 <shapr> er, huh?
16:51:21 <itior> shapr: ahh ill try figure it out myself, dont think i can paste the assignment on a public page
16:51:26 <shapr> I added the -i and -I params myself, but they made no difference.
16:51:37 <shapr> itior: you could describe your problem, then we could help more.
16:51:48 <shapr> itior: also, describing a problem often assists with the answer.
16:51:58 <itior> yeah i know, but there's a lot of stuff
16:52:04 <itior> lines of crap :P
16:52:22 <itior> basically, a book is defined by 3 functions
16:52:24 <shapr> If you describe the problem, and how you approached the solution, it's likely we can suggest some goodness.
16:52:37 <itior> choiceCount :: Int-> Int
16:52:45 <itior> next :: Int-> Int-> Int
16:52:50 <itior> success :: Int-> Bool
16:53:06 <shapr> Doesn't sound too scary so far.
16:53:10 <itior> yeah
16:53:12 <shapr> dons: -I semantics? eh?
16:53:21 <shapr> je ne comprends pas
16:53:23 <itior> i need to write a solve function that finds the shortest path to a success
16:53:34 <itior> needs to be able to deal with looping, ie
16:53:37 <itior> next 0 1 = 1
16:53:42 <itior> next 1 1 = 1
16:53:45 <itior> next 1 1 = 0*
16:54:15 <shapr> What does this code do? Something with books?
16:54:25 <itior> it solves 'the book'
16:54:47 <itior> its just a tree
16:55:00 <shapr> oh, I get it.
16:55:24 <shapr> Well, the Union/Find algorithm would be particularly nice here.
16:55:59 <shapr> What approach did you take?
16:56:03 <itior> solve can't use anything particularly advanced... we aren't allowed to use stuff that wasn't covered in class
16:56:06 <itior> well
16:56:20 <itior> ill paste that
16:56:47 <dons> MkTemp.hsc patch committed
16:56:50 <shapr> Can you describe your approach?
16:56:54 <dons> blackdog: how's Map going?
16:56:58 <itior> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
16:56:59 <dons> that's where I'm at now.
16:57:02 <blackdog> adequately. :)
16:57:32 <itior> shapr: PageID and ChoiceID are just Int, they are declared up further...
16:57:47 <dons> blackdog: ok, I'll work on a automagic fix for hs-boot
16:58:07 <dons> Foo.o-boot is legitimate. hmm.
16:58:42 <shapr> itior: is that code you wrote?
16:58:45 <itior> yeah
16:58:59 <shapr> Looks like you have a clear idea of where to go.
16:59:07 <itior> yeah, but it doesn't work
16:59:07 <itior> ;\
16:59:48 <itior> it doesn't return the shortest success, and sometimes it wont even return it at all
16:59:59 <itior> i figure i want to recursively check all the subpages
17:00:13 <stepcut> cripe! how come everytime I search for something I end up on oleg's web page :-(
17:00:18 <itior> but it seems as though i've screwed it up
17:00:46 <shapr> stepcut: cuz he's so cool
17:00:55 <shapr> itior: what happens?
17:01:25 <itior> if there are 2 choices, it only returns the first choice down the tree, as opposed to the closest
17:01:26 <stepcut> shapr: maybe oleg is a shadow of my future ;)
17:01:36 <shapr> I'm definitely chasing oleg's shadow.
17:02:03 <shapr> itior: sounds like your backtracking code isn't going back.
17:02:08 <stepcut> this time I was searching for how to implement decimal arithmetic...
17:02:27 <shapr> itior: tbh, I don't see any backtracking code there.
17:02:36 <shapr> itior: it looks like your code does just that, finds one solution.
17:02:44 <Darius> stepcut: At the type level !
17:03:02 <itior> shapr: findBestRoute calls solve at some point
17:03:26 <shapr> what does solve do?
17:04:08 <itior> checks if the page is a success or has any nodes below it
17:04:47 <shapr> What does solve evaluate to?
17:04:57 <itior> a list of choices...
17:04:58 * dons eats chocolate and hacks yi
17:05:00 <itior> it depends on the 'book'
17:05:31 <shapr> What result do you want?
17:05:35 * Darius wishes he had some milk.  He has chocolate to go with it.
17:05:47 <itior> the shortest list of choices to the solution
17:06:06 <shapr> Those two don't match.
17:06:32 * shapr is suddenly hungry also
17:06:43 * stepcut is very hungry, but has no food
17:07:00 <shapr> itior: what about replacing a choice with the minimum of steps to the solution?
17:07:19 <shapr> to one of the solutions
17:08:09 <shapr> I'd first prune off loss branches, and then replace multiple solve branches with the best of the branches in a list.
17:08:17 <shapr> If you do that recursively, you're done.
17:08:53 <shapr> itior: you think that would work?
17:09:06 <itior> yeah, that's what i've been trying to do
17:09:59 <shapr> to me it looks like findBestRoute only returns one solution.
17:11:07 <shapr> My approach would be to walk the choiceList, and for each item, dump it if it's a loss, or keep a tuple of (steps,choiceID) for a solution.
17:11:58 <shapr> and if it's a list, compare the steps of the list items,
17:12:23 <shapr> Actually, that's not a clear approach... mostly because it's 3am here
17:12:57 <shapr> dons: yay, MkTemp works!
17:13:45 <dons> :)
17:14:10 <dons> now I'm busily importing hs-boot fixes to the mk/* code, and blackdog's hacking on Yi.Map (?)
17:14:11 <blackdog> dons: what's the clean way of repressing 'GHC.List.lookup'? I don't want to go sprinkling 'import Prelude hiding blah blah blah' all through the code...
17:14:19 <shapr> itior: anyway, you seem to understand what you're doing just fine.
17:14:32 <dons> blackdog: hm. can we hide it in Map somehow?
17:14:40 <dons> and make sure Map is always imported qualifed
17:15:09 <itior> yeah, thanks for your help
17:15:33 <shapr> TNKS: memoize' f range = ((map f range) !!)
17:15:38 <shapr> TNKS: memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
17:15:45 <shapr> I got those from Lor
17:16:09 <shapr> Hm, I hope I didn't get rid of itior.
17:16:52 <blackdog> dons: so you always call Map.lookup instead, you mean?
17:17:04 <dons> yeah. or M.lookup
17:17:06 <shapr> musasabi: Hey did you see my email? - http://lists.alioth.debian.org/pipermail/shootout-list/2005-March/001296.html
17:17:20 <dons> Map should always be imported qualified
17:17:32 <blackdog> dons: ok. ick, but ok.
17:17:50 <shapr> sleeppp
17:19:00 <dons> blackdog: it's how Data.Map is supposed to be used to.
17:20:55 <blackdog> fair enough, fair enough. Should all the functions be qualified, or only the colliding ones?
17:22:08 <dons> I'd think it reasonable to always use Yi.Map qualified, unless it is too burdensome
17:25:33 <TheHunter> dons, Darius, thanks again, but it's simpler than I thought: using -fallow-undecidable-instances, this is allowed: "instance Arbitrary (m (Foo m a)) => Arbitrary (Foo m a)".
17:25:57 <dons> cool :)
17:30:19 <blackdog> dons: is the CWString problem shapr was having fixed?
17:30:49 <dons> i haven't hiit it yet.
17:30:57 <blackdog> i think the map changeup is ok, but i'd like to test it before i make an idiot of myself in public. :)
17:32:09 <dons> :)
17:35:06 <dons> I'm not sure yet how to handle 6.2.2 and 6.4  hs/hi-boots simultaneously.
17:35:08 <dons> hmm
17:37:57 <dons> if in doubt, use sed
17:38:18 <blackdog> you troll me unmercifully.
17:38:44 <blackdog> ok, i'm going to be social for a bit. shall send you a patch, and you can examine it for brain explosions.
17:38:54 <dons> cool. cheers!
17:42:16 <blackdog> dons: postemacs list seems to have been dead for a while. Is there anyone working on intellisense stuff/type aware syntax stuff?
17:43:22 <dons> yeah, but not on post-emacs, I guess.
17:43:29 <dons> mostly you hear about it here.
17:43:55 <dons> the Project Lambda guys at Chalmers are doing some stuff
17:48:16 <dons> blackdog: got me a patch?
17:48:24 <blackdog> yep, sending nwo
17:50:16 <blackdog> sent
17:50:22 <dons> cool. cheers.
17:50:40 <dons> and i've got the hs-boot  thingo sorted. just committing now.
17:50:49 <dons> and it only uses sed once ;)
17:50:59 * blackdog grins
17:51:20 <dons> are these compressed patches?
17:51:33 <dons> can you do a darcs send instead?
17:51:56 <blackdog>  Yep, done
17:52:08 <blackdog> sorry, not a particularly adept darcs user yet
17:52:53 <dons> sent?
17:53:05 <blackdog> bah, bunch of teases - they haven't got anything released yet.
17:53:17 <blackdog> yeah, it's sent. has it not come through?
17:53:29 <dons> not yet. to dons@cse..?
17:53:47 <blackdog> yeah, i just ran darcs send and it said it had sent it to you
17:53:55 <blackdog> might be some firewall issues. hold on.
17:58:40 <dons> if you're still stuck, I can apply the patches by hand.
17:59:07 <dons> ?
18:00:13 <blackdog> Is there another way of sending?
18:00:25 <blackdog> i still have a cse account if you can do it with ssh
18:00:47 <dons> you can push it to a file, and then email me that file.
18:01:28 <dons> sorry, darcs send -o /tmp/f
18:02:53 <blackdog> ok, sent
18:03:21 <dons> got it
18:03:31 <dons> looks good. cheers.
18:03:35 <blackdog> great. catch you later.
18:15:41 * dons continues the yi hack/chocolate feasst
18:16:55 <Darius> How much chocolate do you have?!
18:17:57 <dons> hehe. oh, 3 or 4 bunnies, 1 block, and a dozen eggs :)
18:18:07 <dons> my gf works in a chocolate shop :)
18:22:37 * Darius has a felling this GADT constructor isn't going to work with foldr the way he'd like...
18:23:09 <blackdog> dons: did i screw up Yi.Map under 6.2?
18:23:44 <dons> just forgot to export elems
18:23:51 <Darius> Term :: Term -> Term Term
18:24:03 <dons> Darius: argh!
18:24:49 <blackdog> is that the typesystem equivalent of breaking the fourth wall?
18:34:45 <dons> hmm. how come I can -Dsym in hsc2hs, but not -Usym
18:41:31 <Darius> Bah, this GADT nonsense is useless.
18:44:04 <heatsink> Is there a name for the transformation that converts the LHS of the following to the RHS?
18:44:12 <heatsink> case (if x then Left () else Right y) of { Left _ -> f; Right y -> g y } === if x then f else g y
18:45:46 <Darius> Probably something like case-dropping or case-lifting (it can be viewed as either) and then typical "constant folding" style optimizations.
18:45:53 <skew> I think that's the one called case of constructor
18:46:09 <heatsink> Thx, I'm going to look that up...
18:46:40 <Darius> heatsink: The thing to note is 'if x then y else z' is 'case x of True -> y; False -> z'
18:46:51 <skew> Darius: what are you trying to with with the GADT?
18:51:21 <Darius> skew: Something that I knew wouldn't and unsurprisingly doesn't work.
18:51:35 <skew> what was it?
18:51:55 <heatsink> bah, portal is down.
18:53:00 <Darius> Simply parsing into a GADT.  Simplifying, if you have data T a where L :: Int -> T Int; R :: Bool -> T Bool, you can't write charToT 'a' = L 1;charToT 'b' = R True and type check it.
18:53:53 <Darius> I could deal with it some ways and probably keep the benefits of GADTs, but I'm not sure if it's worthwhile.
18:53:58 <skew> have you tried wrapping an existential around that?
18:54:05 <blackdog> dons: you don't get the CWString_hsc.h error?
18:54:38 <dons> yep. fixed it. commit coming in.
18:54:44 <dons> it was the semantics of -I :)
18:57:27 <Darius> skew: That's pretty much along the lines of the ways to deal with it.  A 'catch-all' case would be needed (in general) it seems.
18:58:33 <blackdog> right. I'll just leave 'watch "darcs pull"' running, shall I? :)
18:58:33 <Darius> skew: Though with some kind of type "passing" it may recover some of the benifit.
18:58:56 <dons> blackdog: yeah, they're coming in. just checking on linux now.
19:08:15 * Darius has interesting ideas regarding GADTs, type classes, and polymorphic recursion, but that will have to await another day.
19:09:45 <dons> grr. hsc2hs is stupid. it just calls 'ghc' without any version number. bug bug bug.
19:26:29 <Kkaa> does anyone know of any good Haskell code editors for Windows?
19:26:45 <dons> emacs?
19:26:48 <dons> vim?
19:27:31 <Kkaa> i thought they were for *nix
19:28:07 <dons> i'm teasing somewhat. you can run those on windows. really though, I'm not sure what people use on windows. pfe perhaps?
19:29:26 <Kkaa> hmm... ok
19:29:54 <skew> Kkaa: those editors were ported approximately the first day a unix programmer had to develop under windows
19:33:53 <skew> while I'm speaking to the nonexistant, I'll mention that existentials seem to to exactly what Darius wanted
19:34:26 <skew> Hmm, I wonder if I could abuse %monad to propagate that trick throughout a happy parser
19:42:28 <stepcutHM> I wonder when my bed will come in the mail
19:50:38 <blackdog> dons: am getting errors from ranlib about libHSyi.a having no symbols. Do you know if Sean's seen that?
19:50:53 <dons> haven't seen that before.
19:52:48 <TNKS> Am I going to get into trouble if I make a data declaration like: data MyGraph = Maybe MyNode (where MyNode is type declared earlier)?
19:53:13 <skew> TNKS: yes, because the constructor name Maybe is already taken
19:53:21 <TNKS> It seems to be "legal" for more than one data type to share a constructor, but I'm running into some problems.
19:53:35 <skew> TNKS: no, it's only legal in different scopes
19:53:40 <dons> it's a name space issue.
19:53:47 <dons> and it's going to confuse _everyone_
19:53:57 <dons> well, almost everyone
19:54:15 <TNKS> I'm getting Expected type: a -> ColorCombinationGraph, Inferred type: a -> Maybe a
19:54:37 <TNKS> sorry.
19:54:44 <TNKS> Let me rephrase.
19:54:58 <dons> you're defining a Maybe data constructor, and here referring to the Maybe type constructor.
19:55:18 <TNKS> I'm getting Expected type: a -> MyGraph, Inferred type: a -> Maybe MyNode.
19:55:27 <dons> do you really just want: data MyGraph = Node (Maybe MyNode) ?
19:55:36 <dons> or type MyGraph = Maybe MyNode ?
19:55:38 <TNKS> So, things aren't working out like I wanted.
19:56:02 <TNKS> dons, exactly, but my datatype is cyclic, so a type declaration isn't an option.
19:56:40 <TNKS> But the Node constructor is kind of fluff, because I don't have many options to my ADT.
19:57:04 <dons> you could use a newtype
19:58:09 <TNKS> dons, how would that look syntactically?
19:58:17 <TNKS> I forgot about newtype.
19:58:25 <dons> newtype MyGraph = N (Maybe MyNode)
19:58:44 <dons> s/N/MyGraph/ say
19:58:57 <skew> you would still have an extra constructor to deal with, but it's optimized away at runtime, and you can use "deriving" to inherit the exact set of class instances you want from the type you are wrapping
19:59:08 <dons> s/runtime/compile time/ ;)
19:59:34 <skew> well, it's gone by runtime
19:59:43 <dons> yeah. I see what you meant.
19:59:58 <dons> s/away at/away by/
20:01:02 <TNKS> so it's like data only optimized?
20:01:32 <TNKS> Are there instances where you _have_ to use data (newtype isn't an option)?
20:02:08 <skew> the benifits of using newtype over type are that it's a distinct type so you can define different instances, control access like normal (make it an ADT, for example), and the compiler warns you about confusing the newtype with the type you made it from
20:02:21 <skew> TNKS: newtype only works when you want to make something identical to an existing type
20:02:43 <skew> TNKS: so basically if you have only one constructor, and that has only one argument
20:03:39 <TNKS> skew, okay.  Kind of confusing, seems like the compiler should manage all that and the user should just use one keyword, whether "data" or "newtype".
20:04:15 <skew> it seems that way, but there are a few differences you can see
20:04:42 <skew> for one, with a newtype you can "deriving" any class the old type has an instance for, which just copies that instance
20:05:21 <stepcutHM> bugzilla sure depends on a lot of CPAN modules...
20:05:50 <skew> also, newtypes are unlifted. If you have newtype I = I Int, then I (undefined :: Int) and undefined:: I are the same value
20:06:36 <skew> with a real data type there is a difference between an undefined value of the new type and a constructor applied to undefined values
20:08:06 <skew> the latter is essential to being able to optimize away the constructor at runtime (otherwise how could you represent I (undefined) differently from undefined), the former is very convenient, and can't really be extended to general data declarations
20:10:48 <skew> The current situation seems a bit redundant but just jamming the two kinds of definitions together makes things a bit worse
20:12:43 <TNKS> skew, I hear you; I just read about the unlifted stuff in the Haskell 98 Report.
20:14:20 <skew> There has been some talk about making e.g. (_|_,_|_) = _|_ while preserving (X,_|_) /= _|_ /= (_|_,Y) which would unify the behaviour of newtype and data, but I don't see how to implement it without a serious performance hit
20:15:20 <skew> The deriving stuff could be changed to a wierd and annyoing special case in the behaviour of deriving on data rather than a wierd and annoying redundancy in the type declaration forms.
20:16:12 <blackdog> dons: what does this mean?
20:16:13 <blackdog> user error (Curses[-1]:keypad)
20:16:13 <blackdog> yi-static: user error (Curses[-1]:keypad)
20:17:19 <TNKS> I studied Haskell a while ago.  I need to brush up on the deriving stuff.
20:18:36 <TNKS> Also, Maybe seems very useful.  But I'm finding that I have to unwind my constructor to take advantage of it.  Is this frowned upon?
20:18:51 <skew> what do you mena?
20:18:54 <skew> unwind?
20:20:07 <TNKS> I end up needing functions like (\(AnnoyingConstructor x) -> x) so that I can get at x which is a Maybe type.
20:20:34 <TNKS> so I can use functions like catMaybes.
20:21:28 <TNKS> and then, I have to reconstruct everything with the AnnoyingConstructor.
20:21:54 <TNKS> I feel like I'm doing something silly.
20:22:56 <TNKS> ...just to use Maybe, but overall, it's less effort than extending my datatype to have a " | Empty" in it's declaration.
20:23:07 <TNKS> Any thoughts?
20:23:24 <skew> what does the data type look like?
20:23:27 <dons> blackdog: donn't know. trying to fix that now.
20:24:27 <TNKS> skew, basically the one I was talking about earlier:  newtype MyGraph = MyGraph (Maybe MyNode), where MyNode recurses back to MyGraph.
20:25:27 <TNKS> I could make this someting like: data MyGraph = MyGraph MyNode | Empty
20:36:57 <blackdog> dons: any luck, or should I go read a book for an hour?
20:37:40 <dons> I've got a theory, but I've run into another problem with hscc2hs
20:38:31 <blackdog> alright. let me know if there's anything i can work on while you're doing it.
20:39:15 <dons> check with --with-ghc=/f/g/ghc-6.2.2 on the mac perhaps?
20:39:54 <bd_> I'm using a StateT a (ErrorT b []) and need to mplus two outer monads using the List semantics, rather than the ErrorT semantics. Is this possible?
20:45:40 <dons> blackdog: the keypad error seems to only happen with -O on :/
20:45:52 <blackdog> oh joy.
20:46:16 <blackdog> (still compiling hs-plugins for ghc. will get back to you when i've tested yi with 6.2.2)
20:46:34 <dons> maybe it's this -fliberate-case playing up.
20:46:37 <blackdog> Something getting optimmised away?
20:46:47 <dons> hmm.
20:46:57 <blackdog> bah. i can't spell today
20:48:40 <dons> really need to work out a good regress system for yi.
20:48:50 <dons> maybe some quickchecking
20:49:01 <dons> random editor sequences, perhaps
20:49:17 <blackdog> these are all good things. you don't have a test suite for it?
20:49:22 <dons> not yet.
20:50:23 <blackdog> got an error on Regex.hsc: parse error on input 'import'. i'll make clean and try again...
20:50:34 <dons> yeah, fixed that. grab new patch
20:50:51 <blackdog> champion
20:51:01 <dons> hsc2hs tries to call "ghc" in the ENV, whatever that is. which leads to trouble if ghc /= --with-ghc
20:51:11 <dons> ghc-6.2.2-compiled-hsc2hs doesn't do this
20:52:36 <blackdog> loki:~/src/yi mwotton$ make
20:52:36 <blackdog> Rebuilding dependencies... Yi/MkTemp.hs: unknown flags in  {-# OPTIONS #-} pragma: _GHC
20:52:42 <blackdog> can't even make clean...
20:52:46 <blackdog> help? :)
20:53:10 <dons> hmm.
20:53:19 <dons> edit  the pragma?
20:54:10 <blackdog> I haven't... it looks like this:
20:54:11 <blackdog> {-# OPTIONS_GHC -optc-DGLASGOW_HASKELL=602 #-}
20:54:30 <blackdog> i tried with 622 instead, but it doesn't seem to make any difference
20:54:49 <dons> 602 is correct
20:55:03 <blackdog> ok. just voodoo debugging on my side
21:02:26 <blackdog> apropos of nothing in particular: Television, Gang of Four, and Wire are three of the best bands in the world.
21:13:59 <TNKS> sorry guys.  I'm still not sure about which way to go on this thing...
21:15:02 <TNKS> which makes more sense?  "newtype MyGraph = MyGraph (Maybe MyNode)", where MyNode recurses back to MyGraph... or "data MyGraph = MyGraph MyNode | Empty"
21:21:17 <skew> why not type MyGraph = Maybe MyNode?
21:21:36 <skew> as long as MyNode is a real data type that's fine
21:25:38 <TNKS> skew, even if MyNode recurses back to MyGraph?
21:26:01 <skew> the problem with type A = (A,Bool) is that it expands to an infinite type
21:26:36 <skew> data types don't just expand into their definition, so if you use a real data type there is no problem
21:30:15 <Lemmih> Good morning, #haskell.
21:30:25 <dons> blackdog: seems to be -fvia-C in 6.4 at fault.
21:30:31 <Lemmih> @seen SyntaxNinja
21:30:32 <lambdabot> I saw SyntaxNinja leaving #haskell 4 hours 24 minutes 11 seconds ago.
21:30:51 <blackdog> dons: was about to say - -Onot didn't help.
21:32:08 <dons> yeah, -fasm -O2 ~> -O2 -fvia-C
21:32:12 <dons> :/
21:32:35 <TNKS> skew,  I think that's a good idea.
21:32:39 <TNKS> I'm going to try it out.
21:32:50 <autrijus> my talk is beginning in a couple hours :)
21:32:55 <blackdog> dons: really? So you need to turn off both of them, then?
21:32:59 * autrijus is in mad slides-writing mode
21:33:26 <dons> nah, blackdog, just add -fasm to the end of HC_OPTS in mk/config.mk
21:33:40 <dons> I'm trying to pin point exactly which file needs the -fasm now.
21:33:51 <blackdog> ok, cool. i did that already, so this build should be the first one to actually work on my mac. :)
21:34:04 <dons> :) and what about 6.2.2 ?
21:35:04 <blackdog> hey, i've only got so many cpu cycles. :) once i've built this one and squirreled a copy of yi-static away, i'll try with 6.2.2
21:35:13 <dons> ok.
21:35:42 <blackdog> ran into the problem that 6.2 and 6.4 both point to the same packages.conf, which bollixed things up
21:40:57 <TNKS> skew, your recommendation worked nicely.  Now I'm getting the benefit of a newtype on MyNode (instead of a data), and also I don't have unnecessary constructors obstructing my Maybe constructors.
21:40:58 <TNKS> Thanks.
21:41:37 <dons> blackdog: ok, I think we've done the  port to 6.4. now some more testing, and then get a release out.
21:42:16 <dons> definitely have to make sure it works on the mac. i'll try way=static on some of the funny boxes like mips64, amd64.
21:44:09 <blackdog> Ok. Works on mac with ghc6.4. testing 6.2.2 now
21:44:24 <dons> i just comitted a -fasm patch
21:44:30 <blackdog> yeah, i got it
21:45:38 <blackdog> 6.2.2 has a pragma error...
21:45:48 <blackdog> Rebuilding dependencies... Yi/Curses/IConv.hs: unknown flags in  {-# OPTIONS #-} pragma: _GHC
21:46:06 * blackdog hopes that it's not my screwup
21:46:21 <blackdog> is there a way to make sure you're up to date with a darcs repository?
21:46:55 <dons> try to pull?
21:47:07 <dons> so what is actually in IConv.hs ?
21:47:08 <blackdog> no remote changes to pull.
21:47:21 <dons> it's preprocessed by cpp, so something apple-ish might have slipped in.
21:47:22 <blackdog> {-# OPTIONS_GHC -optc-DGLASGOW_HASKELL=602 #-}
21:47:52 <dons> hmm. isn't OPTIONS_GHC a Cabal thingo from 6.4?
21:48:07 <dons> what is 'ghc' on your box?
21:48:14 <blackdog> ghc is 6.4
21:48:14 <dons> ghc --numeric-version?
21:48:25 <blackdog> 6.4
21:48:36 <dons> ok, so hsc2hs is actually calling ghc-6.4
21:48:39 <dons> as 'cpp
21:49:39 <dons> I think this should be considered a bug in hsc2hs, that it exec's "ghc" not "ghc-$version"
21:49:56 <dons> so, how to fix... hmm..
21:50:50 <dons> OPTIONS_GHC isn't backwards compatible :/
21:51:48 <dons> blackdog: I think we can just note this down,  but not be too concerned, as people are hardly like to build backwards like this
21:52:07 <dons> more likely to have 6.2.2 officially as ghc, and try --with-ghc=ghc-6.4
21:52:50 <blackdog> dons: sure. One other thing that was bothering me: at least at the moment, I can't run 'make clean' because of the dependency rebuilding step. Is that necessary? It makes it hard to get back to a known state.
21:53:05 <dons> yeah. should kill that.hmm.
21:53:31 <dons> feel free to work out how to stop that
21:56:37 <blackdog> Don: are you sure that's the problem? The link to ghc on my system now points to 6.2.2, and i've deleted IConv.hs - when it rebuilds it using hsc2hs, it still puts that line in.
21:57:23 <dons> rehash?/
21:57:42 <blackdog> ghc -v gives 6.2.2, though
21:57:58 <blackdog> -V, rather
21:58:48 <dons> what does adding -v to mk/rules.mk:HSC_OPTS do ?
21:59:12 <dons> you should see what hsc2hs actually runs
21:59:56 <blackdog> ...oops
22:02:54 <dons> ?
22:03:16 <blackdog> still running 6.4. I don't understand where it's caching it, though. I've run autoreconf and configure.
22:03:42 <dons> I had to rehash my zsh
22:04:08 <dons> but `which ghc` should already point to 6.2.2 by what you're saying
22:04:17 <blackdog> yeah, but if 'ghc -V' gives the right result, how can it be a shell issue?
22:04:20 * blackdog is confused
22:04:33 <dons> which hsc2hs is being called?/
22:04:50 <dons> the one that lives with ghc-6.4 or 6.2.2?
22:05:01 <blackdog> it's 0.66. don't know which that is.
22:05:08 <blackdog> Sorry, i'm sidetracking you something awful here...
22:05:50 <dons> nah, I had to sort out an hsc2hs issue an hour or so ago with __GLASGOW_HASKELL__ being wrong, due to "ghc"
22:06:10 <dons> I don't know why it's still calling 6.4 on your box.
22:06:40 <cm> hey
22:08:36 <beschmi> dons: seeing that you use zsh, do you use command completion for darcs?
22:09:12 <beschmi> it stopped working for me some weeks ago and i'm trying to find out why at the moment
22:09:46 <dons> nope. don't use it. probably should though
22:09:55 <cm> shapr?
22:11:51 <blackdog> dons: I think it must be because it's the version of hsc2hs from 6.4. I blew away my yi directory, and opened a new shell: still calls 6.4, so I figure there must be an embedded reference to it somewhere.
22:13:06 <dons> hmm. maybe I had the hsc2hhs versions wrong. it is the 6.2.2 vers that must call "ghc".
22:13:15 <dons> that's the one sitting on my box.
22:13:54 <dons> yeah. my mistake.
22:14:09 <dons> so just rebinding 'ghc' isn't going to work.
22:14:20 <blackdog> dons: you know you have access to the chil0? machines at cse, right?
22:14:56 <blackdog> i wish sean left his directory a little more open - I'm sure he's compiled all the haskell tools for mac, they're just not there...
22:15:16 <dons> ah. yeah I do. also ozone's g5.
22:15:20 <dons> i'll test on that
22:15:45 <blackdog> cool. i'll go play with it on 6.4. :)
22:17:02 <blackdog> yi:
22:17:02 <blackdog> /usr/local/lib/yi/HSyi.o: unknown symbol `_iconv'
22:17:02 <blackdog> yi: user error (resolveObjs failed with <<False>>)
22:17:16 <blackdog> known?
22:17:37 <dons> yeah. working on it
22:17:47 <dons> hsc2hs isn't seeing "config.h" for some reason, I suspect
22:29:36 <dons> looks like I left  "config.h"' out of a few .hsc files.
22:29:52 <dons> wonder if that fixes the -fvia-C issue..
22:31:00 <dons> nope.
22:31:06 <blackdog> dons: I've got ~/.yi/Config.hs setting a new keymap, but it seems like it's being ignored. How do I find out what's happening?
22:32:46 <blackdog> ok, am off. talk to you later\
22:41:28 <dons> ok. thanks for the code.
23:19:40 <dons> blackdog: doesn't appear to be a problem for me.
23:41:30 <Lemmih> shapr: Yo? Can I have push access to the darcs repos?
23:56:42 <autrijus> http://wagner.elixus.org/~autrijus/p6tu/start.html
