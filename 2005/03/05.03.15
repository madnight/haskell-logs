00:00:08 <Gahhh> Cybertnt, in the link I posted you can read about using haskell like an imperative language. It's amusing actually.
00:00:16 <Gahhh> for loops and all.
00:00:17 <Cale> Cybertnt: put "deriving Show" at the end of the data declaration for Tape and you'll be able to print it too
00:02:35 <lightstep> fix is very nice for loops
00:02:42 <Cybertnt> "08:57:58    sylvan: yeah, just do something like main = do { let (str,tape) = process newTape ; print str}" <-- that doesnt work yntax error in declaration (unexpected `}', possibly due to bad layout)
00:03:26 <lightstep> Cybertnt, just format it like the rest of your codew, and it will be fine
00:19:18 <Cybertnt> ok nearly finished :D
00:22:32 <nlv11757__> hmmm does this have a chance of succeeding; reading a syntax tree from a file and using read :: .... to read it into the Haskell datatype to which this tree belongs....
00:23:00 <nlv11757__> it's a fairly large datatype i must add
00:24:26 <earthy> well, if (read :: Largetype) . (show :: Largetype) = id :: Largetype, yes.
00:24:58 <earthy> (oh, ofcourse, the file has to have been created with show in the first place... but I'm assuming that)
00:26:27 <nlv11757__> hehe see earthy, this is my problem; that syntax tree exists within an ocaml program, so i dumped it to a file using a pretty printer. Now i want to 'import' it into haskell.
00:26:41 <earthy> ah!
00:26:44 <nlv11757__> so my initial plan was...hoping read would work :P
00:26:46 <earthy> you didn't say that. :)
00:27:09 <earthy> anyway, if you derive read and the syntax tree is outputted from ocaml with the correct bracketing
00:27:34 <nlv11757__> hehe there's a fault somewhere, but read just gives no parse :P
00:27:48 <nlv11757__> deriving takes quite some seconds btw
00:27:52 <earthy> really
00:28:11 <earthy> try deriving show and generating some output for a sample member of your datatype
00:28:17 <earthy> then comparing that with what you generate from oaml
00:28:20 <earthy> ocaml even
00:28:52 <nlv11757__> so in principle it should be no problem even though my datatype is one representing a C program (yeah it's big)
00:29:08 * earthy nods
00:29:11 <earthy> in principle
00:29:14 <nlv11757__> :P
00:29:30 <earthy> :)
00:29:40 <nlv11757__> but in practice.... :P
00:29:58 <earthy> you'll have to rub some elbow grease :)
00:29:59 <nlv11757__> i will dump and search for differences, because writing a parser would take significantly more time i think
00:30:13 <earthy> oh yeah
00:30:29 <nlv11757__> or do you think the real way to go is define a parser anyway to slurp up that dump?
00:30:36 <earthy> that is: if you can't find differences by noon you're going to have to anyway
00:30:58 <nlv11757__> yeah, then the derived read is just not good/efficient enough
00:30:58 <earthy> but if you can, you've just saved yourself a shitload of wokrk
00:31:00 <earthy> -k
00:31:07 * nlv11757__ agrees
00:31:18 <nlv11757__> ok thanks, I'll be greasing my elbows then
00:31:24 <earthy> suc6
00:31:38 <nlv11757__> btw can i see how many colloquiems i followed somewhere :D
00:57:22 <Cybertnt> Cale: if i have "test x y" , and somebody just calls "test 90" is there a way to start "test 90 0" ?
00:59:40 <jlouis> Cybertnt: yes, let them call (\x -> test x 0)
01:00:08 <Cybertnt> i dont understand
01:01:30 <jlouis> foo x = test x [
01:01:35 <jlouis> foo x = test x 0
01:01:39 <jlouis> let them call foo
01:01:50 <Cybertnt> ah it cant ahve the same name?
01:01:53 <jlouis> you could also call (flip test 0)
01:02:08 <jlouis> There are no default arguments as far as I know
01:02:14 <Cybertnt> ok
01:02:20 <jlouis> (Rather, I tend not to use them)
01:02:36 <jlouis> maybe some extension have them
01:07:36 <musasabi> implicit parameters exist but are frowned upon.
01:08:27 <musasabi> if you need to pass complex arguments you can either pass a record (and provide values with sensible defaults) or use a monad which provides an envoronment.
01:26:04 <TonyRoberts> hey does haskell obsolete perl python and lisp?
01:26:18 <TonyRoberts> is haskell the next evolutionary step?
01:26:53 <lightstep> no
01:27:02 <lightstep> it didn't evolve from them
01:27:08 <lightstep> it's alien technology
01:27:39 <musasabi> Are you asking whether we feel like advocacy and world domination?
01:28:07 <earthy> well, I do feel like world domination. And scantily clad females.
01:28:19 <earthy> Who cares if it's almost freezing outside. :P
01:28:47 <musasabi> Well there *is* snow outside.
01:28:52 <earthy> anyway, lisp is before Haskell, Python, Perl and Haskell are parallel developments
01:29:34 <lightstep> it's hard to not be influenced from lisp, it being the first computer language with subroutines & recursion
01:29:56 <earthy> first with subroutines?
01:30:01 <earthy> come again?
01:30:16 <earthy> IAL had subroutines and is as old
01:30:36 <earthy> and recursion, at that
01:30:43 <lightstep> at '58?
01:30:46 * earthy nods
01:30:50 <lightstep> oh
01:30:51 <earthy> think so
01:31:04 <lightstep> i blame paul graham
01:31:09 <lightstep> and moore
01:31:29 <TonyRoberts> well
01:31:36 <TonyRoberts> does haskell do more than lisp
01:31:42 <TonyRoberts> lisp claims to be the msot powerful
01:31:48 <TonyRoberts> the cocky bastaarz
01:31:49 <musasabi> TonyRoberts: define more..
01:32:04 <TonyRoberts> dos haskell replace postgresql and python and apache
01:32:13 <earthy> hm. interesting: http://hopl.murdoch.edu.au/
01:32:19 <musasabi> TonyRoberts: certainly common lisp is larger than most other existing languages.
01:34:03 <nlv11757__> is there a boundry on how long one line can be in a string?
01:34:13 <musasabi> nlv11757__: no.
01:34:20 <nlv11757__> cause im writing out this syntax tree as one line i think, but there some weird cutoff
01:36:03 <earthy> did you flush all data to disk?
01:36:12 <earthy> before closing your filehandle?
01:36:54 <nlv11757__> :O im getting an error when opening the file with gedit about the character encoding
01:36:57 <nlv11757__> eek
01:38:42 <nlv11757__> could that be because my whole file is one line and pretty sickass long
01:38:49 <TonyRoberts> someone said that haskell breaks down under large scale websites because you get too many functions
01:38:52 <TonyRoberts> is this true?
01:42:55 <nlv11757__> the weird thing is, if i select everything in the file in an editor...choose to copy...and then past in a different file....i dont get the whole selection....
01:42:59 <musasabi> TonyRoberts: I heard C breaks down with complex software - is that true?
01:50:31 <araujo> Good morning.
02:02:33 <tromp> morning
02:03:38 <Itkovian> meuning
02:54:12 <a5> i'm thinking of a haskell library which would let you construct C-like data types in heap space, or in a file, with nodes with fields pointing to other nodes... does something like this exist?
02:55:33 <musasabi> a5: using e.g. hsc2hs ?
02:55:51 <a5> ... it seems like you could do much better than STL with the capacity for more complex data types. for instance STL won't let you define a set whose nodes are members of several linked lists, which is a rather common construct, because you have no control over the layout and allocation of the nodes
02:55:58 <a5> musasabi: i don't know
02:56:36 <a5> i was thinking you'd need more flexibility. you're suggesting using a C struct to define the layout right?
02:57:11 <musasabi> well your "C-like data types" seemed to suggest you want C compatiblity.
02:57:27 <musasabi> What is wrong with plain algebraic datatypes?
02:57:47 <Philippa> aside from never knowing accurately when they'll get unboxed, not a lot
02:57:47 <a5> no, i just mean that data is linearly stored
02:58:14 <earthy> a5: what do you want, exactly?
02:58:16 <Philippa> that might also be useful for cache coherancy purposes, but most of the time that's kinda considered the RTS's problem
02:58:35 <earthy> exact control over the layout of your data in memory?
02:58:43 <a5> yeah. like if you wanted to write a compiler or a kernel or a file system...
02:58:52 <earthy> you can do that
02:59:11 <earthy> using the ffi
02:59:15 <earthy> e.g.
02:59:32 <Philippa> just import constructors and accessors for the relevant types
02:59:39 * earthy nods
03:00:04 <earthy> and you could always use pointers and bytes directly from Haskell
03:00:13 <a5> is this back to the hsc2hs suggestion?
03:00:33 <Philippa> basically. It /would/ be nice to be able to allocate a heap then frig with it yourself, but hey
03:01:17 <a5> yeah, i think a lot more could be done if it were within haskell. first of all, you want to define data structures by composing other data structures
03:01:40 <a5> and secondly there could be dynamic type inference
03:01:43 <earthy> philippa: you  *can* allocate a heap and frig with it yourself
03:02:09 <Philippa> sans FFI?
03:02:29 <musasabi> well Foreign != FFI.
03:02:32 <earthy> see the QuotesPage on the hawiki, and then Simon Marlow's `How to translate C to Haskell'
03:02:49 <earthy> something like
03:02:49 <musasabi> The operations to mutilate raw memory just live under Foreign.
03:02:51 <earthy>  do
03:02:52 <earthy>   alloca $ \value -&gt; do
03:02:52 <earthy>   poke value (500000::Int)
03:02:52 <earthy>   allocaArray 4 $ \part_stack -&gt; do
03:02:54 <earthy>   alloca $ \part_ptr -&gt; do
03:02:57 <earthy>   poke part_ptr part_stack
03:02:59 <earthy>   let loop = do
03:03:02 <earthy>            val &lt;- peek value
03:03:04 <earthy>            if val == 0 then return () else do
03:03:07 <earthy>            p &lt;- peek part_ptr
03:03:09 <earthy>            poke p (val `rem` 10000)
03:03:12 <earthy>            poke part_ptr (p `plusPtr` 1)
03:03:15 <earthy>            poke value (val `quot` 10000)
03:03:17 <earthy>            loop
03:03:19 <earthy>   loop
03:03:22 <earthy> ofcourse, the &gt; and &lt; should be > and < respectively
03:03:30 <Philippa> fair enough
03:03:46 <earthy> also look at hOp and the NE2000 driver written in Haskell
03:05:33 <a5> the first thing, composition - e.g. list_head in the linux kernel. since they point to each other you need to do arithmetic to get back to the actual node. linux does it with macros but it could be more smooth. variable-sized types would complicate... i don't know.
03:05:50 <a5> earthy: where's that from?
03:06:17 <earthy> trying to find the ne2000 driver stuff
03:06:39 <earthy> anyway, hOp is at http://www.macs.hw.ac.uk/~sebc/hOp/
03:06:44 <a5> i mean the code snippet
03:07:34 <a5> hOp looks cool...
03:08:03 <earthy> owh, that snippet was written by Simon Marlow and can be found at http://www.haskell.org/hawiki/QuotesPage?action=highlight&value=Translate
03:08:17 <earthy> and then scroll for the highlighted Translate word
03:08:37 <a5> ah
03:08:40 <a5> sorry
03:09:03 <earthy> and also look at http://etudiants.insia.org/~jbobbio/hOp/
03:12:20 <a5> anyway, i tried doing something like this with C++ using multiple inheritance. it was OK, but not great. when i learned haskell and saw the FFI capabilities i thought the additional logic would be perfect
03:12:34 <a5> you'd be faster and clearer than STL
03:12:36 <a5> and more powerful
03:12:52 <a5> and it would map to files and other storage layers
03:13:16 <a5> so i was wondering if it was being worked on
03:17:46 <sylvan> Yes, hOp is very cool indeed. Maybe it'll turn into a "real" OS.. That would be sweet.
03:18:06 <sylvan> like piping data between two commands where the data is actually typed
03:18:20 <sylvan> I want a Haskell linux kernel dammit!
03:25:15 <a5> "start by porting UML to hOp"
04:09:22 * araujo was taking a look at hOp/House earlier on 
04:14:27 <Arsilan> HVa så DAvid er du der
04:19:58 <wilx`> So...
04:20:11 <wilx> How do I report GHC bug?
04:20:40 <wilx> My problem with segfaulting program when profiling.
04:21:10 <tromp> Please report it as a compiler bug to glasgow-haskell-bugs@haskell.org,
04:21:39 <Arsilan> David, haloooooo
04:21:40 <tromp> or http://sourceforge.net/projects/ghc/
04:22:34 <wilx> Ok.
04:23:44 <wilx> I'll try to reduce the test case first a bit...
04:24:02 <tromp> always a good idea
04:24:47 <tromp> i was able to remove 90% of a program while preserving a bug
04:29:14 <Arsilan> HEy forresten er der smukke piger på 16-17 år herinde
04:30:46 <Arsilan>  hvor er Dabid hene
04:38:24 <nlv11757__> uh oh
04:48:51 <Arsilan> david
05:00:09 <Arsilan> Daviid
05:00:17 <Arsilan> Er du der
06:11:47 <kuribas> How can you write recursive function types?
06:12:29 <kuribas> for example f :: int -> int -> Either int type_of_f
06:14:22 <Philippa> type Foo = Either Int (Int -> Int -> Foo)?
06:14:32 <Philippa> (then f :: Int -> Int -> Foo)
06:18:44 <kuribas> hmm, ERROR "/tmp/test.hs":1 - Recursive type synonym "Foo"
06:18:45 <kuribas> 	
06:19:56 <earthy> yes.
06:20:08 <earthy> recursion is only allowed with an additional constructor inbetween
06:20:46 <tromp> do you want a recursive function or a recursive type?
06:21:09 <kuribas> a recursive type
06:21:34 <kuribas> Is there a pastebot?
06:22:51 <tromp> try with data
06:23:30 <tromp> or newtype
06:24:13 <lisppaste2> kuribas pasted "recursive type" at http://paste.lisp.org/display/6634
06:28:09 <tromp> you can't apply Right to 2 arguments
06:28:25 <kuribas> tromp: right, I forgot the parentheses
06:30:39 <tromp> so what shld it be?
06:32:02 <kuribas> f 0 => 8
06:32:16 <kuribas> f 9 0 => 9
06:32:56 <tromp> that's not typable
06:33:17 <lightstep> tromp, it is
06:33:27 <lightstep> with type classes
06:33:39 <tromp> f 0 is an int while f 9 is (int->int)
06:35:25 <lisppaste2> kuribas annotated #6634 with "with typing" at http://paste.lisp.org/display/6634#1
06:36:46 <lightstep> http://okmij.org/ftp/Haskell/vararg-fn.lhs
06:37:51 <nlv11757__> why does this freakin read just say no parse $#@@!#$
06:40:52 <Arsilan> David er du der
06:41:44 <earthy> because it doesn't parse.
06:42:09 <earthy> maybe there's an excess \n at the end of the line?
06:42:21 <Arsilan> David er du der
06:42:44 * earthy thinks david isn't here
06:43:44 <bourbaki> moin
06:50:21 <nlv11757__> read can't handle \n?
06:50:37 <lightstep> it can
06:50:46 <nlv11757__> man this is such a frustrating and shitty occupation
07:11:04 * XTL curses at Shelbies and Vipers he can't catch
07:11:23 <nlv11757__> why isn't there a good nice c parser for haskell that is able to process the most dirtiest stuff out there AND builds a nice and usuable AST
07:14:17 <mflux> there was this some project that converted c-code into c-code that had the dirtiest stuff cleaned up
07:14:54 <mflux> also there exists a bison-definition for ansi c
07:24:56 <earthy> nlv11757__: *or* you could use the C parser from stratego, have it generate aterms and then use the haskell aterm lib to import that
07:28:09 <nlv11757__> is the ast that that stratego C parser produces a usefull one? i will perform program analysis on it...so it shouldn't be a one-to-one mapping so to say. CIL does miracles with that part...but it's in Ocaml, making me write a pretty printer to dump the AST, en using read to get it into haskell.
07:28:26 <earthy> ahaa
07:28:36 <nlv11757__> thats why i am even bothering with this approach
07:28:41 <earthy> well, then you're stuck getting the pretty printer to work, I guess
07:29:01 <earthy> since no, the SDF C grammar is not a very nicely abstracting one
07:29:21 <nlv11757__> :) indeed. But it sure is frustrating stuff hehehe
07:30:00 <nlv11757__> testing is also a bit of a problem.
07:30:08 <earthy> why?
07:30:24 <nlv11757__> my current approach: dump a c application, try to read....it fails....look for bugs in pretty printer
07:30:34 <nlv11757__> so with every C app i gain confidence, but still...
07:31:29 <earthy> ah, you're trying the known-ciphertext approach to decoding
07:31:45 <earthy> but you have more control than that
07:32:05 <nlv11757__> ?
07:32:34 <earthy> you could theoretically handcraft a fiendish piece of C designed to test all corners of the OCaml data type that you're pretty printing
07:32:50 <earthy> then pretty print that and try to read that
07:32:53 <earthy> if that works...
07:33:03 <nlv11757__> ah i know, but my C knowledge is not that good yet :P
07:33:26 <nlv11757__> why did i decide to do this project on analysis of C files you ask ...:P
07:33:46 <earthy> ah. you wouldn't know a int(*fp)(int *) from a int * fp(int *) then
07:34:54 <nlv11757__> not yet :P
07:35:03 <nlv11757__> doaitse said i didnt need extensive knowledge of C
07:35:06 <nlv11757__> hopefully he didnt lie
07:35:07 <earthy> hint: one of them is a pointer to a function ;)
07:35:21 <nlv11757__> otherwise im going to end up in a mental institute
07:35:46 <earthy> well, I know more innards of C than most would like, and I'm not in a... oh, wait. :)
07:35:58 <nlv11757__> hehehe
07:36:44 <nlv11757__> no but that was my worry also, i don't have that much C knowledge....so im really hoping doaitse was right
07:37:25 <earthy> trust me, it's just testing your datatype
07:37:36 <earthy> if you can construct a fully filled example of that OCaml datatype
07:37:39 <earthy> you're home free
07:38:21 <nlv11757__> well, CIL can handle the linux kernel...so im going to try that :P
07:40:38 <nlv11757__> i mean, basically what you are talking about is a C example using all of C's features...
07:40:50 <earthy> basically, yes
07:41:03 <earthy> the CIL datatype should give you a nice basis for that
07:41:52 <autrijus> hi chip :)
07:42:30 <nlv11757__> what do you mean with, the CIL datatype should give you a nice basis for that
07:42:48 <nlv11757__> (sry im clogging up so much of your time with questions btw)
07:51:23 <earthy> nlv: simple: look at the datatype definitions in CIL
07:51:41 <earthy> these, theoretically, form an algebraic structure for C programs
07:52:15 <earthy> thus, they should enable you to craft a wickedly fiendish structure that explores every corner of that datatype
07:52:50 <earthy> then, dumping that structure through your pretty printer should give you the worst input to your haskell code that *can* be generated
07:53:03 <earthy> thereby giving you a good test of your pretty printer and your read function
08:11:47 <nlv11757__> ahhh i see what you mean now earthy, but this would mean crafting an ocaml ast tree
08:11:49 <nlv11757__> eek
08:12:58 <earthy> well, you have 2 options... crafting the ast or crafting the C code
08:13:52 <earthy> given that you've written a pretty printer I'd say crafting the ast is simpler...
08:13:54 <earthy> but, good luck
08:16:25 <nlv11757__> ty
08:27:48 <wilx> Hmm, is it legal to use hGetContents on binary mode handle?
08:29:21 <autrijus> anyone got experience in using Parsec's expressionParser to handle ternary?
08:29:27 <autrijus> C-style ? : that is
08:29:45 <autrijus> I have this sinking feeling that I have to abandon expressionParser.
08:29:52 <autrijus> to make that work
08:31:24 <nlv11757__> sorry, not here
08:47:29 <kosmikus> autrijus: you could modify expressionParser
08:48:01 <autrijus> kosmikus: not seeing how :-/
08:48:11 <autrijus> inside the makeParser foldl
08:48:17 <autrijus> it can only see the terms higher up in prec table
08:48:34 <autrijus> but that won't do, because ? : must accept something below its level inbetween ? and :
08:48:48 <autrijus> but reject them on the left of ? and right of :
08:48:52 <autrijus> it is very annoying.
08:51:29 <kosmikus> could you somehow view the whole thing from ? to : as an infix binary operator?
08:51:41 <autrijus> ugh.
08:51:42 <kosmikus> the binary operators can be parametrized over arbitrary parsers, can't they?
08:52:08 <autrijus> I see where you are going with this.
08:52:10 <autrijus> let me think a bit.
08:57:42 <Itkovian> hmm
08:57:47 * Itkovian thinks
09:05:15 <autrijus> kosmikus++
09:05:15 <autrijus> kosmikus++
09:05:15 <autrijus> kosmikus++
09:05:17 <autrijus> it Just Works!
09:06:15 <Oejet> @karma kosmikus +1
09:06:33 <Oejet> Hm, lambdabot is out shopping.
09:07:48 <Lemmih> Bah. I'm still stuck with bad karma for automating the binding process to C++ libraries /-:
09:09:54 <Oejet> Lemmih: Heh.  What happened to your little friend Arlijan?
09:11:00 <Lemmih> He left for good, I hope.
09:17:00 <autrijus> anyone know the name of kosimus so I can credit him/her in AUTHORS file?
09:17:20 <nlv11757__> kosmikus?
09:17:31 <autrijus> yeah, kosmikus.
09:17:37 <nlv11757__> Andres L"oh
09:17:41 <nlv11757__> o umlaud that is
09:17:44 <autrijus> danke.
09:17:48 <nlv11757__> np
09:18:22 <kosmikus> that's me .. er, does that mean this it worked?
09:18:28 <kosmikus> s/this/that/
09:18:48 <nlv11757__> hehe sorry for exposing you andres :P
09:19:01 <autrijus> kosmikus: yes, it worked beautifully.
09:19:01 <kosmikus> I think most people around here know my identity, so np
09:19:26 <kosmikus> autrijus: great, good to know
09:21:41 <autrijus> ternOp pre post syn = (`Infix` AssocRight) $ do
09:21:41 <autrijus>     symbol pre ; y <- parseTightOp ; symbol post
09:21:41 <autrijus>     return $ \x z -> Syn syn [x, y, z]
09:21:47 <autrijus> that's all it takes.
09:26:29 <tuomov> is there some nice profiler output viewer thing?
09:26:53 <Muad_Dibber> yeah, lets all flush our privacy on irc ;)
09:28:51 <bringert> this channel is aggressively logged
09:29:10 <bringert> stuff shows up on google very quickly and is often ranked highly
09:29:20 <bringert> I asked some obscure question here once
09:29:24 <bringert> got no answer
09:29:33 <bringert> googled for it a couple of days later
09:29:49 <bringert> only hit is the log of me asking the question here
09:30:06 <kosmikus> yes, I noticed that too
09:30:36 <kosmikus> anyway, my identity has been discussed here before, so the damage has been done a long time ago
09:32:38 <Igloo> . o O (id :: kosmikus -> kosmikus)
09:37:10 <nlv11757__> if i do a read of a big thing....will it say no parse if it grew out of memory?
09:37:18 <nlv11757__> if not, i can rule out this possibility
09:37:41 <Igloo> It will die with an out of memory error
09:37:46 <nlv11757__> sweet
09:37:48 <Oejet> Maybe the topic or something should state that this channel is agressively logged.
09:39:08 <nlv11757__> im off to home, it's getting dark
09:39:29 <nlv11757__> later and thanks for all the help
09:39:32 <Muad_Dibber> but kosmikus , ur famous :)
09:40:06 <kosmikus> Muad_Dibber: how so?
09:40:28 <Muad_Dibber> you one of the authors of Generic Haskell
09:40:30 <Muad_Dibber> </spam>
09:40:31 <Muad_Dibber> :)
09:41:23 <kosmikus> I guess that lhs2TeX has by far more users than GH these days
09:42:49 <Igloo> Is it worth reading scrollback to find out what people are talking about?
09:44:45 <kosmikus> no :)
09:45:54 <wilx> Hmm, in a monad, can I do early return? Something like do { ....; if x then returnEarlyWith val else return () ; rest of computation }
09:46:19 <tromp> if bla then return x else do ...
09:47:22 <wilx> Well, that would force me to indent the whole else part and if there is another condition that could mean early return then I would have to indent its else part too etc.
09:48:04 <ibid> wilx: there is no early return in monads in general
09:48:29 <wilx> Hmm, maybe I should reread the Monads tutorial, there was something about continuations...maybe that could help?
09:48:34 <tromp> you needn't indent further
09:48:45 <ibid> wilx: particular monads are be free to implement one (though i know of none that do)
09:49:40 <bourbaki> moin
09:49:41 <tromp> here's an exmaple from my code, wilx:
09:49:43 <tromp>     let maxToFront t@(a@(h,_):t') = do
09:49:43 <tromp>          hv <- readArray hist h
09:49:43 <tromp>          if null t' then return (hv,t) else do
09:49:43 <tromp>          (max, b:t'') <- maxToFront t'
09:49:43 <tromp>          return $ if (hv > max) then (hv, a:b:t'') else (max, b:a:t'')
09:50:00 <wilx> Hmm...
09:50:51 <tromp> afk to diner
10:25:22 <stepcut> the quotes page needs a way to reference individual quotes -- like bash.org...
11:02:39 <musasabi> evening
11:07:47 <Oejet> Evening, musasabi.
11:08:56 <musasabi> hello Oejet, hacking anything nice?
11:11:05 <Oejet> musasabi: Doing an Eclipse setup for the software engineering course and making a map drawing program for a special projection in Java.  Oh, and hacking a little on my Haskell IRC bot.  :-)
11:11:33 <_JusSx_> where can i download the code of your haskell bot?
11:12:50 <Oejet> _JusSx_: You can't yet. :-)
11:13:00 <_JusSx_> can you DCC IT?
11:13:07 <musasabi> irc bot sounds nice..
11:13:20 <Oejet> _JusSx_: What is DCC?
11:13:23 <musasabi> Oejet: drop the link sometime :-)
11:13:24 <_JusSx_> lol
11:13:44 <_JusSx_> send it off
11:14:12 <Oejet> Shure I will when I have cleaned it up a bit.  Written a small manual and so on.
11:14:38 <_JusSx_> why not now?
11:14:56 <_JusSx_> can you open a cvs repository for it
11:15:09 <_JusSx_> you might* open a cvs repository for it
11:15:09 <Muad_Dibber> eww @ cvs
11:15:14 <_JusSx_> darc is better ok
11:15:23 <musasabi> publishing things which are too alpha is not nice.
11:15:23 <Muad_Dibber> svn is better as well
11:15:32 * musasabi doesn't like to do that either
11:15:56 <_JusSx_> musasabi: i don't wanna Oejet publish it i would like to look the code
11:18:09 <Oejet> _JusSx_: http://www.student.dtu.dk/~s022018/Temporary/IRC-klient/
11:19:37 <_JusSx_> Oejet: thanx a lot
11:20:29 <Oejet> _JusSx_: Look in Main.hs.
11:20:39 <_JusSx_> i'm reading it
11:21:13 <Oejet> _JusSx_: Note that the server/channel is hardcoded, so please don't run without changing. :-P
11:21:54 <_JusSx_> Oejet: don't worry
11:22:05 <_JusSx_> Oejet: thanx for advicing
11:26:50 <Oejet> _JusSx_: Fetch again.
11:30:21 <_JusSx_> ok i did
11:31:03 <_JusSx_> Oejet: kde or gnome supporter?
11:32:05 <_JusSx_> once i coded a bot in C
11:33:32 <Oejet> _JusSx_: GoboLinux user. :-)   P.S. Comes with KDE. GNOME is still not packaged well enough (yet).
11:41:12 <_JusSx_> Marco monteiro
11:50:02 <Darkbaron> bonjour tous le monde :)
11:50:23 <_JusSx_> scottish please
11:52:55 <_JusSx_> in #ocaml channel you are allowed to speak french
11:53:15 <Darkbaron> _JusSx_ merci :)
11:53:28 <_JusSx_> lol
11:53:41 <Darkbaron> by :)
11:53:51 <tuomov> apparently ghc doesn't optimize hPutStr h (x ++ y) very well. it allocates a lot of memory. mapM_ (hPutStr h) [x, y] fixed some riot memory problems
12:02:56 <CosmicRay> MegaMonad: french?
12:02:56 <MegaMonad> CosmicRay: (I.e. French and swedish.
12:04:05 <Oejet> MegaMonad: Danish, then?
12:04:06 <MegaMonad> Oejet: Shapr: begriber is begriper in danish.
12:04:22 <Oejet> Heh.
12:18:06 <CosmicRay> Igloo: build in progress now.
12:18:12 <Igloo> Cool, thanks
12:34:51 <wilx> Hmm, my LZW implementation apparently sucks hard.
12:35:57 <wilx> 7M input file, 40 times flushed dictionory and then died because heap limit is 500MB :)
12:36:03 <CosmicRay> hah
12:36:27 <CosmicRay> wilx: what, are you converting the file to [Bool] representing each bit, ala Igloo? :-)
12:36:43 <wilx> Heh, I am not that far yet :))
12:36:59 <Oejet> wilx: Can we see some profile numbers?
12:37:02 <wilx> All I have is a function that takes [Word8] and returns [Code]
12:37:36 <wilx> Oejet, nope, because it segfaults right away when I try to profile it.
12:37:47 <CosmicRay> wilx: sneaky, if you type Code = Bool :-)
12:38:14 <wilx> Nah, type Code = Word32.
12:38:19 * Igloo waves his hands - constant factors  :-)
12:38:41 <CosmicRay> Igloo: heh
12:38:48 * Igloo files a GHC bug for it not producing optimal code from my specification
12:38:52 <CosmicRay> haha
12:39:05 <CosmicRay> Igloo: fortunately, you'll have to forward it upstream yourself :-)
12:39:09 <wilx> Those Code's will have to be converted later to bit packets for storage.
12:39:19 <Igloo> Hmm, last I checked my name wasn't Simon
12:39:20 <CosmicRay> build still churning along
12:39:32 <Igloo> Good good  :-)
12:39:38 <CosmicRay> still in stage1
12:39:50 <Igloo> Unfortunately the stage 2 build builds more modules than stage 1, I think, so just getting there isn't any guarantee  :-/
12:40:33 <CosmicRay> are you particularly concerned about alpha, or is this just another datapoint?
12:41:08 <Igloo> I found alpha needed the patch I gave you, so I'd like to be sure that's the only case before throwing it at buildds again
12:41:32 <CosmicRay> ok.
13:00:53 <CosmicRay> stage1/stranal/DmdAnal sounds like a very interesting file.
13:01:25 <CosmicRay> nah, watching ghc build isn't boring at all...
13:02:01 * wagle is worried about CosmicRay 
13:02:10 <wilx> Well, if there is anybody interested in finding out why the thing borks with profiling on I have bundled it and put it here: http://logout.sh.cvut.cz/~wilx/lzw-test.tar.gz
13:03:25 <Igloo> Hey, you only have to do it once  :-)
13:06:53 <CosmicRay> Igloo: assuming that it works, yes :-)
13:09:13 <CosmicRay> MegaMonad: are you bored?
13:09:14 <MegaMonad> CosmicRay: I am just easily bored, thus forcing me to build it for a testsuite to me.
13:09:29 <CosmicRay> MegaMonad: wagle needs some of your special advice.
13:09:30 <MegaMonad> CosmicRay: It's the beatnik theory of buffers make sense if you don't need the eq function though, it will never do anything special in the case that involves xml end up with my right hand side a data class? Or is there something i have to specialize gshow for some advice.
13:09:46 <CosmicRay> MegaMonad: I'm sure wagle will appreciate that.
13:09:46 <MegaMonad> CosmicRay: I appreciate all the text out just now, i agree you're not trying to sell it to look at these responses?
13:10:51 <Lemmih> wilx: 404
13:11:06 <wilx> oops
13:11:16 <wilx> http://logout.sh.cvut.cz/~wilx/lzw/lzw-test.tar.gz
13:11:35 <Igloo> CosmicRay: Do you think we should hold hugs out of sarge until we are happy for ghc 6.4 to go in?
13:11:44 <CosmicRay> Igloo: yes
13:11:58 <CosmicRay> Igloo: we should try to have all three move together
13:12:11 <Igloo> Is the third nhc?
13:12:15 <CosmicRay> Igloo: right
13:12:20 <CosmicRay> Igloo: it uses fptools also, right?
13:12:20 * Lemmih slaps wilx for packing a file which doesn't expand in its own subdir.
13:12:20 <Igloo> Hmm
13:12:30 <wilx> lol, sorry :))
13:12:37 <CosmicRay> @lart wilx
13:12:43 <CosmicRay> rats.
13:12:45 <wilx> :)
13:13:06 <CosmicRay> Igloo: I've found a number of incompatibilities in my code between ghc 6.2 and hugs
13:13:13 <CosmicRay> Igloo: that are due to changes in fptools
13:13:30 <CosmicRay> Igloo: for instance, wrote instance FiniteMap show in one of my modules, since a FiniteMap wasn't showable.
13:13:38 <stepcut> should I use hsql 1.4 or hsql from cvs with haskelldb (from cvs)
13:13:40 <CosmicRay> Igloo: well, now it is, so hugs raises an error
13:13:46 <CosmicRay> Igloo: and if I take it out, ghc 6.2 raises an error
13:14:01 <wilx> Tee hee hee.
13:14:01 <CosmicRay> stepcut: I have found haskelldb to br problematic
13:14:19 <CosmicRay> stepcut: but I have used it with hsql release
13:14:35 <Igloo> Oh, did you work out what was wrong with the inflate code with new libraries BTW?
13:14:36 <CosmicRay> Igloo: so the only away around that would be ugly cppish hackery
13:14:44 <stepcut> CosmicRay: haskelldb from cvs? Or just haskelldb in general?
13:14:55 <CosmicRay> Igloo: it wasn't the code, IIRC, it was my test not opening a file in binary mode
13:15:00 <CosmicRay> stepcut: in general
13:15:09 <CosmicRay> stepcut: but yes, the cvs version produced some very weird query reports
13:15:15 <CosmicRay> stepcut: see the bugs submitted by jgoerzen on sf
13:15:19 <stepcut> CosmicRay: ok
13:16:17 <CosmicRay> Igloo: but I just disabled the hugs tests for now, so I could get a buildable ghc package
13:16:22 <wilx> Lemmih, does it crash for you too when you try to run it with profiling on?
13:16:32 <CosmicRay> Igloo: it made no sense to fix all these things for hugs, onyl to have them non-buildable with ghc
13:16:57 <CosmicRay> Igloo: so, long story short, I'm a big proponent of ghc and nhc98 in sid asap, and moving them to testing all at once.
13:16:59 <Lemmih> wilx: Nope.
13:17:13 <Lemmih> wilx: Gonna try with your build script now.
13:17:24 <Lemmih> wilx: Works great.
13:18:13 <Lemmih> Yo shapr.
13:18:20 <CosmicRay> hey shapr
13:18:33 <shapr> y0
13:19:10 <Lemmih> wilx: What's your system specs?
13:19:40 <wilx> Windows XP, GHC 6.4, Athlon 1.2 TBird, 512MB RAM...
13:20:02 <xerox> Hiya shapr
13:20:06 <shapr> y0 xerox
13:20:11 <CosmicRay> MegaMonad: shapr is back
13:20:11 <MegaMonad> CosmicRay: Shapr shows just a test application, first.
13:20:21 <shapr> I don't think I'm going to have time to work on TMR at all this month.
13:21:13 <Igloo> CosmicRay: Can you give me some code that works with the old version but not the new version?
13:21:32 <Igloo> For what looked like treating the input as utf-8
13:21:58 <Igloo> Oh, was it only hugs not ghc 6.4 that changed behaviour?
13:21:59 <CosmicRay> Igloo: well, I was treating the input as a binary string
13:22:04 <CosmicRay> Igloo: that is unclear
13:22:13 <Igloo> I was testing old hugs and new ghc when looking for a difference, hang on a tick
13:22:14 <CosmicRay> Igloo: but hugs can be fixed by openBinaryFile
13:22:17 <CosmicRay> and that won't harm ghc
13:22:21 <Lemmih> wilx: It's using an awful lot of memory... coming up on 85%
13:22:22 <CosmicRay> so I can just do that
13:22:23 <Igloo> Actually, I'll finish my reply to you first
13:22:50 <wilx> Lemmih, yeah, it does.
13:23:19 <Igloo> Right
13:23:31 <musasabi> evening shapr
13:23:35 <shapr> hei musasabi
13:23:54 <musasabi> busy with work these days?
13:23:54 <Lemmih> wilx: How long should it take to complete?
13:24:18 <wilx> lol, I have no idea, it has never completed for me yet :))
13:24:23 <wilx> Better kill it :)
13:24:42 <wilx> It worked for small files though.
13:24:54 <Igloo> OK, I can get different behaviour from new hugs and new ghc, but I can't get an error
13:25:10 <Igloo> CosmicRay: I'd really like to know what input gave that error
13:25:16 <shapr> I really wish I could get funding to rewrite Plone/Zope in Haskell. They do not have enough separation of concerns. My long harrowed journey has the simple goal of moving data out of the existing installation and into the new one.
13:25:18 * shapr sighs
13:25:25 <wilx> At least I know that it doesn't segfault on any other system than Windows.
13:25:44 <CosmicRay> Igloo: just grab missingh 0.9.1 from sid and run make test-hugs with the new hugs
13:26:11 <CosmicRay> Igloo: er, you may have to re-fix the ctime and finitemap stuff first
13:26:16 <Lemmih> wilx: LZW.encodeLetter is a big sinner.
13:26:20 <CosmicRay> but you can see the testsuite in the testsrc/ dir
13:27:27 <wilx> I has finished?
13:27:55 <wilx> Err.
13:28:01 <wilx> s/I/It/
13:28:33 <Lemmih> Yes, I told it to.
13:28:41 <wilx> :)
13:29:20 <Igloo> Excellent, empty.gz causes it
13:30:28 <Lemmih> wilx: LZW.nextNode is also evil.
13:30:45 <CosmicRay> Igloo: heh
13:31:02 <wilx> Heh, is it that bad?
13:31:04 <wilx> Huh.
13:31:27 <Lemmih> wilx: And charsToWord8.
13:31:36 <wilx> What is the criteria for ebilness?
13:32:41 <CosmicRay> MegaMonad:  What is the criteria for ebilness?
13:32:41 <Lemmih> How much memory they allocate. nextNode: 25%, encodeLetter: 15% and charsToWord8: 13%.
13:32:41 <MegaMonad> CosmicRay: Shapr: just something basic, or is the criteria for ebilness?
13:32:52 <shapr> ebilness, definitely.
13:32:55 <CosmicRay> hehe
13:32:58 * boegel bounces
13:33:02 <shapr> hoi boegel
13:33:04 <CosmicRay> yo boegel
13:33:12 <wilx> Huh.
13:33:13 * boegel waves
13:33:16 <wilx> Interesting.
13:34:47 <wilx> Hmm, is GHC 6.4 in FreeBSD ports? I think I might want to reboot and test it there...
13:36:21 <Igloo> This seems most peculiar
13:40:22 <shapr> I think I'm going to put a "delayed by deadlines" notice on The Monad.Reader and then I won't have to rush to setup the author wiki I've been talking about, and recruit for authors.
13:40:25 * Igloo gets it down to a 16 byte string
13:40:40 <shapr> Unless someone else wants to be editor this month?
13:44:04 <Remi> shapr: while it probably won't be for issue #2 I am interested in writing for it
13:44:18 <Remi> and I may even have a subject :D
13:44:50 <shapr> I could think of a bunch of subjects if you want suggestions.
13:45:34 <Remi> I'm currently finding out whether trying to solve some problems with GHC's Integer implementation is going to be below my head, and it appears to be doable :)
13:45:41 <shapr> I usually suggest subjects that match with the interest of the person themself, but I have been unable to find your homepage and so I don't have much insight into your interests.
13:45:55 <musasabi> good night
13:45:56 <Remi> uhm, my homepage...
13:45:58 <Remi> night
13:46:12 <shapr> g'night musasabi
13:46:33 <shapr> Oh hey, I sent an email to Ward Cunningham about distributed serverless wikis using darcs, and he seems interested in the idea.
13:46:38 <Remi> I don't really have any homepage new enough to talk about haskell, even though I've been toying with haskell for something like 3 years now
13:47:46 <wilx> Heh.
13:47:49 * Remi puts a few results of `ls' on his hawiki-page
13:47:54 <wilx> I hope that nobody looks at my site.
13:48:04 <Remi> you just have to tell us :P
13:48:20 <Igloo> Yo Isaac!
13:48:32 <Igloo> CosmicRay: You aren't objecting to the provides, right?
13:48:56 <CosmicRay> Igloo: no, I'm not objecting
13:49:16 <CosmicRay> Igloo: I'm saying I don't think they're really necessary, but go ahead if you feel like it :-)
13:49:26 <CosmicRay> Igloo: but would be good you check with syntaxninja before providing cabal
13:50:19 <Remi> @wiki RemiTurk
13:50:26 <Remi> *wrong command, apparently*
13:51:22 <CosmicRay> Igloo: I do think that splitting all of them off is going to just be a hassle
13:51:35 <CosmicRay> Igloo: but going the ocaml route with a ghc-nox would make some sense
13:51:46 <CosmicRay> Remi: no, lambdabot is not connected now
13:51:50 <CosmicRay> shapr: lambdabot is gone!
13:51:57 <Igloo> CosmicRay: readline is going to be split off to make migrating to a new libreadline sane
13:51:57 <shapr> Checking now
13:51:57 <CosmicRay> MegaMonad: where is lambdabot?
13:51:59 <MegaMonad> CosmicRay: What did i pick on for something they told us we have lambdabot.
13:52:04 <CosmicRay> Igloo: ahh
13:52:19 <CosmicRay> Igloo: ok then, your plan makes sense.
13:52:25 <Igloo> I have no particular plans to split off the others, although it's worth noting a libsomethingelse-2.0 might be uploaded at some point
13:52:41 <CosmicRay> Igloo: right, but a good number of those are pure haskell, or base/essential stuff
13:52:55 <Igloo> Although given that would require ghc6 anyway I guess that doesn't really matter  :-)
13:53:21 <Igloo> The main reason is so the auto-cabal-deb-magic tool can Just Work, anyway
13:53:47 <CosmicRay> Igloo: are you speaking of my tool, or some uber yet-to-be-invented tool?
13:53:54 <CosmicRay> because mine is not that smart :-)
13:54:10 <Igloo> I'm not sure if your tool is meant for something else or is just buggy
13:54:22 <CosmicRay> my tool does not generate debian/control
13:54:27 <Igloo> And yes, I regard stupidity as a bug in this instance  :-)
13:54:28 <CosmicRay> it does parse it
13:54:33 <CosmicRay> ah :-)
13:54:52 <CosmicRay> Igloo: I stopped hacking on it when it worked.  had enough of perl hacking for the month. :-)
13:54:58 <Igloo> If your stuff is purely meant for a dh_haskell command that is used during build time then another toold could do what I'm thinking of instead
13:55:08 <CosmicRay> yeah, probably so.
13:55:19 <CosmicRay> they could likely work well together, though
13:55:28 <CosmicRay> it sounds like you want a dh_make for cabal
13:55:33 <Igloo> Yeah, the one I'm thinkin of would put a call to yours in the debian/rules file
13:55:54 <CosmicRay> that would be a nice tool.
13:56:06 <Igloo> Yeah. Now we just need someone to write it  :-)
13:56:31 <Igloo> The hard bit is writing the update mode, where it offers to add in new build deps and remove old ones, of course
13:56:46 <Igloo> Probably coupled with overrides
13:57:02 * CosmicRay hands igloo emacs and says "have at it" :-)
13:57:24 <Igloo> Ah, now, y'see, if you'd said vim I'd have just written it  :-P
13:57:28 <CosmicRay> my next project is probably going to be a binding to dpkg-dev and libapt-pkg-dev
13:57:38 <CosmicRay> bah, yet another squandered opportunity on my part!
13:57:43 <Igloo> A Haskell binding?
13:57:50 <CosmicRay> yes
13:57:56 <Igloo> To do what?
13:58:19 <Igloo> And you do know there are plans to libise dpkg, right?
13:58:20 <CosmicRay> well, the first app would be a rewrite of srcinst
13:58:31 <CosmicRay> libise?
13:58:35 <Igloo> Make into a library
13:58:54 <CosmicRay> ah.
13:59:03 <Igloo> If you want to move fast then this won't help you, though
13:59:06 <CosmicRay> yeah, I probably won't need much from dpkg though
13:59:13 <SyntaxNinja> hi al
13:59:15 <SyntaxNinja> all
13:59:28 <CosmicRay> you know me.  I spend a week trying to figure out what to do, then do it in an evening :-)
13:59:29 <Igloo> Yo Syn
13:59:41 <Igloo> SyntaxNinja: We need input  :-)
13:59:46 <CosmicRay> except in the case of building ghc for aix.
14:00:02 * SyntaxNinja tries to read back
14:00:07 <SyntaxNinja> can you summarize the question?
14:00:24 <wagle> CosmicRay: whoa..  you are fast figuring it out
14:00:31 <Igloo> Speaking of which, is ghc still churning on the alpha?
14:00:42 <CosmicRay> Igloo: still in stage1.
14:00:47 <Igloo> SyntaxNinja: The important questions are all in the mailing list posts I think
14:00:52 <CosmicRay> wagle: what, aix?  or my own work pattern? :-)
14:01:00 <wagle> work pattern
14:01:11 <CosmicRay> wagle: it seems a lot of hackers work that way
14:01:27 <CosmicRay> sorta like sherlock holmes, but without the cocaine.
14:01:53 <wagle> i feel like the child who doesnt speak until the age of two, then suddenly starts talking in complete sentences
14:02:13 <wagle> software engineer metrics?  ha!
14:02:22 <CosmicRay> wagle: I'm just lucky if I do less than one stupid thing per day in #haskell :-)
14:02:26 <wagle> i'm either done or "i dunno"
14:03:12 <wagle> anti-engineering?
14:03:17 * Remi notes lambdabot has joined
14:03:25 <wagle> @yo!
14:03:26 <lambdabot> Sorry, I don't know the command "yo!", try "lambdabot: @listcommands"
14:03:35 <Remi> @wiki RemiTurk
14:03:36 <lambdabot> http://www.haskell.org/hawiki/RemiTurk
14:04:19 <Remi> (for anyone wanting to have any slight idea what I'm messing around with haskell)
14:04:55 <shapr> I tend to say significantly more than one stupid thing per day when I'm on #haskell. But you gotta learn somehow.
14:05:25 <shapr> Remi: have you seen FunWorlds/HOpenGL?
14:05:48 <SyntaxNinja> Igloo: CosmicRay, I like the idea of the provides... I don't know what should happen if we want to release a new cabal version, for instance, though.
14:06:18 <shapr> As long as the old version of Cabal can install the new version...
14:06:21 <Remi> shapr: I have seen HOpenGL, googling for FunWorlds right now
14:06:21 <SyntaxNinja> I wouldn't be against an RC bug against HUGS (before it hits sarge!!) until GHC hits sarge as well
14:06:22 <Igloo> It would all just work. And only the new cabal version would be able to satisfy a versioned dep
14:06:51 <SyntaxNinja> shapr: we're talking about debian packaging right now
14:06:58 <shapr> oh, oops.
14:07:17 <Remi> oh damn, it's not going to be useful for creating artificial-life/evolution-simulation-stuff I hope?
14:07:18 <SyntaxNinja> Igloo: hmm... I guess a new cabal wouldn't get in the way of the old cabal.
14:07:52 <Igloo> If it does then we will have the same problem with any other library, AIUI
14:07:55 * Remi has begun implementing some simple evolutionary thingies in some 5 languages the last 10 years ;)
14:07:58 <SyntaxNinja> I would like to try that out; I don't have a lot of experience with GHC 6.4 yet
14:08:43 <SyntaxNinja> Igloo: the stuff in parens on the ghc-pkg -l output are hidden packages
14:08:54 <Igloo> What does that mean exactly?
14:10:37 <SyntaxNinja> Igloo: things in parens require the -package flag to see the modules.
14:10:39 * Igloo files a hugs bug
14:10:49 <SyntaxNinja> Igloo: THE hugs bug?
14:10:52 <Igloo> yup
14:11:10 <SyntaxNinja> ross might get mad at me... we'll see.
14:11:11 <Igloo> Hang on, I though that was true for all cabal packages?
14:13:09 <SyntaxNinja> Igloo: that's the default, but then the user can say "ghc-pkg expose Foo"
14:13:22 <SyntaxNinja> and after that you won't need the -package flag for Foo
14:14:34 * Igloo reads the getContents bug report
14:14:52 <Igloo> Hmm
14:15:02 <Igloo> SyntaxNinja: I'll test that again in a sec
14:15:16 <Igloo> SyntaxNinja: So all packages are either exposed (not in parens) or hidden (in parens)?
14:19:36 <SyntaxNinja> Igloo: ja
14:19:55 <SyntaxNinja> Igloo: http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#package-management
14:21:44 <Igloo> $ cat test.hs
14:21:45 <Igloo> import System.Console.Readline
14:21:45 <Igloo> main = return ()
14:21:48 <Igloo> $ ghc test.hs -o test
14:21:48 <Igloo> test.o(.text+0xf9): In function `__stginit_Main_':
14:21:48 <Igloo> : undefined reference to `__stginit_SystemziConsoleziReadline_'
14:21:48 <Igloo> collect2: ld returned 1 exit status
14:21:54 <Remi> --make
14:22:19 <Igloo> Ah. Hmm.
14:22:26 <SyntaxNinja> Igloo: does that not happen w/ -package flag?
14:22:32 <Igloo> No
14:22:41 <Igloo> But --make does indeed fix it
14:22:45 <Remi> my impression is that basically, unless you're creating huge Makefile's, you almost always want --interactive or --make
14:22:48 <SyntaxNinja> no it doesn't not happen?
14:22:59 <SyntaxNinja> Remi: huge makefile? a think of the past! ;)
14:23:10 <Igloo> ghc test.hs -o test -package readline   succeeds
14:23:18 <Igloo> I dislike this a lot
14:23:31 <Igloo> It means there's no check that the cabal build-depends of cabal packages are correct
14:24:07 <SyntaxNinja> Igloo: eh? -package readline, OR --make works?
14:24:14 <Igloo> yes
14:24:21 <Igloo> Either works
14:24:33 <Igloo> Or both, but not neither
14:24:38 <Remi> /var/tmp/ghc-6.4% find -name Makefile -exec wc -l {} \; | sort -n | tail -5
14:24:38 <Remi>     143 ./libraries/base/Makefile
14:24:38 <Remi>     153 ./ghc/includes/Makefile
14:24:38 <Remi>     364 ./ghc/rts/Makefile
14:24:38 <Remi>     469 ./Makefile
14:24:39 <Remi>     773 ./ghc/compiler/Makefile
14:25:44 <Remi> basically, ghc without --make (or --interactive) is meant for Special Advanced Experienced Do Exactly What I Tell You To Do And Neither Anything More Nor Anything Less Control(TM) these days
14:25:50 <Remi> AFAIK
14:26:44 <SyntaxNinja> Igloo: it sounds like a bug, or I'm confused
14:27:04 <Igloo> A bug that it doesn't work with neither?
14:27:21 <SyntaxNinja> Igloo: yeah
14:27:28 <SyntaxNinja> my simple test was
14:27:31 <SyntaxNinja> ghc-pkg hide Cabal
14:27:39 <SyntaxNinja> ghci ... :t Distribution.Simple.defaultMain
14:27:43 <SyntaxNinja> (can't find  it)
14:27:53 <SyntaxNinja> ghci -package Cabal -- check type, finds it just fine
14:28:00 <SyntaxNinja> ghc-pkg expose Cabal
14:28:09 <SyntaxNinja> ghci -- check type, finds it just fine
14:28:32 * Igloo would really like it if broken cabal deps were detected somehow
14:29:06 <Remi> SyntaxNinja: are you sure? ghc 6.2.1 behaves the same (readline without -package or --make dies while linking)
14:30:03 <SyntaxNinja> Remi: strange I never noticed that behavior; so you could use either --make or -package?
14:30:43 <Igloo> SyntaxNinja: When cabal builds ghc packages, does it use --make?
14:31:12 <SyntaxNinja> don't remember offhand
14:31:29 <Igloo> SyntaxNinja: And does this mean I should be providing libghc6util-dev etc?
14:31:44 <Igloo> I'm a bit wary because they're rather generic names and I think some are going away
14:32:51 <Remi> @wiki HaskellIrcPastePage
14:32:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:32:59 <SyntaxNinja> I don't know that it's necessary to do all of them.
14:33:19 <SyntaxNinja> For the ones where there is a development branch outside of the fptools tree, it makes sense
14:33:21 <SyntaxNinja> like cabal
14:33:35 <Remi> SyntaxNinja: I pasted it on the wiki
14:34:45 <Igloo> It's worth doing anything a cabal package might dep on
14:35:02 <Igloo> Right, the hidden ones are exactly those in hslibs
14:35:22 <SyntaxNinja> Igloo: I don't really understand your concern about cabal dependencies yet
14:35:25 <Igloo> So I'm not going to provide them as cabal packages shouldn't be using them
14:36:08 <SyntaxNinja> Igloo: when you use ghc-pkg to install a package, it checks to make sure that its dependencies are already installed
14:36:39 <Igloo> Suppose I write a cabal package using a number of modules, including some from readline
14:36:53 <Igloo> I look at the modules and fill in the dependency list, but forget readline
14:37:00 <Igloo> Something should tell me I've done something wrong
14:37:09 <SyntaxNinja> if you try to install your package, it'll complain
14:37:13 <SyntaxNinja> oh, hm
14:37:20 <Igloo> But I have readline installed
14:38:22 <SyntaxNinja> yeah, I think you should raise your concern on libraries@
14:38:24 <Igloo> (can someone easily test whether building such a ghc package
14:38:27 <SyntaxNinja> I am at work right now :(
14:38:40 <Igloo> such a cabal package for ghc works?)
14:39:21 <SyntaxNinja> Remi: thanks for confirming that.
15:12:27 <tochiro> is there any lib for haskell similar to libcurl ? (or even better a haskell binding for libcurl)
15:13:12 <Igloo> darcs has something, but I don't know how tightly integrated it is
15:13:17 <Igloo> Or complete
15:16:20 <Remi> darcs has: copyUrl :: String -> String -> Cachable -> IO ()
15:16:35 <Remi> which (from quickly looking at the source) copies an url to a file
15:22:39 <shapr> blackdog: y0
15:23:27 <Pseudonym> shapr!
15:23:31 <Pseudonym> @arr
15:23:32 <lambdabot> Shiver me timbers!
15:23:50 <Pseudonym> Too late to get you an outline for TMR Succ Zero?
15:24:22 <shapr> I don't think I'll have time to do TMR this month.
15:24:26 * Pseudonym nods
15:24:39 <shapr> I haven't had a day off yet.
15:25:02 <Pseudonym> If it's any consolation, I believe there was two months between the first two issues of Playboy, too.  So you're in good company.
15:25:10 * shapr snickers
15:25:21 <shapr> I do want to get an outline from you though.
15:25:23 <Pseudonym> How I know that factoid... dunno.
15:25:41 <Pseudonym> Right.
15:25:45 <Pseudonym> How long you going to be here?
15:25:47 <shapr> I want to set up the authors-only wiki and let everybody put up everything there.
15:25:54 <shapr> AT least another hour.
15:26:01 <Pseudonym> Ah.  Well I won't be.
15:26:04 <Pseudonym> So I'll email you.
15:26:08 <shapr> sounds good.
15:26:09 <Pseudonym> With the darcs details.
15:26:21 <shapr> cool, I look forward to it.
15:26:29 <Pseudonym> A darcs-based wiki would be very cool.
15:26:37 <Pseudonym> You could have multiple copies of the same wiki.
15:26:42 <Pseudonym> Anyway.
15:27:17 <joao> Hello
15:28:21 <joao> How can I load "../../libraries/Foo/Bar.hs" module in ghci? (Bar.hs defines Foo.Bar module). If I do ":l ../../etc..", the dots are converted to /
15:29:20 <shapr> what about :set -i../../libraries and then :l Foo.Bar ?
15:29:54 <joao> Well.. I want to use this with hs-plugins.. is there any other way?
15:50:48 * shapr throws lambdas
15:51:32 * boegel catches and throws back
15:51:53 <dons> shapr: i won't get the hs-plugins paper written this month. snowed in atm.
15:52:04 <shapr> no worries
15:52:22 <shapr> I'm being snowed in by paying work that's taking four times as long as it was predicted.
15:53:09 <shapr> Though I will contact you when I have the author's wiki working.
15:53:35 <dons> yeah. that's a good idea.
16:05:21 <shapr> I wonder if the SMP GHC via STM that SPJ was talking about would show up in the fptools repo on cvs.haskell.org.
16:05:54 <Remi> I guess so, eventually
16:06:02 <Remi> perhaps in another revision?
16:06:51 <shapr> Nothing in the the forks listed here - http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/stm/Control/Concurrent/STM/
16:07:06 <shapr> Oh, you mean wait for a released version? heresy!
16:07:20 <dons> we have an smp ghc rts now? i though that was just in the planning stage.
16:07:55 <shapr> Yeah, it in the planning stage, but since I'm desperate to get hold of that, I was hoping to find an in-progress hack.
16:08:13 <dons> don't think there've been any commits yet
16:08:38 <shapr> The box I've had for the last three years is a two cpu 1.5GHz Athlon MP. I've been wishing for SMP GHC the whole time.
16:08:55 <a5> haha
16:09:10 <shapr> y0 frederik, wassup?
16:09:17 <a5> beats having a powerpc
16:09:38 <Remi> no I don't, I was speculating that they may keep it private for the first few weeks, and then put it in cvs under another tag/revision/branch/whateveritscalled (just like optimistic eval IIRC)
16:09:42 <clavijo> hi
16:10:02 <Remi> hi
16:10:11 <dons> i've had a quad itanium sitting around at uni for about 4 years now -- that thing could really do with smp ghc
16:10:13 <a5> hi shapr. hi clavijo. hi Remi.
16:10:22 <shapr> If STM works for SMP GHC, I bet it'll be easy to hook that up to Manuel Chakravarty's parallel arrays.
16:10:23 <dons> hmm... the hop/house guys would like smp ghc too, i bet
16:10:50 * Remi is going to say something about parallel arrays someday
16:11:00 * boegel is off to dreamland
16:11:05 <Remi> night
16:11:05 <shapr> dons: Wow, that would be fast!
16:11:10 <shapr> g'night boegel
16:11:37 <shapr> Hm, STM is a bit like cache optimistic cache coherency, right?
16:12:18 <dons> I don't know yet.
16:12:37 <Remi> oh btw, I got the My First New Primop working yesterday, and it's actually doing something as of today, so expect a message+wiki from me about GHC/GMP/Integer Real Soon Now (famouslastwords)
16:12:38 <shapr> dons: I have the intuition that parr would make it easy to figure out what data goes with what code, does that sound right?
16:13:12 <dons> Remi: ah! sounds good.
16:13:24 <clavijo> i have a type signature with three different type constructors belonging to a single class, how can i force a common expression (of the class) to be of one of those types?
16:13:33 <dons> shapr, yeah, that's in the area.
16:13:40 * Remi hopes that telling everyone about it makes me a bit more likely to actually finish it ;)
16:13:58 <shapr> Remi: That's a whole methodology, didja know?
16:14:12 <Remi> shapr: any books about it?
16:14:27 <shapr> It's called embarassment oriented programming ;-)
16:14:32 <Remi> lol
16:15:19 * Remi smells money
16:15:26 * Remi has a bad nose
16:15:34 <shapr> dons: so my intuition is that Parr could be used to ship just the right amount code + data into the 256k of memory that is cache/main memory/etc for the Cell sidekick CPUs.
16:15:54 <shapr> I get lots of smell hallucinations when I have a cold. Celery is the worst.
16:16:02 <shapr> er, was that what you were talking about?
16:16:25 <dons> shapr: yeah. you could do that, yes.
16:16:31 <Remi> me? my nose thought a lot of money could be made from EOP
16:16:39 <shapr> oh, hah!
16:17:08 * Remi has recently been wondering why parr actually needs to be so different from The Other Arrays
16:17:12 <shapr> dons: From what I've read, nobody has a good idea of how to program the Cell.
16:17:31 <dons> hmm... that's interesting.
16:17:53 <dons> because i reckon parallel functional people probably have a clue.
16:18:05 <shapr> Yeah, I think that's a good possibility.
16:18:07 <Remi> that is, it's a bit of syntax (array comprehensions + enumerations: would be usefull for other arrays, sets etc too), and a lot of RULES (which aren't implemented in ghc yet IIRC)
16:18:53 <shapr> In fact, hOp, Parr, and HOpenGL could be a fun way to write PS3 games.
16:18:56 * Remi wonders about the possibility they just didn't want to bother too much with library/interface-design instead of working on their actual problem
16:19:52 * stepcut upgrades everything haskell related ;)
16:20:05 <shapr> y0 stepcut, wassup?
16:20:24 <shapr> Is that your brother doing the Hindely-Milner stuff? stepcutHM?
16:21:01 <stepcut> no that is my logged in at HoMe
16:21:14 * Remi goes to bed
16:21:16 <stepcut> hrm, HSQL is getting link errors with GHC 6.4+freebsd
16:21:21 <stepcut> Storage.o(.text+0x3e2): undefined reference to `__gmp_set_memory_functions'
16:21:22 <shapr> g'night Remi
16:21:44 <Remi> is gmp installed on it?
16:21:58 <Remi> (in the right place etc etc)
16:22:05 <Remi> anyway, bye & good luck
16:22:11 <stepcut> actually, maybe its hsc2hs that is the problem..
16:22:19 <stepcut> /usr/local/bin/hsc2hs src/HSQL.hsc -I/usr/local/include/mysql -Isrc/HSQL
16:22:19 <stepcut> /usr/local/lib/ghc-6.4/libHSrts.a(PrimOps.o): In function `plusIntegerzh_fast':
16:22:19 <stepcut> PrimOps.o(.text+0x5cf): undefined reference to `__gmpz_init'
16:23:15 * stepcut addes a -lgmp
16:26:31 <a5> for dependent types, why not just make say (DT 3) a synonym for a special instance with a 'value' method so e.g. (value::(DT 3)) = 3. then you could do n=5; some_func :: (DT n) x => MyArray x a. or is this the realm of template haskell
16:27:25 <a5> i've printed out Yorck Hunke's thesis but haven't read it yet
16:29:51 <shapr> I don't think that would fit so directly into the typesystem, but I'm definitely not an expert.
16:33:10 <a5> couldn't you expand it fairly easily - "define a dummy instance with the required value" and "replace (DT v) with the dummy instance name"
16:34:47 <a5> there goes the conversation
16:36:48 <shapr> You're talking about directly lifting values into the type system. I don't think it works that way. But once again, this is my uninformed opinion.
16:39:26 <shapr> I know you can get value types with nested instances, not sure what else.
16:39:39 <a5> it would be equivalent to: instance Blah BlahWrapper where value = 3; some_func :: Blah x => MyArray x a
16:39:55 <a5> then the MyArray implementation calls 'value::x' to get the value
16:40:12 <shapr> Though in Epigram, there's very little difference between types and functions, so that's a long way past value types.
16:40:28 <a5> nested instances?
16:40:42 <a5> i should look at epigram
16:40:53 <a5> maybe i'll ask the mailing list about this
16:41:21 <shapr> Have you seen how HaskellDB does BoundedList?
16:42:27 <a5> i've seen the HList stuff if that's what you mean.
16:43:44 <clavijo> if I have: instance Blah Foo where...; instance Blah Bar where...; some_func :: (Blah x, Blah y) => x -> y -> a; how can i enforce a "value" evaluation to be of type x or type y?
16:44:02 <shapr> a5: http://cvs.sourceforge.net/viewcvs.py/haskelldb/haskelldb/src/Database/HaskellDB/BoundedList.hs?rev=1.10&view=log
16:44:26 <TheHunter> a5, have a look at that: http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
16:44:30 <a5> "Blah" is supposed to be a unique name. and just cast it value::x
16:45:20 <shapr> BoundedList uses phantom types.
16:45:34 <clavijo> should it work in type constructors ([], Monad) too?
16:45:46 <shapr> Looks a lot like what you were talking about earlier.
16:46:18 <clavijo> may i paste some code?
16:46:45 <a5> shapr: oh yeah quite similar
16:47:00 <a5> i don't care
16:47:07 <TheHunter> @wiki HaskellIrcPastePage
16:47:08 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:47:13 <clavijo> ok
16:50:00 <a5> TheHunter: thanks for the reference
16:51:17 <clavijo> thats done
16:53:09 <a5> is this a problem for my proposal?
16:53:21 <TonyRoberts> hey
16:53:29 <TonyRoberts> is haskell better than perl for websites?
16:53:35 <a5> ha!
16:53:52 <a5> look at WASH
16:54:11 <clavijo> a5: just if you can help me :)
16:54:39 <a5> shapr: btw, Peter Thiemann came up with a useful combinator when I complained that the WASH counter example had log size problems
16:55:11 <a5> now there's an easy example with constant log size
16:55:17 <TheHunter> clavijo, which version of ghc are you using?
16:55:26 <clavijo> TheHunter: 6.2
16:55:59 <TheHunter> ok, the problem is: the m1 from the type signature isn't in scope in the where clause.
16:56:18 <clavijo> how can i solve it?
16:56:34 <TheHunter> you can explicitly scope it with f (_:: m1 a) = ...
16:57:14 <TheHunter> in ghc6.4, you'd just give f the signature f :: forall a m1 m2. (MonadPlus m1, MonadPlus m2) => m1 a -> m2 a
16:57:34 <clavijo> TheHunter: and if i want the s term to be of type m2 () (the result) instead of m1 ()?
16:57:51 <TheHunter> f _ :: m2 a = ...
16:57:58 <a5> TonyRoberts: http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
16:58:08 <clavijo> and in ghc6.4 my actual code should work?
16:58:09 <clavijo> ok
16:58:15 <clavijo> im gonna try it :)
16:58:16 <clavijo> thx
16:58:29 <TheHunter> you still need an explicit forall.
17:00:04 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
17:00:16 <stepcut> so, the new ghc-pkg requires a new format for the input files ?
17:00:28 <clavijo> thanks
17:01:42 <shapr> TonyRoberts: I think it depends on what works for *you*. If you like inductive definitions, purely functional code, etc, then Haskell is likely better for websites for you.
17:01:49 <clavijo> TheHunter: it woks :) merci
17:02:03 <shapr> But if you have ten years of experience using Perl, and no experience using Haskell, you'll do better with Perl.
17:02:05 <clavijo> works*
17:02:25 <shapr> TonyRoberts: Have you done much functional programming?
17:03:20 * clavijo is away: busy
17:03:58 <shapr> duncan_: hey, how's the new wheel?
17:04:42 <shapr> duncan_: you got a Coker, right?
17:05:02 <shapr> a5: you mean the truncate log critter?
17:05:56 <a5> shapr: yeah, 'once' doesn't work for UpDownCounter.hs
17:07:30 * Lemmih starts dancing.
17:08:04 <Lemmih> Finally finished my surface -> texture function.
17:10:01 <shapr> Lemmih: btw, cairo might be interesting to you.
17:10:46 <Lemmih> Have seen it. No interest. (:
17:11:19 <shapr> ok
17:12:07 <duncan_> shapr: it arrived yes. :-) It's very nice. I can go much faster.
17:12:44 <duncan_> it still fits in the lift so I can still take it up to my office :-)
17:13:33 <duncan_> speaking of cairo, we're in the planning stages of hs-cairo & gtk2hs integration since cairo is the fututre for gtk+
17:16:10 <shapr> duncan_: any Coker pix?
17:16:55 <duncan_> shapr: not of myself sadly no. I should take some.
17:17:54 <duncan_> It took me a good few weeks to really get used to, but I'm back to being able to hover. :-)
17:18:02 <shapr> Man, this guy who posted OCaml code on slashdot got flamed viciously by OCaml guys in the comments.
17:18:07 <shapr> I still can't idle :-(
17:18:28 <duncan_> learn! It's good for waiting at traffic lights :-)
17:18:39 <shapr> I can freemount, hop, and I can do all sorts of crazy stuff on scary packed snow terrain.
17:19:47 <duncan_> yes, I don't do offroad, my unicycles are not realy built for it
17:19:55 <shapr> We've had gobs of snow here, and the footpaths in the midst of all the soft snow end up looking like freshly tilled soil, but they're rock hard. It's *lots* of fun to go up and down the hills and try not to break through at the edges.
17:20:07 <duncan_> :-)
17:20:20 <duncan_> I wish we had more snow in the UK
17:20:22 <shapr> Freemounting on a track the width of two feet side by side is challenging.
17:20:28 <duncan_> I bet
17:20:52 <shapr> I have 5mm pins on my KH24, but I may get something larger, the ice sticks in my shoes.
17:21:05 <duncan_> after learning to hover the next challenge is going backwards
17:21:18 <shapr> I wish we had more concrete here, the only time I get interesting places to ride is when there's neat packed snow shapes.
17:21:42 <duncan_> I've got too much concrete!
17:22:07 <shapr> You have the perfect urban uni. Did you get the steel rim, alloy rim, or airfoil?
17:22:13 <duncan_> I should go for more rides in the country
17:22:19 <stepcut> already! hsql is installed, now I just need to install haskelldb and wash
17:22:19 <shapr> Did you get a brake as well?
17:22:32 <stepcut> but I am not going to build wash until I get my new RAM in
17:22:58 <duncan_> no breaks, steel rim on my old one. I think the coker is an alloy rim.
17:23:39 <shapr> stepcut: how much ram do you have now?
17:24:42 <shapr> duncan_: Very nice. I'm going away from the urban setup. I'll buy one of the 65mm 24" Large Marge rims as soon as they're available.
17:25:00 <stepcut> shapr: on my freebsd, 128MB
17:25:11 <shapr> Yeah, I'd wait for ram also.
17:25:29 <stepcut> shapr: I tried to compile wash last night, but after ghc spent 30mins trashing my swap on HtmlMonda98, I decide to hit Cntl-C and get more RAM :)
17:25:50 <shapr> I wish I had a 26" uni, since the Surly Bikes 3.7" tire will be available in the next few months as well.
17:25:50 <stepcut> I should have it by thursday :)
17:25:55 <duncan_> stepcut: wise
17:25:56 * shapr snickers
17:26:25 <shapr> stepcut: I bet waiting for ram will actually cut down your compile time compared to starting the compile now.
17:26:31 <stepcut> heh
17:26:45 <shapr> WASH takes a loong time, even on my dual 1.5GHz with 512MB of ram.
17:26:57 <duncan_> The thing that finally persuaded me to upgrade was developing gtk2hs which uses the c2hs preprocessor which wanted to use >400Mb
17:27:28 <shapr> I wish I could afford more ram for this box. Too bad registered ECC ram never got cheaper.
17:29:30 <shapr> duncan_: I thought it was the long commute times that motivated your upgrade? =)
17:29:44 <duncan_> :-)
17:30:04 <shapr> I hope we end up in the same physical space with unicycles some time, that would be fun.
17:30:08 * stepcut got cheap, non-ECC ram :-/
17:30:19 <CosmicRay> Igloo: the build failed
17:30:22 <CosmicRay> TcForeign.hi
17:30:23 <CosmicRay> typecheck/TcForeign.lhs:185:
17:30:25 <CosmicRay>     Variable not in scope: `typeMachRepRep'
17:30:28 <CosmicRay> typecheck/TcForeign.lhs:186:
17:30:28 <duncan_> I think it was just coker lust really :-) My commute time is still about 5min
17:30:29 <CosmicRay>     Data constructor not in scope: `FloatHint'
17:30:32 <CosmicRay> <<ghc: 84680976 bytes, 19 GCs, 2873992/5651384 avg/max bytes residency (4 samples), 19M in use, 0.01 INIT (0.00 elapsed), 2.07 MUT (2.33 elapsed), 0.63 GC (0.68 elapsed) :ghc>>
17:30:38 <CosmicRay> make[3]: *** [stage1/typecheck/TcForeign.o] Error 1
17:30:40 <CosmicRay> make[2]: *** [all] Error 1
17:30:43 <CosmicRay> and yes, I did apply your patch
17:30:43 <Igloo> OK, hang on a tick
17:30:44 <CosmicRay> duncan_: that long, eh?
17:30:55 <CosmicRay> duncan_: mine only exceeds 4 minutes when traffic is heavy :-)
17:31:05 <CosmicRay> duncan_: meaning I have to wait for up to 2 cars before crossing the highway
17:31:50 <duncan_> :-) Living in the middle of town does make life easier
17:32:05 <shapr> My commute time is however long it takes me to fold my futon up into a couch so I can sit in front of the monitor rather than pretending to be a Roman.
17:32:05 <CosmicRay> duncan_: living where few other people do works too :-)
17:32:11 <Igloo> Oh crap, that's disappeared completely
17:32:22 <CosmicRay> shapr: ok, you win.
17:33:06 <shapr> In some extreme cases I go from alarm clock to working in about two minutes.
17:33:11 <CosmicRay> heh
17:33:31 <duncan_> I should time it one day, I can probably do house to office in 3-4 min if I try. But if you go really fast on a unicycle you do look a bit odd! Like a gerbil on a wheel
17:34:04 <duncan_> Igloo: BTW I've not seen gtk2hs 0.9.7 deb turn up yet. Know what's happening to it?
17:34:45 <CosmicRay> shapr: I am really psyched about asterisk lately.
17:34:51 <Igloo> No, haven't heard anything more from Marvin
17:34:54 <duncan_> asterisk?
17:35:02 <duncan_> Igloo: ok
17:35:05 <CosmicRay> duncan_: an open source pbx
17:35:40 <duncan_> ok
17:35:42 <CosmicRay> duncan_: http://techdatapros.com/asterisk/
17:36:05 <CosmicRay> so anyway, I'm buying a voip phone and replacing the phone wiring in our house with cat5e
17:36:23 <shapr> CosmicRay: does asterisk have an accompanying directory?
17:36:51 <CosmicRay> shapr: you mean, a menu system where you can key in the first few letters of a name and get the extension number?  if so, then yes
17:37:09 <shapr> btw, watch out for the voip spam. It's legal to do unrestrained telemarketing over voip.
17:37:15 <CosmicRay> yeah
17:37:33 <CosmicRay> I've signed up on FWD (freeworlddialup)
17:37:39 <shapr> No, I mean a directory system where I can call you from my voip by putting your name into a search box.
17:37:45 <CosmicRay> if it becomes a problem, it's trivial to restrict incoming calls to numbers I trust
17:37:54 <CosmicRay> oh, no that is not an integral part of asterisk
17:38:10 <shapr> aha, now we've found the opportunity to integrate Haskell!
17:38:18 <CosmicRay> asterisk is the behind-the-scenes program that, for instance, decides whether to route an outgoing call over a voip network or a plain phone line, depending on the number
17:38:26 <CosmicRay> or runs your voicemail system
17:38:32 <CosmicRay> shapr: grin :-)
17:39:05 <CosmicRay> http://www.fwdnet.net/ is pretty cool, they have interlinks with about a dozen other voip places, such as vonage
17:40:36 <shapr> Ok, I'm sold. Are the asterisk debs worthwhile?
17:40:43 <CosmicRay> yeah, but scattered
17:40:56 <CosmicRay> www.voip-info.org is a good resource, but it was down part of today for some reason
17:40:59 <CosmicRay> there's also asteriskdocs.org
17:41:18 <CosmicRay> and there's AGI, the Asterisk Gateway Interface, a language-neutural way to extend it, similra to CGI
17:42:11 <CosmicRay> I was about to start a haskell library, but then I discovered that the built-in system could do everything I need
17:42:28 <CosmicRay> it is quite possibly turing complete :-)
17:42:56 <Igloo> Have you ported GHC to it then?
17:43:22 <CosmicRay> haha
17:43:35 <CosmicRay> I can hear it now.
17:43:50 <CosmicRay> "Press 1 to start a do block.  Press 2 to define a function.  Press 3 to start a case statement."
17:44:02 <Igloo> :-)
17:44:16 <duncan_> shapr: when's the next issue of TMR? I've been working on a program for an article.
17:44:19 <CosmicRay> ".... press 74 to terminate immediately.  press 75 to abort due to an obscure ghc internal error.  press 76 to overflow your heap."
17:47:06 <CosmicRay> shapr: people do some cool stuff with asterisk, and there are voip companies with wickedly-cheap termination into pstn (meaning you route the call over the 'net to them, then they connect it to a regular phone)
17:47:10 <duncan_> Igloo: I've been re-writing our ant simulator & visualiser. The simulator now runs 100,000 rounds in 6 seconds and the visualiser runs 100,000 rounds in 33 seconds. :-}
17:48:00 <duncan_> And it works well over a remote X connection!
17:48:15 <CosmicRay> shapr: less than 2 cents a minute to most of the western hemisphere
17:48:18 * Igloo has visions of ICFP 2005, where 3 of us hack on the new task while duncan occassionally interjects "down to under 4 seconds now!"  :-)
17:48:28 * clavijo goes
17:48:30 <clavijo> bye!
17:48:49 <duncan_> :-)
17:49:04 <Igloo> How does it compare to the Java one now, OOI?
17:49:31 <shapr> duncan_: seems likely to me that I won't have time to round up an issue this month, way too much work.
17:49:33 <duncan_> much faster. And it zooms in and out. And repaints nicely.
17:49:50 <Igloo> Cool
17:50:02 <CosmicRay> shapr: also there are cool things one can do with even the built-in scripting.  for instance, I plan to route long-distance calls over voip, local calls over landline, unless it's busy, in which case it will go over voip
17:50:08 <dons> so it runs fast enough now duncan?
17:50:37 <dons> spj's response was enlightening, I thought.
17:50:45 <CosmicRay> shapr: then if someone tries to dial the emergency service, it will disconnect any active call on the landline and call the emergency service immediately
17:50:49 <duncan_> The Java versions had this odd behaviour where they ran the sim in one thread and painted updates in that thread but expose events got drawn from the other thread which just gave odd efects.
17:51:08 <duncan_> dons: yes it was very interesting.
17:51:48 <dons> he definitely had some insider knowledge about how to approach the optimisation problem - rather than some of the brute force tricks we tried over here in .au
17:52:27 <duncan_> dons: so the visualiser runs satisfyingly fast now. I have other array programs where the more speed the better, pixel-oreintated graphics animation thingies.
17:52:38 <shapr> I suspect spj of insider information into fp implementations. Likely more than I'll ever have.
17:53:05 <dons> yeah, and I've got to try some of this stuff on yi, which does a lot of array tweaking
17:53:10 <duncan_> dons: yes, like knowing about the -fcase-something-or-other-threshhold optimisation
17:53:13 <shapr> I thought up supercombinators by myself, and only later discovered that spj 'been there, done that.'
17:53:34 <dons> the inline main trick was a true surprise
17:53:46 <shapr> duncan_: oh hey, I had a burning partial eval question for ya...
17:53:49 <shapr> wish I could remember it :-/
17:53:54 <duncan_> shapr: probably. He's made a whole carrer out of it.
17:54:00 <shapr> Is your peval code available?
17:54:30 <duncan_> shapr: it's pretty primitive at the moment and painful to use for non-trivial size problems
17:55:12 <duncan_> shapr: I'm working on some automatic analyses to do most of the static/dynamic annotations automatically
17:55:39 <shapr> Yeah, that would be nice. Perfection would be having partial application be the same as partial evaluation.
17:56:19 <a5> hey where do I get the instance MonadPlus IO definition? ghci can't find it
17:56:20 <stepcut> doh, haskelldb cvs does not build under ghc 6.4 :-/
17:56:29 <duncan_> shapr: sadly they're not quite the same. There are more termination issues with the latter :-)
17:56:47 <a5> i imported System.IO Control.Monad
17:56:54 <duncan_> shapr: what's your application / burning question?
17:57:26 <shapr> I'm trying to remember :-/
17:57:59 <duncan_> that burning hey?
17:58:01 <shapr> It had something to do with mixing arrows and partial eval, as in my original email to you. And I think it involved template haskell too.
17:58:34 <shapr> Sadly, this is normally how my memory works. If I don't write down some interesting idea, it's gone forever.
18:00:14 <a5> mzero :: IO () ==> No instances for (Show (IO ()), MonadPlus IO) arising from use of `mzero' at <interactive>:1
18:00:15 <shapr> a5: I have no better ideas, that's where I would have looked.
18:01:33 <shapr> The most irritating part of having a memory like that is when I don't write down the steps to accomplish a process, and the next day I no longer remember how to do that thing. There are a few things I never again figured out how to do.
18:02:06 <a5> oh, Control.Monad.Error, found it in ghc source. shouldn't there be an easier way to track down instance defs?
18:02:15 <shapr> I don't know how to search for instance defs.
18:02:32 <shapr> btw, did you figure out how to bend Haddock to your will?
18:02:42 <a5> working on other things for the moment
18:03:37 <shapr> What was your original goal for Haddock? I forget...
18:03:47 <a5> i think stimulants hurt my memory. or well maybe lack of sleep. but i think i read that stress is also a factor
18:03:55 <duncan_> I thought there were some interesting possibilities in partial evaluation and arrows since the arrows can expose a good deal of static infomation, they can partition 'run time' data from the control flow structure which might allow interesting optimisations on the latter
18:04:03 <a5> shapr: flash cards for learning libraries
18:04:18 <shapr> Oh right. You wanted to learn typesigs.
18:04:45 <shapr> a5: Yeah, stress is my biggest problem.
18:05:03 <a5> types from names, or names from types.
18:05:09 <duncan_> I was imagining that you could write an interpret-style thingy for the control structure side of your arrow combinator and the partial evaluation would 'compile' that for you.
18:05:57 <shapr> hiya jewel, ltns
18:06:22 <shapr> a5: why not just use the HaddockModule I wrote to dump out the info as a text file?
18:06:38 <shapr> jewel: how's code?
18:08:14 <shapr> duncan_: er yeah, I think that's part of my burning question.
18:08:34 <shapr> oh hey, I think I remember!
18:08:58 <shapr> I think I wanted to mix your peval code with hs-plugins.
18:09:55 <duncan_> ah
18:10:00 <shapr> One of my nuttier ideas was to see if I could speed up darcs by turning patches into arrows along with partial evaluation of some of the ops. Something like the poly-inline caching that the Self virtual machine does.
18:10:19 <duncan_> so you can specialise some program with an argument only known at runtime and then load up the generated specialised code via hs-plugins? Sounds like fun.
18:10:33 <shapr> Right, exactly. runtime specialization.
18:10:45 <shapr> Very much like poly-inline caching.
18:11:07 <duncan_> I'm not familiar with poly-inline caching.
18:11:26 <shapr> You know anything about the HotSpot Java VM?
18:11:31 <duncan_> some
18:11:33 <a5> shapr: i'll end up doing something like that
18:12:28 <shapr> Ok, HotSpot uses poly-inline caching, which was originally in Self. In essence, specialize a polymorphic method for each type that passes through it, but only compile up a specialized version the first time you get one of those types.
18:13:00 <duncan_> I'm guessing the idea is you notice at runtime that certian functions are being called often with the same values and so you make specialised versons of them and possibly inline them into their call sites?
18:13:00 <duncan_> A bit like on-line partial evaluation
18:13:11 <shapr> Many of the improvements in Java VMs have come from the Self VM. Why did Sun abandon Self and switch to Java as their flagship language? I cannot overstate my disapproval.
18:13:35 <duncan_> ok, so specialisation but only for types not other values
18:14:19 <shapr> hiya heatsink
18:14:26 <heatsink> hey shapr.
18:14:39 <heatsink> how goes it/
18:14:57 <shapr> Stuck in the mud at the moment, it's not going at all.
18:15:20 <shapr> How's the dissipation of heat on your end?
18:15:26 <heatsink> you should get more-than-one-wheel-drive, it gets better traction in mud.
18:15:29 <shapr> duncan_: meaning, partial eval would be much niftier.
18:15:54 <shapr> Oh, if you mean uni, then it doesn't go because I don't have time at the moment. Too much work.
18:17:19 <heatsink> Muddled. we've been trying to define the problem domain, I was only peripherally involved in that. Needs more work.
18:19:41 <duncan_> shapr: hmmm, possibly though it's not immediatly obvious that it'd help the ordinary OOPy java program. But I suppose it already does less agressive peval-like techniques like lots of inlining and constant propogation. It's much easier to figure out what's constant (or mostly constant) after the program has finnished initialising.
18:19:45 <heatsink> C semantics prevent compilers from making high-level optimizations.  Some of the people in the group are trying to restate that statement in useful ways.
18:21:07 <shapr> duncan_: At least for Haskell, peval + hs-plugins + darcs would be *quite* nifty. Have you seen how long it takes to pull the linux kernel darcs repo?
18:21:34 <shapr> heatsink: like hat?
18:21:37 <shapr> "like what?"
18:22:57 <heatsink> shapr: like taking code that conceptually operates on streams, and splitting it up into tasks that run in different threads.
18:24:15 <shapr> That makes sense. Have you seen the various parallel array languages/libraries?
18:24:47 <heatsink> Not much. There's a lot of stuff dealing with regular array accesses, like MPI and HPF and stuff.
18:24:50 <Cale> heatsink: that sounds related to what they're doing at McMaster
18:24:58 <heatsink> McMaster?
18:25:19 <Cale> The university in Ontario - there's a project called coconut
18:25:30 <Cale> I worked there last summer.
18:25:59 <Cale> http://www.cas.mcmaster.ca/~anand/
18:26:09 <duncan_> shapr: It's not obvious to me how peval would help darcs, but then I'm not familiar with the algorithms in there. An obvious example for peval + hs-plugins would be a reimplementation of PAN.
18:26:21 <Cale> They're writing the compiler in Haskell :)
18:26:22 <heatsink> Cale: thank you, I'll investigate that.
18:26:43 <Cale> unfortunately there's not that much info on the web, but I think desrt is still around there
18:27:05 <Cale> (he's here in this channel, I don't know whether he's reading this)
18:27:32 <shapr> desrt: wake up!
18:27:38 * shapr throws lambdas at desrt 
18:27:52 <heatsink> shapr: There's definitely parallel coding tools out there, but it's essentially the Graduate Student Algorithm on the front end
18:28:18 <heatsink> at least, as far as I know
18:28:23 <shapr> There's a long thread on lambda-the-ultimate.org about declarative concurrency.
18:28:31 <heatsink> step 1: get a graduate student to calculate the optimal way to break this parallel algorithm into tasks.
18:29:05 <heatsink> the forgotten paradigm?
18:29:35 <shapr> Transparent parallelism does exist for a particular class of algorithms. 'Nested data parallel' using array unrolling, etc.
18:30:42 <heatsink> what does 'transparent' mean?
18:31:19 <shapr> You write your code as array operations, and the parallelism is pulled out for you.
18:31:47 <shapr> http://www.cse.unsw.edu.au/~chak/nepal/
18:32:08 <stepcut> okay, I got an application to link against the latest haskelldb, hsql, and ghc 6.4
18:32:10 * heatsink guesses -- since it's from UNSW -- that it's written in haskell
18:32:16 <heatsink> yes!
18:32:16 <stepcut> don't know if it actually runs yet ;)
18:32:32 <duncan_> I was just going to say, isn't that what Manuel's working on!
18:32:34 <shapr> Sisal, Nesl, FISh, etc are data parallel.
18:32:47 <shapr> er, wait.. I'm not sure about FISh, but it's at least related.
18:33:00 <duncan_> Arn't they all first order fp languages?
18:33:18 <shapr> What's first order?
18:33:39 * shapr gets food
18:34:05 <duncan_> I know Sisal is not higher order, no first class values with -> types
18:35:33 <a5> if i have "F m s a", how do I say "F * s *" is an instance of MonadTrans... do I have to declare a new type with 'm' and 'a' at the end?
18:38:51 <shapr> ah, right. I think Sisal and Nesl both fit into that, not sure about FISh.
18:39:24 <duncan_> actually I've not heard of FISh before
18:40:30 <shapr> It's very nifty and very strange.
18:41:06 <duncan_> how so?
18:42:37 <shapr> From the homepage - "FISh is designed to allow naming and computations on shapes. Every datum value is also of the corresponding shape type, also called a static type (as in the two-level lambda calculus)"
18:42:44 <jewel> hi shae
18:42:58 <shapr> Poly-dimensional array programming
18:43:07 <shapr> jewel: how's code?
18:43:24 <jewel> interesting, I can't figure darcs out
18:43:39 <shapr> figure out how to use it? hack it? or what?
18:43:52 <heatsink> I take it that I've got the wrong url? http://www.nelepets.com/FIPL/
18:44:59 <shapr> heatsink: http://www-staff.it.uts.edu.au/~cbj/FISh/
18:46:12 <shapr> This is one of the most impressive parts about FISh - http://www-staff.it.uts.edu.au/~cbj/FISh/Benchmarks/conclusions.html
18:46:46 <shapr> It can significantly outperform C in some cases.
18:47:01 <duncan_> impressive stats
18:53:22 <heatsink> The shape analysis that they use... statically determined array sizes?
18:54:06 <duncan_> or at least if you know some dimensons you can improve indexing calculations and things
18:55:14 <shapr> So I'd say that data parallelism is a special case of 'computation shape'
18:55:16 <heatsink> Yea, but their description leads me to believe that the compiler will report an error if the dimensions are unknown.
18:55:53 <heatsink> shapr: That makes sense.
19:00:23 <shapr> I wonder if there are other interesting optimizations in special cases of computation shape. I wonder if region allocation fits in there too.
19:02:13 <heatsink> Is region allocation proving that you have a stack-based computation?
19:02:54 <duncan_> and thereby reducing the need for garbage collection
19:04:06 <duncan_> actually I think they go slightly more general than strict stack based, more like variable size pools (regions) that get freed all at once
19:04:26 <shapr> I'm so happy I'm living through the infancy of the software industry, anyone can jump in and get to the interesting parts via self-study.
19:05:28 <heatsink> Hmm, my gut feeling is that it's 'computation shape' when the lifetime of the data corresponds to specific locations in the code.
19:07:16 <heatsink> shapr: Depends on which interesting parts you're looking at.  Lots of CS or computer architecture is hard to understand, now or even twenty years ago IMO.
19:25:31 <shapr> heatsink: like what?
19:25:43 <shapr> The only part that causes me headaches is category theory.
19:25:51 <duncan_> me too!
19:27:12 <heatsink> shapr: formal verification, pointer analysis (das, steensgard, etc.), out-of-order execution
19:30:05 <shapr> I've never read about pointer analysis, though I've heard ooo execution is very difficult for compiler writers.
19:30:26 <shapr> As in, difficult to write code in such a way that ooo works predictably with it.
19:30:53 <heatsink> Oh, yea, that's pretty much a heuristic thing.
19:31:04 <duncan_> pointer analysis is actually quite important for lots of interesting analyses in imperitive programs
19:31:23 <heatsink> With OOO I meant how it's done in hardware.
19:32:03 <duncan_> some slicing and refactoring transformations have side conditions which need pointer anslysis if you want to check them automatically
19:32:45 <Pseudonym> Back.
20:14:07 <Cale> Where is the OpenAL support which is apparently in GHC 6.4 documented?
20:16:09 <dons> doesn't look like the docs are up. hmm.
20:19:23 <heatsink> Is IO the only way to achieve sequential semanticsa in haskell?
20:19:37 <heatsink> the IO monad
20:21:21 <dons> no, since it is just a way of doing: case x of x' -> case y of y' ... case z of z' ->
20:21:56 <heatsink> The thing is, it bothers me that non-IO data like HashTable are IO functions.
20:22:24 <dons> I think HashTable is an exception, as SimonM, who wrote it, doesn't use ST that much.
20:22:30 <heatsink> ST?
20:22:36 <heatsink> the ST monad?
20:22:56 <dons> state monad, yeah. anyway, who uses HashTable ;) Data.Map forever
20:23:43 <heatsink> On that note, what's the difference between Data.Map and Data.FiniteMap, aside from Map having more operations?
20:24:15 <dons> the order of args to the main functions is flipped, too.
20:24:57 <dons> addToFM   = \m k e -> Map.insert k e m; delFromFM = flip Map.delete; lookupFM  = flip M.lookup
20:25:30 <heatsink> hmm.
20:25:49 <dons> Data.Map is faster.
20:26:38 <dons> here you go:
20:26:41 <dons> data FiniteMap key elt
20:26:41 <dons>   = EmptyFM
20:26:41 <dons>   | Branch key elt              -- Key and elt stored here
20:26:41 <dons>     IF_GHC(Int#,Int{-STRICT-})  -- Size >= 1
20:26:41 <dons>     (FiniteMap key elt)         -- Children
20:26:43 <dons>     (FiniteMap key elt)
20:26:47 <dons> data Map k a  = Tip
20:26:48 <dons>               | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
20:27:01 <dons> so mostly the same.
20:27:20 <heatsink> hmm, yea.
20:27:43 <heatsink> Didna know it was written in haskell.
20:28:16 <duncan_> so Data.Map is completely strict in the tree structure and key. Hmmm.
20:28:16 <dons> you thought C?
20:28:33 <heatsink> yea. Is Data.Array written in haskell too?
20:28:40 <dons> yeah. all Data.* is Haskell.
20:28:56 <dons> there's only a couple of C bits in the libraries, Text.Regex. Some Unicode.
20:28:59 <dons> that's about it.
20:29:04 <heatsink> Hmm, is array lookup O(1)?
20:29:13 <dons> sposed to be, yeah.
20:29:19 <duncan_> obviously the underlying array primitives are implemented in the RTS which is in C
20:29:47 <duncan_> or implemented as primops in the generated code
20:29:50 <dons> yeah, either there's primops at the bottom, which are rts functions, or else there's an ffi binding at the bottom (like in Foreign.*)
20:30:13 <dons> it's all C in the end (except for ops that map directly to NCG instructions)
20:31:14 <heatsink> I kinda figured that Array internals couldn't be a Haskell data declaration for O(1) access.
20:33:19 <heatsink> I'll have to read that fgl paper soemtime.
20:33:51 * heatsink is surprised the logo isn't an earwig.
21:07:51 <stepcutHM> hoo-ray! I got a query to work with the latest and greatest haskelldb, hsql, and ghc 6.4
21:10:13 <Lemmih> Woot woot.
21:10:31 <stepcutHM> Lemmih!
21:10:44 <stepcutHM> you are doing something cool that I am interested in, but I don't remember what now ;)
21:10:51 <stepcutHM> automatic C++ binding maybe?
21:19:57 * stepcutHM goes to bed
21:20:31 <Lemmih> Neat. But I've put the project on hold since the C++ library I wished to bind with was less impressive than previously assumed.
21:20:52 <Gahhh> which library is that ?
21:20:57 <Lemmih> ClanLib.
21:21:45 <stepcutHM> Lemmih: how does this generator work ?
21:21:54 <Lemmih> But I actually generated a working binding to the 50 most used classes.
21:22:54 * stepcutHM wants bindings for KDE
21:24:06 <Lemmih> stepcutHM: It reads header files and generates marshalling rules on the fly. Those rules can be overwritten by the user when non-default behaviour is desired.
21:25:45 <Lemmih> The coolest part, IMHO, is that it can generate marshalling rules and wrappers for callbacks without user intervention (:
21:25:50 <stepcutHM> :)
21:25:55 <Gahhh> Is there a haskell library for distributed haskell ?
21:25:56 <stepcutHM> is it published anywhere ?
21:27:53 <Lemmih> stepcutHM: shapr is hosting a darcs repo at www.scannedinavian.org/repos/hacanon/ but I haven't been able to send patches for some weeks.
21:29:11 <stepcutHM> Lemmih: cool, maybe I will hit you up in a month or so
21:34:33 <Lemmih> The biggest problem with Hacanon is the code bloat. All generated binding _must_ link with Hacanon + plus object inheritance is less than optimal.
21:49:00 <Lemmih> Has anyone been able to build the GHC package with 6.4?
21:49:50 <desrt_gabriel> i did today.4
21:49:50 <desrt_gabriel> twice.
21:50:33 <Lemmih> Did you add 'BuildPackageGHC=YES' to mk/build.mk?
21:50:43 <desrt_gabriel> no
21:50:46 <desrt_gabriel> i built a binary package
21:53:16 <Lemmih> But I need the GHC package (already got GHC 6.4) (:
21:57:08 * Lemmih heads to bed.
22:00:57 <musasabi> morning
22:01:55 * desrt_gabriel confused
22:02:00 * desrt_gabriel goes away now
22:29:06 <dons> Lemmih: we need to update the ghc -package package.conf file
22:29:11 <dons> to match Cabal.
22:43:51 * juhp uninstalls evince and gtk2-2.6 and friends to see if that should stop oo.o crashing
22:44:19 <juhp> oops w'ong chan
23:26:51 * Lemmih is amused by the obscene Haste documents.
