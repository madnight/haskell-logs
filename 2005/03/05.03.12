00:29:36 <wilx> Hmm, I am in a need of advice.
00:29:37 <wilx> http://www.haskell.org/hawiki/HaskellIrcPastePage
00:29:57 <wilx> Code is type Code = Word32.
00:37:24 <musasabi> you need an explicit forall scoped type variables iirc
00:38:00 <musasabi> fixVal :: forall a. (Enum a, Bounded a) => a -> Code
00:38:14 <wilx> Hmm.
00:42:24 <musasabi> Is Codec.Compress.Foo the right place for compression modules?
00:43:02 <wilx> Huh. Dunno.
00:43:14 <wilx> Are there any other Codec or Codec.Compress modules?
00:44:37 <musasabi> Codec.Encryption.* at least exist.
00:44:50 <musasabi> Compress is the part I am unsure of.
00:45:13 <wilx> Hm, maybe you should use full word Compression.
00:46:24 <musasabi> googling with that finds at least one module, I'll use that.
00:47:58 <wilx> What compression do you do? :)
00:48:03 <musasabi> LZF
01:03:15 <bourbaki> moin
01:19:10 <autrijus> greetings.
01:22:53 <autrijus> @type trace
01:22:58 <lambdabot> bzzt
01:23:03 <autrijus> @type Debug.Trace.trace
01:23:04 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
01:23:22 <autrijus> I'm puzzled why
01:23:23 <autrijus> trace cxt return ()
01:23:25 <autrijus> works
01:23:30 <autrijus> when I thought it should be
01:23:33 <autrijus> trace cxt $ return ()
01:24:03 <esap> autrijus: 'trace cxt return' has type a -> m a
01:24:22 <autrijus> ah.
01:24:26 <autrijus> neat trick. thanks!
01:24:32 <autrijus> so it amounts to the same thing
01:24:49 <esap> yes
02:36:20 <Svrog> hi everyone
02:36:46 <Svrog> i just noticed ghc 6.4 is out - how does it compare to 6.2 performance-wise?
02:39:11 <Philippa> I've not tested it myself, but others have shown a significant increase
02:39:19 <Philippa> on what platforms I don't know
02:40:31 <Svrog> interesting
02:42:08 <Svrog> i would think on x86 - from what i've read 6.4 currently only supports x86 and powerpc
02:43:03 <Lunar^> Svrog: more than that, really
02:43:22 <Lunar^> Svrog: the new backend (using C--) is only available on x86 and PPC
02:43:31 <Svrog> ah right
02:43:43 <Lunar^> AFAIK it's working better on PPC  than te previous backend
02:43:47 <Lunar^> +h
02:44:00 <Svrog> thats good to know - my main dev box is a mac :)
02:45:22 <Lunar^> Svrog: you can test PIC libs, then
02:45:34 <Svrog> PIC libs?
02:47:57 <Lunar^> Position Indepedant Code
02:48:06 <Lunar^> dynamically linked lib
02:48:09 <musasabi> LZF compression - http://www.cs.helsinki.fi/u/ekarttun/Codec-Compression-LZF/
02:48:23 <Philippa> AIUI the relevant facilities for implementing hs-plugins under win32 aren't there yet?
02:48:51 <Svrog> ah right
02:51:00 <Lunar^> Philippa: dons should know
02:51:46 <Philippa> well yeah
03:35:51 <_JusSx_> who uses gentoo here?
03:36:03 <_JusSx_> i'm in trouble with compiling ghc
03:36:11 <shapr> I'm GenX, does that help?
03:38:35 * Philippa is going to have to go do a few disgusting GADT hacks soon
03:38:57 <metaperl> Philippa where are you doing your Ph.D?
03:39:02 <Philippa> I'm not
03:39:12 <metaperl> oh, but you are in graduate school?
03:39:17 <Philippa> I'm supposedly doing a BSc at the University of Nottingham, though I'm in the process of suspending my course yet again
03:39:30 <metaperl> oh, is that Scotland?
03:39:34 <Philippa> I've been stuck around long enough I /should/ be doing a Ph.D by now
03:39:35 <Philippa> no, England
03:39:46 <Philippa> roughly in the middle of England, in fact
03:39:50 <metaperl> I see
03:40:17 <metaperl> we've a guy from London with us here in California. he is grateful for this weather
03:40:20 <Oejet> Good day, good people.
03:40:23 <Philippa> though UoN's got a few known faces - my dissertation supervisor (Graham Hutton) did some of the earlier work on monadic parser combinators that eventually gave us Parsec
03:40:40 <metaperl> sweet
03:41:18 <Philippa> you tend to have more respect for your supervisor when they've been involved in something you make regular use of :-) That said, I was never quite one of the 'my lecturers know nothing!' crowd
03:41:45 <metaperl> "dissertatoin" for B.Sc?
03:42:07 <Philippa> BSc (Hons) technically - it's not expected to involve anything novel
03:42:40 <Philippa> a lot of folks with no imagination go off and implement a web shop or something like that, you might see a small compiler or two
03:42:56 <Philippa> I've seen projects where I could've done the code in a day
03:43:34 <metaperl> I am fascinated by web application frameworks. There is a lot to handling a web application correctly (definitionally) as opposed to with a gaggle of if-thens
03:43:42 * Philippa nods
03:43:52 <Philippa> the projects I'm talking about don't do that - but yeah, I share your interest
03:44:07 <metaperl> most people are not aware of the issues involved in a website, such as authorization, authentication, model, view, controller
03:44:19 <Philippa> I wouldn't call MVC an "issue"
03:44:47 <metaperl> there is a very good product for Perl. It's an underdog, but he has some great slides at his website on Realms, Roles, and Tasks as the basis for his framework
03:45:04 <metaperl> furthermore, his framework can handle HTTP and Email agents, so that it is not limited to web processing
03:45:32 <Philippa> cool. I've talked to shapr a little about doing something in haskell, we don't have anything concrete though. All I've done myself is bash up a lightweight wiki clone
03:46:58 <metaperl> well, recently someone said that MVC was a term for the days when M, V, and C could be accessed synchronously
03:47:12 <metaperl> the web puts a new spin on that .  according to Eric Dobbs
03:47:32 <Philippa> perhaps - it's yet to break my brain though
03:48:01 <Philippa> I mean yeah, doing masses of asynchronous programming needs appropriate tools...
03:49:21 <Philippa> concurrent haskell and much use of Chans makes a good starting point for that from what playing around I've done
03:51:04 <_JusSx_>  Philippa where are you from?
03:51:13 <Philippa> the UK
03:51:19 <_JusSx_> ok city?
03:51:25 <_JusSx_> Glasgow?
03:51:26 <_JusSx_> lol
03:51:34 <Philippa> nah, I'm in Nottingham
03:51:37 <_JusSx_> wow
03:51:43 <_JusSx_> nottingham
03:52:01 <_JusSx_> do you like living it?
03:52:05 <Philippa> though we've a fair level of haskell involvement here too, if not to the extent of providing the best-known implementation
03:52:16 <Philippa> snotts is okay, yeah
03:52:22 <_JusSx_> that's good
03:52:37 <Philippa> bit cheaper'n'london, not as cold as scotland :-)
03:53:16 <_JusSx_> how old are you?
03:53:20 <Philippa> 22
03:53:26 <_JusSx_> female?
03:53:36 <metaperl> oh, yes NHC
03:53:43 <_JusSx_> NCH?
03:53:43 <Philippa> how many guys do you know called Philippa? :-)
03:53:50 <_JusSx_> a lot of
03:54:01 <Philippa> (as one person here's already discovered, asking if I'm single next would be a bad idea btw...)
03:54:45 <_JusSx_> no
03:54:57 <_JusSx_> i don't wonna ask for that
03:55:00 <boegel> Philippa: are you single ?
03:55:04 <_JusSx_> lol
03:55:07 * Oejet ducks.
03:55:08 <boegel> :D
03:55:21 * Philippa produces a flogger
03:55:27 <Philippa> want to ask that again, dear? :-)
03:55:45 <boegel> Philippa: you didn't answer my question... Are you single or not ?
03:55:53 * boegel feels like growing a tail and horns
03:55:55 <_JusSx_> i bet she is
03:56:11 <Philippa> no, I'm not. I've even talked about my SO in chan a little before now
03:56:22 <boegel> SO ?
03:56:26 <Philippa> Significant Other
03:56:42 <boegel> oh, ok
03:57:04 <boegel> Philippa: so why was asking you this so forbidden ? no harm done, right ?
03:57:23 <Philippa> boegel: it's the sequence of questions - he'd already got the ASL trinity...
03:58:22 <boegel> Philippa: what's your ASL ? :D
03:58:37 <wilx> Lenght, heh? :)
03:58:57 <Philippa> wilx: as long or short as I choose - that's the beauty of strap-ons
03:59:06 <wilx> :D
03:59:21 * boegel is shocked
04:05:02 <wilx> I have never become sure what the L in ASL was...
04:05:06 <Philippa> location
04:05:12 <wilx> Oh.
04:05:59 <boegel> wilx: age-sex-location, it's a puberal thingie ;)
04:06:09 <Philippa> so 40/male/your arse is a good way to put off most straight guys
04:06:29 <boegel> meaning, do I have any chance of grabbing this person for some tender lovin'
04:06:36 <boegel> hmm, tender doesn't sound right ;)
04:06:47 <wilx> Eh.
04:07:38 <Philippa> boegel: believe it or not I can be...
04:07:51 <boegel> Philippa: I know
04:07:57 <boegel> I met my girlfriend on the net
04:08:11 <boegel> even though she lives only like 500m away from my front door
04:08:17 <Philippa> though my b/f might argue, as he ended up OTK in front of a bunch of people at a party last night...
04:08:20 <wilx> Err, are you sure she is actually a girl? :D
04:08:36 <boegel> wilx: we've been together for 3.5 years now, so yes :)
04:08:52 <boegel> OTK ?
04:08:59 <wilx> ...because you know, the first ruel of IRC is that there are no girls.
04:09:01 <Philippa> Over The Knee
04:09:18 <boegel> Philippa: I'm not familiar with that one
04:09:20 <Heffalump> wilx: I did too :-)
04:09:31 <boegel> wilx: there were 4 years ago ;)
04:09:33 <Heffalump> TMI!
04:09:38 <Philippa> boegel: common position for a spanking...
04:09:42 <wilx> Yay!
04:10:00 <Philippa> it's generally not to be taken literally as that'd result in dislocated kneecaps pretty fast
04:10:14 <boegel> Philippa: hehe, you embaressed him in front of his friends, that's what you mean ? :)
04:10:25 <Philippa> don't think he was really all that embarassed :-)
04:10:38 <boegel> too drunk to realize it ? :p
04:10:51 <Philippa> then again, I was the second-most masculine person there and the most masculine was another woman - was the birthday party for a couple of gay friends of ours
04:11:13 <boegel> oeh, that sounds harsch
04:11:32 <boegel> anyway, off to work now
04:12:16 <Philippa> I think Damien would've been more than happy to spank about half the guys there anyway :-)
04:12:29 <jlouis> hehe
04:12:32 <jlouis> TMI
04:12:48 <Philippa> oh, er, this wasn't a play party...
04:14:02 <jlouis> ...
04:16:38 <wilx> Eh, your man is less masculine than two women in private party...?
04:16:54 <wilx> Bodybuilders?
04:16:58 <musasabi> masculinity has not very much to do with physical gender.
04:18:00 <Philippa> wilx: the other woman describes herself as a "man-dyke" :-)
04:18:12 <wilx> Heh.
04:18:28 <Philippa> and Damien's the somewhat feminine variety of geek
04:19:08 <Philippa> and the vast majority of men at that party were a wee bit camp
04:19:20 <wilx> Heh.
04:19:34 <wilx> I guess you two complement each other then :)
04:26:24 <Oejet> Any news in the Haskell world since yesterday?   More updates released?
04:28:53 <malaire> Does anyone know why online-documentation for GHC 6.4 is missing some files (e.g. for Data.Map)
04:28:55 <malaire> (at http://www.haskell.org/ghc/docs/6.4/html/libraries/index.html)
04:29:34 <Oejet> malaire: It's not http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Data.Map.html
04:29:46 <Oejet> Look further down the page.
04:30:40 <malaire> That page gives '[an internal server error occured]' for me
04:31:28 <Oejet> malaire: Oh, sorry.  I was too quick.  Get the same error too.
04:34:59 <tromp> i get a not found on any GHC library in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
04:36:57 <Lemmih> Works for me.
04:38:08 <Oejet> Data.List works, Data.Map not.
04:38:26 <metaperl> is there a preferred or common or most convenient way to express associations between two strings?
04:38:47 <metaperl> [(a,a)] is one way
04:38:54 <Oejet> metaperl: What kind of association?
04:38:54 <metaperl> FiniteMap is another
04:39:10 <metaperl> well, actually this might be a good question for Philippa
04:39:35 <metaperl> for instance, how does Haskell encode CGI query strings so that you can access their information?
04:40:25 <metaperl> which library is commonly used for this purpose?
04:41:11 <Lemmih> I just did [(String,String)] in Hemplate using a hacked Network.CGI
04:41:33 <metaperl> Hemplate? Is that your Halipeto-clone thing?
04:42:18 * Heffalump uses a slightly hacked Network.CGI too for something
04:42:26 <Lemmih> Yep. Although it's not much like Halipeto any more.
04:42:27 <Heffalump> well, rather, an older version that still had a feature I wanted
04:49:06 <Philippa> Lemmih: do you have a hacked version that handles cookies?
04:50:18 <Philippa> metaperl: Network.CGI just keeps an association list of the environment variables and rips the query string for GET or POST data otherwise into it as well (assuming foo=bar&...)
04:50:45 <metaperl> I didn't understand the signature of the wrapper function in Network.CGI
04:51:13 <Philippa> it takes a function of type Environment -> IO Html, where Environment is [(String, String)]
04:51:31 <metaperl> yes
04:51:38 <Philippa> and it yields an IO action that does all the work
04:51:39 <metaperl> now IO Html....
04:51:43 <Philippa> *ah*
04:51:55 <Philippa> um. Am tired. Somebody else do the intro to IO and monads please?
04:52:04 <metaperl> heh... never mind
04:52:23 <Philippa> okay. The short version is that IO a is "an IO computation that yields a value of type a"
04:52:52 <metaperl> ok, so it yields a value of type Html in this  case
04:52:54 <metaperl> got it . thanks
04:53:25 <metaperl> what if you just want to access value of "user" in the query string user=bob&age=33
04:53:34 <Philippa> if you want example code you might want to grab the source for Flippi
04:53:35 <metaperl> how do you get it?
04:53:37 <Philippa> (google'll grab it)
04:53:47 <metaperl> yes, I remember you mentioning that package before
04:53:57 <Philippa> it's tiny, especially in v0.02
04:54:00 <metaperl> ok
04:54:09 <Philippa> you should be able to find your way around it no problem - the original version only had four modules
04:54:11 <jlouis> metaperl: you look inside the Environment for ("user", x)
04:54:28 <Philippa> yeah, the lookup func in List will do that
04:54:42 <Philippa> but I figured referring to Flippi will cover a lot of questions all at once :-)
04:54:49 <metaperl> i'm not finding it Phillipa
04:55:37 <Philippa> third hit on google
04:55:39 <metaperl> oh with an i
04:55:46 <metaperl> I was searcing for Flippy
04:56:56 <Heffalump> metaperl: if you don't need to do IO to generate the Html, you can just make a function of type Environment -> Html
04:57:01 <Heffalump> and then compose it with return
04:57:13 <metaperl> are you a windows user Philippa? the files have ^M in them
04:57:24 <Heffalump> unclean! unclean! :-)
04:57:34 <Philippa> yes, I am
04:57:41 <Philippa> and deal :-)
04:58:09 <Philippa> dos2unix and all that
05:01:01 <metaperl> I learned something just looking at a bit of the code: fromJust (lookup ... )
05:01:14 <metaperl> yet some more useful standard Haskell
05:01:25 <Philippa> yeah. Don't do that unless you /know/ the entry exists though
05:01:37 <metaperl> right otherwise it returns an error
05:01:41 <Philippa> no, it doesn't
05:01:45 <nothingmuch> in YAHT, the listHead and listTail excercises
05:01:47 <Philippa> that's the problem
05:01:54 <nothingmuch> why does listHead Nil = Nil confuse everything?
05:01:54 <metaperl> http://www.zvon.org/other/haskell/Outputmaybe/fromJust_f.html
05:02:20 <nothingmuch> it didn't work for me, but then i removed it, when i noticed the book said i don't need to take care of that, and suddenly it started working
05:02:26 <metaperl> nothingmuch, describe your problem fully.
05:02:37 <metaperl> do you think everyone here knows what exercise you are talking about?
05:02:40 <nothingmuch> given 'data List = Nil | Cons a (List a)
05:02:58 <nothingmuch> metaperl: what's with the pedantic attitude today?
05:03:06 <nothingmuch> and listHead Nil = Nil
05:03:11 <nothingmuch> and listHead (Cons a b) = a
05:03:14 <metaperl> i'm trying to help you...
05:03:18 <nothingmuch> listHead does not behave properly
05:03:50 <Philippa> Nil and a are almost certainly not of the same type
05:03:54 <nothingmuch> but if I remove listHead Nil = Nil, then it does
05:03:56 <nothingmuch> except for an empty list
05:03:59 <nothingmuch> well, it seems like you're trying to educate me
05:04:05 <Philippa> also, it should probably be data List a = ...
05:04:29 <nothingmuch> sorry, it is data List a = Nil | Cons a (List a)
05:04:43 <metaperl> we are all in need of education. you clearly lacked the ability to formulate a question in a way that others could readily answer it
05:04:51 <nothingmuch> i was not done
05:04:55 <nothingmuch> i've been asking questions for many years
05:04:57 <metaperl> so I told you what you needed to do to avoid getting ignored
05:05:03 <nothingmuch> and i sometimes got criticism when i started
05:05:07 <nothingmuch> but for a while now i don't
05:05:10 <theorbtwo> Hm, I don't recall having a problem there -- what improper behavior are you seeing?
05:05:34 <Philippa> theorbtwo: having defined a listHead that only works on lists of lists would suck
05:05:55 <Philippa> metaperl: interpreter errors aren't necessarily catchable
05:06:08 <Philippa> you can't catch pattern match failure outside a monad in Haskell 98
05:07:03 <nothingmuch> what is the std nopaste for #haskell?
05:07:15 <metaperl> paste.lisp.org/new/haskell
05:07:29 <nothingmuch> grazie
05:07:31 <metaperl> there is also a HaskellIrcPaste on haskell.org/hawiki
05:07:47 <wilx> Uhh.
05:07:49 <wilx> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
05:07:54 <wilx> compared to
05:07:59 <wilx> lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
05:08:04 <wilx> Why the change?
05:08:48 <lisppaste2> nothingmuch pasted "listHead Nil confusing listHead (Cons a b)" at http://paste.lisp.org/display/6509
05:09:04 <Lemmih> wilx: 'm a' is more general.
05:09:43 <wilx> Oh, *remembering reading soemting about Maybe monad*
05:09:53 <wilx> something even
05:09:55 <wilx> Ok, thanks.
05:10:00 <wilx> Makes sense a bit :)
05:10:52 <theorbtwo> Oh, I see the problem, nothingmuch.
05:11:34 <nothingmuch> btw, the listFold[lr] excercise works as expected with listFoldr f y Nil = y, and listFoldr f y (Cons a b) = ...
05:11:36 <theorbtwo> No, nevermind, I don't.
05:11:50 * Philippa flicks through the GHC 6.4 docs and blinks
05:11:55 <Philippa> WTF happened to the List module?
05:11:55 <nothingmuch> given that, i don't understand the difference
05:12:24 <nothingmuch> oh, sorry, that's a snip out of the file... it has module List where and some more functions on the bottom
05:12:32 <nothingmuch> if that's what you mean, Philippa
05:12:54 <theorbtwo> No, nothingmuch, unrelated to your question.
05:13:06 <nothingmuch> ah
05:13:22 <theorbtwo> Your problem is that the definition of Cons you are creating takes one parameter, a, and uses it twice.
05:13:34 <_JusSx_> who uses gentoo?
05:13:42 <Philippa> the GHC lib docs no longer document all the H98 libs
05:13:50 <musasabi> Philippa: I think it is the new haddock and the preferred module things.
05:13:54 <nothingmuch> in data List a ...?
05:13:56 * nothingmuch does
05:14:29 <Philippa> musasabi: understandable, it should still document it though
05:14:44 <nothingmuch> theorbtwo: ...?
05:14:45 <Philippa> I mean OK, I don't often write to haskell 98 with no extra libs...
05:15:12 <theorbtwo> data List a, the left hand, says that you've got a type List, parameterized with one type, which can be anything.
05:15:32 <Philippa> and the correct List type is data List a = Cons a (List a) | Nil
05:15:48 <theorbtwo> ...oh, possibly I'm dead wrong.
05:15:57 <theorbtwo> The order is significant, Philippa?
05:16:03 <theorbtwo> I'm quite a beginner.
05:16:08 <Philippa> which bit? The order of the constructors isn't
05:16:14 <Philippa> I just felt like typing the Cons first
05:16:34 <Philippa> the order of a and (List a) matters, but only insofar as it has to line up with the way you do pattern matching
05:16:37 <musasabi> Philippa: true.
05:17:25 <theorbtwo> Um, in that case, what you showed is exactly what nothingmuch has.
05:17:44 <Philippa> then the problem isn't the List type
05:18:06 <Philippa> because that's the canonical parameterically-polymorphic list ADT
05:18:25 <Philippa> the problem appears to be the classic "how do I handle errors?"
05:18:27 <theorbtwo> ADT =? abstract data type
05:18:27 <malaire> nothingmuch: I guess your problem is that 'let' isn't working as you think it is.
05:18:29 <malaire> put "foo = Cons 1 Nil" into your file, and then try "listHead foo" from ghci-interpreter
05:18:33 <Philippa> algebraic datatype
05:19:14 <malaire> sorry, ignore me..
05:19:38 <Philippa> okay, given a List a, what type do you want listHead to return?
05:19:55 * theorbtwo smacks his head.
05:20:11 <Philippa> if the answer is "a", you cannot possibly correctly handle a Nil
05:20:38 <nothingmuch> well, if it's an empty list it has no head, right? so is the head nil?
05:20:44 <Philippa> no
05:20:53 <nothingmuch> or should listHead return Either blah blah?
05:20:53 <Philippa> because Nil is of type List b, not type a
05:21:03 <Philippa> listHead could return an Either or a Maybe, yeah
05:21:13 <nothingmuch> Expected type: List (List a)
05:21:17 <nothingmuch> where is that coming from?
05:21:21 <theorbtwo> You can define multiple functions that take different parameters, but they must always have only one return type.
05:21:22 <Philippa> returning Nil
05:21:26 <Philippa> you're unifying a with List b
05:21:49 <Philippa> one case returns a List b, the other returns whatever the list you took as a parm is a list of
05:21:52 <theorbtwo> The compiler figured out that your "a" must be a List, because List is the only thing that has a Nil in it.
05:21:57 * nothingmuch tries to approximate the definitions of all these new verbs
05:22:16 <Philippa> "unifying" = "finding a way to have them be the same thing"
05:22:18 <theorbtwo> Er, that "you can define" should have been a question.
05:23:06 <Philippa> if you unify a type variable with a type, you say that type variable must always be equal to that type (which may contain another variable)
05:23:31 <Philippa> in one case you take a List a and return an a. So the function always returns an a...
05:23:48 <Philippa> in the other case you take a List a and return Nil which is a List b
05:23:56 <Philippa> so the implementation works out a = List b
05:24:16 <Philippa> and when it substitutes that in, there's only one type variable in the resulting type, so it calls that a
05:24:24 <Philippa> (because it can)
05:24:42 <nothingmuch> 	listHead Nil = Nothing
05:24:43 <nothingmuch> 	listHead (Cons a b) = Just a
05:24:46 <nothingmuch> is that what I really meant?
05:24:50 <Philippa> possibly
05:25:07 <Philippa> might I suggest you call the b in (Cons a b) as instead?
05:25:17 <Philippa> (as in 'plural of a', or 'many of a')
05:25:24 <Philippa> it's a convention folks often use
05:25:33 <nothingmuch> ok
05:25:36 <nothingmuch> sounds reasonable
05:25:43 <theorbtwo> You might want to try doing :t on things when things get confusing.
05:25:54 <nothingmuch> i normally see lists as a sort of lopsided tree
05:25:58 <theorbtwo> (Which may just lead to more confusion.)
05:26:27 <nothingmuch> so i have one side, and another side, at every elem, a and b... i should probably get used to really treating lists like i used to treat arrays
05:27:22 <theorbtwo> Well, the defintion of list there really is a lopsided tree.
05:27:24 <nothingmuch> is 'Just 1' possibly equivelent to '1'?
05:27:42 <theorbtwo> Nope, sorry.
05:27:55 <nothingmuch> theorbtwo: yes it is, but people obviously tend to think it's saner to look at it's abstracted form
05:28:34 <Philippa> also it's not really a tree as such, it's equivalent to the C-style linked list
05:28:35 <malaire> nothingmuch: Are you thinking about YAHT exercise 4.8? or something else?
05:28:48 <nothingmuch> malaire: yes, I am
05:28:55 <Philippa> (well, almost - sadly it needs a third word to store whether it's Cons or Nil)
05:29:14 <nothingmuch> i didn't notice at first that it said i didn't need to take care of this case
05:29:14 <theorbtwo> A linked list is also a sort of lopsided tree.
05:29:24 <theorbtwo> Unlike, say, a perl list or a C array.
05:30:27 <nothingmuch> Philippa: i also treated that as a lopsided tree... I usually looked at it like 'i am at x, i can either choose the value, or decend further, into the list', where either choice is a side
05:30:49 <nothingmuch> i used to draw linked lists like an unbalanced tree
05:30:54 <nothingmuch> but then i actually learned about them
05:31:00 <nothingmuch> and saw that people chain them up nicely
05:31:16 <nothingmuch> but I haven't yet gotten out of that fixation
05:32:15 * Philippa nods
05:32:24 <nothingmuch> ok, now moving on
05:32:34 <nothingmuch> I seem to grasp that 'Nil' is not some kind of builtin
05:32:35 <Philippa> you /can/ consider linked lists as degenerate trees
05:32:49 <Philippa> 1-trees, if you like. They just never branch
05:33:05 <nothingmuch> because it seems that in the data BinaryTree definition simply implies Leaf to be something, err, that makes sense
05:33:13 <nothingmuch> is that assumption true?
05:33:44 <theorbtwo> No; your type "List" has two different constructors, "Nil", and "Cons".  (And you can tell something constructed with Nil from something constructed with Cons.)
05:34:53 <nothingmuch> is Cons a builtin? or is it's behavior derived from the way in which I wrote it?
05:34:57 <nothingmuch> like, when i say data Pair = Pair a b
05:34:59 <nothingmuch> it's nearly the same thing
05:35:01 <nothingmuch> and in that example Pair was a user def
05:35:02 <nothingmuch> is Cons not a builtin either?
05:35:09 <theorbtwo> Nope, you just defined it.
05:35:14 <nothingmuch> funky
05:35:16 <Philippa> This Is Not Lisp :-)
05:35:32 <theorbtwo> And thank god it doesn't have car and cdr!
05:35:45 <nothingmuch> so why the hell is it still called Cons, ffs?!
05:35:57 <Philippa> because it's built in much the same way
05:36:17 <nothingmuch> i understand their parralisation
05:36:19 <Philippa> you have an empty list, or you have a pair of an item and a list
05:36:35 <nothingmuch> it's just that if a newbie like me is learning from YAHT
05:36:38 <nothingmuch> and sees Cons
05:36:39 <Philippa> algebraic datatypes sort-of generalise cons cells, in that they can hold any number of items rather than just two
05:36:45 <Philippa> then it doesn't mean anything to you
05:36:46 <nothingmuch> which could be some nicer word instead
05:36:52 <theorbtwo> Because the author of YAHT came from a LISP background, p'haps?
05:37:05 <nothingmuch> well, whatever
05:37:09 <Philippa> or because everybody else'll call it cons
05:37:14 <musasabi> Cons is the normal name for the list constructor.
05:37:25 <Philippa> the haskell list type uses : and [], but people often pronounce them cons and nil...
05:37:38 <nothingmuch> beh
05:37:42 <Philippa> it /would/ be nice if there were a historical footnote explaining why Cons and not Item...
05:37:43 * nothingmuch can cope with that
05:37:44 <theorbtwo> Nil makes sense to me... but "cons"?
05:37:52 <nothingmuch> cons...truct
05:37:56 <nothingmuch> that's what I first thought it was
05:38:03 <Philippa> because you'd cons a pair in lisp
05:38:06 <nothingmuch> but then 'car? cdr? cdaadr? wtf?!'
05:38:12 <Philippa> (cons item next)
05:38:18 <musasabi> A list of t is either Nil or Cons of a t and a list of t
05:38:29 <Philippa> nothingmuch: the result of cons is called a cons cell
05:38:42 <Philippa> Cell Address Register/Data Register, for historical reasons
05:38:45 <theorbtwo> Because the original LISP used the contents of the decrement portion of the register, and the contents of the address portion of the register.
05:38:50 <Philippa> (IANALisper...)
05:38:53 <nothingmuch> aaaah
05:39:09 <Philippa> first and second would've been much better names, but hey
05:39:15 <theorbtwo> In other words, 40 years of backwards compatability with people's brains.
05:39:25 <musasabi> Actually cdr = contents of decrement register iirc.
05:39:54 <nothingmuch> well, anywho, thanks Philippa, theorbtwo, malaire
05:39:57 * nothingmuch gets back to learning
05:40:13 <theorbtwo> I just hope I haven't said anything too horribly wrong.
05:40:30 <theorbtwo> I know what he's talking about... because I did those excersizes the day before yesterday.
05:40:44 <xerox> And they have the good property to being easily arbitrarily composed like: caddr, cdar, caar, etc..
05:41:22 <theorbtwo> Should have just had two operators that were easier to type, then, and not needed more abbreviation.
05:41:41 <Philippa> um. It's lisp. No can do, you still get the parens.
05:42:40 <theorbtwo> Oh: in haskell, is foo(1 2 3) invalid and you need to foo (1 2 3), or is there something else messing me up there?
05:42:51 <Philippa> something else
05:42:56 <Philippa> lists are [1,2,3]
05:43:05 <Philippa> you're trying to apply 1 to 2
05:43:10 <Philippa> and then the result to 3
05:43:36 <theorbtwo> Even if foo :: a -> a -> a -> a ?
05:43:44 <Philippa> think what parens mean
05:44:03 <Philippa> you want foo 1 2 3
05:44:13 <Philippa> juxtaposition is function application
05:44:28 <Philippa> add 1 => 2, add (add 1) => 3
05:44:50 <Philippa> add add doesn't type, so neither does add add 1
05:44:58 <Philippa> f g h = (f g) h
05:45:10 <Philippa> This Is Not Lisp :-)
05:45:15 <theorbtwo> Too many parens in lisp, too few in haskell.
05:45:29 <theorbtwo> I know, I no doubt will get used to it eventually.
05:45:39 <Philippa> you can add as many superfluous parens as you like
05:45:44 <Philippa> you should get used to it pretty quickly
05:45:51 <Philippa> just remember that all functions take exactly one parameter
05:46:06 <theorbtwo> I know, but that's still what messes me up.
05:46:12 <Philippa> foo :: a -> (a -> (a -> a))...
05:46:32 <Philippa> remember parens are what they mean in maths and not what they mean in lisp. It'll help.
05:46:49 <theorbtwo> Yeah, that creeps me out; I want that to be (a, a, a) -> a, but that's something different.
05:47:00 * Philippa nods
05:47:01 <Oejet> Can the strings {{ and }} be in a legal Haskell program (except in strings of course)?
05:47:03 <Philippa> the curried version's nicer
05:47:26 <Philippa> Oejet: Don't think so, with the exception of -}}
05:47:36 <Philippa> (as in {- foo -}})
05:47:53 <Philippa> oh, and thus {{- as well
05:48:44 <Oejet> Philippa: Ok, thanks.
05:49:04 <Philippa> the layout rule works because you can predict where they would otherwise be based on the previous token
05:50:32 <wilx> Hmpf. http://www.haskell.org/hawiki/HaskellIrcPastePage
05:50:37 <wilx> What do I do wrong?
05:53:08 <Philippa> you're doing something equivalent to newListArray (0, 5) ([1 .. 6])...
05:53:16 <Philippa> it looks like the error itself is arising from elsewhere though
05:58:11 <musasabi> wilx: that does not cause any error.
05:58:25 <musasabi> wilx: are you importing Control.Monad.ST and Data.Array.ST ?
05:59:40 <wilx> Reload, I have put the whole thing on the paste page.
06:02:28 <wilx> I am using GHC 6.4, if it is important.
06:04:41 <musasabi> that works with ST but fails with ST.Lazy.
06:04:55 <wilx> Uh.
06:05:39 <wilx> Is there something that says I souldn't use ST.Lazy with STArray?
06:06:20 <musasabi> wilx: I think that it works only with strict ST.
06:06:42 <musasabi> but it is too long since I read the ST paper to say anything definite.
06:06:52 <wilx> Ok.
06:07:10 <musasabi> Out of curiosity what do you need ST.Lazy for ?
06:07:30 <wilx> Hmm, not sure :)
06:07:55 <wilx> I just need the array.
06:08:27 <musasabi> Strict ST then. Also if you use Ints making it STUArray might be worthwhile.
06:08:48 <wilx> And because I thought they are interchangable I just thought "Hey, why not use ST.Lazy."
06:08:57 <wilx> Ok.
06:15:18 <nothingmuch> when I say 'data a b c'
06:15:54 <nothingmuch> err, sorry, 'data Foo a b c'
06:15:55 <nothingmuch> does it mean 'the following constructurs can use any of three types in the way they do, and it will be a valid Foo?'
06:16:16 <nothingmuch> or does 'a b c' have any implications on the construction itself?
06:17:18 <autrijus> in standard haskell
06:17:39 <nothingmuch> err, let me be more specific:
06:17:57 <nothingmuch> does 'a b c' have any implications on blah blah blah that I should care about right now?
06:17:58 <autrijus> "data Foo a b c" means that the "Foo" type has three variables
06:18:07 <nothingmuch> has, or can have?
06:18:15 <nothingmuch> err, ask a stupid question
06:18:31 <nothingmuch> please go on, forget my last two lines
06:18:57 <autrijus> ok...
06:19:39 <autrijus> "data Foo a"
06:20:06 <autrijus> means that its constructors can take differenet types as arguments
06:20:11 <autrijus> i.e. "polymorphic"
06:20:24 <autrijus> but there must be one (and only one) such variable
06:20:49 <nothingmuch> uhuh
06:20:49 <autrijus> that means its constructor cannot take two polymorphic types
06:20:56 <autrijus> unless of course, they are of the same type.
06:20:58 <autrijus> so
06:21:19 <autrijus> data DataType a = Constructor a a
06:21:20 <autrijus> is ok
06:21:22 <autrijus> but
06:21:26 <autrijus> data DataType a = Constructor a b
06:21:26 <autrijus> is not
06:21:28 <autrijus> neither is
06:22:05 <autrijus> data DataType a = Constructor a b c
06:22:09 <autrijus> however,
06:22:13 <autrijus> data DataType a = Constructor
06:22:14 <autrijus> is ok.
06:22:24 <nothingmuch> so are 'data Foo a b = Foo a' and 'data Foo b' equivelent?
06:22:40 <nothingmuch> err, 'data Foo a b = Foo b'
06:23:12 <autrijus> not exactly
06:23:31 <autrijus> because when writing type signatures, you can fill in concrete values for a and b
06:23:32 <autrijus> eg.
06:23:40 <autrijus> func :: Foo Int String
06:24:03 <autrijus> in that case, "FooConstructor Int"  will work
06:24:23 <autrijus> if it was declared as "data Foo a b = FooConstructor a"
06:24:36 <autrijus> but it will not work if it was declared as "data Foo a b = FooConstructor b"
06:24:38 <nothingmuch> i think i see
06:24:59 <autrijus> cool
06:25:01 <nothingmuch> i.e. func would choke on FooConstructor b
06:25:06 <autrijus> exactly.
06:25:18 <nothingmuch> because it explicitly fills in types for the Foo data thingy
06:25:45 <autrijus> that is called "unification"
06:25:56 <autrijus> you "unify" the 'Int' with 'a'
06:25:58 <autrijus> not with 'b'
06:26:08 <nothingmuch> and it can either be explicit, or implicit via type inferrence?
06:26:13 <autrijus> exactly!
06:26:42 <nothingmuch> thinks might actually start making sense sometime soon ;-)
06:26:47 <autrijus> cool :)
06:26:57 <autrijus> Pugs uses only very primitive data types
06:27:07 <autrijus> most are unparameterized (i.e. not polymorphic)
06:27:21 <autrijus> so it should be fine. I don't think I'll make use of GADT any time soon.
06:27:24 <xerox> <autrijus> data DataType a = Constructor
06:27:27 <xerox> What does it mean?
06:27:43 <autrijus> (GADT being the GHC 6.4 feature that subverts most of my explanation above)
06:27:46 <nothingmuch> xerox - as I gather it can be parallelled to an enum
06:27:50 <nothingmuch> the type is the value in that case
06:27:54 <nothingmuch> i see no other use for that
06:28:04 <autrijus> xerox: it means that, you can use "Constructor" to make any DataType x
06:28:12 <autrijus> you can use it to mean DataType Int, or DataType String.
06:28:17 <autrijus> here is a concrete useful use:
06:28:27 <autrijus> data Maybe a = Just a | Nothing
06:28:35 <xerox> Oh, yes.
06:28:52 <autrijus> I hope you grok it already because it will get very difficult to elaborate further :)
06:28:54 <nothingmuch> more of a technical quesstion
06:29:02 <nothingmuch> how are constructor namespace clashes dealt with?
06:29:17 <autrijus> it is dealt with the same fashion as duplicate functions.
06:29:21 <autrijus> i.e. fatal error.
06:29:34 <nothingmuch> ... at compile time?
06:29:46 <autrijus> of course!
06:29:56 <nothingmuch> *blush*
06:30:01 <autrijus> :)
06:30:15 <autrijus> there are very few runtime errors in Haskell, except for IO things.
06:30:17 <nothingmuch> can a diff constructor be  named, with the same signature, but in the context of a different data type pyramid thingy?
06:30:42 <autrijus> you have to put it in a different module
06:30:46 <autrijus> hence different file.
06:30:50 <autrijus> again, same as functions.
06:30:51 <nothingmuch> aha
06:31:07 * nothingmuch has mostly been playing in an interactive env, and can't quite tell apart runtime and compile time
06:31:14 <nothingmuch> soon
06:31:17 <autrijus> ah. time to learn the :r command :)
06:31:21 <autrijus> ghci test.hs
06:31:22 <autrijus> :r
06:31:23 <autrijus> :r
06:31:23 <autrijus> :r
06:31:26 <nothingmuch> i use it
06:31:29 <xerox> C-x o C-l
06:31:30 <xerox> :)
06:50:30 <wilx> Hmm, isn't there anything like C assert that I could use?
06:51:09 <Lemmih> @index assert
06:51:11 <lambdabot> Control.Exception,GHC.Base
06:51:20 <Lemmih> @type Control.Exception.assert
06:51:21 <lambdabot> Control.Exception.assert :: forall a. Bool -> a -> a
06:51:47 <wilx> Ah!, I will remember to try lambdabot first next time :)
06:51:50 <wilx> Thanks.
06:52:42 <nothingmuch> elements2 = foldTree (:) []
06:52:49 <nothingmuch> how does that make sense?
06:52:52 <nothingmuch> page 186 of yaht
06:53:06 <nothingmuch> solution to list of elements in terms of fold, on binary trees
06:53:16 <nothingmuch> i tried elements2 t = foldTree (:) [] t
06:53:30 <nothingmuch> but that didn't work, so i looked at the solution, and founds that atrocity
06:53:38 <xerox> It's the same thing
06:53:40 <nothingmuch> does it simply steal foldTree's type?
06:54:07 <nothingmuch> given any version of foldTree, create an elements2 that uses that version, and has the same type?
06:55:15 <nothingmuch> why did my first solution not work, btw?
06:55:38 <Lemmih> You're refering to too many things I haven't seen.
06:56:00 <xerox> @type \t -> foldr (:) [] t
06:56:01 <lambdabot> \t -> foldr (:) [] t :: forall a. [a] -> [a]
06:56:06 <xerox> @type foldr (:) []
06:56:07 <lambdabot> foldr (:) [] :: forall a. [a] -> [a]
06:56:16 <Lemmih> s/refering/referring/
06:57:42 <nothingmuch> xerox - so that means that lambda with no explicit type signature inherits the type signature from whatever it calls?
06:58:29 <xerox> nothingmuch, if I'm understainding you correctly, the answer would be: Yes, 'a' could be any type, it's called polymorphism.
06:58:40 <xerox> understanding, even
06:58:45 <nothingmuch> that's not really what i meant
06:58:57 <nothingmuch> i think that's derived from whatever data [] says
06:59:12 <nothingmuch> one second
06:59:14 <Lemmih> nothingmuch: Of course and it's called type inference.
07:00:06 <nothingmuch> hmm
07:00:18 <nothingmuch> the problem is not with my elemtns function, but with my foldTree function
07:00:24 <nothingmuch> i'll solve it first
07:00:27 <nothingmuch> then i'll be able to look at the types
07:00:32 <nothingmuch> and then i might come back for more questions
07:00:40 <nothingmuch> sorry for making everyone crazy
07:00:59 <nothingmuch> Lemmih: i thought that for type inferrence to work you must at least declare for it the type variables to work in ;-)
07:03:46 <Lemmih> huh?
07:04:02 <nothingmuch> nevermind, i think my facts are wrong
07:04:17 <nothingmuch> once i get them straight maybe my questions will start making sense
07:04:22 <Lemmih> The implementation already knows the type of everything ('a').
07:04:40 <nothingmuch> 	elements2 =  <-- no signature?
07:05:05 <nothingmuch> elements2 = foldTree (:) [] <-- foldTree takes f y (...)
07:05:10 <Lemmih> It still has a type.
07:05:14 <nothingmuch> does elements2 mean elements2 (...)?
07:05:27 <nothingmuch> same (...)
07:06:03 <Lemmih> Could you rephrase that?
07:07:56 <nothingmuch> err
07:08:08 <nothingmuch> i have elements2 = foldTree (:) []
07:08:15 <nothingmuch> and foldTree's signature is f y blah
07:08:19 <nothingmuch> blah is some constructor
07:08:30 <nothingmuch> is elements2's type implicitly blah?
07:08:39 <nothingmuch> for any given foldTree?
07:09:03 <nothingmuch> elements2's signature
07:09:08 <xerox> I think I see what you mean.
07:09:09 <nothingmuch> not type
07:09:33 <xerox> The type is inferred from foldTree, that's why you get the "extra" parameter in the type signature.
07:09:34 <Lemmih> xerox: Great, for I don't.
07:09:42 <nothingmuch> ok
07:09:49 <xerox> (Even if you don't specify it by hand)
07:10:03 <nothingmuch> ok, makes sense
07:10:09 <xerox> Oh, yeah.
07:10:17 <xerox> It's called partial application.
07:10:44 <xerox> I think YAHT introduces it..
07:11:04 <nothingmuch> from a less functional perspective it looks like elements2 is wildcarded for any possible foldTree signature
07:11:09 <nothingmuch> well, it hasn't done so yet
07:11:19 <nothingmuch> i guess i should first read it through
07:11:24 <nothingmuch> then ask questions
07:12:02 <nothingmuch> now to figure out why foldTree (:) [] foo breaks, but foldTree (+) 1 foo works
07:12:33 <xerox> I think 'breaks' is not enough to help you.
07:12:45 <TheHunter> hmm, i think the answer to that excersise is, well, misleading, foldTree should have type (b -> a -> b -> b) -> (a -> b) -> BinaryTree a -> b
07:12:49 <nothingmuch> i would like to figure this one out myself
07:13:14 <TheHunter> (ignore me if that's confusing you)
07:13:26 <nothingmuch> it is
07:13:30 <nothingmuch> =)
07:14:04 <TheHunter> the foldTree as in the solution in yaht, just folds the flattened tree (i.e. a list).
07:14:13 <autrijus> I think having two languages, a lambda calculus for normal functions, and a not-quite-lambda-but-powerful type calculus for types, is misleading :)
07:14:20 <autrijus> s/misleading/confusing/
07:14:32 <autrijus> it will help of course if we all use unicode terminals and write alpha and beta instead of a and b :)
07:16:30 <TheHunter> it's usually easy to tell them apart.
07:16:32 <nothingmuch> ok ok i give up
07:17:35 <TheHunter> nothingmuch, what do you mean "foldTree (:) []" breaks?
07:17:44 <nothingmuch> i'm nopasting now
07:17:47 <autrijus> what error message does it give you?
07:18:13 <lisppaste2> nothingmuch pasted "foldTree works with (+) 1 but now with (:) []" at http://paste.lisp.org/display/6528
07:18:51 <nothingmuch> s/now/not/
07:19:47 * nothingmuch would rather implement foldTree in terms of elements... Silly YAHT
07:20:25 <TheHunter> *BinaryTree> :t foldTree
07:20:26 <TheHunter> foldTree :: forall a. (a -> a -> a) -> a -> BinaryTree a -> a
07:20:51 <nothingmuch> TheHunter: can you annotate that?
07:21:39 <TheHunter> the type ghc infers for foldTree isn't what you want.
07:22:30 <TheHunter> i guess you want "foldTree f y (Leaf x) = f x y"
07:23:07 <TheHunter> at least that's yaht solution after variable renaming.
07:23:24 * nothingmuch didn't notice a difference
07:23:27 <nothingmuch> but wait... should there be one?
07:23:51 <TheHunter> you pasted "foldTree f y (Leaf x) = f y x"
07:24:03 <autrijus> x and y juxtaposed
07:24:04 <xerox> nothingmuch, notice :: and =, the former introduces type signature, the latter function definition
07:24:46 <nothingmuch> so what i did creates f y x, that is (:) [] (Leaf blah)
07:25:03 <nothingmuch> and []:1 does not make sense?
07:25:09 <TheHunter> right.
07:25:16 <autrijus> @type (:)
07:25:17 <lambdabot> (:) :: forall a. a -> [a] -> [a]
07:26:00 * nothingmuch will reread on how to read type signatures
07:26:02 <autrijus> I like the fact that ghc 6.4 now doesn't add the "forall a."
07:26:07 <nothingmuch> i think i missed more than I thought I missed
07:26:22 <TheHunter> on the left of ':' there should be a list element, on the right the rest of the list.
07:27:02 <autrijus> nothingmuch: you read the last element as "returns" and everything else as positional arguments.
07:27:20 <autrijus> so, "a -> [a] -> [a]" in haskell becomes
07:27:32 <nothingmuch> func a [a] = [a]
07:27:36 <TheHunter> autrijus, really? 6.4.20050303 prints the 'forall'.
07:27:36 <nothingmuch> sort of
07:27:45 <autrijus> sub (Any, List of Any) returns List of Any
07:27:50 <nothingmuch> except that i'm mixing type vars with actual stuff?
07:27:53 <autrijus> TheHunter: it does that with -fglasgow-exts
07:28:00 <nothingmuch> ok
07:28:06 <autrijus> TheHunter: but by default :t doesn't add the forall anymore.
07:28:09 * nothingmuch wonders why it's not a, [a] -> [a]
07:28:14 <autrijus> (6.4-final here)
07:28:20 <nothingmuch> or 'a [a] -> [a]' (maybe that's not as readable?)
07:28:30 <autrijus> nothingmuch: easy, because it can only be used as
07:28:33 <TheHunter> ah, that explains things...
07:28:41 <autrijus> sub (Any) returns sub (Any) returns List of Any
07:28:47 <autrijus> i.e. if you only feed it one argument
07:28:57 <autrijus> it returns a function that takes a list and gives back a list.
07:28:59 <TheHunter> alias ghci='ghci -Wall -cpp -fglasgow-exts -fno-monomorphism-restriction -farrows' ...
07:29:04 <autrijus> TheHunter: heh heh.
07:29:15 <autrijus> nothingmuch: so, a -> b -> c
07:29:16 <autrijus> can be read as
07:29:19 <autrijus> a -> (b -> c)
07:29:19 <autrijus> or
07:29:31 <autrijus> a -> b     -> c
07:29:38 <autrijus> it's called "currying".
07:29:52 <nothingmuch> i get it
07:30:31 <nothingmuch> the evaluation of (:) really is creating a new closure, that when evaluated returns a list that is the first element, the Any it was constructed in the context of, and a list that is passed to it?
07:30:40 <autrijus> err, I should've said sub (Any) returns (sub (List of Any) returns List of Any)
07:31:15 <nothingmuch> like, in perl(6ish), that would be sub concat ($x) { return sub (@foo) { return ($x), @foo } }
07:31:31 <autrijus> correct.
07:31:38 <nothingmuch> purdy
07:31:44 <autrijus> except in perl6 you use .assuming for that.
07:32:02 <nothingmuch> i don't want to know what perl6 does, might do, will not do or did for this kind of stuff ;-)
07:32:10 <autrijus> ok. then you already get it :)
07:32:26 <nothingmuch> i'll cross that bridge when i need to use it for real work, or i'm writing tests
07:32:33 <autrijus> nodnod.
07:32:34 <nothingmuch> (which reminds me ;-)
07:32:53 <autrijus> oh btw, "Gentle Introduction" may be more helpful than YAHT at a certain point.
07:32:57 * nothingmuch feels as though he is not as stupid as he felt he was before
07:33:02 <autrijus> but if you're enjoying YAHT, stick with it. :)
07:33:10 <nothingmuch> i'm sort of
07:33:14 <nothingmuch> i have some grudges
07:33:25 <nothingmuch> but i have a feeling like i'm expecting too much at once
07:33:34 <nothingmuch> and that these issues will be dealt with later
07:35:06 * nothingmuch has a headache (not from the haskell) and goes try and fix it
07:49:52 <_JusSx_> how does haskell-mode works?
07:49:55 <_JusSx_> can you help me?
07:50:47 <xerox> _JusSx_, I think the readme file explains it well, put in a directory in your load-path and add the mode-handlers
07:51:24 <wilx> Yay! the Map.lookup returning monad is actually very neat.
07:51:48 <wilx> It can return Maybe a or [a] depending on context.
07:51:56 <_JusSx_> README
07:51:56 <_JusSx_> ?
07:52:00 <_JusSx_> hum
07:52:01 <xerox> _JusSx_, yep.
07:52:10 <_JusSx_> i forgot it
07:52:59 <_JusSx_> well i don't have any readme file
07:53:27 <xerox> Do you know Emacs?
07:54:14 <_JusSx_> yeah
07:54:32 <xerox> Did you decompress the haskell-mode tarball in a load-path directory?
07:54:38 <_JusSx_> yeah
07:55:13 <_JusSx_> i don't need to know how to install it
07:55:15 <xerox> Then add these lines to ~/.emacs
07:55:19 <xerox> Ah, okay.
07:55:19 <_JusSx_> i installed itt
07:55:36 <_JusSx_> i need to know how it works
07:57:45 <musasabi> M-x haskell-mode ?
07:57:50 <_JusSx_> ok
07:57:51 <_JusSx_> then
07:57:51 <xerox> I don't remember where I read about it..
07:58:05 <_JusSx_> i wonna run ghci
07:58:06 <xerox> I usually just use C-c C-l.
07:58:32 <xerox> To run ghci you need M-x haskell-ghci-show-ghci-buffer
07:58:46 <_JusSx_> key binding?
07:58:56 <xerox> To run it and load the visiting .hs file, you can C-c C-l
07:59:17 <_JusSx_> sorry i got an error
07:59:22 <_JusSx_> it looks for hugs
07:59:38 <xerox> You didn't installed it completely.
07:59:52 <_JusSx_> lol
07:59:55 <_JusSx_> i installed it
07:59:57 <xerox> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
08:00:09 <_JusSx_> yeah i added that line
08:00:16 <xerox> (setq haskell-ghci-program-name ...)
08:01:50 <Lemmih> Did you delete the turn-on-haskell-hugs line?
08:02:22 <_JusSx_> OK NOW I DID IT
08:02:24 <_JusSx_> THANX
08:02:31 <_JusSx_> sorry
08:02:41 <Oejet> _JusSx_: No need to yell.
08:02:52 <_JusSx_> thax
08:03:34 <_JusSx_> yeah now it works great thanx a lot
08:03:50 <_JusSx_> really cool
08:04:06 <autrijus> I really need to learn to use mdo.
08:04:07 * Lemmih is having a wonderful time playing with graphics and sound from Haskell.
08:04:42 <Oejet> Lemmih: Can I see some SDL program you made?
08:05:53 <Lemmih> Oejet: Haven't done anything serious.
08:06:08 <Oejet> Lemmih: Doesn't matter.
08:09:48 <Lemmih> Oejet: DCC?
08:14:34 <Lemmih> Oejet: I've pasted the code at the HaskellIrcPastePage.
08:15:38 <Lemmih> It's a port of some HClanLib code I had.
08:39:05 <metaperl> CosmicRay, ping?
08:40:59 <_JusSx_> i would like to use HSQL in ghci
08:41:11 <_JusSx_> how can i do ?
08:41:14 <_JusSx_> :l HSQL
08:41:15 <_JusSx_> ?
08:41:22 <Lemmih> You can try.
08:41:28 <_JusSx_> ok i did
08:42:37 <Lemmih> HSQL doesn't contain a module named HSQL.
08:42:56 <Lemmih> Try Database.HSQL
08:43:11 <_JusSx_> import Database.HSQL.ODBC
08:43:25 <_JusSx_> import Control.Exception
08:43:25 <_JusSx_> import Database.HSQL.ODBC
08:43:25 <_JusSx_> import Queries
08:43:30 <_JusSx_> from the examples
08:45:35 <_JusSx_> Modules
08:45:35 <_JusSx_> Database	
08:45:35 <_JusSx_> Database.HSQL	
08:45:35 <_JusSx_> Database.HSQL.MySQL	
08:45:35 <_JusSx_> Database.HSQL.ODBC	
08:45:37 <_JusSx_> Database.HSQL.PostgreSQL	
08:45:40 <_JusSx_> Database.HSQL.SQLite
08:46:49 <Lemmih> _JusSx_: Are you trying to say something or just feeling like spamming the channel? (:
08:47:23 <_JusSx_> i'm trying to say that there are several modules
08:47:34 <_JusSx_> i listed them aboce
08:48:40 <Lemmih> Yes of course there is. Never said there weren't.
08:49:01 <_JusSx_> ok thanx
08:49:05 <_JusSx_> i solved the prob
08:49:18 <_JusSx_> the main prob is the starting path
08:49:39 <araujo> Hello around here...
08:49:46 <araujo> mm.. _JusSx_ using hsql?
08:49:51 <Lemmih> Greetings, araujo.
08:49:56 <_JusSx_> why not?
08:50:00 <araujo> How you doing Lemmih ?
08:50:36 <Lemmih> I'm doing just fine, thank you.
08:50:43 <araujo> _JusSx_, are you using it with odbc enabled?
08:50:45 <araujo> 8)
08:50:56 <araujo> Lemmih, Already using ghc6.4?
08:50:58 <_JusSx_> i'm testing it
08:51:10 <_JusSx_> i never used it before
08:51:43 <_JusSx_> why are you asking?
08:52:08 <araujo> testing here, but i can't get it compiled with odbc and sqlite support
08:52:10 <Lemmih> araujo: Yep (: Been following the development of 6.3 for months.
08:52:15 <araujo> can you?
08:52:22 <araujo> 8)
08:54:45 <xerox> Are there win32 builds of ghc 6.4?
08:54:56 <xerox> I'd really love to try it :(
08:55:45 <musasabi> xerox: yes.
08:55:54 <Oejet> xerox: You could compile it youself. :-P
08:55:56 <xerox> musasabi, great! Can you point me to them?
08:56:02 <Philippa> yeah, found it'd been released when I got back to my browser this morning
08:56:07 <Philippa> the main GHC downloads page
08:56:07 <musasabi> http://www.haskell.org/ghc/dist/6.4/ghc-6-4.msi
08:56:15 <xerox> Thanks *so* much.
08:57:59 <araujo> _JusSx_, hellu?
08:58:05 * araujo won't have time to test till next week probably
08:58:21 <wilx> Umm, a but OT question. What do I write into .htaccess to make my Darcs repo browsable?
08:58:44 <wilx> s/a but//
09:00:14 <xerox> Options +Indexes ?
09:01:53 <wilx> Yup, thanks.
09:03:22 <xerox> Good :)
09:03:43 <_JusSx_> araujo: i'm using mysql
09:03:58 <_JusSx_> araujo: and i have trouble with compiling it properly too
09:04:05 <_JusSx_> araujo: the prob is the makefile
09:04:21 <araujo> _JusSx_, only mysql?.. and what kind of problems?
09:04:38 <_JusSx_> araujo: it can't find a source file
09:04:46 <_JusSx_> araujo: it uses wrong path
09:07:38 <wilx> @index expectJust
09:07:38 <lambdabot> bzzt
09:07:45 <wilx> @index justExpected
09:07:45 <lambdabot> bzzt
09:07:57 <araujo> _JusSx_, Gentoo right?
09:08:02 <_JusSx_> yeah
09:08:18 <_JusSx_> /opt/ghc/bin/hsc2hs src/HSQL/MySQL.hsc -I/usr/include/mysql
09:08:19 <_JusSx_> MySQL.hsc:33:21: HsMySQL.h: No such file or directory
09:09:01 <araujo> yes, the configure is just weird
09:09:29 <araujo> the --disable and --enable options doesn't look to affect anything
09:09:33 <_JusSx_> fastest way is to copy HsMySQL.h in /usr/include/mysql
09:10:01 <_JusSx_> but i don't like it
09:10:09 <araujo> yes, ugly
09:10:25 <_JusSx_> i wonnca compile it don't install it
09:11:08 <araujo> you get another error i suppose
09:23:25 <Spark_> the handbook of logic in computer science is l33t
09:23:34 <desrt> huth+ryan is l33t
09:33:10 <wilx> Hmm, some function in a monad returns (M val) and another function in the same monad takes val.
09:33:37 <wilx> How can I compose them so that I do not need to go through an intermediate x <- func1 binding?
09:33:46 <musasabi> @type (>>=)
09:33:47 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
09:34:05 <TheHunter> @type (=<<)
09:34:07 <lambdabot> (=<<) :: forall b m a. (Monad m) => (a -> m b) -> m a -> m b
09:34:10 <wilx> Ah, obvious :)
09:34:17 <wilx> I should have found out myself.
09:34:31 <jlouis> desrt: I hate huth+ryan
09:34:44 <jlouis> desrt: they have so much text, and so little theorems
09:34:57 <jlouis> and they have numerous errors in some of their theorems too
09:34:59 <jlouis> bleh
09:35:37 <desrt> well
09:35:45 <desrt> everyone i know is quite fond of huth+ryan
09:35:54 <desrt> (it's reasonable to say that i don't really know you) :)
09:42:53 <jlouis> desrt: I think it depends on the reader. I like books to be more like european math books (small + concise).
09:44:17 <wilx> When I do { val <- producer ; ref <- newSTRef val ; rec <- Rec { f1 = ref , f2 = ref } ; writeSTRef (f1 rec) newVal }, is the change made by write to the reference in f1 visible through the reference in f2?
09:44:44 <wilx> I.e. is there any "pointee sharing"?
09:47:22 <musasabi> wilx: no.
09:47:31 <wilx> I thought so. Ok.
09:47:35 <musasabi> wilx: you could have STRef (STRef a)
09:47:44 <wilx> Yup.
09:47:44 <musasabi> the same as in C.
09:53:37 <Lemmih> I would say yes.
09:54:30 <wilx> Hm?
09:55:07 <Lemmih> 'ref', 'f1 rec' and 'f2 rec' are exactly the same, right?
09:55:47 <wilx> I guess so.
09:57:19 <Lemmih> Then yes, changes in 'f1 rec' will be visible through 'f2 rec'.
09:58:12 <wilx> Hmm, ok, I will test it anyway :)
09:59:04 <Heffalump> errm, yes
09:59:12 <Heffalump> I'd be very worried if it wasn't shared
09:59:34 <Heffalump> if you wanted non-shared behaviour, you'd need two calls to newSTRef
10:03:08 <desrt> ls
10:03:10 <desrt> erp!
10:13:34 <tromp> i agree; it will be shared
10:16:20 <musasabi> do { let val = 5; r0 <- newSTRef val; r1 <- newSTRef val; let r2 = r1; writeSTRef r2 6; } now r0 = 5, r1 = 6, r2 = 6.
10:18:35 * Heffalump takes issue with musasabi's notation.
10:18:52 <Heffalump> readSTRef r0 == return 5
10:19:17 <Heffalump> though even that's a bit dodgy
10:20:09 <musasabi> Heffalump: true.
10:20:45 <musasabi> btw what are the plans with regards with the freenode ##channel thing and #haskell?
10:20:56 <Heffalump> ##channel?
10:21:06 <desrt> for purposes of informal gatherings
10:21:15 <desrt> freenode is getting more and more evil
10:21:19 * Heffalump no get it
10:21:43 <desrt> you're only supposed to have a channel name if it's an official name of a project or group or some such, i think
10:22:14 <Heffalump> well, we are, aren't we?
10:22:19 <Heffalump> the haskell project/group.
10:22:26 <Heffalump> shapr has it registered
10:22:57 <desrt> then it's no problem
10:23:18 <Heffalump> well, technically there isn't a sourceforge project or anything.
10:23:23 <Heffalump> Do you have a URL about this policy?
10:23:30 <desrt> it's on freenode.net somewhere
10:24:06 <musasabi> http://www.iso-9899.info/wiki/Channel_Ops_Discussion has the discussion from the #c folks.
10:24:51 <musasabi> of course it can be argued that #haskell is fine with haskell.org and all that.
10:25:20 <desrt> the freenode.net people seem to think that people give a damn about politics
10:25:25 <desrt> it's just irc.  people are here to chat
10:27:54 <Gahhh> so there's ##c++ now ? hm
10:28:05 <Heffalump> urgh, horrible.
10:28:26 <desrt> ya.  total BS
10:28:44 <Heffalump> it seems like to solidify our claim over #haskell, we'll need to somehow get the Haskell community to approve our (shapr's) control of the channel.
10:28:50 <desrt> i'm reasonably close to just not using freenode anymore
10:29:15 <Heffalump> (I can't quite remember who has admin privileges over the channel, shapr plus a bunch of others; I had some but resigned them over the Smerdyakov banning thing)
10:29:33 <Gahhh> ugh
10:29:53 <Gahhh> lol what happened to smerdyakov ?
10:30:04 <Heffalump> he got banned by shapr for being too aggressive and unfriendl
10:30:05 <Heffalump> y
10:30:17 <Heffalump> anyway, that's beside the point right now :-)
10:30:44 <Heffalump> the main point is that the channel as a whole is perfectly happy with the current admin and doesn't want to go through bureaucracy just to confirm it in place, right?
10:31:06 <Gahhh> I have no problem with anything
10:31:08 * desrt has no problems with the status quo
10:31:14 * lightstep never met this channel as a whole
10:31:24 <desrt> only lilotrouble :)
10:31:55 <Heffalump> I guess we could ignore it until someone tries to make us move.
10:32:09 <Gahhh> then we write monads !
10:32:49 <Heffalump> http://freenode.net/policy-draft.shtml#channelnaming
10:33:01 <lightstep> i don't get it. if they wanted to change the owner of #c, why did they have to move it to ##c? couldn't they just inform the server of the new owner?
10:33:18 <Heffalump> It's not entirely clear if Haskell actually fits any of the categories listed.
10:33:30 <Heffalump> Since it's not a software project per-se.
10:34:19 <Gahhh> unless it's a project about developing the next haskell
10:34:23 <Cale> Putting two #'s before things which aren't projects is stupid.
10:34:31 <desrt> that's like saying that gnome isn't a software project
10:34:43 <desrt> haskell produces ghc, hugs, etc just as much as gnome produces nautilus, panel, etc
10:34:53 <Cale> Haskell is a language
10:35:01 <Cale> Those are implementations of it
10:35:01 <desrt> gnome is an environment
10:35:08 <desrt> it has components
10:35:19 <Gahhh> they think #ghc and #hugs, but ##haskell.
10:35:21 <tromp> any1 here read fa.haskell newsgroup?
10:35:24 <Cale> But it's not like gnome is an abstract specification
10:35:34 <Heffalump> I guess we could ask fuckwit^Wlilo, but that risks drawing his attention to us.
10:35:49 <desrt> Heffalump; don't wake the sleeping lion :P
10:36:14 <Heffalump> if we really would be moved to ##haskell we should just move to OFTC.
10:36:15 <lightstep> he is actually on #c and ##c now
10:36:18 <desrt> you make a good point though... until someone goes and makes a fuss out of it, it's a non-issue
10:36:30 <desrt> s/oftc/efnet/
10:36:34 <desrt> s/efnet/somewhereelse/
10:36:38 <Heffalump> ugh, no, why efnet?
10:36:40 <musasabi> s/efnet/something-else/
10:36:47 <Heffalump> what's wrong with oftc?
10:36:54 <desrt> because its' yet another network to join
10:37:06 <desrt> there's nothing wrong with efnet these days
10:37:08 <Heffalump> well, I'm not on efnet :-p
10:37:18 <Heffalump> and we're not moving #haskell to OxIRC.
10:37:26 <desrt> i don't think it's moving at all
10:37:41 <Heffalump> I hope it isn't. Too much hassle.
10:38:13 <Heffalump> But if we really have to move to ##haskell I'd personally argue that we should rid ourselves of freenode completely.
10:38:25 <Igloo> OFTC #haskell would be far better than FN ##haskell
10:38:25 <Cale> heh give one of the Simons channel operator status, and have him delegate to shapr :)
10:38:59 <Heffalump> the Haskell 98 committee are arguably the people who have the rights over the channel name.
10:39:01 * Igloo would rather leave if asked than jump through hoops
10:39:06 <Heffalump> Since then we can claim to be a standardisation effort.
10:39:18 <Heffalump> But I'd be incredibly embarrassed to have to ask SPJ to validate our claim.
10:39:56 <Heffalump> I guess the key question is whether we should ignore this until actively faced with a problem or take pre-emptive action (e.g. asking lilo) now.
10:39:58 <Cale> heh, what about #math?
10:40:12 <desrt> #math is basically totally doomed
10:40:14 <Heffalump> is that being forced to move?
10:40:24 <Cale> I haven't heard anything about it
10:41:14 <Cale> But I think that would really be ridiculous, since who the heck do you ask? Wake up Gauss and Euler? :)
10:41:25 <desrt> the point is that #math can't exist as a channel
10:41:29 <desrt> because it's not a project
10:41:44 <desrt> so they have to call it ##math
10:41:51 <desrt> such great rules, hm?
10:41:52 <Heffalump> if you managed to wake them up I think there'd be rather more pressing questions
10:43:39 <Igloo> I'm sure you could find a quote from some such person that math belongs to everyone or something
10:44:13 <desrt> right.  but i doubt you can find a quote saying that math is licensed under the GPL and they approve of the current maintainership of the channel on freenode
10:44:24 <Cale> This turns channel naming into a philosophical debate
10:44:38 <Heffalump> I think having an explicit procedure _in case of conflict_ is a good idea.
10:44:47 <Heffalump> Attempting to impose it where not needed is just silly.
10:44:56 <desrt> there's a conflict here
10:44:59 <desrt> lilo is trying to own his world
10:45:13 <desrt> and there is an explicit procedure
10:45:18 <desrt> so he's invoking it all over the place
10:45:23 <Heffalump> yes, we all tell lilo to fuck off.
10:45:27 <Heffalump> that's a good procedure.
10:45:36 <desrt> calm language is also a good procedure
10:45:50 <Cale> Heh, if I want to kill a general channel like #math, I can create a GPL'd calculator called "math" and claim that I want general discussion of math moved to ##math. That's stupid.
10:45:52 <Heffalump> s/fuck off/please leave us alone/ :-p
10:46:05 <desrt> Cale; you should get on that :)
10:46:09 <Heffalump> it should be #maths anyway.
10:47:52 <Cale> Do I even have to write the calculator, or can I just open a sourceforge project and put up design documentation? At what point is it a project?
10:48:15 <tuomov> huh... this channel naming policy stuff is total bullshit
10:48:33 * Cale remembers when chanserv didn't exist
10:48:38 <desrt> ya
10:48:43 <desrt> chanserv is an awful idea
10:48:46 <musasabi> Cale: isn't that true in reverse too?
10:49:01 <desrt> it leads to people thinking that they somehow can own a channel
10:49:11 <musasabi> Cale: the #math folks could just create the calculator and #math would live on happily ever after.
10:49:39 <desrt> http://math.sourceforge.net/julia.gif
10:49:42 <desrt> crud.
10:49:42 <Cale> yes, but it's even stupid to enforce the creation of projects for general discussion channels
10:50:02 <tuomov> first come, first serve. It's simple, it works and it avoids legal bullshit
10:50:10 <desrt> tuomov; right.
10:50:39 <Heffalump> chanser is first come first serve
10:50:42 <tuomov> if you're unhappy with it, try taking over the channel or otherwise convincing the people currently inhabiting it
10:50:52 <Heffalump> it's just first registration, not first joining
10:51:03 <Heffalump> so you don't become reliant on keeping a client connected all the time to maintain ops etc
10:51:03 <Cale> "Advanced Mathematics Suite, or AMS for short..." -- talk about stepping on acronyms
10:51:25 <Heffalump> we could register a 'haskell' sourceforge project.
10:51:28 <musasabi> that is a joke I hope..
10:52:17 <musasabi> naming a math related thing ams is just too...
10:52:31 <Heffalump> :-)
10:55:00 <xerox> Can you suggest me an algorithm to find all the possible combination of two/n lists?
10:55:37 <Cale> xerox: perhaps you want sequence?
10:55:49 <xerox> I mean, given [0,1,2] and [0,2,4] return [(0,0),(0,2),(0,4),(1,0),(1,2),(1,4),(2,0),(2,1),(2,4)]
10:56:11 <Cale> put the lists in a list, and apply sequence to it, and you'll get a list of lists of 2 elements
10:56:32 <Cale> (which is the Cartesian product)
10:56:35 <xerox> Great.
10:57:36 <musasabi> [(x,y) | x <- list1, y <- list2] may be more readable
10:57:57 <xerox> It does work for more than 2 list, even better.
10:59:05 * ibid had that as an exam question in my late fp course
11:00:39 <TheHunter> there's also liftM2 (,), liftM3 (,,) etc.
11:01:21 <lightstep> or ap
11:01:28 <Heffalump> @seen shapr
11:01:28 <lambdabot> I saw shapr leaving #darcs 4 hours 21 minutes 21 seconds ago.
11:01:34 <xerox> A simple way to check that a list contains only different elements?
11:02:15 <TheHunter> xs == nub xs
11:02:22 <ibid> an additional question was "describe how one could make it work so that if s is an initial subsequence of t, then cp s is an initial subsequence of cp t"
11:02:28 <xerox> Great. Thanks again.
11:03:33 <lightstep> btw, #haskell fits to the definition of "Web Media", "Standards", and "Informal Education" on the policy page
11:04:13 <lightstep> and perhaps it should belong to the owners of haskell.org
11:05:32 <ibid> which policy page?
11:07:15 <lightstep> freenode.org/channel_guidelines.shtml
11:07:21 <lightstep> s/org/net
11:11:03 <tromp> would list1 >>= flip map list2 . (,) also work?
11:12:57 <lightstep> yes
11:13:15 <tromp> lifttM2 sure is more readable
11:15:21 <lightstep> partially because your code should be read in two directions
11:18:04 <tromp> is it possible to post newsnet articles from any website?
11:19:11 <Heffalump> gogole?
11:21:06 <tromp> can one do that from a gmail acct?
11:21:21 <Heffalump> no idea
11:24:21 <tromp> thanks
11:33:49 <wilx> @index stToIO
11:33:49 <lambdabot> Control.Monad.ST.Lazy,Control.Monad.ST,Control.Monad.ST.Strict,GHC.IOBase
11:34:18 <wilx> @type stToIO
11:34:19 <lambdabot> bzzt
11:34:29 <wilx> @type Control.Monad.stToIO
11:34:31 <lambdabot> bzzt
11:34:38 <wilx> @type Control.Monad.ST.stToIO
11:34:40 <lambdabot> Control.Monad.ST.stToIO :: forall a.
11:34:40 <lambdabot> 			   GHC.ST.ST GHC.Prim.RealWorld a -> IO a
11:40:21 <Oejet> Anyone using Haskell with Eclipse?
12:14:49 <Cale> Data.Graph sure has gotten larger :)
12:46:14 <sh10151> eclipse, pah
12:46:19 <sh10151> it needs an editor
12:46:21 <sh10151> badly
12:59:15 <nothingmuch> is anyone here familiar with pugs' insides?
13:00:17 <Heffalump> I'd hope autrijus is :-)
13:00:36 <nothingmuch> autrijus is sleeping right now
13:00:58 <nothingmuch> so i thought i'd try my luck here
13:02:52 <Heffalump> ah
13:03:06 <Oejet> Priviet, nothingmuch.  Are you also one of the million russian speaking people in Israel?
13:03:27 <nothingmuch> Oejet: nope, am not
13:03:35 <nothingmuch> hebrew + english
13:03:54 <nothingmuch> although given my workplace's demographics, I should be able to speak russian sometime in the future
13:04:18 <Oejet> Hebrew University in Jerusalem?
13:07:27 <nothingmuch> no, not yet at least
13:07:32 <nothingmuch> i've a few years till i get to that stage in life
13:08:17 <Oejet> I've talked to a student from there who was 17.  That makes you 12? :-P
13:08:35 <nothingmuch> no, it means that i'm 19, but that my plans are a bit different ;-)
13:10:03 <Oejet> Ah, and those two to three years of conscription takes some time too.
13:10:33 <lightstep> more like three to thirty
13:10:48 <nothingmuch> err, actually none
13:10:59 <xerox> Haskell does have closures?
13:11:00 <nothingmuch> for me
13:11:08 <lightstep> xerox: yes
13:11:13 <Philippa_> xerox: closures are an implementation detail
13:11:15 <xerox> Does it make sense, withput mutation?
13:11:19 <xerox> *without
13:11:22 <Heffalump> err, yes
13:11:23 <Oejet> nothingmuch: That would make you either conservative or Arabic, I think.
13:11:25 <Philippa_> but yes
13:11:31 <Heffalump> they wrap up lexical state
13:11:41 <Heffalump> or medically unfit, presumably
13:11:46 <lightstep> Oejet, half of the israelies skip the army
13:11:48 <nothingmuch> and conservative- i think you have the terms mixed up
13:11:53 <nothingmuch> arabic i'm not
13:11:58 <nothingmuch> it's mostly the orthodox who skip the army
13:12:03 <Philippa_> civil service-type thing as an alternative?
13:12:07 <Heffalump> same thing, innit? :-)
13:12:11 <Philippa_> (seems to be common in most countries with that kind of setup)
13:12:12 <xerox> Okay, thanks.
13:12:13 <nothingmuch> but i did it for ideological reasons, in a sort of err, pirate way
13:12:21 <nothingmuch> Philippa_: well, i tried
13:12:22 <SyntaxNinja> Oo
13:12:22 <Heffalump> 'pirate'?
13:12:24 <Oejet> nothingmuch: Doh, I was thinking about orthodox of course.
13:12:37 <nothingmuch> signed up for paramedics course twice, and twice it didn't open
13:12:44 <nothingmuch> maybe third time's a charm
13:12:49 <Philippa_> heh
13:13:08 <nothingmuch> Heffalump: well, you know, acting up, pointing out very 'serious' medical problems
13:13:18 <Heffalump> ah
13:13:20 <nothingmuch> bad history in school
13:13:27 <nothingmuch> couldn't really fit in
13:13:29 <nothingmuch> have no friends
13:13:35 <nothingmuch> will kill self given gun ;-)
13:13:42 <lightstep> i believe i know whow you are
13:13:59 <Oejet> how/who?
13:14:07 <lightstep> nothingmuch
13:14:15 <musasabi> Here the civil service is 13 months, while army is 6-12 months depending on the unit...
13:14:16 <lightstep> who, of course
13:14:31 <Oejet> lightstep: Ok.
13:14:39 <nothingmuch> lightstep: que?
13:15:32 <SyntaxNinja> cool, /usr/bin/runhaskell works :)
13:15:37 <lightstep> you know Shira Gertner?
13:15:42 <nothingmuch> uhuh
13:16:08 <nothingmuch> well, sort of
13:16:09 <Oejet> SyntaxNinja: Even /Programs/GHC/6.4/bin/runhaskell works.
13:16:12 <nothingmuch> out of touch for a while
13:16:49 <SyntaxNinja> Oejet: yeah, but I'm not going to slap that at the top with a #! :)
13:17:04 <SyntaxNinja> oh, is that macOS X?
13:17:11 <nothingmuch> how do you relate, lightstep?
13:17:28 <Oejet> SyntaxNinja: GoboLinux.
13:17:29 <lightstep> she popularized that thing with the public phones some time ago. i was with her in the movement
13:17:32 <SyntaxNinja> Igloo: so why didn't you put runhaskell in /usr/bin? just because we haven't figured out priorities yet?
13:17:56 <SyntaxNinja> Oejet: so the idea now is that we can put #!/usr/bin/runhaskell at the top of cabal scripts, and then you can just say ./Setup.lhs build, etc
13:18:45 <musasabi> now to get darcs only support exec permissions...
13:18:56 <Oejet> SyntaxNinja: /usr/bin/runhaskell also works for me. :-P
13:19:08 <nothingmuch> well, i think by then i lost touch with the political scene too
13:20:07 <SyntaxNinja> Oejet: whew
13:20:13 <Oejet> But hard coded paths are bad.
13:22:08 <SyntaxNinja> Oejet: I guess you can say #!/bin/env runhaskell or something?
13:22:38 <musasabi> SyntaxNinja: env might be in /usr/bin
13:22:46 <Heffalump> what is the point of env?
13:23:03 <musasabi> it searches the path for the executable.
13:23:05 <SyntaxNinja> that's where it is on my system
13:23:17 <SyntaxNinja> Heffalump: presumably, the location of env is more predicatable then the location of runhaskell
13:23:42 <SyntaxNinja> but I think with the #! syntax you only get one parameter, so you can't say "#!/usr/bin/env runhugs -98"
13:24:57 <Heffalump> yeah
13:25:10 <Heffalump> musasabi: but you have to know where env is.
13:25:27 <musasabi> Heffalump: true. egg & chicken.
13:25:40 <SyntaxNinja> is it not the case that env is more predictable?
13:25:49 <Heffalump> no idea
13:26:02 <Heffalump> but someone above was claiming it's in /bin and someone else /usr/bin
13:26:10 <SyntaxNinja> that was me, I was wrong
13:26:13 <Heffalump> ah, ok
13:26:18 <Heffalump> I've only ever seen it in /usr/bin myself
13:26:39 <Heffalump> and I guess then you have a chance to have runhaskell in /usr/local/bin
13:26:57 * Heffalump goes shopping
13:27:56 <musasabi> at least it is in /usr/bin on solaris and debian.
13:28:22 <SyntaxNinja> Heffalump: right
13:28:50 <Oejet> musasabi: Unvalid argument.
13:29:17 <musasabi> Oejet: env that is.
13:31:05 <Oejet> Have anyone thought about threading an IRC channel?  That is to have threads in the channel.
13:31:13 <Heffalump> I've thought about it
13:31:18 <Heffalump> although I'm shopping now, honest.
13:31:28 <Heffalump> but I have no good solutions
13:31:43 <Heffalump> certainly not backwardsly compatible ones
13:32:11 <Heffalump> and the UI issues are horrible too
13:32:15 * Heffalump really goes shopping
13:32:31 <Oejet> Heffalump: Do you have #haskell on your mobile phone or something?
13:32:43 * Lemmih tried to generalize an API for optional hardware acceleration with SDL in Haskell.
13:33:50 <integral> Oejet: for perl there is a module called Text::Conversation that heuristically threads IRC conversations
13:34:37 <Oejet> integral: Interesting.  Is it any good, you know?
13:35:07 <integral> Oejet: I've seen a few of the results and they're fairly good.   It's not something to rely on, it's very easy for a long thread to break
13:39:16 <Oejet> I can imagine.
13:40:49 <SyntaxNinja> Lemmih: there's a Cairo binding for haskell, fwiw
13:42:07 * Lemmih googles.
13:45:08 <Lemmih> Ah yes. Had a look at some time ago. Didn't really get the impression that it would be used for game development.
13:48:09 <Lemmih> s/would/could/
13:58:52 <Cale> Oh, neat, you can write the kind-signature instead of the parameters on a GADT.
13:59:33 <xerox> Cale, can you point me to an explanation of the H-M t-shirt ? :D
14:00:00 <Heffalump> oejet: no. I'm not that sad ;-)
14:00:11 <Oejet> Heffalump: Heh.
14:01:17 <Cale> xerox: hmm... I wonder if there's a good reference for that on the web
14:09:42 <SyntaxNinja> man... haskell-mode really needs someone to love it
14:09:51 <SyntaxNinja> isn't there anyone out there who loves Haskell and Elisp both?
14:11:59 <SyntaxNinja> my shell connection to www.haskell.org is being really slow
14:12:08 <lightstep> why would anyone love elisp?
14:13:16 <desrt> i met this guy once who seemed totally normal but he actually had a nail embedded in his skull for the past 12 years
14:14:12 <SyntaxNinja> desrt: is that an answer to lightstep's question?
14:14:19 <desrt> SyntaxNinja; yes :)
14:16:11 <SyntaxNinja> hehe
14:16:25 <SyntaxNinja> I guess once you know Haskell, it's hard to love elis
14:16:26 <SyntaxNinja> p
14:16:42 <desrt> i've never actually met anyone that had a nail in their skull
14:19:57 <Igloo> SyntaxNinja: Because I remembered it half way through it building
14:20:07 * Igloo reAFKs
14:20:47 <SyntaxNinja> Igloo: thanks
14:21:05 <SyntaxNinja> we need to put a nail in someone's skull so they'll love haskell-mode
14:22:25 <SyntaxNinja> there's a street trumpet player that I can hear from my apt.
14:22:31 <SyntaxNinja> he knows a lot of songs, but he's not very musical
14:23:13 <SyntaxNinja> he also wears a white suit and a mickey-mouse hat
14:33:04 <xerox> 'night folks
14:54:12 <wilx> *sigh*
14:54:43 <wilx> I wish there were Haskell debugging tools for GHC on Windows.
14:57:00 <SyntaxNinja> I wish there were haskell debugging tools
14:57:56 <wilx> Heh, I thought there were some for Unix world.
14:58:01 <wilx> Buddha?
14:58:55 <sh10151> i wish there were haskell debugging
14:59:16 <SyntaxNinja> and hat, but none of them work with most extensions and new libraries
14:59:40 <wilx> I see.
15:01:51 <SyntaxNinja> OTOH, the testing libraries, HUnit and quickcheck are really pretty good, so my solution is to write lots of test cases and catch the bugs as soon as possible
15:02:00 <SyntaxNinja> before things get so complex that I need a debugger
15:02:16 <wilx> Hmm...
15:02:56 <wilx> The problem is that I have one function and test for that function that fails :)
15:03:32 <wilx> I can hardly make it more fine-grained.
15:04:37 <SyntaxNinja> sure you could, break up the function into smaller functions and unit test those :)
15:05:26 <wilx> I suspect some STRef issues though. The whole monads' world is still blurry at best for me.
15:09:30 <SyntaxNinja> woo I'm outside now
15:12:32 <wilx> >_<
15:12:52 <wilx> At least if it was possible to add some debugging printf() like in C :/
15:13:23 <TheHunter> @type Debug.Trace.trace
15:13:24 <lambdabot> Debug.Trace.trace :: forall a. String -> a -> a
15:13:50 <wilx> Hm...
15:15:03 <SyntaxNinja> wilx: but you have to understand a bit about what's going on to use Debug.Trace... because it uses unsafeperformIO, it may not do exactly what you expect
15:15:07 <SyntaxNinja> because of laziness and such
15:15:28 <wilx> Ah.
15:16:06 <SyntaxNinja> but it's definitely very useful
15:16:41 <TheHunter> @type Control.Monad.ST.unsafeIOToST
15:16:42 <lambdabot> Control.Monad.ST.unsafeIOToST :: forall a s. IO a -> GHC.ST.ST s a
15:16:56 <TheHunter> might also be helpful in connection with a print statement.
15:17:24 <wilx> Wheee, trying...
15:19:41 <TheHunter> you could define traceST = unsafeIOToST . putStrLn
15:22:06 <wilx> Yay!
15:22:10 <wilx> That works fine.
15:43:14 <wilx> Ah!
15:43:16 <wilx> Found the bug.
15:43:31 * SyntaxNinja high-fives wilx
15:43:36 <wilx> :)
15:45:48 <bourbaki> is there some link on haskell for physicists?
15:46:37 <SyntaxNinja> bourbaki: you should make one on the wiki :)
15:46:43 * Igloo realises I should probably try to get ghc6-hopengl renamed to libghc6-hopengl-dev before sarge releases
15:46:46 <SyntaxNinja> there were a lot of neat quantum computing talks at icfp '03
15:47:24 <bourbaki> i try to get some of the phisisits interested in haskell cause i think its interesting cause they can do something like strong unit preservation with the strong typeing
15:49:55 * Oejet tries to get his informatics student friends to learn Haskell.  What resistance he meets.
16:03:47 <Khisanth> SyntaxNinja: which version of haskell-mode were you refering to?
16:11:52 <SyntaxNinja> Khisanth: when I was talking about loving elisp? no particular version
16:13:17 <Khisanth> what do you think it is lacking?
16:14:15 <SyntaxNinja> Khisanth: well, 2.0 is a big improvement, (there are still some bugs) but when I look at something like JDE mode, I just feel really jealous.
16:14:50 <Khisanth> heh I have never used the JDE mode for anything more than highlighting
16:15:28 <SyntaxNinja> It's tightly integrated with javadoc, it's integrated with speedbar...
16:16:09 <sh10151> i hacked something for haskell-mode
16:16:50 <Khisanth> do you mean generating or reading javadoc?
16:16:58 <SyntaxNinja> Khisanth: generating
16:17:00 <sh10151> trying to see where i put it
16:17:17 <Khisanth> hmm yes that was sorta nice
16:18:15 <SyntaxNinja> jde has "electric" features, forward and back conditionals
16:18:52 <SyntaxNinja> I think that jde and haskell-mode are implemented in really different ways, though; I'm not sure. I think that haskell-mode's highlighting is implemented w/ regular expressions...
16:19:08 <SyntaxNinja> but it's possible to craft a mode with more knowledge of the language
16:19:21 <lisppaste2> sh10151 pasted "ghci type hack " at http://paste.lisp.org/display/6546
16:19:37 <sh10151> hmm
16:20:00 <sh10151> i think a mode with more knowledge of the interpreter is also useful
16:20:05 <sh10151> see slime for cl :)
16:20:19 <SyntaxNinja> yeah
16:22:43 <sh10151> JDEE manages most of what it does by offloading the work to Java
16:22:51 <sh10151> BeanShell to be precise
16:23:03 <SyntaxNinja> interesting
16:23:30 <icb1> has anyone here tried compiling 6.4 on a mac?
16:23:34 <sh10151> at least for things like the syntax analysis and autocompletion
16:23:56 <sh10151> it also uses the cedet tools whereas haskell-mode does not
16:23:58 <icb1> it has been going for 18 hours
16:24:11 <icb1> and it stuck on ==fptools== make all -r;
16:24:12 <icb1>  in /Volumes/itc/z/ghc-6.4/ghc/compiler
16:25:20 <Igloo> icb1: Do you mean that's the last line it's shown for a long time?
16:26:09 <icb1> yah
16:26:26 <icb1> is that normal?
16:26:41 <Igloo> No
16:26:50 <Igloo> Try stracing it? (or truss, or whatever)
16:27:28 <Igloo> (well, not normal for Linux at least. I don't see why it should be for a mac)
16:28:10 <icb1> maybe there is a verbose option so i can expand what it is doing
16:28:16 <wilx> Gagh!
16:28:19 <dons> icb1:; you can't use one of wolfgang's binary snapshots of 6.4 from earlier in the week?
16:28:31 <wilx> More than 9 hours of Hashell coding.
16:28:36 <wilx> My brain is dying.
16:28:45 <icb1> i am using the 6.2.2 distro
16:28:53 <dons> and 18 hours is definitely too long btw, my 33Mhz 68k takes about that long..
16:29:03 <icb1> it is a 1.2GHz G4
16:29:29 <icb1> care to take a look at my build.mk?
16:29:49 <Igloo> dons: For a 2 stage build?
16:30:01 <dons> Igloo: nah, just to get to stage1.
16:30:10 <dons> and it actually more like 30 hours ;)
16:30:20 <Igloo> OK, phew  :-)
16:30:29 <icb1> http://10k.org/jake/build.mk
16:31:12 <dons> that's all fine.
16:31:21 <icb1> http://10k.org/jake/ghc.cmd
16:31:26 <icb1> is my config flag
16:31:49 <dons> what does the -hopengl thingy do? build the hopengl lib?
16:32:02 <icb1> it builds the opengl bindings
16:32:32 <icb1> hmmm
16:32:38 <icb1> i see it is no longer in the configure --help
16:32:52 <dons> but you're stuck in compiler/ aren't you?
16:32:52 <icb1> let me try disabling that
16:32:56 <icb1> right
16:33:02 <icb1> i am stuck at compiler/
16:33:07 <Igloo> I believe it's done by default now anyway
16:33:14 <icb1> okay, iglo
16:34:10 <icb1> all my ulimits are set to max
16:34:40 <dons> what's in top -- any deadlocked haskell processes?
16:34:52 <dons> (they have top on the mac, don't they ;)
16:35:44 <icb1> no dead haskell processes
16:35:52 <icb1> while it was stuck
16:36:18 <icb1> the gnumake command was consuming about 17-40% cpu continuously for the past 10 hours
16:36:36 <icb1> i am using gmake 3.79
16:36:39 <dons> were you using -jN ?
16:37:24 <icb1> for make?
16:37:33 * Igloo wonders what distrib/configure-bin.ac is
16:37:46 <icb1> something is really wrong, i am out of processes
16:37:51 <icb1> let me reboot, brb
16:38:02 <dons> ah!
16:38:28 <dons> igloo: it's the configure used in binary distributions
16:39:32 <Igloo> Ah, ta
16:55:47 <icb> back
16:56:14 <icb> i guess after 18 hours, something has gotten exhausted
16:58:10 <icb> should i do distclean or start where i left off?
16:59:54 <dons> hmm. you could probably just start off
16:59:58 <dons> where you left
17:00:05 <icb> alright let me try that
17:00:34 <dons> note that building on a machine such as your should take maybe 2hrs
17:00:43 <dons> and probably less.
17:00:58 <icb> yah, that make more sense
17:01:21 <icb> btw, is libgmp now in the distro or is it still separate?
17:02:27 <dons> it's in the distro, and has been for ages, but you may get better results using your own system's libgmp
17:02:31 <Igloo> It's probably better to use a separate recent libgmp
17:02:54 <icb> i mean in the past because of licensing, one have to distribute it separately
17:03:42 <dons> I don't know about that. You can distribute GPL code however you want.
17:03:58 <icb> i suppose that hasn't changed then
17:04:21 <icb> it was strange before because one had to tag along a framework along with their executable
17:18:22 <icb> alright gnumake is now taking 70% of the cpu, and it is on compilers, i will wait 2 hours and see what happens
17:21:03 <dons> are you getting lots of ghc output?
17:21:56 <icb> nope, zilch
17:22:08 <icb> it is just sitting silently at the compiler line
17:22:34 <dons> that's noot good. i wouldn'tt wait 2 hrs... more like 30 secs.
17:22:48 <icb> 5+ minutes has gone by
17:22:52 <icb> let me kill it
17:23:07 <dons> maybe you can try upgrading to gnu make 3.80?
17:23:17 <icb> okay, let me do that
17:24:55 <icb> that 3.79 was the default apple-devkit make
17:45:16 <maihem> I'm trying to define a data type that describes an expression for a language. As part of that I need something like a dictionary that the definition of the expression can refer to (for the scope).
17:45:24 <maihem> But I don't want to use something like Data.Hashtable. I really would like something like the state in the ST monad (but immutable - addRef only)
17:45:53 <dons> for heaps I would used a Data.Map first
17:46:19 <maihem> So the expression can *only* refer to things in the scope, and only things in that expression can refer to that scope.
17:47:16 <maihem> I want to avoid handling Maybes. So If I've created the expression successfully, using it is easy, with no chance for dropping out with failures
17:48:06 <maihem> Sort of like getting the ref out of the runST, but only being able to use it on the state as it was (or a state produced by transforming that state)
17:48:19 <dons> here's a environment type I have used in a compiler in a course I teach: http://www.cse.unsw.edu.au/~dons/Env.hs
17:48:23 <maihem> with typing guaranteeing that. Is it possible?
17:48:29 <maihem> oh cool, thanks :)
17:48:36 <dons> the same env gets reused for the typechecker, type inference and in the interpreter
17:48:50 <dons> just with different parameter types.
17:49:33 <stepcut> I think my compiler generates unique labels now :p
17:49:49 <dons> :) how will you ever know? ;)
17:50:13 * stepcut whips up a proof-checker
17:50:29 <dons> just encode the proof in the type..
17:50:35 <stepcut> heh
17:50:55 <stepcut> I'll do that in version 2.0
17:51:55 <dons> maihem: regarding always having valid bindings in the environment -- this can certainly be statically checked.
17:52:07 <dons> so an unknown binding at runtime is an `impossible' case
17:53:01 <dons> eval g (Var x) = case getEnv g x of
17:53:01 <dons>         Nothing        -> panic "undefined variable" -- bug if this happens
17:53:01 <dons>         Just BlackHole -> error "<<loop>>"           -- blackhole
17:53:01 <dons>         Just v         -> v
17:54:29 <dons> maihem: lots of good stuff on writing little languages like this in these books: http://www.cse.unsw.edu.au/~cs3161/References.html
17:54:42 <maihem> thanks dons
17:57:40 <dons> anyone know what those little hemispheres you can stick on the bottom of a laptop to raise one edge are called?
17:58:28 <maihem> feet? spacers? grommits?
17:58:45 <maihem> grommits is cool, if they're not called grommits then they should be
17:59:07 <dons> hehe
17:59:40 <dons> grommits is to thingys, as 'x' and 'y' are to haskell variables
18:00:05 <dons> or f, f' and g for that matter
18:00:56 <maihem> actually if you are typing a plastic/tapaulin sheet by its corners (eg to make a roof), you but something in the corner, wrap it up and tie around it. That is *actually* called a grommit :)
18:01:07 <maihem> s/typing/tying
18:01:18 <maihem> s/but/put
18:01:34 <dons> really? huh. so a grommit is not a sprocket?
18:01:49 <maihem> no :)
18:01:55 <dons> I thought a grommit was a rubber washer used in a pump. hmm.
18:02:33 <dons> ah. there is such a thing as a rubber grommit for cables. hmm
18:02:37 <maihem> maybe it refers to two things then
18:04:05 <SyntaxNinja> CosmicRay: checked the sequence queue lately?
18:05:11 <maihem> ooh, "sprocket" is the name of the dog in "Fraggle Rock", and "Grommit" is the name of the dog in the "Wallace and Grommit" animations. I wonder if there's a link
18:06:01 <icb> alright that looks better, it is making progress with gmake 3.80
18:13:46 <maihem> is it possible to define a type in the "where" of a function so the result type of the function application depends on the values the function is applied to (and not just the types of them)?
18:14:29 <Cale> maihem: not in Haskell
18:15:07 <maihem> That sounds like there may be a language in which I *can* do this.
18:15:43 <Cale> maihem: look for dependent types
18:15:48 <dons> so you want the type of the function to vary with the value of the functions argument?
18:15:55 <Cale> or dependently typed lanuages
18:15:59 <maihem> thanks Cale
18:16:49 <maihem> dons: yes, then the type of the reference I get when adding a new thing to the scope is unique to a scope identical up to that point in its construction
18:17:29 <_mordechai> hm sorry
18:19:00 <dons> I think there may be standard compiler techniques for solving this problem without resorting to dependent types
18:21:33 <dons> though I'm not sure what you mean by a value with a unique type (constructed at runtime?)
18:21:55 <dons> do you just want to tag values with a unique key?
18:24:27 <maihem> I want to create a data type that as one part of it has a scope in which values are looked up via references (I want to resolve names early like haskell does). But I want to be able to *not* use Maybe. the references that the definition of the expression uses should be guaranteed to have been put in the scope object - or my language compiler doesn't compile.
18:25:55 <maihem> by creating the type of the new scope as the new larger scope is created (by adding a new thing to a smaller one), the reference that is also returned in a pair with the new scope can only be used to refer to that scope
18:26:33 <maihem> err, I'm tired and that didn't turn out like a proper sentence :)
18:27:26 <dons> isn't this just: f old_scope = ... do something ... let new_scope = old_scope + binding in f new_scope?
18:27:27 <SamB> that sounds like fairly complicated things to be doing when tired
18:28:07 <dons> i.e. you're just making sure only the new set of bindings is visible when they're supposed to be visible?
18:28:08 <maihem> addRef scope newobj = (blah to make new scope, reference to blah in the new scope) where the type of the new scope and new reference is dependent on the value of the old scope and the value of the new object
18:28:48 <maihem> I really want to be able to return the new scope, otherwise I'd just use the ST monad
18:29:48 <maihem> Although the ST monad leaves me the possibility of abusing the extra capabilities of immutability to cause bugs later on
18:30:03 <maihem> s/Although/and
18:30:44 <dons> why does the type of new_scope have to be dependent .. do you specifically want to reflect something of how new_scope was constructed on the type level?
18:31:51 <maihem> yes. A reference returned from a function adding a new objedct to a scope should be possible to use on an identical scope to the one returned along with the reference or one constructed by adding things to an identical scope
18:32:36 <maihem> no chance for using a key (reference) not present, or using the key on a scope with a different value mapped from that key
18:33:33 <maihem> So I can never get suprising failures by assuming I always used the references correctly.
18:34:00 <dons> ah, so (ref of scope1) == (ref of scope2:ref) == (ref of scope1:anything)
18:34:11 <maihem> ?
18:34:56 <dons> you just stated some rules about the semantics of your references, yeah?
18:35:02 <maihem> yeah
18:35:31 <maihem> These dependent types look to be the one true way
18:36:24 <dons> yeah, if you donn't want to detect this at runtime (via Maybe) then you've got to encode it in the type somehow.
18:37:09 <dons> you encode a proof in the type of the environment/scope that your reference is defined, I reckon
18:37:30 <maihem> I would encode it at runtime using Maybe if it was possible for a user to give bad data. but since I'm resolving names early, the data must be made good early, so there is no room for Maybe later on.
18:37:47 <maihem> yeah
18:37:55 <dons> by 'early' you mean statically at compile time?
18:39:07 <maihem> no, I read a user's program. so I have to do things with Maybe until I have successfully resolved the names. Then I must have made everything correct, so the rest of my program should use dependent types since the rules for the references must be fulfilled.
18:40:10 <dons> 'you read' == the interpreter at runtime reads some random user code?
18:40:19 <maihem> yeah
18:41:00 <maihem> so I use Maybe there, until I've checked everything. Then I want to now I have no misuse of Maybe after that point. So I think I need the dependent types.
18:42:43 <dons> could you use a newtype SafeScope = Safe Scope, export this abstractly, and provide a single 'smart' constructor for constructing a SafeScope? that way you tie the construction of safe scopes to a single function that takes you from unsafe world to a Maybe-free world -- and then forever after can use the SafeScope type, knowing it has the property you want?
18:43:51 <dons> so you use Maybe types for the unsafe part, then checkSafety :: Maybe Scope -> SafeScope, (or whatever), and then the rest of the interpreter deals only in the SafeScope type.
18:43:53 <maihem> but I need a collection of reference types for each safe scope created, but they are only created at runtime depending on the users code after chacking that code.
18:44:44 <dons> oh, and the reference types are object language types (not Haskell types)?
18:45:42 <maihem> Well, since Cale said Haskell doesn't have dependent types, they will not be Haskell types. I will have to explain what I need to do another time. I am too tired
18:45:48 <dons> I think I've been mislead by talk of creating types dynamically, when you meant creating (object language) types in the interpreter dynamically
18:46:14 <maihem> They should be Haskell types created in response to checked user data
18:46:22 <dons> it's just that dependent types are a pretty big hammer to hit your nut with -- so I'd want to be sure that's what I need.
18:47:43 <Lemmih> If you've already validated the reference, why do the lookup again?
18:47:56 <maihem> so I can do lookup :: forall Scope a. Scope a -> ref a -> b
18:48:34 <dons> where ref is a new type representing the object language type?
18:48:47 <dons> no, sorry, 'a' would be the object language type
18:49:14 <maihem> no a would be a type unique to that scope (at that point in its construction).
18:49:44 <maihem> note I used "forall Scope a. blah" instead of "forall a."    I think that explains what I'm looking for
18:50:00 <dons> yeah, true.
18:51:12 <maihem> That means I really do have to get a dependently typed language doesn't it?
18:51:42 <dons> I'm not convinced you have to go that far. For one, you seem to also want runtime types.
18:52:00 <dons> So maybe you can get by with the Dynamic type
18:52:24 <maihem> perhaps. I will look at it.
18:52:46 <dons> and secondly, it doesn't seem like you're doing anything to unusual in your interpreter, that wouldn't already be similarly done in a non-dependently typed interpreter
18:52:49 * Lemmih still don't get why doing more than one lookup would be desirable.
18:53:19 <dons> your trying to prove a safety property relating to references
18:53:40 <dons> and there are plenty of languages with referrences around, none of which require dependent types to be implemented
18:54:40 <maihem> Lemmih, forst I want to get a user provided bit of code. check it, fill in a scope object and a dictionary object mapping names to references into the scope. After that point I want to use the references (guaranteed correct now) during compilation.
18:55:47 <maihem> so I can lookup the names early to see exactly what they refer to early, and use the references during later transformations
18:57:08 <maihem> I want to guarantee the structures relating to the references are correct at creation time, and avoid Maybe when looking up the references since it could be a source of errors that might not get tested.
18:57:37 <maihem> s/looking up the references/looking up the values via the references/
18:58:04 <dons> won't type checking spot undefined variables prior to actually executing the code though?
18:59:04 <dons> that's how the small fuctional interpreter I showed examples from earlier could avoid any Maybe type in the heap
18:59:11 <dons> and similarly with Haskell
19:00:00 <dons> or you can't do this for some reason until you actually evaluate your syn tree in the interpreter?
19:00:44 <maihem> but you've got a Maybe in the return from the lookup. I want to be able to see what the reference refers to without any chances later on. So I want to remove the maybe so my code wont compile if it has any of these chances for me to screw up
19:01:22 <dons> oh, that Maybe isn't for any semantic reason -- no program can ever produce a Nothing, it is only the result of a compiler bug
19:02:07 <dons> it's just a convenience while developing the interpreter
19:02:33 <dons> hence I said it was an 'impossible' case.
19:03:07 <dons> The static semantics of the language already rules out any undefined variables at runtime
19:03:08 <maihem> I want to make Haskell say to me "No I wont compile this code because you are using a key (reference) into the wrong scope". So if Nothing isn't supposed to happen, then I want ot write code that doesn't use a Maybe
19:05:07 <maihem> I also want to ensure I don't look up in the wrong scope since there could be a value of the correct type, but with a different value - but if the types of the two scopes are different, then I can't do that.
19:05:31 <maihem> s/can't do that/can't make that mistake without the compiler puking on my new shoes/
19:07:49 <dons> or you can do the usual thing with scopes/heaps/environments, and just map them to haskell's scoping rules (i.e. bind a new scope to the augmented old scope, and then pass that new scope recursively to the eval function - so you automatically get all your scoping rules respected, as you treat scopes as normal values).
19:08:13 <dons> this will all be much harder if you want to encode it in the type, though would be interesting if you can do it
19:09:20 <maihem> Well, I don't think I can without dependent typing. Although the eval idea is an interesting one I hadn't thought of - I wonder if I can be as safe with that.
19:09:46 <Lemmih> What about parsing the refered object around instead of the reference? Or perhaps both as a tuple if the reference contains useful information.
19:09:51 <zebedee> boing
19:10:20 <Lemmih> s/refered/referred/
19:10:52 <zebedee> because the refered object is a value and equality can be undecideable. so I lose a lot of optimisation possibilities
19:11:06 <dons> maihem: the way I described with eval is the standard technique. I teach 3rd year students to write functional language interpreters in 5 weeks this way.
19:11:45 <dons> that's what 'union' in the Env.hs module is for, it returns a new scope representing the old scope augmented with a new binding
19:12:39 <dons> to eval a Let: eval g (Let b In e) = let g' = newscope g b in eval g' e
19:13:22 <zebedee> does that make it impossible for me to use the same key in both scopes?
19:13:34 <dons> hence the scoping rules are preserved by the scoping rules of bindings in Haskell (g' is only visible in the body of e).
19:13:50 <zebedee> Lemmih, ooh, I missed the tuple idea.
19:13:57 <dons> zebedee: if a something is bound in the outer scope, is it still bound in the inner scope.
19:14:00 <zebedee> that would let me do the optimisation
19:14:40 <zebedee> sorry, I mean does that let me use the same key on a completely different scope or does that mistake refuse to compile
19:15:07 <dons> well, let x = 1 in let x = 2 = x works, right?
19:15:22 <dons> sorry, let x = 1 in let x = 2  in x
19:17:27 <zebedee> if I have a scope where x is 1 and a scope where x is 2, can I use the same key as I use to get '1' from the first scope to get '2' from the second scope, or does haskell refuse to compile my interpreter/compiler
19:18:17 <dons> you would normally uniquely identify variable names
19:18:46 <dons> though it isn't necessary, as the language wouldn't allow scope 1 to be visible in scope 2 -- to do so would be a broken interpreter, right?
19:19:46 <zebedee> um, I'm going to have to go to bed, because I'm completely lost. I don't really understand how your solution works.
19:20:10 <dons> haskell won't refuse to compile an interpreter that passes scopes around incorrectly, unless you've somehow mapped your object-language scoping rules to the haskell type system, right? which seems very difficult.
19:20:48 <zebedee> ahah! yes!
19:20:54 <dons> in my solution you could certainly confuse the scope, but it would be a pretty obvious bug. let g' = newscope g b in eval g e,  for example
19:21:26 <dons> where we accidentally pass the old scope in to the eval of the body of the let, losing any new bindings
19:22:15 <zebedee> I'm just looking for "these are different scopes, so that reference can only be used on one of them. bork"
19:22:21 <dons> to solely use the Haskell type system to prevent this seems very hard -- you really need the type of the scope to encode all the current bindings
19:22:29 <zebedee> I'm really going now ;)
19:22:45 <dons> ok. but just distinguishing scopes seems easy enough -- unique keys
19:23:03 <dons> anyway - looks like you've got a nice problem to dream/have nightmares about :}
19:37:49 <Igloo> dons: You have /usr/bin/ghc and /usr/bin/ghc-6.4 right?
19:38:36 <Igloo> And assuming so, is either a symlink to the other?
19:40:26 <dons> /usr/local/bin/ghc -> /usr/local/bin/ghc-6.4
19:40:34 <Igloo> Hmm, thanks
19:48:28 <dons> btw, only the base BSD system goes into /usr/s?bin. External packages aren't trusted to mess with /usr/bin or /etc, usuallyC
19:51:15 <Igloo> *nod*. Do the BSDs aim to become FHS compliant (or do they believe that is), OOI?
19:52:21 <dons> hmm.. isn't the FHS a linux standard?
19:52:39 <Igloo> I thought it was trying to be more, but maybe I'm confused
19:53:15 <dons> maybe it is - but there is a certainly a "BSD way" that you should never break, which probably maps closely to FHS
19:53:15 <Igloo> It says "under UNIX-like operating systems"
19:56:20 <dons>  /boot is a linuxism, so is /etc/opt, /lib, /opt. /var looks BSD though.
19:57:17 <dons> looks like there are a few references to BSD in the doc, but it isn't taken up in the BSD community, I'm pretty sure.
19:57:35 <Igloo> Fair enough
20:03:01 <sh10151> dd
20:05:30 <dons> dd if=irc of=/dev/null
20:34:30 <icb1> compiling compiling ....
22:16:00 <Cale> icb1: what are you compiling?
22:40:36 <yonkeltron> i think i might be in love with the haskell type system
22:43:48 <cm> hello
22:59:49 <icb1> still compiling ...
23:00:05 <icb1> compiling GHC64
23:01:26 <cm> GHC 6.4 fails loading the Win32 package :-(
23:01:42 <cm> (GHCi, actually)
23:06:46 <musasabi> morning
23:09:30 <icb1> morning guys
23:10:22 <cm> do you have any ideas: <spam>
23:10:22 <cm> Prelude> System.Win32.DLL.loadLibrary "user32"
23:10:22 <cm> Loading package Win32-1.0 ... <interactive>: Not x86 PEi386
23:10:22 <cm> ghc.exe: panic! (the `impossible' happened, GHC version 6.4):
23:10:22 <cm>         loadObj: failed
23:33:09 <yonkeltron> cm: that last bit about the impossible looks like it might be a ghc bug
23:33:21 <yonkeltron> cm: then again....windows and all....
23:34:25 <cm> this is a vanilla ghc 6.4 installation (without any ghc 6.2 reminiscents), and it happened on another computer as well, so i'm inclined to think so as well :(
23:34:53 <yonkeltron> cm: another computer with the same ghc version? same error message?
23:35:01 <cm> yes
23:35:15 <cm> vanilla 6.4, windows, same error
23:35:16 <yonkeltron> cm: file a bug report. http://www.haskell.org/ghc
23:36:24 <yonkeltron> just so everyone knows....i see such little purpose for literate haskell outside the areas of education and such
23:36:59 <cm> my brain doesn't work the literate programming way
23:37:50 <yonkeltron> cm: exactly. there should be more code in a file than comments
23:39:08 <cm> i really like having a quick description of what's going on every couple of lines.. but not huge chunks of comments. doesn't support my thinking, it rather interrupts the process :|
23:40:04 <yonkeltron> cm: i concur. i think that haskell is smart to not require line endings....line beginnings don't help the case
23:40:28 <cm> :-)
23:41:02 <yonkeltron> cm: apropos, is there something like doxygen that works with haskell?
23:41:19 <cm> there is haddock
23:41:51 <cm> http://www.haskell.org/haddock/
23:42:13 <cm> I believe it is used to create the GHC documentation, as well. A very nice tool.
23:42:52 <yonkeltron> cm: OH MY!
23:43:09 <yonkeltron> cm: not quite as nice as pydoc but it's slicj
23:43:14 <yonkeltron> *slick
23:43:15 <cm> :)
23:43:43 <cm> it doesn't parse some GHC language extensions, which is a bit sad :| but it's cute anyway :-)
23:45:16 <yonkeltron> cm; yeah......cute. good word for it. have u seen pydoc work?
23:45:46 <wilx> cm, I get the same error here too.
23:46:20 <cm> wilx: I just filed a bug report. Hope it will resolved soon.. I was deeply impressed by the new features in 6.4, btw :-)
23:46:27 <cm> wilx: they just keep adding new cool stuff
23:46:30 <cm> yonkeltron: I'm not sure
23:46:33 <cm> yonkeltron: let me check
23:46:35 <wilx> :)
23:46:43 <wilx> Yeah, too much cool stuff for me :)
23:47:00 <cm> yonkeltron: I'm using the python library reference now and then.. is it created using pydoc?
23:47:07 <wilx> I am still fighting basic monads, so no more advanced stuff for me :)
23:47:12 <cm> :-)
23:49:37 <lightstep> what does (<> a . b) mean?
23:49:54 <lightstep> (<> a) . b     or     (<> (a . b)) ?
23:50:10 <cm> i would guess the former
23:50:15 <cm> ..but
23:50:25 <yonkeltron> cm: not that stuff...but http://www.pydoc.org is better in my opinion
23:51:07 <cm> oh I understand what you're saying now
23:51:40 <cm> i really like the php.net/<keyword> idea
23:54:12 <cm> and the CHMs :-)
23:57:33 <yonkeltron> cm: CHMs?
23:57:38 <dons> what extensions doesn't haddock parse, i wonder?
23:57:50 <cm> GH
23:58:03 <cm> (modulo errors on my side, ofc)
23:58:20 <cm> yonkeltron: windows help format kinda thing
23:58:44 <dons> these extensions must not used anywhere in the haskell libraries -- hmm -- implicit variables would be one.
23:59:26 <yonkeltron> cm: ew.
23:59:36 <cm> dons: GH was what I am using
23:59:41 <cm> yonkeltron: wee!
23:59:49 <dons> cm: GH?
