00:00:11 <nothingmuch> where is it defined?
00:03:39 <musasabi> nothingmuch: the nomaware tutorial teaches about that when you are further.
00:03:39 <musasabi> -c
00:03:49 <nothingmuch> ah, ok
00:03:56 * nothingmuch keeps getting impatient with this haskell stuff
00:04:05 <nothingmuch> I should learn to control myself ;-)
00:05:57 <rtega> or try another language
00:06:05 <rtega> ;)
00:06:21 <nothingmuch> why should I want to do that?
00:07:37 <nothingmuch> well, anyway, real work beckons
00:13:20 <sylvan> nothingmuch: maybe you should hold off on monads other than IO for a while...
00:13:44 <sylvan> I'm not sure how much of a newbie you are, but you'll probably grasp it better after you're comfortable with "regular" haskell first...
00:13:57 <nothingmuch> sylvan: i'm sort of ok with it
00:14:03 <nothingmuch> the typing is working for me
00:14:17 <nothingmuch> passing things around makes sense now
00:14:25 <nothingmuch> composing things too
00:14:28 <sylvan> okay... well State just transfers an invisible state type along with State computations...
00:14:36 <Janni> Sorry, I have been away from keyboard. Have there been any answers on my -fno-prune-decls problem?
00:14:57 <sylvan> within which you can access it using some defined State computations which returns the internal state and also modifies it
00:15:24 <sylvan> then there's a run function which passes the starting state to a state computation (which is defined using other state computations) and returns the final state and some value.
00:15:28 <sylvan> And that's about it
00:15:51 <nothingmuch> i think i get it
00:16:00 <nothingmuch> anyway, as musasabi said, i'll get to it later ;-)
00:16:16 <sylvan> IO is basically a State monad which transfers the "World", but without a run function (so you can't turn an IO computation to a regular function value)
00:20:18 <musasabi> Janni: no..
00:35:59 <musasabi> What is the operator to test equality of Addr# ?
01:28:10 <Itkovian> meuning
01:28:27 * Itkovian is talking to you from his shiny new AMD Athlon XP 'Barton' 3000+
01:28:28 <Itkovian> lol
01:42:27 <shapr> good morning #haskell!
01:42:38 <kosmikus> good morning shapr
01:42:41 <Cale> morning shapr :)
01:42:59 <Cale> very early morning for me
01:45:00 <xerox> 'morning
01:45:03 <xerox> :)
01:47:25 <shapr> How's code?
01:48:08 <xerox> Kinda good.
01:50:35 <shapr> Anything neat I can look at?
01:52:27 <xerox> Not Haskell, I helped a guy running cairo bindings for clim on sbcl :) <bauhh.dyndns.org:8000/mcclim/cairo/>
01:53:02 <shapr> cairo is nifty
01:53:27 <TheStar> shapr, I hear that Enlightenment uses it.
01:55:55 <xerox> shapr: check the shots, the Listenere with antiliased fonts is really cute :)
02:12:04 <shapr> good morning JaffaCake
02:12:22 <JaffaCake> morning!
02:17:23 <Igloo> Yo Jaffa!
02:17:48 <JaffaCake> hey there :)
02:18:28 <Igloo> JaffaCake: Does http://urchin.earth.li/~ian/diff.txt look plausible to fix the alpha problem?
02:19:18 <JaffaCake> looks reasonable, yes
02:19:30 <Igloo> Cool, thanks
02:30:06 <mg_nic> Can be aspect oriented programming done with haskell ?
02:30:30 <shapr> You should read the thread on LtU to get a better idea of the answer to that.
02:30:43 <shapr> In my opinion, AOP is a subset of monads, a single monad in fact.
02:31:08 <shapr> Some other people on LtU disagree.
02:31:23 <mg_nic> Cool, thx.
02:31:28 <musasabi> imho AOP is not really aplicable to haskell.
02:31:45 <shapr> mg_nic: http://lambda-the-ultimate.org/node/view/567#comment-4563
02:31:54 <musasabi> AOP is about problems with OO, when using a monadic DSL the whole problem goes away.
02:32:02 <shapr> Yeah, I agree.
02:33:17 <musasabi> There is no need to cross cut the object hierarchy as there is no object hierarchy in the OO sense to begin with.
02:36:03 <shapr> mg_nic: what do you think? do you know of anything that I might be missing about AOP?
02:36:58 <mg_nic> Well, i'm planning to learn Haskell, so i cant tell anything at this point ;D
02:37:38 <shapr> Have you seen the HaskellDemo and that sort of intro info?
02:37:42 <shapr> g'mornin skylan
02:37:45 <shapr> ahem skew
02:38:17 <mg_nic> nop
02:38:49 <shapr> @wiki HaskellDemo
02:38:49 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
02:39:26 <shapr> That's the one free spoonful that ice cream stores give you.
02:40:00 <mg_nic> hehe ok
02:44:28 <skew> hi shapr
02:53:31 <lightstep> what is IsChar good for
02:53:32 <lightstep> ?
02:53:37 <lightstep> @index IsChar
02:53:37 <lambdabot> bzzt
02:53:45 <lightstep> @info IsChar
02:53:56 <skew> what is IsChar?
02:54:19 <lightstep> Text.Printf.IsChar
02:54:56 <lightstep> printf can have lists of IsChar types as its first parameter
02:59:10 <musasabi> lightstep: that is just a predicate.
02:59:15 <musasabi> lisppaste2: a type-predicate.
02:59:21 <musasabi> *lightstep
02:59:50 <musasabi> lightstep: the definition means that it works for lists that satisfy IsChar.
03:00:01 <musasabi> lightstep: and that is satisfied by Char.
03:00:07 <musasabi> lightstep: the source is quite clean.
03:01:38 <lightstep> is there a browsable source repository for the heirarchical libraries?
03:02:26 <musasabi> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/
03:50:03 <glimming> >  newtype  RecD  t o1 o2     = RecD   {unRecD1 :: o1, unRecD2 :: o2}
03:50:08 <glimming> is there something wrong with this?
03:51:38 <glimming> GHC 6.4 responds   /Users/glimming/Eclipse/hSigma/src/Otypes.lhs:26:52: parse error on input `,'
03:52:38 * shapr bounces hoppily
03:52:44 <Lemmih> You can't use records with newtype.
03:54:11 <glimming> aha
03:54:25 <glimming> shapr, what's up? ;-))))
03:54:38 <glimming> The king of IRC is here.
03:54:57 <glimming> newtype Direc f  = Dinn (f (Direc f) (Direc f))
03:55:03 <glimming> Can I get the inverse of Dinn for free using records?
03:55:09 <glimming> Say defining dout ::   somehow?
03:55:13 <glimming> Inside a record?
03:56:11 <Lemmih> Use 'data' instead of 'newtype'
03:56:19 <glimming> Sure...
03:56:31 <glimming> But sometimes newtype is better e.g. fixpoint operators
03:56:44 <glimming> Why do you prefer data?
03:57:08 <Lemmih> I don't prefer 'data'. They are two different keywords for two different things.
03:57:41 <glimming> Aha
03:58:39 <Lemmih> 'newtype' is like 'type' with a named data constructor.
03:58:45 <glimming> aha
03:58:55 <glimming> whereas data introduces some bottom.
03:58:56 <glimming> ?
03:59:14 <ibid> the other view is that newtype is a specialization of data :)
03:59:50 <glimming> Weird that above worked fine for one field.
03:59:56 <glimming> So for direc, something like this:
03:59:57 <glimming> >  newtype Direc f  = Dinn { dout :: (f (Direc f) (Direc f)) }
04:00:01 <glimming> But you want data (why?)
04:00:28 <xerox> Because of this? <Lemmih> You can't use records with newtype.
04:00:46 <ibid> you can't?
04:00:55 <glimming> c.f. >  newtype Rec f    = Inn { out :: (f (Rec f)) }
04:00:57 <glimming> Oh, I think you can.
04:01:03 <glimming> I saw it somewhere.
04:01:08 <skew> Newtype make a new type isomorphic to but distinct from an existing type
04:01:13 <skew> data defines a new data type
04:01:22 <Lemmih> I got tricked by the two (Direc f)'s. It doesn't matter when you only have one field.
04:01:24 <ibid> yeah, seems so
04:01:37 <glimming> Right.
04:01:45 <glimming> Stran ge.
04:01:50 <glimming> newtype should work with records too I think.
04:01:55 <glimming> Why shouldn't they?
04:01:55 <ibid> yes, newtype can have a single-field record
04:02:00 <glimming> Strange.
04:02:02 * ibid just checked the report
04:02:10 <glimming> There has to be some semantical expanation to this.
04:02:14 <skew> So you say newtype Meters = Meters Float, if you want to think of some special floats as lengths and have the type system keep them apart from plain number
04:02:54 <skew> You have to say data if you want more than one constructor, or multiple parameters on a constructor, etc.
04:03:42 <skew> The reason for making the distinction is because newtypes can be completely compiled out
04:03:50 <glimming> Aha
04:04:09 <lightstep> can (Maybe Int) be an instance?
04:05:04 <shapr> hiya glimming
04:05:26 <skew> Also, with newtype you can write anything you want in the deriving clause, and the instance for the wrapped type is just copied over
04:05:41 <ibid> you also need data if you want your type to have a bottom distinct from the field's bottom
04:06:28 <skew> especially useful for netype InterpreterMonad = InterpM (ComplicatedT MonadT TransforerT TypeT BaseMonad) derving(Whole,Lot,Of,Monad,Classes)
04:06:33 <ibid> skew: that's not h98, right?
04:07:12 <glimming> If someone have some good mini project proiposals in Haskell, send them to me.
04:07:33 <glimming> They have to be well-specified and fit as a laboratory exercise for a course  in AFP.
04:08:29 <glimming> I plan for 4-5 miniprojects as part of examination for an AFP course.
04:08:45 <skew> ibid: the report says deriving on newtype is treated just like deriving on data
04:15:24 <halcyon10> =) i just finally finished a function that i tried to get working for hours
04:16:04 <halcyon10> and i come to the conclusion that good solutions are always simple and beautiful
04:19:58 <ibid> skew: which confirms my point, yes?
04:23:19 <TheHunter> well, "cunning newtype deriving" is one of these things that are so incredibly useful that you're happy to sacrifice compatibility for it.
04:25:35 <ibid> true
04:25:51 <ibid> but it's prudent to be aware of it, imho
04:26:06 <TheHunter> i'm somewhat surprised that hugs didn't add it in its latest release.
04:27:54 <nlv11757_> what qualifies as a cunning newtype deriving?
04:29:30 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
04:31:53 <nlv11757_> ah
04:31:54 <nlv11757_> i see
04:45:28 <glimming> >  newtype Rec f t    = Inn  { out :: (f t (Rec f t)) }
04:45:28 <glimming> >  newtype Direc f t  = Dinn { dout :: (f t (Direc f t) (Direc f t)) }
04:45:39 <glimming> Here Rec f t is supposed to give the fixppoint of a pattern functor f
04:45:44 <glimming> Note that f takes two arguments par and rec
04:45:53 <glimming> The second is an attempt of a generalisation which fails.
04:46:07 <glimming> Here Direc f t is supposed to work similarly, to have an extra type argument.
04:46:15 <glimming> Result: Kind error: `f' is applied to too many type arguments
04:46:15 <glimming>     In the newtype declaration for `Direc'
04:51:43 * shapr throws lambdas
04:53:04 <glimming> In Rec, I want t:*  and f: (* -> (* -> *))
04:53:06 <glimming> I think...
04:53:18 <glimming> t is just a type.
04:53:25 <glimming> f constructs a type constructor given a type.
04:54:44 <lightstep> glimming, you call f with t, (Direc f t) and (Direc f t)
04:54:51 <lightstep> 3 args
04:55:09 <shapr> dons: you doing something interesting with the hOp network stack?
04:56:48 <glimming> Maybe this is what I wanted:
04:56:48 <glimming> >  newtype Rec f t    = Inn  { out  :: (f t (Rec f)) }
04:56:48 <glimming> >  newtype Direc f t  = Dinn { dout :: (f t (Direc f) (Direc f)) }
04:56:58 <glimming> At least it went through ... almost
04:57:16 <shapr> There are two weeks left to write humorous TMR articles for the April 1st issue, anyone wants to write something?
04:57:20 <glimming> phase `Literate pre-processor' failed (exitcode = 1)
04:57:25 <shapr> Anyone has ideas for april 1st articles to write?
04:58:10 <shapr> I was thinking of writing an article flaming the functional programming community for not realizing that loops are a more fundamental control structure than recursion.
05:00:09 <ibid> shapr: been done, and not as a joke :)
05:00:12 <shapr> Let's see, what other mischief could I pursue? How about a Haskell 2 standard that gets rid of significant whitespace, requires {}; and uses implicit params or uniqueness types instead of monads?
05:00:50 <lightstep> copying whitespace overloading from c++ perhaps?
05:00:58 <shapr> Is there really such a thing?
05:01:03 <shapr> whitespace overloading?
05:01:28 <lightstep> it was an april fool's joke
05:01:43 <lightstep> with fake interview with troustrup and all
05:02:27 <edwinb> so you could do 2xy and really mean 2*x*y...
05:02:29 <edwinb> (hello world)
05:02:38 <shapr> wow, that's scary
05:02:53 <ibid> shapr: dijkstra argues in 'a discipline of programming' that loops are more fundamental than recursion
05:03:14 <edwinb> Might have been true/practical in the 1970s ;)
05:03:22 <shapr> We could fake an interview with the Simons in which they claim Microsoft has encouraged them to move all GHC development to dotnet.
05:04:02 <lightstep> like the joke in the humor section at haskell.org?
05:04:13 <edwinb> That joke almost became true...
05:04:24 <edwinb> so careful, they might actually do it...
05:04:27 <shapr> Or what about an announcement where TransMeta is making a hardware STG?
05:04:35 <edwinb> yay
05:04:54 <shapr> What other mischief comes to mind?
05:05:18 <ibid> "Although correct, [the position that loops are defined as recursive functions implicitly called] hurts me, for I don't like to crack and egg with a sledgehammer, no matter how effective the sledgehammer is for doing so. ... In view of the fact that we cannot even define what a Turing machine is supposed to do without appealing to the notion of repetition, some redressing of the balance seemed indicated."
05:05:49 <ibid> edwinb: not really a matter of practicality :)
05:06:21 <shapr> I think a new 'codependent' type system could be amusing.
05:07:02 * ibid still laughs about the old discussion on this channel that ended  with 'what's a conothing?'
05:13:19 <shapr> Does the ghc 6.4 C-- backend work on Linux/x86 ?
05:13:41 <autrijus> shapr: you're not in #perl6, you missed my announcement :)
05:13:44 <shapr> Does gcc support C--, or do I need a separate compiler? Is all this answered in the GHC FAQs already?
05:14:54 <autrijus> shapr: This afternoon I've thrown together a mandelbrot example for the Pugs compiler (to haskell) backend work. Here's the benchmark numbers: Pugs Interpreted:   77.29 seconds 477k memory
05:14:58 <autrijus> PugsCC Unoptimized: 01.35 seconds 476k memory
05:15:01 <autrijus> PugsCC Optimized:   00.39 seconds 455k memory
05:15:03 <autrijus> Perl 5:             00.14 seconds 362k memory
05:15:10 <autrijus> so, [| |] is really da bomb.
05:15:39 <ozone> with unboxed values, you will so destroy perl 5 in that benchmark
05:15:52 <autrijus> very much, because p5 is interpreted.
05:15:53 <lightstep> but not with double-boxed
05:16:02 <lightstep> (like they are now)
05:16:10 <autrijus> yup
05:16:13 <ozone> double-boxed?
05:16:16 <autrijus> double boxed with fundep vCasts
05:16:21 <autrijus> not the recipe of speed
05:16:29 <ozone> vCasts?
05:16:37 <ibid> shapr: gcc does not know C--, there is a separate compiler in the C-- project. dunno if ghc already includes one...
05:16:49 <autrijus> ozone: src/AST.hs, look for vCast :)
05:16:51 <shapr> autrijus: wow
05:17:39 <ozone> autrijus: you're so tempting me to hack on that
05:17:46 <shapr> yeah, me too
05:17:48 <ozone> too much code, too little time
05:18:19 <autrijus> shapr: TMR will get an article on how to hack it :)
05:18:25 <autrijus> this month, that is.
05:18:36 <shapr> I'm not sure if there will be a TMR issue this month.
05:18:40 <autrijus> aw.
05:18:47 <autrijus> I'll still write it anyway.
05:18:53 <ozone> shapr: dare you to make a "TMR Perl 6 Edition"
05:19:01 <ozone> go on
05:19:02 <shapr> ozone: only if you write an article
05:19:03 <autrijus> lol :p
05:19:37 <ozone> shapr: i can write one about chicks in uppsala
05:19:45 <nlv11757_> go on
05:19:48 <shapr> it's dangerous to dare me before I've had my methylphenidate.
05:20:05 <ozone> it will be the best article evar
05:20:06 <shapr> ozone: nah, you gotta hack on pugs and write an article about it.
05:20:28 <shapr> c'mon, you did Teh RuntimeLodar
05:20:46 <ozone> yeah, but that got taken over by crazy don
05:20:59 <shapr> yeah, so now you can hack on pugs and do something equally cool.
05:21:17 <shapr> we know you got da skillz and da kodez
05:21:48 <shapr> A TMR perl 6 edition would be perfect for April 1st
05:21:54 <Lunar^> shapr: What about SPJ dropping GHC in favor of working on Links?
05:22:01 <shapr> Lunar^: interesting!
05:22:15 <xerox> shapr: what is methylphenidate?
05:22:28 <JaffaCake> Lunar^: you thnk that's gonna happen? :)
05:22:29 <shapr> xerox: ritalin, concerta, ADDeral, etc
05:22:52 <Lunar^> JaffaCake: We where talking about something for  April 1st ;)
05:22:59 <JaffaCake> aaaah
05:23:08 <Lunar^> JaffaCake: I hope not, though ;)
05:23:28 <xerox> shapr: I don't know them :\ What is it about?
05:24:09 <ozone> shapr: i reckon you should announce ghc 6.6, with Associated Types
05:24:09 <shapr> xerox: Medication for hyperactive and easily distractable people.
05:24:16 * ozone puts on evil hat
05:24:26 <shapr> ozone: c'mon, doncha wanna write about perl 6 =)
05:24:27 * xerox is one
05:25:56 <Lunar^> shapr: What about GHC 6.6 dropping '\' to follow Guido's advice ? :)
05:26:17 <autrijus> lol :)
05:26:34 <autrijus> "we now force you to lift lambdas so the compiler won't have to"
05:26:46 <JaffaCake> ozone: what do you want associated types for?
05:26:47 <Lunar^> hehe
05:29:00 <ozone> JaffaCake: (1) optimisation, (2) extensible types
05:29:10 <ozone> i should probably point out at this stage that i'm one of manuel's students
05:29:20 <JaffaCake> yes, I know ;)
05:29:35 <glimming> where can I paste a non-trivial problem?
05:29:42 <xerox> lisppaste2: url?
05:29:43 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:29:48 <ozone> JaffaCake: both of them, i think, are equally valuable
05:30:05 <ozone> JaffaCake: with (1), think of all the bandwidth saved by people asking about how to do arrays fast in haskell :)
05:30:21 <lisppaste2> glimming pasted "problem with fixpoints" at http://paste.lisp.org/display/6796
05:30:25 <JaffaCake> I think you get (1) with GADTs, and it might be worthwhile to investigate doing (2) with GADTs too
05:31:01 <glimming> Why does hugs/ghci complain about the pasted code?
05:31:21 <ozone> JaffaCake: i've never investigated using GADTs for optimisation.  have any pointers?
05:31:59 <JaffaCake> hmm, well you can code up most of the associated types examples using GADTs, but what you lose is the extensibility
05:32:08 <shapr> ozone: does this mean I can't persuade you into writing an article about pugs and ghc together at last?
05:32:24 <JaffaCake> eg. for arrays you have one constructor per array type
05:32:25 <ozone> shapr: well, realistically, i'd love to hack on it
05:32:29 <ozone> but i don't think i'll have the time to
05:32:39 <ozone> if you ask me now, i can't promise anything
05:32:50 <shapr> Hey, you have 1.5 weeks before publication of the possible April 1st issue of TMR.
05:33:07 <ozone> JaffaCake: hmm, are you reluctant to implement ATs?
05:33:41 <JaffaCake> me, definitely (I don't know how the typechecker works!) and I think SPJ is quite reluctant too, just because it's quite an invasive change
05:33:48 <shapr> That's more than enough time to write an informative and humorous article about Perl and Haskell.
05:34:14 <pesco> Maybe a fable!
05:34:16 <JaffaCake> anyone remember Haskerl?
05:34:16 <ozone> JaffaCake: rightio
05:34:22 <kosmikus> JaffaCake: how do you want to do extensible types with GADTs?
05:34:37 <shapr> Yeah, Haskerl
05:34:43 <pesco> Greetings, #haskell.
05:34:47 <shapr> y0 pesco
05:34:48 * pesco waves to shapr.
05:35:19 <Lunar^> It's interesting that no one found the FFI <-> Cabal bug before
05:35:26 <JaffaCake> kosmikus: no concrete ideas, but I don't think anyone has put any real thought into extensible data types in Haskell that I'm aware of
05:35:30 * pesco nods to everyone else.
05:35:45 <ozone> JaffaCake: except for oleg et al :)
05:36:05 <shapr> Oleg is cool. I'd love to take classes from him.
05:36:25 <kosmikus> JaffaCake: let me rephrase then; do you think that extensible GADTs might be any easier than extensible ADTs?
05:36:28 <JaffaCake> heh, well yes but they don't want to extend the language - in contrast, we're quite happy to#
05:36:44 <shapr> y0 basti_
05:36:49 <basti_> hi sh10151
05:36:51 <basti_> apr
05:36:52 <JaffaCake> kosmikus: probably not
05:37:01 <basti_> I'll soon have net at home again
05:37:02 <basti_> finally
05:37:16 <shapr> You survived the apartment move then?
05:37:21 <basti_> yes.
05:37:30 <basti_> was pretty chaotic.
05:37:48 <basti_> and the new appartment looks still looks like palestina
05:38:02 <basti_> lookslock
05:38:07 <earthy> hm. Haskerl seems schweet
05:38:09 <kosmikus> JaffaCake: the GADT machinery involves pattern matching against patterns with different results types; this could possibly be reused for extensible datatypes somehow ...
05:38:10 <earthy> and partly implemented, at that.
05:39:39 <nlv11757_> haha you guys use many abbreviations and words that I can't place
05:41:24 <boegel> @seen samc
05:41:25 <lambdabot> I saw samc leaving #haskell 3 days 21 hours 31 minutes 22 seconds ago.
05:41:34 <shapr> @seen kenneth
05:41:34 <lambdabot> I haven't seen kenneth
05:41:51 <shapr> hoi boegel
05:42:20 <Lunar^> shapr: I have understood why HFuse blocks when reentering Haskell
05:42:25 <shapr> Lunar^: oh tell me why!
05:42:34 <Lunar^> shapr: FUSE actually starts a new thread per syscall
05:42:47 <shapr> je ne sais pas! et je veux ...
05:42:51 <Lunar^> shapr: It's just that simple
05:43:00 <shapr> er, why?
05:43:11 * shapr thinks about that
05:43:13 <Lunar^> shapr: It seems that the RTS would allow reentrancy, but not from a different thread, for sure
05:43:30 <Lunar^> (because that's no reentrancy, then)
05:43:53 <shapr> How can you fix that?
05:45:23 <Lunar^> shapr: Build a debug RTS, write a good mail to ghc-users
05:45:47 <Lunar^> or asking JaffaCake, but a mail will be better I think
05:46:09 <JaffaCake> what's the problem?
05:46:12 <Lunar^> shapr: I've hit a Cabal bug also : Module_stub.{h,c,o} aren't handled properly
05:46:29 <Lunar^> JaffaCake: I am doing a binding for Linux FUSE library
05:46:34 <shapr> Well, send off a mail to cabal-users, aka the libraries list.
05:46:44 <Lunar^> shapr: I've noticed Syntax already
05:46:48 <shapr> malheureusment, je donc travaille
05:46:59 * earthy laughs
05:47:09 <shapr> earthy: was it that bad?
05:47:15 <Lunar^> JaffaCake: with it, you can implement filesystems in userspace
05:47:24 <earthy> the haskerl thread actually sparked thoughts about the obfuscated haskell contest
05:47:26 <JaffaCake> okeydoke, sounds cool
05:48:12 <Lunar^> JaffaCake: I am then using most FFI features to do it :) One of the classic example is fusexmp, which use most POSIX (2) calls to mount '/' somewhere
05:48:32 * Philippa_ scrolls up
05:48:48 <Philippa_> I actually don't want extensible ADTs. But I have my own ideas as to what would be useful...
05:49:07 <boegel> hey shapr
05:49:11 <Lunar^> JaffaCake: but, my Haskell implementation of this, blocks when asking for the list of files in /tmp/test/tmp, if '/' is mounted on /tmp/test
05:49:27 <JaffaCake> ok
05:49:37 <Lunar^> JaffaCake: FUSE actually starts a new POSIX thread per syscall
05:49:59 * boegel is swearing on a c exercise again
05:50:11 <JaffaCake> so... you're getting multiple calls to the Haskell code from different POSIX threads?
05:50:34 <Lunar^> JaffaCake: yes, with a clear deadlock in that particular case
05:50:47 <JaffaCake> you're using -threaded, I presume?
05:51:03 <Lunar^> JaffaCake: because the Haskell code can't return without getting the result from the other thread
05:51:13 <Lunar^> JaffaCake: sure, it won't even link without
05:51:57 <JaffaCake> I haven't quite got the picture straight in my head, perhaps it'd be easier to put it in an email
05:52:07 <Lunar^> That's what I thought :)
05:52:11 <JaffaCake> sorry :(
05:52:17 <Lunar^> I should write a trimed down test maybe
05:52:27 <Lunar^> JaffaCake: don't worry :)
05:52:34 <JaffaCake> sounds like it... you think it's a bug in GHC?
05:52:56 <Lunar^> I don't think so, but I don't know how I could work around this
05:55:06 * shapr reads a paper about Haskell by Simon P Booth and Simon B Jones
05:55:13 <shapr> What's up with all the Simons in functional programming?
05:55:27 <shapr> Should I change my name?
05:55:33 <Philippa_> what, again?
05:55:35 <shapr> :-P
05:55:43 <shapr> third time's the charm I hear...
05:56:13 <shapr> Maybe in the Haskell 2 standard this language should be called Simon?
05:56:18 <boegel> shapr: did you use another nick in the past ?
05:56:32 <shapr> boegel: no, I changed my name a few years back.
05:56:36 <shapr> 97 I think
05:57:38 <shapr> musasabi_: You think this would apply to the shootout? - http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR141.pdf
05:57:41 <boegel> shapr: your name, or your nick ?
05:57:59 <shapr> My name. I was born Robert Benjamin Gilliam.
05:58:07 <boegel> why did you change it ?
05:58:10 <lightstep> why did you change?
05:58:15 <boegel> lightstep: :D
05:58:15 <lightstep> err
05:58:16 <shapr> I wanted a name that describes me.
05:58:33 <boegel> and Shae describes you better ? how did your parents like that ?
05:58:43 <shapr> My parents weren't very happy.
05:58:48 <basti_> parents?
05:58:51 <boegel> I can imagine
05:58:58 <shapr> But once they realized I wasn't trying to disown them, they got over it.
05:59:12 <boegel> basti_: your mother (the one with the boobs), and your father (the one without the boobs)
05:59:26 <shapr> I think he was asking the same question in an abbreviated form.
05:59:31 <basti_> but who cares about what they say?
05:59:32 <shapr> Anyway, shae is short for shapr ;-)
05:59:33 <basti_> no ;)
06:00:12 <shapr> I find it humorous that I have chosen my irc nickname for my legal name.
06:00:20 <basti_> do your parents know?
06:00:43 <boegel> basti_: who cares about parents :D
06:00:46 <basti_> -g-
06:00:49 <shapr> Yeah, I explained the whole thing to them. They didn't agree at first, but once they realized the goal behind the action, they were fine with it.
06:01:39 <lightstep> so how did you choose your nick?
06:02:40 <shapr> The whole point of changing my name was that I wanted to remake myself, break out of old habits that weren't good for me. I decided I wanted to do that when I was 21, but experience taught me that the larger a life change I contemplate, the longer I should think carefully before commiting to the action. So I waited till I was 27 to actually do it.
06:03:40 <basti_> I think my life is changing all the time
06:03:48 <basti_> I'm a very different person now than 5 years ago
06:03:57 <boegel> basti_: same here
06:03:58 <shapr> lightstep: I'd love to tell you, everyone like to talk about themselves, but I have to get some work done before my boss gets back.. :-) ask me next time I'm online.
06:04:01 <nlv11757_> you're real name is not shapr i hope?
06:04:12 <shapr> nlv11757_: it is, sort of... 'shae'
06:04:15 <shapr> anyway, I'll bbl
06:13:15 <basti_> so why is it quiet now
06:15:22 <lightstep> megamonad is gone
06:15:50 <basti_> oh.
06:19:14 <boegel> lightstep: no, shapr is gone, that's why :)
06:19:36 <lightstep> probably
06:21:16 <Lunar^> *sigh*
06:24:28 <lightstep> is there a way to implement index (a la Ix) given Typeable?
06:35:02 <TheHunter> you'll need Data.
06:41:05 <TheHunter> @type Data.Ix.index
06:41:06 <lambdabot> Data.Ix.index :: forall a. (GHC.Arr.Ix a) => (a, a) -> a -> Int
06:43:22 <lightstep> acrually Ix is also in the report
06:45:02 <TheHunter> lightstep, what it is exactly you want to do.
06:45:14 <lightstep> a generic hash table
06:46:32 <TheHunter> So you want to write hash :: Data a => a -> Int ?
06:47:24 <TheHunter> if you have a Typeable, there's no easy way to get all instances of that type, if that's what you meant.
06:48:31 <lightstep> now i'm confused. what's Data?
06:48:55 <lightstep> there's already Typeable and Dynamic, why more?
06:49:15 <TheHunter> Data is something like Typeable, but you also get information about how the type is built.
06:49:40 <TheHunter> SYB: http://www.cs.vu.nl/boilerplate/
06:50:40 <TheHunter> The usual way to define a Hashtable would be just a "class Hashable a where hash :: a -> Int" and then defining instances for everything.
06:51:58 <lightstep> i was wondering why there isn't an STHashTable in the libraries. but probably people already define Ix or Ord when they want it
06:54:27 * boegel hits c with a big hammer *smash
06:58:02 <nlv11757_> it's rubbish boegel, i agree
06:58:25 <basti_> everyone here would do i think
06:58:38 <nlv11757_> i never want to work with it ever if i can avoid it. Certainly not for a living.
06:58:48 <nlv11757_> im even prepared to work with OCaml :P
07:04:26 <glimming> How do I pattern match a record Something {a, b} ?
07:04:32 <glimming> f (Something a b) = a ?
07:04:48 <glimming> Do I have to give one argument for each field?
07:05:24 <lightstep> you can use _
07:05:33 <lightstep> or use can use the field names
07:06:21 <lightstep> like f RecordType{field1=a, field5=b} = ...
07:06:49 <glimming> So to match a record I could write simply
07:06:56 <glimming> matchRec rec = ...
07:07:07 <glimming> My program requests two arguments for a two field record Rec
07:07:09 <glimming> So I had to write
07:07:13 <glimming> matchRec (Rec rec rec) = ...
07:07:31 <glimming> (put prime on second rec ---> rec')
07:08:46 <lightstep> at this point, punning is xomplifying things, so it's better to work with a concrete `data' definition
07:09:52 <glimming> >  instance Difunctor RecD where
07:09:52 <glimming> >     dimap _ _ f g (RecD r)      = RecD {unRecD1 = f (unRecD1 r),
07:09:53 <glimming> >                                         unRecD2 = g (unRecD2 r)}
07:10:19 <glimming> where
07:10:19 <glimming> >  data  RecD   t o1 o2       = RecD   {unRecD1  :: o1,
07:10:20 <glimming> >                                       unRecD2  :: o
07:10:31 <glimming> 2}
07:12:15 <lightstep> diMap _ _ f g RecD{unRecD1=r1,unRecD2=r2} = RecD (f r1) (g r2)
07:14:16 <glimming> Is this the only way?
07:15:20 <lightstep> no
07:15:29 <lightstep> timtowtdi
07:46:37 <basti|> "software caused connection abort"
07:51:36 <basti|> whats the ghost command on freenode?
07:55:40 <basti|> o0
08:34:33 <bourbaki> moin
08:36:06 <bourbaki> who of you uses ghc on a mac?
09:14:34 <Cale> heh, from http://www.cs.chalmers.se/~rjmh/Haskell/Messages/Display.cgi?id=444 :
09:14:49 <Cale> Acknowledgements: This proposal benefited considerably from Netscape Navigator crashing when I'd almost finished typing in an earlier version.
09:21:28 <stepcut> haha
09:31:42 <bourbaki> hey TheHunter
09:33:11 <wilx> Cale, in the Notes section, second bullet.
09:33:24 <wilx> You have double for in the second paragraph.
09:33:41 <Cale> wilx: hm?
09:34:03 <Cale> this isn't mine
09:34:18 <wilx> Oh.
09:34:27 <wilx> I misunderstood then.
09:34:29 <Cale> and it's really quite old
09:34:51 <Cale> I believe it's from when Haskell 98 was being defined.
09:34:57 <wilx> I see...
09:34:58 <wilx> :)
09:36:04 * stepcut finally gets around to checking out the new modules in ghc 6.4
09:38:11 <bourbaki> does anyone of you run haskell on a mac?
09:38:27 <cooz> yes.
09:38:36 <bourbaki> what editor do you use?
09:38:52 <cooz> vim.
09:39:37 <bourbaki> is there anything more ide like on the mac that integrates with haskell?
09:39:46 <autrijus> eclipse?
09:40:04 <cooz> I have no idea, I like using vim for everything I code or write..
09:40:37 <halcyon10> but vim isn't learnt in one day..
09:40:47 <Cale> I tended to use emacs. I also use vim.
09:41:10 <bourbaki> hm vim has so strange keys
09:41:20 <cooz> yep, that's true.
09:41:44 <bourbaki> a bit unintuitive
09:41:51 <wilx> Only a bit? :)
09:41:57 <Cale> Vim's keys are nice once you're used to them, but a little tricky to remember at first.
09:42:16 <Cale> The common things usually make some kind of sense.
09:42:38 <cooz> I choose vim instead of emacs about 7 years agom beacuse it was so much faster on my machine..
09:43:12 <Cale> I recommend both.
09:43:57 <Cale> haskell-mode in emacs is fairly nice
09:44:08 * stepcut should work on yi some more...
09:46:09 * humasect nod
09:51:36 <Khisanth> Cale: do you end up trying to use :w and c-x c-s everywhere too? :)
09:52:05 <Cale> Khisanth: I did for a while -- it's less frequent now
09:52:37 <Khisanth> the c-x c-s was especially bad when you are using pico
09:52:47 <bourbaki> cooz: can you somehow replace all the window style? its too bright :)
09:52:50 <Cale> I don't use pico :)
09:53:28 <lucs_> Every time I open a Word document at work, I start by entering a bunch of 'jjjjjj' into it :)
09:54:02 <cooz> bourbaki: colorscheme <name> ?
09:54:31 <bourbaki> cooz: ? you can do that in mac os?
09:54:45 <cooz> bourbaki: try :colorscheme desert for example, and see http://www-2.cs.cmu.edu/~maverick/VimColorSchemeTest/
09:54:56 <cooz> bourbaki: in vim..
09:55:13 <cooz> bourbaki: you mean that terminal is too bright?
09:55:13 <bourbaki> ah ok i want to change my colours on the mac :)
09:55:21 <bourbaki> everything :)
09:56:28 <cooz> terminals background you can change from it's setting, but I don't know about general style..
10:14:39 <Lunar^> JaffaCake: Are you planing to remove any static flag?
10:25:35 <TheHunter> hey bourbaki
10:35:03 <TheHunter> cool, http://www.cs.kent.ac.uk/projects/refactor-fp/Monadification.html
10:37:19 <TheHunter> hmm, does anyone understand style 4?
10:37:45 <TheHunter> "it is decided that a certain type is replaced by computations over that type". Who decides that/How is it decided?
10:38:49 <TheHunter> ahh, there's a paper: that should clarify things.
10:38:55 <TheHunter> hey shapr
10:38:59 <shapr> hiya TheHunter
10:39:16 <shapr> dons: hey, Rebuilding dependencies... ghc-6.4: Can't find Yi/Undo.hs-boot \n (imported from Yi/Buffer.hs)
10:40:17 <shapr> hm, could this be user error because I don't have hs-plugins installed with 6.4?
10:41:41 <shapr> I had one of my many crazy thoughts recently in the shower... I think + and - aren't symmetrical.
10:42:04 <Cale> shapr: huh?
10:42:15 <shapr> I was thinking about partial application, such that (1+) == (+1) but (1-) /= (-1)
10:43:39 <shapr> To get symmetry, you'd have to always use addition, but allow negative numbers.
10:44:19 <shapr> Cale: is this super-basic math stuff that math 101 teaches?
10:44:36 <Cale> well, subtraction isn't commutative
10:44:37 <musasabi> shapr: isn't that just a haskell artefact.
10:45:02 <Cale> musasabi: I think shapr means (\x -> x - 1) by (-1)
10:45:26 <shapr> Yes, but I'm cogitating on the nature of commutative math, and whether it would be all around more natural if commutativity were preserved whenever possible.
10:45:34 <musasabi> isn't (a - b) defined to be (a + (-b))
10:45:42 <shapr> Is it? that would be nice.
10:45:49 <musasabi> that is in math.
10:46:18 <musasabi> In haskell it is not tied to that,
10:46:49 <musasabi> So one is not guaranteeded that (a - b) == (a + (-b)), which is true in math.
10:47:51 <shapr> I think the math definition you gave would allow more compositional thinking, which is the ultimate goal is software engineering.
10:48:14 <shapr> s/is/in
10:48:53 <metaperl> congratulations shapr, you just made my IRC snippets page on sequence for your last comment :)
10:49:06 <Cale> Well, anyone who defines sane instances for Num will make sure of that.
10:49:25 <shapr> metaperl: yay =)
10:49:59 <shapr> that's definitely my long term goal in every piece of software I write, and every system I investigate, I want the most compositional thinking I can get.
10:50:26 <shapr> Lazy eval doesn't usually fit into compositional thinking, but it sure is fun and powerful.
10:54:19 <shapr> musasabi: do you have any code towards the PersisTH idea?
10:56:11 <musasabi> shapr: yes.
10:56:20 <shapr> oh, anything I can look at yet? =)
10:57:07 <musasabi> shapr: currently I am doing the high level interface (how to fit handles nicely on top of the Ptr based buffers.
10:57:10 <Cale> shapr: I think lazy evaluation seems better for compositional thinking than strict evaluation
10:57:17 <musasabi> shapr: I can post something tonight.
10:57:22 <shapr> musasabi: spiffy!
10:57:32 <shapr> Cale: can you elaborate on that?
10:59:10 <Cale> hmm... okay
10:59:53 <Cale> The main issues are when you have something of the form f(g(x)), and you know what the result is mathematically, but strict evaluation diverges.
11:01:37 <Cale> Or even if g(x) just takes a really long time to evaluate
11:02:18 <Cale> f(g(x)) might still be feasible to compute
11:02:48 <Cale> It sort of frees you from worrying about certain performance issues.
11:03:44 <Cale> For example, we had someone here the other day who wanted to determine whether a particular substring occurred in a (potentially very long) string.
11:05:00 <Cale> I wrote:  any (s `isPrefixOf`) (tails str)
11:05:45 <Cale> If it was constructing a new object, tails str would be prohibitive to compute.
11:08:28 <Cale> But instead, we can actually make use of this composition, because it's only going to look at them one at a time. (and furthermore, no copying will be done)
11:11:15 <Cale> shapr: so I suppose the gist of it is that lazy evaluation can give you more options for breaking up a problem
11:11:55 <Cale> Very natural ways of breaking things up that in strict languages might be stupid or impossible.
11:12:36 <Cale> Another instance would be my scheduler, which is a really good case for lazy evaluation and monads.
11:13:02 <Cale> shapr: any of that make sense?
11:13:19 <Cale> I have to run very shortly
11:15:25 <shapr> I'm thinking about it.
11:18:14 <shapr> hiya jyasskin
11:21:55 <shapr> So, to get hs-plugins installed with ghc6.4, I need to cabalise it?
11:21:58 <shapr> Same for HaXml?
11:22:00 <Cale> like, in the code above, it was okay to break the problem up into (construct the tails) then (check if any start with s), whereas in a strict language, you wouldn't want to do that factoring, because it involves the creation of a large intermediate structure
11:23:09 <Cale> In my scheduler, the intermediate structure was a list of several trillion nontrivial entries, something like that.
11:23:38 <shapr> Cale: what you say sounds correct, and puts in question earlier conclusions of mine, specifically that there's more 'ease of composition' of reference counting and strict eval, therefore they're more compositional.
11:24:25 <shapr> Is it really easier to compose reference counting and strict eval because you don't have to think?
11:24:35 <shapr> You lose the flexibility of non-strict eval that you just described.
11:25:00 <jyasskin> shapr: I think HaXml is included in 6.4
11:25:03 <shapr> So for a little more work, you get a lot more flexibility.
11:25:50 <Cale> I think so
11:29:11 <jyasskin> shapr: nm, it's in the sources, but not packaged
11:30:19 <musasabi> How did I type something like newEncoder :: PFun -> Int -> IO (forall a. Serializable a => a -> IO ()) ?
11:30:50 <TheHunter> that's a type error.
11:30:57 <musasabi> yes.
11:31:13 <musasabi> if that would not be a type error I would not be asking ;)
11:31:27 <TheHunter> i guess you need to wrap forall a. Seri... into a newtype.
11:32:30 <TheHunter> sorry, i didn't get that it was a question.
11:34:02 <musasabi> newtype wrapping works, thanks.
11:34:42 <TheHunter> incidently, ghc core is impredicative, so the above can be written (well unsugared) there.
11:38:33 <musasabi> Can I get the polymorphic function somehow out - that would be the only use and adding explicit unwrapping for the user does not seem very nice.
11:40:48 <TheHunter> i don't think so.
11:44:03 <musasabi> Any ideas for alternative ways to create a polymorphic function ?
11:45:59 <TheHunter> well, you could do "newEncoder :: PFun -> Int -> forall a. Serializable a => a -> IO ()" using unsafePerformIO, but i doubt that this is wise.
11:47:23 <musasabi> so it is fine if the creation is outside IO?
11:47:24 <shapr> guten abend pesco
11:47:32 <pesco> nabend.
11:48:02 <musasabi> because that could be just be arranged with doing the io first and then the pure bit with preallocated (in IO) values.
11:49:05 <jyasskin> It's not usually fine to use unsafePerformIO
11:49:38 <TheHunter> i'd be afraid that optimizations may have an impact on the semantics.
11:49:38 <jyasskin> You could write an encodeWith :: Serializable a => Encoder -> a -> IO ()
11:49:59 <jyasskin> where Encoder is the newtype you defined
11:50:18 <musasabi> true and then partially apply..
11:51:34 <jyasskin> you still couldn't return the partially applied value into IO
11:52:17 <jyasskin> Users will have to call the extra function; they just don't have to pattern match.
11:52:52 <musasabi> but that can be done in 1) do blocks like do { enc <- newEncoder ...; let efun = encodeWith enc; ... } and in toplevel one would need unsafePerformIO regardless of circumstances.
11:53:05 <TheHunter> jyasskin, you know about record syntax with newtypes?
11:53:27 <jyasskin> yeah, newtype Encoder = {encodeWith :: Serializable a => a -> IO () }
11:54:04 <jyasskin> mm, * = Encoder { ...
11:54:24 <shapr> What sort of serializable are you using?
11:56:05 <musasabi> shapr: one that contains encode :: a -> SEnv (), decode :: DEnv a, and requires typeable - but the library can derive Typeable for types.
11:56:58 <shapr> nifty
11:57:29 <shapr> "I believe I've read several times that cognitive psychologists have convincingly demonstrated that people would rather have AnAcceptableWayOfFailing than a risky way of succeeding."
11:57:33 * shapr reads http://c2.com/cgi/wiki?AnAcceptableWayOfFailing
11:58:05 <jyasskin> hm, in Wadler's "The marriage of effects and monads", he talks about value polymorphism being needed to make monads work. Is this related?
11:58:50 <Philippa> shapr: it's called knowing your worst case isn't too bad
11:59:10 <shapr> Problem is that the worst case is still failure.
11:59:11 <Philippa> eg I will never /ever/ make a financial decision s.t. I can potentially end up homeless unless I have no choice
11:59:25 <Philippa> yeah, but 'acceptable' failure means it won't fuck your career as well
11:59:42 <Philippa> whereas a risky way of succeeding might well do that if the risk doesn't pan out
11:59:44 <shapr> Incremental improvements only gets you so far.
11:59:53 <shapr> C -> C++ -> Java -> ?
12:00:01 <jyasskin> Haskell! ;)
12:00:03 <shapr> How many steps will that take to get useful features of Haskell?
12:00:06 * shapr grins
12:00:34 <Philippa> jyasskin: I never actively preferred Java, but otherwise you have a notable part of the order in which I learnt and used languages...
12:00:40 <jyasskin> And I'm not sure if C++ -> Java counts as an improvement.
12:01:04 <shapr> I've been thinking about capitalism lately, I've realized that it encourages the companies that make the most money, not the companies that do the best work. I've been wondering how to establish a true meritocracy.
12:01:27 <shapr> I am no longer a capitalist, I am a meritist?
12:01:27 <Philippa> by having a clear definition of merit
12:01:40 * shapr wonders if that's a real word.
12:02:32 <jyasskin> I saw a page a while ago about 'rentalists' being opposed to capitalists.
12:02:32 <Philippa> it is now ;-)
12:02:39 <Philippa> though it's often dubbed 'elitist'
12:02:53 <Philippa> jyasskin: when it comes to housing, that makes a lot of sense in the UK
12:02:59 <Philippa> the housing market is nucking futs here
12:03:11 <shapr> I've never heard of rentalist. I'll ask Google.
12:03:35 <jyasskin> A rentalist charges "rent" (in an economic sense, rather than a housing sense, although I'm not clear on the difference) for pre-existing conditions, which they didn't necessarily create.
12:03:59 <Philippa> ah. 'exploitation', then
12:04:04 <shapr> fascinating.
12:04:56 * jyasskin leaves for lunch
12:07:24 <musasabi> Is there an existing combinator with type of:  Monad m => (a -> b) -> m a -> m b
12:08:41 <Philippa> liftM?
12:08:58 <shapr> @type Control.Monad.liftM
12:08:59 <lambdabot> Control.Monad.liftM :: forall r m a1.
12:08:59 <lambdabot> 		       (Monad m) =>
12:08:59 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
12:10:54 <musasabi> yes.
12:11:04 * musasabi wonders why I didn't think about it.
12:11:26 <shapr> That's why we have #haskell, for when we didn't think of it ourselves.
12:11:58 <musasabi> Except 'Inferred type is less polymorphic than expected' :-(
12:12:30 <musasabi> and solved that too.
12:13:36 <shapr> hiya Darius
12:13:44 <shapr> I was going to tell you something earlier. I wonder what it was.
12:14:06 <Darius> heya shapr
12:26:14 <shapr> I was thinking about adaptive baseN encoding recently, but I'm not sure if it's an improvement. Are there cases where base64 is too small or too large for the other end?
12:35:07 <Darius> Too small is not a problem, and too large doesn't seem likely.
12:36:02 <Darius> Isn't the point of Base64 to ramshackle binary data into ASCII, so you can assume at least 7 bits.
12:36:46 <Philippa> yep
12:37:18 <Philippa> I'd imagine cases where it doesn't work are pretty rare - certainly they couldn't speak a lot of the RFC-defined standards
12:37:39 <Philippa> it's almost /always/ too small though
12:38:10 <Philippa> I mean, once you're playing with MIME you're looking at 7 bits = Base128
12:39:33 * Darius curses Outlook but thanks to a DLL gone missing it didn't start, yay!
12:43:41 <Darius> *sigh* Isn't Firefox 1.0.1 supposed to work better?
12:44:46 <shapr> rumor says yes.
12:46:16 <Darius> Shortcut keys, or at least, Ctrl-T seems to just not work sometimes.
12:54:51 <Khisanth> Darius: does it depend on where your cursor is?
12:55:48 <Darius> I've tried in various places, and when it does work I don't believe my cursor's in an unusual place.  It didn't matter in 1.0.
13:08:13 <shingoki> what's up with firefox?
13:10:51 <shingoki> might need to click on the page or something?
13:19:22 <wilx> Bah.
13:19:37 <wilx> How does darcs decide that decomp.c is a binary file?
13:59:01 * boegel bounces
14:02:28 <boegel> bye cmeme, hi cmeme, bye cmeme, hi cmeme
14:02:46 <boegel> bye cmeme
14:03:20 * shapr boings
14:03:50 <shapr> I think cmeme is losing it.
14:04:30 <shapr> hiya tbarkley
14:05:47 <boegel> hey shapr
14:05:48 <shapr> maybe a tempban for cmeme?
14:05:55 <boegel> how are things with tmr2 ?
14:06:16 <shapr> it's unlikely tmr2 will be out for april 1st, I have a lot of work.
14:06:31 <boegel> I guess you're the one to decide on the tempban shapr
14:07:33 <shapr> metaperl: so we just need to get two other people to start voting on our content.
14:07:43 * pesco sends an email.
14:07:53 * shapr receives an email
14:07:55 <shapr> yay!
14:07:56 <pesco> Hah! Someone brought up the singlemoduleautofetch-idea on haskell@haskell.org!
14:08:30 <ibid> shapr: what's with a single-vote poll?
14:08:41 <shapr> eh?
14:08:50 <ibid> on haskell sequence?
14:09:04 <ibid> haskell evolution has one vote and is closed
14:09:05 <shapr> yay, finally someone voted on that poll!
14:09:29 <shapr> That's because I set the deadline for two weeks, and it took much longer than that for the poll to get through the queue
14:09:34 <ibid> i can't vote, it's closed
14:10:12 <ibid> can it be reopened?
14:10:20 <shapr> probably not by me
14:10:48 <shapr> pesco: btw, I thought of neat way to do autofetch without worrying about trojan code
14:11:01 <pesco> shapr: Digital signatures?
14:11:12 <shapr> pesco: if your import statement includes the version and hash, you know whether you're getting the right code
14:11:39 <shapr> though at this rate, cabal-get is probably a better solution
14:11:39 <pesco> shapr: But you cannot get compatible versions.
14:11:52 <shapr> if you assume that 1.5.x will never have an API change, you can.
14:12:12 <pesco> I don't follow.
14:13:03 <shapr> There were originally conventions for version numbers
14:13:13 <pesco> Oh?
14:13:38 <shapr> for example, you could improve the code all you wanted 'behind the scenes'. The 1.x part would never change, and the API would never change.
14:13:53 <jyasskin> That's why Emacs is still on version 2, iirc.
14:14:09 <shapr> actually, emacs is version 0.21, but they just dropped the 0.x part.
14:14:11 <pesco> shapr: But my improvement will include the trojan behind the scenes.
14:14:42 <shapr> Yeah, I can't figure out a way to do that past signing the next version with the previous version somehow.
14:14:46 <shapr> Oh I know
14:14:48 <shapr> duh :-)
14:15:03 <shapr> include the public key in the source of version 1.0
14:15:28 <shapr> and sign the next version with the private key.
14:15:42 <pesco> Heh.
14:15:56 <shapr> which is probably exactly what you meant when you mentioned digital signatures.
14:16:11 <pesco> Not exactly, but I was only making a broad statement.
14:16:31 <pesco> How do you know you got the right 1.0?
14:16:47 <shapr> You downloaded the source at some point :-)
14:17:22 <pesco> So whenever I start using the module I always need to fetch 1.0?
14:18:13 <pesco> I mean, if I use the module while it's at version 5, the system needs to get 1 to find the key once.
14:18:14 <shapr> at that rate, might as well get the author's public key.
14:18:21 <pesco> Yes.
14:18:35 <shapr> So it still comes down to gpg signing.
14:18:48 <pesco> There's not much wrong with that, is there?
14:19:23 <shapr> no, there's not.
14:19:36 <pesco> Au contraire, GPG is long deployed. There is already a web of trust.
14:19:49 <shapr> right, not much wrong with that.
14:21:51 <pesco> Especially in groups like "Haskell module authors" it might be easy to set up one "authors@haskell.org" key which, once validated by you would let you trust many other keys.
14:22:00 <shapr> yup
14:22:19 * boegel is off to continue reading "The Da Vince Code"
14:22:25 <boegel> bye everyone !
14:22:31 <shapr> cya
14:22:32 <pesco> boegel: Oh, I just ripped through that in two days. Good book.
14:22:38 * pesco waves.
14:22:55 <pesco> (After which I ripped through Neuromancer. Cryptonomicon is next)
14:23:10 <pesco> I wish I could rip through math text books as fast as SciFi novels.
14:23:28 <shapr> ibid: ah, you found baen.com/library?
14:23:45 <shapr> I've just finished the last of those that I can bear to read.
14:25:38 <pesco> shapr: You mean you're out of bearing for SciFi novels? That happens? Mhmmmm...
14:25:42 * pesco contemplates his future.
14:27:40 <shapr> ibid: I got 81%!
14:27:46 <pesco> Wow, efnet.ipv6.xs4all.nl has a huge Bunny in their motd! Freenode only has this stupid cake.
14:30:34 <Oejet> Good evening, folks.
14:33:11 <wilx`> Hmm, this is interesting.
14:33:40 <wilx> Darcs considers text file that ends with ASCII code 1A which is some control character as binary.
14:33:41 <metaperl> Good afternoon Oejet
14:35:34 <ibid> shapr: i've found it months ago
14:37:41 <shapr> hej krmkrl
14:39:05 <ibid> i should've mentioned the coq rouge novels too
14:39:14 <krmkrl> hej shapr
14:39:26 <ibid> shapr: have you read any of them?
14:40:39 <shapr> are they online?
14:41:07 <ibid> no
14:41:09 <shapr> hiya adiabatic
14:41:22 <shapr> At this moment, I can afford to read online novels only.
14:41:35 <ibid> famous swedish spy novels, very sophisticated
14:41:37 <shapr> That is, if I want to buy new hardware for computing, unicycling, etc.
14:41:50 <ibid> shapr: public libraries are good in sweden, i believe :)
14:41:52 <shapr> Oh, I see. In the name of education then...
14:42:13 <shapr> I am unable to return things I've borrowed. This is one reason I love free software.
14:42:17 <ibid> :)
14:42:23 <ibid> i have the same problem
14:42:46 <shapr> I still have this library book from months ago :-/
14:43:34 <ibid> i think i still owe about 300 euros in overdue penalties to the tampere city library :/
14:44:59 <TheStar> Ask how much it costs if you loose a book.
14:45:03 <TheStar> Then pay the cheapest ;)
14:46:18 <ibid> TheStar: easier to just buy the books
14:46:48 <TheStar> Some books are incredibly expensive.
14:47:15 <ibid> shapr: btw, there are a lot of more to harrington than you can get from the free library :)
14:47:20 <pesco> Wow, they have this amazing technology for Apple Mail whereby an X-Image-Url header is put in each Email, so you can see a little portrait of people on their mails.
14:47:36 <ibid> TheStar: yes, and if you "lose" them, you get to pay the whole price. isn't it fun?
14:47:44 <dons> shapr: the hs-boot thingo is a 6.4ism- yi is getting ported to 6.4 atm. hs-plugins also needed much porting, which seafood did a lot of.
14:47:46 <pesco> It absolutely amazes me how cool this is once you see it.
14:47:58 <ibid> plus they make you feel bad. i'd rather buy them outright
14:48:45 <TheStar> ibid, But at least you'd be able to borrow other books.
14:49:15 <TheStar> On that subject, I seriously need to pay my parking fine...
14:49:48 <shapr> pesco: I think gnus supports both the color and black & white versions of that.
14:49:56 <ibid> TheStar: what makes you think i'd be able to borrow other books? :)
14:50:13 <TheStar> pesco, Apparently apple mail doesn't support gnu imapd, and I just wish that it would bind the smtp setting to "network location".
14:50:17 <shapr> dons: silly me, I was playing with the keymap and I did make clean...
14:50:33 <TheStar> ibid, Why couldn't you? :)
14:50:56 <dons> --with-ghc=/f/g/ghc-6.2.2 could help
14:51:02 <dons> --with-hc=/f/g/ghc-6.2.2 could help
14:51:04 <dons> sorry
14:51:28 <ibid> TheStar: if i could, why would i "lose" the expensive book in the first place=
14:51:56 <TheStar> ibid, Pardon?  Please explain.
14:52:19 <TheStar> ibid, did you move?
14:52:59 <ibid> TheStar: if i "lose" an expensive book, i get to pay the expensive sum. then you said "but at least you'd be able to borrow other books"
14:53:03 <ibid> TheStar: what?
14:53:22 <pesco> shapr: I think you mean the X-Face header?
14:53:42 <TheStar> ibid, Most libraries I know of don't allow you to borrow books when you have a current fine.
14:53:51 <ibid> TheStar: so?
14:54:12 <ibid> TheStar: the comparison was to buying the book in the first place
14:54:14 <pesco> shapr: Which is slightly different, only supporting very few colors, because the data is actually in the header. I don't think it's comparable to a "real" picture (which Mail fetches from the web).
14:54:36 <TheStar> ibid, The comparison was paying the fine as opposed to "loosing the book", and paying *that* fine.
14:54:52 <ibid> TheStar: that wasn't my comparison
14:55:04 <ibid> but anyway
14:55:13 <ibid> i think i now know what you meant :)
14:55:27 <shapr> bd_: Greetings, learning Haskell?
14:55:52 <bd_> hi
14:55:54 <bd_> yeah, on and off
14:55:55 * pesco runs over to bd_, sniffing curiously at his leg.
14:56:02 * bd_ backs off
14:56:07 <shapr> bd_: any particular questions?
14:56:10 <bd_> not really
14:56:21 <bd_> just hoping to absorb anything that comes by :)
14:56:29 * pesco senses bd_'s fear.
14:56:33 <bd_> XD
14:57:02 <ibid> pesco: is a canine?
14:57:02 <shapr> Have you had the tour of #haskell?
14:57:06 <ibid> -:
14:57:07 <bd_> I really should be studying Chinese for a test right now :P
14:57:13 <bd_> Not yet, this is my first time here
14:57:23 <shapr> I can give you the short tour if you'd like.
14:57:25 <bd_> mostly just poking my head in randomly
14:57:33 <pesco> TheStar: I wish an X-Image-Url plugin for Thunderbird would appear.
14:57:39 <ibid> "here is ibid, the fat guy who talks much but doesn't code much in haskell"?
14:57:48 <metaperl> lol
14:57:53 <bd_> shapr: Sure
14:58:18 <shapr> ok! The first stop on this tour is the channel topic, source of useful info...
14:58:20 <ibid> (a short tour of #haskell, that:)
14:58:34 <shapr> it includes the logs, pointers to related channels, good stuff like that.
14:58:46 <pesco> bd_: I heard to day that Chinese (with the right input method) can be typed single-handedly.
14:58:50 <shapr> Second you have the famous lambdabot, an irc bot written in Haskell, and holder of useful tools.
14:58:58 <ibid> like...
14:58:59 <bd_> ah, yes, I stopped by the topic on the way in :)
14:59:08 <ibid> @yow
14:59:09 <lambdabot> So this is what it feels like to be potato salad
14:59:13 <ibid> ? :)
14:59:14 <shapr> Last but not least, there's the Haskell Wiki, container of much useful information.
14:59:20 <shapr> @wiki FrontPage
14:59:20 <lambdabot> http://www.haskell.org/hawiki/FrontPage
14:59:31 <shapr> And there's the original author of lambdabot, Mr. Pseudonym himself!
15:00:06 <metaperl> is that Andrew J. Bromage?
15:00:10 <shapr> bd_: for my next trick, I'll direct you to the ice cream parlor 'first spoonful come free' document on the Wiki...
15:00:15 <shapr> @wiki HaskellDemo
15:00:16 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
15:00:16 <pesco> bd_: And that a Chinese typist could smoke any latin touch-typist in a pipe with regards to speed.
15:00:41 <shapr> dons: --with-hc= didn't help :-(
15:00:56 <shapr> oh right, point it to 6.2, duh.
15:01:16 <Pseudonym> Tada!
15:01:17 <shapr> bd_: so, are you really in Maine?
15:01:22 <bd_> shapr: Yes
15:01:32 <Pseudonym> Thank you, thank you.  And for my next trick...
15:01:47 <shapr> bd_: I didn't know they taught Chinese in Maine.
15:01:54 <Pseudonym> Hey, Rocky!  Watch me pull a rabbit out of a hat!
15:02:00 <bd_> I'm at kind of an alternative high school :)
15:02:03 <wilx> musasabi, do you have that LZF (or was that LZJ?) thingy available for public view somewhere?
15:02:09 <shapr> bd_: sounds like fun
15:02:11 <ibid> (Cabot Cove, Maine)
15:02:19 <bd_> I wanted Japanese, but alas they don't offer it :(
15:02:29 <pesco> I think it's about time the world switches to Chinese *g*. Plus they traditionally write top-down as far as I know. All SciFI Matrix-like. I like Chinese.
15:02:50 <wilx> Matrix iirc has only kana in it.
15:02:51 * metaperl taught English in Taiwan 10years ago
15:02:56 <wilx> => Japanese :)
15:03:11 <shapr> I've been learning Swedish in Sweden, but that's not quite as cool.
15:03:15 <ibid> mut mikään kieli ei voita suomea :)
15:03:25 <pesco> wilx: I was only refering to the direction of flow.
15:03:33 <shapr> minä en puhu suomea!
15:03:39 <ibid> i think there are one or two people on this channel, beside myself, who understood that :)
15:03:40 <shapr> minä haluan suklataa
15:03:44 <ibid> suklaata
15:03:48 <shapr> whoops, thanks.
15:03:59 <ibid> shapr: et puhu mutta kirjoittaminen näyttää sujuvan hyvin :)
15:04:16 <shapr> thanks :-)
15:04:30 <ibid> and for the uninitiated:
15:04:42 <ibid> me: "but no language beats finnish"
15:04:48 <shapr> Sadly, my swedish is about the same :-/
15:04:54 <ibid> shapr: "i don't speak finnish"
15:05:06 <ibid> shapr: "i want chocoltae"
15:05:09 * shapr laughs
15:05:11 <pesco> I was also told that voice recognition seems to work much better on chinese than most other languages.
15:05:11 <ibid> me: "chocolate"
15:05:25 <dons> I wonder if that is because of the tones
15:05:27 <shapr> bd_: Did you expect a bunch of linguists?
15:05:28 <ibid> me: "you don't speak but your writing is going well"
15:05:56 <bd_> shapr: ?
15:05:58 <Pseudonym> Mi opinas, ke la mondo devas paroli Esperanton.
15:06:06 <SamB> I don't suppose any of you have heard of something like Parsec for Common Lisp
15:06:09 <ibid> i know a person who knows esperanto
15:06:10 <ibid> :)
15:06:15 <Pseudonym> Me too!
15:06:15 <shapr> xu do tavla mi fo la lojban
15:06:21 <ibid> Pseudonym: not you, tho :)
15:06:23 <Pseudonym> :-)
15:06:31 <Pseudonym> Me parolas malgrandan Esperanton.
15:06:32 <wilx> Heh.
15:06:34 <Pseudonym> Mi
15:06:36 <Pseudonym> Not Me
15:06:39 <pesco> Pseudonym: You're an Esperantist?
15:06:46 <pesco> malgrandan?
15:06:49 <shapr> bd_: just wondering if you had any preconceived notions of the membership of #haskell
15:06:50 <Pseudonym> Not really.
15:06:50 <ibid> "i speak malgrammarous esperanto"? :)
15:06:54 * shapr snickers
15:06:56 <Pseudonym> mal = not, grandas = large
15:07:01 <Pseudonym> i.e. "a little"
15:07:03 <pesco> Ah.
15:07:06 <bd_> shapr: Not really, I was sort of gradually drawn from perl 6 to pugs to haskell :)
15:07:06 <ibid> not too far off :)
15:07:16 <wilx> Sounds very like Spanish to me.
15:07:20 <shapr> bd_: truly life is a smorgasbord of goodies.
15:07:23 <ibid> i wish i spoke klingon
15:07:27 <dons> bd_: ah, another perl convert :)
15:07:28 <Pseudonym> Esperanto actually sounds the most like Polish.
15:07:29 <shapr> nuq'NEH!
15:07:32 <ibid> the esperantist i mention is also a klingonist
15:07:38 <bd_> dons: Seeing a lot of us lately? :)
15:07:43 <wilx> Polish?
15:07:43 <Pseudonym> ibid: It's not Nick Nicholas, is it?
15:07:46 <wilx> No way.
15:07:47 <wilx> Not to me.
15:07:48 <ibid> Pseudonym: no
15:07:50 <Pseudonym> OK.
15:08:02 <dons> bd_: a few, yeah.
15:08:03 <shapr> We have a copy of the Klingon dictionary here, but there's not really enough in there to speak the language.
15:08:04 * bd_ needs to try wrapping his head around monads properly again sometime after his chinese test XD
15:08:07 <Pseudonym> Friend of mine speaks eight languages, including Lojban, Esperanto, Klingon and Latin.
15:08:09 <shapr> lojban is pretty good though.
15:08:12 <Pseudonym> His web site is in eight languages.
15:08:17 <pesco> nb_: We've expecting you. ;-)
15:08:18 <ibid> Pseudonym: ey's a finn
15:08:23 <Pseudonym> He translated Hamlet and As You Like It into Klingon.
15:08:23 <shapr> The lojban community is veeery small, who's your friend?
15:08:32 <ibid> lived in denmark for a couple of years
15:08:41 <Pseudonym> It even follows the meter and rhyme.
15:08:48 <Pseudonym> That's the frightening part.
15:08:53 <pesco> Wow.
15:09:05 <ibid> you haven't properly experienced shakespeare until you've read him in the original klingon
15:09:10 <pesco> lol
15:09:12 <wilx> :)
15:09:12 <Pseudonym> Exactly!
15:09:26 <Pseudonym> He wrote this wonderful essay about the Klingon Shakespeare Restoration Project.
15:09:38 <Oejet> ibid: Where did you live in Denmark?
15:09:40 <ibid> i just love general chang :) [or who was he]
15:09:44 <ibid> Oejet: i did not
15:09:49 <Pseudonym> About how some Earth revisionist historians believed that Shakespeare was from Earth.
15:10:00 <Pseudonym> But this is nonsense.  Look how well Hamlet parodies Klingon politics!
15:10:07 <Pseudonym> What more proof do you need?
15:10:15 <wilx> :))
15:10:21 <pesco> Pseudonym: I'll get back to you once I pick up Esperanto again. I took a few lessons a couple of years ago but somehow lost interest.
15:10:25 <ibid> Pseudonym: look at his name.  surely a man who shakes a spear can be nothing else but klingon!
15:10:29 <Oejet> ibid: Oh.  Misread.
15:10:42 <Pseudonym> Interestingly, Klingon doesn't have a word for jealousy.
15:10:50 <Pseudonym> Nick was mulling over that one for a while.
15:10:51 <ibid> Oejet: i've visited århus, thouhg
15:10:54 <Pseudonym> He came up with "I feel acid".
15:10:58 <ibid> heh
15:11:08 <ibid> i think okrand had a problem with hamlet's famous line
15:11:19 <ibid> s/think/believe/
15:11:30 <ibid> there is no "be" in klingon
15:11:34 <Pseudonym> I think the funniest bit, though, was the Bible translation project.
15:11:55 <Pseudonym> The project was like a full Christian theological argument in microcosm.
15:11:55 <pesco> I need to leave for bed. Nice talking to you all. See you later!
15:12:10 <Pseudonym> For example, consider translating "five loaves and two fish".
15:12:13 <ibid> Pseudonym: every time you say "nick" i immediately complete it with "meyer" :/
15:12:24 <Pseudonym> The literalists wanted to say "grain food" and "water animal".
15:12:34 <Pseudonym> But the dynamicists wanted to make it more relevant to Klingon culture.
15:12:41 <Pseudonym> "Blood pies" and "water serpents".
15:12:46 <Pseudonym> Very amusing.
15:12:50 <wilx> Hehe.
15:12:53 <ibid> Pseudonym: there's got to be two klingon christian churches at least, then? :)
15:13:05 <shapr> bd_: when you want a monads intro, I can give you one. Just ask me.
15:13:06 <Pseudonym> Definitely.
15:13:14 <Pseudonym> http://www.tlg.uci.edu/~opoudjis/ <- This is the guy's web site.
15:13:31 <Pseudonym> In fact... Nick tutored me in my first functional language!
15:13:34 <ibid> drink the flesh and blood of the christ
15:13:42 <ibid> that must be fun for klingons
15:13:57 <bd_> shapr: I've seen some of the monads intros, haskell.org or something under there has a list
15:14:01 <Pseudonym> So there!  He not only speaks Klingon, he also speaks Haskell.
15:14:30 <ibid> you people are too cool
15:14:41 * ibid feels diminished :)
15:15:24 <Pseudonym> No, HE is cool.  I'm not cool.
15:15:31 <Pseudonym> Unless coolness is contagious.
15:15:48 <ibid> you are cool for knowing too many cool persons :)
15:16:08 <Pseudonym> No, that's luck.
15:16:08 <ibid> and i didn't direct the comment solely at you, Pseudonym :)
15:16:12 <Pseudonym> Ah, good.
15:16:16 <shapr> bd_: have monads clicked for you yet?
15:16:24 <ibid> Pseudonym: "you people" :)
15:16:32 <bd_> shapr: Not quite. I get the idea, it's just the syntax I have to work with
15:16:50 <bd_> shapr: And maybe look into mixing a user-defined Monad with IO somehow
15:16:57 <ibid> bd_: sounds good. usually it's the other way around
15:17:10 * shapr doesn't know anybody who's cool.
15:17:18 <shapr> Wait, I know Pseudonym!
15:17:21 <bd_> It probably doesn't help I only skimmed the tutorials for basic syntax :P
15:17:23 * shapr boings cheerfully
15:17:24 <wagle> hey!
15:17:35 <shapr> wagle: you know cool people?
15:17:48 <ibid> if tuomas lukka is cool, i know somebody who's cool. otherwise unlikely
15:18:02 <ibid> (online familiarity does not count)
15:18:18 * Pseudonym knows shapr!
15:18:21 <Pseudonym> Woohoo!
15:18:34 <shapr> Oh, online familiarity does not count.
15:18:36 <shapr> Well then.
15:18:49 <Pseudonym> I had the desk next to Fergus.  Is that cool?
15:18:54 <shapr> that is cool!
15:18:55 <ibid> yes
15:19:01 <shapr> Fergus Henderson is definitely cool.
15:19:12 <Pseudonym> Or does the fact that he was rarely there, preferring to work at night, not count?
15:19:17 <shapr> haha
15:19:22 <ibid> my only hope is to become cool myself so others can become cool because they know me
15:19:25 <Pseudonym> He was there enough, I think.
15:19:29 <Pseudonym> Hey, I know ibid!
15:19:42 <Pseudonym> Actually, ibid, your writings seem to get cited a lot.
15:19:57 <Pseudonym> Alongside infra and supra.
15:19:58 <ibid> where?! :)
15:20:02 <ibid> ah, heh
15:20:06 <ibid> yeah, that
15:20:30 <ibid> i'm related to the world's most profilic author-composer, anonymous
15:20:32 <Pseudonym> As Terry Pratchett wrote: That's the problem with you, ibid.  You're such a bloody know-it-all.
15:20:38 <ibid> :)
15:20:54 <Pseudonym> Coming a close second in composers is Anon's brother, Trad.
15:20:58 <ibid> yeah
15:21:08 <ibid> though i though she was his sister
15:21:20 <ibid> +t
15:21:22 <Pseudonym> I've heard that theory.
15:21:29 <Pseudonym> I think the jury is still out.
15:21:53 <ibid> actually, i chose this nick precisely because of the academic connotation
15:22:05 <Pseudonym> :-)
15:22:29 <Pseudonym> You can guess why I picked Pseudonym.
15:22:39 <Pseudonym> I was reading Goedel, Escher, Bach in the late 80s.
15:22:49 <xerox> "in the late 80s" whoa.
15:22:52 <Pseudonym> So I picked something self-referential.
15:23:08 <ibid> at that time i was desperate to be known for my academic interests
15:23:15 <ibid> and i was tired of my earlier nicks :)
15:23:28 <shapr> xerox: how old are you?
15:23:36 <xerox> Nineteen
15:23:41 <ibid> i was in school in the late 80s
15:23:52 <ibid> geb would've been too rich for me then
15:24:07 <shapr> I got on the 'net in 88 or 89.
15:24:12 <ibid> i barely enjoyed myself reading about school algebra
15:24:19 * ibid in 1995
15:24:26 <wilx> Eh.
15:24:40 <wilx> Interesting...
15:24:42 <ibid> (no, don't say it. it's not an algebra of schools...)
15:24:57 <SamB> GEB doesn't have that much math in it, does it?
15:25:44 <Pseudonym> Not as such.
15:25:54 <Pseudonym> In the sense that you don't need to know any maths to enjoy it.
15:25:57 <Pseudonym> But it contains maths.
15:26:03 <ibid> last i tried to read it, it seemed to me to be a good idea but with too many factual and conceptual errors
15:26:21 <Pseudonym> I thought there were a lot of long bows in it.
15:26:30 <Pseudonym> But the fact that it was just plain fun to read made up for it.
15:26:45 <ibid> too subtle to be visible to somebody who wasn't well versed in logic
15:26:45 <musasabi> shapr: still killing a few bugs, but now things look quite good. (I located what I think is the last one and will solve it in the morning)
15:26:51 <musasabi> now sleep.
15:26:56 <shapr> yay
15:27:31 <ibid> i've heard people say that musicians say "the maths and the art is interesting but the music is a bit off", artists say "the maths and the music is interesting but the art is a bit off", and ... ...
15:28:28 <ibid> geb is certainly important in that it has introduced a lot of shared stories
15:29:07 * ibid should get to bed
15:29:47 <shapr> Shared stories have a surprising amount of importance.
15:30:00 <Pseudonym> Night.
15:30:02 <Pseudonym> Yes, I agree.
15:30:09 <Pseudonym> The thing is, it's a popular science work.
15:30:13 <Pseudonym> It's going to lie.
15:30:29 <Pseudonym> Education is one white lie after another.
15:30:37 <ibid> yeah
15:31:11 <shapr> I think it's the same thing as Haskell's Prelude, shared names for basic patterns.
15:31:16 <ibid> never let the truth keep you from telling a good story
15:31:39 <Pseudonym> They're cultural design patterns!
15:31:42 <Darius> Pseudonym: You may be stretching with "white" in some cases (at least in practice)
15:31:51 <Pseudonym> Perhaps in some cases.
15:32:05 <Pseudonym> But, for example, I don't think teaching Newtonian mechanics is a black lie.
15:32:24 <Darius> Die cross product! Die!
15:32:31 <Pseudonym> OK, THAT I agree with.
15:32:37 <adiabatic> Or drawings that show electrons in concentric circles.
15:32:47 <Pseudonym> Cross products struck me as dumb at the time, too.
15:32:59 <Pseudonym> You multiply a distance by a distance and you get... another distance?
15:33:21 <Darius> Pseudonym: When it comes to Physics, you (should) know everything is wrong and will be corrected later with another (hopefully) less wrong theory.
15:33:23 <adiabatic> Cross products are lies?
15:33:37 <Oejet> adiabatic: Yes, damn lies.
15:33:42 <shapr> How so?
15:33:42 <SamB> cross procucts aren't a theory, though
15:33:49 <Oejet> :-P
15:33:50 <ibid> Pseudonym: well, physicists are to mathematicians what mathematicians are to logicians :)
15:33:55 <SamB> they are a mathematical construct
15:34:01 <Darius> adiabatic: The cross product of two vectors is a different kind of vector.
15:34:06 * Pseudonym laughs
15:34:08 <adiabatic> ibid: that is, "utterly dependent on"?
15:34:26 <ibid> adiabatic: and "utterly laughed at by"
15:34:29 <Pseudonym> Cross products are like Newtonian mechanics.
15:34:32 <Pseudonym> Actually, no.
15:34:45 <Pseudonym> More like celestial spheres.
15:34:50 <Pseudonym> They served their purpose.
15:34:53 * Darius was always disturbed by them only working in 3D, it seemed inelegant.
15:35:05 <Pseudonym> They also work in 7D, for what it's worth.
15:35:31 <Pseudonym> I know this because I was personally corrected, with my name in the subject line and everything, by Pertti Lounesto.
15:35:31 <Darius> Pseudonym: Different formulations can work in different sets of dimensions, but none (that I know of) work in all.
15:35:31 <SamB> not much, from what I hear everything over 4D is rather boring
15:35:36 <ibid> there was this joke about a mathematician, a physicist and an engineer listening to an advanced lecture on some new physical multidimensional theory
15:35:39 <Pseudonym> And if you know who that is, you know why I mentioned it.
15:36:08 <ibid> i recognize the nationality of that name, nothing more :)
15:36:41 <adiabatic> ibid: are you going to tell the rest of the joke? ;)
15:36:47 <ibid> anyway, the physicist and the engineer chatted after the lecture and complained how hard the lecture was
15:36:47 <Pseudonym> OK, my name wasn't in the subject line.
15:36:50 <Pseudonym> http://groups.google.com.au/groups?selm=3A68C5D2.96449853%40pp.htv.fi
15:37:01 <ibid> the mathematician disagreed
15:37:17 <ibid> the physicist asked, how can you visualize a 14-dimensional object?
15:37:39 <ibid> easy, the mathematician said. i first imagined it in n-dimensional space, then took the special case.
15:37:51 <Pseudonym> http://www.kuro5hin.org/story/2002/8/11/155658/046 <- More on Lounesto
15:38:21 * Pseudonym laughs
15:38:24 <Pseudonym> I like that.
15:39:11 * ibid used to be an enthusiastic maths major. i think it still shows :)
15:39:19 * ibid collected a lot of maths jokes as freshman
15:40:32 <ibid> (1997)
15:43:15 <ibid> (it was freshman analysis that killed my enthusiasm; logic has reviwed it somewhat in recent years)
15:43:55 <Pseudonym> Actually, I'm getting more interested in analysis.
15:44:00 <Pseudonym> I think you have to understand it the right way.
15:44:14 <Pseudonym> Numeric analysts tend not to be propertheorists.
15:44:16 <djo> hi guys
15:44:29 <ibid> yeah, it wasn't so much the analysis itself but how it was taught
15:44:32 <Pseudonym> I think the field attracts the wrong people.
15:44:35 <Pseudonym> Like statistics.
15:45:00 <djo> Is it possible to compare 2 strings in haskell with "==" operator ?
15:45:03 <Pseudonym> I think it just goes to show that any field of human endeavour is interesting, once you get through the boring stuff at the start.
15:45:08 <Pseudonym> djo: Did you try it?
15:45:12 <Darius> What is the proper way to to understand it?
15:45:14 <djo> yes
15:45:15 <ibid> our maths department is a strong in analysis research
15:45:15 <Pseudonym> Hello, by the way.
15:45:21 <Pseudonym> And did it work?
15:45:24 <ibid> (not applied nor numerical but the real thing)
15:45:33 <djo> I have a compilation error
15:45:38 <Pseudonym> OK...
15:45:41 <Pseudonym> What is it?
15:45:42 <Oejet> @eval  "abe"=="kat"
15:45:43 <lambdabot> False
15:46:06 <Oejet> @eval "abe"++"kat"
15:46:06 <lambdabot> abekat
15:46:10 <Oejet> Yay!
15:46:18 <ibid> military service is mandatory to all able-bodied finnish males
15:46:22 <Pseudonym> #eval "cat" == "cat"
15:46:24 <Pseudonym> @eval "cat" == "cat"
15:46:25 <lambdabot> True
15:46:43 <ibid> but you can postpone it until you're around 28 or so, if you have a good reason
15:46:50 <adiabatic> shame I don't know "tell me the last digit of pi" in Haskell...
15:46:55 <ibid> like being a brilliant math student
15:46:57 <Oejet> ibid: All males?!
15:47:02 * Darius implemented (==) and (++) (?)
15:47:07 <ibid> Oejet: hm?
15:47:27 <jberg> even a male horse?
15:47:30 <ibid> one of the maths department's young doctors hit the deadline
15:47:34 <ibid> jberg: people
15:47:41 <jberg> oh :(
15:47:42 <Pseudonym> How about Neanderthal?
15:47:52 <Oejet> ibid: All male people?
15:47:52 <Pseudonym> djo: What's the error message?
15:48:00 <ibid> Pseudonym: if you know one, introduce me to him :)
15:48:12 <ibid> Oejet: yes, with some minority groups exempted
15:48:21 <Pseudonym> Such as...?
15:48:26 <Pseudonym> Gypsies?
15:48:43 <Oejet> ibid: That's like in Israel.  How about the women?
15:48:47 <ibid> actually, the only group is jehova's witnesses
15:49:07 <ibid> Oejet: voluntary until they take the military oath; after that they're in it like the males
15:49:25 <ibid> anyway, this young doctor went to the army
15:49:37 <ibid> ended up teaching cadets in the officer courses
15:49:42 <ibid> maths, of course
15:50:16 <ibid> when he was discharged i was just in the middle of my freshman course, and one of the most promising students they had then
15:50:18 <Pseudonym> OK, so conscientious objectors, pretty much.
15:50:32 <ibid> Pseudonym: conscientious objectors are a different group :)
15:50:36 * Oejet likes the huge chalks in the SICP lecture recordings.
15:50:37 <Pseudonym> i.e. people who are actually opposed to war in principle, rather than people opposed to being killed.
15:50:54 <ibid> this doctor wanted to create an "advanced" class for analysis 2
15:51:26 <ibid> it got reduced to a "advanced" study group associated with the normal course
15:51:32 <ibid> i, of course, was one of the students
15:51:54 <ibid> he tried to show us stuff like peano's curve etc
15:52:00 <ibid> way over our head
15:52:25 <ibid> it turned out that one of the other students in the group was a recently discharged voluntary woman
15:52:57 <ibid> so, after he got fed up with our heavy heads, half of the time he chatted with her (it was sort of fun to listen:)
15:53:11 <ibid> and the other half of the time we did the standard study group exercises
15:53:30 <ibid> every so often, he would end chatting by shouting "INTEGRATE!"
15:53:39 <ibid> that *totally* killed my maths career
15:54:21 <Oejet> ibid: You have my sympathy.
15:54:31 <ibid> thanks
15:54:32 <Pseudonym> Defintiely.
15:54:50 <Pseudonym> That's kinda sad.
15:55:03 <ibid> i floated around for a couple of years and ended up in the software engineering line doing my masters on formal methods
15:55:27 <ibid> and a temporary staff position in the department :)
15:55:44 * ibid is still on that road, though the thesis was completed in dec 2002 :)
15:58:30 * Darius figured out the Ctrl+T problem.
15:59:05 <ibid> Pseudonym: finland offers conscientious objectors the choice between a very long non-military service or six months in prison
15:59:34 <Pseudonym> How long?
15:59:37 <Pseudonym> Compared with service?
15:59:44 <Pseudonym> (And compared with prison, I guess.)
15:59:57 <ibid> Pseudonym: finland is constantly in amnesty's list of countries that keep prisoners of conscience
16:00:04 <ibid> because of that
16:00:05 * Pseudonym nods
16:00:16 <Pseudonym> Requiring non-military service isn't a bad idea.
16:00:26 <Pseudonym> But if it's longer tha military service, that's wrong.
16:00:34 <ibid> Pseudonym: military service is minimum 6 months, it's i believe over 12 months in the non-military service
16:00:39 * Pseudonym nods
16:00:42 <Pseudonym> That's wrong.
16:00:54 <Pseudonym> There is a simple fix, though.
16:01:04 <Pseudonym> Make yourself so useful that they won't want to give you a gun.
16:01:11 <Pseudonym> e.g. get a job for a defence contractor
16:01:16 <ibid> ncos and reserve officer candidates have longer service, of course
16:01:44 <ibid> the truly bizarre part is that jehova's witnesses are totally exempted
16:01:48 <Pseudonym> That is bizarre.
16:01:52 <ibid> as i said
16:01:53 <Pseudonym> I guess 12 months isn't so long.
16:02:04 <Pseudonym> The military service is that long in some countries.
16:02:10 <ibid> sure
16:02:24 <Pseudonym> It's the inequity that's the problem, IMO.
16:02:29 <ibid> it's the difference that makes it punitive in amnesty's eyes
16:02:57 * ibid is, fortunately, exempted in peacetime due to disability
16:03:18 <Pseudonym> Ah, that's good.
16:03:31 <Pseudonym> What about someone like me, who is merely overweight and unfit?
16:03:50 <ibid> Pseudonym: my father was like that and he did the regular nco tour
16:03:53 <Pseudonym> And is also a smartarse who can't adapt to military life?
16:04:19 <ibid> well, that can get you discharged early if it's bad enough
16:04:33 <Pseudonym> Well I'm not deliberately so.
16:04:45 <ibid> it's not about deliberateness
16:04:49 <Pseudonym> Like most geeks, I call bullshit on what I believe is bullshit.
16:04:56 <adiabatic> What can you do in the military for a year, though?
16:05:00 <Pseudonym> And the millitary is full of bullshit.
16:05:02 <ibid> it's basically whether they'd rather declare you insane :)
16:05:23 <ibid> insane people get a full exemption
16:05:23 <wagle> i thought basic training was 3 months?
16:05:45 <ibid> people like me are exempted only in peacetime
16:05:54 <Pseudonym> I know of programmers who ended up working on flight simulators for the Finnish air force.
16:06:11 <Pseudonym> That happened to a couple of members of Future Crew, I think.
16:06:16 <ibid> wagle: no idea
16:06:28 <adiabatic> So, um, what does the Finnish military _do_?
16:06:29 <SamB> they probably don't get rid of everyone who is insane
16:06:50 <Pseudonym> adiabatic: The same as everyone else's.
16:06:52 <ibid> one of my fellow students did the military service as a flautist
16:06:55 <SamB> militate
16:07:03 <ibid> adiabatic: it's the defense force
16:07:06 <Pseudonym> I'd think they do border patrol and UN/NATO expeditions.
16:07:19 <ibid> adiabatic: i believe the basic doctrine is to make potential agressors think twice about the cost
16:07:48 <Pseudonym> Right.
16:07:48 <Pseudonym> To get peace you must prepare for war.
16:07:48 <Pseudonym> THey do a lot of preparing.
16:07:48 <ibid> i believe most finnish troops are trained in guerilla warfare
16:07:48 <adiabatic> Who'd want to invade Finland, though?
16:07:53 <SamB> ibid: not a bad idea
16:08:00 <ibid> adiabatic: russia has tried that
16:08:04 <kaol> I believe most Finnish troops would be useless in combat
16:08:23 * ibid has no comment on that :)
16:08:30 <Pseudonym> The other thing is, part of being the UN and/or NATO is that you need to be able to provide troops to provide collective security.
16:08:40 <ibid> finland is not NATO
16:08:43 <Pseudonym> If someone is invaded, you're supposed to help them.
16:08:44 <Pseudonym> Ah, OK.
16:08:47 <Pseudonym> Even so, it is UN.
16:08:56 <adiabatic> ibid: But is Finland _in_ NATO?
16:09:04 <ibid> though it's likely that we will join within the next ten years
16:09:08 * Pseudonym nods
16:09:12 <ibid> adiabatic: no, just a "partner in peace"
16:09:17 <Pseudonym> Did Finland send troops to Afghanistan?
16:09:20 <Pseudonym> Or Somalia?
16:09:30 <ibid> Pseudonym: finland does only peacekeeping ops
16:09:33 * Pseudonym nods
16:10:01 <Pseudonym> Australia _theoretically_ does only border patrol and peacekeeping/peace enforcement.
16:10:06 <Pseudonym> Apart from that Iraq thing.
16:10:16 <ibid> we did not participate in the afganistan invasion, if that's what you're asking
16:10:17 <Pseudonym> But let's not get into that.
16:10:21 <Pseudonym> I was curious about it.
16:10:31 <Pseudonym> Because it was a UN operation.
16:10:35 <Pseudonym> In theory, anyway.
16:10:37 <ibid> i don't know if there have been peacekeeping forces in afganistan later on
16:10:50 <ibid> Pseudonym: the finnish law is fairly strict about it
16:10:54 <adiabatic> I think Canada's still in Afghanistan keeping things clean.
16:11:40 <ibid> Pseudonym: has to do with the fact that finland a) was in the losing side in wwii and b) had to be very careful not to provoke either super power during the cold war
16:11:53 <ibid> we're slowly getting off that mentality
16:11:56 <ibid> slowly
16:12:19 <Pseudonym> Interesting.
16:12:47 <ibid> thus, the policy of neutrality
16:13:05 <ibid> "we're not the police of the world, we are its doctors" or something like that
16:13:33 <ibid> finland had some notable successes in mediating
16:14:47 <Oejet> ibid: Did Finland really loose in WWII?  Denmark was on the winning side, fortunately.
16:15:17 <shapr> Can anyone here explain how to use QuickCheckM to me?
16:15:30 <ibid> Oejet: finland got a negotiated peace separately from germany and its allies
16:15:40 <ibid> Oejet: but yes, in the losing side
16:15:40 <shapr> I'd like to create a side-effecty property to test GHC's math against something like dc or bc
16:16:07 <ibid> Oejet: it's a well-known fact that finland was at least in some respects an ally of germany
16:16:33 <ibid> though, as i indicated, not as closely as say italy
16:16:35 <shapr> Pseudonym: have you tried QuickCheckM?
16:17:20 <shapr> It would be nice to switch all my HUnit assertM tests to QuickCheck.
16:18:07 <ibid> Oejet: finland lost a lot of land in the settlement, as well as was forbidden to have any offensive armed forces
16:18:18 <ibid> for example, submarines were forbidden
16:18:24 <kaol> Finland didn't get annexed to Soviet Union, which IMHO counts as a victory of a sort, considering the situation.
16:18:42 <shapr> hei kaol
16:19:00 <kaol> hej shapr
16:19:50 * shapr advertises for QuickCheckM assistance
16:19:52 <ibid> (in 1990 or so finland unilaterally dissolved those parts of the peace treaty that did not have to do with borders)
16:20:11 <shapr> should be straightforward to create something as simple as a test that compares dc output to ghc output.
16:20:43 <shapr> hm these specifications closely resemble z-schemas.
16:21:03 <ibid> kaol: hence the finnish expression "torjuntavoitto" 'a rebuff victory'
16:21:41 <Oejet> ibid: Of allies to Germany I reckon:  Italy > Finland > Denmark > France.
16:21:51 <ibid> kaol: but it is clear that the soviet union had the upper hand even in the peace treaty negotiations
16:22:01 <ibid> Oejet: france was conquered, not an ally, right?
16:22:20 <Oejet> Indeed, and Denmark was occupied.
16:22:44 <ibid> yeah
16:22:53 <Pseudonym> shapr: Nope, never tried it.
16:22:57 <shapr> fooey
16:23:28 <ibid> i think i was going to bed an hour ago
16:23:29 <shapr> I guess I could create a MathExpression type and make it an instance of arbitrary.
16:23:33 <ibid> see you all later :)
16:24:28 <shingoki> I asked in here yesterday if haskell supported OO, but I just read the stuff about classes... so it seems like you can get pretty much all the advantages of OO that way
16:24:35 <shingoki> or am I looking at that wrongly?
16:24:48 <shapr> typeclasses really aren't OO, but they can do some of the same stuff.
16:25:01 <shapr> In my opinion, monads are closer to OO.
16:25:17 <SamB> what are monads with typeclasses?
16:25:25 <SamB> s/with/without
16:25:26 <shapr> Except there's more than OO in monads.
16:25:36 <shingoki> i have to look at monads
16:25:47 <Pseudonym> It's hard to say.
16:25:52 <shapr> OOP is about combining code with given semantics, but monads let you define whatever semantics you want for combining code.
16:25:55 <TheHunter> shapr, iirc, you can't have QuickCheckM tests for the IO monad.
16:25:56 <Pseudonym> Arguably, Erlang provides better OO than even Java does.
16:25:58 <shingoki> but at the least, classes seem to let you define an interface that can then be implemented different ways
16:26:04 <shapr> TheHunter: whaat?
16:26:08 <shingoki> yeah but erlang seems to have other issues
16:26:11 <Pseudonym> Though it doesn't have objects in its type system.
16:26:33 <TheHunter>   , monadic 	  -- :: Monad a => (a Property -> Property) -> PropertyM a b -> Property
16:26:36 <shapr> shingoki: yes, but that's just polymorphism
16:26:48 <TheHunter> shapr, that's the only way to get rid of a PropertyM.
16:26:50 <shingoki> yes, but it's something I've always associated with OO
16:26:56 <Pseudonym> Haskell has that, but you have to jump through hoops to get mutable local state.
16:27:08 <shingoki> the mutability thing is what is really hurting my head
16:27:31 <Pseudonym> That's good.  It means you're unlearning.
16:27:38 <shingoki> I mean in Java I very often use immutable objects since they are less prone to errors, but I can't quite see how you can do without any mutability
16:27:40 <TheHunter> well, you can of course write "monadic unsafePerformIO"...
16:27:40 <Darius> shingoki: OOHaskell and some papers on Feature-Oriented programming cover emulating OO in Haskell and using monads for OO respectively.
16:28:22 <shapr> with shadowing and GC, you have what is effectively mutability.
16:28:34 <shapr> mylength [] = 0
16:28:47 <shapr> mylength (x:xs) = 1 + mylength xs
16:29:27 <shingoki> hm
16:29:40 <shapr> the garbage collector can tell when data is no longer reachable, and that data just vanishes into the ether.
16:29:47 <shingoki> Yeah I understand that, from Java
16:29:57 <jyasskin> TheHunter: unsafePerformIO is probably even safe if all it's doing is checking some output from dc
16:30:04 <shingoki> the thing is, say you have GUI stuff, like a view of some data
16:30:22 <shingoki> unless it is possible to change the data the view is looking at, somehow, I can't see how you can update the data
16:30:42 <shingoki> You can make say a new list that contains what you want, but then the view is still looking at the old list
16:30:54 <shingoki> so you make the ciew look at the new list, but it is immutable, so you can't
16:31:18 <shingoki> at some point, you need to either change something, or completely reconstruct the entire graph of objects
16:31:26 <shapr> that's an excellent point :-)
16:31:28 <shapr> well spotted
16:31:35 <shingoki> well I know I'm missing something ;)
16:31:40 <shingoki> I just don't know what ;P
16:32:01 <shapr> once you learn about monads, you'll hit IORef, and then you'll that most of the commonly used GUI stuff in Haskell does use cheesy mutable variables.
16:32:08 <shapr> But it's not required :-)
16:32:18 <shingoki> right
16:32:22 <Darius> shingoki: You only need to reconstruct the parts that change and some GUI libraries seem to work along those lines (currently).  And of course, there's always the IO monad.
16:32:23 <shapr> There's some *really* cool stuff that gets past that.
16:32:37 <Pseudonym> Like most things in programming, there's no problem you can't solve by adding a layer of indirection.
16:32:41 <Pseudonym> IORef is but one way to do that.
16:32:50 <shapr> Once you've got monads in your head, check out arrows, and then check Fruit. Fruit r0xx0rs.
16:33:01 <shingoki> This is something I have thought about a lot in Java, but I haven't got to monads yet :)
16:33:22 <Pseudonym> And once you've got your head, arrows and fruit, you can play William Tell.  Just make sure you have a willing participant.
16:33:35 <shingoki> lol
16:33:53 <shingoki> ocaml, erlang, haskell... got to choose one :)
16:34:01 <Darius> shingoki: Why?
16:34:07 <Pseudonym> They're all worth learning.
16:34:10 <shingoki> well, at lesat I have to choose one to learn first
16:34:14 <Pseudonym> But of those three, I'd look at Haskell in the most depth.
16:34:17 <shingoki> and I don't have unlimited time
16:34:32 <shingoki> well so far I love the haskell type and class system
16:34:33 <shapr> Learning is my goal, so this is fun time for me.
16:34:43 <shingoki> well yeah im enjoying it a lot
16:34:54 <shingoki> but I also have a few projects I actually want to get somewhere with
16:34:58 <Darius> shingoki: You should be able to get a feel for all three of those languages in certainly less than 2 months.
16:35:06 <xerox> shapr: suggest me some interesting documentation! I finished the haskell-tutorial while ago :D
16:35:15 <shingoki> so at some point I have to stop learning the basics and actually use the lanugage to make something non trivial :)
16:35:16 <Pseudonym> Once you've mastered one, getting the idea of the other two shouldn't take long.
16:35:20 <shapr> xerox: now it's time to code!
16:35:27 <shingoki> Yeah I got the impression there are a lot of similarities
16:35:31 <Pseudonym> And by "mastered", I don't mean "seriously mastered".
16:35:36 <xerox> shapr: you're right. So what I need is an idea.
16:35:43 <shingoki> just because I am lazy - is the ocaml type system anywhere near as nice as the haskell one?
16:35:53 <shingoki> I love the thing with classes, they seem like the good bits of OO
16:35:54 * Darius wishes Sylpheed-Claws was developed by Windows programmers so it'd be more grabby about being the default application... like Outlook Express *sigh*
16:35:57 <shapr> xerox: find a program that you would want to use on a daily basis, write it in Haskell.
16:36:13 <shapr> xerox: find a way to automate your daily work. Is there something that you do manually that a program could do instead?
16:36:27 <shingoki> probably a bad choice for a first project in a new language, but I want to right some 3d modelling stuff
16:36:42 <shingoki> seems like a functional language may be reasonably well suited to that
16:36:44 <shingoki> I hope :)
16:36:57 <Darius> shingoki: The basic underlying type system (Hindley-Milner) is the same, but Haskell has type classes and OCaml has applicative functors and objects.
16:37:17 <Pseudonym> shingoki: Type classes are a lot more powerful than OO.
16:37:28 <Pseudonym> Two reasons.
16:37:35 <shingoki> the thing is, I can see that with immutable "objects", classes seem to get me everything that normal OO does, and more
16:37:37 <xerox> shapr: I should think about it..
16:37:50 <shapr> TheHunter: are you sure there's no way to do IO stuff with QCm?
16:37:51 <shingoki> but I can't see how to apply immutable classes well to everything, particularly like that GUI stuff
16:37:52 <Pseudonym> 1) You can add an instance after the event.  You don't have to do it in the place where you declare the type.
16:37:55 <Darius> shingoki: With regards to nice, one of the notable issues with OCaml is that surprisingly many people find its syntax horrid.
16:38:09 <Pseudonym> 2) You can define classes which work on more than one type (using multi-parameter type classes).
16:38:13 <shingoki> yeah I didn't much like the ocaml syntax, but I think I can cope
16:38:25 <Pseudonym> THere's only one drawback to type classes, and that's that the vtable is not part of the type.
16:38:36 <shapr> Is there any difference between mptc and multiple dispatch?
16:38:36 <shingoki> Pseudonym, as in table of fields?
16:38:45 <Pseudonym> As in table of virtual fucntions.
16:38:49 <Darius> shapr: Yes.
16:39:05 <shapr> TheHunter: that would really suck if there's no way to use QCm for testing external inputs :-(
16:39:15 <TheHunter> shapr, pretty much, yes. PropertyM is abstract.
16:39:25 <shingoki> Pseudonym, but you still have the necessary guarantee that something of some type will be suitable for some function
16:39:55 <shingoki> what else would you want?
16:40:09 <shingoki> (I'm really asking that, not rhetorical)
16:40:36 <Pseudonym> Basically, what bundled vtables get you is the ability to downcast.
16:40:53 <Pseudonym> class Derived : inherits from Base
16:41:06 <Pseudonym> If you have a Base, you can downcast to a Derived.
16:41:19 <Pseudonym> The cast may fail, of course.
16:41:24 <TheHunter> shapr, but the unsafePerformIO hack doesn't seem to be that bad
16:41:27 <Pseudonym> With Haskell typeclasses, you can't do that.
16:41:48 <shingoki> Pseudonym, but then its not something you should have to is it? I mean if you require a derived, then specify one
16:42:03 <shapr> TheHunter: I'm a purist.. do you see any possibility to do it right?
16:42:06 <Pseudonym> Well, you never _have_ to.
16:42:13 <Pseudonym> But OO programmers find it terribly convenient.
16:42:30 <Pseudonym> Really pure OO programmers would say "use a visitor".
16:42:31 <shingoki> Whenever I find myself doing that I tend to think I have made a mistake
16:42:39 <Pseudonym> Right.
16:42:45 * shapr takes a stick to QCm
16:42:46 <Pseudonym> Which is sometimes true.
16:42:51 <shingoki> I mean yeah, you can write something that will have "special" behaviour for sepcial classes
16:42:53 <Pseudonym> OTOH, sometimes you have no choice,
16:42:55 <shingoki> but its not that nice
16:43:08 <Pseudonym> The code you have to deal with was written by someone else, and you don't have the funding to rearchitect it.
16:43:21 <shingoki> that said though, I got the impression that you could reimplement a function on the subclass, to include that special handling?
16:43:26 <TheHunter> shapr, you'd have to change the QuickCheckM source. Monadify check, Property, etc.
16:43:35 <Pseudonym> Yes, there are a number of tricks that you can do.
16:43:45 <Pseudonym> But it's still terribly convenient.
16:43:57 <shingoki> well that doesn't seem like a trick, more like just overriding a method in a subclass, as you would in java
16:44:00 <Pseudonym> Having said that, in Haskell, there's an even smaller argument for it.
16:44:02 <shingoki> but here you are
16:44:08 <shingoki> oops mistype
16:44:14 <shapr> what about :: PropertyM IO Int ?
16:44:17 <Pseudonym> Because most uses of it are caused by people implementing algebraic data types, which are native in Haskell.
16:44:48 <Pseudonym> So in Haskell specifically, you don't lose a huge deal.
16:45:12 <TheHunter> shapr, you can't really check a PropertyM IO Int right now.
16:45:54 <TheHunter> if you did all that monadifying, i'm pretty confident the semantics would be reasonable close to the unsafePerform-Hack version (But I might be overlooking something).
16:47:50 <TheHunter> ok, one thing I have overlooked already is that evaluate something different than Control.Exception.evaluate...
16:50:31 * shapr tries to do an IO version of  "prop_Add x y = x + y == y + x"
16:51:08 <shapr> something as simple as reading two numbers inside the propertie and then checking the property maybe...
16:52:32 <shingoki> so... am I being stupid to think that you can make a class that specifies that you have input and output functions to change a value, and get something a little like an object with properties?
16:52:43 <shingoki> I mean is that just "nasty" or actually impossible?
16:53:15 <Lemmih> Good morning, #haskell.
16:53:20 <shapr> You can't change a value in the original 'object' you'd have to pass back a newly created object with different values.
16:53:30 <shapr> shingoki: at which point, you're looking at monads.
16:53:59 <shapr> Monads are *really* simple. three ingredients, and two obvious laws.
16:54:55 <SamB> the hardest thing about monads is explaining what they are
16:55:00 <shapr> ingredient one, a partially filled in type, ingredient two, a function that fills in that type with a value, ingredient three, a function that puts together two of those containers and gives you back a new container.
16:55:25 <Pseudonym> Monads are easier to use than they are to explain.
16:55:43 <SamB> Pseudonym: yes, exactly
16:55:45 <shapr> and one of the the obvious laws is that (a >>= b) >>= c must be the same as a >>= (b >>= c)
16:55:57 <shapr> the other one is ...
16:56:00 <TheHunter> ahh, PropertyM m =~= ContT Property (GenT m)
16:56:02 <shapr> um, id I think
16:56:10 <shapr> TheHunter: what? you found something that might do it?
16:56:10 * shapr bounces
16:56:32 <TheHunter> nah, I just understood how PropertyM works.
16:56:33 <shapr> ich verstehe night
16:56:37 <shapr> um nicht
16:56:49 <shapr> Man, my german is only slightly better than my finnish or my dutch.
16:56:54 <shingoki> ok... but can you achieve the effect that x references y, and you "change" y in such a way that x will see that change?
16:56:58 <shingoki> if that makes sense
16:57:10 <shapr> shingoki: how do you do that?
16:57:17 <shingoki> well
16:57:44 <shingoki> I mean if y is mutable, and x has a reference to it, then changing y will lead to you seeing the change when you look at y "from" x
16:57:50 <shapr> TheHunter: does that mean you see how to test against bc or dc?
16:58:02 <shingoki> if y is immutable and is recreated instead of changed, then x will still see the old instance of y
16:58:09 <shingoki> unless you also recreate x
16:58:13 <shingoki> just like I was saying earlier
16:58:16 <shapr> that makes sense.
16:58:19 <TheHunter> if you want to do it right, I think you'll have to go all the way defining a TestableM class and then define checkM, monadicM etc.
16:59:05 <shingoki> You know it seems like you really need some UI designed for this stuff specifically :)
16:59:06 <TheHunter> the thing is probably called DRAFT because it doesn't do that kind of stuff.
16:59:10 <shingoki> I'm sure it could be done
16:59:19 <humasect> look at .Object I/O
16:59:33 <shapr> it's been a draft forever.
16:59:43 <shingoki> humasect, okee dokee where do I look that up? ;)
17:00:00 <humasect> it is bundled with windows GHC. should be part of the package (and included html docs)
17:01:03 <shingoki> ill have a look for docs, I'm on debian, I'm pretty sure I got them, but I don't know where they are
17:01:07 <TheHunter> well, apart from the IO thing there are some obvious issues in there: "variant v (Gen m) = Gen (\n r -> m n (rands r !! (v+1)))", "fmap f m = m >>= return . f"
17:01:54 <humasect> http://www.nomaware.com/monads/html/
17:02:17 * shapr grumbles
17:02:35 <shapr> George Lucas is faster than this!
17:02:41 <shapr> ok, maybe that was unfair...
17:03:02 <shapr> George Lucas isn't really faster than the QuickCheck authors.
17:03:48 <TheHunter> if you don't wanna go through all that trouble, i'm still advertising the unsafePerformIO hack, because the unsafe side effects are done exactly at the right moment.
17:03:52 <shapr> I'm just grumpy because I have a cold.
17:04:49 <shapr> believe it or not, I've never used unsafePerformIO.
17:05:11 <TheHunter> however, i consider that variant thing more as a "bug" in the Random library, as there's no way to increase the "entropy" of a StdGen
17:05:40 <shapr> I could submit a patch, if I can figure it out. I patched the first quickcheck.
17:05:44 * xerox is enjoyng Vital
17:05:59 <TheHunter> not even the in thing that is usually called "the unsafePerformIO hack"?
17:08:09 * TheHunter wanted to await QC2 before complaining about QC1...
17:10:32 <xerox> Goodnight folks.
17:11:05 <TheHunter> 'night xerox
17:11:13 <shapr> g'night xerox
17:11:31 <shapr> I have never used unsafePerformIO in my own code, not at all.
17:11:52 <shapr> I wanted to await QC2 also, but Koen said it'll probably be another season or two at least.
17:12:03 <shapr> lemme check the exact wording of the email...
17:13:34 <shapr> he says that he has stalled the development of QuickCheck2 for a while.
17:15:58 <Pseudonym> I've used it in precisely one circumstance.
17:16:14 <Pseudonym> {-# NOINLINE myRef #-}
17:16:18 <Pseudonym> myRef :: IORef Foo
17:16:27 <Pseudonym> myRef = unsafePerformIO (newIORef Foo)
17:16:28 <autrijus> oh no, global variable thing :)
17:16:38 <Pseudonym> That's all.
17:16:47 <Pseudonym> Unfortunately, I don't think there's a better solution at the moment.
17:16:58 <autrijus> readerT ?
17:17:08 <autrijus> (I just ReaderT exclusively for that)
17:17:16 <Darius> @eval S I I (S I I)
17:17:20 <autrijus> ReaderT + IORef, to be specific.
17:17:21 <Pseudonym> Yeah, but it can break modularity.
17:17:29 <lambdabot> out of fuel - use @resume to continue
17:17:30 <autrijus> how so?
17:17:49 <TheHunter> ReaderT (IORef a) is such an overkill.
17:17:54 <autrijus> you are already under IO monad anyway if you use myRef
17:18:01 <Pseudonym> http://cvs.sourceforge.net/viewcvs.py/hfl/hfl/ioext/IOGlobal.hs?rev=1.4&view=auto
17:18:03 <autrijus> so just make it ReaderT (struct)
17:18:08 <Pseudonym> That, for example.
17:18:54 <Pseudonym> The IORef is local to the module, and it doesn't leak out.
17:19:00 <Pseudonym> Leaking it out would break the modularity of this module.
17:19:11 <Pseudonym> Because it's module-private data.
17:19:23 <Pseudonym> We DEFINTIELY don't want callers messing with it.
17:22:36 <autrijus> point taken. good point. for your use it seems it's unavoidable.
17:25:52 <Oejet> Lemmih: Are you still in SuccGMT, or is you day rythm screwed?
17:26:32 <TheHunter> good night, everyone.
17:28:37 <shingoki> grrr... monad.... head exploding
17:29:32 <stepcut> hehe
17:29:36 <Oejet> shingoki: Don't worry, you'll get to keep the pieces. :-P
17:30:42 <shingoki> so a monad... is a wrapepr for the result of doing something, where there are functions for wrapping a result in that wrapper, and for taking a wrapped result, and passing it through some other function which wraps results the same way, to give ANOTHER wrapped result?
17:32:07 <shingoki> I actually think I understand that, but I still don't see what it has to do with mutability:) More reading...
17:33:41 <Lemmih> Oejet: Still in SuccGMT and my day rhythm is screwed.
17:35:38 <Oejet> Lemmih: Mine will be too, if I don't hit the matress soon.
17:37:18 * Lemmih smiles at the guys who proposed a new package system.
17:39:21 <Oejet> How do I vote on http://sequence.complete.org/node/23 ?
17:40:56 <Darius> shingoki: Well one thing is that monads are not used just for dealing with mutability.
17:51:57 <hellish> is there a way to hide the "dumb" constructor I introduced with newtype?
17:52:20 <hellish> I have other ones which check for data saneness
17:52:40 <autrijus> that'd be amount to subtyping and I don't think haskell does that.
17:53:09 <dons> hide?
17:53:36 <hellish> Force it to be accesible only through the "smart" constructors.
17:54:10 <hellish> like a private constructor in OO
17:54:18 <shingoki> Is that something you do with modules?
17:54:46 <hellish> HS newbie, so no idea.
17:55:38 <dons> usually you just export the type abstractly when playing with smart constructors
17:55:52 <dons> module M ( T ) where .. instead of module M ( T(..) ) where ..
17:55:58 <dons> so the constructors are not visible
17:56:31 <hellish> okay then.
17:56:31 <dons> I guess that's what you're after?
17:57:00 <autrijus> oh ok. I misunderstood the question.
17:57:14 <autrijus> dons: so, is there a snapshot of hsplugin2 that works with ghc6.4 that I can try out?
17:57:21 <autrijus> dons: or should I just use existing hsplugin code?
17:57:37 <dons> if you want  to use 6.4, you need to grab the nightly cvs snapshot
17:57:49 <dons> there's a link to these snapshots on the hs-plugins download page.
17:57:50 <autrijus> where is the cvs co path?
17:57:58 <autrijus> oh ok. does the code work for both 6.4 and 6.2
17:58:00 <dons> it's not a co, it's just a tarball.
17:58:02 <autrijus> or is it now 6.4 specific?
17:58:07 <dons> no, it works with both.
17:58:09 <dons> cpp!
17:58:12 <autrijus> you are amazing.
17:58:48 <dons> nah, you just have to #if __GLASGOW_HASKELL__ < 604 in both imports lists, and package.conf files, and somtimes write mappings, e.g from Data.FiniteMap -> Data.Map
17:58:58 <dons> and deal with the occasional api change
17:59:04 <dons> but it's mostly mechanical
17:59:07 <autrijus> mappings?
17:59:32 <dons> i.e.
17:59:58 <dons> #if __GLASGOW_HASKELL__ < 604
17:59:58 <dons> import Data.FiniteMap
17:59:58 <dons> #else
17:59:58 <dons> import qualified Data.Map as M
17:59:58 <dons> --
18:00:00 <dons> -- and map Data.Map terms to FiniteMap terms
18:00:03 <dons> --
18:00:05 <dons> type FiniteMap k e = M.Map k e
18:00:06 <autrijus> ahhhhh.
18:00:07 <dons> emptyFM :: FiniteMap key elt
18:00:09 <autrijus> I want that.
18:00:10 <dons> emptyFM   = M.empty
18:00:31 <dons> yeah, so you could snoop around in hs-plugins src/* for hints
18:00:35 <autrijus> except it's gpl :)
18:00:44 <dons> yeah.
18:00:45 * autrijus goes for a rewrite
18:00:51 <autrijus> but thanks!
18:00:56 <dons> ok!
18:01:00 * dons goes to teach
18:01:03 <autrijus> guess I'll do this separate dependency on hs-plugins then
18:01:06 <autrijus> just like readlines
18:06:52 <shingoki> if a type has an IORef in it, and is in a class, is it pretty much like a mutable "object" in some OO language like say Java?
18:07:46 <Darius> shingoki: No.
18:07:58 <shingoki> right
18:08:29 <shingoki> why?
18:09:34 <shingoki> I mean, you can have a piece of data, wher eyou know you can use it with a certain set of functions, and you can change it
18:09:37 <Lemmih> shingoki: Type classes aren't like classes in most OO languages.
18:09:41 <shingoki> ah yeah
18:09:47 <Darius> Type classes do not allow dynamic dispatch nor does subtyping work the same.  Further, ignoring subtyping, you could just stick an IORef in a record.
18:10:19 <shingoki> but an IORef will act as a value that can be used in functions etc., but can be changed?
18:10:48 <shingoki> or at least somewhere to get/put values
18:10:56 <Darius> Yes within the IO monad.
18:11:41 <shingoki> I'm still trying to work out what that means, "within the IO monad"
18:12:23 <shingoki> as in, using "do" with IO monad stuff?
18:12:32 <humasect> it is a container of space ?
18:12:56 <Darius> There is no function, IO a -> a.  read/writeIORef :: ... -> IO X
18:13:26 <shingoki> yup
18:13:36 <Darius> Admittedly, the terminology "within the IO monad" isn't very accurate, but the intent is pretty clear.
18:13:50 <shingoki> but you could have an entire set of code where everything -> IO a
18:14:10 <shingoki> hence breaking the whole concept, but still :)
18:14:41 <Darius> shingoki: Even if lifted everything to IO, it would not break the concept.
18:15:17 <Darius> Using the IO monad is still more explicit than using IO in a typical imperative language.
18:15:41 <shingoki> I'm just struggling to see how to get haskell to do something I would actually want to do :)
18:15:49 <shingoki> maybe it is just the wrong language for me :)
18:15:57 <humasect> starting with a modeler ?
18:16:04 <shingoki> yeah
18:16:07 <humasect> well, checking out
18:16:08 <humasect> ok
18:16:47 <humasect> games or video ?
18:17:35 <shingoki> A general 3d modeller, for producing polygon meshes, rendering etc.
18:17:42 <humasect> k
18:17:43 <shingoki> Just something to move polygons about would be the first thing
18:18:07 <humasect> haskell is nice for 3d work
18:18:25 <humasect> haven't had the chance with guis though.
18:19:56 <Darius> shingoki: There's HOpenGL and someone is translating the NeHe OpenGL tutorials to Haskell which should provide (further) examples as well as comparison with imperative equivalents.
18:20:06 <shingoki> Yup the gl stuff seems fine
18:20:23 <shingoki> Just got to work out how to do a GUI that would actually work
18:21:08 <humasect> ..with or without opengl ? (in the api)
18:21:34 <Darius> wxHaskell should be able to do that
18:21:48 <humasect> yeap. not sure about gtk2hs
18:22:24 <shingoki> apparently opengl works within gtk stuff
18:22:35 <shingoki> I mean, given the relevant bits of haskell wrapper
18:23:44 <humasect> i was looking for where to start a similar application
18:24:24 <shingoki> I think I should go for learning more haskell :)
18:24:35 <shingoki> but even what I've seen has scared the crap out of me :)
18:24:44 <humasect> ;) that is a good thing
18:24:48 <shingoki> looks nice but very different, and some tuff I am used to being easy looks hard
18:24:53 <shingoki> as well as the other way around
18:25:01 <humasect> it's a nice contrast isn't it =)
18:25:29 <humasect> you could probably learn haskell while developing this modeler.
18:27:30 <shingoki> that's what I was thinking
18:27:38 <shingoki> well I'll keep looking, pretty late here now
18:27:43 <shingoki> thanks for help though :)
18:27:44 <humasect> good luck
18:27:47 <shingoki> thanks
18:38:53 <Lemmih> Anyone got a RSA implementation distributed under a BSD style license?
18:40:21 <Darius> There are a couple crpytographic libraries.  I'm not sure which of them has an RSA implementation nor if there is one that also has a BSD style license.
18:50:06 <autrijus> ghc-pkg: plugins.conf.inplace: parse error in package config file
18:50:13 <autrijus> hrm. (hs-lugins 20050322)
18:52:00 <Lemmih> autrijus: Say hello to the backwards incompatible Cabal. (:
18:52:23 <autrijus> I thought only CPAN had that problem :p
18:53:10 <Lemmih> Cabalize hs-plugins and everything will be good.
18:53:48 <autrijus> you mean it's not done yet? :)
18:53:54 <autrijus> ok. how do I cabalize something?
18:54:00 <Lemmih> The old package system was less than optimal. Re-packing of all packages is a small price to pay for the joy of Cabal.
18:55:07 <Lemmih> You write a .cabal file for it.
18:55:30 <Lemmih> Does hs-plugins use a complicated makefile build system?
18:57:12 <autrijus> with autoconf and such
18:58:23 <Lemmih> You may need some hooks in the Setup.lhs file then.
19:07:03 <cm> hello
19:08:30 <hellish> I have two questions about the Random module. 1. Is there a standard function for shuffling lists, and 2. Is the module cryptographically secure?
19:12:02 <Darius> No and I doubt it.
19:12:21 <Darius> The Report (www.haskell.org/onlinereport) will give a definitive answer to both.
19:13:02 <Darius> hellish: You should probably use a library specifically for cryptography if you need cryptographically secure random numbers.
19:13:55 <Darius> As for shuffling lists, various solutions are scattered about the internet.  Googling "Haskell list shuffle" or somesuch will almost certainly find them.
19:14:07 <hellish> ah, okay.
19:16:37 <bourbaki> moin
19:19:01 <Darius> hellish: You may want to look at www.haskell.org/crypto/ReadMe.html and the pages it links.
19:20:46 * Darius wonders if there's a Haskell version of the Mersenne Twister.
19:22:09 <Darius> The answer to that (unsurprisingly) is yes.
19:22:42 <Lemmih> Can someone help me grok Alexander Jacobsen's mail to haskell@?
19:24:38 <Darius> What about it?  You seemed to have replied with gusto already (unless another has come since).
19:24:57 <Lemmih> He mailed a reply some minutes ago.
19:29:24 <Lemmih> His second argument is gibberish to me.
19:30:44 <Darius> I don't know what the "mailinglist" part is about.
19:31:28 <Lemmih> Can you explain the rest of it to me?
19:32:51 <Darius> 1) seems to be figuring out which packages are necessary 2) where to find them, and 3) actually installing them.
19:33:03 <dons> auutrijus: hmm. that shouldn't be happening.
19:33:16 <dons> there's cpp to define both forms of package.conf
19:33:25 <Darius> I'm somewhat confused about why this is an issue for a "non-sysadmin end-user" (apprently developer).  Either it's the sysadmin's problem or you're the sysadmin and it's your problem.
19:33:30 <dons> did you configure with one compiler and build with another?
19:33:42 <dons> or possibly the ghc-pkg var in config.mk is referring to the wrong ghc-pkg
19:35:05 <Lemmih> Darius: But why is he talking about finding packages when Cabal is doing it for him?
19:35:09 * Lemmih is confused.
19:35:39 <Darius> Lemmih: I don't think he realized that part.
19:35:51 <dons> autrijus: not auutrijus.
19:36:02 <Darius> And presumably Cabal won't always be able to find out (though it ideally will be rare).
19:38:19 <Darius> Shouldn't problem 1 also be mitigated by some form of dependency system?
19:41:46 <Lemmih> Yeah.
20:11:49 <jyasskin> This "Associated types with Class" paper looks very cool. Does anyone know if they've made any progress toward including type synonyms and default implementations?
20:13:32 <hellish> Is there a way to just get an Int from an IO handle? Yes I've read the report this time, and it looks like all the reading function return IO String or Char.
20:13:48 <hellish> So why not?
20:13:56 <hellish> besides using read.
20:14:52 <Lemmih> What's wrong with using 'read'?
20:16:02 <jyasskin> hellish: you can write a parser. There's 3 kinds in the Text module, and they're not much harder to use than C++'s iostreams.
20:17:02 <hellish> Lemmih: Efficency in storing/reading Ints for one. Two is me needing to read an Int from /dev/random
20:17:27 <jyasskin> Why do you think read :: Int is inefficient?
20:17:40 <SamB> oh, you mean you want to read raw binary words?
20:18:38 <hellish> SamB: yes.
20:19:05 <peon_> isn't there a libray function for rand() ?
20:19:12 <Lemmih> hellish: Look for hGetBuf.
20:19:21 <hellish> jyasskin, you have to encode them in ascii. upper/lower case alphabets and symbols
20:19:38 <jyasskin> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#21
20:19:39 <hellish> Gahhh, not cryptographically secure AFAIK
20:20:16 <SamB> is /dev/random?
20:20:51 <hellish> SamB, under linux, it uses various noise sources, and is considered so
20:21:44 <SamB> I didn't remember that it was /dev/random that was secure and /dev/urandom that only *might* be secure
20:22:49 <jyasskin> /dev/random runs out of bits fairly easily.
20:22:54 <hellish> /dev/urandom uses a pseudo-random number generator when we run out of system entropy, while /dev/random justs waits
20:23:57 <SamB> hellish: oh, is that what it does. I thought it used the same rng but it was only sure to actually be random if you used /dev/random...
20:58:57 <hellish> Are ghc ints shorter than the system word length? My code is causing a segfault
21:00:12 <Lemmih> That should never happen. Post the code.
21:00:44 <SamB> sounds interesting
21:01:39 <hellish> Lemmih, where?
21:01:52 <hellish> copypaste? or a pastebin somewhere?
21:01:58 <Lemmih> Hmm listpaste is gone /-: Try the wiki.
21:02:00 <SamB> how long is it?
21:02:39 <hellish> only 4 lines
21:02:49 <Lemmih> Then just post it here.
21:03:06 <hellish> getSecureRand = do
21:03:06 <hellish>                 randSource <- System.IO.openBinaryFile "/dev/random" ReadMode
21:03:06 <hellish>                 rand <- hGetBuf randSource nullPtr 4
21:03:06 <hellish>                 return rand
21:03:29 <jyasskin> lol. you're assigning to a null pointer ;)
21:03:38 <Lemmih> hGetBuf is not what you want here.
21:04:21 <hellish> Then what is it that I want?
21:04:48 <jyasskin> You need to allocaBytes (http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.Alloc.html#v%3AallocaBytes) the location first.
21:04:50 <Lemmih> Or maybe it is. I can't remember if there's some function to read a word only.
21:05:08 <Gahhh> I think haskell ints are required to be at least 29 bits long.
21:08:33 <Lemmih> Gahhh: maxBound of Int is 2147483647 so it better be 32bits long.
21:08:47 <jyasskin> you probably want something like: (not type checked or anything) rand <- alloca (\p -> do hGetBuf randSource p 4; peek p :: IO Int)
21:09:04 <jyasskin> Lemmih: It's only guaranteed to be at least 29 bits
21:09:56 <Lemmih> jyasskin: Will that be reflected in min/maxBounds when that's the case?
21:10:04 <jyasskin> Lemmih: yeah
21:11:21 <jyasskin> hellish: hGetBuf returns the number of bytes it read, so you can use that for error checking.
21:13:13 <hellish> jyasskin, Ah! That would be the IO Int it returns. The docs didn't say anything about it's return value.
21:13:57 <Lemmih> hellish: Yes it does...
21:13:58 <jyasskin> hellish: you should be looking in the GHC heirarchical libraries docs. They say what it returns.
21:14:31 <jyasskin> i.e. http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#v%3AhGetBuf
21:15:02 <jyasskin> Rather http://haskell.org/ghc/docs/latest/html/libraries/index.html for the index
21:15:41 <jyasskin> hellish: and then the modules you need are System.IO, Foreign.Marshal.Alloc, and Foreign.Storable
21:18:00 <jyasskin> hm, reading Storable, you should probably be using Int32 specifically, so you're sure of the size. And even then, the number of bytes you read should be (sizeOf (undefined::Int32)), just to be sure.
21:30:31 <Pseudonym> And it ties you into a specific piece of hardware.
21:30:45 <Pseudonym> Now a GPU-independent renderer, which still used the accelleration... that'd be something.
21:31:01 <Pseudonym> You could even simulate the GPU on the host CPU if there wasn't one present.
21:34:46 <SamB> I personally use the source for documentation, its available in debian for such...
23:26:06 <musasabi_> morning
23:42:38 <musasabi> How can I see what import pulls what package into compilation?
23:42:47 <musasabi> with ghc --make
23:52:32 <pesco> Good morning, #haskell.
23:54:05 <musasabi> morning pesco
23:55:10 <wilx> Morning folks.
23:55:11 <wilx> ~_~
23:56:22 <skew> hello
