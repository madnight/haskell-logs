00:01:10 <suman> hi all
00:01:25 <suman> are there any good links that point to some information on debuggers?
00:02:47 <autrijus> http://haskell.org/hawiki/LibrariesAndTools#head-d2efc711c8b48133910506215786b00ed2c7d3a6
00:02:50 <Lemmih> Using a conventional debugger is difficult with Haskell.
00:03:21 <autrijus> Lemmih: but not with Eager Haskell, no?
00:03:34 <autrijus> for EH is just like PLT scheme
00:03:44 <autrijus> and similar debugger may be written
00:07:11 <Lemmih> How easy is it to use Eager Haskell?
00:07:27 <Cale> However, Haskell code is not terribly hard to debug regardless of the lack of special programs to help with it.
00:07:36 <wilx> Hmm, can I get a lazy list of Word8 values that is read from binary file?
00:08:01 <tuomov> and there's much less need to debug haskell code than e.g. c code
00:08:09 <Lemmih> Refactoring the functions until you understand them is my debugging tool of choice.
00:08:24 <tuomov> haskell code usually just works
00:08:31 <tuomov> if it compiles
00:08:32 <Cale> Lemmih: how is the C support in HaCanon coming along?
00:09:00 <Lemmih> Cale: It's finished. But I can't send the patches to the repo /-:
00:09:07 * Lemmih pokes shapr.
00:09:08 <Cale> Oh?
00:09:51 <Lemmih> Configuring sendmail to relay mail to a smtp server is really hard (for me at least).
00:09:52 <Cale> I'd like to try using it to generate bindings to the enlightenment foundation libraries.
00:11:15 <Lemmih> I'm not sure I would recommend Hacanon for serious use.
00:11:54 <Cale> oh?
00:12:11 <Lemmih> It requires you to install an improved version of GCCXML and the overhead of linking with Hacanon + TH is not trivial.
00:14:56 <suman> autrijus: i want to understand the theory...like what exactly a debugger is and why is it possible for some languages to have them and not for others..what makes them easy etc..
00:16:25 <Gahhh> it's possible for all languages I believe. O'Caml's debugger is said to be very good. (I never used it)
00:19:22 <Gahhh> "state machine inspectors" heh
00:25:10 <pesco> Good marning!
00:25:16 * pesco stretches.
00:25:18 <Lemmih> Yo pesco.
00:25:42 * pesco 's backbone gives of a loud cracking sound.
00:25:47 <pesco> Yo Lemmih.
00:26:29 <pesco> So what's brewin' today? Cooking up any visionary softs?
00:27:54 <pesco> I'm just reading Neuromancer. I find it cool how the headjack-slottable skill chips are called microsofts.
00:28:06 <Lemmih> Nah. Just thinking actually. Found some stuff which I have no idea how to handle.
00:28:50 <pesco> What kind of stuff? Military? (Oh, need to snap out of the mindset...)
00:30:12 <Lemmih> Proper collision detection and reaction.
00:30:35 * Gahhh sells pesco his kidney for a Ono Sendai Terminal
00:32:01 <Gahhh> I want to filter out characters that are non-us-ascii from a String. Which library do I need ?
00:32:09 <pesco> Data.Char.
00:32:17 <pesco> filter isAscii
00:32:23 * pesco grins widely.
00:33:34 <Gahhh> domo ahrigatoh
00:33:52 <pesco> Lemmih: Wak! That's hot turf, man.
00:34:17 <pesco> Lemmih: You seen the papers?
00:34:29 <Lemmih> What papers?
00:35:00 <pesco> V-Collide, Q-Collide, an' all the others. Forget the names.
00:36:33 <musasabi> morning
00:38:20 * pesco slips Gahhh a folded sheet of paper.
00:38:31 <Lemmih> pesco: I'm only troubled by the proper reation since OpenGL does the detection for me.
00:38:51 <pesco> Lemmih: Oh, in 2D?
00:39:17 <Lemmih> Yes.
00:39:39 <pesco> I see. Well, do you have velocity vectors for the objects?
00:40:23 <Lemmih> Yep.
00:44:19 <pesco> I'm no physicist, but...
00:44:29 * pesco grabs his Physics schoolbook.
00:57:11 <pesco> Lemmih: Damn, it doesn't say it. Stupid book.
01:06:58 <Svrog> hi everyone
01:07:03 <Lemmih> Hey
01:07:10 <Svrog> hows it going?
01:07:51 <Lemmih> Great. Learning new stuff all day long.
01:08:12 <Svrog> cool - same here :)
01:09:26 <Svrog> i've been reading a bit about arrows lately - im still not quite sure how they work
01:09:40 <Svrog> in what way exactly are they better then monads?
01:16:57 <Lemmih> They allow you to gather static information.
01:17:37 <Svrog> what do you mean?
01:18:24 <Lemmih> Consider a function which takes two arrows and gives a new arrow.
01:18:51 <Svrog> yup
01:18:51 <Lemmih> The function will have access to both arrows.
01:19:09 <Svrog> ok
01:19:40 <Lemmih> But with bind in Monads (m a -> (a -> m b) -> m b) you don't have access to the second monad before you evaluate the function.
01:19:56 <Svrog> oh right
01:20:30 <Lemmih> This can cause space leaks.
01:20:54 <Svrog> so is there any reason then not to completely switch to using arrows instead of monads?
01:22:02 <Lemmih> No.
01:22:12 <Svrog> hmm.. interesting..
01:22:19 <Lemmih> But I'm not expert (: Take what I say with a gain of salt.
01:22:27 <Svrog> fair enough
01:22:37 <ozone> Svrog: well, every monad is an arrow
01:22:43 <autrijus> quasiquote patterns!
01:22:44 <ozone> but there's no reason to deprecate monads
01:22:48 <autrijus> I just discovered them.
01:22:54 <ozone> people understand them a lot better than arrows
01:23:01 <autrijus> wow. that means writing a compiler in 5 minutes :)
01:23:02 <ozone> autrijus: uh oh, metaprogramming time :)
01:23:14 <ozone> autrijus: yeah, dons is using them in hs-plugins for runtime metaprogramming ...
01:23:16 <Svrog> so people can learn to use arrows :)
01:23:24 <autrijus> ozone: qq pattersn?
01:23:36 <ozone> Svrog: there's no reason to use arrows if you don't need to
01:23:44 <ozone> autrijus: i gather you mean [| foo |] ?
01:24:23 <autrijus> ozone: no. I mean
01:24:35 <Svrog> well if they are a superset of monads then i don't see a reason not to use them all the time
01:24:47 <autrijus> f [| (x, $y, $(g z)) |] = ...
01:24:49 <autrijus> that is crazy.
01:24:51 <autrijus> crazy crazy.
01:25:19 <Lemmih> *not an expert
01:25:20 <ozone> autrijus: mmm, not sure what you mean.  why is that crazy?
01:25:25 <integral> autrijus: that passes a AST to f, with y and (g z) substituted in?
01:25:42 <autrijus> integral: no, it's parameters.
01:25:48 * Lemmih got a keyboard which eats words.
01:25:48 <autrijus> it's parameters of f.
01:25:59 <autrijus> f arg1 arg2 = ...
01:26:08 <integral> oh, wow, crazy
01:26:13 <autrijus> that's just wrong.
01:26:19 <autrijus> I mean, correct, but wrong.
01:26:34 <autrijus> ozone: it means you get to parametrize over pattern bindings.
01:26:40 <autrijus> in compile time.
01:26:56 * ozone scratches head
01:27:25 <autrijus> so you can say
01:27:47 <autrijus> f [| $(Lit x) |] = x ...
01:27:54 <autrijus> and force f to take a literal.
01:28:01 <autrijus> instead of other expressions.
01:28:07 <autrijus> i.e. it can only be used as
01:28:09 <autrijus> (f 1)
01:28:10 <autrijus> but not
01:28:12 <autrijus> (f (1+1))
01:30:02 <ozone> autrijus: hmm, that code example doesn't work for me
01:30:07 <autrijus> GHC 6.4?
01:30:18 <ozone> i think i understand what you mean, though i'm unsure how it works
01:30:21 <ozone> yeah, 6.4
01:30:21 <ozone> Foo.hs:3:2: Parse error in pattern
01:30:35 <ozone> that's with -fglasgow-exts
01:30:43 <ozone> and also -fth :}
01:30:47 <autrijus> tracing it.
01:31:16 <ozone> that's also with import Language.Haskell.TH.Syntax
01:31:58 <autrijus> hmm, I see a 'sym syntax.
01:32:03 <autrijus> a sec
01:32:24 <ozone> you're on 6.4?
01:33:29 <autrijus> ah. never mind. it's not yet in 6.4, just in the paper
01:33:37 <autrijus> sorry for trigger-happy with new syntax.
01:33:44 <Lemmih> What paper?
01:34:34 <musasabi> autrijus: One has 'x syntax in 6.4
01:34:34 <ozone> yeah, what paper?  now you have me intrigued :)
01:34:54 <autrijus> notes, really. http://research.microsoft.com/~simonpj/tmp/notes2.ps
01:35:02 <ozone> oh, that one
01:35:22 <autrijus> sorry. I'm really a newcomer to this 6.4 thing :)
01:37:33 <ozone> i'd hardly call you a newcomer :)
01:38:18 <autrijus> but I am :) only installed 6.4 this week.
01:38:41 <Oejet> Haha, autrijus is a newbie. :-P
01:38:51 <autrijus> and next week will be my 3rd month in learning haskell :P
01:39:00 <autrijus> so, definitely a newbie.
01:39:35 <Svrog> you sound pretty advanced for a newbie - already messing with th :)
01:39:51 <ozone> your 3rd month? and you're this proficient already?  /me impressed
01:39:53 <autrijus> Svrog: work-driven :)
01:40:17 <Svrog> and you use haskell at work?? wow! im impressed
01:40:26 <Oejet> autrijus: May I ask, how many man hours you have spend on Haskell?
01:40:32 <Svrog> i wish i could use haskell or caml or scheme at work heh..
01:40:42 <autrijus> Oejet: in my first month in learning haskell I did nothing but :)
01:40:46 <autrijus> so it's like 14 hours a day.
01:40:56 <autrijus> so 420 on first month.
01:41:25 <autrijus> then, I talked $client into funding me writing OpenAFP.hs, so that's 7 hrs a day for two weeks.
01:41:31 <autrijus> then Pugs started, and I'm back to 10 or so.
01:41:40 <autrijus> so nearly 1000 I'd say
01:42:18 <autrijus> not quite, but close
01:43:15 <autrijus> GHC is so much fun :)
01:43:16 <Oejet> autrijus: I vaguely remember asking newbie questions three months ago.  That didn't last long, though. :-P
01:43:25 <autrijus> right :P
01:43:29 <Oejet> *remember you
01:43:29 <Svrog> im somewhat surprised you chose haskell for a work project even though you didn't know haskell - not that theres anything wrong with that - im just a bit surprised
01:43:31 <autrijus> thanks for bearing with me then and now
01:43:48 <autrijus> Svrog: oh. it's easy, I need to grok darcs for $another_job
01:43:54 <Svrog> ah right
01:44:07 <autrijus> and then I started this crazy project.
01:44:13 <autrijus> see http://www.perl.com/pub/a/2005/03/03/pugs_interview.html :)
01:44:14 <Svrog> hehe cool
01:45:26 <musasabi> autrijus: I was talking yesterday to our local perl enthustiatic about things and he was quite impressed with Pugs :-)
01:47:17 <autrijus> *smile*
01:50:11 <Svrog> that interview was amusing
01:50:18 <autrijus> =)
01:50:58 <Svrog> i've never heard of pugs before - checking it out now
01:51:08 <Svrog> been a while since i last used perl
01:51:34 <autrijus> Svrog: we are in a shortage of lambdafolks who know perl. SyntaxNinja and lightstep helped a lot, and camelfolks are learning fast, but more is always welcome :)
01:52:09 <Svrog> im not an expert on either perl or haskell though :)
01:52:13 <autrijus> that'd be best.
01:52:35 <Svrog> i use haskell more then perl but i use caml more then haskell.. although now that 6.4 is out im considering switching back to haskell hehe
01:53:00 <autrijus> yeah. TaPL uses caml
01:53:12 <autrijus> but lists in perl 6 is lazy by default
01:53:17 <autrijus> so modelling them using haskell is ~easier
01:56:26 <Svrog> lazy evaluation in caml and sml isn't hard - its pretty easy in fact - however overall haskell is a much nicer language i think.. the only reason why ive been using caml more then haskell was because i was annoyed with some of my code running real slow in haskell - the bottlenecks in haskell just don't seem obvious at all and i had to profile a lot more then then i did in any other language
01:57:11 <autrijus> +RTS -prof has always been kind to me.
01:57:29 <tuomov> sometimes haskell isn't as lazy as I'd want it to be
01:57:29 <autrijus> and I'm thrilled at how easy it is to do pointer arithmatic and/or include C code.
01:57:51 <autrijus> oh and I come from a perl5 background, so however slow Haskell is, it is still many times faster than perl5 :)
01:58:05 <tuomov> e.g. writing out a string concatenation will create the concatenated string
01:58:11 <tuomov> wasting lots of memory
01:58:29 <autrijus> tuomov: there's no flag to turn that off?
01:58:36 <tuomov> I don't know..
01:59:05 <tuomov> I worked it around by using mapM_ (putStr h)
01:59:34 <tuomov> ugly complicated special-case optimization in the code, though. Can't use normal show
02:00:10 <tuomov> Before that haskell could eat 10M of memory never collected when writing out a 500k file
02:00:45 <autrijus> ah. because show is not fusionable?
02:00:56 <tuomov> "fusionable"?
02:01:04 <Svrog> yeah things like that are what made me switch to caml.. i just didnt have to think about those things
02:01:20 <autrijus> "not happy by default with infinite lists"
02:01:44 <autrijus> nodnod. I may use caml when I hit GHC's performance limit.
02:01:44 <Svrog> but i keep going back and forth between the two :)
02:01:54 <autrijus> for now haskell (esp with 6.4) is good enough
02:02:26 <autrijus> Svrog: well, I hear the knowledge between the two is largely transferrable
02:02:26 <tuomov> otherwise I haven't had any serious performance problems
02:02:27 <Svrog> autrijus: if you haven't hit it so far you're probably ahead of me in figuring out the bottlenecks :)
02:02:48 <Svrog> and like i said im considering switching back to haskell now that 6.4 is out :)
02:03:07 <autrijus> Svrog: perhaps. I learned to use CStrings and peek and poke pretty early
02:03:16 <autrijus> and plusPtr and friends.
02:03:37 <Svrog> autrijus: yes thats true - especially once you know haskell - haskell is both the most elegant and also the hardest functional language to get into - once you know haskell all the other functional languages are easy to get into
02:03:45 <Svrog> except maybe joy hehe
02:03:54 <autrijus> I hear Curry and Oz are also fun.
02:04:00 <autrijus> Curry seems very much fun indeed.
02:04:06 <tuomov> I don't know.. I find all the IO and OO kludges in lesser languages very complicated
02:04:22 <autrijus> tuomov: they are all in the Eval nomad :)
02:04:51 <Svrog> tuomov: yeah i find that oo in caml is pretty much useless - it's also pretty slow - ive never felt the need to use it
02:04:53 * autrijus remembers "type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x)" again
02:05:43 <Svrog> as for io.. i cant see what's so complicated about io in caml, sml and scheme - it's not as elegant as in haskell but it's definitley more trivial then monads
02:07:59 <Svrog> i found haskell pretty hard to get into when i was first learning functional languages - took me 3 or 4 goes at it before i finally got it - the first few goes i gave up in disgust hehe (took me a while to get used to syntax and monads and even longer to figure out how they work) - i found it much easier to get into caml and scheme and then learn haskell once i knew those two
02:08:18 <tuomov> Sure, it maybe easy to use them, but they seem such a complicated kludge
02:08:31 <autrijus> yeah, I learned scheme first.
02:08:37 <Svrog> complicated in what way?
02:08:44 <autrijus> culminating in http://search.cpan.org/dist/Inline-MzScheme/
02:08:51 <autrijus> (inline scheme code in perl and vice versa)
02:08:54 <tuomov> very inelegant
02:09:10 <Svrog> thats true
02:09:12 <autrijus> tuomov: the world is not an elegant place :)
02:10:17 <Svrog> which is why i prefer haskell to caml and scheme - well except for the compiler - i really like the caml compiler, it does a great job most of the time without too much effort on my part to write efficient code :)
02:11:09 <tuomov> well, since it isn't inherently lazy, you avoid doing certain things you might attempt in haskell and then be surprised
02:11:10 <Svrog> although it still has its problems.. and it seems like development has slowed down lately.. or at least thats the impression im getting
02:14:24 <musasabi> autrijus: you should write something on "using ConT in the real world" ;)
02:16:15 <autrijus> musasabi: ContT is underused? ;)
02:17:24 <musasabi> yes, and all the examples are toys.
02:18:09 <autrijus> ah.
02:18:12 <autrijus> but ContT is so powerful!
02:18:24 <autrijus> esp. with resetT and shiftT.
02:18:38 <autrijus> who is responsible for the ContT on the wiki, btw?
02:21:46 <Svrog> im off to play with arrows in ghc for a bit :) - cya later everyone!
02:21:52 <autrijus> see ya Svrog!
02:22:17 <autrijus> I find it amusing that perl 6 designers discover that hClose kills hGetContents only now :)
02:22:54 <autrijus> but still larry sticks to the "lazy evaluation by default" rule. yay.
02:24:18 <musasabi> :-)
02:30:51 <autrijus> so p6 may end up becoming the first call-by-need language that is not purely functional.
02:31:02 <autrijus> or is there precedents?
02:34:07 <autrijus> greetings tintin.
02:36:07 <kosmikus> autrijus: I know at least one obscure non-pure, but functional language that is call-by-need
02:36:12 <autrijus> oh?
02:36:15 <autrijus> what is it?
02:36:38 * kosmikus tries to remember how it was called
02:36:40 <autrijus> perl6 is not even functional anyway :)
02:36:54 <autrijus> unless you only use a small subset.
02:38:24 <kosmikus> no, and perl6 is likely to be more important ;)
02:44:01 <kosmikus> autrijus: I can't find it; maybe I was wrong
02:44:45 <autrijus> ok.
02:45:34 <kosmikus> I remember I heard a talk once, somewhere in the .nl, but I don't know exactly where (could have been a "landelijke FP dag"), where someone presented a language which had lazy evaluation, but side effects, which I found very strange back then
02:46:55 <kaol> Mozart has lazy evaluation and side effects. It's not the default as in Haskell, but it's still there.
02:47:07 <autrijus> oh. user-defined lazy eval is just fine.
02:47:13 <autrijus> every language that has closures has them.
02:47:21 <autrijus> but I'm talking about side effects by default.
02:47:40 <autrijus> and lazy evaluation by default.
02:47:43 <Oejet> kosmikus: Backus and Nauers ALGOL language with call by name?
02:48:04 <kosmikus> could have been Amanda, which is now being developed into Tina, but the Web only says "subset of Miranda", which doesn't back back up the non-pureness claim
02:48:38 <kaol> well, you have to just use keyword "lazy" there. no further user involvement needed.
02:48:51 <kosmikus> Oejet: that's also only an option, isn't it?
02:49:18 <Oejet> kosmikus: I have no idea.  I haven't read the ALGOL report. :-P
02:50:36 <kosmikus> earthy does certainly know ...
02:58:51 <Oejet> Wow, sacrificing a chicken with a trifork on a full moon really gets Parsec parsers to work.
02:59:11 * musasabi wonders how one can have sensible semantics in a non-pure lazy language.
03:00:12 <musasabi> especially why does 'print "foo"; print "bar"' work (or do you have ';' corresponding to '>>') ?
03:23:39 <Oejet> Hurrah, my Parsec Frankenstein expression parser seems to work!
03:25:12 <Oejet> Greetings, adiabatic.
03:25:56 <adiabatic> 'lo
03:34:33 <Svrog> is there a library/set of bindings for haskell that adds the remaining gmp functions to haskell?
03:43:56 <Lemmih> musasabi: putStrLn "foo"; putStrLn "bar" doesn't "work". It's part of the do-notation.
03:48:41 <ibid> whaa, spj's implementation of fp is available online
03:53:20 <Svrog> fp as in implementation of fp, the programming language?
03:55:10 <Svrog> or are you talking about something else?
03:55:43 <Svrog> whats the link?
03:59:21 <ibid> Svrog: http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
03:59:32 <ibid> Svrog: it's a classic book on implementation of functional programming languages
04:00:05 <Svrog> oh right
04:00:37 <Svrog> where's the implementation of fp though?
04:00:48 <ibid> hm?
04:01:15 <Svrog> i thought you were referring to backus' fp
04:01:18 <Svrog> the programming language
04:01:56 <Svrog> nevermind - i just found one :)
04:02:09 <Svrog> i looked for one about a year or two ago and couldnt find any
04:02:21 <Svrog> always wanted to have a play with fp
04:04:07 <Svrog> oh right... now i know why i was confused - the title.. implementation of functional programming languages... sorry - im a bit slow tonight
04:05:19 <Svrog> http://christophe.deleuze.free.fr/D/fp.html
04:06:57 <adiabatic> I'm using ghc 6.4 and it seems I'm getting an error...
04:07:08 <adiabatic> "Test.hs:1:1: lexical error"
04:07:16 <adiabatic> Line 1...
04:07:30 <adiabatic> damn BOM
04:07:50 <adiabatic> Nevermind.
04:08:02 <Svrog> ?
04:08:45 <TheStar> Svrog, Appears that adiabatic has discovered a trivial problem.
04:08:50 <ibid> BOM?
04:08:59 <ibid> ah :)
04:09:04 <ibid> byte-order mark
04:09:08 <adiabatic> Byte Order Mark. Three bytes of stuff in Uni...right.
04:09:09 <Svrog> ah hehe
04:13:08 <Svrog> i didnt even know haskell could parse unicode source heh.. i wasn't actually aware of any languages that did - i just assumed it was all ascii
04:13:16 <Svrog> or ghc rather
04:13:38 <adiabatic> Well, it's not as if I'm putting in any characters that aren't in ASCII already.
04:14:08 <Svrog> yeah but why not just use ascii? you wouldn't have to worry about it then
04:14:29 <Svrog> why use unicode?
04:16:11 <adiabatic> Because there is no character set but Unicode, and UTF-8 is its encoding.
04:16:36 <adiabatic> ...and I have TextWrangler set to default to UTF-8 when making new files.
04:18:00 <ibid> should i try yu?
04:18:20 <Svrog> what do you mean there is no character set but unicode? considering you're using textwrangler im assuming you're on a mac - i'm on a mac as well and ive never had to create unicode files - i just use plain ascii
04:18:26 <Svrog> im using vim though
04:19:48 <adiabatic> Svrog: I'm kidding.
04:20:04 <adiabatic> I have vim set to default to UTF-8, too.
04:20:20 <Svrog> fair enough
04:20:35 <Svrog> sorry - didnt get the joke.. like i said im a bit slow tonight heh..
04:24:59 <Svrog> oh well.. im off again..
04:39:15 <metaperl> I have question about polymorphic types posted here: http://www.hcoop.net/~terry/haskell/AllAboutMonads/1.txt
04:41:08 <metaperl> never mind, I think they explained themselves a bit further down
04:47:12 <basti_> hi
04:47:18 <bourbaki> moin
04:47:24 <basti_> hi bourbaki
05:07:28 <musasabi> Lemmih: I know I was referring how it would work in perl.
05:08:32 <_JusSx_> HI
05:08:49 <basti_> hi
05:09:02 <_JusSx_> araujo: hokla
05:13:41 <Oejet> I have a subtle grammar/Parsec problem in the top program at http://haskell.org/hawiki/HaskellIrcPastePage .
05:15:00 <Oejet> I think it has something to do with the use or lack of use of try().
05:26:56 <wilx> Subtle, heh? :)
05:55:26 <djo> could a haskell function change the value of its parametre ?
05:55:43 <tromp> no
05:55:44 <basti_> haskell variables never change their value.
05:55:54 <djo> oki doki
05:55:57 <basti_> almost never.
05:55:57 <basti_> ;)
05:56:37 <musasabi> basti_: never ever ;)
05:56:50 <basti_> well what does IORef do then?
05:56:57 <basti_> it bizarres? ;)
05:57:06 <musasabi> basti_: it does not change the value of a variable.
05:57:26 <musasabi> basti_: it produces a program ;)
05:57:46 <musasabi> There was a thread this week on why IO is pure.
05:57:49 <tromp> it only changes what future IO events will do if performed
05:57:52 <musasabi> on c.l.f.
05:58:04 <basti_> mmmh
05:59:23 <tromp> it's just like putStr, an IO action that affects the state of the world if performed
06:00:08 <basti_> i think i see the point
06:00:25 <basti_> IORef hides the value "outside" the pure area doesnt it?
06:00:55 <tromp> it sticks the value out in the world
06:01:16 <tromp> it's just like a file handle
06:02:38 <musasabi> basti_: iorefs could be trivially be implemented on top of files, so either using files is pure and iorefs are pure or even using files is impure.
06:03:17 <basti_> hm yup
07:07:29 <djo> is there a function to sort a list of int ?
07:08:09 <Oejet> djo: List.sort.
07:08:17 <djo> ah
07:08:21 <djo> think you
07:10:29 <djo> in the doc it's not specified wether this function do the sorting from small to great or the invers
07:12:07 <mflux> propably it is assumed people expect sort to work in ascending order by default?
07:13:42 <TheHunter> you can get descending order using `sortBy (flip compare)
07:13:57 <TheHunter> '
07:13:57 <halcyon10> aren't you supposed to give 'sort' a compare-function? then you can decide yourself in which order you want the list to be sorted
07:14:06 <basti_> thats sortBy then
07:14:11 <halcyon10> ah
07:15:07 <djo> I want ascending sort
07:15:27 <mflux> is there a (the trivial) function in the prelude that would return the reverse of compare?
07:15:34 <djo> what do you mean by a "compare-function" ?
07:15:55 <mflux> well, flip compare obviously does ;)
07:16:08 <mflux> but I'm thinking if you already have for example the value LT
07:16:32 <mflux> as apparently unary - doesn't work with those
07:17:03 <TheHunter> @type Data.List.sortBy
07:17:05 <lambdabot> Data.List.sortBy :: forall a. (a -> a -> Ordering) -> [a] -> [a]
07:17:11 <halcyon10> djo: a function that gets two values of the same type and returns 1, 0 or -1 depending on if they're in the supposed order or not
07:17:23 <mflux> nope, LT, GT or EQ
07:17:28 <halcyon10> oh, ok
07:17:43 <mflux> which is sort of elegant but prohibits that kind of number manipulation ;)
07:17:49 <halcyon10> don't know the haskell-specific return-type yet, sorry
07:24:49 <bringert> cmp x y = fromEnum (compare x y) - 1
07:25:30 <bringert> [cmp x 2 | x <- [1..3]]
07:25:30 <bringert> [-1,0,1]
07:25:54 <bringert> if you really need -1, 0, and 1 as result
07:35:08 <halcyon10> is the Prelude available in Haskell-source in the ghc-distribution ?
07:43:33 <musasabi> halcyon10: at least in the source distribution.
07:44:03 <musasabi> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Prelude.hs?rev=1.23
07:44:11 <halcyon10> thanks musabi
07:44:25 <halcyon10> musasabi
07:57:25 <Asmdroid> Sorry, I'm an absolute amateur to hugs, I'm wondering where I place, or create a hs file on Linux.
07:57:31 <Asmdroid> Will read the documentation now.
07:58:55 <crot> is there even a point to considering haskell for DSP?
07:58:55 <ibid> Asmdroid: what do you mean?
07:59:15 <ibid> crot: if it's hard real time, not really
07:59:21 <Asmdroid> No problem, I know how to do it now :). Simply a matter of typing ":?"
07:59:32 <Asmdroid> cd /x/x/ :load whatever
07:59:42 <Oejet> Philippa_: I have some trouble with a small grammar for which I want to write a Parsec parser.
07:59:59 <crot> it's on conventional computer hardware (with a conventional OS), so it's not hard real-time
08:00:10 <crot> but it is one of those things that would be nicer if it was almost hard real-time
08:01:05 <ibid> then it's not so clear cut
08:01:55 <crot> it is for audio synthesis
08:02:06 <crot> I basically just want a way to hook up a bunch of units that generate audio together
08:02:17 <ibid> try it?
08:02:38 <crot> I guess I could
08:02:49 <crot> I will probably end up making my own language with language support for audio
08:02:56 <crot> I am doing the music side with a modified haskore
08:03:10 <ibid> don't they say that haskell is an excellent language to embed dsls in
08:03:47 <crot> it usually is, the problem here is efficiency
08:05:10 <musasabi> you can get efficiency out of haskell.
08:05:16 <musasabi> real time is harder.
08:05:56 <crot> I was considering just using it as a glue language for different modules I write in C or assembly
08:05:57 <musasabi> the problem is that garbage collection is not very real time friendly (of course if your working set is small it can be within your time-limits)
08:06:24 <ibid> a student of mine wrote a msc thesis on garbage collection in real time systems
08:06:37 <crot> I've done semi-realtime garbage collection before
08:06:46 <musasabi> crot: how about writing the code in haskell - profiling and rewriting the small critical loop in C/asm ?
08:07:09 <crot> well I already know what parts will be critical
08:07:24 <crot> profiling audio code is kind of pointless sometimes
08:07:36 <musasabi> yes, but real-time collection has more overhead than conventional GC - thus most languages don't have it included.
08:07:46 <ibid> if the sublanguage is designed right, you can later change the plumbing so that the same code ends up generating c code when run instead of running for real
08:09:03 <shapr> I can't believe it's not butter!
08:09:19 <ibid> shapr: hm?
08:09:26 <crot> I found some posts on the haskell-cafe list
08:09:30 <musasabi> What should a binary serialization module be called in the module hierarchy? Codec.???.???
08:09:46 <crot> that show that the naive approach in haskell is about 10 times slower than haskell or more
08:09:48 <araujo> Hellu
08:09:50 <wilx> System.IO.Binary?
08:09:51 <crot> err 10 times slower than C
08:10:38 <ibid> that's because you can't do the naive version in C :)
08:10:47 <musasabi> crot: of course a naive approach will be 10 times slower than C. But you don't care about performance for most of the code ;)
08:12:26 <musasabi> wilx: isn't System.IO.?? a wholly wrong place?
08:22:25 <Asmdroid> How long does it take to get into the mood of haskell, I've been playing around with it all of an hour; enjoying it so far :).
08:22:41 <Asmdroid> A month?
08:26:56 <Oejet> Asmdroid:  Haskell with extensions is huge, so you won't run out of mind boggling constructs for a while.  A month of full time will get you very far, though.
08:29:39 <tuomov> One week's programming project will get you far
08:29:51 <tuomov> That's how I got used to it
08:36:04 <ibid> i think i got in the mood the first day
08:36:18 <ibid> of course, my haskell code was horrible for a few years after that :)
08:37:15 <ibid> mostly due to being unaccustomed to higher-order thinking and unfamiliarity with the standard libraries
08:38:51 * Oejet is writing horrible Parsec code and hopes time will better it.
08:39:30 * musasabi keeps deleting code to get something releasable
08:39:38 <ibid> for example, if you look at the small program i wrote for debian's build-essential in 1999, you'll see there's a lot of awkwardness there
08:45:24 <Asmdroid> Oejet: Hehe, well I have plenty of time.
08:46:04 <Oejet> Asmdroid: I guess you are a student then. :-P
08:51:28 <Asmdroid> Oejet: Indeed. I have just got rid of a girl also, so that == Lots of time.
08:51:41 <Asmdroid> The joys of being single.
08:51:46 <Asmdroid> (again)
08:52:03 <Asmdroid> Oh crikey.. she checks these logs.
08:52:30 <Oejet> Asmdroid: You haven't broken up yet. ;-P
08:53:30 <Oejet> Asmdroid: Why would she read the #haskell logs?
08:54:37 <Asmdroid> Well, partially because I told her my alias, and about IRC once. So unfortunately she'll probably read this.
08:54:49 <Asmdroid> These logs are available through google.
08:55:46 <Oejet> Asmdroid: I hope it works out for you anyway.
08:56:00 <ibid> yeah, and they are the only results googling with your nick :)
08:56:14 <X-Scale> Asmdroid: only share the minimal amount of information with strange aliens :)
08:58:05 <Asmdroid> I never will again :). I think my bed will be the only thing I'll share with them.
08:58:19 <ibid> not even your password? :)
08:58:22 <ibid> (a good thing:)
09:00:09 * musasabi met his SO more or less through irc so hiding my nick would be kind of hard.
09:00:53 <Asmdroid> musasabi: If you met her on FreeNode I would be suprised?
09:00:59 <ibid> where i irc all the women are either not there or already have SOs :)
09:01:48 <ibid> there was one who apparently was prepared to take me as her second, but i wasn't prepared for that (and there were other issues as well)
09:02:34 <musasabi> Asmdroid: well she does idle here too ;)
09:03:24 <Asmdroid> Oh christ, I do really hate the logic of some females. I need a female programmer!
09:03:54 <ibid> hm?
09:03:55 <sh10151> my fiancee is easily programmable
09:04:11 <sh10151> i can hum any tune and she will be humming it herself a few minutes later
09:04:18 <Asmdroid> ibid: As her second! You could have been her next?
09:04:18 <sh10151> not realizing that i was humming it first :)
09:04:25 <Asmdroid> (victim)
09:04:41 <ibid> Asmdroid: no, she is polyamorous and clearly committed to her SO
09:05:28 <sh10151> that was the sound of a paradigm shifting without a clutch
09:06:50 <ibid> which paradigm shifted to which paradigm? :)
09:07:15 <Asmdroid> Hehe
09:13:46 <musasabi> How do I derive Typeable by hand?
09:16:56 <Asmdroid> Think I might aswell spend the rest of the month focusing on assignments, then I'll be clear for the rest of the year to focus on Haskell.
09:18:13 <Asmdroid> (ignore)
09:28:21 <Oejet> Wow, I get a stack space overflow with a stack size of 200MB when parsing an 103 characters long string. =-O
09:29:07 <halcyon10> =)
09:29:45 <halcyon10> it must be a very special method of parsing then ;)
09:30:10 <Oejet> halcyon10: It is. There must be an infinite loop, I think.
09:34:17 <Oejet> Heh, find the error: s = s `chainl1` ( do{ try(P.semi lexer); return (\x y->Seq(x, y)) } )
09:40:14 <Oejet> Phew, defined a parser for the While language in ~160 lines of Parsec/Haskell.
09:41:59 <halcyon10> Oejet: what's 'While' like?
09:42:42 <ibid> x := t, if t then s else s' fi, while t do s od, s; s'
09:42:43 <ibid> right?
09:42:47 <ibid> (modulo syntax)
09:42:49 <Oejet> halcyon10:  [x:=4]1; [y:=x]2; while [x=4 & (5+x) <y]2 do ( [ z := x ]4; [x:=2]5 ); if[x=0]7then[x:=0]9 else[y:=x]10
09:43:39 <halcyon10> are the appended numbers linenumbers ?
09:43:48 <Oejet> ibid: It's syntax is only defined abstractly, so the concrete syntax is an implementation issue.
09:44:08 <Oejet> halcyon10: No, they are numbers of basic blocks.
09:44:22 <halcyon10> ah
09:44:57 <Oejet> I made the concrete syntax as close a possible to the one in "Principles of Program Analysis" by Nielson & Nielson & Hankin.
09:45:12 <ibid> Oejet: as i said, modulo syntax :)
09:46:58 <Oejet> Look in the top of http://haskell.org/hawiki/HaskellIrcPastePage for the AST.
09:48:56 <Oejet> I especially found `chainl1` to be neat.
09:53:54 <halcyon10> i'm waiting for 4 hours now for my program to spit out a number.. i think i have to learn haskell faster to be able to implement some better algorithm :)
09:54:51 <Cale> halcyon10: what does your program do?
09:56:28 <halcyon10> it tests how well sorting-networks of a specific maximum number of compare-swap-operations perform on reducing all possible sortcases
09:57:38 <halcyon10> my goal is to understand the nature of sorting-networks better and perhaps find a nice way of finding optimal sortingnetworks
09:59:29 <tromp> hi oeject
09:59:39 <Cale> hmm, interesting
09:59:50 <tromp> i thought while language didnt have "if"
10:00:08 <tromp> you can simulate if with while
10:00:37 <Oejet> tromp: Well, it does in my book.
10:01:14 <halcyon10> Cale: yes, i find it particularly interesting because it is an optimization-task which gets unmanageable with brute-force-methods fast, so one has to come up with more intelligent methods
10:01:40 <tromp> is the optimal network on 16 inputs known yet?
10:02:18 <Cale> I wonder whether representation theory is useful for that.
10:02:27 <halcyon10> tromp: i think not. or it is not proven that the best one known is really the best
10:02:42 <halcyon10> Cale: what's representation-theory?
10:03:25 <halcyon10> here's a summary on the currently best known sortingnets: http://www.cs.brandeis.edu/~hugues/sorting_networks.html
10:03:41 <Cale> It's the theory of representing groups (or other mathematical objects) by matrices, such that the group multiplication aligns with the matrix multiplication.
10:04:09 <tromp> ah, even size 11 unknown
10:04:10 <halcyon10> oh, i see
10:05:12 <halcyon10> tromp: yes, and even size 9 with respect to the number of compare-swaps
10:07:53 <tromp> right, i guess that's a more interesting measure
10:08:33 <Oejet> What's the application of sorting networks?  Parallel sorting?
10:09:43 <halcyon10> Oejet: i think it could be used to do the sorting of small subproblems of other sortingalgos like quicksort
10:10:51 <Oejet> halcyon10: Why not just use it to sort everything?
10:13:10 <halcyon10> Oejet: if you have an optimal sorting net for the size of your to be sorted list that surely would be an option often. or if you are sorting many lists of the same known length
10:14:01 <halcyon10> i'm currently trying to improve my routine which builds a tree of all reasonable sortingnets. for example it would be dumb to apply the same compareswap-operation two times in a row. this possibilities should be pruned from the tree
10:16:04 <maihem> I love template haskell :) I've just written a program that, when you run it, prints out the command line options that it was compiled with :)
10:17:31 <maihem> but is there a standard way to get arguments specifically intended for template haskell (ie, so I don't have to write my TH code with a hard coded option to look out for so it just works on various compilers)
10:18:29 <maihem> like gcc has -Wl,opt,opt,opt to send options to the linker but the linker doesn't have to look out for -Wl, it just gets the options as separate arguments
10:56:28 <wilx> maihem, read GHC docs.
10:56:42 <wilx> It has a section that describes it.
11:05:22 <maihem> oh, sorry, I found -optXblah but I will look again.
11:16:39 <djo> is it possible to change the value of an element knowing his index ?
11:17:16 <Cale> djo: in a list?
11:17:36 <djo> yes
11:17:39 <djo> sorry
11:18:22 <Cale> update x n xs = take n xs ++ x : drop (n+1) xs
11:18:27 <djo> is there a function to this directly or should I play with drop/take and the index ?
11:18:33 <djo> ah
11:18:35 <Cale> but you don't want to do that too often
11:18:53 <Cale> lists are not a good model of random-access arrays
11:19:09 <djo> thinks
11:19:13 <Cale> if you want to do updates like that all the time, look at Data.Map
11:19:23 <Cale> or the various Array types
11:19:36 <Cale> (the mutable ones in particular)
11:20:28 <djo> oki doki
11:20:49 <Cale> (Data.FiniteMap if you're using something older than GHC 6.4)
11:31:47 <Igloo> desrt_gabriel: Are you here?
11:31:51 <desrt> weird.  ya
11:31:57 <desrt> just sat down :)
11:32:04 <Gahhh> psychic
11:32:22 <desrt> s'up?
11:33:09 * desrt just scrolled back to someone activating his nick hilight by flaming him about how ubuntu != debian :)
11:33:30 <metaperl> I have a question on the definition of monads. I have typed up my question here: http://www.hcoop.net/~terry/haskell/AllAboutMonads/2.txt
11:33:31 <Igloo> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/includes/MachRegs.h.diff?r1=1.21;r2=1.21.2.1;f=h is the only patch necessary to fix ghc 6.4 on powerpc, right?
11:33:43 <desrt> yes
11:33:47 <Igloo> Thanks
11:34:32 <desrt> how does debian deal with a package being broken on a given arch?
11:34:53 <Igloo> By fixing it  :-)
11:35:07 <desrt> like, does apt understand the idea that 6.4 is available for ppc but only 6.2.2 works on some-other-platform?
11:35:10 <desrt> ah
11:35:15 <desrt> i sort of like that approach :)
11:35:19 <Igloo> Ultimately you might have to remove the old version on the arch it works on
11:35:48 <desrt> apt-get install ghc6 got me hugs, eh?
11:36:10 <Igloo> I could upload 6.4-1 to unstable and it would get built on most arches, so which versino you got would depend on which arch you were on. But it would never migrate to testing, and hence unstable, if it hadn't been built on all the arches for which there is already a version in testing
11:36:16 <Cale> metaperl: I don't understand what your question is
11:36:23 <Igloo> On powerpc?
11:36:28 <metaperl> their use of the word computation
11:36:34 <wilx> Yay for me!
11:36:42 <wilx> My pure version of LZW works too.
11:36:55 <desrt> Igloo; everywhere
11:36:59 <desrt> it might be ubuntuness
11:37:10 <metaperl> when they say : "to produce a new computation" is that accurate?
11:37:18 <desrt> oh.  neat. not on i386.
11:37:21 <wilx> Looks somewhat nicer than the ST monad one but it needs lazy list of Word8 for input which is somewhat hard to make :/
11:37:24 <Igloo> If haskell-utils was built with hugs then that would make sense
11:37:35 <desrt> i'm guessing it's because 6.2 on powerpc didn't used to have ghci support
11:37:36 <desrt> and now it does
11:37:43 <desrt> so hugs filled the gap
11:38:14 <desrt> hm.  is that a strange thing to do?
11:38:19 <Cale> metaperl: the wording is a little slack, yeah
11:38:21 <desrt> build with hugs on powerpc but ghc in i386?
11:38:28 <metaperl> Cale, one other thing
11:38:43 <metaperl> they say a monad consists of the 3 things, the first of which si a type constructor
11:38:47 <metaperl> and then show
11:38:49 <metaperl> data m a
11:38:52 <Igloo> I don't see why it would have happened
11:39:07 <desrt> anyway.  i don't mind having hugs installed
11:39:10 <desrt> :)
11:39:27 <Igloo> What does dpkg -s haskell-utils | grep Depends    say?
11:39:32 <Gahhh> firstly, the phrase "of *that* type" is repeated too often. I confuse if that type is "m a" or "m b".
11:39:36 <metaperl> oh never mind, I think that is accurate: even though you pass in values which were made by the value constructor, you still need id the monad by the type constructor
11:39:53 <metaperl> Gahhh, you talking to me?
11:39:59 <Gahhh> metaperl, yes
11:40:03 <Gahhh> an in the open heh
11:40:47 <Cale> the "data m a = ..." is pseudocode -- you can't actually write that of course
11:40:54 <metaperl> Cale's tutorial is easier to go through than this
11:40:58 <metaperl> yes, I understand that
11:41:02 <Cale> it's just schematic to show you what sort of thing m is
11:41:15 <metaperl> I changed to this tutorial to read the catalog of monads
11:41:22 <metaperl> is combinators the thing to learn after monads?
11:41:50 <desrt> it says Maintainer: Ian Lynagh (wibble) <igloo@debian.org>
11:41:52 <desrt> :)
11:41:59 <metaperl> return should have been typed a -> m b
11:42:00 <desrt> i386: Depends: libc6 (>= 2.3.2.ds1-4), libgmp3
11:42:02 <metaperl> not a -> m a
11:42:07 <Igloo> Hmm, not that then
11:42:09 <metaperl> @type return
11:42:09 <desrt> ppc: Depends: hugs
11:42:10 <lambdabot> return :: forall m a. (Monad m) => a -> m a
11:42:12 <Cale> metaperl: hm?
11:42:22 <Igloo> Oh, I see. It is that then  :-)
11:42:30 <metaperl> the second arg to bind is return, is it not?
11:42:36 <desrt> i have ubuntu on * these days
11:42:41 <Igloo> Oh well, Debian gets it right  :-)
11:42:44 <metaperl> and the second arg has signature a -> m b, not a -> m a
11:42:45 <Cale> metaperl: you're confusing types and values
11:42:51 <desrt> Maintainer: Ian Lynagh (wibble) <igloo@debian.org>
11:42:55 <metaperl> how so?
11:42:56 <desrt> isn't this you? :)
11:43:15 <Cale> just because something has type (a -> m a) for some m, doesn't mean that it is return
11:43:20 * metaperl is grateful for ghc6, parsec, et al on Debian
11:43:31 <desrt> they're in gentoo too :)
11:43:41 <Igloo> desrt: Yes, but I assume ubuntu has rebuilt it
11:43:52 <Igloo> $ dpkg -I haskell-utils_1.6_powerpc.deb | grep Depends
11:43:52 <Igloo>  Depends: libc6 (>= 2.3.2.ds1-4), libgmp3
11:44:18 <Cale> Ubuntu: The Tastefully Naked Distribution
11:45:11 <metaperl> Cale, you started by saying I am confusing types and values and then said that all functions of signature a -> m a are not return... what is the relation?
11:45:31 <Cale> metaperl: well, you said that the second argument to bind was return
11:45:36 <metaperl> is it?
11:45:38 <Cale> no
11:45:46 <metaperl> oh, but a return function is required
11:45:53 <Cale> the second argument to bind is any function of type a -> m b
11:45:53 <desrt> Igloo; ah.  that was a strange thing for them to do
11:45:58 <metaperl> oh
11:45:59 <desrt> particularly while leaving you as the maintainer
11:46:12 <metaperl> but an instance of Monad must define return
11:46:16 <Cale> yeah
11:46:24 <metaperl> what are combinators?
11:46:33 <metaperl> is that the next step after monads?
11:46:41 <desrt> combinator = function
11:46:53 <desrt> or a function on a function, typically
11:47:10 <Cale> combinators are functions that merely combine their parameters somehow (with function applications)
11:47:24 <desrt> simple stuff like map
11:48:00 <metaperl> is there a library of combinators and an intro article on them?
11:48:23 <desrt> Prelude :)
11:48:33 <metaperl> I get the feeling that most Haskell is based around them : they are so widespread that they dont deserve such an intro
11:48:39 <metaperl> Parsec is combinator based I understand
11:49:17 <desrt> @type either
11:49:18 <lambdabot> either :: forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
11:49:46 <desrt> this is sort of like what a lot of parsec does :)
11:52:06 <Philippa_> yup. You can think of combinators as being ways of gluing existing functions together for now
11:52:48 <Philippa_> and yes, the Prelude, the List module etc are good candidates
11:53:00 <desrt> either, for example, takes two functions and returns a function that acts like one of the two functions depending on the input
11:53:13 <musasabi> and also Control.Monad if you are inclined into that direction.
11:53:16 <Philippa_> it's the obvious 'deconstructor' for Either, if you like
11:53:25 <Oejet> metaperl: s `chainl1` op  is the language  s (op s)*
11:53:38 <desrt> :)
11:53:54 <Philippa_> Oejet: normally ;-) I suspect you could do some screwy things to that using Parsec's state
11:53:54 <musasabi> flip and const are very nice unary combinators.
11:53:55 <metaperl> either sounds like an example of continuation based programming
11:54:03 <metaperl> @type flip
11:54:04 <lambdabot> flip :: forall c a b. (a -> b -> c) -> b -> a -> c
11:54:15 <musasabi> (or can one call them combinators?)
11:54:39 <Philippa_> metaperl: it's not, because one expects c to be an actual result a lot of the time
11:55:03 <musasabi> e.g. flip mapM_ myList $ \elt -> do ...
11:55:14 <Philippa_> I mean, you could use it with continuations, but try either (\x->1) (\x->2) (Left ())
11:55:59 <Philippa_> it's just \l r x -> case x of {Left -> l x; Right -> r x}
11:56:31 <Philippa_> er, nearly...
11:56:35 <Philippa_> it's just \l r x -> case x of {Left x -> l x; Right x -> r x}
11:56:44 <Philippa_> left out a couple of pattern variables, bad me :-)
11:59:07 <musasabi> Anyone feeling like to explain monads in a theoretic way (or provide a link to a good explanation)?
11:59:21 <Philippa_> musasabi: how theoretic?
11:59:28 <Philippa_> and is this for you or somebody else?
11:59:55 <jesse99> you can try http://www.nomaware.com/monads/html/
12:00:05 <musasabi> for me :-)
12:00:15 <musasabi> jesse99: that is practical, how to use monads.
12:00:35 <musasabi> Philippa_: Somekind of formal semantics would be nice.
12:00:44 <jesse99> read up on category theory then :-)
12:01:16 <Gahhh> How theoretic is theoretic ? like Wadler's papers ?
12:01:39 <Darius> musasabi: What do you mean formal semantics?  A monad is something that satisfies the monad laws (and functor laws). Full stop.
12:02:01 <Philippa_> yeah. Read the categorical definition raw, read the definition of bind in terms of map and join, consider categories to represent 'languages' (or at least their semantics)
12:02:24 <Philippa_> yeah, though a full understanding of just what that implies can take time to kick in
12:02:43 <metaperl> is there some syntax/function for taking a list of transformers and the initial value so that mothersPaternalGrandfather s = (Just s) `comb` mother `comb` father `comb` father  can be wrtten as (Just s) [mother, father, father]
12:02:56 <jesse99> hmm, it's be nice if the ghc library docs did a better job of defining ore and postconditions
12:03:03 <jesse99> pre even
12:03:04 <integral> metaperl: foldl ?
12:03:16 * Philippa_ likes the way the relationship between monads and ArrowApply is already clear from the existance of join
12:03:18 <metaperl> hi integral
12:03:23 <integral> hi metaperl
12:03:44 <metaperl> by golly, I think you are right integral
12:03:51 <musasabi> Gahhh: I tried Wadler few years ago and didn't understand it back then..
12:03:58 <Philippa_> jesse99: which kinds of funcs in question? A lot of the time the types're the only relevant preconditions, though obviously that doesn't apply to IO
12:04:16 <Philippa_> musasabi: do you grok functors and natural transformations?
12:04:19 <jesse99> Data.Map.insert for example
12:04:40 <Philippa_> if so, read the raw categorical definition with an eye towards the interpretation in the context of Haskell
12:04:46 <jesse99> says it "Insert a new key and value in the map." but doesnt define what happens if the key is already there
12:05:13 <Philippa_> I would assume that it overwrites it, but yes, that's bad
12:05:35 <Philippa_> oh, for values of overwrite that mean "acts as if overwritten but may leak memory"
12:06:06 <Philippa_> though I think that's unlikely given the time constraint for delete
12:06:16 <musasabi> Philippa_: functors yes, haven't studied natural transformations.
12:07:51 <metaperl> there's no way to short-circuit a chain of monadic computations? what if you want all further function calls to abort if you get a Nothing value?
12:08:15 <Darius> metaperl: With the Maybe monad, that's what happens.
12:08:29 <metaperl> oh
12:08:34 <Philippa_> and you can always sling a MaybeT on top
12:08:42 <integral> and you've got laziness too remember
12:09:21 <Philippa_> dunno if you've gathered the basic idea of monad transformers yet?
12:09:32 <musasabi> I have studied more mathemagical logic than category theory (which is not teached at the local math dept very much)..
12:10:04 <Philippa_> musasabi: google for natural transformation, see if you can get a tolerable intuition
12:11:45 <Darius> In the context of (functional) programming, the intuition is easy.  Natural transformations are polymorphic functions.  The naturality condition is parametricity.
12:12:19 <Darius> musasabi: You may want to look at some of Andrew Pitts Categorical Logic papers.
12:14:02 * musasabi is reading the definition at mathworld - I think I understand that. 
12:14:22 <Darius> wikipedia probably has a reasonable article on it
12:16:27 <musasabi> yes, the wikipedia one is more readable.
12:16:58 * Darius constantly rediscovers the Wikipedia.
12:20:54 <musasabi> Have to lookup Pitts articles, they seem quite interesting :-)
12:21:19 <crot> I thought you said reliable, not reasonable :P
12:27:07 <Oejet> I have a small program reading four megabyte of text from a file and parsing it into one million Integers using read like this:  lst = (map (read::String->Int) .  words) s.  The funny thing is that profiling show the program spending 93% of it's time in map.
12:28:47 <nuffer> I'm having trouble writing this algorithm: http://muer.njoerdba.com/paste/view.aspx?id=663a6556-f4a6-48d9-8c27-e47597aa347e (imperative pseudo-code) functionally with the same order of magnitude
12:28:48 <nuffer> any help?
12:30:27 <Cale> I'll have a look
12:31:06 <nuffer> really it's the step that requires marking a black
12:31:09 <nuffer> block rather
12:31:22 <nuffer> that's clearly O(1) in an imperative language, but it seems O(n) functionally
12:31:58 <Cale> That's O(size(Q)), no?
12:32:17 <nuffer> the entire algorithm is, yeah
12:32:42 <Cale> well, what are you having trouble with? This seems like an application of filter
12:33:25 <nuffer> well, see to mark a node in an imperative language
12:33:34 <nuffer> I would just say "node.marked = true;" or whatever
12:33:48 <nuffer> but if I do it functionally, I have to create a new node with its marked value set to true
12:33:52 <Cale> nuffer: you're really trying to get T, right?
12:33:54 <nuffer> and then I need to update all links to that node
12:33:54 <Darius> nuffer: You could mark the nodes by storing visited ones in a Set.
12:33:59 <nuffer> Cale, yes
12:34:19 <Cale> What are your representations for these data?
12:34:28 <nuffer> Cale, I have a list of Blocks
12:34:29 <Darius> isMarked becomes isIn markedNodes
12:34:32 <nuffer> each block contains a list of its successors
12:34:36 <sh10151> nuffer: those don't differ in algorithmic complexity though, do they?
12:34:41 <sh10151> not time complexity anyway
12:34:50 <nuffer> sh10151, which?
12:35:04 <sh10151> node.marked = true vs new node
12:35:15 <nuffer> that's the same, but if you make a new node, you need to update the links
12:35:26 <nuffer> and then update the links to the links, etc.
12:35:30 <nuffer> so it's O(n) vs. O(1)
12:35:46 <nuffer> even storing them in a set is a poor fix, that's O(logn) as opposed to O(1)
12:36:11 <Cale> nuffer: when you write "mark b" do you mean "update Q with b marked in Q"?
12:36:44 <nuffer> well, yeah, that's the functional idea of it I suppose
12:37:55 <Darius> nuffer: You may want to look at FGL and some of the other functional graph libraries.
12:38:19 <Cale> but it doesn't look like you ever use it again, so is this just  break (marked) Q ?
12:38:21 <sh10151> i see
12:38:28 <desrt> ghci is a great replacement for bc
12:38:47 <nuffer> Cale, I'm sorry, what?
12:39:02 <Cale> if marked :: Block -> Bool
12:39:12 <Cale> determines if a Block is marked
12:39:27 <nuffer> alright, I follow you so far
12:39:33 <Oejet> nuffer: INPUT: Blocks of a program,  OUTPUT: is what?
12:39:44 <Cale> then break (marked) Q will take the first n elements of Q which are unmarked, stopping at the first which is
12:39:46 <nuffer> Oejet, an ordered list of traces of those blocks
12:40:04 <nuffer> Cale, that's an O(n) operation though...
12:40:04 <Cale> but I don't really understand what it is that you're doing
12:40:16 <Cale> nuffer: yes, just like your algorithm
12:40:45 <nuffer> no... if you use an O(n) algorithm to rebuild Q with a marked b, then the algorithm becomes O(n^2)
12:41:02 <Cale> hm?
12:41:12 <Cale> Perhaps I don't understand what you're actually doing there
12:41:17 <nuffer> okay... let me give an example
12:41:50 <nuffer> we get [b1(b2, b3), b2(b4), b3(b4), b4], as a really simple example
12:42:11 <nuffer> so there, b1(b2, b3) means we have block b1, with successors b2 and b3
12:42:12 <Cale> what is "b1(b2, b3)"?
12:42:17 <Cale> oh, okay
12:42:19 <nuffer> we want
12:42:36 <nuffer> [T(b1, b2, b4), T(b3)]
12:43:01 <nuffer> a trace consisting of b1, b2, b4, followed by another trace of b3
12:43:54 <Cale> okay
12:44:18 <Cale> Which is a depth first search of that graph
12:44:34 <Oejet> nuffer: Is the block structure a cyclic graph, or just a tree?
12:44:48 <nuffer> Oejet, it can be cyclic, but won't always be
12:44:49 <Cale> looks like a DAG
12:44:52 <Cale> okay
12:45:07 <nuffer> if it weren't cyclic, the problem would be a lot easier
12:45:11 <Oejet> Heh, obviously since it's a program.
12:46:38 <Cale> You could have a look at fgl
12:46:49 <Cale> (as Darius suggested)
12:48:15 <nuffer> I wonder if I couldn't build a tree, then remove any cyclic elements from the tree by not allowing a node to reference a node of a lower depth
12:48:28 <nuffer> and then the analysis of that tree is fairly simple
12:48:32 <nuffer> will that get the same results?
12:49:11 <Darius> If I remember correctly many graph algorithms could be implemented with the same time complexities purely functionally, but they were approached quite differently.
12:49:29 <Darius> And of course, you could use ST.
12:49:31 <nuffer> I'm very much a functional programming neophyte
12:49:50 <nuffer> I've never even heard the term "graph algorithm" before, to be honest
12:49:55 <nuffer> nor do I know what ST is
12:50:11 <sh10151> is this on your own or for a class?
12:50:26 <nuffer> sh10151, it's for an independent study
12:50:40 <nuffer> my high school doesn't offer any programming classes beyond APCS, unfortunately
12:51:03 <nuffer> so I'm supposed to do the work on my own
12:51:59 <nuffer> okay, yeah, I see how to do this now
12:52:02 <nuffer> thank you all
12:52:06 <Cale> okay :)
12:52:19 <Cale> You're using a tree?
12:52:25 <nuffer> yeah
12:52:48 <nuffer> first I'm going to remove any cyclic relationships from the tree, then it's quite easy
12:55:10 <sh10151> keep it up
12:55:21 <sh10151> my high school didn't offer cs
12:55:33 <sh10151> i thought the TI 85 calculator programs were the bee's knees
12:56:34 * Darius didn't have a link cable so couldn't program TI-83 assembly, the BASIC was slow and ugly.
12:57:17 <Darius> I did write a rotation thing, and right now there's a fourier transform program on it.
13:13:24 <metaperl> fn :: Int -> Maybe [Int]
13:13:24 <metaperl> fn idx = do let l = [Just [1,2,3], Nothing, Just [], Just [7..20]]
13:13:24 <metaperl>             (x:xs) <- l!!idx   -- a pattern match failure will call "fail"
13:13:24 <metaperl>             return xs
13:13:25 <metaperl> So in the code above, fn 0 has the value Just [2,3]
13:13:48 <metaperl> I dont see how (x:xs) pattern matches successfully with Just [1,2,3]
13:15:31 <Darius> metaperl: It's using do-notation with the Maybe monad, it's matching the [1,2,3] part of Just [1,2,3] the Just is handled by (the implicit) (>>=)
13:15:59 <metaperl> how does bind handle it?
13:16:46 <metaperl> I think that is a poor question: I skipped the part on do notation
13:18:10 <Darius> the (x:xs) <- l!!idx;... translates to (l!!idx) >>= ok where ok (x:xs) = ...;ok _ = fail "pattern match failure"
13:18:50 <Darius> When you aren't pattern matching this can be simplified to the clearer, x <- m;... <=> m >>= \x -> ...
13:19:04 <Darius> Then looking at the type of (>>=)
13:19:08 <Darius> @type (>>=)
13:19:09 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
13:19:30 <Darius> The 'a' is [Int] and the 'm' is Maybe.
13:21:56 * Darius should get the free trial Painter IX while the getting is good.
13:24:45 <wilx> Hmmm...
13:24:56 <wilx> The quux.org site seems to be down.
13:25:14 <wilx> Has MissingH moved somewhere else?
13:26:15 <metaperl> Darius, (>>=) promises m as a container for both input and output. The input to (>>=) had container type Maybe. By the type signature, the output must have the same container type
13:26:44 <Darius> metaperl: It does.
13:26:54 <metaperl> [2,3] is not Just [2,3]
13:27:01 <metaperl> and not of the type Maybe
13:27:05 <Darius> metaperl: Look closer at (the second) translation.
13:27:05 <metaperl> the input was of type Maybe
13:27:20 <Cale> return [2,3] == Just [2,3]
13:27:28 <Cale> if the monad is Maybe
13:28:17 <Darius> let me rewrite the relevant parts ignoring 'fail': (l!!idx) >>= \(x:xs) -> return xs
13:28:37 <Darius> Now type check the following by hand.
13:28:43 <Darius> Er the preceding
13:28:50 <metaperl> ok
13:28:58 <metaperl> the first arg is of type Maybe
13:29:06 <metaperl> ignoring the failing cases
13:29:22 <metaperl> e.g., Just [1,2,3] is of type Maybe
13:29:29 <Cale> Maybe [Int]
13:29:47 <metaperl> oh, right, Maybe is a polymorphic type and I forgot its parameter
13:29:48 <metaperl> thanks
13:29:58 <metaperl> yes, the first arg is of type Maybe [Int]
13:30:28 <metaperl> second arg is of type [Int] -> [Int]
13:30:48 <metaperl> ([Int] -> [Int])
13:30:54 <integral> [Int] -> Maybe [Int]
13:30:55 <Cale> is it?
13:30:59 <Cale> yes
13:31:04 <Cale> [Int] -> Maybe [Int]
13:31:08 <metaperl> ???
13:31:10 <sorje> Where can one see the definition of Maybe's >>= ?
13:31:14 <metaperl> <<<---- confused
13:31:17 <Darius> metaperl: Check each subterm at at time.
13:31:22 <Cale> what is the type of (return xs) ?
13:31:26 <integral> metaperl: the function is \(x:xs) -> return xs
13:31:37 <metaperl> Just [Int]
13:31:51 <metaperl> oh! I looked at that return as one might in Perl :)
13:31:54 <metaperl> thanks integral
13:31:55 <metaperl> lol
13:32:00 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html -- search for "instance  Monad Maybe"
13:32:08 <integral> it's actually Maybe [Int].   Just is a constructor, Maybe is a type
13:32:39 <sorje> Cale, thanks
13:36:26 <metaperl> I think "build" is a better word than "return" for that return does
13:37:01 <nuffer> I think "return" is superfluous, and I don't understand why it's there
13:37:07 <metaperl> it also will not have us people in refuge from imperative-land taking it's functionality for granted
13:37:16 <metaperl> nuffer, that's cuz you are an imperative person like me :)
13:37:26 <metaperl> it does something very important
13:37:33 <nuffer> no, a lack of a return instruction is more functional than imperative
13:37:49 <integral> *blink* but a monad isn't a monad without a "return"
13:38:01 <nuffer> the last statement always carries an implicit return
13:38:01 <metaperl> it takes a value and returns a value which is container with that value
13:38:07 <SamB> well, a return looks imperative for a good reason
13:38:12 <Darius> metaperl: The name was likely chosen to be reminiscent of imperative programming.  In most cases, it occurs in the same places where return would in an imperative program.
13:38:13 <SamB> monads are imperative!
13:38:28 <metaperl> it takes a value v and creates a container m which has v in it. I.e., m v
13:38:37 <Darius> The only stumbling block is that it doesn't "jump" out of the function, but most of those uses are superfluous.
13:38:51 <integral> metaperl: only if you're thinking of the monad as a container...
13:39:05 <metaperl> integral, that was the best intro to monads I saw
13:39:11 <metaperl> and yes, that is how I think of them!
13:39:12 <Darius> metaperl: return for the Id monad is 'id'.
13:39:23 <metaperl> so it does not create a container?
13:39:34 <metaperl> hmmm
13:40:12 <Darius> metaperl: I have often stated that I don't find the "Monads As Containers" view very enlightening.
13:40:15 <metaperl> build or construct are better words
13:40:16 <metaperl> :)
13:40:33 <metaperl> what monad intro do you find enlightening?
13:40:43 <integral> sometimes it better to not bother with the words, and just rely on what the laws says it does...
13:40:56 <metaperl> as a math person, you would integral
13:41:11 * wagle doesnt find the laws very enlightening..  *<8-D
13:41:22 <metaperl> math people are ver ygood at staring at a bunch of dry definitions and getting the ponit
13:41:47 <SamB> Monads can just be so many things, I can never come up with one thing they all are.
13:42:21 <Oejet> Why is map so slow?
13:42:23 <integral> well that thing is a monad :-P
13:42:43 <metaperl> i thought map was renamed fmap
13:42:46 <metaperl> in Haskell 98
13:42:49 <SamB> integral: well, when someone asks you what a monad is, do you seriously want to answer "a monad is a monad"?
13:42:52 <metaperl> @type map
13:42:53 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
13:42:54 <metaperl> @type fmap
13:42:55 <lambdabot> fmap :: forall f b a. (Functor f) => (a -> b) -> f a -> f b
13:43:12 <metaperl> oh, map is a specialization of fmap for the list container type
13:43:14 <integral> SamB: sure
13:43:16 <Darius> Oejet: Are you sure you're interpreting the profile output right?  I believe it does it by the stack which means all the time in 'read' would also go to 'map'.
13:43:40 <kosmikus> strange decision to make that two different functions
13:43:55 <SamB> now I ask, what is the IO monad? I know what it does, sure, but what is it?
13:44:23 <Darius> SamB: An abstract datatype, so what it does is what it is.
13:44:32 <Oejet> Darius: Ah, but read doesn't even show up on the profile.
13:45:07 <SamB> Darius: how is IO abstract?
13:45:24 <Darius> Oejet: It should be linking to profiled libraries, but you can add an SCC annotation to the expression and that should be just as good.
13:45:47 <Darius> SamB: It's implementation ("what it is") is not defined, only it's behavior.
13:45:50 <Oejet> Darius: Oh, how do I add that?
13:45:58 <SamB> Darius: so?
13:46:30 <Darius> Oejet: Check the profiling documentation in the User Guide, there's a pragma {-# SCC some stuff #-} that you'd add.
13:46:46 <SamB> nobody complains when I call this black box that I have a tellivision.
13:47:32 <Darius> SamB: Exactly, the answer to what is a television is "a television is a television" ;)
13:47:33 <integral> And no one complains when you call the IO type a monad
13:48:22 <zipper> does anyone complain when you call the haskell function an arrow?
13:49:20 <wagle> it IO's behavior is not defined, then anything you do with it is not defined
13:49:41 <wagle> s/it/if/
13:50:18 <Darius> SamB: More to the point, no one complains when you say that a television shows broadcasted images even though that's not what a television "is", but what it "does".
13:50:30 <Darius> wagle: It's constrained.
13:51:49 <wagle> perfectly acceptable for it to explode and burn down my house
13:52:03 <wagle> thats just what it does
14:18:36 <Oejet> Darius: I think you are right.  Swapping in length for read resulted in 60s -> 4s running time.
14:22:12 <musasabi> read is usually very very slow.
14:30:56 <Darius> Oejet: Using GHC's Text.Read (or something like that) may help somewhat.
14:31:00 <Darius> @index read
14:31:00 <lambdabot> GHC.Read,Prelude,Text.Read
14:42:08 <metaperl> @type length
14:42:09 <lambdabot> length :: forall a. [a] -> Int
14:42:35 <cm> @type genericLength
14:42:37 <lambdabot> bzzt
14:42:46 <cm> grmpf.
14:42:54 <kosmikus> @type Data.List.genericLength
14:42:55 <lambdabot> Data.List.genericLength :: forall i b. (Num i) => [b] -> i
14:43:42 <_JusSx_> build a C function and import in Haskell
14:44:17 <wilx> Huh.
14:44:20 <wilx> Wtf?
14:44:32 <wilx> Why does genericLenght has such type?
14:44:50 <kosmikus> convenience?
14:45:30 <Darius> wilx: It's the type length should have, but doesn't for pragmatic reasons.
14:45:38 <wilx> What I would think it does is that it take something of type x and returns length. Not that it takes a list and returns some kind of number that is its length...
14:46:08 <wilx> This is weird...
14:46:15 <kosmikus> I don't understand what you mean
14:46:41 <cm> he means it should be a type class method?
14:47:08 <kosmikus> of which class? HasLength?
14:47:11 <Darius> wilx: It's not generic in that way.
14:47:11 <cm> class Measurable a where length :: Num b => a -> b ?
14:47:28 <wilx> Yeah, something like that.
14:47:38 <wilx> Darius, I see and that is what strikes me as weird.
14:47:47 <Remi> hi all
14:47:54 <wilx> I guess I got just too used to such thing from C++.
14:47:56 <Cale> @type length
14:47:57 <lambdabot> length :: forall a. [a] -> Int
14:47:59 <wilx> Think virtual methods...
14:48:10 <Darius> wilx: It's not too weird considering there is no standard "container" heirarchy.
14:48:34 <cm> mhm, overloading of functions for disjoint parameter types
14:48:35 <Cale> genericLength is just there because the fact that ordinary length returns an Int
14:48:51 <Cale> which is silly anyway
14:48:58 <Remi> which me still considers to be a wart
14:49:03 <shapr> I am silly!
14:49:04 <kosmikus> ah, you want generic haskell's count or something like that
14:49:41 <Cale> Remi: yeah, that is a wart. I don't really understand why you'd ever want it not to have the definition of genericLength
14:50:10 <kosmikus> same for map/fmap, same for removing monad comprehensions in Haskell 98 ...
14:50:17 * Igloo always feels wrong about using length, but then I'm the sort who generally uses Integer and worries about converting things when interfacing to libraries like ncurses
14:50:21 <kosmikus> I think a lot of things have been done just to shield users from type classes
14:50:26 <Darius> Cale: I believe the reasons were mostly performance and lessening ambiguity.  One -very- rarely needs the generic* functions.
14:50:34 <Igloo> I mean, what if my screen is more than 2^32 lines tall, eh? It's just wrong, dammit!
14:50:49 <Cale> Igloo: heh
14:51:04 <Darius> Igloo: When that happens you'll have 64 bits for sure.
14:51:07 <kosmikus> efficiency is not an issue; ghc uses SPECIALIZE anyway
14:51:07 <Remi> well, if it was to shield users from typeclasses it (arguably) should've been Integer
14:51:18 <Remi> as numeric constants default to Integer too
14:51:39 <Darius> kosmikus: Only if it specializes to Int, it defaults to Integer which are slower.
14:51:58 <Cale> Type classes are already at the point where they're one of the first things you have to teach new users
14:52:20 <Darius> Cale: Typeclasses are possibly the truly interesting part of Haskell.
14:52:23 <kosmikus> Darius: yes, but it's always your choice if you use Int or Integer, and if you're after efficiency, you can always choose Int
14:52:24 <Cale> (just in order to give a proper description of types)
14:52:33 <Darius> Or perhaps "individual" might be better.
14:53:08 <Igloo> Someone should look at a load of Haskell code and work out how often the type would be infered to be Int anyway
14:53:09 <kosmikus> qualified types are nice; I'm not sure if everything that's called "type classes" today is nice
15:02:06 <pesco> shapr: Thanks for pointing to the PiSpigot paper again on LtU! I'm severely enjoying the algorithms.
15:02:49 <vincenz> Hi
15:02:59 <pesco> Hi.
15:03:06 <vincenz> bit ot but
15:03:10 <vincenz> anyone got a 64bit proc?
15:03:20 * pesco shakes his head.
15:03:27 * vincenz sighs
15:03:28 * Remi dreams
15:04:57 <tromp> we wished!
15:07:42 <vincenz> :/
15:09:01 * RemiTurk wonders why xchat suddenly seems to be so difficult after hardly using it for a few years anymore
15:11:13 <kosmikus> because it has a GUI?
15:12:04 <RemiTurk> I seem to remember it has had a GUI for years..
15:12:27 <RemiTurk> the problem could be that it's not scriptable in haskell though ;)
15:12:29 <Darius> Uh, did it never not have a GUI?
15:12:40 <Darius> s/never/ever
15:13:20 * RemiTurk has no idea what the X in xchat stands for ;)
15:13:42 <pesco> Extraneous mabye.
15:13:47 <RemiTurk> btw, has anyone tried :info <something> twice in ghci?
15:14:22 <pesco> Now I have... Seems to work as expected.
15:14:51 <RemiTurk> it seems the first :i since starting ghci gives less instances...
15:15:04 <RemiTurk> (irrespective of what type you're asking info about)
15:15:27 <pesco> Oh, you might have imported something in the meantime?
15:15:44 <RemiTurk> I might
15:15:52 <RemiTurk> but then I'd need a straightjacket ;)
15:16:33 <RemiTurk> starting ghci, :i Bool enter arrow-up enter...
15:16:40 * RemiTurk files a bug
15:16:57 <pesco> Indeed, well spotted.
15:16:58 <RemiTurk> (couldn't find it on sourceforge or ghc-bugs archive)
15:18:43 <pesco> This is an interesting bug. I wonder what in hell is causing it.
15:19:19 <musasabi> I think it is because more modules are loaded to get all the information for the first :i.
15:19:20 <pesco> This being Haskell and all...
15:19:49 <pesco> musasabi: Ah, obviously.
15:20:06 <pesco> The first call only returns the stuff from GHC.Base.
15:20:21 <RemiTurk> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2005-March/004850.html
15:20:50 <RemiTurk> not only from GHC.Base
15:20:57 <RemiTurk> also from at least GHC.IOBase
15:21:15 <RemiTurk> which probably isn't an all that fundamental difference
15:21:21 <pesco> I don't see any instances from that module.
15:21:26 <RemiTurk> :i IO
15:21:35 <pesco> Ah.
15:21:58 <pesco> So yeah, there must be some set of base modules.
15:22:06 <RemiTurk> hm, :i Data.Set.Set (twice) also gives interesting results
15:22:08 <shapr> pesco: spigot algorithms are a good choice for lazy eval
15:22:29 <musasabi> Doing :i Bool and then :i Int and comparing that to :i Int, :i Int and :i Bool :i Bool confirms the theory.
15:22:34 <pesco> shapr: Do you grok all the math in that paper? (Or anyone for that matter?)
15:22:55 * RemiTurk hears about spigot for the first time
15:23:48 <musasabi> Btw if someone is looking for faster Strings cords from boehm GC would be a good candidate. They are an efficient tree structured immutable string type.
15:23:54 <RemiTurk> all of Data.Set.Set, Data.Map.Map and Control.Monad.ST.ST give various instances defined in "their own module" the first time, and Show in addition the second time
15:24:05 <RemiTurk> cords = ropes?
15:24:06 <Darius> pesco: The spigot algorithm paper?
15:24:12 <musasabi> RemiTurk: yes.
15:24:43 <Darius> musasabi: Couldn't they be implemented in Haskell without too much trouble?
15:24:44 <pesco> Darius: "Unboundet Spigot Algorithms for the Digits of pi" by Jeremy Gibbons
15:25:13 <musasabi> Darius: of course, but looking at pointers how others did it is not a bad idea.
15:25:57 <shapr> musasabi: how do cords compare to ShowS ?
15:26:02 <RemiTurk> ropes/cords seem quite interesting for haskell: their main disadvantage is IIRC that array operations on them are slow, which they are anyway in haskell
15:28:54 <shapr> g'day neilc_
15:29:01 <musasabi> shapr: well they are like proper Strings ;)
15:29:09 <shapr> neilc_: How's code in the sunny south?
15:30:08 <neilc_> shapr: great :)
15:30:11 <neilc_> morning all
15:30:36 <shapr> pesco: I don't remember, I haven't looked at that paper since IOHCC 2004
15:30:55 <pesco> shapr: No worries, I'll figure it out eventually.
15:32:02 <shapr> I had the most fun with Ulf Norell's program that made every Haskell program alpha equivalent to every other Haskell program. Anything that imports both Data.Generic and Template Haskell into its main module is going to be *fun* !
15:32:06 <pesco> I just wanted to say thanks, because I missed it at IOHCC but I've been wanting to know how to properly calculate pi's decimal digits for a long time (since seventh grade, I think).
15:32:29 <shapr> Glad you liked the post :-)
15:33:45 <shapr> I'm still recruiting for the second issue of TMR, which will be a month late...
15:33:58 <shapr> I was hoping to have something fun for the April 1st issue, too bad I don't have time.
15:35:00 <pesco> :.( Oh well, let's just put a prank in the next issue anyway, just hide it very well.
15:37:06 <pesco> Oh heh, I figured it (the math) out. Fun!
15:37:17 <Darius> Deriving the quadratic formula was something I had wanted to do for a while until I sat down and did it sometime in high school.
15:37:39 <pesco> Darius: Which one is the quadratic formula?
15:39:08 <Darius> -b+/-sqrt(b^2*b-4ac)/(2a)
15:39:23 <TheHunter> shapr, in that case, count me in.
15:39:38 <pesco> Darius: Oh, that's what it's called in english. I'd been wondering about that.
15:40:42 <RemiTurk> it's called the "ABC formule" in dutch
15:40:45 <TheHunter> pesco, hmm, does it have a name in german?
15:41:08 <pesco> Our teacher called it (literally from German) "the solving formula" which has been amusing me and my surroundings ever since.
15:41:24 * RemiTurk wonders whether the guy who invented it had ABC as his surname
15:42:38 <wilx> Hmm, how do I write Unicode char literal?
15:42:44 <Darius> RemiTurk: It was made either 2000 or 4000 years ago.
15:42:58 <wilx> Something like \u123
15:43:06 <pesco> They had all kinds of strange names back then.
15:43:22 <pesco> wilx: I think that form is deprecated, if supported at all!
15:43:34 <wilx> Ok, what do I use then?
15:43:56 <wilx> chr?
15:43:59 <pesco> wilx: An editor with proper input methods. *cough* And a Haskell system that supports UTF-8 input.
15:44:13 <pesco> Oh, I'm sorry, I misunderstood.
15:44:29 <pesco> Forget what I said.
15:44:33 <RemiTurk> Darius: I wouldn't be surprised at all if it has independently been invented many times. Perhaps even by men named ABC, Quadratic etc ;o)
15:45:07 <cm> RemiTurk: the name "ABC formula" is also used in german (education)
15:45:30 <cm> RemiTurk: along with "PQ formula", for the special case of a=1, b=p, c=q
15:45:33 <pesco> wilx: '\xFFFF'
15:45:47 <wilx> Ok, thanks.
15:46:29 <thunkee> pq is not a special case :)
15:48:25 <cm> it surely is for a useful definition of "special case" :)
15:48:54 <Darius> thunkee: Are you thinking "exceptional" case?
15:55:15 <musasabi> Why is [d| $(foo) = foobar $(bar) |] illegal?
15:55:55 <Igloo> You can only splice expressions and declarations
15:56:04 <Igloo> $(foo) is trying to splice a var
15:57:23 <musasabi> So there is no way to make a temporary top-level variable with an unique name that can be referred to later?
15:58:59 <Igloo> It depends what "later" really means. You can always do it by using smart constructors to put [d| $(foo) = foobar $(bar) |] together, though
16:00:24 <Igloo> If you can do the later bit with [d| foo = foobar $(bar); bar = $( ... [| foo |] ... ) |] then you can, well, do that  :-)
16:00:40 <Igloo> Oh, I didn't mean to use bar twice there
16:01:56 <wilx> Hmm, TH, something I still need to look at.
16:02:27 <musasabi> hmm the later part needs to be a dynamic declaration too.
16:02:45 <musasabi> that is an instance with the typepart not statically known.
16:13:11 <Lemmih> Good morning, #haskell.
16:13:20 <shapr> good evening Lemmih
16:15:08 <cm> hey shapr
16:16:12 <Lemmih> What's up, shapr?
16:17:32 <musasabi> got things working - now deriving a Typeable works too :-)
16:17:36 <musasabi> -> sleep
16:25:27 <hellish> Hello all, I'm trying to compile the Pretty module with ghc and it's complaining about a missing Ubiq module. Anyone know where I could find it?
16:25:30 <wilx> w00t!
16:25:33 <wilx> It works!
16:25:58 <wilx> One thing though. How bad is this?
16:25:58 <wilx> hSetBinaryMode inpf True
16:25:58 <wilx>     str <- hGetContents inpf
16:25:58 <wilx>     (i::[Word8]) <- return $ map (fromIntegral . fromEnum) str
16:26:44 <Lemmih> @type Foreign.C.String.castCharToCChar
16:26:51 <lambdabot> Foreign.C.String.castCharToCChar :: Char -> Foreign.C.Types.CChar
16:27:39 <hellish> oy, nevermind. Forgot to pass -cpp.
16:28:03 <wilx> Hmm...
16:28:13 <wilx> Checking...
16:29:31 <wilx> I am more concerned about that it whether it does not interpret the bytes as UTF-whatever sequences...
16:30:09 <Lemmih> It's just stripping the last 24 bits.
16:30:52 <Lemmih> Oh wait. Concerned about your function or castCharToCChar?
16:31:00 <wilx> My function.
16:31:13 <wilx> hGetContents...
16:31:26 <wilx> I have switched on binary mode but one never knows.. :)
16:31:36 <pesco> Lemmih: I think as of current, it is safe to assume hGetContents always returns "bytes".
16:31:57 <pesco> Actually, I think the documentation even states the fact.
16:32:26 * Lemmih redirects pesco's input to wilx.
16:32:38 <pesco> Oh, heh. Thanks.
16:34:27 <wilx> Heh.
16:34:29 <wilx> Ok.
16:35:54 <johs> There's this thing I find strange. The $-function.
16:35:58 <johs> I understand what it does.
16:36:07 <johs> But why do people use it?
16:36:20 <wilx> f $ g x?
16:36:26 <Lemmih> putStrLn $ "That's great" ++ ", johs"
16:36:34 <pesco> :)
16:36:40 <wilx> Because it is easier than to write () around.
16:36:45 <Cale> johs: Because it has really low precedence
16:36:59 <johs> Oh, that's it?
16:37:01 <johs> Right.
16:37:04 <pesco> forkIO $ do something cool with lots of combinators in
16:37:05 <johs> Fear of parentheses.
16:37:09 * johs jots it down.
16:37:12 <Cale> johs: normally function application binds tighter than everything else
16:37:22 <Cale> $ binds about as weakly as possible
16:37:27 <wagle> what do people think about acl2?
16:37:39 <Cale> wagle: acl2?
16:37:43 <johs> wilx, Cale: Thanks.
16:37:44 <wilx> ACL2?
16:38:26 <wagle> ACL2 is both a programming language in which you can model computer systems and a tool to help you prove properties of those models.
16:38:36 <johs> So, it's considered good style to use $ rather than parenthesizing?
16:38:39 <wagle> </quote>
16:38:47 <Darius> johs: It's helpful to avoid needing to balance parentheses, which makes it easier to add and change functions
16:38:56 <wilx> Hmm, dunno, I use it just because it is more convenient :)
16:39:01 <Lemmih> johs: Sometimes. Overuse can be ugly.
16:39:08 <Darius> johs: Either way is quite accepted.
16:39:10 <jesse99> hmm, is there no built in function to figure out whether an instance of Either is left or right
16:39:22 <Darius> @index isLeft
16:39:23 <lambdabot> bzzt
16:39:24 <wagle> case
16:39:37 <Darius> @type either (const True) (const False)
16:39:39 <lambdabot> either (const True) (const False) :: forall a b. Either a b -> Bool
16:39:46 <RemiTurk> isLeft = either (const True) (const False) :)
16:39:48 <johs> I'm reading the Darcs source code.
16:39:58 <johs> (It's rumored to be a good read.)
16:40:37 <RemiTurk> johs: you cannot always use $ however, e.g. with runST
16:40:51 <RemiTurk> (when using rank-n (n>1) types, to be more specific)
16:41:15 <RemiTurk> which is why some people (though not me) think it shouldn't be used at all just to prevent having to use braces
16:41:39 <jesse99> so, i'm confused there is no isLeft, but there is a function called either?
16:42:28 * RemiTurk notices Darius already gave isLeft in terms of either years ago
16:42:52 * jesse99 notices that he barely knows haskell
16:43:00 <RemiTurk> @type either
16:43:01 <lambdabot> either :: forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
16:43:22 <RemiTurk> jesse99: it may be a good idea to read the whole prelude someday
16:44:00 <RemiTurk> there's a huge amount of functionality there, and you'll spare yourself quite a bit of "oh, I didn't know that already was a standard function" moments
16:44:14 <jesse99> well, i'm looking at the prelude from the standard, but i thoought there might an an isLeft lurking somewhere else
16:45:13 <RemiTurk> nopes
16:45:17 <Darius> You'd expect it to be in Data.Either, but the only thing there is either.
16:45:28 <Darius> At least according to :browse
16:45:44 <jesse99> yeah, i see what you did know
16:46:02 <Darius> Though I'd have to say, if I were only to have one function on Either, either'd be it.
16:46:25 * jesse99 would rather not be restricted to one function :-)
16:46:34 <wagle> i almost always open up the prelude with xemacs when i open up a haskell program..  sometimes just the prelude
16:46:49 <RemiTurk> I have missed it too, but I don't really miss it all that often anymore (just like isJust and isNothing): often using a "case .. of" or one of either/maybe/fromMaybe is a better idea
16:47:08 <jesse99> I used to do that with hugs, but the ghc prelude file doesnt look near as useful
16:47:44 <wagle> i havent really used either, but what is wrong with case (Left x) -> ___ ; (Right x) -> ...
16:48:06 <jesse99> I wanted to write something like "filter (\term -> is_left term) parsed"
16:48:06 <wagle> (i dont use case much either..  8-p
16:48:13 <jesse99> a case seemed excessive
16:48:28 <wagle> ah
16:49:11 <wagle> i think i remember something in the nomaware monad tutorial about this situation
16:50:35 <RemiTurk> concatMap (either return (const [])) ?
16:51:25 <RemiTurk> or if you really like monads: ... >>= either return (const mzero)
16:52:44 <wagle> i think it was to illustrate mplus, etc
16:52:48 <RemiTurk> or mapMaybe (either Just (const Nothing))
16:53:59 <RemiTurk> msum [Left "some error", Right 42, Left "some other error"] == 42 ?
16:54:19 <Darius> RemiTurk: It should.
16:54:28 <RemiTurk> (which could be used instead of isRight, but not instead of isLeft)
16:54:38 <RemiTurk> Darius: but only after import Control.Monad.Error
16:54:49 <RemiTurk> and only for Either String a
16:54:55 <Igloo> @type Monad.msum
16:54:56 <jesse99> I apreciate the help, but I'm still stuck on const :-)
16:54:57 <lambdabot> Monad.msum :: forall a m.
16:54:57 <lambdabot> 	      (Control.Monad.MonadPlus m) =>
16:54:57 <lambdabot> 	      [m a] -> m a
16:55:19 <Igloo> DYM Right 42?
16:55:19 <jesse99> oh, i'm starting to get it
16:55:19 <RemiTurk> jesse99: okay, perhaps we got carried a way a little too far
16:55:23 <Darius> @type foldl' (flip $ mplus . either Right Left)
16:55:24 <lambdabot> bzzt
16:55:35 <jesse99> yeah
16:55:38 <RemiTurk> Igloo: no I don't :)
16:55:50 <RemiTurk> Igloo: yes I do
16:55:55 <Darius> @type Data.List.foldl' (flip $ mplus . either Right Left)
16:55:56 <lambdabot> bzzt
16:55:58 <Darius> @type const
16:55:59 <lambdabot> const :: forall a b. a -> b -> a
16:56:20 <jesse99> I see how and why you used it now Darius
16:56:30 <wagle> Prelude> :m Control.Monad.Error
16:56:30 <wagle> Prelude Control.Monad.Error> msum [Left "some error", Right 42, Left "some other error"]
16:56:33 <wagle> Right 42
16:57:16 <RemiTurk> indeed, misreading ones own code is apparently quite easy ;)
16:57:30 <nuffer> is an O(n) DFS possible?
16:59:27 <Darius> For a graph?
16:59:40 <nuffer> yes
16:59:47 <Darius> Should be.
17:00:01 <nuffer> any links to some pseudo-code (or actual code)?
17:00:15 <nuffer> or any description of the algorithm for that matter?
17:00:38 <Igloo> It's not without mutable datastructures is it?
17:00:52 <jesse99> are there any haskell style guides?
17:01:12 <nuffer> Igloo, yeah, that's what I was thinking
17:01:26 <RemiTurk> @wiki HaskellStyle
17:01:26 <lambdabot> http://www.haskell.org/hawiki/HaskellStyle
17:01:45 <nuffer> but I'm no PhD scientist who's been studying DFSs for eighteen years
17:02:04 <nuffer> so I could be very wrong about that
17:02:47 <Darius> http://www.cs.chalmers.se/~augustss/AFP/overview.html
17:02:59 <Igloo> Actually, with a DiffArray mapping Node -> BeenHere it might be
17:03:21 <nuffer> Igloo, I don't quite follow you
17:03:32 <Darius> nuffer: I think there are also some slick fusion based derivations too somewhere.
17:03:49 <RemiTurk> graph colouring using a diffarray which implements a O(1) array
17:04:07 <RemiTurk> ehm, that may not make anything clear
17:04:11 <Igloo> nuffer: Which bit?
17:04:28 <nuffer> isn't that essentially using a mutable data structure, what you're saying, Igloo?
17:04:37 <Darius> nuffer: The paper is "Structuring Depth-First Search Algorithms in Haskell" in the above linke.
17:05:02 <Darius> nuffer: DiffArray has a pure interface.
17:05:03 <Igloo> Yes, but DiffArrays hide the fact it's a mutable data structure
17:05:07 <nuffer> Darius, yeah, I'm reading it now
17:05:13 <RemiTurk> has a paper "Lazy Depth-First search and linear graph algorithms in haskell" here which is called linear-dfs.ps
17:05:17 <nuffer> the thing here is, I'm not actually coding in haskell
17:05:31 <nuffer> this was just the only channel I could find where people would talk about pure functional programming
17:05:35 <Igloo> Ah
17:05:50 <Darius> nuffer: What language are you coding in if any, then?
17:05:57 <nuffer> I'm coding in Nemerle
17:06:02 <Darius> Ah
17:06:02 <RemiTurk> which seems to be almost exactly the same as the one Darius linked to
17:06:10 <nuffer> so it's not strictly necessary that I make this pure functional, but I'd like to if possible
17:06:45 <Darius> nuffer: If you haven't looked at FGL (the Functional Graph Library) and it's associated papers, they would likely be very helpful.
17:07:03 <nuffer> okay
17:07:19 <nuffer> so, what I've gotten from this paper
17:07:27 <nuffer> is that there is no way to maintain efficiency without using monads
17:08:09 <nuffer> i.e. it needs to be imperative at some point
17:09:07 <nuffer> I guess I need to read up on monads, since I really don't understand them
17:09:32 <nuffer> what's the best introductory page?
17:10:25 <cm> "All about monads"
17:10:31 <cm> ..is very very good
17:11:02 <Z0z0> we used this book in our class it is really good http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
17:11:54 <jesse99> man, haskell really needs an intermediate or advanced haskell book
17:14:17 <Cale> nuffer: I recommend "All about Monads" as well. I also wrote an introductory page about monads, taking an analogy with containers
17:14:39 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
17:14:46 <Lemmih> jesse99: What do you feel is missing from the current books?
17:15:10 <jesse99> well, i've only read the craft of functional programming
17:15:39 <jesse99> which is a pretty good intro, but a poor reference and glosses over a ton of important stuff
17:15:58 <Lemmih> Like what?
17:16:13 <jesse99> the section on monads for example, is nearly useless
17:17:07 <jesse99> and the many ghc extensions seem to be only documeneted in papers which are often well written, but not really a substitute for real documentation
17:18:40 <jesse99> i know I learned a ton from advanced c++ books, and haskell seems to be at least as deep (altho with less wirdness)
17:18:58 <wagle> less?
17:19:06 * wagle giggles himself to death
17:19:28 <Lemmih> I found the monads pages very concise and enjoyable.
17:19:29 <jesse99> did you read that right wagle? i said that haskell has less wierdness than c++
17:19:30 <wagle> (mind you, i find C++ pretty obvious)
17:20:16 <wagle> i _like_ haskell's weirdness..
17:20:29 <Lemmih> Haskell is weird?
17:21:18 <jesse99> i dont really know it well enough, much of it seems really clean though
17:21:25 <Lemmih> jesse99: Have you checked the GHC users guide for GHC extensions?
17:21:30 <jesse99> ghc's error messages usually confuse me however
17:21:37 <jesse99> yeah
17:21:47 <nuffer> what's the advantage of monads over mixed functional/imperative?
17:22:29 <wagle> weird doesnt mean bad
17:23:03 <wagle> referential transparency
17:23:10 <Lemmih> nuffer: Obtaining sequentation while keeping it purely functional.
17:23:22 <jesse99> i woulnt call that weird wagle
17:23:33 <Lemmih> Is 'sequentation' even a word?
17:23:41 <nuffer> how is that possible?
17:23:43 <wagle> though i dont have trouble algebraically transforming imperative programs
17:23:43 <RemiTurk> wagle: hm, "I find C++ pretty obvious", may I conclude you don't consider it "overly complicated" then?
17:23:49 <RemiTurk> (has a nice quote here ;))
17:23:54 <nuffer> aren't you just encapsulating the imperative parts?
17:24:34 * jesse99 dares wagle to look at boost::function or boost::lambda and call it "pretty obvious"
17:24:37 <Lemmih> nuffer: No.
17:24:42 <wagle> nuffer asked what the advantage was.  my answer was "referential transparency:"
17:24:51 <jesse99> oh
17:25:04 <nuffer> what is the difference between a monad and merely encapsulating imperative parts of a mixed language?
17:25:40 <Cale> monads aren't all for imperative things
17:25:49 <Cale> they're more general than that
17:26:10 <humasect> but you can do those things naturally in ipmerative bits of mixed languages
17:26:44 <humasect> no ? =)
17:26:56 <wagle> i understand the mindset that produces C++..  i havent yet wrapped my brain around category theory
17:27:48 <nuffer> http://www.nomaware.com/monads/html/meet.html for the "An Example" why do you need a monad there?
17:27:54 <RemiTurk> haskell /= category theory
17:28:25 <RemiTurk> I think I understand (Haskells) Monads quite well, but that doesn't mean I understand all of the CT behind it
17:28:38 <nuffer> couldn't you just write (forgive my syntax) Mother(s : Maybe Sheep) : Maybe Sheep { match (s) | Sheep => s.Mother | Nothing => Nothing }
17:28:42 <nuffer> and a similar Father function
17:28:42 <wagle> yes, i know that, but i didn't feel like saying that at the time
17:28:55 <nuffer> and then just write Father(Father(Mother(mySheep))) ?
17:29:39 <Lemmih> nuffer: Explicitly check for Nothing is bad.
17:29:43 <wagle> category theory seems to be the pure distilled essence of what i find weird, and some of that shows up most often in haskell
17:29:45 <Lemmih> s/check/checking/
17:29:59 <nuffer> why?
17:30:33 <Lemmih> It requires the programmer to write a lot of error prone code which isn't necessary.
17:31:01 <nuffer> but the monad described in the example still explicitly checks for nothing, just in a different place
17:31:26 <wagle> i need to get back to beating my way through barr and wells, 3rd edtn
17:31:55 <nuffer> why is that not considered inelegant?
17:31:58 <Gahhh> nuffer, aren't the monad version a lot shorter ?
17:32:11 <Lemmih> nuffer: Yes, but it's only once instead of every time you use a monad.
17:32:57 <nuffer> what I'm really asking is, is that an example where a monad was the only solution to the problem?
17:33:03 <Gahhh> no
17:33:07 <nuffer> or was that just an example where a monad was bezst
17:33:09 <nuffer> best rather
17:33:21 <Lemmih> nuffer: You can always do it without monads.
17:33:22 <Gahhh> it's a good monad example
17:33:45 <nuffer> what about I/O, aren't monads required there?
17:33:51 <Gahhh> no heh
17:33:57 <Gahhh> but they make it better
17:34:08 <RemiTurk> some old haskell-version didn't have monads yet
17:34:09 <nuffer> how could you have I/O in a pure functional language without a monad?
17:34:21 <RemiTurk> main :: [Input] -> [Output]
17:34:29 <Gahhh> nuffer, google for Tackling the Awkward Squad
17:34:46 <aFlag> does anyone know what debian package has the POpen lib?
17:34:49 <nuffer> RemiTurk, but that severely limits the program's capabilities
17:35:11 <nuffer> you can't sequence Input, Output, more Input, more Output
17:35:33 <RemiTurk> nuffer: laziness
17:36:07 <nuffer> what about laziness?
17:38:23 <Lemmih> nuffer: Monads offer three simple utility functions which are optimized away is most cases.
17:47:25 <nuffer> can I imagine monads as syntactic sugar for passing around a global state?
17:47:35 <RemiTurk> yes
17:47:36 <nuffer> (while keeping this global state hidden from the programmer)
17:47:38 <Darius> nuffer: no.
17:47:40 <RemiTurk> more or less
17:47:42 <RemiTurk> uhm
17:47:47 <Darius> In some cases you can.
17:48:04 <nuffer> when? and when not?
17:48:06 <Cale> If that's what the monad does for you, you can think of it like that
17:48:09 <RemiTurk> uhm, in the case of IO?
17:48:15 <Darius> nuffer: When the monad is as tate monad.
17:48:18 <Cale> like in the case of IO and State
17:48:22 <Darius> s/tate/state
17:48:31 <Cale> but not for most monads
17:48:37 * RemiTurk slaps forehead for s/monads/IO/ ;)
17:48:39 <Darius> IO can be viewed as a state monad, but it can also be viewed other ways.
17:49:01 <Darius> In fact, SPJ suggests that a continuation based view may be more elegant.
17:50:10 <RemiTurk> does that have any relation with the mostly-forgotten-by-me thing about GHC internally having to treat RealWorld# as a _very_ special case?
17:51:20 <Darius> RemiTurk: I don't think so.  It's more to do with concurrency.
17:51:26 <Darius> If I remember correctly.
17:51:28 <RemiTurk> aha
17:52:02 <shapr> Darius: where does SPJ suggest that? Awkward Squad maybe?
17:52:11 <Darius> shapr: Yes
17:52:58 <shapr> Sounds like a good reason for me to re-read that paper.
17:55:27 <shapr> I agree that Haskell needs an intermediate to advanced book.
17:56:11 <shapr> But, I'm not sure that anything smaller than TaPL would contain enough useful information to be well rounded.
18:02:25 <metaperl> I need some help on List.mplus --- and it does not appear in the online report...
18:02:47 <metaperl> exercise 3 in all about monads says it is useful to solve that problem, but it does not appear to be
18:02:49 <RemiTurk> it's not in List, but in Monad
18:03:00 <metaperl> http://www.nomaware.com/monads/html/exercises.html
18:03:01 <dons> Control.Monad.mplus
18:03:16 <metaperl> yes, but it does not appear to be relevant based on the definition of mplus
18:03:25 <metaperl> you are supposed to return a list of all parents
18:03:46 <metaperl> I think ++ is more in order
18:03:55 <metaperl> could someone look at exercise 3?
18:04:56 <Darius> mplus = (++)
18:05:25 <metaperl> oh .. do the GHC docs have this defintion? where would I find it
18:06:34 <Darius> http://www.haskell.org/onlinereport/monad.html like RemiTurk said.
18:06:45 <Darius> The definition wouldn't be in the documentation.
18:07:09 <Cale> http://www.haskell.org/onlinereport/monad.html
18:07:10 <dons> instance MonadPlus [] where
18:07:10 <dons>    mzero = []
18:07:10 <dons>    mplus = (++)
18:07:12 <Cale> yeah
18:08:03 <metaperl> RemiTurk said Control.Monad and I did not see a Control link so that threw me...
18:08:16 <metaperl> but yes, I now see the definition and it makes sense
18:11:42 <sh10151> TaPL?
18:13:19 <Darius> No, dons said Control.Monad.  RemiTurk just said "it's not in List, but in Monad"
18:13:47 <Darius> sh10151: Types and Programming Languages if I remember correctly
18:14:24 <autrijus> yup.
18:19:41 <wilx> And what would be TPL that you need to add the a there?
18:21:03 <Darius> Whatever HtDP would be.
18:22:00 <Gahhh> I should stop writing haskell and eat something lol.
18:22:28 <autrijus> I know that feeling :)
18:23:17 <wilx> :)
18:23:18 <Philippa_> wilx: unpronounceable
18:23:41 <wilx> In English?
18:23:44 <Philippa_> (am heading bedwards, but TaPL can be pronounced "tapple")
18:23:49 <wilx> Tee Pee eL sounds ok.
18:24:29 <Philippa_> only insofar as Tee Ell Ay does
18:25:43 <shapr> yeah, sleeptime
18:26:12 <wilx> Hmm, dunno, in Czech TPL sounds completely pronouncable as it is :)
18:26:21 <Spark_> heh
18:26:25 <Spark_> "tuple"
18:26:38 <Spark_> thats how i'd read it
18:29:18 <wagle> any of you that i havent asked yet have any opinions about acl2?
18:31:06 <wagle> good?  bad?  okay?  missing something important?
18:33:59 * Darius remembers Painter IX
18:35:51 <wilx> Hmm...
18:36:03 <wilx> Is there Haskell 2 wish list?
18:36:08 <RemiTurk> yes
18:36:10 <wilx> Or something similar?
18:36:12 <wilx> Where?
18:36:13 <RemiTurk> somewhere on the wiki
18:36:23 <wilx> @wiki WishList
18:36:23 <lambdabot> http://www.haskell.org/hawiki/WishList
18:36:26 <wilx> Hah!
18:36:27 <wilx> Yay!
18:36:40 <Darius> gah!
18:36:51 <wagle> @wiki dwim
18:36:51 <lambdabot> http://www.haskell.org/hawiki/dwim
18:37:05 <humasect> ?
18:37:10 <wagle> o_O
18:38:12 <wagle> awww.. i thought that was a hit for "Do What I Mean"
18:39:56 <wagle> but the wiki wishlist isnt what i remember seeing maybe a year ago
18:42:34 <Darius> @wiki HaskellTwo perhaps?
18:42:34 <lambdabot> http://www.haskell.org/hawiki/HaskellTwo perhaps?
18:45:19 <wagle> @wiki jhdfdjhfksjdhernbfsdj
18:45:20 <lambdabot> http://www.haskell.org/hawiki/jhdfdjhfksjdhernbfsdj
18:45:24 <wagle> QED
18:45:30 <wagle> sigh
18:45:35 <wilx> Oh.
18:45:37 <wilx> Hehe.
18:45:50 <wilx> But WishList and HaskellTwo do exist :)
18:46:22 <wagle> but "http://www.haskell.org/hawiki/HaskellTwo perhaps?" probably doesnt
18:47:43 <bourbaki> moin
18:48:12 <Lemmih> Greetings, bourbaki.
18:48:24 <bourbaki> Lemmih: you dont sleep as well do you :)?
18:50:41 <Lemmih> I just woke up some hours ago.
18:51:44 <bourbaki> oh so youre not in europe :)?
18:53:12 <Lemmih> I am (: But my sleep habits aren't governed by the rules of the mundane.
18:53:46 * Lemmih is a member of TeamSuccGMT.
18:54:18 <Lemmih> @wiki TeamSuccGMT
18:54:18 <lambdabot> http://www.haskell.org/hawiki/TeamSuccGMT
18:54:27 <wagle> Lemmih: how many hours in a "day" (ie, sleep cycle)?
18:54:47 <wagle> @wiki TeamPredGMT
18:54:47 <lambdabot> http://www.haskell.org/hawiki/TeamPredGMT
18:54:53 <bourbaki> ?
18:54:54 <Lemmih> About 26.
18:55:20 <wagle> Lemmih: i did that for about 3 months..  worth doing once
18:55:30 <dons> @wiki TeamGMT+11
18:55:30 <lambdabot> http://www.haskell.org/hawiki/TeamGMT+11
18:55:56 <bourbaki> +11??
18:57:04 <dons> sure.
18:57:44 <bourbaki> where is that?
18:57:49 <bourbaki> what country that is
18:58:12 <wagle> anyone use common lisp?  do you have a favorite?
18:58:27 <dons> somewhere 11/24ths of the world further East than GMT...
18:58:28 <wagle> favorite implementation, that is..,.
18:58:29 <bourbaki> wagle: sbcl
18:58:42 <Spark_> and tokyo wobbles a bity
18:58:45 <Spark_> 7.0
18:58:49 <bourbaki> dons: thats not a place i can drink cocktails at
18:58:59 <humasect> 16ths
18:59:00 <bourbaki> so whats right of japan?
18:59:06 <dons> yeah it is - what are you talking about.
18:59:19 <bourbaki> i have heared of a insula once in y2k
18:59:20 <dons> bourbaki: you're latitude is all wrong.
18:59:26 <dons> your
18:59:45 <dons> think around -36 S..
18:59:55 <dons> sorry, -33 S
19:00:49 <bourbaki> ok so whats post +7?
19:01:11 <dons> +7 N, hmm. phillipines?
19:01:22 <dons> or GMT+7?
19:01:27 <wagle> au
19:01:37 <dons> bang!
19:02:01 <dons> Perth is +8
19:02:06 <humasect> phillipines and some taiwan/china i think..
19:02:08 <dons> Maybe Jakarta is +7.
19:02:13 <humasect> yes
19:02:17 <dons> Kuala Lumpur
19:02:40 <bourbaki> ok and whats in +11?
19:02:47 <humasect> it stops at +8 ..
19:02:54 <dons> 4 hrs east of perth...
19:03:17 * wagle pulls up the stakes, and moves on to the next wireless oasis
19:03:20 <humasect> it would be -5 ..
19:03:26 <bourbaki> so there is no place to drink cocktails beside a ship maybe?
19:03:30 <dons> nah. humasect, what you talking about?
19:04:08 <dons> there's a very big chunk of continent GMT+11
19:04:09 <dons> http://www.timeanddate.com/worldclock/results.html?query=Sydney
19:04:53 <humasect> hip
19:04:56 <dons> New Caledonia is +11 too, hmm Auckland is +12
19:05:08 <bourbaki> ahha!
19:05:15 <bourbaki> bering street of course
19:05:43 <dons> of course!
19:06:22 <bourbaki> :)
19:06:30 <dons> Tonga is +13
19:06:47 <dons> that's about as far as it goes I think.
19:07:25 <humasect> nuku'alofa
19:08:10 <dons> it's great being GMT+N>8, you get to submit papers with plenty of time to spare.
19:08:33 <dons> so you always get an extra day till GMT gets around to the deadline
19:08:37 <bourbaki> ah right
19:08:38 <bourbaki> tonga
19:08:53 <bourbaki> thats the place where they do new years eve first
19:09:11 <humasect> doesn't matter where you are, when the deadline starts and you haven't moved...
19:09:24 <humasect> it will come back around the same amount required
19:09:30 <humasect> no ?
19:09:32 <dons> ?
19:09:54 <dons> some guy in the US says announces deadline, has 2 week. I have 2weeks+Nhours+8
19:10:37 <humasect> but you don't get to hear it Nhours+8 earlier than the rest
19:10:54 <humasect> timezone is just for the sun and moon >_>
19:11:03 <humasect> not actual past and present
19:11:07 <dons> but also governs when people are awake.
19:11:25 <dons> everyone gets the announce simultaneously, but the deadline is dependent on timezone
19:11:30 <humasect> yeah.. k
19:11:39 * humasect is -8 T_T
19:11:53 <humasect> 16 hour head start ?
19:12:08 <humasect> for a +8 gmt class competist.
19:14:47 <dons> it's not so much the head start, but the extra hours at the end
19:15:21 <humasect> ok
19:15:23 <dons> I can choose to submit 'Friday, GMT+11 time', or if I'm rushed, 'Friday GMT-8 time'
19:15:53 <dons> that's usually how it plays out - you try to get it down, then you get Saturday to fix anything before submitting morning US time (or UK time)
19:16:10 <humasect> at
19:16:12 <humasect> *ah
19:16:53 <dons> I note however that the .au .jp .nc .nz people don't win everything, so it can't be too much help :)
19:17:08 <humasect> heh
19:21:45 <metaperl> I'm not sure this is entirely true, but it probably is
19:22:20 <metaperl> the cool thing about Haskell is that syntactic sugar is just that. List Int and [Int] mean the same thing
19:22:32 <metaperl> is that true? how might I demonstrate it
19:25:12 <Darius> List isn't defined
19:25:25 <Darius> But yes, the sugar for [a] is just sugar
19:25:28 <dons> show that the definition of the types List Int and [Int] are equivalent by induction of the constructors (if List was defined)
19:25:35 <dons> s/of/over/
19:25:50 <metaperl> Data.List is defined not List?
19:26:19 <metaperl> All types should be constructable by a function call, not syntactic sugar, if my ode to haskell is to ring true
19:28:15 <Darius> metaperl: You can't implement (all) data types as functions with Haskell 98
19:28:27 <Darius> With higher-rank polymorphism you can though.
19:28:37 <metaperl> gosh
19:28:48 * Darius wonders about reflexive data types.
19:28:50 <metaperl> but the List type can?
19:29:05 <metaperl> I can't say f :: List Int -> Int
19:29:13 <metaperl> must I say f :: [Int] -> Int
19:29:28 <metaperl> ?
19:29:38 <Cale> you could also say f :: [] Int -> Int
19:29:44 <Cale> but that's a bit ugly
19:29:51 <Darius> You can make your own data type that's isomorphic
19:29:58 <Darius> data List a = Nil | Cons a (List a)
19:30:12 * metaperl sighs... so much for that Ode to Haskell
19:30:22 <Darius> If you want to implement that data declaration with only functions (i.e. only lambda) you need higher rank types.
19:30:46 <metaperl> no that is not what I meant: I consider a data constructor a function
19:31:04 <metaperl> because it is... I think
19:31:43 <Darius> There is nothing special about [a] other than syntax, and constructors are functions in the mathematical sense.
19:31:59 <Darius> (and pretty much in the pragmatic sense too)
19:32:07 <Cale> The list type constructor is called []
19:32:37 <Darius> @type [1] :: [] Int
19:32:38 <lambdabot> [1] :: [] Int :: [Int]
19:33:16 <Cale> similarly, the type constructor for functions can be written (->) and used in prefix form
19:33:29 <Cale> square :: (->) Integer Integer
19:34:06 <cm> now if you could call these at runtime :o)
19:34:26 <Darius> cm: ?
19:34:32 <Cale> you wouldn't want to :)
19:34:35 <cm> Darius: !
19:34:49 <cm> you know, construct instances of type classes at runtime *ducks*
19:34:53 <Darius> cm: What would you do with them at runtimeL
19:35:28 * RemiTurk goes to sleep
19:35:43 <Darius> cm: Being able to apply type constructors isn't the problem there.
19:36:13 <cm> yeah, it was more of a .. parallel example ;]
19:36:49 * cm ponders
19:44:20 <Lemmih> Fooie. Can't use (=>) in prefix form.
19:44:35 <Darius> That's not a type constructor.
19:45:15 <Darius> It's necessary to be able to use (->) and similar things in a prefix form (or some partially/un-applied form) for instance declarations and such.
19:46:12 <Cale> (->e) should be possible :)
19:46:31 <Lemmih> Yeah I know. Was just trying to make a typesig even more unreadable.
19:46:57 <Darius> There's a paper that describes a system to add a restricted form of type level lambda to Haskell.
19:46:59 <dons> @kind (->) Int
19:46:59 <lambdabot> Sorry, I don't know the command "kind", try "lambdabot: @listcommands"
19:47:02 <dons> bah
19:47:55 <dons> @bot!-patch-your-ghci-module-to-also-use ':k'
19:47:55 <lambdabot> Sorry, I don't know the command "bot!-patch-your-ghci-module-to-also-use
19:47:55 <lambdabot> , try "lambdabot: @listcommands"
20:03:17 <metaperl> Congratulations Igloo on ICFP 2004
20:03:35 <stepcut> hehe
20:03:54 <stepcut> I wonder if I will have time to enter ICFP2005
20:04:30 <stepcut> maybe they will have a useful challenge this year -- like, implement a cross-platform business class accounting solution :p
20:04:50 <cm> haha
20:05:15 <metaperl> actually, I was having problems figuringout how to implement "Unix as a 4GL" in Haskell
20:05:42 <metaperl> I was hoping to write "haskell as a 4gl" but got stumped before even starting :)
20:05:42 <cm> getLine >>= putStrLn is a starter :P
20:06:00 <stepcut> what is a 4GL ?
20:06:07 <metaperl> maybe haskell needs a shell interface
20:06:09 <cm> 4th generation language? :|
20:06:14 <metaperl> 4GL == 4th generation language
20:06:20 <metaperl> a language which makes it very easy to do things in
20:06:34 <metaperl> Here is the paper: http://www.rdb.com/lib/4gl.pdf
20:06:43 <cm> metaperl: if the route to my web server wasn't defunct, i would show you a pic of my "ghci as a shell" attempts..
20:06:45 <metaperl> which shows how Unix out-performed commerical 4GLs on a task
20:06:55 <metaperl> ah
20:07:05 <stepcut> hrm, I think I wrote something along those lines
20:07:26 <cm> it's strongly typed, too! :D
20:07:31 <stepcut> I hope to publish it in the 2nd or 3rd issue of The Monad.Reader
20:08:07 <stepcut> you can express things like --> cat file -|- reverse |> outfile
20:08:39 <metaperl> the big diff beween unix and haskell is that haskell using function composition to do what unix does with flags
20:08:51 <metaperl> flags are used to refine/alter a program/functions behavior
20:09:07 <metaperl> haskell uses f . g for the same thing
20:09:11 <cm> not only
20:09:24 <cm> i think it's HOFs in general
20:10:18 <stepcut> My system is an attempt to make a practical replace for bash as a shell scripting language -- but hopefully building an interactive shell on top of it should be easy...
20:10:31 <cm> i was using GHCi as the shell
20:11:07 <metaperl> stepcut, do I know you from perlmonks or #scheme or something?
20:11:11 <stepcut> I allow you to not only pipe stdout, but also redirect stderr, and add watcher processes for any portion of the pipeline
20:11:44 <stepcut> metaperl: I don't know perl, I was on #scheme for a few days ~6 months ago -- but other than that I most hang out on #haskell or #arch
20:12:13 <metaperl> I was using scheme this summer
20:12:18 <metaperl> summer 2004
20:12:47 <stepcut> the watech process stuff is neat, cat file -|- someProcess `ifExitsNonZero` watcherProcess -|- somethingElse
20:13:25 <stepcut> if 'someProcess' exits nonZero, the watcherProcess gets the exit status AND the stdin, stderr, and stdout file handles so that it can actually take over for 'someProcess' if necessary
20:14:16 <stepcut> the major problem I still have is that unix pipes and lazy evaluation tend to lead toward deadlocks :-(
20:14:53 <stepcut> So I am hoping that if I publish, someone who knows more about the internals of ghc will be able to fix the problem
20:15:04 <stepcut> maybe I just need a link against multi-threaded RTS or something..
20:16:06 <TheStar> What's a very nice, simple example of a haskell gui program?
20:16:12 <TheStar> (Portable too)
20:16:42 <Darius> The wxHaskell page should have some examples as well as more involved uses.
20:17:00 <TheStar> Is wx "nice" to use in Haskell?
20:17:05 <Darius> As likely every other GUI library will.
20:17:27 <Darius> TheStar: I haven't used wxHaskell much and wxWindows not at all.
20:17:29 <cm> stepcut: this is kind of a fork :o)
20:17:47 <stepcut> cm: ?
20:17:47 <TheStar> I use wxPython alot, but I wonder how it would fit in with the Functional paradigm.
20:18:21 <Darius> TheStar: The wxHaskell interface is mostly imperative (by Haskell standards).
20:18:39 <cm> stepcut: does somethingElse get invoked after the watcherProcess finishes running?
20:19:05 <TheStar> Darius, I was hoping for a functional approach.  It's what I meant by _nice_ ;)
20:19:18 <Darius> If you're more interested in functional GUIs, Fudgets, Fruit, and wxFruit are more interesting but much less "mature"
20:19:54 <TheStar> Hmm.
20:20:16 <TheStar> What if wxHaskell used a .xrc file, it could become quite functional that way?
20:20:26 <TheStar> afaik, it would only then need to plug in event handlers...
20:21:32 <stepcut> cm: no, it is like a standard bash pipeline, the -|- operator acts like |, all the parts get forked into seperate OS processes
20:22:07 <stepcut> cm: haskell just takes care of hooking up the stdout's to the stdin's, once things are going, it stays out of the way
20:23:20 <stepcut> cm: but, it makes it nearly transparent as to whether the different components of the pipeline are external commands, like cat, grep, etc, or functions written in haskell -- you can intermix the two very easily with a consistant and simple interface
20:24:21 <cm> stepcut: I don't have `ifExitsNonZero` in bash, and neither do I know about operator precedence in your script :-)
20:24:58 <cm> stepcut: so is it (cat file -|- someProcess) `ifExitsNonZero` (watcherProcess -|- somethingElse)?
20:26:12 <stepcut> cm: no, (cat file) -|- (someProcess `ifExitsNonZero` watcherProcess) -|- (somethingElse)
20:26:26 <cm> but still, somethingElse does not get invoked after watcherProcess finishes running?
20:30:07 <stepcut> cm: I am not sure what you are asking, (cat file), (someProcess `ifExitsNonZero` watcherProcess), and (somethingElse) all get forked into seperate OS threads and the stdouts and stdins are hooked together -- so they are invoked at approximately the same time -- when (someProcess `ifExitsNonZero` watcherProcess) finishes running, it will close its stdout which is being sent to the somethingElse processes stdin. somethingElse wil
20:30:07 <stepcut> l finish consuming the input, and then do whatever it is supposed to do once all the input is consumed...
20:30:37 <cm> ah ok.
20:30:45 <cm> I thought it would work sequentially
20:31:38 <stepcut> no, it works that same way (ideally) as, 'cat file | someProcess | somethingElse' would work under bash
20:32:07 <stepcut> the ifExitsNonZero is something that bash (as far as I know) does not really offer
20:33:51 <stepcut> it allows you to add something like an exception handler to any portion of the pipeline
20:35:21 <stepcut> unfortunately, many people don't realize than in bash if you run, 'prog1 | prog2 && prog3', even if prog1 exits non zero, prog3 will still run :)
20:35:30 <TheStar> Is it possible to dynamically modify Haskell code at runtime?
20:36:20 <stepcut> TheStar: sort of
20:36:36 <TheStar> stepcut, That doesn't sound too encouraging...?
20:37:09 <stepcut> TheStar: the hs-plugins project lets you compile and load code into a running program -- but it is a ghc specific hack, not part of the standard
20:37:25 <stepcut> TheStar: if you see dons around, he can tell you more...
20:37:57 <stepcut> TheStar: why do you want to dynamically modify Haskell code at runtime ?
20:38:01 <metaperl> TheStar: you can probably get what you want done without modifying code at runtime... why did you ask that?
20:38:06 <TheStar> stepcut, Sounds interesting, I wonder what's the hackish bit about it.
20:38:19 <TheStar> metaperl, I'm thinking of a small project of mine.
20:38:42 <dons> *modify* code at runtime?
20:39:08 <TheStar> dons, In the fashion of plugging in event handlers at run time.
20:39:08 <stepcut> TheStar: it will only work with the ghc compiler, and it is likely sensitive to changes in the compiler. I am not sure how it actually works, but I imimagine it is something like using dlopen to dynamically modify a C program at runtime..
20:39:19 <dons> you can modify the src to a module, and reload the new object replacing the old, at runtime
20:39:24 <dons> hot-pluggable modules
20:39:37 <Igloo> Type-safe self-modfying code. Now there's a research challenge  :-)
20:39:55 <dons> there was a paper at last year's HW with that title..
20:39:57 <TheStar> dons, How manual is it?  I would like it to check if the code has changed, then realise the changes automatically.
20:40:05 <TheStar> Igloo, What's so hard about that?
20:40:26 <dons> TheStar: Igloo's defn of 'modify' might be different to yours.
20:40:28 <TheStar> Igloo, Assume I know very little about the subject.
20:40:52 <dons> anyway, hs-plugins has mechanisms to check if src has changed, recompile and reload automatically.
20:40:59 <TheStar> Oh, self-modifying code...  I don't want that.
20:41:04 <dons> check the paper, and the examples in the manual
20:41:12 <TheStar> dons, Looks intruging.
20:41:22 <dons> this problem was actually what I wrote hs-plugins for.
20:41:48 <dons> to compile and reload code in .hs modules used as configuration files
20:41:50 <stepcut> dons: how sensitive is hs-plugins to changes in the compiler? do all the plugins have to be compiled by the same version?
20:42:03 <TheStar> dons, How pervasive does it allow rewritten code? Like, are there limitations as to what can and can't change?
20:42:05 <dons> as sensitive as static linking is
20:42:29 <dons> TheStar: if you mess with data layouts, things will break
20:42:44 <dons> if you just change values, that's fine
20:43:01 <TheStar> dons, It's a given that each replaced function must behave the same.
20:43:18 <dons> 'behave the same', no. have the same type, yes.
20:43:20 <TheStar> At it's interface, and return, anyway.
20:43:47 <stepcut> dons: I want to write a program that can print out all of the instances of a class in scope -- something like how in ghci you can do ':i SomeClass'
20:44:25 <dons> how does :i work?
20:44:33 <dons> it probably scans .hi files
20:46:12 <stepcut> dons: hrm -- that could work for me...
20:46:42 <stepcut> dons: I only need the value once at compile, and the .hi files will be available -- I could probably do something with template haskell
20:46:54 <dons> paprika$ ghc --show-iface Float.hi | grep instance
20:46:54 <dons> instance GHC.Enum.Enum Double = $fEnumDouble
20:46:54 <dons> instance GHC.Enum.Enum Float = $fEnumFloat
20:46:54 <dons> instance GHC.Base.Eq Double = $fEqDouble
20:47:10 <dons> with TH maybe yeah.
20:47:23 * stepcut does evil things with TH
20:47:51 <dons> you're inspecting the typing environment, which is reproduced (sort-of) in the .hi files anyway. so grep *.hi, or TH might work
20:48:06 <dons> using TH you can probably ask the compiler directly
20:48:12 <dons> if you ask nicely
20:48:34 <stepcut> dons: unfortunately, I could not find a way to directly ask the compiler with TH, but I can use TH to run grep and sed ;)
20:48:43 <dons> yeah!
20:49:04 <metaperl> that definitely sounds evil :)
20:49:07 <TheStar> Does haskell allow you to call a function - but if it doesn't exist, to just ignore it and continue?
20:49:31 <dons> you'd know at compile time if it exists, though.
20:49:44 <TheStar> dons, Would you, with dynamic code?
20:49:54 <humasect> test driven development.. in debugger
20:50:04 <dons> with _dynamic_ code. hmmm.. GHC's rts says NO!
20:50:38 <stepcut> My number one use of TH so far is to run 'tla logs -rf | head -1' in order to automatically generate a version number for the output of ./myprogram --version  ;)
20:50:44 <metaperl> programming in Haskell has improved my Perl code considerably. so much so that I need to be careful around my co-workers
20:50:48 <TheStar> dons, Sounds like I have to find another language or make my own.
20:50:54 <dons> you can't even compile it statically unless you've bound a variable to it, anyway
20:51:06 <dons> it's not like you can say 'f x' when 'f' isn't even in scope.
20:51:14 <dons> you need to say 'f <- load module ; f x'
20:51:20 <dons> which ensures it'll work
20:51:57 <TheStar> I suppose I could always use dummy functions.
20:52:31 <dons> read the hs-plugins paper. there's a way to do this describe there, using default values
20:52:42 <metaperl> TheStar, I'm a Haskell beginner but judging from your comments, it seems like you are trying to force your way of thinking upon Haskell :)
20:52:55 <dons> but almost always you don't really need to do anything like this in Haskell
20:52:56 <stepcut> maybe something like , maybe_f <- load module ; case mabye_f of Nothing -> return () ; Just f -> f x
20:52:59 <TheStar> metaperl, I have a specific purpose that I would like to achieve.
20:53:10 <metaperl> TheStar, specify your problem
20:53:12 <TheStar> metaperl, And python doesn't suit me.
20:53:33 <metaperl> s/problem/purpose
20:53:41 <TheStar> metaperl, I have been developing my own language - but when I noticed that it was becomming more lisp-like, I decided to check out Haskell.
20:54:13 <TheStar> metaperl, I am attempting to make the ultimate RAD language.
20:54:18 <metaperl> I would venture to say that Haskell is not very lisp-like in several important ways
20:54:37 <TheStar> metaperl, Ok, rather than lisp, I meant "functional".
20:54:51 <metaperl> TheStar, have you seen Clean?
20:54:51 <TheStar> metaperl, In that functions have no sideeffects, etc.
20:55:00 <TheStar> metaperl, I've _heard_ of it.
20:55:08 <metaperl> they have a rapid development environment. The langauge is strikingly similar to Haskell
20:55:13 <TheStar> metaperl, I would also like to be able to realize the advantages of Erlang, if I can.
20:55:33 <TheStar> And modify code at runtime.
20:55:46 <dons> well, hs-plugins lets you do some of the Erlangy things
20:55:47 <metaperl> isn't it hard to make the ultimate RAD language on your first shot?
20:55:57 <metaperl> I think it is hard to be the very best at anything in your first attempt
20:56:03 <dons> swapping modules for one. restoring state is another.
20:56:05 <TheStar> metaperl, Pfft - where's your sense of adventure? :)
20:56:24 <stepcut> TheStar: maybe you just want to use ghci ;)
20:56:31 <TheStar> ghci?
20:56:42 <stepcut> :(
20:56:50 <dons> it's definitely still a research topic to be able to hot-swap any fragment of compile code (units smaller than a module) or to change the structure of a type dynamically
20:56:56 <metaperl> I think one thing to note is that all languages can compute the same functions
20:57:09 <stepcut> TheStar: interactive version of the compiler -- allows you to reload modules on the fly and interact with the compiler...
20:57:34 <metaperl> TheStar, also join up with the ultimate language inventors on comp.lang.misc :)
20:57:37 <TheStar> dons, I'm attempting to hot-swap entire functions - and only functions.  If they have incompatible data associated, then I'll have to devise some way of manually changing it.
20:57:52 <TheStar> metaperl, I don't like usegroups ;)
20:58:17 * metaperl covers his eyes
20:58:26 <dons> you'd have to hack the rts, TheStar. hack the dyn linker, or bytecode linker
20:58:36 <dons> not for the faint hearted
20:58:40 <TheStar> dons, I'd rather make my own.
20:58:53 <TheStar> dons, It'll lack some functionality, but then at least my curiosity's complete ;)
20:59:04 <dons> you should look at the literature on dynamic linker, hot swapping etc.
20:59:25 <dons> there's plenty of references at the end of the hs-plugins paper.
20:59:41 <dons> Clean has a good bytecode linking system, btw
21:00:19 <ozone> dons: objective-c runtime has been able to replace methods in objects forever
21:00:32 <ozone> though it'll segfault if the types are screwed
21:00:57 <dons> well, you can sort of do it in hs-plugins. you just reload the object the function lives in.
21:01:11 <dons> you're actually swapping in and out code larger than the function, but the effect is the same.
21:01:30 <dons> hence the yi tricks for modifying its own codebase and continuing
21:01:44 <dons> but none of this is very much fun - it's lowdown rts hackery
21:02:27 <TheStar> dons, That's one reason why I want to make my own.
21:02:28 <dons> one point is that Haskell is very good with controlling use of state, so restoring state after a dyn reload is pretty easy
21:02:42 <TheStar> What exactly do you mean by state?
21:02:56 <dons> the state of the program
21:03:09 <TheStar> That is a very general issue...
21:03:51 <dons> you need to be able to restore any state the hot-swapped code was keeping after a swap
21:04:09 <dons> luckily in Haskell this is pretty easy. and there's not much state anyway  (maybe a couple of IORefs)
21:04:37 <TheStar> I'm hoping to be able to separate the code from state.
21:04:37 <dons> restoring state in a C program is ridiculous - to many global vars everywhere - so noone even tries to do it
21:04:38 <stepcut> three cheers for no state!
21:04:41 <TheStar> In that sense.
21:05:13 <dons> @wiki TeamNoState
21:05:13 <lambdabot> http://www.haskell.org/hawiki/TeamNoState
21:05:14 * TheStar is attempting to make a language that does not need stack manipulation and loads of state.
21:05:39 <metaperl> where should I run ghci from so that a program with import Parsec at the top finds parsec?
21:06:02 <TheStar> I guess I'm talking about Monads.
21:06:06 <TheStar> Now that I know about them ;)
21:06:22 <stepcut> metaperl: you might just need to run something like, :set -package parsec
21:06:24 <stepcut> in ghci
21:06:37 <dons> TheStar: have you read Harper yet on the difficulties of mutable variables?
21:06:38 <stepcut> or, 'ghci -package parsec' at the command-line
21:06:49 <metaperl> no, what directory should parsec be in?
21:06:53 <TheStar> dons, No, and I am _very_ interested in that!
21:07:16 <stepcut> metaperl: what version of the compiler ?
21:07:37 <TheStar> dons, I don't see what's difficult about using mutable variables, in any case.
21:07:49 <TheStar> dons, I mean, inside of argument lists...
21:07:49 <dons> you're designing a language - you better get some theory down! - otherwise you'll end up with Basic :)
21:07:52 <metaperl> I have parsec unzipped here: http://www.hcoop.net/~terry/haskell/parsec/distro/
21:08:06 <metaperl> we run ghc 6.2.2.2
21:08:09 <TheStar> dons, I can't end up with Basic without an assignment operator...
21:08:19 <dons> good. that's a start :)
21:08:37 <stepcut> metaperl: parsec should be included as a standard library, are you explicitly trying to run a different version ?
21:08:49 <TheStar> dons, I don't see why one needs an assignment operator.
21:09:24 <metaperl> no...
21:09:31 <ozone> dons: theory schmeory.  theory's only useful to pass subjects. :}
21:09:37 <metaperl> but import Parsec at the top of my example did not work
21:09:40 * dons fails ozone
21:09:43 <metaperl> all the example import lots more
21:09:54 <TheStar> dons, Don't have a return statmeent either.
21:10:08 <ozone> dons: teehee
21:10:08 <TheStar> dons, Apparently it's very much CPS, but I've never learnt that ;)
21:10:43 <metaperl> here's my simple example attempting to use parsec: http://www.hcoop.net/~terry/haskell/parsec/simple/simple.hs
21:10:44 <stepcut> metaperl: scroll to the bottom --> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
21:10:45 <dons> ozone: interesting that obj-c segfaults if you mess with the types
21:11:04 <stepcut> metaperl: you need something more like, import Text.ParsecCombinators.Parsec
21:11:07 <dons> is the hot swapping just a normal dynamic linker? or do they try to do somethiing special?
21:11:08 <TheStar> Interestingly, the _only_ langauges I've ever used are: Qbasic (without modules), C, Python, C#, and Java.
21:12:09 <metaperl> ok that worked stepcut thanks
21:12:17 <stepcut> np
21:12:25 <ozone> dons: rewrites the pointer to the function
21:12:33 <ozone> dons: so, if you have the wrong types, it goes and calls it
21:12:40 * TheStar is a uni student, and so has lots and lots of stupid ideas.
21:12:41 <ozone> -> your stack gets all messed up
21:13:03 <ozone> which i guess doesn't necessarily mean a segfault, but if it doesn't, you're even more screwed :)
21:13:10 <dons> ozone: ah, ok. pointer rewriting is evil.
21:13:28 <ozone> though, since alot of objective-c stuff passes objects around, it's usually OK
21:13:39 <ozone> since objective-c objects must be heap-allocated, and are thus uniform
21:13:55 <ozone> it's only if you change the types of primitive C types, like int to float, or something like that
21:14:10 <dons> oh, rewriting pointers to objects. kinda like rebinding a value to a closure (after an hs-plugins load)
21:14:10 <ozone> replacing one object type with another object type is fine, since that's all dynamically typed
21:14:21 <ozone> dons: right
21:14:22 <dons> oh, that's cool.
21:14:41 <dons> yeah, so you can swap two Dynamic values, no matter what's inside.
21:14:42 <stepcut> metaperl: to answer your other question, -I/some/path will add additional search paths to ghc/ghci
21:14:45 <ozone> basically goes and changes the pointer to the method in the vtable
21:14:45 * stepcut goes to bed
21:14:48 <ozone> yep
21:15:00 <ozone> anyway, time for my monthly shower
21:15:03 <metaperl> thakns stepcut, good night
21:15:04 <ozone> back later
21:15:07 <dons> too much information
21:15:26 <TheStar> ozone, I can't remember my last bath.
21:15:30 * dons sends ozone to the back of the class
21:16:26 <dons> TheStar: where are you going to uni?
21:16:32 <TheStar> dons, Canberra.
21:17:03 <TheStar> dons, Where the students are smarter than the lecturers.
21:17:06 <dons> UniOfCanberra?
21:17:14 <TheStar> dons, Yes.
21:17:25 <TheStar> dons, Why? :)
21:17:37 <TheStar> dons, Don't tell me that your a lecturer *now*? :)
21:17:44 <dons> oh, 'Canberra' could mean ANU too.
21:17:48 * TheStar takes back a half-dozen statements.
21:17:59 <TheStar> dons, YEah, there's about 4 unis.
21:18:22 <dons> yeah. I don't know anyone at Canberra so you can insult them all you want ;)
21:18:33 <TheStar> Ahh, cool :)
21:18:38 <dons> they teach Haskell there?
21:18:47 <TheStar> dons, Because I suddenly thought you were that scripting lecturer... ;)
21:18:48 <TheStar> No.
21:18:58 <TheStar> They teach C --> Java --> C#
21:19:17 <TheStar> Not sure what's next, but it'll probalby be some imperative scripting language, I guess.
21:19:46 <Spark_> the students are smarter than the lecturers everywhere :)
21:19:54 <TheStar> Imperative langauges seem to be easier to teach, when students already know 3 other imperative languages.
21:20:00 <Spark_> but the really smart students keep this fact to themselves :)
21:20:06 <TheStar> Spark_, ;)
21:20:18 <TheStar> Spark_, I only blab on irc.
21:20:33 <Spark_> i believe imperative languages are more intuitive to people without a background in maths
21:20:53 <TheStar> Spark_, I fail to agree.
21:21:04 <dons> Spark_: really?
21:21:08 <Spark_> yeah
21:21:10 <Spark_> for example,
21:21:25 <Spark_> it took me a *long* time to get to grips with euclid's gcd algorithm
21:21:35 <Spark_> and a long time to understand things like quicksort
21:21:41 <Spark_> whereas bubblesort i understood instantly
21:21:52 <dons> but it must be easier to encode maths algos in Haskell
21:21:56 <Spark_> youre used to describing behaviour as a list of simple instructions
21:22:03 <Spark_> yeah sure
21:22:07 * TheStar always looks up things whenhe needs to, never botheres trying to remember.
21:22:57 <Spark_> what im really arguing is that while loops, sequential composition, and assignments are more intuitive than recursion and an implicit stack, for people without a maths background
21:23:14 <Spark_> but of course you need recursion for some things or you get a big mess
21:23:39 <TheStar> Functional Decomposition really does excel for algorithms.
21:24:23 <Spark_> s/sequential composition/sequencing operator/
21:24:26 <Spark_> im getting my terms mixed up
21:24:34 <Spark_> what is functional decomposition exactly?
21:24:48 <Spark_> the sort of (\x.x)M --> M behaviour?
21:25:07 <hellish> Has anyone here used either of the CGI libraries? I can't get either working under ghc and it seems they've been long abandoned.
21:25:56 <TheStar> Spark_, The other common methodology is the object-oriented approach.
21:26:17 <SamB> why speak you of strange "methodologies"?
21:26:18 <Spark_> ah its probably something im not aware of then
21:27:32 <Spark_> back to what i was saying, i'd argue they are more intuitive because they relate to people's past experience with specifying behaviour outside of maths / computing - instructions on how to get to somewhere, how to take your car apart, how to make a cake, ...
22:49:17 <lightstep> i'm getting an error when upping: "svn: Failed to add file 'src/Unicode.hs': object of the same name already exists"
22:49:24 <autrijus> rm it
22:49:26 <autrijus> then svn up.
22:49:29 <lightstep> should i delete the old one (manually)?
22:49:32 <lightstep> lag
22:50:24 <autrijus> and here is #haskell :)
22:50:36 * autrijus nudges lightstep toward #perl6
22:51:03 <lightstep> yeah, i only noticed it too late
22:53:12 <a5> so i have something like python's %: putStrLn $ "% is a string and % is a list and % is a number" % ("a" :. [1,2,3] :. 5 :. Nil) ==> "a" is a string and [1,2,3] is a list and 5 is a number
22:53:21 <a5> has this been done before?
22:53:55 <autrijus> sure, Text.Printf for example?
22:54:51 <a5> where is that? does it use HList?
22:54:57 <a5> or template haskell or ...
22:57:42 <autrijus> I think it uses simple classes
22:57:49 <autrijus> it's part of GHC 6.4
22:59:02 <lightstep> which is probably like HLists. but invisible
22:59:14 <a5> oh. man. i want to upgrade but does 6.4 break HSQL? i think someone mentioned that
22:59:51 <a5> my version uses 'show' so it applies to more things AFAICT. but no format specifiers so less useful
23:01:01 <a5> what does Text.Printf do on type mismatch? i guess type safety was the point of applying Template Haskell right?
23:01:13 <Gahhh> a5, omg I am just using Text.printf
23:01:22 <Gahhh> it throws exception on mismatches
23:01:41 <Gahhh> and it tries to print it, i.e. printf, not sprintf.
23:01:57 <Gahhh> and I need sprintf
23:02:10 <lightstep> Gahhh, the theory is that if you cast it to String, it should be sprintf
23:02:19 <a5> right...
23:02:24 <a5> that doesn't work?
23:02:30 <Gahhh> how do I cast it ?
23:02:39 <a5> (printf stuff)::String
23:02:44 <Gahhh> hm
23:03:29 <Gahhh> awesome
23:03:30 <Gahhh> thanks
23:09:41 <dons> a5: there's 4 or 5 ways I know of to implement a printf-ish function in Haskell. TH, hs-plugins, HLists, some other way with dynamics, some other way with typeclasses
23:10:56 <dons> printf "%c:%c:%c\n"   $> 'a' ! 'b' ! 'c' ! [] uses Dynamics and runtime codegen
23:11:37 <a5> hs-plugins?
23:11:49 <a5> typeclasses?
23:13:42 <dons> in fact, theres several papers on this work, including: Dynamic typing as staged type inference, Template meta-programming for Haskell, Functional Unparsing, Formatting: a class act, Strongly typed heterogeneous collections
23:14:15 <dons> hs-plugins is a bit like runtime TH. I think the `Functional Unparsing' paper discusses a typeclassed soln
23:15:44 <dons> :t printf
23:15:44 <dons> printf :: String -> AltData.Dynamic.Dynamic
23:15:44 <dons> Prelude Printf> let f = printf "%c\n"
23:15:44 <dons> Prelude Printf> f
23:15:45 <dons> <Char -> [Char]>
23:16:08 <dons> Prelude Printf> f $> 'X' ! []
23:16:08 <dons> X
23:17:05 <dons> Prelude Printf> let f = printf "0x%X\n"
23:17:05 <dons> Prelude Printf> f $> (42 :: Int) ! []
23:17:06 <dons> 0x2A
23:17:58 <dons> Prelude Printf> f $> "wrong" ! []
23:17:58 <dons> *** Exception: Type error in dynamic application.
23:17:58 <dons> Can't apply function <Int -> [Char]> to argument <[Char]>
23:18:09 <dons> yay. printf is fun and weird.
23:18:17 <a5> interesting. but enh. i often find that using my own library works out better, especially in haskell
23:18:28 <a5> what is >$, part of Text.Printf?
23:18:41 <dons> dynamic application - i.e. type check then apply
23:18:52 <a5> is that new?
23:19:22 <dons> it's in the hs-plugins' AltData.Dynamic library.
23:20:53 <dons> infixr 0 $>
23:20:54 <dons> ($>) :: Dynamic -> [Dynamic] -> IO ()
23:20:54 <dons> f $> as = putStr (fromDynamic $! f `dynAppHList` as)
23:21:19 <dons> anyway, all this was just to point you to some of the existing solns which might give you ideas
23:21:57 <dons> printf is a very strange function, really, as it's an embedded interpreter for format strings
23:22:24 <a5> thanks for the references
23:22:38 <autrijus> it's also a very useful function.
23:23:28 <dons> autrijus: of course you would say that, Mr. ParserEval ;)
23:23:47 <dons> we may as well add embedded yacc/happy code to our language ;)
23:24:07 <dons> as a DSL for dynamic parser hacking hehe
23:24:08 <autrijus> well true
23:24:24 <autrijus> but my point is that printf() is so genuinely useful
23:24:37 <autrijus> and the fact that it can be done in a type-safe fashion
23:24:44 <dons> yeah. it is.
23:24:56 <dons> and in fact several type safe ways. so it isn't all bad
23:25:00 <autrijus> means that dynamic embedded interpreter, or even on the fly recompilation, makes a lot of practical sense.
23:25:03 <dons> I think I like the TH solution the best
23:25:14 <dons> yes!
23:25:21 <autrijus> but I'm preaching to the choir, Mr. DynamicEval :)
23:25:37 <dons> let's add hs-plugins2/ghci to Haskell2 :)
23:25:44 <autrijus> yay!
23:26:34 <dons> Go TeamEval, yeah!
23:28:10 <a5> DynamicEval?
23:28:55 <dons> paprika$ ghci -package-conf plugins.conf.inplace -package eval
23:28:55 <dons> Prelude> :m Eval.Haskell
23:28:55 <dons> Prelude Eval.Haskell> :t eval
23:28:55 <dons> eval :: (AltData.Typeable.Typeable a) =>
23:28:55 <dons>         String -> [Import] -> IO (Maybe a)
23:30:27 <autrijus> go TeamEval go!
23:33:17 <dons> a5: like:
23:33:18 <dons>   p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
23:33:21 <dons>   if (p == NULL) printf("failed!\n");
23:33:24 <dons>   else printf("%d\n",*p);
23:34:03 <dons> which is the _real_ way to do C programming ;)
23:34:43 <Lemmih> Writing self-modifying code would be easy that way.
23:35:25 <dons> well it's easy to modify the code you're going to splice dynamically
23:35:31 <dons> like in TH
23:35:40 <dons> "" in eval == [| |] in TH
23:35:53 <Lemmih> At run-time?
23:36:05 <dons> yeah
23:36:56 <Lemmih> How would you do anything with TH at run-time?
23:37:23 <dons> no, you don't use TH, except to reuse the [| |] brackets
23:37:42 <dons> you have to replace $() with a splice function that instead calls ghci or hs-plugins
23:37:45 <dons> let me see...
23:38:37 <dons> Prelude Eval.Meta> run (defer [| 1 + 1::Int |]) :: Int
23:38:37 <dons> 2
23:38:55 <dons> that's splicing/deferring at runtime
23:39:13 <dons> Eval.Meta> :t run
23:39:13 <dons> run :: (AltData.Typeable.Typeable t, Show t) => Eval.Meta.ExpR -> t
23:39:23 <dons> using Dynamics to check the splice
23:39:31 <Lemmih> Eeek.
23:39:53 <dons> runtime metaprogramming! OCaml has it, why not Haskell ;)
23:40:06 <autrijus> so does eval work with TH2?
23:40:08 <autrijus> GHC6.4's TH that is
23:40:36 <dons> I'm running it under 6.4 right now. It's not very polished mind you. Wait till this year's HW.
23:40:48 <autrijus> ICFP?
23:41:05 <dons> it doesn't use TH though, 'cept for the Q Exp type, and [||]
23:41:21 <autrijus> that's good.
23:41:22 <dons> autrijus: Haskell Workshop is usually at ICFP, yeah.
23:41:29 <autrijus> I need to submit a paper.
23:41:37 * autrijus needs to learn this ACM format thing.
23:41:56 <dons> Prelude Eval.Meta> :t splice
23:41:56 <dons> splice :: (Show t) => t -> Eval.Meta.ExpR
23:41:56 <dons> Prelude Eval.Meta> :t run
23:41:57 <dons> run :: (AltData.Typeable.Typeable t, Show t) => Eval.Meta.ExpR -> t
23:42:23 <dons> so splice takes a 'thingy' and reifies it, then run turns it back into a value
