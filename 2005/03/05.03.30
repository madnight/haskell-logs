00:07:44 <TNKS> hey guys, it's a little late, and I'm not thinking as straight.
00:07:56 <TNKS> maybe someone can recommend a function to solve a problem I have.
00:08:26 <TNKS> I have a function of the type (Int -> [Double])
00:09:19 <TNKS> I'd like to turn this into a ([Double]) where each element is an infinite sum of all the elements of the same index.
00:10:32 <dons> @quit
00:11:56 <TNKS> it seems like I need some kind of infinite application of zipWith's.
00:24:33 <dons> @quote ghc
00:24:34 <lambdabot>   On Alpha, I can only handle 4 non-floating-point arguments to foreign
00:24:34 <lambdabot> export dynamic
00:24:37 <dons> @quote ghc
00:24:38 <|Lupin|> Helo forks.
00:24:38 <lambdabot>   The instance types do not agree with the functional dependencies of the
00:24:38 <lambdabot> class
00:25:55 <Igloo> What's that doing?
00:26:17 <|Lupin|> Does someone here know if it is possible to obtain an HTML version of the FFI documentation, please ?
00:26:25 <dons> Igloo: just some memorable ghc quotes
00:26:37 <dons> @remember Igloo What's that doing?
00:26:40 <dons> @quote Igloo
00:26:41 <lambdabot>   What's that doing?
00:26:45 <dons> :)
00:26:53 <dons> or random
00:26:55 <dons> @quote
00:26:56 <lambdabot> Igloo says: What's that doing?
00:26:59 <dons> @quote
00:27:00 <lambdabot> ghc says: The signature contexts in a mutually recursive group should all
00:27:00 <lambdabot> be identical
00:27:50 <Igloo> Gee, what a way to be remembered  :-)
00:28:01 <dons> nah, I just scratched it.
00:28:03 <dons> @quote Igloo
00:28:04 <lambdabot> Igloo hasn't said anything memorable
00:28:09 <dons> :P
00:28:10 <Igloo> Ah, much better  :-)
00:28:11 <ozone> @quote autrijus Well, ever since the monadic revolution of '98 Haskell people have started to do real world apps
00:28:12 <lambdabot> autrijus Well, ever since the monadic revolution of '98 Haskell people have
00:28:12 <lambdabot> started to do real world apps hasn't said anything memorable
00:28:20 <ozone> oops
00:28:24 <ozone> @remember autrijus Well, ever since the monadic revolution of '98 Haskell people have started to do real world apps
00:28:36 <ozone> @remember autrijus Parrot is fine except every time I build it, it fails
00:28:44 <ozone> @quote autrijus
00:28:45 <lambdabot>   Well, ever since the monadic revolution of '98 Haskell people have started
00:28:45 <lambdabot> to do real world apps
00:28:52 <ozone> schmexcellent
00:30:04 <dons> @babel en de Haskell is a fine language
00:30:06 <lambdabot> Prelude.head: empty list
00:30:09 <dons> doh
00:30:29 <dons> @babel en de Haskell is a fine language
00:30:30 <lambdabot>   Haskell ist eine feine Sprache
00:30:31 <Igloo> Do remembered things survive restarts?
00:30:35 <dons> yes
00:30:39 <Igloo> Cool
00:30:47 <dons> @babel de en Haskell ist eine feine Sprache
00:30:49 <lambdabot>   Haskell is a fine language
00:31:30 <dons> @babel en it Remembering is fine for lambda robots
00:31:31 <lambdabot>   Ricordarsi è benissimo per i robot di lambda
00:32:26 <|Lupin|> Have to go.
00:32:29 <|Lupin|> Bye everybody.
00:35:06 <nlv11757_> what can you guys recommend me for the building process of a tool I developed in Haskell. Should I delve into automake, make, autoconf, ..... I never actually used that stuff
00:35:35 <dons> make is very commonly used.
00:35:42 <dons> autoconf is also widely used
00:35:46 <nlv11757_> i know, but i want to do it the right way
00:36:21 <dons> I think the right way is to use a small configure script to set up some build vars, and then use ghc -M to generate correct dependencies for GNU make
00:36:51 <dons> this is how ghc, darcs, lambdabot, yi work
00:37:08 <dons> it's also how most port systems expect the code to be built
00:37:25 <dons> plus, you'll get gmake -jN support out of the box :)
00:38:21 <shapr> @quote
00:38:22 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized
00:38:22 <lambdabot> they have to learn it for themselves.
00:38:23 <nlv11757_> -jN does ...
00:38:36 <shapr> @quote
00:38:37 <lambdabot> Gahhh says: monads are usually a personal experience.
00:38:41 <shapr> This is cool.
00:38:42 <dons> hehe
00:39:23 <dons> nlv11757_: -j Specifies the number of jobs (commands) to run simulaneously in gnu make
00:40:21 <dons> a good idea is to find a project you understand, and reuse its build system
00:41:32 <df_> nlv :: how big is the tool?
00:41:52 <ozone> GHC is a good one to start with
00:41:59 <dons> ozone!
00:42:20 <nlv11757_> it consists of an attribute grammar using some packages
00:42:34 <shapr> @quote
00:42:35 <lambdabot> autrijus says: Well, ever since the monadic revolution of '98 Haskell people
00:42:35 <lambdabot> have started to do real world apps
00:42:38 <shapr> @quote
00:42:39 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let
00:42:39 <lambdabot> near a programming language.
00:42:39 <df_> if its small, then a very simple Makefile that gets ghc to do the work is fairly good
00:42:47 <shapr> Yes, I like this command much.
00:42:51 <dons> :D
00:43:03 <nlv11757_> but it will be part of a larger project soon
00:43:14 <nlv11757_> so i thought, might as well get it right the first time
00:43:27 <dons> if it's really small, you can use ghc --make and dispense with makefiles
00:43:39 <df_> simple is often best
00:44:21 <dons> cpphs and idoc have very small (or zero) configuration, and they're highly portable as a result
00:44:22 <Igloo> It's nice to have ./configure --prefix=/foo && make && make install work
00:44:26 <Igloo> Along with make clean
00:44:26 <df_> automake and autoconf are often needlessly complex with many maintainers not actually fully understanding them
00:44:45 <dons> yes. automake is never required, is it?
00:44:58 <dons> though I do like autoreconf generating .h files for me.
00:45:11 <df_> required, no
00:45:59 <df_> alot more people don't actually make use of all (or sometimes any of) the #defines that autoconf's configure produces
00:46:40 <dons> well, you should be writing your own ./configure.ac anyway - they're not too hard
00:46:45 <dons> then you get the symbols you want
00:47:51 <df_> if you want to see a really brilliant example of how not to do it, go grab the gnu hello world application
00:48:11 <nlv11757_> ok, well thanks for the advice so far. im looking into autoconf and ghc's manual
00:50:51 * dons goes looking food
00:51:50 * ozone goes food looking
02:54:00 <dons> @version
02:54:01 <lambdabot> lambdabot : ghc-6.2.2 (Wed Mar 30 20:48:23 EST 2005)  (OpenBSD i386)
02:55:50 <xerox> yay!
02:58:43 <dons> :)
03:25:18 <nlv11757_> ahh making configure.ac files s*ck
03:25:33 <df_> yes
03:25:50 <dons> I don't know, they're not so bad, and you can write normal shell
03:26:06 <dons> MY_SYM=`find my sym` ; AC_SUBST(MY_SYM) done!
03:27:03 <jlouis> autocrap tools
03:27:52 <dons> hey jlouis!
03:28:06 <dons> see our shiny new lambdabot
03:28:10 <dons> @version
03:28:11 <lambdabot> Wed Mar 30 21:11:12 EST 2005, GHC 6.2.2 (OpenBSD i386)
03:28:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:29:49 <basti_> hi
03:51:38 <xerox> hello
03:52:05 * Lemmih is awake.
03:53:02 * basti_ is not
03:53:05 <basti_> hi anyway
04:02:54 <Lemmih> @plugs [ (x,y*2) | x <- [1..10] | y <- [1..10], even y]
04:02:55 <lambdabot> [(1,4),(2,8),(3,12),(4,16),(5,20)]
04:03:00 <Lemmih> Kick ass!
04:03:17 <basti_> plugs?
04:03:23 <basti_> hugs plugs?
04:03:32 <Lemmih> GHC plugs.
04:03:55 <Lemmih> It uses hs-plugins to evaluate Haskell.
04:03:58 <basti_> cool.
04:04:43 <Lemmih> @plugs tail [1..]
04:05:04 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
04:05:04 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
04:05:04 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
04:05:04 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
04:05:04 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
04:05:05 <lambdabot> 119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,
04:05:07 <lambdabot> 137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,
04:05:09 <lambdabot> 155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,
04:05:11 <lambdabot> 173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,
04:05:13 <lambdabot> [58094 @more lines]
04:05:18 <Lemmih> Ops...
04:05:41 <Lemmih> @plugs tail [1..] :: [Integer]
04:05:43 <lambdabot> bzzt
04:05:47 <Lemmih> yay.
04:06:04 <basti_> o0
04:06:06 <basti_> lol
04:06:15 <basti_> maybe ()?
04:06:29 <Igloo> Eh? Why didn't it default to that?
04:06:43 <Lemmih> @plugs let loop () = loop () in loop () :: Bool
04:06:53 <Lemmih> Guess it defaults to Int.
04:06:53 <lambdabot> bzzt
04:07:22 <Lemmih> @plugs System.Exit.exitFailure
04:07:23 <lambdabot> bzzt
04:07:27 <Igloo> dons?
04:07:50 <dons> oh, hello :)
04:08:04 <Lemmih> dons: @plugs is _so_ neat (:
04:08:13 <dons> :)
04:08:16 <Igloo> dons: Do you set defaulting non-standardly?
04:08:31 <dons> probably.
04:08:36 <Igloo> OK  :-)
04:08:45 <dons> each expression isn't wrapped up in a show.
04:08:52 <dons> s/isn't/is/
04:08:55 * dons is tired
04:10:51 <dons> so you get: resource = let { v = show $ expr } in v
04:11:16 <dons> so, the defaulting is whatever happens when you normally try to compile something like that with ghc
04:12:24 <dons> the loop () code actually runs, but gets terminated with 'bzzt'
04:12:34 <Lemmih> @plugs sum [1..]
04:12:46 <lambdabot> bzzt
04:13:00 <Lemmih> @plugs sum [1..10000]
04:13:05 <dons> you have exactly 3 seconds to get your computation done, otherwise bzzt
04:13:07 <lambdabot> 50005000
04:13:12 <xerox> @plugs let fib = 0 : zipWith (+) (tail fib); fib !! 10
04:13:13 <lambdabot> <Plugins.Eval>:1: parse error on input `;'
04:13:24 <xerox> in, whoops.
04:13:39 <xerox> @plugs let fib = 0 : zipWith (+) (tail fib) in  fib !! 10
04:13:40 <lambdabot> bzzt
04:14:11 <Lemmih> zipWith (+) fib (tail fib)?
04:14:20 <xerox> !
04:14:25 <Igloo> You might want another base case, too
04:14:33 <xerox> @plugs let fib = 0 : zipWith (+) fib (tail fib) in fib !! 10
04:14:34 <lambdabot> bzzt
04:14:55 <dons> @plugs let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int
04:14:57 <lambdabot> 10946
04:15:07 <xerox> I see.
04:15:10 <dons> @plugs let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20
04:15:12 <lambdabot> 10946
04:15:27 <dons> maybe it would be helpful to display type and syntax errors :}
04:15:50 <xerox> They'll take many lines of output I think.
04:15:52 * Igloo hands dons some quiche  :-)
04:16:16 <dons> :)
04:16:36 <dons> also new is:
04:16:42 <dons> @kind Int
04:16:52 <dons> bot?
04:16:54 <lambdabot> Int :: *
04:16:58 <dons> thankyou.
04:17:02 <Lemmih> @kind Maybe
04:17:03 <xerox> @kind Maybe
04:17:04 <lambdabot> Maybe :: * -> *
04:17:04 <lambdabot> Maybe :: * -> *
04:17:07 <xerox> :D
04:17:19 <Lemmih> @kind Either Int
04:17:20 <lambdabot> Either Int :: * -> *
04:17:28 <dons> @kind Int# -> Int
04:17:29 <lambdabot> bzzt
04:17:33 <dons> @kind Int#
04:17:34 <lambdabot> bzzt
04:17:43 <dons> @kind GHC.Base.Int#
04:17:44 <lambdabot> GHC.Base.Int# :: #
04:17:44 <xerox> Hiya TheHunter_ ! We got the hired replacement!
04:17:52 <Lemmih> @kind Int -> Int
04:17:54 <lambdabot> Int -> Int :: *
04:17:58 <xerox> What does # mean? :)
04:18:05 <dons> unboxed kind
04:18:12 <TheHunter_> hiya xerox
04:18:50 <xerox> @version
04:18:51 <lambdabot> Wed Mar 30 21:11:12 EST 2005, GHC 6.2.2 (OpenBSD i386)
04:18:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:18:52 <dons> we also have:
04:18:55 <dons> @quote
04:18:57 <lambdabot> ghc says: GHC stage restriction
04:19:03 <dons> @quote
04:19:04 <lambdabot> Gahhh says: monads are usually a personal experience.
04:19:27 <xerox> @quote
04:19:28 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized
04:19:28 <lambdabot> they have to learn it for themselves.
04:19:39 <dons> version is build date, ghc vers, os, and darcs repo it was stolen from
04:19:44 <TheHunter_> dons, do you want my pointless module?
04:19:54 <dons> all modules are very welcome!
04:20:01 <xerox> Great!
04:20:18 <dons> grab the lambdabot2 repo, write a new module, and send me the patch
04:20:28 <TheHunter_> ok, cool
04:21:39 <xerox> @karma dons
04:21:39 <lambdabot> dons has a karma of 0
04:22:01 <dons> I think I'll make karma persistent.
04:22:05 <dons> it's a bit silly that it isn't
04:22:31 <Igloo> Gee, you mean all this juicy karma I've been working up has been lost? My life feels so...empty!
04:22:52 <TheHunter_>     Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
04:22:53 <dons> oh well, that's the meaningless cosmos for you ;)
04:23:25 <dons> TheHunter_ ?
04:24:00 <TheHunter_> ahh, i got it, stupid me...
04:24:01 <boegel> @seen samc
04:24:02 <lambdabot> I haven't seen samc
04:24:19 <xerox> Isn't there a @help / @list-commands ?
04:24:26 <Lemmih> @plugs map Char.toLower "hEllO thErE, bOEgEl"
04:24:27 <lambdabot> bzzt
04:24:42 <dons> Data.Char
04:24:44 <xerox> @index toLower
04:24:45 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
04:24:53 <Lemmih> @plugs map Data.Char.toLower "hEllO thErE, bOEgEl"
04:24:54 <boegel> hi team-mate !
04:24:55 <lambdabot> "hello there, boegel"
04:24:57 <basti_> :)
04:25:05 <Lemmih> Uh. @index is gone?
04:25:09 <dons> no index. hmm.
04:25:21 <dons> oh, that's shaprs proprietary patch, I think.
04:25:40 <dons> I'll get it working tomorrow.
04:26:17 <xerox> Are you killing it?
04:26:22 <dons> yow doesn't work xerox...
04:26:27 <xerox> Whoops :)
04:26:30 <dons> no yow files. they're on shapr's box
04:26:54 <dons> and we need a patch to stop quitting if the file doesn't exist :}
04:28:52 <vegai> lambdabot doesn't seem to compile on ghc-6.4.. hmm
04:29:15 <dons> yeah it does. maybe not from shapr's repo, but lambdabot2 does
04:29:27 <dons> that's what I spent all day working on :}
04:29:33 <dons> @version
04:29:34 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
04:29:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:29:45 <vegai> ah, ok
04:29:48 <vegai> I'll try that
04:31:43 <xerox> autoconf && sh configure && make?
04:31:48 <dons> yeah
04:31:55 <dons> gnu make
04:32:04 <xerox> Good!
04:33:53 <vegai> yup, this works just fine
04:34:14 <vegai> is 'lambdabot1' dead, then?
04:35:15 <dons> oh, not really, I just agreed to take over maintainership from shapr
04:36:10 <Si\> has anyone ever written a TH deriver for Lift for algebraic data-types?
04:36:29 <vegai> hmm, "Exception: Prelude.read: no parse
04:36:30 <vegai> "
04:36:42 <dons> ?
04:37:05 <vegai> happens when I run the binary
04:37:19 <Thehunter> dons, any idea why this is happening (after I made some changes)?
04:37:21 <Thehunter> couldn't load module MoreModule.o
04:37:21 <Thehunter> couldn't load module haddock/HaddockHtml.o
04:37:40 <nlv11757_> how can you prevent make from executing all targets when not given any parameters
04:37:41 <dons> no, I get it to. doesn't seem to be harmful afai can see
04:38:17 <dons> vegai: don't know what's happening there. possible the @quote module. but looks for calls to 'read' I guess
04:38:29 <Thehunter> ok, sorry the problem seems to be something different.
04:41:04 <Darius> So I guess lambdabot hacking is in season again.
04:41:19 <dons> yeah! :)
04:42:46 <xerox> I get the same Exception.
04:42:52 <df_> nlv11746 :: make will execute the first rule it encounters
04:43:38 <vegai> it's not the Quote module at least
04:43:48 <df_> reorder things so that an apropriate rule is first, or, write a first rule that is just @echo some instructions on what to do
04:44:01 <dons> sorry, the @quote code in BabelModule
04:44:36 <dons> though I can't see why it would cause an exception at startup
04:44:37 <vegai> ah
04:45:16 <dons> and why does it build fine for TheHunter? hmm.
04:46:02 <xerox> TheHunter: on which GHC?
04:46:17 <TheHunter> ghc-6.2.2
04:46:24 <dons> well, I'm building with 6.2.2. and 6.4 on linux and openbsd
04:46:33 <xerox> Hm, 6.4 here too.
04:46:36 <dons> so I'm only expecting oddities on e.g. solaris
04:47:08 <Igloo> Is it a compilation or runtime problem?
04:47:14 <vegai> doesn't seem to be Babel either
04:47:24 <xerox> Igloo: Runtime.
04:47:26 <df_> what solaris oddities?
04:47:46 <dons> solaris is a different environment, that's all
04:48:40 <vegai> yep, 6.4 here too
04:48:43 <df_> ah, okay, nothing specific
04:49:07 <xerox> Linux-x86.
04:49:16 <vegai> yes.
04:49:59 <dons> but a read parse fail is unlikely to be a compiler issue, something file or value is missing or wrong at runtime, I'm guessing
04:50:18 <dons> but it's hard to think of what it could be
04:50:56 * Darius wonders when @eval loads it's definitions and whether a definitions file is in the lambdabot darcs repo
04:51:20 <dons> there is a definitions file, it's not in the repo yet. i'll add it now
04:52:29 <dons> done.
04:52:30 <Igloo> Change all read's to reads's with errors, finding the bug and feeling pure at the same time  :-)
04:53:05 <Darius> dons: What's the URL of the current lambdabot repo?
04:53:10 <dons> @version
04:53:11 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
04:53:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:59:16 <Darius> lambdabot: @listmodules
04:59:17 <lambdabot> I have the following modules installed: ["babel","base","dict","dynamic"
04:59:17 <lambdabot> ,"eval","karma","plugs","quote","seen","state","system","topic","type","
04:59:17 <lambdabot> version"]
05:00:15 <xerox> I'm still excited for @plugs, we'll see actual running Haskell code in the channel, yay.
05:00:47 <Darius> @listcommands plugs
05:00:48 <lambdabot> Module plugs provides the following commands: ["plugs"]
05:03:29 <Darius> Did you add @kind and @info, dons?
05:03:29 <Darius> @listcommands type
05:03:31 <lambdabot> Module type provides the following commands: ["type","kind","info"]
05:03:41 <dons> yep
05:03:57 <xerox> @info Integer
05:03:59 <Darius> I was about to hack that in waiting to see if it build.
05:04:06 <xerox> @info Integral
05:04:09 <lambdabot> data Integer
05:04:09 <lambdabot> = S# GHC.Prim.Int# | J# GHC.Prim.Int# GHC.Prim.ByteArray#
05:04:09 <lambdabot>         -- Imported from GHC.Num
05:04:09 <lambdabot> instance Eq Integer         -- Imported from GHC.Num
05:04:09 <lambdabot> instance Num Integer         -- Imported from GHC.Num
05:04:09 <lambdabot> instance Ord Integer         -- Imported from GHC.Num
05:04:12 <lambdabot> class (Real a, Enum a) => Integral a where
05:04:13 <lambdabot> quot :: a -> a -> a
05:04:15 <lambdabot> rem :: a -> a -> a
05:04:23 <lambdabot> div :: a -> a -> a
05:04:23 <lambdabot> mod :: a -> a -> a
05:04:23 <lambdabot> quotRem :: a -> a -> (a, a)
05:04:23 <lambdabot> divMod :: a -> a -> (a, a)
05:04:25 * Darius isn't so sure @info is a good idea.
05:04:25 <lambdabot> toInteger :: a -> Integer
05:04:27 <lambdabot>         -- Imported from GHC.Real
05:04:29 <lambdabot> instance Integral Integer         -- Imported from GHC.Real
05:04:29 <dons> hmm.
05:04:31 <lambdabot> instance Integral Int         -- Imported from GHC.Real
05:04:33 <xerox> Instances, yay, how do you get it?
05:04:33 * Darius was never really sure about it.
05:06:48 <dons> maybe i'll turn it off
05:07:10 <xerox> "privmsg only" ?
05:13:31 <dons> @listcommands type
05:13:31 <lambdabot> Module type provides the following commands: ["type","kind"]
05:13:43 <dons> :)
05:18:00 <Darius> MiniHTTP?
05:18:38 <dons> @babel en de HTTP is used in the lambda robot
05:18:40 <lambdabot>   HTTP wird im Lambda Roboter benutzt
05:18:45 <dons> hehe
05:18:54 <basti_> o0
05:19:05 <dons> yeah, just to talk to babelfish
05:19:23 <dons> I can imagine it will be useful for other things
05:21:10 <Darius> Ah, I just missed it in my grep -R.
05:29:41 <Darius> @index popen
05:29:42 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
05:29:56 <Darius> @type Posix.popen
05:29:58 <lambdabot> bzzt
05:30:10 <dons> hmm.
05:30:32 <Darius> What is the type and meaning of the results for popen?
05:31:20 <Darius> Mainly the results, the inputs seem clear, the last is Just input_for_stdin right?
05:31:26 * Darius is on Windows.
05:32:07 <Darius> I'm thinking of rewriting popen in terms of System.Process.runInteractiveProcess if it'll work.
05:32:19 <Lemmih> What languages does @babel support?
05:32:20 <dons> yeah. I think it wouldn't be too hard
05:32:29 <dons> @babel help
05:32:29 <lambdabot>   usage: babel lang lang phrase
05:32:37 <dons> hmm. it's in BabelModule
05:33:25 * Darius will probably write a @help module and add what's necessary (if someone else doesn't do it first :) once he gets lambdabot building.
05:42:31 * Darius misses MozFBRH.
05:43:55 <nlv11757_> @babel en fr hello
05:43:57 <lambdabot> Prelude.head: empty list
05:44:05 <nlv11757_> @babel en fr "hello"
05:44:07 <lambdabot> Prelude.head: empty list
05:44:14 <nlv11757_> odd translation
05:44:16 <dons> yeah, I don't know  why it does that
05:44:26 <nlv11757_> empty list to you too
05:44:41 <dons> sometimes the parse of the html fails, i think
05:44:53 <dons> or possibly it times out
05:45:05 <nlv11757_> @babel en de hello
05:45:07 <lambdabot> Prelude.head: empty list
05:45:14 <nlv11757_> does it translate anything?
05:45:31 <dons> @babel en de hello lambda robot
05:45:33 <lambdabot>   hallo Lambda Roboter
05:45:38 <dons> @babel en de hello
05:45:39 <lambdabot> Prelude.head: empty list
05:45:41 <nlv11757_> hehe
05:45:42 <dons> hmm.
05:45:45 <nlv11757_> now *that* is odd
05:46:01 <dons> @babel en de one two
05:46:02 <lambdabot>   eine zwei
05:46:05 <dons> @babel en de one
05:46:06 <lambdabot>   ein
05:46:08 <nlv11757_> @babel nl de een twee
05:46:08 <dons> @babel en de one
05:46:10 <lambdabot> Prelude.head: empty list
05:46:10 <lambdabot>   ein
05:46:18 <dons> @babel en de one
05:46:20 <lambdabot>   ein
05:46:23 <nlv11757_> nl not implemented?
05:46:30 <dons> ok. it seems arbitrary.
05:46:35 <dons> @babel en de one
05:46:36 <lambdabot>   ein
05:46:37 <dons> @babel en de one
05:46:38 <lambdabot> Prelude.head: empty list
05:46:41 <dons> see.
05:46:42 <nlv11757_> hehhe
05:47:01 <nlv11757_> @babel en nl two
05:47:03 <lambdabot>   twee
05:47:10 <nlv11757_> @babel nl en negen
05:47:11 <lambdabot> Prelude.head: empty list
05:47:13 <mflux> heyyy, what's this, shouldn't functional programs always return the same reponse for the same input!
05:47:16 <dons> it seems to be more of a problem on #haskell, on my local channel it never does this
05:47:17 <mflux> ;)
05:47:18 <nlv11757_> @babel nl en pannekoek
05:47:20 <lambdabot>   pannekoek
05:47:26 <nlv11757_> right....
05:47:31 <nlv11757_> lmao
05:47:44 <nlv11757_> @babel nl en pannenkoek
05:47:46 <lambdabot>   pan wafer
05:47:50 <nlv11757_> pan wafer....
05:47:51 <nlv11757_> hahaha
05:48:09 <nlv11757_> @babel en nl pancake
05:48:11 <lambdabot>   pannekoek
05:48:19 <nlv11757_> @babel nl en pannekoek
05:48:21 <lambdabot>   pannekoek
05:48:24 <nlv11757_> weird
05:48:32 <nlv11757_> i'd expect pancake
05:48:44 <dons> hehe. babelfish ain't too smart
05:49:04 <nlv11757_> @babel nl de zuurkool
05:49:06 <lambdabot> Prelude.head: empty list
05:49:23 <nlv11757_> @babel de nl sauerkraut
05:49:24 <lambdabot> Prelude.head: empty list
05:49:29 <nlv11757_> @babel de nl lederhosen
05:49:30 <lambdabot> Prelude.head: empty list
05:52:47 <nlv11757_> @babel nl en knoop in je zakdoek
05:52:49 <lambdabot>   button in your handkerchief
05:52:53 <nlv11757_> sweeeet
05:54:32 <nlv11757_> @babel nl en Haskell heerst de wereld
05:54:34 <lambdabot>   Haskell dominate the world
05:55:07 <Lemmih> heh
05:55:27 <nlv11757_> @babel dk en Haskell heerst de wereld
05:55:28 <lambdabot> Error: Language dk not supported
05:55:35 <nlv11757_> @babel nl seHaskell heerst de wereld
05:55:36 <lambdabot> Error: Language seHaskell not supported
05:55:57 <nlv11757_> @babel nl se Haskell heerst de wereld
05:55:58 <lambdabot> Error: Language se not supported
05:56:05 <nlv11757_> @babel nl fr Haskell heerst de wereld
05:56:06 <lambdabot> Prelude.head: empty list
05:56:14 <nlv11757_> @babel nl fr kaas omelet
05:56:16 <lambdabot>   le fromage omelette
05:56:54 <shapr> goood morning #haskell!
05:57:07 <Lemmih> Hey shapr. Have you seen the Quotes page?
05:57:11 * shapr looks
05:57:14 <nlv11757_> @babel nl en goedemorgen
05:57:16 <lambdabot>   good morning
05:57:29 <nlv11757_> @babel nl en ik praat alleen nog maar via babelfish
05:57:30 <lambdabot>   I talk only still but by means of babelfish
05:57:38 <shapr> heh
05:57:43 <shapr> Lemmih: I am an INSTITUTION!
05:57:56 <Darius> @babel en jp Good day
05:57:57 <lambdabot> Error: Language jp not supported
05:58:03 <Darius> tsk
05:58:05 <nlv11757_> how surprising ;)
05:58:19 <Darius> Though I was wondering how I'd input kana if it were.
05:58:31 <nlv11757_> :)
05:58:36 <nlv11757_> unicode
05:59:06 <xerox> shapr: take a look here
05:59:08 <xerox> @version
05:59:08 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
05:59:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:59:10 <xerox> !
05:59:48 <dons> @babel languages
05:59:48 <lambdabot>   ["de","el","en","es","fr","it","ja","ko","nl","pt","ru","zh","zt"]
06:00:04 <xerox> @karma+ dons
06:00:05 <lambdabot> dons's karma has been incremented.
06:00:14 <Lemmih> @babel en ja Hello world.
06:00:15 <lambdabot>   can't parse this language
06:00:20 <dons> hehe
06:00:28 <Lemmih> @babel en ru Hello world.
06:00:30 <lambdabot>   can't parse this language
06:00:30 <nlv11757_> @babel nl ru Haskell heerst de wereld
06:00:32 <lambdabot> Prelude.head: empty list
06:00:40 <nlv11757_> who can
06:00:46 <nlv11757_> @babel nl zt Haskell heerst de wereld
06:00:47 <lambdabot> Prelude.head: empty list
06:00:48 <xerox> haha.
06:00:56 <nlv11757_> @babel nl zh Haskell heerst de wereld
06:00:58 <lambdabot> Prelude.head: empty list
06:01:02 <Darius> nlv11757_: Yes, but I'd have to figure how to do that conveniently, if my IRC client supported it, and if GHC supported it.
06:01:03 <Lemmih> @babel en fr Hello world.
06:01:05 <lambdabot> Prelude.head: empty list
06:01:20 <Darius> @babel en c Hello World
06:01:21 <lambdabot> Error: Language c not supported
06:01:25 <nlv11757_> ahhh darius, you meant *conveniently* :P
06:01:58 <nlv11757_> thats how it should be....dont support C
06:02:11 <dons> he
06:02:58 <shapr> hah, my proprietary patch
06:03:31 <dons> :P
06:03:40 <shapr> It's just a haddock hack.
06:15:29 <shapr> excitement!
06:15:32 <shapr> @quote
06:15:33 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available
06:15:33 <lambdabot> today.
06:16:13 <Lemmih> @help quote
06:16:14 <lambdabot> Sorry, I don't know the command "help", try "lambdabot: @listcommands"
06:17:42 * Darius thinks the 6.4 CPP defines in the documentation are out of date.
06:20:32 <Darius> @listmodules
06:20:33 <lambdabot> I have the following modules installed: ["babel","base","dict","dynamic"
06:20:33 <lambdabot> ,"eval","karma","plugs","quote","seen","state","system","topic","type","
06:20:33 <lambdabot> version"]
06:21:58 <Darius> No dynload? ;)
06:22:10 <dons> had to install a new module
06:22:16 <dons> TheHunter:!
06:22:18 <dons> @pl
06:22:19 <lambdabot> Sorry, I don't know the command "pl", try "lambdabot: @listcommands"
06:22:26 <dons> @listmodules
06:22:27 <lambdabot> I have the following modules installed: ["babel","base","dict","dynamic"
06:22:27 <lambdabot> ,"eval","karma","pl","plugs","quote","seen","state","system","topic","type"
06:22:27 <lambdabot> ,"version"]
06:22:39 <Darius> Argh! -Werror
06:22:48 <dons> damn straight.
06:23:06 <Darius> What file is @quote in by the way?
06:23:16 <TheHunter> @pointless \f x -> x >>= f . return
06:23:16 <lambdabot> (=<<) . (. return)
06:23:23 <TheHunter> @pointless \f x -> x >>= return . f
06:23:24 <lambdabot> fmap
06:23:49 <dons> :D
06:23:56 <TheHunter> cool, thanks.
06:24:19 <dons> Darius, currently just my home dir
06:24:47 <dons> but shapr has happily fiilled it up with good quotes, so I can import it properly now.
06:26:39 <Darius> dons: By the way, what do I need to do to push changes if anything special?
06:29:09 <dons> atm there's no push. just send.
06:29:17 <dons> i'll have to think how to set that up.
06:29:59 <dons> darcs send is probably the most easiest for now
06:33:48 <Lemmih> @pointless \x y -> [x-y .. y-x]
06:33:49 <lambdabot> s (s . (enumFromTo .) . (-)) (flip (-))
06:33:53 <Lemmih> s?
06:34:06 <TheHunter> get-definition S
06:34:10 <TheHunter> @get-definition S
06:34:10 <lambdabot> S = \f g x.f x (g x)
06:34:17 <Lemmih> ah.
06:35:58 <TheHunter> hmm, strange
06:36:06 <TheHunter> @pointless flip (-_
06:36:07 <lambdabot> (line 1, column 7):
06:36:07 <lambdabot> unexpected "-"
06:36:07 <lambdabot> expecting lambda abstraction or expression
06:36:08 <TheHunter> @pointless flip (-)
06:36:08 <lambdabot> flip (-)
06:36:11 <TheHunter> @pointless flip (-) 3
06:36:12 <lambdabot> subtract 3
06:37:12 <xerox> @type fmap
06:37:45 <lambdabot> fmap :: forall (f :: * -> *) b a.
06:37:45 <lambdabot>         (Functor f) =>
06:37:45 <lambdabot>         (a -> b) -> f a -> f b
06:38:14 <xerox> @type \f x -> x >>= return . f
06:38:16 <lambdabot> \f x -> x >>= return . f :: forall a (m :: * -> *) b.
06:38:16 <lambdabot>                             (Monad m) =>
06:38:16 <lambdabot>                             (a -> b) -> m a -> m b
06:38:34 <Darius> Isn't there a pragma that keeps GHC from issueing a warning for unused args (per function) or am I thinking of a different language?
06:38:57 * Darius needs to turn off compiling with optimizations
06:39:42 <dons> you hacking the bot?
06:40:25 <Darius> Yes.  With any luck it will build and run properly on Windows minus a few modules.
06:40:30 <dons> if so, config.mk:HC_OPTS+= -Onot -fasm -H64m
06:40:32 <df_> darius :: there is
06:40:37 <nlv11757_> @seen me
06:40:38 <lambdabot> I haven't seen me
06:40:38 <dons> cool.
06:40:56 <dons> I am hoping to wipe out the -package posix as soon as possible
06:41:57 <Darius> I implemented a Posix module with just popen and if the bot builds I'll see if it works on Windows.
06:42:19 <Darius> The Signals stuff in IRC.hs is conditionally defined out.
06:43:28 <Darius> df_: It's {-# UNUSED var var var #-} if I remember right.  A brief look at the User Guide didn't have it jump out at me.
06:46:07 <df_> sorry, thought you were after -fno-warn-unused-binds
06:52:15 <Darius> dons or someone: Did you figure out what that "Prelude.read: no parse" on startup was?
06:52:25 <dons> do you get it too?
06:52:43 <dons> I haven't been able to reproduce this
06:54:44 <Darius> I think it's in the babelfish stuff, that's one of the few places with read.  I'll tell you in a sec.
06:55:20 <dons> the only thing I thought it might be was babel's quote/remember code trying to read the quotes files
06:55:49 <Itkovian> aft'noon
06:56:04 <Darius> Well, I'll not load the babel stuff and see if that helps.
06:56:06 <shapr> hoi Itkovian
06:56:35 <dons> and  replacing the reads as Igloo suggested is wise
06:56:42 <shapr> Itkovian: have you seen lambdabot after the fashion makeover?
06:57:32 <Itkovian> nope
06:58:11 <shapr> lots of cool new plugins.
06:58:14 <dons> we have @plugs @pointless @quote @babel @kind @version. hmm what else?
06:58:32 <Darius> @index
06:58:33 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
06:58:50 <Itkovian> nice.
06:58:54 <Itkovian> anyway, gotta go.
06:58:55 <Itkovian> ttyl
06:58:56 <shapr> cya
06:59:02 <Darius> That was quick.
06:59:10 <shapr> Just a coffee break I guess.
06:59:34 <Itkovian> nope, going home.
07:02:01 <boegel> hey Itkovian
07:02:31 <boegel> @quote
07:02:32 <lambdabot> samc says: monads are hard, let's go shopping
07:02:39 <boegel> @quote
07:02:40 <lambdabot> autrijus says: woot. I got larry wall started learning Haskell ;)
07:02:45 <boegel> @quote
07:02:46 <lambdabot> samc says: monads are hard, let's go shopping
07:02:52 <boegel> heh, original :p
07:02:54 <boegel> @quote
07:02:54 <lambdabot> hakko says: most programmers have a lot of religious issues about their
07:02:54 <lambdabot> work, yes.
07:03:01 <boegel> @quote
07:03:01 <lambdabot> samc says: monads are hard, let's go shopping
07:03:11 <boegel> okay, I quit, enough samc for today :D
07:03:49 <shapr> @quote dons
07:03:50 <lambdabot> dons hasn't said anything memorable
07:03:55 <shapr> @quote autrijus
07:03:56 <lambdabot>   Well, ever since the monadic revolution of '98 Haskell people have started
07:03:56 <lambdabot> to do real world apps
07:04:07 <shapr> hoi swiert
07:04:15 <swiert> hi shapr
07:04:21 <shapr> How's code?
07:04:25 <Darius> @quote Darius
07:04:26 <lambdabot> Darius hasn't said anything memorable
07:04:28 <dons> @quote ghc
07:04:29 <lambdabot>   Can't mix generic and non-generic equations for class method
07:04:30 <Darius> :(
07:04:48 <swiert> pretty good, although I haven't been coding that much lately.
07:05:02 <Darius> @karma- lambdabot
07:05:03 <lambdabot> lambdabot's karma has been decremented.
07:05:09 <shapr> @quote darius
07:05:10 <lambdabot>   I imagine XSLT programmers say "It's a one pager" the way most other programme
07:05:10 <lambdabot> s say "It's a one liner".
07:05:21 <Darius> @karma+ shapr
07:05:22 <lambdabot> shapr's karma has been incremented.
07:05:24 * shapr grins
07:05:39 <swiert> last thing I made was probably a wiki to html "compiler" for my attribute grammar tutorial.
07:05:46 <shapr> neato
07:05:47 <Darius> Hey it ate the 'r' in programmers
07:06:05 <shapr> Yeah, the line-fill code neats some help.
07:06:18 <shapr> swiert: that sounds particularly interesting.
07:06:58 <swiert> shapr: well, to be honest I just wrote a pretty straight-forward parser and hooked it up to the uuag system.
07:07:12 <shapr> Since I've never used UUAG, that sounds very interesting.
07:07:35 <shapr> I'd like to compare AGs to arrows, I'm still haven't seen enough evidence to convince myself that they're equivalent.
07:07:46 <swiert> yeah - I think it's a neat test case. I want to release it together with my TMR article so people can actually get their hands dirty.
07:07:55 <shapr> But that's because I lack info on AGs.
07:08:16 <swiert> shapr: oh I'm quite convinced that AGs and arrows capture common abstractions.
07:08:53 <shapr> I understand arrows, I don't understand AGs. I'm slowly getting vague ideas about AGs, but no more than that. Therefore, I look forward to your article.
07:09:12 <swiert> I'll be sure to write something about AGs vs Arrows/Monads.
07:09:37 <swiert> shapr: next issue in May?
07:09:42 <shapr> Yup
07:10:01 <shapr> And this time I'd like to have less panic, I should start organizing now!
07:10:47 <swiert> I guess there's always a certain amount of panic in organizing these things.
07:10:57 <swiert> you can only minimize it by starting early.
07:11:13 <shapr> Yup
07:12:01 <shapr> I wonder if it's a problem for lambdabot modules to depend on SerTH.
07:13:19 <dons> hmm. we could import it
07:13:33 <dons> (I presume)
07:13:43 <shapr> Would be an nice way to transparently handle serialization of basic types.
07:14:43 <dons> well, read/show works. but if we want big-time storage of values it looks like a good soln. so does class Binary derived with DrIFT.
07:15:47 <boegel> @quote boegel
07:15:48 <lambdabot> boegel hasn't said anything memorable
07:15:51 <boegel> :o
07:16:19 <boegel> I haven't ? =(
07:16:35 * Lemmih hands boegel a tudekiks.
07:16:46 <dons> @timein london
07:16:48 <lambdabot>   Wednesday, March 30, 2005 at 4:17:47 PM BST
07:16:50 <dons> @timein sydney
07:16:52 <lambdabot>   Thursday, March 31, 2005 at 1:17:51 AM EST
07:17:03 <Lemmih> @timein copenhagen
07:17:04 <lambdabot>   Wednesday, March 30, 2005 at 5:18:04 PM CEST
07:17:07 <mflux> @timein tampere
07:17:08 <lambdabot>   
07:17:10 <mflux> ha!
07:17:27 <dons> @timein help
07:17:28 <lambdabot>   http://www.timeanddate.com
07:17:29 <Lemmih> @timein odense
07:17:31 <lambdabot>   
07:18:01 * Darius remembers part of why he was using nirc.
07:18:51 * boegel throws Lemmih's tudekiks against the wall and screams: "Here's something memorable !"
07:19:16 <Igloo> Where's UNSW again?
07:19:54 <dons> sydney
07:21:30 <Igloo> ta
07:21:35 * Darius is getting confused.
07:22:53 <nlv11757_> @timein Amsterdam
07:22:55 <lambdabot>   Wednesday, March 30, 2005 at 5:23:54 PM CEST
07:22:58 <nlv11757_> :O
07:23:00 <nlv11757_> time to go home
07:23:02 <nlv11757_> cya
07:24:18 <xerox> Do you know what slushy and jangling mean?
07:25:44 <dons> slushy = mushy ice/water mix. jangling = noise made by small bits of metal hitting each other, as in keys
07:26:43 <xerox> Thanks, just finished english homeworks :)
07:27:42 <dons> :p
07:27:55 <dons> I want a lambdabot patch in return, then
07:28:08 * Darius hopes a make clean will make things work.
07:28:27 <dons> @timein tingha
07:28:30 <lambdabot>   Sorry, don't know this city
07:28:33 <dons> good
07:28:40 <dons> make distclean ?
07:28:50 <Darius> That shouldn't be necessary.
07:28:51 <Igloo> What have you got against the Tinghaians, then?
07:29:42 <Darius> @timein washington
07:29:42 <dons> heh. I grew up near there. very small rural town in NSW. pop. 200.
07:29:44 <lambdabot>   
07:30:36 <Darius> Is it just me or did lambdabot say nothing?
07:30:37 <xerox> I'd like to do a lambdabot patch, but I can't understand the sources as-is, can you suggest me where to start?
07:30:48 <Darius> xerox: What do you want to do?
07:30:49 <xerox> Darius: it didn't say nothing here too.
07:31:07 <dons> trying to work out what happened. but it could just be timeouts over http again
07:31:11 <xerox> Darius: hmm, I had some ideas while ago, I'll have to `grep` them :)
07:31:29 <Darius> Gah, I need to get used to using ion again.
07:31:49 <dons> ah. too many washingtons.
07:32:27 <xerox> Something in the TODO list, maybe.
07:32:29 <Igloo> If you're just looking for something to do, then having lambdabot able to be told and remember a person's location, and give thier localtime, would be nice
07:33:00 <Darius> xerox: or add @help and docstrings to each of the commands
07:33:31 <xerox> Beside *what* to do, I need to start understanding the sources, where can I start from? I need some "entry point".
07:33:43 <dons> Igloo's suggestion could be done by adapting the @qute/@remember code (which is an association list of nicks to strings), combined with @timein
07:33:59 <Darius> xerox: Not really depending on what you want to do.  Just look at another module to see how they are written.
07:35:12 <xerox> Makefile:81: depend: No such file or directory
07:35:19 <dons> harmless
07:35:35 <dons> happens when you try to include the depend file before you create it
07:35:47 <xerox> That's the first thing `make' outputs, altrought it compiles.
07:36:22 <dons> should use -include
07:36:23 * Darius did get some warnings with respect to orphan instances that shouldn't be my fault which will presumably stop a compile with -Werror.
07:36:42 <dons> yeah, Typeable with 6.4
07:36:50 <Darius> Yes.
07:36:51 <xerox> No other errors beside this warning: Warning: orphan instances: instance Data.Typeable.Typeable (Data.Map.Map key elt) = $fTypeableMap
07:36:53 <dons> have to read the docs to sort that one.
07:36:55 <Igloo> Does that happen even if there's a make rule to build depend?
07:36:57 <xerox> Whoops.
07:37:27 <dons> Igloo: yep.
07:37:52 <Igloo> Oh  :-(
07:38:10 <xerox> Also instance Data.Typeable.Typeable System.Time.ClockTime = $fTypeableClockTime
07:38:23 <dons> lesson 1: GNU make's module system is unusual
07:38:38 <dons> -include fixes the warning, anyway
07:39:15 <xerox> vegai: did you solved that Exception raised by read ?
07:39:38 <dons> xerox: you get it?
07:39:59 <xerox> dons: Yep.
07:40:15 <dons> ok. i'll have a look
07:40:21 <Darius> It may be @eval's fault, but I'm not sure why.  If it's not finding the file it would give a different error and there doesn't seem to be any reason for it not to parse.
07:40:29 <xerox> If you need specific informations, tell me.
07:40:51 <Darius> I'm going to write a little program to see if it reads the definitions file properly.
07:40:51 <dons> eval not finding it's definitions?
07:41:57 <dons> @timin Sydney
07:41:58 <lambdabot> Sorry, I don't know the command "timin", try "lambdabot: @listcommands"
07:42:01 <Darius> Actually, I just finished rebuilding lambdabot which shouldn't be loading either Eval or Babel and I still get it.
07:42:01 <dons> @timein Sydney
07:42:04 <lambdabot>   Thursday, March 31, 2005 at 1:43:03 AM EST
07:42:17 <dons> hm. ok. i'll have to look tomorrow. time for some sleep
07:42:39 <dons> it's been a 15 hour lambdabot hack now :)
07:42:46 <xerox> @timein Torino
07:42:48 <lambdabot>   Wednesday, March 30, 2005 at 5:43:47 PM CEST
07:43:07 <xerox> Yay, goodnight dons.
07:43:18 <Darius> -prof -auto-all ho!
07:43:43 <xerox> Darius: do you get that Exception too?
07:43:45 <psi> @timein Luleå
07:44:03 <Darius> xerox: Yes.
07:44:22 <lambdabot>   
07:46:23 <TheHunter> @plugs let hamm = 1: map (*2) hamm `merge` map (*3) hamm `merge` map (*5) hamm ; infixr 5 `merge`; merge (x:xs) (y:ys) = case compare x y of LT -> x: merge xs (y:ys); EQ -> x: merge xs ys; GT -> y: merge (x:xs) ys in take 10 hamm
07:46:30 <basti_> boink
07:46:48 <TheHunter> @plugs let hamm = 1: map (*2) hamm `merge` map (*3) hamm `merge` map (*5) hamm ; infixr 5 `merge`; merge (x:xs) (y:ys) = case compare x y of LT -> x: merge xs (y:ys); EQ -> x: merge xs ys; GT -> y: merge (x:xs) ys in take 10 hamm
07:46:51 <lambdabot> [1,2,3,4,5,6,8,9,10,12]
07:47:06 <basti_> huh
07:48:34 <Darius> You can declare fixities at "run-time" in Plugs?
07:49:13 <Igloo> plugs calls ghc to compile its argument
07:50:16 <Igloo> I don't see why that should be more surprising than being able to define functions, anyway?
07:50:53 <basti_> because it involves modification of the parser
07:51:10 <basti_> which is a new feature in programming languages, to my knowledge.
07:51:46 <Igloo> Haskell is normally parsed assuming all operators to be r9, and then post-processed after parsing
07:52:11 * Igloo doesn't know how old the feature is, but it must be at least 7 years old  :-)
07:53:38 <Darius> Igloo: Is putting a fixity declaration there even syntactically legal?
07:53:45 <Igloo> Yes
07:56:10 * Darius thinks the fact that he essentially never uses fixity declarations is showing.
07:57:08 <xerox> TheHunter_: can you explain your code?
07:57:32 <Igloo> Fixity declarations are relatively rare, but local operators are even more so, so local fixity decs are very rare indeed
08:01:03 <TheHunter_> xerox, the hamm code?
08:01:57 <TheHunter_> it computes all numbers that only contain prime factors 2,3,5 in ascending order.
08:03:38 <TheHunter_> merge takes two infinite ascending lists and produces a list that contains all elements of both lists.
08:07:47 <TheHunter_> oooh, scary.
08:07:54 <TheHunter_> @plugs (unsafeCoerce# (1::Int) :: Int)
08:08:01 <lambdabot> 1
08:08:26 <halcyon10> i still get a knot in my brain if i try to comprehend these recursive list-definitions..
08:08:27 <xerox> Does it have anything to do with boxing?
08:08:44 * shapr puts xerox in a very small box
08:08:51 * xerox sighs
08:09:17 * shapr runs unsafeCoerce xerox :: xerox# to get xerox out of the box.
08:09:41 <shapr> halcyon10: do you understand this? "ones = 1 : ones" ?
08:09:47 * xerox finds it interesting, and re-enters into the box to try again.
08:09:51 <Igloo> xerox: The # in unsafeCoerce# means (in this case) it can also be used with unboxed values
08:10:16 <Igloo> Normally it means it can only be used with unboxed values
08:10:20 <halcyon10> shapr: yes
08:10:30 <xerox> What are examples of boxed values, apart from me in a little box?
08:10:50 <shapr> halcyon10: do you see how it's about the same as "fib = 0 : 1 : zipWith (+) fib (tail fib)" ?
08:10:58 <Darius> xerox: Everything in standard Haskell.
08:11:04 <Igloo> Pretty much everything you think of as a value is a boxed value
08:11:20 <xerox> Hm, so what is an unboxed one?
08:11:28 <halcyon10> shapr: yes, i think it takes a bit time to get used to think this way
08:11:29 <Darius> A GHC extension
08:11:42 <Darius> halcyon10: Have you read SICP?
08:11:55 <Igloo> If ghc knows something will always be an actual int, not _|_, then it can used an Int# (unboxed Int) for it instead
08:12:02 <halcyon10> Darius: i think no, what does SICP stand for?
08:12:14 <Darius> "Structure and Interpretation of Computer Programs"
08:12:19 <shapr> halcyon10: http://mitpress.mit.edu/sicp/
08:12:20 <Igloo> The optimiser normally works it out for you, although you can also write code on unboxed values directly yourself
08:12:32 <halcyon10> oh, i see, i'll have a look at it
08:12:49 <Darius> It's a classic as is, but the streams section is the part relevant to what you are asking about.
08:12:50 <Igloo> There are a few other cases you run into them, e.g. IOUArray = IOArray of unboxed values
08:12:57 <xerox> Igloo: I see, so unboxed value doesn't have bound checking.. right?
08:13:17 <halcyon10> shapr: i mean it's a very short and elegant definition of the fibonacci-sequence, but i still don't know if recursion is the natural way of thinking =)
08:13:17 <Igloo> Not quite
08:13:19 <Darius> xerox: A boxed value is represented as a pointer to a value in the heap, an unboxed value is just the value.
08:13:40 <Igloo> unboxed values are already evaluated
08:13:43 <xerox> Using unboxed values is obviously a speed-up, I see.
08:13:51 <Igloo> Thus if you take one as an argument you know that looking at its value won't cause an error
08:14:00 <shapr> halcyon10: I think that either programming is unnatural, or recursion is natural. I'm not sure which is true.
08:14:13 <halcyon10> :)
08:14:43 <shapr> Recursive definitions can be the perfect inductive definitions. First you define a base case, then you define how to take one step towards the base case.
08:14:47 <Darius> halcyon10: Well iterative definitely isn't because encoding arbitrary recursion or following the structure of a data type is quite ugly using just while.
08:14:56 <shapr> length [] = 0 ; length (x:xs) = 1 + length xs
08:15:08 <shapr> greetings leobon
08:15:13 <shapr> Darius: oh hey, have you heard of #sicp?
08:15:18 <xerox> Igloo: can you give/point me to an example?
08:15:30 <Igloo> Of what?
08:15:56 <xerox> Of using of unboxed values, for example.
08:16:07 <Igloo> add (I# i1) (I# i2) = I# (i1 +# i2)
08:16:19 <Darius> halcyon10: Recursion (with TCO) is general, loops are special cases.  Loops are more understandable in the that 2*1 is even is more understandable than forall x.x*(x-1) is even.
08:16:20 <Igloo> is equivalent to   add i1 i2 = i1 + i2
08:16:41 <Darius> shapr: No, if you've been there what is it like or what is it's point/mission statement?
08:16:42 <shapr> I don't think loops are more understandable.
08:16:53 <shapr> I haven't been there enough to know yet.
08:17:07 <Igloo> You shouldn't need to worry about them unless you find GHC isn't optimising something the way you want, though
08:17:28 <xerox> Igloo: Okay, thanks much for the explanation.
08:17:33 <Igloo> And even in such a case you can often convince it to do so with a carefully placed seq or something
08:17:38 <xerox> (Darius too)
08:17:43 <Igloo> np
08:17:49 <xerox> Time to eat something, bbl.
08:17:53 <halcyon10> Darius: I think it depends on the data-type or algorithm if it is represented more naturally in an recursive or imperative way.
08:18:59 <shapr> halcyon10: can you give some examples of more naturally imperative stuff?
08:19:08 <sylvan> IO!
08:19:29 <metaperl> shapr, I ws not around when you asked about adam turoff... he goes by the name of ziggy on use.perl.org so I would imagine his #perl6 handle would be the same: http://use.perl.org/~ziggy/journal/
08:19:41 <shapr> Yeah, I found that journal, looks interesting.
08:19:48 <Darius> Gah, what the hell did it think -prof meant?
08:20:13 <shapr> metaperl: btw, is that the normal 'hostility' level of perl community discussion?
08:20:34 <metaperl> i dont see what is going on in the extremeperl mailing list as hostile at all...
08:20:42 <shapr> ok then :-)
08:20:43 <metaperl> very animated debate but not hostile
08:20:55 <Darius> halcyon10: Certainly, it makes more sense to use map when map is what you want.  But when you want foldAST you'll find most languages don't have such a control structure.
08:20:56 <halcyon10> Darius: yes, i think that's the point. Every time i try to write a recursive algorithm in Haskell i get straight to the point where i have to comprehend the general algorithm in all its complexity to be able to translate it into haskell. the fact that haskell has nearly no fill-code amplifies the impression
08:21:48 <Darius> halcyon10: Recursion combinators (map,foldl,foldr, etc.) are the "loops" of FP.
08:21:53 <shapr> metaperl: I thought Rob's comment about strict typing was hostile.
08:22:05 <basti_> i think you ALWAYS need to know what youre doing before you do it
08:22:17 <metaperl> well, I would say it was critical
08:22:18 <shapr> basti_: that's a brilliant observation.
08:22:26 <metaperl> constructive criticism
08:22:33 * basti_ feels slight irony
08:22:45 <metaperl> Rob just wants to get to the bottom of things... he is not out to defend one view or the other... that I am sure of
08:23:14 <metaperl> but he believes in results. some earlier comments by him were the seeds for my "pumping out the functionality" blog post
08:24:23 <shapr> ok, that explains more of the culture to me.
08:24:53 <TheHunter_>  @plugs has some serious security issues.
08:25:01 <shapr> oh, like what?
08:25:08 <TheHunter_> doing IO isn't really hard
08:25:15 <Darius> Yes, lack of type safety is a massive issue.
08:25:15 <shapr> show us!
08:25:34 <Darius> I was going to ask dons about it, but figured he'd already dealt with these issues before.
08:25:51 <basti_> did I mention it is possible to PROVE things are secure?
08:26:02 <TheHunter_> @plugs let unsafeIOToST :: IO a -> ST s a; unsafeIOToST io = ST $ \ s -> (unsafeCoerce# io) s in runST (unsafeIOToST (readFile "/etc/fstab"))
08:26:04 <basti_> (i found it bizarre too)
08:26:06 <lambdabot> "/dev/wd0a / ffs rw 1 1\n/dev/wd0i /home ffs rw,nodev,nosuid 1 2\n/dev/wd0e
08:26:06 <lambdabot> /tmp ffs rw,nodev,nosuid 1 2\n/dev/wd0f /usr ffs rw,nodev 1 2\n/dev/wd0g
08:26:06 <lambdabot> /usr/local ffs rw,nodev 1 2\n/dev/wd0h /usr/src ffs rw,nodev,nosuid 1 2\
08:26:06 <lambdabot> n/dev/wd0d /var ffs rw,nodev,nosuid 1 2\n"
08:26:12 <halcyon10> shapr: hm, every algorithm which contains no repetition, probably is better suited for imperative programming. But that will be quite few..
08:26:14 <basti_> mmh nice
08:26:27 <Darius> shapr: If you have that old IRC log still, you may want to email it to dons.
08:26:44 <basti_> halcyon10: "imperative" style is just a special case of "functional" style :)
08:26:55 <shapr> I have it around here somewhere, but I wasn't able to find it last night.
08:27:31 <halcyon10> basti: i thought it was the opposite? :)
08:27:43 <Darius> halcyon10: What's an algorithm that has "no repetition" or what do you mean by repetition?  If you mean looping that's a really uninteresting class of "algorithms" and not unnatural in Haskell.
08:28:01 <basti_> hmm you can program a program that interprets "functional" style in an imperative language, but vice versa too.
08:28:38 <basti_> i meant, functional programs is the larger set, as in, there is a set of functional operators so that an imperative program can be expressed
08:28:40 <xerox> basti_: knowing what you're doing before doing it is what Haskell needs, but I have to say my programming experience before it was mainly in dynamic languages - I tried and adapted the code, *while* understanding the problem, using the "REPL" as you can use the calculator.. I mean, the language helped me finding some details faster than thinking about it.
08:29:13 <sylvan> you mean like hugs
08:29:15 <sylvan> =)
08:29:18 <basti_> xerox: i said that half in joke. I know most people program in different ways.
08:29:28 <basti_> xerox: i favour the "interactive" approach too.
08:29:46 <basti_> but i still think its a good thing that in haskell you need to understand what youre doing or you write rubbish
08:30:04 <xerox> basti_: altrought learning Haskell is *very much* worth it, trying implementing some ideas in Haskell could be very helpful/interesting.
08:30:08 <sylvan> functional programming is way better suited for interactive development.. no state to "simulate" in order to test some small part
08:30:25 <basti_> sylvan: right.
08:31:04 <xerox> sylvan: I find something like Scheme "better suited", having the possiblity to draw-back to imperative very fast it's usually handy.
08:31:37 <xerox> ...but maybe it's just me having problems because my little comprehension of Haskell. :)
08:31:38 <stepcutHM> xerox: epigram has some interesting ideas on interactive development (but, unfortunately, is still just a 'toy' language)
08:31:53 <basti_> epigram is...
08:31:55 <basti_> ...
08:32:04 <basti_> it IS.
08:32:16 <xerox> @google epigram
08:32:17 <lambdabot> Sorry, I don't know the command "google", try "lambdabot: @listcommands"
08:32:17 <xerox> ;)
08:32:35 <xerox> I know it is in the wishlist, in the TODO file, heh.
08:32:37 <basti_> actually i favour coq.
08:32:38 <basti_> ;)
08:32:51 <basti_> what?
08:33:26 <halcyon10> probably it boils down to the way of thinking one is used to which style is more favorable. For me it's a challenge to 'think functional' being used to think in loops,etc.. for years:)
08:33:49 <basti_> i did recursive things in C to
08:33:54 <basti_> o
08:34:33 <halcyon10> me too, but if you do it recursive in C you most probably get inefficient code. in haskell you get elegant code
08:34:43 <basti_> ah no.
08:34:49 <basti_> now and then it is the easiest solution
08:34:58 <basti_> maybe a bit slower (but not that much)
08:35:01 <vegai> well... gcc has tail-call optimization
08:35:02 <halcyon10> ok, in C it's elegant, too, but still inefficient
08:35:11 <vegai> don't know how good that is
08:35:21 <basti_> actually it should in many many cases just be slower by a constant factor
08:35:53 <halcyon10> basti_: right, algorithmic complexity is more important
08:36:46 <basti_> yes.
08:37:04 <basti_> even notational complexity is
08:37:33 <sylvan> here's my POV on this: Functional is way more natural to human thought. Imperative programming makes you "think imperatively", which can make it diffictult to program FP for the first few weeks before you "unlearn" the weird thought process that imperative programming demands. However, once you do, you can generally solve problems much easier, with less bugs, and in shorter time because it's just "natural".
08:38:04 <basti_> sylvan: i agree.
08:38:43 <sylvan> And it's also quite evident with newcomers to programming that Haskell is a lot easier to pick up than, say, Java. At least that's my experience here at Chalmers.
08:39:14 <mflux> how about when they need to deal with monads, they seem natural too?
08:39:17 <sylvan> You need to be quite tainted by years of imperative programming to think that FP is "weird" in comparison =)
08:39:29 <sylvan> mflux: yes
08:39:31 <halcyon10> sylvan: yes. i also thinks that FP educates to think about the programming-problem immediately. for me it's kind of to-the-point-programming
08:40:01 <vegai> the same argument has been used for OO programming
08:40:03 <mflux> how about reactive systems?
08:40:23 <sylvan> halycon10: yeah, for lack of a better way to explain it I feel that Haskell is a tool to solve the problem, whereas when programming something in, say, C the language itself is part of the problem you must overcome.
08:41:02 <sylvan> mflux: well it's just a programming pattern.. Just like you can do thinks like Singleton-classes, Subscriber-pattern etc. in OOP..
08:41:17 <sylvan> some of them make more sense than others, but overall FP is just closer to human thought
08:41:19 <halcyon10> sylvan: yes, exactly
08:41:54 <Darius> u
08:42:04 <halcyon10> i have a different question, are function-calls with the same arguments cached in haskell or are they recomputed every time?
08:42:40 * Darius isn't sure he'd agree with necessarily, but it is quite clear that FP is closer to elementary algebra which most people learn early in life.
08:43:05 <Darius> halcyon10: It's not specified, but in practice the latter.
08:43:40 <Darius> halcyon10: In practice, only things referred to by the same name are shared (i.e. updated when any is evaluated).
08:44:40 <halcyon10> how can i check if they are recomputed or not in my program? is there a general way to tell?
08:44:44 <Darius> halcyon10: However, there are ways of writing/turning a function into a memoizing one.
08:45:20 <Darius> halcyon10: Technically no, but an impurity (e.g. Debug.Trace.trace) can show the differenc.
08:45:43 <Darius> halcyon10: You may want to look at the first part of TyingTheKnot on the wiki.
08:45:57 <mflux> darius, I suppose it does use common subexpression elimination though, so return values resulting from calls in the same expression/function would be shared?
08:46:12 <halcyon10> Darius: ok, i'll look at that. Thanks for your answer
08:47:25 * jlouis thinks haskell is about to reach critical mass
08:47:48 <df_> and implode?
08:48:07 <jlouis> no, critical mass in the sense that it is one of those languages that are to stay
08:48:22 <jlouis> Even if a desimonification hits the earth, it will probably survive
08:48:28 <vegai> I think it's well beyond that
08:48:43 <jlouis> vegai: probably
08:48:46 <df_> a what?
08:48:48 <vegai> darcs alone would make that happen :)
08:48:55 <Darius> mflux: The standard certainly doesn't mandate CSE and CSE can cause problems.  Also I believe on GHC does any kind of CSE.
08:49:14 <Darius> jlouis: Haskell has been a language that was there to stay for a long time.
08:49:31 <mflux> darius, hm, why would cse cause problems on a pure language? because of referential equality may still be different?
08:49:46 <Darius> jlouis: But with darcs and Pugs and just it's general growing, it does seem to be reaching new highs.
08:50:11 <mflux> darius, did you mean 'does'->'doesn't'?
08:50:11 <jlouis> Darius: indeed
08:50:35 <jlouis> I fail to see why CSE causes any problems?
08:50:53 <Darius> mflux: I meant "only" not "on"
08:51:35 <Darius> jlouis, mflux: The traditional example is: powerset [] = [[]]; powerset (x:xs) = ps ++ map (x:) ps where ps = powerset xs
08:52:14 <Darius> Given a reasonably sized list you will run out of memory, unsharing the 'ps' will allow to run in reasonable memory.
08:53:07 <Darius> Semantically, everything is fine which is why the Report neither allows nor disallows CSE.
08:53:27 <Darius> In fact, I'm pretty sure the Report allows a call-by-name implementation.
08:53:45 <Darius> (v. call-by-need)
08:54:00 <xerox> Darius: how do you "unshare" ?
08:54:39 <Darius> xerox: Rewrite the second clause as 'powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
08:57:34 <Darius> @plugs product [1..30]
08:57:45 <lambdabot> 265252859812191058636308480000000
08:57:58 <shapr> @quote Alanna
08:57:59 <lambdabot>   Saying that Java is nice because it works on all OS's is like saying that
08:57:59 <lambdabot> anal sex is nice because it works on all genders.
08:58:08 <xerox> @plugs powerset [1..10] where powerset [] = [[]]; powerset (x:xs) = (powerset xs) ++ map (x:) (powerset xs)
08:58:12 <lambdabot> [[],[10],[9],[9,10],[8],[8,10],[8,9],[8,9,10],[7],[7,10],[7,9],[7,9,10],
08:58:12 <lambdabot> [7,8],[7,8,10],[7,8,9],[7,8,9,10],[6],[6,10],[6,9],[6,9,10],[6,8],[6,8,10]
08:58:12 <lambdabot> ,[6,8,9],[6,8,9,10],[6,7],[6,7,10],[6,7,9],[6,7,9,10],[6,7,8],[6,7,8,10]
08:58:12 <lambdabot> ,[6,7,8,9],[6,7,8,9,10],[5],[5,10],[5,9],[5,9,10],[5,8],[5,8,10],[5,8,9]
08:58:12 <lambdabot> ,[5,8,9,10],[5,7],[5,7,10],[5,7,9],[5,7,9,10],[5,7,8],[5,7,8,10],[5,7,8,
08:58:13 <lambdabot> 9],[5,7,8,9,10],[5,6],[5,6,10],[5,6,9],[5,6,9,10],[5,6,8],[5,6,8,10],[5,
08:58:15 <lambdabot> 6,8,9],[5,6,8,9,10],[5,6,7],[5,6,7,10],[5,6,7,9],[5,6,7,9,10],[5,6,7,8],
08:58:17 <lambdabot> [5,6,7,8,10],[5,6,7,8,9],[5,6,7,8,9,10],[4],[4,10],[4,9],[4,9,10],[4,8],
08:58:19 <lambdabot> [4,8,10],[4,8,9],[4,8,9,10],[4,7],[4,7,10],[4,7,9],[4,7,9,10],[4,7,8],[4,
08:58:21 <lambdabot> [168 @more lines]
08:58:25 <xerox> Sorry :)
08:58:29 <shapr> yow!
08:58:30 <Darius> @plugs product [1..10]
08:58:33 <lambdabot> 3628800
08:58:41 <xerox> @plugs powerset [1,2,3] where powerset [] = [[]]; powerset (x:xs) = (powerset xs) ++ map (x:) (powerset xs)
08:58:43 <lambdabot> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:59:05 <vincenz> ouch
08:59:15 <shapr> Finnish has seventeen unique word cases, and they can all be used together on the same word, so each noun in Finnish has how many unique cases?
08:59:25 <shapr> @plug sum [0..17]
08:59:26 <lambdabot> Sorry, I don't know the command "plug", try "lambdabot: @listcommands"
08:59:28 <shapr> @plugs sum [0..17]
08:59:31 <lambdabot> Compiled, but didn't create object file `/tmp/MhEYz19452.o'
08:59:33 <Darius> xerox: length (powerset xs) = 2^(length xs)
08:59:35 * shapr blinks
08:59:54 <xerox> @plugs sum [0..17]
08:59:57 <lambdabot> 153
09:00:07 <jlouis> xerox: check this:
09:00:16 * xerox thinks lambdabot loves me more than shapr ^__^
09:00:19 <jlouis> @plugs length $ powerset [1..10]
09:00:19 * shapr gins
09:00:20 <lambdabot> bzzt
09:00:25 <shapr> xerox: I think lambdabot is tired of me!
09:00:37 <jlouis> bleh
09:00:44 <jlouis> @plugs length $ powerset [1..10] where powerset [] = [[]]; powerset (x:xs) = (powerset xs) ++ map (x:) (powerset xs)
09:00:45 <lambdabot> bzzt
09:00:53 <Darius> let
09:00:55 <xerox> @plugs length $ powerset [1..10] where powerset [] = [[]]; powerset (x:xs) = (powerset xs) ++ map (x:) (powerset xs)
09:01:01 <shapr> yikes!
09:01:11 <Darius> You can't put where on an expression.
09:01:28 <shapr> worked for xerox, didn't it?
09:01:37 <jlouis> it did
09:01:39 <xerox> @plugs let powerset [] = [[]]; powerset (x:xs) = (powerset xs) ++ map (x:) (powerset xs) in length $ powerset [1..10]
09:01:42 <lambdabot> 1024
09:01:45 <jlouis> exactly
09:01:51 <jlouis> 2^10
09:02:18 <vincenz> Shit....I really need to find an optimal algorithm for dataclustering
09:02:29 <shapr> vincenz: google for Hal Daume
09:02:36 <jlouis> haha
09:02:39 <vincenz> Mine has been running for over 12 hours
09:02:40 <xerox> @plugs foo !! 10 where foo = 0 : map (+1) foo
09:02:43 <lambdabot> 10
09:02:54 <shapr> vincenz: It's even clustering code written in OCaml code to make you happy.
09:03:00 <jlouis> what does ``plugs'' refer to?
09:03:11 <xerox> jlouis: hs-plugins used for compiling haskell on the fly.
09:03:20 * xerox hughs dons
09:03:32 * shapr plugs lambdabot 
09:03:45 <xerox> She doesn't love you anymore shapr.
09:03:51 * shapr sniffles
09:04:12 <shapr> If you love something, you let it go...
09:04:17 <shapr> if it comes back to you, it's yours...
09:04:25 <shapr> if it doesn't you HUNT IT DOWN AND KILL IT!
09:04:30 <xerox> yay :D
09:04:36 * shapr snickers
09:04:45 <jlouis> plug and that alanna quote together is bad
09:04:46 <Darius> Well with that gaping security hole, killing it should be quite easy.
09:04:52 <vincenz> hmm
09:04:54 <shapr> jlouis: ewwww
09:05:00 <Darius> @quote jlouis
09:05:01 <lambdabot> jlouis hasn't said anything memorable
09:05:07 <Darius> That's not true!
09:05:15 * xerox wonders if he said anything memorable.
09:05:16 <jlouis> lol
09:05:22 <jlouis> @quote xerox
09:05:23 <lambdabot> xerox hasn't said anything memorable
09:05:27 <jlouis> prolly not
09:05:30 <xerox> That's probably true.
09:05:35 <tuomov> @quote lambdabot
09:05:36 <lambdabot> lambdabot hasn't said anything memorable
09:05:41 <xerox> That's untrue :)
09:05:53 <shapr> @quote jlouis
09:05:54 <lambdabot>   Q: When does one know he has programmed too much Haskell? A: When he uses
09:05:54 <lambdabot> == and /= in everyday IRC chat or when he tries to fix a relationship by
09:05:54 <lambdabot> passing himself as a continuation
09:06:09 * xerox hehs
09:06:32 <vincenz> shapr: thx but unfortunately not what I seek
09:06:44 <shapr> Ah well, first thing I could think of to answer your question.
09:06:44 <xerox> @quote dons
09:06:45 <lambdabot> dons hasn't said anything memorable
09:06:49 <sqrt> jlouis: so did it work?  did it fix the relationship i mean?
09:06:52 <xerox> I do't belive so.
09:06:58 <vincenz> @quote vincenz
09:06:59 <lambdabot> vincenz hasn't said anything memorable
09:07:02 <vincenz> meh
09:07:07 <xerox> @yow
09:07:20 <shapr> er, I haven't submitted the patch yet =)
09:07:27 <xerox> err, yes :
09:07:55 <xerox> (It wasn't a mispelled smiley, it was a cons, obviously)
09:08:06 * shapr tries to con xerox out of some extra bits
09:08:45 <sqrt> do you want it to provide zippy quotes when yowed?
09:08:54 <shapr> It usually does.
09:09:06 <Darius> ghc -prof -auto-all is not ghc -prof -auto-alling!
09:09:15 <Darius> @arr
09:09:15 <lambdabot> Aye Aye Cap'n
09:09:20 * xerox agrees with consing, better than boxing for sure!
09:09:21 <shapr> But I didn't include the yow.lines file in the repository, and Yow.hs doesn't catch errors.
09:10:30 <Darius> printf-style debugging ho!
09:10:59 <wilx> Bah.
09:11:53 <wilx> I cannot find a way to return both new state and result and still make the whole bit serialization thing tail recursive :/
09:13:01 <Darius> wilx: What does the relevant code look like now?
09:13:26 <shapr> hiya Narrenschiff
09:14:05 <Narrenschiff> 'lo!
09:15:28 <wilx> let (res, st) =
09:15:28 <wilx> 			encodeBits' (bb {bitBuf = newBuf, bitCount = newCount})
09:15:28 <wilx> 				  xs
09:15:28 <wilx> 		    in ((bitBuf bb):res, st)
09:15:45 <wilx> The xs is part of the encodeBits' call.
09:16:05 <wilx> The only thing I could come up with is using Data.Queue.
09:16:23 <xerox> @index readFile
09:16:24 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
09:17:48 <Darius> The definition of encodeBits' is required or I'm misunderstanding something.
09:18:18 <wilx> Mmm, just a sec.
09:19:12 <wilx> http://logout.sh.cvut.cz/~wilx/lzw/BitIO.hs
09:21:23 <wilx> The whole thing is still incomplete.
09:22:17 <autrijus> clkao++ # core darcs patch algebra API landed on SVK
09:28:14 <xerox> I can't try it because of that Exception.. what do you thing about:
09:28:15 <xerox> yowParse :: FilePath -> IO [[Char]]
09:28:16 <xerox> yowParse filename = do catch (do rawfs <- readFile filename
09:28:16 <xerox>                                  return ( Util.split "\00" rawfs ))
09:28:16 <xerox>                              (\_ -> return (["Cannot open " ++ filename]))
09:29:32 <Darius> wilx: You need (another) accumulating parameter or continuation.
09:29:52 <Darius> autrijus: Have you used monads in your Perl programming or do you think you might?
09:30:06 <wilx> Hmm.
09:30:35 <wilx> I know nothing about CPS, I guess the accumulator is what I will use.
09:31:37 <Darius> wilx: Essentially, instead of the base case returning ([],bb) it should return (acc,bb)
09:31:53 <shapr> xerox: does that work?
09:32:03 <Darius> Maybe with a reverse thrown in for giggles and kicks.
09:32:20 <xerox> shapr: I don't know, because launching lambdabot raises an exception, dons knows and it's working on it tomorrow.
09:32:36 <wilx> Well, with reverse it would mean I get a big intermediate list.
09:32:37 <wilx> No good.
09:32:39 <xerox> I could at least try compiling it.
09:32:46 * Darius curses!
09:33:16 <wilx> What I want is filter like thingy...if it is even possible.
09:35:03 <Darius> wilx: You could rely on lazy evaluation.
09:35:45 <xerox> shapr: it compiles, it seems.
09:36:00 <wilx> Would using Data.Queue be properly lazy? Without big intermediate list if I trow in some big input?
09:36:06 <shapr> What's the launch exception?
09:36:13 * shapr tries
09:36:26 <xerox> shapr: as it finish compiles I'll show you.
09:36:31 <xerox> compiling, even
09:36:36 <xerox> Exception: Prelude.read: no parse
09:36:49 <autrijus> Darius: no. monadic programming in perl is painful.
09:36:56 <shapr> hm, weird.
09:36:57 <autrijus> so, if I want monads, thank you, I'll write in haskell
09:37:11 <xerox> shapr: can you try "my patch" ?
09:37:28 <xerox> (If it's worth something)
09:37:29 <Darius> wilx: I don't think so.  It (may) depend on the implementation, but I imagine that it effectively does the same accumulate and reverse trick.
09:39:04 <wilx> Hm.
09:39:08 <wilx> Speaking generally.
09:40:30 <wilx> How do you do any filter like thing in Haskell if it is not 1:1 mapping or N->M, with N>=M?
09:41:09 <shapr> Make an fmap instance of your datatype maybe?
09:41:33 <Darius> wilx: Use lazy evaluation.
09:41:58 <wilx> shapr, could you elaborate? Examples?
09:42:00 <Darius> filter p = foldr (\x xs -> if p x then x:xs else xs) []
09:43:31 <Darius> wilx: Your code may already have good streaming behavior.
09:44:21 <astrolabe> concat is a function from a short list to a longer one.
09:46:17 <xerox> Can ghc6.2 and ghc6.4 co-exists safely?
09:46:25 <xerox> (In a debian system, that is)
09:47:41 <Igloo> You can't have official packages of both installed simultaneously
09:47:57 <shapr> wilx: can you give an example?
09:48:04 <Igloo> If you made a ghc6.4 package that could be installed along with ghc6 6.2.2 though (or vice versa)
09:48:24 <xerox> So I have to wait for dons working on the exception, sigh.
09:48:47 <shapr> I get the same exception, hmm.
09:50:56 <wilx> Well, I am trying to "convert" a list of (value, bit_width) pairs to list of Word8. The problem is that one input pair can have no output at all or many Word8s of output. And of course the output depends on previous inputs => state.
09:51:42 <wilx> And one more important thing.
09:52:21 <wilx> I want to preserve the state at the end of input so that I can "restart" the output with new input, so that I can do the conversion in chunks.
09:54:51 <shapr> recursion?
09:55:37 <shapr> wilx: have you seen monadic parsers?
09:55:59 <wilx> Hm, only from afar.
09:57:25 <shapr> You have a bunch of functions that return (Datatype,rest_of_string) and the calling pattern ends up being (Datatype,rest_of_string) -> (Datatype,(Datatype,rest_of_string)) -> (Datatype,(Datatype,(Datatype,rest_of_string))) ->
09:57:27 <shapr> make sense?
09:58:10 <shapr> Then you don't have to worry about whether something returns a value or not, or keeping a bookmark to a place in the stream, or anything.
09:59:02 <shapr> The classic paper on this pattern is Meijer and Hutton's monadic parser combinators paper - http://www.cs.nott.ac.uk/Department/Staff/gmh/monparsing.ps
09:59:27 <shapr> It's a real bolt of lightning the first time you read this paper. *Especially* if you're already having the problem you've described.
09:59:44 <wilx> Hmm. Thanks, I am going to read it now. So far I cannot make much sense from what you have said :)
09:59:48 * shapr grins
09:59:56 <shapr> Just tell me when the lightning happens ;-)
10:00:05 <wilx> Heh, I will :)
10:00:07 <xerox> Is there anything we can do for the Exception? I mean, avoiding some module.. if it's the cause of the problem, dummo really :(
10:00:39 <shapr> xerox: yes, comment out plugin modules until it works, then you know where the error is happening.
10:00:51 <Darius> xerox: Yes, once I (or someone else) figures out where it is.
10:01:01 <xerox> shapr: if only compilation wasn't *so* slow. I'll try btw.
10:01:13 <xerox> It is _not_ in the Babel module.
10:01:34 <shapr> you should be able to comment out plugin modules in the source and run make again
10:01:41 <shapr> Then only part of the recompilation happens.
10:01:47 <shapr> How fast is your box?
10:01:55 <Darius> I think I've figured out why not all modules were getting compiled with profiling, so once this compile finishes I should be able to find the bug quickly.
10:02:55 <xerox> shapr: it is an AMD 3000+, the problem is that process doesn't exactly work. If I comment some module and re-run "make" nothing happens.
10:03:14 <shapr> On linux?
10:03:19 <xerox> Yep.
10:03:26 <shapr> something way broken there.
10:04:01 <shapr> make should check the timestamp on source files, and recompile if it's changed.
10:04:01 <xerox> I `touch' some file and `make'.  This way I get the recompilation done.
10:04:14 <shapr> When you edit, the timestamp isn't changed??
10:04:27 <xerox> But the timestamp of source files doesn't change, if I only modify the Makefile.
10:04:34 <shapr> oh right
10:04:36 <gzl> another question about Parsec. I want to parse wikitext-style lists (e.g. "* item1\n * item2\n"), but the pattern shown at http://www.rafb.net/paste/results/oAekCJ46.html will match the empty list, so you can't use this pattern with 'many' as part of a larger parser. how would one get around this?
10:04:36 <shapr> good point.
10:04:48 <xerox> It is not in Dict.
10:04:54 <wilx> lol, you have AMD 3000+ and you complain about slow compiles?!
10:04:54 <Darius> gzl: many1?
10:04:58 <wilx> Spoiled child :D
10:05:14 <xerox> wilx: yay.
10:05:28 <gzl> hmm, maybe. I had thought many was needed here, but let me see if that doesn't mess stuff up.
10:05:34 <shapr> I'm conflicted, should I get a dual amd64, or save up for a Cell-based workstation?
10:05:49 <wilx> Cell-based? What is it?
10:05:56 <shapr> Like, IBM's Cell cpu.
10:05:59 <Darius> gzl: I haven't really looked at the problem, it just sounds vaguely as if many1 is what you want.
10:06:13 <xerox> The usual hacker problem.  Get the good thing you need now, or the great think you'll need later?
10:06:29 <shapr> IBM claims they'll sell Cell workstations.
10:07:00 <shapr> And I've heard rumors that they've ported Linux to Cell. I can't find any corroboration though.
10:07:26 <gzl> Darius: well you're right that many1 matches 1 or more instead of 0 or more. but the odd thing is that I changed it to many1 and it still throws an exception saying that combinator 'many' is applied to a parser that accepts an empty string. (and i did recompile.) what sense does that make?
10:07:54 <xerox> In fact I've tought about getting an iBook, as Tiger is out.
10:08:10 <gzl> almost out. :)
10:08:20 <shapr> gzl: are you writing a wiki for educational purposes?
10:08:25 <gzl> yes.
10:08:35 <shapr> Ah, ok then. I was going to point you to Flippi.
10:08:58 <gzl> yeah, I've seen flippi. but flippi doesn't handle lists, so i couldn't get any ideas from its code.
10:09:03 <shapr> I added wiki lists to Flippi.
10:09:07 <gzl> ooh
10:09:25 <gzl> let me see how you did that then :)
10:09:28 <shapr> I added a bunch of features to Flippi.
10:09:46 <gzl> that stuff must not be in the latest release
10:10:08 <shapr> Nah, it's not.
10:10:13 <gzl> ok
10:10:19 <gzl> ah, i see dewikify looks much more complicated now
10:10:28 <shapr> I forget which version is the latest release, but the development version has pluggable syntax.
10:10:34 <gzl> ah, i see
10:10:42 <shapr> So you too could define wiki-lists with very little trouble.
10:10:48 <shapr> and you could submit darcs patches!
10:11:05 <shapr> Get your name in lights! (well, CRTs at least)
10:11:35 <wilx> :))
10:11:41 <shapr> If you submit the patch, I'll stick it into the running copy of Flippi...
10:12:13 <gzl> hm, it's not in DefaultSyntax
10:12:41 <shapr> All ya gotta do is create a listPattern parser.
10:12:55 <gzl> well, yeah, that's what I wrote, but it's mildly broken
10:13:09 <gzl> that's what I pasted above
10:13:26 <shapr> oh
10:13:28 * shapr tries
10:14:12 <shapr> Also, you don't need to modify DefaultSyntax.hs you can put your changes into a plugin module. I use ShaeXtensions.hs
10:14:33 <gzl> the problem is that it matches the empty list, and my main parser function works like the old Flippi parser: many (try wikiBold <|> try wikiLink <|> ...), and the many doesn't like parsers that take the empty list. so I tried using many1 like Darius suggested, but it still complains about the use of 'many'
10:15:00 <gzl> which I don't really understand.
10:15:04 <shapr> If you remove the many and/or many1 does it stop complaining?
10:15:10 <Igloo> many1 will have the same problem
10:15:20 <shapr> as in, is this really the many you are looking for?
10:15:27 <shapr> wilx: what do you think of that paper?
10:15:30 <gzl> there are no other manys in the code
10:15:50 <shapr> you could require only a single space.
10:15:52 <Igloo> If wikiBold returns 5 when it consumes no input, then   many (or many1) wikiBold    will give you an infinite list of 5s
10:16:05 <wilx> Hmm, I am not sure...
10:16:07 <shapr> In fact, most wikiList patterns give the number of spaces as the list indent level.
10:16:10 <shapr> hej sond
10:16:13 <gzl> Igloo: ah, right
10:16:14 <Igloo> (possibly with some other prefix)
10:16:16 <sond> shapr, hey
10:16:21 <shapr> sond: how's code?
10:16:24 <gzl> shapr: I've only done it for one indent level right now
10:16:33 <sond> shapr, it's coming along..
10:16:36 <gzl> shapr: I was going to do number of * for indent level
10:16:41 <shapr> Ah, I see.
10:16:45 <sond> shapr, http://d3proj.dyndns.org:8080
10:17:09 <shapr> sond: wow, sexy screenshots.
10:17:26 <sond> =)
10:18:04 <gzl> shapr: sorry, i'm still a little confused. how does requiring only a single space help? the problem is the "<|> return []" which is what's supposed to match when it doesn't find any more "* item"s
10:18:06 <xerox> Did you have try Vital?
10:18:55 <xerox> It can do this kind of things: http://segfaulted.com/~xerox/stuff/pi-220305-1318.png :)
10:19:07 <Darius> gzl: You should make sure you find at least one '* item' otherwise fail.
10:19:52 <shapr> Vital is causing a lot of interest in the academic and real worlds. I'm sort of surprised.
10:20:21 <gzl> Darius: wouldn't that mess up the recursion?
10:20:22 <shapr> Wadler, Darius Bacon, Kragen Sitaker, and more.
10:22:02 <shapr> metaperl_: write more blog entries! =)
10:22:19 <xerox> shapr: it seems magical ^_^
10:22:31 <Darius> gzl: You have listPattern = do i <- parseItem; is <- lp'; return (i:is) where lp = your current definition, but this is what many1 does.
10:22:47 <gzl> oh, hrm.
10:22:59 <gzl> so I could just match one item and do many1 on that pattern
10:23:12 <Darius> Yes
10:24:00 <shapr> So, how to encourage the development of more libraries and applications for/in Haskell?
10:24:35 <shapr> I agree with metaperl's thoughts in his blog - http://sequence.complete.org/blog/16, that we have a wonderful language, and we need more libs and apps.
10:24:39 <Darius> shapr: Make a(nother) killer app.
10:25:03 <shapr> Haskell-OTP with SerTH? distributed lambdabot?
10:25:18 <shapr> Fermat's Last Margin generalized to markup any media, including video?
10:25:49 <sond> shapr, I think we need a good IDE ;)
10:26:04 <shapr> sond: what about mixing Yi and Haste?
10:26:17 <xerox> What's Haste?
10:26:20 <shapr> HastY ?
10:26:28 <sond> shapr, don't know.. haven't really looked into Yi
10:26:29 <wilx> Hmm.
10:26:39 <astrolabe> shapr: Get more people using it I think.  I noticed haskell mentioned on the computer Go mailing list, on wikipedia and on a shootout page.  Generally more publicity is needed I think.
10:26:41 <Darius> sond: It has to be an app not necessarily for Haskell
10:26:50 <wilx> shapr, I think that I see the analogy between the parsers and my problem.
10:27:02 <shapr> astrolabe: so, more cute apps? like a networked Go client?
10:27:06 <wilx> I am not sure how to approach it in my specific case yet though...
10:27:12 <wilx> I will ponder more...
10:27:22 <shapr> wilx: lighting bolt soon...
10:27:26 <xerox> A networked *opensource* Go client would be really nice.
10:27:46 <xerox> KGS client, cute app, is closedsource (and java based) :(
10:28:14 <astrolabe> There is NNGS
10:29:00 <astrolabe> I don't know how nice it is, and IGS, a comercial Go server claim that it has stolen code from them.
10:29:05 <xerox> Not as nice as cgoban2 is :)
10:29:30 <astrolabe> No, cgoban2 and the kgs server are lovely.
10:29:35 * metaperl_ smiles
10:29:36 <gzl> Darius: hmm, you're right about that part
10:30:09 <metaperl_> I am gearing up for the next perl mongers meeting by writing a guestbook in CGI::Prototype... until then just your every Haskell study... no time for philosophy... unless it hits me :)
10:30:45 <vegai> there's one written on ruby
10:31:04 <metaperl_> I like playing at dragongoserver.net
10:31:29 <xerox> Okay, I disabled *all* the modules and I get the exception.
10:31:29 <metaperl_> correspondence Go
10:31:29 <astrolabe> Can Haskell compete with java for GUIs?
10:32:09 <gzl> Darius: and now it no longer whines about the empty list thing, which is good
10:33:05 * metaperl_ heads to an early lunch - it's 10:30am here
10:33:29 <gzl> Darius: ah, slick, this mostly works. thanks a lot :)
10:33:54 <Darius> gzl: You may want to look at Parsec.Tokens by the way.
10:34:45 <Darius> astrolabe: From what I hear and experience Java isn't particularly special or good about GUIs.
10:34:47 <gzl> i'll look at it
10:35:09 <gzl> Darius: only thing is that I had to remove the (spaces) preceding (char '*') in the pattern
10:35:46 <gzl> but i'll futz around with this now
10:35:48 <vegai> http://rubygo.rubyforge.org/
10:36:17 <astrolabe> Darius: but there are lots of nice GUIs written in Java.  I guess it has better libraries.
10:37:30 <TheHunter> i have yet to see a gui written in java that doesn't suck.
10:38:04 <sond> GUI libraries for Haskell are still a bit "in developement"
10:38:23 <astrolabe> Wow.  In what way do they tend to suck?
10:38:34 <Darius> astrolabe: I'd have to agree with TheHunter, but if you are interested in the GUI offerings of Haskell, wxHaskell has the most community support behind it.
10:39:33 <Darius> The libraries and tools page on haskell.org lists some of the other GUI libraries.
10:39:49 <TheHunter> well, swing/awt stuff looks really unnatural. swt's buttons don't work the way they're supposed to do.
10:41:13 <TheHunter> actually, swt is kinda ok.
10:41:45 <TheHunter> but I sure don't wanna write apps using those libs.
10:44:43 <astrolabe> Better than MFC I suspect.
10:44:52 <norpan> gtk2hs is good
10:44:52 <Cale-csc> What was the name of that (pure functional) language which had a drag and drop interface? One would basically construct programs by cloning and modifying things.
10:45:31 <Lemmih> ... if you can live with GPL'ed software.
10:45:32 <Darius> Vital?
10:46:06 <norpan> gpl? gtk2hs is lgpl?
10:46:17 <Lemmih> Yeah but there's no dynamic linking in Haskell.
10:46:39 <norpan> so? you only need to supply the object files
10:46:48 <Cale-csc> It was not Haskell-based
10:47:12 <Cale-csc> It had a flash demo on its website.
10:47:46 <norpan> and you can link dynamically with c stuff
10:47:47 <Lemmih> You _must_ allow the user to link with another version of the library which you can't.
10:48:43 <norpan> you can if you supply the haskell .o files
10:50:59 <norpan> not that i have had any need to
10:51:46 <Igloo> cd /tmp
10:51:49 <Igloo> Bah
10:52:00 <norpan> /tmp: no such file or directory
10:52:28 <Lemmih> Anyhow, I'm staying away from gtk2hs until I can release under a BSD-like license without worrying about breaking the rules.
10:58:05 <astrolabe> There seems to be a choice between fun languages and industrial languages, but I can't see why.
10:59:36 <Lemmih> astrolabe: Google for "LFM LFSP paulgraham", first hit.
10:59:49 <Cale-csc> ah, found it. Subtext.
10:59:54 <Darius> astrolabe: Because industrial languages are backwards compatible with 30 year old languages that were, reasonably, chosen at the time for performance reasons.
11:00:36 <Darius> In a nutshell, legacy code.  From there it's mostly inertia.
11:01:46 <shapr> xerox: what about using make trackdown?
11:02:00 <shapr> err, darcs trackdown?
11:02:27 <astrolabe> Darius: How depressing.  We could be stuck for ever.
11:03:24 <Cale-csc> http://subtextual.org/ - neat idea :)
11:03:47 <shapr> Cale-csc: how does it compare to Self or Wouter van Oortmerssen's languages?
11:04:09 <Cale-csc> well, have a look at the flash demo
11:04:16 <shapr> I'd have to install flash.
11:04:38 <astrolabe> Lemmih: Interesting article.
11:04:42 <shapr> ime, Flash is mostly used as the hi-tek replacement for <BLINK>
11:04:54 <shapr> I might try it.
11:05:20 <shapr> I wish SVG would get ready.
11:05:27 <shapr> Open Source Flash.
11:06:37 <shapr> astrolabe: what about The Monad.Reader? Do you think more domain specific intro text would help Haskell's popularity?
11:10:46 <astrolabe> shapr:  The best advert I've seen for Haskell was that implementation of quicksort.
11:11:24 <astrolabe> I think if more hackers saw haskell code somehow, then many would investigate.
11:11:38 * Darius hates that quicksort
11:11:56 <shapr> astrolabe: what did you like about that quicksort? concise and readable? or what?
11:12:13 <astrolabe> Darius:  I agree it isn't practical, but it looks shockingly good.
11:12:28 <fraxtal> shapr: More snippets with guards and 'where' would get more mathematicians into Haskell
11:12:51 <Darius> fraxtal: And list comprehensions
11:13:10 <integral> I didn't like the quicksort example :-)   I found it too terse to explain the algorithm
11:13:51 <astrolabe> shapr:  What I liked was that it looked like some notes I might make on how the algorithm worked.  So concise!
11:14:28 <astrolabe> Are you a maths type integral?
11:14:48 <integral> I am :-)   But I hadn't read the quicksort algorithm before, and the code didn't really explain it imho
11:14:59 <integral> I was then put off by the page below it just explaining it
11:15:39 <astrolabe> I had come across qs before, which helped.
11:16:38 <shapr> hoi goron
11:17:09 <astrolabe> Maybe for a non-haskeller, there is enough information in the code to recognise an algorithm he knows, but not to understand a new one.
11:17:21 * Darius thinks about voting on shapr's sequence poll.
11:18:34 <astrolabe> Nope, I've looked at it again   http://en.wikipedia.org/wiki/Haskell_programming_language   and I think it's gorgeous
11:19:23 <shapr> I think I voted points-free. That's how I judge my own level of understanding.
11:19:31 <integral> oh, I hadn't seen that one,  that's much better than the one on haskell.org
11:21:43 <astrolabe> So what algorithms are most programmers familiar with, that would flatter haskell?
11:21:51 <Lemmih> Hey Oeje1!
11:22:10 <Oeje1> Greetings, Lemmih.  :-)
11:22:35 <Darius> astrolabe: There are signs that most programmers aren't familiar with algorithms...
11:22:48 * shapr was thinking the same thing
11:22:52 <xerox> shapr: darcs trackdown?
11:23:04 * Lemmih is being greatly annoyed by wxHaskell.
11:23:10 <shapr> Yeah, trackdown is a really cool feature.
11:23:54 * Darius is annoyed by it because (last I checked) there wasn't a 6.4 binary and rampant lying to GHC didn't work.
11:24:22 <xerox> @version
11:24:23 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
11:24:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:25:47 <xerox> $ darcs trackdown
11:25:47 <xerox> Success!
11:26:02 <shapr> yeah, you need to hack up a 'darcs test' for lambdabot first.
11:26:21 <sond> lemmhi, you too? :)
11:27:19 <sond> i'm struggling with flickering and other redraw bugs in windows.. works fine in Linux
11:27:39 <shapr> xerox: trackdown - http://www.darcs.net/manual/node7.html#SECTION00793000000000000000
11:28:10 <Darius> astrolabe: mergesort would be an algorithm better suited to Haskell.
11:28:44 <xerox> shapr: nifty!
11:28:45 <Lemmih> I'm having problems with window{Freeze/Thaw} and the missing word wrapping with staticText.
11:29:09 <sond> lemmih, mmkaty
11:29:12 <astrolabe> Darius: Was it the version of quick sort that I linked to that you didn't like?  If so, why not?
11:31:26 <Lemmih> sond: Gotten it to work in GHCi?
11:31:43 <sond> lemmih, wxHaskell? yes
11:31:49 <Lemmih> On Linux?
11:32:13 <sond> yep
11:32:47 <sond> Lemmih, it doesn'
11:32:51 <sond> Lemmih, it doesn't work for you?
11:33:08 <Darius> astrolabe: Yes (it's essentially the same as the one in the Short Introduction).  I don't like it because it's O(n^2) average case and likely with an unpleasant constant factor which pretty much defeats the point.  I especially didn't like it as a comparison to the C code.
11:33:17 <Lemmih> No. And I haven't meet anyone besides you for whom it worked.
11:33:44 <xerox> PlModule/Rules.hs:28:5:
11:33:44 <xerox>     Warning: This binding for `a' shadows an existing binding
11:33:44 <xerox>              In the definition of `/='
11:33:45 <Darius> I had earlier versions working in GHCi on Windows I'm pretty sure.
11:33:48 <xerox> Hmpf.
11:33:59 <Lemmih> sond: Try running 'start (frame [])' twice.
11:34:13 <sond> really? I remember using ghci with wxHaskell in Linux and got some strange segfaults, but that's all
11:35:05 <Lemmih> Darius: Of course it works under windows (: Daan Leijen is a windows user.
11:35:14 <Darius> Somewhere I read some comments about wxHaskell not working properly in GHCi (probably the wxHaskell page).  I think it said they were fixed with the latest version or would be fixed in the next version, or perhaps I'm creating it out of thin air.
11:35:17 <sond> lemmih, it segfaults the second time?
11:35:19 <xerox> shapr: does the darcs trackdown'd version of lambdabot compiles for you?
11:35:26 <Lemmih> sond: Yep.
11:35:35 <shapr> I haven't created any tests for lambdabot.
11:35:50 <xerox> So, I misunderstood.
11:35:53 <astrolabe> Darius: Code has two purposes: to be read by people, and read by machines.  I agree that the implentation is inefficient, but isn't that a compiler technology problem?  I think it is a very clear concise statement of the quicksort algorithm.
11:36:18 <sond> lemmih, okay I just thought that was something weird with our code, since I didn't get that bug when using wxHaskell at an earlier time in Linux.
11:36:18 <shapr> xerox: just a moment..
11:36:39 <shapr> xerox: what trackdown command do you use?
11:37:23 <TheHunter> xerox, PlModule/Rules.hs doesn't define /= on line 28.
11:37:30 <xerox> "darcs trackdown" ?
11:38:32 <xerox> TheHunter: you're right, dunno really.
11:38:39 <shapr> look at the example usage of darcs trackdown, what about darcs trackdown 'autoreconf && make && ./lambdabot' ?
11:39:07 <xerox> Ah! I see.
11:39:22 <xerox> Noone passed the test!
11:39:28 <xerox> (It says)
11:39:58 <shapr> hm, I think something's broken there.
11:40:04 <Darius> astrolabe: As a specification it's okay, but there is no reason to use this quicksort version over say insert sort, insert sort would probably be faster.  Asymptotic complexities are part of the algorithm in my opinion.  I don't consider it a compiler technology problem.  Admittedly, I think a concatenate/map/reverse-vanish technique would regain the asymptotic complexity.
11:41:14 <Darius> Still mergesort or treesort is a better example all around.
11:41:50 <shapr> greetings nbb
11:43:04 <nbb> hi
11:43:10 <boegel> hi
11:43:12 <shapr> nbb: learning Haskell?
11:43:30 <nbb> always learning it :)
11:43:57 <sylvan> Darius: qsort isn't O(n^2) average case...
11:43:59 <astrolabe> Darius: I agree asymptotic complexity is essentially part of the algorithm, but does haskell specify the conversion from code into an algorithm?
11:44:06 <shapr> So, do any of the Italians here know Moggi?
11:44:08 <sylvan> and I don't see why the haskell definition would be
11:45:12 <Darius> sylvan: I know.  That's why I don't consider the "pretty qsort" qsort (or a good example of it).  The problem (if nothing else) is due to the repeated copying of the prefix by (++).
11:45:42 <astrolabe> There is a space thing with quicksort too, it can be done in place.
11:45:47 <xerox> shapr: Moggi, has he anything to do with soccer?
11:46:10 <boegel> shapr: I know Mogwli, but I'm guessing that's not what you're aiming for
11:46:13 <sylvan> but even with the execssive copying it's still O(n logn) average case, no?
11:46:43 <nbb> Eugenio Moggi... Saw him, but never spoke to him.
11:46:58 <shapr> you've seen him!
11:47:25 <nbb> yes... guess my country :)
11:47:34 <boegel> italy !
11:47:43 <nbb> too easy, I think
11:47:52 <shapr> Yeah, but I live in Sweden, doesn't mean I've met all the Haskell guys living in Sweden.
11:48:01 <Darius> sylvan: If we assume the partition splits the list in half on average, we will copy the first half once, the first half of the first half of both first halfs twice, etc.
11:49:52 <sylvan> I don't understand.. We will split it in two (which is at worst an O(n) operation) and this will cause the algo to be run log n times before hitting the base case. The (++) is also at worst O(n) which would mean O((n+n)*logn)
11:50:41 <shapr> nbb: Have you taken classes from Moggi?
11:51:24 <nbb> shapr: unfortunately, no. Just saw him at some conference
11:53:04 <SyntaxNinja> 'morning #haskell
11:53:05 <Lemmih> SyntaxNinja: Yo.
11:53:11 <boegel> hey SyntaxNinja
11:54:05 <Lemmih> SyntaxNinja: Have you been able to build Hackage/
11:54:12 <Lemmih> s/\/?/
11:54:23 <Lemmih> s/\//?/
11:55:27 <SyntaxNinja> Lemmih: haven't gotten around to it; I was hoping shapr would just let me use his machien to build it...
11:55:43 <shapr> wfm
11:55:45 <SyntaxNinja> I'm feeling lazy since my system is a little b0rked due to the haskell-in-sid siatuation
11:56:10 <rik> hah
11:56:25 <boegel> any Latex experts here?
11:56:32 <rik> i know some.
11:56:43 <xerox> Maybe you'll find some in #latex :)
11:56:53 <SyntaxNinja> I COULD just install hsql that cosmicray made for us debian users, but that uses ghc 6.2, and I had installed igloo's 6.4, and hsql depends on cabal 0.5 which needs 6.2, but hackage needs 6.4, etc
11:57:06 <SyntaxNinja> in short, this is why we have cabal
11:57:40 <Darius> sylvan: Hmm, you may be write
11:57:57 <Darius> s/write/right
11:58:04 <boegel> rik: the default font in Latex is roman, right ? do you know how I can change it to sans serif ?
11:58:47 <rik> nope!
11:58:53 <rik> but #latex will do
11:58:59 <sylvan> Darius: I'm pretty sure I am =)
11:59:05 <boegel> rik: good idea (xerox too, good idea :p)
11:59:17 <xerox> Hm, I knew how to do it..
11:59:29 <xerox> I don't recall, tought :)
12:00:08 * rik contemplates how to being writing this code
12:00:18 <rik> begin too
12:00:55 <astrolabe> being sounds more zen
12:01:18 * rik meditates on the lack of existance of his code
12:01:44 <xerox> This is metaphysical programming.
12:04:13 <Oeje1> Wow.
12:04:19 <Darius> Compiling lambdabot with profiling seems to be causing it to segfault.
12:04:23 <shapr> neat
12:04:48 <boegel> xerox: #latex isn't that active :s
12:04:59 <xerox> boegel: oh :( Let me try to help you. Wait a sec.
12:05:14 <astrolabe> Perhaps it has become sentient and is trying to escape its segment.
12:06:32 <Darius> Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
12:10:20 <Darius> @index mif :(
12:10:21 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
12:10:43 <shapr> Speaking of which, how do I handle import most of the Haddock sources into a lambdabot module?
12:11:09 <shapr> @quote darius
12:11:10 <lambdabot>   Well profiling does add a bit of reflection, but it should have the good
12:11:10 <lambdabot> sense not too go near the barbed wire fences and armed guards.
12:11:24 <Darius> @quote shapr
12:11:25 <lambdabot>   Academics are continually chewing pieces off of impossible and making
12:11:25 <lambdabot> them merely difficult.
12:12:15 <Darius> @version
12:12:16 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
12:12:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:14:23 <shapr> Ã³la masm
12:14:31 <Darius> @listmodules
12:14:32 <lambdabot> I have the following modules installed: ["babel","base","dict","dynamic"
12:14:32 <lambdabot> ,"eval","karma","pl","plugs","quote","seen","state","system","topic","type"
12:14:32 <lambdabot> ,"version"]
12:14:40 <Darius> @listcommands quote
12:14:41 <lambdabot> Module quote provides the following commands: ["fortune","yow","arr"]
12:14:48 <Darius> @listcommands base
12:14:49 <lambdabot> Module base provides the following commands: []
12:15:09 <Darius> shapr: What module is @quote in?
12:15:14 <Lemmih> @listcommands system
12:15:15 <lambdabot> Module system provides the following commands: ["listchans","listmodules"
12:15:15 <lambdabot> ,"listcommands","join","leave","part","msg","quit","reconnect","echo"]
12:15:17 <shapr> babel, surprisingly.
12:17:10 <xerox> @yow
12:17:13 * xerox prrrrrs.
12:19:50 <Darius> EoPL will keep me awake while I wait for GHC to compile lambdabot with profiling correctly.  Or maybe I should get rid of the dynloading, maybe that's all that's wrong.
12:21:20 <xerox> Darius: do you know how to get rid of dynloading trought some darcs hackery?
12:22:13 <shapr> put everything in StaticModules.hs and rip all the dynload code out of BotConfig.hs
12:22:14 <Heffalump> you could just not compile in the dynamic loader module
12:22:36 <shapr> look at StaticcModules.conf
12:22:47 <shapr> um /cc/c/
12:24:35 <Heffalump> has the repo not had any changes for a while?
12:24:36 <Darius> I probably simply need to not load any dynamic modules.
12:25:00 <Darius> But right now I'm waiting to for this compile to finish.
12:25:13 <shapr> Darius: have you read CTM?
12:25:39 <shapr> I'll mirror the new repo on ScannedInAvian
12:25:48 <Heffalump> what new repo?
12:26:07 <shapr> dons is now the man behind the bot.
12:26:08 * Heffalump appears to have a checkout from http://www.scannedinavian.org/repos/lambdabot/
12:26:17 <xerox> @version
12:26:18 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
12:26:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:26:27 <Heffalump> did he start with your repo?
12:26:33 <shapr> could be
12:27:53 * Lemmih just realized that Hackage is violating HaXml's license.
12:28:11 <shapr> !
12:29:24 <xerox> Hm, I can't compile your repository.
12:29:39 <xerox> Failed to load interface for `IRC':
12:30:27 <Darius> shapr: Of course.
12:31:03 <shapr> Darius: worth reading?
12:31:54 <Lemmih> SyntaxNinja: I'm taking Hackage offline for the time being.
12:32:32 <ibid> Lemmih: how is it violating it?
12:33:06 <Lemmih> ibid: I'm using a non-restrictive BSD-like license.
12:33:08 * boegel is off to read his book
12:33:10 <boegel> bye everyone
12:33:15 <ibid> Lemmih: and?
12:33:21 <shapr> cya boegel
12:33:23 <astrolabe> bye
12:33:35 <Lemmih> But you actually aren't allowed to redistribute Hackage in binary-only form.
12:33:48 <shapr> ?
12:33:53 <ibid> Lemmih: as long as you don't you're not violating the license
12:34:29 <Lemmih> Well the current Hackage license lies. Isn't that a violation?
12:34:34 <ibid> Lemmih: it doesn't matter what license you use for your own code, as long as both can be simultaneously followed, and a bsd-style license usually cooperates with anything
12:34:55 <ibid> Lemmih: no, if you document that your license does not cover haxml
12:35:03 <xerox> byebye boegel
12:35:06 <Heffalump> what licence is haxml?
12:35:08 <ibid> Lemmih: and also list haxml's license
12:36:11 <ibid> Lemmih: actually, you'd have to do that anyway, regardless of how haxml is licensed, since you can't decide the license of code whose copyright you don't own
12:37:00 <ddarius> shapr: CTM or EoPL?
12:37:02 <Lemmih> Hmm.
12:37:36 <shapr> ddarius: both, I guess.
12:37:52 <Lemmih> Heffalump: LGPL.
12:38:22 <ibid> Lemmih: the only way you can infringe a copyright is by copying or redistributing without a license to do so; just publishing your own code that is meant to be ciombined by another work does not infringe the copyright on the other work
12:38:50 <Heffalump> ok, so in practice your work is LGPL too.
12:38:54 <Lemmih> I'm still not happy with the fact that you can't do what my license allows you to.
12:38:58 <Heffalump> cos you can't distribute it under any other licence.
12:39:00 <ibid> Lemmih: you are allowed to distribute lgpl stuff in binary-only form (there are hoops to hop though, but in any case)
12:39:20 <Heffalump> oh, LGPL, /me wakes up.
12:39:41 <Lemmih> ibid: But you must allow the user to link with other versions of the LGPL library, right?
12:39:46 <ibid> Lemmih: yes
12:39:54 <ibid> Lemmih: that's one of the hoops
12:40:48 <Lemmih> So you can only do what my license allows you to in theory...
12:41:01 <ibid> one can do it for *your* code
12:41:33 <Lemmih> But Hackage will be statically linked with HaXml...
12:41:42 <Heffalump> AAARGH HATE DARCS HATE HATE
12:41:51 <norpan> no, don
12:41:54 <norpan> 't hate
12:42:01 <Heffalump> it's making up non-existent conflicts.
12:42:41 <norpan> if they are non-existant, they should be easy enough for you to resolv :)
12:42:49 <Heffalump> true
12:42:50 <Lemmih> My license states that you're allowed to redistribution modifycations in binary form, which you're not.
12:42:53 * Heffalump uses darcs revert
12:43:01 <ibid> Lemmih: one is free to modify your code not to use haxml
12:43:09 <Lemmih> *redistribute
12:43:22 <Lemmih> *modifications
12:43:26 <ibid> Lemmih: and if you do that, one is allowed to redistribute in binary form without hoops
12:43:29 <Heffalump> the only problem is that his code is a derived work of HaXml, I believe.
12:43:42 <ibid> Heffalump: how so?
12:44:00 <ibid> Heffalump: using an interface does not a derived work make
12:44:02 <Heffalump> cos it relies on HaXml to work
12:44:05 <Heffalump> oh, true.
12:44:08 * Heffalump withdraws that
12:44:12 <ibid> Heffalump: the statically linked binary is of course a derived work
12:44:21 <Lemmih> ibid: But that's not what my license states. (:
12:45:27 <ibid> Heffalump: and fsf argues that distributing a dynamically linked binary which can only be combined at runtime with the (l)gpl library makes the dynamically linked binary a derived work of the library, but that's disputed
12:45:33 <shapr> btw, if you guys haven't read http://www.haskell.org/hawiki/ThingsToAvoid_2fDiscussion, it contains worthwhile information.
12:45:36 <ibid> Lemmih: it does not matter
12:45:39 <norpan> what makes a derived work is a bit hard to know
12:45:53 <shapr> metaperl_: you might find some parts of this enlightening - http://www.haskell.org/hawiki/ThingsToAvoid_2fDiscussion
12:46:01 <ibid> Lemmih: of course, it is prudent for you to list haxml's license too
12:46:37 <norpan> if just using an api is not making a derived work, then linking dynamically to a gpl:ed library should be fine without having to abide by the gpl
12:46:43 <norpan> for instance
12:46:49 <norpan> and maybe it is so
12:47:02 <norpan> but that's not what the fsf says (of course)
12:47:16 <shapr> hi metaperl! Have you read http://www.haskell.org/hawiki/ThingsToAvoid_2fDiscussion ?
12:47:44 <metaperl> no I have not...
12:47:48 <Lemmih> I'm still taking it down until I either re-license Hackage or HaXml gets re-licensed.
12:47:52 <Darius> Ack this is like some bad Star Trek episode where someone gets stuck in a time loop
12:48:00 <norpan> hehe
12:48:31 <Heffalump> is there    is there any problem with relicensing it?
12:48:32 * metaperl browses things to avoid
12:48:41 * shapr avoids things to browse
12:48:59 <ibid> Lemmih: i think that's unwarranted caution
12:49:04 <Lemmih> Heffalump: Only moral ones (:
12:49:37 <Lemmih> ibid: The current license is under all conditions mis-leading at best.
12:49:40 <jyasskin> Lemmih: If you want _your_ code to be covered by a BSD-style, so that someone is allowed to port it to not use HaXml, then you can't really re-license it
12:49:56 <ibid> Lemmih: as i said, just list the haxml license along with the license of your code
12:50:05 <Heffalump> it sounds to me like BSD is ok, you just need to make it clear that users must comply with the LGPL too
12:50:09 <ibid> Lemmih: it's not misleading, if one knows how copyright works
12:50:21 <ibid> Lemmih: in a README, i mean
12:54:37 <Lemmih> Guess stating in which cases you aren't allowed to redistribute in binary form would be enough.
12:56:00 <ibid> easier to just refer to the lgpl
12:56:06 <ibid> it's hard enough to summarise it
12:56:15 <ibid> especially without experience
12:56:26 <xerox> Little question, why does (\f x -> x >>= return . f) (+2) [0..5] act as "map" ? I mean, how does the function being applied to the single elements of the list? Is it because of how is (>>=) instantiated for the lists?
12:57:08 <Heffalump> yes
12:57:16 <xerox> I must lookup the actual code.
12:57:19 <TheHunter> @pointless (\f x -> x >>= return . f) (+2) [0..5]
12:57:20 <lambdabot> (2 +) `fmap` [0..5]
12:57:41 <Heffalump> @pointless \x -> f (g x)
12:57:42 <lambdabot> f . g
12:57:48 <Heffalump> @pointless \x y -> f (g x) y
12:57:49 <lambdabot> f . g
12:57:52 <TheHunter> hmm, i thought it could do that :(
12:57:53 <Heffalump> @pointless \x y -> f (g x y)
12:57:54 <lambdabot> (f .) . g
12:57:56 <Heffalump> cool :-)
12:57:59 <JaffaCake> Lemmih: could you use another XML library? Haskell XML toolbox, perhaps?
12:58:09 <Heffalump> @pointless \f g x -> f (g x)
12:58:10 <lambdabot> (.)
12:58:17 <Heffalump> @pointless \f g x y -> f (g x y)
12:58:18 <lambdabot> (.) . (.)
12:58:30 <xerox> Whoa!
12:58:35 <liquidengineer> hi
12:58:47 <xerox> TheHunter: I know your example, you always show it :D I just have to check *why* does it work.
12:59:07 <goron> What does ldd stand for? Linker Dynamic something or so?
12:59:17 <TheHunter> @pointless (\f x -> x >>= return . f) (+2) [0,1,2,3,4,5]
12:59:19 <lambdabot> [2, 3, 4, 5, 6, 7]
12:59:41 <xerox> I cant find the actual code, tought.
13:00:07 <TheHunter> @type liftM
13:00:13 <lambdabot> bzzt
13:00:13 <liquidengineer> question
13:00:22 <TheHunter> @type Control.Monad.liftM
13:00:24 <lambdabot> Control.Monad.liftM :: forall r (m :: * -> *) a1.
13:00:24 <lambdabot>                        (Monad m) =>
13:00:24 <lambdabot>                        (a1 -> r) -> m a1 -> m r
13:00:25 <liquidengineer> how do I access the individual elements of a tuple
13:00:33 <liquidengineer> say a touple with five elements
13:00:45 <xerox> TheHunter: are you saying that (>>=) for [] is liftM ?
13:00:52 <TheHunter> liquidengineer, using pattern matching
13:00:56 <Lemmih> JaffaCake: Yeah. I'll probably do that.
13:00:57 <Heffalump> xerox: xs >>= f = concat (map f xs)
13:01:13 <TheHunter> xerox, no, (>>=) is flip concatMap, liftM is map.
13:01:21 <xerox> Heffalump: HM, you're right.
13:01:32 <xerox> Where is in the GHC code hierarchy, tought?
13:01:41 <Heffalump> apt-get install ghc6-libsrc :-)
13:02:15 <Heffalump> in this case you might find the code in the report, since the monad instance for [] is part of the library definition
13:02:35 <TheHunter> liftM is defined as \f x -> f >>= return . f
13:02:42 <astrolabe> liquidengineer:  I'm a beginner, but what about  \(a,b,c,d,e) -> d    ?
13:02:48 * goron is being ignored :(
13:03:02 <Heffalump> goron: I dunno the answer, though i'd like to.
13:03:12 <JaffaCake> goron: your question wasn't Haskell-related
13:03:25 <goron> JaffaCake: I know, but I "know" you.
13:03:37 <astrolabe> Linux Device Driver?
13:03:40 <Khisanth> goron: man ldd :)
13:03:47 <xerox> Khisanth: it doesn't say why the name.
13:04:08 <JaffaCake> oh, ok then :)
13:04:10 <goron> JaffaCake: And I assumed you are rather capable software developers and thus have any experience with it.
13:04:21 <TheHunter> xerox, http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.html#t%3AMonad
13:04:29 * Heffalump has experience with it, just doesn't know why it's called that
13:04:37 * JaffaCake greps /dev/brain for origins of ldd
13:05:06 <df_> list dynamic dependancies
13:05:10 <goron> Heck, I am even talking to Simon Marlow. Already thought that, though. :)
13:05:17 <xerox> Control.Monad.List !
13:05:37 <JaffaCake> well, ld is the loader, ldd = loader dynamic(?)
13:05:52 <df_> jaffacake, no, that doesn't make any sense
13:05:56 <Heffalump> loader dependenices?
13:06:01 <Heffalump> s/ic/ci/
13:06:02 <df_> list dynamic dependancies
13:06:12 <JaffaCake> Heffalump: sounds plausible
13:06:20 <Heffalump> df_'s sounds more plausible
13:06:23 <poetix> Newbie question - how do I get ghc to output an executable with a name other than a.out?
13:06:28 <Heffalump> ghc -o foo
13:06:32 <df_> poetix :: -o
13:06:34 <astrolabe> df_ is right I think (from typing define: ldd into google)
13:06:35 <Heffalump> (as with any other compiler)
13:06:53 <gzl> in Parsec, how does one have a parser that handles two different options where the difference between the two options occurs in the middle of a string? (for example, something that matches "ab" or "ac".) doing try ( do { char 'a'; char 'b'; return "ab"; } ) <|> do { char 'a'; char 'c'; return "ac"; } doesn't work for some reason.
13:06:53 <Heffalump> s/any other compiler/most other compilers/
13:06:57 <poetix> Thanks
13:07:01 <gzl> though he seems to suggest that 'try' is the right combinator for the task
13:07:11 <Heffalump> does parsec commit after the first character
13:07:12 <xerox> What does "mtl" means in the GHC's sources hierarchy?
13:07:15 <Heffalump> ?
13:07:27 <goron> ldd â list dynamic dependencies of executable files or shared libraries
13:07:37 <goron> From HP-UX man pages :)
13:07:39 <TheHunter> xeqi, monad template library.
13:07:40 <Heffalump> lol
13:07:45 <gzl> Heffalump: he claims that 'try p' behaves like 'p' except that it pretends it hasn't consumed anything if p fails
13:07:51 <TheHunter> sorry, xerox
13:07:58 <gzl> Heffalump: to me, that says that it doesn't commit
13:08:07 <Heffalump> true
13:08:08 <xerox> Control.Monad.List wasn't was I was searching, tought.
13:08:13 <JaffaCake> xerox: monad template library
13:08:45 <gzl> Heffalump: so in that code above, "ab" matches but "ac" does not
13:08:56 <TheHunter> Control.Monad.List contains the ListT "monad transformer"
13:08:59 <gzl> any ideas?
13:09:37 <Heffalump> gzl: if it's just that case, you could left factor the grammar
13:09:42 <gzl> no, it's not that case
13:10:02 <gzl> there's an arbitrary number of characters before one would find out that the first case is not the one to use
13:10:07 <Heffalump> I'm not really sure without playing around with it and checking the spec, then.
13:10:31 <Darius> @type Text.ParserCombinators.Parsec.parse
13:10:33 <lambdabot> Text.ParserCombinators.Parsec.parse :: forall a tok.
13:10:33 <lambdabot>                                        Text.ParserCombinators.Parsec.Prim.
13:10:33 <lambdabot> GenParser tok () a
13:10:33 <lambdabot>                                        -> Text.ParserCombinators.Parsec.
13:10:33 <lambdabot> Pos.SourceName
13:10:33 <lambdabot>                                        -> [tok]
13:10:35 <lambdabot>                                        -> Either Text.ParserCombinators.
13:10:37 <lambdabot> Parsec.Error.ParseError a
13:11:20 <liquidengineer> what's a generator error?
13:11:24 <jyasskin> gzl: your example works for me
13:11:25 <shapr> hiya JaffaCake, how's code?
13:11:33 <JaffaCake> hey shapr
13:11:40 <Darius> @plugs parse (try (do char 'a'; char 'c') <|> (do char 'a';char 'b')) "" "ab"
13:11:41 <JaffaCake> ugly :(
13:11:46 <lambdabot> bzzt
13:11:58 <liquidengineer> hugs is choking on this:
13:11:58 <shapr> JaffaCake: writing C++ to generate C-- or something?
13:12:16 <JaffaCake> fighting with an x86_64 native code gen
13:12:25 <norpan> @pointless let x = 1:x in x
13:12:26 <lambdabot> fix (1 :)
13:12:29 <gzl> jyasskin: huh. if I do (parseTest testing "ac") I get "parse error, unexpected 'c', expecting 'b'"
13:12:36 <norpan> wow
13:12:41 <liquidengineer> >update exScore target number book = [x | x <- target /= Name]
13:12:49 <gzl> son of a!
13:12:51 <liquidengineer> I'm getting an error about the /=
13:12:57 <liquidengineer> target and Name are both strings...
13:13:01 <norpan>  @pointless let x = 1:x in x
13:13:03 <gzl> it does work. sorry
13:13:05 <norpan> oh
13:13:14 <gzl> the parentheses around the try were messing it up
13:13:15 <jyasskin> gzl: '"parse (try ( do { char 'a'; char 'b'; return "ab"; } ) <|> do { char 'a'; char 'c'; return "ac"; }) "" "ac"' in ghci gives me Right "ac"
13:13:33 <gzl> jyasskin: yeah, I had try $ do ...; changing it to try (do ...) fixed it
13:13:35 <shapr> I look forward to C-- being widely available.
13:13:42 <gzl> now I feel like a class A idiot
13:13:45 <SyntaxNinja> Lemmih: I agree, I don't see a need to take down hackage; just point out the license of haxml in the readme.
13:13:56 <jyasskin> ah, yeah. $ is a bit dangerous
13:14:05 <JaffaCake> C-- is coming on in leaps.. it's almost useable now
13:14:05 <shapr> gzl: s'okay, I never learn without being humbled first :-)
13:14:05 <Darius> Name isn't a valid identifier for a (variable containing a) Haskell String and even if it were you'd be trying to extract x's from a Bool.
13:14:09 <liquidengineer> how do you compare strings for equality?
13:14:09 <SyntaxNinja> Lemmih: I'm not sure it's a good idea to put your interpretation in the license itself, but go ahead if you're pretty sure about it.
13:14:15 <gzl> jyasskin: yeah, I haven't run into this before
13:14:18 <SyntaxNinja> JaffaCake: !
13:14:36 <JaffaCake> SyntaxNinja:  ;)
13:14:41 <gzl> shapr: yeah, true
13:14:55 <xerox> Is there a specific reason because I can't find xs >>= f = concat (map f xs) in the GHC sources ?
13:15:00 <liquidengineer> I tried to use the /= function, but it's not working...
13:15:01 <shapr> I was just wondering whether/how a penrose tile data type would work.
13:15:04 <SyntaxNinja> JaffaCake: I was just thinking today about how I need to harass you to get back on IRC.
13:15:14 <Lemmih> SyntaxNinja: I would just notice that my license would becore more or less invalid if the user linked to HaXml.
13:15:19 <Heffalump> xerox: look for instance Monad [] where
13:15:25 <Heffalump> the precise definition might be different
13:15:28 <JaffaCake> hehe, I have intermittent trouble getting through the firewall with my IRC client
13:15:31 <Darius> gzl: Assuming you wrote essentially, try $ do ... <|> do ... then it's simply a precedence error.
13:15:37 * shapr hugs wikipedia
13:15:39 <SyntaxNinja> Lemmih: but your code itself can still be modified freely.
13:15:53 <xerox> $ grep -rn 'instance Monad \[\] where' .
13:15:54 <xerox> $
13:16:04 <gzl> Darius: yeah, I see that now. I assumed that the indentation would have taken care of it, but that was clearly wrong
13:16:04 <SyntaxNinja> JaffaCake: btw, It looks like cabal got released in ghc as 1.0? at least that's what ghc-pkg reports.
13:16:04 <liquidengineer> shapr: pardon?
13:16:14 <Lemmih> SyntaxNinja: Yes but some parts of the license would become invalid.
13:16:32 <JaffaCake> SyntaxNinja: hmm, that's probably more accidental than anything else
13:16:35 <SyntaxNinja> JaffaCake: I had meant for it to be 0.6, but we'll go w/ 1.0 if that's what happened.
13:17:00 <Darius> liquidengineer: See my first response to you.  /= is the operator to compare Strings (or any thing else in Eq) for inequality.
13:17:09 <shapr> liquidengineer: I'm happy that lots of knowledge that is 'difficult for outsiders to find' is available on wikipedia. I read everything from Penrose tiles, to photoelectric effect, to aerdynamics, to computational theory to...
13:17:14 <SyntaxNinja> Lemmih: yeah.
13:17:39 <JaffaCake> hope that's ok - I just set the default versions on all the packages to 1.0, and expected relevant owners to reset the versions appropriately, but I probably didn't shout loud enough
13:17:41 <nbb> xerox: ghc-6.4/libraries/base/GHC/Base.lhs
13:17:58 <SyntaxNinja> Lemmih: what are you using haxml for anyway?
13:18:12 <liquidengineer> what's a generator error?
13:18:18 <Lemmih> SyntaxNinja: Parsing and generating xhtml.
13:18:40 <shapr> liquidengineer: how did /= fail for you?
13:18:56 <SyntaxNinja> JaffaCake: no big deal.
13:19:09 <JaffaCake> cool
13:19:15 <SyntaxNinja> JaffaCake: and also, we totally need to play Go :) we got a go board here at work now.
13:19:22 <jyasskin> xerox: heh, grep 'instance Monad' didn't work because there are two spaces there.
13:19:25 <liquidengineer> shapr: you mean, the error trace?
13:19:40 * JaffaCake is already seeing black and white dots
13:19:46 <shapr> liquidengineer: if it's less than 3 lines, yes.
13:20:01 <JaffaCake> SyntaxNinja: you played with John yet?
13:20:15 <liquidengineer> *** Type           : Bool
13:20:15 <liquidengineer> *** Does not match : [a]
13:20:16 <liquidengineer> *** Term           : target /= Name
13:20:23 <liquidengineer> "Type error in generator"
13:20:36 <SyntaxNinja> JaffaCake: not much; we have a group game going. I think he's scared to play against me ;)
13:20:46 <JaffaCake> ah yes, probably
13:20:52 <xerox> m >>= k = foldr ((++) . k) [] m  -- ooohh !
13:20:54 <SyntaxNinja> JaffaCake: but I hear he's at approximately the same level as you, so I know what kind of treatment to expect.
13:20:55 <liquidengineer> target is a string, and Name is a type that's a string
13:21:02 <JaffaCake> hehe :)
13:21:09 <xerox> SyntaxNinja: Do you play Go?
13:21:21 <shapr> liquidengineer: that means that you're trying to use the code "x /= y" as a list. But it's just a single item. you can probably put square brackets on either side to make it a list.
13:21:33 <shapr> liquidengineer: specifically, [target /= Name]
13:21:50 <liquidengineer> shapr: pardon?
13:22:00 <liquidengineer> yes
13:22:02 <JaffaCake> John taught me how to play, probably more than anyone else
13:22:06 <liquidengineer> It's part of a list comprehension
13:22:14 <xerox> Hey you Go players! Do you play on KGS too?
13:22:19 <SyntaxNinja> xerox: a little
13:22:29 <JaffaCake> xerox: used to, haven't for a while
13:22:35 <Heffalump> xerox: I guess that works with foldr-build fusion better or something
13:22:42 <xerox> Great!
13:22:44 <Heffalump> it's a rather obfuscated definition if it's not for optimisation purposes
13:22:49 <SyntaxNinja> JaffaCake: it'll be easier to organize a game now that you're on here
13:22:55 <SyntaxNinja> but I'm at work now
13:22:56 <SyntaxNinja> stupid work
13:23:08 <SyntaxNinja> JaffaCake: I sent you private messages
13:23:10 <Heffalump> I thought you worked somewhere cool.
13:23:12 <JaffaCake> SyntaxNinja: sure thing
13:23:19 <SyntaxNinja> Heffalump: yeah, I do actually.
13:23:23 <shapr> Does anyone have Haskell code that already deals with Wang tiles aka Wang dominoes?
13:23:24 <xerox> I'd really love to open an Haskell/Haskellers/<however you want to call it> room on KGS.
13:23:34 <liquidengineer> shapr: I'm trying to do a list comprehension on a list of tuples so it returns all the elements where Name /= target
13:23:36 <liquidengineer> so I did this
13:23:37 <liquidengineer> [x | x <- Name /= target]
13:23:45 <SyntaxNinja> xerox: there are a number of them
13:23:54 <Heffalump> KGS?
13:24:05 <xerox> Heffalump: Kiseido Go Server, http://kgs.kiseido.com/
13:24:10 <Heffalump> ah
13:24:19 * Heffalump has taken to playing bridge lately.
13:24:22 <liquidengineer> wait a minute
13:24:24 <liquidengineer> oh my god
13:24:25 <shapr> liquidengineer: your syntax for list comps is wrong, [x | x <- [1..99], x < 10]
13:24:25 <liquidengineer> I'm a moron
13:24:34 <xerox> SyntaxNinja: Hm, it would be nice to have Go-related conversation && obviously games, with you Haskell people :)
13:24:41 <liquidengineer> shapr: just realized that
13:24:42 <liquidengineer> d'oh
13:24:45 <liquidengineer> thanks
13:24:47 <SyntaxNinja> JaffaCake: so still interested in playing sometime?
13:24:55 <_JusSx_> so where Lambdabot repos?
13:25:00 <JaffaCake> SyntaxNinja: yup, definitely
13:25:01 <shapr> @version
13:25:02 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
13:25:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:25:04 <xerox> If you're interested in playing and or discussing, obviously.
13:25:06 <shapr> _JusSx_: tadah!
13:25:12 <_JusSx_> shapr: thanx
13:25:20 <SyntaxNinja> xerox: that used to happen more often; at this point, I can't remember who else plays, but we've had some games / discussions here before
13:25:58 <xerox> So, how many Go players are there?
13:26:07 * JaffaCake raises a hand
13:26:14 <shapr> I'd like to learn!
13:26:22 <SyntaxNinja> I think maybe musasabi plays?
13:26:29 * jyasskin has lost a couple times
13:26:35 * psi plays, occasionally :) haven't played in a few months, now
13:26:47 <xerox> Seven..
13:27:06 <SyntaxNinja> next ICFP we should have a Go tournament
13:27:07 <xerox> It's a nice group :)
13:27:29 <JaffaCake> if you want to arrange a time to meet up on KGS, I'm up for that
13:27:45 <JaffaCake> evening GMT is best for me
13:27:46 <xerox> JaffaCake: it would be very nice, do you have any preference about the time?
13:27:47 * SyntaxNinja too
13:28:00 * xerox agrees.
13:28:20 <shapr> Evening GMT is when I'm awake.
13:28:37 <psi> do you guys have a ranking?
13:28:49 <shapr> My ranking is right at the _|_
13:28:50 <SyntaxNinja> no
13:28:55 * SyntaxNinja meeting &
13:28:56 <SyntaxNinja> bbiab
13:29:04 * JaffaCake used to be about 1k, but has probably slipped a bit
13:29:20 <ibid> SyntaxNinja stopped due to attempted terminal output
13:29:26 * xerox was 8k while ago
13:29:33 <psi> 1k, cool
13:29:56 <JaffaCake> I think my KGS account is 3k or 4k
13:30:06 * ibid knows a few go players but never played himself
13:30:15 <psi> i don't know what my internet ranking is, but i've played in a swedish tournament at about 13k :)
13:30:17 <ibid> i *think* the highest i know is 1k or 1d
13:30:20 <xerox> Any suggestion for the name of the Evening GMT meetings?
13:30:40 <xerox> Err, the Evening GMT meetings room, that is.
13:31:20 <liquidengineer> hi
13:31:25 <lightstep> what's gmt?
13:31:28 <liquidengineer> what's this mean:Undefined constructor function "Gbk"?
13:31:39 <xerox> lightstep: GMT as the time zone
13:31:49 <liquidengineer> lightstep: Grenwhich Mean Time
13:32:14 <Darius> liquidengineer: All variables in Haskell must start with a lowercase letter, all data and type constructors must start with an uppercase letter.
13:32:27 <liquidengineer> Darius: right
13:32:29 <lightstep> there's something i seem to not get here (and it's not the timezone being UTC)
13:32:40 <liquidengineer> Darius: I have a type called Gbk defined as a list of tuple
13:32:42 <Darius> Undefined constructor Gbk, means you don't have anything like data Something = Gbk Foo Bar | Baz somewhere.
13:32:44 <liquidengineer> I even have one defiend
13:32:54 <Darius> A type is not a value.
13:33:10 <shapr> what about epigram? =)
13:33:13 * liquidengineer blinks
13:33:22 <liquidengineer> indeed it's not
13:33:24 <liquidengineer> I am a moron
13:33:25 <liquidengineer> again
13:33:28 <liquidengineer> thanks
13:33:42 <liquidengineer> I put in the type name instead of the variable name I wanted to use in the pattern matching
13:33:53 <Oeje1> gzl: How about just 'try (string "ab") <|> string "ac"'?
13:35:16 <gzl> Oeje1: thanks, but i actually fixed it. the thing i showed above was a simplified case of something else i was trying to do, and your code is a little different (because the failure comes at the beginning instead of the middle of the parsing). but regardless, the problem was $ instead of ( )
13:35:42 <Oeje1> gzl: Sure thing.
13:36:00 <Oeje1> gzl: Parsing expressions?
13:36:06 <gzl> parsing wikitext
13:36:40 <shapr> hiya djw
13:36:50 <liquidengineer> could I annoy ya'll with two more lines of code?
13:36:53 <shapr> wow, this is nifty - https://www.cs.tau.ac.il/%7Esorkine/courses/sadna04/wang_tiles.html
13:36:57 <liquidengineer> I'm getting an undefined variable error that's weird to me
13:36:58 <gzl> now my stuff works, but it doesn't do nested expressions. i.e. "#bold#" works and "_underline_" works, but "#_bold underline_#" does not. so trying to figure out how to nest parsers now
13:37:04 <shapr> liquidengineer: what's the error?
13:37:28 <liquidengineer> undefined variable "grades"
13:37:31 <liquidengineer> here's the code
13:37:32 <liquidengineer> >update :: Score --> Name --> ExamNbr --> Gbk --> Gbk
13:37:47 <shapr> where does grades come from?
13:37:55 <liquidengineer> um....there's a return before that second carret
13:38:00 <gzl> and am not having much luck so far. :)
13:38:11 <jyasskin> gzl:have you read throught the parsec manual?
13:38:11 <liquidengineer> shapr: grades is of type Gbk
13:38:16 <liquidengineer> I'm supplying it in the pattern matching
13:38:36 <gzl> jyasskin: most of it
13:39:18 <shapr> liquidengineer: why do your types have --> instead of -> ?
13:39:31 <shapr> liquidengineer: I didn't see the code for that type sig.
13:40:00 <jyasskin> gzl: recursive parsers should just work
13:40:07 <liquidengineer> shapr: it has -->, apparently, because I've lost my mind
13:40:19 <Oeje1> gzl: Are '#' and '_' like parenthesis?
13:40:25 * liquidengineer curses
13:40:26 <liquidengineer> a lot
13:40:30 <liquidengineer> this just isn't my day
13:40:45 <liquidengineer> shapr: thanks.
13:40:52 <gzl> Oeje1: #text# parses to <B>text</B> and _text_ parses to <U>text</U>, if that's what you mean
13:41:16 <gzl> jyasskin: yeah, but there can be arbitrary nesting of many different kinds of tags, so I'm trying to figure out a nice way of doing that without making it messy
13:41:38 <Darius> gzl: Try wrapped wrapper body = do wrapper; x <- body; wrapper; return x
13:41:45 <shapr> Why not do it just as Oeje1 suggested? make the wiki tags 'special' parens?
13:42:13 <Oeje1> Look for "between".
13:42:39 <Darius> Good point Oeje1
13:43:30 <gzl> hmm
13:43:43 <Darius> gzl: So anyways, we're all saying the same thing.  Make a parser that takes a parser to parse the insides of something wrapped by bold/italics/etc. markers.
13:43:55 <gzl> ah, I see what you mean.
13:43:57 <Darius> Then bold (italics foobar) will work.
13:44:19 <jyasskin> so, markup = bold markup <|> underline markup where bold = liftM Bold; underline=...
13:44:24 <xerox> @wiki HaskellGoPeople
13:44:26 <lambdabot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
13:44:29 <xerox> I made up that page.
13:44:44 <Darius> @wiki is gone too?
13:44:45 <lambdabot> Sorry, I don't know the command "wiki", try "lambdabot: @listcommands"
13:44:48 * shapr cries
13:44:56 <xerox> http://haskell.org/hawiki/HaskellGoPeople
13:45:12 <shapr> Not that @wiki was a complicated bit of code or anything.
13:45:30 <Darius> jyasskin: The problem with that is that liftM Bold doesn't parse the markers.
13:45:52 <shapr> Darius: That idiomatic C++ thread on LtU is especially fun.
13:45:54 <jyasskin> *liftM Bold . between (char '#') (char '#')
13:46:05 <jyasskin> Darius: yeah, missed that part
13:47:01 <Darius> shapr: I posted a forum topic about the Hawiki Quotes Page.
13:47:06 <shapr> oh neat
13:47:24 <Darius> The turn out of that will either be little or interesting.
13:47:48 <shapr> Experience implies those are the only two options on LtU.
13:47:57 <Darius> And it's a nice change from some of the longer "heavier" threads.
13:48:31 <shapr> I suspect marcin hasn't used Haskell much.
13:50:57 <shapr> I wonder if I qualify as has used Haskell much.
13:51:08 <shapr> Probably.
13:51:31 <shapr> hiya stepcut!
13:52:09 <xerox> Gotta go, it would be nice if you add yourself to the HaskellGoPeople wikipage, and if someone is wanting to write some details about the aimed meetings.
13:53:00 <shapr> Darius: Truly, "don't want functional programming" is a prize quote.
13:53:04 <liquidengineer> I feel there must be some fundamental part of types/list comprehensions I do not understand
13:53:25 <liquidengineer> I mean, I have type Name = String
13:53:27 <liquidengineer> then this
13:53:28 <liquidengineer> >update :: Score -> Name -> ExamNbr -> Gbk -> Gbk
13:53:42 <liquidengineer> and it tells me Name is an undefined constructor
13:54:14 <shapr> It's a type name in that sig.
13:55:14 <liquidengineer> and that was profoundly dumb.
13:55:33 <liquidengineer> I apologize for skipping out
13:55:40 <shapr> Running away to vent your frustration away from the people helping you?  Heck I do that all the time.
13:55:48 <stepcut> hi shapr!
13:55:59 <shapr> My unicycle takes a serious beating, but at least I don't say thing I might regret later.
13:56:06 <xerox> I got headache.  Goodnight folks, sorry for the Go-spam.
13:56:10 <stepcut> shapr: haha
13:56:15 <shapr> xerox: I want to play Go!
13:56:19 <liquidengineer> shapr: I'm just really confused
13:56:34 <shapr> xerox: I'll bug you when you don't have a headache :-)
13:56:37 <liquidengineer> update :: Score -> Name -> ExamNbr -> Gbk -> Gbk
13:56:40 <Darius> liquidengineer: What Haskell tutorials/books have you read?
13:56:43 <xerox> shapr: sorry, can you wait tomorrow?
13:56:47 <xerox> shapr: pheeew :)
13:56:47 <liquidengineer> update exScore target number grades = [x | x <- grades, target /= Name]
13:57:06 <JaffaCake> xerox: bye ;)
13:57:09 <lightstep> what do you mean by `target /= Name' ?
13:57:11 <xerox> Bye bye
13:57:17 <liquidengineer> Darius: I'm in Functional Programming class in college, and we're using Craft of functional programming 2/e
13:57:30 <Darius> liquidengineer: Name is a type not a value.  A type can't equal a value.
13:57:30 <Darius> They are not even on the same level.
13:57:51 * Darius gives up on trying to get lambdabot compiled with profiling.
13:57:56 <Oeje1> gzl: http://www.haskell.org/hawiki/HaskellIrcPastePage
13:58:07 <liquidengineer> lightstep: I want to compare the string target with the Name components of the tuples in my list and disregard any that match
13:58:09 <shapr> Is Dominic Fox here?
13:58:28 <gzl> Oeje1: oh, thanks a lot
13:58:41 <lightstep> liquidengineer, so you need to compare it to the specific second list
13:58:45 <liquidengineer> Darius: I realize that.  I guess I'm just not sure how to get at what I want
13:58:54 <lightstep> comparing to Name makes no sense to the compiler
13:59:17 <liquidengineer> so how do I tell it to look at the second element of every tuple in the list?
13:59:18 <lightstep> if you have a name field in Score, for example, you can check `target /= scoreName score'
13:59:24 <Darius> shapr: I don't think so.
13:59:26 <liquidengineer> ....
13:59:30 <liquidengineer> score is an integer
14:00:00 <shapr> He says he'll show up. Just wondered if he was here yet.
14:00:03 <lightstep> liquidengineer, it depends which list
14:00:03 <shapr> Darius: have you seen his blog?
14:00:17 <liquidengineer> there's only one list
14:00:18 <Darius> I think a few times, but I don't remember the link.
14:00:23 <liquidengineer> Gbk is a list of tuples
14:00:24 <Oeje1> gzl: A little better now.
14:00:54 <liquidengineer> I want to go over that list, and throw out the tuple whose element with type Name == target
14:00:59 <liquidengineer> Name being a string
14:01:05 <lightstep> liquidengineer, `any' and `all' from the prelude are your friends
14:01:25 <shapr> He has some QuotesPage worthy posts, like - http://codepoetics.com/poetix/index.php?p=41
14:01:29 <lightstep> they check if a predicate is satisfied by, well, any or all the elements from a list
14:02:26 <shapr> The comment on that post is particularly funny.
14:02:43 <liquidengineer> so, if I want the elements where the Name type value is NOT target
14:03:36 <liquidengineer> all (/=target) mylist
14:03:57 <lightstep> i don't understand
14:04:27 <liquidengineer> myList contains tuples
14:04:38 <liquidengineer> I want all the tuples that do not have the target string in them
14:04:43 <liquidengineer> in a new list
14:04:56 <shapr> It's strange, me saying 'particularly funny' means I was cackling with glee when I read it (even though it's midnight). I wonder if everyone has such strong experiences, and they're just being tactful about it.
14:05:19 <lightstep> liquidengineer, perhaps filter?
14:05:25 <Darius> shapr: The watermark is really annoying.
14:05:36 <shapr> And slows down my browser painfully.
14:05:37 <liquidengineer> lightstep: ah.
14:06:09 <Darius> shapr: Yes is the answer to your implied question.
14:06:14 <gzl> Oeje1: yeah, this is nice. why doesn't it allow stuff like "#foo _bar_ bat#" though? the code seems like it would support it
14:06:39 <shapr> Darius: ok =)
14:08:27 <liquidengineer> perhaps if I showed you all my list of tuple so ya'll could see what it looks like
14:08:29 <Darius> It needs to check for more text after parsing the latter '#' etc.
14:08:37 <liquidengineer> it might make what I'm trying to do easier to understand
14:08:41 <liquidengineer> where is that wiki thing?
14:09:04 <shapr> What wiki thing?
14:09:12 <liquidengineer> the pastebin
14:09:17 <shapr> oh that one.
14:09:29 <shapr> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:09:48 <Darius> But that would require the data type to have a case with multiple children (or a list of children).
14:10:17 <gzl> hmm, yeah. that sounds more complicated.
14:10:43 <gzl> maybe I just shouldn't allow people to go nuts with the formatting in the first place. :)
14:10:45 <Darius> gzl: It's pretty much what you'll need to do for real, but I think Oeje1's example was just meant to demonstrate the nesting.
14:10:51 <gzl> yeah, I see.
14:11:27 <Darius> gzl: People will want '''I ''really'' hate that!''' Or #I _really_ hate that!# to use more like your syntax.
14:12:11 <gzl> yeah, i know
14:12:13 <liquidengineer> I stuck it at the top
14:12:19 <liquidengineer> it shows what my tuple is
14:12:26 <liquidengineer> and what the comprehension is I'm trying to do
14:13:05 <liquidengineer> well...most of the comprehensoqin
14:13:25 <Darius> But all you really need is to add a Sequence [Wiki] branch and change it to wiki = liftM Sequence $ many1 (bold <|> underline <|> text) as a first obviously untested cut.
14:13:54 <shapr> liquidengineer: first of all, I'd suggest you change your Gbk type
14:14:32 <shapr> liquidengineer: you won't be able to add more grades to a tuple and keep the type signature.
14:14:48 <shapr> I'd suggest you keep the grades in a list, and don't save the average at all.
14:14:53 <liquidengineer> It only needs to store three grades
14:15:02 <liquidengineer> I have to save the average
14:15:15 <liquidengineer> all the types are provided for me, and I have to use them
14:15:19 <liquidengineer> this is an assignment for FP
14:15:33 <shapr> This was furnished to you? "type Gbk = [(Name, Score, Score, Score, Total, Grade)]" ?
14:15:33 <liquidengineer> I know how I want to solve it...I'm just having syntax problem.s
14:15:42 <liquidengineer> yes
14:15:52 <liquidengineer> more or less
14:16:06 <shapr> How so?
14:16:52 <liquidengineer> I take that back
14:16:55 <liquidengineer> that's exactly how we got it
14:17:02 <liquidengineer> there were some other typos on the page, though
14:17:04 <liquidengineer> I was thinking of those
14:17:08 <shapr> I'd still fix the type if I were you, it's not flexible.
14:17:10 <liquidengineer> Gbk :: [( Name, Score, Score, Score, Total, Grade)]
14:17:17 * shapr shrugs
14:17:26 <liquidengineer> it's a really simple simulation
14:17:34 <shapr> ok, if you gotta stick with it, you can at least get it done right the first time.
14:17:38 <liquidengineer> three scores, an averaged total, and a letter grade
14:17:47 <liquidengineer> shapr: that's my intention
14:18:28 <shapr> If I were you, I'd do something like type Student = (Name, [Score])
14:18:57 <gzl> Darius: yeah, I see what you're doing. probably going to end up running into that empty string problem with many and text, but that should probably do it
14:19:12 <shapr> and forget about Gbk until you understand how to do it right with Student and something close to your given update function.
14:20:11 <shapr> liquidengineer: if you use the given update function with the given Gbk type, you will be forced to drop or replace one of the grades.
14:20:27 * lightstep really likes the way ml does typeclasses
14:20:39 <liquidengineer> shapr: that's exactly what update's supposed to do
14:20:48 <liquidengineer> replace and recalculate
14:20:50 <Darius> lightstep: Not at all?
14:21:10 <lightstep> yes
14:21:10 <liquidengineer> these are exam grades, and the assignment indicates there are only three exams in the class
14:21:18 <lightstep> .(1) just works
14:21:31 <shapr> Huh? what's .(1) mean?
14:21:38 <shapr> oh whoops
14:21:47 <lightstep> first element of tuple or array
14:21:51 * shapr dispatched on the <li part of the nice
14:21:52 <shapr> nick
14:22:08 <Oeje1> gzl: Do you have a BNF grammar for the Wiki markup?
14:22:16 <shapr> liquidengineer: how does a Gbk look when you have no grades in?
14:22:38 <Darius> lightstep: I'm not seeing the relationship between that and type classes.
14:22:42 <gzl> Oeje1: no
14:22:58 <liquidengineer> shapr: that...can never happen
14:23:03 <liquidengineer> at least in terms of use
14:23:09 <shapr> liquidengineer: stupid exercise.
14:23:12 <gzl> Oeje1: just a bunch of patterns and functions using those patterns to generate html
14:23:14 <liquidengineer> the example gradebook object is hardcoded
14:23:19 <gzl> (directly)
14:23:25 <gzl> without any datatype of the kind you had
14:23:41 <liquidengineer> we haven't gone over I/O yet, so we can't do empty gradebooks, as we have no way to fill them
14:23:46 <shapr> liquidengineer: I can think of a lot of exercises that would make more sense and be very close to the same thing.
14:23:52 <gzl> Oeje1: why, would it help?
14:24:01 <shapr> Yes, you can do empty gradebooks, and you can fill them without I/O.
14:24:56 <shapr> liquidengineer: You have a choice, I can show you the (what I consider more sensible) Student way first, or I can just directly help you with the Gbk problem, what would you prefer?
14:27:33 <lightstep> Darius: the type of .(1) is forall a b. (a is a tuple or an array with first element of type b) => a -> b
14:28:13 <shapr> lightstep: can you use the same math operators to add all numbers in ML?
14:28:33 <lightstep> no
14:28:51 <lightstep> im sml you do, in ocaml you don't
14:28:55 <liquidengineer>  shapr: since I have to turn in the Gbk version, that'd probably be more expedient at the moment
14:28:56 <gzl> you have to use +. and *. for floats and stuff, iirc
14:29:17 <shapr> That sounds like ocaml doesn't have typeclasses then.
14:29:24 <liquidengineer> just tried this and hand it fail miserably:
14:29:26 <liquidengineer> >update exScore target number gradebook = [record | record <- gradebook, record /= (target,_,_,_,_,_)]
14:29:32 <lightstep> but comparison operators are the same. and you have `=' for deep equality, `==' for pointer equality
14:29:50 <liquidengineer> I was trying to tell it I didn't care what the other fields were, so long as we found one that matched target
14:29:58 <lightstep> operator <= : a -> a -> a
14:32:46 <shapr> liquidengineer: Total is float and Score is Int?
14:33:06 <kosmikus> lightstep: so what if I compare two functions?
14:33:25 <lightstep> kosmikus, what is head [] ?
14:33:54 <liquidengineer> shapr: yeah
14:33:55 <Oeje1> gzl: Well, I think it will be easier to implement given a BNF grammar, since Parsec constructs maps well to BNF constructs.
14:34:05 <kosmikus> lightstep: ah, so you're saying only because Haskell's type system isn't as strong as it should be, this is an excuse to make it even weaker?
14:34:54 <shapr> lightstep: I don't see how you can do this with a list comprehension.
14:34:55 <kosmikus> lightstep: furthermore, I guess all these operators are just built-in hacks in ML
14:35:03 <lightstep> kosmikus, no, i'm saying that the result isn't specified
14:35:26 <kosmikus> lightstep: I can't see any advantage in that
14:35:39 <gzl> Oeje1: ok. it's all working except the nested tag thing, but maybe i should rewrite some of this from a BNF grammar to do that properly
14:35:40 <shapr> lightstep: I think your only option is to use either case or the sugared form of case that looks like multiple definitions of the same function
14:35:46 <shapr> er liquidengineer
14:35:47 <shapr> doh
14:35:53 <lightstep> the system is arguably simpler
14:36:23 <kosmikus> lightstep: why? all these things are special, so I have to learn them as exceptions
14:36:42 <TheHunter> lightstep, i don't know if that's what you're saying, but if you use the same name for equality and assignment, stuff like foo x | a = b = c is ambigous.
14:37:16 <liquidengineer>  shapr: alright
14:37:17 <liquidengineer> thanks
14:37:22 <liquidengineer> I'll do that, then.
14:37:22 <shapr> lightstep: the problem with tuples is that you can't loop over the pieces, it's not a sequence.
14:37:32 <liquidengineer> shapr: ah
14:37:37 <liquidengineer> that makes since, I guess
14:37:38 <shapr> liquidengineer: I can show you one part of how I would do it, if you like.
14:37:44 <liquidengineer> I guess I've gotten used to lists
14:37:53 <lightstep> tuples are a sequence, imo
14:37:55 <liquidengineer> and my brain is still a Java infested place.
14:37:59 <Darius> lightstep: You can easily implement something that projects the first element of something with a type class.  Making it so that you can index arbitrarily simply requires type level numbers which are easy to.
14:38:16 <shapr> liquidengineer: that's why I suggested you change the datatype to use lists, it's easier for me to deal with at least.
14:38:18 <lightstep> TheHunter, the syntax thing is complicated, but as in haskell, if you indent correctly, the correct result comes
14:38:28 <shapr> lightstep: you might like Generic Haskell then.
14:38:46 <lightstep> Darius, yes, but the builtin way is a lot simpler
14:38:58 <shapr> lightstep: I disagree, the fewer special cases in a language, the easier it is to use/learn/teach.
14:39:13 <kosmikus> lightstep: I don't understand this; why should built-in ever be simpler?
14:40:03 <lightstep> kosmikus, not generally, but in this case it is, since it allows you to drop the cognitive load of typeclasses and all that follows
14:40:05 <shapr> I can add any instance of the Num class to any other instance. I don't have to teach newbies about different addition operators, and how to cast among those types.
14:40:34 <kosmikus> lightstep: at the price of having a significant number of hacks in your language
14:40:44 <TheHunter> lightstep, once again, how do you wanna define equality for function types?
14:40:47 <Darius> and losing a general-purpose mechanism.
14:41:04 <lightstep> shapr, yes, but the special instances Ix, Show, Read, Ord, Enum, Eq, Monad, (, sometimes Binary, Typeable, MonadFix) are still special
14:41:06 <shapr> And in fact, you can drop the cognitive load of typeclasses is Haskell as well. I think it only requires -fno-implicit-prelude
14:41:17 <shapr> lightstep: No they're not.
14:41:23 <kosmikus> lightstep: no
14:41:27 <stepcut> hrm, I think I might have found a bug in peti's rfc2822 parser :-/
14:41:44 <shapr> Ashley Yakely has totally redefined the typeclass, he has his own that he likes much better.
14:41:49 <shapr> It's available on sourceforge if you want the url.
14:42:01 <Darius> stepcut: Add it to the testsuite and see if you can find out why.
14:42:05 <kosmikus> lightstep: deriving is special, and I'm not really going to defend that; but the classes itself are not special
14:42:08 <shapr> s/typeclass/typeclass hierarchy/
14:42:10 <lightstep> TheHunter, obviously a weaker type system works less well for compile-time verification
14:42:32 <stepcut> Darius: first I have to consult the spec and see if my input is valid ;)
14:42:59 <lightstep> i heard that Num and Monad have a special place in the syntaxc
14:43:04 <Darius> stepcut: Technically, it doesn't really matter for the former, it would just be a test case that should fail.
14:43:05 <shapr> Aren't typeclasses HM equivalent?
14:43:26 <kosmikus> shapr: what does that mean?
14:43:32 <Darius> lightstep: Not really and at best extremely superficially.
14:43:48 <shapr> I mean that I don't think having typeclasses affects the strength or weakness of a type system.
14:43:52 <TheHunter> lightstep, so you want to sacrifice run-time guarantees for what? to make the language easier for newbies?
14:44:15 <Darius> lightstep: Numeric literals are read as fromInteger 1 or fromRational 3.4 and do notation expands to (>>=) and (>>)
14:44:32 <shapr> Though I could be wrong, lemme find the typeclasses paper.
14:44:52 <lightstep> and you have things in the IO monad that are only doable in the implementation level, like catch&throw and randomIO -- to create such things by yourself, you'd have to convert your program to another monad (perhaps ErrorT IOError StateT Generator IO a)
14:45:00 <Darius> shapr: Typeclasses are not macro expressible in Haskell.
14:45:07 <Darius> (minus type classes obviously)
14:45:16 <kosmikus> shapr: I'm still not sure what exactly you mean
14:45:30 <wagle> what is "macro expressible"?
14:45:37 <shapr> kosmikus: Possibly it's just my lack of sleep talking. I'm not sure exactly what I mean either.
14:45:59 <Darius> lightstep: So the language provides primitives... just like every other language.  You can't implement print in ML without using some other thing eventually something you can't implement.
14:46:14 <lightstep> TheHunter, i wish to point out that i prefer haskell over ml
14:46:15 <Darius> Though technically you can implement print in Haskell via the FFI, but you might consider that a copout.
14:46:46 <Darius> wagle: Expressible by only local context-insensitive transformations.
14:46:50 <kosmikus> shapr: if you have polymorphic fields in data types, you can represent classes as datatypes, instances as values of datatypes, and have a direct "encoding" of typeclasses within Haskell
14:46:56 <lightstep> Darius, i believe that it were cleaner if IO did IO and ErrorT did errors
14:47:08 <shapr> kosmikus: neato
14:47:36 <Darius> lightstep: Perhaps, but most IO operations can raise exceptions so having IO support them is not unreasonable.
14:47:55 <Darius> If you really wanted to, you could make MyIO that only had "IO" operations in it.
14:48:00 <shapr> Also, there are two flavors of errors in Haskell, I don't think you can do the arbitrary errors part outside of IO.
14:48:12 <wagle> Darius: markov production systems are turing complete
14:49:06 <wagle> (i might be confusing things)
14:49:35 <lightstep> the current system encourages typeless programming in the IO monad unnecessarily. escaping it is tiresome, since the primitives require IO and not MonadIO
14:49:38 <shapr> er, I may be conflating errors and exceptions.
14:50:00 <Darius> wagle: It can do as much transformation as it wants, it just can't reach outside of where it is used nor require putting the whole program in the macro to have it interoperate.
14:50:03 <wagle> i'm imagining that you rewrite the root with tokens that carry context info inwards (and possibly outwords (upwards?))
14:50:10 <kosmikus> context-insensitive translation of type classes fails because the compiler fills in "dictionary arguments" automatically whenever an overloaded method is invoked; these must be given explicitly in the translation, and determining them requires knowledge of all the instances
14:51:22 <Darius> wagle: See Felleisen's 'On The Expressive Power of Programming Languages'
14:51:31 <wagle> my (scheme) macro system had the whole thing inside a big macro with a couple tiers of additional helper macros
14:52:17 <wagle> hmm..  Matthias was the only one who seemed to understand wtf i was talking about
14:52:58 <shapr> I'd love to hang out and chat with the folks at cse.ogi.edu.
14:53:12 <lightstep> f
14:53:16 <lightstep> oops
14:53:16 <shapr> g
14:53:38 <wagle> who's still left at ogi?  8)
14:53:49 <shapr> you've an ogi address.
14:54:23 <wagle> Darius: thats 45 pages..  which part asre you talking about?
14:54:33 <wagle> s/asre/are/
14:54:55 <shapr> I wish I could make a mailing list of people who read research papers that relate to stuff that interests them.
14:55:04 <kosmikus> wagle: I guess you can do much more with macros when giving up static typing [or at least switch to a stronger type system than Haskell has]
14:55:31 <shapr> I've realized that no one that I know face to face (except me) looks up research papers on X when X catches their interest.
14:55:37 <Darius> wagle: The part that defines "macro-expressive/definable"
14:55:50 <SyntaxNinja> wagle: thomas h and mark j are still at ogi
14:55:59 <Darius> shapr: You "LtU: The mailinglist"?
14:56:01 <wagle> i'm just thinking that i could simulate (albeit very clusmily) a synthetic/inheritive attribute grammar with macros
14:56:01 <lightstep> shapr, wasn't that ltu?
14:56:04 <Darius> ^mean
14:56:15 <shapr> heh, in stereo
14:56:50 <wagle> SyntaxNinja: i was exagerating
14:56:56 <shapr> Do you think the LtU denizens look up research papers on tiling, windings for electric motors, etc?
14:57:27 <Darius> Uh, I don't think of done tiling, but certainly things in the vicinity of electric motors.
14:57:43 <SyntaxNinja> wagle: not by much ;)
14:57:57 <shapr> I've been looking into ultrasonic speakers recently, have you read about them?
14:58:07 <Darius> I haven't even heard of them.
14:58:27 <wagle> Darius: got a page number? (the pdf is a bit map and so unsearchable)
14:58:39 <shapr> Powerful eletric ultrasonic transducers exist, but it took years to get the intereference patterns right so that they produce audible sound.
14:59:18 <shapr> And they're *tiny* too. In fact, ultrasonic transducers are usually just transformers. (You know that whine you hear from old TVs?)
14:59:58 <shapr> Anyway, I'd like to find a mailing list where I can throw out this sort of informational item along with links to related research papers, and find others who do the same on any subjecct.
15:00:29 <shapr> Any suggestions?
15:01:50 <Darius> wagle: http://www.ccs.neu.edu/home/cobbe/pl-seminar-jr/notes/2003-sep-26/expressive-slides.pdf p. 27 + in those slides starts on Macro Expressibility.
15:02:31 <Darius> So you need a general purpose forum full of geeks.
15:02:41 <shapr> I guess so.
15:02:44 <wagle> des.pdf p. 27 + in those slides starts on Macro Expressibility.
15:03:19 <shapr> Something like slashdot with more brain cells.
15:06:17 <wagle> oops
15:10:52 <shapr> hi waltz
15:10:55 <wagle> i do see that he uses keyword macros rather than syntax macros (which invoke on app, lambda, identifier, etc)..  might make a difference
15:12:23 <wagle> i wrote a single (scheme) interpreter that was lazy or eager, depending on how cons, car, and cdr were defined
15:13:28 <wagle> the only really tricky part was getting letrec to work right
15:14:15 <wagle> regardless of whether passed values were values, suspensions (or processes)
15:14:55 <waltz> hi shapr
15:15:11 <waltz> you need anything?
15:15:29 <wagle> assuming that i got that right (it worked for the set of examples), i find it hard to believe that lambda-n and lambda-v aren't macro-expressible in each other
15:15:51 <shapr> waltz: world peace, more money, a paying Haskell gig? =)
15:16:10 <waltz> bahaha ;)
15:16:18 <waltz> I'm with you on the first two anyway heh
15:17:34 <wagle> Darius: how do you see that applying to typeclasses?
15:18:51 <Darius> Simply that the dictionary passing implementation and presumably any other implementation only utilizing Haskell-typeclasses(+higher-rank types) are not local transformations.
15:20:02 <Darius> Actually, I didn't really make what I was saying clear when I made the original remark.
15:21:57 <Darius> shapr said that typeclasses don't add to the strength or weakness of the type system (though what exactly "strength/weakness" is is unclear), my remark was supposed to be that lacking them we lose expressiveness (if not power, though the dictionary passing implementation of type classes require higher-rank types so...)
15:24:29 <Darius> I should probably go to sleep soon.  My writing has been incoherent for quite a while.
15:25:20 <shapr> me too
15:25:29 <wagle> g'night
15:26:09 <wagle> whats the formal definition of "expressiveness"
15:26:12 <wagle> ?
15:26:37 <shapr> wagle: http://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR141.pdf
15:26:45 <wagle> i think its harder to express programs, but not impossible
15:27:12 <Darius> wagle: There isn't a generally accepted one, hence the Felleisen paper.
15:29:49 <wagle> i moved an interpreter for a DSL (which was embedded into scheme, and which scheme was embedded into) into the scheme macro system
15:31:02 <wagle> oh well..  i gotta go stare at his stuff for a while
15:40:57 <dons> moin
15:41:24 <Darius> Fix 'bot.  And shapr find that email and send it to dons if you haven't already.
15:41:43 <shapr> er, right
15:41:45 <dons> patches, yay :)
15:42:24 <dons> @arr
15:42:26 <lambdabot> Shiver me timbers!
15:42:39 <dons> he's still here :) that's good to know
15:43:05 <Darius> dons: Attempting to compile lambdabot with profiling is a nightmare (or was for me).
15:43:19 <dons> yeah, that's today's job.
15:43:28 <dons> i'll just copy acrros way=prof code from Yi
15:43:32 <dons> should be easy then
15:43:58 <Darius> I'm not sure what the issue is actually.
15:44:21 <dons> if you look at the build rules in Makefile, you say $(way_) vars in the output files, so we can create *.p_o
15:47:54 <dons> hmm. I see TheHunter managed to hack @plugs
15:48:18 <Darius> Yeah, lack of type safety is really, -really- bad.
15:48:29 <dons> not sure why unsafeCoerce# is in scope
15:48:42 <dons> it's not supposed to be - must be leaking in
15:48:57 <dons> similar with readFile. hmm.
15:49:23 <dons> good hack though
15:50:12 <dons> doh. I explicitly allowed some GHC.Base stuff
15:50:22 <dons> that was silly
15:55:00 <dons> @plugs let unsafeIOToST :: IO a -> ST s a;  unsafeIOToST io = ST $ \ s -> (unsafeCoerce# io) s in runST (unsafeIOToST (readFile "/etc/fstab"))
15:55:02 <lambdabot> bzzt
15:55:07 <dons> much better
15:55:36 <dons> @plugs (unsafeCoerce# (42) :: Char)
15:55:37 <lambdabot> bzzt
15:57:29 <KrispyKringle> hmm. I'm a little confused. I'm trying to use Parsec to write something equivalent to links := link | anyChar link | empty, where link is a predefined parser. Adn I want to return (link match : links match), i.e. cons the results. I'm a little unsure of how to go about this.
15:57:31 <Darius> @plugs unsafePerformIO
15:57:32 <lambdabot> bzzt
15:57:34 <KrispyKringle> Anyone got a suggestion? Thanks. :)
15:58:10 <KrispyKringle> i thought you could do this with the chian functions or something, but i can't quite figure them out.
15:58:21 <Lemmih> KrispyKringle: links = link <|> anyChar <|> empty
15:58:27 <KrispyKringle> ooh :)
15:58:44 <Lemmih> KrispyKringle: links = link <|> anyChar >> link <|> empty
15:59:04 <KrispyKringle> Lemmih: i think i was unclear.
15:59:22 <KrispyKringle> i mean links := link | anyChar links | empty
15:59:31 <KrispyKringle> can i do such a recursive definition?
15:59:37 <Darius> Of course.
15:59:46 <Lemmih> KrispyKringle: links = link <|> anyChar >> links <|> empty (:
15:59:47 <KrispyKringle> it wouldn't appear typesafe, since links is a Parser [String] while link is a {arser String
15:59:58 <KrispyKringle> but i didn't try it.
16:00:38 <Darius> when the link case is taken you will presumably return a singleton list.
16:01:01 <Darius> links = liftM (:[]) link <|> anyChar >> links <|> return []
16:01:18 <KrispyKringle>  ah, true.
16:02:58 <Darius> @plugs unsafePerformIO undefined
16:03:00 <lambdabot> bzzt
16:03:08 <KrispyKringle> what's going on there with liftM and the cons operator? You're consing link onto an empty list?
16:03:34 <Darius> I'm consing the result of running link onto the empty list, (:[]) == (\x -> [x])
16:03:44 * shapr tries to make an algebraic datatype to represent Penrose tiles.
16:03:49 <KrispyKringle> right
16:04:03 <Pseudonym> shapr: data PenroseTile = Dart | Kite
16:04:04 <KrispyKringle> that's what i meant to say :)
16:04:31 <shapr> Pseudonym: can you make one that enforces the correct tiling?
16:04:46 <Pseudonym> You never said you wanted to do that...
16:05:05 <shapr> Hey Pseudonym, I'd like to do typesafe Penrose tiling.
16:05:07 <shapr> better?
16:05:11 <Pseudonym> Better, yes.
16:05:57 <shapr> I guess I'd need a zipper-like structure.
16:07:02 <KrispyKringle> sjo what's wrong with doing links = do{ l <- link; ls <- links; return (l:ls)} <|> (anyChar >> links) <|> return [], other than that it doesn't work? :)
16:07:17 <shapr> How do you define the sort of recursive datatype that would enforce a Penrose surface?
16:07:32 <lightstep> using strings instead of adts makes little pugs cry
16:07:59 <Pseudonym> Well, first things first.
16:08:01 <Darius> KrispyKringle: Doesn't work as in doesn't type check or doesn't parse correctly?
16:08:07 <Pseudonym> What are the angles on a Penrose surface?
16:08:13 <Pseudonym> I think you need to quantise the orientations.
16:08:19 <KrispyKringle> Darius: doesn't typecheck in ghci.
16:08:54 <shapr> Pseudonym:  One tile has four corners with the angles {72, 72, 108, 108} degrees. The other has angles of {36, 36, 144, 144} degrees - from http://en.wikipedia.org/wiki/Penrose_tile
16:08:59 <KrispyKringle> Darius:     Couldn't match `Parser [String]' against `t -> t1'
16:08:59 <KrispyKringle>         Expected type: Parser [String]
16:09:00 <KrispyKringle>         Inferred type: t -> t1
16:09:01 <shapr> I think their L-system is wrong though
16:09:17 <Pseudonym> All multiples of 36./
16:09:43 <dons> shapr: where's the code for @wiki @index live?
16:09:44 <Darius> KrispyKringle: What subexpression is it talking about?  Does link take any args?
16:09:45 <shapr> Maybe I could represent each tile as a node with four edges to other nodes, and they can connect only to certain other edges?
16:10:01 <Pseudonym> Now you need to pick an origin for each tile and try to work out the space that it can live in.
16:10:05 <shapr> dons: @index is in HaddockModule, @wiki is in DummyModule I think. @wiki is *really* boring.
16:10:14 <dons> though @wiki was just echo with a url, right?
16:10:21 <KrispyKringle> Darius: no, links doesn't. but its presumably referring to  do{ l <- link; ls <- links; return (l:ls)}
16:10:33 <Pseudonym> shapr: Actually, a winged edge-like model isn't so dumb.
16:10:40 <Darius> dons: Add an @alias facility and @wiki could be defined (e.g. via @eval/@plugs)
16:11:04 <dons> that's an interesting idea. hmm..
16:11:17 <dons> we'd be generating  new plugins on the fly
16:11:24 <shapr> yeah, that would be much better.
16:11:24 <dons> so they'd have to be kept somewherre.
16:11:32 <dons> sound like a job for hs-plugins!
16:11:33 <shapr> SerTH?
16:11:50 <Darius> dons: It would mostly be a fall-through mechanism that (as a first pass) repipes the "expansion" into the system.
16:11:50 <shapr> Pseudonym: but how do you limit the connecties?
16:12:06 <Pseudonym> That's the NEXT problem. :-)
16:12:19 <Pseudonym> Hmmm.
16:12:20 <Pseudonym> OK.
16:12:38 <Pseudonym> For each tile, and each edge of the tile, work out what edges of what tiles can be attached to it.
16:12:54 <Darius> @type Text.ParserCombinators.Parsec.anyChar
16:12:57 <lambdabot> Text.ParserCombinators.Parsec.anyChar :: forall st.
16:12:57 <lambdabot>                                          Text.ParserCombinators.Parsec.Char.
16:12:57 <lambdabot> CharParser st Char
16:14:03 <Darius> KrispyKringle: You shouldn't need to presume it should tell you.
16:14:20 <KrispyKringle> Darius: to presume what?
16:14:20 <Darius> But if link :: Parser String, then it looks like it's type correct to me.
16:14:31 <KrispyKringle> oh
16:14:39 <KrispyKringle> well, it says     Probable cause: `links' is applied to too many arguments in the call
16:14:45 <KrispyKringle>         (links "asdf[[1]][[2]]")
16:14:54 <KrispyKringle> but that's not so informative.
16:15:00 <lightstep> shapr, i thought that the tiling problem was undecidable. you can't expect haskell's type system to solve it
16:15:11 <Darius> KrispyKringle: Sure it is, it's exactly right.
16:15:20 <Darius> links is not a function.
16:15:26 <shapr> lightstep: no clue, I've never tried this before.
16:15:42 <KrispyKringle> Darius: ...i typoed in the toplevel.
16:15:42 <KrispyKringle> d'oh.
16:15:49 <shapr> And I don't want to solve it in the type system, just enforce the constraints.
16:15:51 <shapr> That part should work.
16:16:12 <KrispyKringle>  Darius sorry for wasitng your time. this is a sign i should take a break and drink some coffee ;)
16:16:16 <KrispyKringle> thanks for the help.
16:16:27 <shapr> lightstep: could you point me to more info?
16:16:43 <shapr> lightstep: here's what I'm looking at - http://www.cs.uidaho.edu/~casey931/puzzle/penrose/penrose.html
16:17:30 <Pseudonym> http://xarch.tu-graz.ac.at/home/rurban/software/lsystem/LSYSTEM.L
16:17:35 <Pseudonym> There are a couple of L-systems.
16:19:03 <shapr> So I could make an L-system interpreter. But I'd rather see if I can find some way to limit connecties first.
16:19:46 <shapr> darts can only connect to kites, kites can only connect to darts. That much I can do immediately.
16:20:23 <Pseudonym> That's not the whole story.
16:21:07 <shapr> Right, edges must match. Can you have typed edges?
16:21:49 <shapr> You can, somewhat.
16:21:58 <Pseudonym> shapr: Do you know about winged-edge models?
16:22:04 <shapr> Never heard of 'em
16:22:14 <shapr> Sounds like a plastic airplane, but I shall ask google.
16:22:15 <lightstep> good night
16:22:43 <Pseudonym> Oh!
16:22:45 <Pseudonym> I've got an idea.
16:22:49 <shapr> I know how to do typed edges I think.
16:23:13 <Pseudonym> Maybe you could do it via the deflation rules.
16:23:29 <shapr> If you name them from left to right from inside the tile, then they're grey-black black-none none-black and black-grey inside the fat tile.
16:23:33 * Lemmih is amazed by wxWidgets... 12 years of development and stuff like word wrapping has not hit stable yet.
16:23:49 <Pseudonym> Hmmm.
16:23:52 <Pseudonym> Maybe not.
16:23:55 <shapr> deflation rules?
16:24:01 <Darius> dons: I'm going to darcs send you the Posix.hs module I made and the changes to IRC.hs.  I don't know if they work, but they compile (which should be enough for the IRC.hs changes).  The code should compile fine in non-Win32 on Win32 it has some warnings that I may fix later.
16:24:21 <dons> cool! thanks.
16:24:39 <dons> btw, regarding build time, -jN works fine with lambdabot.
16:24:44 <shapr> happiness.
16:24:53 <Pseudonym> http://mathworld.wolfram.com/PenroseTiles.html
16:25:26 <Darius> @version
16:25:27 <lambdabot> Wed Mar 30 21:58:22 EST 2005, GHC 6.2.2 (OpenBSD i386)
16:25:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:25:39 <araujo> mmm
16:25:53 <araujo> my package.conf on 6.4 is a real disaster, it doesn't contain newlines
16:26:01 <araujo> anybody with the same problem?
16:26:12 <shapr> The five-fold symmetry tiles are pretty boring.
16:26:18 <dons> araujo: I think that's everyone's experience
16:26:24 <Lemmih> araujo: GHC 6.4 can only understand Cabal packages.
16:26:24 <araujo> :-P
16:26:28 <Darius> dons: The dons@cse... email good?
16:26:32 <dons> yep
16:26:42 <araujo> I see...
16:26:53 <Lemmih> Oh wait. I misread /-:
16:26:55 <araujo> Lemmih, so, no backward compatibility?
16:27:40 <Lemmih> None at all. Cabal is so much better anyway (:
16:27:47 <araujo> dons, you also have it with no-newlines?
16:28:06 <dons> yeah, ghc-pkg seems to do a non-prettyprinted show now
16:28:20 <araujo> ok, thanks
16:28:23 <shapr> hey, I bet I can use fundeps to do this.
16:32:14 <Darius> darcs send doesn't like my mailer so I'm going to email the darcs send -o file.
16:32:24 <dons> that's fine
16:42:59 <shapr> I can't figure out how to type the connections.
16:43:27 <shapr> I need to be able to differentiate between the positions on both tiles.
16:44:05 <shapr> I could just arbitrarily assign them...
16:45:41 <shapr> I should ask Oleg.
16:46:09 * Pseudonym is having a go
16:47:14 <ddarius> dons: My SMTP server doesn't seem to want to listen to me, so I'll probably send it tomorrow at the latest (assuming it works then).
16:48:49 <dons> ok.
16:49:18 <dons> you can't darcs send -o , then scp it somewhere you can send from?
16:49:55 <Darius> No
16:50:48 <Pseudonym> It's an Oleg-like solution, sadly.
16:51:27 <shapr> data FatTile = Fat ThinTile ThinTile ThinTile ThinTile -- connections are none-black, black-none, none-grey, grey-none,
16:51:39 <shapr> data ThinTile = Thin FatTile FatTile FatTile FatTile -- connections are grey-none, black-none, none-black, black-grey
16:52:00 <shapr> With that, I think you can use functions to enforce correct matching rules
16:52:05 <shapr> er, wait...
16:52:10 <shapr> what about GADTs?
16:53:14 <shapr> GADTs just might cut it.
16:57:15 <shapr> Yes, they might!
16:57:59 <dons> this @pointless module is fun
16:58:26 <dons> but we really need to partition lambdabot core and plugins into separate dirs
16:58:35 <shapr> The core is a plugin.
16:58:49 <shapr> oh, I see what you mean.
16:59:00 <shapr> What about partitioning into the two plugin flavors?
16:59:07 <dons> it's just a big dump of src atm.
16:59:16 <dons> what flavours? small and big?
16:59:26 <shapr> typeclass and process
16:59:33 <dons> ok. yeah. that's what I mean.
16:59:52 <dons> core/ plugin/ ?
16:59:58 <shapr> wfm
17:00:07 <dons> and more gmake hacking
17:00:38 <dons> ok.
17:00:51 <shapr> trying to use GADTs to do typesafe Penrose tiles is hurting my head.
17:00:51 <dons> some of the big plugins should be haskell packages
17:00:57 <shapr> like what?
17:01:12 <dons> PlModule, Eval and Haddock, I think.
17:01:49 <dons> maybe it doesn't matter too much though.
17:02:13 <ozone> what's @pointless?
17:02:28 <dons> ah! paprika$ ./lambdabot
17:02:29 <dons> Exception: Prelude.read: no parse
17:02:36 <dons> only when building with 6.4
17:02:37 <shapr> HaddockModule uses a bunch of pieces of Haddok itself to parse the name.haddock binary files. It might be more sensible for me to instead patch haddock to have the ability to dump name.haddock files via show, and then lambdabot wouldn't have to know about it.
17:02:54 <dons> yep. that's a good idea.
17:03:26 <shapr> Eval is pretty muh a separate app. The lambdabot plugin is almost incidental.
17:03:37 <dons> @pointless  \f x -> x >>= return . f
17:03:38 <lambdabot> fmap
17:03:48 <dons> @pointless \x y -> [x-y .. y-x]
17:03:49 <lambdabot> s (s . (enumFromTo .) . (-)) (flip (-))
17:03:56 <dons> ozone :) TheHunter contributed it
17:04:21 <shapr> @pointless \y -> y + \x -> x + 1
17:04:22 <lambdabot> ((1 +) +)
17:04:23 <ozone> ah!
17:04:35 <ozone> damn point-free-style evangelists
17:04:49 <dons> @pointless \f g x y -> f (g x y)
17:04:50 <lambdabot> (.) . (.)
17:04:57 <shapr> That's swing.
17:05:09 <ozone> does it deal with free variables?
17:05:18 <dons> I like this one:
17:05:19 <dons> @pointless let x = 1:x in x
17:05:21 <lambdabot> fix (1 :)
17:05:26 <Darius> EvalModule not too practical as a standalone app.  Heck, it's not too practical as a lamdabot module ;)
17:05:32 <dons> hehe
17:05:45 <ozone> @pointless \x -> f (g x)
17:05:46 <lambdabot> f . g
17:05:48 <dons> but any app with a 'thunkify' function is worth something.
17:06:01 <shapr> Any app with a joy interpreter is worth something!
17:06:18 <dons> :)
17:06:24 <shapr> EvalModule taught me just how short is the path from lambda calculus to Haskell.
17:06:30 <ozone> that's actually pretty cool
17:06:56 <dons> so, Darius, you're using 6.4 - I'm now getting Prelude.read: no parse, only with 6.4 though :/
17:07:04 <shapr> EvalModule plus the definitions file is educations for functional language implementors.
17:07:18 <shapr> Eval itself is educational for interpreter writers.
17:07:50 <dons> yeah, that's true.
17:08:15 <shapr> Darius: you could write a tour of Eval TMR article!
17:10:51 <dons> hang on, what do you bet that it's read $ readFile (ghcLibraryPath ++ "package.conf") failing for 6.4...
17:10:57 <Darius> As long as they don't care about efficiency in the slightest
17:10:58 <shapr> !
17:11:17 <Darius> Though I guess I could've modeled the store with an assoc list!
17:11:37 <dons> :}
17:12:08 <Darius> dons: Isn't that run to generate a file to build another source file?
17:12:33 <Darius> But yes, that would be it (damn GHC6.4 going whole hog into Cabal)
17:12:35 <dons> it's used by the runtime loader to work out package extensions I think.
17:12:46 <dons> I have a patch for this in hs-plugins though.
17:14:51 <dons> Reading package.conf ...
17:14:52 <dons> Exception: Prelude.read: no parse
17:14:58 <dons> it doesn't get passed that line.
17:15:02 <SyntaxNinja> cabal problem?
17:15:07 <dons> nope.
17:15:14 <dons> lambdabot tries to read package.confs
17:15:22 <dons> but doesn't know how to read 6.4 ones yet.
17:15:29 <dons> i'll take a firm hand to it.
17:15:40 <humasect> =)
17:15:42 <SyntaxNinja> ahh
17:15:59 <SyntaxNinja> dons: note that there's a parser in cabal for those, I think.
17:16:10 <SyntaxNinja> does it want to read package.confs or .cabals?
17:20:29 <dons> yep. I'll use the cabal one.
17:20:42 <dons> it want's to read the package.confs
17:21:08 <dons> import Distribution.Package
17:22:35 <shapr> Yes, I think I really can create type-safe Penrose tiles with GADTs, but I'll have to sleep on it first.
17:36:35 <dons> SyntaxNinja: are Cabal-era package.conf's read()-able PackageDescription values?
17:38:00 <dons> oh, we even have readPackageDescription :: FilePath -> IO PackageDescription
17:45:38 <dons> I'm not sure Cabal can read GHC package.confs. I see a showGHCPackageConfig :: GHCPackageConfig -> String, but no parser
17:51:13 <dons> ok. so 6.4 package.confs are really InstalledPackageInfo
17:53:30 <SyntaxNinja> yeah
17:54:39 <dons> so I wonder if there's a way to get from InstalledPackageInfo to Distribution.Simple.GHCPackageConfig's
17:54:58 <dons> though writing that by hand doesn't look too hard
17:55:36 <SyntaxNinja> why do you want a ghcpackageconfig?
17:56:21 <dons> that's the type lambdabot's dyn loader currently deals with. it just uses a couple of fields though.
17:57:25 <SyntaxNinja> hm. then don't pass the whole structure, pass just those fields, and get them directly from the InstalledPackageInfo or PackageDescription or wherever they really come from
17:58:17 <dons> yep. I think I can read the InstalledPackageInfo directly, then construct my own GHCPackageConfig with only the nec. fields set.
17:58:47 <dons> hs-plugins doesn't have to deal with any of this - it knows how to parse both styles of package.conf
17:59:37 <SyntaxNinja> I'm suggesting a refactoring to not use GHCPackageConfig, if you're only using a few fields, why not pass them individually?
18:00:11 <dons> I still need to be able to parse 6.2.2. package.confs though
18:00:48 <dons> but using just the 3 fields I need internally is sensible
18:01:17 <dons> either way, not much work to get there now.
18:01:44 * SyntaxNinja nods
18:02:35 * dons thinks hs-plugins could use more Cabal code than it currently does
18:02:51 <dons> I wonder how much of hs-plugins' make() I could replace
18:08:11 <SyntaxNinja> ooh, probably!
18:08:14 <SyntaxNinja> what does make () do?
18:09:15 <dons> make at its simplest compiles src and dependencies to .o files
18:09:20 <dons> suitable for plugin loading
18:09:41 <dons> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-3.html#node_sec_6
18:10:11 <dons> there's a facility for merging two src files, that I presume Cabal wouldn't need or have
18:10:42 <dons> make does things like parsing OPTION pragmas too
18:11:56 <dons> make() deals with unnecessary recompilation by checking timestamps
18:11:58 <SyntaxNinja> oh cool.
18:12:09 <SyntaxNinja> this is haskell code?
18:12:12 <dons> yeah.
18:12:16 <dons> Plugins.Make in hs-plugins
18:12:23 <SyntaxNinja> hm. some of it could possibly be useful in cabal
18:12:41 <SyntaxNinja> why do you parse OPTION pragmas?
18:13:18 <dons> I think it was to work out load() search paths.
18:14:06 <araujo> ALL the cabalized pkgs must contain a Setup.[l]hs file right?
18:14:14 <SyntaxNinja> hm. don't get it. you should be able to get that fromthe package conf files and such
18:14:20 <SyntaxNinja> araujo: yeah
18:14:23 <dons> oh, when you merge two files, we need to keep track of the OPTIONS pragmas from one of the src files.
18:14:38 <dons> because the Haskell ppr lib doesn't maintains pragmas
18:14:40 <SyntaxNinja> why do you merge source files?
18:14:57 <dons> it's useful for writing plugins to have compulsory syntax always included
18:15:03 <araujo> thanks SyntaxNinja
18:15:04 <SyntaxNinja> you don't happen to have a dependency analyzer, do you?
18:15:14 <dons> nope :/ just --make
18:15:19 <SyntaxNinja> araujo: np. that might change eventually, but that's the conservative thing for now.
18:15:35 <SyntaxNinja> dons: there's a dependency analyser in hmake that I keep meaning to pull out and put into cabal so ppl don' thave to list all their source files
18:15:43 <SyntaxNinja> but it's low priority
18:16:07 <araujo> ok, i ask, because i found this package haxml , in the cvs, it contains a .cabal file, but no Setup.hs
18:16:08 <dons> hmm. I guess load does it's own dependency analysis
18:16:14 <dons> but it reads .hi files for this
18:16:38 <dons> it constructs at runtime a list of dependent modules and packages
18:17:09 <dons> not quite the same as src-level dependency chasing
18:17:32 <SyntaxNinja> yeah
18:17:42 <Lemmih> Hackage Browser. 3/30 2005 to 3/31 2005. RIP.
18:21:39 <SyntaxNinja> whyfor?
18:23:14 <Lemmih> wxWidget just pissed me off too much.
18:56:32 <metaperl> does anyone have a tighter way of generating the final result I created here: http://www.hcoop.net/~terry/haskell/craft-of-fp/ex/horseboard.txt
19:32:50 <CosmicRay> shapr: if  you're still interested in asterisk, http://changelog.complete.org/node/264
20:00:35 <dons> @version
20:00:36 <lambdabot> Thu Mar 31 13:58:15 EST 2005, GHC 6.4 (OpenBSD i386)
20:00:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:00:48 <dons> @quit
20:03:02 <dons> xerox, Darius, vegai: I think I've fixed the 6.4 issues.
20:03:18 <KrispyKringle> heh
20:04:00 <KrispyKringle> so anyone know how to use GET vars in WASH to call a function?
20:49:10 <Pseudonym> http://andrew.bromage.org/Penrose.hs
21:36:19 <Pseudonym> Woah.
21:36:37 <Pseudonym> I printed out a big penrose tile thingy.
21:36:43 <Pseudonym> Now I'm seeing things.
21:37:08 <Pseudonym> I'm guessing this is what serious cannabis use is like.
21:46:33 <Spark> weed makes you hallucinate?
21:46:44 <Pseudonym> Not that I'd know.
21:47:01 <Pseudonym> I've only ever indulged in passive smoking, and it wasn't exactly deliberate.
21:52:49 <KrispyKringle> As in, someone held you down?
21:53:03 <Pseudonym> No, but that'd be interesting, I must admit.
21:53:04 <Spark> you could have chosen not to breathe
21:53:20 <Spark> i think your decision to breathe was irresponsible
21:53:30 <KrispyKringle> Heh. I have a friend who was caught in his dorm. They made him take a one-step program. I guess they were too lazy to deal with all 12.
21:53:34 <KrispyKringle> Struck me as really bizarre.
21:53:39 * Pseudonym laughs
21:53:52 <Spark> heh
21:53:57 <Spark> because weed is addictive
21:53:58 <Gahhh> bahaha
21:53:59 <Pseudonym> That's almost ironic.
21:54:05 <KrispyKringle> He told me this today. I said, "Oh, a 12 step program?" He said "Kinda. But there was only one."
21:54:14 <KrispyKringle> I guess the step is, "stop smoking."
21:54:19 <KrispyKringle> *shrug*
21:54:24 <Spark> you go there and youre like "right, im clean, theres no problem, can i go home now?"
21:54:25 <Pseudonym> "Twelve steps?  Wow, dude.  That sounds like a lot."
21:54:32 <KrispyKringle> anyway, I'm in a sort of quandry over WASH :P
21:54:36 <KrispyKringle> (to get back on topic ;)
21:54:57 <KrispyKringle> I wan't to be able to pass GET variables to my CGI.
21:55:28 <KrispyKringle> But I can't figure out a place it supports that directly. However, it does seem to support reading the URL. So I could parse that myself, but that seems silly. Anyone know of a better way?
21:57:24 <KrispyKringle> Guess not. :P
22:30:50 <Heffalump> morning
22:34:58 <SyntaxNinja> 'morning
22:35:02 <SyntaxNinja> Heffalump: voted yet?
22:35:20 <Pseudonym> There's a vote?
22:35:27 <Heffalump> I'm not a DD
22:35:30 <Heffalump> if that's what you mean
22:35:37 <Pseudonym> Ah, right.
22:36:00 <Heffalump> my first (pretty trivial, haskell-http) package hasn't even made it out of incoming yet.
22:57:14 <Itkovian> meuning
22:57:25 <Igloo> SyntaxNinja: You know you haven't voted, right?
22:57:47 <SyntaxNinja> Heffalump: oh hm. I somehow thought you were a dd
22:57:49 <SyntaxNinja> Igloo: yes
22:58:04 <Igloo> OK, cool  :-)
22:58:08 <SyntaxNinja> Igloo: I'm trying to force myself to read debian-vote; it's like drinking a gallon of evil medicine
22:58:39 <SyntaxNinja> and for a list of people who *just don't get it* when it comes to cryptography, go here: http://wiki.debian.net/?DraftGergely
23:00:59 <Gahhh> ?
23:01:37 <Gahhh> Some people didn't sign. Is that what you mean >
23:01:40 <Gahhh> ?
23:01:48 <Heffalump> I suspect the signatures are all faked.
23:02:15 <Igloo> They all just say things like "Go for it!" without saying what
23:02:28 <Igloo> They're mostly taken from DraftBrandon
23:02:40 <Heffalump> some of them mention him, though.
23:02:43 <Gahhh> ah I see
23:02:46 <SyntaxNinja> Gahhh: what igloo said, so they're subject to replay attacks
23:02:57 <Heffalump> but I guess those ones are faked.
23:02:58 <Gahhh> they should explicitly mention the year and exact position etc huh
23:03:26 <SyntaxNinja> Gahhh: yeah; and worse, they could be used for something completely different, like agreeing to something bad.
23:03:36 <Gahhh> Well
23:03:42 <Gahhh> I think that page is all borked then
23:03:49 <mflux> syntaxninja, otoh, they can easily be retracted, just because of that reason ;)
23:03:57 <Gahhh> You should publish a ballot (yes and no), and make them sign the one they choose.
23:04:44 <xerox> 'morning
23:04:45 <SyntaxNinja> mflux: by signing such messages, they basically retract anything useful they could do with that key, imo :)
23:04:45 <xerox> @version
23:04:46 <lambdabot> Thu Mar 31 14:53:46 EST 2005, GHC 6.4 (OpenBSD i386)
23:04:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:04:56 <mflux> syntaxninja, well they can still sign useful messages?
23:05:09 <SyntaxNinja> mflux: but who will trust them to know how to handle their key properly?
23:05:55 <mflux> so basically they signed them saying 'yes', and you can 'prove' they said 'yes' to some matter.. I don't think it much tells about how they manage their key, and each message signed by them can be considered as a separate case
23:06:48 <mflux> maybe wiki should have some gpg-support built-in
23:06:57 <Gahhh> nah it doesnt
23:07:01 <mflux> so they could hash the version they modified etc ;)
23:07:35 <mflux> someone could just now go and change the page entirely
23:08:00 <SyntaxNinja> Igloo: it's funny that they're taken from the branden page :)
23:08:05 <Gahhh> The wiki page needs to have two paragraphs: 1) "Yes, yadda yadda please run for 2005 Debian PL" and 2) "Not #1", and you sign the paragraph which is your vote.
23:09:10 <SyntaxNinja> mflux: idono, it's pretty easy to screw up when dealing with crypto stuff, and I think seeing someone sign a 'yes' message is a sign that they are not that trustworthy when it comes to crypto
23:09:34 <Gahhh> SyntaxNinja, heh, that is true.
23:09:40 <SyntaxNinja> it doesn't directly say something about how they manage their keys, but it does say something about their depth and intuition with crypto
23:09:43 <Igloo> If you mean literally "Not #1" then you shouldn't sign that either. And anyway, it would make no difference to do so as all that was wanted was 100 yesses
23:10:09 <Gahhh> Igloo, I didn't mean "not #1". I was just lazy to type the negative :)
23:10:17 <Igloo> OK  :-)
23:10:53 * Gahhh thinks that SyntaxNinja is one of those debian developers who cannot use a linked list in C...
23:11:02 <Gahhh> (read that on ./)
23:11:37 <Heffalump> what's he done?
23:11:41 * Heffalump likes linked lists in C
23:11:51 <xerox> Heretic :P
23:12:45 <SyntaxNinja> Gahhh: I have no idea how to take that comment ;)
23:12:59 <SyntaxNinja> but I am proficient at C :)
23:13:38 <Gahhh> Somebody claimed that one of those debian devs who got to vote couldn't even use linked lists in C, and I thought to myself "hmm maybe that's some haskell hacker" ;)
23:14:12 <SyntaxNinja> haha
23:14:23 <Heffalump> I suspect most Haskell programmers are competent or good C programmers.
23:14:42 <Heffalump> they just won't necessarily *like* using it :-)
23:14:47 <SyntaxNinja> linked lists don't bug me much, it's fixed-length buffers that I hate
23:15:00 <SyntaxNinja> I get really stressed using them; linked lists are nice and recursive ;)
23:15:07 <Gahhh> come on
23:15:14 <SyntaxNinja> i'm serious!
23:15:22 <Gahhh> who doesn't like a heart warming "char buf[80];" in a function...
23:15:28 <Gahhh> "80"
23:15:33 <xerox> @yow
23:15:34 <lambdabot> Prelude.(!!): index too large
23:15:38 <SyntaxNinja> heh
23:15:41 <xerox> Exactly the same error here.
23:15:49 <dons> @yow
23:15:49 <SyntaxNinja> who uses !!
23:15:49 <lambdabot> Prelude.(!!): index too large
23:15:52 <dons> @yow
23:15:53 <lambdabot> Couldn't find yow file
23:16:11 <Gahhh> yow as in emacs' yow ?
23:16:19 <xerox> But I can't completely understand the code.
23:17:38 <dons> I don't have any yow definitions yet - shapr?
23:17:57 <xerox> getRandItem mylist rng = (mylist !! index,newRng)  -- Haskell-mode is suggesting that index :: (Ix a) => (a,a) -> a -> Int, how does this line work?
23:18:36 <xerox> where llen = length mylist; (index, newRng) = randomR (0,llen) rng
23:18:39 <dons> yeah, so if list = [], then is yow off by one in the index range. I wonder.
23:19:17 <SyntaxNinja> anyway (!!) is only one of the possible problems w/ fixed-length buffers
23:19:29 <SyntaxNinja> and I almost never use !!
23:19:37 <xerox> I miss where the first and the second arguments are applied to index.
23:20:42 <dons> xerox: 6.4 bugs gone?
23:21:21 <xerox> dons: yep!! Thank you very much, what was it?
23:21:57 <Heffalump> hey dons, where can I email lambdabot patches?
23:22:14 <dons> should be an address in the repo? does darcs send work?
23:22:21 <Heffalump> it wants a target email address
23:22:32 <Heffalump> dons@cse.unsw.edu.au ?
23:22:33 <dons> dons@cse.unsw.edu.au
23:23:10 * Heffalump sends a small patch to SeenModule that must haveonly made it to shapr's repo after you forked it (plus a merger patch)
23:23:34 <dons> I just grabbed shapr's repo 2 days ago.
23:23:40 <dons> but it was a bit old and fusty
23:23:53 <Igloo> You should put that in _darcs/prefs/email
23:23:56 <dons> done.
23:24:09 <xerox> Is "timeoutKiller = do threadDelay (2000000) -- 2 secs" plugs' timeout?
23:24:14 <Heffalump> you must have grabbed a different one to the main one, then
23:24:25 <dons> hmm.
23:24:33 <dons> the ScannedInAvian one
23:25:04 <dons> http://www.scannedinavian.org/repos/lambdabot/
23:25:39 <Heffalump> oh. I'm sure that used to have my patch.
23:25:42 <Heffalump> Maybe I'm confused.
23:25:52 <nlv11757_> happens to the best heffa :P
23:26:10 <dons> looks like there's an even older bot in http://www.scannedinavian.org/repos/hlibs/lambdabot/
23:26:49 <Heffalump> *shrug*
23:27:09 <Heffalump> it's not a particularly important patch, just scratches an itch I had with @seen a while ago :-)
23:27:15 <dons> cool.
23:27:19 <dons> more patches people!
23:27:47 <Heffalump> you should put yourself in AUTHORS
23:28:08 <dons> xerox: nah, plugs timeout is in plugs src code.
23:28:09 <dons> setResourceLimit ResourceCPUTime (ResourceLimits rlimit rlimit)
23:28:16 <dons> Heffa, good idea.
23:29:04 <basti_> hi
23:30:48 <xerox> @plugs take 2 $ drop 2 $ [0..]
23:30:49 <lambdabot> [2,3]
23:31:53 <xerox> Hmpf, my ./lambdabot answers bzzt to all my @plugs .
23:32:02 <dons> you don't have runplugs installed..
23:32:06 <Heffalump> @plugs let loop () = loop () in loop () -- got to do the predictable thing
23:32:07 <lambdabot> <Plugins.Eval>:1: parse error (possibly incorrect indentation)
23:32:17 <Heffalump> @plugs let loop () = loop () in loop () {- got to do the predictable thing -}
23:32:18 <lambdabot> /tmp/MgKku17545.hs:1:
23:32:18 <lambdabot>     Ambiguous type variable `a' in the top-level constraint:
23:32:18 <lambdabot>       `Show a' arising from use of `show' at <Plugins.Eval>:1
23:32:26 <Heffalump> hmph :-)
23:32:35 <dons> give it a monomorphic type
23:32:36 <Heffalump> @plugs let loop () = loop () in loop () :: Int  {- got to do the predictable thing -}
23:32:40 <lambdabot> bzzt
23:32:45 <Heffalump> :-)
23:32:45 <dons> I WIN!
23:32:58 <basti_> ?
23:33:02 <Heffalump> how do you pass values back, Show/Read?
23:33:05 <xerox> dons: where can I get runplugs?
23:33:06 <dons> yep
23:33:14 <dons> expr has to be showable.
23:33:19 <ozone> if only simonpj were here, i bet he could break it :)
23:33:27 <Heffalump> @plugs error "foo"
23:33:28 <lambdabot> /tmp/MpzCkO4581.hs:1:
23:33:28 <lambdabot>     Ambiguous type variable `a' in the top-level constraint:
23:33:28 <lambdabot>       `Show a' arising from use of `show' at <Plugins.Eval>:1
23:33:31 <Heffalump> @plugs error "foo" :: Int
23:33:33 <lambdabot> bzzt
23:33:50 <dons> xerox: grab hs-plugins-0.9.8, build it with 6.2.2, then copy ./runplugs into your path.
23:34:18 <dons> yeah, so there's the Show constraint too
23:34:20 <xerox> dons: getting 6.2.2 is way complicated now, is there a binary copy?
23:34:29 <dons> for what OS?/
23:34:34 <xerox> Linux x86
23:34:42 <dons> i'll make you one.
23:34:52 <xerox> Thank you \o/
23:36:05 <Gahhh> I thought that there were rpms online
23:36:29 <dons> there may be for hs-plugins, yes.
23:36:43 <dons> xerox: ftp ftp://ftp.cse.unsw.edu.au/pub/users/dons/runplugs
23:37:10 <Heffalump> dons: btw, should building lambdabot with ghc 6.2.2 complain? Cos it builds ok, then fails at runtime
23:37:23 <xerox> Oh my..
23:37:23 <dons> should run fine.
23:37:32 <xerox> dons: got it. Thank you.
23:37:44 <dons> xerox: but if you've only got 6.4 on your box, you'll get a FiniteMap warning, I think.
23:37:55 <dons> Heffalump: how does it fail?
23:38:11 <dons> I ran lambdabot from 6.2.2 till this morning, actually.
23:38:23 <Heffalump> oh, the patches I saw made me think it was 6.4 only
23:38:31 <Heffalump> EvalModule.o: unknown symbol `TextziParserCombinatorsziParsecziError_show_closure'
23:38:32 <SyntaxNinja> converting all my code from FiniteMap may be painful
23:38:34 <desrt> i hear the new finitemap is supposed to be nice
23:38:35 <Heffalump> PlModule.o: unknown symbol `__stginit_PlModuleziTransform_'
23:38:40 <xerox> Fail: /home/pls/lib/ghc-6.2.2/package.conf: openFile: does not exist (No such file or directory)
23:38:57 <Heffalump> it does actually run, but fails to connect to IRC for some undiagnosed reason, though that might just be that I haven't configured it properly
23:38:57 <dons> xerox: ok, you got to get 6.2.2 and build it yourself.
23:39:04 <xerox> I'll do it.
23:39:12 <dons> now, those symbol issues should be resolved by today's patches.
23:39:18 <dons> hmm. let me check
23:39:34 <dons> (they're just missing deps in BotConfig.hs iirc)
23:39:40 <Heffalump> oh, I didn't build again after I pulled today's patches
23:39:42 <Heffalump> I'll try now
23:40:32 <dons> -jN even works.
23:41:15 <dons> SyntaxNinja: yeah, it sucks. There's actually a FiniteMap<->Map module in lambdabot you could steal, or just use -fno-warn-deprecations ;)
23:41:17 <xerox> I'll run it on some 24/7 workstation, it will be nice to have a personal lambdabot ;)
23:41:28 <dons> it's fun :)
23:41:46 <xerox> Really fun, now that it has @plugs and @pointless !
23:42:02 <basti_> i still dont understand what @pointless would be useful for
23:42:14 <dons> obfuscation contests, of course
23:42:20 <basti_> hm
23:42:22 <basti_> yes.
23:42:41 <xerox> I liked points-freeing the code, I used to ask here about it, TheHunter had this idea of making a parser for it.. it's nice :)
23:42:53 <dons> yeah, the PlModule is really nice
23:45:31 <SyntaxNinja> dons: not to complain or anything, but it just feels like finitemap is something that shouldn't change.  I'm glad if it's better, and I'll change my code to use it, but still.
23:45:58 <Heffalump> @pointless Heffalump
23:45:59 <lambdabot> Heffalump
23:46:25 <Heffalump> clearly I am truly pointless.
23:46:44 <SyntaxNinja> heh
23:46:54 <xerox> yay :) Breakfast time.
23:47:15 <SyntaxNinja> I should go to bed so I have time for breakfast in the morning
23:52:06 <Heffalump> ahah.
23:52:15 <Heffalump> it just didn't like not being able to use the configured nickname.
23:52:54 <dons> just timing out in the reader loop?
23:52:59 <Heffalump> yeah
23:55:23 <dons> any symbol errors on startup?
23:55:38 <dons> mac-a-bot: @version
23:55:46 <dons> @version
23:55:47 <lambdabot> Thu Mar 31 14:53:46 EST 2005, GHC 6.4 (OpenBSD i386)
23:55:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:55:47 <mac-a-bot> Thu Mar 31 15:51:50 EST 2005, GHC 6.2.2 (Darwin Power Macintosh)
23:55:47 <mac-a-bot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:55:56 <Heffalump> dons: nope
23:56:05 <dons> It runs on the mac :)
23:56:29 <dons> H: good.
