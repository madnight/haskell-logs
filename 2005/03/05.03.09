05:38:11 --- topic: '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]'
05:38:11 --- topic: set by shapr on [Sun Mar 06 12:29:48 2005]
05:38:33 <calvin_> I'm trying out gtk2hs and the hello world binary comes out at about 5.7MB, is that normal?
05:38:48 <jlouis> quite
05:38:59 <jlouis> (its not stripped)
05:39:23 <pipe> hello world of wxhaskell is i think 21MB
05:39:45 <mflux> so haskell's not for embedded environments?-)
05:41:05 <calvin_> ok
05:41:52 <Darius> mflux: GHC doesn't dynamically link libraries (currently)
05:43:02 <Darius> Also I'm not sure how much effort it puts into finding the minimal dependencies, I think practically none.
05:43:14 <Lemmih> pipe: Not quite.
05:44:06 <Philippa> it does it to the object file level
05:44:20 <Philippa> running strip on the generated binaries generally gives a big reduction
05:44:56 <pipe> Lemmih: you are right.. it's only 9 MB :D
05:45:36 <calvin_> Philippa: yeah, strip brings it down from humongous to just huge.
05:45:39 <Itkovian> aft'noon
05:47:45 <Philippa> calvin_: when you consider it's linking in an entire GUI lib it's understandable - the sizes you get for eg statically linked MFC apps under windows are comparable
05:48:48 <calvin_> sure, it's understandable.
05:52:25 <Philippa> and at least it's roughly-constant overhead
05:53:38 <calvin_> sort of
05:54:00 <Philippa> constant by lib features used, yeah
05:55:23 <calvin_> most of the demo apps end up at around 5.7MB, except for the gconf demo that ends up at 8.3MB.
05:55:29 <calvin_> oh well, it's not important. I was just curious.
06:07:49 <Lunar^> -fPIC will be in GHC 6.4
06:08:17 <Lunar^> putStrLn hello world is 8k with shared lib, which is really reasonable
06:10:16 <Lemmih> On other platforms than Mac?
06:10:42 <Lunar^> That what I use ;)
06:11:09 <Lunar^> I should dig through CVS changelog, but IIRC it was ported to x86
06:11:15 <Lunar^> I might be wrong, though
06:12:34 <Darius> Didn't they get it down with fiddling with the Evil Mangler?
06:14:44 * Lunar^ would like Wolfgang to show up in this channel sometimes
06:24:20 <TheHunter> grrr, damn joy interpreter...
06:27:38 <Darius> TheHunter: ?
06:28:21 <TheHunter> it comes in a tar.gz file that doesn't have its files in a subdirectory.
06:28:39 <CosmicRay> I hate those.
06:29:03 <TheHunter> anyway xargs rm was my friend (but if there was a file by the same name in my home dir, it's lost)
06:34:08 <TheHunter> i don't get it: factorial  ==  [0 =] [pop 1] [dup 1 - factorial *] ifte. How is this going to work (sorry for being off-topic)?
06:34:19 <CosmicRay> whoa.
06:34:39 <CosmicRay> uh, is that haskell? :-)
06:35:01 <TheHunter> it's joy.
06:36:50 <TheHunter> doesn't the [0 =] consume the parameter, so the pop should fail?
06:37:10 <Darius> No, ifte preserves it
06:37:29 <TheHunter> ah, ok. That's what I was missing, thanks.
06:39:07 <autrijus> yay for GHC survey
06:39:13 <autrijus> I learned parallel list comprehension there
06:39:18 <autrijus> and it's wonderful.
06:39:22 * autrijus throws zipWith* away
06:43:33 <Darius> @eval joy "6 [[pop 0 =] [pop pop 1] [[dup 1 -] dip x *] ifte] x"
06:44:19 <lambdabot> [720]
06:45:14 <pipe> @eval [1,2,3]
06:45:15 <lambdabot> [1, 2, 3]
06:45:21 <pipe> @eval [1,1,..]
06:45:22 <lambdabot> (line 1, column 6):
06:45:22 <lambdabot> unexpected "."
06:45:22 <lambdabot> expecting simple term
06:45:25 <pipe> @eval [1,1..]
06:45:26 <lambdabot> (line 1, column 6):
06:45:26 <lambdabot> unexpected "."
06:45:26 <lambdabot> expecting simple term
06:45:30 <pipe> @eval [1...]
06:45:30 <lambdabot> (line 1, column 4):
06:45:30 <lambdabot> unexpected "."
06:45:30 <lambdabot> expecting simple term
06:45:32 <pipe> @eval [1,...]
06:45:33 <lambdabot> (line 1, column 4):
06:45:34 <lambdabot> unexpected "."
06:45:35 <lambdabot> expecting simple term
06:45:40 <pipe> screw that :P
06:45:50 <pipe> @eval [1..10]
06:45:50 <lambdabot> (line 1, column 4):
06:45:50 <lambdabot> unexpected "."
06:45:50 <lambdabot> expecting simple term
06:45:53 <Darius> @eval take 10 $ from 1
06:45:53 <lambdabot> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
06:51:03 <nlv11757__> @eval take 5 (zipWith (\s i -> s ++ show i) (repeat "child") [1..])
06:51:03 <lambdabot> (line 1, column 59):
06:51:03 <lambdabot> unexpected "."
06:51:03 <lambdabot> expecting simple term
06:51:25 <nlv11757__> @eval (zipWith (\s i -> s ++ show i) (repeat "child") [1..10])
06:51:25 <lambdabot> (line 1, column 52):
06:51:25 <lambdabot> unexpected "."
06:51:25 <lambdabot> expecting simple term
06:51:40 <TheHunter> @eval take 5 (zipWith (\s i -> s ++ show i) (repeat "child") enumFrom 1)
06:51:41 <lambdabot> type error
06:51:52 <TheHunter> @eval take 5 (zipWith (\s i -> s ++ show i) (repeat "child") (enumFrom 1))
06:51:52 <nlv11757__> @eval take 5 (zipWith (\s i -> s ++ show i) (repeat "child") (from 1))
06:51:52 <lambdabot> unbound variable: show
06:51:53 <lambdabot> unbound variable: show
06:52:01 <Darius> @eval doesn't support [l..h] notation
06:52:01 <lambdabot> (line 1, column 20):
06:52:01 <lambdabot> unexpected "."
06:52:01 <lambdabot> expecting simple term
06:52:07 <Darius> And doesn't have type classes.
06:52:19 <Darius> @definitions show
06:52:20 <lambdabot> ["showList","showMaybe","showNum","showPair","showTerm","showTerm'","showType
06:52:20 <lambdabot> ]
06:52:20 <nlv11757__> so int2string?
06:52:35 <TheHunter> @eval take 5 (zipWith (\s i -> s ++ showNum i) (repeat "child") (enumFrom 1))
06:52:36 <lambdabot> [child1, child2, child3, child4, child5]
06:52:38 <nlv11757__> @eval (zipWith (\s i -> s ++ showNum i) (repeat "child") (from1))
06:52:39 <lambdabot> unbound variable: from1
06:52:41 <nlv11757__> @eval (zipWith (\s i -> s ++ showNum i) (repeat "child") (from 1))
06:52:48 <nlv11757__> yeah
06:52:50 <nlv11757__> thats it
06:53:15 <Darius> @eval take 5 (zipWith (\s i -> s ++ showNum i) (repeat "child") (from 1))
06:53:20 <lambdabot> out of fuel - use @resume to continue
06:53:21 <lambdabot> [child1, child2, child3, child4, child5]
06:53:46 <nlv11757__> kickass
06:57:14 <djo> is there any function which extracts integre from a String?
06:57:23 <Lunar^> @type read
06:57:25 <lambdabot> read :: forall a. (Read a) => String -> a
06:57:40 <Lunar^> Integer implements the Read class
06:57:40 <djo> thx
06:58:11 <Lunar^> @type read "x" `asTypeOf` 42
06:58:13 <lambdabot> read "x" `asTypeOf` 42 :: forall a. (Read a, Num a) => a
06:58:18 <Lunar^> oops
06:58:23 * Lunar^ is messing it
06:58:32 <nlv11757__> the context forces it into the right type
06:58:50 <nlv11757__> of course you can force it manually by :: Int
06:59:21 <Lunar^> nlv11757__: I wanted to make a type like (String -> Integer) appear
06:59:39 <Lunar^> nlv11757__: But I can't find any interesting way here
06:59:40 <Darius> @type \n -> read n :: Int
06:59:42 <lambdabot> \n -> read n :: Int :: String -> Int
07:00:03 <Lunar^> Darius: thanks! :)
07:00:11 <TheHunter> @type read `asTypeOf` length
07:00:13 <lambdabot> read `asTypeOf` length :: String -> Int
07:01:21 <Darius> @type (3 :: Int) :: Int
07:01:23 <lambdabot> (3 :: Int) :: Int :: Int
07:08:57 <Darius> @type 3 :: Int :: Int
07:08:59 <lambdabot> bzzt
07:09:33 <nlv11757__> @type (id :: String -> String)
07:09:35 <lambdabot> (id :: String -> String) :: String -> String
07:09:39 <nlv11757__> :P
07:09:55 <nlv11757__> @type (id :: (String -> String) -> (String -> String))
07:09:57 <lambdabot> (id :: (String -> String) -> (String -> String)) :: (String
07:09:57 <lambdabot> 						     -> String)
07:09:57 <lambdabot> 						    -> String -> String
07:43:57 * boegel yawns
07:49:30 <tromp> @type List.lookup
07:49:32 <lambdabot> List.lookup :: forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
07:49:58 <u1sf> I've got a question, is it possible to implement a fully static Union type in Haskell, while retaining decidability?
07:51:47 <Darius> u1sf: You mean is it possible to add union types to Haskell's type system and keep some of its nice properties?
07:51:56 <musasabi> u1sf: I don't think so if I understand "fully static" right. I don't believe that can be done in any language.
07:52:33 <musasabi> what do you mean by the term?
07:52:36 <nlv11757__> using guards within a case is probably not allowed?
07:52:45 <Darius> It is allowed.
07:52:47 <musasabi> nlv11757__: it is allower.
07:52:49 <musasabi> *ed
07:52:50 <nlv11757__> nice
07:53:05 <nlv11757__> case xs of [] | True -> ....
07:53:08 <nlv11757__> that kind of thing?
07:53:13 <musasabi> yes.
07:53:17 <nlv11757__> totally sweet
07:55:49 <u1sf> musasabi: By static, I mean that it is possible to determine exactly what the Union contains, such that it can be serialized/deserialized. For example Dynamic can be seen as a Union of Typeables, but you can't serialize or deserialize a Dynamic, unless it is type guarded.
07:57:28 <kosmikus> u1sf: so then, why doesn't a normal Haskell union using | qualify?
07:57:51 <u1sf> because it is based on constructor rather than type
07:59:01 <u1sf> if you have a union of X,Y and Z, adding a constructor to each adds irrelevant information
07:59:26 <u1sf> plus, if I'm trying to automatically map types, I can't go about creating a new type for every Union possibility
08:00:51 <Itkovian> cu #haskell
08:01:00 <kosmikus> well, you can use nested Either
08:01:14 <Darius> Can X and Y be the same?
08:01:41 <kosmikus> but I don't see yet why you could ever throw away the constructors
08:04:21 <u1sf> the problem with nested Either is the types created are not regular, and you cannot statically guarantee what an Either contains without undecidable instances
08:05:28 <musasabi> u1sf: data MyUnion = forall a. Binary a, Typeable a => a
08:05:32 <Darius> You can easily statically guarantee what a type contains by simply using that type.
08:05:44 <musasabi> u1sf: deserialization is a hard problem.
08:05:55 <Darius> u1sf: Where does "union" come into what you are trynig to do?
08:06:08 <musasabi> u1sf: e.g. if the communicating systems have different idea what the type Foo is.
08:06:51 <u1sf> yes, which is why we use XML Schema to provide a platform independant description of a type
08:07:23 <TheHunter> u1sf, you can probably get around undecidable instances by delimiting your sum with a special Empty type, as the HNil in the HList library.
08:07:24 <musasabi> u1sf: how does this help?
08:07:51 <musasabi> u1sf: you still have a problem if the types differ.
08:07:59 <TheHunter> (talking about nested Eithers, that is)
08:08:14 <musasabi> u1sf: 1:1 type mapping is not impossible,
08:08:42 <musasabi> I would just use TH to get the data definition - ship that and compare that on the remote side to it's definition.
08:09:10 <u1sf> musasabi: Suppose we're not communicating with a Haskell endpoint
08:10:38 <musasabi> u1sf: then you want to create a mapping from haskell values to an external representation on the sending side... and generating a general enough description can be nontrivial.
08:10:52 <musasabi> u1sf: e.g. cyclic structures can pose problems.
08:10:58 <u1sf> yes; XML
08:11:01 <musasabi> s/pose/create
08:11:10 <u1sf> XML provides built in support for cyclic structures
08:11:22 <u1sf> ID/REF pairs
08:11:39 <musasabi> u1sf: but the haskell side is nontrivial.
08:11:46 <u1sf> true
08:11:52 <musasabi> u1sf: because every String is potentially cyclic..
08:12:28 <wilx> Hmm....
08:12:38 <u1sf> yes, but in practise they can't be if typing with XSD
08:12:39 <wilx> I have a text file. Fairly large one.
08:12:51 <musasabi> u1sf: hmm?
08:13:13 <wilx> Is there a way to mmap() it as a string to memory and operate on it in GHC?
08:13:25 <u1sf> if you constraint your type structures as to how XML Schema defines them, a String must terminate
08:13:33 <musasabi> wilx: you could use FastPackedString from darcs.
08:14:01 <musasabi> u1sf: how would you type a terminating string in haskell?
08:15:00 <musasabi> haskelldb handles typing strings of some finite length, but termination seems much harder.
08:15:30 <u1sf> sorry, that's what I mean
08:16:48 <musasabi> u1sf: but doesn't that limit the serializer quite a bit - or the limit will be so large that it does not really help.
08:18:05 <u1sf> nm
08:34:34 * Lunar^ jumps
08:34:42 <Lunar^> Directory Kernel/Driver/NE2000
08:34:43 <Lunar^> damn
08:34:45 <Lunar^> damn damn damn
08:37:10 <Lunar^> OGI people added Network support to hOp !
08:49:57 <nlv11757__> if you read file contents out of a handle into a string, then close the handle, do you still have the string?
08:50:07 <nlv11757__> or does it vanish with the closing of the handle
08:51:20 <Darius> If you use lazy IO bad things happen, but otherwise a String's a String.
08:51:35 <autrijus> s/lazy/unsafe/
08:51:53 <nlv11757__> im using openFile and hGetContents and hClose
08:51:55 <nlv11757__> that's it
08:52:05 <nlv11757__> then i continue with the string
08:52:12 <Lemmih> nlv11757__: Why not just use readFile?
08:52:24 <nlv11757__> because i only process a portion of the file
08:52:33 <autrijus> well then you just process a portion of the string.
08:52:37 <nlv11757__> the begin and endlines are cmdline arguments
08:52:39 <Lemmih> nlv11757__: readFile is lazy.
08:53:14 <nlv11757__> openFile etc is not?
08:54:22 <Lemmih> hGetContents is.
08:54:45 <nlv11757__> i have to get a fixed nr of lines, so since IO offered hGetLine, i reckoned this was the best way to go
08:55:45 <Darius> That should work, but I think hGetLine and replicateM might be a better way to go.
08:56:39 <earthy> ummm...
08:57:34 <Lunar^> Damn, where's shapr?
08:57:57 <CosmicRay> Lunar^: can we help you?
08:58:01 <nlv11757__> i am using hGetLine Darius
08:58:06 <CosmicRay> I know we are peons compared to the great shapr
08:58:08 <CosmicRay> but we can try :-)
08:58:37 * earthy notes that hGetLine returns an IO String
08:58:42 <Darius> nlv11757__: I misread what you wrote.
08:59:02 <nlv11757__> i confused people by using hGetContents in a sentence earlier
08:59:03 <Lunar^> CosmicRay: I want to see him bouncing with me looking at the NE2000 driver code
08:59:11 <Lunar^> CosmicRay: it's amazing
08:59:20 <CosmicRay> the ne2000 code is amazing?
08:59:24 <CosmicRay> does anybody use those anymore? :-)
08:59:28 <nlv11757__> so why would the use of replicateM be better?
08:59:38 <earthy> and due to IO sequencing the instructions for you there is no reason to worry about the handle being closed and you not having access to the String anymore
08:59:45 <Lunar^> CosmicRay: http://www.cse.ogi.edu/~hallgren/House/kernel/pfe.cgi?Kernel.Driver.NE2000.Driver
08:59:56 <Lunar^> CosmicRay: In Haskell!
08:59:57 <metaperl> CosmicRay, what is the name of that place you mentioned that also does IRC services? it was osft.net or something?
08:59:58 <CosmicRay> ah.
09:00:04 <CosmicRay> metaperl: oftc.net
09:00:16 <nlv11757__> earthy: so what you are saying, is that i can close the handle and then still access the string i obtained by doing hGetLine?
09:00:38 <earthy> yes
09:00:43 <CosmicRay> Lunar^: you're right.  you do need shapr. :-)
09:00:45 <nlv11757__> nice, thanx
09:00:54 * earthy doesn't see the problem
09:00:57 <Darius> nlv11757__: There's nothing particular about replicateM it just seems like the easiest way to do what you want.
09:01:16 <earthy> open file, read string into memory, close file, deal with string in memory...
09:01:22 <CosmicRay> this is a nifty syntax highlighting cgi script too
09:01:50 <CosmicRay> earthy: that sounds like a recipe for hGetContents
09:02:13 <earthy> cosmicRay: not if you don't need all the lines in the file
09:02:16 <Lunar^> CosmicRay: :)
09:02:21 <earthy> then a number of hGetLine's will suffice
09:02:38 <nlv11757__> @type replicateM
09:02:40 <lambdabot> bzzt
09:02:47 <CosmicRay> earthy: or, take n . lines . c, where c <- hGetContents
09:02:54 <CosmicRay> that seems so much easier to me.
09:02:58 <CosmicRay> err
09:03:04 <CosmicRay> take n . lines $ c
09:03:26 <nlv11757__> i don't see how that is easier then doing a couple of hGetLines
09:03:37 <CosmicRay> well ok, if it's 2, it's not.
09:03:54 <nlv11757__> i have a recursive function that gets me the amount of lines i want
09:04:02 <nlv11757__> it uses hGetLine
09:04:46 <Darius> @type Control.Monad.replicateM
09:04:47 <lambdabot> Control.Monad.replicateM :: forall a m.
09:04:47 <lambdabot> 			    (Monad m) =>
09:04:47 <lambdabot> 			    Int -> m a -> m [a]
09:05:00 <CosmicRay> recursive IO functions are difficult to get right with laziness
09:05:12 <CosmicRay> nlv11757__: use replicateM if you could.
09:05:31 <Darius> CosmicRay: ?
09:05:31 <CosmicRay> however, neither approach will scale.
09:05:46 <CosmicRay> let's say that instead of reading 2 lines, you want to read 5000.
09:05:55 <CosmicRay> you will load all of this into memory at once.
09:05:57 <nlv11757__> ok now i want to now what replicateM does
09:06:18 <CosmicRay> haskell is lazy, so you wouldn't really have to.
09:06:28 <CosmicRay> that's why I suggest (take n . lines)
09:06:40 <CosmicRay> nlv11757__: use the source, luke:
09:06:46 <Darius> replicateM 3 m = do a <- m; b <- m; c <- m; return [a,b,c]
09:06:47 <CosmicRay> replicateM        :: (Monad m) => Int -> m a -> m [a]
09:06:48 <CosmicRay> replicateM n x    = sequence (replicate n x)
09:06:53 <nlv11757__> doing hGetLine n times is not different from what you do is it?
09:07:04 <CosmicRay> yes, it is.
09:07:12 <nlv11757__> why
09:07:21 <CosmicRay> you are recursively calling your function that returns IO [String], yes?
09:07:22 <Darius> nlv11757__: What are you going to do with the lines you read in?
09:07:46 <nlv11757__> cosmicray: yes
09:08:10 <CosmicRay> nlv11757__: OK.  So when Haskell wishes to evaluate the result of the function, it must immediately traverse down as far as possible
09:08:11 <nlv11757__> darius: i will parse them into a datatype and do attribute grammar stuff
09:08:21 <CosmicRay> nlv11757__: which means reading in all the desired lines into memory then and there.
09:08:30 <CosmicRay> nlv11757__: essentially, you do not get a lazy return value.
09:08:44 <CosmicRay> nlv11757__: if you instead use a solution based on hGetContents, you get a lazy result
09:08:55 <CosmicRay> nlv11757__: each line in the result will be read from disk only when it is demanded in the program
09:09:21 <nlv11757__> so in that case i shouldnt close the handle until im finished with whatever im doing with those lines right?
09:09:24 <CosmicRay> nlv11757__: so you could just as easily ask for 5000 lines -- assuming your algorithm doesn't need to keep old lines around, it will use up no more memory than 1 line
09:09:36 <CosmicRay> nlv11757__: in your case, asking for 5000 lines will consume far more memory
09:09:52 <CosmicRay> nlv11757__: correct
09:09:56 <nlv11757__> ok i assumed that if hGetContents was lazy, so would hGetLine be
09:10:16 <Darius> CosmicRay: But if nlv11757__ builds the data structure then closes the file if the data structure isn't fully evaluated parts could be missing.
09:10:19 <earthy> nlv11757__: in that case, the IO monad will make sure that the lazy reads *all* get scheduled before the file is closed, if I understand correctly
09:10:44 <earthy> as the hGetContents call is placed before the call that closes the file
09:10:46 <CosmicRay> earthy may b ecorrect, I'd have to re-visit the api docs on that.
09:10:50 <Darius> nlv11757__: It doesn't really make sense for hGetLine to be lazy.
09:11:08 <nlv11757__> lazy line processing :P
09:11:15 <nlv11757__> for realllly small memories :P
09:11:23 <CosmicRay> nlv11757__: even if hGetLine was lazy, it wouldn't matter for your program, since you are doing recursive I/O
09:11:30 <CosmicRay> you'd have to evaluate it all to produce a return value anyway
09:11:41 <nlv11757__> doing <- forces that?
09:11:43 <CosmicRay> unless you discover unsafeInterleaveIO, but really, that is best left un-discovered :-)
09:12:00 <earthy> unsafeInterleaveIO is the devil's spawn.
09:12:06 <CosmicRay> no, but you return an IO action whose value depends on another IO action (that which you get by recursively calling yourself)
09:12:19 <Darius> nlv11757__: It doesn't make sense for hGetLine to be lazy because it needs to read up to the newline anyways.
09:12:24 <CosmicRay> so when haskell wishes to evaluate the IO action, it must evaluate all that actions that it depends upon
09:12:54 <nlv11757__> why not only evaluate the io actions needed for that bit of string?
09:13:24 <nlv11757__> darius: i see
09:13:27 <CosmicRay> nlv11757__: an IO action cannot be partially evaluated
09:13:47 <CosmicRay> the exception is hGetContents and thigns that use unsafeInterleaveIO
09:13:54 <nlv11757__> ow ok, and since the toplevel IO action is being evaluated...everything is being evaluated right?
09:13:58 <CosmicRay> you should really not use the latter unless you have a clear need for it, which you don't here
09:14:01 <earthy> `Computation hGetContents returns the list of characters corresponding to the unread portion of the channel or file managed by , which is made semi-closed. ' -- The Haskell 98 report
09:14:01 <CosmicRay> nlv11757__: exactly
09:14:20 <earthy> how it is implemented is left to the compiler's implementor. :)
09:14:28 <nlv11757__> :O
09:14:29 <nlv11757__> hmmm
09:14:30 <nlv11757__> hehe
09:14:33 * CosmicRay goes to lunch
09:14:47 <earthy> so, yes, you are guaranteed all input, and nothing on whether or not it is read lazily
09:14:47 <nlv11757__> k thanx cosmic for the help
09:15:12 <nlv11757__> ah ok, thats what i wanted to know :) thanx to you also earthy
09:15:23 <nlv11757__> i'll look into that replicateM later
09:15:26 <earthy> ;)
09:15:38 <nlv11757__> after my chinese food :P
09:15:54 <earthy> hm. food.
09:16:05 <earthy> I'll need to make me some of that stuff...
09:16:12 <nlv11757__> :) i still have to make it of course, thats why im leaving work NOW :)
09:16:15 <earthy> better go home and start doing it. :P
09:16:25 <nlv11757__> my thoughts exactly
09:16:28 <nlv11757__> cu all later
09:16:31 <earthy> or I could go to 3c...hmm...
09:16:33 <earthy> nah. :P
09:16:39 <nlv11757__> :)
09:16:56 <earthy> wouldn't be fair to my gf... then she'd be stuck without any food
09:17:12 <nlv11757__> hahah i would call that tough luck
09:17:48 <nlv11757__> is 3c in the library already?
09:17:54 <nlv11757__> or still in its old spot?
09:18:43 <earthy> nope, it opened in the library yesterday
09:19:07 <earthy> and was closed last monday
09:19:09 <nlv11757__> damn, you have to actually walk all the way into the library, what a bad place for 3c
09:19:29 <earthy> actually, it is across from the spar
09:19:33 <nlv11757__> i know :P
09:19:38 <nlv11757__> but it's soooo far away
09:19:44 <earthy> but it's more than twice as far as it used to be, yes.
09:19:59 <nlv11757__> I don't feel comfortable eating pizza and stuff in the library :P
09:20:23 <earthy> well, I'd just buy the pizza and ride home
09:20:37 <earthy> but I live less then 10 minutes away
09:21:01 <nlv11757__> owww
09:22:54 <nlv11757__> anyways, all this talking about food makes me want it :) so im off
09:22:57 <nlv11757__> later
09:34:43 <bourbaki> moin
09:36:52 <boegel> heu bourbaki
09:36:56 <boegel> s/heu/hey
09:46:56 <Oeje1> Hej, bourbaki.
09:47:45 <bourbaki> Oeje1: hey do i know you:)?
09:51:18 <Oeje1> bourbaki: No, but if I don't say hello, you might never know me.
09:52:19 <bourbaki> hellp
09:52:22 <bourbaki> hello :)
09:53:48 <wilx> Hmm, hGetContents is lazy, can I force it to load the whole file at once?
09:54:09 <earthy> why would you want that?
09:54:35 <Heffalum1> use DeepSeq
09:54:47 <Heffalum1> I had to do that for some reason, I forget what.
09:55:25 <SyntaxNinja> hmm.  where's the REAL Heffalump
09:55:28 <wilx> earthy, because I suspect that the IO I dominates my run time.
09:55:51 <wilx> Err, ...that the IO I do dominates...
09:56:09 <Heffalum1> if you want exceptions to happen at the time you do an action, you really need to force evaluation
09:56:12 <Heffalum1> I've found myself doing that a lot.
09:56:19 <earthy> and doing all IO at once would help how?
09:56:46 <earthy> (trust me, I know about buffering in OSs, I just want to hear you say it :))
09:57:35 <wilx> The userland/kernel transition is not for free.
09:57:39 <TheHunter> wilx, or use "last contents `seq` ..."
09:57:49 <wilx> I just want to try and benchmark if it gets better.
09:58:08 <earthy> ah. right
09:58:21 <earthy> (you do realize this will penalize you on GC, right?)
09:58:55 <wilx> Memory issues are not important at this phase :)
09:58:56 <wilx> cont <- hGetContents input
09:58:56 <wilx>     inputList <- cont `seq` return $ lines cont
09:59:01 <wilx> So far I did this.
09:59:14 <wilx> But it doesn't seem to help.
09:59:25 <wilx> MAybe I get the meaning of seq wrong...
09:59:25 <TheHunter> wilx, inputList <- last cont `seq` return $ lines cont
09:59:53 <earthy> wilx: GC takes time. :P
10:00:17 <TheHunter> seq forces only whnf, so if after seq'ing a list, you only know wheter it is empty or not.
10:00:45 <wilx> Oh.
10:00:48 <earthy> anyway, knife-wielding time
10:00:54 <wilx> Eeek!
10:01:00 * wilx runs for cover
10:01:14 <earthy> don't worry. I'm only going to chop a leek and some shrooms
10:01:22 <wilx> :)
10:25:41 <xerox> hiya.
10:30:55 <Darius> Isn't there a strict readFile?
12:13:29 <elux> hi
12:13:36 <elux> would it be possible to write a c compiler in haskell?
12:13:42 <SyntaxNinja> yes
12:13:51 <elux> how would you handle pointers in c though?
12:13:54 <elux> er
12:14:01 <elux> handle pointers in c, within haskell
12:14:03 <elux> when compiling the code
12:14:20 <elux> can you get the "address of" in haskell?
12:14:34 <integral> why would you need to?   You're not evaluating the pointers when you compile the C
12:14:49 <wagle> gcc turns pointers into int's almost immediately when compiling
12:14:53 <elux> well when i go from c->asm
12:15:23 <wagle> .. but what integral said
12:15:27 <elux> so haskell would parse the c, check for errors .. do semantic analysis .. code generation (generate asm)
12:16:15 <elux> lexer->parser->check semantics->code generation
12:16:22 <wagle> i'm not sure what the question is
12:16:39 <elux> i just wasnt sure i would handle pointers when writing the compiler
12:16:39 <elux> thats all
12:16:51 <elux> i know how to parse and check semantics .. but not generate the code when dealing with pointers in c
12:17:09 <SyntaxNinja> you don't need pointers in Haskell to represent pointers in C, right?
12:17:15 <elux> correct
12:17:18 <elux> just int
12:17:22 <elux> gotcha.  thanks
12:17:28 <wagle> mov (reg) to loc
12:17:53 <SyntaxNinja> elux: you just need to represent the code that manages the pointers, as wagle is pointing out.
12:18:34 <wagle> you are writing a asm program, not running it
12:18:54 <wagle> umm
12:19:20 <wagle> you are writing a program that writes an asm program....
12:19:33 <elux> right
12:19:46 <wagle> no pointers actually get dereferenced
12:21:01 <CosmicRay> wait, are you suggesting storing a pointer in an int?
12:21:04 <CosmicRay> that is *not* valid
12:24:03 <elux> .. whats the correct way to handle it then?
12:25:06 <mflux> let's say you want to generate the assembler for code such as { int a; int* b = &a; *b = 42; } - no actual pointer values will be handled in the code generator
12:25:40 <mflux> they would be handled in the case of code such as int* b = (int*) 42, but that would be just like any other kind of value
12:26:35 <elux> i dont even know if you can do int* b = (int*) 42;
12:27:08 <mflux> it's valid c code
12:27:34 <mflux> maybe even useful in some low level stuff
12:28:48 <wagle> i was more expressing my past frustration that gcc forgot that something was a function pointer (or ANY sort of pointer) at the first possible opportunity..  this was supposed to illustrate that the compiler need not treat pointers as being special..  it wasnt supposed to mean that "int" was the preferred representation
12:30:20 * wagle heads off for lunch
12:44:26 <desrt> heh
12:44:28 <desrt> hello, elux
13:08:00 <elux_> have you guys heard of ML ?
13:08:23 <Heffalum1> nope.
13:13:06 <earthy> Mwhat? :P
13:14:21 <Oejet> elux: What is ML?
13:14:51 <elux> functional language
13:15:04 <elux> similar to haskell
13:15:10 <Heffalump> why not just use Haskell
13:15:19 <elux> lol
13:15:25 <elux> i dont know enough about ML to comment
13:15:35 <Darius> If ML were called MN would 'a list be written list a?
13:15:39 <Heffalump> it's not like anyone might want strict evaluation, no indentation, a functor system or anything, is it?
13:16:00 <Darius> Heffalump: Not when they could get all that and more in Haskell.
13:16:06 <Oejet> elux: Like this http://www.it.dtu.dk/introSML/ ?
13:16:28 * Heffalump would like to see Darius adding a functor system to Haskell
13:16:53 <Heffalump> and avoiding the indentation rule enough to get helpful error messages
13:17:20 <earthy> oooh, and strict references... :P
13:17:48 <earthy> and a neatly extensible exception system that is not tied to IO
13:17:50 <earthy> :P
13:18:05 <Darius> Heffalump: Oleg already did.  {}'s can be added for the second.
13:18:15 <Heffalump> no, they can't
13:18:35 <Heffalump> you still get error messages which are bad because of the indentation rule if you do
13:18:46 <Darius> earthy: Extensible exceptions can be done too
13:18:53 <earthy> yeah, I know
13:19:08 <earthy> they just aren't in the standard libs
13:19:25 <Darius> Now get ML to do type classes, lazy evaluation, cyclic immutable data structures.
13:19:53 <Darius> And gah the syntax!
13:19:56 <earthy> welll.... there is this somewhat impressive thingy called ML_F...
13:20:18 <earthy> or was that ML^F? :)
13:21:01 <earthy> anyway, yeah, Haskell is much, much nicer.
13:22:11 <Heffalump> did Oleg add functors properly, or via a type class hack?
13:22:24 <Darius> Heffalump: It's Oleg.
13:22:25 <earthy> what do you think. :P
13:22:48 * boegel boings
13:23:05 <Heffalump> that doesn't count, then :-)
13:23:07 <Darius> Actually higher rank polymorphism is the thing needed, the type class hackery is just sugaring.
13:23:53 * earthy nods
13:24:09 <earthy> and even then it tastes somewhat bitter
13:24:43 <Darius> Oleg thought it relatively idiomatic and at any rate it's more expressive than ML functors.
13:24:58 <earthy> true
13:29:32 <earthy> but the approach had its drawbacks
13:29:34 <earthy> ISTR
13:46:21 <xerox> Where can I find an example usage of Either?
13:48:47 <Oejet> data Either a b = Left a | Right b
13:49:30 <Oejet> f (Left 5) = "42"
13:49:30 <Oejet> f (Right "abekat") = "43"
13:49:51 <boegel> xerox: http://www.nomaware.com/monads/html/errormonad.html#example
13:50:07 <xerox> boegel, I can't understand that :\
13:52:52 <xerox> Thank you all.
13:54:27 <Oejet> xerox: Do you understand the Maybe type?
13:54:31 <pesco> Now that's a quote!
13:54:32 <pesco> I believe in gun control, legal abortion, formal methods and declarative programming.
13:54:36 <xerox> Yep.
13:54:50 <xerox> Oejet, yep.
13:54:58 <pesco>     -- FrankChristoph
13:55:03 <xerox> pesco, eheh.
13:55:20 <Steve_p> Is the Error monad a standard part of Haskell or is it an addon?
13:55:40 <xerox> Steve_p, seems to be standard.
13:55:46 <Oejet> Maybe you can think of Either as Maybe, where Nothing also can carry a value.
13:56:08 <Steve_p> Hmmm
13:56:13 <Darius> Steve_p: A monad instance for Error is not standard.
13:56:22 <Darius> er Either
13:56:49 <Darius> Steve_p: But of course, it's trivial to add it.
13:57:42 <Steve_p> OK, its part of GHC then?
13:59:16 <Oejet> xerox: So I would think the Error monad  works in the same way as the Maybe monad; that is propagating a value and returning when some trouble occured.
13:59:39 <Darius> Steve_p: In the heirarchical libraries, Control.Monad.Error contains an instance declaration for it (I'm pretty sure).
14:00:13 <xerox> Oejet, can I pm flood you with 6 lines?
14:00:33 <xerox> ..hmm maybe more.
14:01:22 <Steve_p> That's what it looked like.  OK, cool!  Thanks Darius :)
14:02:13 <xerox> Oejet, I did a very little thing with Maybe, I'm trying to port it to Either but unsucsessfully.
14:06:22 <xerox> Why it doesn't work? f x | x < 0 = Left x | otherwise = Right x
14:06:53 <xerox> Whoops, it works.
14:10:51 <xerox>     No instance for (Monad (Either [Char]))
14:10:57 <xerox> What does it mean exactly?
14:12:49 <xerox> Ah okay, just needed import Control.Monad.Error btw It's not so clear.
14:16:48 <xerox> Goodnight people (I think I worked it out)
14:18:19 <Oejet> xerox: Great.
14:18:24 <Oejet> Good night.
14:18:58 <boegel> bye xerox !
15:28:48 <boegel> it's _really_ quiet in here
15:29:09 * SyntaxNinja nods
15:29:41 <Muad_Dibber> boegel : you do know what time it is yeah? :P
15:30:08 <boegel> yeah, so ? other nights it's really active here
15:31:16 <Muad_Dibber> hehe
15:31:22 <Muad_Dibber> well, i'm going to see how active my bed its :)
15:31:23 <Muad_Dibber> *is
15:31:24 <SyntaxNinja> it's the middle of the afternoon, what are you talking about
15:31:24 <Muad_Dibber> ciao :)
15:31:30 <SyntaxNinja> Muad_Dibber: good luck
15:33:02 <dons> hmm. it's 10am in the morning. all you guys are nuts
15:35:17 <Lunar^> dons: Have you seen the network stack recently added to House by OGI people ?
15:36:15 <dons> huh. no. sounds cool.
15:36:56 <dons> a .hs network stack, I presume?
15:37:10 <Heffalump> oh, cool.
15:38:54 <boegel> dons, I'm not nuts, you should set your clock right :p
15:39:43 <Heffalump> yeah, GMT rules
15:39:46 <djo> hi guys
15:39:51 <boegel> hi djo
15:41:25 <dons> bah on GMT
15:42:09 <boegel> Heffalump: GMT+1 rules even more ;)
15:42:13 <mwc> Can somebody point me at a good conceptual book on functional programming? I'm looking for something like Design Patterns is for OO ideas
15:42:13 <dons> GMT is always 11 hours wrong in my opinion ;)
15:42:16 <boegel> 'cause it's more, you see
15:42:24 <Lemmih> boegel: I second that.
15:42:56 * boegel wraps his arm around Lemmih and says: "Yeah, we are a team"
15:43:00 <boegel> *cough
15:43:12 <SyntaxNinja> would you guys say that mutable arrays are a standard efficiency strategy for haskell?
15:43:25 <dons> yes.
15:43:34 * Heffalump tries to boot the House demo in VMware and gets grub (I think) complaining about mode 117 not being supported :-(
15:43:47 <SyntaxNinja> mwc: there's a book on "Purely Functional Data Structures" by that name...
15:44:28 <Lemmih> boegel: Team (succ gmt).
15:44:43 <boegel> Lemmih: yeah !
15:44:44 <SyntaxNinja> mwc: I'm not sure if there's a similar concept to "Design patterns"... lots of design patterns are just weaknesses in OO languages anyway.
15:44:51 <mwc> Well, I'm kind of looking for something that will show me how to use functional programming effectively
15:45:01 <SyntaxNinja> mwc: right.
15:45:12 <Lunar^> dons: Yeah
15:45:33 <mwc> well, I ment that the infamous design patterns book sort of laid out how to do OO right, and move beyond procedural code
15:45:37 <SyntaxNinja> mwc: Lots of books that teach functional programming take that sort of approach. I don't know of anything that is kinda generic, though.
15:45:43 <Lunar^> dons: http://www.cse.ogi.edu/~hallgren/House/kernel/pfe.cgi?Net.IPv4
15:46:12 <boegel> @wiki TeamSuccGMT
15:46:12 <lambdabot> http://www.haskell.org/hawiki/TeamSuccGMT
15:46:34 <SyntaxNinja> mwc: "The Structure and Interpretation of Computer Programs", "The Haskell School of Expression", "Haskell: The Craft of Functional Programming"
15:46:41 <boegel> Lemmih: ^
15:47:10 <Lemmih> heh (:
15:47:28 <mwc> SyntaxNinja, yeah, I've done an amazon search... but I was looking for a "customer" review
15:47:32 <SyntaxNinja> mwc: those books try to teach best practices of functional programming and concepts along with the language.
15:47:34 <boegel> any suggestions for our next meeting ? as in activities ? (:
15:47:41 <mwc> Have you read and recommend them?
15:48:10 <SyntaxNinja> mwc: yes, I recommend them.  I wrote a slashdot review of "The haskell school of expression" which google will find for you
15:48:28 <mwc> Excellent
15:48:38 <SyntaxNinja> I've looked at Craft a lot but didn't read it completely.  looks good to me.
15:48:48 <dons> Lunar^: this is so cool! instance Functor Packet .. :)
15:48:58 <SyntaxNinja> SICP is out there on the net for free so you can get an idea o fit.
15:49:24 <mwc> I'll look into it
15:49:39 <Lunar^> dons: Yeah!
15:49:50 <Lunar^> dons: There a NE2000 monad around ;)
15:50:40 <boegel> hey CosmicRay
15:50:44 <dons> it's such a clean way to do bit fiddling. very nice.
15:50:55 <CosmicRay> hi boegel
15:51:02 <boegel> want to join Team (succ gmt) ?
15:51:03 <boegel> :p
15:51:58 <dons> ooh. what's this L4 stuff?
15:52:05 <dons> L4 the u-kernel?
15:52:09 <Lunar^> dons: :)
15:52:13 <Lunar^> dons: dunno
15:52:34 <Lunar^> dons: Maybe they now run GHC RTS on top of L4
15:52:46 <dons> that would be also super-cool
15:57:43 <Lunar^> I fear that this network stack will never be usable
15:57:54 <Lunar^> seems to do a lot of copying at first sight
15:58:01 <dons> ah. ok.
15:59:40 <Lunar^> The FoxNet people had to hack the SML compiler
16:00:09 <Lunar^> I dunno
16:00:18 <Lunar^> That needs profiling and benchmarking anyway
16:00:30 <Lunar^> And in anycase, it's such a clean implementation
16:01:10 <dons> yep.
16:01:30 <dons> the OS guys here already use Haskell to prototype data structures for L4 tweaks
16:03:27 <Lunar^> Are you kidding?
16:03:36 <Lunar^> Is there any webpage describing that?
16:03:44 <dons> let me see..
16:04:07 * Lunar^ is happily gathering any informations about crossing interesting programming languages and OS
16:05:29 <dons> couldn't find a link, but it was this guy http://www.cse.unsw.edu.au/~awiggins/
16:05:37 <Lunar^> thanks
16:05:56 <Lunar^> damn
16:06:00 <Lunar^> Jef Raskin died
16:08:33 <boegel> Lunar^: who was he ?
16:10:09 <Lunar^> boegel: designer of the Macintosh
16:10:24 <Lunar^> boegel: among others
16:10:37 <boegel> oh, but hasn't he died a while ago ?
16:10:55 <Lunar^> I'm catching up the news
16:11:01 <Lunar^> it was 26th feb
16:12:08 <SyntaxNinja> dons: I'm a little confused about the relationship between the Binary class and the Storable class. any enlightening ideas?
16:12:36 <SyntaxNinja> I know that the binary class is not in the official library, and that storable is compatible with C
16:13:38 <dons> hmm. I need to check Storable again..
16:13:46 <SyntaxNinja> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Storable.html#t%3AStorable
16:14:12 <SyntaxNinja> and also:
16:14:14 <SyntaxNinja> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.Storable.html#t%3AStorableArray
16:14:51 <SyntaxNinja> it looks like Binary could us the Storable array instead of the IOUArray if it wanted to; they're both instances of MArray
16:15:00 <SyntaxNinja> I don't think the conversion is completely trivial, but probably not hard.
16:15:04 <dons> ok. Binary lets you write C-level representations to handles, Storable lets you write to memory, yeah?
16:15:07 <SyntaxNinja> by which I mean an hour or something
16:15:23 <dons> but I do think that Binary could be implemented in terms of Storable.
16:15:52 <SyntaxNinja> yeah, at least binary arrays...
16:16:52 <dons> and Storable is more general, whilst Binary is a very specific interface, providing only get and put, with no sizeOf, for example.
16:16:55 <SyntaxNinja> I suppose that binary is more efficient, since it says that IOUArrays are more efficient than storable arrays
16:17:33 <dons> yeah, they're raw bytes
16:18:08 <SyntaxNinja> I actually added size for binary arrays (layered on IOUArrays) to the Binary interface
16:18:18 <SyntaxNinja> but of course it won't work for file handles
16:18:32 <dons> I would think we could add get and put to the Storable class fairly easily
16:19:03 <boegel> @seen shapr
16:19:04 <lambdabot> I saw shapr leaving #haskell 1 day 5 hours 41 minutes 51 seconds ago.
16:20:20 <dons> hmm. Binary is more space efficient it seems. Bool is 8 bits, whilst in Storable it is an int
16:20:28 <dons> Binary also uses string tables
16:20:35 <SyntaxNinja> I guess we couldn't implement size for arbitrary handles though, so we couldn't use the storable interface instead of the binary interface
16:21:15 <dons> hmm.
16:29:18 <SyntaxNinja> someone said there was a lot of discussion about binary IO on some lists, any idea when / where that was?
16:31:04 <dons> hmm. last year sometime. I think on libraries, or haskell-cafe.
16:31:09 <SyntaxNinja> OK
16:38:42 * boegel is going to take a nap
16:38:46 <boegel> bye everyone !
17:23:28 <Xeo^Gunner> hi, can someone help me with a simple haskell prog?
17:24:02 <Cale> Xeo^Gunner: sure
17:24:59 <stepcut> Xeo^Gunner: how about, main = putStrLn "Hello, World!"
17:25:23 <Xeo^Gunner> no semi colons :(
17:25:58 <heatsink> Xeo^Gunner: you can add some semicolons if it makes you happy.
17:26:56 <Xeo^Gunner> yay :)
17:36:10 <SyntaxNinja> haha
18:24:47 <Sonarman> say i have: divs x = [n | n <- [1..x], x `mod` n == 0]
18:25:03 <Sonarman> actually, nevermind. sorry
18:25:09 <heatsink> okay...
18:25:27 <heatsink> I'm trying to make a general-purpose class to implement uniqueness types with arrows... I'm getting kind errors.  http://haskell.org/hawiki/HaskellIrcPastePage
18:26:47 <heatsink> I started with the functions I wanted and then made the class declaration.  I don't really know what the declaration should look like.
18:27:13 <heatsink> The kind error is that `a' is not applied to enough type arguments  When checking kinds in `a ((s, a), (s, b)) (s, (a, b))'
18:28:03 <heatsink> d'oh, I used the letter "a" for two different types.  That won't work.
18:32:35 <heatsink> Can a class be an instance?
18:33:21 <elux> when ghc compiles haskell code, it first translates to C and then calls gcc?
18:33:54 <heatsink> On some platforms, it can generate native code.
18:34:02 <heatsink> I think it calls gcc by default.
18:34:09 <elux> strange
18:34:16 <heatsink> pq?
18:48:12 <Cale> heatsink: what do you mean by the class being the instance? Sounds somewhat like Marshall McLuhan. :)
18:49:52 <ingy> when definition gets to be more than one parapgraph, you'll need `.list`
18:50:00 <ingy> ww
18:50:43 <heatsink> Cale: I have a class ArrowState that I am trying to use to implement uniqueness typing.
18:50:53 <heatsink> Cale: ArrowState is an instance of Arrow
18:51:19 <heatsink> erm, I mean
18:52:02 <heatsink> It's a type constructor that uses an arrow type.  Arrow a => ArrowState s a.
18:52:41 <heatsink> So, it is implemented as a kind of Arrow.
18:52:57 <Cale> okay
18:52:58 <heatsink> But, it is also used as a kind of arrow, with the state value hidden.
18:53:00 <Cale> so it's not a class
18:53:45 <heatsink> I have ArrowState being implemented as Arrow a => a (s, a) (s, b)
18:54:17 <heatsink> Argh, I used "a" for two different types again :(
18:54:21 <heatsink> I have ArrowState being implemented as Arrow a => a (s, b) (s, c)
18:55:06 <heatsink> And to ensure that s is a uniquenss type, I want it to be hidden (in the OO sense)
18:55:19 <heatsink> So ArrowState looks like it's of type Arrow a => a b c
18:55:47 <heatsink> that last part is why I want to make ArrowState an instance of Arrow.
18:56:26 <heatsink> It is a class.  class Arrow a => ArrowState s a where...
18:59:46 <elux> have you guys heard of .lhs files?
18:59:55 <heatsink> literate haskell
19:00:15 <elux> what does that mean?
19:00:22 <heatsink> I dunno.
19:00:54 <elux> thats where your haskell code is in \{begin}   \{end} blocks .. no?
19:01:05 <elux> but why is that useful? why not just use comments like -- in your code
19:01:26 <heatsink> There's some philosophy behind it.
19:01:48 <elux> and whats that
19:02:24 <heatsink> I don't know.  There is probably someone here who uses literate haskell and can tell you more.
19:02:57 <desrt> elux; the entire program becomes a tex document
19:03:10 <desrt> if you run it through tetex you'll get a printable postscript document
19:03:29 <desrt> i have a copy of my compiler in hardcopy at school.  i'll try to remember to show it to you on friday.
19:03:31 <elux> hrmm .. yea i figured the text doc part. . wasnt away the tetex idea though
19:03:41 <elux> awesome. thanks
19:04:20 <heatsink> desrt: even if your source contains something like let a = "\{end}" in ...?
19:04:22 <elux> i couldnt resist but to look at the code ..
19:04:32 <elux> away = aware of .. etc.
19:04:51 <desrt> if you have tetex installed, you should just be able to type 'make stage2.dvi'
19:05:04 <desrt> or 'make stage2.ps' (in the main project directory)
19:05:15 <desrt> you'll get (respectively) a DVI or postscript version of the document
19:05:43 <desrt> heatsink; i think \{end} has to be first column
19:05:48 <heatsink> oh, ok.
19:06:01 <elux> its installing
19:06:08 <desrt> gentoo?
19:06:16 <elux> osx, fink
19:06:18 <desrt> :)
19:06:56 <elux> it actually didnt compile when i ran just "make"
19:07:03 <desrt> the very best thing about pizza is the future prospect of left-over pizza for breakfast
19:07:04 <elux> ld: can't locate file for: -lgmp
19:07:11 <desrt> oh.  that.
19:07:15 <elux> haha. definitely
19:07:31 <elux> hrmm im hungry .. cheese and crackers .. yumm
19:07:32 <desrt> did you install ghc out of fink or did you use wolfgang's packages?
19:07:39 <elux> fink
19:07:43 <desrt> use wolfgang's packages
19:08:13 <desrt> http://www.haskell.org/ghc/download_ghc_622.html
19:08:46 <desrt> it's near the bottom
19:09:00 <elux> yep got it
19:14:13 <elux> desrt
19:14:17 <elux> im on wolfgang's site
19:14:21 <elux> have you seen his VOP project? pretty cool
19:14:45 <desrt> ya.  he's got some neat stuff
19:14:48 <desrt> try deadend 3d
19:14:50 <desrt> it's l33t
19:14:54 <elux> yea im downloading it
19:14:56 <desrt> it's like a weird varient of sokoban
19:15:15 <elux> i never heard of povray until reading it on his site .. im downloading that to .. thats nuts, making 3d images from text files?
19:15:17 <elux> cool stuff
19:16:11 <desrt> haha
19:16:17 <desrt> you have a lot on the go :)
19:16:34 <elux> ahaha
19:16:38 <elux> too many things interest me
19:19:27 <elux> deadend 3d is awesome.. what did he write that in?  c/opengl?
19:19:45 <elux> probably used povray as well
19:19:54 <desrt> c++ with opengl
19:20:07 <desrt> i have the source code but i'm not allowed to redistribute it
19:20:13 <desrt> i'm trying to convince him to release under gpl :)
19:20:24 <elux> naw its cool .. dont need it
19:20:33 <elux> i dont know why he wouldnt though ..
19:20:36 <desrt> i did.  he doesn't have linux binaries :P
19:20:38 <elux> has anyone actually given him money for it?
19:21:04 <elux> do you know if he used povray to do the graphics?
19:21:12 <desrt> no
19:21:17 <desrt> povray is a static raytracer
19:21:27 <desrt> you use it to render images or movies
19:21:32 <desrt> it doesn't work realtime
19:21:33 <elux> ahh ok .. dont know enough about it yet .. just downloaded it
19:21:48 <elux> realtime povray would be cool .. but i guess it wouldnt be possible since its just too slow
19:23:40 <elux> this guy even speaks in german, english, french and latin
19:23:48 <desrt> :)
19:23:49 <elux> fuck
19:23:53 <desrt> language
19:24:03 <elux> he's mastered "language"
19:24:07 <elux> computer and natural
19:24:26 <desrt> no.  that's wolfram :)
19:24:33 <elux> hahaha
19:24:35 <desrt> he knows like 8 human languages
19:24:37 <desrt> seriously
19:24:39 <elux> maybe it runs in the "wolf"
19:24:45 <elux> i think i heard him speak mandarin
19:24:50 <desrt> yes.  he can.
19:25:13 <elux> im gonna name my son wolf and see if theres a pattern
19:25:18 <desrt> heh
19:25:23 <desrt> he has to be german
19:25:34 <elux> ill conceive him in germany
19:26:02 <desrt> it was sort of funny.  i was sitting in the optimisation lab once and wolfram came in and started talking to wolfgang in german
19:26:23 <desrt> so i'm like "it's awful rude you know, speaking a language that i don't understand right in front of me"
19:26:31 <elux> haha
19:26:36 <desrt> so they switch to english, but they were talking about category theory, so i still didn't understand them :(
19:26:57 <stepcutHM> haha
19:27:00 <elux> lol
19:27:18 <elux> wolfram is a really good prof
19:28:32 <desrt> do you know scott?
19:28:40 <elux> your buddy?
19:28:43 <desrt> west
19:28:49 <elux> west?
19:28:56 <desrt> scott west
19:29:00 <elux> is that the guy with red hair?
19:29:04 <desrt> sort of curly?
19:29:08 <elux> in 3rd year
19:29:08 <elux> yea
19:29:10 <desrt> nod
19:29:19 <elux> i dont know him .. but ive seen him around
19:29:43 <desrt> he's doing NSERC
19:29:55 <elux> is that like weed?
19:30:03 <elux> for techies?
19:30:05 <desrt> sort of
19:30:08 <elux> hehe kidding, what is it?
19:30:12 <desrt> except instead of taking all your money, you get money
19:30:27 <desrt> it's a national sciences/engineering research ... soemthing?
19:30:34 <elux> thats awesome
19:30:37 <elux> how come you dont do that?
19:30:40 <desrt> i don't really know what it stands for.. but basically, the government pays for you to have a summer job at the university
19:30:42 <elux> you probably know 1000x more then him
19:30:45 <desrt> you need to have good marks
19:30:52 <elux> how good?
19:30:55 <desrt> and scott is pretty on the ball
19:30:59 <desrt> he's the co-author of the C compiler
19:31:12 <elux> yea i figured
19:31:12 <desrt> put it this way.. only 3 people got it this year
19:31:33 <desrt> you probably know sahar... and almost definitely know william
19:31:42 <elux> william hung?
19:31:46 <elux> will is a genious
19:31:50 <desrt> hua, i think
19:31:56 <elux> yea hua
19:32:00 <elux> is sahar the mx3 ta?
19:32:05 <desrt> yes
19:32:17 <elux> how much does the gov pay them?
19:32:30 <desrt> the gov pays $4500 but the school adds to it
19:32:36 <desrt> 2nd years get $7300
19:32:39 <elux> so they get double pay .. at the university and gov
19:32:41 <desrt> 3rd years $8100
19:32:47 <elux> in total for 4 months?
19:32:49 <desrt> yes
19:33:15 <elux> man...  you more then anyone should be doing that
19:33:18 <desrt> well
19:33:26 <desrt> i didn't get approved for it, but i'm still getting paid
19:33:27 <elux> will is a math genious though
19:33:39 <elux> by the uni right?
19:33:42 <desrt> ya
19:34:04 <elux> id love to do research at the school, but there is no way id make enough money
19:34:21 <desrt> ya.  it's not a tonne of money
19:34:22 <elux> do you think its a good experience though? in terms of learning stuff
19:34:27 <desrt> definitely
19:34:37 <elux> do you work with profs and they teach you things?
19:34:38 <desrt> and the work environment is amazing... the best possible that you could imagine
19:34:42 <desrt> yes
19:34:59 <elux> really wow
19:35:05 <elux> is that where you learnt most of your stuff?
19:35:13 <desrt> i only did it last year
19:35:17 <elux> well i guess last year was your first time
19:35:18 <elux> yea
19:35:27 <desrt> i learned about computer architecture
19:35:36 <desrt> pipelining and such
19:35:43 <elux> dont we have a course on that?
19:35:50 <desrt> 3rd year, 1st term
19:35:59 <desrt> it's pretty low level
19:36:28 <desrt> 2D03 -> 3G03 -> 3F03
19:36:34 <desrt> sort of form a straight line going upward
19:36:53 <elux> cool
19:36:56 <elux> i look forward to it
19:37:26 <elux> ohh
19:37:31 <elux> you know which prof i really like
19:37:32 <elux> ned
19:37:36 <desrt> ned is cool :)
19:37:37 <elux> the algorithms prof .. he's so easy going
19:37:44 <desrt> he's pretty funny too
19:37:48 <elux> yea
19:37:50 <elux> smart guy
19:38:11 <desrt> shreyas worked with him over the summer.  he likes him a lot
19:38:27 <elux> is it 4 months?
19:38:30 <elux> every day?
19:38:34 <desrt> 'heh'
19:38:35 <elux> so you have to go in each day?
19:38:49 <desrt> well.....
19:38:50 <elux> i wonder if i could work with a prof for free?
19:38:58 <desrt> yes.  you definitely can
19:39:03 <elux> i would work my regular job .. but also do that
19:39:10 <desrt> the thing about a laid-back work environment is that it's laid back
19:39:16 <desrt> more or less you come in when you want
19:39:18 <desrt> or not at all
19:39:24 <elux> thats pretty cool
19:39:32 <desrt> scott was particularly proficient at 'working from home' :)
19:39:40 <elux> i would be working M-F .. so i wouldnt be able to come in .. but id love to help code with projects etc.
19:39:50 <desrt> what is mf?
19:39:52 <elux> who would i need to talk to?
19:39:56 <elux> monday to friday
19:39:58 <desrt> ah
19:40:05 <desrt> talk to a prof you'd like to work with
19:40:14 <elux> can you recommend anyone?
19:40:20 <elux> i guess they all have their own projects
19:40:24 <desrt> yes
19:40:39 <elux> any recommendations? you know the type of stuff im interested in
19:40:52 <desrt> no.  not really
19:41:03 <desrt> personality compatibility is an important part of it.  you know who you like
19:41:04 <desrt> ask around
19:41:10 <desrt> free help is always welcomed :)
19:41:33 <elux> cool
19:41:36 <desrt> you could ask chris if you wanted :)
19:41:47 <elux> what sort of things does he work on?
19:41:50 <elux> i never had him as a prof
19:42:00 <desrt> coconut is his
19:42:17 <elux> thats probably over my head
19:42:27 <desrt> there's all sorts of jobs involved with it
19:42:49 <elux> what sorts?
19:43:43 <elux> guess its better to email him and ask
19:43:47 <elux> i am definitely going to ask around
19:43:58 <elux> i dont care about the money, its about the experience and learning
19:44:19 <elux> i would want to do it every year if i could
19:45:03 <elux> btw i did make stage2.dvi  .. what can open this file now? lol
19:45:16 <elux> ill just make a .ps
19:49:19 <elux> hrmm
19:49:35 <elux> installed the new ghc, still getting an error when i compile your code
19:49:41 <desrt> -lgmp?
19:49:45 <elux> ./c Power Macintosh adder.c > adder.s
19:49:53 <elux> Fail: user error (Pattern match failure in do expression at Main.lhs:46)
19:49:53 <desrt> oh.
19:50:00 <desrt> that's evil
19:50:05 <desrt> you need to say 'ppc' instead i think
19:50:25 <desrt> the makefile uses some uname/shell magic to get the architecture type of the machine you're on
19:50:29 <elux> ./c ppc adder.c > adder.s
19:50:39 <elux> ahh .. that must be it
19:50:41 <desrt> now that i think about it, don't expect this to work properly at all
19:50:53 <desrt> there are significant differences in the ABI of darwin and linux
19:51:00 <elux> ./c ppc adder.c > adder.s worked fine
19:51:12 <desrt> right.  but if it assembles (which it might not) it won't run properly
19:51:43 <elux> yea as adder.s didnt work
19:51:54 <desrt> forgot about that small detail
19:52:08 <desrt> you can port it very easily
19:52:17 <desrt> just make a copy of PowerPC.lhs to Darwin.lhs
19:52:19 <desrt> and make the changes
19:53:00 <elux> didnt you test this on your powerbook?
19:53:07 <desrt> my powerbook runs linux
19:53:29 <desrt> so do both of my G5s :)
19:54:22 <elux> strange
19:54:28 <elux> powerpc, darwin .. shouldnt it be the same?
19:54:34 <desrt> definitely not
19:54:45 <elux> darwin is the kernel
19:54:47 <elux> powerpc is the arch
19:54:52 <desrt> a small example of a difference:
19:55:00 <desrt> on linux if you have a function called 'foo' it gets a symbol called 'foo'
19:55:05 <desrt> on macos the symbol is called '_foo'
19:55:23 <elux> ahhh ... because you made it work on powerpc with linux
19:55:23 <desrt> the reason that this happens is because macos names its registers like r0, r1, r2... whereas linux calls them 0, 1, 2....
19:55:33 <desrt> so if you make a function called "r2" on linux it gets the symbol 'r2'
19:55:46 <desrt> where as if you had the symbol 'r2' on macos, the assembler wouldn't know if you meant the register or the label
19:55:55 <wagle> its an old bsd-ism, i think,
19:55:55 <desrt> so the _ is there to disambiguate
19:56:42 <elux> tetex is really cool
19:56:50 <desrt> ya.  don knuth is a really neat guy
19:56:51 <elux> gotcha
19:57:38 <desrt> in 3I03 (who you will have chris anand for) we had to do projects on turing award winners
19:57:47 <desrt> and the people we had to do projects on were chosen by random
19:57:53 <desrt> i wanted dijkstra... but i got knuth
19:57:59 <desrt> i'm glad i did though, he's a really awesome guy
19:58:10 <Gahhh> he's not human imho
19:58:13 <desrt> (he wrote tex, incase you're wondering what the connection is)
19:58:31 <elux> cool and he's from mac?
19:58:35 <desrt> no
19:58:39 <desrt> he's from sanford
19:58:42 <elux> ahh
19:58:43 <desrt> :)
19:58:43 <Gahhh> stanford
19:58:46 <desrt> yes.
19:59:13 <desrt> anyway.. the entire point of lhs files is to satisfy this ideal of donald knuth's
19:59:16 <desrt> "literate programming"
19:59:23 <desrt> programs as literary documents
19:59:26 <elux> its interesting ..  i like it
19:59:28 <Gahhh> yeah he's the weave-tangle guy
19:59:42 <elux> especially with functional programming
19:59:58 <elux> btw .. you mentioned this c compiler isnt 100% complete? what is it missing? besides optimization ..
20:00:19 <desrt> some operations
20:00:24 <elux> i noticed you allow statements like void main() int x;  without braces .. guess its easier to just parse it without the { and } .. but still support it
20:00:30 <desrt> for example, i think it only supports < and == comparisons
20:00:37 <desrt> no > or <= or >= or anything
20:00:41 <elux> gotcha
20:00:52 <elux> what about #include .. preprocessors .. macros ?
20:00:57 <desrt> dream on :)
20:01:02 <elux> hahahaha
20:01:03 <desrt> no preprocessor
20:01:07 <desrt> just the compiler
20:01:37 <desrt> anyway... at the time we were doing that project, we had like 3 other major projects due
20:01:52 <elux> so it only includes the stdio header file?
20:01:57 <elux> for printf etc.?
20:02:06 <desrt> we had to make scrabble for 3A04 and we had a testing project for 3R03 and a written project for 3I03... it was busy
20:02:18 <desrt> no.  it's like K&R
20:02:25 <elux> yea i can imagine
20:02:28 <desrt> it doesn't check arguments
20:02:40 <desrt> if you say somefunc(whatever, blah, foo) it will trust you :)
20:03:01 <elux> hehe .. i guess you werent kidding when you said semantic analysis is over rated
20:03:20 <desrt> we stopped where we did because it was pretty convincing that if we had '<' then support for all the others was just a matter of more typing (ie: all the thinking work had been done)
20:03:28 <desrt> similar story for missing -= and such
20:03:39 <elux> i hear ya
20:03:58 <elux> how hard would it be to implement #include <otherheaders.h>  .. preprocessors etc.??
20:04:16 <desrt> a preprocessor is an entirely different sort of thing
20:04:26 <wagle> cc -E
20:04:26 <desrt> you could probably do it most effectively in perl :)
20:04:41 <desrt> wagle; or just cpp
20:05:22 <wagle> cpp source is moderately large
20:06:08 <desrt> modern cpp has a lot of weird features
20:07:04 <elux> desrt: does the compiler support printf ?
20:07:24 <wagle> i wish someone would actually finish one of these C compilers...
20:07:25 <desrt> elux; the compiler supports calling any function that's in the libc
20:07:36 <elux> wagle: hehe how come?
20:07:50 <elux> pointers .. pointer to functions .. ?
20:07:56 <desrt> pointers yes
20:07:59 <desrt> pointers to functions, no
20:08:09 <desrt> function calls only direct by name
20:08:28 <elux> thats awesome though man.  great work.  i gonna attempt my own implementation when i learn enough about haskell
20:08:28 <desrt> look at the .c files
20:08:34 <elux> yea i did
20:08:37 <elux> first thing i looked at
20:08:52 <desrt>   list = malloc( n * sizeof( int ) );
20:08:53 <desrt> :)
20:09:20 <elux> even supports arg's to the program
20:09:32 <desrt> ya.  that wasn't too hard
20:09:35 <desrt> it basically happened automatically
20:09:58 <desrt> you probably also noticed that each .c file has a corresponding .abstract file
20:10:06 <elux> youve never read a book on compiler construction?  how did you learn a bout lexing and AST's ?
20:10:11 <desrt> you can probably guess what that means, but probably not where it came from
20:10:19 <desrt> scott wrote the parser
20:10:24 <elux> yea the abstract thing confused me
20:10:29 <elux> and you did the assembly
20:10:30 <desrt> basically, we sat down and agreed on an AST
20:10:31 <elux> gotcha :)
20:10:37 <desrt> then scott did ascii->AST and i did AST->ascii
20:10:38 <desrt> :)
20:10:55 <desrt> (his ascii is a C program, my ascii is an assembly listing)
20:11:04 <elux> yep
20:11:23 <desrt> anyway.  .abstract is the AST, as parseable by 'read'
20:11:41 <desrt> the backend came before the parser was ready, so at first i wrote my test programs directly in the abstract syntax format
20:11:50 <elux> is that generated or do you have to define it with the .c program?
20:11:53 <desrt> then once the parser was ready i ported them from abstract to .c
20:12:16 <desrt> it is not generated
20:12:31 <desrt> you could easily generate it (except it wouldn't be indented all pretty like it is)
20:12:48 <elux> ohh so any c program compiled you have to create an abstract to go with it?
20:12:55 <desrt> no
20:13:02 <desrt> the .abstract was just used for before the parser worked
20:13:16 <desrt> basically:
20:13:20 <desrt>          ast <- cParse filename
20:13:20 <desrt>           let ops = compile ast
20:13:27 <desrt> where ast :: AbstractSyntax
20:13:34 <desrt> before we had cParse, i did:
20:13:34 <wagle> could start with gcc's gimple, or even llvm instead of writing your own parser..  that way you are "guaranteed" to parse all the source gcc can
20:13:53 <desrt> abstract <- readFile 'filename'
20:14:00 <desrt> let ast = read abstract
20:14:19 <desrt> wagle; we wanted to write our own compiler, though
20:14:39 <wagle> i want something besides gcc..  (boo hoo)
20:14:45 <desrt> gcc is great
20:14:55 <desrt> it's the glorious c compiler :)
20:15:12 <elux> wagle: not happy with gcc?
20:15:43 <wagle> elux: the most horrible piece of code i've ever worked with
20:15:55 <wagle> though they claim gcc 4 is much better
20:15:59 <desrt> it'd be great if someone rewrote gcc in ghc, i admit
20:16:10 <desrt> but only because of how amusing it would be to have ghc depend on gcc and gcc depend on ghc :)
20:16:22 <wagle> actually, i want gcc to rewrite itself into haskell
20:16:36 <wagle> (or something like haskell, more reasonably)
20:16:42 <desrt> for all other purposes, i believe that C is the correct language for gcc to be written in
20:16:59 <desrt> you can't have parts of the toolchain written in a non-C language
20:17:04 <wagle> gcc is proof that you cant write compilers in C
20:17:10 <desrt> ...
20:17:33 <desrt> s/cant/can/?
20:17:37 <wagle> cant
20:17:41 <desrt> it seems to me that gcc exists :)
20:18:18 <elux> isnt mono written in c ?
20:18:29 <elux> or maybe an earlier version of mono (c#)
20:18:37 <desrt> mono is written in C
20:18:45 <desrt> mcs is written in C#
20:19:11 <wagle> gcc runs only because there's an army of point fixers that tweak it until it mostly does what you think you want
20:19:44 <wagle> its a huge horrid mess..
20:19:48 <wagle> sigh
20:19:57 <desrt> well, i've never worked with the source
20:20:01 <elux> wagle: get in there and write the replacement in haskell :)
20:20:07 <desrt> but as a black box that i use, gcc is one of the most reliable programs i know of
20:20:24 <Gahhh> gcc is very mature. mature sometimes means "messy but working" as well.
20:20:37 <wagle> many replacements have been funded..  none get finished
20:20:51 <Gahhh> how much corporate pressure is behind that ?
20:21:23 <desrt> i should install gcc 4 for fun
20:21:27 <wagle> finishing isnt as fun as starting..  maintaining is even less fun
20:21:34 <desrt> wagle is right :)
20:22:14 <Gahhh> finishing is more craftsmanship. starting is more creativity.
20:22:28 <wagle> hence my "use gcc's front end" remark..  maybe the joy of actually being able to compile ALL of some distribution would start more interest
20:23:27 <wagle> i want a compiler thats easier to tweak than gcc\
20:24:17 <wagle> i've spent months trying to get gcc to do something like would be a obvious one-liner in any compiler i've written
20:24:18 <desrt> i love gcc
20:25:17 <Gahhh> is the gnu obj-C compiler in a better shape ?
20:25:51 <wagle> thats part of gcc
20:25:55 * desrt quickpkg's gcc3 and installs 4 for a good time :)
20:27:16 <Gahhh> very soon, I am going to benchmark g++ 3.4 versus cl (visual studio 6) on my application heh.
20:27:27 <wagle> also, i want to transform some of the "monads" in gcc..  8)
20:28:28 <wagle> non-optimized vs6 code is pretty amazing..  everything is done via procedures...
20:29:06 <wagle> (machine code)
20:31:24 <wagle> (what was disappointing was going to the gcc developers summit, and finding that _no-one_ actually liked the gcc source...  i was hoping to find out how i was missing its inner beauty)
20:32:10 <Gahhh> well, they probably took it over
23:50:13 <Itkovian> meuning
23:50:30 <dblhelix> meuning :)
23:51:46 <Gahhh> meaning ?
23:52:29 <dblhelix> never seen _llo, llo_?
23:54:55 <Gahhh> nope
23:55:45 <dblhelix> say 'morning' with a french accent ;)
23:57:24 <Itkovian> not that discussion again ;-)
23:57:38 <Gahhh> ah
23:57:59 <Gahhh> bon jour
