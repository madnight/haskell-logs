00:21:17 <musasabi> morning
00:22:29 <nlv11757__> morning
01:47:22 <araujo> Good morning here.
01:48:20 <tromp> morning!
02:39:15 <carolyn> Hi
02:39:54 * pesco stretches.
02:40:14 <pesco> Good morning everyone.
02:40:20 * pesco nods to carolyn.
02:40:34 <pesco> carolyn: Have you been to #haskell before?
02:40:45 <carolyn> once
02:41:27 <carolyn> Has anyone used Haskell to explain Algebra as in rings & groups etc?
02:41:40 <Heffalump> I think there's been some mention on the mailing list
02:41:57 <pesco> carolyn: Depending on what you mean by "explain", yes.
02:42:34 <pesco> I've implemented type classes to represent groups, rings, etc. And others have as well.
02:43:32 <carolyn> Guess I relate things together and I'm taking classes for teachers about Number Theory and Algebra and its seems like Haskell could be useful to explain the ideas or...
02:44:19 <carolyn> Usually I'm coming from the computer science side, but this time I'm thinking from the math side
02:45:22 <carolyn> Written up anywhere?
02:48:24 <pesco> Where is the Karczmarczuk paper?! *search*
02:48:51 <pesco> Ah, there: http://citeseer.ist.psu.edu/karczmarczuk95functional.html
02:49:37 <pesco> The module I wrote: http://www.scannedinavian.org/repos/hlibs/Math/Algebra.lhs
02:49:47 <Philippa_> carolyn: it'd be useful for me, certainly. I have a much better handle on types than I do on sets, IYSWIM
02:50:17 <Philippa_> I can do both, but there's one I can make dance and the other needs dragging along by the arm...
02:51:42 <pesco> Philippa_: You can make types dance? Cool!
02:51:57 * pesco stares at type declarations.
02:56:32 <swiert> carolyn: you may be interested in this book: http://homepages.cwi.nl/~jve/HR/
02:57:50 <carolyn> The first link is very very slow for me for some reason. Might be my firewall.
02:58:10 <pesco> The citeseer one?
02:59:39 <carolyn> Opening the .ps or .pdf file
03:00:25 <pesco> You mean the cached one? Try the original link.
03:01:52 <pesco> How does it DO that? Haskell code always seems to shrink magically when improved. It's the Tao.
03:09:51 <Philippa_> FCVO improvement - faster haskell code is often bigger still :-(
03:10:16 <Philippa_> (for constant-time-improvement values of faster - algorithmic improvements can go either way IME)
03:12:47 <carolyn> OK I have everything ... is there a table of contents somewhere for the book?
03:14:13 <pesco> Philippa_: Ah, I see.
03:14:31 <Philippa_> but small code is often readable code
03:14:47 <pesco> And luckily much code doesn't need to be fast.
03:14:50 <pesco> "fast".
03:14:51 <Philippa_> all else being equal (which isn't the case), fewer moving parts means less room for misunderstanding
03:15:22 <Philippa_> it's not the case for much the same reason there's such a thing as writing style in natural languages
03:15:39 <pesco> What do you mean?
03:16:18 <Philippa_> some ways of conveying exactly the same amount of information are easier to parse than others
03:16:43 <Philippa_> perhaps not 'objectively' easier, groups of people end up attuned to different styles
03:17:50 <Philippa_> but eg a formulation that's more complicated viewed as a 1d string of characters can sometimes explicitly show deeper structure in 2d/with layout that a 'simpler' formulation can't
03:18:59 <pesco> Ah. Right.
03:19:25 <Philippa_> introducing new bindings to do the same might be another example if the binding's only used once
03:20:02 <Philippa_> (it's probably an unarguable improvement if it's used more than once)
03:49:37 <carolyn> pesco: Thanks... have to look it over and try it myself with math theory from class. Don't think either Prof have even heard of Haskell.
03:51:11 <carolyn> pesco: But 1 prof I think would still might be interested. I know it will help me understand the theory... make it more practical Thanks again
03:52:07 <TheHunter> "Not saving page ThingsToAvoid because content matches blacklist: a la : None" ?
03:52:11 <TheHunter> @seen shapr
03:52:11 <lambdabot> I saw shapr leaving #haskell 1 day 17 hours 14 minutes 58 seconds ago.
03:54:12 <Lemmih> Are you spamming the wiki? (:
03:54:33 <TheHunter> i wish i knew what triggered this ridiculous error message.
03:56:36 <TheHunter> well, great, in the sandbox, it works: http://www.haskell.org/hawiki/WikiSandBox
04:01:18 <TheHunter> oh, I see, shapr added "a.la" to LocalBadContent
05:53:38 <metaperl> how can I do this with a single list comprehension?
05:53:39 <metaperl> manip num | even num = num
05:53:39 <metaperl>           | odd  num = -1 * num
05:53:39 <metaperl>  
05:53:39 <metaperl> result = map manip [2 .. 11]
05:58:13 <bringert> metaperl: result = [ if even num then num else -1 * num | num <- [2..11] ]
05:58:57 <metaperl> oh beautiful
05:59:21 <bringert> or result = [ num | num <- [2..11], even num] ++ [ -1 * num | num <- [2..11], odd num]
05:59:21 <metaperl> an expression can be there
05:59:26 <bringert> but that seems worse
05:59:34 <bringert> and is not a single list comprehension
05:59:41 <metaperl> that does not order the results does it
05:59:46 <bringert> nope
05:59:46 <metaperl> that concats two lists
05:59:51 <bringert> yes
05:59:59 <metaperl> i tend to forget that Haskell is about evaluating expressions
06:00:00 <bringert> you'd have to use sort on it
06:00:07 <bringert> so the last version sucks
06:00:20 <metaperl> the normal list comprehension is to use a "variable" where you used an entire expression
06:00:27 <bringert>  result = [ (if even num 1 num else -1) * num | num <- [2..11] ]
06:00:32 <bringert> might be prettier
06:00:54 <bringert> if I got it right, which I didn't
06:01:04 <bringert>  result = [ (if even num then 1 else -1) * num | num <- [2..11] ]
06:01:50 <bringert> result = [ (2 * (num `mod` 2) - 1) * num | num <- [2..11] ]
06:02:41 <metaperl> :)
06:03:00 <metaperl> that is DWIS code. The first solution was DWIM
06:03:09 <bringert> result = [ ([id, negate]!!(num `mod`2)) num | num <- [2..11] ]
06:03:26 <bringert> DWI-what?
06:03:38 <metaperl> do what I say versus do what I mean
06:04:13 <bringert> result = [ (if even num then id else negate) num | num <- [2..11] ]
06:04:26 <bringert> is the prettiest I've thought of so far
06:04:30 <metaperl> what does !! do
06:04:37 <bringert> list indexing
06:04:42 <bringert> @type (!!)
06:04:49 <lambdabot> (!!) :: forall a. [a] -> Int -> a
06:05:11 <TheHunter> zipWith ($) (repeat [\num -> -num, id]) [2..11]
06:06:17 <bringert> s/repeat/cycle/
06:06:20 <bringert> zipWith ($) (cycle [negate, id]) [2..11]
06:06:27 <TheHunter> right, cycle, sorry.
06:06:28 <psi> i think [if even num then num else -num | num <- [2..11] is pretty
06:06:53 <bringert> but it is not higher-order
06:06:54 <bringert> :-)
06:07:59 <bringert> slightly shorter: zipWith ($) (cycle [(0-), id]) [2..11]
06:08:20 <psi> :)
06:08:47 <metaperl> @type ($)
06:08:49 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
06:09:18 <bringert> with zip-comprehensions: [ f n | n <- [2..11] | f <- cycle [negate, id] ]
06:09:30 <bringert> (a glasgow extension)
06:14:24 <bringert> my current favourite: zipWith ($) (cycle [negate, id])
06:14:41 <bringert> since it can be written points-free
06:17:51 <nlv11757__> is there a standard function for: (a->b) -> (a,a) -> (b,b)
06:18:04 <nlv11757__> i'd hate to define stuff already existing
06:18:11 <autrijus> fmap?
06:18:12 <autrijus> not sure
06:18:35 <CosmicRay> Well.   I think that my next Haskell project will be to implement an interface for Asterisk AGI
06:18:37 <CosmicRay> http://www.voip-info.org/wiki-Asterisk+AGI
06:19:29 <nlv11757__> i dont think that is going to work autrijus
06:19:39 <TheHunter> @type \f -> f Control.Arrow.*** f
06:19:41 <lambdabot> \f -> f Control.Arrow.*** f :: forall a b c.
06:19:41 <lambdabot> 			       (Control.Arrow.Arrow a) =>
06:19:41 <lambdabot> 			       a b c -> a (b, b) (c, c)
06:19:59 <nlv11757__> sounds fun Cosmicray, although i have no idea what asterisk is of course
06:20:20 <CosmicRay> nlv11757__: asterisk is a Free PBX
06:20:22 <nlv11757__> i'd have to make an instance probably hunter?
06:20:27 <nlv11757__> ok what is a pbx?
06:20:29 <CosmicRay> nlv11757__: a PBX being basically a telephone server
06:20:42 <nlv11757__> ok we can wire up haskellphones
06:20:48 <TheHunter> no, it's already there:
06:20:53 <CosmicRay> nlv11757__: a PBX is a thing that you have at your phone company or office.  It takes care of routing your calls and, in many cases, handling things like voicemail, transfers, etc.
06:21:04 <TheHunter> @type (+1) Control.Arrow.*** (+1)
06:21:05 <lambdabot> (+1) Control.Arrow.*** (+1) :: forall a a1.
06:21:05 <lambdabot> 			       (Num a, Num a1) =>
06:21:05 <lambdabot> 			       (a, a1) -> (a, a1)
06:21:22 <CosmicRay> nlv11757__: asterisk is a PBX that is based on VOIP technologies.  So, while you can still use traditional phones with it, it is at its best with VOIP phones or VOIP service
06:21:27 <nlv11757__> thanx hunter
06:21:56 <nlv11757__> sounds very 21 century :P
06:22:04 <CosmicRay> nlv11757__: I am setting it up in my house.  It will, for instance, be able to use my existing landline when I place local calls, or use a 1.1cent-per-minute service when I place long-distance calls, automatically selecting based on the rules I define.
06:22:19 <CosmicRay> nlv11757__: it has an interface roughly analogous to CGI that lets you obtain even greater control
06:22:29 <CosmicRay> nlv11757__: that interface is AGI and what I will probably write Haskell stuff for.
06:22:58 <nlv11757__> you can talk to your providers pbx?
06:23:02 <CosmicRay> sure
06:23:20 <metaperl> have you heard of skype - free internet telephone?
06:23:37 <metaperl> i talked to a guy in Illinois for free
06:23:38 <nlv11757__> owwww dude, i though routing of your phone company provider :D
06:23:38 <CosmicRay> nlv11757__: you can get T1/E1 interface cards that work with Linux, or ISDN cards, or even use certain models of winmodems to use a standard phone line.  and of course, voip works too
06:23:40 <metaperl> from Cali
06:24:14 <nlv11757__> i know skype, just confused this all with telecommunication.
06:24:34 <CosmicRay> metaperl: yes.  however, I believe it is restricted to their particular clients.  Check out http://www.freeworlddialup.com/ for a similar, but more open, equivolent
06:25:05 <CosmicRay> there is a whole world of hardware VOIP phones.  They basically look like a regular phone but have an Ethernet jack instead of a phone jack.
06:25:16 <CosmicRay> one can hook one of those directly to a service like FWD (or
06:25:35 <CosmicRay> (or Vonage or deltathree or whatever), or you can hook it up to an asterisk server in your house, and hook asterisk up to these services.
06:25:40 <thebug> or using Cisco ATA boxes is common (plug a normal phone into an ATA and you're off)
06:25:47 <CosmicRay> with asterisk, it is possible and easy to hook up to many of these services.
06:26:15 <CosmicRay> right, thebug is talking about a box with an ethernet jack and a phone jack.  It provides dialtone to a normal analog phone, simulating the telco, and converts it to voip internally.
06:26:34 <thebug> ATA -- analog telephone attachment, if I'm remembering correctly
06:26:47 <CosmicRay> yeah, and you can get them for a lot cheaper than cisco, too :-)
06:27:13 <thebug> pretty nice bit a of hardware if you for some reason like the phone you have, or just want to play and not invest piles of money in 'real' IP-phones :)
06:27:27 <CosmicRay> right
06:27:39 <CosmicRay> a good quality ip phone starts at about $85
06:28:10 <CosmicRay> otoh, you get a lot more for that money than with a regular phone.  scripting, web-based administration, etc.
06:28:34 <nlv11757__> ohhh im in dire need of cafeine
06:29:14 <CosmicRay> http://www.voip-info.org/wiki-VOIP+Service+Providers
06:29:21 <CosmicRay> there's a list of companies providing free VOIP service
06:30:12 <CosmicRay> I'd say that FreeWorldDialup is the top-notch one, though.  They have exchange services with most of the other popular ones, too, so hooking up to FWD gets you access to people using other ones, too.
06:30:37 <CosmicRay> so anyway, asterisk is the perfect geek project.  It is cool, novel, and saves money in the long run :-)
06:31:14 <CosmicRay> the amazing thing is that asterisk is becoming so popular that a whole asterisk-centered industry is growing up
06:31:24 <CosmicRay> companies are making hardware specifically targeted at asterisk
06:31:37 <CosmicRay> and there are also some softphones specifically targeted at asterisk
06:32:23 <earthy> what's even cooler is that you can run an ISDN board and the powersupply from an old NT1 to connect any ISDN phone to asterisk
06:32:48 <earthy> so, given you already have ISDN it's just a EUR 50 investment to go voip
06:32:56 * CosmicRay remembers the days of isdn, vaguely
06:33:01 <CosmicRay> isdn never caught on big in the usa
06:33:19 <CosmicRay> but yeah, it would make a perfect budget interface to the pstn
06:33:25 <earthy> exactly
06:33:33 <CosmicRay> for me, I've got a pstn landline that I can't cancel, since my dsl goes over it
06:33:35 <earthy> take a cheap A/B adapter
06:33:43 <CosmicRay> so I just bought a X100D clone off ebay for $7
06:33:46 <earthy> same here, but the landline is ISDN :P
06:33:51 <CosmicRay> heh
06:34:01 <CosmicRay> so I can still route local calls over it
06:34:09 <earthy> costs a bit more, but with ISDN DECT handsets...
06:34:11 <CosmicRay> but for long-distance, the $0.01 per minute is great
06:34:20 <CosmicRay> I pay $0.07 per minute with the landline telco
06:34:45 <earthy> hm. well. `long'-distance in .nl is something like EUR 0.02 / minute, IIRC
06:35:27 <CosmicRay> that's about USD $0.04/min
06:35:34 <CosmicRay> stupid weak dollar.
06:36:04 <earthy> EUR 1 == $ 1.33
06:36:07 <earthy> roughly
06:36:15 <CosmicRay> oh, it's better than it was then
06:36:18 <earthy> so that's like $0.026
06:36:52 <earthy> but it's not quite that simple :)
06:36:55 <CosmicRay> voipjet.com has service to .nl for $0.0164, to .nl cellular for $0.3082, and to .nl antilles for $0.12
06:37:15 <CosmicRay> and cheaper options exist too
06:37:41 * earthy nods
06:38:14 * CosmicRay finds it interesting that it's more expensive to call cell phones in some places
06:39:17 * earthy finds it interesting that you pay airtime in some places :P
06:39:30 <earthy> btw, ever tried calling landsat phones?
06:39:33 <CosmicRay> heh
06:39:36 <CosmicRay> no
06:39:42 <earthy> ka*ching*
06:39:46 <CosmicRay> heh
06:39:56 <earthy> big wads of money needed
06:40:54 <CosmicRay> metaperl: this is what got me interested in the whole thing: http://techdatapros.com/asterisk/
06:55:50 <TheHunter> hmm, does someone know of an "interesting" property that only few permutations have?
06:59:49 <boegel> if you have a function f : a -> b -> c , and you do f x , so you get another function of type b -> c, how do you name this principle ?
07:01:06 <psi> boegel: partial application?
07:01:58 <boegel> psi: thanks ! I couln't remember it :)
07:02:20 <psi> me neither, but i had a haskell book right next to me :)
07:05:57 <boegel> heh
07:11:51 <TheHunter> this is strange: in a small test program using the list monad, fmap is faster than map, and liftM is faster than fmap.
07:19:27 <nlv11757__> lol
07:19:31 <nlv11757__> that are funny results
07:19:59 <nlv11757__> more overhead?
07:20:11 <nlv11757__> i really lack the expertise to do a sensible explanation
07:20:14 <tromp> fmap stands for fast map:)
07:20:25 <nlv11757__> ow yeah, that was the sensible explanation :D
07:20:39 <tromp> there's also smap if u like it slow:P
07:20:46 <xerox> "Wasn't it about Functors" ? ;)
07:20:51 <nlv11757__> nicccccce and slow
07:21:05 <nlv11757__> naaaah xerox
07:21:12 <nlv11757__> that's so nineties
07:59:41 <Itkovian> bye
08:06:52 <nlv11757__> damn cant believe it's thursday already
08:24:42 <bringert> @seen shapr
08:24:42 <lambdabot> I saw shapr leaving #haskell 1 day 21 hours 47 minutes 29 seconds ago.
09:05:57 <lambdabot> I saw shapr leaving #haskell 1 day 22 hours 28 minutes 50 seconds ago. And
09:05:57 <lambdabot> he had some cute chick with him, so I doubt he's coming back anytime soon
09:08:29 <stepcutHM> haha
09:09:48 <CosmicRay> heh
09:10:03 <CosmicRay> I suspect that means shapr is secretly observing our every move by controlling lambdabot! :-)
09:13:37 <bringert> that's scary
09:20:14 <bourbaki> moin
09:20:36 * stepcutHM remembers why you can't write self-modifying code in flash now
09:21:15 * Oejet wonders why he can't write self-modifying code in Flash.
09:23:01 <stepcutHM> well, the flash virtual machine, stores the program code in some sort of virtual ram, but there are no instructions that read or write that address space
09:23:14 <stepcutHM> programs can only push/pop values on a stack
09:24:08 <stepcutHM> the closest you can get is to add and offset to the PC -- though you can't actually find out what the current value of the PC is ;)
09:26:45 <stepcutHM> there is an opcode to push an anonymous function on the stack, but the data for the opcode is calculated at compile time, and stored in the part of the machine you can not access
09:28:37 <stepcutHM> the best you could do is POST the data back to the server, and have the server generate a new .swf file that you download and run... i think that is possible
09:30:35 <Oejet> I think, I unstand.
09:30:42 <Oejet> *understand
09:32:10 <stepcutHM> it is unfortunate that flash does not have support for more media formats, it does mp3, jpeg, and one specific video codec
09:32:53 <stepcutHM> oh well, transcoding for the rest :)
09:33:02 <SyntaxNinja> stepcutHM: it is unfortunate that flash
09:42:20 <bringert> lambdabot: tell shapr I've got something for him
09:42:20 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
09:48:00 <bourbaki> Oejet: hello :)
09:48:51 <Oejet> Hello, bourbaki.  :-)
09:49:31 <Oejet> bourbaki: It seems that your morning is placed right when I get home from school in the evening.
09:50:41 <bourbaki> Oejet: moin is a universal greeting
09:50:51 <bourbaki> its not bound to time space or ppl ;)
09:51:38 <Oejet> bourbaki: I see.  Now the pieces start to fit.
09:52:09 <bourbaki> :)
10:07:47 <autrijus> ooh there is a replicateM
10:08:05 <autrijus> but no genericReplicateM. beh
10:11:01 <djo> hi
10:11:21 <djo> i have a problem
10:11:48 <TheHunter> "monomorphically recursive" - is that a correct term (shows up in google only once!)?
10:12:44 <djo> how can I make the instance of show class for " ForthState [int] "
10:13:22 <TheHunter> @info Show
10:13:24 <lambdabot> -- Show is a class
10:13:24 <lambdabot> class Show a where {
10:13:24 <lambdabot>     showsPrec :: Int -> a -> String -> String {- has default method -};
10:13:24 <lambdabot>     show :: a -> String {- has default method -};
10:13:24 <lambdabot>     showList :: [a] -> String -> String {- has default method -};
10:13:25 <lambdabot>     }
10:13:25 <djo> we have "type ForthSTATE =STateT forthState IO ()
10:13:56 <TheHunter> ok, then you can't make it an instance of show.
10:14:02 <TheHunter> *Show
10:15:21 <TheHunter> i'm not sure I understand you correctly, what is ForthState?
10:15:37 <djo> we have "type ForthSTATE =STateT forthinterp IO ()
10:15:39 <djo> and
10:15:55 <Lemmih> That's not valid Haskell.
10:16:24 <djo> data forthinterp= forthinterp { dataStack :: [Int ]}
10:16:38 <Lemmih> Neither is that.
10:16:49 <djo> it compiles
10:17:07 <djo> type ForthSTATE =STateT forthState IO ()
10:17:09 <djo> data forthinterp= forthinterp { dataStack :: [Int ]}
10:17:24 <Cale> djo: Are you sure that's the capitalisation?
10:17:56 <djo> data forthinterp= forthinterp { dataStack :: [Int ]}
10:17:56 <Lemmih> djo: Haskell is case sensitive.
10:18:13 <djo> type ForthState = STateT forthState IO ()
10:18:51 <Lemmih> Still not valid (:
10:18:58 <djo> why??
10:19:06 <djo> ah ok
10:19:09 <Cale> ForthInterp should be capitalised
10:19:36 <djo> yes you are right
10:19:37 <Cale> in both the type and the data constructor
10:21:24 <Darius> djo: How do you want to show ForthState?
10:21:48 <djo> finally i declare :
10:22:07 <Darius> TheHunter: There is usually little reason to emphasize "monomorphic" wrt recursion.
10:22:08 <djo> data Forthinterp= Forthinterp { dataStack :: [Int ]}
10:22:31 <djo> type ForthState = STateT Forthinterp IO
10:22:47 <djo> i want to show dataStack
10:23:19 <Lemmih> djo: You can derive Show for Forthinterp.
10:23:35 <djo> il tried it
10:23:52 <djo> but it doesn't work
10:24:15 <TheHunter> Darius, usually, yes, but linear implicit parameters are different ;)
10:25:04 <Lemmih> djo: Then you did it wrong.
10:25:33 <TheHunter> I think their implementation is a little fragile; whether a function is treated polymorphically or "monomorphically" recursive (which makes a semantic difference!) seems to depend on so many things.
10:25:57 <djo> data Forthinterp= Forthinterp { dataStack :: [Int ]} deriving show
10:26:09 <djo> Lemmih,
10:26:39 <Lemmih> djo: Haskell is still case sensitive. Try with 'Show'.
10:26:48 <djo> ok
10:28:07 <Darius> My point was more that one can usually decide whether recursion is "polymorphic", "monomorphic", or not applicable depending on context so rarely is it necessary to explicitly say "monomorphically recursive" or it just isn't relevant.
10:29:40 <TheHunter> I take that as a "the term 'monomorphic recursion' is perfectly fine", thanks.
10:39:31 <palomer> could someone show me how to use a fixed point combinator to solve an equation like f u_1 u_2 ... = g for f? (ie, find a term for f)
10:45:10 <bloomberg> ok so im defining an array by a list comprehension. is there an equivalent for the 'where' clause for functions, whereby i can avoid repeating stuff inside the list comprehension
10:46:12 <Philippa> sort of
10:46:32 <Philippa> foo <- <expression> leaves foo in scope, regardless of where you use it
10:46:49 <bloomberg> ok
10:46:58 <Philippa> failing that you'll probably have to stick it in the enclosing function's where clause
10:47:11 <Philippa> foo = ... where list = ..., bitusedinlist = ...
10:47:38 <Darius> You can also use let clauses in list comprehensions.
10:51:09 <bloomberg> so ive just done [...if foo then bar....|foo<-(test y)] for eg
11:05:00 <bloomberg> so let foo=bar in [list comp]
11:05:02 <bloomberg> yeah?
11:05:21 <bloomberg> or [let foo=bar in (----) | (stuff involving foo)]
11:06:27 <bloomberg> which one?
11:17:53 <tic> the first.
11:18:28 <bloomberg> ok
11:27:03 <shapr> @yow !
11:27:04 <lambdabot> Make me look like LINDA RONSTADT again!!
11:27:54 <Lemmih> Hey shapr.
11:28:04 <Lemmih> You missed bringert.
11:28:30 <shapr> hiya Lemmih
11:31:19 * esap just implemented a well-typed polymorphic stack.
11:32:56 <esap> data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
11:40:15 <Philippa> esap: I'm not sure that's what I'd interpret "polymorphic stack" to mean, but hey :-)
11:40:25 <Philippa> (it's polymorphic but it's still homogenous)
11:41:00 <esap> philippa: What do you mean homogenous?
11:41:06 <xerox> Hiya.
11:41:12 <_JusSx_> same types
11:41:16 <Philippa> right
11:41:25 <esap> philippa: curry Frame :: a -> Stack b -> Stack (a,b)
11:41:30 <Philippa> oh, wait, I re-read it
11:41:31 <_JusSx_> use Maybe
11:41:33 <_JusSx_> type
11:41:38 <Philippa> didn't notice the fs because there's no explicit forall
11:41:40 <_JusSx_> Stack of Maybe
11:42:37 <esap> Frame id :: Stack (Stack a -> a)
11:43:06 <esap> pop :: Stack (f b) -> f (Stack b) ; pop (Frame x) = x
11:44:12 <Jan_w> yo
11:44:35 <Jan_w> shapr: just though of you when I say this
11:44:36 <Jan_w> http://www.killsometime.com/games/game.asp?Game=Unicycle-Challenge
11:45:17 <Philippa> esap: no nil frame then?
11:45:24 <Philippa> but yeah, neat otherwise
11:46:17 <shapr> Jan_w: hah, neat
11:46:37 <esap> Philippa: Well "Frame id" works as a end-of-stack marker. And I suppose if you declare 'data I a = I a', then you get empty frame with "Frame . I"
11:47:10 <shapr> Hey have you guys tried FunWorlds/HOpenGL?
11:47:11 <Philippa> why not just have a StackNil constructor?
11:47:29 <esap> Philippa: because it's not needed. It's simpler this way.
11:48:14 <Lemmih> shapr: FunWorlds?
11:48:34 <Philippa> I guess as you've got to know all but the actual values statically anyway it's not so bad
11:48:34 <shapr> http://www.cs.kent.ac.uk/people/staff/cr3/FunWorlds/
11:48:57 <shapr> Igloo: hey, with ghc6-hopengl debs both 6.2 and 6.4 are missing -lpthread
11:59:59 <esap> philippa: Hmm.. any ideas how I could define Functor instance for Stack? It seems pretty difficult.
12:01:52 <Philippa> I don't think you can - fmap can only accept functions of type a -> b where the func's to be used polymorphically. In fact, I don't think that types
12:01:56 <Philippa> impredicativity and all that
12:07:51 <esap> Frame . Frame :: Stack (Stack a) -> Stack (Stack a). Hmm.. interesting.
12:08:56 <monochrom> There should be no problem defining fmap :: (a->b) -> (Stack a -> Stack b) ?
12:09:39 <esap> hmm. how?
12:10:11 <wagle> type Stack = []?
12:10:23 * esap notes that it was data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
12:11:16 <Philippa> monochrom: the problem is what you do with everything else on the stack. You don't get a proper functor
12:12:29 <wagle> Philippa: example?
12:13:04 <Philippa> wagle: using esap's definition, 'strivial. You can't touch anything other than the top of the stack with the function fmap takes as a parm
12:22:33 <Philippa> okay, having re-checked that's technically a functor. Doesn't do what you'd expect though
12:22:43 <Philippa> ("map" is misleading, certainly)
12:25:30 <musasabi> Should haskell libraries use normally british or american spelling for function names (trying to be consistent) ?
12:25:42 <musasabi> flavour vs flavor..
12:26:09 <monochrom> Hahaha...
12:26:29 <monochrom> Chinese spelling, I recommend.
12:27:04 * shapr has fun with FunWorlds
12:27:11 <shapr> This is a lot like Yampa + HOpenGL
12:31:34 <esap> map_stack :: (forall a. f a -> g a) -> Stack (f a) -> Stack (g a) ; map_stack f (Frame x) = Frame (f x)
12:31:56 <esap> not quite instance of Functor.
12:34:38 <wagle> data Stack a where { Frame :: f (Stack a) ->
12:34:40 <wagle>           Stack (f a) }
12:34:51 <wagle> what does the unbound f mean?
12:35:20 <wagle> (i probably know, and am just having a mental block)
12:36:15 <esap> The constructor just has type f (Stack a) -> Stack (f a). You can only construct things with a specific type "Stack (f a)".
12:36:17 <wagle> oh..  now i see why i've having trouble
12:37:33 <wagle> the left f is of kind type (Stack a) -> ? and the right f has type a -> ?'
12:37:55 <wagle> and Stack a wont unify with a?
12:39:30 <esap> the left f is just use of a functor of kind * -> * to "Stack a". Right f is use of functor of kind * -> * to a.
12:39:57 <esap> But the right side use constrains the constructor.
12:40:22 <wagle> where is this documented?
12:40:38 <esap> wagle: GHC docs ("GADTs")
12:41:21 <esap> wagle: http://www.haskell.org/ghc/  "Latest news" chapter.
12:42:56 <Philippa> oh cool, they're working on windows binaries now, I can have a play at last
12:43:15 <wagle> esap: http://www.haskell.org//pipermail/haskell/2004-October/014554.html
12:43:16 <wagle> ?
12:43:26 * esap nods.
12:43:39 <wagle> ah..  it seemed a bit sheard'ish
12:43:54 <wagle> but i could only half follow him
12:43:59 <musasabi> Seems 6.4 will finally be out soon :-)
12:45:42 <wagle> so its time to get a nice big round tuit and figure this stuff out in detail
12:46:39 <esap> GADTs are very powerful. I'm using it to write a compiler, and GADTs are the only thing that keeps my language design clean.
12:47:36 <Heffalump> essentially they allow you guarantee the type safety of the object code, so long as the object code type system is expressible within the constraint language GADTs support, right?
12:48:20 <esap> yes. I think it's also possible to do it for those things that are not expressible by using unsafeCoerce#, but that's somewhat hack :-)
12:49:16 * esap had to use unsafeCoerce# once to type the control operation (subtraction).
12:49:19 <wagle> esap: sheards stuff is very cool, but i haven't gotten around to playing with omega to check it out
12:51:17 * esap should read more of his papers.
12:52:04 <wagle> omega gets a lot of milage out of equalities, and i think i want inequalities, so i've added the tall hurdle of having to spend a couple weeks understanding it enough to figure that out for sure
12:56:46 <wagle> but he has constructions similar to yours
12:56:55 * wagle lunchifies
13:04:45 <shapr> neat, I found an "impossible happened" in GHC
13:05:09 <Lemmih> That's pretty common.
13:05:19 <shapr> I caused it with this "class XML a where toXML :: a -> XML"
13:06:32 <musasabi> class/type names share a namespace.. but still should be reported.
13:06:50 <musasabi> getting internal errors is never nice.
13:07:33 <shapr> Is this a known bug?
13:12:34 <Lemmih> I didn't know it. (:
13:13:17 <ibid> CosmicRay: how often does hs scan the offsite blogs?
13:13:58 * shapr hugs gmane.org
13:18:11 <jlouis> esap: is GADTs powerful because it solves the problem with separate data types for Statements, Expressions, conditionals etc?
13:19:13 <CosmicRay> ibid: every 6 hours, IIRC
13:19:27 <CosmicRay> ibid: are there some that are missing?
13:19:39 <ibid> hm?
13:19:42 <ibid> just wondering :)
13:19:51 <ibid> i wrote something a short while ago
13:19:56 <CosmicRay> ibid: I can bump that up for blogs that are updated more frequently
13:20:11 <CosmicRay> ibid: I try to be nice to everyone's servers
13:20:38 * ibid updates his blog infrequently, meaning: no frequency (ie. sometimes often, sometimes not=
13:20:52 <ibid> my server can handle a hourly ping, if it's well done :)
13:21:10 <CosmicRay> ibid: there, I clicked update for you.   it safved 15 minutes :-)
13:21:19 <CosmicRay> and there I see your new post.
13:21:31 <Igloo> That's irregularly, no?
13:21:51 <ibid> (ie. a lightweight conditional query, not just getting and comparing)
13:21:52 <CosmicRay> correct
13:21:55 <ibid> Igloo: probably
13:22:19 <ibid> though i
13:22:28 <ibid> 'm a little embarrassed about that particular posting
13:22:46 <ibid> i can't resist posting it but it's so "lift your own tail" stuff :)
13:23:53 <ibid> CosmicRay: did you mean that it was going to update it in fifteen minutes anyway?
13:24:24 <CosmicRay> ibid: correct
13:24:38 * ibid is embarrassed :)
13:24:43 <CosmicRay> heh, no prob
13:26:55 * ibid should probably post some technical content too for a change
13:27:02 <CosmicRay> doesn't matter
13:27:15 <CosmicRay> shapr: did you see my comments about asterisk earlier?
13:28:18 <shapr> the asterisk PBX thingy?
13:29:12 <CosmicRay> yeah
13:29:18 <CosmicRay> it has the asterisk gateway interface
13:29:23 <CosmicRay> sorta like cgi but for phone calsl
13:29:31 <CosmicRay> I'mk thinking of making a haskell interface for it
13:29:34 <boegel> anyone here who speaks Dutch ? :)
13:29:41 <CosmicRay> also I'm considering having fewer typos
13:29:52 <CosmicRay> boegel: oddly enough, you are the second person I've seen ask that on irc today
13:30:01 <CosmicRay> why is dutch so popular all of a sudden?
13:30:16 <CosmicRay> boegel: my wife's grandparents speak pennsylvania dutch, close enough? :-)
13:30:21 <boegel> CosmicRay: I have no idea ;)
13:30:25 <boegel> CosmicRay: not really :p
13:31:42 <Oejet> Maybe someone implemented some cool Dutch program, and now #haskell gets flooded by Dutch people.
13:31:55 <boegel> Oejet: I was here before :p
13:32:54 <Oejet> boegel: Yes, you were.
13:37:31 <CosmicRay> <Darwin35> and I will not touch solaris 10
13:37:36 <CosmicRay> <CosmicRay> Darwin35: I will not touch solaris.
13:40:33 <Oejet> In #darcs: ***Oejet curses Solaris and all of its administrators.
13:40:45 <CosmicRay> heh
13:48:03 <wagle> my great great great great great grandfather (Johann Adam Wegel) left amsterdam in 1744 for pennsylvania: http://www.searchforancestors.com/passengerlists/phoenix1744.html
13:48:54 <Itkovian> so was I and boegel and I are not Dutch!
13:48:54 <wagle> whats wrong with solaris 10?
13:48:58 <Itkovian> We're Belgians
13:49:06 <Itkovian> wagle: it's solaris?
13:49:09 <Itkovian> :-)
13:49:38 <boegel> Itkovian: we speak Dutch, for the outside world that's the same
13:49:50 <Itkovian> there are differences!
13:49:59 <Itkovian> the dutch prolly can't even understand me
13:51:00 <boegel> Itkovian: when your speaking our famous dialect, no way :)
13:51:01 <stepcut> anyone know what decodeFloat does ?
13:52:34 <stepcut> nm.
13:54:30 * wagle wonders if anyone knows what decodeFloat does..  now
13:54:41 * Oejet lumps Solaris into the Java soup and starts bashing away at the thing.
13:55:41 <stepcut> wagle: http://www.zvon.org/other/haskell/Outputprelude/decodeFloat_f.html
13:56:13 <tromp> who cares if i'm dutch?
13:56:16 <Itkovian> actually ... solaris is pretty good afaik
13:56:24 * stepcut needs to turn a 32-bit float into a [Word8]
13:56:31 <Itkovian> tromp, when there's soccer, we do!
13:56:42 <Itkovian> bitsex eh
13:57:06 <tromp> i don't keep track of soccer:( although i cldn't help noticing PSV getting into qfinals:(
13:57:13 <Itkovian> yeah ...
13:57:33 <Itkovian> i don't keep track of it either, but I know when we kick yr asses :-)
13:59:11 <boegel> tromp: I do :)
14:00:26 <wagle> stepcut: why [Word8]?
14:00:43 <Darius> stepcut: Is there a Storable instance of Float?
14:02:32 <wagle> (hacking the output of decodeFloat seems a bit fragile)
14:02:54 <Heffalump> wagle: what are you trying to do?
14:03:13 <stepcut> Darius: hrm, I will check
14:03:30 <wagle> Heffalump: huh?
14:03:43 <stepcut> wagle: I am writing a swf assembler, and I need to a way to write out the float in binary...
14:03:51 * stepcut goes to lunch, bbiab
14:03:56 <musasabi> wagle: poke ?
14:04:09 <musasabi> but what about endianess?
14:04:20 <Heffalump> wagle: I have some code that can do precisely that
14:04:30 <Heffalump> unfortunately, it's at work.
14:04:43 <Heffalump> I'll give it to you if you can wait till tomorrow (it's pretty short)
14:04:58 <wagle> Heffalump: i'm responding to stepcut
14:05:03 <Heffalump> and it does precisely hack the output of decodeFloat, because AFAIK that is stable and correct in an IEEE sense.
14:05:11 <Heffalump> s/wagle/stepcut/g # sorry :-)
14:05:36 <SyntaxNinja> stepcut: someone handed me a Binary module the other day that has been quite useful
14:06:00 <SyntaxNinja> hm. doesn't look like it does float though
14:06:14 <Heffalump> the obvious other thing to do is unsafeCoerce
14:07:55 <Darius> To a Ptr Char or an unboxed array or what?
14:08:17 <wagle> ugh
14:09:00 <wagle> the haskell system already knows what bytes the float occupies.  just have it tell you..
14:10:17 <boegel> tromp: check PM
14:11:06 <wagle> i guess i'm allergic to redoing what some other piece of code already knows..  and using unsafe___ seems hideous..
14:11:17 <Heffalump> I was just thinking to an Int32
14:11:33 <Darius> "There is a VCS named darcs, which is much more flexible, but is specced using quantum physics language and written in a scary language called Haskell" This is so the image of Haskell.
14:11:39 <wagle> different machines might have different formats
14:11:45 <Darius> Heffalump: Yeah, I started thinking that too.
14:11:53 <Darius> different machines do have different formats
14:12:11 <earthy> hm. well.
14:12:16 <Heffalump> but an IEEE 32 bit number is likely to be the same
14:12:23 <earthy> Wings3D is written in a scary language called Erlang
14:12:29 <earthy> I don't see people complaining about *that*
14:12:55 <wagle> haskell is scarier..
14:13:33 <earthy> than erlang?
14:13:38 * boegel goes to bed, sleep tight everyone !
14:13:41 <earthy> nu-uhuh
14:13:46 <Darius> Wings3D isn't specced in Quantum Physics language I don't think.
14:14:18 <earthy> true
14:14:34 <wagle> earthy: way
14:17:47 <earthy> erlang is parallel
14:17:54 <earthy> parallel is scarier than functional
14:18:05 <earthy> much more breakage
14:20:48 <earthy> well, potential for breakage
14:23:26 <Oejet> earthy: Concurrent Haskell is both concurrent and functional.  That must be the scariest.  STM is nice, though.
14:23:34 * earthy nods
14:25:12 <metaperl_> what is STM?
14:25:23 <Oejet> metaperl_: STM is nice.
14:25:32 <Oejet> :-P
14:25:36 <metaperl_> I think we have the following major addons to Haskell - relations, logic, concurrency
14:25:42 <metaperl_> where is STM? any links?
14:27:55 <Oejet> Software Transactional Memory: http://www.haskell.org/ghc/docs/6.4/html/libraries/stm/Control.Concurrent.STM.html, http://research.microsoft.com/Users/simonpj/papers/stm/ .
14:30:00 * Oejet wonders if he can implement a barrier abstraction.
14:30:59 <shapr> Isn't STM both concurrent, functional, and parallel?
14:31:09 <shapr> waitasec, that wasn't both, that was at least three.
14:31:15 <earthy> um
14:31:16 <earthy> no.
14:31:22 <shapr> Are you sure?
14:31:24 <earthy> concurrent =~ parallel.
14:32:24 <Oejet> shapr: The semantics are different.
14:32:34 <earthy> anyway, more than late enough to go to bed
14:33:03 <earthy> g'night all
14:34:04 <earthy> hey, mr. Turk.
14:34:13 <earthy> IIRC
14:35:18 <Remi> hi
14:35:20 <Remi> that's correct :)
14:37:33 <Remi> *wonders who knows my name*
14:38:21 * Darius knows Remi's name.
14:39:09 * Darius has some idea of who knows his name.
14:39:55 * Remi probably has a bad day, as he's now left wondering who "his" is ;)
14:40:45 * Darius would be surprised if Remi knew his name off-hand (or could connect it to this nick at all)
14:41:04 <shapr> I know your name!
14:41:12 <earthy> Derek?
14:41:17 <Heffalump> Derek Elkins, innit?
14:41:44 <earthy> hadn't matched the Elkins yet
14:42:28 * Remi will try to remember that for the next few minutes
14:43:02 <earthy> maargoed, bedtijd.
14:43:11 <earthy> err. 'night all
14:43:15 <Remi> dutch too?
14:43:21 <Remi> weltruste in dat geval
14:43:28 <Heffalump> yeah, they're everywhere. S'like a plague or something.
14:43:50 <Remi> Haskell has more in common with Python than you'd think... ;)
14:44:17 <shapr> Except that Guido in convinced that loops are higher level than recursion.
14:44:33 <Remi> then you don't know Guido
14:44:38 <shapr> ik begrijp het niet
14:44:39 <Remi> he's just part of the Greater Plan
14:44:55 <Remi> the HSUs, that is
14:45:05 <wagle> HSU?
14:45:07 <shapr> The Haskell Secret Underground doesn't exist.
14:45:21 <shapr> who told you about it anyway?
14:45:27 * shapr orders that person's execution
14:45:33 <Remi> I was talking about the Humboldt State University
14:45:38 <shapr> oh, whoops
14:45:42 <wagle> SMOF 2005?
14:45:42 * Remi cancels
14:45:51 <wagle> mmm..  SMOH
14:46:13 <shapr> Remi: want to write an article for The Monad.Reader issue 2?
14:46:33 <shapr> Let's see, who can I pick on to write for issue 2? any volunteers?
14:46:42 <shapr> stepcut: want to write for issue 2?
14:46:47 <shapr> musasabi: monad transformers?
14:46:53 <Remi> I'm certainly interested, but I'd definitely need  something to write about ;)
14:46:55 <shapr> edwinb: dependent types?
14:47:09 <wagle> what does "higher level" mean such that recursion vs loops migh be compared?
14:47:25 <shapr> wagle: in that loops are a more intuitive and more basic control structure
14:47:42 <Remi> though "basic" might be a problematic word in this context...
14:48:00 <wagle> basic implies lower (, yeah)
14:48:21 <pipe> man, Benjamin Pierce has some serious biceps
14:48:26 <pipe> http://www.cis.upenn.edu/~bcpierce/photos/2001Sep15/tobyNme-screen.jpg
14:48:43 <Remi> the dog?
14:48:46 <shapr> "It is a strongly typed pure functional language, where just about everything is written as recursive functions, because the language has no looping construct. Because of this it will probably always remain a language of mostly academic interest." from http://www.artima.com/weblogs/viewpost.jsp?forum=106&thread=4550
14:48:55 <shapr> y0 pipe
14:48:59 <pipe> sup
14:49:09 <shapr> Hey, have you seen FunWorlds?
14:49:21 <Remi> I'm afraid he should read ThingsToAvoid then ;)
14:49:31 <shapr> Btw, epigram is not necessarily more powerful or general purpose than Haskell.
14:49:53 <int80_h> my favorite room :)
14:50:09 <shapr> I'm in the same room with my keyboard, this is my favorite room.
14:50:18 <pipe> have not seen FunWorlds. that quote you just gave is totally bogus thoug
14:50:18 <int80_h> I wonder if there is a functional programming users group in silicon valley
14:50:26 <int80_h> I mean channel
14:50:35 <int80_h> bah I am using sdf metaphors
14:50:42 <int80_h> it's hard shifting back and forth.
14:50:43 <shapr> syntax description format?
14:50:52 <int80_h> sdf.lonestar.org
14:51:00 <int80_h> a public shell with a bbs flavor
14:51:06 <shapr> ah, ok.
14:51:12 <int80_h> there's a chat utility that uses rooms instead of channels
14:51:18 <Spark_> i remember playing with that like, 8 years ago or something :)
14:51:19 <shapr> ja, ich verstehe
14:51:26 <pipe> shapr: it seems to me that haskell has better static checking then haskell. sure it may not offer more power, but you might as well have a haskell compiler that doesn't do type checks at compile time, only at runtime. this won't deprive you from any power, but it will make the language less good
14:51:34 <pipe> i hope this analogy makes some sense
14:51:52 <int80_h> haskell has better static checking than haskell?
14:51:56 <shapr> um, you mean epigram vs haskell?
14:52:22 <wagle> haskell > haskell?
14:52:32 <shapr> Epigram can check more statically, but dependent types can possibly deprive you of power.
14:52:44 * wagle suddenly discovers the need to read first
14:52:54 <int80_h> well some say haskell is better than haskell, but others disagree and assert that it is haskell that is better than haskell. I don't think this debate will ever be settled.
14:53:25 <Remi> then again, there are people who assert that there is no ordering at all between haskell and haskell
14:53:28 <shapr> Frank Atannasow argues that dependent types lead to overly coupled code, where much less of the code is reusable compared to Haskell.
14:53:35 <pipe> oops, replace the first "haskell" with "epigram" :D
14:53:48 <shapr> Personally, I want edwinb to write about epigram in The Monad.Reader.
14:53:51 <int80_h> heh I know, I couldn't resist the joke ;)
14:53:58 <shapr> edwinb: awake? Want to write about epigram and dependent types?
14:54:43 <int80_h> how can I find a haskell user group in my area, or barring that, a functional programming users group.
14:54:57 <int80_h> I went to haskell.org, I couldn't see anythign but mailing lists
14:55:12 <shapr> Where are you?
14:55:22 <int80_h> I have to believe that silicon valley has at least five people that like haskell :)
14:55:32 <int80_h> oh I live in santa clara valey in california
14:55:40 <int80_h> valley
14:56:02 <Darius> shapr: Link to Frank's comment?
14:56:26 <metaperl_> int80_h: hi!
14:56:34 <int80_h> hi metaperl :)
14:56:38 <metaperl_> oh santa clara, not santa clarita
14:56:46 <metaperl_> that's up in nocal (santa clara)
14:56:52 <metaperl_> I live in Thousand Oaks, CA
14:57:01 <int80_h> no santa clara, south of san fransisco. Commonly referred to as silicon valley
14:57:05 <metaperl_> what major city is in Santa Clara
14:57:12 <metaperl_> I once lived in San Carlos, CA
14:57:17 <shapr> Darius: looking...
14:57:18 <int80_h> I would have to say the major city is stanford ;)
14:57:19 <pipe> i can't find a single haskell programmer in this entire fucking country :(
14:57:24 <shapr> Darius: want to write something for TMR?
14:57:39 <wagle> pipe: they are all married?
14:57:41 <Darius> shapr: If I think of something coherent.
14:57:51 <int80_h> but I gues stanford isn't that big via population
14:58:03 <pipe> jeez, is it comedy night here or what?
14:58:03 <shapr> http://lambda-the-ultimate.org/node/view/262
14:58:07 <int80_h> santa clara valley is made up of many many small cities
14:58:12 <Darius> shapr: Thanks
14:58:26 <metaperl_> like San Carlos and Palo Alto?
14:58:30 <shapr> That's not the original comment, but the original was on LtU classic.
14:58:37 <int80_h> cupertino has Apple, maybe that makes it the major city.
14:58:49 <int80_h> san carlos is in san mateo, north of us.
14:58:52 <metaperl_> oh how about San Jose
14:58:58 <int80_h> san jose is a pit
14:59:07 <metaperl_> is it santa clara or san mateo?
14:59:13 <shapr> Darius: want to write about how typeclasses are not OOP? Or maybe how to break ghci via irc?
14:59:26 <int80_h> it is large in population but not much of significance happens there. I may be biased however ;)
14:59:40 <int80_h> I think san jose is in santa clara
15:00:07 <shapr> pipe: There's an easy solution to your problem, proselytize.
15:00:38 <int80_h> I have to send away to the cal poly library to get books on haskell
15:01:00 <int80_h> but I imagine there must be at least five people
15:01:08 <int80_h> that makes up a group :)
15:01:38 <pipe> shapr: you mean like lisp?
15:01:47 <shapr> No, not like Lisp!
15:01:52 <int80_h> I thought about that shapr. I think I may have to be more generic and start with "functional programmers users group."
15:01:57 <metaperl_> int80_h , what are you doing with Haskell? and where?
15:02:05 <int80_h> me, I am just learnign it
15:02:20 <int80_h> I got the bird book
15:02:24 <Darius> shapr: I was thinking about a type classes article or perhaps make the free monad thing into an article.
15:02:34 <shapr> free monad thing?
15:02:42 <wagle> pipe: i think meyer goldberg at bgu does some haskell
15:02:45 * shapr tries to remember.
15:02:48 <int80_h> I am learnign lisp and haskell at the same time...lisp because i finish what I start and haskell because it drew me in unexpectedly
15:02:54 <pipe> wagle: bgu?
15:02:56 <shapr> int80_h: wise move.
15:03:05 <wagle> www.cs.bgu.ac.il
15:03:08 <int80_h> i got into haskell googling for proof checking software
15:03:18 <int80_h> and now I can't stop!
15:03:24 <wagle> pipe: i'm assuming you in .il
15:03:48 <pipe> bgu is a pit
15:03:55 <int80_h> I am going to preach haskell to the math people at my school
15:04:03 <wagle> pipe: bummer..  how so?
15:04:04 <int80_h> I think it will appeal t them
15:04:21 <int80_h> but most of the math people here aren't crazy about computers.
15:04:58 <int80_h> when i have worked through the bird book I will bug you all for projects :)
15:05:22 <int80_h> but I have somethign forming in my head
15:05:24 <pipe> wagle: it's in the middle of the desert
15:05:42 <int80_h> as long as haskell has a decent interface to a widget toolkit
15:06:20 <int80_h> we have this old hypercard program for the calc I class. It's awful. I complained to the professor and she says "well maybe you can make something better." and i filed that away.
15:06:48 <int80_h> so when the time comes I want to take a stab at replacing the old mac software with somethign written in haskell
15:07:13 <int80_h> haskell and whatever else I need. i see that haskell is at it's best when used as a part of a larger system.
15:07:43 <int80_h> I am formign a picture, that haskell is best in the code that needs to change and adapt, the code that is lower level and doesn't change much can be done in something else.
15:08:02 <int80_h> these are all naive ideas that have no basis in my personal experience, just what I have been reading.
15:08:21 <Darius> Depending on your requirements, you should be able to do it all in Haskell easily.
15:08:26 <int80_h> sweet :)
15:08:55 <int80_h> well in one part of ther calc tutorial, there is a graph where people can move a parabola around and change things with the mouse
15:09:18 <int80_h> what expect to do with haskell is make a config language for the teachers, so they can change things on the backend.
15:09:52 <pipe> int80_h: there's a cool haskell program where you can transform images
15:09:55 <pipe> in realtime
15:09:58 <int80_h> wow!
15:10:02 <int80_h> excellent
15:10:05 <pipe> using sliders and stuff
15:10:18 <wagle> pipe: that makes it a pit?
15:10:23 <int80_h> ah, so I have what I need in the language then...all good :)
15:10:36 <int80_h> right now I must work through the bird book
15:10:50 <Darius> int80_h: Haskell is a practical general-purpose language.
15:11:05 <int80_h> all I know is that haskell looks like math to me, and that is the way i think..so I think I am close to thinking in haskell.
15:11:42 <pipe> int80_h: http://haskell.org/edsl/pansharp.html
15:11:46 <int80_h> and this will help me witht he preaching...my alehterior motive is to use this system as a proof of concept.
15:11:53 <int80_h> thanks :)
15:12:07 <int80_h> alterior
15:12:20 <wagle> ooo  spirograph!
15:12:45 <int80_h> if I come back to this school years from now and they are using haskell in the discrete math class....well now I am dreaming...
15:13:08 * boegel out, for real
15:13:33 <wagle> nah..  something like mathematica, matlab, maple, ...
15:14:45 * Remi dreams about matlab with a language that doesn't make me feel suicidal behind it
15:15:30 <int80_h> haskell is Puuuure-a!
15:15:35 * int80_h preaches.
15:16:21 <wagle> .. or maybe some theorem prover
15:16:40 <int80_h> well I found a proof-checker in haskell.
15:16:48 <int80_h> not the same I know. but neat.
15:17:15 <int80_h> and it only handles direct proofs. no contra-positive, contradiction.
15:17:36 <Darius> Yarrow?
15:17:49 <int80_h> not it was some kids project and UT austin
15:17:55 <int80_h> erm I mean no,...
15:18:09 <int80_h> this keyboard is driving me crazy
15:18:18 <int80_h> my typing is bad enough without help.
15:26:48 <dons> what about Agda - that's a theorem prover in haskell, I think.
15:26:51 * jadrian has been implementing a theorem prover based on Gentzen deduction systems
15:27:20 <dons> a bit like twelf, if I can read the docs correctly
15:27:34 * jadrian look up Adga
15:27:49 <dons> amd64/ghc just got an ffi :)
15:28:19 <Remi> :)
15:28:52 <Remi> well, I expected amd64 support to be on par with x86 support anyway once I've collected enough money to buy one...
15:29:53 <dons> hehe
15:30:33 <Heffalump> can someone summarise what STM is about?
15:30:45 <Darius> Lock-free concurrency
15:31:22 <Remi> higher-than-lock-level concurrency
15:31:37 <Darius> Remi: There aren't locks underneath
15:31:37 <shapr> optimistic journaling
15:32:34 <Remi> Darius: there would be if there was a real parallel version of GHC
15:32:40 <Remi> AFAIK
15:32:54 <shapr> Why would you need locks with an STM-based SMP GHC?
15:33:01 <Darius> Remi: If there were a compare-and-swap opcode there wouldn't need to be.
15:33:25 <Remi> shapr: I'm talking about STM itself would be implemented
15:33:33 <wagle> agda is not haskell, but hallgren does proof stuff about haskell in it
15:33:53 <shapr> Hallgren did a network stack in Haskell recently.
15:33:55 * Remi nitpicks how a compare-and-swap opcode could be implemented
15:34:07 <Remi> http://research.microsoft.com/Users/simonpj/papers/stm/index.htm
15:34:15 <Remi> it's quite a short & readable article btw
15:34:22 <Remi> and fun to read too
15:34:47 <Remi> though I don't like the "check" function, as it's doing nothing more than MonadPlus's "guard"
15:34:51 <Darius> Remi: In hardware, as it or equivalently expressive primitives often are.
15:35:06 <dons> wagle: but agda is implemented in Haskell, no?
15:35:11 <Darius> Remi: STM follows from a thesis called Practical Lock-Freedom.
15:35:15 <dons> it even has plugins now.
15:35:41 <wagle> dons: dont know..  dont have that impression, but am taking off right now, so cant check
15:36:10 <dons> it is implemented in haskell. I'm reading the build instructions right now.
15:36:13 <wagle> duh
15:36:14 <wagle> http://www.cs.chalmers.se/~catarina/agda/impl.html
15:37:01 * wagle break camp, and travels to the next oasis
15:41:02 <stepcut> (unsafeCoerce# (1.0 :: Float)) :: Word32
15:41:19 <stepcut> is that safe ?
15:41:19 <Darius> showHex and decipher
15:41:34 <dons> I don't think that's safe...
15:41:47 <stepcut> unsafe at any speed !
15:41:54 <Darius> If there's unboxed versions those might be better to use.  Obviously it isn't safe (or defined) in general.
15:41:56 * dons goes rts diving to check..
15:43:13 <dons> yeah, unsafeCoerce# (1.0# :: Float#) :: Word32# might be ok.
15:43:50 <SyntaxNinja> shapr: what did you decide to do in you rfree time?
15:44:04 <shapr> Er, work on a science fiction story
15:44:11 * stepcut is open to other alternatives
15:44:22 <dons> stepcut: you can check what code is generated using (int2Word# (float2Int# 1.0#))
15:44:28 <shapr> Why, do you have a neat alternative?
15:44:40 <dons> W# (int2Word# (float2Int# 1.0#)) :: Word
15:45:27 <stepcut> is W# a function ?
15:45:38 <stepcut> err, constructor ?
15:45:54 <Darius> Yes
15:45:59 <stepcut> what do I need to import ?
15:46:13 <Darius> Data.Word or maybe GHC.Word (?{
15:46:16 <Darius> @index W#
15:46:17 <lambdabot> GHC.Exts,GHC.Word
15:46:18 <dons> import GHC.Word, GHC.Float. maybe GHC.Prim
15:46:29 * Darius pats lambdabot on the head.
15:46:36 <stepcut> ah, I need the GHC.Word, not Data.Word :)
15:46:41 <Remi> and -fglasgow-exts
15:46:44 <dons> yeah.
15:47:00 <stepcut> how do I convert Float -> Float# ?
15:47:07 <Darius> pattern match
15:47:23 <dons> yep.
15:47:30 <dons> F# f
15:48:47 <Remi> Prelude> :m +GHC.Exts
15:48:47 <Remi> Prelude GHC.Exts> :i F#
15:48:47 <Remi> data Float = F# Float# 	-- <wired into compiler>
15:48:47 <Remi> Prelude GHC.Exts> :i S#
15:48:47 <Remi> data Integer = S# Int# | ... 	-- Imported from GHC.Num
15:48:56 <dons> you end up with: *Hp=(W_)(0x1e61);
15:49:08 <Remi> ahh, 1e61, of course ;)
15:49:19 <stepcut> oh, duh!
15:49:30 <dons> sorry, I replaced 1.0 with 7777.0 so I could spot it in the -ddump-realC output
15:49:35 <stepcut> heh
15:49:48 <dons> main = putStrLn $ show (W# (int2Word# (float2Int# 7777.0#)))
15:50:05 <dons> but ghc, even with -Onot, is still flattening out the casts
15:50:32 <Remi> flattening out?
15:50:44 <dons> should be possibly to get it to generate a i=(F)777;j=(W)i; sequence though.
15:52:55 <dons> now, what about using unsafeCoerce#... hmm.
15:53:32 <dons> like this: g' (F# f) = W# (unsafeCoerce# f)
15:54:36 <dons> yep. seems to work, but produces garbage...
15:54:55 <stepcut> garbage?
15:55:17 <dons> you can't just coerce a Float to a Word, right?
15:55:27 <dons> 7777.0 -> 1173555200
15:55:33 * stepcut has no idea, but was hoping you could ;)
15:55:52 <dons> floating point representations and all..
15:56:09 <Remi> which probably might be implementation dependent etc
15:56:37 <dons> ahha. unsafeCoerce# produces: ASSIGN_FLT((W_*)(Hp),(StgFloat)7777.0)
15:57:02 <stepcut> well, maybe I should mention what I want to happen, eh ?
15:57:35 <stepcut> I want to take a Float value, and turn it into a [Word8], MSB representation
15:58:07 <dons> ah! now we can certainly do that..
15:58:10 <Itkovian> stepcut, but what would the bit patterns in the [Word8] mean?
15:58:21 * stepcut tries to remember
15:58:23 <Remi> that is, you want exactly the binary representation of the thing?
15:58:28 <Itkovian> seems rather pointless
15:58:32 <Darius> Float as a Haskell Float or an IEEE Float (is there a difference? Does the Report require IEEE?)
15:58:41 * stepcut looks something up
15:58:46 <Remi> hm, there is a function isIEEE
15:58:48 <Itkovian> for an Int I could imagine something useful, but for a Float/
15:59:06 <Darius> Itkovian: Serialization
15:59:14 <Darius> Binary formats etc.
15:59:31 <Remi> but then you'll run into problems communicating with different platforms
15:59:36 <dons> you can unsafeCoerce# it to a W#, then inspect each byte using indexCharArray#
15:59:46 <stepcut> Itkovian: I am writing a library that outputs .swf files...
16:00:09 <dons> but this is all very totally evil, btw stepcut.
16:00:12 <Itkovian> ok.
16:00:43 <Itkovian> Remi, not necessarily, if you take the spec with you to the other platform, eh
16:00:49 <stepcut> ok, I need to write out a 32-bit IEEE single-precision little-endian floating-point value
16:01:29 <Itkovian> heh
16:01:29 <fraxtal> stepcut: You're writing a library that will help generate .swf's from haskell code?
16:01:34 <stepcut> I could have a bunch of functions that go from, a->[Word8], and then just write the final array out to disk
16:02:11 <Remi> *deletes a probably not-funny-at-all remark I'm not going to make and decides that probably means it's time to get some sleep*
16:02:16 <stepcut> fraxtal: it is haskell code that will generate .swfs
16:02:22 * shapr deletes a mental note
16:02:43 <fraxtal> stepcut: killer
16:02:49 <stepcut> fraxtal: ultimately a scheme->swf compiler
16:02:59 <stepcut> right now I am just doing the assembler portion
16:03:21 <Remi> good night everyone
16:03:54 <dons> you can just use the above W# (int2Word# (float2Int# f)) to get your Word, then using the Bits library to shift off the pieces you want.
16:05:02 <stepcut> dons, really?
16:05:04 <stepcut> floatToWord32 (F# f) = W# (int2Word# (float2Int# f))
16:05:10 <stepcut> *Main> floatToWord32 1.1
16:05:10 <stepcut> 1
16:05:32 <stepcut> I was intending to do something more like,
16:05:33 <stepcut> floatToWord32 (F# f) = W# (unsafeCoerce# f)
16:05:38 <dons> hmm. ok. yeah. I see.
16:05:44 <dons> we want that.
16:05:48 <stepcut> and then shift of the bits (I have the code to go from Word -> [Word8] already)
16:06:50 <stepcut> which is extra-fun, because things are not always byte-aligned in the output file :)
16:07:21 <stepcut> so, is there any haskell98 way to do this ?
16:07:29 <Heffalump> no chance
16:07:37 <Heffalump> well, some FFI
16:07:48 <Heffalump> but your C code wouldn't be strictly conformant either
16:08:08 <dons> no H98. probably nicer using the ffi, and very evil using primops
16:08:23 <Igloo> If the report says IEEE you can do it with decodeFloat can't you?
16:08:23 <stepcut> ok
16:08:41 <Darius> stepcut: I don't believe there is any language (with a separate standard) that standardizes bitformats.  (Well, probably a few)
16:08:47 <Heffalump> igloo: oh, true
16:09:20 <stepcut> Igloo: the report definately says IEEE, I did not understand with decodeFloat was doing though :)
16:09:49 <Heffalump> that's fairly straightforward
16:09:52 * stepcut has hardly ever used a floating point number in 10+ years of programming :)
16:10:03 <Heffalump> as I said, I can give you a few lines of code to translate the output into a bit pattern if you can wait till tomorrow
16:10:24 <dons> ok. got something:
16:10:24 <dons> g :: Float -> (Word8,Word8,Word8,Word8)
16:10:25 <dons> g (F# f) =
16:10:25 <dons>         let words = W32# (unsafeCoerce# f)
16:10:25 <dons>             ba    = unsafeCoerce# words :: ByteArray#     -- more evil
16:10:25 <stepcut> Heffalump: I started this code in 2003, so I think I can wait ;)
16:10:27 <dons>             w0    = W8# (ba `indexWord8Array#` 0#)
16:10:30 <dons>             w1    = W8# (ba `indexWord8Array#` 1#)
16:10:32 <dons>             w2    = W8# (ba `indexWord8Array#` 2#)
16:10:34 <dons>             w3    = W8# (ba `indexWord8Array#` 3#)
16:10:37 <dons>         in (w0, w1, w2, w3)
16:11:10 <Heffalump> drop me an email to ganesh@earth.li and I'll send it to you tomorrow
16:11:50 <Darius> "Fleat is implementation defined"
16:11:55 <Darius> s/Fleat/Float
16:19:24 <stepcut> dons, thanks! That should do for now
16:19:50 <stepcut> I can be non-H98 for a few days :)
16:20:31 <Heffalump> if Float is implementation defined then my version is not much better than the above
16:20:37 <Heffalump> since it's not guaranteed to work by H98
16:21:36 <Darius> Heffalump: Throw an isIEEE in front of it and puke when False.
16:21:54 <Heffalump> fair enough
16:35:57 <stepcut> I don't have to use a Float on the haskell side if there is a better choice
16:36:39 <dons> stepcut: I couldn't get the above code to be invertable, but here's a cleaner version that does reconstruct the original float correctly: http://www.cse.unsw.edu.au/~dons/t.hs
16:37:13 <dons> $ ./a.out
16:37:13 <dons> 7777.0
16:37:13 <dons> (69,243,8,0)
16:37:14 <dons> 7777.0
16:37:16 <dons> :)
16:37:25 <stepcut> cool
16:38:08 <dons> the low-level primop evil code was going: 7777.0 -> (184,113,11,0) -> 1.050985e-39
16:38:34 <dons> and occasionally spitting out: bad register name `%st(-7) :/
16:40:04 <stepcut> eek
16:40:08 * Darius thinks he knows what's going on there.
16:40:18 <Darius> That's great
16:41:13 <dons> Darius?
16:41:32 <Darius> So stepcut, I think that definitely answers your question about the safety of unsafeCoerce#
16:41:38 * Darius thinks it was stepcut.
16:41:43 <Darius> dons: ? ?
16:42:44 <dons> unsafeCoerce# is alright, but you have to remember the machine representation of your type.
16:42:59 <dons> so it works really well for Word8 ops, which always succeed.
16:43:06 <dons> then it just comes down to bit fiddling, sigh.
16:43:17 <Darius> dons: But the machine representation isn't necessarily maintained even within a single program.
16:43:37 * Darius never got to like most forms of bitfiddling.
16:43:54 <dons> of unboxed values, it is, surely.
16:44:10 <stepcut> bitfiddling is a pain, especially in haskell
16:44:23 <Darius> It's fairly horrible in Haskell *sigh*
16:44:45 <dons> especially in haskell? I don't know, the Bits library is pretty clean.
16:44:55 <Darius> However, part of that may just be contrast.
16:45:09 <dons> yeah.
16:45:21 * stepcut ponders
16:46:06 <dons> you get struck with the realisation that C programmers only think about the machine representation of their type.
16:46:14 <stepcut> well, dealing with things like network packets, where you can just use a struct in C is a lot more work in haskell
16:46:14 * Darius should make type level bit specifications to "automatically" make bitfiddling functions.
16:46:44 <dons> that would be pretty cool.
16:46:49 <Darius> In theory you can't use a struct, in practice it's damn convenient.
16:48:27 <dons> Darius, you mean like :: forall w0 w1 . ((w1 `ShiftL` 8_T) :.|. w0)
16:48:56 * dons lifts W8# to the type level :}
16:49:45 <Darius> dons: I'd probably look at Erlang's bit syntax stuff for inspiration.
16:50:48 <dons> twelf/LF-y dependent types gets addictive ;)
16:51:39 * Darius was thinking of playing with such systems or more Martin-Loef (like Agda) very recently.
16:51:51 * Darius isn't too into dependent types for programming though.
16:51:56 <Darius> (at this point)
16:53:30 <dons> it's much fun encoding proofs of, say, safe indexation into an expression's type in LF, though the types get pretty big, pretty fast.
16:54:15 <stepcut> Darius: a while ago Tomasz Zielonka/deser did something that turned Records into parsers, or something like that
16:54:45 <stepcut> so, you could defined a Record, and then use TH to automatically generate a parser for that record
16:54:50 <Darius> stepcut: I wouldn't be surprised if it's already done.  At any rate, the idea isn't new.
16:55:02 <stepcut> but, he never did it at the bit-level, only byte level
16:55:04 <Darius> Pssh, forget TH.  Type level meta programming ho!
16:55:32 <stepcut> the problem I have with the .swf stuff is it isn't even byte aligned
16:55:44 <dons> type level metaprogramming at runtime using dynamic types, yeah yeah!
16:56:08 <Darius> For this application it would seem most of the bit-formats are statically known.
16:56:16 <stepcut> you have a stream of bits, and many of the values are 6-bits, or even a variable number of bits long, with no padding between then
16:57:19 <Darius> There's probably a C++ template metaprogram that does such a thing as well, if not there should be.
17:01:55 <stepcut> the sizes are know, there are just a lot of them, so it is tedious to write all the encoders
17:02:30 <stepcut> and writing encoders, does not provide a way to automatically generate decoders
17:02:44 <stepcut> so to read stuff back in, I would have to write everything a second time...
17:03:13 <stepcut> of course, decoders are even trickier if the input can have errors
17:05:27 <Darius> stepcut: Have you looked at Erlang's bit syntax?
17:07:44 <Darius> A link if the answer is no: http://www.erlang.se/euc/00/bit_syntax.html
17:08:18 <dons> hmm. with -O the bit fiddling program generates invalid C: ((StgFloat)7777.0) & 0xff;
17:08:33 <dons>  error: invalid operands to binary &
17:08:50 <dons> there's a missing (W_) cast.
17:10:27 <dons> hmm. and with -O -fasm we get: bad register name `%fake0'
17:10:31 <dons> with ghc-6.4
17:10:47 <stepcut> Darius: yes, a bit (hahaha)
17:11:13 <dons> I don't think we should be producing compiler failures, even if we throw unsafeCoerce# around (?)
17:11:35 <stepcut> Darius: I hope to look into bit twiddling a fair bit later this year, many things I want to do seem to involve it
17:11:51 <stepcut> Darius: like decode/encode file formats, network packets, etc
17:12:12 <stepcut> Darius: and doing it 'by hand' is just to error prone and time consuming
17:12:17 <Igloo> I'd agree, dons
17:12:44 <dons> Igloo: ok. I'll send it to bugs@
17:12:55 <dons> the %fake0 is certainly wrong.
17:13:04 <stepcut> haha
17:14:05 <Igloo> Tsk, trust you to find bugs days before release  :-)
17:14:13 <dons> bah!
17:14:51 <dons> I'm more concerned about what spj will say if he sees his lovely language being used this way ;)
17:15:22 <SyntaxNinja> <-- is also busy abusing the language
17:15:42 <Darius> SyntaxNinja: Oo, what are you doing?
17:15:43 <SyntaxNinja> I'm going to argue that there's no such thing as idiomatic haskell ;)
17:16:10 <SyntaxNinja> what I'm doing is probably a secret :( I should really find out...
17:16:33 <Igloo> Heh
17:16:47 <int80_h> does he have a weak heart?
17:29:37 <dons> ah ha! -dcmm-lint picked up a type error :)
17:29:48 <dons> hooray for typed low-level representations
17:29:56 <dons> Cmm lint error:
17:29:56 <dons>   in proc s2D4_ret
17:29:56 <dons>     in basic block c2F7
17:29:56 <dons>       in MachOp application:
17:29:57 <dons>         7777.0 :: F32 & 255
17:59:27 <shapr> That's a nice nickname.
17:59:32 <mugwump> why thank you
17:59:45 <mugwump> I'll whip you up some jism later if you ask nicely
17:59:49 <mugwump> but for now,
17:59:51 <shapr> er?
18:00:08 <int80_h> mugwump is a literary reference
18:00:11 <mugwump> how do I cast to type `t' ?
18:00:21 * int80_h salutes mugwump .
18:00:48 <autrijus> mugwump: you do it via "error"
18:01:01 <autrijus> (technicall correct answer, but likely not what you want)
18:01:38 <dons> clearly you do it with unsafeCoerce#
18:01:56 <Darius> @type undefined :: a -> t
18:02:01 <autrijus> clearly you do it with "undefined"
18:02:03 <lambdabot> undefined :: a -> t :: forall t a. a -> t
18:02:08 * int80_h tells mugwump to go see the fucking parrots, kiki.
18:02:14 * int80_h giggles
18:02:26 <int80_h> that was like my favorite line formt he movie
18:02:26 <autrijus> even more clearly you do it via porting your code to Scheme
18:02:34 <int80_h> fromt he
18:02:52 <dons> or asm, that's fairly good for this problem
18:02:59 <autrijus> mugwump: in all seriousness, "t" is not a type; it's a type variable
18:03:13 <autrijus> so your question amonts to "how can I defeat the type checker and cast to any type at all"
18:03:24 <autrijus> which neds to absurd answers above.
18:03:28 <autrijus> s/absurd/radical/
18:04:22 <Itkovian> autrijus, nice interview ...
18:04:25 <mugwump> ah, I see :)
18:04:47 <mugwump> I thought it was some array subscript type, as I tried:
18:04:53 <mugwump> op2Substr s i = return $ s!![ i ..]
18:04:59 <mugwump> &got:
18:04:59 <mugwump>     Couldn't match `Int' against `[t]'
18:05:49 <mugwump> maybe I should stop tinkering with things I know nothing about rather than just throwing cookbook pieces together
18:05:54 <mugwump> er
18:06:15 <int80_h> save the psychpo
18:06:17 <int80_h> erm
18:06:29 <int80_h> save the psychoanalysis for your grasshopper friends
18:06:51 <autrijus> Itkovian: thanks :)
18:07:25 <autrijus> mugwump: that message means "you can't use a Int as a list"
18:07:30 <autrijus> "[t]" means "a list"
18:08:01 <autrijus> and the reason you see that
18:08:11 <autrijus> is that you got the sides of !! reversed.
18:08:36 <autrijus> it's list!!item not list!!list
18:08:39 <autrijus> nor item!!list
18:08:47 <autrijus> i.e. !! can only take one thing, not many.
18:09:05 <autrijus> so somethinglike: map (s!!) [i..length s]
18:09:07 <autrijus> or better:
18:09:20 <autrijus> drop i s
18:09:43 <stepcut> argh, found a bug in the .swf spec :)
18:13:29 <Itkovian> hmm ... I'm using (filter isJust $ munge parsed_cmid parsed_method benchmark_name cmids) where I declare munge :: [(String, String)] -> [(String, (Integer, Integer, Double))] -> String -> [String] -> [Maybe (String, String, Integer, Integer, Double), but the type system complains that it expects a a instead of Maybe a
18:13:53 <Itkovian> in the second arg of ($), ie. in (munge parsed_cmid parsed_method benchmark_name)
18:14:18 <Itkovian> the inferred type is wqhat I'd expect, but the expected type seems all wrong
18:14:59 <Itkovian> help :-)
18:16:42 <autrijus> what if you annotate the munge part with its expected type?
18:16:57 <autrijus> (munge pc pm b c :: [Maybe (String, String, Integer, Integer, Double)])
18:17:02 <autrijus> and see if it agrees
18:17:50 <Darius> @type filter Data.Maybe.isJust
18:17:51 <lambdabot> filter Data.Maybe.isJust :: forall a. [Maybe a] -> [Maybe a]
18:18:40 <Darius> Itkovian: What's the context of the code?  You aren't expecting filter to have type [Maybe a] -> a are you?
18:18:52 <autrijus> or [Maybe a] -> Maybe a
18:18:55 <autrijus> for that matter.
18:19:09 * Darius meant [Maybe a] -> [a]
18:19:38 <Darius> There's a function that seems more like what you want in Data.Maybe
18:19:41 <autrijus> @type catMaybes
18:19:42 <lambdabot> bzzt
18:19:47 <autrijus> @type Data.Maybe.catMaybes
18:19:48 <lambdabot> Data.Maybe.catMaybes :: forall a. [Maybe a] -> [a]
18:19:54 * autrijus smiles
18:21:02 <Darius> Or a sleek list comprehension [a | Just a <- munge pc pm b c]
18:21:11 <Darius> Though I'd probably use catMaybes.
18:21:22 <autrijus> catMaybes sounds saner.
18:21:29 <autrijus> it's all about sanity :)
18:21:35 <Itkovian> ah catMaybes seems neat.
18:22:02 <Itkovian> nice than map fromJust . filter isJust :-)
18:22:05 <Itkovian> *nicer
18:25:19 <autrijus> although, given fusion, that is probably exactly the same thing underneath :)
18:29:56 <dons> pretty easy to check, crank up -O and -ddump-simpl
18:44:54 <bloomberg> is there any way, in a list comp, to range values from the reverse, eg [x|x<-[10..downto..1]]?
18:46:34 <heatsink> You can make an infinite decreasing list with iterate (\a -> a - 1)
18:46:41 <SamB> [x | x <- [10,9..1]] or [x | x <- reverse [1..10]]
18:46:44 <bloomberg> no not infinite
18:47:04 <heatsink> You can then use (take 10) to get only the first ten elements of that list
18:47:07 <bloomberg> as im trying 2 improve the speed of a prog, i dunno whether reverse is a good idea
18:47:35 <SamB> [10,9..1] then?
18:47:56 <heatsink> Oh, interesting.
18:48:18 <Darius> bloomberg: The generators in list comprehensions are arbitrary expressions.
18:48:44 <bloomberg> ok
18:49:02 <SamB> although, since Haskell 98, they must be lists
18:50:55 <heatsink> Apparently the notation doesn't work for all instances of Enum.
18:51:08 <SamB> heatsink: oh?
18:51:25 <heatsink> Yea, I just tried it.
18:51:32 <SamB> With what?
18:51:53 <heatsink> data Day = Monday | Tuesday | (more days) deriving (Show, Enum)
18:52:03 <heatsink> [Monday..] is a parse error
18:52:11 <Darius> [Monday ..]
18:52:44 <heatsink> Oh.
18:52:46 <Darius> You need to fix the Haskell lexer in your head.
18:52:56 <SamB> thats because Monday.. would be an operator in the module Monday!
18:53:29 <heatsink> hmm.
18:53:43 <SamB> and operators need to be parenthesized to stand by themselves
18:54:05 <SamB> see,
18:54:05 <SamB> Prelude> [(Monday..)]
18:54:05 <SamB> <interactive>:1:
18:54:05 <SamB>     Failed to load interface for `Monday':
18:54:05 <SamB>         Could not find interface file for `Monday'
18:54:06 <SamB>         (use -v to see a list of the files searched for)
18:54:08 <SamB> <interactive>:1: Variable not in scope: `Monday..'
19:06:13 <Lemmih> Fuck. What's the prefered way to commit suicide after doing 'rm *.hs' (tried to write *.hc)?
19:06:42 <Pseudonym> Seppuku, I think.
19:06:58 <SamB> look through for *.hs~?
19:07:09 <Pseudonym> Or .*.hs.swp
19:09:37 <Lemmih> Did that. Looses are still severe. );
19:10:01 <SamB> Lemmih: do you have .hi files to recover types from?
19:10:17 <Pseudonym> Oh, you could restore from backup.
19:10:20 <Pseudonym> You keep backups, right?
19:10:40 <SamB> Pseudonym: you are kidding, right?
19:10:48 <Pseudonym> Or update again from CVS/darcs.
19:10:55 <Lemmih> Pseudonym: I did when I ran Gentoo but sendmail is really bitchy on Debian.
19:11:04 <Pseudonym> SamB: The truth hurts sometimes. :-)
19:11:34 <SamB> Pseudonym: what is that supposed to mean?
19:12:01 <Pseudonym> SamB: It';s one of those things we're supposed to do but never do.;
19:12:22 <SamB> What are we even supposed to use for backup media these days?
19:12:25 * Lemmih misses the friendliness of Gentoo );
19:12:29 <keverets> apt-get install rsnapshot
19:12:36 <Pseudonym> CDRs are cheap.
19:12:47 <SamB> CDRs only hold 700 MiB
19:12:50 <Pseudonym> But I tend to use other machines.
19:13:00 <Pseudonym> Just as well they're cheap, then.
19:13:01 <keverets> http://www.rsnapshot.org/ (saved myself a couple of times already)
19:13:13 <Lemmih> shapr: I need Debian support.
19:13:19 <SamB> and they are a real pain to shuttle about
19:13:39 <Pseudonym> And you don't need to back up your operating system, though /etc wouldn't go astray.
19:13:39 <keverets> Lemmih: what kind of support do you need?
19:13:40 <SamB> what with tray-loading, and all.
19:14:17 <SamB> Pseudonym: where are you going to get those versions of the packages from?
19:15:37 <SamB> I think Plan 9 has the nearest approximation to a decent backup system I've seen yet...
19:16:15 <Lemmih> keverets: I can't send mails via sendmail. I want it to run in client mode, sending mails to a smtp server but I'm experiencing problems I can't understand.
19:17:09 <Pseudonym> SamB: Sorry?
19:17:30 <Pseudonym> You can install your OS from media or network.
19:17:41 <Pseudonym> And all of the packages, assuming a decent package system.
19:17:53 <keverets> Lemmih: do you need a full smtp server locally, then?  Could you use ssmtp?
19:18:00 <SamB> Pseudonym: that works fine if you are using stable, and not using non-standard packages!
19:18:26 <Darius> Having your code in a RCS is not a bad idea if it's worth keeping.
19:18:34 <SamB> (for which the servers may have disappeared)
19:19:24 <Lemmih> keverets: I would like to send mails through my gmail account.
19:20:19 <SamB> Lemmih: you are going to need some interesting hacks to do that
19:21:27 <Lemmih> SamB: How so?
19:21:50 <SamB> Lemmih: don't tell me gmail provides pop3/smtp access now?
19:22:03 <SamB> or maybe imap?
19:22:31 <Lemmih> SamB: They've been offering pop3/smtp for quite some time.
19:22:49 <SamB> oh. maybe I was thinking of using it as a filesystem, then
19:23:21 <bloomberg> ok so in a list comp i am generating an array of pairs (Bool,int) in which i only want it to evaluate Int if Bool is TRue. currently i have [(i,j),(if foo then bar else baz,{help needed})|i j range stuff]. can i avoid testing foo again in the {help needed} section?
19:25:21 <bloomberg> any thoughts?
19:25:43 <Darius> bloomberg: To start, list comprehensions make lists not arrays.
19:26:30 <Darius> bloomberg: I also don't know what you mean by "I only want it to evaluate Int if Bool is True"
19:28:15 <bloomberg> well i only want to run the function that works out this integer if the first part of the pair is true
19:29:24 <bloomberg> does haskell have elseif btw?
19:29:36 <Darius> Just use 'else if'
19:30:01 <Darius> bloomberg: If the Bool is False what do you do?  You need to provide an Int.
19:30:26 <metaperl> I need help on exercise 2.8 in "Algorithms" : define a function rep using a list comprehension such that rep n repeats 1 1 times, 2  2 times and so on up to n n times. e.g.: rep 4 = [1,2,2,3,3,3,4,4,4]
19:31:10 <Darius> Shouldn't you have an extra 4?
19:31:11 <SamB> bloomberg: anything that isn't forced won't be evaluated
19:31:27 <bloomberg> no i just set it to -1
19:31:48 <bloomberg> but the point is in the second half of the pair, i dont want to run the test foo again if possible
19:31:52 <Darius> bloomberg: Ugh.  I suggest using Maybe
19:32:03 <bloomberg> do you get my drift?
19:32:26 <Darius> bloomberg: Why don't you show your code?  I think I understand what you want, but I'm not sure if that's really what you want.
19:32:35 <bloomberg> ok
19:33:40 <Darius> metaperl: Where are you now and what in problem in particular are you having?
19:34:04 <metaperl> well I tried to create auxilliary functions
19:34:35 <metaperl> because a fundamental aspect of this problem is to create a list of length L consisting of a single value V
19:34:42 <metaperl> makelis L V
19:35:39 <Darius> metaperl: Not that implementing the functions on your own isn't educational, but (to give the old chestnut) you may really want to browse through the Prelude and standard libraries (either now or after this exercise).
19:36:10 <metaperl> makelis 0 _ = []
19:36:10 <metaperl>  
19:36:10 <metaperl> makelis l v = v:(makelis (l-1) v)
19:36:33 <metaperl> what's the easiest way to do that (browse through the Prelude) ?
19:37:24 <Darius> Seriously, looking at the Prelude and List sections in the Haskell Report may be enough.
19:37:42 <Darius> Or at least let you see what's there and you can look for other sources for more explanation.
19:38:16 <Darius> metaperl: But anyways, continue with the exercise
19:38:51 <Darius> (And just because I'm nitpicky about this, makelis l v = v:makelis (l-1) v parses the same)
19:38:57 <metaperl> makelis 0 _ = []
19:38:58 <metaperl>  
19:38:58 <metaperl> makelis l v = v:(makelis (l-1) v)
19:38:58 <metaperl>  
19:38:58 <metaperl>  
19:38:58 <metaperl> mkls len = [ z | y <- [1 .. len], z <- makelis y y ]
19:39:01 <metaperl> I did it
19:39:11 <metaperl> but I dont understand how z was flattened
19:39:28 <metaperl> it should have come out [ [1], [2,2] , [3,3,3] ]
19:39:31 <metaperl> for mkls 3
19:40:26 <metaperl> why did the list comprehension flatten the lists generated by makelis into one flat list instead of like I have it here?
19:41:57 <Darius> The code you wrote is roughly foreach y in 1..len { foreach z in makelis y y { result := z:result } }. It didn't flatten the lists, but rather you are making a single list (makelis y y) and extracting each element (z) of it for each y in [1..len].
19:47:18 <metaperl> oh, you are saying that a list comprehension works by consing. but that makes no sense to me. [1]:[2,2]:[3,3,3]
19:48:10 <metaperl> maybe Gentle has a definition of how list comprehension works and then this will make sense to me
19:48:32 <Darius> You missed the point that 'z' is ranging over the -elements- of makelis y y, makelis 2 2 is [2,2] so 'z' is 2 then 2, not [2,2].
19:49:00 <Darius> Nested generators are much like nested loops.
19:49:10 <metaperl> ahhhhhhhhhhh
19:49:13 <metaperl> that's right
19:49:18 <metaperl> they certainly are
19:50:12 * metaperl re-examines his tripped-upon solution :)
19:51:54 <metaperl> now, all is clear. Thank you Darius
19:52:23 <autrijus> and parallel generators are much like zipped loops.
19:52:34 * autrijus decides to not scare metaperl with parallel generators yet
19:52:36 <metaperl> I have the Debian install of ghc6... the prelude is not available in source form is it?
19:52:44 * metaperl thanks autrijus
19:52:55 <autrijus> metaperl: see the Report for prelude definitions
19:53:02 <metaperl> ok
19:58:54 <Darius> metaperl: The particular function that prompted me to comment is makelis = replicate.  Also my first reflex for implementing mkls would probably be mkls len = concatMap (\x -> replicate x x) [1..len] (or point-free mkls = concatMap . (\x -> replicate x x) . enumFrom 1 or CT style mkls = concatMap . uncurry replicate . dup . enumFrom 1) which you're version desugars to.
19:59:40 * Darius tends to build up to solutions in terms of combinators and so typically doesn't use list comprehensions
20:00:19 <metaperl> Cale's article on Monads as Containers is excellent. I havent gotten back to finishing it, but if you take it slow, it makes perfect sense
20:02:17 <Darius> I personally don't find the view of Monads as Containers very illuminating or representative.
20:03:07 <autrijus> I think Monads are Action Legos.
20:03:18 <autrijus> that's how they fit in my mind anyway
20:03:24 <autrijus> "Mindstorm legos"
20:18:12 <metaperl> I need help writing a function which takes a string consisting of digits and turning it into a number
20:18:13 <metaperl> string2int str = foldr (+) 0 [ q |  <- [(length str)-1 .. 0], e <- 10 ^ m, q <-\
20:18:13 <metaperl>  str!!((length str)-1)*m ]
20:18:25 <autrijus> string2int = read
20:18:26 <autrijus> ;)
20:18:31 <metaperl> string2int str = foldr (+) 0 [ q |  <- [(length str)-1 .. 0], e <- 10 ^ m, q <- str!!((length str)-1)*m ]
20:18:33 <metaperl> lol
20:18:38 <metaperl> we cant cheat like that
20:18:44 <metaperl> we have to use digitToInt
20:18:50 <metaperl> or something like that
20:18:58 <autrijus> string2int = const read digitToInt
20:19:02 * autrijus grins
20:19:27 <metaperl> const? hmmm
20:19:34 <autrijus> @type const
20:19:36 <lambdabot> const :: forall a b. a -> b -> a
20:20:11 <metaperl> omg
20:20:13 <metaperl> funny
20:21:09 <heatsink> metaperl: you function will probably look nicer if you rewrite it so that it doesn't need (!!).
20:21:21 <metaperl> it doesnt parse
20:27:45 <metaperl> how do you build a list going from 10 to 0?
20:28:13 <autrijus> reverse [0..10]
20:28:24 <autrijus> [10,9..0]
20:28:29 <metaperl> i see
20:31:35 <metaperl> i'm getting a type error on this: string2int str = [ e | m <- (reverse [0 .. (length str)-1]) , e <- 10 ^ m ]
20:31:52 <heatsink> where does it say the type error is?
20:33:13 <metaperl>  No instance for (Num [t])
20:33:13 <metaperl>       arising from use of `string2int' at <interactive>:1
20:33:13 <metaperl>     In the definition of `it': it = string2int "5427"
20:33:31 <metaperl> it has to be in e <- 10 ^ m
20:33:36 <metaperl> because that it what I just added
20:33:50 <heatsink> No...
20:34:02 <heatsink> The problem is that it can't figure out what numeric type your numbers should be
20:34:39 <heatsink> oh, no, I misread the error.
20:35:39 <metaperl> i'm just taking a list of integers and exponentiating each one.
20:36:00 <metaperl> and the result of each exponentiation goes into the list
20:36:04 <metaperl> i dont know what the problem could be
20:37:42 <heatsink> oh, of course
20:37:47 <heatsink> what type is m?
20:38:42 <metaperl> heatsink, a whole number
20:38:43 <heatsink> what type is (10 ^ m)?
20:38:52 <metaperl> integer to I suppose
20:38:58 <metaperl> integer too
20:39:57 <heatsink> So, e <- (10^m) iterates over what?
20:42:24 <metaperl> integers
20:42:31 <metaperl> creating a list of integers
20:42:53 <heatsink> But 10^m is not a list of integers.
20:43:05 <heatsink> It is one integer.
20:44:36 <heatsink> The <- arrows on the right hand side don't create lists.  They take items one at a time from lists.
20:44:57 <heatsink> ...on the right side of a list comprehension...
20:44:59 <metaperl> but m is each of the the list [ 0 .. ((length str) -1) ]
20:45:41 <heatsink> yes, m is each number in the list.
20:46:12 <heatsink> First it is (length str) - 1
20:46:13 <metaperl> and 10 ^ m is 10 to the power of m
20:46:16 <metaperl> yes...
20:46:20 <heatsink> Next it is (length str) - 2
20:46:22 <metaperl> then so on down to 0
20:46:30 <heatsink> right.  But none of those values are lists.
20:47:56 <metaperl> I'm missing something.
20:48:05 <heatsink> you have e <- 10^m
20:48:21 <metaperl> the goal is to loop over each value of m and feed it to the expression 10 ^ m
20:48:22 <heatsink> Which means, take each value in the list (10^m), and assign that value to e in sequence.
20:48:33 <metaperl> and take each result of 10 ^ m and put it in an output list
20:48:36 <heatsink> But 10^m is not a list so you get a type error.
20:48:44 <metaperl> oh!
20:48:49 <metaperl> ah!
20:49:37 <metaperl> string2int str = [ 10 ^ m | m <- (reverse [0 .. (length str)-1])  ]
20:49:39 <metaperl> thanks
20:49:41 <heatsink> yes.
20:49:41 <metaperl> heatsink
20:49:50 <metaperl> now for my fina lstesp
20:53:10 <heatsink> infixl ^.^
20:56:58 <metaperl> and now I present to you the world's most roundabout attempt ever to convert a string of digits to an integer: string2int str = foldr (+) 0 [ digitToInt(str!!(((length str)-1)-m)) * 10 ^ m | m <- (reverse [0 .. (length str)-1])  ]
20:57:06 <metaperl> it _does_ work :)
20:57:28 <metaperl> improvements welcome ;)
20:59:41 * heatsink enters metaperl's function into the IOHCC contest ;)
21:00:21 <SamB> heatsink: is that even still happening?
21:00:27 <heatsink> no idea.
21:01:01 <SamB> isn't sum = foldr (+) 0?
21:01:15 <heatsink> metaperl: In the list comprehension, you're using [str!!0, str!!1, str!!2, ...]
21:01:48 <heatsink> You should put that on the RHS of the list comprehension.
21:02:33 <heatsink> (c, m) <- zip str (reverse [0 .. (length str)-1])
21:02:49 <bloomberg> whats the cause of a "Segmentation fault" in hugs?
21:03:01 <desrt> bloomberg; a bug in hugs
21:03:08 <bloomberg> really?
21:03:11 <bloomberg> so its not my code?
21:03:14 <desrt> yes.  it's definitely not your fault
21:03:43 <desrt> there are certain kinds of code that can cause it to happen, though
21:03:46 <bloomberg> you quite sure? this code is very iffy
21:03:58 <SamB> if it was your fault, you ought to know
21:04:01 <desrt> like if the stack gets too big, i think hugs doesn't deal with that very well
21:04:18 <SamB> did you use unsafe*?
21:04:37 <bloomberg> no wats that?
21:04:50 <desrt> did you use FFI? ("import")
21:05:04 <SamB> (that is, unsafePerformIO)
21:05:06 <desrt> these are both ways to make hugs crash without it being hugs fault :)
21:05:08 <bloomberg> yes its importing Array and another file
21:05:22 <desrt> oh.  no.  not that import
21:05:27 <desrt> foreign import
21:05:38 <desrt> you're basically not doing anything bad
21:05:49 <desrt> SamB; unsafePerformIO isn't capable of making things crash
21:05:53 <desrt> SamB; not on its own, anyway
21:06:06 <bloomberg> ok
21:06:14 <SamB> desrt: I heard you could use it to do casting or something like that
21:06:29 <desrt> SamB; you can, but you require additional evil functions
21:06:45 <desrt> all unsafePerformIO does is give you an instance of the IO monad
21:06:52 <desrt> which you already have in 'main' anyway
21:08:19 <dons> yeah, if you don't use the ffi, or unsafe* stuff, then the type system guarantees no seg faults, barring running out of memory, or some evil interaction with the outside world (sending kill to yourself)
21:09:09 <dons> dynamic loading is another way to shoot yourself, too. jumping to illtyped dynloaded code is a sure way to blow up
21:09:19 <bloomberg> actually i think im referencing an array element (i,j) in the definition of that (i,j)
21:09:36 <desrt> bloomberg; Data.Array is safe
21:10:08 <dons> like SamB says, you ought to know if you did something evil
21:10:29 <desrt> :)
21:11:06 <desrt> wolfgang has this great piece of code that :: Integer
21:11:09 <desrt> it returns 42
21:11:14 <desrt> it's -so- evil
21:11:14 * dons equates moral wrong with breaking the type system for about the 3rd time today.
21:11:23 <dons> hehe
21:11:51 <desrt> it uses unsafeSomethingOrOther to load some powerpc assembly instructions into memory and execute them
21:11:58 <heatsink> getProcessID >>= (\x -> openFile WriteMode ("/proc/" ++ show x ++ "/mem"))
21:12:10 <dons> desrt: oh, really? that's really evil
21:12:17 <desrt> dons; ya.  it's great :)
21:12:18 <ozone> sounds like don and wolfgang really need to meet up
21:12:38 <heatsink> cool.
21:13:29 <dons> I spent a few hours once trying to work out how to jump to arbitrary code in pure haskell, and only ended up able with http://www.cse.unsw.edu.au/~dons/run_haskell.c
21:13:50 <dons> so maybe wolfgang has some nice tricks
21:14:04 <desrt> it has a pure type but it uses unsafe*
21:14:10 <desrt> so it's not really pure
21:14:34 <dons> yeah. it's lots of fun :) the main challenge is trying not to segfault
21:14:42 <dons> and working out what the rts is really doing
21:15:12 <stepcut> hooray! my scheme->flash compiler can now handle, (set! dynText ((lambda (x) (if x "true" "false")) 1))
21:15:21 <desrt> did you encode your program in decimal specifically to be a jerk? :)
21:15:53 <metaperl> heatsink, I dont understand your RHS comments
21:16:20 <metaperl> oh I get it
21:16:35 <stepcut> unfortunately, I can only do one branch instruction right now because it always uses the same label for the destination of the jump :)
21:17:47 * dons -> got to go :)
21:17:57 <stepcut> dons: thanks for your help earlier
21:18:57 <metaperl> heatsink: got it. thanks
21:18:58 <metaperl> string2int str = foldr (+) 0 [ digitToInt(c)*  (10^m)   | (c, m) <- zip str (reverse [0 .. (length str)-1]) ]
21:26:06 <heatsink> How to desugar this arrow code?  proc a -> do f a <- ();
21:26:41 <SamB> heatsink: you could run it through the preprocessor
21:26:53 <heatsink> How do I do that? I've been using ghc -farrow
21:28:23 <SamB> heatsink: maybe you should look on the arrows site?
21:29:15 <heatsink> I found it.
21:38:08 <heatsink> oh, there's a function called app to do that.
22:36:15 <musasabi> ,prmomg
22:40:49 <heatsink> gppd ,prmomg. ,isasabo/
22:52:20 <heatsink> 116 columns of whitespace at the beginning of the line, yay.
22:56:34 <musasabi> morning heatsink
22:57:43 <heatsink> actually, I just finished coding and am now going to bed.
22:57:53 <heatsink> good morning.
