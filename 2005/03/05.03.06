00:57:51 <Lemmih> Good morning, #haskell.
01:18:10 <MachinShin> night all
02:38:47 <_JusSx_> i got this error
02:38:51 <_JusSx_> Variable not in scope: `false'
02:39:01 <_JusSx_> why? which module is it in?
02:40:16 <Lemmih> You probably meant 'False'.
02:43:13 <_JusSx_> ok thanx i solved
02:44:29 <_JusSx_> can list elements be function?
02:44:53 <boegel> _JusSx_: sure
02:44:53 <Lemmih> Sure.
02:44:59 <_JusSx_> ok
02:45:00 <Lemmih> boegel: I WIN!
02:45:08 <boegel> Lemmih: nah :p
02:45:10 <_JusSx_> ok so ocaml
02:45:14 <_JusSx_> but one question
02:45:15 <boegel> in my client I win ;)
02:45:31 <_JusSx_> in toplevel i can' show it right?
02:45:39 <Lemmih> Really? Then we both win.
02:46:12 <Lemmih> _JusSx_: Show a function?
02:46:31 <_JusSx_> for example [ map ]
02:46:47 <_JusSx_> i got an error
02:46:52 <_JusSx_> No instance for (Show ((a -> b) -> [a] -> [b]))
02:47:19 <Lemmih> What did you expect?
02:47:27 <_JusSx_> ocaml works different
02:47:54 <Lemmih> You can make ((a->b) -> [a] -> [b]) an instance of show.
02:48:07 <_JusSx_> yeah i know
02:48:09 <Lemmih> Aren't you just interested in the type?
02:51:12 <Itkovian> what is the correct way to model a waterfall of case .. of stuff where each case distiguishes between Just x and Nothing?
02:51:46 <Cale> Itkovian: Use Maybe as a monad?
02:52:10 <Itkovian> Cale, yes, and how do I fit the code for the Just case in there?
02:52:27 <Cale> hm?
02:52:49 <Itkovian> I'm on a bloody wonblows machine, so pasting here or aywhere else won't work.
02:52:58 <Itkovian> but the idea is something like
02:53:19 <Itkovian> case lookupFM cMap c of
02:53:25 * boegel waves at Itkovian 
02:53:32 <Itkovian> Just x -> case lookupFM xMap x of
02:53:46 <Itkovian> Just (f,g,h) -> blahblah x f g h
02:53:54 <Itkovian> Nothing -> error "oops1"
02:54:07 <Itkovian> Nothing (for the prev case) -> error "oops2"
02:54:08 <Lemmih> Itkovian: do { x <- lookupFM cMap c; (f,g,h) <- lookupFM xmap x; ...}
02:54:13 * Itkovian waves back
02:54:42 <Itkovian> Lemmih, and where does the error code come in there?
02:55:15 <Lemmih> Itkovian: It evaluates to Nothing if either of the lookups fail.
02:55:23 <Cale> Itkovian: you possibly want the Error monad
02:55:38 <Itkovian> ok.
02:55:43 <Itkovian> Let me read the docs for that
03:00:49 <Itkovian> hmm
03:07:01 <_JusSx_> what does ' mean?
03:07:09 <_JusSx_> my_sum [] = 0
03:07:09 <_JusSx_> my_sum l@(x:xs) = helper' 0 l
03:07:09 <_JusSx_>     where helper' k (x:xs) = helper' (k+x) xs
03:07:11 <_JusSx_> 	  helper' k [] = k
03:07:22 <_JusSx_> why is ' used in helper function?
03:07:59 <xerox> _JusSx_, mathematical retail, it's just a valid character in symbol names.
03:08:08 <_JusSx_> ah ok
03:08:14 <_JusSx_> thanx xerox
03:08:53 <Itkovian> _JusSx_, it's as if you'd type _ but then nicer to read imo
03:11:22 <_JusSx_> and @?
03:11:30 <_JusSx_> labelled variables?
03:11:40 <_JusSx_> l@(x::xs)
03:11:48 <_JusSx_> l is the list x:xs
03:12:05 <xerox> It's an alias, yep.
03:12:10 <_JusSx_> thanx
03:25:11 <scalopus> hi
03:28:30 <Lemmih> Hey
03:29:28 <boegel> hey scalopus
03:30:17 <xerox> yo
03:31:20 <boegel> join #c
03:31:23 <boegel> woops :s
03:32:39 <Muad_Dibber> #c :P
03:33:39 <boegel> Muad_Dibber: I need to ask something for uni, don't blame it on me :p
03:38:57 <Muad_Dibber> boegel: i blame your uni then :P
03:38:58 <Muad_Dibber> c :P
03:38:59 <Muad_Dibber> pfft
03:39:00 <Muad_Dibber> ;
03:39:03 <Muad_Dibber> )
03:39:53 <boegel> Muad_Dibber: it's for a course on compilers...
03:40:39 <Muad_Dibber> boegel: you giving that course or following it?
03:41:09 <boegel> Muad_Dibber: heh, following it :)
03:41:22 <boegel> I don't teach courses, I'm still a poor, dumb student
03:42:52 <Muad_Dibber> boegel: we have something called student assistants ;)
03:46:11 <boegel> Muad_Dibber: Phd students then, right ?
03:47:24 <musasabi> good day.
03:47:26 <Muad_Dibber> boegel: depending on the where the course was
03:47:28 <Muad_Dibber> *is
03:47:33 <musasabi> any nice code recently?
03:47:42 <Muad_Dibber> i mean, the bachelor part (first 3 years) has student assistants from upper years
03:48:15 <boegel> Muad_Dibber: oh, I see
03:48:34 <boegel> at out uni, only Phd students assist courses (as far as I know)
03:49:25 <boegel> anyway, I should get going...
03:49:30 <boegel> lots of work to do
03:49:31 <boegel> bye !
04:00:56 <bourbaki> moin
04:01:19 <esap> what's up?
04:03:21 <bourbaki> hey esap :) nothing much i have put some more thought im my idea though i just need to implement it in haskell
04:03:50 <bourbaki> the idea is to do it simimlar to a petri net just with typed tokens
04:20:07 <metaperl> ping
04:20:22 <metaperl> ah, so there is a 3rd purely functional language besides Haskell and Clean: Joy
04:21:04 <Lemmih> pong
04:22:05 <musasabi> the are many pure functional languages.
04:22:20 <musasabi> e.g. miranda
04:22:35 <musasabi> http://www.cs.nott.ac.uk/~gmh//faq.html#languages
04:22:43 <samc_> especially counting toys like joy
04:25:18 <Muad_Dibber> i could make a functional language myself easily :P
04:25:22 <Muad_Dibber> but it wont be a complete language ;)
04:25:24 <TheHunter> joy is purely functional?
04:26:36 <samc_> yes
04:27:06 <TheHunter> i thought "concatenative" was the term to describe joy.
04:27:25 <metaperl> it is interesting because it is neither lamdba calculus or graph-based. it is stack-based. they describe themselves as purely functional
04:29:54 <samc_> TheHunter, it is but that is orthogonal
04:30:21 <samc_> (if I am using the term correctly)
04:35:24 <samc_> quinta, was more or less a superset of joy (iirc) as was a forthish language I wrote myself a long time ago, and probably others have too
04:36:49 <metaperl> lol: There is a useful device called currying, Generally attributed to Curry, but freely acknowledged by him to be due to Sch\"{o}nfinkel (1924). The term "Sch\"{o}nfinkeling" never caught on.
04:37:51 <rtega> why does haskell complain (Cannot infer instance) when i try to input something like 1 :> 2 after declaring data Series a = a :> (Series a)
04:37:57 <rtega> ?
04:38:03 <samc_> hehe
04:38:19 <TheHunter> rtega, you want data Series a = ... deriving (Eq, Show)
04:38:37 <TheHunter> your interpreter just doesn't know how to print it.
04:38:43 <rtega> aha
04:38:44 <rtega> thanks
04:39:30 <rtega> mmm
04:40:03 <TheHunter> oh, sorry.
04:40:28 <rtega> doesn't work
04:40:48 <TheHunter> in 1 :> 2, 1 should be of type a, so 2 should be of type Series a, but 2 is just an integer or something similar.
04:41:01 <rtega> aha
04:41:26 <TheHunter> note that your Series type is only inhabited by _infinite_ streams of a's
04:41:50 <TheHunter> so let a = 1 :> a in a will print a long, long list of 1's.
04:41:50 <rtega> indeed
04:42:19 <cvxb> hey google  www.otomotivshow.com  :)
04:42:51 <rtega> thanks TheHunter
04:45:50 <TheHunter> hmm, in a way, joy looks similar to "functional unparsing".
04:46:41 <samc_> what's that?
04:47:00 <TheHunter> http://www.brics.dk/RS/98/12/BRICS-RS-98-12.pdf
04:47:31 * samc_ downloads
04:49:30 <samc_> there is also no reason not to add lambda absraction to joy, especially since they would have a noce pop and push interpretation, resulting in a backwards lispy language without lots of infuriating single parentheses
04:51:57 <samc_> well, there is no reason they couldn't, rather
05:27:53 <rtega> why does the following complain about not being in scope when compiled?
05:27:55 <rtega> instance (Num a) => Rational [a] where
05:28:03 <rtega>    (+) = zipWith (+)
05:28:12 <rtega> Variable not in scope: `+'
05:29:00 <TheHunter> (+) is a method of the class Num.
05:29:15 <xerox> @info Num
05:29:16 <lambdabot> -- Num is a class
05:29:16 <lambdabot> class (Eq a, Show a) => Num a where {
05:29:16 <lambdabot>     (-) :: a -> a -> a {- has default method -};
05:29:16 <lambdabot>     (*) :: a -> a -> a;
05:29:16 <lambdabot>     (+) :: a -> a -> a;
05:29:16 <lambdabot>     negate :: a -> a {- has default method -};
05:29:18 <lambdabot>     signum :: a -> a;
05:29:18 <TheHunter> you'll have to do instance Num a => Num [a] first.
05:29:20 <lambdabot>     abs :: a -> a;
05:29:23 <lambdabot>     fromInteger :: Integer -> a;
05:29:29 <rtega> aha, ok
05:29:45 <rtega> now I understand it
05:31:19 <rtega> is there some decent documentation on Data, Type, Classes and the like?
05:31:43 <rtega> @info Rational
05:31:44 <lambdabot> -- Rational is a type constructor
05:31:44 <lambdabot> type Rational = GHC.Real.Ratio Integer
05:31:52 <rtega> @info Ratio
05:32:23 <pesco_> @info Ratio.Ratio
05:32:24 <lambdabot> -- GHC.Real.Ratio is a type constructor
05:32:24 <lambdabot> data (Integral a) => GHC.Real.Ratio a = (GHC.Real.:%) !a !a
05:33:03 * pesco shakes his fist at forced disconnect.
05:37:51 <rtega> is there a simple way to add / to Num?
05:38:15 <pesco> There is no way to add (/) to Prelude.Num.
05:38:27 <pesco> Why do you ask?
05:40:04 <rtega> it would simplify some things
05:40:18 <rtega> i'm trying to add the operation / on integral lists
05:40:18 <pesco> That sounds foggy.
05:40:28 <rtega> it doesn't need floating point values
05:41:01 <pesco> But the result might not be an integer.
05:41:17 <pesco> (Assuming you mean element-wise division)
05:41:32 <rtega> nope
05:41:38 <rtega> i didn't mean that :d
05:41:39 <rtega> :D
05:41:54 <pesco> Oh, ok.
05:42:06 <rtega> basically i'm doing it on Rationals only
05:42:23 <rtega> being able to write u/v instead of u `serDiv` v would be simpler
05:42:52 <pesco> That's true.
05:43:45 <pesco> Again, two possible solutions present themselves: Make a dirty instance of the class (/) is in (Floating?) or roll your own class, replacing the standard one.
05:44:25 <pesco> What kind of things specifically are u and v in the above?
05:44:26 <rtega> hum
05:44:29 <rtega> lists
05:44:56 <pesco> And what do they represent? Any of the know algebraic structures?
05:45:39 <pesco> I have an Algebra module somewhere that replaces all the standard classes, although it might not be flexible enough yet to handle your case. It might be simple to extend it though.
05:46:03 <rtega> aha
05:46:08 <rtega> it might be interesting
05:46:29 <rtega> i'm doing my thesis on the use of different programming languages for scientific programming
05:46:37 <pesco> I see.
05:47:46 <rtega> can you mail it to me pesco?
05:48:01 <pesco> Yes. Hold on...
05:48:49 <pesco> There is also a similar suite on the web somewhere. I can't remember the name...
05:52:52 <pesco> rtega: http://www.scannedinavian.org/repos/hlibs/Math/Algebra.lhs
05:52:55 <pesco> rtega: That's my module.
05:54:14 <rtega> thanks
05:54:25 <pesco> rtega: Maybe Multiplicative_group is the class you want.
05:54:41 <pesco> If your lists form a group, of course.
05:55:05 <pesco> Otherwise the (/) operator should be pulled out into a more general class without that requirement.
05:55:17 <pesco> Let me know if you find it useful.
05:56:43 <rtega> pesco: do you know about Karczmarczuk and Fokkers work?
05:57:18 <pesco> rtega: Not sure.
05:57:41 <samc_> ooh, karczmarczuk does some cool stuff
05:58:20 * samc_ had forgotten about it
05:58:27 <rtega> pesco: www.info.unicaen.fr/~karczma/arpap/funcal.ps.gz
05:58:30 <rtega> have a look at that
05:58:46 <rtega> samc_: he certainly does
05:58:58 <rtega> i'm preparing a paper of his for a presentation
05:59:23 <rtega> but it's time for some time off
06:56:03 <rtega> damn, karczmarczuk is a nice fello
06:56:05 <rtega> damn, karczmarczuk is a nice fella
06:56:13 <rtega> sent me his solution to the paper :D
06:56:21 <samc_> nice!
07:52:11 <metaperl> does GHC run through an input list twice if quicksort is defined this way:
07:52:12 <metaperl> qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x
07:52:12 <metaperl>                  where
07:52:12 <metaperl>                    elts_lt_x   = [y | y <- xs, y < x]
07:52:12 <metaperl>                    elts_greq_x = [y | y <- xs, y >= x]
07:53:05 <metaperl> i.e., must it calculate elts_lt_x and elts_greq_x separately? in which case it might be best to partition the input list for optimization purposes
07:54:18 <tromp> in principle a compiler could go through only once, but i'm sure ghc won't
07:55:18 <tromp> esp. since laziness might require only elts_lt_x and not elts_greq_x to be actually computed
07:55:33 <tromp> e.g. if you print half the sorted list
07:55:57 <ibid> don't know how much benefit one gets from doing it only once, since you make each iteration that much longer :)
07:56:09 <metaperl> but from an imperative standpoint, isn't it much faster to partition the list into two and then quickosrt those
07:56:36 <tromp> i'd partition cause it makes the source slightly clearer
07:56:47 <tromp> the speed benefit will be negligable
07:56:59 <ibid> depends on how you write the partitioning
07:57:07 <metaperl> really? filtering a list twice versus once?
07:57:09 <ibid> (the clearer part:)
07:57:58 <ibid> metaperl: what's the difference between doing 1 amount of work 2n times and doing 2 amounts of work n times? :) (simplified, of course)
07:58:46 <roconnor> keep in mind the filtering is defered until elements are requested.
07:59:00 <tromp> (elts_lt_x,elts_greq_x) = partition (<x) xs
08:01:30 <ibid> roconnor: that adds some overhead but since both lists are consumed completely, there are no overall savings from that
08:02:16 <roconnor> ibid that assumes that the entire sorted list is consumed.
08:02:35 <ibid> roconnor: not necessarily
08:02:58 <roconnor> true
08:03:01 <ibid> roconnor: basically you need to consume the whole unsorted list to find out what is the first element of the sorted list
08:03:20 <roconnor> ah
08:03:27 <ibid> roconnor: and that's independent of what sorting algorithm is used
08:03:53 <roconnor> right, but some partitions will remain unsorted even after the first element is requested.
08:03:57 <ibid> (since the smallest element could be the last element of the unsorted list, and you can't know a priori this isn't the case)
08:04:26 <ibid> roconnor: the upper partitions perhaps, perhaps
08:04:31 <roconnor> yes
08:04:45 <ibid> (lose the first perhaps :)
08:07:28 * roconnor wonders what the runtime of head . qsort is
08:08:46 <roconnor> ah it is linear
08:08:49 <roconnor> wonderful
08:09:05 <roconnor> suck it strict evaluation.
08:09:36 <ibid> how do you figure that?
08:10:06 <roconnor> I exepect the runtime to be n + n/2 + n/4 + ... which is about 2n.
08:10:13 <roconnor> oh crap
08:10:18 <roconnor> that is just the average case
08:10:36 <ibid> how so?
08:10:49 <roconnor> bah quicksort is O(n^2) isn't it.
08:10:57 <ibid> i don't see how you'd ever have to look at the upper partitions
08:11:04 <ibid> roconnor: worst case, yes
08:11:24 <roconnor> the first pass will split the list in two (equal) lists.  Then only one of those lists will be traverse, and it will be split in half again.
08:11:50 <ibid> roconnor: O(nlogn) in the average case, assuming a random distribution
08:11:55 <roconnor> yes
08:12:22 <roconnor> my pesudo-math suggests the just requesting the first element will be linear assuming a random distribution.
08:18:17 <TheHunter> so is there a non-sucking purely functional sorting algorithm?
08:19:03 <Heffalump> mergersort is the easy one
08:20:02 <TheHunter> so that e.g. "sort list !! n" runs in logarithmic space for all n.
08:20:08 <TheHunter> i'm probably asking too much.
08:21:04 <Heffalump> logarithmic *space* ?
08:21:05 <TheHunter> ohh, that's impossible.
08:21:11 <Heffalump> how do you expect better than linear space? :-)
08:21:46 <TheHunter> we need a better list representation...
08:22:05 <samc_> Heffalump, how is "Oege" pronounced?
08:22:31 <samc_> (as in De Moor)
08:23:34 <Heffalump> "ooguh" is how I pronounce it
08:23:46 <Heffalump> I don't think it's quite right, but it's close enough.
08:23:56 <samc_> ok, thanks
08:24:11 <pesco> Where is he from?
08:24:28 <Igloo> "de Moor" (little 'd')
08:25:21 <samc_> that's what I thought but it's not on the cover of "Algebra of Programming"
08:27:03 <samc_> odd
08:27:44 <samc_> pesco, nl
08:27:53 <pesco> Hm.
08:29:00 <pesco> Then I also think the "Oe" is pronounced as 'oo' (as in foo).
08:29:54 <Heffalump> Friesland.
08:29:58 <Heffalump> (well, the name is)
08:30:15 <Heffalump> the capitalisation of the 'de' depends on where it's being used, AIUI
08:31:08 <samc_> sorry, AIUI?
08:31:20 <Heffalump> as I understand it
08:32:04 <samc_> ok
08:32:16 <Igloo> Oh, fair enough
08:33:03 <Heffalump> I think most of the time it's little 'd'. Particularly in references.
08:34:16 <samc_> so the second syllable "guh" is short, i.e. non-emphasised?
08:36:31 <rtega> is there any reason why hugs should be used or not used?
08:37:26 <Heffalump> rtega: faster startup times than ghci, but runs slower
08:37:33 <Heffalump> and supports less stuff (but not much less)
08:37:52 <Heffalump> it's also an alternative implementation, so is very useful when checking for portability
08:49:13 * Igloo uploads a ghc 6.4 pre release to Haskell Unsafe (http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html)
09:23:31 <musasabi> evening
09:24:47 * vegai smells a conspiracy :-P
09:36:54 * wilx` smells bacon on his piece of bread
09:39:45 * maihem smells like shit
09:46:25 <wilx`> :)
09:46:32 <wilx`> Go shower :)
09:54:37 <kzm> Good evening!
09:58:00 <pesco> Evening, kzm.
09:58:46 <kzm> So - Sunday night and all channels busy? :-)
10:28:09 <shapr> So, I see spammers have been joining the channel just to paste an url.
10:28:32 <shapr> I wonder if the channel should require that a nickname be registered to join. Any thoughts?
10:28:54 <roconnor> what does registration involve?
10:29:08 <xerox> Hm, along with a note about it and an how to?
10:29:13 <Corion> I've been reading YAHT - could it be that there are typos in the continuation-passing-style definition of cfold' ?
10:29:25 <shapr> roconnor: /msg nickserv help register
10:29:30 <shapr> xerox: yes, exactly
10:30:24 <roconnor> In theory this won't stop spammers.
10:30:26 <musasabi> evenign shapr, any new nice code?
10:30:29 <musasabi> *evening
10:30:31 <xerox> A wikipage could do the job..
10:30:32 <roconnor> shapr: are you a practical person
10:30:36 <shapr> musasabi: Python only :-/
10:30:37 <roconnor> or a theoretical person?
10:30:57 <Lemmih> wb shapr.
10:30:59 <shapr> Most people accuse me of being a bot.
10:31:11 <xerox> shapr, @yow
10:31:12 <shapr> musasabi: interesting code ideas, but no code.
10:31:19 <shapr> what about you? good code?
10:32:00 <shapr> roconnor: I'd say I'm both, why do you ask?
10:32:40 <roconnor> well, in theory registration won't stop spammers, but in practice it probably would temporarily.
10:32:59 * Lemmih is reading up on FRP while battling sendmail on Debian.
10:33:06 <musasabi> shapr: just network-alt fixes.
10:33:15 <tuomov> make the channel moderated and require to stay a few minutes before giving voice
10:33:34 <tuomov> if it gets bad
10:33:43 <Corion> Where should I go to ask a question about Haskell?
10:33:55 <roconnor> Corion: here!
10:34:03 <shapr> Corion: This is a good place, and yes. YAHT has some typos, though I don't know if what you decribe is one.
10:34:04 <sorje> Corion, #haskell is quite nice for that. ;-)
10:34:07 <Lemmih> Corion: #haskell is a pretty good place.
10:34:39 <xerox> I suggest haskell-tutoria.pdf over YAHT.
10:34:54 <Corion> Ah. I was wondering. The author defines a CPS-function, and while I have a pretty good grasp of CPS in a procedural style, his code seems wrong to me...
10:35:00 <Corion> xerox: What URL is that?
10:35:36 <Corion> Ah - Google found it for me, thanks!
10:36:11 <musasabi> Maybe I should just post a note about it to libraries@ when I get the windows buildsystem streamlined, but it still dies with an internal error in GHC on win32 :-(
10:36:12 <Corion> I've just started today with YAHT, but there are some spots that are a bit murky to me - maybe the other documentation clears that up :)
10:36:38 <xerox> Corion, is in the haskell-learning page.
10:37:25 <shapr> musasabi: does network-alt include IPv6 support?
10:38:20 <Corion> xerox: Thanks again - I'll look through that one too :) Maybe then it'll become clear if the first paper has typos or not.
10:38:27 <musasabi> shapr: yes.
10:38:56 <xerox> Corion, I had to read many sources before starting understainding many of the Haskell's concepts :)
10:39:46 <Corion> xerox: My current main stumbling block (besides putting parentheses _after_ the function instead of _around_ the function) are the types. But I'll manage in some time, I hope :)
10:41:03 <Igloo> shapr: I think requiring a registered nick is a hideous idea
10:41:12 <Igloo> Same with the moderation idea
10:41:16 <shapr> Igloo: do you have a better option?
10:41:19 <xerox> Corion, time to get used to. Typing-safe programming requires a bit of a shift in thought, I think.
10:41:36 <Igloo> How often does it happen? Does it get reported to the irc admins? Do they have any advice?
10:41:56 <Corion> xerox: Ah, no. Only the inferred types are really new :) I've programmed Pascal and Perl before (and Python), so I know some languages already :)
10:42:06 <musasabi> it happens quite infrequently - once a few days.
10:42:25 <shapr> But the goal for the spammers is to get into the irc logs and from there to google.
10:42:33 <Heffalump> well, stop the IRC logs being googlable
10:42:42 <Heffalump> I'd really rather they weren't anyway
10:42:46 <Heffalump> or use the nofollow thing
10:42:54 <Corion> Maybe you should blacklist URLs / hosts, and keep a database. Or maybe just have the bots only log registered people.
10:42:56 <musasabi> editing them out of the logs would be simplest.
10:43:07 <xerox> We could hire someone to clean the logs, yay.
10:43:14 <tromp> i want to find interesting irc bits through google
10:43:18 <shapr> I don't control the logs. nef@tunes does.
10:43:21 <Corion> A "learning" blacklist database - whenever you blacklist an URL, it stays blacklisted.
10:43:26 <Heffalump> change the logging bot, then
10:43:39 <Corion> (but yes, that requires changing the logging or cleaning the files afterwards)
10:43:42 <Heffalump> I find myself censoring things I say on here because of the logs being googlable, FWIW.
10:44:17 <Heffalump> I realise there's no expectation of privacy or anything, but it's a balance of risks
10:44:31 <xerox> Is there a big difference between logs publically viewable and googlable?
10:44:41 <tromp> i've never seen a bot spamming url's in here
10:44:57 <musasabi> xerox: yes.
10:45:12 <musasabi> but it is hard to trust them to be one but not the other.
10:45:28 <Heffalump> if I say something about foo, and they or someone else later googles for their name, they'll find what I said
10:46:20 <shapr> That's true of usenet, webpages, and many internet communication media.
10:46:43 <Gahhh> except IM
10:46:58 <Heffalump> correct
10:47:18 <Heffalump> but I don't use those venues for informal chats
10:47:19 <Corion> Well, people paste IM conversations elsewhere too. See http://www.bash.org :)
10:47:29 <Gahhh> Heffalump, just deny it later on based on the fact that it was not pgp-signed with your priv key
10:47:33 <Heffalump> :-)
10:47:54 <roconnor> Gahhh that's a good idea
10:48:31 <roconnor> Heffalump could make a Heffelump bot that says all sorts of stupid things, so if he says somethings stupid then he can just claim it was his bot.
10:49:18 <Corion_> re ...
10:49:37 <Heffalump> cunning
10:49:44 <Heffalump> where's MegaMonad when you need him ;-)
10:50:18 <Gahhh> almost as cunning as trojan horses that paste things in irc channels to hide the intended recipient.
10:50:51 <shapr> Scatter-gather anonymizer connections like that are interesting.
10:51:14 <xerox> On this network there are anonymous channels, too.
10:51:26 <xerox> I mean, channels where people talking are anonymous :)
10:51:27 <shapr> I've thought of doing the same thing with subnet broadcast as well.
10:51:48 <shapr> I like SILCnet a lot more than IRC.
10:51:55 <Heffalump> shapr: the request to make the logs non-googlable is serious, btw.
10:52:06 <xerox> shapr, do you know of a SILC-enabled ERC?
10:52:10 <Heffalump> I've been meaning to for a while but didn't get round to it
10:52:31 <Gahhh> robots.txt ?
10:52:40 <shapr> Heffalump: I don't think it's a good idea, the goal here is teaching more than anything else, and newbies who want to learn do show up here from finding info in google.
10:53:25 <Igloo> Really? That sounds odd to me
10:53:44 <shapr> How so?
10:54:50 <Igloo> Too much effort to explain, but if you have evidence for what you say then I can't argue with it  :-)
10:55:26 <Gahhh> Somebody may discover the channel via a google hit just because of the type of stuff being talked about.
10:55:32 <shapr> I've talked to several people who got here via google + logs.
10:55:36 <Corion_> xerox: Thanks for the link! I found my thinking error. (\x f t -> y) is a function taking three parameters, not two :-)
10:55:51 <xerox> Corion_, right :)
10:56:07 * Corion_ got here via Google, but not via logs. I think Autrijus Tang pointed me towards #haskell, and/or some Haskell wiki
10:57:54 <Corion_> Is it possible for an anonymous function to reference itself? If I have (\a b -> a+b) , can that function reference itself? (and, as an aside, can I say (\ a b -> a), that is, put whitespace between \ and the first arg?
10:58:32 <Igloo> no, yes
10:58:43 <Corion_> Igloo: Thanks! :)
10:59:57 <musasabi> Corion_: you should name it then - you can use let for that purpose.
11:00:19 <musasabi> Corion_: let foo x f t = ... in foo
11:00:34 <integral> Y ?
11:00:37 <Corion_> musasabi: Yeah, I was just wondering if I had to "waste" a name, if I'm doing some recursive definition as a lambda expression. Not good style, but might be handy :)
11:00:54 <musasabi> Corion_: or if you are so inclined let foo = (\x f t -> ...) in foo
11:01:38 <musasabi> Corion: that would quick get complex when refactoring code.
11:02:05 <Corion> musasabi: Yeah, I know - it was more a theoretical question anyway :)
11:04:50 <roconnor> @info fix
11:06:02 <Corion> Ah - another question. YAHT seems to encourage the same name for type and constructor, while the tuwien.ac.at tutorial warns from using the same name. Which is more accepted? Or is that personal taste?
11:09:00 <Gahhh> My personal taste makes me use different names.
11:09:31 <roconnor> When there is one constructor, using the same name is convinient ... and can be confusing for novices.
11:28:06 <xcvb> www.otomotivshow.com
11:46:54 <shapr> see, that was spam
11:50:22 <xerox> Damnit.
11:51:43 <musasabi> at least they are getting K-lines
11:51:51 <musasabi> 81.213.* seems to be to blame.
11:52:59 <shapr> What does IANA say about that number?
11:53:08 <musasabi> From the topic on #freenode - "Spambots? -> /msg Geert SPAM: user@host (no nick)"
11:53:16 <shapr> yeah, I sent in the spam /msg
11:53:44 <Oejet> What is going on?
11:54:23 <shapr> Some ADSL in Turkey is spamming freenode.
11:55:12 <musasabi> Would it be possible to require registered nicks from those ips - with a message or somesuch?
11:56:05 * shapr checks the chanserv modes
11:57:36 <maihem> can anybody help me with the problem I'm having here: http://maihem.org/transducer.hs
11:58:21 <maihem> If you uncomment the explicit type signature on m at the the bottom, it works fine, but I don't want to export the BackTrack type.
12:00:40 <roconnor> ? Do you want to export m?
12:01:09 <musasabi> monomorphism restriction at work..
12:01:22 <maihem> oh, sorry. the main and m are supposed to be in a different file. It is only the stuff above them that is supposed to be in this file
12:02:02 <maihem> musasabi, I don't understand?
12:02:49 --- mode: ChanServ set +g
12:03:00 <musasabi> maihem: the problem is that the types are too polymorphic causing problems with the restriction.
12:03:26 <Igloo> +g?
12:03:37 <shapr> Anyone can invite.
12:04:15 <Igloo> But?
12:04:30 <maihem> The Match type is fine. that works on it's own. and the match type provides both the s and the t of the class which is all that's needed to identify the type of m, surely?
12:04:35 <shapr> Igloo: huh?
12:04:36 <xerox> If not, only ops can.
12:04:48 <maihem> due to the fundeps
12:05:06 <Igloo> But spammers don't need to be invited?
12:11:46 <shapr> I see two options, +q *!*@81.213.*.* will mute that hostmask until the mode is cleared, or the more drastic +R which mutes all unidentified users. In both cases those users can join the channel.
12:12:23 <shapr> I'll start with the first option.
12:12:33 --- mode: ChanServ set +o shapr
12:12:33 <xerox> It's fair enough
12:12:51 --- mode: shapr set +q *!*@81.213.*.*
12:12:56 --- mode: shapr set -o shapr
12:13:02 <shapr> hopefully that'll fix the problem.
12:15:51 <Khisanth> shapr: it will not
12:16:10 <Khisanth> those things have been doing that for around 3 days now with changing ip and ident
12:16:19 <shapr> Any better ideas?
12:16:29 <Khisanth> nope!
12:17:13 <Khisanth> although all their addresses seem to start with 8*
12:18:52 <musasabi> Khisanth: all the four in haskell have been from 81.213.*
12:19:21 <musasabi> 81.213.70.20 81.213.231.187 81.213.231.198 81.213.224.25 by my logs
12:19:22 <Khisanth> gah there is more than one then
12:19:37 <Khisanth> there ones with 85
12:19:41 <shapr> 3 different class A ranges according to #freenode
12:20:37 <Khisanth> hmm all from turkey
12:24:46 <shapr> hiya Steve_p
12:24:49 <shapr> um, stepcut
12:25:07 <stepcut> shapr: the url for TMR is cut off in the topic (atleast under mirc)
12:25:15 <shapr> oops
12:25:30 <stepcut> :)
12:26:17 --- topic: set to '["Learning Haskell - http://haskell.org/learning.html","See logs @ http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! - ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]' by shapr
12:26:19 <shapr> better?
12:26:27 <stepcut> _2fIssu
12:26:35 <Khisanth> it's all here
12:27:28 <stepcut> the last 4 letters are chopped off still (under mirc)
12:27:51 <stepcut> so, I finally have a dvd drive for my computer :)
12:27:53 <shapr> yay
12:27:56 <Khisanth> remove some quotes :p
12:28:47 --- topic: set to '["http://haskell.org/learning.html","See logs http://meme.b9.com/cdates.html?channel=haskell","related channels #haskell.se #haskelldb #darcs","http://haskell.org/cabal/","http://sequence.complete.org/","Haskell is the language of choice for discriminating hackers! ICFP contest 2004","We put the Funk in Funktion","http://www.haskell.org/hawiki/TheMonadReader_2fIssueOne"]' by shapr
12:28:54 <stepcut> it is all there now :)
12:29:01 <shapr> happiness.
12:29:26 <stepcut> when is the submission deadline for issue two ?
12:30:04 <shapr> Get a summary and outline to me by one week into the month
12:31:12 <stepcut> so I need the summary now ?
12:31:31 <shapr> Nah, by tomorrow.
12:31:51 <stepcut> hrm, ok, I will look at my draft and see how it looks
12:31:59 <stepcut> but first, I should read issue one :)
12:32:10 <stepcut> when is the final draft due ?
12:32:29 <shapr> One week before publication, though I'm thinking of moving that earlier.
12:35:18 <stepcut> haha, foldl (flip (:)) []
12:37:12 <xerox> stepcut, nice one :)
12:38:31 <stepcut> xerox: it's not mine, it is from the monad reader
12:39:15 <xerox> I knew it.
12:39:32 <stepcut> ok
12:39:48 <xerox> Didn't mean to be rodue, sorry.
12:39:52 <xerox> *rude
12:42:08 <Oejet> Have you ever been writing Java code and then caught yourself in dreaming that you were writing Haskell?
12:42:17 <bringert> yes
12:42:19 <shapr> yes
12:42:20 <bringert> several times
12:42:32 <shapr> I tried to do pattern matching in Python several times the last week.
12:42:55 <bringert> but it only happended once that I stopped writing the thing in Java and did it in Haskell instead.
12:43:11 <bringert> it was a component for a java app
12:43:14 <stepcut> I keep trying to use first-class functions in c++ :(
12:43:29 <bringert> I wrote the thing in haskell, haven't gotten around to porting it
12:43:33 <shapr> I often try to use partial application in Python.
12:43:51 <bringert> then again, my java looks like haskell
12:44:12 <Oejet> TMR article suggestion: Psychological profile of a Haskell programmer.
12:44:20 <shapr> Want to write it?
12:44:23 <bringert> shapr: did you see my java lib for curried higher-order functions in java
12:44:42 <bringert> strongly typed of course
12:44:49 <shapr> Whoa nifty, hoj
12:45:04 <bringert> syntax sucks though
12:45:23 <bringert> so it fits in nicely into Java
12:45:24 <musasabi> Does anyone know what causes "internal error: resumeThread: thread not found" on Windows with GHC compiled executables which run fine on *nix?
12:45:45 <Oejet> musasabi: Windows, maybe?
12:45:55 <shapr> Scary, thread destructed but not removed from the scheduler?
12:46:23 <bringert> Oejet: haha
12:46:30 <Oejet> :-P
12:47:30 <musasabi> the problem is that I am not very familiar with windows - nor know how to debug things there getting a commandline and compiling an executable seems complicated enough.
12:48:50 <musasabi> with *nix I would just use gdb and locate the problem - with windows I just don't know what to do - other than walk away from the nasty OS.
12:49:07 <shapr> Yeah, I can't believe I tried to learn to program on Windows.
12:50:28 <maihem> I can't believe I just started at a job working on Windows software
12:50:28 <shapr> DOS was better, sadly.
12:50:33 <Gahhh> you can use msvc's compiler like you use gcc.
12:50:53 * maihem just learnt most of C#... it's crap
12:51:14 * maihem jumps up and down on .NET collections
12:51:30 <shapr> Gahhh: it's more challenging to install msvcc on win32 than gcc on debian.
12:51:43 <Gahhh> ugh. why ?
12:51:52 <Gahhh> because it's not free ?
12:52:03 <maihem> heheh, 1. apt-get install gcc, 2. make coffee
12:52:05 <tuomov> It's more challenging to install anything in windows than anything on debian
12:52:19 <musasabi> Gahhh: getting a decent shell + installing ghc + getting programs actually compiled is a quite involved operation.
12:52:43 <tuomov> every windows installation requires you to click through dozens of dialogs. With Debian it's just apt-get install package, and that's it
12:52:51 <shapr> I tried to learn programming first when I was 11, then off and on until I was 16, when I gave up on it entirely.
12:53:08 <Gahhh> NOT all every windows installer puts you thru dozens of dialogs
12:53:17 <Gahhh> espeically not ghc
12:53:55 <shapr> I got to the point where I could write running programs. But once I found the real beauty in programming, I realized windows was not helping.
12:53:56 <musasabi> Gahhh: only that one has to manually add that to the path..
12:53:59 <tuomov> then there's of course the programs that are just tarballs/zips..
12:54:27 <Gahhh> musasabi, it's not command line controlled like unix. You need to creare a makefile and put the compiler's full path there.
12:54:30 * musasabi has done some software for win32 (with lccwin32) for money in the past
12:54:36 <Gahhh> if you want, you can certainly add it to the path anyways
12:54:49 <musasabi> Gahhh: only I have to first install make.
12:54:57 <Gahhh> no, you can use MS's nmake
12:55:11 <musasabi> Gahhh: which is not in path of course..
12:55:31 <Gahhh> I believe msvc installation adds them into the path.
12:55:36 <shapr> Windows attempts to insulate users from the computer. That may be counterintuitive only for programmers, I've never been a normal user.
12:56:08 <Gahhh> shapr, how do you think game developers develop on windows then ?
12:56:30 <stepcut> Gahhh: well, most games never ship :)
12:56:35 <shapr> From what I've heard on #icculus.org, badly and with much pain.
12:57:25 <musasabi> Gahhh: I don't think game developers have much choice..
12:57:52 <tuomov> s/game/most/
12:58:28 <jlouis> Windows attempts to hide the power features
12:58:33 <jlouis> And that is the problems
12:58:56 <Gahhh> which feature specifically would you like ?
12:59:10 <bringert> a useful shell
12:59:13 <shapr> Icculus told me that he found many bugs in games he was porting just by using valgrind. He also said that most game developers have never heard of most software engineering practices. He said the problem is not consistently using stuff like unit tests, but instead getting them to use that sort of stuff at all.
12:59:15 <Gahhh> that's not a feature
12:59:17 <tuomov> the windows ui is the problem. if any were forced to use gnome/kde stuff exclusively on *nix it wouldn't be any better.
12:59:24 <tuomov> s/any/one/
12:59:47 <bringert> Gahhh: a useful shell is not a feature?
12:59:48 <Gahhh> unit test tools do run on windows. if they are not using it, oh well.
12:59:53 <Khisanth> shapr: that doesn't seem OS related though
13:00:16 <shapr> I think it is somewhat OS related, because windows does not encourage automation of processes.
13:00:33 * stepcut tries to remember how to do double-entry bookkeeping
13:00:50 <roconnor> each row sums to 0.
13:00:52 * stepcut gets smart and goes to the used bookstore
13:01:07 <shapr> I've read a lot of language pissing matches over the years, and the only worthwhile criteria I've seen is whether a language/OS/etc makes something easy to do, thereby encouraging it.
13:01:24 <musasabi> Gahhh: how can I make a buildsystem which works with a single command on most windows machines with the ghc installed?
13:01:38 <musasabi> that seems quite impossible for me.
13:01:46 <jlouis> tuomov: KDE/Gnome is not a bad choice. Especially not gnome
13:02:01 <tuomov> gnome esp. is awful.
13:02:06 <jlouis> They have really done something pleasant to GUI.
13:02:19 <jlouis> tuomov: how so? Not .... Ion ? ;)
13:02:21 <Gahhh> musasabi, most windows machines don't come with developer tools like make and compilers.
13:02:28 <shapr> Khisanth: what do you think about that idea?
13:02:30 <tuomov> they've broken the whole system
13:02:37 <tuomov> start anything gnome and the whole X is fscked up
13:02:45 <musasabi> Gahhh: well how does one make a solution which works for most machines wich have those tools?
13:02:47 <roconnor> I have gnome installed.
13:02:57 <roconnor> It blows my mind how bad it is.
13:02:58 <jlouis> tuomov: Can you elaborate?
13:03:05 <tuomov> they don't easily allow configurating stuff (one set of keybindings for everyone! uniformity good! configurability bad!)
13:03:24 <tuomov> and that set is of course totally useless windows-style bindings
13:03:52 <Gahhh> musasabi, if the machines have nmake, you can tell the users to edit the paths in the makefile for ghc, etc. and that should do it imho. sorta like a manual './configure ..'
13:04:12 <tuomov> kde allows configuring more stuff easily, but there's too much stuff available by default
13:04:36 <jlouis> tuomov: I have not checked, but I would presume the gconf-registry allows for changing the keybindings
13:04:40 <musasabi> Gahhh: but that is not really automating it - is it?
13:04:46 <tuomov> yeah... _registry_
13:04:59 <tuomov> where's simple human-readable configuration files?
13:05:03 <tuomov> (xml doesn't count as human-readable)
13:05:23 <roconnor> the file open dialog is practially unusable.
13:05:32 <tuomov> yep, that's awful
13:05:40 <Oejet> Any compiler really needs to have a build system build in.
13:05:51 <tuomov> the most important item in a file dialog is the path entry box
13:05:54 <jlouis> Oejet: agreed.
13:06:03 <tuomov> they've removed it and even typeahead doesn't recognize ..
13:06:22 <Gahhh> musasabi, was it automated for unix before autoconf arrived ?
13:06:26 <roconnor> I thought it was just Gaim the sucked, but nope, it's all of gnome.
13:06:30 <tuomov> so you have to open yet another dialog (that messy jungle of desktop) or move your hand to Alt+Up to go up in the hierarchy
13:06:57 <tuomov> paths confuse the user! must hide them!
13:07:16 <jlouis> paths should be killed anyway
13:07:23 <roconnor> imagine trying to use unix without knowing about paths.
13:07:23 <tuomov> clikety-clickety objects are the only natural way!
13:07:31 <tuomov> paths are the right way to do things
13:07:34 <Gahhh> how about "neither"
13:07:36 <roconnor> Now I'm all for getting rid of paths
13:07:42 <cm> do you have an idea why Text.Regex interpretes the .* in "lala(.*?)lele" as greedy?
13:07:46 <tuomov> how would you reference anything then?
13:07:49 <tuomov> dragging objects around?
13:07:56 <tuomov> totally unusable mouse shit
13:08:00 * samc_ is annoyed by this conversation
13:08:04 <Gahhh> I'm anti-objects, anto-dragging
13:08:05 <heatsink> It would work if you could type the path in the filename entry box... like kde does...
13:08:12 <musasabi> Gahhh: imake ;) (of course that had it's own share of problems)
13:08:29 <roconnor> dragging isn't bad
13:08:30 <tuomov> heatsink: like any sane system does
13:08:32 <jlouis> tuomov: Thanks. I think I have a (tiny) view of your opinion. Lets stop here ;)
13:08:43 <musasabi> Gahhh: so how about autoconf support ;)
13:09:03 <tuomov> if you remove paths, you remove (keyboard) usability
13:09:03 <Gahhh> musasabi, you can use cygwin, then you have it all as you're used to
13:09:09 <samc_> as you would be hearing non-experts discuss the merits of various approaches to programming
13:09:33 * heatsink thought mouse gestures were cool when it discovered them
13:09:44 <shapr> Yeah, I do enjoy reading programming theory discussions on slashdot.
13:09:49 <Gahhh> lol
13:10:16 <samc_> hehe
13:10:18 <shapr> I used to take slashdot seriously, but now it's sort of like the daily webcomics.
13:10:25 <heatsink> Usually someone comments "it's just C clones" when that happens...
13:12:14 <jadrian> Heffalump: hi, are you around?
13:12:30 <roconnor> I'd be happy if giving focus to the file list allowed me to type the name.
13:12:36 <shapr> I got a lot of entertainment out of the recent extensible language discussion. Was it a language written with XML or something?
13:12:40 <Heffalump> jadrian: yes
13:13:25 <Gahhh> if haskell syntax was like XML, it would be adopted by masses.
13:13:28 <tuomov> shapr: about using xml to store the parse tree of the code?
13:14:02 <jadrian> Heffalump: I was looking at the Phds in Oxford, some things seem a little confusing, and I thought maybe you can tell me some things
13:14:09 <Heffalump> sure
13:14:31 <jadrian> Heffalump: for instance, this "Gathered Fields 1,2,3,4,5"
13:14:43 <jadrian> Heffalump: with different deadlines each
13:14:46 <jlouis> shapr: hehe, yes. I remember that discussion
13:14:51 <jlouis> was really funny
13:15:03 <samc_> there aren't any phds from oxford :p
13:15:08 <roconnor> Gahhh: *l*
13:15:13 <Spark_> i wonder if its possible to hardware accelerate the parsing of xml :)
13:15:18 <jadrian> Heffalump: are this deadlines for different kinds of requisites?
13:15:25 <cm> Spark_: lol
13:15:26 <jadrian> Heffalump: http://www.admin.ox.ac.uk/gsp/apply/gathered.shtml
13:15:27 <cm> Spark_: XML cards :D
13:15:33 <Spark_> yeah
13:16:06 <Spark_> then you'd have an excuse for using xml :)
13:16:08 <roconnor> I want hardware accelerated G-Machines, or TIMs, or something
13:16:22 <Heffalump> you need to check on the specific deadlines whatever department you're applying to (Comlab?) uses
13:16:36 <Heffalump> it'll be some subset of the deadlines listed there
13:17:01 <Heffalump> and then you need to get your application in before one of those deadlines. The earlier the deadline you make, the better your chances.
13:17:05 <Spark_> i need to find out about doing a phd soon
13:17:20 <Spark_> most likely it'll be in imperial because i'm rather liking the nightlife here :)
13:17:37 <shapr> Would hardware graph reduction be any good?
13:17:47 <Spark_> thats been done hasnt it?
13:17:56 <Spark_> there was some kind of hardware accelerated lisp machine
13:17:59 <jadrian> Heffalump: yeap that would be the computing laboratory
13:18:06 <shapr> I read about doing graph reduction in optics somewhere.
13:18:23 <Oejet> In other news: Linux will now mark even numbers of the fifth ciffer in the version number as stable and even numbers as development. Version 2.6.11.1.1 will be released soon.
13:18:25 <Spark_> exploit the natural computational power of the universe :)
13:18:52 <heatsink> shapr: I wanna see.
13:19:15 <jadrian> Heffalump: let me search again
13:19:52 <jadrian> Heffalump: ah I got it
13:19:59 <Heffalump> jadrian: from what I can tell from the materials, all the deadlines apply for Comlab.
13:20:09 <tuomov> Linux versio number will start approaching 2.7.18.2.8...
13:20:15 <Heffalump> so just pick one and get your application in for it, the earlier the better
13:20:17 <jadrian> Heffalump: yeap it says Overseas research applicants are advised to apply in gathered field 1 though  :-/
13:20:19 <Oejet> tuomov: lol
13:20:27 <Heffalump> you need an ORS?
13:20:50 <shapr> heatsink: Seems there some connection between combinators and optical graph reduction, though I haven't investigated yet. http://scholar.google.com/scholar?hl=en&lr=&safe=off&q=%22graph+reduction%22+optical&btnG=Search
13:21:13 <jadrian> Heffalump: ORS?
13:21:33 <Heffalump> oh, no, you wouldn't since you're from the EU
13:21:49 <Heffalump> a scholarship that covers the difference in fees between home and overseas rates
13:22:05 <jadrian> Heffalump: I think I can get scholarship here
13:22:14 <Heffalump> have you identified a potential supervisor?
13:23:24 <jadrian> Heffalump: well kind of...
13:24:02 <Heffalump> have you discussed it with him (or her, though given the makeup of the academic staff there it's unlikely..)
13:24:56 <jadrian> Heffalump: I've just started looking at Oxford, I like the kind of work that is done in algebra of programming group, and I just know the big names from there, Gibbons and Bird
13:25:11 <jadrian> Heffalump: but I haven't approached anyone yet
13:25:36 <jadrian> Heffalump: I'm just beginning to look at Universities and research groups
13:26:08 <jadrian> Heffalump: I've been looking at Endiburgh a fe wdays ago and now I was starting to look at Oxford
13:27:50 <jlouis> openldap client... hmm
13:30:24 <jadrian> Heffalump: you were with Oege de Moor right?
13:31:33 <Heffalump> yeah
13:38:45 <stepcut> well, I did not find any used books on accounting, but I did find a used pj harvey cd :)
13:39:35 <shapr> I could go for that.
13:39:56 <shapr> I wish I had a copy of 4-track demos.
13:40:15 <shapr> eq__: thielemann?
13:40:49 <eq__> shapr: what do you mean?
13:41:49 <stepcut> shapr: i have a copy :)
13:42:11 <shapr> eq__: just wondering if you are Henning Thielemann
13:42:42 * shapr emails an order for fifty used CDs to stepcut 
13:42:54 <eq__> shapr: No, just Henning Guenther ;)
13:43:13 <eq__> Is he famous or something?
13:43:46 <shapr> I don't think so, but I would like to talk to him about Haskore.
13:44:00 <shapr> How do you know if someone is famous anyway?
13:44:44 <Oejet> To anyone interested in GNOME bloat, this blog is sweet: http://codeblogs.ximian.com/blogs/benm/archives/000452.html
13:44:49 <stepcut> shapr: if they have a sex tape, of course...
13:45:26 <eq__> perhaps by counting the people that ask for him... but that's interesting, just yesterday i stepped over the same project by accident...
13:46:23 <shapr> hehe, that was a muted spambot.
13:46:53 <shapr> eq__: Haskore is quite nifty.
13:49:28 <stepcut> argh! quickbooks online *still* does not support online banking -- which seems very ironic, since all of the non-online version do...
13:49:34 <eq__> as I'm just new to haskell, every programm written in haskell is quite nifty to me ;)
13:50:07 <shapr> Do you have any questions about Haskell?
13:51:42 <eq__> hmm, no, but as soon I have one, I'll ask you :)
13:52:57 <eq__> i don't know this language very well yet, but I already love it
13:53:33 <stepcut> I heard a rumor that intuit is building their own virtual machine, too which they will port all their apps, making cross-platfrom development a snap
13:57:06 <shapr> I've wondered if that's what Microsoft was doing with dot net, removing their dependence on Intel.
13:58:02 <stepcut> i figured they just wanted to have something that competes with java, just in case
13:59:45 <stepcut> Functional programming and the two-pass assembler <-- argh! I need an acm account to read that paper :-/
14:00:59 <heatsink> portal?
14:01:26 <stepcut> heatsink: yeah
14:01:55 <shapr> acm sucks.
14:02:00 <heatsink> hmmm...
14:02:02 <stepcut> http://portal.acm.org/citation.cfm?id=947944
14:02:17 <bourbaki> moin
14:03:32 <eq__> what means two-pass assembler?
14:04:42 <bourbaki> assembler with macros perhaps?
14:04:54 <Cale> Shall I get that paper for you?
14:05:28 <samc_> does anyone use CiteULike?
14:05:40 <Gahhh> I saw it once.
14:05:44 <Gahhh> looked overcrowded
14:06:33 <samc_> that's bad?
14:06:50 <Gahhh> I was overwhelmed lol.
14:07:15 <stepcut> eq: it's related to how many times to has to read over the input (or perhaps output) to turn the assembly into binary
14:07:43 <Cale> My library gives me access to ACM stuff.
14:08:06 <stepcut> eq__: for example, if the assembly contains a jump to a label that appears later in the program, then you have a problem, because you don't know what the offset is until you generated the code that comes in between the jump and the label...
14:08:13 <samc_> I might try it out, I don't actually care too much about the social aspect
14:09:19 <Cale> http://vx.hn.org/autoshare/p34-early.pdf
14:09:29 <Cale> just don't try to read it in gv :)
14:11:35 <stepcut> I am trying to write a swf assembler in haskell, and my currently implementation works, but is not the prettiest or most efficient
14:12:54 <stepcut> s/currently/current/
14:13:36 <samc_> shapr, if you haven't heard of it you should check it out
14:13:59 <samc_> swf?
14:14:24 <heatsink> feh, hotmail doesn't let me send attachments because I'm not using internet exploder
14:14:39 <stepcut> heatsink: suck!
14:15:02 <heatsink> truly.
14:15:08 <stepcut> heatsink: thanks any! (I got it from Cale's link so I am ok now)
14:15:12 <Gahhh> is that new ??
14:15:15 <heatsink> ok
14:15:26 <Gahhh> I remember attaching files via firefox
14:16:10 <heatsink> They check the browser ident that is sent over http, if not recognized then you get an error message.
14:16:21 <heatsink> I guess they accept firefox.
14:16:27 <samc_> stepcut, swf as in flash?
14:16:50 <stepcut> samc_: yes
14:16:57 <samc_> oh cool
14:17:36 <stepcut> samc: the ultimate goal is a scheme->swf, currently I have core scheme -> asm, and asm -> swf, but the asm->swf does not support branches yet...
14:18:16 <stepcut> but once I get the assembler in shape, it should be possible to write a bunch of x -> swf compilers
14:19:43 <heatsink> How do I make FFI pointers to C objects that never get marshalled into Haskell objects?
14:19:58 <samc_> I was thinking of playing around with the scheme -> ps, but this sounds even more fun :)
14:20:27 <stepcut> samc: yeah, after the flash vm is probably the most wide-spread vm on the net (more so that java or .net)
14:21:53 <heatsink> Can I just let Haskell pretend that my C struct is an int, and call it a ForeignPtr Int?
14:23:13 <stepcut> samc: though, hopefully my design will be modular enough, that you could plug in a asm->ps assembler and re-use most of the scheme->asm portion
14:24:16 <stepcut> core scheme only has something like 7 operations, and they translate pretty straight-forward to stack based languages
14:24:34 <stepcut> i think the key is you need to be able to push anonymous functions on the stack
14:24:49 <stepcut> which the swf vm allows
14:26:46 <Lemmih> heatsink: You could create an opaque data structure to represent the C struct.
14:28:03 <heatsink> Lemmih: Create it in haskell or in C?
14:28:54 <Lemmih> Haskell. eg. data CStruct
14:29:31 <heatsink> and this data object will contain a ForeignPtr, correct?
14:30:00 <heatsink> s/object/type/
14:30:11 <shapr> stepcut: sounds cool, where's the darcs repo?
14:30:37 <Lemmih> Nope. It's not really there. The argument to 'Ptr'/'ForeignPtr' is completely ignored.
14:30:56 <heatsink> oh, I see.
14:30:57 <Lemmih> heatsink: It's only used to be typesafety.
14:31:07 <Lemmih> s/typesafety/typesafe/
14:31:25 <stepcut> shapr: no where, it's in gnu arch :p
14:31:48 <heatsink> that should work nicely.
14:32:42 <Lemmih> And you probably want the vanilla Ptr over ForeignPtr if you don't intent to use finalizers.
14:32:55 <heatsink> I intend to use a finalizer.
14:33:23 <jlouis> ForeignPtr
14:34:25 <samc_> stepcut, is the vm openly documented by macromedia?
14:34:55 <stepcut> samc: yes, up to version 6
14:35:31 <stepcut> samc: I don't know if version 7 adds any new opcodes -- it may just be optimizations to the internals and new library functions
14:37:50 <stepcut> samc: you have to fill out some form that says you won't abuse their trademarks, but other than that the vm is openly documented and you can write royalty free applications that generate .swf files
14:38:28 <samc_> sweet
14:39:15 <boegel> hi everybody !
14:39:40 <stepcut> samc: unfortunately, one table is misformated, which makes it hard to read, and there is one bit error somewhere (and I cannot remember what it was), but otherwise the document seems correct
14:39:50 <heatsink> hi mister boegel!
14:40:01 <Oejet> Greetings, boegel.
14:43:38 <boegel> interesting news ?
14:43:49 <bourbaki> moin boegel
14:44:16 <boegel> hey bourbaki (and heatsink and Oejet )
14:44:27 <bourbaki> :)
14:45:55 <djo> hello everybody
14:46:02 <boegel> hey djo
14:46:16 <Lemmih> djo: Jo.
14:46:24 <djo> :D
14:46:29 <Oejet> djo: Bon soir.
14:46:40 <djo> waw!
14:46:55 <djo> So, I'm new by in haskell
14:47:26 <samc_> djo: tena koi
14:47:35 <Oejet> djo: If you have any questions, we will gladly answer.
14:47:50 <djo> so, one second
14:49:45 <djo> when we write somthing like "data toto = toto { var1:: type1, var2 :: type2}" what exactly means this notation ?
14:51:02 <Oejet> It's data Toto (capital letter).  It's a record declaration.
14:52:00 <djoVSmonads> but what does the "{" means exactly
14:52:49 <Oejet> Just that var1 and var2 are in the same record with the name Toto.
14:52:53 <Lemmih> It denotes a record.
14:53:23 <Lemmih> Oejet: You're too fast for me (:
14:53:35 <Oejet> Lemmih: Blazingly.
14:54:02 <shapr> The stock market sells futures, antique stores sell pasts. I guess that leaves Santa in the middle.
14:55:45 * samc_ looks around surreptitiously to see if he was the only one who didn't get it
14:56:06 <Oejet> shapr: Hahahaha.
14:56:47 <Oejet> samc_: :-P  Just kidding.
14:57:06 <shapr> presents?
14:57:20 * stepcut got it
14:57:23 <shapr> Maybe I'm a bit too random today.
14:57:28 <Pseudonym> G'day shapr.
14:57:33 <samc_> ah, haha
14:57:54 <djoVSmonads> and now can some one explain to me what StateT is ? "type State = StateT Toto IO"
14:57:55 * Oejet pulls out a straight jacket and looks at shapr.
14:57:57 <Pseudonym> This reminds me of the time that Darth Vader knew what Luke was getting for Christmas.
14:58:04 <Pseudonym> "I felt his presents."
14:58:44 <samc_> thats so bad it's almost good, almost :p
14:58:58 <Pseudonym> Almost, yes.
14:59:21 <Pseudonym> I'd like to see the stock market sell second derivatives, or integrals.
14:59:44 <Pseudonym> Or Fourier transforms.
15:00:15 <rtega> nice
15:00:45 <rtega> karczmarczuks haskell program serves to solve math problems in the #math channel
15:00:49 * rtega is a happy person
15:01:09 <djoVSmonads> a question, is there any API (lik the java one) for Haskell ?
15:01:17 <wagle> four yays for haskell
15:02:44 <roconnor> yay
15:02:56 <djoVSmonads> I don't know where to find for predefined haskell functions and types
15:02:58 <Pseudonym> There are lots of APIs for Haskell.
15:03:01 <djoVSmonads> yay ?
15:03:10 <Pseudonym> I don't understand the question.
15:03:23 <wagle> http://www.haskell.org/libraries/ ?
15:03:26 <samc_> that's one and a sort of one so far
15:03:27 <heatsink> http://www.haskell.org/ghc/docs/latest/html/libraries/ is a good place to look if you're using GHC
15:03:37 <shapr> g'day Pseudonym
15:03:49 <wagle> you guys didnt transform my four yays very fast
15:03:55 <samc_> yay
15:04:01 <shapr> yay
15:04:16 <djoVSmonads> for example, i want to know what does "StateT" means...
15:04:36 <mich4545-> hi there
15:04:45 <shapr> hi mich4545-
15:04:51 * rtega yays again!
15:05:07 <Oejet> Hello, mich4545-.
15:05:15 <mich4545-> I am getting an error when trying to load my hs file, could anyone try and tell me what the problem is?
15:05:28 <wagle> what does the error say?
15:05:30 <mich4545-> I can give you the error mesage
15:05:48 <mich4545-> ERROR "C:\Egyf.hs":14 - Inferred type is not general enough
15:05:50 <Oejet> djoVSmonads: Do you have some more context; where did you see StateT?
15:05:59 <mich4545-> *** Expression    : egy21
15:05:59 <mich4545-> *** Expected type : Integral a => Egy a -> String
15:05:59 <mich4545-> *** Inferred type : Integral Double => Egy Double -> String
15:06:28 <heatsink> what the heck is Control.Arrow.(|||)?  It looks anticausal to me.
15:06:41 <djoVSmonads> Oejet, it's corresponding to Toto record that I mentioned earlier
15:06:42 <wagle> "anticausal"?
15:06:49 <xerox> @type (|||)
15:06:51 <lambdabot> bzzt
15:06:57 <xerox> @type Control.Arrow.(|||)
15:06:59 <lambdabot> bzzt
15:07:03 <wagle> @index (|||)
15:07:03 <lambdabot> bzzt
15:07:10 <xerox> @index |||
15:07:10 <lambdabot> Control.Arrow
15:07:16 <xerox> @type Control.Arrow.|||
15:07:17 <lambdabot> bzzt
15:08:03 <heatsink> Oh, I get it now.
15:08:06 <Pseudonym> @type (Control.Arrow.|||)
15:08:07 <lambdabot> (Control.Arrow.|||) :: forall a d c b.
15:08:07 <lambdabot> 		       (Control.Arrow.ArrowChoice a) =>
15:08:07 <lambdabot> 		       a b d -> a c d -> a (Either b c) d
15:08:12 <wagle> @dwim |||
15:08:12 <lambdabot> Sorry, I don't know the command "dwim", try "lambdabot: @listcommands"
15:08:27 <heatsink> It uses an either to select which function to use.
15:08:29 <Pseudonym> Think of it as:
15:08:43 <Pseudonym> (b -> d) -> (c -> d) -> (Either b c -> d)
15:08:55 * heatsink was trying to understand it as the reverse of (&&&)
15:09:07 <Pseudonym> But it's not.  It's the dual, not the reverse.
15:09:17 <Pseudonym> @type (Control.Arrow.&&&)
15:09:18 <lambdabot> (Control.Arrow.&&&) :: forall a c' c b.
15:09:18 <lambdabot> 		       (Control.Arrow.Arrow a) =>
15:09:18 <lambdabot> 		       a b c -> a b c' -> a b (c, c')
15:09:36 <Pseudonym> product <-> coproduct
15:09:37 <heatsink> @arr
15:09:37 <lambdabot> Arrr!
15:09:42 <heatsink> @pure
15:09:42 <lambdabot> Sorry, I don't know the command "pure", try "lambdabot: @listcommands"
15:09:57 <mich4545-> sny ideas what I should do to avoid the error?
15:10:01 <wagle> @arr matey!
15:10:02 <lambdabot> Ahoy mateys
15:10:38 <wagle> mich4545-: look at the code at line 14
15:10:58 <mich4545-> I did
15:11:06 <mich4545-> I dont understand why it wouldnt work
15:11:25 <wagle> mich4545-: if defining a function specifically using doubles, when its not supposed to care what values its using
15:11:45 <wagle> mich4545-: this is an instance?
15:11:53 <mich4545-> not an instance
15:12:04 <mich4545-> a function for a new type
15:12:20 <wagle> mich4545-: how many lines long is the function at line 14?
15:12:24 <mich4545-> 2
15:12:52 <wagle> mich4545-: thats short enough to cut&paste here, i think
15:12:53 <Oejet> djoVSmonads: Where and how is it used?  IO is the input/output type in Haskell and ST  is the state type.
15:13:03 <mich4545-> eg :: Integral a => Egy a -> String
15:13:03 <mich4545-> eg (E (n,d)) = show (div n d) ++ " + " ++ show n ++ "/" ++ show d
15:14:40 <wagle> mich4545-: why are you trying to declare such a general type in the first line?
15:15:14 <mich4545-> because it would be easier to write my instances later on , wouldnt it?
15:15:53 <wagle> (try commenting out the first line and see what happens..  if it works, you can use :t to see what type was inferred for the eg function)
15:16:05 <mich4545-> let me try
15:16:27 <wagle> whats the declaration for Egy?
15:16:29 <mich4545-> oh no wait
15:16:39 <mich4545-> sorry I gave you the wrong code, from a wrong hs file
15:17:08 <mich4545-> egy :: Integral a => Egy a -> String
15:17:08 <mich4545-> egy (E (n,d)) = show w ++ " + " ++ show f
15:17:08 <mich4545->       where
15:17:08 <mich4545->           w = div n d
15:17:08 <mich4545->           f = ceiling w
15:17:11 * boegel bounces
15:17:59 <wagle> whats the declaration for Egy?
15:18:08 <mich4545-> it works when I remove the first line
15:18:22 <mich4545-> it's
15:18:22 <mich4545-> newtype Integral a => Egy a = E (a,a)
15:19:30 <wagle> @type ceiling
15:19:31 <lambdabot> ceiling :: forall a b. (RealFrac a, Integral b) => a -> b
15:20:19 <mich4545-> what does this suggests?
15:21:08 <wagle> that i'm sicker and more fuzzy/light headed that i thought
15:22:04 <wagle> @type div
15:22:06 <lambdabot> div :: forall a. (Integral a) => a -> a -> a
15:22:29 <boegel> owow ! :)
15:22:32 <wagle> wtf does ceiling on a integer mean?
15:22:48 <boegel> wagle: +1 ? :p
15:23:22 <mich4545-> hmm good point
15:23:37 <fraxtal> rounding a number up to its nearest integer
15:23:47 <wagle> ceiling 1
15:23:47 <wagle> 1
15:24:00 <mich4545-> 1.2 -> 2
15:24:05 <boegel> fraxtal: but the number is an integer :) so no rounding necassary
15:24:08 <fraxtal> ceiling 1.1 = 2
15:24:12 <mich4545-> yeah
15:24:13 <boegel> 1.2 is not an integer
15:24:20 <wagle> Prelude> ceiling (1 :: Integer)
15:24:20 <wagle> ERROR - Illegal Haskell 98 class constraint in inferred type
15:24:20 <wagle> *** Expression : ceiling 1
15:24:20 <wagle> *** Type       : RealFrac Integer => Integer
15:24:24 <mich4545-> I know Im thinking why I did this
15:24:52 <boegel> wb everyone :)
15:25:12 <wagle> Prelude> ceiling (1 :: Integral a => a)
15:25:12 <wagle> ERROR - Unresolved overloading
15:25:26 <wagle> 8)
15:26:09 <mich4545-> what I actually want to do is for example divide 7 by 3 and get its ceiling
15:26:26 <mich4545-> this using integral, can it work?
15:26:35 <fraxtal> ah better definition: Ceiling x gives the smallest integer greater than or equal to x.
15:26:56 <mich4545-> so div 7 3 = 2 ceiling of it is going to be 3
15:27:04 <boegel> mich4545-: you cant divide two integers (as in by using /)
15:27:11 <boegel> it'll be 2
15:27:25 <mich4545-> cant I round it up to 3
15:27:35 <wagle> greater than _or equal_
15:27:36 <mich4545-> if not using Integer
15:27:37 <boegel> so you can check mod 7 3, if that's > 0, then you can do +1, else do nothing
15:27:52 <mich4545-> oh right, good thinking
15:27:57 <mich4545-> thanks for that
15:28:02 <boegel> np
15:28:03 <wagle> div 8 2 = 4... +1 == 5..  bazzzt!
15:28:18 <mich4545-> yeah wagle but if yo uuse mod as boegel said it will work
15:28:27 <wagle> ugh
15:28:56 <mich4545-> as my belgian neighbour said to be more specific
15:28:56 <wagle> past the baroque threshold
15:29:33 <mich4545-> boegel are you a student in belgium ?
15:29:46 <boegel> mich4545-: I am
15:29:55 <mich4545-> where are you studying?
15:29:58 <boegel> Ghent
15:30:08 <boegel> where are you from ?
15:30:12 <mich4545-> belgium
15:30:37 <boegel> are you a student too ?
15:30:42 <mich4545-> yes but in the uk
15:30:55 <boegel> where ? Oxford ? Cambridge ?
15:31:06 <mich4545-> nah not so clever ...
15:31:11 <mich4545-> leeds
15:31:23 <wagle> what formula is the result supposed to satisfy?
15:31:38 <boegel> football ! :)
15:31:50 <mich4545-> hehe not such a good team ;)
15:32:02 <mich4545-> wagle, you mean the whole program?
15:35:54 <Lemmih> shapr: Feeling like helping a fellow Haskeller using darcs/sendmail on Debian?
15:37:39 <Lemmih> shapr: Gonna bug you about it tomorrow. Bed time for me now.
15:39:15 <heatsink> I'm using the foreign function declaration syntax I found on the haskell webpage. GHC gives me terse errors.
15:39:37 <heatsink> foreign import ccall "unique.h uniq_create" cCreateUnique :: IO (ForeignPtr UniqueGen)
15:39:41 <Lemmih> heatsink: With -fffi?
15:39:50 <heatsink> No
15:40:01 <heatsink> I even searched the manual for "ffi" first
15:40:17 <Lemmih> The GHC user manual?
15:40:24 <heatsink> the manpages
15:40:38 <heatsink> They don't mention this switch.
15:41:16 <Oejet> heatsink: You could even put {-# OPTIONS -fffi #-} in your source so that option taken automatically.
15:41:39 <heatsink> cool.
15:43:55 <boegel> @info Integral
15:43:56 <lambdabot> -- Integral is a class
15:43:56 <lambdabot> class (Real a, Enum a) => Integral a where {
15:43:56 <lambdabot>     rem :: a -> a -> a {- has default method -};
15:43:56 <lambdabot>     div :: a -> a -> a {- has default method -};
15:43:56 <lambdabot>     mod :: a -> a -> a {- has default method -};
15:43:56 <lambdabot>     quot :: a -> a -> a {- has default method -};
15:43:58 <lambdabot>     divMod :: a -> a -> (a, a) {- has default method -};
15:44:00 <lambdabot>     quotRem :: a -> a -> (a, a);
15:44:02 <lambdabot>     toInteger :: a -> Integer;
15:45:19 * stepcut tries to decide if he should eliminate non-tail recursion from his function or not
15:46:52 * stepcut decides the challenge will do him good
15:47:04 <wagle> opaque code!  yummmm
15:47:12 <wagle> *<8-D
15:47:47 * heatsink concludes from the plethora of errors that it still understands neither the FFI nor arrows
15:47:55 <stepcut> heatsink: haha
15:53:52 <wagle> mich4545-: no, just what the div and ceiling stuff was supposed to satisfy..  hacking in stuff like "if the mod is > 0 then add +1 is hard to understand and easy to get wrong, especially if you later try to add even more stuff to the code..
15:56:00 <boegel> wagle: so how should he solve it ? you can't use (/) on Int's, can you ?
16:00:22 <mich4545-> wagle, for now it works
16:24:27 * boegel crawls to his bed 
16:24:32 <boegel> g'night everyone
16:25:49 <mich4545-> thanks for your help wagle
16:25:53 <mich4545-> I'm off for now
16:26:03 <mich4545-> goodnight
16:27:58 <heatsink> I don't understand how to call my FunPtr callable from haskell.  Can anyone help with FFI?
16:28:23 <heatsink> ooh, there's something on the wiki
16:38:31 <Cale> heatsink: That's strange, I'd expect there to be something of type FunPtr a -> IO a. If you know the type of your function pointer beforehand, I suppose you can write some C code which wraps that call, and import it, but that seems excessive.
16:39:13 <Cale> oh
16:39:47 <Cale> foreign import ccall "dynamic" mkFun :: FunPtr (CInt -> IO()) -> (CInt -> IO ())
16:40:03 <heatsink> yea, that didn't work for me.
16:40:22 <heatsink> I found out that I can import some functions in a way that they're callable from Haskell.
16:41:50 <heatsink> If the function's domain and range are marshallable by the FFI then I can import as a Haskell function type.
16:42:17 <heatsink> But I have a struct pointer.
16:43:34 <heatsink> foreign import ccall "test.h" c_id1 :: CShort -> IO CShort
16:43:34 <heatsink> foreign import ccall "test.h" c_id2 :: ForeignPtr Something -> IO (ForeignPtr Something)
16:43:34 <heatsink> foreign import ccall "test.h" c_id3 :: FunPtr (ForeignPtr Something -> IO (ForeignPtr Something))
16:44:00 <heatsink> Only the second declaration causes errors.
16:45:15 <Cale> what's the error?
16:45:34 <heatsink> Unacceptable result type in foreign declaration: IO (ForeignPtr Something)
16:45:49 <heatsink> and another error for the argument type.
16:45:57 <Cale> Something is Storable?
16:46:29 <Cale> I suppose it shouldn't matter
16:47:07 <Cale> Well, ForeignPtr Something needs to be Storable anyway, but I'd expect that it would be.
16:47:26 <heatsink> Hmm, here on page 23 it says "there is no instance of Storable for foreign pointers."
16:47:33 <heatsink> I'll try converting that to a ptr.
16:59:09 <djo> "A pure functional language cannot update values in place because it violates referential transparency" ???? I don't understand a word
17:01:31 <heatsink> Do you understand "update values in place"?
17:02:08 <heatsink> If you're familiar with c, basic, python, or lisp then you already know the concept.
17:03:12 <jlouis> A purely functional language cannot have side effects, because when side effects are allowed, functions does not always return the same value for fixed input (eg. if f(5) = 7 the first time it is called, altered state in the system might have f(5) = 9 the second time it is called)
17:05:12 <djo> what does the $ do ?
17:05:34 <djo> in the documentation it's said "($) :: (a -> b) -> a -> b"
17:06:55 <heatsink> It's the same as function application, but with different precedence.  It's useful for writing code with fewer parentheses.
17:28:22 <heatsink> yay, it works.
17:30:11 * heatsink goes off to eat something
18:23:58 * stepcut now has an accounting book
18:51:04 <heatsink> what does this line from the hierarchical libraries mean?  Specifically, the m -> s thing.
18:51:06 <heatsink> class Monad m => MonadState s m | m -> s where
18:56:11 * heatsink is trying to write an ArrowState class
19:38:30 <jlouis> heatsink: the m -> s is a functional dependency
19:40:57 <jlouis> the meaning is that m uniquely determines s
19:42:51 <heatsink> ok
19:45:19 <jlouis> so in M -> S, if m1 is some type of M, m2 is some type of M and s is some type of S. Then if we have MonadState m1 s and Monadstate m2 s, we have that m1 == m2
19:45:41 <jlouis> that is, it behaves like a function f: M -> S
19:45:56 <jlouis> ehm, I am sleeping
19:46:03 <jlouis> the other way around
19:46:14 <jlouis> m \in M, s1, s2 \in S
19:46:51 <jlouis> MonadState m s1 and MonadState m s2 implies s1 == s2
19:47:24 <jlouis> informally: if m is fixed to some specific type, we know what s is
19:49:33 <heatsink> Is it possible for the type checker to infer that from the get function in the class,
19:49:37 <heatsink>    get :: m s
19:59:08 <jlouis> exactly. The put :: s -> m () is the problem actually. We give it some s and get an m () back, but how can we be sure we are talking about the correct s,m pair? The functional dependency tells us, that once we determine what type m has, we know (by the instance of the MonadState class) what type s has
20:01:07 <heatsink> ok, I see.
20:06:22 <heatsink> thx
21:52:14 <musasabi> morning
21:52:47 <Cale> Evening :)
22:41:23 <stepcut> hrm...
23:04:35 <pesco> Good morning.
23:05:24 <skew> good morning
23:06:32 <skew> I was wondering who it is already morning for
23:06:47 <pesco> Germans, for instance.
23:07:18 <pesco> Caltech. That must be about 9 hours earlier. 11pm?
23:07:27 <skew> yes
23:07:41 <pesco> Good evening then. :)
23:09:13 <skew> Most people in #haskell seem to be in europe
23:09:31 <pesco> Quite a few at least.
23:10:48 <skew> Most work in Haskell too.
23:11:01 <pesco> Yes, it seems so.
23:12:07 <skew> It seems I'll have to go to a european university for graduate work
23:12:22 <pesco> Heh, since you want to do graduate work on Haskell?
23:13:22 <skew> Maybe not exactly Haskell, but something more formal
23:13:47 <skew> type theory, category theory for programming or semantics, that sort of thing
23:14:11 <pesco> Yeah. And you're sure there's nothing appropriate in the USA? Just curious.
23:15:07 <skew> I haven't looked very hard, but I haven't happened across much
23:15:18 <pesco> I see.
23:16:58 <skew> Haskell, Clean, Ocaml, Erlang, Epigram - all european groups
23:17:20 <pesco> Right. I never noticed that.
23:19:29 <pesco> Sadly my university (Hamburg) doesn't seem to care much about them either.
23:19:45 <pesco> But hell, somebody has to start doing it, right? ;)
23:22:10 <pesco> Although I'll move into the direction of formal program verification, I think. Still, considering Haskell's strong impression it has made on my programming, I doubt it won't be involved. After all type systems are a tool for guaranteeing correctness properties.
23:22:52 <skew> Epigram is interesting in that direction (and a few others)
23:23:06 <skew> I like the idea of integrating a theorem prover and an editor
23:23:15 <skew> and a type system
23:23:34 <a5> skew is a pageboy
23:23:43 <a5> what is epigram
23:24:16 <pesco> And seeing a talk lately about how some people in Dresden (IIRC) actually formalized C enough to be run through a prover, makes me think very much Haskell and whatever comes after it will make a good foundation.
23:24:39 <skew> hello a5 - do I know you?
23:24:45 <pesco> Yes, Epigram's dependent types are definately important.
23:24:59 <a5> skew: no i don't think so
23:25:14 <skew> epigram is an interesting language
23:25:15 <pesco> And integrating the type system and theorem prover into the development environment seems logical.
23:25:29 <skew> a5: you seem pretty familiar with the Caltech IP space, anyway
23:25:58 <pesco> kzm: Welcome back. Sorry for dropping out on you yesterday. I had to leave my location in a hurry. ;)
23:26:14 <skew> a5: and the house names. Caltech alum?
23:26:52 <a5> uh yeah. but your domain name is page-148
23:27:06 <skew> yep
23:27:23 * pesco moves to get some work done.
23:27:38 * pesco waves.
23:27:42 <a5> is epigram better than haskell? what are dependent types?
23:27:45 <skew> hi
23:27:46 <a5> bye pesco
23:27:55 <skew> epigram is an incompletely little toy language
23:28:14 <skew> if you want integers you build them yourself in unary
23:28:15 <pesco> a5: Dependant types are types which depend on values. As in "list of 5 ints"
23:28:28 <skew> but the type system and editor are really cool
23:29:00 <skew> pesco: I think correctness is only half the story with types.
23:29:14 <a5> i really need those
23:29:16 <pesco> skew: What's the other half?
23:29:25 <pesco> a5: Many do. ;)
23:29:43 <skew> pesco: I'm also really impressed by the way the type class system and the epigram editor and similar systems can generate code from type information
23:29:46 <skew> so I don't have to
23:30:11 <pesco> skew: Right. The Curry-Howard-correspondence maybe?
23:31:02 <skew> A theorem prover seen through the correspondence, I suppose
23:32:32 <skew> The correspondence is also important because it lets language designers steal bits of mathematics, but that's not everyday programming
23:32:55 <skew> I think it's more about being able to express intent in a machine-usable form
23:33:16 <pesco> I see.
23:37:21 <a5> but isn't that another way of saying correctness. precision of expression
23:38:02 <skew> I'm writing a paper on types with a heavy focus on Haskell for a technical writing class. I came here to talk to sound out what I'm thinking, and hopefully get some advice.
23:38:47 <skew> a5: I suppose so, but it's not just about program correctness.
23:38:59 <pesco> a5: A program is correct if it works as intended. It's unimportant how it was expressed.
23:40:21 <pesco> a5: Of course expressive power can help you tremendously but it's still possible (theoretically) to write a correct program in machine code.
23:40:24 <skew> The type checker makes sure that your program and types agree according to the type system. Sometimes that's enough to ensure some correctness properties.
23:40:35 <skew> pesco: compilers do that all the time :)
23:40:52 <pesco> skew: :)
23:41:32 <skew> a5: What I was saying about generating code was more that once you have written a type then a compiler can look at it and put it to use
23:41:33 <pesco> skew: So we all hope. ;-)
23:41:50 <pesco> (about compilers writing correct machine code)
23:42:05 <a5> one of my points would be that types are a sort of scaffold for the design process, is this different from what you're saying?
23:42:39 <skew> like generating a type class instance in a Haskell program, or writing down the skeleton of your function in epigram
23:43:06 <stepcut> hrm, my symbol table is a circular list :p
23:43:23 <skew> a5: I think it goes a bit beyond just being part of the design process
23:43:35 <pesco> a5: They are, but as I understand skew, they can also become the material beyond the scaffold.
23:43:56 <skew> types can be part of the design process if you're writing machine code, back in ancient times
23:44:31 <a5> i'm talking about the design process as a continual, never-ending thing
23:44:34 <a5> that lives with the program
23:45:04 <skew> Two nice things about making types a part of a language and compiler is that the machine can pitch in with making sure you're using the types sensibly, and the usually it's really smart people making the type systems so they do it right.
23:46:19 <a5> is there a way to use ghci in a #! line at the top of a script?
23:47:16 <pesco> I think there already is a run-ghc somewhere on the net.
23:47:32 <pesco> But it's not in the 6.2.2 distribution.
23:47:55 <a5> oh runghc is in my path
23:47:55 <pesco> Maybe in 6.3 already.
23:48:06 <pesco> Heh. Which version do you have?
23:48:30 <Gahhh> it's going to be in 6.4
23:48:52 <skew> so many nice things are going in 6.4
23:49:15 <Gahhh> I care about runghc the most personally
23:49:40 <skew> you want to make scripts?
23:49:56 <Gahhh> Yes. Most of the stuff I can write is not worth keeping an exe around
23:50:47 <skew> I don't mind. I've got "main = interact $ unlines . nubBy isPrefixOf . lines" sitting in ~/bin
23:50:53 <pesco> skew: Does it finally accept UTF-8 input? (GHC 6.4)
23:50:53 <a5> 6.2.2
23:50:59 <pesco> a5: Strange.
23:51:06 * pesco shrugs.
23:51:13 <skew> I don't remember. I'll check
23:54:51 <Itkovian> meuning
23:55:11 <a5> skew: what does that do?
23:55:23 <skew> I don't see anything in the updates, and the CVS version I have doesn't like greek in a string.
23:55:34 <skew> a5: what does what do?
23:56:05 <pesco> skew: Grmbl. That's annoying.
23:56:30 <skew> pesco: what do you want to do with UTF-8?
23:56:43 <pesco> skew: Write prettier programs.
23:56:59 <pesco> And I'd like real lambdas, too. ;)
23:57:47 <pesco> I want to use alpha etc for my type variables.
23:57:52 <pesco> I want to use real arrows.
23:57:56 <skew> I remember that working in some language. Maybe OCaml? Or maybe I'm just thinking of lhs2tex, which is excellent for making pretty code
23:58:08 <pesco> I know, lhs2TeX is what I use.
23:58:38 <pesco> But I'd like all the prettyness in vim.
23:58:58 <skew> It's not fancy while you're making it, but at least it's not ugly like TeX - I use LyX now because I couldn't read my equations
23:59:27 <pesco> Anyway, it's not a problem writing a preprocessor in a day or so, but I'd thought that maybe they would have finally gotten around to it.
23:59:41 <skew> You could fill out the survey
23:59:49 <pesco> I am. :)
