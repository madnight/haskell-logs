00:03:25 <a5> what is the use of this dynamic stuff
00:03:47 <a5> (which i'm sure is really great ;) )
00:25:03 <dons> oh, not so useful yet. you can implement embedded interpreters
00:25:10 <dons> printf etc.
00:25:29 <dons> and other things where you would like an 'eval' function
00:26:02 <dons> there's some people using eval in webserver-like aps to use haskell as a scripting language
00:26:09 <dons> it's used in my Yi editor this way.
00:26:29 <dons> hmm. so maybe it is fairly useful - but still definitely a research topic
00:27:23 <dons> but I'm sometimes of the opinion that eval :: String -> t is enough, without the full staged computation system
00:27:46 <dons> anway, got to go. dinner time in GMT+11 !
00:29:10 <jyasskin> Is anyone else running into problems with the haskell98 package in ghc 6.4?
00:29:23 <musasabi> morning
00:29:36 <jyasskin> 'evening ;)
00:30:46 <jyasskin> In 6.2, I could define a module called just 'Time', but 6.4 complains that it's already in haskell98. :-P
00:31:22 <jyasskin> And worse, the template-haskell package depends on it, so I can't just hide it.
00:31:31 * jyasskin complains
00:32:35 <musasabi> jyasskin: using hierarchial modules helps.
00:35:19 <jyasskin> These are local, so, I suppose I stictly ought to be defining Local.Time, but that's more typing than I'd like to do.
00:36:57 <jyasskin> Time (and CString) aren't even listed at the root of the heirarchical libraries docs for ghc.
00:43:28 <musasabi> All haskell-98 implementations should have them ;)
00:50:05 <jyasskin> grr, yes. But I'm still annoyed that I can't hide them without killing template-haskell too.
01:00:18 <wilx> Hmpf....
01:15:22 <a5> using WASH - how do I make this more readable: (table . (border "1" >>)) $ do tr ...
01:45:41 <boegel> @seen samc
01:45:42 <lambdabot> I saw samc leaving #haskell 2 days 17 hours 35 minutes 39 seconds ago.
01:46:02 <boegel> @seen Itkovian
01:46:03 <lambdabot> I saw Itkovian leaving #haskell 2 days 17 hours 6 minutes 5 seconds ago
01:46:09 <boegel> heh :)
01:51:47 <Lemmih> Hello, team member.
01:52:29 <Oejet> Lemmih: Do you have a team for ICFP?
01:53:00 <Lemmih> Nope.
01:54:03 <Oejet> Lemmih: Ah, I see, it's a seeectret team. ;-)
01:54:19 <Igloo> Feels like picking teams back at school  :-)
01:54:25 <boegel> Lemmih: what's our wiki page again?
01:54:41 <Lemmih> @wiki TeamSuccGMT
01:54:41 <lambdabot> http://www.haskell.org/hawiki/TeamSuccGMT
01:54:58 <boegel> new members are welcome :p
01:55:39 <jlouis> SuccGMT, hehe
01:55:50 <Igloo> What's SuccGMT meant to mean exactly?
01:55:52 <Oejet> What are the meetings about?
01:56:00 <jlouis> Igloo: Successor to GMT?
01:56:07 <Igloo> BST or places 1 hop East of Greenwich?
01:59:42 <Lemmih> Oejet: Good question. Let's hold a meeting deciding that.
02:14:02 <boegel> Lemmih: so our first meeting is about what our meetings will be about ?
02:16:29 <Lemmih> When to hold this meeting should also be discussed.
02:35:41 <musasabi> What would be a good way to interface a function that should take both handles and filepaths with some extra options - e.g. compression and use that as a sink.
02:37:23 <Oejet> musasabi: Maybe a data = Compr Int | Other Options, like with ReadWriteMode?
02:37:48 <Oejet> No, bad choice.
02:38:14 <wilx> Hmm, it should get [] of bytes and produce [] of bytes :)
02:38:16 <Oejet> musasabi: Why do you need both handles and filepaths?
02:38:26 <musasabi> that is it can take: (Handle | FilePath) * [CompressionOrCheckSumAlgo] * Maybe BufferSize * Maybe DecoderState * Maybe EncoderState
02:40:05 <Oejet> Then define it like that and make wrapper functions for default uses.
02:41:40 <musasabi> is it cleaner to have a typeclass for the Handle | FilePath, separate functions or a datatype ?
02:43:33 <Oejet> data Source = H Handle | F FilePath looks pretty clean to me.
02:45:25 <Oejet> I think you want to make wrapper functions anyway, so e.g. extract :: Handle -> IO String and compress :: String -> Handle -> IO ().
02:45:50 <Oejet> That is what I did with LibBzip.
02:51:03 <musasabi> I think I will setle with:
02:51:04 <musasabi> data SerializerSource a = SSFile FilePath | SSHandle Handle | SSRaw a
02:51:12 <musasabi> encoder :: SerializerSource PFun -> [SerializerFilter] -> Maybe SMap -> (SEnv a -> IO a)
03:07:27 <wilx> Huh, this looks complicated.
03:30:00 <araujo> Good morning.
04:39:12 <bourbaki> servus
05:30:11 <wilx> Hmm...maybe I should use explicit stack instead of recursion so that I can save the state.
05:30:21 <wilx> Does it sound bad?
05:39:14 <Itkovian> hi all.
05:39:41 <xerox> Hi.
05:41:57 * Lemmih heads to bed.
05:57:37 <RemiTurk> hi all
05:59:07 <lightstep> hello
06:10:30 <pesco> Äh...
06:11:08 * RemiTurk says hi as he guesses the garbage my client shows means "hello"
06:11:38 <xerox> RemiTurk: it is "Ah" with two dots over the 'A' :)
06:12:02 <pesco> Which means as much as "Er..."
06:12:22 <RemiTurk> :)
06:12:51 <RemiTurk> it's shown as an A with a tilde above it followed by a box with 00two-unreadable-digits here ;)
06:13:12 <pesco> RemiTurk: Switch your terminal to UTF-8.
06:14:34 <wilx> Hmm, I am missing isLeft/isRight predicates...
06:15:04 <RemiTurk> I doubt my xchat is capable of doing that, giving that my old distro has totally crippled unicode support :)
06:15:25 * RemiTurk is looking for a new one, but hasn't found a good one yet after a few years of searching
06:15:33 <xerox> RemiTurk: xchat can use UTF-8.
06:15:35 <RemiTurk> wilx: you'll have to define them yourself then
06:15:52 <wilx> I know but what if I am too lazy to do so?
06:16:03 <sorje> wilx, just stop missing them.
06:16:11 <wilx> :))
06:16:19 <RemiTurk> wilx: sit back and enjoy the weather :P
06:16:40 <RemiTurk> xerox: tell me, I'm curious _how_ broken my unicode support exactly is ;)
06:17:50 <xerox> RemiTurk: /CHARSET
06:19:43 * RemiTurk wonders whether pesco would like to say the "Er..." word again for me
06:20:37 <xerox> Äh...
06:21:00 <xerox> hiya boegel
06:21:18 <RemiTurk> xerox: you're right, it actuall works even here :)
06:21:25 <xerox> :-)
06:22:00 <xerox> Gøød ŧØ ĸñøw
06:22:19 <RemiTurk> xerox: now that we've turned #haskell into #xchat-help anyway, could you tell me how to automatically execute /charset on startup?
06:22:21 <boegel> hey xerox
06:22:32 <xerox> RemiTurk: check the configuration file.
06:23:33 <Oejet> So is #haskell an UTF-8 channel or an ISO-8859-1 channel?
06:24:29 <lightstep> ascii, i prefer
06:24:48 <RemiTurk> *found*
06:24:52 <lightstep> which is, of course, Asian SCII
06:24:56 <RemiTurk> :)
06:26:56 * Oejet can only set charset per server, and so stays with ISO-8859-1 to avoid trouble on other channels.
06:27:22 * RemiTurk isn't on any other freenode servers
06:33:48 <Oejet> RemiTurk: You mean channels?
06:34:15 <xerox> Oejet: UTF-8 is backwards compatible IIRC.
06:34:49 <integral> only with 7-bit ASCII, not the extended part of latin-1
06:36:28 <RemiTurk> Oejet: yes I do
06:37:21 <Oejet> xerox: I meant, that people don't like to read UTF-8 on an ISO-8859-1 display.
06:37:54 <xerox> Oejet: what do you mean with ISO-8859-1 `display' ?
06:39:27 <wilx> Hmm...What does a caller of runST get when computation fails using fail?
06:39:30 <wilx> State monad.
06:41:40 <Oejet> xerox: I mean being able to display that charset.
06:41:48 <boegel> @index fail
06:41:48 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
06:41:48 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
06:41:48 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
06:41:52 <xerox> Oejet: isn't it adjustable?
06:42:06 <RemiTurk> Prelude Control.Monad.ST> runST (fail "Hello")
06:42:06 <RemiTurk> *** Exception: Hello
06:42:06 <boegel> @type Monad.fail
06:42:07 <lambdabot> Monad.fail :: forall m a. (Monad m) => String -> m a
06:42:28 <wilx> Ah. Nice. Thanks.
06:42:29 <boegel> wilx: does this help ?
06:42:35 <wilx> Yup.
06:42:42 <boegel> there you go then :)
06:43:19 <Oejet> xerox: I've been talking to people before, who wanted be to change to latin-1.
06:43:21 <TheHunter> well, strictly speaking, fail doesn't make sense for many monads, among them ST.
06:43:49 <wilx> Hmm...Why?
06:43:52 <xerox> Oejet: that seem the UK's response to UTF-8: "here it's all right" ..
06:44:02 <TheHunter> so it just defaults to a regular `error'
06:44:19 <TheHunter> because ST doesn't support failure (like for example Maybe or [] does)
06:44:26 <wilx> Not ST, State.
06:44:43 <lightstep> is (ST s) transformable by ErrorT and the such?
06:45:57 <TheHunter> lightstep, yes, of course.
06:46:13 <wilx> I want to use fail to complain about wrong initial state for my computation.
06:46:32 <lightstep> wilx, fail is error in State
06:47:20 <wilx> Ok, then it doesn't matter what I will use anyway and I can as well use fail as error.
06:47:26 <TheHunter> so unless you want to use unsafeIOtoST, you'll have to make an ErrorT (ST s)
07:24:53 <shapr> gwahr
07:25:25 <xerox> hiya shapr
07:25:35 <shapr> y0y0 xerox
07:25:44 * xerox yoyos
08:19:12 <shapr> I guess this is a silly place to ask about the theory behind helicopter blades? I've just been considering a blade design based on cantor dust.
08:20:51 <Lemmih> ...
08:21:18 <mordechai> shapr, how would that work?
08:21:38 <mordechai> i cannot imagine cantor dust in 3d...
08:25:47 <shapr> It seems to me that you need a certain amount of space, and a certain amount of blade to get maximum lift from a helicopter blade.
08:26:56 <shapr> You can look at it as something close to cantor dust applied to a 2D circle. After you've figured out a good ratio of space to blade area, that is.
08:27:05 <shapr> Makes sense?
08:27:49 <jberg_> i don't get it. can you draw an image of the blade?
08:28:53 <wilx> o_O
08:31:34 <shapr> I suspect the best ratio of space/blade will be dependent on the rotational speed, and that speed at a particular part of the blade depends on the distance from the center of the blade at whatever is the most efficient rpms for the entire blade.
08:31:50 <wilx> I am getting some error messages about overlaping instances where both instances are for Eq (Dict a), Dict a being my type, and both are on the same line which also happens to be the line where the type is declared.
08:40:56 <RemiTurk> wilx: sounds interesting. may we see the code?
08:43:47 <wilx> Yup. Just a sec.
08:48:19 <wilx> http://logout.sh.cvut.cz/~wilx/lzw/LZW.hs
08:48:28 <wilx> and you will need http://logout.sh.cvut.cz/~wilx/lzw/Utility.hs too.
08:48:43 <wilx> Line 49.
08:51:18 * RemiTurk doesn't get any errors
08:51:35 <RemiTurk> although I do get warnings about multiple imports of IntMap and Map
08:54:07 <metaperl> wilx, how about homepage in English? :)
08:57:29 <wilx> >_<
08:57:34 <wilx> Do not try to open it.
08:57:40 <wilx> It is soo old.
08:57:56 <wilx> I made it when I was yet yound and stupid,
08:58:02 <wilx> That's why it looks how it looks.
08:58:16 <wilx> Hmm...
08:58:23 <wilx> Strange...
08:58:30 <wilx> GHC 6.4?
08:59:50 <TheHunter> works here, too: ghc 6.4.20050303
09:01:54 <wilx> Hmm, could you try :l in GHCi?
09:02:23 <wilx> Don't forget to rm LZW.o
09:02:54 <TheHunter> it works fine.
09:03:35 <TheHunter> hmm, i should get a newer ghc, but i fear an "apt-get dist-upgrade" would remove ghc6.2.2
09:03:53 <wilx> Bah, I am not making things up...let me try it in fresh GHCi.
09:04:17 <wilx> Yay!
09:04:22 <wilx> It loads fine.
09:05:56 <wilx> This is what I am getting: http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
09:06:04 <wilx> But not in new instance of GHCi.
09:56:12 <shapr> Having a cold sucks.
09:57:09 <RemiTurk> definitely
09:57:28 * RemiTurk hands shapr a handkerchief
09:58:49 <RemiTurk> wb
09:59:30 * pesco nods.
09:59:41 * pesco cheers.
09:59:57 <pesco> I found this awesome graphical keyboard layout editor for mac os today.
10:00:31 * RemiTurk waits for a screenshot
10:00:35 <pesco> I am now typing on the Dvorak-Hallberg layout.
10:00:51 <pesco> RemiTurk: It's called Ukelele, ask Google.
10:00:54 <pesco> ;)
10:01:16 * RemiTurk still never tried dvorak
10:02:42 <pesco> I retrained some years ago. Just make sure you do it properly if you try it. You'll just have to believe people how much more fun it is once you're through training (which takes what, three days?)
10:03:12 <shapr> Took me more like a week.
10:03:43 <pesco> As someone on this channel put it once "It's like for some words I just hit the keyboard in a single smash and they come out".
10:03:46 <shapr> Maybe because I couldn't touchtype at all when I switched from hunt-and-peck qwerty to learning touchtyping on dvorak.
10:04:22 <pesco> shapr: That might well be it.
10:04:48 <shapr> Yet again my explorations have led me to weird places. Now I am investigating the Coanda effect and how it applies to 60s-futuristic flying cars.
10:05:05 <pesco> shapr: Amazing.
10:05:12 <shapr> Does this sort of journey of exploration happen to everyone?
10:05:23 <pesco> shapr: Please describe the Coanda effect.
10:05:32 <shapr> http://en.wikipedia.org/wiki/Coanda_Effect
10:05:43 <shapr> basically, it's the frisbee effect
10:05:44 <pesco> shapr: I don't think I've ever ended up with 60s-futuristic flying cars...
10:06:00 <shapr> fluid tends to stick to a surface, that's how frisbees stay in the air.
10:06:03 <pesco> shapr: What's the frisbee effect? "Flying"? ;-P
10:06:09 <mordechai> i asked google:
10:06:09 <mordechai> http://images.google.com/images?q=Ukelele&ie=ISO-8859-1&hl=en&btnG=Google+Search
10:06:17 <mordechai> :D
10:07:33 <shapr> pesco: yeah, pretty much. This fits into another neat airplane design I saw recently that I can't remember the name of..
10:08:15 <shapr> In that new design, they put an eggbeater fan on the front of the wing and force air across the top of the wing, giving lots of low-speed lift.
10:10:45 <shapr> That's what I would choose for a personal flying vehicle, the equivalent of a flying pick-up truck.
10:11:16 <mordechai> http://www.exn.ca/Stories/2003/03/04/52.asp
10:11:17 <pesco> Damn, my xterm font does not include "MATHEMATICAL BOLD SMALL LAMBDA".
10:11:44 <pesco> shapr: Winnebago. (Is that spelled right?)
10:11:55 <shapr> Yeah, it is :-)
10:12:07 <shapr> I am *so* offtopic today.
10:12:17 <shapr> Ok, I'll make a conscious effort to get back on-topic.
10:12:29 <pesco> Heheheh.
10:12:47 <shapr> I've been reading up on the fixpoint combinator, and I'm beginning to think it's nothing more than an explicit recursion combinator.
10:12:57 <pesco> I can't concentrate. I'm out of Enterprise episodes!
10:12:59 <shapr> as in, fix == Y from lambda calculus.
10:13:25 <mordechai> x
10:14:13 <pesco> I still know too little about the lambda calculus. Had to put TaPL on hold for Analysis.
10:14:18 <shapr> I originally thought the goal of the fixpoint function was to find the value for which f x == x, is that important at all?
10:14:29 <pesco> Which reminds me of the exercises I should be doing.
10:14:41 * pesco wrestles himself.
10:14:43 * shapr does push-ups, or maybe they're really fall-downs
10:14:59 <RemiTurk> shapr: fix = Y, AFAIK
10:15:25 <skew> shapr: It's the same thing
10:15:49 <RemiTurk> and I recently found out it's actually practially useful too: when using fix to define your recursion you can trivially make it bounded recursion for example
10:16:01 <skew> all the category theory papers use the magic words "least fixed-point of the domain equation" to describe recursive definitions
10:16:40 <shapr> Seems unnecessarily confusing to me.
10:17:08 <shapr> But maybe there's something I don't yet understanding about fixed-point values greater than the least fixed-point.
10:17:33 * RemiTurk is planning to follow a course on CT next year
10:17:43 <tuomov> well, the least fixed point of a List-like data structure definition does not include infinite lists, greatest does
10:17:46 <skew> Y is just finding x so f x == x, for the special case where x is a function
10:18:04 <skew> Not that that's saying much in the lambda calculus...
10:18:14 <shapr> Oh, that makes sense.
10:18:22 <shapr> From a very strange viewpoint.
10:18:31 <skew> but it makes a difference in scheme
10:18:45 <skew> where everything is strict so bottom is always a fixedpoint, and the least defined one at that
10:19:18 <bringert> how the hell can xinput be completely undocumented?
10:19:25 * bringert is also off topic
10:19:43 * pesco laughs manically at bringert.
10:19:50 <tuomov> how can all x extensions be undocumented?-)
10:20:04 * pesco runs around in circles, arms wavingy.
10:20:17 * shapr documents the X with its least fixed point.
10:20:46 <shingoki> Is there any support for OO in haskell?
10:20:49 <shapr> Yes.
10:20:52 <pesco> No.
10:21:00 * pesco stares.
10:21:19 <shapr> shingoki: http://lambda-the-ultimate.org/node/view/319
10:21:29 <pesco> shingoki: I'm sorry, I'm just becoming mentally unstable.
10:21:37 <skew> usually there's a better way, though
10:21:40 <RemiTurk> http://www.google.com/search?q=OOHaskell
10:21:41 <shapr> I tried mental stability once, it was boring.
10:22:03 <shapr> yeah, what skew said. Doing OO in Haskell is rarely the idiomatic approach.
10:22:23 <pesco> First they talk about fix points and recursion combinators, then someone starts about undocumented X extensions.
10:22:30 <tuomov> stability is synonymous with boring, and not just in mental context
10:22:36 <shapr> undocumented fiXpoint eXtensions!
10:22:49 <pesco> shingoki: It's utter madness. Leave this channel while there's still time...
10:22:50 <shapr> tuomov: on the other hand, the ancient chinese curse...
10:22:53 * shapr snickers
10:22:55 <shingoki> heh
10:22:56 <musasabi> OOHaskell (the new HList based one) looks very promising.
10:23:04 <skew> OOHaskell is an extreme application of lots of techniques that can probably be used less painfully to solve whatever problem you have
10:23:08 <musasabi> but 1) error messages, 2) performance.
10:23:17 <shapr> skew: that's nearly quotable
10:23:19 <shingoki> Well, I'm completely new to fp but I like the look of it, so I'm trying to pick a language
10:23:26 <shingoki> I've looked at OCaml and it seems nice
10:23:35 <shapr> shingoki: you've found the purest FP language!
10:23:41 <skew> Haskell is the nicest language
10:23:50 <shingoki> Yeah I like the concept of immutability
10:23:52 <shapr> shingoki: what's your goal? learning FP?
10:23:59 <RemiTurk> in some way Unlambda might be purer
10:24:06 <musasabi> OCaml is easier to get to the start, but haskell is more internally consistent and clean.
10:24:14 <shingoki> Well, I'm a Java coder, so I don't need everything to be perfect
10:24:16 <skew> RemiTurk: nah, it has stateful IO. Lazy SK
10:24:29 <shingoki> I'm just looking at different languages
10:24:40 <skew> shingoki: Haskell is good for that
10:24:43 <shingoki> python made me want to cry
10:24:48 <shingoki> OCaml looks nice and has OO
10:24:50 <RemiTurk> skew: stateful IO? damn, now I can't pretend to ever have used it anymore
10:25:07 <kosmikus> shingoki: but no one is using OO in OCaml
10:25:10 <skew> RemiTurk: IO by side effect. Ewww
10:25:18 <shingoki> kosmikus, really?
10:25:29 <shingoki> I don't think I can move away from OO, I like it too much
10:25:34 <kosmikus> well, that's my impression at least
10:25:42 <skew> shingoki: what is bad about Python?
10:25:43 <shapr> Any experts on the enigma game here? I need a hint on the "Send More Money" level.
10:25:51 <shingoki> skew, what isn't?
10:26:03 <skew> shapr: sounds familiar
10:26:07 <pesco> shapr: What enigma game?!
10:26:15 <shingoki> no python isn't that bad but its moving in the opposite direction to wher eI want to go
10:26:17 <tuomov> shingoki: maybe you don't really want OO, but just some things that are often considered only come with OO?
10:26:24 <musasabi> shingoki: OO exist in OCamls but is not really used outside the examples.
10:26:45 <shapr> pesco: you don't want to know, it's horribly addictive.
10:26:53 <skew> shingoki: I mean, tell me what you didn't like about Python to give me some idea where you are going
10:27:13 <shingoki> skew, The "gee i hope this is the right type, would be nasty if it wasn't" approach
10:27:14 <pesco> shapr: OK, let's leave it ticking in the back of my head until I'm over my exam...
10:27:19 <shapr> pesco: yeah, good idea.
10:27:20 <shingoki> and everything else that works the same way
10:27:28 <shingoki> like not declaring variables
10:27:35 <skew> I don't mind the Python type system that much...
10:27:36 <shapr> I'm unhappy that Python is planning to leave the FP world.
10:27:38 <shingoki> and also it seems like it is stuck together with duct tape
10:27:45 <skew> I really hate the java one.
10:27:54 <skew> shingoki: Python is a bit crufty inside
10:27:56 <tuomov> dynamic typing is typing with duct tape
10:27:57 * pesco turns on the "TV" to watch Max Headroom in substitution for Enterprise.
10:28:01 <shingoki> Things are done this way, except if they are done one of the other 3 ways, and by the way, none of them are compatible
10:28:02 <pesco> See you.
10:28:18 <shapr> I'd like to watch Max Headroom too!
10:28:31 <shingoki> I like Java now it has generics, although I'm sure the implementation has disadvantages
10:28:51 <wilx> Everybody should use Ada.
10:28:53 <shingoki> it still manages to be pretty flexible and also flag a good deal of errors, which seems like the important thing
10:28:57 <tuomov> modern fp language like haskell, otoh, have type inference so you don't need type declarations and it is as easy to do quick prototyping as with dynamiaclly typed languages
10:28:57 <pesco> shapr: Here's a tip: Ask Google about Max Headroom torrents. You'll find what you're looking for.
10:29:03 <RemiTurk> shapr: I'm not sure python is leaving the FP world, iterators look quite familiar to me..
10:29:08 <musasabi> shingoki: if you like principled approaches then choosing between ocaml and haskell is easy.
10:29:09 <shingoki> Yes I like the look of the type inference
10:29:32 <shingoki> I'm not that sure that it is perfect though, just from messing about in ocaml
10:29:52 <shingoki> I don't really understand if there is a way to distinguish types that are "equal" from ones that are identical
10:30:05 <tuomov> you can always write type declarations.. and in case of some extensions it is necessary
10:30:13 <skew> In Java it's like "gee I wish I could write down the type of it's function. Nope, guess I need to write another cast through Object and hope everything has the right type"
10:30:13 <shingoki> like if you don't just want a pair of integers, you want a specific TYPE of pair of integers
10:30:14 <shapr> RemiTurk: Have you seen the discussion on LtU?
10:30:35 <skew> "And the damn language makes me write down types anyways!"
10:30:44 <shingoki> skew, Well using Object and cast is no better than just forgetting types completely really, but that is what generics have gone some way to fixing
10:30:54 <tuomov> shingoki: you can always restrict polymorphism with explicit type declarations if you want to
10:30:55 <shingoki> but yeah it used to be nasty
10:31:05 <kosmikus> shingoki: you can make new distinct datatypes that are isomorphic to existing types
10:31:09 <shingoki> getting Object from collection and casting is evil, but generics do let you do it more easily
10:31:28 <shingoki> isomorphic means having the same constituent types?
10:31:34 <shingoki> I don't know the terms :)
10:31:38 <RemiTurk> shapr: not sure..
10:31:49 <skew> shingoki: I object to pretending the language is typed, and forcing me to write down lots of types, and then not getting anything from the typesystem in return.
10:32:01 <shingoki> skew, you get what you always get, compile-time checking
10:32:14 <shingoki> It's just not good for polymorphic stuff unless you use generics, which aren't taht bad
10:32:18 <kosmikus> shingoki: isomorphic means that there's a one-to-one correspondence between values of the two types
10:32:19 <shapr> RemiTurk: http://lambda-the-ultimate.org/node/view/587
10:32:20 <skew> shingoki: with runtime checks whether the casts through Object worked....
10:32:33 <skew> Which means you can't write any polymorphic functions.
10:32:37 <shingoki> skew, yes but ideally with generics you eliminate those runtime casts
10:32:46 <shingoki> skew, I'm not defending java pre-1.5 at all
10:33:04 <shingoki> I'm just saying it has got far better with generics
10:33:25 <shingoki> seems like generics and any type based system still fall short of the contract based stuff like in eiffel though
10:33:43 <skew> I think of dymanically typed languages as sort of a degenerate case of languages with nice type systems. You can code anything and get no guarantees, with no cost of writing down types.
10:33:44 <shingoki> at least as far as those contracts can be checked at compile-time, still not sure on that one
10:33:45 <shapr> shingoki: wait till you've spent a few months writing Haskell, then I'd like to hear your opinion of the way Java does things.
10:33:46 <RemiTurk> shapr: {filter,map} -> itertools.{ifilter,imap}, and I actually almost never use reduce in python for some reason :)
10:33:56 <musasabi> eiffel is nice, but contravariance causes problems.
10:34:05 <shingoki> shapr, I'm already pretty convinced haskell and ocaml are far better
10:34:12 * RemiTurk goes to dinner
10:34:14 <tuomov> RemiTurk: they're removing lambda!
10:34:21 <shingoki> shapr, I'm just pointing out that the old Object and cast thing has got a little better in java
10:34:33 <tuomov> (not that _I_ ever liked python anyway)
10:34:43 <shingoki> I can already see things that aren't really possible in Java that should work with type inference
10:34:54 <skew> shingoki: Like what?
10:34:59 <skew> I can't think of much.
10:35:08 <RemiTurk> _if_ a nice currying class/function is introduced I wouldn't even mind about that too much...
10:35:11 <musasabi> shingoki: in java I am more annoyed that it is hard to write a e.g. function which returns a list of pairs.
10:35:12 <RemiTurk> @wiki ThingsToAvoid
10:35:12 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid
10:35:26 <RemiTurk> "Don't overuse lambda's" :)
10:35:27 <shingoki> musasabi, well you need to first have a class Pair ;)
10:35:30 <shingoki> THen it is easy
10:35:34 <shingoki> List<Pair>
10:35:46 <skew> RemiTurk: How do you overuse lambda?
10:36:17 <RemiTurk> skew: I try not to, but see the ThingsToAvoid section about lambda's
10:36:25 <shapr> I'm definitely getting out of Python if at all possible. Removal of lambda, filter, map, and reduce will be very painful for me.
10:36:29 * RemiTurk is now really off for dinner
10:36:38 <skew> I can imagine a language like Haskell without type inference, that has a fancy type system but requires you to write down types
10:36:39 <shingoki> I don't know how anyone can use python
10:36:44 <shingoki> without reimplementing everything
10:36:46 <skew> Actually, Epigram is kinda like that
10:36:49 <musasabi> shingoki: actually you need List<Pair <A,B> > or somesuch and you still cannot patternmatch that..
10:37:08 <skew> shingoki: One thing that was nice about python was all the libraries for everything
10:37:14 <tuomov> and it generates new code for each such instance like c++?
10:37:15 <shapr> shingoki: it's a different way of looking at the world compared to Java.
10:37:19 <shingoki> I dunno
10:37:31 <shingoki> I don't really think python is much more than Java with the typing thrown away
10:37:37 <shingoki> but I haven't used it much
10:37:45 <tuomov> much more convenient to use...
10:37:54 <skew> shingoki: the syntax is nices and the reflection is handier
10:37:54 <shingoki> yeah but convenient at what stage of development?
10:37:56 <tuomov> java is too heavy for anything but bloated apps
10:38:03 <shingoki> thats a bad way to put it
10:38:05 <tuomov> I mean code-wise, not just the environment
10:38:18 <tuomov> which is also unrunnable on any hardware
10:38:24 <shingoki> a better way is to look at the curve of payback of each irritating feature with code size
10:38:31 <shapr> I switched from Java 1.0.2 to Python 1.5, so I could say a lot about it.... and I had paying Java gigs up to Java 1.3 or so. But it's hard to explain unless you've tried them both yourself.
10:38:33 <tuomov> start a java app and go buy more memory
10:38:33 <shingoki> for little scripts, you just dont need any "discipline"
10:38:39 <tuomov> while waiting for it to start
10:38:43 <skew> First class functions are horribly painful to fake in java
10:39:14 <tuomov> hello world is horribly painful in java
10:39:14 <shapr> shingoki: in any case, write more Haskell and tell us what you think about FP!
10:39:18 <skew> shingoki: so, what can you think of that type inference can help with? I'm interested
10:39:18 <tuomov> I hate doing everything with classes
10:39:23 <shingoki> skew, ah ok
10:39:31 <shingoki> skew, well this is probably completely wrong
10:39:35 <tuomov> It just not having multiple return values conveniently
10:39:40 <tuomov> s/just/sucks/
10:39:53 <shingoki> but in java, I have been writing something that basically watches a graph of objects
10:40:04 <shingoki> when one changes, it tells its parent about that change
10:40:07 <shingoki> and so on through the graph
10:40:17 <skew> shingoki: Because I can think of lots of examples of the Haskell type system being more powerful, esp. parametric polymorphism, but I don't think any of them essentially rely on type inference
10:40:23 <shingoki> so you can watch the whole graph by watching the root
10:40:32 <shingoki> ok then I dont have an example either :)
10:40:37 <shingoki> I just think it will be much easier
10:40:51 <skew> Type inference does make it much easier to write code
10:41:00 <shingoki> the thing with generics
10:41:01 <musasabi> The problem is that when we touch FP languages we see new elegant ways of solving problems. And then we notice that 1) they are easier than the old way we were using 2) they cannot be expressed easily in java/.../... ;)
10:41:05 <shingoki> you can always get to what you want
10:41:16 <shingoki> but the compiler is basically saying "nope - you got it wrong again"
10:41:22 <shingoki> while you refine the generic type
10:41:31 <shingoki> its half way to working the damn thing out for you anyway
10:41:42 <skew> Ocaml takes inference a bit too far - type inference is good for wiritng code, but type signatures are good for reading it.
10:41:42 <shingoki> so I appreciate that haskell goes the whole way ;)
10:42:00 <shingoki> Yeah im still trying to pin down the differences
10:42:16 <shingoki> but I've been trhough a load of ocaml tutorials and just starting on haskell
10:42:48 <shingoki> The OO thing isn't necessarily a killer
10:42:57 <skew> shingoki: It's eary to worry about OO then
10:43:02 <shingoki> I mean the core of OO as far as I'm concerned is mostly syntactic sugar
10:43:25 <skew> shingoki: write the baby FP examples, like taking the minimum value in a tree
10:43:32 <shingoki> I just have bitter memories of the crap you have to go through without OO even to make a half decent design
10:43:34 <shingoki> yeah
10:43:55 <tuomov> forced OO makes a total crap design
10:44:09 <tuomov> everything just isn't naturally a member function
10:44:10 <shingoki> tuomov, misusing any tool makes a crap design
10:44:12 <skew> shingoki: Then the beginning Haskell examples, like replacing every leaf in the tree with that minimum at the same time :)
10:44:32 <shingoki> yeah but, any language will have a go at that
10:44:48 <skew> That's egninning lazy evaluation example, I guess
10:44:50 <shingoki> its when you try to make something larger and better organised and more extensible that you (or at least I) need oo
10:44:58 <kosmikus> skew: you call repmin a "beginner's problem" ? ;)
10:45:11 <tuomov> shingoki: no, just modules
10:45:13 <skew> well, beginning for learning laziness
10:45:21 <shingoki> modules are ok
10:45:23 <skew> I think that's one of the first illuminating things I say
10:45:27 <skew> saw
10:45:29 <shingoki> but they are just a subset of objects
10:45:31 <shingoki> a small one
10:45:47 <tuomov> modules don't have any direct relation to objects
10:46:09 <shingoki> modules can be faked with objects, unless we are talking about some specific haskell thing, in which case I have no idea :)
10:46:25 <kosmikus> skew: seeing and understanding it is certainly illuminating, but coming up with it on your own without having some experience is something entirely different
10:46:27 <skew> well, object implies this whole subtypeing thing
10:46:30 <tuomov> sure they can.. but the language cna provide modules without being OO
10:46:55 <shingoki> tuomov, yes, so I'm saying that modules are nice but they do less stuff than objects, they aren't a replacement
10:47:03 <skew> kosmikus: sure, but writing the code yourself and changing it a bit is a good idea
10:47:11 <tuomov> and the hiding of details provided by modules is the number one thing that is needed when making bigger programs
10:47:20 <kosmikus> tuomov: real modules have a relation with OO, I think; both objects and modules are records in essence
10:47:25 <shingoki> ok just dumb example, it is really nice to define an object interface then use that interface, and be able to completely replace it, and hide the implementation
10:47:35 <shingoki> I've never seen how to do that without OO except by faking OO
10:47:37 <skew> shingoki: objects are just one complicated language feature that can be seen as a generalization of modules
10:47:48 <tuomov> kosmikus: then we get to the question "what is OO really?"
10:48:00 <kosmikus> tuomov: ok, let's not go there ;)
10:48:03 <tuomov> we know what are considered "OO" languages, but...
10:48:04 <shingoki> for example by creating an object holding its instance data and its functions and making sure you tell each function what object it is in
10:48:14 <shingoki> then you have a fake object, but messy syntax and scope for error
10:48:34 <shingoki> even if objects aren't universally applicable, that doesn't make them pointless :)
10:48:41 <skew> shingoki: well, the design went wrong when you gave it mutable state :)
10:49:05 <shingoki> It works even for immutable objects
10:49:09 <skew> Functions should, of course, get immutable state from their closure.
10:49:09 <tuomov> Type classes can also be used to hide details
10:49:30 <tuomov> Haskell's modules don't really provide replaceable implementations, some more advanced modules languages do
10:49:35 <skew> Silly C needing to pass in extra argument to callbacks and stuff
10:49:44 <shingoki> You can quite happily write an entore java app with only immutable objects, but it is still useful to have them as objects
10:49:50 <tuomov> but they still let you hide the implentmentation
10:49:58 <shingoki> Yeah I agree closures do the same thing, but a closure again is a subset of objects
10:50:04 <skew> shingoki: how is that?
10:50:09 <shingoki> It's an immutable object with one function
10:50:12 <shingoki> in a sense
10:50:26 <musasabi> shingoki: so how is an object different from a record of functions?
10:50:35 <skew> I mean, if you write a Java app around immutable objects, why is it nice to have objects?
10:50:42 <tuomov> no, not a record, a product!
10:50:45 <shingoki> because they are immutable OBJECTS
10:51:02 <shingoki> I don't see how the concept of mutability is necessary for something to be an object
10:51:04 <skew> I'd rather define a data type for the values, and then you can add whatever functions you need, and invent more latter, and they all act the same
10:51:16 <shingoki> it is an object because it contains both data and functions
10:51:31 <skew> But I guess functional programmers prefer data and imperative programmers have come to prefer codata
10:51:43 <musasabi> shingoki: but the data should be accessed through functions - so at the end it is only functions.
10:52:17 <shingoki> musasabi, true, but how do you easily and concisely get all the functions to be working with the same set of data, where that is what you want?
10:52:21 <shingoki> thats really all im after
10:52:28 <shingoki> the rest of OO can go to hell
10:52:39 <shingoki> even inheritance is a bit crap when you actually get into it up to the elbows
10:53:17 <musasabi> shingoki: partial application.
10:53:27 <tuomov> remember that our functional data is immutable
10:53:38 <shingoki> hm ok
10:53:49 <musasabi> shingoki: the constructor just 1) creates data, 3) returns a record of functions partially applied to the data.
10:53:54 <shingoki> so you create an "object" by applying the shared data to all functions
10:54:06 <shingoki> then group them, and make a type that is that grouping of functions
10:54:16 <shingoki> ok that's nice
10:54:17 <skew> shingoki: but you might as well just pass around the shared data
10:54:21 <shingoki> not really
10:54:29 <shingoki> it may be different, compltely different
10:54:29 <skew> and then apply whatever functions you need at the place where you use it
10:54:33 <shingoki> no that is bad
10:54:41 <shingoki> that is the exact opposite of what you should aim for
10:54:47 <shingoki> well, IMHO :)
10:55:20 <shingoki> an example would be say making 3D primitives or something, you define a standard interface for their representation as a set of points say
10:55:38 <shingoki> then you leave them to worry about t5he fact that they are really defined by a sphere center, radius, and point count
10:56:00 <shingoki> you dont want to pass data like that around, when it is meaningless to say a drawing routine that only cares where the points end up
10:56:01 <skew> The data is either opaque, or simple enough that hiding the representation saves nothing
10:56:04 <lucs_> Haskell beginner (me) asks for help:  http://sial.org/pbot/8407
10:56:08 <musasabi> shingoki: the record of functions works for this exactly - you can even do inheritance if you really really want.
10:56:13 <tuomov> The Haskell approach would be a Point3D typeclass
10:56:13 <tuomov> probably
10:56:22 <shingoki> musasabi, yes I am coming round to that point of view :)
10:56:24 <tuomov> so you use polymorphism to access thedata
10:56:33 <musasabi> but after coding a while you notice you don't need it :-)
10:56:36 <shingoki> I mean already in Java, the concept of a public field is anathema
10:56:41 <shingoki> everything SHOULD be functions
10:56:57 <shingoki> and partial application seems like a relatively neat way to create a pseudo object
10:57:12 <skew> That's overstating things a bit. Algebraic data types are a beautiful thing.
10:57:58 <shingoki> The only thing is that in an OO language you already have a syntax geared towards relatively concise production of a set of functions operating on the same set of data
10:58:02 <shingoki> a constructor
10:58:37 <tuomov> class Point3D a where pt_x, pt_y, pt_z :: a -> Float; instance Point3D MyRepresentation where pt_x  = ...
10:58:41 <skew> One thing I don't like about the method syntax is that functions added later look differently, when they are all just working on the same data
10:58:53 <skew> On the same kind of object, or whatever
10:59:04 <shingoki> skew, I don't follow?
10:59:30 <integral> $object->method vs. generic_method($object) ?
10:59:36 <shingoki> yeah
10:59:45 <shingoki> the first is nicer, I don't care what anyone says ;)
10:59:59 <tuomov> I like the latter
11:00:01 <musasabi> you can generate the wrappers and constructors with TH.
11:00:02 <skew> Say you have a class number with methods lessThan and equalTo, and define leq(Num a, Num b) {return a.lessThan(b) || a.equalTo(b);}
11:00:21 <shingoki> yeah
11:00:46 * lucs_ & # Lunch. Back later.
11:00:48 <skew> It just seems odd to me that now leq(a,b) has different syntax, but it's the conceptually the same sort of operation on numbers
11:01:08 <tuomov> oh, another thing I don't like in many OO languages is implicit 'self' scope
11:01:25 <shingoki> its not that bad
11:01:29 <tuomov> I want to explicitly state when accessing something of 'self'
11:01:29 <shingoki> its not great
11:01:34 <skew> Not that there are never reasons for passing around packages of functions, especailly to get some sort of polymorphism
11:01:47 <shingoki> skew, well exactly, I mean thats all an object is
11:02:02 <shingoki> hide the implementation of the thing, just make sure it presents sufficient functions to do something
11:02:22 <skew> It's just that one of the nice things about Haskell is that things are very uniform.
11:02:33 <tuomov> typeclasses do the same thing.. you just don't get inheretiance etc.
11:02:40 <shingoki> i can see that with the immutability and the typing, you get the good bits of OO
11:02:48 <shingoki> inheritance is a mixed bag at best
11:02:53 <shingoki> MI is an abomination
11:02:57 <skew> There are only a handful of build-in functions you couldn't have defined yourself
11:03:02 <tuomov> yeah, MI is evil
11:03:09 <shingoki> even inheritance is evil
11:03:16 <shingoki> unless you treat it with kid gloves
11:03:32 <shingoki> very easy to break the internal state of your superclass by lack of knowledge about it
11:03:35 <shingoki> happens all the time
11:03:51 <shingoki> ironically the way to fix that is to make subclasses never touch the internal state of the superclass
11:04:02 <shingoki> which is just like using a "helper" class with delegation
11:04:12 <skew> shingoki: In Haskell direct access to data types is usually controlled by scope, by making a module that tells the outside the world that the type exists, but not what the details are
11:04:14 <_Codex> MI is just special case of composition. And Composition is very haskell-friendly tool.
11:04:15 <shingoki> which in turn is equivalent to just sticking new functions into a list of them
11:04:19 <tuomov> helper is cleaner.. but then you need wrappers and stuf
11:04:32 <shingoki> yeah you need the delegation code, which just passes through
11:04:43 <shingoki> but that can be done with this "list of functions" idea
11:04:45 <shingoki> I like it :)
11:04:49 <tuomov> _Codex: MI in c++ is evil
11:05:18 <shingoki> yeah, some people/languages claim to fix the problem of everything overlapping, but I don't know if I believe them
11:05:24 <tuomov> sigh I need to move this irc to some other machine.. awful dealys
11:06:17 <tuomov> the local network has been completely saturated always since they busted the local dc hub
11:08:16 <tuomov> I mean the outgoing pipe has been
11:09:21 <_Codex> tuomov: just need to realize that C++'s MI only works with virtual base classes. :)
11:09:34 <tuomov> what's that?
11:09:40 <shingoki> which is equivalent to java interfaces
11:09:46 <shingoki> and yet people complain about interfaces
11:09:50 <tuomov> It's been ages since I touched c++ with a long stick
11:10:10 <tuomov> interfaces are somewhat like typeclasses afaik
11:10:11 <shingoki> I could be very wrong, but essentially inheriting from classes with no real implementation
11:10:17 <tuomov> I don't know the details of java's interfaces, though
11:10:22 <shingoki> interface just defines a set of implemented functions
11:10:26 <skew> Isn't C++ a purely functional template language for generating imperative code?
11:10:27 <shingoki> there aren't really any details :)
11:10:39 <_Codex> java interfaces can only have methods in them. C++ is different.
11:10:44 <tuomov> that's what typeclasses are too
11:11:08 <shingoki> yes but as we discussed including anything other than methods for something designed for external access is a really bad idea
11:11:14 <shingoki> hence accessors
11:11:39 <shingoki> anyway this has been super educational, thanks guys :)
11:11:45 <tuomov> c++ is an ugly beast
11:11:47 <_Codex> but the nice thing with C++'s MI, is that it has commutative "dreaded diamond" diagram in it.
11:11:50 <skew> shingoki: having accessors for variables is orthogonal to providing implementations for methods
11:12:00 <skew> Yay commutativity diagrams
11:12:03 <shingoki> skew, not sure I understand that one ;)
11:12:20 <shingoki> the interface often specifies the presence of accessors
11:12:48 <tuomov> err. if you have accessors you need data?
11:12:51 <skew> shingoki: tumov et. al. are trying to say that these virtual base classes in the multiple inheritance can provide method interfaces. That seems to be unrelated to whether you expose fields or hide them behind accessors
11:13:17 <shingoki> skew, yup true
11:13:24 <skew> tuomov: The idea with the interface is that it just specifies the interface
11:13:30 <shingoki> and exposing fields is so bad that I consider it a bit of a misfeature
11:13:54 <tuomov> oh, sorry, I got a bit confused there
11:14:17 <shingoki> tuomov, I was just saying you don't need OR want access to fields, since you can achieve the same goal in a much nicer way with accessors. This was unrelated to anything else, like skew said ;)
11:14:19 <tuomov> of course the interface specifices accessors to be provided by the implementations
11:14:38 <shingoki> I think the key thing is that we all agree C++ is awful :)
11:14:50 <tuomov> there can be no question of that
11:15:05 * tuomov writes his OO code in C :)
11:15:14 <shingoki> Yeah i was just doing some of that
11:15:24 <shingoki> it actually works surprisingly well :)
11:15:25 <jesse99> c++ might be awful, but its better than c :-)
11:16:03 <shingoki> c with a GC and a preprocessor could be quite a nice language... probably called java :)
11:16:16 <shingoki> or objc, but that has that stupid reference counting stuff
11:16:25 <tuomov> I at one point considered switching to c++.. but decided that its OO facilities don't do what I want
11:16:30 <jesse99> boehm works pretty well with c, not quite so well with c++
11:16:34 <shingoki> yup
11:16:41 <wilx> Hmm, iirc recent GCC ships with real GC for ObjC.
11:16:51 <shingoki> so if you took C, and used boehm gc, and had a preprocessor to hide pointers the same way java does
11:16:55 <shingoki> you have most of a nice language
11:16:55 <tuomov> otoh GObject vs. C++ is a clear win for the latter
11:17:09 <shingoki> just need some way of doing interfaces and you have all the good stuff
11:17:15 <skew> shingoki: but the type system would still be painful
11:17:17 <shingoki> yes
11:17:25 <jlouis> You need explicit ref cells and everything constant too
11:17:25 <shingoki> thats what you would miss :(
11:17:27 <jlouis> ;0
11:17:30 * pesco appears in a TV screen.
11:17:35 <pesco> What's the p-point of it?
11:17:38 * pesco disappears.
11:17:40 <jesse99> sucky std lib too
11:17:44 <shingoki> Does haskell have ref cells? I thought that was caml?
11:17:55 <tuomov> subtyping would help C a lot so you didn't need unsafe explicit casts at every point
11:18:04 <jlouis> shingoki: haskell doesn't have them as suc
11:18:05 <jlouis> h
11:18:07 <tuomov> or accessing through all the fields and so on
11:18:17 <shingoki> you can fake them? I thought it was all immutable?
11:18:25 <wilx> That language is called Ada :))
11:18:25 <skew> Haskell has mutable variables if you want them
11:18:38 <skew> But they are carefully kept contained
11:18:52 <shingoki> seemed like that was ocaml's approach too
11:19:02 <skew> Unlike Ocaml where you can merrilly play with mutable state in any function you want to...
11:19:19 <shingoki> but you need to use a ref, you would notice that surely?
11:19:23 <skew> THe critical thing is that no function in Haskell ever has a side effect
11:19:30 <skew> Or something like that
11:19:33 <shingoki> oh
11:19:47 <tuomov> so you do things with side effects in a monad
11:19:59 <shingoki> so anything mutable isn't persistent, it just happens within the function?
11:20:06 <skew> No.
11:20:08 <shingoki> I need to read more of the tutorial :)
11:20:17 <shingoki> I will come back when I stand more chance of understanding this :)
11:20:21 <shingoki> thanks for help thouigh
11:20:41 <tuomov> monads are a way of passing an extra state around without explicitly doing so everywhere
11:20:47 <tuomov> among other things
11:21:15 <skew> or a way of explicitly representing and ordering side effects, if you think about them a different way
11:28:55 <_Codex> bad thing about monads is that it makes the code look like C code.
11:31:43 <vegai> it's like C with types :-P
11:37:01 <pesco> The Finest... ;-P
11:42:29 <bourbaki> moin
11:56:03 <earthy> what's so bad about C with types?
11:56:35 <SamB> earthy: my guess is that it is too much like C for some people
11:57:21 <earthy> those people aren't practical about their programming languages.
11:57:25 <jesse99> memory management sucks and the std lib is weak for starters
11:58:32 <SamB> jesse99: well, if its really Haskell in the IO monad, it has decent memory management and a decent library
11:58:49 <jesse99> then it isnt "C with types"
11:59:12 <SamB> true ;-)
11:59:31 <SamB> c with types and gc and a little something else
12:14:10 <lucs_> Can anyone help me with this please?:  http://sial.org/pbot/8408
12:16:43 <Cale> er
12:16:44 <earthy> um, jesse99, are you aware of Haskell's pointers and FFI?
12:16:53 <earthy> you *can* do your own memmanagement if you want. :P
12:17:10 <Cale> lucs_: your code works in GHCi
12:17:20 <lucs_> Oh. :/
12:17:38 <lucs_> Hmm...
12:17:42 <jesse99> i dont see how "c with types" has anything at all to do with haskell
12:17:44 <Cale> It looks like hugs is defaulting something
12:18:12 <Cale> or rather
12:18:24 <Cale> not able to deal with the bit of polymorphism there
12:18:51 <Cale> er
12:18:56 <Cale> wait, it works in hugs too
12:19:23 <earthy> jesse99: go to the QuotesPage on the hawiki and find the translation of a bit of C code by Simon Marlow
12:19:29 <earthy> then try to state that again. :P
12:19:39 <lucs_> ?
12:19:54 <earthy> @wiki QuotesPage
12:19:54 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
12:20:23 <earthy> `How to Translate C to Haskell'
12:20:59 <jesse99> you can translate C into a zillion languages earthy
12:21:05 <lucs_> Cale: Maybe I'm running too old a version? (Nov.2002)
12:21:12 <jesse99> that doesnt mean you wind up C
12:21:38 <lucs_> I'll see if there's an update I can get...
12:21:39 <Cale> I'm running 20050308
12:21:44 <lucs_> !
12:21:45 <lucs_> :)
12:22:28 <earthy> jesse99: read that quote. :)
12:22:45 <earthy> it's pretty close to the C, inf  fact
12:55:52 <lucs_> Cale: Works now (version March 2005). It's hard being self-taught some days. I spent hours tring to figure out what I was doing wrong in that example. At least, it's not totally wasted time, as it forces me to look beyond what i currently know.
13:03:31 <jesse99> why do I get a compiler error for: is_left :: Either a b -> Bool
13:03:31 <jesse99> is_left Left _  = True
13:03:47 <Cale> is_left (Left _) = True
13:04:00 <jesse99> ahh
13:04:12 <Cale> otherwise "Left" and "_" are seen as distinct parameters to is_left
13:04:13 <jesse99> thanks cale
13:04:16 <Cale> np
13:04:16 <jesse99> yeah
13:17:54 * boegel jumps up and down like a madman
13:19:00 * SyntaxNinja commits boegel
13:20:09 * boegel bumps into SyntaxNinja an purpose
13:45:06 <jesse99> what's the best way to find a substring within a string?
13:45:39 <Cale> Depends what sort of substring
13:45:48 <Cale> Text.Regex might be handy
13:45:56 <jesse99> well, thats kind of overkill
13:46:26 <jesse99> i just want to find a substring in a parsec error message
13:47:35 <Cale> any (isPrefixOf "lookingFor") (tails message) ?
13:48:18 <jesse99> where is isPrefixOf from?
13:48:26 <Cale> List
13:48:37 <jesse99> yeah, just found it
13:50:30 <jesse99> boy, that looks inefficient :-)
13:50:32 <Cale> any (search `isPrefixOf`) (tails message) -- probably reads a little better
13:50:43 <Cale> it's not so bad
13:50:52 <Cale> remember that it's lazy
13:51:12 <jesse99> even so, if the substring isnt found you're creating a ton of objects
13:51:19 <Cale> oh?
13:51:46 <jesse99> doesnt tails create up to N objects where N is the length of the string?
13:52:18 <Cale> well, it returns a list of tails
13:52:26 <Cale> but it doesn't have to do any copying
13:52:36 <Cale> it just makes pointers to the tails, which you already have
13:52:53 <Cale> inits, on the other hand
13:52:58 <Cale> would be expensive
13:53:34 <Cale> and it doesn't even make them all if it finds the substring
13:54:57 <Cale> any ("foo" `isPrefixOf`) (tails (show [1..1000000]))
13:55:03 <Cale> runs in a reasonable time frame
13:55:21 <Cale> despite that being a really long string
13:56:27 <Cale> (about 3.4 seconds on my machine)
14:02:34 <Cale> It appears to run in O(max(c,n) * n) time where c is the length of the string to look for and n the length of the string to search through.
14:02:58 <Cale> er
14:03:00 <Cale> min
14:03:06 <Cale> O(min(c,n) * n)
14:05:02 <Cale> I think you could probably even put a better bound on it, because it's not going to even bother comparing the whole string to each of the tails, it's going to be pretty close to O(n) even for large values of c, because it will short circuit that comparison.
14:08:25 <jesse99> i'm going to go with it, even though it freak me out
14:09:16 <Darius> What's freaky about it?
14:09:54 <jesse99> the generation of all those temporary objects (even if the compiler is smart enough to not actually copy substrings)
14:10:03 <RemiTurk> did I see a simon there?
14:10:38 <Darius> jesse99: The compiler doesn't need to be smart not to copy the substrings and in fact the compiler may be smart enough to deforest the intermediate list.
14:10:49 <Darius> RemiTurk: Yes, JaffaCake is Simon Marlow.
14:11:48 <jesse99> what's that phrase? lisp programmers know the value of everything and the cost of nothing :-)
14:11:56 <Darius> jesse99: The deforested version would be pretty much the typical naive version.
14:12:00 <RemiTurk> does he hang around here often? that would make my figuring-out-how-ghc-works a bit easier probably ;)
14:12:54 <Darius> RemiTurk: This is only the second time I've seen him on recently.  Though last time he was on to "relax after the GHC 6.4 release", I'm not sure why he decided to get on now.
14:13:21 <Darius> Perhaps he will be around more.
14:13:55 <RemiTurk> Darius: :)
14:42:23 <shingoki> How does the haskell GC work, does it lead to pauses in execution like in Java?
14:42:34 <shingoki> is haskell ever used for soft realtime stuff?
14:43:26 <boegel> shingoki: Haskell is used for _everything_
14:43:31 <boegel> even OS's
14:43:41 * stepcutHM plans to use it for soft realtime someday (hopefully later this year)
14:43:56 * humasect is using it now
14:44:10 <humasect> haskell OS kernel ? oh no
14:44:27 <boegel> humasect: what about hOp ? (I don't know what's the deal there)
14:44:42 <shingoki> I'm really just wondering what the GC performance is like
14:45:02 <humasect> hm cool
14:45:06 <shingoki> does it tend to go off on a mighty quest for a second or so every now and then?
14:45:24 * boegel is off to sleep
14:45:30 <boegel> g'night everyone
14:45:39 <stepcutHM> shingoki: not in my experience.. ghc has calls to force garbage collection too
14:45:43 <humasect> also 'House'
14:45:46 <shingoki> thats nice
14:46:24 <shingoki> I mean in Java, working on stuff like games, you can tame the GC a little by trying to avoid a huge amount of object creation, but that seems to be the exact opposite of the haskell idea :)
14:46:51 <shingoki> so I assume you are just going to have a lot of um, churn
14:47:15 <stepcutHM> the only times I have noticed ghc's garbage collection is if I have done something horribly bad, in which case, it is probably a good idea to fix the cause of the problem in the first place
14:47:39 <shingoki> bad in what sense?
14:47:49 <stepcutHM> but I also don't do stuff where I would be likely to notice garbage collection...
14:48:02 <shingoki> yeah I only noticed java GC when I wrote a little game
14:48:15 <shingoki> otherwise you don't tend to notice sub-second pauses that much
14:48:32 <stepcutHM> shingoki: bad, as in trying to seek to the end of an infinite list :)
14:48:48 <shingoki> ah :)
14:48:55 <shingoki> that seems bad ;)
14:49:13 <stepcutHM> :p
14:52:00 <TheHunter> hey guys.
14:53:54 <Darius> shingoki: GHC's GC is generational.  There is a paper on an incremental generational GC, but I don't think it's implemented.
14:54:53 <shingoki> i don't know if the incremental gc would be like Java's, but in java it doesn't help much
14:55:05 <shingoki> would do for a lot of stuf, but you still see the effect in games
14:55:14 <Darius> Incremental means no long pauses and potentially suitable for hard real-time.
14:55:17 <shingoki> you just get smaller but mroe frequent pauses
14:55:28 <shingoki> yeah
14:55:40 <shingoki> it's just that the size of the pauses has to be rather small for games
14:55:56 <shingoki> like less than a 1/50 of a second
14:56:06 <stepcutHM> shingoki: not for nethack!
14:56:10 <shingoki> java inc gc just gives you maybe tenth of a second pauses
14:56:15 <shingoki> heh true
15:07:31 <tuomov> wouldn't that depend on the java vm, or is it specified in some document what algorithms should be used?
15:07:54 <RemiTurk> good night everyone
15:22:38 <shingoki> tuomov, yup it just depends on the VM
15:22:48 * TheHunter feels like complaining about FunctorM
15:23:02 <shingoki> there are VM's that are far better than the official one for realtime, apparently
15:27:45 <Darius> TheHunter: What about it?
15:29:35 <TheHunter> Darius, http://www.haskell.org//pipermail/libraries/2005-March/003454.html
15:37:15 <TheHunter> have I mixed up subclass and superclass?
15:37:46 <Darius> I was wondering about that.
15:38:06 <TheHunter> dammit!
15:38:30 <Darius> Further it seems the Monad m restrictions are superfluous in your class.  I partly bring it up as a general distributive class may be useful.
15:38:55 * Darius should resubscribe to the lists he was before.
15:39:16 <TheHunter> no, I think the way FunctorM is meant to be, the Moand constraint is reasonable.
15:39:40 <Darius> It's reasonable, but unnecessary.
15:40:00 <TheHunter> actually, i'm pretty sure there's an automatic translation that makes every Functor a FucntorM
15:40:14 <TheHunter> (actually, there are infinitely many of them)
15:40:39 <Darius> @type liftM
15:40:40 <lambdabot> bzzt
15:40:53 <Darius> @type Control.Monad.liftM
15:40:54 <lambdabot> Control.Monad.liftM :: forall r m a1.
15:40:54 <lambdabot> 		       (Monad m) =>
15:40:54 <lambdabot> 		       (a1 -> r) -> m a1 -> m r
15:41:59 <TheHunter> if you want distributivity, the class should be called Distributive or something anyway.
15:42:31 <TheHunter> what about liftM?
15:42:55 * TheHunter must admit he isn't entirely sober.
15:43:26 <Darius> TheHunter: I was thinking about a class named Distributive.  As for liftM I was just looking at it.
15:44:06 <TheHunter> yeah, there should be a class Distributive.
15:44:30 <TheHunter> But the hierarchy gets really messed up if you add any class that seems reasonable.
15:49:32 <Darius> TheHunter: Wouldn't being able to turn every Functor into a FunctorM pretty much require a way to distribute/commute monads.
15:54:59 <TheHunter> i thought that'd be just a trivial application of reflect+reify.
15:58:51 <TheHunter> fmap' :: (a -> Direct r b) -> f a -> Direct r (f b)
15:58:52 <TheHunter> fmap' = --whatever
15:58:52 <TheHunter> fmapM' :: DeepSeq (f b) => (a -> [b]) -> f a -> [f b]
15:58:52 <TheHunter> fmapM' f x = reify (fmap' (\y -> reflect (f y)) x)
16:05:45 <TheHunter> well, fmapM' :: (Monad m, DeepSeq (m (f b))) => (a -> m b) -> f a -> m (f b)
16:12:15 * shapr yodels
16:12:50 <Pseudonym> Can you yodel?
16:12:56 <shapr> Not very well.
16:12:59 <shapr> Can you?
16:13:05 <shapr> I'd like to try throat singing.
16:13:38 * Darius imagines shapr yodeling.
16:14:34 <Pseudonym> Never tried.
16:14:55 <shapr> Darius: have you heard me speaking?
16:15:10 <Darius> shapr: No.
16:15:26 <shapr> Obviously I should add podcasting to my blog.
16:37:58 * Darius always enjoys reading through QuotesPage
16:38:28 <cm> shapr: hello..
17:02:38 <shapr> hiya cm
17:02:46 <shapr> Darius: anything particularly interesting today?
17:03:13 <shapr> I've been trying to sleep for the last coupla hours. Insomnia sucks.
17:03:45 <cm> yup.
17:03:55 <cm> couldn't fall asleep until 6 AM yesterday/today
17:03:58 <Darius> shapr: Not really.  I'm downloading Painter IX, but it's 108MB and I have a dialup connection, so I'm still downloading it.
17:04:50 <shapr> Darius: oh hey, when you have some time, I wanted to discuss the heinlein prize with you.
17:05:07 <shapr> Though I think not tonight, since I'm really trying to sleep.
17:05:23 <Darius> Okay, just yell at me.
17:06:38 <ozone> heineken prize?
17:06:41 <ozone> schmexcellent
17:11:22 <Darius> "So, I used IndigoStar's Perl2Exe to convert the script ... to a standalone exe" ... "I see that GHC has support for the same ability" *smacks forehead*
17:13:38 * Darius can't help but be reminded of Pseudonym's (alleged) quote: "Well, personally, I don't think dumb people should be let near a programming lanugage."
17:14:10 <shapr> I am reminded of that quote on a regular basis.
17:15:26 <dons> anyone got the House network stack url handy?
17:16:19 <shapr> It's on cvs.haskell.org
17:16:43 <shapr> er, I think it is...
17:17:04 <Pseudonym> Did I say that?
17:17:10 <shapr> ah yes - http://cvs.haskell.org/cgi-bin/cvsweb.cgi/programatica/hOp/
17:17:25 <dons> danke
17:17:28 <shapr> <Pseudonym> Well, personally, I don't think dumb people should be let near a programming language.
17:17:32 <Pseudonym> I must be either profound or flippant.
17:17:35 <Pseudonym> Not sure which.
17:17:39 <shapr> Both
17:23:59 <ozone> profoundly flippant?
17:25:18 <cm> intro of moby's hotel is very promising
19:14:33 <Darius> Quick!  Infinitely descending chain is Artinian or Noetherian?
19:16:19 <Pseudonym> I think Noetherian.
19:16:24 <Darius> @wn noetherian
19:16:26 <lambdabot> No match for "noetherian".
19:16:27 <Pseudonym> But it's just a "I think".
19:16:32 <Pseudonym> @foldoc noetherian
19:16:33 <lambdabot> No match for "noetherian".
19:16:35 <Pseudonym> @foldoc noether
19:16:37 <lambdabot> No match for "noether".
19:16:40 <Darius> Pseudonym: Me too.
19:16:50 <Pseudonym> Actually, you might know an answer to this question.
19:17:01 <Pseudonym> I'm looking for a good introduction to the work & thought of Emmy Noether.
19:18:04 <Pseudonym> I'm particularly interested in how it influenced category theory.
19:18:24 <Darius> Unfortunately, about all I know about Noether is that she was a mathematician, Noetherian is named after her, and she did I-forget-what in physics at some point.
19:18:27 <Pseudonym> But in a general context of mathematical "design patterns", for lack of a better term.
19:18:32 <Pseudonym> Yeah, Noether's theorem.
19:18:56 <Pseudonym> Apparently she was quite influential on category theory later.
19:19:11 <Pseudonym> She came up with a first theory of "mathematical structure", separate from specific kinds of algebra.
19:19:17 <Pseudonym> Or abstracted from.
19:19:24 <Pseudonym> I'm curious how far she got.
19:20:17 <Pseudonym> And Noether's Theorem in physics is a pretty powerful thing.
19:20:26 <Pseudonym> Actually, no.  It's very, very powerful.
19:21:41 <Darius> Well, my question wasn't very well formed, but it seems Noetherian disallows infinitely ascending chains so I guess Artinian was what I was looking for.
19:21:48 <Pseudonym> Ah, OK.
19:38:20 <Pseudonym> A ring is called left (respectively right) Artinian if it does not contain an infinite descending chain of left (resp. right) ideals.
19:38:28 <Pseudonym> A ring is called left (respectively, right) Noetherian if it does not contain an infinite ascending chain of left (respectively, right) ideals.
19:38:30 <Pseudonym> THere you go.
19:38:56 <Pseudonym> OK, here's a question.
19:39:07 <Pseudonym> Is there a categorical formulation of "ideals"?
19:39:23 <Pseudonym> An ideal is most likely a subobject.
19:40:33 <TheStar> I have a peculiar thought... Is the single issue of comparison between *imperative* languages the issue of IDE, libraries/framework, and peculiarities of implementation?
19:40:49 <Pseudonym> I _think_ that ideals in ring theory are the same as ideas in Lie theory and normal subgroups in group theory.
19:40:52 <Pseudonym> Is that correct?
19:41:13 <Pseudonym> As I understand it, a generalised "ideal" is a subobject that you can "divide by".
19:41:17 <monochrom> Pseudonym: yes afaik
19:41:23 <Pseudonym> My intuition might be off there.
19:42:32 <Pseudonym> monochrom: Any references?
19:42:34 <Pseudonym> Or ideas?
19:42:45 <Pseudonym> (Or ideals?)
19:43:14 <monochrom> books on universal algebra
19:43:19 <Pseudonym> :-)
19:43:21 <Pseudonym> OK
19:44:08 <wagle> lattice theory
19:44:25 <monochrom> the salient feature seems to be the "1st, 2nd, 3rd isomorphism theorems"
19:45:15 <Pseudonym> Hmmm.
19:45:18 <Pseudonym> Let's look aqt that.
19:45:31 <Pseudonym> h : R -> S is a homomorphism
19:46:01 <Pseudonym> OK, we need some way to characterise the kernel of a homomorphism.
19:46:15 <monochrom> you also want h to be surjective
19:46:28 <Pseudonym> Yes.
19:46:45 <Pseudonym> Hang on, do you?
19:46:53 <Pseudonym> I don't think the first group isomorphsim theorem depends on that.
19:47:05 <Pseudonym> Don't know about the ring theorem.
19:47:23 <Pseudonym> Oh, hang on.
19:47:27 <Pseudonym> Did you mean injective?
19:47:50 <Pseudonym> OK, to define a kernel, it looks like you need an "identity element".
19:47:55 <Pseudonym> Does that mean "zero object"?
19:48:04 <Pseudonym> i.e. an object which is both initial and terminal?
19:51:24 <beschmi> i got a little problem with Data.Map: http://www.haskell.org/hawiki/HaskellIrcPastePage
19:51:38 * Darius is reading a Universal Algebra book right now (or was rather).  
19:51:43 <Pseudonym> Which one?
19:51:53 <Pseudonym> And is it any good? :-)
19:51:54 <beschmi> shouldn't i get an error because of the undefined
19:52:01 * Darius is also thinking of a categorical characterization of kernel and the isomorphism theorems.
19:52:35 <Pseudonym> There you go.
19:52:41 <Pseudonym> If you come up with anything, let me know please.
19:52:51 <Darius> Pseudonym: It's online: "A Course in Universal Algebra" by Burris and Sankappanavar
19:52:56 * Pseudonym nods
19:53:03 <Pseudonym> This is just an idle thought, by the way.
19:53:11 <Pseudonym> My brain is full of gauge symmetries at the moment.
19:54:42 <monochrom> beschmi: where is m in the rhs of the definition of i?
19:55:42 <beschmi> oh, i see what you mean
19:56:25 <beschmi> thanks. i should go to bed ;)
19:56:48 <Pseudonym> Hmmm, I think I'll try to get the LNCS version.
19:56:59 <Pseudonym> Reading printouts on a train is difficult.
19:57:53 <beschmi> but still have some problems with Data.Map in the real code.
20:00:49 <Darius> TheStar: No.
20:01:01 <TheStar> Darius, Explain please :)
20:01:51 <Darius> There are differences in imperative languages beyond environmental or spurious ones.
20:02:44 <TheStar> As I learn more imperative languages, I find it harder to see that.
20:02:49 <TheStar> So, explain :)
20:03:54 <Darius> Well, let me start here.  What differences do you see between functional and imperative languagesL
20:04:02 <Darius> s/L$/?/
20:04:30 <Darius> beschmi: It kind of looks like you are declaring an instance and deriving an instance.
20:05:33 <TheStar> Darius, I've only just begun to learn functional languages, but it appears that imperative languages are centered loop constructs and flow control, where functional languages depend more purely on functions.
20:07:38 <Pseudonym> I think there are more differentiators between imperative languages.
20:07:53 <Pseudonym> For example, FORTRAN and Ada are almost incomparable.
20:08:05 <TheStar> Perhaps it could serve to simplify if we only talk about OO languages.
20:08:07 <Pseudonym> Even though they're both imperative languages.
20:08:14 <TheStar> Rather than Proceedural.
20:08:36 <Pseudonym> I don't think that simplifies anything, but go on.
20:08:38 <TheStar> Scratch that last line. I don't sufficiently know what proceedural means to state that.
20:08:53 <Pseudonym> Java, Smalltalk and C++ are all pretty different.
20:08:58 <Darius> If you consider both OO and Procedural languages imperative.  Then do you consider them the same or different?
20:09:00 <Pseudonym> In ways other than IDE.
20:09:13 <TheStar> Pseudonym, I know Python, C# and Java.
20:09:43 <Darius> There are imperative languages that support functional techniques (especially if you consider "imperative" as "allows side-effects")
20:10:13 <TheStar> From what I understand, functional techniques in Python would be painful, due to it's recursion limit.
20:10:34 <Pseudonym> Well, C# and Java are really, really similar.
20:10:44 <Darius> TheStar: Learn Smalltalk, Prolog, Icon, ML, Scheme, and Common Lisp.
20:10:53 <TheStar> Darius, My next language is Haskell :)
20:10:55 <Pseudonym> I'd add to that Erlang and C++.
20:11:06 <TheStar> Actually, I'm attempting to pick up C++ along the way also.
20:11:11 <Pseudonym> (And by that I mean learn C++ _properly_.)
20:11:20 <TheStar> Pseudonym, Hmm?
20:11:50 <Pseudonym> In the Alexandrescu "Modern C++ Design" sense.
20:12:14 <Pseudonym> Not in the "straw man bastardised OO language" sense.
20:13:34 <TheStar> Pseudonym, I have a C++ reference book by O-reilly, which I do actually understand.
20:13:42 <TheStar> Pseudonym, But elaborate more on what you mean please.
20:14:13 <Pseudonym> OK, you know the STL?
20:14:15 * Darius actually needs to learn Icon.
20:14:31 <Darius> I started on SNOBOL a long time ago, but didn't really play long enough.
20:14:52 <jyasskin> Pseudonym: The STL isn't really OO. Or is that what you mean?
20:15:07 <TheStar> Pseudonym, I've heard of the STL, put it that way.
20:15:39 <TheStar> Pseudonym, I intend to learn the STL.
20:15:54 <TheStar> Infact, I want to learn Boost, for a future project...
20:15:56 <Darius> The STL isn't OO at all.  It's generic programming.
20:16:00 <ozone> give yourself a lot (and a lot, and a lot ...) of time to learn that beast :)
20:16:02 <Pseudonym> Right.
20:16:08 <TheStar> Darius, That makes sense.
20:16:11 <ozone> well
20:16:14 <Pseudonym> Generic programming is very different from standard OO.
20:16:16 <ozone> easy to pick up and use
20:16:25 <ozone> very hard to understand the little innards of
20:16:25 <Pseudonym> OTOH, C++ combines both OO and generic programming.
20:16:31 <Pseudonym> Right.
20:16:38 <TheStar> C++ is supposed to allow multi-paradigm programming, from what I can understand.
20:16:47 <Pseudonym> Most people build fine C++ careers without ever understanding what an iterator category is.
20:17:03 <Pseudonym> But in fact, it's the basic foundation that the STL is built on.
20:17:33 <Pseudonym> Modern C++ design is about merging OO and generic programming into something that's greater than the sum of its parts.
20:18:03 <TheStar> That reminds me of typical Python programming, as opposed to typical Java programming?
20:18:21 <jyasskin> oh, I mis-read you above. I thought you said "not in the Alexandrescu sense", so was getting ready to disagree.
20:18:27 <monochrom> Today I have a revelation regarding "greater than the sum of its parts".
20:18:49 <TheStar> monochrom, Really? I just call that a sandwich.
20:19:31 <Darius> Here's (a reply to) a message I made a long time ago: http://www.programmersheaven.com/c/MsgBoard/read.asp?Board=3&MsgID=166606
20:19:35 <monochrom> In North America the word "add" or "sum" is used for the act of merging or breeding two things.
20:20:00 <monochrom> In East Asia (notably Japan and Hong Kong) they use "times".
20:20:15 <Pseudonym> By "Alexandrescu", I'm probably not giving enough credit to Stepaunov.
20:20:19 <TheStar> monochrom, Those are two very peculiar definitions.
20:20:27 <monochrom> I now think that "times" or "cross" is the right analogy.
20:20:29 <TheStar> monochrom, Add simply means "group".
20:20:42 <monochrom> And needless to say, x times y > x + y
20:21:28 <Darius> Anyways, I've got to go.
20:21:39 <Pseudonym> IMO, Haskell is _this_close_ to being a really, really decent generic programming language.
20:21:44 <Pseudonym> There are just one or two things missing.
20:22:07 <TheStar> Sounds like I really need to learn about "generic" programming languages.
20:22:16 <TheStar> Seems I've missed some aspect of understanding.
20:22:41 <Pseudonym> Well, a generic programming language is anything which supports generic programming natively, to a greater or lesser degree.
20:22:54 <TheStar> At my uni, we focus purely on Object Oriented programming.
20:23:11 <TheStar> We only did C because it was a requirement imposed outside of the uni.
20:24:25 <ozone> Pseudonym: one or two things being ...?
20:24:54 <Pseudonym> 1. Decent semantics for overlapping instance resolution.
20:25:06 <Pseudonym> Oleg et al claim that a negation typeclass fixes this.
20:25:28 <Pseudonym> I have no reason to disbelieve them, but it does really require compiler support.
20:26:02 <Pseudonym> 2. "Associated Types with Class"
20:26:25 <Pseudonym> That's off the top of my head, and it is two things.
20:26:44 <Pseudonym> Subtypes (or Phillipa's "supertypes") would also be handy.
20:26:55 <Pseudonym> But I don't think they'd be necessary unless you needed some type of OO.
20:26:58 <jyasskin> Pseudonym: What's #2?
20:27:00 <ozone> well, (2) is definitely on its way
20:27:27 <Pseudonym> jyasskin: Google that phrase.
20:27:30 <jyasskin> 'k
20:27:47 <Pseudonym> It was supposed to be in 6.4. :-)
20:27:54 <Pseudonym> But yeah.
20:28:25 <ozone> subtypes would also be handy
20:28:33 <ozone> though you can do extensible types with ATs
20:28:48 <ozone> depending on how much syntactic sugar there it, it could either be very nice, or cumbersome
20:28:52 <ozone> s/it/is/
20:28:56 * Pseudonym nods
20:29:00 <ozone> what's Phillipa's supertypes?
20:29:10 <Pseudonym> Ask her about them some time.
20:29:15 <ozone> will do
20:29:21 <Pseudonym> My explanation wouldn't do them justice, probably because I don't fully understand them.
20:29:30 <ozone> and what kind of semantics are you after for overlapping instances?
20:30:16 <Pseudonym> I need something which allows me to make "general" cases, and override them for "specific" cases.
20:30:39 <Pseudonym> For multi-parameter type classes.
20:30:50 <Pseudonym> In a way that's consistent across implementations, and sane.
20:31:02 <Pseudonym> Yes, that's vague. :-)
20:31:05 <ozone> well, you can already do that.  the question is, why does the current way suck :)
20:33:27 <Pseudonym> Well, part of the problem is that typeclass instances are second-class citizens from the point of view of the module system.
20:33:34 <Pseudonym> You can't control whether or not they're exported.
20:34:13 <Pseudonym> So small changes to a program can cause severe breakage if you're doing weird things with typeclass instances.
20:34:24 <Pseudonym> This isn't a criticism of -fallow-overlapping-instances per se.
20:34:27 <Pseudonym> But that makes it worse.
20:35:45 <Pseudonym> But the mere fact that Hugs disagrees with GHC is proof enough that the situation sucks.
20:36:12 <Pseudonym> Oleg et al claim that you don't _need_ overlapping instances if you have an extra built-in type inequality class.
20:36:18 <ozone> nod
20:36:18 <Pseudonym> Which sounds good to me.
20:36:30 <ozone> that proposal was shot down at the workshop last year, though
20:36:40 <Pseudonym> Do you remember why?
20:37:03 <wagle> hugs allows more things (and is less static as a result) with overlapping instances according to philippa.  i havent gotten a chance yet to check my stuff out
20:37:03 <ozone> i think mostly because people looked at the code needed to perform it, and their eyes bulged at the syntax
20:37:12 <ozone> i think they proposed it the wrong way
20:37:18 <Pseudonym> Ah.
20:37:22 <ozone> they were saying "you don't need overlapping instances at all, you can just do it this way"
20:37:49 <ozone> rather than "you can implement overlapping instances this way"
20:38:04 <ozone> so they got shot down because the code they showed looked like, well, typical oleg code :}
20:38:30 <wagle> whats that like?
20:38:56 <Pseudonym> Just goes to show that Wadler's law of language design is true.
20:39:08 <TheStar> Pseudonym, What's that?
20:39:28 <TheStar> I must say, continuation passing style was a very... COnfusing issue in #python.
20:39:41 <monochrom> oleg code looks like you just use the type language and never the main language.
20:39:43 <TheStar> ANd most people including me just ignored it, and said that it wasn't important.
20:40:13 <wagle> the transform is important
20:40:40 <wagle> how did it come up in #python?
20:41:02 <TheStar> wagle, Because it was apparently a major point of stackless python.
20:41:11 <TheStar> From what I understood, anyway.
20:41:20 <wagle> event handling?
20:41:37 <monochrom> Ah, makes sense.  You lose the stack, you move the data to continuations.
20:41:49 <ozone> Pseudonym: i wish there were some way to have dynamic typeclasses
20:42:00 <ozone> Pseudonym: as in, re-use the typeclass syntax for dynamic typing
20:42:42 <wagle> you can do cps at a coarse grain to turn call-nested code to stackless (with respect to breaking it into pieces for handling events)
20:42:54 <TheStar> monochrom, Yes, but you still need to keep track of some sort of track, afaik.
20:43:57 <TheStar> monochrom, afaik, you can only get rid of the stack if you are executing the last call in a block?
20:44:15 <monochrom> I have a revelation.  A parser combinator library written and used in continuation passing style.
20:44:39 <TheStar> monochrom, Pardon?
20:44:57 <monochrom> My revelations are never understood by others.
20:45:29 <TheStar> That'sb ecause they're not really revelations.
20:45:35 <TheStar> THere... Random statements.
20:46:25 <monochrom> They are great revelations.  But I deliberately obfuscate them when I tell them to you, lest you understand and gain salvation.
20:46:29 <wagle> TheStar: A calls B calls C.  C blocks on some operation.  CPS is used to split C in half into C' and C''.
20:47:00 <wagle> B is similarly split in half at its call to C.
20:47:13 <wagle> Likewise A with its call to B.
20:47:20 <ozone> monochrom: you think in a higher plane? :)
20:47:23 <TheStar> wagle, That makes sense.  RAM still grows, though, but I guess at least you don't have to do stack manipulations.
20:47:42 <wagle> now you have two procedures, A'  and A''.
20:48:02 <wagle> A' calls B' call C'.  A'' calls B'' calls B''.
20:48:05 <monochrom> wagle is revealing my secret thoughts in the open.  I must get rid of wagle.
20:48:18 <wagle> A'' needs to start with the info that C' left with.
20:48:21 <TheStar> wagle, I already understood, I just mixed it up with something else.
20:48:33 <wagle> monochrom: i did this in 1995.
20:49:00 <TheStar> wagle, I intend to implement a language with CPS.
20:49:10 <monochrom> Do you have a parser combinator library in continuation passing style?  I want it I want it I want it!
20:49:12 <TheStar> wagle, But at the outside, use normal imperative conventions.
20:49:33 <TheStar> monochrom, Heh, that might as well have been written in all caps...
20:49:36 <wagle> TheStar: have you seen scheme?
20:49:41 <TheStar> No.
20:49:58 <TheStar> I started investigating Haskell once I saw the similarities in my code.
20:50:30 <ozone> TheStar: i'm pretty sure parrot bytecode is totally CPS
20:50:49 <TheStar> ozone, Really?  I know that it's register-based...
20:51:10 <ozone> i think they decided to switch to CPS after they had to implement continuation support for ruby
20:51:18 <TheStar> AHh.
20:51:22 <ozone> and then decided they might as well do everything with continuations to make the model more uniform
20:51:45 <autrijus> actually larry said perl6 has to have continuations too :)
20:51:51 <autrijus> (which is why Pugs is also CPS.)
20:52:18 <wagle> check out essentials of programming languages http://www.amazon.com/exec/obidos/tg/detail/-/0262062178/qid=1111380770/sr=1-1/ref=sr_1_1/104-1620051-1126362?v=glance&s=books
20:52:24 <ozone> autrijus: ever considered Inline::Parrot for Pugs? ;)
20:52:40 * TheStar still can't believe he stumbled on CPS before he understood it, by trying to optimize his code to take advantage of tail-call optimization.
20:52:42 <autrijus> ozone: no. something better: we will be compiling to parrot.
20:52:56 <ozone> woo
20:53:01 <ozone> the circle will be complete
20:53:05 <autrijus> yes.
20:53:30 <autrijus> o/~ the circle of pugs / it's the wheel of fortune / it's the leap of faith / it's the band of hope o/~
20:53:32 <dons> is there already a compilation scheme described for perl->parrot?
20:53:37 <ozone> autrijus: especially after i get my haskell to parrot compiler going
20:53:40 <ozone> in about 5 years
20:53:49 <TheStar> dons, I believe it already exists.
20:53:52 <TheStar> dons, It's perl6
20:53:54 <autrijus> dons: described, yes. specced, no.
20:54:02 <ozone> well, actually, should be only a few months, if i have my way with dons :)
20:54:05 <autrijus> dons: I'm working on it :)
20:54:11 <dons> s/described/informally described/?
20:54:30 <autrijus> dons: let's just say the acceptance criteria at each step has been given out
20:54:33 <dons> ozone: I want you to do the minhs parrot backend for cs3161.
20:54:38 <autrijus> but no real operational semantics.
20:54:39 <ozone> dons: that's the goal
20:54:45 <autrijus> minhs?
20:54:47 <ozone> at least, that's my secret goal
20:54:49 <autrijus> cs3161?
20:55:01 <ozone> autrijus: dons's my tutor at university
20:55:08 <dons> :)
20:55:10 <ozone> i grin at him a lot
20:55:17 <dons> that's very true.
20:55:39 <dons> autrijus: is the compilation strategy online somewhere?
20:55:39 <wagle> i dunno..  i had continuations down solid once i had the stack machine model available in my head to check the operational semantics
20:56:09 <ozone> dons: i've even done the tute questions
20:56:13 <wagle> there's several other ways to view continuations, of course
20:56:15 <ozone> do i get a biscuit?
20:56:17 <dons> ozone: omg!!
20:56:22 <TheStar> ozone, Gasp! You actually do tute questions?
20:56:26 <dons> biscuits for the monkey boy!
20:56:35 <ozone> arf arf
20:56:47 <wagle> i wonder about people who insist that there is precisely one (1) true way to view them
20:57:25 <TheStar> *my* tutor was one year older than I.
20:58:10 <dons> I think ozone is the same age as me.
20:58:14 <ozone> wagle: they weren't python advocates by any chance, were they?
20:58:16 <autrijus> dons: I'll ask. sec
20:58:35 <ozone> dons: i'm 13 at heart!
20:58:42 <dons> I know that!
20:59:03 <dons> monkey boy by name, monkey boy by nature.
20:59:14 <TheStar> Heh.
20:59:36 <ozone> \o/
20:59:38 <TheStar> dons, Are you really a formal tutor, or an informal tutor? (ie, employeed by uni?)
20:59:49 <dons> I'm a formal tutor
21:00:01 <TheStar> dons, The distinction can be important :)
21:00:04 <ozone> informally, he's my gimp.  but don't tell anyone
21:00:05 <wagle> ozone: i dunno
21:00:11 <TheStar> dons, What do you teach?
21:00:15 <TheStar> ozone, Gimp?
21:00:18 <ozone> "not much"
21:00:20 <dons> Principles of Programming Languages.
21:00:30 <wagle> ozone: hmm..  actually i do..  they were scheme advocates
21:00:32 <TheStar> Cool.
21:00:36 <dons> sorry, s/Principles/Concepts/
21:00:48 <wagle> ozone: i just dont know python advocates
21:00:49 <TheStar> They're sorta related.
21:01:22 <dons> it's really principles that are taught, though. not just concepts.
21:01:42 <dons> hmm. ozone's going to have to get up and do some proofs this week, I think ...
21:06:16 * TheStar starts learning XML, because he suspects that's the only file format his C# lecturer will accept...
21:10:06 <TheStar> Even if I believe a different format will be smaller, better, clearer, and more concise ;)
21:10:35 <TheStar> (All I have to do is dump a flat hashmap into a file)
21:11:09 <wagle> XML is assembly language, not (generally) to be viewed directly
21:12:36 <TheStar> wagle, It's supposed to make it easy for the programmer to work with.
21:12:46 <TheStar> wagle, Trouble is, today, it's seen as the only solution...
21:14:14 <wagle> standards can be useful.  you needn't knock the tower down.
21:14:41 <wagle> the xml suite _is_ pretty darn powerful
21:15:09 <monochrom> You can write programs to produce XML files you can hand in.
21:15:10 <TheStar> Yes, but for a simple "dump a list of pairs of letters and their frequency counts"...  It's a bit over-the-top.
21:15:32 <TheStar> monochrom, Actually, this program has to use xml as it's native file format.
21:15:55 <monochrom> Doesn't the C# library come with XML parsers and generators?
21:16:08 <monochrom> (I don't know.)
21:16:55 <TheStar> monochrom, It does... But *nothing* beats "for each line in file { paired = line.split(' '); pair = paired[0]; freq = paired[1];)
21:17:26 <TheStar> monochrom, And it's cross platform, can be made a standard of that program, and is easily incorporated into any other random project if need be.
21:17:33 <monochrom> I agree that the instructor should have posed a question with more difficult output.
21:17:36 <wagle> is you automatically grade 300 programs, xml format is not over the top..  i imagine the data will get more interesting as the course progresses
21:17:48 <wagle> s/is you/if you/
21:18:55 <TheStar> wagle, I certainly hope so.  As it is, it appears that there's 6 of us in second year, in a class of 80 first-year students.
21:18:56 <monochrom> Something like "write a C# program to read /usr/dict/words and output the B-Tree in XML format" would be just right.
21:19:11 <TheStar> monochrom, We're doing a language recognition program.
21:19:12 * wagle pulls up stakes, and leaves the wireless oasis for the desert beyond
21:19:43 <monochrom> Or maybe "write a C# program to read a C# program and output the abstract syntax tree in XML format"
21:20:36 <TheStar> monochrom, That's *way* beyond the level of this class.
21:20:53 <TheStar> monochrom, The lecturer didn't even want them to use hashtables, because he didn't think they could figure out how to do it on their own.
21:21:24 <TheStar> monochrom, Well, that's basically what he told me.  He seemed right impressed when I knew how to use hashtables.  I'm thinking... COMON! IT's just a hashtable!
21:21:43 <sylvan> TheStar how about "xmlserialiser.serialize(mypairs)", pretty simple
21:22:03 <TheStar> sylvan, I could do that, but I'd better check with his lecture notes to ensure that he's happy with it.
21:22:24 <monochrom> I happen to be of the school of thought that the questions should be adjusted to match the level of the output format, not the other way round. :)
21:22:35 <sylvan> he should be, what's the point of C# and .net if you can't use the standard libraries?
21:22:49 <TheStar> sylvan, Well, he told the class not to use a darned hashtable.
21:23:23 <sylvan> true
21:24:03 * TheStar reads up on xmlserializationwriter anyway.
21:25:29 <TheStar> But, for something like this, it's not too hard to write oneself their own xml writer.
21:29:05 <TheStar> Hmm, the docs on serialization are peculiar.  Why would it *produce a C# file#?
21:29:09 <TheStar> ANyawy.
21:31:58 <a5> if I have a type 'X a b c' I can declare '\x -> X a b x' as a functor with instance Functor (X a b), but if I want to declare that '\x -> X a x c' is a functor, what do I do?
21:34:05 <jyasskin> a5: I think you have to use a newtype
21:34:40 <jyasskin> a5: i.e. newtype X' a c x = X a x c; instance Functor (X' a c)
21:35:00 <jyasskin> oops, newtype X' a c x = X' (X a x c)
21:35:26 <a5> that sucks
21:35:54 <jyasskin> I agree. I could be wrong, but if so, I'd like to know the better way too.
21:37:28 <jyasskin> It'd be nice to write just "type X' a c x = X a x c; instance F X' a c", but http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3143135 claims they consciously disallowed that, so there's probably some reason.
21:37:48 <Pseudonym> Sorry, buss key.
21:37:52 <Pseudonym> boss key
21:38:07 * Pseudonym scrolls back
21:38:15 <Pseudonym> OK, Wadler's Law of Language Design:
21:38:18 <Pseudonym> http://www.informatik.uni-kiel.de/~mh/curry/listarchive/0017.html
21:39:01 <Pseudonym> ozone: Yes, I'd like typeclass instances to be first-class.
21:39:11 <Pseudonym> It'd be great if you could declare them dynamically, like records.
21:39:25 <Pseudonym> And if you could pass them by value, rather than implicitly.
21:40:11 <Pseudonym> I think that's everything that was addressed to me.
21:52:22 <jyasskin> Does anyone happen to know where I can read about why partially applied type synonyms aren't allowed in instance declarations (even after the ghc extensions to type synonyms)?
21:53:19 <dons> probably documented in the 'type systeem extensions' part of the ghc user guide?
21:54:10 <dons> or maybe just in the H98 report.
21:54:30 <Pseudonym> The use of type synonyms _at_all_ in instance declarations is a GHC-ism.
21:54:41 <Pseudonym> It's possible that it's an implementation-specific issue.
21:54:49 <Pseudonym> i.e. "we couldn't do it easily"
21:56:03 <jyasskin> dons: It's mentioned in the 'type system extensions' part 7.4.4.2, but not explained.
21:56:38 <dons> "This design decision is independent of all the others, and easily reversed, but it makes sense to me."
21:57:11 <jyasskin> yeah, I was looking for an explanation of "makes sense to me". ;)
21:57:12 <dons> isn't that the explanation for why type synonyms must be fully applied?
21:57:19 <dons> oh, me == spj, qed.
21:57:46 <dons> otherwise, you can inspect the typechecker code of ghc, which probably has more details
21:57:55 <jyasskin> ooh, good idea
21:59:20 <dons> not sure if type synonym checks occur before or after typeclasses are compiled down to normal haskell (i.e. => becomes Dict ->)
21:59:30 <dons> so it may be somewhere else in the compiler
22:00:51 <jyasskin> heh, if it's somewhere else I have no chance at all of finding it.
22:01:46 <dons> grep */* ;)
22:01:48 <Cale> It sounds like that decision was made so that type synonyms always work the same way. (You must always fully apply them)
22:02:49 <dons> yeah. seems to be several notes on full saturation in the code.
22:03:03 <dons> though I haven't found a definitive explanation.
22:03:54 <jyasskin> Cale: ok, that makes sense. Then generalizing the question, why must I always fully apply them?
22:05:01 <Cale> Probably technical reasons. Note that they'd give you a certain sort of type level lambda if you could partially apply them.
22:05:28 <Cale> (why type level lambdas are not permitted, I'm not sure)
22:05:34 <dons> which I suspect would lead to weird things when they're translated to normal haskell.
22:06:07 <dons> Cale: the GHC parser actually looks for /\ ! it's just not plugged in to anything
22:06:23 <Cale> dons: hmm :)
22:06:51 <adiabatic> For what, an upper-case lambda?
22:07:14 <dons>  /\ is a type lambda in usual notation
22:07:55 <Cale> yeah, it mimics an upper case lambda
22:08:05 <jyasskin> Then is it generally agreed that they'd be useful but are just hard to implement?
22:08:16 <dons> what, type application?
22:08:27 <jyasskin> partial application of type synonyms
22:09:11 <dons> oh, that's right. I suspect it screws up the translation of type classes into normal functions with dictionaries. there'd be a discussion in one of the typeclass papers somewhere, I reckon
22:10:00 <jyasskin> ok, I'll look around in those. Thanks :)
22:10:08 <Cale> Has any work been done to figure out what to do in the general case with type classes then?
22:12:58 <dons> don't know. now, how's the translation work? classes describe dictionary data types, and instances describe particular dictionary values.
22:13:41 <dons> and a constraint of f :: A => a -> b , becomes f -> dictA -> a -> b
22:15:48 <ibid> the first -> should probably be ::?
22:15:59 <dons> yes. oops.
22:17:56 <dons> so an instance for a  partially applied type synonym would describe a dictionary for a type-lambda type (?). hmm. or there may be no valid dictionary type for the dictionary value that is defined by the instance.
22:18:22 <dons> s/for a/dictionary of type-lambda type
22:19:49 <jyasskin> Does "constructor classes" sound like the right place to look?
22:20:33 <dons> doesn't sound right  to me.
22:22:12 <jyasskin> hm, that's the ability to even define class Monad
22:23:35 <dons> ghc quote of the day: "Zonking makes sure that the instance types are fully zonked."
22:24:21 <Cale> heheh
22:24:24 <Cale> that's in the source?
22:24:53 <dons> typecheck/Inst.lhs
22:25:26 <TheStar> Classic easteregg.
22:25:37 <dons> ah. much interesting discussion in typecheck/TcClassDcl.lhs
22:25:42 <jyasskin> http://www.cse.ogi.edu/~mpj/pubs/fpca93.html mentions the restriction. It says why, but I don't understand yet.
22:27:12 <dons> the compilation strategy for classes is well documented in the above file :) this is really good.
22:27:26 <dons> there's even examples !
22:35:39 <musasabi> morning
22:36:09 <adiabatic> Where?
22:37:50 <dons> Team GMT+2!
22:38:58 <jyasskin> dons, Cale: thanks for the pointers.
22:42:28 <musasabi> dons: btw garbeam complained that yi had some problems with NetBSD curses.
22:42:59 <dons> hmm. interesting - esp. since developed on openbsd.
22:43:02 <dons> @seen garbeam
22:43:02 <lambdabot> I haven't seen garbeam
22:43:16 <dons> does he hang out here?
22:43:33 <musasabi> I talked with him on #plan9..
22:43:47 <musasabi> dons: I can try that out later this week..
22:43:47 <musasabi> -c
22:44:07 <dons> well, he can certainly email me any bug reports - i'll look into it
23:06:26 <dons> ok, so you can't have partially applied type synonym constructors anywhere (except some certain places in -fglasgow-exts) as type synonyms are (usually) all expanded prior to typechecking. so type P a  = [[a]] ; instance C P ... makes no sense when P is expanded. hence the saturationn rule
23:08:20 <musasabi> partial type senonyms are useful in many places - e.g. defining monad transformers.
23:08:44 <dons> under -fglasgow-exts ?
23:09:39 <musasabi> yes, I think they need that (but the code is using other things which need -fglasfow-exts)
23:10:19 <musasabi> type SEnv = StateT SState IO
23:11:05 <dons> yeah, under -fglasgow-exts I think ghc can determine that certain partially applied type synonym constructors will work by coming up with some guarantee that they'll be expanded away by the time the typechecker gets around to it
23:11:28 <musasabi> I think it just checks all the instantinations.
23:12:53 <musasabi> not applying enough arguments will give a kind error.
23:13:15 <dons> yes.
23:14:02 <musasabi> The good side is that one can sometimes partially apply the type constructor in an instance declaration.
23:14:19 <musasabi> but that could be doable with a saturated one too.
23:18:31 <Janni> Hi.
23:18:41 <Janni> Long time no see, and right away a question:
23:18:51 <Janni> I just upgraded to ghc 6.4 and it doesn't seem to recognize the -fno-prune-decls flag, although it's listed in GHC-doc's flag reference.
23:20:02 <musasabi> Has anyone done an elegant design for allocating buffers for a pipe? Stages know whether they will 1) mutate in place 2) mutate to new buffer (which needs to be +N bytes larger) 3) append/prepend N bytes to the current buffer 5) flush the current buffer to somewhere else with a size constraint.
23:22:40 <musasabi> Currently my typical pipe is: Copy size +2 => append +4 => prepend +8 => sink 64kb.
23:23:01 <musasabi> Would just processing the list in reverse be a good solution?
23:40:12 <musasabi> that seems to work.
23:41:35 <musasabi> Is touching needed for a ByteArray ?
23:43:37 <nothingmuch> hello
23:43:42 <nothingmuch> in http://www.nomaware.com/monads/html/class.html#example2
23:43:56 <nothingmuch> maternalGrandfather s= (return s) >>= mother >>= father
23:44:05 <nothingmuch> i want to know if i'm reading it right:
23:45:26 <nothingmuch> errm... the return part doesn't make sense to me
23:45:35 <nothingmuch> but anywho
23:45:38 <nothingmuch> it takes Sheep
23:45:44 <nothingmuch> turns it into a monadic thing
23:45:52 <nothingmuch> in this case the Just part of the Maybe type
23:46:07 <nothingmuch> then it chucks it over to mother, and then it chucks that over to father?
23:46:21 <musasabi> yes.
23:46:23 <nothingmuch> and in the case that mother returns nothing
23:46:37 <nothingmuch> then mother >>= father will not invoke father with the return of mother?
23:47:36 <nothingmuch> what is Maybe, in this case?
23:47:42 <musasabi> nothingmuch: it is equivalent to case mother s of Just x -> father x ; Nothing -> Nothing
23:47:49 <musasabi> "maternalGrandFather sheep = father =<< mother sheep" could be more readable.
23:48:24 <nothingmuch> okay, that makes sense
23:48:34 <nothingmuch> now, err, about being in type calss Monad
23:48:42 <nothingmuch> and type classes in general
23:48:46 <nothingmuch> this just means that Maybe, as a type
23:49:03 <nothingmuch> can be used in operations having to do with monadic behavior?
23:49:22 <nothingmuch> or does membership in the Monad class not really mean anything at all, beside a convention?
23:49:31 <nothingmuch> i mean, is Maybe monadic in it's own right?
23:50:01 <musasabi> yes.
23:50:19 <musasabi> being a monad means that it can be used with monadic combinators.
23:50:55 <musasabi> >>= is one such combinator.
23:51:00 <musasabi> @type (>>=)
23:51:08 <lambdabot> (>>=) :: forall m b a. (Monad m) => m a -> (a -> m b) -> m b
23:51:50 <nothingmuch> this pulls the regular type a out of it's monadic frobnication (which i assume i'll understand more soon)
23:51:55 <musasabi> "Take a value of a in monad m and combine it with a function producing m b from a.
23:52:04 <nothingmuch> and then applies it to the function whose type is (a -> m b)
23:52:14 <nothingmuch> ok
23:52:34 <musasabi> Each monad instance decides what exactly this combination means.
23:53:01 <musasabi> Like Maybe defining it to mean "combine Just values and short-circuit with Nothing".
23:53:16 <nothingmuch> ah
23:53:19 <nothingmuch> that's unclear
23:53:21 <nothingmuch> i think i need an example =)
23:53:38 <musasabi> well >>= could be defined for maybe as:
23:53:42 <nothingmuch> do you have another example? i'm failing to generalize it myself
23:53:56 <musasabi> Nothing >>= _ = Nothing
23:54:05 <musasabi> Just x >>= f = f x
23:54:32 <nothingmuch> that example I think i grokked
23:55:32 <musasabi> Then continue further and see how different monads do things - State was easy for me, List and Cont harder.
23:56:03 <nothingmuch> what is State?
23:56:42 <nothingmuch> or rather, where is it defined?
23:57:06 <musasabi> State is a monad for transfering a mutable state through computations transparently.
23:57:22 <nothingmuch> a general type for things with side effects?
23:58:05 <musasabi> not, really just something convenient - read and see ;-)
