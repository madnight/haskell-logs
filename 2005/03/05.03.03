00:02:50 <Itkovian> meuning is what the policeman in 'allo 'allo says :-)
00:03:00 <Itkovian> (i keep forgetting his name (crabtree?))
00:03:15 <Matt-W> yup
00:10:05 <nlv11757_> ow yeahhh now i remember
00:10:08 <nlv11757_> he did say that
00:10:43 <nlv11757_> hahah i associate the name crabtree with the 'female' busdriver in southpark :P
00:16:16 <Itkovian> actually he usually says 'good meuning'
00:19:10 <nlv11757_> it's all in the details
00:25:31 <bourbaki> moin
00:26:07 <yome> Offtopic, but does anyone knows what 0w1 means in SML?
00:30:02 <Itkovian> nope
00:38:31 <kzm> God morgen!
00:40:05 <bourbaki> moin
00:46:09 <kzm> Yesterday, I asked for comments on space-efficient Int-sets.
00:46:34 <kzm> One suggestion was a Map of MVars/IORefs to UArray.
00:46:56 <kzm> Does that really hold any advantage over a Map of IOUArrays?
00:47:58 * kzm listens to the sound of crickets for a while, then moves on to check another channel.
00:48:25 * nlv11757_ enjoys the silence
00:51:51 * vincenz drops a pin
01:03:01 * Itkovian drops a bomb
01:03:11 * vincenz drops a C++-standard
01:04:28 * Itkovian ducks
01:05:02 <vincenz> why duck? I drop it I don't throw it....the motion is downwards...aka ducking won't alter your probability of getting hit
01:07:53 <Khisanth> it can explode :)
01:08:10 <Itkovian> it can shatter
01:08:20 <Itkovian> shrapnel can be lethal
01:08:34 <Khisanth> hmm fragile standard
01:16:28 <vincenz> lol
01:19:04 * ibid has a nice hardbound copy of the c++ standard
01:19:13 <ibid> (as well as the c standard and the haskell report:)
01:19:13 <Itkovian> hmm, Suppose I define a type data Line a = L [a], how can I make sure 'a' derives show?
01:19:31 <ibid> you can't, really
01:19:34 <vincenz> ibid: I got a nice hardcopy too ... 2003 release
01:20:00 <ibid> except by using Line a in a context that requires Show a
01:20:16 <ibid> vincenz: the bs version? yeah, me too
01:20:47 <ibid> (that's british standard, not bullshit, you weirdos:)
01:21:27 <vincenz> ibid 2003 was actually a new release
01:21:30 <vincenz> changes in the std
01:21:44 <vincenz> they rerelease every 5 years
01:22:53 <ibid> vincenz: it's not just 1998 with cor1 applied?
01:23:26 <ibid> yeah, this one is BS ISO/IEC 14882:2003
01:23:39 <ibid> but i thought it's just 1998 with cor1 applied :)
01:23:49 <vincenz> not sure what cor1 is but I know that there were changes
01:23:52 <Itkovian> ibid: yes, I have an instance Show (line a), but then I need to map show to [a] in the definition ...
01:24:07 <ibid> Itkovian: can you be more specific?=
01:24:11 * vincenz purrs at the typeclass talks
01:24:19 <Itkovian> ibid: sure I can :-)
01:24:20 <vincenz> typeclasses map SO 1-1 to category theory
01:24:26 <vincenz> I should learn haskell :(
01:24:31 <ibid> vincenz: the introduction confirms me
01:24:47 <Itkovian> 3 lines, eh ;-)
01:24:48 <Itkovian> data Line a = Ln String [a]
01:24:55 <vincenz> yes, but it's not just a bs vesion
01:24:56 <Itkovian> instance Show (Line a) where
01:25:02 <Itkovian> show (Ln s v) = concat (s:(zipWith (++) (repeat ":") (map show v)))
01:25:25 <Itkovian> I want a general type to represent lines in a trace file, of the format <tag>:[number]
01:25:39 <ibid> vincenz: "This most recent revision merges the first C++ standard, officially known as BS ISO/IEC 14882:1998, with updates (Technical Corrigendum 1) adopted between 1997 (when the standard was ratfied) and 2001."
01:25:52 <ibid> vincenz: it's a little joke, that bs version :)
01:26:21 <ibid> vincenz: it's a bs (British Standard) version because the permission to print comes from the british national standards body
01:26:44 <ibid> Itkovian: ah, instance Show a => Show (Line a) where ...
01:27:10 <ibid> Itkovian: that crucial bit of that you are talking about instance declaration was missing before :)
01:27:35 <ibid> vincenz: Cor1 is an abbrev for Technical Corrigendum 1
01:27:45 <vincenz> ah
01:28:53 <Itkovian> ah ok.
01:29:25 <Itkovian> I wasn't sure where to place that Show a bit
01:30:40 <ibid> Itkovian: mind you, that doesn't mean that all Line a's are in Show or that Line a can be only if Show a holds; it only means that *if* Show a holds, then Show (Line a) holds too :)
01:34:19 <Itkovian> i know, i know ...
01:35:32 <Itkovian> musasabi: I need some help with hs_fltk. well ... I haven't done anything _yet_, but I'm wondering if it is easy to construct a board of squares on which images can be places and removed etc.
01:41:54 <tromp> morning, #haskell
01:42:56 <Itkovian> hi
02:05:13 <Lemmih> @seen shapr
02:05:13 <lambdabot> I saw shapr leaving #webwitches 18 hours 21 minutes 54 seconds ago.
02:10:18 <tromp> morning, Thomas
02:10:29 <TheHunter> morning, tromp
02:10:42 <tromp> i finally solved the leak
02:10:46 <TheHunter> yay!
02:10:54 <TheHunter> what was it?
02:11:28 <tromp> negaxmax still had a reference to all of movelist
02:11:44 <tromp> even though it was not gonna use the alrd searched entries
02:12:13 <TheHunter> sound reasonable.
02:12:16 <tromp> i rewrote the dynamic move ordering and now it works
02:12:44 <tromp> although it's still a mystery to me why some intermediate versions still leaked
02:13:07 <tromp> that i thought had no reference to searched entries
02:13:16 <tromp> this stuff can be subtle...
02:14:13 <TheHunter> so how does the haskell solution compare to C/Java?
02:15:35 <tromp> horrible:(
02:15:48 <tromp> seems almost 100 times slower
02:16:13 <TheHunter> uuh, that's much less than I thought.
02:16:28 <tromp> u expected 1000 times slower??
02:16:32 <TheHunter> after all, the code is using unboxed arrays extensively.
02:16:51 <TheHunter> no, i expected something like 10 times slower.
02:16:54 <tromp> i hoped it would be withn a factor of 5
02:17:53 <tromp> it shld be doing the same basic ops as the other versions
02:23:19 <TheHunter> "Syntactic extensions make source code processors complicated and error prone. But they don't help to make programs safer (like type checks and contracts) or easier to maintain (like modularization and scoping)."
02:23:26 <TheHunter> True or false?
02:24:25 <Lemmih> False.
02:24:35 <Lemmih> What do I win?
02:24:41 <TheHunter> Thank you.
02:25:16 <shrimpx> what's a syntactic extension?
02:25:22 <TheHunter> That's pretty obvioulsy wrong isn't it?
02:25:32 <Lemmih> I would say so.
02:25:47 <TheHunter> shrimpx, this text refers to stuff like list comprehensions and guards.
02:26:06 <shrimpx> oh
02:26:22 <shrimpx> yea that sounds bogus
02:26:44 <shrimpx> i think "syntactic exension" refers to macro systems in the scheme world
02:31:00 <TheHunter> @wiki ThingsToAvoid
02:31:01 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid
02:31:02 <TheHunter> the way i read it, the author even seems to claim that tools can't cope with the haskell98 syntactic sugar.
02:31:05 <TheHunter> man, whoising the whole channel takes an awful lot of time...
02:31:39 <Lemmih> TheHunter: With /who #haskell ?
02:31:42 <kzm> Hunter, well, I'm not so sure.  Clearly, syntactic extensions don't *have* to complicate the syntax a lot -- but otoh, they can.
02:32:00 <kzm> (Do you count e.g. implicit parameters as syntactic extension?)
02:32:25 <TheHunter> i'd rather see them as type system extension.
02:32:32 <tromp> i'm willing to admit that TH make source code processors complicated, but the other points i also disagree with
02:33:03 <TheHunter> Lemmih, thanks, I didn't know who...
02:33:11 <theorbtwo> I'm sure I'm missing something obvious, but does anybody know how to use hat with ghc without going through hmake?
02:33:55 <kzm> But is it really?  I mean, you could equally well write the same thing explicitly, couldn't you?  Anyway, the (?) syntax depends on spacing etc.   Which is not so nice.  Similarly, TH recycles some of the list comprehension syntax.
02:34:18 <kzm> IMHO, the Haskell syntax (with GHC exts) is dangerously close to bursting.
02:34:39 <Lemmih> That syntactic extensions make preprocessing harder is not on dispute here.
02:35:09 <TheHunter> kzm, implicit parameters can't be described as a source-to-source translation.
02:35:18 <kzm> Hmm...okay.
02:35:46 <TheHunter> they even have the property that adding a type annotation infered from the compiler can change the meaning of the code...
02:35:48 <kzm> Lemmih: So which part was false -- that it doesn't help?
02:36:09 <Lemmih> Yes.
02:36:19 <kzm> Yes, IIRC there was a pretty convincing example that IPs are indeed Evil.
02:36:21 <kzm> :-)
02:36:27 <kzm> AH, okay.
02:37:15 <TheHunter> implicit parameters are very close to impure languages.
02:37:23 <shrimpx> sweet that page is pretty neat
02:38:05 <tromp> how does one use IP? is there a simple example somewhere?
02:38:37 <shrimpx> does anyone know if the combinator c f g x y = f (g x) (g y) have a name in LC?
02:38:38 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
02:38:46 <TheHunter> section 7.4.5.
02:40:36 <tromp> i doubt it, shrimpx
02:41:58 <tromp> i don't even know a name for c g x y = g x (g y)
02:42:32 <shrimpx> thanks, that's what i figured
02:45:17 <tromp> argument distribution is a lot more common than function distribution
02:48:14 <TheHunter> actually, implicit parameters are very nice. If you figure you need an extra parameter somewhere, you just need to change a few type signatures, and you're done.
02:50:59 <kzm> Well -- I experimented with IPs, and am left wondering whether it bought me something, or whether it is just an excuse for not doing things "properly"
02:51:24 <kzm> (My view may have been colored by having defined an operator (?) in advance)
02:53:42 <TheHunter> i'm not entirely sure. When you do things right in the first place, you don't need implicit parameters. But changing existing code becomes a lot easier (it often turns out you didn't need the paramter anyway).
02:54:53 <TheHunter> Alos, do syntax is much too verbose for commutative monads, and implicit params give you a reader monad in direct style, "for free".
02:55:00 <TheHunter> *Also
02:56:55 <kzm> Hmm...okay.  I haven't used them in that way, but I do recall one paper concluding that IP was the preferred replacement for global variables.  Oh well.
02:56:56 <TheHunter> there should be a flag, -fwarn-if-depending-on-the-monomorphism-restriction, that'd force the programmer to fix the ambiguties.
02:58:26 <kzm> Is it possible to overload (!), btw?  It seems a really obvious target, but AFAICT, this is not possible (intended).
02:58:46 <kzm> (The mentioned (?) operator was my alternative)
02:59:05 <TheHunter> why shouldn't it be possible to overload (!)?
02:59:54 <kzm> Don't quite remember -- is it defined in a class at all?  I remember trying without success...but not the details (I should do my homework before commenting, I guess).
03:00:39 <TheHunter> Data.Array defines (!), but that isn't a problem, really.
03:00:52 <TheHunter> HTML stuff uses it too, iirc.
03:01:16 <TheHunter> Prelude> let a ! b = a + b :: Int
03:01:16 <TheHunter> Prelude> 4 ! 5
03:01:16 <TheHunter> 9
03:01:57 <kzm> Hmm...it's defined in the IArray class - I guess what I want is to instantiate this class for arbitrary indexed structures (lists, say)
03:02:19 <TheHunter> @index !
03:02:19 <lambdabot> Data.Array.Base,Data.Array.Diff,Data.Array.IArray,Data.Array.Unboxed,Data
03:02:19 <lambdabot> Array,GHC.Arr,Text.Html,Array
03:05:12 <TheHunter> i guess it's a bad decision that # in ? are overloadable under -fglasgow-exts.
03:08:19 <kzm> can you define an Instance of IArray for lists?  (I get '!' variable not in scope)
03:10:30 <kzm> Hmm...guess I was looking at outdated (4.08) docuemntation.  IArray no longer contains !, and ! is not a class method.
03:11:55 <kzm> Apparently, ! is defined separately in each module (D.A.Base, GHC.Arr, etc)
03:12:48 <nlv11757_> if i get: "    Inferred type is less polymorphic than expected
03:12:48 <nlv11757_>         Quantified type variable `p' escapes
03:12:48 <nlv11757_> "
03:13:15 <nlv11757_> with the type pTypedef :: (IsParser p Char) => p T_Typedef
03:13:15 <kzm> I guess the easy way is to avoid mixing array ops and ops on "my" data types, and just define yet another ! operator in my module...
03:13:21 <nlv11757_> whats going on?
03:14:54 <tromp> you need to mention p as argument of pTypedef
03:16:50 <TheHunter> nlv11757_, maybe it helps to remove the type sig and see what the compiler infers.
03:17:30 <TheHunter> it'll probably infer something less general than p.
03:20:50 <nlv11757_> ow man, im such a cow.....its not pTypedef.....i accidently had some others WITHOUT signature....i explicitly need that signature for the constraint
03:20:54 <dblhelix> nlv11757: UU.Parsing? your type indicates that pTypedef can supply a value of any character parser
03:23:54 <TheHunter> nlv11757_, -fno-monomorphism-restriction might help...
03:25:27 <Itkovian> How can I add Line(s) (data Line a = Ln String [a]) together, if a is an instance of Num? I'd like to obtain (Ln s v1) + (Ln s v2) = Ln s (zipWith (+)) v1 v2). And It should be done outside of the Line module. Is it a good idea to make Line an instance of Num? Or are there better ways (I'm quite sure there are).
03:25:31 <nlv11757_> YEAH baby, that was it
03:25:34 <nlv11757_> thanx
03:25:46 <nlv11757_> after I explicitly added the signatures it worked
03:26:10 <Itkovian> The goal is to foldr (+) NULLLINE lines ...
03:26:22 <nlv11757_> because without the explicit signatures, this p was in fact escaping because it wasnt mentioned in the constraint (since there was no sig at all)
03:26:29 <nlv11757_> lunch
03:37:49 <TheHunter> Itkovian, it looks more like that should be an instance of Data.Monoid.Monoid.
03:38:37 <TheHunter> you can then use mconcat to "sum" a list of Lines.
03:39:12 <Itkovian> hmm ..
03:39:18 * Itkovian never used Monoid stuff before.
03:40:24 <TheHunter> Num makes sense, if you can define addition, subtraction and multiplication (well, you can of course leave out definitions).
03:41:19 <Itkovian> yeah.
03:41:25 <Itkovian> I am doing that now :-)
03:41:39 <TheHunter> monoids only have one operation (mappend), which is required to be associative and has a unit (mempty).
03:41:59 <Itkovian> uhu
03:42:27 <Itkovian> then the Line would have mappend as (+)?
03:44:48 <TheHunter> yes.
03:45:35 <dblhelix> TheHunter, Itkovian: will that obey the identity law for monoids??
03:46:19 <dblhelix> TheHunter, Itkovian: i.e., what element arises naturally as mempty?
03:47:39 <Itkovian> dblhelix: none that I can think of ...
03:47:47 <TheHunter> i though Ln "" 0, but looking closer, the definition of + is weird anyway, shadowing the second s.
03:47:48 <Itkovian> the type is Ln String [a]
03:48:18 <Itkovian> TheHunter: yes, but the s'ses (ahem) should be the same anyway.
03:48:24 <Itkovian> otherwise adding makes no sens
03:48:26 <Itkovian> e
03:48:54 <dblhelix> Itkovian: well, that disqualifies Line for being a Monad too
03:48:58 <tromp> what do the numbers mean for a line?
03:49:35 <Itkovian> tromp: well, they are measurements for a specific program 'phase'
03:49:45 <Itkovian> of various characterstics
03:49:59 <tromp> but does the list length vray?
03:50:04 <tromp> vary
03:50:17 <Itkovian> dblhelix: anyway, to add the [a]'s should have the same length, and that is not know before the trace file is read.
03:50:24 <Itkovian> tromp: nope.
03:50:34 <Itkovian> tromp: but it may vary between trace files.
03:51:20 <dblhelix> itkovian: an instance of Monoid would not add the lists pairwise, anyway, but just concatenate them
03:51:51 <TheHunter> dblhelix, not necessarily.
03:52:25 <TheHunter> [Int] forms a perfect monoid under mappend = zipWith (+) and mempty = repeat 0
03:52:40 <tromp> i'd be very hesitant to define (+) on data with strings
03:53:59 <dblhelix> TheHunter: okay, but then you would require to constraint the argument type to Monoid as well
03:54:57 <lisppaste2> metaperl pasted "help needed creating output matrix for a series of testing function calls" at http://paste.lisp.org/display/6248
03:56:42 <Itkovian> tromp: the string is ignored.
03:57:45 <tromp> if you ignore the string, why not extract the vectors from the lines before adding?
04:01:09 <Itkovian> Well, the num does it.
04:01:19 <Itkovian> tromp: that looks so bloated :-)
04:01:39 <Itkovian>      15 instance Num a => Num (Line a) where
04:01:40 <Itkovian>      16   (+)  (Ln s1 v1) (Ln s2 v2) = Ln s1 (zipWith (+) v1 v2)
04:02:10 <tromp> doesn't num require a lot more defs than just (+)?
04:02:14 <Itkovian> most code is for the regex splitting ...
04:02:25 <Itkovian> tromp: yeah, but I felt free to ignore them :-)
04:02:37 <tromp> ignorance is bliss:P
04:02:37 <Itkovian> ghc isn't complaining
04:02:42 <Itkovian> damn right.
04:02:45 <TheHunter> Itkovian, don't do that.
04:02:47 <Itkovian> now give me that blue pill
04:02:59 <nlv11757_> hehehe
04:03:02 <TheHunter> define a custom operation.
04:03:16 <Itkovian> TheHunter: I know it's bad, but what would they have to do to be meaningfull?
04:03:22 <Itkovian> I could zipWith (*)
04:03:28 <Itkovian> but what about fromInteger?
04:03:45 <TheHunter> well, why do you want this to be an instance of Num at all?
04:03:57 <tromp> he wants to avoid bloat:)
04:04:05 <Itkovian> TheHunter: to keep code clean when adding Lines?
04:04:25 <Itkovian> hmm, ignore that
04:04:28 <TheHunter> define +|+.
04:05:00 <Itkovian> now there's a good idea!
04:05:06 <Itkovian> Why didn't I think of that?
04:05:29 <Itkovian> TheHunter: suppose I've got another module, I prolly can't overload +|+ ?
04:06:05 <TheHunter> (+|+) is just a usual function that can be exported like any other one.
04:06:32 <TheHunter> you don't overload (+|+), you define (+|+)
04:06:44 <Itkovian> OK.
04:06:50 <Itkovian> import qualified then and some such.
04:07:12 <Itkovian> nice.
04:07:40 <TheHunter> qualified operators are a pita, imo.
04:08:31 <Itkovian> a what?
04:09:41 <TheHunter> well, what do you think about "2 Prelude.+ 4" or even "f Prelude.. g"
04:09:42 <nlv11757_> pain in the ass i think he's referring to
04:11:04 <Itkovian> ah
04:11:06 <Itkovian> ic.
04:11:16 <Itkovian> Hmm.
04:11:22 <Itkovian> you've got a point.
04:11:45 <TheHunter> you can do import qualified MyModule as M; import MyModule (+|+)
04:12:02 <Itkovian> But I can't expect everyone to not use (+|+)?
04:12:14 <lisppaste2> metaperl pasted "help needed: The last statement in a 'do' construct must be an expression" at http://paste.lisp.org/display/6249
04:12:48 <TheHunter> Itkovian, i don't understand.
04:13:13 <TheHunter> metaperl, return $ showres ...
04:13:33 <metaperl> thanks TheHunter
04:17:34 <Itkovian> TheHunter: Well, if one has (+|+) in module M1 and in module M2, one still has to use M1.(+|+), no?
04:20:15 <TheHunter> Itkovian, of course, but the operator be chosen in such a way that it won't clash. I don't know any lib that uses +|+.
04:20:35 <Itkovian> TheHunter: nope, no lib, but homebrew modules perhaps?
04:20:36 <Itkovian> anyway.
04:20:50 <TheHunter> you can be arbitrarily creative: +-<+=+>-+ certainly won't clash.
04:21:02 <TheHunter> @index +|+
04:21:02 <lambdabot> bzzt
04:21:04 <Itkovian> showList [] = shows "" -> this prints "" instead of nothing. How does one make this end with really nothing?
04:21:44 <TheHunter> use id.
04:21:52 <musasabi_> morning
04:21:59 <TheHunter> shows "" shows an empty string, i.e ""
04:22:21 <tromp> it shows some \"
04:22:34 <Itkovian> yeah, I want to see _nothing_
04:22:37 <Itkovian> e.g.
04:22:50 <Itkovian> a3:12:11:12:8:17
04:22:50 <Itkovian> ""
04:22:52 <Itkovian> is not good.
04:23:00 <Itkovian> I just need the a3 line
04:23:13 <tromp> then use id
04:23:23 <lisppaste2> metaperl pasted "type error - help needed" at http://paste.lisp.org/display/6250
04:23:36 <tromp> instead of shows ""
04:23:53 <Itkovian> ok.
04:24:14 <Itkovian> tromp: thx.
04:24:26 <tromp> thehunter said it too
04:24:41 <Itkovian> ah up there, yes. sorry missed that
04:24:45 <Itkovian> TheHunter: thx
04:25:01 <TheHunter> metaperl, what type is showres supposed to have?
04:25:22 <tromp> btw, what is it you're Hunting:-?
04:25:37 <metaperl> it takes 3 args and returns a string
04:25:53 <TheHunter> oh, i meant runtest
04:26:10 <metaperl> the args are a function, a datum of type ApplyArg and a boolean
04:26:33 <metaperl> to be honest, Ihadn't thought of it
04:26:44 <TheHunter> a function of type (a -> m b) or (a -> b)?
04:26:48 <metaperl> that probably should be print $ runtest
04:27:04 <metaperl> that confuses me: a -> m b implies returning two args
04:27:07 <metaperl> how could that be?
04:27:42 <metaperl> or I see, map requires a function of type (a -> b)
04:27:50 <metaperl> therefore if runtest is not of that type, we have problems
04:27:57 <metaperl> however I dont understand a -> m b
04:28:26 <Itkovian> metaperl: a -> b encapsulates f a in the monad m
04:28:39 <Itkovian> f being  the actual function  used
04:28:45 <Itkovian> correct me if I'm wrong
04:28:54 <Itkovian> just got started with this Monad business
04:29:23 <metaperl> maybe I'm doing this all wrong
04:29:24 <TheHunter> tromp, it used to be my nick at playing fps's (that was a long time ago, it's just the translation of my surname), but I rather was the one being hunted ;). I just never had the creativity to choose a less cheesy nick.
04:29:53 <metaperl> I just want to create some output indicating the result of running a function on a series of values
04:29:59 <tromp> why not use just Hunter. saves us all some typing:P
04:30:29 <TheHunter> metaperl, ok, try "let retval = f (mkdat t)", but there are more type errors in that, i guess.
04:31:20 <metaperl> I think my approach is wrong
04:31:35 <TheHunter> tromp, both are three keystrokes using tab-completion...
04:31:51 <TheHunter> anyway, off to lunch.
04:32:02 <tromp> wow, we have tab completion!
04:32:04 <Itkovian> TheHunter: four
04:32:06 <tromp> never knew:(
04:32:17 <Itkovian> tromp: yeah, it was a revelation for me too!
04:32:25 <Itkovian> used it ever since
04:32:52 <metaperl> ok, I have a working function now. It just does not give a lot of output
04:34:13 * samc tries tab completion ooh aah
04:34:52 <samc> now if only I had something to say to someone, I could save keystrokes :)
04:36:02 <lisppaste2> metaperl pasted "better output for my test function needed" at http://paste.lisp.org/display/6253
04:36:26 <metaperl> it works, it just does not display function name, input and output. ONly outuput
04:44:57 <sorje> metaperl, [ ((show t), f (mkdat t)) | f <- funs, t <- types ] will give you the input too, but I don't think you can get the function name as easy.
04:45:24 <metaperl> sorje thanks
04:47:23 <metaperl> how do you get a carriage return at the end of a string? ++ "\n" didnt do it
04:47:44 <sorje> '\n' ?
04:47:58 <sorje> oh forget that ;-)
04:48:27 <tromp> howso, didnt do it?
04:50:04 <metaperl> isnt that funny that we use a typewriter term in computer science? "carriage return"
04:51:00 <metaperl> it didnt put a newline in my output...
04:51:21 <metaperl> it put a literal \n in my output
04:51:40 <tromp> what's the output function u used?
04:51:55 <lisppaste2> metaperl pasted "literal \n in output" at http://paste.lisp.org/display/6254
04:52:07 <sorje> show'int too much?
04:52:11 <metaperl> I think the REPL handles that doesn't it
04:52:19 <metaperl> "show'int" --- what does that mean?
04:52:44 <tromp> i see no output function
04:52:55 <sorje> s/int/ing/ ;-)
04:52:58 <tromp> where's the IO stuff?
04:53:00 <metaperl> right, I think the REPL does that
04:53:07 <metaperl> it calls show automatically doesnt it
04:53:09 <metaperl> ?
04:53:25 <tromp> when then REPL expands your \n into \\n
04:53:39 <kzm> show on a string will quote etc -- try putStr(Ln)'ing it instead.
04:54:23 <tromp> of course you shldnt pass the showres to another show:(
04:55:05 <metaperl> and how do you get the name of a function?
04:55:19 <metaperl> the output just hs (->) when I call show f
04:58:47 <Itkovian> @seen shapr
04:58:48 <lambdabot> I saw shapr leaving #webwitches 21 hours 15 minutes 28 seconds ago.
04:58:57 <Itkovian> oh boy ... he's very busy it seems
05:24:29 <sorje> metaperl, how about that? http://nomorepasting.com/paste.php?pasteID=33270
05:24:35 <kosmikus> Itkovian: I'm done extending tmr.cls
05:24:46 <metaperl> looking
05:25:25 <metaperl> sorje, that is nice.
05:25:26 <kosmikus> Itkovian: look at www.cs.uu.nl/~andres/TMR/Complete.tar.bz2 for a proof-of-concept full version
05:25:37 <metaperl> I just think it is odd that I cannot simply get the name of a function
05:30:39 <earthy> why?
05:31:55 <earthy> conceptually, a function is a first class value that merely performs a certain function
05:32:15 <earthy> that these values can be bound to names is just happenstance, making it easier for the programmer to deal with them
05:32:41 <metaperl> yeah, but I need the name to understand my test diagnostics
05:32:50 <metaperl> to verify them
05:32:55 <earthy> *ah*
05:32:58 <earthy> you want traces
05:33:35 <metaperl> traces, as in hat?
05:33:41 <earthy> e.g.
05:34:48 <metaperl> well I just posted on comp.lang.haskell-cafe or whatever
05:34:54 <metaperl> on GMANE
05:35:05 <earthy> haskell-cafe@haskell.org
05:35:26 <earthy> msgid <6md5ugc103.fsf@Abulafia.hcoop.net>
05:35:29 <earthy> I was just reading it
05:35:30 <earthy> :)
05:36:38 <metaperl> ok, well i dont mean to be rude, but I'm going to sleep right now
05:36:44 <earthy> no worries
05:36:46 <earthy> sleep tight ;)
05:36:48 <metaperl> i am very tired
05:36:50 <metaperl> ok
05:36:51 <metaperl> :)
05:36:54 <sorje> good night ;-)
05:37:51 <metaperl> actually this is morning here in USA_California. but I got up early and want to get some more sleep before work
05:40:11 <nlv11757_> ok, whitespace is officially driving me nuts
05:40:27 <kosmikus> why?
05:40:29 <tromp> dont u love layout rules?
05:45:31 <Philippa_> if you haven't understood how it actually works the layout rule can confuse the hell out of you
05:45:40 <Philippa_> I still occasionally mess up with nested do statements
05:47:35 <dblhelix> kosmikus: how's category theory? :)
05:52:55 <dblhelix> Philippa_,nlv11757_: try mixing do notation with the if ... then ... else ... construct and you'll be ready for instant insanity :)
05:55:33 <samc> how do I write ackerman's function as a fold over the nats?
05:56:00 <samc> ah, nevermind I think I got it
05:56:28 <kosmikus> dblhelix: I'm currently at the EWSCS, so no category theory this week
05:56:34 <dblhelix> samc: are you reading Bird and De Moor's book? :)
05:56:42 <samc> yes, just started
05:56:54 <dblhelix> samc: great book!
05:57:18 <kosmikus> AoP?
05:57:29 <dblhelix> yes
05:57:35 <kosmikus> I like it, yes
05:57:59 <samc> good to hear, it cost an arm and a leg
05:58:09 <dblhelix> however, I'm not too fond of the reversed-arrow notation for functions etc.
05:58:14 <samc> not in the uni library :(
05:58:24 <samc> I like it
05:58:36 <kosmikus> I wouldn't use it myself, but it's ok for the book
05:59:52 <samc> this is what I got:  ack = foldn (+1) (\f -> foldn (f 1) f) does that look right?
06:03:49 <samc> seems to be, it doesn't bode well that I found exercise 1.6 non-trivial :)
06:04:15 <dblhelix> samc: it seems right
06:05:19 <dblhelix> kosmikus: interesting lectures at the winter school?
06:08:15 <araujo> Good morning her.e
06:16:21 <kosmikus> dblhelix: yes, I really enjoy Greg Morrisett's and Olivier Danvy's lectures, and the others are all interesting as well; it's quite a good selection of topics, actually
06:23:51 <nlv11757_> whats an offside parser?
06:24:46 <dblhelix> nlv11757_: a parser that respects haskell's offside rule, i.e., the whitespaces that are driving you crazy
06:27:19 <Philippa_> I found the layout rule completely comprehensible once I'd heard it stated in terms of "this is what Haskell looks like without layout, it attempts to fill in gaps based on this"
06:44:28 <xerox> yo
06:52:00 <nlv11757_> ah i see, philippa (bit late reaction i know :P)
07:04:08 <u1sf> has anyone ever managed to create a decent implementation of Union types just using say Either or similar?
07:06:17 <Itkovian> kosmikus: ok
07:06:32 <Itkovian> I'll look at it as soon as I have some time.
07:06:41 <Itkovian> Fetch me some if you can.
07:07:43 <nlv11757_> i Philippa_ where can i see how haskell would look like without the layout rule?
07:10:21 <Itkovian> dang .. this bloody thing is a veritable memory hog ... 300 MiB
07:10:53 <kosmikus> Itkovian: what thing?
07:11:33 * boegel greets
07:14:53 <earthy> u1sf: you mean something like HList?
07:15:38 <Itkovian> kosmikus: my script to group/accumulate groups of a trace file. Maybe I shoudl consider using plain unix sort first :-)
07:15:49 <Itkovian> then let a small awk scrpt handle it.
07:16:12 <kosmikus> ah
07:16:46 <Itkovian> no, really.
07:17:02 <Itkovian> I need this better, otherwise my haskel advocacy next week will suck
07:21:58 <Igloo> Are you dealing with strings?
07:22:11 <Igloo> If so you might need to switch to some packed string to get the memory usage down
07:22:22 <autrijus> ...or use perl...
07:22:26 * autrijus ducks
07:23:06 <Itkovian> Igloo: yes I am, the line consists of (ah we're through) <tag>:<num1>:<num2>:...:<num33>
07:23:27 <Itkovian> I read it in, put it in a Line data structure, where I read the nums into a Num type (Integer)
07:23:45 <Itkovian> then I group it, (==) on Lines is defines as equals tags (Strings)
07:24:16 <Itkovian> then I map an accumulation on the group list, i.e. I add the elements of each group ([[a]] -> [a])
07:24:37 <Itkovian> it's 93122 lines, thus a list of 93122 items ... not that much I think
07:25:20 <Itkovian> Me thinks the grouping algorithm is just not very good ...
07:25:42 <u1sf> earthy: I don't know, I'd like to achieve a something where I can construct and deconstruct a disjunct of a finite number of types
07:30:12 <musasabi> My favorite PArr bug got fixed in the GHC cvs ^_^
07:31:27 <TheHunter> productP?
07:33:16 <musasabi> parallel parr comprehensions.
07:33:59 <musasabi> http://www.haskell.org//pipermail/cvs-all/2005-March/039267.html
07:36:50 <u1sf> so for example, I'd construct a type like (Int :|: String :|: Float) and then I'd be able to create a value with an index and a type, use a combinator to do case switches and perhaps use TH or SYB to enable value creation based on the element type
07:39:13 <tromp> weird, i'm gstting stack overflow in
07:39:16 <tromp>   putStrLn $ shows n . (" pos / "++) . shows msecs .
07:39:16 <tromp>      (" msec = "++) . shows (ratio n msecs) $ " Kpos/sec"
07:43:12 <tromp> @index $!
07:43:12 <lambdabot> Prelude
07:54:35 <tromp> is there a way to do modifyIORef in a strict way?
07:55:47 <tromp> modifyIORef (\i -> i `seq` i+1)  doesn't quite work
07:56:28 <Philippa> what's it not getting right? The +1 is lazy?
07:57:44 <Philippa> try (\i -> i+1 `seq` i+1)?
07:58:46 <tromp> that won't help
07:59:12 <Philippa> hrmm, you're right
07:59:17 <tromp> i think one has to apply the strictness in the surrounding monad
07:59:24 <tromp>     i <- readIORef nodes
07:59:24 <tromp>     i `seq` writeIORef nodes (i+1)
07:59:28 <tromp> which is a shame:(
07:59:53 <tromp> compared to the cleanliness of modifyIORef (+1)
08:00:05 <Philippa> try (\i -> let r = i+1 in r `seq` r)?
08:00:20 <Philippa> okay, what's going wrong?
08:00:21 <tromp> i'll bet you that doesn't work:)
08:00:23 <Philippa> which bit is lazy?
08:00:37 * Philippa blinks. OK, gotcha
08:00:55 <Philippa> you /could/ just seq the result of a subsequent readIORef?
08:01:13 <Philippa> anyway, I think my brain's dying again atm anyway?
08:01:45 <tromp> there is no subsequence readIORef until the very end of the program
08:01:56 <Philippa> add one?
08:02:02 <tromp> by which time i've done a few million modifyIORef (+1)
08:02:11 <tromp> and then it will stack overflow
08:02:39 <tromp> well, that's what i did in the above rewrite
08:03:17 <Philippa> nearly, you're forcing the old one but not the +1 when you modify there
08:03:28 <TheHunter> modifyIORef' r f = do i <- readIORef r; writIORef $! f i
08:03:45 <TheHunter> that should be in the libs.
08:04:09 <tromp> but isn't
08:04:30 <tromp> wld be nice to have in there
08:05:29 <tromp> btw, writIORef $! f i only forces f, not i, right?
08:05:48 <tromp> or doesn't parse alltogether:(
08:05:59 <TheHunter> it forces f i.
08:06:31 <TheHunter> which is usually what you want, i.e. not storing closures in an IORef.
08:06:36 <tromp> ah! you're right
08:09:20 <tromp> ok, running Fhourstones benchmark in Haskell now
08:09:32 <tromp> 1429411 pos / 43333 msec = 32.9866614358572 Kpos/sec
08:09:44 <tromp> that's a far cry from the C or Java speed:(
08:13:52 <musasabi> tromp: and where is the time being spent?
08:14:25 <tromp> i'll go check
08:15:09 <TheHunter> do you have the latest version on your homepage?
08:15:12 <musasabi> tromp: is the version of source on the page updated?
08:15:34 <tromp> i'll update it in 2 minutes
08:16:29 <tromp> ok, it's there
08:18:36 <musasabi> What kind of input do you use it on (1/10/n ?)
08:19:20 <tromp> just like described on that page
08:19:32 <tromp> eg. 13333111
08:20:08 <tromp> but that one will take forever:(
08:20:24 <tromp> try 2424476144
08:21:12 <TheHunter> that still leaks space, right?
08:21:57 <tromp> nope
08:22:08 <tromp> it just uses a much bigger ttable to start with
08:22:14 <tromp> like 60Mb
08:22:47 <TheHunter> ok
08:23:31 <tromp> shld i get a ./a.out +RTS -p  profile or something else?
08:24:23 <tromp> COST CENTRE                    MODULE               %time %alloc
08:24:24 <tromp>  
08:24:24 <tromp> CAF                            Main                  81.6   80.7
08:24:24 <tromp> CAF                            GameTreeSearch        18.4   19.2
08:26:07 <tromp> i wished a.out.prof was not formatted for 160 columns:(
08:27:05 <musasabi> goodMoves is problematic.
08:27:12 <musasabi> do the other languages use a list there?
08:27:32 <tromp> no, all arrays
08:27:53 <tromp> but they're only 7 elements long
08:29:45 <tromp> the haskell source wld look horrible if i avoided lists alltogether
08:34:47 <tromp> you may want to change back to a smaller transtable size like 1050011
08:35:27 <tromp> that won't change the search speed but avoids the slow ttstats generation
08:36:42 <tromp> btw, goodMoves doesn't appear as a cost centre in my profiles
08:38:30 <musasabi> hmm, how different is your profile from http://youzen.b2.fi/~musasabi/a.out.prof
08:41:13 <tromp> hmm, that's what my profiles used to look like
08:41:19 <tromp> when i was hunting leak
08:41:25 <tromp> now they look quite different
08:41:47 <tromp> just 3 entries in top section
08:41:48 <tromp> COST CENTRE                    MODULE               %time %alloc
08:41:48 <tromp>  
08:41:48 <tromp> makeGameTree                   Main                  70.6   78.1
08:41:48 <tromp> CAF                            Main                  26.4   18.4
08:41:48 <tromp> solve                          Main                   2.5    2.6
08:42:17 <tromp> hmm, i'm using gh-6.4 now
08:42:40 <tromp> i'll try the old 6.2 again
08:43:56 <tromp> btw, your profile looks quite reasonable
08:44:10 <tromp> it makes sense that most time is spent in goodMoves
08:44:20 <tromp> i'm sure the C&Java versions do too
08:44:40 <tromp> it's just shocking that haskell is so slow
08:45:04 <musasabi> well bit operations on Wor64s are not optimized at all.
08:45:11 <musasabi> *Word64
08:45:18 <Lemmih> It's more shocking how rarely one actually need such high speeds.
08:45:53 <tromp> i don't need them optimized; within factor 4 of java would be nice enmough:)
08:46:45 <tromp> ah, with 6.2 i get a better profile:
08:46:46 <tromp> COST CENTRE                    MODULE               %time %alloc
08:46:47 <tromp>  
08:46:47 <tromp> isWon                          Connect4              22.8   32.4
08:46:47 <tromp> alphabeta                      GameTreeSearch        20.4   15.3
08:46:47 <tromp> goodMoves                      Connect4              18.3   18.5
08:46:47 <tromp> move                           Connect4              15.9   16.9
08:47:06 <samc> and so much for the developer efficiency of haskell, you would've been better off doing it in java :p
08:47:40 <tromp> well, the haskell code *does* look much nicer
08:47:51 <tromp> and is in fact way more modular
08:48:14 <tromp> the lazy infinite game tree lets me totally abstract the search from the game
08:48:20 <samc> now if only it worked ;)
08:49:35 <musasabi> one can usually write C in Haskell which is a constant factor from normal C. Of course the result is not very pretty.
08:49:57 <tromp> i wanted the haskell version to show off haskell's strengths
08:50:16 <musasabi> Haskell is not very strong at the bit ops.
08:50:56 <tromp> but that doesn't explain the factor 50 slowdown, does it?
08:51:24 <Igloo> How are you representing the board?
08:51:38 <tromp> 2 64bit words
08:51:53 <tromp> data Game = Game !Int !BitBoard !BitBoard Heights
08:52:05 <tromp> type Heights = UArray Int Int -- index of lowest free square in each column
08:52:24 <Igloo> You'll be copying the UArrays a lot then - does the Java version have to do that?
08:52:44 <tromp> java&c do incremental updates& undo's
08:53:17 <Lemmih> Where's the source?
08:53:20 <tromp> but they also allocate new arrays at every alphabeta call
08:53:37 <tromp> google for Fhourstones
08:53:56 <tromp> http://homepages.cwi.nl/~tromp/c4/fhour.html
08:53:57 <Igloo> Hmm, but 1/5 of the time is spent in isWon. Does that work the same way in the Haskell and Java impls?
08:54:09 <tromp> yes, exactly the same way
08:54:18 <tromp> i used to have -- any ((/= 0) . dir) [1,height,height',height'']
08:54:32 <tromp> but worried about list comprehension inefficiences
08:54:42 <tromp> so i 'unrolled' it into
08:54:43 <tromp> isWon bb = dir 1 /= 0 || dir height /= 0 ||
08:54:44 <tromp>            dir height' /= 0 || dir height'' /= 0 where
08:54:50 <tromp>   dir d = let t = bb .&. (bb `shiftR` d) in t .&. (t `shiftR` (2*d))
08:55:27 <tromp> the C&java actually have the dir function inlined
08:55:42 <tromp> which i expect ghc -O2 to do as well
08:57:29 <tromp> you can see on that webpage the C profile
08:57:33 <tromp> with a line
08:57:34 <tromp>  33.05  12596.52  5880.07 2379228592     0.00     0.00  haswon
08:57:59 <tromp> so that one spends 33% of time on that same function
08:58:33 <Igloo> Oh, i remember this now. shiftR is sillily lazy
08:59:09 <tromp> but this function is strict in every which way
08:59:25 <tromp> all the shift results are immediately tested
08:59:29 <Igloo> No, it checks for 0 in the amount to shift by and returns its argument in that case
08:59:37 <tromp> argh!!
08:59:55 <tromp> what a horrible thing to do
09:00:10 <tromp> that test alone is more expensive than just doing the shift!
09:00:55 <tromp> the fact that the shift gets called means that its result will be needed anyway
09:01:24 <tromp> still, that fails to account for the factor 50 slowdown:(
09:01:44 <tromp> i've seen people on c.l.f discussing a prime micro benchmarkl
09:01:55 <Igloo> Oh, hmm, maybe I'm misremembering, or maybe that's for a different type
09:01:56 <tromp> where haskell gets within a factor 2 of c and ocaml
09:02:12 <Igloo> Anyway, you should look at the core and see what's going on
09:02:48 <tromp> i was hoping that the core experts might do that:)
09:07:07 <musasabi> tromp: Data.Bits shift is not the same thing as a hardware shift.
09:07:32 <musasabi> uncheckedShift{L,R}64# is more like it..
09:07:42 <tromp> what's it checking for?
09:07:59 <musasabi> and even that is not inlined but a separate C call...
09:08:22 <musasabi> tromp: to have well defined semantics if the shift count is larger than the width of the field.
09:08:27 <tromp> do they call C for the 32 bit versions?
09:09:08 <tromp> i think the hardware semantics is what you want
09:09:32 <musasabi> tromp: 64bit shiftL => 2 comparisons + 2-4 jumps + C call + shift.
09:10:21 <tromp> so noway to generate an inlined shift from haskell?
09:12:08 <tromp> does this overhead show up in the Core output
09:12:21 <musasabi> tromp: I don't think so, no-one has really needed it (one can trivially do an inner loop in the C-land) and bit operations have never been optimized.
09:13:42 <tromp> i cannot advertize this as a haskell benchmark if it links to a C library:(
09:14:45 <tromp> what about 64-bit arithmetic. does that also have so much overhead?
09:14:55 <tromp> say, the + on Word64
09:18:37 <musasabi> (W64# x#) + (W64# y#)  = W64# (int64ToWord64# (word64ToInt64# x# `plusInt64#` word64ToInt64# y#))
09:19:26 <nlv11757_> can i define a Show instance of a type definition? so Type Token = (Lex, Int) and in that case "instance Show Token where"
09:20:05 <tromp>  sure, why not?
09:20:33 <Igloo> No (assuming you mean type, not Type)
09:20:53 * Igloo remembers why I cared about shifting - I defined
09:20:56 <Igloo> shiftL, shiftR :: Word32 -> Int -> Word32
09:20:56 <Igloo> shiftL (W32# a) (I# b) = W32# (uncheckedShiftL# a b)
09:20:56 <Igloo> shiftR (W32# a) (I# b) = W32# (uncheckedShiftRL# a b)
09:21:15 <Igloo> So something similar for 64bits should work for you
09:22:00 <nlv11757_> i mean type sry
09:22:14 <nlv11757_> is it because Haskell actually inlines those types?
09:22:20 <nlv11757_> or because of other reasons?
09:22:20 <Igloo> It's just another name for the same type, so it uses the Show instance of the type it is a synonym of
09:22:42 <Igloo> You can use newtype Token = Token (Lex, Int) if you want to be able to give your own instance
09:22:56 <nlv11757_> i know, but i dont want that constructor attached
09:23:06 <Igloo> Although personally I don't like non-derived Show instances, so I'd advocate ppr (for prettyprint) or something instead
09:23:29 <nlv11757_> yeah i will write a pp instead, but i thought maybe i can fit it in
09:23:32 <nlv11757_> thanx
09:26:51 * CosmicRay really needs to get megamonad back.
09:27:23 <SyntaxNinja> we miss him when he's gone
09:27:25 <Igloo> Sorry, are we drowning the channel in intelligent Haskell-related talk?
09:27:45 <CosmicRay> Igloo: heh, no it's just boring in here sometimes when everybody is afk :-)
09:28:01 <CosmicRay> I think I need to retrain megahal with a smaller corpus
09:28:08 <CosmicRay> there seems to be a limit of about 170MB to the brain file size
09:28:18 <CosmicRay> which corresponds to about 512MB of RAM consumed
09:28:20 <SyntaxNinja> yay! I have a little module to combine quickcheck and hunit tests in one list and mix and match them :)
09:28:28 <CosmicRay> ooo
09:28:34 <Igloo> Nifty
09:28:42 <SyntaxNinja> should I slap it up somewhere?
09:28:59 <Igloo> But where does it go in the hierarchial namespace?  :-)
09:30:15 <SyntaxNinja> OHNO
09:31:02 <SyntaxNinja> http://www.syntaxpolice.org/tmp/Test/TestFramework.hs
09:31:05 <Igloo> Oh, that reminds me, I can actually test my cabalisation tonight
09:33:29 <SyntaxNinja> yay cabal
09:33:38 <SyntaxNinja> I'm working on a new hugs package.
09:33:45 <SyntaxNinja> it's almost done
09:33:52 <Igloo> DYM cabalising hugs?
09:34:07 <Igloo> Or packaging a CVS snapshot?
09:34:44 * Igloo hopes to have ghc 6.4 pre debs shortly after a new snapshot appears
09:35:37 <SyntaxNinja> ross is/has released a Unix-only version of Hugs-Feb-05
09:36:05 <Igloo> Ah, cool
09:36:13 <SyntaxNinja> and I'm packaging that, but a number of random things are different about the build system, and I seem to get different results between builds :(
09:36:29 <SyntaxNinja> like the first package didn't have any libraries, then I didn't change anything and rebuilt, and the new package did have the libraries
09:36:42 <SyntaxNinja> I think it has something to do w/ the generation of the Makefiles during the configure step
09:37:26 <Igloo> It could be a list of directories to recurse doesn't get built early enough or something
09:38:49 <SyntaxNinja> yeah, I still haven't really figured out how he builds the libraries
10:13:44 <SyntaxNinja> I still can't get over the fact that there's no good way to compile mutually recursive modules w/ ghc
10:13:49 <SyntaxNinja> and I've never noticed this before
10:29:55 <Igloo> It's a bit nicer in 6.4
10:30:07 <Igloo> But still not ideal
10:31:50 <Heffalump> how is it nicer?
10:32:39 <Igloo> The boot files are checked for consistency with the real source
10:33:12 <Igloo> And I think it's also been rejigged slightly to make Makefile deps easier, but I might be misremembering that
10:35:42 <metaperl_> is there something in Haskell that allows one to take a generated string and form an expression? e.g. str = "5 + 5"; string_eval str
10:36:31 <Igloo> No
10:36:31 <nnunley> metaperl_: parsec, no?
10:36:32 <tromp> not in standard libs
10:36:38 <metaperl_> I think it is poor form to test my programs by using two-tuples where fst tuple == name of function and snd tuple == function
10:36:47 <metaperl_> per this thread on haskell-cafe: http://news.gmane.org/gmane.comp.lang.haskell.cafe
10:37:08 <metaperl_> parsec is a parser nnunley
10:38:29 <lisppaste2> metaperl pasted "my testing function --- the function comes out as (->) instead of its name" at http://paste.lisp.org/display/6260
10:38:50 <earthy> metaperl: you want to look into template haskell
10:39:22 <metaperl_> oh
10:39:27 <metaperl_> now i'm quaking in my boots
10:39:40 <metaperl_> me? a beginner? template haskell?
10:39:43 <earthy> yeah
10:39:47 <metaperl_> well, I will go take a gander
10:39:48 <earthy> you seem to want introspection
10:40:02 <metaperl_> "meta" === above
10:40:08 <metaperl_> as in meta-perl
10:40:09 <metaperl_> :)
10:40:10 <earthy> :)
10:40:12 <metaperl_> meta-knowledge
10:40:15 <metaperl_> lol
10:40:18 * earthy knows about meta
10:40:26 <MegaMonad> Shapr: howdy. Yeah i'm getting the same time :-) a web page :) i know how to upgrade and it looks like it but couldn't use it. But you really need some more pictures up.
10:40:42 <SyntaxNinja> yay
10:40:48 <pesco> Hi MegaMonad!
10:40:58 <CosmicRay> MegaMonad: Welcome back!
10:40:58 <earthy> anyway, time for food
10:40:59 <MegaMonad> CosmicRay: Well, i would have to be most welcome.
10:41:19 <CosmicRay> MegaMonad: I hope you don't crash so often anymore.
10:41:20 <MegaMonad> CosmicRay: Darcs pull seems to crash when i use it in anymore.
10:41:22 <pesco> MegaMonad: How's code?
10:41:23 <MegaMonad> pesco: What does your code needs to return what i could code a lot more profanity in the school kids anymore so we can partition code freely?
10:41:29 <earthy> uh oh. ;)
10:41:45 <CosmicRay> MegaMonad: yup, looks like you're back to your old self again.
10:41:46 <MegaMonad> CosmicRay: Ah, it's in my old self.
10:41:46 <pesco> MegaMonad: Yeah, let's partition some code in school.
10:41:47 <MegaMonad> pesco: If i want to send something back in school and have a partition (fat32), which is good news is you use some sort of code?
10:42:13 <CosmicRay> MegaMonad: do you remember the answer to life, the universe, and everything?
10:42:14 <MegaMonad> CosmicRay: Wouldn't vstudio have its structure, and have embedded lua into software of the life of the universe, and i understand this span cut.
10:42:14 <earthy> megamonad: could you explain template haskell to metaperl?
10:42:15 <MegaMonad> earthy: And you want me to take haskell to metaperl?
10:42:24 * earthy laughs
10:42:34 <CosmicRay> MegaMonad: perl?
10:42:34 <pesco> MegaMonad: Of course, you just dump the FAT to an aux tape drive and pass it to your friends under the table so the teacher won't notice!
10:42:34 <earthy> well, dinnertime. :P
10:42:35 <MegaMonad> CosmicRay: The haskell site says edison (part of graphviz), but i think darcs has a 2d array you probably want the first place, but i would go all the lines of perl or python, i know you could claim that none of the channel? What sort of gross.
10:42:36 <MegaMonad> pesco: Well that becomes a buffer with ropes, and the dump the fat of the thompson's book. It asks to define a view of that nice dutch girl who cant go to the buffer parse with a reference on laziness and strictness is applied in the drive for the buffer?
10:42:58 <CosmicRay> haha
10:43:02 <pesco> lol
10:43:08 <pesco> You're a riot, Monad.
10:43:10 <CosmicRay> "It asks to define a view of that nice dutch girl"
10:43:33 <CosmicRay> MegaMonad: do you still think java sucks?
10:43:34 <MegaMonad> CosmicRay: It sucks that i upload the code, tremendously improving speed and smooth the flow be the one in his code, several other people don't like java.
10:43:47 <pesco> That's true.
10:43:47 <CosmicRay> MegaMonad: what about perl?  does perl suck?
10:43:49 <MegaMonad> CosmicRay: Beyond that, it's gone from suck to be a little whlie, i seem to suck in the haskell-mode 1.45 fixes "this --bug.
10:44:03 <CosmicRay> MegaMonad: that made sense.
10:44:03 <MegaMonad> CosmicRay: Thehunter: yes, that ought to mention the contest, since no impartial person has spoken recently on any finnish channels.
10:44:21 <pesco> impartial person?
10:44:32 <CosmicRay> who knows where he got that from
10:44:41 <CosmicRay> MegaMonad: are you impartial?
10:44:41 <MegaMonad> CosmicRay: Not to mention the contest, since no impartial person has more argument is that i can get a taste of what's missing, maybe i think i can find it ?
10:44:54 <pesco> I think he is.
10:45:00 <CosmicRay> heh
10:45:10 <CosmicRay> MegaMonad: do you like unicycling?
10:45:11 <MegaMonad> CosmicRay: I know c, java, perl, python, smalltalk (via squeak), r and a programmer and i can't think of unicycling.
10:45:17 <zamez> hehe
10:45:39 <CosmicRay> MegaMonad: unicycling isn't a programming language, silly.
10:45:40 <MegaMonad> CosmicRay: (Might not make sense in a language is just silly.
10:46:16 <CosmicRay> MegaMonad: why do you hate java?
10:46:17 <MegaMonad> CosmicRay: I love people who wrote preludeexts code into a dfa or some pdf for the file to the java vm.
10:46:36 <CosmicRay> hmm.
10:46:38 <pesco> MegaMonad: But what about HATE?
10:46:39 <MegaMonad> pesco: Pseudonym used to love xemacs, but emacs.
10:46:44 <CosmicRay> that is interesting
10:46:45 <pesco> aaaarh.
10:46:57 <CosmicRay> it seems to associate hate with love.
10:47:01 <CosmicRay> MegaMonad: are you confused about love and hate?
10:47:02 <MegaMonad> CosmicRay: I love that sort of sprints do you hate hugs.
10:47:21 <CosmicRay> MegaMonad: we all hate hugs, but it's still a lot better than java.
10:47:22 <MegaMonad> CosmicRay: Hugs is a java fibonacci generator.
10:47:27 <CosmicRay> lol
10:47:30 <pesco> MegaMonad: Maybe you need some hugs yourself.
10:47:31 <MegaMonad> pesco: Oh god.. Marvin.. That nick always makes me think i need all the technology needed to build hugs...
10:47:43 <zamez> is MegaMonad functional?
10:47:57 <CosmicRay> zamez: sometimes :-)
10:47:58 <ibid> MegaMonad: do you know maxwell smart?
10:47:59 <MegaMonad> ibid: A really smart to me, but i'm concerned that you know maxwell smart?
10:48:01 <pesco> MegaMonad: Good, Marvin has been desperate for hugs.
10:48:02 <MegaMonad> pesco: So hugs is the type rules for type values had not taken out the competition. I like arch too, but they must be desperate.
10:48:08 <CosmicRay> zamez: actually it is running megahal.  megahal.alioth.debian.org
10:48:12 <CosmicRay> zamez: megahal is written in C
10:48:14 <ibid> MegaMonad: concerned, why? i'm watching the show currently :)
10:48:16 <MegaMonad> ibid: You know you're a good idea. But after watching the show currently.
10:48:17 <CosmicRay> zamez: rather inscrutable C at that.
10:48:22 <zamez> ok
10:48:27 <ibid> MegaMonad: and what i am before?
10:48:28 <MegaMonad> ibid: Either by special markers ({{{ between these in jed }}}) or by hiding whole functions in haskell when i had my haskell experience anywhere isn't monstrous.
10:48:40 <zamez> was wondering if he'd always give the same answer to the same question :>
10:48:50 <CosmicRay> zamez: no
10:49:15 <CosmicRay> zamez: it has an algorithm that randomly selects phrases for a certain amount of time, then after that amount of time has expired, uses the one that is determined to be most relevant
10:49:20 <CosmicRay> I believe.
10:50:00 <CosmicRay> MegaMonad: I hope you still have your healthy disklike of lisp, too.
10:50:01 <MegaMonad> CosmicRay: Lisp is not a healthy way of supporting everything the unix module.
10:50:05 <CosmicRay> heh
10:50:09 <CosmicRay> MegaMonad: excellent.
10:50:10 <MegaMonad> CosmicRay: Actually, the veining is pink in pink marble, and the editor core that is 'fast enough' because it means, that b and c are disjoint.  Thus a is an excellent tree type.
10:50:32 <CosmicRay> MegaMonad: have you seen TMR yet?
10:50:33 <MegaMonad> CosmicRay: I always get my bass out and send me the class tmr~!
10:50:42 <mflux> I guess someone could totally make some money by teaching megamonad to talk dirty
10:50:50 <CosmicRay> heh
10:51:56 <CosmicRay> MegaMonad: I am impressed.  You are using only 283MB of RAM today.
10:51:57 <MegaMonad> CosmicRay: To me that's the interface i've thought up (which has only 128mb or ram.
10:52:15 <CosmicRay> MegaMonad: you thought up your own interface?  that's way cool.
10:52:16 <MegaMonad> CosmicRay: Bourbaki, ow, it's not working for over 4 hours 1 minute 45 seconds to load the haskell interface to my python code in haskell. Cool.
10:52:44 <CosmicRay> MegaMonad: what do you know of pesco?
10:52:45 <MegaMonad> CosmicRay: Pesco, i can't wait for you when you're using hugs, calling "main" only gives me an example of where "this is too simple for me.
10:53:06 <CosmicRay> MegaMonad: you do seem to have a fixation on hugs these days.
10:53:07 <MegaMonad> CosmicRay: Ghc and me have a fixation on hugs for some arbitrary definition.
10:53:23 <CosmicRay> MegaMonad: so you're old pals with ghc too?
10:53:24 <MegaMonad> CosmicRay: Kosmikus2: ok so you're old pals with ghc if you alter it, you really got it, and i'm an emacs keymap.
10:53:40 <CosmicRay> MegaMonad: It must be surreal to be an emacs keymap.
10:53:41 <MegaMonad> CosmicRay: Either as a reference to the next keymap to the emacs keymap for yi yet.
10:54:18 <CosmicRay> heh
10:55:07 <earthy> he is right thogh
10:55:28 <earthy> u
10:55:30 <earthy> ++
11:34:30 <CosmicRay> quiet in here today.
11:34:33 <CosmicRay> MegaMonad: it is too quiet today.
11:34:35 <MegaMonad> CosmicRay: Awfully quiet here :s.
11:34:40 <CosmicRay> MegaMonad: yes it is.
11:34:41 <MegaMonad> CosmicRay: No, i haven't.  Actually, i'm being fairly pragmatic.
11:35:03 <CosmicRay> MegaMonad: sprechen sie deutsch?
11:35:04 <MegaMonad> CosmicRay: Shapr, ich auch verstehe deutsch.
11:35:14 <CosmicRay> MegaMonad: ahh, sehr gut.
11:35:15 <MegaMonad> CosmicRay: I'm going to gut the data constructor then.
11:35:19 <CosmicRay> heh
11:36:34 <Igloo> Quick! CosmicRay is bored! Someone assign him a piece of cabal to hack on!
11:37:28 <CosmicRay> heh
11:37:28 <Igloo> (can't blame a bug for trying...  :-)  )
11:37:31 <CosmicRay> hehe
11:40:01 <PerlJam> CosmicRay: You can track down the recusion bug in pugs if you're bored.
11:40:12 <CosmicRay> heh
11:40:37 <CosmicRay> not bored so much as hating writing webapps
11:40:46 <CosmicRay> only been working on it for 2 weeks and its halfway done
11:40:47 <CosmicRay> but still
11:40:51 <CosmicRay> hate writing webapps :-)
11:40:56 <Igloo> :-)
11:44:43 <PerlJam> In haskell?
11:44:49 <CosmicRay> even in haskell.
11:44:55 <CosmicRay> though it is less distasteful
11:45:02 <PerlJam> Sounds like you need a new job :)
11:45:25 <CosmicRay> I really only have to do this about once a year so I'm just waiting for april to arrive :-)
11:46:08 <PerlJam> At the point of doing it twice I'd write a framework or AI or something that'll do it for me ;-)
11:46:17 <Igloo> Your employer lets you use Haskell? Are they looking for new telecommuters?  :-)
11:46:42 <CosmicRay> Igloo: probably not, unfortunately :-)
11:46:50 <CosmicRay> Igloo: they let me use whatever I like if it does the job well.
11:47:31 <CosmicRay> Igloo: this webapp is probably going to save them the need to take on 15 temps this summer... so haskell is good :-)
11:50:45 <Igloo> Not for the temps  :-)
11:51:16 <CosmicRay> Igloo: they'd be doing mind-numbing work (openening envelopes and keying in data from standardized forms) anyway.  they will probably appreciate getting work elsewhere too :-)
11:51:55 <Igloo> heh
11:57:53 <pesco> Great. xterm crashes when scrolled.
11:59:07 <CosmicRay> MegaMonad: pesco needs to be scrolled.
11:59:08 <MegaMonad> CosmicRay: Needs to be scrolled.
11:59:15 <CosmicRay> MegaMonad: that was boring.
11:59:16 <MegaMonad> CosmicRay: Tuomov; this sounds boring.
12:06:41 <Oejet> Wow, it's hard to get on Freenode this evening.
12:07:33 <CosmicRay> really?
12:07:40 * CosmicRay again advocates moving this channel to OFTC
12:08:18 <Oejet> I tried connecting for the last couple of hours, but the connection kept timing out.
12:08:38 <CosmicRay> have you tried different servers?
12:08:42 <pesco> What is OFTC?
12:09:20 <CosmicRay> pesco: www.oftc.net
12:09:52 <CosmicRay> pesco: basically it was created to be similar in spirit to freenode but with a more republican management structure, instead of the insane dictator style of freenode :-)
12:10:15 <pesco> Cool, freenode is in insane dictator style?!
12:10:41 <CosmicRay> oh yes.  there are major flamewars, etc. about every 6 months.
12:10:49 <pesco> Wow.
12:10:57 * pesco gets some nachos.
12:11:00 <Oejet> I use Gaim, and I just gave it the address irc.freenode.net.
12:11:11 <CosmicRay> lilo gets pissed at some server op for saying something mean about freenode, or lilo, or whatever, so he bans the guy's servers, and several other server ops quit in protest, etc.
12:11:20 <CosmicRay> Oejet: try other servers too
12:11:42 <CosmicRay> oftc was started by server ops that were banned from freenode for insane reasons
12:11:50 <pesco> Oejet: That should put you on the round-robin, I think.
12:11:56 <Philippa> OFTC happened after lilo juped an entire chan because people were saying nasty things about him demanding contributions regularly while threatening to shut the network down
12:12:18 <Philippa> amongst other things - but the #brits incident was significant for a lot of folks
12:12:41 <CosmicRay> yeah there was a time when lilo would send out a globalnotice about every 2 hours seeking donations
12:13:03 <CosmicRay> even now the freenode nonprofit, PDPC, does little more that pay for lilo's apartment.
12:13:07 <Philippa> "Help! My life's falling apart so I'm going to extort from the network!"
12:13:18 <CosmicRay> yeah, that's basically what happened
12:13:31 <CosmicRay> he got laid off for spending too much time IRCing at work
12:13:45 <CosmicRay> so he started PDPC to raise funds "for freenode" at about that time
12:13:55 <pesco> guh
12:14:29 <CosmicRay> AFAICT, oftc has never received nor spent any money
12:14:52 <CosmicRay> http://freenode.net/fundraiser.shtml is enlightening
12:15:01 <CosmicRay> whenever you see "staffer salary", read "lilo"
12:15:33 <CosmicRay> also there is a $2000 travel budget, a $2200 book/phone/printing budget, and a $750 course/certification budget.
12:15:41 <Igloo> #darcs recently decided not to move as FN is still the default place to look for a random channel
12:15:59 <CosmicRay> you can see why the fundraisers aren't exactly the most successful around here.
12:16:06 <CosmicRay> #palmchat moved about 3 years ago
12:16:15 <Itkovian> at least they're open about what they do with the money eh
12:16:18 <CosmicRay> they left a /topic and a person or two on freenode for a month
12:16:30 <CosmicRay> after that, it wasn't really a problem
12:16:55 <CosmicRay> in typical Debian style, #debian-devel didn't move.  It just now exists both places.
12:17:23 <Igloo> Yeah. I'll refuse to be in both if that happens to #haskell
12:17:34 <CosmicRay> yeah, that is the Wrong Way to do it.
12:17:37 <Igloo> I'd probably follow a core majority to OFTC if it happened, though
12:18:03 <CosmicRay> I maintan connections to both networks in my irc client, so it's not a big deal of convenience for me
12:18:06 <pesco> If the topic says "move", I'll move.
12:18:13 <pesco> Right.
12:18:27 <pesco> Just like an HTTP redirect or whatever of that sort.
12:18:33 <Philippa> I'd follow to OFTC no problem, it'd mean I spent more time on #nott too
12:19:08 <CosmicRay> -ChanServ-      Channel: #haskell
12:19:08 <CosmicRay> -ChanServ-      Contact: shapr, last seen: 1 day (11h 0m 51s) ago
12:19:08 <CosmicRay> -ChanServ-    Alternate: Igloo << ONLINE >>
12:19:23 <CosmicRay> looks like shapr and igloo are people to talk to about it
12:19:31 <Igloo> Oh, I hadn't realised you were a #nott person. Or in the UK for that matter
12:19:49 <CosmicRay> #nott == nottingham?
12:19:53 <Igloo> Yup
12:20:05 <Philippa> I've been in nottnum for something like five years now
12:25:42 <Philippa> similarly, you're an earthling?
12:25:55 <Igloo> yup
12:26:39 <CosmicRay> so anyway, to me the main benefits of oftc are ethics.  1) no attempting to raise money from users, and 2) oftc has a constitution that limits powers, and is a member of SPI, which is duty-bound to enforce the constitution
12:27:24 * Philippa nods
12:28:08 <Philippa> the latter is very, very much a Good Thing if you ever talk about anything genuinely private over IRC. Smaller networks I've been on have had major incidents where a (now ex-)ircop messed with logs for blackmail purposes
12:28:09 <CosmicRay> and I would say that even if I wasn't on SPI's board :-)
12:31:19 <CosmicRay> that could majorly suck.
12:31:46 * Igloo looks at the channel list and wonders when half the channel last spoke
12:32:35 <Philippa> heh
12:32:41 <Philippa> this isn't a bad chan to lurk, in fairness
12:32:49 <CosmicRay> yeah
12:33:08 <CosmicRay> you might learn about ffi one minute, laugh at megamonad the next, and wind up being inspired to take up unicycling.
12:33:40 <Igloo> Oh, I wasn't complaining about lurking, it just makes asking contributors their opinions individually a more time consuming task than I have time for right now  :-)
12:35:07 <musasabi> isn't all private chat in irc with dcc chat and encryption plugins?
12:35:17 <CosmicRay> no
12:35:21 <CosmicRay> you can /msg someone
12:35:25 <CosmicRay> still goes through the servers
12:35:41 <musasabi> CosmicRay: true, but that is not very private.
12:35:45 <CosmicRay> right
12:35:51 <CosmicRay> people do it anyway
12:36:05 <Philippa> it's "private" in the sense of not being addressed to more than one person
12:36:18 * pesco mumbles something about silc.
12:36:27 <Philippa> even the command for it's PRIVMSG, though that goes for sending to chans too
12:36:42 * musasabi does not really think anything not encrypted will stay private for long.
12:37:22 <Philippa> short of somebody eavesdropping one of the lines involved I've generally got a good bet on lspace IRC
12:38:04 <musasabi> here we have a giant campus lan as the first hop...
12:38:43 <musasabi> but that does not really apply to irc as I have ssh till the university server.
12:38:53 <Igloo> Of course, you never know who'll see it on the screen at the other end anyway
12:40:37 <pesco> OK, I'm starting an off-topic poll. Apart from xterm, rxvt, and urxvt, which X Terminal emulator do you use?
12:40:41 <Philippa> which means carl knows a few things I've told susie and vice versa, yeah
12:40:44 <CosmicRay> konsole
12:40:57 <Igloo> uxterm
12:41:05 * Igloo cheats slightly
12:41:14 <pesco> Grmbl.
12:41:15 <CosmicRay> Igloo: typical :-)
12:41:35 <Igloo> It seems an odd question, anyway
12:41:49 <pesco> Why?
12:42:20 <Igloo> Well, if you don't want to use one of those 3 then presumably there's some particular functionality you want?
12:42:30 <CosmicRay> >>one thing to note. any channel that moves, lilo shuts down, takes over, and locks up for at least a week
12:42:42 <CosmicRay> >>so that noone can find out the new location
12:42:50 <Philippa> oh fun
12:43:04 <Igloo> Being blackmailed to stay shouldn't be considered IMO
12:43:04 <CosmicRay> I don't recall that happening to #palmchat though
12:44:09 <pesco> Igloo: I want correct Unicode display (with UTF-8). Strangely, urxvt doesn't do it right, xterm crashes in ion, and vanialla rxvt doesn't seem to know about Unicode either.
12:44:24 <musasabi> looked at oftc - seems to have few channels with the size of #haskell..
12:47:30 <CosmicRay> in terms of users, there are about three, although there are several that qre quite a bit more active than #haskell
12:48:24 <musasabi> pesco: I used uxterm for unicode without problems.
12:48:31 <Philippa> yeah, #haskell has actual lulls still
12:49:06 <CosmicRay> if it weren't for debian, haskell would probably be almost at the top in freenode too
12:49:10 <pesco> musasabi: Me too, on Linux. Now on Mac OS it seems dumb-struck.
12:49:23 <CosmicRay> debian is still at freenode for complicated political reasons involving people that are both debian developers and freenode netops
12:51:18 <CosmicRay> interesting, ibid already registered oftc #haskell
12:51:21 <musasabi> #c is quite large too..
12:52:02 <CosmicRay> -ChanServ-         Founder: ibid (~ajk@kukkaruukku.keltti.jyu.fi)
12:52:03 <CosmicRay> -ChanServ-     Description: Haskell discussions
12:52:03 <CosmicRay> -ChanServ-      Registered: Jan 07 17:50:39 2003 UTC (2 years, 1 month, 3 weeks, 5 days, 03:02:03 ago)
12:52:03 <CosmicRay> -ChanServ-       Last used: Nov 16 11:39:55 2004 UTC (3 months, 2 weeks, 3 days, 09:12:47 ago)
12:52:24 <ibid> CosmicRay: as i told you on tuesday, iirc :)
12:53:00 <ibid> i created it a long time ago, but nobody ever showed up
12:53:07 <CosmicRay> ibid: really?
12:53:07 <ibid> even though i mentioned it here a few times
12:53:10 <CosmicRay> I must have a very small stack
12:53:14 <Igloo> ISTR we had a failed move attempt at lilo's peak
12:53:34 <ibid> CosmicRay: just after spi meeting, we chatted about haskell :)
12:53:52 <ibid> i think i mentioned the channel then
12:53:54 * boegel bounces
12:54:02 <boegel> ibid: created what ?
12:54:19 <Oejet> What's this haskell@conferences.jabber.org anyway?
12:54:19 <CosmicRay> I remember the chat but not the channel.  not saying that you didn't mention it, just that my memory sucks.
12:54:22 <CosmicRay> (truly, it does)
12:54:37 <ibid> boegel: #haskell @ OFTC, as CosmicRay mentioned a few lines up
12:55:50 <boegel> what's OFTC ?
12:56:12 <ibid> another irc network
12:56:18 <ibid> an old fork of freenode
12:56:32 <boegel> oh, okay
12:56:40 <boegel> but there's no activity on it ?
12:56:45 <Philippa> from a time when freenode was a bit forked itself
12:56:55 <Philippa> I wouldn't say none - but not as much as freenode
12:56:56 <ibid> http://www.oftc.net/
12:57:11 <CosmicRay> oftc has quite a bit of activity, but is not as large as freenode
12:57:14 <ibid> boegel: there is quite a bit activity, but not in #haskell there :)
12:57:24 <boegel> the problem with irc is there's no real 'center' channel for anything
12:57:34 <CosmicRay> just like the internet, boegel :-)
12:58:10 <ibid> "center" channel?
12:58:14 <ibid> hmm
12:58:23 <boegel> CosmicRay: bah, that's not true... there's haskell.org
12:58:47 <boegel> @seen shapr
12:58:48 <lambdabot> I saw shapr leaving #webwitches 1 day 5 hours 15 minutes 28 seconds ago
12:58:48 * ibid is writing yet another p2p-based irc for a course here :)
12:58:54 <CosmicRay> boegel: but everybody knows that it's not maintained anymore, so we go elsewhere :-)
12:59:02 <boegel> heh, he's away again... when he's again it's always long :)
12:59:12 <boegel> CosmicRay: why not ? that's a shame
12:59:24 <CosmicRay> boegel: I don't recall.  lack of time on the part of the maintainer maybe?
12:59:32 <CosmicRay> it's particularly annoying in the libraries section
12:59:45 <CosmicRay> there is no good haskell library collection
12:59:50 <CosmicRay> freshmeat is the closest ther eis, I guess
13:00:00 <Philippa> Somebody start maintaining a list on the wiki?
13:00:10 <Igloo> But that's just waiting for hackage+cabal to be complete, no?
13:00:11 <CosmicRay> there is a list there
13:00:24 <CosmicRay> Igloo: I dunno, it would seem that we could keep up the html page in the meantime
13:00:25 <Igloo> And I think haskell.org is maintained, just not /actively/ developed
13:00:42 <CosmicRay> Igloo: I just recall a thread on cafe about the libraries page not being maintained
13:00:48 <CosmicRay> but I guess I could be wrong again
13:00:58 <CosmicRay> experience shows it doesn't have much newer than 2003 there
13:00:59 <boegel> but hey, there's no real center place for c/c++ either :p
13:01:11 <CosmicRay> boegel: berkeley, 1965. :-)
13:01:24 <CosmicRay> boegel: alternatively, AT&T, 1963 :-)
13:01:27 <Igloo> Last I heard the two guys were applying stuff they were sent fine, but little was being sent to them
13:01:36 <CosmicRay> ah.
13:01:42 <CosmicRay> perhaps I should send them some stuff then.
13:03:37 <boegel> CosmicRay: you got me there :p I always get stuck when looking for info on c/c++ when I need to do stuff for uni
13:03:43 <musasabi> There is a libraries list in the wiki.
13:04:24 <boegel> I mean for basic stuff
13:04:25 <musasabi> @wiki LibrariesAndTools
13:04:25 <lambdabot> http://www.haskell.org/hawiki/LibrariesAndTools
13:04:38 <boegel> oh, you were talking about Haskell, sorry :)
13:05:13 <boegel> hey dev9
13:09:46 <kzm> God kveld!
13:18:23 <Oejet> Why did people stop talking?
13:18:38 <boegel> Oejet: because you came in ! mwoehahaha
13:18:44 <boegel> *sorry
13:18:45 <Oejet> Heh.
13:19:15 * pesco waves sadly after cptchaos.
13:20:00 <Oejet> I wouldn't want all 130 people in the room writing "/me looks at Ojet".
13:20:40 * boegel wonders how many people have read the full TMR
13:21:18 <Oejet> boegel: Wouldn't it be enough if SPJ read it?
13:21:38 <boegel> I don't know, who's SPJ?
13:22:06 <Oejet> boegel: GHC Mastermind.
13:22:27 <boegel> Simon Peyton Jones ?
13:22:32 <gzl> yes
13:22:34 <gzl> peyton jones
13:22:39 <Oejet> boegel: Oh, yes.
13:22:44 <boegel> I've have heard about him
13:22:49 <gzl> he's a bigwig :)
13:22:53 <boegel> is he the guy who walks around barefoot ?
13:23:42 <Oejet> I've only heard of a guy called Henning Makholm do that.
13:23:58 <gzl> i know a guy totally unrelated to haskell who does that.
13:24:33 * boegel knows such one too
13:24:47 <boegel> (was that correct English ?)
13:25:04 <gzl> almost. you could drop the 'such'
13:25:36 <rtega> damn, karczmarczuk's papers ain't that specific
13:27:38 <rtega> but damn interesting non the less ;)
13:29:57 * boegel likes spheres :)
13:39:53 * boegel yawns
13:44:51 <Oejet> Good night everyone.  Tomorrow http://linuxforum.dk/2005/ time!
13:45:02 <boegel> bye Oejet
13:45:09 <Oejet> *tomorrow is
13:45:29 <Oejet> Good bye boegel.
14:04:26 <Igloo> SyntaxNinja: The cabal usersguide should say what valid values for "tested-with" are
14:09:34 <Igloo> SyntaxNinja: And it seems to be installing a bin/ directory for no reason
14:16:01 * tmoertel noticed the bin/ directory, too, when testing cabal2rpm
14:21:22 <SyntaxNinja> Igloo: when does it install a bin? always?
14:21:28 <SyntaxNinja> or just for cabal itself?
14:27:47 <Igloo> For my cabal package
14:28:02 <Igloo> Do you want a copy of it?
14:31:39 <CosmicRay> MegaMonad: i like gopher.
14:31:40 <MegaMonad> CosmicRay: I work for you. You need gopher!
14:32:01 <SyntaxNinja> Igloo: I wonder if it just always does that
14:32:44 <SyntaxNinja> MegaMonad: I want a mapFMM for monadic map
14:32:44 <MegaMonad> SyntaxNinja: You want a mapfmm for monadic code.
14:32:55 <SyntaxNinja> MegaMonad: yeah, that's what I said
14:32:55 <MegaMonad> SyntaxNinja: Yeah..i noticed you need this program.
14:33:06 <SyntaxNinja> MegaMonad: gee, thanks. you're so helpful
14:33:07 <MegaMonad> SyntaxNinja: Though dons recent accomplishments should keep track of where i'm supposed to be some easier way just using network.http as a parent of that function would be helpful.
14:36:11 <SyntaxNinja> MegaMonad: welcome back
14:36:12 <MegaMonad> SyntaxNinja: Cptchaos: welcome to the abstractness of types.
14:37:48 <Igloo> SyntaxNinja: How am I meant to make a cabal package these days? Just tar up foo-version into foo-version.tar.gz?
14:37:48 <musasabi> SyntaxNinja: wouldn't a two-level typed map be best for that?
14:39:00 <SyntaxNinja> Igloo: yeah
14:39:18 <SyntaxNinja> musasabi: I don't know what you mean.
14:40:29 <SyntaxNinja> you mean fmToList ... mapM ... listToFM?
14:41:16 <musasabi> SyntaxNinja: no, making trees which are parametrized by the types of nodes they have.
14:42:24 <musasabi> SyntaxNinja: like InderectComposite in the wiki (JFP had a quite good article on this)
14:42:48 <SyntaxNinja> musasabi: link?
14:45:10 <CosmicRay> ok, so I want to implement a megahal-like creature in haskell
14:45:17 <CosmicRay> because the C one sucks and gobbles up all my ram.
14:45:26 <CosmicRay> the C code is also nasty and horribly spaghetti-like
14:45:33 <CosmicRay> and has known core dump conditions anyway.
14:45:36 <musasabi> www.cse.ogi.edu/~pasalic/Work/sp.pdf
14:45:39 <CosmicRay> so I find a java implementation of the same algorithm.
14:45:44 <CosmicRay> works well, reasonably nice code
14:45:55 <CosmicRay> but dammit, it's still hard to follow because strings in java suck so badly!
14:45:56 <Igloo> SyntaxNinja: Why do I need to run configure in order to make the haddock docs?
14:46:07 <CosmicRay> it's constantly converting from stringbuffers to strings
14:46:09 <CosmicRay> argh.
14:48:49 <musasabi> Igloo: because the haddock pass needs to know where various tools (haddock,cpphs,...) are.
14:49:15 <Igloo> Hmm, OK. As long as it's not going to do different things depending on which compiler I configure it for...
14:51:03 <jadrian> musasabi: icredible what one can learn by randomly taking a look at what's going on in this channel :)
14:51:09 <jadrian> musasabi: nice stuff
14:51:32 <musasabi> yes, that article was very enlightening.
14:52:15 <jadrian> musasabi: haven't read it yet but seems nic, and I liked the IndirectComposite wiki page too
14:52:23 <jadrian> s/nic/nice
14:54:08 <CosmicRay> MegaMonad: shhh, heffalump is back.
14:54:09 <MegaMonad> CosmicRay: Heffalump doesn't have it.
14:54:23 <CosmicRay> MegaMonad: I know that, but he doesn't yet.
14:54:24 <MegaMonad> CosmicRay: Godaften, lemmih.  Hvordan gr chalmers.
14:54:33 <CosmicRay> re heffalump :-)
14:54:43 <Lemmih> Say what?
14:54:49 <CosmicRay> heh
14:56:25 <jlouis> yay!
14:56:57 * CosmicRay celerates with jlouis
14:57:00 <CosmicRay> err celebrates.
14:57:16 * CosmicRay never thinks to stop to ask what we're celebrating.
14:57:54 <Heffalump> oh, channel move being discussed again.
14:58:14 <CosmicRay> do you have an opinion?
14:58:29 <Heffalump> I'm with Igloo; I'd move if a core of people did. But I did have a try at moving it years ago when things really seemed out of control and it didn't really work.
15:00:57 <SyntaxNinja> Igloo: you need to configure before everything, but that could perhaps be optimized in some cases
15:01:11 <SyntaxNinja> Igloo: I think there's a reason for haddock, I can't remember.
15:01:19 <Igloo> SyntaxNinja: I don't mind as long as I don't get different docs for different implementations
15:01:36 <SyntaxNinja> Igloo: no
15:17:31 <jadrian> off topic question
15:18:01 <jadrian> I've read that nowadays it's common not to use < > in (E)BNF
15:18:38 <jadrian> and to use bold for terminal symbols
15:18:43 <jadrian> is that so?
15:19:05 <kosmikus> Heffalump: what channel move?
15:20:04 <Heffalump> kosmikus: this channel, to OFTC
15:21:18 <kosmikus> because of this new freenode policy that someone complained about on the darcs mailinglist?
15:24:47 <ibid> what new freenode policy?
15:25:04 <jlouis> I was about to ask the same
15:25:15 <ibid> jadrian: everybody uses their own syntax for bnf :)
15:25:42 <wagle> how is the unix "socket" called spelled in haskell (that darcs would use)?
15:27:30 <ibid> blah. bedtime, bbl :)
15:28:00 <jadrian> ibid: I just found this :) http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html
15:28:15 <ibid> jadrian: i have that on hardcopy :)
15:28:19 <ibid> jadrian: and nobody uses it
15:29:15 <ibid> going, going, gone (sleeeep)
15:32:20 <wagle> (i grep for socket or tcp, and find nothing in the darcs source)
15:33:33 <musasabi> wagle: grepping for "Network" might work - however darcs uses external programs like scp for much of the things.
15:33:36 <musasabi> => sleep
15:35:22 <wagle> linux kernel hackers hate waiting 8 hours for darcs to clone a kernel repository..  thought i'd poke at reducing the bottleneck
15:36:53 <Muad_Dibber> does the linux kernel use darcs then? :)
15:37:20 <wagle> not yet
15:37:38 <wagle> who wants to wait 8 hours?
15:38:33 <Muad_Dibber> well, if you have to do it once, it would be a nice time to go sleep in the mainwhile :P
15:41:38 * kosmikus just read the logs (hope I found the relevant ones)
15:41:51 <kosmikus> I don't see any convincing reason for moving the channel
15:42:21 <Muad_Dibber> obviously i missed something again :)
15:44:22 <Igloo> kosmikus: Do you actually prefer it being here?
15:46:34 <kosmikus> I know and like freenode (from a rather agnostic perspective); I don't know if any alternative is acutally better
15:46:52 <kosmikus> I guess I would follow, but I will not lead
15:47:06 <wagle> oranges!
15:47:11 <wagle> no, apples!
15:47:23 * Itkovian goes wherever #haskell goes.
15:47:51 <wagle> what is the problem that needs solving?
15:51:07 <Muad_Dibber> o0o
15:51:18 * Muad_Dibber gets it, they want to move #haskell ;) (doh)
15:52:11 <Heffalump> IMO OFTC is better from a management point of view, but freenode wins because it's larger
15:52:34 <Heffalump> still about 10 times larger, in fact.
15:53:06 <Pirate> hi, can anyone help me with a quick haskell question?
15:53:14 <dons> ask away!
15:53:21 <Muad_Dibber> Heffalump : well so it depends on the goals of #haskell
15:53:24 <kosmikus> Heffalump: but is there a real problem with freenode?
15:53:31 <Muad_Dibber> if you want a closed community then you should move away from freenode
15:53:45 <kosmikus> Heffalump: it certainly has the advantage that #haskell is established on freenode
15:54:02 <Muad_Dibber> but if you want an accessible server, with a lot of users, which is also well known, with lots of connection points to other groups of interest, you should stay here
15:55:28 <wagle> what is the problem with #haskell that needs solving?
15:55:47 <Pirate> ok here goes, im trying to wrtie a function  that takes an expression and prints it out, but, im trying to convert from a bit of sml code i was given and im having problems making it work
15:55:54 <kosmikus> Muad_Dibber: that's maybe rather extreme. It would be interesting to learn if most of the #haskell users came to #haskell because they hung out on freenode anyway, and discovered it by accident, or because they saw information on the internet and were directed here. If the latter, they would find #haskell on another network as well.
15:56:28 <Muad_Dibber> kosmikus : so, if you go to find #haskell, its more like a closed community
15:57:10 <Muad_Dibber> however, there's always the grey ones
15:57:11 <Muad_Dibber> like me
15:57:20 <Muad_Dibber> i'm here because i happen to be on freenode anyway
15:57:29 <Muad_Dibber> but it's usefull to be here, since sometimes i actually do learn stuff
15:57:53 <Muad_Dibber> but if each time i just have to join a new server, only to visit #haskell, it would get annoying, and in the end i would end up not showing anymore
15:57:58 <Muad_Dibber> (which actually might be what you want)
15:58:04 <Heffalump> I think the main problem with freenode is lilo; there's always a risk of him causing trouble as he does in the past. However, the risk of him causing trouble for #haskell is probably small.
15:58:10 <wagle> what is the problem with #haskell that needs solving?
15:58:11 <Heffalump> s/main/only/
15:58:26 <Pirate> right ive posted a better description and the code sample at http://rafb.net/paste/results/UcJAO469.html
15:59:03 <Muad_Dibber> Heffalump : i dont know who lilo is :P
15:59:03 <Pirate> if anyone can figure out how i could do that it would be a great help
15:59:50 <kosmikus> Muad_Dibber: most irc clients can be configured to autojoin multiple networks, I guess
16:00:09 <Muad_Dibber> kosmikus : thats true
16:00:34 <Sonarman> Pirate: try do { newLines 1; printLine blah }
16:00:36 <dons> Pirate: do notation!
16:00:45 <dons> don't even need the { }
16:00:46 <kosmikus> Muad_Dibber: I'm on freenode because of #gentoo-dev, too
16:00:49 <Itkovian> Pirate: do { stmt 1; stmt2 }
16:00:58 <Itkovian> heh
16:01:07 <Muad_Dibber> kosmikus : it's nice to have all nice systems near
16:01:13 <Muad_Dibber> instead of each one having its own server :)
16:01:14 <Itkovian> dons: then why did 3 people suggest using the braces?
16:01:54 <Pirate> ok thanks alot!
16:01:59 <kosmikus> all in all, I've still not seen any real argument against freenode; I mean, the current #haskell experience is quite enjoyable here, or is it not?
16:02:05 <Sonarman> Itkovian: because we're ignorant
16:02:26 <dons> Itkovian: I'm not sure.
16:02:27 <Muad_Dibber> kosmikus : infact i was not arguing against freenode at all either :P
16:03:06 <wagle> ["what is the problem with #haskell that needs solving?" ..]
16:03:17 <kosmikus> Muad_Dibber: I know
16:03:43 <kosmikus> braces make the statement more robust w.r.t. layout
16:03:45 <Muad_Dibber> missed you at the colloquiem today too :)
16:04:02 <kosmikus> Muad_Dibber: why? no interesting questions being asked?
16:04:20 <Muad_Dibber> yeah
16:04:23 <kosmikus> hehe
16:04:34 <kosmikus> what was the talk? swiert?
16:04:38 <Muad_Dibber> to bad swiert isnt online now
16:04:58 <Muad_Dibber> i dont know what the smart people think about it, but it was quite a nice understandable talk
16:05:11 <kosmikus> Muad_Dibber: I'm in .ee until end of March, so I can't participate
16:05:36 <Muad_Dibber> ah didnt know that :)
16:05:51 <Muad_Dibber> (not that you have to tell me anyway ;)
16:06:41 <kosmikus> I'll be at .uu.nl from April to the beginning of June, and then leave to take on a postdoc in Bonn.de
16:07:20 <Muad_Dibber> do they have anything to do with GH? or you up to something new?
16:12:34 <Pirate> another question for u haskell gurus, is it possible to have a Bool value defined as a flag that u can change using an on/off function that can be used to see when to do stuff? if that makes sence
16:13:12 <kosmikus> Muad_Dibber: yes, they have something to do with GH
16:13:15 <wagle> debug = False
16:13:23 <Pirate> the sml code that im trying to convert is val Debug = ref true;
16:13:23 <Pirate> fun Don() = (Debug := true);
16:13:23 <Pirate> fun Doff() = (Debug := false);
16:13:25 <wagle> if debug then ... else ...
16:13:53 <wagle> oh, you want to change it multiple times while running
16:14:11 <Muad_Dibber> :)
16:14:24 <dons> not very politically correct to structure it that way, Pirate.
16:15:22 <wagle> i'm not very familier with the debugging frameworks, one of them might have something
16:16:15 <dons> you can of course use IORefs, or a state monad, but you lose 'purely functional' points
16:16:16 * kosmikus is off to rl
16:16:29 <Pirate> its a pain having to do this, its for uni, our lecturer doesnt do haskell so all his samples are in sml, but we have to submit haskell code
16:16:30 <jlouis> Pirate: simply put. Not possible as easy as you want it
16:17:34 <Muad_Dibber> kosmikus : like we believe that ;)
16:18:01 <dons> debug :: MVar (IORef Bool), for what it's worth -- but don't do this!
16:18:16 <wagle> there is the "implicit parameters" stuff
16:19:54 <Pirate> right so basically its gonna be really hard to do, if not impossible?
16:20:10 <wagle> http://portal.acm.org/citation.cfm?id=325708
16:20:56 <dons> Pirate: to do it exactly the way you want could be done in 4 very evil lines. but you should think of something less evil
16:21:37 <Pirate> right ok
16:22:17 <dons> for example, you could pass the Debug value around instead
16:22:29 <jlouis> Pirate: are you using ghci for this?
16:22:38 <Pirate> im using hugs
16:22:42 <jlouis> bleh
16:23:01 <Muad_Dibber> jay @ hugs
16:23:13 <wagle> there is also the problem of doing what you want when debugging is turned "on"
16:23:49 <wagle> .. like print statements, eetc
16:24:31 <dons> I would think: my_fun :: ... -> DebugState -> ... ; my_fun .. dval = ... when dval $ (..)
16:24:53 <dons> would be the easiest for a new haskeller
16:25:55 <Pirate> ok
16:26:00 <jlouis> I would screw debugging altogether and just do with QuickCheck
16:26:27 <wagle> http://www.haskell.org/libraries/#tracing
16:26:54 <jlouis> that too
16:27:21 <Pirate> its not really for debugging, its ment for printing the data that a function is working with so u can see the flow of the recursion
16:27:28 <jlouis> GHC.Base.assert is also nice. When compiling with the correct flags it is ``commented out''
16:27:40 <jlouis> but it is GHC only
16:28:45 <jlouis> (why the _ghuck_ will the lecturerer not code in Haskell but does SML. (For the meaning of ghuck, the gh has the same sound as in rough)
16:28:57 <Pirate> dont ask me!
16:29:09 <jlouis> give me an e-mail address
16:29:11 <jlouis> ;)
16:30:23 <Pirate> at the moment we have to convert sml code for a lexer,parser,typer,evaluator and exec of the code generated into haskell and addd about 10 functions that his sml version didnt have
16:30:30 <wagle> "fsck"
16:31:21 <Pirate> ive done the simple version which is just 3 operators and single digit ints and bools, but im trying to figure out this 'debugging' bit before i add the other functions
16:32:52 <jlouis> why do you need to be able to turn it off and on in the program?
16:33:03 <jlouis> why not just define:
16:33:09 <jlouis> debug :: Bool
16:33:13 <jlouis> debug = True
16:33:26 <jlouis> and then, where you need it: if debug ...
16:33:52 <dons> or are you writing code that with the right command line flag prints out the AST, for example? i.e. with mycompiler -debug ?
16:33:55 <wagle> jlouis: how do you then get debugging to do something when its enabled?
16:34:38 <jlouis> wagle: like side-effects?
16:35:54 <wagle> yeah..  the trace is the main problem, not the dynamism of the flag
16:36:17 <jlouis> I always debug with assertions
16:36:30 <jlouis> but you are right, it cannot capture tracing
16:37:01 <Pirate> ive just pasted the sml function of the bit of code im trying to convert, along with my effort at it, which works, except its missing the debug bit, if u guys wouldnt mind having a look http://rafb.net/paste/results/4JoSnh30.html
16:39:12 <jlouis> Pirate: your lecturer should learn to write SML code ;)
16:39:19 <Pirate> lol
16:39:30 <Pirate> its copied directly from his lecture notes!
16:39:55 <jlouis> anyway, take the debug flag as a parameter and let the eval function return something of type IO EXPR
16:40:18 <jlouis> * Semicolons are not needed at the end of expressions in SML
16:40:27 <wagle> sml can be translated to java or haskell..  haskell is not all that translatable to other languages
16:40:27 <jlouis> (ICON n) can be simplified to ICON n
16:40:51 <jlouis> mismatch is not bound on the RHS, so it would have been better to use _
16:41:22 <Pirate> right ok
16:41:56 <jlouis> snd is not defined in the top-level, use #2 instead
16:42:29 <jlouis> etc
16:43:34 <jlouis> I code too much SML it seems
16:43:54 <Pirate> basically i think for now i'll leave the debug code stuff and get on with adding the other functions, and if ive got any time left at the end i'll have another go at it
16:44:35 <wagle> Pirate: take a look at the debugging frameworks from the url i listed above
16:45:21 <Pirate> ok i will, thanks
16:45:40 <Muad_Dibber> g'night all :)
16:50:44 <Pirate> right if anyone is really bored please have a look at http://rafb.net/paste/results/daeadC38.html  its aload of code ive done, but there is an error towards the end the function p should give an error when presented with something like "(~ 5" but it doesnt and i cant figure out why
16:51:51 <Pirate> the bit of code that isnt working properly is on line 267
16:54:31 <liquidengineer> hey
16:54:35 <liquidengineer> how's everyone tonight
16:54:54 <liquidengineer> Is there a command to remove an element from a list based on value?
16:55:08 <liquidengineer> i.e: I want to remove the smallest element
16:55:18 <liquidengineer> I can get the smallest with minimum [a]
16:55:29 <Pseudonym> You could use xs \\ [x]
16:55:34 <Pseudonym> As a suggestion.
16:55:39 <Pseudonym> @type (//)
16:55:45 <Pseudonym> @type (\\)
16:55:45 <lambdabot> bzzt
16:55:46 <lambdabot> bzzt
16:55:50 <Pseudonym> Hmmm.
16:55:52 <liquidengineer> or not
16:55:52 <liquidengineer> :)
16:55:56 <Pseudonym> @type Data.List.(\\)
16:55:58 <lambdabot> bzzt
16:56:06 <Pseudonym> What is that again?
16:56:07 <dons> @type (Data.List.\\)
16:56:09 <lambdabot> (Data.List.\\) :: forall a. (Eq a) => [a] -> [a] -> [a]
16:56:11 <Pseudonym> That's it.
16:56:31 <Pseudonym> I keep forgetting it.  In Miranda, it was (--), but that's a comment in Haskell.
16:56:43 <dons> ;) always thought that was a counterintuitive lexical rule.
16:56:46 <Pseudonym> I liked the symmetry between (++) and (--).
16:57:12 <dons> good point
16:57:37 <dons> the set-notation meanies got to it first, it seems
16:58:04 <Pseudonym> Mind you, you could argue that (--) isn't actually that useful.
16:58:11 <Pseudonym> And you should avoid it.
16:58:16 <dons> hmm. what was the comment token in Miranda?
16:58:20 <Pseudonym> ||
16:58:25 <liquidengineer> so
16:58:31 <liquidengineer> what exactly does that do?
16:58:32 <dons> ah, it all comes flooding back.
16:58:34 <Pseudonym> That's actually closer to mathematical notation.
16:58:49 <Pseudonym> fac x = 1, x = 0     || base case
16:59:02 <Pseudonym>       = x*fac (x-1), otherwise
16:59:10 <Pseudonym> Does that bring back memories? :-)
16:59:58 <dons> yeah :) the postfix `otherwise'
17:00:21 <Pseudonym> I think Gofer still had that notation, but it required "if".
17:00:24 <Pseudonym> fac x = 1, if x = 0
17:00:50 <jlouis> damn, that is hard to read
17:00:58 <dons> nah. not so bad.
17:01:04 <jlouis> Before my time.
17:01:22 <jlouis> heck, while(--x) { ... } is easier ;)
17:01:25 <Pseudonym> jlouis: It's closer to "customary" mathematical notation.
17:01:52 <Pseudonym> I think the guard notation is superior for programming purposes.
17:02:02 <Pseudonym> It emphasises the "reduction rule" idea.
17:02:09 <jlouis> wouldn't be defined as a recurrence?
17:02:23 <jlouis> or with ... notation, which is arguably bad
17:02:46 <Pseudonym> I've seen lots of mathematical notation that looks a bit like this:
17:02:53 <Pseudonym> sinc x = 1, x = 0
17:03:06 <Pseudonym>        = sin x / x, otherwise
17:03:18 <Pseudonym> Except instead of the double equals, there'd be a large left curly brace.
17:03:44 <jlouis> ah, a \cases ;)
17:03:49 <Pseudonym> That's about as close you can get in ASCII, I think.
17:04:18 <jlouis> yeah, ok
17:12:29 <liquidengineer> hi
17:12:35 <liquidengineer> sorry for leaving so suddenly
17:12:39 <liquidengineer> connection fritzed
17:12:42 <liquidengineer> okay
17:12:56 <liquidengineer> I'm still a bit confused
17:13:25 <liquidengineer> there's no built in way to remove the duplicate of a list element?
17:13:58 <liquidengineer> I've got something like [2,3,3,4]
17:14:02 <liquidengineer> I want one of the threes gone
17:15:11 <Darius> liquidengineer: nub removes all duplicates
17:15:57 <Darius> (also very little is "built-in" to Haskell, "standard" or "library function" would be more precise)
17:17:00 <liquidengineer> sorry
17:17:01 <liquidengineer> :)
17:17:11 <liquidengineer> I don't want to remove all duplicates
17:17:15 <liquidengineer> I'm doing a selection sort
17:17:21 <liquidengineer> err..insertion sort
17:17:25 <liquidengineer> recursively
17:17:48 <liquidengineer> I want to remove the element I just sorted from the list of elements remaining to be sorted
17:19:25 <Darius> If you are following the structure of the list, then you should just be able to continue with the tail of the list.
17:19:55 <liquidengineer> I've got this
17:19:56 <liquidengineer> >insSort :: Ord a => [a] -> [a]
17:19:56 <liquidengineer> >insSort [] = []
17:19:56 <liquidengineer> >insSort xs = (minimum [a]):()
17:20:37 <liquidengineer> I need to be able to call insSort on the remainder of xs (excepting the minimum [a])
17:21:31 <liquidengineer> I can't just call insSort on xs again...I've got to do something to make xs smaller
17:21:42 <wli> proxmapsort could be interesting in Haskell
17:22:05 <liquidengineer> this is frustrating
17:22:08 <liquidengineer> I know what I want to do
17:22:11 <liquidengineer> just not how to do it
17:22:13 <jlouis> liquidengineer: insSort xs = (minimum xs) : (insSort (remove (minimum xs) xs))
17:22:27 <liquidengineer> remove won't take ALL the instances of minimum?
17:22:45 <jlouis> then define it by filter
17:22:46 <liquidengineer> like, if the list is [1,1,2] it'll leave me with [1,2]
17:22:49 <jlouis> @type filter
17:22:49 <liquidengineer> ?
17:22:50 <lambdabot> filter :: forall a. (a -> Bool) -> [a] -> [a]
17:22:54 <Pirate> does anyone know what the mathematical symbol 'backwards C' means?
17:22:57 <liquidengineer> I'm confused
17:23:03 <jlouis> Pirate: complementary set
17:23:06 <stepcutHM> delete 'a' "banana" == "bnana"
17:23:19 <Pirate> jlouis whats that?
17:23:33 <liquidengineer> jlouis and stepcut: thianks a bundle
17:24:09 <jlouis> Pirate: Let A be the world you are working in. If B is a subset of A, then the complementary set of B is A \ B (that is A setminus B)
17:24:18 <jlouis> ``everything'' but b
17:25:26 <Pirate> in terms of programming what is the default Boolean symbol for that? or does it not have one?
17:25:55 <jlouis> Boolean symbol?
17:26:37 <Pirate> i ment like A [symbol] B like == or !=
17:27:26 <Pseudonym> It's (\\), I guess.
17:27:34 <Pseudonym> If you're working on lists.
17:27:53 <stepcutHM> liquidengineer: why are you doing this anyway ?
17:28:12 <Pirate> right ok, cheers
17:34:09 <Cale> Pirate: it might mean subset, depending on context
17:34:42 <Pirate> ive emailed my lecturer to ask him
17:35:34 <Cale> A  B -- B is a subset of A (if you can see Unicode)
17:36:24 <Pirate> i cant see unicode in mirc unfortunately
17:36:42 <Cale> http://en.wikipedia.org/wiki/Na%EFve_set_theory
17:36:55 <Cale> See the section labelled "subsets"
17:37:10 <Pirate> yep
17:37:31 <Pirate> but unfortunately all the symbols are just squares
17:37:39 <Cale> on that page?
17:37:43 <Pirate> yep
17:37:46 <Cale> argh
17:39:35 <gzl> ?
17:39:36 <gzl> it loads for me
17:41:03 <Cale> http://vx.hn.org/autoshare/subset.pdf
17:41:08 <Cale> can you read that?
17:41:23 <Pirate> yep
17:42:03 <Cale> Does it look like the symbol you're looking for?
17:42:09 <Pirate> its the second one, i have to make a function for that in my lexer,parser,typer,interpreter and compile/exec haskell program
17:43:59 <Cale> To test if one set is a subset of another?
17:44:08 <Cale> or to generate all subsets of a given set?
17:44:27 <Pirate> im not sure, thats why ive emailed the lecturer guy, it just says implement and then that symbol
17:45:19 <Cale> Doesn't even mention which datatype it will work with?
17:45:27 <Pirate> nope
17:45:52 <Pirate> http://www.dcs.shef.ac.uk/%7Egraham/co31/nuC1.pdf
17:45:56 <Pirate> thats the assignment
17:46:30 <Cale> oh, in the context of logic, that tends to mean "implies"
17:46:53 <xeiro> hello all
17:47:05 <Pirate> so what does that mean?!
17:47:21 <Pirate> is it A implies B do something?
17:47:27 <Cale> "a implies b" means "b or not a"
17:47:38 <Cale> where a and b are boolean variables
17:47:40 <xeiro> any haskell gurus in here :D
17:47:44 <Pirate> sort of like eox?
17:47:49 <Pirate> sorry xor
17:48:28 <Cale> not quite
17:48:37 <xeiro> :)
17:48:41 <Pirate> sorry a || (!b)
17:49:16 <Cale> (!a) || b
17:49:39 <Cale> (a -> b) = (!a) | b
17:49:44 <Pirate> so it still accepts (!a) && b if that case arose
17:50:13 <Cale> If a is false, then it's automatically true, and if b is true it's automatically true.
17:50:32 <Pirate> ah i see, sorry its late here and i forgot we were talking about Bools
17:50:39 <Cale> The only way that it can be false is if A holds, but B does not.
17:51:08 <Cale> (hence, "A implies B")
17:51:34 <Pirate> ic, thanks for making it clearer!
17:52:08 <xeiro> any one knows what this means
17:52:12 <xeiro> "Illegal type in class constraint"
17:53:30 <liquidengineer> hi
17:53:32 <Pirate> ps for anyone who is interested in the amazing lecturer whos teaching a haskell course and cant program haskell, http://www.dcs.shef.ac.uk/%7Egraham/CO31.html
17:53:36 <liquidengineer> what's wrong with this definition?
17:53:38 <liquidengineer> >iSort :: Ord a => [a] -> [a]
17:53:43 <liquidengineer> it's giving me a syntax error
17:54:19 <Darius> What error is it giving you?
17:54:21 <liquidengineer> "Syntax error in input"
17:54:35 <Darius> Are you trying to type this in at a REPL?
17:54:41 <liquidengineer> (unexpected symbol "iSort")
17:54:48 <liquidengineer> tried changing the function name to no avail
17:59:04 <liquidengineer> hmm
17:59:08 <liquidengineer> I killed the room
17:59:10 <liquidengineer> bugger
17:59:18 <liquidengineer> REPL?
17:59:28 <liquidengineer> It's a literate haskell script
17:59:37 <Pirate> if anyone has the time can u explain the whole Ord Eq etc thing when defining functions?
17:59:43 <Pseudonym> Try looking on the line of Haskell _above_ it.
17:59:56 <liquidengineer> the line above it is white space
18:00:00 <liquidengineer> and the line above that is a comment
18:00:07 <Pseudonym> Generally speaking, when the parser complains about the start of a line, the error is often on the line of Haskell above it.
18:00:15 <Pseudonym> Yes, skip all that to the previous line of actual Haskell.
18:00:34 <liquidengineer> so, it's these two lines
18:00:35 <liquidengineer> > x :: [Int]
18:00:35 <liquidengineer> > x = [1,2,3,3,4,5,1,2]
18:00:35 <liquidengineer> Comment!
18:00:41 <liquidengineer> err...ignore that last part
18:00:51 <liquidengineer> and yes, there is whitespace after the x assignment
18:01:13 <liquidengineer> that's how you declare a list, yes?
18:02:08 <Pseudonym> Yes.
18:02:19 <Pseudonym> BRB.  Need caffeine.
18:03:04 <liquidengineer> so, if that's how you declare a list, what's it complaining about?
18:04:11 <Igloo> You need a space before iSort
18:04:22 <liquidengineer> before?
18:04:22 <Igloo> Or no space before the x's
18:04:39 <Igloo> To the left of
18:04:57 <liquidengineer> OH!
18:05:00 <liquidengineer> duh!
18:05:02 <liquidengineer> damn
18:05:17 <liquidengineer> It's been too long since I programmed in a language that used whitespace formatting
18:05:17 <liquidengineer> thanks
18:06:22 <liquidengineer> ....now it says delete is an undefined variable
18:08:04 <liquidengineer> that's a list function, right?
18:08:11 <liquidengineer> @type
18:08:13 <lambdabot> bzzt
18:08:17 <liquidengineer> @type delete
18:08:19 <lambdabot> bzzt
18:08:20 <liquidengineer> or not
18:09:12 <Darius> @index delete
18:09:13 <lambdabot> Data.HashTable,Data.List,List
18:09:28 <Darius> @type Data.List.delete
18:09:30 <lambdabot> Data.List.delete :: forall a. (Eq a) => a -> [a] -> [a]
18:10:40 <liquidengineer> I'm confused
18:10:43 <liquidengineer> what does that mean?
18:10:58 <liquidengineer> Do I have to import something?
18:13:24 <liquidengineer> I've never used anything that wasn't part of the prelude
18:15:52 <liquidengineer> hello?
18:16:51 <Darius> liquidengineer: You need to import one of those modules.  Preferably Data.List.
18:17:15 <Darius> liquidengineer: This should be covered in just about any introduction/tutorial on Haskell.
18:17:31 <liquidengineer> Darius: it probably is
18:17:34 <liquidengineer> I've just not had to do it yet
18:17:51 <liquidengineer> thanks for the help
18:21:01 <liquidengineer> hmm...
18:21:07 <liquidengineer> my textbook has disappeared
18:21:09 <liquidengineer> odd.
18:27:23 <liquidengineer> okay
18:27:28 <liquidengineer> so, this should work, yes?
18:27:28 <liquidengineer> >module InsertionSortMod where
18:27:28 <liquidengineer> >import Data.List (delete)
18:27:34 <liquidengineer> it says it can't find the file Data
18:28:51 <liquidengineer> I'm really confused now
18:29:01 <liquidengineer> I'm looking at an example code that does the exact same thing
18:29:29 <Darius> liquidengineer: Which implementation are you using?
18:29:37 <liquidengineer> hugs
18:29:45 <liquidengineer> should I restart with haskell98 mode on?
18:30:25 <Igloo> no
18:30:32 <Darius> I believe there's an option +N (?) that will turn on hierarchical modules, or you could use List instead of Data.List which is the standard one (though the hierarchical libraries are pretty much de facto standard now).
18:33:32 <liquidengineer> the plain list thing worked fine
18:33:45 <liquidengineer> I'll have to look up the switch for hierchal libraries
18:34:50 <liquidengineer> excellent
18:34:52 <liquidengineer> it works
18:34:55 <liquidengineer> thanks
18:38:53 <liquidengineer> \Hmmm.
18:39:00 <liquidengineer> looks like I'm running a tres old version of hugs
18:39:02 <liquidengineer> Feb 2001
18:40:33 <liquidengineer> got it through fink
19:33:32 <MegaMonad> G'day seafood, how ar ya.
19:34:15 <CosmicRay> good evening
19:34:26 <ozone> hi MegaMonad, you sly beast you
19:34:50 <CosmicRay> heh
19:35:08 * CosmicRay notes that megamonad only replies when you say "MegaMonad: ...."
19:35:15 <CosmicRay> s/when/unless/
19:49:49 <MachinShin> hey +
20:16:05 <Pseudonym> MegaMonad: Why do you only reply when I sai "MegaMonad:...."
20:16:58 <Pseudonym> Errr...
20:17:07 <Pseudonym> Oh, he disconnected.
20:17:26 <Pseudonym> Well, don't I feel like a bit of a wally.
