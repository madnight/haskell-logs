00:00:19 <cm> or wait, sorry, it's called just Generics IIRC
00:00:42 <cm> {|foo|} etc
00:00:43 <dons> ah, ok. generics. but what particular extension won't parse?
00:00:50 <dons> ok. yeah. that won't fly.
00:00:59 <musasabi> You can have source which has non-haddock friendly things if you use cpp and conditionally have something alternative for haddock.
00:01:11 <dons> yeah. that's a good idea.
00:01:17 <dons> #ifdef HADDOCK
00:01:25 <dons> but it's a bit evil ;)
00:01:39 <dons> extending Language.Haskell.Syntax would be better :)
00:01:44 <musasabi> __HADDOCK__ iirc
00:02:23 <dons> yep. that's the one. often used to import the Prelude to keep links working
00:02:25 <musasabi> unifying TH and L.H.Syntax would be nice.
00:02:46 <dons> and ghc's HsSyn..
00:03:01 <cm> and giving TH a syntax nice enough people start using it. ofc i don't propose a better alternative, i just bitch.
00:03:05 <yonkeltron> cm: ya know how in php there is a function to make a random identifier?
00:03:18 <cm> gensym? :P
00:03:25 <yonkeltron> cm: i guess....
00:03:32 <dons> GHC's HsSyn type (the internal type) is almost (>=) the TH type, which is > Language.Haskell
00:04:07 <musasabi> TH cannot handle non-haskell-98 data declarations at all.
00:04:20 <dons> huh. didn't know that.
00:04:45 <dons> but they're very open to people filling out the rest of the type
00:05:37 <musasabi> ghc/compiler/typecheck/TcSplice.lhs:601 is the place...
00:06:59 <dons> ah ha! yes.
00:07:01 <yonkeltron> does ghc compile natively directly or does it convert to c first?
00:07:16 <dons> it does both.
00:07:16 <musasabi> yonkeltron: It can do both.
00:07:30 <dons> and C--, and a bytecode form, too!
00:08:02 <dons> musasabi: yeah, so TcSplice implies actually helping out the compiler, and not just extending the library. hmm :/
00:08:10 <yonkeltron> musasabi: so ghc --make helloworld.hs -o helloworld ......will that do it directly?
00:08:26 <dons> nah. you need -fasm
00:08:31 <yonkeltron> dons: C--? it can do bytecode?
00:08:51 <dons> C-- is one backend, bytecode (used by GHCi) is another.
00:08:52 <yonkeltron> so what's the default?
00:09:04 <dons> -fvia-C -- produces 1% faster code than -fasm
00:09:17 <musasabi> yonkeltron: -O means via-c unless -fasm is specified *after* -O.
00:09:34 <musasabi> without -O -fasm is used.
00:09:48 <yonkeltron> musasabi: so when i compile like i showed above...what is happening?
00:10:23 <dons> Haskell -> Core -> Cmm -> C ~> gcc ~> ld ~> helloworld
00:10:44 <yonkeltron> dons: crap dude.....holy crap
00:11:58 <dons> Cmm -> C isn't really a pass though, it's actually Cmm printed as C.
00:12:31 <yonkeltron> dons: Cmm?
00:13:04 <wilx> C--
00:13:05 <dons> an abstract (i.e. data) representation of C--, used as the code generation target of ghc
00:13:11 <wilx> Sort of assembler language.
00:13:21 <yonkeltron> what is C--?
00:13:22 <yonkeltron> i don't get it
00:14:17 <Cale> http://www.cminusminus.org/
00:14:37 <autrijus> Cmm looks fun.
00:14:49 * autrijus wonders if F# can retarget Cmm
00:15:08 <dons> autrijus: you should try p6 -> C-- :)
00:15:18 <autrijus> uh. pugscc is already there.
00:15:38 <autrijus> so eventually p6->Haskell->Core->Cmm->C
00:16:22 <dons> yikes. isn't there a fairly easy mapping from p6 -> C? and hence C-- would do too?
00:16:31 <autrijus> is there?
00:16:35 <autrijus> if there is I have no idea
00:16:45 <dons> or are the closures causing trouble ;)
00:16:59 <autrijus> I think the caller continuations can cause more trouble
00:17:05 <autrijus> oh and lightweight threads and coroutines.
00:17:28 <dons> ok. you'd have to compile to C the a bit of an rts. the mapping would be a bit more 'heavy'
00:17:36 <dons> s/the/plus/
00:17:37 <wilx> Hmm, despite it's name C-- is very far from C.
00:17:42 <autrijus> so I'll just compile to haskell
00:17:47 <autrijus> and let GHC-RTS take care of the rest.
00:17:51 <autrijus> I actually quite like GHC-RTS ;)
00:17:52 <dons> autrijus: :) yay!
00:18:12 <dons> wilx: but it's trivial to transform C-- to C.
00:18:21 <dons> but, yes, it isn't C at all.
00:18:46 <dons> this is probably the number one question about C--, in fact. "why isn't it like C?"
00:19:19 <dons> autrijus: then you can run p6 in the kernel of the House OS :)
00:19:27 <dons> (ghc's rts on bare metal OS)
00:21:42 <autrijus> woot.
00:21:54 <autrijus> yeah. one of pugs' goal is to be able to inline haskell code.
00:22:03 <autrijus> sort of like how C can inline assembly
00:22:35 <dons> that shouldn't be too hard from the interpreter. hmm you'd want dyn loading maybe, or else a binding to GHCi
00:22:49 <autrijus> hs-plugins.
00:23:26 <dons> eval (InlineHaskell str) = let a = evalHaskell str in toPerlVal a
00:24:07 <autrijus> except I need to sequence IO.
00:24:15 <autrijus> and preferably Cont and Reader as well.
00:24:19 <dons> I have to admit (as the author) that hs-plugins is a bit heavyweight for inline code, atm -- unless that code is used repeatedly.
00:24:43 <autrijus> because perl6 has eval(), I need the code to dynamically generate haskell code and load it.
00:24:53 <autrijus> which to my knowledge hs-plugins is the only sane solution
00:24:56 <dons> hence I'm writing hs-plugins v2 atm, which uses ghci directly to eval to bytecode -- much faster.
00:25:35 <dons> doesn't eval() generate perl code, that you would feed back into pugs, which would have to be callable by itself?
00:25:52 <dons> that would be the lispy way to do things.
00:26:17 <autrijus> perl6 is extremely lispy that way.
00:26:23 <dons> lots of literature on runtime metaprogramming (which is what eval is) via interpreters linked into the rts.
00:26:35 <autrijus> there is no hard distinction between runtime and compile time, really.
00:26:41 <autrijus> dons: ooh. got a reading list?
00:26:41 <dons> not in the interpreter.
00:27:20 <dons> autrijus: hmm. have a look at Meta ML, and 'reflective towers', and go from there.
00:27:28 <dons> I'll see if I can find my list..
00:30:34 <dons> autrijus: www.cse.unsw.edu.au/~dons/safe.html
00:30:40 <autrijus> danke!
00:30:55 <autrijus> how is hs-pl-v2 coming along?
00:31:01 <autrijus> mmm user/pass?
00:31:10 <dons> hmm.
00:31:13 <autrijus> PLS_Internal login
00:31:21 <dons> grr. gimme sec.
00:31:45 <autrijus> I'll food, so bbiab anyway. ciao!
00:32:01 <Svrog> hi everyone
00:32:26 <Svrog> anyone tried compiling 6.4 on os x?
00:33:07 <dons> autrijus: try that.
00:33:47 <dons> there's enough notes on Staged Computation to get started, I'd say - if you want to do eval() well.
00:34:34 <dons> hopefully hs-plv2 will be done by this year's Haskell Workshop. And pointing out that it would be good for perl6 is very interesting, in fact.
00:35:47 <dons> atm, hs-plugins would be good for dyn loaded modules for pugs, but not for eval() (it would be a bit slow, having to natively compile the code)
00:36:12 <dons> though you could try it. it works alright for interactive eval, like in my plugs interpreter.
00:55:33 <dons> autrijus: "Types and Reflection" is another good paper to read
01:00:14 <wilx> OMG! I RULE!
01:00:24 <wilx> My LZW encoding in Haskell actually works!
01:00:30 * wilx pats himself
01:00:42 <dons> yay :)
01:00:47 <dons> pure H98?
01:00:59 <wilx> Err, nope. GHC 6.4 centric :)
01:01:16 <dons> really? why for?
01:01:23 <dons> ghc 6.4 even?
01:02:09 <wilx> The answer is "Why not?" :)
01:02:28 <wilx> It has loads of useful data structures etc.
01:02:44 <dons> yeah, but what ghc-6.4 features did you use, that aren't Haskell 98?
01:02:57 <dons> just using the libraries is still fine.
01:03:08 <dons> do you use -fglasgow-exts?
01:03:18 <wilx> Hmm, ST monad, that forced me to use forall t. etc.
01:03:23 <wilx> Yup.
01:03:26 <dons> ah..
01:03:34 <dons> I see.
01:03:52 <dons> oh well. it's still good to try to get it working with nhc.
01:04:25 <wilx> Hmm, that would mean trying to build it in FreeBSD, I doubt there is NHC for Win32, is there?
01:04:39 <dons> I'd think almost certainly there is one.
01:05:05 <dons> "ix86-CYGWIN_NT-5.1" ?
01:05:42 <dons> but if you're on windows, don't worry bout it. too much effort :)
01:05:54 <wilx> Hm, I was never able to make it build under Cygwin. Though the last time I tried was like two years ago...
01:06:11 <dons> there's a binary or two on www.haskell.org/nhc98
01:06:27 <dons> it's really easy to build, I've found. far more so than ghc
01:07:51 <dons> hehe. it's been ported to >24 platforms
01:08:01 <dons> and they're all all 32 bits :)
01:23:51 <wilx> Whee.
01:24:08 <wilx> Now that I have the encoding I need decoding.
01:24:15 <wilx> Which will a bit harder I think.
01:24:19 <wilx> And than storage.
01:38:11 <bourbaki> moin
01:58:00 <wilx> Lzw.hs:197:5:
01:58:00 <wilx>     Warning: This binding for `c' shadows an existing binding
01:58:00 <wilx>              In a case alternative
01:58:06 <wilx> What is this?
01:58:16 <wilx> This line: data MyType = A | B | C | D deriving (Eq, Show, Enum, Bounded, Ix, Ord)
02:07:04 <basti_> hi
02:10:28 <xerox> How would you do a function "match :: String -> Bool" for matching paired parens?
02:10:54 <basti_> i would build a subfunction that counts ('s and uncounts )'s
02:11:45 <xerox> I did it this way, thinking if there would be a cleaner solution :)
02:12:11 <basti_> hmm
02:12:14 <dons> wilx: it just means you bind some variable 'c' when there is some other 'c' bound in an outer scope.
02:12:45 <wilx> dons, yeah, but it the line 197 is the line I pasted.
02:12:50 <wilx> No `c' there.
02:12:53 <xerox> match = (==0) . foldr1 (+) . map (matchP)
02:12:53 <xerox>     where matchP c | c == '(' = 1 | c == ')' = -1 | otherwise = 0
02:12:56 <wilx> Only the C constructor.
02:13:29 <dons> that 'c' after matchP might shadow another. try c' maybe.
02:13:41 <wilx> xerox, does it work for ")(" too? :)
02:13:42 <dons> where is the case, btw?
02:13:50 <xerox> wilx, yay, it does.
02:14:58 <dons> xerox: you're not enrolled at unsw, right? -- matching parens is this weeks tut question ;)
02:15:24 <wilx> That is what is strange. There is no case near that.
02:15:43 <xerox> dons, eheh, nope. Our info professor talked about it.. and I was in the mood of trying to implement :)
02:15:45 <bourbaki> hey basti_
02:15:47 <wilx> http://logout.sh.cvut.cz/~wilx/lzw/Lzw.hs
02:15:55 <basti_> hey bourbaks. still without net at home.
02:16:15 <bourbaki> basti_: have you got win at the place you are at now and can install things?
02:16:37 <basti_> hmm.
02:16:47 <basti_> this is windows, I'm not sure how many or what things i may install
02:17:56 <_JusSx_> i need help. how can i read a TEXT file and get a list of lines?
02:17:57 <bourbaki> you need the dx sdk to have a look at my sample app
02:19:10 <basti_> bourbaki i do not think that this is possible here.
02:19:16 <bourbaki> pitty
02:19:18 <basti_> bourbaki how about a screenshot or something?
02:19:33 <bourbaki> http://codemages.sf.net/Unbenannt.JPG
02:19:37 <basti_> _JusSx_: i would try opening it, and then reading it line by line.
02:19:57 <basti_> bourbaki cute =)
02:20:35 <bourbaki> the red dots are particles on that surface
02:20:45 <bourbaki> and move according to the slope
02:20:50 <basti_> hehe
02:20:56 <bourbaki> and in between there are springs
02:21:13 <basti_> i see.
02:28:46 <_JusSx_> basti_: i wonna an example
02:29:02 <_JusSx_> main = do
02:29:02 <_JusSx_>        bracket (openFile "foo" ReadMode) hClose body
02:29:18 <_JusSx_> what should body do?
02:29:37 <basti_> hmm i would think that would depend on how it is defined, wouldn't it?
02:30:19 <Cale> _JusSx_: you can't do it like that, because that throws away the file handle.
02:31:12 <Cale> do { text <- hGetContents =<< openFile "foo" ReadMode; print (lines text) }
02:31:31 <Cale> I suppose in a real example, you want to hClose that as well
02:32:29 <Cale> oh, I'm silly
02:32:34 <Cale> yeah, you can do that
02:32:49 <Cale> I misread the type of bracket
02:32:54 <basti_> i think _JusSx_'s idea is not wrong.
02:32:59 <basti_> he'd just need to define body
02:32:59 <Cale> It's not
02:33:01 <Cale> yeah
02:33:19 <Cale> body is a function that takes that file handle and reads from it
02:34:19 <Cale> \h -> do { text <- hGetContents h; print (lines text) } -- perhaps like this
02:34:31 <basti_> _JusSx_ so, what do you want body to do? =)
02:52:10 <xerox> *Parens> match "()"
02:52:10 <xerox> Just 0
02:52:10 <xerox> *Parens> match ")("
02:52:10 <xerox> Nothing
02:52:10 <xerox> *Parens> match "("
02:52:10 <xerox> Just 1
02:52:14 <xerox> Better?
02:53:12 <basti_> why would one forbid )( in the first place? ;)
02:53:21 <xerox> ...
02:53:40 <basti_> :P
02:54:01 <basti_> no but i think this behaviour is acceptable
02:55:02 <xerox> I don't like too much how I wrote this, I'll paste it. Maybesomeone can suggest me a more `concise' version.
02:55:44 <xerox> @wiki HaskellIrcPastePage
02:55:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:55:46 <xerox> There.
02:57:44 <basti_> hmm
02:58:58 <xerox> I'm thinking of another form, but I'm not able to Haskellize my tought.
03:00:53 <wilx> map (Just . matchP) maybe?
03:11:25 * xerox is transposing it to the Error Monad.
03:13:01 <xerox> <dons> that 'c' after matchP might shadow another. try c' maybe.
03:13:08 <xerox> dons, what do you mean?
03:15:12 <xerox> Is there a way to check if you're at the end of the computation/list, during folding?
03:17:09 <xerox> ..or do I need an helper function?
03:20:08 <tromp> in what way are you checking for the end?
03:20:36 <xerox> I'm not, I can't think of a way to do.
03:20:44 <tromp> what does your unfolded code look like?
03:20:45 <xerox> It's probably not possible.
03:21:29 <xerox> tromp, hm, I wrote it folded.
03:22:08 <wilx> So, I am used to write Doxygen docs in my C++ programs. Is Haddock what I want?
03:22:28 <xerox> Ok, let me paste it.
03:22:51 <Philippa_> wilx: probably
03:22:56 <xerox> @wiki HaskellIrcPastePage
03:22:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:24:04 <xerox> Unmatched closing parens are reported in a sane way, but not unclosed ones. So, "Right 2" means 2 parens are left unclosed.
03:25:19 <xerox> Can you suggest me a way to do a correct error reporting? (as in ``Left [n] ++ "unclosed paren"'' or something similar)
03:29:48 <basti_> hmm
03:30:04 <basti_> you could define a data type especially for your results.
03:30:34 <xerox> Can you give me an exmaple? Gotta go, I'll read later, thanks much.
03:32:31 <basti_> uhm like, "data BracketResult = MissingLeft Int | MissingRight Int | WellFormed | UnspecifiedError"
03:34:54 <basti_> that would also force you to catch all the errors.
03:38:39 <ibid> so, how would ")(" be handled?
03:39:33 <basti_> maybe UnspecifiedError?
03:39:37 <basti_> that was only an example
03:39:42 <ibid> sure
03:40:15 <basti_> one could also do some "UnexpectedClosedBrace" or something
03:47:23 <dons> hmm. Malcolm's defaulting mechanism proposal for Haskell2 is very nice.
03:54:18 <_JusSx_> Cale: i dont wonna print the file lines
03:54:46 <theorbtwo> Is there any way to convince ghci to show me something that does not have an instance of Show defined?
03:54:48 <basti_> _JusSx_ but?
03:55:54 <ibid> theorbtwo: how should it show it?
03:56:36 <theorbtwo> The same way it would had it just taken the default instance?
03:57:35 <_JusSx_> i wonna read a text file and get a list of chars?
03:57:37 <theorbtwo> Used derive, that is.
03:57:42 <_JusSx_> any idea?
03:58:02 <ibid> theorbtwo: any reason for not just deriving Show?
03:58:16 <ibid> (sorry, i have no ideas:)
03:58:27 <dons> _JusSx_: getContents
03:58:38 <_JusSx_> hGetChar ?=
03:58:39 <dons> oh, sorry: readFile :: FilePath -> IO String
03:58:59 <theorbtwo> Can I do that after the fact?  I'm trying to show a Rule.Prim.GenParser.
03:59:20 <dons> or, if you have a handle, _JusSx_, hGetContents :: Handle -> IO String
03:59:41 <_JusSx_> hGetChar::Handle -> IO Char
03:59:42 <_JusSx_> ok
03:59:45 <_JusSx_> so go on
03:59:49 <_JusSx_> then how to get a list
03:59:52 <ibid> theorbtwo: you can instance it, but not derive, after the fact
04:00:13 <dons> _JusSx_ : type String = [Char]
04:01:10 <dons> hmm. maybe someone should write a 'deriving' lib for adding new instances in an autoderive kind of way.
04:01:16 <dons> via TH, that is.
04:01:28 <_JusSx_> okmain = do
04:01:28 <_JusSx_>        bracket (openFile "foo" ReadMode) hClose hGetContents
04:01:36 <dons> as a TH replacement for DrIFT.
04:02:49 <dons> _JusSx_: you need some plumbing to pass the values around, right?
04:03:38 * dons ~> sleep
04:03:50 <_JusSx_> lkl
04:03:57 <_JusSx_> lkl
04:04:15 <basti_> klk!
04:19:31 <wilx> @type =<<
04:19:37 <lambdabot> bzzt
04:19:48 <wilx> @type Control.Monad.(=<<)
04:19:49 <lambdabot> bzzt
04:23:10 <TheHunter> @type (=<<)
04:23:11 <lambdabot> (=<<) :: forall b m a. (Monad m) => (a -> m b) -> m a -> m b
05:03:53 <wilx> Hm, is Darcs compilable by NHC98?
05:06:26 <autrijus> don't think so
05:06:45 <wilx> :/
05:10:05 <wilx> I want Darcs static binary for FreeBSD 4.10 but the respective FreeBSD package contains only some 0.9.x version.
05:16:31 <metaperl> o
05:16:40 <basti_> p
05:16:45 <metaperl> ,i'm getting major errors from this innocent program:
05:16:46 <metaperl> map (\x -> x mod 3) [2 .. 10]
05:16:50 <metaperl> :) @ basti
05:17:16 <metaperl> oh... my bad
05:17:17 <basti_> uh
05:17:20 <metaperl> backticks needed
05:17:24 <basti_> yes.
05:21:04 <lisppaste2> metaperl pasted "help needed creating a matrix by an array comprehension" at http://paste.lisp.org/display/6556
05:30:27 <metaperl> solved
05:30:29 <metaperl> p2 1 = 0
05:30:29 <metaperl> p2 i = (2 ^ (i-1))
05:30:29 <metaperl> m2 = array ( (1,1), (3,3) ) [ ( (i,j), i + j + (p2 i) ) | i <- [1..3], j <- [1.\
05:30:29 <metaperl> .3] ]
05:38:21 * comeflores bye
05:41:57 <metaperl>  map (\x -> x) (assocs m2)
05:41:57 <metaperl> [((1,1),2),((1,2),3),((1,3),4),((2,1),5),((2,2),6),((2,3),7),((3,1),8),((3,2),9\
05:41:57 <metaperl> ),((3,3),10)]
05:42:16 <metaperl> how can I pattern-match on the various parts of each list element in my anonymous function?
05:49:10 <wilx> ((_,_),_)?
05:49:44 <wilx> \((a,b),c) -> a+b+c?
05:49:44 <basti_> i didnt get the question too.
05:49:55 <metaperl> oh that works? ok
05:50:06 <basti_> yes it does
05:50:15 <metaperl> (\(a,b),c -> (b,a),c ) -- matrix transpose
05:50:17 <metaperl> oh good
05:50:24 <basti_> cool.
05:58:50 <metaperl> For cube x = x * x * x why is the type signature (Num a) => a -> a instead of (Num a, Num b) => a -> b
05:59:08 <basti_> because it wouldnt ever change the type
05:59:09 <metaperl> a -> a means that it returns the same value it gets
05:59:21 <metaperl> oh *type* not *value*
05:59:24 <basti_> :)
05:59:39 <metaperl> ok, so something in Cale's Monads as containers tutorial makes sense now
05:59:49 <metaperl> box of apples === f a
05:59:55 <metaperl> box of blueberries === f b
05:59:59 <metaperl> f is a container type
06:00:09 <basti_> yes.
06:00:12 <metaperl> a is apples (a type) , b is blueberries (another type)
06:00:23 <xerox> hello.
06:00:27 <metaperl> I cant believe it. I am being a reasonable person in a reasonable language
06:00:32 <metaperl> hi xerox
06:00:46 <wilx> :))
06:08:17 <xerox> basti_, using data ParenResult = .. how would you specify the instance Monad ParentResult ... ?
06:08:29 <basti_> uhm.
06:08:35 <metaperl> for sumAtoB a b = sum [a .. b] I think the type signature is a bit vague.. ghci gives sumAtoB :: forall a. (Enum a, Num a) => a -> a -> a  but the only thing which is Enum a and Num a is Integral
06:08:56 <metaperl> @type sum
06:08:57 <lambdabot> sum :: forall a. (Num a) => [a] -> a
06:09:10 <basti_> xerox: this is an interesting question
06:09:26 <basti_> xerox: in this case, you would need a result type of "n braces left open"
06:11:05 <basti_> if you think the same way as i do.
06:12:11 <basti_> oh but we got that
06:13:44 <basti_> you would have to rebuild your matcher to go Type -> String -> Type and not String -> Type (with Type being the result type)
06:13:56 <xerox> Why?
06:14:11 <basti_> or you would have to invent a function that combines two results.
06:14:37 <basti_> but i think that could interfere with some "errors"
06:14:52 <xerox> Btw I have a bigger problem - *where* have I to catch the "n parens left open" error?
06:15:05 <basti_> well one value of "Type" would need to be passed around. Of course you might be able to hide that in bind.
06:15:09 <basti_> at []
06:15:25 <xerox> But I can't do it with foldl, I think.
06:15:30 <xerox> foldM even.
06:15:58 <basti_> there is a difference between "unevaluated point in a list" and "end of list"
06:16:43 <xerox> I know something remained unclosed only at the end of the list.
06:16:52 <xerox> *if something
06:17:07 <basti_> yes.
06:18:27 <xerox> I easily lose the point without the implementation of what we are talking about. Hmpf.
06:18:45 <basti_> :)
06:19:24 <basti_> i dont even know what youre aiming at ;)
06:19:29 <glimming> is someone skilled in ocaml/ML?
06:19:36 <basti_> hint: there are many monadic parsers.
06:19:38 <glimming> I want to define an algebraic datatype
06:19:52 <glimming> and typed this
06:19:52 <glimming> type 'f direc = ('f ('f direc) ('f direc))
06:19:57 * basti_ does not even know what an algebraic datatype is
06:19:58 <glimming> but I get syntax error
06:19:59 <tromp> what is match supposed to do, xerox?
06:20:10 <glimming> recursive
06:20:11 <glimming> datatype
06:20:13 <xerox> tromp, check if all the parens are correctly paired (closed)
06:20:43 <basti_> glimming afaics in my limited knowledge, you applied two parameters to a unary function.
06:20:54 <tromp> what's the type of match?
06:20:57 <basti_> i would complain about that, too, if I were ocaml.
06:21:09 <glimming> Hmm 'f is supposed to take two arguments.
06:21:19 <basti_> tromp "match" was just an informal name i gave to one of the functions utilised, i think.
06:21:26 <xerox> tromp, String -> Either String Integer
06:21:34 <basti_> glimming: you should specify it then.
06:21:36 <glimming> ocaml should infer this
06:21:41 <glimming> aha, how?
06:21:44 <basti_> the arity?
06:21:48 <glimming> yes
06:22:04 <glimming> how do I give arity?
06:22:08 <basti_> if you start with "type 'f direc =" then it would start assuming 'f is unary i think
06:22:21 <basti_> like "type 'f direc direc2" maybe?
06:22:28 <basti_> im no ml expert btw. ;)
06:22:33 <glimming> nah
06:22:43 <glimming> 'f direc means in Haskell   data Direc f
06:22:48 <basti_> oh
06:22:50 <glimming> 'f is parameter
06:23:02 <basti_> well then give the thing two parameters.
06:23:15 <basti_> but wait
06:23:18 <basti_> maybe im just confused.
06:23:29 <glimming> aha
06:23:34 <glimming> well no
06:23:40 <glimming> it should have only one parameter
06:23:40 <basti_> hm? ;) youre not? ;)
06:23:44 <basti_> hmm okay.
06:23:44 <glimming> but the parameter is a type consturctor.
06:24:09 <tromp> i don't see the point of mapping to -1,+1,0
06:24:11 <glimming> syntax problem
06:24:22 <glimming> ocaml has datatype and type
06:24:29 <basti_> tromp: ( is +1, ) is -1, every other character is 0
06:24:34 <basti_> hmm
06:24:42 <tromp> just increase open count on a '('
06:24:50 <tromp> decrease on a ')'
06:25:12 <xerox> tromp, "an open count" ?
06:26:08 <tromp> that's the intermediate state
06:26:23 <tromp> that gives error when it goes negative
06:26:44 <tromp> do you allow "()()" ?
06:26:45 <xerox> More or less what I tought, but I can't implement it, can you give me some suggestions?
06:27:27 <basti_> well 1. use a parser generator.
06:27:28 <basti_> ;)
06:27:31 <basti_> because of the hassle
06:27:51 <xerox> tromp, yes
06:28:02 <tromp> also "" then?
06:28:29 <TheHunter> glimming, newtype Direc f = Direc { unDirec :: f (Direc f) (Direc f) }
06:28:45 <xerox> tromp, I think so.
06:28:59 <glimming> sure, in Haskell thehunter, but I am using Ocaml today! ;-)
06:28:59 <TheHunter> or even (GHC 6.4, i think) newtype Direc (~>) = Direc { unDirec :: Direc (~>) ~> Direc (~>) }
06:29:17 <TheHunter> oh, sorry, i didn't get that.
06:29:52 <TheHunter> doesn't datatype work?
06:30:48 <tromp> dar; http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.Error.html is not found
06:30:58 <tromp> @index Error
06:30:59 <lambdabot> Graphics.UI.GLUT,Graphics.UI.GLUT,Graphics.Rendering.OpenGL,Graphics.Rendering
06:30:59 <lambdabot> OpenGL.GLU,Graphics.Rendering.OpenGL.GLU.Errors,Graphics.Rendering.OpenGL
06:30:59 <lambdabot> GLU.ErrorsInternal,Graphics.Rendering.OpenGL,Graphics.Rendering.OpenGL.GLU
06:30:59 <lambdabot> Graphics.Rendering.OpenGL.GLU.Errors,Graphics.Rendering.OpenGL.GLU.ErrorsInterna
06:30:59 <lambdabot> ,Control.Monad.Error
06:41:04 <xerox> tromp, any news?
06:42:18 <tromp> working on it:)
06:43:00 <tromp> btw, what was the problem you had with the paszted code?
06:44:58 <_JusSx_> exit
06:45:45 <xerox> tromp, the return type. It returns Left String for unmatched closed parens but Right Integer for unclosed ones.
06:46:19 <tromp> so why not wrap it with another test?
06:47:05 <xerox> Is it the only way? I tought the way I wrote it is very verbose, adding a function would have not helped in this sense.. what do you think?
06:47:30 <tromp> it's mostly verbose because of your map
06:47:30 <xerox> I always see very concise and clean solutions in Haskell.. if I'm not the one writing those. :)
06:47:54 <tromp> try
06:47:56 <tromp> check x c | c=='(' = return (x+1)
06:47:56 <tromp>           | x==')' = return (if x==0 then Left "oops" else Right (x-1))
06:47:56 <tromp>           | otherwise = return x
06:47:56 <tromp>                                                                                 
06:47:56 <tromp> match = foldM (check) 0
06:49:06 <xerox> Hmmm.
06:50:10 <tromp> what do you want match "()()" to return then?
06:50:19 <tromp> Right 0 ?
06:50:27 <xerox> Yep, I think.
06:50:35 <tromp> but the 0 is not informative
06:50:46 <xerox> Exactly.
06:50:52 <tromp> since nonzero gets mapped to Left
06:52:16 <tromp> oh, my code was wrong
06:52:35 <xerox> tromp, what would you suggest? My biggest problems are with those returning values, I can't find good ones.
06:52:53 <tromp> all depends on how you want to process results of match
06:53:03 <tromp> maybe you prefer match to give Bool
06:53:15 <xerox> I'd like to have "verbose" erros.
06:53:17 <xerox> *errors
06:53:27 <xerox> That's why I passed from Maybe to Error.
06:53:42 <tromp> you mean Either?
06:55:28 <xerox> yep, sorry.
06:58:10 <tromp> what about:
06:58:11 <tromp> check :: Integer -> Char -> Either String Integer
06:58:11 <tromp> check x c | c=='(' = return (x+1)
06:58:11 <tromp>           | c==')' = if x==0 then fail "oops" else return (x-1)
06:58:11 <tromp>           | otherwise = return x
06:58:11 <tromp>                                                                                 
06:58:13 <tromp> match s = do
06:58:15 <tromp>     cnt <- foldM (check) 0 s
06:58:17 <tromp>     if cnt==0 then return 0 else fail "oops"
06:59:40 <tromp> @index fail
06:59:41 <lambdabot> Control.Monad,Control.Monad.Cont,Control.Monad.Error,Control.Monad.Identity
06:59:41 <lambdabot> Control.Monad.List,Control.Monad.RWS,Control.Monad.Reader,Control.Monad
06:59:41 <lambdabot> State,Control.Monad.Writer,GHC.Base,Prelude,Monad
07:00:30 <xerox> Does it work for you?
07:06:35 <wilx> Hmm....
07:06:56 <wilx> I want my module to export all of its functions and also reexport modules that it imports.
07:06:57 <wilx> Can I do it?
07:07:56 <xerox> Maybe explicily writing which function you want to export.
07:08:49 <wilx> Isn't there some wild card for the export all thingy?
07:09:56 <Lunar^> wilx: module Ex ( module Foo ) where ... import Foo ...
07:10:21 <wilx> Yup.
07:10:23 <wilx> Found out.
07:10:40 <wilx> module Foo ( module Bar, module Foo ) where ... works fine :)
07:13:05 <xerox> Thanks tromp.
07:15:04 <musasabi> Why do nhc98 1.18 compiled programs claim "OS allocated a heap in high memory (>0x80000000)" and die instantly on i386 linux?
07:15:06 <xerox> tromp, it's nice how check's x and c can be of different types, while folding.. !
07:16:05 <xerox> tromp, return stands for Right and fail for Left ?
07:19:56 <tromp> yep
07:20:12 <xerox> Right 0 is kinda bad, tought :)
07:20:54 <tromp> normally you'd get some result out of the parsed expression
07:21:31 <xerox> tromp, what do you mean?
07:22:18 <tromp> you'd have Right Expr where Expr encodes arithmetic expressions for instance
07:23:06 <tromp> i mean you normally check parentheses while parsing, trying to get a parse tree result
07:23:13 <xerox> Maybe "Either String String" is not the best returning type for match.
07:23:26 <xerox> tromp, oh, yes.
07:24:11 <xerox> tromp, this code is not really suitable for that work, do you have some time to show me something that actually does something while parsing, like encoding an arithmetic expression?
07:25:11 <xerox> ..or the exercise is left to the reader? ;)
07:36:07 <tromp> you can find lotsa parsing examples on the web i suppose
07:36:55 <xerox> What can I search for?
07:36:57 <tromp> most use type ReadS a = String -> [(a, String)]
07:37:16 <tromp> google for haskell parsing ReadS :)
07:37:22 <xerox> Thank you :)
07:45:03 <Muad_Dibber> parsercombinators :)
07:45:09 * Muad_Dibber goes back to silentmode
07:46:24 <xerox> Muad_Dibber, do you have any good (simple?) reference about those? It's like the n-th time I hear of them :)
07:50:33 <wilx> @index Parsec
07:50:33 <lambdabot> bzzt
07:51:29 <Muad_Dibber> i'm not sure but check this one out: http://www.cs.lth.se/EDA120/assignment4/parser.pdf
07:51:31 <Muad_Dibber> might be nothing
08:11:04 * Lemmih wishes GHC would do a better job at not linking unused code into binaries.
08:11:55 <Lunar^> Lemmih: you could try with split_objs
08:12:20 * Lemmih googles.
08:13:09 <Lemmih> How does it work and how do I use it?
08:13:25 <lightstep> section 4.10.7 in the user manual
08:14:17 <Lemmih> Thanks.
08:17:19 <Lemmih> Is there a more detailed description somewhere? The user manual only tells me that it split objects and that I shouldn't use it (:
08:18:11 <lightstep> rumor says it's related to -fglobalise-toplev-names
08:19:03 <lightstep> but only wizards ever use /that/ option
08:19:43 <desrt> Lemmih; splitobjs is just a hack to be used when building the system libraries
08:19:56 <desrt> so that the static linker can do a better job of dead code stripping
08:20:10 <desrt> it automatically affects the programs you link in a big way
08:20:24 <desrt> (since you only link against parts of the system libraries now instead of the whole mess)
08:20:36 <xerox> Muad_Dibber, there is some code that doesn't compile in that (nice) pdf :(
08:20:58 <stepcut> sweet! macromedia updated the .swf for flash 7
08:21:00 <desrt> the only time you'd want to care aobut splitobjs is on your own (large) binaries
08:21:04 <desrt> s/binaries/libraries/
08:22:11 <lightstep> 
08:22:16 <stepcut> looks like they even fixed the errors in the docs :)
08:22:17 <gzl> stepcut: in what way?
08:23:11 <stepcut> gzl: in atleast two cases, they gave the wrong hex code for an opcode, they copied a previous section and forgot to update the field
08:23:14 <Lemmih> I'm using a TH library to generate FFI code. The library isn't touched after the FFI code is generated but still I have to link with template-haskell and the TH lib.
08:23:32 <gzl> stepcut: ah, ok
08:23:32 <stepcut> gzl: and, there was one table that was horribly mis-formatted'
08:23:50 <Lemmih> Which makes small bindings a lot bigger.
08:23:52 <stepcut> and, I now know what the new opcodes for flash7 are :)
08:24:37 <stepcut> it now has exceptions (at the vm level)
08:25:42 <tic> would this be correct to say? f :: Int -> Int -> Int -> Int is the same as:  f :: ((Int -> Int) -> Int) -> Int ?
08:26:02 <Lemmih> tic: No.
08:26:15 <tic> Lemmih, what's the first statement equivalent to?
08:26:23 <lightstep> f :: Int -> (Int -> (Int -> Int))
08:26:29 <Lemmih> tic: What lightstep said.
08:26:43 <tic> Hm.  Ah, that actually makes more sense.
08:27:00 <tic> Okay, I was thinking right, just didn't express myself correctly. thanks. ):
08:27:01 <tic> :)
08:27:36 <tic> (f returns a function that takes one less parameter each call)
08:27:53 <tic> (kind-of. again, not being very clar)
08:27:55 <tic> clEar.
08:28:24 <lightstep> schonfinkelling is so stupid
08:29:39 <gzl> it sounds a little less stupid if you just call it currying
08:29:41 * gzl ducks
08:30:38 <lightstep> we already name things Haskell and Brooks. he's got enough praise
08:30:53 <Heffalump> what do we call Brooks?
08:30:56 <musasabi> Lemmih: if you find a solution for that please tell me too...
08:31:45 <Muad_Dibber> xerox : i'm not affiliated to that pdf in anyway, just found it via google ;)
08:31:45 <lightstep> it's impolite to address him by first name, so we address him by his middle name
08:35:51 <xerox> Muad_Dibber, uh :))
08:36:05 <xerox> Muad_Dibber, I think it was my error, btw (#) :: .. seems to give problems.
08:58:05 <xerox> How to define a Monad instance of "type Parser a = String -> Maybe (a, String)" ?
08:58:22 <autrijus> instance Monad (Parser a) where ...
08:58:30 <bourbaki> who was it again who did that fuild dynamics simulation in haskell?
08:58:55 <lightstep> instance Monad Parser where {...}
08:59:09 <xerox> autrijus, this way raises a kind error
08:59:13 <lightstep> since Parser is the parameteric type
08:59:23 <autrijus> ah right.
08:59:32 <lightstep> (Parser a) is of king *, and Parser is of kind * -> *
08:59:32 <xerox> lightstep, this way says: "Type synonym `Parser' should have 1 argument, but has been given 0"
08:59:50 <xerox> :\ I understand, but I don't know how to fix.
09:00:02 <lightstep> the haskell standard allows you to declare synonims as instances
09:00:19 <lightstep> but you never ever want to do it. only algebraic datatypes, and newtypes
09:00:34 <xerox> Maybe glasgow extension are messing it up?
09:01:03 <lightstep> no, the syntax doesn't allow Parser to ever appear alone (iirc)
09:01:26 <xerox> So, there is no way?
09:01:56 <lightstep> i'm almost gertain that some extension allows it
09:02:17 <lightstep> but the solution is to define Parser ad `data', not as `type'
09:02:20 <wilx> Gertain, how certain is that? :)
09:02:35 <lightstep> which has the extra benefit that your program would be more typesafe
09:03:07 <lightstep> wilx, not very much. my keyboard skills are worsening every day
09:03:14 <wilx> :)
09:03:26 <xerox> But it gives a parse error on `->' (in line "data Parser a = String -> Maybe (a, String)")
09:03:53 <wilx> (...)?
09:04:01 <xerox> I added it
09:04:13 <lightstep> xerox, yes, you must have a constructor on a `data' declaration
09:04:22 <wilx> Oh, right.
09:04:23 <musasabi> Is there really no method to read n-bytes from a handle? (\n -> replicateM n getChar) ?
09:04:33 <musasabi> s/getChar/hGetChar
09:04:55 <wilx> hGetBuf something?
09:05:18 <xerox> lightstep, hmm, I can't get it.
09:05:40 <lightstep> like data Maybe a = Nothing | Just a
09:05:46 <lightstep> Nothing and Just are constructors
09:06:13 <xerox> data Parser a = Parser (String -> Maybe (a, String))
09:06:21 <lightstep> exactly
09:06:36 <xerox> ? But it gives me error with all the function :: Parser .. previously defined.
09:06:52 <autrijus> I use hGetBuf.
09:07:05 <wilx> So do I.
09:07:06 <lightstep> yes
09:07:21 <autrijus> hGetBuf is fast and nice.
09:07:33 <wilx> Nice? The Ptr a thingies are pita.
09:07:45 <autrijus> try writing that in C.
09:07:49 <autrijus> ;)
09:08:16 <lightstep> xerox, the types changed. before, Parser was just a synonym, so the types were expended to String -> Maybe (a, String), and not the expanded types are Parser a. so you need to add the word Parser to a lot of places to fix it
09:08:27 <wilx> What bugs me is that I have to do my own free.
09:08:41 <autrijus> wilx: what?
09:08:41 <wilx> I haven't figured out how to force GHC take care of the memory.
09:08:44 <autrijus> ouch.
09:08:52 <autrijus> never free it by yourself.
09:08:56 <lightstep> xerox, also see this:
09:09:01 <lightstep> @wiki NotJustMaybe
09:09:01 <lambdabot> http://www.haskell.org/hawiki/NotJustMaybe
09:09:55 <autrijus> I always use
09:09:55 <autrijus> withForeignPtr
09:10:12 <autrijus> and finalizers.
09:10:45 <wilx> @index malloc
09:10:45 <lambdabot> Foreign,Foreign.Marshal,Foreign.Marshal.Alloc,MarshalAlloc
09:11:00 <autrijus> see http://svn.openfoundry.org/openafp/OpenAFP/Internals/Binary.hs
09:11:07 <autrijus> grep for hGetBuf
09:11:08 <musasabi> wilx: alloca may help.
09:11:15 <xerox> lightstep, mmm, I try. Maybe it would be simpler to search for the extension. But I try :)
09:11:21 <musasabi> or more precisely allocaBytes
09:11:23 <autrijus> I use the  mallocForeignPtrBytes  ==> withForeignPtr  chain
09:11:43 <autrijus> and when absolutely neccessary to malloc by myself, I use
09:11:51 <autrijus> withForeignPtr  ==> addFinalizer  touchForeignPtr
09:12:00 <autrijus> that way it's always destroyed on time.
09:12:51 <autrijus> it took me ~3 days to grok all this, though.
09:12:52 <lightstep> xerox, writing a parser with Maybe is probably the best way to learn about parsers
09:12:56 <autrijus> now it makes perfect sense.
09:13:18 <autrijus> but for simple uses, allocaBytes is all you need/.
09:13:45 <_Codex> I dont really see the need to use custom memory allocation.
09:14:05 <xerox> lightstep, I don't follow you completely, in any case Maybe is involved (using data or type)
09:14:23 <autrijus> _Codex: when speed and memory use is top priority, there's little other choices.
09:14:40 <autrijus> OpenAFP is essentially using GHC for things normally done in C.
09:14:59 <autrijus> (and the result is often faster than C, much to my surprise.)
09:15:26 <lightstep> xerox, i meant to say that is this is your first monadic parser library, and you write it for educational or recreational purposes, using the technique from that wiki page is irrelevant (might be unhelpful)
09:15:27 <wilx> @index ind
09:15:27 <lambdabot> bzzt
09:15:37 <wilx> @index  touchForeignPtr
09:15:38 <lambdabot> Foreign,Foreign.ForeignPtr,GHC.ForeignPtr,ForeignPtr
09:16:20 <xerox> lightstep, ah! Okay.
09:16:57 <xerox> lightstep, but how to change "char :: Parser Char; char (c:cs) = Just (c,cs); char [] = Nothing" to accomplish to the new definition of Parser, with data?
09:18:23 <lightstep> you need to encapsulate the function in a Parser constructor
09:18:32 <autrijus> so what's the preferred way to read UTF8 into String nowadays?
09:19:19 <xerox> lightstep, the returning value?
09:20:01 <wilx> Hmm, the problem with ForeignPtr is that I wanted to use the storage for hGetBuf and that takes Ptr and I didn't want to use that unsafe* thingy to cast it.
09:20:05 <lightstep> xerox, to create a Parser value from the parsing function, you need to invoke Parser (the value constructor) on it
09:20:16 <icb1> done compiling, putting up the binary
09:21:07 <lightstep> xerox, so you need to create a temporary binding that contains the old function, and then encapsulate it in a Parser
09:24:08 <xerox> lightstep, with temporary binding you mean something like the old "type Parser" ?
09:25:05 <lightstep> yes
09:25:17 <lightstep> with a value like the old `char'
09:26:17 <lightstep> "an enormous challenge -- create a programing language better than Java". lol
09:27:02 <Cale> lightstep: what are you quoting there?
09:27:07 <_Codex> lightstep: that's quite difficult, if better means "how many people use it" :)
09:27:14 <lightstep> Guy Steele, on lambda-the-ultimate.org
09:27:34 <tromp> the language is so-so, but the tools available are really good
09:28:58 <tromp> and it doesn't slow your code by a factor of 60:)
09:29:26 <xerox> lightstep, what about:
09:29:28 <xerox> type Parser a = String -> (a,String)
09:29:28 <xerox> data ParserType a = ParserType a
09:29:28 <xerox>  
09:29:28 <xerox> char (c:cs) = ParserType (Just (c,cs))
09:29:28 <xerox> char []     = ParserType Nothing
09:29:28 <xerox>  
09:29:36 <xerox> ( sorry for flooding :( )
09:30:30 <lightstep> it won't typecheck
09:30:44 * xerox is lost
09:30:48 <lightstep> actually, it will
09:30:54 <lightstep> but probably not the way you want
09:31:20 <xerox> data ParserType a = ParserType (Parser a) =
09:31:26 <xerox> s/=/\?/
09:31:30 <lightstep> that's more reasonable
09:31:47 <lightstep> now it really won't typecheck
09:32:11 <lightstep> a ParserType now contains a function
09:32:14 <xerox> Before, I got char :: forall a. [a] -> ParserType (Maybe (a, [a]))
09:32:25 <tromp> you should not put the Maybe inside the Parsertype!
09:32:30 <xerox> That worked.. now does'nt even work, what I'm missing?
09:32:44 <xerox> Ah.
09:33:04 <tromp> normally one has newtype Parser a = String -> [(a,String)]
09:33:04 <lightstep> the function really does the parsing work, so you need to wrap the function in ParserType, not the rhs expression
09:33:17 <tromp> with a Maybe instead of a List monad, it becomes
09:33:31 <tromp> newtype Parser a = String -> Maybe (a,String)
09:33:34 <lightstep> tromp, this is not legal haskell (you need a data constructor)
09:33:51 <tromp> oops, put it in the dummy constructor there:)
09:34:35 <lightstep> the only difference between this and a `data' declaration is strictness issues
09:34:56 * lightstep has a you sister that urges him to go to dinner
09:40:09 <Remii> hi
09:42:47 <bringert> hi
09:59:03 <tromp> afk
10:01:00 * Lemmih wonders how shapr can unicycle in a subzero environment.
10:16:32 * Remii wonders whether Lemmih ever (=today) plays bzflag
10:18:31 * Remii clearly hasn't woken up yet as he just thought he couldn't spell his name
10:21:59 <Ruller> Hello, true coders!
10:22:41 <Ruller> may I join your community?
10:22:44 * Remii wonders whether that includes me
10:22:56 <Remii> you already seem to have done so
10:23:01 <Ruller> thank you!
10:23:22 <bringert> Ruller, first you must answer these questions three!
10:23:45 <bringert> well, not really
10:24:03 <Remii> errr, aren't you confused with some python channel? ;)
10:24:08 <Ruller> I read the tutorial from the page, but I cannot code well yet
10:24:27 <Ruller> python was my working language for all purposes
10:24:34 <bringert> hej chucky
10:24:47 <Ruller> chucky: welcome!
10:24:49 <tromp> u're not the first to move from python to haskell
10:24:55 <Heffalump> ruller: ooh, dunno, it'll cost ya
10:25:14 <Heffalump> hmm. Bit late to be extorting money, really, since you've already let him in...
10:25:43 <Ruller> Heffalump: =)
10:25:52 <bringert> we even went to EuroPython and put up Haskell posters
10:26:02 <Ruller> cool idea! :))
10:26:10 <bringert> it was it the next building though
10:26:18 <Remii> lol
10:26:35 <bringert> speaking of which, who's up for EuroHaskell?
10:26:51 <bringert> is shapr off unicycling again?
10:27:45 <Remii> in a subzero environment?
10:27:55 <bringert> I'd guess so
10:28:00 <bringert> where else would he go?
10:28:54 <Remii> a superzero environment?
10:29:09 <bringert> where would he find one of those?
10:29:39 <Remii> errr
10:30:07 * Remii gives up trying to pretend he knows what's being talked about ;)
10:30:46 <bringert> Remii, shapr lives in Boden, in northern Sweden
10:30:50 <Remii> *gets it*
10:31:05 <bringert> and he likes to unicycle
10:31:26 <Remii> with snow chains?
10:31:59 <Heffalump> where would EuroHaskell be?
10:32:09 <Lemmih> Remii: I played bzflag earlier today.
10:32:11 * Heffalump thinks doing something attached to ICFP would be good.
10:32:13 <bringert> http://andersca.org/gallery/eurohaskell/p1010015
10:32:26 <bringert> shapr riding a unicycle and talking about monads
10:32:37 <bringert> Heffalump, good idea
10:32:38 <Heffalump> I know that's what happened last time.
10:32:46 <Heffalump> I was asking about next time :-)
10:33:01 <Remii> Lemmih: I probably saw you today then :)
10:33:35 <bringert> hmm, doing it in Tallinn would mean that we'd have to get local organizers
10:33:36 <Lemmih> Remii: What alias do you play with?
10:33:47 <bringert> in Göteborg we've got that down
10:33:53 <Remii> Lemmih: I was playing as "Moi" today, for lack of imagination
10:34:00 <bringert> anyone in here from Tallinn?
10:34:47 <Lemmih> Remii: Feel free to notify me if you want a rematch (:
10:36:07 <Remii> Lemmih: Actually, the only thing I remember about that level is that I was wondering whether that was you. Could be repressed memories though
10:39:40 * Lemmih vaguely recalls a rogue named "Moi".
10:42:25 * Remii wonders why, in GHC, it's ByteArr# in the source (e.g. PrimOps.cmm) and ByteArray# when importing
10:45:04 * Lemmih feels like playing bzflag again.
10:45:20 * Remii tries to resist the temptation
10:45:50 * Remii is trying darcs and hacking ghc for the first time simultaneously
10:47:23 <Ruller> I'm for EuroHaskell in Berlin
10:47:23 <Ruller> :)
10:47:49 <musasabi> Sweden is a good compromise.
10:47:53 <Ruller> ok
10:48:33 * Remii votes for amsterdam
10:48:51 <Remii> which, obviously, is a compromise between sweden and rotterdam
10:48:58 * Heffalump suggests Cambridge.
10:49:04 <Heffalump> which isn't a compromise of any form :-)
10:49:23 <Remii> hm, the simons can probably get their tickets paid for by microsoft, I cannot ;)
10:50:05 <Igloo> I doubt they'll turn up unless it's in Cambridge
10:50:25 <chucky> hi ruller and bringert. Sorry for the late answer. :)
10:50:36 <chucky> and everyone else
10:52:54 * Ruller kisses chucky 
10:53:08 <chucky> oh wow. :)
10:53:18 <chucky> umm... Thanks I guess
10:53:26 <Ruller> :))
10:54:55 * chucky contemplates: Should I spend the week hacking Darcs or study for the exam I'm probably gonna fail anyway? :)
10:55:25 <sh10151> what's the exam in?
10:55:49 <chucky> mathematical statistics
10:55:55 <mflux> and what's the current propability and how much do you expect to be able to affect it?-)
10:56:38 * Remii goes to dinner
10:56:40 <Remii> ttyl
10:57:04 <sh10151> mathematical statistics?
10:57:07 <Ruller> good appetite, Remii
10:57:22 <sh10151> is that more mathematics than statistics I hope?
10:57:25 <chucky> mflux: :) Good question
10:57:26 <mflux> maybe if you can calculate that you should consider studying
10:57:37 <chucky> probably
10:57:40 <Remii> thx
10:58:19 <chucky> sh10151: If I could answer questions like that, I would probably have better chances to pass. :)
11:01:29 <bringert> chucky, graduating is pretty nice
11:01:39 <bringert> as is darcs hacking I guess
11:04:03 <chucky> bringert: :) Thing is, there's a new chance after easter
11:04:17 <bringert> ah, right
11:04:48 <chucky> so not studying now would only mean I would have to study some more later, nothing more serious. :)
11:14:28 * genoff hi all
11:15:20 <Oejet> Hello, genoff.
11:15:29 <genoff> ^^ hello
11:15:52 <Oejet> Looking to sharpen your Haskell skills?
11:15:54 <Ruller> Welcome, dear genoff!
11:16:20 <genoff> something like that, Oejet ;)
11:16:23 <genoff> thanks Ruller
11:17:18 <Oejet> genoff: What do you want to know about?  The FFI, STM, GADT,...?
11:19:09 <genoff> I've just begun to learn Haskell.. I joined this chan just once or twice and I went really amazed
11:20:02 <genoff> would love to learn everything I could
11:21:38 <Gahhh> genoff, have you read the online tutorials ? any questions ?
11:22:23 <genoff> no I haven't read them
11:25:23 <icb1> where do i submit binaries packages of GHC?
11:27:26 <lightstep> the gentle introduction is cool, if you already know some functional language
11:29:03 <lightstep> is there wxhaskell for ghc 6.4?
11:30:27 <Ruller> I don't know, really
11:31:13 <Heffalump> someone could try to build it
11:40:58 <lightstep> is unicode support better in ghc-6.4 than in ghc-6.2.2?
11:52:25 <Oejet> lightstep: I'm trying to build WxHaskell 0.9 for GHC 6.4 right now.  Stay tuned.
11:53:28 <musasabi> icb1: you post a link to e.g. glasgow-haskell-users
11:54:12 <musasabi> that is if you have a ghc build for a platform afaik
11:57:38 <lightstep> what is an orphaned instance?
12:00:08 <lightstep> (as in ghc's error messages)
12:02:07 <stepcut> the binary parser in house looks neat
12:02:45 <_mordechai> rehi :)
12:16:26 * Remii finished his dinner
12:17:04 <Remii> continues his first private GHC hacking party
12:18:41 <Oejet> lightstep: WxHaskell 0.9 failed to compile on GoboLinux with GHC 6.4 with the error: "Could not find module `Map'".
12:19:11 * lightstep doesn't have the source
12:19:18 <lightstep> i heard it's Data.Map?
12:20:43 <Lemmih> Oejet: I overcome that by runing make several times.
12:21:07 <xerox> Are there anything like SICP video lectures.. about Haskell? It would be fun to watch.
12:21:14 <Lemmih> lightstep: wxHaskell is distributing Data.Map as Map since Data.Map is only in GHC 6.4 which wxHaskell doesn't support.
12:22:10 <lightstep> oh
12:26:16 <icb1> alright, thanks wasa
12:30:04 <Oejet> Lemmih: Recompiling for the fourth time...
12:37:13 <Lemmih> Oejet: Does it get any further?
12:37:56 <Oejet> Lemmih: Still recompiling over and over. :-P
12:38:03 <Oejet> But it progresses.
12:38:33 <CosmicRay> metaperl: nice post on the sequence.  I went ahead and promoted it to the front page (even though blog posts normally aren't.)
12:43:19 <ibid> good evening :)
12:49:46 <Oejet> Lemmih: I didn't quite understand why WxHaskell cannot compile with GHC 6.4.  Is it because 6.2 excludes 6.4 compilation?
12:50:19 <autrijus> pugs 6.0.11 out with ghc 6.4 support:
12:50:25 <autrijus> http://autrijus.org/dist/Perl6-Pugs-6.0.11.tar.gz
12:50:27 <wilx> Hmm....is there something like null STRef?
12:50:34 <autrijus> however GHC's unicode support appears borken on osx :-/
12:50:54 <lightstep> wilx, with unpredictable semantics and all the rest?
12:51:11 <wilx> Unpredictable? :)
12:51:36 <wilx> I would accept error "You are stupid." on readSTRef'ing null ref.
12:52:04 <lightstep> i don't think ghc has it
12:52:23 <wilx> I can't find it either.
12:54:18 <Lemmih> Oejet: I can compile alright but it's not cabalized.
12:57:41 <metaperl> CosmicRay, thanks
13:09:33 <stepcut> ok, I think it is nearly time to write a macro expander for my scheme compiler
13:10:43 <CosmicRay> heh
13:10:53 <CosmicRay> I feel left out.  I have never written a scheme compiler.
13:11:01 <CosmicRay> MegaMonad: have you written a scheme compiler?
13:11:01 <MegaMonad> CosmicRay: This friend of me to a haskell to scheme should be written without?
13:12:21 <stepcut> CosmicRay: this is my first :p
13:12:50 <stepcut> and I started it 1.5 years ago ;)
13:14:31 <stepcut> I can now compile all (7) primitive expressions -- but if I write a macro expander, it should be easy to add the derived expressions, since they are defined in r5rs already ;)
13:14:48 <CosmicRay> heh
13:15:10 * ibid has started several scheme implementations, but they always collapse in their own impossibility
13:15:16 <stepcut> heh
13:16:10 <ibid> namely, i hate *writing* scheme, and whatever idea i start witth, i always eventually end up with the notion that i should write a scheme compiler in scheme
13:17:22 <stepcut> I don't know that I will enjoy writing in scheme much either, but writing the compiler will give me enough experience to write a compiler for a language I like better :)
13:19:18 <ibid> i've went down the same thinking
13:19:29 <ibid> and i love scheme, i just hate *writing* scheme :)
13:20:36 <ibid> but even if i start with a simple scheme interpreter in some other language, i end up with, say, a bytecode interpreter and a scheme-to-bytecompiler-in-scheme
13:20:58 <X-Scale> ibid: it depends on the editor...writing directly into text file won't be a nice experience....writing scheme in DrScheme is easy IMHO
13:21:18 <ibid> X-Scale: i write in emacs, which is supposed to be a good lisp editor :)
13:22:33 <X-Scale> have you ever tried doing it in DrScheme ?
13:23:34 <ibid> i've looked at drscheme
13:23:52 <ibid> i had even looked at packaging it, years ago
13:24:02 <xerox> Emacs, Emacs, & Emacs.
13:24:22 <_mordechai> man emacs
13:24:26 <_mordechai> actually
13:24:32 <ibid> xerox: hm?
13:24:40 <Remii> *joy*
13:24:51 <_mordechai> http://www.cs.bell-labs.com/magic/man2html/1/emacs
13:25:03 <Itkovian> @seen boegel
13:25:03 <lambdabot> I saw boegel leaving #haskell 1 day 9 hours 12 minutes 21 seconds ago.
13:25:06 * Remii just found out why his /var/tmp/ghc-6.4% grep -rls quotInteger | grep -v _darcs > /tmp/quot
13:25:06 <Remii>  took so long, while it needed to grep only ~800Mb
13:25:31 <stepcut> ibid: In my implementation, the parser, macro-expander, and primitive expression -> byte-code compiler are written in haskell -- the derived expressions will probably be implemented as scheme macros (atleast for now)
13:26:31 <stepcut> of course, the primitive->byte-code compiler is all of ~40 lines :p
13:26:37 <xerox> ibid, Emacs is really good for writing lisp.
13:27:00 <sh10151> ibid: look at quack.el
13:27:34 <sh10151> http://www.neilvandyke.org/quack/
13:27:53 <stepcut> unfortunately, I must do my taxes before I can do the macro expander :-/
13:28:18 * ibid is currently doing an experimental language
13:30:59 <metaperl> stepcut, www.turboxtax.com worked great for me
13:31:03 <metaperl> I've used them for 3 years now
13:32:24 <ibid> originally, it was about trying out the ideas from polyphonic c# in a different setting (that's based on the join calculus)
13:36:37 <stepcut> metaperl: I have to do partnership taxes (1065), which is an *extra* $90 for federal and $35 for state
13:36:48 <metaperl> oh
13:37:02 <stepcut> and I only had, like $10 in revenue this year ;)
13:37:36 <ibid> the state does my taxes :)
13:59:38 <Remii> does anyone here have experience with adding new PrimOps to GHC?
14:14:44 <Remii> hm, does that mean "no"
14:14:46 <Remii> ?
14:15:12 <Lemmih> You can ask JaffaCake when he gets around (:
14:15:30 <Remii> I will
14:15:38 <Remii> if I'm still awake then ;)
14:16:24 * Lemmih has seen him online twice in the last year.
14:16:46 <Remii> aiks
14:17:06 <Lemmih> E-mailing ghc-users might be faster.
14:17:13 <Remii> I guess so
14:17:57 * Remii is trying to figure out whether he's going to be capable of working on GHC's Integer (GMP) implementation
14:18:17 <Remii> but right now not even capable of adding a primop exactly 100% equal to quotInteger# ;)
14:19:06 <musasabi> Remii: well the source is quite clean.
14:19:26 <Remii> no, it's haskell
14:20:03 <Maddas> heh
14:20:25 <musasabi> :-)
14:20:53 <Remii> unfortunately, the comments about adding them seem to be out-of-date (well, that's the least my messing around should achieve: some patches with new comments ;))
14:22:11 <Remii> and I can't get the thing to compile yet, so I'll probably have to mess around some more
14:22:31 <astrolabe> hello, I'm a haskell newbie.  Would it be ok for me to ask an elementary question here?
14:22:38 <musasabi> astrolabe: yes.
14:22:39 <Remii> of course
14:22:40 <_JusSx_> yeah
14:22:45 <ibid> astrolabe: don't ask for permission to ask, ask the question
14:22:46 <_mordechai> :)
14:23:43 <astrolabe> I'm getting an error "Cannot build superclass instance".  The instance is Ord P and the required superclass is Eq P
14:24:10 <astrolabe> I think I've defined compare for P
14:25:05 <Remii> could you post the failing snippet on http://www.haskell.org/hawiki/HaskellIrcPastePage ?
14:25:21 <lisppaste2> metaperl pasted "confused on definition of Stack." at http://paste.lisp.org/display/6576
14:25:52 <metaperl> Remi, paste.lisp.org/new/haskell is much nicer IMHO
14:26:36 <metaperl> could someone help with my stack question please?
14:27:35 <ibid> metaperl: how is Stk defined?
14:28:10 <astrolabe> Thanks Remii.  I've done that.
14:28:16 <ibid> metaperl: note that usually pop does not return the element it removes from the stack
14:28:55 <ibid> metaperl: and - not knowing how Stk or push is defined, this is just a guess - it returns the "new version" of the stack, not the bottom of it
14:29:12 <Remii> astrolabe: when, in either hugs or ghci, you type :i Ord, you'll see that it's a sub typeclass of Eq
14:29:28 <Remii> which means that you'll _have_ to have an instance for Eq if you want an instance for Ord
14:29:46 <ibid> which sucks if you define compare :)
14:29:54 <ibid> since (==) should be inferred from that
14:30:08 <ibid> like the other infix comparators
14:31:05 <Remii> well, I guess that with -fallow-undecidable-instances one _could_ define instance Ord a => Eq a, though I have no idea whether that would actually do the wanted thing
14:31:17 <astrolabe> ibid, does "should" mean there is a problem with Hugs or with the definition of Haskell?
14:31:35 <metaperl> ibid, thanks... I did not know that
14:31:49 <ibid> astrolabe: from those two, the latter
14:32:15 <ibid> astrolabe: though it does not completely agree with my position :)
14:32:44 <ibid> astrolabe: and i understand the tradeoff
14:33:01 <Remii> {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances #-}
14:33:01 <Remii> data P = A | B
14:33:01 <Remii> instance Ord P where
14:33:01 <Remii>     compare A A = EQ
14:33:01 <Remii>     compare A B = GT
14:33:01 <Remii>     compare B A = LT
14:33:03 <Remii>     compare B B = EQ
14:33:06 <Remii> instance Ord a => Eq a where
14:33:07 <Remii>     x == y = compare x y == EQ
14:33:28 <ibid> does that work?
14:33:31 <Remii> the cost seems to be rather heavy
14:33:32 <Remii> it does
14:33:39 <ibid> cost in what sense?
14:33:45 <Remii> *Main> A == B
14:33:45 <Remii> False
14:33:45 <Remii> *Main> A == A
14:33:45 <Remii> True
14:34:00 <Remii> in the sense that one has to allow overlapping instances
14:34:07 <ibid> metaperl: "that" being which of the two? :)
14:34:41 <ibid> Remii: is faui indispensable?
14:34:57 <metaperl> I didnt know that pop() did not return the element it popped. In Perl, popping an array returns the element, sicne the array stays memory-resident. I understand why haskell must do it the other way as it maintains no statate
14:35:07 <Remii> faui = allow-overlapping?
14:35:11 <Remii> AFAIK: yes
14:35:32 <ibid> Remii: -FAllow-Undecidable-Instances
14:35:39 <ibid> ie. faui :)
14:35:45 <Remii> ahh
14:35:48 <Remii> *tries*
14:36:01 <Remii>     Illegal instance declaration for `Eq a'
14:36:02 <Remii> 	(There must be at least one non-type-variable in the instance head
14:36:02 <Remii> 	 Use -fallow-undecidable-instances to permit this)
14:36:04 <Remii> I guess it is ;)
14:36:07 <ibid> :)
14:37:17 <ibid> metaperl: there is a guideline - often forgotten in popular programming - that a subroutine be either a mutator or an inspector but not both
14:37:32 <ibid> metaperl: if pop returned the element, it'd be both
14:38:14 <ibid> metaperl: there are some situations where violating the guideline is appropriate, but they are rarer than it seems
14:38:26 <metaperl> that's some great information ibid
14:38:42 <metaperl> thank you! I can hear myself arguing with the people at work about their coding style now!
14:38:47 <ibid> heh :)
14:38:54 <musasabi> metaperl: pust :: a -> Stack a -> Stack a, top :: Stack a -> a, empty :: Stack a -> Bool, pop :: Stack a -> Stack a
14:39:19 <metaperl> yes, "algorithms.." has a stack imiplementation. I am going through it now
14:40:02 <musasabi> combining top&pop is possible but not very good most of the time.
14:41:00 <nothingmuch> hola señors
14:41:06 <Remii> hi
14:41:13 <nothingmuch> we are but a few humble camelheads trying to grok pugs internals
14:41:18 <nothingmuch> we have gotten pretty far
14:41:21 <nothingmuch> but have run into a wall
14:41:28 <nothingmuch> is 'asks' something builtin?
14:41:32 <nothingmuch> if so, what does it mean?
14:41:45 <nothingmuch> it seems not to be
14:41:53 <nothingmuch> because :t asks in ghci says it's not there
14:41:58 <musasabi> @index asks
14:41:58 <lambdabot> Control.Monad.RWS,Control.Monad.Reader
14:42:10 <nothingmuch> ah, this gets interesting
14:42:30 * Remii wishes if was a normal function, if only for the nice questions we'd get
14:42:43 <nothingmuch> errm
14:42:47 <lumi> Morning
14:42:55 <musasabi> @type Control.Monad.Reader.asks
14:42:57 <lambdabot> Control.Monad.Reader.asks :: forall a m r.
14:42:57 <lambdabot> 			     (Control.Monad.Reader.MonadReader r m) =>
14:42:57 <lambdabot> 			     (r -> a) -> m a
14:43:21 <lightstep> it gets the environment, runs the functions on it, and binds the result
14:43:29 <musasabi> yes.
14:43:54 <nothingmuch> lightstep: could you help us track down what envCaller means in src/Eval.hs?
14:45:00 <lightstep> in findVar?
14:45:05 <nothingmuch> uhuh
14:45:29 <nothingmuch> and what is it's relation to caller n in Monads.hs
14:45:33 <nothingmuch> line 197
14:46:15 * Remii downloads pugs
14:46:29 <lightstep> and only yesterday you asked what id is good for...
14:46:44 <Remii> lightstep: me?
14:46:58 <lightstep> no, nevermind
14:47:27 * Remii has a vague feeling he'd do well to think of a nick which isn't already taken
14:48:04 <lightstep> to my
14:48:07 <lightstep> ugh
14:51:12 <xerox> 'night folks.
14:51:28 <astrolabe> Thanks for your help Remii and ibid.  I'm not sure what I should be doing with    {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances #-}    though
14:51:29 <Remii> night
14:51:39 <Remii> astrolabe: nothing
14:52:06 <ibid> astrolabe: don't :)
14:52:08 <Remii> you should just define an instance for Eq (either with a manual "instance Eq P ..." or a "deriving Eq")
14:52:15 <boegel> @seen shapr
14:52:15 <lambdabot> I saw shapr leaving #darcs 1 day 8 hours 12 minutes 8 seconds ago.
14:54:13 <Remii> isn't it lovely?
14:54:14 <Remii> /tmp/ghc11930.hc: In function `GHCziPrimopWrappers_callzugmpzutake2zuret1zh_entr
14:54:15 <Remii> y':
14:54:15 <Remii> /tmp/ghc11930.hc:5091: error: `callzugmpzutake2zuret1zh_fast' undeclared (first
14:54:15 <Remii> use in this function)
15:01:30 <astrolabe> Hmmm.  It is saying -- Overlapping instances for
15:01:30 <astrolabe>  class "Eq"
15:01:55 <astrolabe> I think maybe I should do more reading before I try to start programming :(
15:02:54 <Remii> I guess it's not that bad
15:03:14 <Remii> did you copy the instance Ord a => Eq a where
15:03:15 <Remii> <Remii>     x == y = compare x y == EQ example?
15:03:51 <astrolabe> I've included those lines, yes.
15:04:00 <Remii> you shouldn't ;)
15:04:16 <astrolabe> LOL
15:04:21 <ibid> astrolabe: it was a game Remii and i played, a game of "can you do that"
15:04:25 <Remii> sorry, but that was my confusing reply to ibid about some technical thing
15:04:27 <Remii> indeed
15:04:28 <ibid> astrolabe: was not intended for serious use :)
15:04:53 <Remii> what you _should_ do is defining an instance of Eq for P
15:05:08 <ibid> agreed
15:05:43 <Ruller> I'm so tired...
15:05:51 <Ruller> Good night, my new friends!
15:05:56 <Remii> bye
15:06:07 <Ruller> all be fine!
15:06:24 <ibid> yeah, sleep sounds good
15:06:33 <Remii> oh, and remove the typesignature from the Ord instance, as it's not permitted in instance declarations
15:06:44 <ibid> argh, it's 1am and i need to be up at around 6am
15:06:53 <Remii> that sucks
15:07:21 <Remii> it's 0am here and I need to be up at ~7.30, so it's not that bad here yet
15:07:44 <ibid> i'll be giving a lecture at 10am which still needs a lot of preparation work
15:07:48 <ibid> that's why 6am
15:08:28 <ibid> (on formal models of concurrency. i think i'll concentrate on CSP and the join calculus)
15:08:29 <Remii> good night then I guess...
15:08:34 <ibid> yeah
15:08:48 <ibid> sleeep
15:08:52 <ibid> see you tomorrow :)
15:08:56 <ibid> or today, whatever
15:08:56 <boegel> bye ibid and good luck
15:09:01 * Remii doesn't think your lectures are reachable for me to hear more about the join calculus
15:09:15 <Remii> goodnight & good luck tomorrow then
15:09:46 <ibid> (and i can't wait for tuesday)
15:10:01 <Remii> tuesday?
15:10:14 <ibid> i'll be sworn in as a lay judge, if all goes as planned
15:10:35 <Remii> :)
15:10:39 <ibid> but yeah, bbl, good night and all that
15:10:43 <Remii> bye
15:13:32 <astrolabe> Wow it works!  Thanks ibid
15:15:29 <astrolabe> Oh, and Remii if you are still there :)
15:21:39 <Remii> yes I am
15:32:35 * Remii leaves for some 20 minutes or so
15:43:48 <lightstep> MegaMonad, what do you think about the Pugs implementation effort?
15:43:49 <MegaMonad> lightstep: I could work on free/openbsd since they added all that effort to get something good or bad id have to compile that header to get an error "cannot build superclass instance". The instance is in implementation.
15:44:32 <lightstep> MegaMonad, but I work on Linux, not *BSD, and I want to know about the situtation in this part of the world.
15:44:32 <MegaMonad> lightstep: Boegel agrees, but remembers igloo about the situtation in this world, and the world about those build problems?
15:45:09 <lightstep> MegaMonad, do you really think that the world revolves around build problems? What a pessimist.
15:45:09 <MegaMonad> lightstep: So it's some way to sort when it's in a world of the problems solves 90146f that, so that's no issue.
15:45:40 <lightstep> MegaMonad, I think you had a little stroke somewhere in the middle.
15:45:40 <MegaMonad> lightstep: Yellow pill puts you in the arrows anything that uses the a in the middle?
15:54:23 <wilx> Yellow pill? There is no yellow pill. Just blue and red pill :)
16:02:17 <mugwump> blue pill = alcohol.  red pill = ayahuasca
16:02:54 <icb1> http://www.cs.columbia.edu/~ji/ghc-6.4-macosx-binary.tar.bz2
16:03:02 <icb1> case anyone is interested
16:03:10 <icb1> it was setup to install in /fp
16:03:22 <icb1> so you can use it to build your own
16:04:47 <Remii> astrolabe: what's the problem?
16:05:24 <astrolabe> Oh, sorry, I was just thanking you.
16:05:44 <astrolabe> I think it is now too late for me to deal with any more bugs tonight.
16:05:53 <Remii> haha
16:05:56 <Remii> ok, np :)
16:07:49 * Remii decides it's bedtime
16:07:54 <Remii> night everyone
16:16:31 <metaperl> CosmicRay, ping?
16:47:01 <lisppaste2> metaperl pasted "help needed understanding functional implementation of a table type" at http://paste.lisp.org/display/6581
17:08:59 <Cale> metaperl: what exactly are you having trouble with there?
17:09:31 <metaperl> I'm working it out... I think I almost have it... sorry for the intrusion... I'm getting closer
17:09:50 <Cale> basically it's representing "tables" as mappings from indices (of type b) to values (of type a)
17:10:24 <metaperl> the newtype declaration is new to me... newtype Table a b   = Tbl (b -> a)
17:10:56 <Cale> You can read it as  data Table a b = Tbl (b -> a), and it will mean mostly the same thing
17:11:27 <metaperl> so Tbl is a type constructor that takes a function as an argument
17:11:35 <metaperl> value constructor sorry
17:12:15 <Cale> yeah, up to strictness, it's the same as a constructor defined using data
17:12:44 <Cale> Tbl _|_ = _|_ though.
17:13:07 <Cale> Basically, it's a renaming of the type with forced labelling of elements.
17:14:07 <Cale> newtype, unlike data, only permits a single data constructor with a single parameter
17:14:15 <wagle> cant you pattern match with Tbl _ and not diverge?
17:14:24 <Cale> no
17:14:32 <Cale> at least, according to the report
17:14:39 <wagle> which report?
17:14:46 <Cale> http://www.haskell.org/onlinereport/decls.html
17:14:52 <Cale> Unlike algebraic datatypes, the newtype constructor N is unlifted, so that N _|_ is the same as _|_.
17:15:05 <Cale> newtype cx => T u1 ... uk = N t
17:15:21 <Cale> (that's a quote from that page)
17:16:20 <wagle> i didnt see that you were doing newtype
17:17:20 <wagle> though i'm not sure why it needs to be strict even if the constructor is imaginary
17:18:26 <Cale> The idea is that the type is isomorphic to the original type, just renamed.
17:19:10 <Cale> If N _|_ was different from _|_, then T would have an extra value in it that the original type didn't.
17:20:01 <wagle> right..  problem is that bottom is a value that can be passed around
17:21:07 <wagle> but i think i can pattern match vs "x" or "N x"
17:21:33 <wagle> (i could be wrong)
17:24:50 <Cale> newtype T = N Integer
17:24:55 <Cale> f (N u) = 42
17:25:03 <Cale> then f undefined = 42
17:25:06 <wagle> bottom = bottom
17:25:06 <wagle> newtype N = N Int
17:25:06 <wagle> foo x = 1
17:25:06 <wagle> foo' (N x) = 2
17:25:06 <wagle> foo'' (N x) = x + 1
17:25:26 <wagle> foo bottom = 1
17:25:32 <wagle> foo' bottom = 2
17:26:00 <wagle> foo'' bottom = <infinite_loop>
17:26:28 <Cale> newtype T = N Integer
17:26:29 <Cale> data D = D1 Integer
17:26:29 <Cale> f (N u) = 42
17:26:29 <Cale> g (D1 u) = 42
17:26:34 <Cale> f undefined = 42
17:26:42 <Cale> g undefined = undefined
17:26:45 <wagle> oh, my example is broken
17:27:14 <Cale> because u = undefined implies N u = undefined as well
17:27:21 <Cale> and so the match succeeds
17:28:17 <Cale> but undefined /= D1 u for any u.
17:29:06 <wagle> newtypes seem staged differently than data
17:30:04 <Cale> their "constructors" are merely labels, and do not really get involved in pattern matching
17:31:45 <wagle> yeah
17:32:18 <lisppaste2> metaperl annotated #6581 with "my questions about the functional implementation of a Table" at http://paste.lisp.org/display/6581#1
17:32:43 <wagle> i think i'm claiming that by the time you can reason about bottom, N x is rewritten as x (or something like that)
17:33:33 <wagle> (ie, modulo the fact that N x has a different type than x
17:33:35 <wagle> )
17:34:28 <metaperl> Cale, I have formulated my questions now
17:35:01 <Cale> metaperl: Your questions seem to make assumptions which fail :)
17:35:13 <Cale> *Table> let nt = newTable [(1,11), (2,22), (3,33)]
17:35:13 <Cale> *Table> nt
17:35:13 <Cale> <<A Table>>
17:35:25 <metaperl> that didnt happen with ghci..
17:35:28 * metaperl tries again
17:35:31 <Cale> this is ghci
17:35:59 <metaperl> *Main> nt
17:35:59 <metaperl> Tbl [(1,11),(2,22),(3,33)]
17:36:14 <Cale> that's not even valid
17:36:28 <metaperl> that's what it showed...
17:36:31 <Cale> are you sure you're loading the right module?
17:36:34 * metaperl exits and restarts
17:37:06 <metaperl> sorry for the long paste
17:37:07 <metaperl> terry@Abulafia:~/haskell/algorithms-functional/Chapter5$ ghci table.hs
17:37:07 <metaperl>    ___         ___ _
17:37:07 <metaperl>   / _ \ /\  /\/ __(_)
17:37:07 <metaperl>  / /_\// /_/ / /  | |      GHC Interactive, version 6.2.2, for Haskell 98.
17:37:08 <metaperl> / /_\\/ __  / /___| |      http://www.haskell.org/ghc/
17:37:09 <metaperl> \____/\/ /_/\____/|_|      Type :? for help.
17:37:11 <metaperl>  
17:37:13 <metaperl> Loading package base ... linking ... done.
17:37:15 <metaperl> Compiling Table            ( ./Table.hs, interpreted )
17:37:17 <metaperl> Compiling Main             ( table.hs, interpreted )
17:37:19 <metaperl> Ok, modules loaded: Main, Table.
17:37:21 <metaperl> *Main> nt
17:37:23 <metaperl> Tbl [(1,11),(2,22),(3,33)]
17:37:25 <metaperl> *Main>
17:37:30 <Cale> uh
17:37:42 <Cale> could you cat Table.hs and make sure it matches your paste?
17:38:17 <metaperl> http://www.hcoop.net/~terry/haskell/algorithms-functional/Chapter5/
17:38:25 <metaperl> contains Table.hs and table.hs
17:38:31 <metaperl> oh you know what?
17:38:43 <metaperl> the file has all the different implementations of Table in one file
17:38:45 <Cale> ah
17:38:47 <Cale> yeah
17:38:48 <metaperl> and the latter ones use lists...
17:38:51 <Cale> yeah
17:38:54 <metaperl> ok let me separate this one out
17:38:57 <Cale> which would explain it
17:39:20 <Cale> oh
17:39:22 <Cale> and look
17:39:31 <Cale> the function implementation is commented out
17:39:51 <Cale> otherwise it wouldn't work
17:41:03 <metaperl> I cant get it to load now: http://www.hcoop.net/~terry/haskell/algorithms-functional/Chapter5/q/Table.hs
17:41:10 <metaperl> I moved it to a directory of its own
17:41:22 <Cale> first, uncomment things
17:41:26 <metaperl> :)
17:41:36 * metaperl grins sheepishly
17:41:48 <Cale> (It would be obvious that it's all commented out if you use vim or emacs with syntax colouring :)
17:42:18 <metaperl> that stuff doesnt work so well ... i use xemacs remotely on a text terminal
17:42:31 <Cale> What OS are you running?
17:42:38 <metaperl> Debian
17:42:46 <metaperl> ok
17:42:50 <metaperl> *Main> nt
17:42:50 <metaperl> <<A Table>>
17:42:50 <metaperl> *Main>
17:42:58 <Cale> hmm... vim and emacs work fine for me :)
17:43:02 <metaperl> ok so we have a functional data structure
17:43:05 <Cale> (I'm running debian unstable)
17:43:18 <metaperl> same here...
17:43:30 <metaperl> the font locking might be better in emacs than xemacs
17:43:33 <metaperl> but I dont use emacs
17:43:36 <metaperl> just xemacs
17:43:39 <Cale> hehe
17:44:00 <metaperl> I dont understand how newTable works
17:44:07 <metaperl> you see what I think newTable is doing?
17:44:38 <Cale> first of all, let's define  e = (Tbl (\_ -> error "item not found in table"))
17:44:52 <Cale> e represents the empty table
17:45:18 <metaperl> e represents what happens when the index is not found in the table
17:45:23 <Cale> let's look at what happens when you call updTable (1,"Hello") e
17:45:30 <metaperl> that can occur when the table is empty OR when the index is not found
17:45:38 <Cale> metaperl: right
17:46:01 <Cale> it returns Tbl g
17:46:11 <metaperl> ok, trivial example first
17:46:29 <metaperl> a function is returned
17:46:43 <Cale> where g j = if j == 1 then "Hello" else (\_ -> error "item not found in table") j
17:46:54 <Cale> (essentially)
17:47:04 <metaperl> yes, I understand this trivial case....
17:47:07 <Cale> okay
17:47:20 <Cale> so the table has "Hello" at 1, and error otherwise
17:47:26 <metaperl> yes
17:47:32 <Cale> the fold builds up the table in this way
17:47:53 <metaperl> I know how
17:48:10 <metaperl> but I never thought the outermost function call would fire first
17:48:12 <Cale> by repeatedly adding a single "if match then value else defer"
17:48:27 <metaperl> now something the authors said earlier is coming back to me
17:48:49 <metaperl> it has been proven that the safe way to reduce a function is via outermost function call
17:49:35 <metaperl> so is that what happens? I am used to innermost parentheses being "solved" first
17:50:20 <Cale> If there's a way that the evaluation can succeed, then it will.
17:50:44 <metaperl> yes, but do you know what I mean about outermost function avoiding infiniteloops?
17:50:53 <Cale> yes, this is laziness
17:51:05 <Cale> if I define loop = loop
17:51:15 <Cale> (that's an infinite loop)
17:51:20 <Cale> and I have, say
17:51:23 <Cale> f _ = 42
17:51:35 <Cale> then f loop = 42 as well
17:51:44 <Cale> it doesn't need to evaluate loop in order to tell that
17:51:50 <Cale> so it doesn't
17:52:06 <stepcut> uh oh, my scheme compiler might not support function currying...
17:52:49 <Cale> That's the thing I miss most when I write lisp code, is the currying.
17:53:03 <stepcut> oh ?
17:53:18 <Cale> it's so awkward to have to use lambda to wrap the call
17:54:04 <Cale> actually, the thing which annoys me most about common lisp is the need to use funcall to call functions which I pass to other functions
17:54:29 <Cale> just makes everything a little more awkward and difficult to think about
17:54:45 <Cale> (and the type system of course)
17:55:07 <Cale> but I haven't given lisp types enough of a chance yet, so I don't know
17:55:22 <stepcut> ((lambda (f x) (f x)) ((lambda (x y) (+ x y)) 1) 2)
17:55:30 <stepcut> apparently that is not actually valid scheme code...
17:56:03 <metaperl> Cale, could you tell me how fold builds up that table?
17:56:14 <wagle> stepcut: might be, might not be
17:56:19 <Cale> metaperl: okay
17:56:46 <wagle> oh wait
17:56:52 <metaperl> I dont understand why the function does not run the second the newTable is called?
17:57:14 <metaperl> is it because Tbl g expects one argument?
17:57:24 <Cale> metaperl: foldr updTable e ((1,11):(2,22):(3,33):[]) = (1,11) `updTable` (2,22) `updTable` (3,33) `updTable` e
17:57:33 <metaperl> so you have nested curried functions waiting on an argument
17:58:16 <wagle> i was looking at wrong part
17:58:20 <Cale> which, ignoring the Tbl constructor, is a function equivalent to:
17:58:30 <Cale> f x | x == 1 = 11
17:58:36 <Cale>     | x == 2 = 22
17:58:40 <Cale>     | x == 3 = 33
17:58:48 <Cale>     | otherwise = error "blah"
17:59:57 <Cale> but really, it's sort of nested, you're right
18:00:30 <metaperl> I hate to tangent but the expansion of foldr you gave above is very similar to your use of >>= in MonadsAsContainers
18:01:18 <metaperl> [10,20,30] >>= \x -> [x, x+1] >>= \y -> if y > 20 then [] else [y,y]
18:01:43 <Cale> It's mildly related :)
18:02:37 <Cale> but not really the same thing
18:04:05 <Cale> f x | x == 1 = 11
18:04:05 <Cale>     | otherwise = g x
18:04:05 <Cale>         where g x | x == 2 = 22
18:04:05 <Cale>                   | otherwise = h x
18:04:05 <Cale>                 where h x | x == 3 = 33
18:04:06 <Cale>                           | otherwise = (\_ -> error "blah") x
18:04:12 <Cale> is the real expansion
18:04:31 <Cale> but you can easily see them to be equivalent.
18:05:47 <Cale> One might build a Table monad of various sorts
18:06:57 <Cale> In fact, this is what the Reader monad is.
19:07:20 <stepcut> doh! I have some bogus cvs version of ghc 6.3 that does not work with cabal 0.5 :-/
19:07:33 <stepcut> I wonder when 6.4 will be in freebsd ports ;)
19:12:38 <dons> stepcut: if you ask simonM nicely, he might makes his nightly freebsd/6.4 snapshots available
19:13:09 <dons> in fact, I'm sure he would, barring network issues.
19:23:23 <sh10151> http://lemonodor.com/archives/001096.html
19:28:27 <wagle> same civilization as this stuff:
19:28:30 <wagle> 	mov    $0x5,%ecx
19:28:30 <wagle> 	mov    $0x805972e,%edx
19:28:30 <wagle>  	mov    %eax,%esi
19:28:30 <wagle>  	mov    %ecx,0x8(%esp)
19:28:30 <wagle>  	mov    %edx,0x4(%esp)
19:28:33 <wagle>  	movl   $0x0,(%esp)
19:41:09 <cm> hiho
19:42:04 <Lemmih> Hey
20:22:31 <Cale> Are there any other mathies in here with some knowledge of the representation theory of finite groups?
20:32:31 <gzl> i know of it, but i can't really help. :)
20:32:50 <gzl> however, you could try #math on efnet. there are definitely people there who would know
20:32:51 <heatsink> same here.
20:34:07 <gzl> i've been meaning to read some rep theory but haven't gotten around to it, like most everything else =\
20:38:07 * Lemmih has trouble with Cabal under Windows.
20:39:17 <cm> meh
20:46:09 <_mordechai> heyo
20:46:32 <cm> hi
20:50:23 <cm> metaperl, mhm
20:59:22 <ibid> good morning
21:00:35 <Lemmih> Using another linker with GHC 6.4 appears to be broken on Windows.
21:01:30 * cm starts looking wth is wrong with spamassassin
21:03:04 <dons> Lemmih: 'another linker'? sounds dangerous
21:04:04 <dons> ghc sends the linker half a page for flags, so I'm not to surpised it doesn't play well with an unknown linker
21:04:06 <Lemmih> dons: The one shipped with GHC can't find libpq.a on my cygwin box.
21:04:18 <dons> oh. ok. that's doesn't sounds to bad.
21:04:31 <dons> add some -optl flags
21:05:02 <Lemmih> '-L/lib' didn't work.
21:05:34 <Lemmih> (I even check that it was being passed to the linker)
21:06:43 <Lemmih> I think it has something to do with cygwin, although I must admit I'm quite out of my element here.
21:07:16 <Lemmih> /usr/bin/ld didn't have problems finding -lpq.
21:08:05 <Lemmih> Anyhow, the sun is rising. Time to sleep.
