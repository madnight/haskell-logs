01:31:27 <lightstep> @seen boegel
01:31:27 <lambdabot> I saw boegel leaving #haskell 1 hour 28 minutes 34 seconds ago.
01:31:41 <shapr> @seen JaffaCake
01:31:41 <lambdabot> I haven't seen JaffaCake
01:31:59 <lightstep> does anyone know if boegel uploaded the paper he was talking about?
01:59:51 <shapr> boegel: hey, did you upload that paper you were talking about?
02:00:16 <Lunar^> shapr: Hi!
02:00:55 <shapr> salut Lunar^!
02:01:16 <shapr> I tried to build the network-enabled hOp, but I couldn't figure it out in ten minutes.
02:01:21 <shapr> Is there some trick to it?
02:02:24 <Lunar^> shapr: AFAIK, you have to first get latest hOp to build, then checkout CVS (files are replaced in rts/ directory!) and build it again
02:02:36 <shapr> ah, I see.
02:02:37 <Lunar^> shapr: the TOP variable in the house/Makefile should point to the hOp directory
02:02:58 <Lunar^> shapr: But I did not took the time to do it, though :(
02:03:07 <boegel> shapr: which paper ?
02:03:15 <musasabi> morning2
02:04:25 <shapr> boegel: I don't know, whichever one lightstep was asking about.
02:04:43 <shapr> skew: hiya!
02:05:00 <boegel> oh, the presentation on my raytracer
02:05:05 <musasabi> boegel: the translation of the raytracer presentation
02:05:12 <boegel> I didn't have time to translate it yesterday....
02:05:22 <boegel> lemme try and fix that now
02:18:57 <skew> shapr: Hi!
02:19:14 <shapr> skew: how's code?
02:19:19 <skew> good.
02:19:27 <skew> I've found a job building a DSL compiler in Haskell
02:19:59 <shapr> wow, nice
02:21:47 <araujo> Good morning.
02:21:54 <tromp> g'morning
02:22:43 <Lunar^> skew: Cool!
02:22:58 <mayhem> DSL compiler ?
02:24:34 <Philippa> skew: how fast does the object code have to be?
02:25:01 <tromp> 100+ km/h
02:25:27 <skew> Philippa: well, right now they're writing Perl by hand
02:25:32 <Philippa> only if monad(transformer) heavy haskell code is okay, template haskell is very much your friend
02:25:50 <skew> I'm not embedding the DSL.
02:26:00 <skew> I figure generating not-totally-braindead C should be good enough
02:26:05 <Philippa> and I'm not talking about embedding the DSL
02:26:43 <Philippa> basically, if you use template haskell you can effectively turn an interpreter into a compiler by adding staging annotations, if that makes sense
02:27:01 <skew> where does the transformer heavy code come in?
02:27:27 <Philippa> easiest way to build an interpreter :-)
02:27:46 <skew> Ah, I don't want to build on a Haskell interpreter either
02:27:53 <Philippa> certainly you could have a prototype PDQ
02:28:01 <Philippa> fair enough
02:28:12 <Philippa> just thought I'd mention the possibility because it's scarily easy to get results fast
02:28:22 <skew> It's sort of concurrent query language, so Haskell's semantics are not a very direct fit
02:28:24 <boegel> uploading the presentation...
02:28:38 <skew> I do have a prototype interpreter, though.
02:30:04 <skew> Also, the idea is a single runtime/server that dynamically loads and upgrades the object code from lots of different specifications
02:30:39 <skew> As I far as I know, dynamically loading Haskell code is still a bit of a fragile hack at this point.
02:31:47 <vegai> I hear it should be getting better with ghc-6.4
02:33:10 <skew> How are data types handled? I thought there was some issue with different compilations making different versions of the types, Dynamic getting confused, and so on
02:35:43 <skew> I have the idea that GHCi doesn't support class and data definitions for infrastructure reasons that may be cleaned up to improve support for dynamic loading.
02:35:57 <skew> Am I just dreaming that?
02:38:47 <nlv11757__> earthy present?
02:38:57 <skew> Philippa: how do you get source into and code out of the TH version?
02:39:54 <Philippa> IO from the quotation monad to get source in. Code out is just what TH /does/ - you use it to construct a haskell program which GHC then compiles
02:40:30 <Philippa> I ended up with a module that could be summed up as main = $(compile "FILENAME")
02:40:32 <skew> I've turned an interpreter into a compiler well before TH existed by turning equations of eval X = <monad stuff ... (eval Y) ...> into compile X = "monad stuf ...  "++compile Y++" ...>"
02:40:33 <boegel> shapr, lightstep, a5 and others: http://studwww.ugent.be/~kehoste/thesisPublic/website/presentation/raytracing_en.sxi
02:40:58 <boegel> other versions (Powerpoint, or Dutch) available on my website
02:41:26 <nlv11757__> anyone else knowing UUAG here?
02:42:05 <Philippa> I don't really, but I'm sort of wondering what it manages beyond 'macros on crack'
02:42:26 * boegel is off making dinner
02:42:29 <skew> Philippa: UUAG or the template Haskell thing?
02:42:34 <skew> nlv11757__: I do a bit
02:42:41 <skew> at least, I used an older version
02:42:50 <Philippa> UUAG. TH isn't quite macros, if only because it can do stuff like compile-time IO
02:43:16 <nlv11757__> ok, i have something weird here
02:43:25 <nlv11757__> DATA File
02:43:25 <nlv11757__> | File fileName : String globals : {List_Global_}
02:43:34 <nlv11757__> i have an ATTR rule
02:43:45 <nlv11757__> ATTR List_Global_ [ || index_trs : {[PP_Doc]} ]
02:43:45 <nlv11757__> SEM List_Global_
02:43:52 <nlv11757__> and then lhs . bblablabalblabla
02:44:06 <nlv11757__> but when i want to do @globals.index_trs....
02:44:17 <nlv11757__> i get errors that synthesized attribute is undefined
02:46:16 <skew> You do produce index_trs in the semantic rules for List_Global_, right?
02:46:49 <nlv11757__> yeah
02:47:02 <skew> That would probably give a different sort of error message anyway.
02:47:06 <nlv11757__> lhs . index_trs = []
02:47:11 * Philippa blinks
02:47:17 <Philippa> I just had a really, *really* sick idea
02:48:02 <skew> Philippa: main = $(do [filename] <- getArgs; compile filename)?
02:48:20 <skew> (well, stripping the GHC options somehow)
02:48:52 <skew> nlv11757__: uuagc doesn't make any code for that input?
02:49:01 <Philippa> skew: probably. I was hacking and using the C preprocessor to fill in FILENAME for now
02:49:05 <kosmikus> nlv11757__: try removing the { ... } around List_Global_
02:49:18 <skew> Oh, right!
02:49:33 <Philippa> on the grounds GHC'll call one anyway and you can still wrap it up in a nice script if need be
02:49:56 <skew> The braces tell uuagc  "this is some glorious Haskell type that your puny brain could not possibly comprehend"
02:50:27 <Philippa> also, you have to wrap IO stuff within the quotation monad in a call to qIO or similar
02:50:41 <skew> cpp is just as good
02:50:46 <nlv11757__> :O
02:50:56 <nlv11757__> kosmikus, it worked....but why
02:51:01 <Philippa> yeah, though a raw #include wouldn't quite work
02:51:07 <nlv11757__> putting extra {} is not a crime in uuag i thought
02:51:12 <kosmikus> nlv11757__: skew's explanation
02:51:19 <kosmikus> I couldn't say it any better
02:51:28 <nlv11757__> ow crap
02:51:31 <skew> nlv11757__: so uuagc just assumes that globals is some primitive value, like if you had said globals : {Int}, or globabls {()}. It just passes the type along to GHC.
02:52:01 <nlv11757__> List_Global_ was defined in the uuag world....of course
02:52:02 <nlv11757__> thanks
02:53:38 <skew> What I remember wanting from UUAG was some way to wire attributes through a computed term
02:56:05 <skew> Like SEM <whatever> {fakeSubterm = File "test" <something involving lhs>; fakeSubterm . inherited_prop_a = 12; lhs . result = @fakeSubterm . computed_prop_13}
02:57:11 <kosmikus> you can always call the sem function by hand
02:57:13 <skew> Philippa: cpp is a lot better than trying to parse the arguments yourself, as GHC already accepts -DFILENAME to pass an argument on in to cpp, so you don't need to abuse something else to hide your filename argument
02:57:47 <Philippa> skew: agreed
02:58:12 <skew> kosmikus: yeah, I ended up either doing that or giving up. It's annyoing matching the well-named arguments with positions in the tuple, though.
02:58:23 <Philippa> I just wouldn't want to try #including anything into a string literal
02:59:15 <skew> Philippa: I was thinking just use -DFILENAME to get the filename in, then qIO (readFile FILENAME) to actually get at the program to compile
02:59:23 <Philippa> yeah, that's what I've done
03:00:07 <kosmikus> skew: you can prevent that by using the WRAPPER feature, which is relatively new
03:00:24 <bourbaki> moin
03:00:37 <boegel> shapr, musasabi: interesting presentatin ? or damn right boring ?
03:00:48 <boegel> hey bourbaki
03:01:09 <shapr> I'm about to go to class, I won't be able to check it out till I get back.
03:01:12 <bourbaki> boegel: your presentation is online?
03:01:26 <Philippa> boegel: what's it about?
03:02:23 <skew> kosmikus: that sounds vaugely familiar. What does it do? (Or: is there now up-to-date documentation online?)
03:02:54 <boegel> Philippa: my rayracer I built in Haskell
03:02:55 <skew> hey, looks like there is!
03:03:05 <kosmikus> no, there isn't, but it might be more up-to-date than the last time you looked
03:03:40 <musasabi> boegel: link?
03:03:53 <musasabi> boegel: yes, I am interested in it.
03:04:27 <kosmikus> skew: the documentation plus the comments on arthur's homepage cover everything I know, at least ...
03:06:00 <skew> At least there is an HTML reference now. I finding a few different UUAG pages. each offering an assortment of PDF files which were more tutorial than reference, and out of date to boot.
03:08:41 <kosmikus> the situation is certainly sub-optimal
03:08:51 <kosmikus> but it has improved
03:14:13 <skew> Did anything ever come from the discussion about global mutable variables a few months ago?
03:14:33 <skew> (I'm catching up on about six months of various Haskell lists after some email lossage)
03:21:21 <Philippa> skew: don't think anything did
03:21:37 <musasabi> boegel: that presentation looks very nice :-)
03:22:00 <boegel> musasabi: thanks :)
03:22:42 <musasabi> maybe add a slide about problems in the funmath -> haskell translation (as there probably were some)
03:29:26 <musasabi> varargs are too easy in haskell.
03:34:30 <musasabi> Of course it is not haskell98 :-(
03:46:31 <autrijus> anyone groks Japanese by chance?
03:46:42 <autrijus> I'd very much like to understand http://autrijus.org/brain.html :-)
03:46:43 <musasabi> a little bit
03:47:00 <autrijus> (mirrored from http://www.sampou.org/cgi-bin/cahier.cgi?Cahier%3a2005-03-02 )
03:49:31 <musasabi> grah, too many kanjis
03:49:41 <nlv11757__> Copying the value of a field using a copy-rule is deprecated
03:49:41 <nlv11757__>            Please add the following lines to your code:
03:49:41 <nlv11757__>            SEM Location
03:49:41 <nlv11757__>              | Location lhs . byte = @byte
03:49:50 <nlv11757__> why is this not a nice alternative
03:50:35 <autrijus> musasabi: incidentally I grok all the kanjis
03:50:40 <nlv11757__> isnt this what copy rules are for...capturing these trivial rules
03:50:47 <autrijus> but none of the rest
03:51:49 <autrijus> I wonder if it would help if I translate all the kanji to english
04:03:36 <boegel> musasabi: my work with Funmath isn't far enough yet to make such a slide
04:04:17 <boegel> and en plus, it's not really a translation... Funmath is on a higher level than Haskell is (for modelling), so some stuff just isn't available in Haskell
04:04:28 <kosmikus> nlv11757__: yes, but there have been confusions about priority too often
04:04:39 <kosmikus> nlv11757__: you can have a field and an attribute of the same name
04:05:45 <skew> kosmikus: is there any way to refer to the synthesized attributes of the current node?
04:05:59 <kosmikus> nlv11757__: I think Arthur and I agreed in the end that one should never copy implicitly from a field ...
04:06:30 <kosmikus> skew: no, not directly, but via a local variable, you can
04:06:49 <skew> yeah, but that totally screws up the copy rule
04:07:06 <musasabi> boegel: ok.
04:07:07 <skew> I don't think I did find a satisfactory solution to that one...
04:07:21 <kosmikus> skew: only if you use the same name for the local attribute
04:07:58 <skew> why didn't I think of that?
04:08:34 <skew> btw, why isn't the ordering of inherited and synthesized attributes in the copy rule cyclic?
04:09:56 <kosmikus> probably because currently, you have to write at least one rule to create a looping program
04:10:15 <skew> I've always thought the copy rule should tie the knot at the top of the repMin example...
04:10:29 <kosmikus> but this would be a one-line change, and could be made optional with a flag
04:11:10 <kosmikus> I'm not convinced that it helps readability of the program though
04:12:06 <kosmikus> I thought about writing a version of UUAG with pluggable attribute types, using hs-plugins; then you can write your own copy rules
04:12:12 * kosmikus is off for lunch
04:14:36 <nlv11757__> enjoy
04:17:04 <boegel> bourbaki, Philippa : I've replaced the sxi and ppt versions of my presentation with pdf versions... so if you're still interested, check my website
04:22:58 <bourbaki> sure i am
04:23:43 <boegel> bourbaki: still have the url ? :)
04:24:01 <bourbaki> yep
04:25:41 <bourbaki> nice a little short though :)
04:27:03 <boegel> bourbaki: I had 15 min's
04:27:37 <boegel> it's supposed to be a short overview of my work, without any details and such
04:27:47 <bourbaki> ah i see
04:28:00 <bourbaki> our presentations are useually 1.5h long
04:28:08 <bourbaki> usualle
04:28:13 <bourbaki> er ... usually
04:28:34 <bourbaki> though my presentations dont have a lot more foils ;)
04:28:45 <boegel> :)
04:28:55 <bourbaki> i like to talk free without that kind of stuff
04:29:18 <boegel> bourbaki: I talked a lot too... explained the images to the people not familiar with raytracing, and so on
04:29:26 <boegel> hwo do you like the images at the end ? :D
04:30:05 <bourbaki> really cool
04:30:18 <bourbaki> the perlin noise is really good now
04:30:18 <duncan_> boegel: just read the presentation (en version). Nice and clear.
04:30:50 <boegel> duncan_: thanks :)
04:31:01 <autrijus> musasabi: I think I grokked it thanks to several translation sites
04:31:08 <autrijus> I'm translating this to english. that's so hilarious.
04:31:34 <bourbaki> i have got a question but i want to describe the thing i want to apply it first so the use is clear
04:31:39 <duncan_> JaffaCake: did you manage to build gtk2hs on amd64 with GHC 6.4 ok in the end?
04:31:46 <JaffaCake> nah, not yet
04:31:54 <bourbaki> i have a particle system and there are a couple of forces acting on the particles
04:32:01 <autrijus> "alpha wave is dominant during Haskell worshipping rituals; the believer is relaxed, because Haskell does not cause side effects to one's brain"
04:32:04 <duncan_> more problems? can I help?
04:32:09 <JaffaCake> been busy, I'm doing it in between  other stuff, but I'll have another go today
04:32:32 <bourbaki> all these forces are modeled as functions now i want to pick up all these functions and make it a single one and apply just that on the particles
04:32:50 <JaffaCake> duncan_: any clue on the automake prob I mailed you yesterday?
04:32:51 <duncan_> ok, just ask if there's anything we can help with
04:32:55 <bourbaki> will this save me time in haskell compared to just apply each function after another to a pointer arry in c?
04:33:19 <duncan_> JaffaCake: let me go check today's mail...
04:33:29 <JaffaCake> sure, ok
04:33:51 <boegel> bourbaki: it might :p
04:34:36 <bourbaki> i mean is it getting rid of always pushing stuff to the stack and call the next function like c would
04:34:41 <bourbaki> when i call function pointer
04:35:34 <boegel> I'm afraid I don't know enough about the internals of Haskell to answer that
04:37:10 <boegel> bourbaki: a clone !
04:39:24 <skew> bourbaki: If you are using Haskell functions, the only sensible way I can think of to combine them is to make a function that applies all the other functions and combines the result somehow
04:40:28 <skew> If you are combining the functions dynamically I don't think this can save any function call overhead. At compile time you might pick up some optimization
04:41:53 <autrijus> there is also generator/consumer patterns
04:42:12 <autrijus> where multiple functions that traverse a list can be fusioned automagically by the compiler to traverse it once.
04:42:19 <tromp> nice to see you on slashdot, atrijus:)
04:42:41 <skew> that's one sort of optimization. I was just thinking of inlining
04:43:57 <skew> If you have definitions {f1 x = 2*x; f2 x = x + 1; combine f g x = f x + g x; f3 = combine f1 f2}, then the compiler probably inlines it all to {f3 x = 2*x + (x + 1)}
04:44:00 <autrijus> tromp: nice to see Haskell on slashdot :)
04:44:13 <autrijus> dinner &
04:48:01 <samc> there's bugger all funmath info on the web :(
04:48:58 <boegel> samc: ?
04:50:48 <duncan_> JaffaCake: email answered. The short answer is just run "autoreconf -i" again and it should work (and you may want to cvs up).
04:51:51 <JaffaCake> autom4te: unknown language: Autoconf-without-aclocal-m4
04:52:10 <duncan_> aarg!
04:52:16 <duncan_> :-) hmmm
04:52:38 <JaffaCake> I don't like autoconf, I don't like it a lot
04:53:26 <JaffaCake> does it work for other people?  why am I particularly cursed?
04:53:37 <duncan_> I'll go bug Jens Peterson, he's gtk2hs's real autotools expert
04:53:41 <samc> as in Boute
04:55:04 <bringert> JaffaCake: is the thing where ghc-6.4 compiled code segfaults when run with +RTS -xc a known problem?
04:55:23 <JaffaCake> no...
04:55:33 <bringert> mkay :-)
04:55:37 <duncan_> JaffaCake: the other thing I try in these circumstances is to blow away the auto4mate cache directory, re-run automake-1.9 and autoreconf -i
04:55:37 <JaffaCake> although there's a known problem with profiling on windows right now
04:55:52 <bringert> this is on linux
04:56:06 <JaffaCake> duncan_: just tried that, no joy
04:56:29 <bringert> not all code though, it doesn't happen with hello world
04:56:31 <JaffaCake> bringert: looks like a bug then, can you cut the example down?
04:57:22 <bringert> I'll try, our code is about 39k lines...
04:57:34 <JaffaCake> wow
04:57:57 <bringert> when looking at the core file with gdb, it looks to me like a C stack overflow problem
04:58:05 <bringert> > 2000 stack frames
04:58:29 <bringert> I'm just not quite sure where to start cutting down, or rather what to keep
04:59:39 <JaffaCake> hmm, I see the problem... let me just check whether I can make it fall over here
04:59:41 <duncan_> JaffaCake: you run Fedora right? FC2, FC3? So I know what to ask Jens...
04:59:52 <JaffaCake> FC3 on my amd64 box, yes
04:59:58 <duncan_> Ta
05:00:37 <bringert> oh, sorry, it's not the 39 kloc program that has the problem, it's only 4500 loc
05:01:09 <JaffaCake> ah well, that's fine then :)
05:01:37 <JaffaCake> hmm ok, I got a crash with +RTS -xc here too
05:02:13 <bringert> mine was without even throwing an exception, I think
05:02:35 <bringert> it happend during program startup
05:02:43 <JaffaCake> right
05:02:51 <bringert> but I'll have to double check that
05:03:31 <bringert> yeah, happens pretty much right away
05:12:42 <JaffaCake> bringert: found it, turns out that +RTS -xc is just broken in 6.4
05:19:22 <bringert> ah, that would explain it
05:19:23 <bringert> :-)
05:43:24 <nlv11757__> my haskell program takes 1 minute and 40 secs for building a function index of the mpeg2 encoder as provided by MPEG2.org (crappy C code yeah)....thats not bad is it?
05:43:41 <nlv11757__> or is the mpeg2encoder not that big in terms of C programs?
05:43:54 <nlv11757__> my prog is using UUAG of course ;)
05:45:04 <mflux> how long does it take to compile it?
05:45:13 <mflux> the c-program of course ;)
05:46:28 <earthy_> just a function index?
05:46:52 <earthy_> cscope is quicker
05:47:09 <mflux> well, I'm not sure if cscope is a fair comparison, as I'm quite sure it takes plenty of shortcuts
05:47:12 <nlv11757__> yeah, but im counting all the time from the point that this whole tree representation of the C file is being parsed using the built in 'read' until the file is written
05:47:15 <mflux> but a compiler should atleast to more work ;)
05:47:22 <nlv11757__> so surely haskell 'read' is my bottleneck
05:47:34 <nlv11757__> if i would write my own parser it would be much faster i think
05:49:35 <nlv11757__> or don;t you think usage of the haskell 'read' to parse the whole ast is the bottleneck in this case?
05:50:05 <earthy_> profile it and you'll know it
05:52:08 <nlv11757__> ow yeah, i'll do that. That will be a nice learning experience since i've never actually profiled my haskell programs
05:59:18 * earthy_ whistles
05:59:20 <earthy_> me either
06:04:23 <nlv11757__> hehehe my supervisor had a laugh about the 1 minute and 40 secs :P
06:06:19 <nlv11757__> so just -prof is ok?
06:08:21 <nlv11757__> :/ all libraries i use have to be compiled with profiling :O
06:08:22 <boegel> nlv11757__: compile: ghc -O2 --make foo.hs -o bar.exe -prof -auto-all, execute: ./bar.exe +RTS -P
06:08:38 <halcyon_> http://www.macs.hw.ac.uk/~dsg/gph/docs/4.06/users_guide/prof-rts-options.html
06:08:56 <bringert> what's up with haddock 0.7?
06:09:14 <bringert> the ghc lib docs claim to have been produced with 0.7
06:09:26 <bringert> but 0.7 is not available for download
06:10:12 <nlv11757__> it suddenly can't find modules i import when i compile like that boegel
06:11:29 <nlv11757__> u cant use -package with -prof?
06:12:47 <boegel> hmm, I'm not sure...
06:13:36 <nlv11757__> im getting a lot of missing interfaces when i leave out --make
06:25:37 <nlv11757__> if i do --make i suddenly have to give a shitload of includepaths while normally i would just do 'ghc -O2 -package uust Main.hs'
06:29:21 <duncan_> bringert: haddock 0.7 is the current cvs version. You're right it has not been released yet. But it works nicely with several improvements over 0.6 it'll be released soonish I guess
06:32:26 <JaffaCake> duncan_, bringert: yes, 0.7 isn't released yet
06:32:39 <JaffaCake> must get around to it at some point
06:33:24 <Lunar^> JaffaCake: congrats for GHC 6.4
06:33:36 <JaffaCake> Ta :)
06:33:50 <Lunar^> JaffaCake: How is the survey going?
06:34:13 <JaffaCake> haven't checked how many submissions recently, but it was around 150 before 6.4 was released
06:34:28 <Lunar^> that's great! :)
06:34:57 <JaffaCake> yes, we'd be very pleased with 150, but I think it'll be quite a bit more than that
06:36:39 <nlv11757__> has anybody ever succeeded in compiling with -prof in combination with -package ?
06:37:07 <JaffaCake> sure, what problem are you having?
06:37:07 <nlv11757__> im dying in failed to load interfaces
06:37:20 <JaffaCake> which package?
06:37:22 <nlv11757__> Failed to load interface for `Maybe'
06:37:24 <nlv11757__> etc etc
06:37:26 <nlv11757__> uust
06:37:33 <JaffaCake> did you install the profilied libraries?
06:38:01 <nlv11757__> dont tell me i need to recompile every library that i use with -prof in order to profile my app :O
06:38:15 <JaffaCake> ok, I won't tell you that :)
06:38:23 <nlv11757__> but it's true right
06:38:24 <nlv11757__> :)
06:38:27 <JaffaCake> 'fraid so
06:38:47 * nlv11757__ breaks down
06:39:08 <JaffaCake> but we provide profiled versions of all the standard libraries
06:39:13 * boegel puzzles nlv11757__ back together and gives him a hug
06:39:33 <nlv11757__> hehe i know jaffa, but the uust package dont
06:39:34 <nlv11757__> :D
06:39:40 <JaffaCake> ah
06:40:43 <nlv11757__> earthy: is it simple to build a profilied uust package ?
06:44:11 <Lunar^> JaffaCake: I wonder if you have any interests in this, but OGI people added network support to House
06:44:29 <JaffaCake> :-o
06:44:35 <JaffaCake> fantastic
06:44:45 <Lunar^> http://www.cse.ogi.edu/~hallgren/House/kernel/pfe.cgi?Net.IPv4
06:44:52 <Lunar^> there's a NE2000 monad around also
06:45:31 <Lunar^> JaffaCake: that'll be the ultimate test for strictness and update in place analysises, IMHO
06:53:51 <basti_> uhm hi
06:59:19 <nlv11757__> hi
06:59:38 * shapr bounces
06:59:44 <basti_> oh hi shapr
06:59:44 <shapr> JaffaCake: hiya! long time no see!
06:59:54 <JaffaCake> yup, hi shapr :)
07:00:14 <shapr> Hey, I can get those webstats for you if no one else has volunteered.
07:00:19 <araujo> g'day herwe
07:00:34 <JaffaCake> sure, that'd be great
07:00:35 <shapr> Any particular sort of report you want?
07:00:57 <JaffaCake> just a download count for each distribution would be fine
07:01:08 <JaffaCake> it's not that urgent now, we have the survey
07:01:18 <shapr> ok
07:01:28 <JaffaCake> do you have an account on haskell.org?
07:01:30 * basti_ still has no 'net at home
07:01:41 <shapr> When will the survey results be available to the general public?
07:01:55 <shapr> I have r00t access on www.haskell.org, but no account on cvs.haskell.org
07:02:20 <JaffaCake> I'll give it a while until the rate of submissions has dropped, then start collating the results
07:03:01 <CosmicRay> morning shapr
07:03:03 <JaffaCake> you can grab the httpd logs on haskell.org then
07:03:10 <shapr> y0 CosmicRay, how's code?
07:03:19 <CosmicRay> good
07:03:27 <shapr> JaffaCake: sounds good
07:04:42 <musasabi> Approximately how many submissions are there?
07:04:43 <shapr> Oh heey, any inside info on the SMP GHC via STM?
07:05:10 <shapr> Is it really happening? will we see the interim results of such an idea in the anon fptools repo on cvs.haskell.org?
07:05:14 <JaffaCake> musasabi: don't know right now, there were 150 just before the 6.4 release
07:05:15 <shapr> I'm *really* looking forward to that.
07:05:35 <musasabi> JaffaCake: :-)
07:05:35 <boegel> shapr: have you seen my presentation ?
07:05:36 <JaffaCake> shapr: I'm kinda working on it...
07:05:50 <musasabi> that is a very nice number
07:05:58 <JaffaCake> hehe
07:06:06 <shapr> boegel: no, but I'll look at it now.
07:06:11 <shapr> JaffaCake: yay! happiness!
07:06:33 <JaffaCake> I'm also putting an API on GHC - the "ghc as a library" thing
07:07:07 <JaffaCake> shapr: oh, did you mean a parallel GHC?
07:07:14 <JaffaCake> I'm not doing that
07:07:23 <boegel> shapr: http://studwww.ugent.be/~kehoste/thesisPublic/website
07:07:25 <shapr> Will that allow me to write a program that can programmatically get results from -prof ?
07:07:31 <JaffaCake> but it would be neat
07:08:04 <JaffaCake> um, no not really
07:08:27 <JaffaCake> tha API is more at the level of the compiler rather than the RTS
07:08:49 <Lunar^> shapr: Do you know that we would need that for hOp?
07:08:49 <musasabi> JaffaCake: What steps would be necessary to add support for TH not to be linked into an executable which just uses TH created code? (looking for a simple project to get more familiar with GHC internals)
07:08:50 * kosmikus has finally completed the survey
07:09:12 <shapr> Ah, too bad. I had the nifty idea to use hs-plugins to self-tune by turning on and off optimizations and programmatically checking the profiling results.
07:09:38 <basti_> boegel looking good =)
07:09:53 <boegel> basti_: thanks :)
07:09:58 <JaffaCake> musasabi: not sure I understand
07:10:02 <musasabi> shapr: that could be done as a shellscript/haskell program parsing the results.
07:10:28 <shapr> True, but that would be platform specific. Not that hs-plugins works on win32 yet...
07:10:31 <JaffaCake> musasabi: you want to use TH-created code in your program, but not link with package template-haskell?
07:10:37 <musasabi> JaffaCake: yes.
07:11:11 <JaffaCake> doesn't it work? I mean TH isn't needed at runtime
07:11:36 <JaffaCake> I'm not a TH expert, tho
07:12:15 <nlv11757_> needless to say that my attempt to compile the uust package with profiling enabled crashed my pc
07:12:27 <shapr> crashed the whole box?
07:12:35 <nlv11757_> couldnt even move my mouse
07:12:49 <nlv11757_> or anything for that matter
07:13:13 <nlv11757_> to rule out mistakes on my side; i just added a -prof as a ghc option in the makefile...that should be sufficient right?
07:13:27 <nlv11757_> to enable applications using that package to do profiling
07:13:57 <basti_> it certainly should not crash your box.
07:14:04 <nlv11757_> hehehe
07:14:22 <basti_> I would suggest trying it again, just the same way, to rule out a local/intermittent problem
07:14:26 <nlv11757_> it was up for 2 weeks now i think, so maybe it was unrelated to compiling
07:14:31 <basti_> but i know how crashes affect blood pressure.
07:15:11 <basti_> -prof by itself does only profile where you added these "magic comments"
07:15:15 <boegel> shapr: how do you like it ?
07:15:17 <basti_> iirc
07:15:18 <musasabi> JaffaCake: it dies to linker errors if I don't add -package template-haskell.
07:15:48 <nlv11757_> basti_ so how can i compile a package so programs using it will be able to profile?
07:16:05 <JaffaCake> strange, I wonder what requires the template-haskell package then
07:16:06 <nlv11757_> cause i have downloaded ghc-prof, but thats not enough because im also using uust package
07:16:07 <musasabi> nlv11757_: is it possible that your machine ran out of memory?
07:16:18 <basti_> nlv11757_ you want to profile the package and not the program yes?
07:17:14 <musasabi> JaffaCake: well if module A is using template haskell code defined in module B it must import B. Now because A imports B, B is compiled to the executable and B has the code using TH.
07:17:37 <nlv11757_> basti_: i want to profile my program using the uust package, which means i have to recompile the uust package also right?
07:18:05 <JaffaCake> oh, I see
07:18:17 <nlv11757_> musasabi: i have 512 mb, should be enough i think
07:18:18 * CosmicRay returns
07:18:31 <basti_> nlv11757_ hmm i fail to see the connection between uust and profiling. I will google a bit.
07:18:49 <JaffaCake> so really, you want to eliminate from your code everything that is needed at compile-time only
07:18:57 <JaffaCake> from the executable, I mean
07:19:16 <nlv11757_> basti_: just as i need ghc-prof to profile a program using the Maybe module for example....i should recompile the uust package
07:19:21 <nlv11757_> at least, thats what i think
07:19:26 <nlv11757_> i could be wrong
07:19:33 <basti_> but generally, i would say, if you do not want to debug/improve a package, you would not need to recompile it.
07:19:43 <musasabi> JaffaCake: yes.
07:20:03 <nlv11757_> basti_: why do i need to have ghc-prof instead of just ghc then?
07:20:07 <nlv11757_> isnt that the same thing
07:20:08 <basti_> so if youre only interested in the behaviour of your program and want to see whatever library as a "black box", then you do not need to recompile
07:20:27 <basti_> no it is not the same thing if you compile something for profiled runs or not
07:20:30 <musasabi> and since the TH functions defined in B are used from A they are exported and thus not dead.
07:21:00 <basti_> profiling programs have another "runtime package" (what you call it in the haskell world?)
07:21:08 <nlv11757_> ok
07:21:25 <basti_> but you do not need to recompile every single library your program uses just because you want to profile it
07:21:31 <nlv11757_> in that case, im getting failed to load interface messages which i cant get rid of
07:21:46 <basti_> thats strange.
07:21:47 <basti_> =)
07:21:54 <basti_> while compiling?
07:21:58 <nlv11757_> Failed to load interface for `GetOpt'
07:22:22 <basti_> or while running?
07:22:30 <nlv11757_> while doing 'ghc -O2 -prof -auto-all -o main -fglasgow-exts Main.hs'
07:22:36 <basti_> i see
07:22:57 <basti_> have you tried to compile a trivial program with -prof?
07:23:47 <basti_> maybe your installation is faulty.
07:26:50 <nlv11757_> it works on trivial examples
07:27:12 <basti_> thats good.
07:28:14 <basti_> i really believe that you would not need to recompile anything besides the thing you want to profile.
07:29:23 <nlv11757_> ok
07:29:32 <nlv11757_> i will look elsewhere for problems
07:29:47 <nlv11757_> btw isnt hp2ps supposed to be in the ghc-prof package?
07:30:14 * basti_ shrugs
07:31:14 <nlv11757_> shrug is a fitness exercise, but im guessing you are referring to something else/
07:31:16 <nlv11757_> :)
07:31:36 <basti_> i do not know it is supposed to be there.
07:36:07 <nlv11757_> is it a choice between ghc and ghc-prof? or are both needed?
07:36:57 <basti_> i think ghc-prof is just the add-ons to make -prof work.
07:37:24 <basti_> ive never seen different versions of ghc being shipped, one with profiling support disabled.
07:38:12 <nlv11757_> ahhh it didnt chase dependencies correctly earlier, now it also retrieves ghc in addition to ghc-prof
07:38:30 <basti_> :)
07:39:43 <shapr> boegel: pretty pictures, nice code.
07:42:23 <boegel> shapr: there's not much code in there, is it :p
07:44:09 <shapr> Nice explanation of the algorithm, and I particularly like the surprisingly informative pictures that have the eye.
07:44:22 <shapr> Most ppts have an overall negative information impact.
07:44:28 <shapr> That is, they confuse more than they inform.
07:45:14 <shapr> Or maybe I'm being a cynical corporate drone when it comes to my opinions on ppts ;-)
07:49:42 <nlv11757_> doesn't literate haskell files obscure the code?
07:50:16 <basti_> no.
07:50:57 <nlv11757_> you know, the thing which is the documentation and the code at the same time
07:51:01 <basti_> yes.
07:51:17 <basti_> actually i think the world needs more documentation than code.
07:51:31 <nlv11757_> i can imagine if someone wants to modify it, he/she might be a bit stunned because of the doc interleaving the code
07:52:18 <CosmicRay> personally, I find haddock docs much more useful than lhs docs
07:52:25 <CosmicRay> it is faster to find what I want
07:52:34 <CosmicRay> it is easier to read docs from many different sources because they all look the same
07:52:50 <CosmicRay> and usually I care what the code does, not how it does it
07:53:20 <basti_> i think the optimal solution is something like literate in combination with "javadoc" type documentation.
07:53:23 <shapr> I like literate Haskell, I think it's easier to keep docs in sync
07:53:33 <musasabi> Did anyone find a latex style file tutorial when looking for one for TMR ?
07:53:49 <CosmicRay> I dunno, it's pretty easy for me to keep me {- | .... -} docs in sync for any particular function
07:53:53 <shapr> I'd much rather have unit tests instead of docs.
07:54:02 <CosmicRay> shapr: I prefer both
07:54:03 <nlv11757_> true, but if im to deliver something to my employer that want to continue development...i dont think he will be pleased with literate haskell
07:54:14 <CosmicRay> shapr: actually if it works, I don't care if it has no unit tests :-)
07:54:20 <shapr> Unit tests distill the essence of code for me.
07:54:28 <basti_> i want extracted proofs instead of stupid unit tests :P
07:54:33 <shapr> CosmicRay: it's important for me because code that works rarely does exactly what I want.
07:54:39 <CosmicRay> shapr: heh
07:54:50 <CosmicRay> shapr: how about code that doesn't work?
07:54:56 <tromp> i thought i understood C bitfields...
07:55:12 <tromp> guess the sizeof the following:
07:55:14 <tromp> typedef struct {
07:55:14 <tromp>   signed bigscore:3;
07:55:14 <tromp>   unsigned biglock:26;
07:55:14 <tromp>   unsigned bigwork:6;
07:55:14 <tromp>   signed newscore:3;
07:55:14 <tromp>   unsigned newlock:26;
07:55:17 <tromp> } hashentry;
07:55:46 <nlv11757_> >1
07:56:04 <basti_> tromp: it depends on the compiler.
07:56:28 <musasabi> tromp: that is probably >= 64 bits.
07:56:44 <musasabi> tromp: which means that sizeof will be >= 1.
07:57:40 <tromp> i thought it shld be 8
07:58:18 <musasabi> tromp: depends on 1) CHAR_BITS, 2) Even if CHAR_BITS == 8, it is >= 8.
07:59:19 <tromp> why can't it fit 64 bits in 64 bits:-?
07:59:51 <musasabi> tromp: because that would be quite stupid thing to do for other number of bits.
08:00:01 <tromp> now i'm forced to forego bitfields and do the bitfiddling myself
08:00:12 <halcyon_> tromp: the implementation could use 64 ints for the 64 bits, that's why there is the sizeof keyword =)
08:00:32 <tromp> but you'd expect gcc to do better
08:00:33 <musasabi> tromp: you will probably want something that is 7 bytes to be 8 byte aligned, or the compiler will almost certainly do that for performance.
08:00:47 <tromp> i'm allocating an array of 10M of these
08:03:10 <tromp> is there no way to force a specific layout of bitfields?
08:03:30 <musasabi> no iirc, ##c could answer that probably.
08:03:48 <musasabi> there is no way to force the layout of an int either ;)
08:04:04 <musasabi> nor of a struct { int a; int b; }
08:04:24 <tromp> why does ##c have two # ?
08:04:35 <musasabi> freenode politics
08:05:35 <shapr> speaking of which...
08:05:57 <shapr> I wonder if the picky details of freenode politics are sated if JaffaCake is the alternate for #haskell?
08:06:25 * JaffaCake wakes up
08:06:38 <shapr> good morning JaffaCake !
08:06:54 <JaffaCake> eh, wha?  someone mention me?
08:07:19 <shapr> Yeah, freenode politics are such that they want #name and ##name to be official and unofficial respectively.
08:07:43 <CosmicRay> never mind that ##name violates the irc rfc
08:07:49 <JaffaCake> ok
08:07:52 <CosmicRay> pfft.  it is weird.
08:07:59 <CosmicRay> anyone can still start a #name channel anytime
08:08:00 <shapr> So #haskell should only exist if someone who is part of the 'real Haskell' is one of the bosses.
08:08:19 <CosmicRay> oh, so #c would have to be started by Brian Ritchie? :-)
08:08:35 <CosmicRay> err, Dennis Ritchie
08:08:37 <shapr> Of course Cale brought up the point that it would be difficult to find people to run #math .
08:08:38 <JaffaCake> there is no 'real Haskell', really
08:08:46 <CosmicRay> heh
08:08:58 <thebug> how can they actually enforce this policy anyway? That'd take a pile of effort constantly
08:09:16 <CosmicRay> thebug: but if we contribute to PDPC, then they can pay lilo to do it!
08:09:43 <thebug> y'know, I'd support PDPC if I knew the money was going anywhere but to feed lilo
08:10:07 <CosmicRay> thebug: oh, it also pays for his phone line, travel, and office supplies.
08:10:13 <shapr> Personally, as long as no one complains, I don't think anything should change.
08:10:18 <duncan_> JaffaCake: about the autotools, I'd say don't bother with the gtk2hs CVS version, use the 0.9.7 with the patch I gave in the email. There's nothing special in the CVS version from the ghc 6.4 or amd64 point of view.
08:10:22 <shapr> And the only person who has complained so far has been Smerdy.
08:10:42 <CosmicRay> any he's one of those loser ocaml defectors, right? :-)
08:10:50 <JaffaCake> duncan_: ok, but part of the patch was to Makefile.am, so I still need automake, right?
08:11:26 <shapr> CosmicRay: I think I am sufficiently biased on the subject of Smerdy that I shouldn't give you my opinion.
08:11:47 <CosmicRay> shapr: it is not a big deal to me, but every time I log on to freenode I feel a little dirty, that I'm being a tool to support pdpc somehow
08:12:05 <shapr> Why isn't there a purely p2p network?
08:12:05 <CosmicRay> shapr: the whole thing, whatever it was, was before my time, so that's fine
08:12:22 <CosmicRay> shapr: nat
08:12:34 <musasabi> shapr: because trust is hard on p2p.
08:12:34 <shapr> You can beat nat with bubble packets.
08:12:48 <duncan_> err. true. (though the patch should work on the generated Makefile) but perhaps I should roll a special release for 6.4
08:12:54 <musasabi> shapr: how would you implement irc over p2p without n*n messages.
08:13:01 <shapr> multicast?
08:13:11 <JaffaCake> duncan_: don't worry, I can figure out how to patch the Makefile
08:13:13 <CosmicRay> shapr: what is a bubble packet?
08:13:17 <CosmicRay> shapr: unix talk is pure p2p
08:13:29 <CosmicRay> shapr: also a braindead protocol that has lots of trouble with nat, but hey :-)
08:13:57 <shapr> CosmicRay: I'll get you an url, but in short it's "send out a packet to fake the nats into thinking both nodes are doing outgoing connects'
08:14:04 <musasabi> shapr: multicast doesn't work well on internet.
08:14:19 <CosmicRay> shapr: does that work for tcp also, or just udp?
08:14:20 <shapr> Does multicast work with 6to4 ?
08:14:28 <shapr> Not sure
08:14:43 <CosmicRay> shapr: it seems that this would work ok with udp
08:14:58 <CosmicRay> shapr: but I can't see it working with tcp, though my brain may not be fully engaged yet
08:15:03 <shapr> search for bubble in this page - http://www.microsoft.com/technet/community/columns/cableguy/cg0403.mspx
08:15:19 <duncan_> JaffaCake: ok. The original patch makes one line changes in two files but both bits end up in the same generated Makefile.
08:15:30 <Narrenschiff> Out of the blue... could anyone recommend a good haskell textbook for someone kind of familiar with functional programming?
08:15:44 <musasabi> CosmicRay: doesn't that need a trusted server through which all communication is made with udp?
08:15:51 <JaffaCake> duncan_: thanks, I'll give it a go tomorrow probably
08:16:14 <shapr> Narrenschiff: Might want to start with the Gentle Intro if you're already FP clueful.
08:16:38 <CosmicRay> musasabi: what, unix talk?  no, it's p2p, but it would suck for someone on a dynamic ip
08:16:50 <CosmicRay> musasabi: it was designed in a time where most unix machines were on a real public ip
08:17:32 <musasabi> CosmicRay: so how would you go through the NAT ?
08:17:34 <CosmicRay> shapr: it looks liek this is restricted to udp
08:17:37 <shapr> musasabi: outgoing packets set up a nat mapping, if both machines send an outgoing packet, they both have incoming channels available. That's the idea at least.
08:17:52 <shapr> CosmicRay: tcp works over udp...
08:17:52 <CosmicRay> musasabi: you wouldn't, unix talk sucks with nats.  it requires a protocol translator or proxy.
08:18:14 <shapr> could you 'bootstrap' tcp it once the udp channel is up and running?
08:18:25 <musasabi> shapr: only the NAT will blacklist the peer when it sends the packet without the outgoing connection
08:18:27 <CosmicRay> shapr: well yes, one could tunnel tcp within udp somehow
08:18:38 <CosmicRay> shapr: no, they are different IP protocol numbers
08:18:49 <CosmicRay> shapr: TCP port 80 is not the same as UDP port 80, for instance
08:19:14 <musasabi> CosmicRay: but one can use tcp over udp, as one can use tcp over ip.
08:19:50 <CosmicRay> musasabi: what is out there that encapsulates tcp in udp, out of curiosity?
08:20:06 <Narrenschiff> shapr: cheers.
08:20:23 <CosmicRay> musasabi: (re tcp over ip)... of course, but a NAT doesn't treat a UDP path the same as a TCP path.  You can't use one to bootstrap the other.  It would be a bug if you could.
08:20:26 <shapr> Narrenschiff: I like Hudak better, but others like Thompson better. I learned from Thompson, but wish I had used Hudak instead.
08:21:08 <musasabi> CosmicRay: well that would be quite trivial to do, but not really worth it as generic ip-over-ip tunnels exist.
08:21:17 <nlv11757_> System.Time in ghc6.4 suddenly don't have timeDiffToString anymore?
08:21:35 <Narrenschiff> shapr: "The haskell school of expression"?
08:21:35 <CosmicRay> musasabi: right, but they tend to use either TCP or another protocol entirely (GRE perhaps)
08:21:59 <shapr> Narrenschiff: Yes, that's it. But the 'Gentle Intro' is free, and designed for people with prior FP experience.
08:22:01 <musasabi> CosmicRay: they use TCP because doing that in UDP would not be very responsible,
08:22:24 <Narrenschiff> shapr: yeah, I'm thumbing through it now. Virtually.
08:23:02 <CosmicRay> musasabi: actually, I maintain that doing it in TCP is not very responsible.  The underlying protocol should already have retransmission, etc. support, so why duplicate it by forcing it into the sequential tunnel that is tcp?  it could really hurt performance in some cases
08:23:31 <musasabi> CosmicRay: because UDP does not have congestion control.
08:24:29 <CosmicRay> musasabi: right, but if you're forwarding TCP, even if it is physically transmitted as UDP packets across a gateway, wouldn't the underlying TCP still have its congestion control intact and working/
08:26:26 <shapr> In any case, UDP can get through NAT with this bubble packet idea, so why not use that for a multicast ipv6 p2p setup?
08:27:46 <shapr> Does ipv6 multicast work with 6to4 ?
08:27:47 <musasabi> shapr: because firewalls with a clue will temporarily blacklist the peers when they try the handshake.
08:28:04 <shapr> What to do about it?
08:28:08 <shapr> Is there something else?
08:28:45 <musasabi> well there is no really foolproof way.
08:29:15 <CosmicRay> musasabi: are you saying that about the bubble packet idea in general, or about the ipv6 setup in particular?
08:29:28 <musasabi> about the idea in general.
08:30:03 <CosmicRay> musasabi: why would they blacklist something?
08:30:09 <musasabi> CosmicRay: consider a firewall setup which temporarily blacklists hosts which send suspectfull packets.
08:30:24 <CosmicRay> yeah, but just sending out an empty udp packet isn't suspicious, is it?
08:30:48 <CosmicRay> yay, 300000 bugs in debian :-)
08:30:52 <musasabi> CosmicRay: which one is easier blacklisting everybody suspect or doing a detailed analysis?
08:31:20 <CosmicRay> musasabi: I'm just saying, there have to be criteria for determining what is suspect
08:31:20 * musasabi has done a few such solutions (but they of course had whitelists too)
08:31:39 <CosmicRay> some udp protocols actually use empty packets (the old time protocol, for instance)
08:32:45 <CosmicRay> I mean, of course you are right that some firewall someplace might do this, but it seems odd that this would be a common situation
08:32:52 <musasabi> CosmicRay: yes, but if they are not in a connection but knocking attempts they are suspect.
08:33:02 <CosmicRay> but udp is connectionless
08:33:32 <CosmicRay> musasabi: what you say makes perfect sense for tcp, and is probably common there...
08:33:38 <CosmicRay> but I'm having trouble mapping it to udp
08:33:41 <musasabi> CosmicRay: it is connection-full when looking from NAT perspective.
08:33:52 <CosmicRay> ok, true
08:33:58 <musasabi> CosmicRay: firewalls implement dirty state tracking for UDP.
08:34:14 <CosmicRay> but any packet going out should be enough to make it consider it the start of a new virtual connection, no?
08:34:45 <musasabi> CosmicRay: of course the first packet which opens the pathway for the peer can arrive before the peer has opened his pathway and then it can be classified as a knock attempt and thus resulting in a blacklisting.
08:35:22 <CosmicRay> ah, I see what you're saying.  one firewall could be ok, and whichever gets a packet first finds it suspicious?
08:35:29 <musasabi> yes.
08:35:59 <CosmicRay> still seems that one packet shouldn't trip up too many firewalls, but I could see it.
08:36:57 <shapr> So, in the case where it's not considered knocking, and doesn't blacklist, think it'll work?
08:37:39 * CosmicRay scrolls back up to see the original question ;-)
08:37:55 <shapr> Original question being, serverless chat?
08:38:14 <CosmicRay> ah.  well you would still need a central directory server, so you could map a nick to an ip.
08:38:30 <CosmicRay> but after that, the connection could be handed off
08:39:03 <musasabi> but with irc you have a larger problem.
08:39:10 <musasabi> The channel has 100 people.
08:39:11 <shapr> let's say we wanted to redo IRC without servers, I'd go for this bubble packet trick, and ipv6 multicast.
08:39:19 <musasabi> You need to coordinate joins and parts.
08:39:20 <CosmicRay> musasabi: right
08:39:30 <musasabi> and you cannot trust anyone to forward messages.
08:39:30 <CosmicRay> musasabi: also distribution of messages to a channel to everyone
08:39:36 <musasabi> also anyone can drop anytime.
08:39:51 <musasabi> so you have either a centralized server or send 100 messages.
08:40:06 <shapr> What about channel as multicast address?
08:40:08 <CosmicRay> exactly
08:40:14 <CosmicRay> I think multi-party chat would be difficult
08:40:37 * CosmicRay doesn't really grok multicast, so stays out of this one
08:40:50 <musasabi> shapr: multicasting is not very mature on internet.
08:40:54 <shapr> So you leave by unsubscribing
08:41:02 <shapr> In that case, pushing it hard might clean that up? :-)
08:41:48 <musasabi> shapr: and people would suffer because their ISP/company/whatever would not have enough incentives to buy new routers.
08:42:13 <musasabi> shapr: also multicast address allocation is a black art iirc (but that could have been solved)
08:42:18 <shapr> But if no one ever uses multicast, will there be an incentive?
08:42:47 <musasabi> TV over IP, should be an incentive.
08:42:59 <CosmicRay> well, I think there is plenty of incentive -- any sort of live streaming media, for instance
08:43:07 <CosmicRay> but things are moving in the direction of on-demand streaming media
08:43:13 <CosmicRay> which wouldn't benefit so much
09:08:05 <SyntaxNinja> hiya
09:14:57 <halcyon_> i have a short question: how should my 'main' function look like if i want to take two integer arguments from the commandline ?
09:16:48 <CosmicRay> no
09:16:52 <CosmicRay> err
09:16:56 <CosmicRay> args are not passed to main
09:17:00 <CosmicRay> see the System.Environment module
09:17:05 <SyntaxNinja> @type System.Environment.getArgs
09:17:06 <lambdabot> System.Environment.getArgs :: IO [String]
09:17:17 <halcyon_> oh
09:17:25 <CosmicRay> main is *always* IO ()
09:17:43 <CosmicRay> actually, maybe IO a is acceptable
09:17:44 <CosmicRay> I don't reall
09:17:47 <CosmicRay> recall
09:17:52 <SyntaxNinja> recall!
09:17:59 <CosmicRay> getProgName gives you access to argv[0]
09:18:13 <CosmicRay> getArgs gives you argv[1] and onwards
09:19:28 <halcyon_> so can i do this: main = putStr (show f (getArgs 1) (getArgs 2))  ?
09:20:02 <SyntaxNinja> halcyon_: no, you can't use getArgs as if it's a pure function
09:20:09 <SyntaxNinja> it performs IO, so you have to extract it first
09:20:24 <tic> lbarf <- getArgs
09:21:32 <halcyon_> ok, i think i'll have to dig deeper in the IO-part of Haskell.
09:21:48 <CosmicRay> halcyon_: Yet Another Haskell Tutorial is useful
09:21:58 <CosmicRay> halcyon_: http://www.isi.edu/%7Ehdaume/htut/
09:22:21 <CosmicRay> I wish I could say @yaht and lambdabot would say what YAHT is and give the url
09:22:25 <CosmicRay> can you rig that up shapr?
09:22:31 <halcyon_> thanks, i'll look at that
09:22:39 <CosmicRay> MegaMonad: @yaht
09:22:40 <MegaMonad> CosmicRay: I think yaht introduces it..
09:22:47 <CosmicRay> MegaMonad: thanks
09:22:48 <MegaMonad> CosmicRay: Combinatory logic. Arguably the simplest solution usually has other problems as that guy who designed the right edge of what there is a high impact.
09:25:02 <shapr> CosmicRay: can do it, but won't get to it today, time to work
09:33:58 <SyntaxNinja> can anyone tell me why this is buggy; it doesn't print the last line if there's no newline: http://haskell.org/hawiki/CatInHaskell
09:34:18 <SyntaxNinja> also, feel free to add your own versions of cat, or those from the recent discussion.
09:34:57 <Lemmih> Hey SyntaxNinja.
09:35:18 <SyntaxNinja> hiya Lemmih
09:35:24 <Lemmih> Did you finish the tests?
09:35:34 <SyntaxNinja> Lemmih: ross submitted a fix for that before I got  to it; I haven't compared the fixes yet
09:38:04 <Lemmih> SyntaxNinja: (wiki cat) Works for me...
09:39:05 <Lemmih> Sounds like it's your terminal which resets the line.
09:39:24 <pesco> SyntaxNinja: Try 'echo -n "foo" | cat'.
09:40:11 <SyntaxNinja> yeah, doesn't do anything
09:40:54 <Lemmih> ./Cat [files];echo ?
09:41:05 <pesco> Then your shell appearently prints a carriage return before the prompt
09:41:17 <SyntaxNinja> OK so cat behaves the same as my cat
09:41:25 <SyntaxNinja> so I'm happy now.'
09:41:25 <pesco> Yes.
09:41:29 <pesco> Yes.
09:41:54 <SyntaxNinja> do you think I need the hFlush
09:42:06 <pesco> No.
09:42:13 <pesco> Oh wait!
09:42:18 <pesco> No, you don't.
09:42:32 <musasabi> yes, you do.
09:42:33 <SyntaxNinja> why not?
09:42:39 <CosmicRay> I'd prefer contents <- mapM (\x -> readFile x >>= putStr) theFiles
09:42:44 <musasabi> or actually no.
09:42:46 <CosmicRay> otherwise, you open up all the files before you even read the first one
09:42:49 <CosmicRay> anyway, must run
09:42:53 <SyntaxNinja> l8r
09:42:55 <CosmicRay> err
09:43:01 <CosmicRay> you don't even need contents <- that way
09:43:03 <CosmicRay> you can use mapM_
09:43:06 <CosmicRay> anyway, afk
09:43:16 <musasabi> SyntaxNinja: GHC flush std{in,out,err} but nothing else when quitting iirc.
09:43:50 <pesco> SyntaxNinja: Yes, what musasabi said.
09:44:04 <pesco> musasabi: So, he doesn't need to flush stdout.
09:49:00 <Oejet> Good evening.
09:50:21 <SyntaxNinja> y0
09:50:23 <Lemmih> Hey Oejet.
09:53:21 <Oejet> I love this channel.
09:53:40 * Gahhh takes a picture of this Kodak moment
09:55:57 <Oejet> I'll take 5 copies please.
09:58:58 <musasabi> a loving and tender? evening @ #haskell :-)
09:59:58 <Lemmih> SyntaxNinja: The fix isn't in the darcs repo?
10:00:18 <SyntaxNinja> Lemmih: NO, NOT YET.
10:00:24 <SyntaxNinja> sorry for caps
10:00:25 <Lemmih> OKAY THEN!
10:00:31 <Lemmih> (:
10:03:36 <SyntaxNinja> Lemmih: pushed. it's rather untested
10:07:04 <Lemmih> I like my fix better (:
10:07:35 <Lemmih> He just checks for the error case.
10:14:53 <SyntaxNinja> Lemmih: OK I'll apply your fix... if you want to send me a patch that removes his fix and adds yours that would be great :)
10:14:56 <SyntaxNinja> but that's no big deal.
10:19:07 <Lemmih> They aren't mutual exclusive, actually.
10:20:04 <SyntaxNinja> notu: y0y0
10:20:20 <SyntaxNinja> notu: do you want us to teach you haskell?
10:31:57 * CosmicRay returns
10:32:05 <SyntaxNinja> hi CosmicRay
10:33:03 <CosmicRay> SyntaxNinja: shame on you.  now you have spurred me to finish up my grep example in haskell :-)
10:34:59 <SyntaxNinja> sweet
10:35:13 <notu> syntaxninja: actually I'm looking for help on a homework problem ;)
10:35:29 <SyntaxNinja> notu: sure, anytime. we give full answers for a great price.
10:37:37 <musasabi> http://www.haskell.org/humor/homework.html ;)
10:37:45 <musasabi> seriously though just ask.
10:39:15 <araujo> haha
10:40:02 <araujo>  Programs: $1 / line of code (comments extra)
10:40:09 * araujo rolls over the floor
10:41:43 <notu> maybe I can get a discount - no shipping req'd
10:42:37 * SyntaxNinja never noticed that web page before. we should fix the URL
10:44:33 <CosmicRay> how does one creat a brand new page in the wiki?
10:45:12 <musasabi> CosmicRay: just type in the url or create a link to it.
10:45:17 <CosmicRay> ah, one has to link to it.
10:46:57 <musasabi> well one can just create it too.
10:47:08 <musasabi> if it has no links it will get lost.
10:47:21 <musasabi> like my darcs + ghc one did.
10:48:34 <CosmicRay> @wiki GrepInHaskell
10:48:34 <lambdabot> http://www.haskell.org/hawiki/GrepInHaskell
10:48:40 <CosmicRay> SyntaxNinja: let me know what you think of that
10:49:36 <SyntaxNinja> did you link it from cat? I linked cat from ThatAnnoyingIO Type
10:49:39 <SyntaxNinja> I'll let you know :)
10:50:27 * musasabi votes for short examples as subpages.
10:50:42 <CosmicRay> I linked both frmo CodeExamples
10:51:33 <CosmicRay> hmm, there are two pages:  ThatAnnoyingIOType and ThatAnnoyingIoType
10:51:42 <CosmicRay> that's annoying
10:51:57 <SyntaxNinja> heh
10:52:02 <SyntaxNinja> one redirects to the other
10:52:05 <CosmicRay> ahh, the first reirects to the second
10:52:14 <SyntaxNinja> can you add cat to code examples while you're at it/
10:52:23 <CosmicRay> I did
10:53:08 <SyntaxNinja> ta
10:54:53 * tmoertel cannot log into his hawiki account
10:57:22 <wilx> Hmm...darcs doesn't handle UTF-16 XML files as text?
10:57:33 <wilx> All I get is some not so nice hex blobs.
10:57:52 <Igloo> It thinks a 0 or 255 byte == binary IIRC
11:00:27 <CosmicRay> SyntaxNinja: so, what do you think of the grep?
11:00:34 <CosmicRay> I keep thinking there ought to be a more compact way to do it
11:00:39 <CosmicRay> but can't think of one right off hand
11:03:48 <wilx> @wiki HaskellIRCPastePAge
11:03:49 <lambdabot> http://www.haskell.org/hawiki/HaskellIRCPastePAge
11:05:42 <SyntaxNinja> CosmicRay: can't look at it now, sorry. will check it out soon.
11:06:40 <CosmicRay> OK, I have an FFI question.
11:07:00 * stepcut pretends like he will know the answer
11:07:02 <CosmicRay> I wish to export a function with this tye, from Haskell to C:
11:07:08 <Igloo> match = isJust . matchRegex regexp
11:07:19 <wilx> So...
11:07:22 * stepcut has never exported a function from Haskell 
11:07:28 <CosmicRay> vGetLine :: HVIO a => a -> IO String
11:07:47 * tmoertel added a slightly-more cat-like cat to the HaWiki
11:07:57 <CosmicRay> now, I will be initializing a C setup with an item that's in the HVIO class
11:08:03 <CosmicRay> The C setup doesn't care about the item at all
11:08:17 <CosmicRay> but the C setup uses callbacks, and will be passing that object back through to Haskell.
11:08:20 <wilx> Anybody with Windows version of GHC 6.4, I'd like you to try the short test I've pasted on paste page.
11:08:21 <CosmicRay> I can't figure out how to do this
11:10:14 <CosmicRay> I can't just put it into some opaque pointer type, because then the original type information is lost as it goes hrough C
11:10:32 <CosmicRay> normally in Haskell, I would use closures to nicely do this, and make the other functions not require the parameter
11:10:41 <CosmicRay> but I also can't do that, since I can only export top-level functions
11:12:06 <wilx> Ah!
11:12:17 <wilx> Somebody has already tripped that...
11:12:36 <wilx> Checking SF.net...
11:13:19 <musasabi> wilx: hmm, can you link?
11:13:26 <wilx> http://sourceforge.net/tracker/index.php?func=detail&aid=1163018&group_id=8032&atid=108032
11:14:04 <musasabi> ah, that is different from my problems.
11:49:09 <halcyon_> has someone an idea for a better approach to swap two elements in a list? i think my current code is rather ugly: http://www.rafb.net/paste/results/RT8Tql83.html
11:50:21 <Lemmih> What's up with the 'otherwise' case?
11:50:40 <halcyon_> ?
11:50:59 <halcyon_> you mean it's superfluous?
11:51:02 <Lemmih> When will a number neither be equal, greater or smaller than another number?
11:52:17 <halcyon_> yes, you're right. i think i started with less guardians just with 'otherwise=undefined' and forgot to delete it
11:52:29 <Lemmih> ah.
11:53:52 <halcyon_> but the real problem is the i<j case. i think it's an ugly way to deal with lists in Haskell, but i hadn't got an idea how to write this more elegant
11:54:41 <Lemmih> I would not do it at all.
11:54:58 <halcyon_> oh, how would you circumvent this?
11:55:43 <Lemmih> Depends on how you're using 'swap'.
11:57:53 <halcyon_> i'm experimenting with sorting-networks, that are lists of pairs of indices to do a compareSwap-operation on. so for example, the sortnet could be [(1,2),(2,3)], that means: compare the first and second element in the list and swap them if they aren't in ascending order. same for the second and third element thereafter..
11:58:39 <halcyon_> that is why i need a swap-operation
11:59:44 <Lemmih> That would be _very_ slow. Try a better algorithm or mutable arrays.
12:00:10 <halcyon_> what exactly would be slow?
12:01:05 <Lemmih> You don't actually swap the elemens in the list. You create a completely new list where the elements are swapped.
12:01:51 <halcyon_> i thought this is the only possible way to operate on lists?
12:03:44 <Lemmih> And it is. There's _no_ way to change a list.
12:06:12 <halcyon_> ok, so an array could be better, because an indexed access on elements is more natural with an array than with a list, right?
12:07:45 <Lemmih> Yes, and you can even get mutable arrays if you don't mind impurity or get annoyed by the performance.
12:08:34 <halcyon_> ok, then i'll have to find out about those mutable arrays. thanks for the help!
12:12:27 <Oejet> This really small grammar gives me great troubles to parse: b ::= true | false | not b | b opb b | a opr a | (b) .
12:13:46 <Lemmih> Using parsec?
12:14:47 <ibid> Oejet: what's a?
12:15:54 <Oejet> a is aritmethic expressions.  b is boolean expressions.  opb is &, |.  opr is >,<,=.  opa is +,-,*.
12:16:06 <Oejet> Lemmih: Yes using Parsec.
12:17:24 <ibid> well, your grammar is ambiguous
12:21:23 <Lemmih> D'oh.
12:21:36 <tromp> rehi
12:21:42 * Lemmih just realized why "do { let x = 10; return 0 }" isn't valid.
12:22:01 <ibid> why?
12:22:23 <Oejet> ibid: Heh, that's not my greatest concern.  It's getting my head wrapped around Parsec to formulate the grammar.
12:22:25 <Lemmih> Because ';' is used to separate bindings in a let expression.
12:22:42 <ibid> Lemmih: ah, so you need another set of braces :)
12:22:52 <Lemmih> "do { let x = 10; y = 20 in putStrLn "hello"; return 0 }
12:22:55 <Lemmih> "
12:22:58 <ibid> Oejet: well, having a good grammar to start from might help :)
12:28:37 <Igloo> It's unambiguous as long as a can't be parenthesised isn't it?
12:28:44 <Igloo> Oejet: What have you got so far?
12:29:12 <Igloo> Oh, I don't mean unambiguous
12:29:40 <Igloo> I mean parsec will give a valid parse if you write it the natural way
12:30:15 <Igloo> Whether that's the one you wanted is a different question  :-)
12:31:35 <Oejet> http://www.student.dtu.dk/~s022018/Temporary/Parser.hs
12:32:45 <Oejet> I'm not shure how to use Parsec's expression parser with type b, since it can contain expressions of type a.
12:33:42 <Oejet> The program is runnable in GHCi.  Search for the "Try" comment.
12:39:35 <Oejet> So parsing arithmetic expressions works well.
12:43:53 <Oejet> A boolean expression, b is always b = conjunctions `chainl1` disjunction.
12:43:59 <Igloo> Only subparsers return things of type "a". This is similar to how you have subparsers returning Integers
12:45:55 <Oejet> Igloo: I need to encode precedence, and both "*" and "&" and ">" cannot be in the same precendence table in Parsec.Expr.
12:46:31 <Igloo> Ah, I don't know about such special parsec stuff
12:47:56 <Oejet> Well, thanks for your help, ibid and Igloo.  I'm progressing slowly.
12:49:50 <skew> Oejet: why can't those operators be in the same table?
12:52:34 <Oejet> table :: OperatorTable Char () BExp  cannot have operators like (op "*") :: Integer -> Integer -> AExp.
12:53:31 <skew> Are you comitted to having expressions carry their types this early?
12:54:27 <skew> If '*' is multiplication, shouldn't it take two integer expressions and join them together, like (op "*") ::  Exp Integer -> Exp Integer -> Exp Integer
12:54:42 <Oejet> skew: Ah, so that would not be a parse error, but a type error?   Well, then I would need an intermediate AST.
12:56:38 <skew> Another way to do that is to wrap up the expression types, like data Exp = Boolean BExp | Arithmetic AExp
12:56:53 <skew> then it will be runtime error.
12:57:47 <Oejet> skew: I think, I get your point now.
12:58:52 <skew> The most natural way of doing a general expression parser is to parse a list alternating between values and operators, and group them up later.
13:00:13 <Oejet> skew: Ah, and later using a stack for handling precedence.
13:01:27 <skew> Hmm, I'm considering using a GLR parser and annotating each subparse with the precedence of the tightest binding operator used within
13:01:56 <skew> and then filtering out only valid parses
13:02:10 <skew> It's only quadradic work, right?
13:02:30 <Oejet> skew: GLR means what?
13:02:43 <skew> I'm also trying to work out some nice way of handling expression parsing when the operators may want different types of arguments.
13:03:09 <Oejet> skew: For my problem or for your own?  :-)
13:03:15 <skew> I'll do typechecking later, but I'm working with C where the left hand side of an assignment needs special grammar
13:03:30 <Oejet> Ah.
13:03:32 <skew> GLR means something like generalized LR
13:03:39 <Oejet> Ok.
13:03:48 <skew> Happy supports it.
13:03:57 <earthy> skew: exactly that, in facdt
13:04:00 <earthy> -d
13:05:21 <skew> It's basically compiling a nondeterministic choice rather than whining whenever the parser generator runs into a conflict
13:05:50 <skew> And then some clever representation of the resulting DAG of possible parses that exploits sharing to the max
13:24:44 <Remi> hi
13:32:45 <skew> Oejet: how many operators and precedence levels do you have?
13:33:05 <skew> You do know the standard way of encoding precedence into a BNF grammar, right?
13:34:19 <skew> I'm thinking user-defined operators could be handled by making nonterminals or magic lexer tokens or something for each combination of precedence level * associativity, and then writing the standard encoding in terms of those nonterminals
13:39:31 <wilx> Hmm....
13:39:39 <wilx> Question...
13:39:53 <wilx> I have this tree that represents LZW dictionary.
13:40:08 <skew> actually, I think that's exactly how the Haskell Report expresses their grammar
13:40:18 <wilx> I need to update it.
13:40:55 <wilx> And I also have a context record that I use to store current state of the encoding.
13:41:33 <Oejet> skew: 10-12 operators and 8 precendence levels.  I know about introducing a variable for each precendence level e.g. factors, terms and expressions.
13:41:40 <wilx> I think I could use Control.Monad.RWS instead of STRef to record for the context.
13:42:20 <wilx> The question is can I have my tree/dictionary that I could update "in place"-like without STRef?
13:44:03 <skew> wilx: depends what you mean by in place
13:44:27 <skew> if you just mean continuing with a different tree than any simple state monad like plain State or RWS is enough
13:44:51 <skew> if you mean actually modifying the bits holding the tree directly for performance reasons or something, then you need STRef
13:46:54 <wilx> Well, I have this STRef to the root of the tree and another STRef that "points" to the current node in that tree and when I cannot go further from current node through a some letter I need to add a child node to that current node.
13:47:26 <wilx> Maybe there is a better structure for LZW dictionary but I do no know that.
13:48:11 <skew> If you are using STRef to hold the children, then there is no need keep an STRef to the current node, because a plain reference is enough...
13:48:30 <skew> What are you doing that needs to add child nodes?
13:49:16 <wilx> Err, LZW compression.
13:50:26 <skew> you have are keeping a tree of all the sequences you have seen so far?
13:52:55 <wilx> Yup, kind of.
13:53:12 <skew> are you doing something fancy about sharing?
13:54:18 <wilx> Fancy sharing? :)
13:54:43 <skew> If you have something like "abcde" and the next character is "f", don't you need to update the most recent place you've seen each of "abcdef", "bcdef", "cdef", "def", "ef", "f"
13:57:59 <wilx> Hmm, in LZW the tree/dictionary star with all symbols of your alphabet. And with each input character you walk the tree untill you cannot go further and then you add a child node from the node where you failed to go further through and you restar again from root.
13:58:42 <wilx> So it doesn't really build a dictionary of all substrings.
13:58:48 <skew> So you extend one sequece by one character each time you try to parse something?
13:58:49 <wilx> (I think...).
13:59:06 <wilx> skew, yup.
14:00:05 <skew> That's easy. Want a function in ST that returns a pure tree of the LZW dictionary for your problem?
14:02:03 <wilx> Hmm, nope, thanks though.
14:02:42 <wilx> This is my first bigger thing in Haskell so I am trying to do everything myself :)
14:05:24 <skew> Try something like this: do {count <- newSTRef 0; buildTree count}, where buildTree count = do {now <- readSTRef count; writeSTRef count (now+1); subtrees <- mapM (\c -> unsafeInterleaveST (buildTree count) >>= (c,)) ['a'..'z']; return (Node now subtrees)}
14:05:51 <skew> Don't worry, if you understand that then you already know enough Haskell :)
14:06:24 * SamB doesn't think he would understand that without layout substitution
14:07:18 <skew> Hmm, I think that needs to be in IO to be safe.
14:08:00 <skew> I don't think ST computations have the semantic leeway to magically pick the tree where the numbering just happens to be identical to the order the cells were examined during this execution...
14:08:12 <skew> but IO can do anything :)
14:08:32 <skew> SamB: it's just the same thing as the unique supply tree.
14:09:05 <skew> SamB: you know, the one that uses unsafeInterleaveIO so the cells in the tree get values as you examine them
14:09:14 <metaperl_> Cale, ping?
14:09:34 <SamB> now mind you, I likely wouldn't understand it with layout either
14:10:23 <skew> SamB: do you know what unsafeInterleaveIO means?
14:10:36 <SamB> yes
14:10:54 <SamB> at least somewhat
14:12:30 <skew> let's define postIncrement ref = do value <- readIORef ref ; writeIORef ref (value+1); return ref
14:12:38 <skew> maybe just incr
14:13:50 <skew> then define makePsychicPair = do counter <- newIORef 0; fst <- unsafeInterleaveIO (postIncrement counter); snd <- unsafeInterleaveIO (postIncrement counter); return (fst,snd)
14:16:28 <skew> now in GHCi test it out like this:
14:16:34 <skew> x <- makePsychicPair
14:16:36 <skew> fst x
14:16:43 <skew> --- prints 0
14:16:47 <skew> snd x
14:16:57 <skew> --- prints 1
14:16:58 <skew> x
14:17:02 <skew> --- prints (0,1)
14:17:13 <skew> y <- makePsychicPair
14:17:15 <skew> snd y
14:17:29 <skew> --- prints 0
14:17:33 <skew> y
14:17:37 <skew> --- prints (1,0)
14:19:39 <CosmicRay> hmm, I think you need psychicInterleaveIO :-)
14:19:58 <skew> CosmicRay: nah, actually the values are picked when you reference the object
14:20:12 <skew> remember, we've got lazy evaluation
14:21:37 <skew> And this doesn't break the purity of the language, because we're in IO
14:22:30 <skew> Denotationally the value of x and y was determined by the makePsychicPair computation
14:24:46 <Cale> metaperl: pong
14:24:59 <Cale> metaperl_: pong
14:25:22 <metaperl_> ok
14:25:24 <metaperl_> one sec
14:25:54 <metaperl_> ok Cale
14:25:54 <metaperl_> http://www.hcoop.net/~terry/haskell/MonadsAsContainers/q.txt
14:26:27 <metaperl_> this is what I did to the first few paragraphs of your tutorial. Anytime I have the slightest question about what you are saying... I write a question or rewrite it
14:26:56 <metaperl_> You know, one fact about functional programming languages is that they can't do two things at once
14:27:03 <metaperl_> one function can't do two things at once
14:27:09 <metaperl_> unlike an imperative language
14:27:19 <metaperl_> in goes the input out goes the output
14:27:55 <metaperl_> and the output is all that happened
14:28:18 <skew> metaperl_: depends what you mean by doing two things at once
14:28:32 <metaperl_> in Perl a function can alter a global and return a value
14:28:38 <skew> in goes input, out comes a pair of output and something else
14:28:39 <Cale> metaperl_: so, what exactly is the question?
14:28:49 <metaperl_> in Haskell a function must respect the "vertical line test"
14:28:57 <Cale> whether that is an accurate description?
14:29:18 <metaperl_> I was just telling you how I would rewrite that section Cale... do you agree with my rewrite? At least are there no factual errors in it?
14:29:45 <Cale> It seems correct, yes
14:30:13 <skew> metaperl_: another way to think of it is that a function in perl takes some input and then returns a value and a list of changes to make to the globals
14:31:08 <Cale> the functor is List ([]) in this case: functors are functions which act on both types and functions between them, and map is the general name for "apply the functor to this function"
14:31:27 <skew> metaperl_: or, takes a function and a list of the state of the globals, and returns an output, and a list of the new state of the globals
14:31:47 <Cale> but taking the container perspective, it is just applying the function to the things in the container, indeed
14:32:10 <metaperl_> The functor is not f though
14:32:14 <metaperl_> as you said in the tutorial
14:32:19 <Cale> the functor is []
14:32:37 <metaperl_> the function is the function which takes a function and a container consisting of a
14:32:44 <metaperl_> the functior is the function which takes a function and a container consisting of a
14:32:53 <metaperl_> is it not the container consisting of a
14:32:57 <metaperl_> as the tutorial implies
14:33:01 <SyntaxNinja> someone hit control-C on metaperl_
14:33:09 <Cale> Which takes a type to lists of that type, and functions on that type (using map) to functions on lists of that type.
14:33:36 <Cale> i.e. it takes f: a -> b to map f : [a] -> [b]
14:33:51 <skew> metaperl_: "takes a function and a container and gives a container" is written (a -> b) -> C a -> C b
14:34:08 <metaperl_> yes, I know skew
14:34:15 <skew> metaperl_: "takes a function and returns a function on containers" is written (a -> b) -> (C a -> C b)
14:34:20 <metaperl_> I was just saying that I thought that Cale's tutorial obscured what a functor was
14:34:30 <metaperl_> if you read it, you think that a functor is the container type when it is not
14:34:37 <metaperl_> http://haskell.org/hawiki/MonadsAsContainers
14:34:39 <Cale> It is the container type
14:34:51 <metaperl_> not according to foldoc
14:34:53 <Cale> The functor consists of the container type, and an implementation of map.
14:35:02 <metaperl_> http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=functor&action=Search
14:35:03 <skew> metaperl_: Ah, the first "function" should be "functor" there?
14:35:11 <metaperl_> no, a functor is a _generalization_ of map
14:35:11 <skew> in what you said?
14:35:25 <metaperl_> yes, that's why I re-sbumitted the line
14:35:37 <Cale> Well, foldoc's description is sort of odd.
14:35:43 <skew> Oh, I read functior as function again.
14:35:54 <Cale> Really, functors from category theory act on categories
14:36:13 <Cale> functors in Haskell act on the category of types and functions between them
14:36:38 <Cale> They act on the objects (types) to produce new types
14:36:57 <skew> A functor has two parts, the transformation on types, like A to [A] for list, and the transformation on functions, like map :: (a ->b) -> ([a] -> [b]), which is the other half of the list functor
14:37:00 <Cale> and they simultaneously act on the functions between those types in a nice way
14:39:08 <Cale> http://en.wikipedia.org/wiki/Functor
14:40:12 <Cale> don't worry if that melts your brain though, because this is really just justification for terminology, you don't need to know category theory to know what functors are in the context of Haskell (but it helps)
14:40:40 <skew> The category theory helps a lot.
15:05:49 <dons> moin
15:07:02 <SyntaxNinja> hiya dons
15:08:32 <boegel> hey dons
15:08:45 <boegel> @seen samc
15:08:45 <lambdabot> I saw samc leaving #haskell 6 hours 58 minutes 43 seconds ago.
15:09:41 <stepcut> SyntaxNinja: is ghc-options ignore in the cabal in ghc 6.4 ?
15:09:53 <stepcut> s,ignore,ignored,
15:13:40 <stepcut> sweet! after muching haXXoring things up, I got my wash+haskelldb app to build and run under ghc 6.4 :)
15:13:47 <stepcut> the future is wide open!
15:14:12 <boegel> stepcut: yaay !
15:17:41 <SyntaxNinja> stepcut: shouldn't be? :(
15:20:10 <Muad_Dibber> according to kosmikus  and gentoo ghc 6.4 is still in development ,right?
15:20:58 <araujo> Muad_Dibber, it is hardmasked
15:21:10 <stepcut> ghc-pkg describe rts | grep options
15:21:18 <stepcut> hugs-options:
15:21:19 <stepcut> cc-options:
15:21:19 <stepcut> ld-options: -u GHCziBase_Izh_static_info -u
15:21:25 <stepcut> but no ghc-options
15:22:00 <Muad_Dibber> indeed araujo
15:22:33 <dons> I'm guessing this comes from the package.conf, stepcut, and I don't see an yghc-options defined in rts/package.conf (?)
15:24:33 <stepcut> dons: well, it did not work for a package where I did try to define an ghc-option explicity
15:24:49 <stepcut> dons: but it seems that describe shows all possible fields, not just ones with values
15:25:20 <duncan_> Muad_Dibber: yes, 6.4 in in portage hardmasked. It breaks nigh on every package in some way or another. So lots of packages will need updating or patching before 6.4 goes into ~arch
15:25:28 <stepcut> I put this in my input file -> ghc-options: -fglasgow-exts, -fallow-overlapping-instances
15:26:54 <Muad_Dibber> well, i'll wait till it's al lfixed :)
15:27:06 <Muad_Dibber> quite busy with other non-haskell stuff atm so it doenst matter much
15:37:12 * boegel goes to bed
15:37:16 <boegel> sleep tight everyone
15:37:27 <kosmikus> Muad_Dibber: I should change the comment
15:37:51 <Muad_Dibber> g'night boegel
15:38:18 <Muad_Dibber> you should
15:38:31 <Muad_Dibber> being still in development doesnt say much :)
15:38:40 <djo> hello everybody round here
15:40:44 <Muad_Dibber> but currently eelco and martin keep me to busy with stratego to have me spend any time on haskell anyway :P
15:55:59 <djo> I have a list like ["s1","s2","s3",....,"sn"] and I want to delete all entries between a given "si" and "sj" .how can I make it ?
15:58:45 <dons> sounds like a homework question
15:59:48 <djo> nope
15:59:48 <djo> I've tried something with deleteBy whthout sucess
15:59:49 <dons> there should be something in List that helps you: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
16:00:01 <Lemmih> djo: Look at take and drop.
16:00:10 <djo> okidoki
16:01:22 <SyntaxNinja> curse you GHC's handling of mutually inclusive modules!!!1
16:03:16 <SamB> SyntaxNinja: how would YOU do it?
16:03:53 <SyntaxNinja> stepcut: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution.InstalledPackageInfo.html
16:04:00 <SyntaxNinja> that's where that stuff comes from, fwiw
16:04:12 <SamB> there are, in fact, limitations on the capacity of the human mind
16:04:31 <SyntaxNinja> SamB: the programatica people figured it out
16:05:42 <SyntaxNinja> (from what I undersatand)
16:05:50 <SamB> SyntaxNinja: feel free to implement it if you like
16:07:07 <SyntaxNinja> bah
16:07:28 <SyntaxNinja> just because I'm whining doesn't mean I need to actually contribute something useful
16:09:17 <SamB> okay, then I guess I might as well whine about how you can't use functions from the same module inside of splices
16:10:20 <SyntaxNinja> go for it
16:15:18 <SyntaxNinja> maybe I should complain now that cabal doesn't dtrt for hi-boot files either
16:15:59 <SamB> very well: I hate how you can't use functions from the same module inside of splices
16:18:36 * SyntaxNinja high-fives samb
16:19:59 <djo> what is the parse error in this line ? "buffComp = (take (i-1) buffComp)++(take (i-1) (take (j-1) buffComp))++(drop k buffComp)"
16:25:57 <Muad_Dibber> nn all
16:26:27 <djo> all the line is wrong !?
16:27:17 <SyntaxNinja> looks kinda recursive to me
16:28:00 <djo> hum I see
16:28:09 <SyntaxNinja> but that's not a parse error
16:28:28 <SyntaxNinja> what's i?
16:28:37 <SyntaxNinja> (and j and k)
16:29:15 <djo> they are index
16:29:19 <SyntaxNinja> where do they come from?
16:30:12 <djo> let i = fromJust $ elemIndex "if" buffComp
16:30:39 <djo> i,j and k are not the problem
16:30:54 <kosmikus> layout error?
16:32:07 <SyntaxNinja> djo: then the only error we can see from what you posted is that it's a loop
16:34:28 <djo> its not a loop
16:34:39 <djo> I want to concat diffrent parts of a list
16:34:58 <djo> the first part is defined by the "take (i-1) buffComp"
16:35:22 <djo> the seconde part is defined by "take (i-1) (take (j-1) buffComp)"
16:35:35 <djo> and the last one is defined by "drop k buffComp"
16:39:41 <djo> it was a partenthesis problem
16:40:58 <SyntaxNinja> but you assign the result to buffComp when buffComp is on the rhs, and I don't see a paren problem with what you posted
16:41:27 <wagle> anyone used eclipse?
16:41:51 <sh10151> wagle: I have used it on and off. It has a shoddy editor
16:42:23 <wagle> v2 or v3?
16:42:59 <wagle> i guess i'm looking for people who have looked under the hood
16:43:45 <wagle> to find out things like how tied it was to cvs (and how easy to switch over to other version control systems)
16:44:30 <sh10151> 3
16:44:46 <sh10151> it has a plugin architecture of some sort
16:44:57 <sh10151> which raises the barrier of entry for customization
16:45:16 <sh10151> I know there is an SVN plugin and I am sure there are clearcase and PVCS ones available
16:45:41 <sh10151> don't know about darcs yet :)
16:45:49 <wagle> ahh..  i was wondering first about bitkeeper, then about darcs
16:46:09 <sh10151> in theory it is customizable for any of that, but it is not nearly as easy and fun to do as e.g. emacs
16:46:30 <sh10151> when it gets a better editor and scriptability I might switch
16:47:01 <sh10151> but when I last looked at their editor scripting project mailing list it was in suspended animation
16:47:03 <wagle> the v3 editor still broken?
16:47:28 <sh10151> The java one has a lot of useless widgets
16:47:37 <sh10151> but basic editing is still broken
16:47:51 <sh10151> the indentation behavior is not good, it has no macros
16:48:09 <wagle> started poking at it last night..  the tutorials are kinda broken
16:48:34 <wagle> they do say you can use emacs or whatever, if you wants
16:48:43 <wagle> s/s$//
16:48:55 <sh10151> yeah but that just prompts me to stay in emacs
16:49:04 <sh10151> especially since I do as little java programming as possible
16:50:37 <wagle> i want something like a structure editor
16:50:49 <wagle> emacs doesnt parse programs
16:51:36 <humasect> like st browser.. whisker.. o/~
16:51:49 <wagle> my experience writing a java program in emacs was that i couldnt see what i wanted: things like "show me all the source for this method in all the classes"
16:52:07 <wagle> humasect: eh?
17:00:38 <sh10151> wagle: you mean you had an interface method with several implementing classes?
17:02:43 <sh10151> and wanted to see all the implementations?
17:02:53 <sh10151> you should be able to manage that with etags i would think
17:03:25 <sh10151> the bonus is that emacs works on haskell too :)
17:04:05 <wagle> sort of works on haskell
17:05:09 <wagle> i had a very large soup of little itty bitty methods (turned all the if statements into virtual method dispatch)
17:06:25 <sh10151> i just tried it, emacs has tags-apropos
17:06:39 <sh10151> used it to find all printStackTrace in the cocoon source :)
17:07:19 <sh10151> that is out-of-the-box behavior too, with semantic/jdee it would probably be much more buzzworthy
17:08:48 <sh10151> since tags-apropos naturally doesn't understand the difference between a method named printStackTrace on a genuine exception subclass and printStackTrace on RandomNonExceptionClassWithMethodsNamedByBozoProgrammer
17:10:54 <wagle> i had the experience that tags wouldnt find half the function definitions, since they werent in a form that the hackneyed pseudo parse would see as a definition..
17:12:14 <wagle> ultimately, i want to just use the real parser, not some weak imitation of the real crufty thing
17:12:36 <sh10151> wait
17:12:38 <sh10151> what form was that?
17:13:11 <wagle> so i want the editor to see the various stages of the compilation and present them to you in useful ways
17:13:39 <wagle> i dont remember what exactly was throwing it off, this was two years ago
17:13:46 <sh10151> k
17:13:51 <wagle> i just went back to using grep -r
17:13:56 <sh10151> :)
17:14:21 <sh10151> i am not sure that eclipse could do all that much better
17:14:29 <wagle> but now i want to start doing global visualization and analysis of large code bases
17:14:31 <sh10151> let me rephrase
17:14:33 <sh10151> it COULD
17:14:36 <sh10151> it doesn't yet
17:15:01 <sh10151> but the same could be said for emacs really, or rather emacs + cedet + beanshell
17:15:16 <wagle> yeah..  maybe i can get funding to incrementally improve eclipse..  starting over from scratch aint going to fly with funding agencies
17:16:17 <wagle> o_O
17:16:20 <sh10151> what kind of visualization would you like to do?
17:17:06 <sh10151> i am just curious, never been in the situation where visualizing more than 7 code entities at once was particularly useful to me
17:17:16 <sh10151> at least as far as graphical charts
17:17:26 <sh10151> tables, hyperlinks, browsers, sure
17:17:38 <sh10151> but not uml or er style diagrams
17:21:06 <wagle> i'd like to view the linux distribution source as a database and pose queries
17:21:47 <SamB> the *distribution* source?
17:21:48 <wagle> like to see all the intermediate forms the source takes to being compiled to object, including the object itself
17:21:52 <wagle> yes
17:22:11 <SamB> they don't generally have one big source for the whole distro...
17:22:18 <wagle> in my past life, i added security modifications to gcc and recompiled everything
17:22:28 <SamB> what do you think this is, BSD?
17:22:46 <wagle> in rh42, 50, 51, 52, 61, 73
17:22:50 <SamB> not a bad way of operating, I'm sure, but it isn't what they do in Linux land...
17:23:59 <wagle> redhat isnt terrifically self hosting, but close enough to get it to compile itself in a few weeks of head pounding
17:25:42 <wagle> want to have a role of "distribution scientist" and "distribution engineer" who takes the entire distribution, transforms the compiler, and causes distributions with varying security properties to come out the other end
17:27:04 <wagle> lots of security properties cant be seen at the source level
17:28:35 <SyntaxNinja> wagle: we're planning to do something w/ hackage so you can perform queries against the database :)
17:29:51 <wagle> oooo
17:31:15 <sh10151> why does that Hoare quote come to my head here
17:32:19 <Lemmih> The Hackage RPC interface is kinda simple but fully functional.
17:33:22 <sh10151> "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies,and the other way is to make it so complicated that there are no obvious deficiencies."
17:37:45 * Lemmih mentally pokes shapr.
17:39:06 <sh10151> 1111 seconds left
17:39:36 <wagle> date +%s --date="Thu, 17 Mar 2005 17:58:31 PST"
17:40:34 <wagle> (thats 17 minutes ffrom now)
17:40:59 <wagle> (works on linux)
17:41:09 <wagle> try it
17:43:26 <sh10151> while true; do clear; perl -e 'print time . "\n"'; sleep 1; done
17:45:16 <TheHunter> hmm, watch -n1 date +%s
17:45:47 <sh10151> what is watch?
17:46:23 <SamB> consider joining ##1111111111
17:46:27 <skew> sh10151: run a program every n seconds and show its output
17:46:42 <skew> except it doesn't like your perl thing for some reason
17:48:10 <sh10151> that's ok
17:48:18 <sh10151> i don't have watch on this machine
17:48:31 <sh10151> is it a gnu thing or what?
17:48:53 <sh10151> and thanks for date +%s, knew there was a way to get rid of perl
17:49:13 <TheHunter> it's in procps, so it's a linux thing, i guess.
17:50:23 <xerox> 423 to 1111111111 secs from Epoch :)
17:50:24 <sh10151> damn linuxcentric thinking
17:50:26 <sh10151> :)
17:51:40 <xerox> "watch --interval=1 date +%s"
17:52:41 <sh10151> steve$ which watch
17:52:41 <sh10151> no watch in /usr/local/bin /Users/steve/bin /System/Library/Frameworks/JavaVM.framework/Versions/1.4.2/bin /Developer/Java/J2EE/Ant/bin /usr/local/pgsql/bin /bin /sbin /usr/bin /usr/sbin /usr/local/teTeX/bin/powerpc-apple-darwin-current
17:52:43 <sh10151> :-P
17:53:46 <SyntaxNinja> Lemmih: but is it purely functional? ;)
17:57:52 <wagle> well that was exciting
17:58:57 <SyntaxNinja> heh
18:54:36 <metaperl> @type fmap
18:54:43 <lambdabot> fmap :: forall f b a. (Functor f) => (a -> b) -> f a -> f b
18:55:28 <metaperl> Cale, I guess that resolves things as you explained it
18:56:13 <metaperl> type restriction on f  as Functor is f such that f is the container type value constructor
18:56:41 <metaperl> so a functor is not a function which takes a function and a container of elements
18:56:56 <metaperl> it is the container type's value constructor
18:59:03 <Cale> metaperl: it is both :)
18:59:18 <metaperl> i see --- I'm continuing reading... no problems yet
19:02:56 <metaperl> further down, I have written something on return and join in the same URL: http://www.hcoop.net/~terry/haskell/MonadsAsContainers/q.txt
19:28:18 <Ruller> Hello, everybody!
19:28:51 <Lemmih> Hey Ruller.
19:37:08 <Ruller> How are you today, dear Lemmih?
19:45:58 <Ruller> I hope, you are fine
19:46:22 <Lemmih> I'm just great, thank you.
19:48:25 <Lemmih> Enjoying an episode of South Park with some alcohol in my hand.
19:48:26 <Ruller> That is good! :))
19:52:55 <Lemmih> Time to get working again.
19:53:40 <Ruller> ohh: (
19:56:22 <Lemmih> It could be much worse (: I'm currently playing around with SDL/HOpenGL.
19:56:34 <Ruller> you are cool!
19:57:42 <stepcutHM> heh, its hard to find information about css properties for tables, because all the googles hits are why css is better than tables
